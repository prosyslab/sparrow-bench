/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 211 "/usr/lib/gcc/x86_64-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned long size_t;
#line 27 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxbitset.h"
typedef unsigned long RX_subset;
#line 30 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxbitset.h"
typedef RX_subset *rx_Bitset;
#line 34 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxhash.h"
struct rx_hash;
#line 34 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxhash.h"
struct rx_hash_item {
   struct rx_hash_item *next_same_hash ;
   struct rx_hash *table ;
   unsigned long hash ;
   void *data ;
   void *binding ;
};
#line 43 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxhash.h"
struct rx_hash {
   struct rx_hash *parent ;
   int refs ;
   RX_subset nested_p ;
   void **children[16] ;
};
#line 51
struct rx_hash_rules;
#line 74 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxhash.h"
struct rx_hash_rules {
   int (*eq)(void * , void * ) ;
   struct rx_hash *(*hash_alloc)(struct rx_hash_rules * ) ;
   void (*free_hash)(struct rx_hash * , struct rx_hash_rules * ) ;
   struct rx_hash_item *(*hash_item_alloc)(struct rx_hash_rules * , void * ) ;
   void (*free_hash_item)(struct rx_hash_item * , struct rx_hash_rules * ) ;
};
#line 34 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rx.h"
struct rx;
#line 32 "/home/wslee/gnu_benchmarks/guile-1.0/rx/_rx.h"
struct rx_cache;
#line 33
struct rx_superset;
#line 35
struct rx_se_list;
#line 58
struct rx_nfa_state;
#line 58 "/home/wslee/gnu_benchmarks/guile-1.0/rx/_rx.h"
struct rx {
   int rx_id ;
   struct rx_cache *cache ;
   int local_cset_size ;
   struct rx_hash se_list_memo ;
   struct rx_hash set_list_memo ;
   void **instruction_table ;
   struct rx_nfa_state *nfa_states ;
   struct rx_nfa_state *start_nfa_states ;
   struct rx_superset *start_set ;
   int (*se_list_cmp)(struct rx * , struct rx_se_list * , struct rx_se_list * ) ;
   int next_nfa_id ;
};
#line 27 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxunfa.h"
struct rx_cached_rexp;
#line 27 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxunfa.h"
struct rx_unfaniverse {
   int delay ;
   int delayed ;
   struct rx_hash table ;
   struct rx_cached_rexp *free_queue ;
};
#line 36
struct rexp_node;
#line 36 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxunfa.h"
struct rx_unfa {
   int refs ;
   struct rexp_node *exp ;
   struct rx *nfa ;
   int cset_size ;
   struct rx_unfaniverse *verse ;
};
#line 45 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxunfa.h"
struct rx_cached_rexp {
   struct rx_unfa unfa ;
   struct rx_cached_rexp *next ;
   struct rx_cached_rexp *prev ;
   struct rx_hash_item *hash_item ;
};
#line 35 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnode.h"
enum rexp_node_type {
    r_cset = 0,
    r_concat = 1,
    r_alternate = 2,
    r_opt = 3,
    r_star = 4,
    r_plus = 5,
    r_string = 6,
    r_cut = 7,
    r_interval = 8,
    r_parens = 9,
    r_context = 10
} ;
#line 57 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnode.h"
struct rx_string {
   unsigned long len ;
   unsigned long reallen ;
   unsigned char *contents ;
};
#line 64 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnode.h"
struct __anonstruct_pair_19 {
   struct rexp_node *left ;
   struct rexp_node *right ;
};
#line 64 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnode.h"
struct __anonstruct_params_18 {
   int cset_size ;
   rx_Bitset cset ;
   int intval ;
   int intval2 ;
   struct __anonstruct_pair_19 pair ;
   struct rx_string cstr ;
};
#line 64 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnode.h"
struct rexp_node {
   int refs ;
   enum rexp_node_type type ;
   struct __anonstruct_params_18 params ;
   int id ;
   int len ;
   int observed ;
   struct rexp_node *simplified ;
   struct rx_cached_rexp *cr ;
};
#line 39 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnfa.h"
struct rx_nfa_edge;
#line 39
struct rx_possible_future;
#line 39 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnfa.h"
struct rx_nfa_state {
   struct rx_nfa_state *next ;
   int id ;
   struct rx_nfa_edge *edges ;
   struct rx_possible_future *futures ;
   int futures_computed : 1 ;
   unsigned int is_start : 1 ;
   int has_cset_edges : 1 ;
   int is_final ;
   unsigned int eclosure_needed : 1 ;
   unsigned int mark : 1 ;
};
#line 138
enum rx_nfa_etype {
    ne_cset = 0,
    ne_epsilon = 1,
    ne_side_effect = 2
} ;
#line 157 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnfa.h"
union __anonunion_params_20 {
   rx_Bitset cset ;
   void *side_effect ;
};
#line 157 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnfa.h"
struct rx_nfa_edge {
   struct rx_nfa_edge *next ;
   enum rx_nfa_etype type ;
   struct rx_nfa_state *dest ;
   union __anonunion_params_20 params ;
};
#line 178 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnfa.h"
struct rx_nfa_state_set {
   struct rx_nfa_state *car ;
   struct rx_nfa_state_set *cdr ;
};
#line 184 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnfa.h"
struct rx_se_list {
   void *car ;
   struct rx_se_list *cdr ;
};
#line 190 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnfa.h"
struct rx_possible_future {
   struct rx_possible_future *next ;
   struct rx_se_list *effects ;
   struct rx_nfa_state_set *destset ;
};
#line 197 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxsuper.h"
struct rx_inx {
   void *data ;
   void *data_2 ;
   void *inx ;
   void *fnord ;
};
#line 213
struct rx_superstate;
#line 213 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxsuper.h"
struct rx_superset {
   int refs ;
   int id ;
   struct rx_nfa_state *car ;
   struct rx_superset *cdr ;
   struct rx_superstate *superstate ;
   int is_final ;
   int has_cset_edges ;
   struct rx *starts_for ;
   struct rx_hash_item hash_item ;
};
#line 272
struct rx_distinct_future;
#line 272 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxsuper.h"
struct rx_super_edge {
   struct rx_super_edge *next ;
   struct rx_inx rx_backtrack_frame ;
   int cset_size ;
   rx_Bitset cset ;
   struct rx_distinct_future *options ;
};
#line 286 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxsuper.h"
struct rx_superstate {
   int rx_id ;
   int locks ;
   struct rx_superstate *next_recyclable ;
   struct rx_superstate *prev_recyclable ;
   struct rx_distinct_future *transition_refs ;
   struct rx_superset *contents ;
   struct rx_super_edge *edges ;
   int is_semifree ;
   int trans_size ;
   struct rx_inx transitions[1] ;
};
#line 345 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxsuper.h"
struct rx_distinct_future {
   struct rx_distinct_future *next_same_super_edge[2] ;
   struct rx_distinct_future *next_same_dest ;
   struct rx_distinct_future *prev_same_dest ;
   struct rx_superstate *present ;
   struct rx_superstate *future ;
   struct rx_super_edge *edge ;
   struct rx_inx future_frame ;
   struct rx_inx side_effects_frame ;
   struct rx_se_list *effects ;
};
#line 386 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxsuper.h"
struct rx_cache {
   struct rx_hash_rules superset_hash_rules ;
   struct rx_superstate *lru_superstate ;
   struct rx_superstate *semifree_superstate ;
   struct rx_superset *empty_superset ;
   int superstates ;
   int semifree_superstates ;
   int hits ;
   int misses ;
   int bytes_allowed ;
   int bytes_used ;
   int local_cset_size ;
   void **instruction_table ;
   struct rx_hash superset_table ;
};
#line 32 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxanal.h"
enum rx_answers {
    rx_yes = 0,
    rx_no = 1,
    rx_bogus = -1,
    rx_start_state_with_too_many_futures = -2
} ;
#line 42 "/home/wslee/gnu_benchmarks/guile-1.0/rx/inst-rxposix.h"
typedef int regoff_t;
#line 44 "/home/wslee/gnu_benchmarks/guile-1.0/rx/inst-rxposix.h"
struct rx_registers {
   regoff_t rm_so ;
   regoff_t rm_eo ;
   regoff_t final_tag ;
};
#line 25 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxcontext.h"
struct rx_context_rules {
   unsigned int newline_anchor : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int case_indep : 1 ;
};
#line 33 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxstr.h"
struct rx_str_closure {
   struct rx_context_rules rules ;
   unsigned char const   *str ;
   int len ;
};
#line 41 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxanal.h"
struct rx_classical_system {
   struct rx *rx ;
   struct rx_superstate *state ;
   int final_tag ;
};
#line 46 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxspencer.h"
struct rx_solutions {
   int step ;
   int cset_size ;
   struct rexp_node *exp ;
   struct rexp_node **subexps ;
   struct rx_registers *regs ;
   int start ;
   int end ;
   enum rx_answers (*vmfn)(void *closure , unsigned char const   **burst , int *len ,
                           int *offset , int start , int end , int need ) ;
   enum rx_answers (*contextfn)(void *closure , struct rexp_node *node , int start ,
                                int end , struct rx_registers *regs ) ;
   void *closure ;
   int current_pos ;
   struct rx_unfaniverse *verse ;
   struct rx_unfa *dfa ;
   struct rx_classical_system match_engine ;
   int split_guess ;
   struct rx_solutions *left ;
   struct rx_solutions *right ;
   int interval_x ;
   int final_tag ;
};
#line 25 "/home/wslee/gnu_benchmarks/guile-1.0/rx/inst-rxposix.h"
struct rx_posix_regex {
   struct rexp_node *pattern ;
   struct rexp_node **subexps ;
   size_t n_subexps ;
   unsigned char *translate ;
   unsigned int newline_anchor : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int is_anchored : 1 ;
   unsigned int is_nullable : 1 ;
   unsigned char fastmap[256] ;
   void *owner_data ;
};
#line 39 "/home/wslee/gnu_benchmarks/guile-1.0/rx/inst-rxposix.h"
typedef struct rx_posix_regex regex_t;
#line 44 "/home/wslee/gnu_benchmarks/guile-1.0/rx/inst-rxposix.h"
typedef struct rx_registers regmatch_t;
#line 40 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxgnucomp.h"
enum __anonenum_reg_errcode_t_21 {
    REG_NOERROR = 0,
    REG_NOMATCH = 1,
    REG_BADPAT = 2,
    REG_ECOLLATE = 3,
    REG_ECTYPE = 4,
    REG_EESCAPE = 5,
    REG_ESUBREG = 6,
    REG_EBRACK = 7,
    REG_EPAREN = 8,
    REG_EBRACE = 9,
    REG_BADBR = 10,
    REG_ERANGE = 11,
    REG_ESPACE = 12,
    REG_BADRPT = 13,
    REG_EEND = 14,
    REG_ESIZE = 15,
    REG_ERPAREN = 16
} ;
#line 40 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxgnucomp.h"
typedef enum __anonenum_reg_errcode_t_21 reg_errcode_t;
#line 660 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnfa.c"
struct eclose_frame {
   struct rx_se_list *prog_backwards ;
};
#line 131 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxgnucomp.c"
typedef int regnum_t;
#line 136 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxgnucomp.c"
typedef int pattern_offset_t;
#line 138 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxgnucomp.c"
struct __anonstruct_compile_stack_elt_t_21 {
   struct rexp_node **top_expression ;
   struct rexp_node **last_expression ;
   struct rexp_node **last_non_regular_expression ;
   pattern_offset_t inner_group_offset ;
   regnum_t regnum ;
};
#line 138 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxgnucomp.c"
typedef struct __anonstruct_compile_stack_elt_t_21 compile_stack_elt_t;
#line 147 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxgnucomp.c"
struct __anonstruct_compile_stack_type_22 {
   compile_stack_elt_t *stack ;
   unsigned int size ;
   unsigned int avail ;
};
#line 147 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxgnucomp.c"
typedef struct __anonstruct_compile_stack_type_22 compile_stack_type;
#line 55 "./../libguile/tags.h"
typedef long SCM;
#line 71 "./../libguile/print.h"
struct scm_print_state {
   SCM handle ;
   unsigned long writingp ;
   unsigned long fancyp ;
   unsigned long level ;
   unsigned long length ;
   SCM hot_ref ;
   unsigned long list_offset ;
   unsigned long top ;
   unsigned long ceiling ;
   SCM *ref_stack ;
   SCM ref_vect ;
};
#line 71 "./../libguile/print.h"
typedef struct scm_print_state scm_print_state;
#line 51 "./../libguile/pairs.h"
struct scm_cell {
   SCM car ;
   SCM cdr ;
};
#line 51 "./../libguile/pairs.h"
typedef struct scm_cell scm_cell;
#line 58 "./../libguile/ports.h"
enum scm_string_representation_type {
    scm_regular_string = 0,
    scm_mb_string = 1,
    scm_wchar_string = 2
} ;
#line 49 "./../libguile/smob.h"
struct scm_smobfuns {
   SCM (*mark)(SCM  ) ;
   size_t (*free)(SCM  ) ;
   int (*print)(SCM exp , SCM port , scm_print_state *pstate ) ;
   SCM (*equalp)(SCM  , SCM  ) ;
};
#line 49 "./../libguile/smob.h"
typedef struct scm_smobfuns scm_smobfuns;
#line 435 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rgx.c"
struct rx_dfa_state {
   struct rx_classical_system frame ;
   struct rx_unfa *unfa ;
};
#line 51 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.h"
enum scm_port_representation_type {
    scm_regular_port = 0,
    scm_mb_port = 1,
    scm_wchar_port = 2
} ;
#line 66 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.h"
struct scm_port_table {
   SCM port ;
   int revealed ;
   SCM stream ;
   SCM file_name ;
   int unchr ;
   int line_number ;
   int column_number ;
   enum scm_port_representation_type representation ;
};
#line 139 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.h"
struct scm_ptobfuns {
   SCM (*mark)(SCM  ) ;
   int (*free)(SCM  ) ;
   int (*print)(SCM exp , SCM port , scm_print_state *pstate ) ;
   SCM (*equalp)(SCM  , SCM  ) ;
   int (*fputc)(int  , SCM stream ) ;
   int (*fputs)(char * , SCM stream ) ;
   size_t (*fwrite)(char *ptr , size_t size , size_t nitems , SCM stream ) ;
   int (*fflush)(SCM stream ) ;
   int (*fgetc)(SCM stream ) ;
   int (*fclose)(SCM stream ) ;
};
#line 139 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.h"
typedef struct scm_ptobfuns scm_ptobfuns;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef long __off64_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 29 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_9 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 29 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_9 __sigset_t;
#line 32 "/usr/include/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 35 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 49 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag jmp_buf[1];
#line 241 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/__scm.h"
typedef long SCM_STACKITEM;
#line 218 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.h"
struct scm_dbl {
   SCM type ;
   double *real ;
};
#line 218 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.h"
typedef struct scm_dbl scm_dbl;
#line 114 "../libguile/debug.h"
struct __anonstruct_e_22 {
   SCM exp ;
   SCM env ;
};
#line 114 "../libguile/debug.h"
struct __anonstruct_a_23 {
   SCM proc ;
   SCM args ;
};
#line 114 "../libguile/debug.h"
union scm_debug_info {
   struct __anonstruct_e_22 e ;
   struct __anonstruct_a_23 a ;
   SCM id ;
};
#line 114 "../libguile/debug.h"
typedef union scm_debug_info scm_debug_info;
#line 123 "../libguile/debug.h"
struct scm_debug_frame {
   struct scm_debug_frame *prev ;
   long status ;
   scm_debug_info *vect ;
   scm_debug_info *info ;
};
#line 123 "../libguile/debug.h"
typedef struct scm_debug_frame scm_debug_frame;
#line 87 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/root.h"
struct scm_root_state {
   SCM_STACKITEM *stack_base ;
   jmp_buf save_regs_gc_mark ;
   int errjmp_bad ;
   SCM rootcont ;
   SCM dynwinds ;
   SCM continuation_stack ;
   SCM continuation_stack_ptr ;
   scm_debug_frame *last_debug_frame ;
   SCM progargs ;
   SCM exitval ;
   SCM cur_inp ;
   SCM cur_outp ;
   SCM cur_errp ;
   SCM def_inp ;
   SCM def_outp ;
   SCM def_errp ;
   SCM system_transformer ;
   SCM top_level_lookup_closure_var ;
   SCM handle ;
   SCM parent ;
};
#line 50 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.h"
struct scm_array {
   SCM v ;
   size_t base ;
};
#line 50 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.h"
typedef struct scm_array scm_array;
#line 56 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.h"
struct scm_array_dim {
   long lbnd ;
   long ubnd ;
   long inc ;
};
#line 56 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.h"
typedef struct scm_array_dim scm_array_dim;
#line 54 "../libguile/options.h"
struct scm_option {
   int type ;
   char *name ;
   unsigned long val ;
   char *doc ;
};
#line 54 "../libguile/options.h"
typedef struct scm_option scm_option;
#line 50 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/continuations.h"
struct __anonstruct_scm_contregs_24 {
   SCM throw_value ;
   jmp_buf jmpbuf ;
   SCM dynenv ;
   SCM_STACKITEM *base ;
   unsigned long seq ;
   struct scm_debug_frame *dframe ;
};
#line 50 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/continuations.h"
typedef struct __anonstruct_scm_contregs_24 scm_contregs;
#line 63 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/throw.h"
struct scm_body_thunk_data {
   SCM tag ;
   SCM body_proc ;
};
#line 134 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/throw.c"
struct jmp_buf_and_retval {
   jmp_buf buf ;
   SCM throw_tag ;
   SCM retval ;
};
#line 145 "/usr/include/bits/types.h"
typedef long __clock_t;
#line 149 "/usr/include/bits/types.h"
typedef long __time_t;
#line 76 "/usr/include/time.h"
typedef __time_t time_t;
#line 60 "/usr/include/time.h"
typedef __clock_t clock_t;
#line 35 "/usr/include/sys/times.h"
struct tms {
   clock_t tms_utime ;
   clock_t tms_stime ;
   clock_t tms_cutime ;
   clock_t tms_cstime ;
};
#line 32 "/usr/include/sys/timeb.h"
struct timeb {
   time_t time ;
   unsigned short millitm ;
   short timezone ;
   short dstflag ;
};
#line 55 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.h"
struct scm_info_frame {
   SCM flags ;
   SCM source ;
   SCM proc ;
   SCM args ;
};
#line 55 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.h"
typedef struct scm_info_frame scm_info_frame;
#line 65 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.h"
struct scm_stack {
   SCM id ;
   scm_info_frame *frames ;
   unsigned int length ;
   unsigned int tail_length ;
   scm_info_frame tail[1] ;
};
#line 65 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.h"
typedef struct scm_stack scm_stack;
#line 80 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/srcprop.h"
struct scm_srcprops {
   unsigned long pos ;
   SCM fname ;
   SCM copy ;
   SCM plist ;
};
#line 80 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/srcprop.h"
typedef struct scm_srcprops scm_srcprops;
#line 89 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/srcprop.h"
struct scm_srcprops_chunk {
   struct scm_srcprops_chunk *next ;
   scm_srcprops srcprops[1] ;
};
#line 89 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/srcprop.h"
typedef struct scm_srcprops_chunk scm_srcprops_chunk;
#line 180 "/usr/include/bits/types.h"
typedef long __ssize_t;
#line 192 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 275 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 174 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 400 "/usr/include/bits/socket.h"
struct linger {
   int l_onoff ;
   int l_linger ;
};
#line 30 "/usr/include/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 97 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 141 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 142 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 225 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 143 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 84 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 87 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/root.h"
typedef struct scm_root_state scm_root_state;
#line 188 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/root.c"
struct cwdr_body_data {
   SCM a1 ;
   SCM args ;
   SCM body_proc ;
};
#line 330 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/root.c"
typedef long setjmp_type;
#line 63 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/extchrs.h"
typedef unsigned short xwchar_t;
#line 55 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/procs.h"
struct scm_subr {
   long sname ;
   SCM (*cproc)() ;
};
#line 55 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/procs.h"
typedef struct scm_subr scm_subr;
#line 67 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/procs.h"
struct scm_dsubr {
   long sname ;
   double (*dproc)() ;
};
#line 67 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/procs.h"
typedef struct scm_dsubr scm_dsubr;
#line 60 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
struct __anonstruct_ra_iproc_24 {
   char *name ;
   SCM sproc ;
   int (*vproc)() ;
};
#line 60 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
typedef struct __anonstruct_ra_iproc_24 ra_iproc;
#line 64 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/pairs.h"
typedef scm_cell *SCM_CELLPTR;
#line 61 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/procs.h"
struct scm_iproc {
   char *scm_string ;
   SCM (*cproc)() ;
};
#line 61 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/procs.h"
typedef struct scm_iproc scm_iproc;
#line 134 "/usr/include/bits/types.h"
typedef unsigned long __dev_t;
#line 135 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 136 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 67 "/usr/include/sys/types.h"
typedef __gid_t gid_t;
#line 100 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 50 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 43 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 49 "/usr/include/sys/utsname.h"
struct utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char __domainname[65] ;
};
#line 38 "/usr/include/utime.h"
struct utimbuf {
   __time_t actime ;
   __time_t modtime ;
};
#line 893 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
union __anonunion_p_26 {
   long l ;
   unsigned short bd[((sizeof(long ) * 8UL + sizeof(unsigned short ) * 8UL) - 1UL) / (sizeof(unsigned short ) * 8UL)] ;
};
#line 3123 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
struct dpair {
   double x ;
   double y ;
};
#line 27 "/usr/include/bits/netdb.h"
struct netent {
   char *n_name ;
   char **n_aliases ;
   int n_addrtype ;
   uint32_t n_net ;
};
#line 99 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 256 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 326 "/usr/include/netdb.h"
struct protoent {
   char *p_name ;
   char **p_aliases ;
   int p_proto ;
};
#line 137 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned long __nlink_t;
#line 164 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 169 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 43 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   long __unused[3] ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.4.3/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 102 "/usr/lib/gcc/x86_64-linux-gnu/4.4.3/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 265 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/init.c"
struct main_func_closure {
   void (*main_func)(void *closure , int argc , char **argv ) ;
   void *closure ;
   int argc ;
   char **argv ;
};
#line 377 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
struct scm_ihashx_closure {
   SCM hash ;
   SCM assoc ;
   SCM delete ;
};
#line 53 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.h"
struct scm_heap_seg_data;
#line 194 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
struct scm_heap_seg_data {
   SCM_CELLPTR bounds[2] ;
   SCM *freelistp ;
   int ncells ;
   int (*valid)() ;
};
#line 151 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 72 "/usr/include/sys/types.h"
typedef __mode_t mode_t;
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_6 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 67 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_6 fd_set;
#line 23 "/usr/include/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 128 "/usr/include/dirent.h"
struct __dirstream;
#line 128 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 1311 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
union __anonunion_t_25 {
   SCM *lloc ;
   SCM arg1 ;
};
#line 1311 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
union __anonunion_t_26 {
   SCM *lloc ;
   SCM arg1 ;
};
#line 105 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
struct scm_async {
   int got_it ;
   SCM thunk ;
};
#line 78 "/home/wslee/gnu_benchmarks/guile-1.0/guile/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 488
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 89 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxhash.h"
struct rx_hash_item *rx_hash_store(struct rx_hash *table , unsigned long hash , void *value ,
                                   struct rx_hash_rules *rules ) ;
#line 93
void rx_hash_free(struct rx_hash_item *it , struct rx_hash_rules *rules ) ;
#line 34 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rx.h"
struct rx *rx_make_rx(int cset_size ) ;
#line 35
void rx_free_rx(struct rx *rx ) ;
#line 36
void rx_bzero(char *mem , int size ) ;
#line 56 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxunfa.h"
struct rx_unfaniverse *rx_make_unfaniverse(int delay ) ;
#line 57
void rx_free_unfaniverse(struct rx_unfaniverse *it ) ;
#line 58
struct rx_unfa *rx_unfa(struct rx_unfaniverse *unfaniverse , struct rexp_node *exp___0 ,
                        int cset_size ) ;
#line 59
void rx_free_unfa(struct rx_unfa *unfa ) ;
#line 60
void rx_save_unfa(struct rx_unfa *unfa ) ;
#line 98 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnode.h"
void rx_free_rexp(struct rexp_node *node ) ;
#line 99
void rx_save_rexp(struct rexp_node *node ) ;
#line 102
int rx_rexp_equal(struct rexp_node *a , struct rexp_node *b ) ;
#line 103
unsigned long rx_rexp_hash(struct rexp_node *node , unsigned long seed ) ;
#line 206 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnfa.h"
int rx_build_nfa(struct rx *rx , struct rexp_node *rexp , struct rx_nfa_state **start ,
                 struct rx_nfa_state **end ) ;
#line 30 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxunfa.c"
static int unfa_equal(void *va , void *vb ) 
{ 
  int tmp ;

  {
  {
#line 39
  tmp = rx_rexp_equal((struct rexp_node *)va, (struct rexp_node *)vb);
  }
#line 39
  return (tmp);
}
}
#line 43 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxunfa.c"
struct rx_hash_rules unfa_rules  =    {& unfa_equal, (struct rx_hash *(*)(struct rx_hash_rules * ))0, (void (*)(struct rx_hash * ,
                                                                             struct rx_hash_rules * ))0,
    (struct rx_hash_item *(*)(struct rx_hash_rules * , void * ))0, (void (*)(struct rx_hash_item * ,
                                                                             struct rx_hash_rules * ))0};
#line 47 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxunfa.c"
static struct rx_cached_rexp *canonical_unfa(struct rx_hash *table , struct rexp_node *rexp ,
                                             int cset_size ) 
{ 
  struct rx_hash_item *it ;
  unsigned long tmp ;
  struct rx_cached_rexp *cr ;
  void *tmp___0 ;
  void *__cil_tmp8 ;

  {
  {
#line 58
  tmp = rx_rexp_hash(rexp, 0UL);
#line 58
  it = rx_hash_store(table, tmp, (void *)rexp, & unfa_rules);
  }
#line 60
  if ((unsigned long )it->binding == (unsigned long )((void *)0)) {
#line 64
    if ((unsigned long )it->data == (unsigned long )((void *)rexp)) {
      {
#line 65
      rx_save_rexp(rexp);
      }
    }
    {
#line 67
    tmp___0 = malloc(sizeof(*cr));
#line 67
    cr = (struct rx_cached_rexp *)tmp___0;
#line 68
    rx_bzero((char *)cr, (int )sizeof(*cr));
    }
#line 69
    if (! cr) {
#line 70
      return ((struct rx_cached_rexp *)0);
    }
    {
#line 71
    it->binding = (void *)cr;
#line 72
    cr->unfa.nfa = (struct rx *)0;
#line 73
    cr->unfa.exp = rexp;
#line 74
    cr->hash_item = it;
#line 75
    rx_save_rexp(rexp);
    }
  }
#line 77
  return ((struct rx_cached_rexp *)it->binding);
}
}
#line 82 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxunfa.c"
static struct rx *rx_unfa_rx(struct rx_cached_rexp *cr , struct rexp_node *exp___0 ,
                             int cset_size ) 
{ 
  struct rx *new_rx ;
  struct rx_nfa_state *start ;
  struct rx_nfa_state *end ;
  int tmp ;
  struct rx_nfa_state *s___0 ;
  int x ;
  int tmp___0 ;

  {
#line 94
  if (cr->unfa.nfa) {
#line 95
    return (cr->unfa.nfa);
  }
  {
#line 97
  new_rx = rx_make_rx(cset_size);
  }
#line 98
  if (! new_rx) {
#line 99
    return ((struct rx *)0);
  }
  {
#line 103
  end = (struct rx_nfa_state *)0;
#line 103
  start = end;
#line 104
  tmp = rx_build_nfa(new_rx, exp___0, & start, & end);
  }
#line 104
  if (! tmp) {
    {
#line 106
    free((void *)new_rx);
    }
#line 107
    return ((struct rx *)0);
  }
#line 109
  new_rx->start_nfa_states = start;
#line 110
  end->is_final = 1;
#line 111
  start->is_start = 1U;
#line 115
  x = 0;
#line 116
  s___0 = new_rx->nfa_states;
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! s___0) {
#line 116
      goto while_break;
    }
#line 117
    tmp___0 = x;
#line 117
    x ++;
#line 117
    s___0->id = tmp___0;
#line 116
    s___0 = s___0->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  cr->unfa.nfa = new_rx;
#line 121
  return (new_rx);
}
}
#line 128 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxunfa.c"
struct rx_unfaniverse *rx_make_unfaniverse(int delay ) 
{ 
  struct rx_unfaniverse *it ;
  void *tmp ;
  void *__cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 137
  tmp = malloc(sizeof(*it));
#line 137
  it = (struct rx_unfaniverse *)tmp;
  }
#line 138
  if (! it) {
#line 138
    return ((struct rx_unfaniverse *)0);
  }
  {
#line 139
  rx_bzero((char *)it, (int )sizeof(*it));
#line 140
  it->delay = delay;
  }
#line 141
  return (it);
}
}
#line 146 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxunfa.c"
void rx_free_unfaniverse(struct rx_unfaniverse *it ) 
{ 


  {
#line 154
  return;
}
}
#line 161 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxunfa.c"
struct rx_unfa *rx_unfa(struct rx_unfaniverse *unfaniverse , struct rexp_node *exp___0 ,
                        int cset_size ) 
{ 
  struct rx_cached_rexp *cr ;

  {
#line 172
  if (exp___0) {
#line 172
    if (exp___0->cr) {
#line 173
      cr = exp___0->cr;
    } else {
#line 172
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 176
    cr = canonical_unfa(& unfaniverse->table, exp___0, cset_size);
    }
#line 177
    if (exp___0) {
#line 178
      exp___0->cr = cr;
    }
  }
#line 180
  if (! cr) {
#line 181
    return ((struct rx_unfa *)0);
  }
#line 182
  if (cr->next) {
#line 184
    if ((unsigned long )unfaniverse->free_queue == (unsigned long )cr) {
#line 186
      unfaniverse->free_queue = cr->next;
#line 187
      if ((unsigned long )unfaniverse->free_queue == (unsigned long )cr) {
#line 188
        unfaniverse->free_queue = (struct rx_cached_rexp *)0;
      }
    }
#line 190
    (cr->next)->prev = cr->prev;
#line 191
    (cr->prev)->next = cr->next;
#line 192
    cr->next = (struct rx_cached_rexp *)0;
#line 193
    cr->prev = (struct rx_cached_rexp *)0;
#line 194
    (unfaniverse->delayed) --;
  }
  {
#line 196
  (cr->unfa.refs) ++;
#line 197
  cr->unfa.cset_size = cset_size;
#line 198
  cr->unfa.verse = unfaniverse;
#line 199
  rx_unfa_rx(cr, exp___0, cset_size);
  }
#line 200
  return (& cr->unfa);
}
}
#line 205 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxunfa.c"
void rx_free_unfa(struct rx_unfa *unfa ) 
{ 
  struct rx_cached_rexp *cr ;
  struct rx_cached_rexp *tmp ;
  struct rx_cached_rexp *it ;

  {
#line 215
  cr = (struct rx_cached_rexp *)unfa;
#line 216
  if (! cr) {
#line 217
    return;
  }
#line 218
  (cr->unfa.refs) --;
#line 218
  if (cr->unfa.refs) {
#line 255
    return;
  } else {
#line 220
    if (! (unfa->verse)->free_queue) {
#line 222
      (unfa->verse)->free_queue = cr;
#line 223
      tmp = cr;
#line 223
      cr->prev = tmp;
#line 223
      cr->next = tmp;
    } else {
#line 227
      cr->next = (unfa->verse)->free_queue;
#line 228
      cr->prev = ((unfa->verse)->free_queue)->prev;
#line 229
      (cr->next)->prev = cr;
#line 230
      (cr->prev)->next = cr;
    }
#line 233
    ((unfa->verse)->delayed) ++;
    {
#line 234
    while (1) {
      while_continue: /* CIL Label */ ;
#line 234
      if (! ((unfa->verse)->delayed > (unfa->verse)->delay)) {
#line 234
        goto while_break;
      }
#line 237
      it = (unfa->verse)->free_queue;
#line 238
      (unfa->verse)->free_queue = it->next;
#line 239
      ((unfa->verse)->delayed) --;
#line 239
      if (! (unfa->verse)->delayed) {
#line 240
        (unfa->verse)->free_queue = (struct rx_cached_rexp *)0;
      }
#line 241
      (it->prev)->next = it->next;
#line 242
      (it->next)->prev = it->prev;
#line 243
      if (it->unfa.exp) {
#line 244
        (it->unfa.exp)->cr = (struct rx_cached_rexp *)0;
      }
      {
#line 245
      rx_free_rexp((struct rexp_node *)(it->hash_item)->data);
#line 246
      rx_hash_free(it->hash_item, & unfa_rules);
#line 247
      rx_free_rx(it->unfa.nfa);
#line 248
      rx_free_rexp(it->unfa.exp);
#line 249
      free((void *)it);
      }
#line 250
      if ((unsigned long )it == (unsigned long )cr) {
#line 251
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 256
  return;
}
}
#line 260 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxunfa.c"
void rx_save_unfa(struct rx_unfa *unfa ) 
{ 


  {
#line 268
  (unfa->refs) ++;
#line 269
  return;
}
}
#line 67 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxbitset.h"
RX_subset rx_subset_singletons[8UL * sizeof(RX_subset )] ;
#line 73
int rx_bitset_is_subset(int size , rx_Bitset a , rx_Bitset b ) ;
#line 76
void rx_bitset_universe(int size , rx_Bitset b ) ;
#line 78
void rx_bitset_assign(int size , rx_Bitset a , rx_Bitset b ) ;
#line 80
void rx_bitset_intersection(int size , rx_Bitset a , rx_Bitset b ) ;
#line 82
void rx_bitset_difference(int size , rx_Bitset a , rx_Bitset b ) ;
#line 165 "/home/wslee/gnu_benchmarks/guile-1.0/rx/_rx.h"
void *rx_id_instruction_table[6] ;
#line 166
struct rx_cache *rx_default_cache ;
#line 210 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnfa.h"
struct rx_possible_future *rx_state_possible_futures(struct rx *rx , struct rx_nfa_state *n ) ;
#line 413 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxsuper.h"
char *rx_cache_malloc(struct rx_cache *cache , int size ) ;
#line 414
void rx_cache_free(struct rx_cache *cache , int size , char *mem ) ;
#line 415
void rx_release_superset(struct rx *rx , struct rx_superset *set ) ;
#line 417
struct rx_superset *rx_superset_cons(struct rx *rx , struct rx_nfa_state *car , struct rx_superset *cdr ) ;
#line 419
struct rx_superset *rx_superstate_eclosure_union(struct rx *rx , struct rx_superset *set ,
                                                 struct rx_nfa_state_set *ecl ) ;
#line 420
struct rx_superstate *rx_superstate(struct rx *rx , struct rx_superset *set ) ;
#line 422
struct rx_inx *rx_handle_cache_miss(struct rx *rx , struct rx_superstate *super ,
                                    unsigned char chr , void *data ) ;
#line 41 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxsuper.c"
void *rx_id_instruction_table[6]  = {      (void *)0,      (void *)1,      (void *)2,      (void *)3, 
        (void *)4,      (void *)5};
#line 59 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxsuper.c"
static void install_transition(struct rx_superstate *super , struct rx_inx *answer ,
                               rx_Bitset trcset ) 
{ 
  struct rx_inx *transitions ;
  int chr ;
  RX_subset sub ;
  RX_subset mask ;
  int bound ;

  {
#line 70
  transitions = super->transitions;
#line 72
  chr = 0;
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
#line 72
    if (! (chr < 256)) {
#line 72
      goto while_break;
    }
#line 73
    if (! *trcset) {
#line 75
      trcset ++;
#line 76
      chr += 32;
    } else {
#line 80
      sub = *trcset;
#line 81
      mask = (RX_subset )1;
#line 82
      bound = chr + 32;
      {
#line 83
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 83
        if (! (chr < bound)) {
#line 83
          goto while_break___0;
        }
#line 85
        if (sub & mask) {
#line 86
          *(transitions + chr) = *answer;
        }
#line 87
        chr ++;
#line 88
        mask <<= 1;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 90
      trcset ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  return;
}
}
#line 131 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxsuper.c"
char *rx_cache_malloc(struct rx_cache *cache , int size ) 
{ 
  char *answer ;
  void *tmp ;

  {
  {
#line 141
  tmp = malloc((size_t )size);
#line 141
  answer = (char *)tmp;
  }
#line 142
  if (answer) {
#line 143
    cache->bytes_used += size;
  }
#line 144
  return (answer);
}
}
#line 149 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxsuper.c"
void rx_cache_free(struct rx_cache *cache , int size , char *mem ) 
{ 


  {
  {
#line 159
  free((void *)mem);
#line 160
  cache->bytes_used -= size;
  }
#line 161
  return;
}
}
#line 184 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxsuper.c"
static void semifree_superstate(struct rx_cache *cache ) 
{ 
  int disqualified ;
  struct rx_superstate *it ;
  struct rx_distinct_future *df ;

  {
#line 192
  disqualified = cache->semifree_superstates;
#line 193
  if (disqualified == cache->superstates) {
#line 194
    return;
  }
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 195
    if (! (cache->lru_superstate)->locks) {
#line 195
      goto while_break;
    }
#line 197
    cache->lru_superstate = (cache->lru_superstate)->next_recyclable;
#line 198
    disqualified ++;
#line 199
    if (disqualified == cache->superstates) {
#line 200
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 203
  it = cache->lru_superstate;
#line 204
  (it->next_recyclable)->prev_recyclable = it->prev_recyclable;
#line 205
  (it->prev_recyclable)->next_recyclable = it->next_recyclable;
#line 206
  if ((unsigned long )it == (unsigned long )it->next_recyclable) {
#line 206
    cache->lru_superstate = (struct rx_superstate *)0;
  } else {
#line 206
    cache->lru_superstate = it->next_recyclable;
  }
#line 209
  if (! cache->semifree_superstate) {
#line 211
    cache->semifree_superstate = it;
#line 212
    it->next_recyclable = it;
#line 213
    it->prev_recyclable = it;
  } else {
#line 217
    it->prev_recyclable = (cache->semifree_superstate)->prev_recyclable;
#line 218
    it->next_recyclable = cache->semifree_superstate;
#line 219
    (it->prev_recyclable)->next_recyclable = it;
#line 220
    (it->next_recyclable)->prev_recyclable = it;
  }
#line 224
  it->is_semifree = 1;
#line 225
  (cache->semifree_superstates) ++;
#line 226
  df = it->transition_refs;
#line 227
  if (df) {
#line 229
    (df->prev_same_dest)->next_same_dest = (struct rx_distinct_future *)0;
#line 230
    df = it->transition_refs;
    {
#line 230
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 230
      if (! df) {
#line 230
        goto while_break___0;
      }
#line 232
      df->future_frame.inx = *(cache->instruction_table + 2);
#line 233
      df->future_frame.data = (void *)0;
#line 234
      df->future_frame.data_2 = (void *)df;
#line 238
      if (! df->effects) {
#line 238
        if ((unsigned long )((df->edge)->options)->next_same_super_edge[0] == (unsigned long )(df->edge)->options) {
          {
#line 241
          install_transition(df->present, & df->future_frame, (df->edge)->cset);
          }
        }
      }
#line 230
      df = df->next_same_dest;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 244
    df = it->transition_refs;
#line 245
    (df->prev_same_dest)->next_same_dest = df;
  }
#line 249
  return;
}
}
#line 253 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxsuper.c"
static void refresh_semifree_superstate(struct rx_cache *cache , struct rx_superstate *super ) 
{ 
  struct rx_distinct_future *df ;
  struct rx_superstate *tmp ;
  struct rx_superstate *tmp___0 ;

  {
#line 265
  if (super->transition_refs) {
#line 267
    ((super->transition_refs)->prev_same_dest)->next_same_dest = (struct rx_distinct_future *)0;
#line 268
    df = super->transition_refs;
    {
#line 268
    while (1) {
      while_continue: /* CIL Label */ ;
#line 268
      if (! df) {
#line 268
        goto while_break;
      }
#line 270
      df->future_frame.inx = *(cache->instruction_table + 3);
#line 271
      df->future_frame.data = (void *)(super->transitions);
#line 272
      df->future_frame.data_2 = (void *)(super->contents)->is_final;
#line 276
      if (! df->effects) {
#line 276
        if ((unsigned long )((df->edge)->options)->next_same_super_edge[0] == (unsigned long )(df->edge)->options) {
          {
#line 279
          install_transition(df->present, & df->future_frame, (df->edge)->cset);
          }
        }
      }
#line 268
      df = df->next_same_dest;
    }
    while_break: /* CIL Label */ ;
    }
#line 282
    ((super->transition_refs)->prev_same_dest)->next_same_dest = super->transition_refs;
  }
#line 285
  if ((unsigned long )cache->semifree_superstate == (unsigned long )super) {
#line 286
    if ((unsigned long )super->prev_recyclable == (unsigned long )super) {
#line 286
      cache->semifree_superstate = (struct rx_superstate *)0;
    } else {
#line 286
      cache->semifree_superstate = super->prev_recyclable;
    }
  }
#line 289
  (super->next_recyclable)->prev_recyclable = super->prev_recyclable;
#line 290
  (super->prev_recyclable)->next_recyclable = super->next_recyclable;
#line 292
  if (! cache->lru_superstate) {
#line 293
    tmp___0 = super;
#line 293
    super->prev_recyclable = tmp___0;
#line 293
    tmp = tmp___0;
#line 293
    super->next_recyclable = tmp;
#line 293
    cache->lru_superstate = tmp;
  } else {
#line 299
    super->next_recyclable = cache->lru_superstate;
#line 300
    super->prev_recyclable = (cache->lru_superstate)->prev_recyclable;
#line 301
    (super->next_recyclable)->prev_recyclable = super;
#line 302
    (super->prev_recyclable)->next_recyclable = super;
  }
#line 304
  super->is_semifree = 0;
#line 305
  (cache->semifree_superstates) --;
#line 306
  return;
}
}
#line 309 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxsuper.c"
void rx_refresh_this_superstate(struct rx_cache *cache , struct rx_superstate *superstate ) 
{ 


  {
#line 319
  if (superstate->is_semifree) {
    {
#line 320
    refresh_semifree_superstate(cache, superstate);
    }
  } else
#line 321
  if ((unsigned long )cache->lru_superstate == (unsigned long )superstate) {
#line 322
    cache->lru_superstate = superstate->next_recyclable;
  } else
#line 323
  if ((unsigned long )superstate != (unsigned long )(cache->lru_superstate)->prev_recyclable) {
#line 325
    (superstate->next_recyclable)->prev_recyclable = superstate->prev_recyclable;
#line 327
    (superstate->prev_recyclable)->next_recyclable = superstate->next_recyclable;
#line 329
    superstate->next_recyclable = cache->lru_superstate;
#line 330
    superstate->prev_recyclable = (cache->lru_superstate)->prev_recyclable;
#line 331
    (superstate->next_recyclable)->prev_recyclable = superstate;
#line 332
    (superstate->prev_recyclable)->next_recyclable = superstate;
  }
#line 334
  return;
}
}
#line 337 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxsuper.c"
static void release_superset_low(struct rx_cache *cache , struct rx_superset *set ) 
{ 


  {
#line 347
  (set->refs) --;
#line 347
  if (! set->refs) {
#line 349
    if (set->starts_for) {
#line 350
      (set->starts_for)->start_set = (struct rx_superset *)0;
    }
#line 352
    if (set->cdr) {
      {
#line 353
      release_superset_low(cache, set->cdr);
      }
    }
    {
#line 355
    rx_hash_free(& set->hash_item, & cache->superset_hash_rules);
#line 356
    rx_cache_free(cache, (int )sizeof(struct rx_superset ), (char *)set);
    }
  }
#line 360
  return;
}
}
#line 363 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxsuper.c"
void rx_release_superset(struct rx *rx , struct rx_superset *set ) 
{ 


  {
  {
#line 373
  release_superset_low(rx->cache, set);
  }
#line 374
  return;
}
}
#line 382 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxsuper.c"
static int rx_really_free_superstate(struct rx_cache *cache ) 
{ 
  int locked_superstates ;
  struct rx_superstate *it ;
  struct rx_distinct_future *df ;
  struct rx_super_edge *tc ;
  struct rx_distinct_future *df___0 ;
  struct rx_super_edge *tct ;
  struct rx_distinct_future *dft ;

  {
#line 390
  locked_superstates = 0;
#line 393
  if (! cache->superstates) {
#line 394
    return (0);
  }
  {
#line 397
  while (1) {
    while_continue: /* CIL Label */ ;
#line 397
    if (! (cache->hits + cache->misses > cache->superstates)) {
#line 397
      goto while_break;
    }
#line 399
    cache->hits >>= 1;
#line 400
    cache->misses >>= 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 406
  semifree_superstate(cache);
#line 407
  semifree_superstate(cache);
#line 408
  semifree_superstate(cache);
  }
#line 444
  if (! cache->semifree_superstate) {
#line 445
    return (0);
  }
#line 448
  it = cache->semifree_superstate;
#line 449
  (it->next_recyclable)->prev_recyclable = it->prev_recyclable;
#line 450
  (it->prev_recyclable)->next_recyclable = it->next_recyclable;
#line 451
  if ((unsigned long )it == (unsigned long )it->next_recyclable) {
#line 451
    cache->semifree_superstate = (struct rx_superstate *)0;
  } else {
#line 451
    cache->semifree_superstate = it->next_recyclable;
  }
#line 454
  (cache->semifree_superstates) --;
#line 458
  if (it->transition_refs) {
#line 461
    df = it->transition_refs;
#line 461
    (df->prev_same_dest)->next_same_dest = (struct rx_distinct_future *)0;
    {
#line 461
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 461
      if (! df) {
#line 461
        goto while_break___0;
      }
#line 466
      df->future_frame.inx = *(cache->instruction_table + 2);
#line 467
      df->future_frame.data = (void *)0;
#line 468
      df->future_frame.data_2 = (void *)df;
#line 469
      df->future = (struct rx_superstate *)0;
#line 461
      df = df->next_same_dest;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 471
    ((it->transition_refs)->prev_same_dest)->next_same_dest = it->transition_refs;
  }
#line 475
  tc = it->edges;
  {
#line 476
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 476
    if (! tc) {
#line 476
      goto while_break___1;
    }
#line 479
    tct = tc->next;
#line 480
    df___0 = tc->options;
#line 481
    (df___0->next_same_super_edge[1])->next_same_super_edge[0] = (struct rx_distinct_future *)0;
    {
#line 482
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 482
      if (! df___0) {
#line 482
        goto while_break___2;
      }
#line 484
      dft = df___0;
#line 485
      df___0 = df___0->next_same_super_edge[0];
#line 488
      if (dft->future) {
#line 488
        if ((unsigned long )(dft->future)->transition_refs == (unsigned long )dft) {
#line 490
          (dft->future)->transition_refs = dft->next_same_dest;
#line 491
          if ((unsigned long )(dft->future)->transition_refs == (unsigned long )dft) {
#line 492
            (dft->future)->transition_refs = (struct rx_distinct_future *)0;
          }
        }
      }
      {
#line 494
      (dft->next_same_dest)->prev_same_dest = dft->prev_same_dest;
#line 495
      (dft->prev_same_dest)->next_same_dest = dft->next_same_dest;
#line 496
      rx_cache_free(cache, (int )sizeof(struct rx_distinct_future ), (char *)dft);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 500
    rx_cache_free(cache, (int )sizeof(struct rx_super_edge ), (char *)tc);
#line 503
    tc = tct;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 507
  if ((unsigned long )(it->contents)->superstate == (unsigned long )it) {
#line 508
    (it->contents)->superstate = (struct rx_superstate *)0;
  }
  {
#line 509
  release_superset_low(cache, it->contents);
#line 510
  rx_cache_free(cache, (int )(sizeof(struct rx_superstate ) + (unsigned long )cache->local_cset_size * sizeof(struct rx_inx )),
                (char *)it);
#line 514
  (cache->superstates) --;
  }
#line 515
  return (1);
}
}
#line 520 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxsuper.c"
static char *rx_cache_malloc_or_get(struct rx_cache *cache , int size ) 
{ 
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 529
  while (1) {
    while_continue: /* CIL Label */ ;
#line 529
    if (cache->bytes_used + size > cache->bytes_allowed) {
      {
#line 529
      tmp = rx_really_free_superstate(cache);
      }
#line 529
      if (! tmp) {
#line 529
        goto while_break;
      }
    } else {
#line 529
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 533
  tmp___0 = rx_cache_malloc(cache, size);
  }
#line 533
  return (tmp___0);
}
}
#line 539 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxsuper.c"
static int supersetcmp(void *va , void *vb ) 
{ 
  struct rx_superset *a ;
  struct rx_superset *b ;
  int tmp ;

  {
#line 548
  a = (struct rx_superset *)va;
#line 549
  b = (struct rx_superset *)vb;
#line 550
  if ((unsigned long )a == (unsigned long )b) {
#line 550
    tmp = 1;
  } else
#line 550
  if (a) {
#line 550
    if (b) {
#line 550
      if (a->id == b->id) {
#line 550
        if ((unsigned long )a->car == (unsigned long )b->car) {
#line 550
          if ((unsigned long )a->cdr == (unsigned long )b->cdr) {
#line 550
            tmp = 1;
          } else {
#line 550
            tmp = 0;
          }
        } else {
#line 550
          tmp = 0;
        }
      } else {
#line 550
        tmp = 0;
      }
    } else {
#line 550
      tmp = 0;
    }
  } else {
#line 550
    tmp = 0;
  }
#line 550
  return (tmp);
}
}
#line 558 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxsuper.c"
static struct rx_hash_item *superset_allocator(struct rx_hash_rules *rules , void *val ) 
{ 
  struct rx_cache *cache ;
  struct rx_superset *template ;
  struct rx_superset *newset ;
  char *tmp ;
  int cdrfinal ;
  int cdredges ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 571
  cache = (struct rx_cache *)((char *)rules - (unsigned long )(& ((struct rx_cache *)0)->superset_hash_rules));
#line 574
  template = (struct rx_superset *)val;
#line 575
  tmp = rx_cache_malloc(cache, (int )sizeof(*template));
#line 575
  newset = (struct rx_superset *)tmp;
  }
#line 577
  if (! newset) {
#line 578
    return ((struct rx_hash_item *)0);
  }
#line 583
  if (template->cdr) {
#line 583
    cdrfinal = (template->cdr)->is_final;
  } else {
#line 583
    cdrfinal = 0;
  }
#line 586
  if (template->cdr) {
#line 586
    cdredges = (template->cdr)->has_cset_edges;
  } else {
#line 586
    cdredges = 0;
  }
#line 590
  if ((template->car)->is_final > 0) {
#line 590
    tmp___2 = (template->car)->is_final;
  } else {
#line 590
    tmp___2 = - (template->car)->is_final;
  }
#line 590
  if ((template->cdr)->is_final > 0) {
#line 590
    tmp___3 = (template->cdr)->is_final;
  } else {
#line 590
    tmp___3 = - (template->cdr)->is_final;
  }
#line 590
  if (tmp___2 > tmp___3) {
#line 590
    newset->is_final = (template->car)->is_final;
  } else {
#line 590
    newset->is_final = (template->cdr)->is_final;
  }
#line 593
  if ((template->car)->has_cset_edges) {
#line 593
    tmp___4 = 1;
  } else
#line 593
  if (cdredges) {
#line 593
    tmp___4 = 1;
  } else {
#line 593
    tmp___4 = 0;
  }
#line 593
  newset->has_cset_edges = tmp___4;
#line 595
  newset->refs = 0;
#line 596
  newset->id = template->id;
#line 597
  newset->car = template->car;
#line 598
  newset->cdr = template->cdr;
#line 599
  ((template->cdr)->refs) ++;
#line 600
  newset->superstate = (struct rx_superstate *)0;
#line 601
  newset->starts_for = (struct rx *)0;
#line 602
  newset->hash_item.data = (void *)newset;
#line 603
  newset->hash_item.binding = (void *)0;
#line 604
  return (& newset->hash_item);
}
}
#line 608 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxsuper.c"
static struct rx_hash *super_hash_allocator(struct rx_hash_rules *rules ) 
{ 
  struct rx_cache *cache ;
  char *tmp ;

  {
  {
#line 617
  cache = (struct rx_cache *)((char *)rules - (unsigned long )(& ((struct rx_cache *)0)->superset_hash_rules));
#line 620
  tmp = rx_cache_malloc(cache, (int )sizeof(struct rx_hash ));
  }
#line 620
  return ((struct rx_hash *)tmp);
}
}
#line 626 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxsuper.c"
static void super_hash_liberator(struct rx_hash *hash , struct rx_hash_rules *rules ) 
{ 
  struct rx_cache *cache ;

  {
  {
#line 635
  cache = (struct rx_cache *)((char *)rules) - (long )(& ((struct rx_cache *)0)->superset_hash_rules);
#line 638
  rx_cache_free(cache, (int )sizeof(struct rx_hash ), (char *)hash);
  }
#line 639
  return;
}
}
#line 642 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxsuper.c"
static void superset_hash_item_liberator(struct rx_hash_item *it , struct rx_hash_rules *rules ) 
{ 


  {
#line 652
  return;
}
}
#line 654 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxsuper.c"
int rx_cache_bound  =    3;
#line 657 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxsuper.c"
static struct rx_cache default_cache  = 
#line 657
     {{& supersetcmp, & super_hash_allocator, & super_hash_liberator, & superset_allocator,
     & superset_hash_item_liberator}, (struct rx_superstate *)0, (struct rx_superstate *)0,
    (struct rx_superset *)0, 0, 0, 0, 0, 1 << 19, 0, 256, rx_id_instruction_table,
    {(struct rx_hash *)0, 0, (RX_subset )0, {(void **)0, (void **)0}}};
#line 685 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxsuper.c"
struct rx_cache *rx_default_cache  =    & default_cache;
#line 694 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxsuper.c"
struct rx_superset *rx_superset_cons(struct rx *rx , struct rx_nfa_state *car , struct rx_superset *cdr ) 
{ 
  struct rx_cache *cache ;
  char *tmp ;
  struct rx_superset template ;
  struct rx_hash_item *hit ;
  struct rx_superset *tmp___0 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;

  {
#line 705
  cache = rx->cache;
#line 706
  if (! car) {
#line 706
    if (! cdr) {
#line 708
      if (! cache->empty_superset) {
        {
#line 710
        tmp = rx_cache_malloc(cache, (int )sizeof(struct rx_superset ));
#line 710
        cache->empty_superset = (struct rx_superset *)tmp;
        }
#line 713
        if (! cache->empty_superset) {
#line 714
          return ((struct rx_superset *)0);
        }
        {
#line 715
        rx_bzero((char *)cache->empty_superset, sizeof(struct rx_superset ));
#line 716
        (cache->empty_superset)->refs = 1000;
        }
      }
#line 718
      return (cache->empty_superset);
    }
  }
  {
#line 723
  template.car = car;
#line 724
  template.cdr = cdr;
#line 725
  template.id = rx->rx_id;
#line 726
  hit = rx_hash_store(& cache->superset_table, ((unsigned long )car ^ (unsigned long )car->id) ^ (unsigned long )cdr,
                      (void *)(& template), & cache->superset_hash_rules);
  }
#line 730
  if (hit) {
#line 730
    tmp___0 = (struct rx_superset *)hit->data;
  } else {
#line 730
    tmp___0 = (struct rx_superset *)0;
  }
#line 730
  return (tmp___0);
}
}
#line 742 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxsuper.c"
struct rx_superset *rx_superstate_eclosure_union(struct rx *rx , struct rx_superset *set ,
                                                 struct rx_nfa_state_set *ecl ) 
{ 
  struct rx_superset *tmp ;
  struct rx_superset *tmp___0 ;
  struct rx_superset *tmp___1 ;
  struct rx_superset *tail ;
  struct rx_nfa_state *first___0 ;
  struct rx_superset *answer ;

  {
#line 752
  if (! ecl) {
#line 753
    return (set);
  }
#line 755
  if (! set->car) {
    {
#line 756
    tmp = rx_superstate_eclosure_union(rx, set, ecl->cdr);
#line 756
    tmp___0 = rx_superset_cons(rx, ecl->car, tmp);
    }
#line 756
    return (tmp___0);
  }
#line 758
  if ((unsigned long )set->car == (unsigned long )ecl->car) {
    {
#line 759
    tmp___1 = rx_superstate_eclosure_union(rx, set, ecl->cdr);
    }
#line 759
    return (tmp___1);
  }
#line 765
  if ((unsigned long )set->car > (unsigned long )ecl->car) {
    {
#line 767
    tail = rx_superstate_eclosure_union(rx, set->cdr, ecl);
#line 768
    first___0 = set->car;
    }
  } else {
    {
#line 772
    tail = rx_superstate_eclosure_union(rx, set, ecl->cdr);
#line 773
    first___0 = ecl->car;
    }
  }
#line 775
  if (! tail) {
#line 776
    return ((struct rx_superset *)0);
  } else {
    {
#line 780
    answer = rx_superset_cons(rx, first___0, tail);
    }
#line 781
    if (! answer) {
      {
#line 783
      (tail->refs) ++;
#line 784
      rx_release_superset(rx, tail);
      }
#line 785
      return ((struct rx_superset *)0);
    } else {
#line 788
      return (answer);
    }
  }
}
}
#line 804 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxsuper.c"
static struct rx_distinct_future *include_futures(struct rx *rx , struct rx_distinct_future *df ,
                                                  struct rx_nfa_state *state , struct rx_superstate *superstate ) 
{ 
  struct rx_possible_future *future ;
  struct rx_cache *cache ;
  struct rx_distinct_future *dfp ;
  struct rx_distinct_future *insert_before ;
  int order ;
  int tmp ;
  char *tmp___0 ;
  struct rx_distinct_future *tmp___1 ;
  struct rx_distinct_future *tmp___2 ;

  {
  {
#line 818
  cache = rx->cache;
#line 819
  future = rx_state_possible_futures(rx, state);
  }
  {
#line 819
  while (1) {
    while_continue: /* CIL Label */ ;
#line 819
    if (! future) {
#line 819
      goto while_break;
    }
#line 822
    insert_before = (struct rx_distinct_future *)0;
#line 823
    if (df) {
#line 824
      (df->next_same_super_edge[1])->next_same_super_edge[0] = (struct rx_distinct_future *)0;
    }
#line 825
    dfp = df;
    {
#line 825
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 825
      if (! dfp) {
#line 825
        goto while_break___0;
      }
#line 826
      if ((unsigned long )dfp->effects == (unsigned long )future->effects) {
#line 827
        goto while_break___0;
      } else {
        {
#line 830
        tmp = (*(rx->se_list_cmp))(rx, dfp->effects, future->effects);
#line 830
        order = tmp;
        }
#line 831
        if (order > 0) {
#line 833
          insert_before = dfp;
#line 834
          dfp = (struct rx_distinct_future *)0;
#line 835
          goto while_break___0;
        }
      }
#line 825
      dfp = dfp->next_same_super_edge[0];
    }
    while_break___0: /* CIL Label */ ;
    }
#line 838
    if (df) {
#line 839
      (df->next_same_super_edge[1])->next_same_super_edge[0] = df;
    }
#line 840
    if (! dfp) {
      {
#line 842
      tmp___0 = rx_cache_malloc(cache, (int )sizeof(struct rx_distinct_future ));
#line 842
      dfp = (struct rx_distinct_future *)tmp___0;
      }
#line 846
      if (! dfp) {
#line 847
        return ((struct rx_distinct_future *)0);
      }
#line 848
      if (! df) {
#line 850
        insert_before = dfp;
#line 850
        df = insert_before;
#line 851
        tmp___1 = df;
#line 851
        df->next_same_super_edge[1] = tmp___1;
#line 851
        df->next_same_super_edge[0] = tmp___1;
      } else
#line 853
      if (! insert_before) {
#line 854
        insert_before = df;
      } else
#line 855
      if ((unsigned long )insert_before == (unsigned long )df) {
#line 856
        df = dfp;
      }
#line 858
      dfp->next_same_super_edge[0] = insert_before;
#line 859
      dfp->next_same_super_edge[1] = insert_before->next_same_super_edge[1];
#line 861
      (dfp->next_same_super_edge[1])->next_same_super_edge[0] = dfp;
#line 862
      (dfp->next_same_super_edge[0])->next_same_super_edge[1] = dfp;
#line 863
      tmp___2 = dfp;
#line 863
      dfp->prev_same_dest = tmp___2;
#line 863
      dfp->next_same_dest = tmp___2;
#line 864
      dfp->future = (struct rx_superstate *)0;
#line 865
      dfp->present = superstate;
#line 866
      dfp->future_frame.inx = *(rx->instruction_table + 2);
#line 867
      dfp->future_frame.data = (void *)0;
#line 868
      dfp->future_frame.data_2 = (void *)dfp;
#line 869
      dfp->side_effects_frame.inx = *(rx->instruction_table + 1);
#line 871
      dfp->side_effects_frame.data = (void *)0;
#line 872
      dfp->side_effects_frame.data_2 = (void *)dfp;
#line 873
      dfp->effects = future->effects;
    }
#line 819
    future = future->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 876
  return (df);
}
}
#line 885 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxsuper.c"
struct rx_superstate *rx_superstate(struct rx *rx , struct rx_superset *set ) 
{ 
  struct rx_cache *cache ;
  struct rx_superstate *superstate ;
  struct rx_superstate *tmp ;
  struct rx_superstate *tmp___0 ;
  int superstate_size ;
  char *tmp___1 ;
  struct rx_superstate *tmp___2 ;
  struct rx_superstate *tmp___3 ;
  struct rx_superstate *tmp___4 ;
  int x ;
  struct rx_inx *ifr ;
  void *tmp___5 ;

  {
#line 895
  cache = rx->cache;
#line 896
  superstate = (struct rx_superstate *)0;
#line 899
  if (set->superstate) {
#line 901
    if ((set->superstate)->rx_id != rx->rx_id) {
#line 909
      superstate = set->superstate;
#line 910
      if (! superstate->is_semifree) {
#line 912
        if ((unsigned long )cache->lru_superstate == (unsigned long )superstate) {
#line 914
          cache->lru_superstate = superstate->next_recyclable;
#line 915
          if ((unsigned long )cache->lru_superstate == (unsigned long )superstate) {
#line 916
            cache->lru_superstate = (struct rx_superstate *)0;
          }
        }
#line 919
        (superstate->next_recyclable)->prev_recyclable = superstate->prev_recyclable;
#line 921
        (superstate->prev_recyclable)->next_recyclable = superstate->next_recyclable;
#line 923
        if (! cache->semifree_superstate) {
#line 925
          tmp___0 = superstate;
#line 925
          superstate->prev_recyclable = tmp___0;
#line 925
          tmp = tmp___0;
#line 925
          superstate->next_recyclable = tmp;
#line 925
          cache->semifree_superstate = tmp;
        } else {
#line 932
          superstate->next_recyclable = cache->semifree_superstate;
#line 933
          superstate->prev_recyclable = (cache->semifree_superstate)->prev_recyclable;
#line 935
          (superstate->next_recyclable)->prev_recyclable = superstate;
#line 937
          (superstate->prev_recyclable)->next_recyclable = superstate;
#line 939
          cache->semifree_superstate = superstate;
        }
#line 941
        (cache->semifree_superstates) ++;
      }
#line 944
      set->superstate = (struct rx_superstate *)0;
#line 945
      goto handle_cache_miss;
    }
    {
#line 947
    (cache->hits) ++;
#line 948
    superstate = set->superstate;
#line 950
    rx_refresh_this_superstate(cache, superstate);
    }
#line 951
    return (superstate);
  }
  handle_cache_miss: 
  {
#line 957
  (cache->misses) ++;
#line 974
  superstate_size = (int )(sizeof(*superstate) + sizeof(struct rx_inx ) * (unsigned long )rx->local_cset_size);
#line 977
  tmp___1 = rx_cache_malloc_or_get(cache, superstate_size);
#line 977
  superstate = (struct rx_superstate *)tmp___1;
#line 979
  (cache->superstates) ++;
  }
#line 982
  if (! superstate) {
#line 983
    return ((struct rx_superstate *)0);
  }
#line 985
  if (! cache->lru_superstate) {
#line 986
    tmp___3 = superstate;
#line 986
    superstate->prev_recyclable = tmp___3;
#line 986
    tmp___2 = tmp___3;
#line 986
    superstate->next_recyclable = tmp___2;
#line 986
    cache->lru_superstate = tmp___2;
  } else {
#line 992
    superstate->next_recyclable = cache->lru_superstate;
#line 993
    superstate->prev_recyclable = (cache->lru_superstate)->prev_recyclable;
#line 994
    tmp___4 = superstate;
#line 994
    (superstate->next_recyclable)->prev_recyclable = tmp___4;
#line 994
    (superstate->prev_recyclable)->next_recyclable = tmp___4;
  }
#line 998
  superstate->rx_id = rx->rx_id;
#line 999
  superstate->transition_refs = (struct rx_distinct_future *)0;
#line 1000
  superstate->locks = 0;
#line 1001
  superstate->is_semifree = 0;
#line 1002
  set->superstate = superstate;
#line 1003
  superstate->contents = set;
#line 1004
  (set->refs) ++;
#line 1005
  superstate->edges = (struct rx_super_edge *)0;
#line 1009
  x = 0;
  {
#line 1009
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1009
    if (! (x < rx->local_cset_size)) {
#line 1009
      goto while_break;
    }
#line 1011
    ifr = & superstate->transitions[x];
#line 1012
    ifr->inx = *(rx->instruction_table + 2);
#line 1013
    tmp___5 = (void *)0;
#line 1013
    ifr->data_2 = tmp___5;
#line 1013
    ifr->data = tmp___5;
#line 1009
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1016
  return (superstate);
}
}
#line 1026 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxsuper.c"
static int solve_destination(struct rx *rx , struct rx_distinct_future *df ) 
{ 
  struct rx_super_edge *tc ;
  struct rx_superset *nfa_state ;
  struct rx_superset *nil_set ;
  struct rx_superset *tmp ;
  struct rx_superset *solution ;
  struct rx_superstate *dest ;
  struct rx_nfa_edge *e ;
  struct rx_nfa_state *n ;
  struct rx_possible_future *pf ;
  struct rx_superset *old_sol ;
  int tmp___0 ;
  struct rx_distinct_future *dft ;
  struct rx_distinct_future *dft___0 ;

  {
  {
#line 1035
  tc = df->edge;
#line 1037
  tmp = rx_superset_cons(rx, (struct rx_nfa_state *)0, (struct rx_superset *)0);
#line 1037
  nil_set = tmp;
#line 1038
  solution = nil_set;
#line 1041
  (solution->refs) ++;
#line 1043
  nfa_state = (df->present)->contents;
  }
  {
#line 1043
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1043
    if (! nfa_state->car) {
#line 1043
      goto while_break;
    }
#line 1049
    e = (nfa_state->car)->edges;
    {
#line 1049
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1049
      if (! e) {
#line 1049
        goto while_break___0;
      }
#line 1053
      if ((unsigned int )e->type == 0U) {
        {
#line 1053
        tmp___0 = rx_bitset_is_subset(rx->local_cset_size, tc->cset, e->params.cset);
        }
#line 1053
        if (tmp___0) {
          {
#line 1058
          n = e->dest;
#line 1066
          pf = rx_state_possible_futures(rx, n);
          }
          {
#line 1066
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 1066
            if (! pf) {
#line 1066
              goto while_break___1;
            }
#line 1067
            if ((unsigned long )pf->effects == (unsigned long )df->effects) {
              {
#line 1070
              old_sol = solution;
#line 1071
              solution = rx_superstate_eclosure_union(rx, solution, pf->destset);
              }
#line 1073
              if (! solution) {
#line 1074
                return (0);
              }
              {
#line 1075
              (solution->refs) ++;
#line 1076
              rx_release_superset(rx, old_sol);
              }
            }
#line 1066
            pf = pf->next;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
      }
#line 1049
      e = e->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1043
    nfa_state = nfa_state->cdr;
  }
  while_break: /* CIL Label */ ;
  }
#line 1084
  if ((unsigned long )solution == (unsigned long )nil_set) {
#line 1086
    df->future_frame.inx = (void *)4;
#line 1087
    df->future_frame.data = (void *)0;
#line 1088
    df->future_frame.data_2 = (void *)0;
#line 1089
    return (1);
  }
  {
#line 1091
  dest = rx_superstate(rx, solution);
#line 1092
  rx_release_superset(rx, solution);
  }
#line 1093
  if (! dest) {
#line 1094
    return (0);
  }
#line 1098
  dft = df;
#line 1099
  (df->prev_same_dest)->next_same_dest = (struct rx_distinct_future *)0;
  {
#line 1100
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1100
    if (! dft) {
#line 1100
      goto while_break___2;
    }
#line 1102
    dft->future = dest;
#line 1103
    dft->future_frame.inx = *(rx->instruction_table + 3);
#line 1104
    dft->future_frame.data = (void *)(dest->transitions);
#line 1105
    dft->future_frame.data_2 = (void *)(dest->contents)->is_final;
#line 1106
    dft = dft->next_same_dest;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1108
  (df->prev_same_dest)->next_same_dest = df;
#line 1110
  if (! dest->transition_refs) {
#line 1111
    dest->transition_refs = df;
  } else {
#line 1115
    dft___0 = (dest->transition_refs)->next_same_dest;
#line 1116
    (dest->transition_refs)->next_same_dest = df->next_same_dest;
#line 1117
    (df->next_same_dest)->prev_same_dest = dest->transition_refs;
#line 1118
    df->next_same_dest = dft___0;
#line 1119
    dft___0->prev_same_dest = df;
  }
#line 1121
  return (1);
}
}
#line 1135 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxsuper.c"
static int compute_super_edge(struct rx *rx , struct rx_distinct_future **dfout ,
                              rx_Bitset csetout , struct rx_superstate *superstate ,
                              unsigned char chr ) 
{ 
  struct rx_superset *stateset ;
  struct rx_nfa_edge *e ;
  struct rx_distinct_future *saved ;
  struct rx_distinct_future *df ;
  struct rx_distinct_future *dft ;

  {
  {
#line 1149
  stateset = superstate->contents;
#line 1154
  rx_bitset_universe(rx->local_cset_size, csetout);
#line 1155
  *dfout = (struct rx_distinct_future *)0;
  }
  {
#line 1158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1158
    if (! stateset->car) {
#line 1158
      goto while_break;
    }
#line 1161
    e = (stateset->car)->edges;
    {
#line 1161
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1161
      if (! e) {
#line 1161
        goto while_break___0;
      }
#line 1162
      if ((unsigned int )e->type == 0U) {
#line 1164
        if (! (*(e->params.cset + (unsigned long )chr / (8UL * sizeof(RX_subset ))) & rx_subset_singletons[(unsigned long )chr & (8UL * sizeof(RX_subset ) - 1UL)])) {
          {
#line 1168
          rx_bitset_difference(rx->local_cset_size, csetout, e->params.cset);
          }
        } else {
          {
#line 1176
          saved = *dfout;
#line 1177
          *dfout = include_futures(rx, *dfout, e->dest, superstate);
          }
#line 1178
          if (! *dfout) {
#line 1181
            df = saved;
#line 1182
            if (df) {
#line 1183
              (df->next_same_super_edge[1])->next_same_super_edge[0] = (struct rx_distinct_future *)0;
            }
            {
#line 1184
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 1184
              if (! df) {
#line 1184
                goto while_break___1;
              }
#line 1187
              dft = df;
#line 1188
              df = df->next_same_super_edge[0];
#line 1190
              if (dft->future) {
#line 1190
                if ((unsigned long )(dft->future)->transition_refs == (unsigned long )dft) {
#line 1192
                  (dft->future)->transition_refs = dft->next_same_dest;
#line 1193
                  if ((unsigned long )(dft->future)->transition_refs == (unsigned long )dft) {
#line 1194
                    (dft->future)->transition_refs = (struct rx_distinct_future *)0;
                  }
                }
              }
              {
#line 1196
              (dft->next_same_dest)->prev_same_dest = dft->prev_same_dest;
#line 1197
              (dft->prev_same_dest)->next_same_dest = dft->next_same_dest;
#line 1198
              rx_cache_free(rx->cache, (int )sizeof(*dft), (char *)dft);
              }
            }
            while_break___1: /* CIL Label */ ;
            }
#line 1200
            return (0);
          }
          {
#line 1204
          rx_bitset_intersection(rx->local_cset_size, csetout, e->params.cset);
          }
        }
      }
#line 1161
      e = e->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1208
    stateset = stateset->cdr;
  }
  while_break: /* CIL Label */ ;
  }
#line 1210
  return (1);
}
}
#line 1221 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxsuper.c"
static struct rx_super_edge *rx_super_edge(struct rx *rx , struct rx_superstate *super ,
                                           rx_Bitset cset , struct rx_distinct_future *df ) 
{ 
  struct rx_super_edge *tc ;
  int tc_size ;
  char *tmp ;
  struct rx_distinct_future *dfp ;

  {
  {
#line 1237
  tc_size = (int )(sizeof(struct rx_super_edge ) + ((((unsigned long )rx->local_cset_size + 8UL * sizeof(RX_subset )) - 1UL) / (8UL * sizeof(RX_subset ))) * sizeof(RX_subset ));
#line 1240
  tmp = rx_cache_malloc(rx->cache, tc_size);
#line 1240
  tc = (struct rx_super_edge *)tmp;
  }
#line 1243
  if (! tc) {
#line 1244
    return ((struct rx_super_edge *)0);
  }
  {
#line 1246
  tc->next = super->edges;
#line 1247
  super->edges = tc;
#line 1248
  tc->rx_backtrack_frame.inx = *(rx->instruction_table + 0);
#line 1249
  tc->rx_backtrack_frame.data = (void *)0;
#line 1250
  tc->rx_backtrack_frame.data_2 = (void *)tc;
#line 1251
  tc->options = df;
#line 1252
  tc->cset = (rx_Bitset )((char *)tc + sizeof(*tc));
#line 1253
  rx_bitset_assign(rx->local_cset_size, tc->cset, cset);
  }
#line 1254
  if (df) {
#line 1256
    dfp = df;
#line 1257
    (df->next_same_super_edge[1])->next_same_super_edge[0] = (struct rx_distinct_future *)0;
    {
#line 1258
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1258
      if (! dfp) {
#line 1258
        goto while_break;
      }
#line 1260
      dfp->edge = tc;
#line 1261
      dfp = dfp->next_same_super_edge[0];
    }
    while_break: /* CIL Label */ ;
    }
#line 1263
    (df->next_same_super_edge[1])->next_same_super_edge[0] = df;
  }
#line 1265
  return (tc);
}
}
#line 1284 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxsuper.c"
static void install_partial_transition(struct rx_superstate *super , struct rx_inx *answer ,
                                       RX_subset set , int offset ) 
{ 
  int start ;
  int end ;
  RX_subset pos ;
  struct rx_inx *transitions ;

  {
#line 1297
  start = offset;
#line 1298
  end = start + 32;
#line 1299
  pos = (RX_subset )1;
#line 1300
  transitions = super->transitions;
  {
#line 1302
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1302
    if (! (start < end)) {
#line 1302
      goto while_break;
    }
#line 1304
    if (set & pos) {
#line 1305
      *(transitions + start) = *answer;
    }
#line 1306
    pos <<= 1;
#line 1307
    start ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1309
  return;
}
}
#line 1365 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxsuper.c"
static struct rx_inx shared_fail_frame  =    {(void *)0, (void *)0, (void *)4, (void *)0};
#line 1313 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxsuper.c"
struct rx_inx *rx_handle_cache_miss(struct rx *rx , struct rx_superstate *super ,
                                    unsigned char chr , void *data ) 
{ 
  int offset ;
  struct rx_distinct_future *df ;
  struct rx_super_edge *tc ;
  RX_subset mask ;
  struct rx_inx *answer ;
  struct rx_inx *tmp ;
  char cset_space[1024] ;
  rx_Bitset trcset ;
  struct rx_inx *answer___0 ;
  int tmp___0 ;
  struct rx_inx *tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp17 ;

  {
#line 1324
  offset = (int )((unsigned long )chr / (8UL * sizeof(RX_subset )));
#line 1325
  df = (struct rx_distinct_future *)data;
#line 1327
  if (! df) {
#line 1331
    mask = rx_subset_singletons[(unsigned long )chr % (8UL * sizeof(RX_subset ))];
#line 1333
    tc = super->edges;
    {
#line 1333
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1333
      if (! tc) {
#line 1333
        goto while_break;
      }
#line 1334
      if (*(tc->cset + offset) & mask) {
#line 1337
        df = tc->options;
#line 1338
        if ((unsigned long )(tc->options)->next_same_super_edge[0] != (unsigned long )tc->options) {
#line 1338
          answer = & tc->rx_backtrack_frame;
        } else {
#line 1338
          if (df->effects) {
#line 1338
            tmp = & df->side_effects_frame;
          } else {
#line 1338
            tmp = & df->future_frame;
          }
#line 1338
          answer = tmp;
        }
        {
#line 1343
        install_partial_transition(super, answer, *(tc->cset + offset), offset * 32);
        }
#line 1345
        return (answer);
      }
#line 1333
      tc = tc->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 1353
    if (((((unsigned long )rx->local_cset_size + 8UL * sizeof(RX_subset )) - 1UL) / (8UL * sizeof(RX_subset ))) * sizeof(RX_subset ) > sizeof(cset_space)) {
#line 1354
      return ((struct rx_inx *)0);
    }
    {
#line 1356
    trcset = (rx_Bitset )(cset_space);
#line 1357
    (super->locks) ++;
#line 1358
    tmp___0 = compute_super_edge(rx, & df, trcset, super, chr);
    }
#line 1358
    if (! tmp___0) {
#line 1360
      (super->locks) --;
#line 1361
      return ((struct rx_inx *)0);
    }
#line 1363
    if (! df) {
#line 1367
      answer___0 = & shared_fail_frame;
    } else {
      {
#line 1371
      tc = rx_super_edge(rx, super, trcset, df);
      }
#line 1372
      if (! tc) {
#line 1374
        (super->locks) --;
#line 1375
        return ((struct rx_inx *)0);
      }
#line 1377
      if ((unsigned long )(tc->options)->next_same_super_edge[0] != (unsigned long )tc->options) {
#line 1377
        answer___0 = & tc->rx_backtrack_frame;
      } else {
#line 1377
        if (df->effects) {
#line 1377
          tmp___1 = & df->side_effects_frame;
        } else {
#line 1377
          tmp___1 = & df->future_frame;
        }
#line 1377
        answer___0 = tmp___1;
      }
    }
    {
#line 1383
    install_partial_transition(super, answer___0, *(trcset + offset), offset * 32);
#line 1385
    (super->locks) --;
    }
#line 1386
    return (answer___0);
  } else
#line 1389
  if (df->future) {
#line 1392
    if ((df->future)->is_semifree) {
      {
#line 1393
      refresh_semifree_superstate(rx->cache, df->future);
      }
    }
#line 1394
    return (& df->future_frame);
  } else {
    {
#line 1399
    (super->locks) ++;
#line 1400
    tmp___2 = solve_destination(rx, df);
    }
#line 1400
    if (! tmp___2) {
#line 1402
      (super->locks) --;
#line 1403
      return ((struct rx_inx *)0);
    }
#line 1405
    if (! df->effects) {
#line 1405
      if ((unsigned long )((df->edge)->options)->next_same_super_edge[0] == (unsigned long )(df->edge)->options) {
        {
#line 1407
        install_partial_transition(super, & df->future_frame, *((df->edge)->cset + offset),
                                   offset * 32);
        }
      }
    }
#line 1409
    (super->locks) --;
#line 1410
    return (& df->future_frame);
  }
}
}
#line 43 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxstr.h"
enum rx_answers rx_str_vmfn(void *closure , unsigned char const   **burstp , int *lenp ,
                            int *offsetp , int start , int end , int need ) ;
#line 44
enum rx_answers rx_str_contextfn(void *closure , struct rexp_node *node , int start ,
                                 int end , struct rx_registers *regs ) ;
#line 27 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxstr.c"
enum rx_answers rx_str_vmfn(void *closure , unsigned char const   **burstp , int *lenp ,
                            int *offsetp , int start , int end , int need ) 
{ 
  struct rx_str_closure *strc ;

  {
#line 42
  strc = (struct rx_str_closure *)closure;
#line 44
  if (need < 0) {
#line 46
    return ((enum rx_answers )1);
  } else
#line 44
  if (need > strc->len) {
#line 46
    return ((enum rx_answers )1);
  }
#line 48
  *burstp = strc->str;
#line 49
  *lenp = strc->len;
#line 50
  *offsetp = 0;
#line 51
  return ((enum rx_answers )0);
}
}
#line 84
extern int ( /* missing proto */  strncasecmp)() ;
#line 88
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
#line 55 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxstr.c"
enum rx_answers rx_str_contextfn(void *closure , struct rexp_node *node , int start ,
                                 int end , struct rx_registers *regs ) 
{ 
  struct rx_str_closure *strc ;
  int cmp ;
  int regn ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 69
  strc = (struct rx_str_closure *)closure;
  {
#line 73
  if (node->params.intval == 57) {
#line 73
    goto case_57;
  }
#line 73
  if (node->params.intval == 56) {
#line 73
    goto case_57;
  }
#line 73
  if (node->params.intval == 55) {
#line 73
    goto case_57;
  }
#line 73
  if (node->params.intval == 54) {
#line 73
    goto case_57;
  }
#line 73
  if (node->params.intval == 53) {
#line 73
    goto case_57;
  }
#line 73
  if (node->params.intval == 52) {
#line 73
    goto case_57;
  }
#line 73
  if (node->params.intval == 51) {
#line 73
    goto case_57;
  }
#line 73
  if (node->params.intval == 50) {
#line 73
    goto case_57;
  }
#line 73
  if (node->params.intval == 49) {
#line 73
    goto case_57;
  }
#line 98
  if (node->params.intval == 94) {
#line 98
    goto case_94;
  }
#line 109
  if (node->params.intval == 36) {
#line 109
    goto case_36;
  }
#line 127
  goto switch_default;
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
#line 77
  regn = node->params.intval - 48;
#line 78
  if ((regs + regn)->rm_so == -1) {
#line 80
    return ((enum rx_answers )1);
  } else
#line 78
  if (end - start != (regs + regn)->rm_eo - (regs + regn)->rm_so) {
#line 80
    return ((enum rx_answers )1);
  } else {
#line 83
    if (strc->rules.case_indep) {
      {
#line 84
      cmp = strncasecmp(strc->str + start, strc->str + (regs + regn)->rm_so, end - start);
      }
    } else {
      {
#line 88
      cmp = strncmp(strc->str + start, strc->str + (regs + regn)->rm_so, end - start);
      }
    }
#line 92
    if (! cmp) {
#line 92
      tmp = 0;
    } else {
#line 92
      tmp = 1;
    }
#line 92
    return ((enum rx_answers )tmp);
  }
  case_94: /* CIL Label */ 
#line 100
  if (start == end) {
#line 100
    if (start == 0) {
#line 100
      if (! strc->rules.not_bol) {
#line 100
        tmp___0 = 0;
      } else {
#line 100
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 100
    if (start > 0) {
#line 100
      if (strc->rules.newline_anchor) {
#line 100
        if ((int const   )*(strc->str + (start - 1)) == 10) {
#line 100
          tmp___0 = 0;
        } else {
#line 100
          tmp___0 = 1;
        }
      } else {
#line 100
        tmp___0 = 1;
      }
    } else {
#line 100
      tmp___0 = 1;
    }
  } else {
#line 100
    tmp___0 = 1;
  }
#line 100
  return ((enum rx_answers )tmp___0);
  case_36: /* CIL Label */ 
#line 111
  if (start == end) {
#line 111
    if (start == strc->len) {
#line 111
      if (! strc->rules.not_eol) {
#line 111
        tmp___1 = 0;
      } else {
#line 111
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 111
    if (start < strc->len) {
#line 111
      if (strc->rules.newline_anchor) {
#line 111
        if ((int const   )*(strc->str + start) == 10) {
#line 111
          tmp___1 = 0;
        } else {
#line 111
          tmp___1 = 1;
        }
      } else {
#line 111
        tmp___1 = 1;
      }
    } else {
#line 111
      tmp___1 = 1;
    }
  } else {
#line 111
    tmp___1 = 1;
  }
#line 111
  return ((enum rx_answers )tmp___1);
  switch_default: /* CIL Label */ 
#line 128
  return ((enum rx_answers )-1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 57 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxanal.h"
enum rx_answers rx_start_superstate(struct rx_classical_system *frame ) ;
#line 58
enum rx_answers rx_fit_p(struct rx_classical_system *frame , unsigned char const   *burst ,
                         int len ) ;
#line 59
enum rx_answers rx_advance(struct rx_classical_system *frame , unsigned char const   *burst ,
                           int len ) ;
#line 60
void rx_terminate_system(struct rx_classical_system *frame ) ;
#line 61
void rx_init_system(struct rx_classical_system *frame , struct rx *rx ) ;
#line 76 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxspencer.h"
struct rx_solutions rx_no_solutions  ;
#line 80
struct rx_solutions *rx_make_solutions(struct rx_registers *regs , struct rx_unfaniverse *verse ,
                                       struct rexp_node *expression , struct rexp_node **subexps ,
                                       int cset_size , int start , int end , enum rx_answers (*vmfn)(void *closure ,
                                                                                                     unsigned char const   **burst ,
                                                                                                     int *len ,
                                                                                                     int *offset ,
                                                                                                     int start ,
                                                                                                     int end ,
                                                                                                     int need ) ,
                                       enum rx_answers (*contextfn)(void *closure ,
                                                                    struct rexp_node *node ,
                                                                    int start , int end ,
                                                                    struct rx_registers *regs ) ,
                                       void *closure ) ;
#line 88
void rx_free_solutions(struct rx_solutions *solns ) ;
#line 89
enum rx_answers rx_next_solution(struct rx_solutions *solns ) ;
#line 30 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxsimp.h"
int rx_simple_rexp(struct rexp_node **answer , int cset_size , struct rexp_node *node ,
                   struct rexp_node **subexps ) ;
#line 27 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxspencer.c"
static char *silly_hack_2  =    (char *)0;
#line 32 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxspencer.c"
struct rx_solutions *rx_make_solutions(struct rx_registers *regs , struct rx_unfaniverse *verse ,
                                       struct rexp_node *expression , struct rexp_node **subexps ,
                                       int cset_size , int start , int end , enum rx_answers (*vmfn)(void *closure ,
                                                                                                     unsigned char const   **burst ,
                                                                                                     int *len ,
                                                                                                     int *offset ,
                                                                                                     int start ,
                                                                                                     int end ,
                                                                                                     int need ) ,
                                       enum rx_answers (*contextfn)(void *closure ,
                                                                    struct rexp_node *node ,
                                                                    int start , int end ,
                                                                    struct rx_registers *regs ) ,
                                       void *closure ) 
{ 
  struct rx_solutions *solns ;
  void *tmp ;
  struct rx *rx ;
  enum rx_answers tmp___0 ;
  struct rexp_node *simplified ;
  int status ;
  enum rx_answers tmp___1 ;
  void *__cil_tmp18 ;

  {
#line 52
  if (expression) {
#line 52
    if (expression->len >= 0) {
#line 52
      if (expression->len != end - start) {
#line 55
        return (& rx_no_solutions);
      }
    }
  }
#line 57
  if (silly_hack_2) {
#line 59
    solns = (struct rx_solutions *)silly_hack_2;
#line 60
    silly_hack_2 = (char *)0;
  } else {
    {
#line 63
    tmp = malloc(sizeof(*solns));
#line 63
    solns = (struct rx_solutions *)tmp;
    }
  }
#line 64
  if (! solns) {
#line 65
    return ((struct rx_solutions *)0);
  }
  {
#line 66
  rx_bzero((char *)solns, sizeof(*solns));
#line 68
  solns->step = 0;
#line 69
  solns->cset_size = cset_size;
#line 70
  solns->subexps = subexps;
#line 71
  solns->exp = expression;
#line 72
  rx_save_rexp(expression);
#line 73
  solns->verse = verse;
#line 74
  solns->regs = regs;
#line 75
  solns->start = start;
#line 76
  solns->end = end;
#line 77
  solns->vmfn = vmfn;
#line 78
  solns->contextfn = contextfn;
#line 79
  solns->closure = closure;
#line 80
  solns->current_pos = start;
  }
#line 82
  if (! (solns->exp)->observed) {
    {
#line 84
    solns->dfa = rx_unfa(verse, expression, cset_size);
    }
#line 85
    if (! solns->dfa) {
#line 86
      goto err_return;
    }
    {
#line 87
    rx_init_system(& solns->match_engine, (solns->dfa)->nfa);
#line 91
    rx = solns->match_engine.rx;
#line 92
    tmp___0 = rx_start_superstate(& solns->match_engine);
    }
#line 92
    if (0 != (int )tmp___0) {
#line 93
      goto err_return;
    }
  } else {
    {
#line 100
    status = rx_simple_rexp(& simplified, cset_size, solns->exp, subexps);
    }
#line 101
    if (status) {
#line 102
      goto err_return;
    }
    {
#line 103
    solns->dfa = rx_unfa(verse, simplified, cset_size);
    }
#line 104
    if (! solns->dfa) {
      {
#line 106
      rx_free_rexp(simplified);
      }
#line 107
      goto err_return;
    }
    {
#line 109
    rx_init_system(& solns->match_engine, (solns->dfa)->nfa);
#line 110
    tmp___1 = rx_start_superstate(& solns->match_engine);
    }
#line 110
    if (0 != (int )tmp___1) {
#line 111
      goto err_return;
    }
    {
#line 112
    rx_free_rexp(simplified);
    }
  }
#line 114
  return (solns);
  err_return: 
  {
#line 117
  rx_free_rexp(solns->exp);
#line 118
  free((void *)solns);
  }
#line 119
  return ((struct rx_solutions *)0);
}
}
#line 125 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxspencer.c"
void rx_free_solutions(struct rx_solutions *solns ) 
{ 


  {
#line 133
  if (! solns) {
#line 134
    return;
  }
#line 136
  if ((unsigned long )solns == (unsigned long )(& rx_no_solutions)) {
#line 137
    return;
  }
#line 139
  if (solns->left) {
    {
#line 141
    rx_free_solutions(solns->left);
#line 142
    solns->left = (struct rx_solutions *)0;
    }
  }
#line 145
  if (solns->right) {
    {
#line 147
    rx_free_solutions(solns->right);
#line 148
    solns->right = (struct rx_solutions *)0;
    }
  }
#line 151
  if (solns->dfa) {
    {
#line 153
    rx_free_unfa(solns->dfa);
#line 154
    solns->dfa = (struct rx_unfa *)0;
    }
  }
  {
#line 157
  rx_terminate_system(& solns->match_engine);
  }
#line 159
  if (solns->exp) {
    {
#line 161
    rx_free_rexp(solns->exp);
#line 162
    solns->exp = (struct rexp_node *)0;
    }
  }
#line 165
  if (! silly_hack_2) {
#line 166
    silly_hack_2 = (char *)solns;
  } else {
    {
#line 168
    free((void *)solns);
    }
  }
#line 169
  return;
}
}
#line 173 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxspencer.c"
static enum rx_answers rx_solution_fit_p(struct rx_solutions *solns ) 
{ 
  unsigned char const   *burst ;
  int burst_addr ;
  int burst_len ;
  int burst_end_addr ;
  int rel_pos_in_burst ;
  enum rx_answers vmstat ;
  enum rx_answers fit_status ;
  enum rx_answers fit_status___0 ;

  {
  next_burst: 
  {
#line 190
  vmstat = (*(solns->vmfn))(solns->closure, & burst, & burst_len, & burst_addr, solns->current_pos,
                            solns->end, solns->current_pos);
  }
#line 195
  if ((int )vmstat != 0) {
#line 196
    return (vmstat);
  }
#line 198
  rel_pos_in_burst = solns->current_pos - burst_addr;
#line 199
  burst_end_addr = burst_addr + burst_len;
#line 201
  if (burst_end_addr >= solns->end) {
    {
#line 204
    fit_status = rx_fit_p(& solns->match_engine, burst + rel_pos_in_burst, solns->end - solns->current_pos);
    }
#line 207
    return (fit_status);
  } else {
    {
#line 212
    fit_status___0 = rx_advance(& solns->match_engine, burst + rel_pos_in_burst, burst_len - rel_pos_in_burst);
    }
#line 215
    if ((int )fit_status___0 != 0) {
#line 217
      return (fit_status___0);
    } else {
#line 221
      solns->current_pos += burst_len - rel_pos_in_burst;
#line 222
      goto next_burst;
    }
  }
}
}
#line 229 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxspencer.c"
static enum rx_answers rx_solution_fit_str_p(struct rx_solutions *solns ) 
{ 
  unsigned char const   *burst ;
  int burst_addr ;
  int burst_len ;
  int burst_end_addr ;
  int rel_pos_in_burst ;
  enum rx_answers vmstat ;
  int count ;
  unsigned char *key ;
  unsigned char const   *pos ;
  int part_count ;
  int part_count_init ;

  {
#line 247
  count = (int )(solns->exp)->params.cstr.len;
#line 248
  key = (solns->exp)->params.cstr.contents;
  next_burst: 
  {
#line 251
  vmstat = (*(solns->vmfn))(solns->closure, & burst, & burst_len, & burst_addr, solns->current_pos,
                            solns->end, solns->current_pos);
  }
#line 256
  if ((int )vmstat != 0) {
#line 257
    return (vmstat);
  }
#line 259
  rel_pos_in_burst = solns->current_pos - burst_addr;
#line 260
  burst_end_addr = burst_addr + burst_len;
#line 265
  pos = burst + rel_pos_in_burst;
#line 267
  if (burst_end_addr >= solns->end) {
    {
#line 269
    while (1) {
      while_continue: /* CIL Label */ ;
#line 269
      if (! count) {
#line 269
        goto while_break;
      }
#line 271
      if ((int const   )*pos != (int const   )*key) {
#line 272
        return ((enum rx_answers )1);
      }
#line 273
      pos ++;
#line 274
      key ++;
#line 275
      count --;
    }
    while_break: /* CIL Label */ ;
    }
#line 277
    return ((enum rx_answers )0);
  } else {
#line 284
    part_count_init = burst_len - rel_pos_in_burst;
#line 285
    part_count = part_count_init;
    {
#line 286
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 286
      if (! part_count) {
#line 286
        goto while_break___0;
      }
#line 288
      if ((int const   )*pos != (int const   )*key) {
#line 289
        return ((enum rx_answers )1);
      }
#line 290
      pos ++;
#line 291
      key ++;
#line 292
      part_count --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 294
    count -= part_count_init;
#line 295
    solns->current_pos += burst_len - rel_pos_in_burst;
#line 296
    goto next_burst;
  }
}
}
#line 304 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxspencer.c"
enum rx_answers rx_next_solution(struct rx_solutions *solns ) 
{ 
  int tmp ;
  enum rx_answers ans ;
  enum rx_answers ans___0 ;
  enum rx_answers fit_p ;
  enum rx_answers paren_stat ;
  enum rx_answers opt_stat ;
  int tmp___0 ;
  enum rx_answers alt_stat ;
  enum rx_answers concat_stat ;
  struct rx_solutions *tmp___1 ;
  enum rx_answers star_stat ;
  struct rx_solutions *tmp___2 ;
  enum rx_answers tmp___3 ;
  enum rx_answers interval_stat ;
  int tmp___4 ;
  struct rx_solutions *tmp___5 ;

  {
#line 312
  if (! solns) {
#line 313
    return ((enum rx_answers )-1);
  }
#line 315
  if ((unsigned long )solns == (unsigned long )(& rx_no_solutions)) {
#line 317
    return ((enum rx_answers )1);
  }
#line 320
  if (! solns->exp) {
#line 322
    if (solns->step != 0) {
#line 324
      return ((enum rx_answers )1);
    } else {
#line 328
      solns->step = 1;
#line 329
      solns->final_tag = 1;
#line 330
      if (solns->start == solns->end) {
#line 330
        tmp = 0;
      } else {
#line 330
        tmp = 1;
      }
#line 330
      return ((enum rx_answers )tmp);
    }
  } else
#line 335
  if ((solns->exp)->len >= 0) {
#line 335
    if ((solns->exp)->len != solns->end - solns->start) {
#line 338
      return ((enum rx_answers )1);
    } else {
#line 335
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 340
  if (! (solns->exp)->observed) {
#line 342
    if (solns->step != 0) {
#line 344
      return ((enum rx_answers )1);
    } else
#line 346
    if ((unsigned int )(solns->exp)->type == 6U) {
      {
#line 349
      ans = rx_solution_fit_str_p(solns);
#line 350
      solns->final_tag = 1;
#line 351
      solns->step = -1;
      }
#line 352
      return (ans);
    } else {
      {
#line 357
      ans___0 = rx_solution_fit_p(solns);
#line 358
      solns->final_tag = solns->match_engine.final_tag;
#line 359
      solns->step = -1;
      }
#line 360
      return (ans___0);
    }
  } else
#line 363
  if ((solns->exp)->observed) {
    {
#line 368
    if (solns->step == -1) {
#line 368
      goto case_neg_1;
    }
#line 371
    if (solns->step == 0) {
#line 371
      goto case_0;
    }
#line 394
    goto resolve_fit;
    case_neg_1: /* CIL Label */ 
#line 369
    return ((enum rx_answers )1);
    case_0: /* CIL Label */ 
    {
#line 372
    fit_p = rx_solution_fit_p(solns);
#line 379
    solns->final_tag = solns->match_engine.final_tag;
    }
    {
#line 382
    if ((int )fit_p == 1) {
#line 382
      goto case_1;
    }
#line 385
    if ((int )fit_p == 0) {
#line 385
      goto case_0___0;
    }
#line 389
    goto switch_default;
    case_1: /* CIL Label */ 
#line 383
    solns->step = -1;
#line 384
    return ((enum rx_answers )1);
    case_0___0: /* CIL Label */ 
#line 386
    solns->step = 1;
#line 387
    goto resolve_fit;
    switch_default: /* CIL Label */ 
#line 390
    solns->step = -1;
#line 391
    return (fit_p);
    switch_break___0: /* CIL Label */ ;
    }
    resolve_fit: 
    switch_default___0: /* CIL Label */ 
    {
#line 400
    if ((unsigned int )(solns->exp)->type == 7U) {
#line 400
      goto case_7;
    }
#line 400
    if ((unsigned int )(solns->exp)->type == 6U) {
#line 400
      goto case_7;
    }
#line 400
    if ((unsigned int )(solns->exp)->type == 0U) {
#line 400
      goto case_7;
    }
#line 404
    if ((unsigned int )(solns->exp)->type == 9U) {
#line 404
      goto case_9;
    }
#line 473
    if ((unsigned int )(solns->exp)->type == 3U) {
#line 473
      goto case_3;
    }
#line 517
    if ((unsigned int )(solns->exp)->type == 2U) {
#line 517
      goto case_2___1;
    }
#line 594
    if ((unsigned int )(solns->exp)->type == 1U) {
#line 594
      goto case_1___3;
    }
#line 696
    if ((unsigned int )(solns->exp)->type == 4U) {
#line 696
      goto case_4___1;
    }
#line 696
    if ((unsigned int )(solns->exp)->type == 5U) {
#line 696
      goto case_4___1;
    }
#line 811
    if ((unsigned int )(solns->exp)->type == 10U) {
#line 811
      goto case_10;
    }
#line 821
    if ((unsigned int )(solns->exp)->type == 8U) {
#line 821
      goto case_8;
    }
#line 396
    goto switch_break___1;
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
    case_0___1: /* CIL Label */ 
#line 401
    solns->step = -1;
#line 402
    return ((enum rx_answers )-1);
    case_9: /* CIL Label */ 
    {
#line 409
    if (solns->step == 1) {
#line 409
      goto case_1___0;
    }
#line 444
    if (solns->step == 2) {
#line 444
      goto case_2;
    }
#line 407
    goto switch_break___2;
    case_1___0: /* CIL Label */ 
#line 411
    if (! (solns->exp)->params.pair.left) {
#line 411
      goto _L;
    } else
#line 411
    if (! ((solns->exp)->params.pair.left)->observed) {
      _L: /* CIL Label */ 
#line 414
      if ((solns->exp)->params.intval) {
#line 416
        (solns->regs + (solns->exp)->params.intval)->rm_so = solns->start;
#line 417
        (solns->regs + (solns->exp)->params.intval)->rm_eo = solns->end;
      }
#line 419
      solns->step = -1;
#line 421
      return ((enum rx_answers )0);
    } else {
      {
#line 425
      solns->left = rx_make_solutions(solns->regs, solns->verse, (solns->exp)->params.pair.left,
                                      solns->subexps, solns->cset_size, solns->start,
                                      solns->end, solns->vmfn, solns->contextfn, solns->closure);
      }
#line 435
      if (! solns->left) {
#line 437
        solns->step = -1;
#line 438
        return ((enum rx_answers )-1);
      }
    }
#line 441
    solns->step = 2;
    case_2: /* CIL Label */ 
#line 445
    if ((solns->exp)->params.intval) {
#line 447
      (solns->regs + (solns->exp)->params.intval)->rm_so = -1;
#line 448
      (solns->regs + (solns->exp)->params.intval)->rm_eo = -1;
    }
    {
#line 451
    paren_stat = rx_next_solution(solns->left);
    }
#line 452
    if ((int )paren_stat == 0) {
#line 454
      if ((solns->exp)->params.intval) {
#line 456
        (solns->regs + (solns->exp)->params.intval)->rm_so = solns->start;
#line 457
        (solns->regs + (solns->exp)->params.intval)->rm_eo = solns->end;
      }
#line 459
      solns->final_tag = (solns->left)->final_tag;
#line 460
      return ((enum rx_answers )0);
    } else {
      {
#line 464
      solns->step = -1;
#line 465
      rx_free_solutions(solns->left);
#line 466
      solns->left = (struct rx_solutions *)0;
      }
#line 467
      return (paren_stat);
    }
    switch_break___2: /* CIL Label */ ;
    }
    case_3: /* CIL Label */ 
    {
#line 478
    if (solns->step == 1) {
#line 478
      goto case_1___1;
    }
#line 497
    if (solns->step == 2) {
#line 497
      goto case_2___0;
    }
#line 476
    goto switch_break___3;
    case_1___1: /* CIL Label */ 
    {
#line 479
    solns->left = rx_make_solutions(solns->regs, solns->verse, (solns->exp)->params.pair.left,
                                    solns->subexps, solns->cset_size, solns->start,
                                    solns->end, solns->vmfn, solns->contextfn, solns->closure);
    }
#line 489
    if (! solns->left) {
#line 491
      solns->step = -1;
#line 492
      return ((enum rx_answers )-1);
    }
#line 494
    solns->step = 2;
    case_2___0: /* CIL Label */ 
    {
#line 498
    opt_stat = rx_next_solution(solns->left);
    }
#line 499
    if ((int )opt_stat == 0) {
#line 501
      solns->final_tag = (solns->left)->final_tag;
#line 502
      return ((enum rx_answers )0);
    } else {
      {
#line 506
      solns->step = -1;
#line 507
      rx_free_solutions(solns->left);
#line 508
      solns->left = (struct rx_solutions *)0;
      }
#line 509
      if (solns->start == solns->end) {
#line 509
        tmp___0 = 0;
      } else {
#line 509
        tmp___0 = 1;
      }
#line 509
      return ((enum rx_answers )tmp___0);
    }
    switch_break___3: /* CIL Label */ ;
    }
    case_2___1: /* CIL Label */ 
    {
#line 522
    if (solns->step == 1) {
#line 522
      goto case_1___2;
    }
#line 541
    if (solns->step == 2) {
#line 541
      goto case_2___2;
    }
#line 557
    if (solns->step == 3) {
#line 557
      goto case_3___0;
    }
#line 576
    if (solns->step == 4) {
#line 576
      goto case_4;
    }
#line 520
    goto switch_break___4;
    case_1___2: /* CIL Label */ 
    {
#line 523
    solns->left = rx_make_solutions(solns->regs, solns->verse, (solns->exp)->params.pair.left,
                                    solns->subexps, solns->cset_size, solns->start,
                                    solns->end, solns->vmfn, solns->contextfn, solns->closure);
    }
#line 533
    if (! solns->left) {
#line 535
      solns->step = -1;
#line 536
      return ((enum rx_answers )-1);
    }
#line 538
    solns->step = 2;
    case_2___2: /* CIL Label */ 
    {
#line 542
    alt_stat = rx_next_solution(solns->left);
    }
#line 544
    if ((int )alt_stat == 0) {
#line 546
      solns->final_tag = (solns->left)->final_tag;
#line 547
      return (alt_stat);
    } else {
      {
#line 551
      solns->step = 3;
#line 552
      rx_free_solutions(solns->left);
#line 553
      solns->left = (struct rx_solutions *)0;
      }
    }
    case_3___0: /* CIL Label */ 
    {
#line 558
    solns->right = rx_make_solutions(solns->regs, solns->verse, (solns->exp)->params.pair.right,
                                     solns->subexps, solns->cset_size, solns->start,
                                     solns->end, solns->vmfn, solns->contextfn, solns->closure);
    }
#line 568
    if (! solns->right) {
#line 570
      solns->step = -1;
#line 571
      return ((enum rx_answers )-1);
    }
#line 573
    solns->step = 4;
    case_4: /* CIL Label */ 
    {
#line 577
    alt_stat = rx_next_solution(solns->right);
    }
#line 579
    if ((int )alt_stat == 0) {
#line 581
      solns->final_tag = (solns->right)->final_tag;
#line 582
      return (alt_stat);
    } else {
      {
#line 586
      solns->step = -1;
#line 587
      rx_free_solutions(solns->right);
#line 588
      solns->right = (struct rx_solutions *)0;
      }
#line 589
      return (alt_stat);
    }
    switch_break___4: /* CIL Label */ ;
    }
    case_1___3: /* CIL Label */ 
    {
#line 599
    if (solns->step == 1) {
#line 599
      goto case_1___4;
    }
#line 620
    if (solns->step == 2) {
#line 620
      goto concat_try_next_left_match;
    }
#line 644
    if (solns->step == 3) {
#line 644
      goto case_3___1;
    }
#line 666
    if (solns->step == 4) {
#line 666
      goto case_4___0;
    }
#line 596
    goto switch_break___5;
    case_1___4: /* CIL Label */ 
#line 600
    solns->split_guess = solns->end;
    concat_split_guess_loop: 
    {
#line 603
    solns->left = rx_make_solutions(solns->regs, solns->verse, (solns->exp)->params.pair.left,
                                    solns->subexps, solns->cset_size, solns->start,
                                    solns->split_guess, solns->vmfn, solns->contextfn,
                                    solns->closure);
    }
#line 613
    if (! solns->left) {
#line 615
      solns->step = -1;
#line 616
      return ((enum rx_answers )-1);
    }
#line 618
    solns->step = 2;
    concat_try_next_left_match: 
    case_2___3: /* CIL Label */ 
    {
#line 623
    concat_stat = rx_next_solution(solns->left);
    }
#line 624
    if ((int )concat_stat != 0) {
      {
#line 626
      rx_free_solutions(solns->left);
#line 627
      rx_free_solutions(solns->right);
#line 628
      tmp___1 = (struct rx_solutions *)0;
#line 628
      solns->right = tmp___1;
#line 628
      solns->left = tmp___1;
#line 629
      (solns->split_guess) --;
      }
#line 630
      if (solns->split_guess >= solns->start) {
#line 631
        goto concat_split_guess_loop;
      } else {
#line 634
        solns->step = -1;
#line 635
        return (concat_stat);
      }
    } else {
#line 640
      solns->step = 3;
    }
    case_3___1: /* CIL Label */ 
    {
#line 645
    solns->right = rx_make_solutions(solns->regs, solns->verse, (solns->exp)->params.pair.right,
                                     solns->subexps, solns->cset_size, solns->split_guess,
                                     solns->end, solns->vmfn, solns->contextfn, solns->closure);
    }
#line 655
    if (! solns->right) {
      {
#line 657
      rx_free_solutions(solns->left);
#line 658
      solns->left = (struct rx_solutions *)0;
#line 659
      solns->step = -1;
      }
#line 660
      return ((enum rx_answers )-1);
    }
#line 663
    solns->step = 4;
    case_4___0: /* CIL Label */ 
    {
#line 669
    concat_stat = rx_next_solution(solns->right);
    }
#line 670
    if ((int )concat_stat == 0) {
#line 672
      solns->final_tag = (solns->right)->final_tag;
#line 673
      return (concat_stat);
    } else
#line 675
    if ((int )concat_stat == 1) {
      {
#line 677
      rx_free_solutions(solns->right);
#line 678
      solns->right = (struct rx_solutions *)0;
#line 679
      solns->step = 2;
      }
#line 680
      goto concat_try_next_left_match;
    } else {
      {
#line 684
      rx_free_solutions(solns->left);
#line 685
      solns->left = (struct rx_solutions *)0;
#line 686
      rx_free_solutions(solns->right);
#line 687
      solns->right = (struct rx_solutions *)0;
#line 688
      solns->step = -1;
      }
#line 689
      return (concat_stat);
    }
    switch_break___5: /* CIL Label */ ;
    }
    case_4___1: /* CIL Label */ 
    case_5: /* CIL Label */ 
    {
#line 701
    if (solns->step == 1) {
#line 701
      goto case_1___5;
    }
#line 722
    if (solns->step == 2) {
#line 722
      goto star_try_next_left_match;
    }
#line 761
    if (solns->step == 3) {
#line 761
      goto case_3___2;
    }
#line 783
    if (solns->step == 4) {
#line 783
      goto case_4___2;
    }
#line 698
    goto switch_break___6;
    case_1___5: /* CIL Label */ 
#line 702
    solns->split_guess = solns->end;
    star_split_guess_loop: 
    {
#line 705
    solns->left = rx_make_solutions(solns->regs, solns->verse, (solns->exp)->params.pair.left,
                                    solns->subexps, solns->cset_size, solns->start,
                                    solns->split_guess, solns->vmfn, solns->contextfn,
                                    solns->closure);
    }
#line 715
    if (! solns->left) {
#line 717
      solns->step = -1;
#line 718
      return ((enum rx_answers )-1);
    }
#line 720
    solns->step = 2;
    star_try_next_left_match: 
    case_2___4: /* CIL Label */ 
    {
#line 725
    star_stat = rx_next_solution(solns->left);
    }
#line 726
    if ((int )star_stat != 0) {
      {
#line 728
      rx_free_solutions(solns->left);
#line 729
      rx_free_solutions(solns->right);
#line 730
      tmp___2 = (struct rx_solutions *)0;
#line 730
      solns->right = tmp___2;
#line 730
      solns->left = tmp___2;
#line 731
      (solns->split_guess) --;
      }
#line 732
      if (solns->split_guess >= solns->start) {
#line 733
        goto star_split_guess_loop;
      } else {
#line 736
        solns->step = -1;
#line 738
        if ((unsigned int )(solns->exp)->type == 4U) {
#line 738
          if ((int )star_stat == 1) {
#line 741
            solns->final_tag = 1;
#line 742
            return ((enum rx_answers )0);
          } else {
#line 745
            return (star_stat);
          }
        } else {
#line 745
          return (star_stat);
        }
      }
    } else {
#line 750
      solns->step = 3;
    }
#line 755
    if (solns->split_guess == solns->end) {
#line 757
      solns->final_tag = (solns->left)->final_tag;
#line 758
      return ((enum rx_answers )0);
    }
    case_3___2: /* CIL Label */ 
    {
#line 762
    solns->right = rx_make_solutions(solns->regs, solns->verse, solns->exp, solns->subexps,
                                     solns->cset_size, solns->split_guess, solns->end,
                                     solns->vmfn, solns->contextfn, solns->closure);
    }
#line 772
    if (! solns->right) {
      {
#line 774
      rx_free_solutions(solns->left);
#line 775
      solns->left = (struct rx_solutions *)0;
#line 776
      solns->step = -1;
      }
#line 777
      return ((enum rx_answers )-1);
    }
#line 780
    solns->step = 4;
    case_4___2: /* CIL Label */ 
    {
#line 786
    star_stat = rx_next_solution(solns->right);
    }
#line 787
    if ((int )star_stat == 0) {
#line 789
      solns->final_tag = (solns->right)->final_tag;
#line 790
      return (star_stat);
    } else
#line 792
    if ((int )star_stat == 1) {
      {
#line 794
      rx_free_solutions(solns->right);
#line 795
      solns->right = (struct rx_solutions *)0;
#line 796
      solns->step = 2;
      }
#line 797
      goto star_try_next_left_match;
    } else {
      {
#line 801
      rx_free_solutions(solns->left);
#line 802
      solns->left = (struct rx_solutions *)0;
#line 803
      rx_free_solutions(solns->right);
#line 804
      solns->right = (struct rx_solutions *)0;
#line 805
      solns->step = -1;
      }
#line 806
      return (star_stat);
    }
    switch_break___6: /* CIL Label */ ;
    }
    case_10: /* CIL Label */ 
    {
#line 813
    solns->step = -1;
#line 814
    solns->final_tag = 1;
#line 815
    tmp___3 = (*(solns->contextfn))(solns->closure, solns->exp, solns->start, solns->end,
                                    solns->regs);
    }
#line 815
    return (tmp___3);
    case_8: /* CIL Label */ 
    {
#line 827
    if (solns->step == 1) {
#line 827
      goto case_1___6;
    }
#line 880
    if (solns->step == 2) {
#line 880
      goto interval_split_guess_loop;
    }
#line 905
    if (solns->step == 3) {
#line 905
      goto interval_try_next_left_match;
    }
#line 929
    if (solns->step == 4) {
#line 929
      goto case_4___3;
    }
#line 962
    if (solns->step == 5) {
#line 962
      goto case_5___0;
    }
#line 823
    goto switch_break___7;
    case_1___6: /* CIL Label */ 
#line 831
    if ((solns->exp)->params.intval2 < solns->interval_x) {
#line 833
      solns->step = -1;
#line 834
      return ((enum rx_answers )1);
    }
#line 841
    if ((solns->exp)->params.intval2 == solns->interval_x) {
#line 841
      if ((solns->exp)->params.intval <= solns->interval_x) {
#line 844
        solns->step = -1;
#line 845
        solns->final_tag = 1;
#line 846
        if (solns->start == solns->end) {
#line 846
          tmp___4 = 0;
        } else {
#line 846
          tmp___4 = 1;
        }
#line 846
        return ((enum rx_answers )tmp___4);
      }
    }
#line 854
    if ((solns->exp)->params.intval2 == solns->interval_x) {
#line 857
      solns->step = -1;
#line 858
      return ((enum rx_answers )-1);
    }
#line 861
    solns->split_guess = solns->end;
#line 867
    if ((solns->exp)->params.intval <= solns->interval_x) {
#line 869
      solns->step = 2;
#line 870
      if (solns->start == solns->end) {
#line 872
        solns->final_tag = 1;
#line 873
        return ((enum rx_answers )0);
      }
    }
    interval_split_guess_loop: 
    case_2___5: /* CIL Label */ 
    {
#line 888
    solns->left = rx_make_solutions(solns->regs, solns->verse, (solns->exp)->params.pair.left,
                                    solns->subexps, solns->cset_size, solns->start,
                                    solns->split_guess, solns->vmfn, solns->contextfn,
                                    solns->closure);
    }
#line 898
    if (! solns->left) {
#line 900
      solns->step = -1;
#line 901
      return ((enum rx_answers )-1);
    }
#line 903
    solns->step = 3;
    interval_try_next_left_match: 
    case_3___3: /* CIL Label */ 
    {
#line 908
    interval_stat = rx_next_solution(solns->left);
    }
#line 909
    if ((int )interval_stat != 0) {
      {
#line 911
      rx_free_solutions(solns->left);
#line 912
      rx_free_solutions(solns->right);
#line 913
      tmp___5 = (struct rx_solutions *)0;
#line 913
      solns->right = tmp___5;
#line 913
      solns->left = tmp___5;
#line 914
      (solns->split_guess) --;
      }
#line 915
      if (solns->split_guess >= solns->start) {
#line 916
        goto interval_split_guess_loop;
      } else {
#line 919
        solns->step = -1;
#line 920
        return (interval_stat);
      }
    } else {
#line 925
      solns->step = 4;
    }
    case_4___3: /* CIL Label */ 
    {
#line 939
    solns->right = rx_make_solutions(solns->regs, solns->verse, solns->exp, solns->subexps,
                                     solns->cset_size, solns->split_guess, solns->end,
                                     solns->vmfn, solns->contextfn, solns->closure);
#line 949
    (solns->right)->interval_x = solns->interval_x + 1;
    }
#line 951
    if (! solns->right) {
      {
#line 953
      rx_free_solutions(solns->left);
#line 954
      solns->left = (struct rx_solutions *)0;
#line 955
      solns->step = -1;
      }
#line 956
      return ((enum rx_answers )-1);
    }
#line 959
    solns->step = 5;
    case_5___0: /* CIL Label */ 
    {
#line 965
    interval_stat = rx_next_solution(solns->right);
    }
#line 966
    if ((int )interval_stat == 0) {
#line 968
      solns->final_tag = (solns->right)->final_tag;
#line 969
      return (interval_stat);
    } else
#line 971
    if ((int )interval_stat == 1) {
      {
#line 973
      rx_free_solutions(solns->right);
#line 974
      solns->right = (struct rx_solutions *)0;
#line 975
      solns->step = 2;
      }
#line 976
      goto interval_try_next_left_match;
    } else {
      {
#line 980
      rx_free_solutions(solns->left);
#line 981
      solns->left = (struct rx_solutions *)0;
#line 982
      rx_free_solutions(solns->right);
#line 983
      solns->right = (struct rx_solutions *)0;
#line 984
      solns->step = -1;
      }
#line 985
      return (interval_stat);
    }
    switch_break___7: /* CIL Label */ ;
    }
    switch_break___1: /* CIL Label */ ;
    }
    switch_break: /* CIL Label */ ;
    }
#line 991
    return ((enum rx_answers )-1);
  }
#line 993
  return ((enum rx_answers )0);
}
}
#line 32 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxcset.h"
rx_Bitset rx_copy_cset(int size , rx_Bitset a ) ;
#line 92 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnode.h"
struct rexp_node *rexp_node(int type ) ;
#line 81 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxsimp.c"
extern int ( /* missing proto */  isdigit)() ;
#line 30 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxsimp.c"
int rx_simple_rexp(struct rexp_node **answer , int cset_size , struct rexp_node *node ,
                   struct rexp_node **subexps ) 
{ 
  int stat___0 ;
  int tmp ;
  struct rexp_node *n ;
  int s___0 ;

  {
#line 46
  if (! node) {
#line 48
    *answer = (struct rexp_node *)0;
#line 49
    return (0);
  }
#line 52
  if (! node->observed) {
    {
#line 54
    rx_save_rexp(node);
#line 55
    *answer = node;
    }
#line 56
    return (0);
  }
#line 59
  if (node->simplified) {
    {
#line 61
    rx_save_rexp(node->simplified);
#line 62
    *answer = node->simplified;
    }
#line 63
    return (0);
  }
  {
#line 74
  if ((unsigned int )node->type == 9U) {
#line 74
    goto case_9;
  }
#line 80
  if ((unsigned int )node->type == 10U) {
#line 80
    goto case_10;
  }
#line 97
  if ((unsigned int )node->type == 8U) {
#line 97
    goto case_8;
  }
#line 97
  if ((unsigned int )node->type == 5U) {
#line 97
    goto case_8;
  }
#line 97
  if ((unsigned int )node->type == 4U) {
#line 97
    goto case_8;
  }
#line 97
  if ((unsigned int )node->type == 3U) {
#line 97
    goto case_8;
  }
#line 97
  if ((unsigned int )node->type == 2U) {
#line 97
    goto case_8;
  }
#line 97
  if ((unsigned int )node->type == 1U) {
#line 97
    goto case_8;
  }
#line 68
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 72
  return (-2);
  case_9: /* CIL Label */ 
  {
#line 75
  stat___0 = rx_simple_rexp(answer, cset_size, node->params.pair.left, subexps);
  }
#line 78
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 81
  tmp = isdigit(node->params.intval);
  }
#line 81
  if (tmp) {
    {
#line 82
    stat___0 = rx_simple_rexp(answer, cset_size, *(subexps + (node->params.intval - 48)),
                              subexps);
    }
  } else {
#line 87
    *answer = (struct rexp_node *)0;
#line 88
    stat___0 = 0;
  }
#line 90
  goto switch_break;
  case_8: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 100
  n = rexp_node((int )node->type);
  }
#line 101
  if (! n) {
#line 102
    return (-1);
  }
#line 104
  if (node->params.cset) {
    {
#line 106
    n->params.cset = rx_copy_cset(cset_size, node->params.cset);
    }
#line 108
    if (! n->params.cset) {
      {
#line 110
      rx_free_rexp(n);
      }
#line 111
      return (-1);
    }
  }
  {
#line 114
  n->params.intval = node->params.intval;
#line 115
  n->params.intval2 = node->params.intval2;
#line 119
  s___0 = rx_simple_rexp(& n->params.pair.left, cset_size, node->params.pair.left,
                         subexps);
  }
#line 121
  if (! s___0) {
    {
#line 122
    s___0 = rx_simple_rexp(& n->params.pair.right, cset_size, node->params.pair.right,
                           subexps);
    }
  }
#line 124
  if (! s___0) {
#line 126
    *answer = n;
#line 127
    stat___0 = 0;
  } else {
    {
#line 131
    rx_free_rexp(n);
#line 132
    stat___0 = s___0;
    }
  }
#line 136
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 139
  if (! stat___0) {
    {
#line 141
    node->simplified = *answer;
#line 142
    rx_save_rexp(node->simplified);
    }
  }
#line 144
  return (stat___0);
}
}
#line 127 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 130
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 397
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 51 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxanal.h"
int rx_posix_analyze_rexp(struct rexp_node ***subexps , size_t *n_subexps , struct rexp_node *node ,
                          int id ) ;
#line 55
int rx_fill_in_fastmap(int cset_size , unsigned char *map , struct rexp_node *exp___0 ) ;
#line 56
int rx_is_anchored_p(struct rexp_node *exp___0 ) ;
#line 101 "/home/wslee/gnu_benchmarks/guile-1.0/rx/inst-rxposix.h"
int regncomp(regex_t *preg , int len , char const   *pattern , int cflags ) ;
#line 102
int regcomp(regex_t *preg , char const   *pattern , int cflags ) ;
#line 103
size_t regerror(int errcode , regex_t const   *preg , char *errbuf , size_t errbuf_size ) ;
#line 105
int regnexec(regex_t const   *preg , int len , char const   *string , size_t nmatch ,
             regmatch_t **pmatch , int eflags ) ;
#line 106
int regexec(regex_t const   *preg , char const   *string , size_t nmatch , regmatch_t *pmatch ,
            int eflags ) ;
#line 107
void regfree(regex_t *preg ) ;
#line 33 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxgnucomp.h"
char const   *rx_error_msg[17] ;
#line 240
reg_errcode_t rx_parse(struct rexp_node **rexp_p , char const   *pattern , int size ,
                       unsigned long syntax , int cset_size , unsigned char *translate ) ;
#line 33 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxbasic.h"
struct rx_solutions *rx_basic_make_solutions(struct rx_registers *regs , struct rexp_node *expression ,
                                             struct rexp_node **subexps , int start ,
                                             int end , struct rx_context_rules *rules ,
                                             unsigned char const   *str ) ;
#line 34
void rx_basic_free_solutions(struct rx_solutions *solns ) ;
#line 87 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxposix.c"
extern int ( /* missing proto */  isupper)() ;
#line 87
extern int ( /* missing proto */  tolower)() ;
#line 56 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxposix.c"
int regncomp(regex_t *preg , int len , char const   *pattern , int cflags ) 
{ 
  reg_errcode_t ret ;
  unsigned int syntax ;
  unsigned int i ;
  void *tmp ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 70
  rx_bzero((char *)preg, sizeof(*preg));
  }
#line 71
  if (cflags & 1) {
#line 71
    syntax = (unsigned int )((((((((((((1 << 1) << 1) | ((((((1 << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((1 << 1) << 1) << 1)) | ((((1 << 1) << 1) << 1) << 1)) | ((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
  } else {
#line 71
    syntax = (unsigned int )(((((((1 << 1) << 1) | ((((((1 << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (1 << 1));
  }
#line 75
  if (! (cflags & (1 << 1))) {
#line 76
    preg->translate = (unsigned char *)0;
  } else {
    {
#line 81
    tmp = malloc((size_t )256);
#line 81
    preg->translate = (unsigned char *)tmp;
    }
#line 82
    if (! preg->translate) {
#line 83
      return (12);
    }
#line 86
    i = 0U;
    {
#line 86
    while (1) {
      while_continue: /* CIL Label */ ;
#line 86
      if (! (i < (unsigned int )(1 << 8))) {
#line 86
        goto while_break;
      }
      {
#line 87
      tmp___2 = isupper(i);
      }
#line 87
      if (tmp___2) {
        {
#line 87
        tmp___1 = tolower(i);
#line 87
        *(preg->translate + i) = (unsigned char )tmp___1;
        }
      } else {
#line 87
        *(preg->translate + i) = (unsigned char )i;
      }
#line 86
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 92
  if (! (cflags & ((1 << 1) << 1))) {
#line 93
    preg->newline_anchor = 0U;
  } else {
#line 97
    syntax &= (unsigned int )(~ ((((((1 << 1) << 1) << 1) << 1) << 1) << 1));
#line 98
    syntax |= (unsigned int )((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);
#line 100
    preg->newline_anchor = 1U;
  }
  {
#line 103
  preg->no_sub = (unsigned int )(! (! (cflags & (((1 << 1) << 1) << 1))));
#line 105
  ret = rx_parse(& preg->pattern, pattern, len, (unsigned long )syntax, 256, preg->translate);
  }
#line 114
  if ((unsigned int )ret == 16U) {
#line 115
    ret = (reg_errcode_t )8;
  }
#line 117
  if (! ret) {
    {
#line 119
    preg->n_subexps = (size_t )1;
#line 120
    preg->subexps = (struct rexp_node **)0;
#line 121
    rx_posix_analyze_rexp(& preg->subexps, & preg->n_subexps, preg->pattern, 0);
#line 125
    tmp___3 = rx_fill_in_fastmap(256, preg->fastmap, preg->pattern);
#line 125
    preg->is_nullable = (unsigned int )tmp___3;
#line 129
    tmp___4 = rx_is_anchored_p(preg->pattern);
#line 129
    preg->is_anchored = (unsigned int )tmp___4;
    }
  }
#line 132
  return ((int )ret);
}
}
#line 137 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxposix.c"
int regcomp(regex_t *preg , char const   *pattern , int cflags ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 151
  tmp = strlen(pattern);
#line 151
  tmp___0 = regncomp(preg, (int )tmp, pattern, cflags);
  }
#line 151
  return (tmp___0);
}
}
#line 161 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxposix.c"
size_t regerror(int errcode , regex_t const   *preg , char *errbuf , size_t errbuf_size ) 
{ 
  char const   *msg ;
  size_t msg_size ;
  size_t tmp ;
  char *__cil_tmp8 ;

  {
#line 176
  if ((unsigned long )rx_error_msg[errcode] == (unsigned long )((char const   *)0)) {
#line 176
    msg = "Success";
  } else {
#line 176
    msg = rx_error_msg[errcode];
  }
  {
#line 177
  tmp = strlen(msg);
#line 177
  msg_size = tmp + 1UL;
  }
#line 178
  if (errbuf_size != 0UL) {
#line 180
    if (msg_size > errbuf_size) {
      {
#line 182
      strncpy((char */* __restrict  */)errbuf, (char const   */* __restrict  */)msg,
              errbuf_size - 1UL);
#line 183
      *(errbuf + (errbuf_size - 1UL)) = (char)0;
      }
    } else {
      {
#line 186
      strcpy((char */* __restrict  */)errbuf, (char const   */* __restrict  */)msg);
      }
    }
  }
#line 188
  return (msg_size);
}
}
#line 194 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxposix.c"
int rx_regmatch(regmatch_t *pmatch , regex_t const   *preg , struct rx_context_rules *rules ,
                int start , int end , char const   *string ) 
{ 
  struct rx_solutions *solutions ;
  enum rx_answers answer ;
  struct rx_context_rules local_rules ;
  int orig_end ;
  int end_lower_bound ;
  int end_upper_bound ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp15 ;

  {
#line 214
  local_rules = *rules;
#line 215
  orig_end = end;
#line 217
  if (! preg->pattern) {
#line 219
    end_lower_bound = start;
#line 220
    end_upper_bound = start;
  } else
#line 222
  if ((preg->pattern)->len >= 0) {
#line 224
    end_lower_bound = start + (preg->pattern)->len;
#line 225
    end_upper_bound = start + (preg->pattern)->len;
  } else {
#line 229
    end_lower_bound = start;
#line 230
    end_upper_bound = end;
  }
#line 232
  end = end_upper_bound;
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 233
    if (! (end >= end_lower_bound)) {
#line 233
      goto while_break;
    }
#line 235
    if (rules->not_eol) {
#line 235
      if (end == orig_end) {
#line 235
        tmp = 1;
      } else
#line 235
      if (! local_rules.newline_anchor) {
#line 235
        tmp = 1;
      } else
#line 235
      if ((int const   )*(string + end) != 10) {
#line 235
        tmp = 1;
      } else {
#line 235
        tmp = 0;
      }
#line 235
      local_rules.not_eol = (unsigned int )tmp;
    } else {
#line 235
      if (end != orig_end) {
#line 235
        if (! local_rules.newline_anchor) {
#line 235
          tmp___0 = 1;
        } else
#line 235
        if ((int const   )*(string + end) != 10) {
#line 235
          tmp___0 = 1;
        } else {
#line 235
          tmp___0 = 0;
        }
      } else {
#line 235
        tmp___0 = 0;
      }
#line 235
      local_rules.not_eol = (unsigned int )tmp___0;
    }
    {
#line 242
    solutions = rx_basic_make_solutions(pmatch, (struct rexp_node *)preg->pattern,
                                        (struct rexp_node **)preg->subexps, start,
                                        end, & local_rules, (unsigned char const   *)string);
    }
#line 244
    if (! solutions) {
#line 245
      return (12);
    }
    {
#line 247
    answer = rx_next_solution(solutions);
    }
#line 249
    if ((int )answer == 0) {
#line 251
      if (pmatch) {
#line 253
        (pmatch + 0)->rm_so = start;
#line 254
        (pmatch + 0)->rm_eo = end;
#line 255
        (pmatch + 0)->final_tag = solutions->final_tag;
      }
      {
#line 257
      rx_basic_free_solutions(solutions);
      }
#line 258
      return (0);
    } else {
      {
#line 261
      rx_basic_free_solutions(solutions);
      }
    }
#line 263
    end --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 272
  if ((int )answer == 1) {
#line 272
    goto case_1;
  }
#line 268
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 270
  return (12);
  case_1: /* CIL Label */ 
#line 273
  return (1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 279 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxposix.c"
int rx_regexec(regmatch_t *pmatch , regex_t const   *preg , struct rx_context_rules *rules ,
               int start , int end , char const   *string ) 
{ 
  int x ;
  int stat___0 ;
  int anchored ;

  {
#line 296
  anchored = (int )preg->is_anchored;
#line 297
  x = start;
  {
#line 297
  while (1) {
    while_continue: /* CIL Label */ ;
#line 297
    if (! (x <= end)) {
#line 297
      goto while_break;
    }
#line 299
    if (preg->is_nullable) {
#line 299
      goto _L;
    } else
#line 299
    if (x < end) {
#line 299
      if (preg->fastmap[*((unsigned char *)string + x)]) {
        _L: /* CIL Label */ 
        {
#line 302
        stat___0 = rx_regmatch(pmatch, preg, rules, x, end, string);
        }
#line 303
        if (! stat___0) {
#line 304
          return (stat___0);
        } else
#line 303
        if (stat___0 != 1) {
#line 304
          return (stat___0);
        }
      }
    }
#line 306
    if (anchored) {
#line 308
      if (rules->newline_anchor) {
        {
#line 310
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 310
          if (x < end) {
#line 310
            if (! ((int const   )*(string + x) != 10)) {
#line 310
              goto while_break___0;
            }
          } else {
#line 310
            goto while_break___0;
          }
#line 311
          x ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
#line 314
        return (1);
      }
    }
#line 297
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 317
  return (1);
}
}
#line 338 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxposix.c"
int regnexec(regex_t const   *preg , int len , char const   *string , size_t nmatch ,
             regmatch_t **pmatch , int eflags ) 
{ 
  int want_reg_info ;
  struct rx_context_rules rules ;
  regmatch_t *regs ;
  size_t nregs ;
  int stat___0 ;
  int tmp ;
  void *tmp___0 ;
  int x ;
  regoff_t tmp___1 ;
  size_t x___0 ;
  void *__cil_tmp17 ;

  {
#line 357
  if (! preg->no_sub) {
#line 357
    if (nmatch > 0UL) {
#line 357
      tmp = 1;
    } else {
#line 357
      tmp = 0;
    }
  } else {
#line 357
    tmp = 0;
  }
#line 357
  want_reg_info = tmp;
#line 359
  rules.newline_anchor = (unsigned int )preg->newline_anchor;
#line 360
  rules.not_bol = (unsigned int )(! (! (eflags & 1)));
#line 361
  rules.not_eol = (unsigned int )(! (! (eflags & (1 << 1))));
#line 362
  rules.case_indep = (unsigned int )(! (! (eflags & (1 << 1))));
#line 364
  if (nmatch >= (size_t )preg->n_subexps) {
#line 366
    regs = *pmatch;
#line 367
    nregs = nmatch;
  } else {
    {
#line 371
    tmp___0 = malloc((size_t )(preg->n_subexps * (size_t const   )sizeof(*regs)));
#line 371
    regs = (regmatch_t *)tmp___0;
    }
#line 372
    if (! regs) {
#line 373
      return (12);
    }
#line 374
    nregs = (size_t )preg->n_subexps;
  }
#line 379
  x = 0;
  {
#line 379
  while (1) {
    while_continue: /* CIL Label */ ;
#line 379
    if (! ((size_t )x < nregs)) {
#line 379
      goto while_break;
    }
#line 380
    tmp___1 = -1;
#line 380
    (regs + x)->rm_eo = tmp___1;
#line 380
    (regs + x)->rm_so = tmp___1;
#line 379
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 384
  stat___0 = rx_regexec(regs, preg, & rules, 0, len, string);
  }
#line 386
  if (! stat___0) {
#line 386
    if (want_reg_info) {
#line 386
      if (pmatch) {
#line 386
        if ((unsigned long )regs != (unsigned long )*pmatch) {
#line 389
          x___0 = (size_t )0;
          {
#line 389
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 389
            if (! (x___0 < nmatch)) {
#line 389
              goto while_break___0;
            }
#line 390
            *(*pmatch + x___0) = *(regs + x___0);
#line 389
            x___0 ++;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
    }
  }
#line 393
  if (! stat___0) {
#line 393
    if (eflags & ((1 << 1) << 1)) {
#line 394
      *pmatch = regs;
    } else {
#line 393
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 395
  if ((unsigned long )regs != (unsigned long )*pmatch) {
    {
#line 396
    free((void *)regs);
    }
  }
#line 398
  return (stat___0);
}
}
#line 402 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxposix.c"
int regexec(regex_t const   *preg , char const   *string , size_t nmatch , regmatch_t *pmatch ,
            int eflags ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 414
  tmp = strlen(string);
#line 414
  tmp___0 = regnexec(preg, (int )tmp, string, nmatch, & pmatch, eflags & ~ ((1 << 1) << 1));
  }
#line 414
  return (tmp___0);
}
}
#line 426 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxposix.c"
void regfree(regex_t *preg ) 
{ 


  {
#line 434
  if (preg->pattern) {
    {
#line 436
    rx_free_rexp(preg->pattern);
#line 437
    preg->pattern = (struct rexp_node *)0;
    }
  }
#line 439
  if (preg->subexps) {
    {
#line 441
    free((void *)preg->subexps);
#line 442
    preg->subexps = (struct rexp_node **)0;
    }
  }
#line 444
  if ((unsigned long )preg->translate != (unsigned long )((unsigned char *)0)) {
    {
#line 446
    free((void *)preg->translate);
#line 447
    preg->translate = (unsigned char *)0;
    }
  }
#line 449
  return;
}
}
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 67
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) memcmp)(void const   *__s1 ,
                                                                                     void const   *__s2 ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
#line 485 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
#line 72 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxbitset.h"
int rx_bitset_is_equal(int size , rx_Bitset a , rx_Bitset b ) ;
#line 86
unsigned long rx_bitset_hash(int size , rx_Bitset b ) ;
#line 33 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxcset.h"
void rx_free_cset(rx_Bitset c ) ;
#line 91 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnode.h"
int rx_adjoin_string(struct rx_string *str , char c ) ;
#line 93
struct rexp_node *rx_mk_r_cset(int type , int size , rx_Bitset b ) ;
#line 94
struct rexp_node *rx_mk_r_int(int type , int intval ) ;
#line 95
struct rexp_node *rx_mk_r_str(int type , char c ) ;
#line 96
struct rexp_node *rx_mk_r_binop(int type , struct rexp_node *a , struct rexp_node *b ) ;
#line 97
struct rexp_node *rx_mk_r_monop(int type , struct rexp_node *a ) ;
#line 100
struct rexp_node *rx_copy_rexp(int cset_size , struct rexp_node *node ) ;
#line 101
struct rexp_node *rx_shallow_copy_rexp(int cset_size , struct rexp_node *node ) ;
#line 36 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnode.c"
static int rx_init_string(struct rx_string *thisone , char first___0 ) 
{ 
  char *tmp ;
  void *tmp___0 ;

  {
  {
#line 47
  tmp___0 = malloc((size_t )8);
#line 47
  tmp = (char *)tmp___0;
  }
#line 49
  if (! tmp) {
#line 50
    return (-1);
  }
#line 52
  thisone->contents = (unsigned char *)tmp;
#line 53
  *(thisone->contents + 0) = (unsigned char )first___0;
#line 54
  thisone->reallen = 8UL;
#line 55
  thisone->len = 1UL;
#line 56
  return (0);
}
}
#line 60 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnode.c"
static void rx_free_string(struct rx_string *junk ) 
{ 
  unsigned long tmp ;

  {
  {
#line 68
  free((void *)junk->contents);
#line 69
  tmp = 0UL;
#line 69
  junk->reallen = tmp;
#line 69
  junk->len = tmp;
#line 70
  junk->contents = (unsigned char *)0;
  }
#line 71
  return;
}
}
#line 75 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnode.c"
int rx_adjoin_string(struct rx_string *str , char c ) 
{ 
  int tmp ;
  char *temp ;
  void *tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 84
  if (! str->contents) {
    {
#line 85
    tmp = rx_init_string(str, c);
    }
#line 85
    return (tmp);
  }
#line 87
  if (str->len == str->reallen) {
    {
#line 90
    tmp___0 = realloc((void *)str->contents, str->reallen + 8UL);
#line 90
    temp = (char *)tmp___0;
    }
#line 92
    if (! temp) {
#line 93
      return (-1);
    }
#line 95
    str->contents = (unsigned char *)temp;
#line 96
    str->reallen += 8UL;
  }
#line 99
  tmp___1 = str->len;
#line 99
  (str->len) ++;
#line 99
  *(str->contents + tmp___1) = (unsigned char )c;
#line 100
  return (0);
}
}
#line 105 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnode.c"
static int rx_copy_string(struct rx_string *to , struct rx_string *from ) 
{ 
  char *tmp ;
  void *tmp___0 ;

  {
#line 116
  if (from->len) {
    {
#line 118
    tmp___0 = malloc(from->reallen);
#line 118
    tmp = (char *)tmp___0;
    }
#line 120
    if (! tmp) {
#line 121
      return (-1);
    }
  }
  {
#line 124
  rx_free_string(to);
#line 125
  to->len = from->len;
#line 126
  to->reallen = from->reallen;
#line 127
  to->contents = (unsigned char *)tmp;
#line 129
  memcpy((void */* __restrict  */)to->contents, (void const   */* __restrict  */)from->contents,
         from->reallen);
  }
#line 131
  return (0);
}
}
#line 136 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnode.c"
static int rx_compare_rx_strings(struct rx_string *a , struct rx_string *b ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 145
  if (a->len != b->len) {
#line 146
    return (0);
  }
#line 148
  if (a->len) {
    {
#line 149
    tmp = memcmp((void const   *)a->contents, (void const   *)b->contents, a->len);
    }
#line 149
    if (tmp) {
#line 149
      tmp___0 = 0;
    } else {
#line 149
      tmp___0 = 1;
    }
#line 149
    return (tmp___0);
  } else {
#line 151
    return (1);
  }
}
}
#line 156 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnode.c"
static unsigned long rx_string_hash(unsigned long seed , struct rx_string *str ) 
{ 
  unsigned long result ;
  int c ;
  char *string ;
  int len ;
  int tmp ;

  {
#line 171
  string = (char *)str->contents;
#line 172
  len = (int )str->len;
#line 173
  result = seed;
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    tmp = len;
#line 175
    len --;
#line 175
    if (! tmp) {
#line 175
      goto while_break;
    }
#line 177
    c = (int )*string;
#line 178
    string ++;
#line 179
    result += (result << 3) + (unsigned long )c;
  }
  while_break: /* CIL Label */ ;
  }
#line 181
  return (result);
}
}
#line 188 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnode.c"
struct rexp_node *rexp_node(int type ) 
{ 
  struct rexp_node *n ;
  void *tmp ;
  void *__cil_tmp4 ;
  void *__cil_tmp5 ;
  void *__cil_tmp6 ;

  {
  {
#line 198
  tmp = malloc(sizeof(*n));
#line 198
  n = (struct rexp_node *)tmp;
#line 199
  rx_bzero((char *)n, sizeof(*n));
  }
#line 200
  if (n) {
#line 202
    n->type = (enum rexp_node_type )type;
#line 203
    n->id = -1;
#line 204
    n->refs = 1;
  }
#line 206
  return (n);
}
}
#line 215 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnode.c"
struct rexp_node *rx_mk_r_cset(int type , int size , rx_Bitset b ) 
{ 
  struct rexp_node *n ;

  {
  {
#line 226
  n = rexp_node(type);
  }
#line 227
  if (n) {
#line 229
    n->params.cset = b;
#line 230
    n->params.cset_size = size;
  }
#line 232
  return (n);
}
}
#line 237 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnode.c"
struct rexp_node *rx_mk_r_int(int type , int intval ) 
{ 
  struct rexp_node *n ;

  {
  {
#line 247
  n = rexp_node(type);
  }
#line 248
  if (n) {
#line 249
    n->params.intval = intval;
  }
#line 250
  return (n);
}
}
#line 255 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnode.c"
struct rexp_node *rx_mk_r_str(int type , char c ) 
{ 
  struct rexp_node *n ;

  {
  {
#line 265
  n = rexp_node(type);
  }
#line 266
  if (n) {
    {
#line 267
    rx_init_string(& n->params.cstr, c);
    }
  }
#line 268
  return (n);
}
}
#line 273 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnode.c"
struct rexp_node *rx_mk_r_binop(int type , struct rexp_node *a , struct rexp_node *b ) 
{ 
  struct rexp_node *n ;
  struct rexp_node *tmp ;

  {
  {
#line 283
  tmp = rexp_node(type);
#line 283
  n = tmp;
  }
#line 284
  if (n) {
#line 286
    n->params.pair.left = a;
#line 287
    n->params.pair.right = b;
  }
#line 289
  return (n);
}
}
#line 294 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnode.c"
struct rexp_node *rx_mk_r_monop(int type , struct rexp_node *a ) 
{ 
  struct rexp_node *tmp ;

  {
  {
#line 303
  tmp = rx_mk_r_binop(type, a, (struct rexp_node *)0);
  }
#line 303
  return (tmp);
}
}
#line 308 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnode.c"
void rx_free_rexp(struct rexp_node *node ) 
{ 


  {
#line 316
  if (node) {
#line 316
    (node->refs) --;
#line 316
    if (! node->refs) {
#line 318
      if (node->params.cset) {
        {
#line 319
        rx_free_cset(node->params.cset);
        }
      }
#line 320
      if (node->params.cstr.reallen) {
        {
#line 321
        rx_free_string(& node->params.cstr);
        }
      }
      {
#line 322
      rx_free_rexp(node->params.pair.left);
#line 323
      rx_free_rexp(node->params.pair.right);
#line 324
      rx_free_rexp(node->simplified);
#line 325
      free((void *)((char *)node));
      }
    }
  }
#line 327
  return;
}
}
#line 330 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnode.c"
void rx_save_rexp(struct rexp_node *node ) 
{ 


  {
#line 338
  if (node) {
#line 339
    (node->refs) ++;
  }
#line 340
  return;
}
}
#line 344 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnode.c"
struct rexp_node *rx_copy_rexp(int cset_size , struct rexp_node *node ) 
{ 
  struct rexp_node *n ;
  int tmp ;

  {
#line 353
  if (! node) {
#line 354
    return ((struct rexp_node *)0);
  } else {
    {
#line 358
    n = rexp_node((int )node->type);
    }
#line 359
    if (! n) {
#line 360
      return ((struct rexp_node *)0);
    }
#line 362
    if (node->params.cset) {
      {
#line 364
      n->params.cset = rx_copy_cset(cset_size, node->params.cset);
      }
#line 366
      if (! n->params.cset) {
        {
#line 368
        rx_free_rexp(n);
        }
#line 369
        return ((struct rexp_node *)0);
      }
    }
#line 373
    if (node->params.cstr.reallen) {
      {
#line 374
      tmp = rx_copy_string(& n->params.cstr, & node->params.cstr);
      }
#line 374
      if (tmp) {
        {
#line 376
        rx_free_rexp(n);
        }
#line 377
        return ((struct rexp_node *)0);
      }
    }
    {
#line 380
    n->params.intval = node->params.intval;
#line 381
    n->params.intval2 = node->params.intval2;
#line 382
    n->params.pair.left = rx_copy_rexp(cset_size, node->params.pair.left);
#line 383
    n->params.pair.right = rx_copy_rexp(cset_size, node->params.pair.right);
    }
#line 384
    if (node->params.pair.left) {
#line 384
      if (! n->params.pair.left) {
        {
#line 387
        rx_free_rexp(n);
        }
#line 388
        return ((struct rexp_node *)0);
      } else {
#line 384
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 384
    if (node->params.pair.right) {
#line 384
      if (! n->params.pair.right) {
        {
#line 387
        rx_free_rexp(n);
        }
#line 388
        return ((struct rexp_node *)0);
      }
    }
#line 390
    n->id = node->id;
#line 391
    n->len = node->len;
#line 392
    n->observed = node->observed;
#line 393
    return (n);
  }
}
}
#line 400 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnode.c"
struct rexp_node *rx_shallow_copy_rexp(int cset_size , struct rexp_node *node ) 
{ 
  struct rexp_node *n ;
  int tmp ;

  {
#line 409
  if (! node) {
#line 410
    return ((struct rexp_node *)0);
  } else {
    {
#line 414
    n = rexp_node((int )node->type);
    }
#line 415
    if (! n) {
#line 416
      return ((struct rexp_node *)0);
    }
#line 418
    if (node->params.cset) {
      {
#line 420
      n->params.cset = rx_copy_cset(cset_size, node->params.cset);
      }
#line 422
      if (! n->params.cset) {
        {
#line 424
        rx_free_rexp(n);
        }
#line 425
        return ((struct rexp_node *)0);
      }
    }
#line 429
    if (node->params.cstr.reallen) {
      {
#line 430
      tmp = rx_copy_string(& n->params.cstr, & node->params.cstr);
      }
#line 430
      if (tmp) {
        {
#line 432
        rx_free_rexp(n);
        }
#line 433
        return ((struct rexp_node *)0);
      }
    }
    {
#line 436
    n->params.intval = node->params.intval;
#line 437
    n->params.intval2 = node->params.intval2;
#line 438
    n->params.pair.left = node->params.pair.left;
#line 439
    rx_save_rexp(node->params.pair.left);
#line 440
    n->params.pair.right = node->params.pair.right;
#line 441
    rx_save_rexp(node->params.pair.right);
#line 442
    n->id = node->id;
#line 443
    n->len = node->len;
#line 444
    n->observed = node->observed;
    }
#line 445
    return (n);
  }
}
}
#line 453 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnode.c"
int rx_rexp_equal(struct rexp_node *a , struct rexp_node *b ) 
{ 
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 464
  if ((unsigned long )a == (unsigned long )b) {
#line 465
    return (1);
  }
#line 467
  if ((unsigned long )a == (unsigned long )((struct rexp_node *)0)) {
#line 468
    return (0);
  } else
#line 467
  if ((unsigned long )b == (unsigned long )((struct rexp_node *)0)) {
#line 468
    return (0);
  }
#line 470
  if ((unsigned int )a->type != (unsigned int )b->type) {
#line 471
    return (0);
  }
  {
#line 475
  if ((unsigned int )a->type == 0U) {
#line 475
    goto case_0;
  }
#line 482
  if ((unsigned int )a->type == 6U) {
#line 482
    goto case_6;
  }
#line 486
  if ((unsigned int )a->type == 7U) {
#line 486
    goto case_7;
  }
#line 491
  if ((unsigned int )a->type == 2U) {
#line 491
    goto case_2;
  }
#line 491
  if ((unsigned int )a->type == 1U) {
#line 491
    goto case_2;
  }
#line 497
  if ((unsigned int )a->type == 5U) {
#line 497
    goto case_5;
  }
#line 497
  if ((unsigned int )a->type == 4U) {
#line 497
    goto case_5;
  }
#line 497
  if ((unsigned int )a->type == 3U) {
#line 497
    goto case_5;
  }
#line 500
  if ((unsigned int )a->type == 8U) {
#line 500
    goto case_8;
  }
#line 504
  if ((unsigned int )a->type == 9U) {
#line 504
    goto case_9;
  }
#line 509
  if ((unsigned int )a->type == 10U) {
#line 509
    goto case_10;
  }
#line 512
  goto switch_default;
  case_0: /* CIL Label */ 
#line 476
  if (a->params.cset_size == b->params.cset_size) {
    {
#line 476
    tmp = rx_bitset_is_equal(a->params.cset_size, a->params.cset, b->params.cset);
    }
#line 476
    if (tmp) {
#line 476
      tmp___0 = 1;
    } else {
#line 476
      tmp___0 = 0;
    }
  } else {
#line 476
    tmp___0 = 0;
  }
#line 476
  ret = tmp___0;
#line 480
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 483
  ret = rx_compare_rx_strings(& a->params.cstr, & b->params.cstr);
  }
#line 484
  goto switch_break;
  case_7: /* CIL Label */ 
#line 487
  ret = a->params.intval == b->params.intval;
#line 488
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 492
  tmp___1 = rx_rexp_equal(a->params.pair.left, b->params.pair.left);
  }
#line 492
  if (tmp___1) {
    {
#line 492
    tmp___2 = rx_rexp_equal(a->params.pair.right, b->params.pair.right);
    }
#line 492
    if (tmp___2) {
#line 492
      tmp___3 = 1;
    } else {
#line 492
      tmp___3 = 0;
    }
  } else {
#line 492
    tmp___3 = 0;
  }
#line 492
  ret = tmp___3;
#line 494
  goto switch_break;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 498
  ret = rx_rexp_equal(a->params.pair.left, b->params.pair.left);
  }
#line 499
  goto switch_break;
  case_8: /* CIL Label */ 
#line 501
  if (a->params.intval == b->params.intval) {
#line 501
    if (a->params.intval2 == b->params.intval2) {
#line 501
      tmp___4 = 1;
    } else {
#line 501
      tmp___4 = 0;
    }
  } else {
#line 501
    tmp___4 = 0;
  }
#line 501
  ret = tmp___4;
#line 503
  goto switch_break;
  case_9: /* CIL Label */ 
#line 505
  if (a->params.intval == b->params.intval) {
    {
#line 505
    tmp___5 = rx_rexp_equal(a->params.pair.left, b->params.pair.left);
    }
#line 505
    if (tmp___5) {
#line 505
      tmp___6 = 1;
    } else {
#line 505
      tmp___6 = 0;
    }
  } else {
#line 505
    tmp___6 = 0;
  }
#line 505
  ret = tmp___6;
#line 507
  goto switch_break;
  case_10: /* CIL Label */ 
#line 510
  ret = a->params.intval == b->params.intval;
#line 511
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 513
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 515
  return (ret);
}
}
#line 523 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnode.c"
unsigned long rx_rexp_hash(struct rexp_node *node , unsigned long seed ) 
{ 


  {
#line 532
  if (! node) {
#line 533
    return (seed);
  }
  {
#line 535
  seed = rx_rexp_hash(node->params.pair.left, seed);
#line 536
  seed = rx_rexp_hash(node->params.pair.right, seed);
#line 537
  seed = rx_bitset_hash(node->params.cset_size, node->params.cset);
#line 538
  seed = rx_string_hash(seed, & node->params.cstr);
#line 539
  seed += (seed << 3) + (unsigned long )node->params.intval;
#line 540
  seed += (seed << 3) + (unsigned long )node->params.intval2;
#line 541
  seed += (seed << 3) + (unsigned long )node->type;
#line 542
  seed += (seed << 3) + (unsigned long )node->id;
  }
#line 547
  return (seed);
}
}
#line 94 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxhash.h"
void rx_free_hash_table(struct rx_hash *tab , void (*freefn)(struct rx_hash_item *it ) ,
                        struct rx_hash_rules *rules ) ;
#line 31 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxcset.h"
rx_Bitset rx_cset(int size ) ;
#line 201 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnfa.h"
struct rx_nfa_state *rx_nfa_state(struct rx *rx ) ;
#line 202
struct rx_nfa_edge *rx_nfa_edge(struct rx *rx , enum rx_nfa_etype type , struct rx_nfa_state *start ,
                                struct rx_nfa_state *dest ) ;
#line 211
void rx_free_nfa(struct rx *rx ) ;
#line 38 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnfa.c"
struct rx_nfa_state *rx_nfa_state(struct rx *rx ) 
{ 
  struct rx_nfa_state *n ;
  void *tmp ;

  {
  {
#line 46
  tmp = malloc(sizeof(*n));
#line 46
  n = (struct rx_nfa_state *)tmp;
  }
#line 47
  if (! n) {
#line 48
    return ((struct rx_nfa_state *)0);
  }
  {
#line 49
  rx_bzero((char *)n, sizeof(*n));
#line 50
  n->next = rx->nfa_states;
#line 51
  rx->nfa_states = n;
  }
#line 52
  return (n);
}
}
#line 57 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnfa.c"
static void rx_free_nfa_state(struct rx_nfa_state *n ) 
{ 


  {
  {
#line 65
  free((void *)((char *)n));
  }
#line 66
  return;
}
}
#line 74 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnfa.c"
struct rx_nfa_edge *rx_nfa_edge(struct rx *rx , enum rx_nfa_etype type , struct rx_nfa_state *start ,
                                struct rx_nfa_state *dest ) 
{ 
  struct rx_nfa_edge *e ;
  void *tmp ;
  void *__cil_tmp7 ;

  {
  {
#line 89
  tmp = malloc(sizeof(*e));
#line 89
  e = (struct rx_nfa_edge *)tmp;
  }
#line 90
  if (! e) {
#line 91
    return ((struct rx_nfa_edge *)0);
  }
#line 92
  e->next = start->edges;
#line 93
  start->edges = e;
#line 94
  e->type = type;
#line 95
  e->dest = dest;
#line 96
  return (e);
}
}
#line 101 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnfa.c"
static void rx_free_nfa_edge(struct rx_nfa_edge *e ) 
{ 


  {
  {
#line 109
  free((void *)((char *)e));
  }
#line 110
  return;
}
}
#line 118 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnfa.c"
static struct rx_possible_future *rx_possible_future(struct rx *rx , struct rx_se_list *effects ) 
{ 
  struct rx_possible_future *ec ;
  void *tmp ;

  {
  {
#line 129
  tmp = malloc(sizeof(*ec));
#line 129
  ec = (struct rx_possible_future *)tmp;
  }
#line 130
  if (! ec) {
#line 131
    return ((struct rx_possible_future *)0);
  }
#line 132
  ec->destset = (struct rx_nfa_state_set *)0;
#line 133
  ec->next = (struct rx_possible_future *)0;
#line 134
  ec->effects = effects;
#line 135
  return (ec);
}
}
#line 140 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnfa.c"
static void rx_free_possible_future(struct rx_possible_future *pf ) 
{ 


  {
  {
#line 148
  free((void *)((char *)pf));
  }
#line 149
  return;
}
}
#line 153 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnfa.c"
static void rx_free_nfa_graph(struct rx *rx ) 
{ 
  struct rx_nfa_edge *e ;
  struct rx_possible_future *pf ;
  struct rx_possible_future *pft ;
  struct rx_nfa_state *n ;

  {
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    if (! rx->nfa_states) {
#line 161
      goto while_break;
    }
    {
#line 163
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 163
      if (! (rx->nfa_states)->edges) {
#line 163
        goto while_break___0;
      }
      {
#line 167
      if ((unsigned int )((rx->nfa_states)->edges)->type == 0U) {
#line 167
        goto case_0;
      }
#line 170
      goto switch_default;
      case_0: /* CIL Label */ 
      {
#line 168
      rx_free_cset(((rx->nfa_states)->edges)->params.cset);
      }
#line 169
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 171
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 175
      e = (rx->nfa_states)->edges;
#line 176
      (rx->nfa_states)->edges = ((rx->nfa_states)->edges)->next;
#line 177
      rx_free_nfa_edge(e);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 182
    pf = (rx->nfa_states)->futures;
    {
#line 183
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 183
      if (! pf) {
#line 183
        goto while_break___1;
      }
      {
#line 185
      pft = pf;
#line 186
      pf = pf->next;
#line 187
      rx_free_possible_future(pft);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 192
    n = rx->nfa_states;
#line 193
    rx->nfa_states = (rx->nfa_states)->next;
#line 194
    rx_free_nfa_state(n);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 197
  return;
}
}
#line 217 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnfa.c"
int rx_build_nfa(struct rx *rx , struct rexp_node *rexp , struct rx_nfa_state **start ,
                 struct rx_nfa_state **end ) 
{ 
  struct rx_nfa_edge *edge ;
  struct rx_nfa_state *tmp ;
  struct rx_nfa_state *tmp___0 ;
  struct rexp_node copied ;
  struct rx_nfa_state *shared ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct rx_nfa_edge *tmp___4 ;
  int tmp___5 ;
  struct rx_nfa_state *star_start ;
  struct rx_nfa_state *star_end ;
  struct rx_nfa_state *shared___0 ;
  int tmp___6 ;
  int tmp___7 ;
  struct rx_nfa_edge *tmp___8 ;
  struct rx_nfa_edge *tmp___9 ;
  struct rx_nfa_edge *tmp___10 ;
  struct rx_nfa_edge *tmp___11 ;
  int tmp___12 ;
  struct rx_nfa_state *star_start___0 ;
  struct rx_nfa_state *star_end___0 ;
  int tmp___13 ;
  struct rx_nfa_edge *tmp___14 ;
  struct rx_nfa_edge *tmp___15 ;
  struct rx_nfa_edge *tmp___16 ;
  struct rx_nfa_edge *tmp___17 ;
  int tmp___18 ;
  struct rx_nfa_state *cut_end ;
  struct rx_nfa_edge *tmp___19 ;
  int tmp___20 ;
  struct rx_nfa_state *shared___1 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  struct rx_nfa_state *ls ;
  struct rx_nfa_state *le ;
  struct rx_nfa_state *rs ;
  struct rx_nfa_state *re ;
  int tmp___24 ;
  int tmp___25 ;
  struct rx_nfa_edge *tmp___26 ;
  struct rx_nfa_edge *tmp___27 ;
  struct rx_nfa_edge *tmp___28 ;
  struct rx_nfa_edge *tmp___29 ;
  int tmp___30 ;
  void *__cil_tmp51 ;
  void *__cil_tmp52 ;
  void *__cil_tmp53 ;
  void *__cil_tmp54 ;

  {
#line 234
  if (*start) {
#line 234
    *start = *start;
  } else {
    {
#line 234
    tmp = rx_nfa_state(rx);
#line 234
    *start = tmp;
    }
  }
#line 236
  if (! *start) {
#line 237
    return (0);
  }
#line 239
  if (! rexp) {
#line 241
    *end = *start;
#line 242
    return (1);
  }
#line 245
  if (*end) {
#line 245
    *end = *end;
  } else {
    {
#line 245
    tmp___0 = rx_nfa_state(rx);
#line 245
    *end = tmp___0;
    }
  }
#line 247
  if (! *end) {
    {
#line 249
    rx_free_nfa_state(*start);
    }
#line 250
    return (0);
  }
  {
#line 255
  if ((unsigned int )rexp->type == 0U) {
#line 255
    goto case_0;
  }
#line 269
  if ((unsigned int )rexp->type == 6U) {
#line 269
    goto case_6;
  }
#line 303
  if ((unsigned int )rexp->type == 3U) {
#line 303
    goto case_3;
  }
#line 307
  if ((unsigned int )rexp->type == 5U) {
#line 307
    goto case_5;
  }
#line 327
  if ((unsigned int )rexp->type == 4U) {
#line 327
    goto case_4;
  }
#line 327
  if ((unsigned int )rexp->type == 8U) {
#line 327
    goto case_4;
  }
#line 342
  if ((unsigned int )rexp->type == 7U) {
#line 342
    goto case_7;
  }
#line 359
  if ((unsigned int )rexp->type == 9U) {
#line 359
    goto case_9;
  }
#line 362
  if ((unsigned int )rexp->type == 1U) {
#line 362
    goto case_1;
  }
#line 370
  if ((unsigned int )rexp->type == 2U) {
#line 370
    goto case_2;
  }
#line 384
  if ((unsigned int )rexp->type == 10U) {
#line 384
    goto case_10;
  }
#line 253
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 256
  edge = rx_nfa_edge(rx, (enum rx_nfa_etype )0, *start, *end);
#line 257
  (*start)->has_cset_edges = 1;
  }
#line 258
  if (! edge) {
#line 259
    return (0);
  }
  {
#line 260
  edge->params.cset = rx_copy_cset(rx->local_cset_size, rexp->params.cset);
  }
#line 262
  if (! edge->params.cset) {
    {
#line 264
    rx_free_nfa_edge(edge);
    }
#line 265
    return (0);
  }
#line 267
  return (1);
  case_6: /* CIL Label */ 
#line 271
  if (rexp->params.cstr.len == 1UL) {
    {
#line 273
    edge = rx_nfa_edge(rx, (enum rx_nfa_etype )0, *start, *end);
#line 274
    (*start)->has_cset_edges = 1;
    }
#line 275
    if (! edge) {
#line 276
      return (0);
    }
    {
#line 277
    edge->params.cset = rx_cset(rx->local_cset_size);
    }
#line 278
    if (! edge->params.cset) {
      {
#line 280
      rx_free_nfa_edge(edge);
      }
#line 281
      return (0);
    }
#line 283
    *(edge->params.cset + (unsigned long )*(rexp->params.cstr.contents + 0) / (8UL * sizeof(RX_subset ))) |= rx_subset_singletons[(unsigned long )*(rexp->params.cstr.contents + 0) & (8UL * sizeof(RX_subset ) - 1UL)];
#line 284
    return (1);
  } else {
    {
#line 291
    copied = *rexp;
#line 292
    shared = (struct rx_nfa_state *)0;
#line 293
    (copied.params.cstr.len) --;
#line 294
    (copied.params.cstr.contents) ++;
#line 295
    tmp___1 = rx_build_nfa(rx, & copied, & shared, end);
    }
#line 295
    if (! tmp___1) {
#line 296
      return (0);
    }
    {
#line 297
    copied.params.cstr.len = 1UL;
#line 298
    (copied.params.cstr.contents) --;
#line 299
    tmp___2 = rx_build_nfa(rx, & copied, start, & shared);
    }
#line 299
    return (tmp___2);
  }
  case_3: /* CIL Label */ 
  {
#line 304
  tmp___3 = rx_build_nfa(rx, rexp->params.pair.left, start, end);
  }
#line 304
  if (tmp___3) {
    {
#line 304
    tmp___4 = rx_nfa_edge(rx, (enum rx_nfa_etype )1, *start, *end);
    }
#line 304
    if (tmp___4) {
#line 304
      tmp___5 = 1;
    } else {
#line 304
      tmp___5 = 0;
    }
  } else {
#line 304
    tmp___5 = 0;
  }
#line 304
  return (tmp___5);
  case_5: /* CIL Label */ 
  {
#line 309
  star_start = (struct rx_nfa_state *)0;
#line 310
  star_end = (struct rx_nfa_state *)0;
#line 313
  shared___0 = (struct rx_nfa_state *)0;
#line 314
  tmp___6 = rx_build_nfa(rx, rexp->params.pair.left, start, & shared___0);
  }
#line 314
  if (! tmp___6) {
#line 315
    return (0);
  }
  {
#line 316
  tmp___7 = rx_build_nfa(rx, rexp->params.pair.left, & star_start, & star_end);
  }
#line 316
  if (tmp___7) {
#line 316
    if (star_start) {
#line 316
      if (star_end) {
        {
#line 316
        tmp___8 = rx_nfa_edge(rx, (enum rx_nfa_etype )1, star_start, star_end);
        }
#line 316
        if (tmp___8) {
          {
#line 316
          tmp___9 = rx_nfa_edge(rx, (enum rx_nfa_etype )1, shared___0, star_start);
          }
#line 316
          if (tmp___9) {
            {
#line 316
            tmp___10 = rx_nfa_edge(rx, (enum rx_nfa_etype )1, star_end, *end);
            }
#line 316
            if (tmp___10) {
              {
#line 316
              tmp___11 = rx_nfa_edge(rx, (enum rx_nfa_etype )1, star_end, star_start);
              }
#line 316
              if (tmp___11) {
#line 316
                tmp___12 = 1;
              } else {
#line 316
                tmp___12 = 0;
              }
            } else {
#line 316
              tmp___12 = 0;
            }
          } else {
#line 316
            tmp___12 = 0;
          }
        } else {
#line 316
          tmp___12 = 0;
        }
      } else {
#line 316
        tmp___12 = 0;
      }
    } else {
#line 316
      tmp___12 = 0;
    }
  } else {
#line 316
    tmp___12 = 0;
  }
#line 316
  return (tmp___12);
  case_4: /* CIL Label */ 
  case_8: /* CIL Label */ 
  {
#line 329
  star_start___0 = (struct rx_nfa_state *)0;
#line 330
  star_end___0 = (struct rx_nfa_state *)0;
#line 331
  tmp___13 = rx_build_nfa(rx, rexp->params.pair.left, & star_start___0, & star_end___0);
  }
#line 331
  if (tmp___13) {
#line 331
    if (star_start___0) {
#line 331
      if (star_end___0) {
        {
#line 331
        tmp___14 = rx_nfa_edge(rx, (enum rx_nfa_etype )1, star_start___0, star_end___0);
        }
#line 331
        if (tmp___14) {
          {
#line 331
          tmp___15 = rx_nfa_edge(rx, (enum rx_nfa_etype )1, *start, star_start___0);
          }
#line 331
          if (tmp___15) {
            {
#line 331
            tmp___16 = rx_nfa_edge(rx, (enum rx_nfa_etype )1, star_end___0, *end);
            }
#line 331
            if (tmp___16) {
              {
#line 331
              tmp___17 = rx_nfa_edge(rx, (enum rx_nfa_etype )1, star_end___0, star_start___0);
              }
#line 331
              if (tmp___17) {
#line 331
                tmp___18 = 1;
              } else {
#line 331
                tmp___18 = 0;
              }
            } else {
#line 331
              tmp___18 = 0;
            }
          } else {
#line 331
            tmp___18 = 0;
          }
        } else {
#line 331
          tmp___18 = 0;
        }
      } else {
#line 331
        tmp___18 = 0;
      }
    } else {
#line 331
      tmp___18 = 0;
    }
  } else {
#line 331
    tmp___18 = 0;
  }
#line 331
  return (tmp___18);
  case_7: /* CIL Label */ 
  {
#line 344
  cut_end = (struct rx_nfa_state *)0;
#line 346
  cut_end = rx_nfa_state(rx);
  }
#line 347
  if (cut_end) {
    {
#line 347
    tmp___19 = rx_nfa_edge(rx, (enum rx_nfa_etype )1, *start, cut_end);
    }
#line 347
    if (! tmp___19) {
#line 347
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 349
    rx_free_nfa_state(*start);
#line 350
    rx_free_nfa_state(*end);
    }
#line 351
    if (cut_end) {
      {
#line 352
      rx_free_nfa_state(cut_end);
      }
    }
#line 353
    return (0);
  }
#line 355
  cut_end->is_final = rexp->params.intval;
#line 356
  return (1);
  case_9: /* CIL Label */ 
  {
#line 360
  tmp___20 = rx_build_nfa(rx, rexp->params.pair.left, start, end);
  }
#line 360
  return (tmp___20);
  case_1: /* CIL Label */ 
  {
#line 364
  shared___1 = (struct rx_nfa_state *)0;
#line 365
  tmp___21 = rx_build_nfa(rx, rexp->params.pair.left, start, & shared___1);
  }
#line 365
  if (tmp___21) {
    {
#line 365
    tmp___22 = rx_build_nfa(rx, rexp->params.pair.right, & shared___1, end);
    }
#line 365
    if (tmp___22) {
#line 365
      tmp___23 = 1;
    } else {
#line 365
      tmp___23 = 0;
    }
  } else {
#line 365
    tmp___23 = 0;
  }
#line 365
  return (tmp___23);
  case_2: /* CIL Label */ 
  {
#line 372
  ls = (struct rx_nfa_state *)0;
#line 373
  le = (struct rx_nfa_state *)0;
#line 374
  rs = (struct rx_nfa_state *)0;
#line 375
  re = (struct rx_nfa_state *)0;
#line 376
  tmp___24 = rx_build_nfa(rx, rexp->params.pair.left, & ls, & le);
  }
#line 376
  if (tmp___24) {
    {
#line 376
    tmp___25 = rx_build_nfa(rx, rexp->params.pair.right, & rs, & re);
    }
#line 376
    if (tmp___25) {
      {
#line 376
      tmp___26 = rx_nfa_edge(rx, (enum rx_nfa_etype )1, *start, ls);
      }
#line 376
      if (tmp___26) {
        {
#line 376
        tmp___27 = rx_nfa_edge(rx, (enum rx_nfa_etype )1, *start, rs);
        }
#line 376
        if (tmp___27) {
          {
#line 376
          tmp___28 = rx_nfa_edge(rx, (enum rx_nfa_etype )1, le, *end);
          }
#line 376
          if (tmp___28) {
            {
#line 376
            tmp___29 = rx_nfa_edge(rx, (enum rx_nfa_etype )1, re, *end);
            }
#line 376
            if (tmp___29) {
#line 376
              tmp___30 = 1;
            } else {
#line 376
              tmp___30 = 0;
            }
          } else {
#line 376
            tmp___30 = 0;
          }
        } else {
#line 376
          tmp___30 = 0;
        }
      } else {
#line 376
        tmp___30 = 0;
      }
    } else {
#line 376
      tmp___30 = 0;
    }
  } else {
#line 376
    tmp___30 = 0;
  }
#line 376
  return (tmp___30);
  case_10: /* CIL Label */ 
  {
#line 385
  edge = rx_nfa_edge(rx, (enum rx_nfa_etype )2, *start, *end);
  }
#line 386
  if (! edge) {
#line 387
    return (0);
  }
#line 388
  edge->params.side_effect = (void *)rexp->params.intval;
#line 389
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 393
  return (0);
}
}
#line 422 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnfa.c"
static int se_list_cmp(void *va , void *vb ) 
{ 
  struct rx_se_list *a ;
  struct rx_se_list *b ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 431
  a = (struct rx_se_list *)va;
#line 432
  b = (struct rx_se_list *)vb;
#line 434
  if ((unsigned long )va == (unsigned long )vb) {
#line 434
    tmp___4 = 0;
  } else {
#line 434
    if (! va) {
#line 434
      tmp___3 = -1;
    } else {
#line 434
      if (! vb) {
#line 434
        tmp___2 = 1;
      } else {
#line 434
        if ((long )a->car < (long )b->car) {
#line 434
          tmp___1 = 1;
        } else {
#line 434
          if ((long )a->car > (long )b->car) {
#line 434
            tmp___0 = -1;
          } else {
            {
#line 434
            tmp = se_list_cmp((void *)a->cdr, (void *)b->cdr);
#line 434
            tmp___0 = tmp;
            }
          }
#line 434
          tmp___1 = tmp___0;
        }
#line 434
        tmp___2 = tmp___1;
      }
#line 434
      tmp___3 = tmp___2;
    }
#line 434
    tmp___4 = tmp___3;
  }
#line 434
  return (tmp___4);
}
}
#line 449 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnfa.c"
static int se_list_equal(void *va , void *vb ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 458
  tmp = se_list_cmp(va, vb);
  }
#line 458
  if (tmp) {
#line 458
    tmp___0 = 0;
  } else {
#line 458
    tmp___0 = 1;
  }
#line 458
  return (tmp___0);
}
}
#line 461 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnfa.c"
static struct rx_hash_rules se_list_hash_rules  =    {& se_list_equal, (struct rx_hash *(*)(struct rx_hash_rules * ))0, (void (*)(struct rx_hash * ,
                                                                                struct rx_hash_rules * ))0,
    (struct rx_hash_item *(*)(struct rx_hash_rules * , void * ))0, (void (*)(struct rx_hash_item * ,
                                                                             struct rx_hash_rules * ))0};
#line 465 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnfa.c"
static struct rx_se_list *side_effect_cons(struct rx *rx , void *se , struct rx_se_list *list ) 
{ 
  struct rx_se_list *l ;
  void *tmp ;

  {
  {
#line 477
  tmp = malloc(sizeof(*l));
#line 477
  l = (struct rx_se_list *)tmp;
  }
#line 478
  if (! l) {
#line 479
    return ((struct rx_se_list *)0);
  }
#line 480
  l->car = se;
#line 481
  l->cdr = list;
#line 482
  return (l);
}
}
#line 487 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnfa.c"
static struct rx_se_list *hash_cons_se_prog(struct rx *rx , struct rx_hash *memo ,
                                            void *car , struct rx_se_list *cdr ) 
{ 
  long hash ;
  struct rx_se_list template ;
  struct rx_hash_item *it ;
  struct rx_hash_item *tmp ;
  struct rx_se_list *consed ;
  void *tmp___0 ;
  void *__cil_tmp11 ;

  {
  {
#line 500
  hash = (long )car ^ (long )cdr;
#line 503
  template.car = car;
#line 504
  template.cdr = cdr;
#line 506
  tmp = rx_hash_store(memo, (unsigned long )hash, (void *)(& template), & se_list_hash_rules);
#line 506
  it = tmp;
  }
#line 509
  if (! it) {
#line 510
    return ((struct rx_se_list *)0);
  }
#line 511
  if ((unsigned long )it->data == (unsigned long )((void *)(& template))) {
    {
#line 514
    tmp___0 = malloc(sizeof(*consed));
#line 514
    consed = (struct rx_se_list *)tmp___0;
#line 515
    *consed = template;
#line 516
    it->data = (void *)consed;
    }
  }
#line 518
  return ((struct rx_se_list *)it->data);
}
}
#line 524 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnfa.c"
static struct rx_se_list *hash_se_prog(struct rx *rx , struct rx_hash *memo , struct rx_se_list *prog ) 
{ 
  struct rx_se_list *answer ;

  {
#line 534
  answer = (struct rx_se_list *)0;
  {
#line 535
  while (1) {
    while_continue: /* CIL Label */ ;
#line 535
    if (! prog) {
#line 535
      goto while_break;
    }
    {
#line 537
    answer = hash_cons_se_prog(rx, memo, prog->car, answer);
    }
#line 538
    if (! answer) {
#line 539
      return ((struct rx_se_list *)0);
    }
#line 540
    prog = prog->cdr;
  }
  while_break: /* CIL Label */ ;
  }
#line 542
  return (answer);
}
}
#line 551 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnfa.c"
static int nfa_set_cmp(void *va , void *vb ) 
{ 
  struct rx_nfa_state_set *a ;
  struct rx_nfa_state_set *b ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 560
  a = (struct rx_nfa_state_set *)va;
#line 561
  b = (struct rx_nfa_state_set *)vb;
#line 563
  if ((unsigned long )va == (unsigned long )vb) {
#line 563
    tmp___4 = 0;
  } else {
#line 563
    if (! va) {
#line 563
      tmp___3 = -1;
    } else {
#line 563
      if (! vb) {
#line 563
        tmp___2 = 1;
      } else {
#line 563
        if ((a->car)->id < (b->car)->id) {
#line 563
          tmp___1 = 1;
        } else {
#line 563
          if ((a->car)->id > (b->car)->id) {
#line 563
            tmp___0 = -1;
          } else {
            {
#line 563
            tmp = nfa_set_cmp((void *)a->cdr, (void *)b->cdr);
#line 563
            tmp___0 = tmp;
            }
          }
#line 563
          tmp___1 = tmp___0;
        }
#line 563
        tmp___2 = tmp___1;
      }
#line 563
      tmp___3 = tmp___2;
    }
#line 563
    tmp___4 = tmp___3;
  }
#line 563
  return (tmp___4);
}
}
#line 577 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnfa.c"
static int nfa_set_equal(void *va , void *vb ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 586
  tmp = nfa_set_cmp(va, vb);
  }
#line 586
  if (tmp) {
#line 586
    tmp___0 = 0;
  } else {
#line 586
    tmp___0 = 1;
  }
#line 586
  return (tmp___0);
}
}
#line 589 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnfa.c"
static struct rx_hash_rules nfa_set_hash_rules  =    {& nfa_set_equal, (struct rx_hash *(*)(struct rx_hash_rules * ))0, (void (*)(struct rx_hash * ,
                                                                                struct rx_hash_rules * ))0,
    (struct rx_hash_item *(*)(struct rx_hash_rules * , void * ))0, (void (*)(struct rx_hash_item * ,
                                                                             struct rx_hash_rules * ))0};
#line 593 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnfa.c"
static struct rx_nfa_state_set *nfa_set_cons(struct rx *rx , struct rx_hash *memo ,
                                             struct rx_nfa_state *state , struct rx_nfa_state_set *set ) 
{ 
  struct rx_nfa_state_set template ;
  struct rx_hash_item *node ;
  struct rx_nfa_state_set *l ;
  void *tmp ;
  void *__cil_tmp9 ;

  {
  {
#line 608
  template.car = state;
#line 609
  template.cdr = set;
#line 610
  node = rx_hash_store(memo, (unsigned long )(((long )state >> 8) ^ (long )set), (void *)(& template),
                       & nfa_set_hash_rules);
  }
#line 613
  if (! node) {
#line 614
    return ((struct rx_nfa_state_set *)0);
  }
#line 615
  if ((unsigned long )node->data == (unsigned long )(& template)) {
    {
#line 618
    tmp = malloc(sizeof(*l));
#line 618
    l = (struct rx_nfa_state_set *)tmp;
#line 619
    node->data = (void *)l;
    }
#line 620
    if (! l) {
#line 621
      return ((struct rx_nfa_state_set *)0);
    }
#line 622
    *l = template;
  }
#line 624
  return ((struct rx_nfa_state_set *)node->data);
}
}
#line 629 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnfa.c"
static struct rx_nfa_state_set *nfa_set_enjoin(struct rx *rx , struct rx_hash *memo ,
                                               struct rx_nfa_state *state , struct rx_nfa_state_set *set ) 
{ 
  struct rx_nfa_state_set *tmp ;
  struct rx_nfa_state_set *newcdr ;
  struct rx_nfa_state_set *tmp___0 ;

  {
#line 642
  if (! set) {
    {
#line 643
    tmp = nfa_set_cons(rx, memo, state, set);
    }
#line 643
    return (tmp);
  } else
#line 642
  if (state->id < (set->car)->id) {
    {
#line 643
    tmp = nfa_set_cons(rx, memo, state, set);
    }
#line 643
    return (tmp);
  }
#line 644
  if (state->id == (set->car)->id) {
#line 645
    return (set);
  } else {
    {
#line 648
    tmp___0 = nfa_set_enjoin(rx, memo, state, set->cdr);
#line 648
    newcdr = tmp___0;
    }
#line 650
    if ((unsigned long )newcdr != (unsigned long )set->cdr) {
      {
#line 651
      set = nfa_set_cons(rx, memo, set->car, newcdr);
      }
    }
#line 652
    return (set);
  }
}
}
#line 678 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnfa.c"
static int eclose_node(struct rx *rx , struct rx_nfa_state *outnode , struct rx_nfa_state *node ,
                       struct eclose_frame *frame ) 
{ 
  struct rx_nfa_edge *e ;
  struct rx_possible_future **ec ;
  struct rx_se_list *prog_in_order ;
  int cmp ;
  struct rx_se_list *tmp ;
  struct rx_possible_future *pf ;
  int tmp___0 ;
  int tmp___1 ;
  struct rx_se_list *dying ;

  {
#line 690
  e = node->edges;
#line 698
  if (node->mark) {
#line 699
    return (1);
  }
#line 700
  node->mark = 1U;
#line 707
  if (node->id >= 0) {
#line 707
    goto _L___0;
  } else
#line 707
  if (node->is_final) {
    _L___0: /* CIL Label */ 
    {
#line 713
    tmp = hash_se_prog(rx, & rx->se_list_memo, frame->prog_backwards);
#line 713
    prog_in_order = tmp;
#line 717
    ec = & outnode->futures;
    }
    {
#line 719
    while (1) {
      while_continue: /* CIL Label */ ;
#line 719
      if (! *ec) {
#line 719
        goto while_break;
      }
      {
#line 721
      cmp = se_list_cmp((void *)(*ec)->effects, (void *)prog_in_order);
      }
#line 722
      if (cmp <= 0) {
#line 723
        goto while_break;
      }
#line 724
      ec = & (*ec)->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 727
    if (! *ec) {
#line 727
      goto _L;
    } else
#line 727
    if (cmp < 0) {
      _L: /* CIL Label */ 
      {
#line 730
      pf = rx_possible_future(rx, prog_in_order);
      }
#line 731
      if (! pf) {
#line 732
        return (0);
      }
#line 733
      pf->next = *ec;
#line 734
      *ec = pf;
    }
#line 736
    if (node->id >= 0) {
      {
#line 738
      (*ec)->destset = nfa_set_enjoin(rx, & rx->set_list_memo, node, (*ec)->destset);
      }
#line 740
      if (! (*ec)->destset) {
#line 741
        return (0);
      }
    }
  }
  {
#line 747
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 747
    if (! e) {
#line 747
      goto while_break___0;
    }
    {
#line 751
    if ((unsigned int )e->type == 1U) {
#line 751
      goto case_1;
    }
#line 755
    if ((unsigned int )e->type == 2U) {
#line 755
      goto case_2;
    }
#line 771
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 752
    tmp___0 = eclose_node(rx, outnode, e->dest, frame);
    }
#line 752
    if (! tmp___0) {
#line 753
      return (0);
    }
#line 754
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 757
    frame->prog_backwards = side_effect_cons(rx, e->params.side_effect, frame->prog_backwards);
    }
#line 760
    if (! frame->prog_backwards) {
#line 761
      return (0);
    }
    {
#line 762
    tmp___1 = eclose_node(rx, outnode, e->dest, frame);
    }
#line 762
    if (! tmp___1) {
#line 763
      return (0);
    }
    {
#line 765
    dying = frame->prog_backwards;
#line 766
    frame->prog_backwards = (frame->prog_backwards)->cdr;
#line 767
    free((void *)((char *)dying));
    }
#line 769
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 772
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 774
    e = e->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 776
  node->mark = 0U;
#line 777
  return (1);
}
}
#line 782 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnfa.c"
struct rx_possible_future *rx_state_possible_futures(struct rx *rx , struct rx_nfa_state *n ) 
{ 
  struct eclose_frame frame ;
  int tmp ;
  void *__cil_tmp5 ;

  {
#line 791
  if (n->futures_computed) {
#line 792
    return (n->futures);
  } else {
    {
#line 796
    frame.prog_backwards = (struct rx_se_list *)0;
#line 797
    tmp = eclose_node(rx, n, n, & frame);
    }
#line 797
    if (tmp) {
#line 801
      n->futures_computed = 1;
#line 802
      return (n->futures);
    } else {
#line 798
      return ((struct rx_possible_future *)0);
    }
  }
}
}
#line 815 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnfa.c"
static void se_memo_freer(struct rx_hash_item *node ) 
{ 


  {
  {
#line 823
  free((void *)((char *)node->data));
  }
#line 824
  return;
}
}
#line 828 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnfa.c"
static void nfa_set_freer(struct rx_hash_item *node ) 
{ 


  {
  {
#line 836
  free((void *)((char *)node->data));
  }
#line 837
  return;
}
}
#line 840 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxnfa.c"
void rx_free_nfa(struct rx *rx ) 
{ 


  {
  {
#line 848
  rx_free_hash_table(& rx->se_list_memo, & se_memo_freer, & se_list_hash_rules);
#line 849
  rx_bzero((char *)(& rx->se_list_memo), sizeof(rx->se_list_memo));
#line 850
  rx_free_hash_table(& rx->set_list_memo, & nfa_set_freer, & nfa_set_hash_rules);
#line 851
  rx_bzero((char *)(& rx->set_list_memo), sizeof(rx->set_list_memo));
#line 852
  rx_free_nfa_graph(rx);
  }
#line 853
  return;
}
}
#line 85 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxhash.h"
struct rx_hash_item *rx_hash_find(struct rx_hash *table , unsigned long hash , void *value ,
                                  struct rx_hash_rules *rules ) ;
#line 96
int rx_count_hash_nodes(struct rx_hash *st ) ;
#line 31 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxhash.c"
static struct rx_hash *default_hash_alloc(struct rx_hash_rules *rules ) 
{ 
  void *tmp ;
  void *__cil_tmp3 ;

  {
  {
#line 39
  tmp = malloc(sizeof(struct rx_hash ));
  }
#line 39
  return ((struct rx_hash *)tmp);
}
}
#line 44 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxhash.c"
static struct rx_hash_item *default_hash_item_alloc(struct rx_hash_rules *rules ,
                                                    void *value ) 
{ 
  struct rx_hash_item *it ;
  void *tmp ;

  {
  {
#line 54
  tmp = malloc(sizeof(*it));
#line 54
  it = (struct rx_hash_item *)tmp;
  }
#line 55
  if (it) {
#line 57
    it->data = value;
#line 58
    it->binding = (void *)0;
  }
#line 60
  return (it);
}
}
#line 65 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxhash.c"
static void default_free_hash(struct rx_hash *tab , struct rx_hash_rules *rules ) 
{ 


  {
  {
#line 75
  free((void *)((char *)tab));
  }
#line 76
  return;
}
}
#line 80 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxhash.c"
static void default_free_hash_item(struct rx_hash_item *item , struct rx_hash_rules *rules ) 
{ 


  {
  {
#line 90
  free((void *)((char *)item));
  }
#line 91
  return;
}
}
#line 94 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxhash.c"
static int default_eq(void *va , void *vb ) 
{ 


  {
#line 103
  return ((unsigned long )va == (unsigned long )vb);
}
}
#line 115 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxhash.c"
static unsigned long rx_hash_masks[4]  = {      306742305UL,      2523502185UL,      3195918315UL,      4294967295UL};
#line 132 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxhash.c"
struct rx_hash_item *rx_hash_find(struct rx_hash *table , unsigned long hash , void *value ,
                                  struct rx_hash_rules *rules ) 
{ 
  int (*eq)(void * , void * ) ;
  int (*tmp)(void * , void * ) ;
  int maskc ;
  long mask ;
  int bucket ;
  struct rx_hash_item *it ;
  int tmp___0 ;

  {
#line 146
  if (rules) {
#line 146
    if (rules->eq) {
#line 146
      tmp = rules->eq;
    } else {
#line 146
      tmp = & default_eq;
    }
  } else {
#line 146
    tmp = & default_eq;
  }
#line 146
  eq = tmp;
#line 147
  maskc = 0;
#line 148
  mask = (long )rx_hash_masks[0];
#line 149
  bucket = (int )(((((((((((hash & (unsigned long )mask) & 15UL) + (((hash & (unsigned long )mask) & 15UL) << 3)) + ((hash & (unsigned long )(mask >> 8)) & 15UL)) & 15UL) + ((((((hash & (unsigned long )mask) & 15UL) + (((hash & (unsigned long )mask) & 15UL) << 3)) + ((hash & (unsigned long )(mask >> 8)) & 15UL)) & 15UL) << 3)) + ((hash & (unsigned long )(mask >> 16)) & 15UL)) & 15UL) + (((((((((hash & (unsigned long )mask) & 15UL) + (((hash & (unsigned long )mask) & 15UL) << 3)) + ((hash & (unsigned long )(mask >> 8)) & 15UL)) & 15UL) + ((((((hash & (unsigned long )mask) & 15UL) + (((hash & (unsigned long )mask) & 15UL) << 3)) + ((hash & (unsigned long )(mask >> 8)) & 15UL)) & 15UL) << 3)) + ((hash & (unsigned long )(mask >> 16)) & 15UL)) & 15UL) << 3)) + ((hash & (unsigned long )(mask >> 24)) & 15UL)) & 15UL);
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 151
    if (! (*(& table->nested_p + (unsigned long )bucket / (8UL * sizeof(RX_subset ))) & rx_subset_singletons[(unsigned long )bucket & (8UL * sizeof(RX_subset ) - 1UL)])) {
#line 151
      goto while_break;
    }
#line 153
    table = (struct rx_hash *)table->children[bucket];
#line 154
    maskc ++;
#line 155
    mask = (long )rx_hash_masks[maskc];
#line 156
    bucket = (int )(((((((((((hash & (unsigned long )mask) & 15UL) + (((hash & (unsigned long )mask) & 15UL) << 3)) + ((hash & (unsigned long )(mask >> 8)) & 15UL)) & 15UL) + ((((((hash & (unsigned long )mask) & 15UL) + (((hash & (unsigned long )mask) & 15UL) << 3)) + ((hash & (unsigned long )(mask >> 8)) & 15UL)) & 15UL) << 3)) + ((hash & (unsigned long )(mask >> 16)) & 15UL)) & 15UL) + (((((((((hash & (unsigned long )mask) & 15UL) + (((hash & (unsigned long )mask) & 15UL) << 3)) + ((hash & (unsigned long )(mask >> 8)) & 15UL)) & 15UL) + ((((((hash & (unsigned long )mask) & 15UL) + (((hash & (unsigned long )mask) & 15UL) << 3)) + ((hash & (unsigned long )(mask >> 8)) & 15UL)) & 15UL) << 3)) + ((hash & (unsigned long )(mask >> 16)) & 15UL)) & 15UL) << 3)) + ((hash & (unsigned long )(mask >> 24)) & 15UL)) & 15UL);
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  it = (struct rx_hash_item *)table->children[bucket];
  {
#line 162
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 162
    if (! it) {
#line 162
      goto while_break___0;
    }
    {
#line 163
    tmp___0 = (*eq)(it->data, value);
    }
#line 163
    if (tmp___0) {
#line 164
      return (it);
    } else {
#line 166
      it = it->next_same_hash;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 169
  return ((struct rx_hash_item *)0);
}
}
#line 174 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxhash.c"
static int listlen(struct rx_hash_item *bucket ) 
{ 
  int i ;

  {
#line 183
  i = 0;
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 183
    if (! bucket) {
#line 183
      goto while_break;
    }
#line 183
    i ++;
#line 183
    bucket = bucket->next_same_hash;
  }
  while_break: /* CIL Label */ ;
  }
#line 185
  return (i);
}
}
#line 189 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxhash.c"
static int overflows(struct rx_hash_item *bucket ) 
{ 
  int tmp ;

  {
#line 197
  if (bucket) {
#line 197
    if (bucket->next_same_hash) {
#line 197
      if ((bucket->next_same_hash)->next_same_hash) {
#line 197
        if (((bucket->next_same_hash)->next_same_hash)->next_same_hash) {
#line 197
          tmp = 0;
        } else {
#line 197
          tmp = 1;
        }
      } else {
#line 197
        tmp = 1;
      }
    } else {
#line 197
      tmp = 1;
    }
  } else {
#line 197
    tmp = 1;
  }
#line 197
  return (tmp);
}
}
#line 205 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxhash.c"
struct rx_hash_item *rx_hash_store(struct rx_hash *table , unsigned long hash , void *value ,
                                   struct rx_hash_rules *rules ) 
{ 
  int (*eq)(void * , void * ) ;
  int (*tmp)(void * , void * ) ;
  int maskc ;
  long mask ;
  int bucket ;
  int depth ;
  struct rx_hash_item *it ;
  int tmp___0 ;
  struct rx_hash *newtab ;
  struct rx_hash *(*tmp___1)(struct rx_hash_rules * ) ;
  struct rx_hash *tmp___2 ;
  struct rx_hash_item *them ;
  unsigned long newmask ;
  struct rx_hash_item *save ;
  int new_buck ;
  int tmp___3 ;
  struct rx_hash_item *it___0 ;
  struct rx_hash_item *(*tmp___4)(struct rx_hash_rules * , void * ) ;
  struct rx_hash_item *tmp___5 ;

  {
#line 219
  if (rules) {
#line 219
    if (rules->eq) {
#line 219
      tmp = rules->eq;
    } else {
#line 219
      tmp = & default_eq;
    }
  } else {
#line 219
    tmp = & default_eq;
  }
#line 219
  eq = tmp;
#line 220
  maskc = 0;
#line 221
  mask = (long )rx_hash_masks[0];
#line 222
  bucket = (int )(((((((((((hash & (unsigned long )mask) & 15UL) + (((hash & (unsigned long )mask) & 15UL) << 3)) + ((hash & (unsigned long )(mask >> 8)) & 15UL)) & 15UL) + ((((((hash & (unsigned long )mask) & 15UL) + (((hash & (unsigned long )mask) & 15UL) << 3)) + ((hash & (unsigned long )(mask >> 8)) & 15UL)) & 15UL) << 3)) + ((hash & (unsigned long )(mask >> 16)) & 15UL)) & 15UL) + (((((((((hash & (unsigned long )mask) & 15UL) + (((hash & (unsigned long )mask) & 15UL) << 3)) + ((hash & (unsigned long )(mask >> 8)) & 15UL)) & 15UL) + ((((((hash & (unsigned long )mask) & 15UL) + (((hash & (unsigned long )mask) & 15UL) << 3)) + ((hash & (unsigned long )(mask >> 8)) & 15UL)) & 15UL) << 3)) + ((hash & (unsigned long )(mask >> 16)) & 15UL)) & 15UL) << 3)) + ((hash & (unsigned long )(mask >> 24)) & 15UL)) & 15UL);
#line 223
  depth = 0;
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 225
    if (! (*(& table->nested_p + (unsigned long )bucket / (8UL * sizeof(RX_subset ))) & rx_subset_singletons[(unsigned long )bucket & (8UL * sizeof(RX_subset ) - 1UL)])) {
#line 225
      goto while_break;
    }
#line 227
    table = (struct rx_hash *)table->children[bucket];
#line 228
    maskc ++;
#line 229
    mask = (long )rx_hash_masks[maskc];
#line 230
    bucket = (int )(((((((((((hash & (unsigned long )mask) & 15UL) + (((hash & (unsigned long )mask) & 15UL) << 3)) + ((hash & (unsigned long )(mask >> 8)) & 15UL)) & 15UL) + ((((((hash & (unsigned long )mask) & 15UL) + (((hash & (unsigned long )mask) & 15UL) << 3)) + ((hash & (unsigned long )(mask >> 8)) & 15UL)) & 15UL) << 3)) + ((hash & (unsigned long )(mask >> 16)) & 15UL)) & 15UL) + (((((((((hash & (unsigned long )mask) & 15UL) + (((hash & (unsigned long )mask) & 15UL) << 3)) + ((hash & (unsigned long )(mask >> 8)) & 15UL)) & 15UL) + ((((((hash & (unsigned long )mask) & 15UL) + (((hash & (unsigned long )mask) & 15UL) << 3)) + ((hash & (unsigned long )(mask >> 8)) & 15UL)) & 15UL) << 3)) + ((hash & (unsigned long )(mask >> 16)) & 15UL)) & 15UL) << 3)) + ((hash & (unsigned long )(mask >> 24)) & 15UL)) & 15UL);
#line 231
    depth ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 236
  it = (struct rx_hash_item *)table->children[bucket];
  {
#line 237
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 237
    if (! it) {
#line 237
      goto while_break___0;
    }
    {
#line 238
    tmp___0 = (*eq)(it->data, value);
    }
#line 238
    if (tmp___0) {
#line 239
      return (it);
    } else {
#line 241
      it = it->next_same_hash;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 245
  if (depth < 3) {
    {
#line 245
    tmp___3 = overflows((struct rx_hash_item *)table->children[bucket]);
    }
#line 245
    if (tmp___3) {
#line 249
      if (rules) {
#line 249
        if (rules->hash_alloc) {
#line 249
          tmp___1 = rules->hash_alloc;
        } else {
#line 249
          tmp___1 = & default_hash_alloc;
        }
      } else {
#line 249
        tmp___1 = & default_hash_alloc;
      }
      {
#line 249
      tmp___2 = (*tmp___1)(rules);
#line 249
      newtab = tmp___2;
      }
#line 250
      if (! newtab) {
#line 251
        goto add_to_bucket;
      }
      {
#line 252
      rx_bzero((char *)newtab, sizeof(*newtab));
#line 253
      newtab->parent = table;
#line 257
      them = (struct rx_hash_item *)table->children[bucket];
#line 258
      newmask = rx_hash_masks[maskc + 1];
      }
      {
#line 259
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 259
        if (! them) {
#line 259
          goto while_break___1;
        }
#line 261
        save = them->next_same_hash;
#line 262
        new_buck = (int )(((((((((((them->hash & newmask) & 15UL) + (((them->hash & newmask) & 15UL) << 3)) + ((them->hash & (newmask >> 8)) & 15UL)) & 15UL) + ((((((them->hash & newmask) & 15UL) + (((them->hash & newmask) & 15UL) << 3)) + ((them->hash & (newmask >> 8)) & 15UL)) & 15UL) << 3)) + ((them->hash & (newmask >> 16)) & 15UL)) & 15UL) + (((((((((them->hash & newmask) & 15UL) + (((them->hash & newmask) & 15UL) << 3)) + ((them->hash & (newmask >> 8)) & 15UL)) & 15UL) + ((((((them->hash & newmask) & 15UL) + (((them->hash & newmask) & 15UL) << 3)) + ((them->hash & (newmask >> 8)) & 15UL)) & 15UL) << 3)) + ((them->hash & (newmask >> 16)) & 15UL)) & 15UL) << 3)) + ((them->hash & (newmask >> 24)) & 15UL)) & 15UL);
#line 263
        them->next_same_hash = (struct rx_hash_item *)newtab->children[new_buck];
#line 265
        *((struct rx_hash_item **)(newtab->children) + new_buck) = them;
#line 266
        them->table = newtab;
#line 267
        them = save;
#line 268
        (newtab->refs) ++;
#line 269
        (table->refs) --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 271
      *((struct rx_hash **)(table->children) + bucket) = newtab;
#line 272
      *(& table->nested_p + (unsigned long )bucket / (8UL * sizeof(RX_subset ))) |= rx_subset_singletons[(unsigned long )bucket & (8UL * sizeof(RX_subset ) - 1UL)];
#line 273
      (table->refs) ++;
#line 274
      table = newtab;
#line 275
      bucket = (int )(((((((((((hash & newmask) & 15UL) + (((hash & newmask) & 15UL) << 3)) + ((hash & (newmask >> 8)) & 15UL)) & 15UL) + ((((((hash & newmask) & 15UL) + (((hash & newmask) & 15UL) << 3)) + ((hash & (newmask >> 8)) & 15UL)) & 15UL) << 3)) + ((hash & (newmask >> 16)) & 15UL)) & 15UL) + (((((((((hash & newmask) & 15UL) + (((hash & newmask) & 15UL) << 3)) + ((hash & (newmask >> 8)) & 15UL)) & 15UL) + ((((((hash & newmask) & 15UL) + (((hash & newmask) & 15UL) << 3)) + ((hash & (newmask >> 8)) & 15UL)) & 15UL) << 3)) + ((hash & (newmask >> 16)) & 15UL)) & 15UL) << 3)) + ((hash & (newmask >> 24)) & 15UL)) & 15UL);
    }
  }
  add_to_bucket: 
#line 281
  if (rules) {
#line 281
    if (rules->hash_item_alloc) {
#line 281
      tmp___4 = rules->hash_item_alloc;
    } else {
#line 281
      tmp___4 = & default_hash_item_alloc;
    }
  } else {
#line 281
    tmp___4 = & default_hash_item_alloc;
  }
  {
#line 281
  tmp___5 = (*tmp___4)(rules, value);
#line 281
  it___0 = tmp___5;
  }
#line 283
  if (! it___0) {
#line 284
    return ((struct rx_hash_item *)0);
  }
#line 285
  it___0->hash = hash;
#line 286
  it___0->table = table;
#line 288
  it___0->next_same_hash = (struct rx_hash_item *)table->children[bucket];
#line 289
  *((struct rx_hash_item **)(table->children) + bucket) = it___0;
#line 290
  (table->refs) ++;
#line 291
  return (it___0);
}
}
#line 297 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxhash.c"
void rx_hash_free(struct rx_hash_item *it , struct rx_hash_rules *rules ) 
{ 
  struct rx_hash *table ;
  unsigned long hash ;
  int depth ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int bucket ;
  struct rx_hash_item **pos ;
  void (*tmp___2)(struct rx_hash_item * , struct rx_hash_rules * ) ;
  struct rx_hash *save ;
  void (*tmp___3)(struct rx_hash * , struct rx_hash_rules * ) ;

  {
#line 306
  if (it) {
#line 308
    table = it->table;
#line 309
    hash = it->hash;
#line 310
    if (table->parent) {
#line 310
      if ((table->parent)->parent) {
#line 310
        if (((table->parent)->parent)->parent) {
#line 310
          tmp = 3;
        } else {
#line 310
          tmp = 2;
        }
#line 310
        tmp___0 = tmp;
      } else {
#line 310
        tmp___0 = 1;
      }
#line 310
      tmp___1 = tmp___0;
    } else {
#line 310
      tmp___1 = 0;
    }
#line 310
    depth = tmp___1;
#line 317
    bucket = (int )(((((((((((hash & rx_hash_masks[depth]) & 15UL) + (((hash & rx_hash_masks[depth]) & 15UL) << 3)) + ((hash & (rx_hash_masks[depth] >> 8)) & 15UL)) & 15UL) + ((((((hash & rx_hash_masks[depth]) & 15UL) + (((hash & rx_hash_masks[depth]) & 15UL) << 3)) + ((hash & (rx_hash_masks[depth] >> 8)) & 15UL)) & 15UL) << 3)) + ((hash & (rx_hash_masks[depth] >> 16)) & 15UL)) & 15UL) + (((((((((hash & rx_hash_masks[depth]) & 15UL) + (((hash & rx_hash_masks[depth]) & 15UL) << 3)) + ((hash & (rx_hash_masks[depth] >> 8)) & 15UL)) & 15UL) + ((((((hash & rx_hash_masks[depth]) & 15UL) + (((hash & rx_hash_masks[depth]) & 15UL) << 3)) + ((hash & (rx_hash_masks[depth] >> 8)) & 15UL)) & 15UL) << 3)) + ((hash & (rx_hash_masks[depth] >> 16)) & 15UL)) & 15UL) << 3)) + ((hash & (rx_hash_masks[depth] >> 24)) & 15UL)) & 15UL);
#line 318
    pos = (struct rx_hash_item **)(& table->children[bucket]);
    {
#line 321
    while (1) {
      while_continue: /* CIL Label */ ;
#line 321
      if (! ((unsigned long )*pos != (unsigned long )it)) {
#line 321
        goto while_break;
      }
#line 322
      pos = & (*pos)->next_same_hash;
    }
    while_break: /* CIL Label */ ;
    }
#line 323
    *pos = it->next_same_hash;
#line 324
    if (rules) {
#line 324
      if (rules->free_hash_item) {
#line 324
        tmp___2 = rules->free_hash_item;
      } else {
#line 324
        tmp___2 = & default_free_hash_item;
      }
    } else {
#line 324
      tmp___2 = & default_free_hash_item;
    }
    {
#line 324
    (*tmp___2)(it, rules);
#line 325
    (table->refs) --;
    }
    {
#line 326
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 326
      if (! table->refs) {
#line 326
        if (! depth) {
#line 326
          goto while_break___0;
        }
      } else {
#line 326
        goto while_break___0;
      }
#line 328
      save = table;
#line 329
      table = table->parent;
#line 330
      depth --;
#line 331
      bucket = (int )(((((((((((hash & rx_hash_masks[depth]) & 15UL) + (((hash & rx_hash_masks[depth]) & 15UL) << 3)) + ((hash & (rx_hash_masks[depth] >> 8)) & 15UL)) & 15UL) + ((((((hash & rx_hash_masks[depth]) & 15UL) + (((hash & rx_hash_masks[depth]) & 15UL) << 3)) + ((hash & (rx_hash_masks[depth] >> 8)) & 15UL)) & 15UL) << 3)) + ((hash & (rx_hash_masks[depth] >> 16)) & 15UL)) & 15UL) + (((((((((hash & rx_hash_masks[depth]) & 15UL) + (((hash & rx_hash_masks[depth]) & 15UL) << 3)) + ((hash & (rx_hash_masks[depth] >> 8)) & 15UL)) & 15UL) + ((((((hash & rx_hash_masks[depth]) & 15UL) + (((hash & rx_hash_masks[depth]) & 15UL) << 3)) + ((hash & (rx_hash_masks[depth] >> 8)) & 15UL)) & 15UL) << 3)) + ((hash & (rx_hash_masks[depth] >> 16)) & 15UL)) & 15UL) << 3)) + ((hash & (rx_hash_masks[depth] >> 24)) & 15UL)) & 15UL);
#line 332
      (table->refs) --;
#line 333
      table->children[bucket] = (void **)0;
#line 334
      *(& table->nested_p + (unsigned long )bucket / (8UL * sizeof(RX_subset ))) &= ~ rx_subset_singletons[(unsigned long )bucket & (8UL * sizeof(RX_subset ) - 1UL)];
#line 335
      if (rules) {
#line 335
        if (rules->free_hash) {
#line 335
          tmp___3 = rules->free_hash;
        } else {
#line 335
          tmp___3 = & default_free_hash;
        }
      } else {
#line 335
        tmp___3 = & default_free_hash;
      }
      {
#line 335
      (*tmp___3)(save, rules);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 338
  return;
}
}
#line 341 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxhash.c"
void rx_free_hash_table(struct rx_hash *tab , void (*freefn)(struct rx_hash_item *it ) ,
                        struct rx_hash_rules *rules ) 
{ 
  int x ;
  void (*tmp)(struct rx_hash * , struct rx_hash_rules * ) ;
  struct rx_hash_item *them ;
  struct rx_hash_item *that ;
  void (*tmp___0)(struct rx_hash_item * , struct rx_hash_rules * ) ;

  {
#line 354
  x = 0;
  {
#line 354
  while (1) {
    while_continue: /* CIL Label */ ;
#line 354
    if (! (x < 16)) {
#line 354
      goto while_break;
    }
#line 355
    if (*(& tab->nested_p + (unsigned long )x / (8UL * sizeof(RX_subset ))) & rx_subset_singletons[(unsigned long )x & (8UL * sizeof(RX_subset ) - 1UL)]) {
      {
#line 357
      rx_free_hash_table((struct rx_hash *)tab->children[x], freefn, rules);
      }
#line 359
      if (rules) {
#line 359
        if (rules->free_hash) {
#line 359
          tmp = rules->free_hash;
        } else {
#line 359
          tmp = & default_free_hash;
        }
      } else {
#line 359
        tmp = & default_free_hash;
      }
      {
#line 359
      (*tmp)((struct rx_hash *)tab->children[x], rules);
      }
    } else {
#line 363
      them = (struct rx_hash_item *)tab->children[x];
      {
#line 364
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 364
        if (! them) {
#line 364
          goto while_break___0;
        }
        {
#line 366
        that = them;
#line 367
        them = that->next_same_hash;
#line 368
        (*freefn)(that);
        }
#line 369
        if (rules) {
#line 369
          if (rules->free_hash_item) {
#line 369
            tmp___0 = rules->free_hash_item;
          } else {
#line 369
            tmp___0 = & default_free_hash_item;
          }
        } else {
#line 369
          tmp___0 = & default_free_hash_item;
        }
        {
#line 369
        (*tmp___0)(that, rules);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 354
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 372
  return;
}
}
#line 377 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxhash.c"
int rx_count_hash_nodes(struct rx_hash *st ) 
{ 
  int x ;
  int count ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 386
  count = 0;
#line 387
  x = 0;
  {
#line 387
  while (1) {
    while_continue: /* CIL Label */ ;
#line 387
    if (! (x < 16)) {
#line 387
      goto while_break;
    }
#line 388
    if (*(& st->nested_p + (unsigned long )x / (8UL * sizeof(RX_subset ))) & rx_subset_singletons[(unsigned long )x & (8UL * sizeof(RX_subset ) - 1UL)]) {
      {
#line 388
      tmp = rx_count_hash_nodes((struct rx_hash *)st->children[x]);
#line 388
      tmp___1 = tmp;
      }
    } else {
      {
#line 388
      tmp___0 = listlen((struct rx_hash_item *)st->children[x]);
#line 388
      tmp___1 = tmp___0;
      }
    }
#line 388
    count += tmp___1;
#line 387
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 392
  return (count);
}
}
#line 75 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxbitset.h"
void rx_bitset_null(int size , rx_Bitset b ) ;
#line 77
void rx_bitset_complement(int size , rx_Bitset b ) ;
#line 79
void rx_bitset_union(int size , rx_Bitset a , rx_Bitset b ) ;
#line 34 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxgnucomp.c"
char re_syntax_table[1 << 8]  ;
#line 45
static void init_syntax_once(void) ;
#line 45 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxgnucomp.c"
static int done  =    0;
#line 37 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxgnucomp.c"
static void init_syntax_once(void) 
{ 
  register int c ;

  {
#line 47
  if (done) {
#line 48
    return;
  }
  {
#line 50
  rx_bzero(re_syntax_table, sizeof(re_syntax_table));
#line 52
  c = 'a';
  }
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    if (! (c <= 122)) {
#line 52
      goto while_break;
    }
#line 53
    re_syntax_table[c] = (char)1;
#line 52
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  c = 'A';
  {
#line 55
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 55
    if (! (c <= 90)) {
#line 55
      goto while_break___0;
    }
#line 56
    re_syntax_table[c] = (char)1;
#line 55
    c ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 58
  c = '0';
  {
#line 58
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 58
    if (! (c <= 57)) {
#line 58
      goto while_break___1;
    }
#line 59
    re_syntax_table[c] = (char)1;
#line 58
    c ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 61
  re_syntax_table['_'] = (char)1;
#line 63
  done = 1;
#line 64
  return;
}
}
#line 71 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxgnucomp.c"
char const   *rx_error_msg[17]  = 
#line 71
  {      (char const   *)0,      "No match",      "Invalid regular expression",      "Invalid collation character", 
        "Invalid character class name",      "Trailing backslash",      "Invalid back reference",      "Unmatched [ or [^", 
        "Unmatched ( or \\(",      "Unmatched \\{",      "Invalid content of \\{\\}",      "Invalid range end", 
        "Memory exhausted",      "Invalid preceding regular expression",      "Premature end of regular expression",      "Regular expression too big", 
        "Unmatched ) or \\)"};
#line 205 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxgnucomp.c"
static int at_begline_loc_p(char const   *pattern , char const   *p , unsigned long syntax ) 
{ 
  char const   *prev ;
  int prev_prev_backslash ;
  int tmp ;
  int tmp___0 ;

  {
#line 215
  prev = p - 2;
#line 216
  if ((unsigned long )prev > (unsigned long )pattern) {
#line 216
    if ((int const   )*(prev + -1) == 92) {
#line 216
      tmp = 1;
    } else {
#line 216
      tmp = 0;
    }
  } else {
#line 216
    tmp = 0;
  }
#line 216
  prev_prev_backslash = tmp;
#line 218
  if ((int const   )*prev == 40) {
#line 218
    if (syntax & (unsigned long )(((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 218
      tmp___0 = 1;
    } else
#line 218
    if (prev_prev_backslash) {
#line 218
      tmp___0 = 1;
    } else {
#line 218
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 218
  if ((int const   )*prev == 124) {
#line 218
    if (syntax & (unsigned long )(((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 218
      tmp___0 = 1;
    } else
#line 218
    if (prev_prev_backslash) {
#line 218
      tmp___0 = 1;
    } else {
#line 218
      tmp___0 = 0;
    }
  } else {
#line 218
    tmp___0 = 0;
  }
#line 218
  return (tmp___0);
}
}
#line 233 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxgnucomp.c"
static int at_endline_loc_p(char const   *p , char const   *pend , int syntax ) 
{ 
  char const   *next ;
  int next_backslash ;
  char const   *next_next ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 243
  next = p;
#line 244
  next_backslash = (int const   )*next == 92;
#line 245
  if ((unsigned long )(p + 1) < (unsigned long )pend) {
#line 245
    tmp = p + 1;
  } else {
#line 245
    tmp = (char const   *)0;
  }
#line 245
  next_next = tmp;
#line 247
  if (syntax & (((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 247
    tmp___1 = (int const   )*next == 41;
  } else {
#line 247
    if (next_backslash) {
#line 247
      if (next_next) {
#line 247
        if ((int const   )*next_next == 41) {
#line 247
          tmp___0 = 1;
        } else {
#line 247
          tmp___0 = 0;
        }
      } else {
#line 247
        tmp___0 = 0;
      }
    } else {
#line 247
      tmp___0 = 0;
    }
#line 247
    tmp___1 = tmp___0;
  }
#line 247
  if (tmp___1) {
#line 247
    tmp___4 = 1;
  } else {
#line 247
    if (syntax & (((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 247
      tmp___3 = (int const   )*next == 124;
    } else {
#line 247
      if (next_backslash) {
#line 247
        if (next_next) {
#line 247
          if ((int const   )*next_next == 124) {
#line 247
            tmp___2 = 1;
          } else {
#line 247
            tmp___2 = 0;
          }
        } else {
#line 247
          tmp___2 = 0;
        }
      } else {
#line 247
        tmp___2 = 0;
      }
#line 247
      tmp___3 = tmp___2;
    }
#line 247
    if (tmp___3) {
#line 247
      tmp___4 = 1;
    } else {
#line 247
      tmp___4 = 0;
    }
  }
#line 247
  return (tmp___4);
}
}
#line 262 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxgnucomp.c"
unsigned char rx_id_translation[256]  = 
#line 262
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)8,      (unsigned char)9,      (unsigned char)10,      (unsigned char)11, 
        (unsigned char)12,      (unsigned char)13,      (unsigned char)14,      (unsigned char)15, 
        (unsigned char)16,      (unsigned char)17,      (unsigned char)18,      (unsigned char)19, 
        (unsigned char)20,      (unsigned char)21,      (unsigned char)22,      (unsigned char)23, 
        (unsigned char)24,      (unsigned char)25,      (unsigned char)26,      (unsigned char)27, 
        (unsigned char)28,      (unsigned char)29,      (unsigned char)30,      (unsigned char)31, 
        (unsigned char)32,      (unsigned char)33,      (unsigned char)34,      (unsigned char)35, 
        (unsigned char)36,      (unsigned char)37,      (unsigned char)38,      (unsigned char)39, 
        (unsigned char)40,      (unsigned char)41,      (unsigned char)42,      (unsigned char)43, 
        (unsigned char)44,      (unsigned char)45,      (unsigned char)46,      (unsigned char)47, 
        (unsigned char)48,      (unsigned char)49,      (unsigned char)50,      (unsigned char)51, 
        (unsigned char)52,      (unsigned char)53,      (unsigned char)54,      (unsigned char)55, 
        (unsigned char)56,      (unsigned char)57,      (unsigned char)58,      (unsigned char)59, 
        (unsigned char)60,      (unsigned char)61,      (unsigned char)62,      (unsigned char)63, 
        (unsigned char)64,      (unsigned char)65,      (unsigned char)66,      (unsigned char)67, 
        (unsigned char)68,      (unsigned char)69,      (unsigned char)70,      (unsigned char)71, 
        (unsigned char)72,      (unsigned char)73,      (unsigned char)74,      (unsigned char)75, 
        (unsigned char)76,      (unsigned char)77,      (unsigned char)78,      (unsigned char)79, 
        (unsigned char)80,      (unsigned char)81,      (unsigned char)82,      (unsigned char)83, 
        (unsigned char)84,      (unsigned char)85,      (unsigned char)86,      (unsigned char)87, 
        (unsigned char)88,      (unsigned char)89,      (unsigned char)90,      (unsigned char)91, 
        (unsigned char)92,      (unsigned char)93,      (unsigned char)94,      (unsigned char)95, 
        (unsigned char)96,      (unsigned char)97,      (unsigned char)98,      (unsigned char)99, 
        (unsigned char)100,      (unsigned char)101,      (unsigned char)102,      (unsigned char)103, 
        (unsigned char)104,      (unsigned char)105,      (unsigned char)106,      (unsigned char)107, 
        (unsigned char)108,      (unsigned char)109,      (unsigned char)110,      (unsigned char)111, 
        (unsigned char)112,      (unsigned char)113,      (unsigned char)114,      (unsigned char)115, 
        (unsigned char)116,      (unsigned char)117,      (unsigned char)118,      (unsigned char)119, 
        (unsigned char)120,      (unsigned char)121,      (unsigned char)122,      (unsigned char)123, 
        (unsigned char)124,      (unsigned char)125,      (unsigned char)126,      (unsigned char)127, 
        (unsigned char)128,      (unsigned char)129,      (unsigned char)130,      (unsigned char)131, 
        (unsigned char)132,      (unsigned char)133,      (unsigned char)134,      (unsigned char)135, 
        (unsigned char)136,      (unsigned char)137,      (unsigned char)138,      (unsigned char)139, 
        (unsigned char)140,      (unsigned char)141,      (unsigned char)142,      (unsigned char)143, 
        (unsigned char)144,      (unsigned char)145,      (unsigned char)146,      (unsigned char)147, 
        (unsigned char)148,      (unsigned char)149,      (unsigned char)150,      (unsigned char)151, 
        (unsigned char)152,      (unsigned char)153,      (unsigned char)154,      (unsigned char)155, 
        (unsigned char)156,      (unsigned char)157,      (unsigned char)158,      (unsigned char)159, 
        (unsigned char)160,      (unsigned char)161,      (unsigned char)162,      (unsigned char)163, 
        (unsigned char)164,      (unsigned char)165,      (unsigned char)166,      (unsigned char)167, 
        (unsigned char)168,      (unsigned char)169,      (unsigned char)170,      (unsigned char)171, 
        (unsigned char)172,      (unsigned char)173,      (unsigned char)174,      (unsigned char)175, 
        (unsigned char)176,      (unsigned char)177,      (unsigned char)178,      (unsigned char)179, 
        (unsigned char)180,      (unsigned char)181,      (unsigned char)182,      (unsigned char)183, 
        (unsigned char)184,      (unsigned char)185,      (unsigned char)186,      (unsigned char)187, 
        (unsigned char)188,      (unsigned char)189,      (unsigned char)190,      (unsigned char)191, 
        (unsigned char)192,      (unsigned char)193,      (unsigned char)194,      (unsigned char)195, 
        (unsigned char)196,      (unsigned char)197,      (unsigned char)198,      (unsigned char)199, 
        (unsigned char)200,      (unsigned char)201,      (unsigned char)202,      (unsigned char)203, 
        (unsigned char)204,      (unsigned char)205,      (unsigned char)206,      (unsigned char)207, 
        (unsigned char)208,      (unsigned char)209,      (unsigned char)210,      (unsigned char)211, 
        (unsigned char)212,      (unsigned char)213,      (unsigned char)214,      (unsigned char)215, 
        (unsigned char)216,      (unsigned char)217,      (unsigned char)218,      (unsigned char)219, 
        (unsigned char)220,      (unsigned char)221,      (unsigned char)222,      (unsigned char)223, 
        (unsigned char)224,      (unsigned char)225,      (unsigned char)226,      (unsigned char)227, 
        (unsigned char)228,      (unsigned char)229,      (unsigned char)230,      (unsigned char)231, 
        (unsigned char)232,      (unsigned char)233,      (unsigned char)234,      (unsigned char)235, 
        (unsigned char)236,      (unsigned char)237,      (unsigned char)238,      (unsigned char)239, 
        (unsigned char)240,      (unsigned char)241,      (unsigned char)242,      (unsigned char)243, 
        (unsigned char)244,      (unsigned char)245,      (unsigned char)246,      (unsigned char)247, 
        (unsigned char)248,      (unsigned char)249,      (unsigned char)250,      (unsigned char)251, 
        (unsigned char)252,      (unsigned char)253,      (unsigned char)254,      (unsigned char)255};
#line 300 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxgnucomp.c"
static rx_Bitset inverse_translation(int *n_members , int cset_size , char *valid ,
                                     rx_Bitset cache , unsigned char *translate ,
                                     int c ) 
{ 
  rx_Bitset cs ;
  int x ;
  int c_tr ;
  int membs ;

  {
#line 314
  cs = cache + (unsigned long )c * ((((unsigned long )cset_size + 8UL * sizeof(RX_subset )) - 1UL) / (8UL * sizeof(RX_subset )));
#line 316
  if (! *(valid + c)) {
    {
#line 322
    c_tr = (int )*(translate + (unsigned char )c);
#line 323
    rx_bitset_null(cset_size, cs);
#line 324
    membs = 0;
#line 325
    x = 0;
    }
    {
#line 325
    while (1) {
      while_continue: /* CIL Label */ ;
#line 325
      if (! (x < 256)) {
#line 325
        goto while_break;
      }
#line 326
      if ((int )*(translate + (unsigned char )x) == c_tr) {
#line 328
        *(cs + (unsigned long )x / (8UL * sizeof(RX_subset ))) |= rx_subset_singletons[(unsigned long )x & (8UL * sizeof(RX_subset ) - 1UL)];
#line 329
        membs ++;
      }
#line 325
      x ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 331
    *(valid + c) = (char)1;
#line 332
    *(n_members + c) = membs;
  }
#line 334
  return (cs);
}
}
#line 382 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxgnucomp.c"
static reg_errcode_t compile_range(int *n_members , int cset_size , rx_Bitset cs ,
                                   char const   **p_ptr , char const   *pend , unsigned char *translate ,
                                   unsigned long syntax , rx_Bitset inv_tr , char *valid_inv_tr ) 
{ 
  unsigned int this_char ;
  char const   *p ;
  unsigned char range_end ;
  unsigned char range_start ;
  char const   *tmp ;
  int tmp___0 ;
  rx_Bitset it ;
  rx_Bitset tmp___1 ;

  {
#line 400
  p = *p_ptr;
#line 403
  range_start = *(translate + (unsigned char )*(p + -2));
#line 405
  if ((unsigned long )p == (unsigned long )pend) {
#line 406
    return ((reg_errcode_t )11);
  }
  {
#line 408
  while (1) {
    while_continue: /* CIL Label */ ;
#line 408
    if ((unsigned long )p == (unsigned long )pend) {
#line 408
      return ((reg_errcode_t )14);
    }
#line 408
    tmp = p;
#line 408
    p ++;
#line 408
    range_end = (unsigned char )*tmp;
#line 408
    range_end = *(translate + range_end);
#line 408
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 410
  (*p_ptr) ++;
#line 412
  if ((int )range_start > (int )range_end) {
#line 413
    if (syntax & (unsigned long )((((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 413
      tmp___0 = 11;
    } else {
#line 413
      tmp___0 = 0;
    }
#line 413
    return ((reg_errcode_t )tmp___0);
  }
#line 415
  this_char = (unsigned int )range_start;
  {
#line 415
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 415
    if (! (this_char <= (unsigned int )range_end)) {
#line 415
      goto while_break___0;
    }
    {
#line 417
    tmp___1 = inverse_translation(n_members, cset_size, valid_inv_tr, inv_tr, translate,
                                  (int )this_char);
#line 417
    it = tmp___1;
#line 419
    rx_bitset_union(cset_size, cs, it);
#line 415
    this_char ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 422
  return ((reg_errcode_t )0);
}
}
#line 427 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxgnucomp.c"
static int pointless_if_repeated(struct rexp_node *node ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 435
  if (! node) {
#line 436
    return (1);
  }
  {
#line 441
  if ((unsigned int )node->type == 7U) {
#line 441
    goto case_7;
  }
#line 441
  if ((unsigned int )node->type == 6U) {
#line 441
    goto case_7;
  }
#line 441
  if ((unsigned int )node->type == 0U) {
#line 441
    goto case_7;
  }
#line 444
  if ((unsigned int )node->type == 2U) {
#line 444
    goto case_2;
  }
#line 444
  if ((unsigned int )node->type == 1U) {
#line 444
    goto case_2;
  }
#line 450
  if ((unsigned int )node->type == 9U) {
#line 450
    goto case_9;
  }
#line 450
  if ((unsigned int )node->type == 8U) {
#line 450
    goto case_9;
  }
#line 450
  if ((unsigned int )node->type == 4U) {
#line 450
    goto case_9;
  }
#line 450
  if ((unsigned int )node->type == 3U) {
#line 450
    goto case_9;
  }
#line 452
  if ((unsigned int )node->type == 10U) {
#line 452
    goto case_10;
  }
#line 466
  goto switch_default___0;
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 442
  return (0);
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 445
  tmp = pointless_if_repeated(node->params.pair.left);
  }
#line 445
  if (tmp) {
    {
#line 445
    tmp___0 = pointless_if_repeated(node->params.pair.right);
    }
#line 445
    if (tmp___0) {
#line 445
      tmp___1 = 1;
    } else {
#line 445
      tmp___1 = 0;
    }
  } else {
#line 445
    tmp___1 = 0;
  }
#line 445
  return (tmp___1);
  case_9: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 451
  tmp___2 = pointless_if_repeated(node->params.pair.left);
  }
#line 451
  return (tmp___2);
  case_10: /* CIL Label */ 
  {
#line 461
  if (node->params.intval == 39) {
#line 461
    goto case_39;
  }
#line 461
  if (node->params.intval == 96) {
#line 461
    goto case_39;
  }
#line 461
  if (node->params.intval == 66) {
#line 461
    goto case_39;
  }
#line 461
  if (node->params.intval == 98) {
#line 461
    goto case_39;
  }
#line 461
  if (node->params.intval == 94) {
#line 461
    goto case_39;
  }
#line 461
  if (node->params.intval == 60) {
#line 461
    goto case_39;
  }
#line 461
  if (node->params.intval == 61) {
#line 461
    goto case_39;
  }
#line 463
  goto switch_default;
  case_39: /* CIL Label */ 
  case_96: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_94: /* CIL Label */ 
  case_60: /* CIL Label */ 
  case_61: /* CIL Label */ 
#line 462
  return (1);
  switch_default: /* CIL Label */ 
#line 464
  return (0);
  switch_break___0: /* CIL Label */ ;
  }
  switch_default___0: /* CIL Label */ 
#line 467
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 474 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxgnucomp.c"
static int factor_string(struct rexp_node ***lastp , int cset_size ) 
{ 
  struct rexp_node **expp ;
  struct rexp_node *exp___0 ;
  rx_Bitset cs ;
  struct rexp_node *cset_node ;
  struct rexp_node *concat_node ;

  {
  {
#line 488
  expp = *lastp;
#line 489
  exp___0 = *expp;
#line 491
  cs = rx_cset(cset_size);
  }
#line 492
  if (! cs) {
#line 493
    return (-1);
  }
  {
#line 494
  *(cs + (unsigned long )*(exp___0->params.cstr.contents + (exp___0->params.cstr.len - 1UL)) / (8UL * sizeof(RX_subset ))) |= rx_subset_singletons[(unsigned long )*(exp___0->params.cstr.contents + (exp___0->params.cstr.len - 1UL)) & (8UL * sizeof(RX_subset ) - 1UL)];
#line 495
  cset_node = rx_mk_r_cset(0, cset_size, cs);
  }
#line 496
  if (! cset_node) {
    {
#line 498
    rx_free_cset(cs);
    }
#line 499
    return (-1);
  }
#line 501
  if (exp___0->params.cstr.len == 1UL) {
    {
#line 503
    rx_free_rexp(exp___0);
#line 504
    *expp = cset_node;
    }
#line 506
    return (0);
  } else {
    {
#line 511
    (exp___0->params.cstr.len) --;
#line 512
    concat_node = rx_mk_r_binop(1, exp___0, cset_node);
    }
#line 513
    if (! concat_node) {
      {
#line 515
      rx_free_rexp(cset_node);
      }
#line 516
      return (-1);
    }
#line 518
    *expp = concat_node;
#line 519
    *lastp = & concat_node->params.pair.right;
#line 520
    return (0);
  }
}
}
#line 962
extern int ( /* missing proto */  sscanf)() ;
#line 996
extern int ( /* missing proto */  strcmp)() ;
#line 1023
extern int ( /* missing proto */  isalnum)() ;
#line 1023
extern int ( /* missing proto */  isalpha)() ;
#line 1023
extern int ( /* missing proto */  iscntrl)() ;
#line 1023
extern int ( /* missing proto */  isgraph)() ;
#line 1023
extern int ( /* missing proto */  islower)() ;
#line 1023
extern int ( /* missing proto */  isprint)() ;
#line 1023
extern int ( /* missing proto */  ispunct)() ;
#line 1023
extern int ( /* missing proto */  isspace)() ;
#line 1023
extern int ( /* missing proto */  isxdigit)() ;
#line 529 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxgnucomp.c"
reg_errcode_t rx_parse(struct rexp_node **rexp_p , char const   *pattern , int size ,
                       unsigned long syntax , int cset_size , unsigned char *translate ) 
{ 
  reg_errcode_t compile_error ;
  RX_subset inverse_translate[(unsigned long )(1 << 8) * ((((unsigned long )(1 << 8) + 8UL * sizeof(RX_subset )) - 1UL) / (8UL * sizeof(RX_subset )))] ;
  char validate_inv_tr[1 << 8] ;
  int n_members[1 << 8] ;
  register unsigned char c ;
  register unsigned char c1 ;
  char const   *p1 ;
  compile_stack_type compile_stack ;
  char const   *p ;
  char const   *pend ;
  struct rexp_node *rexp ;
  struct rexp_node **top_expression ;
  struct rexp_node **last_non_regular_expression ;
  struct rexp_node **last_expression ;
  struct rexp_node *append ;
  regnum_t regnum ;
  int syntax_only_parens ;
  char const   *beg_interval ;
  int side ;
  void *tmp ;
  char const   *tmp___0 ;
  struct rexp_node *n ;
  struct rexp_node *tmp___1 ;
  int tmp___2 ;
  struct rexp_node *n___0 ;
  struct rexp_node *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char zero_times_ok ;
  char many_times_ok ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  struct rexp_node *inner_exp ;
  struct rexp_node *star ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  rx_Bitset cs ;
  struct rexp_node *n___1 ;
  int had_char_class ;
  rx_Bitset cs___0 ;
  struct rexp_node *node ;
  int is_inverted ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  rx_Bitset it ;
  rx_Bitset tmp___13 ;
  reg_errcode_t ret ;
  reg_errcode_t tmp___14 ;
  reg_errcode_t ret___0 ;
  char const   *tmp___15 ;
  char str[65] ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  unsigned char tmp___18 ;
  int val ;
  int tmp___19 ;
  char const   *tmp___20 ;
  char const   *tmp___21 ;
  struct rexp_node *cut ;
  char const   *tmp___22 ;
  char const   *tmp___23 ;
  char const   *tmp___24 ;
  char const   *tmp___25 ;
  int ch ;
  int is_alnum ;
  int tmp___26 ;
  int tmp___27 ;
  int is_alpha ;
  int tmp___28 ;
  int tmp___29 ;
  int is_blank ;
  int tmp___30 ;
  int tmp___31 ;
  int is_cntrl ;
  int tmp___32 ;
  int tmp___33 ;
  int is_digit ;
  int tmp___34 ;
  int tmp___35 ;
  int is_graph ;
  int tmp___36 ;
  int tmp___37 ;
  int is_lower ;
  int tmp___38 ;
  int tmp___39 ;
  int is_print ;
  int tmp___40 ;
  int tmp___41 ;
  int is_punct ;
  int tmp___42 ;
  int tmp___43 ;
  int is_space ;
  int tmp___44 ;
  int tmp___45 ;
  int is_upper ;
  int tmp___46 ;
  int tmp___47 ;
  int is_xdigit ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  char const   *tmp___62 ;
  rx_Bitset it___0 ;
  rx_Bitset tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  int tmp___77 ;
  unsigned char tmp___78 ;
  rx_Bitset it___1 ;
  rx_Bitset tmp___79 ;
  rx_Bitset it___2 ;
  rx_Bitset tmp___80 ;
  rx_Bitset it___3 ;
  rx_Bitset tmp___81 ;
  char const   *tmp___82 ;
  void *tmp___83 ;
  struct rexp_node *concat ;
  regnum_t this_group_regnum ;
  struct rexp_node **inner ;
  struct rexp_node *parens ;
  struct rexp_node *alt ;
  int lower_bound ;
  int upper_bound ;
  char const   *tmp___84 ;
  char const   *tmp___85 ;
  int tmp___86 ;
  char const   *tmp___87 ;
  char const   *tmp___88 ;
  int tmp___89 ;
  char const   *tmp___90 ;
  int tmp___91 ;
  struct rexp_node *interval ;
  int tmp___92 ;
  char const   *tmp___93 ;
  rx_Bitset cs___1 ;
  struct rexp_node *n___2 ;
  struct rexp_node *tmp___94 ;
  int x ;
  struct rexp_node *se ;
  rx_Bitset cs___2 ;
  struct rexp_node *match ;
  rx_Bitset it___4 ;
  struct rexp_node *tmp___95 ;
  int tmp___96 ;
  struct rexp_node *concat___0 ;
  struct rexp_node *concat___1 ;
  void *__cil_tmp176 ;
  void *__cil_tmp177 ;
  void *__cil_tmp178 ;
  void *__cil_tmp179 ;
  void *__cil_tmp180 ;
  int __cil_tmp181 ;
  void *__cil_tmp182 ;
  char *__cil_tmp183 ;
  char *__cil_tmp184 ;
  char *__cil_tmp185 ;
  char *__cil_tmp186 ;
  char *__cil_tmp187 ;
  char *__cil_tmp188 ;
  char *__cil_tmp189 ;
  char *__cil_tmp190 ;
  char *__cil_tmp191 ;
  char *__cil_tmp192 ;
  char *__cil_tmp193 ;
  char *__cil_tmp194 ;
  char *__cil_tmp195 ;
  char *__cil_tmp196 ;
  char *__cil_tmp197 ;
  char *__cil_tmp198 ;
  char *__cil_tmp199 ;
  char *__cil_tmp200 ;
  char *__cil_tmp201 ;
  char *__cil_tmp202 ;
  char *__cil_tmp203 ;
  char *__cil_tmp204 ;
  char *__cil_tmp205 ;
  char *__cil_tmp206 ;
  char *__cil_tmp207 ;
  char *__cil_tmp208 ;
  char *__cil_tmp209 ;
  char *__cil_tmp210 ;

  {
#line 601
  if (! translate) {
#line 602
    translate = rx_id_translation;
  }
  {
#line 605
  p = pattern;
#line 606
  pend = pattern + size;
#line 609
  rexp = (struct rexp_node *)0;
#line 614
  top_expression = & rexp;
#line 615
  last_non_regular_expression = top_expression;
#line 616
  last_expression = top_expression;
#line 621
  regnum = 0;
#line 623
  rx_bzero(validate_inv_tr, sizeof(validate_inv_tr));
#line 627
  tmp = malloc(32UL * sizeof(compile_stack_elt_t ));
#line 627
  compile_stack.stack = (compile_stack_elt_t *)tmp;
  }
#line 628
  if ((unsigned long )compile_stack.stack == (unsigned long )((compile_stack_elt_t *)0)) {
#line 629
    return ((reg_errcode_t )12);
  }
  {
#line 631
  compile_stack.size = 32U;
#line 632
  compile_stack.avail = 0U;
#line 636
  init_syntax_once();
  }
  {
#line 640
  while (1) {
    while_continue: /* CIL Label */ ;
#line 640
    if (! ((unsigned long )p != (unsigned long )pend)) {
#line 640
      goto while_break;
    }
    {
#line 642
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 642
      if ((unsigned long )p == (unsigned long )pend) {
#line 642
        return ((reg_errcode_t )14);
      }
#line 642
      tmp___0 = p;
#line 642
      p ++;
#line 642
      c = (unsigned char )*tmp___0;
#line 642
      c = *(translate + c);
#line 642
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 646
    if ((int )c == 94) {
#line 646
      goto case_94;
    }
#line 668
    if ((int )c == 36) {
#line 668
      goto case_36;
    }
#line 691
    if ((int )c == 63) {
#line 691
      goto case_63;
    }
#line 691
    if ((int )c == 43) {
#line 691
      goto case_63;
    }
#line 697
    if ((int )c == 42) {
#line 697
      goto handle_plus;
    }
#line 784
    if ((int )c == 46) {
#line 784
      goto case_46;
    }
#line 809
    if ((int )c == 91) {
#line 809
      goto case_91;
    }
#line 1107
    if ((int )c == 40) {
#line 1107
      goto case_40;
    }
#line 1117
    if ((int )c == 41) {
#line 1117
      goto case_41;
    }
#line 1127
    if ((int )c == 10) {
#line 1127
      goto case_10;
    }
#line 1134
    if ((int )c == 124) {
#line 1134
      goto case_124;
    }
#line 1141
    if ((int )c == 123) {
#line 1141
      goto case_123;
    }
#line 1148
    if ((int )c == 92) {
#line 1148
      goto case_92;
    }
#line 1550
    goto normal_char;
    case_94: /* CIL Label */ 
#line 648
    if ((unsigned long )p == (unsigned long )(pattern + 1)) {
#line 648
      goto _L;
    } else
#line 648
    if (syntax & (unsigned long )(((1 << 1) << 1) << 1)) {
#line 648
      goto _L;
    } else {
      {
#line 648
      tmp___2 = at_begline_loc_p(pattern, p, syntax);
      }
#line 648
      if (tmp___2) {
        _L: /* CIL Label */ 
        {
#line 655
        tmp___1 = rx_mk_r_int(10, '^');
#line 655
        n = tmp___1;
        }
#line 657
        if (! n) {
#line 658
          goto space_error;
        }
#line 659
        append = n;
#line 660
        goto append_node;
      } else {
#line 663
        goto normal_char;
      }
    }
#line 665
    goto switch_break;
    case_36: /* CIL Label */ 
#line 670
    if ((unsigned long )p == (unsigned long )pend) {
#line 670
      goto _L___0;
    } else
#line 670
    if (syntax & (unsigned long )(((1 << 1) << 1) << 1)) {
#line 670
      goto _L___0;
    } else {
      {
#line 670
      tmp___4 = at_endline_loc_p(p, pend, (int )syntax);
      }
#line 670
      if (tmp___4) {
        _L___0: /* CIL Label */ 
        {
#line 677
        tmp___3 = rx_mk_r_int(10, '$');
#line 677
        n___0 = tmp___3;
        }
#line 679
        if (! n___0) {
#line 680
          goto space_error;
        }
#line 681
        append = n___0;
#line 682
        goto append_node;
      } else {
#line 685
        goto normal_char;
      }
    }
#line 687
    goto switch_break;
    case_63: /* CIL Label */ 
    case_43: /* CIL Label */ 
#line 692
    if (syntax & (unsigned long )(1 << 1)) {
#line 694
      goto normal_char;
    } else
#line 692
    if (syntax & (unsigned long )((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 694
      goto normal_char;
    }
    handle_plus: 
    case_42: /* CIL Label */ 
    {
#line 699
    tmp___5 = pointless_if_repeated(*last_expression);
    }
#line 699
    if (tmp___5) {
#line 701
      if (syntax & (unsigned long )(((((1 << 1) << 1) << 1) << 1) << 1)) {
#line 703
        compile_error = (reg_errcode_t )13;
#line 704
        goto error_return;
      } else
#line 706
      if (! (syntax & (unsigned long )((((1 << 1) << 1) << 1) << 1))) {
#line 707
        goto normal_char;
      }
    }
#line 712
    zero_times_ok = (char)0;
#line 712
    many_times_ok = (char)0;
    {
#line 719
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 721
      zero_times_ok = (char )((int )zero_times_ok | ((int )c != 43));
#line 722
      many_times_ok = (char )((int )many_times_ok | ((int )c != 63));
#line 724
      if ((unsigned long )p == (unsigned long )pend) {
#line 725
        goto while_break___1;
      }
      {
#line 727
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 727
        if ((unsigned long )p == (unsigned long )pend) {
#line 727
          return ((reg_errcode_t )14);
        }
#line 727
        tmp___6 = p;
#line 727
        p ++;
#line 727
        c = (unsigned char )*tmp___6;
#line 727
        c = *(translate + c);
#line 727
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 729
      if (! ((int )c == 42)) {
#line 729
        if (! (syntax & (unsigned long )(1 << 1))) {
#line 729
          if (! ((int )c == 43)) {
#line 729
            if (! ((int )c == 63)) {
#line 729
              goto _L___1;
            }
          }
        } else
        _L___1: /* CIL Label */ 
#line 733
        if (syntax & (unsigned long )(1 << 1)) {
#line 733
          if ((int )c == 92) {
#line 735
            if ((unsigned long )p == (unsigned long )pend) {
#line 737
              compile_error = (reg_errcode_t )5;
#line 738
              goto error_return;
            }
            {
#line 741
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 741
              if ((unsigned long )p == (unsigned long )pend) {
#line 741
                return ((reg_errcode_t )14);
              }
#line 741
              tmp___7 = p;
#line 741
              p ++;
#line 741
              c1 = (unsigned char )*tmp___7;
#line 741
              c1 = *(translate + c1);
#line 741
              goto while_break___3;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 742
            if (! ((int )c1 == 43)) {
#line 742
              if (! ((int )c1 == 63)) {
#line 744
                p --;
#line 745
                p --;
#line 746
                goto while_break___1;
              }
            }
#line 749
            c = c1;
          } else {
#line 753
            p --;
#line 754
            goto while_break___1;
          }
        } else {
#line 753
          p --;
#line 754
          goto while_break___1;
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 768
    if (*last_expression) {
#line 768
      if ((unsigned int )(*last_expression)->type == 6U) {
        {
#line 769
        tmp___8 = factor_string(& last_expression, cset_size);
        }
#line 769
        if (tmp___8) {
#line 770
          goto space_error;
        }
      }
    }
#line 771
    inner_exp = *last_expression;
#line 772
    if (many_times_ok) {
#line 772
      if (zero_times_ok) {
#line 772
        tmp___9 = 4;
      } else {
#line 772
        tmp___9 = 5;
      }
#line 772
      tmp___10 = tmp___9;
    } else {
#line 772
      tmp___10 = 3;
    }
    {
#line 772
    star = rx_mk_r_monop(tmp___10, inner_exp);
    }
#line 776
    if (! star) {
#line 777
      goto space_error;
    }
#line 778
    *last_expression = star;
#line 781
    goto switch_break;
    case_46: /* CIL Label */ 
    {
#line 788
    cs = rx_cset(cset_size);
    }
#line 789
    if (! cs) {
#line 790
      goto space_error;
    }
    {
#line 791
    n___1 = rx_mk_r_cset(0, cset_size, cs);
    }
#line 792
    if (! n___1) {
      {
#line 794
      rx_free_cset(cs);
      }
#line 795
      goto space_error;
    }
    {
#line 797
    rx_bitset_universe(cset_size, cs);
    }
#line 798
    if (! (syntax & (unsigned long )((((((1 << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 799
      *(cs + 10UL / (8UL * sizeof(RX_subset ))) &= ~ rx_subset_singletons[10UL & (8UL * sizeof(RX_subset ) - 1UL)];
    }
#line 800
    if (! (syntax & (unsigned long )(((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 801
      *(cs + 0UL / (8UL * sizeof(RX_subset ))) &= ~ rx_subset_singletons[0UL];
    }
#line 803
    append = n___1;
#line 804
    goto append_node;
#line 805
    goto switch_break;
    case_91: /* CIL Label */ 
#line 810
    if ((unsigned long )p == (unsigned long )pend) {
#line 812
      compile_error = (reg_errcode_t )7;
#line 813
      goto error_return;
    }
    {
#line 821
    had_char_class = 0;
#line 822
    is_inverted = (int const   )*p == 94;
#line 823
    cs___0 = rx_cset(cset_size);
    }
#line 824
    if (! cs___0) {
#line 825
      goto space_error;
    }
    {
#line 826
    node = rx_mk_r_cset(0, cset_size, cs___0);
    }
#line 827
    if (! node) {
      {
#line 829
      rx_free_cset(cs___0);
      }
#line 830
      goto space_error;
    }
#line 836
    append = node;
#line 838
    if (is_inverted) {
#line 839
      p ++;
    }
#line 842
    p1 = p;
    {
#line 845
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 847
      if ((unsigned long )p == (unsigned long )pend) {
#line 849
        compile_error = (reg_errcode_t )7;
#line 850
        goto error_return;
      }
      {
#line 853
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 853
        if ((unsigned long )p == (unsigned long )pend) {
#line 853
          return ((reg_errcode_t )14);
        }
#line 853
        tmp___11 = p;
#line 853
        p ++;
#line 853
        c = (unsigned char )*tmp___11;
#line 853
        c = *(translate + c);
#line 853
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 856
      if (syntax & 1UL) {
#line 856
        if ((int )c == 92) {
#line 858
          if ((unsigned long )p == (unsigned long )pend) {
#line 860
            compile_error = (reg_errcode_t )5;
#line 861
            goto error_return;
          }
          {
#line 864
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 864
            if ((unsigned long )p == (unsigned long )pend) {
#line 864
              return ((reg_errcode_t )14);
            }
#line 864
            tmp___12 = p;
#line 864
            p ++;
#line 864
            c1 = (unsigned char )*tmp___12;
#line 864
            c1 = *(translate + c1);
#line 864
            goto while_break___6;
          }
          while_break___6: /* CIL Label */ ;
          }
          {
#line 866
          tmp___13 = inverse_translation(n_members, cset_size, validate_inv_tr, inverse_translate,
                                         translate, (int )c1);
#line 866
          it = tmp___13;
#line 872
          rx_bitset_union(cset_size, cs___0, it);
          }
#line 874
          goto __Cont;
        }
      }
#line 880
      if ((int )c == 93) {
#line 880
        if ((unsigned long )p != (unsigned long )(p1 + 1)) {
#line 881
          goto finalize_class_and_append;
        }
      }
#line 885
      if (had_char_class) {
#line 885
        if ((int )c == 45) {
#line 885
          if ((int const   )*p != 93) {
#line 887
            compile_error = (reg_errcode_t )11;
#line 888
            goto error_return;
          }
        }
      }
#line 895
      if ((int )c == 45) {
#line 895
        if ((unsigned long )(p - 2) >= (unsigned long )pattern) {
#line 895
          if ((int const   )*(p + -2) == 91) {
#line 895
            goto _L___19;
          } else {
#line 895
            goto _L___20;
          }
        } else
        _L___20: /* CIL Label */ 
#line 895
        if ((unsigned long )(p - 3) >= (unsigned long )pattern) {
#line 895
          if ((int const   )*(p + -3) == 91) {
#line 895
            if ((int const   )*(p + -2) == 94) {
#line 895
              goto _L___19;
            } else {
#line 895
              goto _L___18;
            }
          } else {
#line 895
            goto _L___18;
          }
        } else
        _L___18: /* CIL Label */ 
#line 895
        if ((int const   )*p != 93) {
          {
#line 900
          tmp___14 = compile_range(n_members, cset_size, cs___0, & p, pend, translate,
                                   syntax, inverse_translate, validate_inv_tr);
#line 900
          ret = tmp___14;
          }
#line 903
          if ((unsigned int )ret != 0U) {
#line 905
            compile_error = ret;
#line 906
            goto error_return;
          }
        } else {
#line 895
          goto _L___19;
        }
      } else
      _L___19: /* CIL Label */ 
#line 910
      if ((int const   )*(p + 0) == 45) {
#line 910
        if ((int const   )*(p + 1) != 93) {
          {
#line 915
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 915
            if ((unsigned long )p == (unsigned long )pend) {
#line 915
              return ((reg_errcode_t )14);
            }
#line 915
            tmp___15 = p;
#line 915
            p ++;
#line 915
            c1 = (unsigned char )*tmp___15;
#line 915
            c1 = *(translate + c1);
#line 915
            goto while_break___7;
          }
          while_break___7: /* CIL Label */ ;
          }
          {
#line 917
          ret___0 = compile_range(n_members, cset_size, cs___0, & p, pend, translate,
                                  syntax, inverse_translate, validate_inv_tr);
          }
#line 919
          if ((unsigned int )ret___0 != 0U) {
#line 921
            compile_error = ret___0;
#line 922
            goto error_return;
          }
        } else {
#line 910
          goto _L___14;
        }
      } else
      _L___14: /* CIL Label */ 
#line 929
      if (syntax & (unsigned long )((1 << 1) << 1)) {
#line 929
        if ((int )c == 91) {
#line 929
          if ((int const   )*p == 58) {
            {
#line 934
            while (1) {
              while_continue___8: /* CIL Label */ ;
#line 934
              if ((unsigned long )p == (unsigned long )pend) {
#line 934
                return ((reg_errcode_t )14);
              }
#line 934
              tmp___16 = p;
#line 934
              p ++;
#line 934
              c = (unsigned char )*tmp___16;
#line 934
              c = *(translate + c);
#line 934
              goto while_break___8;
            }
            while_break___8: /* CIL Label */ ;
            }
#line 935
            c1 = (unsigned char)0;
#line 938
            if ((unsigned long )p == (unsigned long )pend) {
#line 940
              compile_error = (reg_errcode_t )7;
#line 941
              goto error_return;
            }
            {
#line 944
            while (1) {
              while_continue___9: /* CIL Label */ ;
              {
#line 946
              while (1) {
                while_continue___10: /* CIL Label */ ;
#line 946
                if ((unsigned long )p == (unsigned long )pend) {
#line 946
                  return ((reg_errcode_t )14);
                }
#line 946
                tmp___17 = p;
#line 946
                p ++;
#line 946
                c = (unsigned char )*tmp___17;
#line 946
                c = *(translate + c);
#line 946
                goto while_break___10;
              }
              while_break___10: /* CIL Label */ ;
              }
#line 947
              if ((int )c == 58) {
#line 949
                goto while_break___9;
              } else
#line 947
              if ((int )c == 93) {
#line 949
                goto while_break___9;
              } else
#line 947
              if ((unsigned long )p == (unsigned long )pend) {
#line 949
                goto while_break___9;
              } else
#line 947
              if ((int )c1 == 64) {
#line 949
                goto while_break___9;
              }
#line 950
              tmp___18 = c1;
#line 950
              c1 = (unsigned char )((int )c1 + 1);
#line 950
              str[tmp___18] = (char )c;
            }
            while_break___9: /* CIL Label */ ;
            }
#line 952
            str[c1] = (char )'\000';
#line 957
            if ((int )c == 58) {
#line 957
              if ((int const   )*p == 93) {
                {
#line 959
                tmp___77 = strncmp(str, "cut", 3);
                }
#line 959
                if (tmp___77) {
                  {
#line 977
                  tmp___76 = strncmp(str, "(", 1);
                  }
#line 977
                  if (tmp___76) {
                    {
#line 985
                    tmp___75 = strncmp(str, ")", 1);
                    }
#line 985
                    if (tmp___75) {
                      {
#line 996
                      tmp___26 = strcmp(str, "alnum");
                      }
#line 996
                      if (tmp___26) {
#line 996
                        tmp___27 = 0;
                      } else {
#line 996
                        tmp___27 = 1;
                      }
                      {
#line 996
                      is_alnum = tmp___27;
#line 997
                      tmp___28 = strcmp(str, "alpha");
                      }
#line 997
                      if (tmp___28) {
#line 997
                        tmp___29 = 0;
                      } else {
#line 997
                        tmp___29 = 1;
                      }
                      {
#line 997
                      is_alpha = tmp___29;
#line 998
                      tmp___30 = strcmp(str, "blank");
                      }
#line 998
                      if (tmp___30) {
#line 998
                        tmp___31 = 0;
                      } else {
#line 998
                        tmp___31 = 1;
                      }
                      {
#line 998
                      is_blank = tmp___31;
#line 999
                      tmp___32 = strcmp(str, "cntrl");
                      }
#line 999
                      if (tmp___32) {
#line 999
                        tmp___33 = 0;
                      } else {
#line 999
                        tmp___33 = 1;
                      }
                      {
#line 999
                      is_cntrl = tmp___33;
#line 1000
                      tmp___34 = strcmp(str, "digit");
                      }
#line 1000
                      if (tmp___34) {
#line 1000
                        tmp___35 = 0;
                      } else {
#line 1000
                        tmp___35 = 1;
                      }
                      {
#line 1000
                      is_digit = tmp___35;
#line 1001
                      tmp___36 = strcmp(str, "graph");
                      }
#line 1001
                      if (tmp___36) {
#line 1001
                        tmp___37 = 0;
                      } else {
#line 1001
                        tmp___37 = 1;
                      }
                      {
#line 1001
                      is_graph = tmp___37;
#line 1002
                      tmp___38 = strcmp(str, "lower");
                      }
#line 1002
                      if (tmp___38) {
#line 1002
                        tmp___39 = 0;
                      } else {
#line 1002
                        tmp___39 = 1;
                      }
                      {
#line 1002
                      is_lower = tmp___39;
#line 1003
                      tmp___40 = strcmp(str, "print");
                      }
#line 1003
                      if (tmp___40) {
#line 1003
                        tmp___41 = 0;
                      } else {
#line 1003
                        tmp___41 = 1;
                      }
                      {
#line 1003
                      is_print = tmp___41;
#line 1004
                      tmp___42 = strcmp(str, "punct");
                      }
#line 1004
                      if (tmp___42) {
#line 1004
                        tmp___43 = 0;
                      } else {
#line 1004
                        tmp___43 = 1;
                      }
                      {
#line 1004
                      is_punct = tmp___43;
#line 1005
                      tmp___44 = strcmp(str, "space");
                      }
#line 1005
                      if (tmp___44) {
#line 1005
                        tmp___45 = 0;
                      } else {
#line 1005
                        tmp___45 = 1;
                      }
                      {
#line 1005
                      is_space = tmp___45;
#line 1006
                      tmp___46 = strcmp(str, "upper");
                      }
#line 1006
                      if (tmp___46) {
#line 1006
                        tmp___47 = 0;
                      } else {
#line 1006
                        tmp___47 = 1;
                      }
                      {
#line 1006
                      is_upper = tmp___47;
#line 1007
                      tmp___48 = strcmp(str, "xdigit");
                      }
#line 1007
                      if (tmp___48) {
#line 1007
                        tmp___49 = 0;
                      } else {
#line 1007
                        tmp___49 = 1;
                      }
                      {
#line 1007
                      is_xdigit = tmp___49;
#line 1009
                      tmp___50 = strcmp(str, "alpha");
                      }
#line 1009
                      if (tmp___50) {
                        {
#line 1009
                        tmp___51 = strcmp(str, "upper");
                        }
#line 1009
                        if (tmp___51) {
                          {
#line 1009
                          tmp___52 = strcmp(str, "lower");
                          }
#line 1009
                          if (tmp___52) {
                            {
#line 1009
                            tmp___53 = strcmp(str, "digit");
                            }
#line 1009
                            if (tmp___53) {
                              {
#line 1009
                              tmp___54 = strcmp(str, "alnum");
                              }
#line 1009
                              if (tmp___54) {
                                {
#line 1009
                                tmp___55 = strcmp(str, "xdigit");
                                }
#line 1009
                                if (tmp___55) {
                                  {
#line 1009
                                  tmp___56 = strcmp(str, "space");
                                  }
#line 1009
                                  if (tmp___56) {
                                    {
#line 1009
                                    tmp___57 = strcmp(str, "print");
                                    }
#line 1009
                                    if (tmp___57) {
                                      {
#line 1009
                                      tmp___58 = strcmp(str, "punct");
                                      }
#line 1009
                                      if (tmp___58) {
                                        {
#line 1009
                                        tmp___59 = strcmp(str, "graph");
                                        }
#line 1009
                                        if (tmp___59) {
                                          {
#line 1009
                                          tmp___60 = strcmp(str, "cntrl");
                                          }
#line 1009
                                          if (tmp___60) {
                                            {
#line 1009
                                            tmp___61 = strcmp(str, "blank");
                                            }
#line 1009
                                            if (tmp___61) {
#line 1011
                                              compile_error = (reg_errcode_t )4;
#line 1012
                                              goto error_return;
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                      {
#line 1017
                      while (1) {
                        while_continue___11: /* CIL Label */ ;
#line 1017
                        if ((unsigned long )p == (unsigned long )pend) {
#line 1017
                          return ((reg_errcode_t )14);
                        }
#line 1017
                        tmp___62 = p;
#line 1017
                        p ++;
#line 1017
                        c = (unsigned char )*tmp___62;
#line 1017
                        c = *(translate + c);
#line 1017
                        goto while_break___11;
                      }
                      while_break___11: /* CIL Label */ ;
                      }
#line 1019
                      if ((unsigned long )p == (unsigned long )pend) {
#line 1019
                        compile_error = (reg_errcode_t )7;
#line 1019
                        goto error_return;
                      }
#line 1021
                      ch = 0;
                      {
#line 1021
                      while (1) {
                        while_continue___12: /* CIL Label */ ;
#line 1021
                        if (! (ch < 1 << 8)) {
#line 1021
                          goto while_break___12;
                        }
#line 1023
                        if (is_alnum) {
                          {
#line 1023
                          tmp___64 = isalnum(ch);
                          }
#line 1023
                          if (tmp___64) {
                            {
#line 1036
                            tmp___63 = inverse_translation(n_members, cset_size, validate_inv_tr,
                                                           inverse_translate, translate,
                                                           ch);
#line 1036
                            it___0 = tmp___63;
#line 1043
                            rx_bitset_union(cset_size, cs___0, it___0);
                            }
                          } else {
#line 1023
                            goto _L___12;
                          }
                        } else
                        _L___12: /* CIL Label */ 
#line 1023
                        if (is_alpha) {
                          {
#line 1023
                          tmp___65 = isalpha(ch);
                          }
#line 1023
                          if (tmp___65) {
                            {
#line 1036
                            tmp___63 = inverse_translation(n_members, cset_size, validate_inv_tr,
                                                           inverse_translate, translate,
                                                           ch);
#line 1036
                            it___0 = tmp___63;
#line 1043
                            rx_bitset_union(cset_size, cs___0, it___0);
                            }
                          } else {
#line 1023
                            goto _L___11;
                          }
                        } else
                        _L___11: /* CIL Label */ 
#line 1023
                        if (is_blank) {
#line 1023
                          if (ch == 32) {
                            {
#line 1036
                            tmp___63 = inverse_translation(n_members, cset_size, validate_inv_tr,
                                                           inverse_translate, translate,
                                                           ch);
#line 1036
                            it___0 = tmp___63;
#line 1043
                            rx_bitset_union(cset_size, cs___0, it___0);
                            }
                          } else
#line 1023
                          if (ch != 9) {
                            {
#line 1036
                            tmp___63 = inverse_translation(n_members, cset_size, validate_inv_tr,
                                                           inverse_translate, translate,
                                                           ch);
#line 1036
                            it___0 = tmp___63;
#line 1043
                            rx_bitset_union(cset_size, cs___0, it___0);
                            }
                          } else {
#line 1023
                            goto _L___10;
                          }
                        } else
                        _L___10: /* CIL Label */ 
#line 1023
                        if (is_cntrl) {
                          {
#line 1023
                          tmp___66 = iscntrl(ch);
                          }
#line 1023
                          if (tmp___66) {
                            {
#line 1036
                            tmp___63 = inverse_translation(n_members, cset_size, validate_inv_tr,
                                                           inverse_translate, translate,
                                                           ch);
#line 1036
                            it___0 = tmp___63;
#line 1043
                            rx_bitset_union(cset_size, cs___0, it___0);
                            }
                          } else {
#line 1023
                            goto _L___9;
                          }
                        } else
                        _L___9: /* CIL Label */ 
#line 1023
                        if (is_digit) {
                          {
#line 1023
                          tmp___67 = isdigit(ch);
                          }
#line 1023
                          if (tmp___67) {
                            {
#line 1036
                            tmp___63 = inverse_translation(n_members, cset_size, validate_inv_tr,
                                                           inverse_translate, translate,
                                                           ch);
#line 1036
                            it___0 = tmp___63;
#line 1043
                            rx_bitset_union(cset_size, cs___0, it___0);
                            }
                          } else {
#line 1023
                            goto _L___8;
                          }
                        } else
                        _L___8: /* CIL Label */ 
#line 1023
                        if (is_graph) {
                          {
#line 1023
                          tmp___68 = isgraph(ch);
                          }
#line 1023
                          if (tmp___68) {
                            {
#line 1036
                            tmp___63 = inverse_translation(n_members, cset_size, validate_inv_tr,
                                                           inverse_translate, translate,
                                                           ch);
#line 1036
                            it___0 = tmp___63;
#line 1043
                            rx_bitset_union(cset_size, cs___0, it___0);
                            }
                          } else {
#line 1023
                            goto _L___7;
                          }
                        } else
                        _L___7: /* CIL Label */ 
#line 1023
                        if (is_lower) {
                          {
#line 1023
                          tmp___69 = islower(ch);
                          }
#line 1023
                          if (tmp___69) {
                            {
#line 1036
                            tmp___63 = inverse_translation(n_members, cset_size, validate_inv_tr,
                                                           inverse_translate, translate,
                                                           ch);
#line 1036
                            it___0 = tmp___63;
#line 1043
                            rx_bitset_union(cset_size, cs___0, it___0);
                            }
                          } else {
#line 1023
                            goto _L___6;
                          }
                        } else
                        _L___6: /* CIL Label */ 
#line 1023
                        if (is_print) {
                          {
#line 1023
                          tmp___70 = isprint(ch);
                          }
#line 1023
                          if (tmp___70) {
                            {
#line 1036
                            tmp___63 = inverse_translation(n_members, cset_size, validate_inv_tr,
                                                           inverse_translate, translate,
                                                           ch);
#line 1036
                            it___0 = tmp___63;
#line 1043
                            rx_bitset_union(cset_size, cs___0, it___0);
                            }
                          } else {
#line 1023
                            goto _L___5;
                          }
                        } else
                        _L___5: /* CIL Label */ 
#line 1023
                        if (is_punct) {
                          {
#line 1023
                          tmp___71 = ispunct(ch);
                          }
#line 1023
                          if (tmp___71) {
                            {
#line 1036
                            tmp___63 = inverse_translation(n_members, cset_size, validate_inv_tr,
                                                           inverse_translate, translate,
                                                           ch);
#line 1036
                            it___0 = tmp___63;
#line 1043
                            rx_bitset_union(cset_size, cs___0, it___0);
                            }
                          } else {
#line 1023
                            goto _L___4;
                          }
                        } else
                        _L___4: /* CIL Label */ 
#line 1023
                        if (is_space) {
                          {
#line 1023
                          tmp___72 = isspace(ch);
                          }
#line 1023
                          if (tmp___72) {
                            {
#line 1036
                            tmp___63 = inverse_translation(n_members, cset_size, validate_inv_tr,
                                                           inverse_translate, translate,
                                                           ch);
#line 1036
                            it___0 = tmp___63;
#line 1043
                            rx_bitset_union(cset_size, cs___0, it___0);
                            }
                          } else {
#line 1023
                            goto _L___3;
                          }
                        } else
                        _L___3: /* CIL Label */ 
#line 1023
                        if (is_upper) {
                          {
#line 1023
                          tmp___73 = isupper(ch);
                          }
#line 1023
                          if (tmp___73) {
                            {
#line 1036
                            tmp___63 = inverse_translation(n_members, cset_size, validate_inv_tr,
                                                           inverse_translate, translate,
                                                           ch);
#line 1036
                            it___0 = tmp___63;
#line 1043
                            rx_bitset_union(cset_size, cs___0, it___0);
                            }
                          } else {
#line 1023
                            goto _L___2;
                          }
                        } else
                        _L___2: /* CIL Label */ 
#line 1023
                        if (is_xdigit) {
                          {
#line 1023
                          tmp___74 = isxdigit(ch);
                          }
#line 1023
                          if (tmp___74) {
                            {
#line 1036
                            tmp___63 = inverse_translation(n_members, cset_size, validate_inv_tr,
                                                           inverse_translate, translate,
                                                           ch);
#line 1036
                            it___0 = tmp___63;
#line 1043
                            rx_bitset_union(cset_size, cs___0, it___0);
                            }
                          }
                        }
#line 1021
                        ch ++;
                      }
                      while_break___12: /* CIL Label */ ;
                      }
#line 1047
                      had_char_class = 1;
                    } else {
                      {
#line 988
                      while (1) {
                        while_continue___13: /* CIL Label */ ;
#line 988
                        if ((unsigned long )p == (unsigned long )pend) {
#line 988
                          return ((reg_errcode_t )14);
                        }
#line 988
                        tmp___24 = p;
#line 988
                        p ++;
#line 988
                        c = (unsigned char )*tmp___24;
#line 988
                        c = *(translate + c);
#line 988
                        goto while_break___13;
                      }
                      while_break___13: /* CIL Label */ ;
                      }
                      {
#line 989
                      while (1) {
                        while_continue___14: /* CIL Label */ ;
#line 989
                        if ((unsigned long )p == (unsigned long )pend) {
#line 989
                          return ((reg_errcode_t )14);
                        }
#line 989
                        tmp___25 = p;
#line 989
                        p ++;
#line 989
                        c = (unsigned char )*tmp___25;
#line 989
                        c = *(translate + c);
#line 989
                        goto while_break___14;
                      }
                      while_break___14: /* CIL Label */ ;
                      }
#line 990
                      syntax_only_parens = 1;
#line 991
                      goto handle_close;
                    }
                  } else {
                    {
#line 980
                    while (1) {
                      while_continue___15: /* CIL Label */ ;
#line 980
                      if ((unsigned long )p == (unsigned long )pend) {
#line 980
                        return ((reg_errcode_t )14);
                      }
#line 980
                      tmp___22 = p;
#line 980
                      p ++;
#line 980
                      c = (unsigned char )*tmp___22;
#line 980
                      c = *(translate + c);
#line 980
                      goto while_break___15;
                    }
                    while_break___15: /* CIL Label */ ;
                    }
                    {
#line 981
                    while (1) {
                      while_continue___16: /* CIL Label */ ;
#line 981
                      if ((unsigned long )p == (unsigned long )pend) {
#line 981
                        return ((reg_errcode_t )14);
                      }
#line 981
                      tmp___23 = p;
#line 981
                      p ++;
#line 981
                      c = (unsigned char )*tmp___23;
#line 981
                      c = *(translate + c);
#line 981
                      goto while_break___16;
                    }
                    while_break___16: /* CIL Label */ ;
                    }
#line 982
                    syntax_only_parens = 1;
#line 983
                    goto handle_open;
                  }
                } else {
                  {
#line 962
                  tmp___19 = sscanf(str + 3, " %d", & val);
                  }
#line 962
                  if (1 != tmp___19) {
#line 964
                    compile_error = (reg_errcode_t )4;
#line 965
                    goto error_return;
                  }
                  {
#line 968
                  while (1) {
                    while_continue___17: /* CIL Label */ ;
#line 968
                    if ((unsigned long )p == (unsigned long )pend) {
#line 968
                      return ((reg_errcode_t )14);
                    }
#line 968
                    tmp___20 = p;
#line 968
                    p ++;
#line 968
                    c = (unsigned char )*tmp___20;
#line 968
                    c = *(translate + c);
#line 968
                    goto while_break___17;
                  }
                  while_break___17: /* CIL Label */ ;
                  }
                  {
#line 969
                  while (1) {
                    while_continue___18: /* CIL Label */ ;
#line 969
                    if ((unsigned long )p == (unsigned long )pend) {
#line 969
                      return ((reg_errcode_t )14);
                    }
#line 969
                    tmp___21 = p;
#line 969
                    p ++;
#line 969
                    c = (unsigned char )*tmp___21;
#line 969
                    c = *(translate + c);
#line 969
                    goto while_break___18;
                  }
                  while_break___18: /* CIL Label */ ;
                  }
                  {
#line 972
                  cut = rx_mk_r_int(7, val);
#line 973
                  append = cut;
                  }
#line 974
                  goto append_node;
                }
              } else {
#line 957
                goto _L___13;
              }
            } else {
              _L___13: /* CIL Label */ 
#line 1052
              c1 = (unsigned char )((int )c1 + 1);
              {
#line 1053
              while (1) {
                while_continue___19: /* CIL Label */ ;
#line 1053
                tmp___78 = c1;
#line 1053
                c1 = (unsigned char )((int )c1 - 1);
#line 1053
                if (! tmp___78) {
#line 1053
                  goto while_break___19;
                }
#line 1054
                p --;
              }
              while_break___19: /* CIL Label */ ;
              }
              {
#line 1056
              tmp___79 = inverse_translation(n_members, cset_size, validate_inv_tr,
                                             inverse_translate, translate, '[');
#line 1056
              it___1 = tmp___79;
#line 1063
              rx_bitset_union(cset_size, cs___0, it___1);
#line 1067
              tmp___80 = inverse_translation(n_members, cset_size, validate_inv_tr,
                                             inverse_translate, translate, ':');
#line 1067
              it___2 = tmp___80;
#line 1074
              rx_bitset_union(cset_size, cs___0, it___2);
#line 1077
              had_char_class = 0;
              }
            }
          } else {
            {
#line 1082
            had_char_class = 0;
#line 1084
            tmp___81 = inverse_translation(n_members, cset_size, validate_inv_tr,
                                           inverse_translate, translate, (int )c);
#line 1084
            it___3 = tmp___81;
#line 1090
            rx_bitset_union(cset_size, cs___0, it___3);
            }
          }
        } else {
          {
#line 1082
          had_char_class = 0;
#line 1084
          tmp___81 = inverse_translation(n_members, cset_size, validate_inv_tr, inverse_translate,
                                         translate, (int )c);
#line 1084
          it___3 = tmp___81;
#line 1090
          rx_bitset_union(cset_size, cs___0, it___3);
          }
        }
      } else {
        {
#line 1082
        had_char_class = 0;
#line 1084
        tmp___81 = inverse_translation(n_members, cset_size, validate_inv_tr, inverse_translate,
                                       translate, (int )c);
#line 1084
        it___3 = tmp___81;
#line 1090
        rx_bitset_union(cset_size, cs___0, it___3);
        }
      }
      __Cont: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
    finalize_class_and_append: 
#line 1096
    if (is_inverted) {
      {
#line 1098
      rx_bitset_complement(cset_size, cs___0);
      }
#line 1099
      if (syntax & (unsigned long )((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1100
        *(cs___0 + 10UL / (8UL * sizeof(RX_subset ))) &= ~ rx_subset_singletons[10UL & (8UL * sizeof(RX_subset ) - 1UL)];
      }
    }
#line 1102
    goto append_node;
#line 1104
    goto switch_break;
    case_40: /* CIL Label */ 
#line 1108
    if (syntax & (unsigned long )(((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1110
      syntax_only_parens = 0;
#line 1111
      goto handle_open;
    } else {
#line 1114
      goto normal_char;
    }
    case_41: /* CIL Label */ 
#line 1118
    if (syntax & (unsigned long )(((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1120
      syntax_only_parens = 0;
#line 1121
      goto handle_close;
    } else {
#line 1124
      goto normal_char;
    }
    case_10: /* CIL Label */ 
#line 1128
    if (syntax & (unsigned long )(((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1129
      goto handle_alt;
    } else {
#line 1131
      goto normal_char;
    }
    case_124: /* CIL Label */ 
#line 1135
    if (syntax & (unsigned long )(((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1136
      goto handle_alt;
    } else {
#line 1138
      goto normal_char;
    }
    case_123: /* CIL Label */ 
#line 1142
    if (syntax & (unsigned long )(((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1142
      if (syntax & (unsigned long )((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1143
        goto handle_interval;
      } else {
#line 1145
        goto normal_char;
      }
    } else {
#line 1145
      goto normal_char;
    }
    case_92: /* CIL Label */ 
#line 1149
    if ((unsigned long )p == (unsigned long )pend) {
#line 1149
      compile_error = (reg_errcode_t )5;
#line 1149
      goto error_return;
    }
    {
#line 1154
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 1154
      if ((unsigned long )p == (unsigned long )pend) {
#line 1154
        return ((reg_errcode_t )14);
      }
#line 1154
      tmp___82 = p;
#line 1154
      p ++;
#line 1154
      c = (unsigned char )*tmp___82;
#line 1154
      goto while_break___20;
    }
    while_break___20: /* CIL Label */ ;
    }
    {
#line 1158
    if ((int )c == 40) {
#line 1158
      goto case_40___0;
    }
#line 1209
    if ((int )c == 41) {
#line 1209
      goto case_41___0;
    }
#line 1255
    if ((int )c == 124) {
#line 1255
      goto case_124___0;
    }
#line 1275
    if ((int )c == 123) {
#line 1275
      goto case_123___0;
    }
#line 1450
    if ((int )c == 87) {
#line 1450
      goto case_87;
    }
#line 1450
    if ((int )c == 119) {
#line 1450
      goto case_87;
    }
#line 1476
    if ((int )c == 60) {
#line 1476
      goto case_60;
    }
#line 1481
    if ((int )c == 62) {
#line 1481
      goto case_62;
    }
#line 1486
    if ((int )c == 98) {
#line 1486
      goto case_98;
    }
#line 1491
    if ((int )c == 66) {
#line 1491
      goto case_66;
    }
#line 1496
    if ((int )c == 96) {
#line 1496
      goto case_96;
    }
#line 1501
    if ((int )c == 39) {
#line 1501
      goto case_39;
    }
#line 1518
    if ((int )c == 57) {
#line 1518
      goto case_57;
    }
#line 1518
    if ((int )c == 56) {
#line 1518
      goto case_57;
    }
#line 1518
    if ((int )c == 55) {
#line 1518
      goto case_57;
    }
#line 1518
    if ((int )c == 54) {
#line 1518
      goto case_57;
    }
#line 1518
    if ((int )c == 53) {
#line 1518
      goto case_57;
    }
#line 1518
    if ((int )c == 52) {
#line 1518
      goto case_57;
    }
#line 1518
    if ((int )c == 51) {
#line 1518
      goto case_57;
    }
#line 1518
    if ((int )c == 50) {
#line 1518
      goto case_57;
    }
#line 1518
    if ((int )c == 49) {
#line 1518
      goto case_57;
    }
#line 1532
    if ((int )c == 63) {
#line 1532
      goto case_63___0;
    }
#line 1532
    if ((int )c == 43) {
#line 1532
      goto case_63___0;
    }
#line 1538
    goto normal_backslash;
    case_40___0: /* CIL Label */ 
#line 1159
    if (syntax & (unsigned long )(((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1160
      goto normal_backslash;
    }
#line 1162
    syntax_only_parens = 0;
    handle_open: 
#line 1165
    if (! syntax_only_parens) {
#line 1166
      regnum ++;
    }
#line 1168
    if (compile_stack.avail == compile_stack.size) {
      {
#line 1170
      tmp___83 = realloc((void *)compile_stack.stack, (unsigned long )(compile_stack.size << 1) * sizeof(compile_stack_elt_t ));
#line 1170
      compile_stack.stack = (compile_stack_elt_t *)tmp___83;
      }
#line 1174
      if ((unsigned long )compile_stack.stack == (unsigned long )((compile_stack_elt_t *)0)) {
#line 1175
        goto space_error;
      }
#line 1176
      compile_stack.size <<= 1;
    }
#line 1179
    if (*last_non_regular_expression) {
      {
#line 1182
      concat = rx_mk_r_binop(1, *last_non_regular_expression, (struct rexp_node *)0);
      }
#line 1183
      if (! concat) {
#line 1184
        goto space_error;
      }
#line 1185
      *last_non_regular_expression = concat;
#line 1186
      last_non_regular_expression = & concat->params.pair.right;
#line 1187
      last_expression = last_non_regular_expression;
    }
#line 1194
    (compile_stack.stack + compile_stack.avail)->top_expression = top_expression;
#line 1195
    (compile_stack.stack + compile_stack.avail)->last_expression = last_expression;
#line 1196
    (compile_stack.stack + compile_stack.avail)->last_non_regular_expression = last_non_regular_expression;
#line 1198
    if (syntax_only_parens) {
#line 1199
      (compile_stack.stack + compile_stack.avail)->regnum = -1;
    } else {
#line 1201
      (compile_stack.stack + compile_stack.avail)->regnum = regnum;
    }
#line 1203
    (compile_stack.avail) ++;
#line 1205
    top_expression = last_non_regular_expression;
#line 1206
    goto switch_break___0;
    case_41___0: /* CIL Label */ 
#line 1210
    if (syntax & (unsigned long )(((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1210
      goto normal_backslash;
    }
#line 1211
    syntax_only_parens = 0;
    handle_close: 
#line 1215
    if (compile_stack.avail == 0U) {
#line 1216
      if (syntax & (unsigned long )(((((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1217
        goto normal_char;
      } else {
#line 1219
        compile_error = (reg_errcode_t )16;
#line 1219
        goto error_return;
      }
    }
#line 1234
    inner = top_expression;
#line 1235
    (compile_stack.avail) --;
#line 1237
    if (! (! syntax_only_parens) != ((compile_stack.stack + compile_stack.avail)->regnum == -1)) {
#line 1238
      compile_error = (reg_errcode_t )16;
#line 1238
      goto error_return;
    }
    {
#line 1240
    top_expression = (compile_stack.stack + compile_stack.avail)->top_expression;
#line 1241
    last_expression = (compile_stack.stack + compile_stack.avail)->last_expression;
#line 1242
    last_non_regular_expression = (compile_stack.stack + compile_stack.avail)->last_non_regular_expression;
#line 1243
    this_group_regnum = (compile_stack.stack + compile_stack.avail)->regnum;
#line 1246
    parens = rx_mk_r_monop(9, *inner);
    }
#line 1247
    if (! parens) {
#line 1248
      goto space_error;
    }
#line 1249
    parens->params.intval = this_group_regnum;
#line 1250
    *inner = parens;
#line 1251
    goto switch_break___0;
    case_124___0: /* CIL Label */ 
#line 1256
    if (syntax & (unsigned long )((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1257
      goto normal_backslash;
    } else
#line 1256
    if (syntax & (unsigned long )(((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1257
      goto normal_backslash;
    }
    handle_alt: 
#line 1259
    if (syntax & (unsigned long )((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1260
      goto normal_char;
    }
    {
#line 1265
    alt = rx_mk_r_binop(2, *top_expression, (struct rexp_node *)0);
    }
#line 1266
    if (! alt) {
#line 1267
      goto space_error;
    }
#line 1268
    *top_expression = alt;
#line 1269
    last_expression = & alt->params.pair.right;
#line 1270
    last_non_regular_expression = & alt->params.pair.right;
#line 1272
    goto switch_break___0;
    case_123___0: /* CIL Label */ 
#line 1277
    if (! (syntax & (unsigned long )(((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1282
      goto normal_backslash;
    } else
#line 1277
    if (syntax & (unsigned long )(((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1277
      if (syntax & (unsigned long )((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1282
        goto normal_backslash;
      } else {
#line 1277
        goto _L___21;
      }
    } else
    _L___21: /* CIL Label */ 
#line 1277
    if ((unsigned long )(p - 2) == (unsigned long )pattern) {
#line 1277
      if ((unsigned long )p == (unsigned long )pend) {
#line 1282
        goto normal_backslash;
      }
    }
    handle_interval: 
#line 1294
    lower_bound = -1;
#line 1295
    upper_bound = -1;
#line 1303
    beg_interval = p - 1;
#line 1305
    if ((unsigned long )p == (unsigned long )pend) {
#line 1307
      if (syntax & (unsigned long )((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1308
        goto unfetch_interval;
      } else {
#line 1310
        compile_error = (reg_errcode_t )9;
#line 1310
        goto error_return;
      }
    }
#line 1313
    if ((unsigned long )p != (unsigned long )pend) {
      {
#line 1313
      while (1) {
        while_continue___21: /* CIL Label */ ;
#line 1313
        if ((unsigned long )p == (unsigned long )pend) {
#line 1313
          return ((reg_errcode_t )14);
        }
#line 1313
        tmp___84 = p;
#line 1313
        p ++;
#line 1313
        c = (unsigned char )*tmp___84;
#line 1313
        c = *(translate + c);
#line 1313
        goto while_break___21;
      }
      while_break___21: /* CIL Label */ ;
      }
      {
#line 1313
      while (1) {
        while_continue___22: /* CIL Label */ ;
        {
#line 1313
        tmp___86 = isdigit((int )c);
        }
#line 1313
        if (! tmp___86) {
#line 1313
          goto while_break___22;
        }
#line 1313
        if (lower_bound < 0) {
#line 1313
          lower_bound = 0;
        }
#line 1313
        lower_bound = (lower_bound * 10 + (int )c) - 48;
#line 1313
        if ((unsigned long )p == (unsigned long )pend) {
#line 1313
          goto while_break___22;
        }
        {
#line 1313
        while (1) {
          while_continue___23: /* CIL Label */ ;
#line 1313
          if ((unsigned long )p == (unsigned long )pend) {
#line 1313
            return ((reg_errcode_t )14);
          }
#line 1313
          tmp___85 = p;
#line 1313
          p ++;
#line 1313
          c = (unsigned char )*tmp___85;
#line 1313
          c = *(translate + c);
#line 1313
          goto while_break___23;
        }
        while_break___23: /* CIL Label */ ;
        }
      }
      while_break___22: /* CIL Label */ ;
      }
    }
#line 1315
    if ((int )c == 44) {
#line 1317
      if ((unsigned long )p != (unsigned long )pend) {
        {
#line 1317
        while (1) {
          while_continue___24: /* CIL Label */ ;
#line 1317
          if ((unsigned long )p == (unsigned long )pend) {
#line 1317
            return ((reg_errcode_t )14);
          }
#line 1317
          tmp___87 = p;
#line 1317
          p ++;
#line 1317
          c = (unsigned char )*tmp___87;
#line 1317
          c = *(translate + c);
#line 1317
          goto while_break___24;
        }
        while_break___24: /* CIL Label */ ;
        }
        {
#line 1317
        while (1) {
          while_continue___25: /* CIL Label */ ;
          {
#line 1317
          tmp___89 = isdigit((int )c);
          }
#line 1317
          if (! tmp___89) {
#line 1317
            goto while_break___25;
          }
#line 1317
          if (upper_bound < 0) {
#line 1317
            upper_bound = 0;
          }
#line 1317
          upper_bound = (upper_bound * 10 + (int )c) - 48;
#line 1317
          if ((unsigned long )p == (unsigned long )pend) {
#line 1317
            goto while_break___25;
          }
          {
#line 1317
          while (1) {
            while_continue___26: /* CIL Label */ ;
#line 1317
            if ((unsigned long )p == (unsigned long )pend) {
#line 1317
              return ((reg_errcode_t )14);
            }
#line 1317
            tmp___88 = p;
#line 1317
            p ++;
#line 1317
            c = (unsigned char )*tmp___88;
#line 1317
            c = *(translate + c);
#line 1317
            goto while_break___26;
          }
          while_break___26: /* CIL Label */ ;
          }
        }
        while_break___25: /* CIL Label */ ;
        }
      }
#line 1318
      if (upper_bound < 0) {
#line 1318
        upper_bound = (1 << 15) - 1;
      }
    } else {
#line 1323
      upper_bound = lower_bound;
    }
#line 1325
    if (lower_bound < 0) {
#line 1325
      goto _L___22;
    } else
#line 1325
    if (upper_bound > (1 << 15) - 1) {
#line 1325
      goto _L___22;
    } else
#line 1325
    if (lower_bound > upper_bound) {
      _L___22: /* CIL Label */ 
#line 1329
      if (syntax & (unsigned long )((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1330
        goto unfetch_interval;
      } else {
#line 1332
        compile_error = (reg_errcode_t )10;
#line 1332
        goto error_return;
      }
    }
#line 1335
    if (! (syntax & (unsigned long )((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1337
      if ((int )c != 92) {
#line 1337
        compile_error = (reg_errcode_t )9;
#line 1337
        goto error_return;
      }
      {
#line 1338
      while (1) {
        while_continue___27: /* CIL Label */ ;
#line 1338
        if ((unsigned long )p == (unsigned long )pend) {
#line 1338
          return ((reg_errcode_t )14);
        }
#line 1338
        tmp___90 = p;
#line 1338
        p ++;
#line 1338
        c = (unsigned char )*tmp___90;
#line 1338
        c = *(translate + c);
#line 1338
        goto while_break___27;
      }
      while_break___27: /* CIL Label */ ;
      }
    }
#line 1341
    if ((int )c != 125) {
#line 1343
      if (syntax & (unsigned long )((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1344
        goto unfetch_interval;
      } else {
#line 1346
        compile_error = (reg_errcode_t )10;
#line 1346
        goto error_return;
      }
    }
    {
#line 1355
    tmp___91 = pointless_if_repeated(*last_expression);
    }
#line 1355
    if (tmp___91) {
#line 1357
      if (syntax & (unsigned long )(((((1 << 1) << 1) << 1) << 1) << 1)) {
#line 1358
        compile_error = (reg_errcode_t )13;
#line 1358
        goto error_return;
      } else
#line 1359
      if (! (syntax & (unsigned long )((((1 << 1) << 1) << 1) << 1))) {
#line 1361
        goto unfetch_interval;
      }
    }
#line 1367
    if (*last_expression) {
#line 1367
      if ((unsigned int )(*last_expression)->type == 6U) {
        {
#line 1368
        tmp___92 = factor_string(& last_expression, cset_size);
        }
#line 1368
        if (tmp___92) {
#line 1369
          goto space_error;
        }
      }
    }
    {
#line 1370
    interval = rx_mk_r_monop(8, *last_expression);
    }
#line 1371
    if (! interval) {
#line 1372
      goto space_error;
    }
#line 1373
    interval->params.intval = lower_bound;
#line 1374
    interval->params.intval2 = upper_bound;
#line 1375
    *last_expression = interval;
#line 1376
    last_non_regular_expression = last_expression;
#line 1378
    beg_interval = (char const   *)0;
#line 1380
    goto switch_break___0;
    unfetch_interval: 
#line 1384
    p = beg_interval;
#line 1385
    beg_interval = (char const   *)0;
    {
#line 1388
    while (1) {
      while_continue___28: /* CIL Label */ ;
#line 1388
      if ((unsigned long )p == (unsigned long )pend) {
#line 1388
        return ((reg_errcode_t )14);
      }
#line 1388
      tmp___93 = p;
#line 1388
      p ++;
#line 1388
      c = (unsigned char )*tmp___93;
#line 1388
      c = *(translate + c);
#line 1388
      goto while_break___28;
    }
    while_break___28: /* CIL Label */ ;
    }
#line 1390
    if (! (syntax & (unsigned long )((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1392
      if ((unsigned long )p > (unsigned long )pattern) {
#line 1392
        if ((int const   )*(p + -1) == 92) {
#line 1393
          goto normal_backslash;
        }
      }
    }
#line 1395
    goto normal_char;
    case_87: /* CIL Label */ 
    case_119: /* CIL Label */ 
    {
#line 1455
    cs___1 = rx_cset(cset_size);
    }
#line 1456
    if (cs___1) {
      {
#line 1456
      tmp___94 = rx_mk_r_cset(0, cset_size, cs___1);
#line 1456
      n___2 = tmp___94;
      }
    } else {
#line 1456
      n___2 = (struct rexp_node *)0;
    }
#line 1457
    if (cs___1) {
#line 1457
      if (! n___2) {
#line 1457
        goto _L___23;
      }
    } else {
      _L___23: /* CIL Label */ 
#line 1459
      if (cs___1) {
        {
#line 1460
        rx_free_cset(cs___1);
        }
      }
#line 1461
      goto space_error;
    }
#line 1463
    if ((int )c == 87) {
      {
#line 1464
      rx_bitset_universe(cset_size, cs___1);
      }
    }
#line 1467
    x = cset_size - 1;
    {
#line 1467
    while (1) {
      while_continue___29: /* CIL Label */ ;
#line 1467
      if (! (x > 0)) {
#line 1467
        goto while_break___29;
      }
#line 1468
      if ((int )re_syntax_table[x] & 1) {
#line 1469
        *(cs___1 + (unsigned long )x / (8UL * sizeof(RX_subset ))) ^= rx_subset_singletons[(unsigned long )x & (8UL * sizeof(RX_subset ) - 1UL)];
      }
#line 1467
      x --;
    }
    while_break___29: /* CIL Label */ ;
    }
#line 1471
    append = n___2;
#line 1472
    goto append_node;
#line 1474
    goto switch_break___0;
    case_60: /* CIL Label */ 
#line 1477
    side = '<';
#line 1478
    goto add_side_effect;
#line 1479
    goto switch_break___0;
    case_62: /* CIL Label */ 
#line 1482
    side = '>';
#line 1483
    goto add_side_effect;
#line 1484
    goto switch_break___0;
    case_98: /* CIL Label */ 
#line 1487
    side = 'b';
#line 1488
    goto add_side_effect;
#line 1489
    goto switch_break___0;
    case_66: /* CIL Label */ 
#line 1492
    side = 'B';
#line 1493
    goto add_side_effect;
#line 1494
    goto switch_break___0;
    case_96: /* CIL Label */ 
#line 1497
    side = '`';
#line 1498
    goto add_side_effect;
#line 1499
    goto switch_break___0;
    case_39: /* CIL Label */ 
#line 1502
    side = '\'';
#line 1503
    goto add_side_effect;
#line 1504
    goto switch_break___0;
    add_side_effect: 
    {
#line 1509
    se = rx_mk_r_int(10, side);
    }
#line 1510
    if (! se) {
#line 1511
      goto space_error;
    }
#line 1512
    append = se;
#line 1513
    goto append_node;
#line 1515
    goto switch_break___0;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
#line 1519
    if (syntax & (unsigned long )((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1520
      goto normal_char;
    }
#line 1522
    c1 = (unsigned char )((int )c - 48);
#line 1524
    if ((int )c1 > regnum) {
#line 1525
      compile_error = (reg_errcode_t )6;
#line 1525
      goto error_return;
    }
#line 1527
    side = (int )c;
#line 1528
    goto add_side_effect;
#line 1529
    goto switch_break___0;
    case_63___0: /* CIL Label */ 
    case_43___0: /* CIL Label */ 
#line 1533
    if (syntax & (unsigned long )(1 << 1)) {
#line 1534
      goto handle_plus;
    }
    normal_backslash: 
    switch_default: /* CIL Label */ 
#line 1544
    c = *(translate + c);
#line 1545
    goto normal_char;
    switch_break___0: /* CIL Label */ ;
    }
#line 1547
    goto switch_break;
    normal_char: 
    switch_default___0: /* CIL Label */ 
    {
#line 1558
    it___4 = inverse_translation(n_members, cset_size, validate_inv_tr, inverse_translate,
                                 translate, (int )c);
    }
#line 1562
    if (1 != n_members[c]) {
      {
#line 1564
      cs___2 = rx_cset(cset_size);
      }
#line 1565
      if (cs___2) {
        {
#line 1565
        tmp___95 = rx_mk_r_cset(0, cset_size, cs___2);
#line 1565
        match = tmp___95;
        }
      } else {
#line 1565
        match = (struct rexp_node *)0;
      }
#line 1566
      if (cs___2) {
#line 1566
        if (! match) {
#line 1566
          goto _L___24;
        }
      } else {
        _L___24: /* CIL Label */ 
#line 1568
        if (cs___2) {
          {
#line 1569
          rx_free_cset(cs___2);
          }
        }
#line 1570
        goto space_error;
      }
      {
#line 1572
      rx_bitset_union(1 << 8, cs___2, it___4);
#line 1573
      append = match;
      }
#line 1574
      goto append_node;
    } else
#line 1578
    if (*last_expression) {
#line 1578
      if ((unsigned int )(*last_expression)->type == 6U) {
        {
#line 1580
        tmp___96 = rx_adjoin_string(& (*last_expression)->params.cstr, (char )c);
        }
#line 1580
        if (tmp___96) {
#line 1581
          goto space_error;
        }
#line 1582
        goto switch_break;
      } else {
#line 1578
        goto _L___25;
      }
    } else {
      _L___25: /* CIL Label */ 
      {
#line 1586
      append = rx_mk_r_str(6, (char )c);
      }
#line 1587
      if (! append) {
#line 1588
        goto space_error;
      }
#line 1589
      goto append_node;
    }
#line 1592
    goto switch_break;
    append_node: 
#line 1598
    if ((unsigned int )append->type <= 8U) {
#line 1600
      if (! *last_expression) {
#line 1601
        *last_expression = append;
      } else {
        {
#line 1605
        concat___0 = rx_mk_r_binop(1, *last_expression, append);
        }
#line 1607
        if (! concat___0) {
#line 1608
          goto space_error;
        }
#line 1609
        *last_expression = concat___0;
#line 1610
        last_expression = & concat___0->params.pair.right;
      }
    } else
#line 1615
    if (! *last_non_regular_expression) {
#line 1617
      *last_non_regular_expression = append;
#line 1618
      last_expression = last_non_regular_expression;
    } else {
      {
#line 1623
      concat___1 = rx_mk_r_binop(1, *last_non_regular_expression, append);
      }
#line 1625
      if (! concat___1) {
#line 1626
        goto space_error;
      }
#line 1627
      *last_non_regular_expression = concat___1;
#line 1628
      last_non_regular_expression = & concat___1->params.pair.right;
#line 1629
      last_expression = last_non_regular_expression;
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1639
  if (! (compile_stack.avail == 0U)) {
#line 1640
    compile_error = (reg_errcode_t )8;
#line 1640
    goto error_return;
  }
  {
#line 1641
  free((void *)compile_stack.stack);
#line 1644
  *rexp_p = rexp;
  }
#line 1645
  return ((reg_errcode_t )0);
  space_error: 
#line 1648
  compile_error = (reg_errcode_t )12;
  error_return: 
  {
#line 1651
  free((void *)compile_stack.stack);
  }
#line 1653
  if (rexp) {
    {
#line 1654
    rx_free_rexp(rexp);
    }
  }
#line 1655
  return (compile_error);
}
}
#line 339 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 562
extern int putchar(int __c ) ;
#line 87 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxbitset.h"
int rx_bitset_population(int size , rx_Bitset a ) ;
#line 34 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxdbug.c"
char *node_type_names[11]  = 
#line 34 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxdbug.c"
  {      (char *)"r_cset",      (char *)"r_concat",      (char *)"r_alternate",      (char *)"r_opt", 
        (char *)"r_star",      (char *)"r_plus",      (char *)"r_string",      (char *)"r_cut", 
        (char *)"r_interval",      (char *)"r_parens",      (char *)"r_context"};
#line 50 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxdbug.c"
void print_cset(int cset_size , rx_Bitset cs ) 
{ 
  int x ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 56
  if (! cs) {
    {
#line 57
    printf((char const   */* __restrict  */)"nil");
    }
  } else {
    {
#line 60
    putchar('[');
#line 61
    x = 0;
    }
    {
#line 61
    while (1) {
      while_continue: /* CIL Label */ ;
#line 61
      if (! (x < cset_size)) {
#line 61
        goto while_break;
      }
#line 62
      if (*(cs + (unsigned long )x / (8UL * sizeof(RX_subset ))) & rx_subset_singletons[(unsigned long )x & (8UL * sizeof(RX_subset ) - 1UL)]) {
        {
#line 64
        tmp = isprint(x);
        }
#line 64
        if (tmp) {
          {
#line 65
          putchar(x);
          }
        } else {
          {
#line 67
          printf((char const   */* __restrict  */)"\\0%o ", x);
          }
        }
      }
#line 61
      x ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 69
    putchar(']');
    }
  }
#line 71
  return;
}
}
#line 73 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxdbug.c"
void print_string(struct rx_string *s___0 , char bracket ) 
{ 
  int x ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 77
  if (! s___0) {
#line 77
    if (bracket) {
      {
#line 78
      printf((char const   */* __restrict  */)"nil");
      }
    } else {
#line 77
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 81
    if (bracket) {
      {
#line 82
      putchar('\"');
      }
    }
#line 83
    x = 0;
    {
#line 83
    while (1) {
      while_continue: /* CIL Label */ ;
#line 83
      if (! ((unsigned long )x < s___0->len)) {
#line 83
        goto while_break;
      }
      {
#line 84
      tmp = isprint((int )*(s___0->contents + x));
      }
#line 84
      if (tmp) {
        {
#line 85
        putchar((int )*(s___0->contents + x));
        }
      } else {
        {
#line 87
        printf((char const   */* __restrict  */)"\\0%o ", x);
        }
      }
#line 83
      x ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 88
    if (bracket) {
      {
#line 89
      putchar('\"');
      }
    }
  }
#line 91
  return;
}
}
#line 93 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxdbug.c"
void spaces(int n ) 
{ 
  int tmp ;

  {
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    tmp = n;
#line 97
    n --;
#line 97
    if (! tmp) {
#line 97
      goto while_break;
    }
    {
#line 98
    putchar(' ');
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  return;
}
}
#line 101 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxdbug.c"
void print_rexp(int cset_size , int indent___0 , struct rexp_node *rexp ) 
{ 
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 107
  spaces(indent___0);
  }
#line 108
  if (! rexp) {
    {
#line 109
    printf((char const   */* __restrict  */)"nil\n");
    }
  } else {
    {
#line 112
    tmp___1 = isprint(rexp->params.intval);
    }
#line 112
    if (tmp___1) {
#line 112
      tmp___0 = rexp->params.intval;
    } else {
#line 112
      tmp___0 = ' ';
    }
    {
#line 112
    printf((char const   */* __restrict  */)"Node %d type %d (%s), iv=%d(%c), iv2=%d, len=%d obs=%d cs=",
           rexp->id, (unsigned int )rexp->type, node_type_names[rexp->type], rexp->params.intval,
           tmp___0, rexp->params.intval2, rexp->len, rexp->observed);
#line 121
    print_cset(cset_size, rexp->params.cset);
#line 122
    printf((char const   */* __restrict  */)" s=");
#line 123
    print_string(& rexp->params.cstr, (char)1);
#line 124
    putchar('\n');
    }
#line 125
    if (rexp->params.pair.left) {
      {
#line 127
      print_rexp(cset_size, indent___0 + 2, rexp->params.pair.left);
#line 128
      print_rexp(cset_size, indent___0 + 2, rexp->params.pair.right);
      }
    } else
#line 125
    if (rexp->params.pair.right) {
      {
#line 127
      print_rexp(cset_size, indent___0 + 2, rexp->params.pair.left);
#line 128
      print_rexp(cset_size, indent___0 + 2, rexp->params.pair.right);
      }
    }
  }
#line 131
  return;
}
}
#line 136 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxdbug.c"
void unparse_print_rexp(int cset_size , struct rexp_node *rexp ) 
{ 
  int x ;
  rx_Bitset cs ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 141
  if (! rexp) {
#line 142
    return;
  } else {
    {
#line 146
    if ((unsigned int )rexp->type == 0U) {
#line 146
      goto case_0;
    }
#line 166
    if ((unsigned int )rexp->type == 6U) {
#line 166
      goto case_6;
    }
#line 170
    if ((unsigned int )rexp->type == 9U) {
#line 170
      goto case_9;
    }
#line 176
    if ((unsigned int )rexp->type == 10U) {
#line 176
      goto case_10;
    }
#line 181
    if ((unsigned int )rexp->type == 1U) {
#line 181
      goto case_1;
    }
#line 186
    if ((unsigned int )rexp->type == 2U) {
#line 186
      goto case_2;
    }
#line 192
    if ((unsigned int )rexp->type == 3U) {
#line 192
      goto case_3;
    }
#line 197
    if ((unsigned int )rexp->type == 4U) {
#line 197
      goto case_4;
    }
#line 202
    if ((unsigned int )rexp->type == 5U) {
#line 202
      goto case_5;
    }
#line 207
    if ((unsigned int )rexp->type == 8U) {
#line 207
      goto case_8;
    }
#line 144
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 147
    tmp___0 = rx_bitset_population(cset_size, rexp->params.cset);
    }
#line 147
    if (1 != tmp___0) {
      {
#line 148
      print_cset(cset_size, rexp->params.cset);
      }
    } else {
#line 154
      cs = rexp->params.cset;
#line 155
      x = 0;
      {
#line 155
      while (1) {
        while_continue: /* CIL Label */ ;
#line 155
        if (! (x < cset_size)) {
#line 155
          goto while_break;
        }
#line 156
        if (*(cs + (unsigned long )x / (8UL * sizeof(RX_subset ))) & rx_subset_singletons[(unsigned long )x & (8UL * sizeof(RX_subset ) - 1UL)]) {
          {
#line 158
          tmp = isprint(x);
          }
#line 158
          if (tmp) {
            {
#line 159
            putchar(x);
            }
          } else {
            {
#line 161
            printf((char const   */* __restrict  */)"\\0%o ", x);
            }
          }
        }
#line 155
        x ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 164
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 167
    print_string(& rexp->params.cstr, (char)0);
    }
#line 168
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 171
    putchar('(');
#line 172
    unparse_print_rexp(cset_size, rexp->params.pair.left);
#line 173
    putchar(')');
    }
#line 174
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 177
    putchar('\\');
#line 178
    putchar(rexp->params.intval);
    }
#line 179
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 182
    unparse_print_rexp(cset_size, rexp->params.pair.left);
#line 183
    unparse_print_rexp(cset_size, rexp->params.pair.right);
    }
#line 184
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 187
    unparse_print_rexp(cset_size, rexp->params.pair.left);
#line 188
    putchar('|');
#line 189
    unparse_print_rexp(cset_size, rexp->params.pair.right);
    }
#line 190
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 193
    unparse_print_rexp(cset_size, rexp->params.pair.left);
#line 194
    putchar('?');
    }
#line 195
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 198
    unparse_print_rexp(cset_size, rexp->params.pair.left);
#line 199
    putchar('*');
    }
#line 200
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 203
    unparse_print_rexp(cset_size, rexp->params.pair.left);
#line 204
    putchar('+');
    }
#line 205
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 208
    unparse_print_rexp(cset_size, rexp->params.pair.left);
#line 209
    printf((char const   */* __restrict  */)"{%d,%d}", rexp->params.intval, rexp->params.intval2);
    }
#line 210
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 212
  return;
}
}
#line 215 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxdbug.c"
void print_nfa_state(struct rx *rx , struct rx_nfa_state *state ) 
{ 
  struct rx_nfa_edge *e ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 221
  printf((char const   */* __restrict  */)"state %d, is_final %d, is_start %d\n",
         state->id, state->is_final, state->is_start);
#line 223
  e = state->edges;
  }
  {
#line 223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 223
    if (! e) {
#line 223
      goto while_break;
    }
#line 225
    if ((unsigned int )e->type == 0U) {
#line 225
      tmp___0 = "cset";
    } else {
#line 225
      if ((unsigned int )e->type == 1U) {
#line 225
        tmp = "epsilon";
      } else {
#line 225
        tmp = "side effect";
      }
#line 225
      tmp___0 = tmp;
    }
    {
#line 225
    printf((char const   */* __restrict  */)"\tEdge %s to %d ", tmp___0, (e->dest)->id);
    }
#line 232
    if ((unsigned int )e->type == 0U) {
      {
#line 233
      print_cset(rx->local_cset_size, e->params.cset);
      }
    } else {
      {
#line 235
      printf((char const   */* __restrict  */)"%d", (int )e->params.side_effect);
      }
    }
    {
#line 236
    putchar('\n');
#line 223
    e = e->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 238
  return;
}
}
#line 240 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxdbug.c"
void print_nfa(struct rx *rx ) 
{ 
  struct rx_nfa_state *state ;

  {
#line 245
  state = rx->nfa_states;
  {
#line 245
  while (1) {
    while_continue: /* CIL Label */ ;
#line 245
    if (! state) {
#line 245
      goto while_break;
    }
    {
#line 246
    print_nfa_state(rx, state);
#line 245
    state = state->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 247
  return;
}
}
#line 31 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxcset.c"
rx_Bitset rx_cset(int size ) 
{ 
  rx_Bitset b ;
  void *tmp ;

  {
  {
#line 40
  tmp = malloc(((((unsigned long )size + 8UL * sizeof(RX_subset )) - 1UL) / (8UL * sizeof(RX_subset ))) * sizeof(RX_subset ));
#line 40
  b = (rx_Bitset )tmp;
  }
#line 41
  if (b) {
    {
#line 42
    rx_bitset_null(size, b);
    }
  }
#line 43
  return (b);
}
}
#line 48 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxcset.c"
rx_Bitset rx_copy_cset(int size , rx_Bitset a ) 
{ 
  rx_Bitset cs ;

  {
  {
#line 58
  cs = rx_cset(size);
  }
#line 60
  if (cs) {
    {
#line 61
    rx_bitset_union(size, cs, a);
    }
  }
#line 63
  return (cs);
}
}
#line 68 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxcset.c"
void rx_free_cset(rx_Bitset c ) 
{ 


  {
#line 76
  if (c) {
    {
#line 77
    free((void *)((char *)c));
    }
  }
#line 78
  return;
}
}
#line 74 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxbitset.h"
int rx_bitset_empty(int size , rx_Bitset set ) ;
#line 83
void rx_bitset_revdifference(int size , rx_Bitset a , rx_Bitset b ) ;
#line 85
void rx_bitset_xor(int size , rx_Bitset a , rx_Bitset b ) ;
#line 30 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxbitset.c"
int rx_bitset_is_equal(int size , rx_Bitset a , rx_Bitset b ) 
{ 
  int x ;
  RX_subset s___0 ;
  int tmp ;

  {
#line 43
  if (size == 0) {
#line 44
    return (1);
  }
#line 46
  s___0 = *(b + 0);
#line 47
  *(b + 0) = ~ *(a + 0);
#line 49
  x = (int )((((unsigned long )size + 8UL * sizeof(RX_subset )) - 1UL) / (8UL * sizeof(RX_subset )) - 1UL);
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    if (! (*(a + x) == *(b + x))) {
#line 49
      goto while_break;
    }
#line 49
    x --;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  *(b + 0) = s___0;
#line 53
  if (! x) {
#line 53
    if (s___0 == *(a + 0)) {
#line 53
      tmp = 1;
    } else {
#line 53
      tmp = 0;
    }
  } else {
#line 53
    tmp = 0;
  }
#line 53
  return (tmp);
}
}
#line 58 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxbitset.c"
int rx_bitset_is_subset(int size , rx_Bitset a , rx_Bitset b ) 
{ 
  int x ;
  int tmp ;

  {
#line 69
  x = (int )((((unsigned long )size + 8UL * sizeof(RX_subset )) - 1UL) / (8UL * sizeof(RX_subset )) - 1UL);
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    tmp = x;
#line 70
    x --;
#line 70
    if (tmp) {
#line 70
      if (! ((*(a + x) & *(b + x)) == *(a + x))) {
#line 70
        goto while_break;
      }
    } else {
#line 70
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  return (x == -1);
}
}
#line 76 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxbitset.c"
int rx_bitset_empty(int size , rx_Bitset set ) 
{ 
  int x ;
  RX_subset s___0 ;

  {
#line 87
  s___0 = *(set + 0);
#line 88
  *(set + 0) = (RX_subset )1;
#line 89
  x = (int )((((unsigned long )size + 8UL * sizeof(RX_subset )) - 1UL) / (8UL * sizeof(RX_subset )) - 1UL);
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! (! *(set + x))) {
#line 89
      goto while_break;
    }
#line 89
    x --;
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  *(set + 0) = s___0;
#line 92
  return (! s___0);
}
}
#line 96 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxbitset.c"
void rx_bitset_null(int size , rx_Bitset b ) 
{ 


  {
  {
#line 105
  rx_bzero((char *)b, ((((unsigned long )size + 8UL * sizeof(RX_subset )) - 1UL) / (8UL * sizeof(RX_subset ))) * sizeof(RX_subset ));
  }
#line 106
  return;
}
}
#line 110 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxbitset.c"
void rx_bitset_universe(int size , rx_Bitset b ) 
{ 
  int x ;
  rx_Bitset tmp ;
  int tmp___0 ;

  {
#line 119
  x = (int )((((unsigned long )size + 8UL * sizeof(RX_subset )) - 1UL) / (8UL * sizeof(RX_subset )));
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    tmp___0 = x;
#line 120
    x --;
#line 120
    if (! tmp___0) {
#line 120
      goto while_break;
    }
#line 121
    tmp = b;
#line 121
    b ++;
#line 121
    *tmp = ~ ((RX_subset )0);
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  return;
}
}
#line 126 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxbitset.c"
void rx_bitset_complement(int size , rx_Bitset b ) 
{ 
  int x ;
  int tmp ;

  {
#line 135
  x = (int )((((unsigned long )size + 8UL * sizeof(RX_subset )) - 1UL) / (8UL * sizeof(RX_subset )));
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    tmp = x;
#line 136
    x --;
#line 136
    if (! tmp) {
#line 136
      goto while_break;
    }
#line 138
    *b = ~ *b;
#line 139
    b ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 141
  return;
}
}
#line 145 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxbitset.c"
void rx_bitset_assign(int size , rx_Bitset a , rx_Bitset b ) 
{ 
  int x ;

  {
#line 156
  x = (int )((((unsigned long )size + 8UL * sizeof(RX_subset )) - 1UL) / (8UL * sizeof(RX_subset )) - 1UL);
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (! (x >= 0)) {
#line 156
      goto while_break;
    }
#line 157
    *(a + x) = *(b + x);
#line 156
    x --;
  }
  while_break: /* CIL Label */ ;
  }
#line 158
  return;
}
}
#line 162 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxbitset.c"
void rx_bitset_union(int size , rx_Bitset a , rx_Bitset b ) 
{ 
  int x ;

  {
#line 173
  x = (int )((((unsigned long )size + 8UL * sizeof(RX_subset )) - 1UL) / (8UL * sizeof(RX_subset )) - 1UL);
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 173
    if (! (x >= 0)) {
#line 173
      goto while_break;
    }
#line 174
    *(a + x) |= *(b + x);
#line 173
    x --;
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  return;
}
}
#line 179 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxbitset.c"
void rx_bitset_intersection(int size , rx_Bitset a , rx_Bitset b ) 
{ 
  int x ;

  {
#line 191
  x = (int )((((unsigned long )size + 8UL * sizeof(RX_subset )) - 1UL) / (8UL * sizeof(RX_subset )) - 1UL);
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! (x >= 0)) {
#line 191
      goto while_break;
    }
#line 192
    *(a + x) &= *(b + x);
#line 191
    x --;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  return;
}
}
#line 197 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxbitset.c"
void rx_bitset_difference(int size , rx_Bitset a , rx_Bitset b ) 
{ 
  int x ;

  {
#line 208
  x = (int )((((unsigned long )size + 8UL * sizeof(RX_subset )) - 1UL) / (8UL * sizeof(RX_subset )) - 1UL);
  {
#line 208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    if (! (x >= 0)) {
#line 208
      goto while_break;
    }
#line 209
    *(a + x) &= ~ *(b + x);
#line 208
    x --;
  }
  while_break: /* CIL Label */ ;
  }
#line 210
  return;
}
}
#line 214 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxbitset.c"
void rx_bitset_revdifference(int size , rx_Bitset a , rx_Bitset b ) 
{ 
  int x ;

  {
#line 226
  x = (int )((((unsigned long )size + 8UL * sizeof(RX_subset )) - 1UL) / (8UL * sizeof(RX_subset )) - 1UL);
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 226
    if (! (x >= 0)) {
#line 226
      goto while_break;
    }
#line 227
    *(a + x) = ~ *(a + x) & *(b + x);
#line 226
    x --;
  }
  while_break: /* CIL Label */ ;
  }
#line 228
  return;
}
}
#line 231 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxbitset.c"
void rx_bitset_xor(int size , rx_Bitset a , rx_Bitset b ) 
{ 
  int x ;

  {
#line 242
  x = (int )((((unsigned long )size + 8UL * sizeof(RX_subset )) - 1UL) / (8UL * sizeof(RX_subset )) - 1UL);
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 242
    if (! (x >= 0)) {
#line 242
      goto while_break;
    }
#line 243
    *(a + x) ^= *(b + x);
#line 242
    x --;
  }
  while_break: /* CIL Label */ ;
  }
#line 244
  return;
}
}
#line 248 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxbitset.c"
unsigned long rx_bitset_hash(int size , rx_Bitset b ) 
{ 
  int x ;
  unsigned long answer ;

  {
#line 260
  answer = 0UL;
#line 262
  x = 0;
  {
#line 262
  while (1) {
    while_continue: /* CIL Label */ ;
#line 262
    if (! (x < size)) {
#line 262
      goto while_break;
    }
#line 264
    if (*(b + (unsigned long )x / (8UL * sizeof(RX_subset ))) & rx_subset_singletons[(unsigned long )x & (8UL * sizeof(RX_subset ) - 1UL)]) {
#line 265
      answer += (answer << 3) + (unsigned long )x;
    }
#line 262
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 267
  return (answer);
}
}
#line 271 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxbitset.c"
RX_subset rx_subset_singletons[8UL * sizeof(RX_subset )]  = 
#line 271
  {      (RX_subset )1,      (RX_subset )2,      (RX_subset )4,      (RX_subset )8, 
        (RX_subset )16,      (RX_subset )32,      (RX_subset )64,      (RX_subset )128, 
        (RX_subset )256,      (RX_subset )512,      (RX_subset )1024,      (RX_subset )2048, 
        (RX_subset )4096,      (RX_subset )8192,      (RX_subset )16384,      (RX_subset )32768, 
        (RX_subset )65536,      (RX_subset )131072,      (RX_subset )262144,      (RX_subset )524288, 
        (RX_subset )1048576,      (RX_subset )2097152,      (RX_subset )4194304,      (RX_subset )8388608, 
        (RX_subset )16777216,      (RX_subset )33554432,      (RX_subset )67108864,      (RX_subset )134217728, 
        (RX_subset )268435456,      (RX_subset )536870912,      (RX_subset )1073741824,      (RX_subset )2147483648U};
#line 316 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxbitset.c"
static int char_pops[256]  = 
#line 316
  {      0,      1,      1,      2, 
        1,      2,      2,      3, 
        1,      2,      2,      3, 
        2,      3,      3,      4, 
        1,      2,      2,      3, 
        2,      3,      3,      4, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        1,      2,      2,      3, 
        2,      3,      3,      4, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        1,      2,      2,      3, 
        2,      3,      3,      4, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        4,      5,      5,      6, 
        5,      6,      6,      7, 
        1,      2,      2,      3, 
        2,      3,      3,      4, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        4,      5,      5,      6, 
        5,      6,      6,      7, 
        2,      3,      3,      4, 
        3,      4,      4,      5, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        4,      5,      5,      6, 
        5,      6,      6,      7, 
        3,      4,      4,      5, 
        4,      5,      5,      6, 
        4,      5,      5,      6, 
        5,      6,      6,      7, 
        4,      5,      5,      6, 
        5,      6,      6,      7, 
        5,      6,      6,      7, 
        6,      7,      7,      8};
#line 339 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxbitset.c"
int rx_bitset_population(int size , rx_Bitset a ) 
{ 
  int x ;
  int total ;
  unsigned char s___0 ;

  {
#line 352
  if (size == 0) {
#line 353
    return (0);
  }
#line 355
  total = 0;
#line 356
  x = (int )(sizeof(RX_subset ) * ((((unsigned long )size + 8UL * sizeof(RX_subset )) - 1UL) / (8UL * sizeof(RX_subset ))) - 1UL);
  {
#line 357
  while (1) {
    while_continue: /* CIL Label */ ;
#line 357
    if (! (x >= 0)) {
#line 357
      goto while_break;
    }
#line 359
    s___0 = *((unsigned char *)a + x);
#line 360
    x --;
#line 361
    total += char_pops[s___0];
  }
  while_break: /* CIL Label */ ;
  }
#line 363
  return (total);
}
}
#line 32 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxbasic.h"
struct rx_unfaniverse *rx_basic_unfaniverse(void) ;
#line 28 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxbasic.c"
int rx_basic_unfaniverse_delay  =    64;
#line 29 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxbasic.c"
static struct rx_unfaniverse *rx_basic_uv  =    (struct rx_unfaniverse *)0;
#line 33 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxbasic.c"
static int init_basic_once(void) 
{ 
  int tmp ;

  {
#line 36
  if (rx_basic_uv) {
#line 37
    return (0);
  }
  {
#line 38
  rx_basic_uv = rx_make_unfaniverse(rx_basic_unfaniverse_delay);
  }
#line 39
  if (rx_basic_uv) {
#line 39
    tmp = 0;
  } else {
#line 39
    tmp = -1;
  }
#line 39
  return (tmp);
}
}
#line 44 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxbasic.c"
struct rx_unfaniverse *rx_basic_unfaniverse(void) 
{ 
  int tmp ;

  {
  {
#line 51
  tmp = init_basic_once();
  }
#line 51
  if (tmp) {
#line 52
    return ((struct rx_unfaniverse *)0);
  }
#line 53
  return (rx_basic_uv);
}
}
#line 57 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxbasic.c"
static char *silly_hack  =    (char *)0;
#line 60 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxbasic.c"
struct rx_solutions *rx_basic_make_solutions(struct rx_registers *regs , struct rexp_node *expression ,
                                             struct rexp_node **subexps , int start ,
                                             int end , struct rx_context_rules *rules ,
                                             unsigned char const   *str ) 
{ 
  struct rx_str_closure *closure ;
  int tmp ;
  void *tmp___0 ;
  struct rx_solutions *tmp___1 ;
  void *__cil_tmp12 ;

  {
  {
#line 75
  tmp = init_basic_once();
  }
#line 75
  if (tmp) {
#line 76
    return ((struct rx_solutions *)0);
  }
#line 77
  if (expression) {
#line 77
    if (expression->len >= 0) {
#line 77
      if (expression->len != end - start) {
#line 80
        return (& rx_no_solutions);
      }
    }
  }
#line 81
  if (silly_hack) {
#line 83
    closure = (struct rx_str_closure *)silly_hack;
#line 84
    silly_hack = (char *)0;
  } else {
    {
#line 87
    tmp___0 = malloc(sizeof(*closure));
#line 87
    closure = (struct rx_str_closure *)tmp___0;
    }
  }
#line 88
  if (! closure) {
#line 89
    return ((struct rx_solutions *)0);
  }
  {
#line 90
  closure->str = str;
#line 91
  closure->len = end;
#line 92
  closure->rules = *rules;
#line 93
  tmp___1 = rx_make_solutions(regs, rx_basic_uv, expression, subexps, 256, start,
                              end, & rx_str_vmfn, & rx_str_contextfn, (void *)closure);
  }
#line 93
  return (tmp___1);
}
}
#line 101 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxbasic.c"
void rx_basic_free_solutions(struct rx_solutions *solns ) 
{ 


  {
#line 109
  if ((unsigned long )solns == (unsigned long )(& rx_no_solutions)) {
#line 110
    return;
  }
#line 112
  if (! silly_hack) {
#line 113
    silly_hack = (char *)solns->closure;
  } else {
    {
#line 115
    free(solns->closure);
    }
  }
  {
#line 116
  solns->closure = (void *)0;
#line 117
  rx_free_solutions(solns);
  }
#line 118
  return;
}
}
#line 29 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxanal.c"
int rx_posix_analyze_rexp(struct rexp_node ***subexps , size_t *n_subexps , struct rexp_node *node ,
                          int id ) 
{ 
  size_t this_subexp ;
  void *tmp ;
  void *tmp___0 ;
  int lob ;
  int rob ;
  int llen ;
  int rlen ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 43
  if (node) {
#line 46
    if ((unsigned int )node->type == 9U) {
#line 48
      if (node->params.intval >= 0) {
#line 50
        this_subexp = *n_subexps;
#line 51
        (*n_subexps) ++;
#line 52
        if (! *subexps) {
          {
#line 53
          tmp = malloc(sizeof(struct rexp_node *) * *n_subexps);
#line 53
          *subexps = (struct rexp_node **)tmp;
          }
        } else {
          {
#line 55
          tmp___0 = realloc((void *)*subexps, sizeof(struct rexp_node *) * *n_subexps);
#line 55
          *subexps = (struct rexp_node **)tmp___0;
          }
        }
      }
    }
#line 59
    if (node->params.pair.left) {
      {
#line 60
      id = rx_posix_analyze_rexp(subexps, n_subexps, node->params.pair.left, id);
      }
    }
#line 61
    if (node->params.pair.right) {
      {
#line 62
      id = rx_posix_analyze_rexp(subexps, n_subexps, node->params.pair.right, id);
      }
    }
    {
#line 65
    if ((unsigned int )node->type == 0U) {
#line 65
      goto case_0;
    }
#line 69
    if ((unsigned int )node->type == 6U) {
#line 69
      goto case_6;
    }
#line 73
    if ((unsigned int )node->type == 7U) {
#line 73
      goto case_7;
    }
#line 78
    if ((unsigned int )node->type == 2U) {
#line 78
      goto case_2;
    }
#line 78
    if ((unsigned int )node->type == 1U) {
#line 78
      goto case_2;
    }
#line 96
    if ((unsigned int )node->type == 5U) {
#line 96
      goto case_5;
    }
#line 96
    if ((unsigned int )node->type == 4U) {
#line 96
      goto case_5;
    }
#line 96
    if ((unsigned int )node->type == 3U) {
#line 96
      goto case_5;
    }
#line 103
    if ((unsigned int )node->type == 8U) {
#line 103
      goto case_8;
    }
#line 108
    if ((unsigned int )node->type == 9U) {
#line 108
      goto case_9;
    }
#line 122
    if ((unsigned int )node->type == 10U) {
#line 122
      goto case_10;
    }
#line 63
    goto switch_break;
    case_0: /* CIL Label */ 
#line 66
    node->len = 1;
#line 67
    node->observed = 0;
#line 68
    goto switch_break;
    case_6: /* CIL Label */ 
#line 70
    node->len = (int )node->params.cstr.len;
#line 71
    node->observed = 0;
#line 72
    goto switch_break;
    case_7: /* CIL Label */ 
#line 74
    node->len = 0;
#line 75
    node->observed = 0;
#line 76
    goto switch_break;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 82
    if (! node->params.pair.left) {
#line 82
      lob = 0;
    } else {
#line 82
      lob = (node->params.pair.left)->observed;
    }
#line 83
    if (! node->params.pair.right) {
#line 83
      rob = 0;
    } else {
#line 83
      rob = (node->params.pair.right)->observed;
    }
#line 84
    if (! node->params.pair.left) {
#line 84
      llen = 0;
    } else {
#line 84
      llen = (node->params.pair.left)->len;
    }
#line 85
    if (! node->params.pair.right) {
#line 85
      rlen = 0;
    } else {
#line 85
      rlen = (node->params.pair.right)->len;
    }
#line 86
    if (llen >= 0) {
#line 86
      if (rlen >= 0) {
#line 86
        if ((unsigned int )node->type == 1U) {
#line 86
          tmp___2 = llen + rlen;
        } else {
#line 86
          if (llen == rlen) {
#line 86
            tmp___1 = llen;
          } else {
#line 86
            tmp___1 = -1;
          }
#line 86
          tmp___2 = tmp___1;
        }
#line 86
        node->len = tmp___2;
      } else {
#line 86
        node->len = -1;
      }
    } else {
#line 86
      node->len = -1;
    }
#line 91
    if (lob) {
#line 91
      tmp___3 = 1;
    } else
#line 91
    if (rob) {
#line 91
      tmp___3 = 1;
    } else {
#line 91
      tmp___3 = 0;
    }
#line 91
    node->observed = tmp___3;
#line 92
    goto switch_break;
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
    case_3: /* CIL Label */ 
#line 97
    node->len = -1;
#line 98
    if (node->params.pair.left) {
#line 98
      node->observed = (node->params.pair.left)->observed;
    } else {
#line 98
      node->observed = 0;
    }
#line 101
    goto switch_break;
    case_8: /* CIL Label */ 
#line 104
    node->len = -1;
#line 105
    node->observed = 1;
#line 106
    goto switch_break;
    case_9: /* CIL Label */ 
#line 109
    if (node->params.intval >= 0) {
#line 111
      node->observed = 1;
#line 112
      *(*subexps + this_subexp) = node;
    } else
#line 115
    if (node->params.pair.left) {
#line 115
      node->observed = (node->params.pair.left)->observed;
    } else {
#line 115
      node->observed = 0;
    }
#line 118
    if (node->params.pair.left) {
#line 118
      node->len = (node->params.pair.left)->len;
    } else {
#line 118
      node->len = 0;
    }
#line 121
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 137
    if (node->params.intval == 39) {
#line 137
      goto case_39;
    }
#line 137
    if (node->params.intval == 96) {
#line 137
      goto case_39;
    }
#line 137
    if (node->params.intval == 66) {
#line 137
      goto case_39;
    }
#line 137
    if (node->params.intval == 98) {
#line 137
      goto case_39;
    }
#line 137
    if (node->params.intval == 62) {
#line 137
      goto case_39;
    }
#line 137
    if (node->params.intval == 60) {
#line 137
      goto case_39;
    }
#line 137
    if (node->params.intval == 61) {
#line 137
      goto case_39;
    }
#line 137
    if (node->params.intval == 36) {
#line 137
      goto case_39;
    }
#line 137
    if (node->params.intval == 94) {
#line 137
      goto case_39;
    }
#line 125
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 126
    node->observed = 1;
#line 127
    node->len = -1;
#line 128
    goto switch_break___0;
    case_39: /* CIL Label */ 
    case_96: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_62: /* CIL Label */ 
    case_60: /* CIL Label */ 
    case_61: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_94: /* CIL Label */ 
#line 138
    node->observed = 1;
#line 139
    node->len = 0;
#line 140
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 142
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 144
    if (node->observed) {
#line 145
      tmp___4 = id;
#line 145
      id ++;
#line 145
      node->id = tmp___4;
    }
#line 146
    return (id);
  }
#line 148
  return (0);
}
}
#line 152 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxanal.c"
int rx_fill_in_fastmap(int cset_size , unsigned char *map , struct rexp_node *exp___0 ) 
{ 
  int x ;
  int x___0 ;
  int most ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 162
  if (! exp___0) {
    can_match_empty: 
#line 167
    x = 0;
    {
#line 167
    while (1) {
      while_continue: /* CIL Label */ ;
#line 167
      if (! (x < cset_size)) {
#line 167
        goto while_break;
      }
#line 168
      *(map + x) = (unsigned char)1;
#line 167
      x ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 170
    return (1);
  }
  {
#line 175
  if ((unsigned int )exp___0->type == 0U) {
#line 175
    goto case_0;
  }
#line 187
  if ((unsigned int )exp___0->type == 6U) {
#line 187
    goto case_6;
  }
#line 196
  if ((unsigned int )exp___0->type == 7U) {
#line 196
    goto case_7;
  }
#line 200
  if ((unsigned int )exp___0->type == 1U) {
#line 200
    goto case_1;
  }
#line 210
  if ((unsigned int )exp___0->type == 2U) {
#line 210
    goto case_2;
  }
#line 215
  if ((unsigned int )exp___0->type == 5U) {
#line 215
    goto case_5;
  }
#line 215
  if ((unsigned int )exp___0->type == 9U) {
#line 215
    goto case_5;
  }
#line 219
  if ((unsigned int )exp___0->type == 4U) {
#line 219
    goto case_4;
  }
#line 219
  if ((unsigned int )exp___0->type == 3U) {
#line 219
    goto case_4;
  }
#line 225
  if ((unsigned int )exp___0->type == 8U) {
#line 225
    goto case_8;
  }
#line 231
  if ((unsigned int )exp___0->type == 10U) {
#line 231
    goto case_10;
  }
#line 173
  goto switch_break;
  case_0: /* CIL Label */ 
#line 180
  most = exp___0->params.cset_size;
#line 181
  x___0 = 0;
  {
#line 181
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 181
    if (! (x___0 < most)) {
#line 181
      goto while_break___0;
    }
#line 182
    if (*(exp___0->params.cset + (unsigned long )x___0 / (8UL * sizeof(RX_subset ))) & rx_subset_singletons[(unsigned long )x___0 & (8UL * sizeof(RX_subset ) - 1UL)]) {
#line 183
      *(map + x___0) = (unsigned char)1;
    }
#line 181
    x___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 185
  return (0);
  case_6: /* CIL Label */ 
#line 188
  if (exp___0->params.cstr.len) {
#line 190
    *(map + *(exp___0->params.cstr.contents + 0)) = (unsigned char)1;
#line 191
    return (0);
  } else {
#line 194
    return (1);
  }
  case_7: /* CIL Label */ 
#line 197
  return (1);
  case_1: /* CIL Label */ 
  {
#line 201
  tmp = rx_fill_in_fastmap(cset_size, map, exp___0->params.pair.left);
  }
#line 201
  return (tmp);
  case_2: /* CIL Label */ 
  {
#line 211
  tmp___0 = rx_fill_in_fastmap(cset_size, map, exp___0->params.pair.left);
#line 211
  tmp___1 = rx_fill_in_fastmap(cset_size, map, exp___0->params.pair.right);
  }
#line 211
  return (tmp___0 | tmp___1);
  case_5: /* CIL Label */ 
  case_9: /* CIL Label */ 
  {
#line 216
  tmp___2 = rx_fill_in_fastmap(cset_size, map, exp___0->params.pair.left);
  }
#line 216
  return (tmp___2);
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 220
  goto can_match_empty;
  case_8: /* CIL Label */ 
#line 226
  if (exp___0->params.intval == 0) {
#line 227
    goto can_match_empty;
  } else {
    {
#line 229
    tmp___3 = rx_fill_in_fastmap(cset_size, map, exp___0->params.pair.left);
    }
#line 229
    return (tmp___3);
  }
  case_10: /* CIL Label */ 
#line 232
  goto can_match_empty;
  switch_break: /* CIL Label */ ;
  }
#line 236
  return (0);
}
}
#line 242 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxanal.c"
int rx_is_anchored_p(struct rexp_node *exp___0 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 250
  if (! exp___0) {
#line 251
    return (0);
  }
  {
#line 259
  if ((unsigned int )exp___0->type == 7U) {
#line 259
    goto case_7;
  }
#line 259
  if ((unsigned int )exp___0->type == 6U) {
#line 259
    goto case_7;
  }
#line 259
  if ((unsigned int )exp___0->type == 0U) {
#line 259
    goto case_7;
  }
#line 259
  if ((unsigned int )exp___0->type == 4U) {
#line 259
    goto case_7;
  }
#line 259
  if ((unsigned int )exp___0->type == 3U) {
#line 259
    goto case_7;
  }
#line 264
  if ((unsigned int )exp___0->type == 1U) {
#line 264
    goto case_1;
  }
#line 264
  if ((unsigned int )exp___0->type == 5U) {
#line 264
    goto case_1;
  }
#line 264
  if ((unsigned int )exp___0->type == 9U) {
#line 264
    goto case_1;
  }
#line 267
  if ((unsigned int )exp___0->type == 2U) {
#line 267
    goto case_2;
  }
#line 272
  if ((unsigned int )exp___0->type == 8U) {
#line 272
    goto case_8;
  }
#line 278
  if ((unsigned int )exp___0->type == 10U) {
#line 278
    goto case_10;
  }
#line 253
  goto switch_break;
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_0: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 260
  return (0);
  case_1: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_9: /* CIL Label */ 
  {
#line 265
  tmp = rx_is_anchored_p(exp___0->params.pair.left);
  }
#line 265
  return (tmp);
  case_2: /* CIL Label */ 
  {
#line 268
  tmp___0 = rx_is_anchored_p(exp___0->params.pair.left);
  }
#line 268
  if (tmp___0) {
    {
#line 268
    tmp___1 = rx_is_anchored_p(exp___0->params.pair.right);
    }
#line 268
    if (tmp___1) {
#line 268
      tmp___2 = 1;
    } else {
#line 268
      tmp___2 = 0;
    }
  } else {
#line 268
    tmp___2 = 0;
  }
#line 268
  return (tmp___2);
  case_8: /* CIL Label */ 
#line 273
  if (exp___0->params.intval == 0) {
#line 274
    return (0);
  } else {
    {
#line 276
    tmp___3 = rx_is_anchored_p(exp___0->params.pair.left);
    }
#line 276
    return (tmp___3);
  }
  case_10: /* CIL Label */ 
#line 279
  return (exp___0->params.intval == 94);
  switch_break: /* CIL Label */ ;
  }
#line 283
  return (0);
}
}
#line 289 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxanal.c"
enum rx_answers rx_start_superstate(struct rx_classical_system *frame ) 
{ 
  struct rx_superset *start_contents ;
  struct rx_nfa_state_set *start_nfa_set ;
  struct rx_possible_future *futures ;
  struct rx_superset *tmp ;
  struct rx_superstate *state ;

  {
#line 300
  if ((frame->rx)->start_set) {
#line 301
    start_contents = (frame->rx)->start_set;
  } else {
    {
#line 306
    futures = rx_state_possible_futures(frame->rx, (frame->rx)->start_nfa_states);
    }
#line 308
    if (! futures) {
#line 309
      return ((enum rx_answers )-1);
    }
#line 311
    if (futures->next) {
#line 312
      return ((enum rx_answers )-2);
    }
    {
#line 314
    start_nfa_set = futures->destset;
#line 317
    tmp = rx_superset_cons(frame->rx, (struct rx_nfa_state *)0, (struct rx_superset *)0);
#line 317
    start_contents = rx_superstate_eclosure_union(frame->rx, tmp, start_nfa_set);
    }
#line 322
    if (! start_contents) {
#line 323
      return ((enum rx_answers )-1);
    }
#line 325
    start_contents->starts_for = frame->rx;
#line 326
    (frame->rx)->start_set = start_contents;
  }
#line 329
  if (start_contents->superstate) {
#line 329
    if ((start_contents->superstate)->rx_id == (frame->rx)->rx_id) {
#line 332
      if (frame->state) {
#line 334
        ((frame->state)->locks) --;
      }
      {
#line 336
      frame->state = start_contents->superstate;
#line 342
      rx_refresh_this_superstate((frame->rx)->cache, frame->state);
#line 343
      ((frame->state)->locks) ++;
      }
#line 344
      return ((enum rx_answers )0);
    } else {
#line 329
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 350
    (start_contents->refs) ++;
#line 351
    state = rx_superstate(frame->rx, start_contents);
#line 352
    rx_release_superset(frame->rx, start_contents);
    }
#line 353
    if (! state) {
#line 354
      return ((enum rx_answers )-1);
    }
#line 355
    if (frame->state) {
#line 357
      ((frame->state)->locks) --;
    }
#line 359
    frame->state = state;
#line 360
    ((frame->state)->locks) ++;
#line 361
    return ((enum rx_answers )0);
  }
}
}
#line 369 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxanal.c"
enum rx_answers rx_fit_p(struct rx_classical_system *frame , unsigned char const   *burst ,
                         int len ) 
{ 
  struct rx_inx *inx_table ;
  struct rx_inx *inx ;
  int tmp ;
  struct rx_inx *next_table ;
  struct rx_superstate *state ;
  int tmp___0 ;

  {
#line 382
  if (! frame->state) {
#line 383
    return ((enum rx_answers )-1);
  }
#line 385
  if (! len) {
#line 387
    frame->final_tag = ((frame->state)->contents)->is_final;
#line 388
    if (((frame->state)->contents)->is_final) {
#line 388
      tmp = 0;
    } else {
#line 388
      tmp = 1;
    }
#line 388
    return ((enum rx_answers )tmp);
  }
#line 393
  inx_table = (frame->state)->transitions;
#line 394
  ((frame->state)->locks) --;
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 396
    tmp___0 = len;
#line 396
    len --;
#line 396
    if (! tmp___0) {
#line 396
      goto while_break;
    }
#line 400
    inx = inx_table + (int const   )*burst;
#line 401
    next_table = (struct rx_inx *)inx->data;
    {
#line 402
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 402
      if (! (! next_table)) {
#line 402
        goto while_break___0;
      }
#line 405
      state = (struct rx_superstate *)((char *)inx_table - (unsigned long )(((struct rx_superstate *)0)->transitions));
      {
#line 412
      if ((int )inx->inx == 4) {
#line 412
        goto case_4;
      }
#line 420
      if ((int )inx->inx == 2) {
#line 420
        goto case_2;
      }
#line 443
      goto switch_default;
      case_4: /* CIL Label */ 
#line 417
      frame->state = (struct rx_superstate *)0;
#line 418
      return ((enum rx_answers )1);
      case_2: /* CIL Label */ 
      {
#line 426
      inx = rx_handle_cache_miss(frame->rx, state, (unsigned char )*burst, inx->data_2);
      }
#line 430
      if (! inx) {
#line 432
        frame->state = (struct rx_superstate *)0;
#line 433
        return ((enum rx_answers )-1);
      }
#line 435
      next_table = (struct rx_inx *)inx->data;
#line 436
      goto while_continue___0;
      switch_default: /* CIL Label */ 
#line 444
      frame->state = (struct rx_superstate *)0;
#line 445
      return ((enum rx_answers )-1);
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 448
    inx_table = next_table;
#line 449
    burst ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 452
  if (inx->data_2) {
#line 454
    frame->final_tag = (int )inx->data_2;
#line 455
    frame->state = (struct rx_superstate *)((char *)inx_table - (unsigned long )(((struct rx_superstate *)0)->transitions));
#line 459
    ((frame->state)->locks) ++;
#line 460
    return ((enum rx_answers )0);
  }
#line 462
  frame->state = (struct rx_superstate *)((char *)inx_table - (unsigned long )(((struct rx_superstate *)0)->transitions));
#line 466
  ((frame->state)->locks) ++;
#line 467
  return ((enum rx_answers )1);
}
}
#line 474 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxanal.c"
enum rx_answers rx_advance(struct rx_classical_system *frame , unsigned char const   *burst ,
                           int len ) 
{ 
  struct rx_inx *inx_table ;
  struct rx_inx *inx ;
  struct rx_inx *next_table ;
  struct rx_superstate *state ;
  int tmp ;

  {
#line 486
  if (! frame->state) {
#line 487
    return ((enum rx_answers )-1);
  }
#line 489
  if (! len) {
#line 490
    return ((enum rx_answers )0);
  }
#line 492
  inx_table = (frame->state)->transitions;
#line 493
  ((frame->state)->locks) --;
  {
#line 495
  while (1) {
    while_continue: /* CIL Label */ ;
#line 495
    tmp = len;
#line 495
    len --;
#line 495
    if (! tmp) {
#line 495
      goto while_break;
    }
#line 500
    inx = inx_table + (int const   )*burst;
#line 501
    next_table = (struct rx_inx *)inx->data;
    {
#line 502
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 502
      if (! (! next_table)) {
#line 502
        goto while_break___0;
      }
#line 505
      state = (struct rx_superstate *)((char *)inx_table - (unsigned long )(((struct rx_superstate *)0)->transitions));
      {
#line 512
      if ((int )inx->inx == 4) {
#line 512
        goto case_4;
      }
#line 520
      if ((int )inx->inx == 2) {
#line 520
        goto case_2;
      }
#line 543
      goto switch_default;
      case_4: /* CIL Label */ 
#line 517
      frame->state = (struct rx_superstate *)0;
#line 518
      return ((enum rx_answers )1);
      case_2: /* CIL Label */ 
      {
#line 526
      inx = rx_handle_cache_miss(frame->rx, state, (unsigned char )*burst, inx->data_2);
      }
#line 530
      if (! inx) {
#line 532
        frame->state = (struct rx_superstate *)0;
#line 533
        return ((enum rx_answers )-1);
      }
#line 535
      next_table = (struct rx_inx *)inx->data;
#line 536
      goto while_continue___0;
      switch_default: /* CIL Label */ 
#line 544
      frame->state = (struct rx_superstate *)0;
#line 545
      return ((enum rx_answers )-1);
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 548
    inx_table = next_table;
#line 549
    burst ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 552
  frame->state = (struct rx_superstate *)((char *)inx_table - (unsigned long )(((struct rx_superstate *)0)->transitions));
#line 556
  ((frame->state)->locks) ++;
#line 557
  return ((enum rx_answers )0);
}
}
#line 563 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxanal.c"
int rx_advance_to_final(struct rx_classical_system *frame , unsigned char const   *burst ,
                        int len ) 
{ 
  int initial_len ;
  struct rx_inx *inx_table ;
  struct rx_superstate *this_state ;
  struct rx_inx *inx ;
  struct rx_inx *next_table ;
  struct rx_superstate *state ;
  int tmp ;

  {
#line 577
  if (! frame->state) {
#line 578
    return (0);
  }
#line 580
  if (! len) {
#line 581
    return (0);
  }
#line 583
  inx_table = (frame->state)->transitions;
#line 585
  initial_len = len;
#line 587
  this_state = frame->state;
  {
#line 589
  while (1) {
    while_continue: /* CIL Label */ ;
#line 589
    tmp = len;
#line 589
    len --;
#line 589
    if (! tmp) {
#line 589
      goto while_break;
    }
#line 597
    inx = inx_table + (int const   )*burst;
#line 598
    next_table = (struct rx_inx *)inx->data;
    {
#line 600
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 600
      if (! (! next_table)) {
#line 600
        goto while_break___0;
      }
#line 604
      state = (struct rx_superstate *)((char *)inx_table - (unsigned long )(((struct rx_superstate *)0)->transitions));
      {
#line 611
      if ((int )inx->inx == 4) {
#line 611
        goto case_4;
      }
#line 622
      if ((int )inx->inx == 2) {
#line 622
        goto case_2;
      }
#line 645
      goto switch_default;
      case_4: /* CIL Label */ 
#line 619
      frame->state = this_state;
#line 620
      return ((initial_len - len) - 1);
      case_2: /* CIL Label */ 
      {
#line 628
      inx = rx_handle_cache_miss(frame->rx, state, (unsigned char )*burst, inx->data_2);
      }
#line 631
      if (! inx) {
#line 633
        (this_state->locks) --;
#line 634
        frame->state = (struct rx_superstate *)0;
#line 635
        return (-1);
      }
#line 637
      next_table = (struct rx_inx *)inx->data;
#line 638
      goto while_continue___0;
      switch_default: /* CIL Label */ 
#line 646
      (this_state->locks) --;
#line 647
      frame->state = (struct rx_superstate *)0;
#line 648
      return (-1);
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 653
    (this_state->locks) --;
#line 656
    inx_table = next_table;
#line 657
    this_state = (struct rx_superstate *)((char *)inx_table - (unsigned long )(((struct rx_superstate *)0)->transitions));
#line 663
    (this_state->locks) ++;
#line 666
    if ((this_state->contents)->is_final) {
#line 668
      frame->state = this_state;
#line 669
      return (initial_len - len);
    }
#line 672
    burst ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 676
  frame->state = this_state;
#line 678
  return (initial_len);
}
}
#line 685 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxanal.c"
void rx_terminate_system(struct rx_classical_system *frame ) 
{ 


  {
#line 693
  if (frame->state) {
#line 695
    ((frame->state)->locks) --;
#line 696
    frame->state = (struct rx_superstate *)0;
  }
#line 698
  return;
}
}
#line 709 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rxanal.c"
void rx_init_system(struct rx_classical_system *frame , struct rx *rx ) 
{ 


  {
#line 718
  frame->rx = rx;
#line 719
  frame->state = (struct rx_superstate *)0;
#line 720
  return;
}
}
#line 30 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rx.h"
char const   rx_version_string[19] ;
#line 29 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rx.c"
char const   rx_version_string[19]  = 
#line 29 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rx.c"
  {      (char const   )'G',      (char const   )'N',      (char const   )'U',      (char const   )' ', 
        (char const   )'R',      (char const   )'x',      (char const   )' ',      (char const   )'v', 
        (char const   )'e',      (char const   )'r',      (char const   )'s',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'1', 
        (char const   )'.',      (char const   )'1',      (char const   )'\000'};
#line 41 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rx.c"
static int rx_id  =    0;
#line 33 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rx.c"
struct rx *rx_make_rx(int cset_size ) 
{ 
  struct rx *new_rx ;
  void *tmp ;
  int tmp___0 ;
  void *__cil_tmp5 ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;

  {
  {
#line 43
  tmp = malloc(sizeof(*new_rx));
#line 43
  new_rx = (struct rx *)tmp;
#line 44
  rx_bzero((char *)new_rx, (int )sizeof(*new_rx));
#line 45
  tmp___0 = rx_id;
#line 45
  rx_id ++;
#line 45
  new_rx->rx_id = tmp___0;
#line 46
  new_rx->cache = rx_default_cache;
#line 47
  new_rx->local_cset_size = cset_size;
#line 48
  new_rx->instruction_table = rx_id_instruction_table;
#line 49
  new_rx->next_nfa_id = 0;
  }
#line 50
  return (new_rx);
}
}
#line 54 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rx.c"
void rx_free_rx(struct rx *rx ) 
{ 


  {
#line 62
  if (rx->start_set) {
#line 63
    (rx->start_set)->starts_for = (struct rx *)0;
  }
  {
#line 64
  rx_free_nfa(rx);
#line 65
  free((void *)rx);
  }
#line 66
  return;
}
}
#line 70 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rx.c"
void rx_bzero(char *mem , int size ) 
{ 


  {
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! size) {
#line 79
      goto while_break;
    }
#line 81
    *mem = (char)0;
#line 82
    mem ++;
#line 83
    size --;
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  return;
}
}
#line 254 "./../libguile/__scm.h"
unsigned int scm_async_clock ;
#line 49 "./../libguile/error.h"
int scm_ints_disabled ;
#line 65
 __attribute__((__noreturn__)) void scm_error(SCM key , char *subr , char *message ,
                                              SCM args , SCM rest ) ;
#line 78
 __attribute__((__noreturn__)) void scm_memory_error(char *subr ) ;
#line 81
SCM scm_wta(SCM arg , char *pos , char *s_subr ) ;
#line 89 "./../libguile/print.h"
void scm_intprint(long n , int radix , SCM port ) ;
#line 165 "./../libguile/pairs.h"
SCM scm_cons(SCM x , SCM y ) ;
#line 51 "./../libguile/list.h"
SCM scm_listify(SCM elt  , ...) ;
#line 63 "./../libguile/gc.h"
SCM scm_freelist ;
#line 67
unsigned long scm_cells_allocated ;
#line 68
unsigned long scm_mallocated ;
#line 84
SCM scm_gc_for_newcell(void) ;
#line 90
char *scm_must_malloc(long len , char *what ) ;
#line 93
void scm_must_free(char *obj ) ;
#line 95
SCM scm_return_first(SCM elt  , ...) ;
#line 96
SCM scm_permanent_object(SCM obj ) ;
#line 51 "./../libguile/gsubr.h"
SCM scm_make_gsubr(char *name , int req , int opt , int rst , SCM (*fcn)() ) ;
#line 314 "./../libguile/numbers.h"
SCM scm_long2num(long sl ) ;
#line 113 "./../libguile/symbols.h"
SCM scm_intern0(char *name ) ;
#line 114
SCM scm_sysintern(char *name , SCM val ) ;
#line 68 "./../libguile/strings.h"
SCM scm_makfrom0str(char const   *src ) ;
#line 76
SCM scm_make_shared_substring(SCM str , SCM frm , SCM to ) ;
#line 63 "./../libguile/vectors.h"
SCM scm_make_vector(SCM k , SCM fill , SCM multip ) ;
#line 56 "./../libguile/async.h"
void scm_async_click(void) ;
#line 52 "./../libguile/genio.h"
void scm_gen_puts(enum scm_string_representation_type rep , char *str_data , SCM port ) ;
#line 55 "./../libguile/markers.h"
SCM scm_mark0(SCM ptr ) ;
#line 75 "./../libguile/smob.h"
long scm_newsmob(scm_smobfuns *smob ) ;
#line 57 "./../libguile/mallocs.h"
SCM scm_malloc_obj(size_t n ) ;
#line 49 "./../libguile/feature.h"
void scm_add_feature(char *str ) ;
#line 50 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rgx.h"
size_t free_regex_t(SCM obj ) ;
#line 51
int print_regex_t(SCM obj , SCM port , scm_print_state *pstate ) ;
#line 52
SCM scm_compiled_regexp_p(SCM obj ) ;
#line 53
SCM scm_regcomp(SCM pat , SCM cfl ) ;
#line 54
SCM scm_regexec(SCM rgx , SCM str , SCM match_pick , SCM eflags ) ;
#line 55
size_t free_dfa_t(SCM obj ) ;
#line 56
int print_dfa_t(SCM obj , SCM port , scm_print_state *pstate ) ;
#line 57
SCM scm_regexp_to_dfa(SCM regexp , SCM cfl ) ;
#line 58
SCM scm_dfa_fork(SCM dfa ) ;
#line 59
SCM scm_reset_dfa_x(SCM dfa ) ;
#line 60
SCM scm_dfa_final_tag(SCM dfa ) ;
#line 61
SCM scm_dfa_continuable_p(SCM dfa ) ;
#line 62
SCM scm_advance_dfa_x(SCM dfa , SCM s___0 ) ;
#line 63
void scm_init_rgx(void) ;
#line 64 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rgx.c"
long scm_tc16_regex_t  ;
#line 68 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rgx.c"
size_t free_regex_t(SCM obj ) 
{ 
  regex_t *r ;

  {
  {
#line 73
  r = (regex_t *)((scm_cell *)obj)->cdr;
#line 74
  free((void *)((char *)r->owner_data));
#line 75
  regfree(r);
  }
#line 76
  return ((size_t )0);
}
}
#line 79 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rgx.c"
int print_regex_t(SCM obj , SCM port , scm_print_state *pstate ) 
{ 
  regex_t *r ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 86
  r = (regex_t *)((scm_cell *)obj)->cdr;
#line 87
  scm_gen_puts((enum scm_string_representation_type )0, (char *)"#<rgx ", port);
#line 88
  scm_gen_puts((enum scm_string_representation_type )0, (char *)r->owner_data, port);
#line 89
  scm_gen_puts((enum scm_string_representation_type )0, (char *)">", port);
  }
#line 90
  return (1);
}
}
#line 94 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rgx.c"
static scm_smobfuns regex_t_smob  =    {& scm_mark0, & free_regex_t, & print_regex_t, (SCM (*)(SCM  , SCM  ))0};
#line 97 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rgx.c"
static SCM scm_regex_error_key  =    (long )(16 << 9) + 372L;
#line 99 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rgx.c"
static void scm_regex_error(char *subr , int code ) 
{ 
  SCM tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  char *__cil_tmp6 ;

  {
  {
#line 104
  tmp = scm_listify((long )(code << 2) + 2L, (long )(18 << 9) + 372L);
#line 104
  tmp___0 = scm_makfrom0str(rx_error_msg[code]);
#line 104
  tmp___1 = scm_listify(tmp___0, (long )(18 << 9) + 372L);
#line 104
  scm_error(scm_regex_error_key, subr, (char *)"%s", tmp___1, tmp);
  }
}
}
#line 112 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rgx.c"
static char s_compiled_regexp_p[17]  = 
#line 112
  {      (char )'c',      (char )'o',      (char )'m',      (char )'p', 
        (char )'i',      (char )'l',      (char )'e',      (char )'d', 
        (char )'-',      (char )'r',      (char )'e',      (char )'g', 
        (char )'e',      (char )'x',      (char )'p',      (char )'?', 
        (char )'\000'};
#line 113 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rgx.c"
SCM scm_compiled_regexp_p(SCM obj ) 
{ 
  long tmp ;

  {
#line 117
  if (! (6 & (int )obj)) {
#line 117
    if (((scm_cell *)obj)->car == scm_tc16_regex_t) {
#line 117
      tmp = (long )(17 << 9) + 372L;
    } else {
#line 117
      tmp = (long )(16 << 9) + 372L;
    }
  } else {
#line 117
    tmp = (long )(16 << 9) + 372L;
  }
#line 117
  return (tmp);
}
}
#line 122 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rgx.c"
static char s_regcomp[8]  = 
#line 122
  {      (char )'r',      (char )'e',      (char )'g',      (char )'c', 
        (char )'o',      (char )'m',      (char )'p',      (char )'\000'};
#line 123 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rgx.c"
SCM scm_regcomp(SCM pat , SCM cfl ) 
{ 
  SCM answer ;
  regex_t *it ;
  int status ;
  void *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  void *__cil_tmp10 ;

  {
#line 129
  if (! (6 & (int )pat)) {
#line 129
    if (! ((117 & (int )((scm_cell *)pat)->car) == 21)) {
#line 129
      if (! ((125 & (int )((scm_cell *)pat)->car) == 5)) {
        {
#line 129
        scm_wta(pat, (char *)1, s_regcomp);
        }
      }
    }
  } else {
    {
#line 129
    scm_wta(pat, (char *)1, s_regcomp);
    }
  }
#line 130
  if (cfl == (long )(18 << 9) + 372L) {
#line 131
    cfl = (SCM )2;
  }
#line 132
  if (! (2 & (int )cfl)) {
    {
#line 132
    scm_wta(cfl, (char *)2, s_regcomp);
    }
  }
#line 134
  if (6 & (int )scm_freelist) {
    {
#line 134
    answer = scm_gc_for_newcell();
    }
  } else {
#line 134
    answer = scm_freelist;
#line 134
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 134
    scm_cells_allocated ++;
  }
  {
#line 135
  scm_ints_disabled = 1;
#line 139
  tmp = malloc(sizeof(*it));
#line 139
  it = (regex_t *)tmp;
  }
#line 140
  if (! it) {
    allocation: 
    {
#line 143
    scm_memory_error(s_regcomp);
    }
  }
#line 145
  if ((127 & (int )((scm_cell *)pat)->car) == 29) {
#line 145
    tmp___0 = (char *)((scm_cell *)((scm_cell *)((scm_cell *)pat)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)pat)->cdr)->car >> 2);
  } else {
#line 145
    tmp___0 = (char *)((scm_cell *)pat)->cdr;
  }
  {
#line 145
  status = regncomp(it, (int )((unsigned long )((scm_cell *)pat)->car >> 8), (char const   *)tmp___0,
                    (int )(cfl >> 2));
  }
#line 146
  if (status) {
    {
#line 148
    free((void *)it);
#line 149
    scm_regex_error(s_regcomp, status);
    }
  } else {
    {
#line 153
    tmp___1 = malloc(((unsigned long )((scm_cell *)pat)->car >> 8) + 1UL);
#line 153
    it->owner_data = tmp___1;
    }
#line 154
    if (! it->owner_data) {
      {
#line 156
      regfree(it);
#line 157
      free((void *)it);
      }
#line 158
      goto allocation;
    }
#line 160
    if ((127 & (int )((scm_cell *)pat)->car) == 29) {
#line 160
      tmp___2 = (char *)((scm_cell *)((scm_cell *)((scm_cell *)pat)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)pat)->cdr)->car >> 2);
    } else {
#line 160
      tmp___2 = (char *)((scm_cell *)pat)->cdr;
    }
    {
#line 160
    memcpy((void */* __restrict  */)it->owner_data, (void const   */* __restrict  */)tmp___2,
           (unsigned long )((scm_cell *)pat)->car >> 8);
#line 161
    *((char *)it->owner_data + ((unsigned long )((scm_cell *)pat)->car >> 8)) = (char)0;
#line 162
    ((scm_cell *)answer)->car = scm_tc16_regex_t;
#line 163
    ((scm_cell *)answer)->cdr = (SCM )it;
    }
  }
#line 166
  scm_ints_disabled = 0;
#line 166
  scm_async_clock --;
#line 166
  if (0U == scm_async_clock) {
    {
#line 166
    scm_async_click();
    }
  }
#line 167
  return (answer);
}
}
#line 225 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rgx.c"
static char s_regexec[8]  = 
#line 225
  {      (char )'r',      (char )'e',      (char )'g',      (char )'e', 
        (char )'x',      (char )'e',      (char )'c',      (char )'\000'};
#line 226 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rgx.c"
SCM scm_regexec(SCM rgx , SCM str , SCM match_pick , SCM eflags ) 
{ 
  SCM answer ;
  SCM malloc_protect ;
  regmatch_t *pmatch ;
  int status ;
  char *tmp ;
  int i ;
  int i___0 ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  SCM tmp___2 ;
  SCM tmp___3 ;
  SCM tmp___4 ;
  int i___1 ;
  size_t bound ;
  int vlen ;
  SCM spec ;
  size_t bound___0 ;
  SCM ans_pos ;
  SCM item ;
  SCM frm ;
  SCM to ;
  SCM tmp___5 ;
  SCM tmp___6 ;
  SCM tmp___7 ;
  SCM tmp___8 ;
  SCM tmp___9 ;
  SCM ipos ;
  int solved ;
  SCM iitem ;
  int ival ;
  SCM tmp___10 ;
  SCM tmp___11 ;
  int n ;
  SCM tmp___12 ;
  SCM tmp___13 ;
  SCM tmp___14 ;

  {
#line 237
  if (! (6 & (int )rgx)) {
#line 237
    if (! (((scm_cell *)rgx)->car == scm_tc16_regex_t)) {
      {
#line 237
      scm_wta(rgx, (char *)1, s_regexec);
      }
    }
  } else {
    {
#line 237
    scm_wta(rgx, (char *)1, s_regexec);
    }
  }
#line 238
  if (! (6 & (int )str)) {
#line 238
    if (! ((117 & (int )((scm_cell *)str)->car) == 21)) {
#line 238
      if (! ((125 & (int )((scm_cell *)str)->car) == 5)) {
        {
#line 238
        scm_wta(str, (char *)2, s_regexec);
        }
      }
    }
  } else {
    {
#line 238
    scm_wta(str, (char *)2, s_regexec);
    }
  }
#line 239
  if (eflags == (long )(18 << 9) + 372L) {
#line 240
    eflags = (SCM )2;
  }
#line 241
  if (! (2 & (int )eflags)) {
    {
#line 241
    scm_wta(eflags, (char *)4, s_regexec);
    }
  }
  {
#line 243
  malloc_protect = scm_malloc_obj((size_t )0);
#line 244
  scm_ints_disabled = 1;
#line 247
  pmatch = (regmatch_t *)0;
  }
#line 248
  if ((127 & (int )((scm_cell *)str)->car) == 29) {
#line 248
    tmp = (char *)((scm_cell *)((scm_cell *)((scm_cell *)str)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)str)->cdr)->car >> 2);
  } else {
#line 248
    tmp = (char *)((scm_cell *)str)->cdr;
  }
  {
#line 248
  status = regnexec((regex_t const   *)((regex_t *)((scm_cell *)rgx)->cdr), (int )((unsigned long )((scm_cell *)str)->car >> 8),
                    (char const   *)tmp, (size_t )0, & pmatch, (int )((eflags >> 2) | (long )((1 << 1) << 1)));
  }
#line 250
  if (status) {
#line 252
    scm_ints_disabled = 0;
#line 252
    scm_async_clock --;
#line 252
    if (0U == scm_async_clock) {
      {
#line 252
      scm_async_click();
      }
    }
#line 253
    if (status == 1) {
#line 254
      return ((long )(16 << 9) + 372L);
    } else {
      {
#line 256
      scm_regex_error(s_regexec, status);
      }
    }
  }
#line 258
  if (match_pick == (long )(16 << 9) + 372L) {
    {
#line 259
    free((void *)pmatch);
    }
  } else {
#line 261
    ((scm_cell *)malloc_protect)->cdr = (SCM )pmatch;
  }
#line 263
  scm_ints_disabled = 0;
#line 263
  scm_async_clock --;
#line 263
  if (0U == scm_async_clock) {
    {
#line 263
    scm_async_click();
    }
  }
#line 265
  if (match_pick == (long )(16 << 9) + 372L) {
#line 266
    return ((long )(17 << 9) + 372L);
  } else
#line 267
  if (match_pick == (long )(17 << 9) + 372L) {
#line 267
    goto _L___3;
  } else
#line 267
  if (match_pick == (long )(18 << 9) + 372L) {
    _L___3: /* CIL Label */ 
    {
#line 271
    answer = scm_make_vector((SCM )((((regex_t *)((scm_cell *)rgx)->cdr)->n_subexps << 2) + 2UL),
                             (long )(16 << 9) + 372L, (long )(16 << 9) + 372L);
#line 273
    i = 0;
    }
    {
#line 273
    while (1) {
      while_continue: /* CIL Label */ ;
#line 273
      if (! ((size_t )i < ((regex_t *)((scm_cell *)rgx)->cdr)->n_subexps)) {
#line 273
        goto while_break;
      }
#line 275
      if ((pmatch + i)->rm_so >= 0) {
        {
#line 277
        *((SCM *)((scm_cell *)answer)->cdr + i) = scm_cons((long )((pmatch + i)->rm_so << 2) + 2L,
                                                           (long )((pmatch + i)->rm_eo << 2) + 2L);
        }
      }
#line 273
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 281
    return (answer);
  } else
#line 283
  if (! (6 & (int )match_pick)) {
#line 283
    if ((117 & (int )((scm_cell *)match_pick)->car) == 21) {
#line 283
      goto _L___2;
    } else
#line 283
    if ((125 & (int )((scm_cell *)match_pick)->car) == 5) {
      _L___2: /* CIL Label */ 
      {
#line 287
      answer = scm_listify((long )(18 << 9) + 372L);
#line 289
      i___0 = (int )(((regex_t *)((scm_cell *)rgx)->cdr)->n_subexps - 1UL);
      }
      {
#line 289
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 289
        if (! (i___0 >= 1)) {
#line 289
          goto while_break___0;
        }
#line 291
        if ((pmatch + i___0)->rm_so >= 0) {
          {
#line 293
          tmp___0 = scm_make_shared_substring(str, (long )((pmatch + i___0)->rm_so << 2) + 2L,
                                              (long )((pmatch + i___0)->rm_eo << 2) + 2L);
#line 293
          answer = scm_cons(tmp___0, answer);
          }
        } else {
          {
#line 299
          answer = scm_cons((long )(16 << 9) + 372L, answer);
          }
        }
#line 289
        i___0 --;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 301
      tmp___1 = scm_make_shared_substring(str, (long )((pmatch + 0)->rm_eo << 2) + 2L,
                                          (SCM )((((unsigned long )((scm_cell *)str)->car >> 8) << 2) + 2UL));
#line 301
      tmp___2 = scm_make_shared_substring(str, (long )((pmatch + 0)->rm_so << 2) + 2L,
                                          (long )((pmatch + 0)->rm_eo << 2) + 2L);
#line 301
      tmp___3 = scm_make_shared_substring(str, 2L, (long )((pmatch + 0)->rm_so << 2) + 2L);
#line 301
      tmp___4 = scm_listify(tmp___3, tmp___2, tmp___1, (long )(18 << 9) + 372L);
#line 301
      answer = scm_cons(tmp___4, answer);
      }
#line 313
      return (answer);
    } else {
#line 283
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 315
  if (! (6 & (int )match_pick)) {
#line 315
    if ((125 & (int )((scm_cell *)match_pick)->car) == 13) {
#line 321
      bound = ((regex_t *)((scm_cell *)rgx)->cdr)->n_subexps;
#line 322
      vlen = (int )((unsigned long )((scm_cell *)match_pick)->car >> 8);
#line 323
      if ((size_t )vlen < bound) {
#line 324
        bound = (size_t )vlen;
      }
#line 325
      i___1 = 0;
      {
#line 325
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 325
        if (! ((size_t )i___1 < bound)) {
#line 325
          goto while_break___1;
        }
#line 326
        if ((pmatch + i___1)->rm_so >= 0) {
          {
#line 327
          *((SCM *)((scm_cell *)match_pick)->cdr + i___1) = scm_cons((long )((pmatch + i___1)->rm_so << 2) + 2L,
                                                                     (long )((pmatch + i___1)->rm_eo << 2) + 2L);
          }
        } else {
#line 330
          *((SCM *)((scm_cell *)match_pick)->cdr + i___1) = (long )(16 << 9) + 372L;
        }
#line 325
        i___1 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 331
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 331
        if (! (i___1 < vlen)) {
#line 331
          goto while_break___2;
        }
#line 333
        *((SCM *)((scm_cell *)match_pick)->cdr + i___1) = (long )(16 << 9) + 372L;
#line 334
        i___1 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 336
      return (match_pick);
    } else {
#line 315
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 344
    answer = scm_cons((long )(16 << 9) + 372L, (long )(16 << 9) + 372L);
#line 345
    ans_pos = answer;
#line 346
    bound___0 = ((regex_t *)((scm_cell *)rgx)->cdr)->n_subexps;
#line 348
    spec = match_pick;
    }
    {
#line 348
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 348
      if (! (spec != (long )(20 << 9) + 372L)) {
#line 348
        goto while_break___3;
      }
#line 354
      if (! (6 & (int )spec)) {
#line 354
        if (! (! (1 & (int )((scm_cell *)spec)->car))) {
          {
#line 354
          scm_wta(spec, (char *)3, s_regexec);
          }
        }
      } else {
        {
#line 354
        scm_wta(spec, (char *)3, s_regexec);
        }
      }
#line 355
      item = ((scm_cell *)spec)->car;
#line 357
      if (((int )item & 255) == 244) {
#line 359
        if ((unsigned int )(item >> 8) == 60U) {
          {
#line 361
          frm = (SCM )2;
#line 362
          to = (long )((pmatch + 0)->rm_so << 2) + 2L;
#line 363
          tmp___5 = scm_make_shared_substring(str, frm, to);
#line 363
          tmp___6 = scm_cons(tmp___5, (long )(20 << 9) + 372L);
#line 363
          ((scm_cell *)ans_pos)->cdr = tmp___6;
          }
        } else
#line 366
        if ((unsigned int )(item >> 8) == 62U) {
          {
#line 368
          frm = (long )((pmatch + 0)->rm_eo << 2) + 2L;
#line 369
          to = (long )(18 << 9) + 372L;
#line 370
          tmp___7 = scm_make_shared_substring(str, frm, to);
#line 370
          tmp___8 = scm_cons(tmp___7, (long )(20 << 9) + 372L);
#line 370
          ((scm_cell *)ans_pos)->cdr = tmp___8;
          }
        } else
#line 373
        if ((unsigned int )(item >> 8) == 99U) {
          {
#line 375
          tmp___9 = scm_cons((long )((pmatch + 0)->final_tag << 2) + 2L, (long )(20 << 9) + 372L);
#line 375
          ((scm_cell *)ans_pos)->cdr = tmp___9;
          }
        } else {
          {
#line 379
          scm_wta(spec, (char *)3, s_regexec);
          }
        }
#line 380
        ans_pos = ((scm_cell *)ans_pos)->cdr;
      } else
#line 382
      if (! (6 & (int )item)) {
#line 382
        if (! (1 & (int )((scm_cell *)item)->car)) {
#line 387
          solved = 0;
#line 388
          ipos = item;
          {
#line 388
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 388
            if (! (6 & (int )ipos)) {
#line 388
              if (! (! (1 & (int )((scm_cell *)ipos)->car))) {
#line 388
                goto while_break___4;
              }
            } else {
#line 388
              goto while_break___4;
            }
#line 392
            iitem = ((scm_cell *)ipos)->car;
#line 393
            if (! (2 & (int )iitem)) {
              {
#line 393
              scm_wta(spec, (char *)3, s_regexec);
              }
            }
#line 394
            ival = (int )(iitem >> 2);
#line 395
            if (ival >= 0) {
#line 395
              if (! ((size_t )ival < bound___0)) {
                {
#line 395
                scm_wta(spec, (char *)10, s_regexec);
                }
              }
            } else {
              {
#line 395
              scm_wta(spec, (char *)10, s_regexec);
              }
            }
#line 396
            if ((pmatch + ival)->rm_so >= 0) {
              {
#line 398
              tmp___10 = scm_cons((long )(ival << 2) + 2L, (long )(20 << 9) + 372L);
#line 398
              ((scm_cell *)ans_pos)->cdr = tmp___10;
#line 399
              ans_pos = ((scm_cell *)ans_pos)->cdr;
#line 400
              solved = 1;
              }
#line 401
              goto while_break___4;
            }
#line 388
            ipos = ((scm_cell *)ipos)->cdr;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 404
          if (! solved) {
            {
#line 406
            tmp___11 = scm_cons((long )(16 << 9) + 372L, (long )(20 << 9) + 372L);
#line 406
            ((scm_cell *)ans_pos)->cdr = tmp___11;
#line 407
            ans_pos = ((scm_cell *)ans_pos)->cdr;
            }
          }
        } else {
#line 382
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 413
        if (! (2 & (int )item)) {
          {
#line 413
          scm_wta(spec, (char *)3, s_regexec);
          }
        }
#line 414
        n = (int )(item >> 2);
#line 415
        if (n >= 0) {
#line 415
          if (! ((size_t )n < bound___0)) {
            {
#line 415
            scm_wta(spec, (char *)10, s_regexec);
            }
          }
        } else {
          {
#line 415
          scm_wta(spec, (char *)10, s_regexec);
          }
        }
#line 416
        if ((pmatch + n)->rm_so < 0) {
          {
#line 418
          tmp___12 = scm_cons((long )(16 << 9) + 372L, (long )(20 << 9) + 372L);
#line 418
          ((scm_cell *)ans_pos)->cdr = tmp___12;
#line 419
          ans_pos = ((scm_cell *)ans_pos)->cdr;
          }
#line 420
          goto __Cont;
        }
        {
#line 422
        frm = (long )((pmatch + n)->rm_so << 2) + 2L;
#line 423
        to = (long )((pmatch + n)->rm_eo << 2) + 2L;
#line 424
        tmp___13 = scm_make_shared_substring(str, frm, to);
#line 424
        tmp___14 = scm_cons(tmp___13, (long )(20 << 9) + 372L);
#line 424
        ((scm_cell *)ans_pos)->cdr = tmp___14;
#line 426
        ans_pos = ((scm_cell *)ans_pos)->cdr;
        }
      }
      __Cont: /* CIL Label */ 
#line 348
      spec = ((scm_cell *)spec)->cdr;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 429
    return (((scm_cell *)answer)->cdr);
  }
}
}
#line 441 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rgx.c"
long scm_tc16_dfa_t  ;
#line 445 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rgx.c"
size_t free_dfa_t(SCM obj ) 
{ 
  struct rx_dfa_state *r ;

  {
  {
#line 450
  r = (struct rx_dfa_state *)((scm_cell *)obj)->cdr;
#line 451
  rx_terminate_system(& r->frame);
#line 452
  rx_free_unfa(r->unfa);
#line 453
  scm_must_free((char *)r);
  }
#line 454
  return (sizeof(struct rx_dfa_state ));
}
}
#line 457 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rgx.c"
int print_dfa_t(SCM obj , SCM port , scm_print_state *pstate ) 
{ 
  struct rx_dfa_state *r ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 464
  r = (struct rx_dfa_state *)((scm_cell *)obj)->cdr;
#line 465
  scm_gen_puts((enum scm_string_representation_type )0, (char *)"#<dfa ", port);
#line 466
  scm_intprint((long )(r->frame.rx)->rx_id, 10, port);
#line 467
  scm_gen_puts((enum scm_string_representation_type )0, (char *)">", port);
  }
#line 468
  return (1);
}
}
#line 471 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rgx.c"
static scm_smobfuns dfa_t_smob  =    {& scm_mark0, & free_dfa_t, & print_dfa_t, (SCM (*)(SCM  , SCM  ))0};
#line 475 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rgx.c"
static char s_regexp_to_dfa[12]  = 
#line 475
  {      (char )'r',      (char )'e',      (char )'g',      (char )'e', 
        (char )'x',      (char )'p',      (char )'-',      (char )'>', 
        (char )'d',      (char )'f',      (char )'a',      (char )'\000'};
#line 476 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rgx.c"
SCM scm_regexp_to_dfa(SCM regexp , SCM cfl ) 
{ 
  reg_errcode_t ret ;
  unsigned int syntax ;
  struct rx_dfa_state *r ;
  struct rexp_node *parsed ;
  int cflags ;
  char *pattern ;
  int len ;
  SCM answer ;
  char *tmp ;
  struct rx_unfaniverse *tmp___0 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 490
  if (! (6 & (int )regexp)) {
#line 490
    if (! ((117 & (int )((scm_cell *)regexp)->car) == 21)) {
#line 490
      if (! ((125 & (int )((scm_cell *)regexp)->car) == 5)) {
        {
#line 490
        scm_wta(regexp, (char *)1, s_regexp_to_dfa);
        }
      }
    }
  } else {
    {
#line 490
    scm_wta(regexp, (char *)1, s_regexp_to_dfa);
    }
  }
#line 492
  if (cfl == (long )(18 << 9) + 372L) {
#line 493
    cfl = (SCM )2;
  }
#line 494
  if (! (2 & (int )cfl)) {
    {
#line 494
    scm_wta(cfl, (char *)2, s_regexp_to_dfa);
    }
  }
#line 496
  if ((127 & (int )((scm_cell *)regexp)->car) == 29) {
#line 496
    pattern = (char *)((scm_cell *)((scm_cell *)((scm_cell *)regexp)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)regexp)->cdr)->car >> 2);
  } else {
#line 496
    pattern = (char *)((scm_cell *)regexp)->cdr;
  }
#line 497
  len = (int )((unsigned long )((scm_cell *)regexp)->car >> 8);
#line 498
  cflags = (int )(cfl >> 2);
#line 501
  if (6 & (int )scm_freelist) {
    {
#line 501
    answer = scm_gc_for_newcell();
    }
  } else {
#line 501
    answer = scm_freelist;
#line 501
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 501
    scm_cells_allocated ++;
  }
#line 503
  scm_ints_disabled = 1;
#line 504
  if (cflags & 1) {
#line 504
    syntax = (unsigned int )((((((((((((1 << 1) << 1) | ((((((1 << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((1 << 1) << 1) << 1)) | ((((1 << 1) << 1) << 1) << 1)) | ((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
  } else {
#line 504
    syntax = (unsigned int )(((((((1 << 1) << 1) | ((((((1 << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (1 << 1));
  }
#line 508
  if (cflags & ((1 << 1) << 1)) {
#line 510
    syntax &= (unsigned int )(~ ((((((1 << 1) << 1) << 1) << 1) << 1) << 1));
#line 511
    syntax |= (unsigned int )((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);
  }
  {
#line 515
  ret = rx_parse(& parsed, (char const   *)pattern, len, (unsigned long )syntax, 256,
                 (unsigned char *)0);
  }
#line 517
  if (ret) {
    {
#line 518
    scm_regex_error(s_regexp_to_dfa, (int )ret);
    }
  }
  {
#line 520
  tmp = scm_must_malloc((long )sizeof(struct rx_dfa_state ), (char *)"dfa");
#line 520
  r = (struct rx_dfa_state *)tmp;
#line 521
  tmp___0 = rx_basic_unfaniverse();
#line 521
  r->unfa = rx_unfa(tmp___0, parsed, 256);
#line 522
  rx_free_rexp(parsed);
  }
#line 523
  if (! r->unfa) {
    {
#line 525
    scm_mallocated -= sizeof(*r);
#line 526
    scm_must_free((char *)r);
#line 527
    scm_ints_disabled = 0;
#line 527
    scm_async_clock --;
    }
#line 527
    if (0U == scm_async_clock) {
      {
#line 527
      scm_async_click();
      }
    }
    {
#line 528
    scm_wta(regexp, (char *)"internal error constructing rx_unfa", s_regexp_to_dfa);
    }
  }
  {
#line 531
  rx_init_system(& r->frame, (r->unfa)->nfa);
#line 532
  ((scm_cell *)answer)->car = scm_tc16_dfa_t;
#line 533
  ((scm_cell *)answer)->cdr = (SCM )r;
#line 534
  scm_ints_disabled = 0;
#line 534
  scm_async_clock --;
  }
#line 534
  if (0U == scm_async_clock) {
    {
#line 534
    scm_async_click();
    }
  }
#line 535
  return (answer);
}
}
#line 539 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rgx.c"
static char s_dfa_fork[9]  = 
#line 539
  {      (char )'d',      (char )'f',      (char )'a',      (char )'-', 
        (char )'f',      (char )'o',      (char )'r',      (char )'k', 
        (char )'\000'};
#line 540 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rgx.c"
SCM scm_dfa_fork(SCM dfa ) 
{ 
  struct rx_dfa_state *r ;
  SCM answer ;
  char *tmp ;
  char *__cil_tmp5 ;

  {
#line 547
  if (! (6 & (int )dfa)) {
#line 547
    if (! (((scm_cell *)dfa)->car == scm_tc16_dfa_t)) {
      {
#line 547
      scm_wta(dfa, (char *)1, s_dfa_fork);
      }
    }
  } else {
    {
#line 547
    scm_wta(dfa, (char *)1, s_dfa_fork);
    }
  }
#line 550
  if (6 & (int )scm_freelist) {
    {
#line 550
    answer = scm_gc_for_newcell();
    }
  } else {
#line 550
    answer = scm_freelist;
#line 550
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 550
    scm_cells_allocated ++;
  }
  {
#line 552
  scm_ints_disabled = 1;
#line 553
  tmp = scm_must_malloc((long )sizeof(struct rx_dfa_state ), (char *)"dfa");
#line 553
  r = (struct rx_dfa_state *)tmp;
#line 554
  rx_save_unfa(((struct rx_dfa_state *)((scm_cell *)dfa)->cdr)->unfa);
#line 555
  r->unfa = ((struct rx_dfa_state *)((scm_cell *)dfa)->cdr)->unfa;
#line 556
  rx_init_system(& r->frame, (r->unfa)->nfa);
#line 557
  r->frame.state = ((struct rx_dfa_state *)((scm_cell *)dfa)->cdr)->frame.state;
  }
#line 558
  if (r->frame.state) {
#line 559
    ((r->frame.state)->locks) ++;
  }
#line 560
  ((scm_cell *)answer)->car = scm_tc16_dfa_t;
#line 561
  ((scm_cell *)answer)->cdr = (SCM )r;
#line 562
  scm_ints_disabled = 0;
#line 562
  scm_async_clock --;
#line 562
  if (0U == scm_async_clock) {
    {
#line 562
    scm_async_click();
    }
  }
#line 563
  return (answer);
}
}
#line 567 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rgx.c"
static char s_reset_dfa_x[11]  = 
#line 567
  {      (char )'r',      (char )'e',      (char )'s',      (char )'e', 
        (char )'t',      (char )'-',      (char )'d',      (char )'f', 
        (char )'a',      (char )'!',      (char )'\000'};
#line 568 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rgx.c"
SCM scm_reset_dfa_x(SCM dfa ) 
{ 
  enum rx_answers tmp ;
  char *__cil_tmp3 ;

  {
#line 572
  if (! (6 & (int )dfa)) {
#line 572
    if (! (((scm_cell *)dfa)->car == scm_tc16_dfa_t)) {
      {
#line 572
      scm_wta(dfa, (char *)1, s_reset_dfa_x);
      }
    }
  } else {
    {
#line 572
    scm_wta(dfa, (char *)1, s_reset_dfa_x);
    }
  }
  {
#line 575
  scm_ints_disabled = 1;
#line 576
  tmp = rx_start_superstate(& ((struct rx_dfa_state *)((scm_cell *)dfa)->cdr)->frame);
  }
#line 576
  if (0 != (int )tmp) {
#line 578
    scm_ints_disabled = 0;
#line 578
    scm_async_clock --;
#line 578
    if (0U == scm_async_clock) {
      {
#line 578
      scm_async_click();
      }
    }
    {
#line 579
    scm_wta(dfa, (char *)"internal error constructing rx starting superstate", s_reset_dfa_x);
    }
  }
#line 581
  scm_ints_disabled = 0;
#line 581
  scm_async_clock --;
#line 581
  if (0U == scm_async_clock) {
    {
#line 581
    scm_async_click();
    }
  }
#line 582
  return (dfa);
}
}
#line 587 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rgx.c"
static char s_dfa_final_tag[14]  = 
#line 587
  {      (char )'d',      (char )'f',      (char )'a',      (char )'-', 
        (char )'f',      (char )'i',      (char )'n',      (char )'a', 
        (char )'l',      (char )'-',      (char )'t',      (char )'a', 
        (char )'g',      (char )'\000'};
#line 588 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rgx.c"
SCM scm_dfa_final_tag(SCM dfa ) 
{ 
  SCM tmp ;

  {
#line 592
  if (! (6 & (int )dfa)) {
#line 592
    if (! (((scm_cell *)dfa)->car == scm_tc16_dfa_t)) {
      {
#line 592
      scm_wta(dfa, (char *)1, s_dfa_final_tag);
      }
    }
  } else {
    {
#line 592
    scm_wta(dfa, (char *)1, s_dfa_final_tag);
    }
  }
#line 595
  if (((struct rx_dfa_state *)((scm_cell *)dfa)->cdr)->frame.state) {
    {
#line 596
    tmp = scm_long2num((long )((((struct rx_dfa_state *)((scm_cell *)dfa)->cdr)->frame.state)->contents)->is_final);
    }
#line 596
    return (tmp);
  } else {
#line 598
    return ((SCM )2);
  }
}
}
#line 603 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rgx.c"
static char s_dfa_continuable_p[17]  = 
#line 603
  {      (char )'d',      (char )'f',      (char )'a',      (char )'-', 
        (char )'c',      (char )'o',      (char )'n',      (char )'t', 
        (char )'i',      (char )'n',      (char )'u',      (char )'a', 
        (char )'b',      (char )'l',      (char )'e',      (char )'?', 
        (char )'\000'};
#line 604 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rgx.c"
SCM scm_dfa_continuable_p(SCM dfa ) 
{ 
  long tmp ;

  {
#line 608
  if (! (6 & (int )dfa)) {
#line 608
    if (! (((scm_cell *)dfa)->car == scm_tc16_dfa_t)) {
      {
#line 608
      scm_wta(dfa, (char *)1, s_dfa_continuable_p);
      }
    }
  } else {
    {
#line 608
    scm_wta(dfa, (char *)1, s_dfa_continuable_p);
    }
  }
#line 611
  if (((struct rx_dfa_state *)((scm_cell *)dfa)->cdr)->frame.state) {
#line 611
    if (((((struct rx_dfa_state *)((scm_cell *)dfa)->cdr)->frame.state)->contents)->has_cset_edges) {
#line 611
      tmp = (long )(17 << 9) + 372L;
    } else {
#line 611
      tmp = (long )(16 << 9) + 372L;
    }
  } else {
#line 611
    tmp = (long )(16 << 9) + 372L;
  }
#line 611
  return (tmp);
}
}
#line 617 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rgx.c"
static char s_advance_dfa_x[13]  = 
#line 617
  {      (char )'a',      (char )'d',      (char )'v',      (char )'a', 
        (char )'n',      (char )'c',      (char )'e',      (char )'-', 
        (char )'d',      (char )'f',      (char )'a',      (char )'!', 
        (char )'\000'};
#line 618 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rgx.c"
SCM scm_advance_dfa_x(SCM dfa , SCM s___0 ) 
{ 
  struct rx_dfa_state *d ;
  char *str ;
  int len ;
  int matched ;
  char *__cil_tmp7 ;

  {
#line 628
  if (! (6 & (int )dfa)) {
#line 628
    if (! (((scm_cell *)dfa)->car == scm_tc16_dfa_t)) {
      {
#line 628
      scm_wta(dfa, (char *)1, s_advance_dfa_x);
      }
    }
  } else {
    {
#line 628
    scm_wta(dfa, (char *)1, s_advance_dfa_x);
    }
  }
#line 630
  if (! (6 & (int )s___0)) {
#line 630
    if (! ((117 & (int )((scm_cell *)s___0)->car) == 21)) {
#line 630
      if (! ((125 & (int )((scm_cell *)s___0)->car) == 5)) {
        {
#line 630
        scm_wta(s___0, (char *)2, s_advance_dfa_x);
        }
      }
    }
  } else {
    {
#line 630
    scm_wta(s___0, (char *)2, s_advance_dfa_x);
    }
  }
#line 633
  if ((127 & (int )((scm_cell *)s___0)->car) == 29) {
#line 633
    str = (char *)((scm_cell *)((scm_cell *)((scm_cell *)s___0)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)s___0)->cdr)->car >> 2);
  } else {
#line 633
    str = (char *)((scm_cell *)s___0)->cdr;
  }
  {
#line 634
  len = (int )((unsigned long )((scm_cell *)s___0)->car >> 8);
#line 635
  d = (struct rx_dfa_state *)((scm_cell *)dfa)->cdr;
#line 637
  scm_ints_disabled = 1;
#line 638
  matched = rx_advance_to_final(& d->frame, (unsigned char *)str, len);
#line 639
  scm_ints_disabled = 0;
#line 639
  scm_async_clock --;
  }
#line 639
  if (0U == scm_async_clock) {
    {
#line 639
    scm_async_click();
    }
  }
#line 641
  if (matched >= 0) {
    {
#line 642
    scm_return_first((long )(matched << 2) + 2L, dfa, s___0);
    }
  } else {
    {
#line 644
    scm_wta(dfa, (char *)"internal error in rx_advance_to_final", s_advance_dfa_x);
    }
  }
#line 645
  return (0L);
}
}
#line 652 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rgx.c"
void scm_init_rgx(void) 
{ 
  SCM tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
  {
#line 655
  scm_add_feature((char *)"regex");
#line 656
  scm_tc16_regex_t = scm_newsmob(& regex_t_smob);
#line 657
  scm_tc16_dfa_t = scm_newsmob(& dfa_t_smob);
#line 660
  scm_sysintern((char *)"REG_EXTENDED", (long )(1 << 2) + 2L);
#line 661
  scm_sysintern((char *)"REG_ICASE", (long )((1 << 1) << 2) + 2L);
#line 662
  scm_sysintern((char *)"REG_NEWLINE", (long )(((1 << 1) << 1) << 2) + 2L);
#line 663
  scm_sysintern((char *)"REG_NOTBOL", (long )(1 << 2) + 2L);
#line 664
  scm_sysintern((char *)"REG_NOTEOL", (long )((1 << 1) << 2) + 2L);
#line 667
  scm_sysintern((char *)"RE_BACKSLASH_ESCAPE_IN_LISTS", (long )(1 << 2) + 2L);
#line 668
  scm_sysintern((char *)"RE_BK_PLUS_QM", (long )((1 << 1) << 2) + 2L);
#line 669
  scm_sysintern((char *)"RE_CHAR_CLASSES", (long )(((1 << 1) << 1) << 2) + 2L);
#line 670
  scm_sysintern((char *)"RE_CONTEXT_INDEP_ANCHORS", (long )((((1 << 1) << 1) << 1) << 2) + 2L);
#line 671
  scm_sysintern((char *)"RE_CONTEXT_INDEP_OPS", (long )(((((1 << 1) << 1) << 1) << 1) << 2) + 2L);
#line 672
  scm_sysintern((char *)"RE_CONTEXT_INVALID_OPS", (long )((((((1 << 1) << 1) << 1) << 1) << 1) << 2) + 2L);
#line 673
  scm_sysintern((char *)"RE_DOT_NEWLINE", (long )(((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 2) + 2L);
#line 674
  scm_sysintern((char *)"RE_DOT_NOT_NULL", (long )((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 2) + 2L);
#line 675
  scm_sysintern((char *)"RE_HAT_LISTS_NOT_NEWLINE", (long )(((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 2) + 2L);
#line 676
  scm_sysintern((char *)"RE_INTERVALS", (long )((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 2) + 2L);
#line 677
  scm_sysintern((char *)"RE_LIMITED_OPS", (long )(((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 2) + 2L);
#line 678
  scm_sysintern((char *)"RE_NEWLINE_ALT", (long )((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 2) + 2L);
#line 679
  scm_sysintern((char *)"RE_NO_BK_BRACES", (long )(((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 2) + 2L);
#line 680
  scm_sysintern((char *)"RE_NO_BK_PARENS", (long )((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 2) + 2L);
#line 681
  scm_sysintern((char *)"RE_NO_BK_REFS", (long )(((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 2) + 2L);
#line 682
  scm_sysintern((char *)"RE_NO_BK_VBAR", (long )((((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 2) + 2L);
#line 683
  scm_sysintern((char *)"RE_NO_EMPTY_RANGES", (long )(((((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 2) + 2L);
#line 684
  scm_sysintern((char *)"RE_UNMATCHED_RIGHT_PAREN_ORD", (long )((((((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 2) + 2L);
#line 685
  scm_sysintern((char *)"RE_SYNTAX_EMACS", 2L);
#line 686
  scm_sysintern((char *)"RE_SYNTAX_AWK", (long )(((((((1 | (((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) << 2) + 2L);
#line 687
  scm_sysintern((char *)"RE_SYNTAX_POSIX_AWK", (long )((((((((((((((1 << 1) << 1) | ((((((1 << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((1 << 1) << 1) << 1)) | ((((1 << 1) << 1) << 1) << 1)) | ((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | 1) << 2) + 2L);
#line 688
  scm_sysintern((char *)"RE_SYNTAX_GREP", (long )((((((1 << 1) | ((1 << 1) << 1)) | ((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) << 2) + 2L);
#line 689
  scm_sysintern((char *)"RE_SYNTAX_EGREP", (long )(((((((((1 << 1) << 1) | (((1 << 1) << 1) << 1)) | ((((1 << 1) << 1) << 1) << 1)) | ((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) << 2) + 2L);
#line 690
  scm_sysintern((char *)"RE_SYNTAX_POSIX_EGREP", (long )(((((((((((1 << 1) << 1) | (((1 << 1) << 1) << 1)) | ((((1 << 1) << 1) << 1) << 1)) | ((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) << 2) + 2L);
#line 691
  scm_sysintern((char *)"RE_SYNTAX_SED", (long )((((((((1 << 1) << 1) | ((((((1 << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (1 << 1)) << 2) + 2L);
#line 692
  scm_sysintern((char *)"RE_SYNTAX_POSIX_BASIC", (long )((((((((1 << 1) << 1) | ((((((1 << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (1 << 1)) << 2) + 2L);
#line 693
  scm_sysintern((char *)"RE_SYNTAX_POSIX_MINIMAL_BASIC", (long )((((((((1 << 1) << 1) | ((((((1 << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) << 2) + 2L);
#line 694
  scm_sysintern((char *)"RE_SYNTAX_POSIX_EXTENDED", (long )(((((((((((((1 << 1) << 1) | ((((((1 << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((1 << 1) << 1) << 1)) | ((((1 << 1) << 1) << 1) << 1)) | ((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) << 2) + 2L);
#line 695
  scm_sysintern((char *)"RE_SYNTAX_POSIX_MINIMAL_EXTENDED", (long )((((((((((((((1 << 1) << 1) | ((((((1 << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((1 << 1) << 1) << 1)) | (((((1 << 1) << 1) << 1) << 1) << 1)) | ((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) << 2) + 2L);
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rgx.x"
  tmp = scm_intern0((char *)"regex-error");
#line 1
  scm_regex_error_key = scm_permanent_object(((scm_cell *)tmp)->car);
#line 2
  scm_make_gsubr(s_compiled_regexp_p, 1, 0, 0, (SCM (*)())(& scm_compiled_regexp_p));
#line 3
  scm_make_gsubr(s_regcomp, 1, 1, 0, (SCM (*)())(& scm_regcomp));
#line 4
  scm_make_gsubr(s_regexec, 2, 2, 0, (SCM (*)())(& scm_regexec));
#line 5
  scm_make_gsubr(s_regexp_to_dfa, 1, 1, 0, (SCM (*)())(& scm_regexp_to_dfa));
#line 6
  scm_make_gsubr(s_dfa_fork, 1, 0, 0, (SCM (*)())(& scm_dfa_fork));
#line 7
  scm_make_gsubr(s_reset_dfa_x, 1, 0, 0, (SCM (*)())(& scm_reset_dfa_x));
#line 8
  scm_make_gsubr(s_dfa_final_tag, 1, 0, 0, (SCM (*)())(& scm_dfa_final_tag));
#line 9
  scm_make_gsubr(s_dfa_continuable_p, 1, 0, 0, (SCM (*)())(& scm_dfa_continuable_p));
#line 10
  scm_make_gsubr(s_advance_dfa_x, 2, 0, 0, (SCM (*)())(& scm_advance_dfa_x));
  }
#line 698 "/home/wslee/gnu_benchmarks/guile-1.0/rx/rgx.c"
  return;
}
}
#line 55 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.h"
long scm_ilength(SCM sx ) ;
#line 291 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.h"
SCM scm_sum(SCM x , SCM y ) ;
#line 60 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/weaks.h"
SCM scm_make_weak_vector(SCM k , SCM fill ) ;
#line 61
SCM scm_weak_vector(SCM l ) ;
#line 62
SCM scm_weak_vector_p(SCM x ) ;
#line 63
SCM scm_make_weak_key_hash_table(SCM k ) ;
#line 64
SCM scm_make_weak_value_hash_table(SCM k ) ;
#line 65
SCM scm_make_doubly_weak_hash_table(SCM k ) ;
#line 66
SCM scm_weak_key_hash_table_p(SCM x ) ;
#line 67
SCM scm_weak_value_hash_table_p(SCM x ) ;
#line 68
SCM scm_doubly_weak_hash_table_p(SCM x ) ;
#line 69
void scm_init_weaks(void) ;
#line 53 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/weaks.c"
static char s_make_weak_vector[17]  = 
#line 53 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/weaks.c"
  {      (char )'m',      (char )'a',      (char )'k',      (char )'e', 
        (char )'-',      (char )'w',      (char )'e',      (char )'a', 
        (char )'k',      (char )'-',      (char )'v',      (char )'e', 
        (char )'c',      (char )'t',      (char )'o',      (char )'r', 
        (char )'\000'};
#line 55 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/weaks.c"
SCM scm_make_weak_vector(SCM k , SCM fill ) 
{ 
  SCM v ;
  SCM tmp ;

  {
  {
#line 61
  tmp = scm_sum(k, (long )(1 << 2) + 2L);
#line 61
  v = scm_make_vector(tmp, fill, (long )(18 << 9) + 372L);
#line 62
  scm_ints_disabled = 1;
#line 63
  ((scm_cell *)v)->car = ((k >> 2) << 8) + 15L;
#line 64
  *((SCM *)((scm_cell *)v)->cdr + 0) = (SCM )0;
#line 65
  ((scm_cell *)v)->cdr = (SCM )((SCM *)((scm_cell *)v)->cdr + 1);
#line 66
  scm_ints_disabled = 0;
#line 66
  scm_async_clock --;
  }
#line 66
  if (0U == scm_async_clock) {
    {
#line 66
    scm_async_click();
    }
  }
#line 67
  return (v);
}
}
#line 71 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/weaks.c"
static char s_weak_vector[12]  = 
#line 71
  {      (char )'w',      (char )'e',      (char )'a',      (char )'k', 
        (char )'-',      (char )'v',      (char )'e',      (char )'c', 
        (char )'t',      (char )'o',      (char )'r',      (char )'\000'};
#line 72 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/weaks.c"
static char s_list_to_weak_vector[18]  = 
#line 72
  {      (char )'l',      (char )'i',      (char )'s',      (char )'t', 
        (char )'-',      (char )'>',      (char )'w',      (char )'e', 
        (char )'a',      (char )'k',      (char )'-',      (char )'v', 
        (char )'e',      (char )'c',      (char )'t',      (char )'o', 
        (char )'r',      (char )'\000'};
#line 74 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/weaks.c"
SCM scm_weak_vector(SCM l ) 
{ 
  SCM res ;
  register SCM *data ;
  long i ;
  SCM *tmp ;

  {
  {
#line 82
  i = scm_ilength(l);
  }
#line 83
  if (! (i >= 0L)) {
    {
#line 83
    scm_wta(l, (char *)1, s_weak_vector);
    }
  }
  {
#line 84
  res = scm_make_weak_vector((i << 2) + 2L, (long )(21 << 9) + 372L);
#line 85
  data = (SCM *)((scm_cell *)res)->cdr;
  }
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (i) {
#line 86
      if (! (6 & (int )l)) {
#line 86
        if (! (! (1 & (int )((scm_cell *)l)->car))) {
#line 86
          goto while_break;
        }
      } else {
#line 86
        goto while_break;
      }
    } else {
#line 86
      goto while_break;
    }
#line 89
    tmp = data;
#line 89
    data ++;
#line 89
    *tmp = ((scm_cell *)l)->car;
#line 86
    i --;
#line 86
    l = ((scm_cell *)l)->cdr;
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  return (res);
}
}
#line 94 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/weaks.c"
static char s_weak_vector_p[13]  = 
#line 94
  {      (char )'w',      (char )'e',      (char )'a',      (char )'k', 
        (char )'-',      (char )'v',      (char )'e',      (char )'c', 
        (char )'t',      (char )'o',      (char )'r',      (char )'?', 
        (char )'\000'};
#line 96 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/weaks.c"
SCM scm_weak_vector_p(SCM x ) 
{ 
  long tmp ;

  {
#line 100
  if (! (6 & (int )x)) {
#line 100
    if ((127 & (int )((scm_cell *)x)->car) == 15) {
#line 100
      if (! (*((SCM *)((scm_cell *)x)->cdr + -1) == 1L)) {
#line 100
        tmp = (long )(17 << 9) + 372L;
      } else {
#line 100
        tmp = (long )(16 << 9) + 372L;
      }
    } else {
#line 100
      tmp = (long )(16 << 9) + 372L;
    }
  } else {
#line 100
    tmp = (long )(16 << 9) + 372L;
  }
#line 100
  return (tmp);
}
}
#line 111 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/weaks.c"
static char s_make_weak_key_hash_table[25]  = 
#line 111
  {      (char )'m',      (char )'a',      (char )'k',      (char )'e', 
        (char )'-',      (char )'w',      (char )'e',      (char )'a', 
        (char )'k',      (char )'-',      (char )'k',      (char )'e', 
        (char )'y',      (char )'-',      (char )'h',      (char )'a', 
        (char )'s',      (char )'h',      (char )'-',      (char )'t', 
        (char )'a',      (char )'b',      (char )'l',      (char )'e', 
        (char )'\000'};
#line 113 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/weaks.c"
SCM scm_make_weak_key_hash_table(SCM k ) 
{ 
  SCM v ;

  {
#line 118
  if (! (2 & (int )k)) {
    {
#line 118
    scm_wta(k, (char *)1, s_make_weak_key_hash_table);
    }
  }
  {
#line 119
  v = scm_make_weak_vector(k, (long )(20 << 9) + 372L);
#line 120
  scm_ints_disabled = 0;
#line 120
  scm_async_clock --;
  }
#line 120
  if (0U == scm_async_clock) {
    {
#line 120
    scm_async_click();
    }
  }
#line 121
  *((SCM *)((scm_cell *)v)->cdr + -1) = (SCM )1;
#line 122
  scm_ints_disabled = 0;
#line 122
  scm_async_clock --;
#line 122
  if (0U == scm_async_clock) {
    {
#line 122
    scm_async_click();
    }
  }
#line 123
  return (v);
}
}
#line 127 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/weaks.c"
static char s_make_weak_value_hash_table[27]  = 
#line 127
  {      (char )'m',      (char )'a',      (char )'k',      (char )'e', 
        (char )'-',      (char )'w',      (char )'e',      (char )'a', 
        (char )'k',      (char )'-',      (char )'v',      (char )'a', 
        (char )'l',      (char )'u',      (char )'e',      (char )'-', 
        (char )'h',      (char )'a',      (char )'s',      (char )'h', 
        (char )'-',      (char )'t',      (char )'a',      (char )'b', 
        (char )'l',      (char )'e',      (char )'\000'};
#line 129 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/weaks.c"
SCM scm_make_weak_value_hash_table(SCM k ) 
{ 
  SCM v ;

  {
#line 134
  if (! (2 & (int )k)) {
    {
#line 134
    scm_wta(k, (char *)1, s_make_weak_value_hash_table);
    }
  }
  {
#line 135
  v = scm_make_weak_vector(k, (long )(20 << 9) + 372L);
#line 136
  scm_ints_disabled = 0;
#line 136
  scm_async_clock --;
  }
#line 136
  if (0U == scm_async_clock) {
    {
#line 136
    scm_async_click();
    }
  }
#line 137
  *((SCM *)((scm_cell *)v)->cdr + -1) = (SCM )2;
#line 138
  scm_ints_disabled = 0;
#line 138
  scm_async_clock --;
#line 138
  if (0U == scm_async_clock) {
    {
#line 138
    scm_async_click();
    }
  }
#line 139
  return (v);
}
}
#line 144 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/weaks.c"
static char s_make_doubly_weak_hash_table[28]  = 
#line 144
  {      (char )'m',      (char )'a',      (char )'k',      (char )'e', 
        (char )'-',      (char )'d',      (char )'o',      (char )'u', 
        (char )'b',      (char )'l',      (char )'y',      (char )'-', 
        (char )'w',      (char )'e',      (char )'a',      (char )'k', 
        (char )'-',      (char )'h',      (char )'a',      (char )'s', 
        (char )'h',      (char )'-',      (char )'t',      (char )'a', 
        (char )'b',      (char )'l',      (char )'e',      (char )'\000'};
#line 146 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/weaks.c"
SCM scm_make_doubly_weak_hash_table(SCM k ) 
{ 
  SCM v ;

  {
#line 151
  if (! (2 & (int )k)) {
    {
#line 151
    scm_wta(k, (char *)1, s_make_doubly_weak_hash_table);
    }
  }
  {
#line 152
  v = scm_make_weak_vector(k, (long )(20 << 9) + 372L);
#line 153
  scm_ints_disabled = 0;
#line 153
  scm_async_clock --;
  }
#line 153
  if (0U == scm_async_clock) {
    {
#line 153
    scm_async_click();
    }
  }
#line 154
  *((SCM *)((scm_cell *)v)->cdr + -1) = (SCM )3;
#line 155
  scm_ints_disabled = 0;
#line 155
  scm_async_clock --;
#line 155
  if (0U == scm_async_clock) {
    {
#line 155
    scm_async_click();
    }
  }
#line 156
  return (v);
}
}
#line 159 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/weaks.c"
static char s_weak_key_hash_table_p[21]  = 
#line 159
  {      (char )'w',      (char )'e',      (char )'a',      (char )'k', 
        (char )'-',      (char )'k',      (char )'e',      (char )'y', 
        (char )'-',      (char )'h',      (char )'a',      (char )'s', 
        (char )'h',      (char )'-',      (char )'t',      (char )'a', 
        (char )'b',      (char )'l',      (char )'e',      (char )'?', 
        (char )'\000'};
#line 161 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/weaks.c"
SCM scm_weak_key_hash_table_p(SCM x ) 
{ 
  long tmp ;

  {
#line 165
  if (! (6 & (int )x)) {
#line 165
    if ((127 & (int )((scm_cell *)x)->car) == 15) {
#line 165
      if (*((SCM *)((scm_cell *)x)->cdr + -1) == 1L) {
#line 165
        tmp = (long )(17 << 9) + 372L;
      } else {
#line 165
        tmp = (long )(16 << 9) + 372L;
      }
    } else {
#line 165
      tmp = (long )(16 << 9) + 372L;
    }
  } else {
#line 165
    tmp = (long )(16 << 9) + 372L;
  }
#line 165
  return (tmp);
}
}
#line 171 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/weaks.c"
static char s_weak_value_hash_table_p[23]  = 
#line 171
  {      (char )'w',      (char )'e',      (char )'a',      (char )'k', 
        (char )'-',      (char )'v',      (char )'a',      (char )'l', 
        (char )'u',      (char )'e',      (char )'-',      (char )'h', 
        (char )'a',      (char )'s',      (char )'h',      (char )'-', 
        (char )'t',      (char )'a',      (char )'b',      (char )'l', 
        (char )'e',      (char )'?',      (char )'\000'};
#line 173 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/weaks.c"
SCM scm_weak_value_hash_table_p(SCM x ) 
{ 
  long tmp ;

  {
#line 177
  if (! (6 & (int )x)) {
#line 177
    if ((127 & (int )((scm_cell *)x)->car) == 15) {
#line 177
      if (*((SCM *)((scm_cell *)x)->cdr + -1) == 2L) {
#line 177
        tmp = (long )(17 << 9) + 372L;
      } else {
#line 177
        tmp = (long )(16 << 9) + 372L;
      }
    } else {
#line 177
      tmp = (long )(16 << 9) + 372L;
    }
  } else {
#line 177
    tmp = (long )(16 << 9) + 372L;
  }
#line 177
  return (tmp);
}
}
#line 183 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/weaks.c"
static char s_doubly_weak_hash_table_p[24]  = 
#line 183
  {      (char )'d',      (char )'o',      (char )'u',      (char )'b', 
        (char )'l',      (char )'y',      (char )'-',      (char )'w', 
        (char )'e',      (char )'a',      (char )'k',      (char )'-', 
        (char )'h',      (char )'a',      (char )'s',      (char )'h', 
        (char )'-',      (char )'t',      (char )'a',      (char )'b', 
        (char )'l',      (char )'e',      (char )'?',      (char )'\000'};
#line 185 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/weaks.c"
SCM scm_doubly_weak_hash_table_p(SCM x ) 
{ 
  long tmp ;

  {
#line 189
  if (! (6 & (int )x)) {
#line 189
    if ((127 & (int )((scm_cell *)x)->car) == 15) {
#line 189
      if (*((SCM *)((scm_cell *)x)->cdr + -1) == 3L) {
#line 189
        tmp = (long )(17 << 9) + 372L;
      } else {
#line 189
        tmp = (long )(16 << 9) + 372L;
      }
    } else {
#line 189
      tmp = (long )(16 << 9) + 372L;
    }
  } else {
#line 189
    tmp = (long )(16 << 9) + 372L;
  }
#line 189
  return (tmp);
}
}
#line 198 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/weaks.c"
void scm_init_weaks(void) 
{ 


  {
  {
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/weaks.x"
  scm_make_gsubr(s_make_weak_vector, 1, 1, 0, (SCM (*)())(& scm_make_weak_vector));
#line 2
  scm_make_gsubr(s_weak_vector, 0, 0, 1, (SCM (*)())(& scm_weak_vector));
#line 3
  scm_make_gsubr(s_list_to_weak_vector, 1, 0, 0, (SCM (*)())(& scm_weak_vector));
#line 4
  scm_make_gsubr(s_weak_vector_p, 1, 0, 0, (SCM (*)())(& scm_weak_vector_p));
#line 5
  scm_make_gsubr(s_make_weak_key_hash_table, 1, 0, 0, (SCM (*)())(& scm_make_weak_key_hash_table));
#line 6
  scm_make_gsubr(s_make_weak_value_hash_table, 1, 0, 0, (SCM (*)())(& scm_make_weak_value_hash_table));
#line 7
  scm_make_gsubr(s_make_doubly_weak_hash_table, 1, 0, 0, (SCM (*)())(& scm_make_doubly_weak_hash_table));
#line 8
  scm_make_gsubr(s_weak_key_hash_table_p, 1, 0, 0, (SCM (*)())(& scm_weak_key_hash_table_p));
#line 9
  scm_make_gsubr(s_weak_value_hash_table_p, 1, 0, 0, (SCM (*)())(& scm_weak_value_hash_table_p));
#line 10
  scm_make_gsubr(s_doubly_weak_hash_table_p, 1, 0, 0, (SCM (*)())(& scm_doubly_weak_hash_table_p));
  }
#line 202 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/weaks.c"
  return;
}
}
#line 67 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strings.h"
SCM scm_makfromstr(char const   *src , size_t len , int slots ) ;
#line 78 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/root.h"
SCM scm_sys_protects[17] ;
#line 163 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.h"
SCM scm_markstream(SCM ptr ) ;
#line 174
struct scm_port_table *scm_add_to_port_table(SCM port ) ;
#line 194
void scm_prinport(SCM exp___0 , SCM port , char *type ) ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 145 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.h"
SCM scm_apply(SCM proc , SCM arg1 , SCM args ) ;
#line 59 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/fports.h"
long scm_mode_bits(char *modes ) ;
#line 49 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/vports.h"
scm_ptobfuns scm_sfptob ;
#line 56
SCM scm_make_soft_port(SCM pv , SCM modes ) ;
#line 57
void scm_init_vports(void) ;
#line 63 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/vports.c"
static int prinsfpt(SCM exp___0 , SCM port , scm_print_state *pstate ) ;
#line 65 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/vports.c"
static int prinsfpt(SCM exp___0 , SCM port , scm_print_state *pstate ) 
{ 
  char *__cil_tmp4 ;

  {
  {
#line 71
  scm_prinport(exp___0, port, (char *)"soft");
  }
#line 72
  return (1);
}
}
#line 84
static int sfputc(int c , SCM p ) ;
#line 86 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/vports.c"
static int sfputc(int c , SCM p ) 
{ 
  int *tmp ;

  {
  {
#line 91
  scm_apply(*((SCM *)((scm_cell *)p)->cdr + 0), (SCM )((c << 8) + 244), scm_sys_protects[1]);
#line 92
  tmp = __errno_location();
#line 92
  *tmp = 0;
  }
#line 93
  return (c);
}
}
#line 97
static size_t sfwrite(char *str , size_t siz , size_t num , SCM p ) ;
#line 99 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/vports.c"
static size_t sfwrite(char *str , size_t siz , size_t num , SCM p ) 
{ 
  SCM sstr ;
  int *tmp ;

  {
  {
#line 107
  sstr = scm_makfromstr((char const   *)str, siz * num, 0);
#line 108
  scm_apply(*((SCM *)((scm_cell *)p)->cdr + 1), sstr, scm_sys_protects[1]);
#line 109
  tmp = __errno_location();
#line 109
  *tmp = 0;
  }
#line 110
  return (num);
}
}
#line 114
static int sfputs(char *s___0 , SCM p ) ;
#line 116 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/vports.c"
static int sfputs(char *s___0 , SCM p ) 
{ 
  size_t tmp ;

  {
  {
#line 121
  tmp = strlen((char const   *)s___0);
#line 121
  sfwrite(s___0, (size_t )1, tmp, p);
  }
#line 122
  return (0);
}
}
#line 126
static int sfflush(SCM stream ) ;
#line 128 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/vports.c"
static int sfflush(SCM stream ) 
{ 
  SCM f ;
  int *tmp ;
  int tmp___0 ;

  {
#line 132
  f = *((SCM *)((scm_cell *)stream)->cdr + 2);
#line 133
  if ((long )(16 << 9) + 372L == f) {
#line 134
    return (0);
  }
  {
#line 135
  f = scm_apply(f, (long )(20 << 9) + 372L, (long )(20 << 9) + 372L);
#line 136
  tmp = __errno_location();
#line 136
  *tmp = 0;
  }
#line 137
  if ((long )(16 << 9) + 372L == f) {
#line 137
    tmp___0 = -1;
  } else {
#line 137
    tmp___0 = 0;
  }
#line 137
  return (tmp___0);
}
}
#line 141
static int sfgetc(SCM p ) ;
#line 143 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/vports.c"
static int sfgetc(SCM p ) 
{ 
  SCM ans ;
  int *tmp ;
  char *__cil_tmp4 ;

  {
  {
#line 148
  ans = scm_apply(*((SCM *)((scm_cell *)p)->cdr + 3), (long )(20 << 9) + 372L, (long )(20 << 9) + 372L);
#line 149
  tmp = __errno_location();
#line 149
  *tmp = 0;
  }
#line 150
  if ((long )(16 << 9) + 372L == ans) {
#line 151
    return (-1);
  } else
#line 150
  if ((long )(19 << 9) + 372L == ans) {
#line 151
    return (-1);
  }
#line 152
  if (! (((int )ans & 255) == 244)) {
    {
#line 152
    scm_wta(ans, (char *)1, (char *)"getc");
    }
  }
#line 153
  return ((int )((unsigned int )(ans >> 8)));
}
}
#line 157
static int sfclose(SCM p ) ;
#line 159 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/vports.c"
static int sfclose(SCM p ) 
{ 
  SCM f ;
  int *tmp ;
  int tmp___0 ;

  {
#line 163
  f = *((SCM *)((scm_cell *)p)->cdr + 4);
#line 164
  if ((long )(16 << 9) + 372L == f) {
#line 165
    return (0);
  }
  {
#line 166
  f = scm_apply(f, (long )(20 << 9) + 372L, (long )(20 << 9) + 372L);
#line 167
  tmp = __errno_location();
#line 167
  *tmp = 0;
  }
#line 168
  if ((long )(16 << 9) + 372L == f) {
#line 168
    tmp___0 = -1;
  } else {
#line 168
    tmp___0 = 0;
  }
#line 168
  return (tmp___0);
}
}
#line 173 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/vports.c"
static char s_make_soft_port[15]  = 
#line 173
  {      (char )'m',      (char )'a',      (char )'k',      (char )'e', 
        (char )'-',      (char )'s',      (char )'o',      (char )'f', 
        (char )'t',      (char )'-',      (char )'p',      (char )'o', 
        (char )'r',      (char )'t',      (char )'\000'};
#line 175 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/vports.c"
SCM scm_make_soft_port(SCM pv , SCM modes ) 
{ 
  struct scm_port_table *pt ;
  SCM z ;
  long tmp ;

  {
#line 182
  if (! (6 & (int )pv)) {
#line 182
    if ((125 & (int )((scm_cell *)pv)->car) == 13) {
#line 182
      if (! (5UL == (unsigned long )((scm_cell *)pv)->car >> 8)) {
        {
#line 182
        scm_wta(pv, (char *)1, s_make_soft_port);
        }
      }
    } else {
      {
#line 182
      scm_wta(pv, (char *)1, s_make_soft_port);
      }
    }
  } else {
    {
#line 182
    scm_wta(pv, (char *)1, s_make_soft_port);
    }
  }
#line 183
  if (! (6 & (int )modes)) {
#line 183
    if (! ((125 & (int )((scm_cell *)modes)->car) == 21)) {
      {
#line 183
      scm_wta(modes, (char *)2, s_make_soft_port);
      }
    }
  } else {
    {
#line 183
    scm_wta(modes, (char *)2, s_make_soft_port);
    }
  }
#line 184
  if (6 & (int )scm_freelist) {
    {
#line 184
    z = scm_gc_for_newcell();
    }
  } else {
#line 184
    z = scm_freelist;
#line 184
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 184
    scm_cells_allocated ++;
  }
  {
#line 185
  scm_ints_disabled = 1;
#line 186
  pt = scm_add_to_port_table(z);
#line 187
  tmp = scm_mode_bits((char *)((scm_cell *)modes)->cdr);
#line 187
  ((scm_cell *)z)->car = 893L | tmp;
#line 188
  ((scm_cell *)z)->cdr = (SCM )pt;
#line 189
  ((struct scm_port_table *)((scm_cell *)z)->cdr)->stream = pv;
#line 190
  scm_ints_disabled = 0;
#line 190
  scm_async_clock --;
  }
#line 190
  if (0U == scm_async_clock) {
    {
#line 190
    scm_async_click();
    }
  }
#line 191
  return (z);
}
}
#line 195
static int noop0(SCM stream ) ;
#line 197 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/vports.c"
static int noop0(SCM stream ) 
{ 


  {
#line 201
  return (0);
}
}
#line 205 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/vports.c"
scm_ptobfuns scm_sfptob  = 
#line 205
     {& scm_markstream, & noop0, & prinsfpt, (SCM (*)(SCM  , SCM  ))0, & sfputc, & sfputs,
    & sfwrite, & sfflush, & sfgetc, & sfclose};
#line 221 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/vports.c"
void scm_init_vports(void) 
{ 


  {
  {
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/vports.x"
  scm_make_gsubr(s_make_soft_port, 2, 0, 0, (SCM (*)())(& scm_make_soft_port));
  }
#line 225 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/vports.c"
  return;
}
}
#line 51 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/version.h"
SCM scm_major_version(void) ;
#line 52
SCM scm_minor_version(void) ;
#line 53
SCM scm_version(void) ;
#line 54
void scm_init_version(void) ;
#line 50 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/version.c"
static char s_major_version[14]  = 
#line 50 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/version.c"
  {      (char )'m',      (char )'a',      (char )'j',      (char )'o', 
        (char )'r',      (char )'-',      (char )'v',      (char )'e', 
        (char )'r',      (char )'s',      (char )'i',      (char )'o', 
        (char )'n',      (char )'\000'};
#line 52 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/version.c"
SCM scm_major_version(void) 
{ 
  SCM tmp ;
  char *__cil_tmp2 ;

  {
  {
#line 55
  tmp = scm_makfrom0str("1");
  }
#line 55
  return (tmp);
}
}
#line 60 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/version.c"
static char s_minor_version[14]  = 
#line 60
  {      (char )'m',      (char )'i',      (char )'n',      (char )'o', 
        (char )'r',      (char )'-',      (char )'v',      (char )'e', 
        (char )'r',      (char )'s',      (char )'i',      (char )'o', 
        (char )'n',      (char )'\000'};
#line 62 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/version.c"
SCM scm_minor_version(void) 
{ 
  SCM tmp ;
  char *__cil_tmp2 ;

  {
  {
#line 65
  tmp = scm_makfrom0str("0");
  }
#line 65
  return (tmp);
}
}
#line 70 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/version.c"
static char s_version[8]  = 
#line 70
  {      (char )'v',      (char )'e',      (char )'r',      (char )'s', 
        (char )'i',      (char )'o',      (char )'n',      (char )'\000'};
#line 72 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/version.c"
SCM scm_version(void) 
{ 
  SCM tmp ;
  char *__cil_tmp2 ;

  {
  {
#line 75
  tmp = scm_makfrom0str("1.0");
  }
#line 75
  return (tmp);
}
}
#line 81 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/version.c"
void scm_init_version(void) 
{ 


  {
  {
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/version.x"
  scm_make_gsubr(s_major_version, 0, 0, 0, & scm_major_version);
#line 2
  scm_make_gsubr(s_minor_version, 0, 0, 0, & scm_minor_version);
#line 3
  scm_make_gsubr(s_version, 0, 0, 0, & scm_version);
  }
#line 85 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/version.c"
  return;
}
}
#line 58 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/vectors.h"
SCM scm_vector_p(SCM x ) ;
#line 59
SCM scm_vector_length(SCM v ) ;
#line 60
SCM scm_vector(SCM l ) ;
#line 61
SCM scm_vector_ref(SCM v , SCM k ) ;
#line 62
SCM scm_vector_set_x(SCM v , SCM k , SCM obj ) ;
#line 64
SCM scm_vector_to_list(SCM v ) ;
#line 65
SCM scm_vector_fill_x(SCM v , SCM fill_x ) ;
#line 66
SCM scm_vector_equal_p(SCM x , SCM y ) ;
#line 67
SCM scm_vector_move_left_x(SCM vec1 , SCM start1 , SCM end1 , SCM vec2 , SCM start2 ) ;
#line 69
SCM scm_vector_move_right_x(SCM vec1 , SCM start1 , SCM end1 , SCM vec2 , SCM start2 ) ;
#line 71
void scm_init_vectors(void) ;
#line 52 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eq.h"
SCM scm_equal_p(SCM x , SCM y ) ;
#line 51 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/vectors.c"
static char s_vector_p[8]  = 
#line 51 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/vectors.c"
  {      (char )'v',      (char )'e',      (char )'c',      (char )'t', 
        (char )'o',      (char )'r',      (char )'?',      (char )'\000'};
#line 53 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/vectors.c"
SCM scm_vector_p(SCM x ) 
{ 
  long tmp ;

  {
#line 57
  if (6 & (int )x) {
#line 57
    return ((long )(16 << 9) + 372L);
  }
#line 58
  if ((125 & (int )((scm_cell *)x)->car) == 13) {
#line 58
    tmp = (long )(17 << 9) + 372L;
  } else {
#line 58
    tmp = (long )(16 << 9) + 372L;
  }
#line 58
  return (tmp);
}
}
#line 61 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/vectors.c"
static char s_vector_length[14]  = 
#line 61
  {      (char )'v',      (char )'e',      (char )'c',      (char )'t', 
        (char )'o',      (char )'r',      (char )'-',      (char )'l', 
        (char )'e',      (char )'n',      (char )'g',      (char )'t', 
        (char )'h',      (char )'\000'};
#line 63 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/vectors.c"
SCM scm_vector_length(SCM v ) 
{ 


  {
#line 67
  if (! (6 & (int )v)) {
#line 67
    if (! ((125 & (int )((scm_cell *)v)->car) == 13)) {
      {
#line 67
      scm_wta(v, (char *)1, s_vector_length);
      }
    }
  } else {
    {
#line 67
    scm_wta(v, (char *)1, s_vector_length);
    }
  }
#line 68
  return ((SCM )((((unsigned long )((scm_cell *)v)->car >> 8) << 2) + 2UL));
}
}
#line 71 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/vectors.c"
static char s_list_to_vector[13]  = 
#line 71
  {      (char )'l',      (char )'i',      (char )'s',      (char )'t', 
        (char )'-',      (char )'>',      (char )'v',      (char )'e', 
        (char )'c',      (char )'t',      (char )'o',      (char )'r', 
        (char )'\000'};
#line 72 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/vectors.c"
static char s_vector[7]  = {      (char )'v',      (char )'e',      (char )'c',      (char )'t', 
        (char )'o',      (char )'r',      (char )'\000'};
#line 74 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/vectors.c"
SCM scm_vector(SCM l ) 
{ 
  SCM res ;
  register SCM *data ;
  long i ;
  long tmp ;
  SCM *tmp___0 ;

  {
  {
#line 80
  tmp = scm_ilength(l);
#line 80
  i = tmp;
  }
#line 81
  if (! (i >= 0L)) {
    {
#line 81
    scm_wta(l, (char *)1, s_vector);
    }
  }
  {
#line 82
  res = scm_make_vector((i << 2) + 2L, (long )(21 << 9) + 372L, (long )(18 << 9) + 372L);
#line 83
  data = (SCM *)((scm_cell *)res)->cdr;
  }
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (i) {
#line 84
      if (! (! (6 & (int )l))) {
#line 84
        goto while_break;
      }
    } else {
#line 84
      goto while_break;
    }
#line 85
    tmp___0 = data;
#line 85
    data ++;
#line 85
    *tmp___0 = ((scm_cell *)l)->car;
#line 84
    i --;
#line 84
    l = ((scm_cell *)l)->cdr;
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  return (res);
}
}
#line 89 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/vectors.c"
static char s_vector_ref[11]  = 
#line 89
  {      (char )'v',      (char )'e',      (char )'c',      (char )'t', 
        (char )'o',      (char )'r',      (char )'-',      (char )'r', 
        (char )'e',      (char )'f',      (char )'\000'};
#line 91 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/vectors.c"
SCM scm_vector_ref(SCM v , SCM k ) 
{ 


  {
#line 96
  if (! (6 & (int )v)) {
#line 96
    if (! ((125 & (int )((scm_cell *)v)->car) == 13)) {
      {
#line 96
      scm_wta(v, (char *)1, s_vector_ref);
      }
    }
  } else {
    {
#line 96
    scm_wta(v, (char *)1, s_vector_ref);
    }
  }
#line 97
  if (! (2 & (int )k)) {
    {
#line 97
    scm_wta(k, (char *)2, s_vector_ref);
    }
  }
#line 98
  if ((unsigned long )(k >> 2) < (unsigned long )((scm_cell *)v)->car >> 8) {
#line 98
    if (! (k >> 2 >= 0L)) {
      {
#line 98
      scm_wta(k, (char *)10, s_vector_ref);
      }
    }
  } else {
    {
#line 98
    scm_wta(k, (char *)10, s_vector_ref);
    }
  }
#line 99
  return (*((SCM *)((scm_cell *)v)->cdr + (k >> 2)));
}
}
#line 103 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/vectors.c"
static char s_vector_set_x[12]  = 
#line 103
  {      (char )'v',      (char )'e',      (char )'c',      (char )'t', 
        (char )'o',      (char )'r',      (char )'-',      (char )'s', 
        (char )'e',      (char )'t',      (char )'!',      (char )'\000'};
#line 105 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/vectors.c"
SCM scm_vector_set_x(SCM v , SCM k , SCM obj ) 
{ 


  {
#line 111
  if (! (6 & (int )v)) {
#line 111
    if (! ((125 & (int )((scm_cell *)v)->car) == 13)) {
      {
#line 111
      scm_wta(v, (char *)1, s_vector_set_x);
      }
    }
  } else {
    {
#line 111
    scm_wta(v, (char *)1, s_vector_set_x);
    }
  }
#line 112
  if (! (2 & (int )k)) {
    {
#line 112
    scm_wta(k, (char *)2, s_vector_set_x);
    }
  }
#line 113
  if ((unsigned long )(k >> 2) < (unsigned long )((scm_cell *)v)->car >> 8) {
#line 113
    if (! (k >> 2 >= 0L)) {
      {
#line 113
      scm_wta(k, (char *)10, s_vector_set_x);
      }
    }
  } else {
    {
#line 113
    scm_wta(k, (char *)10, s_vector_set_x);
    }
  }
#line 114
  *((SCM *)((scm_cell *)v)->cdr + (k >> 2)) = obj;
#line 115
  return (obj);
}
}
#line 119 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/vectors.c"
static char s_make_vector[12]  = 
#line 119
  {      (char )'m',      (char )'a',      (char )'k',      (char )'e', 
        (char )'-',      (char )'v',      (char )'e',      (char )'c', 
        (char )'t',      (char )'o',      (char )'r',      (char )'\000'};
#line 121 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/vectors.c"
SCM scm_make_vector(SCM k , SCM fill , SCM multip ) 
{ 
  SCM v ;
  int multi ;
  register long i ;
  register long j ;
  register SCM *velts ;
  int tmp ;
  long tmp___0 ;
  char *tmp___1 ;
  long tmp___2 ;

  {
#line 133
  if (2 & (int )k) {
#line 133
    if (! (0L <= k >> 2)) {
      {
#line 133
      scm_wta(k, (char *)1, s_make_vector);
      }
    }
  } else {
    {
#line 133
    scm_wta(k, (char *)1, s_make_vector);
    }
  }
#line 134
  if ((long )(18 << 9) + 372L == fill) {
#line 135
    fill = (long )(21 << 9) + 372L;
  }
#line 136
  if ((long )(18 << 9) + 372L == multip) {
#line 136
    tmp = 0;
  } else
#line 136
  if ((long )(16 << 9) + 372L == multip) {
#line 136
    tmp = 0;
  } else {
#line 136
    tmp = 1;
  }
#line 136
  multi = tmp;
#line 137
  i = k >> 2;
#line 138
  if (6 & (int )scm_freelist) {
    {
#line 138
    v = scm_gc_for_newcell();
    }
  } else {
#line 138
    v = scm_freelist;
#line 138
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 138
    scm_cells_allocated ++;
  }
#line 139
  scm_ints_disabled = 1;
#line 140
  if (i) {
#line 140
    tmp___0 = (long )((unsigned long )i * sizeof(SCM ));
  } else {
#line 140
    tmp___0 = 1L;
  }
  {
#line 140
  tmp___1 = scm_must_malloc(tmp___0, s_vector);
#line 140
  ((scm_cell *)v)->cdr = (SCM )tmp___1;
#line 141
  ((scm_cell *)v)->car = (i << 8) + 13L;
#line 142
  velts = (SCM *)((scm_cell *)v)->cdr;
#line 143
  j = 0L;
  }
#line 144
  if (multi) {
    {
#line 146
    while (1) {
      while_continue: /* CIL Label */ ;
#line 146
      if (fill != (long )(20 << 9) + 372L) {
#line 146
        if (! (j < i)) {
#line 146
          goto while_break;
        }
      } else {
#line 146
        goto while_break;
      }
#line 148
      tmp___2 = j;
#line 148
      j ++;
#line 148
      *(velts + tmp___2) = ((scm_cell *)fill)->car;
#line 149
      fill = ((scm_cell *)fill)->cdr;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 152
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 152
    i --;
#line 152
    if (! (i >= j)) {
#line 152
      goto while_break___0;
    }
#line 152
    *(velts + i) = fill;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 153
  scm_ints_disabled = 0;
#line 153
  scm_async_clock --;
#line 153
  if (0U == scm_async_clock) {
    {
#line 153
    scm_async_click();
    }
  }
#line 154
  return (v);
}
}
#line 158 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/vectors.c"
static char s_vector_to_list[13]  = 
#line 158
  {      (char )'v',      (char )'e',      (char )'c',      (char )'t', 
        (char )'o',      (char )'r',      (char )'-',      (char )'>', 
        (char )'l',      (char )'i',      (char )'s',      (char )'t', 
        (char )'\000'};
#line 160 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/vectors.c"
SCM scm_vector_to_list(SCM v ) 
{ 
  SCM res ;
  long i ;
  SCM *data ;

  {
#line 164
  res = (long )(20 << 9) + 372L;
#line 167
  if (! (6 & (int )v)) {
#line 167
    if (! ((125 & (int )((scm_cell *)v)->car) == 13)) {
      {
#line 167
      scm_wta(v, (char *)1, s_vector_to_list);
      }
    }
  } else {
    {
#line 167
    scm_wta(v, (char *)1, s_vector_to_list);
    }
  }
#line 168
  data = (SCM *)((scm_cell *)v)->cdr;
#line 169
  i = (long )(((unsigned long )((scm_cell *)v)->car >> 8) - 1UL);
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    if (! (i >= 0L)) {
#line 169
      goto while_break;
    }
    {
#line 169
    res = scm_cons(*(data + i), res);
#line 169
    i --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 170
  return (res);
}
}
#line 174 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/vectors.c"
static char s_vector_fill_x[13]  = 
#line 174
  {      (char )'v',      (char )'e',      (char )'c',      (char )'t', 
        (char )'o',      (char )'r',      (char )'-',      (char )'f', 
        (char )'i',      (char )'l',      (char )'l',      (char )'!', 
        (char )'\000'};
#line 176 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/vectors.c"
SCM scm_vector_fill_x(SCM v , SCM fill_x ) 
{ 
  register long i ;
  register SCM *data ;

  {
#line 183
  if (! (6 & (int )v)) {
#line 183
    if (! ((125 & (int )((scm_cell *)v)->car) == 13)) {
      {
#line 183
      scm_wta(v, (char *)1, s_vector_fill_x);
      }
    }
  } else {
    {
#line 183
    scm_wta(v, (char *)1, s_vector_fill_x);
    }
  }
#line 184
  data = (SCM *)((scm_cell *)v)->cdr;
#line 185
  i = (long )(((unsigned long )((scm_cell *)v)->car >> 8) - 1UL);
  {
#line 185
  while (1) {
    while_continue: /* CIL Label */ ;
#line 185
    if (! (i >= 0L)) {
#line 185
      goto while_break;
    }
#line 185
    *(data + i) = fill_x;
#line 185
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  return ((long )(21 << 9) + 372L);
}
}
#line 191 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/vectors.c"
SCM scm_vector_equal_p(SCM x , SCM y ) 
{ 
  long i ;
  SCM tmp ;

  {
#line 197
  i = (long )(((unsigned long )((scm_cell *)x)->car >> 8) - 1UL);
  {
#line 197
  while (1) {
    while_continue: /* CIL Label */ ;
#line 197
    if (! (i >= 0L)) {
#line 197
      goto while_break;
    }
    {
#line 198
    tmp = scm_equal_p(*((SCM *)((scm_cell *)x)->cdr + i), *((SCM *)((scm_cell *)y)->cdr + i));
    }
#line 198
    if ((long )(16 << 9) + 372L == tmp) {
#line 199
      return ((long )(16 << 9) + 372L);
    }
#line 197
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 200
  return ((long )(17 << 9) + 372L);
}
}
#line 204 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/vectors.c"
static char s_vector_move_left_x[18]  = 
#line 204
  {      (char )'v',      (char )'e',      (char )'c',      (char )'t', 
        (char )'o',      (char )'r',      (char )'-',      (char )'m', 
        (char )'o',      (char )'v',      (char )'e',      (char )'-', 
        (char )'l',      (char )'e',      (char )'f',      (char )'t', 
        (char )'!',      (char )'\000'};
#line 206 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/vectors.c"
SCM scm_vector_move_left_x(SCM vec1 , SCM start1 , SCM end1 , SCM vec2 , SCM start2 ) 
{ 
  long i ;
  long j ;
  long e ;
  long tmp ;
  long tmp___0 ;

  {
#line 218
  if (! (6 & (int )vec1)) {
#line 218
    if (! ((125 & (int )((scm_cell *)vec1)->car) == 13)) {
      {
#line 218
      scm_wta(vec1, (char *)1, s_vector_move_left_x);
      }
    }
  } else {
    {
#line 218
    scm_wta(vec1, (char *)1, s_vector_move_left_x);
    }
  }
#line 219
  if (! (2 & (int )start1)) {
    {
#line 219
    scm_wta(start1, (char *)2, s_vector_move_left_x);
    }
  }
#line 220
  if (! (2 & (int )end1)) {
    {
#line 220
    scm_wta(end1, (char *)3, s_vector_move_left_x);
    }
  }
#line 221
  if (! (6 & (int )vec2)) {
#line 221
    if (! ((125 & (int )((scm_cell *)vec2)->car) == 13)) {
      {
#line 221
      scm_wta(vec2, (char *)4, s_vector_move_left_x);
      }
    }
  } else {
    {
#line 221
    scm_wta(vec2, (char *)4, s_vector_move_left_x);
    }
  }
#line 222
  if (! (2 & (int )start2)) {
    {
#line 222
    scm_wta(start2, (char *)5, s_vector_move_left_x);
    }
  }
#line 223
  i = start1 >> 2;
#line 224
  j = start2 >> 2;
#line 225
  e = end1 >> 2;
#line 226
  if ((unsigned long )i <= (unsigned long )((scm_cell *)vec1)->car >> 8) {
#line 226
    if (! (i >= 0L)) {
      {
#line 226
      scm_wta(start1, (char *)10, s_vector_move_left_x);
      }
    }
  } else {
    {
#line 226
    scm_wta(start1, (char *)10, s_vector_move_left_x);
    }
  }
#line 227
  if ((unsigned long )j <= (unsigned long )((scm_cell *)vec2)->car >> 8) {
#line 227
    if (! (j >= 0L)) {
      {
#line 227
      scm_wta(start2, (char *)10, s_vector_move_left_x);
      }
    }
  } else {
    {
#line 227
    scm_wta(start2, (char *)10, s_vector_move_left_x);
    }
  }
#line 228
  if ((unsigned long )e <= (unsigned long )((scm_cell *)vec1)->car >> 8) {
#line 228
    if (! (e >= 0L)) {
      {
#line 228
      scm_wta(end1, (char *)10, s_vector_move_left_x);
      }
    }
  } else {
    {
#line 228
    scm_wta(end1, (char *)10, s_vector_move_left_x);
    }
  }
#line 229
  if (! ((unsigned long )((e - i) + j) <= (unsigned long )((scm_cell *)vec2)->car >> 8)) {
    {
#line 229
    scm_wta(start2, (char *)10, s_vector_move_left_x);
    }
  }
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! (i < e)) {
#line 230
      goto while_break;
    }
#line 230
    tmp = j;
#line 230
    j ++;
#line 230
    tmp___0 = i;
#line 230
    i ++;
#line 230
    *((SCM *)((scm_cell *)vec2)->cdr + tmp) = *((SCM *)((scm_cell *)vec1)->cdr + tmp___0);
  }
  while_break: /* CIL Label */ ;
  }
#line 231
  return ((long )(21 << 9) + 372L);
}
}
#line 234 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/vectors.c"
static char s_vector_move_right_x[19]  = 
#line 234
  {      (char )'v',      (char )'e',      (char )'c',      (char )'t', 
        (char )'o',      (char )'r',      (char )'-',      (char )'m', 
        (char )'o',      (char )'v',      (char )'e',      (char )'-', 
        (char )'r',      (char )'i',      (char )'g',      (char )'h', 
        (char )'t',      (char )'!',      (char )'\000'};
#line 236 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/vectors.c"
SCM scm_vector_move_right_x(SCM vec1 , SCM start1 , SCM end1 , SCM vec2 , SCM start2 ) 
{ 
  long i ;
  long j ;
  long e ;

  {
#line 248
  if (! (6 & (int )vec1)) {
#line 248
    if (! ((125 & (int )((scm_cell *)vec1)->car) == 13)) {
      {
#line 248
      scm_wta(vec1, (char *)1, s_vector_move_right_x);
      }
    }
  } else {
    {
#line 248
    scm_wta(vec1, (char *)1, s_vector_move_right_x);
    }
  }
#line 249
  if (! (2 & (int )start1)) {
    {
#line 249
    scm_wta(start1, (char *)2, s_vector_move_right_x);
    }
  }
#line 250
  if (! (2 & (int )end1)) {
    {
#line 250
    scm_wta(end1, (char *)3, s_vector_move_right_x);
    }
  }
#line 251
  if (! (6 & (int )vec2)) {
#line 251
    if (! ((125 & (int )((scm_cell *)vec2)->car) == 13)) {
      {
#line 251
      scm_wta(vec2, (char *)4, s_vector_move_right_x);
      }
    }
  } else {
    {
#line 251
    scm_wta(vec2, (char *)4, s_vector_move_right_x);
    }
  }
#line 252
  if (! (2 & (int )start2)) {
    {
#line 252
    scm_wta(start2, (char *)5, s_vector_move_right_x);
    }
  }
#line 253
  i = start1 >> 2;
#line 254
  j = start2 >> 2;
#line 255
  e = end1 >> 2;
#line 256
  if ((unsigned long )i <= (unsigned long )((scm_cell *)vec1)->car >> 8) {
#line 256
    if (! (i >= 0L)) {
      {
#line 256
      scm_wta(start1, (char *)10, s_vector_move_right_x);
      }
    }
  } else {
    {
#line 256
    scm_wta(start1, (char *)10, s_vector_move_right_x);
    }
  }
#line 257
  if ((unsigned long )j <= (unsigned long )((scm_cell *)vec2)->car >> 8) {
#line 257
    if (! (j >= 0L)) {
      {
#line 257
      scm_wta(start2, (char *)10, s_vector_move_right_x);
      }
    }
  } else {
    {
#line 257
    scm_wta(start2, (char *)10, s_vector_move_right_x);
    }
  }
#line 258
  if ((unsigned long )e <= (unsigned long )((scm_cell *)vec1)->car >> 8) {
#line 258
    if (! (e >= 0L)) {
      {
#line 258
      scm_wta(end1, (char *)10, s_vector_move_right_x);
      }
    }
  } else {
    {
#line 258
    scm_wta(end1, (char *)10, s_vector_move_right_x);
    }
  }
#line 259
  j = (e - i) + j;
#line 259
  if (! ((unsigned long )j <= (unsigned long )((scm_cell *)vec2)->car >> 8)) {
    {
#line 259
    scm_wta(start2, (char *)10, s_vector_move_right_x);
    }
  }
  {
#line 260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 260
    if (! (i < e)) {
#line 260
      goto while_break;
    }
#line 260
    j --;
#line 260
    e --;
#line 260
    *((SCM *)((scm_cell *)vec2)->cdr + j) = *((SCM *)((scm_cell *)vec1)->cdr + e);
  }
  while_break: /* CIL Label */ ;
  }
#line 261
  return ((long )(21 << 9) + 372L);
}
}
#line 266 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/vectors.c"
void scm_init_vectors(void) 
{ 


  {
  {
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/vectors.x"
  scm_make_gsubr(s_vector_p, 1, 0, 0, (SCM (*)())(& scm_vector_p));
#line 2
  scm_make_gsubr(s_vector_length, 1, 0, 0, (SCM (*)())(& scm_vector_length));
#line 3
  scm_make_gsubr(s_list_to_vector, 1, 0, 0, (SCM (*)())(& scm_vector));
#line 4
  scm_make_gsubr(s_vector, 0, 0, 1, (SCM (*)())(& scm_vector));
#line 5
  scm_make_gsubr(s_vector_ref, 2, 0, 0, (SCM (*)())(& scm_vector_ref));
#line 6
  scm_make_gsubr(s_vector_set_x, 3, 0, 0, (SCM (*)())(& scm_vector_set_x));
#line 7
  scm_make_gsubr(s_make_vector, 1, 2, 0, (SCM (*)())(& scm_make_vector));
#line 8
  scm_make_gsubr(s_vector_to_list, 1, 0, 0, (SCM (*)())(& scm_vector_to_list));
#line 9
  scm_make_gsubr(s_vector_fill_x, 2, 0, 0, (SCM (*)())(& scm_vector_fill_x));
#line 10
  scm_make_gsubr(s_vector_move_left_x, 5, 0, 0, (SCM (*)())(& scm_vector_move_left_x));
#line 11
  scm_make_gsubr(s_vector_move_right_x, 5, 0, 0, (SCM (*)())(& scm_vector_move_right_x));
  }
#line 270 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/vectors.c"
  return;
}
}
#line 93 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/print.h"
void scm_iprin1(SCM exp___0 , SCM port , scm_print_state *pstate ) ;
#line 107 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.h"
SCM scm_sym2vcell(SCM sym , SCM thunk , SCM definep ) ;
#line 109
SCM scm_sym2ovcell(SCM sym , SCM obarray ) ;
#line 119
SCM scm_intern_symbol(SCM o , SCM s___0 ) ;
#line 51 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/genio.h"
void scm_gen_putc(int c , SCM port ) ;
#line 53 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/variable.h"
int scm_tc16_variable  ;
#line 62
SCM scm_make_variable(SCM init , SCM name_hint ) ;
#line 63
SCM scm_make_undefined_variable(SCM name_hint ) ;
#line 64
SCM scm_variable_p(SCM obj ) ;
#line 65
SCM scm_variable_ref(SCM var ) ;
#line 66
SCM scm_variable_set_x(SCM var , SCM val ) ;
#line 67
SCM scm_builtin_variable(SCM name ) ;
#line 68
SCM scm_variable_bound_p(SCM var ) ;
#line 69
void scm_init_variable(void) ;
#line 51 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/variable.c"
static size_t free_var(SCM obj ) ;
#line 53 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/variable.c"
static size_t free_var(SCM obj ) 
{ 


  {
#line 57
  return ((size_t )0);
}
}
#line 62
static int prin_var(SCM exp___0 , SCM port , scm_print_state *pstate ) ;
#line 64 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/variable.c"
static int prin_var(SCM exp___0 , SCM port , scm_print_state *pstate ) 
{ 
  SCM val_cell ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 70
  scm_gen_puts((enum scm_string_representation_type )0, (char *)"#<variable ", port);
#line 71
  scm_intprint(exp___0, 16, port);
#line 74
  val_cell = ((scm_cell *)exp___0)->cdr;
  }
#line 75
  if (((scm_cell *)val_cell)->car != (long )(18 << 9) + 372L) {
    {
#line 77
    scm_gen_puts((enum scm_string_representation_type )0, (char *)" name: ", port);
#line 78
    scm_iprin1(((scm_cell *)val_cell)->car, port, pstate);
    }
  }
  {
#line 80
  scm_gen_puts((enum scm_string_representation_type )0, (char *)" binding: ", port);
#line 81
  scm_iprin1(((scm_cell *)val_cell)->cdr, port, pstate);
#line 83
  scm_gen_putc('>', port);
  }
#line 84
  return (1);
}
}
#line 88
static SCM scm_markvar(SCM ptr ) ;
#line 90 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/variable.c"
static SCM scm_markvar(SCM ptr ) 
{ 


  {
#line 94
  if (128 & (int )((scm_cell *)ptr)->car) {
#line 95
    return ((long )(16 << 9) + 372L);
  }
#line 96
  ((scm_cell *)ptr)->car |= 128L;
#line 97
  return (((scm_cell *)ptr)->cdr);
}
}
#line 101 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/variable.c"
static scm_smobfuns variable_smob  =    {& scm_markvar, & free_var, & prin_var, (SCM (*)(SCM  , SCM  ))0};
#line 104 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/variable.c"
static SCM anonymous_variable_sym  ;
#line 107
static SCM make_vcell_variable(SCM vcell ) ;
#line 109 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/variable.c"
static SCM make_vcell_variable(SCM vcell ) 
{ 
  SCM answer ;

  {
#line 114
  if (6 & (int )scm_freelist) {
    {
#line 114
    answer = scm_gc_for_newcell();
    }
  } else {
#line 114
    answer = scm_freelist;
#line 114
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 114
    scm_cells_allocated ++;
  }
#line 115
  scm_ints_disabled ++;
#line 116
  ((scm_cell *)answer)->car = (SCM )scm_tc16_variable;
#line 117
  ((scm_cell *)answer)->cdr = vcell;
#line 118
  scm_ints_disabled --;
#line 118
  if (! scm_ints_disabled) {
#line 118
    scm_async_clock --;
#line 118
    if (0U == scm_async_clock) {
      {
#line 118
      scm_async_click();
      }
    }
  }
#line 119
  return (answer);
}
}
#line 122 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/variable.c"
static char s_make_variable[14]  = 
#line 122
  {      (char )'m',      (char )'a',      (char )'k',      (char )'e', 
        (char )'-',      (char )'v',      (char )'a',      (char )'r', 
        (char )'i',      (char )'a',      (char )'b',      (char )'l', 
        (char )'e',      (char )'\000'};
#line 124 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/variable.c"
SCM scm_make_variable(SCM init , SCM name_hint ) 
{ 
  SCM val_cell ;
  SCM tmp ;

  {
#line 131
  if (name_hint == (long )(18 << 9) + 372L) {
#line 132
    name_hint = anonymous_variable_sym;
  }
#line 134
  if (6 & (int )scm_freelist) {
    {
#line 134
    val_cell = scm_gc_for_newcell();
    }
  } else {
#line 134
    val_cell = scm_freelist;
#line 134
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 134
    scm_cells_allocated ++;
  }
#line 135
  scm_ints_disabled = 1;
#line 136
  ((scm_cell *)val_cell)->car = name_hint;
#line 137
  ((scm_cell *)val_cell)->cdr = init;
#line 138
  scm_ints_disabled = 0;
#line 138
  scm_async_clock --;
#line 138
  if (0U == scm_async_clock) {
    {
#line 138
    scm_async_click();
    }
  }
  {
#line 139
  tmp = make_vcell_variable(val_cell);
  }
#line 139
  return (tmp);
}
}
#line 143 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/variable.c"
static char s_make_undefined_variable[24]  = 
#line 143
  {      (char )'m',      (char )'a',      (char )'k',      (char )'e', 
        (char )'-',      (char )'u',      (char )'n',      (char )'d', 
        (char )'e',      (char )'f',      (char )'i',      (char )'n', 
        (char )'e',      (char )'d',      (char )'-',      (char )'v', 
        (char )'a',      (char )'r',      (char )'i',      (char )'a', 
        (char )'b',      (char )'l',      (char )'e',      (char )'\000'};
#line 145 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/variable.c"
SCM scm_make_undefined_variable(SCM name_hint ) 
{ 
  SCM vcell ;
  SCM tmp ;

  {
#line 151
  if (name_hint == (long )(18 << 9) + 372L) {
#line 152
    name_hint = anonymous_variable_sym;
  }
#line 154
  if (6 & (int )scm_freelist) {
    {
#line 154
    vcell = scm_gc_for_newcell();
    }
  } else {
#line 154
    vcell = scm_freelist;
#line 154
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 154
    scm_cells_allocated ++;
  }
#line 155
  scm_ints_disabled = 1;
#line 156
  ((scm_cell *)vcell)->car = name_hint;
#line 157
  ((scm_cell *)vcell)->cdr = (long )(18 << 9) + 372L;
#line 158
  scm_ints_disabled = 0;
#line 158
  scm_async_clock --;
#line 158
  if (0U == scm_async_clock) {
    {
#line 158
    scm_async_click();
    }
  }
  {
#line 159
  tmp = make_vcell_variable(vcell);
  }
#line 159
  return (tmp);
}
}
#line 163 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/variable.c"
static char s_variable_p[10]  = 
#line 163
  {      (char )'v',      (char )'a',      (char )'r',      (char )'i', 
        (char )'a',      (char )'b',      (char )'l',      (char )'e', 
        (char )'?',      (char )'\000'};
#line 165 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/variable.c"
SCM scm_variable_p(SCM obj ) 
{ 
  long tmp ;

  {
#line 169
  if (! (6 & (int )obj)) {
#line 169
    if ((SCM )scm_tc16_variable == ((scm_cell *)obj)->car) {
#line 169
      tmp = (long )(17 << 9) + 372L;
    } else {
#line 169
      tmp = (long )(16 << 9) + 372L;
    }
  } else {
#line 169
    tmp = (long )(16 << 9) + 372L;
  }
#line 169
  return (tmp);
}
}
#line 175 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/variable.c"
static char s_variable_ref[13]  = 
#line 175
  {      (char )'v',      (char )'a',      (char )'r',      (char )'i', 
        (char )'a',      (char )'b',      (char )'l',      (char )'e', 
        (char )'-',      (char )'r',      (char )'e',      (char )'f', 
        (char )'\000'};
#line 177 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/variable.c"
SCM scm_variable_ref(SCM var ) 
{ 


  {
#line 181
  if (! (6 & (int )var)) {
#line 181
    if (! ((SCM )scm_tc16_variable == ((scm_cell *)var)->car)) {
      {
#line 181
      scm_wta(var, (char *)1, s_variable_ref);
      }
    }
  } else {
    {
#line 181
    scm_wta(var, (char *)1, s_variable_ref);
    }
  }
#line 182
  return (((scm_cell *)((scm_cell *)var)->cdr)->cdr);
}
}
#line 187 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/variable.c"
static char s_variable_set_x[14]  = 
#line 187
  {      (char )'v',      (char )'a',      (char )'r',      (char )'i', 
        (char )'a',      (char )'b',      (char )'l',      (char )'e', 
        (char )'-',      (char )'s',      (char )'e',      (char )'t', 
        (char )'!',      (char )'\000'};
#line 189 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/variable.c"
SCM scm_variable_set_x(SCM var , SCM val ) 
{ 


  {
#line 194
  if (! (6 & (int )var)) {
#line 194
    if (! ((SCM )scm_tc16_variable == ((scm_cell *)var)->car)) {
      {
#line 194
      scm_wta(var, (char *)1, s_variable_set_x);
      }
    }
  } else {
    {
#line 194
    scm_wta(var, (char *)1, s_variable_set_x);
    }
  }
#line 195
  ((scm_cell *)((scm_cell *)var)->cdr)->cdr = val;
#line 196
  return ((long )(21 << 9) + 372L);
}
}
#line 200 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/variable.c"
static char s_builtin_variable[17]  = 
#line 200
  {      (char )'b',      (char )'u',      (char )'i',      (char )'l', 
        (char )'t',      (char )'i',      (char )'n',      (char )'-', 
        (char )'v',      (char )'a',      (char )'r',      (char )'i', 
        (char )'a',      (char )'b',      (char )'l',      (char )'e', 
        (char )'\000'};
#line 202 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/variable.c"
SCM scm_builtin_variable(SCM name ) 
{ 
  SCM vcell ;
  SCM var_slot ;
  SCM tmp ;

  {
#line 209
  if (! (6 & (int )name)) {
#line 209
    if (! ((125 & (int )((scm_cell *)name)->car) == 5)) {
      {
#line 209
      scm_wta(name, (char *)1, s_builtin_variable);
      }
    }
  } else {
    {
#line 209
    scm_wta(name, (char *)1, s_builtin_variable);
    }
  }
  {
#line 210
  vcell = scm_sym2vcell(name, (long )(16 << 9) + 372L, (long )(17 << 9) + 372L);
  }
#line 211
  if (vcell == (long )(16 << 9) + 372L) {
#line 212
    return ((long )(16 << 9) + 372L);
  }
  {
#line 214
  scm_intern_symbol(scm_sys_protects[7], name);
#line 215
  var_slot = scm_sym2ovcell(name, scm_sys_protects[7]);
#line 217
  scm_ints_disabled = 1;
  }
#line 218
  if (6 & (int )((scm_cell *)var_slot)->cdr) {
    {
#line 220
    tmp = make_vcell_variable(vcell);
#line 220
    ((scm_cell *)var_slot)->cdr = tmp;
    }
  } else
#line 218
  if (((scm_cell *)var_slot)->cdr != vcell) {
    {
#line 220
    tmp = make_vcell_variable(vcell);
#line 220
    ((scm_cell *)var_slot)->cdr = tmp;
    }
  }
#line 221
  scm_ints_disabled = 0;
#line 221
  scm_async_clock --;
#line 221
  if (0U == scm_async_clock) {
    {
#line 221
    scm_async_click();
    }
  }
#line 223
  return (((scm_cell *)var_slot)->cdr);
}
}
#line 227 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/variable.c"
static char s_variable_bound_p[16]  = 
#line 227
  {      (char )'v',      (char )'a',      (char )'r',      (char )'i', 
        (char )'a',      (char )'b',      (char )'l',      (char )'e', 
        (char )'-',      (char )'b',      (char )'o',      (char )'u', 
        (char )'n',      (char )'d',      (char )'?',      (char )'\000'};
#line 229 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/variable.c"
SCM scm_variable_bound_p(SCM var ) 
{ 
  long tmp ;

  {
#line 233
  if (! (6 & (int )var)) {
#line 233
    if (! ((SCM )scm_tc16_variable == ((scm_cell *)var)->car)) {
      {
#line 233
      scm_wta(var, (char *)1, s_variable_bound_p);
      }
    }
  } else {
    {
#line 233
    scm_wta(var, (char *)1, s_variable_bound_p);
    }
  }
#line 234
  if ((long )(18 << 9) + 372L == ((scm_cell *)((scm_cell *)var)->cdr)->cdr) {
#line 234
    tmp = (long )(16 << 9) + 372L;
  } else {
#line 234
    tmp = (long )(17 << 9) + 372L;
  }
#line 234
  return (tmp);
}
}
#line 242 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/variable.c"
void scm_init_variable(void) 
{ 
  long tmp ;
  SCM tmp___0 ;
  char *__cil_tmp3 ;

  {
  {
#line 245
  tmp = scm_newsmob(& variable_smob);
#line 245
  scm_tc16_variable = (int )tmp;
#line 246
  tmp___0 = scm_sysintern((char *)"anonymous-variable", (long )(18 << 9) + 372L);
#line 246
  anonymous_variable_sym = ((scm_cell *)tmp___0)->car;
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/variable.x"
  scm_make_gsubr(s_make_variable, 1, 1, 0, (SCM (*)())(& scm_make_variable));
#line 2
  scm_make_gsubr(s_make_undefined_variable, 0, 1, 0, (SCM (*)())(& scm_make_undefined_variable));
#line 3
  scm_make_gsubr(s_variable_p, 1, 0, 0, (SCM (*)())(& scm_variable_p));
#line 4
  scm_make_gsubr(s_variable_ref, 1, 0, 0, (SCM (*)())(& scm_variable_ref));
#line 5
  scm_make_gsubr(s_variable_set_x, 2, 0, 0, (SCM (*)())(& scm_variable_set_x));
#line 6
  scm_make_gsubr(s_builtin_variable, 1, 0, 0, (SCM (*)())(& scm_builtin_variable));
#line 7
  scm_make_gsubr(s_variable_bound_p, 1, 0, 0, (SCM (*)())(& scm_variable_bound_p));
  }
#line 248 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/variable.c"
  return;
}
}
#line 675 "/usr/include/stdio.h"
extern int ungetc(int __c , FILE *__stream ) ;
#line 682
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 688
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 513 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
#line 74 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/error.h"
 __attribute__((__noreturn__)) void scm_out_of_range(char *subr , SCM bad_value ) ;
#line 75
 __attribute__((__noreturn__)) void scm_wrong_num_args(SCM proc ) ;
#line 166 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/pairs.h"
SCM scm_cons2(SCM w , SCM x , SCM y ) ;
#line 59 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.h"
SCM scm_list_reverse(SCM lst ) ;
#line 91 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.h"
char *scm_must_realloc(char *where , long olen , long len , char *what ) ;
#line 97 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/procs.h"
SCM scm_procedure_p(SCM obj ) ;
#line 268 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.h"
int scm_floprint(SCM sexp , SCM port , scm_print_state *pstate ) ;
#line 274
SCM scm_makdbl(double x , double y ) ;
#line 316
SCM scm_ulong2num(unsigned long sl ) ;
#line 318
long num2long(SCM num , char *pos , char *s_caller ) ;
#line 320
unsigned long scm_num2ulong(SCM num , char *pos , char *s_caller ) ;
#line 112 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.h"
SCM scm_intern(char *name , size_t len ) ;
#line 70 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strings.h"
SCM scm_make_string(SCM k , SCM chr ) ;
#line 146 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/root.h"
struct scm_root_state *scm_root ;
#line 86 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.h"
int scm_upcase(unsigned int c ) ;
#line 87
int scm_downcase(unsigned int c ) ;
#line 56 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/sequences.h"
SCM scm_reverse(SCM objs ) ;
#line 60 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strop.h"
SCM scm_string_to_list(SCM str ) ;
#line 64 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.h"
long scm_tc16_array  ;
#line 77
SCM scm_vector_set_length_x(SCM vect , SCM len ) ;
#line 79
SCM scm_make_uve(long k , SCM prot ) ;
#line 80
SCM scm_uniform_vector_length(SCM v ) ;
#line 81
SCM scm_array_p(SCM v , SCM prot ) ;
#line 82
SCM scm_array_rank(SCM ra ) ;
#line 83
SCM scm_array_dimensions(SCM ra ) ;
#line 84
long scm_aind(SCM ra , SCM args , char *what ) ;
#line 85
SCM scm_make_ra(int ndim ) ;
#line 86
SCM scm_shap2ra(SCM args , char *what ) ;
#line 87
SCM scm_dimensions_to_uniform_array(SCM dims , SCM prot , SCM fill ) ;
#line 88
void scm_ra_set_contp(SCM ra ) ;
#line 89
SCM scm_make_shared_array(SCM oldra , SCM mapfunc , SCM dims ) ;
#line 90
SCM scm_transpose_array(SCM args ) ;
#line 91
SCM scm_enclose_array(SCM axes ) ;
#line 92
SCM scm_array_in_bounds_p(SCM args ) ;
#line 93
SCM scm_uniform_vector_ref(SCM v , SCM args ) ;
#line 94
SCM scm_cvref(SCM v , size_t pos , SCM last ) ;
#line 95
SCM scm_array_set_x(SCM v , SCM obj , SCM args ) ;
#line 96
SCM scm_array_contents(SCM ra , SCM strict ) ;
#line 97
SCM scm_ra2contig(SCM ra , int copy ) ;
#line 98
SCM scm_uniform_array_read_x(SCM ra , SCM port ) ;
#line 99
SCM scm_uniform_array_write(SCM v , SCM port ) ;
#line 100
SCM scm_bit_count(SCM item , SCM seq ) ;
#line 101
SCM scm_bit_position(SCM item , SCM v , SCM k ) ;
#line 102
SCM scm_bit_set_star_x(SCM v , SCM kv , SCM obj ) ;
#line 103
SCM scm_bit_count_star(SCM v , SCM kv , SCM obj ) ;
#line 104
SCM scm_bit_invert_x(SCM v ) ;
#line 105
SCM scm_string_upcase_x(SCM v ) ;
#line 106
SCM scm_string_downcase_x(SCM v ) ;
#line 107
SCM scm_istr2bve(char *str , long len ) ;
#line 108
SCM scm_array_to_list(SCM v ) ;
#line 109
SCM scm_list_to_uniform_array(SCM ndim , SCM prot , SCM lst ) ;
#line 110
int scm_raprin1(SCM exp___0 , SCM port , scm_print_state *pstate ) ;
#line 111
SCM scm_array_prototype(SCM ra ) ;
#line 112
void scm_init_unif(void) ;
#line 54 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.h"
SCM scm_array_fill_x(SCM ra , SCM fill ) ;
#line 55
SCM scm_array_copy_x(SCM src , SCM dst ) ;
#line 70
SCM scm_array_equal_p(SCM ra0 , SCM ra1 ) ;
#line 80 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
static char s_vector_set_length_x[19]  = 
#line 80 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
  {      (char )'v',      (char )'e',      (char )'c',      (char )'t', 
        (char )'o',      (char )'r',      (char )'-',      (char )'s', 
        (char )'e',      (char )'t',      (char )'-',      (char )'l', 
        (char )'e',      (char )'n',      (char )'g',      (char )'t', 
        (char )'h',      (char )'!',      (char )'\000'};
#line 83 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
SCM scm_vector_set_length_x(SCM vect , SCM len ) 
{ 
  long l ;
  size_t siz ;
  size_t sz ;
  char *tmp ;

  {
#line 92
  l = len >> 2;
#line 93
  if (! (! (6 & (int )vect))) {
#line 93
    goto badarg1;
  }
  {
#line 99
  if ((127 & (int )((scm_cell *)vect)->car) == 23) {
#line 99
    goto case_23;
  }
#line 99
  if ((127 & (int )((scm_cell *)vect)->car) == 21) {
#line 99
    goto case_23;
  }
#line 104
  if ((127 & (int )((scm_cell *)vect)->car) == 13) {
#line 104
    goto case_13;
  }
#line 109
  if ((127 & (int )((scm_cell *)vect)->car) == 71) {
#line 109
    goto case_71;
  }
#line 112
  if ((127 & (int )((scm_cell *)vect)->car) == 79) {
#line 112
    goto case_79;
  }
#line 112
  if ((127 & (int )((scm_cell *)vect)->car) == 37) {
#line 112
    goto case_79;
  }
#line 115
  if ((127 & (int )((scm_cell *)vect)->car) == 77) {
#line 115
    goto case_77;
  }
#line 119
  if ((127 & (int )((scm_cell *)vect)->car) == 55) {
#line 119
    goto case_55;
  }
#line 134
  if ((127 & (int )((scm_cell *)vect)->car) == 47) {
#line 134
    goto case_47;
  }
#line 137
  if ((127 & (int )((scm_cell *)vect)->car) == 53) {
#line 137
    goto case_53;
  }
#line 96
  goto badarg1;
  badarg1: 
  switch_default: /* CIL Label */ 
  {
#line 97
  scm_wta(vect, (char *)1, s_vector_set_length_x);
  }
  case_23: /* CIL Label */ 
  case_21: /* CIL Label */ 
#line 100
  if (! (vect != scm_sys_protects[4])) {
#line 100
    goto badarg1;
  }
#line 101
  sz = sizeof(char );
#line 102
  l ++;
#line 103
  goto switch_break;
  case_13: /* CIL Label */ 
#line 105
  if (! (vect != scm_sys_protects[3])) {
#line 105
    goto badarg1;
  }
#line 106
  sz = sizeof(SCM );
#line 107
  goto switch_break;
  case_71: /* CIL Label */ 
#line 110
  l = (long )((((unsigned long )l + (8UL * sizeof(long )) / sizeof(char )) - 1UL) / ((8UL * sizeof(long )) / sizeof(char )));
  case_79: /* CIL Label */ 
  case_37: /* CIL Label */ 
#line 113
  sz = sizeof(long );
#line 114
  goto switch_break;
  case_77: /* CIL Label */ 
#line 116
  sz = sizeof(char );
#line 117
  goto switch_break;
  case_55: /* CIL Label */ 
#line 120
  sz = sizeof(short );
#line 121
  goto switch_break;
  case_47: /* CIL Label */ 
#line 135
  sz = sizeof(double );
#line 136
  goto switch_break;
  case_53: /* CIL Label */ 
#line 138
  sz = 2UL * sizeof(double );
#line 139
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 143
  if (! (2 & (int )len)) {
    {
#line 143
    scm_wta(len, (char *)2, s_vector_set_length_x);
    }
  }
#line 144
  if (! l) {
#line 145
    l = 1L;
  }
#line 146
  siz = (size_t )l * sz;
#line 147
  if (siz != (size_t )l * sz) {
    {
#line 148
    scm_wta((SCM )(((size_t )l * sz << 2) + 2UL), (char *)11, s_vector_set_length_x);
    }
  }
  {
#line 149
  scm_ints_disabled ++;
#line 150
  tmp = scm_must_realloc((char *)((scm_cell *)vect)->cdr, (long )((size_t )((long )((unsigned long )((scm_cell *)vect)->car >> 8)) * sz),
                         (long )siz, s_vector_set_length_x);
#line 150
  ((scm_cell *)vect)->cdr = (SCM )tmp;
  }
#line 156
  if ((125 & (int )((scm_cell *)vect)->car) == 13) {
#line 158
    sz = (unsigned long )((scm_cell *)vect)->car >> 8;
    {
#line 159
    while (1) {
      while_continue: /* CIL Label */ ;
#line 159
      if (! ((size_t )l > sz)) {
#line 159
        goto while_break;
      }
#line 160
      l --;
#line 160
      *((SCM *)((scm_cell *)vect)->cdr + l) = (long )(21 << 9) + 372L;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 162
  if ((125 & (int )((scm_cell *)vect)->car) == 21) {
#line 163
    *((char *)((scm_cell *)vect)->cdr + (l - 1L)) = (char)0;
  }
#line 164
  ((scm_cell *)vect)->car = ((len >> 2) << 8) + (SCM )(127 & (int )((scm_cell *)vect)->car);
#line 165
  scm_ints_disabled --;
#line 165
  if (! scm_ints_disabled) {
#line 165
    scm_async_clock --;
#line 165
    if (0U == scm_async_clock) {
      {
#line 165
      scm_async_click();
      }
    }
  }
#line 166
  return (vect);
}
}
#line 194 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
SCM scm_make_uve(long k , SCM prot ) 
{ 
  SCM v ;
  long i ;
  long type ;
  char s___0 ;
  SCM tmp ;
  SCM tmp___0 ;
  char *m ;
  long tmp___1 ;
  long tmp___2 ;
  char *__cil_tmp12 ;

  {
#line 201
  if ((long )(17 << 9) + 372L == prot) {
#line 203
    i = (long )(sizeof(long ) * ((((unsigned long )k + (8UL * sizeof(long )) / sizeof(char )) - 1UL) / ((8UL * sizeof(long )) / sizeof(char ))));
#line 204
    type = 71L;
  } else
#line 206
  if (((int )prot & 255) == 244) {
#line 206
    if (prot == 244L) {
#line 208
      i = (long )(sizeof(char ) * (unsigned long )k);
#line 209
      type = 77L;
    } else {
#line 206
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 211
  if (((int )prot & 255) == 244) {
#line 213
    i = (long )(sizeof(char ) * (unsigned long )k);
#line 214
    type = 21L;
  } else
#line 216
  if (2 & (int )prot) {
#line 218
    i = (long )(sizeof(long ) * (unsigned long )k);
#line 219
    if (prot >> 2 > 0L) {
#line 220
      type = 37L;
    } else {
#line 222
      type = 79L;
    }
  } else
#line 224
  if (! (6 & (int )prot)) {
#line 224
    if ((125 & (int )((scm_cell *)prot)->car) == 5) {
#line 224
      if (1UL == (unsigned long )((scm_cell *)prot)->car >> 8) {
#line 228
        s___0 = *((char *)((scm_cell *)prot)->cdr + 0);
#line 229
        if ((int )s___0 == 115) {
#line 231
          i = (long )(sizeof(short ) * (unsigned long )k);
#line 232
          type = 55L;
        } else {
          {
#line 243
          tmp = scm_make_vector((k << 2) + 2L, (long )(18 << 9) + 372L, (long )(18 << 9) + 372L);
          }
#line 243
          return (tmp);
        }
      } else {
#line 224
        goto _L___0;
      }
    } else {
#line 224
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 248
  if (6 & (int )prot) {
    {
#line 251
    tmp___0 = scm_make_vector((k << 2) + 2L, (long )(18 << 9) + 372L, (long )(18 << 9) + 372L);
    }
#line 251
    return (tmp___0);
  } else
#line 248
  if (! ((65535 & (int )((scm_cell *)prot)->car) == 383)) {
    {
#line 251
    tmp___0 = scm_make_vector((k << 2) + 2L, (long )(18 << 9) + 372L, (long )(18 << 9) + 372L);
    }
#line 251
    return (tmp___0);
  } else
#line 261
  if (((scm_cell *)prot)->car == ((383L | (1L << 16)) | (2L << 16))) {
#line 263
    i = (long )((2UL * sizeof(double )) * (unsigned long )k);
#line 264
    type = 53L;
  } else {
#line 268
    i = (long )(sizeof(double ) * (unsigned long )k);
#line 269
    type = 47L;
  }
#line 273
  if (6 & (int )scm_freelist) {
    {
#line 273
    v = scm_gc_for_newcell();
    }
  } else {
#line 273
    v = scm_freelist;
#line 273
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 273
    scm_cells_allocated ++;
  }
#line 274
  scm_ints_disabled = 1;
#line 277
  if (i) {
#line 277
    tmp___1 = i;
  } else {
#line 277
    tmp___1 = 1L;
  }
  {
#line 277
  m = scm_must_malloc(tmp___1, (char *)"vector");
#line 278
  ((scm_cell *)v)->cdr = (SCM )m;
  }
#line 280
  if (k < 16777215L) {
#line 280
    tmp___2 = k;
  } else {
#line 280
    tmp___2 = 16777215L;
  }
#line 280
  ((scm_cell *)v)->car = (tmp___2 << 8) + type;
#line 281
  scm_ints_disabled = 0;
#line 281
  scm_async_clock --;
#line 281
  if (0U == scm_async_clock) {
    {
#line 281
    scm_async_click();
    }
  }
#line 282
  return (v);
}
}
#line 285 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
static char s_uniform_vector_length[22]  = 
#line 285
  {      (char )'u',      (char )'n',      (char )'i',      (char )'f', 
        (char )'o',      (char )'r',      (char )'m',      (char )'-', 
        (char )'v',      (char )'e',      (char )'c',      (char )'t', 
        (char )'o',      (char )'r',      (char )'-',      (char )'l', 
        (char )'e',      (char )'n',      (char )'g',      (char )'t', 
        (char )'h',      (char )'\000'};
#line 287 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
SCM scm_uniform_vector_length(SCM v ) 
{ 


  {
#line 291
  if (! (! (6 & (int )v))) {
#line 291
    goto badarg1;
  }
  {
#line 306
  if ((127 & (int )((scm_cell *)v)->car) == 55) {
#line 306
    goto case_55;
  }
#line 306
  if ((127 & (int )((scm_cell *)v)->car) == 13) {
#line 306
    goto case_55;
  }
#line 306
  if ((127 & (int )((scm_cell *)v)->car) == 53) {
#line 306
    goto case_55;
  }
#line 306
  if ((127 & (int )((scm_cell *)v)->car) == 47) {
#line 306
    goto case_55;
  }
#line 306
  if ((127 & (int )((scm_cell *)v)->car) == 45) {
#line 306
    goto case_55;
  }
#line 306
  if ((127 & (int )((scm_cell *)v)->car) == 79) {
#line 306
    goto case_55;
  }
#line 306
  if ((127 & (int )((scm_cell *)v)->car) == 37) {
#line 306
    goto case_55;
  }
#line 306
  if ((127 & (int )((scm_cell *)v)->car) == 77) {
#line 306
    goto case_55;
  }
#line 306
  if ((127 & (int )((scm_cell *)v)->car) == 21) {
#line 306
    goto case_55;
  }
#line 306
  if ((127 & (int )((scm_cell *)v)->car) == 71) {
#line 306
    goto case_55;
  }
#line 295
  goto badarg1;
  badarg1: 
  switch_default: /* CIL Label */ 
  {
#line 296
  scm_wta(v, (char *)1, s_uniform_vector_length);
  }
  case_55: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_21: /* CIL Label */ 
  case_71: /* CIL Label */ 
#line 310
  return ((SCM )((((unsigned long )((scm_cell *)v)->car >> 8) << 2) + 2UL));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 314 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
static char s_array_p[7]  = {      (char )'a',      (char )'r',      (char )'r',      (char )'a', 
        (char )'y',      (char )'?',      (char )'\000'};
#line 316 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
SCM scm_array_p(SCM v , SCM prot ) 
{ 
  int nprot ;
  int enclosed ;
  int tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;

  {
#line 323
  nprot = (long )(18 << 9) + 372L == prot;
#line 324
  enclosed = 0;
#line 325
  if (6 & (int )v) {
#line 326
    return ((long )(16 << 9) + 372L);
  }
  loop: 
  {
#line 330
  if ((127 & (int )((scm_cell *)v)->car) == 127) {
#line 330
    goto case_127;
  }
#line 339
  if ((127 & (int )((scm_cell *)v)->car) == 71) {
#line 339
    goto case_71;
  }
#line 341
  if ((127 & (int )((scm_cell *)v)->car) == 21) {
#line 341
    goto case_21;
  }
#line 343
  if ((127 & (int )((scm_cell *)v)->car) == 77) {
#line 343
    goto case_77;
  }
#line 345
  if ((127 & (int )((scm_cell *)v)->car) == 37) {
#line 345
    goto case_37;
  }
#line 347
  if ((127 & (int )((scm_cell *)v)->car) == 79) {
#line 347
    goto case_79;
  }
#line 349
  if ((127 & (int )((scm_cell *)v)->car) == 55) {
#line 349
    goto case_55;
  }
#line 368
  if ((127 & (int )((scm_cell *)v)->car) == 47) {
#line 368
    goto case_47;
  }
#line 370
  if ((127 & (int )((scm_cell *)v)->car) == 53) {
#line 370
    goto case_53;
  }
#line 373
  if ((127 & (int )((scm_cell *)v)->car) == 13) {
#line 373
    goto case_13;
  }
#line 375
  goto switch_default;
  case_127: /* CIL Label */ 
#line 331
  if (! (scm_tc16_array == (long )(65535 & (int )((scm_cell *)v)->car))) {
#line 332
    return ((long )(16 << 9) + 372L);
  }
#line 333
  if (nprot) {
#line 334
    return ((long )(17 << 9) + 372L);
  }
#line 335
  tmp = enclosed;
#line 335
  enclosed ++;
#line 335
  if (tmp) {
#line 336
    return ((long )(16 << 9) + 372L);
  }
#line 337
  v = ((scm_array *)((scm_cell *)v)->cdr)->v;
#line 338
  goto loop;
  case_71: /* CIL Label */ 
#line 340
  if (nprot) {
#line 340
    tmp___0 = (long )(17 << 9) + 372L;
  } else
#line 340
  if ((long )(17 << 9) + 372L == prot) {
#line 340
    tmp___0 = (long )(17 << 9) + 372L;
  } else {
#line 340
    tmp___0 = (long )(16 << 9) + 372L;
  }
#line 340
  return (tmp___0);
  case_21: /* CIL Label */ 
#line 342
  if (nprot) {
#line 342
    tmp___1 = (long )(17 << 9) + 372L;
  } else
#line 342
  if (((int )prot & 255) == 244) {
#line 342
    if (prot != 244L) {
#line 342
      tmp___1 = (long )(17 << 9) + 372L;
    } else {
#line 342
      tmp___1 = (long )(16 << 9) + 372L;
    }
  } else {
#line 342
    tmp___1 = (long )(16 << 9) + 372L;
  }
#line 342
  return (tmp___1);
  case_77: /* CIL Label */ 
#line 344
  if (nprot) {
#line 344
    tmp___2 = (long )(17 << 9) + 372L;
  } else
#line 344
  if (prot == 244L) {
#line 344
    tmp___2 = (long )(17 << 9) + 372L;
  } else {
#line 344
    tmp___2 = (long )(16 << 9) + 372L;
  }
#line 344
  return (tmp___2);
  case_37: /* CIL Label */ 
#line 346
  if (nprot) {
#line 346
    tmp___3 = (long )(17 << 9) + 372L;
  } else
#line 346
  if (2 & (int )prot) {
#line 346
    if (prot >> 2 > 0L) {
#line 346
      tmp___3 = (long )(17 << 9) + 372L;
    } else {
#line 346
      tmp___3 = (long )(16 << 9) + 372L;
    }
  } else {
#line 346
    tmp___3 = (long )(16 << 9) + 372L;
  }
#line 346
  return (tmp___3);
  case_79: /* CIL Label */ 
#line 348
  if (nprot) {
#line 348
    tmp___4 = (long )(17 << 9) + 372L;
  } else
#line 348
  if (2 & (int )prot) {
#line 348
    if (prot >> 2 <= 0L) {
#line 348
      tmp___4 = (long )(17 << 9) + 372L;
    } else {
#line 348
      tmp___4 = (long )(16 << 9) + 372L;
    }
  } else {
#line 348
    tmp___4 = (long )(16 << 9) + 372L;
  }
#line 348
  return (tmp___4);
  case_55: /* CIL Label */ 
#line 350
  if (nprot) {
#line 350
    tmp___5 = 1;
  } else
#line 350
  if (! (6 & (int )prot)) {
#line 350
    if ((125 & (int )((scm_cell *)prot)->car) == 5) {
#line 350
      if (1UL == (unsigned long )((scm_cell *)prot)->car >> 8) {
#line 350
        if (115 == (int )*((char *)((scm_cell *)prot)->cdr + 0)) {
#line 350
          tmp___5 = 1;
        } else {
#line 350
          tmp___5 = 0;
        }
      } else {
#line 350
        tmp___5 = 0;
      }
    } else {
#line 350
      tmp___5 = 0;
    }
  } else {
#line 350
    tmp___5 = 0;
  }
#line 350
  return ((SCM )tmp___5);
  case_47: /* CIL Label */ 
#line 369
  if (nprot) {
#line 369
    tmp___6 = (long )(17 << 9) + 372L;
  } else
#line 369
  if (! (6 & (int )prot)) {
#line 369
    if (((scm_cell *)prot)->car == (383L | (1L << 16))) {
#line 369
      tmp___6 = (long )(17 << 9) + 372L;
    } else {
#line 369
      tmp___6 = (long )(16 << 9) + 372L;
    }
  } else {
#line 369
    tmp___6 = (long )(16 << 9) + 372L;
  }
#line 369
  return (tmp___6);
  case_53: /* CIL Label */ 
#line 371
  if (nprot) {
#line 371
    tmp___7 = (long )(17 << 9) + 372L;
  } else
#line 371
  if (! (6 & (int )prot)) {
#line 371
    if (((scm_cell *)prot)->car == ((383L | (1L << 16)) | (2L << 16))) {
#line 371
      tmp___7 = (long )(17 << 9) + 372L;
    } else {
#line 371
      tmp___7 = (long )(16 << 9) + 372L;
    }
  } else {
#line 371
    tmp___7 = (long )(16 << 9) + 372L;
  }
#line 371
  return (tmp___7);
  case_13: /* CIL Label */ 
#line 374
  if (nprot) {
#line 374
    tmp___8 = (long )(17 << 9) + 372L;
  } else
#line 374
  if ((long )(20 << 9) + 372L == prot) {
#line 374
    tmp___8 = (long )(17 << 9) + 372L;
  } else {
#line 374
    tmp___8 = (long )(16 << 9) + 372L;
  }
#line 374
  return (tmp___8);
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 377
  return ((long )(16 << 9) + 372L);
}
}
#line 381 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
static char s_array_rank[11]  = 
#line 381
  {      (char )'a',      (char )'r',      (char )'r',      (char )'a', 
        (char )'y',      (char )'-',      (char )'r',      (char )'a', 
        (char )'n',      (char )'k',      (char )'\000'};
#line 383 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
SCM scm_array_rank(SCM ra ) 
{ 


  {
#line 387
  if (6 & (int )ra) {
#line 388
    return ((SCM )2);
  }
  {
#line 404
  if ((127 & (int )((scm_cell *)ra)->car) == 55) {
#line 404
    goto case_55;
  }
#line 404
  if ((127 & (int )((scm_cell *)ra)->car) == 47) {
#line 404
    goto case_55;
  }
#line 404
  if ((127 & (int )((scm_cell *)ra)->car) == 53) {
#line 404
    goto case_55;
  }
#line 404
  if ((127 & (int )((scm_cell *)ra)->car) == 45) {
#line 404
    goto case_55;
  }
#line 404
  if ((127 & (int )((scm_cell *)ra)->car) == 79) {
#line 404
    goto case_55;
  }
#line 404
  if ((127 & (int )((scm_cell *)ra)->car) == 37) {
#line 404
    goto case_55;
  }
#line 404
  if ((127 & (int )((scm_cell *)ra)->car) == 77) {
#line 404
    goto case_55;
  }
#line 404
  if ((127 & (int )((scm_cell *)ra)->car) == 13) {
#line 404
    goto case_55;
  }
#line 404
  if ((127 & (int )((scm_cell *)ra)->car) == 21) {
#line 404
    goto case_55;
  }
#line 406
  if ((127 & (int )((scm_cell *)ra)->car) == 127) {
#line 406
    goto case_127;
  }
#line 391
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 392
  return ((SCM )2);
  case_55: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_21: /* CIL Label */ 
#line 405
  return ((1L << 2) + 2L);
  case_127: /* CIL Label */ 
#line 407
  if (scm_tc16_array == (long )(65535 & (int )((scm_cell *)ra)->car)) {
#line 408
    return ((SCM )(((size_t )(((scm_cell *)ra)->car >> 17) << 2) + 2UL));
  }
#line 409
  return ((SCM )2);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 414 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
static char s_array_dimensions[17]  = 
#line 414
  {      (char )'a',      (char )'r',      (char )'r',      (char )'a', 
        (char )'y',      (char )'-',      (char )'d',      (char )'i', 
        (char )'m',      (char )'e',      (char )'n',      (char )'s', 
        (char )'i',      (char )'o',      (char )'n',      (char )'s', 
        (char )'\000'};
#line 416 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
SCM scm_array_dimensions(SCM ra ) 
{ 
  SCM res ;
  size_t k ;
  scm_array_dim *s___0 ;
  SCM tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  size_t tmp___2 ;

  {
#line 420
  res = (long )(20 << 9) + 372L;
#line 423
  if (6 & (int )ra) {
#line 424
    return ((long )(16 << 9) + 372L);
  }
  {
#line 438
  if ((127 & (int )((scm_cell *)ra)->car) == 55) {
#line 438
    goto case_55;
  }
#line 438
  if ((127 & (int )((scm_cell *)ra)->car) == 47) {
#line 438
    goto case_55;
  }
#line 438
  if ((127 & (int )((scm_cell *)ra)->car) == 53) {
#line 438
    goto case_55;
  }
#line 438
  if ((127 & (int )((scm_cell *)ra)->car) == 45) {
#line 438
    goto case_55;
  }
#line 438
  if ((127 & (int )((scm_cell *)ra)->car) == 79) {
#line 438
    goto case_55;
  }
#line 438
  if ((127 & (int )((scm_cell *)ra)->car) == 37) {
#line 438
    goto case_55;
  }
#line 438
  if ((127 & (int )((scm_cell *)ra)->car) == 77) {
#line 438
    goto case_55;
  }
#line 438
  if ((127 & (int )((scm_cell *)ra)->car) == 71) {
#line 438
    goto case_55;
  }
#line 438
  if ((127 & (int )((scm_cell *)ra)->car) == 13) {
#line 438
    goto case_55;
  }
#line 438
  if ((127 & (int )((scm_cell *)ra)->car) == 21) {
#line 438
    goto case_55;
  }
#line 443
  if ((127 & (int )((scm_cell *)ra)->car) == 127) {
#line 443
    goto case_127;
  }
#line 427
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 428
  return ((long )(16 << 9) + 372L);
  case_55: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_21: /* CIL Label */ 
  {
#line 442
  tmp = scm_cons((SCM )((((unsigned long )((scm_cell *)ra)->car >> 8) << 2) + 2UL),
                 (long )(20 << 9) + 372L);
  }
#line 442
  return (tmp);
  case_127: /* CIL Label */ 
#line 444
  if (! (scm_tc16_array == (long )(65535 & (int )((scm_cell *)ra)->car))) {
#line 445
    return ((long )(16 << 9) + 372L);
  }
#line 446
  k = (size_t )(((scm_cell *)ra)->car >> 17);
#line 447
  s___0 = (scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array ));
  {
#line 448
  while (1) {
    while_continue: /* CIL Label */ ;
#line 448
    tmp___2 = k;
#line 448
    k --;
#line 448
    if (! tmp___2) {
#line 448
      goto while_break;
    }
#line 449
    if ((s___0 + k)->lbnd) {
      {
#line 449
      tmp___0 = scm_cons2(((s___0 + k)->lbnd << 2) + 2L, ((s___0 + k)->ubnd << 2) + 2L,
                          (long )(20 << 9) + 372L);
#line 449
      tmp___1 = tmp___0;
      }
    } else {
#line 449
      tmp___1 = ((1L + (s___0 + k)->ubnd) << 2) + 2L;
    }
    {
#line 449
    res = scm_cons(tmp___1, res);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 452
  return (res);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 457 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
static char s_bad_ind[20]  = 
#line 457
  {      (char )'B',      (char )'a',      (char )'d',      (char )' ', 
        (char )'s',      (char )'c',      (char )'m',      (char )'_', 
        (char )'a',      (char )'r',      (char )'r',      (char )'a', 
        (char )'y',      (char )' ',      (char )'i',      (char )'n', 
        (char )'d',      (char )'e',      (char )'x',      (char )'\000'};
#line 460 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
long scm_aind(SCM ra , SCM args , char *what ) 
{ 
  SCM ind ;
  register long j ;
  register size_t pos ;
  register size_t k ;
  scm_array_dim *s___0 ;
  SCM tmp ;
  SCM tmp___0 ;

  {
#line 468
  pos = ((scm_array *)((scm_cell *)ra)->cdr)->base;
#line 469
  k = (size_t )(((scm_cell *)ra)->car >> 17);
#line 470
  s___0 = (scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array ));
#line 471
  if (2 & (int )args) {
#line 473
    if (! (1UL == k)) {
      {
#line 473
      tmp = scm_makfrom0str((char const   *)what);
#line 473
      scm_wta(tmp, (char *)8, (char *)((void *)0));
      }
    }
#line 474
    return ((long )(pos + (size_t )(((args >> 2) - s___0->lbnd) * s___0->inc)));
  }
  {
#line 476
  while (1) {
    while_continue: /* CIL Label */ ;
#line 476
    if (k) {
#line 476
      if (! (! (6 & (int )args))) {
#line 476
        goto while_break;
      }
    } else {
#line 476
      goto while_break;
    }
#line 478
    ind = ((scm_cell *)args)->car;
#line 479
    args = ((scm_cell *)args)->cdr;
#line 480
    if (! (2 & (int )ind)) {
      {
#line 480
      scm_wta(ind, s_bad_ind, what);
      }
    }
#line 481
    j = ind >> 2;
#line 482
    if (j >= s___0->lbnd) {
#line 482
      if (! (j <= s___0->ubnd)) {
        {
#line 482
        scm_wta(ind, (char *)10, what);
        }
      }
    } else {
      {
#line 482
      scm_wta(ind, (char *)10, what);
      }
    }
#line 483
    pos += (size_t )((j - s___0->lbnd) * s___0->inc);
#line 484
    k --;
#line 485
    s___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 487
  if (0UL == k) {
#line 487
    if (! ((long )(20 << 9) + 372L == args)) {
      {
#line 487
      tmp___0 = scm_makfrom0str((char const   *)what);
#line 487
      scm_wta(tmp___0, (char *)8, (char *)((void *)0));
      }
    }
  } else {
    {
#line 487
    tmp___0 = scm_makfrom0str((char const   *)what);
#line 487
    scm_wta(tmp___0, (char *)8, (char *)((void *)0));
    }
  }
#line 489
  return ((long )pos);
}
}
#line 494 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
SCM scm_make_ra(int ndim ) 
{ 
  SCM ra ;
  char *tmp ;
  char *__cil_tmp4 ;

  {
#line 499
  if (6 & (int )scm_freelist) {
    {
#line 499
    ra = scm_gc_for_newcell();
    }
  } else {
#line 499
    ra = scm_freelist;
#line 499
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 499
    scm_cells_allocated ++;
  }
  {
#line 500
  scm_ints_disabled = 1;
#line 501
  tmp = scm_must_malloc((long )(sizeof(scm_array ) + (unsigned long )ndim * sizeof(scm_array_dim )),
                        (char *)"array");
#line 501
  ((scm_cell *)ra)->cdr = (SCM )tmp;
#line 503
  ((scm_cell *)ra)->car = ((long )ndim << 17) + scm_tc16_array;
#line 504
  ((scm_array *)((scm_cell *)ra)->cdr)->v = scm_sys_protects[3];
#line 505
  scm_ints_disabled = 0;
#line 505
  scm_async_clock --;
  }
#line 505
  if (0U == scm_async_clock) {
    {
#line 505
    scm_async_click();
    }
  }
#line 506
  return (ra);
}
}
#line 509 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
static char s_bad_spec[24]  = 
#line 509
  {      (char )'B',      (char )'a',      (char )'d',      (char )' ', 
        (char )'s',      (char )'c',      (char )'m',      (char )'_', 
        (char )'a',      (char )'r',      (char )'r',      (char )'a', 
        (char )'y',      (char )' ',      (char )'d',      (char )'i', 
        (char )'m',      (char )'e',      (char )'n',      (char )'s', 
        (char )'i',      (char )'o',      (char )'n',      (char )'\000'};
#line 513 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
SCM scm_shap2ra(SCM args , char *what ) 
{ 
  scm_array_dim *s___0 ;
  SCM ra ;
  SCM spec ;
  SCM sp ;
  int ndim ;
  long tmp ;

  {
  {
#line 520
  tmp = scm_ilength(args);
#line 520
  ndim = (int )tmp;
  }
#line 521
  if (! (0 <= ndim)) {
    {
#line 521
    scm_wta(args, s_bad_spec, what);
    }
  }
  {
#line 522
  ra = scm_make_ra(ndim);
#line 523
  ((scm_array *)((scm_cell *)ra)->cdr)->base = (size_t )0;
#line 524
  s___0 = (scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array ));
  }
  {
#line 525
  while (1) {
    while_continue: /* CIL Label */ ;
#line 525
    if (! (! (6 & (int )args))) {
#line 525
      goto while_break;
    }
#line 527
    spec = ((scm_cell *)args)->car;
#line 528
    if (6 & (int )spec) {
#line 531
      if (2 & (int )spec) {
#line 531
        if (! (spec >> 2 >= 0L)) {
          {
#line 531
          scm_wta(spec, s_bad_spec, what);
          }
        }
      } else {
        {
#line 531
        scm_wta(spec, s_bad_spec, what);
        }
      }
#line 532
      s___0->lbnd = 0L;
#line 533
      s___0->ubnd = (spec >> 2) - 1L;
#line 534
      s___0->inc = 1L;
    } else {
#line 538
      if (! (1 & (int )((scm_cell *)spec)->car)) {
#line 538
        if (! (2 & (int )((scm_cell *)spec)->car)) {
          {
#line 538
          scm_wta(spec, s_bad_spec, what);
          }
        }
      } else {
        {
#line 538
        scm_wta(spec, s_bad_spec, what);
        }
      }
#line 539
      s___0->lbnd = ((scm_cell *)spec)->car >> 2;
#line 540
      sp = ((scm_cell *)spec)->cdr;
#line 541
      if (2 & (int )((scm_cell *)sp)->car) {
#line 541
        if (! ((long )(20 << 9) + 372L == ((scm_cell *)sp)->cdr)) {
          {
#line 541
          scm_wta(spec, s_bad_spec, what);
          }
        }
      } else {
        {
#line 541
        scm_wta(spec, s_bad_spec, what);
        }
      }
#line 543
      s___0->ubnd = ((scm_cell *)sp)->car >> 2;
#line 544
      s___0->inc = 1L;
    }
#line 525
    s___0 ++;
#line 525
    args = ((scm_cell *)args)->cdr;
  }
  while_break: /* CIL Label */ ;
  }
#line 547
  return (ra);
}
}
#line 550 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
static char s_dimensions_to_uniform_array[26]  = 
#line 550
  {      (char )'d',      (char )'i',      (char )'m',      (char )'e', 
        (char )'n',      (char )'s',      (char )'i',      (char )'o', 
        (char )'n',      (char )'s',      (char )'-',      (char )'>', 
        (char )'u',      (char )'n',      (char )'i',      (char )'f', 
        (char )'o',      (char )'r',      (char )'m',      (char )'-', 
        (char )'a',      (char )'r',      (char )'r',      (char )'a', 
        (char )'y',      (char )'\000'};
#line 552 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
SCM scm_dimensions_to_uniform_array(SCM dims , SCM prot , SCM fill ) 
{ 
  size_t k ;
  size_t vlen ;
  long rlen ;
  scm_array_dim *s___0 ;
  SCM ra ;
  SCM answer ;
  SCM tmp ;
  long tmp___0 ;
  size_t tmp___1 ;
  long tmp___2 ;
  size_t bit ;
  SCM tmp___3 ;
  SCM tmp___4 ;
  long tmp___5 ;

  {
#line 558
  vlen = (size_t )1;
#line 559
  rlen = 1L;
#line 562
  if (2 & (int )dims) {
#line 563
    if (dims >> 2 < 16777215L) {
      {
#line 566
      answer = scm_make_uve(dims >> 2, prot);
      }
#line 567
      if ((long )(20 << 9) + 372L != fill) {
        {
#line 569
        tmp___0 = scm_ilength(fill);
        }
#line 569
        if (! (1L == tmp___0)) {
          {
#line 569
          tmp = scm_makfrom0str((char const   *)(s_dimensions_to_uniform_array));
#line 569
          scm_wta(tmp, (char *)8, (char *)((void *)0));
          }
        }
        {
#line 572
        scm_array_fill_x(answer, ((scm_cell *)fill)->car);
        }
      } else
#line 574
      if (! (6 & (int )prot)) {
#line 574
        if ((125 & (int )((scm_cell *)prot)->car) == 5) {
          {
#line 575
          scm_array_fill_x(answer, 2L);
          }
        } else {
          {
#line 577
          scm_array_fill_x(answer, prot);
          }
        }
      } else {
        {
#line 577
        scm_array_fill_x(answer, prot);
        }
      }
#line 578
      return (answer);
    } else {
      {
#line 581
      dims = scm_cons(dims, (long )(20 << 9) + 372L);
      }
    }
  }
#line 582
  if (! ((long )(20 << 9) + 372L == dims)) {
#line 582
    if (! (6 & (int )dims)) {
#line 582
      if (! (! (1 & (int )((scm_cell *)dims)->car))) {
        {
#line 582
        scm_wta(dims, (char *)1, s_dimensions_to_uniform_array);
        }
      }
    } else {
      {
#line 582
      scm_wta(dims, (char *)1, s_dimensions_to_uniform_array);
      }
    }
  }
  {
#line 584
  ra = scm_shap2ra(dims, s_dimensions_to_uniform_array);
#line 585
  ((scm_cell *)ra)->car |= 65536L;
#line 586
  s___0 = (scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array ));
#line 587
  k = (size_t )(((scm_cell *)ra)->car >> 17);
  }
  {
#line 588
  while (1) {
    while_continue: /* CIL Label */ ;
#line 588
    tmp___1 = k;
#line 588
    k --;
#line 588
    if (! tmp___1) {
#line 588
      goto while_break;
    }
#line 590
    if (rlen > 0L) {
#line 590
      (s___0 + k)->inc = rlen;
    } else {
#line 590
      (s___0 + k)->inc = 0L;
    }
#line 591
    rlen = (((s___0 + k)->ubnd - (s___0 + k)->lbnd) + 1L) * (s___0 + k)->inc;
#line 592
    vlen *= (size_t )(((s___0 + k)->ubnd - (s___0 + k)->lbnd) + 1L);
  }
  while_break: /* CIL Label */ ;
  }
#line 594
  if (rlen < 16777215L) {
#line 595
    if (rlen > 0L) {
#line 595
      tmp___2 = rlen;
    } else {
#line 595
      tmp___2 = 0L;
    }
    {
#line 595
    ((scm_array *)((scm_cell *)ra)->cdr)->v = scm_make_uve(tmp___2, prot);
    }
  } else {
    {
#line 599
    tmp___3 = scm_make_uve(0L, prot);
    }
    {
#line 604
    if ((127 & (int )((scm_cell *)tmp___3)->car) == 71) {
#line 604
      goto case_71;
    }
#line 607
    if ((127 & (int )((scm_cell *)tmp___3)->car) == 21) {
#line 607
      goto case_21;
    }
#line 610
    if ((127 & (int )((scm_cell *)tmp___3)->car) == 45) {
#line 610
      goto case_45;
    }
#line 613
    if ((127 & (int )((scm_cell *)tmp___3)->car) == 47) {
#line 613
      goto case_47;
    }
#line 616
    if ((127 & (int )((scm_cell *)tmp___3)->car) == 53) {
#line 616
      goto case_53;
    }
#line 601
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 602
    bit = (8UL * sizeof(long )) / sizeof(char );
#line 603
    goto switch_break;
    case_71: /* CIL Label */ 
#line 605
    bit = (size_t )1;
#line 606
    goto switch_break;
    case_21: /* CIL Label */ 
#line 608
    bit = (size_t )8;
#line 609
    goto switch_break;
    case_45: /* CIL Label */ 
#line 611
    bit = (sizeof(float ) * 8UL) / sizeof(char );
#line 612
    goto switch_break;
    case_47: /* CIL Label */ 
#line 614
    bit = (sizeof(double ) * 8UL) / sizeof(char );
#line 615
    goto switch_break;
    case_53: /* CIL Label */ 
#line 617
    bit = ((2UL * sizeof(double )) * 8UL) / sizeof(char );
#line 618
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 620
    ((scm_array *)((scm_cell *)ra)->cdr)->base = (((8UL * sizeof(long )) / sizeof(char ) + bit) - 1UL) / bit;
#line 621
    rlen = (long )((size_t )rlen + ((scm_array *)((scm_cell *)ra)->cdr)->base);
#line 622
    ((scm_array *)((scm_cell *)ra)->cdr)->v = scm_make_uve(rlen, prot);
#line 623
    *((SCM *)((scm_cell *)((scm_array *)((scm_cell *)ra)->cdr)->v)->cdr) = rlen;
    }
  }
#line 625
  if ((long )(20 << 9) + 372L != fill) {
    {
#line 627
    tmp___5 = scm_ilength(fill);
    }
#line 627
    if (! (1L == tmp___5)) {
      {
#line 627
      tmp___4 = scm_makfrom0str((char const   *)(s_dimensions_to_uniform_array));
#line 627
      scm_wta(tmp___4, (char *)8, (char *)((void *)0));
      }
    }
    {
#line 630
    scm_array_fill_x(ra, ((scm_cell *)fill)->car);
    }
  } else
#line 632
  if (! (6 & (int )prot)) {
#line 632
    if ((125 & (int )((scm_cell *)prot)->car) == 5) {
      {
#line 633
      scm_array_fill_x(ra, 2L);
      }
    } else {
      {
#line 635
      scm_array_fill_x(ra, prot);
      }
    }
  } else {
    {
#line 635
    scm_array_fill_x(ra, prot);
    }
  }
#line 636
  if (1UL == (size_t )(((scm_cell *)ra)->car >> 17)) {
#line 636
    if (0UL == ((scm_array *)((scm_cell *)ra)->cdr)->base) {
#line 637
      if (s___0->ubnd < s___0->lbnd) {
#line 638
        return (((scm_array *)((scm_cell *)ra)->cdr)->v);
      } else
#line 637
      if (0L == s___0->lbnd) {
#line 637
        if (1L == s___0->inc) {
#line 638
          return (((scm_array *)((scm_cell *)ra)->cdr)->v);
        }
      }
    }
  }
#line 639
  return (ra);
}
}
#line 643 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
void scm_ra_set_contp(SCM ra ) 
{ 
  size_t k ;
  long inc ;
  size_t tmp ;

  {
#line 647
  k = (size_t )(((scm_cell *)ra)->car >> 17);
#line 648
  if (k) {
#line 650
    inc = ((scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array )) + (k - 1UL))->inc;
    {
#line 651
    while (1) {
      while_continue: /* CIL Label */ ;
#line 651
      tmp = k;
#line 651
      k --;
#line 651
      if (! tmp) {
#line 651
        goto while_break;
      }
#line 653
      if (inc != ((scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array )) + k)->inc) {
#line 655
        ((scm_cell *)ra)->car &= -65537L;
#line 656
        return;
      }
#line 658
      inc *= (((scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array )) + k)->ubnd - ((scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array )) + k)->lbnd) + 1L;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 662
  ((scm_cell *)ra)->car |= 65536L;
#line 663
  return;
}
}
#line 666 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
static char s_make_shared_array[18]  = 
#line 666
  {      (char )'m',      (char )'a',      (char )'k',      (char )'e', 
        (char )'-',      (char )'s',      (char )'h',      (char )'a', 
        (char )'r',      (char )'e',      (char )'d',      (char )'-', 
        (char )'a',      (char )'r',      (char )'r',      (char )'a', 
        (char )'y',      (char )'\000'};
#line 668 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
SCM scm_make_shared_array(SCM oldra , SCM mapfunc , SCM dims ) 
{ 
  SCM ra ;
  SCM inds ;
  SCM indptr ;
  SCM imap ;
  size_t i ;
  size_t k ;
  long old_min ;
  long new_min ;
  long old_max ;
  long new_max ;
  scm_array_dim *s___0 ;
  SCM tmp ;
  SCM tmp___0 ;
  size_t tmp___1 ;
  SCM tmp___2 ;
  SCM tmp___3 ;
  SCM tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  SCM tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  size_t tmp___10 ;
  SCM tmp___11 ;
  SCM tmp___12 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
  {
#line 680
  tmp = scm_procedure_p(mapfunc);
  }
#line 680
  if (! ((long )(17 << 9) + 372L == tmp)) {
    {
#line 680
    scm_wta(mapfunc, (char *)2, s_make_shared_array);
    }
  }
#line 681
  if (! (6 & (int )oldra)) {
    {
#line 681
    tmp___0 = scm_array_p(oldra, (long )(18 << 9) + 372L);
    }
#line 681
    if (! ((long )(16 << 9) + 372L != tmp___0)) {
      {
#line 681
      scm_wta(oldra, (char *)1, s_make_shared_array);
      }
    }
  } else {
    {
#line 681
    scm_wta(oldra, (char *)1, s_make_shared_array);
    }
  }
  {
#line 682
  ra = scm_shap2ra(dims, s_make_shared_array);
  }
#line 683
  if (scm_tc16_array == (long )(65535 & (int )((scm_cell *)oldra)->car)) {
#line 685
    ((scm_array *)((scm_cell *)ra)->cdr)->v = ((scm_array *)((scm_cell *)oldra)->cdr)->v;
#line 686
    old_max = (long )((scm_array *)((scm_cell *)oldra)->cdr)->base;
#line 686
    old_min = old_max;
#line 687
    s___0 = (scm_array_dim *)((char *)((scm_cell *)oldra)->cdr + sizeof(scm_array ));
#line 688
    k = (size_t )(((scm_cell *)oldra)->car >> 17);
    {
#line 689
    while (1) {
      while_continue: /* CIL Label */ ;
#line 689
      tmp___1 = k;
#line 689
      k --;
#line 689
      if (! tmp___1) {
#line 689
        goto while_break;
      }
#line 691
      if ((s___0 + k)->inc > 0L) {
#line 692
        old_max += ((s___0 + k)->ubnd - (s___0 + k)->lbnd) * (s___0 + k)->inc;
      } else {
#line 694
        old_min += ((s___0 + k)->ubnd - (s___0 + k)->lbnd) * (s___0 + k)->inc;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 699
    ((scm_array *)((scm_cell *)ra)->cdr)->v = oldra;
#line 700
    old_min = 0L;
#line 701
    old_max = (long )((unsigned long )((scm_cell *)oldra)->car >> 8) - 1L;
  }
#line 703
  inds = (long )(20 << 9) + 372L;
#line 704
  s___0 = (scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array ));
#line 705
  k = (size_t )0;
  {
#line 705
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 705
    if (! (k < (size_t )(((scm_cell *)ra)->car >> 17))) {
#line 705
      goto while_break___0;
    }
    {
#line 707
    inds = scm_cons(((s___0 + k)->lbnd << 2) + 2L, inds);
    }
#line 708
    if ((s___0 + k)->ubnd < (s___0 + k)->lbnd) {
#line 710
      if (1UL == (size_t )(((scm_cell *)ra)->car >> 17)) {
        {
#line 711
        tmp___2 = scm_array_prototype(ra);
#line 711
        ra = scm_make_uve(0L, tmp___2);
        }
      } else {
        {
#line 713
        tmp___3 = scm_array_prototype(ra);
#line 713
        ((scm_array *)((scm_cell *)ra)->cdr)->v = scm_make_uve(0L, tmp___3);
        }
      }
#line 714
      return (ra);
    }
#line 705
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 717
  tmp___4 = scm_list_reverse(inds);
#line 717
  imap = scm_apply(mapfunc, tmp___4, (long )(20 << 9) + 372L);
  }
#line 718
  if (scm_tc16_array == (long )(65535 & (int )((scm_cell *)oldra)->car)) {
    {
#line 719
    tmp___5 = scm_aind(oldra, imap, s_make_shared_array);
#line 719
    i = (size_t )tmp___5;
    }
  } else {
#line 722
    if (! (2 & (int )imap)) {
      {
#line 725
      tmp___6 = scm_ilength(imap);
      }
#line 725
      if (1L == tmp___6) {
#line 725
        if (! (2 & (int )((scm_cell *)imap)->car)) {
          {
#line 725
          scm_wta(imap, s_bad_ind, s_make_shared_array);
          }
        }
      } else {
        {
#line 725
        scm_wta(imap, s_bad_ind, s_make_shared_array);
        }
      }
#line 727
      imap = ((scm_cell *)imap)->car;
    }
#line 729
    i = (size_t )(imap >> 2);
  }
#line 731
  new_max = (long )i;
#line 731
  new_min = new_max;
#line 731
  ((scm_array *)((scm_cell *)ra)->cdr)->base = (size_t )new_min;
#line 732
  indptr = inds;
#line 733
  k = (size_t )(((scm_cell *)ra)->car >> 17);
  {
#line 734
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 734
    tmp___10 = k;
#line 734
    k --;
#line 734
    if (! tmp___10) {
#line 734
      goto while_break___1;
    }
#line 736
    if ((s___0 + k)->ubnd > (s___0 + k)->lbnd) {
      {
#line 738
      ((scm_cell *)indptr)->car = (((((scm_cell *)indptr)->car >> 2) + 1L) << 2) + 2L;
#line 739
      tmp___7 = scm_reverse(inds);
#line 739
      imap = scm_apply(mapfunc, tmp___7, (long )(20 << 9) + 372L);
      }
#line 740
      if (scm_tc16_array == (long )(65535 & (int )((scm_cell *)oldra)->car)) {
        {
#line 742
        tmp___8 = scm_aind(oldra, imap, s_make_shared_array);
#line 742
        (s___0 + k)->inc = (long )((size_t )tmp___8 - i);
        }
      } else {
#line 745
        if (! (2 & (int )imap)) {
          {
#line 748
          tmp___9 = scm_ilength(imap);
          }
#line 748
          if (1L == tmp___9) {
#line 748
            if (! (2 & (int )((scm_cell *)imap)->car)) {
              {
#line 748
              scm_wta(imap, s_bad_ind, s_make_shared_array);
              }
            }
          } else {
            {
#line 748
            scm_wta(imap, s_bad_ind, s_make_shared_array);
            }
          }
#line 750
          imap = ((scm_cell *)imap)->car;
        }
#line 752
        (s___0 + k)->inc = (long )((size_t )(imap >> 2) - i);
      }
#line 754
      i += (size_t )(s___0 + k)->inc;
#line 755
      if ((s___0 + k)->inc > 0L) {
#line 756
        new_max += ((s___0 + k)->ubnd - (s___0 + k)->lbnd) * (s___0 + k)->inc;
      } else {
#line 758
        new_min += ((s___0 + k)->ubnd - (s___0 + k)->lbnd) * (s___0 + k)->inc;
      }
    } else {
#line 761
      (s___0 + k)->inc = (new_max - new_min) + 1L;
    }
#line 762
    indptr = ((scm_cell *)indptr)->cdr;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 764
  if (old_min <= new_min) {
#line 764
    if (! (old_max >= new_max)) {
      {
#line 764
      scm_wta((long )(18 << 9) + 372L, (char *)"mapping out of range", s_make_shared_array);
      }
    }
  } else {
    {
#line 764
    scm_wta((long )(18 << 9) + 372L, (char *)"mapping out of range", s_make_shared_array);
    }
  }
#line 766
  if (1UL == (size_t )(((scm_cell *)ra)->car >> 17)) {
#line 766
    if (0UL == ((scm_array *)((scm_cell *)ra)->cdr)->base) {
#line 768
      if (1L == s___0->inc) {
#line 768
        if (0L == s___0->lbnd) {
#line 768
          if ((unsigned long )((scm_cell *)((scm_array *)((scm_cell *)ra)->cdr)->v)->car >> 8 == (unsigned long )(1L + s___0->ubnd)) {
#line 770
            return (((scm_array *)((scm_cell *)ra)->cdr)->v);
          }
        }
      }
#line 771
      if (s___0->ubnd < s___0->lbnd) {
        {
#line 772
        tmp___11 = scm_array_prototype(ra);
#line 772
        tmp___12 = scm_make_uve(0L, tmp___11);
        }
#line 772
        return (tmp___12);
      }
    }
  }
  {
#line 774
  scm_ra_set_contp(ra);
  }
#line 775
  return (ra);
}
}
#line 780 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
static char s_transpose_array[16]  = 
#line 780
  {      (char )'t',      (char )'r',      (char )'a',      (char )'n', 
        (char )'s',      (char )'p',      (char )'o',      (char )'s', 
        (char )'e',      (char )'-',      (char )'a',      (char )'r', 
        (char )'r',      (char )'a',      (char )'y',      (char )'\000'};
#line 782 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
SCM scm_transpose_array(SCM args ) 
{ 
  SCM ra ;
  SCM res ;
  SCM vargs ;
  SCM *ve ;
  scm_array_dim *s___0 ;
  scm_array_dim *r ;
  int ndim ;
  int i ;
  int k ;
  SCM tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp16 ;

  {
#line 786
  ve = & vargs;
#line 789
  if (! ((long )(20 << 9) + 372L != args)) {
    {
#line 789
    tmp = scm_makfrom0str((char const   *)(s_transpose_array));
#line 789
    scm_wta(tmp, (char *)8, (char *)((void *)0));
    }
  }
#line 791
  ra = ((scm_cell *)args)->car;
#line 792
  if (! (! (6 & (int )ra))) {
    {
#line 792
    scm_wta(ra, (char *)1, s_transpose_array);
    }
  }
#line 793
  args = ((scm_cell *)args)->cdr;
  {
#line 806
  if ((127 & (int )((scm_cell *)ra)->car) == 55) {
#line 806
    goto case_55;
  }
#line 806
  if ((127 & (int )((scm_cell *)ra)->car) == 53) {
#line 806
    goto case_55;
  }
#line 806
  if ((127 & (int )((scm_cell *)ra)->car) == 47) {
#line 806
    goto case_55;
  }
#line 806
  if ((127 & (int )((scm_cell *)ra)->car) == 45) {
#line 806
    goto case_55;
  }
#line 806
  if ((127 & (int )((scm_cell *)ra)->car) == 79) {
#line 806
    goto case_55;
  }
#line 806
  if ((127 & (int )((scm_cell *)ra)->car) == 37) {
#line 806
    goto case_55;
  }
#line 806
  if ((127 & (int )((scm_cell *)ra)->car) == 77) {
#line 806
    goto case_55;
  }
#line 806
  if ((127 & (int )((scm_cell *)ra)->car) == 21) {
#line 806
    goto case_55;
  }
#line 806
  if ((127 & (int )((scm_cell *)ra)->car) == 71) {
#line 806
    goto case_55;
  }
#line 817
  if ((127 & (int )((scm_cell *)ra)->car) == 127) {
#line 817
    goto case_127;
  }
#line 796
  goto badarg;
  badarg: 
  switch_default: /* CIL Label */ 
  {
#line 797
  scm_wta(ra, (char *)0, s_transpose_array);
  }
  case_55: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_21: /* CIL Label */ 
  case_71: /* CIL Label */ 
#line 810
  if (! (6 & (int )args)) {
#line 810
    if (! ((long )(20 << 9) + 372L == ((scm_cell *)args)->cdr)) {
      {
#line 810
      tmp___0 = scm_makfrom0str((char const   *)(s_transpose_array));
#line 810
      scm_wta(tmp___0, (char *)8, (char *)((void *)0));
      }
    }
  } else {
    {
#line 810
    tmp___0 = scm_makfrom0str((char const   *)(s_transpose_array));
#line 810
    scm_wta(tmp___0, (char *)8, (char *)((void *)0));
    }
  }
#line 812
  if (! (2 & (int )((scm_cell *)args)->car)) {
    {
#line 812
    scm_wta(((scm_cell *)args)->car, (char *)2, s_transpose_array);
    }
  }
#line 814
  if (! (2L == ((scm_cell *)args)->car)) {
    {
#line 814
    scm_wta(((scm_cell *)args)->car, (char *)10, s_transpose_array);
    }
  }
#line 816
  return (ra);
  case_127: /* CIL Label */ 
#line 818
  if (! (scm_tc16_array == (long )(65535 & (int )((scm_cell *)ra)->car))) {
#line 818
    goto badarg;
  }
  {
#line 819
  vargs = scm_vector(args);
  }
#line 820
  if (! ((unsigned long )((scm_cell *)vargs)->car >> 8 == (size_t )(((scm_cell *)ra)->car >> 17))) {
    {
#line 820
    tmp___1 = scm_makfrom0str((char const   *)(s_transpose_array));
#line 820
    scm_wta(tmp___1, (char *)8, (char *)((void *)0));
    }
  }
#line 822
  ve = (SCM *)((scm_cell *)vargs)->cdr;
#line 823
  ndim = 0;
#line 824
  k = 0;
  {
#line 824
  while (1) {
    while_continue: /* CIL Label */ ;
#line 824
    if (! ((size_t )k < (size_t )(((scm_cell *)ra)->car >> 17))) {
#line 824
      goto while_break;
    }
#line 826
    i = (int )(*(ve + k) >> 2);
#line 827
    if (2 & (int )*(ve + k)) {
#line 827
      if (i >= 0) {
#line 827
        if (! ((size_t )i < (size_t )(((scm_cell *)ra)->car >> 17))) {
          {
#line 827
          scm_wta(*(ve + k), (char *)2, s_transpose_array);
          }
        }
      } else {
        {
#line 827
        scm_wta(*(ve + k), (char *)2, s_transpose_array);
        }
      }
    } else {
      {
#line 827
      scm_wta(*(ve + k), (char *)2, s_transpose_array);
      }
    }
#line 829
    if (ndim < i) {
#line 830
      ndim = i;
    }
#line 824
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 832
  ndim ++;
#line 833
  res = scm_make_ra(ndim);
#line 834
  ((scm_array *)((scm_cell *)res)->cdr)->v = ((scm_array *)((scm_cell *)ra)->cdr)->v;
#line 835
  ((scm_array *)((scm_cell *)res)->cdr)->base = ((scm_array *)((scm_cell *)ra)->cdr)->base;
#line 836
  k = ndim;
  }
  {
#line 836
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 836
    tmp___2 = k;
#line 836
    k --;
#line 836
    if (! tmp___2) {
#line 836
      goto while_break___0;
    }
#line 838
    ((scm_array_dim *)((char *)((scm_cell *)res)->cdr + sizeof(scm_array )) + k)->lbnd = 0L;
#line 839
    ((scm_array_dim *)((char *)((scm_cell *)res)->cdr + sizeof(scm_array )) + k)->ubnd = -1L;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 841
  k = (int )((size_t )(((scm_cell *)ra)->car >> 17));
  {
#line 841
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 841
    tmp___3 = k;
#line 841
    k --;
#line 841
    if (! tmp___3) {
#line 841
      goto while_break___1;
    }
#line 843
    i = (int )(*(ve + k) >> 2);
#line 844
    s___0 = (scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array )) + k;
#line 845
    r = (scm_array_dim *)((char *)((scm_cell *)res)->cdr + sizeof(scm_array )) + i;
#line 846
    if (r->ubnd < r->lbnd) {
#line 848
      r->lbnd = s___0->lbnd;
#line 849
      r->ubnd = s___0->ubnd;
#line 850
      r->inc = s___0->inc;
#line 851
      ndim --;
    } else {
#line 855
      if (r->ubnd > s___0->ubnd) {
#line 856
        r->ubnd = s___0->ubnd;
      }
#line 857
      if (r->lbnd < s___0->lbnd) {
#line 859
        ((scm_array *)((scm_cell *)res)->cdr)->base += (size_t )((s___0->lbnd - r->lbnd) * r->inc);
#line 860
        r->lbnd = s___0->lbnd;
      }
#line 862
      r->inc += s___0->inc;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 865
  if (! (ndim <= 0)) {
    {
#line 865
    scm_wta(args, (char *)"bad argument scm_list", s_transpose_array);
    }
  }
  {
#line 866
  scm_ra_set_contp(res);
  }
#line 867
  return (res);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 872 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
static char s_enclose_array[14]  = 
#line 872
  {      (char )'e',      (char )'n',      (char )'c',      (char )'l', 
        (char )'o',      (char )'s',      (char )'e',      (char )'-', 
        (char )'a',      (char )'r',      (char )'r',      (char )'a', 
        (char )'y',      (char )'\000'};
#line 874 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
SCM scm_enclose_array(SCM axes ) 
{ 
  SCM axv ;
  SCM ra ;
  SCM res ;
  SCM ra_inr ;
  scm_array_dim vdim ;
  scm_array_dim *s___0 ;
  int ndim ;
  int j ;
  int k ;
  int ninr ;
  int noutr ;
  SCM tmp ;
  size_t tmp___0 ;
  long tmp___1 ;
  SCM tmp___2 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 879
  s___0 = & vdim;
#line 881
  if (! (! (6 & (int )axes))) {
    {
#line 881
    tmp = scm_makfrom0str((char const   *)(s_enclose_array));
#line 881
    scm_wta(tmp, (char *)8, (char *)((void *)0));
    }
  }
#line 883
  ra = ((scm_cell *)axes)->car;
#line 884
  axes = ((scm_cell *)axes)->cdr;
#line 885
  if ((long )(20 << 9) + 372L == axes) {
#line 887
    if (scm_tc16_array == (long )(65535 & (int )((scm_cell *)ra)->car)) {
#line 887
      tmp___0 = (((size_t )(((scm_cell *)ra)->car >> 17) - 1UL) << 2) + 2UL;
    } else {
#line 887
      tmp___0 = (size_t )((SCM )2);
    }
    {
#line 887
    axes = scm_cons((SCM )tmp___0, (long )(20 << 9) + 372L);
    }
  }
  {
#line 888
  tmp___1 = scm_ilength(axes);
#line 888
  ninr = (int )tmp___1;
#line 889
  ra_inr = scm_make_ra(ninr);
  }
#line 890
  if (! (! (6 & (int )ra))) {
#line 890
    goto badarg1;
  }
  {
#line 905
  if ((127 & (int )((scm_cell *)ra)->car) == 55) {
#line 905
    goto case_55;
  }
#line 905
  if ((127 & (int )((scm_cell *)ra)->car) == 13) {
#line 905
    goto case_55;
  }
#line 905
  if ((127 & (int )((scm_cell *)ra)->car) == 53) {
#line 905
    goto case_55;
  }
#line 905
  if ((127 & (int )((scm_cell *)ra)->car) == 47) {
#line 905
    goto case_55;
  }
#line 905
  if ((127 & (int )((scm_cell *)ra)->car) == 45) {
#line 905
    goto case_55;
  }
#line 905
  if ((127 & (int )((scm_cell *)ra)->car) == 79) {
#line 905
    goto case_55;
  }
#line 905
  if ((127 & (int )((scm_cell *)ra)->car) == 37) {
#line 905
    goto case_55;
  }
#line 905
  if ((127 & (int )((scm_cell *)ra)->car) == 77) {
#line 905
    goto case_55;
  }
#line 905
  if ((127 & (int )((scm_cell *)ra)->car) == 71) {
#line 905
    goto case_55;
  }
#line 905
  if ((127 & (int )((scm_cell *)ra)->car) == 21) {
#line 905
    goto case_55;
  }
#line 916
  if ((127 & (int )((scm_cell *)ra)->car) == 127) {
#line 916
    goto case_127;
  }
#line 894
  goto badarg1;
  badarg1: 
  switch_default: /* CIL Label */ 
  {
#line 895
  scm_wta(ra, (char *)1, s_enclose_array);
  }
  case_55: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_21: /* CIL Label */ 
#line 909
  s___0->lbnd = 0L;
#line 910
  s___0->ubnd = (long )(((unsigned long )((scm_cell *)ra)->car >> 8) - 1UL);
#line 911
  s___0->inc = 1L;
#line 912
  ((scm_array *)((scm_cell *)ra_inr)->cdr)->v = ra;
#line 913
  ((scm_array *)((scm_cell *)ra_inr)->cdr)->base = (size_t )0;
#line 914
  ndim = 1;
#line 915
  goto switch_break;
  case_127: /* CIL Label */ 
#line 917
  if (! (scm_tc16_array == (long )(65535 & (int )((scm_cell *)ra)->car))) {
#line 917
    goto badarg1;
  }
#line 918
  s___0 = (scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array ));
#line 919
  ((scm_array *)((scm_cell *)ra_inr)->cdr)->v = ((scm_array *)((scm_cell *)ra)->cdr)->v;
#line 920
  ((scm_array *)((scm_cell *)ra_inr)->cdr)->base = ((scm_array *)((scm_cell *)ra)->cdr)->base;
#line 921
  ndim = (int )((size_t )(((scm_cell *)ra)->car >> 17));
#line 922
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 924
  noutr = ndim - ninr;
#line 925
  axv = scm_make_string((long )(ndim << 2) + 2L, (SCM )244);
  }
#line 926
  if (0 <= noutr) {
#line 926
    if (! (0 <= ninr)) {
      {
#line 926
      tmp___2 = scm_makfrom0str((char const   *)(s_enclose_array));
#line 926
      scm_wta(tmp___2, (char *)8, (char *)((void *)0));
      }
    }
  } else {
    {
#line 926
    tmp___2 = scm_makfrom0str((char const   *)(s_enclose_array));
#line 926
    scm_wta(tmp___2, (char *)8, (char *)((void *)0));
    }
  }
  {
#line 928
  res = scm_make_ra(noutr);
#line 929
  ((scm_array *)((scm_cell *)res)->cdr)->base = ((scm_array *)((scm_cell *)ra_inr)->cdr)->base;
#line 930
  ((scm_array *)((scm_cell *)res)->cdr)->v = ra_inr;
#line 931
  k = 0;
  }
  {
#line 931
  while (1) {
    while_continue: /* CIL Label */ ;
#line 931
    if (! (k < ninr)) {
#line 931
      goto while_break;
    }
#line 933
    if (! (2 & (int )((scm_cell *)axes)->car)) {
      {
#line 933
      scm_wta(((scm_cell *)axes)->car, (char *)"bad axis", s_enclose_array);
      }
    }
#line 934
    j = (int )(((scm_cell *)axes)->car >> 2);
#line 935
    ((scm_array_dim *)((char *)((scm_cell *)ra_inr)->cdr + sizeof(scm_array )) + k)->lbnd = (s___0 + j)->lbnd;
#line 936
    ((scm_array_dim *)((char *)((scm_cell *)ra_inr)->cdr + sizeof(scm_array )) + k)->ubnd = (s___0 + j)->ubnd;
#line 937
    ((scm_array_dim *)((char *)((scm_cell *)ra_inr)->cdr + sizeof(scm_array )) + k)->inc = (s___0 + j)->inc;
#line 938
    *((char *)((scm_cell *)axv)->cdr + j) = (char)1;
#line 931
    k ++;
#line 931
    axes = ((scm_cell *)axes)->cdr;
  }
  while_break: /* CIL Label */ ;
  }
#line 940
  j = 0;
#line 940
  k = 0;
  {
#line 940
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 940
    if (! (k < noutr)) {
#line 940
      goto while_break___0;
    }
    {
#line 942
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 942
      if (! *((char *)((scm_cell *)axv)->cdr + j)) {
#line 942
        goto while_break___1;
      }
#line 943
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 944
    ((scm_array_dim *)((char *)((scm_cell *)res)->cdr + sizeof(scm_array )) + k)->lbnd = (s___0 + j)->lbnd;
#line 945
    ((scm_array_dim *)((char *)((scm_cell *)res)->cdr + sizeof(scm_array )) + k)->ubnd = (s___0 + j)->ubnd;
#line 946
    ((scm_array_dim *)((char *)((scm_cell *)res)->cdr + sizeof(scm_array )) + k)->inc = (s___0 + j)->inc;
#line 940
    k ++;
#line 940
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 948
  scm_ra_set_contp(ra_inr);
#line 949
  scm_ra_set_contp(res);
  }
#line 950
  return (res);
}
}
#line 955 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
static char s_array_in_bounds_p[17]  = 
#line 955
  {      (char )'a',      (char )'r',      (char )'r',      (char )'a', 
        (char )'y',      (char )'-',      (char )'i',      (char )'n', 
        (char )'-',      (char )'b',      (char )'o',      (char )'u', 
        (char )'n',      (char )'d',      (char )'s',      (char )'?', 
        (char )'\000'};
#line 957 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
SCM scm_array_in_bounds_p(SCM args ) 
{ 
  SCM v ;
  SCM ind ;
  long pos ;
  register size_t k ;
  register long j ;
  scm_array_dim *s___0 ;
  SCM tmp ;
  SCM tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 961
  ind = (long )(20 << 9) + 372L;
#line 962
  pos = 0L;
#line 966
  if (! (! (6 & (int )args))) {
    {
#line 966
    tmp = scm_makfrom0str((char const   *)(s_array_in_bounds_p));
#line 966
    scm_wta(tmp, (char *)8, (char *)((void *)0));
    }
  }
#line 968
  v = ((scm_cell *)args)->car;
#line 969
  args = ((scm_cell *)args)->cdr;
#line 970
  if (! (! (6 & (int )v))) {
#line 970
    goto badarg1;
  }
#line 971
  if (! (6 & (int )args)) {
#line 974
    ind = ((scm_cell *)args)->car;
#line 975
    args = ((scm_cell *)args)->cdr;
#line 976
    if (! (2 & (int )ind)) {
      {
#line 976
      scm_wta(ind, (char *)2, s_array_in_bounds_p);
      }
    }
#line 977
    pos = ind >> 2;
  }
  tail: 
  {
#line 986
  if ((127 & (int )((scm_cell *)v)->car) == 127) {
#line 986
    goto case_127;
  }
#line 1027
  if ((127 & (int )((scm_cell *)v)->car) == 13) {
#line 1027
    goto case_13;
  }
#line 1027
  if ((127 & (int )((scm_cell *)v)->car) == 55) {
#line 1027
    goto case_13;
  }
#line 1027
  if ((127 & (int )((scm_cell *)v)->car) == 53) {
#line 1027
    goto case_13;
  }
#line 1027
  if ((127 & (int )((scm_cell *)v)->car) == 47) {
#line 1027
    goto case_13;
  }
#line 1027
  if ((127 & (int )((scm_cell *)v)->car) == 45) {
#line 1027
    goto case_13;
  }
#line 1027
  if ((127 & (int )((scm_cell *)v)->car) == 79) {
#line 1027
    goto case_13;
  }
#line 1027
  if ((127 & (int )((scm_cell *)v)->car) == 37) {
#line 1027
    goto case_13;
  }
#line 1027
  if ((127 & (int )((scm_cell *)v)->car) == 77) {
#line 1027
    goto case_13;
  }
#line 1027
  if ((127 & (int )((scm_cell *)v)->car) == 21) {
#line 1027
    goto case_13;
  }
#line 1027
  if ((127 & (int )((scm_cell *)v)->car) == 71) {
#line 1027
    goto case_13;
  }
#line 983
  goto badarg1;
  badarg1: 
  switch_default: /* CIL Label */ 
  {
#line 984
  scm_wta(v, (char *)1, s_array_in_bounds_p);
  }
  wna: 
  {
#line 985
  tmp___0 = scm_makfrom0str((char const   *)(s_array_in_bounds_p));
#line 985
  scm_wrong_num_args(tmp___0);
  }
  case_127: /* CIL Label */ 
#line 987
  k = (size_t )(((scm_cell *)v)->car >> 17);
#line 988
  s___0 = (scm_array_dim *)((char *)((scm_cell *)v)->cdr + sizeof(scm_array ));
#line 989
  pos = (long )((scm_array *)((scm_cell *)v)->cdr)->base;
#line 990
  if (! k) {
#line 992
    if (! ((long )(20 << 9) + 372L == ind)) {
#line 992
      goto wna;
    }
#line 993
    ind = (SCM )2;
  } else {
    {
#line 996
    while (1) {
      while_continue: /* CIL Label */ ;
#line 998
      j = ind >> 2;
#line 999
      if (j >= s___0->lbnd) {
#line 999
        if (! (j <= s___0->ubnd)) {
#line 999
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 1001
        k --;
#line 1001
        tmp___1 = scm_ilength(args);
        }
#line 1001
        if (! (k == (size_t )tmp___1)) {
#line 1001
          goto wna;
        }
#line 1002
        return ((long )(16 << 9) + 372L);
      }
#line 1004
      pos += (j - s___0->lbnd) * s___0->inc;
#line 1005
      k --;
#line 1005
      if (k) {
#line 1005
        if (! (! (6 & (int )args))) {
#line 1006
          goto while_break;
        }
      } else {
#line 1006
        goto while_break;
      }
#line 1007
      ind = ((scm_cell *)args)->car;
#line 1008
      args = ((scm_cell *)args)->cdr;
#line 1009
      s___0 ++;
#line 1010
      if (! (2 & (int )ind)) {
        {
#line 1010
        scm_wta(ind, s_bad_ind, s_array_in_bounds_p);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1012
  if (! (0UL == k)) {
#line 1012
    goto wna;
  }
#line 1013
  v = ((scm_array *)((scm_cell *)v)->cdr)->v;
#line 1014
  goto tail;
  case_13: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_21: /* CIL Label */ 
  case_71: /* CIL Label */ 
#line 1028
  if ((long )(20 << 9) + 372L == args) {
#line 1028
    if (! (2 & (int )ind)) {
#line 1028
      goto wna;
    }
  } else {
#line 1028
    goto wna;
  }
#line 1029
  if (pos >= 0L) {
#line 1029
    if ((unsigned long )pos < (unsigned long )((scm_cell *)v)->car >> 8) {
#line 1029
      tmp___2 = (long )(17 << 9) + 372L;
    } else {
#line 1029
      tmp___2 = (long )(16 << 9) + 372L;
    }
  } else {
#line 1029
    tmp___2 = (long )(16 << 9) + 372L;
  }
#line 1029
  return (tmp___2);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1034 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
static char s_array_ref[10]  = 
#line 1034
  {      (char )'a',      (char )'r',      (char )'r',      (char )'a', 
        (char )'y',      (char )'-',      (char )'r',      (char )'e', 
        (char )'f',      (char )'\000'};
#line 1035 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
static char s_uniform_vector_ref[19]  = 
#line 1035
  {      (char )'u',      (char )'n',      (char )'i',      (char )'f', 
        (char )'o',      (char )'r',      (char )'m',      (char )'-', 
        (char )'v',      (char )'e',      (char )'c',      (char )'t', 
        (char )'o',      (char )'r',      (char )'-',      (char )'r', 
        (char )'e',      (char )'f',      (char )'\000'};
#line 1037 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
SCM scm_uniform_vector_ref(SCM v , SCM args ) 
{ 
  long pos ;
  SCM tmp ;
  int k ;
  SCM res ;
  SCM tmp___0 ;
  int tmp___1 ;
  SCM tmp___2 ;
  SCM tmp___3 ;
  SCM tmp___4 ;
  SCM tmp___5 ;

  {
#line 1044
  if (6 & (int )v) {
#line 1046
    if (! ((long )(20 << 9) + 372L == args)) {
#line 1046
      goto badarg;
    }
#line 1047
    return (v);
  } else
#line 1049
  if (scm_tc16_array == (long )(65535 & (int )((scm_cell *)v)->car)) {
    {
#line 1051
    pos = scm_aind(v, args, s_uniform_vector_ref);
#line 1052
    v = ((scm_array *)((scm_cell *)v)->cdr)->v;
    }
  } else {
#line 1056
    if (! (6 & (int )args)) {
#line 1059
      if (! (1 & (int )((scm_cell *)args)->car)) {
#line 1059
        if (! (2 & (int )((scm_cell *)args)->car)) {
          {
#line 1059
          scm_wta(args, (char *)2, s_uniform_vector_ref);
          }
        }
      } else {
        {
#line 1059
        scm_wta(args, (char *)2, s_uniform_vector_ref);
        }
      }
#line 1060
      pos = ((scm_cell *)args)->car >> 2;
#line 1061
      if (! ((long )(20 << 9) + 372L == ((scm_cell *)args)->cdr)) {
#line 1061
        goto wna;
      }
    } else {
#line 1065
      if (! (2 & (int )args)) {
        {
#line 1065
        scm_wta(args, (char *)2, s_uniform_vector_ref);
        }
      }
#line 1066
      pos = args >> 2;
    }
#line 1068
    if (pos >= 0L) {
#line 1068
      if (! ((unsigned long )pos < (unsigned long )((scm_cell *)v)->car >> 8)) {
#line 1068
        goto outrng;
      }
    } else {
#line 1068
      goto outrng;
    }
  }
  {
#line 1081
  if ((127 & (int )((scm_cell *)v)->car) == 127) {
#line 1081
    goto case_127;
  }
#line 1095
  if ((127 & (int )((scm_cell *)v)->car) == 71) {
#line 1095
    goto case_71;
  }
#line 1100
  if ((127 & (int )((scm_cell *)v)->car) == 21) {
#line 1100
    goto case_21;
  }
#line 1102
  if ((127 & (int )((scm_cell *)v)->car) == 77) {
#line 1102
    goto case_77;
  }
#line 1109
  if ((127 & (int )((scm_cell *)v)->car) == 37) {
#line 1109
    goto case_37;
  }
#line 1111
  if ((127 & (int )((scm_cell *)v)->car) == 79) {
#line 1111
    goto case_79;
  }
#line 1115
  if ((127 & (int )((scm_cell *)v)->car) == 55) {
#line 1115
    goto case_55;
  }
#line 1127
  if ((127 & (int )((scm_cell *)v)->car) == 47) {
#line 1127
    goto case_47;
  }
#line 1129
  if ((127 & (int )((scm_cell *)v)->car) == 53) {
#line 1129
    goto case_53;
  }
#line 1133
  if ((127 & (int )((scm_cell *)v)->car) == 13) {
#line 1133
    goto case_13;
  }
#line 1073
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1074
  if ((long )(20 << 9) + 372L == args) {
#line 1075
    return (v);
  }
  badarg: 
  {
#line 1077
  scm_wta(v, (char *)1, s_uniform_vector_ref);
#line 1078
  abort();
  }
  outrng: 
  {
#line 1079
  scm_out_of_range(s_uniform_vector_ref, (pos << 2) + 2L);
  }
  wna: 
  {
#line 1080
  tmp = scm_makfrom0str((char const   *)(s_uniform_vector_ref));
#line 1080
  scm_wrong_num_args(tmp);
  }
  case_127: /* CIL Label */ 
  {
#line 1083
  k = (int )((size_t )(((scm_cell *)v)->car >> 17));
#line 1084
  tmp___0 = scm_make_ra(k);
#line 1084
  res = tmp___0;
#line 1085
  ((scm_array *)((scm_cell *)res)->cdr)->v = ((scm_array *)((scm_cell *)v)->cdr)->v;
#line 1086
  ((scm_array *)((scm_cell *)res)->cdr)->base = (size_t )pos;
  }
  {
#line 1087
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1087
    tmp___1 = k;
#line 1087
    k --;
#line 1087
    if (! tmp___1) {
#line 1087
      goto while_break;
    }
#line 1089
    ((scm_array_dim *)((char *)((scm_cell *)res)->cdr + sizeof(scm_array )) + k)->lbnd = ((scm_array_dim *)((char *)((scm_cell *)v)->cdr + sizeof(scm_array )) + k)->lbnd;
#line 1090
    ((scm_array_dim *)((char *)((scm_cell *)res)->cdr + sizeof(scm_array )) + k)->ubnd = ((scm_array_dim *)((char *)((scm_cell *)v)->cdr + sizeof(scm_array )) + k)->ubnd;
#line 1091
    ((scm_array_dim *)((char *)((scm_cell *)res)->cdr + sizeof(scm_array )) + k)->inc = ((scm_array_dim *)((char *)((scm_cell *)v)->cdr + sizeof(scm_array )) + k)->inc;
  }
  while_break: /* CIL Label */ ;
  }
#line 1093
  return (res);
  case_71: /* CIL Label */ 
#line 1096
  if (*((SCM *)((scm_cell *)v)->cdr + (unsigned long )pos / ((8UL * sizeof(long )) / sizeof(char ))) & (1L << (unsigned long )pos % ((8UL * sizeof(long )) / sizeof(char )))) {
#line 1097
    return ((long )(17 << 9) + 372L);
  } else {
#line 1099
    return ((long )(16 << 9) + 372L);
  }
  case_21: /* CIL Label */ 
#line 1101
  return ((SCM )(((int )*((char *)((scm_cell *)v)->cdr + pos) << 8) + 244));
  case_77: /* CIL Label */ 
#line 1103
  return ((long )((int )*((char *)((scm_cell *)v)->cdr + pos) << 2) + 2L);
  case_37: /* CIL Label */ 
  {
#line 1110
  tmp___2 = scm_ulong2num((unsigned long )*((SCM *)((scm_cell *)v)->cdr + pos));
  }
#line 1110
  return (tmp___2);
  case_79: /* CIL Label */ 
  {
#line 1112
  tmp___3 = scm_long2num(*((SCM *)((scm_cell *)v)->cdr + pos));
  }
#line 1112
  return (tmp___3);
  case_55: /* CIL Label */ 
#line 1116
  return ((long )((int )*((short *)((scm_cell *)v)->cdr + pos) << 2) + 2L);
  case_47: /* CIL Label */ 
  {
#line 1128
  tmp___4 = scm_makdbl(*((double *)((scm_cell *)v)->cdr + pos), 0.0);
  }
#line 1128
  return (tmp___4);
  case_53: /* CIL Label */ 
  {
#line 1130
  tmp___5 = scm_makdbl(*((double *)((scm_cell *)v)->cdr + 2L * pos), *((double *)((scm_cell *)v)->cdr + (2L * pos + 1L)));
  }
#line 1130
  return (tmp___5);
  case_13: /* CIL Label */ 
#line 1134
  return (*((SCM *)((scm_cell *)v)->cdr + pos));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1141 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
SCM scm_cvref(SCM v , size_t pos , SCM last ) 
{ 
  SCM tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  SCM tmp___2 ;
  int k ;
  SCM res ;
  SCM tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp12 ;

  {
  {
#line 1152
  if ((127 & (int )((scm_cell *)v)->car) == 71) {
#line 1152
    goto case_71;
  }
#line 1157
  if ((127 & (int )((scm_cell *)v)->car) == 21) {
#line 1157
    goto case_21;
  }
#line 1159
  if ((127 & (int )((scm_cell *)v)->car) == 77) {
#line 1159
    goto case_77;
  }
#line 1166
  if ((127 & (int )((scm_cell *)v)->car) == 37) {
#line 1166
    goto case_37;
  }
#line 1168
  if ((127 & (int )((scm_cell *)v)->car) == 79) {
#line 1168
    goto case_79;
  }
#line 1171
  if ((127 & (int )((scm_cell *)v)->car) == 55) {
#line 1171
    goto case_55;
  }
#line 1187
  if ((127 & (int )((scm_cell *)v)->car) == 47) {
#line 1187
    goto case_47;
  }
#line 1198
  if ((127 & (int )((scm_cell *)v)->car) == 53) {
#line 1198
    goto case_53;
  }
#line 1208
  if ((127 & (int )((scm_cell *)v)->car) == 13) {
#line 1208
    goto case_13;
  }
#line 1210
  if ((127 & (int )((scm_cell *)v)->car) == 127) {
#line 1210
    goto case_127;
  }
#line 1150
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 1151
  scm_wta(v, (char *)1, (char *)"PROGRAMMING ERROR: scm_cvref");
  }
  case_71: /* CIL Label */ 
#line 1153
  if (*((SCM *)((scm_cell *)v)->cdr + pos / ((8UL * sizeof(long )) / sizeof(char ))) & (1L << pos % ((8UL * sizeof(long )) / sizeof(char )))) {
#line 1154
    return ((long )(17 << 9) + 372L);
  } else {
#line 1156
    return ((long )(16 << 9) + 372L);
  }
  case_21: /* CIL Label */ 
#line 1158
  return ((SCM )(((int )*((char *)((scm_cell *)v)->cdr + pos) << 8) + 244));
  case_77: /* CIL Label */ 
#line 1160
  return ((long )((int )*((char *)((scm_cell *)v)->cdr + pos) << 2) + 2L);
  case_37: /* CIL Label */ 
  {
#line 1167
  tmp = scm_ulong2num((unsigned long )*((SCM *)((scm_cell *)v)->cdr + pos));
  }
#line 1167
  return (tmp);
  case_79: /* CIL Label */ 
  {
#line 1169
  tmp___0 = scm_long2num(*((SCM *)((scm_cell *)v)->cdr + pos));
  }
#line 1169
  return (tmp___0);
  case_55: /* CIL Label */ 
#line 1172
  return ((long )((int )*((short *)((scm_cell *)v)->cdr + pos) << 2) + 2L);
  case_47: /* CIL Label */ 
#line 1191
  if (! (6 & (int )last)) {
#line 1191
    if (last != scm_sys_protects[0]) {
#line 1191
      if ((383L | (1L << 16)) == ((scm_cell *)last)->car) {
#line 1194
        *(((scm_dbl *)last)->real) = *((double *)((scm_cell *)v)->cdr + pos);
#line 1195
        return (last);
      }
    }
  }
  {
#line 1197
  tmp___1 = scm_makdbl(*((double *)((scm_cell *)v)->cdr + pos), 0.0);
  }
#line 1197
  return (tmp___1);
  case_53: /* CIL Label */ 
#line 1199
  if (! (6 & (int )last)) {
#line 1199
    if (((383L | (1L << 16)) | (2L << 16)) == ((scm_cell *)last)->car) {
#line 1201
      *(((scm_dbl *)last)->real) = *((double *)((scm_cell *)v)->cdr + 2UL * pos);
#line 1202
      *((double *)((char *)((scm_cell *)last)->cdr + sizeof(double ))) = *((double *)((scm_cell *)v)->cdr + (2UL * pos + 1UL));
#line 1203
      return (last);
    }
  }
  {
#line 1205
  tmp___2 = scm_makdbl(*((double *)((scm_cell *)v)->cdr + 2UL * pos), *((double *)((scm_cell *)v)->cdr + (2UL * pos + 1UL)));
  }
#line 1205
  return (tmp___2);
  case_13: /* CIL Label */ 
#line 1209
  return (*((SCM *)((scm_cell *)v)->cdr + pos));
  case_127: /* CIL Label */ 
  {
#line 1212
  k = (int )((size_t )(((scm_cell *)v)->car >> 17));
#line 1213
  tmp___3 = scm_make_ra(k);
#line 1213
  res = tmp___3;
#line 1214
  ((scm_array *)((scm_cell *)res)->cdr)->v = ((scm_array *)((scm_cell *)v)->cdr)->v;
#line 1215
  ((scm_array *)((scm_cell *)res)->cdr)->base = pos;
  }
  {
#line 1216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1216
    tmp___4 = k;
#line 1216
    k --;
#line 1216
    if (! tmp___4) {
#line 1216
      goto while_break;
    }
#line 1218
    ((scm_array_dim *)((char *)((scm_cell *)res)->cdr + sizeof(scm_array )) + k)->ubnd = ((scm_array_dim *)((char *)((scm_cell *)v)->cdr + sizeof(scm_array )) + k)->ubnd;
#line 1219
    ((scm_array_dim *)((char *)((scm_cell *)res)->cdr + sizeof(scm_array )) + k)->lbnd = ((scm_array_dim *)((char *)((scm_cell *)v)->cdr + sizeof(scm_array )) + k)->lbnd;
#line 1220
    ((scm_array_dim *)((char *)((scm_cell *)res)->cdr + sizeof(scm_array )) + k)->inc = ((scm_array_dim *)((char *)((scm_cell *)v)->cdr + sizeof(scm_array )) + k)->inc;
  }
  while_break: /* CIL Label */ ;
  }
#line 1222
  return (res);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1227 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
static char s_uniform_array_set1_x[20]  = 
#line 1227
  {      (char )'u',      (char )'n',      (char )'i',      (char )'f', 
        (char )'o',      (char )'r',      (char )'m',      (char )'-', 
        (char )'a',      (char )'r',      (char )'r',      (char )'a', 
        (char )'y',      (char )'-',      (char )'s',      (char )'e', 
        (char )'t',      (char )'1',      (char )'!',      (char )'\000'};
#line 1228 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
static char s_array_set_x[11]  = 
#line 1228
  {      (char )'a',      (char )'r',      (char )'r',      (char )'a', 
        (char )'y',      (char )'-',      (char )'s',      (char )'e', 
        (char )'t',      (char )'!',      (char )'\000'};
#line 1230 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
SCM scm_array_set_x(SCM v , SCM obj , SCM args ) 
{ 
  long pos ;
  SCM tmp ;
  unsigned long tmp___0 ;

  {
#line 1237
  if (! (! (6 & (int )v))) {
#line 1237
    goto badarg1;
  }
#line 1238
  if (scm_tc16_array == (long )(65535 & (int )((scm_cell *)v)->car)) {
    {
#line 1240
    pos = scm_aind(v, args, s_array_set_x);
#line 1241
    v = ((scm_array *)((scm_cell *)v)->cdr)->v;
    }
  } else {
#line 1245
    if (! (6 & (int )args)) {
#line 1247
      if (! (1 & (int )((scm_cell *)args)->car)) {
#line 1247
        if (! (2 & (int )((scm_cell *)args)->car)) {
          {
#line 1247
          scm_wta(args, (char *)2, s_array_set_x);
          }
        }
      } else {
        {
#line 1247
        scm_wta(args, (char *)2, s_array_set_x);
        }
      }
#line 1248
      pos = ((scm_cell *)args)->car >> 2;
#line 1249
      if (! ((long )(20 << 9) + 372L == ((scm_cell *)args)->cdr)) {
#line 1249
        goto wna;
      }
    } else {
#line 1253
      if (! (2 & (int )args)) {
        {
#line 1253
        scm_wta(args, (char *)2, s_array_set_x);
        }
      }
#line 1254
      pos = args >> 2;
    }
#line 1256
    if (pos >= 0L) {
#line 1256
      if (! ((unsigned long )pos < (unsigned long )((scm_cell *)v)->car >> 8)) {
#line 1256
        goto outrng;
      }
    } else {
#line 1256
      goto outrng;
    }
  }
  {
#line 1265
  if ((127 & (int )((scm_cell *)v)->car) == 127) {
#line 1265
    goto case_127;
  }
#line 1267
  if ((127 & (int )((scm_cell *)v)->car) == 71) {
#line 1267
    goto case_71;
  }
#line 1275
  if ((127 & (int )((scm_cell *)v)->car) == 21) {
#line 1275
    goto case_21;
  }
#line 1279
  if ((127 & (int )((scm_cell *)v)->car) == 77) {
#line 1279
    goto case_77;
  }
#line 1291
  if ((127 & (int )((scm_cell *)v)->car) == 37) {
#line 1291
    goto case_37;
  }
#line 1293
  if ((127 & (int )((scm_cell *)v)->car) == 79) {
#line 1293
    goto case_79;
  }
#line 1298
  if ((127 & (int )((scm_cell *)v)->car) == 55) {
#line 1298
    goto case_55;
  }
#line 1316
  if ((127 & (int )((scm_cell *)v)->car) == 47) {
#line 1316
    goto case_47;
  }
#line 1320
  if ((127 & (int )((scm_cell *)v)->car) == 53) {
#line 1320
    goto case_53;
  }
#line 1326
  if ((127 & (int )((scm_cell *)v)->car) == 13) {
#line 1326
    goto case_13;
  }
#line 1260
  goto badarg1;
  badarg1: 
  switch_default: /* CIL Label */ 
  {
#line 1261
  scm_wta(v, (char *)1, s_array_set_x);
#line 1262
  abort();
  }
  outrng: 
  {
#line 1263
  scm_out_of_range(s_array_set_x, (pos << 2) + 2L);
  }
  wna: 
  {
#line 1264
  tmp = scm_makfrom0str((char const   *)(s_array_set_x));
#line 1264
  scm_wrong_num_args(tmp);
  }
  case_127: /* CIL Label */ 
#line 1266
  goto badarg1;
  case_71: /* CIL Label */ 
#line 1268
  if ((long )(16 << 9) + 372L == obj) {
#line 1269
    *((SCM *)((scm_cell *)v)->cdr + (unsigned long )pos / ((8UL * sizeof(long )) / sizeof(char ))) &= ~ (1L << (unsigned long )pos % ((8UL * sizeof(long )) / sizeof(char )));
  } else
#line 1270
  if ((long )(17 << 9) + 372L == obj) {
#line 1271
    *((SCM *)((scm_cell *)v)->cdr + (unsigned long )pos / ((8UL * sizeof(long )) / sizeof(char ))) |= 1L << (unsigned long )pos % ((8UL * sizeof(long )) / sizeof(char ));
  } else {
    badarg3: 
    {
#line 1273
    scm_wta(obj, (char *)3, s_array_set_x);
    }
  }
#line 1274
  goto switch_break;
  case_21: /* CIL Label */ 
#line 1276
  if (! (((int )obj & 255) == 244)) {
#line 1276
    goto badarg3;
  }
#line 1277
  *((char *)((scm_cell *)v)->cdr + pos) = (char )((unsigned int )(obj >> 8));
#line 1278
  goto switch_break;
  case_77: /* CIL Label */ 
#line 1280
  if (((int )obj & 255) == 244) {
#line 1281
    obj = (long )((unsigned int )(obj >> 8) << 2) + 2L;
  }
#line 1282
  if (! (2 & (int )obj)) {
#line 1282
    goto badarg3;
  }
#line 1283
  *((char *)((scm_cell *)v)->cdr + pos) = (char )(obj >> 2);
#line 1284
  goto switch_break;
  case_37: /* CIL Label */ 
  {
#line 1292
  tmp___0 = scm_num2ulong(obj, (char *)3, s_array_set_x);
#line 1292
  *((SCM *)((scm_cell *)v)->cdr + pos) = (SCM )tmp___0;
  }
#line 1292
  goto switch_break;
  case_79: /* CIL Label */ 
  {
#line 1294
  *((SCM *)((scm_cell *)v)->cdr + pos) = num2long(obj, (char *)3, s_array_set_x);
  }
#line 1294
  goto switch_break;
#line 1296
  goto switch_break;
  case_55: /* CIL Label */ 
#line 1299
  if (! (2 & (int )obj)) {
#line 1299
    goto badarg3;
  }
#line 1300
  *((short *)((scm_cell *)v)->cdr + pos) = (short )(obj >> 2);
#line 1301
  goto switch_break;
  case_47: /* CIL Label */ 
#line 1317
  if (! (6 & (int )obj)) {
#line 1317
    if (! (((scm_cell *)obj)->car == (383L | (1L << 16)))) {
#line 1317
      goto badarg3;
    }
  } else {
#line 1317
    goto badarg3;
  }
#line 1318
  *((double *)((scm_cell *)v)->cdr + pos) = *(((scm_dbl *)obj)->real);
#line 1319
  goto switch_break;
  case_53: /* CIL Label */ 
#line 1321
  if (! (6 & (int )obj)) {
#line 1321
    if (! ((65535 & (int )((scm_cell *)obj)->car) == 383)) {
#line 1321
      goto badarg3;
    }
  } else {
#line 1321
    goto badarg3;
  }
#line 1322
  *((double *)((scm_cell *)v)->cdr + 2L * pos) = *(((scm_dbl *)obj)->real);
#line 1323
  if (((scm_cell *)obj)->car == ((383L | (1L << 16)) | (2L << 16))) {
#line 1323
    *((double *)((scm_cell *)v)->cdr + (2L * pos + 1L)) = *((double *)((char *)((scm_cell *)obj)->cdr + sizeof(double )));
  } else {
#line 1323
    *((double *)((scm_cell *)v)->cdr + (2L * pos + 1L)) = 0.0;
  }
#line 1324
  goto switch_break;
  case_13: /* CIL Label */ 
#line 1327
  *((SCM *)((scm_cell *)v)->cdr + pos) = obj;
#line 1328
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1330
  return ((long )(21 << 9) + 372L);
}
}
#line 1333 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
static char s_array_contents[15]  = 
#line 1333
  {      (char )'a',      (char )'r',      (char )'r',      (char )'a', 
        (char )'y',      (char )'-',      (char )'c',      (char )'o', 
        (char )'n',      (char )'t',      (char )'e',      (char )'n', 
        (char )'t',      (char )'s',      (char )'\000'};
#line 1335 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
SCM scm_array_contents(SCM ra , SCM strict ) 
{ 
  SCM sra ;
  size_t k ;
  size_t ndim ;
  size_t len ;

  {
#line 1341
  if (6 & (int )ra) {
#line 1342
    return ((long )(16 << 9) + 372L);
  }
  {
#line 1357
  if ((127 & (int )((scm_cell *)ra)->car) == 55) {
#line 1357
    goto case_55;
  }
#line 1357
  if ((127 & (int )((scm_cell *)ra)->car) == 53) {
#line 1357
    goto case_55;
  }
#line 1357
  if ((127 & (int )((scm_cell *)ra)->car) == 47) {
#line 1357
    goto case_55;
  }
#line 1357
  if ((127 & (int )((scm_cell *)ra)->car) == 45) {
#line 1357
    goto case_55;
  }
#line 1357
  if ((127 & (int )((scm_cell *)ra)->car) == 79) {
#line 1357
    goto case_55;
  }
#line 1357
  if ((127 & (int )((scm_cell *)ra)->car) == 37) {
#line 1357
    goto case_55;
  }
#line 1357
  if ((127 & (int )((scm_cell *)ra)->car) == 77) {
#line 1357
    goto case_55;
  }
#line 1357
  if ((127 & (int )((scm_cell *)ra)->car) == 71) {
#line 1357
    goto case_55;
  }
#line 1357
  if ((127 & (int )((scm_cell *)ra)->car) == 21) {
#line 1357
    goto case_55;
  }
#line 1357
  if ((127 & (int )((scm_cell *)ra)->car) == 13) {
#line 1357
    goto case_55;
  }
#line 1362
  if ((127 & (int )((scm_cell *)ra)->car) == 127) {
#line 1362
    goto case_127;
  }
#line 1346
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1347
  return ((long )(16 << 9) + 372L);
  case_55: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_21: /* CIL Label */ 
  case_13: /* CIL Label */ 
#line 1361
  return (ra);
  case_127: /* CIL Label */ 
#line 1364
  ndim = (size_t )(((scm_cell *)ra)->car >> 17);
#line 1364
  len = (size_t )1;
#line 1365
  if (! (scm_tc16_array == (long )(65535 & (int )((scm_cell *)ra)->car))) {
#line 1366
    return ((long )(16 << 9) + 372L);
  } else
#line 1365
  if (! (65536 & (int )((scm_cell *)ra)->car)) {
#line 1366
    return ((long )(16 << 9) + 372L);
  }
#line 1367
  k = (size_t )0;
  {
#line 1367
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1367
    if (! (k < ndim)) {
#line 1367
      goto while_break;
    }
#line 1368
    len *= (size_t )((((scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array )) + k)->ubnd - ((scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array )) + k)->lbnd) + 1L);
#line 1367
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1369
  if (! ((long )(18 << 9) + 372L == strict)) {
#line 1371
    if (((scm_array *)((scm_cell *)ra)->cdr)->base) {
#line 1371
      return ((long )(16 << 9) + 372L);
    }
#line 1373
    if (ndim) {
#line 1373
      if (1L != ((scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array )) + (ndim - 1UL))->inc) {
#line 1374
        return ((long )(16 << 9) + 372L);
      }
    }
#line 1375
    if (71 == (127 & (int )((scm_cell *)((scm_array *)((scm_cell *)ra)->cdr)->v)->car)) {
#line 1377
      if (len != (unsigned long )((scm_cell *)((scm_array *)((scm_cell *)ra)->cdr)->v)->car >> 8) {
#line 1380
        return ((long )(16 << 9) + 372L);
      } else
#line 1377
      if (((scm_array *)((scm_cell *)ra)->cdr)->base % ((8UL * sizeof(long )) / sizeof(char ))) {
#line 1380
        return ((long )(16 << 9) + 372L);
      } else
#line 1377
      if (len % ((8UL * sizeof(long )) / sizeof(char ))) {
#line 1380
        return ((long )(16 << 9) + 372L);
      }
    }
  }
#line 1383
  if (len == (unsigned long )((scm_cell *)((scm_array *)((scm_cell *)ra)->cdr)->v)->car >> 8) {
#line 1383
    if (0UL == ((scm_array *)((scm_cell *)ra)->cdr)->base) {
#line 1383
      if (((scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array )))->inc) {
#line 1384
        return (((scm_array *)((scm_cell *)ra)->cdr)->v);
      }
    }
  }
  {
#line 1385
  sra = scm_make_ra(1);
#line 1386
  ((scm_array_dim *)((char *)((scm_cell *)sra)->cdr + sizeof(scm_array )))->lbnd = 0L;
#line 1387
  ((scm_array_dim *)((char *)((scm_cell *)sra)->cdr + sizeof(scm_array )))->ubnd = (long )(len - 1UL);
#line 1388
  ((scm_array *)((scm_cell *)sra)->cdr)->v = ((scm_array *)((scm_cell *)ra)->cdr)->v;
#line 1389
  ((scm_array *)((scm_cell *)sra)->cdr)->base = ((scm_array *)((scm_cell *)ra)->cdr)->base;
  }
#line 1390
  if (ndim) {
#line 1390
    ((scm_array_dim *)((char *)((scm_cell *)sra)->cdr + sizeof(scm_array )))->inc = ((scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array )) + (ndim - 1UL))->inc;
  } else {
#line 1390
    ((scm_array_dim *)((char *)((scm_cell *)sra)->cdr + sizeof(scm_array )))->inc = 1L;
  }
#line 1391
  return (sra);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1397 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
SCM scm_ra2contig(SCM ra , int copy ) 
{ 
  SCM ret ;
  long inc ;
  size_t k ;
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  SCM tmp___1 ;

  {
#line 1403
  inc = 1L;
#line 1404
  len = (size_t )1;
#line 1405
  k = (size_t )(((scm_cell *)ra)->car >> 17);
  {
#line 1405
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1405
    tmp = k;
#line 1405
    k --;
#line 1405
    if (! tmp) {
#line 1405
      goto while_break;
    }
#line 1406
    len *= (size_t )((((scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array )) + k)->ubnd - ((scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array )) + k)->lbnd) + 1L);
  }
  while_break: /* CIL Label */ ;
  }
#line 1407
  k = (size_t )(((scm_cell *)ra)->car >> 17);
#line 1408
  if (65536 & (int )((scm_cell *)ra)->car) {
#line 1408
    if (0UL == k) {
#line 1408
      goto _L;
    } else
#line 1408
    if (1L == ((scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array )) + (k - 1UL))->inc) {
      _L: /* CIL Label */ 
#line 1410
      if (71 != (127 & (int )((scm_cell *)ra)->car)) {
#line 1411
        return (ra);
      }
#line 1412
      if (len == (unsigned long )((scm_cell *)((scm_array *)((scm_cell *)ra)->cdr)->v)->car >> 8) {
#line 1412
        if (0UL == ((scm_array *)((scm_cell *)ra)->cdr)->base % ((8UL * sizeof(long )) / sizeof(char ))) {
#line 1412
          if (0UL == len % ((8UL * sizeof(long )) / sizeof(char ))) {
#line 1415
            return (ra);
          }
        }
      }
    }
  }
  {
#line 1417
  ret = scm_make_ra((int )k);
#line 1418
  ((scm_array *)((scm_cell *)ret)->cdr)->base = (size_t )0;
  }
  {
#line 1419
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1419
    tmp___0 = k;
#line 1419
    k --;
#line 1419
    if (! tmp___0) {
#line 1419
      goto while_break___0;
    }
#line 1421
    ((scm_array_dim *)((char *)((scm_cell *)ret)->cdr + sizeof(scm_array )) + k)->lbnd = ((scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array )) + k)->lbnd;
#line 1422
    ((scm_array_dim *)((char *)((scm_cell *)ret)->cdr + sizeof(scm_array )) + k)->ubnd = ((scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array )) + k)->ubnd;
#line 1423
    ((scm_array_dim *)((char *)((scm_cell *)ret)->cdr + sizeof(scm_array )) + k)->inc = inc;
#line 1424
    inc *= (((scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array )) + k)->ubnd - ((scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array )) + k)->lbnd) + 1L;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1426
  tmp___1 = scm_array_prototype(ra);
#line 1426
  ((scm_array *)((scm_cell *)ret)->cdr)->v = scm_make_uve(inc - 1L, tmp___1);
  }
#line 1427
  if (copy) {
    {
#line 1428
    scm_array_copy_x(ra, ret);
    }
  }
#line 1429
  return (ret);
}
}
#line 1434 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
static char s_uniform_array_read_x[20]  = 
#line 1434
  {      (char )'u',      (char )'n',      (char )'i',      (char )'f', 
        (char )'o',      (char )'r',      (char )'m',      (char )'-', 
        (char )'a',      (char )'r',      (char )'r',      (char )'a', 
        (char )'y',      (char )'-',      (char )'r',      (char )'e', 
        (char )'a',      (char )'d',      (char )'!',      (char )'\000'};
#line 1436 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
SCM scm_uniform_array_read_x(SCM ra , SCM port ) 
{ 
  SCM cra ;
  SCM v ;
  long sz ;
  long len ;
  long ans ;
  long start ;
  int *tmp ;
  size_t tmp___0 ;
  int *tmp___1 ;

  {
#line 1441
  cra = (long )(18 << 9) + 372L;
#line 1441
  v = ra;
#line 1443
  start = 0L;
#line 1445
  if ((long )(18 << 9) + 372L == port) {
#line 1446
    port = scm_root->cur_inp;
  } else
#line 1448
  if (! (6 & (int )port)) {
#line 1448
    if (! ((((65279L | (1L << 16)) | (2L << 16)) & ((scm_cell *)port)->car) == ((125L | (1L << 16)) | (2L << 16)))) {
      {
#line 1448
      scm_wta(port, (char *)2, s_uniform_array_read_x);
      }
    }
  } else {
    {
#line 1448
    scm_wta(port, (char *)2, s_uniform_array_read_x);
    }
  }
#line 1450
  if (! (! (6 & (int )v))) {
#line 1450
    goto badarg1;
  }
#line 1452
  len = (long )((unsigned long )((scm_cell *)v)->car >> 8);
  loop: 
  {
#line 1458
  if ((127 & (int )((scm_cell *)v)->car) == 127) {
#line 1458
    goto case_127;
  }
#line 1467
  if ((127 & (int )((scm_cell *)v)->car) == 77) {
#line 1467
    goto case_77;
  }
#line 1467
  if ((127 & (int )((scm_cell *)v)->car) == 21) {
#line 1467
    goto case_77;
  }
#line 1470
  if ((127 & (int )((scm_cell *)v)->car) == 71) {
#line 1470
    goto case_71;
  }
#line 1474
  if ((127 & (int )((scm_cell *)v)->car) == 79) {
#line 1474
    goto case_79;
  }
#line 1474
  if ((127 & (int )((scm_cell *)v)->car) == 37) {
#line 1474
    goto case_79;
  }
#line 1477
  if ((127 & (int )((scm_cell *)v)->car) == 55) {
#line 1477
    goto case_55;
  }
#line 1491
  if ((127 & (int )((scm_cell *)v)->car) == 47) {
#line 1491
    goto case_47;
  }
#line 1494
  if ((127 & (int )((scm_cell *)v)->car) == 53) {
#line 1494
    goto case_53;
  }
#line 1456
  goto badarg1;
  badarg1: 
  switch_default: /* CIL Label */ 
  {
#line 1457
  scm_wta(v, (char *)1, s_uniform_array_read_x);
  }
  case_127: /* CIL Label */ 
#line 1459
  if (! (scm_tc16_array == (long )(65535 & (int )((scm_cell *)v)->car))) {
#line 1459
    goto badarg1;
  }
  {
#line 1460
  cra = scm_ra2contig(ra, 0);
#line 1461
  start = (long )((scm_array *)((scm_cell *)cra)->cdr)->base;
#line 1462
  len = ((scm_array_dim *)((char *)((scm_cell *)cra)->cdr + sizeof(scm_array )))->inc * ((((scm_array_dim *)((char *)((scm_cell *)cra)->cdr + sizeof(scm_array )))->ubnd - ((scm_array_dim *)((char *)((scm_cell *)cra)->cdr + sizeof(scm_array )))->lbnd) + 1L);
#line 1464
  v = ((scm_array *)((scm_cell *)cra)->cdr)->v;
  }
#line 1465
  goto loop;
  case_77: /* CIL Label */ 
  case_21: /* CIL Label */ 
#line 1468
  sz = (long )sizeof(char );
#line 1469
  goto switch_break;
  case_71: /* CIL Label */ 
#line 1471
  len = (long )((((unsigned long )len + (8UL * sizeof(long )) / sizeof(char )) - 1UL) / ((8UL * sizeof(long )) / sizeof(char )));
#line 1472
  start = (long )((unsigned long )start / ((8UL * sizeof(long )) / sizeof(char )));
  case_79: /* CIL Label */ 
  case_37: /* CIL Label */ 
#line 1475
  sz = (long )sizeof(long );
#line 1476
  goto switch_break;
  case_55: /* CIL Label */ 
#line 1478
  sz = (long )sizeof(short );
#line 1479
  goto switch_break;
  case_47: /* CIL Label */ 
#line 1492
  sz = (long )sizeof(double );
#line 1493
  goto switch_break;
  case_53: /* CIL Label */ 
#line 1495
  sz = (long )(2UL * sizeof(double ));
#line 1496
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1502
  if (((scm_cell *)port)->car & (32L << 16)) {
    {
#line 1504
    ungetc(((struct scm_port_table *)((scm_cell *)port)->cdr)->unchr, (FILE *)((struct scm_port_table *)((scm_cell *)port)->cdr)->stream);
#line 1505
    ((scm_cell *)port)->car &= 2097151L;
    }
  }
  {
#line 1508
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1508
    tmp = __errno_location();
#line 1508
    *tmp = 0;
#line 1508
    tmp___0 = fread((void */* __restrict  */)((char *)((scm_cell *)v)->cdr + start * sz),
                    (size_t )sz, (size_t )len, (FILE */* __restrict  */)((FILE *)((struct scm_port_table *)((scm_cell *)port)->cdr)->stream));
#line 1508
    ans = (long )tmp___0;
#line 1508
    tmp___1 = __errno_location();
    }
#line 1508
    if (! (4 == *tmp___1)) {
#line 1508
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1512
  if ((127 & (int )((scm_cell *)v)->car) == 71) {
#line 1513
    ans = (long )((unsigned long )ans * ((8UL * sizeof(long )) / sizeof(char )));
  }
#line 1515
  if (v != ra) {
#line 1515
    if (cra != ra) {
      {
#line 1516
      scm_array_copy_x(cra, ra);
      }
    }
  }
#line 1518
  return ((ans << 2) + 2L);
}
}
#line 1521 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
static char s_uniform_array_write[20]  = 
#line 1521
  {      (char )'u',      (char )'n',      (char )'i',      (char )'f', 
        (char )'o',      (char )'r',      (char )'m',      (char )'-', 
        (char )'a',      (char )'r',      (char )'r',      (char )'a', 
        (char )'y',      (char )'-',      (char )'w',      (char )'r', 
        (char )'i',      (char )'t',      (char )'e',      (char )'\000'};
#line 1523 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
SCM scm_uniform_array_write(SCM v , SCM port ) 
{ 
  long sz ;
  long len ;
  long ans ;
  long start ;
  int *tmp ;
  size_t tmp___0 ;
  int *tmp___1 ;

  {
#line 1529
  start = 0L;
#line 1530
  if ((long )(18 << 9) + 372L == port) {
#line 1531
    port = scm_root->cur_outp;
  } else
#line 1533
  if (! (6 & (int )port)) {
#line 1533
    if (! ((((65279L | (1L << 16)) | (4L << 16)) & ((scm_cell *)port)->car) == ((125L | (1L << 16)) | (4L << 16)))) {
      {
#line 1533
      scm_wta(port, (char *)2, s_uniform_array_write);
      }
    }
  } else {
    {
#line 1533
    scm_wta(port, (char *)2, s_uniform_array_write);
    }
  }
#line 1534
  if (! (! (6 & (int )v))) {
#line 1534
    goto badarg1;
  }
#line 1535
  len = (long )((unsigned long )((scm_cell *)v)->car >> 8);
  loop: 
  {
#line 1542
  if ((127 & (int )((scm_cell *)v)->car) == 127) {
#line 1542
    goto case_127;
  }
#line 1550
  if ((127 & (int )((scm_cell *)v)->car) == 21) {
#line 1550
    goto case_21;
  }
#line 1550
  if ((127 & (int )((scm_cell *)v)->car) == 77) {
#line 1550
    goto case_21;
  }
#line 1553
  if ((127 & (int )((scm_cell *)v)->car) == 71) {
#line 1553
    goto case_71;
  }
#line 1557
  if ((127 & (int )((scm_cell *)v)->car) == 79) {
#line 1557
    goto case_79;
  }
#line 1557
  if ((127 & (int )((scm_cell *)v)->car) == 37) {
#line 1557
    goto case_79;
  }
#line 1560
  if ((127 & (int )((scm_cell *)v)->car) == 55) {
#line 1560
    goto case_55;
  }
#line 1574
  if ((127 & (int )((scm_cell *)v)->car) == 47) {
#line 1574
    goto case_47;
  }
#line 1577
  if ((127 & (int )((scm_cell *)v)->car) == 53) {
#line 1577
    goto case_53;
  }
#line 1540
  goto badarg1;
  badarg1: 
  switch_default: /* CIL Label */ 
  {
#line 1541
  scm_wta(v, (char *)1, s_uniform_array_write);
  }
  case_127: /* CIL Label */ 
#line 1543
  if (! (scm_tc16_array == (long )(65535 & (int )((scm_cell *)v)->car))) {
#line 1543
    goto badarg1;
  }
  {
#line 1544
  v = scm_ra2contig(v, 1);
#line 1545
  start = (long )((scm_array *)((scm_cell *)v)->cdr)->base;
#line 1546
  len = ((scm_array_dim *)((char *)((scm_cell *)v)->cdr + sizeof(scm_array )))->inc * ((((scm_array_dim *)((char *)((scm_cell *)v)->cdr + sizeof(scm_array )))->ubnd - ((scm_array_dim *)((char *)((scm_cell *)v)->cdr + sizeof(scm_array )))->lbnd) + 1L);
#line 1547
  v = ((scm_array *)((scm_cell *)v)->cdr)->v;
  }
#line 1548
  goto loop;
  case_21: /* CIL Label */ 
  case_77: /* CIL Label */ 
#line 1551
  sz = (long )sizeof(char );
#line 1552
  goto switch_break;
  case_71: /* CIL Label */ 
#line 1554
  len = (long )((((unsigned long )len + (8UL * sizeof(long )) / sizeof(char )) - 1UL) / ((8UL * sizeof(long )) / sizeof(char )));
#line 1555
  start = (long )((unsigned long )start / ((8UL * sizeof(long )) / sizeof(char )));
  case_79: /* CIL Label */ 
  case_37: /* CIL Label */ 
#line 1558
  sz = (long )sizeof(long );
#line 1559
  goto switch_break;
  case_55: /* CIL Label */ 
#line 1561
  sz = (long )sizeof(short );
#line 1562
  goto switch_break;
  case_47: /* CIL Label */ 
#line 1575
  sz = (long )sizeof(double );
#line 1576
  goto switch_break;
  case_53: /* CIL Label */ 
#line 1578
  sz = (long )(2UL * sizeof(double ));
#line 1579
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1582
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1582
    tmp = __errno_location();
#line 1582
    *tmp = 0;
#line 1582
    tmp___0 = fwrite((void const   */* __restrict  */)((char *)((scm_cell *)v)->cdr + start * sz),
                     (size_t )sz, (size_t )len, (FILE */* __restrict  */)((FILE *)((struct scm_port_table *)((scm_cell *)port)->cdr)->stream));
#line 1582
    ans = (long )tmp___0;
#line 1582
    tmp___1 = __errno_location();
    }
#line 1582
    if (! (4 == *tmp___1)) {
#line 1582
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1583
  if ((127 & (int )((scm_cell *)v)->car) == 71) {
#line 1584
    ans = (long )((unsigned long )ans * ((8UL * sizeof(long )) / sizeof(char )));
  }
#line 1585
  return ((ans << 2) + 2L);
}
}
#line 1589 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
static char cnt_tab[16]  = 
#line 1589
  {      (char)0,      (char)1,      (char)1,      (char)2, 
        (char)1,      (char)2,      (char)2,      (char)3, 
        (char)1,      (char)2,      (char)2,      (char)3, 
        (char)2,      (char)3,      (char)3,      (char)4};
#line 1592 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
static char s_bit_count[10]  = 
#line 1592
  {      (char )'b',      (char )'i',      (char )'t',      (char )'-', 
        (char )'c',      (char )'o',      (char )'u',      (char )'n', 
        (char )'t',      (char )'\000'};
#line 1594 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
SCM scm_bit_count(SCM item , SCM seq ) 
{ 
  long i ;
  register unsigned long cnt ;
  register unsigned long w ;
  long tmp ;

  {
#line 1600
  cnt = 0UL;
#line 1601
  if (! (! (6 & (int )seq))) {
    {
#line 1601
    scm_wta(seq, (char *)2, s_bit_count);
    }
  }
  {
#line 1607
  if ((127 & (int )((scm_cell *)seq)->car) == 71) {
#line 1607
    goto case_71;
  }
#line 1605
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 1606
  scm_wta(seq, (char *)2, s_bit_count);
  }
  case_71: /* CIL Label */ 
#line 1608
  if (0UL == (unsigned long )((scm_cell *)seq)->car >> 8) {
#line 1609
    return ((SCM )2);
  }
#line 1610
  i = (long )((((unsigned long )((scm_cell *)seq)->car >> 8) - 1UL) / ((8UL * sizeof(long )) / sizeof(char )));
#line 1611
  w = (unsigned long )*((SCM *)((scm_cell *)seq)->cdr + i);
#line 1612
  if ((long )(16 << 9) + 372L == item) {
#line 1613
    w = ~ w;
  }
#line 1614
  w <<= ((8UL * sizeof(long )) / sizeof(char ) - 1UL) - (((unsigned long )((scm_cell *)seq)->car >> 8) - 1UL) % ((8UL * sizeof(long )) / sizeof(char ));
  {
#line 1615
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1617
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1617
      if (! w) {
#line 1617
        goto while_break___0;
      }
#line 1618
      cnt += (unsigned long )cnt_tab[w & 15UL];
#line 1617
      w >>= 4;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1619
    tmp = i;
#line 1619
    i --;
#line 1619
    if (0L == tmp) {
#line 1620
      return ((SCM )((cnt << 2) + 2UL));
    }
#line 1621
    w = (unsigned long )*((SCM *)((scm_cell *)seq)->cdr + i);
#line 1622
    if ((long )(16 << 9) + 372L == item) {
#line 1623
      w = ~ w;
    }
  }
  while_break: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1629 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
static char s_bit_position[13]  = 
#line 1629
  {      (char )'b',      (char )'i',      (char )'t',      (char )'-', 
        (char )'p',      (char )'o',      (char )'s',      (char )'i', 
        (char )'t',      (char )'i',      (char )'o',      (char )'n', 
        (char )'\000'};
#line 1631 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
SCM scm_bit_position(SCM item , SCM v , SCM k ) 
{ 
  long i ;
  long lenw ;
  long xbits ;
  long pos ;
  register unsigned long w ;

  {
#line 1637
  pos = k >> 2;
#line 1639
  if (! (! (6 & (int )v))) {
    {
#line 1639
    scm_wta(v, (char *)2, s_bit_position);
    }
  }
#line 1640
  if (! (2 & (int )k)) {
    {
#line 1640
    scm_wta(k, (char *)3, s_bit_position);
    }
  }
#line 1641
  if ((unsigned long )pos <= (unsigned long )((scm_cell *)v)->car >> 8) {
#line 1641
    if (! (pos >= 0L)) {
      {
#line 1641
      scm_wta(k, (char *)10, s_bit_position);
      }
    }
  } else {
    {
#line 1641
    scm_wta(k, (char *)10, s_bit_position);
    }
  }
#line 1643
  if ((unsigned long )pos == (unsigned long )((scm_cell *)v)->car >> 8) {
#line 1644
    return ((long )(16 << 9) + 372L);
  }
  {
#line 1650
  if ((127 & (int )((scm_cell *)v)->car) == 71) {
#line 1650
    goto case_71;
  }
#line 1648
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 1649
  scm_wta(v, (char *)2, s_bit_position);
  }
  case_71: /* CIL Label */ 
#line 1651
  if (0UL == (unsigned long )((scm_cell *)v)->car >> 8) {
#line 1652
    return ((-1L << 2) + 2L);
  }
#line 1653
  lenw = (long )((((unsigned long )((scm_cell *)v)->car >> 8) - 1UL) / ((8UL * sizeof(long )) / sizeof(char )));
#line 1654
  i = (long )((unsigned long )pos / ((8UL * sizeof(long )) / sizeof(char )));
#line 1655
  w = (unsigned long )*((SCM *)((scm_cell *)v)->cdr + i);
#line 1656
  if ((long )(16 << 9) + 372L == item) {
#line 1657
    w = ~ w;
  }
#line 1658
  xbits = (long )((unsigned long )pos % ((8UL * sizeof(long )) / sizeof(char )));
#line 1659
  pos -= xbits;
#line 1660
  w = (w >> xbits) << xbits;
#line 1661
  xbits = (long )(((8UL * sizeof(long )) / sizeof(char ) - 1UL) - (((unsigned long )((scm_cell *)v)->car >> 8) - 1UL) % ((8UL * sizeof(long )) / sizeof(char )));
  {
#line 1662
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1664
    if (w) {
#line 1664
      if (i == lenw) {
#line 1665
        w = (w << xbits) >> xbits;
      }
    }
#line 1666
    if (w) {
      {
#line 1667
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1667
        if (! w) {
#line 1667
          goto while_break___0;
        }
        {
#line 1675
        if ((w & 15UL) == 14UL) {
#line 1675
          goto case_14;
        }
#line 1675
        if ((w & 15UL) == 10UL) {
#line 1675
          goto case_14;
        }
#line 1675
        if ((w & 15UL) == 6UL) {
#line 1675
          goto case_14;
        }
#line 1675
        if ((w & 15UL) == 2UL) {
#line 1675
          goto case_14;
        }
#line 1678
        if ((w & 15UL) == 12UL) {
#line 1678
          goto case_12;
        }
#line 1678
        if ((w & 15UL) == 4UL) {
#line 1678
          goto case_12;
        }
#line 1680
        if ((w & 15UL) == 8UL) {
#line 1680
          goto case_8;
        }
#line 1682
        if ((w & 15UL) == 0UL) {
#line 1682
          goto case_0;
        }
#line 1670
        goto switch_default___0;
        switch_default___0: /* CIL Label */ 
#line 1671
        return ((pos << 2) + 2L);
        case_14: /* CIL Label */ 
        case_10: /* CIL Label */ 
        case_6: /* CIL Label */ 
        case_2: /* CIL Label */ 
#line 1676
        return (((pos + 1L) << 2) + 2L);
        case_12: /* CIL Label */ 
        case_4: /* CIL Label */ 
#line 1679
        return (((pos + 2L) << 2) + 2L);
        case_8: /* CIL Label */ 
#line 1681
        return (((pos + 3L) << 2) + 2L);
        case_0: /* CIL Label */ 
#line 1683
        pos += 4L;
#line 1684
        w >>= 4;
        switch_break___0: /* CIL Label */ ;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1686
    i ++;
#line 1686
    if (i > lenw) {
#line 1687
      goto while_break;
    }
#line 1688
    pos = (long )((unsigned long )pos + (8UL * sizeof(long )) / sizeof(char ));
#line 1689
    w = (unsigned long )*((SCM *)((scm_cell *)v)->cdr + i);
#line 1690
    if ((long )(16 << 9) + 372L == item) {
#line 1691
      w = ~ w;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1693
  return ((long )(16 << 9) + 372L);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1698 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
static char s_bit_set_star_x[10]  = 
#line 1698
  {      (char )'b',      (char )'i',      (char )'t',      (char )'-', 
        (char )'s',      (char )'e',      (char )'t',      (char )'*', 
        (char )'!',      (char )'\000'};
#line 1700 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
SCM scm_bit_set_star_x(SCM v , SCM kv , SCM obj ) 
{ 
  register long i ;
  register long k ;
  register long vlen ;
  long tmp ;
  long tmp___0 ;

  {
#line 1707
  if (! (! (6 & (int )v))) {
#line 1707
    goto badarg1;
  }
#line 1708
  if (! (! (6 & (int )kv))) {
#line 1708
    goto badarg2;
  }
  {
#line 1714
  if ((127 & (int )((scm_cell *)kv)->car) == 37) {
#line 1714
    goto case_37;
  }
#line 1740
  if ((127 & (int )((scm_cell *)kv)->car) == 71) {
#line 1740
    goto case_71___0;
  }
#line 1712
  goto badarg2;
  badarg2: 
  switch_default: /* CIL Label */ 
  {
#line 1713
  scm_wta(kv, (char *)2, s_bit_set_star_x);
  }
  case_37: /* CIL Label */ 
  {
#line 1720
  if ((127 & (int )((scm_cell *)v)->car) == 71) {
#line 1720
    goto case_71;
  }
#line 1718
  goto badarg1;
  badarg1: 
  switch_default___0: /* CIL Label */ 
  {
#line 1719
  scm_wta(v, (char *)1, s_bit_set_star_x);
  }
  case_71: /* CIL Label */ 
#line 1721
  vlen = (long )((unsigned long )((scm_cell *)v)->car >> 8);
#line 1722
  if ((long )(16 << 9) + 372L == obj) {
#line 1723
    i = (long )((unsigned long )((scm_cell *)kv)->car >> 8);
    {
#line 1723
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1723
      if (! i) {
#line 1723
        goto while_break;
      }
#line 1725
      i --;
#line 1725
      k = *((SCM *)((scm_cell *)kv)->cdr + i);
#line 1726
      if (! (k < vlen)) {
        {
#line 1726
        scm_wta((k << 2) + 2L, (char *)10, s_bit_set_star_x);
        }
      }
#line 1727
      *((SCM *)((scm_cell *)v)->cdr + (unsigned long )k / ((8UL * sizeof(long )) / sizeof(char ))) &= ~ (1L << (unsigned long )k % ((8UL * sizeof(long )) / sizeof(char )));
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 1729
  if ((long )(17 << 9) + 372L == obj) {
#line 1730
    i = (long )((unsigned long )((scm_cell *)kv)->car >> 8);
    {
#line 1730
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1730
      if (! i) {
#line 1730
        goto while_break___0;
      }
#line 1732
      i --;
#line 1732
      k = *((SCM *)((scm_cell *)kv)->cdr + i);
#line 1733
      if (! (k < vlen)) {
        {
#line 1733
        scm_wta((k << 2) + 2L, (char *)10, s_bit_set_star_x);
        }
      }
#line 1734
      *((SCM *)((scm_cell *)v)->cdr + (unsigned long )k / ((8UL * sizeof(long )) / sizeof(char ))) |= 1L << (unsigned long )k % ((8UL * sizeof(long )) / sizeof(char ));
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    badarg3: 
    {
#line 1737
    scm_wta(obj, (char *)3, s_bit_set_star_x);
    }
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 1739
  goto switch_break;
  case_71___0: /* CIL Label */ 
#line 1741
  if ((127 & (int )((scm_cell *)v)->car) == 71) {
#line 1741
    if (! ((unsigned long )((scm_cell *)v)->car >> 8 == (unsigned long )((scm_cell *)kv)->car >> 8)) {
#line 1741
      goto badarg1;
    }
  } else {
#line 1741
    goto badarg1;
  }
#line 1742
  if ((long )(16 << 9) + 372L == obj) {
#line 1743
    k = (long )(((((unsigned long )((scm_cell *)v)->car >> 8) + (8UL * sizeof(long )) / sizeof(char )) - 1UL) / ((8UL * sizeof(long )) / sizeof(char )));
    {
#line 1743
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1743
      tmp = k;
#line 1743
      k --;
#line 1743
      if (! tmp) {
#line 1743
        goto while_break___1;
      }
#line 1744
      *((SCM *)((scm_cell *)v)->cdr + k) &= ~ *((SCM *)((scm_cell *)kv)->cdr + k);
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 1745
  if ((long )(17 << 9) + 372L == obj) {
#line 1746
    k = (long )(((((unsigned long )((scm_cell *)v)->car >> 8) + (8UL * sizeof(long )) / sizeof(char )) - 1UL) / ((8UL * sizeof(long )) / sizeof(char )));
    {
#line 1746
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1746
      tmp___0 = k;
#line 1746
      k --;
#line 1746
      if (! tmp___0) {
#line 1746
        goto while_break___2;
      }
#line 1747
      *((SCM *)((scm_cell *)v)->cdr + k) |= *((SCM *)((scm_cell *)kv)->cdr + k);
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
#line 1749
    goto badarg3;
  }
#line 1750
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1752
  return ((long )(21 << 9) + 372L);
}
}
#line 1756 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
static char s_bit_count_star[11]  = 
#line 1756
  {      (char )'b',      (char )'i',      (char )'t',      (char )'-', 
        (char )'c',      (char )'o',      (char )'u',      (char )'n', 
        (char )'t',      (char )'*',      (char )'\000'};
#line 1758 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
SCM scm_bit_count_star(SCM v , SCM kv , SCM obj ) 
{ 
  register long i ;
  register long vlen ;
  register long count ;
  register unsigned long k ;
  SCM tmp ;
  long tmp___0 ;
  SCM tmp___1 ;

  {
#line 1764
  count = 0L;
#line 1766
  if (! (! (6 & (int )v))) {
#line 1766
    goto badarg1;
  }
#line 1767
  if (! (! (6 & (int )kv))) {
#line 1767
    goto badarg2;
  }
  {
#line 1773
  if ((127 & (int )((scm_cell *)kv)->car) == 37) {
#line 1773
    goto case_37;
  }
#line 1801
  if ((127 & (int )((scm_cell *)kv)->car) == 71) {
#line 1801
    goto case_71___0;
  }
#line 1771
  goto badarg2;
  badarg2: 
  switch_default: /* CIL Label */ 
  {
#line 1772
  scm_wta(kv, (char *)2, s_bit_count_star);
  }
  case_37: /* CIL Label */ 
  {
#line 1779
  if ((127 & (int )((scm_cell *)v)->car) == 71) {
#line 1779
    goto case_71;
  }
#line 1777
  goto badarg1;
  badarg1: 
  switch_default___0: /* CIL Label */ 
  {
#line 1778
  scm_wta(v, (char *)1, s_bit_count_star);
  }
  case_71: /* CIL Label */ 
#line 1780
  vlen = (long )((unsigned long )((scm_cell *)v)->car >> 8);
#line 1781
  if ((long )(16 << 9) + 372L == obj) {
#line 1782
    i = (long )((unsigned long )((scm_cell *)kv)->car >> 8);
    {
#line 1782
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1782
      if (! i) {
#line 1782
        goto while_break;
      }
#line 1784
      i --;
#line 1784
      k = (unsigned long )*((SCM *)((scm_cell *)kv)->cdr + i);
#line 1785
      if (! (k < (unsigned long )vlen)) {
        {
#line 1785
        scm_wta((SCM )((k << 2) + 2UL), (char *)10, s_bit_count_star);
        }
      }
#line 1786
      if (! (*((SCM *)((scm_cell *)v)->cdr + k / ((8UL * sizeof(long )) / sizeof(char ))) & (1L << k % ((8UL * sizeof(long )) / sizeof(char ))))) {
#line 1787
        count ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 1789
  if ((long )(17 << 9) + 372L == obj) {
#line 1790
    i = (long )((unsigned long )((scm_cell *)kv)->car >> 8);
    {
#line 1790
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1790
      if (! i) {
#line 1790
        goto while_break___0;
      }
#line 1792
      i --;
#line 1792
      k = (unsigned long )*((SCM *)((scm_cell *)kv)->cdr + i);
#line 1793
      if (! (k < (unsigned long )vlen)) {
        {
#line 1793
        scm_wta((SCM )((k << 2) + 2UL), (char *)10, s_bit_count_star);
        }
      }
#line 1794
      if (*((SCM *)((scm_cell *)v)->cdr + k / ((8UL * sizeof(long )) / sizeof(char ))) & (1L << k % ((8UL * sizeof(long )) / sizeof(char )))) {
#line 1795
        count ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    badarg3: 
    {
#line 1798
    scm_wta(obj, (char *)3, s_bit_count_star);
    }
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 1800
  goto switch_break;
  case_71___0: /* CIL Label */ 
#line 1802
  if ((127 & (int )((scm_cell *)v)->car) == 71) {
#line 1802
    if (! ((unsigned long )((scm_cell *)v)->car >> 8 == (unsigned long )((scm_cell *)kv)->car >> 8)) {
#line 1802
      goto badarg1;
    }
  } else {
#line 1802
    goto badarg1;
  }
#line 1803
  if (0UL == (unsigned long )((scm_cell *)v)->car >> 8) {
#line 1804
    return ((SCM )2);
  }
#line 1805
  if (! ((long )(17 << 9) + 372L == obj)) {
#line 1805
    if (! ((long )(16 << 9) + 372L == obj)) {
#line 1805
      goto badarg3;
    }
  }
#line 1806
  obj = (SCM )((long )(17 << 9) + 372L == obj);
#line 1807
  i = (long )((((unsigned long )((scm_cell *)v)->car >> 8) - 1UL) / ((8UL * sizeof(long )) / sizeof(char )));
#line 1808
  if (obj) {
#line 1808
    tmp = *((SCM *)((scm_cell *)v)->cdr + i);
  } else {
#line 1808
    tmp = ~ *((SCM *)((scm_cell *)v)->cdr + i);
  }
#line 1808
  k = (unsigned long )(*((SCM *)((scm_cell *)kv)->cdr + i) & tmp);
#line 1809
  k <<= ((8UL * sizeof(long )) / sizeof(char ) - 1UL) - (((unsigned long )((scm_cell *)v)->car >> 8) - 1UL) % ((8UL * sizeof(long )) / sizeof(char ));
  {
#line 1810
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1812
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1812
      if (! k) {
#line 1812
        goto while_break___2;
      }
#line 1813
      count += (long )cnt_tab[k & 15UL];
#line 1812
      k >>= 4;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1814
    tmp___0 = i;
#line 1814
    i --;
#line 1814
    if (0L == tmp___0) {
#line 1815
      return ((count << 2) + 2L);
    }
#line 1816
    if (obj) {
#line 1816
      tmp___1 = *((SCM *)((scm_cell *)v)->cdr + i);
    } else {
#line 1816
      tmp___1 = ~ *((SCM *)((scm_cell *)v)->cdr + i);
    }
#line 1816
    k = (unsigned long )(*((SCM *)((scm_cell *)kv)->cdr + i) & tmp___1);
  }
  while_break___1: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
#line 1819
  return ((count << 2) + 2L);
}
}
#line 1823 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
static char s_bit_invert_x[12]  = 
#line 1823
  {      (char )'b',      (char )'i',      (char )'t',      (char )'-', 
        (char )'i',      (char )'n',      (char )'v',      (char )'e', 
        (char )'r',      (char )'t',      (char )'!',      (char )'\000'};
#line 1825 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
SCM scm_bit_invert_x(SCM v ) 
{ 
  register long k ;
  long tmp ;

  {
#line 1830
  if (! (! (6 & (int )v))) {
#line 1830
    goto badarg1;
  }
#line 1831
  k = (long )((unsigned long )((scm_cell *)v)->car >> 8);
  {
#line 1835
  if ((127 & (int )((scm_cell *)v)->car) == 71) {
#line 1835
    goto case_71;
  }
#line 1839
  goto badarg1;
  case_71: /* CIL Label */ 
#line 1836
  k = (long )((((unsigned long )k + (8UL * sizeof(long )) / sizeof(char )) - 1UL) / ((8UL * sizeof(long )) / sizeof(char )));
  {
#line 1836
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1836
    tmp = k;
#line 1836
    k --;
#line 1836
    if (! tmp) {
#line 1836
      goto while_break;
    }
#line 1837
    *((SCM *)((scm_cell *)v)->cdr + k) = ~ *((SCM *)((scm_cell *)v)->cdr + k);
  }
  while_break: /* CIL Label */ ;
  }
#line 1838
  goto switch_break;
  badarg1: 
  switch_default: /* CIL Label */ 
  {
#line 1840
  scm_wta(v, (char *)1, s_bit_invert_x);
  }
  switch_break: /* CIL Label */ ;
  }
#line 1842
  return ((long )(21 << 9) + 372L);
}
}
#line 1846 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
static char s_string_upcase_x[15]  = 
#line 1846
  {      (char )'s',      (char )'t',      (char )'r',      (char )'i', 
        (char )'n',      (char )'g',      (char )'-',      (char )'u', 
        (char )'p',      (char )'c',      (char )'a',      (char )'s', 
        (char )'e',      (char )'!',      (char )'\000'};
#line 1848 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
SCM scm_string_upcase_x(SCM v ) 
{ 
  register long k ;
  register unsigned char *cs ;
  int tmp ;
  long tmp___0 ;

  {
#line 1854
  if (! (! (6 & (int )v))) {
#line 1854
    goto badarg1;
  }
#line 1855
  k = (long )((unsigned long )((scm_cell *)v)->car >> 8);
  {
#line 1859
  if ((127 & (int )((scm_cell *)v)->car) == 21) {
#line 1859
    goto case_21;
  }
#line 1864
  goto badarg1;
  case_21: /* CIL Label */ 
#line 1860
  cs = (unsigned char *)((scm_cell *)v)->cdr;
  {
#line 1861
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1861
    tmp___0 = k;
#line 1861
    k --;
#line 1861
    if (! tmp___0) {
#line 1861
      goto while_break;
    }
    {
#line 1862
    tmp = scm_upcase((unsigned int )*(cs + k));
#line 1862
    *(cs + k) = (unsigned char )tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1863
  goto switch_break;
  badarg1: 
  switch_default: /* CIL Label */ 
  {
#line 1865
  scm_wta(v, (char *)1, s_string_upcase_x);
  }
  switch_break: /* CIL Label */ ;
  }
#line 1867
  return (v);
}
}
#line 1870 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
static char s_string_downcase_x[17]  = 
#line 1870
  {      (char )'s',      (char )'t',      (char )'r',      (char )'i', 
        (char )'n',      (char )'g',      (char )'-',      (char )'d', 
        (char )'o',      (char )'w',      (char )'n',      (char )'c', 
        (char )'a',      (char )'s',      (char )'e',      (char )'!', 
        (char )'\000'};
#line 1872 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
SCM scm_string_downcase_x(SCM v ) 
{ 
  register long k ;
  register unsigned char *cs ;
  int tmp ;
  long tmp___0 ;

  {
#line 1878
  if (! (! (6 & (int )v))) {
#line 1878
    goto badarg1;
  }
#line 1879
  k = (long )((unsigned long )((scm_cell *)v)->car >> 8);
  {
#line 1883
  if ((127 & (int )((scm_cell *)v)->car) == 21) {
#line 1883
    goto case_21;
  }
#line 1888
  goto badarg1;
  case_21: /* CIL Label */ 
#line 1884
  cs = (unsigned char *)((scm_cell *)v)->cdr;
  {
#line 1885
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1885
    tmp___0 = k;
#line 1885
    k --;
#line 1885
    if (! tmp___0) {
#line 1885
      goto while_break;
    }
    {
#line 1886
    tmp = scm_downcase((unsigned int )*(cs + k));
#line 1886
    *(cs + k) = (unsigned char )tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1887
  goto switch_break;
  badarg1: 
  switch_default: /* CIL Label */ 
  {
#line 1889
  scm_wta(v, (char *)1, s_string_downcase_x);
  }
  switch_break: /* CIL Label */ ;
  }
#line 1891
  return (v);
}
}
#line 1896 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
SCM scm_istr2bve(char *str , long len ) 
{ 
  SCM v ;
  SCM tmp ;
  long *data ;
  register unsigned long mask ;
  register long k ;
  register long j ;
  char *tmp___0 ;
  long tmp___1 ;

  {
  {
#line 1901
  tmp = scm_make_uve(len, (long )(17 << 9) + 372L);
#line 1901
  v = tmp;
#line 1902
  data = (SCM *)((scm_cell *)v)->cdr;
#line 1906
  k = 0L;
  }
  {
#line 1906
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1906
    if (! ((unsigned long )k < (((unsigned long )len + (8UL * sizeof(long )) / sizeof(char )) - 1UL) / ((8UL * sizeof(long )) / sizeof(char )))) {
#line 1906
      goto while_break;
    }
#line 1908
    *(data + k) = 0L;
#line 1909
    j = (long )((unsigned long )len - (unsigned long )k * ((8UL * sizeof(long )) / sizeof(char )));
#line 1910
    if ((unsigned long )j > (8UL * sizeof(long )) / sizeof(char )) {
#line 1911
      j = (long )((8UL * sizeof(long )) / sizeof(char ));
    }
#line 1912
    mask = 1UL;
    {
#line 1912
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1912
      tmp___1 = j;
#line 1912
      j --;
#line 1912
      if (! tmp___1) {
#line 1912
        goto while_break___0;
      }
#line 1913
      tmp___0 = str;
#line 1913
      str ++;
      {
#line 1915
      if ((int )*tmp___0 == 48) {
#line 1915
        goto case_48;
      }
#line 1917
      if ((int )*tmp___0 == 49) {
#line 1917
        goto case_49;
      }
#line 1920
      goto switch_default;
      case_48: /* CIL Label */ 
#line 1916
      goto switch_break;
      case_49: /* CIL Label */ 
#line 1918
      *(data + k) = (long )((unsigned long )*(data + k) | mask);
#line 1919
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1921
      return ((long )(16 << 9) + 372L);
      switch_break: /* CIL Label */ ;
      }
#line 1912
      mask <<= 1;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1906
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1924
  return (v);
}
}
#line 1929
static SCM ra2l(SCM ra , size_t base , size_t k ) ;
#line 1931 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
static SCM ra2l(SCM ra , size_t base , size_t k ) 
{ 
  register SCM res ;
  register long inc ;
  register size_t i ;
  SCM tmp ;
  SCM tmp___0 ;

  {
#line 1937
  res = (long )(20 << 9) + 372L;
#line 1938
  inc = ((scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array )) + k)->inc;
#line 1940
  if (((scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array )) + k)->ubnd < ((scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array )) + k)->lbnd) {
#line 1941
    return ((long )(20 << 9) + 372L);
  }
#line 1942
  i = base + (size_t )(((1L + ((scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array )) + k)->ubnd) - ((scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array )) + k)->lbnd) * inc);
#line 1943
  if (k < (size_t )(((scm_cell *)ra)->car >> 17) - 1UL) {
    {
#line 1945
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1947
      i -= (size_t )inc;
#line 1948
      tmp = ra2l(ra, i, k + 1UL);
#line 1948
      res = scm_cons(tmp, res);
      }
#line 1945
      if (! (i != base)) {
#line 1945
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1953
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1955
      i -= (size_t )inc;
#line 1956
      tmp___0 = scm_uniform_vector_ref(((scm_array *)((scm_cell *)ra)->cdr)->v, (SCM )((i << 2) + 2UL));
#line 1956
      res = scm_cons(tmp___0, res);
      }
#line 1953
      if (! (i != base)) {
#line 1953
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1959
  return (res);
}
}
#line 1963 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
static char s_array_to_list[12]  = 
#line 1963
  {      (char )'a',      (char )'r',      (char )'r',      (char )'a', 
        (char )'y',      (char )'-',      (char )'>',      (char )'l', 
        (char )'i',      (char )'s',      (char )'t',      (char )'\000'};
#line 1965 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
SCM scm_array_to_list(SCM v ) 
{ 
  SCM res ;
  register long k ;
  SCM tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  long *data ;
  register unsigned long mask ;
  long tmp___2 ;
  long tmp___3 ;
  long *data___0 ;
  SCM tmp___4 ;
  long *data___1 ;
  SCM tmp___5 ;
  short *data___2 ;
  double *data___3 ;
  SCM tmp___6 ;
  double (*data___4)[2] ;
  SCM tmp___7 ;

  {
#line 1969
  res = (long )(20 << 9) + 372L;
#line 1971
  if (! (! (6 & (int )v))) {
#line 1971
    goto badarg1;
  }
  {
#line 1977
  if ((127 & (int )((scm_cell *)v)->car) == 127) {
#line 1977
    goto case_127;
  }
#line 1980
  if ((127 & (int )((scm_cell *)v)->car) == 13) {
#line 1980
    goto case_13;
  }
#line 1982
  if ((127 & (int )((scm_cell *)v)->car) == 21) {
#line 1982
    goto case_21;
  }
#line 1984
  if ((127 & (int )((scm_cell *)v)->car) == 71) {
#line 1984
    goto case_71;
  }
#line 2005
  if ((127 & (int )((scm_cell *)v)->car) == 37) {
#line 2005
    goto case_37;
  }
#line 2011
  if ((127 & (int )((scm_cell *)v)->car) == 79) {
#line 2011
    goto case_79;
  }
#line 2018
  if ((127 & (int )((scm_cell *)v)->car) == 55) {
#line 2018
    goto case_55;
  }
#line 2046
  if ((127 & (int )((scm_cell *)v)->car) == 47) {
#line 2046
    goto case_47;
  }
#line 2053
  if ((127 & (int )((scm_cell *)v)->car) == 53) {
#line 2053
    goto case_53;
  }
#line 1975
  goto badarg1;
  badarg1: 
  switch_default: /* CIL Label */ 
  {
#line 1976
  scm_wta(v, (char *)1, s_array_to_list);
  }
  case_127: /* CIL Label */ 
#line 1978
  if (! (scm_tc16_array == (long )(65535 & (int )((scm_cell *)v)->car))) {
#line 1978
    goto badarg1;
  }
  {
#line 1979
  tmp = ra2l(v, ((scm_array *)((scm_cell *)v)->cdr)->base, (size_t )0);
  }
#line 1979
  return (tmp);
  case_13: /* CIL Label */ 
  {
#line 1981
  tmp___0 = scm_vector_to_list(v);
  }
#line 1981
  return (tmp___0);
  case_21: /* CIL Label */ 
  {
#line 1983
  tmp___1 = scm_string_to_list(v);
  }
#line 1983
  return (tmp___1);
  case_71: /* CIL Label */ 
#line 1986
  data = (SCM *)((scm_cell *)v)->cdr;
#line 1988
  k = (long )((((unsigned long )((scm_cell *)v)->car >> 8) - 1UL) / ((8UL * sizeof(long )) / sizeof(char )));
  {
#line 1988
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1988
    if (! (k > 0L)) {
#line 1988
      goto while_break;
    }
#line 1989
    mask = (unsigned long )(1L << ((8UL * sizeof(long )) / sizeof(char ) - 1UL));
    {
#line 1989
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1989
      if (! mask) {
#line 1989
        goto while_break___0;
      }
#line 1990
      if ((unsigned long )*(data + k) & mask) {
#line 1990
        tmp___2 = (long )(17 << 9) + 372L;
      } else {
#line 1990
        tmp___2 = (long )(16 << 9) + 372L;
      }
      {
#line 1990
      res = scm_cons(tmp___2, res);
#line 1989
      mask >>= 1;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1988
    k --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1991
  mask = (unsigned long )(1L << (((unsigned long )((scm_cell *)v)->car >> 8) % ((8UL * sizeof(long )) / sizeof(char )) - 1UL));
  {
#line 1991
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1991
    if (! mask) {
#line 1991
      goto while_break___1;
    }
#line 1992
    if ((unsigned long )*(data + k) & mask) {
#line 1992
      tmp___3 = (long )(17 << 9) + 372L;
    } else {
#line 1992
      tmp___3 = (long )(16 << 9) + 372L;
    }
    {
#line 1992
    res = scm_cons(tmp___3, res);
#line 1991
    mask >>= 1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1993
  return (res);
  case_37: /* CIL Label */ 
#line 2006
  data___0 = (SCM *)((scm_cell *)v)->cdr;
#line 2007
  k = (long )(((unsigned long )((scm_cell *)v)->car >> 8) - 1UL);
  {
#line 2007
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2007
    if (! (k >= 0L)) {
#line 2007
      goto while_break___2;
    }
    {
#line 2008
    tmp___4 = scm_ulong2num((unsigned long )*(data___0 + k));
#line 2008
    res = scm_cons(tmp___4, res);
#line 2007
    k --;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2009
  return (res);
  case_79: /* CIL Label */ 
#line 2012
  data___1 = (SCM *)((scm_cell *)v)->cdr;
#line 2013
  k = (long )(((unsigned long )((scm_cell *)v)->car >> 8) - 1UL);
  {
#line 2013
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2013
    if (! (k >= 0L)) {
#line 2013
      goto while_break___3;
    }
    {
#line 2014
    tmp___5 = scm_long2num(*(data___1 + k));
#line 2014
    res = scm_cons(tmp___5, res);
#line 2013
    k --;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 2015
  return (res);
  case_55: /* CIL Label */ 
#line 2020
  data___2 = (short *)((SCM *)((scm_cell *)v)->cdr);
#line 2021
  k = (long )(((unsigned long )((scm_cell *)v)->car >> 8) - 1UL);
  {
#line 2021
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 2021
    if (! (k >= 0L)) {
#line 2021
      goto while_break___4;
    }
    {
#line 2022
    res = scm_cons((long )((int )*(data___2 + k) << 2) + 2L, res);
#line 2021
    k --;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 2023
  return (res);
  case_47: /* CIL Label */ 
#line 2048
  data___3 = (double *)((SCM *)((scm_cell *)v)->cdr);
#line 2049
  k = (long )(((unsigned long )((scm_cell *)v)->car >> 8) - 1UL);
  {
#line 2049
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 2049
    if (! (k >= 0L)) {
#line 2049
      goto while_break___5;
    }
    {
#line 2050
    tmp___6 = scm_makdbl(*(data___3 + k), 0.0);
#line 2050
    res = scm_cons(tmp___6, res);
#line 2049
    k --;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 2051
  return (res);
  case_53: /* CIL Label */ 
#line 2055
  data___4 = (double (*)[2])((SCM *)((scm_cell *)v)->cdr);
#line 2056
  k = (long )(((unsigned long )((scm_cell *)v)->car >> 8) - 1UL);
  {
#line 2056
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 2056
    if (! (k >= 0L)) {
#line 2056
      goto while_break___6;
    }
    {
#line 2057
    tmp___7 = scm_makdbl((*(data___4 + k))[0], (*(data___4 + k))[1]);
#line 2057
    res = scm_cons(tmp___7, res);
#line 2056
    k --;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 2058
  return (res);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 2065 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
static char s_bad_ralst[32]  = 
#line 2065
  {      (char )'B',      (char )'a',      (char )'d',      (char )' ', 
        (char )'s',      (char )'c',      (char )'m',      (char )'_', 
        (char )'a',      (char )'r',      (char )'r',      (char )'a', 
        (char )'y',      (char )' ',      (char )'c',      (char )'o', 
        (char )'n',      (char )'t',      (char )'e',      (char )'n', 
        (char )'t',      (char )'s',      (char )' ',      (char )'s', 
        (char )'c',      (char )'m',      (char )'_',      (char )'l', 
        (char )'i',      (char )'s',      (char )'t',      (char )'\000'};
#line 2067
static int l2ra(SCM lst , SCM ra , size_t base , size_t k ) ;
#line 2069 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
static char s_list_to_uniform_array[20]  = 
#line 2069
  {      (char )'l',      (char )'i',      (char )'s',      (char )'t', 
        (char )'-',      (char )'>',      (char )'u',      (char )'n', 
        (char )'i',      (char )'f',      (char )'o',      (char )'r', 
        (char )'m',      (char )'-',      (char )'a',      (char )'r', 
        (char )'r',      (char )'a',      (char )'y',      (char )'\000'};
#line 2071 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
SCM scm_list_to_uniform_array(SCM ndim , SCM prot , SCM lst ) 
{ 
  SCM shp ;
  SCM row ;
  SCM ra ;
  size_t k ;
  long n ;
  size_t tmp ;
  SCM tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;

  {
#line 2077
  shp = (long )(20 << 9) + 372L;
#line 2078
  row = lst;
#line 2082
  if (! (2 & (int )ndim)) {
    {
#line 2082
    scm_wta(ndim, (char *)1, s_list_to_uniform_array);
    }
  }
#line 2083
  k = (size_t )(ndim >> 2);
  {
#line 2084
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2084
    tmp = k;
#line 2084
    k --;
#line 2084
    if (! tmp) {
#line 2084
      goto while_break;
    }
    {
#line 2086
    n = scm_ilength(row);
    }
#line 2087
    if (! (n >= 0L)) {
      {
#line 2087
      scm_wta(lst, (char *)2, s_list_to_uniform_array);
      }
    }
    {
#line 2088
    shp = scm_cons((n << 2) + 2L, shp);
    }
#line 2089
    if (! (6 & (int )row)) {
#line 2090
      row = ((scm_cell *)row)->car;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2092
  tmp___0 = scm_reverse(shp);
#line 2092
  ra = scm_dimensions_to_uniform_array(tmp___0, prot, (long )(20 << 9) + 372L);
  }
#line 2093
  if ((long )(20 << 9) + 372L == shp) {
    {
#line 2096
    tmp___1 = scm_ilength(lst);
    }
#line 2096
    if (! (1L == tmp___1)) {
#line 2096
      goto badlst;
    }
    {
#line 2097
    scm_array_set_x(ra, ((scm_cell *)lst)->car, (long )(20 << 9) + 372L);
    }
#line 2098
    return (ra);
  }
#line 2100
  if (! (scm_tc16_array == (long )(65535 & (int )((scm_cell *)ra)->car))) {
#line 2102
    k = (size_t )0;
    {
#line 2102
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2102
      if (! (k < (unsigned long )((scm_cell *)ra)->car >> 8)) {
#line 2102
        goto while_break___0;
      }
      {
#line 2103
      scm_array_set_x(ra, ((scm_cell *)lst)->car, (SCM )((k << 2) + 2UL));
#line 2102
      k ++;
#line 2102
      lst = ((scm_cell *)lst)->cdr;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2104
    return (ra);
  }
  {
#line 2106
  tmp___2 = l2ra(lst, ra, ((scm_array *)((scm_cell *)ra)->cdr)->base, (size_t )0);
  }
#line 2106
  if (tmp___2) {
#line 2107
    return (ra);
  } else {
    badlst: 
    {
#line 2109
    scm_wta(lst, s_bad_ralst, s_list_to_uniform_array);
    }
  }
#line 2110
  return ((long )(16 << 9) + 372L);
}
}
#line 2113 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
static int l2ra(SCM lst , SCM ra , size_t base , size_t k ) 
{ 
  register long inc ;
  register long n ;
  int ok ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  SCM tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
#line 2120
  inc = ((scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array )) + k)->inc;
#line 2121
  n = (1L + ((scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array )) + k)->ubnd) - ((scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array )) + k)->lbnd;
#line 2122
  ok = 1;
#line 2123
  if (n <= 0L) {
#line 2124
    return ((long )(20 << 9) + 372L == lst);
  }
#line 2125
  if (k < (size_t )(((scm_cell *)ra)->car >> 17) - 1UL) {
    {
#line 2127
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2127
      tmp___1 = n;
#line 2127
      n --;
#line 2127
      if (! tmp___1) {
#line 2127
        goto while_break;
      }
#line 2129
      if (6 & (int )lst) {
#line 2130
        return (0);
      } else
#line 2129
      if (1 & (int )((scm_cell *)lst)->car) {
#line 2130
        return (0);
      }
#line 2131
      if (ok) {
        {
#line 2131
        tmp = l2ra(((scm_cell *)lst)->car, ra, base, k + 1UL);
        }
#line 2131
        if (tmp) {
#line 2131
          tmp___0 = 1;
        } else {
#line 2131
          tmp___0 = 0;
        }
      } else {
#line 2131
        tmp___0 = 0;
      }
#line 2131
      ok = tmp___0;
#line 2132
      base += (size_t )inc;
#line 2133
      lst = ((scm_cell *)lst)->cdr;
    }
    while_break: /* CIL Label */ ;
    }
#line 2135
    if ((long )(20 << 9) + 372L != lst) {
#line 2136
      return (0);
    }
  } else {
    {
#line 2140
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2140
      tmp___4 = n;
#line 2140
      n --;
#line 2140
      if (! tmp___4) {
#line 2140
        goto while_break___0;
      }
#line 2142
      if (6 & (int )lst) {
#line 2143
        return (0);
      } else
#line 2142
      if (1 & (int )((scm_cell *)lst)->car) {
#line 2143
        return (0);
      }
#line 2144
      if (ok) {
        {
#line 2144
        tmp___2 = scm_array_set_x(((scm_array *)((scm_cell *)ra)->cdr)->v, ((scm_cell *)lst)->car,
                                  (SCM )((base << 2) + 2UL));
        }
#line 2144
        if (tmp___2) {
#line 2144
          tmp___3 = 1;
        } else {
#line 2144
          tmp___3 = 0;
        }
      } else {
#line 2144
        tmp___3 = 0;
      }
#line 2144
      ok = tmp___3;
#line 2145
      base += (size_t )inc;
#line 2146
      lst = ((scm_cell *)lst)->cdr;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2148
    if ((long )(20 << 9) + 372L != lst) {
#line 2149
      return (0);
    }
  }
#line 2151
  return (ok);
}
}
#line 2155
static void rapr1(SCM ra , size_t j , size_t k , SCM port , scm_print_state *pstate ) ;
#line 2157 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
static void rapr1(SCM ra , size_t j , size_t k , SCM port , scm_print_state *pstate ) 
{ 
  long inc ;
  long n ;
  int enclosed ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long i ;
  SCM tmp___2 ;
  long tmp___3 ;
  SCM tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  long tmp___14 ;
  SCM z ;
  SCM tmp___15 ;
  long tmp___16 ;
  long tmp___17 ;
  SCM cz ;
  SCM tmp___18 ;
  SCM z___0 ;
  SCM tmp___19 ;
  double tmp___20 ;
  SCM tmp___21 ;
  double tmp___22 ;
  SCM tmp___23 ;
  long tmp___24 ;
  long tmp___25 ;
  char *__cil_tmp40 ;

  {
#line 2165
  inc = 1L;
#line 2166
  n = (long )((unsigned long )((scm_cell *)ra)->car >> 8);
#line 2167
  enclosed = 0;
  tail: 
  {
#line 2172
  if ((127 & (int )((scm_cell *)ra)->car) == 127) {
#line 2172
    goto case_127;
  }
#line 2224
  if ((127 & (int )((scm_cell *)ra)->car) == 21) {
#line 2224
    goto case_21;
  }
#line 2237
  if ((127 & (int )((scm_cell *)ra)->car) == 77) {
#line 2237
    goto case_77;
  }
#line 2248
  if ((127 & (int )((scm_cell *)ra)->car) == 79) {
#line 2248
    goto case_79;
  }
#line 2248
  if ((127 & (int )((scm_cell *)ra)->car) == 37) {
#line 2248
    goto case_79;
  }
#line 2258
  if ((127 & (int )((scm_cell *)ra)->car) == 55) {
#line 2258
    goto case_55;
  }
#line 2285
  if ((127 & (int )((scm_cell *)ra)->car) == 47) {
#line 2285
    goto case_47;
  }
#line 2299
  if ((127 & (int )((scm_cell *)ra)->car) == 53) {
#line 2299
    goto case_53;
  }
#line 2215
  goto switch_default;
  case_127: /* CIL Label */ 
#line 2173
  tmp___1 = enclosed;
#line 2173
  enclosed ++;
#line 2173
  if (tmp___1) {
#line 2175
    ((scm_array *)((scm_cell *)ra)->cdr)->base = j;
#line 2176
    tmp = n;
#line 2176
    n --;
#line 2176
    if (tmp > 0L) {
      {
#line 2177
      scm_iprin1(ra, port, pstate);
      }
    }
#line 2178
    j += (size_t )inc;
    {
#line 2178
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2178
      tmp___0 = n;
#line 2178
      n --;
#line 2178
      if (! (tmp___0 > 0L)) {
#line 2178
        goto while_break;
      }
      {
#line 2180
      scm_gen_putc(' ', port);
#line 2181
      ((scm_array *)((scm_cell *)ra)->cdr)->base = j;
#line 2182
      scm_iprin1(ra, port, pstate);
#line 2178
      j += (size_t )inc;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 2184
    goto switch_break;
  }
#line 2186
  if (k + 1UL < (size_t )(((scm_cell *)ra)->car >> 17)) {
#line 2189
    inc = ((scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array )) + k)->inc;
#line 2190
    i = ((scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array )) + k)->lbnd;
    {
#line 2190
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2190
      if (! (i < ((scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array )) + k)->ubnd)) {
#line 2190
        goto while_break___0;
      }
      {
#line 2192
      scm_gen_putc('(', port);
#line 2193
      rapr1(ra, j, k + 1UL, port, pstate);
#line 2194
      scm_gen_puts((enum scm_string_representation_type )0, (char *)") ", port);
#line 2195
      j += (size_t )inc;
#line 2190
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2197
    if (i == ((scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array )) + k)->ubnd) {
      {
#line 2199
      scm_gen_putc('(', port);
#line 2200
      rapr1(ra, j, k + 1UL, port, pstate);
#line 2201
      scm_gen_putc(')', port);
      }
    }
#line 2203
    goto switch_break;
  }
#line 2205
  if ((size_t )(((scm_cell *)ra)->car >> 17)) {
#line 2208
    inc = ((scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array )) + k)->inc;
#line 2209
    n = (((scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array )) + k)->ubnd - ((scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array )) + k)->lbnd) + 1L;
  } else {
#line 2212
    n = 1L;
  }
#line 2213
  ra = ((scm_array *)((scm_cell *)ra)->cdr)->v;
#line 2214
  goto tail;
  switch_default: /* CIL Label */ 
#line 2216
  tmp___3 = n;
#line 2216
  n --;
#line 2216
  if (tmp___3 > 0L) {
    {
#line 2217
    tmp___2 = scm_uniform_vector_ref(ra, (SCM )((j << 2) + 2UL));
#line 2217
    scm_iprin1(tmp___2, port, pstate);
    }
  }
#line 2218
  j += (size_t )inc;
  {
#line 2218
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2218
    tmp___5 = n;
#line 2218
    n --;
#line 2218
    if (! (tmp___5 > 0L)) {
#line 2218
      goto while_break___1;
    }
    {
#line 2220
    scm_gen_putc(' ', port);
#line 2221
    tmp___4 = scm_cvref(ra, j, (long )(18 << 9) + 372L);
#line 2221
    scm_iprin1(tmp___4, port, pstate);
#line 2218
    j += (size_t )inc;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2223
  goto switch_break;
  case_21: /* CIL Label */ 
#line 2225
  tmp___6 = n;
#line 2225
  n --;
#line 2225
  if (tmp___6 > 0L) {
    {
#line 2226
    scm_iprin1((SCM )(((int )*((char *)((scm_cell *)ra)->cdr + j) << 8) + 244), port,
               pstate);
    }
  }
#line 2227
  if (pstate->writingp) {
#line 2228
    j += (size_t )inc;
    {
#line 2228
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2228
      tmp___7 = n;
#line 2228
      n --;
#line 2228
      if (! (tmp___7 > 0L)) {
#line 2228
        goto while_break___2;
      }
      {
#line 2230
      scm_gen_putc(' ', port);
#line 2231
      scm_iprin1((SCM )(((int )*((char *)((scm_cell *)ra)->cdr + j) << 8) + 244),
                 port, pstate);
#line 2228
      j += (size_t )inc;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
#line 2234
    j += (size_t )inc;
    {
#line 2234
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2234
      tmp___8 = n;
#line 2234
      n --;
#line 2234
      if (! (tmp___8 > 0L)) {
#line 2234
        goto while_break___3;
      }
      {
#line 2235
      scm_gen_putc((int )*((char *)((scm_cell *)ra)->cdr + j), port);
#line 2234
      j += (size_t )inc;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 2236
  goto switch_break;
  case_77: /* CIL Label */ 
#line 2238
  tmp___9 = n;
#line 2238
  n --;
#line 2238
  if (tmp___9 > 0L) {
    {
#line 2239
    scm_intprint((long )*((char *)((scm_cell *)ra)->cdr + j), 10, port);
    }
  }
#line 2240
  j += (size_t )inc;
  {
#line 2240
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 2240
    tmp___10 = n;
#line 2240
    n --;
#line 2240
    if (! (tmp___10 > 0L)) {
#line 2240
      goto while_break___4;
    }
    {
#line 2242
    scm_gen_putc(' ', port);
#line 2243
    scm_intprint((long )*((char *)((scm_cell *)ra)->cdr + j), 10, port);
#line 2240
    j += (size_t )inc;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 2245
  goto switch_break;
  case_79: /* CIL Label */ 
  case_37: /* CIL Label */ 
#line 2249
  tmp___11 = n;
#line 2249
  n --;
#line 2249
  if (tmp___11 > 0L) {
    {
#line 2250
    scm_intprint(*((SCM *)((scm_cell *)ra)->cdr + j), 10, port);
    }
  }
#line 2251
  j += (size_t )inc;
  {
#line 2251
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 2251
    tmp___12 = n;
#line 2251
    n --;
#line 2251
    if (! (tmp___12 > 0L)) {
#line 2251
      goto while_break___5;
    }
    {
#line 2253
    scm_gen_putc(' ', port);
#line 2254
    scm_intprint(*((SCM *)((scm_cell *)ra)->cdr + j), 10, port);
#line 2251
    j += (size_t )inc;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 2256
  goto switch_break;
  case_55: /* CIL Label */ 
#line 2259
  tmp___13 = n;
#line 2259
  n --;
#line 2259
  if (tmp___13 > 0L) {
    {
#line 2260
    scm_intprint((long )*((short *)((scm_cell *)ra)->cdr + j), 10, port);
    }
  }
#line 2261
  j += (size_t )inc;
  {
#line 2261
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 2261
    tmp___14 = n;
#line 2261
    n --;
#line 2261
    if (! (tmp___14 > 0L)) {
#line 2261
      goto while_break___6;
    }
    {
#line 2263
    scm_gen_putc(' ', port);
#line 2264
    scm_intprint((long )*((short *)((scm_cell *)ra)->cdr + j), 10, port);
#line 2261
    j += (size_t )inc;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 2266
  goto switch_break;
  case_47: /* CIL Label */ 
#line 2286
  tmp___17 = n;
#line 2286
  n --;
#line 2286
  if (tmp___17 > 0L) {
    {
#line 2288
    tmp___15 = scm_makdbl(1.0 / 3.0, 0.0);
#line 2288
    z = tmp___15;
#line 2289
    *(((scm_dbl *)z)->real) = *((double *)((SCM *)((scm_cell *)ra)->cdr) + j);
#line 2290
    scm_floprint(z, port, pstate);
#line 2291
    j += (size_t )inc;
    }
    {
#line 2291
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 2291
      tmp___16 = n;
#line 2291
      n --;
#line 2291
      if (! (tmp___16 > 0L)) {
#line 2291
        goto while_break___7;
      }
      {
#line 2293
      scm_gen_putc(' ', port);
#line 2294
      *(((scm_dbl *)z)->real) = *((double *)((SCM *)((scm_cell *)ra)->cdr) + j);
#line 2295
      scm_floprint(z, port, pstate);
#line 2291
      j += (size_t )inc;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
  }
#line 2298
  goto switch_break;
  case_53: /* CIL Label */ 
#line 2300
  tmp___25 = n;
#line 2300
  n --;
#line 2300
  if (tmp___25 > 0L) {
    {
#line 2302
    tmp___18 = scm_makdbl(0.0, 1.0);
#line 2302
    cz = tmp___18;
#line 2302
    tmp___19 = scm_makdbl(1.0 / 3.0, 0.0);
#line 2302
    z___0 = tmp___19;
#line 2303
    tmp___20 = *((double *)((SCM *)((scm_cell *)ra)->cdr) + 2UL * j);
#line 2303
    *(((scm_dbl *)cz)->real) = tmp___20;
#line 2303
    *(((scm_dbl *)z___0)->real) = tmp___20;
#line 2304
    *((double *)((char *)((scm_cell *)cz)->cdr + sizeof(double ))) = *((double *)((SCM *)((scm_cell *)ra)->cdr) + (2UL * j + 1UL));
    }
#line 2305
    if (0.0 == *((double *)((char *)((scm_cell *)cz)->cdr + sizeof(double )))) {
#line 2305
      tmp___21 = z___0;
    } else {
#line 2305
      tmp___21 = cz;
    }
    {
#line 2305
    scm_floprint(tmp___21, port, pstate);
#line 2306
    j += (size_t )inc;
    }
    {
#line 2306
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 2306
      tmp___24 = n;
#line 2306
      n --;
#line 2306
      if (! (tmp___24 > 0L)) {
#line 2306
        goto while_break___8;
      }
      {
#line 2308
      scm_gen_putc(' ', port);
#line 2309
      tmp___22 = *((double *)((SCM *)((scm_cell *)ra)->cdr) + 2UL * j);
#line 2309
      *(((scm_dbl *)cz)->real) = tmp___22;
#line 2309
      *(((scm_dbl *)z___0)->real) = tmp___22;
#line 2310
      *((double *)((char *)((scm_cell *)cz)->cdr + sizeof(double ))) = *((double *)((SCM *)((scm_cell *)ra)->cdr) + (2UL * j + 1UL));
      }
#line 2311
      if (0.0 == *((double *)((char *)((scm_cell *)cz)->cdr + sizeof(double )))) {
#line 2311
        tmp___23 = z___0;
      } else {
#line 2311
        tmp___23 = cz;
      }
      {
#line 2311
      scm_floprint(tmp___23, port, pstate);
#line 2306
      j += (size_t )inc;
      }
    }
    while_break___8: /* CIL Label */ ;
    }
  }
#line 2314
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2317
  return;
}
}
#line 2321 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
int scm_raprin1(SCM exp___0 , SCM port , scm_print_state *pstate ) 
{ 
  SCM v ;
  size_t base ;
  long ndim ;
  register long i ;
  register long j ;
  register long w ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 2327
  v = exp___0;
#line 2328
  base = (size_t )0;
#line 2329
  scm_gen_putc('#', port);
  }
  tail: 
  {
#line 2334
  if ((127 & (int )((scm_cell *)v)->car) == 127) {
#line 2334
    goto case_127;
  }
#line 2353
  if ((127 & (int )((scm_cell *)v)->car) == 71) {
#line 2353
    goto case_71;
  }
#line 2382
  if ((127 & (int )((scm_cell *)v)->car) == 21) {
#line 2382
    goto case_21;
  }
#line 2385
  if ((127 & (int )((scm_cell *)v)->car) == 77) {
#line 2385
    goto case_77;
  }
#line 2388
  if ((127 & (int )((scm_cell *)v)->car) == 37) {
#line 2388
    goto case_37;
  }
#line 2391
  if ((127 & (int )((scm_cell *)v)->car) == 79) {
#line 2391
    goto case_79;
  }
#line 2394
  if ((127 & (int )((scm_cell *)v)->car) == 55) {
#line 2394
    goto case_55;
  }
#line 2408
  if ((127 & (int )((scm_cell *)v)->car) == 47) {
#line 2408
    goto case_47;
  }
#line 2411
  if ((127 & (int )((scm_cell *)v)->car) == 53) {
#line 2411
    goto case_53;
  }
#line 2331
  goto switch_break;
  case_127: /* CIL Label */ 
#line 2336
  ndim = (long )((size_t )(((scm_cell *)v)->car >> 17));
#line 2337
  base = ((scm_array *)((scm_cell *)v)->cdr)->base;
#line 2338
  v = ((scm_array *)((scm_cell *)v)->cdr)->v;
#line 2339
  if (scm_tc16_array == (long )(65535 & (int )((scm_cell *)v)->car)) {
    {
#line 2342
    scm_gen_puts((enum scm_string_representation_type )0, (char *)"<enclosed-array ",
                 port);
#line 2343
    rapr1(exp___0, base, (size_t )0, port, pstate);
#line 2344
    scm_gen_putc('>', port);
    }
#line 2345
    return (1);
  } else {
    {
#line 2349
    scm_intprint(ndim, 10, port);
    }
#line 2350
    goto tail;
  }
  case_71: /* CIL Label */ 
#line 2354
  if (exp___0 == v) {
    {
#line 2357
    scm_gen_putc('*', port);
#line 2358
    i = 0L;
    }
    {
#line 2358
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2358
      if (! ((unsigned long )i < ((unsigned long )((scm_cell *)exp___0)->car >> 8) / ((8UL * sizeof(long )) / sizeof(char )))) {
#line 2358
        goto while_break;
      }
#line 2360
      w = *((SCM *)((scm_cell *)exp___0)->cdr + i);
#line 2361
      j = (long )((8UL * sizeof(long )) / sizeof(char ));
      {
#line 2361
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2361
        if (! j) {
#line 2361
          goto while_break___0;
        }
#line 2363
        if (w & 1L) {
#line 2363
          tmp = '1';
        } else {
#line 2363
          tmp = '0';
        }
        {
#line 2363
        scm_gen_putc(tmp, port);
#line 2364
        w >>= 1;
#line 2361
        j --;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2358
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 2367
    j = (long )(((unsigned long )((scm_cell *)exp___0)->car >> 8) % ((8UL * sizeof(long )) / sizeof(char )));
#line 2368
    if (j) {
#line 2370
      w = *((SCM *)((scm_cell *)exp___0)->cdr + ((unsigned long )((scm_cell *)exp___0)->car >> 8) / ((8UL * sizeof(long )) / sizeof(char )));
      {
#line 2371
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2371
        if (! j) {
#line 2371
          goto while_break___1;
        }
#line 2373
        if (w & 1L) {
#line 2373
          tmp___0 = '1';
        } else {
#line 2373
          tmp___0 = '0';
        }
        {
#line 2373
        scm_gen_putc(tmp___0, port);
#line 2374
        w >>= 1;
#line 2371
        j --;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 2377
    return (1);
  } else {
    {
#line 2380
    scm_gen_putc('b', port);
    }
  }
#line 2381
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 2383
  scm_gen_putc('a', port);
  }
#line 2384
  goto switch_break;
  case_77: /* CIL Label */ 
  {
#line 2386
  scm_gen_puts((enum scm_string_representation_type )0, (char *)"bytes", port);
  }
#line 2387
  goto switch_break;
  case_37: /* CIL Label */ 
  {
#line 2389
  scm_gen_putc('u', port);
  }
#line 2390
  goto switch_break;
  case_79: /* CIL Label */ 
  {
#line 2392
  scm_gen_putc('e', port);
  }
#line 2393
  goto switch_break;
  case_55: /* CIL Label */ 
  {
#line 2395
  scm_gen_puts((enum scm_string_representation_type )0, (char *)"short", port);
  }
#line 2396
  goto switch_break;
  case_47: /* CIL Label */ 
  {
#line 2409
  scm_gen_putc('i', port);
  }
#line 2410
  goto switch_break;
  case_53: /* CIL Label */ 
  {
#line 2412
  scm_gen_putc('c', port);
  }
#line 2413
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 2416
  scm_gen_putc('(', port);
#line 2417
  rapr1(exp___0, base, (size_t )0, port, pstate);
#line 2418
  scm_gen_putc(')', port);
  }
#line 2419
  return (1);
}
}
#line 2422 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
static char s_array_prototype[16]  = 
#line 2422
  {      (char )'a',      (char )'r',      (char )'r',      (char )'a', 
        (char )'y',      (char )'-',      (char )'p',      (char )'r', 
        (char )'o',      (char )'t',      (char )'o',      (char )'t', 
        (char )'y',      (char )'p',      (char )'e',      (char )'\000'};
#line 2424 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
SCM scm_array_prototype(SCM ra ) 
{ 
  int enclosed ;
  int tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  SCM tmp___2 ;
  char *__cil_tmp7 ;

  {
#line 2428
  enclosed = 0;
#line 2429
  if (! (! (6 & (int )ra))) {
#line 2429
    goto badarg;
  }
  loop: 
  {
#line 2436
  if ((127 & (int )((scm_cell *)ra)->car) == 127) {
#line 2436
    goto case_127;
  }
#line 2442
  if ((127 & (int )((scm_cell *)ra)->car) == 13) {
#line 2442
    goto case_13;
  }
#line 2444
  if ((127 & (int )((scm_cell *)ra)->car) == 71) {
#line 2444
    goto case_71;
  }
#line 2446
  if ((127 & (int )((scm_cell *)ra)->car) == 21) {
#line 2446
    goto case_21;
  }
#line 2448
  if ((127 & (int )((scm_cell *)ra)->car) == 77) {
#line 2448
    goto case_77;
  }
#line 2450
  if ((127 & (int )((scm_cell *)ra)->car) == 37) {
#line 2450
    goto case_37;
  }
#line 2452
  if ((127 & (int )((scm_cell *)ra)->car) == 79) {
#line 2452
    goto case_79;
  }
#line 2454
  if ((127 & (int )((scm_cell *)ra)->car) == 55) {
#line 2454
    goto case_55;
  }
#line 2465
  if ((127 & (int )((scm_cell *)ra)->car) == 47) {
#line 2465
    goto case_47;
  }
#line 2467
  if ((127 & (int )((scm_cell *)ra)->car) == 53) {
#line 2467
    goto case_53;
  }
#line 2434
  goto badarg;
  badarg: 
  switch_default: /* CIL Label */ 
  {
#line 2435
  scm_wta(ra, (char *)1, s_array_prototype);
  }
  case_127: /* CIL Label */ 
#line 2437
  if (! (scm_tc16_array == (long )(65535 & (int )((scm_cell *)ra)->car))) {
#line 2437
    goto badarg;
  }
#line 2438
  tmp = enclosed;
#line 2438
  enclosed ++;
#line 2438
  if (tmp) {
#line 2439
    return ((long )(21 << 9) + 372L);
  }
#line 2440
  ra = ((scm_array *)((scm_cell *)ra)->cdr)->v;
#line 2441
  goto loop;
  case_13: /* CIL Label */ 
#line 2443
  return ((long )(20 << 9) + 372L);
  case_71: /* CIL Label */ 
#line 2445
  return ((long )(17 << 9) + 372L);
  case_21: /* CIL Label */ 
#line 2447
  return ((SCM )((97 << 8) + 244));
  case_77: /* CIL Label */ 
#line 2449
  return ((SCM )244);
  case_37: /* CIL Label */ 
#line 2451
  return ((1L << 2) + 2L);
  case_79: /* CIL Label */ 
#line 2453
  return ((-1L << 2) + 2L);
  case_55: /* CIL Label */ 
  {
#line 2455
  tmp___0 = scm_intern((char *)"s", (size_t )1);
  }
#line 2455
  return (((scm_cell *)tmp___0)->cdr);
  case_47: /* CIL Label */ 
  {
#line 2466
  tmp___1 = scm_makdbl(1.0 / 3.0, 0.0);
  }
#line 2466
  return (tmp___1);
  case_53: /* CIL Label */ 
  {
#line 2468
  tmp___2 = scm_makdbl(0.0, 1.0);
  }
#line 2468
  return (tmp___2);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 2474
static SCM markra(SCM ptr ) ;
#line 2476 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
static SCM markra(SCM ptr ) 
{ 


  {
#line 2480
  if (128 & (int )((scm_cell *)ptr)->car) {
#line 2480
    return ((long )(16 << 9) + 372L);
  }
#line 2482
  ((scm_cell *)ptr)->car |= 128L;
#line 2483
  return (((scm_array *)((scm_cell *)ptr)->cdr)->v);
}
}
#line 2487
static size_t freera(SCM ptr ) ;
#line 2489 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
static size_t freera(SCM ptr ) 
{ 


  {
  {
#line 2493
  scm_must_free((char *)((scm_cell *)ptr)->cdr);
  }
#line 2494
  return (sizeof(scm_array ) + (size_t )(((scm_cell *)ptr)->car >> 17) * sizeof(scm_array_dim ));
}
}
#line 2497 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
static scm_smobfuns rasmob  =    {& markra, & freera, & scm_raprin1, & scm_array_equal_p};
#line 2503 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
void scm_init_unif(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.x"
  scm_make_gsubr(s_uniform_vector_length, 1, 0, 0, (SCM (*)())(& scm_uniform_vector_length));
#line 2
  scm_make_gsubr(s_array_p, 1, 1, 0, (SCM (*)())(& scm_array_p));
#line 3
  scm_make_gsubr(s_array_rank, 1, 0, 0, (SCM (*)())(& scm_array_rank));
#line 4
  scm_make_gsubr(s_array_dimensions, 1, 0, 0, (SCM (*)())(& scm_array_dimensions));
#line 5
  scm_make_gsubr(s_dimensions_to_uniform_array, 2, 0, 1, (SCM (*)())(& scm_dimensions_to_uniform_array));
#line 6
  scm_make_gsubr(s_make_shared_array, 2, 0, 1, (SCM (*)())(& scm_make_shared_array));
#line 7
  scm_make_gsubr(s_transpose_array, 0, 0, 1, (SCM (*)())(& scm_transpose_array));
#line 8
  scm_make_gsubr(s_enclose_array, 0, 0, 1, (SCM (*)())(& scm_enclose_array));
#line 9
  scm_make_gsubr(s_array_in_bounds_p, 0, 0, 1, (SCM (*)())(& scm_array_in_bounds_p));
#line 10
  scm_make_gsubr(s_array_ref, 1, 0, 1, (SCM (*)())(& scm_uniform_vector_ref));
#line 11
  scm_make_gsubr(s_uniform_vector_ref, 2, 0, 0, (SCM (*)())(& scm_uniform_vector_ref));
#line 12
  scm_make_gsubr(s_uniform_array_set1_x, 3, 0, 0, (SCM (*)())(& scm_array_set_x));
#line 13
  scm_make_gsubr(s_array_set_x, 2, 0, 1, (SCM (*)())(& scm_array_set_x));
#line 14
  scm_make_gsubr(s_array_contents, 1, 1, 0, (SCM (*)())(& scm_array_contents));
#line 15
  scm_make_gsubr(s_uniform_array_read_x, 1, 1, 0, (SCM (*)())(& scm_uniform_array_read_x));
#line 16
  scm_make_gsubr(s_uniform_array_write, 1, 1, 0, (SCM (*)())(& scm_uniform_array_write));
#line 17
  scm_make_gsubr(s_bit_count, 2, 0, 0, (SCM (*)())(& scm_bit_count));
#line 18
  scm_make_gsubr(s_bit_position, 3, 0, 0, (SCM (*)())(& scm_bit_position));
#line 19
  scm_make_gsubr(s_bit_set_star_x, 3, 0, 0, (SCM (*)())(& scm_bit_set_star_x));
#line 20
  scm_make_gsubr(s_bit_count_star, 3, 0, 0, (SCM (*)())(& scm_bit_count_star));
#line 21
  scm_make_gsubr(s_bit_invert_x, 1, 0, 0, (SCM (*)())(& scm_bit_invert_x));
#line 22
  scm_make_gsubr(s_string_upcase_x, 1, 0, 0, (SCM (*)())(& scm_string_upcase_x));
#line 23
  scm_make_gsubr(s_string_downcase_x, 1, 0, 0, (SCM (*)())(& scm_string_downcase_x));
#line 24
  scm_make_gsubr(s_array_to_list, 1, 0, 0, (SCM (*)())(& scm_array_to_list));
#line 25
  scm_make_gsubr(s_list_to_uniform_array, 3, 0, 0, (SCM (*)())(& scm_list_to_uniform_array));
#line 26
  scm_make_gsubr(s_array_prototype, 1, 0, 0, (SCM (*)())(& scm_array_prototype));
#line 2507 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/unif.c"
  scm_tc16_array = scm_newsmob(& rasmob);
#line 2508
  scm_add_feature((char *)"array");
  }
#line 2509
  return;
}
}
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 65 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag *__env ) ;
#line 82
extern  __attribute__((__nothrow__, __noreturn__)) void longjmp(struct __jmp_buf_tag *__env ,
                                                                int __val ) ;
#line 92 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/print.h"
void scm_prin1(SCM exp___0 , SCM port , int writingp ) ;
#line 69 "../libguile/debug.h"
scm_option scm_debug_opts[12] ;
#line 132
scm_debug_frame *scm_last_debug_frame ;
#line 51 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/alist.h"
SCM scm_acons(SCM w , SCM x , SCM y ) ;
#line 51 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/dynwind.h"
void scm_dowinds(SCM to , long delta ) ;
#line 52 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/backtrace.h"
void scm_display_error_message(SCM message , SCM args , SCM port ) ;
#line 83 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stackchk.h"
int scm_stack_checking_enabled_p ;
#line 55 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/throw.h"
SCM scm_internal_catch(SCM tag , SCM (*body)(void *data , SCM jmpbuf ) , void *body_data ,
                       SCM (*handler)(void *data , SCM tag , SCM throw_args ) , void *handler_data ) ;
#line 75
SCM scm_body_thunk(void *body_data , SCM jmpbuf ) ;
#line 78
SCM scm_handle_by_proc(void *handler_data , SCM tag , SCM throw_args ) ;
#line 79
SCM scm_handle_by_message(void *handler_data , SCM tag , SCM args ) ;
#line 81
SCM scm_catch(SCM tag , SCM thunk , SCM handler ) ;
#line 82
SCM scm_lazy_catch(SCM tag , SCM thunk , SCM handler ) ;
#line 83
SCM scm_ithrow(SCM key , SCM args , int noreturn ) ;
#line 84
SCM scm_throw(SCM key , SCM args ) ;
#line 85
void scm_init_throw(void) ;
#line 62 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/throw.c"
static int scm_tc16_jmpbuffer  ;
#line 78
static size_t freejb(SCM jbsmob___0 ) ;
#line 80 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/throw.c"
static size_t freejb(SCM jbsmob___0 ) 
{ 


  {
  {
#line 84
  scm_must_free((char *)((scm_cell *)jbsmob___0)->cdr);
  }
#line 85
  return (sizeof(scm_cell ));
}
}
#line 89
static int printjb(SCM exp___0 , SCM port , scm_print_state *pstate ) ;
#line 90 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/throw.c"
static int printjb(SCM exp___0 , SCM port , scm_print_state *pstate ) 
{ 
  char const   *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 96
  scm_gen_puts((enum scm_string_representation_type )0, (char *)"#<jmpbuffer ", port);
  }
#line 97
  if (((scm_cell *)exp___0)->car & (1L << 16L)) {
#line 97
    tmp = "(active) ";
  } else {
#line 97
    tmp = "(inactive) ";
  }
  {
#line 97
  scm_gen_puts((enum scm_string_representation_type )0, (char *)tmp, port);
#line 98
  scm_intprint((SCM )((jmp_buf *)((scm_cell *)((scm_cell *)exp___0)->cdr)->cdr), 16,
               port);
#line 99
  scm_gen_putc('>', port);
  }
#line 100
  return (1);
}
}
#line 103 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/throw.c"
static scm_smobfuns jbsmob  =    {& scm_mark0, & freejb, & printjb, (SCM (*)(SCM  , SCM  ))0};
#line 114
static SCM make_jmpbuf(void) ;
#line 115 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/throw.c"
static SCM make_jmpbuf(void) 
{ 
  SCM answer ;
  char *mem ;
  char *tmp ;
  char *__cil_tmp4 ;

  {
#line 119
  if (6 & (int )scm_freelist) {
    {
#line 119
    answer = scm_gc_for_newcell();
    }
  } else {
#line 119
    answer = scm_freelist;
#line 119
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 119
    scm_cells_allocated ++;
  }
  {
#line 120
  scm_ints_disabled ++;
#line 123
  tmp = scm_must_malloc((long )sizeof(scm_cell ), (char *)"jb");
#line 123
  mem = tmp;
#line 124
  ((scm_cell *)answer)->cdr = (SCM )mem;
#line 126
  ((scm_cell *)answer)->car = (SCM )scm_tc16_jmpbuffer;
#line 127
  ((scm_cell *)((scm_cell *)answer)->cdr)->cdr = (SCM )((jmp_buf *)0);
#line 128
  ((scm_cell *)answer)->car &= ~ (1L << 16L);
#line 130
  scm_ints_disabled --;
  }
#line 130
  if (! scm_ints_disabled) {
#line 130
    scm_async_clock --;
#line 130
    if (0U == scm_async_clock) {
      {
#line 130
      scm_async_click();
      }
    }
  }
#line 131
  return (answer);
}
}
#line 184 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/throw.c"
SCM scm_internal_catch(SCM tag , SCM (*body)(void *data , SCM jmpbuf ) , void *body_data ,
                       SCM (*handler)(void *data , SCM tag , SCM throw_args ) , void *handler_data ) 
{ 
  struct jmp_buf_and_retval jbr ;
  SCM jmpbuf ;
  SCM answer ;
  SCM throw_tag ;
  SCM throw_args ;
  int tmp ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  int __cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;

  {
  {
#line 196
  jmpbuf = make_jmpbuf();
#line 197
  answer = (long )(20 << 9) + 372L;
#line 198
  scm_root->dynwinds = scm_acons(tag, jmpbuf, scm_root->dynwinds);
#line 199
  ((scm_cell *)((scm_cell *)jmpbuf)->cdr)->cdr = (SCM )(& jbr.buf);
#line 201
  ((scm_cell *)((scm_cell *)jmpbuf)->cdr)->car = (SCM )scm_last_debug_frame;
#line 203
  tmp = _setjmp((struct __jmp_buf_tag *)(jbr.buf));
  }
#line 203
  if (tmp) {
#line 209
    scm_stack_checking_enabled_p = (int )scm_debug_opts[11].val;
#line 211
    scm_ints_disabled ++;
#line 212
    ((scm_cell *)jmpbuf)->car &= ~ (1L << 16L);
#line 213
    scm_root->dynwinds = ((scm_cell *)scm_root->dynwinds)->cdr;
#line 214
    scm_ints_disabled --;
#line 214
    if (! scm_ints_disabled) {
#line 214
      scm_async_clock --;
#line 214
      if (0U == scm_async_clock) {
        {
#line 214
        scm_async_click();
        }
      }
    }
    {
#line 215
    throw_args = jbr.retval;
#line 216
    throw_tag = jbr.throw_tag;
#line 217
    jbr.throw_tag = (long )(20 << 9) + 372L;
#line 218
    jbr.retval = (long )(20 << 9) + 372L;
#line 219
    answer = (*handler)(handler_data, throw_tag, throw_args);
    }
  } else {
    {
#line 223
    ((scm_cell *)jmpbuf)->car |= 1L << 16L;
#line 224
    answer = (*body)(body_data, jmpbuf);
#line 225
    scm_ints_disabled ++;
#line 226
    ((scm_cell *)jmpbuf)->car &= ~ (1L << 16L);
#line 227
    scm_root->dynwinds = ((scm_cell *)scm_root->dynwinds)->cdr;
#line 228
    scm_ints_disabled --;
    }
#line 228
    if (! scm_ints_disabled) {
#line 228
      scm_async_clock --;
#line 228
      if (0U == scm_async_clock) {
        {
#line 228
        scm_async_click();
        }
      }
    }
  }
#line 230
  return (answer);
}
}
#line 242 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/throw.c"
SCM scm_body_thunk(void *body_data , SCM jmpbuf ) 
{ 
  struct scm_body_thunk_data *c ;
  SCM tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;

  {
#line 247
  c = (struct scm_body_thunk_data *)body_data;
#line 249
  if (c->tag == (long )(16 << 9) + 372L) {
    {
#line 250
    tmp = scm_cons(jmpbuf, (long )(20 << 9) + 372L);
#line 250
    tmp___0 = scm_apply(c->body_proc, tmp, (long )(20 << 9) + 372L);
    }
#line 250
    return (tmp___0);
  } else {
    {
#line 252
    tmp___1 = scm_apply(c->body_proc, (long )(20 << 9) + 372L, (long )(20 << 9) + 372L);
    }
#line 252
    return (tmp___1);
  }
}
}
#line 261 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/throw.c"
SCM scm_handle_by_proc(void *handler_data , SCM tag , SCM throw_args ) 
{ 
  SCM *handler_proc_p ;
  SCM tmp ;
  SCM tmp___0 ;

  {
  {
#line 267
  handler_proc_p = (SCM *)handler_data;
#line 269
  tmp = scm_cons(tag, throw_args);
#line 269
  tmp___0 = scm_apply(*handler_proc_p, tmp, (long )(20 << 9) + 372L);
  }
#line 269
  return (tmp___0);
}
}
#line 273 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/throw.c"
static char s_catch[6]  = {      (char )'c',      (char )'a',      (char )'t',      (char )'c', 
        (char )'h',      (char )'\000'};
#line 274 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/throw.c"
SCM scm_catch(SCM tag , SCM thunk , SCM handler ) 
{ 
  struct scm_body_thunk_data c ;
  SCM tmp ;
  void *__cil_tmp6 ;

  {
#line 282
  if (! (tag == (long )(16 << 9) + 372L)) {
#line 282
    if (! (6 & (int )tag)) {
#line 282
      if (! ((125 & (int )((scm_cell *)tag)->car) == 5)) {
#line 282
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 282
    if (! (tag == (long )(17 << 9) + 372L)) {
      {
#line 282
      scm_wta(tag, (char *)1, s_catch);
      }
    }
  }
  {
#line 287
  c.tag = tag;
#line 288
  c.body_proc = thunk;
#line 295
  tmp = scm_internal_catch(tag, & scm_body_thunk, (void *)(& c), & scm_handle_by_proc,
                           (void *)(& handler));
  }
#line 295
  return (tmp);
}
}
#line 300 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/throw.c"
static char s_lazy_catch[11]  = 
#line 300
  {      (char )'l',      (char )'a',      (char )'z',      (char )'y', 
        (char )'-',      (char )'c',      (char )'a',      (char )'t', 
        (char )'c',      (char )'h',      (char )'\000'};
#line 301 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/throw.c"
SCM scm_lazy_catch(SCM tag , SCM thunk , SCM handler ) 
{ 
  SCM answer ;

  {
#line 308
  if (! (6 & (int )tag)) {
#line 308
    if (! ((125 & (int )((scm_cell *)tag)->car) == 5)) {
#line 308
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 308
  if (! (tag == (long )(17 << 9) + 372L)) {
    {
#line 308
    scm_wta(tag, (char *)1, s_lazy_catch);
    }
  }
  {
#line 311
  scm_ints_disabled ++;
#line 312
  scm_root->dynwinds = scm_acons(tag, handler, scm_root->dynwinds);
#line 313
  scm_ints_disabled --;
  }
#line 313
  if (! scm_ints_disabled) {
#line 313
    scm_async_clock --;
#line 313
    if (0U == scm_async_clock) {
      {
#line 313
      scm_async_click();
      }
    }
  }
  {
#line 314
  answer = scm_apply(thunk, (long )(20 << 9) + 372L, (long )(20 << 9) + 372L);
#line 315
  scm_ints_disabled ++;
#line 316
  scm_root->dynwinds = ((scm_cell *)scm_root->dynwinds)->cdr;
#line 317
  scm_ints_disabled --;
  }
#line 317
  if (! scm_ints_disabled) {
#line 317
    scm_async_clock --;
#line 317
    if (0U == scm_async_clock) {
      {
#line 317
      scm_async_click();
      }
    }
  }
#line 318
  return (answer);
}
}
#line 335 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/throw.c"
SCM scm_handle_by_message(void *handler_data , SCM tag , SCM args ) 
{ 
  char *prog_name ;
  SCM p ;
  SCM message ;
  SCM parts ;
  long tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 341
  prog_name = (char *)handler_data;
#line 342
  p = scm_root->def_errp;
#line 344
  if (! prog_name) {
#line 345
    prog_name = (char *)"guile";
  }
  {
#line 347
  scm_gen_puts((enum scm_string_representation_type )0, prog_name, p);
#line 348
  scm_gen_puts((enum scm_string_representation_type )0, (char *)": ", p);
#line 350
  tmp = scm_ilength(args);
  }
#line 350
  if (tmp >= 3L) {
    {
#line 352
    message = ((scm_cell *)((scm_cell *)args)->cdr)->car;
#line 353
    parts = ((scm_cell *)((scm_cell *)((scm_cell *)args)->cdr)->cdr)->car;
#line 355
    scm_display_error_message(message, parts, p);
    }
  } else {
    {
#line 359
    scm_gen_puts((enum scm_string_representation_type )0, (char *)"uncaught throw to ",
                 p);
#line 360
    scm_prin1(tag, p, 0);
#line 361
    scm_gen_puts((enum scm_string_representation_type )0, (char *)": ", p);
#line 362
    scm_prin1(args, p, 1);
#line 363
    scm_gen_putc('\n', p);
    }
  }
  {
#line 366
  exit(2);
  }
}
}
#line 370
static char s_throw[6] ;
#line 371 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/throw.c"
SCM scm_ithrow(SCM key , SCM args , int noreturn ) 
{ 
  SCM jmpbuf ;
  SCM wind_goal ;
  SCM dynpair ;
  SCM winds ;
  SCM this_key ;
  long tmp ;
  SCM oldwinds ;
  SCM handle ;
  SCM answer ;
  long tmp___0 ;
  long tmp___1 ;
  SCM tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  struct jmp_buf_and_retval *jbr ;
  long tmp___5 ;
  long tmp___6 ;
  char *__cil_tmp21 ;

  {
#line 380
  if (! (6 & (int )key)) {
#line 380
    if ((65535 & (int )((scm_cell *)key)->car) == scm_tc16_jmpbuffer) {
#line 382
      jmpbuf = key;
#line 383
      if (noreturn) {
#line 385
        if (! (((scm_cell *)jmpbuf)->car & (1L << 16L))) {
          {
#line 385
          scm_wta(jmpbuf, (char *)"throw to dynamically inactive catch", s_throw);
          }
        }
      } else
#line 389
      if (! (((scm_cell *)jmpbuf)->car & (1L << 16L))) {
#line 390
        return ((long )(21 << 9) + 372L);
      }
    } else {
#line 380
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 394
    dynpair = (long )(18 << 9) + 372L;
#line 397
    if (noreturn) {
#line 399
      if (! (6 & (int )key)) {
#line 399
        if (! ((125 & (int )((scm_cell *)key)->car) == 5)) {
          {
#line 399
          scm_wta(key, (char *)1, s_throw);
          }
        }
      } else {
        {
#line 399
        scm_wta(key, (char *)1, s_throw);
        }
      }
    } else
#line 402
    if (! (6 & (int )key)) {
#line 402
      if (! ((125 & (int )((scm_cell *)key)->car) == 5)) {
#line 403
        return ((long )(21 << 9) + 372L);
      }
    } else {
#line 403
      return ((long )(21 << 9) + 372L);
    }
#line 407
    winds = scm_root->dynwinds;
    {
#line 407
    while (1) {
      while_continue: /* CIL Label */ ;
#line 407
      if (! (! (6 & (int )winds))) {
#line 407
        goto while_break;
      }
#line 409
      if (! (! (1 & (int )((scm_cell *)winds)->car))) {
        {
#line 410
        abort();
        }
      }
#line 412
      dynpair = ((scm_cell *)winds)->car;
#line 413
      if (! (6 & (int )dynpair)) {
#line 413
        if (! (1 & (int )((scm_cell *)dynpair)->car)) {
#line 415
          this_key = ((scm_cell *)dynpair)->car;
#line 417
          if (this_key == (long )(17 << 9) + 372L) {
#line 418
            goto while_break;
          } else
#line 417
          if (this_key == key) {
#line 418
            goto while_break;
          }
        }
      }
#line 407
      winds = ((scm_cell *)winds)->cdr;
    }
    while_break: /* CIL Label */ ;
    }
#line 425
    if (winds == (long )(20 << 9) + 372L) {
      {
#line 426
      abort();
      }
    }
#line 428
    if (6 & (int )winds) {
      {
#line 429
      abort();
      }
    } else
#line 428
    if (1 & (int )((scm_cell *)winds)->car) {
      {
#line 429
      abort();
      }
    }
#line 431
    if (dynpair != (long )(16 << 9) + 372L) {
#line 432
      jmpbuf = ((scm_cell *)dynpair)->cdr;
    } else
#line 435
    if (! noreturn) {
#line 436
      return ((long )(21 << 9) + 372L);
    } else {
      {
#line 439
      scm_root->exitval = scm_cons(key, args);
#line 440
      tmp = scm_ilength(scm_root->dynwinds);
#line 440
      scm_dowinds((long )(20 << 9) + 372L, tmp);
#line 442
      scm_last_debug_frame = ((scm_contregs *)((char *)((scm_cell *)scm_root->rootcont)->cdr))->dframe;
#line 444
      longjmp((struct __jmp_buf_tag *)(((scm_contregs *)((char *)((scm_cell *)scm_root->rootcont)->cdr))->jmpbuf),
              1);
      }
    }
  }
#line 448
  wind_goal = scm_root->dynwinds;
  {
#line 448
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 448
    if (! (((scm_cell *)((scm_cell *)wind_goal)->car)->cdr != jmpbuf)) {
#line 448
      goto while_break___0;
    }
#line 448
    wind_goal = ((scm_cell *)wind_goal)->cdr;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 452
  if (! ((65535 & (int )((scm_cell *)jmpbuf)->car) == scm_tc16_jmpbuffer)) {
    {
#line 454
    oldwinds = scm_root->dynwinds;
#line 456
    tmp___0 = scm_ilength(scm_root->dynwinds);
#line 456
    tmp___1 = scm_ilength(wind_goal);
#line 456
    scm_dowinds(wind_goal, tmp___0 - tmp___1);
#line 457
    scm_ints_disabled ++;
#line 458
    handle = scm_root->dynwinds;
#line 459
    scm_root->dynwinds = ((scm_cell *)scm_root->dynwinds)->cdr;
#line 460
    scm_ints_disabled --;
    }
#line 460
    if (! scm_ints_disabled) {
#line 460
      scm_async_clock --;
#line 460
      if (0U == scm_async_clock) {
        {
#line 460
        scm_async_click();
        }
      }
    }
    {
#line 461
    tmp___2 = scm_cons(key, args);
#line 461
    answer = scm_apply(jmpbuf, tmp___2, (long )(20 << 9) + 372L);
#line 462
    scm_ints_disabled ++;
#line 463
    ((scm_cell *)handle)->cdr = scm_root->dynwinds;
#line 464
    scm_root->dynwinds = handle;
#line 465
    scm_ints_disabled --;
    }
#line 465
    if (! scm_ints_disabled) {
#line 465
      scm_async_clock --;
#line 465
      if (0U == scm_async_clock) {
        {
#line 465
        scm_async_click();
        }
      }
    }
    {
#line 466
    tmp___3 = scm_ilength(scm_root->dynwinds);
#line 466
    tmp___4 = scm_ilength(oldwinds);
#line 466
    scm_dowinds(oldwinds, tmp___3 - tmp___4);
    }
#line 467
    return (answer);
  } else {
    {
#line 472
    tmp___5 = scm_ilength(scm_root->dynwinds);
#line 472
    tmp___6 = scm_ilength(wind_goal);
#line 472
    scm_dowinds(wind_goal, tmp___5 - tmp___6);
#line 473
    jbr = (struct jmp_buf_and_retval *)((jmp_buf *)((scm_cell *)((scm_cell *)jmpbuf)->cdr)->cdr);
#line 474
    jbr->throw_tag = key;
#line 475
    jbr->retval = args;
    }
  }
  {
#line 478
  scm_last_debug_frame = (scm_debug_frame *)((scm_cell *)((scm_cell *)jmpbuf)->cdr)->car;
#line 480
  longjmp((struct __jmp_buf_tag *)(*((jmp_buf *)((scm_cell *)((scm_cell *)jmpbuf)->cdr)->cdr)),
          1);
  }
}
}
#line 484 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/throw.c"
static char s_throw[6]  = {      (char )'t',      (char )'h',      (char )'r',      (char )'o', 
        (char )'w',      (char )'\000'};
#line 485 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/throw.c"
SCM scm_throw(SCM key , SCM args ) 
{ 
  SCM tmp ;

  {
  {
#line 491
  tmp = scm_ithrow(key, args, 1);
  }
#line 491
  return (tmp);
}
}
#line 495 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/throw.c"
void scm_init_throw(void) 
{ 
  long tmp ;

  {
  {
#line 498
  tmp = scm_newsmob(& jbsmob);
#line 498
  scm_tc16_jmpbuffer = (int )tmp;
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/throw.x"
  scm_make_gsubr(s_catch, 3, 0, 0, (SCM (*)())(& scm_catch));
#line 2
  scm_make_gsubr(s_lazy_catch, 3, 0, 0, (SCM (*)())(& scm_lazy_catch));
#line 3
  scm_make_gsubr(s_throw, 1, 0, 1, (SCM (*)())(& scm_throw));
  }
#line 500 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/throw.c"
  return;
}
}
#line 55 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/tag.h"
SCM scm_tag(SCM x ) ;
#line 56
void scm_init_tag(void) ;
#line 50 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/tag.c"
static SCM scm_utag_immediate_integer  =    (long )(16 << 9) + 372L;
#line 51 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/tag.c"
static SCM scm_utag_immediate_char  =    (long )(16 << 9) + 372L;
#line 52 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/tag.c"
static SCM scm_utag_pair  =    (long )(16 << 9) + 372L;
#line 53 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/tag.c"
static SCM scm_utag_closure  =    (long )(16 << 9) + 372L;
#line 54 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/tag.c"
static SCM scm_utag_symbol  =    (long )(16 << 9) + 372L;
#line 55 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/tag.c"
static SCM scm_utag_vector  =    (long )(16 << 9) + 372L;
#line 56 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/tag.c"
static SCM scm_utag_wvect  =    (long )(16 << 9) + 372L;
#line 57 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/tag.c"
static SCM scm_utag_bvect  =    (long )(16 << 9) + 372L;
#line 58 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/tag.c"
static SCM scm_utag_byvect  =    (long )(16 << 9) + 372L;
#line 59 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/tag.c"
static SCM scm_utag_svect  =    (long )(16 << 9) + 372L;
#line 60 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/tag.c"
static SCM scm_utag_ivect  =    (long )(16 << 9) + 372L;
#line 61 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/tag.c"
static SCM scm_utag_uvect  =    (long )(16 << 9) + 372L;
#line 62 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/tag.c"
static SCM scm_utag_fvect  =    (long )(16 << 9) + 372L;
#line 63 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/tag.c"
static SCM scm_utag_dvect  =    (long )(16 << 9) + 372L;
#line 64 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/tag.c"
static SCM scm_utag_cvect  =    (long )(16 << 9) + 372L;
#line 65 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/tag.c"
static SCM scm_utag_string  =    (long )(16 << 9) + 372L;
#line 66 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/tag.c"
static SCM scm_utag_mb_string  =    (long )(16 << 9) + 372L;
#line 67 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/tag.c"
static SCM scm_utag_substring  =    (long )(16 << 9) + 372L;
#line 68 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/tag.c"
static SCM scm_utag_mb_substring  =    (long )(16 << 9) + 372L;
#line 69 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/tag.c"
static SCM scm_utag_asubr  =    (long )(16 << 9) + 372L;
#line 70 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/tag.c"
static SCM scm_utag_subr_0  =    (long )(16 << 9) + 372L;
#line 71 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/tag.c"
static SCM scm_utag_subr_1  =    (long )(16 << 9) + 372L;
#line 72 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/tag.c"
static SCM scm_utag_cxr  =    (long )(16 << 9) + 372L;
#line 73 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/tag.c"
static SCM scm_utag_subr_3  =    (long )(16 << 9) + 372L;
#line 74 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/tag.c"
static SCM scm_utag_subr_2  =    (long )(16 << 9) + 372L;
#line 75 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/tag.c"
static SCM scm_utag_rpsubr  =    (long )(16 << 9) + 372L;
#line 76 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/tag.c"
static SCM scm_utag_subr_1o  =    (long )(16 << 9) + 372L;
#line 77 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/tag.c"
static SCM scm_utag_subr_2o  =    (long )(16 << 9) + 372L;
#line 78 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/tag.c"
static SCM scm_utag_lsubr_2  =    (long )(16 << 9) + 372L;
#line 79 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/tag.c"
static SCM scm_utag_lsubr  =    (long )(16 << 9) + 372L;
#line 80 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/tag.c"
static SCM scm_utag_smob_base  =    (long )(16 << 9) + 372L;
#line 81 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/tag.c"
static SCM scm_utag_port_base  =    (long )(16 << 9) + 372L;
#line 82 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/tag.c"
static SCM scm_utag_flag_base  =    (long )(16 << 9) + 372L;
#line 83 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/tag.c"
static SCM scm_utag_struct_base  =    (long )(16 << 9) + 372L;
#line 86 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/tag.c"
static char s_tag[4]  = {      (char )'t',      (char )'a',      (char )'g',      (char )'\000'};
#line 88 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/tag.c"
SCM scm_tag(SCM x ) 
{ 
  int tag ;
  int tag___0 ;
  int tag___1 ;
  int tag___2 ;

  {
  {
#line 95
  if ((7 & (int )x) == 6) {
#line 95
    goto case_6;
  }
#line 95
  if ((7 & (int )x) == 2) {
#line 95
    goto case_6;
  }
#line 98
  if ((7 & (int )x) == 4) {
#line 98
    goto case_4;
  }
#line 108
  if ((7 & (int )x) == 0) {
#line 108
    goto case_0;
  }
#line 199
  if ((7 & (int )x) == 3) {
#line 199
    goto case_3___0;
  }
#line 199
  if ((7 & (int )x) == 7) {
#line 199
    goto case_3___0;
  }
#line 199
  if ((7 & (int )x) == 5) {
#line 199
    goto case_3___0;
  }
#line 199
  if ((7 & (int )x) == 1) {
#line 199
    goto case_3___0;
  }
#line 92
  goto switch_break;
  case_6: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 96
  return (((scm_cell *)scm_utag_immediate_integer)->cdr);
  case_4: /* CIL Label */ 
#line 99
  if (((int )x & 255) == 244) {
#line 100
    return (((scm_cell *)scm_utag_immediate_char)->cdr);
  } else {
#line 104
    tag = (int )((((x >> 8) & 255L) << 2) + 2L);
#line 105
    return ((((((scm_cell *)scm_utag_flag_base)->cdr >> 2) | (long )(tag << 8)) << 2) + 2L);
  }
  case_0: /* CIL Label */ 
  {
#line 111
  if ((127 & (int )((scm_cell *)x)->car) == 120) {
#line 111
    goto case_120;
  }
#line 111
  if ((127 & (int )((scm_cell *)x)->car) == 112) {
#line 111
    goto case_120;
  }
#line 111
  if ((127 & (int )((scm_cell *)x)->car) == 104) {
#line 111
    goto case_120;
  }
#line 111
  if ((127 & (int )((scm_cell *)x)->car) == 96) {
#line 111
    goto case_120;
  }
#line 111
  if ((127 & (int )((scm_cell *)x)->car) == 88) {
#line 111
    goto case_120;
  }
#line 111
  if ((127 & (int )((scm_cell *)x)->car) == 80) {
#line 111
    goto case_120;
  }
#line 111
  if ((127 & (int )((scm_cell *)x)->car) == 72) {
#line 111
    goto case_120;
  }
#line 111
  if ((127 & (int )((scm_cell *)x)->car) == 64) {
#line 111
    goto case_120;
  }
#line 111
  if ((127 & (int )((scm_cell *)x)->car) == 56) {
#line 111
    goto case_120;
  }
#line 111
  if ((127 & (int )((scm_cell *)x)->car) == 48) {
#line 111
    goto case_120;
  }
#line 111
  if ((127 & (int )((scm_cell *)x)->car) == 40) {
#line 111
    goto case_120;
  }
#line 111
  if ((127 & (int )((scm_cell *)x)->car) == 32) {
#line 111
    goto case_120;
  }
#line 111
  if ((127 & (int )((scm_cell *)x)->car) == 24) {
#line 111
    goto case_120;
  }
#line 111
  if ((127 & (int )((scm_cell *)x)->car) == 16) {
#line 111
    goto case_120;
  }
#line 111
  if ((127 & (int )((scm_cell *)x)->car) == 8) {
#line 111
    goto case_120;
  }
#line 111
  if ((127 & (int )((scm_cell *)x)->car) == 0) {
#line 111
    goto case_120;
  }
#line 113
  if ((127 & (int )((scm_cell *)x)->car) == 123) {
#line 113
    goto case_123;
  }
#line 113
  if ((127 & (int )((scm_cell *)x)->car) == 115) {
#line 113
    goto case_123;
  }
#line 113
  if ((127 & (int )((scm_cell *)x)->car) == 107) {
#line 113
    goto case_123;
  }
#line 113
  if ((127 & (int )((scm_cell *)x)->car) == 99) {
#line 113
    goto case_123;
  }
#line 113
  if ((127 & (int )((scm_cell *)x)->car) == 91) {
#line 113
    goto case_123;
  }
#line 113
  if ((127 & (int )((scm_cell *)x)->car) == 83) {
#line 113
    goto case_123;
  }
#line 113
  if ((127 & (int )((scm_cell *)x)->car) == 75) {
#line 113
    goto case_123;
  }
#line 113
  if ((127 & (int )((scm_cell *)x)->car) == 67) {
#line 113
    goto case_123;
  }
#line 113
  if ((127 & (int )((scm_cell *)x)->car) == 59) {
#line 113
    goto case_123;
  }
#line 113
  if ((127 & (int )((scm_cell *)x)->car) == 51) {
#line 113
    goto case_123;
  }
#line 113
  if ((127 & (int )((scm_cell *)x)->car) == 43) {
#line 113
    goto case_123;
  }
#line 113
  if ((127 & (int )((scm_cell *)x)->car) == 35) {
#line 113
    goto case_123;
  }
#line 113
  if ((127 & (int )((scm_cell *)x)->car) == 27) {
#line 113
    goto case_123;
  }
#line 113
  if ((127 & (int )((scm_cell *)x)->car) == 19) {
#line 113
    goto case_123;
  }
#line 113
  if ((127 & (int )((scm_cell *)x)->car) == 11) {
#line 113
    goto case_123;
  }
#line 113
  if ((127 & (int )((scm_cell *)x)->car) == 3) {
#line 113
    goto case_123;
  }
#line 115
  if ((127 & (int )((scm_cell *)x)->car) == 7) {
#line 115
    goto case_7;
  }
#line 115
  if ((127 & (int )((scm_cell *)x)->car) == 5) {
#line 115
    goto case_7;
  }
#line 117
  if ((127 & (int )((scm_cell *)x)->car) == 13) {
#line 117
    goto case_13;
  }
#line 119
  if ((127 & (int )((scm_cell *)x)->car) == 15) {
#line 119
    goto case_15;
  }
#line 121
  if ((127 & (int )((scm_cell *)x)->car) == 71) {
#line 121
    goto case_71;
  }
#line 123
  if ((127 & (int )((scm_cell *)x)->car) == 77) {
#line 123
    goto case_77;
  }
#line 125
  if ((127 & (int )((scm_cell *)x)->car) == 55) {
#line 125
    goto case_55;
  }
#line 127
  if ((127 & (int )((scm_cell *)x)->car) == 79) {
#line 127
    goto case_79;
  }
#line 129
  if ((127 & (int )((scm_cell *)x)->car) == 37) {
#line 129
    goto case_37;
  }
#line 131
  if ((127 & (int )((scm_cell *)x)->car) == 45) {
#line 131
    goto case_45;
  }
#line 133
  if ((127 & (int )((scm_cell *)x)->car) == 47) {
#line 133
    goto case_47;
  }
#line 135
  if ((127 & (int )((scm_cell *)x)->car) == 53) {
#line 135
    goto case_53;
  }
#line 137
  if ((127 & (int )((scm_cell *)x)->car) == 21) {
#line 137
    goto case_21;
  }
#line 139
  if ((127 & (int )((scm_cell *)x)->car) == 23) {
#line 139
    goto case_23;
  }
#line 141
  if ((127 & (int )((scm_cell *)x)->car) == 29) {
#line 141
    goto case_29;
  }
#line 143
  if ((127 & (int )((scm_cell *)x)->car) == 31) {
#line 143
    goto case_31;
  }
#line 145
  if ((127 & (int )((scm_cell *)x)->car) == 103) {
#line 145
    goto case_103;
  }
#line 147
  if ((127 & (int )((scm_cell *)x)->car) == 85) {
#line 147
    goto case_85;
  }
#line 149
  if ((127 & (int )((scm_cell *)x)->car) == 87) {
#line 149
    goto case_87;
  }
#line 151
  if ((127 & (int )((scm_cell *)x)->car) == 93) {
#line 151
    goto case_93;
  }
#line 153
  if ((127 & (int )((scm_cell *)x)->car) == 95) {
#line 153
    goto case_95;
  }
#line 155
  if ((127 & (int )((scm_cell *)x)->car) == 101) {
#line 155
    goto case_101;
  }
#line 157
  if ((127 & (int )((scm_cell *)x)->car) == 69) {
#line 157
    goto case_69;
  }
#line 159
  if ((127 & (int )((scm_cell *)x)->car) == 109) {
#line 159
    goto case_109;
  }
#line 161
  if ((127 & (int )((scm_cell *)x)->car) == 111) {
#line 161
    goto case_111;
  }
#line 163
  if ((127 & (int )((scm_cell *)x)->car) == 117) {
#line 163
    goto case_117;
  }
#line 165
  if ((127 & (int )((scm_cell *)x)->car) == 119) {
#line 165
    goto case_119;
  }
#line 168
  if ((127 & (int )((scm_cell *)x)->car) == 125) {
#line 168
    goto case_125;
  }
#line 174
  if ((127 & (int )((scm_cell *)x)->car) == 127) {
#line 174
    goto case_127;
  }
#line 180
  if ((127 & (int )((scm_cell *)x)->car) == 121) {
#line 180
    goto case_121;
  }
#line 180
  if ((127 & (int )((scm_cell *)x)->car) == 113) {
#line 180
    goto case_121;
  }
#line 180
  if ((127 & (int )((scm_cell *)x)->car) == 105) {
#line 180
    goto case_121;
  }
#line 180
  if ((127 & (int )((scm_cell *)x)->car) == 97) {
#line 180
    goto case_121;
  }
#line 180
  if ((127 & (int )((scm_cell *)x)->car) == 89) {
#line 180
    goto case_121;
  }
#line 180
  if ((127 & (int )((scm_cell *)x)->car) == 81) {
#line 180
    goto case_121;
  }
#line 180
  if ((127 & (int )((scm_cell *)x)->car) == 73) {
#line 180
    goto case_121;
  }
#line 180
  if ((127 & (int )((scm_cell *)x)->car) == 65) {
#line 180
    goto case_121;
  }
#line 180
  if ((127 & (int )((scm_cell *)x)->car) == 57) {
#line 180
    goto case_121;
  }
#line 180
  if ((127 & (int )((scm_cell *)x)->car) == 49) {
#line 180
    goto case_121;
  }
#line 180
  if ((127 & (int )((scm_cell *)x)->car) == 41) {
#line 180
    goto case_121;
  }
#line 180
  if ((127 & (int )((scm_cell *)x)->car) == 33) {
#line 180
    goto case_121;
  }
#line 180
  if ((127 & (int )((scm_cell *)x)->car) == 25) {
#line 180
    goto case_121;
  }
#line 180
  if ((127 & (int )((scm_cell *)x)->car) == 17) {
#line 180
    goto case_121;
  }
#line 180
  if ((127 & (int )((scm_cell *)x)->car) == 9) {
#line 180
    goto case_121;
  }
#line 180
  if ((127 & (int )((scm_cell *)x)->car) == 1) {
#line 180
    goto case_121;
  }
#line 189
  goto switch_default;
  case_120: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_96: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_64: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_48: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_32: /* CIL Label */ 
  case_24: /* CIL Label */ 
  case_16: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_0___0: /* CIL Label */ 
#line 112
  return (((scm_cell *)scm_utag_pair)->cdr);
  case_123: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_91: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_59: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_35: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_19: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 114
  return (((scm_cell *)scm_utag_closure)->cdr);
  case_7: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 116
  return (((scm_cell *)scm_utag_symbol)->cdr);
  case_13: /* CIL Label */ 
#line 118
  return (((scm_cell *)scm_utag_vector)->cdr);
  case_15: /* CIL Label */ 
#line 120
  return (((scm_cell *)scm_utag_wvect)->cdr);
  case_71: /* CIL Label */ 
#line 122
  return (((scm_cell *)scm_utag_bvect)->cdr);
  case_77: /* CIL Label */ 
#line 124
  return (((scm_cell *)scm_utag_byvect)->cdr);
  case_55: /* CIL Label */ 
#line 126
  return (((scm_cell *)scm_utag_svect)->cdr);
  case_79: /* CIL Label */ 
#line 128
  return (((scm_cell *)scm_utag_ivect)->cdr);
  case_37: /* CIL Label */ 
#line 130
  return (((scm_cell *)scm_utag_uvect)->cdr);
  case_45: /* CIL Label */ 
#line 132
  return (((scm_cell *)scm_utag_fvect)->cdr);
  case_47: /* CIL Label */ 
#line 134
  return (((scm_cell *)scm_utag_dvect)->cdr);
  case_53: /* CIL Label */ 
#line 136
  return (((scm_cell *)scm_utag_cvect)->cdr);
  case_21: /* CIL Label */ 
#line 138
  return (((scm_cell *)scm_utag_string)->cdr);
  case_23: /* CIL Label */ 
#line 140
  return (((scm_cell *)scm_utag_mb_string)->cdr);
  case_29: /* CIL Label */ 
#line 142
  return (((scm_cell *)scm_utag_substring)->cdr);
  case_31: /* CIL Label */ 
#line 144
  return (((scm_cell *)scm_utag_mb_substring)->cdr);
  case_103: /* CIL Label */ 
#line 146
  return (((scm_cell *)scm_utag_asubr)->cdr);
  case_85: /* CIL Label */ 
#line 148
  return (((scm_cell *)scm_utag_subr_0)->cdr);
  case_87: /* CIL Label */ 
#line 150
  return (((scm_cell *)scm_utag_subr_1)->cdr);
  case_93: /* CIL Label */ 
#line 152
  return (((scm_cell *)scm_utag_cxr)->cdr);
  case_95: /* CIL Label */ 
#line 154
  return (((scm_cell *)scm_utag_subr_3)->cdr);
  case_101: /* CIL Label */ 
#line 156
  return (((scm_cell *)scm_utag_subr_2)->cdr);
  case_69: /* CIL Label */ 
#line 158
  return (((scm_cell *)scm_utag_rpsubr)->cdr);
  case_109: /* CIL Label */ 
#line 160
  return (((scm_cell *)scm_utag_subr_1o)->cdr);
  case_111: /* CIL Label */ 
#line 162
  return (((scm_cell *)scm_utag_subr_2o)->cdr);
  case_117: /* CIL Label */ 
#line 164
  return (((scm_cell *)scm_utag_lsubr_2)->cdr);
  case_119: /* CIL Label */ 
#line 166
  return (((scm_cell *)scm_utag_lsubr)->cdr);
  case_125: /* CIL Label */ 
#line 171
  tag___0 = ((65535 & (int )((scm_cell *)x)->car) >> 8) & 255;
#line 172
  return ((((((scm_cell *)scm_utag_port_base)->cdr >> 2) | (long )(tag___0 << 8)) << 2) + 2L);
  case_127: /* CIL Label */ 
#line 177
  tag___1 = ((65535 & (int )((scm_cell *)x)->car) >> 8) & 255;
#line 178
  return ((((((scm_cell *)scm_utag_smob_base)->cdr >> 2) | (long )(tag___1 << 8)) << 2) + 2L);
  case_121: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_97: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_65: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_25: /* CIL Label */ 
  case_17: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 184
  tag___2 = (int )*((SCM *)(((scm_cell *)x)->car - 1L) + -1);
#line 185
  return ((((((scm_cell *)scm_utag_struct_base)->cdr >> 2) | (long )(tag___2 << 8)) << 2) + 2L);
#line 187
  return (((scm_cell *)scm_utag_struct_base)->cdr);
  switch_default: /* CIL Label */ 
#line 190
  if (! (1 & (int )((scm_cell *)x)->car)) {
#line 191
    return (((scm_cell *)scm_utag_pair)->cdr);
  } else {
#line 193
    return ((long )(-1 << 2) + 2L);
  }
  switch_break___0: /* CIL Label */ ;
  }
  case_3___0: /* CIL Label */ 
  case_7___0: /* CIL Label */ 
  case_5___0: /* CIL Label */ 
  case_1___0: /* CIL Label */ 
#line 201
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 203
  return ((long )(-1 << 2) + 2L);
}
}
#line 210 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/tag.c"
void scm_init_tag(void) 
{ 
  SCM tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  SCM tmp___2 ;
  SCM tmp___3 ;
  SCM tmp___4 ;
  SCM tmp___5 ;
  SCM tmp___6 ;
  SCM tmp___7 ;
  SCM tmp___8 ;
  SCM tmp___9 ;
  SCM tmp___10 ;
  SCM tmp___11 ;
  SCM tmp___12 ;
  SCM tmp___13 ;
  SCM tmp___14 ;
  SCM tmp___15 ;
  SCM tmp___16 ;
  SCM tmp___17 ;
  SCM tmp___18 ;
  SCM tmp___19 ;
  SCM tmp___20 ;
  SCM tmp___21 ;
  SCM tmp___22 ;
  SCM tmp___23 ;
  SCM tmp___24 ;
  SCM tmp___25 ;
  SCM tmp___26 ;
  SCM tmp___27 ;
  SCM tmp___28 ;
  SCM tmp___29 ;
  SCM tmp___30 ;
  SCM tmp___31 ;
  SCM tmp___32 ;
  SCM tmp___33 ;
  SCM tmp___34 ;
  SCM tmp___35 ;
  SCM tmp___36 ;
  SCM tmp___37 ;
  SCM tmp___38 ;
  SCM tmp___39 ;
  SCM tmp___40 ;
  SCM tmp___41 ;
  SCM tmp___42 ;
  SCM tmp___43 ;
  SCM tmp___44 ;
  SCM tmp___45 ;
  SCM tmp___46 ;
  SCM tmp___47 ;
  SCM tmp___48 ;
  SCM tmp___49 ;
  SCM tmp___50 ;
  SCM tmp___51 ;
  SCM tmp___52 ;
  SCM tmp___53 ;
  SCM tmp___54 ;
  SCM tmp___55 ;
  SCM tmp___56 ;
  SCM tmp___57 ;
  SCM tmp___58 ;
  SCM tmp___59 ;
  SCM tmp___60 ;
  SCM tmp___61 ;
  SCM tmp___62 ;
  SCM tmp___63 ;
  SCM tmp___64 ;
  SCM tmp___65 ;
  SCM tmp___66 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;

  {
  {
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/tag.x"
  tmp = scm_intern0((char *)"utag_immediate_integer");
#line 1
  scm_utag_immediate_integer = scm_permanent_object(tmp);
#line 1
  tmp___0 = scm_long2num(0L);
#line 1
  ((scm_cell *)scm_utag_immediate_integer)->cdr = tmp___0;
#line 2
  tmp___1 = scm_intern0((char *)"utag_immediate_char");
#line 2
  scm_utag_immediate_char = scm_permanent_object(tmp___1);
#line 2
  tmp___2 = scm_long2num(1L);
#line 2
  ((scm_cell *)scm_utag_immediate_char)->cdr = tmp___2;
#line 3
  tmp___3 = scm_intern0((char *)"utag_pair");
#line 3
  scm_utag_pair = scm_permanent_object(tmp___3);
#line 3
  tmp___4 = scm_long2num(2L);
#line 3
  ((scm_cell *)scm_utag_pair)->cdr = tmp___4;
#line 4
  tmp___5 = scm_intern0((char *)"utag_closure");
#line 4
  scm_utag_closure = scm_permanent_object(tmp___5);
#line 4
  tmp___6 = scm_long2num(3L);
#line 4
  ((scm_cell *)scm_utag_closure)->cdr = tmp___6;
#line 5
  tmp___7 = scm_intern0((char *)"utag_symbol");
#line 5
  scm_utag_symbol = scm_permanent_object(tmp___7);
#line 5
  tmp___8 = scm_long2num(4L);
#line 5
  ((scm_cell *)scm_utag_symbol)->cdr = tmp___8;
#line 6
  tmp___9 = scm_intern0((char *)"utag_vector");
#line 6
  scm_utag_vector = scm_permanent_object(tmp___9);
#line 6
  tmp___10 = scm_long2num(5L);
#line 6
  ((scm_cell *)scm_utag_vector)->cdr = tmp___10;
#line 7
  tmp___11 = scm_intern0((char *)"utag_wvect");
#line 7
  scm_utag_wvect = scm_permanent_object(tmp___11);
#line 7
  tmp___12 = scm_long2num(6L);
#line 7
  ((scm_cell *)scm_utag_wvect)->cdr = tmp___12;
#line 8
  tmp___13 = scm_intern0((char *)"utag_bvect");
#line 8
  scm_utag_bvect = scm_permanent_object(tmp___13);
#line 8
  tmp___14 = scm_long2num(7L);
#line 8
  ((scm_cell *)scm_utag_bvect)->cdr = tmp___14;
#line 9
  tmp___15 = scm_intern0((char *)"utag_byvect");
#line 9
  scm_utag_byvect = scm_permanent_object(tmp___15);
#line 9
  tmp___16 = scm_long2num(8L);
#line 9
  ((scm_cell *)scm_utag_byvect)->cdr = tmp___16;
#line 10
  tmp___17 = scm_intern0((char *)"utag_svect");
#line 10
  scm_utag_svect = scm_permanent_object(tmp___17);
#line 10
  tmp___18 = scm_long2num(9L);
#line 10
  ((scm_cell *)scm_utag_svect)->cdr = tmp___18;
#line 11
  tmp___19 = scm_intern0((char *)"utag_ivect");
#line 11
  scm_utag_ivect = scm_permanent_object(tmp___19);
#line 11
  tmp___20 = scm_long2num(10L);
#line 11
  ((scm_cell *)scm_utag_ivect)->cdr = tmp___20;
#line 12
  tmp___21 = scm_intern0((char *)"utag_uvect");
#line 12
  scm_utag_uvect = scm_permanent_object(tmp___21);
#line 12
  tmp___22 = scm_long2num(11L);
#line 12
  ((scm_cell *)scm_utag_uvect)->cdr = tmp___22;
#line 13
  tmp___23 = scm_intern0((char *)"utag_fvect");
#line 13
  scm_utag_fvect = scm_permanent_object(tmp___23);
#line 13
  tmp___24 = scm_long2num(12L);
#line 13
  ((scm_cell *)scm_utag_fvect)->cdr = tmp___24;
#line 14
  tmp___25 = scm_intern0((char *)"utag_dvect");
#line 14
  scm_utag_dvect = scm_permanent_object(tmp___25);
#line 14
  tmp___26 = scm_long2num(13L);
#line 14
  ((scm_cell *)scm_utag_dvect)->cdr = tmp___26;
#line 15
  tmp___27 = scm_intern0((char *)"utag_cvect");
#line 15
  scm_utag_cvect = scm_permanent_object(tmp___27);
#line 15
  tmp___28 = scm_long2num(14L);
#line 15
  ((scm_cell *)scm_utag_cvect)->cdr = tmp___28;
#line 16
  tmp___29 = scm_intern0((char *)"utag_string");
#line 16
  scm_utag_string = scm_permanent_object(tmp___29);
#line 16
  tmp___30 = scm_long2num(15L);
#line 16
  ((scm_cell *)scm_utag_string)->cdr = tmp___30;
#line 17
  tmp___31 = scm_intern0((char *)"utag_mb_string");
#line 17
  scm_utag_mb_string = scm_permanent_object(tmp___31);
#line 17
  tmp___32 = scm_long2num(16L);
#line 17
  ((scm_cell *)scm_utag_mb_string)->cdr = tmp___32;
#line 18
  tmp___33 = scm_intern0((char *)"utag_substring");
#line 18
  scm_utag_substring = scm_permanent_object(tmp___33);
#line 18
  tmp___34 = scm_long2num(17L);
#line 18
  ((scm_cell *)scm_utag_substring)->cdr = tmp___34;
#line 19
  tmp___35 = scm_intern0((char *)"utag_mb_substring");
#line 19
  scm_utag_mb_substring = scm_permanent_object(tmp___35);
#line 19
  tmp___36 = scm_long2num(18L);
#line 19
  ((scm_cell *)scm_utag_mb_substring)->cdr = tmp___36;
#line 20
  tmp___37 = scm_intern0((char *)"utag_asubr");
#line 20
  scm_utag_asubr = scm_permanent_object(tmp___37);
#line 20
  tmp___38 = scm_long2num(19L);
#line 20
  ((scm_cell *)scm_utag_asubr)->cdr = tmp___38;
#line 21
  tmp___39 = scm_intern0((char *)"utag_subr_0");
#line 21
  scm_utag_subr_0 = scm_permanent_object(tmp___39);
#line 21
  tmp___40 = scm_long2num(20L);
#line 21
  ((scm_cell *)scm_utag_subr_0)->cdr = tmp___40;
#line 22
  tmp___41 = scm_intern0((char *)"utag_subr_1");
#line 22
  scm_utag_subr_1 = scm_permanent_object(tmp___41);
#line 22
  tmp___42 = scm_long2num(21L);
#line 22
  ((scm_cell *)scm_utag_subr_1)->cdr = tmp___42;
#line 23
  tmp___43 = scm_intern0((char *)"utag_cxr");
#line 23
  scm_utag_cxr = scm_permanent_object(tmp___43);
#line 23
  tmp___44 = scm_long2num(22L);
#line 23
  ((scm_cell *)scm_utag_cxr)->cdr = tmp___44;
#line 24
  tmp___45 = scm_intern0((char *)"utag_subr_3");
#line 24
  scm_utag_subr_3 = scm_permanent_object(tmp___45);
#line 24
  tmp___46 = scm_long2num(23L);
#line 24
  ((scm_cell *)scm_utag_subr_3)->cdr = tmp___46;
#line 25
  tmp___47 = scm_intern0((char *)"utag_subr_2");
#line 25
  scm_utag_subr_2 = scm_permanent_object(tmp___47);
#line 25
  tmp___48 = scm_long2num(24L);
#line 25
  ((scm_cell *)scm_utag_subr_2)->cdr = tmp___48;
#line 26
  tmp___49 = scm_intern0((char *)"utag_rpsubr");
#line 26
  scm_utag_rpsubr = scm_permanent_object(tmp___49);
#line 26
  tmp___50 = scm_long2num(25L);
#line 26
  ((scm_cell *)scm_utag_rpsubr)->cdr = tmp___50;
#line 27
  tmp___51 = scm_intern0((char *)"utag_subr_1o");
#line 27
  scm_utag_subr_1o = scm_permanent_object(tmp___51);
#line 27
  tmp___52 = scm_long2num(26L);
#line 27
  ((scm_cell *)scm_utag_subr_1o)->cdr = tmp___52;
#line 28
  tmp___53 = scm_intern0((char *)"utag_subr_2o");
#line 28
  scm_utag_subr_2o = scm_permanent_object(tmp___53);
#line 28
  tmp___54 = scm_long2num(27L);
#line 28
  ((scm_cell *)scm_utag_subr_2o)->cdr = tmp___54;
#line 29
  tmp___55 = scm_intern0((char *)"utag_lsubr_2");
#line 29
  scm_utag_lsubr_2 = scm_permanent_object(tmp___55);
#line 29
  tmp___56 = scm_long2num(28L);
#line 29
  ((scm_cell *)scm_utag_lsubr_2)->cdr = tmp___56;
#line 30
  tmp___57 = scm_intern0((char *)"utag_lsubr");
#line 30
  scm_utag_lsubr = scm_permanent_object(tmp___57);
#line 30
  tmp___58 = scm_long2num(29L);
#line 30
  ((scm_cell *)scm_utag_lsubr)->cdr = tmp___58;
#line 31
  tmp___59 = scm_intern0((char *)"utag_smob_base");
#line 31
  scm_utag_smob_base = scm_permanent_object(tmp___59);
#line 31
  tmp___60 = scm_long2num(252L);
#line 31
  ((scm_cell *)scm_utag_smob_base)->cdr = tmp___60;
#line 32
  tmp___61 = scm_intern0((char *)"utag_port_base");
#line 32
  scm_utag_port_base = scm_permanent_object(tmp___61);
#line 32
  tmp___62 = scm_long2num(253L);
#line 32
  ((scm_cell *)scm_utag_port_base)->cdr = tmp___62;
#line 33
  tmp___63 = scm_intern0((char *)"utag_flag_base");
#line 33
  scm_utag_flag_base = scm_permanent_object(tmp___63);
#line 33
  tmp___64 = scm_long2num(254L);
#line 33
  ((scm_cell *)scm_utag_flag_base)->cdr = tmp___64;
#line 34
  tmp___65 = scm_intern0((char *)"utag_struct_base");
#line 34
  scm_utag_struct_base = scm_permanent_object(tmp___65);
#line 34
  tmp___66 = scm_long2num(255L);
#line 34
  ((scm_cell *)scm_utag_struct_base)->cdr = tmp___66;
#line 35
  scm_make_gsubr(s_tag, 1, 0, 0, (SCM (*)())(& scm_tag));
  }
#line 214 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/tag.c"
  return;
}
}
#line 50 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.h"
int scm_symhash_dim ;
#line 106
unsigned long scm_strhash(unsigned char *str , size_t len , unsigned long n ) ;
#line 108
SCM scm_sym2ovcell_soft(SCM sym , SCM obarray ) ;
#line 110
SCM scm_intern_obarray_soft(char *name , size_t len , SCM obarray , int softness ) ;
#line 111
SCM scm_intern_obarray(char *name , size_t len , SCM obarray ) ;
#line 115
SCM scm_symbol_p(SCM x ) ;
#line 116
SCM scm_symbol_to_string(SCM s___0 ) ;
#line 117
SCM scm_string_to_symbol(SCM s___0 ) ;
#line 118
SCM scm_string_to_obarray_symbol(SCM o , SCM s___0 , SCM softp ) ;
#line 120
SCM scm_unintern_symbol(SCM o , SCM s___0 ) ;
#line 121
SCM scm_symbol_binding(SCM o , SCM s___0 ) ;
#line 122
SCM scm_symbol_interned_p(SCM o , SCM s___0 ) ;
#line 123
SCM scm_symbol_bound_p(SCM o , SCM s___0 ) ;
#line 124
SCM scm_symbol_set_x(SCM o , SCM s___0 , SCM v ) ;
#line 125
SCM scm_symbol_fref(SCM s___0 ) ;
#line 126
SCM scm_symbol_pref(SCM s___0 ) ;
#line 127
SCM scm_symbol_fset_x(SCM s___0 , SCM val ) ;
#line 128
SCM scm_symbol_pset_x(SCM s___0 , SCM val ) ;
#line 129
SCM scm_symbol_hash(SCM s___0 ) ;
#line 130
void scm_init_symbols(void) ;
#line 71 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.c"
unsigned long scm_strhash(unsigned char *str , size_t len , unsigned long n ) 
{ 
  size_t i ;
  unsigned long h ;
  int tmp ;
  size_t tmp___0 ;
  size_t i___0 ;
  unsigned long h___0 ;
  int tmp___1 ;

  {
#line 77
  if (len > 5UL) {
#line 79
    i = (size_t )5;
#line 80
    h = 264UL % n;
    {
#line 81
    while (1) {
      while_continue: /* CIL Label */ ;
#line 81
      tmp___0 = i;
#line 81
      i --;
#line 81
      if (! tmp___0) {
#line 81
        goto while_break;
      }
      {
#line 82
      tmp = scm_downcase((unsigned int )*(str + h % len));
#line 82
      h = ((h << 8) + (unsigned long )((unsigned int )tmp)) % n;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 83
    return (h);
  } else {
#line 87
    i___0 = len;
#line 88
    h___0 = 0UL;
    {
#line 89
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 89
      if (! i___0) {
#line 89
        goto while_break___0;
      }
      {
#line 90
      i___0 --;
#line 90
      tmp___1 = scm_downcase((unsigned int )*(str + i___0));
#line 90
      h___0 = ((h___0 << 8) + (unsigned long )((unsigned int )tmp___1)) % n;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 91
    return (h___0);
  }
}
}
#line 95 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.c"
int scm_symhash_dim  =    137;
#line 102 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.c"
SCM scm_sym2vcell(SCM sym , SCM thunk , SCM definep ) 
{ 
  SCM var ;
  SCM tmp ;
  SCM tmp___0 ;
  SCM lsym ;
  SCM *lsymp ;
  SCM z ;
  size_t scm_hash___0 ;
  unsigned long tmp___1 ;
  SCM tmp___2 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 108
  if (! (6 & (int )thunk)) {
    {
#line 110
    tmp = scm_cons(definep, scm_sys_protects[1]);
#line 110
    tmp___0 = scm_apply(thunk, sym, tmp);
#line 110
    var = tmp___0;
    }
#line 112
    if (var == (long )(16 << 9) + 372L) {
#line 113
      return ((long )(16 << 9) + 372L);
    } else {
#line 116
      if (6 & (int )var) {
        {
#line 117
        scm_wta(sym, (char *)"strangely interned symbol? ", (char *)"");
        }
      } else
#line 116
      if (! ((SCM )scm_tc16_variable == ((scm_cell *)var)->car)) {
        {
#line 117
        scm_wta(sym, (char *)"strangely interned symbol? ", (char *)"");
        }
      }
#line 118
      return (((scm_cell *)var)->cdr);
    }
  } else {
    {
#line 126
    tmp___1 = scm_strhash((unsigned char *)((scm_cell *)sym)->cdr, (unsigned long )((scm_cell *)sym)->car >> 8,
                          (unsigned long )scm_symhash_dim);
#line 126
    scm_hash___0 = tmp___1;
#line 129
    scm_ints_disabled = 1;
#line 130
    lsym = *((SCM *)((scm_cell *)scm_sys_protects[5])->cdr + scm_hash___0);
    }
    {
#line 130
    while (1) {
      while_continue: /* CIL Label */ ;
#line 130
      if (! (! (6 & (int )lsym))) {
#line 130
        goto while_break;
      }
#line 132
      z = ((scm_cell *)lsym)->car;
#line 133
      if (((scm_cell *)z)->car == sym) {
#line 135
        scm_ints_disabled = 0;
#line 135
        scm_async_clock --;
#line 135
        if (0U == scm_async_clock) {
          {
#line 135
          scm_async_click();
          }
        }
#line 136
        return (z);
      }
#line 130
      lsym = ((scm_cell *)lsym)->cdr;
    }
    while_break: /* CIL Label */ ;
    }
#line 140
    lsymp = (SCM *)((scm_cell *)scm_sys_protects[6])->cdr + scm_hash___0;
#line 140
    lsym = *lsymp;
    {
#line 140
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 140
      if (! (! (6 & (int )lsym))) {
#line 140
        goto while_break___0;
      }
#line 144
      z = ((scm_cell *)lsym)->car;
#line 145
      if (((scm_cell *)z)->car == sym) {
#line 147
        if (definep) {
#line 150
          *lsymp = ((scm_cell *)lsym)->cdr;
#line 151
          ((scm_cell *)lsym)->cdr = *((SCM *)((scm_cell *)scm_sys_protects[5])->cdr + scm_hash___0);
#line 152
          *((SCM *)((scm_cell *)scm_sys_protects[5])->cdr + scm_hash___0) = lsym;
        }
#line 154
        scm_ints_disabled = 0;
#line 154
        scm_async_clock --;
#line 154
        if (0U == scm_async_clock) {
          {
#line 154
          scm_async_click();
          }
        }
#line 155
        return (z);
      }
#line 140
      lsymp = & ((scm_cell *)lsym)->cdr;
#line 140
      lsym = *lsymp;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 158
    scm_ints_disabled = 0;
#line 158
    scm_async_clock --;
#line 158
    if (0U == scm_async_clock) {
      {
#line 158
      scm_async_click();
      }
    }
    {
#line 159
    tmp___2 = scm_wta(sym, (char *)"uninterned symbol? ", (char *)"");
    }
#line 159
    return (tmp___2);
  }
}
}
#line 167 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.c"
SCM scm_sym2ovcell_soft(SCM sym , SCM obarray ) 
{ 
  SCM lsym ;
  SCM z ;
  size_t scm_hash___0 ;

  {
  {
#line 175
  scm_hash___0 = scm_strhash((unsigned char *)((scm_cell *)sym)->cdr, (unsigned long )((scm_cell *)sym)->car >> 8,
                             (unsigned long )((scm_cell *)obarray)->car >> 8);
#line 178
  scm_ints_disabled ++;
#line 179
  lsym = *((SCM *)((scm_cell *)obarray)->cdr + scm_hash___0);
  }
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! (! (6 & (int )lsym))) {
#line 179
      goto while_break;
    }
#line 183
    z = ((scm_cell *)lsym)->car;
#line 184
    if (((scm_cell *)z)->car == sym) {
#line 186
      scm_ints_disabled --;
#line 186
      if (! scm_ints_disabled) {
#line 186
        scm_async_clock --;
#line 186
        if (0U == scm_async_clock) {
          {
#line 186
          scm_async_click();
          }
        }
      }
#line 187
      return (z);
    }
#line 179
    lsym = ((scm_cell *)lsym)->cdr;
  }
  while_break: /* CIL Label */ ;
  }
#line 190
  scm_ints_disabled --;
#line 190
  if (! scm_ints_disabled) {
#line 190
    scm_async_clock --;
#line 190
    if (0U == scm_async_clock) {
      {
#line 190
      scm_async_click();
      }
    }
  }
#line 191
  return ((long )(16 << 9) + 372L);
}
}
#line 195 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.c"
SCM scm_sym2ovcell(SCM sym , SCM obarray ) 
{ 
  SCM answer ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 201
  answer = scm_sym2ovcell_soft(sym, obarray);
  }
#line 202
  if (answer != (long )(16 << 9) + 372L) {
#line 203
    return (answer);
  }
  {
#line 204
  scm_wta(sym, (char *)"uninterned symbol? ", (char *)"");
  }
#line 205
  return ((long )(21 << 9) + 372L);
}
}
#line 231 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.c"
SCM scm_intern_obarray_soft(char *name , size_t len , SCM obarray , int softness ) 
{ 
  SCM lsym ;
  SCM z ;
  register size_t i ;
  register unsigned char *tmp ;
  size_t scm_hash___0 ;
  size_t tmp___0 ;
  SCM a ;
  SCM answer ;
  SCM a___0 ;
  SCM b ;

  {
#line 244
  scm_ints_disabled ++;
#line 246
  i = len;
#line 247
  tmp = (unsigned char *)name;
#line 249
  if (obarray == (long )(16 << 9) + 372L) {
    {
#line 251
    scm_hash___0 = scm_strhash(tmp, i, 1019UL);
    }
#line 252
    goto uninterned_symbol;
  }
  {
#line 255
  scm_hash___0 = scm_strhash(tmp, i, (unsigned long )((scm_cell *)obarray)->car >> 8);
  }
#line 261
  if (softness == -1) {
    {
#line 262
    abort();
    }
  }
  retry_new_obarray: 
#line 265
  lsym = *((SCM *)((scm_cell *)obarray)->cdr + scm_hash___0);
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 265
    if (! (! (6 & (int )lsym))) {
#line 265
      goto while_break;
    }
#line 267
    z = ((scm_cell *)lsym)->car;
#line 268
    z = ((scm_cell *)z)->car;
#line 269
    tmp = (unsigned char *)((scm_cell *)z)->cdr;
#line 270
    if ((unsigned long )((scm_cell *)z)->car >> 8 != len) {
#line 271
      goto trynext;
    }
#line 272
    i = len;
    {
#line 272
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 272
      tmp___0 = i;
#line 272
      i --;
#line 272
      if (! tmp___0) {
#line 272
        goto while_break___0;
      }
#line 273
      if ((int )*((unsigned char *)name + i) != (int )*(tmp + i)) {
#line 274
        goto trynext;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 277
    a = ((scm_cell *)lsym)->car;
#line 278
    scm_ints_disabled --;
#line 278
    if (! scm_ints_disabled) {
#line 278
      scm_async_clock --;
#line 278
      if (0U == scm_async_clock) {
        {
#line 278
        scm_async_click();
        }
      }
    }
#line 279
    return (a);
    trynext: 
#line 265
    lsym = ((scm_cell *)lsym)->cdr;
  }
  while_break: /* CIL Label */ ;
  }
#line 284
  if (obarray == scm_sys_protects[5]) {
#line 286
    obarray = scm_sys_protects[6];
#line 287
    goto retry_new_obarray;
  }
  uninterned_symbol: 
#line 291
  if (softness) {
#line 293
    scm_ints_disabled --;
#line 293
    if (! scm_ints_disabled) {
#line 293
      scm_async_clock --;
#line 293
      if (0U == scm_async_clock) {
        {
#line 293
        scm_async_click();
        }
      }
    }
#line 294
    return ((long )(16 << 9) + 372L);
  }
  {
#line 297
  lsym = scm_makfromstr((char const   *)name, len, 5);
#line 299
  ((scm_cell *)lsym)->car = ((long )len << 8) + 7L;
#line 300
  *((unsigned long *)((SCM *)*((SCM *)((char *)((scm_cell *)lsym)->cdr) - 1) + 3)) = (unsigned long )((long )(16 << 9) + 372L);
#line 301
  *((unsigned long *)((SCM *)*((SCM *)((char *)((scm_cell *)lsym)->cdr) - 1) + 2)) = scm_hash___0;
#line 302
  *((SCM *)*((SCM *)((char *)((scm_cell *)lsym)->cdr) - 1) + 1) = (long )(20 << 9) + 372L;
  }
#line 303
  if (obarray == (long )(16 << 9) + 372L) {
#line 306
    scm_ints_disabled --;
#line 306
    if (! scm_ints_disabled) {
#line 306
      scm_async_clock --;
#line 306
      if (0U == scm_async_clock) {
        {
#line 306
        scm_async_click();
        }
      }
    }
#line 307
    if (6 & (int )scm_freelist) {
      {
#line 307
      answer = scm_gc_for_newcell();
      }
    } else {
#line 307
      answer = scm_freelist;
#line 307
      scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 307
      scm_cells_allocated ++;
    }
#line 308
    scm_ints_disabled = 1;
#line 309
    ((scm_cell *)answer)->car = lsym;
#line 310
    ((scm_cell *)answer)->cdr = (long )(18 << 9) + 372L;
#line 311
    scm_ints_disabled --;
#line 311
    if (! scm_ints_disabled) {
#line 311
      scm_async_clock --;
#line 311
      if (0U == scm_async_clock) {
        {
#line 311
        scm_async_click();
        }
      }
    }
#line 312
    return (answer);
  } else {
#line 319
    if (6 & (int )scm_freelist) {
      {
#line 319
      a___0 = scm_gc_for_newcell();
      }
    } else {
#line 319
      a___0 = scm_freelist;
#line 319
      scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 319
      scm_cells_allocated ++;
    }
#line 320
    if (6 & (int )scm_freelist) {
      {
#line 320
      b = scm_gc_for_newcell();
      }
    } else {
#line 320
      b = scm_freelist;
#line 320
      scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 320
      scm_cells_allocated ++;
    }
#line 321
    ((scm_cell *)a___0)->car = lsym;
#line 322
    ((scm_cell *)a___0)->cdr = (long )(18 << 9) + 372L;
#line 323
    ((scm_cell *)b)->car = a___0;
#line 324
    ((scm_cell *)b)->cdr = *((SCM *)((scm_cell *)obarray)->cdr + scm_hash___0);
#line 325
    *((SCM *)((scm_cell *)obarray)->cdr + scm_hash___0) = b;
#line 326
    scm_ints_disabled --;
#line 326
    if (! scm_ints_disabled) {
#line 326
      scm_async_clock --;
#line 326
      if (0U == scm_async_clock) {
        {
#line 326
        scm_async_click();
        }
      }
    }
#line 327
    return (((scm_cell *)b)->car);
  }
}
}
#line 332 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.c"
SCM scm_intern_obarray(char *name , size_t len , SCM obarray ) 
{ 
  SCM tmp ;

  {
  {
#line 338
  tmp = scm_intern_obarray_soft(name, len, obarray, 0);
  }
#line 338
  return (tmp);
}
}
#line 342 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.c"
SCM scm_intern(char *name , size_t len ) 
{ 
  SCM tmp ;

  {
  {
#line 347
  tmp = scm_intern_obarray(name, len, scm_sys_protects[5]);
  }
#line 347
  return (tmp);
}
}
#line 351 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.c"
SCM scm_intern0(char *name ) 
{ 
  size_t tmp ;
  SCM tmp___0 ;

  {
  {
#line 355
  tmp = strlen((char const   *)name);
#line 355
  tmp___0 = scm_intern(name, tmp);
  }
#line 355
  return (tmp___0);
}
}
#line 361 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.c"
SCM scm_sysintern(char *name , SCM val ) 
{ 
  SCM easy_answer ;
  size_t tmp ;
  SCM lsym ;
  size_t len ;
  size_t tmp___0 ;
  register unsigned char *tmp___1 ;
  size_t scm_hash___0 ;
  unsigned long tmp___2 ;

  {
  {
#line 367
  scm_ints_disabled = 1;
#line 368
  tmp = strlen((char const   *)name);
#line 368
  easy_answer = scm_intern_obarray_soft(name, tmp, scm_sys_protects[5], 1);
  }
#line 369
  if (! (6 & (int )easy_answer)) {
#line 371
    ((scm_cell *)easy_answer)->cdr = val;
#line 372
    scm_ints_disabled = 0;
#line 372
    scm_async_clock --;
#line 372
    if (0U == scm_async_clock) {
      {
#line 372
      scm_async_click();
      }
    }
#line 373
    return (easy_answer);
  } else {
    {
#line 378
    tmp___0 = strlen((char const   *)name);
#line 378
    len = tmp___0;
#line 379
    tmp___1 = (unsigned char *)name;
#line 380
    tmp___2 = scm_strhash(tmp___1, len, (unsigned long )scm_symhash_dim);
#line 380
    scm_hash___0 = tmp___2;
    }
#line 381
    if (6 & (int )scm_freelist) {
      {
#line 381
      lsym = scm_gc_for_newcell();
      }
    } else {
#line 381
      lsym = scm_freelist;
#line 381
      scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 381
      scm_cells_allocated ++;
    }
    {
#line 382
    ((scm_cell *)lsym)->car = ((long )len << 8) + 5L;
#line 383
    ((scm_cell *)lsym)->cdr = (SCM )name;
#line 384
    lsym = scm_cons(lsym, val);
#line 385
    *((SCM *)((scm_cell *)scm_sys_protects[5])->cdr + scm_hash___0) = scm_cons(lsym,
                                                                               *((SCM *)((scm_cell *)scm_sys_protects[5])->cdr + scm_hash___0));
#line 386
    scm_ints_disabled = 0;
#line 386
    scm_async_clock --;
    }
#line 386
    if (0U == scm_async_clock) {
      {
#line 386
      scm_async_click();
      }
    }
#line 387
    return (lsym);
  }
}
}
#line 392 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.c"
static char s_symbol_p[8]  = 
#line 392
  {      (char )'s',      (char )'y',      (char )'m',      (char )'b', 
        (char )'o',      (char )'l',      (char )'?',      (char )'\000'};
#line 394 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.c"
SCM scm_symbol_p(SCM x ) 
{ 
  long tmp ;

  {
#line 398
  if (6 & (int )x) {
#line 398
    return ((long )(16 << 9) + 372L);
  }
#line 399
  if ((125 & (int )((scm_cell *)x)->car) == 5) {
#line 399
    tmp = (long )(17 << 9) + 372L;
  } else {
#line 399
    tmp = (long )(16 << 9) + 372L;
  }
#line 399
  return (tmp);
}
}
#line 402 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.c"
static char s_symbol_to_string[15]  = 
#line 402
  {      (char )'s',      (char )'y',      (char )'m',      (char )'b', 
        (char )'o',      (char )'l',      (char )'-',      (char )'>', 
        (char )'s',      (char )'t',      (char )'r',      (char )'i', 
        (char )'n',      (char )'g',      (char )'\000'};
#line 404 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.c"
SCM scm_symbol_to_string(SCM s___0 ) 
{ 
  SCM tmp ;

  {
#line 408
  if (! (6 & (int )s___0)) {
#line 408
    if (! ((125 & (int )((scm_cell *)s___0)->car) == 5)) {
      {
#line 408
      scm_wta(s___0, (char *)1, s_symbol_to_string);
      }
    }
  } else {
    {
#line 408
    scm_wta(s___0, (char *)1, s_symbol_to_string);
    }
  }
  {
#line 409
  tmp = scm_makfromstr((char const   *)((char *)((scm_cell *)s___0)->cdr), (unsigned long )((scm_cell *)s___0)->car >> 8,
                       0);
  }
#line 409
  return (tmp);
}
}
#line 413 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.c"
static char s_string_to_symbol[15]  = 
#line 413
  {      (char )'s',      (char )'t',      (char )'r',      (char )'i', 
        (char )'n',      (char )'g',      (char )'-',      (char )'>', 
        (char )'s',      (char )'y',      (char )'m',      (char )'b', 
        (char )'o',      (char )'l',      (char )'\000'};
#line 415 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.c"
SCM scm_string_to_symbol(SCM s___0 ) 
{ 
  SCM vcell ;
  SCM answer ;
  char *tmp ;

  {
#line 422
  if (! (6 & (int )s___0)) {
#line 422
    if (! ((117 & (int )((scm_cell *)s___0)->car) == 21)) {
#line 422
      if (! ((125 & (int )((scm_cell *)s___0)->car) == 5)) {
        {
#line 422
        scm_wta(s___0, (char *)1, s_string_to_symbol);
        }
      }
    }
  } else {
    {
#line 422
    scm_wta(s___0, (char *)1, s_string_to_symbol);
    }
  }
#line 423
  if ((127 & (int )((scm_cell *)s___0)->car) == 29) {
#line 423
    tmp = (char *)((scm_cell *)((scm_cell *)((scm_cell *)s___0)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)s___0)->cdr)->car >> 2);
  } else {
#line 423
    tmp = (char *)((scm_cell *)s___0)->cdr;
  }
  {
#line 423
  vcell = scm_intern(tmp, (unsigned long )((scm_cell *)s___0)->car >> 8);
#line 424
  answer = ((scm_cell *)vcell)->car;
  }
#line 425
  if ((127 & (int )((scm_cell *)answer)->car) == 7) {
#line 427
    if ((119 & (int )((scm_cell *)s___0)->car) == 21) {
#line 428
      *((unsigned long *)((SCM *)*((SCM *)((char *)((scm_cell *)answer)->cdr) - 1) + 3)) = (unsigned long )((long )(16 << 9) + 372L);
    } else {
#line 430
      *((unsigned long *)((SCM *)*((SCM *)((char *)((scm_cell *)answer)->cdr) - 1) + 3)) = (unsigned long )((long )(17 << 9) + 372L);
    }
  }
#line 432
  return (answer);
}
}
#line 436 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.c"
static char s_string_to_obarray_symbol[23]  = 
#line 436
  {      (char )'s',      (char )'t',      (char )'r',      (char )'i', 
        (char )'n',      (char )'g',      (char )'-',      (char )'>', 
        (char )'o',      (char )'b',      (char )'a',      (char )'r', 
        (char )'r',      (char )'a',      (char )'y',      (char )'-', 
        (char )'s',      (char )'y',      (char )'m',      (char )'b', 
        (char )'o',      (char )'l',      (char )'\000'};
#line 438 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.c"
SCM scm_string_to_obarray_symbol(SCM o , SCM s___0 , SCM softp ) 
{ 
  SCM vcell ;
  SCM answer ;
  int softness ;
  int tmp ;
  char *tmp___0 ;

  {
#line 448
  if (! (6 & (int )s___0)) {
#line 448
    if (! ((117 & (int )((scm_cell *)s___0)->car) == 21)) {
#line 448
      if (! ((125 & (int )((scm_cell *)s___0)->car) == 5)) {
        {
#line 448
        scm_wta(s___0, (char *)2, s_string_to_obarray_symbol);
        }
      }
    }
  } else {
    {
#line 448
    scm_wta(s___0, (char *)2, s_string_to_obarray_symbol);
    }
  }
#line 450
  if (! (o == (long )(16 << 9) + 372L)) {
#line 450
    if (! (o == (long )(17 << 9) + 372L)) {
#line 450
      if (! (6 & (int )o)) {
#line 450
        if (! ((125 & (int )((scm_cell *)o)->car) == 13)) {
          {
#line 450
          scm_wta(o, (char *)1, s_string_to_obarray_symbol);
          }
        }
      } else {
        {
#line 450
        scm_wta(o, (char *)1, s_string_to_obarray_symbol);
        }
      }
    }
  }
#line 457
  if (softp != (long )(18 << 9) + 372L) {
#line 457
    if (softp != (long )(16 << 9) + 372L) {
#line 457
      tmp = 1;
    } else {
#line 457
      tmp = 0;
    }
  } else {
#line 457
    tmp = 0;
  }
#line 457
  softness = tmp;
#line 459
  if (o == (long )(16 << 9) + 372L) {
#line 460
    o = scm_sys_protects[5];
  } else
#line 461
  if (o == (long )(17 << 9) + 372L) {
#line 462
    o = (long )(16 << 9) + 372L;
  }
#line 464
  if ((127 & (int )((scm_cell *)s___0)->car) == 29) {
#line 464
    tmp___0 = (char *)((scm_cell *)((scm_cell *)((scm_cell *)s___0)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)s___0)->cdr)->car >> 2);
  } else {
#line 464
    tmp___0 = (char *)((scm_cell *)s___0)->cdr;
  }
  {
#line 464
  vcell = scm_intern_obarray_soft(tmp___0, (unsigned long )((scm_cell *)s___0)->car >> 8,
                                  o, softness);
  }
#line 468
  if (vcell == (long )(16 << 9) + 372L) {
#line 469
    return (vcell);
  }
#line 470
  answer = ((scm_cell *)vcell)->car;
#line 471
  if ((127 & (int )((scm_cell *)s___0)->car) == 7) {
#line 473
    if ((119 & (int )((scm_cell *)s___0)->car) == 21) {
#line 474
      *((unsigned long *)((SCM *)*((SCM *)((char *)((scm_cell *)answer)->cdr) - 1) + 3)) = (unsigned long )((long )(16 << 9) + 372L);
    } else {
#line 476
      *((unsigned long *)((SCM *)*((SCM *)((char *)((scm_cell *)answer)->cdr) - 1) + 3)) = (unsigned long )((long )(17 << 9) + 372L);
    }
  }
#line 478
  return (answer);
}
}
#line 481 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.c"
static char s_intern_symbol[14]  = 
#line 481
  {      (char )'i',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'n',      (char )'-',      (char )'s', 
        (char )'y',      (char )'m',      (char )'b',      (char )'o', 
        (char )'l',      (char )'\000'};
#line 483 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.c"
SCM scm_intern_symbol(SCM o , SCM s___0 ) 
{ 
  size_t hval ;
  SCM lsym ;
  SCM sym ;

  {
#line 489
  if (! (6 & (int )s___0)) {
#line 489
    if (! ((125 & (int )((scm_cell *)s___0)->car) == 5)) {
      {
#line 489
      scm_wta(s___0, (char *)2, s_intern_symbol);
      }
    }
  } else {
    {
#line 489
    scm_wta(s___0, (char *)2, s_intern_symbol);
    }
  }
#line 490
  if (o == (long )(16 << 9) + 372L) {
#line 491
    o = scm_sys_protects[5];
  }
#line 492
  if (! (6 & (int )o)) {
#line 492
    if (! ((125 & (int )((scm_cell *)o)->car) == 13)) {
      {
#line 492
      scm_wta(o, (char *)1, s_intern_symbol);
      }
    }
  } else {
    {
#line 492
    scm_wta(o, (char *)1, s_intern_symbol);
    }
  }
  {
#line 493
  hval = scm_strhash((unsigned char *)((scm_cell *)s___0)->cdr, (unsigned long )((scm_cell *)s___0)->car >> 8,
                     (unsigned long )((scm_cell *)o)->car >> 8);
#line 495
  scm_ints_disabled ++;
#line 499
  lsym = *((SCM *)((scm_cell *)o)->cdr + hval);
  }
  {
#line 499
  while (1) {
    while_continue: /* CIL Label */ ;
#line 499
    if (! (! (6 & (int )lsym))) {
#line 499
      goto while_break;
    }
#line 503
    sym = ((scm_cell *)lsym)->car;
#line 504
    if (((scm_cell *)sym)->car == s___0) {
#line 506
      scm_ints_disabled --;
#line 506
      if (! scm_ints_disabled) {
#line 506
        scm_async_clock --;
#line 506
        if (0U == scm_async_clock) {
          {
#line 506
          scm_async_click();
          }
        }
      }
#line 507
      return ((long )(21 << 9) + 372L);
    }
#line 499
    lsym = ((scm_cell *)lsym)->cdr;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 510
  *((SCM *)((scm_cell *)o)->cdr + hval) = scm_acons(s___0, (long )(18 << 9) + 372L,
                                                    *((SCM *)((scm_cell *)o)->cdr + hval));
#line 513
  scm_ints_disabled --;
  }
#line 513
  if (! scm_ints_disabled) {
#line 513
    scm_async_clock --;
#line 513
    if (0U == scm_async_clock) {
      {
#line 513
      scm_async_click();
      }
    }
  }
#line 514
  return ((long )(21 << 9) + 372L);
}
}
#line 517 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.c"
static char s_unintern_symbol[16]  = 
#line 517
  {      (char )'u',      (char )'n',      (char )'i',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'n', 
        (char )'-',      (char )'s',      (char )'y',      (char )'m', 
        (char )'b',      (char )'o',      (char )'l',      (char )'\000'};
#line 519 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.c"
SCM scm_unintern_symbol(SCM o , SCM s___0 ) 
{ 
  size_t hval ;
  SCM lsym_follow ;
  SCM lsym ;
  SCM sym ;

  {
#line 525
  if (! (6 & (int )s___0)) {
#line 525
    if (! ((125 & (int )((scm_cell *)s___0)->car) == 5)) {
      {
#line 525
      scm_wta(s___0, (char *)2, s_unintern_symbol);
      }
    }
  } else {
    {
#line 525
    scm_wta(s___0, (char *)2, s_unintern_symbol);
    }
  }
#line 526
  if (o == (long )(16 << 9) + 372L) {
#line 527
    o = scm_sys_protects[5];
  }
#line 528
  if (! (6 & (int )o)) {
#line 528
    if (! ((125 & (int )((scm_cell *)o)->car) == 13)) {
      {
#line 528
      scm_wta(o, (char *)1, s_unintern_symbol);
      }
    }
  } else {
    {
#line 528
    scm_wta(o, (char *)1, s_unintern_symbol);
    }
  }
  {
#line 529
  hval = scm_strhash((unsigned char *)((scm_cell *)s___0)->cdr, (unsigned long )((scm_cell *)s___0)->car >> 8,
                     (unsigned long )((scm_cell *)o)->car >> 8);
#line 530
  scm_ints_disabled = 1;
#line 535
  lsym = *((SCM *)((scm_cell *)o)->cdr + hval);
#line 535
  lsym_follow = (long )(16 << 9) + 372L;
  }
  {
#line 535
  while (1) {
    while_continue: /* CIL Label */ ;
#line 535
    if (! (! (6 & (int )lsym))) {
#line 535
      goto while_break;
    }
#line 539
    sym = ((scm_cell *)lsym)->car;
#line 540
    if (((scm_cell *)sym)->car == s___0) {
#line 543
      if (lsym_follow == (long )(16 << 9) + 372L) {
#line 544
        *((SCM *)((scm_cell *)o)->cdr + hval) = lsym;
      } else {
#line 546
        ((scm_cell *)lsym_follow)->cdr = ((scm_cell *)lsym)->cdr;
      }
#line 547
      scm_ints_disabled = 0;
#line 547
      scm_async_clock --;
#line 547
      if (0U == scm_async_clock) {
        {
#line 547
        scm_async_click();
        }
      }
#line 548
      return ((long )(17 << 9) + 372L);
    }
#line 535
    lsym_follow = lsym;
#line 535
    lsym = ((scm_cell *)lsym)->cdr;
  }
  while_break: /* CIL Label */ ;
  }
#line 552
  scm_ints_disabled = 0;
#line 552
  scm_async_clock --;
#line 552
  if (0U == scm_async_clock) {
    {
#line 552
    scm_async_click();
    }
  }
#line 553
  return ((long )(16 << 9) + 372L);
}
}
#line 556 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.c"
static char s_symbol_binding[15]  = 
#line 556
  {      (char )'s',      (char )'y',      (char )'m',      (char )'b', 
        (char )'o',      (char )'l',      (char )'-',      (char )'b', 
        (char )'i',      (char )'n',      (char )'d',      (char )'i', 
        (char )'n',      (char )'g',      (char )'\000'};
#line 558 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.c"
SCM scm_symbol_binding(SCM o , SCM s___0 ) 
{ 
  SCM vcell ;

  {
#line 564
  if (! (6 & (int )s___0)) {
#line 564
    if (! ((125 & (int )((scm_cell *)s___0)->car) == 5)) {
      {
#line 564
      scm_wta(s___0, (char *)2, s_symbol_binding);
      }
    }
  } else {
    {
#line 564
    scm_wta(s___0, (char *)2, s_symbol_binding);
    }
  }
#line 565
  if (o == (long )(16 << 9) + 372L) {
#line 566
    o = scm_sys_protects[5];
  }
#line 567
  if (! (6 & (int )o)) {
#line 567
    if (! ((125 & (int )((scm_cell *)o)->car) == 13)) {
      {
#line 567
      scm_wta(o, (char *)1, s_symbol_binding);
      }
    }
  } else {
    {
#line 567
    scm_wta(o, (char *)1, s_symbol_binding);
    }
  }
  {
#line 568
  vcell = scm_sym2ovcell(s___0, o);
  }
#line 569
  return (((scm_cell *)vcell)->cdr);
}
}
#line 573 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.c"
static char s_symbol_interned_p[17]  = 
#line 573
  {      (char )'s',      (char )'y',      (char )'m',      (char )'b', 
        (char )'o',      (char )'l',      (char )'-',      (char )'i', 
        (char )'n',      (char )'t',      (char )'e',      (char )'r', 
        (char )'n',      (char )'e',      (char )'d',      (char )'?', 
        (char )'\000'};
#line 575 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.c"
SCM scm_symbol_interned_p(SCM o , SCM s___0 ) 
{ 
  SCM vcell ;
  long tmp ;

  {
#line 581
  if (! (6 & (int )s___0)) {
#line 581
    if (! ((125 & (int )((scm_cell *)s___0)->car) == 5)) {
      {
#line 581
      scm_wta(s___0, (char *)2, s_symbol_interned_p);
      }
    }
  } else {
    {
#line 581
    scm_wta(s___0, (char *)2, s_symbol_interned_p);
    }
  }
#line 582
  if (o == (long )(16 << 9) + 372L) {
#line 583
    o = scm_sys_protects[5];
  }
#line 584
  if (! (6 & (int )o)) {
#line 584
    if (! ((125 & (int )((scm_cell *)o)->car) == 13)) {
      {
#line 584
      scm_wta(o, (char *)1, s_symbol_interned_p);
      }
    }
  } else {
    {
#line 584
    scm_wta(o, (char *)1, s_symbol_interned_p);
    }
  }
  {
#line 585
  vcell = scm_sym2ovcell_soft(s___0, o);
  }
#line 586
  if (6 & (int )vcell) {
#line 586
    if (o == scm_sys_protects[5]) {
      {
#line 587
      vcell = scm_sym2ovcell_soft(s___0, scm_sys_protects[6]);
      }
    }
  }
#line 588
  if (! (6 & (int )vcell)) {
#line 588
    tmp = (long )(17 << 9) + 372L;
  } else {
#line 588
    tmp = (long )(16 << 9) + 372L;
  }
#line 588
  return (tmp);
}
}
#line 594 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.c"
static char s_symbol_bound_p[14]  = 
#line 594
  {      (char )'s',      (char )'y',      (char )'m',      (char )'b', 
        (char )'o',      (char )'l',      (char )'-',      (char )'b', 
        (char )'o',      (char )'u',      (char )'n',      (char )'d', 
        (char )'?',      (char )'\000'};
#line 596 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.c"
SCM scm_symbol_bound_p(SCM o , SCM s___0 ) 
{ 
  SCM vcell ;
  long tmp ;

  {
#line 602
  if (! (6 & (int )s___0)) {
#line 602
    if (! ((125 & (int )((scm_cell *)s___0)->car) == 5)) {
      {
#line 602
      scm_wta(s___0, (char *)2, s_symbol_bound_p);
      }
    }
  } else {
    {
#line 602
    scm_wta(s___0, (char *)2, s_symbol_bound_p);
    }
  }
#line 603
  if (o == (long )(16 << 9) + 372L) {
#line 604
    o = scm_sys_protects[5];
  }
#line 605
  if (! (6 & (int )o)) {
#line 605
    if (! ((125 & (int )((scm_cell *)o)->car) == 13)) {
      {
#line 605
      scm_wta(o, (char *)1, s_symbol_bound_p);
      }
    }
  } else {
    {
#line 605
    scm_wta(o, (char *)1, s_symbol_bound_p);
    }
  }
  {
#line 606
  vcell = scm_sym2ovcell_soft(s___0, o);
  }
#line 607
  if (! (6 & (int )vcell)) {
#line 607
    if (((scm_cell *)vcell)->cdr != (long )(18 << 9) + 372L) {
#line 607
      tmp = (long )(17 << 9) + 372L;
    } else {
#line 607
      tmp = (long )(16 << 9) + 372L;
    }
  } else {
#line 607
    tmp = (long )(16 << 9) + 372L;
  }
#line 607
  return (tmp);
}
}
#line 614 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.c"
static char s_symbol_set_x[12]  = 
#line 614
  {      (char )'s',      (char )'y',      (char )'m',      (char )'b', 
        (char )'o',      (char )'l',      (char )'-',      (char )'s', 
        (char )'e',      (char )'t',      (char )'!',      (char )'\000'};
#line 616 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.c"
SCM scm_symbol_set_x(SCM o , SCM s___0 , SCM v ) 
{ 
  SCM vcell ;

  {
#line 623
  if (! (6 & (int )s___0)) {
#line 623
    if (! ((125 & (int )((scm_cell *)s___0)->car) == 5)) {
      {
#line 623
      scm_wta(s___0, (char *)2, s_symbol_set_x);
      }
    }
  } else {
    {
#line 623
    scm_wta(s___0, (char *)2, s_symbol_set_x);
    }
  }
#line 624
  if (o == (long )(16 << 9) + 372L) {
#line 625
    o = scm_sys_protects[5];
  }
#line 626
  if (! (6 & (int )o)) {
#line 626
    if (! ((125 & (int )((scm_cell *)o)->car) == 13)) {
      {
#line 626
      scm_wta(o, (char *)1, s_symbol_set_x);
      }
    }
  } else {
    {
#line 626
    scm_wta(o, (char *)1, s_symbol_set_x);
    }
  }
  {
#line 627
  vcell = scm_sym2ovcell(s___0, o);
#line 628
  ((scm_cell *)vcell)->cdr = v;
  }
#line 629
  return ((long )(21 << 9) + 372L);
}
}
#line 632 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.c"
static void msymbolize(SCM s___0 ) 
{ 
  SCM string ;

  {
  {
#line 637
  string = scm_makfromstr((char const   *)((char *)((scm_cell *)s___0)->cdr), (unsigned long )((scm_cell *)s___0)->car >> 8,
                          5);
#line 638
  ((scm_cell *)s___0)->cdr = (SCM )((char *)((scm_cell *)string)->cdr);
#line 639
  ((scm_cell *)s___0)->car = (SCM )((((unsigned long )((scm_cell *)s___0)->car >> 8) << 8) + 7UL);
#line 640
  *((unsigned long *)((SCM *)*((SCM *)((char *)((scm_cell *)s___0)->cdr) - 1) + 3)) = (unsigned long )((long )(16 << 9) + 372L);
#line 641
  ((scm_cell *)string)->cdr = (long )(20 << 9) + 372L;
#line 642
  ((scm_cell *)string)->car = (long )(20 << 9) + 372L;
  }
#line 643
  return;
}
}
#line 646 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.c"
static char s_symbol_fref[12]  = 
#line 646
  {      (char )'s',      (char )'y',      (char )'m',      (char )'b', 
        (char )'o',      (char )'l',      (char )'-',      (char )'f', 
        (char )'r',      (char )'e',      (char )'f',      (char )'\000'};
#line 648 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.c"
SCM scm_symbol_fref(SCM s___0 ) 
{ 


  {
#line 652
  if (! (6 & (int )s___0)) {
#line 652
    if (! ((125 & (int )((scm_cell *)s___0)->car) == 5)) {
      {
#line 652
      scm_wta(s___0, (char *)1, s_symbol_fref);
      }
    }
  } else {
    {
#line 652
    scm_wta(s___0, (char *)1, s_symbol_fref);
    }
  }
#line 653
  scm_ints_disabled = 1;
#line 654
  if ((127 & (int )((scm_cell *)s___0)->car) == 5) {
    {
#line 655
    msymbolize(s___0);
    }
  }
#line 656
  scm_ints_disabled = 0;
#line 656
  scm_async_clock --;
#line 656
  if (0U == scm_async_clock) {
    {
#line 656
    scm_async_click();
    }
  }
#line 657
  return (*((SCM *)*((SCM *)((char *)((scm_cell *)s___0)->cdr) - 1) + 0));
}
}
#line 661 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.c"
static char s_symbol_pref[12]  = 
#line 661
  {      (char )'s',      (char )'y',      (char )'m',      (char )'b', 
        (char )'o',      (char )'l',      (char )'-',      (char )'p', 
        (char )'r',      (char )'e',      (char )'f',      (char )'\000'};
#line 663 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.c"
SCM scm_symbol_pref(SCM s___0 ) 
{ 


  {
#line 667
  if (! (6 & (int )s___0)) {
#line 667
    if (! ((125 & (int )((scm_cell *)s___0)->car) == 5)) {
      {
#line 667
      scm_wta(s___0, (char *)1, s_symbol_pref);
      }
    }
  } else {
    {
#line 667
    scm_wta(s___0, (char *)1, s_symbol_pref);
    }
  }
#line 668
  scm_ints_disabled = 1;
#line 669
  if ((127 & (int )((scm_cell *)s___0)->car) == 5) {
    {
#line 670
    msymbolize(s___0);
    }
  }
#line 671
  scm_ints_disabled = 0;
#line 671
  scm_async_clock --;
#line 671
  if (0U == scm_async_clock) {
    {
#line 671
    scm_async_click();
    }
  }
#line 672
  return (*((SCM *)*((SCM *)((char *)((scm_cell *)s___0)->cdr) - 1) + 1));
}
}
#line 676 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.c"
static char s_symbol_fset_x[13]  = 
#line 676
  {      (char )'s',      (char )'y',      (char )'m',      (char )'b', 
        (char )'o',      (char )'l',      (char )'-',      (char )'f', 
        (char )'s',      (char )'e',      (char )'t',      (char )'!', 
        (char )'\000'};
#line 678 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.c"
SCM scm_symbol_fset_x(SCM s___0 , SCM val ) 
{ 


  {
#line 683
  if (! (6 & (int )s___0)) {
#line 683
    if (! ((125 & (int )((scm_cell *)s___0)->car) == 5)) {
      {
#line 683
      scm_wta(s___0, (char *)1, s_symbol_fset_x);
      }
    }
  } else {
    {
#line 683
    scm_wta(s___0, (char *)1, s_symbol_fset_x);
    }
  }
#line 684
  scm_ints_disabled = 1;
#line 685
  if ((127 & (int )((scm_cell *)s___0)->car) == 5) {
    {
#line 686
    msymbolize(s___0);
    }
  }
#line 687
  scm_ints_disabled = 0;
#line 687
  scm_async_clock --;
#line 687
  if (0U == scm_async_clock) {
    {
#line 687
    scm_async_click();
    }
  }
#line 688
  *((SCM *)*((SCM *)((char *)((scm_cell *)s___0)->cdr) - 1) + 0) = val;
#line 689
  return ((long )(21 << 9) + 372L);
}
}
#line 693 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.c"
static char s_symbol_pset_x[13]  = 
#line 693
  {      (char )'s',      (char )'y',      (char )'m',      (char )'b', 
        (char )'o',      (char )'l',      (char )'-',      (char )'p', 
        (char )'s',      (char )'e',      (char )'t',      (char )'!', 
        (char )'\000'};
#line 695 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.c"
SCM scm_symbol_pset_x(SCM s___0 , SCM val ) 
{ 


  {
#line 700
  if (! (6 & (int )s___0)) {
#line 700
    if (! ((125 & (int )((scm_cell *)s___0)->car) == 5)) {
      {
#line 700
      scm_wta(s___0, (char *)1, s_symbol_pset_x);
      }
    }
  } else {
    {
#line 700
    scm_wta(s___0, (char *)1, s_symbol_pset_x);
    }
  }
#line 701
  scm_ints_disabled = 1;
#line 702
  if ((127 & (int )((scm_cell *)s___0)->car) == 5) {
    {
#line 703
    msymbolize(s___0);
    }
  }
#line 704
  *((SCM *)*((SCM *)((char *)((scm_cell *)s___0)->cdr) - 1) + 1) = val;
#line 705
  scm_ints_disabled = 0;
#line 705
  scm_async_clock --;
#line 705
  if (0U == scm_async_clock) {
    {
#line 705
    scm_async_click();
    }
  }
#line 706
  return ((long )(21 << 9) + 372L);
}
}
#line 710 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.c"
static char s_symbol_hash[12]  = 
#line 710
  {      (char )'s',      (char )'y',      (char )'m',      (char )'b', 
        (char )'o',      (char )'l',      (char )'-',      (char )'h', 
        (char )'a',      (char )'s',      (char )'h',      (char )'\000'};
#line 712 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.c"
SCM scm_symbol_hash(SCM s___0 ) 
{ 


  {
#line 716
  if (! (6 & (int )s___0)) {
#line 716
    if (! ((125 & (int )((scm_cell *)s___0)->car) == 5)) {
      {
#line 716
      scm_wta(s___0, (char *)1, s_symbol_hash);
      }
    }
  } else {
    {
#line 716
    scm_wta(s___0, (char *)1, s_symbol_hash);
    }
  }
#line 717
  return ((SCM )((((unsigned long )s___0 ^ *((unsigned long *)((SCM *)*((SCM *)((char *)((scm_cell *)s___0)->cdr) - 1) + 2))) << 2) + 2UL));
}
}
#line 722 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.c"
void scm_init_symbols(void) 
{ 


  {
  {
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.x"
  scm_make_gsubr(s_symbol_p, 1, 0, 0, (SCM (*)())(& scm_symbol_p));
#line 2
  scm_make_gsubr(s_symbol_to_string, 1, 0, 0, (SCM (*)())(& scm_symbol_to_string));
#line 3
  scm_make_gsubr(s_string_to_symbol, 1, 0, 0, (SCM (*)())(& scm_string_to_symbol));
#line 4
  scm_make_gsubr(s_string_to_obarray_symbol, 2, 1, 0, (SCM (*)())(& scm_string_to_obarray_symbol));
#line 5
  scm_make_gsubr(s_intern_symbol, 2, 0, 0, (SCM (*)())(& scm_intern_symbol));
#line 6
  scm_make_gsubr(s_unintern_symbol, 2, 0, 0, (SCM (*)())(& scm_unintern_symbol));
#line 7
  scm_make_gsubr(s_symbol_binding, 2, 0, 0, (SCM (*)())(& scm_symbol_binding));
#line 8
  scm_make_gsubr(s_symbol_interned_p, 2, 0, 0, (SCM (*)())(& scm_symbol_interned_p));
#line 9
  scm_make_gsubr(s_symbol_bound_p, 2, 0, 0, (SCM (*)())(& scm_symbol_bound_p));
#line 10
  scm_make_gsubr(s_symbol_set_x, 3, 0, 0, (SCM (*)())(& scm_symbol_set_x));
#line 11
  scm_make_gsubr(s_symbol_fref, 1, 0, 0, (SCM (*)())(& scm_symbol_fref));
#line 12
  scm_make_gsubr(s_symbol_pref, 1, 0, 0, (SCM (*)())(& scm_symbol_pref));
#line 13
  scm_make_gsubr(s_symbol_fset_x, 2, 0, 0, (SCM (*)())(& scm_symbol_fset_x));
#line 14
  scm_make_gsubr(s_symbol_pset_x, 2, 0, 0, (SCM (*)())(& scm_symbol_pset_x));
#line 15
  scm_make_gsubr(s_symbol_hash, 1, 0, 0, (SCM (*)())(& scm_symbol_hash));
  }
#line 726 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/symbols.c"
  return;
}
}
#line 75 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strings.h"
SCM scm_string_append(SCM args ) ;
#line 75 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/struct.h"
SCM scm_make_struct_layout(SCM fields ) ;
#line 76
SCM scm_struct_p(SCM x ) ;
#line 77
SCM scm_struct_vtable_p(SCM x ) ;
#line 78
SCM scm_make_struct(SCM vtable , SCM tail_array_size , SCM init ) ;
#line 79
SCM scm_make_vtable_vtable(SCM extra_fields , SCM tail_array_size , SCM init ) ;
#line 80
SCM scm_struct_ref(SCM handle , SCM pos ) ;
#line 81
SCM scm_struct_set_x(SCM handle , SCM pos , SCM val ) ;
#line 82
SCM scm_struct_vtable(SCM handle ) ;
#line 83
SCM scm_struct_vtable_tag(SCM handle ) ;
#line 84
void scm_init_struct(void) ;
#line 55 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/struct.c"
static SCM required_vtable_fields  =    (long )(16 << 9) + 372L;
#line 56 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/struct.c"
static int struct_num  =    0;
#line 59 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/struct.c"
static char s_struct_make_layout[19]  = 
#line 59
  {      (char )'m',      (char )'a',      (char )'k',      (char )'e', 
        (char )'-',      (char )'s',      (char )'t',      (char )'r', 
        (char )'u',      (char )'c',      (char )'t',      (char )'-', 
        (char )'l',      (char )'a',      (char )'y',      (char )'o', 
        (char )'u',      (char )'t',      (char )'\000'};
#line 61 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/struct.c"
SCM scm_make_struct_layout(SCM fields ) 
{ 
  SCM new_sym ;
  char *field_desc ;
  int len ;
  int x ;
  SCM tmp ;
  SCM tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 66
  if (! (6 & (int )fields)) {
#line 66
    if (! ((117 & (int )((scm_cell *)fields)->car) == 21)) {
#line 66
      if (! ((125 & (int )((scm_cell *)fields)->car) == 5)) {
        {
#line 66
        scm_wta(fields, (char *)1, s_struct_make_layout);
        }
      }
    }
  } else {
    {
#line 66
    scm_wta(fields, (char *)1, s_struct_make_layout);
    }
  }
#line 74
  len = (int )((unsigned long )((scm_cell *)fields)->car >> 8);
#line 75
  if ((127 & (int )((scm_cell *)fields)->car) == 29) {
#line 75
    field_desc = (char *)((scm_cell *)((scm_cell *)((scm_cell *)fields)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)fields)->cdr)->car >> 2);
  } else {
#line 75
    field_desc = (char *)((scm_cell *)fields)->cdr;
  }
#line 76
  if (! (! (len & 1))) {
    {
#line 76
    scm_wta(fields, (char *)"odd length field specification", s_struct_make_layout);
    }
  }
#line 78
  x = 0;
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (! (x < len)) {
#line 78
      goto while_break;
    }
    {
#line 88
    if ((int )*(field_desc + x) == 115) {
#line 88
      goto case_115;
    }
#line 88
    if ((int )*(field_desc + x) == 112) {
#line 88
      goto case_115;
    }
#line 88
    if ((int )*(field_desc + x) == 117) {
#line 88
      goto case_115;
    }
#line 90
    goto switch_default;
    case_115: /* CIL Label */ 
    case_112: /* CIL Label */ 
    case_117: /* CIL Label */ 
#line 89
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 91
    scm_wta((SCM )(((int )*(field_desc + x) << 8) + 244), (char *)"unrecognized field type",
            s_struct_make_layout);
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 96
    if ((int )*(field_desc + (x + 1)) == 119) {
#line 96
      goto case_119;
    }
#line 101
    if ((int )*(field_desc + (x + 1)) == 111) {
#line 101
      goto case_111;
    }
#line 101
    if ((int )*(field_desc + (x + 1)) == 114) {
#line 101
      goto case_111;
    }
#line 105
    if ((int )*(field_desc + (x + 1)) == 79) {
#line 105
      goto case_79;
    }
#line 105
    if ((int )*(field_desc + (x + 1)) == 87) {
#line 105
      goto case_79;
    }
#line 105
    if ((int )*(field_desc + (x + 1)) == 82) {
#line 105
      goto case_79;
    }
#line 113
    goto switch_default___0;
    case_119: /* CIL Label */ 
#line 97
    if (! ((int )*(field_desc + x) != 115)) {
      {
#line 97
      scm_wta((SCM )(((int )*(field_desc + (x + 1)) << 8) + 244), (char *)"self fields not writable",
              s_struct_make_layout);
      }
    }
    case_111: /* CIL Label */ 
    case_114: /* CIL Label */ 
#line 102
    goto switch_break___0;
    case_79: /* CIL Label */ 
    case_87: /* CIL Label */ 
    case_82: /* CIL Label */ 
#line 106
    if (! ((int )*(field_desc + x) != 115)) {
      {
#line 106
      scm_wta((SCM )(((int )*(field_desc + (x + 1)) << 8) + 244), (char *)"self fields not allowed in tail array",
              s_struct_make_layout);
      }
    }
#line 109
    if (! (x == len - 2)) {
      {
#line 109
      scm_wta((SCM )(((int )*(field_desc + (x + 1)) << 8) + 244), (char *)"tail array field must be last field in layout",
              s_struct_make_layout);
      }
    }
#line 112
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 114
    scm_wta((SCM )(((int )*(field_desc + x) << 8) + 244), (char *)"unrecognized ref specification",
            s_struct_make_layout);
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 78
    x += 2;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 125
  tmp = scm_intern_obarray(field_desc, (size_t )len, (long )(16 << 9) + 372L);
#line 125
  new_sym = ((scm_cell *)tmp)->car;
#line 127
  tmp___0 = scm_return_first(new_sym, fields);
  }
#line 127
  return (tmp___0);
}
}
#line 134
static void init_struct(SCM handle , int tail_elts , SCM inits ) ;
#line 136 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/struct.c"
static void init_struct(SCM handle , int tail_elts , SCM inits ) 
{ 
  SCM layout ;
  SCM *data ;
  unsigned char *fields_desc ;
  unsigned char prot ;
  int n_fields ;
  SCM *mem ;
  int tailp ;
  int tmp ;
  SCM *tmp___0 ;
  unsigned long tmp___1 ;
  char *__cil_tmp14 ;

  {
#line 145
  prot = (unsigned char)0;
#line 148
  tailp = 0;
#line 150
  layout = *((SCM *)(((scm_cell *)handle)->car - 1L) + 0);
#line 151
  data = (SCM *)((scm_cell *)handle)->cdr;
#line 152
  fields_desc = (unsigned char *)((char *)((scm_cell *)layout)->cdr) - 2;
#line 153
  n_fields = (int )(((unsigned long )((scm_cell *)layout)->car >> 8) / 2UL);
#line 154
  mem = (SCM *)((scm_cell *)handle)->cdr;
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    if (! n_fields) {
#line 155
      goto while_break;
    }
#line 157
    if (! tailp) {
#line 159
      fields_desc += 2;
#line 160
      prot = *(fields_desc + 1);
#line 161
      if (((int )prot & 32) == 0) {
#line 163
        tailp = 1;
#line 164
        if ((int )prot == 82) {
#line 164
          prot = (unsigned char )'r';
        } else {
#line 164
          if ((int )prot == 87) {
#line 164
            tmp = 'w';
          } else {
#line 164
            tmp = 'o';
          }
#line 164
          prot = (unsigned char )tmp;
        }
#line 165
        tmp___0 = mem;
#line 165
        mem ++;
#line 165
        *tmp___0 = (SCM )tail_elts;
#line 166
        n_fields += tail_elts - 1;
#line 167
        if (n_fields == 0) {
#line 168
          goto while_break;
        }
      }
    }
    {
#line 186
    if ((int )*fields_desc == 117) {
#line 186
      goto case_117;
    }
#line 196
    if ((int )*fields_desc == 112) {
#line 196
      goto case_112;
    }
#line 220
    if ((int )*fields_desc == 115) {
#line 220
      goto case_115;
    }
#line 172
    goto switch_break;
    case_117: /* CIL Label */ 
#line 187
    if ((int )prot != 114) {
#line 187
      if ((int )prot != 119) {
#line 188
        *mem = (SCM )0;
      } else {
#line 187
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 187
    if (inits == (long )(20 << 9) + 372L) {
#line 188
      *mem = (SCM )0;
    } else {
      {
#line 191
      tmp___1 = scm_num2ulong(((scm_cell *)inits)->car, (char *)0, (char *)"init_struct");
#line 191
      *mem = (SCM )tmp___1;
#line 192
      inits = ((scm_cell *)inits)->cdr;
      }
    }
#line 194
    goto switch_break;
    case_112: /* CIL Label */ 
#line 197
    if ((int )prot != 114) {
#line 197
      if ((int )prot != 119) {
#line 198
        *mem = (long )(20 << 9) + 372L;
      } else {
#line 197
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 197
    if (inits == (long )(20 << 9) + 372L) {
#line 198
      *mem = (long )(20 << 9) + 372L;
    } else {
#line 201
      *mem = ((scm_cell *)inits)->car;
#line 202
      inits = ((scm_cell *)inits)->cdr;
    }
#line 205
    goto switch_break;
    case_115: /* CIL Label */ 
#line 221
    *mem = handle;
#line 222
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 225
    n_fields --;
#line 226
    mem ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 228
  return;
}
}
#line 231 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/struct.c"
static char s_struct_p[8]  = 
#line 231
  {      (char )'s',      (char )'t',      (char )'r',      (char )'u', 
        (char )'c',      (char )'t',      (char )'?',      (char )'\000'};
#line 233 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/struct.c"
SCM scm_struct_p(SCM x ) 
{ 
  long tmp ;

  {
#line 237
  if (! (6 & (int )x)) {
#line 237
    if ((7 & (int )((scm_cell *)x)->car) == 1) {
#line 237
      tmp = (long )(17 << 9) + 372L;
    } else {
#line 237
      tmp = (long )(16 << 9) + 372L;
    }
  } else {
#line 237
    tmp = (long )(16 << 9) + 372L;
  }
#line 237
  return (tmp);
}
}
#line 242 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/struct.c"
static char s_struct_vtable_p[15]  = 
#line 242
  {      (char )'s',      (char )'t',      (char )'r',      (char )'u', 
        (char )'c',      (char )'t',      (char )'-',      (char )'v', 
        (char )'t',      (char )'a',      (char )'b',      (char )'l', 
        (char )'e',      (char )'?',      (char )'\000'};
#line 244 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/struct.c"
SCM scm_struct_vtable_p(SCM x ) 
{ 
  SCM layout ;
  SCM *mem ;
  int tmp ;
  long tmp___0 ;

  {
#line 251
  if (6 & (int )x) {
#line 252
    return ((long )(16 << 9) + 372L);
  }
#line 254
  if (! ((7 & (int )((scm_cell *)x)->car) == 1)) {
#line 255
    return ((long )(16 << 9) + 372L);
  }
#line 257
  layout = *((SCM *)(((scm_cell *)x)->car - 1L) + 0);
#line 259
  if ((unsigned long )((scm_cell *)layout)->car >> 8 < (unsigned long )((scm_cell *)required_vtable_fields)->car >> 8) {
#line 260
    return ((long )(16 << 9) + 372L);
  }
  {
#line 262
  tmp = strncmp((char const   *)((char *)((scm_cell *)layout)->cdr), (char const   *)((char *)((scm_cell *)required_vtable_fields)->cdr),
                (unsigned long )((scm_cell *)required_vtable_fields)->car >> 8);
  }
#line 262
  if (tmp) {
#line 264
    return ((long )(16 << 9) + 372L);
  }
#line 266
  mem = (SCM *)((scm_cell *)x)->cdr;
#line 268
  if (*(mem + 1) != 0L) {
#line 269
    return ((long )(16 << 9) + 372L);
  }
#line 271
  if (6 & (int )*(mem + 0)) {
#line 272
    return ((long )(16 << 9) + 372L);
  }
#line 274
  if ((125 & (int )((scm_cell *)*(mem + 0))->car) == 5) {
#line 274
    tmp___0 = (long )(17 << 9) + 372L;
  } else {
#line 274
    tmp___0 = (long )(16 << 9) + 372L;
  }
#line 274
  return (tmp___0);
}
}
#line 313
static SCM *alloc_struct(int n_words , char *who ) ;
#line 315 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/struct.c"
static SCM *alloc_struct(int n_words , char *who ) 
{ 
  int size ;
  SCM *block ;
  char *tmp ;
  SCM *p ;
  int tmp___0 ;

  {
  {
#line 320
  size = (int )(sizeof(SCM ) * (unsigned long )(n_words + 3) + 7UL);
#line 321
  tmp = scm_must_malloc((long )size, who);
#line 321
  block = (SCM *)tmp;
#line 324
  p = block + 3;
#line 327
  p = (SCM *)(((SCM )p + 7L) & -8L);
#line 330
  *(p + -3) = (SCM )block;
#line 331
  *(p + -2) = (SCM )(3 + n_words);
#line 332
  tmp___0 = struct_num;
#line 332
  struct_num ++;
#line 332
  *(p + -1) = (SCM )tmp___0;
  }
#line 334
  return (p);
}
}
#line 338 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/struct.c"
static char s_make_struct[12]  = 
#line 338
  {      (char )'m',      (char )'a',      (char )'k',      (char )'e', 
        (char )'-',      (char )'s',      (char )'t',      (char )'r', 
        (char )'u',      (char )'c',      (char )'t',      (char )'\000'};
#line 340 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/struct.c"
SCM scm_make_struct(SCM vtable , SCM tail_array_size , SCM init ) 
{ 
  SCM layout ;
  int basic_size ;
  int tail_elts ;
  SCM *data ;
  SCM handle ;
  SCM tmp ;
  char *__cil_tmp10 ;

  {
  {
#line 352
  tmp = scm_struct_vtable_p(vtable);
  }
#line 352
  if (! ((long )(16 << 9) + 372L != tmp)) {
    {
#line 352
    scm_wta(vtable, (char *)1, s_make_struct);
    }
  }
#line 354
  if (! (2 & (int )tail_array_size)) {
    {
#line 354
    scm_wta(tail_array_size, (char *)2, s_make_struct);
    }
  }
#line 357
  layout = *((SCM *)((scm_cell *)vtable)->cdr + 0);
#line 358
  basic_size = (int )(((unsigned long )((scm_cell *)layout)->car >> 8) / 2UL);
#line 359
  tail_elts = (int )(tail_array_size >> 2);
#line 360
  if (6 & (int )scm_freelist) {
    {
#line 360
    handle = scm_gc_for_newcell();
    }
  } else {
#line 360
    handle = scm_freelist;
#line 360
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 360
    scm_cells_allocated ++;
  }
  {
#line 361
  scm_ints_disabled = 1;
#line 362
  data = alloc_struct(basic_size + tail_elts, (char *)"make-struct");
#line 363
  ((scm_cell *)handle)->cdr = (SCM )data;
#line 364
  ((scm_cell *)handle)->car = (SCM )((SCM *)((scm_cell *)vtable)->cdr) + 1L;
#line 365
  init_struct(handle, tail_elts, init);
#line 366
  scm_ints_disabled = 0;
#line 366
  scm_async_clock --;
  }
#line 366
  if (0U == scm_async_clock) {
    {
#line 366
    scm_async_click();
    }
  }
#line 367
  return (handle);
}
}
#line 372 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/struct.c"
static char s_make_vtable_vtable[19]  = 
#line 372
  {      (char )'m',      (char )'a',      (char )'k',      (char )'e', 
        (char )'-',      (char )'v',      (char )'t',      (char )'a', 
        (char )'b',      (char )'l',      (char )'e',      (char )'-', 
        (char )'v',      (char )'t',      (char )'a',      (char )'b', 
        (char )'l',      (char )'e',      (char )'\000'};
#line 374 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/struct.c"
SCM scm_make_vtable_vtable(SCM extra_fields , SCM tail_array_size , SCM init ) 
{ 
  SCM fields ;
  SCM layout ;
  int basic_size ;
  int tail_elts ;
  SCM *data ;
  SCM handle ;
  SCM tmp ;
  SCM tmp___0 ;
  char *__cil_tmp12 ;

  {
#line 387
  if (! (6 & (int )extra_fields)) {
#line 387
    if (! ((117 & (int )((scm_cell *)extra_fields)->car) == 21)) {
#line 387
      if (! ((125 & (int )((scm_cell *)extra_fields)->car) == 5)) {
        {
#line 387
        scm_wta(extra_fields, (char *)1, s_make_vtable_vtable);
        }
      }
    }
  } else {
    {
#line 387
    scm_wta(extra_fields, (char *)1, s_make_vtable_vtable);
    }
  }
#line 389
  if (! (2 & (int )tail_array_size)) {
    {
#line 389
    scm_wta(tail_array_size, (char *)2, s_make_vtable_vtable);
    }
  }
  {
#line 392
  tmp = scm_listify(required_vtable_fields, extra_fields, (long )(18 << 9) + 372L);
#line 392
  fields = scm_string_append(tmp);
#line 395
  layout = scm_make_struct_layout(fields);
#line 396
  basic_size = (int )(((unsigned long )((scm_cell *)layout)->car >> 8) / 2UL);
#line 397
  tail_elts = (int )(tail_array_size >> 2);
  }
#line 398
  if (6 & (int )scm_freelist) {
    {
#line 398
    handle = scm_gc_for_newcell();
    }
  } else {
#line 398
    handle = scm_freelist;
#line 398
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 398
    scm_cells_allocated ++;
  }
  {
#line 399
  scm_ints_disabled = 1;
#line 400
  data = alloc_struct(basic_size + tail_elts, (char *)"make-vtable-vtable");
#line 401
  ((scm_cell *)handle)->cdr = (SCM )data;
#line 402
  ((scm_cell *)handle)->car = (SCM )data + 1L;
#line 403
  *((SCM *)(((scm_cell *)handle)->car - 1L) + 0) = layout;
#line 404
  tmp___0 = scm_cons(layout, init);
#line 404
  init_struct(handle, tail_elts, tmp___0);
#line 405
  scm_ints_disabled = 0;
#line 405
  scm_async_clock --;
  }
#line 405
  if (0U == scm_async_clock) {
    {
#line 405
    scm_async_click();
    }
  }
#line 406
  return (handle);
}
}
#line 412 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/struct.c"
static char s_struct_ref[11]  = 
#line 412
  {      (char )'s',      (char )'t',      (char )'r',      (char )'u', 
        (char )'c',      (char )'t',      (char )'-',      (char )'r', 
        (char )'e',      (char )'f',      (char )'\000'};
#line 414 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/struct.c"
SCM scm_struct_ref(SCM handle , SCM pos ) 
{ 
  SCM answer ;
  SCM *data ;
  SCM layout ;
  int p ;
  int n_fields ;
  unsigned char *fields_desc ;
  unsigned char field_type ;
  unsigned char ref ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 419
  answer = (long )(18 << 9) + 372L;
#line 428
  if (! (6 & (int )handle)) {
#line 428
    if (! ((7 & (int )((scm_cell *)handle)->car) == 1)) {
      {
#line 428
      scm_wta(handle, (char *)1, s_struct_ref);
      }
    }
  } else {
    {
#line 428
    scm_wta(handle, (char *)1, s_struct_ref);
    }
  }
#line 430
  if (! (2 & (int )pos)) {
    {
#line 430
    scm_wta(pos, (char *)2, s_struct_ref);
    }
  }
#line 432
  layout = *((SCM *)(((scm_cell *)handle)->car - 1L) + 0);
#line 433
  data = (SCM *)((scm_cell *)handle)->cdr;
#line 434
  p = (int )(pos >> 2);
#line 436
  fields_desc = (unsigned char *)((char *)((scm_cell *)layout)->cdr);
#line 437
  n_fields = (int )(*(data + -3) - 3L);
#line 439
  if (! (p < n_fields)) {
    {
#line 439
    scm_wta(pos, (char *)10, s_struct_ref);
    }
  }
#line 441
  if ((unsigned long )(p * 2) < (unsigned long )((scm_cell *)layout)->car >> 8) {
#line 444
    field_type = *(fields_desc + p * 2);
#line 445
    ref = *(fields_desc + (p * 2 + 1));
#line 446
    if ((int )ref != 114) {
#line 446
      if ((int )ref != 119) {
#line 448
        if ((int )ref == 82) {
#line 449
          field_type = (unsigned char )'u';
        } else
#line 448
        if ((int )ref == 87) {
#line 449
          field_type = (unsigned char )'u';
        } else {
          {
#line 451
          scm_wta(pos, (char *)"ref denied", s_struct_ref);
          }
        }
      }
    }
  } else
#line 454
  if ((int )*(fields_desc + (((unsigned long )((scm_cell *)layout)->car >> 8) - 1UL)) != 79) {
#line 455
    field_type = *(fields_desc + (((unsigned long )((scm_cell *)layout)->car >> 8) - 2UL));
  } else {
    {
#line 458
    scm_wta(pos, (char *)"ref denied", s_struct_ref);
#line 459
    abort();
    }
  }
  {
#line 464
  if ((int )field_type == 117) {
#line 464
    goto case_117;
  }
#line 479
  if ((int )field_type == 112) {
#line 479
    goto case_112;
  }
#line 479
  if ((int )field_type == 115) {
#line 479
    goto case_112;
  }
#line 484
  goto switch_default;
  case_117: /* CIL Label */ 
  {
#line 465
  answer = scm_ulong2num((unsigned long )*(data + p));
  }
#line 466
  goto switch_break;
  case_112: /* CIL Label */ 
  case_115: /* CIL Label */ 
#line 480
  answer = *(data + p);
#line 481
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 485
  scm_wta((SCM )(((int )field_type << 8) + 244), (char *)"unrecognized field type",
          s_struct_ref);
  }
#line 486
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 489
  return (answer);
}
}
#line 493 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/struct.c"
static char s_struct_set_x[12]  = 
#line 493
  {      (char )'s',      (char )'t',      (char )'r',      (char )'u', 
        (char )'c',      (char )'t',      (char )'-',      (char )'s', 
        (char )'e',      (char )'t',      (char )'!',      (char )'\000'};
#line 495 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/struct.c"
SCM scm_struct_set_x(SCM handle , SCM pos , SCM val ) 
{ 
  SCM *data ;
  SCM layout ;
  int p ;
  int n_fields ;
  unsigned char *fields_desc ;
  unsigned char field_type ;
  unsigned char set_x ;
  unsigned long tmp ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 510
  if (! (6 & (int )handle)) {
#line 510
    if (! ((7 & (int )((scm_cell *)handle)->car) == 1)) {
      {
#line 510
      scm_wta(handle, (char *)1, s_struct_ref);
      }
    }
  } else {
    {
#line 510
    scm_wta(handle, (char *)1, s_struct_ref);
    }
  }
#line 512
  if (! (2 & (int )pos)) {
    {
#line 512
    scm_wta(pos, (char *)2, s_struct_ref);
    }
  }
#line 514
  layout = *((SCM *)(((scm_cell *)handle)->car - 1L) + 0);
#line 515
  data = (SCM *)((scm_cell *)handle)->cdr;
#line 516
  p = (int )(pos >> 2);
#line 518
  fields_desc = (unsigned char *)((char *)((scm_cell *)layout)->cdr);
#line 519
  n_fields = (int )(*(data + -3) - 3L);
#line 521
  if (! (p < n_fields)) {
    {
#line 521
    scm_wta(pos, (char *)10, s_struct_set_x);
    }
  }
#line 523
  if ((unsigned long )(p * 2) < (unsigned long )((scm_cell *)layout)->car >> 8) {
#line 526
    field_type = *(fields_desc + p * 2);
#line 527
    set_x = *(fields_desc + (p * 2 + 1));
#line 528
    if ((int )set_x != 119) {
      {
#line 529
      scm_wta(pos, (char *)"set_x denied", s_struct_set_x);
      }
    }
  } else
#line 531
  if ((int )*(fields_desc + (((unsigned long )((scm_cell *)layout)->car >> 8) - 1UL)) == 87) {
#line 532
    field_type = *(fields_desc + (((unsigned long )((scm_cell *)layout)->car >> 8) - 2UL));
  } else {
    {
#line 535
    scm_wta(pos, (char *)"set_x denied", s_struct_ref);
#line 536
    abort();
    }
  }
  {
#line 541
  if ((int )field_type == 117) {
#line 541
    goto case_117;
  }
#line 555
  if ((int )field_type == 112) {
#line 555
    goto case_112;
  }
#line 559
  if ((int )field_type == 115) {
#line 559
    goto case_115;
  }
#line 563
  goto switch_default;
  case_117: /* CIL Label */ 
  {
#line 542
  tmp = scm_num2ulong(val, (char *)3, s_struct_set_x);
#line 542
  *(data + p) = (SCM )tmp;
  }
#line 543
  goto switch_break;
  case_112: /* CIL Label */ 
#line 556
  *(data + p) = val;
#line 557
  goto switch_break;
  case_115: /* CIL Label */ 
  {
#line 560
  scm_wta((SCM )(((int )field_type << 8) + 244), (char *)"self fields immutable",
          s_struct_set_x);
  }
#line 561
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 564
  scm_wta((SCM )(((int )field_type << 8) + 244), (char *)"unrecognized field type",
          s_struct_set_x);
  }
#line 565
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 568
  return (val);
}
}
#line 572 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/struct.c"
static char s_struct_vtable[14]  = 
#line 572
  {      (char )'s',      (char )'t',      (char )'r',      (char )'u', 
        (char )'c',      (char )'t',      (char )'-',      (char )'v', 
        (char )'t',      (char )'a',      (char )'b',      (char )'l', 
        (char )'e',      (char )'\000'};
#line 574 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/struct.c"
SCM scm_struct_vtable(SCM handle ) 
{ 


  {
#line 578
  if (! (6 & (int )handle)) {
#line 578
    if (! ((7 & (int )((scm_cell *)handle)->car) == 1)) {
      {
#line 578
      scm_wta(handle, (char *)1, s_struct_vtable);
      }
    }
  } else {
    {
#line 578
    scm_wta(handle, (char *)1, s_struct_vtable);
    }
  }
#line 580
  return (*((SCM *)(((scm_cell *)handle)->car - 1L) + 2));
}
}
#line 584 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/struct.c"
static char s_struct_vtable_tag[18]  = 
#line 584
  {      (char )'s',      (char )'t',      (char )'r',      (char )'u', 
        (char )'c',      (char )'t',      (char )'-',      (char )'v', 
        (char )'t',      (char )'a',      (char )'b',      (char )'l', 
        (char )'e',      (char )'-',      (char )'t',      (char )'a', 
        (char )'g',      (char )'\000'};
#line 586 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/struct.c"
SCM scm_struct_vtable_tag(SCM handle ) 
{ 
  SCM tmp ;
  SCM tmp___0 ;

  {
#line 590
  if (! (6 & (int )handle)) {
    {
#line 590
    tmp = scm_struct_vtable_p(handle);
    }
#line 590
    if (! ((long )(16 << 9) + 372L != tmp)) {
      {
#line 590
      scm_wta(handle, (char *)1, s_struct_vtable_tag);
      }
    }
  } else {
    {
#line 590
    scm_wta(handle, (char *)1, s_struct_vtable_tag);
    }
  }
  {
#line 592
  tmp___0 = scm_long2num(*((SCM *)((scm_cell *)handle)->cdr + -1));
  }
#line 592
  return (tmp___0);
}
}
#line 599 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/struct.c"
void scm_init_struct(void) 
{ 
  SCM tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 602
  tmp = scm_intern_obarray((char *)"pruosr", sizeof("pruosr") - 1UL, (long )(16 << 9) + 372L);
#line 602
  required_vtable_fields = ((scm_cell *)tmp)->car;
#line 603
  scm_permanent_object(required_vtable_fields);
#line 604
  scm_sysintern((char *)"struct-vtable-offset", (long )(3 << 2) + 2L);
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/struct.x"
  scm_make_gsubr(s_struct_make_layout, 1, 0, 0, (SCM (*)())(& scm_make_struct_layout));
#line 2
  scm_make_gsubr(s_struct_p, 1, 0, 0, (SCM (*)())(& scm_struct_p));
#line 3
  scm_make_gsubr(s_struct_vtable_p, 1, 0, 0, (SCM (*)())(& scm_struct_vtable_p));
#line 4
  scm_make_gsubr(s_make_struct, 2, 0, 1, (SCM (*)())(& scm_make_struct));
#line 5
  scm_make_gsubr(s_make_vtable_vtable, 2, 0, 1, (SCM (*)())(& scm_make_vtable_vtable));
#line 6
  scm_make_gsubr(s_struct_ref, 2, 0, 0, (SCM (*)())(& scm_struct_ref));
#line 7
  scm_make_gsubr(s_struct_set_x, 3, 0, 0, (SCM (*)())(& scm_struct_set_x));
#line 8
  scm_make_gsubr(s_struct_vtable, 1, 0, 0, (SCM (*)())(& scm_struct_vtable));
#line 9
  scm_make_gsubr(s_struct_vtable_tag, 1, 0, 0, (SCM (*)())(& scm_struct_vtable_tag));
  }
#line 606 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/struct.c"
  return;
}
}
#line 64 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strings.h"
SCM scm_makstr(long len , int slots ) ;
#line 181 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.h"
SCM scm_close_port(SCM port ) ;
#line 162 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.h"
SCM scm_eval_x(SCM obj ) ;
#line 79 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/read.h"
SCM scm_read(SCM port , SCM case_insensitive_p , SCM sharp ) ;
#line 49 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strports.h"
scm_ptobfuns scm_stptob ;
#line 53
SCM scm_mkstrport(SCM pos , SCM str , long modes , char *caller ) ;
#line 54
SCM scm_call_with_output_string(SCM proc ) ;
#line 55
SCM scm_strprint_obj(SCM obj ) ;
#line 56
SCM scm_call_with_input_string(SCM str , SCM proc ) ;
#line 57
SCM scm_read_0str(char *expr ) ;
#line 58
SCM scm_eval_0str(char *expr ) ;
#line 59
void scm_init_strports(void) ;
#line 62 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strports.c"
static int prinstpt(SCM exp___0 , SCM port , scm_print_state *pstate ) ;
#line 64 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strports.c"
static int prinstpt(SCM exp___0 , SCM port , scm_print_state *pstate ) 
{ 
  char *__cil_tmp4 ;

  {
  {
#line 70
  scm_prinport(exp___0, port, (char *)"string");
  }
#line 71
  return (1);
}
}
#line 75
static int stputc(int c , SCM p ) ;
#line 77 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strports.c"
static int stputc(int c , SCM p ) 
{ 
  size_t ind ;

  {
#line 82
  ind = (size_t )(((scm_cell *)p)->car >> 2);
#line 83
  scm_ints_disabled = 1;
#line 84
  if (ind >= (unsigned long )((scm_cell *)((scm_cell *)p)->cdr)->car >> 8) {
    {
#line 85
    scm_vector_set_length_x(((scm_cell *)p)->cdr, (SCM )(((ind + (ind >> 1)) << 2) + 2UL));
    }
  }
#line 86
  scm_ints_disabled = 0;
#line 86
  scm_async_clock --;
#line 86
  if (0U == scm_async_clock) {
    {
#line 86
    scm_async_click();
    }
  }
#line 87
  *((char *)((scm_cell *)((scm_cell *)p)->cdr)->cdr + ind) = (char )c;
#line 88
  ((scm_cell *)p)->car = (SCM )(((ind + 1UL) << 2) + 2UL);
#line 89
  return (c);
}
}
#line 93
static size_t stwrite(char *str , size_t siz , size_t num , SCM p ) ;
#line 95 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strports.c"
static size_t stwrite(char *str , size_t siz , size_t num , SCM p ) 
{ 
  size_t ind ;
  size_t len ;
  char *dst ;
  size_t tmp ;

  {
#line 102
  ind = (size_t )(((scm_cell *)p)->car >> 2);
#line 103
  len = siz * num;
#line 105
  scm_ints_disabled = 1;
#line 106
  if (ind + len >= (unsigned long )((scm_cell *)((scm_cell *)p)->cdr)->car >> 8) {
    {
#line 107
    scm_vector_set_length_x(((scm_cell *)p)->cdr, (SCM )((((ind + len) + ((ind + len) >> 1)) << 2) + 2UL));
    }
  }
#line 108
  scm_ints_disabled = 0;
#line 108
  scm_async_clock --;
#line 108
  if (0U == scm_async_clock) {
    {
#line 108
    scm_async_click();
    }
  }
#line 109
  dst = (char *)((scm_cell *)((scm_cell *)p)->cdr)->cdr + ind;
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    tmp = len;
#line 110
    len --;
#line 110
    if (! tmp) {
#line 110
      goto while_break;
    }
#line 111
    *(dst + len) = *(str + len);
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  ((scm_cell *)p)->car = (SCM )(((ind + siz * num) << 2) + 2UL);
#line 113
  return (num);
}
}
#line 117
static int stputs(char *s___0 , SCM p ) ;
#line 119 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strports.c"
static int stputs(char *s___0 , SCM p ) 
{ 
  size_t tmp ;

  {
  {
#line 124
  tmp = strlen((char const   *)s___0);
#line 124
  stwrite(s___0, (size_t )1, tmp, p);
  }
#line 125
  return (0);
}
}
#line 129
static int stgetc(SCM p ) ;
#line 131 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strports.c"
static int stgetc(SCM p ) 
{ 
  size_t ind ;
  unsigned char *tmp ;

  {
#line 135
  ind = (size_t )(((scm_cell *)p)->car >> 2);
#line 136
  if (ind >= (unsigned long )((scm_cell *)((scm_cell *)p)->cdr)->car >> 8) {
#line 137
    return (-1);
  }
#line 138
  ((scm_cell *)p)->car = (SCM )(((ind + 1UL) << 2) + 2UL);
#line 139
  if ((127 & (int )((scm_cell *)((scm_cell *)p)->cdr)->car) == 29) {
#line 139
    tmp = (unsigned char *)((scm_cell *)((scm_cell *)((scm_cell *)((scm_cell *)p)->cdr)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)((scm_cell *)p)->cdr)->cdr)->car >> 2);
  } else {
#line 139
    tmp = (unsigned char *)((scm_cell *)((scm_cell *)p)->cdr)->cdr;
  }
#line 139
  return ((int )*(tmp + ind));
}
}
#line 143 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strports.c"
SCM scm_mkstrport(SCM pos , SCM str , long modes , char *caller ) 
{ 
  SCM z ;
  SCM stream ;
  struct scm_port_table *pt ;

  {
#line 154
  if (2 & (int )pos) {
#line 154
    if (! (pos >> 2 >= 0L)) {
      {
#line 154
      scm_wta(pos, (char *)1, caller);
      }
    }
  } else {
    {
#line 154
    scm_wta(pos, (char *)1, caller);
    }
  }
#line 155
  if (! (6 & (int )str)) {
#line 155
    if (! ((117 & (int )((scm_cell *)str)->car) == 21)) {
#line 155
      if (! ((125 & (int )((scm_cell *)str)->car) == 5)) {
        {
#line 155
        scm_wta(str, (char *)1, caller);
        }
      }
    }
  } else {
    {
#line 155
    scm_wta(str, (char *)1, caller);
    }
  }
  {
#line 156
  stream = scm_cons(pos, str);
  }
#line 157
  if (6 & (int )scm_freelist) {
    {
#line 157
    z = scm_gc_for_newcell();
    }
  } else {
#line 157
    z = scm_freelist;
#line 157
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 157
    scm_cells_allocated ++;
  }
  {
#line 158
  scm_ints_disabled = 1;
#line 159
  pt = scm_add_to_port_table(z);
#line 160
  ((scm_cell *)z)->car = 637L | modes;
#line 161
  ((scm_cell *)z)->cdr = (SCM )pt;
#line 162
  ((struct scm_port_table *)((scm_cell *)z)->cdr)->stream = stream;
#line 163
  scm_ints_disabled = 0;
#line 163
  scm_async_clock --;
  }
#line 163
  if (0U == scm_async_clock) {
    {
#line 163
    scm_async_click();
    }
  }
#line 164
  return (z);
}
}
#line 167 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strports.c"
static char s_call_with_output_string[24]  = 
#line 167
  {      (char )'c',      (char )'a',      (char )'l',      (char )'l', 
        (char )'-',      (char )'w',      (char )'i',      (char )'t', 
        (char )'h',      (char )'-',      (char )'o',      (char )'u', 
        (char )'t',      (char )'p',      (char )'u',      (char )'t', 
        (char )'-',      (char )'s',      (char )'t',      (char )'r', 
        (char )'i',      (char )'n',      (char )'g',      (char )'\000'};
#line 169 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strports.c"
SCM scm_call_with_output_string(SCM proc ) 
{ 
  SCM p ;
  SCM tmp ;
  SCM answer ;

  {
  {
#line 174
  tmp = scm_make_string((long )(30 << 2) + 2L, (long )(18 << 9) + 372L);
#line 174
  p = scm_mkstrport((SCM )2, tmp, (1L << 16) | (4L << 16), s_call_with_output_string);
#line 177
  scm_apply(proc, p, scm_sys_protects[1]);
#line 180
  scm_ints_disabled = 1;
#line 181
  answer = scm_makfromstr((char const   *)((char *)((scm_cell *)((scm_cell *)((struct scm_port_table *)((scm_cell *)p)->cdr)->stream)->cdr)->cdr),
                          (size_t )(((scm_cell *)((struct scm_port_table *)((scm_cell *)p)->cdr)->stream)->car >> 2),
                          0);
#line 184
  scm_ints_disabled = 0;
#line 184
  scm_async_clock --;
  }
#line 184
  if (0U == scm_async_clock) {
    {
#line 184
    scm_async_click();
    }
  }
#line 185
  return (answer);
}
}
#line 195 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strports.c"
SCM scm_strprint_obj(SCM obj ) 
{ 
  SCM str ;
  SCM port ;
  SCM answer ;
  char *__cil_tmp5 ;

  {
  {
#line 202
  str = scm_makstr(64L, 0);
#line 203
  port = scm_mkstrport(2L, str, (1L << 16) | (4L << 16), (char *)"scm_strprint_obj");
#line 204
  scm_prin1(obj, port, 1);
#line 207
  scm_ints_disabled = 1;
#line 208
  answer = scm_makfromstr((char const   *)((char *)((scm_cell *)((scm_cell *)((struct scm_port_table *)((scm_cell *)port)->cdr)->stream)->cdr)->cdr),
                          (size_t )(((scm_cell *)((struct scm_port_table *)((scm_cell *)port)->cdr)->stream)->car >> 2),
                          0);
#line 211
  scm_ints_disabled = 0;
#line 211
  scm_async_clock --;
  }
#line 211
  if (0U == scm_async_clock) {
    {
#line 211
    scm_async_click();
    }
  }
#line 212
  return (answer);
}
}
#line 219 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strports.c"
static char s_call_with_input_string[23]  = 
#line 219
  {      (char )'c',      (char )'a',      (char )'l',      (char )'l', 
        (char )'-',      (char )'w',      (char )'i',      (char )'t', 
        (char )'h',      (char )'-',      (char )'i',      (char )'n', 
        (char )'p',      (char )'u',      (char )'t',      (char )'-', 
        (char )'s',      (char )'t',      (char )'r',      (char )'i', 
        (char )'n',      (char )'g',      (char )'\000'};
#line 221 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strports.c"
SCM scm_call_with_input_string(SCM str , SCM proc ) 
{ 
  SCM p ;
  SCM tmp ;
  SCM tmp___0 ;

  {
  {
#line 226
  tmp = scm_mkstrport((SCM )2, str, (1L << 16) | (2L << 16), s_call_with_input_string);
#line 226
  p = tmp;
#line 227
  tmp___0 = scm_apply(proc, p, scm_sys_protects[1]);
  }
#line 227
  return (tmp___0);
}
}
#line 234 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strports.c"
SCM scm_read_0str(char *expr ) 
{ 
  SCM port ;
  SCM tmp ;
  SCM tmp___0 ;
  SCM form ;
  char *__cil_tmp6 ;

  {
  {
#line 238
  tmp = scm_makfrom0str((char const   *)expr);
#line 238
  tmp___0 = scm_mkstrport(2L, tmp, (1L << 16) | (2L << 16), (char *)"scm_eval_0str");
#line 238
  port = tmp___0;
#line 245
  form = scm_read(port, (long )(16 << 9) + 372L, (long )(16 << 9) + 372L);
#line 247
  scm_close_port(port);
  }
#line 248
  return (form);
}
}
#line 253 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strports.c"
SCM scm_eval_0str(char *expr ) 
{ 
  SCM port ;
  SCM tmp ;
  SCM tmp___0 ;
  SCM form ;
  SCM ans ;
  char *__cil_tmp7 ;

  {
  {
#line 257
  tmp = scm_makfrom0str((char const   *)expr);
#line 257
  tmp___0 = scm_mkstrport(2L, tmp, (1L << 16) | (2L << 16), (char *)"scm_eval_0str");
#line 257
  port = tmp___0;
#line 262
  ans = (long )(20 << 9) + 372L;
  }
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 265
    form = scm_read(port, (long )(16 << 9) + 372L, (long )(16 << 9) + 372L);
    }
#line 265
    if (! (form != (long )(19 << 9) + 372L)) {
#line 265
      goto while_break;
    }
    {
#line 266
    ans = scm_eval_x(form);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 268
  scm_close_port(port);
  }
#line 269
  return (ans);
}
}
#line 273
static int noop0___0(SCM stream ) ;
#line 275 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strports.c"
static int noop0___0(SCM stream ) 
{ 


  {
#line 279
  return (0);
}
}
#line 283 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strports.c"
scm_ptobfuns scm_stptob  = 
#line 283
     {& scm_markstream, & noop0___0, & prinstpt, (SCM (*)(SCM  , SCM  ))0, & stputc,
    & stputs, & stwrite, & noop0___0, & stgetc, (int (*)(SCM stream ))0};
#line 299 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strports.c"
void scm_init_strports(void) 
{ 


  {
  {
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strports.x"
  scm_make_gsubr(s_call_with_output_string, 1, 0, 0, (SCM (*)())(& scm_call_with_output_string));
#line 2
  scm_make_gsubr(s_call_with_input_string, 2, 0, 0, (SCM (*)())(& scm_call_with_input_string));
  }
#line 303 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strports.c"
  return;
}
}
#line 93 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/procs.h"
SCM scm_make_subr(char *name , int type , SCM (*fcn)() ) ;
#line 56 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strorder.h"
SCM scm_string_equal_p(SCM s1 , SCM s2 ) ;
#line 57
SCM scm_string_ci_equal_p(SCM s1 , SCM s2 ) ;
#line 58
SCM scm_string_less_p(SCM s1 , SCM s2 ) ;
#line 59
SCM scm_string_leq_p(SCM s1 , SCM s2 ) ;
#line 60
SCM scm_string_gr_p(SCM s1 , SCM s2 ) ;
#line 61
SCM scm_string_geq_p(SCM s1 , SCM s2 ) ;
#line 62
SCM scm_string_ci_less_p(SCM s1 , SCM s2 ) ;
#line 63
SCM scm_string_ci_leq_p(SCM s1 , SCM s2 ) ;
#line 64
SCM scm_string_ci_gr_p(SCM s1 , SCM s2 ) ;
#line 65
SCM scm_string_ci_geq_p(SCM s1 , SCM s2 ) ;
#line 66
void scm_init_strorder(void) ;
#line 50 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strorder.c"
static char s_string_equal_p[9]  = 
#line 50 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strorder.c"
  {      (char )'s',      (char )'t',      (char )'r',      (char )'i', 
        (char )'n',      (char )'g',      (char )'=',      (char )'?', 
        (char )'\000'};
#line 52 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strorder.c"
SCM scm_string_equal_p(SCM s1 , SCM s2 ) 
{ 
  register size_t i ;
  register unsigned char *c1 ;
  register unsigned char *c2 ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  size_t tmp___1 ;

  {
#line 59
  if (! (6 & (int )s1)) {
#line 59
    if (! ((117 & (int )((scm_cell *)s1)->car) == 21)) {
#line 59
      if (! ((125 & (int )((scm_cell *)s1)->car) == 5)) {
        {
#line 59
        scm_wta(s1, (char *)1, s_string_equal_p);
        }
      }
    }
  } else {
    {
#line 59
    scm_wta(s1, (char *)1, s_string_equal_p);
    }
  }
#line 60
  if (! (6 & (int )s2)) {
#line 60
    if (! ((117 & (int )((scm_cell *)s2)->car) == 21)) {
#line 60
      if (! ((125 & (int )((scm_cell *)s2)->car) == 5)) {
        {
#line 60
        scm_wta(s2, (char *)2, s_string_equal_p);
        }
      }
    }
  } else {
    {
#line 60
    scm_wta(s2, (char *)2, s_string_equal_p);
    }
  }
#line 62
  i = (unsigned long )((scm_cell *)s2)->car >> 8;
#line 63
  if ((unsigned long )((scm_cell *)s1)->car >> 8 != i) {
#line 65
    return ((long )(16 << 9) + 372L);
  }
#line 67
  if ((127 & (int )((scm_cell *)s1)->car) == 29) {
#line 67
    c1 = (unsigned char *)((scm_cell *)((scm_cell *)((scm_cell *)s1)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)s1)->cdr)->car >> 2);
  } else {
#line 67
    c1 = (unsigned char *)((scm_cell *)s1)->cdr;
  }
#line 68
  if ((127 & (int )((scm_cell *)s2)->car) == 29) {
#line 68
    c2 = (unsigned char *)((scm_cell *)((scm_cell *)((scm_cell *)s2)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)s2)->cdr)->car >> 2);
  } else {
#line 68
    c2 = (unsigned char *)((scm_cell *)s2)->cdr;
  }
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    tmp___1 = i;
#line 69
    i --;
#line 69
    if (! (0UL != tmp___1)) {
#line 69
      goto while_break;
    }
#line 70
    tmp = c1;
#line 70
    c1 ++;
#line 70
    tmp___0 = c2;
#line 70
    c2 ++;
#line 70
    if ((int )*tmp != (int )*tmp___0) {
#line 71
      return ((long )(16 << 9) + 372L);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  return ((long )(17 << 9) + 372L);
}
}
#line 75 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strorder.c"
static char s_string_ci_equal_p[12]  = 
#line 75
  {      (char )'s',      (char )'t',      (char )'r',      (char )'i', 
        (char )'n',      (char )'g',      (char )'-',      (char )'c', 
        (char )'i',      (char )'=',      (char )'?',      (char )'\000'};
#line 77 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strorder.c"
SCM scm_string_ci_equal_p(SCM s1 , SCM s2 ) 
{ 
  register size_t i ;
  register unsigned char *c1 ;
  register unsigned char *c2 ;
  unsigned char *tmp ;
  int tmp___0 ;
  unsigned char *tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
#line 84
  if (! (6 & (int )s1)) {
#line 84
    if (! ((117 & (int )((scm_cell *)s1)->car) == 21)) {
#line 84
      if (! ((125 & (int )((scm_cell *)s1)->car) == 5)) {
        {
#line 84
        scm_wta(s1, (char *)1, s_string_ci_equal_p);
        }
      }
    }
  } else {
    {
#line 84
    scm_wta(s1, (char *)1, s_string_ci_equal_p);
    }
  }
#line 85
  if (! (6 & (int )s2)) {
#line 85
    if (! ((117 & (int )((scm_cell *)s2)->car) == 21)) {
#line 85
      if (! ((125 & (int )((scm_cell *)s2)->car) == 5)) {
        {
#line 85
        scm_wta(s2, (char *)2, s_string_ci_equal_p);
        }
      }
    }
  } else {
    {
#line 85
    scm_wta(s2, (char *)2, s_string_ci_equal_p);
    }
  }
#line 86
  i = (unsigned long )((scm_cell *)s2)->car >> 8;
#line 87
  if ((unsigned long )((scm_cell *)s1)->car >> 8 != i) {
#line 89
    return ((long )(16 << 9) + 372L);
  }
#line 91
  if ((127 & (int )((scm_cell *)s1)->car) == 29) {
#line 91
    c1 = (unsigned char *)((scm_cell *)((scm_cell *)((scm_cell *)s1)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)s1)->cdr)->car >> 2);
  } else {
#line 91
    c1 = (unsigned char *)((scm_cell *)s1)->cdr;
  }
#line 92
  if ((127 & (int )((scm_cell *)s2)->car) == 29) {
#line 92
    c2 = (unsigned char *)((scm_cell *)((scm_cell *)((scm_cell *)s2)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)s2)->cdr)->car >> 2);
  } else {
#line 92
    c2 = (unsigned char *)((scm_cell *)s2)->cdr;
  }
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    tmp___3 = i;
#line 93
    i --;
#line 93
    if (! (0UL != tmp___3)) {
#line 93
      goto while_break;
    }
    {
#line 94
    tmp = c1;
#line 94
    c1 ++;
#line 94
    tmp___0 = scm_upcase((unsigned int )*tmp);
#line 94
    tmp___1 = c2;
#line 94
    c2 ++;
#line 94
    tmp___2 = scm_upcase((unsigned int )*tmp___1);
    }
#line 94
    if (tmp___0 != tmp___2) {
#line 95
      return ((long )(16 << 9) + 372L);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 96
  return ((long )(17 << 9) + 372L);
}
}
#line 99 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strorder.c"
static char s_string_less_p[9]  = 
#line 99
  {      (char )'s',      (char )'t',      (char )'r',      (char )'i', 
        (char )'n',      (char )'g',      (char )'<',      (char )'?', 
        (char )'\000'};
#line 101 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strorder.c"
SCM scm_string_less_p(SCM s1 , SCM s2 ) 
{ 
  register size_t i ;
  register size_t len ;
  register size_t s2len ;
  register unsigned char *c1 ;
  register unsigned char *c2 ;
  register int c ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  SCM answer ;

  {
#line 110
  if (! (6 & (int )s1)) {
#line 110
    if (! ((117 & (int )((scm_cell *)s1)->car) == 21)) {
#line 110
      if (! ((125 & (int )((scm_cell *)s1)->car) == 5)) {
        {
#line 110
        scm_wta(s1, (char *)1, s_string_less_p);
        }
      }
    }
  } else {
    {
#line 110
    scm_wta(s1, (char *)1, s_string_less_p);
    }
  }
#line 111
  if (! (6 & (int )s2)) {
#line 111
    if (! ((117 & (int )((scm_cell *)s2)->car) == 21)) {
#line 111
      if (! ((125 & (int )((scm_cell *)s2)->car) == 5)) {
        {
#line 111
        scm_wta(s2, (char *)2, s_string_less_p);
        }
      }
    }
  } else {
    {
#line 111
    scm_wta(s2, (char *)2, s_string_less_p);
    }
  }
#line 112
  len = (unsigned long )((scm_cell *)s1)->car >> 8;
#line 113
  i = (unsigned long )((scm_cell *)s2)->car >> 8;
#line 113
  s2len = i;
#line 114
  if (len > i) {
#line 114
    i = len;
  }
#line 115
  if ((127 & (int )((scm_cell *)s1)->car) == 29) {
#line 115
    c1 = (unsigned char *)((scm_cell *)((scm_cell *)((scm_cell *)s1)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)s1)->cdr)->car >> 2);
  } else {
#line 115
    c1 = (unsigned char *)((scm_cell *)s1)->cdr;
  }
#line 116
  if ((127 & (int )((scm_cell *)s2)->car) == 29) {
#line 116
    c2 = (unsigned char *)((scm_cell *)((scm_cell *)((scm_cell *)s2)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)s2)->cdr)->car >> 2);
  } else {
#line 116
    c2 = (unsigned char *)((scm_cell *)s2)->cdr;
  }
#line 118
  i = (size_t )0;
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 118
    if (! (i < len)) {
#line 118
      goto while_break;
    }
#line 119
    tmp = c1;
#line 119
    c1 ++;
#line 119
    tmp___0 = c2;
#line 119
    c2 ++;
#line 119
    c = (int )*tmp - (int )*tmp___0;
#line 120
    if (c > 0) {
#line 121
      return ((long )(16 << 9) + 372L);
    }
#line 122
    if (c < 0) {
#line 123
      return ((long )(17 << 9) + 372L);
    }
#line 118
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 127
  if (s2len != len) {
#line 127
    answer = (long )(17 << 9) + 372L;
  } else {
#line 127
    answer = (long )(16 << 9) + 372L;
  }
#line 128
  return (answer);
}
}
#line 132 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strorder.c"
static char s_string_leq_p[10]  = 
#line 132
  {      (char )'s',      (char )'t',      (char )'r',      (char )'i', 
        (char )'n',      (char )'g',      (char )'<',      (char )'=', 
        (char )'?',      (char )'\000'};
#line 134 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strorder.c"
SCM scm_string_leq_p(SCM s1 , SCM s2 ) 
{ 
  SCM tmp ;

  {
  {
#line 139
  tmp = scm_string_less_p(s2, s1);
  }
#line 139
  return (tmp ^ (((long )(17 << 9) + 372L) ^ ((long )(16 << 9) + 372L)));
}
}
#line 142 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strorder.c"
static char s_string_gr_p[9]  = 
#line 142
  {      (char )'s',      (char )'t',      (char )'r',      (char )'i', 
        (char )'n',      (char )'g',      (char )'>',      (char )'?', 
        (char )'\000'};
#line 144 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strorder.c"
SCM scm_string_gr_p(SCM s1 , SCM s2 ) 
{ 
  SCM tmp ;

  {
  {
#line 149
  tmp = scm_string_less_p(s2, s1);
  }
#line 149
  return (tmp);
}
}
#line 152 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strorder.c"
static char s_string_geq_p[10]  = 
#line 152
  {      (char )'s',      (char )'t',      (char )'r',      (char )'i', 
        (char )'n',      (char )'g',      (char )'>',      (char )'=', 
        (char )'?',      (char )'\000'};
#line 154 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strorder.c"
SCM scm_string_geq_p(SCM s1 , SCM s2 ) 
{ 
  SCM tmp ;

  {
  {
#line 159
  tmp = scm_string_less_p(s1, s2);
  }
#line 159
  return (tmp ^ (((long )(17 << 9) + 372L) ^ ((long )(16 << 9) + 372L)));
}
}
#line 162 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strorder.c"
static char s_string_ci_less_p[12]  = 
#line 162
  {      (char )'s',      (char )'t',      (char )'r',      (char )'i', 
        (char )'n',      (char )'g',      (char )'-',      (char )'c', 
        (char )'i',      (char )'<',      (char )'?',      (char )'\000'};
#line 164 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strorder.c"
SCM scm_string_ci_less_p(SCM s1 , SCM s2 ) 
{ 
  register size_t i ;
  register size_t len ;
  register size_t s2len ;
  register unsigned char *c1 ;
  register unsigned char *c2 ;
  register int c ;
  unsigned char *tmp ;
  int tmp___0 ;
  unsigned char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
#line 172
  if (! (6 & (int )s1)) {
#line 172
    if (! ((117 & (int )((scm_cell *)s1)->car) == 21)) {
#line 172
      if (! ((125 & (int )((scm_cell *)s1)->car) == 5)) {
        {
#line 172
        scm_wta(s1, (char *)1, s_string_ci_less_p);
        }
      }
    }
  } else {
    {
#line 172
    scm_wta(s1, (char *)1, s_string_ci_less_p);
    }
  }
#line 173
  if (! (6 & (int )s2)) {
#line 173
    if (! ((117 & (int )((scm_cell *)s2)->car) == 21)) {
#line 173
      if (! ((125 & (int )((scm_cell *)s2)->car) == 5)) {
        {
#line 173
        scm_wta(s2, (char *)2, s_string_ci_less_p);
        }
      }
    }
  } else {
    {
#line 173
    scm_wta(s2, (char *)2, s_string_ci_less_p);
    }
  }
#line 174
  len = (unsigned long )((scm_cell *)s1)->car >> 8;
#line 175
  i = (unsigned long )((scm_cell *)s2)->car >> 8;
#line 175
  s2len = i;
#line 176
  if (len > i) {
#line 176
    i = len;
  }
#line 177
  if ((127 & (int )((scm_cell *)s1)->car) == 29) {
#line 177
    c1 = (unsigned char *)((scm_cell *)((scm_cell *)((scm_cell *)s1)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)s1)->cdr)->car >> 2);
  } else {
#line 177
    c1 = (unsigned char *)((scm_cell *)s1)->cdr;
  }
#line 178
  if ((127 & (int )((scm_cell *)s2)->car) == 29) {
#line 178
    c2 = (unsigned char *)((scm_cell *)((scm_cell *)((scm_cell *)s2)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)s2)->cdr)->car >> 2);
  } else {
#line 178
    c2 = (unsigned char *)((scm_cell *)s2)->cdr;
  }
#line 179
  i = (size_t )0;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! (i < len)) {
#line 179
      goto while_break;
    }
    {
#line 180
    tmp = c1;
#line 180
    c1 ++;
#line 180
    tmp___0 = scm_upcase((unsigned int )*tmp);
#line 180
    tmp___1 = c2;
#line 180
    c2 ++;
#line 180
    tmp___2 = scm_upcase((unsigned int )*tmp___1);
#line 180
    c = tmp___0 - tmp___2;
    }
#line 181
    if (c > 0) {
#line 181
      return ((long )(16 << 9) + 372L);
    }
#line 182
    if (c < 0) {
#line 182
      return ((long )(17 << 9) + 372L);
    }
#line 179
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  if (s2len != len) {
#line 184
    tmp___3 = (long )(17 << 9) + 372L;
  } else {
#line 184
    tmp___3 = (long )(16 << 9) + 372L;
  }
#line 184
  return (tmp___3);
}
}
#line 187 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strorder.c"
static char s_string_ci_leq_p[13]  = 
#line 187
  {      (char )'s',      (char )'t',      (char )'r',      (char )'i', 
        (char )'n',      (char )'g',      (char )'-',      (char )'c', 
        (char )'i',      (char )'<',      (char )'=',      (char )'?', 
        (char )'\000'};
#line 189 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strorder.c"
SCM scm_string_ci_leq_p(SCM s1 , SCM s2 ) 
{ 
  SCM tmp ;

  {
  {
#line 194
  tmp = scm_string_ci_less_p(s2, s1);
  }
#line 194
  return (tmp ^ (((long )(17 << 9) + 372L) ^ ((long )(16 << 9) + 372L)));
}
}
#line 197 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strorder.c"
static char s_string_ci_gr_p[12]  = 
#line 197
  {      (char )'s',      (char )'t',      (char )'r',      (char )'i', 
        (char )'n',      (char )'g',      (char )'-',      (char )'c', 
        (char )'i',      (char )'>',      (char )'?',      (char )'\000'};
#line 199 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strorder.c"
SCM scm_string_ci_gr_p(SCM s1 , SCM s2 ) 
{ 
  SCM tmp ;

  {
  {
#line 204
  tmp = scm_string_ci_less_p(s2, s1);
  }
#line 204
  return (tmp);
}
}
#line 207 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strorder.c"
static char s_string_ci_geq_p[13]  = 
#line 207
  {      (char )'s',      (char )'t',      (char )'r',      (char )'i', 
        (char )'n',      (char )'g',      (char )'-',      (char )'c', 
        (char )'i',      (char )'>',      (char )'=',      (char )'?', 
        (char )'\000'};
#line 209 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strorder.c"
SCM scm_string_ci_geq_p(SCM s1 , SCM s2 ) 
{ 
  SCM tmp ;

  {
  {
#line 214
  tmp = scm_string_ci_less_p(s1, s2);
  }
#line 214
  return (tmp ^ (((long )(17 << 9) + 372L) ^ ((long )(16 << 9) + 372L)));
}
}
#line 219 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strorder.c"
void scm_init_strorder(void) 
{ 


  {
  {
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strorder.x"
  scm_make_subr(s_string_equal_p, 69, (SCM (*)())(& scm_string_equal_p));
#line 2
  scm_make_subr(s_string_ci_equal_p, 69, (SCM (*)())(& scm_string_ci_equal_p));
#line 3
  scm_make_subr(s_string_less_p, 69, (SCM (*)())(& scm_string_less_p));
#line 4
  scm_make_subr(s_string_leq_p, 69, (SCM (*)())(& scm_string_leq_p));
#line 5
  scm_make_subr(s_string_gr_p, 69, (SCM (*)())(& scm_string_gr_p));
#line 6
  scm_make_subr(s_string_geq_p, 69, (SCM (*)())(& scm_string_geq_p));
#line 7
  scm_make_subr(s_string_ci_less_p, 69, (SCM (*)())(& scm_string_ci_less_p));
#line 8
  scm_make_subr(s_string_ci_leq_p, 69, (SCM (*)())(& scm_string_ci_leq_p));
#line 9
  scm_make_subr(s_string_ci_gr_p, 69, (SCM (*)())(& scm_string_ci_gr_p));
#line 10
  scm_make_subr(s_string_ci_geq_p, 69, (SCM (*)())(& scm_string_ci_geq_p));
  }
#line 223 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strorder.c"
  return;
}
}
#line 52 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strop.h"
int scm_i_index(SCM *str , SCM chr , SCM sub_start , SCM sub_end , int pos , int pos2 ,
                int pos3 , int pos4 , char *why ) ;
#line 53
int scm_i_rindex(SCM *str , SCM chr , SCM sub_start , SCM sub_end , int pos , int pos2 ,
                 int pos3 , int pos4 , char *why ) ;
#line 54
SCM scm_string_index(SCM str , SCM chr , SCM frm , SCM to ) ;
#line 55
SCM scm_string_rindex(SCM str , SCM chr , SCM frm , SCM to ) ;
#line 56
SCM scm_substring_move_left_x(SCM str1 , SCM start1 , SCM args ) ;
#line 57
SCM scm_substring_move_right_x(SCM str1 , SCM start1 , SCM args ) ;
#line 58
SCM scm_substring_fill_x(SCM str , SCM start , SCM args ) ;
#line 59
SCM scm_string_null_p(SCM str ) ;
#line 61
SCM scm_string_copy(SCM str ) ;
#line 62
SCM scm_string_fill_x(SCM str , SCM chr ) ;
#line 63
void scm_init_strop(void) ;
#line 29 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strop.c"
int scm_i_index(SCM *str , SCM chr , SCM sub_start , SCM sub_end , int pos , int pos2 ,
                int pos3 , int pos4 , char *why ) 
{ 
  unsigned char *p ;
  int x ;
  int bound ;
  int ch ;
  char *tmp ;

  {
#line 46
  if (! (6 & (int )*str)) {
#line 46
    if (! ((117 & (int )((scm_cell *)*str)->car) == 21)) {
#line 46
      if (! ((125 & (int )((scm_cell *)*str)->car) == 5)) {
        {
#line 46
        scm_wta(*str, (char *)pos, why);
        }
      }
    }
  } else {
    {
#line 46
    scm_wta(*str, (char *)pos, why);
    }
  }
#line 47
  if (! (((int )chr & 255) == 244)) {
    {
#line 47
    scm_wta(chr, (char *)pos2, why);
    }
  }
#line 49
  if (sub_start == (long )(16 << 9) + 372L) {
#line 50
    sub_start = 2L;
  } else
#line 52
  if (2 & (int )sub_start) {
#line 52
    if (0L <= sub_start >> 2) {
#line 52
      if (! ((unsigned long )(sub_start >> 2) <= (unsigned long )((scm_cell *)*str)->car >> 8)) {
        {
#line 52
        scm_wta(sub_start, (char *)pos3, why);
        }
      }
    } else {
      {
#line 52
      scm_wta(sub_start, (char *)pos3, why);
      }
    }
  } else {
    {
#line 52
    scm_wta(sub_start, (char *)pos3, why);
    }
  }
#line 57
  if (sub_end == (long )(16 << 9) + 372L) {
#line 58
    sub_end = (SCM )((((unsigned long )((scm_cell *)*str)->car >> 8) << 2) + 2UL);
  } else
#line 60
  if (2 & (int )sub_end) {
#line 60
    if (sub_start >> 2 <= sub_end >> 2) {
#line 60
      if (! ((unsigned long )(sub_end >> 2) <= (unsigned long )((scm_cell *)*str)->car >> 8)) {
        {
#line 60
        scm_wta(sub_end, (char *)pos4, why);
        }
      }
    } else {
      {
#line 60
      scm_wta(sub_end, (char *)pos4, why);
      }
    }
  } else {
    {
#line 60
    scm_wta(sub_end, (char *)pos4, why);
    }
  }
#line 65
  if ((127 & (int )((scm_cell *)*str)->car) == 29) {
#line 65
    tmp = (char *)((scm_cell *)((scm_cell *)((scm_cell *)*str)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)*str)->cdr)->car >> 2);
  } else {
#line 65
    tmp = (char *)((scm_cell *)*str)->cdr;
  }
#line 65
  p = (unsigned char *)tmp + (sub_start >> 2);
#line 66
  bound = (int )(sub_end >> 2);
#line 67
  ch = (int )((unsigned int )(chr >> 8));
#line 69
  x = (int )(sub_start >> 2);
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (! (x < bound)) {
#line 69
      goto while_break;
    }
#line 70
    if ((int )*p == ch) {
#line 71
      return (x);
    }
#line 69
    x ++;
#line 69
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  return (-1);
}
}
#line 77 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strop.c"
int scm_i_rindex(SCM *str , SCM chr , SCM sub_start , SCM sub_end , int pos , int pos2 ,
                 int pos3 , int pos4 , char *why ) 
{ 
  unsigned char *p ;
  int x ;
  int upper_bound ;
  int lower_bound ;
  int ch ;
  char *tmp ;

  {
#line 95
  if (! (6 & (int )*str)) {
#line 95
    if (! ((117 & (int )((scm_cell *)*str)->car) == 21)) {
#line 95
      if (! ((125 & (int )((scm_cell *)*str)->car) == 5)) {
        {
#line 95
        scm_wta(*str, (char *)pos, why);
        }
      }
    }
  } else {
    {
#line 95
    scm_wta(*str, (char *)pos, why);
    }
  }
#line 96
  if (! (((int )chr & 255) == 244)) {
    {
#line 96
    scm_wta(chr, (char *)pos2, why);
    }
  }
#line 98
  if (sub_start == (long )(16 << 9) + 372L) {
#line 99
    sub_start = 2L;
  } else
#line 101
  if (2 & (int )sub_start) {
#line 101
    if (0L <= sub_start >> 2) {
#line 101
      if (! ((unsigned long )(sub_start >> 2) <= (unsigned long )((scm_cell *)*str)->car >> 8)) {
        {
#line 101
        scm_wta(sub_start, (char *)pos3, why);
        }
      }
    } else {
      {
#line 101
      scm_wta(sub_start, (char *)pos3, why);
      }
    }
  } else {
    {
#line 101
    scm_wta(sub_start, (char *)pos3, why);
    }
  }
#line 106
  if (sub_end == (long )(16 << 9) + 372L) {
#line 107
    sub_end = (SCM )((((unsigned long )((scm_cell *)*str)->car >> 8) << 2) + 2UL);
  } else
#line 109
  if (2 & (int )sub_end) {
#line 109
    if (sub_start >> 2 <= sub_end >> 2) {
#line 109
      if (! ((unsigned long )(sub_end >> 2) <= (unsigned long )((scm_cell *)*str)->car >> 8)) {
        {
#line 109
        scm_wta(sub_end, (char *)pos4, why);
        }
      }
    } else {
      {
#line 109
      scm_wta(sub_end, (char *)pos4, why);
      }
    }
  } else {
    {
#line 109
    scm_wta(sub_end, (char *)pos4, why);
    }
  }
#line 114
  upper_bound = (int )(sub_end >> 2);
#line 115
  lower_bound = (int )(sub_start >> 2);
#line 116
  if ((127 & (int )((scm_cell *)*str)->car) == 29) {
#line 116
    tmp = (char *)((scm_cell *)((scm_cell *)((scm_cell *)*str)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)*str)->cdr)->car >> 2);
  } else {
#line 116
    tmp = (char *)((scm_cell *)*str)->cdr;
  }
#line 116
  p = (unsigned char *)tmp + (upper_bound - 1);
#line 117
  ch = (int )((unsigned int )(chr >> 8));
#line 118
  x = upper_bound - 1;
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 118
    if (! (x >= lower_bound)) {
#line 118
      goto while_break;
    }
#line 119
    if ((int )*p == ch) {
#line 120
      return (x);
    }
#line 118
    x --;
#line 118
    p --;
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  return (-1);
}
}
#line 126 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strop.c"
static char s_string_index[13]  = 
#line 126
  {      (char )'s',      (char )'t',      (char )'r',      (char )'i', 
        (char )'n',      (char )'g',      (char )'-',      (char )'i', 
        (char )'n',      (char )'d',      (char )'e',      (char )'x', 
        (char )'\000'};
#line 128 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strop.c"
SCM scm_string_index(SCM str , SCM chr , SCM frm , SCM to ) 
{ 
  int pos ;
  long tmp ;

  {
#line 137
  if (frm == (long )(18 << 9) + 372L) {
#line 138
    frm = (long )(16 << 9) + 372L;
  }
#line 139
  if (to == (long )(18 << 9) + 372L) {
#line 140
    to = (long )(16 << 9) + 372L;
  }
  {
#line 141
  pos = scm_i_index(& str, chr, frm, to, 1, 2, 3, 4, s_string_index);
  }
#line 142
  if (pos < 0) {
#line 142
    tmp = (long )(16 << 9) + 372L;
  } else {
#line 142
    tmp = (long )(pos << 2) + 2L;
  }
#line 142
  return (tmp);
}
}
#line 147 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strop.c"
static char s_string_rindex[14]  = 
#line 147
  {      (char )'s',      (char )'t',      (char )'r',      (char )'i', 
        (char )'n',      (char )'g',      (char )'-',      (char )'r', 
        (char )'i',      (char )'n',      (char )'d',      (char )'e', 
        (char )'x',      (char )'\000'};
#line 149 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strop.c"
SCM scm_string_rindex(SCM str , SCM chr , SCM frm , SCM to ) 
{ 
  int pos ;
  long tmp ;

  {
#line 158
  if (frm == (long )(18 << 9) + 372L) {
#line 159
    frm = (long )(16 << 9) + 372L;
  }
#line 160
  if (to == (long )(18 << 9) + 372L) {
#line 161
    to = (long )(16 << 9) + 372L;
  }
  {
#line 162
  pos = scm_i_rindex(& str, chr, frm, to, 1, 2, 3, 4, s_string_index);
  }
#line 163
  if (pos < 0) {
#line 163
    tmp = (long )(16 << 9) + 372L;
  } else {
#line 163
    tmp = (long )(pos << 2) + 2L;
  }
#line 163
  return (tmp);
}
}
#line 173 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strop.c"
static char s_substring_move_left_x[21]  = 
#line 173
  {      (char )'s',      (char )'u',      (char )'b',      (char )'s', 
        (char )'t',      (char )'r',      (char )'i',      (char )'n', 
        (char )'g',      (char )'-',      (char )'m',      (char )'o', 
        (char )'v',      (char )'e',      (char )'-',      (char )'l', 
        (char )'e',      (char )'f',      (char )'t',      (char )'!', 
        (char )'\000'};
#line 175 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strop.c"
SCM scm_substring_move_left_x(SCM str1 , SCM start1 , SCM args ) 
{ 
  SCM end1 ;
  SCM str2 ;
  SCM start2 ;
  long i ;
  long j ;
  long e ;
  SCM tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  {
#line 183
  tmp___0 = scm_ilength(args);
  }
#line 183
  if (! (3L == tmp___0)) {
    {
#line 183
    tmp = scm_makfrom0str((char const   *)(s_substring_move_left_x));
#line 183
    scm_wta(tmp, (char *)8, (char *)((void *)0));
    }
  }
#line 185
  end1 = ((scm_cell *)args)->car;
#line 185
  args = ((scm_cell *)args)->cdr;
#line 186
  str2 = ((scm_cell *)args)->car;
#line 186
  args = ((scm_cell *)args)->cdr;
#line 187
  start2 = ((scm_cell *)args)->car;
#line 188
  if (! (6 & (int )str1)) {
#line 188
    if (! ((125 & (int )((scm_cell *)str1)->car) == 21)) {
      {
#line 188
      scm_wta(str1, (char *)1, s_substring_move_left_x);
      }
    }
  } else {
    {
#line 188
    scm_wta(str1, (char *)1, s_substring_move_left_x);
    }
  }
#line 189
  if (! (2 & (int )start1)) {
    {
#line 189
    scm_wta(start1, (char *)2, s_substring_move_left_x);
    }
  }
#line 190
  if (! (2 & (int )end1)) {
    {
#line 190
    scm_wta(end1, (char *)3, s_substring_move_left_x);
    }
  }
#line 191
  if (! (6 & (int )str2)) {
#line 191
    if (! ((125 & (int )((scm_cell *)str2)->car) == 21)) {
      {
#line 191
      scm_wta(str2, (char *)4, s_substring_move_left_x);
      }
    }
  } else {
    {
#line 191
    scm_wta(str2, (char *)4, s_substring_move_left_x);
    }
  }
#line 192
  if (! (2 & (int )start2)) {
    {
#line 192
    scm_wta(start2, (char *)5, s_substring_move_left_x);
    }
  }
#line 193
  i = start1 >> 2;
#line 193
  j = start2 >> 2;
#line 193
  e = end1 >> 2;
#line 194
  if ((unsigned long )i <= (unsigned long )((scm_cell *)str1)->car >> 8) {
#line 194
    if (! (i >= 0L)) {
      {
#line 194
      scm_wta(start1, (char *)10, s_substring_move_left_x);
      }
    }
  } else {
    {
#line 194
    scm_wta(start1, (char *)10, s_substring_move_left_x);
    }
  }
#line 195
  if ((unsigned long )j <= (unsigned long )((scm_cell *)str2)->car >> 8) {
#line 195
    if (! (j >= 0L)) {
      {
#line 195
      scm_wta(start2, (char *)10, s_substring_move_left_x);
      }
    }
  } else {
    {
#line 195
    scm_wta(start2, (char *)10, s_substring_move_left_x);
    }
  }
#line 196
  if ((unsigned long )e <= (unsigned long )((scm_cell *)str1)->car >> 8) {
#line 196
    if (! (e >= 0L)) {
      {
#line 196
      scm_wta(end1, (char *)10, s_substring_move_left_x);
      }
    }
  } else {
    {
#line 196
    scm_wta(end1, (char *)10, s_substring_move_left_x);
    }
  }
#line 197
  if (! ((unsigned long )((e - i) + j) <= (unsigned long )((scm_cell *)str2)->car >> 8)) {
    {
#line 197
    scm_wta(start2, (char *)10, s_substring_move_left_x);
    }
  }
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 198
    if (! (i < e)) {
#line 198
      goto while_break;
    }
#line 198
    tmp___1 = j;
#line 198
    j ++;
#line 198
    tmp___2 = i;
#line 198
    i ++;
#line 198
    *((char *)((scm_cell *)str2)->cdr + tmp___1) = *((char *)((scm_cell *)str1)->cdr + tmp___2);
  }
  while_break: /* CIL Label */ ;
  }
#line 199
  return ((long )(21 << 9) + 372L);
}
}
#line 203 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strop.c"
static char s_substring_move_right_x[22]  = 
#line 203
  {      (char )'s',      (char )'u',      (char )'b',      (char )'s', 
        (char )'t',      (char )'r',      (char )'i',      (char )'n', 
        (char )'g',      (char )'-',      (char )'m',      (char )'o', 
        (char )'v',      (char )'e',      (char )'-',      (char )'r', 
        (char )'i',      (char )'g',      (char )'h',      (char )'t', 
        (char )'!',      (char )'\000'};
#line 205 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strop.c"
SCM scm_substring_move_right_x(SCM str1 , SCM start1 , SCM args ) 
{ 
  SCM end1 ;
  SCM str2 ;
  SCM start2 ;
  long i ;
  long j ;
  long e ;
  SCM tmp ;
  long tmp___0 ;

  {
  {
#line 213
  tmp___0 = scm_ilength(args);
  }
#line 213
  if (! (3L == tmp___0)) {
    {
#line 213
    tmp = scm_makfrom0str((char const   *)(s_substring_move_right_x));
#line 213
    scm_wta(tmp, (char *)8, (char *)((void *)0));
    }
  }
#line 215
  end1 = ((scm_cell *)args)->car;
#line 215
  args = ((scm_cell *)args)->cdr;
#line 216
  str2 = ((scm_cell *)args)->car;
#line 216
  args = ((scm_cell *)args)->cdr;
#line 217
  start2 = ((scm_cell *)args)->car;
#line 218
  if (! (6 & (int )str1)) {
#line 218
    if (! ((125 & (int )((scm_cell *)str1)->car) == 21)) {
      {
#line 218
      scm_wta(str1, (char *)1, s_substring_move_right_x);
      }
    }
  } else {
    {
#line 218
    scm_wta(str1, (char *)1, s_substring_move_right_x);
    }
  }
#line 219
  if (! (2 & (int )start1)) {
    {
#line 219
    scm_wta(start1, (char *)2, s_substring_move_right_x);
    }
  }
#line 220
  if (! (2 & (int )end1)) {
    {
#line 220
    scm_wta(end1, (char *)3, s_substring_move_right_x);
    }
  }
#line 221
  if (! (6 & (int )str2)) {
#line 221
    if (! ((125 & (int )((scm_cell *)str2)->car) == 21)) {
      {
#line 221
      scm_wta(str2, (char *)4, s_substring_move_right_x);
      }
    }
  } else {
    {
#line 221
    scm_wta(str2, (char *)4, s_substring_move_right_x);
    }
  }
#line 222
  if (! (2 & (int )start2)) {
    {
#line 222
    scm_wta(start2, (char *)5, s_substring_move_right_x);
    }
  }
#line 223
  i = start1 >> 2;
#line 223
  j = start2 >> 2;
#line 223
  e = end1 >> 2;
#line 224
  if ((unsigned long )i <= (unsigned long )((scm_cell *)str1)->car >> 8) {
#line 224
    if (! (i >= 0L)) {
      {
#line 224
      scm_wta(start1, (char *)10, s_substring_move_right_x);
      }
    }
  } else {
    {
#line 224
    scm_wta(start1, (char *)10, s_substring_move_right_x);
    }
  }
#line 225
  if ((unsigned long )j <= (unsigned long )((scm_cell *)str2)->car >> 8) {
#line 225
    if (! (j >= 0L)) {
      {
#line 225
      scm_wta(start2, (char *)10, s_substring_move_right_x);
      }
    }
  } else {
    {
#line 225
    scm_wta(start2, (char *)10, s_substring_move_right_x);
    }
  }
#line 226
  if ((unsigned long )e <= (unsigned long )((scm_cell *)str1)->car >> 8) {
#line 226
    if (! (e >= 0L)) {
      {
#line 226
      scm_wta(end1, (char *)10, s_substring_move_right_x);
      }
    }
  } else {
    {
#line 226
    scm_wta(end1, (char *)10, s_substring_move_right_x);
    }
  }
#line 227
  j = (e - i) + j;
#line 227
  if (! ((unsigned long )j <= (unsigned long )((scm_cell *)str2)->car >> 8)) {
    {
#line 227
    scm_wta(start2, (char *)10, s_substring_move_right_x);
    }
  }
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 228
    if (! (i < e)) {
#line 228
      goto while_break;
    }
#line 228
    j --;
#line 228
    e --;
#line 228
    *((char *)((scm_cell *)str2)->cdr + j) = *((char *)((scm_cell *)str1)->cdr + e);
  }
  while_break: /* CIL Label */ ;
  }
#line 229
  return ((long )(21 << 9) + 372L);
}
}
#line 233 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strop.c"
static char s_substring_fill_x[16]  = 
#line 233
  {      (char )'s',      (char )'u',      (char )'b',      (char )'s', 
        (char )'t',      (char )'r',      (char )'i',      (char )'n', 
        (char )'g',      (char )'-',      (char )'f',      (char )'i', 
        (char )'l',      (char )'l',      (char )'!',      (char )'\000'};
#line 235 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strop.c"
SCM scm_substring_fill_x(SCM str , SCM start , SCM args ) 
{ 
  SCM end ;
  SCM fill ;
  long i ;
  long e ;
  char c ;
  SCM tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  {
#line 244
  tmp___0 = scm_ilength(args);
  }
#line 244
  if (! (2L == tmp___0)) {
    {
#line 244
    tmp = scm_makfrom0str((char const   *)(s_substring_fill_x));
#line 244
    scm_wta(tmp, (char *)8, (char *)((void *)0));
    }
  }
#line 246
  end = ((scm_cell *)args)->car;
#line 246
  args = ((scm_cell *)args)->cdr;
#line 247
  fill = ((scm_cell *)args)->car;
#line 248
  if (! (6 & (int )str)) {
#line 248
    if (! ((125 & (int )((scm_cell *)str)->car) == 21)) {
      {
#line 248
      scm_wta(str, (char *)1, s_substring_fill_x);
      }
    }
  } else {
    {
#line 248
    scm_wta(str, (char *)1, s_substring_fill_x);
    }
  }
#line 249
  if (! (2 & (int )start)) {
    {
#line 249
    scm_wta(start, (char *)2, s_substring_fill_x);
    }
  }
#line 250
  if (! (2 & (int )end)) {
    {
#line 250
    scm_wta(end, (char *)3, s_substring_fill_x);
    }
  }
#line 251
  if (! (((int )fill & 255) == 244)) {
    {
#line 251
    scm_wta(fill, (char *)4, s_substring_fill_x);
    }
  }
#line 252
  i = start >> 2;
#line 252
  e = end >> 2;
#line 252
  c = (char )((unsigned int )(fill >> 8));
#line 253
  if ((unsigned long )i <= (unsigned long )((scm_cell *)str)->car >> 8) {
#line 253
    if (! (i >= 0L)) {
      {
#line 253
      scm_wta(start, (char *)10, s_substring_fill_x);
      }
    }
  } else {
    {
#line 253
    scm_wta(start, (char *)10, s_substring_fill_x);
    }
  }
#line 254
  if ((unsigned long )e <= (unsigned long )((scm_cell *)str)->car >> 8) {
#line 254
    if (! (e >= 0L)) {
      {
#line 254
      scm_wta(end, (char *)10, s_substring_fill_x);
      }
    }
  } else {
    {
#line 254
    scm_wta(end, (char *)10, s_substring_fill_x);
    }
  }
  {
#line 255
  while (1) {
    while_continue: /* CIL Label */ ;
#line 255
    if (! (i < e)) {
#line 255
      goto while_break;
    }
#line 255
    tmp___1 = i;
#line 255
    i ++;
#line 255
    *((char *)((scm_cell *)str)->cdr + tmp___1) = c;
  }
  while_break: /* CIL Label */ ;
  }
#line 256
  return ((long )(21 << 9) + 372L);
}
}
#line 260 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strop.c"
static char s_string_null_p[13]  = 
#line 260
  {      (char )'s',      (char )'t',      (char )'r',      (char )'i', 
        (char )'n',      (char )'g',      (char )'-',      (char )'n', 
        (char )'u',      (char )'l',      (char )'l',      (char )'?', 
        (char )'\000'};
#line 262 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strop.c"
SCM scm_string_null_p(SCM str ) 
{ 
  long tmp ;

  {
#line 266
  if (! (6 & (int )str)) {
#line 266
    if (! ((117 & (int )((scm_cell *)str)->car) == 21)) {
#line 266
      if (! ((125 & (int )((scm_cell *)str)->car) == 5)) {
        {
#line 266
        scm_wta(str, (char *)1, s_string_null_p);
        }
      }
    }
  } else {
    {
#line 266
    scm_wta(str, (char *)1, s_string_null_p);
    }
  }
#line 267
  if ((unsigned long )((scm_cell *)str)->car >> 8) {
#line 267
    tmp = (long )(16 << 9) + 372L;
  } else {
#line 267
    tmp = (long )(17 << 9) + 372L;
  }
#line 267
  return (tmp);
}
}
#line 273 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strop.c"
static char s_string_to_list[13]  = 
#line 273
  {      (char )'s',      (char )'t',      (char )'r',      (char )'i', 
        (char )'n',      (char )'g',      (char )'-',      (char )'>', 
        (char )'l',      (char )'i',      (char )'s',      (char )'t', 
        (char )'\000'};
#line 275 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strop.c"
SCM scm_string_to_list(SCM str ) 
{ 
  long i ;
  SCM res ;
  unsigned char *src ;

  {
#line 280
  res = (long )(20 << 9) + 372L;
#line 282
  if (! (6 & (int )str)) {
#line 282
    if (! ((117 & (int )((scm_cell *)str)->car) == 21)) {
#line 282
      if (! ((125 & (int )((scm_cell *)str)->car) == 5)) {
        {
#line 282
        scm_wta(str, (char *)1, s_string_to_list);
        }
      }
    }
  } else {
    {
#line 282
    scm_wta(str, (char *)1, s_string_to_list);
    }
  }
#line 283
  if ((127 & (int )((scm_cell *)str)->car) == 29) {
#line 283
    src = (unsigned char *)((scm_cell *)((scm_cell *)((scm_cell *)str)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)str)->cdr)->car >> 2);
  } else {
#line 283
    src = (unsigned char *)((scm_cell *)str)->cdr;
  }
#line 284
  i = (long )(((unsigned long )((scm_cell *)str)->car >> 8) - 1UL);
  {
#line 284
  while (1) {
    while_continue: /* CIL Label */ ;
#line 284
    if (! (i >= 0L)) {
#line 284
      goto while_break;
    }
    {
#line 284
    res = scm_cons((SCM )(((int )*(src + i) << 8) + 244), res);
#line 284
    i --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 285
  return (res);
}
}
#line 290 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strop.c"
static char s_string_copy[12]  = 
#line 290
  {      (char )'s',      (char )'t',      (char )'r',      (char )'i', 
        (char )'n',      (char )'g',      (char )'-',      (char )'c', 
        (char )'o',      (char )'p',      (char )'y',      (char )'\000'};
#line 292 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strop.c"
SCM scm_string_copy(SCM str ) 
{ 
  SCM tmp ;

  {
#line 296
  if (! (6 & (int )str)) {
#line 296
    if (! ((125 & (int )((scm_cell *)str)->car) == 21)) {
      {
#line 296
      scm_wta(str, (char *)1, s_string_copy);
      }
    }
  } else {
    {
#line 296
    scm_wta(str, (char *)1, s_string_copy);
    }
  }
  {
#line 297
  tmp = scm_makfromstr((char const   *)((char *)((scm_cell *)str)->cdr), (unsigned long )((scm_cell *)str)->car >> 8,
                       0);
  }
#line 297
  return (tmp);
}
}
#line 301 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strop.c"
static char s_string_fill_x[13]  = 
#line 301
  {      (char )'s',      (char )'t',      (char )'r',      (char )'i', 
        (char )'n',      (char )'g',      (char )'-',      (char )'f', 
        (char )'i',      (char )'l',      (char )'l',      (char )'!', 
        (char )'\000'};
#line 303 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strop.c"
SCM scm_string_fill_x(SCM str , SCM chr ) 
{ 
  register char *dst ;
  register char c ;
  register long k ;

  {
#line 310
  if (! (6 & (int )str)) {
#line 310
    if (! ((125 & (int )((scm_cell *)str)->car) == 21)) {
      {
#line 310
      scm_wta(str, (char *)1, s_string_fill_x);
      }
    }
  } else {
    {
#line 310
    scm_wta(str, (char *)1, s_string_fill_x);
    }
  }
#line 311
  if (! (((int )chr & 255) == 244)) {
    {
#line 311
    scm_wta(chr, (char *)2, s_string_fill_x);
    }
  }
#line 312
  c = (char )((unsigned int )(chr >> 8));
#line 313
  dst = (char *)((scm_cell *)str)->cdr;
#line 314
  k = (long )(((unsigned long )((scm_cell *)str)->car >> 8) - 1UL);
  {
#line 314
  while (1) {
    while_continue: /* CIL Label */ ;
#line 314
    if (! (k >= 0L)) {
#line 314
      goto while_break;
    }
#line 314
    *(dst + k) = c;
#line 314
    k --;
  }
  while_break: /* CIL Label */ ;
  }
#line 315
  return ((long )(21 << 9) + 372L);
}
}
#line 320 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strop.c"
void scm_init_strop(void) 
{ 


  {
  {
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strop.x"
  scm_make_gsubr(s_string_index, 2, 2, 0, (SCM (*)())(& scm_string_index));
#line 2
  scm_make_gsubr(s_string_rindex, 2, 2, 0, (SCM (*)())(& scm_string_rindex));
#line 3
  scm_make_gsubr(s_substring_move_left_x, 2, 0, 1, (SCM (*)())(& scm_substring_move_left_x));
#line 4
  scm_make_gsubr(s_substring_move_right_x, 2, 0, 1, (SCM (*)())(& scm_substring_move_right_x));
#line 5
  scm_make_gsubr(s_substring_fill_x, 2, 0, 1, (SCM (*)())(& scm_substring_fill_x));
#line 6
  scm_make_gsubr(s_string_null_p, 1, 0, 0, (SCM (*)())(& scm_string_null_p));
#line 7
  scm_make_gsubr(s_string_to_list, 1, 0, 0, (SCM (*)())(& scm_string_to_list));
#line 8
  scm_make_gsubr(s_string_copy, 1, 0, 0, (SCM (*)())(& scm_string_copy));
#line 9
  scm_make_gsubr(s_string_fill_x, 2, 0, 0, (SCM (*)())(& scm_string_fill_x));
  }
#line 324 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strop.c"
  return;
}
}
#line 61 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strings.h"
SCM scm_string_p(SCM x ) ;
#line 62
SCM scm_read_only_string_p(SCM x ) ;
#line 63
SCM scm_string(SCM chrs ) ;
#line 65
SCM scm_makfromstrs(int argc , char **argv ) ;
#line 66
SCM scm_take0str(char *it ) ;
#line 69
SCM scm_makfrom0str_opt(char const   *src ) ;
#line 71
SCM scm_string_length(SCM str ) ;
#line 72
SCM scm_string_ref(SCM str , SCM k ) ;
#line 73
SCM scm_string_set_x(SCM str , SCM k , SCM chr ) ;
#line 74
SCM scm_substring(SCM str , SCM start , SCM end ) ;
#line 77
void scm_init_strings(void) ;
#line 53 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strings.c"
static char s_string_p[8]  = 
#line 53 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strings.c"
  {      (char )'s',      (char )'t',      (char )'r',      (char )'i', 
        (char )'n',      (char )'g',      (char )'?',      (char )'\000'};
#line 55 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strings.c"
SCM scm_string_p(SCM x ) 
{ 
  long tmp ;

  {
#line 59
  if (6 & (int )x) {
#line 60
    return ((long )(16 << 9) + 372L);
  }
#line 61
  if ((125 & (int )((scm_cell *)x)->car) == 21) {
#line 61
    tmp = (long )(17 << 9) + 372L;
  } else {
#line 61
    tmp = (long )(16 << 9) + 372L;
  }
#line 61
  return (tmp);
}
}
#line 64 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strings.c"
static char s_read_only_string_p[18]  = 
#line 64
  {      (char )'r',      (char )'e',      (char )'a',      (char )'d', 
        (char )'-',      (char )'o',      (char )'n',      (char )'l', 
        (char )'y',      (char )'-',      (char )'s',      (char )'t', 
        (char )'r',      (char )'i',      (char )'n',      (char )'g', 
        (char )'?',      (char )'\000'};
#line 66 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strings.c"
SCM scm_read_only_string_p(SCM x ) 
{ 
  long tmp ;

  {
#line 70
  if (6 & (int )x) {
#line 71
    return ((long )(16 << 9) + 372L);
  }
#line 72
  if ((117 & (int )((scm_cell *)x)->car) == 21) {
#line 72
    tmp = (long )(17 << 9) + 372L;
  } else
#line 72
  if ((125 & (int )((scm_cell *)x)->car) == 5) {
#line 72
    tmp = (long )(17 << 9) + 372L;
  } else {
#line 72
    tmp = (long )(16 << 9) + 372L;
  }
#line 72
  return (tmp);
}
}
#line 75 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strings.c"
static char s_list_to_string[13]  = 
#line 75
  {      (char )'l',      (char )'i',      (char )'s',      (char )'t', 
        (char )'-',      (char )'>',      (char )'s',      (char )'t', 
        (char )'r',      (char )'i',      (char )'n',      (char )'g', 
        (char )'\000'};
#line 76 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strings.c"
static char s_string[7]  = {      (char )'s',      (char )'t',      (char )'r',      (char )'i', 
        (char )'n',      (char )'g',      (char )'\000'};
#line 78 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strings.c"
SCM scm_string(SCM chrs ) 
{ 
  SCM res ;
  register unsigned char *data ;
  long i ;
  long len ;
  SCM s___0 ;
  unsigned char *tmp ;
  int l ;
  char *c ;
  unsigned char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 86
  scm_ints_disabled = 1;
#line 87
  i = scm_ilength(chrs);
  }
#line 88
  if (i < 0L) {
#line 90
    scm_ints_disabled = 0;
#line 90
    scm_async_clock --;
#line 90
    if (0U == scm_async_clock) {
      {
#line 90
      scm_async_click();
      }
    }
    {
#line 91
    scm_wta(chrs, (char *)1, s_string);
    }
  }
#line 93
  len = 0L;
#line 97
  len = 0L;
#line 97
  s___0 = chrs;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (! (s___0 != (long )(20 << 9) + 372L)) {
#line 97
      goto while_break;
    }
#line 98
    if (((int )((scm_cell *)s___0)->car & 255) == 244) {
#line 99
      len ++;
    } else
#line 100
    if (! (6 & (int )((scm_cell *)s___0)->car)) {
#line 100
      if ((117 & (int )((scm_cell *)((scm_cell *)s___0)->car)->car) == 21) {
#line 101
        len = (long )((unsigned long )len + ((unsigned long )((scm_cell *)((scm_cell *)s___0)->car)->car >> 8));
      } else
#line 100
      if ((125 & (int )((scm_cell *)((scm_cell *)s___0)->car)->car) == 5) {
#line 101
        len = (long )((unsigned long )len + ((unsigned long )((scm_cell *)((scm_cell *)s___0)->car)->car >> 8));
      } else {
#line 100
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 104
      scm_ints_disabled = 0;
#line 104
      scm_async_clock --;
#line 104
      if (0U == scm_async_clock) {
        {
#line 104
        scm_async_click();
        }
      }
      {
#line 105
      scm_wta(s___0, (char *)1, s_string);
      }
    }
#line 97
    s___0 = ((scm_cell *)s___0)->cdr;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 108
  res = scm_makstr(len, 0);
#line 109
  data = (unsigned char *)((scm_cell *)res)->cdr;
  }
  {
#line 110
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 110
    if (! ((long )(20 << 9) + 372L != chrs)) {
#line 110
      goto while_break___0;
    }
#line 112
    if (((int )((scm_cell *)chrs)->car & 255) == 244) {
#line 113
      tmp = data;
#line 113
      data ++;
#line 113
      *tmp = (unsigned char )((unsigned int )(((scm_cell *)chrs)->car >> 8));
    } else {
#line 118
      l = (int )((unsigned long )((scm_cell *)((scm_cell *)chrs)->car)->car >> 8);
#line 119
      if ((127 & (int )((scm_cell *)((scm_cell *)chrs)->car)->car) == 29) {
#line 119
        c = (char *)((unsigned char *)((scm_cell *)((scm_cell *)((scm_cell *)((scm_cell *)chrs)->car)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)((scm_cell *)chrs)->car)->cdr)->car >> 2));
      } else {
#line 119
        c = (char *)((unsigned char *)((scm_cell *)((scm_cell *)chrs)->car)->cdr);
      }
      {
#line 120
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 120
        if (! l) {
#line 120
          goto while_break___1;
        }
#line 122
        l --;
#line 123
        tmp___0 = data;
#line 123
        data ++;
#line 123
        tmp___1 = c;
#line 123
        c ++;
#line 123
        *tmp___0 = (unsigned char )*tmp___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 110
    chrs = ((scm_cell *)chrs)->cdr;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 127
  scm_ints_disabled = 0;
#line 127
  scm_async_clock --;
#line 127
  if (0U == scm_async_clock) {
    {
#line 127
    scm_async_click();
    }
  }
#line 128
  return (res);
}
}
#line 132 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strings.c"
SCM scm_makstr(long len , int slots ) 
{ 
  SCM s___0 ;
  SCM *mem ;
  char *tmp ;
  int x ;

  {
#line 139
  if (6 & (int )scm_freelist) {
    {
#line 139
    s___0 = scm_gc_for_newcell();
    }
  } else {
#line 139
    s___0 = scm_freelist;
#line 139
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 139
    scm_cells_allocated ++;
  }
  {
#line 140
  slots --;
#line 141
  scm_ints_disabled ++;
#line 142
  tmp = scm_must_malloc((long )((sizeof(SCM ) * (unsigned long )(slots + 1) + (unsigned long )len) + 1UL),
                        s_string);
#line 142
  mem = (SCM *)tmp;
  }
#line 144
  if (slots >= 0) {
#line 147
    *(mem + slots) = (SCM )mem;
#line 148
    x = 0;
    {
#line 148
    while (1) {
      while_continue: /* CIL Label */ ;
#line 148
      if (! (x < slots)) {
#line 148
        goto while_break;
      }
#line 149
      *(mem + x) = (long )(16 << 9) + 372L;
#line 148
      x ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 151
  ((scm_cell *)s___0)->cdr = (SCM )((char *)((mem + slots) + 1));
#line 152
  ((scm_cell *)s___0)->car = (len << 8) + 21L;
#line 153
  scm_ints_disabled --;
#line 153
  if (! scm_ints_disabled) {
#line 153
    scm_async_clock --;
#line 153
    if (0U == scm_async_clock) {
      {
#line 153
      scm_async_click();
      }
    }
  }
#line 154
  *((char *)((scm_cell *)s___0)->cdr + len) = (char)0;
#line 155
  return (s___0);
}
}
#line 161 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strings.c"
SCM scm_makfromstrs(int argc , char **argv ) 
{ 
  int i ;
  SCM lst ;
  size_t tmp ;
  SCM tmp___0 ;
  int tmp___1 ;

  {
#line 166
  i = argc;
#line 167
  lst = (long )(20 << 9) + 372L;
#line 168
  if (0 > i) {
#line 169
    i = 0;
    {
#line 169
    while (1) {
      while_continue: /* CIL Label */ ;
#line 169
      if (! *(argv + i)) {
#line 169
        goto while_break;
      }
#line 169
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 170
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 170
    tmp___1 = i;
#line 170
    i --;
#line 170
    if (! tmp___1) {
#line 170
      goto while_break___0;
    }
    {
#line 171
    tmp = strlen((char const   *)*(argv + i));
#line 171
    tmp___0 = scm_makfromstr((char const   *)*(argv + i), tmp, 0);
#line 171
    lst = scm_cons(tmp___0, lst);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 172
  return (lst);
}
}
#line 177 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strings.c"
SCM scm_take0str(char *it ) 
{ 
  SCM answer ;
  size_t tmp ;

  {
#line 182
  if (6 & (int )scm_freelist) {
    {
#line 182
    answer = scm_gc_for_newcell();
    }
  } else {
#line 182
    answer = scm_freelist;
#line 182
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 182
    scm_cells_allocated ++;
  }
  {
#line 183
  scm_ints_disabled = 1;
#line 184
  tmp = strlen((char const   *)it);
#line 184
  ((scm_cell *)answer)->car = (SCM )((tmp << 8) + 21UL);
#line 185
  ((scm_cell *)answer)->cdr = (SCM )it;
#line 186
  scm_ints_disabled = 0;
#line 186
  scm_async_clock --;
  }
#line 186
  if (0U == scm_async_clock) {
    {
#line 186
    scm_async_click();
    }
  }
#line 187
  return (answer);
}
}
#line 191 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strings.c"
SCM scm_makfromstr(char const   *src , size_t len , int slots ) 
{ 
  SCM s___0 ;
  register char *dst ;
  char *tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 199
  s___0 = scm_makstr((long )len, slots);
#line 200
  dst = (char *)((scm_cell *)s___0)->cdr;
  }
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 201
    tmp___1 = len;
#line 201
    len --;
#line 201
    if (! tmp___1) {
#line 201
      goto while_break;
    }
#line 202
    tmp = dst;
#line 202
    dst ++;
#line 202
    tmp___0 = src;
#line 202
    src ++;
#line 202
    *tmp = (char )*tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 203
  return (s___0);
}
}
#line 208 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strings.c"
SCM scm_makfrom0str(char const   *src ) 
{ 
  size_t tmp ;
  SCM tmp___0 ;

  {
#line 212
  if (! src) {
#line 212
    return ((long )(16 << 9) + 372L);
  }
  {
#line 213
  tmp = strlen(src);
#line 213
  tmp___0 = scm_makfromstr(src, tmp, 0);
  }
#line 213
  return (tmp___0);
}
}
#line 217 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strings.c"
SCM scm_makfrom0str_opt(char const   *src ) 
{ 
  SCM tmp ;

  {
  {
#line 221
  tmp = scm_makfrom0str(src);
  }
#line 221
  return (tmp);
}
}
#line 227 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strings.c"
static char s_make_string[12]  = 
#line 227
  {      (char )'m',      (char )'a',      (char )'k',      (char )'e', 
        (char )'-',      (char )'s',      (char )'t',      (char )'r', 
        (char )'i',      (char )'n',      (char )'g',      (char )'\000'};
#line 229 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strings.c"
SCM scm_make_string(SCM k , SCM chr ) 
{ 
  SCM res ;
  register unsigned char *dst ;
  register long i ;
  char c ;

  {
#line 237
  if (2 & (int )k) {
#line 237
    if (! (k >= 0L)) {
      {
#line 237
      scm_wta(k, (char *)1, s_make_string);
      }
    }
  } else {
    {
#line 237
    scm_wta(k, (char *)1, s_make_string);
    }
  }
  {
#line 238
  i = k >> 2;
#line 239
  res = scm_makstr(i, 0);
#line 240
  dst = (unsigned char *)((scm_cell *)res)->cdr;
  }
#line 241
  if (((int )chr & 255) == 244) {
#line 243
    c = (char )((unsigned int )(chr >> 8));
#line 244
    i --;
    {
#line 244
    while (1) {
      while_continue: /* CIL Label */ ;
#line 244
      if (! (i >= 0L)) {
#line 244
        goto while_break;
      }
#line 246
      *(dst + i) = (unsigned char )c;
#line 244
      i --;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 249
  return (res);
}
}
#line 252 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strings.c"
static char s_string_length[14]  = 
#line 252
  {      (char )'s',      (char )'t',      (char )'r',      (char )'i', 
        (char )'n',      (char )'g',      (char )'-',      (char )'l', 
        (char )'e',      (char )'n',      (char )'g',      (char )'t', 
        (char )'h',      (char )'\000'};
#line 254 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strings.c"
SCM scm_string_length(SCM str ) 
{ 


  {
#line 258
  if (! (6 & (int )str)) {
#line 258
    if (! ((117 & (int )((scm_cell *)str)->car) == 21)) {
#line 258
      if (! ((125 & (int )((scm_cell *)str)->car) == 5)) {
        {
#line 258
        scm_wta(str, (char *)1, s_string_length);
        }
      }
    }
  } else {
    {
#line 258
    scm_wta(str, (char *)1, s_string_length);
    }
  }
#line 259
  return ((SCM )((((unsigned long )((scm_cell *)str)->car >> 8) << 2) + 2UL));
}
}
#line 262 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strings.c"
static char s_string_ref[11]  = 
#line 262
  {      (char )'s',      (char )'t',      (char )'r',      (char )'i', 
        (char )'n',      (char )'g',      (char )'-',      (char )'r', 
        (char )'e',      (char )'f',      (char )'\000'};
#line 264 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strings.c"
SCM scm_string_ref(SCM str , SCM k ) 
{ 
  unsigned char *tmp ;

  {
#line 269
  if (! (6 & (int )str)) {
#line 269
    if (! ((117 & (int )((scm_cell *)str)->car) == 21)) {
#line 269
      if (! ((125 & (int )((scm_cell *)str)->car) == 5)) {
        {
#line 269
        scm_wta(str, (char *)1, s_string_ref);
        }
      }
    }
  } else {
    {
#line 269
    scm_wta(str, (char *)1, s_string_ref);
    }
  }
#line 270
  if (k == (long )(18 << 9) + 372L) {
#line 271
    k = 2L;
  }
#line 272
  if (! (2 & (int )k)) {
    {
#line 272
    scm_wta(k, (char *)2, s_string_ref);
    }
  }
#line 273
  if ((unsigned long )(k >> 2) < (unsigned long )((scm_cell *)str)->car >> 8) {
#line 273
    if (! (k >> 2 >= 0L)) {
      {
#line 273
      scm_wta(k, (char *)10, s_string_ref);
      }
    }
  } else {
    {
#line 273
    scm_wta(k, (char *)10, s_string_ref);
    }
  }
#line 274
  if ((127 & (int )((scm_cell *)str)->car) == 29) {
#line 274
    tmp = (unsigned char *)((scm_cell *)((scm_cell *)((scm_cell *)str)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)str)->cdr)->car >> 2);
  } else {
#line 274
    tmp = (unsigned char *)((scm_cell *)str)->cdr;
  }
#line 274
  return ((SCM )(((int )*(tmp + (k >> 2)) << 8) + 244));
}
}
#line 277 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strings.c"
static char s_string_set_x[12]  = 
#line 277
  {      (char )'s',      (char )'t',      (char )'r',      (char )'i', 
        (char )'n',      (char )'g',      (char )'-',      (char )'s', 
        (char )'e',      (char )'t',      (char )'!',      (char )'\000'};
#line 279 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strings.c"
SCM scm_string_set_x(SCM str , SCM k , SCM chr ) 
{ 


  {
#line 285
  if (! (6 & (int )str)) {
#line 285
    if (! ((125 & (int )((scm_cell *)str)->car) == 21)) {
      {
#line 285
      scm_wta(str, (char *)1, s_string_set_x);
      }
    }
  } else {
    {
#line 285
    scm_wta(str, (char *)1, s_string_set_x);
    }
  }
#line 286
  if (! (2 & (int )k)) {
    {
#line 286
    scm_wta(k, (char *)2, s_string_set_x);
    }
  }
#line 287
  if (! (((int )chr & 255) == 244)) {
    {
#line 287
    scm_wta(chr, (char *)3, s_string_set_x);
    }
  }
#line 288
  if ((unsigned long )(k >> 2) < (unsigned long )((scm_cell *)str)->car >> 8) {
#line 288
    if (! (k >> 2 >= 0L)) {
      {
#line 288
      scm_wta(k, (char *)10, s_string_set_x);
      }
    }
  } else {
    {
#line 288
    scm_wta(k, (char *)10, s_string_set_x);
    }
  }
#line 289
  *((unsigned char *)((scm_cell *)str)->cdr + (k >> 2)) = (unsigned char )((unsigned int )(chr >> 8));
#line 290
  return ((long )(21 << 9) + 372L);
}
}
#line 295 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strings.c"
static char s_substring[10]  = 
#line 295
  {      (char )'s',      (char )'u',      (char )'b',      (char )'s', 
        (char )'t',      (char )'r',      (char )'i',      (char )'n', 
        (char )'g',      (char )'\000'};
#line 297 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strings.c"
SCM scm_substring(SCM str , SCM start , SCM end ) 
{ 
  long l ;
  char *tmp ;
  SCM tmp___0 ;

  {
#line 304
  if (! (6 & (int )str)) {
#line 304
    if (! ((117 & (int )((scm_cell *)str)->car) == 21)) {
#line 304
      if (! ((125 & (int )((scm_cell *)str)->car) == 5)) {
        {
#line 304
        scm_wta(str, (char *)1, s_substring);
        }
      }
    }
  } else {
    {
#line 304
    scm_wta(str, (char *)1, s_substring);
    }
  }
#line 306
  if (! (2 & (int )start)) {
    {
#line 306
    scm_wta(start, (char *)2, s_substring);
    }
  }
#line 307
  if (end == (long )(18 << 9) + 372L) {
#line 308
    end = (SCM )((((unsigned long )((scm_cell *)str)->car >> 8) << 2) + 2UL);
  }
#line 309
  if (! (2 & (int )end)) {
    {
#line 309
    scm_wta(end, (char *)3, s_substring);
    }
  }
#line 310
  if (! ((unsigned long )(start >> 2) <= (unsigned long )((scm_cell *)str)->car >> 8)) {
    {
#line 310
    scm_wta(start, (char *)10, s_substring);
    }
  }
#line 311
  if (! ((unsigned long )(end >> 2) <= (unsigned long )((scm_cell *)str)->car >> 8)) {
    {
#line 311
    scm_wta(end, (char *)10, s_substring);
    }
  }
#line 312
  l = (end >> 2) - (start >> 2);
#line 313
  if (! (l >= 0L)) {
    {
#line 313
    scm_wta((l << 2) + 2L, (char *)10, s_substring);
    }
  }
#line 314
  if ((127 & (int )((scm_cell *)str)->car) == 29) {
#line 314
    tmp = (char *)((scm_cell *)((scm_cell *)((scm_cell *)str)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)str)->cdr)->car >> 2);
  } else {
#line 314
    tmp = (char *)((scm_cell *)str)->cdr;
  }
  {
#line 314
  tmp___0 = scm_makfromstr((char const   *)(tmp + (start >> 2)), (size_t )l, 0);
  }
#line 314
  return (tmp___0);
}
}
#line 317 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strings.c"
static char s_string_append[14]  = 
#line 317
  {      (char )'s',      (char )'t',      (char )'r',      (char )'i', 
        (char )'n',      (char )'g',      (char )'-',      (char )'a', 
        (char )'p',      (char )'p',      (char )'e',      (char )'n', 
        (char )'d',      (char )'\000'};
#line 319 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strings.c"
SCM scm_string_append(SCM args ) 
{ 
  SCM res ;
  register long i ;
  register SCM l ;
  register SCM s___0 ;
  register unsigned char *data ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;

  {
#line 324
  i = 0L;
#line 327
  l = args;
  {
#line 327
  while (1) {
    while_continue: /* CIL Label */ ;
#line 327
    if (! (! (6 & (int )l))) {
#line 327
      goto while_break;
    }
#line 328
    if (! (! (1 & (int )((scm_cell *)l)->car))) {
      {
#line 328
      scm_wta(l, (char *)0, s_string_append);
      }
    }
#line 329
    s___0 = ((scm_cell *)l)->car;
#line 330
    if (! (6 & (int )s___0)) {
#line 330
      if (! ((117 & (int )((scm_cell *)s___0)->car) == 21)) {
#line 330
        if (! ((125 & (int )((scm_cell *)s___0)->car) == 5)) {
          {
#line 330
          scm_wta(s___0, (char *)0, s_string_append);
          }
        }
      }
    } else {
      {
#line 330
      scm_wta(s___0, (char *)0, s_string_append);
      }
    }
#line 332
    i = (long )((unsigned long )i + ((unsigned long )((scm_cell *)s___0)->car >> 8));
#line 333
    l = ((scm_cell *)l)->cdr;
  }
  while_break: /* CIL Label */ ;
  }
#line 335
  if (! ((long )(20 << 9) + 372L == l)) {
    {
#line 335
    scm_wta(args, (char *)0, s_string_append);
    }
  }
  {
#line 336
  res = scm_makstr(i, 0);
#line 337
  data = (unsigned char *)((scm_cell *)res)->cdr;
#line 338
  l = args;
  }
  {
#line 338
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 338
    if (! (! (6 & (int )l))) {
#line 338
      goto while_break___0;
    }
#line 339
    s___0 = ((scm_cell *)l)->car;
#line 340
    i = 0L;
    {
#line 340
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 340
      if (! ((unsigned long )i < (unsigned long )((scm_cell *)s___0)->car >> 8)) {
#line 340
        goto while_break___1;
      }
#line 340
      tmp = data;
#line 340
      data ++;
#line 340
      if ((127 & (int )((scm_cell *)s___0)->car) == 29) {
#line 340
        tmp___0 = (unsigned char *)((scm_cell *)((scm_cell *)((scm_cell *)s___0)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)s___0)->cdr)->car >> 2);
      } else {
#line 340
        tmp___0 = (unsigned char *)((scm_cell *)s___0)->cdr;
      }
#line 340
      *tmp = *(tmp___0 + i);
#line 340
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 338
    l = ((scm_cell *)l)->cdr;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 342
  return (res);
}
}
#line 345 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strings.c"
static char s_make_shared_substring[22]  = 
#line 345
  {      (char )'m',      (char )'a',      (char )'k',      (char )'e', 
        (char )'-',      (char )'s',      (char )'h',      (char )'a', 
        (char )'r',      (char )'e',      (char )'d',      (char )'-', 
        (char )'s',      (char )'u',      (char )'b',      (char )'s', 
        (char )'t',      (char )'r',      (char )'i',      (char )'n', 
        (char )'g',      (char )'\000'};
#line 347 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strings.c"
SCM scm_make_shared_substring(SCM str , SCM frm , SCM to ) 
{ 
  long f ;
  long t ;
  SCM answer ;
  SCM len_str ;
  long offset ;

  {
#line 358
  if (! (6 & (int )str)) {
#line 358
    if (! ((117 & (int )((scm_cell *)str)->car) == 21)) {
#line 358
      if (! ((125 & (int )((scm_cell *)str)->car) == 5)) {
        {
#line 358
        scm_wta(str, (char *)1, s_make_shared_substring);
        }
      }
    }
  } else {
    {
#line 358
    scm_wta(str, (char *)1, s_make_shared_substring);
    }
  }
#line 360
  if (frm == (long )(18 << 9) + 372L) {
#line 361
    frm = 2L;
  } else
#line 363
  if (! (2 & (int )frm)) {
    {
#line 363
    scm_wta(frm, (char *)2, s_make_shared_substring);
    }
  }
#line 365
  if (to == (long )(18 << 9) + 372L) {
#line 366
    to = (SCM )((((unsigned long )((scm_cell *)str)->car >> 8) << 2) + 2UL);
  } else
#line 368
  if (! (2 & (int )to)) {
    {
#line 368
    scm_wta(to, (char *)3, s_make_shared_substring);
    }
  }
#line 370
  f = frm >> 2;
#line 371
  t = to >> 2;
#line 372
  if (! (f >= 0L)) {
    {
#line 372
    scm_wta(frm, (char *)10, s_make_shared_substring);
    }
  }
#line 373
  if (f <= t) {
#line 373
    if (! ((unsigned long )t <= (unsigned long )((scm_cell *)str)->car >> 8)) {
      {
#line 373
      scm_wta(to, (char *)10, s_make_shared_substring);
      }
    }
  } else {
    {
#line 373
    scm_wta(to, (char *)10, s_make_shared_substring);
    }
  }
#line 375
  if (6 & (int )scm_freelist) {
    {
#line 375
    answer = scm_gc_for_newcell();
    }
  } else {
#line 375
    answer = scm_freelist;
#line 375
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 375
    scm_cells_allocated ++;
  }
#line 376
  if (6 & (int )scm_freelist) {
    {
#line 376
    len_str = scm_gc_for_newcell();
    }
  } else {
#line 376
    len_str = scm_freelist;
#line 376
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 376
    scm_cells_allocated ++;
  }
#line 378
  scm_ints_disabled = 1;
#line 379
  if ((125 & (int )((scm_cell *)str)->car) == 29) {
#line 382
    offset = ((scm_cell *)((scm_cell *)str)->cdr)->car >> 2;
#line 383
    f += offset;
#line 384
    t += offset;
#line 385
    ((scm_cell *)len_str)->car = (f << 2) + 2L;
#line 386
    ((scm_cell *)len_str)->cdr = ((scm_cell *)((scm_cell *)str)->cdr)->cdr;
#line 387
    ((scm_cell *)answer)->cdr = len_str;
#line 388
    ((scm_cell *)answer)->car = ((t - f) << 8) + 29L;
  } else {
#line 392
    ((scm_cell *)len_str)->car = (f << 2) + 2L;
#line 393
    ((scm_cell *)len_str)->cdr = str;
#line 394
    ((scm_cell *)answer)->cdr = len_str;
#line 395
    ((scm_cell *)answer)->car = ((t - f) << 8) + 29L;
  }
#line 397
  scm_ints_disabled = 0;
#line 397
  scm_async_clock --;
#line 397
  if (0U == scm_async_clock) {
    {
#line 397
    scm_async_click();
    }
  }
#line 398
  return (answer);
}
}
#line 402 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strings.c"
void scm_init_strings(void) 
{ 


  {
  {
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strings.x"
  scm_make_gsubr(s_string_p, 1, 0, 0, (SCM (*)())(& scm_string_p));
#line 2
  scm_make_gsubr(s_read_only_string_p, 1, 0, 0, (SCM (*)())(& scm_read_only_string_p));
#line 3
  scm_make_gsubr(s_list_to_string, 1, 0, 0, (SCM (*)())(& scm_string));
#line 4
  scm_make_gsubr(s_string, 0, 0, 1, (SCM (*)())(& scm_string));
#line 5
  scm_make_gsubr(s_make_string, 1, 1, 0, (SCM (*)())(& scm_make_string));
#line 6
  scm_make_gsubr(s_string_length, 1, 0, 0, (SCM (*)())(& scm_string_length));
#line 7
  scm_make_gsubr(s_string_ref, 1, 1, 0, (SCM (*)())(& scm_string_ref));
#line 8
  scm_make_gsubr(s_string_set_x, 3, 0, 0, (SCM (*)())(& scm_string_set_x));
#line 9
  scm_make_gsubr(s_substring, 2, 1, 0, (SCM (*)())(& scm_substring));
#line 10
  scm_make_gsubr(s_string_append, 0, 0, 1, (SCM (*)())(& scm_string_append));
#line 11
  scm_make_gsubr(s_make_shared_substring, 1, 2, 0, (SCM (*)())(& scm_make_shared_substring));
  }
#line 406 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strings.c"
  return;
}
}
#line 26 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strerror.c"
extern char *sys_errlist[] ;
#line 27
extern int sys_nerr ;
#line 22
 __attribute__((__nothrow__)) char *strerror(int errnum ) ;
#line 22 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/strerror.c"
char *strerror(int errnum ) 
{ 
  char *__cil_tmp2 ;

  {
#line 29
  if (errnum >= 0) {
#line 29
    if (errnum < sys_nerr) {
#line 30
      return (sys_errlist[errnum]);
    }
  }
#line 31
  return ((char *)"Unknown error");
}
}
#line 50 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stime.h"
SCM scm_get_internal_real_time(void) ;
#line 51
SCM scm_get_internal_run_time(void) ;
#line 52
SCM scm_current_time(void) ;
#line 53
long scm_time_in_msec(long x ) ;
#line 54
void scm_init_stime(void) ;
#line 186 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 49 "/usr/include/sys/times.h"
extern  __attribute__((__nothrow__)) clock_t times(struct tms *__buffer ) ;
#line 42 "/usr/include/sys/timeb.h"
extern int ftime(struct timeb *__timebuf ) ;
#line 112 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stime.c"
static long mytime(void) 
{ 
  struct tms time_buffer ;
  void *__cil_tmp2 ;

  {
  {
#line 116
  times(& time_buffer);
  }
#line 117
  return (time_buffer.tms_utime + time_buffer.tms_stime);
}
}
#line 133 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stime.c"
struct timeb scm_your_base  =    {(time_t )0, (unsigned short)0, (short)0, (short)0};
#line 134 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stime.c"
static char s_get_internal_real_time[23]  = 
#line 134
  {      (char )'g',      (char )'e',      (char )'t',      (char )'-', 
        (char )'i',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'n',      (char )'a',      (char )'l', 
        (char )'-',      (char )'r',      (char )'e',      (char )'a', 
        (char )'l',      (char )'-',      (char )'t',      (char )'i', 
        (char )'m',      (char )'e',      (char )'\000'};
#line 135 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stime.c"
SCM scm_get_internal_real_time(void) 
{ 
  struct timeb time_buffer ;
  long tmp ;
  void *__cil_tmp3 ;

  {
  {
#line 140
  ftime(& time_buffer);
#line 141
  time_buffer.time -= scm_your_base.time;
#line 142
  tmp = (long )((int )time_buffer.millitm - (int )scm_your_base.millitm);
#line 143
  tmp = time_buffer.time * 1000L + tmp;
#line 144
  tmp *= 1000000L;
#line 145
  tmp /= 1000L;
  }
#line 146
  return ((tmp << 2) + 2L);
}
}
#line 162 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stime.c"
static long scm_my_base  =    0L;
#line 164 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stime.c"
static char s_get_internal_run_time[22]  = 
#line 164
  {      (char )'g',      (char )'e',      (char )'t',      (char )'-', 
        (char )'i',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'n',      (char )'a',      (char )'l', 
        (char )'-',      (char )'r',      (char )'u',      (char )'n', 
        (char )'-',      (char )'t',      (char )'i',      (char )'m', 
        (char )'e',      (char )'\000'};
#line 165 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stime.c"
SCM scm_get_internal_run_time(void) 
{ 
  long tmp ;

  {
  {
#line 168
  tmp = mytime();
  }
#line 168
  return (((tmp - scm_my_base) << 2) + 2L);
}
}
#line 171 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stime.c"
static char s_current_time[13]  = 
#line 171
  {      (char )'c',      (char )'u',      (char )'r',      (char )'r', 
        (char )'e',      (char )'n',      (char )'t',      (char )'-', 
        (char )'t',      (char )'i',      (char )'m',      (char )'e', 
        (char )'\000'};
#line 172 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stime.c"
SCM scm_current_time(void) 
{ 
  time_t timv ;
  time_t tmp ;
  SCM ans ;
  time_t tmp___0 ;

  {
  {
#line 175
  tmp = time((time_t *)0);
#line 175
  timv = tmp;
#line 177
  ans = scm_ulong2num((unsigned long )timv);
  }
#line 178
  if ((long )(16 << 9) + 372L == ans) {
#line 178
    tmp___0 = (timv << 2) + 2L;
  } else {
#line 178
    tmp___0 = ans;
  }
#line 178
  return (tmp___0);
}
}
#line 181 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stime.c"
long scm_time_in_msec(long x ) 
{ 


  {
#line 187
  return ((x * 1000L) / 1000000L);
}
}
#line 190 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stime.c"
void scm_init_stime(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
#line 193
  scm_sysintern((char *)"internal-time-units-per-second", (1000000L << 2) + 2L);
  }
#line 197
  if (! scm_your_base.time) {
    {
#line 197
    ftime(& scm_your_base);
    }
  }
#line 202
  if (! scm_my_base) {
    {
#line 202
    scm_my_base = mytime();
    }
  }
  {
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stime.x"
  scm_make_gsubr(s_get_internal_real_time, 0, 0, 0, & scm_get_internal_real_time);
#line 2
  scm_make_gsubr(s_get_internal_run_time, 0, 0, 0, & scm_get_internal_run_time);
#line 3
  scm_make_gsubr(s_current_time, 0, 0, 0, & scm_current_time);
  }
#line 205 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stime.c"
  return;
}
}
#line 76 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/error.h"
 __attribute__((__noreturn__)) void scm_wrong_type_arg(char *subr , int pos , SCM bad_value ) ;
#line 166 "../libguile/debug.h"
long scm_tc16_debugobj ;
#line 195
SCM scm_make_memoized(SCM exp___0 , SCM env ) ;
#line 73 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.h"
SCM scm_stack_type  ;
#line 115
SCM scm_stack_p(SCM obj ) ;
#line 116
SCM scm_make_stack(SCM args ) ;
#line 117
SCM scm_stack_ref(SCM stack , SCM i ) ;
#line 118
SCM scm_stack_length(SCM stack ) ;
#line 120
SCM scm_frame_p(SCM obj ) ;
#line 121
SCM scm_last_stack_frame(SCM obj ) ;
#line 122
SCM scm_frame_number(SCM frame ) ;
#line 123
SCM scm_frame_source(SCM frame ) ;
#line 124
SCM scm_frame_procedure(SCM frame ) ;
#line 125
SCM scm_frame_arguments(SCM frame ) ;
#line 126
SCM scm_frame_previous(SCM frame ) ;
#line 127
SCM scm_frame_next(SCM frame ) ;
#line 128
SCM scm_frame_real_p(SCM frame ) ;
#line 129
SCM scm_frame_procedure_p(SCM frame ) ;
#line 130
SCM scm_frame_evaluating_args_p(SCM frame ) ;
#line 131
SCM scm_frame_overflow_p(SCM frame ) ;
#line 133
void scm_init_stacks(void) ;
#line 145 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.c"
static int stack_depth(scm_debug_frame *dframe , long offset , SCM *id , int *maxp ) ;
#line 146 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.c"
static int stack_depth(scm_debug_frame *dframe , long offset , SCM *id , int *maxp ) 
{ 
  int n ;
  int size ;
  int max_depth ;
  scm_debug_info *info ;

  {
#line 154
  max_depth = (int )scm_debug_opts[7].val;
#line 156
  n = 0;
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (dframe) {
#line 156
      if (! ((dframe->status & (3L << 10)) == 2L << 10)) {
#line 156
        if (! (n < max_depth)) {
#line 156
          goto while_break;
        }
      } else {
#line 156
        goto while_break;
      }
    } else {
#line 156
      goto while_break;
    }
#line 160
    if ((dframe->status & (3L << 10)) == 0L) {
#line 162
      size = (int )(dframe->status & 63L);
#line 163
      info = (scm_debug_info *)((SCM_STACKITEM *)dframe->info + offset);
#line 164
      n = (int )((long )n + ((info - dframe->vect) / 2L + 1L));
#line 167
      if (((info - dframe->vect) & 1L) == 0L) {
#line 167
        if ((dframe->status & (1L << 6)) != 0L) {
#line 167
          if (! ((long )(18 << 9) + 372L == (info + 1)->a.proc)) {
#line 170
            n ++;
          }
        }
      }
    } else {
#line 173
      n ++;
    }
#line 156
    dframe = (scm_debug_frame *)((SCM_STACKITEM *)dframe->prev + offset);
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  if (dframe) {
#line 175
    if ((dframe->status & (3L << 10)) == 2L << 10) {
#line 176
      *id = (dframe->vect + 0)->id;
    } else {
#line 175
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 177
  if (dframe) {
#line 178
    *maxp = 1;
  }
#line 179
  return (n);
}
}
#line 184
static void read_frame(scm_debug_frame *dframe , long offset , scm_info_frame *iframe ) ;
#line 185 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.c"
static void read_frame(scm_debug_frame *dframe , long offset , scm_info_frame *iframe ) 
{ 
  SCM flags ;
  int size ;
  scm_debug_info *info ;

  {
#line 191
  flags = (SCM )2;
#line 194
  if ((dframe->status & (3L << 10)) == 0L) {
#line 196
    size = (int )(dframe->status & 63L);
#line 197
    info = (scm_debug_info *)((SCM_STACKITEM *)dframe->info + offset);
#line 198
    if ((info - dframe->vect) & 1L) {
#line 201
      info --;
#line 202
      if ((info + 1)->a.proc != (long )(18 << 9) + 372L) {
#line 204
        flags |= 1L << 4;
#line 205
        iframe->proc = (info + 1)->a.proc;
#line 206
        iframe->args = (info + 1)->a.args;
#line 207
        if (! ((dframe->status & (1L << 7)) != 0L)) {
#line 208
          flags |= 1L << 5;
        }
      }
    }
    {
#line 211
    iframe->source = scm_make_memoized((info + 0)->e.exp, (info + 0)->e.env);
    }
  } else {
#line 215
    flags |= 1L << 4;
#line 216
    iframe->proc = (dframe->vect + 0)->a.proc;
#line 217
    iframe->args = (dframe->vect + 0)->a.args;
  }
#line 219
  iframe->flags = flags;
#line 220
  return;
}
}
#line 235
static void read_frames(scm_debug_frame *dframe , long offset , int n , scm_info_frame *iframes ) ;
#line 236 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.c"
static void read_frames(scm_debug_frame *dframe , long offset , int n , scm_info_frame *iframes ) 
{ 
  int size ;
  scm_info_frame *iframe ;
  scm_debug_info *info ;

  {
#line 244
  iframe = iframes;
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if (dframe) {
#line 247
      if (! ((dframe->status & (3L << 10)) == 2L << 10)) {
#line 247
        if (! (n > 0)) {
#line 247
          goto while_break;
        }
      } else {
#line 247
        goto while_break;
      }
    } else {
#line 247
      goto while_break;
    }
    {
#line 251
    read_frame(dframe, offset, iframe);
    }
#line 252
    if ((dframe->status & (3L << 10)) == 0L) {
#line 254
      size = (int )(dframe->status & 63L);
#line 255
      info = (scm_debug_info *)((SCM_STACKITEM *)dframe->info + offset);
#line 256
      if ((info - dframe->vect) & 1L) {
#line 257
        info --;
      } else
#line 260
      if ((dframe->status & (1L << 6)) != 0L) {
#line 260
        if (! ((long )(18 << 9) + 372L == (info + 1)->a.proc)) {
#line 263
          iframe ++;
#line 263
          n --;
#line 263
          if (n == 0) {
#line 263
            goto quit;
          }
#line 264
          iframe->flags = 2L | (1L << 4);
#line 265
          iframe->proc = (info + 1)->a.proc;
#line 266
          iframe->args = (info + 1)->a.args;
        }
      }
#line 268
      if ((dframe->status & (1L << 6)) != 0L) {
#line 269
        iframe->flags |= 1L << 6;
      }
#line 270
      info -= 2;
#line 271
      iframe ++;
#line 271
      n --;
#line 271
      if (n == 0) {
#line 271
        goto quit;
      }
      {
#line 272
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 272
        if (! ((unsigned long )info >= (unsigned long )dframe->vect)) {
#line 272
          goto while_break___0;
        }
#line 274
        if (! ((long )(18 << 9) + 372L == (info + 1)->a.proc)) {
#line 276
          iframe->flags = 2L | (1L << 4);
#line 277
          iframe->proc = (info + 1)->a.proc;
#line 278
          iframe->args = (info + 1)->a.args;
        } else {
#line 281
          iframe->flags = (SCM )2;
        }
        {
#line 282
        iframe->source = scm_make_memoized((info + 0)->e.exp, (info + 0)->e.env);
#line 284
        info -= 2;
#line 285
        iframe ++;
#line 285
        n --;
        }
#line 285
        if (n == 0) {
#line 285
          goto quit;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 290
      iframe ++;
#line 290
      n --;
#line 290
      if (n == 0) {
#line 290
        goto quit;
      }
    }
    quit: 
#line 293
    if ((unsigned long )iframe > (unsigned long )iframes) {
#line 294
      (iframe - 1)->flags |= 1L << 3;
    }
#line 247
    dframe = (scm_debug_frame *)((SCM_STACKITEM *)dframe->prev + offset);
  }
  while_break: /* CIL Label */ ;
  }
#line 296
  return;
}
}
#line 298
static void narrow_stack(SCM stack , int inner , SCM inner_key , int outer , SCM outer_key ) ;
#line 300 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.c"
static void narrow_stack(SCM stack , int inner , SCM inner_key , int outer , SCM outer_key ) 
{ 
  scm_stack *s___0 ;
  int i ;
  int n ;
  int tmp ;

  {
#line 308
  s___0 = (scm_stack *)((SCM *)((scm_cell *)stack)->cdr);
#line 310
  n = (int )s___0->length;
#line 313
  i = 0;
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 313
    if (! inner) {
#line 313
      goto while_break;
    }
#line 314
    tmp = i;
#line 314
    i ++;
#line 314
    if ((s___0->frames + tmp)->proc == inner_key) {
#line 315
      goto while_break;
    }
#line 313
    inner --;
  }
  while_break: /* CIL Label */ ;
  }
#line 316
  s___0->frames += i;
#line 317
  n -= i;
  {
#line 320
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 320
    if (n) {
#line 320
      if (! outer) {
#line 320
        goto while_break___0;
      }
    } else {
#line 320
      goto while_break___0;
    }
#line 321
    n --;
#line 321
    if ((s___0->frames + n)->proc == outer_key) {
#line 322
      goto while_break___0;
    }
#line 320
    outer --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 324
  s___0->length = (unsigned int )n;
#line 325
  return;
}
}
#line 334 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.c"
static char s_stack_p[7]  = {      (char )'s',      (char )'t',      (char )'a',      (char )'c', 
        (char )'k',      (char )'?',      (char )'\000'};
#line 335 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.c"
SCM scm_stack_p(SCM obj ) 
{ 
  long tmp ;

  {
#line 339
  if (! (6 & (int )obj)) {
#line 339
    if ((7 & (int )((scm_cell *)obj)->car) == 1) {
#line 339
      if (*((SCM *)(((scm_cell *)obj)->car - 1L) + 2) == scm_stack_type) {
#line 339
        tmp = (long )(17 << 9) + 372L;
      } else {
#line 339
        tmp = (long )(16 << 9) + 372L;
      }
    } else {
#line 339
      tmp = (long )(16 << 9) + 372L;
    }
  } else {
#line 339
    tmp = (long )(16 << 9) + 372L;
  }
#line 339
  return (tmp);
}
}
#line 342 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.c"
static char s_make_stack[11]  = 
#line 342
  {      (char )'m',      (char )'a',      (char )'k',      (char )'e', 
        (char )'-',      (char )'s',      (char )'t',      (char )'a', 
        (char )'c',      (char )'k',      (char )'\000'};
#line 343 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.c"
SCM scm_make_stack(SCM args ) 
{ 
  int n ;
  int maxp ;
  int size ;
  scm_debug_frame *dframe ;
  scm_info_frame *iframe ;
  long offset ;
  SCM stack ;
  SCM id ;
  SCM obj ;
  SCM inner_cut ;
  SCM outer_cut ;
  SCM tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  SCM tmp___2 ;

  {
#line 350
  offset = 0L;
#line 354
  if (! (6 & (int )args)) {
#line 354
    if (! (! (1 & (int )((scm_cell *)args)->car))) {
      {
#line 354
      scm_wta((SCM )8, (char *)args, s_make_stack);
      }
    }
  } else {
    {
#line 354
    scm_wta((SCM )8, (char *)args, s_make_stack);
    }
  }
#line 355
  obj = ((scm_cell *)args)->car;
#line 356
  args = ((scm_cell *)args)->cdr;
#line 360
  if (obj == (long )(17 << 9) + 372L) {
#line 361
    dframe = scm_last_debug_frame;
  } else {
#line 364
    if (! (! (6 & (int )obj))) {
      {
#line 364
      scm_wta(obj, (char *)1, s_make_stack);
      }
    }
#line 365
    if (scm_tc16_debugobj == (long )(65535 & (int )((scm_cell *)obj)->car)) {
#line 366
      dframe = (scm_debug_frame *)((scm_cell *)obj)->cdr;
    } else
#line 367
    if (61 == (127 & (int )((scm_cell *)obj)->car)) {
#line 369
      offset = (SCM_STACKITEM *)((char *)((scm_cell *)obj)->cdr + sizeof(scm_contregs )) - ((scm_contregs *)((char *)((scm_cell *)obj)->cdr))->base;
#line 372
      offset = (long )((unsigned long )offset + ((unsigned long )((scm_cell *)obj)->car >> 8));
#line 374
      dframe = (scm_debug_frame *)((SCM_STACKITEM *)((scm_contregs *)((char *)((scm_cell *)obj)->cdr))->dframe + offset);
    } else {
      {
#line 378
      scm_wta(obj, (char *)1, s_make_stack);
#line 379
      abort();
      }
    }
  }
  {
#line 386
  id = (long )(16 << 9) + 372L;
#line 387
  maxp = 0;
#line 388
  n = stack_depth(dframe, offset, & id, & maxp);
#line 389
  size = (int )((unsigned long )n * (sizeof(scm_info_frame ) / sizeof(SCM )));
#line 392
  stack = scm_make_struct(scm_stack_type, (long )(size << 2) + 2L, (long )(20 << 9) + 372L);
#line 393
  ((scm_stack *)((SCM *)((scm_cell *)stack)->cdr))->id = id;
#line 394
  ((scm_stack *)((SCM *)((scm_cell *)stack)->cdr))->length = (unsigned int )n;
#line 395
  iframe = & ((scm_stack *)((SCM *)((scm_cell *)stack)->cdr))->tail[0];
#line 396
  ((scm_stack *)((SCM *)((scm_cell *)stack)->cdr))->frames = iframe;
#line 399
  read_frames((scm_debug_frame *)((SCM_STACKITEM *)dframe + offset), offset, n, iframe);
  }
  {
#line 402
  while (1) {
    while_continue: /* CIL Label */ ;
#line 402
    if (n > 0) {
#line 402
      if (! (6 & (int )args)) {
#line 402
        if (! (! (1 & (int )((scm_cell *)args)->car))) {
#line 402
          goto while_break;
        }
      } else {
#line 402
        goto while_break;
      }
    } else {
#line 402
      goto while_break;
    }
#line 404
    inner_cut = ((scm_cell *)args)->car;
#line 405
    args = ((scm_cell *)args)->cdr;
#line 406
    if (! (6 & (int )args)) {
#line 406
      if (! (1 & (int )((scm_cell *)args)->car)) {
#line 408
        outer_cut = ((scm_cell *)args)->car;
#line 409
        args = ((scm_cell *)args)->cdr;
      } else {
#line 412
        outer_cut = (SCM )2;
      }
    } else {
#line 412
      outer_cut = (SCM )2;
    }
#line 414
    if (2 & (int )outer_cut) {
#line 414
      tmp = (SCM )0;
    } else {
#line 414
      tmp = outer_cut;
    }
#line 414
    if (2 & (int )outer_cut) {
#line 414
      tmp___0 = outer_cut >> 2;
    } else {
#line 414
      tmp___0 = (SCM )n;
    }
#line 414
    if (2 & (int )inner_cut) {
#line 414
      tmp___1 = (SCM )0;
    } else {
#line 414
      tmp___1 = inner_cut;
    }
#line 414
    if (2 & (int )inner_cut) {
#line 414
      tmp___2 = inner_cut >> 2;
    } else {
#line 414
      tmp___2 = (SCM )n;
    }
    {
#line 414
    narrow_stack(stack, (int )tmp___2, tmp___1, (int )tmp___0, tmp);
#line 420
    n = (int )((scm_stack *)((SCM *)((scm_cell *)stack)->cdr))->length;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 423
  if (n > 0) {
#line 425
    if (maxp) {
#line 426
      (iframe + (n - 1))->flags |= 1L << 6;
    }
#line 427
    return (stack);
  } else {
#line 430
    return ((long )(16 << 9) + 372L);
  }
}
}
#line 433 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.c"
static char s_stack_id[9]  = 
#line 433
  {      (char )'s',      (char )'t',      (char )'a',      (char )'c', 
        (char )'k',      (char )'-',      (char )'i',      (char )'d', 
        (char )'\000'};
#line 434 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.c"
SCM scm_stack_id(SCM stack ) 
{ 
  scm_debug_frame *dframe ;
  long offset ;

  {
#line 439
  offset = 0L;
#line 440
  if (stack == (long )(17 << 9) + 372L) {
#line 441
    dframe = scm_last_debug_frame;
  } else {
#line 444
    if (! (! (6 & (int )stack))) {
      {
#line 444
      scm_wta(stack, (char *)1, s_make_stack);
      }
    }
#line 445
    if (scm_tc16_debugobj == (long )(65535 & (int )((scm_cell *)stack)->car)) {
#line 446
      dframe = (scm_debug_frame *)((scm_cell *)stack)->cdr;
    } else
#line 447
    if (61 == (127 & (int )((scm_cell *)stack)->car)) {
#line 449
      offset = (SCM_STACKITEM *)((char *)((scm_cell *)stack)->cdr + sizeof(scm_contregs )) - ((scm_contregs *)((char *)((scm_cell *)stack)->cdr))->base;
#line 452
      offset = (long )((unsigned long )offset + ((unsigned long )((scm_cell *)stack)->car >> 8));
#line 454
      dframe = (scm_debug_frame *)((SCM_STACKITEM *)((scm_contregs *)((char *)((scm_cell *)stack)->cdr))->dframe + offset);
    } else
#line 456
    if ((7 & (int )((scm_cell *)stack)->car) == 1) {
#line 456
      if (*((SCM *)(((scm_cell *)stack)->car - 1L) + 2) == scm_stack_type) {
#line 457
        return (((scm_stack *)((SCM *)((scm_cell *)stack)->cdr))->id);
      } else {
        {
#line 458
        scm_wrong_type_arg(s_stack_id, 1, stack);
        }
      }
    } else {
      {
#line 458
      scm_wrong_type_arg(s_stack_id, 1, stack);
      }
    }
  }
  {
#line 460
  while (1) {
    while_continue: /* CIL Label */ ;
#line 460
    if (dframe) {
#line 460
      if (! (! ((dframe->status & (3L << 10)) == 2L << 10))) {
#line 460
        goto while_break;
      }
    } else {
#line 460
      goto while_break;
    }
#line 461
    dframe = (scm_debug_frame *)((SCM_STACKITEM *)dframe->prev + offset);
  }
  while_break: /* CIL Label */ ;
  }
#line 462
  if (dframe) {
#line 462
    if ((dframe->status & (3L << 10)) == 2L << 10) {
#line 463
      return ((dframe->vect + 0)->id);
    }
  }
#line 464
  return ((long )(16 << 9) + 372L);
}
}
#line 467 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.c"
static char s_stack_ref[10]  = 
#line 467
  {      (char )'s',      (char )'t',      (char )'a',      (char )'c', 
        (char )'k',      (char )'-',      (char )'r',      (char )'e', 
        (char )'f',      (char )'\000'};
#line 468 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.c"
SCM scm_stack_ref(SCM stack , SCM i ) 
{ 
  SCM tmp ;

  {
#line 473
  if (! (6 & (int )stack)) {
#line 473
    if ((7 & (int )((scm_cell *)stack)->car) == 1) {
#line 473
      if (! (*((SCM *)(((scm_cell *)stack)->car - 1L) + 2) == scm_stack_type)) {
        {
#line 473
        scm_wta(stack, (char *)1, s_stack_ref);
        }
      }
    } else {
      {
#line 473
      scm_wta(stack, (char *)1, s_stack_ref);
      }
    }
  } else {
    {
#line 473
    scm_wta(stack, (char *)1, s_stack_ref);
    }
  }
#line 478
  if (! (2 & (int )i)) {
    {
#line 478
    scm_wta(i, (char *)2, s_stack_ref);
    }
  }
#line 479
  if (i >> 2 >= 0L) {
#line 479
    if (! (i >> 2 < (SCM )((scm_stack *)((SCM *)((scm_cell *)stack)->cdr))->length)) {
      {
#line 479
      scm_wta(i, (char *)10, s_stack_ref);
      }
    }
  } else {
    {
#line 479
    scm_wta(i, (char *)10, s_stack_ref);
    }
  }
  {
#line 484
  tmp = scm_cons(stack, i);
  }
#line 484
  return (tmp);
}
}
#line 487 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.c"
static char s_stack_length[13]  = 
#line 487
  {      (char )'s',      (char )'t',      (char )'a',      (char )'c', 
        (char )'k',      (char )'-',      (char )'l',      (char )'e', 
        (char )'n',      (char )'g',      (char )'t',      (char )'h', 
        (char )'\000'};
#line 488 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.c"
SCM scm_stack_length(SCM stack ) 
{ 


  {
#line 492
  if (! (6 & (int )stack)) {
#line 492
    if ((7 & (int )((scm_cell *)stack)->car) == 1) {
#line 492
      if (! (*((SCM *)(((scm_cell *)stack)->car - 1L) + 2) == scm_stack_type)) {
        {
#line 492
        scm_wta(stack, (char *)1, s_stack_length);
        }
      }
    } else {
      {
#line 492
      scm_wta(stack, (char *)1, s_stack_length);
      }
    }
  } else {
    {
#line 492
    scm_wta(stack, (char *)1, s_stack_length);
    }
  }
#line 497
  return ((long )(((scm_stack *)((SCM *)((scm_cell *)stack)->cdr))->length << 2) + 2L);
}
}
#line 503 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.c"
static char s_frame_p[7]  = {      (char )'f',      (char )'r',      (char )'a',      (char )'m', 
        (char )'e',      (char )'?',      (char )'\000'};
#line 504 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.c"
SCM scm_frame_p(SCM obj ) 
{ 
  int tmp ;

  {
#line 508
  if (! (6 & (int )obj)) {
#line 508
    if (! (1 & (int )((scm_cell *)obj)->car)) {
#line 508
      if (! (6 & (int )((scm_cell *)obj)->car)) {
#line 508
        if ((7 & (int )((scm_cell *)((scm_cell *)obj)->car)->car) == 1) {
#line 508
          if (*((SCM *)(((scm_cell *)((scm_cell *)obj)->car)->car - 1L) + 2) == scm_stack_type) {
#line 508
            if (2 & (int )((scm_cell *)obj)->cdr) {
#line 508
              tmp = 1;
            } else {
#line 508
              tmp = 0;
            }
          } else {
#line 508
            tmp = 0;
          }
        } else {
#line 508
          tmp = 0;
        }
      } else {
#line 508
        tmp = 0;
      }
    } else {
#line 508
      tmp = 0;
    }
  } else {
#line 508
    tmp = 0;
  }
#line 508
  return ((SCM )tmp);
}
}
#line 511 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.c"
static char s_last_stack_frame[17]  = 
#line 511
  {      (char )'l',      (char )'a',      (char )'s',      (char )'t', 
        (char )'-',      (char )'s',      (char )'t',      (char )'a', 
        (char )'c',      (char )'k',      (char )'-',      (char )'f', 
        (char )'r',      (char )'a',      (char )'m',      (char )'e', 
        (char )'\000'};
#line 512 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.c"
SCM scm_last_stack_frame(SCM obj ) 
{ 
  scm_debug_frame *dframe ;
  long offset ;
  SCM stack ;
  SCM tmp ;

  {
#line 517
  offset = 0L;
#line 520
  if (! (! (6 & (int )obj))) {
    {
#line 520
    scm_wta(obj, (char *)1, s_last_stack_frame);
    }
  }
#line 521
  if (scm_tc16_debugobj == (long )(65535 & (int )((scm_cell *)obj)->car)) {
#line 522
    dframe = (scm_debug_frame *)((scm_cell *)obj)->cdr;
  } else
#line 523
  if (61 == (127 & (int )((scm_cell *)obj)->car)) {
#line 525
    offset = (SCM_STACKITEM *)((char *)((scm_cell *)obj)->cdr + sizeof(scm_contregs )) - ((scm_contregs *)((char *)((scm_cell *)obj)->cdr))->base;
#line 528
    offset = (long )((unsigned long )offset + ((unsigned long )((scm_cell *)obj)->car >> 8));
#line 530
    dframe = (scm_debug_frame *)((SCM_STACKITEM *)((scm_contregs *)((char *)((scm_cell *)obj)->cdr))->dframe + offset);
  } else {
    {
#line 534
    scm_wta(obj, (char *)1, s_last_stack_frame);
#line 535
    abort();
    }
  }
#line 538
  if (! dframe) {
#line 539
    return ((long )(16 << 9) + 372L);
  } else
#line 538
  if ((dframe->status & (3L << 10)) == 2L << 10) {
#line 539
    return ((long )(16 << 9) + 372L);
  }
  {
#line 541
  stack = scm_make_struct(scm_stack_type, (SCM )((sizeof(scm_info_frame ) / sizeof(SCM ) << 2) + 2UL),
                          (long )(20 << 9) + 372L);
#line 543
  ((scm_stack *)((SCM *)((scm_cell *)stack)->cdr))->length = 1U;
#line 544
  ((scm_stack *)((SCM *)((scm_cell *)stack)->cdr))->frames = & ((scm_stack *)((SCM *)((scm_cell *)stack)->cdr))->tail[0];
#line 545
  read_frame(dframe, offset, ((scm_stack *)((SCM *)((scm_cell *)stack)->cdr))->frames + 0);
#line 548
  tmp = scm_cons(stack, (SCM )2);
  }
#line 548
  return (tmp);
}
}
#line 551 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.c"
static char s_frame_number[13]  = 
#line 551
  {      (char )'f',      (char )'r',      (char )'a',      (char )'m', 
        (char )'e',      (char )'-',      (char )'n',      (char )'u', 
        (char )'m',      (char )'b',      (char )'e',      (char )'r', 
        (char )'\000'};
#line 552 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.c"
SCM scm_frame_number(SCM frame ) 
{ 
  SCM tmp ;

  {
#line 556
  if (! (6 & (int )frame)) {
#line 556
    if (! (1 & (int )((scm_cell *)frame)->car)) {
#line 556
      if (! (6 & (int )((scm_cell *)frame)->car)) {
#line 556
        if ((7 & (int )((scm_cell *)((scm_cell *)frame)->car)->car) == 1) {
#line 556
          if (*((SCM *)(((scm_cell *)((scm_cell *)frame)->car)->car - 1L) + 2) == scm_stack_type) {
#line 556
            if (! (2 & (int )((scm_cell *)frame)->cdr)) {
              {
#line 556
              scm_wta(frame, (char *)1, s_frame_number);
              }
            }
          } else {
            {
#line 556
            scm_wta(frame, (char *)1, s_frame_number);
            }
          }
        } else {
          {
#line 556
          scm_wta(frame, (char *)1, s_frame_number);
          }
        }
      } else {
        {
#line 556
        scm_wta(frame, (char *)1, s_frame_number);
        }
      }
    } else {
      {
#line 556
      scm_wta(frame, (char *)1, s_frame_number);
      }
    }
  } else {
    {
#line 556
    scm_wta(frame, (char *)1, s_frame_number);
    }
  }
#line 560
  if (scm_debug_opts[4].val) {
#line 560
    tmp = ((scm_cell *)frame)->cdr >> 2;
  } else {
#line 560
    tmp = ((SCM )((scm_stack *)((SCM *)((scm_cell *)((scm_cell *)frame)->car)->cdr))->length - (((scm_cell *)frame)->cdr >> 2)) - 1L;
  }
#line 560
  return ((tmp << 2) + 2L);
}
}
#line 563 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.c"
static char s_frame_source[13]  = 
#line 563
  {      (char )'f',      (char )'r',      (char )'a',      (char )'m', 
        (char )'e',      (char )'-',      (char )'s',      (char )'o', 
        (char )'u',      (char )'r',      (char )'c',      (char )'e', 
        (char )'\000'};
#line 564 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.c"
SCM scm_frame_source(SCM frame ) 
{ 


  {
#line 568
  if (! (6 & (int )frame)) {
#line 568
    if (! (1 & (int )((scm_cell *)frame)->car)) {
#line 568
      if (! (6 & (int )((scm_cell *)frame)->car)) {
#line 568
        if ((7 & (int )((scm_cell *)((scm_cell *)frame)->car)->car) == 1) {
#line 568
          if (*((SCM *)(((scm_cell *)((scm_cell *)frame)->car)->car - 1L) + 2) == scm_stack_type) {
#line 568
            if (! (2 & (int )((scm_cell *)frame)->cdr)) {
              {
#line 568
              scm_wta(frame, (char *)1, s_frame_source);
              }
            }
          } else {
            {
#line 568
            scm_wta(frame, (char *)1, s_frame_source);
            }
          }
        } else {
          {
#line 568
          scm_wta(frame, (char *)1, s_frame_source);
          }
        }
      } else {
        {
#line 568
        scm_wta(frame, (char *)1, s_frame_source);
        }
      }
    } else {
      {
#line 568
      scm_wta(frame, (char *)1, s_frame_source);
      }
    }
  } else {
    {
#line 568
    scm_wta(frame, (char *)1, s_frame_source);
    }
  }
#line 572
  return ((((scm_stack *)((SCM *)((scm_cell *)((scm_cell *)frame)->car)->cdr))->frames + (((scm_cell *)frame)->cdr >> 2))->source);
}
}
#line 575 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.c"
static char s_frame_procedure[16]  = 
#line 575
  {      (char )'f',      (char )'r',      (char )'a',      (char )'m', 
        (char )'e',      (char )'-',      (char )'p',      (char )'r', 
        (char )'o',      (char )'c',      (char )'e',      (char )'d', 
        (char )'u',      (char )'r',      (char )'e',      (char )'\000'};
#line 576 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.c"
SCM scm_frame_procedure(SCM frame ) 
{ 
  long tmp ;

  {
#line 580
  if (! (6 & (int )frame)) {
#line 580
    if (! (1 & (int )((scm_cell *)frame)->car)) {
#line 580
      if (! (6 & (int )((scm_cell *)frame)->car)) {
#line 580
        if ((7 & (int )((scm_cell *)((scm_cell *)frame)->car)->car) == 1) {
#line 580
          if (*((SCM *)(((scm_cell *)((scm_cell *)frame)->car)->car - 1L) + 2) == scm_stack_type) {
#line 580
            if (! (2 & (int )((scm_cell *)frame)->cdr)) {
              {
#line 580
              scm_wta(frame, (char *)1, s_frame_procedure);
              }
            }
          } else {
            {
#line 580
            scm_wta(frame, (char *)1, s_frame_procedure);
            }
          }
        } else {
          {
#line 580
          scm_wta(frame, (char *)1, s_frame_procedure);
          }
        }
      } else {
        {
#line 580
        scm_wta(frame, (char *)1, s_frame_procedure);
        }
      }
    } else {
      {
#line 580
      scm_wta(frame, (char *)1, s_frame_procedure);
      }
    }
  } else {
    {
#line 580
    scm_wta(frame, (char *)1, s_frame_procedure);
    }
  }
#line 584
  if ((((scm_stack *)((SCM *)((scm_cell *)((scm_cell *)frame)->car)->cdr))->frames + (((scm_cell *)frame)->cdr >> 2))->flags & (1L << 4)) {
#line 584
    tmp = (long )(16 << 9) + 372L;
  } else {
#line 584
    tmp = (((scm_stack *)((SCM *)((scm_cell *)((scm_cell *)frame)->car)->cdr))->frames + (((scm_cell *)frame)->cdr >> 2))->proc;
  }
#line 584
  return (tmp);
}
}
#line 589 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.c"
static char s_frame_arguments[16]  = 
#line 589
  {      (char )'f',      (char )'r',      (char )'a',      (char )'m', 
        (char )'e',      (char )'-',      (char )'a',      (char )'r', 
        (char )'g',      (char )'u',      (char )'m',      (char )'e', 
        (char )'n',      (char )'t',      (char )'s',      (char )'\000'};
#line 590 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.c"
SCM scm_frame_arguments(SCM frame ) 
{ 


  {
#line 594
  if (! (6 & (int )frame)) {
#line 594
    if (! (1 & (int )((scm_cell *)frame)->car)) {
#line 594
      if (! (6 & (int )((scm_cell *)frame)->car)) {
#line 594
        if ((7 & (int )((scm_cell *)((scm_cell *)frame)->car)->car) == 1) {
#line 594
          if (*((SCM *)(((scm_cell *)((scm_cell *)frame)->car)->car - 1L) + 2) == scm_stack_type) {
#line 594
            if (! (2 & (int )((scm_cell *)frame)->cdr)) {
              {
#line 594
              scm_wta(frame, (char *)1, s_frame_arguments);
              }
            }
          } else {
            {
#line 594
            scm_wta(frame, (char *)1, s_frame_arguments);
            }
          }
        } else {
          {
#line 594
          scm_wta(frame, (char *)1, s_frame_arguments);
          }
        }
      } else {
        {
#line 594
        scm_wta(frame, (char *)1, s_frame_arguments);
        }
      }
    } else {
      {
#line 594
      scm_wta(frame, (char *)1, s_frame_arguments);
      }
    }
  } else {
    {
#line 594
    scm_wta(frame, (char *)1, s_frame_arguments);
    }
  }
#line 598
  return ((((scm_stack *)((SCM *)((scm_cell *)((scm_cell *)frame)->car)->cdr))->frames + (((scm_cell *)frame)->cdr >> 2))->args);
}
}
#line 601 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.c"
static char s_frame_previous[15]  = 
#line 601
  {      (char )'f',      (char )'r',      (char )'a',      (char )'m', 
        (char )'e',      (char )'-',      (char )'p',      (char )'r', 
        (char )'e',      (char )'v',      (char )'i',      (char )'o', 
        (char )'u',      (char )'s',      (char )'\000'};
#line 602 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.c"
SCM scm_frame_previous(SCM frame ) 
{ 
  int n ;
  SCM tmp ;

  {
#line 607
  if (! (6 & (int )frame)) {
#line 607
    if (! (1 & (int )((scm_cell *)frame)->car)) {
#line 607
      if (! (6 & (int )((scm_cell *)frame)->car)) {
#line 607
        if ((7 & (int )((scm_cell *)((scm_cell *)frame)->car)->car) == 1) {
#line 607
          if (*((SCM *)(((scm_cell *)((scm_cell *)frame)->car)->car - 1L) + 2) == scm_stack_type) {
#line 607
            if (! (2 & (int )((scm_cell *)frame)->cdr)) {
              {
#line 607
              scm_wta(frame, (char *)1, s_frame_previous);
              }
            }
          } else {
            {
#line 607
            scm_wta(frame, (char *)1, s_frame_previous);
            }
          }
        } else {
          {
#line 607
          scm_wta(frame, (char *)1, s_frame_previous);
          }
        }
      } else {
        {
#line 607
        scm_wta(frame, (char *)1, s_frame_previous);
        }
      }
    } else {
      {
#line 607
      scm_wta(frame, (char *)1, s_frame_previous);
      }
    }
  } else {
    {
#line 607
    scm_wta(frame, (char *)1, s_frame_previous);
    }
  }
#line 611
  n = (int )((((scm_cell *)frame)->cdr >> 2) + 1L);
#line 612
  if ((unsigned int )n >= ((scm_stack *)((SCM *)((scm_cell *)((scm_cell *)frame)->car)->cdr))->length) {
#line 613
    return ((long )(16 << 9) + 372L);
  } else {
    {
#line 615
    tmp = scm_cons(((scm_cell *)frame)->car, (long )(n << 2) + 2L);
    }
#line 615
    return (tmp);
  }
}
}
#line 618 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.c"
static char s_frame_next[11]  = 
#line 618
  {      (char )'f',      (char )'r',      (char )'a',      (char )'m', 
        (char )'e',      (char )'-',      (char )'n',      (char )'e', 
        (char )'x',      (char )'t',      (char )'\000'};
#line 619 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.c"
SCM scm_frame_next(SCM frame ) 
{ 
  int n ;
  SCM tmp ;

  {
#line 624
  if (! (6 & (int )frame)) {
#line 624
    if (! (1 & (int )((scm_cell *)frame)->car)) {
#line 624
      if (! (6 & (int )((scm_cell *)frame)->car)) {
#line 624
        if ((7 & (int )((scm_cell *)((scm_cell *)frame)->car)->car) == 1) {
#line 624
          if (*((SCM *)(((scm_cell *)((scm_cell *)frame)->car)->car - 1L) + 2) == scm_stack_type) {
#line 624
            if (! (2 & (int )((scm_cell *)frame)->cdr)) {
              {
#line 624
              scm_wta(frame, (char *)1, s_frame_next);
              }
            }
          } else {
            {
#line 624
            scm_wta(frame, (char *)1, s_frame_next);
            }
          }
        } else {
          {
#line 624
          scm_wta(frame, (char *)1, s_frame_next);
          }
        }
      } else {
        {
#line 624
        scm_wta(frame, (char *)1, s_frame_next);
        }
      }
    } else {
      {
#line 624
      scm_wta(frame, (char *)1, s_frame_next);
      }
    }
  } else {
    {
#line 624
    scm_wta(frame, (char *)1, s_frame_next);
    }
  }
#line 628
  n = (int )((((scm_cell *)frame)->cdr >> 2) - 1L);
#line 629
  if (n < 0) {
#line 630
    return ((long )(16 << 9) + 372L);
  } else {
    {
#line 632
    tmp = scm_cons(((scm_cell *)frame)->car, (long )(n << 2) + 2L);
    }
#line 632
    return (tmp);
  }
}
}
#line 635 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.c"
static char s_frame_real_p[12]  = 
#line 635
  {      (char )'f',      (char )'r',      (char )'a',      (char )'m', 
        (char )'e',      (char )'-',      (char )'r',      (char )'e', 
        (char )'a',      (char )'l',      (char )'?',      (char )'\000'};
#line 636 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.c"
SCM scm_frame_real_p(SCM frame ) 
{ 
  long tmp ;

  {
#line 640
  if (! (6 & (int )frame)) {
#line 640
    if (! (1 & (int )((scm_cell *)frame)->car)) {
#line 640
      if (! (6 & (int )((scm_cell *)frame)->car)) {
#line 640
        if ((7 & (int )((scm_cell *)((scm_cell *)frame)->car)->car) == 1) {
#line 640
          if (*((SCM *)(((scm_cell *)((scm_cell *)frame)->car)->car - 1L) + 2) == scm_stack_type) {
#line 640
            if (! (2 & (int )((scm_cell *)frame)->cdr)) {
              {
#line 640
              scm_wta(frame, (char *)1, s_frame_real_p);
              }
            }
          } else {
            {
#line 640
            scm_wta(frame, (char *)1, s_frame_real_p);
            }
          }
        } else {
          {
#line 640
          scm_wta(frame, (char *)1, s_frame_real_p);
          }
        }
      } else {
        {
#line 640
        scm_wta(frame, (char *)1, s_frame_real_p);
        }
      }
    } else {
      {
#line 640
      scm_wta(frame, (char *)1, s_frame_real_p);
      }
    }
  } else {
    {
#line 640
    scm_wta(frame, (char *)1, s_frame_real_p);
    }
  }
#line 644
  if ((((scm_stack *)((SCM *)((scm_cell *)((scm_cell *)frame)->car)->cdr))->frames + (((scm_cell *)frame)->cdr >> 2))->flags & (1L << 3)) {
#line 644
    tmp = (long )(17 << 9) + 372L;
  } else {
#line 644
    tmp = (long )(16 << 9) + 372L;
  }
#line 644
  return (tmp);
}
}
#line 647 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.c"
static char s_frame_procedure_p[17]  = 
#line 647
  {      (char )'f',      (char )'r',      (char )'a',      (char )'m', 
        (char )'e',      (char )'-',      (char )'p',      (char )'r', 
        (char )'o',      (char )'c',      (char )'e',      (char )'d', 
        (char )'u',      (char )'r',      (char )'e',      (char )'?', 
        (char )'\000'};
#line 648 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.c"
SCM scm_frame_procedure_p(SCM frame ) 
{ 
  long tmp ;

  {
#line 652
  if (! (6 & (int )frame)) {
#line 652
    if (! (1 & (int )((scm_cell *)frame)->car)) {
#line 652
      if (! (6 & (int )((scm_cell *)frame)->car)) {
#line 652
        if ((7 & (int )((scm_cell *)((scm_cell *)frame)->car)->car) == 1) {
#line 652
          if (*((SCM *)(((scm_cell *)((scm_cell *)frame)->car)->car - 1L) + 2) == scm_stack_type) {
#line 652
            if (! (2 & (int )((scm_cell *)frame)->cdr)) {
              {
#line 652
              scm_wta(frame, (char *)1, s_frame_procedure_p);
              }
            }
          } else {
            {
#line 652
            scm_wta(frame, (char *)1, s_frame_procedure_p);
            }
          }
        } else {
          {
#line 652
          scm_wta(frame, (char *)1, s_frame_procedure_p);
          }
        }
      } else {
        {
#line 652
        scm_wta(frame, (char *)1, s_frame_procedure_p);
        }
      }
    } else {
      {
#line 652
      scm_wta(frame, (char *)1, s_frame_procedure_p);
      }
    }
  } else {
    {
#line 652
    scm_wta(frame, (char *)1, s_frame_procedure_p);
    }
  }
#line 656
  if ((((scm_stack *)((SCM *)((scm_cell *)((scm_cell *)frame)->car)->cdr))->frames + (((scm_cell *)frame)->cdr >> 2))->flags & (1L << 4)) {
#line 656
    tmp = (long )(17 << 9) + 372L;
  } else {
#line 656
    tmp = (long )(16 << 9) + 372L;
  }
#line 656
  return (tmp);
}
}
#line 659 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.c"
static char s_frame_evaluating_args_p[23]  = 
#line 659
  {      (char )'f',      (char )'r',      (char )'a',      (char )'m', 
        (char )'e',      (char )'-',      (char )'e',      (char )'v', 
        (char )'a',      (char )'l',      (char )'u',      (char )'a', 
        (char )'t',      (char )'i',      (char )'n',      (char )'g', 
        (char )'-',      (char )'a',      (char )'r',      (char )'g', 
        (char )'s',      (char )'?',      (char )'\000'};
#line 660 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.c"
SCM scm_frame_evaluating_args_p(SCM frame ) 
{ 
  long tmp ;

  {
#line 664
  if (! (6 & (int )frame)) {
#line 664
    if (! (1 & (int )((scm_cell *)frame)->car)) {
#line 664
      if (! (6 & (int )((scm_cell *)frame)->car)) {
#line 664
        if ((7 & (int )((scm_cell *)((scm_cell *)frame)->car)->car) == 1) {
#line 664
          if (*((SCM *)(((scm_cell *)((scm_cell *)frame)->car)->car - 1L) + 2) == scm_stack_type) {
#line 664
            if (! (2 & (int )((scm_cell *)frame)->cdr)) {
              {
#line 664
              scm_wta(frame, (char *)1, s_frame_evaluating_args_p);
              }
            }
          } else {
            {
#line 664
            scm_wta(frame, (char *)1, s_frame_evaluating_args_p);
            }
          }
        } else {
          {
#line 664
          scm_wta(frame, (char *)1, s_frame_evaluating_args_p);
          }
        }
      } else {
        {
#line 664
        scm_wta(frame, (char *)1, s_frame_evaluating_args_p);
        }
      }
    } else {
      {
#line 664
      scm_wta(frame, (char *)1, s_frame_evaluating_args_p);
      }
    }
  } else {
    {
#line 664
    scm_wta(frame, (char *)1, s_frame_evaluating_args_p);
    }
  }
#line 668
  if ((((scm_stack *)((SCM *)((scm_cell *)((scm_cell *)frame)->car)->cdr))->frames + (((scm_cell *)frame)->cdr >> 2))->flags & (1L << 5)) {
#line 668
    tmp = (long )(17 << 9) + 372L;
  } else {
#line 668
    tmp = (long )(16 << 9) + 372L;
  }
#line 668
  return (tmp);
}
}
#line 671 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.c"
static char s_frame_overflow_p[16]  = 
#line 671
  {      (char )'f',      (char )'r',      (char )'a',      (char )'m', 
        (char )'e',      (char )'-',      (char )'o',      (char )'v', 
        (char )'e',      (char )'r',      (char )'f',      (char )'l', 
        (char )'o',      (char )'w',      (char )'?',      (char )'\000'};
#line 672 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.c"
SCM scm_frame_overflow_p(SCM frame ) 
{ 
  long tmp ;

  {
#line 676
  if (! (6 & (int )frame)) {
#line 676
    if (! (1 & (int )((scm_cell *)frame)->car)) {
#line 676
      if (! (6 & (int )((scm_cell *)frame)->car)) {
#line 676
        if ((7 & (int )((scm_cell *)((scm_cell *)frame)->car)->car) == 1) {
#line 676
          if (*((SCM *)(((scm_cell *)((scm_cell *)frame)->car)->car - 1L) + 2) == scm_stack_type) {
#line 676
            if (! (2 & (int )((scm_cell *)frame)->cdr)) {
              {
#line 676
              scm_wta(frame, (char *)1, s_frame_overflow_p);
              }
            }
          } else {
            {
#line 676
            scm_wta(frame, (char *)1, s_frame_overflow_p);
            }
          }
        } else {
          {
#line 676
          scm_wta(frame, (char *)1, s_frame_overflow_p);
          }
        }
      } else {
        {
#line 676
        scm_wta(frame, (char *)1, s_frame_overflow_p);
        }
      }
    } else {
      {
#line 676
      scm_wta(frame, (char *)1, s_frame_overflow_p);
      }
    }
  } else {
    {
#line 676
    scm_wta(frame, (char *)1, s_frame_overflow_p);
    }
  }
#line 680
  if ((((scm_stack *)((SCM *)((scm_cell *)((scm_cell *)frame)->car)->cdr))->frames + (((scm_cell *)frame)->cdr >> 2))->flags & (1L << 6)) {
#line 680
    tmp = (long )(17 << 9) + 372L;
  } else {
#line 680
    tmp = (long )(16 << 9) + 372L;
  }
#line 680
  return (tmp);
}
}
#line 685 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.c"
void scm_init_stacks(void) 
{ 
  SCM vtable ;
  SCM vtable_layout ;
  SCM tmp ;
  SCM stack_layout ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  SCM tmp___2 ;
  SCM tmp___3 ;
  char *__cil_tmp9 ;

  {
  {
#line 689
  tmp = scm_make_struct_layout(scm_sys_protects[4]);
#line 689
  vtable_layout = tmp;
#line 690
  tmp___0 = scm_makfrom0str("pwuourpW");
#line 690
  tmp___1 = scm_make_struct_layout(tmp___0);
#line 690
  stack_layout = tmp___1;
#line 692
  vtable = scm_make_vtable_vtable(vtable_layout, (SCM )2, (long )(20 << 9) + 372L);
#line 693
  tmp___2 = scm_cons(stack_layout, (long )(20 << 9) + 372L);
#line 693
  tmp___3 = scm_make_struct(vtable, (SCM )2, tmp___2);
#line 693
  scm_stack_type = scm_permanent_object(tmp___3);
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.x"
  scm_make_gsubr(s_stack_p, 1, 0, 0, (SCM (*)())(& scm_stack_p));
#line 2
  scm_make_gsubr(s_make_stack, 0, 0, 1, (SCM (*)())(& scm_make_stack));
#line 3
  scm_make_gsubr(s_stack_id, 1, 0, 0, (SCM (*)())(& scm_stack_id));
#line 4
  scm_make_gsubr(s_stack_ref, 2, 0, 0, (SCM (*)())(& scm_stack_ref));
#line 5
  scm_make_gsubr(s_stack_length, 1, 0, 0, (SCM (*)())(& scm_stack_length));
#line 6
  scm_make_gsubr(s_frame_p, 1, 0, 0, (SCM (*)())(& scm_frame_p));
#line 7
  scm_make_gsubr(s_last_stack_frame, 1, 0, 0, (SCM (*)())(& scm_last_stack_frame));
#line 8
  scm_make_gsubr(s_frame_number, 1, 0, 0, (SCM (*)())(& scm_frame_number));
#line 9
  scm_make_gsubr(s_frame_source, 1, 0, 0, (SCM (*)())(& scm_frame_source));
#line 10
  scm_make_gsubr(s_frame_procedure, 1, 0, 0, (SCM (*)())(& scm_frame_procedure));
#line 11
  scm_make_gsubr(s_frame_arguments, 1, 0, 0, (SCM (*)())(& scm_frame_arguments));
#line 12
  scm_make_gsubr(s_frame_previous, 1, 0, 0, (SCM (*)())(& scm_frame_previous));
#line 13
  scm_make_gsubr(s_frame_next, 1, 0, 0, (SCM (*)())(& scm_frame_next));
#line 14
  scm_make_gsubr(s_frame_real_p, 1, 0, 0, (SCM (*)())(& scm_frame_real_p));
#line 15
  scm_make_gsubr(s_frame_procedure_p, 1, 0, 0, (SCM (*)())(& scm_frame_procedure_p));
#line 16
  scm_make_gsubr(s_frame_evaluating_args_p, 1, 0, 0, (SCM (*)())(& scm_frame_evaluating_args_p));
#line 17
  scm_make_gsubr(s_frame_overflow_p, 1, 0, 0, (SCM (*)())(& scm_frame_overflow_p));
  }
#line 698 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stacks.c"
  return;
}
}
#line 83 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stackchk.h"
int scm_stack_checking_enabled_p  ;
#line 87
void scm_report_stack_overflow(void) ;
#line 88
long scm_stack_size(SCM_STACKITEM *start ) ;
#line 89
void scm_stack_report(void) ;
#line 90
void scm_init_stackchk(void) ;
#line 56 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stackchk.c"
static SCM scm_stack_overflow_key  =    (long )(16 << 9) + 372L;
#line 58 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stackchk.c"
void scm_report_stack_overflow(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
#line 61
  scm_stack_checking_enabled_p = 0;
#line 62
  scm_error(scm_stack_overflow_key, (char *)((void *)0), (char *)"Stack overflow",
            (long )(16 << 9) + 372L, (long )(16 << 9) + 372L);
  }
}
}
#line 71 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stackchk.c"
long scm_stack_size(SCM_STACKITEM *start ) 
{ 
  SCM_STACKITEM stack ;

  {
#line 79
  return (start - & stack);
}
}
#line 84 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stackchk.c"
void scm_stack_report(void) 
{ 
  SCM_STACKITEM stack ;
  long tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 88
  tmp = scm_stack_size(((scm_contregs *)((char *)((scm_cell *)scm_root->rootcont)->cdr))->base);
#line 88
  scm_intprint((long )((unsigned long )tmp * sizeof(SCM_STACKITEM )), 16, scm_root->cur_errp);
#line 90
  scm_gen_puts((enum scm_string_representation_type )0, (char *)" of stack: 0x", scm_root->cur_errp);
#line 91
  scm_intprint((long )((scm_contregs *)((char *)((scm_cell *)scm_root->rootcont)->cdr))->base,
               16, scm_root->cur_errp);
#line 92
  scm_gen_puts((enum scm_string_representation_type )0, (char *)" - 0x", scm_root->cur_errp);
#line 93
  scm_intprint((long )(& stack), 16, scm_root->cur_errp);
#line 94
  scm_gen_puts((enum scm_string_representation_type )0, (char *)"\n", scm_root->cur_errp);
  }
#line 95
  return;
}
}
#line 100 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stackchk.c"
void scm_init_stackchk(void) 
{ 
  SCM tmp ;
  char *__cil_tmp2 ;

  {
  {
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stackchk.x"
  tmp = scm_intern0((char *)"stack-overflow");
#line 1
  scm_stack_overflow_key = scm_permanent_object(((scm_cell *)tmp)->car);
  }
#line 104 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/stackchk.c"
  return;
}
}
#line 86 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.h"
void scm_gc_mark(SCM p ) ;
#line 175 "../libguile/debug.h"
long scm_tc16_memoized ;
#line 52 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/alist.h"
SCM scm_sloppy_assq(SCM x , SCM alist ) ;
#line 57
SCM scm_assoc(SCM x , SCM alist ) ;
#line 56 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.h"
SCM scm_hash_fn_get_handle(SCM table , SCM obj , unsigned int (*hash_fn)() , SCM (*assoc_fn)() ,
                           void *closure ) ;
#line 57
SCM scm_hash_fn_create_handle_x(SCM table , SCM obj , SCM init , unsigned int (*hash_fn)() ,
                                SCM (*assoc_fn)() , void *closure ) ;
#line 63
SCM scm_hashq_create_handle_x(SCM table , SCM obj , SCM init ) ;
#line 64
SCM scm_hashq_ref(SCM table , SCM obj , SCM dflt ) ;
#line 52 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hash.h"
unsigned int scm_ihashq(SCM obj , unsigned int n ) ;
#line 78 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/srcprop.h"
long scm_tc16_srcprops  ;
#line 116 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/srcprop.h"
SCM scm_i_filename  ;
#line 117 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/srcprop.h"
SCM scm_i_copy  ;
#line 118 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/srcprop.h"
SCM scm_i_line  ;
#line 119 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/srcprop.h"
SCM scm_i_column  ;
#line 120 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/srcprop.h"
SCM scm_i_breakpoint  ;
#line 125
SCM scm_srcprops_to_plist(SCM obj ) ;
#line 126
SCM scm_make_srcprops(int line , int col , SCM filename , SCM copy , SCM plist ) ;
#line 127
SCM scm_source_property(SCM obj , SCM key ) ;
#line 128
SCM scm_set_source_property_x(SCM obj , SCM key , SCM datum ) ;
#line 129
SCM scm_source_properties(SCM obj ) ;
#line 130
SCM scm_set_source_properties_x(SCM obj , SCM plist ) ;
#line 131
void scm_finish_srcprop(void) ;
#line 132
void scm_init_srcprop(void) ;
#line 79 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/srcprop.c"
static scm_srcprops_chunk *srcprops_chunklist  =    (scm_srcprops_chunk *)0;
#line 80 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/srcprop.c"
static scm_srcprops *srcprops_freelist  =    (scm_srcprops *)0;
#line 83
static SCM marksrcprops(SCM obj ) ;
#line 85 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/srcprop.c"
static SCM marksrcprops(SCM obj ) 
{ 


  {
  {
#line 89
  ((scm_cell *)obj)->car |= 128L;
#line 90
  scm_gc_mark(((scm_srcprops *)((scm_cell *)obj)->cdr)->fname);
#line 91
  scm_gc_mark(((scm_srcprops *)((scm_cell *)obj)->cdr)->copy);
  }
#line 92
  return (((scm_srcprops *)((scm_cell *)obj)->cdr)->plist);
}
}
#line 96
static size_t freesrcprops(SCM obj ) ;
#line 98 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/srcprop.c"
static size_t freesrcprops(SCM obj ) 
{ 


  {
#line 102
  *((scm_srcprops **)((scm_cell *)obj)->cdr) = srcprops_freelist;
#line 103
  srcprops_freelist = (scm_srcprops *)((scm_cell *)obj)->cdr;
#line 104
  return ((size_t )0);
}
}
#line 108
static int prinsrcprops(SCM obj , SCM port , scm_print_state *pstate ) ;
#line 110 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/srcprop.c"
static int prinsrcprops(SCM obj , SCM port , scm_print_state *pstate ) 
{ 
  int writingp ;
  SCM tmp ;
  char *__cil_tmp6 ;

  {
  {
#line 116
  writingp = (int )pstate->writingp;
#line 117
  scm_gen_puts((enum scm_string_representation_type )0, (char *)"#<srcprops ", port);
#line 118
  pstate->writingp = 1UL;
#line 119
  tmp = scm_srcprops_to_plist(obj);
#line 119
  scm_iprin1(tmp, port, pstate);
#line 120
  pstate->writingp = (unsigned long )writingp;
#line 121
  scm_gen_putc('>', port);
  }
#line 122
  return (1);
}
}
#line 125 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/srcprop.c"
static scm_smobfuns srcpropssmob  =    {& marksrcprops, & freesrcprops, & prinsrcprops, (SCM (*)(SCM  , SCM  ))0};
#line 129 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/srcprop.c"
SCM scm_make_srcprops(int line , int col , SCM filename , SCM copy , SCM plist ) 
{ 
  register SCM ans ;
  register scm_srcprops *ptr ;
  int i ;
  scm_srcprops_chunk *mem ;
  size_t n ;
  int *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *__cil_tmp14 ;

  {
#line 139
  scm_ints_disabled = 1;
#line 140
  ptr = srcprops_freelist;
#line 140
  if ((unsigned long )ptr != (unsigned long )((void *)0)) {
#line 141
    srcprops_freelist = *((scm_srcprops **)ptr);
  } else {
#line 146
    n = sizeof(scm_srcprops_chunk ) + sizeof(scm_srcprops ) * 2046UL;
    {
#line 148
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 148
      tmp = __errno_location();
#line 148
      *tmp = 0;
#line 148
      tmp___0 = malloc(n);
#line 148
      mem = (scm_srcprops_chunk *)tmp___0;
#line 148
      tmp___1 = __errno_location();
      }
#line 148
      if (! (4 == *tmp___1)) {
#line 148
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 149
    if (! mem) {
      {
#line 149
      scm_wta((long )(18 << 9) + 372L, (char *)11, (char *)"srcprops");
      }
    }
#line 150
    scm_mallocated += n;
#line 151
    mem->next = srcprops_chunklist;
#line 152
    srcprops_chunklist = mem;
#line 153
    ptr = & mem->srcprops[0];
#line 154
    i = 1;
    {
#line 154
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 154
      if (! (i < 2046)) {
#line 154
        goto while_break___0;
      }
#line 155
      *((scm_srcprops **)(ptr + i)) = ptr + (i + 1);
#line 154
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 156
    *((scm_srcprops **)(ptr + 2046)) = (scm_srcprops *)0;
#line 157
    srcprops_freelist = ptr + 1;
  }
#line 159
  if (6 & (int )scm_freelist) {
    {
#line 159
    ans = scm_gc_for_newcell();
    }
  } else {
#line 159
    ans = scm_freelist;
#line 159
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 159
    scm_cells_allocated ++;
  }
#line 160
  ((scm_cell *)ans)->car = scm_tc16_srcprops;
#line 161
  ptr->pos = (unsigned long )((line << 12) + col);
#line 162
  ptr->fname = filename;
#line 163
  ptr->copy = copy;
#line 164
  ptr->plist = plist;
#line 165
  ((scm_cell *)ans)->cdr = (SCM )ptr;
#line 166
  scm_ints_disabled = 0;
#line 166
  scm_async_clock --;
#line 166
  if (0U == scm_async_clock) {
    {
#line 166
    scm_async_click();
    }
  }
#line 167
  return (ans);
}
}
#line 171 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/srcprop.c"
SCM scm_srcprops_to_plist(SCM obj ) 
{ 
  SCM plist ;
  long tmp ;

  {
#line 175
  plist = ((scm_srcprops *)((scm_cell *)obj)->cdr)->plist;
#line 176
  if (! ((long )(18 << 9) + 372L == ((scm_srcprops *)((scm_cell *)obj)->cdr)->copy)) {
    {
#line 177
    plist = scm_acons(scm_i_copy, ((scm_srcprops *)((scm_cell *)obj)->cdr)->copy,
                      plist);
    }
  }
#line 178
  if (! ((long )(18 << 9) + 372L == ((scm_srcprops *)((scm_cell *)obj)->cdr)->fname)) {
    {
#line 179
    plist = scm_acons(scm_i_filename, ((scm_srcprops *)((scm_cell *)obj)->cdr)->fname,
                      plist);
    }
  }
  {
#line 180
  plist = scm_acons(scm_i_column, (SCM )(((((scm_srcprops *)((scm_cell *)obj)->cdr)->pos & 4095UL) << 2) + 2UL),
                    plist);
#line 181
  plist = scm_acons(scm_i_line, (SCM )(((((scm_srcprops *)((scm_cell *)obj)->cdr)->pos >> 12) << 2) + 2UL),
                    plist);
  }
#line 182
  if ((1L << 16) & ((scm_cell *)obj)->car) {
#line 182
    tmp = (long )(17 << 9) + 372L;
  } else {
#line 182
    tmp = (long )(16 << 9) + 372L;
  }
  {
#line 182
  plist = scm_acons(scm_i_breakpoint, tmp, plist);
  }
#line 183
  return (plist);
}
}
#line 186 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/srcprop.c"
static char s_source_properties[18]  = 
#line 186
  {      (char )'s',      (char )'o',      (char )'u',      (char )'r', 
        (char )'c',      (char )'e',      (char )'-',      (char )'p', 
        (char )'r',      (char )'o',      (char )'p',      (char )'e', 
        (char )'r',      (char )'t',      (char )'i',      (char )'e', 
        (char )'s',      (char )'\000'};
#line 188 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/srcprop.c"
SCM scm_source_properties(SCM obj ) 
{ 
  SCM p ;
  SCM tmp ;

  {
#line 193
  if (! (! (6 & (int )obj))) {
    {
#line 193
    scm_wta(obj, (char *)1, s_source_properties);
    }
  }
#line 194
  if (scm_tc16_memoized == (long )(65535 & (int )((scm_cell *)obj)->car)) {
#line 195
    obj = ((scm_cell *)((scm_cell *)obj)->cdr)->car;
  } else
#line 197
  if (1 & (int )((scm_cell *)obj)->car) {
    {
#line 198
    scm_wrong_type_arg(s_source_properties, 1, obj);
    }
  }
  {
#line 200
  p = scm_hashq_ref(scm_sys_protects[16], obj, (SCM )((void *)0));
  }
#line 201
  if (p != (SCM )((void *)0)) {
#line 201
    if ((long )(65535 & (int )((scm_cell *)p)->car) == scm_tc16_srcprops) {
      {
#line 202
      tmp = scm_srcprops_to_plist(p);
      }
#line 202
      return (tmp);
    }
  }
#line 203
  return ((long )(20 << 9) + 372L);
}
}
#line 208 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/srcprop.c"
static char s_set_source_properties_x[23]  = 
#line 208
  {      (char )'s',      (char )'e',      (char )'t',      (char )'-', 
        (char )'s',      (char )'o',      (char )'u',      (char )'r', 
        (char )'c',      (char )'e',      (char )'-',      (char )'p', 
        (char )'r',      (char )'o',      (char )'p',      (char )'e', 
        (char )'r',      (char )'t',      (char )'i',      (char )'e', 
        (char )'s',      (char )'!',      (char )'\000'};
#line 210 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/srcprop.c"
SCM scm_set_source_properties_x(SCM obj , SCM plist ) 
{ 
  SCM handle ;

  {
#line 216
  if (! (! (6 & (int )obj))) {
    {
#line 216
    scm_wta(obj, (char *)1, s_set_source_properties_x);
    }
  }
#line 217
  if (scm_tc16_memoized == (long )(65535 & (int )((scm_cell *)obj)->car)) {
#line 218
    obj = ((scm_cell *)((scm_cell *)obj)->cdr)->car;
  } else
#line 220
  if (1 & (int )((scm_cell *)obj)->car) {
    {
#line 221
    scm_wrong_type_arg(s_set_source_properties_x, 1, obj);
    }
  }
  {
#line 223
  handle = scm_hashq_create_handle_x(scm_sys_protects[16], obj, plist);
#line 224
  ((scm_cell *)handle)->cdr = plist;
  }
#line 225
  return (plist);
}
}
#line 228 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/srcprop.c"
static char s_source_property[16]  = 
#line 228
  {      (char )'s',      (char )'o',      (char )'u',      (char )'r', 
        (char )'c',      (char )'e',      (char )'-',      (char )'p', 
        (char )'r',      (char )'o',      (char )'p',      (char )'e', 
        (char )'r',      (char )'t',      (char )'y',      (char )'\000'};
#line 230 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/srcprop.c"
SCM scm_source_property(SCM obj , SCM key ) 
{ 
  SCM p ;
  SCM tmp ;
  long tmp___0 ;

  {
#line 236
  if (! (! (6 & (int )obj))) {
    {
#line 236
    scm_wta(obj, (char *)1, s_source_property);
    }
  }
#line 237
  if (scm_tc16_memoized == (long )(65535 & (int )((scm_cell *)obj)->car)) {
#line 238
    obj = ((scm_cell *)((scm_cell *)obj)->cdr)->car;
  } else
#line 240
  if (1 & (int )((scm_cell *)obj)->car) {
    {
#line 241
    scm_wrong_type_arg(s_source_property, 1, obj);
    }
  }
  {
#line 243
  p = scm_hashq_ref(scm_sys_protects[16], obj, (long )(20 << 9) + 372L);
  }
#line 244
  if (6 & (int )p) {
#line 245
    goto plist;
  } else
#line 244
  if (! ((long )(65535 & (int )((scm_cell *)p)->car) == scm_tc16_srcprops)) {
#line 245
    goto plist;
  }
#line 246
  if (scm_i_breakpoint == key) {
#line 246
    if ((1L << 16) & ((scm_cell *)p)->car) {
#line 246
      p = (long )(17 << 9) + 372L;
    } else {
#line 246
      p = (long )(16 << 9) + 372L;
    }
  } else
#line 247
  if (scm_i_line == key) {
#line 247
    p = (SCM )(((((scm_srcprops *)((scm_cell *)p)->cdr)->pos >> 12) << 2) + 2UL);
  } else
#line 248
  if (scm_i_column == key) {
#line 248
    p = (SCM )(((((scm_srcprops *)((scm_cell *)p)->cdr)->pos & 4095UL) << 2) + 2UL);
  } else
#line 249
  if (scm_i_filename == key) {
#line 249
    p = ((scm_srcprops *)((scm_cell *)p)->cdr)->fname;
  } else
#line 250
  if (scm_i_copy == key) {
#line 250
    p = ((scm_srcprops *)((scm_cell *)p)->cdr)->copy;
  } else {
#line 253
    p = ((scm_srcprops *)((scm_cell *)p)->cdr)->plist;
    plist: 
    {
#line 255
    p = scm_assoc(key, p);
    }
#line 256
    if (! (6 & (int )p)) {
#line 256
      tmp = ((scm_cell *)p)->cdr;
    } else {
#line 256
      tmp = (long )(16 << 9) + 372L;
    }
#line 256
    return (tmp);
  }
#line 258
  if ((long )(18 << 9) + 372L == p) {
#line 258
    tmp___0 = (long )(16 << 9) + 372L;
  } else {
#line 258
    tmp___0 = p;
  }
#line 258
  return (tmp___0);
}
}
#line 261 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/srcprop.c"
static char s_set_source_property_x[21]  = 
#line 261
  {      (char )'s',      (char )'e',      (char )'t',      (char )'-', 
        (char )'s',      (char )'o',      (char )'u',      (char )'r', 
        (char )'c',      (char )'e',      (char )'-',      (char )'p', 
        (char )'r',      (char )'o',      (char )'p',      (char )'e', 
        (char )'r',      (char )'t',      (char )'y',      (char )'!', 
        (char )'\000'};
#line 263 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/srcprop.c"
SCM scm_set_source_property_x(SCM obj , SCM key , SCM datum ) 
{ 
  SCM h ;
  SCM p ;
  SCM tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  SCM tmp___2 ;
  SCM tmp___3 ;
  SCM tmp___4 ;
  SCM tmp___5 ;
  SCM tmp___6 ;
  SCM tmp___7 ;
  SCM tmp___8 ;
  SCM tmp___9 ;

  {
#line 271
  if (! (! (6 & (int )obj))) {
    {
#line 271
    scm_wta(obj, (char *)1, s_set_source_property_x);
    }
  }
#line 272
  if (scm_tc16_memoized == (long )(65535 & (int )((scm_cell *)obj)->car)) {
#line 273
    obj = ((scm_cell *)((scm_cell *)obj)->cdr)->car;
  } else
#line 275
  if (1 & (int )((scm_cell *)obj)->car) {
    {
#line 276
    scm_wrong_type_arg(s_set_source_property_x, 1, obj);
    }
  }
  {
#line 278
  h = scm_hash_fn_get_handle(scm_sys_protects[16], obj, (unsigned int (*)())(& scm_ihashq),
                             (SCM (*)())(& scm_sloppy_assq), (void *)0);
  }
#line 279
  if (h != (long )(16 << 9) + 372L) {
#line 280
    p = ((scm_cell *)h)->cdr;
  } else {
    {
#line 283
    h = scm_hash_fn_create_handle_x(scm_sys_protects[16], obj, (long )(21 << 9) + 372L,
                                    (unsigned int (*)())(& scm_ihashq), (SCM (*)())(& scm_sloppy_assq),
                                    (void *)0);
#line 284
    p = (long )(20 << 9) + 372L;
    }
  }
#line 286
  if (scm_i_breakpoint == key) {
#line 287
    if ((long )(16 << 9) + 372L == datum) {
#line 288
      if (! (6 & (int )p)) {
#line 288
        if ((long )(65535 & (int )((scm_cell *)p)->car) == scm_tc16_srcprops) {
#line 288
          tmp___1 = p;
        } else {
          {
#line 288
          tmp___0 = scm_make_srcprops(0, 0, (long )(18 << 9) + 372L, (long )(18 << 9) + 372L,
                                      p);
#line 288
          tmp = tmp___0;
#line 288
          ((scm_cell *)h)->cdr = tmp;
#line 288
          tmp___1 = tmp;
          }
        }
      } else {
        {
#line 288
        tmp___0 = scm_make_srcprops(0, 0, (long )(18 << 9) + 372L, (long )(18 << 9) + 372L,
                                    p);
#line 288
        tmp = tmp___0;
#line 288
        ((scm_cell *)h)->cdr = tmp;
#line 288
        tmp___1 = tmp;
        }
      }
#line 288
      ((scm_cell *)tmp___1)->car &= ~ (1L << 16);
    } else {
#line 294
      if (! (6 & (int )p)) {
#line 294
        if ((long )(65535 & (int )((scm_cell *)p)->car) == scm_tc16_srcprops) {
#line 294
          tmp___4 = p;
        } else {
          {
#line 294
          tmp___3 = scm_make_srcprops(0, 0, (long )(18 << 9) + 372L, (long )(18 << 9) + 372L,
                                      p);
#line 294
          tmp___2 = tmp___3;
#line 294
          ((scm_cell *)h)->cdr = tmp___2;
#line 294
          tmp___4 = tmp___2;
          }
        }
      } else {
        {
#line 294
        tmp___3 = scm_make_srcprops(0, 0, (long )(18 << 9) + 372L, (long )(18 << 9) + 372L,
                                    p);
#line 294
        tmp___2 = tmp___3;
#line 294
        ((scm_cell *)h)->cdr = tmp___2;
#line 294
        tmp___4 = tmp___2;
        }
      }
#line 294
      ((scm_cell *)tmp___4)->car |= 1L << 16;
    }
  } else
#line 299
  if (scm_i_line == key) {
#line 301
    if (! (6 & (int )p)) {
#line 301
      if ((long )(65535 & (int )((scm_cell *)p)->car) == scm_tc16_srcprops) {
#line 302
        ((scm_srcprops *)((scm_cell *)p)->cdr)->pos = (unsigned long )(datum << 12) + (((scm_srcprops *)((scm_cell *)p)->cdr)->pos & 4095UL);
      } else {
        {
#line 304
        tmp___5 = scm_make_srcprops((int )datum, 0, (long )(18 << 9) + 372L, (long )(18 << 9) + 372L,
                                    p);
#line 304
        ((scm_cell *)h)->cdr = tmp___5;
        }
      }
    } else {
      {
#line 304
      tmp___5 = scm_make_srcprops((int )datum, 0, (long )(18 << 9) + 372L, (long )(18 << 9) + 372L,
                                  p);
#line 304
      ((scm_cell *)h)->cdr = tmp___5;
      }
    }
  } else
#line 307
  if (scm_i_column == key) {
#line 309
    if (! (6 & (int )p)) {
#line 309
      if ((long )(65535 & (int )((scm_cell *)p)->car) == scm_tc16_srcprops) {
#line 310
        ((scm_srcprops *)((scm_cell *)p)->cdr)->pos = ((((scm_srcprops *)((scm_cell *)p)->cdr)->pos >> 12) << 12) + (unsigned long )datum;
      } else {
        {
#line 312
        tmp___6 = scm_make_srcprops(0, (int )datum, (long )(18 << 9) + 372L, (long )(18 << 9) + 372L,
                                    p);
#line 312
        ((scm_cell *)h)->cdr = tmp___6;
        }
      }
    } else {
      {
#line 312
      tmp___6 = scm_make_srcprops(0, (int )datum, (long )(18 << 9) + 372L, (long )(18 << 9) + 372L,
                                  p);
#line 312
      ((scm_cell *)h)->cdr = tmp___6;
      }
    }
  } else
#line 315
  if (scm_i_filename == key) {
#line 317
    if (! (6 & (int )p)) {
#line 317
      if ((long )(65535 & (int )((scm_cell *)p)->car) == scm_tc16_srcprops) {
#line 318
        ((scm_srcprops *)((scm_cell *)p)->cdr)->fname = datum;
      } else {
        {
#line 320
        tmp___7 = scm_make_srcprops(0, 0, datum, (long )(18 << 9) + 372L, p);
#line 320
        ((scm_cell *)h)->cdr = tmp___7;
        }
      }
    } else {
      {
#line 320
      tmp___7 = scm_make_srcprops(0, 0, datum, (long )(18 << 9) + 372L, p);
#line 320
      ((scm_cell *)h)->cdr = tmp___7;
      }
    }
  } else
#line 322
  if (scm_i_filename == key) {
#line 324
    if (! (6 & (int )p)) {
#line 324
      if ((long )(65535 & (int )((scm_cell *)p)->car) == scm_tc16_srcprops) {
#line 325
        ((scm_srcprops *)((scm_cell *)p)->cdr)->copy = datum;
      } else {
        {
#line 327
        tmp___8 = scm_make_srcprops(0, 0, (long )(18 << 9) + 372L, datum, p);
#line 327
        ((scm_cell *)h)->cdr = tmp___8;
        }
      }
    } else {
      {
#line 327
      tmp___8 = scm_make_srcprops(0, 0, (long )(18 << 9) + 372L, datum, p);
#line 327
      ((scm_cell *)h)->cdr = tmp___8;
      }
    }
  } else {
    {
#line 330
    tmp___9 = scm_acons(key, datum, p);
#line 330
    ((scm_cell *)h)->cdr = tmp___9;
    }
  }
#line 331
  return ((long )(21 << 9) + 372L);
}
}
#line 335 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/srcprop.c"
void scm_init_srcprop(void) 
{ 
  SCM tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  SCM tmp___2 ;
  SCM tmp___3 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 338
  scm_tc16_srcprops = scm_newsmob(& srcpropssmob);
#line 339
  scm_sys_protects[16] = scm_make_weak_key_hash_table((long )(2047 << 2) + 2L);
#line 341
  tmp = scm_sysintern((char *)"filename", (long )(18 << 9) + 372L);
#line 341
  scm_i_filename = ((scm_cell *)tmp)->car;
#line 342
  tmp___0 = scm_sysintern((char *)"copy", (long )(18 << 9) + 372L);
#line 342
  scm_i_copy = ((scm_cell *)tmp___0)->car;
#line 343
  tmp___1 = scm_sysintern((char *)"line", (long )(18 << 9) + 372L);
#line 343
  scm_i_line = ((scm_cell *)tmp___1)->car;
#line 344
  tmp___2 = scm_sysintern((char *)"column", (long )(18 << 9) + 372L);
#line 344
  scm_i_column = ((scm_cell *)tmp___2)->car;
#line 345
  tmp___3 = scm_sysintern((char *)"breakpoint", (long )(18 << 9) + 372L);
#line 345
  scm_i_breakpoint = ((scm_cell *)tmp___3)->car;
#line 347
  scm_sysintern((char *)"source-whash", scm_sys_protects[16]);
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/srcprop.x"
  scm_make_gsubr(s_source_properties, 1, 0, 0, (SCM (*)())(& scm_source_properties));
#line 2
  scm_make_gsubr(s_set_source_properties_x, 2, 0, 0, (SCM (*)())(& scm_set_source_properties_x));
#line 3
  scm_make_gsubr(s_source_property, 2, 0, 0, (SCM (*)())(& scm_source_property));
#line 4
  scm_make_gsubr(s_set_source_property_x, 3, 0, 0, (SCM (*)())(& scm_set_source_property_x));
  }
#line 349 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/srcprop.c"
  return;
}
}
#line 351 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/srcprop.c"
void scm_finish_srcprop(void) 
{ 
  register scm_srcprops_chunk *ptr ;
  register scm_srcprops_chunk *next ;

  {
#line 354
  ptr = srcprops_chunklist;
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;
#line 355
    if (! ptr) {
#line 355
      goto while_break;
    }
    {
#line 357
    next = ptr->next;
#line 358
    free((void *)((char *)ptr));
#line 359
    scm_mallocated -= sizeof(scm_srcprops_chunk ) + sizeof(scm_srcprops ) * 2046UL;
#line 361
    ptr = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 363
  return;
}
}
#line 283 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 831
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 69 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/error.h"
 __attribute__((__noreturn__)) void scm_syserror(char *subr ) ;
#line 79
 __attribute__((__noreturn__)) void scm_misc_error(char *subr , char *message , SCM args ) ;
#line 58 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/fports.h"
SCM scm_setbuf0(SCM port ) ;
#line 55 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/socket.h"
SCM scm_socket(SCM family , SCM style , SCM proto ) ;
#line 56
SCM scm_socketpair(SCM family , SCM style , SCM proto ) ;
#line 57
SCM scm_getsockopt(SCM sock , SCM level , SCM optname ) ;
#line 58
SCM scm_setsockopt(SCM sock , SCM level , SCM optname , SCM value ) ;
#line 59
SCM scm_shutdown(SCM sock , SCM how ) ;
#line 60
SCM scm_connect(SCM sock , SCM fam , SCM address , SCM args ) ;
#line 61
SCM scm_bind(SCM sock , SCM fam , SCM address , SCM args ) ;
#line 62
SCM scm_listen(SCM sock , SCM backlog ) ;
#line 63
SCM scm_accept(SCM sock ) ;
#line 64
SCM scm_getsockname(SCM sock ) ;
#line 65
SCM scm_getpeername(SCM sock ) ;
#line 66
SCM scm_recv(SCM sock , SCM buff_or_size , SCM flags ) ;
#line 67
SCM scm_send(SCM sock , SCM message , SCM flags ) ;
#line 68
SCM scm_recvfrom(SCM sock , SCM buff_or_size , SCM flags ) ;
#line 69
SCM scm_sendto(SCM sock , SCM message , SCM fam , SCM address , SCM args_and_flags ) ;
#line 70
void scm_init_socket(void) ;
#line 350 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 105 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 111
extern  __attribute__((__nothrow__)) int socketpair(int __domain , int __type , int __protocol ,
                                                    int *__fds ) ;
#line 115
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  *__addr ,
                                              socklen_t __len ) ;
#line 119
extern  __attribute__((__nothrow__)) int getsockname(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 129
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 133
extern  __attribute__((__nothrow__)) int getpeername(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 141
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 148
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 155
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  *__addr , socklen_t __addr_len ) ;
#line 166
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 190
extern  __attribute__((__nothrow__)) int getsockopt(int __fd , int __level , int __optname ,
                                                    void * __restrict  __optval ,
                                                    socklen_t * __restrict  __optlen ) ;
#line 197
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
#line 204
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
#line 214
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 232
extern  __attribute__((__nothrow__)) int shutdown(int __fd , int __how ) ;
#line 365 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ntohl(uint32_t __netlong )  __attribute__((__const__)) ;
#line 366
extern  __attribute__((__nothrow__)) uint16_t ntohs(uint16_t __netshort )  __attribute__((__const__)) ;
#line 368
extern  __attribute__((__nothrow__)) uint32_t htonl(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 370
extern  __attribute__((__nothrow__)) uint16_t htons(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 68 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/socket.c"
static SCM scm_sock_fd_to_port(int fd , char *proc ) ;
#line 70 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/socket.c"
static SCM scm_sock_fd_to_port(int fd , char *proc ) 
{ 
  SCM result ;
  FILE *f ;
  int *tmp ;
  int *tmp___0 ;
  struct scm_port_table *pt ;
  struct scm_port_table *tmp___1 ;
  long tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 78
  if (fd == -1) {
    {
#line 79
    scm_syserror(proc);
    }
  }
  {
#line 80
  f = fdopen(fd, "r+");
  }
#line 81
  if (! f) {
    {
#line 83
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 83
      tmp = __errno_location();
#line 83
      *tmp = 0;
#line 83
      close(fd);
#line 83
      tmp___0 = __errno_location();
      }
#line 83
      if (! (4 == *tmp___0)) {
#line 83
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 84
    scm_syserror(proc);
    }
  }
#line 86
  if (6 & (int )scm_freelist) {
    {
#line 86
    result = scm_gc_for_newcell();
    }
  } else {
#line 86
    result = scm_freelist;
#line 86
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 86
    scm_cells_allocated ++;
  }
  {
#line 88
  tmp___1 = scm_add_to_port_table(result);
#line 88
  pt = tmp___1;
#line 90
  ((scm_cell *)result)->cdr = (SCM )pt;
#line 92
  tmp___2 = scm_mode_bits((char *)"r+0");
#line 92
  ((scm_cell *)result)->car = 125L | tmp___2;
#line 93
  ((struct scm_port_table *)((scm_cell *)result)->cdr)->stream = (SCM )f;
#line 94
  scm_setbuf0(result);
  }
#line 95
  return (result);
}
}
#line 98 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/socket.c"
static char s_socket[7]  = {      (char )'s',      (char )'o',      (char )'c',      (char )'k', 
        (char )'e',      (char )'t',      (char )'\000'};
#line 100 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/socket.c"
SCM scm_socket(SCM family , SCM style , SCM proto ) 
{ 
  int fd ;
  SCM result ;

  {
#line 109
  if (! (2 & (int )family)) {
    {
#line 109
    scm_wta(family, (char *)1, s_socket);
    }
  }
#line 110
  if (! (2 & (int )style)) {
    {
#line 110
    scm_wta(style, (char *)2, s_socket);
    }
  }
#line 111
  if (! (2 & (int )proto)) {
    {
#line 111
    scm_wta(proto, (char *)3, s_socket);
    }
  }
  {
#line 112
  scm_ints_disabled = 1;
#line 113
  fd = socket((int )(family >> 2), (int )(style >> 2), (int )(proto >> 2));
#line 114
  result = scm_sock_fd_to_port(fd, s_socket);
#line 115
  scm_ints_disabled = 0;
#line 115
  scm_async_clock --;
  }
#line 115
  if (0U == scm_async_clock) {
    {
#line 115
    scm_async_click();
    }
  }
#line 116
  return (result);
}
}
#line 121 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/socket.c"
static char s_socketpair[11]  = 
#line 121
  {      (char )'s',      (char )'o',      (char )'c',      (char )'k', 
        (char )'e',      (char )'t',      (char )'p',      (char )'a', 
        (char )'i',      (char )'r',      (char )'\000'};
#line 123 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/socket.c"
SCM scm_socketpair(SCM family , SCM style , SCM proto ) 
{ 
  int fam ;
  int fd[2] ;
  SCM a ;
  SCM b ;
  int tmp ;
  SCM tmp___0 ;
  void *__cil_tmp10 ;

  {
#line 134
  if (! (2 & (int )family)) {
    {
#line 134
    scm_wta(family, (char *)1, s_socketpair);
    }
  }
#line 135
  if (! (2 & (int )style)) {
    {
#line 135
    scm_wta(style, (char *)2, s_socketpair);
    }
  }
#line 136
  if (! (2 & (int )proto)) {
    {
#line 136
    scm_wta(proto, (char *)3, s_socketpair);
    }
  }
  {
#line 138
  fam = (int )(family >> 2);
#line 140
  scm_ints_disabled = 1;
#line 141
  tmp = socketpair(fam, (int )(style >> 2), (int )(proto >> 2), (int *)(fd));
  }
#line 141
  if (tmp == -1) {
    {
#line 142
    scm_syserror(s_socketpair);
    }
  }
  {
#line 144
  a = scm_sock_fd_to_port(fd[0], s_socketpair);
#line 145
  b = scm_sock_fd_to_port(fd[1], s_socketpair);
#line 146
  scm_ints_disabled = 0;
#line 146
  scm_async_clock --;
  }
#line 146
  if (0U == scm_async_clock) {
    {
#line 146
    scm_async_click();
    }
  }
  {
#line 147
  tmp___0 = scm_cons(a, b);
  }
#line 147
  return (tmp___0);
}
}
#line 151 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/socket.c"
static char s_getsockopt[11]  = 
#line 151
  {      (char )'g',      (char )'e',      (char )'t',      (char )'s', 
        (char )'o',      (char )'c',      (char )'k',      (char )'o', 
        (char )'p',      (char )'t',      (char )'\000'};
#line 153 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/socket.c"
SCM scm_getsockopt(SCM sock , SCM level , SCM optname ) 
{ 
  int fd ;
  int optlen ;
  char optval[sizeof(struct linger )] ;
  int ilevel ;
  int ioptname ;
  int tmp ;
  struct linger *ling ;
  SCM tmp___0 ;
  size_t *bufsize ;
  size_t *bufsize___0 ;
  void *__cil_tmp14 ;

  {
#line 170
  optlen = (int )sizeof(struct linger );
#line 175
  if (! (6 & (int )sock)) {
#line 175
    if (! ((65279 & (int )((scm_cell *)sock)->car) == 125)) {
      {
#line 175
      scm_wta(sock, (char *)1, s_getsockopt);
      }
    }
  } else {
    {
#line 175
    scm_wta(sock, (char *)1, s_getsockopt);
    }
  }
#line 177
  if (! (2 & (int )level)) {
    {
#line 177
    scm_wta(level, (char *)2, s_getsockopt);
    }
  }
#line 178
  if (! (2 & (int )optname)) {
    {
#line 178
    scm_wta(optname, (char *)3, s_getsockopt);
    }
  }
  {
#line 180
  fd = fileno((FILE *)((struct scm_port_table *)((scm_cell *)sock)->cdr)->stream);
#line 181
  ilevel = (int )(level >> 2);
#line 182
  ioptname = (int )(optname >> 2);
#line 183
  tmp = getsockopt(fd, ilevel, ioptname, (void */* __restrict  */)((void *)(optval)),
                   (socklen_t */* __restrict  */)(& optlen));
  }
#line 183
  if (tmp == -1) {
    {
#line 184
    scm_syserror(s_getsockopt);
    }
  }
#line 187
  if (ilevel == 1) {
#line 187
    if (ioptname == 13) {
      {
#line 190
      ling = (struct linger *)(optval);
#line 191
      tmp___0 = scm_cons((long )(ling->l_onoff << 2) + 2L, (long )(ling->l_linger << 2) + 2L);
      }
#line 191
      return (tmp___0);
    }
  }
#line 201
  if (ilevel == 1) {
#line 201
    if (ioptname == 7) {
#line 203
      bufsize = (size_t *)(optval);
#line 204
      return ((SCM )((*bufsize << 2) + 2UL));
    }
  }
#line 208
  if (ilevel == 1) {
#line 208
    if (ioptname == 8) {
#line 210
      bufsize___0 = (size_t *)(optval);
#line 211
      return ((SCM )((*bufsize___0 << 2) + 2UL));
    }
  }
#line 214
  return ((long )(*((int *)(optval)) << 2) + 2L);
}
}
#line 217 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/socket.c"
static char s_setsockopt[11]  = 
#line 217
  {      (char )'s',      (char )'e',      (char )'t',      (char )'s', 
        (char )'o',      (char )'c',      (char )'k',      (char )'o', 
        (char )'p',      (char )'t',      (char )'\000'};
#line 219 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/socket.c"
SCM scm_setsockopt(SCM sock , SCM level , SCM optname , SCM value ) 
{ 
  int fd ;
  int optlen ;
  char optval[sizeof(struct linger )] ;
  int ilevel ;
  int ioptname ;
  struct linger ling ;
  int tmp ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;

  {
#line 234
  if (! (6 & (int )sock)) {
#line 234
    if (! ((65279 & (int )((scm_cell *)sock)->car) == 125)) {
      {
#line 234
      scm_wta(sock, (char *)1, s_setsockopt);
      }
    }
  } else {
    {
#line 234
    scm_wta(sock, (char *)1, s_setsockopt);
    }
  }
#line 236
  if (! (2 & (int )level)) {
    {
#line 236
    scm_wta(level, (char *)2, s_setsockopt);
    }
  }
#line 237
  if (! (2 & (int )optname)) {
    {
#line 237
    scm_wta(optname, (char *)3, s_setsockopt);
    }
  }
  {
#line 238
  fd = fileno((FILE *)((struct scm_port_table *)((scm_cell *)sock)->cdr)->stream);
#line 239
  ilevel = (int )(level >> 2);
#line 240
  ioptname = (int )(optname >> 2);
  }
#line 243
  if (ilevel == 1) {
#line 243
    if (ioptname == 13) {
#line 247
      if (! (6 & (int )value)) {
#line 247
        if (! (1 & (int )((scm_cell *)value)->car)) {
#line 247
          if (2 & (int )((scm_cell *)value)->car) {
#line 247
            if (! (2 & (int )((scm_cell *)value)->cdr)) {
              {
#line 247
              scm_wta(value, (char *)4, s_setsockopt);
              }
            }
          } else {
            {
#line 247
            scm_wta(value, (char *)4, s_setsockopt);
            }
          }
        } else {
          {
#line 247
          scm_wta(value, (char *)4, s_setsockopt);
          }
        }
      } else {
        {
#line 247
        scm_wta(value, (char *)4, s_setsockopt);
        }
      }
      {
#line 251
      ling.l_onoff = (int )(((scm_cell *)value)->car >> 2);
#line 252
      ling.l_linger = (int )(((scm_cell *)value)->cdr >> 2);
#line 253
      optlen = (int )sizeof(struct linger );
#line 254
      memcpy((void */* __restrict  */)(optval), (void const   */* __restrict  */)((void *)(& ling)),
             (size_t )optlen);
      }
    } else {
#line 243
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 268
  if (ilevel == 1) {
#line 268
    if (ioptname == 7) {
#line 270
      if (! (2 & (int )value)) {
        {
#line 270
        scm_wta(value, (char *)4, s_setsockopt);
        }
      }
#line 271
      optlen = (int )sizeof(size_t );
#line 272
      *((size_t *)(optval)) = (size_t )(value >> 2);
    } else {
#line 268
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 276
  if (ilevel == 1) {
#line 276
    if (ioptname == 8) {
#line 278
      if (! (2 & (int )value)) {
        {
#line 278
        scm_wta(value, (char *)4, s_setsockopt);
        }
      }
#line 279
      optlen = (int )sizeof(size_t );
#line 280
      *((size_t *)(optval)) = (size_t )(value >> 2);
    } else {
#line 276
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 286
    if (! (2 & (int )value)) {
      {
#line 286
      scm_wta(value, (char *)4, s_setsockopt);
      }
    }
#line 287
    optlen = (int )sizeof(int );
#line 288
    *((int *)(optval)) = (int )(value >> 2);
  }
  {
#line 290
  tmp = setsockopt(fd, ilevel, ioptname, (void const   *)((void *)(optval)), (socklen_t )optlen);
  }
#line 290
  if (tmp == -1) {
    {
#line 291
    scm_syserror(s_setsockopt);
    }
  }
#line 292
  return ((long )(21 << 9) + 372L);
}
}
#line 295 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/socket.c"
static char s_shutdown[9]  = 
#line 295
  {      (char )'s',      (char )'h',      (char )'u',      (char )'t', 
        (char )'d',      (char )'o',      (char )'w',      (char )'n', 
        (char )'\000'};
#line 297 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/socket.c"
SCM scm_shutdown(SCM sock , SCM how ) 
{ 
  int fd ;
  int tmp ;

  {
#line 303
  if (! (6 & (int )sock)) {
#line 303
    if (! ((65279 & (int )((scm_cell *)sock)->car) == 125)) {
      {
#line 303
      scm_wta(sock, (char *)1, s_shutdown);
      }
    }
  } else {
    {
#line 303
    scm_wta(sock, (char *)1, s_shutdown);
    }
  }
#line 305
  if (2 & (int )how) {
#line 305
    if (0L <= how >> 2) {
#line 305
      if (! (2L >= how >> 2)) {
        {
#line 305
        scm_wta(how, (char *)2, s_shutdown);
        }
      }
    } else {
      {
#line 305
      scm_wta(how, (char *)2, s_shutdown);
      }
    }
  } else {
    {
#line 305
    scm_wta(how, (char *)2, s_shutdown);
    }
  }
  {
#line 307
  fd = fileno((FILE *)((struct scm_port_table *)((scm_cell *)sock)->cdr)->stream);
#line 308
  tmp = shutdown(fd, (int )(how >> 2));
  }
#line 308
  if (tmp == -1) {
    {
#line 309
    scm_syserror(s_shutdown);
    }
  }
#line 310
  return ((long )(21 << 9) + 372L);
}
}
#line 321
static struct sockaddr *scm_fill_sockaddr(int fam , SCM address , SCM *args , int which_arg ,
                                          char *proc , size_t *size ) ;
#line 323 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/socket.c"
static struct sockaddr *scm_fill_sockaddr(int fam , SCM address , SCM *args , int which_arg ,
                                          char *proc , size_t *size ) 
{ 
  SCM isport ;
  struct sockaddr_in *soka ;
  char *tmp ;
  unsigned long tmp___0 ;
  struct sockaddr_un *soka___0 ;
  char *tmp___1 ;

  {
  {
#line 334
  if (fam == 2) {
#line 334
    goto case_2;
  }
#line 353
  if (fam == 1) {
#line 353
    goto case_1;
  }
#line 366
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 339
  tmp = scm_must_malloc((long )sizeof(struct sockaddr_in ), proc);
#line 339
  soka = (struct sockaddr_in *)tmp;
#line 341
  soka->sin_family = (sa_family_t )2;
#line 342
  tmp___0 = scm_num2ulong(address, (char *)which_arg, proc);
#line 342
  soka->sin_addr.s_addr = htonl((uint32_t )tmp___0);
  }
#line 344
  if (! (6 & (int )*args)) {
#line 344
    if (! (! (1 & (int )((scm_cell *)*args)->car))) {
      {
#line 344
      scm_wta(*args, (char *)(which_arg + 1), proc);
      }
    }
  } else {
    {
#line 344
    scm_wta(*args, (char *)(which_arg + 1), proc);
    }
  }
#line 346
  isport = ((scm_cell *)*args)->car;
#line 347
  *args = ((scm_cell *)*args)->cdr;
#line 348
  if (! (2 & (int )isport)) {
    {
#line 348
    scm_wta(isport, (char *)(which_arg + 1), proc);
    }
  }
  {
#line 349
  soka->sin_port = htons((uint16_t )(isport >> 2));
#line 350
  *size = sizeof(struct sockaddr_in );
  }
#line 351
  return ((struct sockaddr *)soka);
  case_1: /* CIL Label */ 
  {
#line 357
  tmp___1 = scm_must_malloc((long )sizeof(struct sockaddr_un ), proc);
#line 357
  soka___0 = (struct sockaddr_un *)tmp___1;
#line 359
  soka___0->sun_family = (sa_family_t )1;
  }
#line 360
  if (! (6 & (int )address)) {
#line 360
    if (! ((125 & (int )((scm_cell *)address)->car) == 21)) {
      {
#line 360
      scm_wta(address, (char *)which_arg, proc);
      }
    }
  } else {
    {
#line 360
    scm_wta(address, (char *)which_arg, proc);
    }
  }
  {
#line 362
  memcpy((void */* __restrict  */)(soka___0->sun_path), (void const   */* __restrict  */)((char *)((scm_cell *)address)->cdr),
         1UL + ((unsigned long )((scm_cell *)address)->car >> 8));
#line 363
  *size = sizeof(struct sockaddr_un );
  }
#line 364
  return ((struct sockaddr *)soka___0);
  switch_default: /* CIL Label */ 
  {
#line 367
  scm_out_of_range(proc, (long )(fam << 2) + 2L);
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 371 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/socket.c"
static char s_connect[8]  = 
#line 371
  {      (char )'c',      (char )'o',      (char )'n',      (char )'n', 
        (char )'e',      (char )'c',      (char )'t',      (char )'\000'};
#line 373 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/socket.c"
SCM scm_connect(SCM sock , SCM fam , SCM address , SCM args ) 
{ 
  int fd ;
  struct sockaddr *soka ;
  size_t size ;
  int tmp ;

  {
#line 385
  if (! (6 & (int )sock)) {
#line 385
    if (! ((65279 & (int )((scm_cell *)sock)->car) == 125)) {
      {
#line 385
      scm_wta(sock, (char *)1, s_connect);
      }
    }
  } else {
    {
#line 385
    scm_wta(sock, (char *)1, s_connect);
    }
  }
#line 386
  if (! (2 & (int )fam)) {
    {
#line 386
    scm_wta(fam, (char *)2, s_connect);
    }
  }
  {
#line 387
  fd = fileno((FILE *)((struct scm_port_table *)((scm_cell *)sock)->cdr)->stream);
#line 388
  scm_ints_disabled = 1;
#line 389
  soka = scm_fill_sockaddr((int )(fam >> 2), address, & args, 3, s_connect, & size);
#line 390
  tmp = connect(fd, (struct sockaddr  const  *)soka, (socklen_t )size);
  }
#line 390
  if (tmp == -1) {
    {
#line 391
    scm_syserror(s_connect);
    }
  }
  {
#line 392
  scm_must_free((char *)soka);
#line 393
  scm_ints_disabled = 0;
#line 393
  scm_async_clock --;
  }
#line 393
  if (0U == scm_async_clock) {
    {
#line 393
    scm_async_click();
    }
  }
#line 394
  return ((long )(21 << 9) + 372L);
}
}
#line 397 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/socket.c"
static char s_bind[5]  = {      (char )'b',      (char )'i',      (char )'n',      (char )'d', 
        (char )'\000'};
#line 399 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/socket.c"
SCM scm_bind(SCM sock , SCM fam , SCM address , SCM args ) 
{ 
  int rv ;
  struct sockaddr *soka ;
  size_t size ;
  int fd ;

  {
#line 411
  if (! (6 & (int )sock)) {
#line 411
    if (! ((65279 & (int )((scm_cell *)sock)->car) == 125)) {
      {
#line 411
      scm_wta(sock, (char *)1, s_bind);
      }
    }
  } else {
    {
#line 411
    scm_wta(sock, (char *)1, s_bind);
    }
  }
#line 412
  if (! (2 & (int )fam)) {
    {
#line 412
    scm_wta(fam, (char *)2, s_bind);
    }
  }
  {
#line 413
  soka = scm_fill_sockaddr((int )(fam >> 2), address, & args, 3, s_bind, & size);
#line 414
  fd = fileno((FILE *)((struct scm_port_table *)((scm_cell *)sock)->cdr)->stream);
#line 415
  rv = bind(fd, (struct sockaddr  const  *)soka, (socklen_t )size);
  }
#line 416
  if (rv == -1) {
    {
#line 417
    scm_syserror(s_bind);
    }
  }
#line 418
  return ((long )(21 << 9) + 372L);
}
}
#line 421 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/socket.c"
static char s_listen[7]  = {      (char )'l',      (char )'i',      (char )'s',      (char )'t', 
        (char )'e',      (char )'n',      (char )'\000'};
#line 423 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/socket.c"
SCM scm_listen(SCM sock , SCM backlog ) 
{ 
  int fd ;
  int tmp ;

  {
#line 429
  if (! (6 & (int )sock)) {
#line 429
    if (! ((65279 & (int )((scm_cell *)sock)->car) == 125)) {
      {
#line 429
      scm_wta(sock, (char *)1, s_listen);
      }
    }
  } else {
    {
#line 429
    scm_wta(sock, (char *)1, s_listen);
    }
  }
#line 430
  if (! (2 & (int )backlog)) {
    {
#line 430
    scm_wta(backlog, (char *)2, s_listen);
    }
  }
  {
#line 431
  fd = fileno((FILE *)((struct scm_port_table *)((scm_cell *)sock)->cdr)->stream);
#line 432
  tmp = listen(fd, (int )(backlog >> 2));
  }
#line 432
  if (tmp == -1) {
    {
#line 433
    scm_syserror(s_listen);
    }
  }
#line 434
  return ((long )(21 << 9) + 372L);
}
}
#line 439
static SCM scm_addr_vector(struct sockaddr *address , char *proc ) ;
#line 441 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/socket.c"
static SCM scm_addr_vector(struct sockaddr *address , char *proc ) 
{ 
  short fam ;
  SCM result ;
  SCM *ve ;
  struct sockaddr_un *nad ;
  size_t tmp ;
  struct sockaddr_in *nad___0 ;
  uint32_t tmp___0 ;
  uint16_t tmp___1 ;
  SCM tmp___2 ;
  char *__cil_tmp12 ;

  {
#line 446
  fam = (short )address->sa_family;
#line 449
  if ((int )fam == 1) {
    {
#line 451
    nad = (struct sockaddr_un *)address;
#line 452
    result = scm_make_vector((long )(2 << 2) + 2L, (long )(21 << 9) + 372L, (long )(16 << 9) + 372L);
#line 453
    ve = (SCM *)((scm_cell *)result)->cdr;
#line 454
    *(ve + 0) = scm_ulong2num((unsigned long )fam);
#line 455
    tmp = strlen((char const   *)(nad->sun_path));
#line 455
    *(ve + 1) = scm_makfromstr((char const   *)(nad->sun_path), tmp, 0);
    }
  } else
#line 458
  if ((int )fam == 2) {
    {
#line 460
    nad___0 = (struct sockaddr_in *)address;
#line 461
    result = scm_make_vector((long )(3 << 2) + 2L, (long )(21 << 9) + 372L, (long )(16 << 9) + 372L);
#line 462
    ve = (SCM *)((scm_cell *)result)->cdr;
#line 463
    *(ve + 0) = scm_ulong2num((unsigned long )fam);
#line 464
    tmp___0 = ntohl(nad___0->sin_addr.s_addr);
#line 464
    *(ve + 1) = scm_ulong2num((unsigned long )tmp___0);
#line 465
    tmp___1 = ntohs(nad___0->sin_port);
#line 465
    *(ve + 2) = scm_ulong2num((unsigned long )tmp___1);
    }
  } else {
    {
#line 468
    tmp___2 = scm_listify((long )((int )fam << 2) + 2L, (long )(21 << 9) + 372L);
#line 468
    scm_misc_error(proc, (char *)"Unrecognised socket address type: %s", tmp___2);
    }
  }
#line 471
  return (result);
}
}
#line 475 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/socket.c"
static char *scm_addr_buffer  ;
#line 476 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/socket.c"
static int scm_addr_buffer_size  ;
#line 478
static void scm_init_addr_buffer(void) ;
#line 480 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/socket.c"
static void scm_init_addr_buffer(void) 
{ 
  char *__cil_tmp1 ;

  {
#line 483
  scm_addr_buffer_size = (int )sizeof(struct sockaddr_un );
#line 484
  if (sizeof(struct sockaddr_in ) > (unsigned long )scm_addr_buffer_size) {
#line 485
    scm_addr_buffer_size = (int )sizeof(struct sockaddr_in );
  }
  {
#line 486
  scm_addr_buffer = scm_must_malloc((long )scm_addr_buffer_size, (char *)"address buffer");
  }
#line 487
  return;
}
}
#line 489 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/socket.c"
static char s_accept[7]  = {      (char )'a',      (char )'c',      (char )'c',      (char )'e', 
        (char )'p',      (char )'t',      (char )'\000'};
#line 491 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/socket.c"
SCM scm_accept(SCM sock ) 
{ 
  int fd ;
  int newfd ;
  SCM address ;
  SCM newsock ;
  int tmp_size ;
  SCM tmp ;

  {
#line 501
  if (! (6 & (int )sock)) {
#line 501
    if (! ((65279 & (int )((scm_cell *)sock)->car) == 125)) {
      {
#line 501
      scm_wta(sock, (char *)1, s_accept);
      }
    }
  } else {
    {
#line 501
    scm_wta(sock, (char *)1, s_accept);
    }
  }
  {
#line 502
  fd = fileno((FILE *)((struct scm_port_table *)((scm_cell *)sock)->cdr)->stream);
#line 503
  scm_ints_disabled = 1;
#line 504
  tmp_size = scm_addr_buffer_size;
#line 505
  newfd = accept(fd, (struct sockaddr */* __restrict  */)((struct sockaddr *)scm_addr_buffer),
                 (socklen_t */* __restrict  */)(& tmp_size));
#line 506
  newsock = scm_sock_fd_to_port(newfd, s_accept);
  }
#line 507
  if (tmp_size > 0) {
    {
#line 508
    address = scm_addr_vector((struct sockaddr *)scm_addr_buffer, s_accept);
    }
  } else {
#line 510
    address = (long )(16 << 9) + 372L;
  }
#line 512
  scm_ints_disabled = 0;
#line 512
  scm_async_clock --;
#line 512
  if (0U == scm_async_clock) {
    {
#line 512
    scm_async_click();
    }
  }
  {
#line 513
  tmp = scm_cons(newsock, address);
  }
#line 513
  return (tmp);
}
}
#line 516 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/socket.c"
static char s_getsockname[12]  = 
#line 516
  {      (char )'g',      (char )'e',      (char )'t',      (char )'s', 
        (char )'o',      (char )'c',      (char )'k',      (char )'n', 
        (char )'a',      (char )'m',      (char )'e',      (char )'\000'};
#line 518 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/socket.c"
SCM scm_getsockname(SCM sock ) 
{ 
  int tmp_size ;
  int fd ;
  SCM result ;
  int tmp ;

  {
#line 525
  if (! (6 & (int )sock)) {
#line 525
    if (! ((65279 & (int )((scm_cell *)sock)->car) == 125)) {
      {
#line 525
      scm_wta(sock, (char *)1, s_getsockname);
      }
    }
  } else {
    {
#line 525
    scm_wta(sock, (char *)1, s_getsockname);
    }
  }
  {
#line 526
  fd = fileno((FILE *)((struct scm_port_table *)((scm_cell *)sock)->cdr)->stream);
#line 527
  scm_ints_disabled = 1;
#line 528
  tmp_size = scm_addr_buffer_size;
#line 529
  tmp = getsockname(fd, (struct sockaddr */* __restrict  */)((struct sockaddr *)scm_addr_buffer),
                    (socklen_t */* __restrict  */)(& tmp_size));
  }
#line 529
  if (tmp == -1) {
    {
#line 530
    scm_syserror(s_getsockname);
    }
  }
#line 531
  if (tmp_size > 0) {
    {
#line 532
    result = scm_addr_vector((struct sockaddr *)scm_addr_buffer, s_getsockname);
    }
  } else {
#line 534
    result = (long )(16 << 9) + 372L;
  }
#line 535
  scm_ints_disabled = 0;
#line 535
  scm_async_clock --;
#line 535
  if (0U == scm_async_clock) {
    {
#line 535
    scm_async_click();
    }
  }
#line 536
  return (result);
}
}
#line 539 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/socket.c"
static char s_getpeername[12]  = 
#line 539
  {      (char )'g',      (char )'e',      (char )'t',      (char )'p', 
        (char )'e',      (char )'e',      (char )'r',      (char )'n', 
        (char )'a',      (char )'m',      (char )'e',      (char )'\000'};
#line 541 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/socket.c"
SCM scm_getpeername(SCM sock ) 
{ 
  int tmp_size ;
  int fd ;
  SCM result ;
  int tmp ;

  {
#line 548
  if (! (6 & (int )sock)) {
#line 548
    if (! ((65279 & (int )((scm_cell *)sock)->car) == 125)) {
      {
#line 548
      scm_wta(sock, (char *)1, s_getpeername);
      }
    }
  } else {
    {
#line 548
    scm_wta(sock, (char *)1, s_getpeername);
    }
  }
  {
#line 549
  fd = fileno((FILE *)((struct scm_port_table *)((scm_cell *)sock)->cdr)->stream);
#line 550
  scm_ints_disabled = 1;
#line 551
  tmp_size = scm_addr_buffer_size;
#line 552
  tmp = getpeername(fd, (struct sockaddr */* __restrict  */)((struct sockaddr *)scm_addr_buffer),
                    (socklen_t */* __restrict  */)(& tmp_size));
  }
#line 552
  if (tmp == -1) {
    {
#line 553
    scm_syserror(s_getpeername);
    }
  }
#line 554
  if (tmp_size > 0) {
    {
#line 555
    result = scm_addr_vector((struct sockaddr *)scm_addr_buffer, s_getpeername);
    }
  } else {
#line 557
    result = (long )(16 << 9) + 372L;
  }
#line 558
  scm_ints_disabled = 0;
#line 558
  scm_async_clock --;
#line 558
  if (0U == scm_async_clock) {
    {
#line 558
    scm_async_click();
    }
  }
#line 559
  return (result);
}
}
#line 562 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/socket.c"
static char s_recv[5]  = {      (char )'r',      (char )'e',      (char )'c',      (char )'v', 
        (char )'\000'};
#line 564 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/socket.c"
SCM scm_recv(SCM sock , SCM buff_or_size , SCM flags ) 
{ 
  int rv ;
  int fd ;
  int flg ;
  SCM tok_buf___0 ;
  char *p ;
  int size ;
  int allocated ;
  unsigned long tmp ;
  int *tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  SCM tmp___3 ;
  SCM tmp___4 ;
  SCM tmp___5 ;

  {
#line 576
  allocated = 0;
#line 578
  if (! (6 & (int )sock)) {
#line 578
    if (! ((65279 & (int )((scm_cell *)sock)->car) == 125)) {
      {
#line 578
      scm_wta(sock, (char *)1, s_recv);
      }
    }
  } else {
    {
#line 578
    scm_wta(sock, (char *)1, s_recv);
    }
  }
#line 579
  if (2 & (int )buff_or_size) {
    {
#line 581
    size = (int )(buff_or_size >> 2);
#line 582
    tok_buf___0 = scm_makstr((long )size, 0);
#line 583
    allocated = 1;
    }
  } else {
#line 587
    if (! (6 & (int )buff_or_size)) {
#line 587
      if (! ((125 & (int )((scm_cell *)buff_or_size)->car) == 21)) {
        {
#line 587
        scm_wta(buff_or_size, (char *)2, s_recv);
        }
      }
    } else {
      {
#line 587
      scm_wta(buff_or_size, (char *)2, s_recv);
      }
    }
#line 589
    tok_buf___0 = buff_or_size;
#line 590
    size = (int )((unsigned long )((scm_cell *)tok_buf___0)->car >> 8);
  }
  {
#line 592
  p = (char *)((scm_cell *)tok_buf___0)->cdr;
#line 593
  fd = fileno((FILE *)((struct scm_port_table *)((scm_cell *)sock)->cdr)->stream);
  }
#line 595
  if ((long )(18 << 9) + 372L == flags) {
#line 596
    flg = 0;
  } else {
    {
#line 598
    tmp = scm_num2ulong(flags, (char *)3, s_recv);
#line 598
    flg = (int )tmp;
    }
  }
  {
#line 600
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 600
    tmp___0 = __errno_location();
#line 600
    *tmp___0 = 0;
#line 600
    tmp___1 = recv(fd, (void *)p, (size_t )size, flg);
#line 600
    rv = (int )tmp___1;
#line 600
    tmp___2 = __errno_location();
    }
#line 600
    if (! (4 == *tmp___2)) {
#line 600
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 601
  if (rv == -1) {
    {
#line 602
    scm_syserror(s_recv);
    }
  }
#line 604
  if (allocated) {
    {
#line 604
    tmp___3 = scm_vector_set_length_x(tok_buf___0, (long )(rv << 2) + 2L);
#line 604
    tmp___4 = tmp___3;
    }
  } else {
#line 604
    tmp___4 = tok_buf___0;
  }
  {
#line 604
  tmp___5 = scm_cons(tmp___4, (long )(rv << 2) + 2L);
  }
#line 604
  return (tmp___5);
}
}
#line 610 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/socket.c"
static char s_send[5]  = {      (char )'s',      (char )'e',      (char )'n',      (char )'d', 
        (char )'\000'};
#line 612 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/socket.c"
SCM scm_send(SCM sock , SCM message , SCM flags ) 
{ 
  int rv ;
  int fd ;
  int flg ;
  unsigned long tmp ;
  int *tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;

  {
#line 622
  if (! (6 & (int )sock)) {
#line 622
    if (! ((65279 & (int )((scm_cell *)sock)->car) == 125)) {
      {
#line 622
      scm_wta(sock, (char *)1, s_send);
      }
    }
  } else {
    {
#line 622
    scm_wta(sock, (char *)1, s_send);
    }
  }
#line 623
  if (! (6 & (int )message)) {
#line 623
    if (! ((125 & (int )((scm_cell *)message)->car) == 21)) {
      {
#line 623
      scm_wta(message, (char *)2, s_send);
      }
    }
  } else {
    {
#line 623
    scm_wta(message, (char *)2, s_send);
    }
  }
  {
#line 624
  fd = fileno((FILE *)((struct scm_port_table *)((scm_cell *)sock)->cdr)->stream);
  }
#line 626
  if ((long )(18 << 9) + 372L == flags) {
#line 627
    flg = 0;
  } else {
    {
#line 629
    tmp = scm_num2ulong(flags, (char *)3, s_send);
#line 629
    flg = (int )tmp;
    }
  }
  {
#line 631
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 631
    tmp___0 = __errno_location();
#line 631
    *tmp___0 = 0;
#line 631
    tmp___1 = send(fd, (void const   *)((char *)((scm_cell *)message)->cdr), (unsigned long )((scm_cell *)message)->car >> 8,
                   flg);
#line 631
    rv = (int )tmp___1;
#line 631
    tmp___2 = __errno_location();
    }
#line 631
    if (! (4 == *tmp___2)) {
#line 631
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 632
  if (rv == -1) {
    {
#line 633
    scm_syserror(s_send);
    }
  }
#line 634
  return ((long )(rv << 2) + 2L);
}
}
#line 637 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/socket.c"
static char s_recvfrom[9]  = 
#line 637
  {      (char )'r',      (char )'e',      (char )'c',      (char )'v', 
        (char )'f',      (char )'r',      (char )'o',      (char )'m', 
        (char )'\000'};
#line 639 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/socket.c"
SCM scm_recvfrom(SCM sock , SCM buff_or_size , SCM flags ) 
{ 
  int rv ;
  int fd ;
  int flg ;
  SCM tok_buf___0 ;
  char *p ;
  int size ;
  int allocated ;
  int tmp_size ;
  SCM address ;
  unsigned long tmp ;
  int *tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  SCM tmp___3 ;
  SCM tmp___4 ;
  SCM tmp___5 ;

  {
#line 651
  allocated = 0;
#line 655
  if (! (6 & (int )sock)) {
#line 655
    if (! ((65279 & (int )((scm_cell *)sock)->car) == 125)) {
      {
#line 655
      scm_wta(sock, (char *)1, s_recvfrom);
      }
    }
  } else {
    {
#line 655
    scm_wta(sock, (char *)1, s_recvfrom);
    }
  }
#line 656
  if (2 & (int )buff_or_size) {
    {
#line 658
    size = (int )(buff_or_size >> 2);
#line 659
    tok_buf___0 = scm_makstr((long )size, 0);
#line 660
    allocated = 1;
    }
  } else {
#line 664
    if (! (6 & (int )buff_or_size)) {
#line 664
      if (! ((125 & (int )((scm_cell *)buff_or_size)->car) == 21)) {
        {
#line 664
        scm_wta(buff_or_size, (char *)2, s_recvfrom);
        }
      }
    } else {
      {
#line 664
      scm_wta(buff_or_size, (char *)2, s_recvfrom);
      }
    }
#line 666
    tok_buf___0 = buff_or_size;
#line 667
    size = (int )((unsigned long )((scm_cell *)tok_buf___0)->car >> 8);
  }
  {
#line 669
  p = (char *)((scm_cell *)tok_buf___0)->cdr;
#line 670
  fd = fileno((FILE *)((struct scm_port_table *)((scm_cell *)sock)->cdr)->stream);
  }
#line 672
  if ((long )(18 << 9) + 372L == flags) {
#line 673
    flg = 0;
  } else {
    {
#line 675
    tmp = scm_num2ulong(flags, (char *)3, s_recvfrom);
#line 675
    flg = (int )tmp;
    }
  }
#line 677
  tmp_size = scm_addr_buffer_size;
  {
#line 678
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 678
    tmp___0 = __errno_location();
#line 678
    *tmp___0 = 0;
#line 678
    tmp___1 = recvfrom(fd, (void */* __restrict  */)p, (size_t )size, flg, (struct sockaddr */* __restrict  */)((struct sockaddr *)scm_addr_buffer),
                       (socklen_t */* __restrict  */)(& tmp_size));
#line 678
    rv = (int )tmp___1;
#line 678
    tmp___2 = __errno_location();
    }
#line 678
    if (! (4 == *tmp___2)) {
#line 678
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 681
  if (rv == -1) {
    {
#line 682
    scm_syserror(s_recvfrom);
    }
  }
#line 683
  if (tmp_size > 0) {
    {
#line 684
    address = scm_addr_vector((struct sockaddr *)scm_addr_buffer, s_recvfrom);
    }
  } else {
#line 686
    address = (long )(16 << 9) + 372L;
  }
#line 688
  if (allocated) {
    {
#line 688
    tmp___3 = scm_vector_set_length_x(tok_buf___0, (long )(rv << 2) + 2L);
#line 688
    tmp___4 = tmp___3;
    }
  } else {
#line 688
    tmp___4 = tok_buf___0;
  }
  {
#line 688
  tmp___5 = scm_listify(tmp___4, (long )(rv << 2) + 2L, address, (long )(18 << 9) + 372L);
  }
#line 688
  return (tmp___5);
}
}
#line 697 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/socket.c"
static char s_sendto[7]  = {      (char )'s',      (char )'e',      (char )'n',      (char )'d', 
        (char )'t',      (char )'o',      (char )'\000'};
#line 699 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/socket.c"
SCM scm_sendto(SCM sock , SCM message , SCM fam , SCM address , SCM args_and_flags ) 
{ 
  int rv ;
  int fd ;
  int flg ;
  struct sockaddr *soka ;
  size_t size ;
  unsigned long tmp ;
  int *tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;

  {
#line 713
  if (! (6 & (int )sock)) {
#line 713
    if (! ((65279 & (int )((scm_cell *)sock)->car) == 125)) {
      {
#line 713
      scm_wta(sock, (char *)1, s_sendto);
      }
    }
  } else {
    {
#line 713
    scm_wta(sock, (char *)1, s_sendto);
    }
  }
#line 714
  if (! (6 & (int )message)) {
#line 714
    if (! ((125 & (int )((scm_cell *)message)->car) == 21)) {
      {
#line 714
      scm_wta(message, (char *)2, s_sendto);
      }
    }
  } else {
    {
#line 714
    scm_wta(message, (char *)2, s_sendto);
    }
  }
#line 715
  if (! (2 & (int )fam)) {
    {
#line 715
    scm_wta(fam, (char *)3, s_sendto);
    }
  }
  {
#line 716
  fd = fileno((FILE *)((struct scm_port_table *)((scm_cell *)sock)->cdr)->stream);
#line 717
  scm_ints_disabled = 1;
#line 718
  soka = scm_fill_sockaddr((int )(fam >> 2), address, & args_and_flags, 4, s_sendto,
                           & size);
  }
#line 720
  if ((long )(20 << 9) + 372L == args_and_flags) {
#line 721
    flg = 0;
  } else {
#line 724
    if (! (6 & (int )args_and_flags)) {
#line 724
      if (! (! (1 & (int )((scm_cell *)args_and_flags)->car))) {
        {
#line 724
        scm_wta(args_and_flags, (char *)5, s_sendto);
        }
      }
    } else {
      {
#line 724
      scm_wta(args_and_flags, (char *)5, s_sendto);
      }
    }
    {
#line 726
    tmp = scm_num2ulong(((scm_cell *)args_and_flags)->car, (char *)5, s_sendto);
#line 726
    flg = (int )tmp;
    }
  }
  {
#line 728
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 728
    tmp___0 = __errno_location();
#line 728
    *tmp___0 = 0;
#line 728
    tmp___1 = sendto(fd, (void const   *)((char *)((scm_cell *)message)->cdr), (unsigned long )((scm_cell *)message)->car >> 8,
                     flg, (struct sockaddr  const  *)soka, (socklen_t )size);
#line 728
    rv = (int )tmp___1;
#line 728
    tmp___2 = __errno_location();
    }
#line 728
    if (! (4 == *tmp___2)) {
#line 728
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 730
  if (rv == -1) {
    {
#line 731
    scm_syserror(s_sendto);
    }
  }
  {
#line 732
  scm_must_free((char *)soka);
#line 733
  scm_ints_disabled = 0;
#line 733
  scm_async_clock --;
  }
#line 733
  if (0U == scm_async_clock) {
    {
#line 733
    scm_async_click();
    }
  }
#line 734
  return ((long )(rv << 2) + 2L);
}
}
#line 739 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/socket.c"
void scm_init_socket(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
  {
#line 744
  scm_sysintern((char *)"AF_UNSPEC", 2L);
#line 747
  scm_sysintern((char *)"AF_UNIX", (long )(1 << 2) + 2L);
#line 750
  scm_sysintern((char *)"AF_INET", (long )(2 << 2) + 2L);
#line 754
  scm_sysintern((char *)"PF_UNSPEC", 2L);
#line 757
  scm_sysintern((char *)"PF_UNIX", (long )(1 << 2) + 2L);
#line 760
  scm_sysintern((char *)"PF_INET", (long )(2 << 2) + 2L);
#line 765
  scm_sysintern((char *)"SOCK_STREAM", (long )(1 << 2) + 2L);
#line 768
  scm_sysintern((char *)"SOCK_DGRAM", (long )(2 << 2) + 2L);
#line 771
  scm_sysintern((char *)"SOCK_RAW", (long )(3 << 2) + 2L);
#line 776
  scm_sysintern((char *)"SOL_SOCKET", (long )(1 << 2) + 2L);
#line 779
  scm_sysintern((char *)"SOL_IP", 2L);
#line 790
  scm_sysintern((char *)"SO_DEBUG", (long )(1 << 2) + 2L);
#line 793
  scm_sysintern((char *)"SO_REUSEADDR", (long )(2 << 2) + 2L);
#line 799
  scm_sysintern((char *)"SO_TYPE", (long )(3 << 2) + 2L);
#line 802
  scm_sysintern((char *)"SO_ERROR", (long )(4 << 2) + 2L);
#line 805
  scm_sysintern((char *)"SO_DONTROUTE", (long )(5 << 2) + 2L);
#line 808
  scm_sysintern((char *)"SO_BROADCAST", (long )(6 << 2) + 2L);
#line 811
  scm_sysintern((char *)"SO_SNDBUF", (long )(7 << 2) + 2L);
#line 814
  scm_sysintern((char *)"SO_RCVBUF", (long )(8 << 2) + 2L);
#line 817
  scm_sysintern((char *)"SO_KEEPALIVE", (long )(9 << 2) + 2L);
#line 820
  scm_sysintern((char *)"SO_OOBINLINE", (long )(10 << 2) + 2L);
#line 823
  scm_sysintern((char *)"SO_NO_CHECK", (long )(11 << 2) + 2L);
#line 826
  scm_sysintern((char *)"SO_PRIORITY", (long )(12 << 2) + 2L);
#line 829
  scm_sysintern((char *)"SO_LINGER", (long )(13 << 2) + 2L);
#line 834
  scm_sysintern((char *)"MSG_OOB", (long )(1 << 2) + 2L);
#line 837
  scm_sysintern((char *)"MSG_PEEK", (long )(2 << 2) + 2L);
#line 840
  scm_sysintern((char *)"MSG_DONTROUTE", (long )(4 << 2) + 2L);
#line 843
  scm_add_feature((char *)"socket");
#line 844
  scm_init_addr_buffer();
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/socket.x"
  scm_make_gsubr(s_socket, 3, 0, 0, (SCM (*)())(& scm_socket));
#line 2
  scm_make_gsubr(s_socketpair, 3, 0, 0, (SCM (*)())(& scm_socketpair));
#line 3
  scm_make_gsubr(s_getsockopt, 3, 0, 0, (SCM (*)())(& scm_getsockopt));
#line 4
  scm_make_gsubr(s_setsockopt, 4, 0, 0, (SCM (*)())(& scm_setsockopt));
#line 5
  scm_make_gsubr(s_shutdown, 2, 0, 0, (SCM (*)())(& scm_shutdown));
#line 6
  scm_make_gsubr(s_connect, 3, 0, 1, (SCM (*)())(& scm_connect));
#line 7
  scm_make_gsubr(s_bind, 3, 0, 1, (SCM (*)())(& scm_bind));
#line 8
  scm_make_gsubr(s_listen, 2, 0, 0, (SCM (*)())(& scm_listen));
#line 9
  scm_make_gsubr(s_accept, 1, 0, 0, (SCM (*)())(& scm_accept));
#line 10
  scm_make_gsubr(s_getsockname, 1, 0, 0, (SCM (*)())(& scm_getsockname));
#line 11
  scm_make_gsubr(s_getpeername, 1, 0, 0, (SCM (*)())(& scm_getpeername));
#line 12
  scm_make_gsubr(s_recv, 2, 1, 0, (SCM (*)())(& scm_recv));
#line 13
  scm_make_gsubr(s_send, 2, 1, 0, (SCM (*)())(& scm_send));
#line 14
  scm_make_gsubr(s_recvfrom, 2, 1, 0, (SCM (*)())(& scm_recvfrom));
#line 15
  scm_make_gsubr(s_sendto, 4, 0, 1, (SCM (*)())(& scm_sendto));
  }
#line 847 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/socket.c"
  return;
}
}
#line 269 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.h"
int scm_bigprint(SCM exp___0 , SCM port , scm_print_state *pstate ) ;
#line 275
SCM scm_bigequal(SCM x , SCM y ) ;
#line 276
SCM scm_floequal(SCM x , SCM y ) ;
#line 62 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/smob.h"
size_t scm_numsmob  ;
#line 63 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/smob.h"
scm_smobfuns *scm_smobs  ;
#line 57 "../libguile/markers.h"
size_t scm_free0(SCM ptr ) ;
#line 76 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/smob.h"
void scm_smob_prehistory(void) ;
#line 63 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/smob.c"
long scm_newsmob(scm_smobfuns *smob ) 
{ 
  char *tmp ;
  int *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *__cil_tmp6 ;

  {
#line 68
  if (255UL <= scm_numsmob) {
#line 69
    goto smoberr;
  }
#line 70
  scm_ints_disabled = 1;
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 71
    tmp___0 = __errno_location();
#line 71
    *tmp___0 = 0;
#line 71
    tmp___1 = realloc((void *)((char *)scm_smobs), (1UL + scm_numsmob) * sizeof(scm_smobfuns ));
#line 71
    tmp = (char *)tmp___1;
#line 71
    tmp___2 = __errno_location();
    }
#line 71
    if (! (4 == *tmp___2)) {
#line 71
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  if (tmp) {
#line 74
    scm_smobs = (scm_smobfuns *)tmp;
#line 75
    (scm_smobs + scm_numsmob)->mark = smob->mark;
#line 76
    (scm_smobs + scm_numsmob)->free = smob->free;
#line 77
    (scm_smobs + scm_numsmob)->print = smob->print;
#line 78
    (scm_smobs + scm_numsmob)->equalp = smob->equalp;
#line 79
    scm_numsmob ++;
  }
#line 81
  scm_ints_disabled = 0;
#line 81
  scm_async_clock --;
#line 81
  if (0U == scm_async_clock) {
    {
#line 81
    scm_async_click();
    }
  }
#line 82
  if (! tmp) {
    smoberr: 
    {
#line 83
    scm_wta(((long )scm_numsmob << 2) + 2L, (char *)11, (char *)"newsmob");
    }
  }
#line 84
  return ((long )(127UL + (scm_numsmob - 1UL) * 256UL));
}
}
#line 90 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/smob.c"
static scm_smobfuns freecell  =    {& scm_mark0, & scm_free0, (int (*)(SCM exp , SCM port , scm_print_state *pstate ))0,
    (SCM (*)(SCM  , SCM  ))0};
#line 98 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/smob.c"
static scm_smobfuns flob  =    {& scm_mark0, (size_t (*)(SCM  ))0, & scm_floprint, & scm_floequal};
#line 106 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/smob.c"
static scm_smobfuns bigob  =    {& scm_mark0, (size_t (*)(SCM  ))0, & scm_bigprint, & scm_bigequal};
#line 117 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/smob.c"
void scm_smob_prehistory(void) 
{ 
  void *tmp ;
  int __cil_tmp2 ;
  void *__cil_tmp3 ;

  {
  {
#line 120
  scm_numsmob = (size_t )0;
#line 121
  tmp = malloc(7UL * sizeof(scm_smobfuns ));
#line 121
  scm_smobs = (scm_smobfuns *)tmp;
#line 124
  scm_newsmob(& freecell);
#line 125
  scm_newsmob(& flob);
#line 126
  scm_newsmob(& bigob);
#line 127
  scm_newsmob(& bigob);
  }
#line 128
  return;
}
}
#line 566 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
#line 712
extern int system(char const   *__command ) ;
#line 55 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/scmsigs.h"
void scm_ignore_signals(void) ;
#line 56
void scm_unignore_signals(void) ;
#line 50 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/simpos.h"
SCM scm_system(SCM cmd ) ;
#line 51
SCM scm_getenv(SCM nam ) ;
#line 52
SCM scm_software_type(void) ;
#line 53
void scm_init_simpos(void) ;
#line 61 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/simpos.c"
static char s_system[7]  = {      (char )'s',      (char )'y',      (char )'s',      (char )'t', 
        (char )'e',      (char )'m',      (char )'\000'};
#line 63 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/simpos.c"
SCM scm_system(SCM cmd ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 67
  if (! (6 & (int )cmd)) {
#line 67
    if (! ((117 & (int )((scm_cell *)cmd)->car) == 21)) {
#line 67
      if (! ((125 & (int )((scm_cell *)cmd)->car) == 5)) {
        {
#line 67
        scm_wta(cmd, (char *)1, s_system);
        }
      }
    }
  } else {
    {
#line 67
    scm_wta(cmd, (char *)1, s_system);
    }
  }
#line 68
  if ((117 & (int )((scm_cell *)cmd)->car) == 21) {
#line 68
    goto _L;
  } else
#line 68
  if ((125 & (int )((scm_cell *)cmd)->car) == 5) {
    _L: /* CIL Label */ 
#line 69
    if ((127 & (int )((scm_cell *)cmd)->car) == 29) {
#line 69
      tmp = (char *)((scm_cell *)((scm_cell *)((scm_cell *)cmd)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)cmd)->cdr)->car >> 2);
    } else {
#line 69
      tmp = (char *)((scm_cell *)cmd)->cdr;
    }
    {
#line 69
    cmd = scm_makfromstr((char const   *)tmp, (unsigned long )((scm_cell *)cmd)->car >> 8,
                         0);
    }
  }
  {
#line 70
  scm_ignore_signals();
  }
#line 74
  if ((127 & (int )((scm_cell *)cmd)->car) == 29) {
#line 74
    tmp___0 = (char *)((scm_cell *)((scm_cell *)((scm_cell *)cmd)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)cmd)->cdr)->car >> 2);
  } else {
#line 74
    tmp___0 = (char *)((scm_cell *)cmd)->cdr;
  }
  {
#line 74
  tmp___1 = system((char const   *)tmp___0);
#line 74
  cmd = ((long )tmp___1 << 2) + 2L;
#line 76
  scm_unignore_signals();
  }
#line 77
  return (cmd);
}
}
#line 82 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/simpos.c"
static char s_getenv[7]  = {      (char )'g',      (char )'e',      (char )'t',      (char )'e', 
        (char )'n',      (char )'v',      (char )'\000'};
#line 84 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/simpos.c"
SCM scm_getenv(SCM nam ) 
{ 
  char *val ;
  char *tmp ;
  size_t tmp___0 ;
  SCM tmp___1 ;
  SCM tmp___2 ;

  {
#line 89
  if (! (6 & (int )nam)) {
#line 89
    if (! ((117 & (int )((scm_cell *)nam)->car) == 21)) {
#line 89
      if (! ((125 & (int )((scm_cell *)nam)->car) == 5)) {
        {
#line 89
        scm_wta(nam, (char *)1, s_getenv);
        }
      }
    }
  } else {
    {
#line 89
    scm_wta(nam, (char *)1, s_getenv);
    }
  }
#line 90
  if ((117 & (int )((scm_cell *)nam)->car) == 21) {
#line 90
    goto _L;
  } else
#line 90
  if ((125 & (int )((scm_cell *)nam)->car) == 5) {
    _L: /* CIL Label */ 
#line 91
    if ((127 & (int )((scm_cell *)nam)->car) == 29) {
#line 91
      tmp = (char *)((scm_cell *)((scm_cell *)((scm_cell *)nam)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)nam)->cdr)->car >> 2);
    } else {
#line 91
      tmp = (char *)((scm_cell *)nam)->cdr;
    }
    {
#line 91
    nam = scm_makfromstr((char const   *)tmp, (unsigned long )((scm_cell *)nam)->car >> 8,
                         0);
    }
  }
  {
#line 92
  val = getenv((char const   *)((char *)((scm_cell *)nam)->cdr));
  }
#line 93
  if (val) {
    {
#line 93
    tmp___0 = strlen((char const   *)val);
#line 93
    tmp___1 = scm_makfromstr((char const   *)val, tmp___0, 0);
#line 93
    tmp___2 = tmp___1;
    }
  } else {
#line 93
    tmp___2 = (long )(16 << 9) + 372L;
  }
#line 93
  return (tmp___2);
}
}
#line 134 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/simpos.c"
static char s_software_type[14]  = 
#line 134
  {      (char )'s',      (char )'o',      (char )'f',      (char )'t', 
        (char )'w',      (char )'a',      (char )'r',      (char )'e', 
        (char )'-',      (char )'t',      (char )'y',      (char )'p', 
        (char )'e',      (char )'\000'};
#line 136 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/simpos.c"
SCM scm_software_type(void) 
{ 
  SCM tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 142
  tmp = scm_intern((char *)"UNIX", sizeof("UNIX") / sizeof(char ) - 1UL);
  }
#line 142
  return (((scm_cell *)tmp)->car);
}
}
#line 147 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/simpos.c"
void scm_init_simpos(void) 
{ 


  {
  {
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/simpos.x"
  scm_make_gsubr(s_system, 1, 0, 0, (SCM (*)())(& scm_system));
#line 2
  scm_make_gsubr(s_getenv, 1, 0, 0, (SCM (*)())(& scm_getenv));
#line 3
  scm_make_gsubr(s_software_type, 0, 0, 0, & scm_software_type);
  }
#line 151 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/simpos.c"
  return;
}
}
#line 54 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/sequences.h"
int scm_obj_length(SCM obj ) ;
#line 55
SCM scm_length(SCM x ) ;
#line 57
void scm_init_sequences(void) ;
#line 52 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/sequences.c"
int scm_obj_length(SCM obj ) 
{ 
  int i ;
  long tmp ;

  {
  {
#line 57
  tmp = scm_ilength(obj);
#line 57
  i = (int )tmp;
  }
#line 58
  if (i >= 0) {
#line 59
    return (i);
  } else
#line 60
  if (! (6 & (int )obj)) {
#line 62
    if ((117 & (int )((scm_cell *)obj)->car) == 21) {
#line 63
      return ((int )((unsigned long )((scm_cell *)obj)->car >> 8));
    } else
#line 62
    if ((125 & (int )((scm_cell *)obj)->car) == 5) {
#line 63
      return ((int )((unsigned long )((scm_cell *)obj)->car >> 8));
    } else
#line 64
    if ((125 & (int )((scm_cell *)obj)->car) == 13) {
#line 65
      return ((int )((unsigned long )((scm_cell *)obj)->car >> 8));
    } else {
#line 67
      return (-1);
    }
  } else {
#line 70
    return (-1);
  }
}
}
#line 74 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/sequences.c"
static char s_length[7]  = {      (char )'l',      (char )'e',      (char )'n',      (char )'g', 
        (char )'t',      (char )'h',      (char )'\000'};
#line 76 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/sequences.c"
SCM scm_length(SCM x ) 
{ 
  int i ;

  {
  {
#line 81
  i = scm_obj_length(x);
  }
#line 82
  if (i >= 0) {
#line 83
    return ((long )(i << 2) + 2L);
  } else {
    {
#line 86
    scm_wta(x, (char *)1, s_length);
    }
#line 87
    return ((long )(16 << 9) + 372L);
  }
}
}
#line 95 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/sequences.c"
static char s_reverse[8]  = 
#line 95
  {      (char )'r',      (char )'e',      (char )'v',      (char )'e', 
        (char )'r',      (char )'s',      (char )'e',      (char )'\000'};
#line 97 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/sequences.c"
SCM scm_reverse(SCM objs ) 
{ 
  SCM tmp ;

  {
  {
#line 101
  tmp = scm_list_reverse(objs);
  }
#line 101
  return (tmp);
}
}
#line 108 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/sequences.c"
void scm_init_sequences(void) 
{ 


  {
  {
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/sequences.x"
  scm_make_gsubr(s_length, 1, 0, 0, (SCM (*)())(& scm_length));
#line 2
  scm_make_gsubr(s_reverse, 1, 0, 0, (SCM (*)())(& scm_reverse));
  }
#line 112 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/sequences.c"
  return;
}
}
#line 146 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 147
extern struct _IO_FILE *stderr ;
#line 219
extern int fflush(FILE *__stream ) ;
#line 101 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 126
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 66 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.h"
SCM scm_take_signal(int n ) ;
#line 50 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/scmsigs.h"
SCM scm_alarm(SCM i ) ;
#line 51
SCM scm_pause(void) ;
#line 52
SCM scm_sleep(SCM i ) ;
#line 53
SCM scm_raise(SCM sig ) ;
#line 54
void scm_init_signals(void) ;
#line 57
SCM scm_restore_signals(void) ;
#line 58
void scm_init_scmsigs(void) ;
#line 429 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) unsigned int alarm(unsigned int __seconds ) ;
#line 441
extern unsigned int sleep(unsigned int __seconds ) ;
#line 465
extern int pause(void) ;
#line 623
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 105 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/scmsigs.c"
static void scm_hup_signal(int sig ) 
{ 


  {
  {
#line 105
  signal(1, & scm_hup_signal);
#line 105
  scm_take_signal(14);
  }
#line 105
  return;
}
}
#line 109 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/scmsigs.c"
static void scm_int_signal(int sig ) 
{ 


  {
  {
#line 109
  signal(2, & scm_int_signal);
#line 109
  scm_take_signal(15);
  }
#line 109
  return;
}
}
#line 113 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/scmsigs.c"
static void scm_fpe_signal(int sig ) 
{ 


  {
  {
#line 113
  signal(8, & scm_fpe_signal);
#line 113
  scm_take_signal(16);
  }
#line 113
  return;
}
}
#line 117 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/scmsigs.c"
static void scm_bus_signal(int sig ) 
{ 


  {
  {
#line 117
  signal(7, & scm_bus_signal);
#line 117
  scm_take_signal(17);
  }
#line 117
  return;
}
}
#line 121 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/scmsigs.c"
static void scm_segv_signal(int sig ) 
{ 


  {
  {
#line 121
  signal(11, & scm_segv_signal);
#line 121
  scm_take_signal(18);
  }
#line 121
  return;
}
}
#line 125 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/scmsigs.c"
static void scm_alrm_signal(int sig ) 
{ 


  {
  {
#line 125
  signal(14, & scm_alrm_signal);
#line 125
  scm_take_signal(19);
  }
#line 125
  return;
}
}
#line 143 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/scmsigs.c"
static char s_alarm[6]  = {      (char )'a',      (char )'l',      (char )'a',      (char )'r', 
        (char )'m',      (char )'\000'};
#line 145 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/scmsigs.c"
SCM scm_alarm(SCM i ) 
{ 
  unsigned int j ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 150
  if (2 & (int )i) {
#line 150
    if (! (i >> 2 >= 0L)) {
      {
#line 150
      scm_wta(i, (char *)1, s_alarm);
      }
    }
  } else {
    {
#line 150
    scm_wta(i, (char *)1, s_alarm);
    }
  }
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 151
    tmp = __errno_location();
#line 151
    *tmp = 0;
#line 151
    j = alarm((unsigned int )(i >> 2));
#line 151
    tmp___0 = __errno_location();
    }
#line 151
    if (! (4 == *tmp___0)) {
#line 151
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 152
  return ((long )(j << 2) + 2L);
}
}
#line 156 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/scmsigs.c"
static char s_pause[6]  = {      (char )'p',      (char )'a',      (char )'u',      (char )'s', 
        (char )'e',      (char )'\000'};
#line 158 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/scmsigs.c"
SCM scm_pause(void) 
{ 


  {
  {
#line 161
  pause();
  }
#line 162
  return ((long )(21 << 9) + 372L);
}
}
#line 165 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/scmsigs.c"
static char s_sleep[6]  = {      (char )'s',      (char )'l',      (char )'e',      (char )'e', 
        (char )'p',      (char )'\000'};
#line 167 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/scmsigs.c"
SCM scm_sleep(SCM i ) 
{ 
  unsigned int j ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 172
  if (2 & (int )i) {
#line 172
    if (! (i >> 2 >= 0L)) {
      {
#line 172
      scm_wta(i, (char *)1, s_sleep);
      }
    }
  } else {
    {
#line 172
    scm_wta(i, (char *)1, s_sleep);
    }
  }
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 176
    tmp = __errno_location();
#line 176
    *tmp = 0;
#line 176
    j = sleep((unsigned int )(i >> 2));
#line 176
    tmp___0 = __errno_location();
    }
#line 176
    if (! (4 == *tmp___0)) {
#line 176
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 178
  return ((long )(j << 2) + 2L);
}
}
#line 181 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/scmsigs.c"
static char s_raise[6]  = {      (char )'r',      (char )'a',      (char )'i',      (char )'s', 
        (char )'e',      (char )'\000'};
#line 183 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/scmsigs.c"
SCM scm_raise(SCM sig ) 
{ 
  long tmp___1 ;
  __pid_t tmp___2 ;
  int tmp___3 ;

  {
#line 187
  if (! (2 & (int )sig)) {
    {
#line 187
    scm_wta(sig, (char *)1, s_raise);
    }
  }
  {
#line 191
  tmp___2 = getpid();
#line 191
  tmp___3 = kill(tmp___2, (int )(sig >> 2));
  }
#line 191
  if (tmp___3) {
#line 191
    tmp___1 = (long )(16 << 9) + 372L;
  } else {
#line 191
    tmp___1 = (long )(17 << 9) + 372L;
  }
#line 191
  return (tmp___1);
}
}
#line 197 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/scmsigs.c"
static void (*oldhup)()  ;
#line 201 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/scmsigs.c"
static void (*oldint)()  ;
#line 205 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/scmsigs.c"
static void (*oldfpe)()  ;
#line 209 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/scmsigs.c"
static void (*oldbus)()  ;
#line 213 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/scmsigs.c"
static void (*oldsegv)()  ;
#line 217 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/scmsigs.c"
static void (*oldalrm)()  ;
#line 221 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/scmsigs.c"
static void (*oldpipe)()  ;
#line 226 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/scmsigs.c"
void scm_init_signals(void) 
{ 
  __sighandler_t tmp ;
  __sighandler_t tmp___0 ;
  __sighandler_t tmp___1 ;
  __sighandler_t tmp___2 ;
  __sighandler_t tmp___3 ;
  __sighandler_t tmp___4 ;
  __sighandler_t tmp___5 ;

  {
  {
#line 230
  tmp = signal(2, & scm_int_signal);
#line 230
  oldint = (void (*)())tmp;
#line 233
  tmp___0 = signal(1, & scm_hup_signal);
#line 233
  oldhup = (void (*)())tmp___0;
#line 236
  tmp___1 = signal(8, & scm_fpe_signal);
#line 236
  oldfpe = (void (*)())tmp___1;
#line 239
  tmp___2 = signal(7, & scm_bus_signal);
#line 239
  oldbus = (void (*)())tmp___2;
#line 242
  tmp___3 = signal(11, & scm_segv_signal);
#line 242
  oldsegv = (void (*)())tmp___3;
#line 245
  alarm(0U);
#line 246
  tmp___4 = signal(14, & scm_alrm_signal);
#line 246
  oldalrm = (void (*)())tmp___4;
#line 249
  tmp___5 = signal(13, (void (*)(int  ))1);
#line 249
  oldpipe = (void (*)())tmp___5;
  }
#line 257
  return;
}
}
#line 263 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/scmsigs.c"
void scm_ignore_signals(void) 
{ 


  {
  {
#line 272
  signal(2, (void (*)(int  ))1);
#line 274
  signal(1, (void (*)(int  ))0);
#line 277
  signal(8, (void (*)(int  ))0);
#line 280
  signal(7, (void (*)(int  ))0);
#line 283
  signal(11, (void (*)(int  ))0);
#line 295
  fflush(stdout);
#line 296
  fflush(stderr);
  }
#line 297
  return;
}
}
#line 300 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/scmsigs.c"
void scm_unignore_signals(void) 
{ 


  {
  {
#line 303
  signal(2, & scm_int_signal);
#line 305
  signal(1, & scm_hup_signal);
#line 308
  signal(8, & scm_fpe_signal);
#line 311
  signal(7, & scm_bus_signal);
#line 314
  signal(11, & scm_segv_signal);
#line 317
  signal(14, & scm_alrm_signal);
  }
#line 325
  return;
}
}
#line 327 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/scmsigs.c"
static char s_restore_signals[16]  = 
#line 327
  {      (char )'r',      (char )'e',      (char )'s',      (char )'t', 
        (char )'o',      (char )'r',      (char )'e',      (char )'-', 
        (char )'s',      (char )'i',      (char )'g',      (char )'n', 
        (char )'a',      (char )'l',      (char )'s',      (char )'\000'};
#line 329 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/scmsigs.c"
SCM scm_restore_signals(void) 
{ 


  {
  {
#line 338
  signal(2, (void (*)(int  ))oldint);
#line 340
  signal(1, (void (*)(int  ))oldhup);
#line 343
  signal(8, (void (*)(int  ))oldfpe);
#line 346
  signal(7, (void (*)(int  ))oldbus);
#line 349
  signal(11, (void (*)(int  ))oldsegv);
#line 352
  signal(13, (void (*)(int  ))oldpipe);
#line 355
  alarm(0U);
#line 356
  signal(14, (void (*)(int  ))oldalrm);
  }
#line 358
  return ((long )(21 << 9) + 372L);
}
}
#line 363 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/scmsigs.c"
void scm_init_scmsigs(void) 
{ 


  {
  {
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/scmsigs.x"
  scm_make_gsubr(s_alarm, 1, 0, 0, (SCM (*)())(& scm_alarm));
#line 2
  scm_make_gsubr(s_pause, 0, 0, 0, & scm_pause);
#line 3
  scm_make_gsubr(s_sleep, 1, 0, 0, (SCM (*)())(& scm_sleep));
#line 4
  scm_make_gsubr(s_raise, 1, 0, 0, (SCM (*)())(& scm_raise));
#line 5
  scm_make_gsubr(s_restore_signals, 0, 0, 0, & scm_restore_signals);
  }
#line 367 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/scmsigs.c"
  return;
}
}
#line 57 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.h"
int scm_gc_heap_lock ;
#line 78 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/root.h"
SCM scm_sys_protects[17]  ;
#line 82 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/root.h"
long scm_tc16_root  ;
#line 146 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/root.h"
struct scm_root_state *scm_root  ;
#line 152
SCM scm_make_root(SCM parent ) ;
#line 153
SCM scm_call_with_dynamic_root(SCM thunk , SCM handler ) ;
#line 154
SCM scm_apply_with_dynamic_root(SCM proc , SCM a1 , SCM args , SCM handler ) ;
#line 155
SCM scm_call_catching_errors(SCM (*thunk)() , SCM (*err_filter)() , void *closure ) ;
#line 156
void scm_init_root(void) ;
#line 66 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/root.c"
static SCM mark_root(SCM root ) ;
#line 68 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/root.c"
static SCM mark_root(SCM root ) 
{ 
  scm_root_state *s___0 ;

  {
  {
#line 72
  s___0 = (scm_root_state *)((scm_cell *)root)->cdr;
#line 73
  ((scm_cell *)root)->car |= 128L;
#line 74
  scm_gc_mark(s___0->rootcont);
#line 75
  scm_gc_mark(s___0->dynwinds);
#line 76
  scm_gc_mark(s___0->continuation_stack);
#line 77
  scm_gc_mark(s___0->continuation_stack_ptr);
#line 78
  scm_gc_mark(s___0->progargs);
#line 79
  scm_gc_mark(s___0->exitval);
#line 80
  scm_gc_mark(s___0->cur_inp);
#line 81
  scm_gc_mark(s___0->cur_outp);
#line 82
  scm_gc_mark(s___0->cur_errp);
#line 83
  scm_gc_mark(s___0->def_inp);
#line 84
  scm_gc_mark(s___0->def_outp);
#line 85
  scm_gc_mark(s___0->def_errp);
#line 86
  scm_gc_mark(s___0->top_level_lookup_closure_var);
#line 87
  scm_gc_mark(s___0->system_transformer);
  }
#line 88
  return (((scm_root_state *)((scm_cell *)root)->cdr)->parent);
}
}
#line 91
static size_t free_root(SCM root ) ;
#line 93 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/root.c"
static size_t free_root(SCM root ) 
{ 


  {
  {
#line 97
  scm_must_free((char *)((scm_root_state *)((scm_cell *)root)->cdr));
  }
#line 98
  return (sizeof(scm_root_state ));
}
}
#line 101
static int print_root(SCM exp___0 , SCM port , scm_print_state *pstate ) ;
#line 103 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/root.c"
static int print_root(SCM exp___0 , SCM port , scm_print_state *pstate ) 
{ 
  char *__cil_tmp4 ;

  {
  {
#line 109
  scm_gen_puts((enum scm_string_representation_type )0, (char *)"#<root ", port);
#line 110
  scm_intprint((long )((scm_contregs *)((char *)((scm_cell *)((scm_root_state *)((scm_cell *)exp___0)->cdr)->rootcont)->cdr))->seq,
               16, port);
#line 111
  scm_gen_putc('>', port);
  }
#line 112
  return (1);
}
}
#line 115 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/root.c"
static scm_smobfuns root_smob  =    {& mark_root, & free_root, & print_root, (SCM (*)(SCM  , SCM  ))0};
#line 125 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/root.c"
SCM scm_make_root(SCM parent ) 
{ 
  SCM root ;
  scm_root_state *root_state ;
  char *tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 132
  tmp = scm_must_malloc((long )sizeof(scm_root_state ), (char *)"scm_make_root");
#line 132
  root_state = (scm_root_state *)tmp;
  }
#line 134
  if (! (6 & (int )parent)) {
#line 134
    if (scm_tc16_root == (long )(65535 & (int )((scm_cell *)parent)->car)) {
      {
#line 136
      memcpy((void */* __restrict  */)root_state, (void const   */* __restrict  */)((scm_root_state *)((scm_cell *)parent)->cdr),
             sizeof(scm_root_state ));
#line 137
      root_state->parent = parent;
      }
    } else {
#line 141
      root_state->parent = (long )(16 << 9) + 372L;
    }
  } else {
#line 141
    root_state->parent = (long )(16 << 9) + 372L;
  }
#line 143
  if (6 & (int )scm_freelist) {
    {
#line 143
    root = scm_gc_for_newcell();
    }
  } else {
#line 143
    root = scm_freelist;
#line 143
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 143
    scm_cells_allocated ++;
  }
#line 144
  scm_ints_disabled ++;
#line 145
  ((scm_cell *)root)->car = scm_tc16_root;
#line 146
  ((scm_cell *)root)->cdr = (SCM )root_state;
#line 147
  root_state->handle = root;
#line 148
  scm_ints_disabled --;
#line 148
  if (! scm_ints_disabled) {
#line 148
    scm_async_clock --;
#line 148
    if (0U == scm_async_clock) {
      {
#line 148
      scm_async_click();
      }
    }
  }
#line 149
  return (root);
}
}
#line 177 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/root.c"
static int n_dynamic_roots  =    0;
#line 204
static SCM cwdr_body(void *data , SCM jmpbuf ) ;
#line 206 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/root.c"
static SCM cwdr_body(void *data , SCM jmpbuf ) 
{ 
  struct cwdr_body_data *c ;
  SCM tmp ;

  {
  {
#line 209
  c = (struct cwdr_body_data *)data;
#line 211
  tmp = scm_apply(c->body_proc, c->a1, c->args);
  }
#line 211
  return (tmp);
}
}
#line 215
static SCM cwdr(SCM proc , SCM a1 , SCM args , SCM handler , SCM_STACKITEM *stack_start ) ;
#line 223 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/root.c"
static SCM cwdr(SCM proc , SCM a1 , SCM args , SCM handler , SCM_STACKITEM *stack_start ) 
{ 
  int old_ints_disabled ;
  SCM old_rootcont ;
  SCM old_winds ;
  SCM answer ;
  SCM new_rootcont ;
  char *tmp ;
  long tmp___0 ;
  struct cwdr_body_data c ;
  long tmp___1 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 231
  old_ints_disabled = scm_ints_disabled;
#line 239
  if (6 & (int )scm_freelist) {
    {
#line 239
    new_rootcont = scm_gc_for_newcell();
    }
  } else {
#line 239
    new_rootcont = scm_freelist;
#line 239
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 239
    scm_cells_allocated ++;
  }
  {
#line 240
  scm_ints_disabled ++;
#line 241
  tmp = scm_must_malloc((long )sizeof(scm_contregs ), (char *)"inferior root continuation");
#line 241
  ((scm_cell *)new_rootcont)->cdr = (SCM )tmp;
#line 244
  ((scm_cell *)new_rootcont)->car = (SCM )61;
#line 245
  ((scm_contregs *)((char *)((scm_cell *)new_rootcont)->cdr))->dynenv = (long )(20 << 9) + 372L;
#line 246
  ((scm_contregs *)((char *)((scm_cell *)new_rootcont)->cdr))->base = stack_start;
#line 247
  n_dynamic_roots ++;
#line 247
  ((scm_contregs *)((char *)((scm_cell *)new_rootcont)->cdr))->seq = (unsigned long )n_dynamic_roots;
#line 249
  ((scm_contregs *)((char *)((scm_cell *)new_rootcont)->cdr))->dframe = (struct scm_debug_frame *)0;
#line 251
  old_rootcont = scm_root->rootcont;
#line 252
  scm_root->rootcont = new_rootcont;
#line 253
  scm_ints_disabled --;
  }
#line 253
  if (! scm_ints_disabled) {
#line 253
    scm_async_clock --;
#line 253
    if (0U == scm_async_clock) {
      {
#line 253
      scm_async_click();
      }
    }
  }
  {
#line 258
  old_winds = scm_root->dynwinds;
#line 259
  tmp___0 = scm_ilength(scm_root->dynwinds);
#line 259
  scm_dowinds((long )(20 << 9) + 372L, tmp___0);
#line 261
  ((scm_contregs *)((char *)((scm_cell *)old_rootcont)->cdr))->dframe = scm_last_debug_frame;
#line 262
  scm_last_debug_frame = (scm_debug_frame *)0;
#line 269
  c.a1 = a1;
#line 270
  c.args = args;
#line 271
  c.body_proc = proc;
#line 273
  answer = scm_internal_catch((long )(17 << 9) + 372L, & cwdr_body, (void *)(& c),
                              & scm_handle_by_proc, (void *)(& handler));
#line 278
  tmp___1 = scm_ilength(old_winds);
#line 278
  scm_dowinds(old_winds, - tmp___1);
#line 279
  scm_ints_disabled ++;
#line 281
  scm_last_debug_frame = ((scm_contregs *)((char *)((scm_cell *)old_rootcont)->cdr))->dframe;
#line 283
  scm_root->rootcont = old_rootcont;
#line 284
  scm_ints_disabled --;
  }
#line 284
  if (! scm_ints_disabled) {
#line 284
    scm_async_clock --;
#line 284
    if (0U == scm_async_clock) {
      {
#line 284
      scm_async_click();
      }
    }
  }
#line 285
  scm_ints_disabled = old_ints_disabled;
#line 286
  return (answer);
}
}
#line 290 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/root.c"
static char s_call_with_dynamic_root[23]  = 
#line 290
  {      (char )'c',      (char )'a',      (char )'l',      (char )'l', 
        (char )'-',      (char )'w',      (char )'i',      (char )'t', 
        (char )'h',      (char )'-',      (char )'d',      (char )'y', 
        (char )'n',      (char )'a',      (char )'m',      (char )'i', 
        (char )'c',      (char )'-',      (char )'r',      (char )'o', 
        (char )'o',      (char )'t',      (char )'\000'};
#line 291 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/root.c"
SCM scm_call_with_dynamic_root(SCM thunk , SCM handler ) 
{ 
  SCM_STACKITEM stack_place ;
  SCM tmp ;

  {
  {
#line 298
  tmp = cwdr(thunk, (long )(20 << 9) + 372L, (long )(20 << 9) + 372L, handler, & stack_place);
  }
#line 298
  return (tmp);
}
}
#line 301 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/root.c"
static char s_dynamic_root[13]  = 
#line 301
  {      (char )'d',      (char )'y',      (char )'n',      (char )'a', 
        (char )'m',      (char )'i',      (char )'c',      (char )'-', 
        (char )'r',      (char )'o',      (char )'o',      (char )'t', 
        (char )'\000'};
#line 302 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/root.c"
SCM scm_dynamic_root(void) 
{ 
  SCM tmp ;

  {
  {
#line 305
  tmp = scm_ulong2num(((scm_contregs *)((char *)((scm_cell *)scm_root->rootcont)->cdr))->seq);
  }
#line 305
  return (tmp);
}
}
#line 308 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/root.c"
SCM scm_apply_with_dynamic_root(SCM proc , SCM a1 , SCM args , SCM handler ) 
{ 
  SCM_STACKITEM stack_place ;
  SCM tmp ;

  {
  {
#line 316
  tmp = cwdr(proc, a1, args, handler, & stack_place);
  }
#line 316
  return (tmp);
}
}
#line 335 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/root.c"
SCM scm_call_catching_errors(SCM (*thunk)() , SCM (*err_filter)() , void *closure ) 
{ 
  SCM answer ;
  setjmp_type i ;
  int tmp ;

  {
  {
#line 344
  ((scm_contregs *)((char *)((scm_cell *)scm_root->rootcont)->cdr))->dframe = scm_last_debug_frame;
#line 346
  tmp = _setjmp((struct __jmp_buf_tag *)(((scm_contregs *)((char *)((scm_cell *)scm_root->rootcont)->cdr))->jmpbuf));
#line 346
  i = (setjmp_type )tmp;
#line 347
  scm_stack_checking_enabled_p = (int )scm_debug_opts[11].val;
  }
#line 348
  if (! i) {
    {
#line 350
    scm_gc_heap_lock = 0;
#line 351
    answer = (*thunk)(closure);
    }
  } else {
    {
#line 355
    scm_gc_heap_lock = 1;
#line 356
    answer = (*err_filter)(scm_root->exitval, closure);
    }
  }
#line 358
  return (answer);
}
}
#line 361 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/root.c"
void scm_init_root(void) 
{ 


  {
  {
#line 364
  scm_tc16_root = scm_newsmob(& root_smob);
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/root.x"
  scm_make_gsubr(s_call_with_dynamic_root, 2, 0, 0, (SCM (*)())(& scm_call_with_dynamic_root));
#line 2
  scm_make_gsubr(s_dynamic_root, 0, 0, 0, & scm_dynamic_root);
  }
#line 366 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/root.c"
  return;
}
}
#line 71 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/extchrs.h"
int xwctomb(char *_str , int c ) ;
#line 69 "../libguile/options.h"
SCM scm_options(SCM new_mode , scm_option *options , int n , char *s___0 ) ;
#line 70
void scm_init_opts(SCM (*func)(SCM  ) , scm_option *options , int n ) ;
#line 270 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.h"
SCM scm_istr2int(char *str , long len , long radix ) ;
#line 272
SCM scm_istring2number(char *str , long len , long radix ) ;
#line 58 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.h"
char *scm_charnames[40] ;
#line 59
int scm_n_charnames ;
#line 60
char scm_charnums[41] ;
#line 56 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/genio.h"
int scm_gen_getc(SCM port ) ;
#line 57
void scm_gen_ungetc(int c , SCM port ) ;
#line 89 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.h"
SCM scm_i_dot ;
#line 90
SCM scm_i_quote ;
#line 91
SCM scm_i_quasiquote ;
#line 96
SCM scm_i_unquote ;
#line 97
SCM scm_i_uq_splicing ;
#line 66 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/mbstrings.h"
SCM scm_set_symbol_multi_byte_x(SCM symbol , SCM val ) ;
#line 58 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/kw.h"
SCM scm_make_keyword_from_dash_symbol(SCM symbol ) ;
#line 58 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.h"
SCM scm_hash_fn_ref(SCM table , SCM obj , SCM dflt , unsigned int (*hash_fn)() , SCM (*assoc_fn)() ,
                    void *closure ) ;
#line 70 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/read.h"
scm_option scm_read_opts[2] ;
#line 78
SCM scm_read_options(SCM setting ) ;
#line 80
char *scm_grow_tok_buf(SCM *tok_buf___0 ) ;
#line 81
int scm_flush_ws(SCM port , char *eoferr ) ;
#line 82
int scm_casei_streq(char *s1 , char *s2 ) ;
#line 83
SCM scm_lreadr(SCM *tok_buf___0 , SCM port , int case_i , SCM sharp , SCM *copy ) ;
#line 84
size_t scm_read_token(int ic , SCM *tok_buf___0 , SCM port , int case_i , int weird ) ;
#line 85
SCM scm_lreadparen(SCM *tok_buf___0 , SCM port , char *name , int case_i , SCM sharp ,
                   SCM *copy ) ;
#line 86
SCM scm_lreadrecparen(SCM *tok_buf___0 , SCM port , char *name , int case_i , SCM sharp ,
                      SCM *copy ) ;
#line 87
void scm_init_read(void) ;
#line 65 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/read.c"
scm_option scm_read_opts[2]  = {      {0, (char *)"copy", 0UL, (char *)"Copy source code expressions."}, 
        {0, (char *)"positions", 0UL, (char *)"Record positions of source code expressions."}};
#line 72 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/read.c"
static char s_read_options[23]  = 
#line 72
  {      (char )'r',      (char )'e',      (char )'a',      (char )'d', 
        (char )'-',      (char )'o',      (char )'p',      (char )'t', 
        (char )'i',      (char )'o',      (char )'n',      (char )'s', 
        (char )'-',      (char )'i',      (char )'n',      (char )'t', 
        (char )'e',      (char )'r',      (char )'f',      (char )'a', 
        (char )'c',      (char )'e',      (char )'\000'};
#line 74 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/read.c"
SCM scm_read_options(SCM setting ) 
{ 
  SCM ans ;
  SCM tmp ;

  {
  {
#line 78
  tmp = scm_options(setting, scm_read_opts, 2, s_read_options);
#line 78
  ans = tmp;
  }
#line 82
  if (scm_read_opts[0].val) {
#line 83
    scm_read_opts[1].val = 1UL;
  }
#line 84
  return (ans);
}
}
#line 87 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/read.c"
static char s_read[5]  = {      (char )'r',      (char )'e',      (char )'a',      (char )'d', 
        (char )'\000'};
#line 89 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/read.c"
SCM scm_read(SCM port , SCM case_insensitive_p , SCM sharp ) 
{ 
  int c ;
  SCM tok_buf___0 ;
  SCM copy ;
  int case_i ;
  SCM tmp ;

  {
#line 99
  if ((long )(18 << 9) + 372L == port) {
#line 100
    port = scm_root->cur_inp;
  } else
#line 102
  if (! (6 & (int )port)) {
#line 102
    if (! ((((127L | (1L << 16)) | (2L << 16)) & ((scm_cell *)port)->car) == ((125L | (1L << 16)) | (2L << 16)))) {
      {
#line 102
      scm_wta(port, (char *)1, s_read);
      }
    }
  } else {
    {
#line 102
    scm_wta(port, (char *)1, s_read);
    }
  }
#line 107
  if ((long )(18 << 9) + 372L == case_insensitive_p) {
#line 107
    case_i = 0;
  } else {
#line 107
    case_i = case_insensitive_p == (long )(16 << 9) + 372L;
  }
#line 111
  if ((long )(18 << 9) + 372L == sharp) {
#line 112
    sharp = (long )(16 << 9) + 372L;
  }
  {
#line 114
  c = scm_flush_ws(port, (char *)((void *)0));
  }
#line 115
  if (-1 == c) {
#line 116
    return ((long )(19 << 9) + 372L);
  }
  {
#line 117
  scm_gen_ungetc(c, port);
#line 119
  tok_buf___0 = scm_makstr(30L, 0);
#line 120
  tmp = scm_lreadr(& tok_buf___0, port, case_i, sharp, & copy);
  }
#line 120
  return (tmp);
}
}
#line 125 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/read.c"
char *scm_grow_tok_buf(SCM *tok_buf___0 ) 
{ 


  {
  {
#line 129
  scm_vector_set_length_x(*tok_buf___0, (SCM )((2UL * ((unsigned long )((scm_cell *)*tok_buf___0)->car >> 8) << 2) + 2UL));
  }
#line 130
  return ((char *)((scm_cell *)*tok_buf___0)->cdr);
}
}
#line 135 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/read.c"
int scm_flush_ws(SCM port , char *eoferr ) 
{ 
  register int c ;
  char *__cil_tmp4 ;

  {
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 142
    c = scm_gen_getc(port);
    }
    {
#line 144
    if (c == -1) {
#line 144
      goto goteof;
    }
#line 149
    if (c == 59) {
#line 149
      goto lp;
    }
#line 163
    if (c == 9) {
#line 163
      goto case_9;
    }
#line 163
    if (c == 12) {
#line 163
      goto case_9;
    }
#line 163
    if (c == 13) {
#line 163
      goto case_9;
    }
#line 163
    if (c == 32) {
#line 163
      goto case_9;
    }
#line 163
    if (c == 10) {
#line 163
      goto case_9;
    }
#line 165
    goto switch_default___0;
    goteof: 
    case_neg_1: /* CIL Label */ 
#line 146
    if (eoferr) {
      {
#line 147
      scm_wta((long )(18 << 9) + 372L, (char *)"end of file in ", eoferr);
      }
    }
#line 148
    return (c);
    lp: 
    case_59: /* CIL Label */ 
    {
#line 151
    c = scm_gen_getc(port);
    }
    {
#line 153
    if (c == -1) {
#line 153
      goto case_neg_1___0;
    }
#line 157
    if (c == 10) {
#line 157
      goto case_10;
    }
#line 155
    goto switch_default;
    case_neg_1___0: /* CIL Label */ 
#line 154
    goto goteof;
    switch_default: /* CIL Label */ 
#line 156
    goto lp;
    case_10: /* CIL Label */ 
#line 158
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 160
    goto switch_break;
    case_9: /* CIL Label */ 
    case_12: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_10___0: /* CIL Label */ 
#line 164
    goto switch_break;
    switch_default___0: /* CIL Label */ 
#line 166
    return (c);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 172 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/read.c"
int scm_casei_streq(char *s1 , char *s2 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 177
    if (*s1) {
#line 177
      if (! *s2) {
#line 177
        goto while_break;
      }
    } else {
#line 177
      goto while_break;
    }
    {
#line 178
    tmp = scm_downcase((unsigned int )((int )*s1));
#line 178
    tmp___0 = scm_downcase((unsigned int )((int )*s2));
    }
#line 178
    if (tmp != tmp___0) {
#line 179
      return (0);
    } else {
#line 182
      s1 ++;
#line 183
      s2 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 185
  if (*s1) {
#line 185
    tmp___1 = 0;
  } else
#line 185
  if (*s2) {
#line 185
    tmp___1 = 0;
  } else {
#line 185
    tmp___1 = 1;
  }
#line 185
  return (tmp___1);
}
}
#line 193
static SCM recsexpr(SCM obj , int line , int column , SCM filename ) ;
#line 195 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/read.c"
static SCM recsexpr(SCM obj , int line , int column , SCM filename ) 
{ 
  SCM tmp ;
  SCM copy ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  SCM tmp___2 ;
  register SCM w ;
  SCM tmp___3 ;
  SCM tmp___4 ;
  SCM tmp___5 ;

  {
#line 202
  if (6 & (int )obj) {
#line 203
    return (obj);
  } else
#line 202
  if (1 & (int )((scm_cell *)obj)->car) {
#line 203
    return (obj);
  }
  {
#line 205
  tmp = obj;
#line 209
  tmp___5 = scm_hash_fn_ref(scm_sys_protects[16], obj, (long )(16 << 9) + 372L, (unsigned int (*)())(& scm_ihashq),
                            (SCM (*)())(& scm_sloppy_assq), (void *)0);
  }
#line 209
  if ((long )(16 << 9) + 372L == tmp___5) {
#line 211
    if (scm_read_opts[0].val) {
      {
#line 213
      tmp___0 = recsexpr(((scm_cell *)obj)->car, line, column, filename);
#line 213
      copy = scm_cons(tmp___0, (long )(18 << 9) + 372L);
      }
      {
#line 215
      while (1) {
        while_continue: /* CIL Label */ ;
#line 215
        tmp = ((scm_cell *)tmp)->cdr;
#line 215
        if (6 & (int )tmp) {
#line 215
          goto while_break;
        } else
#line 215
        if (! (! (1 & (int )((scm_cell *)tmp)->car))) {
#line 215
          goto while_break;
        }
        {
#line 217
        tmp___1 = recsexpr(((scm_cell *)tmp)->car, line, column, filename);
#line 217
        tmp___2 = scm_cons(tmp___1, (long )(18 << 9) + 372L);
#line 217
        ((scm_cell *)copy)->cdr = tmp___2;
#line 222
        copy = ((scm_cell *)copy)->cdr;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 224
      ((scm_cell *)copy)->cdr = tmp;
    } else {
      {
#line 228
      recsexpr(((scm_cell *)obj)->car, line, column, filename);
      }
      {
#line 229
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 229
        tmp = ((scm_cell *)tmp)->cdr;
#line 229
        if (6 & (int )tmp) {
#line 229
          goto while_break___0;
        } else
#line 229
        if (! (! (1 & (int )((scm_cell *)tmp)->car))) {
#line 229
          goto while_break___0;
        }
        {
#line 230
        recsexpr(((scm_cell *)tmp)->car, line, column, filename);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 231
      copy = (long )(18 << 9) + 372L;
    }
    {
#line 233
    w = scm_sys_protects[16];
#line 233
    tmp___3 = scm_hash_fn_create_handle_x(w, obj, (long )(21 << 9) + 372L, (unsigned int (*)())(& scm_ihashq),
                                          (SCM (*)())(& scm_sloppy_assq), (void *)0);
#line 233
    tmp___4 = scm_make_srcprops(line, column, filename, copy, (long )(20 << 9) + 372L);
#line 233
    ((scm_cell *)tmp___3)->cdr = tmp___4;
    }
  }
#line 241
  return (obj);
}
}
#line 249 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/read.c"
static void skip_scsh_block_comment(SCM port ) 
{ 
  char last_c ;
  int c ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 253
  last_c = (char )'\000';
  {
#line 255
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 257
    tmp = scm_gen_getc(port);
#line 257
    c = tmp;
    }
#line 259
    if (c == -1) {
      {
#line 260
      scm_wta((long )(18 << 9) + 372L, (char *)"unterminated `#! ... !#\' comment",
              (char *)"read");
      }
    } else
#line 262
    if (c == 35) {
#line 262
      if ((int )last_c == 33) {
#line 263
        return;
      }
    }
#line 265
    last_c = (char )c;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 270 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/read.c"
static char s_list[5]  = {      (char )'l',      (char )'i',      (char )'s',      (char )'t', 
        (char )'\000'};
#line 272 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/read.c"
SCM scm_lreadr(SCM *tok_buf___0 , SCM port , int case_i , SCM sharp , SCM *copy ) 
{ 
  int c ;
  size_t j ;
  SCM p ;
  SCM tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  SCM tmp___2 ;
  register SCM w ;
  SCM tmp___3 ;
  SCM tmp___4 ;
  SCM tmp___5 ;
  SCM tmp___6 ;
  SCM tmp___7 ;
  SCM tmp___8 ;
  int tmp___9 ;
  int line ;
  int column ;
  SCM got ;
  SCM tmp___10 ;
  SCM tmp___11 ;
  int len ;
  SCM str ;
  int tmp___12 ;
  SCM tmp___13 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
  tryagain: 
  {
#line 285
  c = scm_flush_ws(port, s_read);
  }
  tryagain_no_flush_ws: 
  {
#line 289
  if (c == -1) {
#line 289
    goto case_neg_1;
  }
#line 292
  if (c == 40) {
#line 292
    goto case_40;
  }
#line 296
  if (c == 41) {
#line 296
    goto case_41;
  }
#line 300
  if (c == 39) {
#line 300
    goto case_39;
  }
#line 303
  if (c == 96) {
#line 303
    goto case_96;
  }
#line 306
  if (c == 44) {
#line 306
    goto case_44;
  }
#line 332
  if (c == 35) {
#line 332
    goto case_35;
  }
#line 425
  if (c == 34) {
#line 425
    goto case_34;
  }
#line 493
  if (c == 43) {
#line 493
    goto num;
  }
#line 493
  if (c == 45) {
#line 493
    goto num;
  }
#line 493
  if (c == 46) {
#line 493
    goto num;
  }
#line 493
  if (c == 57) {
#line 493
    goto num;
  }
#line 493
  if (c == 56) {
#line 493
    goto num;
  }
#line 493
  if (c == 55) {
#line 493
    goto num;
  }
#line 493
  if (c == 54) {
#line 493
    goto num;
  }
#line 493
  if (c == 53) {
#line 493
    goto num;
  }
#line 493
  if (c == 52) {
#line 493
    goto num;
  }
#line 493
  if (c == 51) {
#line 493
    goto num;
  }
#line 493
  if (c == 50) {
#line 493
    goto num;
  }
#line 493
  if (c == 49) {
#line 493
    goto num;
  }
#line 493
  if (c == 48) {
#line 493
    goto num;
  }
#line 511
  if (c == 58) {
#line 511
    goto case_58;
  }
#line 518
  goto switch_default___0;
  case_neg_1: /* CIL Label */ 
#line 290
  return ((long )(19 << 9) + 372L);
  case_40: /* CIL Label */ 
#line 293
  if (scm_read_opts[1].val) {
    {
#line 293
    tmp = scm_lreadrecparen(tok_buf___0, port, s_list, case_i, sharp, copy);
#line 293
    tmp___1 = tmp;
    }
  } else {
    {
#line 293
    tmp___0 = scm_lreadparen(tok_buf___0, port, s_list, case_i, sharp, copy);
#line 293
    tmp___1 = tmp___0;
    }
  }
#line 293
  return (tmp___1);
  case_41: /* CIL Label */ 
  {
#line 297
  scm_wta((long )(18 << 9) + 372L, (char *)"unexpected \")\"", (char *)"read");
  }
#line 298
  goto tryagain;
  case_39: /* CIL Label */ 
#line 301
  p = scm_i_quote;
#line 302
  goto recquote;
  case_96: /* CIL Label */ 
#line 304
  p = scm_i_quasiquote;
#line 305
  goto recquote;
  case_44: /* CIL Label */ 
  {
#line 307
  c = scm_gen_getc(port);
  }
#line 308
  if (64 == c) {
#line 309
    p = scm_i_uq_splicing;
  } else {
    {
#line 312
    scm_gen_ungetc(c, port);
#line 313
    p = scm_i_unquote;
    }
  }
  recquote: 
  {
#line 316
  tmp___2 = scm_lreadr(tok_buf___0, port, case_i, sharp, copy);
#line 316
  p = scm_cons2(p, tmp___2, (long )(20 << 9) + 372L);
  }
#line 319
  if (scm_read_opts[1].val) {
    {
#line 320
    w = scm_sys_protects[16];
#line 320
    tmp___3 = scm_hash_fn_create_handle_x(w, p, (long )(21 << 9) + 372L, (unsigned int (*)())(& scm_ihashq),
                                          (SCM (*)())(& scm_sloppy_assq), (void *)0);
    }
#line 320
    if (scm_read_opts[0].val) {
      {
#line 320
      tmp___4 = scm_cons2(((scm_cell *)p)->car, ((scm_cell *)((scm_cell *)p)->cdr)->car,
                          (long )(20 << 9) + 372L);
#line 320
      *copy = tmp___4;
#line 320
      tmp___5 = tmp___4;
      }
    } else {
#line 320
      tmp___5 = (long )(18 << 9) + 372L;
    }
    {
#line 320
    tmp___6 = scm_make_srcprops(((struct scm_port_table *)((scm_cell *)port)->cdr)->line_number,
                                ((struct scm_port_table *)((scm_cell *)port)->cdr)->column_number - 1,
                                ((struct scm_port_table *)((scm_cell *)port)->cdr)->file_name,
                                tmp___5, (long )(20 << 9) + 372L);
#line 320
    ((scm_cell *)tmp___3)->cdr = tmp___6;
    }
  }
#line 331
  return (p);
  case_35: /* CIL Label */ 
  {
#line 333
  c = scm_gen_getc(port);
  }
  {
#line 336
  if (c == 40) {
#line 336
    goto case_40___0;
  }
#line 341
  if (c == 84) {
#line 341
    goto case_84;
  }
#line 341
  if (c == 116) {
#line 341
    goto case_84;
  }
#line 344
  if (c == 70) {
#line 344
    goto case_70;
  }
#line 344
  if (c == 102) {
#line 344
    goto case_70;
  }
#line 358
  if (c == 69) {
#line 358
    goto case_69;
  }
#line 358
  if (c == 101) {
#line 358
    goto case_69;
  }
#line 358
  if (c == 73) {
#line 358
    goto case_69;
  }
#line 358
  if (c == 105) {
#line 358
    goto case_69;
  }
#line 358
  if (c == 88) {
#line 358
    goto case_69;
  }
#line 358
  if (c == 120) {
#line 358
    goto case_69;
  }
#line 358
  if (c == 68) {
#line 358
    goto case_69;
  }
#line 358
  if (c == 100) {
#line 358
    goto case_69;
  }
#line 358
  if (c == 79) {
#line 358
    goto case_69;
  }
#line 358
  if (c == 111) {
#line 358
    goto case_69;
  }
#line 358
  if (c == 66) {
#line 358
    goto case_69;
  }
#line 358
  if (c == 98) {
#line 358
    goto case_69;
  }
#line 363
  if (c == 33) {
#line 363
    goto case_33;
  }
#line 371
  if (c == 42) {
#line 371
    goto case_42;
  }
#line 379
  if (c == 123) {
#line 379
    goto case_123;
  }
#line 386
  if (c == 92) {
#line 386
    goto case_92;
  }
#line 404
  goto callshrp;
  case_40___0: /* CIL Label */ 
  {
#line 337
  p = scm_lreadparen(tok_buf___0, port, (char *)"vector", case_i, sharp, copy);
  }
#line 338
  if ((long )(20 << 9) + 372L == p) {
#line 338
    tmp___8 = scm_sys_protects[3];
  } else {
    {
#line 338
    tmp___7 = scm_vector(p);
#line 338
    tmp___8 = tmp___7;
    }
  }
#line 338
  return (tmp___8);
  case_84: /* CIL Label */ 
  case_116: /* CIL Label */ 
#line 342
  return ((long )(17 << 9) + 372L);
  case_70: /* CIL Label */ 
  case_102: /* CIL Label */ 
#line 345
  return ((long )(16 << 9) + 372L);
  case_69: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_98: /* CIL Label */ 
  {
#line 359
  scm_gen_ungetc(c, port);
#line 360
  c = '#';
  }
#line 361
  goto num;
  case_33: /* CIL Label */ 
  {
#line 366
  skip_scsh_block_comment(port);
#line 368
  c = scm_flush_ws(port, (char *)((void *)0));
  }
#line 369
  goto tryagain_no_flush_ws;
  case_42: /* CIL Label */ 
  {
#line 372
  j = scm_read_token(c, tok_buf___0, port, case_i, 0);
#line 373
  p = scm_istr2bve((char *)((scm_cell *)*tok_buf___0)->cdr + 1, (long )(j - 1UL));
  }
#line 374
  if ((long )(16 << 9) + 372L != p) {
#line 375
    return (p);
  } else {
#line 377
    goto unkshrp;
  }
  case_123: /* CIL Label */ 
  {
#line 380
  j = scm_read_token(c, tok_buf___0, port, case_i, 1);
#line 381
  p = scm_intern((char *)((scm_cell *)*tok_buf___0)->cdr, j);
  }
#line 382
  if ((unsigned int )((struct scm_port_table *)((scm_cell *)port)->cdr)->representation != 0U) {
    {
#line 383
    scm_set_symbol_multi_byte_x(((scm_cell *)p)->car, (long )(17 << 9) + 372L);
    }
  }
#line 384
  return (((scm_cell *)p)->car);
  case_92: /* CIL Label */ 
  {
#line 387
  c = scm_gen_getc(port);
#line 388
  j = scm_read_token(c, tok_buf___0, port, case_i, 0);
  }
#line 389
  if (j == 1UL) {
#line 390
    return ((SCM )((c << 8) + 244));
  }
#line 391
  if (c >= 48) {
#line 391
    if (c < 56) {
      {
#line 393
      p = scm_istr2int((char *)((scm_cell *)*tok_buf___0)->cdr, (long )j, 8L);
      }
#line 394
      if ((long )(16 << 9) + 372L != p) {
#line 395
        return (((p >> 2) << 8) + 244L);
      }
    }
  }
#line 397
  c = 0;
  {
#line 397
  while (1) {
    while_continue: /* CIL Label */ ;
#line 397
    if (! (c < scm_n_charnames)) {
#line 397
      goto while_break;
    }
#line 398
    if (scm_charnames[c]) {
      {
#line 398
      tmp___9 = scm_casei_streq(scm_charnames[c], (char *)((scm_cell *)*tok_buf___0)->cdr);
      }
#line 398
      if (tmp___9) {
#line 400
        return ((SCM )(((int )scm_charnums[c] << 8) + 244));
      }
    }
#line 397
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 401
  scm_wta((long )(18 << 9) + 372L, (char *)"unknown # object: #\\", (char *)((scm_cell *)*tok_buf___0)->cdr);
  }
  callshrp: 
  switch_default: /* CIL Label */ 
#line 406
  if (! (6 & (int )sharp)) {
    {
#line 408
    line = ((struct scm_port_table *)((scm_cell *)port)->cdr)->line_number;
#line 409
    column = ((struct scm_port_table *)((scm_cell *)port)->cdr)->column_number - 2;
#line 411
    tmp___10 = scm_acons(port, (long )(20 << 9) + 372L, (long )(20 << 9) + 372L);
#line 411
    got = scm_apply(sharp, (SCM )((c << 8) + 244), tmp___10);
    }
#line 414
    if ((long )(21 << 9) + 372L == got) {
#line 415
      goto unkshrp;
    }
#line 416
    if (scm_read_opts[1].val) {
      {
#line 417
      tmp___11 = recsexpr(got, line, column, ((struct scm_port_table *)((scm_cell *)port)->cdr)->file_name);
#line 417
      *copy = tmp___11;
      }
#line 417
      return (tmp___11);
    } else {
#line 420
      return (got);
    }
  }
  unkshrp: 
  {
#line 422
  scm_wta((SCM )((c << 8) + 244), (char *)"unknown # object", (char *)"");
  }
  switch_break___0: /* CIL Label */ ;
  }
  case_34: /* CIL Label */ 
#line 426
  j = (size_t )0;
  {
#line 427
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 427
    c = scm_gen_getc(port);
    }
#line 427
    if (! (34 != c)) {
#line 427
      goto while_break___0;
    }
#line 429
    if (! (-1 != c)) {
      {
#line 429
      scm_wta((long )(18 << 9) + 372L, (char *)"end of file in ", (char *)"string");
      }
    }
    {
#line 431
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 431
      if (! ((j + sizeof(xwchar_t )) + 4UL >= (unsigned long )((scm_cell *)*tok_buf___0)->car >> 8)) {
#line 431
        goto while_break___1;
      }
      {
#line 432
      scm_grow_tok_buf(tok_buf___0);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 434
    if (c == 92) {
      {
#line 435
      c = scm_gen_getc(port);
      }
      {
#line 437
      if (c == 10) {
#line 437
        goto case_10;
      }
#line 439
      if (c == 48) {
#line 439
        goto case_48;
      }
#line 442
      if (c == 102) {
#line 442
        goto case_102___0;
      }
#line 445
      if (c == 110) {
#line 445
        goto case_110;
      }
#line 448
      if (c == 114) {
#line 448
        goto case_114;
      }
#line 451
      if (c == 116) {
#line 451
        goto case_116___0;
      }
#line 454
      if (c == 97) {
#line 454
        goto case_97;
      }
#line 457
      if (c == 118) {
#line 457
        goto case_118;
      }
#line 435
      goto switch_break___1;
      case_10: /* CIL Label */ 
#line 438
      goto while_continue___0;
      case_48: /* CIL Label */ 
#line 440
      c = '\000';
#line 441
      goto switch_break___1;
      case_102___0: /* CIL Label */ 
#line 443
      c = '\f';
#line 444
      goto switch_break___1;
      case_110: /* CIL Label */ 
#line 446
      c = '\n';
#line 447
      goto switch_break___1;
      case_114: /* CIL Label */ 
#line 449
      c = '\r';
#line 450
      goto switch_break___1;
      case_116___0: /* CIL Label */ 
#line 452
      c = '\t';
#line 453
      goto switch_break___1;
      case_97: /* CIL Label */ 
#line 455
      c = '\a';
#line 456
      goto switch_break___1;
      case_118: /* CIL Label */ 
#line 458
      c = '\v';
#line 459
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
    }
#line 461
    if ((unsigned int )((struct scm_port_table *)((scm_cell *)port)->cdr)->representation == 0U) {
#line 463
      *((char *)((scm_cell *)*tok_buf___0)->cdr + j) = (char )c;
#line 464
      j ++;
    } else {
      {
#line 469
      len = xwctomb((char *)((scm_cell *)*tok_buf___0)->cdr + j, c);
      }
#line 470
      if (len == 0) {
#line 471
        len = 1;
      }
#line 472
      if (! (len > 0)) {
        {
#line 472
        scm_wta((long )(c << 2) + 2L, (char *)"bogus char", (char *)"read");
        }
      }
#line 473
      j += (size_t )len;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 476
  if (j == 0UL) {
#line 477
    return (scm_sys_protects[4]);
  }
  {
#line 478
  *((char *)((scm_cell *)*tok_buf___0)->cdr + j) = (char)0;
#line 481
  str = scm_makfromstr((char const   *)((char *)((scm_cell *)*tok_buf___0)->cdr),
                       j, 0);
  }
#line 482
  if ((unsigned int )((struct scm_port_table *)((scm_cell *)port)->cdr)->representation != 0U) {
#line 484
    ((scm_cell *)str)->car = (SCM )((((unsigned long )((scm_cell *)str)->car >> 8) << 8) + 23UL);
  }
#line 486
  return (str);
  num: 
  case_43: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_46: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48___0: /* CIL Label */ 
  {
#line 495
  j = scm_read_token(c, tok_buf___0, port, case_i, 0);
#line 496
  p = scm_istring2number((char *)((scm_cell *)*tok_buf___0)->cdr, (long )j, 10L);
  }
#line 497
  if ((long )(16 << 9) + 372L != p) {
#line 498
    return (p);
  }
#line 499
  if (c == 35) {
#line 501
    if (j == 2UL) {
      {
#line 501
      tmp___12 = scm_gen_getc(port);
      }
#line 501
      if (tmp___12 == 40) {
        {
#line 503
        scm_gen_ungetc('(', port);
#line 504
        c = (int )*((char *)((scm_cell *)*tok_buf___0)->cdr + 1);
        }
#line 505
        goto callshrp;
      }
    }
    {
#line 507
    scm_wta((long )(18 << 9) + 372L, (char *)"unknown # object", (char *)((scm_cell *)*tok_buf___0)->cdr);
    }
  }
#line 509
  goto tok;
  case_58: /* CIL Label */ 
  {
#line 512
  j = scm_read_token('-', tok_buf___0, port, case_i, 0);
#line 513
  p = scm_intern((char *)((scm_cell *)*tok_buf___0)->cdr, j);
  }
#line 514
  if ((unsigned int )((struct scm_port_table *)((scm_cell *)port)->cdr)->representation != 0U) {
    {
#line 515
    scm_set_symbol_multi_byte_x(((scm_cell *)p)->car, (long )(17 << 9) + 372L);
    }
  }
  {
#line 516
  tmp___13 = scm_make_keyword_from_dash_symbol(((scm_cell *)p)->car);
  }
#line 516
  return (tmp___13);
  switch_default___0: /* CIL Label */ 
  {
#line 519
  j = scm_read_token(c, tok_buf___0, port, case_i, 0);
  }
  tok: 
  {
#line 523
  p = scm_intern((char *)((scm_cell *)*tok_buf___0)->cdr, j);
  }
#line 524
  if ((unsigned int )((struct scm_port_table *)((scm_cell *)port)->cdr)->representation != 0U) {
    {
#line 525
    scm_set_symbol_multi_byte_x(((scm_cell *)p)->car, (long )(17 << 9) + 372L);
    }
  }
#line 526
  return (((scm_cell *)p)->car);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 534 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/read.c"
size_t scm_read_token(int ic , SCM *tok_buf___0 , SCM port , int case_i , int weird ) 
{ 
  register size_t j ;
  register int c ;
  register char *p ;
  int len ;
  int tmp ;
  int len___0 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 546
  c = ic;
#line 547
  p = (char *)((scm_cell *)*tok_buf___0)->cdr;
#line 549
  if (weird) {
#line 550
    j = (size_t )0;
  } else {
#line 553
    j = (size_t )0;
    {
#line 554
    while (1) {
      while_continue: /* CIL Label */ ;
#line 554
      if (! ((j + sizeof(xwchar_t )) + 4UL >= (unsigned long )((scm_cell *)*tok_buf___0)->car >> 8)) {
#line 554
        goto while_break;
      }
      {
#line 555
      p = scm_grow_tok_buf(tok_buf___0);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 556
    if ((unsigned int )((struct scm_port_table *)((scm_cell *)port)->cdr)->representation == 0U) {
#line 558
      *(p + j) = (char )c;
#line 559
      j ++;
    } else {
      {
#line 564
      len = xwctomb(p + j, c);
      }
#line 565
      if (len == 0) {
#line 566
        len = 1;
      }
#line 567
      if (! (len > 0)) {
        {
#line 567
        scm_wta((long )(c << 2) + 2L, (char *)"bogus char", (char *)"read");
        }
      }
#line 568
      j += (size_t )len;
    }
  }
  {
#line 572
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 574
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 574
      if (! ((j + sizeof(xwchar_t )) + 4UL >= (unsigned long )((scm_cell *)*tok_buf___0)->car >> 8)) {
#line 574
        goto while_break___1;
      }
      {
#line 575
      p = scm_grow_tok_buf(tok_buf___0);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 576
    c = scm_gen_getc(port);
    }
    {
#line 584
    if (c == 10) {
#line 584
      goto case_10;
    }
#line 584
    if (c == 9) {
#line 584
      goto case_10;
    }
#line 584
    if (c == 12) {
#line 584
      goto case_10;
    }
#line 584
    if (c == 13) {
#line 584
      goto case_10;
    }
#line 584
    if (c == 32) {
#line 584
      goto case_10;
    }
#line 584
    if (c == 59) {
#line 584
      goto case_10;
    }
#line 584
    if (c == 34) {
#line 584
      goto case_10;
    }
#line 584
    if (c == 41) {
#line 584
      goto case_10;
    }
#line 584
    if (c == 40) {
#line 584
      goto case_10;
    }
#line 589
    if (c == -1) {
#line 589
      goto eof_case;
    }
#line 593
    if (c == 92) {
#line 593
      goto case_92;
    }
#line 604
    if (c == 125) {
#line 604
      goto case_125;
    }
#line 621
    goto default_case;
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_12: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_59: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_41: /* CIL Label */ 
    case_40: /* CIL Label */ 
#line 585
    if (weird) {
#line 586
      goto default_case;
    }
    {
#line 588
    scm_gen_ungetc(c, port);
    }
    eof_case: 
    case_neg_1: /* CIL Label */ 
#line 591
    *(p + j) = (char)0;
#line 592
    return (j);
    case_92: /* CIL Label */ 
#line 594
    if (! weird) {
#line 595
      goto default_case;
    } else {
      {
#line 598
      c = scm_gen_getc(port);
      }
#line 599
      if (c == -1) {
#line 600
        goto eof_case;
      } else {
#line 602
        goto default_case;
      }
    }
    case_125: /* CIL Label */ 
#line 605
    if (! weird) {
#line 606
      goto default_case;
    }
    {
#line 608
    c = scm_gen_getc(port);
    }
#line 609
    if (c == 35) {
#line 611
      *(p + j) = (char)0;
#line 612
      return (j);
    } else {
      {
#line 616
      scm_gen_ungetc(c, port);
#line 617
      c = '}';
      }
#line 618
      goto default_case;
    }
    default_case: 
    switch_default: /* CIL Label */ 
#line 624
    if (case_i) {
      {
#line 624
      tmp = scm_downcase((unsigned int )c);
#line 624
      c = tmp;
      }
    } else {
#line 624
      c = c;
    }
#line 625
    if ((unsigned int )((struct scm_port_table *)((scm_cell *)port)->cdr)->representation == 0U) {
#line 627
      *(p + j) = (char )c;
#line 628
      j ++;
    } else {
      {
#line 633
      len___0 = xwctomb(p + j, c);
      }
#line 634
      if (len___0 == 0) {
#line 635
        len___0 = 1;
      }
#line 636
      if (! (len___0 > 0)) {
        {
#line 636
        scm_wta((long )(c << 2) + 2L, (char *)"bogus char", (char *)"read");
        }
      }
#line 637
      j += (size_t )len___0;
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 649 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/read.c"
SCM scm_lreadparen(SCM *tok_buf___0 , SCM port , char *name , int case_i , SCM sharp ,
                   SCM *copy ) 
{ 
  SCM tmp ;
  SCM tl ;
  SCM ans ;
  int c ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 663
  c = scm_flush_ws(port, name);
  }
#line 664
  if (41 == c) {
#line 665
    return ((long )(20 << 9) + 372L);
  }
  {
#line 666
  scm_gen_ungetc(c, port);
#line 667
  tmp = scm_lreadr(tok_buf___0, port, case_i, sharp, copy);
  }
#line 667
  if (scm_i_dot == tmp) {
    {
#line 669
    ans = scm_lreadr(tok_buf___0, port, case_i, sharp, copy);
    }
    closeit: 
    {
#line 671
    c = scm_flush_ws(port, name);
    }
#line 671
    if (41 != c) {
      {
#line 672
      scm_wta((long )(18 << 9) + 372L, (char *)"missing close paren", (char *)"");
      }
    }
#line 673
    return (ans);
  }
  {
#line 675
  tl = scm_cons(tmp, (long )(20 << 9) + 372L);
#line 675
  ans = tl;
  }
  {
#line 676
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 676
    c = scm_flush_ws(port, name);
    }
#line 676
    if (! (41 != c)) {
#line 676
      goto while_break;
    }
    {
#line 678
    scm_gen_ungetc(c, port);
#line 679
    tmp = scm_lreadr(tok_buf___0, port, case_i, sharp, copy);
    }
#line 679
    if (scm_i_dot == tmp) {
      {
#line 681
      tmp___0 = scm_lreadr(tok_buf___0, port, case_i, sharp, copy);
#line 681
      ((scm_cell *)tl)->cdr = tmp___0;
      }
#line 682
      goto closeit;
    }
    {
#line 684
    tmp___1 = scm_cons(tmp, (long )(20 << 9) + 372L);
#line 684
    ((scm_cell *)tl)->cdr = tmp___1;
#line 685
    tl = ((scm_cell *)tl)->cdr;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 687
  return (ans);
}
}
#line 691 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/read.c"
SCM scm_lreadrecparen(SCM *tok_buf___0 , SCM port , char *name , int case_i , SCM sharp ,
                      SCM *copy ) 
{ 
  register int c ;
  register SCM tmp ;
  register SCM tl ;
  register SCM tl2 ;
  SCM ans ;
  SCM ans2 ;
  int line ;
  int column ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  SCM tmp___2 ;
  SCM tmp___3 ;
  SCM tmp___4 ;
  SCM tmp___5 ;
  SCM tmp___6 ;
  SCM tmp___7 ;
  register SCM w ;
  SCM tmp___8 ;
  SCM tmp___9 ;
  SCM tmp___10 ;
  SCM tmp___11 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
  {
#line 702
  tl2 = (long )(20 << 9) + 372L;
#line 703
  ans2 = (long )(20 << 9) + 372L;
#line 705
  line = ((struct scm_port_table *)((scm_cell *)port)->cdr)->line_number;
#line 706
  column = ((struct scm_port_table *)((scm_cell *)port)->cdr)->column_number - 1;
#line 708
  c = scm_flush_ws(port, name);
  }
#line 709
  if (41 == c) {
#line 710
    return ((long )(20 << 9) + 372L);
  }
  {
#line 711
  scm_gen_ungetc(c, port);
#line 712
  tmp = scm_lreadr(tok_buf___0, port, case_i, sharp, copy);
  }
#line 712
  if (scm_i_dot == tmp) {
    {
#line 714
    ans = scm_lreadr(tok_buf___0, port, case_i, sharp, copy);
#line 715
    c = scm_flush_ws(port, name);
    }
#line 715
    if (41 != c) {
      {
#line 716
      scm_wta((long )(18 << 9) + 372L, (char *)"missing close paren", (char *)"");
      }
    }
#line 717
    return (ans);
  }
  {
#line 720
  tl = scm_cons(tmp, (long )(20 << 9) + 372L);
#line 720
  ans = tl;
  }
#line 721
  if (scm_read_opts[0].val) {
#line 722
    if (! (6 & (int )tmp)) {
#line 722
      if (! (1 & (int )((scm_cell *)tmp)->car)) {
#line 722
        tmp___0 = *copy;
      } else {
#line 722
        tmp___0 = tmp;
      }
    } else {
#line 722
      tmp___0 = tmp;
    }
    {
#line 722
    tl2 = scm_cons(tmp___0, (long )(20 << 9) + 372L);
#line 722
    ans2 = tl2;
    }
  }
  {
#line 726
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 726
    c = scm_flush_ws(port, name);
    }
#line 726
    if (! (41 != c)) {
#line 726
      goto while_break;
    }
    {
#line 728
    scm_gen_ungetc(c, port);
#line 729
    tmp = scm_lreadr(tok_buf___0, port, case_i, sharp, copy);
    }
#line 729
    if (scm_i_dot == tmp) {
      {
#line 731
      tmp = scm_lreadr(tok_buf___0, port, case_i, sharp, copy);
#line 731
      ((scm_cell *)tl)->cdr = tmp;
      }
#line 732
      if (scm_read_opts[0].val) {
#line 733
        if (! (6 & (int )tmp)) {
#line 733
          if (! (1 & (int )((scm_cell *)tmp)->car)) {
#line 733
            tmp___1 = *copy;
          } else {
#line 733
            tmp___1 = tmp;
          }
        } else {
#line 733
          tmp___1 = tmp;
        }
        {
#line 733
        tmp___2 = scm_cons(tmp___1, (long )(20 << 9) + 372L);
#line 733
        ((scm_cell *)tl2)->cdr = tmp___2;
        }
      }
      {
#line 737
      c = scm_flush_ws(port, name);
      }
#line 737
      if (41 != c) {
        {
#line 738
        scm_wta((long )(18 << 9) + 372L, (char *)"missing close paren", (char *)"");
        }
      }
#line 739
      goto exit;
    }
    {
#line 741
    tmp___4 = scm_cons(tmp, (long )(20 << 9) + 372L);
#line 741
    tmp___3 = tmp___4;
#line 741
    ((scm_cell *)tl)->cdr = tmp___3;
#line 741
    tl = tmp___3;
    }
#line 742
    if (scm_read_opts[0].val) {
#line 743
      if (! (6 & (int )tmp)) {
#line 743
        if (! (1 & (int )((scm_cell *)tmp)->car)) {
#line 743
          tmp___6 = *copy;
        } else {
#line 743
          tmp___6 = tmp;
        }
      } else {
#line 743
        tmp___6 = tmp;
      }
      {
#line 743
      tmp___7 = scm_cons(tmp___6, (long )(20 << 9) + 372L);
#line 743
      tmp___5 = tmp___7;
#line 743
      ((scm_cell *)tl2)->cdr = tmp___5;
#line 743
      tl2 = tmp___5;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  exit: 
  {
#line 749
  w = scm_sys_protects[16];
#line 749
  tmp___8 = scm_hash_fn_create_handle_x(w, ans, (long )(21 << 9) + 372L, (unsigned int (*)())(& scm_ihashq),
                                        (SCM (*)())(& scm_sloppy_assq), (void *)0);
  }
#line 749
  if (scm_read_opts[0].val) {
#line 749
    tmp___9 = ans2;
#line 749
    *copy = tmp___9;
#line 749
    tmp___10 = tmp___9;
  } else {
#line 749
    tmp___10 = (long )(18 << 9) + 372L;
  }
  {
#line 749
  tmp___11 = scm_make_srcprops(line, column, ((struct scm_port_table *)((scm_cell *)port)->cdr)->file_name,
                               tmp___10, (long )(20 << 9) + 372L);
#line 749
  ((scm_cell *)tmp___8)->cdr = tmp___11;
  }
#line 758
  return (ans);
}
}
#line 766 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/read.c"
void scm_init_read(void) 
{ 


  {
  {
#line 769
  scm_init_opts(& scm_read_options, scm_read_opts, 2);
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/read.x"
  scm_make_gsubr(s_read_options, 0, 1, 0, (SCM (*)())(& scm_read_options));
#line 2
  scm_make_gsubr(s_read, 0, 3, 0, (SCM (*)())(& scm_read));
  }
#line 771 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/read.c"
  return;
}
}
#line 282 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.h"
SCM scm_less_p(SCM x , SCM y ) ;
#line 292
SCM scm_difference(SCM x , SCM y ) ;
#line 293
SCM scm_product(SCM x , SCM y ) ;
#line 295
SCM scm_divide(SCM x , SCM y ) ;
#line 50 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eq.h"
SCM scm_eq_p(SCM x , SCM y ) ;
#line 51 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.h"
int scm_ra_matchp(SCM ra0 , SCM ras ) ;
#line 52
int scm_ramapc(int (*cproc)() , SCM data , SCM ra0 , SCM lra , char *what ) ;
#line 53
int scm_array_fill_int(SCM ra , SCM fill , SCM ignore ) ;
#line 56
int scm_ra_eqp(SCM ra0 , SCM ras ) ;
#line 57
int scm_ra_lessp(SCM ra0 , SCM ras ) ;
#line 58
int scm_ra_leqp(SCM ra0 , SCM ras ) ;
#line 59
int scm_ra_grp(SCM ra0 , SCM ras ) ;
#line 60
int scm_ra_greqp(SCM ra0 , SCM ras ) ;
#line 61
int scm_ra_sum(SCM ra0 , SCM ras ) ;
#line 62
int scm_ra_difference(SCM ra0 , SCM ras ) ;
#line 63
int scm_ra_product(SCM ra0 , SCM ras ) ;
#line 64
int scm_ra_divide(SCM ra0 , SCM ras ) ;
#line 65
int scm_array_identity(SCM dst , SCM src ) ;
#line 66
SCM scm_array_map(SCM ra0 , SCM proc , SCM lra ) ;
#line 67
SCM scm_array_for_each(SCM proc , SCM ra0 , SCM lra ) ;
#line 68
SCM scm_array_index_map_x(SCM ra , SCM proc ) ;
#line 69
SCM scm_raequal(SCM ra0 , SCM ra1 ) ;
#line 71
void scm_init_ramap(void) ;
#line 67 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
static ra_iproc ra_rpsubrs[6] ;
#line 68
static ra_iproc ra_asubrs[5] ;
#line 92
static size_t cind(SCM ra , SCM inds ) ;
#line 94 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
static size_t cind(SCM ra , SCM inds ) 
{ 
  size_t i ;
  int k ;
  long *ve ;

  {
#line 101
  ve = (SCM *)((scm_cell *)inds)->cdr;
#line 102
  if (! (scm_tc16_array == (long )(65535 & (int )((scm_cell *)ra)->car))) {
#line 103
    return ((size_t )*ve);
  }
#line 104
  i = ((scm_array *)((scm_cell *)ra)->cdr)->base;
#line 105
  k = 0;
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    if (! ((size_t )k < (size_t )(((scm_cell *)ra)->car >> 17))) {
#line 105
      goto while_break;
    }
#line 106
    i += (size_t )((*(ve + k) - ((scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array )) + k)->lbnd) * ((scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array )) + k)->inc);
#line 105
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  return (i);
}
}
#line 119 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
int scm_ra_matchp(SCM ra0 , SCM ras ) 
{ 
  SCM ra1 ;
  scm_array_dim dims ;
  scm_array_dim *s0 ;
  scm_array_dim *s1 ;
  size_t bas0 ;
  int i ;
  int ndim ;
  int exact ;
  int tmp ;
  void *__cil_tmp12 ;

  {
#line 126
  s0 = & dims;
#line 128
  bas0 = (size_t )0;
#line 129
  ndim = 1;
#line 130
  exact = 2;
#line 131
  if (6 & (int )ra0) {
#line 131
    return (0);
  }
  {
#line 144
  if ((127 & (int )((scm_cell *)ra0)->car) == 53) {
#line 144
    goto case_53;
  }
#line 144
  if ((127 & (int )((scm_cell *)ra0)->car) == 47) {
#line 144
    goto case_53;
  }
#line 144
  if ((127 & (int )((scm_cell *)ra0)->car) == 45) {
#line 144
    goto case_53;
  }
#line 144
  if ((127 & (int )((scm_cell *)ra0)->car) == 79) {
#line 144
    goto case_53;
  }
#line 144
  if ((127 & (int )((scm_cell *)ra0)->car) == 37) {
#line 144
    goto case_53;
  }
#line 144
  if ((127 & (int )((scm_cell *)ra0)->car) == 71) {
#line 144
    goto case_53;
  }
#line 144
  if ((127 & (int )((scm_cell *)ra0)->car) == 21) {
#line 144
    goto case_53;
  }
#line 144
  if ((127 & (int )((scm_cell *)ra0)->car) == 13) {
#line 144
    goto case_53;
  }
#line 149
  if ((127 & (int )((scm_cell *)ra0)->car) == 127) {
#line 149
    goto case_127;
  }
#line 135
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 136
  return (0);
  case_53: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_21: /* CIL Label */ 
  case_13: /* CIL Label */ 
#line 145
  s0->lbnd = 0L;
#line 146
  s0->inc = 1L;
#line 147
  s0->ubnd = (long )((unsigned long )((scm_cell *)ra0)->car >> 8) - 1L;
#line 148
  goto switch_break;
  case_127: /* CIL Label */ 
#line 150
  if (! (scm_tc16_array == (long )(65535 & (int )((scm_cell *)ra0)->car))) {
#line 151
    return (0);
  }
#line 152
  ndim = (int )((size_t )(((scm_cell *)ra0)->car >> 17));
#line 153
  s0 = (scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array ));
#line 154
  bas0 = ((scm_array *)((scm_cell *)ra0)->cdr)->base;
#line 155
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    if (! (! (6 & (int )ras))) {
#line 157
      goto while_break;
    }
#line 160
    ra1 = ((scm_cell *)ras)->car;
#line 161
    if (6 & (int )ra1) {
#line 161
      return (0);
    }
    {
#line 175
    if ((127 & (int )((scm_cell *)ra1)->car) == 53) {
#line 175
      goto case_53___0;
    }
#line 175
    if ((127 & (int )((scm_cell *)ra1)->car) == 47) {
#line 175
      goto case_53___0;
    }
#line 175
    if ((127 & (int )((scm_cell *)ra1)->car) == 45) {
#line 175
      goto case_53___0;
    }
#line 175
    if ((127 & (int )((scm_cell *)ra1)->car) == 79) {
#line 175
      goto case_53___0;
    }
#line 175
    if ((127 & (int )((scm_cell *)ra1)->car) == 37) {
#line 175
      goto case_53___0;
    }
#line 175
    if ((127 & (int )((scm_cell *)ra1)->car) == 71) {
#line 175
      goto case_53___0;
    }
#line 175
    if ((127 & (int )((scm_cell *)ra1)->car) == 21) {
#line 175
      goto case_53___0;
    }
#line 175
    if ((127 & (int )((scm_cell *)ra1)->car) == 13) {
#line 175
      goto case_53___0;
    }
#line 195
    if ((127 & (int )((scm_cell *)ra1)->car) == 127) {
#line 195
      goto case_127___0;
    }
#line 166
    goto switch_default___0;
    switch_default___0: /* CIL Label */ 
#line 167
    return (0);
    case_53___0: /* CIL Label */ 
    case_47___0: /* CIL Label */ 
    case_45___0: /* CIL Label */ 
    case_79___0: /* CIL Label */ 
    case_37___0: /* CIL Label */ 
    case_71___0: /* CIL Label */ 
    case_21___0: /* CIL Label */ 
    case_13___0: /* CIL Label */ 
#line 176
    if (1 != ndim) {
#line 177
      return (0);
    }
    {
#line 180
    if (exact == 4) {
#line 180
      goto case_4;
    }
#line 183
    if (exact == 3) {
#line 183
      goto case_3;
    }
#line 186
    if (exact == 2) {
#line 186
      goto case_2;
    }
#line 190
    if (exact == 1) {
#line 190
      goto case_1;
    }
#line 178
    goto switch_break___1;
    case_4: /* CIL Label */ 
#line 181
    if (0UL != bas0) {
#line 182
      exact = 3;
    }
    case_3: /* CIL Label */ 
#line 184
    if (1L != s0->inc) {
#line 185
      exact = 2;
    }
    case_2: /* CIL Label */ 
#line 187
    if (0L == s0->lbnd) {
#line 187
      if ((unsigned long )s0->ubnd == ((unsigned long )((scm_cell *)ra1)->car >> 8) - 1UL) {
#line 188
        goto switch_break___1;
      }
    }
#line 189
    exact = 1;
    case_1: /* CIL Label */ 
#line 191
    if (s0->lbnd < 0L) {
#line 192
      return (0);
    } else
#line 191
    if ((unsigned long )s0->ubnd >= (unsigned long )((scm_cell *)ra1)->car >> 8) {
#line 192
      return (0);
    }
    switch_break___1: /* CIL Label */ ;
    }
#line 194
    goto switch_break___0;
    case_127___0: /* CIL Label */ 
#line 196
    if (! (scm_tc16_array == (long )(65535 & (int )((scm_cell *)ra1)->car))) {
#line 197
      return (0);
    } else
#line 196
    if ((size_t )ndim != (size_t )(((scm_cell *)ra1)->car >> 17)) {
#line 197
      return (0);
    }
#line 198
    s1 = (scm_array_dim *)((char *)((scm_cell *)ra1)->cdr + sizeof(scm_array ));
#line 199
    if (bas0 != ((scm_array *)((scm_cell *)ra1)->cdr)->base) {
#line 200
      exact = 3;
    }
#line 201
    i = 0;
    {
#line 201
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 201
      if (! (i < ndim)) {
#line 201
        goto while_break___0;
      }
      {
#line 205
      if (exact == 3) {
#line 205
        goto case_3___0;
      }
#line 205
      if (exact == 4) {
#line 205
        goto case_3___0;
      }
#line 208
      if (exact == 2) {
#line 208
        goto case_2___0;
      }
#line 212
      goto switch_default___1;
      case_3___0: /* CIL Label */ 
      case_4___0: /* CIL Label */ 
#line 206
      if ((s0 + i)->inc != (s1 + i)->inc) {
#line 207
        exact = 2;
      }
      case_2___0: /* CIL Label */ 
#line 209
      if ((s0 + i)->lbnd == (s1 + i)->lbnd) {
#line 209
        if ((s0 + i)->ubnd == (s1 + i)->ubnd) {
#line 210
          goto switch_break___2;
        }
      }
#line 211
      exact = 1;
      switch_default___1: /* CIL Label */ 
#line 213
      if ((s0 + i)->lbnd < (s1 + i)->lbnd) {
#line 213
        goto _L;
      } else
#line 213
      if ((s0 + i)->ubnd > (s1 + i)->ubnd) {
        _L: /* CIL Label */ 
#line 214
        if ((s0 + i)->lbnd <= (s0 + i)->ubnd) {
#line 214
          tmp = 0;
        } else {
#line 214
          tmp = 1;
        }
#line 214
        return (tmp);
      }
      switch_break___2: /* CIL Label */ ;
      }
#line 201
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 216
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 218
    ras = ((scm_cell *)ras)->cdr;
  }
  while_break: /* CIL Label */ ;
  }
#line 220
  return (exact);
}
}
#line 223 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
static char s_ra_mismatch[21]  = 
#line 223
  {      (char )'a',      (char )'r',      (char )'r',      (char )'a', 
        (char )'y',      (char )' ',      (char )'s',      (char )'h', 
        (char )'a',      (char )'p',      (char )'e',      (char )' ', 
        (char )'m',      (char )'i',      (char )'s',      (char )'m', 
        (char )'a',      (char )'t',      (char )'c',      (char )'h', 
        (char )'\000'};
#line 225 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
int scm_ramapc(int (*cproc)() , SCM data , SCM ra0 , SCM lra , char *what ) 
{ 
  SCM inds ;
  SCM z ;
  SCM vra0 ;
  SCM ra1 ;
  SCM vra1 ;
  SCM lvra ;
  SCM *plvra ;
  long *vinds ;
  int k ;
  int kmax ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  SCM y ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 238
  tmp = scm_ra_matchp(ra0, lra);
  }
  {
#line 245
  if (tmp == 4) {
#line 245
    goto case_4;
  }
#line 245
  if (tmp == 3) {
#line 245
    goto case_4;
  }
#line 245
  if (tmp == 2) {
#line 245
    goto case_4;
  }
#line 288
  if (tmp == 1) {
#line 288
    goto gencase;
  }
#line 240
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 242
  scm_wta(ra0, s_ra_mismatch, what);
  }
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 246
  if (scm_tc16_array == (long )(65535 & (int )((scm_cell *)ra0)->car)) {
#line 246
    kmax = (int )((size_t )(((scm_cell *)ra0)->car >> 17) - 1UL);
  } else {
#line 246
    kmax = 0;
  }
#line 247
  if (kmax < 0) {
#line 248
    goto gencase;
  }
  {
#line 249
  vra0 = scm_array_contents(ra0, (long )(18 << 9) + 372L);
  }
#line 250
  if (6 & (int )vra0) {
#line 250
    goto gencase;
  }
#line 252
  if (! (scm_tc16_array == (long )(65535 & (int )((scm_cell *)vra0)->car))) {
    {
#line 254
    vra1 = scm_make_ra(1);
#line 255
    ((scm_array *)((scm_cell *)vra1)->cdr)->base = (size_t )0;
#line 256
    ((scm_array_dim *)((char *)((scm_cell *)vra1)->cdr + sizeof(scm_array )))->lbnd = 0L;
#line 257
    ((scm_array_dim *)((char *)((scm_cell *)vra1)->cdr + sizeof(scm_array )))->ubnd = (long )(((unsigned long )((scm_cell *)vra0)->car >> 8) - 1UL);
#line 258
    ((scm_array_dim *)((char *)((scm_cell *)vra1)->cdr + sizeof(scm_array )))->inc = 1L;
#line 259
    ((scm_array *)((scm_cell *)vra1)->cdr)->v = vra0;
#line 260
    vra0 = vra1;
    }
  }
#line 262
  lvra = (long )(20 << 9) + 372L;
#line 263
  plvra = & lvra;
#line 264
  z = lra;
  {
#line 264
  while (1) {
    while_continue: /* CIL Label */ ;
#line 264
    if (! (! (6 & (int )z))) {
#line 264
      goto while_break;
    }
    {
#line 266
    ra1 = ((scm_cell *)z)->car;
#line 267
    vra1 = scm_make_ra(1);
#line 268
    ((scm_array_dim *)((char *)((scm_cell *)vra1)->cdr + sizeof(scm_array )))->lbnd = ((scm_array_dim *)((char *)((scm_cell *)vra0)->cdr + sizeof(scm_array )))->lbnd;
#line 269
    ((scm_array_dim *)((char *)((scm_cell *)vra1)->cdr + sizeof(scm_array )))->ubnd = ((scm_array_dim *)((char *)((scm_cell *)vra0)->cdr + sizeof(scm_array )))->ubnd;
    }
#line 270
    if (! (scm_tc16_array == (long )(65535 & (int )((scm_cell *)ra1)->car))) {
#line 272
      ((scm_array *)((scm_cell *)vra1)->cdr)->base = (size_t )0;
#line 273
      ((scm_array_dim *)((char *)((scm_cell *)vra1)->cdr + sizeof(scm_array )))->inc = 1L;
#line 274
      ((scm_array *)((scm_cell *)vra1)->cdr)->v = ra1;
    } else
#line 276
    if (! (65536 & (int )((scm_cell *)ra1)->car)) {
#line 277
      goto gencase;
    } else {
#line 280
      ((scm_array *)((scm_cell *)vra1)->cdr)->base = ((scm_array *)((scm_cell *)ra1)->cdr)->base;
#line 281
      ((scm_array_dim *)((char *)((scm_cell *)vra1)->cdr + sizeof(scm_array )))->inc = ((scm_array_dim *)((char *)((scm_cell *)ra1)->cdr + sizeof(scm_array )) + kmax)->inc;
#line 282
      ((scm_array *)((scm_cell *)vra1)->cdr)->v = ((scm_array *)((scm_cell *)ra1)->cdr)->v;
    }
    {
#line 284
    *plvra = scm_cons(vra1, (long )(20 << 9) + 372L);
#line 285
    plvra = & ((scm_cell *)*plvra)->cdr;
#line 264
    z = ((scm_cell *)z)->cdr;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 287
  if ((long )(18 << 9) + 372L == data) {
    {
#line 287
    tmp___0 = (*cproc)(vra0, lvra);
#line 287
    tmp___2 = tmp___0;
    }
  } else {
    {
#line 287
    tmp___1 = (*cproc)(vra0, data, lvra);
#line 287
    tmp___2 = tmp___1;
    }
  }
#line 287
  return (tmp___2);
  gencase: 
  case_1: /* CIL Label */ 
  {
#line 290
  vra0 = scm_make_ra(1);
  }
#line 291
  if (scm_tc16_array == (long )(65535 & (int )((scm_cell *)ra0)->car)) {
#line 294
    kmax = (int )((size_t )(((scm_cell *)ra0)->car >> 17) - 1UL);
#line 295
    if (kmax < 0) {
#line 297
      ((scm_array_dim *)((char *)((scm_cell *)vra0)->cdr + sizeof(scm_array )))->lbnd = 0L;
#line 298
      ((scm_array_dim *)((char *)((scm_cell *)vra0)->cdr + sizeof(scm_array )))->ubnd = 0L;
#line 299
      ((scm_array_dim *)((char *)((scm_cell *)vra0)->cdr + sizeof(scm_array )))->inc = 1L;
    } else {
#line 303
      ((scm_array_dim *)((char *)((scm_cell *)vra0)->cdr + sizeof(scm_array )))->lbnd = ((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )) + kmax)->lbnd;
#line 304
      ((scm_array_dim *)((char *)((scm_cell *)vra0)->cdr + sizeof(scm_array )))->ubnd = ((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )) + kmax)->ubnd;
#line 305
      ((scm_array_dim *)((char *)((scm_cell *)vra0)->cdr + sizeof(scm_array )))->inc = ((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )) + kmax)->inc;
    }
#line 307
    ((scm_array *)((scm_cell *)vra0)->cdr)->base = ((scm_array *)((scm_cell *)ra0)->cdr)->base;
#line 308
    ((scm_array *)((scm_cell *)vra0)->cdr)->v = ((scm_array *)((scm_cell *)ra0)->cdr)->v;
  } else {
#line 312
    kmax = 0;
#line 313
    ((scm_array_dim *)((char *)((scm_cell *)vra0)->cdr + sizeof(scm_array )))->lbnd = 0L;
#line 314
    ((scm_array_dim *)((char *)((scm_cell *)vra0)->cdr + sizeof(scm_array )))->ubnd = (long )(((unsigned long )((scm_cell *)ra0)->car >> 8) - 1UL);
#line 315
    ((scm_array_dim *)((char *)((scm_cell *)vra0)->cdr + sizeof(scm_array )))->inc = 1L;
#line 316
    ((scm_array *)((scm_cell *)vra0)->cdr)->base = (size_t )0;
#line 317
    ((scm_array *)((scm_cell *)vra0)->cdr)->v = ra0;
#line 318
    ra0 = vra0;
  }
#line 320
  lvra = (long )(20 << 9) + 372L;
#line 321
  plvra = & lvra;
#line 322
  z = lra;
  {
#line 322
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 322
    if (! (! (6 & (int )z))) {
#line 322
      goto while_break___0;
    }
    {
#line 324
    ra1 = ((scm_cell *)z)->car;
#line 325
    vra1 = scm_make_ra(1);
#line 326
    ((scm_array_dim *)((char *)((scm_cell *)vra1)->cdr + sizeof(scm_array )))->lbnd = ((scm_array_dim *)((char *)((scm_cell *)vra0)->cdr + sizeof(scm_array )))->lbnd;
#line 327
    ((scm_array_dim *)((char *)((scm_cell *)vra1)->cdr + sizeof(scm_array )))->ubnd = ((scm_array_dim *)((char *)((scm_cell *)vra0)->cdr + sizeof(scm_array )))->ubnd;
    }
#line 328
    if (scm_tc16_array == (long )(65535 & (int )((scm_cell *)ra1)->car)) {
#line 331
      if (kmax >= 0) {
#line 332
        ((scm_array_dim *)((char *)((scm_cell *)vra1)->cdr + sizeof(scm_array )))->inc = ((scm_array_dim *)((char *)((scm_cell *)ra1)->cdr + sizeof(scm_array )) + kmax)->inc;
      }
#line 333
      ((scm_array *)((scm_cell *)vra1)->cdr)->v = ((scm_array *)((scm_cell *)ra1)->cdr)->v;
    } else {
#line 337
      ((scm_array_dim *)((char *)((scm_cell *)vra1)->cdr + sizeof(scm_array )))->inc = 1L;
#line 338
      ((scm_array *)((scm_cell *)vra1)->cdr)->v = ra1;
    }
    {
#line 340
    *plvra = scm_cons(vra1, (long )(20 << 9) + 372L);
#line 341
    plvra = & ((scm_cell *)*plvra)->cdr;
#line 322
    z = ((scm_cell *)z)->cdr;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 343
  inds = scm_make_uve((long )((size_t )(((scm_cell *)ra0)->car >> 17)), (-1L << 2) + 2L);
#line 344
  vinds = (SCM *)((scm_cell *)inds)->cdr;
#line 345
  k = 0;
  }
  {
#line 345
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 345
    if (! (k <= kmax)) {
#line 345
      goto while_break___1;
    }
#line 346
    *(vinds + k) = ((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )) + k)->lbnd;
#line 345
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 347
  k = kmax;
  {
#line 348
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 350
    if (k == kmax) {
      {
#line 352
      y = lra;
#line 353
      ((scm_array *)((scm_cell *)vra0)->cdr)->base = cind(ra0, inds);
#line 354
      z = lvra;
      }
      {
#line 354
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 354
        if (! (! (6 & (int )z))) {
#line 354
          goto while_break___3;
        }
        {
#line 355
        ((scm_array *)((scm_cell *)((scm_cell *)z)->car)->cdr)->base = cind(((scm_cell *)y)->car,
                                                                            inds);
#line 354
        z = ((scm_cell *)z)->cdr;
#line 354
        y = ((scm_cell *)y)->cdr;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 356
      if ((long )(18 << 9) + 372L == data) {
        {
#line 356
        tmp___3 = (*cproc)(vra0, lvra);
#line 356
        tmp___5 = tmp___3;
        }
      } else {
        {
#line 356
        tmp___4 = (*cproc)(vra0, data, lvra);
#line 356
        tmp___5 = tmp___4;
        }
      }
#line 356
      if (0 == tmp___5) {
#line 357
        return (0);
      }
#line 358
      k --;
#line 359
      goto __Cont;
    }
#line 361
    if (*(vinds + k) < ((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )) + k)->ubnd) {
#line 363
      (*(vinds + k)) ++;
#line 364
      k ++;
#line 365
      goto __Cont;
    }
#line 367
    *(vinds + k) = ((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )) + k)->lbnd - 1L;
#line 368
    k --;
    __Cont: /* CIL Label */ 
#line 348
    if (! (k >= 0)) {
#line 348
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 371
  return (1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 376
static char s_array_fill_x[12] ;
#line 378 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
int scm_array_fill_int(SCM ra , SCM fill , SCM ignore ) 
{ 
  size_t i ;
  size_t n ;
  long inc ;
  size_t base ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  long *ve ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  long f ;
  long *ve___0 ;
  size_t tmp___6 ;
  double f___0 ;
  double *ve___1 ;
  size_t tmp___7 ;
  double fr ;
  double fi ;
  double (*ve___2)[2] ;
  size_t tmp___8 ;

  {
#line 384
  n = (size_t )((((scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array )))->ubnd - ((scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array )))->lbnd) + 1L);
#line 385
  inc = ((scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array )))->inc;
#line 386
  base = ((scm_array *)((scm_cell *)ra)->cdr)->base;
#line 387
  ra = ((scm_array *)((scm_cell *)ra)->cdr)->v;
  {
#line 395
  if ((127 & (int )((scm_cell *)ra)->car) == 13) {
#line 395
    goto case_13;
  }
#line 399
  if ((127 & (int )((scm_cell *)ra)->car) == 21) {
#line 399
    goto case_21;
  }
#line 404
  if ((127 & (int )((scm_cell *)ra)->car) == 71) {
#line 404
    goto case_71;
  }
#line 444
  if ((127 & (int )((scm_cell *)ra)->car) == 37) {
#line 444
    goto case_37;
  }
#line 446
  if ((127 & (int )((scm_cell *)ra)->car) == 79) {
#line 446
    goto case_79;
  }
#line 466
  if ((127 & (int )((scm_cell *)ra)->car) == 47) {
#line 466
    goto case_47;
  }
#line 475
  if ((127 & (int )((scm_cell *)ra)->car) == 53) {
#line 475
    goto case_53;
  }
#line 391
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 392
  i = base;
  {
#line 392
  while (1) {
    while_continue: /* CIL Label */ ;
#line 392
    tmp = n;
#line 392
    n --;
#line 392
    if (! tmp) {
#line 392
      goto while_break;
    }
    {
#line 393
    scm_array_set_x(ra, fill, (SCM )((i << 2) + 2UL));
#line 392
    i += (size_t )inc;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 394
  goto switch_break;
  case_13: /* CIL Label */ 
#line 396
  i = base;
  {
#line 396
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 396
    tmp___0 = n;
#line 396
    n --;
#line 396
    if (! tmp___0) {
#line 396
      goto while_break___0;
    }
#line 397
    *((SCM *)((scm_cell *)ra)->cdr + i) = fill;
#line 396
    i += (size_t )inc;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 398
  goto switch_break;
  case_21: /* CIL Label */ 
#line 400
  if (! (((int )fill & 255) == 244)) {
#line 400
    goto badarg2;
  }
#line 401
  i = base;
  {
#line 401
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 401
    tmp___1 = n;
#line 401
    n --;
#line 401
    if (! tmp___1) {
#line 401
      goto while_break___1;
    }
#line 402
    *((char *)((scm_cell *)ra)->cdr + i) = (char )((unsigned int )(fill >> 8));
#line 401
    i += (size_t )inc;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 403
  goto switch_break;
  case_71: /* CIL Label */ 
#line 406
  ve = (SCM *)((scm_cell *)ra)->cdr;
#line 407
  if (1L == inc) {
#line 407
    if (n >= (8UL * sizeof(long )) / sizeof(char )) {
#line 407
      goto _L___0;
    } else
#line 407
    if (n == (unsigned long )((scm_cell *)ra)->car >> 8) {
      _L___0: /* CIL Label */ 
#line 409
      i = base / ((8UL * sizeof(long )) / sizeof(char ));
#line 410
      if ((long )(16 << 9) + 372L == fill) {
#line 412
        if (base % ((8UL * sizeof(long )) / sizeof(char ))) {
#line 413
          tmp___2 = i;
#line 413
          i ++;
#line 413
          *(ve + tmp___2) &= ~ (-1L << base % ((8UL * sizeof(long )) / sizeof(char )));
        }
        {
#line 414
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 414
          if (! (i < (base + n) / ((8UL * sizeof(long )) / sizeof(char )))) {
#line 414
            goto while_break___2;
          }
#line 415
          *(ve + i) = 0L;
#line 414
          i ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 416
        if ((base + n) % ((8UL * sizeof(long )) / sizeof(char ))) {
#line 417
          *(ve + i) &= -1L << (base + n) % ((8UL * sizeof(long )) / sizeof(char ));
        }
      } else
#line 419
      if ((long )(17 << 9) + 372L == fill) {
#line 421
        if (base % ((8UL * sizeof(long )) / sizeof(char ))) {
#line 422
          tmp___3 = i;
#line 422
          i ++;
#line 422
          *(ve + tmp___3) |= -1L << base % ((8UL * sizeof(long )) / sizeof(char ));
        }
        {
#line 423
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 423
          if (! (i < (base + n) / ((8UL * sizeof(long )) / sizeof(char )))) {
#line 423
            goto while_break___3;
          }
#line 424
          *(ve + i) = ~ 0L;
#line 423
          i ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 425
        if ((base + n) % ((8UL * sizeof(long )) / sizeof(char ))) {
#line 426
          *(ve + i) |= ~ (-1L << (base + n) % ((8UL * sizeof(long )) / sizeof(char )));
        }
      } else {
        badarg2: 
        {
#line 429
        scm_wta(fill, (char *)2, s_array_fill_x);
        }
      }
    } else {
#line 407
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 433
  if ((long )(16 << 9) + 372L == fill) {
#line 434
    i = base;
    {
#line 434
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 434
      tmp___4 = n;
#line 434
      n --;
#line 434
      if (! tmp___4) {
#line 434
        goto while_break___4;
      }
#line 435
      *(ve + i / ((8UL * sizeof(long )) / sizeof(char ))) &= ~ (1L << i % ((8UL * sizeof(long )) / sizeof(char )));
#line 434
      i += (size_t )inc;
    }
    while_break___4: /* CIL Label */ ;
    }
  } else
#line 436
  if ((long )(17 << 9) + 372L == fill) {
#line 437
    i = base;
    {
#line 437
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 437
      tmp___5 = n;
#line 437
      n --;
#line 437
      if (! tmp___5) {
#line 437
        goto while_break___5;
      }
#line 438
      *(ve + i / ((8UL * sizeof(long )) / sizeof(char ))) |= 1L << i % ((8UL * sizeof(long )) / sizeof(char ));
#line 437
      i += (size_t )inc;
    }
    while_break___5: /* CIL Label */ ;
    }
  } else {
#line 440
    goto badarg2;
  }
#line 442
  goto switch_break;
  case_37: /* CIL Label */ 
#line 445
  if (! (0L <= fill >> 2)) {
#line 445
    goto badarg2;
  }
  case_79: /* CIL Label */ 
#line 447
  if (! (2 & (int )fill)) {
#line 447
    goto badarg2;
  }
#line 449
  f = fill >> 2;
#line 449
  ve___0 = (SCM *)((scm_cell *)ra)->cdr;
#line 450
  i = base;
  {
#line 450
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 450
    tmp___6 = n;
#line 450
    n --;
#line 450
    if (! tmp___6) {
#line 450
      goto while_break___6;
    }
#line 451
    *(ve___0 + i) = f;
#line 450
    i += (size_t )inc;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 452
  goto switch_break;
  case_47: /* CIL Label */ 
#line 468
  ve___1 = (double *)((SCM *)((scm_cell *)ra)->cdr);
#line 469
  if (! (6 & (int )fill)) {
#line 469
    if (! (((scm_cell *)fill)->car == (383L | (1L << 16)))) {
#line 469
      goto badarg2;
    }
  } else {
#line 469
    goto badarg2;
  }
#line 470
  f___0 = *(((scm_dbl *)fill)->real);
#line 471
  i = base;
  {
#line 471
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 471
    tmp___7 = n;
#line 471
    n --;
#line 471
    if (! tmp___7) {
#line 471
      goto while_break___7;
    }
#line 472
    *(ve___1 + i) = f___0;
#line 471
    i += (size_t )inc;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 473
  goto switch_break;
  case_53: /* CIL Label */ 
#line 478
  ve___2 = (double (*)[2])((SCM *)((scm_cell *)ra)->cdr);
#line 479
  if (! (6 & (int )fill)) {
#line 479
    if (! ((65535 & (int )((scm_cell *)fill)->car) == 383)) {
#line 479
      goto badarg2;
    }
  } else {
#line 479
    goto badarg2;
  }
#line 480
  fr = *(((scm_dbl *)fill)->real);
#line 481
  if (((scm_cell *)fill)->car == ((383L | (1L << 16)) | (2L << 16))) {
#line 481
    fi = *((double *)((char *)((scm_cell *)fill)->cdr + sizeof(double )));
  } else {
#line 481
    fi = 0.0;
  }
#line 482
  i = base;
  {
#line 482
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 482
    tmp___8 = n;
#line 482
    n --;
#line 482
    if (! tmp___8) {
#line 482
      goto while_break___8;
    }
#line 484
    (*(ve___2 + i))[0] = fr;
#line 485
    (*(ve___2 + i))[1] = fi;
#line 482
    i += (size_t )inc;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 487
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 491
  return (1);
}
}
#line 494 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
static char s_array_fill_x[12]  = 
#line 494
  {      (char )'a',      (char )'r',      (char )'r',      (char )'a', 
        (char )'y',      (char )'-',      (char )'f',      (char )'i', 
        (char )'l',      (char )'l',      (char )'!',      (char )'\000'};
#line 496 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
SCM scm_array_fill_x(SCM ra , SCM fill ) 
{ 


  {
  {
#line 501
  scm_ramapc((int (*)())(& scm_array_fill_int), fill, ra, (long )(20 << 9) + 372L,
             s_array_fill_x);
  }
#line 502
  return ((long )(21 << 9) + 372L);
}
}
#line 508
static int racp(SCM src , SCM dst ) ;
#line 510 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
static int racp(SCM src , SCM dst ) 
{ 
  long n ;
  long inc_d ;
  long inc_s ;
  size_t i_d ;
  size_t i_s ;
  SCM tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long *sv ;
  long *dv ;
  long tmp___2 ;
  long *d ;
  long *s___0 ;
  long tmp___3 ;
  long *d___0 ;
  long *s___1 ;
  long tmp___4 ;
  double *d___1 ;
  double *s___2 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  double (*d___2)[2] ;
  double (*s___3)[2] ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;

  {
#line 515
  n = (((scm_array_dim *)((char *)((scm_cell *)src)->cdr + sizeof(scm_array )))->ubnd - ((scm_array_dim *)((char *)((scm_cell *)src)->cdr + sizeof(scm_array )))->lbnd) + 1L;
#line 516
  inc_s = ((scm_array_dim *)((char *)((scm_cell *)src)->cdr + sizeof(scm_array )))->inc;
#line 517
  i_s = ((scm_array *)((scm_cell *)src)->cdr)->base;
#line 518
  dst = ((scm_cell *)dst)->car;
#line 519
  inc_d = ((scm_array_dim *)((char *)((scm_cell *)dst)->cdr + sizeof(scm_array )))->inc;
#line 520
  i_d = ((scm_array *)((scm_cell *)dst)->cdr)->base;
#line 521
  src = ((scm_array *)((scm_cell *)src)->cdr)->v;
#line 522
  dst = ((scm_array *)((scm_cell *)dst)->cdr)->v;
  {
#line 531
  if ((127 & (int )((scm_cell *)dst)->car) == 21) {
#line 531
    goto case_21;
  }
#line 537
  if ((127 & (int )((scm_cell *)dst)->car) == 71) {
#line 537
    goto case_71;
  }
#line 568
  if ((127 & (int )((scm_cell *)dst)->car) == 37) {
#line 568
    goto case_37;
  }
#line 579
  if ((127 & (int )((scm_cell *)dst)->car) == 79) {
#line 579
    goto case_79;
  }
#line 621
  if ((127 & (int )((scm_cell *)dst)->car) == 47) {
#line 621
    goto case_47;
  }
#line 649
  if ((127 & (int )((scm_cell *)dst)->car) == 53) {
#line 649
    goto case_53;
  }
#line 526
  goto gencase;
  gencase: 
  switch_default: /* CIL Label */ 
  {
#line 528
  while (1) {
    while_continue: /* CIL Label */ ;
#line 528
    tmp___0 = n;
#line 528
    n --;
#line 528
    if (! (tmp___0 > 0L)) {
#line 528
      goto while_break;
    }
    {
#line 529
    tmp = scm_cvref(src, i_s, (long )(18 << 9) + 372L);
#line 529
    scm_array_set_x(dst, tmp, (SCM )((i_d << 2) + 2UL));
#line 528
    i_s += (size_t )inc_s;
#line 528
    i_d += (size_t )inc_d;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 530
  goto switch_break;
  case_21: /* CIL Label */ 
#line 532
  if (21 != (127 & (int )((scm_cell *)dst)->car)) {
#line 533
    goto gencase;
  }
  {
#line 534
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 534
    tmp___1 = n;
#line 534
    n --;
#line 534
    if (! (tmp___1 > 0L)) {
#line 534
      goto while_break___0;
    }
#line 535
    *((char *)((scm_cell *)dst)->cdr + i_d) = *((char *)((scm_cell *)src)->cdr + i_s);
#line 534
    i_s += (size_t )inc_s;
#line 534
    i_d += (size_t )inc_d;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 536
  goto switch_break;
  case_71: /* CIL Label */ 
#line 538
  if (71 != (127 & (int )((scm_cell *)dst)->car)) {
#line 539
    goto gencase;
  }
#line 540
  if (1L == inc_d) {
#line 540
    if (1L == inc_s) {
#line 540
      if (i_s % ((8UL * sizeof(long )) / sizeof(char )) == i_d % ((8UL * sizeof(long )) / sizeof(char ))) {
#line 540
        if ((unsigned long )n >= (8UL * sizeof(long )) / sizeof(char )) {
#line 542
          sv = (SCM *)((scm_cell *)src)->cdr;
#line 543
          dv = (SCM *)((scm_cell *)dst)->cdr;
#line 544
          sv += i_s / ((8UL * sizeof(long )) / sizeof(char ));
#line 545
          dv += i_d / ((8UL * sizeof(long )) / sizeof(char ));
#line 546
          if (i_s % ((8UL * sizeof(long )) / sizeof(char ))) {
#line 548
            *dv = (*dv & ~ (-1L << i_s % ((8UL * sizeof(long )) / sizeof(char )))) | (*sv & (-1L << i_s % ((8UL * sizeof(long )) / sizeof(char ))));
#line 549
            dv ++;
#line 550
            sv ++;
#line 551
            n = (long )((unsigned long )n - ((8UL * sizeof(long )) / sizeof(char ) - i_s % ((8UL * sizeof(long )) / sizeof(char ))));
          }
          {
#line 553
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 553
            if (! ((unsigned long )n >= (8UL * sizeof(long )) / sizeof(char ))) {
#line 553
              goto while_break___1;
            }
#line 553
            *dv = *sv;
#line 553
            n = (long )((unsigned long )n - (8UL * sizeof(long )) / sizeof(char ));
#line 553
            sv ++;
#line 553
            dv ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 556
          if (n) {
#line 557
            *dv = (*dv & (-1L << n)) | (*sv & ~ (-1L << n));
          }
        } else {
#line 540
          goto _L___1;
        }
      } else {
#line 540
        goto _L___1;
      }
    } else {
#line 540
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    {
#line 561
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 561
      tmp___2 = n;
#line 561
      n --;
#line 561
      if (! (tmp___2 > 0L)) {
#line 561
        goto while_break___2;
      }
#line 562
      if (*((SCM *)((scm_cell *)src)->cdr + i_s / ((8UL * sizeof(long )) / sizeof(char ))) & (1L << i_s % ((8UL * sizeof(long )) / sizeof(char )))) {
#line 563
        *((SCM *)((scm_cell *)dst)->cdr + i_d / ((8UL * sizeof(long )) / sizeof(char ))) |= 1L << i_d % ((8UL * sizeof(long )) / sizeof(char ));
      } else {
#line 565
        *((SCM *)((scm_cell *)dst)->cdr + i_d / ((8UL * sizeof(long )) / sizeof(char ))) &= ~ (1L << i_d % ((8UL * sizeof(long )) / sizeof(char )));
      }
#line 561
      i_s += (size_t )inc_s;
#line 561
      i_d += (size_t )inc_d;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 567
  goto switch_break;
  case_37: /* CIL Label */ 
#line 569
  if (37 != (127 & (int )((scm_cell *)src)->car)) {
#line 570
    goto gencase;
  } else {
#line 573
    d = (SCM *)((scm_cell *)dst)->cdr;
#line 573
    s___0 = (SCM *)((scm_cell *)src)->cdr;
    {
#line 574
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 574
      tmp___3 = n;
#line 574
      n --;
#line 574
      if (! (tmp___3 > 0L)) {
#line 574
        goto while_break___3;
      }
#line 574
      *(d + i_d) = *(s___0 + i_s);
#line 574
      i_s += (size_t )inc_s;
#line 574
      i_d += (size_t )inc_d;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 577
    goto switch_break;
  }
  case_79: /* CIL Label */ 
#line 580
  if (37 != (127 & (int )((scm_cell *)src)->car)) {
#line 580
    if (79 != (127 & (int )((scm_cell *)src)->car)) {
#line 581
      goto gencase;
    } else {
#line 580
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
#line 584
    d___0 = (SCM *)((scm_cell *)dst)->cdr;
#line 584
    s___1 = (SCM *)((scm_cell *)src)->cdr;
    {
#line 585
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 585
      tmp___4 = n;
#line 585
      n --;
#line 585
      if (! (tmp___4 > 0L)) {
#line 585
        goto while_break___4;
      }
#line 585
      *(d___0 + i_d) = *(s___1 + i_s);
#line 585
      i_s += (size_t )inc_s;
#line 585
      i_d += (size_t )inc_d;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 588
    goto switch_break;
  }
  case_47: /* CIL Label */ 
#line 623
  d___1 = (double *)((SCM *)((scm_cell *)dst)->cdr);
#line 624
  s___2 = (double *)((SCM *)((scm_cell *)src)->cdr);
  {
#line 631
  if ((127 & (int )((scm_cell *)src)->car) == 37) {
#line 631
    goto case_37___0;
  }
#line 631
  if ((127 & (int )((scm_cell *)src)->car) == 79) {
#line 631
    goto case_37___0;
  }
#line 636
  if ((127 & (int )((scm_cell *)src)->car) == 45) {
#line 636
    goto case_45;
  }
#line 641
  if ((127 & (int )((scm_cell *)src)->car) == 47) {
#line 641
    goto case_47___0;
  }
#line 628
  goto switch_default___0;
  switch_default___0: /* CIL Label */ 
#line 629
  goto gencase;
  case_37___0: /* CIL Label */ 
  case_79___0: /* CIL Label */ 
  {
#line 632
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 632
    tmp___5 = n;
#line 632
    n --;
#line 632
    if (! (tmp___5 > 0L)) {
#line 632
      goto while_break___5;
    }
#line 632
    *(d___1 + i_d) = (double )*((long *)s___2 + i_s);
#line 632
    i_s += (size_t )inc_s;
#line 632
    i_d += (size_t )inc_d;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 635
  goto switch_break___0;
  case_45: /* CIL Label */ 
  {
#line 637
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 637
    tmp___6 = n;
#line 637
    n --;
#line 637
    if (! (tmp___6 > 0L)) {
#line 637
      goto while_break___6;
    }
#line 637
    *(d___1 + i_d) = (double )*((float *)s___2 + i_s);
#line 637
    i_s += (size_t )inc_s;
#line 637
    i_d += (size_t )inc_d;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 640
  goto switch_break___0;
  case_47___0: /* CIL Label */ 
  {
#line 642
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 642
    tmp___7 = n;
#line 642
    n --;
#line 642
    if (! (tmp___7 > 0L)) {
#line 642
      goto while_break___7;
    }
#line 642
    *(d___1 + i_d) = *(s___2 + i_s);
#line 642
    i_s += (size_t )inc_s;
#line 642
    i_d += (size_t )inc_d;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 645
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 647
  goto switch_break;
  case_53: /* CIL Label */ 
#line 651
  d___2 = (double (*)[2])((SCM *)((scm_cell *)dst)->cdr);
#line 652
  s___3 = (double (*)[2])((SCM *)((scm_cell *)src)->cdr);
  {
#line 659
  if ((127 & (int )((scm_cell *)src)->car) == 37) {
#line 659
    goto case_37___1;
  }
#line 659
  if ((127 & (int )((scm_cell *)src)->car) == 79) {
#line 659
    goto case_37___1;
  }
#line 668
  if ((127 & (int )((scm_cell *)src)->car) == 45) {
#line 668
    goto case_45___0;
  }
#line 677
  if ((127 & (int )((scm_cell *)src)->car) == 47) {
#line 677
    goto case_47___1;
  }
#line 686
  if ((127 & (int )((scm_cell *)src)->car) == 53) {
#line 686
    goto case_53___0;
  }
#line 656
  goto switch_default___1;
  switch_default___1: /* CIL Label */ 
#line 657
  goto gencase;
  case_37___1: /* CIL Label */ 
  case_79___1: /* CIL Label */ 
  {
#line 660
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 660
    tmp___8 = n;
#line 660
    n --;
#line 660
    if (! (tmp___8 > 0L)) {
#line 660
      goto while_break___8;
    }
#line 660
    (*(d___2 + i_d))[0] = (double )*((long *)s___3 + i_s);
#line 660
    (*(d___2 + i_d))[1] = 0.0;
#line 660
    i_s += (size_t )inc_s;
#line 660
    i_d += (size_t )inc_d;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 667
  goto switch_break___1;
  case_45___0: /* CIL Label */ 
  {
#line 669
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 669
    tmp___9 = n;
#line 669
    n --;
#line 669
    if (! (tmp___9 > 0L)) {
#line 669
      goto while_break___9;
    }
#line 669
    (*(d___2 + i_d))[0] = (double )*((float *)s___3 + i_s);
#line 669
    (*(d___2 + i_d))[1] = 0.0;
#line 669
    i_s += (size_t )inc_s;
#line 669
    i_d += (size_t )inc_d;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 676
  goto switch_break___1;
  case_47___1: /* CIL Label */ 
  {
#line 678
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 678
    tmp___10 = n;
#line 678
    n --;
#line 678
    if (! (tmp___10 > 0L)) {
#line 678
      goto while_break___10;
    }
#line 678
    (*(d___2 + i_d))[0] = *((double *)s___3 + i_s);
#line 678
    (*(d___2 + i_d))[1] = 0.0;
#line 678
    i_s += (size_t )inc_s;
#line 678
    i_d += (size_t )inc_d;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 685
  goto switch_break___1;
  case_53___0: /* CIL Label */ 
  {
#line 687
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 687
    tmp___11 = n;
#line 687
    n --;
#line 687
    if (! (tmp___11 > 0L)) {
#line 687
      goto while_break___11;
    }
#line 687
    (*(d___2 + i_d))[0] = (*(s___3 + i_s))[0];
#line 687
    (*(d___2 + i_d))[1] = (*(s___3 + i_s))[1];
#line 687
    i_s += (size_t )inc_s;
#line 687
    i_d += (size_t )inc_d;
  }
  while_break___11: /* CIL Label */ ;
  }
  switch_break___1: /* CIL Label */ ;
  }
#line 695
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 699
  return (1);
}
}
#line 703 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
static char s_serial_array_copy_x[19]  = 
#line 703
  {      (char )'s',      (char )'e',      (char )'r',      (char )'i', 
        (char )'a',      (char )'l',      (char )'-',      (char )'a', 
        (char )'r',      (char )'r',      (char )'a',      (char )'y', 
        (char )'-',      (char )'c',      (char )'o',      (char )'p', 
        (char )'y',      (char )'!',      (char )'\000'};
#line 704 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
static char s_array_copy_x[12]  = 
#line 704
  {      (char )'a',      (char )'r',      (char )'r',      (char )'a', 
        (char )'y',      (char )'-',      (char )'c',      (char )'o', 
        (char )'p',      (char )'y',      (char )'!',      (char )'\000'};
#line 706 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
SCM scm_array_copy_x(SCM src , SCM dst ) 
{ 
  SCM tmp ;

  {
  {
#line 711
  tmp = scm_cons(dst, (long )(20 << 9) + 372L);
#line 711
  scm_ramapc((int (*)())(& racp), (long )(18 << 9) + 372L, src, tmp, s_array_copy_x);
  }
#line 712
  return ((long )(21 << 9) + 372L);
}
}
#line 718 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
int scm_ra_eqp(SCM ra0 , SCM ras ) 
{ 
  SCM ra1 ;
  SCM ra2 ;
  long n ;
  size_t i0 ;
  size_t i1 ;
  size_t i2 ;
  long inc0 ;
  long inc1 ;
  long inc2 ;
  int tmp ;
  SCM e1 ;
  SCM e2 ;
  SCM tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;
  long tmp___8 ;

  {
#line 723
  ra1 = ((scm_cell *)ras)->car;
#line 723
  ra2 = ((scm_cell *)((scm_cell *)ras)->cdr)->car;
#line 724
  n = (((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )))->ubnd - ((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )))->lbnd) + 1L;
#line 725
  i0 = ((scm_array *)((scm_cell *)ra0)->cdr)->base;
#line 725
  i1 = ((scm_array *)((scm_cell *)ra1)->cdr)->base;
#line 725
  i2 = ((scm_array *)((scm_cell *)ra2)->cdr)->base;
#line 726
  inc0 = ((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )))->inc;
#line 727
  inc1 = ((scm_array_dim *)((char *)((scm_cell *)ra1)->cdr + sizeof(scm_array )))->inc;
#line 728
  inc2 = ((scm_array_dim *)((char *)((scm_cell *)ra1)->cdr + sizeof(scm_array )))->inc;
#line 729
  ra0 = ((scm_array *)((scm_cell *)ra0)->cdr)->v;
#line 730
  ra1 = ((scm_array *)((scm_cell *)ra1)->cdr)->v;
#line 731
  ra2 = ((scm_array *)((scm_cell *)ra2)->cdr)->v;
#line 732
  if ((127 & (int )((scm_cell *)ra1)->car) == (127 & (int )((scm_cell *)ra2)->car)) {
#line 732
    tmp = 127 & (int )((scm_cell *)ra1)->car;
  } else {
#line 732
    tmp = 0;
  }
  {
#line 746
  if (tmp == 79) {
#line 746
    goto case_79;
  }
#line 746
  if (tmp == 37) {
#line 746
    goto case_79;
  }
#line 763
  if (tmp == 47) {
#line 763
    goto case_47;
  }
#line 770
  if (tmp == 53) {
#line 770
    goto case_53;
  }
#line 734
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 736
  e1 = (long )(18 << 9) + 372L;
#line 736
  e2 = (long )(18 << 9) + 372L;
  {
#line 737
  while (1) {
    while_continue: /* CIL Label */ ;
#line 737
    tmp___2 = n;
#line 737
    n --;
#line 737
    if (! (tmp___2 > 0L)) {
#line 737
      goto while_break;
    }
#line 738
    if (*((SCM *)((scm_cell *)ra0)->cdr + i0 / ((8UL * sizeof(long )) / sizeof(char ))) & (1L << i0 % ((8UL * sizeof(long )) / sizeof(char )))) {
#line 738
      tmp___1 = 1;
    } else {
#line 738
      tmp___1 = 0;
    }
#line 738
    if (tmp___1) {
      {
#line 740
      e2 = scm_cvref(ra2, i2, e2);
#line 740
      e1 = scm_cvref(ra1, i1, e1);
#line 740
      tmp___0 = scm_eq_p(e1, e2);
      }
#line 740
      if ((long )(16 << 9) + 372L == tmp___0) {
#line 742
        *((SCM *)((scm_cell *)ra0)->cdr + i0 / ((8UL * sizeof(long )) / sizeof(char ))) &= ~ (1L << i0 % ((8UL * sizeof(long )) / sizeof(char )));
      }
    }
#line 737
    i0 += (size_t )inc0;
#line 737
    i1 += (size_t )inc1;
#line 737
    i2 += (size_t )inc2;
  }
  while_break: /* CIL Label */ ;
  }
#line 743
  goto switch_break;
  case_79: /* CIL Label */ 
  case_37: /* CIL Label */ 
  {
#line 747
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 747
    tmp___4 = n;
#line 747
    n --;
#line 747
    if (! (tmp___4 > 0L)) {
#line 747
      goto while_break___0;
    }
#line 748
    if (*((SCM *)((scm_cell *)ra0)->cdr + i0 / ((8UL * sizeof(long )) / sizeof(char ))) & (1L << i0 % ((8UL * sizeof(long )) / sizeof(char )))) {
#line 748
      tmp___3 = 1;
    } else {
#line 748
      tmp___3 = 0;
    }
#line 748
    if (tmp___3) {
#line 750
      if (*((SCM *)((scm_cell *)ra1)->cdr + i1) != *((SCM *)((scm_cell *)ra2)->cdr + i2)) {
#line 751
        *((SCM *)((scm_cell *)ra0)->cdr + i0 / ((8UL * sizeof(long )) / sizeof(char ))) &= ~ (1L << i0 % ((8UL * sizeof(long )) / sizeof(char )));
      }
    }
#line 747
    i0 += (size_t )inc0;
#line 747
    i1 += (size_t )inc1;
#line 747
    i2 += (size_t )inc2;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 752
  goto switch_break;
  case_47: /* CIL Label */ 
  {
#line 764
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 764
    tmp___6 = n;
#line 764
    n --;
#line 764
    if (! (tmp___6 > 0L)) {
#line 764
      goto while_break___1;
    }
#line 765
    if (*((SCM *)((scm_cell *)ra0)->cdr + i0 / ((8UL * sizeof(long )) / sizeof(char ))) & (1L << i0 % ((8UL * sizeof(long )) / sizeof(char )))) {
#line 765
      tmp___5 = 1;
    } else {
#line 765
      tmp___5 = 0;
    }
#line 765
    if (tmp___5) {
#line 767
      if (*((double *)((SCM *)((scm_cell *)ra1)->cdr) + i1) != *((double *)((SCM *)((scm_cell *)ra2)->cdr) + i2)) {
#line 768
        *((SCM *)((scm_cell *)ra0)->cdr + i0 / ((8UL * sizeof(long )) / sizeof(char ))) &= ~ (1L << i0 % ((8UL * sizeof(long )) / sizeof(char )));
      }
    }
#line 764
    i0 += (size_t )inc0;
#line 764
    i1 += (size_t )inc1;
#line 764
    i2 += (size_t )inc2;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 769
  goto switch_break;
  case_53: /* CIL Label */ 
  {
#line 771
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 771
    tmp___8 = n;
#line 771
    n --;
#line 771
    if (! (tmp___8 > 0L)) {
#line 771
      goto while_break___2;
    }
#line 772
    if (*((SCM *)((scm_cell *)ra0)->cdr + i0 / ((8UL * sizeof(long )) / sizeof(char ))) & (1L << i0 % ((8UL * sizeof(long )) / sizeof(char )))) {
#line 772
      tmp___7 = 1;
    } else {
#line 772
      tmp___7 = 0;
    }
#line 772
    if (tmp___7) {
#line 774
      if (*((double *)((SCM *)((scm_cell *)ra1)->cdr) + 2UL * i1) != *((double *)((SCM *)((scm_cell *)ra2)->cdr) + 2UL * i2)) {
#line 776
        *((SCM *)((scm_cell *)ra0)->cdr + i0 / ((8UL * sizeof(long )) / sizeof(char ))) &= ~ (1L << i0 % ((8UL * sizeof(long )) / sizeof(char )));
      } else
#line 774
      if (*((double *)((SCM *)((scm_cell *)ra1)->cdr) + (2UL * i1 + 1UL)) != *((double *)((SCM *)((scm_cell *)ra2)->cdr) + (2UL * i2 + 1UL))) {
#line 776
        *((SCM *)((scm_cell *)ra0)->cdr + i0 / ((8UL * sizeof(long )) / sizeof(char ))) &= ~ (1L << i0 % ((8UL * sizeof(long )) / sizeof(char )));
      }
    }
#line 771
    i0 += (size_t )inc0;
#line 771
    i1 += (size_t )inc1;
#line 771
    i2 += (size_t )inc2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 777
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 780
  return (1);
}
}
#line 785
static int ra_compare(SCM ra0 , SCM ra1 , SCM ra2 , int opt ) ;
#line 787 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
static int ra_compare(SCM ra0 , SCM ra1 , SCM ra2 , int opt ) 
{ 
  long n ;
  size_t i0 ;
  size_t i1 ;
  size_t i2 ;
  long inc0 ;
  long inc1 ;
  long inc2 ;
  int tmp ;
  SCM e1 ;
  SCM e2 ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;

  {
#line 794
  n = (((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )))->ubnd - ((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )))->lbnd) + 1L;
#line 795
  i0 = ((scm_array *)((scm_cell *)ra0)->cdr)->base;
#line 795
  i1 = ((scm_array *)((scm_cell *)ra1)->cdr)->base;
#line 795
  i2 = ((scm_array *)((scm_cell *)ra2)->cdr)->base;
#line 796
  inc0 = ((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )))->inc;
#line 797
  inc1 = ((scm_array_dim *)((char *)((scm_cell *)ra1)->cdr + sizeof(scm_array )))->inc;
#line 798
  inc2 = ((scm_array_dim *)((char *)((scm_cell *)ra1)->cdr + sizeof(scm_array )))->inc;
#line 799
  ra0 = ((scm_array *)((scm_cell *)ra0)->cdr)->v;
#line 800
  ra1 = ((scm_array *)((scm_cell *)ra1)->cdr)->v;
#line 801
  ra2 = ((scm_array *)((scm_cell *)ra2)->cdr)->v;
#line 802
  if ((127 & (int )((scm_cell *)ra1)->car) == (127 & (int )((scm_cell *)ra2)->car)) {
#line 802
    tmp = 127 & (int )((scm_cell *)ra1)->car;
  } else {
#line 802
    tmp = 0;
  }
  {
#line 817
  if (tmp == 79) {
#line 817
    goto case_79;
  }
#line 817
  if (tmp == 37) {
#line 817
    goto case_79;
  }
#line 840
  if (tmp == 47) {
#line 840
    goto case_47;
  }
#line 804
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 806
  e1 = (long )(18 << 9) + 372L;
#line 806
  e2 = (long )(18 << 9) + 372L;
  {
#line 807
  while (1) {
    while_continue: /* CIL Label */ ;
#line 807
    tmp___4 = n;
#line 807
    n --;
#line 807
    if (! (tmp___4 > 0L)) {
#line 807
      goto while_break;
    }
#line 808
    if (*((SCM *)((scm_cell *)ra0)->cdr + i0 / ((8UL * sizeof(long )) / sizeof(char ))) & (1L << i0 % ((8UL * sizeof(long )) / sizeof(char )))) {
#line 808
      tmp___3 = 1;
    } else {
#line 808
      tmp___3 = 0;
    }
#line 808
    if (tmp___3) {
#line 810
      if (opt) {
        {
#line 810
        e2 = scm_cvref(ra2, i2, e2);
#line 810
        e1 = scm_cvref(ra1, i1, e1);
#line 810
        tmp___0 = scm_less_p(e1, e2);
#line 810
        tmp___2 = (long )(16 << 9) + 372L != tmp___0;
        }
      } else {
        {
#line 810
        e2 = scm_cvref(ra2, i2, e2);
#line 810
        e1 = scm_cvref(ra1, i1, e1);
#line 810
        tmp___1 = scm_less_p(e1, e2);
#line 810
        tmp___2 = (long )(16 << 9) + 372L == tmp___1;
        }
      }
#line 810
      if (tmp___2) {
#line 813
        *((SCM *)((scm_cell *)ra0)->cdr + i0 / ((8UL * sizeof(long )) / sizeof(char ))) &= ~ (1L << i0 % ((8UL * sizeof(long )) / sizeof(char )));
      }
    }
#line 807
    i0 += (size_t )inc0;
#line 807
    i1 += (size_t )inc1;
#line 807
    i2 += (size_t )inc2;
  }
  while_break: /* CIL Label */ ;
  }
#line 814
  goto switch_break;
  case_79: /* CIL Label */ 
  case_37: /* CIL Label */ 
  {
#line 818
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 818
    tmp___7 = n;
#line 818
    n --;
#line 818
    if (! (tmp___7 > 0L)) {
#line 818
      goto while_break___0;
    }
#line 820
    if (*((SCM *)((scm_cell *)ra0)->cdr + i0 / ((8UL * sizeof(long )) / sizeof(char ))) & (1L << i0 % ((8UL * sizeof(long )) / sizeof(char )))) {
#line 820
      tmp___6 = 1;
    } else {
#line 820
      tmp___6 = 0;
    }
#line 820
    if (tmp___6) {
#line 822
      if (opt) {
#line 822
        tmp___5 = *((SCM *)((scm_cell *)ra1)->cdr + i1) < *((SCM *)((scm_cell *)ra2)->cdr + i2);
      } else {
#line 822
        tmp___5 = *((SCM *)((scm_cell *)ra1)->cdr + i1) >= *((SCM *)((scm_cell *)ra2)->cdr + i2);
      }
#line 822
      if (tmp___5) {
#line 825
        *((SCM *)((scm_cell *)ra0)->cdr + i0 / ((8UL * sizeof(long )) / sizeof(char ))) &= ~ (1L << i0 % ((8UL * sizeof(long )) / sizeof(char )));
      }
    }
#line 818
    i0 += (size_t )inc0;
#line 818
    i1 += (size_t )inc1;
#line 818
    i2 += (size_t )inc2;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 827
  goto switch_break;
  case_47: /* CIL Label */ 
  {
#line 841
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 841
    tmp___10 = n;
#line 841
    n --;
#line 841
    if (! (tmp___10 > 0L)) {
#line 841
      goto while_break___1;
    }
#line 842
    if (*((SCM *)((scm_cell *)ra0)->cdr + i0 / ((8UL * sizeof(long )) / sizeof(char ))) & (1L << i0 % ((8UL * sizeof(long )) / sizeof(char )))) {
#line 842
      tmp___9 = 1;
    } else {
#line 842
      tmp___9 = 0;
    }
#line 842
    if (tmp___9) {
#line 844
      if (opt) {
#line 844
        tmp___8 = *((double *)((SCM *)((scm_cell *)ra1)->cdr) + i1) < *((double *)((SCM *)((scm_cell *)ra2)->cdr) + i2);
      } else {
#line 844
        tmp___8 = *((double *)((SCM *)((scm_cell *)ra1)->cdr) + i1) >= *((double *)((SCM *)((scm_cell *)ra2)->cdr) + i2);
      }
#line 844
      if (tmp___8) {
#line 847
        *((SCM *)((scm_cell *)ra0)->cdr + i0 / ((8UL * sizeof(long )) / sizeof(char ))) &= ~ (1L << i0 % ((8UL * sizeof(long )) / sizeof(char )));
      }
    }
#line 841
    i0 += (size_t )inc0;
#line 841
    i1 += (size_t )inc1;
#line 841
    i2 += (size_t )inc2;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 848
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 851
  return (1);
}
}
#line 856 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
int scm_ra_lessp(SCM ra0 , SCM ras ) 
{ 
  int tmp ;

  {
  {
#line 861
  tmp = ra_compare(ra0, ((scm_cell *)ras)->car, ((scm_cell *)((scm_cell *)ras)->cdr)->car,
                   0);
  }
#line 861
  return (tmp);
}
}
#line 865 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
int scm_ra_leqp(SCM ra0 , SCM ras ) 
{ 
  int tmp ;

  {
  {
#line 870
  tmp = ra_compare(ra0, ((scm_cell *)((scm_cell *)ras)->cdr)->car, ((scm_cell *)ras)->car,
                   1);
  }
#line 870
  return (tmp);
}
}
#line 874 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
int scm_ra_grp(SCM ra0 , SCM ras ) 
{ 
  int tmp ;

  {
  {
#line 879
  tmp = ra_compare(ra0, ((scm_cell *)((scm_cell *)ras)->cdr)->car, ((scm_cell *)ras)->car,
                   0);
  }
#line 879
  return (tmp);
}
}
#line 883 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
int scm_ra_greqp(SCM ra0 , SCM ras ) 
{ 
  int tmp ;

  {
  {
#line 888
  tmp = ra_compare(ra0, ((scm_cell *)ras)->car, ((scm_cell *)((scm_cell *)ras)->cdr)->car,
                   1);
  }
#line 888
  return (tmp);
}
}
#line 893 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
int scm_ra_sum(SCM ra0 , SCM ras ) 
{ 
  long n ;
  size_t i0 ;
  long inc0 ;
  SCM ra1 ;
  size_t i1 ;
  long inc1 ;
  int tmp ;
  SCM e0 ;
  SCM e1 ;
  SCM tmp___0 ;
  long tmp___1 ;
  long *v0 ;
  long *v1 ;
  long tmp___2 ;
  double *v0___0 ;
  double *v1___0 ;
  long tmp___3 ;
  double (*v0___1)[2] ;
  double (*v1___1)[2] ;
  long tmp___4 ;

  {
#line 898
  n = (((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )))->ubnd - ((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )))->lbnd) + 1L;
#line 899
  i0 = ((scm_array *)((scm_cell *)ra0)->cdr)->base;
#line 900
  inc0 = ((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )))->inc;
#line 901
  ra0 = ((scm_array *)((scm_cell *)ra0)->cdr)->v;
#line 902
  if ((long )(20 << 9) + 372L != ras) {
#line 905
    ra1 = ((scm_cell *)ras)->car;
#line 906
    i1 = ((scm_array *)((scm_cell *)ra1)->cdr)->base;
#line 907
    inc1 = ((scm_array_dim *)((char *)((scm_cell *)ra1)->cdr + sizeof(scm_array )))->inc;
#line 908
    ra1 = ((scm_array *)((scm_cell *)ra1)->cdr)->v;
#line 909
    if ((127 & (int )((scm_cell *)ra0)->car) == (127 & (int )((scm_cell *)ra1)->car)) {
#line 909
      tmp = 127 & (int )((scm_cell *)ra0)->car;
    } else {
#line 909
      tmp = 0;
    }
    {
#line 920
    if (tmp == 79) {
#line 920
      goto case_79;
    }
#line 920
    if (tmp == 37) {
#line 920
      goto case_79;
    }
#line 941
    if (tmp == 47) {
#line 941
      goto case_47;
    }
#line 950
    if (tmp == 53) {
#line 950
      goto case_53;
    }
#line 911
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 913
    e0 = (long )(18 << 9) + 372L;
#line 913
    e1 = (long )(18 << 9) + 372L;
    {
#line 914
    while (1) {
      while_continue: /* CIL Label */ ;
#line 914
      tmp___1 = n;
#line 914
      n --;
#line 914
      if (! (tmp___1 > 0L)) {
#line 914
        goto while_break;
      }
      {
#line 915
      e1 = scm_cvref(ra1, i1, e1);
#line 915
      e0 = scm_cvref(ra0, i0, e0);
#line 915
      tmp___0 = scm_sum(e0, e1);
#line 915
      scm_array_set_x(ra0, tmp___0, (SCM )((i0 << 2) + 2UL));
#line 914
      i0 += (size_t )inc0;
#line 914
      i1 += (size_t )inc1;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 917
    goto switch_break;
    case_79: /* CIL Label */ 
    case_37: /* CIL Label */ 
#line 922
    v0 = (SCM *)((scm_cell *)ra0)->cdr;
#line 923
    v1 = (SCM *)((scm_cell *)ra1)->cdr;
    {
#line 924
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 924
      tmp___2 = n;
#line 924
      n --;
#line 924
      if (! (tmp___2 > 0L)) {
#line 924
        goto while_break___0;
      }
#line 924
      *(v0 + i0) += *(v1 + i1);
#line 924
      i0 += (size_t )inc0;
#line 924
      i1 += (size_t )inc1;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 927
    goto switch_break;
    case_47: /* CIL Label */ 
#line 943
    v0___0 = (double *)((SCM *)((scm_cell *)ra0)->cdr);
#line 944
    v1___0 = (double *)((SCM *)((scm_cell *)ra1)->cdr);
    {
#line 945
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 945
      tmp___3 = n;
#line 945
      n --;
#line 945
      if (! (tmp___3 > 0L)) {
#line 945
        goto while_break___1;
      }
#line 945
      *(v0___0 + i0) += *(v1___0 + i1);
#line 945
      i0 += (size_t )inc0;
#line 945
      i1 += (size_t )inc1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 948
    goto switch_break;
    case_53: /* CIL Label */ 
#line 952
    v0___1 = (double (*)[2])((SCM *)((scm_cell *)ra0)->cdr);
#line 953
    v1___1 = (double (*)[2])((SCM *)((scm_cell *)ra1)->cdr);
    {
#line 954
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 954
      tmp___4 = n;
#line 954
      n --;
#line 954
      if (! (tmp___4 > 0L)) {
#line 954
        goto while_break___2;
      }
#line 954
      (*(v0___1 + i0))[0] += (*(v1___1 + i1))[0];
#line 954
      (*(v0___1 + i0))[1] += (*(v1___1 + i1))[1];
#line 954
      i0 += (size_t )inc0;
#line 954
      i1 += (size_t )inc1;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 961
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 966
  return (1);
}
}
#line 971 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
int scm_ra_difference(SCM ra0 , SCM ras ) 
{ 
  long n ;
  size_t i0 ;
  long inc0 ;
  SCM e0 ;
  SCM tmp ;
  long tmp___0 ;
  double *v0 ;
  long tmp___1 ;
  double (*v0___0)[2] ;
  long tmp___2 ;
  SCM ra1 ;
  size_t i1 ;
  long inc1 ;
  int tmp___3 ;
  SCM e0___0 ;
  SCM e1 ;
  SCM tmp___4 ;
  long tmp___5 ;
  double *v0___1 ;
  double *v1 ;
  long tmp___6 ;
  double (*v0___2)[2] ;
  double (*v1___0)[2] ;
  long tmp___7 ;

  {
#line 976
  n = (((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )))->ubnd - ((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )))->lbnd) + 1L;
#line 977
  i0 = ((scm_array *)((scm_cell *)ra0)->cdr)->base;
#line 978
  inc0 = ((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )))->inc;
#line 979
  ra0 = ((scm_array *)((scm_cell *)ra0)->cdr)->v;
#line 980
  if ((long )(20 << 9) + 372L == ras) {
    {
#line 1003
    if ((127 & (int )((scm_cell *)ra0)->car) == 47) {
#line 1003
      goto case_47;
    }
#line 1010
    if ((127 & (int )((scm_cell *)ra0)->car) == 53) {
#line 1010
      goto case_53;
    }
#line 986
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 988
    e0 = (long )(18 << 9) + 372L;
    {
#line 989
    while (1) {
      while_continue: /* CIL Label */ ;
#line 989
      tmp___0 = n;
#line 989
      n --;
#line 989
      if (! (tmp___0 > 0L)) {
#line 989
        goto while_break;
      }
      {
#line 990
      e0 = scm_cvref(ra0, i0, e0);
#line 990
      tmp = scm_difference(e0, (long )(18 << 9) + 372L);
#line 990
      scm_array_set_x(ra0, tmp, (SCM )((i0 << 2) + 2UL));
#line 989
      i0 += (size_t )inc0;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 991
    goto switch_break;
    case_47: /* CIL Label */ 
#line 1005
    v0 = (double *)((SCM *)((scm_cell *)ra0)->cdr);
    {
#line 1006
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1006
      tmp___1 = n;
#line 1006
      n --;
#line 1006
      if (! (tmp___1 > 0L)) {
#line 1006
        goto while_break___0;
      }
#line 1007
      *(v0 + i0) = - *(v0 + i0);
#line 1006
      i0 += (size_t )inc0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1008
    goto switch_break;
    case_53: /* CIL Label */ 
#line 1012
    v0___0 = (double (*)[2])((SCM *)((scm_cell *)ra0)->cdr);
    {
#line 1013
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1013
      tmp___2 = n;
#line 1013
      n --;
#line 1013
      if (! (tmp___2 > 0L)) {
#line 1013
        goto while_break___1;
      }
#line 1015
      (*(v0___0 + i0))[0] = - (*(v0___0 + i0))[0];
#line 1016
      (*(v0___0 + i0))[1] = - (*(v0___0 + i0))[1];
#line 1013
      i0 += (size_t )inc0;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1018
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
#line 1025
    ra1 = ((scm_cell *)ras)->car;
#line 1026
    i1 = ((scm_array *)((scm_cell *)ra1)->cdr)->base;
#line 1027
    inc1 = ((scm_array_dim *)((char *)((scm_cell *)ra1)->cdr + sizeof(scm_array )))->inc;
#line 1028
    ra1 = ((scm_array *)((scm_cell *)ra1)->cdr)->v;
#line 1029
    if ((127 & (int )((scm_cell *)ra0)->car) == (127 & (int )((scm_cell *)ra1)->car)) {
#line 1029
      tmp___3 = 127 & (int )((scm_cell *)ra0)->car;
    } else {
#line 1029
      tmp___3 = 0;
    }
    {
#line 1050
    if (tmp___3 == 47) {
#line 1050
      goto case_47___0;
    }
#line 1059
    if (tmp___3 == 53) {
#line 1059
      goto case_53___0;
    }
#line 1031
    goto switch_default___0;
    switch_default___0: /* CIL Label */ 
#line 1033
    e0___0 = (long )(18 << 9) + 372L;
#line 1033
    e1 = (long )(18 << 9) + 372L;
    {
#line 1034
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1034
      tmp___5 = n;
#line 1034
      n --;
#line 1034
      if (! (tmp___5 > 0L)) {
#line 1034
        goto while_break___2;
      }
      {
#line 1035
      e1 = scm_cvref(ra1, i1, e1);
#line 1035
      e0___0 = scm_cvref(ra0, i0, e0___0);
#line 1035
      tmp___4 = scm_difference(e0___0, e1);
#line 1035
      scm_array_set_x(ra0, tmp___4, (SCM )((i0 << 2) + 2UL));
#line 1034
      i0 += (size_t )inc0;
#line 1034
      i1 += (size_t )inc1;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1036
    goto switch_break___0;
    case_47___0: /* CIL Label */ 
#line 1052
    v0___1 = (double *)((SCM *)((scm_cell *)ra0)->cdr);
#line 1053
    v1 = (double *)((SCM *)((scm_cell *)ra1)->cdr);
    {
#line 1054
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1054
      tmp___6 = n;
#line 1054
      n --;
#line 1054
      if (! (tmp___6 > 0L)) {
#line 1054
        goto while_break___3;
      }
#line 1054
      *(v0___1 + i0) -= *(v1 + i1);
#line 1054
      i0 += (size_t )inc0;
#line 1054
      i1 += (size_t )inc1;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1057
    goto switch_break___0;
    case_53___0: /* CIL Label */ 
#line 1061
    v0___2 = (double (*)[2])((SCM *)((scm_cell *)ra0)->cdr);
#line 1062
    v1___0 = (double (*)[2])((SCM *)((scm_cell *)ra1)->cdr);
    {
#line 1063
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1063
      tmp___7 = n;
#line 1063
      n --;
#line 1063
      if (! (tmp___7 > 0L)) {
#line 1063
        goto while_break___4;
      }
#line 1063
      (*(v0___2 + i0))[0] -= (*(v1___0 + i1))[0];
#line 1063
      (*(v0___2 + i0))[1] -= (*(v1___0 + i1))[1];
#line 1063
      i0 += (size_t )inc0;
#line 1063
      i1 += (size_t )inc1;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1070
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 1075
  return (1);
}
}
#line 1080 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
int scm_ra_product(SCM ra0 , SCM ras ) 
{ 
  long n ;
  size_t i0 ;
  long inc0 ;
  SCM ra1 ;
  size_t i1 ;
  long inc1 ;
  int tmp ;
  SCM e0 ;
  SCM e1 ;
  SCM tmp___0 ;
  long tmp___1 ;
  long *v0 ;
  long *v1 ;
  long tmp___2 ;
  double *v0___0 ;
  double *v1___0 ;
  long tmp___3 ;
  double (*v0___1)[2] ;
  register double r ;
  double (*v1___1)[2] ;
  long tmp___4 ;

  {
#line 1085
  n = (((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )))->ubnd - ((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )))->lbnd) + 1L;
#line 1086
  i0 = ((scm_array *)((scm_cell *)ra0)->cdr)->base;
#line 1087
  inc0 = ((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )))->inc;
#line 1088
  ra0 = ((scm_array *)((scm_cell *)ra0)->cdr)->v;
#line 1089
  if ((long )(20 << 9) + 372L != ras) {
#line 1092
    ra1 = ((scm_cell *)ras)->car;
#line 1093
    i1 = ((scm_array *)((scm_cell *)ra1)->cdr)->base;
#line 1094
    inc1 = ((scm_array_dim *)((char *)((scm_cell *)ra1)->cdr + sizeof(scm_array )))->inc;
#line 1095
    ra1 = ((scm_array *)((scm_cell *)ra1)->cdr)->v;
#line 1096
    if ((127 & (int )((scm_cell *)ra0)->car) == (127 & (int )((scm_cell *)ra1)->car)) {
#line 1096
      tmp = 127 & (int )((scm_cell *)ra0)->car;
    } else {
#line 1096
      tmp = 0;
    }
    {
#line 1107
    if (tmp == 79) {
#line 1107
      goto case_79;
    }
#line 1107
    if (tmp == 37) {
#line 1107
      goto case_79;
    }
#line 1128
    if (tmp == 47) {
#line 1128
      goto case_47;
    }
#line 1137
    if (tmp == 53) {
#line 1137
      goto case_53;
    }
#line 1098
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 1100
    e0 = (long )(18 << 9) + 372L;
#line 1100
    e1 = (long )(18 << 9) + 372L;
    {
#line 1101
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1101
      tmp___1 = n;
#line 1101
      n --;
#line 1101
      if (! (tmp___1 > 0L)) {
#line 1101
        goto while_break;
      }
      {
#line 1102
      e1 = scm_cvref(ra1, i1, e1);
#line 1102
      e0 = scm_cvref(ra0, i0, e0);
#line 1102
      tmp___0 = scm_product(e0, e1);
#line 1102
      scm_array_set_x(ra0, tmp___0, (SCM )((i0 << 2) + 2UL));
#line 1101
      i0 += (size_t )inc0;
#line 1101
      i1 += (size_t )inc1;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1104
    goto switch_break;
    case_79: /* CIL Label */ 
    case_37: /* CIL Label */ 
#line 1109
    v0 = (SCM *)((scm_cell *)ra0)->cdr;
#line 1110
    v1 = (SCM *)((scm_cell *)ra1)->cdr;
    {
#line 1111
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1111
      tmp___2 = n;
#line 1111
      n --;
#line 1111
      if (! (tmp___2 > 0L)) {
#line 1111
        goto while_break___0;
      }
#line 1111
      *(v0 + i0) *= *(v1 + i1);
#line 1111
      i0 += (size_t )inc0;
#line 1111
      i1 += (size_t )inc1;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1114
    goto switch_break;
    case_47: /* CIL Label */ 
#line 1130
    v0___0 = (double *)((SCM *)((scm_cell *)ra0)->cdr);
#line 1131
    v1___0 = (double *)((SCM *)((scm_cell *)ra1)->cdr);
    {
#line 1132
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1132
      tmp___3 = n;
#line 1132
      n --;
#line 1132
      if (! (tmp___3 > 0L)) {
#line 1132
        goto while_break___1;
      }
#line 1132
      *(v0___0 + i0) *= *(v1___0 + i1);
#line 1132
      i0 += (size_t )inc0;
#line 1132
      i1 += (size_t )inc1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1135
    goto switch_break;
    case_53: /* CIL Label */ 
#line 1139
    v0___1 = (double (*)[2])((SCM *)((scm_cell *)ra0)->cdr);
#line 1141
    v1___1 = (double (*)[2])((SCM *)((scm_cell *)ra1)->cdr);
    {
#line 1142
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1142
      tmp___4 = n;
#line 1142
      n --;
#line 1142
      if (! (tmp___4 > 0L)) {
#line 1142
        goto while_break___2;
      }
#line 1142
      r = (*(v0___1 + i0))[0] * (*(v1___1 + i1))[0] - (*(v0___1 + i0))[1] * (*(v1___1 + i1))[1];
#line 1142
      (*(v0___1 + i0))[1] = (*(v0___1 + i0))[0] * (*(v1___1 + i1))[1] + (*(v0___1 + i0))[1] * (*(v1___1 + i1))[0];
#line 1142
      (*(v0___1 + i0))[0] = r;
#line 1142
      i0 += (size_t )inc0;
#line 1142
      i1 += (size_t )inc1;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1150
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 1155
  return (1);
}
}
#line 1159 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
int scm_ra_divide(SCM ra0 , SCM ras ) 
{ 
  long n ;
  size_t i0 ;
  long inc0 ;
  SCM e0 ;
  SCM tmp ;
  long tmp___0 ;
  double *v0 ;
  long tmp___1 ;
  register double d ;
  double (*v0___0)[2] ;
  long tmp___2 ;
  SCM ra1 ;
  size_t i1 ;
  long inc1 ;
  int tmp___3 ;
  SCM e0___0 ;
  SCM e1 ;
  SCM tmp___4 ;
  long tmp___5 ;
  double *v0___1 ;
  double *v1 ;
  long tmp___6 ;
  register double d___0 ;
  register double r ;
  double (*v0___2)[2] ;
  double (*v1___0)[2] ;
  long tmp___7 ;

  {
#line 1164
  n = (((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )))->ubnd - ((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )))->lbnd) + 1L;
#line 1165
  i0 = ((scm_array *)((scm_cell *)ra0)->cdr)->base;
#line 1166
  inc0 = ((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )))->inc;
#line 1167
  ra0 = ((scm_array *)((scm_cell *)ra0)->cdr)->v;
#line 1168
  if ((long )(20 << 9) + 372L == ras) {
    {
#line 1191
    if ((127 & (int )((scm_cell *)ra0)->car) == 47) {
#line 1191
      goto case_47;
    }
#line 1198
    if ((127 & (int )((scm_cell *)ra0)->car) == 53) {
#line 1198
      goto case_53;
    }
#line 1174
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 1176
    e0 = (long )(18 << 9) + 372L;
    {
#line 1177
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1177
      tmp___0 = n;
#line 1177
      n --;
#line 1177
      if (! (tmp___0 > 0L)) {
#line 1177
        goto while_break;
      }
      {
#line 1178
      e0 = scm_cvref(ra0, i0, e0);
#line 1178
      tmp = scm_divide(e0, (long )(18 << 9) + 372L);
#line 1178
      scm_array_set_x(ra0, tmp, (SCM )((i0 << 2) + 2UL));
#line 1177
      i0 += (size_t )inc0;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1179
    goto switch_break;
    case_47: /* CIL Label */ 
#line 1193
    v0 = (double *)((SCM *)((scm_cell *)ra0)->cdr);
    {
#line 1194
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1194
      tmp___1 = n;
#line 1194
      n --;
#line 1194
      if (! (tmp___1 > 0L)) {
#line 1194
        goto while_break___0;
      }
#line 1195
      *(v0 + i0) = 1.0 / *(v0 + i0);
#line 1194
      i0 += (size_t )inc0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1196
    goto switch_break;
    case_53: /* CIL Label */ 
#line 1201
    v0___0 = (double (*)[2])((SCM *)((scm_cell *)ra0)->cdr);
    {
#line 1202
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1202
      tmp___2 = n;
#line 1202
      n --;
#line 1202
      if (! (tmp___2 > 0L)) {
#line 1202
        goto while_break___1;
      }
#line 1204
      d = (*(v0___0 + i0))[0] * (*(v0___0 + i0))[0] + (*(v0___0 + i0))[1] * (*(v0___0 + i0))[1];
#line 1205
      (*(v0___0 + i0))[0] /= d;
#line 1206
      (*(v0___0 + i0))[1] /= - d;
#line 1202
      i0 += (size_t )inc0;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1208
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
#line 1215
    ra1 = ((scm_cell *)ras)->car;
#line 1216
    i1 = ((scm_array *)((scm_cell *)ra1)->cdr)->base;
#line 1217
    inc1 = ((scm_array_dim *)((char *)((scm_cell *)ra1)->cdr + sizeof(scm_array )))->inc;
#line 1218
    ra1 = ((scm_array *)((scm_cell *)ra1)->cdr)->v;
#line 1219
    if ((127 & (int )((scm_cell *)ra0)->car) == (127 & (int )((scm_cell *)ra1)->car)) {
#line 1219
      tmp___3 = 127 & (int )((scm_cell *)ra0)->car;
    } else {
#line 1219
      tmp___3 = 0;
    }
    {
#line 1240
    if (tmp___3 == 47) {
#line 1240
      goto case_47___0;
    }
#line 1249
    if (tmp___3 == 53) {
#line 1249
      goto case_53___0;
    }
#line 1221
    goto switch_default___0;
    switch_default___0: /* CIL Label */ 
#line 1223
    e0___0 = (long )(18 << 9) + 372L;
#line 1223
    e1 = (long )(18 << 9) + 372L;
    {
#line 1224
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1224
      tmp___5 = n;
#line 1224
      n --;
#line 1224
      if (! (tmp___5 > 0L)) {
#line 1224
        goto while_break___2;
      }
      {
#line 1225
      e1 = scm_cvref(ra1, i1, e1);
#line 1225
      e0___0 = scm_cvref(ra0, i0, e0___0);
#line 1225
      tmp___4 = scm_divide(e0___0, e1);
#line 1225
      scm_array_set_x(ra0, tmp___4, (SCM )((i0 << 2) + 2UL));
#line 1224
      i0 += (size_t )inc0;
#line 1224
      i1 += (size_t )inc1;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1226
    goto switch_break___0;
    case_47___0: /* CIL Label */ 
#line 1242
    v0___1 = (double *)((SCM *)((scm_cell *)ra0)->cdr);
#line 1243
    v1 = (double *)((SCM *)((scm_cell *)ra1)->cdr);
    {
#line 1244
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1244
      tmp___6 = n;
#line 1244
      n --;
#line 1244
      if (! (tmp___6 > 0L)) {
#line 1244
        goto while_break___3;
      }
#line 1244
      *(v0___1 + i0) /= *(v1 + i1);
#line 1244
      i0 += (size_t )inc0;
#line 1244
      i1 += (size_t )inc1;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1247
    goto switch_break___0;
    case_53___0: /* CIL Label */ 
#line 1252
    v0___2 = (double (*)[2])((SCM *)((scm_cell *)ra0)->cdr);
#line 1253
    v1___0 = (double (*)[2])((SCM *)((scm_cell *)ra1)->cdr);
    {
#line 1254
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1254
      tmp___7 = n;
#line 1254
      n --;
#line 1254
      if (! (tmp___7 > 0L)) {
#line 1254
        goto while_break___4;
      }
#line 1254
      d___0 = (*(v1___0 + i1))[0] * (*(v1___0 + i1))[0] + (*(v1___0 + i1))[1] * (*(v1___0 + i1))[1];
#line 1254
      r = ((*(v0___2 + i0))[0] * (*(v1___0 + i1))[0] + (*(v0___2 + i0))[1] * (*(v1___0 + i1))[1]) / d___0;
#line 1254
      (*(v0___2 + i0))[1] = ((*(v0___2 + i0))[1] * (*(v1___0 + i1))[0] - (*(v0___2 + i0))[0] * (*(v1___0 + i1))[1]) / d___0;
#line 1254
      (*(v0___2 + i0))[0] = r;
#line 1254
      i0 += (size_t )inc0;
#line 1254
      i1 += (size_t )inc1;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1263
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 1268
  return (1);
}
}
#line 1272 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
int scm_array_identity(SCM dst , SCM src ) 
{ 
  SCM tmp ;
  int tmp___0 ;

  {
  {
#line 1277
  tmp = scm_cons(dst, (long )(20 << 9) + 372L);
#line 1277
  tmp___0 = racp(((scm_cell *)src)->car, tmp);
  }
#line 1277
  return (tmp___0);
}
}
#line 1282
static int ramap(SCM ra0 , SCM proc , SCM ras ) ;
#line 1284 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
static int ramap(SCM ra0 , SCM proc , SCM ras ) 
{ 
  long i ;
  long inc ;
  long n ;
  long base ;
  SCM tmp ;
  SCM ra1 ;
  SCM args ;
  SCM *ve ;
  size_t k ;
  size_t i1 ;
  long inc1 ;
  SCM tmp___0 ;
  size_t tmp___1 ;
  SCM tmp___2 ;
  SCM tmp___3 ;

  {
#line 1290
  i = ((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )))->lbnd;
#line 1291
  inc = ((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )))->inc;
#line 1292
  n = ((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )))->ubnd;
#line 1293
  base = (long )(((scm_array *)((scm_cell *)ra0)->cdr)->base - (size_t )(i * inc));
#line 1294
  ra0 = ((scm_array *)((scm_cell *)ra0)->cdr)->v;
#line 1295
  if ((long )(20 << 9) + 372L == ras) {
    {
#line 1297
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1297
      if (! (i <= n)) {
#line 1297
        goto while_break;
      }
      {
#line 1298
      tmp = scm_apply(proc, (long )(20 << 9) + 372L, (long )(20 << 9) + 372L);
#line 1298
      scm_array_set_x(ra0, tmp, ((i * inc + base) << 2) + 2L);
#line 1297
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1301
    ra1 = ((scm_cell *)ras)->car;
#line 1302
    ve = & ras;
#line 1303
    i1 = ((scm_array *)((scm_cell *)ra1)->cdr)->base;
#line 1304
    inc1 = ((scm_array_dim *)((char *)((scm_cell *)ra1)->cdr + sizeof(scm_array )))->inc;
#line 1305
    ra1 = ((scm_array *)((scm_cell *)ra1)->cdr)->v;
#line 1306
    ras = ((scm_cell *)ras)->cdr;
#line 1307
    if ((long )(20 << 9) + 372L == ras) {
#line 1309
      ras = scm_sys_protects[3];
    } else {
      {
#line 1312
      ras = scm_vector(ras);
#line 1313
      ve = (SCM *)((scm_cell *)ras)->cdr;
      }
    }
    {
#line 1315
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1315
      if (! (i <= n)) {
#line 1315
        goto while_break___0;
      }
#line 1317
      args = (long )(20 << 9) + 372L;
#line 1318
      k = (unsigned long )((scm_cell *)ras)->car >> 8;
      {
#line 1318
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1318
        tmp___1 = k;
#line 1318
        k --;
#line 1318
        if (! tmp___1) {
#line 1318
          goto while_break___1;
        }
        {
#line 1319
        tmp___0 = scm_uniform_vector_ref(*(ve + k), (i << 2) + 2L);
#line 1319
        args = scm_cons(tmp___0, args);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1320
      tmp___2 = scm_cvref(ra1, i1, (long )(18 << 9) + 372L);
#line 1320
      args = scm_cons(tmp___2, args);
#line 1321
      tmp___3 = scm_apply(proc, args, (long )(20 << 9) + 372L);
#line 1321
      scm_array_set_x(ra0, tmp___3, ((i * inc + base) << 2) + 2L);
#line 1315
      i ++;
#line 1315
      i1 += (size_t )inc1;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1324
  return (1);
}
}
#line 1328
static int ramap_cxr(SCM ra0 , SCM proc , SCM ras ) ;
#line 1330 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
static int ramap_cxr(SCM ra0 , SCM proc , SCM ras ) 
{ 
  SCM ra1 ;
  SCM e1 ;
  size_t i0 ;
  size_t i1 ;
  long inc0 ;
  long inc1 ;
  long n ;
  SCM tmp ;
  long tmp___0 ;
  double *dst ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 1336
  ra1 = ((scm_cell *)ras)->car;
#line 1337
  e1 = (long )(18 << 9) + 372L;
#line 1338
  i0 = ((scm_array *)((scm_cell *)ra0)->cdr)->base;
#line 1338
  i1 = ((scm_array *)((scm_cell *)ra1)->cdr)->base;
#line 1339
  inc0 = ((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )))->inc;
#line 1339
  inc1 = ((scm_array_dim *)((char *)((scm_cell *)ra1)->cdr + sizeof(scm_array )))->inc;
#line 1340
  n = (((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )))->ubnd - ((scm_array_dim *)((char *)((scm_cell *)ra1)->cdr + sizeof(scm_array )))->lbnd) + 1L;
#line 1341
  ra0 = ((scm_array *)((scm_cell *)ra0)->cdr)->v;
#line 1342
  ra1 = ((scm_array *)((scm_cell *)ra1)->cdr)->v;
  {
#line 1374
  if ((127 & (int )((scm_cell *)ra0)->car) == 47) {
#line 1374
    goto case_47;
  }
#line 1346
  goto gencase;
  gencase: 
  switch_default: /* CIL Label */ 
  {
#line 1348
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1348
    tmp___0 = n;
#line 1348
    n --;
#line 1348
    if (! (tmp___0 > 0L)) {
#line 1348
      goto while_break;
    }
    {
#line 1349
    e1 = scm_cvref(ra1, i1, e1);
#line 1349
    tmp = scm_apply(proc, e1, scm_sys_protects[1]);
#line 1349
    scm_array_set_x(ra0, tmp, (SCM )((i0 << 2) + 2UL));
#line 1348
    i0 += (size_t )inc0;
#line 1348
    i1 += (size_t )inc1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1350
  goto switch_break;
  case_47: /* CIL Label */ 
#line 1376
  dst = (double *)((SCM *)((scm_cell *)ra0)->cdr);
  {
#line 1382
  if ((127 & (int )((scm_cell *)ra1)->car) == 47) {
#line 1382
    goto case_47___0;
  }
#line 1387
  if ((127 & (int )((scm_cell *)ra1)->car) == 79) {
#line 1387
    goto case_79;
  }
#line 1387
  if ((127 & (int )((scm_cell *)ra1)->car) == 37) {
#line 1387
    goto case_79;
  }
#line 1380
  goto switch_default___0;
  switch_default___0: /* CIL Label */ 
#line 1381
  goto gencase;
  case_47___0: /* CIL Label */ 
  {
#line 1383
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1383
    tmp___1 = n;
#line 1383
    n --;
#line 1383
    if (! (tmp___1 > 0L)) {
#line 1383
      goto while_break___0;
    }
    {
#line 1384
    *(dst + i0) = (*(((scm_dsubr *)proc)->dproc))(*((double *)((SCM *)((scm_cell *)ra1)->cdr) + i1));
#line 1383
    i0 += (size_t )inc0;
#line 1383
    i1 += (size_t )inc1;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1385
  goto switch_break___0;
  case_79: /* CIL Label */ 
  case_37: /* CIL Label */ 
  {
#line 1388
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1388
    tmp___2 = n;
#line 1388
    n --;
#line 1388
    if (! (tmp___2 > 0L)) {
#line 1388
      goto while_break___1;
    }
    {
#line 1389
    *(dst + i0) = (*(((scm_dsubr *)proc)->dproc))((double )*((SCM *)((scm_cell *)ra1)->cdr + i1));
#line 1388
    i0 += (size_t )inc0;
#line 1388
    i1 += (size_t )inc1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1390
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1392
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1396
  return (1);
}
}
#line 1401
static int ramap_rp(SCM ra0 , SCM proc , SCM ras ) ;
#line 1403 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
static int ramap_rp(SCM ra0 , SCM proc , SCM ras ) 
{ 
  SCM ra1 ;
  SCM ra2 ;
  SCM e1 ;
  SCM e2 ;
  long n ;
  size_t i0 ;
  size_t i1 ;
  size_t i2 ;
  long inc0 ;
  long inc1 ;
  long inc2 ;
  int tmp ;
  SCM tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  SCM tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  SCM a1 ;
  SCM tmp___6 ;
  SCM a2 ;
  SCM tmp___7 ;
  SCM tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  SCM a1___0 ;
  SCM tmp___11 ;
  SCM a2___0 ;
  SCM tmp___12 ;
  SCM tmp___13 ;
  int tmp___14 ;
  long tmp___15 ;

  {
#line 1409
  ra1 = ((scm_cell *)ras)->car;
#line 1409
  ra2 = ((scm_cell *)((scm_cell *)ras)->cdr)->car;
#line 1410
  e1 = (long )(18 << 9) + 372L;
#line 1410
  e2 = (long )(18 << 9) + 372L;
#line 1411
  n = (((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )))->ubnd - ((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )))->lbnd) + 1L;
#line 1412
  i0 = ((scm_array *)((scm_cell *)ra0)->cdr)->base;
#line 1412
  i1 = ((scm_array *)((scm_cell *)ra1)->cdr)->base;
#line 1412
  i2 = ((scm_array *)((scm_cell *)ra2)->cdr)->base;
#line 1413
  inc0 = ((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )))->inc;
#line 1414
  inc1 = ((scm_array_dim *)((char *)((scm_cell *)ra1)->cdr + sizeof(scm_array )))->inc;
#line 1415
  inc2 = ((scm_array_dim *)((char *)((scm_cell *)ra1)->cdr + sizeof(scm_array )))->inc;
#line 1416
  ra0 = ((scm_array *)((scm_cell *)ra0)->cdr)->v;
#line 1417
  ra1 = ((scm_array *)((scm_cell *)ra1)->cdr)->v;
#line 1418
  ra2 = ((scm_array *)((scm_cell *)ra2)->cdr)->v;
#line 1419
  if ((127 & (int )((scm_cell *)ra1)->car) == (127 & (int )((scm_cell *)ra2)->car)) {
#line 1419
    tmp = 127 & (int )((scm_cell *)ra1)->car;
  } else {
#line 1419
    tmp = 0;
  }
  {
#line 1430
  if (tmp == 79) {
#line 1430
    goto case_79;
  }
#line 1430
  if (tmp == 37) {
#line 1430
    goto case_79;
  }
#line 1459
  if (tmp == 47) {
#line 1459
    goto case_47;
  }
#line 1474
  if (tmp == 53) {
#line 1474
    goto case_53;
  }
#line 1421
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 1422
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1422
    tmp___2 = n;
#line 1422
    n --;
#line 1422
    if (! (tmp___2 > 0L)) {
#line 1422
      goto while_break;
    }
#line 1423
    if (*((SCM *)((scm_cell *)ra0)->cdr + i0 / ((8UL * sizeof(long )) / sizeof(char ))) & (1L << i0 % ((8UL * sizeof(long )) / sizeof(char )))) {
#line 1423
      tmp___1 = 1;
    } else {
#line 1423
      tmp___1 = 0;
    }
#line 1423
    if (tmp___1) {
      {
#line 1425
      e2 = scm_cvref(ra2, i2, e2);
#line 1425
      e1 = scm_cvref(ra1, i1, e1);
#line 1425
      tmp___0 = (*(((scm_subr *)proc)->cproc))(e1, e2);
      }
#line 1425
      if ((long )(16 << 9) + 372L == tmp___0) {
#line 1427
        *((SCM *)((scm_cell *)ra0)->cdr + i0 / ((8UL * sizeof(long )) / sizeof(char ))) &= ~ (1L << i0 % ((8UL * sizeof(long )) / sizeof(char )));
      }
    }
#line 1422
    i0 += (size_t )inc0;
#line 1422
    i1 += (size_t )inc1;
#line 1422
    i2 += (size_t )inc2;
  }
  while_break: /* CIL Label */ ;
  }
#line 1428
  goto switch_break;
  case_79: /* CIL Label */ 
  case_37: /* CIL Label */ 
  {
#line 1431
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1431
    tmp___5 = n;
#line 1431
    n --;
#line 1431
    if (! (tmp___5 > 0L)) {
#line 1431
      goto while_break___0;
    }
#line 1432
    if (*((SCM *)((scm_cell *)ra0)->cdr + i0 / ((8UL * sizeof(long )) / sizeof(char ))) & (1L << i0 % ((8UL * sizeof(long )) / sizeof(char )))) {
#line 1432
      tmp___4 = 1;
    } else {
#line 1432
      tmp___4 = 0;
    }
#line 1432
    if (tmp___4) {
      {
#line 1435
      tmp___3 = (*(((scm_subr *)proc)->cproc))((*((SCM *)((scm_cell *)ra1)->cdr + i1) << 2) + 2L,
                                               (*((SCM *)((scm_cell *)ra2)->cdr + i2) << 2) + 2L);
      }
#line 1435
      if ((long )(16 << 9) + 372L == tmp___3) {
#line 1438
        *((SCM *)((scm_cell *)ra0)->cdr + i0 / ((8UL * sizeof(long )) / sizeof(char ))) &= ~ (1L << i0 % ((8UL * sizeof(long )) / sizeof(char )));
      }
    }
#line 1431
    i0 += (size_t )inc0;
#line 1431
    i1 += (size_t )inc1;
#line 1431
    i2 += (size_t )inc2;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1440
  goto switch_break;
  case_47: /* CIL Label */ 
  {
#line 1461
  tmp___6 = scm_makdbl(1.0 / 3.0, 0.0);
#line 1461
  a1 = tmp___6;
#line 1461
  tmp___7 = scm_makdbl(1.0 / 3.0, 0.0);
#line 1461
  a2 = tmp___7;
  }
  {
#line 1462
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1462
    tmp___10 = n;
#line 1462
    n --;
#line 1462
    if (! (tmp___10 > 0L)) {
#line 1462
      goto while_break___1;
    }
#line 1463
    if (*((SCM *)((scm_cell *)ra0)->cdr + i0 / ((8UL * sizeof(long )) / sizeof(char ))) & (1L << i0 % ((8UL * sizeof(long )) / sizeof(char )))) {
#line 1463
      tmp___9 = 1;
    } else {
#line 1463
      tmp___9 = 0;
    }
#line 1463
    if (tmp___9) {
      {
#line 1466
      *(((scm_dbl *)a1)->real) = *((double *)((SCM *)((scm_cell *)ra1)->cdr) + i1);
#line 1467
      *(((scm_dbl *)a2)->real) = *((double *)((SCM *)((scm_cell *)ra2)->cdr) + i2);
#line 1468
      tmp___8 = (*(((scm_subr *)proc)->cproc))(a1, a2);
      }
#line 1468
      if ((long )(16 << 9) + 372L == tmp___8) {
#line 1470
        *((SCM *)((scm_cell *)ra0)->cdr + i0 / ((8UL * sizeof(long )) / sizeof(char ))) &= ~ (1L << i0 % ((8UL * sizeof(long )) / sizeof(char )));
      }
    }
#line 1462
    i0 += (size_t )inc0;
#line 1462
    i1 += (size_t )inc1;
#line 1462
    i2 += (size_t )inc2;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1472
  goto switch_break;
  case_53: /* CIL Label */ 
  {
#line 1476
  tmp___11 = scm_makdbl(1.0, 1.0);
#line 1476
  a1___0 = tmp___11;
#line 1476
  tmp___12 = scm_makdbl(1.0, 1.0);
#line 1476
  a2___0 = tmp___12;
  }
  {
#line 1477
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1477
    tmp___15 = n;
#line 1477
    n --;
#line 1477
    if (! (tmp___15 > 0L)) {
#line 1477
      goto while_break___2;
    }
#line 1478
    if (*((SCM *)((scm_cell *)ra0)->cdr + i0 / ((8UL * sizeof(long )) / sizeof(char ))) & (1L << i0 % ((8UL * sizeof(long )) / sizeof(char )))) {
#line 1478
      tmp___14 = 1;
    } else {
#line 1478
      tmp___14 = 0;
    }
#line 1478
    if (tmp___14) {
      {
#line 1481
      *(((scm_dbl *)a1___0)->real) = *((double *)((SCM *)((scm_cell *)ra1)->cdr) + 2UL * i1);
#line 1482
      *((double *)((char *)((scm_cell *)a1___0)->cdr + sizeof(double ))) = *((double *)((SCM *)((scm_cell *)ra1)->cdr) + (2UL * i1 + 1UL));
#line 1483
      *(((scm_dbl *)a2___0)->real) = *((double *)((SCM *)((scm_cell *)ra2)->cdr) + 2UL * i2);
#line 1484
      *((double *)((char *)((scm_cell *)a2___0)->cdr + sizeof(double ))) = *((double *)((SCM *)((scm_cell *)ra2)->cdr) + (2UL * i2 + 1UL));
#line 1485
      tmp___13 = (*(((scm_subr *)proc)->cproc))(a1___0, a2___0);
      }
#line 1485
      if ((long )(16 << 9) + 372L == tmp___13) {
#line 1487
        *((SCM *)((scm_cell *)ra0)->cdr + i0 / ((8UL * sizeof(long )) / sizeof(char ))) &= ~ (1L << i0 % ((8UL * sizeof(long )) / sizeof(char )));
      }
    }
#line 1477
    i0 += (size_t )inc0;
#line 1477
    i1 += (size_t )inc1;
#line 1477
    i2 += (size_t )inc2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1489
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1493
  return (1);
}
}
#line 1498
static int ramap_1(SCM ra0 , SCM proc , SCM ras ) ;
#line 1500 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
static int ramap_1(SCM ra0 , SCM proc , SCM ras ) 
{ 
  SCM ra1 ;
  SCM e1 ;
  long n ;
  size_t i0 ;
  size_t i1 ;
  long inc0 ;
  long inc1 ;
  SCM tmp ;
  SCM tmp___0 ;
  long tmp___1 ;
  SCM tmp___2 ;
  long tmp___3 ;

  {
#line 1506
  ra1 = ((scm_cell *)ras)->car;
#line 1507
  e1 = (long )(18 << 9) + 372L;
#line 1508
  n = (((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )))->ubnd - ((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )))->lbnd) + 1L;
#line 1509
  i0 = ((scm_array *)((scm_cell *)ra0)->cdr)->base;
#line 1509
  i1 = ((scm_array *)((scm_cell *)ra1)->cdr)->base;
#line 1510
  inc0 = ((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )))->inc;
#line 1510
  inc1 = ((scm_array_dim *)((char *)((scm_cell *)ra1)->cdr + sizeof(scm_array )))->inc;
#line 1511
  ra0 = ((scm_array *)((scm_cell *)ra0)->cdr)->v;
#line 1512
  ra1 = ((scm_array *)((scm_cell *)ra1)->cdr)->v;
#line 1513
  if (13 == (127 & (int )((scm_cell *)ra0)->car)) {
    {
#line 1514
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1514
      tmp___1 = n;
#line 1514
      n --;
#line 1514
      if (! (tmp___1 > 0L)) {
#line 1514
        goto while_break;
      }
      {
#line 1515
      tmp = scm_cvref(ra1, i1, (long )(18 << 9) + 372L);
#line 1515
      tmp___0 = (*(((scm_subr *)proc)->cproc))(tmp);
#line 1515
      scm_array_set_x(ra0, tmp___0, (SCM )((i0 << 2) + 2UL));
#line 1514
      i0 += (size_t )inc0;
#line 1514
      i1 += (size_t )inc1;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1517
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1517
      tmp___3 = n;
#line 1517
      n --;
#line 1517
      if (! (tmp___3 > 0L)) {
#line 1517
        goto while_break___0;
      }
      {
#line 1518
      e1 = scm_cvref(ra1, i1, e1);
#line 1518
      tmp___2 = (*(((scm_subr *)proc)->cproc))(e1);
#line 1518
      scm_array_set_x(ra0, tmp___2, (SCM )((i0 << 2) + 2UL));
#line 1517
      i0 += (size_t )inc0;
#line 1517
      i1 += (size_t )inc1;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1519
  return (1);
}
}
#line 1524
static int ramap_2o(SCM ra0 , SCM proc , SCM ras ) ;
#line 1526 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
static int ramap_2o(SCM ra0 , SCM proc , SCM ras ) 
{ 
  SCM ra1 ;
  SCM e1 ;
  long n ;
  size_t i0 ;
  size_t i1 ;
  long inc0 ;
  long inc1 ;
  SCM tmp ;
  SCM tmp___0 ;
  long tmp___1 ;
  SCM tmp___2 ;
  long tmp___3 ;
  SCM ra2 ;
  SCM e2 ;
  size_t i2 ;
  long inc2 ;
  SCM tmp___4 ;
  SCM tmp___5 ;
  SCM tmp___6 ;
  long tmp___7 ;
  SCM tmp___8 ;
  long tmp___9 ;

  {
#line 1532
  ra1 = ((scm_cell *)ras)->car;
#line 1533
  e1 = (long )(18 << 9) + 372L;
#line 1534
  n = (((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )))->ubnd - ((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )))->lbnd) + 1L;
#line 1535
  i0 = ((scm_array *)((scm_cell *)ra0)->cdr)->base;
#line 1535
  i1 = ((scm_array *)((scm_cell *)ra1)->cdr)->base;
#line 1536
  inc0 = ((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )))->inc;
#line 1536
  inc1 = ((scm_array_dim *)((char *)((scm_cell *)ra1)->cdr + sizeof(scm_array )))->inc;
#line 1537
  ra0 = ((scm_array *)((scm_cell *)ra0)->cdr)->v;
#line 1538
  ra1 = ((scm_array *)((scm_cell *)ra1)->cdr)->v;
#line 1539
  ras = ((scm_cell *)ras)->cdr;
#line 1540
  if ((long )(20 << 9) + 372L == ras) {
#line 1543
    if (13 == (127 & (int )((scm_cell *)ra0)->car)) {
      {
#line 1544
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1544
        tmp___1 = n;
#line 1544
        n --;
#line 1544
        if (! (tmp___1 > 0L)) {
#line 1544
          goto while_break;
        }
        {
#line 1545
        tmp = scm_cvref(ra1, i1, (long )(18 << 9) + 372L);
#line 1545
        tmp___0 = (*(((scm_subr *)proc)->cproc))(tmp, (long )(18 << 9) + 372L);
#line 1545
        scm_array_set_x(ra0, tmp___0, (SCM )((i0 << 2) + 2UL));
#line 1544
        i0 += (size_t )inc0;
#line 1544
        i1 += (size_t )inc1;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 1548
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1548
        tmp___3 = n;
#line 1548
        n --;
#line 1548
        if (! (tmp___3 > 0L)) {
#line 1548
          goto while_break___0;
        }
        {
#line 1549
        e1 = scm_cvref(ra1, i1, e1);
#line 1549
        tmp___2 = (*(((scm_subr *)proc)->cproc))(e1, (long )(18 << 9) + 372L);
#line 1549
        scm_array_set_x(ra0, tmp___2, (SCM )((i0 << 2) + 2UL));
#line 1548
        i0 += (size_t )inc0;
#line 1548
        i1 += (size_t )inc1;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  } else {
#line 1554
    ra2 = ((scm_cell *)ras)->car;
#line 1555
    e2 = (long )(18 << 9) + 372L;
#line 1556
    i2 = ((scm_array *)((scm_cell *)ra2)->cdr)->base;
#line 1557
    inc2 = ((scm_array_dim *)((char *)((scm_cell *)ra2)->cdr + sizeof(scm_array )))->inc;
#line 1558
    ra2 = ((scm_array *)((scm_cell *)ra2)->cdr)->v;
#line 1559
    if (13 == (127 & (int )((scm_cell *)ra0)->car)) {
      {
#line 1560
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1560
        tmp___7 = n;
#line 1560
        n --;
#line 1560
        if (! (tmp___7 > 0L)) {
#line 1560
          goto while_break___1;
        }
        {
#line 1561
        tmp___4 = scm_cvref(ra2, i2, (long )(18 << 9) + 372L);
#line 1561
        tmp___5 = scm_cvref(ra1, i1, (long )(18 << 9) + 372L);
#line 1561
        tmp___6 = (*(((scm_subr *)proc)->cproc))(tmp___5, tmp___4);
#line 1561
        scm_array_set_x(ra0, tmp___6, (SCM )((i0 << 2) + 2UL));
#line 1560
        i0 += (size_t )inc0;
#line 1560
        i1 += (size_t )inc1;
#line 1560
        i2 += (size_t )inc2;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
      {
#line 1565
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1565
        tmp___9 = n;
#line 1565
        n --;
#line 1565
        if (! (tmp___9 > 0L)) {
#line 1565
          goto while_break___2;
        }
        {
#line 1566
        e2 = scm_cvref(ra2, i2, e2);
#line 1566
        e1 = scm_cvref(ra1, i1, e1);
#line 1566
        tmp___8 = (*(((scm_subr *)proc)->cproc))(e1, e2);
#line 1566
        scm_array_set_x(ra0, tmp___8, (SCM )((i0 << 2) + 2UL));
#line 1565
        i0 += (size_t )inc0;
#line 1565
        i1 += (size_t )inc1;
#line 1565
        i2 += (size_t )inc2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
#line 1570
  return (1);
}
}
#line 1575
static int ramap_a(SCM ra0 , SCM proc , SCM ras ) ;
#line 1577 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
static int ramap_a(SCM ra0 , SCM proc , SCM ras ) 
{ 
  SCM e0 ;
  SCM e1 ;
  long n ;
  size_t i0 ;
  long inc0 ;
  SCM tmp ;
  long tmp___0 ;
  SCM ra1 ;
  size_t i1 ;
  long inc1 ;
  SCM tmp___1 ;
  long tmp___2 ;

  {
#line 1583
  e0 = (long )(18 << 9) + 372L;
#line 1583
  e1 = (long )(18 << 9) + 372L;
#line 1584
  n = (((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )))->ubnd - ((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )))->lbnd) + 1L;
#line 1585
  i0 = ((scm_array *)((scm_cell *)ra0)->cdr)->base;
#line 1586
  inc0 = ((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )))->inc;
#line 1587
  ra0 = ((scm_array *)((scm_cell *)ra0)->cdr)->v;
#line 1588
  if ((long )(20 << 9) + 372L == ras) {
    {
#line 1590
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1590
      tmp___0 = n;
#line 1590
      n --;
#line 1590
      if (! (tmp___0 > 0L)) {
#line 1590
        goto while_break;
      }
      {
#line 1591
      e0 = scm_cvref(ra0, i0, e0);
#line 1591
      tmp = (*(((scm_subr *)proc)->cproc))(e0, (long )(18 << 9) + 372L);
#line 1591
      scm_array_set_x(ra0, tmp, (SCM )((i0 << 2) + 2UL));
#line 1590
      i0 += (size_t )inc0;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1594
    ra1 = ((scm_cell *)ras)->car;
#line 1595
    i1 = ((scm_array *)((scm_cell *)ra1)->cdr)->base;
#line 1596
    inc1 = ((scm_array_dim *)((char *)((scm_cell *)ra1)->cdr + sizeof(scm_array )))->inc;
#line 1597
    ra1 = ((scm_array *)((scm_cell *)ra1)->cdr)->v;
    {
#line 1598
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1598
      tmp___2 = n;
#line 1598
      n --;
#line 1598
      if (! (tmp___2 > 0L)) {
#line 1598
        goto while_break___0;
      }
      {
#line 1599
      e1 = scm_cvref(ra1, i1, e1);
#line 1599
      e0 = scm_cvref(ra0, i0, e0);
#line 1599
      tmp___1 = (*(((scm_subr *)proc)->cproc))(e0, e1);
#line 1599
      scm_array_set_x(ra0, tmp___1, (SCM )((i0 << 2) + 2UL));
#line 1598
      i0 += (size_t )inc0;
#line 1598
      i1 += (size_t )inc1;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1602
  return (1);
}
}
#line 1605 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
static char s_serial_array_map[17]  = 
#line 1605
  {      (char )'s',      (char )'e',      (char )'r',      (char )'i', 
        (char )'a',      (char )'l',      (char )'-',      (char )'a', 
        (char )'r',      (char )'r',      (char )'a',      (char )'y', 
        (char )'-',      (char )'m',      (char )'a',      (char )'p', 
        (char )'\000'};
#line 1606 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
static char s_array_map[10]  = 
#line 1606
  {      (char )'a',      (char )'r',      (char )'r',      (char )'a', 
        (char )'y',      (char )'-',      (char )'m',      (char )'a', 
        (char )'p',      (char )'\000'};
#line 1608 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
SCM scm_array_map(SCM ra0 , SCM proc , SCM lra ) 
{ 
  SCM tmp ;
  ra_iproc *p ;
  SCM tmp___0 ;
  SCM prot ;
  SCM fill ;
  SCM tmp___1 ;
  SCM tail ;
  SCM ra1 ;
  SCM v0 ;
  SCM tmp___2 ;
  ra_iproc *p___0 ;
  SCM tmp___3 ;

  {
  {
#line 1614
  tmp = scm_procedure_p(proc);
  }
#line 1614
  if (! ((long )(17 << 9) + 372L == tmp)) {
    {
#line 1614
    scm_wta(proc, (char *)2, s_array_map);
    }
  }
  {
#line 1621
  if ((127 & (int )((scm_cell *)proc)->car) == 87) {
#line 1621
    goto case_87;
  }
#line 1625
  if ((127 & (int )((scm_cell *)proc)->car) == 111) {
#line 1625
    goto case_111;
  }
#line 1625
  if ((127 & (int )((scm_cell *)proc)->car) == 101) {
#line 1625
    goto case_111;
  }
#line 1628
  if ((127 & (int )((scm_cell *)proc)->car) == 93) {
#line 1628
    goto case_93;
  }
#line 1633
  if ((127 & (int )((scm_cell *)proc)->car) == 69) {
#line 1633
    goto case_69;
  }
#line 1656
  if ((127 & (int )((scm_cell *)proc)->car) == 103) {
#line 1656
    goto case_103;
  }
#line 1617
  goto gencase;
  gencase: 
  switch_default: /* CIL Label */ 
  {
#line 1619
  scm_ramapc((int (*)())(& ramap), proc, ra0, lra, s_array_map);
  }
#line 1620
  return ((long )(21 << 9) + 372L);
  case_87: /* CIL Label */ 
  {
#line 1622
  scm_ramapc((int (*)())(& ramap_1), proc, ra0, lra, s_array_map);
  }
#line 1623
  return ((long )(21 << 9) + 372L);
  case_111: /* CIL Label */ 
  case_101: /* CIL Label */ 
  {
#line 1626
  scm_ramapc((int (*)())(& ramap_2o), proc, ra0, lra, s_array_map);
  }
#line 1627
  return ((long )(21 << 9) + 372L);
  case_93: /* CIL Label */ 
#line 1629
  if (! ((scm_subr *)proc)->cproc) {
#line 1630
    goto gencase;
  }
  {
#line 1631
  scm_ramapc((int (*)())(& ramap_cxr), proc, ra0, lra, s_array_map);
  }
#line 1632
  return ((long )(21 << 9) + 372L);
  case_69: /* CIL Label */ 
  {
#line 1636
  tmp___0 = scm_array_p(ra0, (long )(17 << 9) + 372L);
  }
#line 1636
  if ((long )(16 << 9) + 372L == tmp___0) {
#line 1637
    goto gencase;
  }
  {
#line 1638
  scm_array_fill_x(ra0, (long )(17 << 9) + 372L);
#line 1639
  p = ra_rpsubrs;
  }
  {
#line 1639
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1639
    if (! p->name) {
#line 1639
      goto while_break;
    }
#line 1640
    if (proc == p->sproc) {
      {
#line 1642
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1642
        if ((long )(20 << 9) + 372L != lra) {
#line 1642
          if (! ((long )(20 << 9) + 372L != ((scm_cell *)lra)->cdr)) {
#line 1642
            goto while_break___0;
          }
        } else {
#line 1642
          goto while_break___0;
        }
        {
#line 1644
        scm_ramapc(p->vproc, (long )(18 << 9) + 372L, ra0, lra, s_array_map);
#line 1645
        lra = ((scm_cell *)lra)->cdr;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1647
      return ((long )(21 << 9) + 372L);
    }
#line 1639
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1649
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1649
    if ((long )(20 << 9) + 372L != lra) {
#line 1649
      if (! ((long )(20 << 9) + 372L != ((scm_cell *)lra)->cdr)) {
#line 1649
        goto while_break___1;
      }
    } else {
#line 1649
      goto while_break___1;
    }
    {
#line 1651
    scm_ramapc((int (*)())(& ramap_rp), proc, ra0, lra, s_array_map);
#line 1652
    lra = ((scm_cell *)lra)->cdr;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1654
  return ((long )(21 << 9) + 372L);
  case_103: /* CIL Label */ 
#line 1657
  if ((long )(20 << 9) + 372L == lra) {
    {
#line 1660
    tmp___1 = (*(((scm_subr *)proc)->cproc))((long )(18 << 9) + 372L, (long )(18 << 9) + 372L);
#line 1660
    fill = tmp___1;
    }
#line 1661
    if (2 & (int )fill) {
      {
#line 1664
      prot = scm_array_prototype(ra0);
      }
#line 1665
      if (! (6 & (int )prot)) {
#line 1665
        if ((65535 & (int )((scm_cell *)prot)->car) == 383) {
          {
#line 1666
          fill = scm_makdbl((double )(fill >> 2), 0.0);
          }
        }
      }
    }
    {
#line 1669
    scm_array_fill_x(ra0, fill);
    }
  } else {
#line 1673
    ra1 = ((scm_cell *)lra)->car;
#line 1674
    if (! (6 & (int )ra0)) {
#line 1674
      if (scm_tc16_array == (long )(65535 & (int )((scm_cell *)ra0)->car)) {
#line 1674
        tmp___2 = ((scm_array *)((scm_cell *)ra0)->cdr)->v;
      } else {
#line 1674
        tmp___2 = ra0;
      }
    } else {
#line 1674
      tmp___2 = ra0;
    }
#line 1674
    v0 = tmp___2;
#line 1679
    if (v0 == ra1) {
#line 1679
      goto _L;
    } else
#line 1679
    if (! (6 & (int )ra1)) {
#line 1679
      if (scm_tc16_array == (long )(65535 & (int )((scm_cell *)ra1)->car)) {
#line 1679
        if (v0 == ((scm_array *)((scm_cell *)ra1)->cdr)->v) {
          _L: /* CIL Label */ 
#line 1680
          if (ra0 != ra1) {
#line 1681
            goto gencase;
          } else
#line 1680
          if (scm_tc16_array == (long )(65535 & (int )((scm_cell *)ra0)->car)) {
#line 1680
            if (! (65536 & (int )((scm_cell *)ra0)->car)) {
#line 1681
              goto gencase;
            }
          }
        }
      }
    }
#line 1682
    tail = ((scm_cell *)lra)->cdr;
    {
#line 1682
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1682
      if (! ((long )(20 << 9) + 372L != tail)) {
#line 1682
        goto while_break___2;
      }
#line 1684
      ra1 = ((scm_cell *)tail)->car;
#line 1685
      if (v0 == ra1) {
#line 1686
        goto gencase;
      } else
#line 1685
      if (! (6 & (int )ra1)) {
#line 1685
        if (scm_tc16_array == (long )(65535 & (int )((scm_cell *)ra1)->car)) {
#line 1685
          if (v0 == ((scm_array *)((scm_cell *)ra1)->cdr)->v) {
#line 1686
            goto gencase;
          }
        }
      }
#line 1682
      tail = ((scm_cell *)tail)->cdr;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1688
    p___0 = ra_asubrs;
    {
#line 1688
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1688
      if (! p___0->name) {
#line 1688
        goto while_break___3;
      }
#line 1689
      if (proc == p___0->sproc) {
#line 1691
        if (ra0 != ((scm_cell *)lra)->car) {
          {
#line 1692
          tmp___3 = scm_cons(((scm_cell *)lra)->car, (long )(20 << 9) + 372L);
#line 1692
          scm_ramapc((int (*)())(& scm_array_identity), (long )(18 << 9) + 372L, ra0,
                     tmp___3, s_array_map);
          }
        }
#line 1693
        lra = ((scm_cell *)lra)->cdr;
        {
#line 1694
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 1696
          scm_ramapc(p___0->vproc, (long )(18 << 9) + 372L, ra0, lra, s_array_map);
          }
#line 1697
          if (6 & (int )lra) {
#line 1698
            return ((long )(21 << 9) + 372L);
          } else
#line 1697
          if (6 & (int )((scm_cell *)lra)->cdr) {
#line 1698
            return ((long )(21 << 9) + 372L);
          }
#line 1699
          lra = ((scm_cell *)lra)->cdr;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
#line 1688
      p___0 ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 1702
    scm_ramapc((int (*)())(& ramap_2o), proc, ra0, lra, s_array_map);
#line 1703
    lra = ((scm_cell *)lra)->cdr;
    }
#line 1704
    if (! (6 & (int )lra)) {
#line 1706
      lra = ((scm_cell *)lra)->cdr;
      {
#line 1706
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1706
        if (! (! (6 & (int )lra))) {
#line 1706
          goto while_break___5;
        }
        {
#line 1707
        scm_ramapc((int (*)())(& ramap_a), proc, ra0, lra, s_array_map);
#line 1706
        lra = ((scm_cell *)lra)->cdr;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
    }
  }
#line 1709
  return ((long )(21 << 9) + 372L);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1714
static int rafe(SCM ra0 , SCM proc , SCM ras ) ;
#line 1716 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
static int rafe(SCM ra0 , SCM proc , SCM ras ) 
{ 
  long i ;
  size_t i0 ;
  long inc0 ;
  long n ;
  SCM tmp ;
  SCM ra1 ;
  SCM args ;
  SCM *ve ;
  size_t k ;
  size_t i1 ;
  long inc1 ;
  SCM tmp___0 ;
  size_t tmp___1 ;
  SCM tmp___2 ;
  SCM tmp___3 ;

  {
#line 1722
  i = ((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )))->lbnd;
#line 1723
  i0 = ((scm_array *)((scm_cell *)ra0)->cdr)->base;
#line 1724
  inc0 = ((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )))->inc;
#line 1725
  n = ((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )))->ubnd;
#line 1726
  ra0 = ((scm_array *)((scm_cell *)ra0)->cdr)->v;
#line 1727
  if ((long )(20 << 9) + 372L == ras) {
    {
#line 1729
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1729
      if (! (i <= n)) {
#line 1729
        goto while_break;
      }
      {
#line 1730
      tmp = scm_cvref(ra0, i0, (long )(18 << 9) + 372L);
#line 1730
      scm_apply(proc, tmp, scm_sys_protects[1]);
#line 1729
      i ++;
#line 1729
      i0 += (size_t )inc0;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1733
    ra1 = ((scm_cell *)ras)->car;
#line 1734
    ve = & ras;
#line 1735
    i1 = ((scm_array *)((scm_cell *)ra1)->cdr)->base;
#line 1736
    inc1 = ((scm_array_dim *)((char *)((scm_cell *)ra1)->cdr + sizeof(scm_array )))->inc;
#line 1737
    ra1 = ((scm_array *)((scm_cell *)ra1)->cdr)->v;
#line 1738
    ras = ((scm_cell *)ras)->cdr;
#line 1739
    if ((long )(20 << 9) + 372L == ras) {
#line 1741
      ras = scm_sys_protects[3];
    } else {
      {
#line 1744
      ras = scm_vector(ras);
#line 1745
      ve = (SCM *)((scm_cell *)ras)->cdr;
      }
    }
    {
#line 1747
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1747
      if (! (i <= n)) {
#line 1747
        goto while_break___0;
      }
#line 1749
      args = (long )(20 << 9) + 372L;
#line 1750
      k = (unsigned long )((scm_cell *)ras)->car >> 8;
      {
#line 1750
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1750
        tmp___1 = k;
#line 1750
        k --;
#line 1750
        if (! tmp___1) {
#line 1750
          goto while_break___1;
        }
        {
#line 1751
        tmp___0 = scm_uniform_vector_ref(*(ve + k), (i << 2) + 2L);
#line 1751
        args = scm_cons(tmp___0, args);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1752
      tmp___2 = scm_cvref(ra1, i1, (long )(18 << 9) + 372L);
#line 1752
      tmp___3 = scm_cvref(ra0, i0, (long )(18 << 9) + 372L);
#line 1752
      args = scm_cons2(tmp___3, tmp___2, args);
#line 1753
      scm_apply(proc, args, (long )(20 << 9) + 372L);
#line 1747
      i ++;
#line 1747
      i0 += (size_t )inc0;
#line 1747
      i1 += (size_t )inc1;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1756
  return (1);
}
}
#line 1760 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
static char s_array_for_each[15]  = 
#line 1760
  {      (char )'a',      (char )'r',      (char )'r',      (char )'a', 
        (char )'y',      (char )'-',      (char )'f',      (char )'o', 
        (char )'r',      (char )'-',      (char )'e',      (char )'a', 
        (char )'c',      (char )'h',      (char )'\000'};
#line 1762 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
SCM scm_array_for_each(SCM proc , SCM ra0 , SCM lra ) 
{ 
  SCM tmp ;

  {
  {
#line 1768
  tmp = scm_procedure_p(proc);
  }
#line 1768
  if (! ((long )(17 << 9) + 372L == tmp)) {
    {
#line 1768
    scm_wta(proc, (char *)1, s_array_for_each);
    }
  }
  {
#line 1769
  scm_ramapc((int (*)())(& rafe), proc, ra0, lra, s_array_for_each);
  }
#line 1770
  return ((long )(21 << 9) + 372L);
}
}
#line 1773 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
static char s_array_index_map_x[17]  = 
#line 1773
  {      (char )'a',      (char )'r',      (char )'r',      (char )'a', 
        (char )'y',      (char )'-',      (char )'i',      (char )'n', 
        (char )'d',      (char )'e',      (char )'x',      (char )'-', 
        (char )'m',      (char )'a',      (char )'p',      (char )'!', 
        (char )'\000'};
#line 1775 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
SCM scm_array_index_map_x(SCM ra , SCM proc ) 
{ 
  size_t i ;
  SCM tmp ;
  SCM *ve ;
  SCM tmp___0 ;
  SCM args ;
  SCM inds ;
  SCM tmp___1 ;
  long *vinds ;
  int j ;
  int k ;
  int kmax ;
  int tmp___2 ;
  SCM tmp___3 ;

  {
#line 1781
  if (! (! (6 & (int )ra))) {
    {
#line 1781
    scm_wta(ra, (char *)1, s_array_index_map_x);
    }
  }
  {
#line 1782
  tmp = scm_procedure_p(proc);
  }
#line 1782
  if (! ((long )(17 << 9) + 372L == tmp)) {
    {
#line 1782
    scm_wta(proc, (char *)2, s_array_index_map_x);
    }
  }
  {
#line 1788
  if ((127 & (int )((scm_cell *)ra)->car) == 13) {
#line 1788
    goto case_13;
  }
#line 1801
  if ((127 & (int )((scm_cell *)ra)->car) == 53) {
#line 1801
    goto case_53;
  }
#line 1801
  if ((127 & (int )((scm_cell *)ra)->car) == 47) {
#line 1801
    goto case_53;
  }
#line 1801
  if ((127 & (int )((scm_cell *)ra)->car) == 45) {
#line 1801
    goto case_53;
  }
#line 1801
  if ((127 & (int )((scm_cell *)ra)->car) == 79) {
#line 1801
    goto case_53;
  }
#line 1801
  if ((127 & (int )((scm_cell *)ra)->car) == 37) {
#line 1801
    goto case_53;
  }
#line 1801
  if ((127 & (int )((scm_cell *)ra)->car) == 71) {
#line 1801
    goto case_53;
  }
#line 1801
  if ((127 & (int )((scm_cell *)ra)->car) == 21) {
#line 1801
    goto case_53;
  }
#line 1805
  if ((127 & (int )((scm_cell *)ra)->car) == 127) {
#line 1805
    goto case_127;
  }
#line 1786
  goto badarg;
  badarg: 
  switch_default: /* CIL Label */ 
  {
#line 1787
  scm_wta(ra, (char *)1, s_array_index_map_x);
  }
  case_13: /* CIL Label */ 
#line 1790
  ve = (SCM *)((scm_cell *)ra)->cdr;
#line 1791
  i = (size_t )0;
  {
#line 1791
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1791
    if (! (i < (unsigned long )((scm_cell *)ra)->car >> 8)) {
#line 1791
      goto while_break;
    }
    {
#line 1792
    *(ve + i) = scm_apply(proc, (SCM )((i << 2) + 2UL), scm_sys_protects[1]);
#line 1791
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1793
  return ((long )(21 << 9) + 372L);
  case_53: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_21: /* CIL Label */ 
#line 1802
  i = (size_t )0;
  {
#line 1802
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1802
    if (! (i < (unsigned long )((scm_cell *)ra)->car >> 8)) {
#line 1802
      goto while_break___0;
    }
    {
#line 1803
    tmp___0 = scm_apply(proc, (SCM )((i << 2) + 2UL), scm_sys_protects[1]);
#line 1803
    scm_array_set_x(ra, tmp___0, (SCM )((i << 2) + 2UL));
#line 1802
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1804
  return ((long )(21 << 9) + 372L);
  case_127: /* CIL Label */ 
#line 1806
  if (! (scm_tc16_array == (long )(65535 & (int )((scm_cell *)ra)->car))) {
#line 1806
    goto badarg;
  }
  {
#line 1808
  args = (long )(20 << 9) + 372L;
#line 1809
  tmp___1 = scm_make_uve((long )((size_t )(((scm_cell *)ra)->car >> 17)), (-1L << 2) + 2L);
#line 1809
  inds = tmp___1;
#line 1810
  vinds = (SCM *)((scm_cell *)inds)->cdr;
#line 1811
  kmax = (int )((size_t )(((scm_cell *)ra)->car >> 17) - 1UL);
#line 1812
  k = 0;
  }
  {
#line 1812
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1812
    if (! (k <= kmax)) {
#line 1812
      goto while_break___1;
    }
#line 1813
    *(vinds + k) = ((scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array )) + k)->lbnd;
#line 1812
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1814
  k = kmax;
  {
#line 1815
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1817
    if (k == kmax) {
      {
#line 1819
      *(vinds + k) = ((scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array )) + k)->lbnd;
#line 1820
      i = cind(ra, inds);
      }
      {
#line 1821
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1821
        if (! (*(vinds + k) <= ((scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array )) + k)->ubnd)) {
#line 1821
          goto while_break___3;
        }
#line 1823
        j = kmax + 1;
#line 1823
        args = (long )(20 << 9) + 372L;
        {
#line 1823
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 1823
          tmp___2 = j;
#line 1823
          j --;
#line 1823
          if (! tmp___2) {
#line 1823
            goto while_break___4;
          }
          {
#line 1824
          args = scm_cons((*(vinds + j) << 2) + 2L, args);
          }
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 1825
        tmp___3 = scm_apply(proc, args, (long )(20 << 9) + 372L);
#line 1825
        scm_array_set_x(((scm_array *)((scm_cell *)ra)->cdr)->v, tmp___3, (SCM )((i << 2) + 2UL));
#line 1826
        i += (size_t )((scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array )) + k)->inc;
#line 1821
        (*(vinds + k)) ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1828
      k --;
#line 1829
      goto __Cont;
    }
#line 1831
    if (*(vinds + k) < ((scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array )) + k)->ubnd) {
#line 1833
      (*(vinds + k)) ++;
#line 1834
      k ++;
#line 1835
      goto __Cont;
    }
#line 1837
    *(vinds + k) = ((scm_array_dim *)((char *)((scm_cell *)ra)->cdr + sizeof(scm_array )) + k)->lbnd - 1L;
#line 1838
    k --;
    __Cont: /* CIL Label */ 
#line 1815
    if (! (k >= 0)) {
#line 1815
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1841
  return ((long )(21 << 9) + 372L);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1847
static int raeql_1(SCM ra0 , SCM as_equal , SCM ra1 ) ;
#line 1849 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
static int raeql_1(SCM ra0 , SCM as_equal , SCM ra1 ) 
{ 
  SCM e0 ;
  SCM e1 ;
  size_t i0 ;
  size_t i1 ;
  long inc0 ;
  long inc1 ;
  size_t n ;
  SCM tmp ;
  SCM tmp___0 ;
  size_t tmp___1 ;
  char *v0 ;
  char *v1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  long *v0___0 ;
  long *v1___0 ;
  size_t tmp___6 ;
  double *v0___1 ;
  double *v1___1 ;
  size_t tmp___7 ;
  double (*v0___2)[2] ;
  double (*v1___2)[2] ;
  size_t tmp___8 ;

  {
#line 1855
  e0 = (long )(18 << 9) + 372L;
#line 1855
  e1 = (long )(18 << 9) + 372L;
#line 1856
  i0 = (size_t )0;
#line 1856
  i1 = (size_t )0;
#line 1857
  inc0 = 1L;
#line 1857
  inc1 = 1L;
#line 1858
  n = (unsigned long )((scm_cell *)ra0)->car >> 8;
#line 1859
  ra1 = ((scm_cell *)ra1)->car;
#line 1860
  if (scm_tc16_array == (long )(65535 & (int )((scm_cell *)ra0)->car)) {
#line 1863
    n = (size_t )((((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )))->ubnd - ((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )))->lbnd) + 1L);
#line 1864
    i0 = ((scm_array *)((scm_cell *)ra0)->cdr)->base;
#line 1865
    inc0 = ((scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array )))->inc;
#line 1866
    ra0 = ((scm_array *)((scm_cell *)ra0)->cdr)->v;
  }
#line 1868
  if (scm_tc16_array == (long )(65535 & (int )((scm_cell *)ra1)->car)) {
#line 1871
    i1 = ((scm_array *)((scm_cell *)ra1)->cdr)->base;
#line 1872
    inc1 = ((scm_array_dim *)((char *)((scm_cell *)ra1)->cdr + sizeof(scm_array )))->inc;
#line 1873
    ra1 = ((scm_array *)((scm_cell *)ra1)->cdr)->v;
  }
  {
#line 1894
  if ((127 & (int )((scm_cell *)ra0)->car) == 21) {
#line 1894
    goto case_21;
  }
#line 1903
  if ((127 & (int )((scm_cell *)ra0)->car) == 71) {
#line 1903
    goto case_71;
  }
#line 1909
  if ((127 & (int )((scm_cell *)ra0)->car) == 79) {
#line 1909
    goto case_79;
  }
#line 1909
  if ((127 & (int )((scm_cell *)ra0)->car) == 37) {
#line 1909
    goto case_79;
  }
#line 1930
  if ((127 & (int )((scm_cell *)ra0)->car) == 47) {
#line 1930
    goto case_47;
  }
#line 1939
  if ((127 & (int )((scm_cell *)ra0)->car) == 53) {
#line 1939
    goto case_53;
  }
#line 1879
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 1880
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1880
    tmp___1 = n;
#line 1880
    n --;
#line 1880
    if (! tmp___1) {
#line 1880
      goto while_break;
    }
#line 1882
    if ((long )(16 << 9) + 372L == as_equal) {
      {
#line 1885
      e1 = scm_cvref(ra1, i1, e1);
#line 1885
      e0 = scm_cvref(ra0, i0, e0);
#line 1885
      tmp = scm_array_equal_p(e0, e1);
      }
#line 1885
      if ((long )(16 << 9) + 372L == tmp) {
#line 1887
        return (0);
      }
    } else {
      {
#line 1889
      e1 = scm_cvref(ra1, i1, e1);
#line 1889
      e0 = scm_cvref(ra0, i0, e0);
#line 1889
      tmp___0 = scm_equal_p(e0, e1);
      }
#line 1889
      if ((long )(16 << 9) + 372L == tmp___0) {
#line 1891
        return (0);
      }
    }
#line 1880
    i0 += (size_t )inc0;
#line 1880
    i1 += (size_t )inc1;
  }
  while_break: /* CIL Label */ ;
  }
#line 1893
  return (1);
  case_21: /* CIL Label */ 
#line 1896
  v0 = (char *)((scm_cell *)ra0)->cdr + i0;
#line 1897
  v1 = (char *)((scm_cell *)ra1)->cdr + i1;
  {
#line 1898
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1898
    tmp___2 = n;
#line 1898
    n --;
#line 1898
    if (! tmp___2) {
#line 1898
      goto while_break___0;
    }
#line 1899
    if ((int )*v0 != (int )*v1) {
#line 1900
      return (0);
    }
#line 1898
    v0 += inc0;
#line 1898
    v1 += inc1;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1901
  return (1);
  case_71: /* CIL Label */ 
  {
#line 1904
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1904
    tmp___5 = n;
#line 1904
    n --;
#line 1904
    if (! tmp___5) {
#line 1904
      goto while_break___1;
    }
#line 1905
    if (*((SCM *)((scm_cell *)ra0)->cdr + i0 / ((8UL * sizeof(long )) / sizeof(char ))) & (1L << i0 % ((8UL * sizeof(long )) / sizeof(char )))) {
#line 1905
      tmp___3 = 1;
    } else {
#line 1905
      tmp___3 = 0;
    }
#line 1905
    if (*((SCM *)((scm_cell *)ra1)->cdr + i1 / ((8UL * sizeof(long )) / sizeof(char ))) & (1L << i1 % ((8UL * sizeof(long )) / sizeof(char )))) {
#line 1905
      tmp___4 = 1;
    } else {
#line 1905
      tmp___4 = 0;
    }
#line 1905
    if (tmp___3 != tmp___4) {
#line 1906
      return (0);
    }
#line 1904
    i0 += (size_t )inc0;
#line 1904
    i1 += (size_t )inc1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1907
  return (1);
  case_79: /* CIL Label */ 
  case_37: /* CIL Label */ 
#line 1911
  v0___0 = (SCM *)((scm_cell *)ra0)->cdr + i0;
#line 1912
  v1___0 = (SCM *)((scm_cell *)ra1)->cdr + i1;
  {
#line 1913
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1913
    tmp___6 = n;
#line 1913
    n --;
#line 1913
    if (! tmp___6) {
#line 1913
      goto while_break___2;
    }
#line 1914
    if (*v0___0 != *v1___0) {
#line 1915
      return (0);
    }
#line 1913
    v0___0 += inc0;
#line 1913
    v1___0 += inc1;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1916
  return (1);
  case_47: /* CIL Label */ 
#line 1932
  v0___1 = (double *)((SCM *)((scm_cell *)ra0)->cdr) + i0;
#line 1933
  v1___1 = (double *)((SCM *)((scm_cell *)ra1)->cdr) + i1;
  {
#line 1934
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1934
    tmp___7 = n;
#line 1934
    n --;
#line 1934
    if (! tmp___7) {
#line 1934
      goto while_break___3;
    }
#line 1935
    if (*v0___1 != *v1___1) {
#line 1936
      return (0);
    }
#line 1934
    v0___1 += inc0;
#line 1934
    v1___1 += inc1;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1937
  return (1);
  case_53: /* CIL Label */ 
#line 1941
  v0___2 = (double (*)[2])((SCM *)((scm_cell *)ra0)->cdr) + i0;
#line 1942
  v1___2 = (double (*)[2])((SCM *)((scm_cell *)ra1)->cdr) + i1;
  {
#line 1943
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1943
    tmp___8 = n;
#line 1943
    n --;
#line 1943
    if (! tmp___8) {
#line 1943
      goto while_break___4;
    }
#line 1945
    if ((*v0___2)[0] != (*v1___2)[0]) {
#line 1946
      return (0);
    }
#line 1947
    if ((*v0___2)[1] != (*v1___2)[1]) {
#line 1948
      return (0);
    }
#line 1943
    v0___2 += inc0;
#line 1943
    v1___2 += inc1;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1950
  return (1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1958
static int raeql(SCM ra0 , SCM as_equal , SCM ra1 ) ;
#line 1960 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
static int raeql(SCM ra0 , SCM as_equal , SCM ra1 ) 
{ 
  SCM v0 ;
  SCM v1 ;
  scm_array_dim dim0 ;
  scm_array_dim dim1 ;
  scm_array_dim *s0 ;
  scm_array_dim *s1 ;
  size_t bas0 ;
  size_t bas1 ;
  int k ;
  int unroll ;
  int vlen ;
  int ndim ;
  int tmp ;
  SCM tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 1966
  v0 = ra0;
#line 1966
  v1 = ra1;
#line 1968
  s0 = & dim0;
#line 1968
  s1 = & dim1;
#line 1969
  bas0 = (size_t )0;
#line 1969
  bas1 = (size_t )0;
#line 1970
  unroll = 1;
#line 1970
  vlen = 1;
#line 1970
  ndim = 1;
#line 1971
  if (scm_tc16_array == (long )(65535 & (int )((scm_cell *)ra0)->car)) {
#line 1974
    ndim = (int )((size_t )(((scm_cell *)ra0)->car >> 17));
#line 1975
    s0 = (scm_array_dim *)((char *)((scm_cell *)ra0)->cdr + sizeof(scm_array ));
#line 1976
    bas0 = ((scm_array *)((scm_cell *)ra0)->cdr)->base;
#line 1977
    v0 = ((scm_array *)((scm_cell *)ra0)->cdr)->v;
  } else {
#line 1981
    s0->inc = 1L;
#line 1982
    s0->lbnd = 0L;
#line 1983
    s0->ubnd = (long )(((unsigned long )((scm_cell *)v0)->car >> 8) - 1UL);
#line 1984
    unroll = 0;
  }
#line 1986
  if (scm_tc16_array == (long )(65535 & (int )((scm_cell *)ra1)->car)) {
#line 1989
    if ((size_t )ndim != (size_t )(((scm_cell *)ra1)->car >> 17)) {
#line 1990
      return (0);
    }
#line 1991
    s1 = (scm_array_dim *)((char *)((scm_cell *)ra1)->cdr + sizeof(scm_array ));
#line 1992
    bas1 = ((scm_array *)((scm_cell *)ra1)->cdr)->base;
#line 1993
    v1 = ((scm_array *)((scm_cell *)ra1)->cdr)->v;
  } else {
#line 1997
    if (1 != ndim) {
#line 1998
      return ((int )((long )(16 << 9) + 372L));
    }
#line 1999
    s1->inc = 1L;
#line 2000
    s1->lbnd = 0L;
#line 2001
    s1->ubnd = (long )(((unsigned long )((scm_cell *)v1)->car >> 8) - 1UL);
#line 2002
    unroll = 0;
  }
#line 2004
  if ((127 & (int )((scm_cell *)v0)->car) != (127 & (int )((scm_cell *)v1)->car)) {
#line 2005
    return (0);
  }
#line 2006
  k = ndim;
  {
#line 2006
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2006
    tmp = k;
#line 2006
    k --;
#line 2006
    if (! tmp) {
#line 2006
      goto while_break;
    }
#line 2008
    if ((s0 + k)->lbnd != (s1 + k)->lbnd) {
#line 2009
      return (0);
    } else
#line 2008
    if ((s0 + k)->ubnd != (s1 + k)->ubnd) {
#line 2009
      return (0);
    }
#line 2010
    if (unroll) {
#line 2012
      unroll = (s0 + k)->inc == (s1 + k)->inc;
#line 2013
      vlen = (int )((long )vlen * (((s0 + k)->ubnd - (s1 + k)->lbnd) + 1L));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2016
  if (unroll) {
#line 2016
    if (bas0 == bas1) {
#line 2016
      if (v0 == v1) {
#line 2017
        return ((int )((long )(17 << 9) + 372L));
      }
    }
  }
  {
#line 2018
  tmp___0 = scm_cons(ra1, (long )(20 << 9) + 372L);
#line 2018
  tmp___1 = scm_ramapc((int (*)())(& raeql_1), as_equal, ra0, tmp___0, (char *)"");
  }
#line 2018
  return (tmp___1);
}
}
#line 2022 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
SCM scm_raequal(SCM ra0 , SCM ra1 ) 
{ 
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 2027
  tmp___1 = raeql(ra0, (long )(17 << 9) + 372L, ra1);
  }
#line 2027
  if (tmp___1) {
#line 2027
    tmp___0 = (long )(17 << 9) + 372L;
  } else {
#line 2027
    tmp___0 = (long )(16 << 9) + 372L;
  }
#line 2027
  return (tmp___0);
}
}
#line 2030 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
static char s_array_equal_p[13]  = 
#line 2030
  {      (char )'a',      (char )'r',      (char )'r',      (char )'a', 
        (char )'y',      (char )'-',      (char )'e',      (char )'q', 
        (char )'u',      (char )'a',      (char )'l',      (char )'?', 
        (char )'\000'};
#line 2033 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
SCM scm_array_equal_p(SCM ra0 , SCM ra1 ) 
{ 
  SCM tmp ;
  long tmp___1 ;
  int tmp___2 ;

  {
#line 2038
  if (6 & (int )ra0) {
#line 2038
    goto callequal;
  } else
#line 2038
  if (6 & (int )ra1) {
    callequal: 
    {
#line 2039
    tmp = scm_equal_p(ra0, ra1);
    }
#line 2039
    return (tmp);
  }
  {
#line 2052
  if ((127 & (int )((scm_cell *)ra0)->car) == 13) {
#line 2052
    goto case_13;
  }
#line 2052
  if ((127 & (int )((scm_cell *)ra0)->car) == 53) {
#line 2052
    goto case_13;
  }
#line 2052
  if ((127 & (int )((scm_cell *)ra0)->car) == 47) {
#line 2052
    goto case_13;
  }
#line 2052
  if ((127 & (int )((scm_cell *)ra0)->car) == 45) {
#line 2052
    goto case_13;
  }
#line 2052
  if ((127 & (int )((scm_cell *)ra0)->car) == 79) {
#line 2052
    goto case_13;
  }
#line 2052
  if ((127 & (int )((scm_cell *)ra0)->car) == 37) {
#line 2052
    goto case_13;
  }
#line 2052
  if ((127 & (int )((scm_cell *)ra0)->car) == 21) {
#line 2052
    goto case_13;
  }
#line 2052
  if ((127 & (int )((scm_cell *)ra0)->car) == 71) {
#line 2052
    goto case_13;
  }
#line 2054
  if ((127 & (int )((scm_cell *)ra0)->car) == 127) {
#line 2054
    goto case_127;
  }
#line 2043
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 2044
  goto callequal;
  case_13: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_21: /* CIL Label */ 
  case_71: /* CIL Label */ 
#line 2053
  goto switch_break;
  case_127: /* CIL Label */ 
#line 2055
  if (! (scm_tc16_array == (long )(65535 & (int )((scm_cell *)ra0)->car))) {
#line 2056
    goto callequal;
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 2070
  if ((127 & (int )((scm_cell *)ra1)->car) == 13) {
#line 2070
    goto case_13___0;
  }
#line 2070
  if ((127 & (int )((scm_cell *)ra1)->car) == 53) {
#line 2070
    goto case_13___0;
  }
#line 2070
  if ((127 & (int )((scm_cell *)ra1)->car) == 47) {
#line 2070
    goto case_13___0;
  }
#line 2070
  if ((127 & (int )((scm_cell *)ra1)->car) == 45) {
#line 2070
    goto case_13___0;
  }
#line 2070
  if ((127 & (int )((scm_cell *)ra1)->car) == 79) {
#line 2070
    goto case_13___0;
  }
#line 2070
  if ((127 & (int )((scm_cell *)ra1)->car) == 37) {
#line 2070
    goto case_13___0;
  }
#line 2070
  if ((127 & (int )((scm_cell *)ra1)->car) == 21) {
#line 2070
    goto case_13___0;
  }
#line 2070
  if ((127 & (int )((scm_cell *)ra1)->car) == 71) {
#line 2070
    goto case_13___0;
  }
#line 2072
  if ((127 & (int )((scm_cell *)ra1)->car) == 127) {
#line 2072
    goto case_127___0;
  }
#line 2061
  goto switch_default___0;
  switch_default___0: /* CIL Label */ 
#line 2062
  goto callequal;
  case_13___0: /* CIL Label */ 
  case_53___0: /* CIL Label */ 
  case_47___0: /* CIL Label */ 
  case_45___0: /* CIL Label */ 
  case_79___0: /* CIL Label */ 
  case_37___0: /* CIL Label */ 
  case_21___0: /* CIL Label */ 
  case_71___0: /* CIL Label */ 
#line 2071
  goto switch_break___0;
  case_127___0: /* CIL Label */ 
#line 2073
  if (! (scm_tc16_array == (long )(65535 & (int )((scm_cell *)ra1)->car))) {
#line 2074
    goto callequal;
  }
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 2076
  tmp___2 = raeql(ra0, (long )(16 << 9) + 372L, ra1);
  }
#line 2076
  if (tmp___2) {
#line 2076
    tmp___1 = (long )(17 << 9) + 372L;
  } else {
#line 2076
    tmp___1 = (long )(16 << 9) + 372L;
  }
#line 2076
  return (tmp___1);
}
}
#line 2088 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
static ra_iproc ra_rpsubrs[6]  = {      {(char *)"=", (long )(18 << 9) + 372L, (int (*)())(& scm_ra_eqp)}, 
        {(char *)"<", (long )(18 << 9) + 372L, (int (*)())(& scm_ra_lessp)}, 
        {(char *)"<=", (long )(18 << 9) + 372L, (int (*)())(& scm_ra_leqp)}, 
        {(char *)">", (long )(18 << 9) + 372L, (int (*)())(& scm_ra_grp)}, 
        {(char *)">=", (long )(18 << 9) + 372L, (int (*)())(& scm_ra_greqp)}, 
        {(char *)0, (SCM )0, (int (*)())0}};
#line 2098 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
static ra_iproc ra_asubrs[5]  = {      {(char *)"+", (long )(18 << 9) + 372L, (int (*)())(& scm_ra_sum)}, 
        {(char *)"-", (long )(18 << 9) + 372L, (int (*)())(& scm_ra_difference)}, 
        {(char *)"*", (long )(18 << 9) + 372L, (int (*)())(& scm_ra_product)}, 
        {(char *)"/", (long )(18 << 9) + 372L, (int (*)())(& scm_ra_divide)}, 
        {(char *)0, (SCM )0, (int (*)())0}};
#line 2107 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
static void init_raprocs(ra_iproc *subra ) 
{ 
  size_t tmp ;
  SCM tmp___0 ;

  {
  {
#line 2111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2111
    if (! subra->name) {
#line 2111
      goto while_break;
    }
    {
#line 2112
    tmp = strlen((char const   *)subra->name);
#line 2112
    tmp___0 = scm_intern(subra->name, tmp);
#line 2112
    subra->sproc = ((scm_cell *)tmp___0)->cdr;
#line 2111
    subra ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2113
  return;
}
}
#line 2116 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
void scm_init_ramap(void) 
{ 


  {
  {
#line 2119
  init_raprocs(ra_rpsubrs);
#line 2120
  init_raprocs(ra_asubrs);
#line 2121
  scm_make_subr(s_array_equal_p, 69, (SCM (*)())(& scm_array_equal_p));
#line 2122
  (scm_smobs + (255L & (scm_tc16_array >> 8)))->equalp = & scm_raequal;
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.x"
  scm_make_gsubr(s_array_fill_x, 2, 0, 0, (SCM (*)())(& scm_array_fill_x));
#line 2
  scm_make_gsubr(s_serial_array_copy_x, 2, 0, 0, (SCM (*)())(& scm_array_copy_x));
#line 3
  scm_make_gsubr(s_array_copy_x, 2, 0, 0, (SCM (*)())(& scm_array_copy_x));
#line 4
  scm_make_gsubr(s_serial_array_map, 2, 0, 1, (SCM (*)())(& scm_array_map));
#line 5
  scm_make_gsubr(s_array_map, 2, 0, 1, (SCM (*)())(& scm_array_map));
#line 6
  scm_make_gsubr(s_array_for_each, 2, 0, 1, (SCM (*)())(& scm_array_for_each));
#line 7
  scm_make_gsubr(s_array_index_map_x, 2, 0, 0, (SCM (*)())(& scm_array_index_map_x));
#line 2124 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ramap.c"
  scm_add_feature(s_array_for_each);
  }
#line 2125
  return;
}
}
#line 62 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.h"
SCM_CELLPTR scm_heap_org ;
#line 94 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/procs.h"
SCM scm_make_subr_opt(char *name , int type , SCM (*fcn)() , int set ) ;
#line 96
SCM scm_makcclo(SCM proc , long len ) ;
#line 98
SCM scm_thunk_p(SCM obj ) ;
#line 99
void scm_init_iprocs(scm_iproc *subra , int type ) ;
#line 100
void scm_init_procs(void) ;
#line 54 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/procs.c"
SCM scm_make_subr_opt(char *name , int type , SCM (*fcn)() , int set ) 
{ 
  SCM symcell ;
  long tmp ;
  register SCM z ;

  {
  {
#line 64
  symcell = scm_sysintern(name, (long )(18 << 9) + 372L);
#line 65
  tmp = ((SCM_CELLPTR )((scm_cell *)symcell)->car - scm_heap_org) << 8;
  }
#line 66
  if (tmp >> 8 != (SCM_CELLPTR )((scm_cell *)symcell)->car - scm_heap_org) {
#line 67
    tmp = 0L;
  }
#line 68
  if (6 & (int )scm_freelist) {
    {
#line 68
    z = scm_gc_for_newcell();
    }
  } else {
#line 68
    z = scm_freelist;
#line 68
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 68
    scm_cells_allocated ++;
  }
#line 69
  ((scm_subr *)z)->cproc = fcn;
#line 70
  ((scm_cell *)z)->car = tmp + (long )type;
#line 71
  if (set) {
#line 72
    ((scm_cell *)symcell)->cdr = z;
  }
#line 73
  return (z);
}
}
#line 78 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/procs.c"
SCM scm_make_subr(char *name , int type , SCM (*fcn)() ) 
{ 
  SCM tmp ;

  {
  {
#line 84
  tmp = scm_make_subr_opt(name, type, fcn, 1);
  }
#line 84
  return (tmp);
}
}
#line 89 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/procs.c"
SCM scm_makcclo(SCM proc , long len ) 
{ 
  SCM s___0 ;
  char *tmp ;
  char *__cil_tmp5 ;

  {
#line 95
  if (6 & (int )scm_freelist) {
    {
#line 95
    s___0 = scm_gc_for_newcell();
    }
  } else {
#line 95
    s___0 = scm_freelist;
#line 95
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 95
    scm_cells_allocated ++;
  }
  {
#line 96
  scm_ints_disabled = 1;
#line 97
  tmp = scm_must_malloc((long )((unsigned long )len * sizeof(SCM )), (char *)"compiled-closure");
#line 97
  ((scm_cell *)s___0)->cdr = (SCM )tmp;
#line 98
  ((scm_cell *)s___0)->car = (len << 8) + 63L;
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    len --;
#line 99
    if (! len) {
#line 99
      goto while_break;
    }
#line 100
    *((SCM *)((scm_cell *)s___0)->cdr + len) = (long )(21 << 9) + 372L;
  }
  while_break: /* CIL Label */ ;
  }
#line 101
  *((SCM *)((scm_cell *)s___0)->cdr + 0) = proc;
#line 102
  scm_ints_disabled = 0;
#line 102
  scm_async_clock --;
#line 102
  if (0U == scm_async_clock) {
    {
#line 102
    scm_async_click();
    }
  }
#line 103
  return (s___0);
}
}
#line 109 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/procs.c"
static char s_procedure_p[11]  = 
#line 109
  {      (char )'p',      (char )'r',      (char )'o',      (char )'c', 
        (char )'e',      (char )'d',      (char )'u',      (char )'r', 
        (char )'e',      (char )'?',      (char )'\000'};
#line 111 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/procs.c"
SCM scm_procedure_p(SCM obj ) 
{ 


  {
#line 115
  if (! (6 & (int )obj)) {
    {
#line 122
    if ((127 & (int )((scm_cell *)obj)->car) == 63) {
#line 122
      goto case_63;
    }
#line 122
    if ((127 & (int )((scm_cell *)obj)->car) == 119) {
#line 122
      goto case_63;
    }
#line 122
    if ((127 & (int )((scm_cell *)obj)->car) == 117) {
#line 122
      goto case_63;
    }
#line 122
    if ((127 & (int )((scm_cell *)obj)->car) == 111) {
#line 122
      goto case_63;
    }
#line 122
    if ((127 & (int )((scm_cell *)obj)->car) == 109) {
#line 122
      goto case_63;
    }
#line 122
    if ((127 & (int )((scm_cell *)obj)->car) == 69) {
#line 122
      goto case_63;
    }
#line 122
    if ((127 & (int )((scm_cell *)obj)->car) == 101) {
#line 122
      goto case_63;
    }
#line 122
    if ((127 & (int )((scm_cell *)obj)->car) == 95) {
#line 122
      goto case_63;
    }
#line 122
    if ((127 & (int )((scm_cell *)obj)->car) == 93) {
#line 122
      goto case_63;
    }
#line 122
    if ((127 & (int )((scm_cell *)obj)->car) == 87) {
#line 122
      goto case_63;
    }
#line 122
    if ((127 & (int )((scm_cell *)obj)->car) == 85) {
#line 122
      goto case_63;
    }
#line 122
    if ((127 & (int )((scm_cell *)obj)->car) == 103) {
#line 122
      goto case_63;
    }
#line 122
    if ((127 & (int )((scm_cell *)obj)->car) == 61) {
#line 122
      goto case_63;
    }
#line 122
    if ((127 & (int )((scm_cell *)obj)->car) == 123) {
#line 122
      goto case_63;
    }
#line 122
    if ((127 & (int )((scm_cell *)obj)->car) == 115) {
#line 122
      goto case_63;
    }
#line 122
    if ((127 & (int )((scm_cell *)obj)->car) == 107) {
#line 122
      goto case_63;
    }
#line 122
    if ((127 & (int )((scm_cell *)obj)->car) == 99) {
#line 122
      goto case_63;
    }
#line 122
    if ((127 & (int )((scm_cell *)obj)->car) == 91) {
#line 122
      goto case_63;
    }
#line 122
    if ((127 & (int )((scm_cell *)obj)->car) == 83) {
#line 122
      goto case_63;
    }
#line 122
    if ((127 & (int )((scm_cell *)obj)->car) == 75) {
#line 122
      goto case_63;
    }
#line 122
    if ((127 & (int )((scm_cell *)obj)->car) == 67) {
#line 122
      goto case_63;
    }
#line 122
    if ((127 & (int )((scm_cell *)obj)->car) == 59) {
#line 122
      goto case_63;
    }
#line 122
    if ((127 & (int )((scm_cell *)obj)->car) == 51) {
#line 122
      goto case_63;
    }
#line 122
    if ((127 & (int )((scm_cell *)obj)->car) == 43) {
#line 122
      goto case_63;
    }
#line 122
    if ((127 & (int )((scm_cell *)obj)->car) == 35) {
#line 122
      goto case_63;
    }
#line 122
    if ((127 & (int )((scm_cell *)obj)->car) == 27) {
#line 122
      goto case_63;
    }
#line 122
    if ((127 & (int )((scm_cell *)obj)->car) == 19) {
#line 122
      goto case_63;
    }
#line 122
    if ((127 & (int )((scm_cell *)obj)->car) == 11) {
#line 122
      goto case_63;
    }
#line 122
    if ((127 & (int )((scm_cell *)obj)->car) == 3) {
#line 122
      goto case_63;
    }
#line 125
    goto switch_default;
    case_63: /* CIL Label */ 
    case_119: /* CIL Label */ 
    case_117: /* CIL Label */ 
    case_111: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_95: /* CIL Label */ 
    case_93: /* CIL Label */ 
    case_87: /* CIL Label */ 
    case_85: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_61: /* CIL Label */ 
    case_123: /* CIL Label */ 
    case_115: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_91: /* CIL Label */ 
    case_83: /* CIL Label */ 
    case_75: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_59: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_35: /* CIL Label */ 
    case_27: /* CIL Label */ 
    case_19: /* CIL Label */ 
    case_11: /* CIL Label */ 
    case_3: /* CIL Label */ 
#line 124
    return ((long )(17 << 9) + 372L);
    switch_default: /* CIL Label */ 
#line 126
    return ((long )(16 << 9) + 372L);
    switch_break: /* CIL Label */ ;
    }
  }
#line 128
  return ((long )(16 << 9) + 372L);
}
}
#line 131 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/procs.c"
static char s_closure_p[9]  = 
#line 131
  {      (char )'c',      (char )'l',      (char )'o',      (char )'s', 
        (char )'u',      (char )'r',      (char )'e',      (char )'?', 
        (char )'\000'};
#line 133 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/procs.c"
SCM scm_closure_p(SCM obj ) 
{ 


  {
#line 137
  if (! (6 & (int )obj)) {
    {
#line 140
    if ((127 & (int )((scm_cell *)obj)->car) == 123) {
#line 140
      goto case_123;
    }
#line 140
    if ((127 & (int )((scm_cell *)obj)->car) == 115) {
#line 140
      goto case_123;
    }
#line 140
    if ((127 & (int )((scm_cell *)obj)->car) == 107) {
#line 140
      goto case_123;
    }
#line 140
    if ((127 & (int )((scm_cell *)obj)->car) == 99) {
#line 140
      goto case_123;
    }
#line 140
    if ((127 & (int )((scm_cell *)obj)->car) == 91) {
#line 140
      goto case_123;
    }
#line 140
    if ((127 & (int )((scm_cell *)obj)->car) == 83) {
#line 140
      goto case_123;
    }
#line 140
    if ((127 & (int )((scm_cell *)obj)->car) == 75) {
#line 140
      goto case_123;
    }
#line 140
    if ((127 & (int )((scm_cell *)obj)->car) == 67) {
#line 140
      goto case_123;
    }
#line 140
    if ((127 & (int )((scm_cell *)obj)->car) == 59) {
#line 140
      goto case_123;
    }
#line 140
    if ((127 & (int )((scm_cell *)obj)->car) == 51) {
#line 140
      goto case_123;
    }
#line 140
    if ((127 & (int )((scm_cell *)obj)->car) == 43) {
#line 140
      goto case_123;
    }
#line 140
    if ((127 & (int )((scm_cell *)obj)->car) == 35) {
#line 140
      goto case_123;
    }
#line 140
    if ((127 & (int )((scm_cell *)obj)->car) == 27) {
#line 140
      goto case_123;
    }
#line 140
    if ((127 & (int )((scm_cell *)obj)->car) == 19) {
#line 140
      goto case_123;
    }
#line 140
    if ((127 & (int )((scm_cell *)obj)->car) == 11) {
#line 140
      goto case_123;
    }
#line 140
    if ((127 & (int )((scm_cell *)obj)->car) == 3) {
#line 140
      goto case_123;
    }
#line 142
    goto switch_default;
    case_123: /* CIL Label */ 
    case_115: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_91: /* CIL Label */ 
    case_83: /* CIL Label */ 
    case_75: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_59: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_35: /* CIL Label */ 
    case_27: /* CIL Label */ 
    case_19: /* CIL Label */ 
    case_11: /* CIL Label */ 
    case_3: /* CIL Label */ 
#line 141
    return ((long )(17 << 9) + 372L);
    switch_default: /* CIL Label */ ;
    switch_break: /* CIL Label */ ;
    }
  }
#line 144
  return ((long )(16 << 9) + 372L);
}
}
#line 148 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/procs.c"
SCM scm_thunk_p(SCM obj ) 
{ 


  {
#line 156
  if (! (6 & (int )obj)) {
    {
#line 159
    if ((127 & (int )((scm_cell *)obj)->car) == 123) {
#line 159
      goto case_123;
    }
#line 159
    if ((127 & (int )((scm_cell *)obj)->car) == 115) {
#line 159
      goto case_123;
    }
#line 159
    if ((127 & (int )((scm_cell *)obj)->car) == 107) {
#line 159
      goto case_123;
    }
#line 159
    if ((127 & (int )((scm_cell *)obj)->car) == 99) {
#line 159
      goto case_123;
    }
#line 159
    if ((127 & (int )((scm_cell *)obj)->car) == 91) {
#line 159
      goto case_123;
    }
#line 159
    if ((127 & (int )((scm_cell *)obj)->car) == 83) {
#line 159
      goto case_123;
    }
#line 159
    if ((127 & (int )((scm_cell *)obj)->car) == 75) {
#line 159
      goto case_123;
    }
#line 159
    if ((127 & (int )((scm_cell *)obj)->car) == 67) {
#line 159
      goto case_123;
    }
#line 159
    if ((127 & (int )((scm_cell *)obj)->car) == 59) {
#line 159
      goto case_123;
    }
#line 159
    if ((127 & (int )((scm_cell *)obj)->car) == 51) {
#line 159
      goto case_123;
    }
#line 159
    if ((127 & (int )((scm_cell *)obj)->car) == 43) {
#line 159
      goto case_123;
    }
#line 159
    if ((127 & (int )((scm_cell *)obj)->car) == 35) {
#line 159
      goto case_123;
    }
#line 159
    if ((127 & (int )((scm_cell *)obj)->car) == 27) {
#line 159
      goto case_123;
    }
#line 159
    if ((127 & (int )((scm_cell *)obj)->car) == 19) {
#line 159
      goto case_123;
    }
#line 159
    if ((127 & (int )((scm_cell *)obj)->car) == 11) {
#line 159
      goto case_123;
    }
#line 159
    if ((127 & (int )((scm_cell *)obj)->car) == 3) {
#line 159
      goto case_123;
    }
#line 168
    if ((127 & (int )((scm_cell *)obj)->car) == 63) {
#line 168
      goto case_63;
    }
#line 168
    if ((127 & (int )((scm_cell *)obj)->car) == 103) {
#line 168
      goto case_63;
    }
#line 168
    if ((127 & (int )((scm_cell *)obj)->car) == 69) {
#line 168
      goto case_63;
    }
#line 168
    if ((127 & (int )((scm_cell *)obj)->car) == 119) {
#line 168
      goto case_63;
    }
#line 168
    if ((127 & (int )((scm_cell *)obj)->car) == 109) {
#line 168
      goto case_63;
    }
#line 168
    if ((127 & (int )((scm_cell *)obj)->car) == 85) {
#line 168
      goto case_63;
    }
#line 171
    goto switch_default;
    case_123: /* CIL Label */ 
    case_115: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_91: /* CIL Label */ 
    case_83: /* CIL Label */ 
    case_75: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_59: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_35: /* CIL Label */ 
    case_27: /* CIL Label */ 
    case_19: /* CIL Label */ 
    case_11: /* CIL Label */ 
    case_3: /* CIL Label */ 
#line 160
    if ((long )(20 << 9) + 372L == ((scm_cell *)((scm_cell *)(((scm_cell *)obj)->car - 3L))->car)->car) {
#line 161
      return ((long )(17 << 9) + 372L);
    }
    case_63: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_119: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_85: /* CIL Label */ 
#line 170
    return ((long )(17 << 9) + 372L);
    switch_default: /* CIL Label */ ;
    switch_break: /* CIL Label */ ;
    }
  }
#line 174
  return ((long )(16 << 9) + 372L);
}
}
#line 179 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/procs.c"
void scm_init_iprocs(scm_iproc *subra , int type ) 
{ 


  {
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    if (! subra->scm_string) {
#line 184
      goto while_break;
    }
    {
#line 185
    scm_make_subr(subra->scm_string, type, subra->cproc);
#line 184
    subra ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  return;
}
}
#line 194 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/procs.c"
void scm_init_procs(void) 
{ 


  {
  {
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/procs.x"
  scm_make_gsubr(s_procedure_p, 1, 0, 0, (SCM (*)())(& scm_procedure_p));
#line 2
  scm_make_gsubr(s_closure_p, 1, 0, 0, (SCM (*)())(& scm_closure_p));
  }
#line 198 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/procs.c"
  return;
}
}
#line 150 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.h"
SCM scm_closure(SCM code , SCM env ) ;
#line 55 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/procprop.h"
SCM scm_procedure_properties(SCM proc ) ;
#line 56
SCM scm_set_procedure_properties_x(SCM proc , SCM new_val ) ;
#line 57
SCM scm_procedure_property(SCM p , SCM k ) ;
#line 58
SCM scm_set_procedure_property_x(SCM p , SCM k , SCM v ) ;
#line 59
void scm_init_procprop(void) ;
#line 51 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/procprop.c"
static SCM scm_stand_in_scm_proc(SCM proc ) 
{ 
  SCM answer ;
  SCM tmp ;
  SCM tmp___0 ;

  {
  {
#line 56
  answer = scm_assoc(proc, scm_sys_protects[11]);
  }
#line 57
  if (answer == (long )(16 << 9) + 372L) {
    {
#line 59
    tmp = scm_listify((long )(20 << 9) + 372L, (long )(16 << 9) + 372L, (long )(18 << 9) + 372L);
#line 59
    answer = scm_closure(tmp, (long )(20 << 9) + 372L);
#line 61
    tmp___0 = scm_cons(proc, answer);
#line 61
    scm_sys_protects[11] = scm_cons(tmp___0, scm_sys_protects[11]);
    }
  } else {
#line 65
    answer = ((scm_cell *)answer)->cdr;
  }
#line 66
  return (answer);
}
}
#line 69 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/procprop.c"
static char s_procedure_properties[21]  = 
#line 69
  {      (char )'p',      (char )'r',      (char )'o',      (char )'c', 
        (char )'e',      (char )'d',      (char )'u',      (char )'r', 
        (char )'e',      (char )'-',      (char )'p',      (char )'r', 
        (char )'o',      (char )'p',      (char )'e',      (char )'r', 
        (char )'t',      (char )'i',      (char )'e',      (char )'s', 
        (char )'\000'};
#line 71 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/procprop.c"
SCM scm_procedure_properties(SCM proc ) 
{ 
  SCM tmp ;

  {
  {
#line 75
  tmp = scm_procedure_p(proc);
  }
#line 75
  if (! tmp) {
    {
#line 75
    scm_wta(proc, (char *)1, s_procedure_properties);
    }
  }
#line 76
  if (! (6 & (int )proc)) {
#line 76
    if (! ((7 & (int )((scm_cell *)proc)->car) == 3)) {
      {
#line 77
      proc = scm_stand_in_scm_proc(proc);
      }
    }
  } else {
    {
#line 77
    proc = scm_stand_in_scm_proc(proc);
    }
  }
#line 78
  return (((scm_cell *)(((scm_cell *)proc)->car - 3L))->cdr);
}
}
#line 81 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/procprop.c"
static char s_set_procedure_properties_x[26]  = 
#line 81
  {      (char )'s',      (char )'e',      (char )'t',      (char )'-', 
        (char )'p',      (char )'r',      (char )'o',      (char )'c', 
        (char )'e',      (char )'d',      (char )'u',      (char )'r', 
        (char )'e',      (char )'-',      (char )'p',      (char )'r', 
        (char )'o',      (char )'p',      (char )'e',      (char )'r', 
        (char )'t',      (char )'i',      (char )'e',      (char )'s', 
        (char )'!',      (char )'\000'};
#line 83 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/procprop.c"
SCM scm_set_procedure_properties_x(SCM proc , SCM new_val ) 
{ 


  {
#line 88
  if (! (6 & (int )proc)) {
#line 88
    if (! ((7 & (int )((scm_cell *)proc)->car) == 3)) {
      {
#line 89
      proc = scm_stand_in_scm_proc(proc);
      }
    }
  } else {
    {
#line 89
    proc = scm_stand_in_scm_proc(proc);
    }
  }
#line 90
  if (! (6 & (int )proc)) {
#line 90
    if (! ((7 & (int )((scm_cell *)proc)->car) == 3)) {
      {
#line 90
      scm_wta(proc, (char *)1, s_set_procedure_properties_x);
      }
    }
  } else {
    {
#line 90
    scm_wta(proc, (char *)1, s_set_procedure_properties_x);
    }
  }
#line 91
  ((scm_cell *)(((scm_cell *)proc)->car - 3L))->cdr = new_val;
#line 92
  return ((long )(21 << 9) + 372L);
}
}
#line 95 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/procprop.c"
static char s_procedure_property[19]  = 
#line 95
  {      (char )'p',      (char )'r',      (char )'o',      (char )'c', 
        (char )'e',      (char )'d',      (char )'u',      (char )'r', 
        (char )'e',      (char )'-',      (char )'p',      (char )'r', 
        (char )'o',      (char )'p',      (char )'e',      (char )'r', 
        (char )'t',      (char )'y',      (char )'\000'};
#line 97 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/procprop.c"
SCM scm_procedure_property(SCM p , SCM k ) 
{ 
  SCM assoc ;
  SCM tmp ;
  SCM tmp___0 ;

  {
#line 103
  if (! (6 & (int )p)) {
#line 103
    if (! ((7 & (int )((scm_cell *)p)->car) == 3)) {
      {
#line 104
      p = scm_stand_in_scm_proc(p);
      }
    }
  } else {
    {
#line 104
    p = scm_stand_in_scm_proc(p);
    }
  }
  {
#line 105
  tmp = scm_procedure_p(p);
  }
#line 105
  if (! tmp) {
    {
#line 105
    scm_wta(p, (char *)1, s_procedure_property);
    }
  }
  {
#line 106
  assoc = scm_sloppy_assq(k, ((scm_cell *)(((scm_cell *)p)->car - 3L))->cdr);
  }
#line 107
  if (! (6 & (int )assoc)) {
#line 107
    tmp___0 = ((scm_cell *)assoc)->cdr;
  } else {
#line 107
    tmp___0 = (long )(16 << 9) + 372L;
  }
#line 107
  return (tmp___0);
}
}
#line 110 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/procprop.c"
static char s_set_procedure_property_x[24]  = 
#line 110
  {      (char )'s',      (char )'e',      (char )'t',      (char )'-', 
        (char )'p',      (char )'r',      (char )'o',      (char )'c', 
        (char )'e',      (char )'d',      (char )'u',      (char )'r', 
        (char )'e',      (char )'-',      (char )'p',      (char )'r', 
        (char )'o',      (char )'p',      (char )'e',      (char )'r', 
        (char )'t',      (char )'y',      (char )'!',      (char )'\000'};
#line 112 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/procprop.c"
SCM scm_set_procedure_property_x(SCM p , SCM k , SCM v ) 
{ 
  SCM assoc ;
  SCM tmp ;

  {
#line 119
  if (! (6 & (int )p)) {
#line 119
    if (! ((7 & (int )((scm_cell *)p)->car) == 3)) {
      {
#line 120
      p = scm_stand_in_scm_proc(p);
      }
    }
  } else {
    {
#line 120
    p = scm_stand_in_scm_proc(p);
    }
  }
#line 121
  if (! (6 & (int )p)) {
#line 121
    if (! ((7 & (int )((scm_cell *)p)->car) == 3)) {
      {
#line 121
      scm_wta(p, (char *)1, s_set_procedure_property_x);
      }
    }
  } else {
    {
#line 121
    scm_wta(p, (char *)1, s_set_procedure_property_x);
    }
  }
  {
#line 122
  assoc = scm_sloppy_assq(k, ((scm_cell *)(((scm_cell *)p)->car - 3L))->cdr);
  }
#line 123
  if (! (6 & (int )assoc)) {
#line 124
    ((scm_cell *)assoc)->cdr = v;
  } else {
    {
#line 126
    tmp = scm_acons(k, v, ((scm_cell *)(((scm_cell *)p)->car - 3L))->cdr);
#line 126
    ((scm_cell *)(((scm_cell *)p)->car - 3L))->cdr = tmp;
    }
  }
#line 127
  return ((long )(21 << 9) + 372L);
}
}
#line 133 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/procprop.c"
void scm_init_procprop(void) 
{ 


  {
  {
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/procprop.x"
  scm_make_gsubr(s_procedure_properties, 1, 0, 0, (SCM (*)())(& scm_procedure_properties));
#line 2
  scm_make_gsubr(s_set_procedure_properties_x, 2, 0, 0, (SCM (*)())(& scm_set_procedure_properties_x));
#line 3
  scm_make_gsubr(s_procedure_property, 2, 0, 0, (SCM (*)())(& scm_procedure_property));
#line 4
  scm_make_gsubr(s_set_procedure_property_x, 3, 0, 0, (SCM (*)())(& scm_set_procedure_property_x));
  }
#line 137 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/procprop.c"
  return;
}
}
#line 51 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/print.h"
scm_option scm_print_opts[2] ;
#line 86
SCM scm_print_options(SCM setting ) ;
#line 87
SCM scm_make_print_state(void) ;
#line 88
void scm_free_print_state(SCM print_state ) ;
#line 90
void scm_ipruk(char *hdr , SCM ptr , SCM port ) ;
#line 91
void scm_iprlist(char *hdr , SCM exp___0 , char tlr , SCM port , scm_print_state *pstate ) ;
#line 94
SCM scm_write(SCM obj , SCM port ) ;
#line 95
SCM scm_display(SCM obj , SCM port ) ;
#line 96
SCM scm_newline(SCM port ) ;
#line 97
SCM scm_write_char(SCM chr , SCM port ) ;
#line 98
void scm_init_print(void) ;
#line 94 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.h"
void scm_remember(SCM *ptr ) ;
#line 266 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.h"
size_t scm_iint2str(long num , int rad , char *p ) ;
#line 157 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.h"
scm_ptobfuns *scm_ptobs ;
#line 158
size_t scm_numptob ;
#line 165
void scm_fflush(SCM port ) ;
#line 55 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/genio.h"
void scm_gen_write(enum scm_string_representation_type rep , char *str_data , size_t nitems ,
                   SCM port ) ;
#line 73 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/mbstrings.h"
void scm_put_wchar(int c , SCM port , int writing ) ;
#line 74
void scm_print_mb_string(SCM exp___0 , SCM port , int writing ) ;
#line 75
void scm_print_mb_symbol(SCM exp___0 , SCM port ) ;
#line 115 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.h"
SCM scm_unmemocopy(SCM x , SCM env ) ;
#line 51 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/procprop.h"
SCM scm_i_name ;
#line 65 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/print.c"
char *scm_isymnames[22]  = 
#line 65 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/print.c"
  {      (char *)"#@and",      (char *)"#@begin",      (char *)"#@case",      (char *)"#@cond", 
        (char *)"#@do",      (char *)"#@if",      (char *)"#@lambda",      (char *)"#@let", 
        (char *)"#@let*",      (char *)"#@letrec",      (char *)"#@or",      (char *)"#@quote", 
        (char *)"#@set!",      (char *)"#@define",      (char *)"#@apply",      (char *)"#@call-with-current-continuation", 
        (char *)"#f",      (char *)"#t",      (char *)"#<undefined>",      (char *)"#<eof>", 
        (char *)"()",      (char *)"#<unspecified>"};
#line 101 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/print.c"
scm_option scm_print_opts[2]  = {      {2, (char *)"closure-hook", (unsigned long )((long )(16 << 9) + 372L), (char *)"Hook for printing closures."}, 
        {0,
      (char *)"source", 0UL, (char *)"Print closures with source."}};
#line 108 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/print.c"
static char s_print_options[24]  = 
#line 108
  {      (char )'p',      (char )'r',      (char )'i',      (char )'n', 
        (char )'t',      (char )'-',      (char )'o',      (char )'p', 
        (char )'t',      (char )'i',      (char )'o',      (char )'n', 
        (char )'s',      (char )'-',      (char )'i',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'f', 
        (char )'a',      (char )'c',      (char )'e',      (char )'\000'};
#line 110 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/print.c"
SCM scm_print_options(SCM setting ) 
{ 
  SCM ans ;
  SCM tmp ;

  {
  {
#line 114
  tmp = scm_options(setting, scm_print_opts, 2, s_print_options);
#line 114
  ans = tmp;
  }
#line 118
  return (ans);
}
}
#line 158 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/print.c"
static SCM print_state_pool  ;
#line 161 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/print.c"
static char s_current_pstate[15]  = 
#line 161
  {      (char )'c',      (char )'u',      (char )'r',      (char )'r', 
        (char )'e',      (char )'n',      (char )'t',      (char )'-', 
        (char )'p',      (char )'s',      (char )'t',      (char )'a', 
        (char )'t',      (char )'e',      (char )'\000'};
#line 163 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/print.c"
SCM scm_current_pstate(void) 
{ 


  {
#line 166
  return (((scm_cell *)((scm_cell *)print_state_pool)->cdr)->car);
}
}
#line 172
static SCM make_print_state(void) ;
#line 174 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/print.c"
static SCM make_print_state(void) 
{ 
  SCM print_state ;
  SCM tmp ;
  scm_print_state *pstate ;

  {
  {
#line 177
  tmp = scm_make_struct(((scm_cell *)print_state_pool)->car, (SCM )2, (long )(20 << 9) + 372L);
#line 177
  print_state = tmp;
#line 180
  pstate = (scm_print_state *)((SCM *)((scm_cell *)print_state)->cdr);
#line 181
  pstate->ref_vect = scm_make_vector((50L << 2) + 2L, (long )(18 << 9) + 372L, (long )(18 << 9) + 372L);
#line 184
  pstate->ref_stack = (SCM *)((scm_cell *)pstate->ref_vect)->cdr;
#line 185
  pstate->ceiling = (unsigned long )((scm_cell *)pstate->ref_vect)->car >> 8;
  }
#line 186
  return (print_state);
}
}
#line 189 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/print.c"
SCM scm_make_print_state(void) 
{ 
  SCM answer ;
  SCM tmp ;
  SCM tmp___0 ;

  {
#line 192
  answer = (SCM )0;
#line 195
  scm_ints_disabled = 1;
#line 196
  if ((long )(20 << 9) + 372L != ((scm_cell *)print_state_pool)->cdr) {
#line 198
    answer = ((scm_cell *)((scm_cell *)print_state_pool)->cdr)->car;
#line 199
    ((scm_cell *)print_state_pool)->cdr = ((scm_cell *)((scm_cell *)print_state_pool)->cdr)->cdr;
  }
#line 201
  scm_ints_disabled = 0;
#line 201
  scm_async_clock --;
#line 201
  if (0U == scm_async_clock) {
    {
#line 201
    scm_async_click();
    }
  }
#line 203
  if (answer) {
#line 203
    tmp___0 = answer;
  } else {
    {
#line 203
    tmp = make_print_state();
#line 203
    tmp___0 = tmp;
    }
  }
#line 203
  return (tmp___0);
}
}
#line 206 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/print.c"
void scm_free_print_state(SCM print_state ) 
{ 
  SCM handle ;
  scm_print_state *pstate ;

  {
#line 211
  pstate = (scm_print_state *)((SCM *)((scm_cell *)print_state)->cdr);
#line 217
  pstate->fancyp = 0UL;
#line 218
  if (6 & (int )scm_freelist) {
    {
#line 218
    handle = scm_gc_for_newcell();
    }
  } else {
#line 218
    handle = scm_freelist;
#line 218
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 218
    scm_cells_allocated ++;
  }
#line 219
  scm_ints_disabled = 1;
#line 220
  ((scm_cell *)handle)->car = print_state;
#line 221
  ((scm_cell *)handle)->cdr = ((scm_cell *)print_state_pool)->cdr;
#line 222
  ((scm_cell *)print_state_pool)->cdr = handle;
#line 223
  scm_ints_disabled = 0;
#line 223
  scm_async_clock --;
#line 223
  if (0U == scm_async_clock) {
    {
#line 223
    scm_async_click();
    }
  }
#line 224
  return;
}
}
#line 226
static void grow_ref_stack(scm_print_state *pstate ) ;
#line 228 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/print.c"
static void grow_ref_stack(scm_print_state *pstate ) 
{ 
  int new_size ;

  {
  {
#line 232
  new_size = (int )(2UL * pstate->ceiling);
#line 233
  scm_vector_set_length_x(pstate->ref_vect, (long )(new_size << 2) + 2L);
#line 234
  pstate->ref_stack = (SCM *)((scm_cell *)pstate->ref_vect)->cdr;
#line 235
  pstate->ceiling = (unsigned long )new_size;
  }
#line 236
  return;
}
}
#line 239
static void print_circref(SCM port , scm_print_state *pstate , SCM ref ) ;
#line 241 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/print.c"
static void print_circref(SCM port , scm_print_state *pstate , SCM ref ) 
{ 
  register int i ;
  int self ;

  {
#line 248
  self = (int )(pstate->top - 1UL);
#line 249
  i = (int )(pstate->top - 1UL);
#line 250
  if (! (1 & (int )((scm_cell *)*(pstate->ref_stack + i))->car)) {
    {
#line 252
    while (1) {
      while_continue: /* CIL Label */ ;
#line 252
      if (! (i > 0)) {
#line 252
        goto while_break;
      }
#line 254
      if (1 & (int )((scm_cell *)*(pstate->ref_stack + (i - 1)))->car) {
#line 256
        goto while_break;
      } else
#line 254
      if (((scm_cell *)*(pstate->ref_stack + (i - 1)))->cdr != *(pstate->ref_stack + i)) {
#line 256
        goto while_break;
      }
#line 257
      i --;
    }
    while_break: /* CIL Label */ ;
    }
#line 259
    self = i;
  }
#line 261
  i = (int )(pstate->top - 1UL);
  {
#line 261
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 262
    if (*(pstate->ref_stack + i) == ref) {
#line 263
      goto while_break___0;
    }
#line 261
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 264
  scm_gen_putc('#', port);
#line 265
  scm_intprint((long )(i - self), 10, port);
#line 266
  scm_gen_putc('#', port);
  }
#line 267
  return;
}
}
#line 273 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/print.c"
void scm_iprin1(SCM exp___0 , SCM port , scm_print_state *pstate ) 
{ 
  register long i ;
  int tmp ;
  register int i___0 ;
  unsigned long tmp___0 ;
  SCM ans ;
  long tmp___1 ;
  SCM tmp___2 ;
  SCM tmp___3 ;
  SCM name ;
  SCM code ;
  char *tmp___4 ;
  SCM tmp___5 ;
  register int i___1 ;
  unsigned long tmp___6 ;
  SCM tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int pos ;
  int end ;
  int len ;
  char *str ;
  int weird ;
  int maybe_weird ;
  int mw_pos ;
  char buf[2] ;
  register int i___2 ;
  unsigned long tmp___11 ;
  register int i___3 ;
  unsigned long tmp___12 ;
  SCM tmp___13 ;
  int tmp___17 ;
  SCM tmp___18 ;
  SCM tmp___19 ;
  SCM tmp___20 ;
  int tmp___21 ;
  register int i___4 ;
  unsigned long tmp___22 ;
  int tmp___23 ;
  void *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;

  {
  taloop: 
  {
#line 284
  if ((7 & (int )exp___0) == 6) {
#line 284
    goto case_6;
  }
#line 284
  if ((7 & (int )exp___0) == 2) {
#line 284
    goto case_6;
  }
#line 287
  if ((7 & (int )exp___0) == 4) {
#line 287
    goto case_4;
  }
#line 307
  if ((7 & (int )exp___0) == 1) {
#line 307
    goto case_1;
  }
#line 316
  if ((7 & (int )exp___0) == 0) {
#line 316
    goto case_0;
  }
#line 312
  goto idef;
  case_6: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 285
  scm_intprint(exp___0 >> 2, 10, port);
  }
#line 286
  goto switch_break;
  case_4: /* CIL Label */ 
#line 288
  if (((int )exp___0 & 255) == 244) {
    {
#line 290
    i = (long )((unsigned int )(exp___0 >> 8));
#line 291
    scm_put_wchar((int )i, port, (int )pstate->writingp);
    }
  } else
#line 294
  if ((135 & (int )exp___0) == 4) {
#line 294
    if ((unsigned long )((int )(exp___0 >> 9)) < sizeof(scm_isymnames) / sizeof(char *)) {
      {
#line 296
      scm_gen_puts((enum scm_string_representation_type )0, scm_isymnames[(int )(exp___0 >> 9)],
                   port);
      }
    } else {
#line 294
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 297
  if (((int )exp___0 & 255) == 252) {
    {
#line 299
    scm_gen_puts((enum scm_string_representation_type )0, (char *)"#@", port);
#line 300
    scm_intprint((long )((int )(524032L >> 8) & ((int )exp___0 >> 8)), 10, port);
    }
#line 301
    if (524288L & exp___0) {
#line 301
      tmp = '-';
    } else {
#line 301
      tmp = '+';
    }
    {
#line 301
    scm_gen_putc(tmp, port);
#line 302
    scm_intprint((long )((unsigned long )exp___0 >> 20), 10, port);
    }
  } else {
#line 305
    goto idef;
  }
#line 306
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 309
  scm_gen_puts((enum scm_string_representation_type )0, (char *)"#@", port);
#line 310
  exp___0 = ((scm_cell *)(exp___0 - 1L))->car;
  }
#line 311
  goto taloop;
  idef: 
  switch_default: /* CIL Label */ 
  {
#line 314
  scm_ipruk((char *)"immediate", exp___0, port);
  }
#line 315
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 319
  if ((127 & (int )((scm_cell *)exp___0)->car) == 121) {
#line 319
    goto case_121;
  }
#line 319
  if ((127 & (int )((scm_cell *)exp___0)->car) == 113) {
#line 319
    goto case_121;
  }
#line 319
  if ((127 & (int )((scm_cell *)exp___0)->car) == 105) {
#line 319
    goto case_121;
  }
#line 319
  if ((127 & (int )((scm_cell *)exp___0)->car) == 97) {
#line 319
    goto case_121;
  }
#line 319
  if ((127 & (int )((scm_cell *)exp___0)->car) == 89) {
#line 319
    goto case_121;
  }
#line 319
  if ((127 & (int )((scm_cell *)exp___0)->car) == 81) {
#line 319
    goto case_121;
  }
#line 319
  if ((127 & (int )((scm_cell *)exp___0)->car) == 73) {
#line 319
    goto case_121;
  }
#line 319
  if ((127 & (int )((scm_cell *)exp___0)->car) == 65) {
#line 319
    goto case_121;
  }
#line 319
  if ((127 & (int )((scm_cell *)exp___0)->car) == 57) {
#line 319
    goto case_121;
  }
#line 319
  if ((127 & (int )((scm_cell *)exp___0)->car) == 49) {
#line 319
    goto case_121;
  }
#line 319
  if ((127 & (int )((scm_cell *)exp___0)->car) == 41) {
#line 319
    goto case_121;
  }
#line 319
  if ((127 & (int )((scm_cell *)exp___0)->car) == 33) {
#line 319
    goto case_121;
  }
#line 319
  if ((127 & (int )((scm_cell *)exp___0)->car) == 25) {
#line 319
    goto case_121;
  }
#line 319
  if ((127 & (int )((scm_cell *)exp___0)->car) == 17) {
#line 319
    goto case_121;
  }
#line 319
  if ((127 & (int )((scm_cell *)exp___0)->car) == 9) {
#line 319
    goto case_121;
  }
#line 319
  if ((127 & (int )((scm_cell *)exp___0)->car) == 1) {
#line 319
    goto case_121;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 120) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 112) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 104) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 96) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 88) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 80) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 72) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 64) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 56) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 48) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 40) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 32) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 24) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 16) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 8) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 0) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 126) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 124) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 122) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 118) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 116) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 114) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 110) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 108) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 106) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 102) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 100) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 98) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 94) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 92) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 90) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 86) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 84) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 82) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 78) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 76) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 74) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 70) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 68) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 66) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 62) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 60) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 58) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 54) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 52) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 50) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 46) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 44) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 42) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 38) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 36) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 34) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 30) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 28) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 26) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 22) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 20) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 18) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 14) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 12) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 10) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 6) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 4) {
#line 330
    goto case_120;
  }
#line 330
  if ((127 & (int )((scm_cell *)exp___0)->car) == 2) {
#line 330
    goto case_120;
  }
#line 338
  if ((127 & (int )((scm_cell *)exp___0)->car) == 123) {
#line 338
    goto case_123;
  }
#line 338
  if ((127 & (int )((scm_cell *)exp___0)->car) == 115) {
#line 338
    goto case_123;
  }
#line 338
  if ((127 & (int )((scm_cell *)exp___0)->car) == 107) {
#line 338
    goto case_123;
  }
#line 338
  if ((127 & (int )((scm_cell *)exp___0)->car) == 99) {
#line 338
    goto case_123;
  }
#line 338
  if ((127 & (int )((scm_cell *)exp___0)->car) == 91) {
#line 338
    goto case_123;
  }
#line 338
  if ((127 & (int )((scm_cell *)exp___0)->car) == 83) {
#line 338
    goto case_123;
  }
#line 338
  if ((127 & (int )((scm_cell *)exp___0)->car) == 75) {
#line 338
    goto case_123;
  }
#line 338
  if ((127 & (int )((scm_cell *)exp___0)->car) == 67) {
#line 338
    goto case_123;
  }
#line 338
  if ((127 & (int )((scm_cell *)exp___0)->car) == 59) {
#line 338
    goto case_123;
  }
#line 338
  if ((127 & (int )((scm_cell *)exp___0)->car) == 51) {
#line 338
    goto case_123;
  }
#line 338
  if ((127 & (int )((scm_cell *)exp___0)->car) == 43) {
#line 338
    goto case_123;
  }
#line 338
  if ((127 & (int )((scm_cell *)exp___0)->car) == 35) {
#line 338
    goto case_123;
  }
#line 338
  if ((127 & (int )((scm_cell *)exp___0)->car) == 27) {
#line 338
    goto case_123;
  }
#line 338
  if ((127 & (int )((scm_cell *)exp___0)->car) == 19) {
#line 338
    goto case_123;
  }
#line 338
  if ((127 & (int )((scm_cell *)exp___0)->car) == 11) {
#line 338
    goto case_123;
  }
#line 338
  if ((127 & (int )((scm_cell *)exp___0)->car) == 3) {
#line 338
    goto case_123;
  }
#line 375
  if ((127 & (int )((scm_cell *)exp___0)->car) == 31) {
#line 375
    goto case_31;
  }
#line 375
  if ((127 & (int )((scm_cell *)exp___0)->car) == 23) {
#line 375
    goto case_31;
  }
#line 379
  if ((127 & (int )((scm_cell *)exp___0)->car) == 21) {
#line 379
    goto case_21;
  }
#line 379
  if ((127 & (int )((scm_cell *)exp___0)->car) == 29) {
#line 379
    goto case_21;
  }
#line 400
  if ((127 & (int )((scm_cell *)exp___0)->car) == 7) {
#line 400
    goto case_7;
  }
#line 400
  if ((127 & (int )((scm_cell *)exp___0)->car) == 5) {
#line 400
    goto case_7;
  }
#line 485
  if ((127 & (int )((scm_cell *)exp___0)->car) == 15) {
#line 485
    goto case_15;
  }
#line 493
  if ((127 & (int )((scm_cell *)exp___0)->car) == 13) {
#line 493
    goto case_13___0;
  }
#line 518
  if ((127 & (int )((scm_cell *)exp___0)->car) == 53) {
#line 518
    goto case_53;
  }
#line 518
  if ((127 & (int )((scm_cell *)exp___0)->car) == 47) {
#line 518
    goto case_53;
  }
#line 518
  if ((127 & (int )((scm_cell *)exp___0)->car) == 45) {
#line 518
    goto case_53;
  }
#line 518
  if ((127 & (int )((scm_cell *)exp___0)->car) == 37) {
#line 518
    goto case_53;
  }
#line 518
  if ((127 & (int )((scm_cell *)exp___0)->car) == 79) {
#line 518
    goto case_53;
  }
#line 518
  if ((127 & (int )((scm_cell *)exp___0)->car) == 55) {
#line 518
    goto case_53;
  }
#line 518
  if ((127 & (int )((scm_cell *)exp___0)->car) == 77) {
#line 518
    goto case_53;
  }
#line 518
  if ((127 & (int )((scm_cell *)exp___0)->car) == 71) {
#line 518
    goto case_53;
  }
#line 524
  if ((127 & (int )((scm_cell *)exp___0)->car) == 119) {
#line 524
    goto case_119;
  }
#line 524
  if ((127 & (int )((scm_cell *)exp___0)->car) == 117) {
#line 524
    goto case_119;
  }
#line 524
  if ((127 & (int )((scm_cell *)exp___0)->car) == 111) {
#line 524
    goto case_119;
  }
#line 524
  if ((127 & (int )((scm_cell *)exp___0)->car) == 109) {
#line 524
    goto case_119;
  }
#line 524
  if ((127 & (int )((scm_cell *)exp___0)->car) == 69) {
#line 524
    goto case_119;
  }
#line 524
  if ((127 & (int )((scm_cell *)exp___0)->car) == 101) {
#line 524
    goto case_119;
  }
#line 524
  if ((127 & (int )((scm_cell *)exp___0)->car) == 95) {
#line 524
    goto case_119;
  }
#line 524
  if ((127 & (int )((scm_cell *)exp___0)->car) == 93) {
#line 524
    goto case_119;
  }
#line 524
  if ((127 & (int )((scm_cell *)exp___0)->car) == 87) {
#line 524
    goto case_119;
  }
#line 524
  if ((127 & (int )((scm_cell *)exp___0)->car) == 85) {
#line 524
    goto case_119;
  }
#line 524
  if ((127 & (int )((scm_cell *)exp___0)->car) == 103) {
#line 524
    goto case_119;
  }
#line 533
  if ((127 & (int )((scm_cell *)exp___0)->car) == 63) {
#line 533
    goto case_63;
  }
#line 539
  if ((127 & (int )((scm_cell *)exp___0)->car) == 61) {
#line 539
    goto case_61;
  }
#line 546
  if ((127 & (int )((scm_cell *)exp___0)->car) == 125) {
#line 546
    goto case_125___0;
  }
#line 553
  if ((127 & (int )((scm_cell *)exp___0)->car) == 127) {
#line 553
    goto case_127;
  }
#line 563
  goto punk;
  case_121: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_97: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_65: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_25: /* CIL Label */ 
  case_17: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_1___0: /* CIL Label */ 
#line 321
  if (((scm_cell *)(((scm_cell *)exp___0)->car - 1L))->cdr == 0L) {
    {
#line 323
    scm_gen_write((enum scm_string_representation_type )0, (char *)"#<struct ", sizeof("#<struct ") - 1UL,
                  port);
#line 324
    scm_intprint(exp___0, 16, port);
#line 325
    scm_gen_putc('>', port);
    }
#line 326
    goto switch_break___0;
  }
  case_120: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_96: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_64: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_48: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_32: /* CIL Label */ 
  case_24: /* CIL Label */ 
  case_16: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_0___0: /* CIL Label */ 
  case_126: /* CIL Label */ 
  case_124: /* CIL Label */ 
  case_122: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_94: /* CIL Label */ 
  case_92: /* CIL Label */ 
  case_90: /* CIL Label */ 
  case_86: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_82: /* CIL Label */ 
  case_78: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_62: /* CIL Label */ 
  case_60: /* CIL Label */ 
  case_58: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_46: /* CIL Label */ 
  case_44: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_38: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_34: /* CIL Label */ 
  case_30: /* CIL Label */ 
  case_28: /* CIL Label */ 
  case_26: /* CIL Label */ 
  case_22: /* CIL Label */ 
  case_20: /* CIL Label */ 
  case_18: /* CIL Label */ 
  case_14: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_6___0: /* CIL Label */ 
  case_4___0: /* CIL Label */ 
  case_2___0: /* CIL Label */ 
#line 331
  i___0 = 0;
  {
#line 331
  while (1) {
    while_continue: /* CIL Label */ ;
#line 331
    if (! ((unsigned long )i___0 < pstate->top)) {
#line 331
      goto while_break;
    }
#line 331
    if (*(pstate->ref_stack + i___0) == exp___0) {
#line 331
      goto circref;
    }
#line 331
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 331
  if (pstate->fancyp) {
#line 331
    if (pstate->top - pstate->list_offset >= pstate->level) {
      {
#line 331
      scm_gen_putc('#', port);
      }
#line 331
      return;
    }
  }
#line 331
  tmp___0 = pstate->top;
#line 331
  (pstate->top) ++;
#line 331
  *(pstate->ref_stack + tmp___0) = exp___0;
#line 331
  if (pstate->top == pstate->ceiling) {
    {
#line 331
    grow_ref_stack(pstate);
    }
  }
  {
#line 332
  scm_iprlist((char *)"(", exp___0, (char )')', port, pstate);
#line 333
  (pstate->top) --;
  }
#line 334
  goto switch_break___0;
  circref: 
  {
#line 336
  print_circref(port, pstate, exp___0);
  }
#line 337
  goto switch_break___0;
  case_123: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_91: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_59: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_35: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_19: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 339
  tmp___7 = scm_procedure_p((SCM )scm_print_opts[0].val);
  }
#line 339
  if ((long )(16 << 9) + 372L != tmp___7) {
#line 341
    if (pstate->writingp) {
#line 341
      tmp___1 = (long )(17 << 9) + 372L;
    } else {
#line 341
      tmp___1 = (long )(16 << 9) + 372L;
    }
    {
#line 341
    tmp___2 = scm_cons(tmp___1, (long )(20 << 9) + 372L);
#line 341
    tmp___3 = scm_cons2(exp___0, port, tmp___2);
#line 341
    ans = tmp___3;
#line 346
    ans = scm_apply((SCM )scm_print_opts[0].val, ans, (long )(20 << 9) + 372L);
    }
  } else {
    {
#line 351
    name = scm_procedure_property(exp___0, scm_i_name);
#line 352
    code = ((scm_cell *)(((scm_cell *)exp___0)->car - 3L))->car;
#line 353
    scm_gen_puts((enum scm_string_representation_type )0, (char *)"#<procedure ",
                 port);
    }
#line 354
    if (! (6 & (int )name)) {
#line 354
      if ((117 & (int )((scm_cell *)name)->car) == 21) {
#line 354
        goto _L___0;
      } else
#line 354
      if ((125 & (int )((scm_cell *)name)->car) == 5) {
        _L___0: /* CIL Label */ 
#line 356
        if ((127 & (int )((scm_cell *)name)->car) == 29) {
#line 356
          tmp___4 = (char *)((scm_cell *)((scm_cell *)((scm_cell *)name)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)name)->cdr)->car >> 2);
        } else {
#line 356
          tmp___4 = (char *)((scm_cell *)name)->cdr;
        }
        {
#line 356
        scm_gen_puts((enum scm_string_representation_type )0, tmp___4, port);
#line 357
        scm_gen_putc(' ', port);
        }
      }
    }
    {
#line 359
    scm_iprin1(((scm_cell *)code)->car, port, pstate);
    }
#line 360
    if ((int )scm_print_opts[1].val) {
      {
#line 362
      tmp___5 = scm_acons(((scm_cell *)code)->car, (long )(20 << 9) + 372L, ((scm_cell *)exp___0)->cdr);
#line 362
      code = scm_unmemocopy(((scm_cell *)code)->cdr, tmp___5);
#line 366
      i___1 = 0;
      }
      {
#line 366
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 366
        if (! ((unsigned long )i___1 < pstate->top)) {
#line 366
          goto while_break___0;
        }
#line 366
        if (*(pstate->ref_stack + i___1) == exp___0) {
#line 366
          goto circref;
        }
#line 366
        i___1 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 366
      if (pstate->fancyp) {
#line 366
        if (pstate->top - pstate->list_offset >= pstate->level) {
          {
#line 366
          scm_gen_putc('#', port);
          }
#line 366
          return;
        }
      }
#line 366
      tmp___6 = pstate->top;
#line 366
      (pstate->top) ++;
#line 366
      *(pstate->ref_stack + tmp___6) = exp___0;
#line 366
      if (pstate->top == pstate->ceiling) {
        {
#line 366
        grow_ref_stack(pstate);
        }
      }
      {
#line 367
      scm_iprlist((char *)" ", code, (char )'>', port, pstate);
#line 368
      (pstate->top) --;
      }
    } else {
      {
#line 371
      scm_gen_putc('>', port);
      }
    }
  }
#line 373
  goto switch_break___0;
  case_31: /* CIL Label */ 
  case_23: /* CIL Label */ 
  {
#line 376
  scm_print_mb_string(exp___0, port, (int )pstate->writingp);
  }
#line 377
  goto switch_break___0;
  case_21: /* CIL Label */ 
  case_29: /* CIL Label */ 
#line 380
  if (pstate->writingp) {
    {
#line 382
    scm_gen_putc('\"', port);
#line 383
    i = 0L;
    }
    {
#line 383
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 383
      if (! ((unsigned long )i < (unsigned long )((scm_cell *)exp___0)->car >> 8)) {
#line 383
        goto while_break___1;
      }
#line 384
      if ((127 & (int )((scm_cell *)exp___0)->car) == 29) {
#line 384
        tmp___8 = (char *)((scm_cell *)((scm_cell *)((scm_cell *)exp___0)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)exp___0)->cdr)->car >> 2);
      } else {
#line 384
        tmp___8 = (char *)((scm_cell *)exp___0)->cdr;
      }
      {
#line 387
      if ((int )*(tmp___8 + i) == 92) {
#line 387
        goto case_92___0;
      }
#line 387
      if ((int )*(tmp___8 + i) == 34) {
#line 387
        goto case_92___0;
      }
#line 389
      goto switch_default___0;
      case_92___0: /* CIL Label */ 
      case_34___0: /* CIL Label */ 
      {
#line 388
      scm_gen_putc('\\', port);
      }
      switch_default___0: /* CIL Label */ 
#line 390
      if ((127 & (int )((scm_cell *)exp___0)->car) == 29) {
#line 390
        tmp___9 = (char *)((scm_cell *)((scm_cell *)((scm_cell *)exp___0)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)exp___0)->cdr)->car >> 2);
      } else {
#line 390
        tmp___9 = (char *)((scm_cell *)exp___0)->cdr;
      }
      {
#line 390
      scm_gen_putc((int )*(tmp___9 + i), port);
      }
      switch_break___1: /* CIL Label */ ;
      }
#line 383
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 392
    scm_gen_putc('\"', port);
    }
#line 393
    goto switch_break___0;
  } else {
#line 396
    if ((127 & (int )((scm_cell *)exp___0)->car) == 29) {
#line 396
      tmp___10 = (char *)((scm_cell *)((scm_cell *)((scm_cell *)exp___0)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)exp___0)->cdr)->car >> 2);
    } else {
#line 396
      tmp___10 = (char *)((scm_cell *)exp___0)->cdr;
    }
    {
#line 396
    scm_gen_write((enum scm_string_representation_type )0, tmp___10, (unsigned long )((scm_cell *)exp___0)->car >> 8,
                  port);
    }
  }
#line 399
  goto switch_break___0;
  case_7: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 401
  if ((127 & (int )((scm_cell *)exp___0)->car) == 23) {
    {
#line 403
    scm_print_mb_symbol(exp___0, port);
    }
#line 404
    goto switch_break___0;
  } else
#line 401
  if ((127 & (int )((scm_cell *)exp___0)->car) == 7) {
#line 401
    if (*((unsigned long *)((SCM *)*((SCM *)((char *)((scm_cell *)exp___0)->cdr) - 1) + 3)) != (unsigned long )((long )(16 << 9) + 372L)) {
      {
#line 403
      scm_print_mb_symbol(exp___0, port);
      }
#line 404
      goto switch_break___0;
    } else {
#line 401
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    {
#line 414
    mw_pos = 0;
#line 416
    len = (int )((unsigned long )((scm_cell *)exp___0)->car >> 8);
#line 417
    str = (char *)((scm_cell *)exp___0)->cdr;
#line 418
    scm_remember(& exp___0);
#line 419
    pos = 0;
#line 420
    weird = 0;
#line 421
    maybe_weird = 0;
    }
#line 423
    if (len == 0) {
      {
#line 424
      scm_gen_write((enum scm_string_representation_type )0, (char *)"#{}#", (size_t )4,
                    port);
      }
    }
#line 426
    end = pos;
    {
#line 426
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 426
      if (! (end < len)) {
#line 426
        goto while_break___2;
      }
      {
#line 438
      if ((int )*(str + end) == 10) {
#line 438
        goto weird_handler;
      }
#line 438
      if ((int )*(str + end) == 9) {
#line 438
        goto weird_handler;
      }
#line 438
      if ((int )*(str + end) == 12) {
#line 438
        goto weird_handler;
      }
#line 438
      if ((int )*(str + end) == 13) {
#line 438
        goto weird_handler;
      }
#line 438
      if ((int )*(str + end) == 32) {
#line 438
        goto weird_handler;
      }
#line 438
      if ((int )*(str + end) == 59) {
#line 438
        goto weird_handler;
      }
#line 438
      if ((int )*(str + end) == 34) {
#line 438
        goto weird_handler;
      }
#line 438
      if ((int )*(str + end) == 41) {
#line 438
        goto weird_handler;
      }
#line 438
      if ((int )*(str + end) == 40) {
#line 438
        goto weird_handler;
      }
#line 462
      if ((int )*(str + end) == 92) {
#line 462
        goto case_92___1;
      }
#line 472
      if ((int )*(str + end) == 35) {
#line 472
        goto case_35___0;
      }
#line 472
      if ((int )*(str + end) == 125) {
#line 472
        goto case_35___0;
      }
#line 476
      goto switch_default___1;
      weird_handler: 
      case_10___0: /* CIL Label */ 
      case_9___0: /* CIL Label */ 
      case_12___0: /* CIL Label */ 
      case_13: /* CIL Label */ 
      case_32___0: /* CIL Label */ 
      case_59___0: /* CIL Label */ 
      case_34___1: /* CIL Label */ 
      case_41___0: /* CIL Label */ 
      case_40___0: /* CIL Label */ 
#line 440
      if (maybe_weird) {
#line 442
        end = mw_pos;
#line 443
        maybe_weird = 0;
      }
#line 445
      if (! weird) {
        {
#line 447
        scm_gen_write((enum scm_string_representation_type )0, (char *)"#{", (size_t )2,
                      port);
#line 448
        weird = 1;
        }
      }
#line 450
      if (pos < end) {
        {
#line 452
        scm_gen_write((enum scm_string_representation_type )0, str + pos, (size_t )(end - pos),
                      port);
        }
      }
      {
#line 456
      buf[0] = (char )'\\';
#line 457
      buf[1] = *(str + end);
#line 458
      scm_gen_write((enum scm_string_representation_type )0, buf, (size_t )2, port);
#line 460
      pos = end + 1;
      }
#line 461
      goto switch_break___2;
      case_92___1: /* CIL Label */ 
#line 463
      if (weird) {
#line 464
        goto weird_handler;
      }
#line 465
      if (! maybe_weird) {
#line 467
        maybe_weird = 1;
#line 468
        mw_pos = pos;
      }
#line 470
      goto switch_break___2;
      case_35___0: /* CIL Label */ 
      case_125: /* CIL Label */ 
#line 473
      if (weird) {
#line 474
        goto weird_handler;
      }
#line 475
      goto switch_break___2;
      switch_default___1: /* CIL Label */ 
#line 477
      goto switch_break___2;
      switch_break___2: /* CIL Label */ ;
      }
#line 426
      end ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 479
    if (pos < end) {
      {
#line 480
      scm_gen_write((enum scm_string_representation_type )0, str + pos, (size_t )(end - pos),
                    port);
      }
    }
#line 481
    if (weird) {
      {
#line 482
      scm_gen_write((enum scm_string_representation_type )0, (char *)"}#", (size_t )2,
                    port);
      }
    }
#line 483
    goto switch_break___0;
  }
  case_15: /* CIL Label */ 
#line 486
  i___2 = 0;
  {
#line 486
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 486
    if (! ((unsigned long )i___2 < pstate->top)) {
#line 486
      goto while_break___3;
    }
#line 486
    if (*(pstate->ref_stack + i___2) == exp___0) {
#line 486
      goto circref;
    }
#line 486
    i___2 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 486
  if (pstate->fancyp) {
#line 486
    if (pstate->top - pstate->list_offset >= pstate->level) {
      {
#line 486
      scm_gen_putc('#', port);
      }
#line 486
      return;
    }
  }
#line 486
  tmp___11 = pstate->top;
#line 486
  (pstate->top) ++;
#line 486
  *(pstate->ref_stack + tmp___11) = exp___0;
#line 486
  if (pstate->top == pstate->ceiling) {
    {
#line 486
    grow_ref_stack(pstate);
    }
  }
#line 487
  if (*((SCM *)((scm_cell *)exp___0)->cdr + -1) == 1L) {
    {
#line 488
    scm_gen_puts((enum scm_string_representation_type )0, (char *)"#wh(", port);
    }
  } else {
    {
#line 490
    scm_gen_puts((enum scm_string_representation_type )0, (char *)"#w(", port);
    }
  }
#line 491
  goto common_vector_printer;
  case_13___0: /* CIL Label */ 
#line 494
  i___3 = 0;
  {
#line 494
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 494
    if (! ((unsigned long )i___3 < pstate->top)) {
#line 494
      goto while_break___4;
    }
#line 494
    if (*(pstate->ref_stack + i___3) == exp___0) {
#line 494
      goto circref;
    }
#line 494
    i___3 ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 494
  if (pstate->fancyp) {
#line 494
    if (pstate->top - pstate->list_offset >= pstate->level) {
      {
#line 494
      scm_gen_putc('#', port);
      }
#line 494
      return;
    }
  }
#line 494
  tmp___12 = pstate->top;
#line 494
  (pstate->top) ++;
#line 494
  *(pstate->ref_stack + tmp___12) = exp___0;
#line 494
  if (pstate->top == pstate->ceiling) {
    {
#line 494
    grow_ref_stack(pstate);
    }
  }
  {
#line 495
  scm_gen_puts((enum scm_string_representation_type )0, (char *)"#(", port);
  }
  common_vector_printer: 
#line 497
  i = 0L;
  {
#line 497
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 497
    if (! ((unsigned long )(i + 1L) < (unsigned long )((scm_cell *)exp___0)->car >> 8)) {
#line 497
      goto while_break___5;
    }
    {
#line 500
    scm_iprin1(*((SCM *)((scm_cell *)exp___0)->cdr + i), port, pstate);
#line 501
    scm_gen_putc(' ', port);
#line 497
    i ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 503
  if ((unsigned long )i < (unsigned long )((scm_cell *)exp___0)->car >> 8) {
    {
#line 506
    scm_iprin1(*((SCM *)((scm_cell *)exp___0)->cdr + i), port, pstate);
    }
  }
  {
#line 508
  scm_gen_putc(')', port);
#line 509
  (pstate->top) --;
  }
#line 510
  goto switch_break___0;
  case_53: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_71: /* CIL Label */ 
  {
#line 522
  scm_raprin1(exp___0, port, pstate);
  }
#line 523
  goto switch_break___0;
  case_119: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_95: /* CIL Label */ 
  case_93: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_103: /* CIL Label */ 
  {
#line 525
  scm_gen_puts((enum scm_string_representation_type )0, (char *)"#<primitive-procedure ",
               port);
  }
#line 526
  if (((scm_cell *)exp___0)->car >> 8) {
#line 526
    tmp___13 = (SCM )(scm_heap_org + (((scm_cell *)exp___0)->car >> 8));
  } else {
#line 526
    tmp___13 = scm_sys_protects[4];
  }
#line 526
  if (((scm_cell *)exp___0)->car >> 8) {
#line 526
    tmp___18 = (SCM )(scm_heap_org + (((scm_cell *)exp___0)->car >> 8));
  } else {
#line 526
    tmp___18 = scm_sys_protects[4];
  }
#line 526
  if ((127 & (int )((scm_cell *)tmp___18)->car) == 23) {
#line 526
    tmp___17 = 1;
  } else {
#line 526
    if (((scm_cell *)exp___0)->car >> 8) {
#line 526
      tmp___19 = (SCM )(scm_heap_org + (((scm_cell *)exp___0)->car >> 8));
    } else {
#line 526
      tmp___19 = scm_sys_protects[4];
    }
#line 526
    if ((127 & (int )((scm_cell *)tmp___19)->car) == 7) {
#line 526
      if (((scm_cell *)exp___0)->car >> 8) {
#line 526
        tmp___20 = (SCM )(scm_heap_org + (((scm_cell *)exp___0)->car >> 8));
      } else {
#line 526
        tmp___20 = scm_sys_protects[4];
      }
#line 526
      if (*((unsigned long *)((SCM *)*((SCM *)((char *)((scm_cell *)tmp___20)->cdr) - 1) + 3)) != (unsigned long )((long )(16 << 9) + 372L)) {
#line 526
        tmp___17 = 1;
      } else {
#line 526
        tmp___17 = 0;
      }
    } else {
#line 526
      tmp___17 = 0;
    }
  }
  {
#line 526
  scm_gen_puts((enum scm_string_representation_type )tmp___17, (char *)((scm_cell *)tmp___13)->cdr,
               port);
#line 530
  scm_gen_putc('>', port);
  }
#line 531
  goto switch_break___0;
  case_63: /* CIL Label */ 
  {
#line 534
  scm_gen_puts((enum scm_string_representation_type )0, (char *)"#<compiled-closure ",
               port);
#line 535
  scm_iprin1(*((SCM *)((scm_cell *)exp___0)->cdr + 0), port, pstate);
#line 536
  scm_gen_putc('>', port);
  }
#line 537
  goto switch_break___0;
  case_61: /* CIL Label */ 
  {
#line 540
  scm_gen_puts((enum scm_string_representation_type )0, (char *)"#<continuation ",
               port);
#line 541
  scm_intprint((long )((unsigned long )((scm_cell *)exp___0)->car >> 8), 10, port);
#line 542
  scm_gen_puts((enum scm_string_representation_type )0, (char *)" @ ", port);
#line 543
  scm_intprint((long )((char *)((scm_cell *)exp___0)->cdr), 16, port);
#line 544
  scm_gen_putc('>', port);
  }
#line 545
  goto switch_break___0;
  case_125___0: /* CIL Label */ 
#line 547
  i = 255L & (((scm_cell *)exp___0)->car >> 8);
#line 548
  if ((size_t )i < scm_numptob) {
#line 548
    if ((scm_ptobs + i)->print) {
      {
#line 548
      tmp___21 = (*((scm_ptobs + i)->print))(exp___0, port, pstate);
      }
#line 548
      if (tmp___21) {
#line 551
        goto switch_break___0;
      }
    }
  }
#line 552
  goto punk;
  case_127: /* CIL Label */ 
#line 554
  i___4 = 0;
  {
#line 554
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 554
    if (! ((unsigned long )i___4 < pstate->top)) {
#line 554
      goto while_break___6;
    }
#line 554
    if (*(pstate->ref_stack + i___4) == exp___0) {
#line 554
      goto circref;
    }
#line 554
    i___4 ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 554
  if (pstate->fancyp) {
#line 554
    if (pstate->top - pstate->list_offset >= pstate->level) {
      {
#line 554
      scm_gen_putc('#', port);
      }
#line 554
      return;
    }
  }
#line 554
  tmp___22 = pstate->top;
#line 554
  (pstate->top) ++;
#line 554
  *(pstate->ref_stack + tmp___22) = exp___0;
#line 554
  if (pstate->top == pstate->ceiling) {
    {
#line 554
    grow_ref_stack(pstate);
    }
  }
#line 555
  i = 255L & (((scm_cell *)exp___0)->car >> 8);
#line 556
  if ((size_t )i < scm_numsmob) {
#line 556
    if ((scm_smobs + i)->print) {
      {
#line 556
      tmp___23 = (*((scm_smobs + i)->print))(exp___0, port, pstate);
      }
#line 556
      if (tmp___23) {
#line 559
        (pstate->top) --;
#line 560
        goto switch_break___0;
      }
    }
  }
#line 562
  (pstate->top) --;
  punk: 
  switch_default___2: /* CIL Label */ 
  {
#line 565
  scm_ipruk((char *)"type", exp___0, port);
  }
  switch_break___0: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
#line 568
  return;
}
}
#line 575 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/print.c"
void scm_prin1(SCM exp___0 , SCM port , int writingp ) 
{ 
  SCM handle ;
  scm_print_state *pstate ;
  SCM tmp ;

  {
#line 581
  handle = (SCM )0;
#line 585
  scm_ints_disabled = 1;
#line 586
  if ((long )(20 << 9) + 372L != ((scm_cell *)print_state_pool)->cdr) {
#line 588
    handle = ((scm_cell *)print_state_pool)->cdr;
#line 589
    ((scm_cell *)print_state_pool)->cdr = ((scm_cell *)((scm_cell *)print_state_pool)->cdr)->cdr;
  }
#line 591
  scm_ints_disabled = 0;
#line 591
  scm_async_clock --;
#line 591
  if (0U == scm_async_clock) {
    {
#line 591
    scm_async_click();
    }
  }
#line 593
  if (! handle) {
    {
#line 594
    tmp = make_print_state();
#line 594
    handle = scm_cons(tmp, (long )(20 << 9) + 372L);
    }
  }
  {
#line 596
  pstate = (scm_print_state *)((SCM *)((scm_cell *)((scm_cell *)handle)->car)->cdr);
#line 597
  pstate->writingp = (unsigned long )writingp;
#line 598
  scm_iprin1(exp___0, port, pstate);
#line 601
  scm_ints_disabled = 1;
#line 602
  ((scm_cell *)handle)->cdr = ((scm_cell *)print_state_pool)->cdr;
#line 603
  ((scm_cell *)print_state_pool)->cdr = handle;
#line 604
  scm_ints_disabled = 0;
#line 604
  scm_async_clock --;
  }
#line 604
  if (0U == scm_async_clock) {
    {
#line 604
    scm_async_click();
    }
  }
#line 605
  return;
}
}
#line 611 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/print.c"
void scm_intprint(long n , int radix , SCM port ) 
{ 
  char num_buf[5UL + (8UL * sizeof(long )) / sizeof(char )] ;
  size_t tmp ;
  void *__cil_tmp6 ;

  {
  {
#line 618
  tmp = scm_iint2str(n, radix, num_buf);
#line 618
  scm_gen_write((enum scm_string_representation_type )0, num_buf, tmp, port);
  }
#line 619
  return;
}
}
#line 624 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/print.c"
void scm_ipruk(char *hdr , SCM ptr , SCM port ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 630
  scm_gen_puts((enum scm_string_representation_type )0, (char *)"#<unknown-", port);
#line 631
  scm_gen_puts((enum scm_string_representation_type )0, hdr, port);
  }
#line 632
  if (! ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )ptr))) {
    {
#line 634
    scm_gen_puts((enum scm_string_representation_type )0, (char *)" (0x", port);
#line 635
    scm_intprint(((scm_cell *)ptr)->car, 16, port);
#line 636
    scm_gen_puts((enum scm_string_representation_type )0, (char *)" . 0x", port);
#line 637
    scm_intprint(((scm_cell *)ptr)->cdr, 16, port);
#line 638
    scm_gen_puts((enum scm_string_representation_type )0, (char *)") @", port);
    }
  }
  {
#line 640
  scm_gen_puts((enum scm_string_representation_type )0, (char *)" 0x", port);
#line 641
  scm_intprint(ptr, 16, port);
#line 642
  scm_gen_putc('>', port);
  }
#line 643
  return;
}
}
#line 649 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/print.c"
void scm_iprlist(char *hdr , SCM exp___0 , char tlr , SCM port , scm_print_state *pstate ) 
{ 
  register int i ;
  register SCM hare ;
  register SCM tortoise ;
  int floor___0 ;
  unsigned long tmp ;
  int n ;
  unsigned long tmp___0 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 659
  floor___0 = (int )(pstate->top - 2UL);
#line 660
  scm_gen_puts((enum scm_string_representation_type )0, hdr, port);
  }
#line 662
  if (pstate->fancyp) {
#line 663
    goto fancy_printing;
  }
#line 667
  hare = ((scm_cell *)exp___0)->cdr;
#line 668
  tortoise = exp___0;
  {
#line 669
  while (1) {
    while_continue: /* CIL Label */ ;
#line 669
    if (! (6 & (int )hare)) {
#line 669
      if (! (! (1 & (int )((scm_cell *)hare)->car))) {
#line 669
        if (! (1 == (7 & (int )((scm_cell *)hare)->car))) {
#line 669
          goto while_break;
        }
      }
    } else {
#line 669
      goto while_break;
    }
#line 671
    if (hare == tortoise) {
#line 672
      goto fancy_printing;
    }
#line 673
    hare = ((scm_cell *)hare)->cdr;
#line 674
    if (6 & (int )hare) {
#line 675
      goto while_break;
    } else
#line 674
    if (1 & (int )((scm_cell *)hare)->car) {
#line 674
      if (1 != (7 & (int )((scm_cell *)hare)->car)) {
#line 675
        goto while_break;
      }
    }
#line 676
    hare = ((scm_cell *)hare)->cdr;
#line 677
    tortoise = ((scm_cell *)tortoise)->cdr;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 681
  scm_iprin1(((scm_cell *)exp___0)->car, port, pstate);
#line 682
  exp___0 = ((scm_cell *)exp___0)->cdr;
  }
  {
#line 683
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 683
    if (! (! (6 & (int )exp___0))) {
#line 683
      goto while_break___0;
    }
#line 685
    if (1 & (int )((scm_cell *)exp___0)->car) {
#line 685
      if (1 != (7 & (int )((scm_cell *)exp___0)->car)) {
#line 686
        goto while_break___0;
      }
    }
#line 687
    i = floor___0;
    {
#line 687
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 687
      if (! (i >= 0)) {
#line 687
        goto while_break___1;
      }
#line 688
      if (*(pstate->ref_stack + i) == exp___0) {
#line 689
        goto circref;
      }
#line 687
      i --;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 690
    tmp = pstate->top;
#line 690
    (pstate->top) ++;
#line 690
    *(pstate->ref_stack + tmp) = exp___0;
#line 690
    if (pstate->top == pstate->ceiling) {
      {
#line 690
      grow_ref_stack(pstate);
      }
    }
    {
#line 691
    scm_gen_putc(' ', port);
#line 693
    scm_iprin1(((scm_cell *)exp___0)->car, port, pstate);
#line 683
    exp___0 = ((scm_cell *)exp___0)->cdr;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 695
  if ((long )(20 << 9) + 372L != exp___0) {
    {
#line 697
    scm_gen_puts((enum scm_string_representation_type )0, (char *)" . ", port);
#line 698
    scm_iprin1(exp___0, port, pstate);
    }
  }
  end: 
  {
#line 702
  scm_gen_putc((int )tlr, port);
#line 703
  pstate->top = (unsigned long )(floor___0 + 2);
  }
#line 704
  return;
  fancy_printing: 
  {
#line 708
  n = (int )pstate->length;
#line 710
  scm_iprin1(((scm_cell *)exp___0)->car, port, pstate);
#line 711
  exp___0 = ((scm_cell *)exp___0)->cdr;
#line 711
  n --;
  }
  {
#line 712
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 712
    if (! (! (6 & (int )exp___0))) {
#line 712
      goto while_break___2;
    }
#line 714
    if (1 & (int )((scm_cell *)exp___0)->car) {
#line 714
      if (1 != (7 & (int )((scm_cell *)exp___0)->car)) {
#line 715
        goto while_break___2;
      }
    }
#line 716
    i = 0;
    {
#line 716
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 716
      if (! ((unsigned long )i < pstate->top)) {
#line 716
        goto while_break___3;
      }
#line 717
      if (*(pstate->ref_stack + i) == exp___0) {
#line 718
        goto fancy_circref;
      }
#line 716
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 719
    if (pstate->fancyp) {
#line 721
      if (n == 0) {
        {
#line 723
        scm_gen_puts((enum scm_string_representation_type )0, (char *)" ...", port);
        }
#line 724
        goto skip_tail;
      } else {
#line 727
        n --;
      }
    }
#line 729
    tmp___0 = pstate->top;
#line 729
    (pstate->top) ++;
#line 729
    *(pstate->ref_stack + tmp___0) = exp___0;
#line 729
    if (pstate->top == pstate->ceiling) {
      {
#line 729
      grow_ref_stack(pstate);
      }
    }
    {
#line 730
    (pstate->list_offset) ++;
#line 731
    scm_gen_putc(' ', port);
#line 733
    scm_iprin1(((scm_cell *)exp___0)->car, port, pstate);
#line 712
    exp___0 = ((scm_cell *)exp___0)->cdr;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 736
  if ((long )(20 << 9) + 372L != exp___0) {
    {
#line 738
    scm_gen_puts((enum scm_string_representation_type )0, (char *)" . ", port);
#line 739
    scm_iprin1(exp___0, port, pstate);
    }
  }
  skip_tail: 
#line 742
  pstate->list_offset -= (pstate->top - (unsigned long )floor___0) - 2UL;
#line 743
  goto end;
  fancy_circref: 
#line 746
  pstate->list_offset -= (pstate->top - (unsigned long )floor___0) - 2UL;
  circref: 
  {
#line 749
  scm_gen_puts((enum scm_string_representation_type )0, (char *)" . ", port);
#line 750
  print_circref(port, pstate, exp___0);
  }
#line 751
  goto end;
}
}
#line 756 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/print.c"
static char s_write[6]  = {      (char )'w',      (char )'r',      (char )'i',      (char )'t', 
        (char )'e',      (char )'\000'};
#line 758 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/print.c"
SCM scm_write(SCM obj , SCM port ) 
{ 


  {
#line 763
  if ((long )(18 << 9) + 372L == port) {
#line 764
    port = scm_root->cur_outp;
  } else
#line 766
  if (! (6 & (int )port)) {
#line 766
    if (! ((((127L | (1L << 16)) | (4L << 16)) & ((scm_cell *)port)->car) == ((125L | (1L << 16)) | (4L << 16)))) {
      {
#line 766
      scm_wta(port, (char *)2, s_write);
      }
    }
  } else {
    {
#line 766
    scm_wta(port, (char *)2, s_write);
    }
  }
  {
#line 767
  scm_prin1(obj, port, 1);
  }
#line 774
  return ((long )(21 << 9) + 372L);
}
}
#line 778 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/print.c"
static char s_display[8]  = 
#line 778
  {      (char )'d',      (char )'i',      (char )'s',      (char )'p', 
        (char )'l',      (char )'a',      (char )'y',      (char )'\000'};
#line 780 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/print.c"
SCM scm_display(SCM obj , SCM port ) 
{ 


  {
#line 785
  if ((long )(18 << 9) + 372L == port) {
#line 786
    port = scm_root->cur_outp;
  } else
#line 788
  if (! (6 & (int )port)) {
#line 788
    if (! ((((127L | (1L << 16)) | (4L << 16)) & ((scm_cell *)port)->car) == ((125L | (1L << 16)) | (4L << 16)))) {
      {
#line 788
      scm_wta(port, (char *)2, s_display);
      }
    }
  } else {
    {
#line 788
    scm_wta(port, (char *)2, s_display);
    }
  }
  {
#line 789
  scm_prin1(obj, port, 0);
  }
#line 796
  return ((long )(21 << 9) + 372L);
}
}
#line 799 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/print.c"
static char s_newline[8]  = 
#line 799
  {      (char )'n',      (char )'e',      (char )'w',      (char )'l', 
        (char )'i',      (char )'n',      (char )'e',      (char )'\000'};
#line 801 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/print.c"
SCM scm_newline(SCM port ) 
{ 


  {
#line 805
  if ((long )(18 << 9) + 372L == port) {
#line 806
    port = scm_root->cur_outp;
  } else
#line 808
  if (! (6 & (int )port)) {
#line 808
    if (! ((((127L | (1L << 16)) | (4L << 16)) & ((scm_cell *)port)->car) == ((125L | (1L << 16)) | (4L << 16)))) {
      {
#line 808
      scm_wta(port, (char *)1, s_newline);
      }
    }
  } else {
    {
#line 808
    scm_wta(port, (char *)1, s_newline);
    }
  }
  {
#line 809
  scm_gen_putc('\n', port);
  }
#line 817
  if (port == scm_root->cur_outp) {
    {
#line 818
    scm_fflush(port);
    }
  }
#line 819
  return ((long )(21 << 9) + 372L);
}
}
#line 822 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/print.c"
static char s_write_char[11]  = 
#line 822
  {      (char )'w',      (char )'r',      (char )'i',      (char )'t', 
        (char )'e',      (char )'-',      (char )'c',      (char )'h', 
        (char )'a',      (char )'r',      (char )'\000'};
#line 824 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/print.c"
SCM scm_write_char(SCM chr , SCM port ) 
{ 


  {
#line 829
  if ((long )(18 << 9) + 372L == port) {
#line 830
    port = scm_root->cur_outp;
  } else
#line 832
  if (! (6 & (int )port)) {
#line 832
    if (! ((((127L | (1L << 16)) | (4L << 16)) & ((scm_cell *)port)->car) == ((125L | (1L << 16)) | (4L << 16)))) {
      {
#line 832
      scm_wta(port, (char *)2, s_write_char);
      }
    }
  } else {
    {
#line 832
    scm_wta(port, (char *)2, s_write_char);
    }
  }
#line 833
  if (! (((int )chr & 255) == 244)) {
    {
#line 833
    scm_wta(chr, (char *)1, s_write_char);
    }
  }
  {
#line 834
  scm_gen_putc((int )((unsigned int )(chr >> 8)), port);
  }
#line 841
  return ((long )(21 << 9) + 372L);
}
}
#line 848 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/print.c"
void scm_init_print(void) 
{ 
  SCM vtable ;
  SCM type ;
  SCM tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  SCM tmp___2 ;
  SCM tmp___3 ;
  char *__cil_tmp8 ;

  {
  {
#line 852
  scm_init_opts(& scm_print_options, scm_print_opts, 2);
#line 853
  tmp = scm_make_struct_layout(scm_sys_protects[4]);
#line 853
  vtable = scm_make_vtable_vtable(tmp, (SCM )2, (long )(20 << 9) + 372L);
#line 854
  tmp___0 = scm_makfrom0str("sruwuwuwuwpwuwuwuruopr");
#line 854
  tmp___1 = scm_make_struct_layout(tmp___0);
#line 854
  tmp___2 = scm_cons(tmp___1, (long )(20 << 9) + 372L);
#line 854
  type = scm_make_struct(vtable, (SCM )2, tmp___2);
#line 858
  tmp___3 = scm_cons(type, (long )(20 << 9) + 372L);
#line 858
  print_state_pool = scm_permanent_object(tmp___3);
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/print.x"
  scm_make_gsubr(s_print_options, 0, 1, 0, (SCM (*)())(& scm_print_options));
#line 2
  scm_make_gsubr(s_current_pstate, 0, 0, 0, & scm_current_pstate);
#line 3
  scm_make_gsubr(s_write, 1, 1, 0, (SCM (*)())(& scm_write));
#line 4
  scm_make_gsubr(s_display, 1, 1, 0, (SCM (*)())(& scm_display));
#line 5
  scm_make_gsubr(s_newline, 0, 1, 0, (SCM (*)())(& scm_newline));
#line 6
  scm_make_gsubr(s_write_char, 1, 1, 0, (SCM (*)())(& scm_write_char));
  }
#line 860 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/print.c"
  return;
}
}
#line 186 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) char *tmpnam(char *__s ) ;
#line 214
extern int fclose(FILE *__stream ) ;
#line 846
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 858
extern  __attribute__((__nothrow__)) char *ctermid(char *__s ) ;
#line 578 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) putenv)(char *__string ) ;
#line 317 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.h"
long scm_num2long(SCM num , char *pos , char *s_caller ) ;
#line 233 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 54 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.h"
SCM scm_tcsetpgrp(SCM port , SCM pgid ) ;
#line 55
SCM scm_tcgetpgrp(SCM port ) ;
#line 56
SCM scm_ctermid(void) ;
#line 57
SCM scm_setsid(void) ;
#line 58
SCM scm_setpgid(SCM pid , SCM pgid ) ;
#line 59
SCM scm_pipe(void) ;
#line 60
SCM scm_getgroups(void) ;
#line 61
SCM scm_getpgrp(void) ;
#line 62
SCM scm_getpwuid(SCM user ) ;
#line 63
SCM scm_setpwent(SCM arg ) ;
#line 64
SCM scm_getgrgid(SCM name ) ;
#line 65
SCM scm_setgrent(SCM arg ) ;
#line 66
SCM scm_kill(SCM pid , SCM sig ) ;
#line 67
SCM scm_waitpid(SCM pid , SCM options ) ;
#line 68
SCM scm_getppid(void) ;
#line 69
SCM scm_getuid(void) ;
#line 70
SCM scm_getgid(void) ;
#line 71
SCM scm_geteuid(void) ;
#line 72
SCM scm_getegid(void) ;
#line 73
SCM scm_setuid(SCM id ) ;
#line 74
SCM scm_setgid(SCM id ) ;
#line 75
SCM scm_seteuid(SCM id ) ;
#line 76
SCM scm_setegid(SCM id ) ;
#line 77
SCM scm_ttyname(SCM port ) ;
#line 78
SCM scm_execl(SCM args ) ;
#line 79
SCM scm_execlp(SCM args ) ;
#line 80
SCM scm_fork(void) ;
#line 81
SCM scm_uname(void) ;
#line 82
SCM scm_environ(SCM env ) ;
#line 83
SCM scm_open_pipe(SCM pipestr , SCM modes ) ;
#line 84
SCM scm_open_input_pipe(SCM pipestr ) ;
#line 85
SCM scm_open_output_pipe(SCM pipestr ) ;
#line 86
SCM scm_utime(SCM pathname , SCM actime , SCM modtime ) ;
#line 87
SCM scm_access(SCM path , SCM how ) ;
#line 88
SCM scm_getpid(void) ;
#line 89
SCM scm_putenv(SCM str ) ;
#line 90
SCM scm_read_line(SCM port , SCM include_terminator ) ;
#line 91
SCM scm_read_line_x(SCM str , SCM port ) ;
#line 92
SCM scm_write_line(SCM obj , SCM port ) ;
#line 93
SCM scm_setlocale(SCM category , SCM locale ) ;
#line 94
SCM scm_strftime(SCM format , SCM stime___0 ) ;
#line 95
SCM scm_strptime(SCM format , SCM string ) ;
#line 96
SCM scm_mknod(SCM path , SCM mode , SCM dev ) ;
#line 97
SCM scm_nice(SCM incr ) ;
#line 98
SCM scm_sync(void) ;
#line 99
void scm_init_posix(void) ;
#line 193 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t mktime(struct tm *__tp ) ;
#line 199
extern  __attribute__((__nothrow__)) size_t strftime(char * __restrict  __s , size_t __maxsize ,
                                                     char const   * __restrict  __format ,
                                                     struct tm  const  * __restrict  __tp ) ;
#line 288 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) access)(char const   *__name ,
                                                                                   int __type ) ;
#line 414
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
#line 558
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) execv)(char const   *__path ,
                                                                                  char * const  *__argv ) ;
#line 573
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) execvp)(char const   *__file ,
                                                                                   char * const  *__argv ) ;
#line 593
extern  __attribute__((__nothrow__)) int nice(int __inc ) ;
#line 626
extern  __attribute__((__nothrow__)) __pid_t getppid(void) ;
#line 631
extern  __attribute__((__nothrow__)) __pid_t getpgrp(void) ;
#line 650
extern  __attribute__((__nothrow__)) int setpgid(__pid_t __pid , __pid_t __pgid ) ;
#line 684
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 692
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 695
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 698
extern  __attribute__((__nothrow__)) __gid_t getgid(void) ;
#line 701
extern  __attribute__((__nothrow__)) __gid_t getegid(void) ;
#line 706
extern  __attribute__((__nothrow__)) int getgroups(int __size , __gid_t *__list ) ;
#line 717
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
#line 727
extern  __attribute__((__nothrow__)) int seteuid(__uid_t __uid ) ;
#line 734
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 744
extern  __attribute__((__nothrow__)) int setegid(__gid_t __gid ) ;
#line 773
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 786
extern  __attribute__((__nothrow__)) char *ttyname(int __fd ) ;
#line 855
extern  __attribute__((__nothrow__)) __pid_t tcgetpgrp(int __fd ) ;
#line 858
extern  __attribute__((__nothrow__)) int tcsetpgrp(int __fd , __pid_t __pgrp_id ) ;
#line 983
extern  __attribute__((__nothrow__)) void sync(void) ;
#line 336 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) mknod)(char const   *__path ,
                                                                                  __mode_t __mode ,
                                                                                  __dev_t __dev ) ;
#line 73 "/usr/include/pwd.h"
extern void setpwent(void) ;
#line 79
extern void endpwent(void) ;
#line 85
extern struct passwd *getpwent(void) ;
#line 111
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 117
extern struct passwd *getpwnam(char const   *__name ) ;
#line 139 "/usr/include/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 122 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
extern char **environ ;
#line 63 "/usr/include/grp.h"
extern void setgrent(void) ;
#line 69
extern void endgrent(void) ;
#line 75
extern struct group *getgrent(void) ;
#line 103
extern struct group *getgrgid(__gid_t __gid ) ;
#line 109
extern struct group *getgrnam(char const   *__name ) ;
#line 82 "/usr/include/sys/utsname.h"
extern  __attribute__((__nothrow__)) int uname(struct utsname *__name ) ;
#line 144 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
extern char *strptime() ;
#line 125 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *setlocale(int __category , char const   *__locale ) ;
#line 46 "/usr/include/utime.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) utime)(char const   *__file ,
                                                                                  struct utimbuf  const  *__file_times ) ;
#line 190 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_pipe[5]  = {      (char )'p',      (char )'i',      (char )'p',      (char )'e', 
        (char )'\000'};
#line 192 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_pipe(void) 
{ 
  int fd[2] ;
  int rv ;
  FILE *f_rd ;
  FILE *f_wt ;
  SCM p_rd ;
  SCM p_wt ;
  struct scm_port_table *ptr ;
  struct scm_port_table *ptw ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int en ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  SCM tmp___9 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 201
  if (6 & (int )scm_freelist) {
    {
#line 201
    p_rd = scm_gc_for_newcell();
    }
  } else {
#line 201
    p_rd = scm_freelist;
#line 201
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 201
    scm_cells_allocated ++;
  }
#line 202
  if (6 & (int )scm_freelist) {
    {
#line 202
    p_wt = scm_gc_for_newcell();
    }
  } else {
#line 202
    p_wt = scm_freelist;
#line 202
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 202
    scm_cells_allocated ++;
  }
  {
#line 203
  rv = pipe((int *)(fd));
  }
#line 204
  if (rv) {
    {
#line 205
    scm_syserror(s_pipe);
    }
  }
  {
#line 206
  f_rd = fdopen(fd[0], "r");
  }
#line 207
  if (! f_rd) {
    {
#line 209
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 209
      tmp = __errno_location();
#line 209
      *tmp = 0;
#line 209
      close(fd[0]);
#line 209
      tmp___0 = __errno_location();
      }
#line 209
      if (! (4 == *tmp___0)) {
#line 209
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 210
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 210
      tmp___1 = __errno_location();
#line 210
      *tmp___1 = 0;
#line 210
      close(fd[1]);
#line 210
      tmp___2 = __errno_location();
      }
#line 210
      if (! (4 == *tmp___2)) {
#line 210
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 211
    scm_syserror(s_pipe);
    }
  }
  {
#line 213
  f_wt = fdopen(fd[1], "w");
  }
#line 214
  if (! f_wt) {
    {
#line 217
    tmp___3 = __errno_location();
#line 217
    en = *tmp___3;
#line 218
    fclose(f_rd);
    }
    {
#line 219
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 219
      tmp___4 = __errno_location();
#line 219
      *tmp___4 = 0;
#line 219
      close(fd[1]);
#line 219
      tmp___5 = __errno_location();
      }
#line 219
      if (! (4 == *tmp___5)) {
#line 219
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 220
    tmp___6 = __errno_location();
#line 220
    *tmp___6 = en;
#line 221
    scm_syserror(s_pipe);
    }
  }
  {
#line 223
  ptr = scm_add_to_port_table(p_rd);
#line 224
  ptw = scm_add_to_port_table(p_wt);
#line 225
  ((scm_cell *)p_rd)->cdr = (SCM )ptr;
#line 226
  ((scm_cell *)p_wt)->cdr = (SCM )ptw;
#line 227
  tmp___7 = scm_mode_bits((char *)"r");
#line 227
  ((scm_cell *)p_rd)->car = 125L | tmp___7;
#line 228
  tmp___8 = scm_mode_bits((char *)"w");
#line 228
  ((scm_cell *)p_wt)->car = 125L | tmp___8;
#line 229
  ((struct scm_port_table *)((scm_cell *)p_rd)->cdr)->stream = (SCM )f_rd;
#line 230
  ((struct scm_port_table *)((scm_cell *)p_wt)->cdr)->stream = (SCM )f_wt;
#line 232
  scm_ints_disabled = 0;
#line 232
  scm_async_clock --;
  }
#line 232
  if (0U == scm_async_clock) {
    {
#line 232
    scm_async_click();
    }
  }
  {
#line 233
  tmp___9 = scm_cons(p_rd, p_wt);
  }
#line 233
  return (tmp___9);
}
}
#line 238 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_getgroups[10]  = 
#line 238
  {      (char )'g',      (char )'e',      (char )'t',      (char )'g', 
        (char )'r',      (char )'o',      (char )'u',      (char )'p', 
        (char )'s',      (char )'\000'};
#line 240 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_getgroups(void) 
{ 
  SCM grps ;
  SCM ans ;
  int ngroups ;
  int tmp ;
  gid_t *groups ;
  int val ;
  char *tmp___0 ;

  {
  {
#line 244
  tmp = getgroups(0, (__gid_t *)((void *)0));
#line 244
  ngroups = tmp;
  }
#line 245
  if (! ngroups) {
    {
#line 246
    scm_syserror(s_getgroups);
    }
  }
#line 247
  if (6 & (int )scm_freelist) {
    {
#line 247
    grps = scm_gc_for_newcell();
    }
  } else {
#line 247
    grps = scm_freelist;
#line 247
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 247
    scm_cells_allocated ++;
  }
  {
#line 248
  scm_ints_disabled = 1;
#line 253
  tmp___0 = scm_must_malloc((long )((unsigned long )ngroups * sizeof(gid_t )), s_getgroups);
#line 253
  groups = (gid_t *)tmp___0;
#line 255
  val = getgroups(ngroups, groups);
  }
#line 256
  if (val < 0) {
    {
#line 258
    scm_must_free((char *)groups);
#line 259
    scm_syserror(s_getgroups);
    }
  }
#line 261
  ((scm_cell *)grps)->cdr = (SCM )groups;
#line 262
  ((scm_cell *)grps)->car = (SCM )(((unsigned long )ngroups * sizeof(gid_t ) << 8) + 21UL);
#line 263
  scm_ints_disabled = 0;
#line 263
  scm_async_clock --;
#line 263
  if (0U == scm_async_clock) {
    {
#line 263
    scm_async_click();
    }
  }
  {
#line 264
  ans = scm_make_vector((long )(ngroups << 2) + 2L, (long )(18 << 9) + 372L, (long )(16 << 9) + 372L);
  }
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 265
    ngroups --;
#line 265
    if (! (ngroups >= 0)) {
#line 265
      goto while_break;
    }
#line 265
    *((SCM *)((scm_cell *)ans)->cdr + ngroups) = (long )(*(groups + ngroups) << 2) + 2L;
  }
  while_break: /* CIL Label */ ;
  }
#line 266
  ((scm_cell *)grps)->cdr = (SCM )groups;
#line 267
  return (ans);
}
}
#line 273 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_getpwuid[6]  = {      (char )'g',      (char )'e',      (char )'t',      (char )'p', 
        (char )'w',      (char )'\000'};
#line 275 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_getpwuid(SCM user ) 
{ 
  SCM result ;
  struct passwd *entry ;
  SCM *ve ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 283
  result = scm_make_vector((long )(7 << 2) + 2L, (long )(21 << 9) + 372L, (long )(16 << 9) + 372L);
#line 284
  ve = (SCM *)((scm_cell *)result)->cdr;
  }
#line 285
  if ((long )(18 << 9) + 372L == user) {
#line 285
    goto _L;
  } else
#line 285
  if ((long )(16 << 9) + 372L == user) {
    _L: /* CIL Label */ 
#line 287
    scm_ints_disabled = 1;
    {
#line 288
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 288
      tmp = __errno_location();
#line 288
      *tmp = 0;
#line 288
      entry = getpwent();
#line 288
      tmp___0 = __errno_location();
      }
#line 288
      if (! (4 == *tmp___0)) {
#line 288
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 290
  if (2 & (int )user) {
    {
#line 292
    scm_ints_disabled = 1;
#line 293
    entry = getpwuid((__uid_t )(user >> 2));
    }
  } else {
#line 297
    if (! (6 & (int )user)) {
#line 297
      if (! ((117 & (int )((scm_cell *)user)->car) == 21)) {
#line 297
        if (! ((125 & (int )((scm_cell *)user)->car) == 5)) {
          {
#line 297
          scm_wta(user, (char *)1, s_getpwuid);
          }
        }
      }
    } else {
      {
#line 297
      scm_wta(user, (char *)1, s_getpwuid);
      }
    }
#line 298
    if ((125 & (int )((scm_cell *)user)->car) == 29) {
#line 299
      if ((127 & (int )((scm_cell *)user)->car) == 29) {
#line 299
        tmp___1 = (char *)((scm_cell *)((scm_cell *)((scm_cell *)user)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)user)->cdr)->car >> 2);
      } else {
#line 299
        tmp___1 = (char *)((scm_cell *)user)->cdr;
      }
      {
#line 299
      user = scm_makfromstr((char const   *)tmp___1, (unsigned long )((scm_cell *)user)->car >> 8,
                            0);
      }
    }
#line 300
    scm_ints_disabled = 1;
#line 301
    if ((127 & (int )((scm_cell *)user)->car) == 29) {
#line 301
      tmp___2 = (char *)((scm_cell *)((scm_cell *)((scm_cell *)user)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)user)->cdr)->car >> 2);
    } else {
#line 301
      tmp___2 = (char *)((scm_cell *)user)->cdr;
    }
    {
#line 301
    entry = getpwnam((char const   *)tmp___2);
    }
  }
#line 303
  if (! entry) {
    {
#line 304
    scm_syserror(s_getpwuid);
    }
  }
  {
#line 306
  *(ve + 0) = scm_makfrom0str((char const   *)entry->pw_name);
#line 307
  *(ve + 1) = scm_makfrom0str((char const   *)entry->pw_passwd);
#line 308
  *(ve + 2) = scm_ulong2num((unsigned long )entry->pw_uid);
#line 309
  *(ve + 3) = scm_ulong2num((unsigned long )entry->pw_gid);
#line 310
  *(ve + 4) = scm_makfrom0str((char const   *)entry->pw_gecos);
  }
#line 311
  if (! entry->pw_dir) {
    {
#line 312
    *(ve + 5) = scm_makfrom0str("");
    }
  } else {
    {
#line 314
    *(ve + 5) = scm_makfrom0str((char const   *)entry->pw_dir);
    }
  }
#line 315
  if (! entry->pw_shell) {
    {
#line 316
    *(ve + 6) = scm_makfrom0str("");
    }
  } else {
    {
#line 318
    *(ve + 6) = scm_makfrom0str((char const   *)entry->pw_shell);
    }
  }
#line 319
  scm_ints_disabled = 0;
#line 319
  scm_async_clock --;
#line 319
  if (0U == scm_async_clock) {
    {
#line 319
    scm_async_click();
    }
  }
#line 320
  return (result);
}
}
#line 325 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_setpwent[6]  = {      (char )'s',      (char )'e',      (char )'t',      (char )'p', 
        (char )'w',      (char )'\000'};
#line 327 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_setpwent(SCM arg ) 
{ 


  {
#line 331
  if ((long )(18 << 9) + 372L == arg) {
    {
#line 332
    endpwent();
    }
  } else
#line 331
  if ((long )(16 << 9) + 372L == arg) {
    {
#line 332
    endpwent();
    }
  } else {
    {
#line 334
    setpwent();
    }
  }
#line 335
  return ((long )(21 << 9) + 372L);
}
}
#line 341 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_getgrgid[6]  = {      (char )'g',      (char )'e',      (char )'t',      (char )'g', 
        (char )'r',      (char )'\000'};
#line 343 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_getgrgid(SCM name ) 
{ 
  SCM result ;
  struct group *entry ;
  SCM *ve ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;

  {
  {
#line 350
  result = scm_make_vector((long )(4 << 2) + 2L, (long )(21 << 9) + 372L, (long )(16 << 9) + 372L);
#line 351
  ve = (SCM *)((scm_cell *)result)->cdr;
#line 352
  scm_ints_disabled = 1;
  }
#line 353
  if ((long )(18 << 9) + 372L == name) {
#line 353
    goto _L;
  } else
#line 353
  if (name == (long )(16 << 9) + 372L) {
    _L: /* CIL Label */ 
    {
#line 354
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 354
      tmp = __errno_location();
#line 354
      *tmp = 0;
#line 354
      entry = getgrent();
#line 354
      tmp___0 = __errno_location();
      }
#line 354
      if (! (4 == *tmp___0)) {
#line 354
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 355
  if (2 & (int )name) {
    {
#line 356
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 356
      tmp___1 = __errno_location();
#line 356
      *tmp___1 = 0;
#line 356
      entry = getgrgid((__gid_t )(name >> 2));
#line 356
      tmp___2 = __errno_location();
      }
#line 356
      if (! (4 == *tmp___2)) {
#line 356
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 359
    if (! (6 & (int )name)) {
#line 359
      if (! ((125 & (int )((scm_cell *)name)->car) == 21)) {
        {
#line 359
        scm_wta(name, (char *)1, s_getgrgid);
        }
      }
    } else {
      {
#line 359
      scm_wta(name, (char *)1, s_getgrgid);
      }
    }
#line 360
    if ((125 & (int )((scm_cell *)name)->car) == 29) {
#line 361
      if ((127 & (int )((scm_cell *)name)->car) == 29) {
#line 361
        tmp___3 = (char *)((scm_cell *)((scm_cell *)((scm_cell *)name)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)name)->cdr)->car >> 2);
      } else {
#line 361
        tmp___3 = (char *)((scm_cell *)name)->cdr;
      }
      {
#line 361
      name = scm_makfromstr((char const   *)tmp___3, (unsigned long )((scm_cell *)name)->car >> 8,
                            0);
      }
    }
    {
#line 362
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 362
      tmp___4 = __errno_location();
#line 362
      *tmp___4 = 0;
#line 362
      entry = getgrnam((char const   *)((char *)((scm_cell *)name)->cdr));
#line 362
      tmp___5 = __errno_location();
      }
#line 362
      if (! (4 == *tmp___5)) {
#line 362
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 364
  if (! entry) {
    {
#line 365
    scm_syserror(s_getgrgid);
    }
  }
  {
#line 367
  *(ve + 0) = scm_makfrom0str((char const   *)entry->gr_name);
#line 368
  *(ve + 1) = scm_makfrom0str((char const   *)entry->gr_passwd);
#line 369
  *(ve + 2) = scm_ulong2num((unsigned long )entry->gr_gid);
#line 370
  *(ve + 3) = scm_makfromstrs(-1, entry->gr_mem);
#line 371
  scm_ints_disabled = 0;
#line 371
  scm_async_clock --;
  }
#line 371
  if (0U == scm_async_clock) {
    {
#line 371
    scm_async_click();
    }
  }
#line 372
  return (result);
}
}
#line 377 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_setgrent[6]  = {      (char )'s',      (char )'e',      (char )'t',      (char )'g', 
        (char )'r',      (char )'\000'};
#line 379 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_setgrent(SCM arg ) 
{ 


  {
#line 383
  if ((long )(18 << 9) + 372L == arg) {
    {
#line 384
    endgrent();
    }
  } else
#line 383
  if ((long )(16 << 9) + 372L == arg) {
    {
#line 384
    endgrent();
    }
  } else {
    {
#line 386
    setgrent();
    }
  }
#line 387
  return ((long )(21 << 9) + 372L);
}
}
#line 392 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_kill[5]  = {      (char )'k',      (char )'i',      (char )'l',      (char )'l', 
        (char )'\000'};
#line 394 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_kill(SCM pid , SCM sig ) 
{ 
  int tmp ;

  {
#line 399
  if (! (2 & (int )pid)) {
    {
#line 399
    scm_wta(pid, (char *)1, s_kill);
    }
  }
#line 400
  if (! (2 & (int )sig)) {
    {
#line 400
    scm_wta(sig, (char *)2, s_kill);
    }
  }
  {
#line 402
  tmp = kill((int )(pid >> 2), (int )(sig >> 2));
  }
#line 402
  if (tmp != 0) {
    {
#line 403
    scm_syserror(s_kill);
    }
  }
#line 404
  return ((long )(21 << 9) + 372L);
}
}
#line 409 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_waitpid[8]  = 
#line 409
  {      (char )'w',      (char )'a',      (char )'i',      (char )'t', 
        (char )'p',      (char )'i',      (char )'d',      (char )'\000'};
#line 411 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_waitpid(SCM pid , SCM options ) 
{ 
  int i ;
  int status ;
  int ioptions ;
  int *tmp ;
  int *tmp___0 ;
  SCM tmp___1 ;

  {
#line 420
  if (! (2 & (int )pid)) {
    {
#line 420
    scm_wta(pid, (char *)1, s_waitpid);
    }
  }
#line 421
  if ((long )(18 << 9) + 372L == options) {
#line 422
    ioptions = 0;
  } else {
#line 425
    if (! (2 & (int )options)) {
      {
#line 425
      scm_wta(options, (char *)2, s_waitpid);
      }
    }
#line 427
    ioptions = (int )(options >> 2);
  }
  {
#line 429
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 429
    tmp = __errno_location();
#line 429
    *tmp = 0;
#line 429
    i = waitpid((__pid_t )(pid >> 2), & status, ioptions);
#line 429
    tmp___0 = __errno_location();
    }
#line 429
    if (! (4 == *tmp___0)) {
#line 429
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 430
  if (i == -1) {
    {
#line 431
    scm_syserror(s_waitpid);
    }
  }
  {
#line 432
  tmp___1 = scm_cons(((long )i << 2) + 2L, ((long )status << 2) + 2L);
  }
#line 432
  return (tmp___1);
}
}
#line 442 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_getppid[8]  = 
#line 442
  {      (char )'g',      (char )'e',      (char )'t',      (char )'p', 
        (char )'p',      (char )'i',      (char )'d',      (char )'\000'};
#line 444 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_getppid(void) 
{ 
  __pid_t tmp ;

  {
  {
#line 447
  tmp = getppid();
  }
#line 447
  return (((long )tmp << 2) + 2L);
}
}
#line 452 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_getuid[7]  = {      (char )'g',      (char )'e',      (char )'t',      (char )'u', 
        (char )'i',      (char )'d',      (char )'\000'};
#line 454 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_getuid(void) 
{ 
  __uid_t tmp ;

  {
  {
#line 457
  tmp = getuid();
  }
#line 457
  return (((long )tmp << 2) + 2L);
}
}
#line 462 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_getgid[7]  = {      (char )'g',      (char )'e',      (char )'t',      (char )'g', 
        (char )'i',      (char )'d',      (char )'\000'};
#line 464 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_getgid(void) 
{ 
  __gid_t tmp ;

  {
  {
#line 467
  tmp = getgid();
  }
#line 467
  return (((long )tmp << 2) + 2L);
}
}
#line 472 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_geteuid[8]  = 
#line 472
  {      (char )'g',      (char )'e',      (char )'t',      (char )'e', 
        (char )'u',      (char )'i',      (char )'d',      (char )'\000'};
#line 474 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_geteuid(void) 
{ 
  __uid_t tmp ;

  {
  {
#line 478
  tmp = geteuid();
  }
#line 478
  return (((long )tmp << 2) + 2L);
}
}
#line 486 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_getegid[8]  = 
#line 486
  {      (char )'g',      (char )'e',      (char )'t',      (char )'e', 
        (char )'g',      (char )'i',      (char )'d',      (char )'\000'};
#line 488 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_getegid(void) 
{ 
  __gid_t tmp ;

  {
  {
#line 492
  tmp = getegid();
  }
#line 492
  return (((long )tmp << 2) + 2L);
}
}
#line 499 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_setuid[7]  = {      (char )'s',      (char )'e',      (char )'t',      (char )'u', 
        (char )'i',      (char )'d',      (char )'\000'};
#line 501 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_setuid(SCM id ) 
{ 
  int tmp ;

  {
#line 505
  if (! (2 & (int )id)) {
    {
#line 505
    scm_wta(id, (char *)1, s_setuid);
    }
  }
  {
#line 506
  tmp = setuid((__uid_t )(id >> 2));
  }
#line 506
  if (tmp != 0) {
    {
#line 507
    scm_syserror(s_setuid);
    }
  }
#line 508
  return ((long )(21 << 9) + 372L);
}
}
#line 511 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_setgid[7]  = {      (char )'s',      (char )'e',      (char )'t',      (char )'g', 
        (char )'i',      (char )'d',      (char )'\000'};
#line 513 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_setgid(SCM id ) 
{ 
  int tmp ;

  {
#line 517
  if (! (2 & (int )id)) {
    {
#line 517
    scm_wta(id, (char *)1, s_setgid);
    }
  }
  {
#line 518
  tmp = setgid((__gid_t )(id >> 2));
  }
#line 518
  if (tmp != 0) {
    {
#line 519
    scm_syserror(s_setgid);
    }
  }
#line 520
  return ((long )(21 << 9) + 372L);
}
}
#line 523 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_seteuid[8]  = 
#line 523
  {      (char )'s',      (char )'e',      (char )'t',      (char )'e', 
        (char )'u',      (char )'i',      (char )'d',      (char )'\000'};
#line 525 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_seteuid(SCM id ) 
{ 
  int rv ;

  {
#line 531
  if (! (2 & (int )id)) {
    {
#line 531
    scm_wta(id, (char *)1, s_seteuid);
    }
  }
  {
#line 533
  rv = seteuid((__uid_t )(id >> 2));
  }
#line 537
  if (rv != 0) {
    {
#line 538
    scm_syserror(s_seteuid);
    }
  }
#line 539
  return ((long )(21 << 9) + 372L);
}
}
#line 542 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_setegid[8]  = 
#line 542
  {      (char )'s',      (char )'e',      (char )'t',      (char )'e', 
        (char )'g',      (char )'i',      (char )'d',      (char )'\000'};
#line 544 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_setegid(SCM id ) 
{ 
  int rv ;

  {
#line 550
  if (! (2 & (int )id)) {
    {
#line 550
    scm_wta(id, (char *)1, s_setegid);
    }
  }
  {
#line 552
  rv = setegid((__gid_t )(id >> 2));
  }
#line 556
  if (rv != 0) {
    {
#line 557
    scm_syserror(s_setegid);
    }
  }
#line 558
  return ((long )(21 << 9) + 372L);
}
}
#line 562 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_getpgrp[8]  = 
#line 562
  {      (char )'g',      (char )'e',      (char )'t',      (char )'p', 
        (char )'g',      (char )'r',      (char )'p',      (char )'\000'};
#line 563 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_getpgrp(void) 
{ 
  int (*fn)() ;
  int tmp ;

  {
  {
#line 567
  fn = & getpgrp;
#line 568
  tmp = (*fn)(0);
  }
#line 568
  return ((long )(tmp << 2) + 2L);
}
}
#line 571 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_setpgid[8]  = 
#line 571
  {      (char )'s',      (char )'e',      (char )'t',      (char )'p', 
        (char )'g',      (char )'i',      (char )'d',      (char )'\000'};
#line 572 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_setpgid(SCM pid , SCM pgid ) 
{ 
  int tmp ;

  {
#line 577
  if (! (2 & (int )pid)) {
    {
#line 577
    scm_wta(pid, (char *)1, s_setpgid);
    }
  }
#line 578
  if (! (2 & (int )pgid)) {
    {
#line 578
    scm_wta(pgid, (char *)2, s_setpgid);
    }
  }
  {
#line 580
  tmp = setpgid((__pid_t )(pid >> 2), (__pid_t )(pgid >> 2));
  }
#line 580
  if (tmp != 0) {
    {
#line 581
    scm_syserror(s_setpgid);
    }
  }
#line 582
  return ((long )(21 << 9) + 372L);
}
}
#line 590 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_setsid[7]  = {      (char )'s',      (char )'e',      (char )'t',      (char )'s', 
        (char )'i',      (char )'d',      (char )'\000'};
#line 591 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_setsid(void) 
{ 
  pid_t sid ;
  __pid_t tmp ;

  {
  {
#line 595
  tmp = setsid();
#line 595
  sid = tmp;
  }
#line 596
  if (sid == -1) {
    {
#line 597
    scm_syserror(s_setsid);
    }
  }
#line 598
  return ((long )(21 << 9) + 372L);
}
}
#line 606 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_ttyname[8]  = 
#line 606
  {      (char )'t',      (char )'t',      (char )'y',      (char )'n', 
        (char )'a',      (char )'m',      (char )'e',      (char )'\000'};
#line 608 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_ttyname(SCM port ) 
{ 
  char *ans ;
  int fd ;
  int *tmp ;
  int *tmp___0 ;
  SCM tmp___1 ;

  {
#line 614
  if (! (6 & (int )port)) {
#line 614
    if (! (((127L | (1L << 16)) & ((scm_cell *)port)->car) == (125L | (1L << 16)))) {
      {
#line 614
      scm_wta(port, (char *)1, s_ttyname);
      }
    }
  } else {
    {
#line 614
    scm_wta(port, (char *)1, s_ttyname);
    }
  }
#line 615
  if (125L != (long )(65535 & (int )((scm_cell *)port)->car)) {
#line 616
    return ((long )(16 << 9) + 372L);
  }
  {
#line 617
  fd = fileno((FILE *)((struct scm_port_table *)((scm_cell *)port)->cdr)->stream);
  }
#line 618
  if (fd == -1) {
    {
#line 619
    scm_syserror(s_ttyname);
    }
  }
  {
#line 620
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 620
    tmp = __errno_location();
#line 620
    *tmp = 0;
#line 620
    ans = ttyname(fd);
#line 620
    tmp___0 = __errno_location();
    }
#line 620
    if (! (4 == *tmp___0)) {
#line 620
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 621
  if (! ans) {
    {
#line 622
    scm_syserror(s_ttyname);
    }
  }
  {
#line 624
  tmp___1 = scm_makfrom0str((char const   *)ans);
  }
#line 624
  return (tmp___1);
}
}
#line 628 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_ctermid[8]  = 
#line 628
  {      (char )'c',      (char )'t',      (char )'e',      (char )'r', 
        (char )'m',      (char )'i',      (char )'d',      (char )'\000'};
#line 629 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_ctermid(void) 
{ 
  char *result ;
  char *tmp ;
  SCM tmp___0 ;

  {
  {
#line 633
  tmp = ctermid((char *)((void *)0));
#line 633
  result = tmp;
  }
#line 634
  if ((int )*result == 0) {
    {
#line 635
    scm_syserror(s_ctermid);
    }
  }
  {
#line 636
  tmp___0 = scm_makfrom0str((char const   *)result);
  }
#line 636
  return (tmp___0);
}
}
#line 644 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_tcgetpgrp[10]  = 
#line 644
  {      (char )'t',      (char )'c',      (char )'g',      (char )'e', 
        (char )'t',      (char )'p',      (char )'g',      (char )'r', 
        (char )'p',      (char )'\000'};
#line 645 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_tcgetpgrp(SCM port ) 
{ 
  int fd ;
  pid_t pgid ;

  {
#line 652
  if (! (6 & (int )port)) {
#line 652
    if (! (((65279L | (1L << 16)) & ((scm_cell *)port)->car) == (125L | (1L << 16)))) {
      {
#line 652
      scm_wta(port, (char *)1, s_tcgetpgrp);
      }
    }
  } else {
    {
#line 652
    scm_wta(port, (char *)1, s_tcgetpgrp);
    }
  }
  {
#line 653
  fd = fileno((FILE *)((struct scm_port_table *)((scm_cell *)port)->cdr)->stream);
  }
#line 654
  if (fd == -1) {
    {
#line 655
    scm_syserror(s_tcgetpgrp);
    }
  } else {
    {
#line 654
    pgid = tcgetpgrp(fd);
    }
#line 654
    if (pgid == -1) {
      {
#line 655
      scm_syserror(s_tcgetpgrp);
      }
    }
  }
#line 656
  return ((long )(pgid << 2) + 2L);
}
}
#line 664 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_tcsetpgrp[10]  = 
#line 664
  {      (char )'t',      (char )'c',      (char )'s',      (char )'e', 
        (char )'t',      (char )'p',      (char )'g',      (char )'r', 
        (char )'p',      (char )'\000'};
#line 665 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_tcsetpgrp(SCM port , SCM pgid ) 
{ 
  int fd ;
  int tmp ;

  {
#line 671
  if (! (6 & (int )port)) {
#line 671
    if (! (((65279L | (1L << 16)) & ((scm_cell *)port)->car) == (125L | (1L << 16)))) {
      {
#line 671
      scm_wta(port, (char *)1, s_tcsetpgrp);
      }
    }
  } else {
    {
#line 671
    scm_wta(port, (char *)1, s_tcsetpgrp);
    }
  }
#line 672
  if (! (2 & (int )pgid)) {
    {
#line 672
    scm_wta(pgid, (char *)2, s_tcsetpgrp);
    }
  }
  {
#line 673
  fd = fileno((FILE *)((struct scm_port_table *)((scm_cell *)port)->cdr)->stream);
  }
#line 674
  if (fd == -1) {
    {
#line 675
    scm_syserror(s_tcsetpgrp);
    }
  } else {
    {
#line 674
    tmp = tcsetpgrp(fd, (__pid_t )(pgid >> 2));
    }
#line 674
    if (tmp == -1) {
      {
#line 675
      scm_syserror(s_tcsetpgrp);
      }
    }
  }
#line 676
  return ((long )(21 << 9) + 372L);
}
}
#line 686
static char **scm_convert_exec_args(SCM args ) ;
#line 688 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char **scm_convert_exec_args(SCM args ) 
{ 
  char **execargv ;
  int num_args ;
  int i ;
  long tmp ;
  char *tmp___0 ;
  size_t len ;
  char *dst ;
  char *src ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 695
  scm_ints_disabled = 1;
#line 696
  tmp = scm_ilength(args);
#line 696
  num_args = (int )tmp;
#line 697
  tmp___0 = scm_must_malloc((long )((unsigned long )(num_args + 1) * sizeof(char *)),
                            s_ttyname);
#line 697
  execargv = (char **)tmp___0;
#line 699
  i = 0;
  }
  {
#line 699
  while (1) {
    while_continue: /* CIL Label */ ;
#line 699
    if (! ((long )(20 << 9) + 372L != args)) {
#line 699
      goto while_break;
    }
#line 704
    if (! (6 & (int )((scm_cell *)args)->car)) {
#line 704
      if (! ((117 & (int )((scm_cell *)((scm_cell *)args)->car)->car) == 21)) {
#line 704
        if (! ((125 & (int )((scm_cell *)((scm_cell *)args)->car)->car) == 5)) {
          {
#line 704
          scm_wta(((scm_cell *)args)->car, (char *)"wrong type in SCM_ARG", (char *)"exec arg");
          }
        }
      }
    } else {
      {
#line 704
      scm_wta(((scm_cell *)args)->car, (char *)"wrong type in SCM_ARG", (char *)"exec arg");
      }
    }
    {
#line 706
    len = 1UL + ((unsigned long )((scm_cell *)((scm_cell *)args)->car)->car >> 8);
#line 707
    tmp___1 = scm_must_malloc((long )len, s_ttyname);
#line 707
    dst = tmp___1;
    }
#line 708
    if ((127 & (int )((scm_cell *)((scm_cell *)args)->car)->car) == 29) {
#line 708
      src = (char *)((scm_cell *)((scm_cell *)((scm_cell *)((scm_cell *)args)->car)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)((scm_cell *)args)->car)->cdr)->car >> 2);
    } else {
#line 708
      src = (char *)((scm_cell *)((scm_cell *)args)->car)->cdr;
    }
    {
#line 709
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 709
      tmp___2 = len;
#line 709
      len --;
#line 709
      if (! tmp___2) {
#line 709
        goto while_break___0;
      }
#line 710
      *(dst + len) = *(src + len);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 711
    *(execargv + i) = dst;
#line 699
    args = ((scm_cell *)args)->cdr;
#line 699
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 713
  *(execargv + i) = (char *)0;
#line 714
  scm_ints_disabled = 0;
#line 714
  scm_async_clock --;
#line 714
  if (0U == scm_async_clock) {
    {
#line 714
    scm_async_click();
    }
  }
#line 715
  return (execargv);
}
}
#line 718 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_execl[6]  = {      (char )'e',      (char )'x',      (char )'e',      (char )'c', 
        (char )'l',      (char )'\000'};
#line 720 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_execl(SCM args ) 
{ 
  char **execargv ;
  SCM filename ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 725
  filename = ((scm_cell *)args)->car;
#line 726
  if (! (6 & (int )filename)) {
#line 726
    if (! ((117 & (int )((scm_cell *)filename)->car) == 21)) {
#line 726
      if (! ((125 & (int )((scm_cell *)filename)->car) == 5)) {
        {
#line 726
        scm_wta(filename, (char *)1, s_execl);
        }
      }
    }
  } else {
    {
#line 726
    scm_wta(filename, (char *)1, s_execl);
    }
  }
#line 727
  if ((125 & (int )((scm_cell *)filename)->car) == 29) {
#line 728
    if ((127 & (int )((scm_cell *)filename)->car) == 29) {
#line 728
      tmp = (char *)((scm_cell *)((scm_cell *)((scm_cell *)filename)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)filename)->cdr)->car >> 2);
    } else {
#line 728
      tmp = (char *)((scm_cell *)filename)->cdr;
    }
    {
#line 728
    filename = scm_makfromstr((char const   *)tmp, (unsigned long )((scm_cell *)filename)->car >> 8,
                              0);
    }
  }
  {
#line 729
  args = ((scm_cell *)args)->cdr;
#line 730
  execargv = scm_convert_exec_args(args);
  }
#line 731
  if ((127 & (int )((scm_cell *)filename)->car) == 29) {
#line 731
    tmp___0 = (char *)((scm_cell *)((scm_cell *)((scm_cell *)filename)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)filename)->cdr)->car >> 2);
  } else {
#line 731
    tmp___0 = (char *)((scm_cell *)filename)->cdr;
  }
  {
#line 731
  execv((char const   *)tmp___0, (char * const  *)execargv);
#line 732
  scm_syserror(s_execl);
  }
#line 734
  return ((long )(16 << 9) + 372L);
}
}
#line 737 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_execlp[7]  = {      (char )'e',      (char )'x',      (char )'e',      (char )'c', 
        (char )'l',      (char )'p',      (char )'\000'};
#line 739 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_execlp(SCM args ) 
{ 
  char **execargv ;
  SCM filename ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 744
  filename = ((scm_cell *)args)->car;
#line 745
  if (! (6 & (int )filename)) {
#line 745
    if (! ((117 & (int )((scm_cell *)filename)->car) == 21)) {
#line 745
      if (! ((125 & (int )((scm_cell *)filename)->car) == 5)) {
        {
#line 745
        scm_wta(filename, (char *)1, s_execlp);
        }
      }
    }
  } else {
    {
#line 745
    scm_wta(filename, (char *)1, s_execlp);
    }
  }
#line 746
  if ((125 & (int )((scm_cell *)filename)->car) == 29) {
#line 747
    if ((127 & (int )((scm_cell *)filename)->car) == 29) {
#line 747
      tmp = (char *)((scm_cell *)((scm_cell *)((scm_cell *)filename)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)filename)->cdr)->car >> 2);
    } else {
#line 747
      tmp = (char *)((scm_cell *)filename)->cdr;
    }
    {
#line 747
    filename = scm_makfromstr((char const   *)tmp, (unsigned long )((scm_cell *)filename)->car >> 8,
                              0);
    }
  }
  {
#line 748
  args = ((scm_cell *)args)->cdr;
#line 749
  execargv = scm_convert_exec_args(args);
  }
#line 750
  if ((127 & (int )((scm_cell *)filename)->car) == 29) {
#line 750
    tmp___0 = (char *)((scm_cell *)((scm_cell *)((scm_cell *)filename)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)filename)->cdr)->car >> 2);
  } else {
#line 750
    tmp___0 = (char *)((scm_cell *)filename)->cdr;
  }
  {
#line 750
  execvp((char const   *)tmp___0, (char * const  *)execargv);
#line 751
  scm_syserror(s_execlp);
  }
#line 753
  return ((long )(16 << 9) + 372L);
}
}
#line 757 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_fork[5]  = {      (char )'f',      (char )'o',      (char )'r',      (char )'k', 
        (char )'\000'};
#line 759 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_fork(void) 
{ 
  int pid ;

  {
  {
#line 763
  pid = fork();
  }
#line 764
  if (pid == -1) {
    {
#line 765
    scm_syserror(s_fork);
    }
  }
#line 766
  return (((long )pid << 2) + 2L);
}
}
#line 770 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_uname[6]  = {      (char )'u',      (char )'n',      (char )'a',      (char )'m', 
        (char )'e',      (char )'\000'};
#line 772 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_uname(void) 
{ 
  struct utsname buf ;
  SCM ans ;
  SCM tmp ;
  SCM *ve ;
  int *tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;

  {
  {
#line 777
  tmp = scm_make_vector((long )(5 << 2) + 2L, (long )(21 << 9) + 372L, (long )(16 << 9) + 372L);
#line 777
  ans = tmp;
#line 778
  ve = (SCM *)((scm_cell *)ans)->cdr;
#line 779
  tmp___1 = uname(& buf);
  }
#line 779
  if (tmp___1) {
    {
#line 780
    tmp___0 = __errno_location();
    }
#line 780
    return ((long )(*tmp___0 << 2) + 2L);
  }
  {
#line 781
  *(ve + 0) = scm_makfrom0str((char const   *)(buf.sysname));
#line 782
  *(ve + 1) = scm_makfrom0str((char const   *)(buf.nodename));
#line 783
  *(ve + 2) = scm_makfrom0str((char const   *)(buf.release));
#line 784
  *(ve + 3) = scm_makfrom0str((char const   *)(buf.version));
#line 785
  *(ve + 4) = scm_makfrom0str((char const   *)(buf.machine));
  }
#line 790
  return (ans);
}
}
#line 798 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_environ[8]  = 
#line 798
  {      (char )'e',      (char )'n',      (char )'v',      (char )'i', 
        (char )'r',      (char )'o',      (char )'n',      (char )'\000'};
#line 837 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static int first  =    1;
#line 800 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_environ(SCM env ) 
{ 
  SCM tmp ;
  int num_strings ;
  char **new_environ ;
  int i ;
  long tmp___0 ;
  char *tmp___1 ;
  int len ;
  char *src ;
  int tmp___2 ;
  char **ep ;

  {
#line 804
  if ((long )(18 << 9) + 372L == env) {
    {
#line 805
    tmp = scm_makfromstrs(-1, environ);
    }
#line 805
    return (tmp);
  } else {
#line 810
    i = 0;
#line 811
    if (! ((long )(20 << 9) + 372L == env)) {
#line 811
      if (! (6 & (int )env)) {
#line 811
        if (! (! (1 & (int )((scm_cell *)env)->car))) {
          {
#line 811
          scm_wta(env, (char *)1, s_environ);
          }
        }
      } else {
        {
#line 811
        scm_wta(env, (char *)1, s_environ);
        }
      }
    }
    {
#line 813
    tmp___0 = scm_ilength(env);
#line 813
    num_strings = (int )tmp___0;
#line 814
    tmp___1 = scm_must_malloc((long )((unsigned long )(num_strings + 1) * sizeof(char *)),
                              s_environ);
#line 814
    new_environ = (char **)tmp___1;
    }
    {
#line 817
    while (1) {
      while_continue: /* CIL Label */ ;
#line 817
      if (! ((long )(20 << 9) + 372L != env)) {
#line 817
        goto while_break;
      }
#line 821
      if (! (6 & (int )((scm_cell *)env)->car)) {
#line 821
        if (! ((117 & (int )((scm_cell *)((scm_cell *)env)->car)->car) == 21)) {
#line 821
          if (! ((125 & (int )((scm_cell *)((scm_cell *)env)->car)->car) == 5)) {
            {
#line 821
            scm_wta(env, (char *)1, s_environ);
            }
          }
        }
      } else {
        {
#line 821
        scm_wta(env, (char *)1, s_environ);
        }
      }
      {
#line 823
      len = (int )(1UL + ((unsigned long )((scm_cell *)((scm_cell *)env)->car)->car >> 8));
#line 824
      *(new_environ + i) = scm_must_malloc((long )len, s_environ);
      }
#line 825
      if ((127 & (int )((scm_cell *)((scm_cell *)env)->car)->car) == 29) {
#line 825
        src = (char *)((scm_cell *)((scm_cell *)((scm_cell *)((scm_cell *)env)->car)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)((scm_cell *)env)->car)->cdr)->car >> 2);
      } else {
#line 825
        src = (char *)((scm_cell *)((scm_cell *)env)->car)->cdr;
      }
      {
#line 826
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 826
        tmp___2 = len;
#line 826
        len --;
#line 826
        if (! tmp___2) {
#line 826
          goto while_break___0;
        }
#line 827
        *(*(new_environ + i) + len) = *(src + len);
      }
      while_break___0: /* CIL Label */ ;
      }
#line 828
      env = ((scm_cell *)env)->cdr;
#line 829
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 831
    *(new_environ + i) = (char *)0;
#line 838
    if (! first) {
#line 840
      ep = environ;
      {
#line 840
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 840
        if (! ((unsigned long )*ep != (unsigned long )((void *)0))) {
#line 840
          goto while_break___1;
        }
        {
#line 841
        scm_must_free(*ep);
#line 840
        ep ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 842
      scm_must_free((char *)environ);
      }
    }
#line 844
    first = 0;
#line 846
    environ = new_environ;
#line 847
    return ((long )(21 << 9) + 372L);
  }
}
}
#line 853 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_tmpnam[7]  = {      (char )'t',      (char )'m',      (char )'p',      (char )'n', 
        (char )'a',      (char )'m',      (char )'\000'};
#line 855 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_tmpnam(void) 
{ 
  char name[20] ;
  int *tmp ;
  int *tmp___0 ;
  SCM tmp___1 ;
  void *__cil_tmp5 ;

  {
  {
#line 858
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 858
    tmp = __errno_location();
#line 858
    *tmp = 0;
#line 858
    tmpnam(name);
#line 858
    tmp___0 = __errno_location();
    }
#line 858
    if (! (4 == *tmp___0)) {
#line 858
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 859
  tmp___1 = scm_makfrom0str((char const   *)(name));
  }
#line 859
  return (tmp___1);
}
}
#line 863 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_open_pipe[10]  = 
#line 863
  {      (char )'o',      (char )'p',      (char )'e',      (char )'n', 
        (char )'-',      (char )'p',      (char )'i',      (char )'p', 
        (char )'e',      (char )'\000'};
#line 865 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_open_pipe(SCM pipestr , SCM modes ) 
{ 
  FILE *f ;
  register SCM z ;
  struct scm_port_table *pt ;
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  long tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
#line 874
  if (! (6 & (int )pipestr)) {
#line 874
    if (! ((117 & (int )((scm_cell *)pipestr)->car) == 21)) {
#line 874
      if (! ((125 & (int )((scm_cell *)pipestr)->car) == 5)) {
        {
#line 874
        scm_wta(pipestr, (char *)1, s_open_pipe);
        }
      }
    }
  } else {
    {
#line 874
    scm_wta(pipestr, (char *)1, s_open_pipe);
    }
  }
#line 875
  if ((125 & (int )((scm_cell *)pipestr)->car) == 29) {
#line 876
    if ((127 & (int )((scm_cell *)pipestr)->car) == 29) {
#line 876
      tmp = (char *)((scm_cell *)((scm_cell *)((scm_cell *)pipestr)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)pipestr)->cdr)->car >> 2);
    } else {
#line 876
      tmp = (char *)((scm_cell *)pipestr)->cdr;
    }
    {
#line 876
    pipestr = scm_makfromstr((char const   *)tmp, (unsigned long )((scm_cell *)pipestr)->car >> 8,
                             0);
    }
  }
#line 877
  if (! (6 & (int )modes)) {
#line 877
    if (! ((117 & (int )((scm_cell *)modes)->car) == 21)) {
#line 877
      if (! ((125 & (int )((scm_cell *)modes)->car) == 5)) {
        {
#line 877
        scm_wta(modes, (char *)2, s_open_pipe);
        }
      }
    }
  } else {
    {
#line 877
    scm_wta(modes, (char *)2, s_open_pipe);
    }
  }
#line 878
  if ((125 & (int )((scm_cell *)modes)->car) == 29) {
#line 879
    if ((127 & (int )((scm_cell *)modes)->car) == 29) {
#line 879
      tmp___0 = (char *)((scm_cell *)((scm_cell *)((scm_cell *)modes)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)modes)->cdr)->car >> 2);
    } else {
#line 879
      tmp___0 = (char *)((scm_cell *)modes)->cdr;
    }
    {
#line 879
    modes = scm_makfromstr((char const   *)tmp___0, (unsigned long )((scm_cell *)modes)->car >> 8,
                           0);
    }
  }
#line 880
  if (6 & (int )scm_freelist) {
    {
#line 880
    z = scm_gc_for_newcell();
    }
  } else {
#line 880
    z = scm_freelist;
#line 880
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 880
    scm_cells_allocated ++;
  }
  {
#line 881
  scm_ints_disabled = 1;
#line 882
  scm_ignore_signals();
  }
  {
#line 883
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 883
    tmp___1 = __errno_location();
#line 883
    *tmp___1 = 0;
    }
#line 883
    if ((127 & (int )((scm_cell *)modes)->car) == 29) {
#line 883
      tmp___2 = (char *)((scm_cell *)((scm_cell *)((scm_cell *)modes)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)modes)->cdr)->car >> 2);
    } else {
#line 883
      tmp___2 = (char *)((scm_cell *)modes)->cdr;
    }
#line 883
    if ((127 & (int )((scm_cell *)pipestr)->car) == 29) {
#line 883
      tmp___3 = (char *)((scm_cell *)((scm_cell *)((scm_cell *)pipestr)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)pipestr)->cdr)->car >> 2);
    } else {
#line 883
      tmp___3 = (char *)((scm_cell *)pipestr)->cdr;
    }
    {
#line 883
    f = popen((char const   *)tmp___3, (char const   *)tmp___2);
#line 883
    tmp___4 = __errno_location();
    }
#line 883
    if (! (4 == *tmp___4)) {
#line 883
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 884
  scm_unignore_signals();
  }
#line 885
  if (! f) {
    {
#line 886
    scm_syserror(s_open_pipe);
    }
  }
  {
#line 887
  pt = scm_add_to_port_table(z);
#line 888
  ((scm_cell *)z)->cdr = (SCM )pt;
  }
#line 889
  if ((127 & (int )((scm_cell *)modes)->car) == 29) {
#line 889
    tmp___8 = (char *)((scm_cell *)((scm_cell *)((scm_cell *)modes)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)modes)->cdr)->car >> 2);
  } else {
#line 889
    tmp___8 = (char *)((scm_cell *)modes)->cdr;
  }
  {
#line 889
  tmp___9 = strchr((char const   *)tmp___8, 'r');
  }
#line 889
  if (tmp___9) {
#line 889
    tmp___7 = 2L << 16;
  } else {
#line 889
    tmp___7 = 4L << 16;
  }
#line 889
  ((scm_cell *)z)->car = (381L | (1L << 16)) | tmp___7;
#line 891
  ((struct scm_port_table *)((scm_cell *)z)->cdr)->stream = (SCM )f;
#line 892
  scm_ints_disabled = 0;
#line 892
  scm_async_clock --;
#line 892
  if (0U == scm_async_clock) {
    {
#line 892
    scm_async_click();
    }
  }
#line 893
  return (z);
}
}
#line 897 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_open_input_pipe[16]  = 
#line 897
  {      (char )'o',      (char )'p',      (char )'e',      (char )'n', 
        (char )'-',      (char )'i',      (char )'n',      (char )'p', 
        (char )'u',      (char )'t',      (char )'-',      (char )'p', 
        (char )'i',      (char )'p',      (char )'e',      (char )'\000'};
#line 899 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_open_input_pipe(SCM pipestr ) 
{ 
  SCM tmp ;
  SCM tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 903
  tmp = scm_makfromstr("r", sizeof("r") - 1UL, 0);
#line 903
  tmp___0 = scm_open_pipe(pipestr, tmp);
  }
#line 903
  return (tmp___0);
}
}
#line 906 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_open_output_pipe[17]  = 
#line 906
  {      (char )'o',      (char )'p',      (char )'e',      (char )'n', 
        (char )'-',      (char )'o',      (char )'u',      (char )'t', 
        (char )'p',      (char )'u',      (char )'t',      (char )'-', 
        (char )'p',      (char )'i',      (char )'p',      (char )'e', 
        (char )'\000'};
#line 908 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_open_output_pipe(SCM pipestr ) 
{ 
  SCM tmp ;
  SCM tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 912
  tmp = scm_makfromstr("w", sizeof("w") - 1UL, 0);
#line 912
  tmp___0 = scm_open_pipe(pipestr, tmp);
  }
#line 912
  return (tmp___0);
}
}
#line 916 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_utime[6]  = {      (char )'u',      (char )'t',      (char )'i',      (char )'m', 
        (char )'e',      (char )'\000'};
#line 918 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_utime(SCM pathname , SCM actime , SCM modtime ) 
{ 
  int rv ;
  struct utimbuf utm_tmp ;
  int *tmp ;
  int *tmp___0 ;
  unsigned long tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  unsigned long tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  void *__cil_tmp14 ;

  {
#line 927
  if (! (6 & (int )pathname)) {
#line 927
    if (! ((125 & (int )((scm_cell *)pathname)->car) == 21)) {
      {
#line 927
      scm_wta(pathname, (char *)1, s_utime);
      }
    }
  } else {
    {
#line 927
    scm_wta(pathname, (char *)1, s_utime);
    }
  }
#line 929
  if ((long )(18 << 9) + 372L == actime) {
    {
#line 930
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 930
      tmp = __errno_location();
#line 930
      *tmp = 0;
#line 930
      time(& utm_tmp.actime);
#line 930
      tmp___0 = __errno_location();
      }
#line 930
      if (! (4 == *tmp___0)) {
#line 930
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 932
    tmp___1 = scm_num2ulong(actime, (char *)2, s_utime);
#line 932
    utm_tmp.actime = (__time_t )tmp___1;
    }
  }
#line 934
  if ((long )(18 << 9) + 372L == modtime) {
    {
#line 935
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 935
      tmp___2 = __errno_location();
#line 935
      *tmp___2 = 0;
#line 935
      time(& utm_tmp.modtime);
#line 935
      tmp___3 = __errno_location();
      }
#line 935
      if (! (4 == *tmp___3)) {
#line 935
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 937
    tmp___4 = scm_num2ulong(modtime, (char *)3, s_utime);
#line 937
    utm_tmp.modtime = (__time_t )tmp___4;
    }
  }
  {
#line 939
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 939
    tmp___5 = __errno_location();
#line 939
    *tmp___5 = 0;
#line 939
    rv = utime((char const   *)((char *)((scm_cell *)pathname)->cdr), (struct utimbuf  const  *)(& utm_tmp));
#line 939
    tmp___6 = __errno_location();
    }
#line 939
    if (! (4 == *tmp___6)) {
#line 939
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 940
  if (rv != 0) {
    {
#line 941
    scm_syserror(s_utime);
    }
  }
#line 942
  return ((long )(21 << 9) + 372L);
}
}
#line 945 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_access[8]  = 
#line 945
  {      (char )'a',      (char )'c',      (char )'c',      (char )'e', 
        (char )'s',      (char )'s',      (char )'?',      (char )'\000'};
#line 947 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_access(SCM path , SCM how ) 
{ 
  int rv ;
  char *tmp ;
  char *tmp___0 ;
  long tmp___1 ;

  {
#line 954
  if (! (6 & (int )path)) {
#line 954
    if (! ((117 & (int )((scm_cell *)path)->car) == 21)) {
#line 954
      if (! ((125 & (int )((scm_cell *)path)->car) == 5)) {
        {
#line 954
        scm_wta(path, (char *)1, s_access);
        }
      }
    }
  } else {
    {
#line 954
    scm_wta(path, (char *)1, s_access);
    }
  }
#line 955
  if ((125 & (int )((scm_cell *)path)->car) == 29) {
#line 956
    if ((127 & (int )((scm_cell *)path)->car) == 29) {
#line 956
      tmp = (char *)((scm_cell *)((scm_cell *)((scm_cell *)path)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)path)->cdr)->car >> 2);
    } else {
#line 956
      tmp = (char *)((scm_cell *)path)->cdr;
    }
    {
#line 956
    path = scm_makfromstr((char const   *)tmp, (unsigned long )((scm_cell *)path)->car >> 8,
                          0);
    }
  }
#line 957
  if (! (2 & (int )how)) {
    {
#line 957
    scm_wta(how, (char *)2, s_access);
    }
  }
#line 958
  if ((127 & (int )((scm_cell *)path)->car) == 29) {
#line 958
    tmp___0 = (char *)((scm_cell *)((scm_cell *)((scm_cell *)path)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)path)->cdr)->car >> 2);
  } else {
#line 958
    tmp___0 = (char *)((scm_cell *)path)->cdr;
  }
  {
#line 958
  rv = access((char const   *)tmp___0, (int )(how >> 2));
  }
#line 959
  if (rv) {
#line 959
    tmp___1 = (long )(16 << 9) + 372L;
  } else {
#line 959
    tmp___1 = (long )(17 << 9) + 372L;
  }
#line 959
  return (tmp___1);
}
}
#line 962 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_getpid[7]  = {      (char )'g',      (char )'e',      (char )'t',      (char )'p', 
        (char )'i',      (char )'d',      (char )'\000'};
#line 964 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_getpid(void) 
{ 
  __pid_t tmp ;

  {
  {
#line 967
  tmp = getpid();
  }
#line 967
  return ((SCM )(((unsigned long )tmp << 2) + 2UL));
}
}
#line 970 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_putenv[7]  = {      (char )'p',      (char )'u',      (char )'t',      (char )'e', 
        (char )'n',      (char )'v',      (char )'\000'};
#line 972 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_putenv(SCM str ) 
{ 
  int rv ;

  {
#line 979
  if (! (6 & (int )str)) {
#line 979
    if (! ((125 & (int )((scm_cell *)str)->car) == 21)) {
      {
#line 979
      scm_wta(str, (char *)1, s_putenv);
      }
    }
  } else {
    {
#line 979
    scm_wta(str, (char *)1, s_putenv);
    }
  }
  {
#line 980
  rv = putenv((char *)((scm_cell *)str)->cdr);
  }
#line 981
  if (rv < 0) {
    {
#line 982
    scm_syserror(s_putenv);
    }
  }
#line 983
  return ((long )(21 << 9) + 372L);
}
}
#line 991 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_read_line[10]  = 
#line 991
  {      (char )'r',      (char )'e',      (char )'a',      (char )'d', 
        (char )'-',      (char )'l',      (char )'i',      (char )'n', 
        (char )'e',      (char )'\000'};
#line 993 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_read_line(SCM port , SCM include_terminator ) 
{ 
  register int c ;
  register int j ;
  size_t len ;
  SCM tok_buf___0 ;
  register char *p ;
  int include ;
  int tmp ;
  SCM tmp___0 ;
  int tmp___1 ;

  {
  {
#line 999
  j = 0;
#line 1000
  len = (size_t )30;
#line 1005
  tok_buf___0 = scm_makstr((long )len, 0);
#line 1006
  p = (char *)((scm_cell *)tok_buf___0)->cdr;
  }
#line 1007
  if ((long )(18 << 9) + 372L == port) {
#line 1008
    port = scm_root->cur_inp;
  } else
#line 1010
  if (! (6 & (int )port)) {
#line 1010
    if (! ((((127L | (1L << 16)) | (2L << 16)) & ((scm_cell *)port)->car) == ((125L | (1L << 16)) | (2L << 16)))) {
      {
#line 1010
      scm_wta(port, (char *)1, s_read_line);
      }
    }
  } else {
    {
#line 1010
    scm_wta(port, (char *)1, s_read_line);
    }
  }
#line 1012
  if ((long )(18 << 9) + 372L == include_terminator) {
#line 1013
    include = 0;
  } else {
#line 1015
    include = (long )(16 << 9) + 372L != include_terminator;
  }
  {
#line 1017
  c = scm_gen_getc(port);
  }
#line 1017
  if (-1 == c) {
#line 1018
    return ((long )(19 << 9) + 372L);
  }
  {
#line 1019
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1023
    if (c == 10) {
#line 1023
      goto case_10;
    }
#line 1031
    if (c == -1) {
#line 1031
      goto case_neg_1;
    }
#line 1036
    goto switch_default;
    case_10: /* CIL Label */ 
#line 1024
    if ((size_t )j >= len) {
      {
#line 1026
      p = scm_grow_tok_buf(& tok_buf___0);
#line 1027
      len = (unsigned long )((scm_cell *)tok_buf___0)->car >> 8;
      }
    }
#line 1029
    tmp = j;
#line 1029
    j ++;
#line 1029
    *(p + tmp) = (char )c;
    case_neg_1: /* CIL Label */ 
#line 1032
    if (len == (size_t )j) {
#line 1033
      return (tok_buf___0);
    }
    {
#line 1034
    tmp___0 = scm_vector_set_length_x(tok_buf___0, (long )(j << 2) + 2L);
    }
#line 1034
    return (tmp___0);
    switch_default: /* CIL Label */ 
#line 1037
    if ((size_t )j >= len) {
      {
#line 1039
      p = scm_grow_tok_buf(& tok_buf___0);
#line 1040
      len = (unsigned long )((scm_cell *)tok_buf___0)->car >> 8;
      }
    }
    {
#line 1042
    tmp___1 = j;
#line 1042
    j ++;
#line 1042
    *(p + tmp___1) = (char )c;
#line 1043
    c = scm_gen_getc(port);
    }
#line 1044
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1049 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_read_line_x[11]  = 
#line 1049
  {      (char )'r',      (char )'e',      (char )'a',      (char )'d', 
        (char )'-',      (char )'l',      (char )'i',      (char )'n', 
        (char )'e',      (char )'!',      (char )'\000'};
#line 1051 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_read_line_x(SCM str , SCM port ) 
{ 
  register int c ;
  register int j ;
  register char *p ;
  size_t len ;
  int tmp ;

  {
#line 1057
  j = 0;
#line 1060
  if (! (6 & (int )str)) {
#line 1060
    if (! ((125 & (int )((scm_cell *)str)->car) == 21)) {
      {
#line 1060
      scm_wta(str, (char *)1, s_read_line_x);
      }
    }
  } else {
    {
#line 1060
    scm_wta(str, (char *)1, s_read_line_x);
    }
  }
#line 1061
  p = (char *)((scm_cell *)str)->cdr;
#line 1062
  len = (unsigned long )((scm_cell *)str)->car >> 8;
#line 1063
  if ((long )(18 << 9) + 372L == port) {
#line 1063
    port = scm_root->cur_inp;
  } else
#line 1066
  if (! (6 & (int )port)) {
#line 1066
    if (! ((((127L | (1L << 16)) | (2L << 16)) & ((scm_cell *)port)->car) == ((125L | (1L << 16)) | (2L << 16)))) {
      {
#line 1066
      scm_wta(port, (char *)2, s_read_line_x);
      }
    }
  } else {
    {
#line 1066
    scm_wta(port, (char *)2, s_read_line_x);
    }
  }
  {
#line 1067
  c = scm_gen_getc(port);
  }
#line 1068
  if (-1 == c) {
#line 1069
    return ((long )(19 << 9) + 372L);
  }
  {
#line 1070
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1075
    if (c == -1) {
#line 1075
      goto case_neg_1;
    }
#line 1075
    if (c == 10) {
#line 1075
      goto case_neg_1;
    }
#line 1077
    goto switch_default;
    case_neg_1: /* CIL Label */ 
    case_10: /* CIL Label */ 
#line 1076
    return ((long )(j << 2) + 2L);
    switch_default: /* CIL Label */ 
#line 1078
    if ((size_t )j >= len) {
      {
#line 1080
      scm_gen_ungetc(c, port);
      }
#line 1081
      return ((long )(16 << 9) + 372L);
    }
    {
#line 1083
    tmp = j;
#line 1083
    j ++;
#line 1083
    *(p + tmp) = (char )c;
#line 1084
    c = scm_gen_getc(port);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1089 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_write_line[11]  = 
#line 1089
  {      (char )'w',      (char )'r',      (char )'i',      (char )'t', 
        (char )'e',      (char )'-',      (char )'l',      (char )'i', 
        (char )'n',      (char )'e',      (char )'\000'};
#line 1091 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_write_line(SCM obj , SCM port ) 
{ 
  SCM tmp ;

  {
  {
#line 1096
  scm_display(obj, port);
#line 1097
  tmp = scm_newline(port);
  }
#line 1097
  return (tmp);
}
}
#line 1100 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_setlocale[10]  = 
#line 1100
  {      (char )'s',      (char )'e',      (char )'t',      (char )'l', 
        (char )'o',      (char )'c',      (char )'a',      (char )'l', 
        (char )'e',      (char )'\000'};
#line 1102 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_setlocale(SCM category , SCM locale ) 
{ 
  char *clocale ;
  char *rv ;
  SCM tmp ;

  {
#line 1111
  if (! (2 & (int )category)) {
    {
#line 1111
    scm_wta(category, (char *)1, s_setlocale);
    }
  }
#line 1112
  if ((long )(18 << 9) + 372L == locale) {
#line 1114
    clocale = (char *)((void *)0);
  } else {
#line 1118
    if (! (6 & (int )locale)) {
#line 1118
      if (! ((125 & (int )((scm_cell *)locale)->car) == 21)) {
        {
#line 1118
        scm_wta(locale, (char *)2, s_setlocale);
        }
      }
    } else {
      {
#line 1118
      scm_wta(locale, (char *)2, s_setlocale);
      }
    }
#line 1119
    clocale = (char *)((scm_cell *)locale)->cdr;
  }
  {
#line 1122
  rv = setlocale((int )(category >> 2), (char const   *)clocale);
  }
#line 1123
  if ((unsigned long )rv == (unsigned long )((void *)0)) {
    {
#line 1124
    scm_syserror(s_setlocale);
    }
  }
  {
#line 1125
  tmp = scm_makfrom0str((char const   *)rv);
  }
#line 1125
  return (tmp);
}
}
#line 1133 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_strftime[9]  = 
#line 1133
  {      (char )'s',      (char )'t',      (char )'r',      (char )'f', 
        (char )'t',      (char )'i',      (char )'m',      (char )'e', 
        (char )'\000'};
#line 1135 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_strftime(SCM format , SCM stime___0 ) 
{ 
  struct tm t ;
  char *tbuf ;
  int n ;
  int size ;
  char *fmt ;
  int len ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  int tmp___12 ;
  long tmp___13 ;
  size_t tmp___14 ;
  SCM tmp___15 ;
  void *__cil_tmp26 ;

  {
#line 1144
  size = 50;
#line 1148
  if (! (6 & (int )format)) {
#line 1148
    if (! ((125 & (int )((scm_cell *)format)->car) == 21)) {
      {
#line 1148
      scm_wta(format, (char *)1, s_strftime);
      }
    }
  } else {
    {
#line 1148
    scm_wta(format, (char *)1, s_strftime);
    }
  }
#line 1149
  if (! (6 & (int )stime___0)) {
#line 1149
    if ((125 & (int )((scm_cell *)stime___0)->car) == 13) {
      {
#line 1149
      tmp = scm_obj_length(stime___0);
      }
#line 1149
      if (! (tmp == 9)) {
        {
#line 1149
        scm_wta(stime___0, (char *)2, s_strftime);
        }
      }
    } else {
      {
#line 1149
      scm_wta(stime___0, (char *)2, s_strftime);
      }
    }
  } else {
    {
#line 1149
    scm_wta(stime___0, (char *)2, s_strftime);
    }
  }
#line 1152
  if ((127 & (int )((scm_cell *)format)->car) == 29) {
#line 1152
    fmt = (char *)((scm_cell *)((scm_cell *)((scm_cell *)format)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)format)->cdr)->car >> 2);
  } else {
#line 1152
    fmt = (char *)((scm_cell *)format)->cdr;
  }
  {
#line 1153
  len = (int )((unsigned long )((scm_cell *)format)->car >> 8);
#line 1156
  n = 0;
#line 1157
  tmp___0 = n;
#line 1157
  n ++;
#line 1157
  tmp___1 = scm_num2long(*((SCM *)((scm_cell *)stime___0)->cdr + tmp___0), (char *)2,
                         s_strftime);
#line 1157
  t.tm_sec = (int )tmp___1;
#line 1158
  tmp___2 = n;
#line 1158
  n ++;
#line 1158
  tmp___3 = scm_num2long(*((SCM *)((scm_cell *)stime___0)->cdr + tmp___2), (char *)2,
                         s_strftime);
#line 1158
  t.tm_min = (int )tmp___3;
#line 1159
  tmp___4 = n;
#line 1159
  n ++;
#line 1159
  tmp___5 = scm_num2long(*((SCM *)((scm_cell *)stime___0)->cdr + tmp___4), (char *)2,
                         s_strftime);
#line 1159
  t.tm_hour = (int )tmp___5;
#line 1160
  tmp___6 = n;
#line 1160
  n ++;
#line 1160
  tmp___7 = scm_num2long(*((SCM *)((scm_cell *)stime___0)->cdr + tmp___6), (char *)2,
                         s_strftime);
#line 1160
  t.tm_mday = (int )tmp___7;
#line 1161
  tmp___8 = n;
#line 1161
  n ++;
#line 1161
  tmp___9 = scm_num2long(*((SCM *)((scm_cell *)stime___0)->cdr + tmp___8), (char *)2,
                         s_strftime);
#line 1161
  t.tm_mon = (int )tmp___9;
#line 1162
  tmp___10 = n;
#line 1162
  n ++;
#line 1162
  tmp___11 = scm_num2long(*((SCM *)((scm_cell *)stime___0)->cdr + tmp___10), (char *)2,
                          s_strftime);
#line 1162
  t.tm_year = (int )tmp___11;
#line 1166
  tmp___12 = n;
#line 1166
  n ++;
#line 1166
  tmp___13 = scm_num2long(*((SCM *)((scm_cell *)stime___0)->cdr + tmp___12), (char *)2,
                          s_strftime);
#line 1166
  t.tm_isdst = (int )tmp___13;
#line 1170
  mktime(& t);
#line 1172
  tbuf = scm_must_malloc((long )size, s_strftime);
  }
  {
#line 1173
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1173
    tmp___14 = strftime((char */* __restrict  */)tbuf, (size_t )size, (char const   */* __restrict  */)fmt,
                        (struct tm  const  */* __restrict  */)(& t));
#line 1173
    len = (int )tmp___14;
    }
#line 1173
    if (! (len == size)) {
#line 1173
      goto while_break;
    }
    {
#line 1175
    scm_must_free(tbuf);
#line 1176
    size *= 2;
#line 1177
    tbuf = scm_must_malloc((long )size, s_strftime);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1179
  tmp___15 = scm_makfromstr((char const   *)tbuf, (size_t )len, 0);
  }
#line 1179
  return (tmp___15);
}
}
#line 1182 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_strptime[9]  = 
#line 1182
  {      (char )'s',      (char )'t',      (char )'r',      (char )'p', 
        (char )'t',      (char )'i',      (char )'m',      (char )'e', 
        (char )'\000'};
#line 1184 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_strptime(SCM format , SCM string ) 
{ 
  SCM stime___0 ;
  struct tm t ;
  char *fmt ;
  char *str ;
  char *rest ;
  int n ;
  char *tmp ;
  char *tmp___0 ;
  SCM tmp___1 ;
  SCM tmp___2 ;
  int tmp___3 ;
  SCM tmp___4 ;
  int tmp___5 ;
  SCM tmp___6 ;
  int tmp___7 ;
  SCM tmp___8 ;
  int tmp___9 ;
  SCM tmp___10 ;
  int tmp___11 ;
  SCM tmp___12 ;
  int tmp___13 ;
  SCM tmp___14 ;
  int tmp___15 ;
  SCM tmp___16 ;
  int tmp___17 ;
  SCM tmp___18 ;
  int tmp___19 ;
  SCM tmp___20 ;
  SCM tmp___21 ;
  void *__cil_tmp32 ;

  {
#line 1196
  if (! (6 & (int )format)) {
#line 1196
    if (! ((117 & (int )((scm_cell *)format)->car) == 21)) {
#line 1196
      if (! ((125 & (int )((scm_cell *)format)->car) == 5)) {
        {
#line 1196
        scm_wta(format, (char *)1, s_strptime);
        }
      }
    }
  } else {
    {
#line 1196
    scm_wta(format, (char *)1, s_strptime);
    }
  }
#line 1197
  if ((125 & (int )((scm_cell *)format)->car) == 29) {
#line 1198
    if ((127 & (int )((scm_cell *)format)->car) == 29) {
#line 1198
      tmp = (char *)((scm_cell *)((scm_cell *)((scm_cell *)format)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)format)->cdr)->car >> 2);
    } else {
#line 1198
      tmp = (char *)((scm_cell *)format)->cdr;
    }
    {
#line 1198
    format = scm_makfromstr((char const   *)tmp, (unsigned long )((scm_cell *)format)->car >> 8,
                            0);
    }
  }
#line 1199
  if (! (6 & (int )string)) {
#line 1199
    if (! ((117 & (int )((scm_cell *)string)->car) == 21)) {
#line 1199
      if (! ((125 & (int )((scm_cell *)string)->car) == 5)) {
        {
#line 1199
        scm_wta(string, (char *)2, s_strptime);
        }
      }
    }
  } else {
    {
#line 1199
    scm_wta(string, (char *)2, s_strptime);
    }
  }
#line 1200
  if ((125 & (int )((scm_cell *)string)->car) == 29) {
#line 1201
    if ((127 & (int )((scm_cell *)string)->car) == 29) {
#line 1201
      tmp___0 = (char *)((scm_cell *)((scm_cell *)((scm_cell *)string)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)string)->cdr)->car >> 2);
    } else {
#line 1201
      tmp___0 = (char *)((scm_cell *)string)->cdr;
    }
    {
#line 1201
    string = scm_makfromstr((char const   *)tmp___0, (unsigned long )((scm_cell *)string)->car >> 8,
                            0);
    }
  }
  {
#line 1203
  fmt = (char *)((scm_cell *)format)->cdr;
#line 1204
  str = (char *)((scm_cell *)string)->cdr;
#line 1208
  t.tm_sec = 0;
#line 1209
  t.tm_min = 0;
#line 1210
  t.tm_hour = 0;
#line 1211
  t.tm_mday = 0;
#line 1212
  t.tm_mon = 0;
#line 1213
  t.tm_year = 0;
#line 1214
  t.tm_wday = 0;
#line 1215
  t.tm_yday = 0;
#line 1216
  t.tm_isdst = 0;
#line 1219
  scm_ints_disabled = 1;
#line 1220
  rest = strptime(str, fmt, & t);
#line 1221
  scm_ints_disabled = 0;
#line 1221
  scm_async_clock --;
  }
#line 1221
  if (0U == scm_async_clock) {
    {
#line 1221
    scm_async_click();
    }
  }
#line 1223
  if ((unsigned long )rest == (unsigned long )((void *)0)) {
    {
#line 1224
    scm_syserror(s_strptime);
    }
  }
  {
#line 1226
  tmp___1 = scm_long2num(0L);
#line 1226
  stime___0 = scm_make_vector((long )(9 << 2) + 2L, tmp___1, (long )(18 << 9) + 372L);
#line 1229
  n = 0;
#line 1230
  tmp___2 = scm_long2num((long )t.tm_sec);
#line 1230
  tmp___3 = n;
#line 1230
  n ++;
#line 1230
  scm_vector_set_x(stime___0, (long )(tmp___3 << 2) + 2L, tmp___2);
#line 1231
  tmp___4 = scm_long2num((long )t.tm_min);
#line 1231
  tmp___5 = n;
#line 1231
  n ++;
#line 1231
  scm_vector_set_x(stime___0, (long )(tmp___5 << 2) + 2L, tmp___4);
#line 1232
  tmp___6 = scm_long2num((long )t.tm_hour);
#line 1232
  tmp___7 = n;
#line 1232
  n ++;
#line 1232
  scm_vector_set_x(stime___0, (long )(tmp___7 << 2) + 2L, tmp___6);
#line 1233
  tmp___8 = scm_long2num((long )t.tm_mday);
#line 1233
  tmp___9 = n;
#line 1233
  n ++;
#line 1233
  scm_vector_set_x(stime___0, (long )(tmp___9 << 2) + 2L, tmp___8);
#line 1234
  tmp___10 = scm_long2num((long )t.tm_mon);
#line 1234
  tmp___11 = n;
#line 1234
  n ++;
#line 1234
  scm_vector_set_x(stime___0, (long )(tmp___11 << 2) + 2L, tmp___10);
#line 1235
  tmp___12 = scm_long2num((long )t.tm_year);
#line 1235
  tmp___13 = n;
#line 1235
  n ++;
#line 1235
  scm_vector_set_x(stime___0, (long )(tmp___13 << 2) + 2L, tmp___12);
#line 1236
  tmp___14 = scm_long2num((long )t.tm_wday);
#line 1236
  tmp___15 = n;
#line 1236
  n ++;
#line 1236
  scm_vector_set_x(stime___0, (long )(tmp___15 << 2) + 2L, tmp___14);
#line 1237
  tmp___16 = scm_long2num((long )t.tm_yday);
#line 1237
  tmp___17 = n;
#line 1237
  n ++;
#line 1237
  scm_vector_set_x(stime___0, (long )(tmp___17 << 2) + 2L, tmp___16);
#line 1238
  tmp___18 = scm_long2num((long )t.tm_isdst);
#line 1238
  tmp___19 = n;
#line 1238
  n ++;
#line 1238
  scm_vector_set_x(stime___0, (long )(tmp___19 << 2) + 2L, tmp___18);
#line 1241
  tmp___20 = scm_makfrom0str((char const   *)rest);
#line 1241
  tmp___21 = scm_cons(stime___0, tmp___20);
  }
#line 1241
  return (tmp___21);
}
}
#line 1249 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_mknod[6]  = {      (char )'m',      (char )'k',      (char )'n',      (char )'o', 
        (char )'d',      (char )'\000'};
#line 1251 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_mknod(SCM path , SCM mode , SCM dev ) 
{ 
  int val ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 1259
  if (! (6 & (int )path)) {
#line 1259
    if (! ((125 & (int )((scm_cell *)path)->car) == 21)) {
      {
#line 1259
      scm_wta(path, (char *)1, s_mknod);
      }
    }
  } else {
    {
#line 1259
    scm_wta(path, (char *)1, s_mknod);
    }
  }
#line 1260
  if (! (2 & (int )mode)) {
    {
#line 1260
    scm_wta(mode, (char *)2, s_mknod);
    }
  }
#line 1261
  if (! (2 & (int )dev)) {
    {
#line 1261
    scm_wta(dev, (char *)3, s_mknod);
    }
  }
  {
#line 1262
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1262
    tmp = __errno_location();
#line 1262
    *tmp = 0;
#line 1262
    val = mknod((char const   *)((char *)((scm_cell *)path)->cdr), (__mode_t )(mode >> 2),
                (__dev_t )(dev >> 2));
#line 1262
    tmp___0 = __errno_location();
    }
#line 1262
    if (! (4 == *tmp___0)) {
#line 1262
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1263
  if (val != 0) {
    {
#line 1264
    scm_syserror(s_mknod);
    }
  }
#line 1265
  return ((long )(21 << 9) + 372L);
}
}
#line 1274 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_nice[5]  = {      (char )'n',      (char )'i',      (char )'c',      (char )'e', 
        (char )'\000'};
#line 1276 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_nice(SCM incr ) 
{ 
  int tmp ;

  {
#line 1281
  if (! (2 & (int )incr)) {
    {
#line 1281
    scm_wta(incr, (char *)1, s_nice);
    }
  }
  {
#line 1282
  tmp = nice((int )(incr >> 2));
  }
#line 1282
  if (tmp != 0) {
    {
#line 1283
    scm_syserror(s_nice);
    }
  }
#line 1284
  return ((long )(21 << 9) + 372L);
}
}
#line 1293 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
static char s_sync[5]  = {      (char )'s',      (char )'y',      (char )'n',      (char )'c', 
        (char )'\000'};
#line 1295 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
SCM scm_sync(void) 
{ 


  {
  {
#line 1299
  sync();
  }
#line 1304
  return ((long )(16 << 9) + 372L);
}
}
#line 1310 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
void scm_init_posix(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;

  {
  {
#line 1313
  scm_add_feature((char *)"posix");
#line 1315
  scm_add_feature((char *)"EIDs");
#line 1318
  scm_sysintern((char *)"WAIT_ANY", (long )(-1 << 2) + 2L);
#line 1321
  scm_sysintern((char *)"WAIT_MYPGRP", 2L);
#line 1324
  scm_sysintern((char *)"WNOHANG", (long )(1 << 2) + 2L);
#line 1327
  scm_sysintern((char *)"WUNTRACED", (long )(2 << 2) + 2L);
#line 1331
  scm_sysintern((char *)"EINTR", (long )(4 << 2) + 2L);
#line 1335
  scm_sysintern((char *)"SIGHUP", (long )(1 << 2) + 2L);
#line 1338
  scm_sysintern((char *)"SIGINT", (long )(2 << 2) + 2L);
#line 1341
  scm_sysintern((char *)"SIGQUIT", (long )(3 << 2) + 2L);
#line 1344
  scm_sysintern((char *)"SIGILL", (long )(4 << 2) + 2L);
#line 1347
  scm_sysintern((char *)"SIGTRAP", (long )(5 << 2) + 2L);
#line 1350
  scm_sysintern((char *)"SIGABRT", (long )(6 << 2) + 2L);
#line 1353
  scm_sysintern((char *)"SIGIOT", (long )(6 << 2) + 2L);
#line 1356
  scm_sysintern((char *)"SIGBUS", (long )(7 << 2) + 2L);
#line 1359
  scm_sysintern((char *)"SIGFPE", (long )(8 << 2) + 2L);
#line 1362
  scm_sysintern((char *)"SIGKILL", (long )(9 << 2) + 2L);
#line 1365
  scm_sysintern((char *)"SIGUSR1", (long )(10 << 2) + 2L);
#line 1368
  scm_sysintern((char *)"SIGSEGV", (long )(11 << 2) + 2L);
#line 1371
  scm_sysintern((char *)"SIGUSR2", (long )(12 << 2) + 2L);
#line 1374
  scm_sysintern((char *)"SIGPIPE", (long )(13 << 2) + 2L);
#line 1377
  scm_sysintern((char *)"SIGALRM", (long )(14 << 2) + 2L);
#line 1380
  scm_sysintern((char *)"SIGTERM", (long )(15 << 2) + 2L);
#line 1383
  scm_sysintern((char *)"SIGSTKFLT", (long )(16 << 2) + 2L);
#line 1386
  scm_sysintern((char *)"SIGCHLD", (long )(17 << 2) + 2L);
#line 1389
  scm_sysintern((char *)"SIGCONT", (long )(18 << 2) + 2L);
#line 1392
  scm_sysintern((char *)"SIGSTOP", (long )(19 << 2) + 2L);
#line 1395
  scm_sysintern((char *)"SIGTSTP", (long )(20 << 2) + 2L);
#line 1398
  scm_sysintern((char *)"SIGTTIN", (long )(21 << 2) + 2L);
#line 1401
  scm_sysintern((char *)"SIGTTOU", (long )(22 << 2) + 2L);
#line 1404
  scm_sysintern((char *)"SIGIO", (long )(29 << 2) + 2L);
#line 1407
  scm_sysintern((char *)"SIGPOLL", (long )(29 << 2) + 2L);
#line 1410
  scm_sysintern((char *)"SIGURG", (long )(23 << 2) + 2L);
#line 1413
  scm_sysintern((char *)"SIGXCPU", (long )(24 << 2) + 2L);
#line 1416
  scm_sysintern((char *)"SIGXFSZ", (long )(25 << 2) + 2L);
#line 1419
  scm_sysintern((char *)"SIGVTALRM", (long )(26 << 2) + 2L);
#line 1422
  scm_sysintern((char *)"SIGPROF", (long )(27 << 2) + 2L);
#line 1425
  scm_sysintern((char *)"SIGWINCH", (long )(28 << 2) + 2L);
#line 1431
  scm_sysintern((char *)"SIGPWR", (long )(30 << 2) + 2L);
#line 1434
  scm_sysintern((char *)"R_OK", (long )(4 << 2) + 2L);
#line 1435
  scm_sysintern((char *)"W_OK", (long )(2 << 2) + 2L);
#line 1436
  scm_sysintern((char *)"X_OK", (long )(1 << 2) + 2L);
#line 1437
  scm_sysintern((char *)"F_OK", 2L);
#line 1440
  scm_sysintern((char *)"LC_COLLATE", (long )(3 << 2) + 2L);
#line 1443
  scm_sysintern((char *)"LC_CTYPE", 2L);
#line 1446
  scm_sysintern((char *)"LC_MONETARY", (long )(4 << 2) + 2L);
#line 1449
  scm_sysintern((char *)"LC_NUMERIC", (long )(1 << 2) + 2L);
#line 1452
  scm_sysintern((char *)"LC_TIME", (long )(2 << 2) + 2L);
#line 1455
  scm_sysintern((char *)"LC_MESSAGES", (long )(5 << 2) + 2L);
#line 1458
  scm_sysintern((char *)"LC_ALL", (long )(6 << 2) + 2L);
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.x"
  scm_make_gsubr(s_pipe, 0, 0, 0, & scm_pipe);
#line 2
  scm_make_gsubr(s_getgroups, 0, 0, 0, & scm_getgroups);
#line 3
  scm_make_gsubr(s_getpwuid, 0, 1, 0, (SCM (*)())(& scm_getpwuid));
#line 4
  scm_make_gsubr(s_setpwent, 0, 1, 0, (SCM (*)())(& scm_setpwent));
#line 5
  scm_make_gsubr(s_getgrgid, 0, 1, 0, (SCM (*)())(& scm_getgrgid));
#line 6
  scm_make_gsubr(s_setgrent, 0, 1, 0, (SCM (*)())(& scm_setgrent));
#line 7
  scm_make_gsubr(s_kill, 2, 0, 0, (SCM (*)())(& scm_kill));
#line 8
  scm_make_gsubr(s_waitpid, 1, 1, 0, (SCM (*)())(& scm_waitpid));
#line 9
  scm_make_gsubr(s_getppid, 0, 0, 0, & scm_getppid);
#line 10
  scm_make_gsubr(s_getuid, 0, 0, 0, & scm_getuid);
#line 11
  scm_make_gsubr(s_getgid, 0, 0, 0, & scm_getgid);
#line 12
  scm_make_gsubr(s_geteuid, 0, 0, 0, & scm_geteuid);
#line 13
  scm_make_gsubr(s_getegid, 0, 0, 0, & scm_getegid);
#line 14
  scm_make_gsubr(s_setuid, 1, 0, 0, (SCM (*)())(& scm_setuid));
#line 15
  scm_make_gsubr(s_setgid, 1, 0, 0, (SCM (*)())(& scm_setgid));
#line 16
  scm_make_gsubr(s_seteuid, 1, 0, 0, (SCM (*)())(& scm_seteuid));
#line 17
  scm_make_gsubr(s_setegid, 1, 0, 0, (SCM (*)())(& scm_setegid));
#line 18
  scm_make_gsubr(s_getpgrp, 0, 0, 0, & scm_getpgrp);
#line 19
  scm_make_gsubr(s_setpgid, 2, 0, 0, (SCM (*)())(& scm_setpgid));
#line 20
  scm_make_gsubr(s_setsid, 0, 0, 0, & scm_setsid);
#line 21
  scm_make_gsubr(s_ttyname, 1, 0, 0, (SCM (*)())(& scm_ttyname));
#line 22
  scm_make_gsubr(s_ctermid, 0, 0, 0, & scm_ctermid);
#line 23
  scm_make_gsubr(s_tcgetpgrp, 1, 0, 0, (SCM (*)())(& scm_tcgetpgrp));
#line 24
  scm_make_gsubr(s_tcsetpgrp, 2, 0, 0, (SCM (*)())(& scm_tcsetpgrp));
#line 25
  scm_make_gsubr(s_execl, 0, 0, 1, (SCM (*)())(& scm_execl));
#line 26
  scm_make_gsubr(s_execlp, 0, 0, 1, (SCM (*)())(& scm_execlp));
#line 27
  scm_make_gsubr(s_fork, 0, 0, 0, & scm_fork);
#line 28
  scm_make_gsubr(s_uname, 0, 0, 0, & scm_uname);
#line 29
  scm_make_gsubr(s_environ, 0, 1, 0, (SCM (*)())(& scm_environ));
#line 30
  scm_make_gsubr(s_tmpnam, 0, 0, 0, & scm_tmpnam);
#line 31
  scm_make_gsubr(s_open_pipe, 2, 0, 0, (SCM (*)())(& scm_open_pipe));
#line 32
  scm_make_gsubr(s_open_input_pipe, 1, 0, 0, (SCM (*)())(& scm_open_input_pipe));
#line 33
  scm_make_gsubr(s_open_output_pipe, 1, 0, 0, (SCM (*)())(& scm_open_output_pipe));
#line 34
  scm_make_gsubr(s_utime, 1, 2, 0, (SCM (*)())(& scm_utime));
#line 35
  scm_make_gsubr(s_access, 2, 0, 0, (SCM (*)())(& scm_access));
#line 36
  scm_make_gsubr(s_getpid, 0, 0, 0, & scm_getpid);
#line 37
  scm_make_gsubr(s_putenv, 1, 0, 0, (SCM (*)())(& scm_putenv));
#line 38
  scm_make_gsubr(s_read_line, 0, 2, 0, (SCM (*)())(& scm_read_line));
#line 39
  scm_make_gsubr(s_read_line_x, 1, 1, 0, (SCM (*)())(& scm_read_line_x));
#line 40
  scm_make_gsubr(s_write_line, 1, 1, 0, (SCM (*)())(& scm_write_line));
#line 41
  scm_make_gsubr(s_setlocale, 1, 1, 0, (SCM (*)())(& scm_setlocale));
#line 42
  scm_make_gsubr(s_strftime, 2, 0, 0, (SCM (*)())(& scm_strftime));
#line 43
  scm_make_gsubr(s_strptime, 2, 0, 0, (SCM (*)())(& scm_strptime));
#line 44
  scm_make_gsubr(s_mknod, 3, 0, 0, (SCM (*)())(& scm_mknod));
#line 45
  scm_make_gsubr(s_nice, 1, 0, 0, (SCM (*)())(& scm_nice));
#line 46
  scm_make_gsubr(s_sync, 0, 0, 0, & scm_sync);
  }
#line 1461 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/posix.c"
  return;
}
}
#line 83 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.h"
struct scm_port_table **scm_port_table  ;
#line 84
int scm_port_table_size ;
#line 157 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.h"
scm_ptobfuns *scm_ptobs  ;
#line 158 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.h"
size_t scm_numptob  ;
#line 159
int scm_port_table_room ;
#line 164
long scm_newptob(scm_ptobfuns *ptob ) ;
#line 166
SCM scm_char_ready_p(SCM port ) ;
#line 167
SCM scm_ungetc_char_ready_p(SCM port ) ;
#line 168
SCM scm_current_input_port(void) ;
#line 169
SCM scm_current_output_port(void) ;
#line 170
SCM scm_current_error_port(void) ;
#line 171
SCM scm_set_current_input_port(SCM port ) ;
#line 172
SCM scm_set_current_output_port(SCM port ) ;
#line 173
SCM scm_set_current_error_port(SCM port ) ;
#line 175
void scm_remove_from_port_table(SCM port ) ;
#line 178
int scm_revealed_count(SCM port ) ;
#line 179
SCM scm_port_revealed(SCM port ) ;
#line 180
SCM scm_set_port_revealed_x(SCM port , SCM rcount ) ;
#line 182
SCM scm_close_all_ports_except(SCM ports ) ;
#line 183
SCM scm_input_port_p(SCM x ) ;
#line 184
SCM scm_output_port_p(SCM x ) ;
#line 185
SCM scm_eof_object_p(SCM x ) ;
#line 186
SCM scm_force_output(SCM port ) ;
#line 187
SCM scm_read_char(SCM port ) ;
#line 188
SCM scm_peek_char(SCM port ) ;
#line 189
SCM scm_unread_char(SCM cobj , SCM port ) ;
#line 190
SCM scm_port_line(SCM port ) ;
#line 191
SCM scm_port_column(SCM port ) ;
#line 192
SCM scm_port_filename(SCM port ) ;
#line 193
SCM scm_set_port_filename_x(SCM port , SCM filename ) ;
#line 195
void scm_ports_prehistory(void) ;
#line 196
SCM scm_void_port(char *mode_str ) ;
#line 197
SCM scm_sys_make_void_port(SCM mode ) ;
#line 198
void scm_init_ports(void) ;
#line 98 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.h"
int scm_input_waiting_p(FILE *f , char *caller ) ;
#line 53 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/fports.h"
scm_ptobfuns scm_fptob ;
#line 54
scm_ptobfuns scm_pipob ;
#line 795 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 78 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
SCM scm_markstream(SCM ptr ) 
{ 
  int openp ;

  {
#line 83
  if (128 & (int )((scm_cell *)ptr)->car) {
#line 84
    return ((long )(16 << 9) + 372L);
  }
#line 85
  openp = (int )(((scm_cell *)ptr)->car & (1L << 16));
#line 86
  ((scm_cell *)ptr)->car |= 128L;
#line 87
  if (openp) {
#line 88
    return (((struct scm_port_table *)((scm_cell *)ptr)->cdr)->stream);
  } else {
#line 90
    return ((long )(16 << 9) + 372L);
  }
}
}
#line 95 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
long scm_newptob(scm_ptobfuns *ptob ) 
{ 
  char *tmp ;
  int *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *__cil_tmp6 ;

  {
#line 100
  if (255UL <= scm_numptob) {
#line 101
    goto ptoberr;
  }
#line 102
  scm_ints_disabled = 1;
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 103
    tmp___0 = __errno_location();
#line 103
    *tmp___0 = 0;
#line 103
    tmp___1 = realloc((void *)((char *)scm_ptobs), (1UL + scm_numptob) * sizeof(scm_ptobfuns ));
#line 103
    tmp = (char *)tmp___1;
#line 103
    tmp___2 = __errno_location();
    }
#line 103
    if (! (4 == *tmp___2)) {
#line 103
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  if (tmp) {
#line 106
    scm_ptobs = (scm_ptobfuns *)tmp;
#line 107
    (scm_ptobs + scm_numptob)->mark = ptob->mark;
#line 108
    (scm_ptobs + scm_numptob)->free = ptob->free;
#line 109
    (scm_ptobs + scm_numptob)->print = ptob->print;
#line 110
    (scm_ptobs + scm_numptob)->equalp = ptob->equalp;
#line 111
    (scm_ptobs + scm_numptob)->fputc = ptob->fputc;
#line 112
    (scm_ptobs + scm_numptob)->fputs = ptob->fputs;
#line 113
    (scm_ptobs + scm_numptob)->fwrite = ptob->fwrite;
#line 114
    (scm_ptobs + scm_numptob)->fflush = ptob->fflush;
#line 115
    (scm_ptobs + scm_numptob)->fgetc = ptob->fgetc;
#line 116
    (scm_ptobs + scm_numptob)->fclose = ptob->fclose;
#line 117
    scm_numptob ++;
  }
#line 119
  scm_ints_disabled = 0;
#line 119
  scm_async_clock --;
#line 119
  if (0U == scm_async_clock) {
    {
#line 119
    scm_async_click();
    }
  }
#line 120
  if (! tmp) {
    ptoberr: 
    {
#line 121
    scm_wta(((long )scm_numptob << 2) + 2L, (char *)11, (char *)"newptob");
    }
  }
#line 122
  return ((long )(125UL + (scm_numptob - 1UL) * 256UL));
}
}
#line 128 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
void scm_fflush(SCM port ) 
{ 
  size_t i ;

  {
  {
#line 132
  i = (size_t )(255L & (((scm_cell *)port)->car >> 8));
#line 133
  (*((scm_ptobs + i)->fflush))(((struct scm_port_table *)((scm_cell *)port)->cdr)->stream);
  }
#line 134
  return;
}
}
#line 138 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
static char s_char_ready_p[12]  = 
#line 138
  {      (char )'c',      (char )'h',      (char )'a',      (char )'r', 
        (char )'-',      (char )'r',      (char )'e',      (char )'a', 
        (char )'d',      (char )'y',      (char )'?',      (char )'\000'};
#line 140 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
SCM scm_char_ready_p(SCM port ) 
{ 
  long tmp___0 ;
  int tmp___1 ;

  {
#line 144
  if ((long )(18 << 9) + 372L == port) {
#line 145
    port = scm_root->cur_inp;
  } else
#line 147
  if (! (6 & (int )port)) {
#line 147
    if (! ((((127L | (1L << 16)) | (2L << 16)) & ((scm_cell *)port)->car) == ((125L | (1L << 16)) | (2L << 16)))) {
      {
#line 147
      scm_wta(port, (char *)1, s_char_ready_p);
      }
    }
  } else {
    {
#line 147
    scm_wta(port, (char *)1, s_char_ready_p);
    }
  }
#line 148
  if (((scm_cell *)port)->car & (32L << 16)) {
#line 149
    return ((long )(17 << 9) + 372L);
  } else
#line 148
  if (! ((65279 & (int )((scm_cell *)port)->car) == 125)) {
#line 149
    return ((long )(17 << 9) + 372L);
  }
  {
#line 150
  tmp___1 = scm_input_waiting_p((FILE *)((struct scm_port_table *)((scm_cell *)port)->cdr)->stream,
                                s_char_ready_p);
  }
#line 150
  if (tmp___1) {
#line 150
    tmp___0 = (long )(17 << 9) + 372L;
  } else {
#line 150
    tmp___0 = (long )(16 << 9) + 372L;
  }
#line 150
  return (tmp___0);
}
}
#line 158 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
static char s_ungetc_char_ready_p[19]  = 
#line 158
  {      (char )'u',      (char )'n',      (char )'g',      (char )'e', 
        (char )'t',      (char )'c',      (char )'-',      (char )'c', 
        (char )'h',      (char )'a',      (char )'r',      (char )'-', 
        (char )'r',      (char )'e',      (char )'a',      (char )'d', 
        (char )'y',      (char )'?',      (char )'\000'};
#line 160 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
SCM scm_ungetc_char_ready_p(SCM port ) 
{ 
  long tmp ;

  {
#line 164
  if ((long )(18 << 9) + 372L == port) {
#line 165
    port = scm_root->cur_inp;
  } else
#line 167
  if (! (6 & (int )port)) {
#line 167
    if (! ((((127L | (1L << 16)) | (2L << 16)) & ((scm_cell *)port)->car) == ((125L | (1L << 16)) | (2L << 16)))) {
      {
#line 167
      scm_wta(port, (char *)1, s_ungetc_char_ready_p);
      }
    }
  } else {
    {
#line 167
    scm_wta(port, (char *)1, s_ungetc_char_ready_p);
    }
  }
#line 168
  if (((scm_cell *)port)->car & (32L << 16)) {
#line 168
    tmp = (long )(17 << 9) + 372L;
  } else {
#line 168
    tmp = (long )(16 << 9) + 372L;
  }
#line 168
  return (tmp);
}
}
#line 179 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
static char s_current_input_port[19]  = 
#line 179
  {      (char )'c',      (char )'u',      (char )'r',      (char )'r', 
        (char )'e',      (char )'n',      (char )'t',      (char )'-', 
        (char )'i',      (char )'n',      (char )'p',      (char )'u', 
        (char )'t',      (char )'-',      (char )'p',      (char )'o', 
        (char )'r',      (char )'t',      (char )'\000'};
#line 181 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
SCM scm_current_input_port(void) 
{ 


  {
#line 184
  return (scm_root->cur_inp);
}
}
#line 187 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
static char s_current_output_port[20]  = 
#line 187
  {      (char )'c',      (char )'u',      (char )'r',      (char )'r', 
        (char )'e',      (char )'n',      (char )'t',      (char )'-', 
        (char )'o',      (char )'u',      (char )'t',      (char )'p', 
        (char )'u',      (char )'t',      (char )'-',      (char )'p', 
        (char )'o',      (char )'r',      (char )'t',      (char )'\000'};
#line 189 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
SCM scm_current_output_port(void) 
{ 


  {
#line 192
  return (scm_root->cur_outp);
}
}
#line 195 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
static char s_current_error_port[19]  = 
#line 195
  {      (char )'c',      (char )'u',      (char )'r',      (char )'r', 
        (char )'e',      (char )'n',      (char )'t',      (char )'-', 
        (char )'e',      (char )'r',      (char )'r',      (char )'o', 
        (char )'r',      (char )'-',      (char )'p',      (char )'o', 
        (char )'r',      (char )'t',      (char )'\000'};
#line 197 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
SCM scm_current_error_port(void) 
{ 


  {
#line 200
  return (scm_root->cur_errp);
}
}
#line 203 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
static char s_set_current_input_port[23]  = 
#line 203
  {      (char )'s',      (char )'e',      (char )'t',      (char )'-', 
        (char )'c',      (char )'u',      (char )'r',      (char )'r', 
        (char )'e',      (char )'n',      (char )'t',      (char )'-', 
        (char )'i',      (char )'n',      (char )'p',      (char )'u', 
        (char )'t',      (char )'-',      (char )'p',      (char )'o', 
        (char )'r',      (char )'t',      (char )'\000'};
#line 205 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
SCM scm_set_current_input_port(SCM port ) 
{ 
  SCM oinp ;

  {
#line 209
  oinp = scm_root->cur_inp;
#line 210
  if (! (6 & (int )port)) {
#line 210
    if (! ((((127L | (1L << 16)) | (2L << 16)) & ((scm_cell *)port)->car) == ((125L | (1L << 16)) | (2L << 16)))) {
      {
#line 210
      scm_wta(port, (char *)1, s_set_current_input_port);
      }
    }
  } else {
    {
#line 210
    scm_wta(port, (char *)1, s_set_current_input_port);
    }
  }
#line 211
  scm_root->cur_inp = port;
#line 212
  return (oinp);
}
}
#line 216 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
static char s_set_current_output_port[24]  = 
#line 216
  {      (char )'s',      (char )'e',      (char )'t',      (char )'-', 
        (char )'c',      (char )'u',      (char )'r',      (char )'r', 
        (char )'e',      (char )'n',      (char )'t',      (char )'-', 
        (char )'o',      (char )'u',      (char )'t',      (char )'p', 
        (char )'u',      (char )'t',      (char )'-',      (char )'p', 
        (char )'o',      (char )'r',      (char )'t',      (char )'\000'};
#line 218 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
SCM scm_set_current_output_port(SCM port ) 
{ 
  SCM ooutp ;

  {
#line 222
  ooutp = scm_root->cur_outp;
#line 223
  if (! (6 & (int )port)) {
#line 223
    if (! ((((127L | (1L << 16)) | (4L << 16)) & ((scm_cell *)port)->car) == ((125L | (1L << 16)) | (4L << 16)))) {
      {
#line 223
      scm_wta(port, (char *)1, s_set_current_output_port);
      }
    }
  } else {
    {
#line 223
    scm_wta(port, (char *)1, s_set_current_output_port);
    }
  }
#line 224
  scm_root->cur_outp = port;
#line 225
  return (ooutp);
}
}
#line 229 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
static char s_set_current_error_port[23]  = 
#line 229
  {      (char )'s',      (char )'e',      (char )'t',      (char )'-', 
        (char )'c',      (char )'u',      (char )'r',      (char )'r', 
        (char )'e',      (char )'n',      (char )'t',      (char )'-', 
        (char )'e',      (char )'r',      (char )'r',      (char )'o', 
        (char )'r',      (char )'-',      (char )'p',      (char )'o', 
        (char )'r',      (char )'t',      (char )'\000'};
#line 231 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
SCM scm_set_current_error_port(SCM port ) 
{ 
  SCM oerrp ;

  {
#line 235
  oerrp = scm_root->cur_errp;
#line 236
  if (! (6 & (int )port)) {
#line 236
    if (! ((((127L | (1L << 16)) | (4L << 16)) & ((scm_cell *)port)->car) == ((125L | (1L << 16)) | (4L << 16)))) {
      {
#line 236
      scm_wta(port, (char *)1, s_set_current_error_port);
      }
    }
  } else {
    {
#line 236
    scm_wta(port, (char *)1, s_set_current_error_port);
    }
  }
#line 237
  scm_root->cur_errp = port;
#line 238
  return (oerrp);
}
}
#line 250 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
int scm_port_table_size  =    0;
#line 251 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
int scm_port_table_room  =    20;
#line 255 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
struct scm_port_table *scm_add_to_port_table(SCM port ) 
{ 
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp5 ;

  {
#line 259
  if (scm_port_table_size == scm_port_table_room) {
    {
#line 261
    tmp = realloc((void *)((char *)scm_port_table), (size_t )((long )((sizeof(struct scm_port_table ) * (unsigned long )scm_port_table_room) * 2UL)));
#line 261
    scm_port_table = (struct scm_port_table **)tmp;
#line 266
    scm_port_table_room *= 2;
    }
  }
  {
#line 268
  tmp___0 = scm_must_malloc((long )sizeof(struct scm_port_table ), (char *)"system port table");
#line 268
  *(scm_port_table + scm_port_table_size) = (struct scm_port_table *)tmp___0;
#line 271
  (*(scm_port_table + scm_port_table_size))->port = port;
#line 272
  (*(scm_port_table + scm_port_table_size))->revealed = 0;
#line 273
  (*(scm_port_table + scm_port_table_size))->stream = (SCM )0;
#line 274
  (*(scm_port_table + scm_port_table_size))->file_name = (long )(16 << 9) + 372L;
#line 275
  (*(scm_port_table + scm_port_table_size))->line_number = 1;
#line 276
  (*(scm_port_table + scm_port_table_size))->column_number = 0;
#line 277
  (*(scm_port_table + scm_port_table_size))->representation = (enum scm_port_representation_type )0;
#line 278
  tmp___1 = scm_port_table_size;
#line 278
  scm_port_table_size ++;
  }
#line 278
  return (*(scm_port_table + tmp___1));
}
}
#line 283 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
void scm_remove_from_port_table(SCM port ) 
{ 
  int i ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 287
  i = 0;
  {
#line 288
  while (1) {
    while_continue: /* CIL Label */ ;
#line 288
    if (! ((*(scm_port_table + i))->port != port)) {
#line 288
      goto while_break;
    }
#line 290
    i ++;
#line 292
    if (i >= scm_port_table_size) {
      {
#line 293
      scm_wta(port, (char *)"Port not in table", (char *)"scm_remove_from_port_table");
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 295
  scm_must_free((char *)*(scm_port_table + i));
#line 296
  scm_mallocated -= sizeof(*(*(scm_port_table + i)));
#line 297
  *(scm_port_table + i) = *(scm_port_table + (scm_port_table_size - 1));
#line 298
  ((scm_cell *)port)->cdr = (SCM )0;
#line 299
  scm_port_table_size --;
  }
#line 300
  return;
}
}
#line 335 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
int scm_revealed_count(SCM port ) 
{ 


  {
#line 339
  return (((struct scm_port_table *)((scm_cell *)port)->cdr)->revealed);
}
}
#line 346 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
static char s_port_revealed[14]  = 
#line 346
  {      (char )'p',      (char )'o',      (char )'r',      (char )'t', 
        (char )'-',      (char )'r',      (char )'e',      (char )'v', 
        (char )'e',      (char )'a',      (char )'l',      (char )'e', 
        (char )'d',      (char )'\000'};
#line 348 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
SCM scm_port_revealed(SCM port ) 
{ 
  int tmp ;

  {
#line 352
  if (! (6 & (int )port)) {
#line 352
    if (! ((127 & (int )((scm_cell *)port)->car) == 125)) {
      {
#line 352
      scm_wta(port, (char *)1, s_port_revealed);
      }
    }
  } else {
    {
#line 352
    scm_wta(port, (char *)1, s_port_revealed);
    }
  }
  {
#line 353
  tmp = scm_revealed_count(port);
  }
#line 353
  return ((long )(tmp << 2) + 2L);
}
}
#line 357 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
static char s_set_port_revealed_x[19]  = 
#line 357
  {      (char )'s',      (char )'e',      (char )'t',      (char )'-', 
        (char )'p',      (char )'o',      (char )'r',      (char )'t', 
        (char )'-',      (char )'r',      (char )'e',      (char )'v', 
        (char )'e',      (char )'a',      (char )'l',      (char )'e', 
        (char )'d',      (char )'!',      (char )'\000'};
#line 359 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
SCM scm_set_port_revealed_x(SCM port , SCM rcount ) 
{ 


  {
#line 364
  if (! (6 & (int )port)) {
#line 364
    if (! ((127 & (int )((scm_cell *)port)->car) == 125)) {
      {
#line 364
      scm_wta(port, (char *)1, s_set_port_revealed_x);
      }
    }
  } else {
    {
#line 364
    scm_wta(port, (char *)1, s_set_port_revealed_x);
    }
  }
#line 365
  if (! (2 & (int )rcount)) {
    {
#line 365
    scm_wta(rcount, (char *)2, s_set_port_revealed_x);
    }
  }
#line 366
  scm_ints_disabled = 1;
#line 367
  ((struct scm_port_table *)((scm_cell *)port)->cdr)->revealed = (int )(rcount >> 2);
#line 368
  scm_ints_disabled = 0;
#line 368
  scm_async_clock --;
#line 368
  if (0U == scm_async_clock) {
    {
#line 368
    scm_async_click();
    }
  }
#line 369
  return ((long )(21 << 9) + 372L);
}
}
#line 375 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
static char s_close_port[11]  = 
#line 375
  {      (char )'c',      (char )'l',      (char )'o',      (char )'s', 
        (char )'e',      (char )'-',      (char )'p',      (char )'o', 
        (char )'r',      (char )'t',      (char )'\000'};
#line 377 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
SCM scm_close_port(SCM port ) 
{ 
  size_t i ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 382
  if (! (6 & (int )port)) {
#line 382
    if (! ((127 & (int )((scm_cell *)port)->car) == 125)) {
      {
#line 382
      scm_wta(port, (char *)1, s_close_port);
      }
    }
  } else {
    {
#line 382
    scm_wta(port, (char *)1, s_close_port);
    }
  }
#line 383
  if (! ((1L << 16) & ((scm_cell *)port)->car)) {
#line 384
    return ((long )(21 << 9) + 372L);
  }
#line 385
  i = (size_t )(255L & (((scm_cell *)port)->car >> 8));
#line 386
  scm_ints_disabled = 1;
#line 387
  if ((scm_ptobs + i)->fclose) {
    {
#line 388
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 388
      tmp = __errno_location();
#line 388
      *tmp = 0;
#line 388
      (*((scm_ptobs + i)->fclose))(((struct scm_port_table *)((scm_cell *)port)->cdr)->stream);
#line 388
      tmp___0 = __errno_location();
      }
#line 388
      if (! (4 == *tmp___0)) {
#line 388
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 389
  scm_remove_from_port_table(port);
#line 390
  ((scm_cell *)port)->car &= ~ (1L << 16);
#line 391
  scm_ints_disabled = 0;
#line 391
  scm_async_clock --;
  }
#line 391
  if (0U == scm_async_clock) {
    {
#line 391
    scm_async_click();
    }
  }
#line 392
  return ((long )(21 << 9) + 372L);
}
}
#line 395 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
static char s_close_all_ports_except[23]  = 
#line 395
  {      (char )'c',      (char )'l',      (char )'o',      (char )'s', 
        (char )'e',      (char )'-',      (char )'a',      (char )'l', 
        (char )'l',      (char )'-',      (char )'p',      (char )'o', 
        (char )'r',      (char )'t',      (char )'s',      (char )'-', 
        (char )'e',      (char )'x',      (char )'c',      (char )'e', 
        (char )'p',      (char )'t',      (char )'\000'};
#line 397 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
SCM scm_close_all_ports_except(SCM ports ) 
{ 
  int i ;
  SCM thisport ;
  int found ;
  SCM ports_ptr ;
  SCM port ;

  {
#line 401
  i = 0;
#line 402
  if (! (6 & (int )ports)) {
#line 402
    if (! (! (1 & (int )((scm_cell *)ports)->car))) {
      {
#line 402
      scm_wta(ports, (char *)1, s_close_all_ports_except);
      }
    }
  } else {
    {
#line 402
    scm_wta(ports, (char *)1, s_close_all_ports_except);
    }
  }
#line 403
  scm_ints_disabled = 1;
  {
#line 404
  while (1) {
    while_continue: /* CIL Label */ ;
#line 404
    if (! (i < scm_port_table_size)) {
#line 404
      goto while_break;
    }
#line 406
    thisport = (*(scm_port_table + i))->port;
#line 407
    found = 0;
#line 408
    ports_ptr = ports;
    {
#line 410
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 410
      if (! ((long )(20 << 9) + 372L != ports_ptr)) {
#line 410
        goto while_break___0;
      }
#line 412
      port = ((scm_cell *)ports_ptr)->car;
#line 413
      if (i == 0) {
#line 414
        if (! (6 & (int )port)) {
#line 414
          if (! (((127L | (1L << 16)) & ((scm_cell *)port)->car) == (125L | (1L << 16)))) {
            {
#line 414
            scm_wta(port, (char *)1, s_close_all_ports_except);
            }
          }
        } else {
          {
#line 414
          scm_wta(port, (char *)1, s_close_all_ports_except);
          }
        }
      }
#line 415
      if (port == thisport) {
#line 416
        found = 1;
      }
#line 417
      ports_ptr = ((scm_cell *)ports_ptr)->cdr;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 419
    if (found) {
#line 420
      i ++;
    } else {
      {
#line 423
      scm_close_port(thisport);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 425
  scm_ints_disabled = 0;
#line 425
  scm_async_clock --;
#line 425
  if (0U == scm_async_clock) {
    {
#line 425
    scm_async_click();
    }
  }
#line 426
  return ((long )(21 << 9) + 372L);
}
}
#line 429 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
static char s_input_port_p[12]  = 
#line 429
  {      (char )'i',      (char )'n',      (char )'p',      (char )'u', 
        (char )'t',      (char )'-',      (char )'p',      (char )'o', 
        (char )'r',      (char )'t',      (char )'?',      (char )'\000'};
#line 431 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
SCM scm_input_port_p(SCM x ) 
{ 
  long tmp ;

  {
#line 435
  if (6 & (int )x) {
#line 436
    return ((long )(16 << 9) + 372L);
  }
#line 437
  if (((127L | (2L << 16)) & ((scm_cell *)x)->car) == (125L | (2L << 16))) {
#line 437
    tmp = (long )(17 << 9) + 372L;
  } else {
#line 437
    tmp = (long )(16 << 9) + 372L;
  }
#line 437
  return (tmp);
}
}
#line 440 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
static char s_output_port_p[13]  = 
#line 440
  {      (char )'o',      (char )'u',      (char )'t',      (char )'p', 
        (char )'u',      (char )'t',      (char )'-',      (char )'p', 
        (char )'o',      (char )'r',      (char )'t',      (char )'?', 
        (char )'\000'};
#line 442 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
SCM scm_output_port_p(SCM x ) 
{ 
  long tmp ;

  {
#line 446
  if (6 & (int )x) {
#line 447
    return ((long )(16 << 9) + 372L);
  }
#line 448
  if (((127L | (4L << 16)) & ((scm_cell *)x)->car) == (125L | (4L << 16))) {
#line 448
    tmp = (long )(17 << 9) + 372L;
  } else {
#line 448
    tmp = (long )(16 << 9) + 372L;
  }
#line 448
  return (tmp);
}
}
#line 452 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
static char s_eof_object_p[12]  = 
#line 452
  {      (char )'e',      (char )'o',      (char )'f',      (char )'-', 
        (char )'o',      (char )'b',      (char )'j',      (char )'e', 
        (char )'c',      (char )'t',      (char )'?',      (char )'\000'};
#line 454 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
SCM scm_eof_object_p(SCM x ) 
{ 
  long tmp ;

  {
#line 458
  if ((long )(19 << 9) + 372L == x) {
#line 458
    tmp = (long )(17 << 9) + 372L;
  } else {
#line 458
    tmp = (long )(16 << 9) + 372L;
  }
#line 458
  return (tmp);
}
}
#line 461 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
static char s_force_output[13]  = 
#line 461
  {      (char )'f',      (char )'o',      (char )'r',      (char )'c', 
        (char )'e',      (char )'-',      (char )'o',      (char )'u', 
        (char )'t',      (char )'p',      (char )'u',      (char )'t', 
        (char )'\000'};
#line 463 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
SCM scm_force_output(SCM port ) 
{ 
  size_t i ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 467
  if ((long )(18 << 9) + 372L == port) {
#line 468
    port = scm_root->cur_outp;
  } else
#line 470
  if (! (6 & (int )port)) {
#line 470
    if (! ((((127L | (1L << 16)) | (4L << 16)) & ((scm_cell *)port)->car) == ((125L | (1L << 16)) | (4L << 16)))) {
      {
#line 470
      scm_wta(port, (char *)1, s_force_output);
      }
    }
  } else {
    {
#line 470
    scm_wta(port, (char *)1, s_force_output);
    }
  }
#line 472
  i = (size_t )(255L & (((scm_cell *)port)->car >> 8));
  {
#line 473
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 473
    tmp = __errno_location();
#line 473
    *tmp = 0;
#line 473
    (*((scm_ptobs + i)->fflush))(((struct scm_port_table *)((scm_cell *)port)->cdr)->stream);
#line 473
    tmp___0 = __errno_location();
    }
#line 473
    if (! (4 == *tmp___0)) {
#line 473
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 474
  return ((long )(21 << 9) + 372L);
}
}
#line 479 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
static char s_read_char[10]  = 
#line 479
  {      (char )'r',      (char )'e',      (char )'a',      (char )'d', 
        (char )'-',      (char )'c',      (char )'h',      (char )'a', 
        (char )'r',      (char )'\000'};
#line 481 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
SCM scm_read_char(SCM port ) 
{ 
  int c ;

  {
#line 486
  if ((long )(18 << 9) + 372L == port) {
#line 487
    port = scm_root->cur_inp;
  } else
#line 489
  if (! (6 & (int )port)) {
#line 489
    if (! ((((127L | (1L << 16)) | (2L << 16)) & ((scm_cell *)port)->car) == ((125L | (1L << 16)) | (2L << 16)))) {
      {
#line 489
      scm_wta(port, (char *)1, s_read_char);
      }
    }
  } else {
    {
#line 489
    scm_wta(port, (char *)1, s_read_char);
    }
  }
  {
#line 490
  c = scm_gen_getc(port);
  }
#line 491
  if (-1 == c) {
#line 492
    return ((long )(19 << 9) + 372L);
  }
#line 493
  return ((SCM )((c << 8) + 244));
}
}
#line 497 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
static char s_peek_char[10]  = 
#line 497
  {      (char )'p',      (char )'e',      (char )'e',      (char )'k', 
        (char )'-',      (char )'c',      (char )'h',      (char )'a', 
        (char )'r',      (char )'\000'};
#line 499 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
SCM scm_peek_char(SCM port ) 
{ 
  int c ;

  {
#line 504
  if ((long )(18 << 9) + 372L == port) {
#line 505
    port = scm_root->cur_inp;
  } else
#line 507
  if (! (6 & (int )port)) {
#line 507
    if (! ((((127L | (1L << 16)) | (2L << 16)) & ((scm_cell *)port)->car) == ((125L | (1L << 16)) | (2L << 16)))) {
      {
#line 507
      scm_wta(port, (char *)1, s_peek_char);
      }
    }
  } else {
    {
#line 507
    scm_wta(port, (char *)1, s_peek_char);
    }
  }
  {
#line 508
  c = scm_gen_getc(port);
  }
#line 509
  if (-1 == c) {
#line 510
    return ((long )(19 << 9) + 372L);
  }
  {
#line 511
  scm_gen_ungetc(c, port);
  }
#line 512
  return ((SCM )((c << 8) + 244));
}
}
#line 515 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
static char s_unread_char[12]  = 
#line 515
  {      (char )'u',      (char )'n',      (char )'r',      (char )'e', 
        (char )'a',      (char )'d',      (char )'-',      (char )'c', 
        (char )'h',      (char )'a',      (char )'r',      (char )'\000'};
#line 517 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
SCM scm_unread_char(SCM cobj , SCM port ) 
{ 
  int c ;

  {
#line 524
  if (! (((int )cobj & 255) == 244)) {
    {
#line 524
    scm_wta(cobj, (char *)1, s_unread_char);
    }
  }
#line 526
  if ((long )(18 << 9) + 372L == port) {
#line 527
    port = scm_root->cur_inp;
  } else
#line 529
  if (! (6 & (int )port)) {
#line 529
    if (! ((((127L | (1L << 16)) | (2L << 16)) & ((scm_cell *)port)->car) == ((125L | (1L << 16)) | (2L << 16)))) {
      {
#line 529
      scm_wta(port, (char *)2, s_unread_char);
      }
    }
  } else {
    {
#line 529
    scm_wta(port, (char *)2, s_unread_char);
    }
  }
  {
#line 532
  c = (int )((unsigned int )(cobj >> 8));
#line 534
  scm_gen_ungetc(c, port);
  }
#line 535
  return (cobj);
}
}
#line 540 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
static char s_port_line[10]  = 
#line 540
  {      (char )'p',      (char )'o',      (char )'r',      (char )'t', 
        (char )'-',      (char )'l',      (char )'i',      (char )'n', 
        (char )'e',      (char )'\000'};
#line 542 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
SCM scm_port_line(SCM port ) 
{ 
  SCM p ;

  {
#line 547
  if (port == (long )(18 << 9) + 372L) {
#line 547
    p = scm_root->cur_inp;
  } else {
#line 547
    p = port;
  }
#line 550
  if (! (6 & (int )p)) {
#line 550
    if ((127 & (int )((scm_cell *)p)->car) == 125) {
#line 553
      return ((long )(((struct scm_port_table *)((scm_cell *)p)->cdr)->line_number << 2) + 2L);
    } else {
#line 551
      return ((long )(16 << 9) + 372L);
    }
  } else {
#line 551
    return ((long )(16 << 9) + 372L);
  }
}
}
#line 556 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
static char s_set_port_line_x[15]  = 
#line 556
  {      (char )'s',      (char )'e',      (char )'t',      (char )'-', 
        (char )'p',      (char )'o',      (char )'r',      (char )'t', 
        (char )'-',      (char )'l',      (char )'i',      (char )'n', 
        (char )'e',      (char )'!',      (char )'\000'};
#line 558 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
SCM scm_set_port_line_x(SCM port , SCM line ) 
{ 
  int tmp ;

  {
#line 563
  if (line == (long )(18 << 9) + 372L) {
#line 565
    line = port;
#line 566
    port = scm_root->cur_inp;
  } else
#line 569
  if (! (6 & (int )port)) {
#line 569
    if ((127 & (int )((scm_cell *)port)->car) == 125) {
#line 569
      if (! ((1L << 16) & ((scm_cell *)port)->car)) {
        {
#line 569
        scm_wta(port, (char *)1, s_set_port_line_x);
        }
      }
    } else {
      {
#line 569
      scm_wta(port, (char *)1, s_set_port_line_x);
      }
    }
  } else {
    {
#line 569
    scm_wta(port, (char *)1, s_set_port_line_x);
    }
  }
#line 573
  tmp = (int )(line >> 2);
#line 573
  ((struct scm_port_table *)((scm_cell *)port)->cdr)->line_number = tmp;
#line 573
  return ((SCM )tmp);
}
}
#line 576 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
static char s_port_column[12]  = 
#line 576
  {      (char )'p',      (char )'o',      (char )'r',      (char )'t', 
        (char )'-',      (char )'c',      (char )'o',      (char )'l', 
        (char )'u',      (char )'m',      (char )'n',      (char )'\000'};
#line 578 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
SCM scm_port_column(SCM port ) 
{ 
  SCM p ;

  {
#line 583
  if (port == (long )(18 << 9) + 372L) {
#line 583
    p = scm_root->cur_inp;
  } else {
#line 583
    p = port;
  }
#line 586
  if (! (6 & (int )p)) {
#line 586
    if ((127 & (int )((scm_cell *)p)->car) == 125) {
#line 589
      return ((long )(((struct scm_port_table *)((scm_cell *)p)->cdr)->column_number << 2) + 2L);
    } else {
#line 587
      return ((long )(16 << 9) + 372L);
    }
  } else {
#line 587
    return ((long )(16 << 9) + 372L);
  }
}
}
#line 592 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
static char s_set_port_column_x[17]  = 
#line 592
  {      (char )'s',      (char )'e',      (char )'t',      (char )'-', 
        (char )'p',      (char )'o',      (char )'r',      (char )'t', 
        (char )'-',      (char )'c',      (char )'o',      (char )'l', 
        (char )'u',      (char )'m',      (char )'n',      (char )'!', 
        (char )'\000'};
#line 594 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
SCM scm_set_port_column_x(SCM port , SCM column ) 
{ 
  int tmp ;

  {
#line 599
  if (column == (long )(18 << 9) + 372L) {
#line 601
    column = port;
#line 602
    port = scm_root->cur_inp;
  } else
#line 605
  if (! (6 & (int )port)) {
#line 605
    if ((127 & (int )((scm_cell *)port)->car) == 125) {
#line 605
      if (! ((1L << 16) & ((scm_cell *)port)->car)) {
        {
#line 605
        scm_wta(port, (char *)1, s_set_port_column_x);
        }
      }
    } else {
      {
#line 605
      scm_wta(port, (char *)1, s_set_port_column_x);
      }
    }
  } else {
    {
#line 605
    scm_wta(port, (char *)1, s_set_port_column_x);
    }
  }
#line 609
  tmp = (int )(column >> 2);
#line 609
  ((struct scm_port_table *)((scm_cell *)port)->cdr)->column_number = tmp;
#line 609
  return ((SCM )tmp);
}
}
#line 612 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
static char s_port_filename[14]  = 
#line 612
  {      (char )'p',      (char )'o',      (char )'r',      (char )'t', 
        (char )'-',      (char )'f',      (char )'i',      (char )'l', 
        (char )'e',      (char )'n',      (char )'a',      (char )'m', 
        (char )'e',      (char )'\000'};
#line 614 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
SCM scm_port_filename(SCM port ) 
{ 
  SCM p ;

  {
#line 619
  if (port == (long )(18 << 9) + 372L) {
#line 619
    p = scm_root->cur_inp;
  } else {
#line 619
    p = port;
  }
#line 622
  if (! (6 & (int )p)) {
#line 622
    if ((127 & (int )((scm_cell *)p)->car) == 125) {
#line 625
      return (((struct scm_port_table *)((scm_cell *)p)->cdr)->file_name);
    } else {
#line 623
      return ((long )(16 << 9) + 372L);
    }
  } else {
#line 623
    return ((long )(16 << 9) + 372L);
  }
}
}
#line 628 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
static char s_set_port_filename_x[19]  = 
#line 628
  {      (char )'s',      (char )'e',      (char )'t',      (char )'-', 
        (char )'p',      (char )'o',      (char )'r',      (char )'t', 
        (char )'-',      (char )'f',      (char )'i',      (char )'l', 
        (char )'e',      (char )'n',      (char )'a',      (char )'m', 
        (char )'e',      (char )'!',      (char )'\000'};
#line 630 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
SCM scm_set_port_filename_x(SCM port , SCM filename ) 
{ 
  SCM tmp ;

  {
#line 635
  if (filename == (long )(18 << 9) + 372L) {
#line 637
    filename = port;
#line 638
    port = scm_root->cur_inp;
  } else
#line 641
  if (! (6 & (int )port)) {
#line 641
    if ((127 & (int )((scm_cell *)port)->car) == 125) {
#line 641
      if (! ((1L << 16) & ((scm_cell *)port)->car)) {
        {
#line 641
        scm_wta(port, (char *)1, s_set_port_filename_x);
        }
      }
    } else {
      {
#line 641
      scm_wta(port, (char *)1, s_set_port_filename_x);
      }
    }
  } else {
    {
#line 641
    scm_wta(port, (char *)1, s_set_port_filename_x);
    }
  }
#line 645
  tmp = filename;
#line 645
  ((struct scm_port_table *)((scm_cell *)port)->cdr)->file_name = tmp;
#line 645
  return (tmp);
}
}
#line 653 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
void scm_prinport(SCM exp___0 , SCM port , char *type ) 
{ 
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 659
  scm_gen_puts((enum scm_string_representation_type )0, (char *)"#<", port);
  }
#line 660
  if (! ((1L << 16) & ((scm_cell *)exp___0)->car)) {
    {
#line 661
    scm_gen_puts((enum scm_string_representation_type )0, (char *)"closed: ", port);
    }
  } else {
#line 664
    if ((2L << 16) & ((scm_cell *)exp___0)->car) {
      {
#line 665
      scm_gen_puts((enum scm_string_representation_type )0, (char *)"input: ", port);
      }
    }
#line 666
    if ((4L << 16) & ((scm_cell *)exp___0)->car) {
      {
#line 667
      scm_gen_puts((enum scm_string_representation_type )0, (char *)"output: ", port);
      }
    }
  }
  {
#line 669
  scm_gen_puts((enum scm_string_representation_type )0, type, port);
#line 670
  scm_gen_putc(' ', port);
  }
#line 676
  if ((1L << 16) & ((scm_cell *)exp___0)->car) {
#line 676
    if (125L == (long )(65535 & (int )((scm_cell *)exp___0)->car)) {
      {
#line 676
      tmp___2 = fileno((FILE *)((struct scm_port_table *)((scm_cell *)exp___0)->cdr)->stream);
#line 676
      tmp___3 = isatty(tmp___2);
      }
#line 676
      if (tmp___3) {
        {
#line 677
        tmp = fileno((FILE *)((struct scm_port_table *)((scm_cell *)exp___0)->cdr)->stream);
#line 677
        tmp___0 = ttyname(tmp);
#line 677
        scm_gen_puts((enum scm_string_representation_type )0, tmp___0, port);
        }
      } else {
#line 676
        goto _L___0;
      }
    } else {
#line 676
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 684
  if (((65279L | (1L << 16)) & ((scm_cell *)exp___0)->car) == (125L | (1L << 16))) {
    {
#line 685
    tmp___1 = fileno((FILE *)((struct scm_port_table *)((scm_cell *)exp___0)->cdr)->stream);
#line 685
    scm_intprint((long )tmp___1, 10, port);
    }
  } else {
    {
#line 687
    scm_intprint(((scm_cell *)exp___0)->cdr, 16, port);
    }
  }
  {
#line 688
  scm_gen_putc('>', port);
  }
#line 689
  return;
}
}
#line 692 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
void scm_ports_prehistory(void) 
{ 
  void *tmp ;

  {
  {
#line 695
  scm_numptob = (size_t )0;
#line 696
  tmp = malloc(sizeof(scm_ptobfuns ));
#line 696
  scm_ptobs = (scm_ptobfuns *)tmp;
#line 701
  scm_newptob(& scm_fptob);
#line 702
  scm_newptob(& scm_pipob);
#line 703
  scm_newptob(& scm_stptob);
#line 704
  scm_newptob(& scm_sfptob);
  }
#line 705
  return;
}
}
#line 712 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
int scm_tc16_void_port  =    0;
#line 714 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
static int print_void_port(SCM exp___0 , SCM port , int writing ) 
{ 
  char *__cil_tmp4 ;

  {
  {
#line 720
  scm_prinport(exp___0, port, (char *)"void");
  }
#line 721
  return (1);
}
}
#line 724 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
static int putc_void_port(int c , SCM strm ) 
{ 


  {
#line 729
  return (0);
}
}
#line 732 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
static int puts_void_port(char *s___0 , SCM strm ) 
{ 


  {
#line 737
  return (0);
}
}
#line 740 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
static size_t write_void_port(void *ptr , int size , int nitems , SCM strm ) 
{ 
  int len ;

  {
#line 748
  len = size * nitems;
#line 749
  return ((size_t )len);
}
}
#line 753
static int flush_void_port(SCM strm ) ;
#line 755 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
static int flush_void_port(SCM strm ) 
{ 


  {
#line 759
  return (0);
}
}
#line 763
static int getc_void_port(SCM strm ) ;
#line 765 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
static int getc_void_port(SCM strm ) 
{ 


  {
#line 769
  return (-1);
}
}
#line 773
static int close_void_port(SCM strm ) ;
#line 775 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
static int close_void_port(SCM strm ) 
{ 


  {
#line 779
  return (0);
}
}
#line 784
static int noop0___1(SCM stream ) ;
#line 786 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
static int noop0___1(SCM stream ) 
{ 


  {
#line 790
  return (0);
}
}
#line 794 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
static struct scm_ptobfuns void_port_ptob  = 
#line 794
     {& scm_mark0, & noop0___1, (int (*)(SCM exp , SCM port , scm_print_state *pstate ))(& print_void_port),
    (SCM (*)(SCM  , SCM  ))0, & putc_void_port, & puts_void_port, (size_t (*)(char *ptr ,
                                                                              size_t size ,
                                                                              size_t nitems ,
                                                                              SCM stream ))(& write_void_port),
    & flush_void_port, & getc_void_port, & close_void_port};
#line 811 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
SCM scm_void_port(char *mode_str ) 
{ 
  int mode_bits ;
  SCM answer ;
  struct scm_port_table *pt ;
  long tmp ;

  {
#line 819
  if (6 & (int )scm_freelist) {
    {
#line 819
    answer = scm_gc_for_newcell();
    }
  } else {
#line 819
    answer = scm_freelist;
#line 819
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 819
    scm_cells_allocated ++;
  }
  {
#line 820
  scm_ints_disabled = 1;
#line 821
  tmp = scm_mode_bits(mode_str);
#line 821
  mode_bits = (int )tmp;
#line 822
  pt = scm_add_to_port_table(answer);
#line 823
  ((scm_cell *)answer)->car = (SCM )(scm_tc16_void_port | mode_bits);
#line 824
  ((scm_cell *)answer)->cdr = (SCM )pt;
#line 825
  ((struct scm_port_table *)((scm_cell *)answer)->cdr)->stream = (long )(16 << 9) + 372L;
#line 826
  scm_ints_disabled = 0;
#line 826
  scm_async_clock --;
  }
#line 826
  if (0U == scm_async_clock) {
    {
#line 826
    scm_async_click();
    }
  }
#line 827
  return (answer);
}
}
#line 831 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
static char s_sys_make_void_port[16]  = 
#line 831
  {      (char )'%',      (char )'m',      (char )'a',      (char )'k', 
        (char )'e',      (char )'-',      (char )'v',      (char )'o', 
        (char )'i',      (char )'d',      (char )'-',      (char )'p', 
        (char )'o',      (char )'r',      (char )'t',      (char )'\000'};
#line 833 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
SCM scm_sys_make_void_port(SCM mode ) 
{ 
  char *tmp ;
  SCM tmp___0 ;

  {
#line 837
  if (! (6 & (int )mode)) {
#line 837
    if (! ((125 & (int )((scm_cell *)mode)->car) == 21)) {
      {
#line 837
      scm_wta(mode, (char *)1, s_sys_make_void_port);
      }
    }
  } else {
    {
#line 837
    scm_wta(mode, (char *)1, s_sys_make_void_port);
    }
  }
#line 840
  if ((127 & (int )((scm_cell *)mode)->car) == 29) {
#line 840
    tmp = (char *)((scm_cell *)((scm_cell *)((scm_cell *)mode)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)mode)->cdr)->car >> 2);
  } else {
#line 840
    tmp = (char *)((scm_cell *)mode)->cdr;
  }
  {
#line 840
  tmp___0 = scm_void_port(tmp);
  }
#line 840
  return (tmp___0);
}
}
#line 848 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
void scm_init_ports(void) 
{ 
  long tmp ;

  {
  {
#line 851
  tmp = scm_newptob(& void_port_ptob);
#line 851
  scm_tc16_void_port = (int )tmp;
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.x"
  scm_make_gsubr(s_char_ready_p, 1, 0, 0, (SCM (*)())(& scm_char_ready_p));
#line 2
  scm_make_gsubr(s_ungetc_char_ready_p, 1, 0, 0, (SCM (*)())(& scm_ungetc_char_ready_p));
#line 3
  scm_make_gsubr(s_current_input_port, 0, 0, 0, & scm_current_input_port);
#line 4
  scm_make_gsubr(s_current_output_port, 0, 0, 0, & scm_current_output_port);
#line 5
  scm_make_gsubr(s_current_error_port, 0, 0, 0, & scm_current_error_port);
#line 6
  scm_make_gsubr(s_set_current_input_port, 1, 0, 0, (SCM (*)())(& scm_set_current_input_port));
#line 7
  scm_make_gsubr(s_set_current_output_port, 1, 0, 0, (SCM (*)())(& scm_set_current_output_port));
#line 8
  scm_make_gsubr(s_set_current_error_port, 1, 0, 0, (SCM (*)())(& scm_set_current_error_port));
#line 9
  scm_make_gsubr(s_port_revealed, 1, 0, 0, (SCM (*)())(& scm_port_revealed));
#line 10
  scm_make_gsubr(s_set_port_revealed_x, 2, 0, 0, (SCM (*)())(& scm_set_port_revealed_x));
#line 11
  scm_make_gsubr(s_close_port, 1, 0, 0, (SCM (*)())(& scm_close_port));
#line 12
  scm_make_gsubr(s_close_all_ports_except, 0, 0, 1, (SCM (*)())(& scm_close_all_ports_except));
#line 13
  scm_make_gsubr(s_input_port_p, 1, 0, 0, (SCM (*)())(& scm_input_port_p));
#line 14
  scm_make_gsubr(s_output_port_p, 1, 0, 0, (SCM (*)())(& scm_output_port_p));
#line 15
  scm_make_gsubr(s_eof_object_p, 1, 0, 0, (SCM (*)())(& scm_eof_object_p));
#line 16
  scm_make_gsubr(s_force_output, 0, 1, 0, (SCM (*)())(& scm_force_output));
#line 17
  scm_make_gsubr(s_read_char, 0, 1, 0, (SCM (*)())(& scm_read_char));
#line 18
  scm_make_gsubr(s_peek_char, 0, 1, 0, (SCM (*)())(& scm_peek_char));
#line 19
  scm_make_gsubr(s_unread_char, 2, 0, 0, (SCM (*)())(& scm_unread_char));
#line 20
  scm_make_gsubr(s_port_line, 0, 1, 0, (SCM (*)())(& scm_port_line));
#line 21
  scm_make_gsubr(s_set_port_line_x, 1, 1, 0, (SCM (*)())(& scm_set_port_line_x));
#line 22
  scm_make_gsubr(s_port_column, 0, 1, 0, (SCM (*)())(& scm_port_column));
#line 23
  scm_make_gsubr(s_set_port_column_x, 1, 1, 0, (SCM (*)())(& scm_set_port_column_x));
#line 24
  scm_make_gsubr(s_port_filename, 0, 1, 0, (SCM (*)())(& scm_port_filename));
#line 25
  scm_make_gsubr(s_set_port_filename_x, 1, 1, 0, (SCM (*)())(& scm_set_port_filename_x));
#line 26
  scm_make_gsubr(s_sys_make_void_port, 1, 0, 0, (SCM (*)())(& scm_sys_make_void_port));
  }
#line 853 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ports.c"
  return;
}
}
#line 167 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/pairs.h"
SCM scm_pair_p(SCM x ) ;
#line 168
SCM scm_set_car_x(SCM pair , SCM value ) ;
#line 169
SCM scm_set_cdr_x(SCM pair , SCM value ) ;
#line 170
void scm_init_pairs(void) ;
#line 50 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/pairs.c"
static char s_cons[5]  = {      (char )'c',      (char )'o',      (char )'n',      (char )'s', 
        (char )'\000'};
#line 52 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/pairs.c"
SCM scm_cons(SCM x , SCM y ) 
{ 
  register SCM z ;

  {
#line 58
  if (6 & (int )scm_freelist) {
    {
#line 58
    z = scm_gc_for_newcell();
    }
  } else {
#line 58
    z = scm_freelist;
#line 58
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 58
    scm_cells_allocated ++;
  }
#line 59
  ((scm_cell *)z)->car = x;
#line 60
  ((scm_cell *)z)->cdr = y;
#line 61
  return (z);
}
}
#line 65 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/pairs.c"
SCM scm_cons2(SCM w , SCM x , SCM y ) 
{ 
  register SCM z ;

  {
#line 72
  if (6 & (int )scm_freelist) {
    {
#line 72
    z = scm_gc_for_newcell();
    }
  } else {
#line 72
    z = scm_freelist;
#line 72
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 72
    scm_cells_allocated ++;
  }
#line 73
  ((scm_cell *)z)->car = x;
#line 74
  ((scm_cell *)z)->cdr = y;
#line 75
  x = z;
#line 76
  if (6 & (int )scm_freelist) {
    {
#line 76
    z = scm_gc_for_newcell();
    }
  } else {
#line 76
    z = scm_freelist;
#line 76
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 76
    scm_cells_allocated ++;
  }
#line 77
  ((scm_cell *)z)->car = w;
#line 78
  ((scm_cell *)z)->cdr = x;
#line 79
  return (z);
}
}
#line 83 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/pairs.c"
static char s_pair_p[6]  = {      (char )'p',      (char )'a',      (char )'i',      (char )'r', 
        (char )'?',      (char )'\000'};
#line 85 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/pairs.c"
SCM scm_pair_p(SCM x ) 
{ 
  long tmp ;

  {
#line 89
  if (6 & (int )x) {
#line 89
    return ((long )(16 << 9) + 372L);
  }
#line 90
  if (! (1 & (int )((scm_cell *)x)->car)) {
#line 90
    tmp = (long )(17 << 9) + 372L;
  } else {
#line 90
    tmp = (long )(16 << 9) + 372L;
  }
#line 90
  return (tmp);
}
}
#line 93 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/pairs.c"
static char s_set_car_x[9]  = 
#line 93
  {      (char )'s',      (char )'e',      (char )'t',      (char )'-', 
        (char )'c',      (char )'a',      (char )'r',      (char )'!', 
        (char )'\000'};
#line 95 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/pairs.c"
SCM scm_set_car_x(SCM pair , SCM value ) 
{ 


  {
#line 100
  if (! (6 & (int )pair)) {
#line 100
    if (! (! (1 & (int )((scm_cell *)pair)->car))) {
      {
#line 100
      scm_wta(pair, (char *)1, s_set_car_x);
      }
    }
  } else {
    {
#line 100
    scm_wta(pair, (char *)1, s_set_car_x);
    }
  }
#line 101
  ((scm_cell *)pair)->car = value;
#line 102
  return (value);
}
}
#line 105 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/pairs.c"
static char s_set_cdr_x[9]  = 
#line 105
  {      (char )'s',      (char )'e',      (char )'t',      (char )'-', 
        (char )'c',      (char )'d',      (char )'r',      (char )'!', 
        (char )'\000'};
#line 107 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/pairs.c"
SCM scm_set_cdr_x(SCM pair , SCM value ) 
{ 


  {
#line 112
  if (! (6 & (int )pair)) {
#line 112
    if (! (! (1 & (int )((scm_cell *)pair)->car))) {
      {
#line 112
      scm_wta(pair, (char *)1, s_set_cdr_x);
      }
    }
  } else {
    {
#line 112
    scm_wta(pair, (char *)1, s_set_cdr_x);
    }
  }
#line 113
  ((scm_cell *)pair)->cdr = value;
#line 114
  return (value);
}
}
#line 120 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/pairs.c"
static scm_iproc cxrs[31]  = 
#line 120
  {      {(char *)"car", (SCM (*)())0}, 
        {(char *)"cdr", (SCM (*)())0}, 
        {(char *)"caar", (SCM (*)())0}, 
        {(char *)"cadr", (SCM (*)())0}, 
        {(char *)"cdar", (SCM (*)())0}, 
        {(char *)"cddr", (SCM (*)())0}, 
        {(char *)"caaar", (SCM (*)())0}, 
        {(char *)"caadr", (SCM (*)())0}, 
        {(char *)"cadar", (SCM (*)())0}, 
        {(char *)"caddr", (SCM (*)())0}, 
        {(char *)"cdaar", (SCM (*)())0}, 
        {(char *)"cdadr", (SCM (*)())0}, 
        {(char *)"cddar", (SCM (*)())0}, 
        {(char *)"cdddr", (SCM (*)())0}, 
        {(char *)"caaaar", (SCM (*)())0}, 
        {(char *)"caaadr", (SCM (*)())0}, 
        {(char *)"caadar", (SCM (*)())0}, 
        {(char *)"caaddr", (SCM (*)())0}, 
        {(char *)"cadaar", (SCM (*)())0}, 
        {(char *)"cadadr", (SCM (*)())0}, 
        {(char *)"caddar", (SCM (*)())0}, 
        {(char *)"cadddr", (SCM (*)())0}, 
        {(char *)"cdaaar", (SCM (*)())0}, 
        {(char *)"cdaadr", (SCM (*)())0}, 
        {(char *)"cdadar", (SCM (*)())0}, 
        {(char *)"cdaddr", (SCM (*)())0}, 
        {(char *)"cddaar", (SCM (*)())0}, 
        {(char *)"cddadr", (SCM (*)())0}, 
        {(char *)"cdddar", (SCM (*)())0}, 
        {(char *)"cddddr", (SCM (*)())0}, 
        {(char *)0, (SCM (*)())0}};
#line 157 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/pairs.c"
void scm_init_pairs(void) 
{ 


  {
  {
#line 160
  scm_init_iprocs(cxrs, 93);
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/pairs.x"
  scm_make_gsubr(s_cons, 2, 0, 0, (SCM (*)())(& scm_cons));
#line 2
  scm_make_gsubr(s_pair_p, 1, 0, 0, (SCM (*)())(& scm_pair_p));
#line 3
  scm_make_gsubr(s_set_car_x, 2, 0, 0, (SCM (*)())(& scm_set_car_x));
#line 4
  scm_make_gsubr(s_set_cdr_x, 2, 0, 0, (SCM (*)())(& scm_set_cdr_x));
  }
#line 162 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/pairs.c"
  return;
}
}
#line 71 "../libguile/options.h"
void scm_init_options(void) ;
#line 118 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/options.c"
SCM scm_options(SCM new_mode , scm_option *options , int n , char *s___0 ) 
{ 
  int i ;
  int docp ;
  int tmp ;
  SCM ans ;
  SCM ls ;
  SCM tmp___0 ;
  char const   *tmp___1 ;
  SCM tmp___2 ;
  unsigned long *flags ;
  char *tmp___3 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 125
  if (! ((long )(18 << 9) + 372L == new_mode)) {
#line 125
    if (6 & (int )new_mode) {
#line 125
      tmp = 1;
    } else
#line 125
    if (1 & (int )((scm_cell *)new_mode)->car) {
#line 125
      tmp = 1;
    } else {
#line 125
      tmp = 0;
    }
  } else {
#line 125
    tmp = 0;
  }
#line 125
  docp = tmp;
#line 127
  ans = (long )(20 << 9) + 372L;
#line 128
  i = 0;
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    if (! (i < n)) {
#line 128
      goto while_break;
    }
#line 130
    if (docp) {
      {
#line 130
      tmp___0 = scm_cons((SCM )(options + i)->doc, (long )(20 << 9) + 372L);
#line 130
      ls = tmp___0;
      }
    } else {
#line 130
      ls = ans;
    }
    {
#line 133
    if ((options + i)->type == 0) {
#line 133
      goto case_0;
    }
#line 140
    if ((options + i)->type == 1) {
#line 140
      goto case_1;
    }
#line 143
    if ((options + i)->type == 2) {
#line 143
      goto case_2;
    }
#line 131
    goto switch_break;
    case_0: /* CIL Label */ 
#line 134
    if (docp) {
#line 135
      if ((int )(options + i)->val) {
#line 135
        tmp___1 = "yes";
      } else {
#line 135
        tmp___1 = "no";
      }
      {
#line 135
      ls = scm_cons((SCM )tmp___1, ls);
      }
    }
#line 139
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 141
    ls = scm_cons((long )((int )(options + i)->val << 2) + 2L, ls);
    }
#line 142
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 144
    ls = scm_cons((SCM )(options + i)->val, ls);
    }
    switch_break: /* CIL Label */ ;
    }
#line 146
    if ((options + i)->type == 0) {
#line 146
      if (! docp) {
#line 146
        if (! (! ((int )(options + i)->val))) {
          {
#line 149
          ls = scm_cons((SCM )(options + i)->name, ls);
          }
        }
      } else {
        {
#line 149
        ls = scm_cons((SCM )(options + i)->name, ls);
        }
      }
    } else {
      {
#line 149
      ls = scm_cons((SCM )(options + i)->name, ls);
      }
    }
#line 150
    if (docp) {
      {
#line 150
      tmp___2 = scm_cons(ls, ans);
#line 150
      ans = tmp___2;
      }
    } else {
#line 150
      ans = ls;
    }
#line 128
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 152
  if (! ((long )(18 << 9) + 372L == new_mode)) {
#line 152
    if (! docp) {
      {
#line 155
      tmp___3 = scm_must_malloc((long )((unsigned long )n * sizeof(unsigned long )),
                                (char *)"mode buffer");
#line 155
      flags = (unsigned long *)tmp___3;
#line 157
      i = 0;
      }
      {
#line 157
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 157
        if (! (i < n)) {
#line 157
          goto while_break___0;
        }
#line 158
        if ((options + i)->type == 0) {
#line 159
          *(flags + i) = 0UL;
        } else {
#line 161
          *(flags + i) = (options + i)->val;
        }
#line 157
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 162
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 162
        if (! ((long )(20 << 9) + 372L != new_mode)) {
#line 162
          goto while_break___1;
        }
#line 164
        if (! (6 & (int )new_mode)) {
#line 164
          if (! (! (1 & (int )((scm_cell *)new_mode)->car))) {
            {
#line 164
            scm_wta(new_mode, (char *)1, s___0);
            }
          }
        } else {
          {
#line 164
          scm_wta(new_mode, (char *)1, s___0);
          }
        }
#line 168
        i = 0;
        {
#line 168
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 168
          if (! (i < n)) {
#line 168
            goto while_break___2;
          }
#line 169
          if (((scm_cell *)new_mode)->car == (SCM )(options + i)->name) {
            {
#line 172
            if ((options + i)->type == 0) {
#line 172
              goto case_0___0;
            }
#line 175
            if ((options + i)->type == 1) {
#line 175
              goto case_1___0;
            }
#line 185
            if ((options + i)->type == 2) {
#line 185
              goto case_2___0;
            }
#line 170
            goto switch_break___0;
            case_0___0: /* CIL Label */ 
#line 173
            *(flags + i) = 1UL;
#line 174
            goto cont;
            case_1___0: /* CIL Label */ 
#line 176
            new_mode = ((scm_cell *)new_mode)->cdr;
#line 177
            if (! (6 & (int )new_mode)) {
#line 177
              if (! (1 & (int )((scm_cell *)new_mode)->car)) {
#line 177
                if (! (2 & (int )((scm_cell *)new_mode)->car)) {
                  {
#line 177
                  scm_wta(new_mode, (char *)1, s___0);
                  }
                }
              } else {
                {
#line 177
                scm_wta(new_mode, (char *)1, s___0);
                }
              }
            } else {
              {
#line 177
              scm_wta(new_mode, (char *)1, s___0);
              }
            }
#line 183
            *(flags + i) = (unsigned long )(((scm_cell *)new_mode)->car >> 2);
#line 184
            goto cont;
            case_2___0: /* CIL Label */ 
#line 186
            new_mode = ((scm_cell *)new_mode)->cdr;
#line 187
            *(flags + i) = (unsigned long )((scm_cell *)new_mode)->car;
#line 188
            goto cont;
            switch_break___0: /* CIL Label */ ;
            }
          }
#line 168
          i ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 191
        scm_must_free((char *)flags);
#line 192
        scm_wta(((scm_cell *)new_mode)->car, (char *)"Unknown mode flag", s___0);
        }
        cont: 
#line 195
        new_mode = ((scm_cell *)new_mode)->cdr;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 197
      i = 0;
      {
#line 197
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 197
        if (! (i < n)) {
#line 197
          goto while_break___3;
        }
#line 197
        (options + i)->val = *(flags + i);
#line 197
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 198
      scm_must_free((char *)flags);
      }
    }
  }
#line 200
  return (ans);
}
}
#line 204 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/options.c"
void scm_init_opts(SCM (*func)(SCM  ) , scm_option *options , int n ) 
{ 
  int i ;
  SCM tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;

  {
#line 212
  i = 0;
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    if (! (i < n)) {
#line 212
      goto while_break;
    }
    {
#line 214
    tmp = scm_sysintern((options + i)->name, (long )(18 << 9) + 372L);
#line 214
    (options + i)->name = (char *)((scm_cell *)tmp)->car;
#line 216
    tmp___0 = scm_take0str((options + i)->doc);
#line 216
    tmp___1 = scm_permanent_object(tmp___0);
#line 216
    (options + i)->doc = (char *)tmp___1;
#line 212
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 219
  (*func)((long )(18 << 9) + 372L);
  }
#line 220
  return;
}
}
#line 223 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/options.c"
void scm_init_options(void) 
{ 


  {
#line 227
  return;
}
}
#line 55 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/alist.h"
SCM scm_assq(SCM x , SCM alist ) ;
#line 56 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/objprop.h"
SCM scm_object_properties(SCM obj ) ;
#line 57
SCM scm_set_object_properties_x(SCM obj , SCM plist ) ;
#line 58
SCM scm_object_property(SCM obj , SCM key ) ;
#line 59
SCM scm_set_object_property_x(SCM obj , SCM key , SCM val ) ;
#line 60
void scm_init_objprop(void) ;
#line 55 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/objprop.c"
static char s_object_properties[18]  = 
#line 55 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/objprop.c"
  {      (char )'o',      (char )'b',      (char )'j',      (char )'e', 
        (char )'c',      (char )'t',      (char )'-',      (char )'p', 
        (char )'r',      (char )'o',      (char )'p',      (char )'e', 
        (char )'r',      (char )'t',      (char )'i',      (char )'e', 
        (char )'s',      (char )'\000'};
#line 57 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/objprop.c"
SCM scm_object_properties(SCM obj ) 
{ 
  SCM tmp ;

  {
  {
#line 61
  tmp = scm_hashq_ref(scm_sys_protects[12], obj, (long )(20 << 9) + 372L);
  }
#line 61
  return (tmp);
}
}
#line 65 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/objprop.c"
static char s_set_object_properties_x[23]  = 
#line 65
  {      (char )'s',      (char )'e',      (char )'t',      (char )'-', 
        (char )'o',      (char )'b',      (char )'j',      (char )'e', 
        (char )'c',      (char )'t',      (char )'-',      (char )'p', 
        (char )'r',      (char )'o',      (char )'p',      (char )'e', 
        (char )'r',      (char )'t',      (char )'i',      (char )'e', 
        (char )'s',      (char )'!',      (char )'\000'};
#line 67 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/objprop.c"
SCM scm_set_object_properties_x(SCM obj , SCM plist ) 
{ 
  SCM handle ;
  SCM tmp ;

  {
  {
#line 72
  tmp = scm_hashq_create_handle_x(scm_sys_protects[12], obj, plist);
#line 72
  handle = tmp;
#line 73
  ((scm_cell *)handle)->cdr = plist;
  }
#line 74
  return (plist);
}
}
#line 77 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/objprop.c"
static char s_object_property[16]  = 
#line 77
  {      (char )'o',      (char )'b',      (char )'j',      (char )'e', 
        (char )'c',      (char )'t',      (char )'-',      (char )'p', 
        (char )'r',      (char )'o',      (char )'p',      (char )'e', 
        (char )'r',      (char )'t',      (char )'y',      (char )'\000'};
#line 79 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/objprop.c"
SCM scm_object_property(SCM obj , SCM key ) 
{ 
  SCM assoc ;
  SCM tmp ;
  SCM tmp___0 ;

  {
  {
#line 85
  tmp = scm_object_properties(obj);
#line 85
  assoc = scm_assq(key, ((scm_cell *)tmp)->cdr);
  }
#line 86
  if (! (6 & (int )assoc)) {
#line 86
    tmp___0 = ((scm_cell *)assoc)->cdr;
  } else {
#line 86
    tmp___0 = (long )(16 << 9) + 372L;
  }
#line 86
  return (tmp___0);
}
}
#line 89 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/objprop.c"
static char s_set_object_property_x[21]  = 
#line 89
  {      (char )'s',      (char )'e',      (char )'t',      (char )'-', 
        (char )'o',      (char )'b',      (char )'j',      (char )'e', 
        (char )'c',      (char )'t',      (char )'-',      (char )'p', 
        (char )'r',      (char )'o',      (char )'p',      (char )'e', 
        (char )'r',      (char )'t',      (char )'y',      (char )'!', 
        (char )'\000'};
#line 91 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/objprop.c"
SCM scm_set_object_property_x(SCM obj , SCM key , SCM val ) 
{ 
  SCM h ;
  SCM assoc ;

  {
  {
#line 99
  h = scm_hashq_create_handle_x(scm_sys_protects[12], obj, (long )(20 << 9) + 372L);
#line 100
  scm_ints_disabled = 1;
#line 101
  assoc = scm_assoc(key, ((scm_cell *)h)->cdr);
  }
#line 102
  if (! (6 & (int )assoc)) {
#line 103
    ((scm_cell *)assoc)->cdr = val;
  } else {
    {
#line 106
    assoc = scm_acons(key, val, ((scm_cell *)h)->cdr);
#line 107
    ((scm_cell *)h)->cdr = assoc;
    }
  }
#line 109
  scm_ints_disabled = 0;
#line 109
  scm_async_clock --;
#line 109
  if (0U == scm_async_clock) {
    {
#line 109
    scm_async_click();
    }
  }
#line 110
  return (val);
}
}
#line 114 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/objprop.c"
void scm_init_objprop(void) 
{ 


  {
  {
#line 117
  scm_sys_protects[12] = scm_make_weak_key_hash_table((long )(511 << 2) + 2L);
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/objprop.x"
  scm_make_gsubr(s_object_properties, 1, 0, 0, (SCM (*)())(& scm_object_properties));
#line 2
  scm_make_gsubr(s_set_object_properties_x, 2, 0, 0, (SCM (*)())(& scm_set_object_properties_x));
#line 3
  scm_make_gsubr(s_object_property, 2, 0, 0, (SCM (*)())(& scm_object_property));
#line 4
  scm_make_gsubr(s_set_object_property_x, 3, 0, 0, (SCM (*)())(& scm_set_object_property_x));
  }
#line 119 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/objprop.c"
  return;
}
}
#line 55 "/usr/include/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double acos(double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) double asin(double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) double atan(double __x ) ;
#line 61
extern  __attribute__((__nothrow__)) double atan2(double __y , double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) double cos(double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) double sin(double __x ) ;
#line 68
extern  __attribute__((__nothrow__)) double tan(double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) double cosh(double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) double sinh(double __x ) ;
#line 77
extern  __attribute__((__nothrow__)) double tanh(double __x ) ;
#line 101
extern  __attribute__((__nothrow__)) double exp(double __x ) ;
#line 110
extern  __attribute__((__nothrow__)) double log(double __x ) ;
#line 154
extern  __attribute__((__nothrow__)) double pow(double __x , double __y ) ;
#line 157
extern  __attribute__((__nothrow__)) double sqrt(double __x ) ;
#line 179
extern  __attribute__((__nothrow__)) double ceil(double __x )  __attribute__((__const__)) ;
#line 182
extern  __attribute__((__nothrow__)) double fabs(double __x )  __attribute__((__const__)) ;
#line 185
extern  __attribute__((__nothrow__)) double floor(double __x )  __attribute__((__const__)) ;
#line 73 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/error.h"
 __attribute__((__noreturn__)) void scm_num_overflow(char *subr ) ;
#line 229 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.h"
SCM scm_exact_p(SCM x ) ;
#line 230
SCM scm_odd_p(SCM n ) ;
#line 231
SCM scm_even_p(SCM n ) ;
#line 232
SCM scm_abs(SCM x ) ;
#line 233
SCM scm_quotient(SCM x , SCM y ) ;
#line 234
SCM scm_remainder(SCM x , SCM y ) ;
#line 235
SCM scm_modulo(SCM x , SCM y ) ;
#line 236
SCM scm_gcd(SCM x , SCM y ) ;
#line 237
SCM scm_lcm(SCM n1 , SCM n2 ) ;
#line 238
SCM scm_logand(SCM n1 , SCM n2 ) ;
#line 239
SCM scm_logior(SCM n1 , SCM n2 ) ;
#line 240
SCM scm_logxor(SCM n1 , SCM n2 ) ;
#line 241
SCM scm_logtest(SCM n1 , SCM n2 ) ;
#line 242
SCM scm_logbit_p(SCM n1 , SCM n2 ) ;
#line 243
SCM scm_lognot(SCM n ) ;
#line 244
SCM scm_integer_expt(SCM z1 , SCM z2 ) ;
#line 245
SCM scm_ash(SCM n , SCM cnt ) ;
#line 246
SCM scm_bit_extract(SCM n , SCM start , SCM end ) ;
#line 247
SCM scm_logcount(SCM n ) ;
#line 248
SCM scm_integer_length(SCM n ) ;
#line 249
SCM scm_mkbig(size_t nlen , int sign ) ;
#line 250
SCM scm_big2inum(SCM b , size_t l ) ;
#line 251
SCM scm_adjbig(SCM b , size_t nlen ) ;
#line 252
SCM scm_normbig(SCM b ) ;
#line 253
SCM scm_copybig(SCM b , int sign ) ;
#line 254
SCM scm_long2big(long n ) ;
#line 256
SCM scm_2ulong2big(unsigned long *np ) ;
#line 257
SCM scm_ulong2big(unsigned long n ) ;
#line 258
int scm_bigcomp(SCM x , SCM y ) ;
#line 259
long scm_pseudolong(long x ) ;
#line 261
SCM scm_addbig(unsigned short *x , size_t nx , int xsgn , SCM bigy , int sgny ) ;
#line 262
SCM scm_mulbig(unsigned short *x , size_t nx , unsigned short *y , size_t ny , int sgn ) ;
#line 263
unsigned int scm_divbigdig(unsigned short *ds , size_t h , unsigned short div___0 ) ;
#line 264
SCM scm_divbigint(SCM x , long z , int sgn , int mode ) ;
#line 265
SCM scm_divbigbig(unsigned short *x , size_t nx , unsigned short *y , size_t ny ,
                  int sgn , int modes ) ;
#line 267
SCM scm_number_to_string(SCM x , SCM radix ) ;
#line 271
SCM scm_istr2flo(char *str , long len , long radix ) ;
#line 273
SCM scm_string_to_number(SCM str , SCM radix ) ;
#line 277
SCM scm_number_p(SCM x ) ;
#line 278
SCM scm_real_p(SCM x ) ;
#line 279
SCM scm_integer_p(SCM x ) ;
#line 280
SCM scm_inexact_p(SCM x ) ;
#line 281
SCM scm_num_eq_p(SCM x , SCM y ) ;
#line 283
SCM scm_gr_p(SCM x , SCM y ) ;
#line 284
SCM scm_leq_p(SCM x , SCM y ) ;
#line 285
SCM scm_geq_p(SCM x , SCM y ) ;
#line 286
SCM scm_zero_p(SCM z ) ;
#line 287
SCM scm_positive_p(SCM x ) ;
#line 288
SCM scm_negative_p(SCM x ) ;
#line 289
SCM scm_max(SCM x , SCM y ) ;
#line 290
SCM scm_min(SCM x , SCM y ) ;
#line 294
double scm_num2dbl(SCM a , char *why ) ;
#line 296
double scm_asinh(double x ) ;
#line 297
double scm_acosh(double x ) ;
#line 298
double scm_atanh(double x ) ;
#line 299
double scm_truncate(double x ) ;
#line 300
double scm_round(double x ) ;
#line 301
double scm_exact_to_inexact(double z ) ;
#line 302
SCM scm_sys_expt(SCM z1 , SCM z2 ) ;
#line 303
SCM scm_sys_atan2(SCM z1 , SCM z2 ) ;
#line 304
SCM scm_make_rectangular(SCM z1 , SCM z2 ) ;
#line 305
SCM scm_make_polar(SCM z1 , SCM z2 ) ;
#line 306
SCM scm_real_part(SCM z ) ;
#line 307
SCM scm_imag_part(SCM z ) ;
#line 308
SCM scm_magnitude(SCM z ) ;
#line 309
SCM scm_angle(SCM z ) ;
#line 310
SCM scm_inexact_to_exact(SCM z ) ;
#line 312
SCM scm_dbl2big(double d ) ;
#line 313
double scm_big2dbl(SCM b ) ;
#line 321
void scm_init_numbers(void) ;
#line 85 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_exact_p[7]  = {      (char )'e',      (char )'x',      (char )'a',      (char )'c', 
        (char )'t',      (char )'?',      (char )'\000'};
#line 87 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_exact_p(SCM x ) 
{ 


  {
#line 91
  if (2 & (int )x) {
#line 91
    return ((long )(17 << 9) + 372L);
  }
#line 93
  if (! (6 & (int )x)) {
#line 93
    if ((65279 & (int )((scm_cell *)x)->car) == 639) {
#line 93
      return ((long )(17 << 9) + 372L);
    }
  }
#line 95
  return ((long )(16 << 9) + 372L);
}
}
#line 98 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_odd_p[5]  = {      (char )'o',      (char )'d',      (char )'d',      (char )'?', 
        (char )'\000'};
#line 100 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_odd_p(SCM n ) 
{ 
  long tmp ;
  long tmp___0 ;

  {
#line 105
  if (! (2 & (int )n)) {
#line 106
    if (! (6 & (int )n)) {
#line 106
      if (! ((65279 & (int )((scm_cell *)n)->car) == 639)) {
        {
#line 106
        scm_wta(n, (char *)1, s_odd_p);
        }
      }
    } else {
      {
#line 106
      scm_wta(n, (char *)1, s_odd_p);
      }
    }
#line 107
    if (1 & (int )*((unsigned short *)((scm_cell *)n)->cdr + 0)) {
#line 107
      tmp = (long )(17 << 9) + 372L;
    } else {
#line 107
      tmp = (long )(16 << 9) + 372L;
    }
#line 107
    return (tmp);
  }
#line 112
  if (4 & (int )n) {
#line 112
    tmp___0 = (long )(17 << 9) + 372L;
  } else {
#line 112
    tmp___0 = (long )(16 << 9) + 372L;
  }
#line 112
  return (tmp___0);
}
}
#line 115 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_even_p[6]  = {      (char )'e',      (char )'v',      (char )'e',      (char )'n', 
        (char )'?',      (char )'\000'};
#line 117 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_even_p(SCM n ) 
{ 
  long tmp ;
  long tmp___0 ;

  {
#line 122
  if (! (2 & (int )n)) {
#line 123
    if (! (6 & (int )n)) {
#line 123
      if (! ((65279 & (int )((scm_cell *)n)->car) == 639)) {
        {
#line 123
        scm_wta(n, (char *)1, s_even_p);
        }
      }
    } else {
      {
#line 123
      scm_wta(n, (char *)1, s_even_p);
      }
    }
#line 124
    if (1 & (int )*((unsigned short *)((scm_cell *)n)->cdr + 0)) {
#line 124
      tmp = (long )(16 << 9) + 372L;
    } else {
#line 124
      tmp = (long )(17 << 9) + 372L;
    }
#line 124
    return (tmp);
  }
#line 129
  if (4 & (int )n) {
#line 129
    tmp___0 = (long )(16 << 9) + 372L;
  } else {
#line 129
    tmp___0 = (long )(17 << 9) + 372L;
  }
#line 129
  return (tmp___0);
}
}
#line 132 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_abs[4]  = {      (char )'a',      (char )'b',      (char )'s',      (char )'\000'};
#line 134 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_abs(SCM x ) 
{ 
  SCM tmp ;
  SCM tmp___0 ;

  {
#line 139
  if (! (2 & (int )x)) {
#line 140
    if (! (6 & (int )x)) {
#line 140
      if (! ((65279 & (int )((scm_cell *)x)->car) == 639)) {
        {
#line 140
        scm_wta(x, (char *)1, s_abs);
        }
      }
    } else {
      {
#line 140
      scm_wta(x, (char *)1, s_abs);
      }
    }
#line 141
    if ((65535 & (int )((scm_cell *)x)->car) == 639) {
#line 141
      return (x);
    }
    {
#line 142
    tmp = scm_copybig(x, 0);
    }
#line 142
    return (tmp);
  }
#line 147
  if (x >> 2 >= 0L) {
#line 147
    return (x);
  }
#line 148
  x = - (x >> 2);
#line 149
  if (! (x <= 9223372036854775807L >> 2)) {
    {
#line 151
    tmp___0 = scm_long2big(x);
    }
#line 151
    return (tmp___0);
  }
#line 155
  return ((x << 2) + 2L);
}
}
#line 158 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_quotient[9]  = 
#line 158
  {      (char )'q',      (char )'u',      (char )'o',      (char )'t', 
        (char )'i',      (char )'e',      (char )'n',      (char )'t', 
        (char )'\000'};
#line 160 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_quotient(SCM x , SCM y ) 
{ 
  register long z ;
  long w ;
  SCM tmp ;
  int tmp___0 ;
  SCM tmp___1 ;
  int tmp___2 ;
  SCM tmp___3 ;
  SCM tmp___4 ;

  {
#line 167
  if (! (2 & (int )x)) {
#line 169
    if (! (6 & (int )x)) {
#line 169
      if (! ((65279 & (int )((scm_cell *)x)->car) == 639)) {
        {
#line 169
        scm_wta(x, (char *)1, s_quotient);
        }
      }
    } else {
      {
#line 169
      scm_wta(x, (char *)1, s_quotient);
      }
    }
#line 170
    if (! (2 & (int )y)) {
#line 171
      if (! (6 & (int )y)) {
#line 171
        if (! ((65279 & (int )((scm_cell *)y)->car) == 639)) {
#line 171
          goto bady;
        }
      } else {
#line 171
        goto bady;
      }
      {
#line 172
      tmp = scm_divbigbig((unsigned short *)((scm_cell *)x)->cdr, (size_t )(((scm_cell *)x)->car >> 16),
                          (unsigned short *)((scm_cell *)y)->cdr, (size_t )(((scm_cell *)y)->car >> 16),
                          (256 & (int )((scm_cell *)x)->car) ^ (256 & (int )((scm_cell *)y)->car),
                          2);
      }
#line 172
      return (tmp);
    }
#line 179
    z = y >> 2;
#line 180
    if (! z) {
#line 180
      goto ov;
    }
#line 181
    if (1L == z) {
#line 181
      return (x);
    }
#line 182
    if (z < 0L) {
#line 182
      z = - z;
    }
#line 183
    if (z < 1L << sizeof(unsigned short ) * 8UL) {
#line 184
      if (256 & (int )((scm_cell *)x)->car) {
#line 184
        tmp___0 = y > 0L;
      } else {
#line 184
        tmp___0 = y < 0L;
      }
      {
#line 184
      w = scm_copybig(x, tmp___0);
#line 185
      scm_divbigdig((unsigned short *)((scm_cell *)w)->cdr, (size_t )(((scm_cell *)w)->car >> 16),
                    (unsigned short )z);
#line 186
      tmp___1 = scm_normbig(w);
      }
#line 186
      return (tmp___1);
    }
    {
#line 189
    w = scm_pseudolong(z);
    }
#line 190
    if (256 & (int )((scm_cell *)x)->car) {
#line 190
      tmp___2 = y > 0L;
    } else {
#line 190
      tmp___2 = y < 0L;
    }
    {
#line 190
    tmp___3 = scm_divbigbig((unsigned short *)((scm_cell *)x)->cdr, (size_t )(((scm_cell *)x)->car >> 16),
                            (unsigned short *)(& w), ((sizeof(long ) * 8UL + sizeof(unsigned short ) * 8UL) - 1UL) / (sizeof(unsigned short ) * 8UL),
                            tmp___2, 2);
    }
#line 190
    return (tmp___3);
  }
#line 200
  if (! (2 & (int )y)) {
#line 202
    if (! (6 & (int )y)) {
#line 202
      if (! ((65279 & (int )((scm_cell *)y)->car) == 639)) {
#line 202
        goto bady;
      }
    } else {
      bady: 
      {
#line 203
      scm_wta(y, (char *)2, s_quotient);
      }
    }
#line 205
    return ((SCM )2);
  }
#line 211
  z = y >> 2;
#line 211
  if (z == 0L) {
    ov: 
    {
#line 212
    scm_num_overflow(s_quotient);
    }
  }
#line 213
  z = (x >> 2) / z;
#line 228
  if (z <= 9223372036854775807L >> 2) {
#line 228
    if (! (z >= (-0x7FFFFFFFFFFFFFFF-1) >> 2)) {
      {
#line 230
      tmp___4 = scm_long2big(z);
      }
#line 230
      return (tmp___4);
    }
  } else {
    {
#line 230
    tmp___4 = scm_long2big(z);
    }
#line 230
    return (tmp___4);
  }
#line 234
  return ((z << 2) + 2L);
}
}
#line 237 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_remainder[10]  = 
#line 237
  {      (char )'r',      (char )'e',      (char )'m',      (char )'a', 
        (char )'i',      (char )'n',      (char )'d',      (char )'e', 
        (char )'r',      (char )'\000'};
#line 239 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_remainder(SCM x , SCM y ) 
{ 
  register long z ;
  SCM tmp ;
  SCM tmp___0 ;

  {
#line 246
  if (! (2 & (int )x)) {
#line 247
    if (! (6 & (int )x)) {
#line 247
      if (! ((65279 & (int )((scm_cell *)x)->car) == 639)) {
        {
#line 247
        scm_wta(x, (char *)1, s_remainder);
        }
      }
    } else {
      {
#line 247
      scm_wta(x, (char *)1, s_remainder);
      }
    }
#line 248
    if (! (2 & (int )y)) {
#line 249
      if (! (6 & (int )y)) {
#line 249
        if (! ((65279 & (int )((scm_cell *)y)->car) == 639)) {
#line 249
          goto bady;
        }
      } else {
#line 249
        goto bady;
      }
      {
#line 250
      tmp = scm_divbigbig((unsigned short *)((scm_cell *)x)->cdr, (size_t )(((scm_cell *)x)->car >> 16),
                          (unsigned short *)((scm_cell *)y)->cdr, (size_t )(((scm_cell *)y)->car >> 16),
                          256 & (int )((scm_cell *)x)->car, 0);
      }
#line 250
      return (tmp);
    }
#line 253
    z = y >> 2;
#line 253
    if (! z) {
#line 253
      goto ov;
    }
    {
#line 254
    tmp___0 = scm_divbigint(x, z, 256 & (int )((scm_cell *)x)->car, 0);
    }
#line 254
    return (tmp___0);
  }
#line 256
  if (! (2 & (int )y)) {
#line 258
    if (! (6 & (int )y)) {
#line 258
      if (! ((65279 & (int )((scm_cell *)y)->car) == 639)) {
#line 258
        goto bady;
      }
    } else {
      bady: 
      {
#line 259
      scm_wta(y, (char *)2, s_remainder);
      }
    }
#line 261
    return (x);
  }
#line 267
  z = y >> 2;
#line 267
  if (! z) {
    ov: 
    {
#line 268
    scm_num_overflow(s_remainder);
    }
  }
#line 272
  z = (x >> 2) % z;
#line 280
  return ((z << 2) + 2L);
}
}
#line 283 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_modulo[7]  = {      (char )'m',      (char )'o',      (char )'d',      (char )'u', 
        (char )'l',      (char )'o',      (char )'\000'};
#line 285 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_modulo(SCM x , SCM y ) 
{ 
  register long yy ;
  register long z ;
  int tmp ;
  SCM tmp___0 ;
  int tmp___2 ;
  int tmp___3 ;
  SCM tmp___4 ;
  SCM tmp___6 ;
  SCM tmp___7 ;
  int tmp___8 ;
  long tmp___10 ;
  int tmp___11 ;

  {
#line 292
  if (! (2 & (int )x)) {
#line 293
    if (! (6 & (int )x)) {
#line 293
      if (! ((65279 & (int )((scm_cell *)x)->car) == 639)) {
        {
#line 293
        scm_wta(x, (char *)1, s_modulo);
        }
      }
    } else {
      {
#line 293
      scm_wta(x, (char *)1, s_modulo);
      }
    }
#line 294
    if (! (2 & (int )y)) {
#line 295
      if (! (6 & (int )y)) {
#line 295
        if (! ((65279 & (int )((scm_cell *)y)->car) == 639)) {
#line 295
          goto bady;
        }
      } else {
#line 295
        goto bady;
      }
#line 296
      if ((256 & (int )((scm_cell *)x)->car) ^ (256 & (int )((scm_cell *)y)->car)) {
#line 296
        tmp = 1;
      } else {
#line 296
        tmp = 0;
      }
      {
#line 296
      tmp___0 = scm_divbigbig((unsigned short *)((scm_cell *)x)->cdr, (size_t )(((scm_cell *)x)->car >> 16),
                              (unsigned short *)((scm_cell *)y)->cdr, (size_t )(((scm_cell *)y)->car >> 16),
                              256 & (int )((scm_cell *)y)->car, tmp);
      }
#line 296
      return (tmp___0);
    }
#line 299
    z = y >> 2;
#line 299
    if (! z) {
#line 299
      goto ov;
    }
#line 300
    if (256 & (int )((scm_cell *)x)->car) {
#line 300
      tmp___3 = y > 0L;
    } else {
#line 300
      tmp___3 = y < 0L;
    }
#line 300
    if (tmp___3) {
#line 300
      tmp___2 = 1;
    } else {
#line 300
      tmp___2 = 0;
    }
    {
#line 300
    tmp___4 = scm_divbigint(x, z, y < 0L, tmp___2);
    }
#line 300
    return (tmp___4);
  }
#line 302
  if (! (2 & (int )y)) {
#line 304
    if (! (6 & (int )y)) {
#line 304
      if (! ((65279 & (int )((scm_cell *)y)->car) == 639)) {
#line 304
        goto bady;
      }
    } else {
      bady: 
      {
#line 305
      scm_wta(y, (char *)2, s_modulo);
      }
    }
#line 307
    if (256 & (int )((scm_cell *)y)->car) {
#line 307
      tmp___8 = x > 0L;
    } else {
#line 307
      tmp___8 = x < 0L;
    }
#line 307
    if (tmp___8) {
      {
#line 307
      tmp___6 = scm_sum(x, y);
#line 307
      tmp___7 = tmp___6;
      }
    } else {
#line 307
      tmp___7 = x;
    }
#line 307
    return (tmp___7);
  }
#line 313
  yy = y >> 2;
#line 313
  if (! yy) {
    ov: 
    {
#line 314
    scm_num_overflow(s_modulo);
    }
  }
#line 319
  z = (x >> 2) % yy;
#line 321
  if (yy < 0L) {
#line 321
    tmp___11 = z > 0L;
  } else {
#line 321
    tmp___11 = z < 0L;
  }
#line 321
  if (tmp___11) {
#line 321
    tmp___10 = z + yy;
  } else {
#line 321
    tmp___10 = z;
  }
#line 321
  return ((tmp___10 << 2) + 2L);
}
}
#line 324 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_gcd[4]  = {      (char )'g',      (char )'c',      (char )'d',      (char )'\000'};
#line 326 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_gcd(SCM x , SCM y ) 
{ 
  register long u ;
  register long v ;
  register long k ;
  register long t ;
  SCM tmp ;
  int tmp___0 ;
  SCM tmp___1 ;

  {
#line 332
  if ((long )(18 << 9) + 372L == y) {
#line 332
    if ((long )(18 << 9) + 372L == x) {
#line 332
      tmp = (SCM )2;
    } else {
#line 332
      tmp = x;
    }
#line 332
    return (tmp);
  }
  tailrec: 
#line 335
  if (! (2 & (int )x)) {
    big_gcd: 
#line 337
    if (! (6 & (int )x)) {
#line 337
      if (! ((65279 & (int )((scm_cell *)x)->car) == 639)) {
        {
#line 337
        scm_wta(x, (char *)1, s_gcd);
        }
      }
    } else {
      {
#line 337
      scm_wta(x, (char *)1, s_gcd);
      }
    }
#line 338
    if (256 & (int )((scm_cell *)x)->car) {
      {
#line 338
      x = scm_copybig(x, 0);
      }
    }
    newy: 
#line 340
    if (! (2 & (int )y)) {
#line 341
      if (! (6 & (int )y)) {
#line 341
        if (! ((65279 & (int )((scm_cell *)y)->car) == 639)) {
          {
#line 341
          scm_wta(y, (char *)2, s_gcd);
          }
        }
      } else {
        {
#line 341
        scm_wta(y, (char *)2, s_gcd);
        }
      }
#line 342
      if (256 & (int )((scm_cell *)y)->car) {
        {
#line 342
        y = scm_copybig(y, 0);
        }
      }
      {
#line 343
      tmp___0 = scm_bigcomp(x, y);
      }
      {
#line 344
      if (tmp___0 == -1) {
#line 344
        goto swaprec;
      }
#line 346
      if (tmp___0 == 0) {
#line 346
        goto case_0;
      }
#line 347
      if (tmp___0 == 1) {
#line 347
        goto case_1;
      }
#line 343
      goto switch_break;
      swaprec: 
      case_neg_1: /* CIL Label */ 
      {
#line 345
      t = scm_remainder(x, y);
#line 345
      x = y;
#line 345
      y = t;
      }
#line 345
      goto tailrec;
      case_0: /* CIL Label */ 
#line 346
      return (x);
      case_1: /* CIL Label */ 
      {
#line 347
      y = scm_remainder(y, x);
      }
#line 347
      goto newy;
      switch_break: /* CIL Label */ ;
      }
    }
#line 351
    if (2L == y) {
#line 351
      return (x);
    }
#line 351
    goto swaprec;
  }
#line 353
  if (! (2 & (int )y)) {
#line 353
    t = x;
#line 353
    x = y;
#line 353
    y = t;
#line 353
    goto big_gcd;
  }
#line 358
  u = x >> 2;
#line 359
  if (u < 0L) {
#line 359
    u = - u;
  }
#line 360
  v = y >> 2;
#line 361
  if (v < 0L) {
#line 361
    v = - v;
  } else
#line 362
  if (0L == v) {
#line 362
    goto getout;
  }
#line 363
  if (0L == u) {
#line 363
    u = v;
#line 363
    goto getout;
  }
#line 364
  k = 1L;
  {
#line 364
  while (1) {
    while_continue: /* CIL Label */ ;
#line 364
    if (! (! (1 & ((int )u | (int )v)))) {
#line 364
      goto while_break;
    }
#line 364
    k <<= 1;
#line 364
    u >>= 1;
#line 364
    v >>= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 365
  if (1 & (int )u) {
#line 365
    t = - v;
  } else {
#line 367
    t = u;
    b3: 
#line 369
    t >>= 1;
  }
#line 371
  if (! (1 & (int )t)) {
#line 371
    goto b3;
  }
#line 372
  if (t > 0L) {
#line 372
    u = t;
  } else {
#line 373
    v = - t;
  }
#line 374
  t = u - v;
#line 374
  if (t) {
#line 374
    goto b3;
  }
#line 375
  u *= k;
  getout: 
#line 377
  if (! (u <= 9223372036854775807L >> 2)) {
    {
#line 379
    tmp___1 = scm_long2big(u);
    }
#line 379
    return (tmp___1);
  }
#line 383
  return ((u << 2) + 2L);
}
}
#line 386 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_lcm[4]  = {      (char )'l',      (char )'c',      (char )'m',      (char )'\000'};
#line 388 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_lcm(SCM n1 , SCM n2 ) 
{ 
  SCM d ;
  SCM tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;

  {
#line 394
  if ((long )(18 << 9) + 372L == n2) {
#line 395
    n2 = (1L << 2) + 2L;
#line 396
    if ((long )(18 << 9) + 372L == n1) {
#line 396
      return (n2);
    }
  }
  {
#line 398
  d = scm_gcd(n1, n2);
  }
#line 399
  if (2L == d) {
#line 399
    return (d);
  }
  {
#line 400
  tmp = scm_quotient(n2, d);
#line 400
  tmp___0 = scm_product(n1, tmp);
#line 400
  tmp___1 = scm_abs(tmp___0);
  }
#line 400
  return (tmp___1);
}
}
#line 410 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_logand[7]  = {      (char )'l',      (char )'o',      (char )'g',      (char )'a', 
        (char )'n',      (char )'d',      (char )'\000'};
#line 412 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_logand(SCM n1 , SCM n2 ) 
{ 
  long tmp ;
  long tmp___0 ;
  SCM tmp___1 ;

  {
  {
#line 417
  tmp = scm_num2long(n1, (char *)1, s_logand);
#line 417
  tmp___0 = scm_num2long(n2, (char *)2, s_logand);
#line 417
  tmp___1 = scm_long2num(tmp & tmp___0);
  }
#line 417
  return (tmp___1);
}
}
#line 421 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_logior[7]  = {      (char )'l',      (char )'o',      (char )'g',      (char )'i', 
        (char )'o',      (char )'r',      (char )'\000'};
#line 423 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_logior(SCM n1 , SCM n2 ) 
{ 
  long tmp ;
  long tmp___0 ;
  SCM tmp___1 ;

  {
  {
#line 428
  tmp = scm_num2long(n1, (char *)1, s_logior);
#line 428
  tmp___0 = scm_num2long(n2, (char *)2, s_logior);
#line 428
  tmp___1 = scm_long2num(tmp | tmp___0);
  }
#line 428
  return (tmp___1);
}
}
#line 432 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_logxor[7]  = {      (char )'l',      (char )'o',      (char )'g',      (char )'x', 
        (char )'o',      (char )'r',      (char )'\000'};
#line 434 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_logxor(SCM n1 , SCM n2 ) 
{ 
  long tmp ;
  long tmp___0 ;
  SCM tmp___1 ;

  {
  {
#line 439
  tmp = scm_num2long(n1, (char *)1, s_logxor);
#line 439
  tmp___0 = scm_num2long(n2, (char *)2, s_logxor);
#line 439
  tmp___1 = scm_long2num(tmp ^ tmp___0);
  }
#line 439
  return (tmp___1);
}
}
#line 443 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_logtest[8]  = 
#line 443
  {      (char )'l',      (char )'o',      (char )'g',      (char )'t', 
        (char )'e',      (char )'s',      (char )'t',      (char )'\000'};
#line 445 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_logtest(SCM n1 , SCM n2 ) 
{ 
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
  {
#line 450
  tmp___2 = scm_num2long(n1, (char *)1, s_logtest);
#line 450
  tmp___3 = scm_num2long(n2, (char *)2, s_logtest);
  }
#line 450
  if (tmp___2 & tmp___3) {
#line 450
    tmp___1 = (long )(17 << 9) + 372L;
  } else {
#line 450
    tmp___1 = (long )(16 << 9) + 372L;
  }
#line 450
  return (tmp___1);
}
}
#line 456 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_logbit_p[8]  = 
#line 456
  {      (char )'l',      (char )'o',      (char )'g',      (char )'b', 
        (char )'i',      (char )'t',      (char )'?',      (char )'\000'};
#line 458 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_logbit_p(SCM n1 , SCM n2 ) 
{ 
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
  {
#line 463
  tmp___2 = scm_num2long(n1, (char *)1, s_logtest);
#line 463
  tmp___3 = scm_num2long(n2, (char *)2, s_logtest);
  }
#line 463
  if ((long )(1 << tmp___2) & tmp___3) {
#line 463
    tmp___1 = (long )(17 << 9) + 372L;
  } else {
#line 463
    tmp___1 = (long )(16 << 9) + 372L;
  }
#line 463
  return (tmp___1);
}
}
#line 531 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_lognot[7]  = {      (char )'l',      (char )'o',      (char )'g',      (char )'n', 
        (char )'o',      (char )'t',      (char )'\000'};
#line 533 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_lognot(SCM n ) 
{ 
  SCM tmp ;

  {
#line 537
  if (! (2 & (int )n)) {
    {
#line 537
    scm_wta(n, (char *)1, s_lognot);
    }
  }
  {
#line 538
  tmp = scm_difference((-1L << 2) + 2L, n);
  }
#line 538
  return (tmp);
}
}
#line 541 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_integer_expt[13]  = 
#line 541
  {      (char )'i',      (char )'n',      (char )'t',      (char )'e', 
        (char )'g',      (char )'e',      (char )'r',      (char )'-', 
        (char )'e',      (char )'x',      (char )'p',      (char )'t', 
        (char )'\000'};
#line 543 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_integer_expt(SCM z1 , SCM z2 ) 
{ 
  SCM acc ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  SCM tmp___2 ;

  {
#line 548
  acc = (1L << 2) + 2L;
#line 550
  if (2L == z1) {
#line 550
    return (z1);
  } else
#line 550
  if (acc == z1) {
#line 550
    return (z1);
  } else
#line 551
  if ((-1L << 2) + 2L == z1) {
    {
#line 551
    tmp___1 = scm_even_p(z2);
    }
#line 551
    if ((long )(16 << 9) + 372L == tmp___1) {
#line 551
      tmp___0 = z1;
    } else {
#line 551
      tmp___0 = acc;
    }
#line 551
    return (tmp___0);
  }
#line 553
  if (! (2 & (int )z2)) {
    {
#line 553
    scm_wta(z2, (char *)2, s_integer_expt);
    }
  }
#line 554
  z2 >>= 2;
#line 555
  if (z2 < 0L) {
    {
#line 556
    z2 = - z2;
#line 557
    z1 = scm_divide(z1, (long )(18 << 9) + 372L);
    }
  }
  {
#line 559
  while (1) {
    while_continue: /* CIL Label */ ;
#line 560
    if (0L == z2) {
#line 560
      return (acc);
    }
#line 561
    if (1L == z2) {
      {
#line 561
      tmp___2 = scm_product(acc, z1);
      }
#line 561
      return (tmp___2);
    }
#line 562
    if (z2 & 1L) {
      {
#line 562
      acc = scm_product(acc, z1);
      }
    }
    {
#line 563
    z1 = scm_product(z1, z1);
#line 564
    z2 >>= 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 568 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_ash[4]  = {      (char )'a',      (char )'s',      (char )'h',      (char )'\000'};
#line 570 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_ash(SCM n , SCM cnt ) 
{ 
  SCM res ;
  SCM tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  SCM tmp___2 ;
  SCM tmp___3 ;
  SCM tmp___4 ;
  SCM tmp___5 ;

  {
#line 575
  res = n >> 2;
#line 576
  if (! (2 & (int )cnt)) {
    {
#line 576
    scm_wta(cnt, (char *)2, s_ash);
    }
  }
#line 578
  if (cnt < 0L) {
    {
#line 579
    res = scm_integer_expt((long )(2 << 2) + 2L, (- (cnt >> 2) << 2) + 2L);
#line 580
    tmp___3 = scm_negative_p(n);
    }
#line 580
    if ((long )(16 << 9) + 372L != tmp___3) {
      {
#line 581
      tmp = scm_sum((1L << 2) + 2L, n);
#line 581
      tmp___0 = scm_quotient(tmp, res);
#line 581
      tmp___1 = scm_sum((-1L << 2) + 2L, tmp___0);
      }
#line 581
      return (tmp___1);
    } else {
      {
#line 582
      tmp___2 = scm_quotient(n, res);
      }
#line 582
      return (tmp___2);
    }
  } else {
    {
#line 584
    tmp___4 = scm_integer_expt((long )(2 << 2) + 2L, cnt);
#line 584
    tmp___5 = scm_product(n, tmp___4);
    }
#line 584
    return (tmp___5);
  }
}
}
#line 596 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_bit_extract[12]  = 
#line 596
  {      (char )'b',      (char )'i',      (char )'t',      (char )'-', 
        (char )'e',      (char )'x',      (char )'t',      (char )'r', 
        (char )'a',      (char )'c',      (char )'t',      (char )'\000'};
#line 598 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_bit_extract(SCM n , SCM start , SCM end ) 
{ 
  SCM tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  SCM tmp___2 ;

  {
#line 604
  if (! (2 & (int )start)) {
    {
#line 604
    scm_wta(start, (char *)2, s_bit_extract);
    }
  }
#line 605
  if (! (2 & (int )end)) {
    {
#line 605
    scm_wta(end, (char *)3, s_bit_extract);
    }
  }
#line 606
  start >>= 2;
#line 606
  end >>= 2;
#line 607
  if (! (end >= start)) {
    {
#line 607
    scm_wta((end << 2) + 2L, (char *)10, s_bit_extract);
    }
  }
#line 609
  if (! (2 & (int )n)) {
    {
#line 610
    tmp = scm_ash(n, (- start << 2) + 2L);
#line 610
    tmp___0 = scm_integer_expt((long )(2 << 2) + 2L, ((end - start) << 2) + 2L);
#line 610
    tmp___1 = scm_difference(tmp___0, (1L << 2) + 2L);
#line 610
    tmp___2 = scm_logand(tmp___1, tmp);
    }
#line 610
    return (tmp___2);
  }
#line 617
  return (((((n >> 2) >> start) & ((1L << (end - start)) - 1L)) << 2) + 2L);
}
}
#line 620 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
char scm_logtab[16]  = 
#line 620
  {      (char)0,      (char)1,      (char)1,      (char)2, 
        (char)1,      (char)2,      (char)2,      (char)3, 
        (char)1,      (char)2,      (char)2,      (char)3, 
        (char)2,      (char)3,      (char)3,      (char)4};
#line 621 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_logcount[9]  = 
#line 621
  {      (char )'l',      (char )'o',      (char )'g',      (char )'c', 
        (char )'o',      (char )'u',      (char )'n',      (char )'t', 
        (char )'\000'};
#line 623 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_logcount(SCM n ) 
{ 
  register unsigned long c ;
  register long nn ;
  size_t i ;
  unsigned short *ds ;
  unsigned short d ;
  SCM tmp ;
  SCM tmp___0 ;
  size_t tmp___1 ;

  {
#line 627
  c = 0UL;
#line 630
  if (! (2 & (int )n)) {
#line 632
    if (! (6 & (int )n)) {
#line 632
      if (! ((65279 & (int )((scm_cell *)n)->car) == 639)) {
        {
#line 632
        scm_wta(n, (char *)1, s_logcount);
        }
      }
    } else {
      {
#line 632
      scm_wta(n, (char *)1, s_logcount);
      }
    }
#line 633
    if (256 & (int )((scm_cell *)n)->car) {
      {
#line 633
      tmp = scm_difference((-1L << 2) + 2L, n);
#line 633
      tmp___0 = scm_logcount(tmp);
      }
#line 633
      return (tmp___0);
    }
#line 634
    ds = (unsigned short *)((scm_cell *)n)->cdr;
#line 635
    i = (size_t )(((scm_cell *)n)->car >> 16);
    {
#line 635
    while (1) {
      while_continue: /* CIL Label */ ;
#line 635
      tmp___1 = i;
#line 635
      i --;
#line 635
      if (! tmp___1) {
#line 635
        goto while_break;
      }
#line 636
      d = *(ds + i);
      {
#line 636
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 636
        if (! d) {
#line 636
          goto while_break___0;
        }
#line 636
        c += (unsigned long )scm_logtab[15 & (int )d];
#line 636
        d = (unsigned short )((int )d >> 4);
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 637
    return ((SCM )((c << 2) + 2UL));
  }
#line 642
  nn = n >> 2;
#line 642
  if (nn < 0L) {
#line 642
    nn = -1L - nn;
  }
  {
#line 643
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 643
    if (! nn) {
#line 643
      goto while_break___1;
    }
#line 643
    c += (unsigned long )scm_logtab[15L & nn];
#line 643
    nn >>= 4;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 644
  return ((SCM )((c << 2) + 2UL));
}
}
#line 647 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
char scm_ilentab[16]  = 
#line 647
  {      (char)0,      (char)1,      (char)2,      (char)2, 
        (char)3,      (char)3,      (char)3,      (char)3, 
        (char)4,      (char)4,      (char)4,      (char)4, 
        (char)4,      (char)4,      (char)4,      (char)4};
#line 648 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_integer_length[15]  = 
#line 648
  {      (char )'i',      (char )'n',      (char )'t',      (char )'e', 
        (char )'g',      (char )'e',      (char )'r',      (char )'-', 
        (char )'l',      (char )'e',      (char )'n',      (char )'g', 
        (char )'t',      (char )'h',      (char )'\000'};
#line 650 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_integer_length(SCM n ) 
{ 
  register unsigned long c ;
  register long nn ;
  unsigned int l ;
  unsigned short *ds ;
  unsigned short d ;
  SCM tmp ;
  SCM tmp___0 ;

  {
#line 654
  c = 0UL;
#line 656
  l = 4U;
#line 658
  if (! (2 & (int )n)) {
#line 660
    if (! (6 & (int )n)) {
#line 660
      if (! ((65279 & (int )((scm_cell *)n)->car) == 639)) {
        {
#line 660
        scm_wta(n, (char *)1, s_integer_length);
        }
      }
    } else {
      {
#line 660
      scm_wta(n, (char *)1, s_integer_length);
      }
    }
#line 661
    if (256 & (int )((scm_cell *)n)->car) {
      {
#line 661
      tmp = scm_difference((-1L << 2) + 2L, n);
#line 661
      tmp___0 = scm_integer_length(tmp);
      }
#line 661
      return (tmp___0);
    }
#line 662
    ds = (unsigned short *)((scm_cell *)n)->cdr;
#line 663
    c = (size_t )(((scm_cell *)n)->car >> 16) - 1UL;
#line 663
    d = *(ds + c);
#line 664
    c *= sizeof(unsigned short ) * 8UL;
    {
#line 664
    while (1) {
      while_continue: /* CIL Label */ ;
#line 664
      if (! d) {
#line 664
        goto while_break;
      }
#line 664
      c += 4UL;
#line 664
      l = (unsigned int )scm_ilentab[15 & (int )d];
#line 664
      d = (unsigned short )((int )d >> 4);
    }
    while_break: /* CIL Label */ ;
    }
#line 665
    return ((SCM )((((c - 4UL) + (unsigned long )l) << 2) + 2UL));
  }
#line 670
  nn = n >> 2;
#line 670
  if (nn < 0L) {
#line 670
    nn = -1L - nn;
  }
  {
#line 671
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 671
    if (! nn) {
#line 671
      goto while_break___0;
    }
#line 671
    c += 4UL;
#line 671
    l = (unsigned int )scm_ilentab[15L & nn];
#line 671
    nn >>= 4;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 672
  return ((SCM )((((c - 4UL) + (unsigned long )l) << 2) + 2UL));
}
}
#line 677 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
char s_bignum[7]  = {      (char )'b',      (char )'i',      (char )'g',      (char )'n', 
        (char )'u',      (char )'m',      (char )'\000'};
#line 679 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_mkbig(size_t nlen , int sign ) 
{ 
  SCM v ;
  char *tmp ;
  int tmp___0 ;

  {
#line 684
  v = (SCM )nlen;
#line 685
  if ((size_t )((v << 16) >> 16) != nlen) {
    {
#line 686
    scm_wta((SCM )((nlen << 2) + 2UL), (char *)11, s_bignum);
    }
  }
#line 687
  if (6 & (int )scm_freelist) {
    {
#line 687
    v = scm_gc_for_newcell();
    }
  } else {
#line 687
    v = scm_freelist;
#line 687
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 687
    scm_cells_allocated ++;
  }
  {
#line 688
  scm_ints_disabled = 1;
#line 689
  tmp = scm_must_malloc((long )(nlen * sizeof(unsigned short )), s_bignum);
#line 689
  ((scm_cell *)v)->cdr = (SCM )tmp;
  }
#line 690
  if (sign) {
#line 690
    tmp___0 = 895;
  } else {
#line 690
    tmp___0 = 639;
  }
#line 690
  ((scm_cell *)v)->car = (SCM )((nlen << 16) + (size_t )tmp___0);
#line 691
  scm_ints_disabled = 0;
#line 691
  scm_async_clock --;
#line 691
  if (0U == scm_async_clock) {
    {
#line 691
    scm_async_click();
    }
  }
#line 692
  return (v);
}
}
#line 696 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_big2inum(SCM b , size_t l ) 
{ 
  unsigned long num ;
  unsigned short *tmp ;
  size_t tmp___0 ;

  {
#line 701
  num = 0UL;
#line 702
  tmp = (unsigned short *)((scm_cell *)b)->cdr;
  {
#line 703
  while (1) {
    while_continue: /* CIL Label */ ;
#line 703
    tmp___0 = l;
#line 703
    l --;
#line 703
    if (! tmp___0) {
#line 703
      goto while_break;
    }
#line 703
    num = (num << sizeof(unsigned short ) * 8UL) + (unsigned long )*(tmp + l);
  }
  while_break: /* CIL Label */ ;
  }
#line 704
  if ((65535 & (int )((scm_cell *)b)->car) == 639) {
#line 705
    if (num <= (unsigned long )(9223372036854775807L >> 2)) {
#line 705
      return ((SCM )((num << 2) + 2UL));
    }
  } else
#line 707
  if (num <= (unsigned long )(- ((-0x7FFFFFFFFFFFFFFF-1) >> 2))) {
#line 707
    return ((SCM )((- num << 2) + 2UL));
  }
#line 708
  return (b);
}
}
#line 712 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
char s_adjbig[11]  = 
#line 712
  {      (char )'s',      (char )'c',      (char )'m',      (char )'_', 
        (char )'a',      (char )'d',      (char )'j',      (char )'b', 
        (char )'i',      (char )'g',      (char )'\000'};
#line 714 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_adjbig(SCM b , size_t nlen ) 
{ 
  long nsiz ;
  char *tmp ;

  {
#line 719
  nsiz = (long )nlen;
#line 720
  if ((size_t )((nsiz << 16) >> 16) != nlen) {
    {
#line 720
    scm_wta((nsiz << 2) + 2L, (char *)11, s_adjbig);
    }
  }
  {
#line 721
  scm_ints_disabled = 1;
#line 722
  tmp = scm_must_realloc((char *)((scm_cell *)b)->cdr, (long )((size_t )(((scm_cell *)b)->car >> 16) * sizeof(unsigned short )),
                         (long )((unsigned long )nsiz * sizeof(unsigned short )),
                         s_adjbig);
#line 722
  ((scm_cell *)b)->cdr = (SCM )((unsigned short *)tmp);
#line 725
  ((scm_cell *)b)->car = (nsiz << 16) + (long )(65535 & (int )((scm_cell *)b)->car);
#line 726
  scm_ints_disabled = 0;
#line 726
  scm_async_clock --;
  }
#line 726
  if (0U == scm_async_clock) {
    {
#line 726
    scm_async_click();
    }
  }
#line 727
  return (b);
}
}
#line 732 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_normbig(SCM b ) 
{ 
  size_t nlen ;
  unsigned short *zds ;
  size_t tmp ;
  SCM tmp___0 ;

  {
#line 737
  nlen = (size_t )(((scm_cell *)b)->car >> 16);
#line 741
  zds = (unsigned short *)((scm_cell *)b)->cdr;
  {
#line 742
  while (1) {
    while_continue: /* CIL Label */ ;
#line 742
    tmp = nlen;
#line 742
    nlen --;
#line 742
    if (tmp) {
#line 742
      if (! (! *(zds + nlen))) {
#line 742
        goto while_break;
      }
    } else {
#line 742
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 742
  nlen ++;
#line 743
  if ((nlen * (sizeof(unsigned short ) * 8UL)) / 8UL <= sizeof(SCM )) {
    {
#line 744
    b = scm_big2inum(b, nlen);
    }
#line 744
    if (2 & (int )b) {
#line 744
      return (b);
    }
  }
#line 745
  if ((size_t )(((scm_cell *)b)->car >> 16) == nlen) {
#line 745
    return (b);
  }
  {
#line 746
  tmp___0 = scm_adjbig(b, nlen);
  }
#line 746
  return (tmp___0);
}
}
#line 751 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_copybig(SCM b , int sign ) 
{ 
  size_t i ;
  SCM ans ;
  SCM tmp ;
  unsigned short *src ;
  unsigned short *dst ;
  size_t tmp___0 ;

  {
  {
#line 756
  i = (size_t )(((scm_cell *)b)->car >> 16);
#line 757
  tmp = scm_mkbig(i, sign);
#line 757
  ans = tmp;
#line 758
  src = (unsigned short *)((scm_cell *)b)->cdr;
#line 758
  dst = (unsigned short *)((scm_cell *)ans)->cdr;
  }
  {
#line 759
  while (1) {
    while_continue: /* CIL Label */ ;
#line 759
    tmp___0 = i;
#line 759
    i --;
#line 759
    if (! tmp___0) {
#line 759
      goto while_break;
    }
#line 759
    *(dst + i) = *(src + i);
  }
  while_break: /* CIL Label */ ;
  }
#line 760
  return (ans);
}
}
#line 765 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_long2big(long n ) 
{ 
  size_t i ;
  unsigned short *digits ;
  SCM ans ;
  SCM tmp ;
  size_t tmp___0 ;

  {
  {
#line 769
  i = (size_t )0;
#line 771
  tmp = scm_mkbig(((sizeof(long ) * 8UL + sizeof(unsigned short ) * 8UL) - 1UL) / (sizeof(unsigned short ) * 8UL),
                  n < 0L);
#line 771
  ans = tmp;
#line 772
  digits = (unsigned short *)((scm_cell *)ans)->cdr;
  }
#line 773
  if (n < 0L) {
#line 773
    n = - n;
  }
  {
#line 774
  while (1) {
    while_continue: /* CIL Label */ ;
#line 774
    if (! (i < ((sizeof(long ) * 8UL + sizeof(unsigned short ) * 8UL) - 1UL) / (sizeof(unsigned short ) * 8UL))) {
#line 774
      goto while_break;
    }
#line 775
    tmp___0 = i;
#line 775
    i ++;
#line 775
    *(digits + tmp___0) = (unsigned short )(n & ((1L << sizeof(unsigned short ) * 8UL) - 1L));
#line 776
    n = (long )((unsigned long )n >> sizeof(unsigned short ) * 8UL);
  }
  while_break: /* CIL Label */ ;
  }
#line 778
  return (ans);
}
}
#line 822 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_2ulong2big(unsigned long *np ) 
{ 
  unsigned long n ;
  size_t i ;
  unsigned short *digits ;
  SCM ans ;

  {
  {
#line 831
  ans = scm_mkbig(2UL * (((sizeof(long ) * 8UL + sizeof(unsigned short ) * 8UL) - 1UL) / (sizeof(unsigned short ) * 8UL)),
                  0);
#line 832
  digits = (unsigned short *)((scm_cell *)ans)->cdr;
#line 834
  n = *(np + 0);
#line 835
  i = (size_t )0;
  }
  {
#line 835
  while (1) {
    while_continue: /* CIL Label */ ;
#line 835
    if (! (i < ((sizeof(long ) * 8UL + sizeof(unsigned short ) * 8UL) - 1UL) / (sizeof(unsigned short ) * 8UL))) {
#line 835
      goto while_break;
    }
#line 837
    *(digits + i) = (unsigned short )(n & (unsigned long )((1L << sizeof(unsigned short ) * 8UL) - 1L));
#line 838
    n >>= sizeof(unsigned short ) * 8UL;
#line 835
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 840
  n = *(np + 1);
#line 841
  i = (size_t )0;
  {
#line 841
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 841
    if (! (i < ((sizeof(long ) * 8UL + sizeof(unsigned short ) * 8UL) - 1UL) / (sizeof(unsigned short ) * 8UL))) {
#line 841
      goto while_break___0;
    }
#line 843
    *(digits + (i + ((sizeof(long ) * 8UL + sizeof(unsigned short ) * 8UL) - 1UL) / (sizeof(unsigned short ) * 8UL))) = (unsigned short )(n & (unsigned long )((1L << sizeof(unsigned short ) * 8UL) - 1L));
#line 844
    n >>= sizeof(unsigned short ) * 8UL;
#line 841
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 846
  return (ans);
}
}
#line 851 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_ulong2big(unsigned long n ) 
{ 
  size_t i ;
  unsigned short *digits ;
  SCM ans ;
  SCM tmp ;
  size_t tmp___0 ;

  {
  {
#line 855
  i = (size_t )0;
#line 857
  tmp = scm_mkbig(((sizeof(long ) * 8UL + sizeof(unsigned short ) * 8UL) - 1UL) / (sizeof(unsigned short ) * 8UL),
                  0);
#line 857
  ans = tmp;
#line 858
  digits = (unsigned short *)((scm_cell *)ans)->cdr;
  }
  {
#line 859
  while (1) {
    while_continue: /* CIL Label */ ;
#line 859
    if (! (i < ((sizeof(long ) * 8UL + sizeof(unsigned short ) * 8UL) - 1UL) / (sizeof(unsigned short ) * 8UL))) {
#line 859
      goto while_break;
    }
#line 860
    tmp___0 = i;
#line 860
    i ++;
#line 860
    *(digits + tmp___0) = (unsigned short )(n & (unsigned long )((1L << sizeof(unsigned short ) * 8UL) - 1L));
#line 861
    n >>= sizeof(unsigned short ) * 8UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 863
  return (ans);
}
}
#line 868 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
int scm_bigcomp(SCM x , SCM y ) 
{ 
  int xsign ;
  int ysign ;
  size_t xlen ;
  size_t ylen ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 873
  xsign = 256 & (int )((scm_cell *)x)->car;
#line 874
  ysign = 256 & (int )((scm_cell *)y)->car;
#line 876
  if (ysign < xsign) {
#line 876
    return (1);
  }
#line 877
  if (ysign > xsign) {
#line 877
    return (-1);
  }
#line 878
  ylen = (size_t )(((scm_cell *)y)->car >> 16);
#line 878
  xlen = (size_t )(((scm_cell *)x)->car >> 16);
#line 878
  if (ylen > xlen) {
#line 878
    if (xsign) {
#line 878
      tmp = -1;
    } else {
#line 878
      tmp = 1;
    }
#line 878
    return (tmp);
  }
#line 879
  if (ylen < xlen) {
#line 879
    if (xsign) {
#line 879
      tmp___0 = 1;
    } else {
#line 879
      tmp___0 = -1;
    }
#line 879
    return (tmp___0);
  }
  {
#line 880
  while (1) {
    while_continue: /* CIL Label */ ;
#line 880
    tmp___1 = xlen;
#line 880
    xlen --;
#line 880
    if (tmp___1) {
#line 880
      if (! ((int )*((unsigned short *)((scm_cell *)y)->cdr + xlen) == (int )*((unsigned short *)((scm_cell *)x)->cdr + xlen))) {
#line 880
        goto while_break;
      }
    } else {
#line 880
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 881
  if (0xffffffffffffffffUL == xlen) {
#line 881
    return (0);
  }
#line 882
  if ((int )*((unsigned short *)((scm_cell *)y)->cdr + xlen) > (int )*((unsigned short *)((scm_cell *)x)->cdr + xlen)) {
#line 882
    if (xsign) {
#line 882
      tmp___2 = -1;
    } else {
#line 882
      tmp___2 = 1;
    }
#line 882
    tmp___4 = tmp___2;
  } else {
#line 882
    if (xsign) {
#line 882
      tmp___3 = 1;
    } else {
#line 882
      tmp___3 = -1;
    }
#line 882
    tmp___4 = tmp___3;
  }
#line 882
  return (tmp___4);
}
}
#line 889 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
long scm_pseudolong(long x ) 
{ 
  union __anonunion_p_26 p ;
  size_t i ;
  size_t tmp ;
  void *__cil_tmp5 ;
  void *__cil_tmp6 ;

  {
#line 897
  i = (size_t )0;
#line 898
  if (x < 0L) {
#line 898
    x = - x;
  }
  {
#line 899
  while (1) {
    while_continue: /* CIL Label */ ;
#line 899
    if (! (i < ((sizeof(long ) * 8UL + sizeof(unsigned short ) * 8UL) - 1UL) / (sizeof(unsigned short ) * 8UL))) {
#line 899
      goto while_break;
    }
#line 899
    tmp = i;
#line 899
    i ++;
#line 899
    p.bd[tmp] = (unsigned short )(x & ((1L << sizeof(unsigned short ) * 8UL) - 1L));
#line 899
    x >>= sizeof(unsigned short ) * 8UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 901
  return (p.l);
}
}
#line 920 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_addbig(unsigned short *x , size_t nx , int xsgn , SCM bigy , int sgny ) 
{ 
  long num ;
  size_t i ;
  size_t ny ;
  SCM z ;
  SCM tmp ;
  unsigned short *zds ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  SCM tmp___5 ;

  {
  {
#line 930
  num = 0L;
#line 931
  i = (size_t )0;
#line 931
  ny = (size_t )(((scm_cell *)bigy)->car >> 16);
#line 932
  tmp = scm_copybig(bigy, (256 & (int )((scm_cell *)bigy)->car) ^ sgny);
#line 932
  z = tmp;
#line 933
  zds = (unsigned short *)((scm_cell *)z)->cdr;
  }
#line 934
  if (xsgn ^ (256 & (int )((scm_cell *)z)->car)) {
    {
#line 935
    while (1) {
      while_continue: /* CIL Label */ ;
#line 936
      num += (long )*(zds + i) - (long )*(x + i);
#line 937
      if (num < 0L) {
#line 937
        *(zds + i) = (unsigned short )(num + (1L << sizeof(unsigned short ) * 8UL));
#line 937
        num = -1L;
      } else {
#line 938
        *(zds + i) = (unsigned short )(num & ((1L << sizeof(unsigned short ) * 8UL) - 1L));
#line 938
        num = 0L;
      }
#line 935
      i ++;
#line 935
      if (! (i < nx)) {
#line 935
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 940
    if (num) {
#line 940
      if (nx == ny) {
#line 941
        num = 1L;
#line 941
        i = (size_t )0;
#line 942
        ((scm_cell *)z)->car ^= 256L;
        {
#line 943
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 944
          num += ((1L << sizeof(unsigned short ) * 8UL) - 1L) - (long )*(zds + i);
#line 945
          tmp___0 = i;
#line 945
          i ++;
#line 945
          *(zds + tmp___0) = (unsigned short )(num & ((1L << sizeof(unsigned short ) * 8UL) - 1L));
#line 946
          num >>= sizeof(unsigned short ) * 8UL;
#line 943
          if (! (i < ny)) {
#line 943
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
#line 940
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 949
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 949
        if (! (i < ny)) {
#line 949
          goto while_break___1;
        }
#line 950
        num += (long )*(zds + i);
#line 951
        if (num < 0L) {
#line 951
          tmp___1 = i;
#line 951
          i ++;
#line 951
          *(zds + tmp___1) = (unsigned short )(num + (1L << sizeof(unsigned short ) * 8UL));
#line 951
          num = -1L;
        } else {
#line 952
          tmp___2 = i;
#line 952
          i ++;
#line 952
          *(zds + tmp___2) = (unsigned short )(num & ((1L << sizeof(unsigned short ) * 8UL) - 1L));
#line 952
          num = 0L;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 955
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 956
      num += (long )*(zds + i) + (long )*(x + i);
#line 957
      tmp___3 = i;
#line 957
      i ++;
#line 957
      *(zds + tmp___3) = (unsigned short )(num & ((1L << sizeof(unsigned short ) * 8UL) - 1L));
#line 958
      num >>= sizeof(unsigned short ) * 8UL;
#line 955
      if (! (i < nx)) {
#line 955
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 960
    if (! num) {
#line 960
      return (z);
    }
    {
#line 961
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 961
      if (! (i < ny)) {
#line 961
        goto while_break___3;
      }
#line 962
      num += (long )*(zds + i);
#line 963
      tmp___4 = i;
#line 963
      i ++;
#line 963
      *(zds + tmp___4) = (unsigned short )(num & ((1L << sizeof(unsigned short ) * 8UL) - 1L));
#line 964
      num >>= sizeof(unsigned short ) * 8UL;
#line 965
      if (! num) {
#line 965
        return (z);
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 967
    if (num) {
      {
#line 967
      z = scm_adjbig(z, ny + 1UL);
#line 967
      *((unsigned short *)((scm_cell *)z)->cdr + ny) = (unsigned short )num;
      }
#line 967
      return (z);
    }
  }
  {
#line 969
  tmp___5 = scm_normbig(z);
  }
#line 969
  return (tmp___5);
}
}
#line 973 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_mulbig(unsigned short *x , size_t nx , unsigned short *y , size_t ny , int sgn ) 
{ 
  size_t i ;
  size_t j ;
  unsigned long n ;
  SCM z ;
  SCM tmp ;
  unsigned short *zds ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  SCM tmp___2 ;

  {
  {
#line 981
  i = (size_t )0;
#line 981
  j = nx + ny;
#line 982
  n = 0UL;
#line 983
  tmp = scm_mkbig(j, sgn);
#line 983
  z = tmp;
#line 984
  zds = (unsigned short *)((scm_cell *)z)->cdr;
  }
  {
#line 985
  while (1) {
    while_continue: /* CIL Label */ ;
#line 985
    tmp___0 = j;
#line 985
    j --;
#line 985
    if (! tmp___0) {
#line 985
      goto while_break;
    }
#line 985
    *(zds + j) = (unsigned short)0;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 986
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 987
    j = (size_t )0;
#line 988
    if (*(x + i)) {
      {
#line 989
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 990
        n += (unsigned long )*(zds + (i + j)) + (unsigned long )*(x + i) * (unsigned long )*(y + j);
#line 991
        tmp___1 = j;
#line 991
        j ++;
#line 991
        *(zds + (i + tmp___1)) = (unsigned short )(n & (unsigned long )((1L << sizeof(unsigned short ) * 8UL) - 1L));
#line 992
        n >>= sizeof(unsigned short ) * 8UL;
#line 989
        if (! (j < ny)) {
#line 989
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 994
      if (n) {
#line 994
        *(zds + (i + j)) = (unsigned short )n;
#line 994
        n = 0UL;
      }
    }
#line 986
    i ++;
#line 986
    if (! (i < nx)) {
#line 986
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 997
  tmp___2 = scm_normbig(z);
  }
#line 997
  return (tmp___2);
}
}
#line 1001 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
unsigned int scm_divbigdig(unsigned short *ds , size_t h , unsigned short div___0 ) 
{ 
  register unsigned long t2 ;
  size_t tmp ;

  {
#line 1007
  t2 = 0UL;
  {
#line 1008
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1008
    tmp = h;
#line 1008
    h --;
#line 1008
    if (! tmp) {
#line 1008
      goto while_break;
    }
#line 1009
    t2 = (t2 << sizeof(unsigned short ) * 8UL) + (unsigned long )*(ds + h);
#line 1010
    *(ds + h) = (unsigned short )(t2 / (unsigned long )div___0);
#line 1011
    t2 %= (unsigned long )div___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 1013
  return ((unsigned int )t2);
}
}
#line 1018 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_divbigint(SCM x , long z , int sgn , int mode ) 
{ 
  register unsigned long t2 ;
  register unsigned short *ds ;
  size_t nd ;
  size_t tmp ;
  unsigned long tmp___0 ;
  unsigned long t2___0 ;
  long tmp___1 ;
  SCM tmp___2 ;

  {
#line 1025
  if (z < 0L) {
#line 1025
    z = - z;
  }
#line 1026
  if (z < 1L << sizeof(unsigned short ) * 8UL) {
#line 1027
    t2 = 0UL;
#line 1028
    ds = (unsigned short *)((scm_cell *)x)->cdr;
#line 1029
    nd = (size_t )(((scm_cell *)x)->car >> 16);
    {
#line 1030
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1030
      tmp = nd;
#line 1030
      nd --;
#line 1030
      if (! tmp) {
#line 1030
        goto while_break;
      }
#line 1030
      t2 = ((t2 << sizeof(unsigned short ) * 8UL) + (unsigned long )*(ds + nd)) % (unsigned long )z;
    }
    while_break: /* CIL Label */ ;
    }
#line 1031
    if (mode) {
#line 1031
      if (t2) {
#line 1031
        t2 = (unsigned long )z - t2;
      }
    }
#line 1032
    if (sgn) {
#line 1032
      tmp___0 = - t2;
    } else {
#line 1032
      tmp___0 = t2;
    }
#line 1032
    return ((SCM )((tmp___0 << 2) + 2UL));
  }
  {
#line 1036
  tmp___1 = scm_pseudolong(z);
#line 1036
  t2___0 = (unsigned long )tmp___1;
#line 1037
  tmp___2 = scm_divbigbig((unsigned short *)((scm_cell *)x)->cdr, (size_t )(((scm_cell *)x)->car >> 16),
                          (unsigned short *)(& t2___0), ((sizeof(long ) * 8UL + sizeof(unsigned short ) * 8UL) - 1UL) / (sizeof(unsigned short ) * 8UL),
                          sgn, mode);
  }
#line 1037
  return (tmp___2);
}
}
#line 1048 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_divbigbig(unsigned short *x , size_t nx , unsigned short *y , size_t ny ,
                  int sgn , int modes ) 
{ 
  size_t i ;
  size_t j ;
  long num ;
  unsigned long t2 ;
  SCM z ;
  SCM newy ;
  unsigned short d ;
  unsigned short qhat ;
  unsigned short *zds ;
  unsigned short *yds ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  SCM tmp___6 ;

  {
#line 1062
  i = (size_t )0;
#line 1062
  j = (size_t )0;
#line 1063
  num = 0L;
#line 1064
  t2 = 0UL;
#line 1066
  d = (unsigned short)0;
#line 1068
  if (nx < ny) {
    {
#line 1070
    if (modes == 0) {
#line 1070
      goto case_0;
    }
#line 1074
    if (modes == 1) {
#line 1074
      goto case_1;
    }
#line 1087
    if (modes == 2) {
#line 1087
      goto case_2;
    }
#line 1088
    if (modes == 3) {
#line 1088
      goto case_3;
    }
#line 1069
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 1071
    z = scm_mkbig(nx, sgn);
#line 1071
    zds = (unsigned short *)((scm_cell *)z)->cdr;
    }
    {
#line 1072
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1072
      *(zds + i) = *(x + i);
#line 1072
      i ++;
#line 1072
      if (! (i < nx)) {
#line 1072
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1073
    return (z);
    case_1: /* CIL Label */ 
    {
#line 1075
    z = scm_mkbig(ny, sgn);
#line 1075
    zds = (unsigned short *)((scm_cell *)z)->cdr;
    }
    {
#line 1076
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1077
      num += (long )*(y + i) - (long )*(x + i);
#line 1078
      if (num < 0L) {
#line 1078
        *(zds + i) = (unsigned short )(num + (1L << sizeof(unsigned short ) * 8UL));
#line 1078
        num = -1L;
      } else {
#line 1079
        *(zds + i) = (unsigned short )num;
#line 1079
        num = 0L;
      }
#line 1076
      i ++;
#line 1076
      if (! (i < nx)) {
#line 1076
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1081
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1081
      if (! (i < ny)) {
#line 1081
        goto while_break___1;
      }
#line 1082
      num += (long )*(y + i);
#line 1083
      if (num < 0L) {
#line 1083
        tmp = i;
#line 1083
        i ++;
#line 1083
        *(zds + tmp) = (unsigned short )(num + (1L << sizeof(unsigned short ) * 8UL));
#line 1083
        num = -1L;
      } else {
#line 1084
        tmp___0 = i;
#line 1084
        i ++;
#line 1084
        *(zds + tmp___0) = (unsigned short )num;
#line 1084
        num = 0L;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1086
    goto doadj;
    case_2: /* CIL Label */ 
#line 1087
    return ((SCM )2);
    case_3: /* CIL Label */ 
#line 1088
    return ((SCM )0);
    switch_break: /* CIL Label */ ;
    }
  }
#line 1091
  if (nx == ny) {
#line 1091
    tmp___1 = nx + 2UL;
  } else {
#line 1091
    tmp___1 = nx + 1UL;
  }
  {
#line 1091
  z = scm_mkbig(tmp___1, sgn);
#line 1091
  zds = (unsigned short *)((scm_cell *)z)->cdr;
  }
#line 1092
  if (nx == ny) {
#line 1092
    *(zds + (nx + 1UL)) = (unsigned short)0;
  }
  {
#line 1093
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1093
    if (! (! *(y + (ny - 1UL)))) {
#line 1093
      goto while_break___2;
    }
#line 1093
    ny --;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1094
  if ((long )*(y + (ny - 1UL)) < (1L << sizeof(unsigned short ) * 8UL) >> 1) {
    {
#line 1095
    d = (unsigned short )((1L << sizeof(unsigned short ) * 8UL) / (long )((int )*(y + (ny - 1UL)) + 1));
#line 1096
    newy = scm_mkbig(ny, 0);
#line 1096
    yds = (unsigned short *)((scm_cell *)newy)->cdr;
    }
    {
#line 1097
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1097
      if (! (j < ny)) {
#line 1097
        goto while_break___3;
      }
#line 1098
      t2 += (unsigned long )*(y + j) * (unsigned long )d;
#line 1098
      tmp___2 = j;
#line 1098
      j ++;
#line 1098
      *(yds + tmp___2) = (unsigned short )(t2 & (unsigned long )((1L << sizeof(unsigned short ) * 8UL) - 1L));
#line 1098
      t2 >>= sizeof(unsigned short ) * 8UL;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1099
    y = yds;
#line 1099
    j = (size_t )0;
#line 1099
    t2 = 0UL;
    {
#line 1100
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1100
      if (! (j < nx)) {
#line 1100
        goto while_break___4;
      }
#line 1101
      t2 += (unsigned long )*(x + j) * (unsigned long )d;
#line 1101
      tmp___3 = j;
#line 1101
      j ++;
#line 1101
      *(zds + tmp___3) = (unsigned short )(t2 & (unsigned long )((1L << sizeof(unsigned short ) * 8UL) - 1L));
#line 1101
      t2 >>= sizeof(unsigned short ) * 8UL;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1102
    *(zds + j) = (unsigned short )t2;
  } else {
#line 1104
    j = nx;
#line 1104
    *(zds + j) = (unsigned short)0;
    {
#line 1104
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1104
      tmp___4 = j;
#line 1104
      j --;
#line 1104
      if (! tmp___4) {
#line 1104
        goto while_break___5;
      }
#line 1104
      *(zds + j) = *(x + j);
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 1105
  if (nx == ny) {
#line 1105
    j = nx + 1UL;
  } else {
#line 1105
    j = nx;
  }
  {
#line 1106
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 1107
    if ((int )*(zds + j) == (int )*(y + (ny - 1UL))) {
#line 1107
      qhat = (unsigned short )((1L << sizeof(unsigned short ) * 8UL) - 1L);
    } else {
#line 1108
      qhat = (unsigned short )((((unsigned long )*(zds + j) << sizeof(unsigned short ) * 8UL) + (unsigned long )*(zds + (j - 1UL))) / (unsigned long )*(y + (ny - 1UL)));
    }
#line 1109
    if (! qhat) {
#line 1109
      goto __Cont;
    }
#line 1110
    i = (size_t )0;
#line 1110
    num = 0L;
#line 1110
    t2 = 0UL;
    {
#line 1111
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1112
      t2 += (unsigned long )*(y + i) * (unsigned long )qhat;
#line 1113
      num = (long )((unsigned long )num + ((unsigned long )*(zds + ((j - ny) + i)) - (t2 & (unsigned long )((1L << sizeof(unsigned short ) * 8UL) - 1L))));
#line 1114
      if (num < 0L) {
#line 1114
        *(zds + ((j - ny) + i)) = (unsigned short )(num + (1L << sizeof(unsigned short ) * 8UL));
#line 1114
        num = -1L;
      } else {
#line 1115
        *(zds + ((j - ny) + i)) = (unsigned short )num;
#line 1115
        num = 0L;
      }
#line 1116
      t2 >>= sizeof(unsigned short ) * 8UL;
#line 1111
      i ++;
#line 1111
      if (! (i < ny)) {
#line 1111
        goto while_break___7;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
#line 1118
    num = (long )((unsigned long )num + ((unsigned long )*(zds + ((j - ny) + i)) - t2));
    {
#line 1119
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1119
      if (! num) {
#line 1119
        goto while_break___8;
      }
#line 1120
      i = (size_t )0;
#line 1120
      num = 0L;
#line 1120
      qhat = (unsigned short )((int )qhat - 1);
      {
#line 1121
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 1122
        num += (long )*(zds + ((j - ny) + i)) + (long )*(y + i);
#line 1123
        *(zds + ((j - ny) + i)) = (unsigned short )(num & ((1L << sizeof(unsigned short ) * 8UL) - 1L));
#line 1124
        num >>= sizeof(unsigned short ) * 8UL;
#line 1121
        i ++;
#line 1121
        if (! (i < ny)) {
#line 1121
          goto while_break___9;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
#line 1126
      num --;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 1128
    if (modes & 2) {
#line 1128
      *(zds + j) = qhat;
    }
    __Cont: /* CIL Label */ 
#line 1106
    j --;
#line 1106
    if (! (j >= ny)) {
#line 1106
      goto while_break___6;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 1131
  if (modes == 3) {
#line 1131
    goto case_3___0;
  }
#line 1133
  if (modes == 2) {
#line 1133
    goto case_2___0;
  }
#line 1138
  if (modes == 1) {
#line 1138
    goto case_1___0;
  }
#line 1146
  if (modes == 0) {
#line 1146
    goto case_0___0;
  }
#line 1130
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
#line 1132
  j = ny;
  {
#line 1132
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 1132
    if (j) {
#line 1132
      if (! (! *(zds + (j - 1UL)))) {
#line 1132
        goto while_break___10;
      }
    } else {
#line 1132
      goto while_break___10;
    }
#line 1132
    j --;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 1132
  if (j) {
#line 1132
    return ((SCM )0);
  }
  case_2___0: /* CIL Label */ 
#line 1134
  if (nx == ny) {
#line 1134
    tmp___5 = nx + 2UL;
  } else {
#line 1134
    tmp___5 = nx + 1UL;
  }
#line 1134
  j = tmp___5 - ny;
#line 1135
  i = (size_t )0;
  {
#line 1135
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 1135
    if (! (i < j)) {
#line 1135
      goto while_break___11;
    }
#line 1135
    *(zds + i) = *(zds + (i + ny));
#line 1135
    i ++;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 1136
  ny = i;
#line 1137
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 1139
  i = (size_t )0;
#line 1139
  num = 0L;
#line 1139
  j = (size_t )0;
  {
#line 1140
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 1140
    num += (long )((int )*(y + i) - (int )*(zds + i));
#line 1141
    j |= (unsigned long )*(zds + i);
#line 1142
    if (num < 0L) {
#line 1142
      *(zds + i) = (unsigned short )(num + (1L << sizeof(unsigned short ) * 8UL));
#line 1142
      num = -1L;
    } else {
#line 1143
      *(zds + i) = (unsigned short )num;
#line 1143
      num = 0L;
    }
#line 1140
    i ++;
#line 1140
    if (! (i < ny)) {
#line 1140
      goto while_break___12;
    }
  }
  while_break___12: /* CIL Label */ ;
  }
#line 1145
  if (! j) {
#line 1145
    return ((SCM )2);
  }
  case_0___0: /* CIL Label */ 
#line 1147
  if (d) {
    {
#line 1147
    scm_divbigdig(zds, ny, d);
    }
  }
  switch_break___0: /* CIL Label */ ;
  }
  doadj: 
#line 1150
  j = ny;
  {
#line 1150
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 1150
    if (j) {
#line 1150
      if (! (! *(zds + (j - 1UL)))) {
#line 1150
        goto while_break___13;
      }
    } else {
#line 1150
      goto while_break___13;
    }
#line 1150
    j --;
  }
  while_break___13: /* CIL Label */ ;
  }
#line 1151
  if (j * (sizeof(unsigned short ) * 8UL) <= sizeof(SCM ) * 8UL) {
    {
#line 1152
    z = scm_big2inum(z, j);
    }
#line 1152
    if (2 & (int )z) {
#line 1152
      return (z);
    }
  }
  {
#line 1153
  tmp___6 = scm_adjbig(z, j);
  }
#line 1153
  return (tmp___6);
}
}
#line 1163 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
int scm_dblprec  ;
#line 1164 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static double fx[21]  = 
#line 1164
  {      0.0,      5e-1,      5e-2,      5e-3, 
        5e-4,      5e-5,      5e-6,      5e-7, 
        5e-8,      5e-9,      5e-10,      5e-11, 
        5e-12,      5e-13,      5e-14,      5e-15, 
        5e-16,      5e-17,      5e-18,      5e-19, 
        5e-20};
#line 1172
static size_t idbl2str(double f , char *a ) ;
#line 1174 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static size_t idbl2str(double f , char *a ) 
{ 
  int efmt ;
  int dpt ;
  int d ;
  int i ;
  int wp ;
  size_t ch ;
  int exp___0 ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;

  {
#line 1179
  wp = scm_dblprec;
#line 1180
  ch = (size_t )0;
#line 1181
  exp___0 = 0;
#line 1183
  if (f == 0.0) {
#line 1183
    goto zero;
  }
#line 1184
  if (f < 0.0) {
#line 1184
    f = - f;
#line 1184
    tmp = ch;
#line 1184
    ch ++;
#line 1184
    *(a + tmp) = (char )'-';
  } else
#line 1185
  if (! (f > 0.0)) {
#line 1186
    goto funny;
  }
#line 1187
  if (f == f / (double )2) {
#line 1189
    if (ch == 0UL) {
#line 1189
      tmp___0 = ch;
#line 1189
      ch ++;
#line 1189
      *(a + tmp___0) = (char )'+';
    }
    funny: 
#line 1190
    tmp___1 = ch;
#line 1190
    ch ++;
#line 1190
    *(a + tmp___1) = (char )'#';
#line 1190
    tmp___2 = ch;
#line 1190
    ch ++;
#line 1190
    *(a + tmp___2) = (char )'.';
#line 1190
    tmp___3 = ch;
#line 1190
    ch ++;
#line 1190
    *(a + tmp___3) = (char )'#';
#line 1190
    return (ch);
  }
  {
#line 1194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1194
    if (! (f < 1.0)) {
#line 1194
      goto while_break;
    }
#line 1194
    f *= 10.0;
#line 1194
    tmp___4 = exp___0;
#line 1194
    exp___0 --;
#line 1194
    if (tmp___4 < -307) {
#line 1194
      goto funny;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1195
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1195
    if (! (f > 10.0)) {
#line 1195
      goto while_break___0;
    }
#line 1195
    f *= 0.10;
#line 1195
    tmp___5 = exp___0;
#line 1195
    exp___0 ++;
#line 1195
    if (tmp___5 > 308) {
#line 1195
      goto funny;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1200
  if (f + fx[wp] >= 10.0) {
#line 1200
    f = 1.0;
#line 1200
    exp___0 ++;
  }
  zero: 
#line 1207
  if (exp___0 < -3) {
#line 1207
    tmp___6 = 1;
  } else
#line 1207
  if (exp___0 > wp + 2) {
#line 1207
    tmp___6 = 1;
  } else {
#line 1207
    tmp___6 = 0;
  }
#line 1207
  efmt = tmp___6;
#line 1208
  if (! efmt) {
#line 1209
    if (exp___0 < 0) {
#line 1210
      tmp___7 = ch;
#line 1210
      ch ++;
#line 1210
      *(a + tmp___7) = (char )'0';
#line 1211
      tmp___8 = ch;
#line 1211
      ch ++;
#line 1211
      *(a + tmp___8) = (char )'.';
#line 1212
      dpt = exp___0;
      {
#line 1213
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1213
        dpt ++;
#line 1213
        if (! dpt) {
#line 1213
          goto while_break___1;
        }
#line 1213
        tmp___9 = ch;
#line 1213
        ch ++;
#line 1213
        *(a + tmp___9) = (char )'0';
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
#line 1215
      dpt = exp___0 + 1;
    }
  } else {
#line 1217
    dpt = 1;
  }
  {
#line 1220
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1221
    d = (int )f;
#line 1222
    f -= (double )d;
#line 1223
    tmp___10 = ch;
#line 1223
    ch ++;
#line 1223
    *(a + tmp___10) = (char )(d + 48);
#line 1224
    if (f < fx[wp]) {
#line 1224
      goto while_break___2;
    }
#line 1225
    if (f + fx[wp] >= 1.0) {
#line 1226
      *(a + (ch - 1UL)) = (char )((int )*(a + (ch - 1UL)) + 1);
#line 1227
      goto while_break___2;
    }
#line 1229
    f *= 10.0;
#line 1230
    dpt --;
#line 1230
    if (! dpt) {
#line 1230
      tmp___11 = ch;
#line 1230
      ch ++;
#line 1230
      *(a + tmp___11) = (char )'.';
    }
#line 1220
    tmp___12 = wp;
#line 1220
    wp --;
#line 1220
    if (! tmp___12) {
#line 1220
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1233
  if (dpt > 0) {
#line 1235
    if (dpt > 4) {
#line 1235
      if (exp___0 > 6) {
#line 1236
        if ((int )*(a + 0) == 45) {
#line 1236
          d = 2;
        } else {
#line 1236
          d = 1;
        }
#line 1237
        tmp___13 = ch;
#line 1237
        ch ++;
#line 1237
        i = (int )tmp___13;
        {
#line 1237
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1237
          if (! (i > d)) {
#line 1237
            goto while_break___3;
          }
#line 1238
          *(a + i) = *(a + (i - 1));
#line 1237
          i --;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 1239
        *(a + d) = (char )'.';
#line 1240
        efmt = 1;
      } else {
#line 1235
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 1244
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1244
        dpt --;
#line 1244
        if (! dpt) {
#line 1244
          goto while_break___4;
        }
#line 1244
        tmp___14 = ch;
#line 1244
        ch ++;
#line 1244
        *(a + tmp___14) = (char )'0';
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1245
      tmp___15 = ch;
#line 1245
      ch ++;
#line 1245
      *(a + tmp___15) = (char )'.';
    }
  }
#line 1247
  if ((int )*(a + (ch - 1UL)) == 46) {
#line 1247
    tmp___16 = ch;
#line 1247
    ch ++;
#line 1247
    *(a + tmp___16) = (char )'0';
  }
#line 1248
  if (efmt) {
#line 1248
    if (exp___0) {
#line 1249
      tmp___17 = ch;
#line 1249
      ch ++;
#line 1249
      *(a + tmp___17) = (char )'e';
#line 1250
      if (exp___0 < 0) {
#line 1251
        exp___0 = - exp___0;
#line 1252
        tmp___18 = ch;
#line 1252
        ch ++;
#line 1252
        *(a + tmp___18) = (char )'-';
      }
#line 1254
      i = 10;
      {
#line 1254
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1254
        if (! (i <= exp___0)) {
#line 1254
          goto while_break___5;
        }
#line 1254
        i *= 10;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1255
      i /= 10;
      {
#line 1255
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1255
        if (! i) {
#line 1255
          goto while_break___6;
        }
#line 1256
        tmp___19 = ch;
#line 1256
        ch ++;
#line 1256
        *(a + tmp___19) = (char )(exp___0 / i + 48);
#line 1257
        exp___0 %= i;
#line 1255
        i /= 10;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
  }
#line 1260
  return (ch);
}
}
#line 1264
static size_t iflo2str(SCM flt , char *str ) ;
#line 1266 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static size_t iflo2str(SCM flt , char *str ) 
{ 
  size_t i ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 1276
  i = idbl2str(*(((scm_dbl *)flt)->real), str);
  }
#line 1277
  if (((scm_cell *)flt)->car == ((383L | (1L << 16)) | (2L << 16))) {
#line 1278
    if ((double )0 <= *((double *)((char *)((scm_cell *)flt)->cdr + sizeof(double )))) {
#line 1279
      tmp = i;
#line 1279
      i ++;
#line 1279
      *(str + tmp) = (char )'+';
    }
    {
#line 1280
    tmp___0 = idbl2str(*((double *)((char *)((scm_cell *)flt)->cdr + sizeof(double ))),
                       str + i);
#line 1280
    i += tmp___0;
#line 1281
    tmp___1 = i;
#line 1281
    i ++;
#line 1281
    *(str + tmp___1) = (char )'i';
    }
  }
#line 1283
  return (i);
}
}
#line 1288 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
size_t scm_iint2str(long num , int rad , char *p ) 
{ 
  size_t j ;
  register int i ;
  register int d ;
  register long n ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1295
  i = 1;
#line 1296
  n = num;
#line 1297
  if (n < 0L) {
#line 1297
    n = - n;
#line 1297
    i ++;
  }
#line 1298
  n /= (long )rad;
  {
#line 1298
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1298
    if (! (n > 0L)) {
#line 1298
      goto while_break;
    }
#line 1298
    i ++;
#line 1298
    n /= (long )rad;
  }
  while_break: /* CIL Label */ ;
  }
#line 1299
  j = (size_t )i;
#line 1300
  n = num;
#line 1301
  if (n < 0L) {
#line 1301
    n = - n;
#line 1301
    tmp = p;
#line 1301
    p ++;
#line 1301
    *tmp = (char )'-';
#line 1301
    i --;
  }
  {
#line 1302
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1302
    tmp___1 = i;
#line 1302
    i --;
#line 1302
    if (! tmp___1) {
#line 1302
      goto while_break___0;
    }
#line 1303
    d = (int )(n % (long )rad);
#line 1304
    n /= (long )rad;
#line 1305
    if (d < 10) {
#line 1305
      tmp___0 = '0';
    } else {
#line 1305
      tmp___0 = 87;
    }
#line 1305
    *(p + i) = (char )(d + tmp___0);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1307
  return (j);
}
}
#line 1313
static SCM big2str(SCM b , unsigned int radix ) ;
#line 1315 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static SCM big2str(SCM b , unsigned int radix ) 
{ 
  SCM t ;
  SCM tmp ;
  register unsigned short *ds ;
  size_t i ;
  size_t j ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  size_t k ;
  size_t radct ;
  size_t ch ;
  unsigned short radpow ;
  unsigned short radmod ;
  SCM ss ;
  SCM tmp___2 ;
  char *s___0 ;
  char c ;
  unsigned int tmp___3 ;

  {
  {
#line 1320
  tmp = scm_copybig(b, 0);
#line 1320
  t = tmp;
#line 1321
  ds = (unsigned short *)((scm_cell *)t)->cdr;
#line 1322
  i = (size_t )(((scm_cell *)t)->car >> 16);
  }
#line 1323
  if (radix == 16U) {
#line 1323
    tmp___1 = ((sizeof(unsigned short ) * 8UL) * i) / 4UL + 2UL;
  } else {
#line 1323
    if (radix >= 10U) {
#line 1323
      tmp___0 = (((sizeof(unsigned short ) * 8UL) * i) * 241UL) / 800UL + 2UL;
    } else {
#line 1323
      tmp___0 = (sizeof(unsigned short ) * 8UL) * i + 2UL;
    }
#line 1323
    tmp___1 = tmp___0;
  }
  {
#line 1323
  j = tmp___1;
#line 1326
  k = (size_t )0;
#line 1327
  radct = (size_t )0;
#line 1329
  radpow = (unsigned short)1;
#line 1329
  radmod = (unsigned short)0;
#line 1330
  tmp___2 = scm_makstr((long )j, 0);
#line 1330
  ss = tmp___2;
#line 1331
  s___0 = (char *)((scm_cell *)ss)->cdr;
  }
  {
#line 1332
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1332
    if (! ((long )radpow * (long )radix < 1L << sizeof(unsigned short ) * 8UL)) {
#line 1332
      goto while_break;
    }
#line 1333
    radpow = (unsigned short )((unsigned int )radpow * radix);
#line 1334
    radct ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1336
  if (895 == (65535 & (int )((scm_cell *)b)->car)) {
#line 1336
    *(s___0 + 0) = (char )'-';
  } else {
#line 1336
    *(s___0 + 0) = (char )'+';
  }
  {
#line 1337
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1337
    if (i) {
#line 1337
      goto _L;
    } else
#line 1337
    if (radmod) {
      _L: /* CIL Label */ 
#line 1337
      if (! j) {
#line 1337
        goto while_break___0;
      }
    } else {
#line 1337
      goto while_break___0;
    }
#line 1338
    if (k == 0UL) {
      {
#line 1339
      tmp___3 = scm_divbigdig(ds, i, radpow);
#line 1339
      radmod = (unsigned short )tmp___3;
#line 1340
      k = radct;
      }
#line 1341
      if (! *(ds + (i - 1UL))) {
#line 1341
        i --;
      }
    }
#line 1343
    c = (char )((unsigned int )radmod % radix);
#line 1343
    radmod = (unsigned short )((unsigned int )radmod / radix);
#line 1343
    k --;
#line 1344
    j --;
#line 1344
    if ((int )c < 10) {
#line 1344
      *(s___0 + j) = (char )((int )c + 48);
    } else {
#line 1344
      *(s___0 + j) = (char )(((int )c + 97) - 10);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1346
  if ((int )*(s___0 + 0) == 45) {
#line 1346
    ch = (size_t )1;
  } else {
#line 1346
    ch = (size_t )0;
  }
#line 1347
  if (ch < j) {
#line 1348
    i = j;
    {
#line 1348
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1348
      if (! (j < (unsigned long )((scm_cell *)ss)->car >> 8)) {
#line 1348
        goto while_break___1;
      }
#line 1348
      *(s___0 + ((ch + j) - i)) = *(s___0 + j);
#line 1348
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1349
    scm_vector_set_length_x(ss, (SCM )((((ch + ((unsigned long )((scm_cell *)ss)->car >> 8)) - i) << 2) + 2UL));
    }
  }
#line 1351
  return (ss);
}
}
#line 1356 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_number_to_string[15]  = 
#line 1356
  {      (char )'n',      (char )'u',      (char )'m',      (char )'b', 
        (char )'e',      (char )'r',      (char )'-',      (char )'>', 
        (char )'s',      (char )'t',      (char )'r',      (char )'i', 
        (char )'n',      (char )'g',      (char )'\000'};
#line 1358 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_number_to_string(SCM x , SCM radix ) 
{ 
  char num_buf[10UL + (2UL * (((sizeof(double ) / sizeof(char )) * 8UL) * 3UL + 9UL)) / 10UL] ;
  SCM tmp ;
  size_t tmp___0 ;
  SCM tmp___1 ;
  char num_buf___0[5UL + (8UL * sizeof(long )) / sizeof(char )] ;
  size_t tmp___2 ;
  SCM tmp___3 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;

  {
#line 1363
  if ((long )(18 << 9) + 372L == radix) {
#line 1363
    radix = (10L << 2) + 2L;
  } else
#line 1364
  if (! (2 & (int )radix)) {
    {
#line 1364
    scm_wta(radix, (char *)2, s_number_to_string);
    }
  }
#line 1366
  if (! (2 & (int )x)) {
#line 1369
    if (! (! (6 & (int )x))) {
#line 1369
      goto badx;
    }
#line 1370
    if ((65279 & (int )((scm_cell *)x)->car) == 639) {
      {
#line 1370
      tmp = big2str(x, (unsigned int )(radix >> 2));
      }
#line 1370
      return (tmp);
    }
#line 1372
    if (! ((65535 & (int )((scm_cell *)x)->car) == 383)) {
      badx: 
      {
#line 1373
      scm_wta(x, (char *)1, s_number_to_string);
      }
    }
    {
#line 1378
    tmp___0 = iflo2str(x, num_buf);
#line 1378
    tmp___1 = scm_makfromstr((char const   *)(num_buf), tmp___0, 0);
    }
#line 1378
    return (tmp___1);
  }
  {
#line 1392
  tmp___2 = scm_iint2str(x >> 2, (int )(radix >> 2), num_buf___0);
#line 1392
  tmp___3 = scm_makfromstr((char const   *)(num_buf___0), tmp___2, 0);
  }
#line 1392
  return (tmp___3);
}
}
#line 1401 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
int scm_floprint(SCM sexp , SCM port , scm_print_state *pstate ) 
{ 
  char num_buf[10UL + (2UL * (((sizeof(double ) / sizeof(char )) * 8UL) * 3UL + 9UL)) / 10UL] ;
  size_t tmp ;
  void *__cil_tmp6 ;

  {
  {
#line 1409
  tmp = iflo2str(sexp, num_buf);
#line 1409
  scm_gen_write((enum scm_string_representation_type )0, num_buf, tmp, port);
  }
#line 1413
  return (1);
}
}
#line 1418 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
int scm_bigprint(SCM exp___0 , SCM port , scm_print_state *pstate ) 
{ 


  {
  {
#line 1425
  exp___0 = big2str(exp___0, 10U);
#line 1426
  scm_gen_write((enum scm_string_representation_type )0, (char *)((scm_cell *)exp___0)->cdr,
                (unsigned long )((scm_cell *)exp___0)->car >> 8, port);
  }
#line 1430
  return (1);
}
}
#line 1436
static SCM scm_small_istr2int(char *str , long len , long radix ) ;
#line 1438 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static SCM scm_small_istr2int(char *str , long len , long radix ) 
{ 
  register long n ;
  register long ln ;
  register int c ;
  register int i ;
  int lead_neg ;
  int tmp ;

  {
#line 1444
  n = 0L;
#line 1446
  i = 0;
#line 1447
  lead_neg = 0;
#line 1448
  if (0L >= len) {
#line 1448
    return ((long )(16 << 9) + 372L);
  }
  {
#line 1450
  if ((int )*str == 45) {
#line 1450
    goto case_45;
  }
#line 1451
  if ((int )*str == 43) {
#line 1451
    goto case_43;
  }
#line 1449
  goto switch_break;
  case_45: /* CIL Label */ 
#line 1450
  lead_neg = 1;
  case_43: /* CIL Label */ 
#line 1451
  i ++;
#line 1451
  if ((long )i == len) {
#line 1451
    return ((long )(16 << 9) + 372L);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 1454
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1455
    tmp = i;
#line 1455
    i ++;
#line 1455
    c = (int )*(str + tmp);
    {
#line 1456
    if (c == 57) {
#line 1456
      goto case_57;
    }
#line 1456
    if (c == 56) {
#line 1456
      goto case_57;
    }
#line 1456
    if (c == 55) {
#line 1456
      goto case_57;
    }
#line 1456
    if (c == 54) {
#line 1456
      goto case_57;
    }
#line 1456
    if (c == 53) {
#line 1456
      goto case_57;
    }
#line 1456
    if (c == 52) {
#line 1456
      goto case_57;
    }
#line 1456
    if (c == 51) {
#line 1456
      goto case_57;
    }
#line 1456
    if (c == 50) {
#line 1456
      goto case_57;
    }
#line 1456
    if (c == 49) {
#line 1456
      goto case_57;
    }
#line 1456
    if (c == 48) {
#line 1456
      goto case_57;
    }
#line 1459
    if (c == 70) {
#line 1459
      goto case_70;
    }
#line 1459
    if (c == 69) {
#line 1459
      goto case_70;
    }
#line 1459
    if (c == 68) {
#line 1459
      goto case_70;
    }
#line 1459
    if (c == 67) {
#line 1459
      goto case_70;
    }
#line 1459
    if (c == 66) {
#line 1459
      goto case_70;
    }
#line 1459
    if (c == 65) {
#line 1459
      goto case_70;
    }
#line 1462
    if (c == 102) {
#line 1462
      goto case_102;
    }
#line 1462
    if (c == 101) {
#line 1462
      goto case_102;
    }
#line 1462
    if (c == 100) {
#line 1462
      goto case_102;
    }
#line 1462
    if (c == 99) {
#line 1462
      goto case_102;
    }
#line 1462
    if (c == 98) {
#line 1462
      goto case_102;
    }
#line 1462
    if (c == 97) {
#line 1462
      goto case_102;
    }
#line 1471
    goto switch_default;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
#line 1457
    c -= 48;
#line 1458
    goto accumulate;
    case_70: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_65: /* CIL Label */ 
#line 1460
    c = (c - 65) + 10;
#line 1461
    goto accumulate;
    case_102: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_97: /* CIL Label */ 
#line 1463
    c = (c - 97) + 10;
    accumulate: 
#line 1465
    if ((long )c >= radix) {
#line 1465
      return ((long )(16 << 9) + 372L);
    }
#line 1466
    ln = n;
#line 1467
    n = n * radix - (long )c;
#line 1469
    if (n > ln) {
#line 1469
      goto ovfl;
    } else
#line 1469
    if (- n > - ((-0x7FFFFFFFFFFFFFFF-1) >> 2)) {
#line 1469
      goto ovfl;
    }
#line 1470
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 1472
    return ((long )(16 << 9) + 372L);
    switch_break___0: /* CIL Label */ ;
    }
#line 1454
    if (! ((long )i < len)) {
#line 1454
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1475
  if (! lead_neg) {
#line 1475
    n = - n;
#line 1475
    if (n > 9223372036854775807L >> 2) {
#line 1475
      goto ovfl;
    }
  }
#line 1476
  return ((n << 2) + 2L);
  ovfl: 
#line 1478
  return ((long )(16 << 9) + 372L);
}
}
#line 1483 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_istr2int(char *str , long len , long radix ) 
{ 
  size_t j ;
  register size_t k ;
  register size_t blen ;
  size_t i ;
  int c ;
  SCM res ;
  register unsigned short *ds ;
  register unsigned long t2 ;
  SCM tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  SCM tmp___3 ;
  char *__cil_tmp17 ;

  {
#line 1490
  blen = (size_t )1;
#line 1491
  i = (size_t )0;
#line 1497
  if (0L >= len) {
#line 1497
    return ((long )(16 << 9) + 372L);
  }
#line 1501
  if (len < 6L) {
    {
#line 1502
    tmp = scm_small_istr2int(str, len, radix);
    }
#line 1502
    return (tmp);
  }
#line 1504
  if (16L == radix) {
#line 1504
    j = 1UL + ((unsigned long )(4L * len) * sizeof(char )) / (sizeof(unsigned short ) * 8UL);
  } else
#line 1505
  if (10L <= radix) {
#line 1506
    j = 1UL + ((unsigned long )(84L * len) * sizeof(char )) / ((sizeof(unsigned short ) * 8UL) * 25UL);
  } else {
#line 1507
    j = 1UL + ((unsigned long )len * sizeof(char )) / (sizeof(unsigned short ) * 8UL);
  }
  {
#line 1510
  if ((int )*(str + 0) == 43) {
#line 1510
    goto case_43;
  }
#line 1510
  if ((int )*(str + 0) == 45) {
#line 1510
    goto case_43;
  }
#line 1508
  goto switch_break;
  case_43: /* CIL Label */ 
  case_45: /* CIL Label */ 
#line 1510
  i ++;
#line 1510
  if (i == (size_t )len) {
#line 1510
    return ((long )(16 << 9) + 372L);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 1512
  res = scm_mkbig(j, 45 == (int )*(str + 0));
#line 1513
  ds = (unsigned short *)((scm_cell *)res)->cdr;
#line 1514
  k = j;
  }
  {
#line 1514
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1514
    tmp___0 = k;
#line 1514
    k --;
#line 1514
    if (! tmp___0) {
#line 1514
      goto while_break;
    }
#line 1514
    *(ds + k) = (unsigned short)0;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1515
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1516
    tmp___1 = i;
#line 1516
    i ++;
#line 1516
    c = (int )*(str + tmp___1);
    {
#line 1517
    if (c == 57) {
#line 1517
      goto case_57;
    }
#line 1517
    if (c == 56) {
#line 1517
      goto case_57;
    }
#line 1517
    if (c == 55) {
#line 1517
      goto case_57;
    }
#line 1517
    if (c == 54) {
#line 1517
      goto case_57;
    }
#line 1517
    if (c == 53) {
#line 1517
      goto case_57;
    }
#line 1517
    if (c == 52) {
#line 1517
      goto case_57;
    }
#line 1517
    if (c == 51) {
#line 1517
      goto case_57;
    }
#line 1517
    if (c == 50) {
#line 1517
      goto case_57;
    }
#line 1517
    if (c == 49) {
#line 1517
      goto case_57;
    }
#line 1517
    if (c == 48) {
#line 1517
      goto case_57;
    }
#line 1520
    if (c == 70) {
#line 1520
      goto case_70;
    }
#line 1520
    if (c == 69) {
#line 1520
      goto case_70;
    }
#line 1520
    if (c == 68) {
#line 1520
      goto case_70;
    }
#line 1520
    if (c == 67) {
#line 1520
      goto case_70;
    }
#line 1520
    if (c == 66) {
#line 1520
      goto case_70;
    }
#line 1520
    if (c == 65) {
#line 1520
      goto case_70;
    }
#line 1523
    if (c == 102) {
#line 1523
      goto case_102;
    }
#line 1523
    if (c == 101) {
#line 1523
      goto case_102;
    }
#line 1523
    if (c == 100) {
#line 1523
      goto case_102;
    }
#line 1523
    if (c == 99) {
#line 1523
      goto case_102;
    }
#line 1523
    if (c == 98) {
#line 1523
      goto case_102;
    }
#line 1523
    if (c == 97) {
#line 1523
      goto case_102;
    }
#line 1540
    goto switch_default;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
#line 1518
    c -= 48;
#line 1519
    goto accumulate;
    case_70: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_65: /* CIL Label */ 
#line 1521
    c = (c - 65) + 10;
#line 1522
    goto accumulate;
    case_102: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_97: /* CIL Label */ 
#line 1524
    c = (c - 97) + 10;
    accumulate: 
#line 1526
    if ((long )c >= radix) {
#line 1526
      return ((long )(16 << 9) + 372L);
    }
#line 1527
    k = (size_t )0;
#line 1528
    t2 = (unsigned long )c;
    moretodo: 
    {
#line 1530
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1530
      if (! (k < blen)) {
#line 1530
        goto while_break___1;
      }
#line 1532
      t2 += (unsigned long )((long )*(ds + k) * radix);
#line 1533
      tmp___2 = k;
#line 1533
      k ++;
#line 1533
      *(ds + tmp___2) = (unsigned short )(t2 & (unsigned long )((1L << sizeof(unsigned short ) * 8UL) - 1L));
#line 1534
      t2 >>= sizeof(unsigned short ) * 8UL;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1536
    if (blen > j) {
      {
#line 1537
      scm_num_overflow((char *)"bignum");
      }
    }
#line 1538
    if (t2) {
#line 1538
      blen ++;
#line 1538
      goto moretodo;
    }
#line 1539
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 1541
    return ((long )(16 << 9) + 372L);
    switch_break___0: /* CIL Label */ ;
    }
#line 1515
    if (! (i < (size_t )len)) {
#line 1515
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1544
  if ((blen * (sizeof(unsigned short ) * 8UL)) / 8UL <= sizeof(SCM )) {
    {
#line 1545
    res = scm_big2inum(res, blen);
    }
#line 1545
    if (2 & (int )res) {
#line 1545
      return (res);
    }
  }
#line 1546
  if (j == blen) {
#line 1546
    return (res);
  }
  {
#line 1547
  tmp___3 = scm_adjbig(res, blen);
  }
#line 1547
  return (tmp___3);
}
}
#line 1552 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_istr2flo(char *str , long len , long radix ) 
{ 
  register int c ;
  register int i ;
  double lead_sgn ;
  double res ;
  double tmp ;
  int flg ;
  int point ;
  SCM second ;
  SCM tmp___0 ;
  int expsgn ;
  int expon ;
  int tmp___1 ;
  int tmp___2 ;
  SCM tmp___3 ;
  SCM tmp___4 ;
  int tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  SCM tmp___8 ;
  SCM tmp___9 ;
  SCM tmp___10 ;

  {
#line 1558
  i = 0;
#line 1560
  res = 0.0;
#line 1560
  tmp = 0.0;
#line 1561
  flg = 0;
#line 1562
  point = 0;
#line 1565
  if ((long )i >= len) {
#line 1565
    return ((long )(16 << 9) + 372L);
  }
  {
#line 1568
  if ((int )*str == 45) {
#line 1568
    goto case_45;
  }
#line 1569
  if ((int )*str == 43) {
#line 1569
    goto case_43;
  }
#line 1570
  goto switch_default;
  case_45: /* CIL Label */ 
#line 1568
  lead_sgn = - 1.0;
#line 1568
  i ++;
#line 1568
  goto switch_break;
  case_43: /* CIL Label */ 
#line 1569
  lead_sgn = 1.0;
#line 1569
  i ++;
#line 1569
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1570
  lead_sgn = 0.0;
  switch_break: /* CIL Label */ ;
  }
#line 1572
  if ((long )i == len) {
#line 1572
    return ((long )(16 << 9) + 372L);
  }
#line 1574
  if ((int )*(str + i) == 105) {
#line 1574
    goto _L;
  } else
#line 1574
  if ((int )*(str + i) == 73) {
    _L: /* CIL Label */ 
#line 1575
    if (lead_sgn == 0.0) {
#line 1575
      return ((long )(16 << 9) + 372L);
    }
#line 1576
    i ++;
#line 1576
    if ((long )i < len) {
#line 1576
      return ((long )(16 << 9) + 372L);
    }
    {
#line 1577
    tmp___0 = scm_makdbl(0.0, lead_sgn);
    }
#line 1577
    return (tmp___0);
  }
  {
#line 1579
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1580
    c = (int )*(str + i);
    {
#line 1581
    if (c == 57) {
#line 1581
      goto case_57;
    }
#line 1581
    if (c == 56) {
#line 1581
      goto case_57;
    }
#line 1581
    if (c == 55) {
#line 1581
      goto case_57;
    }
#line 1581
    if (c == 54) {
#line 1581
      goto case_57;
    }
#line 1581
    if (c == 53) {
#line 1581
      goto case_57;
    }
#line 1581
    if (c == 52) {
#line 1581
      goto case_57;
    }
#line 1581
    if (c == 51) {
#line 1581
      goto case_57;
    }
#line 1581
    if (c == 50) {
#line 1581
      goto case_57;
    }
#line 1581
    if (c == 49) {
#line 1581
      goto case_57;
    }
#line 1581
    if (c == 48) {
#line 1581
      goto case_57;
    }
#line 1584
    if (c == 70) {
#line 1584
      goto case_70;
    }
#line 1584
    if (c == 69) {
#line 1584
      goto case_70;
    }
#line 1584
    if (c == 68) {
#line 1584
      goto case_70;
    }
#line 1586
    if (c == 67) {
#line 1586
      goto case_67;
    }
#line 1586
    if (c == 66) {
#line 1586
      goto case_67;
    }
#line 1586
    if (c == 65) {
#line 1586
      goto case_67;
    }
#line 1589
    if (c == 102) {
#line 1589
      goto case_102;
    }
#line 1589
    if (c == 101) {
#line 1589
      goto case_102;
    }
#line 1589
    if (c == 100) {
#line 1589
      goto case_102;
    }
#line 1591
    if (c == 99) {
#line 1591
      goto case_99;
    }
#line 1591
    if (c == 98) {
#line 1591
      goto case_99;
    }
#line 1591
    if (c == 97) {
#line 1591
      goto case_99;
    }
#line 1598
    goto switch_default___0;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
#line 1582
    c -= 48;
#line 1583
    goto accum1;
    case_70: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_68: /* CIL Label */ 
#line 1585
    if (radix == 10L) {
#line 1585
      goto out1;
    }
    case_67: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_65: /* CIL Label */ 
#line 1587
    c = (c - 65) + 10;
#line 1588
    goto accum1;
    case_102: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_100: /* CIL Label */ 
#line 1590
    if (radix == 10L) {
#line 1590
      goto out1;
    }
    case_99: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_97: /* CIL Label */ 
#line 1592
    c = (c - 97) + 10;
    accum1: 
#line 1594
    if ((long )c >= radix) {
#line 1594
      return ((long )(16 << 9) + 372L);
    }
#line 1595
    res = res * (double )radix + (double )c;
#line 1596
    flg = 1;
#line 1597
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 1599
    goto out1;
    switch_break___0: /* CIL Label */ ;
    }
#line 1579
    i ++;
#line 1579
    if (! ((long )i < len)) {
#line 1579
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  out1: 
#line 1605
  if ((long )i == len) {
#line 1605
    goto done;
  }
#line 1609
  if (! flg) {
#line 1610
    if ((int )*(str + i) == 46) {
#line 1610
      if (! (radix == 10L)) {
#line 1611
        return ((long )(16 << 9) + 372L);
      }
    } else {
#line 1611
      return ((long )(16 << 9) + 372L);
    }
  }
  {
#line 1613
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1613
    if (! ((int )*(str + i) == 35)) {
#line 1613
      goto while_break___0;
    }
#line 1614
    res *= (double )radix;
#line 1615
    i ++;
#line 1615
    if ((long )i == len) {
#line 1615
      goto done;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1618
  if ((int )*(str + i) == 47) {
    {
#line 1619
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1619
      i ++;
#line 1619
      if (! ((long )i < len)) {
#line 1619
        goto while_break___1;
      }
#line 1620
      c = (int )*(str + i);
      {
#line 1621
      if (c == 57) {
#line 1621
        goto case_57___0;
      }
#line 1621
      if (c == 56) {
#line 1621
        goto case_57___0;
      }
#line 1621
      if (c == 55) {
#line 1621
        goto case_57___0;
      }
#line 1621
      if (c == 54) {
#line 1621
        goto case_57___0;
      }
#line 1621
      if (c == 53) {
#line 1621
        goto case_57___0;
      }
#line 1621
      if (c == 52) {
#line 1621
        goto case_57___0;
      }
#line 1621
      if (c == 51) {
#line 1621
        goto case_57___0;
      }
#line 1621
      if (c == 50) {
#line 1621
        goto case_57___0;
      }
#line 1621
      if (c == 49) {
#line 1621
        goto case_57___0;
      }
#line 1621
      if (c == 48) {
#line 1621
        goto case_57___0;
      }
#line 1624
      if (c == 70) {
#line 1624
        goto case_70___0;
      }
#line 1624
      if (c == 69) {
#line 1624
        goto case_70___0;
      }
#line 1624
      if (c == 68) {
#line 1624
        goto case_70___0;
      }
#line 1624
      if (c == 67) {
#line 1624
        goto case_70___0;
      }
#line 1624
      if (c == 66) {
#line 1624
        goto case_70___0;
      }
#line 1624
      if (c == 65) {
#line 1624
        goto case_70___0;
      }
#line 1627
      if (c == 102) {
#line 1627
        goto case_102___0;
      }
#line 1627
      if (c == 101) {
#line 1627
        goto case_102___0;
      }
#line 1627
      if (c == 100) {
#line 1627
        goto case_102___0;
      }
#line 1627
      if (c == 99) {
#line 1627
        goto case_102___0;
      }
#line 1627
      if (c == 98) {
#line 1627
        goto case_102___0;
      }
#line 1627
      if (c == 97) {
#line 1627
        goto case_102___0;
      }
#line 1633
      goto switch_default___1;
      case_57___0: /* CIL Label */ 
      case_56___0: /* CIL Label */ 
      case_55___0: /* CIL Label */ 
      case_54___0: /* CIL Label */ 
      case_53___0: /* CIL Label */ 
      case_52___0: /* CIL Label */ 
      case_51___0: /* CIL Label */ 
      case_50___0: /* CIL Label */ 
      case_49___0: /* CIL Label */ 
      case_48___0: /* CIL Label */ 
#line 1622
      c -= 48;
#line 1623
      goto accum2;
      case_70___0: /* CIL Label */ 
      case_69___0: /* CIL Label */ 
      case_68___0: /* CIL Label */ 
      case_67___0: /* CIL Label */ 
      case_66___0: /* CIL Label */ 
      case_65___0: /* CIL Label */ 
#line 1625
      c = (c - 65) + 10;
#line 1626
      goto accum2;
      case_102___0: /* CIL Label */ 
      case_101___0: /* CIL Label */ 
      case_100___0: /* CIL Label */ 
      case_99___0: /* CIL Label */ 
      case_98___0: /* CIL Label */ 
      case_97___0: /* CIL Label */ 
#line 1628
      c = (c - 97) + 10;
      accum2: 
#line 1630
      if ((long )c >= radix) {
#line 1630
        return ((long )(16 << 9) + 372L);
      }
#line 1631
      tmp = tmp * (double )radix + (double )c;
#line 1632
      goto switch_break___1;
      switch_default___1: /* CIL Label */ 
#line 1634
      goto out2;
      switch_break___1: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    out2: 
#line 1638
    if (tmp == 0.0) {
#line 1638
      return ((long )(16 << 9) + 372L);
    }
#line 1639
    if ((long )i < len) {
      {
#line 1640
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1640
        if (! ((int )*(str + i) == 35)) {
#line 1640
          goto while_break___2;
        }
#line 1641
        tmp *= (double )radix;
#line 1642
        i ++;
#line 1642
        if ((long )i == len) {
#line 1642
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 1644
    res /= tmp;
#line 1645
    goto done;
  }
#line 1648
  if ((int )*(str + i) == 46) {
#line 1649
    if (radix != 10L) {
#line 1649
      return ((long )(16 << 9) + 372L);
    }
    {
#line 1650
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1650
      i ++;
#line 1650
      if (! ((long )i < len)) {
#line 1650
        goto while_break___3;
      }
#line 1651
      c = (int )*(str + i);
      {
#line 1652
      if (c == 57) {
#line 1652
        goto case_57___1;
      }
#line 1652
      if (c == 56) {
#line 1652
        goto case_57___1;
      }
#line 1652
      if (c == 55) {
#line 1652
        goto case_57___1;
      }
#line 1652
      if (c == 54) {
#line 1652
        goto case_57___1;
      }
#line 1652
      if (c == 53) {
#line 1652
        goto case_57___1;
      }
#line 1652
      if (c == 52) {
#line 1652
        goto case_57___1;
      }
#line 1652
      if (c == 51) {
#line 1652
        goto case_57___1;
      }
#line 1652
      if (c == 50) {
#line 1652
        goto case_57___1;
      }
#line 1652
      if (c == 49) {
#line 1652
        goto case_57___1;
      }
#line 1652
      if (c == 48) {
#line 1652
        goto case_57___1;
      }
#line 1657
      goto switch_default___2;
      case_57___1: /* CIL Label */ 
      case_56___1: /* CIL Label */ 
      case_55___1: /* CIL Label */ 
      case_54___1: /* CIL Label */ 
      case_53___1: /* CIL Label */ 
      case_52___1: /* CIL Label */ 
      case_51___1: /* CIL Label */ 
      case_50___1: /* CIL Label */ 
      case_49___1: /* CIL Label */ 
      case_48___1: /* CIL Label */ 
#line 1653
      point --;
#line 1654
      res = (res * 10.0 + (double )c) - (double )48;
#line 1655
      flg = 1;
#line 1656
      goto switch_break___2;
      switch_default___2: /* CIL Label */ 
#line 1658
      goto out3;
      switch_break___2: /* CIL Label */ ;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    out3: 
#line 1662
    if (! flg) {
#line 1662
      return ((long )(16 << 9) + 372L);
    }
#line 1663
    if ((long )i == len) {
#line 1663
      goto adjust;
    }
    {
#line 1664
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1664
      if (! ((int )*(str + i) == 35)) {
#line 1664
        goto while_break___4;
      }
#line 1665
      i ++;
#line 1665
      if ((long )i == len) {
#line 1665
        goto adjust;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  {
#line 1674
  if ((int )*(str + i) == 83) {
#line 1674
    goto case_83;
  }
#line 1674
  if ((int )*(str + i) == 115) {
#line 1674
    goto case_83;
  }
#line 1674
  if ((int )*(str + i) == 76) {
#line 1674
    goto case_83;
  }
#line 1674
  if ((int )*(str + i) == 108) {
#line 1674
    goto case_83;
  }
#line 1674
  if ((int )*(str + i) == 70) {
#line 1674
    goto case_83;
  }
#line 1674
  if ((int )*(str + i) == 102) {
#line 1674
    goto case_83;
  }
#line 1674
  if ((int )*(str + i) == 69) {
#line 1674
    goto case_83;
  }
#line 1674
  if ((int )*(str + i) == 101) {
#line 1674
    goto case_83;
  }
#line 1674
  if ((int )*(str + i) == 68) {
#line 1674
    goto case_83;
  }
#line 1674
  if ((int )*(str + i) == 100) {
#line 1674
    goto case_83;
  }
#line 1669
  goto switch_break___3;
  case_83: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_70___1: /* CIL Label */ 
  case_102___1: /* CIL Label */ 
  case_69___1: /* CIL Label */ 
  case_101___1: /* CIL Label */ 
  case_68___1: /* CIL Label */ 
  case_100___1: /* CIL Label */ 
#line 1675
  expsgn = 1;
#line 1675
  expon = 0;
#line 1676
  if (radix != 10L) {
#line 1676
    return ((long )(16 << 9) + 372L);
  }
#line 1677
  i ++;
#line 1677
  if ((long )i == len) {
#line 1677
    return ((long )(16 << 9) + 372L);
  }
  {
#line 1679
  if ((int )*(str + i) == 45) {
#line 1679
    goto case_45___0;
  }
#line 1680
  if ((int )*(str + i) == 43) {
#line 1680
    goto case_43___0;
  }
#line 1678
  goto switch_break___4;
  case_45___0: /* CIL Label */ 
#line 1679
  expsgn = -1;
  case_43___0: /* CIL Label */ 
#line 1680
  i ++;
#line 1680
  if ((long )i == len) {
#line 1680
    return ((long )(16 << 9) + 372L);
  }
  switch_break___4: /* CIL Label */ ;
  }
#line 1682
  if ((int )*(str + i) < 48) {
#line 1682
    return ((long )(16 << 9) + 372L);
  } else
#line 1682
  if ((int )*(str + i) > 57) {
#line 1682
    return ((long )(16 << 9) + 372L);
  }
  {
#line 1683
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1684
    c = (int )*(str + i);
    {
#line 1685
    if (c == 57) {
#line 1685
      goto case_57___2;
    }
#line 1685
    if (c == 56) {
#line 1685
      goto case_57___2;
    }
#line 1685
    if (c == 55) {
#line 1685
      goto case_57___2;
    }
#line 1685
    if (c == 54) {
#line 1685
      goto case_57___2;
    }
#line 1685
    if (c == 53) {
#line 1685
      goto case_57___2;
    }
#line 1685
    if (c == 52) {
#line 1685
      goto case_57___2;
    }
#line 1685
    if (c == 51) {
#line 1685
      goto case_57___2;
    }
#line 1685
    if (c == 50) {
#line 1685
      goto case_57___2;
    }
#line 1685
    if (c == 49) {
#line 1685
      goto case_57___2;
    }
#line 1685
    if (c == 48) {
#line 1685
      goto case_57___2;
    }
#line 1689
    goto switch_default___3;
    case_57___2: /* CIL Label */ 
    case_56___2: /* CIL Label */ 
    case_55___2: /* CIL Label */ 
    case_54___2: /* CIL Label */ 
    case_53___2: /* CIL Label */ 
    case_52___2: /* CIL Label */ 
    case_51___2: /* CIL Label */ 
    case_50___2: /* CIL Label */ 
    case_49___2: /* CIL Label */ 
    case_48___2: /* CIL Label */ 
#line 1686
    expon = (expon * 10 + c) - 48;
#line 1687
    if (expon > 308) {
#line 1687
      return ((long )(16 << 9) + 372L);
    }
#line 1688
    goto switch_break___5;
    switch_default___3: /* CIL Label */ 
#line 1690
    goto out4;
    switch_break___5: /* CIL Label */ ;
    }
#line 1683
    i ++;
#line 1683
    if (! ((long )i < len)) {
#line 1683
      goto while_break___5;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  out4: 
#line 1694
  point += expsgn * expon;
  switch_break___3: /* CIL Label */ ;
  }
  adjust: 
#line 1699
  if (point >= 0) {
    {
#line 1700
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1700
      tmp___1 = point;
#line 1700
      point --;
#line 1700
      if (! tmp___1) {
#line 1700
        goto while_break___6;
      }
#line 1700
      res *= 10.0;
    }
    while_break___6: /* CIL Label */ ;
    }
  } else {
    {
#line 1705
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1705
      tmp___2 = point;
#line 1705
      point ++;
#line 1705
      if (! tmp___2) {
#line 1705
        goto while_break___7;
      }
#line 1705
      res /= 10.0;
    }
    while_break___7: /* CIL Label */ ;
    }
  }
  done: 
#line 1710
  if (lead_sgn == - 1.0) {
#line 1710
    res = - res;
  }
#line 1711
  if ((long )i == len) {
    {
#line 1711
    tmp___3 = scm_makdbl(res, 0.0);
    }
#line 1711
    return (tmp___3);
  }
#line 1713
  if ((int )*(str + i) == 105) {
#line 1713
    goto _L___0;
  } else
#line 1713
  if ((int )*(str + i) == 73) {
    _L___0: /* CIL Label */ 
#line 1714
    if (lead_sgn == 0.0) {
#line 1714
      return ((long )(16 << 9) + 372L);
    }
#line 1715
    i ++;
#line 1715
    if ((long )i < len) {
#line 1715
      return ((long )(16 << 9) + 372L);
    }
    {
#line 1716
    tmp___4 = scm_makdbl(0.0, res);
    }
#line 1716
    return (tmp___4);
  }
#line 1719
  tmp___5 = i;
#line 1719
  i ++;
  {
#line 1720
  if ((int )*(str + tmp___5) == 45) {
#line 1720
    goto case_45___1;
  }
#line 1721
  if ((int )*(str + tmp___5) == 43) {
#line 1721
    goto case_43___1;
  }
#line 1722
  if ((int )*(str + tmp___5) == 64) {
#line 1722
    goto case_64;
  }
#line 1730
  goto switch_default___4;
  case_45___1: /* CIL Label */ 
#line 1720
  lead_sgn = - 1.0;
#line 1720
  goto switch_break___6;
  case_43___1: /* CIL Label */ 
#line 1721
  lead_sgn = 1.0;
#line 1721
  goto switch_break___6;
  case_64: /* CIL Label */ 
  {
#line 1724
  second = scm_istr2flo(str + i, len - (long )i, radix);
  }
#line 1725
  if (! ((65535 & (int )((scm_cell *)second)->car) == 383)) {
#line 1725
    return ((long )(16 << 9) + 372L);
  }
#line 1726
  if (((scm_cell *)second)->car == ((383L | (1L << 16)) | (2L << 16))) {
#line 1726
    return ((long )(16 << 9) + 372L);
  }
  {
#line 1727
  tmp = *(((scm_dbl *)second)->real);
#line 1728
  tmp___6 = sin(tmp);
#line 1728
  tmp___7 = cos(tmp);
#line 1728
  tmp___8 = scm_makdbl(res * tmp___7, res * tmp___6);
  }
#line 1728
  return (tmp___8);
  switch_default___4: /* CIL Label */ 
#line 1730
  return ((long )(16 << 9) + 372L);
  switch_break___6: /* CIL Label */ ;
  }
#line 1734
  if ((int )*(str + (len - 1L)) != 105) {
#line 1734
    if ((int )*(str + (len - 1L)) != 73) {
#line 1734
      return ((long )(16 << 9) + 372L);
    }
  }
#line 1736
  if ((long )i == len - 1L) {
    {
#line 1736
    tmp___9 = scm_makdbl(res, lead_sgn);
    }
#line 1736
    return (tmp___9);
  }
  {
#line 1738
  second = scm_istr2flo(str + i, (len - (long )i) - 1L, radix);
  }
#line 1739
  if (! ((65535 & (int )((scm_cell *)second)->car) == 383)) {
#line 1739
    return ((long )(16 << 9) + 372L);
  }
#line 1740
  if (((scm_cell *)second)->car == ((383L | (1L << 16)) | (2L << 16))) {
#line 1740
    return ((long )(16 << 9) + 372L);
  }
#line 1741
  tmp = *(((scm_dbl *)second)->real);
#line 1742
  if (tmp < 0.0) {
#line 1742
    return ((long )(16 << 9) + 372L);
  }
  {
#line 1743
  tmp___10 = scm_makdbl(res, lead_sgn * tmp);
  }
#line 1743
  return (tmp___10);
}
}
#line 1749 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_istring2number(char *str , long len , long radix ) 
{ 
  int i ;
  char ex ;
  char ex_p ;
  char rx_p ;
  SCM res ;
  int tmp ;
  char tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  char tmp___3 ;
  char tmp___4 ;
  char tmp___5 ;
  SCM tmp___6 ;
  SCM tmp___7 ;

  {
#line 1755
  i = 0;
#line 1756
  ex = (char)0;
#line 1757
  ex_p = (char)0;
#line 1757
  rx_p = (char)0;
#line 1759
  if (len == 1L) {
#line 1760
    if ((int )*str == 43) {
#line 1761
      return ((long )(16 << 9) + 372L);
    } else
#line 1760
    if ((int )*str == 45) {
#line 1761
      return ((long )(16 << 9) + 372L);
    }
  }
  {
#line 1763
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1763
    if (len - (long )i >= 2L) {
#line 1763
      if ((int )*(str + i) == 35) {
#line 1763
        i ++;
#line 1763
        if (! i) {
#line 1763
          goto while_break;
        }
      } else {
#line 1763
        goto while_break;
      }
    } else {
#line 1763
      goto while_break;
    }
#line 1764
    tmp = i;
#line 1764
    i ++;
    {
#line 1765
    if ((int )*(str + tmp) == 66) {
#line 1765
      goto case_66;
    }
#line 1765
    if ((int )*(str + tmp) == 98) {
#line 1765
      goto case_66;
    }
#line 1766
    if ((int )*(str + tmp) == 79) {
#line 1766
      goto case_79;
    }
#line 1766
    if ((int )*(str + tmp) == 111) {
#line 1766
      goto case_79;
    }
#line 1767
    if ((int )*(str + tmp) == 68) {
#line 1767
      goto case_68;
    }
#line 1767
    if ((int )*(str + tmp) == 100) {
#line 1767
      goto case_68;
    }
#line 1768
    if ((int )*(str + tmp) == 88) {
#line 1768
      goto case_88;
    }
#line 1768
    if ((int )*(str + tmp) == 120) {
#line 1768
      goto case_88;
    }
#line 1769
    if ((int )*(str + tmp) == 73) {
#line 1769
      goto case_73;
    }
#line 1769
    if ((int )*(str + tmp) == 105) {
#line 1769
      goto case_73;
    }
#line 1770
    if ((int )*(str + tmp) == 69) {
#line 1770
      goto case_69;
    }
#line 1770
    if ((int )*(str + tmp) == 101) {
#line 1770
      goto case_69;
    }
#line 1771
    goto switch_default;
    case_66: /* CIL Label */ 
    case_98: /* CIL Label */ 
#line 1765
    tmp___0 = rx_p;
#line 1765
    rx_p = (char )((int )rx_p + 1);
#line 1765
    if (tmp___0) {
#line 1765
      return ((long )(16 << 9) + 372L);
    }
#line 1765
    radix = 2L;
#line 1765
    goto switch_break;
    case_79: /* CIL Label */ 
    case_111: /* CIL Label */ 
#line 1766
    tmp___1 = rx_p;
#line 1766
    rx_p = (char )((int )rx_p + 1);
#line 1766
    if (tmp___1) {
#line 1766
      return ((long )(16 << 9) + 372L);
    }
#line 1766
    radix = 8L;
#line 1766
    goto switch_break;
    case_68: /* CIL Label */ 
    case_100: /* CIL Label */ 
#line 1767
    tmp___2 = rx_p;
#line 1767
    rx_p = (char )((int )rx_p + 1);
#line 1767
    if (tmp___2) {
#line 1767
      return ((long )(16 << 9) + 372L);
    }
#line 1767
    radix = 10L;
#line 1767
    goto switch_break;
    case_88: /* CIL Label */ 
    case_120: /* CIL Label */ 
#line 1768
    tmp___3 = rx_p;
#line 1768
    rx_p = (char )((int )rx_p + 1);
#line 1768
    if (tmp___3) {
#line 1768
      return ((long )(16 << 9) + 372L);
    }
#line 1768
    radix = 16L;
#line 1768
    goto switch_break;
    case_73: /* CIL Label */ 
    case_105: /* CIL Label */ 
#line 1769
    tmp___4 = ex_p;
#line 1769
    ex_p = (char )((int )ex_p + 1);
#line 1769
    if (tmp___4) {
#line 1769
      return ((long )(16 << 9) + 372L);
    }
#line 1769
    ex = (char)2;
#line 1769
    goto switch_break;
    case_69: /* CIL Label */ 
    case_101: /* CIL Label */ 
#line 1770
    tmp___5 = ex_p;
#line 1770
    ex_p = (char )((int )ex_p + 1);
#line 1770
    if (tmp___5) {
#line 1770
      return ((long )(16 << 9) + 372L);
    }
#line 1770
    ex = (char)1;
#line 1770
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1771
    return ((long )(16 << 9) + 372L);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1775
  if ((int )ex == 1) {
#line 1775
    goto case_1;
  }
#line 1777
  if ((int )ex == 0) {
#line 1777
    goto case_0;
  }
#line 1781
  if ((int )ex == 2) {
#line 1781
    goto case_2;
  }
#line 1774
  goto switch_break___0;
  case_1: /* CIL Label */ 
  {
#line 1776
  tmp___6 = scm_istr2int(str + i, len - (long )i, radix);
  }
#line 1776
  return (tmp___6);
  case_0: /* CIL Label */ 
  {
#line 1778
  res = scm_istr2int(str + i, len - (long )i, radix);
  }
#line 1779
  if ((long )(16 << 9) + 372L != res) {
#line 1779
    return (res);
  }
  case_2: /* CIL Label */ 
  {
#line 1781
  tmp___7 = scm_istr2flo(str + i, len - (long )i, radix);
  }
#line 1781
  return (tmp___7);
  switch_break___0: /* CIL Label */ ;
  }
#line 1784
  return ((long )(16 << 9) + 372L);
}
}
#line 1788 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_string_to_number[15]  = 
#line 1788
  {      (char )'s',      (char )'t',      (char )'r',      (char )'i', 
        (char )'n',      (char )'g',      (char )'-',      (char )'>', 
        (char )'n',      (char )'u',      (char )'m',      (char )'b', 
        (char )'e',      (char )'r',      (char )'\000'};
#line 1790 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_string_to_number(SCM str , SCM radix ) 
{ 
  SCM answer ;
  char *tmp ;
  SCM tmp___0 ;

  {
#line 1796
  if ((long )(18 << 9) + 372L == radix) {
#line 1796
    radix = (10L << 2) + 2L;
  } else
#line 1797
  if (! (2 & (int )radix)) {
    {
#line 1797
    scm_wta(radix, (char *)2, s_string_to_number);
    }
  }
#line 1798
  if (! (6 & (int )str)) {
#line 1798
    if (! ((117 & (int )((scm_cell *)str)->car) == 21)) {
#line 1798
      if (! ((125 & (int )((scm_cell *)str)->car) == 5)) {
        {
#line 1798
        scm_wta(str, (char *)1, s_string_to_number);
        }
      }
    }
  } else {
    {
#line 1798
    scm_wta(str, (char *)1, s_string_to_number);
    }
  }
#line 1799
  if ((127 & (int )((scm_cell *)str)->car) == 29) {
#line 1799
    tmp = (char *)((scm_cell *)((scm_cell *)((scm_cell *)str)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)str)->cdr)->car >> 2);
  } else {
#line 1799
    tmp = (char *)((scm_cell *)str)->cdr;
  }
  {
#line 1799
  answer = scm_istring2number(tmp, (long )((unsigned long )((scm_cell *)str)->car >> 8),
                              radix >> 2);
#line 1800
  tmp___0 = scm_return_first(answer, str);
  }
#line 1800
  return (tmp___0);
}
}
#line 1806 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_makdbl(double x , double y ) 
{ 
  SCM z ;
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 1812
  if (y == 0.0) {
#line 1812
    if (x == 0.0) {
#line 1812
      return (scm_sys_protects[0]);
    }
  }
#line 1813
  if (6 & (int )scm_freelist) {
    {
#line 1813
    z = scm_gc_for_newcell();
    }
  } else {
#line 1813
    z = scm_freelist;
#line 1813
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 1813
    scm_cells_allocated ++;
  }
#line 1814
  scm_ints_disabled = 1;
#line 1815
  if (y == 0.0) {
    {
#line 1828
    tmp = scm_must_malloc((long )sizeof(double ), (char *)"real");
#line 1828
    ((scm_cell *)z)->cdr = (SCM )tmp;
#line 1829
    ((scm_cell *)z)->car = 383L | (1L << 16);
    }
  } else {
    {
#line 1832
    tmp___0 = scm_must_malloc((long )(2UL * sizeof(double )), (char *)"complex");
#line 1832
    ((scm_cell *)z)->cdr = (SCM )tmp___0;
#line 1833
    ((scm_cell *)z)->car = (383L | (1L << 16)) | (2L << 16);
#line 1834
    *((double *)((char *)((scm_cell *)z)->cdr + sizeof(double ))) = y;
    }
  }
#line 1836
  *(((scm_dbl *)z)->real) = x;
#line 1837
  scm_ints_disabled = 0;
#line 1837
  scm_async_clock --;
#line 1837
  if (0U == scm_async_clock) {
    {
#line 1837
    scm_async_click();
    }
  }
#line 1838
  return (z);
}
}
#line 1844 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_bigequal(SCM x , SCM y ) 
{ 
  int tmp ;

  {
  {
#line 1850
  tmp = scm_bigcomp(x, y);
  }
#line 1850
  if (0 == tmp) {
#line 1850
    return ((long )(17 << 9) + 372L);
  }
#line 1852
  return ((long )(16 << 9) + 372L);
}
}
#line 1857 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_floequal(SCM x , SCM y ) 
{ 


  {
#line 1863
  if (*(((scm_dbl *)x)->real) != *(((scm_dbl *)y)->real)) {
#line 1863
    return ((long )(16 << 9) + 372L);
  }
#line 1864
  if (((scm_cell *)x)->car == ((383L | (1L << 16)) | (2L << 16))) {
#line 1864
    if (! (*((double *)((char *)((scm_cell *)x)->cdr + sizeof(double ))) != *((double *)((char *)((scm_cell *)y)->cdr + sizeof(double ))))) {
#line 1864
      return ((long )(17 << 9) + 372L);
    }
  } else {
#line 1864
    return ((long )(17 << 9) + 372L);
  }
#line 1866
  return ((long )(16 << 9) + 372L);
}
}
#line 1872 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_number_p[8]  = 
#line 1872
  {      (char )'n',      (char )'u',      (char )'m',      (char )'b', 
        (char )'e',      (char )'r',      (char )'?',      (char )'\000'};
#line 1873 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_complex_p[9]  = 
#line 1873
  {      (char )'c',      (char )'o',      (char )'m',      (char )'p', 
        (char )'l',      (char )'e',      (char )'x',      (char )'?', 
        (char )'\000'};
#line 1875 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_number_p(SCM x ) 
{ 


  {
#line 1879
  if (2 & (int )x) {
#line 1879
    return ((long )(17 << 9) + 372L);
  }
#line 1881
  if (! (6 & (int )x)) {
#line 1881
    if ((64767 & (int )((scm_cell *)x)->car) == 127) {
#line 1881
      return ((long )(17 << 9) + 372L);
    }
  }
#line 1887
  return ((long )(16 << 9) + 372L);
}
}
#line 1893 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_real_p[6]  = {      (char )'r',      (char )'e',      (char )'a',      (char )'l', 
        (char )'?',      (char )'\000'};
#line 1894 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_rational_p[10]  = 
#line 1894
  {      (char )'r',      (char )'a',      (char )'t',      (char )'i', 
        (char )'o',      (char )'n',      (char )'a',      (char )'l', 
        (char )'?',      (char )'\000'};
#line 1896 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_real_p(SCM x ) 
{ 


  {
#line 1900
  if (2 & (int )x) {
#line 1901
    return ((long )(17 << 9) + 372L);
  }
#line 1902
  if (6 & (int )x) {
#line 1903
    return ((long )(16 << 9) + 372L);
  }
#line 1904
  if (((scm_cell *)x)->car == (383L | (1L << 16))) {
#line 1905
    return ((long )(17 << 9) + 372L);
  }
#line 1907
  if ((65279 & (int )((scm_cell *)x)->car) == 639) {
#line 1908
    return ((long )(17 << 9) + 372L);
  }
#line 1910
  return ((long )(16 << 9) + 372L);
}
}
#line 1915 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_int_p[9]  = 
#line 1915
  {      (char )'i',      (char )'n',      (char )'t',      (char )'e', 
        (char )'g',      (char )'e',      (char )'r',      (char )'?', 
        (char )'\000'};
#line 1917 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_integer_p(SCM x ) 
{ 
  double r ;
  double tmp ;

  {
#line 1922
  if (2 & (int )x) {
#line 1922
    return ((long )(17 << 9) + 372L);
  }
#line 1923
  if (6 & (int )x) {
#line 1923
    return ((long )(16 << 9) + 372L);
  }
#line 1925
  if ((65279 & (int )((scm_cell *)x)->car) == 639) {
#line 1925
    return ((long )(17 << 9) + 372L);
  }
#line 1927
  if (! ((65535 & (int )((scm_cell *)x)->car) == 383)) {
#line 1927
    return ((long )(16 << 9) + 372L);
  }
#line 1928
  if (((scm_cell *)x)->car == ((383L | (1L << 16)) | (2L << 16))) {
#line 1928
    return ((long )(16 << 9) + 372L);
  }
  {
#line 1929
  r = *(((scm_dbl *)x)->real);
#line 1930
  tmp = floor(r);
  }
#line 1930
  if (r == tmp) {
#line 1930
    return ((long )(17 << 9) + 372L);
  }
#line 1931
  return ((long )(16 << 9) + 372L);
}
}
#line 1938 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_inexact_p[9]  = 
#line 1938
  {      (char )'i',      (char )'n',      (char )'e',      (char )'x', 
        (char )'a',      (char )'c',      (char )'t',      (char )'?', 
        (char )'\000'};
#line 1940 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_inexact_p(SCM x ) 
{ 


  {
#line 1945
  if (! (6 & (int )x)) {
#line 1945
    if ((65535 & (int )((scm_cell *)x)->car) == 383) {
#line 1945
      return ((long )(17 << 9) + 372L);
    }
  }
#line 1947
  return ((long )(16 << 9) + 372L);
}
}
#line 1953 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_eq_p[2]  = {      (char )'=',      (char )'\000'};
#line 1955 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_num_eq_p(SCM x , SCM y ) 
{ 
  SCM t ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___3 ;
  double tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;

  {
#line 1962
  if (! (2 & (int )x)) {
#line 1965
    if (! (! (6 & (int )x))) {
      badx: 
      {
#line 1966
      scm_wta(x, (char *)1, s_eq_p);
      }
    }
#line 1968
    if ((65279 & (int )((scm_cell *)x)->car) == 639) {
#line 1969
      if (2 & (int )y) {
#line 1969
        return ((long )(16 << 9) + 372L);
      }
#line 1970
      if (! (! (6 & (int )y))) {
#line 1970
        goto bady;
      }
#line 1971
      if ((65279 & (int )((scm_cell *)y)->car) == 639) {
        {
#line 1971
        tmp___1 = scm_bigcomp(x, y);
        }
#line 1971
        if (0 == tmp___1) {
#line 1971
          tmp___0 = (long )(17 << 9) + 372L;
        } else {
#line 1971
          tmp___0 = (long )(16 << 9) + 372L;
        }
#line 1971
        return (tmp___0);
      }
#line 1972
      if (! ((65535 & (int )((scm_cell *)y)->car) == 383)) {
#line 1972
        goto bady;
      }
      bigreal: 
#line 1974
      if (((scm_cell *)y)->car == (383L | (1L << 16))) {
        {
#line 1974
        tmp___4 = scm_big2dbl(x);
        }
#line 1974
        if (tmp___4 == *(((scm_dbl *)y)->real)) {
#line 1974
          tmp___3 = (long )(17 << 9) + 372L;
        } else {
#line 1974
          tmp___3 = (long )(16 << 9) + 372L;
        }
      } else {
#line 1974
        tmp___3 = (long )(16 << 9) + 372L;
      }
#line 1974
      return (tmp___3);
    }
#line 1976
    if (! ((65535 & (int )((scm_cell *)x)->car) == 383)) {
#line 1976
      goto badx;
    }
#line 1980
    if (2 & (int )y) {
#line 1980
      t = x;
#line 1980
      x = y;
#line 1980
      y = t;
#line 1980
      goto realint;
    }
#line 1982
    if (! (! (6 & (int )y))) {
#line 1982
      goto bady;
    }
#line 1983
    if ((65279 & (int )((scm_cell *)y)->car) == 639) {
#line 1983
      t = x;
#line 1983
      x = y;
#line 1983
      y = t;
#line 1983
      goto bigreal;
    }
#line 1984
    if (! ((65535 & (int )((scm_cell *)y)->car) == 383)) {
#line 1984
      goto bady;
    }
#line 1988
    if (*(((scm_dbl *)x)->real) != *(((scm_dbl *)y)->real)) {
#line 1988
      return ((long )(16 << 9) + 372L);
    }
#line 1989
    if (((scm_cell *)x)->car == ((383L | (1L << 16)) | (2L << 16))) {
#line 1990
      if (((scm_cell *)y)->car == ((383L | (1L << 16)) | (2L << 16))) {
#line 1990
        if (*((double *)((char *)((scm_cell *)x)->cdr + sizeof(double ))) == *((double *)((char *)((scm_cell *)y)->cdr + sizeof(double )))) {
#line 1990
          tmp___5 = (long )(17 << 9) + 372L;
        } else {
#line 1990
          tmp___5 = (long )(16 << 9) + 372L;
        }
      } else {
#line 1990
        tmp___5 = (long )(16 << 9) + 372L;
      }
#line 1990
      return (tmp___5);
    }
#line 1991
    if (((scm_cell *)y)->car == ((383L | (1L << 16)) | (2L << 16))) {
#line 1991
      tmp___6 = (long )(16 << 9) + 372L;
    } else {
#line 1991
      tmp___6 = (long )(17 << 9) + 372L;
    }
#line 1991
    return (tmp___6);
  }
#line 1993
  if (! (2 & (int )y)) {
#line 1995
    if (! (! (6 & (int )y))) {
#line 1995
      goto bady;
    }
#line 1996
    if ((65279 & (int )((scm_cell *)y)->car) == 639) {
#line 1996
      return ((long )(16 << 9) + 372L);
    }
#line 1998
    if (! ((65535 & (int )((scm_cell *)y)->car) == 383)) {
      bady: 
      {
#line 1999
      scm_wta(y, (char *)2, s_eq_p);
      }
    }
    realint: 
#line 2008
    if (((scm_cell *)y)->car == (383L | (1L << 16))) {
#line 2008
      if ((double )(x >> 2) == *(((scm_dbl *)y)->real)) {
#line 2008
        tmp___7 = (long )(17 << 9) + 372L;
      } else {
#line 2008
        tmp___7 = (long )(16 << 9) + 372L;
      }
    } else {
#line 2008
      tmp___7 = (long )(16 << 9) + 372L;
    }
#line 2008
    return (tmp___7);
  }
#line 2030
  if (x == y) {
#line 2030
    tmp___8 = (long )(17 << 9) + 372L;
  } else {
#line 2030
    tmp___8 = (long )(16 << 9) + 372L;
  }
#line 2030
  return (tmp___8);
}
}
#line 2035 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_less_p[2]  = {      (char )'<',      (char )'\000'};
#line 2037 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_less_p(SCM x , SCM y ) 
{ 
  long tmp ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___4 ;
  double tmp___5 ;
  long tmp___6 ;
  long tmp___8 ;
  double tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;

  {
#line 2043
  if (! (2 & (int )x)) {
#line 2046
    if (! (! (6 & (int )x))) {
      badx: 
      {
#line 2047
      scm_wta(x, (char *)1, s_less_p);
      }
    }
#line 2049
    if ((65279 & (int )((scm_cell *)x)->car) == 639) {
#line 2050
      if (2 & (int )y) {
#line 2050
        if (256 & (int )((scm_cell *)x)->car) {
#line 2050
          tmp = (long )(17 << 9) + 372L;
        } else {
#line 2050
          tmp = (long )(16 << 9) + 372L;
        }
#line 2050
        return (tmp);
      }
#line 2051
      if (! (! (6 & (int )y))) {
#line 2051
        goto bady;
      }
#line 2052
      if ((65279 & (int )((scm_cell *)y)->car) == 639) {
        {
#line 2052
        tmp___2 = scm_bigcomp(x, y);
        }
#line 2052
        if (1 == tmp___2) {
#line 2052
          tmp___1 = (long )(17 << 9) + 372L;
        } else {
#line 2052
          tmp___1 = (long )(16 << 9) + 372L;
        }
#line 2052
        return (tmp___1);
      }
#line 2053
      if (! (((scm_cell *)y)->car == (383L | (1L << 16)))) {
#line 2053
        goto bady;
      }
      {
#line 2054
      tmp___5 = scm_big2dbl(x);
      }
#line 2054
      if (tmp___5 < *(((scm_dbl *)y)->real)) {
#line 2054
        tmp___4 = (long )(17 << 9) + 372L;
      } else {
#line 2054
        tmp___4 = (long )(16 << 9) + 372L;
      }
#line 2054
      return (tmp___4);
    }
#line 2056
    if (! (((scm_cell *)x)->car == (383L | (1L << 16)))) {
#line 2056
      goto badx;
    }
#line 2060
    if (2 & (int )y) {
#line 2061
      if (*(((scm_dbl *)x)->real) < (double )(y >> 2)) {
#line 2061
        tmp___6 = (long )(17 << 9) + 372L;
      } else {
#line 2061
        tmp___6 = (long )(16 << 9) + 372L;
      }
#line 2061
      return (tmp___6);
    }
#line 2063
    if (! (! (6 & (int )y))) {
#line 2063
      goto bady;
    }
#line 2064
    if ((65279 & (int )((scm_cell *)y)->car) == 639) {
      {
#line 2064
      tmp___9 = scm_big2dbl(y);
      }
#line 2064
      if (*(((scm_dbl *)x)->real) < tmp___9) {
#line 2064
        tmp___8 = (long )(17 << 9) + 372L;
      } else {
#line 2064
        tmp___8 = (long )(16 << 9) + 372L;
      }
#line 2064
      return (tmp___8);
    }
#line 2065
    if (! (((scm_cell *)y)->car == (383L | (1L << 16)))) {
#line 2065
      goto bady;
    }
#line 2069
    if (*(((scm_dbl *)x)->real) < *(((scm_dbl *)y)->real)) {
#line 2069
      tmp___10 = (long )(17 << 9) + 372L;
    } else {
#line 2069
      tmp___10 = (long )(16 << 9) + 372L;
    }
#line 2069
    return (tmp___10);
  }
#line 2071
  if (! (2 & (int )y)) {
#line 2073
    if (! (! (6 & (int )y))) {
#line 2073
      goto bady;
    }
#line 2074
    if ((65279 & (int )((scm_cell *)y)->car) == 639) {
#line 2074
      if (256 & (int )((scm_cell *)y)->car) {
#line 2074
        tmp___11 = (long )(16 << 9) + 372L;
      } else {
#line 2074
        tmp___11 = (long )(17 << 9) + 372L;
      }
#line 2074
      return (tmp___11);
    }
#line 2076
    if (! (((scm_cell *)y)->car == (383L | (1L << 16)))) {
      bady: 
      {
#line 2077
      scm_wta(y, (char *)2, s_less_p);
      }
    }
#line 2085
    if ((double )(x >> 2) < *(((scm_dbl *)y)->real)) {
#line 2085
      tmp___12 = (long )(17 << 9) + 372L;
    } else {
#line 2085
      tmp___12 = (long )(16 << 9) + 372L;
    }
#line 2085
    return (tmp___12);
  }
#line 2107
  if (x < y) {
#line 2107
    tmp___13 = (long )(17 << 9) + 372L;
  } else {
#line 2107
    tmp___13 = (long )(16 << 9) + 372L;
  }
#line 2107
  return (tmp___13);
}
}
#line 2111 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_gr_p[2]  = {      (char )'>',      (char )'\000'};
#line 2113 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_gr_p(SCM x , SCM y ) 
{ 
  SCM tmp ;

  {
  {
#line 2118
  tmp = scm_less_p(y, x);
  }
#line 2118
  return (tmp);
}
}
#line 2123 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_leq_p[3]  = {      (char )'<',      (char )'=',      (char )'\000'};
#line 2125 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_leq_p(SCM x , SCM y ) 
{ 
  SCM tmp ;

  {
  {
#line 2130
  tmp = scm_less_p(y, x);
  }
#line 2130
  return (tmp ^ (((long )(17 << 9) + 372L) ^ ((long )(16 << 9) + 372L)));
}
}
#line 2135 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_geq_p[3]  = {      (char )'>',      (char )'=',      (char )'\000'};
#line 2137 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_geq_p(SCM x , SCM y ) 
{ 
  SCM tmp ;

  {
  {
#line 2142
  tmp = scm_less_p(x, y);
  }
#line 2142
  return (tmp ^ (((long )(17 << 9) + 372L) ^ ((long )(16 << 9) + 372L)));
}
}
#line 2147 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_zero_p[6]  = {      (char )'z',      (char )'e',      (char )'r',      (char )'o', 
        (char )'?',      (char )'\000'};
#line 2149 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_zero_p(SCM z ) 
{ 
  long tmp ;
  long tmp___0 ;

  {
#line 2154
  if (! (2 & (int )z)) {
#line 2156
    if (! (! (6 & (int )z))) {
#line 2156
      goto badz;
    }
#line 2157
    if ((65279 & (int )((scm_cell *)z)->car) == 639) {
#line 2157
      return ((long )(16 << 9) + 372L);
    }
#line 2159
    if (! ((65535 & (int )((scm_cell *)z)->car) == 383)) {
      badz: 
      {
#line 2160
      scm_wta(z, (char *)1, s_zero_p);
      }
    }
#line 2165
    if (z == scm_sys_protects[0]) {
#line 2165
      tmp = (long )(17 << 9) + 372L;
    } else {
#line 2165
      tmp = (long )(16 << 9) + 372L;
    }
#line 2165
    return (tmp);
  }
#line 2177
  if (z == 2L) {
#line 2177
    tmp___0 = (long )(17 << 9) + 372L;
  } else {
#line 2177
    tmp___0 = (long )(16 << 9) + 372L;
  }
#line 2177
  return (tmp___0);
}
}
#line 2182 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_positive_p[10]  = 
#line 2182
  {      (char )'p',      (char )'o',      (char )'s',      (char )'i', 
        (char )'t',      (char )'i',      (char )'v',      (char )'e', 
        (char )'?',      (char )'\000'};
#line 2184 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_positive_p(SCM x ) 
{ 
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 2189
  if (! (2 & (int )x)) {
#line 2191
    if (! (! (6 & (int )x))) {
#line 2191
      goto badx;
    }
#line 2192
    if ((65279 & (int )((scm_cell *)x)->car) == 639) {
#line 2192
      if ((65535 & (int )((scm_cell *)x)->car) == 639) {
#line 2192
        tmp = (long )(17 << 9) + 372L;
      } else {
#line 2192
        tmp = (long )(16 << 9) + 372L;
      }
#line 2192
      return (tmp);
    }
#line 2194
    if (! (((scm_cell *)x)->car == (383L | (1L << 16)))) {
      badx: 
      {
#line 2195
      scm_wta(x, (char *)1, s_positive_p);
      }
    }
#line 2200
    if (*(((scm_dbl *)x)->real) > 0.0) {
#line 2200
      tmp___0 = (long )(17 << 9) + 372L;
    } else {
#line 2200
      tmp___0 = (long )(16 << 9) + 372L;
    }
#line 2200
    return (tmp___0);
  }
#line 2212
  if (x > 2L) {
#line 2212
    tmp___1 = (long )(17 << 9) + 372L;
  } else {
#line 2212
    tmp___1 = (long )(16 << 9) + 372L;
  }
#line 2212
  return (tmp___1);
}
}
#line 2217 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_negative_p[10]  = 
#line 2217
  {      (char )'n',      (char )'e',      (char )'g',      (char )'a', 
        (char )'t',      (char )'i',      (char )'v',      (char )'e', 
        (char )'?',      (char )'\000'};
#line 2219 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_negative_p(SCM x ) 
{ 
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 2224
  if (! (2 & (int )x)) {
#line 2226
    if (! (! (6 & (int )x))) {
#line 2226
      goto badx;
    }
#line 2227
    if ((65279 & (int )((scm_cell *)x)->car) == 639) {
#line 2227
      if ((65535 & (int )((scm_cell *)x)->car) == 639) {
#line 2227
        tmp = (long )(16 << 9) + 372L;
      } else {
#line 2227
        tmp = (long )(17 << 9) + 372L;
      }
#line 2227
      return (tmp);
    }
#line 2229
    if (! (((scm_cell *)x)->car == (383L | (1L << 16)))) {
      badx: 
      {
#line 2230
      scm_wta(x, (char *)1, s_negative_p);
      }
    }
#line 2235
    if (*(((scm_dbl *)x)->real) < 0.0) {
#line 2235
      tmp___0 = (long )(17 << 9) + 372L;
    } else {
#line 2235
      tmp___0 = (long )(16 << 9) + 372L;
    }
#line 2235
    return (tmp___0);
  }
#line 2247
  if (x < 2L) {
#line 2247
    tmp___1 = (long )(17 << 9) + 372L;
  } else {
#line 2247
    tmp___1 = (long )(16 << 9) + 372L;
  }
#line 2247
  return (tmp___1);
}
}
#line 2251 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_max[4]  = {      (char )'m',      (char )'a',      (char )'x',      (char )'\000'};
#line 2253 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_max(SCM x , SCM y ) 
{ 
  double z ;
  SCM tmp ;
  SCM tmp___1 ;
  int tmp___2 ;
  SCM tmp___3 ;
  SCM tmp___4 ;
  SCM tmp___5 ;
  SCM tmp___6 ;
  SCM tmp___7 ;
  SCM tmp___8 ;
  SCM tmp___9 ;
  SCM tmp___10 ;
  SCM tmp___11 ;
  SCM tmp___12 ;
  SCM tmp___13 ;

  {
#line 2261
  if ((long )(18 << 9) + 372L == y) {
#line 2263
    if (! (2 & (int )x)) {
#line 2263
      if (! (6 & (int )x)) {
#line 2263
        if (! ((64767 & (int )((scm_cell *)x)->car) == 127)) {
#line 2263
          goto badx;
        }
      } else {
        badx: 
        {
#line 2264
        scm_wta(x, (char *)1, s_max);
        }
      }
    }
#line 2266
    return (x);
  }
#line 2269
  if (! (2 & (int )x)) {
#line 2271
    if (! (! (6 & (int )x))) {
#line 2271
      goto badx;
    }
#line 2272
    if ((65279 & (int )((scm_cell *)x)->car) == 639) {
#line 2273
      if (2 & (int )y) {
#line 2273
        if (256 & (int )((scm_cell *)x)->car) {
#line 2273
          tmp = y;
        } else {
#line 2273
          tmp = x;
        }
#line 2273
        return (tmp);
      }
#line 2274
      if (! (! (6 & (int )y))) {
#line 2274
        goto bady;
      }
#line 2275
      if ((65279 & (int )((scm_cell *)y)->car) == 639) {
        {
#line 2275
        tmp___2 = scm_bigcomp(x, y);
        }
#line 2275
        if (1 == tmp___2) {
#line 2275
          tmp___1 = y;
        } else {
#line 2275
          tmp___1 = x;
        }
#line 2275
        return (tmp___1);
      }
#line 2276
      if (! (((scm_cell *)y)->car == (383L | (1L << 16)))) {
#line 2276
        goto bady;
      }
      {
#line 2277
      z = scm_big2dbl(x);
      }
#line 2278
      if (z < *(((scm_dbl *)y)->real)) {
#line 2278
        tmp___4 = y;
      } else {
        {
#line 2278
        tmp___3 = scm_makdbl(z, 0.0);
#line 2278
        tmp___4 = tmp___3;
        }
      }
#line 2278
      return (tmp___4);
    }
#line 2280
    if (! (((scm_cell *)x)->car == (383L | (1L << 16)))) {
#line 2280
      goto badx;
    }
#line 2284
    if (2 & (int )y) {
#line 2285
      z = (double )(y >> 2);
#line 2285
      if (*(((scm_dbl *)x)->real) < z) {
        {
#line 2285
        tmp___5 = scm_makdbl(z, 0.0);
#line 2285
        tmp___6 = tmp___5;
        }
      } else {
#line 2285
        tmp___6 = x;
      }
#line 2285
      return (tmp___6);
    }
#line 2287
    if (! (! (6 & (int )y))) {
#line 2287
      goto bady;
    }
#line 2288
    if ((65279 & (int )((scm_cell *)y)->car) == 639) {
      {
#line 2289
      z = scm_big2dbl(y);
      }
#line 2289
      if (*(((scm_dbl *)x)->real) < z) {
        {
#line 2289
        tmp___7 = scm_makdbl(z, 0.0);
#line 2289
        tmp___8 = tmp___7;
        }
      } else {
#line 2289
        tmp___8 = x;
      }
#line 2289
      return (tmp___8);
    }
#line 2290
    if (! (((scm_cell *)y)->car == (383L | (1L << 16)))) {
#line 2290
      goto bady;
    }
#line 2294
    if (*(((scm_dbl *)x)->real) < *(((scm_dbl *)y)->real)) {
#line 2294
      tmp___9 = y;
    } else {
#line 2294
      tmp___9 = x;
    }
#line 2294
    return (tmp___9);
  }
#line 2296
  if (! (2 & (int )y)) {
#line 2298
    if (! (! (6 & (int )y))) {
#line 2298
      goto bady;
    }
#line 2299
    if ((65279 & (int )((scm_cell *)y)->car) == 639) {
#line 2299
      if (256 & (int )((scm_cell *)y)->car) {
#line 2299
        tmp___10 = x;
      } else {
#line 2299
        tmp___10 = y;
      }
#line 2299
      return (tmp___10);
    }
#line 2301
    if (! (((scm_cell *)y)->car == (383L | (1L << 16)))) {
      bady: 
      {
#line 2302
      scm_wta(y, (char *)2, s_max);
      }
    }
#line 2310
    z = (double )(x >> 2);
#line 2310
    if (z < *(((scm_dbl *)y)->real)) {
#line 2310
      tmp___12 = y;
    } else {
      {
#line 2310
      tmp___11 = scm_makdbl(z, 0.0);
#line 2310
      tmp___12 = tmp___11;
      }
    }
#line 2310
    return (tmp___12);
  }
#line 2332
  if (x < y) {
#line 2332
    tmp___13 = y;
  } else {
#line 2332
    tmp___13 = x;
  }
#line 2332
  return (tmp___13);
}
}
#line 2338 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_min[4]  = {      (char )'m',      (char )'i',      (char )'n',      (char )'\000'};
#line 2340 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_min(SCM x , SCM y ) 
{ 
  double z ;
  SCM tmp ;
  SCM tmp___1 ;
  int tmp___2 ;
  SCM tmp___3 ;
  SCM tmp___4 ;
  SCM tmp___5 ;
  SCM tmp___6 ;
  SCM tmp___7 ;
  SCM tmp___8 ;
  SCM tmp___9 ;
  SCM tmp___10 ;
  SCM tmp___11 ;
  SCM tmp___12 ;
  SCM tmp___13 ;

  {
#line 2348
  if ((long )(18 << 9) + 372L == y) {
#line 2350
    if (! (2 & (int )x)) {
#line 2350
      if (! (6 & (int )x)) {
#line 2350
        if (! ((64767 & (int )((scm_cell *)x)->car) == 127)) {
#line 2350
          goto badx;
        }
      } else {
        badx: 
        {
#line 2351
        scm_wta(x, (char *)1, s_min);
        }
      }
    }
#line 2353
    return (x);
  }
#line 2356
  if (! (2 & (int )x)) {
#line 2358
    if (! (! (6 & (int )x))) {
#line 2358
      goto badx;
    }
#line 2359
    if ((65279 & (int )((scm_cell *)x)->car) == 639) {
#line 2360
      if (2 & (int )y) {
#line 2360
        if (256 & (int )((scm_cell *)x)->car) {
#line 2360
          tmp = x;
        } else {
#line 2360
          tmp = y;
        }
#line 2360
        return (tmp);
      }
#line 2361
      if (! (! (6 & (int )y))) {
#line 2361
        goto bady;
      }
#line 2362
      if ((65279 & (int )((scm_cell *)y)->car) == 639) {
        {
#line 2362
        tmp___2 = scm_bigcomp(x, y);
        }
#line 2362
        if (-1 == tmp___2) {
#line 2362
          tmp___1 = y;
        } else {
#line 2362
          tmp___1 = x;
        }
#line 2362
        return (tmp___1);
      }
#line 2363
      if (! (((scm_cell *)y)->car == (383L | (1L << 16)))) {
#line 2363
        goto bady;
      }
      {
#line 2364
      z = scm_big2dbl(x);
      }
#line 2365
      if (z > *(((scm_dbl *)y)->real)) {
#line 2365
        tmp___4 = y;
      } else {
        {
#line 2365
        tmp___3 = scm_makdbl(z, 0.0);
#line 2365
        tmp___4 = tmp___3;
        }
      }
#line 2365
      return (tmp___4);
    }
#line 2367
    if (! (((scm_cell *)x)->car == (383L | (1L << 16)))) {
#line 2367
      goto badx;
    }
#line 2371
    if (2 & (int )y) {
#line 2371
      z = (double )(y >> 2);
#line 2371
      if (*(((scm_dbl *)x)->real) > z) {
        {
#line 2371
        tmp___5 = scm_makdbl(z, 0.0);
#line 2371
        tmp___6 = tmp___5;
        }
      } else {
#line 2371
        tmp___6 = x;
      }
#line 2371
      return (tmp___6);
    }
#line 2373
    if (! (! (6 & (int )y))) {
#line 2373
      goto bady;
    }
#line 2374
    if ((65279 & (int )((scm_cell *)y)->car) == 639) {
      {
#line 2374
      z = scm_big2dbl(y);
      }
#line 2374
      if (*(((scm_dbl *)x)->real) > z) {
        {
#line 2374
        tmp___7 = scm_makdbl(z, 0.0);
#line 2374
        tmp___8 = tmp___7;
        }
      } else {
#line 2374
        tmp___8 = x;
      }
#line 2374
      return (tmp___8);
    }
#line 2375
    if (! (((scm_cell *)y)->car == (383L | (1L << 16)))) {
#line 2375
      goto bady;
    }
#line 2379
    if (*(((scm_dbl *)x)->real) > *(((scm_dbl *)y)->real)) {
#line 2379
      tmp___9 = y;
    } else {
#line 2379
      tmp___9 = x;
    }
#line 2379
    return (tmp___9);
  }
#line 2381
  if (! (2 & (int )y)) {
#line 2383
    if (! (! (6 & (int )y))) {
#line 2383
      goto bady;
    }
#line 2384
    if ((65279 & (int )((scm_cell *)y)->car) == 639) {
#line 2384
      if (256 & (int )((scm_cell *)y)->car) {
#line 2384
        tmp___10 = y;
      } else {
#line 2384
        tmp___10 = x;
      }
#line 2384
      return (tmp___10);
    }
#line 2386
    if (! (((scm_cell *)y)->car == (383L | (1L << 16)))) {
      bady: 
      {
#line 2387
      scm_wta(y, (char *)2, s_min);
      }
    }
#line 2395
    z = (double )(x >> 2);
#line 2395
    if (z > *(((scm_dbl *)y)->real)) {
#line 2395
      tmp___12 = y;
    } else {
      {
#line 2395
      tmp___11 = scm_makdbl(z, 0.0);
#line 2395
      tmp___12 = tmp___11;
      }
    }
#line 2395
    return (tmp___12);
  }
#line 2417
  if (x > y) {
#line 2417
    tmp___13 = y;
  } else {
#line 2417
    tmp___13 = x;
  }
#line 2417
  return (tmp___13);
}
}
#line 2423 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_sum[2]  = {      (char )'+',      (char )'\000'};
#line 2425 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_sum(SCM x , SCM y ) 
{ 
  SCM t ;
  SCM tmp ;
  double tmp___0 ;
  double tmp___1 ;
  SCM tmp___2 ;
  double i ;
  SCM tmp___3 ;
  long z ;
  long tmp___4 ;
  int tmp___5 ;
  SCM tmp___6 ;
  double tmp___7 ;
  SCM tmp___8 ;
  SCM tmp___9 ;

  {
#line 2430
  if ((long )(18 << 9) + 372L == y) {
#line 2431
    if ((long )(18 << 9) + 372L == x) {
#line 2431
      return ((SCM )2);
    }
#line 2433
    if (! (2 & (int )x)) {
#line 2433
      if (! (6 & (int )x)) {
#line 2433
        if (! ((64767 & (int )((scm_cell *)x)->car) == 127)) {
#line 2433
          goto badx;
        }
      } else {
        badx: 
        {
#line 2434
        scm_wta(x, (char *)1, s_sum);
        }
      }
    }
#line 2436
    return (x);
  }
#line 2439
  if (! (2 & (int )x)) {
#line 2442
    if (! (! (6 & (int )x))) {
#line 2442
      goto badx;
    }
#line 2443
    if ((65279 & (int )((scm_cell *)x)->car) == 639) {
#line 2444
      if (2 & (int )y) {
#line 2444
        t = x;
#line 2444
        x = y;
#line 2444
        y = t;
#line 2444
        goto intbig;
      }
#line 2445
      if (! (! (6 & (int )y))) {
#line 2445
        goto bady;
      }
#line 2446
      if ((65279 & (int )((scm_cell *)y)->car) == 639) {
#line 2447
        if ((size_t )(((scm_cell *)x)->car >> 16) > (size_t )(((scm_cell *)y)->car >> 16)) {
#line 2447
          t = x;
#line 2447
          x = y;
#line 2447
          y = t;
        }
        {
#line 2448
        tmp = scm_addbig((unsigned short *)((scm_cell *)x)->cdr, (size_t )(((scm_cell *)x)->car >> 16),
                         256 & (int )((scm_cell *)x)->car, y, 0);
        }
#line 2448
        return (tmp);
      }
#line 2450
      if (! ((65535 & (int )((scm_cell *)y)->car) == 383)) {
#line 2450
        goto bady;
      }
      bigreal: 
#line 2451
      if (((scm_cell *)y)->car == ((383L | (1L << 16)) | (2L << 16))) {
#line 2451
        tmp___0 = *((double *)((char *)((scm_cell *)y)->cdr + sizeof(double )));
      } else {
#line 2451
        tmp___0 = 0.0;
      }
      {
#line 2451
      tmp___1 = scm_big2dbl(x);
#line 2451
      tmp___2 = scm_makdbl(tmp___1 + *(((scm_dbl *)y)->real), tmp___0);
      }
#line 2451
      return (tmp___2);
    }
#line 2453
    if (! ((65535 & (int )((scm_cell *)x)->car) == 383)) {
#line 2453
      goto badx;
    }
#line 2457
    if (2 & (int )y) {
#line 2457
      t = x;
#line 2457
      x = y;
#line 2457
      y = t;
#line 2457
      goto intreal;
    }
#line 2459
    if (! (! (6 & (int )y))) {
#line 2459
      goto bady;
    }
#line 2460
    if ((65279 & (int )((scm_cell *)y)->car) == 639) {
#line 2460
      t = x;
#line 2460
      x = y;
#line 2460
      y = t;
#line 2460
      goto bigreal;
    } else
#line 2462
    if (! ((65535 & (int )((scm_cell *)y)->car) == 383)) {
      bady: 
      {
#line 2463
      scm_wta(y, (char *)2, s_sum);
      }
    }
#line 2471
    i = 0.0;
#line 2472
    if (((scm_cell *)x)->car == ((383L | (1L << 16)) | (2L << 16))) {
#line 2472
      i = *((double *)((char *)((scm_cell *)x)->cdr + sizeof(double )));
    }
#line 2473
    if (((scm_cell *)y)->car == ((383L | (1L << 16)) | (2L << 16))) {
#line 2473
      i += *((double *)((char *)((scm_cell *)y)->cdr + sizeof(double )));
    }
    {
#line 2474
    tmp___3 = scm_makdbl(*(((scm_dbl *)x)->real) + *(((scm_dbl *)y)->real), i);
    }
#line 2474
    return (tmp___3);
  }
#line 2476
  if (! (2 & (int )y)) {
#line 2478
    if (! (! (6 & (int )y))) {
#line 2478
      goto bady;
    }
#line 2479
    if ((65279 & (int )((scm_cell *)y)->car) == 639) {
      intbig: 
      {
#line 2482
      tmp___4 = scm_pseudolong(x >> 2);
#line 2482
      z = tmp___4;
      }
#line 2483
      if (x < 0L) {
#line 2483
        tmp___5 = 256;
      } else {
#line 2483
        tmp___5 = 0;
      }
      {
#line 2483
      tmp___6 = scm_addbig((unsigned short *)(& z), ((sizeof(long ) * 8UL + sizeof(unsigned short ) * 8UL) - 1UL) / (sizeof(unsigned short ) * 8UL),
                           tmp___5, y, 0);
      }
#line 2483
      return (tmp___6);
    }
#line 2490
    if (! ((65535 & (int )((scm_cell *)y)->car) == 383)) {
#line 2490
      goto bady;
    }
    intreal: 
#line 2494
    if (((scm_cell *)y)->car == ((383L | (1L << 16)) | (2L << 16))) {
#line 2494
      tmp___7 = *((double *)((char *)((scm_cell *)y)->cdr + sizeof(double )));
    } else {
#line 2494
      tmp___7 = 0.0;
    }
    {
#line 2494
    tmp___8 = scm_makdbl((double )(x >> 2) + *(((scm_dbl *)y)->real), tmp___7);
    }
#line 2494
    return (tmp___8);
  }
#line 2527
  x = (x >> 2) + (y >> 2);
#line 2528
  if (x <= 9223372036854775807L >> 2) {
#line 2528
    if (x >= (-0x7FFFFFFFFFFFFFFF-1) >> 2) {
#line 2528
      return ((x << 2) + 2L);
    }
  }
  {
#line 2530
  tmp___9 = scm_long2big(x);
  }
#line 2530
  return (tmp___9);
}
}
#line 2544 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_difference[2]  = {      (char )'-',      (char )'\000'};
#line 2546 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_difference(SCM x , SCM y ) 
{ 
  SCM tmp ;
  SCM tmp___0 ;
  double tmp___1 ;
  SCM tmp___2 ;
  SCM tmp___3 ;
  SCM tmp___4 ;
  SCM tmp___5 ;
  SCM tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  SCM tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  SCM tmp___12 ;
  SCM tmp___13 ;
  SCM tmp___14 ;
  double tmp___15 ;
  SCM tmp___16 ;
  long z ;
  long tmp___17 ;
  int tmp___18 ;
  SCM tmp___19 ;
  double tmp___20 ;
  SCM tmp___21 ;
  SCM tmp___22 ;

  {
#line 2552
  if (! (2 & (int )x)) {
#line 2554
    if (! (! (6 & (int )x))) {
      badx: 
      {
#line 2555
      scm_wta(x, (char *)1, s_difference);
      }
    }
#line 2557
    if ((long )(18 << 9) + 372L == y) {
#line 2559
      if ((65279 & (int )((scm_cell *)x)->car) == 639) {
        {
#line 2560
        x = scm_copybig(x, ! (256 & (int )((scm_cell *)x)->car));
        }
#line 2561
        if (((size_t )(((scm_cell *)x)->car >> 16) * (sizeof(unsigned short ) * 8UL)) / 8UL <= sizeof(SCM )) {
          {
#line 2561
          tmp = scm_big2inum(x, (size_t )(((scm_cell *)x)->car >> 16));
#line 2561
          tmp___0 = tmp;
          }
        } else {
#line 2561
          tmp___0 = x;
        }
#line 2561
        return (tmp___0);
      }
#line 2565
      if (! ((65535 & (int )((scm_cell *)x)->car) == 383)) {
#line 2565
        goto badx;
      }
#line 2566
      if (((scm_cell *)x)->car == ((383L | (1L << 16)) | (2L << 16))) {
#line 2566
        tmp___1 = - *((double *)((char *)((scm_cell *)x)->cdr + sizeof(double )));
      } else {
#line 2566
        tmp___1 = 0.0;
      }
      {
#line 2566
      tmp___2 = scm_makdbl(- *(((scm_dbl *)x)->real), tmp___1);
      }
#line 2566
      return (tmp___2);
    }
#line 2568
    if (2 & (int )y) {
      {
#line 2568
      tmp___3 = scm_sum(x, (- (y >> 2) << 2) + 2L);
      }
#line 2568
      return (tmp___3);
    }
#line 2570
    if (! (! (6 & (int )y))) {
#line 2570
      goto bady;
    }
#line 2571
    if ((65279 & (int )((scm_cell *)x)->car) == 639) {
#line 2572
      if ((65279 & (int )((scm_cell *)y)->car) == 639) {
#line 2572
        if ((size_t )(((scm_cell *)x)->car >> 16) < (size_t )(((scm_cell *)y)->car >> 16)) {
          {
#line 2572
          tmp___4 = scm_addbig((unsigned short *)((scm_cell *)x)->cdr, (size_t )(((scm_cell *)x)->car >> 16),
                               256 & (int )((scm_cell *)x)->car, y, 256);
#line 2572
          tmp___6 = tmp___4;
          }
        } else {
          {
#line 2572
          tmp___5 = scm_addbig((unsigned short *)((scm_cell *)y)->cdr, (size_t )(((scm_cell *)y)->car >> 16),
                               (256 & (int )((scm_cell *)y)->car) ^ 256, x, 0);
#line 2572
          tmp___6 = tmp___5;
          }
        }
#line 2572
        return (tmp___6);
      }
#line 2575
      if (! ((65535 & (int )((scm_cell *)y)->car) == 383)) {
#line 2575
        goto bady;
      }
#line 2576
      if (((scm_cell *)y)->car == ((383L | (1L << 16)) | (2L << 16))) {
#line 2576
        tmp___7 = - *((double *)((char *)((scm_cell *)y)->cdr + sizeof(double )));
      } else {
#line 2576
        tmp___7 = 0.0;
      }
      {
#line 2576
      tmp___8 = scm_big2dbl(x);
#line 2576
      tmp___9 = scm_makdbl(tmp___8 - *(((scm_dbl *)y)->real), tmp___7);
      }
#line 2576
      return (tmp___9);
    }
#line 2578
    if (! ((65535 & (int )((scm_cell *)x)->car) == 383)) {
#line 2578
      goto badx;
    }
#line 2579
    if ((65279 & (int )((scm_cell *)y)->car) == 639) {
#line 2579
      if (((scm_cell *)x)->car == ((383L | (1L << 16)) | (2L << 16))) {
#line 2579
        tmp___10 = *((double *)((char *)((scm_cell *)x)->cdr + sizeof(double )));
      } else {
#line 2579
        tmp___10 = 0.0;
      }
      {
#line 2579
      tmp___11 = scm_big2dbl(y);
#line 2579
      tmp___12 = scm_makdbl(*(((scm_dbl *)x)->real) - tmp___11, tmp___10);
      }
#line 2579
      return (tmp___12);
    }
#line 2580
    if (! ((65535 & (int )((scm_cell *)y)->car) == 383)) {
#line 2580
      goto bady;
    }
#line 2585
    if (((scm_cell *)x)->car == ((383L | (1L << 16)) | (2L << 16))) {
#line 2586
      if (((scm_cell *)y)->car == ((383L | (1L << 16)) | (2L << 16))) {
        {
#line 2587
        tmp___13 = scm_makdbl(*(((scm_dbl *)x)->real) - *(((scm_dbl *)y)->real), *((double *)((char *)((scm_cell *)x)->cdr + sizeof(double ))) - *((double *)((char *)((scm_cell *)y)->cdr + sizeof(double ))));
        }
#line 2587
        return (tmp___13);
      } else {
        {
#line 2589
        tmp___14 = scm_makdbl(*(((scm_dbl *)x)->real) - *(((scm_dbl *)y)->real), *((double *)((char *)((scm_cell *)x)->cdr + sizeof(double ))));
        }
#line 2589
        return (tmp___14);
      }
    }
#line 2590
    if (((scm_cell *)y)->car == ((383L | (1L << 16)) | (2L << 16))) {
#line 2590
      tmp___15 = - *((double *)((char *)((scm_cell *)y)->cdr + sizeof(double )));
    } else {
#line 2590
      tmp___15 = 0.0;
    }
    {
#line 2590
    tmp___16 = scm_makdbl(*(((scm_dbl *)x)->real) - *(((scm_dbl *)y)->real), tmp___15);
    }
#line 2590
    return (tmp___16);
  }
#line 2592
  if ((long )(18 << 9) + 372L == y) {
#line 2592
    x = - (x >> 2);
#line 2592
    goto checkx;
  }
#line 2593
  if (! (2 & (int )y)) {
#line 2595
    if (! (! (6 & (int )y))) {
#line 2595
      goto bady;
    }
#line 2596
    if ((65279 & (int )((scm_cell *)y)->car) == 639) {
      {
#line 2598
      tmp___17 = scm_pseudolong(x >> 2);
#line 2598
      z = tmp___17;
      }
#line 2599
      if (x < 0L) {
#line 2599
        tmp___18 = 256;
      } else {
#line 2599
        tmp___18 = 0;
      }
      {
#line 2599
      tmp___19 = scm_addbig((unsigned short *)(& z), ((sizeof(long ) * 8UL + sizeof(unsigned short ) * 8UL) - 1UL) / (sizeof(unsigned short ) * 8UL),
                            tmp___18, y, 256);
      }
#line 2599
      return (tmp___19);
    }
#line 2607
    if (! ((65535 & (int )((scm_cell *)y)->car) == 383)) {
      bady: 
      {
#line 2608
      scm_wta(y, (char *)2, s_difference);
      }
    }
#line 2616
    if (((scm_cell *)y)->car == ((383L | (1L << 16)) | (2L << 16))) {
#line 2616
      tmp___20 = - *((double *)((char *)((scm_cell *)y)->cdr + sizeof(double )));
    } else {
#line 2616
      tmp___20 = 0.0;
    }
    {
#line 2616
    tmp___21 = scm_makdbl((double )(x >> 2) - *(((scm_dbl *)y)->real), tmp___20);
    }
#line 2616
    return (tmp___21);
  }
#line 2665
  x = (x >> 2) - (y >> 2);
  checkx: 
#line 2667
  if (x <= 9223372036854775807L >> 2) {
#line 2667
    if (x >= (-0x7FFFFFFFFFFFFFFF-1) >> 2) {
#line 2667
      return ((x << 2) + 2L);
    }
  }
  {
#line 2669
  tmp___22 = scm_long2big(x);
  }
#line 2669
  return (tmp___22);
}
}
#line 2683 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_product[2]  = {      (char )'*',      (char )'\000'};
#line 2685 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_product(SCM x , SCM y ) 
{ 
  SCM t ;
  SCM tmp ;
  double bg ;
  double tmp___0 ;
  double tmp___1 ;
  SCM tmp___2 ;
  SCM tmp___3 ;
  SCM tmp___4 ;
  double tmp___5 ;
  SCM tmp___6 ;
  long z ;
  long tmp___7 ;
  int tmp___8 ;
  SCM tmp___9 ;
  double tmp___10 ;
  SCM tmp___11 ;
  long i ;
  long j ;
  long k ;
  int sgn ;
  SCM tmp___12 ;

  {
#line 2690
  if ((long )(18 << 9) + 372L == y) {
#line 2691
    if ((long )(18 << 9) + 372L == x) {
#line 2691
      return ((1L << 2) + 2L);
    }
#line 2693
    if (! (2 & (int )x)) {
#line 2693
      if (! (6 & (int )x)) {
#line 2693
        if (! ((64767 & (int )((scm_cell *)x)->car) == 127)) {
#line 2693
          goto badx;
        }
      } else {
        badx: 
        {
#line 2694
        scm_wta(x, (char *)1, s_product);
        }
      }
    }
#line 2696
    return (x);
  }
#line 2699
  if (! (2 & (int )x)) {
#line 2702
    if (! (! (6 & (int )x))) {
#line 2702
      goto badx;
    }
#line 2703
    if ((65279 & (int )((scm_cell *)x)->car) == 639) {
#line 2704
      if (2 & (int )y) {
#line 2704
        t = x;
#line 2704
        x = y;
#line 2704
        y = t;
#line 2704
        goto intbig;
      }
#line 2705
      if (! (! (6 & (int )y))) {
#line 2705
        goto bady;
      }
#line 2706
      if ((65279 & (int )((scm_cell *)y)->car) == 639) {
        {
#line 2706
        tmp = scm_mulbig((unsigned short *)((scm_cell *)x)->cdr, (size_t )(((scm_cell *)x)->car >> 16),
                         (unsigned short *)((scm_cell *)y)->cdr, (size_t )(((scm_cell *)y)->car >> 16),
                         (256 & (int )((scm_cell *)x)->car) ^ (256 & (int )((scm_cell *)y)->car));
        }
#line 2706
        return (tmp);
      }
#line 2708
      if (! ((65535 & (int )((scm_cell *)y)->car) == 383)) {
#line 2708
        goto bady;
      }
      bigreal: 
      {
#line 2710
      tmp___0 = scm_big2dbl(x);
#line 2710
      bg = tmp___0;
      }
#line 2711
      if (((scm_cell *)y)->car == ((383L | (1L << 16)) | (2L << 16))) {
#line 2711
        tmp___1 = bg * *((double *)((char *)((scm_cell *)y)->cdr + sizeof(double )));
      } else {
#line 2711
        tmp___1 = 0.0;
      }
      {
#line 2711
      tmp___2 = scm_makdbl(bg * *(((scm_dbl *)y)->real), tmp___1);
      }
#line 2711
      return (tmp___2);
    }
#line 2713
    if (! ((65535 & (int )((scm_cell *)x)->car) == 383)) {
#line 2713
      goto badx;
    }
#line 2717
    if (2 & (int )y) {
#line 2717
      t = x;
#line 2717
      x = y;
#line 2717
      y = t;
#line 2717
      goto intreal;
    }
#line 2719
    if (! (! (6 & (int )y))) {
#line 2719
      goto bady;
    }
#line 2720
    if ((65279 & (int )((scm_cell *)y)->car) == 639) {
#line 2720
      t = x;
#line 2720
      x = y;
#line 2720
      y = t;
#line 2720
      goto bigreal;
    } else
#line 2722
    if (! ((65535 & (int )((scm_cell *)y)->car) == 383)) {
      bady: 
      {
#line 2723
      scm_wta(y, (char *)2, s_product);
      }
    }
#line 2731
    if (((scm_cell *)x)->car == ((383L | (1L << 16)) | (2L << 16))) {
#line 2732
      if (((scm_cell *)y)->car == ((383L | (1L << 16)) | (2L << 16))) {
        {
#line 2733
        tmp___3 = scm_makdbl(*(((scm_dbl *)x)->real) * *(((scm_dbl *)y)->real) - *((double *)((char *)((scm_cell *)x)->cdr + sizeof(double ))) * *((double *)((char *)((scm_cell *)y)->cdr + sizeof(double ))),
                             *(((scm_dbl *)x)->real) * *((double *)((char *)((scm_cell *)y)->cdr + sizeof(double ))) + *((double *)((char *)((scm_cell *)x)->cdr + sizeof(double ))) * *(((scm_dbl *)y)->real));
        }
#line 2733
        return (tmp___3);
      } else {
        {
#line 2736
        tmp___4 = scm_makdbl(*(((scm_dbl *)x)->real) * *(((scm_dbl *)y)->real), *((double *)((char *)((scm_cell *)x)->cdr + sizeof(double ))) * *(((scm_dbl *)y)->real));
        }
#line 2736
        return (tmp___4);
      }
    }
#line 2737
    if (((scm_cell *)y)->car == ((383L | (1L << 16)) | (2L << 16))) {
#line 2737
      tmp___5 = *(((scm_dbl *)x)->real) * *((double *)((char *)((scm_cell *)y)->cdr + sizeof(double )));
    } else {
#line 2737
      tmp___5 = 0.0;
    }
    {
#line 2737
    tmp___6 = scm_makdbl(*(((scm_dbl *)x)->real) * *(((scm_dbl *)y)->real), tmp___5);
    }
#line 2737
    return (tmp___6);
  }
#line 2740
  if (! (2 & (int )y)) {
#line 2742
    if (! (! (6 & (int )y))) {
#line 2742
      goto bady;
    }
#line 2743
    if ((65279 & (int )((scm_cell *)y)->car) == 639) {
      intbig: 
#line 2744
      if (2L == x) {
#line 2744
        return (x);
      }
#line 2744
      if ((1L << 2) + 2L == x) {
#line 2744
        return (y);
      }
      {
#line 2747
      tmp___7 = scm_pseudolong(x >> 2);
#line 2747
      z = tmp___7;
      }
#line 2748
      if (256 & (int )((scm_cell *)y)->car) {
#line 2748
        tmp___8 = x > 0L;
      } else {
#line 2748
        tmp___8 = x < 0L;
      }
      {
#line 2748
      tmp___9 = scm_mulbig((unsigned short *)(& z), ((sizeof(long ) * 8UL + sizeof(unsigned short ) * 8UL) - 1UL) / (sizeof(unsigned short ) * 8UL),
                           (unsigned short *)((scm_cell *)y)->cdr, (size_t )(((scm_cell *)y)->car >> 16),
                           tmp___8);
      }
#line 2748
      return (tmp___9);
    }
#line 2758
    if (! ((65535 & (int )((scm_cell *)y)->car) == 383)) {
#line 2758
      goto bady;
    }
    intreal: 
#line 2762
    if (((scm_cell *)y)->car == ((383L | (1L << 16)) | (2L << 16))) {
#line 2762
      tmp___10 = (double )(x >> 2) * *((double *)((char *)((scm_cell *)y)->cdr + sizeof(double )));
    } else {
#line 2762
      tmp___10 = 0.0;
    }
    {
#line 2762
    tmp___11 = scm_makdbl((double )(x >> 2) * *(((scm_dbl *)y)->real), tmp___10);
    }
#line 2762
    return (tmp___11);
  }
#line 2799
  i = x >> 2;
#line 2800
  if (0L == i) {
#line 2800
    return (x);
  }
#line 2801
  j = y >> 2;
#line 2802
  k = i * j;
#line 2803
  y = (k << 2) + 2L;
#line 2804
  if (k != y >> 2) {
    {
#line 2806
    sgn = (i < 0L) ^ (j < 0L);
#line 2808
    i = scm_pseudolong(i);
#line 2809
    j = scm_pseudolong(j);
#line 2810
    tmp___12 = scm_mulbig((unsigned short *)(& i), ((sizeof(long ) * 8UL + sizeof(unsigned short ) * 8UL) - 1UL) / (sizeof(unsigned short ) * 8UL),
                          (unsigned short *)(& j), ((sizeof(long ) * 8UL + sizeof(unsigned short ) * 8UL) - 1UL) / (sizeof(unsigned short ) * 8UL),
                          sgn);
    }
#line 2810
    return (tmp___12);
  } else
#line 2804
  if (k / i != j) {
    {
#line 2806
    sgn = (i < 0L) ^ (j < 0L);
#line 2808
    i = scm_pseudolong(i);
#line 2809
    j = scm_pseudolong(j);
#line 2810
    tmp___12 = scm_mulbig((unsigned short *)(& i), ((sizeof(long ) * 8UL + sizeof(unsigned short ) * 8UL) - 1UL) / (sizeof(unsigned short ) * 8UL),
                          (unsigned short *)(& j), ((sizeof(long ) * 8UL + sizeof(unsigned short ) * 8UL) - 1UL) / (sizeof(unsigned short ) * 8UL),
                          sgn);
    }
#line 2810
    return (tmp___12);
  }
#line 2827
  return (y);
}
}
#line 2833 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
double scm_num2dbl(SCM a , char *why ) 
{ 
  double tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 2838
  if (2 & (int )a) {
#line 2839
    return ((double )(a >> 2));
  }
#line 2841
  if (! (! (6 & (int )a))) {
    {
#line 2841
    scm_wta(a, (char *)"wrong type argument", why);
    }
  }
#line 2842
  if (((scm_cell *)a)->car == (383L | (1L << 16))) {
#line 2843
    return (*(((scm_dbl *)a)->real));
  }
  {
#line 2846
  tmp = scm_big2dbl(a);
  }
#line 2846
  return (tmp);
  {
#line 2848
  scm_wta(a, (char *)"wrong type argument", why);
  }
#line 2849
  return ((double )((long )(21 << 9) + 372L));
}
}
#line 2853 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_divide[2]  = {      (char )'/',      (char )'\000'};
#line 2855 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_divide(SCM x , SCM y ) 
{ 
  double d ;
  double r ;
  double i ;
  double a ;
  double tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  SCM tmp___2 ;
  SCM z ;
  SCM w ;
  int tmp___3 ;
  SCM tmp___4 ;
  double tmp___6 ;
  SCM tmp___7 ;
  SCM tmp___8 ;
  SCM tmp___9 ;
  unsigned int tmp___10 ;
  int tmp___11 ;
  double tmp___12 ;
  SCM tmp___13 ;
  SCM tmp___14 ;
  double tmp___15 ;
  double tmp___16 ;
  SCM tmp___17 ;
  SCM tmp___18 ;
  double tmp___19 ;
  SCM tmp___20 ;
  double tmp___21 ;
  SCM tmp___22 ;
  SCM tmp___23 ;
  SCM tmp___24 ;
  double tmp___25 ;
  SCM tmp___26 ;
  SCM tmp___27 ;
  SCM tmp___28 ;
  long z___0 ;
  SCM tmp___29 ;
  SCM tmp___30 ;

  {
#line 2862
  if (! (2 & (int )x)) {
#line 2864
    if (! (! (6 & (int )x))) {
      badx: 
      {
#line 2865
      scm_wta(x, (char *)1, s_divide);
      }
    }
#line 2867
    if ((long )(18 << 9) + 372L == y) {
#line 2869
      if ((65279 & (int )((scm_cell *)x)->car) == 639) {
        {
#line 2869
        tmp = scm_big2dbl(x);
#line 2869
        tmp___0 = scm_makdbl(1.0 / tmp, 0.0);
        }
#line 2869
        return (tmp___0);
      }
#line 2871
      if (! ((65535 & (int )((scm_cell *)x)->car) == 383)) {
#line 2871
        goto badx;
      }
#line 2872
      if (((scm_cell *)x)->car == (383L | (1L << 16))) {
        {
#line 2872
        tmp___1 = scm_makdbl(1.0 / *(((scm_dbl *)x)->real), 0.0);
        }
#line 2872
        return (tmp___1);
      }
      {
#line 2873
      r = *(((scm_dbl *)x)->real);
#line 2873
      i = *((double *)((char *)((scm_cell *)x)->cdr + sizeof(double )));
#line 2873
      d = r * r + i * i;
#line 2874
      tmp___2 = scm_makdbl(r / d, - i / d);
      }
#line 2874
      return (tmp___2);
    }
#line 2877
    if ((65279 & (int )((scm_cell *)x)->car) == 639) {
#line 2879
      if (2 & (int )y) {
#line 2880
        z = y >> 2;
#line 2882
        if (! z) {
          {
#line 2883
          scm_num_overflow(s_divide);
          }
        }
#line 2885
        if (1L == z) {
#line 2885
          return (x);
        }
#line 2886
        if (z < 0L) {
#line 2886
          z = - z;
        }
#line 2887
        if (z < 1L << sizeof(unsigned short ) * 8UL) {
#line 2888
          if (256 & (int )((scm_cell *)x)->car) {
#line 2888
            tmp___3 = y > 0L;
          } else {
#line 2888
            tmp___3 = y < 0L;
          }
          {
#line 2888
          tmp___4 = scm_copybig(x, tmp___3);
#line 2888
          w = tmp___4;
#line 2889
          tmp___10 = scm_divbigdig((unsigned short *)((scm_cell *)w)->cdr, (size_t )(((scm_cell *)w)->car >> 16),
                                   (unsigned short )z);
          }
#line 2889
          if (tmp___10) {
            {
#line 2889
            tmp___6 = scm_big2dbl(x);
#line 2889
            tmp___7 = scm_makdbl(tmp___6 / (double )(y >> 2), 0.0);
#line 2889
            tmp___9 = tmp___7;
            }
          } else {
            {
#line 2889
            tmp___8 = scm_normbig(w);
#line 2889
            tmp___9 = tmp___8;
            }
          }
#line 2889
          return (tmp___9);
        }
        {
#line 2893
        z = scm_pseudolong(z);
        }
#line 2894
        if (256 & (int )((scm_cell *)x)->car) {
#line 2894
          tmp___11 = y > 0L;
        } else {
#line 2894
          tmp___11 = y < 0L;
        }
        {
#line 2894
        z = scm_divbigbig((unsigned short *)((scm_cell *)x)->cdr, (size_t )(((scm_cell *)x)->car >> 16),
                          (unsigned short *)(& z), ((sizeof(long ) * 8UL + sizeof(unsigned short ) * 8UL) - 1UL) / (sizeof(unsigned short ) * 8UL),
                          tmp___11, 3);
        }
#line 2902
        if (z) {
#line 2902
          tmp___14 = z;
        } else {
          {
#line 2902
          tmp___12 = scm_big2dbl(x);
#line 2902
          tmp___13 = scm_makdbl(tmp___12 / (double )(y >> 2), 0.0);
#line 2902
          tmp___14 = tmp___13;
          }
        }
#line 2902
        return (tmp___14);
      }
#line 2904
      if (! (! (6 & (int )y))) {
#line 2904
        goto bady;
      }
#line 2905
      if ((65279 & (int )((scm_cell *)y)->car) == 639) {
        {
#line 2906
        z = scm_divbigbig((unsigned short *)((scm_cell *)x)->cdr, (size_t )(((scm_cell *)x)->car >> 16),
                          (unsigned short *)((scm_cell *)y)->cdr, (size_t )(((scm_cell *)y)->car >> 16),
                          (256 & (int )((scm_cell *)x)->car) ^ (256 & (int )((scm_cell *)y)->car),
                          3);
        }
#line 2908
        if (z) {
#line 2908
          tmp___18 = z;
        } else {
          {
#line 2908
          tmp___15 = scm_big2dbl(x);
#line 2908
          tmp___16 = scm_big2dbl(y);
#line 2908
          tmp___17 = scm_makdbl(tmp___15 / tmp___16, 0.0);
#line 2908
          tmp___18 = tmp___17;
          }
        }
#line 2908
        return (tmp___18);
      }
#line 2910
      if (! ((65535 & (int )((scm_cell *)y)->car) == 383)) {
#line 2910
        goto bady;
      }
#line 2911
      if (((scm_cell *)y)->car == (383L | (1L << 16))) {
        {
#line 2911
        tmp___19 = scm_big2dbl(x);
#line 2911
        tmp___20 = scm_makdbl(tmp___19 / *(((scm_dbl *)y)->real), 0.0);
        }
#line 2911
        return (tmp___20);
      }
      {
#line 2912
      a = scm_big2dbl(x);
      }
#line 2913
      goto complex_div;
    }
#line 2916
    if (! ((65535 & (int )((scm_cell *)x)->car) == 383)) {
#line 2916
      goto badx;
    }
#line 2917
    if (2 & (int )y) {
#line 2917
      d = (double )(y >> 2);
#line 2917
      goto basic_div;
    }
#line 2919
    if (! (! (6 & (int )y))) {
#line 2919
      goto bady;
    }
#line 2920
    if ((65279 & (int )((scm_cell *)y)->car) == 639) {
      {
#line 2920
      d = scm_big2dbl(y);
      }
#line 2920
      goto basic_div;
    }
#line 2921
    if (! ((65535 & (int )((scm_cell *)y)->car) == 383)) {
#line 2921
      goto bady;
    }
#line 2925
    if (((scm_cell *)y)->car == (383L | (1L << 16))) {
#line 2926
      d = *(((scm_dbl *)y)->real);
      basic_div: 
#line 2927
      if (((scm_cell *)x)->car == ((383L | (1L << 16)) | (2L << 16))) {
#line 2927
        tmp___21 = *((double *)((char *)((scm_cell *)x)->cdr + sizeof(double ))) / d;
      } else {
#line 2927
        tmp___21 = 0.0;
      }
      {
#line 2927
      tmp___22 = scm_makdbl(*(((scm_dbl *)x)->real) / d, tmp___21);
      }
#line 2927
      return (tmp___22);
    }
#line 2929
    a = *(((scm_dbl *)x)->real);
#line 2930
    if (((scm_cell *)x)->car == (383L | (1L << 16))) {
#line 2930
      goto complex_div;
    }
    {
#line 2931
    r = *(((scm_dbl *)y)->real);
#line 2931
    i = *((double *)((char *)((scm_cell *)y)->cdr + sizeof(double )));
#line 2931
    d = r * r + i * i;
#line 2932
    tmp___23 = scm_makdbl((a * r + *((double *)((char *)((scm_cell *)x)->cdr + sizeof(double ))) * i) / d,
                          (*((double *)((char *)((scm_cell *)x)->cdr + sizeof(double ))) * r - a * i) / d);
    }
#line 2932
    return (tmp___23);
  }
#line 2934
  if ((long )(18 << 9) + 372L == y) {
#line 2935
    if ((1L << 2) + 2L == x) {
#line 2935
      return (x);
    } else
#line 2935
    if ((-1L << 2) + 2L == x) {
#line 2935
      return (x);
    }
    {
#line 2936
    tmp___24 = scm_makdbl(1.0 / (double )(x >> 2), 0.0);
    }
#line 2936
    return (tmp___24);
  }
#line 2938
  if (! (2 & (int )y)) {
#line 2940
    if (! (! (6 & (int )y))) {
#line 2940
      goto bady;
    }
#line 2941
    if ((65279 & (int )((scm_cell *)y)->car) == 639) {
      {
#line 2941
      tmp___25 = scm_big2dbl(y);
#line 2941
      tmp___26 = scm_makdbl((double )(x >> 2) / tmp___25, 0.0);
      }
#line 2941
      return (tmp___26);
    }
#line 2943
    if (! ((65535 & (int )((scm_cell *)y)->car) == 383)) {
      bady: 
      {
#line 2944
      scm_wta(y, (char *)2, s_divide);
      }
    }
#line 2952
    if (((scm_cell *)y)->car == (383L | (1L << 16))) {
      {
#line 2953
      tmp___27 = scm_makdbl((double )(x >> 2) / *(((scm_dbl *)y)->real), 0.0);
      }
#line 2953
      return (tmp___27);
    }
#line 2954
    a = (double )(x >> 2);
    complex_div: 
    {
#line 2956
    r = *(((scm_dbl *)y)->real);
#line 2956
    i = *((double *)((char *)((scm_cell *)y)->cdr + sizeof(double )));
#line 2956
    d = r * r + i * i;
#line 2957
    tmp___28 = scm_makdbl((a * r) / d, (- a * i) / d);
    }
#line 2957
    return (tmp___28);
  }
#line 3014
  z___0 = y >> 2;
#line 3015
  if (0L == z___0) {
#line 3015
    goto ov;
  } else
#line 3015
  if ((x >> 2) % z___0) {
#line 3015
    goto ov;
  }
#line 3016
  z___0 = (x >> 2) / z___0;
#line 3017
  if (z___0 <= 9223372036854775807L >> 2) {
#line 3017
    if (z___0 >= (-0x7FFFFFFFFFFFFFFF-1) >> 2) {
#line 3017
      return ((z___0 << 2) + 2L);
    }
  }
  {
#line 3019
  tmp___29 = scm_long2big(z___0);
  }
#line 3019
  return (tmp___29);
  ov: 
  {
#line 3022
  tmp___30 = scm_makdbl((double )(x >> 2) / (double )(y >> 2), 0.0);
  }
#line 3022
  return (tmp___30);
}
}
#line 3034 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_asinh[7]  = {      (char )'$',      (char )'a',      (char )'s',      (char )'i', 
        (char )'n',      (char )'h',      (char )'\000'};
#line 3036 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
double scm_asinh(double x ) 
{ 
  double tmp ;
  double tmp___0 ;

  {
  {
#line 3040
  tmp = sqrt(x * x + (double )1);
#line 3040
  tmp___0 = log(x + tmp);
  }
#line 3040
  return (tmp___0);
}
}
#line 3046 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_acosh[7]  = {      (char )'$',      (char )'a',      (char )'c',      (char )'o', 
        (char )'s',      (char )'h',      (char )'\000'};
#line 3048 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
double scm_acosh(double x ) 
{ 
  double tmp ;
  double tmp___0 ;

  {
  {
#line 3052
  tmp = sqrt(x * x - (double )1);
#line 3052
  tmp___0 = log(x + tmp);
  }
#line 3052
  return (tmp___0);
}
}
#line 3058 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_atanh[7]  = {      (char )'$',      (char )'a',      (char )'t',      (char )'a', 
        (char )'n',      (char )'h',      (char )'\000'};
#line 3060 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
double scm_atanh(double x ) 
{ 
  double tmp ;

  {
  {
#line 3064
  tmp = log(((double )1 + x) / ((double )1 - x));
  }
#line 3064
  return (0.5 * tmp);
}
}
#line 3070 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_truncate[9]  = 
#line 3070
  {      (char )'t',      (char )'r',      (char )'u',      (char )'n', 
        (char )'c',      (char )'a',      (char )'t',      (char )'e', 
        (char )'\000'};
#line 3072 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
double scm_truncate(double x ) 
{ 
  double tmp ;
  double tmp___0 ;

  {
#line 3076
  if (x < 0.0) {
    {
#line 3076
    tmp = floor(- x);
    }
#line 3076
    return (- tmp);
  }
  {
#line 3077
  tmp___0 = floor(x);
  }
#line 3077
  return (tmp___0);
}
}
#line 3082 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_round[6]  = {      (char )'r',      (char )'o',      (char )'u',      (char )'n', 
        (char )'d',      (char )'\000'};
#line 3084 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
double scm_round(double x ) 
{ 
  double plus_half ;
  double result ;
  double tmp ;
  double tmp___1 ;
  double tmp___2 ;

  {
  {
#line 3088
  plus_half = x + 0.5;
#line 3089
  tmp = floor(plus_half);
#line 3089
  result = tmp;
  }
#line 3091
  if (plus_half == result) {
    {
#line 3091
    tmp___2 = floor(plus_half / (double )2);
    }
#line 3091
    if (plus_half / (double )2 != tmp___2) {
#line 3091
      tmp___1 = result - (double )1;
    } else {
#line 3091
      tmp___1 = result;
    }
  } else {
#line 3091
    tmp___1 = result;
  }
#line 3091
  return (tmp___1);
}
}
#line 3097 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_exact_to_inexact[15]  = 
#line 3097
  {      (char )'e',      (char )'x',      (char )'a',      (char )'c', 
        (char )'t',      (char )'-',      (char )'>',      (char )'i', 
        (char )'n',      (char )'e',      (char )'x',      (char )'a', 
        (char )'c',      (char )'t',      (char )'\000'};
#line 3099 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
double scm_exact_to_inexact(double z ) 
{ 


  {
#line 3103
  return (z);
}
}
#line 3107 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_i_floor[6]  = {      (char )'f',      (char )'l',      (char )'o',      (char )'o', 
        (char )'r',      (char )'\000'};
#line 3108 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_i_ceil[8]  = 
#line 3108
  {      (char )'c',      (char )'e',      (char )'i',      (char )'l', 
        (char )'i',      (char )'n',      (char )'g',      (char )'\000'};
#line 3109 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_i_sqrt[6]  = {      (char )'$',      (char )'s',      (char )'q',      (char )'r', 
        (char )'t',      (char )'\000'};
#line 3110 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_i_abs[5]  = {      (char )'$',      (char )'a',      (char )'b',      (char )'s', 
        (char )'\000'};
#line 3111 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_i_exp[5]  = {      (char )'$',      (char )'e',      (char )'x',      (char )'p', 
        (char )'\000'};
#line 3112 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_i_log[5]  = {      (char )'$',      (char )'l',      (char )'o',      (char )'g', 
        (char )'\000'};
#line 3113 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_i_sin[5]  = {      (char )'$',      (char )'s',      (char )'i',      (char )'n', 
        (char )'\000'};
#line 3114 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_i_cos[5]  = {      (char )'$',      (char )'c',      (char )'o',      (char )'s', 
        (char )'\000'};
#line 3115 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_i_tan[5]  = {      (char )'$',      (char )'t',      (char )'a',      (char )'n', 
        (char )'\000'};
#line 3116 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_i_asin[6]  = {      (char )'$',      (char )'a',      (char )'s',      (char )'i', 
        (char )'n',      (char )'\000'};
#line 3117 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_i_acos[6]  = {      (char )'$',      (char )'a',      (char )'c',      (char )'o', 
        (char )'s',      (char )'\000'};
#line 3118 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_i_atan[6]  = {      (char )'$',      (char )'a',      (char )'t',      (char )'a', 
        (char )'n',      (char )'\000'};
#line 3119 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_i_sinh[6]  = {      (char )'$',      (char )'s',      (char )'i',      (char )'n', 
        (char )'h',      (char )'\000'};
#line 3120 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_i_cosh[6]  = {      (char )'$',      (char )'c',      (char )'o',      (char )'s', 
        (char )'h',      (char )'\000'};
#line 3121 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_i_tanh[6]  = {      (char )'$',      (char )'t',      (char )'a',      (char )'n', 
        (char )'h',      (char )'\000'};
#line 3125
static void scm_two_doubles(SCM z1 , SCM z2 , char *sstring , struct dpair *xy ) ;
#line 3127 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static void scm_two_doubles(SCM z1 , SCM z2 , char *sstring , struct dpair *xy ) 
{ 


  {
#line 3133
  if (2 & (int )z1) {
#line 3133
    xy->x = (double )(z1 >> 2);
  } else {
#line 3136
    if (! (! (6 & (int )z1))) {
#line 3136
      goto badz1;
    }
#line 3137
    if ((65279 & (int )((scm_cell *)z1)->car) == 639) {
      {
#line 3137
      xy->x = scm_big2dbl(z1);
      }
    } else {
#line 3140
      if (! (((scm_cell *)z1)->car == (383L | (1L << 16)))) {
        badz1: 
        {
#line 3141
        scm_wta(z1, (char *)1, sstring);
        }
      }
#line 3143
      xy->x = *(((scm_dbl *)z1)->real);
    }
  }
#line 3149
  if (2 & (int )z2) {
#line 3149
    xy->y = (double )(z2 >> 2);
  } else {
#line 3152
    if (! (! (6 & (int )z2))) {
#line 3152
      goto badz2;
    }
#line 3153
    if ((65279 & (int )((scm_cell *)z2)->car) == 639) {
      {
#line 3153
      xy->y = scm_big2dbl(z2);
      }
    } else {
#line 3156
      if (! (((scm_cell *)z2)->car == (383L | (1L << 16)))) {
        badz2: 
        {
#line 3157
        scm_wta(z2, (char *)2, sstring);
        }
      }
#line 3159
      xy->y = *(((scm_dbl *)z2)->real);
    }
  }
#line 3165
  return;
}
}
#line 3170 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_sys_expt[6]  = {      (char )'$',      (char )'e',      (char )'x',      (char )'p', 
        (char )'t',      (char )'\000'};
#line 3172 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_sys_expt(SCM z1 , SCM z2 ) 
{ 
  struct dpair xy ;
  double tmp ;
  SCM tmp___0 ;
  void *__cil_tmp6 ;

  {
  {
#line 3178
  scm_two_doubles(z1, z2, s_sys_expt, & xy);
#line 3179
  tmp = pow(xy.x, xy.y);
#line 3179
  tmp___0 = scm_makdbl(tmp, 0.0);
  }
#line 3179
  return (tmp___0);
}
}
#line 3184 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_sys_atan2[7]  = {      (char )'$',      (char )'a',      (char )'t',      (char )'a', 
        (char )'n',      (char )'2',      (char )'\000'};
#line 3186 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_sys_atan2(SCM z1 , SCM z2 ) 
{ 
  struct dpair xy ;
  double tmp ;
  SCM tmp___0 ;
  void *__cil_tmp6 ;

  {
  {
#line 3192
  scm_two_doubles(z1, z2, s_sys_atan2, & xy);
#line 3193
  tmp = atan2(xy.x, xy.y);
#line 3193
  tmp___0 = scm_makdbl(tmp, 0.0);
  }
#line 3193
  return (tmp___0);
}
}
#line 3198 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_make_rectangular[17]  = 
#line 3198
  {      (char )'m',      (char )'a',      (char )'k',      (char )'e', 
        (char )'-',      (char )'r',      (char )'e',      (char )'c', 
        (char )'t',      (char )'a',      (char )'n',      (char )'g', 
        (char )'u',      (char )'l',      (char )'a',      (char )'r', 
        (char )'\000'};
#line 3200 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_make_rectangular(SCM z1 , SCM z2 ) 
{ 
  struct dpair xy ;
  SCM tmp ;
  void *__cil_tmp5 ;

  {
  {
#line 3206
  scm_two_doubles(z1, z2, s_make_rectangular, & xy);
#line 3207
  tmp = scm_makdbl(xy.x, xy.y);
  }
#line 3207
  return (tmp);
}
}
#line 3212 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_make_polar[11]  = 
#line 3212
  {      (char )'m',      (char )'a',      (char )'k',      (char )'e', 
        (char )'-',      (char )'p',      (char )'o',      (char )'l', 
        (char )'a',      (char )'r',      (char )'\000'};
#line 3214 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_make_polar(SCM z1 , SCM z2 ) 
{ 
  struct dpair xy ;
  double tmp ;
  double tmp___0 ;
  SCM tmp___1 ;
  void *__cil_tmp7 ;

  {
  {
#line 3220
  scm_two_doubles(z1, z2, s_make_polar, & xy);
#line 3221
  tmp = sin(xy.y);
#line 3221
  tmp___0 = cos(xy.y);
#line 3221
  tmp___1 = scm_makdbl(xy.x * tmp___0, xy.x * tmp);
  }
#line 3221
  return (tmp___1);
}
}
#line 3227 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_real_part[10]  = 
#line 3227
  {      (char )'r',      (char )'e',      (char )'a',      (char )'l', 
        (char )'-',      (char )'p',      (char )'a',      (char )'r', 
        (char )'t',      (char )'\000'};
#line 3229 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_real_part(SCM z ) 
{ 
  SCM tmp ;

  {
#line 3233
  if (! (2 & (int )z)) {
#line 3235
    if (! (! (6 & (int )z))) {
#line 3235
      goto badz;
    }
#line 3236
    if ((65279 & (int )((scm_cell *)z)->car) == 639) {
#line 3236
      return (z);
    }
#line 3238
    if (! ((65535 & (int )((scm_cell *)z)->car) == 383)) {
      badz: 
      {
#line 3239
      scm_wta(z, (char *)1, s_real_part);
      }
    }
#line 3244
    if (((scm_cell *)z)->car == ((383L | (1L << 16)) | (2L << 16))) {
      {
#line 3244
      tmp = scm_makdbl(*(((scm_dbl *)z)->real), 0.0);
      }
#line 3244
      return (tmp);
    }
  }
#line 3246
  return (z);
}
}
#line 3251 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_imag_part[10]  = 
#line 3251
  {      (char )'i',      (char )'m',      (char )'a',      (char )'g', 
        (char )'-',      (char )'p',      (char )'a',      (char )'r', 
        (char )'t',      (char )'\000'};
#line 3253 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_imag_part(SCM z ) 
{ 
  SCM tmp ;

  {
#line 3257
  if (2 & (int )z) {
#line 3257
    return ((SCM )2);
  }
#line 3259
  if (! (! (6 & (int )z))) {
#line 3259
    goto badz;
  }
#line 3260
  if ((65279 & (int )((scm_cell *)z)->car) == 639) {
#line 3260
    return ((SCM )2);
  }
#line 3262
  if (! ((65535 & (int )((scm_cell *)z)->car) == 383)) {
    badz: 
    {
#line 3263
    scm_wta(z, (char *)1, s_imag_part);
    }
  }
#line 3268
  if (((scm_cell *)z)->car == ((383L | (1L << 16)) | (2L << 16))) {
    {
#line 3268
    tmp = scm_makdbl(*((double *)((char *)((scm_cell *)z)->cdr + sizeof(double ))),
                     0.0);
    }
#line 3268
    return (tmp);
  }
#line 3269
  return (scm_sys_protects[0]);
}
}
#line 3274 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_magnitude[10]  = 
#line 3274
  {      (char )'m',      (char )'a',      (char )'g',      (char )'n', 
        (char )'i',      (char )'t',      (char )'u',      (char )'d', 
        (char )'e',      (char )'\000'};
#line 3276 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_magnitude(SCM z ) 
{ 
  SCM tmp ;
  SCM tmp___0 ;
  double i ;
  double r ;
  double tmp___1 ;
  SCM tmp___2 ;
  double tmp___3 ;
  SCM tmp___4 ;

  {
#line 3280
  if (2 & (int )z) {
    {
#line 3280
    tmp = scm_abs(z);
    }
#line 3280
    return (tmp);
  }
#line 3282
  if (! (! (6 & (int )z))) {
#line 3282
    goto badz;
  }
#line 3283
  if ((65279 & (int )((scm_cell *)z)->car) == 639) {
    {
#line 3283
    tmp___0 = scm_abs(z);
    }
#line 3283
    return (tmp___0);
  }
#line 3285
  if (! ((65535 & (int )((scm_cell *)z)->car) == 383)) {
    badz: 
    {
#line 3286
    scm_wta(z, (char *)1, s_magnitude);
    }
  }
#line 3291
  if (((scm_cell *)z)->car == ((383L | (1L << 16)) | (2L << 16))) {
    {
#line 3293
    i = *((double *)((char *)((scm_cell *)z)->cdr + sizeof(double )));
#line 3293
    r = *(((scm_dbl *)z)->real);
#line 3294
    tmp___1 = sqrt(i * i + r * r);
#line 3294
    tmp___2 = scm_makdbl(tmp___1, 0.0);
    }
#line 3294
    return (tmp___2);
  }
  {
#line 3296
  tmp___3 = fabs(*(((scm_dbl *)z)->real));
#line 3296
  tmp___4 = scm_makdbl(tmp___3, 0.0);
  }
#line 3296
  return (tmp___4);
}
}
#line 3302 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_angle[6]  = {      (char )'a',      (char )'n',      (char )'g',      (char )'l', 
        (char )'e',      (char )'\000'};
#line 3304 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_angle(SCM z ) 
{ 
  double x ;
  double y ;
  double tmp ;
  SCM tmp___0 ;

  {
#line 3308
  y = 0.0;
#line 3309
  if (2 & (int )z) {
#line 3309
    if (z >= 2L) {
#line 3309
      x = 1.0;
    } else {
#line 3309
      x = - 1.0;
    }
#line 3309
    goto do_angle;
  }
#line 3311
  if (! (! (6 & (int )z))) {
#line 3311
    goto badz;
  }
#line 3312
  if ((65279 & (int )((scm_cell *)z)->car) == 639) {
#line 3312
    if ((65535 & (int )((scm_cell *)z)->car) == 639) {
#line 3312
      x = 1.0;
    } else {
#line 3312
      x = - 1.0;
    }
#line 3312
    goto do_angle;
  }
#line 3314
  if (! ((65535 & (int )((scm_cell *)z)->car) == 383)) {
    badz: 
    {
#line 3315
    scm_wta(z, (char *)1, s_angle);
    }
  }
#line 3320
  if (((scm_cell *)z)->car == (383L | (1L << 16))) {
#line 3322
    x = *(((scm_dbl *)z)->real);
#line 3323
    goto do_angle;
  }
#line 3325
  x = *(((scm_dbl *)z)->real);
#line 3325
  y = *((double *)((char *)((scm_cell *)z)->cdr + sizeof(double )));
  do_angle: 
  {
#line 3327
  tmp = atan2(y, x);
#line 3327
  tmp___0 = scm_makdbl(tmp, 0.0);
  }
#line 3327
  return (tmp___0);
}
}
#line 3331 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
static char s_inexact_to_exact[15]  = 
#line 3331
  {      (char )'i',      (char )'n',      (char )'e',      (char )'x', 
        (char )'a',      (char )'c',      (char )'t',      (char )'-', 
        (char )'>',      (char )'e',      (char )'x',      (char )'a', 
        (char )'c',      (char )'t',      (char )'\000'};
#line 3333 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_inexact_to_exact(SCM z ) 
{ 
  double u ;
  double tmp ;
  SCM ans ;
  SCM tmp___0 ;

  {
#line 3337
  if (2 & (int )z) {
#line 3337
    return (z);
  }
#line 3339
  if (! (! (6 & (int )z))) {
#line 3339
    goto badz;
  }
#line 3340
  if ((65279 & (int )((scm_cell *)z)->car) == 639) {
#line 3340
    return (z);
  }
#line 3342
  if (! (((scm_cell *)z)->car == (383L | (1L << 16)))) {
    badz: 
    {
#line 3343
    scm_wta(z, (char *)1, s_inexact_to_exact);
    }
  }
  {
#line 3350
  tmp = floor(*(((scm_dbl *)z)->real) + 0.5);
#line 3350
  u = tmp;
  }
#line 3351
  if (u <= (double )(9223372036854775807L >> 2)) {
#line 3351
    if (- u <= (double )(- ((-0x7FFFFFFFFFFFFFFF-1) >> 2))) {
#line 3353
      ans = ((long )u << 2) + 2L;
#line 3354
      if (ans >> 2 == (long )u) {
#line 3354
        return (ans);
      }
    }
  }
#line 3356
  if (! (! (u == u / (double )2))) {
#line 3356
    goto badz;
  }
  {
#line 3357
  tmp___0 = scm_dbl2big(u);
  }
#line 3357
  return (tmp___0);
}
}
#line 3385 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_dbl2big(double d ) 
{ 
  size_t i ;
  long c ;
  unsigned short *digits ;
  SCM ans ;
  double u ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  size_t tmp___2 ;
  char *__cil_tmp11 ;

  {
#line 3389
  i = (size_t )0;
#line 3393
  if (d < (double )0) {
#line 3393
    tmp = - d;
  } else {
#line 3393
    tmp = d;
  }
#line 3393
  u = tmp;
  {
#line 3394
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3394
    tmp___0 = floor(u);
    }
#line 3394
    if (! ((double )0 != tmp___0)) {
#line 3394
      goto while_break;
    }
#line 3394
    u /= (double )(1L << sizeof(unsigned short ) * 8UL);
#line 3394
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3395
  ans = scm_mkbig(i, d < (double )0);
#line 3396
  digits = (unsigned short *)((scm_cell *)ans)->cdr;
  }
  {
#line 3397
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3397
    tmp___2 = i;
#line 3397
    i --;
#line 3397
    if (! tmp___2) {
#line 3397
      goto while_break___0;
    }
    {
#line 3398
    u *= (double )(1L << sizeof(unsigned short ) * 8UL);
#line 3399
    tmp___1 = floor(u);
#line 3399
    c = (long )tmp___1;
#line 3400
    u -= (double )c;
#line 3401
    *(digits + i) = (unsigned short )c;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3404
  if (u != (double )0) {
    {
#line 3405
    scm_num_overflow((char *)"dbl2big");
    }
  }
#line 3407
  return (ans);
}
}
#line 3413 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
double scm_big2dbl(SCM b ) 
{ 
  double ans ;
  size_t i ;
  unsigned short *digits ;
  size_t tmp ;

  {
#line 3417
  ans = 0.0;
#line 3418
  i = (size_t )(((scm_cell *)b)->car >> 16);
#line 3419
  digits = (unsigned short *)((scm_cell *)b)->cdr;
  {
#line 3420
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3420
    tmp = i;
#line 3420
    i --;
#line 3420
    if (! tmp) {
#line 3420
      goto while_break;
    }
#line 3420
    ans = (double )*(digits + i) + (double )(1L << sizeof(unsigned short ) * 8UL) * ans;
  }
  while_break: /* CIL Label */ ;
  }
#line 3421
  if (895 == (65535 & (int )((scm_cell *)b)->car)) {
#line 3421
    return (- ans);
  }
#line 3422
  return (ans);
}
}
#line 3428 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_long2num(long sl ) 
{ 
  SCM tmp ;

  {
#line 3432
  if (sl <= 9223372036854775807L >> 2) {
#line 3432
    if (! (sl >= (-0x7FFFFFFFFFFFFFFF-1) >> 2)) {
      {
#line 3434
      tmp = scm_long2big(sl);
      }
#line 3434
      return (tmp);
    }
  } else {
    {
#line 3434
    tmp = scm_long2big(sl);
    }
#line 3434
    return (tmp);
  }
#line 3443
  return ((sl << 2) + 2L);
}
}
#line 3470 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
SCM scm_ulong2num(unsigned long sl ) 
{ 
  SCM tmp ;

  {
#line 3474
  if (! (sl <= (unsigned long )(9223372036854775807L >> 2))) {
    {
#line 3476
    tmp = scm_ulong2big(sl);
    }
#line 3476
    return (tmp);
  }
#line 3485
  return ((SCM )((sl << 2) + 2UL));
}
}
#line 3489 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
long scm_num2long(SCM num , char *pos , char *s_caller ) 
{ 
  long res ;
  double u ;
  long oldres ;
  size_t l ;
  size_t tmp ;

  {
#line 3496
  if (2 & (int )num) {
#line 3498
    res = num >> 2;
#line 3499
    return (res);
  }
#line 3501
  if (! (! (6 & (int )num))) {
#line 3501
    goto errout;
  }
#line 3503
  if (((scm_cell *)num)->car == (383L | (1L << 16))) {
#line 3505
    u = *(((scm_dbl *)num)->real);
#line 3506
    res = (long )u;
#line 3507
    if ((double )res == u) {
#line 3509
      return (res);
    }
  }
#line 3514
  if ((65279 & (int )((scm_cell *)num)->car) == 639) {
#line 3517
    res = 0L;
#line 3518
    oldres = 0L;
#line 3519
    l = (size_t )(((scm_cell *)num)->car >> 16);
    {
#line 3519
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3519
      tmp = l;
#line 3519
      l --;
#line 3519
      if (! tmp) {
#line 3519
        goto while_break;
      }
#line 3521
      res = (long )(((unsigned long )res << sizeof(unsigned short ) * 8UL) + (unsigned long )*((unsigned short *)((scm_cell *)num)->cdr + l));
#line 3522
      if (res < oldres) {
#line 3523
        goto errout;
      }
#line 3524
      oldres = res;
    }
    while_break: /* CIL Label */ ;
    }
#line 3526
    if ((65535 & (int )((scm_cell *)num)->car) == 639) {
#line 3527
      return (res);
    } else {
#line 3529
      return (- res);
    }
  }
  errout: 
  {
#line 3532
  scm_wta(num, pos, s_caller);
  }
#line 3533
  return ((long )(21 << 9) + 372L);
}
}
#line 3540 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
long num2long(SCM num , char *pos , char *s_caller ) 
{ 
  long res ;
  double u ;
  size_t l ;
  size_t tmp ;

  {
#line 3547
  if (2 & (int )num) {
#line 3548
    res = num >> 2;
#line 3549
    return (res);
  }
#line 3551
  if (! (! (6 & (int )num))) {
#line 3551
    goto errout;
  }
#line 3553
  if (((scm_cell *)num)->car == (383L | (1L << 16))) {
#line 3554
    u = *(((scm_dbl *)num)->real);
#line 3555
    if ((double )(((-0x7FFFFFFFFFFFFFFF-1) >> 2) * 4L) <= u) {
#line 3555
      if (u <= (double )((9223372036854775807L >> 2) * 4L + 3L)) {
#line 3557
        res = (long )u;
#line 3558
        return (res);
      }
    }
  }
#line 3563
  if ((65279 & (int )((scm_cell *)num)->car) == 639) {
#line 3564
    l = (size_t )(((scm_cell *)num)->car >> 16);
#line 3565
    if (! (((sizeof(long ) * 8UL + sizeof(unsigned short ) * 8UL) - 1UL) / (sizeof(unsigned short ) * 8UL) >= l)) {
#line 3565
      goto errout;
    }
#line 3566
    res = 0L;
    {
#line 3567
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3567
      tmp = l;
#line 3567
      l --;
#line 3567
      if (! tmp) {
#line 3567
        goto while_break;
      }
#line 3567
      res = (long )(((unsigned long )res << sizeof(unsigned short ) * 8UL) + (unsigned long )*((unsigned short *)((scm_cell *)num)->cdr + l));
    }
    while_break: /* CIL Label */ ;
    }
#line 3568
    return (res);
  }
  errout: 
  {
#line 3571
  scm_wta(num, pos, s_caller);
  }
#line 3572
  return ((long )(21 << 9) + 372L);
}
}
#line 3616 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
unsigned long scm_num2ulong(SCM num , char *pos , char *s_caller ) 
{ 
  unsigned long res ;
  double u ;
  unsigned long oldres ;
  size_t l ;
  size_t tmp ;

  {
#line 3623
  if (2 & (int )num) {
#line 3625
    res = (unsigned long )num >> 2;
#line 3626
    return (res);
  }
#line 3628
  if (! (! (6 & (int )num))) {
#line 3628
    goto errout;
  }
#line 3630
  if (((scm_cell *)num)->car == (383L | (1L << 16))) {
#line 3632
    u = *(((scm_dbl *)num)->real);
#line 3633
    if ((double )0 <= u) {
#line 3633
      if (u <= (double )0xffffffffffffffffUL) {
#line 3635
        res = (unsigned long )u;
#line 3636
        return (res);
      }
    }
  }
#line 3641
  if ((65279 & (int )((scm_cell *)num)->car) == 639) {
#line 3644
    res = 0UL;
#line 3645
    oldres = 0UL;
#line 3646
    l = (size_t )(((scm_cell *)num)->car >> 16);
    {
#line 3646
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3646
      tmp = l;
#line 3646
      l --;
#line 3646
      if (! tmp) {
#line 3646
        goto while_break;
      }
#line 3648
      res = (res << sizeof(unsigned short ) * 8UL) + (unsigned long )*((unsigned short *)((scm_cell *)num)->cdr + l);
#line 3649
      if (res < oldres) {
#line 3650
        goto errout;
      }
#line 3651
      oldres = res;
    }
    while_break: /* CIL Label */ ;
    }
#line 3653
    return (res);
  }
  errout: 
  {
#line 3656
  scm_wta(num, pos, s_caller);
  }
#line 3657
  return ((unsigned long )((long )(21 << 9) + 372L));
}
}
#line 3674 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
void scm_init_numbers(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;

  {
#line 3678
  if (6 & (int )scm_freelist) {
    {
#line 3678
    scm_sys_protects[0] = scm_gc_for_newcell();
    }
  } else {
#line 3678
    scm_sys_protects[0] = scm_freelist;
#line 3678
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 3678
    scm_cells_allocated ++;
  }
  {
#line 3683
  tmp = scm_must_malloc((long )sizeof(double ), (char *)"real");
#line 3683
  ((scm_cell *)scm_sys_protects[0])->cdr = (SCM )tmp;
#line 3684
  *(((scm_dbl *)scm_sys_protects[0])->real) = 0.0;
#line 3685
  ((scm_cell *)scm_sys_protects[0])->car = 383L | (1L << 16);
#line 3688
  scm_dblprec = 15;
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.x"
  scm_make_gsubr(s_exact_p, 1, 0, 0, (SCM (*)())(& scm_exact_p));
#line 2
  scm_make_gsubr(s_odd_p, 1, 0, 0, (SCM (*)())(& scm_odd_p));
#line 3
  scm_make_gsubr(s_even_p, 1, 0, 0, (SCM (*)())(& scm_even_p));
#line 4
  scm_make_gsubr(s_abs, 1, 0, 0, (SCM (*)())(& scm_abs));
#line 5
  scm_make_gsubr(s_quotient, 2, 0, 0, (SCM (*)())(& scm_quotient));
#line 6
  scm_make_gsubr(s_remainder, 2, 0, 0, (SCM (*)())(& scm_remainder));
#line 7
  scm_make_gsubr(s_modulo, 2, 0, 0, (SCM (*)())(& scm_modulo));
#line 8
  scm_make_subr(s_gcd, 103, (SCM (*)())(& scm_gcd));
#line 9
  scm_make_subr(s_lcm, 103, (SCM (*)())(& scm_lcm));
#line 10
  scm_make_subr(s_logand, 103, (SCM (*)())(& scm_logand));
#line 11
  scm_make_subr(s_logior, 103, (SCM (*)())(& scm_logior));
#line 12
  scm_make_subr(s_logxor, 103, (SCM (*)())(& scm_logxor));
#line 13
  scm_make_gsubr(s_logtest, 2, 0, 0, (SCM (*)())(& scm_logtest));
#line 14
  scm_make_gsubr(s_logbit_p, 2, 0, 0, (SCM (*)())(& scm_logbit_p));
#line 15
  scm_make_gsubr(s_lognot, 1, 0, 0, (SCM (*)())(& scm_lognot));
#line 16
  scm_make_gsubr(s_integer_expt, 2, 0, 0, (SCM (*)())(& scm_integer_expt));
#line 17
  scm_make_gsubr(s_ash, 2, 0, 0, (SCM (*)())(& scm_ash));
#line 18
  scm_make_gsubr(s_bit_extract, 3, 0, 0, (SCM (*)())(& scm_bit_extract));
#line 19
  scm_make_gsubr(s_logcount, 1, 0, 0, (SCM (*)())(& scm_logcount));
#line 20
  scm_make_gsubr(s_integer_length, 1, 0, 0, (SCM (*)())(& scm_integer_length));
#line 21
  scm_make_gsubr(s_number_to_string, 1, 1, 0, (SCM (*)())(& scm_number_to_string));
#line 22
  scm_make_gsubr(s_string_to_number, 1, 1, 0, (SCM (*)())(& scm_string_to_number));
#line 23
  scm_make_gsubr(s_number_p, 1, 0, 0, (SCM (*)())(& scm_number_p));
#line 24
  scm_make_gsubr(s_complex_p, 1, 0, 0, (SCM (*)())(& scm_number_p));
#line 25
  scm_make_gsubr(s_real_p, 1, 0, 0, (SCM (*)())(& scm_real_p));
#line 26
  scm_make_gsubr(s_rational_p, 1, 0, 0, (SCM (*)())(& scm_real_p));
#line 27
  scm_make_gsubr(s_int_p, 1, 0, 0, (SCM (*)())(& scm_integer_p));
#line 28
  scm_make_gsubr(s_inexact_p, 1, 0, 0, (SCM (*)())(& scm_inexact_p));
#line 29
  scm_make_subr(s_eq_p, 69, (SCM (*)())(& scm_num_eq_p));
#line 30
  scm_make_subr(s_less_p, 69, (SCM (*)())(& scm_less_p));
#line 31
  scm_make_subr(s_gr_p, 69, (SCM (*)())(& scm_gr_p));
#line 32
  scm_make_subr(s_leq_p, 69, (SCM (*)())(& scm_leq_p));
#line 33
  scm_make_subr(s_geq_p, 69, (SCM (*)())(& scm_geq_p));
#line 34
  scm_make_gsubr(s_zero_p, 1, 0, 0, (SCM (*)())(& scm_zero_p));
#line 35
  scm_make_gsubr(s_positive_p, 1, 0, 0, (SCM (*)())(& scm_positive_p));
#line 36
  scm_make_gsubr(s_negative_p, 1, 0, 0, (SCM (*)())(& scm_negative_p));
#line 37
  scm_make_subr(s_max, 103, (SCM (*)())(& scm_max));
#line 38
  scm_make_subr(s_min, 103, (SCM (*)())(& scm_min));
#line 39
  scm_make_subr(s_sum, 103, (SCM (*)())(& scm_sum));
#line 40
  scm_make_subr(s_difference, 103, (SCM (*)())(& scm_difference));
#line 41
  scm_make_subr(s_product, 103, (SCM (*)())(& scm_product));
#line 42
  scm_make_subr(s_divide, 103, (SCM (*)())(& scm_divide));
#line 43
  scm_make_subr(s_asinh, 93, (SCM (*)())(& scm_asinh));
#line 44
  scm_make_subr(s_acosh, 93, (SCM (*)())(& scm_acosh));
#line 45
  scm_make_subr(s_atanh, 93, (SCM (*)())(& scm_atanh));
#line 46
  scm_make_subr(s_truncate, 93, (SCM (*)())(& scm_truncate));
#line 47
  scm_make_subr(s_round, 93, (SCM (*)())(& scm_round));
#line 48
  scm_make_subr(s_exact_to_inexact, 93, (SCM (*)())(& scm_exact_to_inexact));
#line 49
  scm_make_subr(s_i_floor, 93, (SCM (*)())(& floor));
#line 50
  scm_make_subr(s_i_ceil, 93, (SCM (*)())(& ceil));
#line 51
  scm_make_subr(s_i_sqrt, 93, (SCM (*)())(& sqrt));
#line 52
  scm_make_subr(s_i_abs, 93, (SCM (*)())(& fabs));
#line 53
  scm_make_subr(s_i_exp, 93, (SCM (*)())(& exp));
#line 54
  scm_make_subr(s_i_log, 93, (SCM (*)())(& log));
#line 55
  scm_make_subr(s_i_sin, 93, (SCM (*)())(& sin));
#line 56
  scm_make_subr(s_i_cos, 93, (SCM (*)())(& cos));
#line 57
  scm_make_subr(s_i_tan, 93, (SCM (*)())(& tan));
#line 58
  scm_make_subr(s_i_asin, 93, (SCM (*)())(& asin));
#line 59
  scm_make_subr(s_i_acos, 93, (SCM (*)())(& acos));
#line 60
  scm_make_subr(s_i_atan, 93, (SCM (*)())(& atan));
#line 61
  scm_make_subr(s_i_sinh, 93, (SCM (*)())(& sinh));
#line 62
  scm_make_subr(s_i_cosh, 93, (SCM (*)())(& cosh));
#line 63
  scm_make_subr(s_i_tanh, 93, (SCM (*)())(& tanh));
#line 64
  scm_make_gsubr(s_sys_expt, 2, 0, 0, (SCM (*)())(& scm_sys_expt));
#line 65
  scm_make_gsubr(s_sys_atan2, 2, 0, 0, (SCM (*)())(& scm_sys_atan2));
#line 66
  scm_make_gsubr(s_make_rectangular, 2, 0, 0, (SCM (*)())(& scm_make_rectangular));
#line 67
  scm_make_gsubr(s_make_polar, 2, 0, 0, (SCM (*)())(& scm_make_polar));
#line 68
  scm_make_gsubr(s_real_part, 1, 0, 0, (SCM (*)())(& scm_real_part));
#line 69
  scm_make_gsubr(s_imag_part, 1, 0, 0, (SCM (*)())(& scm_imag_part));
#line 70
  scm_make_gsubr(s_magnitude, 1, 0, 0, (SCM (*)())(& scm_magnitude));
#line 71
  scm_make_gsubr(s_angle, 1, 0, 0, (SCM (*)())(& scm_angle));
#line 72
  scm_make_gsubr(s_inexact_to_exact, 1, 0, 0, (SCM (*)())(& scm_inexact_to_exact));
  }
#line 3703 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/numbers.c"
  return;
}
}
#line 54 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/net_db.h"
SCM scm_gethost(SCM name ) ;
#line 55
SCM scm_inet_aton(SCM address ) ;
#line 56
SCM scm_inet_ntoa(SCM inetid ) ;
#line 57
SCM scm_inet_netof(SCM address ) ;
#line 58
SCM scm_lnaof(SCM address ) ;
#line 59
SCM scm_inet_makeaddr(SCM net , SCM lna ) ;
#line 60
SCM scm_getnet(SCM name ) ;
#line 61
SCM scm_getproto(SCM name ) ;
#line 62
SCM scm_getserv(SCM name , SCM proto ) ;
#line 63
SCM scm_sethost(SCM arg ) ;
#line 64
SCM scm_setnet(SCM arg ) ;
#line 65
SCM scm_setproto(SCM arg ) ;
#line 66
SCM scm_setserv(SCM arg ) ;
#line 67
void scm_init_net_db(void) ;
#line 116 "/usr/include/netdb.h"
extern void sethostent(int __stay_open ) ;
#line 122
extern void endhostent(void) ;
#line 136
extern struct hostent *gethostbyaddr(void const   *__addr , __socklen_t __len , int __type ) ;
#line 143
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 197
extern void setnetent(int __stay_open ) ;
#line 203
extern void endnetent(void) ;
#line 210
extern struct netent *getnetent(void) ;
#line 217
extern struct netent *getnetbyaddr(uint32_t __net , int __type ) ;
#line 223
extern struct netent *getnetbyname(char const   *__name ) ;
#line 269
extern void setservent(int __stay_open ) ;
#line 275
extern void endservent(void) ;
#line 282
extern struct servent *getservent(void) ;
#line 289
extern struct servent *getservbyname(char const   *__name , char const   *__proto ) ;
#line 297
extern struct servent *getservbyport(int __port , char const   *__proto ) ;
#line 338
extern void setprotoent(int __stay_open ) ;
#line 344
extern void endprotoent(void) ;
#line 351
extern struct protoent *getprotoent(void) ;
#line 357
extern struct protoent *getprotobyname(char const   *__name ) ;
#line 363
extern struct protoent *getprotobynumber(int __proto ) ;
#line 38 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t inet_lnaof(struct in_addr __in ) ;
#line 42
extern  __attribute__((__nothrow__)) struct in_addr inet_makeaddr(in_addr_t __net ,
                                                                  in_addr_t __host ) ;
#line 46
extern  __attribute__((__nothrow__)) in_addr_t inet_netof(struct in_addr __in ) ;
#line 54
extern  __attribute__((__nothrow__)) char *inet_ntoa(struct in_addr __in ) ;
#line 74
 __attribute__((__nothrow__)) int inet_aton(char const   *cp , struct in_addr *addr ) ;
#line 74 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/net_db.c"
static char s_inet_aton[10]  = 
#line 74 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/net_db.c"
  {      (char )'i',      (char )'n',      (char )'e',      (char )'t', 
        (char )'-',      (char )'a',      (char )'t',      (char )'o', 
        (char )'n',      (char )'\000'};
#line 76 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/net_db.c"
SCM scm_inet_aton(SCM address ) 
{ 
  struct in_addr soka ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  uint32_t tmp___2 ;
  SCM tmp___3 ;
  void *__cil_tmp8 ;

  {
#line 82
  if (! (6 & (int )address)) {
#line 82
    if (! ((117 & (int )((scm_cell *)address)->car) == 21)) {
#line 82
      if (! ((125 & (int )((scm_cell *)address)->car) == 5)) {
        {
#line 82
        scm_wta(address, (char *)1, s_inet_aton);
        }
      }
    }
  } else {
    {
#line 82
    scm_wta(address, (char *)1, s_inet_aton);
    }
  }
#line 83
  if ((125 & (int )((scm_cell *)address)->car) == 29) {
#line 84
    if ((127 & (int )((scm_cell *)address)->car) == 29) {
#line 84
      tmp = (char *)((scm_cell *)((scm_cell *)((scm_cell *)address)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)address)->cdr)->car >> 2);
    } else {
#line 84
      tmp = (char *)((scm_cell *)address)->cdr;
    }
    {
#line 84
    address = scm_makfromstr((char const   *)tmp, (unsigned long )((scm_cell *)address)->car >> 8,
                             0);
    }
  }
#line 85
  if ((127 & (int )((scm_cell *)address)->car) == 29) {
#line 85
    tmp___0 = (char *)((scm_cell *)((scm_cell *)((scm_cell *)address)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)address)->cdr)->car >> 2);
  } else {
#line 85
    tmp___0 = (char *)((scm_cell *)address)->cdr;
  }
  {
#line 85
  tmp___1 = inet_aton((char const   *)tmp___0, & soka);
  }
#line 85
  if (tmp___1 == 0) {
    {
#line 86
    scm_syserror(s_inet_aton);
    }
  }
  {
#line 87
  tmp___2 = ntohl(soka.s_addr);
#line 87
  tmp___3 = scm_ulong2num((unsigned long )tmp___2);
  }
#line 87
  return (tmp___3);
}
}
#line 91 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/net_db.c"
static char s_inet_ntoa[10]  = 
#line 91
  {      (char )'i',      (char )'n',      (char )'e',      (char )'t', 
        (char )'-',      (char )'n',      (char )'t',      (char )'o', 
        (char )'a',      (char )'\000'};
#line 93 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/net_db.c"
SCM scm_inet_ntoa(SCM inetid ) 
{ 
  struct in_addr addr ;
  char *s___0 ;
  SCM answer ;
  unsigned long tmp ;
  size_t tmp___0 ;
  void *__cil_tmp7 ;

  {
  {
#line 100
  tmp = scm_num2ulong(inetid, (char *)1, s_inet_ntoa);
#line 100
  addr.s_addr = htonl((uint32_t )tmp);
#line 101
  scm_ints_disabled = 1;
#line 102
  s___0 = inet_ntoa(addr);
#line 103
  tmp___0 = strlen((char const   *)s___0);
#line 103
  answer = scm_makfromstr((char const   *)s___0, tmp___0, 0);
#line 104
  scm_ints_disabled = 0;
#line 104
  scm_async_clock --;
  }
#line 104
  if (0U == scm_async_clock) {
    {
#line 104
    scm_async_click();
    }
  }
#line 105
  return (answer);
}
}
#line 108 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/net_db.c"
static char s_inet_netof[11]  = 
#line 108
  {      (char )'i',      (char )'n',      (char )'e',      (char )'t', 
        (char )'-',      (char )'n',      (char )'e',      (char )'t', 
        (char )'o',      (char )'f',      (char )'\000'};
#line 110 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/net_db.c"
SCM scm_inet_netof(SCM address ) 
{ 
  struct in_addr addr ;
  unsigned long tmp ;
  in_addr_t tmp___0 ;
  SCM tmp___1 ;
  void *__cil_tmp6 ;

  {
  {
#line 115
  tmp = scm_num2ulong(address, (char *)1, s_inet_netof);
#line 115
  addr.s_addr = htonl((uint32_t )tmp);
#line 116
  tmp___0 = inet_netof(addr);
#line 116
  tmp___1 = scm_ulong2num((unsigned long )tmp___0);
  }
#line 116
  return (tmp___1);
}
}
#line 119 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/net_db.c"
static char s_lnaof[6]  = {      (char )'l',      (char )'n',      (char )'a',      (char )'o', 
        (char )'f',      (char )'\000'};
#line 121 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/net_db.c"
SCM scm_lnaof(SCM address ) 
{ 
  struct in_addr addr ;
  unsigned long tmp ;
  in_addr_t tmp___0 ;
  SCM tmp___1 ;
  void *__cil_tmp6 ;

  {
  {
#line 126
  tmp = scm_num2ulong(address, (char *)1, s_lnaof);
#line 126
  addr.s_addr = htonl((uint32_t )tmp);
#line 127
  tmp___0 = inet_lnaof(addr);
#line 127
  tmp___1 = scm_ulong2num((unsigned long )tmp___0);
  }
#line 127
  return (tmp___1);
}
}
#line 131 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/net_db.c"
static char s_inet_makeaddr[14]  = 
#line 131
  {      (char )'i',      (char )'n',      (char )'e',      (char )'t', 
        (char )'-',      (char )'m',      (char )'a',      (char )'k', 
        (char )'e',      (char )'a',      (char )'d',      (char )'d', 
        (char )'r',      (char )'\000'};
#line 133 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/net_db.c"
SCM scm_inet_makeaddr(SCM net , SCM lna ) 
{ 
  struct in_addr addr ;
  unsigned long netnum ;
  unsigned long lnanum ;
  uint32_t tmp ;
  SCM tmp___0 ;
  void *__cil_tmp8 ;

  {
  {
#line 142
  netnum = scm_num2ulong(net, (char *)1, s_inet_makeaddr);
#line 143
  lnanum = scm_num2ulong(lna, (char *)2, s_inet_makeaddr);
#line 144
  addr = inet_makeaddr((in_addr_t )netnum, (in_addr_t )lnanum);
#line 145
  tmp = ntohl(addr.s_addr);
#line 145
  tmp___0 = scm_ulong2num((unsigned long )tmp);
  }
#line 145
  return (tmp___0);
}
}
#line 153 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/net_db.c"
static char s_gethost[8]  = 
#line 153
  {      (char )'g',      (char )'e',      (char )'t',      (char )'h', 
        (char )'o',      (char )'s',      (char )'t',      (char )'\000'};
#line 155 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/net_db.c"
SCM scm_gethost(SCM name ) 
{ 
  SCM ans ;
  SCM tmp ;
  SCM *ve ;
  SCM lst ;
  struct hostent *entry ;
  struct in_addr inad ;
  char **argv ;
  int i ;
  unsigned long tmp___0 ;
  size_t tmp___1 ;
  uint32_t tmp___2 ;
  SCM tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp15 ;

  {
  {
#line 159
  tmp = scm_make_vector((long )(5 << 2) + 2L, (long )(21 << 9) + 372L, (long )(16 << 9) + 372L);
#line 159
  ans = tmp;
#line 160
  ve = (SCM *)((scm_cell *)ans)->cdr;
#line 161
  lst = (long )(20 << 9) + 372L;
#line 165
  i = 0;
  }
#line 174
  if (! (6 & (int )name)) {
#line 174
    if ((125 & (int )((scm_cell *)name)->car) == 21) {
      {
#line 176
      scm_ints_disabled = 1;
#line 177
      entry = gethostbyname((char const   *)((char *)((scm_cell *)name)->cdr));
      }
    } else {
      {
#line 181
      tmp___0 = scm_num2ulong(name, (char *)1, s_gethost);
#line 181
      inad.s_addr = htonl((uint32_t )tmp___0);
#line 182
      scm_ints_disabled = 1;
#line 183
      entry = gethostbyaddr((void const   *)((char *)(& inad)), (__socklen_t )sizeof(inad),
                            2);
      }
    }
  } else {
    {
#line 181
    tmp___0 = scm_num2ulong(name, (char *)1, s_gethost);
#line 181
    inad.s_addr = htonl((uint32_t )tmp___0);
#line 182
    scm_ints_disabled = 1;
#line 183
    entry = gethostbyaddr((void const   *)((char *)(& inad)), (__socklen_t )sizeof(inad),
                          2);
    }
  }
#line 185
  scm_ints_disabled = 0;
#line 185
  scm_async_clock --;
#line 185
  if (0U == scm_async_clock) {
    {
#line 185
    scm_async_click();
    }
  }
#line 186
  if (! entry) {
    {
#line 187
    scm_syserror(s_gethost);
    }
  }
  {
#line 188
  tmp___1 = strlen((char const   *)entry->h_name);
#line 188
  *(ve + 0) = scm_makfromstr((char const   *)entry->h_name, tmp___1, 0);
#line 189
  *(ve + 1) = scm_makfromstrs(-1, entry->h_aliases);
#line 190
  *(ve + 2) = ((long )entry->h_addrtype << 2) + 2L;
#line 191
  *(ve + 3) = ((long )entry->h_length << 2) + 2L;
  }
#line 192
  if (sizeof(struct in_addr ) != (unsigned long )entry->h_length) {
#line 194
    *(ve + 4) = (long )(16 << 9) + 372L;
#line 195
    return (ans);
  }
#line 197
  argv = entry->h_addr_list;
  {
#line 197
  while (1) {
    while_continue: /* CIL Label */ ;
#line 197
    if (! *(argv + i)) {
#line 197
      goto while_break;
    }
#line 197
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 198
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 198
    tmp___4 = i;
#line 198
    i --;
#line 198
    if (! tmp___4) {
#line 198
      goto while_break___0;
    }
    {
#line 200
    inad = *((struct in_addr *)*(argv + i));
#line 201
    tmp___2 = ntohl(inad.s_addr);
#line 201
    tmp___3 = scm_ulong2num((unsigned long )tmp___2);
#line 201
    lst = scm_cons(tmp___3, lst);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 203
  *(ve + 4) = lst;
#line 204
  return (ans);
}
}
#line 208 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/net_db.c"
static char s_getnet[7]  = {      (char )'g',      (char )'e',      (char )'t',      (char )'n', 
        (char )'e',      (char )'t',      (char )'\000'};
#line 210 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/net_db.c"
SCM scm_getnet(SCM name ) 
{ 
  SCM ans ;
  SCM *ve ;
  struct netent *entry ;
  unsigned long netnum ;
  size_t tmp ;

  {
  {
#line 218
  ans = scm_make_vector((long )(4 << 2) + 2L, (long )(21 << 9) + 372L, (long )(16 << 9) + 372L);
#line 219
  ve = (SCM *)((scm_cell *)ans)->cdr;
  }
#line 220
  if ((long )(18 << 9) + 372L == name) {
    {
#line 222
    scm_ints_disabled = 1;
#line 223
    entry = getnetent();
    }
  } else
#line 225
  if (! (6 & (int )name)) {
#line 225
    if ((125 & (int )((scm_cell *)name)->car) == 21) {
      {
#line 227
      scm_ints_disabled = 1;
#line 228
      entry = getnetbyname((char const   *)((char *)((scm_cell *)name)->cdr));
      }
    } else {
      {
#line 233
      netnum = scm_num2ulong(name, (char *)1, s_getnet);
#line 234
      scm_ints_disabled = 1;
#line 235
      entry = getnetbyaddr((uint32_t )netnum, 2);
      }
    }
  } else {
    {
#line 233
    netnum = scm_num2ulong(name, (char *)1, s_getnet);
#line 234
    scm_ints_disabled = 1;
#line 235
    entry = getnetbyaddr((uint32_t )netnum, 2);
    }
  }
#line 237
  scm_ints_disabled = 0;
#line 237
  scm_async_clock --;
#line 237
  if (0U == scm_async_clock) {
    {
#line 237
    scm_async_click();
    }
  }
#line 238
  if (! entry) {
    {
#line 239
    scm_syserror(s_getnet);
    }
  }
  {
#line 240
  tmp = strlen((char const   *)entry->n_name);
#line 240
  *(ve + 0) = scm_makfromstr((char const   *)entry->n_name, tmp, 0);
#line 241
  *(ve + 1) = scm_makfromstrs(-1, entry->n_aliases);
#line 242
  *(ve + 2) = ((long )entry->n_addrtype << 2) + 2L;
#line 243
  *(ve + 3) = scm_ulong2num((unsigned long )((long )entry->n_net));
  }
#line 244
  return (ans);
}
}
#line 247 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/net_db.c"
static char s_getproto[9]  = 
#line 247
  {      (char )'g',      (char )'e',      (char )'t',      (char )'p', 
        (char )'r',      (char )'o',      (char )'t',      (char )'o', 
        (char )'\000'};
#line 249 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/net_db.c"
SCM scm_getproto(SCM name ) 
{ 
  SCM ans ;
  SCM *ve ;
  struct protoent *entry ;
  unsigned long protonum ;
  size_t tmp ;

  {
  {
#line 257
  ans = scm_make_vector((long )(3 << 2) + 2L, (long )(21 << 9) + 372L, (long )(16 << 9) + 372L);
#line 258
  ve = (SCM *)((scm_cell *)ans)->cdr;
  }
#line 259
  if ((long )(18 << 9) + 372L == name) {
    {
#line 261
    scm_ints_disabled = 1;
#line 262
    entry = getprotoent();
    }
  } else
#line 264
  if (! (6 & (int )name)) {
#line 264
    if ((125 & (int )((scm_cell *)name)->car) == 21) {
      {
#line 266
      scm_ints_disabled = 1;
#line 267
      entry = getprotobyname((char const   *)((char *)((scm_cell *)name)->cdr));
      }
    } else {
      {
#line 272
      protonum = scm_num2ulong(name, (char *)1, s_getproto);
#line 273
      scm_ints_disabled = 1;
#line 274
      entry = getprotobynumber((int )protonum);
      }
    }
  } else {
    {
#line 272
    protonum = scm_num2ulong(name, (char *)1, s_getproto);
#line 273
    scm_ints_disabled = 1;
#line 274
    entry = getprotobynumber((int )protonum);
    }
  }
#line 276
  scm_ints_disabled = 0;
#line 276
  scm_async_clock --;
#line 276
  if (0U == scm_async_clock) {
    {
#line 276
    scm_async_click();
    }
  }
#line 277
  if (! entry) {
    {
#line 278
    scm_syserror(s_getproto);
    }
  }
  {
#line 279
  tmp = strlen((char const   *)entry->p_name);
#line 279
  *(ve + 0) = scm_makfromstr((char const   *)entry->p_name, tmp, 0);
#line 280
  *(ve + 1) = scm_makfromstrs(-1, entry->p_aliases);
#line 281
  *(ve + 2) = ((long )entry->p_proto << 2) + 2L;
  }
#line 282
  return (ans);
}
}
#line 286
static SCM scm_return_entry(struct servent *entry ) ;
#line 288 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/net_db.c"
static SCM scm_return_entry(struct servent *entry ) 
{ 
  SCM ans ;
  SCM *ve ;
  size_t tmp ;
  uint16_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 295
  ans = scm_make_vector((long )(4 << 2) + 2L, (long )(21 << 9) + 372L, (long )(16 << 9) + 372L);
#line 296
  ve = (SCM *)((scm_cell *)ans)->cdr;
#line 297
  tmp = strlen((char const   *)entry->s_name);
#line 297
  *(ve + 0) = scm_makfromstr((char const   *)entry->s_name, tmp, 0);
#line 298
  *(ve + 1) = scm_makfromstrs(-1, entry->s_aliases);
#line 299
  tmp___0 = ntohs((uint16_t )entry->s_port);
#line 299
  *(ve + 2) = ((long )tmp___0 << 2) + 2L;
#line 300
  tmp___1 = strlen((char const   *)entry->s_proto);
#line 300
  *(ve + 3) = scm_makfromstr((char const   *)entry->s_proto, tmp___1, 0);
#line 301
  scm_ints_disabled = 0;
#line 301
  scm_async_clock --;
  }
#line 301
  if (0U == scm_async_clock) {
    {
#line 301
    scm_async_click();
    }
  }
#line 302
  return (ans);
}
}
#line 305 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/net_db.c"
static char s_getserv[8]  = 
#line 305
  {      (char )'g',      (char )'e',      (char )'t',      (char )'s', 
        (char )'e',      (char )'r',      (char )'v',      (char )'\000'};
#line 307 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/net_db.c"
SCM scm_getserv(SCM name , SCM proto ) 
{ 
  struct servent *entry ;
  SCM tmp ;
  SCM tmp___0 ;

  {
#line 313
  if ((long )(18 << 9) + 372L == name) {
    {
#line 315
    scm_ints_disabled = 1;
#line 316
    entry = getservent();
    }
#line 317
    if (! entry) {
      {
#line 318
      scm_syserror(s_getserv);
      }
    }
    {
#line 319
    tmp = scm_return_entry(entry);
    }
#line 319
    return (tmp);
  }
#line 321
  if (! (6 & (int )proto)) {
#line 321
    if (! ((125 & (int )((scm_cell *)proto)->car) == 21)) {
      {
#line 321
      scm_wta(proto, (char *)2, s_getserv);
      }
    }
  } else {
    {
#line 321
    scm_wta(proto, (char *)2, s_getserv);
    }
  }
#line 322
  if (! (6 & (int )name)) {
#line 322
    if ((125 & (int )((scm_cell *)name)->car) == 21) {
      {
#line 324
      scm_ints_disabled = 1;
#line 325
      entry = getservbyname((char const   *)((char *)((scm_cell *)name)->cdr), (char const   *)((char *)((scm_cell *)proto)->cdr));
      }
    } else {
#line 322
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 329
    if (! (2 & (int )name)) {
      {
#line 329
      scm_wta(name, (char *)1, s_getserv);
      }
    }
    {
#line 330
    scm_ints_disabled = 1;
#line 331
    entry = getservbyport((int )(name >> 2), (char const   *)((char *)((scm_cell *)proto)->cdr));
    }
  }
#line 333
  if (! entry) {
    {
#line 334
    scm_syserror(s_getserv);
    }
  }
  {
#line 335
  tmp___0 = scm_return_entry(entry);
  }
#line 335
  return (tmp___0);
}
}
#line 338 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/net_db.c"
static char s_sethost[8]  = 
#line 338
  {      (char )'s',      (char )'e',      (char )'t',      (char )'h', 
        (char )'o',      (char )'s',      (char )'t',      (char )'\000'};
#line 340 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/net_db.c"
SCM scm_sethost(SCM arg ) 
{ 


  {
#line 344
  if ((long )(18 << 9) + 372L == arg) {
    {
#line 345
    endhostent();
    }
  } else {
    {
#line 347
    sethostent((long )(16 << 9) + 372L != arg);
    }
  }
#line 348
  return ((long )(21 << 9) + 372L);
}
}
#line 351 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/net_db.c"
static char s_setnet[7]  = {      (char )'s',      (char )'e',      (char )'t',      (char )'n', 
        (char )'e',      (char )'t',      (char )'\000'};
#line 353 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/net_db.c"
SCM scm_setnet(SCM arg ) 
{ 


  {
#line 357
  if ((long )(18 << 9) + 372L == arg) {
    {
#line 358
    endnetent();
    }
  } else {
    {
#line 360
    setnetent((long )(16 << 9) + 372L != arg);
    }
  }
#line 361
  return ((long )(21 << 9) + 372L);
}
}
#line 364 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/net_db.c"
static char s_setproto[9]  = 
#line 364
  {      (char )'s',      (char )'e',      (char )'t',      (char )'p', 
        (char )'r',      (char )'o',      (char )'t',      (char )'o', 
        (char )'\000'};
#line 366 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/net_db.c"
SCM scm_setproto(SCM arg ) 
{ 


  {
#line 370
  if ((long )(18 << 9) + 372L == arg) {
    {
#line 371
    endprotoent();
    }
  } else {
    {
#line 373
    setprotoent((long )(16 << 9) + 372L != arg);
    }
  }
#line 374
  return ((long )(21 << 9) + 372L);
}
}
#line 377 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/net_db.c"
static char s_setserv[8]  = 
#line 377
  {      (char )'s',      (char )'e',      (char )'t',      (char )'s', 
        (char )'e',      (char )'r',      (char )'v',      (char )'\000'};
#line 379 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/net_db.c"
SCM scm_setserv(SCM arg ) 
{ 


  {
#line 383
  if ((long )(18 << 9) + 372L == arg) {
    {
#line 384
    endservent();
    }
  } else {
    {
#line 386
    setservent((long )(16 << 9) + 372L != arg);
    }
  }
#line 387
  return ((long )(21 << 9) + 372L);
}
}
#line 391 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/net_db.c"
void scm_init_net_db(void) 
{ 
  SCM tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  SCM tmp___2 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 395
  tmp = scm_ulong2num((unsigned long )((in_addr_t )0));
#line 395
  scm_sysintern((char *)"INADDR_ANY", tmp);
#line 398
  tmp___0 = scm_ulong2num(4294967295UL);
#line 398
  scm_sysintern((char *)"INADDR_BROADCAST", tmp___0);
#line 401
  tmp___1 = scm_ulong2num(4294967295UL);
#line 401
  scm_sysintern((char *)"INADDR_NONE", tmp___1);
#line 404
  tmp___2 = scm_ulong2num((unsigned long )((in_addr_t )2130706433));
#line 404
  scm_sysintern((char *)"INADDR_LOOPBACK", tmp___2);
#line 407
  scm_add_feature((char *)"net-db");
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/net_db.x"
  scm_make_gsubr(s_inet_aton, 1, 0, 0, (SCM (*)())(& scm_inet_aton));
#line 2
  scm_make_gsubr(s_inet_ntoa, 1, 0, 0, (SCM (*)())(& scm_inet_ntoa));
#line 3
  scm_make_gsubr(s_inet_netof, 1, 0, 0, (SCM (*)())(& scm_inet_netof));
#line 4
  scm_make_gsubr(s_lnaof, 1, 0, 0, (SCM (*)())(& scm_lnaof));
#line 5
  scm_make_gsubr(s_inet_makeaddr, 2, 0, 0, (SCM (*)())(& scm_inet_makeaddr));
#line 6
  scm_make_gsubr(s_gethost, 0, 1, 0, (SCM (*)())(& scm_gethost));
#line 7
  scm_make_gsubr(s_getnet, 0, 1, 0, (SCM (*)())(& scm_getnet));
#line 8
  scm_make_gsubr(s_getproto, 0, 1, 0, (SCM (*)())(& scm_getproto));
#line 9
  scm_make_gsubr(s_getserv, 0, 2, 0, (SCM (*)())(& scm_getserv));
#line 10
  scm_make_gsubr(s_sethost, 0, 1, 0, (SCM (*)())(& scm_sethost));
#line 11
  scm_make_gsubr(s_setnet, 0, 1, 0, (SCM (*)())(& scm_setnet));
#line 12
  scm_make_gsubr(s_setproto, 0, 1, 0, (SCM (*)())(& scm_setproto));
#line 13
  scm_make_gsubr(s_setserv, 0, 1, 0, (SCM (*)())(& scm_setserv));
  }
#line 409 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/net_db.c"
  return;
}
}
#line 70 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/extchrs.h"
int xmblen(char const   *str , size_t size ) ;
#line 72
int xmbtowc(xwchar_t *result , unsigned char const   *_str , size_t size ) ;
#line 60 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/mbstrings.h"
SCM scm_multi_byte_string_p(SCM obj ) ;
#line 61
SCM scm_regular_string_p(SCM obj ) ;
#line 62
SCM scm_multi_byte_string(SCM chrs ) ;
#line 63
int scm_mb_ilength(unsigned char *data , int size ) ;
#line 64
SCM scm_multi_byte_string_length(SCM str ) ;
#line 65
SCM scm_symbol_multi_byte_p(SCM symbol ) ;
#line 67
SCM scm_regular_port_p(SCM p ) ;
#line 68
SCM scm_regular_port_x(SCM p ) ;
#line 69
SCM scm_multi_byte_port_p(SCM p ) ;
#line 70
SCM scm_multi_byte_port_x(SCM p ) ;
#line 71
SCM scm_wide_character_port_p(SCM p ) ;
#line 72
SCM scm_wide_character_port_x(SCM p ) ;
#line 76
void scm_init_mbstrings(void) ;
#line 57 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/mbstrings.c"
static char s_multi_byte_string_p[19]  = 
#line 57 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/mbstrings.c"
  {      (char )'m',      (char )'u',      (char )'l',      (char )'t', 
        (char )'i',      (char )'-',      (char )'b',      (char )'y', 
        (char )'t',      (char )'e',      (char )'-',      (char )'s', 
        (char )'t',      (char )'r',      (char )'i',      (char )'n', 
        (char )'g',      (char )'?',      (char )'\000'};
#line 59 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/mbstrings.c"
SCM scm_multi_byte_string_p(SCM obj ) 
{ 
  long tmp ;

  {
#line 63
  if ((127 & (int )((scm_cell *)obj)->car) == 23) {
#line 63
    tmp = (long )(17 << 9) + 372L;
  } else
#line 63
  if ((127 & (int )((scm_cell *)obj)->car) == 7) {
#line 63
    if (*((unsigned long *)((SCM *)*((SCM *)((char *)((scm_cell *)obj)->cdr) - 1) + 3)) != (unsigned long )((long )(16 << 9) + 372L)) {
#line 63
      tmp = (long )(17 << 9) + 372L;
    } else {
#line 63
      tmp = (long )(16 << 9) + 372L;
    }
  } else {
#line 63
    tmp = (long )(16 << 9) + 372L;
  }
#line 63
  return (tmp);
}
}
#line 70 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/mbstrings.c"
SCM scm_regular_string_p(SCM obj ) 
{ 
  long tmp ;

  {
#line 74
  if ((119 & (int )((scm_cell *)obj)->car) == 21) {
#line 74
    tmp = (long )(17 << 9) + 372L;
  } else {
#line 74
    tmp = (long )(16 << 9) + 372L;
  }
#line 74
  return (tmp);
}
}
#line 79 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/mbstrings.c"
static char s_list_to_multi_byte_string[24]  = 
#line 79
  {      (char )'l',      (char )'i',      (char )'s',      (char )'t', 
        (char )'-',      (char )'>',      (char )'m',      (char )'u', 
        (char )'l',      (char )'t',      (char )'i',      (char )'-', 
        (char )'b',      (char )'y',      (char )'t',      (char )'e', 
        (char )'-',      (char )'s',      (char )'t',      (char )'r', 
        (char )'i',      (char )'n',      (char )'g',      (char )'\000'};
#line 80 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/mbstrings.c"
static char s_multi_byte_string[18]  = 
#line 80
  {      (char )'m',      (char )'u',      (char )'l',      (char )'t', 
        (char )'i',      (char )'-',      (char )'b',      (char )'y', 
        (char )'t',      (char )'e',      (char )'-',      (char )'s', 
        (char )'t',      (char )'r',      (char )'i',      (char )'n', 
        (char )'g',      (char )'\000'};
#line 82 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/mbstrings.c"
SCM scm_multi_byte_string(SCM chrs ) 
{ 
  SCM res ;
  register char *data ;
  long i ;
  long byte_len ;
  int used ;
  SCM ch ;
  int tmp ;

  {
  {
#line 91
  i = scm_ilength(chrs);
  }
#line 92
  if (! (i >= 0L)) {
    {
#line 92
    scm_wta(chrs, (char *)1, s_multi_byte_string);
    }
  }
  {
#line 93
  i *= 4L;
#line 94
  res = scm_makstr(i, 0);
#line 95
  ((scm_cell *)res)->car = (SCM )((((unsigned long )((scm_cell *)res)->car >> 8) << 8) + 23UL);
#line 96
  data = (char *)((scm_cell *)res)->cdr;
#line 97
  byte_len = 0L;
#line 98
  xwctomb((char *)0, 0);
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (i) {
#line 99
      if (! ((long )(20 << 9) + 372L != chrs)) {
#line 99
        goto while_break;
      }
    } else {
#line 99
      goto while_break;
    }
#line 104
    ch = ((scm_cell *)chrs)->car;
#line 105
    if (! (((int )ch & 255) == 244)) {
      {
#line 105
      scm_wta(chrs, (char *)1, s_multi_byte_string);
      }
    }
    {
#line 106
    used = xwctomb(data + byte_len, (int )((unsigned int )(ch >> 8)));
    }
#line 107
    if (! (used >= 0)) {
      {
#line 107
      scm_wta(chrs, (char *)1, s_multi_byte_string);
      }
    }
#line 108
    if (used) {
#line 108
      tmp = used;
    } else {
#line 108
      tmp = 1;
    }
#line 108
    byte_len += (long )tmp;
#line 109
    chrs = ((scm_cell *)chrs)->cdr;
#line 110
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 112
  res = scm_vector_set_length_x(res, (byte_len << 2) + 2L);
  }
#line 113
  return (res);
}
}
#line 117 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/mbstrings.c"
int scm_mb_ilength(unsigned char *data , int size ) 
{ 
  int pos ;
  int len ;
  int inc ;

  {
  {
#line 125
  len = 0;
#line 126
  pos = 0;
#line 127
  xmblen((char const   *)0, (size_t )0);
  }
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    if (! (pos < size)) {
#line 128
      goto while_break;
    }
    {
#line 132
    inc = xmblen((char const   *)(data + pos), (size_t )(size - pos));
    }
#line 133
    if (inc == 0) {
#line 134
      inc ++;
    }
#line 136
    if (inc < 0) {
#line 137
      return (-1);
    }
#line 139
    len ++;
#line 140
    pos += inc;
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  return (len);
}
}
#line 146 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/mbstrings.c"
static char s_multi_byte_string_length[25]  = 
#line 146
  {      (char )'m',      (char )'u',      (char )'l',      (char )'t', 
        (char )'i',      (char )'-',      (char )'b',      (char )'y', 
        (char )'t',      (char )'e',      (char )'-',      (char )'s', 
        (char )'t',      (char )'r',      (char )'i',      (char )'n', 
        (char )'g',      (char )'-',      (char )'l',      (char )'e', 
        (char )'n',      (char )'g',      (char )'t',      (char )'h', 
        (char )'\000'};
#line 148 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/mbstrings.c"
SCM scm_multi_byte_string_length(SCM str ) 
{ 
  int size ;
  int len ;
  unsigned char *data ;

  {
#line 156
  if (! (6 & (int )str)) {
#line 156
    if (! ((117 & (int )((scm_cell *)str)->car) == 21)) {
#line 156
      if (! ((125 & (int )((scm_cell *)str)->car) == 5)) {
        {
#line 156
        scm_wta(str, (char *)1, s_multi_byte_string_length);
        }
      }
    }
  } else {
    {
#line 156
    scm_wta(str, (char *)1, s_multi_byte_string_length);
    }
  }
#line 158
  if ((127 & (int )((scm_cell *)str)->car) == 29) {
#line 158
    data = (unsigned char *)((char *)((scm_cell *)((scm_cell *)((scm_cell *)str)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)str)->cdr)->car >> 2));
  } else {
#line 158
    data = (unsigned char *)((char *)((scm_cell *)str)->cdr);
  }
  {
#line 159
  size = (int )((unsigned long )((scm_cell *)str)->car >> 8);
#line 160
  len = scm_mb_ilength(data, size);
  }
#line 161
  if (! (len >= 0)) {
    {
#line 161
    scm_wta(str, (char *)1, s_multi_byte_string_length);
    }
  }
#line 162
  return ((long )(len << 2) + 2L);
}
}
#line 166 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/mbstrings.c"
static char s_symbol_multi_byte_p[19]  = 
#line 166
  {      (char )'s',      (char )'y',      (char )'m',      (char )'b', 
        (char )'o',      (char )'l',      (char )'-',      (char )'m', 
        (char )'u',      (char )'l',      (char )'t',      (char )'i', 
        (char )'-',      (char )'b',      (char )'y',      (char )'t', 
        (char )'e',      (char )'?',      (char )'\000'};
#line 168 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/mbstrings.c"
SCM scm_symbol_multi_byte_p(SCM symbol ) 
{ 


  {
#line 172
  return ((SCM )*((unsigned long *)((SCM *)*((SCM *)((char *)((scm_cell *)symbol)->cdr) - 1) + 3)));
}
}
#line 175 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/mbstrings.c"
static char s_set_symbol_multi_byte_x[23]  = 
#line 175
  {      (char )'s',      (char )'e',      (char )'t',      (char )'-', 
        (char )'s',      (char )'y',      (char )'m',      (char )'b', 
        (char )'o',      (char )'l',      (char )'-',      (char )'m', 
        (char )'u',      (char )'l',      (char )'t',      (char )'i', 
        (char )'-',      (char )'b',      (char )'y',      (char )'t', 
        (char )'e',      (char )'!',      (char )'\000'};
#line 177 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/mbstrings.c"
SCM scm_set_symbol_multi_byte_x(SCM symbol , SCM val ) 
{ 


  {
#line 182
  if ((127 & (int )((scm_cell *)symbol)->car) == 7) {
#line 184
    if ((long )(16 << 9) + 372L == val) {
#line 184
      *((unsigned long *)((SCM *)*((SCM *)((char *)((scm_cell *)symbol)->cdr) - 1) + 3)) = (unsigned long )((long )(16 << 9) + 372L);
    } else {
#line 184
      *((unsigned long *)((SCM *)*((SCM *)((char *)((scm_cell *)symbol)->cdr) - 1) + 3)) = (unsigned long )((long )(17 << 9) + 372L);
    }
  }
#line 188
  return ((long )(21 << 9) + 372L);
}
}
#line 192 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/mbstrings.c"
static char s_regular_port_p[14]  = 
#line 192
  {      (char )'r',      (char )'e',      (char )'g',      (char )'u', 
        (char )'l',      (char )'a',      (char )'r',      (char )'-', 
        (char )'p',      (char )'o',      (char )'r',      (char )'t', 
        (char )'?',      (char )'\000'};
#line 194 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/mbstrings.c"
SCM scm_regular_port_p(SCM p ) 
{ 
  long tmp ;

  {
#line 198
  if ((unsigned int )((struct scm_port_table *)((scm_cell *)p)->cdr)->representation == 0U) {
#line 198
    tmp = (long )(17 << 9) + 372L;
  } else {
#line 198
    tmp = (long )(16 << 9) + 372L;
  }
#line 198
  return (tmp);
}
}
#line 203 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/mbstrings.c"
static char s_regular_port_x[14]  = 
#line 203
  {      (char )'r',      (char )'e',      (char )'g',      (char )'u', 
        (char )'l',      (char )'a',      (char )'r',      (char )'-', 
        (char )'p',      (char )'o',      (char )'r',      (char )'t', 
        (char )'!',      (char )'\000'};
#line 205 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/mbstrings.c"
SCM scm_regular_port_x(SCM p ) 
{ 


  {
#line 209
  ((struct scm_port_table *)((scm_cell *)p)->cdr)->representation = (enum scm_port_representation_type )0;
#line 210
  return ((long )(21 << 9) + 372L);
}
}
#line 213 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/mbstrings.c"
static char s_multi_byte_port_p[17]  = 
#line 213
  {      (char )'m',      (char )'u',      (char )'l',      (char )'t', 
        (char )'i',      (char )'-',      (char )'b',      (char )'y', 
        (char )'t',      (char )'e',      (char )'-',      (char )'p', 
        (char )'o',      (char )'r',      (char )'t',      (char )'?', 
        (char )'\000'};
#line 215 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/mbstrings.c"
SCM scm_multi_byte_port_p(SCM p ) 
{ 
  long tmp ;

  {
#line 219
  if ((unsigned int )((struct scm_port_table *)((scm_cell *)p)->cdr)->representation == 1U) {
#line 219
    tmp = (long )(17 << 9) + 372L;
  } else {
#line 219
    tmp = (long )(16 << 9) + 372L;
  }
#line 219
  return (tmp);
}
}
#line 224 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/mbstrings.c"
static char s_multi_byte_port_x[17]  = 
#line 224
  {      (char )'m',      (char )'u',      (char )'l',      (char )'t', 
        (char )'i',      (char )'-',      (char )'b',      (char )'y', 
        (char )'t',      (char )'e',      (char )'-',      (char )'p', 
        (char )'o',      (char )'r',      (char )'t',      (char )'!', 
        (char )'\000'};
#line 226 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/mbstrings.c"
SCM scm_multi_byte_port_x(SCM p ) 
{ 


  {
#line 230
  ((struct scm_port_table *)((scm_cell *)p)->cdr)->representation = (enum scm_port_representation_type )1;
#line 231
  return ((long )(21 << 9) + 372L);
}
}
#line 235 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/mbstrings.c"
static char s_wide_character_port_p[21]  = 
#line 235
  {      (char )'w',      (char )'i',      (char )'d',      (char )'e', 
        (char )'-',      (char )'c',      (char )'h',      (char )'a', 
        (char )'r',      (char )'a',      (char )'c',      (char )'t', 
        (char )'e',      (char )'r',      (char )'-',      (char )'p', 
        (char )'o',      (char )'r',      (char )'t',      (char )'?', 
        (char )'\000'};
#line 237 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/mbstrings.c"
SCM scm_wide_character_port_p(SCM p ) 
{ 
  long tmp ;

  {
#line 241
  if ((unsigned int )((struct scm_port_table *)((scm_cell *)p)->cdr)->representation == 2U) {
#line 241
    tmp = (long )(17 << 9) + 372L;
  } else {
#line 241
    tmp = (long )(16 << 9) + 372L;
  }
#line 241
  return (tmp);
}
}
#line 246 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/mbstrings.c"
static char s_wide_character_port_x[21]  = 
#line 246
  {      (char )'w',      (char )'i',      (char )'d',      (char )'e', 
        (char )'-',      (char )'c',      (char )'h',      (char )'a', 
        (char )'r',      (char )'a',      (char )'c',      (char )'t', 
        (char )'e',      (char )'r',      (char )'-',      (char )'p', 
        (char )'o',      (char )'r',      (char )'t',      (char )'!', 
        (char )'\000'};
#line 248 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/mbstrings.c"
SCM scm_wide_character_port_x(SCM p ) 
{ 


  {
#line 252
  ((struct scm_port_table *)((scm_cell *)p)->cdr)->representation = (enum scm_port_representation_type )2;
#line 253
  return ((long )(21 << 9) + 372L);
}
}
#line 261 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/mbstrings.c"
void scm_put_wchar(int c , SCM port , int writing ) 
{ 
  char buf[256] ;
  int len ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 267
  if (writing) {
    {
#line 268
    scm_gen_puts((enum scm_string_representation_type )0, (char *)"#\\", port);
    }
  }
  {
#line 271
  if ((unsigned int )((struct scm_port_table *)((scm_cell *)port)->cdr)->representation == 0U) {
#line 271
    goto case_0;
  }
#line 294
  if ((unsigned int )((struct scm_port_table *)((scm_cell *)port)->cdr)->representation == 1U) {
#line 294
    goto case_1;
  }
#line 314
  if ((unsigned int )((struct scm_port_table *)((scm_cell *)port)->cdr)->representation == 2U) {
#line 314
    goto case_2;
  }
#line 269
  goto switch_break;
  case_0: /* CIL Label */ 
#line 273
  if (c < 256) {
#line 275
    if (! writing) {
      {
#line 276
      scm_gen_putc((int )((unsigned char )c), port);
      }
    } else
#line 277
    if (c <= 32) {
#line 277
      if (scm_charnames[c]) {
        {
#line 278
        scm_gen_puts((enum scm_string_representation_type )0, scm_charnames[c], port);
        }
      } else {
#line 277
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 279
    if (c > 127) {
      {
#line 280
      scm_intprint((long )c, 8, port);
      }
    } else {
      {
#line 282
      scm_gen_putc(c, port);
      }
    }
  } else {
    print_octal: 
#line 287
    if (! writing) {
      {
#line 288
      scm_gen_putc('\\', port);
      }
    }
    {
#line 289
    scm_intprint((long )c, 8, port);
    }
  }
#line 291
  goto switch_break;
  case_1: /* CIL Label */ 
#line 299
  if (4UL > sizeof(buf)) {
#line 300
    goto print_octal;
  }
  {
#line 302
  len = xwctomb(buf, c);
  }
#line 304
  if (len < 0) {
#line 305
    goto print_octal;
  }
#line 307
  if (len == 0) {
    {
#line 308
    scm_gen_putc(0, port);
    }
  } else {
    {
#line 310
    scm_gen_putc(c, port);
    }
  }
#line 311
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 316
  scm_gen_putc(c, port);
  }
#line 317
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 320
  return;
}
}
#line 327 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/mbstrings.c"
void scm_print_mb_string(SCM exp___0 , SCM port , int writing ) 
{ 
  int i ;
  int len ;
  char *data ;
  xwchar_t c ;
  int inc ;
  char *tmp ;

  {
#line 333
  if (writing) {
    {
#line 339
    scm_gen_putc('\"', port);
#line 340
    i = 0;
#line 341
    len = (int )((unsigned long )((scm_cell *)exp___0)->car >> 8);
    }
#line 342
    if ((127 & (int )((scm_cell *)exp___0)->car) == 29) {
#line 342
      data = (char *)((scm_cell *)((scm_cell *)((scm_cell *)exp___0)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)exp___0)->cdr)->car >> 2);
    } else {
#line 342
      data = (char *)((scm_cell *)exp___0)->cdr;
    }
    {
#line 344
    while (1) {
      while_continue: /* CIL Label */ ;
#line 344
      if (! (i < len)) {
#line 344
        goto while_break;
      }
      {
#line 349
      inc = xmbtowc(& c, (unsigned char const   *)(data + i), (size_t )(len - i));
      }
#line 350
      if (inc == 0) {
#line 351
        inc = 1;
      }
#line 352
      if (inc < 0) {
#line 354
        inc = 1;
#line 355
        c = (xwchar_t )*(data + i);
      }
#line 357
      i += inc;
      {
#line 361
      if ((int )c == 92) {
#line 361
        goto case_92;
      }
#line 361
      if ((int )c == 34) {
#line 361
        goto case_92;
      }
#line 363
      goto switch_default;
      case_92: /* CIL Label */ 
      case_34: /* CIL Label */ 
      {
#line 362
      scm_gen_putc('\\', port);
      }
      switch_default: /* CIL Label */ 
      {
#line 364
      scm_gen_putc((int )c, port);
      }
      switch_break: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 367
    scm_gen_putc('\"', port);
    }
  } else {
#line 370
    if ((127 & (int )((scm_cell *)exp___0)->car) == 29) {
#line 370
      tmp = (char *)((scm_cell *)((scm_cell *)((scm_cell *)exp___0)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)exp___0)->cdr)->car >> 2);
    } else {
#line 370
      tmp = (char *)((scm_cell *)exp___0)->cdr;
    }
    {
#line 370
    scm_gen_write((enum scm_string_representation_type )1, tmp, (unsigned long )((scm_cell *)exp___0)->car >> 8,
                  port);
    }
  }
#line 371
  return;
}
}
#line 375 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/mbstrings.c"
void scm_print_mb_symbol(SCM exp___0 , SCM port ) 
{ 
  int pos ;
  int end ;
  int len ;
  char *str ;
  int weird ;
  int maybe_weird ;
  int mw_pos ;
  int inc ;
  xwchar_t c ;
  int q ;
  int qinc ;
  char buf[2] ;
  int q___0 ;
  int qinc___0 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 386
  mw_pos = 0;
#line 387
  inc = 0;
#line 390
  len = (int )((unsigned long )((scm_cell *)exp___0)->car >> 8);
#line 391
  str = (char *)((scm_cell *)exp___0)->cdr;
#line 392
  scm_remember(& exp___0);
#line 393
  pos = 0;
#line 394
  weird = 0;
#line 395
  maybe_weird = 0;
#line 397
  end = pos;
  }
  {
#line 397
  while (1) {
    while_continue: /* CIL Label */ ;
#line 397
    if (! (end < len)) {
#line 397
      goto while_break;
    }
    {
#line 399
    inc = xmbtowc(& c, (unsigned char const   *)(str + end), (size_t )(len - end));
    }
#line 400
    if (inc < 0) {
#line 402
      inc = 1;
#line 403
      c = (xwchar_t )*(str + end);
#line 404
      goto weird_handler;
    }
#line 406
    if (inc == 0) {
#line 408
      inc = 1;
#line 409
      goto weird_handler;
    }
    {
#line 422
    if ((int )c == 10) {
#line 422
      goto weird_handler;
    }
#line 422
    if ((int )c == 9) {
#line 422
      goto weird_handler;
    }
#line 422
    if ((int )c == 12) {
#line 422
      goto weird_handler;
    }
#line 422
    if ((int )c == 13) {
#line 422
      goto weird_handler;
    }
#line 422
    if ((int )c == 32) {
#line 422
      goto weird_handler;
    }
#line 422
    if ((int )c == 59) {
#line 422
      goto weird_handler;
    }
#line 422
    if ((int )c == 34) {
#line 422
      goto weird_handler;
    }
#line 422
    if ((int )c == 41) {
#line 422
      goto weird_handler;
    }
#line 422
    if ((int )c == 40) {
#line 422
      goto weird_handler;
    }
#line 460
    if ((int )c == 92) {
#line 460
      goto case_92;
    }
#line 470
    if ((int )c == 35) {
#line 470
      goto case_35;
    }
#line 470
    if ((int )c == 125) {
#line 470
      goto case_35;
    }
#line 474
    goto switch_default;
    weird_handler: 
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_12: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_59: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_41: /* CIL Label */ 
    case_40: /* CIL Label */ 
#line 424
    if (maybe_weird) {
#line 426
      end = mw_pos;
#line 427
      maybe_weird = 0;
    }
#line 429
    if (! weird) {
      {
#line 431
      scm_gen_write((enum scm_string_representation_type )0, (char *)"#{", (size_t )2,
                    port);
#line 432
      weird = 1;
      }
    }
#line 434
    if (pos < end) {
#line 439
      q = pos;
      {
#line 440
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 440
        if (! (q < end)) {
#line 440
          goto while_break___0;
        }
        {
#line 442
        qinc = xmbtowc(& c, (unsigned char const   *)(str + q), (size_t )(end - q));
        }
#line 443
        if (inc <= 0) {
#line 445
          inc = 1;
#line 446
          c = (xwchar_t )*(str + q);
        }
        {
#line 448
        scm_gen_putc((int )c, port);
#line 449
        q += qinc;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 454
    buf[0] = (char )'\\';
#line 455
    buf[1] = *(str + end);
#line 456
    scm_gen_write((enum scm_string_representation_type )0, buf, (size_t )2, port);
#line 458
    pos = end + 1;
    }
#line 459
    goto switch_break;
    case_92: /* CIL Label */ 
#line 461
    if (weird) {
#line 462
      goto weird_handler;
    }
#line 463
    if (! maybe_weird) {
#line 465
      maybe_weird = 1;
#line 466
      mw_pos = pos;
    }
#line 468
    goto switch_break;
    case_35: /* CIL Label */ 
    case_125: /* CIL Label */ 
#line 471
    if (weird) {
#line 472
      goto weird_handler;
    }
#line 473
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 475
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 397
    end += inc;
  }
  while_break: /* CIL Label */ ;
  }
#line 478
  if (pos < end) {
#line 482
    q___0 = pos;
    {
#line 483
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 483
      if (! (q___0 < end)) {
#line 483
        goto while_break___1;
      }
      {
#line 485
      qinc___0 = xmbtowc(& c, (unsigned char const   *)(str + q___0), (size_t )(end - q___0));
      }
#line 486
      if (inc <= 0) {
#line 487
        inc = 1;
      }
      {
#line 488
      scm_gen_putc((int )c, port);
#line 489
      q___0 += qinc___0;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 492
  if (weird) {
    {
#line 493
    scm_gen_write((enum scm_string_representation_type )0, (char *)"}#", (size_t )2,
                  port);
    }
  }
#line 494
  return;
}
}
#line 500 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/mbstrings.c"
void scm_init_mbstrings(void) 
{ 


  {
  {
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/mbstrings.x"
  scm_make_gsubr(s_multi_byte_string_p, 1, 0, 0, (SCM (*)())(& scm_multi_byte_string_p));
#line 2
  scm_make_gsubr(s_list_to_multi_byte_string, 1, 0, 0, (SCM (*)())(& scm_multi_byte_string));
#line 3
  scm_make_gsubr(s_multi_byte_string, 0, 0, 1, (SCM (*)())(& scm_multi_byte_string));
#line 4
  scm_make_gsubr(s_multi_byte_string_length, 1, 0, 0, (SCM (*)())(& scm_multi_byte_string_length));
#line 5
  scm_make_gsubr(s_symbol_multi_byte_p, 1, 0, 0, (SCM (*)())(& scm_symbol_multi_byte_p));
#line 6
  scm_make_gsubr(s_set_symbol_multi_byte_x, 2, 0, 0, (SCM (*)())(& scm_set_symbol_multi_byte_x));
#line 7
  scm_make_gsubr(s_regular_port_p, 1, 0, 0, (SCM (*)())(& scm_regular_port_p));
#line 8
  scm_make_gsubr(s_regular_port_x, 1, 0, 0, (SCM (*)())(& scm_regular_port_x));
#line 9
  scm_make_gsubr(s_multi_byte_port_p, 1, 0, 0, (SCM (*)())(& scm_multi_byte_port_p));
#line 10
  scm_make_gsubr(s_multi_byte_port_x, 1, 0, 0, (SCM (*)())(& scm_multi_byte_port_x));
#line 11
  scm_make_gsubr(s_wide_character_port_p, 1, 0, 0, (SCM (*)())(& scm_wide_character_port_p));
#line 12
  scm_make_gsubr(s_wide_character_port_x, 1, 0, 0, (SCM (*)())(& scm_wide_character_port_x));
  }
#line 504 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/mbstrings.c"
  return;
}
}
#line 56 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/markers.h"
SCM scm_markcdr(SCM ptr ) ;
#line 53 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/markers.c"
SCM scm_mark0(SCM ptr ) 
{ 


  {
#line 57
  ((scm_cell *)ptr)->car |= 128L;
#line 58
  return ((long )(16 << 9) + 372L);
}
}
#line 63 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/markers.c"
SCM scm_markcdr(SCM ptr ) 
{ 


  {
#line 67
  if (128 & (int )((scm_cell *)ptr)->car) {
#line 68
    return ((long )(16 << 9) + 372L);
  }
#line 69
  ((scm_cell *)ptr)->car |= 128L;
#line 70
  return (((scm_cell *)ptr)->cdr);
}
}
#line 74 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/markers.c"
size_t scm_free0(SCM ptr ) 
{ 


  {
#line 78
  return ((size_t )0);
}
}
#line 49 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/mallocs.h"
int scm_tc16_malloc  ;
#line 58
void scm_init_mallocs(void) ;
#line 41 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/mallocs.c"
static size_t fmalloc(SCM ptr ) ;
#line 43 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/mallocs.c"
static size_t fmalloc(SCM ptr ) 
{ 


  {
#line 47
  if ((char *)((scm_cell *)ptr)->cdr) {
    {
#line 48
    free((void *)((char *)((scm_cell *)ptr)->cdr));
    }
  }
#line 49
  return ((size_t )0);
}
}
#line 53
static int prinmalloc(SCM exp___0 , SCM port , scm_print_state *pstate ) ;
#line 55 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/mallocs.c"
static int prinmalloc(SCM exp___0 , SCM port , scm_print_state *pstate ) 
{ 
  char *__cil_tmp4 ;

  {
  {
#line 61
  scm_gen_puts((enum scm_string_representation_type )0, (char *)"#<malloc ", port);
#line 62
  scm_intprint(((scm_cell *)exp___0)->cdr, 16, port);
#line 63
  scm_gen_putc('>', port);
  }
#line 64
  return (1);
}
}
#line 69 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/mallocs.c"
static scm_smobfuns mallocsmob  =    {& scm_mark0, & fmalloc, & prinmalloc, (SCM (*)(SCM  , SCM  ))0};
#line 74 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/mallocs.c"
SCM scm_malloc_obj(size_t n ) 
{ 
  SCM answer ;
  SCM mem ;
  void *tmp ;

  {
#line 81
  if (6 & (int )scm_freelist) {
    {
#line 81
    answer = scm_gc_for_newcell();
    }
  } else {
#line 81
    answer = scm_freelist;
#line 81
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 81
    scm_cells_allocated ++;
  }
#line 82
  scm_ints_disabled = 1;
#line 83
  if (n) {
    {
#line 83
    tmp = malloc(n);
#line 83
    mem = (SCM )tmp;
    }
  } else {
#line 83
    mem = (SCM )0;
  }
#line 86
  if (n) {
#line 86
    if (! mem) {
#line 88
      scm_ints_disabled = 0;
#line 88
      scm_async_clock --;
#line 88
      if (0U == scm_async_clock) {
        {
#line 88
        scm_async_click();
        }
      }
#line 89
      return ((long )(16 << 9) + 372L);
    }
  }
#line 91
  ((scm_cell *)answer)->cdr = mem;
#line 92
  ((scm_cell *)answer)->car = (SCM )scm_tc16_malloc;
#line 93
  scm_ints_disabled = 0;
#line 93
  scm_async_clock --;
#line 93
  if (0U == scm_async_clock) {
    {
#line 93
    scm_async_click();
    }
  }
#line 94
  return (answer);
}
}
#line 100 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/mallocs.c"
void scm_init_mallocs(void) 
{ 
  long tmp ;

  {
  {
#line 103
  tmp = scm_newsmob(& mallocsmob);
#line 103
  scm_tc16_malloc = (int )tmp;
  }
#line 104
  return;
}
}
#line 60 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/fports.h"
SCM scm_open_file(SCM filename , SCM modes ) ;
#line 49 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/load.h"
void scm_init_load_path(void) ;
#line 50
SCM scm_primitive_load(SCM filename , SCM case_insensitive_p , SCM sharp ) ;
#line 51
SCM scm_sys_package_data_dir(void) ;
#line 52
SCM scm_sys_search_load_path(SCM filename ) ;
#line 53
SCM scm_primitive_load_path(SCM filename , SCM case_insensitive_p , SCM sharp ) ;
#line 55
SCM scm_read_and_eval_x(SCM port , SCM case_insensitive_p , SCM sharp ) ;
#line 58
void scm_init_load(void) ;
#line 209 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) stat)(char const   * __restrict  __file ,
                                                                                   struct stat * __restrict  __buf ) ;
#line 69 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/load.c"
static SCM *scm_loc_load_hook  ;
#line 71 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/load.c"
static char s_primitive_load[15]  = 
#line 71
  {      (char )'p',      (char )'r',      (char )'i',      (char )'m', 
        (char )'i',      (char )'t',      (char )'i',      (char )'v', 
        (char )'e',      (char )'-',      (char )'l',      (char )'o', 
        (char )'a',      (char )'d',      (char )'\000'};
#line 72 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/load.c"
SCM scm_primitive_load(SCM filename , SCM case_insensitive_p , SCM sharp ) 
{ 
  SCM hook ;
  SCM tmp ;
  SCM tmp___0 ;
  SCM form ;
  SCM port ;
  SCM tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 78
  hook = *scm_loc_load_hook;
#line 79
  if (! (6 & (int )filename)) {
#line 79
    if (! ((117 & (int )((scm_cell *)filename)->car) == 21)) {
#line 79
      if (! ((125 & (int )((scm_cell *)filename)->car) == 5)) {
        {
#line 79
        scm_wta(filename, (char *)1, s_primitive_load);
        }
      }
    }
  } else {
    {
#line 79
    scm_wta(filename, (char *)1, s_primitive_load);
    }
  }
#line 81
  if (! (hook == (long )(16 << 9) + 372L)) {
    {
#line 81
    tmp = scm_procedure_p(hook);
    }
#line 81
    if (! (tmp == (long )(17 << 9) + 372L)) {
      {
#line 81
      scm_wta(hook, (char *)"value of %load-hook is neither a procedure nor #f", s_primitive_load);
      }
    }
  }
#line 86
  if (hook != (long )(16 << 9) + 372L) {
    {
#line 87
    tmp___0 = scm_listify(filename, (long )(18 << 9) + 372L);
#line 87
    scm_apply(hook, tmp___0, (long )(20 << 9) + 372L);
    }
  }
  {
#line 91
  tmp___1 = scm_makfromstr("r", sizeof(char ), 0);
#line 91
  port = scm_open_file(filename, tmp___1);
  }
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 95
    form = scm_read(port, case_insensitive_p, sharp);
    }
#line 96
    if ((long )(19 << 9) + 372L == form) {
#line 97
      goto while_break;
    }
    {
#line 98
    scm_eval_x(form);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 100
  scm_close_port(port);
  }
#line 102
  return ((long )(21 << 9) + 372L);
}
}
#line 108 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/load.c"
static char s_sys_package_data_dir[18]  = 
#line 108
  {      (char )'%',      (char )'p',      (char )'a',      (char )'c', 
        (char )'k',      (char )'a',      (char )'g',      (char )'e', 
        (char )'-',      (char )'d',      (char )'a',      (char )'t', 
        (char )'a',      (char )'-',      (char )'d',      (char )'i', 
        (char )'r',      (char )'\000'};
#line 109 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/load.c"
SCM scm_sys_package_data_dir(void) 
{ 
  SCM tmp ;
  char *__cil_tmp2 ;

  {
  {
#line 112
  tmp = scm_makfrom0str("/usr/local/share/guile");
  }
#line 112
  return (tmp);
}
}
#line 120 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/load.c"
static SCM *scm_loc_load_path  ;
#line 123 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/load.c"
static SCM *scm_loc_load_extensions  ;
#line 128 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/load.c"
void scm_init_load_path(void) 
{ 
  SCM path ;
  SCM tmp ;
  SCM tmp___0 ;
  char *path_string ;
  char *tmp___1 ;
  char *scan ;
  char *elt_end ;
  size_t tmp___2 ;
  SCM tmp___3 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 131
  path = (long )(20 << 9) + 372L;
#line 134
  tmp = scm_makfrom0str("/usr/local/share/guile/1.0");
#line 134
  tmp___0 = scm_makfrom0str("/usr/local/share/guile/site");
#line 134
  path = scm_cons2(tmp___0, tmp, path);
#line 140
  tmp___1 = getenv("SCHEME_LOAD_PATH");
#line 140
  path_string = tmp___1;
  }
#line 142
  if (path_string) {
#line 142
    if ((int )*(path_string + 0) != 0) {
      {
#line 148
      tmp___2 = strlen((char const   *)path_string);
#line 148
      elt_end = path_string + tmp___2;
#line 148
      scan = elt_end;
      }
      {
#line 149
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 151
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 151
          scan --;
#line 151
          if ((unsigned long )scan >= (unsigned long )path_string) {
#line 151
            if (! ((int )*scan != 58)) {
#line 151
              goto while_break___0;
            }
          } else {
#line 151
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 153
        tmp___3 = scm_makfromstr((char const   *)(scan + 1), (size_t )(elt_end - (scan + 1)),
                                 0);
#line 153
        path = scm_cons(tmp___3, path);
#line 155
        elt_end = scan;
        }
#line 149
        if (! ((unsigned long )scan >= (unsigned long )path_string)) {
#line 149
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 160
  *scm_loc_load_path = path;
#line 161
  return;
}
}
#line 168 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/load.c"
static char s_sys_search_load_path[18]  = 
#line 168
  {      (char )'%',      (char )'s',      (char )'e',      (char )'a', 
        (char )'r',      (char )'c',      (char )'h',      (char )'-', 
        (char )'l',      (char )'o',      (char )'a',      (char )'d', 
        (char )'-',      (char )'p',      (char )'a',      (char )'t', 
        (char )'h',      (char )'\000'};
#line 169 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/load.c"
SCM scm_sys_search_load_path(SCM filename ) 
{ 
  SCM path ;
  SCM exts ;
  char *buf ;
  int filename_len ;
  int max_path_len ;
  int max_ext_len ;
  long tmp ;
  long tmp___0 ;
  char *tmp___1 ;
  SCM walk ;
  SCM elt ;
  SCM walk___0 ;
  SCM elt___0 ;
  SCM path_elt ;
  SCM ext_elt ;
  int i ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  struct stat mode ;
  SCM result ;
  SCM tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
#line 173
  path = *scm_loc_load_path;
#line 174
  exts = *scm_loc_load_extensions;
#line 180
  if (! (6 & (int )filename)) {
#line 180
    if (! ((117 & (int )((scm_cell *)filename)->car) == 21)) {
#line 180
      if (! ((125 & (int )((scm_cell *)filename)->car) == 5)) {
        {
#line 180
        scm_wta(filename, (char *)1, s_sys_search_load_path);
        }
      }
    }
  } else {
    {
#line 180
    scm_wta(filename, (char *)1, s_sys_search_load_path);
    }
  }
  {
#line 182
  tmp = scm_ilength(path);
  }
#line 182
  if (! (tmp >= 0L)) {
    {
#line 182
    scm_wta(path, (char *)"load path is not a proper list", s_sys_search_load_path);
    }
  }
  {
#line 184
  tmp___0 = scm_ilength(exts);
  }
#line 184
  if (! (tmp___0 >= 0L)) {
    {
#line 184
    scm_wta(exts, (char *)"load extension list is not a proper list", s_sys_search_load_path);
    }
  }
#line 187
  filename_len = (int )((unsigned long )((scm_cell *)filename)->car >> 8);
#line 190
  if (filename_len >= 1) {
#line 190
    if ((127 & (int )((scm_cell *)filename)->car) == 29) {
#line 190
      tmp___1 = (char *)((scm_cell *)((scm_cell *)((scm_cell *)filename)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)filename)->cdr)->car >> 2);
    } else {
#line 190
      tmp___1 = (char *)((scm_cell *)filename)->cdr;
    }
#line 190
    if ((int )*(tmp___1 + 0) == 47) {
#line 192
      return (filename);
    }
  }
#line 198
  max_path_len = 0;
#line 199
  walk = path;
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 199
    if (! (! (6 & (int )walk))) {
#line 199
      goto while_break;
    }
#line 201
    elt = ((scm_cell *)walk)->car;
#line 202
    if (! (6 & (int )elt)) {
#line 202
      if (! ((117 & (int )((scm_cell *)elt)->car) == 21)) {
#line 202
        if (! ((125 & (int )((scm_cell *)elt)->car) == 5)) {
          {
#line 202
          scm_wta(elt, (char *)"load path is not a list of strings", s_sys_search_load_path);
          }
        }
      }
    } else {
      {
#line 202
      scm_wta(elt, (char *)"load path is not a list of strings", s_sys_search_load_path);
      }
    }
#line 205
    if ((unsigned long )((scm_cell *)elt)->car >> 8 > (unsigned long )max_path_len) {
#line 206
      max_path_len = (int )((unsigned long )((scm_cell *)elt)->car >> 8);
    }
#line 199
    walk = ((scm_cell *)walk)->cdr;
  }
  while_break: /* CIL Label */ ;
  }
#line 215
  max_ext_len = 0;
#line 216
  walk___0 = exts;
  {
#line 216
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 216
    if (! (! (6 & (int )walk___0))) {
#line 216
      goto while_break___0;
    }
#line 218
    elt___0 = ((scm_cell *)walk___0)->car;
#line 219
    if (! (6 & (int )elt___0)) {
#line 219
      if (! ((117 & (int )((scm_cell *)elt___0)->car) == 21)) {
#line 219
        if (! ((125 & (int )((scm_cell *)elt___0)->car) == 5)) {
          {
#line 219
          scm_wta(elt___0, (char *)"load extension list is not a list of strings",
                  s_sys_search_load_path);
          }
        }
      }
    } else {
      {
#line 219
      scm_wta(elt___0, (char *)"load extension list is not a list of strings", s_sys_search_load_path);
      }
    }
#line 222
    if ((unsigned long )((scm_cell *)elt___0)->car >> 8 > (unsigned long )max_ext_len) {
#line 223
      max_ext_len = (int )((unsigned long )((scm_cell *)elt___0)->car >> 8);
    }
#line 216
    walk___0 = ((scm_cell *)walk___0)->cdr;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 227
  scm_ints_disabled = 1;
#line 229
  buf = scm_must_malloc((long )((((max_path_len + 1) + filename_len) + max_ext_len) + 1),
                        s_sys_search_load_path);
  }
  {
#line 234
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 234
    if (! (! (6 & (int )path))) {
#line 234
      goto while_break___1;
    }
#line 236
    path_elt = ((scm_cell *)path)->car;
#line 240
    exts = *scm_loc_load_extensions;
    {
#line 240
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 240
      if (! (! (6 & (int )exts))) {
#line 240
        goto while_break___2;
      }
#line 244
      ext_elt = ((scm_cell *)exts)->car;
#line 248
      i = (int )((unsigned long )((scm_cell *)path_elt)->car >> 8);
#line 249
      if ((127 & (int )((scm_cell *)path_elt)->car) == 29) {
#line 249
        tmp___2 = (char *)((scm_cell *)((scm_cell *)((scm_cell *)path_elt)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)path_elt)->cdr)->car >> 2);
      } else {
#line 249
        tmp___2 = (char *)((scm_cell *)path_elt)->cdr;
      }
      {
#line 249
      memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)tmp___2,
             (size_t )i);
      }
#line 250
      if (i >= 1) {
#line 250
        if ((int )*(buf + (i - 1)) != 47) {
#line 251
          tmp___3 = i;
#line 251
          i ++;
#line 251
          *(buf + tmp___3) = (char )'/';
        }
      }
#line 252
      if ((127 & (int )((scm_cell *)filename)->car) == 29) {
#line 252
        tmp___4 = (char *)((scm_cell *)((scm_cell *)((scm_cell *)filename)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)filename)->cdr)->car >> 2);
      } else {
#line 252
        tmp___4 = (char *)((scm_cell *)filename)->cdr;
      }
      {
#line 252
      memcpy((void */* __restrict  */)(buf + i), (void const   */* __restrict  */)tmp___4,
             (size_t )filename_len);
#line 253
      i += filename_len;
      }
#line 254
      if ((127 & (int )((scm_cell *)ext_elt)->car) == 29) {
#line 254
        tmp___5 = (char *)((scm_cell *)((scm_cell *)((scm_cell *)ext_elt)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)ext_elt)->cdr)->car >> 2);
      } else {
#line 254
        tmp___5 = (char *)((scm_cell *)ext_elt)->cdr;
      }
      {
#line 254
      memcpy((void */* __restrict  */)(buf + i), (void const   */* __restrict  */)tmp___5,
             (unsigned long )((scm_cell *)ext_elt)->car >> 8);
#line 255
      i = (int )((unsigned long )i + ((unsigned long )((scm_cell *)ext_elt)->car >> 8));
#line 256
      *(buf + i) = (char )'\000';
#line 261
      tmp___7 = stat((char const   */* __restrict  */)buf, (struct stat */* __restrict  */)(& mode));
      }
#line 261
      if (tmp___7 >= 0) {
#line 261
        if (! (mode.st_mode & 16384U)) {
          {
#line 261
          tmp___8 = access((char const   *)buf, 4);
          }
#line 261
          if (tmp___8 == 0) {
            {
#line 265
            tmp___6 = scm_makfromstr((char const   *)buf, (size_t )i, 0);
#line 265
            result = tmp___6;
#line 266
            scm_must_free(buf);
#line 267
            scm_ints_disabled = 0;
#line 267
            scm_async_clock --;
            }
#line 267
            if (0U == scm_async_clock) {
              {
#line 267
              scm_async_click();
              }
            }
#line 268
            return (result);
          }
        }
      }
#line 240
      exts = ((scm_cell *)exts)->cdr;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 234
    path = ((scm_cell *)path)->cdr;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 274
  scm_must_free(buf);
#line 275
  scm_ints_disabled = 0;
#line 275
  scm_async_clock --;
  }
#line 275
  if (0U == scm_async_clock) {
    {
#line 275
    scm_async_click();
    }
  }
#line 276
  return ((long )(16 << 9) + 372L);
}
}
#line 280 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/load.c"
static char s_primitive_load_path[20]  = 
#line 280
  {      (char )'p',      (char )'r',      (char )'i',      (char )'m', 
        (char )'i',      (char )'t',      (char )'i',      (char )'v', 
        (char )'e',      (char )'-',      (char )'l',      (char )'o', 
        (char )'a',      (char )'d',      (char )'-',      (char )'p', 
        (char )'a',      (char )'t',      (char )'h',      (char )'\000'};
#line 281 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/load.c"
SCM scm_primitive_load_path(SCM filename , SCM case_insensitive_p , SCM sharp ) 
{ 
  SCM full_filename ;
  int absolute ;
  char *tmp ;
  int tmp___0 ;
  SCM tmp___1 ;
  char const   *tmp___2 ;
  SCM tmp___3 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 289
  if (! (6 & (int )filename)) {
#line 289
    if (! ((117 & (int )((scm_cell *)filename)->car) == 21)) {
#line 289
      if (! ((125 & (int )((scm_cell *)filename)->car) == 5)) {
        {
#line 289
        scm_wta(filename, (char *)1, s_primitive_load_path);
        }
      }
    }
  } else {
    {
#line 289
    scm_wta(filename, (char *)1, s_primitive_load_path);
    }
  }
  {
#line 292
  full_filename = scm_sys_search_load_path(filename);
  }
#line 294
  if ((long )(16 << 9) + 372L == full_filename) {
#line 296
    if ((unsigned long )((scm_cell *)filename)->car >> 8 >= 1UL) {
#line 296
      if ((127 & (int )((scm_cell *)filename)->car) == 29) {
#line 296
        tmp = (char *)((scm_cell *)((scm_cell *)((scm_cell *)filename)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)filename)->cdr)->car >> 2);
      } else {
#line 296
        tmp = (char *)((scm_cell *)filename)->cdr;
      }
#line 296
      if ((int )*(tmp + 0) == 47) {
#line 296
        tmp___0 = 1;
      } else {
#line 296
        tmp___0 = 0;
      }
    } else {
#line 296
      tmp___0 = 0;
    }
    {
#line 296
    absolute = tmp___0;
#line 298
    tmp___1 = scm_listify(filename, (long )(18 << 9) + 372L);
    }
#line 298
    if (absolute) {
#line 298
      tmp___2 = "Unable to load file %S";
    } else {
#line 298
      tmp___2 = "Unable to find file %S in load path";
    }
    {
#line 298
    scm_misc_error(s_primitive_load_path, (char *)tmp___2, tmp___1);
    }
  }
  {
#line 305
  tmp___3 = scm_primitive_load(full_filename, case_insensitive_p, sharp);
  }
#line 305
  return (tmp___3);
}
}
#line 313 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/load.c"
static SCM scm_end_of_file_key  =    (long )(16 << 9) + 372L;
#line 315 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/load.c"
static char s_read_and_eval_x[15]  = 
#line 315
  {      (char )'r',      (char )'e',      (char )'a',      (char )'d', 
        (char )'-',      (char )'a',      (char )'n',      (char )'d', 
        (char )'-',      (char )'e',      (char )'v',      (char )'a', 
        (char )'l',      (char )'!',      (char )'\000'};
#line 317 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/load.c"
SCM scm_read_and_eval_x(SCM port , SCM case_insensitive_p , SCM sharp ) 
{ 
  SCM form ;
  SCM tmp ;
  SCM tmp___0 ;

  {
  {
#line 323
  tmp = scm_read(port, case_insensitive_p, sharp);
#line 323
  form = tmp;
  }
#line 324
  if (form == (long )(19 << 9) + 372L) {
    {
#line 325
    scm_ithrow(scm_end_of_file_key, (long )(20 << 9) + 372L, 1);
    }
  }
  {
#line 326
  tmp___0 = scm_eval_x(form);
  }
#line 326
  return (tmp___0);
}
}
#line 331 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/load.c"
void scm_init_load(void) 
{ 
  SCM tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  SCM tmp___2 ;
  SCM tmp___3 ;
  SCM tmp___4 ;
  SCM tmp___5 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 334
  tmp = scm_sysintern((char *)"%load-path", (long )(20 << 9) + 372L);
#line 334
  scm_loc_load_path = & ((scm_cell *)tmp)->cdr;
#line 335
  tmp___0 = scm_makfrom0str(".scm");
#line 335
  tmp___1 = scm_makfrom0str("");
#line 335
  tmp___2 = scm_listify(tmp___1, tmp___0, (long )(18 << 9) + 372L);
#line 335
  tmp___3 = scm_sysintern((char *)"%load-extensions", tmp___2);
#line 335
  scm_loc_load_extensions = & ((scm_cell *)tmp___3)->cdr;
#line 340
  tmp___4 = scm_sysintern((char *)"%load-hook", (long )(16 << 9) + 372L);
#line 340
  scm_loc_load_hook = & ((scm_cell *)tmp___4)->cdr;
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/load.x"
  scm_make_gsubr(s_primitive_load, 1, 2, 0, (SCM (*)())(& scm_primitive_load));
#line 2
  scm_make_gsubr(s_sys_package_data_dir, 0, 0, 0, & scm_sys_package_data_dir);
#line 3
  scm_make_gsubr(s_sys_search_load_path, 1, 0, 0, (SCM (*)())(& scm_sys_search_load_path));
#line 4
  scm_make_gsubr(s_primitive_load_path, 1, 2, 0, (SCM (*)())(& scm_primitive_load_path));
#line 5
  tmp___5 = scm_intern0((char *)"end-of-file");
#line 5
  scm_end_of_file_key = scm_permanent_object(((scm_cell *)tmp___5)->car);
#line 6
  scm_make_gsubr(s_read_and_eval_x, 0, 3, 0, (SCM (*)())(& scm_read_and_eval_x));
  }
#line 343 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/load.c"
  return;
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 50 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.h"
SCM scm_list_head(SCM lst , SCM k ) ;
#line 52
SCM scm_list(SCM objs ) ;
#line 53
SCM scm_null_p(SCM x ) ;
#line 54
SCM scm_list_p(SCM x ) ;
#line 56
SCM scm_list_length(SCM x ) ;
#line 57
SCM scm_list_append(SCM args ) ;
#line 58
SCM scm_list_append_x(SCM args ) ;
#line 60
SCM scm_list_reverse_x(SCM lst , SCM newtail ) ;
#line 61
SCM scm_list_ref(SCM lst , SCM k ) ;
#line 62
SCM scm_list_set_x(SCM lst , SCM k , SCM val ) ;
#line 64
SCM scm_list_cdr_set_x(SCM lst , SCM k , SCM val ) ;
#line 65
SCM scm_last_pair(SCM sx ) ;
#line 66
SCM scm_list_tail(SCM lst , SCM k ) ;
#line 67
SCM scm_sloppy_memq(SCM x , SCM lst ) ;
#line 68
SCM scm_sloppy_memv(SCM x , SCM lst ) ;
#line 69
SCM scm_sloppy_member(SCM x , SCM lst ) ;
#line 70
SCM scm_memq(SCM x , SCM lst ) ;
#line 71
SCM scm_memv(SCM x , SCM lst ) ;
#line 72
SCM scm_member(SCM x , SCM lst ) ;
#line 73
SCM scm_delq_x(SCM item , SCM lst ) ;
#line 74
SCM scm_delv_x(SCM item , SCM lst ) ;
#line 75
SCM scm_delete_x(SCM item , SCM lst ) ;
#line 76
SCM scm_list_copy(SCM lst ) ;
#line 77
SCM scm_delq(SCM item , SCM lst ) ;
#line 78
SCM scm_delv(SCM item , SCM lst ) ;
#line 79
SCM scm_delete(SCM item , SCM lst ) ;
#line 80
void scm_init_list(void) ;
#line 51 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eq.h"
SCM scm_eqv_p(SCM x , SCM y ) ;
#line 61 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
SCM scm_listify(SCM elt  , ...) 
{ 
  va_list foo ;
  SCM answer ;
  SCM *pos ;
  SCM tmp ;

  {
  {
#line 74
  __builtin_va_start(foo, elt);
#line 75
  answer = (long )(20 << 9) + 372L;
#line 76
  pos = & answer;
  }
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! (elt != (long )(18 << 9) + 372L)) {
#line 77
      goto while_break;
    }
    {
#line 79
    *pos = scm_cons(elt, (long )(20 << 9) + 372L);
#line 80
    pos = & ((scm_cell *)*pos)->cdr;
#line 81
    tmp = __builtin_va_arg(foo, SCM );
#line 81
    elt = tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  return (answer);
}
}
#line 87 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
static char s_list___0[5]  = {      (char )'l',      (char )'i',      (char )'s',      (char )'t', 
        (char )'\000'};
#line 88 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
SCM scm_list(SCM objs ) 
{ 


  {
#line 92
  return (objs);
}
}
#line 100 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
static char s_null_p[6]  = {      (char )'n',      (char )'u',      (char )'l',      (char )'l', 
        (char )'?',      (char )'\000'};
#line 101 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
SCM scm_null_p(SCM x ) 
{ 
  long tmp ;

  {
#line 105
  if ((long )(20 << 9) + 372L == x) {
#line 105
    tmp = (long )(17 << 9) + 372L;
  } else {
#line 105
    tmp = (long )(16 << 9) + 372L;
  }
#line 105
  return (tmp);
}
}
#line 108 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
static char s_list_p[6]  = {      (char )'l',      (char )'i',      (char )'s',      (char )'t', 
        (char )'?',      (char )'\000'};
#line 109 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
SCM scm_list_p(SCM x ) 
{ 
  long tmp ;

  {
  {
#line 113
  tmp = scm_ilength(x);
  }
#line 113
  if (tmp < 0L) {
#line 114
    return ((long )(16 << 9) + 372L);
  } else {
#line 116
    return ((long )(17 << 9) + 372L);
  }
}
}
#line 124 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
long scm_ilength(SCM sx ) 
{ 
  register long i ;
  register SCM tortoise ;
  register SCM hare ;
  long tmp ;
  long tmp___0 ;

  {
#line 128
  i = 0L;
#line 129
  tortoise = sx;
#line 130
  hare = sx;
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    if (6 & (int )hare) {
#line 133
      if ((long )(20 << 9) + 372L == hare) {
#line 133
        tmp = i;
      } else {
#line 133
        tmp = -1L;
      }
#line 133
      return (tmp);
    }
#line 134
    if (1 & (int )((scm_cell *)hare)->car) {
#line 134
      return (-1L);
    }
#line 135
    hare = ((scm_cell *)hare)->cdr;
#line 136
    i ++;
#line 137
    if (6 & (int )hare) {
#line 137
      if ((long )(20 << 9) + 372L == hare) {
#line 137
        tmp___0 = i;
      } else {
#line 137
        tmp___0 = -1L;
      }
#line 137
      return (tmp___0);
    }
#line 138
    if (1 & (int )((scm_cell *)hare)->car) {
#line 138
      return (-1L);
    }
#line 139
    hare = ((scm_cell *)hare)->cdr;
#line 140
    i ++;
#line 142
    tortoise = ((scm_cell *)tortoise)->cdr;
#line 132
    if (! (hare != tortoise)) {
#line 132
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  return (-1L);
}
}
#line 151 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
static char s_list_length[12]  = 
#line 151
  {      (char )'l',      (char )'i',      (char )'s',      (char )'t', 
        (char )'-',      (char )'l',      (char )'e',      (char )'n', 
        (char )'g',      (char )'t',      (char )'h',      (char )'\000'};
#line 152 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
SCM scm_list_length(SCM x ) 
{ 
  int i ;
  long tmp ;

  {
  {
#line 157
  tmp = scm_ilength(x);
#line 157
  i = (int )tmp;
  }
#line 158
  if (! (i >= 0)) {
    {
#line 158
    scm_wta(x, (char *)1, s_list_length);
    }
  }
#line 159
  return ((long )(i << 2) + 2L);
}
}
#line 166 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
static char s_list_append[12]  = 
#line 166
  {      (char )'l',      (char )'i',      (char )'s',      (char )'t', 
        (char )'-',      (char )'a',      (char )'p',      (char )'p', 
        (char )'e',      (char )'n',      (char )'d',      (char )'\000'};
#line 167 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
SCM scm_list_append(SCM args ) 
{ 
  SCM res ;
  SCM *lloc ;
  SCM arg ;

  {
#line 171
  res = (long )(20 << 9) + 372L;
#line 172
  lloc = & res;
#line 173
  if (6 & (int )args) {
#line 174
    if (! ((long )(20 << 9) + 372L == args)) {
      {
#line 174
      scm_wta(args, (char *)0, s_list_append);
      }
    }
#line 175
    return (res);
  }
#line 177
  if (! (! (1 & (int )((scm_cell *)args)->car))) {
    {
#line 177
    scm_wta(args, (char *)0, s_list_append);
    }
  }
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    arg = ((scm_cell *)args)->car;
#line 180
    args = ((scm_cell *)args)->cdr;
#line 181
    if (6 & (int )args) {
#line 182
      *lloc = arg;
#line 183
      if (! ((long )(20 << 9) + 372L == args)) {
        {
#line 183
        scm_wta(args, (char *)0, s_list_append);
        }
      }
#line 184
      return (res);
    }
#line 186
    if (! (! (1 & (int )((scm_cell *)args)->car))) {
      {
#line 186
      scm_wta(args, (char *)0, s_list_append);
      }
    }
    {
#line 187
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 187
      if (! (! (6 & (int )arg))) {
#line 187
        goto while_break___0;
      }
#line 188
      if (! (! (1 & (int )((scm_cell *)arg)->car))) {
        {
#line 188
        scm_wta(arg, (char *)0, s_list_append);
        }
      }
      {
#line 189
      *lloc = scm_cons(((scm_cell *)arg)->car, (long )(20 << 9) + 372L);
#line 190
      lloc = & ((scm_cell *)*lloc)->cdr;
#line 187
      arg = ((scm_cell *)arg)->cdr;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 192
    if (! ((long )(20 << 9) + 372L == arg)) {
      {
#line 192
      scm_wta(arg, (char *)0, s_list_append);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 197 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
static char s_list_append_x[13]  = 
#line 197
  {      (char )'l',      (char )'i',      (char )'s',      (char )'t', 
        (char )'-',      (char )'a',      (char )'p',      (char )'p', 
        (char )'e',      (char )'n',      (char )'d',      (char )'!', 
        (char )'\000'};
#line 198 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
SCM scm_list_append_x(SCM args ) 
{ 
  SCM arg ;
  SCM tmp ;
  SCM tmp___0 ;

  {
  tail: 
#line 204
  if ((long )(20 << 9) + 372L == args) {
#line 204
    return ((long )(20 << 9) + 372L);
  }
#line 205
  arg = ((scm_cell *)args)->car;
#line 206
  if (! ((long )(20 << 9) + 372L == arg)) {
#line 206
    if (! (6 & (int )arg)) {
#line 206
      if (! (! (1 & (int )((scm_cell *)arg)->car))) {
        {
#line 206
        scm_wta(arg, (char *)1, s_list_append_x);
        }
      }
    } else {
      {
#line 206
      scm_wta(arg, (char *)1, s_list_append_x);
      }
    }
  }
#line 207
  args = ((scm_cell *)args)->cdr;
#line 208
  if ((long )(20 << 9) + 372L == args) {
#line 208
    return (arg);
  }
#line 209
  if ((long )(20 << 9) + 372L == arg) {
#line 209
    goto tail;
  }
  {
#line 210
  tmp = scm_last_pair(arg);
#line 210
  tmp___0 = scm_list_append_x(args);
#line 210
  ((scm_cell *)tmp)->cdr = tmp___0;
  }
#line 211
  return (arg);
}
}
#line 215 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
static char s_last_pair[10]  = 
#line 215
  {      (char )'l',      (char )'a',      (char )'s',      (char )'t', 
        (char )'-',      (char )'p',      (char )'a',      (char )'i', 
        (char )'r',      (char )'\000'};
#line 216 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
SCM scm_last_pair(SCM sx ) 
{ 
  register SCM res ;
  register SCM x ;

  {
#line 220
  res = sx;
#line 223
  if ((long )(20 << 9) + 372L == sx) {
#line 224
    return ((long )(20 << 9) + 372L);
  }
#line 226
  if (! (6 & (int )res)) {
#line 226
    if (! (! (1 & (int )((scm_cell *)res)->car))) {
      {
#line 226
      scm_wta(res, (char *)1, s_last_pair);
      }
    }
  } else {
    {
#line 226
    scm_wta(res, (char *)1, s_last_pair);
    }
  }
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 228
    x = ((scm_cell *)res)->cdr;
#line 229
    if (6 & (int )x) {
#line 229
      return (res);
    } else
#line 229
    if (1 & (int )((scm_cell *)x)->car) {
#line 229
      return (res);
    }
#line 230
    res = x;
#line 231
    x = ((scm_cell *)res)->cdr;
#line 232
    if (6 & (int )x) {
#line 232
      return (res);
    } else
#line 232
    if (1 & (int )((scm_cell *)x)->car) {
#line 232
      return (res);
    }
#line 233
    res = x;
#line 234
    sx = ((scm_cell *)sx)->cdr;
#line 235
    if (! (x != sx)) {
      {
#line 235
      scm_wta(sx, (char *)1, s_last_pair);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 242 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
static char s_list_reverse[13]  = 
#line 242
  {      (char )'l',      (char )'i',      (char )'s',      (char )'t', 
        (char )'-',      (char )'r',      (char )'e',      (char )'v', 
        (char )'e',      (char )'r',      (char )'s',      (char )'e', 
        (char )'\000'};
#line 243 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
SCM scm_list_reverse(SCM lst ) 
{ 
  SCM res ;
  SCM p ;

  {
#line 247
  res = (long )(20 << 9) + 372L;
#line 248
  p = lst;
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    if (! (! (6 & (int )p))) {
#line 249
      goto while_break;
    }
#line 250
    if (! (! (1 & (int )((scm_cell *)p)->car))) {
      {
#line 250
      scm_wta(lst, (char *)1, s_list_reverse);
      }
    }
    {
#line 251
    res = scm_cons(((scm_cell *)p)->car, res);
#line 249
    p = ((scm_cell *)p)->cdr;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  if (! ((long )(20 << 9) + 372L == p)) {
    {
#line 253
    scm_wta(lst, (char *)1, s_list_reverse);
    }
  }
#line 254
  return (res);
}
}
#line 257 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
static char s_list_reverse_x[14]  = 
#line 257
  {      (char )'l',      (char )'i',      (char )'s',      (char )'t', 
        (char )'-',      (char )'r',      (char )'e',      (char )'v', 
        (char )'e',      (char )'r',      (char )'s',      (char )'e', 
        (char )'!',      (char )'\000'};
#line 258 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
SCM scm_list_reverse_x(SCM lst , SCM newtail ) 
{ 
  SCM old_tail ;

  {
#line 264
  if (newtail == (long )(18 << 9) + 372L) {
#line 265
    newtail = (long )(20 << 9) + 372L;
  }
  loop: 
#line 268
  if (! (6 & (int )lst)) {
#line 268
    if (! (! (1 & (int )((scm_cell *)lst)->car))) {
#line 269
      return (lst);
    }
  } else {
#line 269
    return (lst);
  }
#line 271
  old_tail = ((scm_cell *)lst)->cdr;
#line 272
  ((scm_cell *)lst)->cdr = newtail;
#line 273
  if ((long )(20 << 9) + 372L == old_tail) {
#line 274
    return (lst);
  }
#line 276
  newtail = lst;
#line 277
  lst = old_tail;
#line 278
  goto loop;
}
}
#line 285 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
static char s_list_ref[9]  = 
#line 285
  {      (char )'l',      (char )'i',      (char )'s',      (char )'t', 
        (char )'-',      (char )'r',      (char )'e',      (char )'f', 
        (char )'\000'};
#line 286 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
SCM scm_list_ref(SCM lst , SCM k ) 
{ 
  register long i ;
  long tmp ;
  int tmp___0 ;
  SCM tmp___1 ;

  {
#line 292
  if (! (2 & (int )k)) {
    {
#line 292
    scm_wta(k, (char *)2, s_list_ref);
    }
  }
#line 293
  i = k >> 2;
#line 294
  if (! (i >= 0L)) {
    {
#line 294
    scm_wta(k, (char *)2, s_list_ref);
    }
  }
  {
#line 295
  while (1) {
    while_continue: /* CIL Label */ ;
#line 295
    tmp = i;
#line 295
    i --;
#line 295
    if (! (tmp > 0L)) {
#line 295
      goto while_break;
    }
#line 296
    if (! (6 & (int )lst)) {
#line 296
      if (! (! (1 & (int )((scm_cell *)lst)->car))) {
#line 296
        goto erout;
      }
    } else {
#line 296
      goto erout;
    }
#line 297
    lst = ((scm_cell *)lst)->cdr;
  }
  while_break: /* CIL Label */ ;
  }
  erout: 
#line 299
  if (! (6 & (int )lst)) {
#line 299
    if (! (! (1 & (int )((scm_cell *)lst)->car))) {
#line 299
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 299
    if ((long )(20 << 9) + 372L == lst) {
#line 299
      tmp___0 = 10;
    } else {
#line 299
      tmp___0 = 1;
    }
#line 299
    if ((long )(20 << 9) + 372L == lst) {
#line 299
      tmp___1 = k;
    } else {
#line 299
      tmp___1 = lst;
    }
    {
#line 299
    scm_wta(tmp___1, (char *)tmp___0, s_list_ref);
    }
  }
#line 301
  return (((scm_cell *)lst)->car);
}
}
#line 304 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
static char s_list_set_x[10]  = 
#line 304
  {      (char )'l',      (char )'i',      (char )'s',      (char )'t', 
        (char )'-',      (char )'s',      (char )'e',      (char )'t', 
        (char )'!',      (char )'\000'};
#line 305 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
SCM scm_list_set_x(SCM lst , SCM k , SCM val ) 
{ 
  register long i ;
  long tmp ;
  int tmp___0 ;
  SCM tmp___1 ;

  {
#line 312
  if (! (2 & (int )k)) {
    {
#line 312
    scm_wta(k, (char *)2, s_list_set_x);
    }
  }
#line 313
  i = k >> 2;
#line 314
  if (! (i >= 0L)) {
    {
#line 314
    scm_wta(k, (char *)2, s_list_set_x);
    }
  }
  {
#line 315
  while (1) {
    while_continue: /* CIL Label */ ;
#line 315
    tmp = i;
#line 315
    i --;
#line 315
    if (! (tmp > 0L)) {
#line 315
      goto while_break;
    }
#line 316
    if (! (6 & (int )lst)) {
#line 316
      if (! (! (1 & (int )((scm_cell *)lst)->car))) {
#line 316
        goto erout;
      }
    } else {
#line 316
      goto erout;
    }
#line 317
    lst = ((scm_cell *)lst)->cdr;
  }
  while_break: /* CIL Label */ ;
  }
  erout: 
#line 319
  if (! (6 & (int )lst)) {
#line 319
    if (! (! (1 & (int )((scm_cell *)lst)->car))) {
#line 319
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 319
    if ((long )(20 << 9) + 372L == lst) {
#line 319
      tmp___0 = 10;
    } else {
#line 319
      tmp___0 = 1;
    }
#line 319
    if ((long )(20 << 9) + 372L == lst) {
#line 319
      tmp___1 = k;
    } else {
#line 319
      tmp___1 = lst;
    }
    {
#line 319
    scm_wta(tmp___1, (char *)tmp___0, s_list_set_x);
    }
  }
#line 321
  ((scm_cell *)lst)->car = val;
#line 322
  return (val);
}
}
#line 326 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
static char s_list_cdr_ref[13]  = 
#line 326
  {      (char )'l',      (char )'i',      (char )'s',      (char )'t', 
        (char )'-',      (char )'c',      (char )'d',      (char )'r', 
        (char )'-',      (char )'r',      (char )'e',      (char )'f', 
        (char )'\000'};
#line 327 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
static char s_list_tail[10]  = 
#line 327
  {      (char )'l',      (char )'i',      (char )'s',      (char )'t', 
        (char )'-',      (char )'t',      (char )'a',      (char )'i', 
        (char )'l',      (char )'\000'};
#line 328 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
SCM scm_list_tail(SCM lst , SCM k ) 
{ 
  register long i ;
  long tmp ;

  {
#line 334
  if (! (2 & (int )k)) {
    {
#line 334
    scm_wta(k, (char *)2, s_list_tail);
    }
  }
#line 335
  i = k >> 2;
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 336
    tmp = i;
#line 336
    i --;
#line 336
    if (! (tmp > 0L)) {
#line 336
      goto while_break;
    }
#line 337
    if (! (6 & (int )lst)) {
#line 337
      if (! (! (1 & (int )((scm_cell *)lst)->car))) {
        {
#line 337
        scm_wta(lst, (char *)1, s_list_tail);
        }
      }
    } else {
      {
#line 337
      scm_wta(lst, (char *)1, s_list_tail);
      }
    }
#line 338
    lst = ((scm_cell *)lst)->cdr;
  }
  while_break: /* CIL Label */ ;
  }
#line 340
  return (lst);
}
}
#line 344 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
static char s_list_cdr_set_x[14]  = 
#line 344
  {      (char )'l',      (char )'i',      (char )'s',      (char )'t', 
        (char )'-',      (char )'c',      (char )'d',      (char )'r', 
        (char )'-',      (char )'s',      (char )'e',      (char )'t', 
        (char )'!',      (char )'\000'};
#line 345 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
SCM scm_list_cdr_set_x(SCM lst , SCM k , SCM val ) 
{ 
  register long i ;
  long tmp ;
  int tmp___0 ;
  SCM tmp___1 ;

  {
#line 352
  if (! (2 & (int )k)) {
    {
#line 352
    scm_wta(k, (char *)2, s_list_cdr_set_x);
    }
  }
#line 353
  i = k >> 2;
#line 354
  if (! (i >= 0L)) {
    {
#line 354
    scm_wta(k, (char *)2, s_list_cdr_set_x);
    }
  }
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;
#line 355
    tmp = i;
#line 355
    i --;
#line 355
    if (! (tmp > 0L)) {
#line 355
      goto while_break;
    }
#line 356
    if (! (6 & (int )lst)) {
#line 356
      if (! (! (1 & (int )((scm_cell *)lst)->car))) {
#line 356
        goto erout;
      }
    } else {
#line 356
      goto erout;
    }
#line 357
    lst = ((scm_cell *)lst)->cdr;
  }
  while_break: /* CIL Label */ ;
  }
  erout: 
#line 359
  if (! (6 & (int )lst)) {
#line 359
    if (! (! (1 & (int )((scm_cell *)lst)->car))) {
#line 359
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 359
    if ((long )(20 << 9) + 372L == lst) {
#line 359
      tmp___0 = 10;
    } else {
#line 359
      tmp___0 = 1;
    }
#line 359
    if ((long )(20 << 9) + 372L == lst) {
#line 359
      tmp___1 = k;
    } else {
#line 359
      tmp___1 = lst;
    }
    {
#line 359
    scm_wta(tmp___1, (char *)tmp___0, s_list_cdr_set_x);
    }
  }
#line 361
  ((scm_cell *)lst)->cdr = val;
#line 362
  return (val);
}
}
#line 369 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
static char s_list_head[10]  = 
#line 369
  {      (char )'l',      (char )'i',      (char )'s',      (char )'t', 
        (char )'-',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'\000'};
#line 370 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
SCM scm_list_head(SCM lst , SCM k ) 
{ 
  SCM answer ;
  SCM *pos ;
  register long i ;
  long tmp ;

  {
#line 379
  if (! (2 & (int )k)) {
    {
#line 379
    scm_wta(k, (char *)2, s_list_head);
    }
  }
#line 380
  answer = (long )(20 << 9) + 372L;
#line 381
  pos = & answer;
#line 382
  i = k >> 2;
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
#line 383
    tmp = i;
#line 383
    i --;
#line 383
    if (! (tmp > 0L)) {
#line 383
      goto while_break;
    }
#line 385
    if (! (6 & (int )lst)) {
#line 385
      if (! (! (1 & (int )((scm_cell *)lst)->car))) {
        {
#line 385
        scm_wta(lst, (char *)1, s_list_head);
        }
      }
    } else {
      {
#line 385
      scm_wta(lst, (char *)1, s_list_head);
      }
    }
    {
#line 386
    *pos = scm_cons(((scm_cell *)lst)->car, (long )(20 << 9) + 372L);
#line 387
    pos = & ((scm_cell *)*pos)->cdr;
#line 388
    lst = ((scm_cell *)lst)->cdr;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 390
  return (answer);
}
}
#line 394 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
static char s_list_copy[10]  = 
#line 394
  {      (char )'l',      (char )'i',      (char )'s',      (char )'t', 
        (char )'-',      (char )'c',      (char )'o',      (char )'p', 
        (char )'y',      (char )'\000'};
#line 395 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
SCM scm_list_copy(SCM lst ) 
{ 
  SCM newlst ;
  SCM *fill_here ;
  SCM from_here ;
  SCM c ;

  {
#line 403
  newlst = (long )(20 << 9) + 372L;
#line 404
  fill_here = & newlst;
#line 405
  from_here = lst;
  {
#line 407
  while (1) {
    while_continue: /* CIL Label */ ;
#line 407
    if (! (6 & (int )from_here)) {
#line 407
      if (! (! (1 & (int )((scm_cell *)from_here)->car))) {
#line 407
        goto while_break;
      }
    } else {
#line 407
      goto while_break;
    }
    {
#line 410
    c = scm_cons(((scm_cell *)from_here)->car, ((scm_cell *)from_here)->cdr);
#line 411
    *fill_here = c;
#line 412
    fill_here = & ((scm_cell *)c)->cdr;
#line 413
    from_here = ((scm_cell *)from_here)->cdr;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 415
  return (newlst);
}
}
#line 421
static void sloppy_mem_check(SCM obj , char *where , char *why ) ;
#line 423 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
static void sloppy_mem_check(SCM obj , char *where , char *why ) 
{ 
  long tmp ;

  {
  {
#line 429
  tmp = scm_ilength(obj);
  }
#line 429
  if (! (tmp >= 0L)) {
    {
#line 429
    scm_wta(obj, where, why);
    }
  }
#line 430
  return;
}
}
#line 433 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
static char s_sloppy_memq[12]  = 
#line 433
  {      (char )'s',      (char )'l',      (char )'o',      (char )'p', 
        (char )'p',      (char )'y',      (char )'-',      (char )'m', 
        (char )'e',      (char )'m',      (char )'q',      (char )'\000'};
#line 434 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
SCM scm_sloppy_memq(SCM x , SCM lst ) 
{ 


  {
  {
#line 439
  while (1) {
    while_continue: /* CIL Label */ ;
#line 439
    if (! (6 & (int )lst)) {
#line 439
      if (! (! (1 & (int )((scm_cell *)lst)->car))) {
#line 439
        goto while_break;
      }
    } else {
#line 439
      goto while_break;
    }
#line 441
    if (((scm_cell *)lst)->car == x) {
#line 442
      return (lst);
    }
#line 439
    lst = ((scm_cell *)lst)->cdr;
  }
  while_break: /* CIL Label */ ;
  }
#line 444
  return (lst);
}
}
#line 448 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
static char s_sloppy_memv[12]  = 
#line 448
  {      (char )'s',      (char )'l',      (char )'o',      (char )'p', 
        (char )'p',      (char )'y',      (char )'-',      (char )'m', 
        (char )'e',      (char )'m',      (char )'v',      (char )'\000'};
#line 449 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
SCM scm_sloppy_memv(SCM x , SCM lst ) 
{ 
  SCM tmp ;

  {
  {
#line 454
  while (1) {
    while_continue: /* CIL Label */ ;
#line 454
    if (! (6 & (int )lst)) {
#line 454
      if (! (! (1 & (int )((scm_cell *)lst)->car))) {
#line 454
        goto while_break;
      }
    } else {
#line 454
      goto while_break;
    }
    {
#line 456
    tmp = scm_eqv_p(((scm_cell *)lst)->car, x);
    }
#line 456
    if ((long )(16 << 9) + 372L != tmp) {
#line 457
      return (lst);
    }
#line 454
    lst = ((scm_cell *)lst)->cdr;
  }
  while_break: /* CIL Label */ ;
  }
#line 459
  return (lst);
}
}
#line 463 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
static char s_sloppy_member[14]  = 
#line 463
  {      (char )'s',      (char )'l',      (char )'o',      (char )'p', 
        (char )'p',      (char )'y',      (char )'-',      (char )'m', 
        (char )'e',      (char )'m',      (char )'b',      (char )'e', 
        (char )'r',      (char )'\000'};
#line 464 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
SCM scm_sloppy_member(SCM x , SCM lst ) 
{ 
  SCM tmp ;

  {
  {
#line 469
  while (1) {
    while_continue: /* CIL Label */ ;
#line 469
    if (! (6 & (int )lst)) {
#line 469
      if (! (! (1 & (int )((scm_cell *)lst)->car))) {
#line 469
        goto while_break;
      }
    } else {
#line 469
      goto while_break;
    }
    {
#line 471
    tmp = scm_equal_p(((scm_cell *)lst)->car, x);
    }
#line 471
    if ((long )(16 << 9) + 372L != tmp) {
#line 472
      return (lst);
    }
#line 469
    lst = ((scm_cell *)lst)->cdr;
  }
  while_break: /* CIL Label */ ;
  }
#line 474
  return (lst);
}
}
#line 479 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
static char s_memq[5]  = {      (char )'m',      (char )'e',      (char )'m',      (char )'q', 
        (char )'\000'};
#line 480 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
SCM scm_memq(SCM x , SCM lst ) 
{ 
  SCM answer ;
  long tmp ;

  {
  {
#line 486
  answer = scm_sloppy_memq(x, lst);
#line 487
  sloppy_mem_check(answer, (char *)2, s_memq);
  }
#line 488
  if (answer == (long )(20 << 9) + 372L) {
#line 488
    tmp = (long )(16 << 9) + 372L;
  } else {
#line 488
    tmp = answer;
  }
#line 488
  return (tmp);
}
}
#line 493 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
static char s_memv[5]  = {      (char )'m',      (char )'e',      (char )'m',      (char )'v', 
        (char )'\000'};
#line 494 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
SCM scm_memv(SCM x , SCM lst ) 
{ 
  SCM answer ;
  long tmp ;

  {
  {
#line 500
  answer = scm_sloppy_memv(x, lst);
#line 501
  sloppy_mem_check(answer, (char *)2, s_memv);
  }
#line 502
  if (answer == (long )(20 << 9) + 372L) {
#line 502
    tmp = (long )(16 << 9) + 372L;
  } else {
#line 502
    tmp = answer;
  }
#line 502
  return (tmp);
}
}
#line 506 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
static char s_member[7]  = {      (char )'m',      (char )'e',      (char )'m',      (char )'b', 
        (char )'e',      (char )'r',      (char )'\000'};
#line 507 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
SCM scm_member(SCM x , SCM lst ) 
{ 
  SCM answer ;
  long tmp ;

  {
  {
#line 513
  answer = scm_sloppy_member(x, lst);
#line 514
  sloppy_mem_check(answer, (char *)2, s_member);
  }
#line 515
  if (answer == (long )(20 << 9) + 372L) {
#line 515
    tmp = (long )(16 << 9) + 372L;
  } else {
#line 515
    tmp = answer;
  }
#line 515
  return (tmp);
}
}
#line 522 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
static char s_delq_x[6]  = {      (char )'d',      (char )'e',      (char )'l',      (char )'q', 
        (char )'!',      (char )'\000'};
#line 523 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
SCM scm_delq_x(SCM item , SCM lst ) 
{ 
  SCM walk ;
  SCM *prev ;

  {
#line 531
  prev = & lst;
#line 531
  walk = lst;
  {
#line 531
  while (1) {
    while_continue: /* CIL Label */ ;
#line 531
    if (! (6 & (int )walk)) {
#line 531
      if (! (! (1 & (int )((scm_cell *)walk)->car))) {
#line 531
        goto while_break;
      }
    } else {
#line 531
      goto while_break;
    }
#line 535
    if (((scm_cell *)walk)->car == item) {
#line 536
      *prev = ((scm_cell *)walk)->cdr;
    } else {
#line 538
      prev = & ((scm_cell *)walk)->cdr;
    }
#line 531
    walk = ((scm_cell *)walk)->cdr;
  }
  while_break: /* CIL Label */ ;
  }
#line 541
  return (lst);
}
}
#line 545 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
static char s_delv_x[6]  = {      (char )'d',      (char )'e',      (char )'l',      (char )'v', 
        (char )'!',      (char )'\000'};
#line 546 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
SCM scm_delv_x(SCM item , SCM lst ) 
{ 
  SCM walk ;
  SCM *prev ;
  SCM tmp ;

  {
#line 554
  prev = & lst;
#line 554
  walk = lst;
  {
#line 554
  while (1) {
    while_continue: /* CIL Label */ ;
#line 554
    if (! (6 & (int )walk)) {
#line 554
      if (! (! (1 & (int )((scm_cell *)walk)->car))) {
#line 554
        goto while_break;
      }
    } else {
#line 554
      goto while_break;
    }
    {
#line 558
    tmp = scm_eqv_p(((scm_cell *)walk)->car, item);
    }
#line 558
    if ((long )(16 << 9) + 372L != tmp) {
#line 559
      *prev = ((scm_cell *)walk)->cdr;
    } else {
#line 561
      prev = & ((scm_cell *)walk)->cdr;
    }
#line 554
    walk = ((scm_cell *)walk)->cdr;
  }
  while_break: /* CIL Label */ ;
  }
#line 564
  return (lst);
}
}
#line 569 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
static char s_delete_x[8]  = 
#line 569
  {      (char )'d',      (char )'e',      (char )'l',      (char )'e', 
        (char )'t',      (char )'e',      (char )'!',      (char )'\000'};
#line 570 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
SCM scm_delete_x(SCM item , SCM lst ) 
{ 
  SCM walk ;
  SCM *prev ;
  SCM tmp ;

  {
#line 578
  prev = & lst;
#line 578
  walk = lst;
  {
#line 578
  while (1) {
    while_continue: /* CIL Label */ ;
#line 578
    if (! (6 & (int )walk)) {
#line 578
      if (! (! (1 & (int )((scm_cell *)walk)->car))) {
#line 578
        goto while_break;
      }
    } else {
#line 578
      goto while_break;
    }
    {
#line 582
    tmp = scm_equal_p(((scm_cell *)walk)->car, item);
    }
#line 582
    if ((long )(16 << 9) + 372L != tmp) {
#line 583
      *prev = ((scm_cell *)walk)->cdr;
    } else {
#line 585
      prev = & ((scm_cell *)walk)->cdr;
    }
#line 578
    walk = ((scm_cell *)walk)->cdr;
  }
  while_break: /* CIL Label */ ;
  }
#line 588
  return (lst);
}
}
#line 595 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
static char s_delq[5]  = {      (char )'d',      (char )'e',      (char )'l',      (char )'q', 
        (char )'\000'};
#line 596 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
SCM scm_delq(SCM item , SCM lst ) 
{ 
  SCM copy ;
  SCM tmp ;

  {
  {
#line 603
  copy = scm_list_copy(lst);
#line 604
  tmp = scm_delq_x(item, copy);
  }
#line 604
  return (tmp);
}
}
#line 607 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
static char s_delv[5]  = {      (char )'d',      (char )'e',      (char )'l',      (char )'v', 
        (char )'\000'};
#line 608 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
SCM scm_delv(SCM item , SCM lst ) 
{ 
  SCM copy ;
  SCM tmp ;

  {
  {
#line 615
  copy = scm_list_copy(lst);
#line 616
  tmp = scm_delv_x(item, copy);
  }
#line 616
  return (tmp);
}
}
#line 619 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
static char s_delete[7]  = {      (char )'d',      (char )'e',      (char )'l',      (char )'e', 
        (char )'t',      (char )'e',      (char )'\000'};
#line 620 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
SCM scm_delete(SCM item , SCM lst ) 
{ 
  SCM copy ;
  SCM tmp ;

  {
  {
#line 627
  copy = scm_list_copy(lst);
#line 628
  tmp = scm_delete_x(item, copy);
  }
#line 628
  return (tmp);
}
}
#line 633 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
void scm_init_list(void) 
{ 


  {
  {
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.x"
  scm_make_gsubr(s_list___0, 0, 0, 1, (SCM (*)())(& scm_list));
#line 2
  scm_make_gsubr(s_null_p, 1, 0, 0, (SCM (*)())(& scm_null_p));
#line 3
  scm_make_gsubr(s_list_p, 1, 0, 0, (SCM (*)())(& scm_list_p));
#line 4
  scm_make_gsubr(s_list_length, 1, 0, 0, (SCM (*)())(& scm_list_length));
#line 5
  scm_make_gsubr(s_list_append, 0, 0, 1, (SCM (*)())(& scm_list_append));
#line 6
  scm_make_gsubr(s_list_append_x, 0, 0, 1, (SCM (*)())(& scm_list_append_x));
#line 7
  scm_make_gsubr(s_last_pair, 1, 0, 0, (SCM (*)())(& scm_last_pair));
#line 8
  scm_make_gsubr(s_list_reverse, 1, 0, 0, (SCM (*)())(& scm_list_reverse));
#line 9
  scm_make_gsubr(s_list_reverse_x, 1, 1, 0, (SCM (*)())(& scm_list_reverse_x));
#line 10
  scm_make_gsubr(s_list_ref, 2, 0, 0, (SCM (*)())(& scm_list_ref));
#line 11
  scm_make_gsubr(s_list_set_x, 3, 0, 0, (SCM (*)())(& scm_list_set_x));
#line 12
  scm_make_gsubr(s_list_cdr_ref, 2, 0, 0, (SCM (*)())(& scm_list_tail));
#line 13
  scm_make_gsubr(s_list_tail, 2, 0, 0, (SCM (*)())(& scm_list_tail));
#line 14
  scm_make_gsubr(s_list_cdr_set_x, 3, 0, 0, (SCM (*)())(& scm_list_cdr_set_x));
#line 15
  scm_make_gsubr(s_list_head, 2, 0, 0, (SCM (*)())(& scm_list_head));
#line 16
  scm_make_gsubr(s_list_copy, 1, 0, 0, (SCM (*)())(& scm_list_copy));
#line 17
  scm_make_gsubr(s_sloppy_memq, 2, 0, 0, (SCM (*)())(& scm_sloppy_memq));
#line 18
  scm_make_gsubr(s_sloppy_memv, 2, 0, 0, (SCM (*)())(& scm_sloppy_memv));
#line 19
  scm_make_gsubr(s_sloppy_member, 2, 0, 0, (SCM (*)())(& scm_sloppy_member));
#line 20
  scm_make_gsubr(s_memq, 2, 0, 0, (SCM (*)())(& scm_memq));
#line 21
  scm_make_gsubr(s_memv, 2, 0, 0, (SCM (*)())(& scm_memv));
#line 22
  scm_make_gsubr(s_member, 2, 0, 0, (SCM (*)())(& scm_member));
#line 23
  scm_make_gsubr(s_delq_x, 2, 0, 0, (SCM (*)())(& scm_delq_x));
#line 24
  scm_make_gsubr(s_delv_x, 2, 0, 0, (SCM (*)())(& scm_delv_x));
#line 25
  scm_make_gsubr(s_delete_x, 2, 0, 0, (SCM (*)())(& scm_delete_x));
#line 26
  scm_make_gsubr(s_delq, 2, 0, 0, (SCM (*)())(& scm_delq));
#line 27
  scm_make_gsubr(s_delv, 2, 0, 0, (SCM (*)())(& scm_delv));
#line 28
  scm_make_gsubr(s_delete, 2, 0, 0, (SCM (*)())(& scm_delete));
  }
#line 637 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/list.c"
  return;
}
}
#line 51 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/kw.h"
int scm_tc16_kw  ;
#line 59
SCM scm_keyword_p(SCM obj ) ;
#line 60
SCM scm_keyword_dash_symbol(SCM kw ) ;
#line 61
void scm_init_kw(void) ;
#line 53 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/kw.c"
static size_t free_kw(SCM obj ) ;
#line 55 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/kw.c"
static size_t free_kw(SCM obj ) 
{ 


  {
#line 59
  return ((size_t )0);
}
}
#line 63
static int prin_kw(SCM exp___0 , SCM port , scm_print_state *pstate ) ;
#line 65 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/kw.c"
static int prin_kw(SCM exp___0 , SCM port , scm_print_state *pstate ) 
{ 
  int tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 71
  scm_gen_puts((enum scm_string_representation_type )0, (char *)":", port);
  }
#line 72
  if ((127 & (int )((scm_cell *)((scm_cell *)exp___0)->cdr)->car) == 23) {
#line 72
    tmp = 1;
  } else
#line 72
  if ((127 & (int )((scm_cell *)((scm_cell *)exp___0)->cdr)->car) == 7) {
#line 72
    if (*((unsigned long *)((SCM *)*((SCM *)((char *)((scm_cell *)((scm_cell *)exp___0)->cdr)->cdr) - 1) + 3)) != (unsigned long )((long )(16 << 9) + 372L)) {
#line 72
      tmp = 1;
    } else {
#line 72
      tmp = 0;
    }
  } else {
#line 72
    tmp = 0;
  }
  {
#line 72
  scm_gen_puts((enum scm_string_representation_type )tmp, (char *)((scm_cell *)((scm_cell *)exp___0)->cdr)->cdr + 1,
               port);
  }
#line 77
  return (1);
}
}
#line 82 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/kw.c"
static scm_smobfuns kw_smob  =    {& scm_markcdr, & free_kw, & prin_kw, (SCM (*)(SCM  , SCM  ))0};
#line 86 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/kw.c"
static char s_make_keyword_from_dash_symbol[30]  = 
#line 86
  {      (char )'m',      (char )'a',      (char )'k',      (char )'e', 
        (char )'-',      (char )'k',      (char )'e',      (char )'y', 
        (char )'w',      (char )'o',      (char )'r',      (char )'d', 
        (char )'-',      (char )'f',      (char )'r',      (char )'o', 
        (char )'m',      (char )'-',      (char )'d',      (char )'a', 
        (char )'s',      (char )'h',      (char )'-',      (char )'s', 
        (char )'y',      (char )'m',      (char )'b',      (char )'o', 
        (char )'l',      (char )'\000'};
#line 88 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/kw.c"
SCM scm_make_keyword_from_dash_symbol(SCM symbol ) 
{ 
  SCM vcell ;
  SCM kw ;

  {
#line 94
  if (! (6 & (int )symbol)) {
#line 94
    if ((125 & (int )((scm_cell *)symbol)->car) == 5) {
#line 94
      if (! (45 == (int )*((char *)((scm_cell *)symbol)->cdr + 0))) {
        {
#line 94
        scm_wta(symbol, (char *)1, s_make_keyword_from_dash_symbol);
        }
      }
    } else {
      {
#line 94
      scm_wta(symbol, (char *)1, s_make_keyword_from_dash_symbol);
      }
    }
  } else {
    {
#line 94
    scm_wta(symbol, (char *)1, s_make_keyword_from_dash_symbol);
    }
  }
  {
#line 98
  scm_ints_disabled = 1;
#line 99
  vcell = scm_sym2ovcell_soft(symbol, scm_sys_protects[8]);
  }
#line 100
  if (vcell == (long )(16 << 9) + 372L) {
#line 103
    if (6 & (int )scm_freelist) {
      {
#line 103
      kw = scm_gc_for_newcell();
      }
    } else {
#line 103
      kw = scm_freelist;
#line 103
      scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 103
      scm_cells_allocated ++;
    }
    {
#line 104
    ((scm_cell *)kw)->car = (SCM )scm_tc16_kw;
#line 105
    ((scm_cell *)kw)->cdr = symbol;
#line 106
    scm_intern_symbol(scm_sys_protects[8], symbol);
#line 107
    vcell = scm_sym2ovcell_soft(symbol, scm_sys_protects[8]);
#line 108
    ((scm_cell *)vcell)->cdr = kw;
    }
  }
#line 110
  scm_ints_disabled = 0;
#line 110
  scm_async_clock --;
#line 110
  if (0U == scm_async_clock) {
    {
#line 110
    scm_async_click();
    }
  }
#line 111
  return (((scm_cell *)vcell)->cdr);
}
}
#line 114 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/kw.c"
static char s_keyword_p[9]  = 
#line 114
  {      (char )'k',      (char )'e',      (char )'y',      (char )'w', 
        (char )'o',      (char )'r',      (char )'d',      (char )'?', 
        (char )'\000'};
#line 116 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/kw.c"
SCM scm_keyword_p(SCM obj ) 
{ 
  long tmp ;

  {
#line 120
  if (! (6 & (int )obj)) {
#line 120
    if (((scm_cell *)obj)->car == (SCM )scm_tc16_kw) {
#line 120
      tmp = (long )(17 << 9) + 372L;
    } else {
#line 120
      tmp = (long )(16 << 9) + 372L;
    }
  } else {
#line 120
    tmp = (long )(16 << 9) + 372L;
  }
#line 120
  return (tmp);
}
}
#line 127 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/kw.c"
static char s_keyword_dash_symbol[20]  = 
#line 127
  {      (char )'k',      (char )'e',      (char )'y',      (char )'w', 
        (char )'o',      (char )'r',      (char )'d',      (char )'-', 
        (char )'d',      (char )'a',      (char )'s',      (char )'h', 
        (char )'-',      (char )'s',      (char )'y',      (char )'m', 
        (char )'b',      (char )'o',      (char )'l',      (char )'\000'};
#line 129 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/kw.c"
SCM scm_keyword_dash_symbol(SCM kw ) 
{ 


  {
#line 133
  if (! (6 & (int )kw)) {
#line 133
    if (! (((scm_cell *)kw)->car == (SCM )scm_tc16_kw)) {
      {
#line 133
      scm_wta(kw, (char *)1, s_keyword_dash_symbol);
      }
    }
  } else {
    {
#line 133
    scm_wta(kw, (char *)1, s_keyword_dash_symbol);
    }
  }
#line 134
  return (((scm_cell *)kw)->cdr);
}
}
#line 141 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/kw.c"
void scm_init_kw(void) 
{ 
  long tmp ;

  {
  {
#line 144
  tmp = scm_newsmob(& kw_smob);
#line 144
  scm_tc16_kw = (int )tmp;
#line 145
  scm_sys_protects[8] = scm_make_vector((long )(256 << 2) + 2L, (long )(20 << 9) + 372L,
                                        (long )(18 << 9) + 372L);
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/kw.x"
  scm_make_gsubr(s_make_keyword_from_dash_symbol, 1, 0, 0, (SCM (*)())(& scm_make_keyword_from_dash_symbol));
#line 2
  scm_make_gsubr(s_keyword_p, 1, 0, 0, (SCM (*)())(& scm_keyword_p));
#line 3
  scm_make_gsubr(s_keyword_dash_symbol, 1, 0, 0, (SCM (*)())(& scm_keyword_dash_symbol));
  }
#line 147 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/kw.c"
  return;
}
}
#line 255 "/usr/include/stdio.h"
extern FILE *freopen(char const   * __restrict  __filename , char const   * __restrict  __modes ,
                     FILE * __restrict  __stream ) ;
#line 722
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 727
extern long ftell(FILE *__stream ) ;
#line 54 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ioext.h"
SCM scm_sys_ftell(SCM port ) ;
#line 55
SCM scm_sys_fseek(SCM port , SCM offset , SCM whence ) ;
#line 56
SCM scm_sys_freopen(SCM filename , SCM modes , SCM port ) ;
#line 57
SCM scm_sys_duplicate_port(SCM oldpt , SCM modes ) ;
#line 58
SCM scm_sys_redirect_port(SCM into_pt , SCM from_pt ) ;
#line 59
SCM scm_sys_fileno(SCM port ) ;
#line 60
SCM scm_sys_isatty_p(SCM port ) ;
#line 61
SCM scm_sys_fdopen(SCM fdes , SCM modes ) ;
#line 62
SCM scm_sys_primitive_move_to_fdes(SCM port , SCM fd ) ;
#line 63
void scm_setfileno(FILE *fs , int fd ) ;
#line 64
void scm_evict_ports(int fd ) ;
#line 65
SCM scm_fdes_to_ports(SCM fd ) ;
#line 66
void scm_init_ioext(void) ;
#line 526 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 529
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 59 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ioext.c"
static char s_sys_ftell[6]  = {      (char )'f',      (char )'t',      (char )'e',      (char )'l', 
        (char )'l',      (char )'\000'};
#line 61 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ioext.c"
SCM scm_sys_ftell(SCM port ) 
{ 
  long pos ;
  int *tmp ;
  int *tmp___0 ;
  SCM tmp___1 ;

  {
#line 66
  if (! (6 & (int )port)) {
#line 66
    if (! (((65279L | (1L << 16)) & ((scm_cell *)port)->car) == (125L | (1L << 16)))) {
      {
#line 66
      scm_wta(port, (char *)1, s_sys_ftell);
      }
    }
  } else {
    {
#line 66
    scm_wta(port, (char *)1, s_sys_ftell);
    }
  }
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 67
    tmp = __errno_location();
#line 67
    *tmp = 0;
#line 67
    pos = ftell((FILE *)((struct scm_port_table *)((scm_cell *)port)->cdr)->stream);
#line 67
    tmp___0 = __errno_location();
    }
#line 67
    if (! (4 == *tmp___0)) {
#line 67
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 68
  if (pos < 0L) {
    {
#line 69
    scm_syserror(s_sys_ftell);
    }
  }
#line 70
  if (pos > 0L) {
#line 70
    if (((scm_cell *)port)->car & (32L << 16)) {
#line 71
      pos --;
    }
  }
  {
#line 72
  tmp___1 = scm_long2num(pos);
  }
#line 72
  return (tmp___1);
}
}
#line 77 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ioext.c"
static char s_sys_fseek[6]  = {      (char )'f',      (char )'s',      (char )'e',      (char )'e', 
        (char )'k',      (char )'\000'};
#line 79 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ioext.c"
SCM scm_sys_fseek(SCM port , SCM offset , SCM whence ) 
{ 
  int rv ;
  long loff ;

  {
#line 88
  if (! (6 & (int )port)) {
#line 88
    if (! (((65279L | (1L << 16)) & ((scm_cell *)port)->car) == (125L | (1L << 16)))) {
      {
#line 88
      scm_wta(port, (char *)1, s_sys_fseek);
      }
    }
  } else {
    {
#line 88
    scm_wta(port, (char *)1, s_sys_fseek);
    }
  }
  {
#line 89
  loff = scm_num2long(offset, (char *)2, s_sys_fseek);
  }
#line 90
  if (2 & (int )whence) {
#line 90
    if (whence >> 2 < 3L) {
#line 90
      if (! (whence >> 2 >= 0L)) {
        {
#line 90
        scm_wta(whence, (char *)3, s_sys_fseek);
        }
      }
    } else {
      {
#line 90
      scm_wta(whence, (char *)3, s_sys_fseek);
      }
    }
  } else {
    {
#line 90
    scm_wta(whence, (char *)3, s_sys_fseek);
    }
  }
  {
#line 93
  ((scm_cell *)port)->car &= 2097151L;
#line 95
  rv = fseek((FILE *)((struct scm_port_table *)((scm_cell *)port)->cdr)->stream, loff,
             (int )(whence >> 2));
  }
#line 96
  if (rv != 0) {
    {
#line 97
    scm_syserror(s_sys_fseek);
    }
  }
#line 98
  return ((long )(21 << 9) + 372L);
}
}
#line 103 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ioext.c"
static char s_sys_freopen[8]  = 
#line 103
  {      (char )'f',      (char )'r',      (char )'e',      (char )'o', 
        (char )'p',      (char )'e',      (char )'n',      (char )'\000'};
#line 105 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ioext.c"
SCM scm_sys_freopen(SCM filename , SCM modes , SCM port ) 
{ 
  FILE *f ;
  int *tmp ;
  int *tmp___0 ;
  SCM p ;
  int *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 112
  if (! (6 & (int )filename)) {
#line 112
    if (! ((125 & (int )((scm_cell *)filename)->car) == 21)) {
      {
#line 112
      scm_wta(filename, (char *)1, s_sys_freopen);
      }
    }
  } else {
    {
#line 112
    scm_wta(filename, (char *)1, s_sys_freopen);
    }
  }
#line 113
  if (! (6 & (int )modes)) {
#line 113
    if (! ((125 & (int )((scm_cell *)modes)->car) == 21)) {
      {
#line 113
      scm_wta(modes, (char *)2, s_sys_freopen);
      }
    }
  } else {
    {
#line 113
    scm_wta(modes, (char *)2, s_sys_freopen);
    }
  }
#line 114
  scm_ints_disabled = 1;
#line 115
  if (! (6 & (int )port)) {
#line 115
    if (! ((65279 & (int )((scm_cell *)port)->car) == 125)) {
      {
#line 115
      scm_wta(port, (char *)3, s_sys_freopen);
      }
    }
  } else {
    {
#line 115
    scm_wta(port, (char *)3, s_sys_freopen);
    }
  }
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 116
    tmp = __errno_location();
#line 116
    *tmp = 0;
#line 116
    f = freopen((char const   */* __restrict  */)((char *)((scm_cell *)filename)->cdr),
                (char const   */* __restrict  */)((char *)((scm_cell *)modes)->cdr),
                (FILE */* __restrict  */)((FILE *)((struct scm_port_table *)((scm_cell *)port)->cdr)->stream));
#line 116
    tmp___0 = __errno_location();
    }
#line 116
    if (! (4 == *tmp___0)) {
#line 116
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 117
  if (! f) {
    {
#line 120
    p = port;
#line 121
    tmp___1 = __errno_location();
#line 121
    port = (long )(*tmp___1 << 2) + 2L;
#line 122
    ((scm_cell *)p)->car &= ~ (1L << 16);
#line 123
    scm_remove_from_port_table(p);
    }
  } else {
    {
#line 127
    tmp___2 = scm_mode_bits((char *)((scm_cell *)modes)->cdr);
#line 127
    ((scm_cell *)port)->car = 125L | tmp___2;
#line 128
    ((struct scm_port_table *)((scm_cell *)port)->cdr)->stream = (SCM )f;
#line 129
    tmp___3 = scm_mode_bits((char *)((scm_cell *)modes)->cdr);
#line 129
    ((scm_cell *)port)->car = 125L | tmp___3;
    }
#line 130
    if ((8L << 16) & ((scm_cell *)port)->car) {
      {
#line 131
      scm_setbuf0(port);
      }
    }
  }
#line 133
  scm_ints_disabled = 0;
#line 133
  scm_async_clock --;
#line 133
  if (0U == scm_async_clock) {
    {
#line 133
    scm_async_click();
    }
  }
#line 134
  return (port);
}
}
#line 139 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ioext.c"
static char s_sys_duplicate_port[15]  = 
#line 139
  {      (char )'d',      (char )'u',      (char )'p',      (char )'l', 
        (char )'i',      (char )'c',      (char )'a',      (char )'t', 
        (char )'e',      (char )'-',      (char )'p',      (char )'o', 
        (char )'r',      (char )'t',      (char )'\000'};
#line 141 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ioext.c"
SCM scm_sys_duplicate_port(SCM oldpt , SCM modes ) 
{ 
  int oldfd ;
  int newfd ;
  FILE *f ;
  SCM newpt ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  struct scm_port_table *pt ;
  long tmp___3 ;

  {
#line 150
  if (! (6 & (int )oldpt)) {
#line 150
    if (! (((127L | (1L << 16)) & ((scm_cell *)oldpt)->car) == (125L | (1L << 16)))) {
      {
#line 150
      scm_wta(oldpt, (char *)1, s_sys_duplicate_port);
      }
    }
  } else {
    {
#line 150
    scm_wta(oldpt, (char *)1, s_sys_duplicate_port);
    }
  }
#line 151
  if (! (6 & (int )modes)) {
#line 151
    if (! ((125 & (int )((scm_cell *)modes)->car) == 21)) {
      {
#line 151
      scm_wta(modes, (char *)2, s_sys_duplicate_port);
      }
    }
  } else {
    {
#line 151
    scm_wta(modes, (char *)2, s_sys_duplicate_port);
    }
  }
#line 152
  if (6 & (int )scm_freelist) {
    {
#line 152
    newpt = scm_gc_for_newcell();
    }
  } else {
#line 152
    newpt = scm_freelist;
#line 152
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 152
    scm_cells_allocated ++;
  }
  {
#line 153
  scm_ints_disabled = 1;
#line 154
  oldfd = fileno((FILE *)((struct scm_port_table *)((scm_cell *)oldpt)->cdr)->stream);
  }
#line 155
  if (oldfd == -1) {
    {
#line 156
    scm_syserror(s_sys_duplicate_port);
    }
  }
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 157
    tmp = __errno_location();
#line 157
    *tmp = 0;
#line 157
    newfd = dup(oldfd);
#line 157
    tmp___0 = __errno_location();
    }
#line 157
    if (! (4 == *tmp___0)) {
#line 157
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 158
  if (newfd == -1) {
    {
#line 159
    scm_syserror(s_sys_duplicate_port);
    }
  }
  {
#line 160
  f = fdopen(newfd, (char const   *)((char *)((scm_cell *)modes)->cdr));
  }
#line 161
  if (! f) {
    {
#line 163
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 163
      tmp___1 = __errno_location();
#line 163
      *tmp___1 = 0;
#line 163
      close(newfd);
#line 163
      tmp___2 = __errno_location();
      }
#line 163
      if (! (4 == *tmp___2)) {
#line 163
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 164
    scm_syserror(s_sys_duplicate_port);
    }
  }
  {
#line 168
  pt = scm_add_to_port_table(newpt);
#line 169
  ((scm_cell *)newpt)->cdr = (SCM )pt;
#line 170
  tmp___3 = scm_mode_bits((char *)((scm_cell *)modes)->cdr);
#line 170
  ((scm_cell *)newpt)->car = 125L | tmp___3;
  }
#line 171
  if ((8L << 16) & ((scm_cell *)newpt)->car) {
    {
#line 172
    scm_setbuf0(newpt);
    }
  }
#line 173
  ((struct scm_port_table *)((scm_cell *)newpt)->cdr)->stream = (SCM )f;
#line 174
  ((struct scm_port_table *)((scm_cell *)newpt)->cdr)->file_name = ((struct scm_port_table *)((scm_cell *)oldpt)->cdr)->file_name;
#line 176
  scm_ints_disabled = 0;
#line 176
  scm_async_clock --;
#line 176
  if (0U == scm_async_clock) {
    {
#line 176
    scm_async_click();
    }
  }
#line 177
  return (newpt);
}
}
#line 182 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ioext.c"
static char s_sys_redirect_port[14]  = 
#line 182
  {      (char )'r',      (char )'e',      (char )'d',      (char )'i', 
        (char )'r',      (char )'e',      (char )'c',      (char )'t', 
        (char )'-',      (char )'p',      (char )'o',      (char )'r', 
        (char )'t',      (char )'\000'};
#line 184 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ioext.c"
SCM scm_sys_redirect_port(SCM into_pt , SCM from_pt ) 
{ 
  int ans ;
  int oldfd ;
  int newfd ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 190
  scm_ints_disabled = 1;
#line 191
  if (! (6 & (int )into_pt)) {
#line 191
    if (! (((127L | (1L << 16)) & ((scm_cell *)into_pt)->car) == (125L | (1L << 16)))) {
      {
#line 191
      scm_wta(into_pt, (char *)1, s_sys_redirect_port);
      }
    }
  } else {
    {
#line 191
    scm_wta(into_pt, (char *)1, s_sys_redirect_port);
    }
  }
#line 192
  if (! (6 & (int )from_pt)) {
#line 192
    if (! (((127L | (1L << 16)) & ((scm_cell *)from_pt)->car) == (125L | (1L << 16)))) {
      {
#line 192
      scm_wta(from_pt, (char *)2, s_sys_redirect_port);
      }
    }
  } else {
    {
#line 192
    scm_wta(from_pt, (char *)2, s_sys_redirect_port);
    }
  }
  {
#line 193
  oldfd = fileno((FILE *)((struct scm_port_table *)((scm_cell *)into_pt)->cdr)->stream);
  }
#line 194
  if (oldfd == -1) {
    {
#line 195
    scm_syserror(s_sys_redirect_port);
    }
  }
  {
#line 196
  newfd = fileno((FILE *)((struct scm_port_table *)((scm_cell *)from_pt)->cdr)->stream);
  }
#line 197
  if (newfd == -1) {
    {
#line 198
    scm_syserror(s_sys_redirect_port);
    }
  }
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 199
    tmp = __errno_location();
#line 199
    *tmp = 0;
#line 199
    ans = dup2(oldfd, newfd);
#line 199
    tmp___0 = __errno_location();
    }
#line 199
    if (! (4 == *tmp___0)) {
#line 199
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 200
  if (ans == -1) {
    {
#line 201
    scm_syserror(s_sys_redirect_port);
    }
  }
#line 202
  scm_ints_disabled = 0;
#line 202
  scm_async_clock --;
#line 202
  if (0U == scm_async_clock) {
    {
#line 202
    scm_async_click();
    }
  }
#line 203
  return ((long )(21 << 9) + 372L);
}
}
#line 206 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ioext.c"
static char s_sys_fileno[7]  = {      (char )'f',      (char )'i',      (char )'l',      (char )'e', 
        (char )'n',      (char )'o',      (char )'\000'};
#line 208 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ioext.c"
SCM scm_sys_fileno(SCM port ) 
{ 
  int fd ;

  {
#line 213
  if (! (6 & (int )port)) {
#line 213
    if (! (((65279L | (1L << 16)) & ((scm_cell *)port)->car) == (125L | (1L << 16)))) {
      {
#line 213
      scm_wta(port, (char *)1, s_sys_fileno);
      }
    }
  } else {
    {
#line 213
    scm_wta(port, (char *)1, s_sys_fileno);
    }
  }
  {
#line 214
  fd = fileno((FILE *)((struct scm_port_table *)((scm_cell *)port)->cdr)->stream);
  }
#line 215
  if (fd == -1) {
    {
#line 216
    scm_syserror(s_sys_fileno);
    }
  }
#line 217
  return ((long )(fd << 2) + 2L);
}
}
#line 220 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ioext.c"
static char s_sys_isatty[8]  = 
#line 220
  {      (char )'i',      (char )'s',      (char )'a',      (char )'t', 
        (char )'t',      (char )'y',      (char )'?',      (char )'\000'};
#line 222 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ioext.c"
SCM scm_sys_isatty_p(SCM port ) 
{ 
  int rv ;
  long tmp ;

  {
#line 227
  if (! (6 & (int )port)) {
#line 227
    if (! (((65279L | (1L << 16)) & ((scm_cell *)port)->car) == (125L | (1L << 16)))) {
      {
#line 227
      scm_wta(port, (char *)1, s_sys_isatty);
      }
    }
  } else {
    {
#line 227
    scm_wta(port, (char *)1, s_sys_isatty);
    }
  }
  {
#line 228
  rv = fileno((FILE *)((struct scm_port_table *)((scm_cell *)port)->cdr)->stream);
  }
#line 229
  if (rv == -1) {
    {
#line 230
    scm_syserror(s_sys_isatty);
    }
  }
  {
#line 231
  rv = isatty(rv);
  }
#line 232
  if (rv) {
#line 232
    tmp = (long )(17 << 9) + 372L;
  } else {
#line 232
    tmp = (long )(16 << 9) + 372L;
  }
#line 232
  return (tmp);
}
}
#line 237 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ioext.c"
static char s_sys_fdopen[7]  = {      (char )'f',      (char )'d',      (char )'o',      (char )'p', 
        (char )'e',      (char )'n',      (char )'\000'};
#line 239 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ioext.c"
SCM scm_sys_fdopen(SCM fdes , SCM modes ) 
{ 
  FILE *f ;
  SCM port ;
  struct scm_port_table *pt ;
  long tmp ;

  {
#line 248
  if (! (2 & (int )fdes)) {
    {
#line 248
    scm_wta(fdes, (char *)1, s_sys_fdopen);
    }
  }
#line 249
  if (! (6 & (int )modes)) {
#line 249
    if (! ((125 & (int )((scm_cell *)modes)->car) == 21)) {
      {
#line 249
      scm_wta(modes, (char *)2, s_sys_fdopen);
      }
    }
  } else {
    {
#line 249
    scm_wta(modes, (char *)2, s_sys_fdopen);
    }
  }
#line 250
  if (6 & (int )scm_freelist) {
    {
#line 250
    port = scm_gc_for_newcell();
    }
  } else {
#line 250
    port = scm_freelist;
#line 250
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 250
    scm_cells_allocated ++;
  }
  {
#line 251
  scm_ints_disabled = 1;
#line 252
  f = fdopen((int )(fdes >> 2), (char const   *)((char *)((scm_cell *)modes)->cdr));
  }
#line 253
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 254
    scm_syserror(s_sys_fdopen);
    }
  }
  {
#line 255
  pt = scm_add_to_port_table(port);
#line 256
  ((scm_cell *)port)->cdr = (SCM )pt;
#line 257
  tmp = scm_mode_bits((char *)((scm_cell *)modes)->cdr);
#line 257
  ((scm_cell *)port)->car = 125L | tmp;
  }
#line 258
  if ((8L << 16) & ((scm_cell *)port)->car) {
    {
#line 259
    scm_setbuf0(port);
    }
  }
#line 260
  ((struct scm_port_table *)((scm_cell *)port)->cdr)->stream = (SCM )f;
#line 261
  scm_ints_disabled = 0;
#line 261
  scm_async_clock --;
#line 261
  if (0U == scm_async_clock) {
    {
#line 261
    scm_async_click();
    }
  }
#line 262
  return (port);
}
}
#line 272 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ioext.c"
static char s_sys_primitive_move_to_fdes[21]  = 
#line 272
  {      (char )'p',      (char )'r',      (char )'i',      (char )'m', 
        (char )'i',      (char )'t',      (char )'i',      (char )'v', 
        (char )'e',      (char )'-',      (char )'m',      (char )'o', 
        (char )'v',      (char )'e',      (char )'-',      (char )'>', 
        (char )'f',      (char )'d',      (char )'e',      (char )'s', 
        (char )'\000'};
#line 274 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ioext.c"
SCM scm_sys_primitive_move_to_fdes(SCM port , SCM fd ) 
{ 
  FILE *stream ;
  int old_fd ;
  int new_fd ;
  int rv ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 284
  if (! (6 & (int )port)) {
#line 284
    if (! (((65279L | (1L << 16)) & ((scm_cell *)port)->car) == (125L | (1L << 16)))) {
      {
#line 284
      scm_wta(port, (char *)1, s_sys_primitive_move_to_fdes);
      }
    }
  } else {
    {
#line 284
    scm_wta(port, (char *)1, s_sys_primitive_move_to_fdes);
    }
  }
#line 285
  if (! (2 & (int )fd)) {
    {
#line 285
    scm_wta(fd, (char *)2, s_sys_primitive_move_to_fdes);
    }
  }
  {
#line 286
  scm_ints_disabled = 1;
#line 287
  stream = (FILE *)((struct scm_port_table *)((scm_cell *)port)->cdr)->stream;
#line 288
  old_fd = fileno(stream);
#line 289
  new_fd = (int )(fd >> 2);
  }
#line 290
  if (old_fd == new_fd) {
#line 292
    scm_ints_disabled = 0;
#line 292
    scm_async_clock --;
#line 292
    if (0U == scm_async_clock) {
      {
#line 292
      scm_async_click();
      }
    }
#line 293
    return ((long )(16 << 9) + 372L);
  }
  {
#line 295
  scm_evict_ports(new_fd);
#line 296
  rv = dup2(old_fd, new_fd);
  }
#line 297
  if (rv == -1) {
    {
#line 298
    scm_syserror(s_sys_primitive_move_to_fdes);
    }
  }
  {
#line 299
  scm_setfileno(stream, new_fd);
  }
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 300
    tmp = __errno_location();
#line 300
    *tmp = 0;
#line 300
    close(old_fd);
#line 300
    tmp___0 = __errno_location();
    }
#line 300
    if (! (4 == *tmp___0)) {
#line 300
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 301
  scm_ints_disabled = 0;
#line 301
  scm_async_clock --;
#line 301
  if (0U == scm_async_clock) {
    {
#line 301
    scm_async_click();
    }
  }
#line 302
  return ((long )(17 << 9) + 372L);
}
}
#line 306 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ioext.c"
void scm_setfileno(FILE *fs , int fd ) 
{ 


  {
#line 312
  fs->_fileno = fd;
#line 324
  return;
}
}
#line 331 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ioext.c"
void scm_evict_ports(int fd ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 337
  i = 0;
  {
#line 337
  while (1) {
    while_continue: /* CIL Label */ ;
#line 337
    if (! (i < scm_port_table_size)) {
#line 337
      goto while_break;
    }
#line 339
    if ((65279 & (int )((scm_cell *)(*(scm_port_table + i))->port)->car) == 125) {
      {
#line 339
      tmp___0 = fileno((FILE *)((struct scm_port_table *)((scm_cell *)(*(scm_port_table + i))->port)->cdr)->stream);
      }
#line 339
      if (tmp___0 == fd) {
        {
#line 342
        tmp = dup(fd);
#line 342
        scm_setfileno((FILE *)((struct scm_port_table *)((scm_cell *)(*(scm_port_table + i))->port)->cdr)->stream,
                      tmp);
#line 343
        scm_set_port_revealed_x((*(scm_port_table + i))->port, 2L);
        }
      }
    }
#line 337
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 346
  return;
}
}
#line 349 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ioext.c"
static char s_fdes_to_ports[12]  = 
#line 349
  {      (char )'f',      (char )'d',      (char )'e',      (char )'s', 
        (char )'-',      (char )'>',      (char )'p',      (char )'o', 
        (char )'r',      (char )'t',      (char )'s',      (char )'\000'};
#line 351 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ioext.c"
SCM scm_fdes_to_ports(SCM fd ) 
{ 
  SCM result ;
  int int_fd ;
  int i ;
  int tmp ;

  {
#line 355
  result = (long )(20 << 9) + 372L;
#line 359
  if (! (2 & (int )fd)) {
    {
#line 359
    scm_wta(fd, (char *)1, s_fdes_to_ports);
    }
  }
#line 360
  int_fd = (int )(fd >> 2);
#line 362
  scm_ints_disabled = 1;
#line 363
  i = 0;
  {
#line 363
  while (1) {
    while_continue: /* CIL Label */ ;
#line 363
    if (! (i < scm_port_table_size)) {
#line 363
      goto while_break;
    }
#line 365
    if ((65279 & (int )((scm_cell *)(*(scm_port_table + i))->port)->car) == 125) {
      {
#line 365
      tmp = fileno((FILE *)((struct scm_port_table *)((scm_cell *)(*(scm_port_table + i))->port)->cdr)->stream);
      }
#line 365
      if (tmp == int_fd) {
        {
#line 367
        result = scm_cons((*(scm_port_table + i))->port, result);
        }
      }
    }
#line 363
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 369
  scm_ints_disabled = 0;
#line 369
  scm_async_clock --;
#line 369
  if (0U == scm_async_clock) {
    {
#line 369
    scm_async_click();
    }
  }
#line 370
  return (result);
}
}
#line 374 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ioext.c"
void scm_init_ioext(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 378
  scm_sysintern((char *)"SEEK_SET", 2L);
#line 379
  scm_sysintern((char *)"SEEK_CUR", (long )(1 << 2) + 2L);
#line 380
  scm_sysintern((char *)"SEEK_END", (long )(2 << 2) + 2L);
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ioext.x"
  scm_make_gsubr(s_sys_ftell, 1, 0, 0, (SCM (*)())(& scm_sys_ftell));
#line 2
  scm_make_gsubr(s_sys_fseek, 3, 0, 0, (SCM (*)())(& scm_sys_fseek));
#line 3
  scm_make_gsubr(s_sys_freopen, 3, 0, 0, (SCM (*)())(& scm_sys_freopen));
#line 4
  scm_make_gsubr(s_sys_duplicate_port, 2, 0, 0, (SCM (*)())(& scm_sys_duplicate_port));
#line 5
  scm_make_gsubr(s_sys_redirect_port, 2, 0, 0, (SCM (*)())(& scm_sys_redirect_port));
#line 6
  scm_make_gsubr(s_sys_fileno, 1, 0, 0, (SCM (*)())(& scm_sys_fileno));
#line 7
  scm_make_gsubr(s_sys_isatty, 1, 0, 0, (SCM (*)())(& scm_sys_isatty_p));
#line 8
  scm_make_gsubr(s_sys_fdopen, 2, 0, 0, (SCM (*)())(& scm_sys_fdopen));
#line 9
  scm_make_gsubr(s_sys_primitive_move_to_fdes, 2, 0, 0, (SCM (*)())(& scm_sys_primitive_move_to_fdes));
#line 10
  scm_make_gsubr(s_fdes_to_ports, 1, 0, 0, (SCM (*)())(& scm_fdes_to_ports));
  }
#line 457 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/ioext.c"
  return;
}
}
#line 145 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 82 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/error.h"
void scm_init_error(void) ;
#line 56 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.h"
int scm_block_gc ;
#line 99
int scm_init_storage(long init_heap_size ) ;
#line 100
void scm_init_gc(void) ;
#line 53 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gsubr.h"
void scm_init_gsubr(void) ;
#line 65 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/boolean.h"
void scm_init_boolean(void) ;
#line 202 "../libguile/debug.h"
void scm_init_debug(void) ;
#line 69 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.h"
void scm_init_async(void) ;
#line 67 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/alist.h"
void scm_init_alist(void) ;
#line 53 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/append.h"
void scm_init_append(void) ;
#line 54 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/arbiters.h"
void scm_init_arbiters(void) ;
#line 56 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/backtrace.h"
void scm_init_backtrace(void) ;
#line 85 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.h"
void scm_tables_prehistory(void) ;
#line 88
void scm_init_chars(void) ;
#line 76 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/continuations.h"
void scm_init_continuations(void) ;
#line 55 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/dynl.h"
void scm_init_dynamic_linking(void) ;
#line 52 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/dynwind.h"
void scm_init_dynwind(void) ;
#line 53 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eq.h"
void scm_init_eq(void) ;
#line 168 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.h"
void scm_init_eval(void) ;
#line 51 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/feature.h"
void scm_set_program_arguments(int argc , char **argv , char *first___0 ) ;
#line 53
void scm_init_feature(void) ;
#line 103 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.h"
void scm_init_filesys(void) ;
#line 61 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/fports.h"
SCM scm_stdio_to_port(FILE *file , char *mode , char *name ) ;
#line 63
void scm_init_fports(void) ;
#line 56 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gdbint.h"
void scm_init_gdbint(void) ;
#line 58 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hash.h"
void scm_init_hash(void) ;
#line 82 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.h"
void scm_init_hashtab(void) ;
#line 50 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/init.h"
void scm_boot_guile(int argc , char **argv , void (*main_func)(void *closure , int argc ,
                                                               char **argv ) , void *closure ) ;
#line 123 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/init.c"
static void scm_start_stack(void *base ) ;
#line 124
static void scm_restart_stack(void *base ) ;
#line 126 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/init.c"
static void scm_start_stack(void *base ) 
{ 
  SCM root ;
  SCM tmp ;
  char *tmp___0 ;
  char *__cil_tmp5 ;

  {
  {
#line 132
  tmp = scm_make_root((long )(18 << 9) + 372L);
#line 132
  root = scm_permanent_object(tmp);
#line 133
  scm_root = (scm_root_state *)((scm_cell *)root)->cdr;
#line 134
  scm_root->stack_base = (SCM_STACKITEM *)base;
#line 136
  scm_root->exitval = (long )(16 << 9) + 372L;
#line 138
  scm_root->top_level_lookup_closure_var = (long )(16 << 9) + 372L;
#line 139
  scm_root->system_transformer = (long )(16 << 9) + 372L;
  }
#line 143
  if (6 & (int )scm_freelist) {
    {
#line 143
    scm_root->rootcont = scm_gc_for_newcell();
    }
  } else {
#line 143
    scm_root->rootcont = scm_freelist;
#line 143
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 143
    scm_cells_allocated ++;
  }
  {
#line 144
  tmp___0 = scm_must_malloc((long )sizeof(scm_contregs ), (char *)"continuation");
#line 144
  ((scm_cell *)scm_root->rootcont)->cdr = (SCM )tmp___0;
#line 146
  ((scm_cell *)scm_root->rootcont)->car = (SCM )61;
#line 147
  ((scm_contregs *)((char *)((scm_cell *)scm_root->rootcont)->cdr))->seq = 0UL;
#line 153
  scm_root->continuation_stack = scm_make_vector((long )(512 << 2) + 2L, (long )(18 << 9) + 372L,
                                                 (long )(18 << 9) + 372L);
#line 160
  scm_restart_stack(base);
  }
#line 161
  return;
}
}
#line 164 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/init.c"
static void scm_restart_stack(void *base ) 
{ 


  {
#line 168
  scm_root->dynwinds = (long )(20 << 9) + 372L;
#line 169
  ((scm_contregs *)((char *)((scm_cell *)scm_root->rootcont)->cdr))->dynenv = (long )(20 << 9) + 372L;
#line 170
  ((scm_contregs *)((char *)((scm_cell *)scm_root->rootcont)->cdr))->throw_value = (long )(20 << 9) + 372L;
#line 172
  scm_last_debug_frame = (scm_debug_frame *)0;
#line 172
  ((scm_contregs *)((char *)((scm_cell *)scm_root->rootcont)->cdr))->dframe = scm_last_debug_frame;
#line 174
  ((scm_contregs *)((char *)((scm_cell *)scm_root->rootcont)->cdr))->base = (SCM_STACKITEM *)base;
#line 175
  scm_root->continuation_stack_ptr = 2L;
#line 176
  return;
}
}
#line 240 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/init.c"
static void scm_init_standard_ports(void) 
{ 
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 245
  tmp___2 = fileno(stdin);
#line 245
  tmp___3 = isatty(tmp___2);
  }
#line 245
  if (tmp___3) {
#line 245
    tmp___1 = "r0";
  } else {
#line 245
    tmp___1 = "r";
  }
  {
#line 245
  scm_root->def_inp = scm_stdio_to_port(stdin, (char *)tmp___1, (char *)"standard input");
#line 248
  scm_root->def_outp = scm_stdio_to_port(stdout, (char *)"w", (char *)"standard output");
#line 249
  scm_root->def_errp = scm_stdio_to_port(stderr, (char *)"w", (char *)"standard error");
#line 251
  scm_root->cur_inp = scm_root->def_inp;
#line 252
  scm_root->cur_outp = scm_root->def_outp;
#line 253
  scm_root->cur_errp = scm_root->def_errp;
  }
#line 254
  return;
}
}
#line 275
static void scm_boot_guile_1(SCM_STACKITEM *base , struct main_func_closure *closure ) ;
#line 277
static SCM invoke_main_func(void *body_data , SCM jmpbuf ) ;
#line 308 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/init.c"
void scm_boot_guile(int argc , char **argv , void (*main_func)(void *closure , int argc ,
                                                               char **argv ) , void *closure ) 
{ 
  SCM_STACKITEM dummy ;
  struct main_func_closure c ;
  void *__cil_tmp7 ;

  {
  {
#line 321
  c.main_func = main_func;
#line 322
  c.closure = closure;
#line 323
  c.argc = argc;
#line 324
  c.argv = argv;
#line 326
  scm_boot_guile_1(& dummy, & c);
  }
#line 326
  return;
}
}
#line 335 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/init.c"
int scm_boot_guile_1_live  =    0;
#line 342 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/init.c"
static int initialized  =    0;
#line 337 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/init.c"
static void scm_boot_guile_1(SCM_STACKITEM *base , struct main_func_closure *closure ) 
{ 
  setjmp_type setjmp_val ;
  int tmp ;

  {
#line 347
  if (scm_boot_guile_1_live) {
    {
#line 348
    abort();
    }
  }
#line 350
  scm_boot_guile_1_live = 1;
#line 352
  scm_ints_disabled = 1;
#line 353
  scm_block_gc = 1;
#line 355
  if (initialized) {
    {
#line 357
    scm_restart_stack((void *)base);
    }
  } else {
    {
#line 361
    scm_ports_prehistory();
#line 362
    scm_smob_prehistory();
#line 363
    scm_tables_prehistory();
#line 364
    scm_init_storage(0L);
#line 365
    scm_init_root();
#line 369
    scm_start_stack((void *)base);
#line 370
    scm_init_gsubr();
#line 371
    scm_init_feature();
#line 372
    scm_init_alist();
#line 373
    scm_init_append();
#line 374
    scm_init_arbiters();
#line 375
    scm_init_async();
#line 376
    scm_init_backtrace();
#line 377
    scm_init_boolean();
#line 378
    scm_init_chars();
#line 379
    scm_init_continuations();
#line 380
    scm_init_dynwind();
#line 381
    scm_init_eq();
#line 382
    scm_init_error();
#line 383
    scm_init_fports();
#line 384
    scm_init_filesys();
#line 385
    scm_init_gc();
#line 386
    scm_init_gdbint();
#line 387
    scm_init_hash();
#line 388
    scm_init_hashtab();
#line 389
    scm_init_ioext();
#line 390
    scm_init_kw();
#line 391
    scm_init_list();
#line 392
    scm_init_mallocs();
#line 393
    scm_init_net_db();
#line 394
    scm_init_numbers();
#line 395
    scm_init_objprop();
#line 399
    scm_init_options();
#line 401
    scm_init_pairs();
#line 402
    scm_init_ports();
#line 403
    scm_init_posix();
#line 404
    scm_init_procs();
#line 405
    scm_init_procprop();
#line 406
    scm_init_scmsigs();
#line 407
    scm_init_socket();
#line 409
    scm_init_srcprop();
#line 411
    scm_init_stackchk();
#line 412
    scm_init_struct();
#line 413
    scm_init_stacks();
#line 414
    scm_init_strports();
#line 415
    scm_init_symbols();
#line 416
    scm_init_tag();
#line 417
    scm_init_load();
#line 418
    scm_init_print();
#line 419
    scm_init_read();
#line 420
    scm_init_sequences();
#line 421
    scm_init_stime();
#line 422
    scm_init_strings();
#line 423
    scm_init_strorder();
#line 424
    scm_init_mbstrings();
#line 425
    scm_init_strop();
#line 426
    scm_init_throw();
#line 427
    scm_init_variable();
#line 428
    scm_init_vectors();
#line 429
    scm_init_version();
#line 430
    scm_init_weaks();
#line 431
    scm_init_vports();
#line 432
    scm_init_eval();
#line 434
    scm_init_debug();
#line 436
    scm_init_ramap();
#line 437
    scm_init_unif();
#line 438
    scm_init_simpos();
#line 439
    scm_init_load_path();
#line 440
    scm_init_standard_ports();
#line 441
    scm_init_dynamic_linking();
#line 442
    initialized = 1;
    }
  }
  {
#line 445
  scm_block_gc = 0;
#line 449
  scm_stack_checking_enabled_p = (int )scm_debug_opts[11].val;
#line 452
  tmp = _setjmp((struct __jmp_buf_tag *)(((scm_contregs *)((char *)((scm_cell *)scm_root->rootcont)->cdr))->jmpbuf));
#line 452
  setjmp_val = (setjmp_type )tmp;
  }
#line 453
  if (! setjmp_val) {
    {
#line 455
    scm_init_signals();
#line 457
    scm_set_program_arguments(closure->argc, closure->argv, (char *)0);
#line 458
    scm_internal_catch((long )(17 << 9) + 372L, & invoke_main_func, (void *)closure,
                       & scm_handle_by_message, (void *)0);
    }
  }
  {
#line 462
  scm_restore_signals();
#line 468
  scm_async_clock --;
  }
#line 468
  if (0U == scm_async_clock) {
    {
#line 468
    scm_async_click();
    }
  }
  {
#line 472
  exit(0);
  }
}
}
#line 476 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/init.c"
static SCM invoke_main_func(void *body_data , SCM jmpbuf ) 
{ 
  struct main_func_closure *closure ;

  {
  {
#line 481
  closure = (struct main_func_closure *)body_data;
#line 483
  (*(closure->main_func))(closure->closure, closure->argc, closure->argv);
  }
#line 486
  return ((long )(18 << 9) + 372L);
}
}
#line 81 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 70 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/inet_aton.c"
 __attribute__((__nothrow__)) int inet_aton(char const   *cp , struct in_addr *addr ) ;
#line 70 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/inet_aton.c"
int inet_aton(char const   *cp , struct in_addr *addr ) 
{ 
  register unsigned long val ;
  register int base ;
  register int n ;
  register char c ;
  unsigned int parts[4] ;
  register unsigned int *pp ;
  unsigned short const   **tmp ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned int *tmp___4 ;
  unsigned short const   **tmp___5 ;
  void *__cil_tmp16 ;

  {
#line 79
  pp = parts;
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    val = 0UL;
#line 87
    base = 10;
#line 88
    if ((int const   )*cp == 48) {
#line 89
      cp ++;
#line 89
      if ((int const   )*cp == 120) {
#line 90
        base = 16;
#line 90
        cp ++;
      } else
#line 89
      if ((int const   )*cp == 88) {
#line 90
        base = 16;
#line 90
        cp ++;
      } else {
#line 92
        base = 8;
      }
    }
    {
#line 94
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 94
      c = (char )*cp;
#line 94
      if (! ((int )c != 0)) {
#line 94
        goto while_break___0;
      }
#line 95
      if (((int )c & -128) == 0) {
        {
#line 95
        tmp = __ctype_b_loc();
        }
#line 95
        if ((int const   )*(*tmp + (int )c) & 2048) {
#line 96
          val = val * (unsigned long )base + (unsigned long )((int )c - 48);
#line 97
          cp ++;
#line 98
          goto while_continue___0;
        }
      }
#line 100
      if (base == 16) {
#line 100
        if (((int )c & -128) == 0) {
          {
#line 100
          tmp___3 = __ctype_b_loc();
          }
#line 100
          if ((int const   )*(*tmp___3 + (int )c) & 4096) {
            {
#line 101
            tmp___2 = __ctype_b_loc();
            }
#line 101
            if ((int const   )*(*tmp___2 + (int )c) & 512) {
#line 101
              tmp___1 = 'a';
            } else {
#line 101
              tmp___1 = 'A';
            }
#line 101
            val = (val << 4) + (unsigned long )(((int )c + 10) - tmp___1);
#line 103
            cp ++;
#line 104
            goto while_continue___0;
          }
        }
      }
#line 106
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 108
    if ((int const   )*cp == 46) {
#line 115
      if ((unsigned long )pp >= (unsigned long )(parts + 3)) {
#line 116
        return (0);
      } else
#line 115
      if (val > 255UL) {
#line 116
        return (0);
      }
#line 117
      tmp___4 = pp;
#line 117
      pp ++;
#line 117
      *tmp___4 = (unsigned int )val;
#line 117
      cp ++;
    } else {
#line 119
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 124
  if (*cp) {
#line 124
    if (! (((int const   )*cp & -128) == 0)) {
#line 125
      return (0);
    } else {
      {
#line 124
      tmp___5 = __ctype_b_loc();
      }
#line 124
      if (! ((int const   )*(*tmp___5 + (int )*cp) & 8192)) {
#line 125
        return (0);
      }
    }
  }
#line 130
  n = (int )((pp - parts) + 1L);
  {
#line 133
  if (n == 1) {
#line 133
    goto case_1;
  }
#line 136
  if (n == 2) {
#line 136
    goto case_2;
  }
#line 142
  if (n == 3) {
#line 142
    goto case_3;
  }
#line 148
  if (n == 4) {
#line 148
    goto case_4;
  }
#line 131
  goto switch_break;
  case_1: /* CIL Label */ 
#line 134
  goto switch_break;
  case_2: /* CIL Label */ 
#line 137
  if (val > 16777215UL) {
#line 138
    return (0);
  }
#line 139
  val |= (unsigned long )(parts[0] << 24);
#line 140
  goto switch_break;
  case_3: /* CIL Label */ 
#line 143
  if (val > 65535UL) {
#line 144
    return (0);
  }
#line 145
  val |= (unsigned long )((parts[0] << 24) | (parts[1] << 16));
#line 146
  goto switch_break;
  case_4: /* CIL Label */ 
#line 149
  if (val > 255UL) {
#line 150
    return (0);
  }
#line 151
  val |= (unsigned long )(((parts[0] << 24) | (parts[1] << 16)) | (parts[2] << 8));
#line 152
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 154
  if (addr) {
    {
#line 155
    addr->s_addr = htonl((uint32_t )val);
    }
  }
#line 156
  return (1);
}
}
#line 53 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/alist.h"
SCM scm_sloppy_assv(SCM x , SCM alist ) ;
#line 54
SCM scm_sloppy_assoc(SCM x , SCM alist ) ;
#line 54 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hash.h"
unsigned int scm_ihashv(SCM obj , unsigned int n ) ;
#line 56
unsigned int scm_ihash(SCM obj , unsigned int n ) ;
#line 59 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.h"
SCM scm_hash_fn_set_x(SCM table , SCM obj , SCM val , unsigned int (*hash_fn)() ,
                      SCM (*assoc_fn)() , void *closure ) ;
#line 60
SCM scm_hash_fn_remove_x(SCM table , SCM obj , unsigned int (*hash_fn)() , SCM (*assoc_fn)() ,
                         SCM (*delete_fn)() , void *closure ) ;
#line 62
SCM scm_hashq_get_handle(SCM table , SCM obj ) ;
#line 65
SCM scm_hashq_set_x(SCM table , SCM obj , SCM val ) ;
#line 66
SCM scm_hashq_remove_x(SCM table , SCM obj ) ;
#line 67
SCM scm_hashv_get_handle(SCM table , SCM obj ) ;
#line 68
SCM scm_hashv_create_handle_x(SCM table , SCM obj , SCM init ) ;
#line 69
SCM scm_hashv_ref(SCM table , SCM obj , SCM dflt ) ;
#line 70
SCM scm_hashv_set_x(SCM table , SCM obj , SCM val ) ;
#line 71
SCM scm_hashv_remove_x(SCM table , SCM obj ) ;
#line 72
SCM scm_hash_get_handle(SCM table , SCM obj ) ;
#line 73
SCM scm_hash_create_handle_x(SCM table , SCM obj , SCM init ) ;
#line 74
SCM scm_hash_ref(SCM table , SCM obj , SCM dflt ) ;
#line 75
SCM scm_hash_set_x(SCM table , SCM obj , SCM val ) ;
#line 76
SCM scm_hash_remove_x(SCM table , SCM obj ) ;
#line 77
SCM scm_hashx_get_handle(SCM hash , SCM assoc , SCM table , SCM obj ) ;
#line 78
SCM scm_hashx_create_handle_x(SCM hash , SCM assoc , SCM table , SCM obj , SCM init ) ;
#line 79
SCM scm_hashx_ref(SCM hash , SCM assoc , SCM table , SCM obj , SCM dflt ) ;
#line 80
SCM scm_hashx_set_x(SCM hash , SCM assoc , SCM table , SCM obj , SCM val ) ;
#line 81
SCM scm_hashx_remove_x(SCM hash , SCM assoc , SCM delete , SCM table , SCM obj ) ;
#line 53 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
SCM scm_hash_fn_get_handle(SCM table , SCM obj , unsigned int (*hash_fn)() , SCM (*assoc_fn)() ,
                           void *closure ) 
{ 
  int k ;
  SCM h ;
  unsigned int tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 64
  if (! (6 & (int )table)) {
#line 64
    if (! ((125 & (int )((scm_cell *)table)->car) == 13)) {
      {
#line 64
      scm_wta(table, (char *)1, (char *)"hash_fn_get_handle");
      }
    }
  } else {
    {
#line 64
    scm_wta(table, (char *)1, (char *)"hash_fn_get_handle");
    }
  }
#line 65
  if ((unsigned long )((scm_cell *)table)->car >> 8 == 0UL) {
#line 66
    return ((long )(20 << 9) + 372L);
  }
  {
#line 67
  tmp = (*hash_fn)(obj, (unsigned long )((scm_cell *)table)->car >> 8, closure);
#line 67
  k = (int )tmp;
  }
#line 68
  if (0 <= k) {
#line 68
    if (! ((unsigned long )k < (unsigned long )((scm_cell *)table)->car >> 8)) {
      {
#line 68
      scm_wta((long )(k << 2) + 2L, (char *)10, (char *)"hash_fn_get_handle");
      }
    }
  } else {
    {
#line 68
    scm_wta((long )(k << 2) + 2L, (char *)10, (char *)"hash_fn_get_handle");
    }
  }
  {
#line 72
  h = (*assoc_fn)(obj, *((SCM *)((scm_cell *)table)->cdr + k), closure);
  }
#line 73
  return (h);
}
}
#line 78 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
SCM scm_hash_fn_create_handle_x(SCM table , SCM obj , SCM init , unsigned int (*hash_fn)() ,
                                SCM (*assoc_fn)() , void *closure ) 
{ 
  int k ;
  SCM it ;
  unsigned int tmp ;
  SCM new_bucket ;
  SCM old_bucket ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 90
  if (! (6 & (int )table)) {
#line 90
    if (! ((125 & (int )((scm_cell *)table)->car) == 13)) {
      {
#line 90
      scm_wta(table, (char *)1, (char *)"hash_fn_create_handle_x");
      }
    }
  } else {
    {
#line 90
    scm_wta(table, (char *)1, (char *)"hash_fn_create_handle_x");
    }
  }
#line 91
  if ((unsigned long )((scm_cell *)table)->car >> 8 == 0UL) {
#line 92
    return ((long )(20 << 9) + 372L);
  }
  {
#line 93
  tmp = (*hash_fn)(obj, (unsigned long )((scm_cell *)table)->car >> 8, closure);
#line 93
  k = (int )tmp;
  }
#line 94
  if (0 <= k) {
#line 94
    if (! ((unsigned long )k < (unsigned long )((scm_cell *)table)->car >> 8)) {
      {
#line 94
      scm_wta((long )(k << 2) + 2L, (char *)10, (char *)"hash_fn_create_handle_x");
      }
    }
  } else {
    {
#line 94
    scm_wta((long )(k << 2) + 2L, (char *)10, (char *)"hash_fn_create_handle_x");
    }
  }
  {
#line 98
  scm_ints_disabled ++;
#line 99
  it = (*assoc_fn)(obj, *((SCM *)((scm_cell *)table)->cdr + k), closure);
  }
#line 100
  if (! (6 & (int )it)) {
#line 102
    return (it);
  }
  {
#line 107
  old_bucket = *((SCM *)((scm_cell *)table)->cdr + k);
#line 108
  new_bucket = scm_acons(obj, init, old_bucket);
#line 109
  *((SCM *)((scm_cell *)table)->cdr + k) = new_bucket;
#line 110
  scm_ints_disabled --;
  }
#line 110
  if (! scm_ints_disabled) {
#line 110
    scm_async_clock --;
#line 110
    if (0U == scm_async_clock) {
      {
#line 110
      scm_async_click();
      }
    }
  }
#line 111
  return (((scm_cell *)new_bucket)->car);
}
}
#line 118 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
SCM scm_hash_fn_ref(SCM table , SCM obj , SCM dflt , unsigned int (*hash_fn)() , SCM (*assoc_fn)() ,
                    void *closure ) 
{ 
  SCM it ;

  {
  {
#line 129
  it = scm_hash_fn_get_handle(table, obj, hash_fn, assoc_fn, closure);
  }
#line 130
  if (6 & (int )it) {
#line 131
    return (dflt);
  } else {
#line 133
    return (((scm_cell *)it)->cdr);
  }
}
}
#line 139 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
SCM scm_hash_fn_set_x(SCM table , SCM obj , SCM val , unsigned int (*hash_fn)() ,
                      SCM (*assoc_fn)() , void *closure ) 
{ 
  SCM it ;

  {
  {
#line 150
  it = scm_hash_fn_create_handle_x(table, obj, (long )(16 << 9) + 372L, hash_fn, assoc_fn,
                                   closure);
#line 151
  ((scm_cell *)it)->cdr = val;
  }
#line 152
  return (val);
}
}
#line 159 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
SCM scm_hash_fn_remove_x(SCM table , SCM obj , unsigned int (*hash_fn)() , SCM (*assoc_fn)() ,
                         SCM (*delete_fn)() , void *closure ) 
{ 
  int k ;
  SCM h ;
  unsigned int tmp ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 171
  if (! (6 & (int )table)) {
#line 171
    if (! ((125 & (int )((scm_cell *)table)->car) == 13)) {
      {
#line 171
      scm_wta(table, (char *)1, (char *)"hash_fn_remove_x");
      }
    }
  } else {
    {
#line 171
    scm_wta(table, (char *)1, (char *)"hash_fn_remove_x");
    }
  }
#line 172
  if ((unsigned long )((scm_cell *)table)->car >> 8 == 0UL) {
#line 173
    return ((long )(20 << 9) + 372L);
  }
  {
#line 174
  tmp = (*hash_fn)(obj, (unsigned long )((scm_cell *)table)->car >> 8, closure);
#line 174
  k = (int )tmp;
  }
#line 175
  if (0 <= k) {
#line 175
    if (! ((unsigned long )k < (unsigned long )((scm_cell *)table)->car >> 8)) {
      {
#line 175
      scm_wta((long )(k << 2) + 2L, (char *)10, (char *)"hash_fn_remove_x");
      }
    }
  } else {
    {
#line 175
    scm_wta((long )(k << 2) + 2L, (char *)10, (char *)"hash_fn_remove_x");
    }
  }
  {
#line 179
  h = (*assoc_fn)(obj, *((SCM *)((scm_cell *)table)->cdr + k), closure);
#line 180
  *((SCM *)((scm_cell *)table)->cdr + k) = (*delete_fn)(h, *((SCM *)((scm_cell *)table)->cdr + k));
  }
#line 181
  return (h);
}
}
#line 187 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
static char s_hashq_get_handle[17]  = 
#line 187
  {      (char )'h',      (char )'a',      (char )'s',      (char )'h', 
        (char )'q',      (char )'-',      (char )'g',      (char )'e', 
        (char )'t',      (char )'-',      (char )'h',      (char )'a', 
        (char )'n',      (char )'d',      (char )'l',      (char )'e', 
        (char )'\000'};
#line 189 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
SCM scm_hashq_get_handle(SCM table , SCM obj ) 
{ 
  SCM tmp ;

  {
  {
#line 194
  tmp = scm_hash_fn_get_handle(table, obj, (unsigned int (*)())(& scm_ihashq), (SCM (*)())(& scm_sloppy_assq),
                               (void *)0);
  }
#line 194
  return (tmp);
}
}
#line 198 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
static char s_hashq_create_handle_x[21]  = 
#line 198
  {      (char )'h',      (char )'a',      (char )'s',      (char )'h', 
        (char )'q',      (char )'-',      (char )'c',      (char )'r', 
        (char )'e',      (char )'a',      (char )'t',      (char )'e', 
        (char )'-',      (char )'h',      (char )'a',      (char )'n', 
        (char )'d',      (char )'l',      (char )'e',      (char )'!', 
        (char )'\000'};
#line 200 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
SCM scm_hashq_create_handle_x(SCM table , SCM obj , SCM init ) 
{ 
  SCM tmp ;

  {
  {
#line 206
  tmp = scm_hash_fn_create_handle_x(table, obj, init, (unsigned int (*)())(& scm_ihashq),
                                    (SCM (*)())(& scm_sloppy_assq), (void *)0);
  }
#line 206
  return (tmp);
}
}
#line 210 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
static char s_hashq_ref[10]  = 
#line 210
  {      (char )'h',      (char )'a',      (char )'s',      (char )'h', 
        (char )'q',      (char )'-',      (char )'r',      (char )'e', 
        (char )'f',      (char )'\000'};
#line 212 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
SCM scm_hashq_ref(SCM table , SCM obj , SCM dflt ) 
{ 
  SCM tmp ;

  {
#line 218
  if (dflt == (long )(18 << 9) + 372L) {
#line 219
    dflt = (long )(16 << 9) + 372L;
  }
  {
#line 220
  tmp = scm_hash_fn_ref(table, obj, dflt, (unsigned int (*)())(& scm_ihashq), (SCM (*)())(& scm_sloppy_assq),
                        (void *)0);
  }
#line 220
  return (tmp);
}
}
#line 225 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
static char s_hashq_set_x[11]  = 
#line 225
  {      (char )'h',      (char )'a',      (char )'s',      (char )'h', 
        (char )'q',      (char )'-',      (char )'s',      (char )'e', 
        (char )'t',      (char )'!',      (char )'\000'};
#line 227 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
SCM scm_hashq_set_x(SCM table , SCM obj , SCM val ) 
{ 
  SCM tmp ;

  {
  {
#line 233
  tmp = scm_hash_fn_set_x(table, obj, val, (unsigned int (*)())(& scm_ihashq), (SCM (*)())(& scm_sloppy_assq),
                          (void *)0);
  }
#line 233
  return (tmp);
}
}
#line 238 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
static char s_hashq_remove_x[14]  = 
#line 238
  {      (char )'h',      (char )'a',      (char )'s',      (char )'h', 
        (char )'q',      (char )'-',      (char )'r',      (char )'e', 
        (char )'m',      (char )'o',      (char )'v',      (char )'e', 
        (char )'!',      (char )'\000'};
#line 240 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
SCM scm_hashq_remove_x(SCM table , SCM obj ) 
{ 
  SCM tmp ;

  {
  {
#line 245
  tmp = scm_hash_fn_remove_x(table, obj, (unsigned int (*)())(& scm_ihashq), (SCM (*)())(& scm_sloppy_assq),
                             (SCM (*)())(& scm_delq_x), (void *)0);
  }
#line 245
  return (tmp);
}
}
#line 251 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
static char s_hashv_get_handle[17]  = 
#line 251
  {      (char )'h',      (char )'a',      (char )'s',      (char )'h', 
        (char )'v',      (char )'-',      (char )'g',      (char )'e', 
        (char )'t',      (char )'-',      (char )'h',      (char )'a', 
        (char )'n',      (char )'d',      (char )'l',      (char )'e', 
        (char )'\000'};
#line 253 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
SCM scm_hashv_get_handle(SCM table , SCM obj ) 
{ 
  SCM tmp ;

  {
  {
#line 258
  tmp = scm_hash_fn_get_handle(table, obj, (unsigned int (*)())(& scm_ihashv), (SCM (*)())(& scm_sloppy_assv),
                               (void *)0);
  }
#line 258
  return (tmp);
}
}
#line 262 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
static char s_hashv_create_handle_x[21]  = 
#line 262
  {      (char )'h',      (char )'a',      (char )'s',      (char )'h', 
        (char )'v',      (char )'-',      (char )'c',      (char )'r', 
        (char )'e',      (char )'a',      (char )'t',      (char )'e', 
        (char )'-',      (char )'h',      (char )'a',      (char )'n', 
        (char )'d',      (char )'l',      (char )'e',      (char )'!', 
        (char )'\000'};
#line 264 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
SCM scm_hashv_create_handle_x(SCM table , SCM obj , SCM init ) 
{ 
  SCM tmp ;

  {
  {
#line 270
  tmp = scm_hash_fn_create_handle_x(table, obj, init, (unsigned int (*)())(& scm_ihashv),
                                    (SCM (*)())(& scm_sloppy_assv), (void *)0);
  }
#line 270
  return (tmp);
}
}
#line 274 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
static char s_hashv_ref[10]  = 
#line 274
  {      (char )'h',      (char )'a',      (char )'s',      (char )'h', 
        (char )'v',      (char )'-',      (char )'r',      (char )'e', 
        (char )'f',      (char )'\000'};
#line 276 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
SCM scm_hashv_ref(SCM table , SCM obj , SCM dflt ) 
{ 
  SCM tmp ;

  {
#line 282
  if (dflt == (long )(18 << 9) + 372L) {
#line 283
    dflt = (long )(16 << 9) + 372L;
  }
  {
#line 284
  tmp = scm_hash_fn_ref(table, obj, dflt, (unsigned int (*)())(& scm_ihashv), (SCM (*)())(& scm_sloppy_assv),
                        (void *)0);
  }
#line 284
  return (tmp);
}
}
#line 289 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
static char s_hashv_set_x[11]  = 
#line 289
  {      (char )'h',      (char )'a',      (char )'s',      (char )'h', 
        (char )'v',      (char )'-',      (char )'s',      (char )'e', 
        (char )'t',      (char )'!',      (char )'\000'};
#line 291 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
SCM scm_hashv_set_x(SCM table , SCM obj , SCM val ) 
{ 
  SCM tmp ;

  {
  {
#line 297
  tmp = scm_hash_fn_set_x(table, obj, val, (unsigned int (*)())(& scm_ihashv), (SCM (*)())(& scm_sloppy_assv),
                          (void *)0);
  }
#line 297
  return (tmp);
}
}
#line 301 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
static char s_hashv_remove_x[14]  = 
#line 301
  {      (char )'h',      (char )'a',      (char )'s',      (char )'h', 
        (char )'v',      (char )'-',      (char )'r',      (char )'e', 
        (char )'m',      (char )'o',      (char )'v',      (char )'e', 
        (char )'!',      (char )'\000'};
#line 303 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
SCM scm_hashv_remove_x(SCM table , SCM obj ) 
{ 
  SCM tmp ;

  {
  {
#line 308
  tmp = scm_hash_fn_remove_x(table, obj, (unsigned int (*)())(& scm_ihashv), (SCM (*)())(& scm_sloppy_assv),
                             (SCM (*)())(& scm_delv_x), (void *)0);
  }
#line 308
  return (tmp);
}
}
#line 313 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
static char s_hash_get_handle[16]  = 
#line 313
  {      (char )'h',      (char )'a',      (char )'s',      (char )'h', 
        (char )'-',      (char )'g',      (char )'e',      (char )'t', 
        (char )'-',      (char )'h',      (char )'a',      (char )'n', 
        (char )'d',      (char )'l',      (char )'e',      (char )'\000'};
#line 315 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
SCM scm_hash_get_handle(SCM table , SCM obj ) 
{ 
  SCM tmp ;

  {
  {
#line 320
  tmp = scm_hash_fn_get_handle(table, obj, (unsigned int (*)())(& scm_ihash), (SCM (*)())(& scm_sloppy_assoc),
                               (void *)0);
  }
#line 320
  return (tmp);
}
}
#line 324 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
static char s_hash_create_handle_x[20]  = 
#line 324
  {      (char )'h',      (char )'a',      (char )'s',      (char )'h', 
        (char )'-',      (char )'c',      (char )'r',      (char )'e', 
        (char )'a',      (char )'t',      (char )'e',      (char )'-', 
        (char )'h',      (char )'a',      (char )'n',      (char )'d', 
        (char )'l',      (char )'e',      (char )'!',      (char )'\000'};
#line 326 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
SCM scm_hash_create_handle_x(SCM table , SCM obj , SCM init ) 
{ 
  SCM tmp ;

  {
  {
#line 332
  tmp = scm_hash_fn_create_handle_x(table, obj, init, (unsigned int (*)())(& scm_ihash),
                                    (SCM (*)())(& scm_sloppy_assoc), (void *)0);
  }
#line 332
  return (tmp);
}
}
#line 336 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
static char s_hash_ref[9]  = 
#line 336
  {      (char )'h',      (char )'a',      (char )'s',      (char )'h', 
        (char )'-',      (char )'r',      (char )'e',      (char )'f', 
        (char )'\000'};
#line 338 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
SCM scm_hash_ref(SCM table , SCM obj , SCM dflt ) 
{ 
  SCM tmp ;

  {
#line 344
  if (dflt == (long )(18 << 9) + 372L) {
#line 345
    dflt = (long )(16 << 9) + 372L;
  }
  {
#line 346
  tmp = scm_hash_fn_ref(table, obj, dflt, (unsigned int (*)())(& scm_ihash), (SCM (*)())(& scm_sloppy_assoc),
                        (void *)0);
  }
#line 346
  return (tmp);
}
}
#line 351 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
static char s_hash_set_x[10]  = 
#line 351
  {      (char )'h',      (char )'a',      (char )'s',      (char )'h', 
        (char )'-',      (char )'s',      (char )'e',      (char )'t', 
        (char )'!',      (char )'\000'};
#line 353 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
SCM scm_hash_set_x(SCM table , SCM obj , SCM val ) 
{ 
  SCM tmp ;

  {
  {
#line 359
  tmp = scm_hash_fn_set_x(table, obj, val, (unsigned int (*)())(& scm_ihash), (SCM (*)())(& scm_sloppy_assoc),
                          (void *)0);
  }
#line 359
  return (tmp);
}
}
#line 364 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
static char s_hash_remove_x[13]  = 
#line 364
  {      (char )'h',      (char )'a',      (char )'s',      (char )'h', 
        (char )'-',      (char )'r',      (char )'e',      (char )'m', 
        (char )'o',      (char )'v',      (char )'e',      (char )'!', 
        (char )'\000'};
#line 366 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
SCM scm_hash_remove_x(SCM table , SCM obj ) 
{ 
  SCM tmp ;

  {
  {
#line 371
  tmp = scm_hash_fn_remove_x(table, obj, (unsigned int (*)())(& scm_ihash), (SCM (*)())(& scm_sloppy_assoc),
                             (SCM (*)())(& scm_delete_x), (void *)0);
  }
#line 371
  return (tmp);
}
}
#line 386
static unsigned int scm_ihashx(SCM obj , unsigned int n , struct scm_ihashx_closure *closure ) ;
#line 388 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
static unsigned int scm_ihashx(SCM obj , unsigned int n , struct scm_ihashx_closure *closure ) 
{ 
  SCM answer ;
  SCM tmp ;
  SCM tmp___0 ;

  {
#line 395
  scm_ints_disabled = 0;
#line 395
  scm_async_clock --;
#line 395
  if (0U == scm_async_clock) {
    {
#line 395
    scm_async_click();
    }
  }
  {
#line 396
  tmp = scm_ulong2num((unsigned long )n);
#line 396
  tmp___0 = scm_listify(obj, tmp, (long )(18 << 9) + 372L);
#line 396
  answer = scm_apply(closure->hash, tmp___0, (long )(20 << 9) + 372L);
#line 399
  scm_ints_disabled = 1;
  }
#line 400
  return ((unsigned int )(answer >> 2));
}
}
#line 405
static SCM scm_sloppy_assx(SCM obj , SCM alist , struct scm_ihashx_closure *closure ) ;
#line 407 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
static SCM scm_sloppy_assx(SCM obj , SCM alist , struct scm_ihashx_closure *closure ) 
{ 
  SCM answer ;
  SCM tmp ;

  {
#line 414
  scm_ints_disabled = 0;
#line 414
  scm_async_clock --;
#line 414
  if (0U == scm_async_clock) {
    {
#line 414
    scm_async_click();
    }
  }
  {
#line 415
  tmp = scm_listify(obj, alist, (long )(18 << 9) + 372L);
#line 415
  answer = scm_apply(closure->assoc, tmp, (long )(20 << 9) + 372L);
#line 418
  scm_ints_disabled = 1;
  }
#line 419
  return (answer);
}
}
#line 425
static SCM scm_delx_x(SCM obj , SCM alist , struct scm_ihashx_closure *closure ) ;
#line 427 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
static SCM scm_delx_x(SCM obj , SCM alist , struct scm_ihashx_closure *closure ) 
{ 
  SCM answer ;
  SCM tmp ;

  {
#line 434
  scm_ints_disabled = 0;
#line 434
  scm_async_clock --;
#line 434
  if (0U == scm_async_clock) {
    {
#line 434
    scm_async_click();
    }
  }
  {
#line 435
  tmp = scm_listify(obj, alist, (long )(18 << 9) + 372L);
#line 435
  answer = scm_apply(closure->delete, tmp, (long )(20 << 9) + 372L);
#line 438
  scm_ints_disabled = 1;
  }
#line 439
  return (answer);
}
}
#line 444 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
static char s_hashx_get_handle[17]  = 
#line 444
  {      (char )'h',      (char )'a',      (char )'s',      (char )'h', 
        (char )'x',      (char )'-',      (char )'g',      (char )'e', 
        (char )'t',      (char )'-',      (char )'h',      (char )'a', 
        (char )'n',      (char )'d',      (char )'l',      (char )'e', 
        (char )'\000'};
#line 446 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
SCM scm_hashx_get_handle(SCM hash , SCM assoc , SCM table , SCM obj ) 
{ 
  struct scm_ihashx_closure closure ;
  SCM tmp ;
  void *__cil_tmp7 ;

  {
  {
#line 454
  closure.hash = hash;
#line 455
  closure.assoc = assoc;
#line 456
  tmp = scm_hash_fn_get_handle(table, obj, (unsigned int (*)())(& scm_ihashx), (SCM (*)())(& scm_sloppy_assx),
                               (void *)(& closure));
  }
#line 456
  return (tmp);
}
}
#line 460 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
static char s_hashx_create_handle_x[21]  = 
#line 460
  {      (char )'h',      (char )'a',      (char )'s',      (char )'h', 
        (char )'x',      (char )'-',      (char )'c',      (char )'r', 
        (char )'e',      (char )'a',      (char )'t',      (char )'e', 
        (char )'-',      (char )'h',      (char )'a',      (char )'n', 
        (char )'d',      (char )'l',      (char )'e',      (char )'!', 
        (char )'\000'};
#line 462 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
SCM scm_hashx_create_handle_x(SCM hash , SCM assoc , SCM table , SCM obj , SCM init ) 
{ 
  struct scm_ihashx_closure closure ;
  SCM tmp ;
  void *__cil_tmp8 ;

  {
  {
#line 471
  closure.hash = hash;
#line 472
  closure.assoc = assoc;
#line 473
  tmp = scm_hash_fn_create_handle_x(table, obj, init, (unsigned int (*)())(& scm_ihashx),
                                    (SCM (*)())(& scm_sloppy_assx), (void *)(& closure));
  }
#line 473
  return (tmp);
}
}
#line 478 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
static char s_hashx_ref[10]  = 
#line 478
  {      (char )'h',      (char )'a',      (char )'s',      (char )'h', 
        (char )'x',      (char )'-',      (char )'r',      (char )'e', 
        (char )'f',      (char )'\000'};
#line 480 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
SCM scm_hashx_ref(SCM hash , SCM assoc , SCM table , SCM obj , SCM dflt ) 
{ 
  struct scm_ihashx_closure closure ;
  SCM tmp ;
  void *__cil_tmp8 ;

  {
#line 489
  if (dflt == (long )(18 << 9) + 372L) {
#line 490
    dflt = (long )(16 << 9) + 372L;
  }
  {
#line 491
  closure.hash = hash;
#line 492
  closure.assoc = assoc;
#line 493
  tmp = scm_hash_fn_ref(table, obj, dflt, (unsigned int (*)())(& scm_ihashx), (SCM (*)())(& scm_sloppy_assx),
                        (void *)(& closure));
  }
#line 493
  return (tmp);
}
}
#line 499 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
static char s_hashx_set_x[11]  = 
#line 499
  {      (char )'h',      (char )'a',      (char )'s',      (char )'h', 
        (char )'x',      (char )'-',      (char )'s',      (char )'e', 
        (char )'t',      (char )'!',      (char )'\000'};
#line 501 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
SCM scm_hashx_set_x(SCM hash , SCM assoc , SCM table , SCM obj , SCM val ) 
{ 
  struct scm_ihashx_closure closure ;
  SCM tmp ;
  void *__cil_tmp8 ;

  {
  {
#line 510
  closure.hash = hash;
#line 511
  closure.assoc = assoc;
#line 512
  tmp = scm_hash_fn_set_x(table, obj, val, (unsigned int (*)())(& scm_ihashx), (SCM (*)())(& scm_sloppy_assx),
                          (void *)(& closure));
  }
#line 512
  return (tmp);
}
}
#line 517 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
SCM scm_hashx_remove_x(SCM hash , SCM assoc , SCM delete , SCM table , SCM obj ) 
{ 
  struct scm_ihashx_closure closure ;
  SCM tmp ;
  void *__cil_tmp8 ;

  {
  {
#line 526
  closure.hash = hash;
#line 527
  closure.assoc = assoc;
#line 528
  closure.delete = delete;
#line 529
  tmp = scm_hash_fn_remove_x(table, obj, (unsigned int (*)())(& scm_ihashx), (SCM (*)())(& scm_sloppy_assx),
                             (SCM (*)())(& scm_delx_x), (void *)0);
  }
#line 529
  return (tmp);
}
}
#line 535 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
void scm_init_hashtab(void) 
{ 


  {
  {
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.x"
  scm_make_gsubr(s_hashq_get_handle, 2, 0, 0, (SCM (*)())(& scm_hashq_get_handle));
#line 2
  scm_make_gsubr(s_hashq_create_handle_x, 3, 0, 0, (SCM (*)())(& scm_hashq_create_handle_x));
#line 3
  scm_make_gsubr(s_hashq_ref, 2, 1, 0, (SCM (*)())(& scm_hashq_ref));
#line 4
  scm_make_gsubr(s_hashq_set_x, 3, 0, 0, (SCM (*)())(& scm_hashq_set_x));
#line 5
  scm_make_gsubr(s_hashq_remove_x, 2, 0, 0, (SCM (*)())(& scm_hashq_remove_x));
#line 6
  scm_make_gsubr(s_hashv_get_handle, 2, 0, 0, (SCM (*)())(& scm_hashv_get_handle));
#line 7
  scm_make_gsubr(s_hashv_create_handle_x, 3, 0, 0, (SCM (*)())(& scm_hashv_create_handle_x));
#line 8
  scm_make_gsubr(s_hashv_ref, 2, 1, 0, (SCM (*)())(& scm_hashv_ref));
#line 9
  scm_make_gsubr(s_hashv_set_x, 3, 0, 0, (SCM (*)())(& scm_hashv_set_x));
#line 10
  scm_make_gsubr(s_hashv_remove_x, 2, 0, 0, (SCM (*)())(& scm_hashv_remove_x));
#line 11
  scm_make_gsubr(s_hash_get_handle, 2, 0, 0, (SCM (*)())(& scm_hash_get_handle));
#line 12
  scm_make_gsubr(s_hash_create_handle_x, 3, 0, 0, (SCM (*)())(& scm_hash_create_handle_x));
#line 13
  scm_make_gsubr(s_hash_ref, 2, 1, 0, (SCM (*)())(& scm_hash_ref));
#line 14
  scm_make_gsubr(s_hash_set_x, 3, 0, 0, (SCM (*)())(& scm_hash_set_x));
#line 15
  scm_make_gsubr(s_hash_remove_x, 2, 0, 0, (SCM (*)())(& scm_hash_remove_x));
#line 16
  scm_make_gsubr(s_hashx_get_handle, 4, 0, 0, (SCM (*)())(& scm_hashx_get_handle));
#line 17
  scm_make_gsubr(s_hashx_create_handle_x, 5, 0, 0, (SCM (*)())(& scm_hashx_create_handle_x));
#line 18
  scm_make_gsubr(s_hashx_ref, 4, 1, 0, (SCM (*)())(& scm_hashx_ref));
#line 19
  scm_make_gsubr(s_hashx_set_x, 5, 0, 0, (SCM (*)())(& scm_hashx_set_x));
  }
#line 539 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hashtab.c"
  return;
}
}
#line 51 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hash.h"
unsigned long scm_hasher(SCM obj , unsigned long n , size_t d ) ;
#line 53
SCM scm_hashq(SCM obj , SCM n ) ;
#line 55
SCM scm_hashv(SCM obj , SCM n ) ;
#line 57
SCM scm_hash(SCM obj , SCM n ) ;
#line 55 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hash.c"
unsigned long scm_hasher(SCM obj , unsigned long n , size_t d ) 
{ 
  int tmp ;
  SCM tmp___0 ;
  double r ;
  double tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned long tmp___3 ;
  size_t len ;
  SCM *data ;
  size_t i ;
  unsigned long h ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;
  size_t i___0 ;
  unsigned long h___0 ;
  unsigned long tmp___6 ;
  size_t tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;
  int tmp___10 ;

  {
  {
#line 62
  if ((7 & (int )obj) == 6) {
#line 62
    goto case_6;
  }
#line 62
  if ((7 & (int )obj) == 2) {
#line 62
    goto case_6;
  }
#line 64
  if ((7 & (int )obj) == 4) {
#line 64
    goto case_4;
  }
#line 78
  if ((7 & (int )obj) == 0) {
#line 78
    goto case_0;
  }
#line 77
  goto switch_default___0;
  case_6: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 63
  return ((unsigned long )(obj >> 2) % n);
  case_4: /* CIL Label */ 
#line 65
  if (((int )obj & 255) == 244) {
    {
#line 66
    tmp = scm_downcase((unsigned int )(obj >> 8));
    }
#line 66
    return ((unsigned long )((unsigned int )tmp) % n);
  }
  {
#line 69
  if ((int )obj == (int )((long )(20 << 9) + 372L)) {
#line 69
    goto case_exp;
  }
#line 71
  if ((int )obj == (int )((long )(17 << 9) + 372L)) {
#line 71
    goto case_exp___0;
  }
#line 72
  if ((int )obj == (int )((long )(16 << 9) + 372L)) {
#line 72
    goto case_exp___1;
  }
#line 73
  if ((int )obj == (int )((long )(19 << 9) + 372L)) {
#line 73
    goto case_exp___2;
  }
#line 74
  goto switch_default;
  case_exp: /* CIL Label */ 
#line 69
  d = (size_t )256;
#line 69
  goto switch_break___0;
  case_exp___0: /* CIL Label */ 
#line 71
  d = (size_t )257;
#line 71
  goto switch_break___0;
  case_exp___1: /* CIL Label */ 
#line 72
  d = (size_t )258;
#line 72
  goto switch_break___0;
  case_exp___2: /* CIL Label */ 
#line 73
  d = (size_t )259;
#line 73
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 74
  d = (size_t )263;
  switch_break___0: /* CIL Label */ ;
  }
#line 76
  return (d % n);
  switch_default___0: /* CIL Label */ 
#line 77
  return (263UL % n);
  case_0: /* CIL Label */ 
  {
#line 81
  if ((127 & (int )((scm_cell *)obj)->car) == 127) {
#line 81
    goto case_127;
  }
#line 103
  if ((127 & (int )((scm_cell *)obj)->car) == 31) {
#line 103
    goto case_31;
  }
#line 103
  if ((127 & (int )((scm_cell *)obj)->car) == 29) {
#line 103
    goto case_31;
  }
#line 103
  if ((127 & (int )((scm_cell *)obj)->car) == 23) {
#line 103
    goto case_31;
  }
#line 103
  if ((127 & (int )((scm_cell *)obj)->car) == 21) {
#line 103
    goto case_31;
  }
#line 103
  if ((127 & (int )((scm_cell *)obj)->car) == 7) {
#line 103
    goto case_31;
  }
#line 103
  if ((127 & (int )((scm_cell *)obj)->car) == 5) {
#line 103
    goto case_31;
  }
#line 106
  if ((127 & (int )((scm_cell *)obj)->car) == 13) {
#line 106
    goto case_13;
  }
#line 106
  if ((127 & (int )((scm_cell *)obj)->car) == 15) {
#line 106
    goto case_13;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 120) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 112) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 104) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 96) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 88) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 80) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 72) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 64) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 56) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 48) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 40) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 32) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 24) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 16) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 8) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 0) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 126) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 124) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 122) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 118) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 116) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 114) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 110) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 108) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 106) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 102) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 100) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 98) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 94) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 92) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 90) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 86) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 84) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 82) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 78) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 76) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 74) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 70) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 68) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 66) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 62) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 60) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 58) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 54) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 52) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 50) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 46) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 44) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 42) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 38) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 36) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 34) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 30) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 28) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 26) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 22) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 20) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 18) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 14) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 12) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 10) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 6) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 4) {
#line 125
    goto case_120;
  }
#line 125
  if ((127 & (int )((scm_cell *)obj)->car) == 2) {
#line 125
    goto case_120;
  }
#line 128
  if ((127 & (int )((scm_cell *)obj)->car) == 125) {
#line 128
    goto case_125;
  }
#line 130
  if ((127 & (int )((scm_cell *)obj)->car) == 119) {
#line 130
    goto case_119;
  }
#line 130
  if ((127 & (int )((scm_cell *)obj)->car) == 117) {
#line 130
    goto case_119;
  }
#line 130
  if ((127 & (int )((scm_cell *)obj)->car) == 111) {
#line 130
    goto case_119;
  }
#line 130
  if ((127 & (int )((scm_cell *)obj)->car) == 109) {
#line 130
    goto case_119;
  }
#line 130
  if ((127 & (int )((scm_cell *)obj)->car) == 69) {
#line 130
    goto case_119;
  }
#line 130
  if ((127 & (int )((scm_cell *)obj)->car) == 101) {
#line 130
    goto case_119;
  }
#line 130
  if ((127 & (int )((scm_cell *)obj)->car) == 95) {
#line 130
    goto case_119;
  }
#line 130
  if ((127 & (int )((scm_cell *)obj)->car) == 93) {
#line 130
    goto case_119;
  }
#line 130
  if ((127 & (int )((scm_cell *)obj)->car) == 87) {
#line 130
    goto case_119;
  }
#line 130
  if ((127 & (int )((scm_cell *)obj)->car) == 85) {
#line 130
    goto case_119;
  }
#line 130
  if ((127 & (int )((scm_cell *)obj)->car) == 103) {
#line 130
    goto case_119;
  }
#line 130
  if ((127 & (int )((scm_cell *)obj)->car) == 61) {
#line 130
    goto case_119;
  }
#line 130
  if ((127 & (int )((scm_cell *)obj)->car) == 123) {
#line 130
    goto case_119;
  }
#line 130
  if ((127 & (int )((scm_cell *)obj)->car) == 115) {
#line 130
    goto case_119;
  }
#line 130
  if ((127 & (int )((scm_cell *)obj)->car) == 107) {
#line 130
    goto case_119;
  }
#line 130
  if ((127 & (int )((scm_cell *)obj)->car) == 99) {
#line 130
    goto case_119;
  }
#line 130
  if ((127 & (int )((scm_cell *)obj)->car) == 91) {
#line 130
    goto case_119;
  }
#line 130
  if ((127 & (int )((scm_cell *)obj)->car) == 83) {
#line 130
    goto case_119;
  }
#line 130
  if ((127 & (int )((scm_cell *)obj)->car) == 75) {
#line 130
    goto case_119;
  }
#line 130
  if ((127 & (int )((scm_cell *)obj)->car) == 67) {
#line 130
    goto case_119;
  }
#line 130
  if ((127 & (int )((scm_cell *)obj)->car) == 59) {
#line 130
    goto case_119;
  }
#line 130
  if ((127 & (int )((scm_cell *)obj)->car) == 51) {
#line 130
    goto case_119;
  }
#line 130
  if ((127 & (int )((scm_cell *)obj)->car) == 43) {
#line 130
    goto case_119;
  }
#line 130
  if ((127 & (int )((scm_cell *)obj)->car) == 35) {
#line 130
    goto case_119;
  }
#line 130
  if ((127 & (int )((scm_cell *)obj)->car) == 27) {
#line 130
    goto case_119;
  }
#line 130
  if ((127 & (int )((scm_cell *)obj)->car) == 19) {
#line 130
    goto case_119;
  }
#line 130
  if ((127 & (int )((scm_cell *)obj)->car) == 11) {
#line 130
    goto case_119;
  }
#line 130
  if ((127 & (int )((scm_cell *)obj)->car) == 3) {
#line 130
    goto case_119;
  }
#line 80
  goto switch_default___1;
  switch_default___1: /* CIL Label */ 
#line 80
  return (263UL % n);
  case_127: /* CIL Label */ 
  {
#line 83
  if ((65535 & (int )((scm_cell *)obj)->car) == 895) {
#line 83
    goto bighash;
  }
#line 83
  if ((65535 & (int )((scm_cell *)obj)->car) == 639) {
#line 83
    goto bighash;
  }
#line 87
  if ((65535 & (int )((scm_cell *)obj)->car) == 383) {
#line 87
    goto case_383;
  }
#line 85
  goto switch_default___2;
  bighash: 
  case_895: /* CIL Label */ 
  case_639: /* CIL Label */ 
  {
#line 84
  tmp___0 = scm_modulo(obj, (SCM )((n << 2) + 2UL));
  }
#line 84
  return ((unsigned long )(tmp___0 >> 2));
  switch_default___2: /* CIL Label */ 
#line 85
  return (263UL % n);
  case_383: /* CIL Label */ 
#line 88
  if (((scm_cell *)obj)->car == (383L | (1L << 16))) {
    {
#line 89
    r = *(((scm_dbl *)obj)->real);
#line 90
    tmp___1 = floor(r);
    }
#line 90
    if (tmp___1 == r) {
      {
#line 91
      obj = scm_inexact_to_exact(obj);
      }
#line 92
      if (6 & (int )obj) {
#line 92
        return ((unsigned long )(obj >> 2) % n);
      }
#line 93
      goto bighash;
    }
  }
  {
#line 96
  obj = scm_number_to_string(obj, (long )(10 << 2) + 2L);
  }
  switch_break___2: /* CIL Label */ ;
  }
  case_31: /* CIL Label */ 
  case_29: /* CIL Label */ 
  case_23: /* CIL Label */ 
  case_21: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 104
  if ((127 & (int )((scm_cell *)obj)->car) == 29) {
#line 104
    tmp___2 = (unsigned char *)((scm_cell *)((scm_cell *)((scm_cell *)obj)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)obj)->cdr)->car >> 2);
  } else {
#line 104
    tmp___2 = (unsigned char *)((scm_cell *)obj)->cdr;
  }
  {
#line 104
  tmp___3 = scm_strhash(tmp___2, (unsigned long )((scm_cell *)obj)->car >> 8, n);
  }
#line 104
  return (tmp___3);
  case_13: /* CIL Label */ 
  case_15: /* CIL Label */ 
#line 108
  len = (unsigned long )((scm_cell *)obj)->car >> 8;
#line 109
  data = (SCM *)((scm_cell *)obj)->cdr;
#line 110
  if (len > 5UL) {
#line 112
    i = d / 2UL;
#line 113
    h = 1UL;
    {
#line 114
    while (1) {
      while_continue: /* CIL Label */ ;
#line 114
      tmp___5 = i;
#line 114
      i --;
#line 114
      if (! tmp___5) {
#line 114
        goto while_break;
      }
      {
#line 114
      tmp___4 = scm_hasher(*(data + h % len), n, (size_t )2);
#line 114
      h = ((h << 8) + tmp___4) % n;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 115
    return (h);
  } else {
#line 119
    i___0 = len;
#line 120
    h___0 = n - 1UL;
    {
#line 121
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 121
      tmp___7 = i___0;
#line 121
      i___0 --;
#line 121
      if (! tmp___7) {
#line 121
        goto while_break___0;
      }
      {
#line 121
      tmp___6 = scm_hasher(*(data + i___0), n, d / len);
#line 121
      h___0 = ((h___0 << 8) + tmp___6) % n;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 122
    return (h___0);
  }
  case_120: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_96: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_64: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_48: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_32: /* CIL Label */ 
  case_24: /* CIL Label */ 
  case_16: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_0___0: /* CIL Label */ 
  case_126: /* CIL Label */ 
  case_124: /* CIL Label */ 
  case_122: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_94: /* CIL Label */ 
  case_92: /* CIL Label */ 
  case_90: /* CIL Label */ 
  case_86: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_82: /* CIL Label */ 
  case_78: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_62: /* CIL Label */ 
  case_60: /* CIL Label */ 
  case_58: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_46: /* CIL Label */ 
  case_44: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_38: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_34: /* CIL Label */ 
  case_30: /* CIL Label */ 
  case_28: /* CIL Label */ 
  case_26: /* CIL Label */ 
  case_22: /* CIL Label */ 
  case_20: /* CIL Label */ 
  case_18: /* CIL Label */ 
  case_14: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_6___0: /* CIL Label */ 
  case_4___0: /* CIL Label */ 
  case_2___0: /* CIL Label */ 
#line 126
  if (d) {
    {
#line 126
    tmp___8 = scm_hasher(((scm_cell *)obj)->car, n, d / 2UL);
#line 126
    tmp___9 = scm_hasher(((scm_cell *)obj)->cdr, n, d / 2UL);
    }
#line 126
    return ((tmp___8 + tmp___9) % n);
  } else {
#line 127
    return (1UL);
  }
  case_125: /* CIL Label */ 
#line 129
  if ((2L << 16) & ((scm_cell *)obj)->car) {
#line 129
    tmp___10 = 260;
  } else {
#line 129
    tmp___10 = 261;
  }
#line 129
  return ((unsigned long )tmp___10 % n);
  case_119: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_95: /* CIL Label */ 
  case_93: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_61: /* CIL Label */ 
  case_123: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_91: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_59: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_35: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_19: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 131
  return (262UL % n);
  switch_break___1: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 140 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hash.c"
unsigned int scm_ihashq(SCM obj , unsigned int n ) 
{ 


  {
#line 145
  return (((unsigned int )obj >> 1) % n);
}
}
#line 149 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hash.c"
static char s_hashq[6]  = {      (char )'h',      (char )'a',      (char )'s',      (char )'h', 
        (char )'q',      (char )'\000'};
#line 151 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hash.c"
SCM scm_hashq(SCM obj , SCM n ) 
{ 
  unsigned int tmp ;

  {
#line 156
  if (2 & (int )n) {
#line 156
    if (! (0L <= n)) {
      {
#line 156
      scm_wta(n, (char *)2, s_hashq);
      }
    }
  } else {
    {
#line 156
    scm_wta(n, (char *)2, s_hashq);
    }
  }
  {
#line 157
  tmp = scm_ihashq(obj, (unsigned int )(n >> 2));
  }
#line 157
  return ((long )(tmp << 2) + 2L);
}
}
#line 164 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hash.c"
unsigned int scm_ihashv(SCM obj , unsigned int n ) 
{ 
  int tmp ;
  unsigned long tmp___0 ;

  {
#line 169
  if (((int )obj & 255) == 244) {
    {
#line 170
    tmp = scm_downcase((unsigned int )(obj >> 8));
    }
#line 170
    return ((unsigned int )tmp % n);
  }
#line 172
  if (! (6 & (int )obj)) {
#line 172
    if ((64767 & (int )((scm_cell *)obj)->car) == 127) {
      {
#line 173
      tmp___0 = scm_hasher(obj, (unsigned long )n, (size_t )10);
      }
#line 173
      return ((unsigned int )tmp___0);
    } else {
#line 175
      return ((unsigned int )obj % n);
    }
  } else {
#line 175
    return ((unsigned int )obj % n);
  }
}
}
#line 179 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hash.c"
static char s_hashv[6]  = {      (char )'h',      (char )'a',      (char )'s',      (char )'h', 
        (char )'v',      (char )'\000'};
#line 181 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hash.c"
SCM scm_hashv(SCM obj , SCM n ) 
{ 
  unsigned int tmp ;

  {
#line 186
  if (2 & (int )n) {
#line 186
    if (! (0L <= n)) {
      {
#line 186
      scm_wta(n, (char *)2, s_hashv);
      }
    }
  } else {
    {
#line 186
    scm_wta(n, (char *)2, s_hashv);
    }
  }
  {
#line 187
  tmp = scm_ihashv(obj, (unsigned int )(n >> 2));
  }
#line 187
  return ((long )(tmp << 2) + 2L);
}
}
#line 194 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hash.c"
unsigned int scm_ihash(SCM obj , unsigned int n ) 
{ 
  unsigned long tmp ;

  {
  {
#line 199
  tmp = scm_hasher(obj, (unsigned long )n, (size_t )10);
  }
#line 199
  return ((unsigned int )tmp);
}
}
#line 202 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hash.c"
static char s_hash[5]  = {      (char )'h',      (char )'a',      (char )'s',      (char )'h', 
        (char )'\000'};
#line 204 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hash.c"
SCM scm_hash(SCM obj , SCM n ) 
{ 
  unsigned int tmp ;

  {
#line 209
  if (2 & (int )n) {
#line 209
    if (! (0L <= n)) {
      {
#line 209
      scm_wta(n, (char *)2, s_hash);
      }
    }
  } else {
    {
#line 209
    scm_wta(n, (char *)2, s_hash);
    }
  }
  {
#line 210
  tmp = scm_ihash(obj, (unsigned int )(n >> 2));
  }
#line 210
  return ((long )(tmp << 2) + 2L);
}
}
#line 217 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hash.c"
void scm_init_hash(void) 
{ 


  {
  {
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hash.x"
  scm_make_gsubr(s_hashq, 2, 0, 0, (SCM (*)())(& scm_hashq));
#line 2
  scm_make_gsubr(s_hashv, 2, 0, 0, (SCM (*)())(& scm_hashv));
#line 3
  scm_make_gsubr(s_hash, 2, 0, 0, (SCM (*)())(& scm_hash));
  }
#line 221 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/hash.c"
  return;
}
}
#line 662 "/usr/include/stdio.h"
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 52 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gsubr.h"
SCM scm_gsubr_apply(SCM args ) ;
#line 51 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/procprop.h"
SCM scm_i_name  ;
#line 70 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gsubr.c"
static SCM f_gsubr_apply  ;
#line 72 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gsubr.c"
SCM scm_make_gsubr(char *name , int req , int opt , int rst , SCM (*fcn)() ) 
{ 
  SCM tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  SCM tmp___2 ;
  SCM tmp___3 ;
  SCM tmp___4 ;
  SCM tmp___5 ;
  SCM tmp___6 ;
  SCM symcell ;
  SCM tmp___7 ;
  SCM z ;
  SCM cclo ;
  SCM tmp___8 ;
  long tmp___9 ;
  char *__cil_tmp20 ;

  {
  {
#line 81
  if (((req | (opt << 4)) | (rst << 8)) == 0) {
#line 81
    goto case_0;
  }
#line 82
  if (((req | (opt << 4)) | (rst << 8)) == 1) {
#line 82
    goto case_1;
  }
#line 83
  if (((req | (opt << 4)) | (rst << 8)) == 1 << 4) {
#line 83
    goto case_exp;
  }
#line 84
  if (((req | (opt << 4)) | (rst << 8)) == (1 | (1 << 4))) {
#line 84
    goto case_exp___0;
  }
#line 85
  if (((req | (opt << 4)) | (rst << 8)) == 2) {
#line 85
    goto case_2;
  }
#line 86
  if (((req | (opt << 4)) | (rst << 8)) == 3) {
#line 86
    goto case_3;
  }
#line 87
  if (((req | (opt << 4)) | (rst << 8)) == 1 << 8) {
#line 87
    goto case_exp___1;
  }
#line 88
  if (((req | (opt << 4)) | (rst << 8)) == (2 | (1 << 8))) {
#line 88
    goto case_exp___2;
  }
#line 89
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 81
  tmp = scm_make_subr(name, 85, fcn);
  }
#line 81
  return (tmp);
  case_1: /* CIL Label */ 
  {
#line 82
  tmp___0 = scm_make_subr(name, 87, fcn);
  }
#line 82
  return (tmp___0);
  case_exp: /* CIL Label */ 
  {
#line 83
  tmp___1 = scm_make_subr(name, 109, fcn);
  }
#line 83
  return (tmp___1);
  case_exp___0: /* CIL Label */ 
  {
#line 84
  tmp___2 = scm_make_subr(name, 111, fcn);
  }
#line 84
  return (tmp___2);
  case_2: /* CIL Label */ 
  {
#line 85
  tmp___3 = scm_make_subr(name, 101, fcn);
  }
#line 85
  return (tmp___3);
  case_3: /* CIL Label */ 
  {
#line 86
  tmp___4 = scm_make_subr(name, 95, fcn);
  }
#line 86
  return (tmp___4);
  case_exp___1: /* CIL Label */ 
  {
#line 87
  tmp___5 = scm_make_subr(name, 119, fcn);
  }
#line 87
  return (tmp___5);
  case_exp___2: /* CIL Label */ 
  {
#line 88
  tmp___6 = scm_make_subr(name, 117, fcn);
  }
#line 88
  return (tmp___6);
  switch_default: /* CIL Label */ 
  {
#line 91
  tmp___7 = scm_sysintern(name, (long )(18 << 9) + 372L);
#line 91
  symcell = tmp___7;
#line 92
  tmp___8 = scm_makcclo(f_gsubr_apply, 3L);
#line 92
  cclo = tmp___8;
#line 93
  tmp___9 = ((SCM_CELLPTR )((scm_cell *)symcell)->car - scm_heap_org) << 8;
  }
#line 94
  if (10 < (req + opt) + rst) {
    {
#line 95
    fputs((char const   */* __restrict  */)"ERROR in scm_make_gsubr: too many args\n",
          (FILE */* __restrict  */)stderr);
#line 96
    exit(1);
    }
  }
#line 98
  if (tmp___9 >> 8 != (SCM_CELLPTR )((scm_cell *)symcell)->car - scm_heap_org) {
#line 99
    tmp___9 = 0L;
  }
#line 100
  if (6 & (int )scm_freelist) {
    {
#line 100
    z = scm_gc_for_newcell();
    }
  } else {
#line 100
    z = scm_freelist;
#line 100
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 100
    scm_cells_allocated ++;
  }
#line 101
  ((scm_subr *)z)->cproc = fcn;
#line 102
  ((scm_cell *)z)->car = tmp___9 + 85L;
#line 103
  *((SCM *)((scm_cell *)cclo)->cdr + 2) = z;
#line 104
  *((SCM *)((scm_cell *)cclo)->cdr + 1) = (long )(((req | (opt << 4)) | (rst << 8)) << 2) + 2L;
#line 105
  ((scm_cell *)symcell)->cdr = cclo;
#line 107
  if (scm_debug_opts[3].val) {
    {
#line 108
    scm_set_procedure_property_x(cclo, scm_i_name, ((scm_cell *)symcell)->car);
    }
  }
#line 110
  return (cclo);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 116 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gsubr.c"
static char s_gsubr_apply[12]  = 
#line 116
  {      (char )'g',      (char )'s',      (char )'u',      (char )'b', 
        (char )'r',      (char )'-',      (char )'a',      (char )'p', 
        (char )'p',      (char )'l',      (char )'y',      (char )'\000'};
#line 118 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gsubr.c"
SCM scm_gsubr_apply(SCM args ) 
{ 
  SCM self ;
  SCM (*fcn)() ;
  SCM v[10] ;
  int typ ;
  int i ;
  int n ;
  SCM tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  SCM tmp___2 ;
  SCM tmp___3 ;
  SCM tmp___4 ;
  SCM tmp___5 ;
  SCM tmp___6 ;
  SCM tmp___7 ;
  SCM tmp___8 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 122
  self = ((scm_cell *)args)->car;
#line 123
  fcn = ((scm_subr *)*((SCM *)((scm_cell *)self)->cdr + 2))->cproc;
#line 125
  typ = (int )(*((SCM *)((scm_cell *)self)->cdr + 1) >> 2);
#line 126
  n = ((typ & 15) + ((typ & 240) >> 4)) + (typ >> 8);
#line 127
  args = ((scm_cell *)args)->cdr;
#line 128
  i = 0;
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    if (! (i < (typ & 15))) {
#line 128
      goto while_break;
    }
#line 130
    if (6 & (int )args) {
#line 131
      if (((scm_cell *)*((SCM *)((scm_cell *)self)->cdr + 2))->car >> 8) {
#line 131
        tmp = (SCM )(scm_heap_org + (((scm_cell *)*((SCM *)((scm_cell *)self)->cdr + 2))->car >> 8));
      } else {
#line 131
        tmp = scm_sys_protects[4];
      }
      {
#line 131
      scm_wrong_num_args(tmp);
      }
    }
#line 133
    v[i] = ((scm_cell *)args)->car;
#line 134
    args = ((scm_cell *)args)->cdr;
#line 128
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 136
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 136
    if (! (i < (typ & 15) + ((typ & 240) >> 4))) {
#line 136
      goto while_break___0;
    }
#line 137
    if (! (6 & (int )args)) {
#line 138
      v[i] = ((scm_cell *)args)->car;
#line 139
      args = ((scm_cell *)args)->cdr;
    } else {
#line 142
      v[i] = (long )(18 << 9) + 372L;
    }
#line 136
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 144
  if (typ >> 8) {
#line 145
    v[i] = args;
  }
  {
#line 148
  if (n == 2) {
#line 148
    goto case_2;
  }
#line 149
  if (n == 3) {
#line 149
    goto case_3;
  }
#line 150
  if (n == 4) {
#line 150
    goto case_4;
  }
#line 151
  if (n == 5) {
#line 151
    goto case_5;
  }
#line 152
  if (n == 6) {
#line 152
    goto case_6;
  }
#line 153
  if (n == 7) {
#line 153
    goto case_7;
  }
#line 154
  if (n == 8) {
#line 154
    goto case_8;
  }
#line 155
  if (n == 9) {
#line 155
    goto case_9;
  }
#line 156
  if (n == 10) {
#line 156
    goto case_10;
  }
#line 147
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 147
  scm_wta(self, (char *)"internal programming error", s_gsubr_apply);
  }
  case_2: /* CIL Label */ 
  {
#line 148
  tmp___0 = (*fcn)(v[0], v[1]);
  }
#line 148
  return (tmp___0);
  case_3: /* CIL Label */ 
  {
#line 149
  tmp___1 = (*fcn)(v[0], v[1], v[2]);
  }
#line 149
  return (tmp___1);
  case_4: /* CIL Label */ 
  {
#line 150
  tmp___2 = (*fcn)(v[0], v[1], v[2], v[3]);
  }
#line 150
  return (tmp___2);
  case_5: /* CIL Label */ 
  {
#line 151
  tmp___3 = (*fcn)(v[0], v[1], v[2], v[3], v[4]);
  }
#line 151
  return (tmp___3);
  case_6: /* CIL Label */ 
  {
#line 152
  tmp___4 = (*fcn)(v[0], v[1], v[2], v[3], v[4], v[5]);
  }
#line 152
  return (tmp___4);
  case_7: /* CIL Label */ 
  {
#line 153
  tmp___5 = (*fcn)(v[0], v[1], v[2], v[3], v[4], v[5], v[6]);
  }
#line 153
  return (tmp___5);
  case_8: /* CIL Label */ 
  {
#line 154
  tmp___6 = (*fcn)(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7]);
  }
#line 154
  return (tmp___6);
  case_9: /* CIL Label */ 
  {
#line 155
  tmp___7 = (*fcn)(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7], v[8]);
  }
#line 155
  return (tmp___7);
  case_10: /* CIL Label */ 
  {
#line 156
  tmp___8 = (*fcn)(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7], v[8], v[9]);
  }
#line 156
  return (tmp___8);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 165 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gsubr.c"
SCM gsubr_21l(SCM req1 , SCM req2 , SCM opt , SCM rst ) 
{ 
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 169
  scm_gen_puts((enum scm_string_representation_type )0, (char *)"gsubr-2-1-l:\n req1: ",
               scm_root->cur_outp);
#line 170
  scm_display(req1, scm_root->cur_outp);
#line 171
  scm_gen_puts((enum scm_string_representation_type )0, (char *)"\n req2: ", scm_root->cur_outp);
#line 172
  scm_display(req2, scm_root->cur_outp);
#line 173
  scm_gen_puts((enum scm_string_representation_type )0, (char *)"\n opt: ", scm_root->cur_outp);
#line 174
  scm_display(opt, scm_root->cur_outp);
#line 175
  scm_gen_puts((enum scm_string_representation_type )0, (char *)"\n rest: ", scm_root->cur_outp);
#line 176
  scm_display(rst, scm_root->cur_outp);
#line 177
  scm_newline(scm_root->cur_outp);
  }
#line 178
  return ((long )(21 << 9) + 372L);
}
}
#line 184 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gsubr.c"
void scm_init_gsubr(void) 
{ 
  SCM tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 187
  f_gsubr_apply = scm_make_subr(s_gsubr_apply, 119, (SCM (*)())(& scm_gsubr_apply));
#line 188
  tmp = scm_sysintern((char *)"name", (long )(18 << 9) + 372L);
#line 188
  scm_i_name = ((scm_cell *)tmp)->car;
#line 189
  scm_permanent_object(scm_i_name);
#line 191
  scm_make_gsubr((char *)"gsubr-2-1-l", 2, 1, 1, (SCM (*)())(& gsubr_21l));
  }
#line 193
  return;
}
}
#line 56 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/genio.c"
static void scm_putc(int c , SCM port ) ;
#line 58 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/genio.c"
static void scm_putc(int c , SCM port ) 
{ 
  size_t i ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 63
  i = (size_t )(255L & (((scm_cell *)port)->car >> 8));
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 64
    tmp = __errno_location();
#line 64
    *tmp = 0;
#line 64
    (*((scm_ptobs + i)->fputc))(c, ((struct scm_port_table *)((scm_cell *)port)->cdr)->stream);
#line 64
    tmp___0 = __errno_location();
    }
#line 64
    if (! (4 == *tmp___0)) {
#line 64
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 65
  return;
}
}
#line 69
static void scm_puts(char *s___0 , SCM port ) ;
#line 71 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/genio.c"
static void scm_puts(char *s___0 , SCM port ) 
{ 
  size_t i ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 76
  i = (size_t )(255L & (((scm_cell *)port)->car >> 8));
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 77
    tmp = __errno_location();
#line 77
    *tmp = 0;
#line 77
    (*((scm_ptobs + i)->fputs))(s___0, ((struct scm_port_table *)((scm_cell *)port)->cdr)->stream);
#line 77
    tmp___0 = __errno_location();
    }
#line 77
    if (! (4 == *tmp___0)) {
#line 77
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return;
}
}
#line 86
static int scm_lfwrite(char *ptr , size_t size , size_t nitems , SCM port ) ;
#line 88 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/genio.c"
static int scm_lfwrite(char *ptr , size_t size , size_t nitems , SCM port ) 
{ 
  int ret ;
  size_t i ;
  int *tmp ;
  size_t tmp___0 ;
  int *tmp___1 ;

  {
#line 96
  i = (size_t )(255L & (((scm_cell *)port)->car >> 8));
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 97
    tmp = __errno_location();
#line 97
    *tmp = 0;
#line 97
    tmp___0 = (*((scm_ptobs + i)->fwrite))(ptr, size, nitems, ((struct scm_port_table *)((scm_cell *)port)->cdr)->stream);
#line 97
    ret = (int )tmp___0;
#line 97
    tmp___1 = __errno_location();
    }
#line 97
    if (! (4 == *tmp___1)) {
#line 97
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  return (ret);
}
}
#line 109 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/genio.c"
void scm_gen_putc(int c , SCM port ) 
{ 
  char buf[256] ;
  int len ;
  int x ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 116
  if ((unsigned int )((struct scm_port_table *)((scm_cell *)port)->cdr)->representation == 0U) {
#line 116
    goto case_0;
  }
#line 125
  if ((unsigned int )((struct scm_port_table *)((scm_cell *)port)->cdr)->representation == 1U) {
#line 125
    goto case_1;
  }
#line 148
  if ((unsigned int )((struct scm_port_table *)((scm_cell *)port)->cdr)->representation == 2U) {
#line 148
    goto case_2;
  }
#line 114
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 121
  scm_putc((int )((unsigned char )c), port);
  }
#line 122
  goto switch_break;
  case_1: /* CIL Label */ 
#line 130
  if (! (4UL < sizeof(buf))) {
    {
#line 130
    scm_wta((SCM )((c << 8) + 244), (char *)"huge translation", (char *)"scm_gen_putc");
    }
  }
  {
#line 133
  len = xwctomb(buf, c);
  }
#line 135
  if (! (len >= 0)) {
    {
#line 135
    scm_wta((SCM )((c << 8) + 244), (char *)"bogus character", (char *)"scm_gen_putc");
    }
  }
#line 137
  if (len == 0) {
    {
#line 138
    scm_putc(0, port);
    }
  } else {
#line 142
    x = 0;
    {
#line 142
    while (1) {
      while_continue: /* CIL Label */ ;
#line 142
      if (! (x < len)) {
#line 142
        goto while_break;
      }
      {
#line 143
      scm_putc((int )buf[x], port);
#line 142
      x ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 145
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 150
  scm_putc((int )((unsigned char )(c >> 8)) & 255, port);
#line 151
  scm_putc((int )((unsigned char )(c & 255)), port);
  }
#line 152
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 155
  return;
}
}
#line 162 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/genio.c"
void scm_gen_puts(enum scm_string_representation_type rep , char *str_data , SCM port ) 
{ 
  xwchar_t output ;
  int len ;
  int size ;
  size_t tmp ;
  xwchar_t *wstr_data ;
  char buf[256] ;
  int len___0 ;
  int x ;
  int len___1 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 171
  if ((unsigned int )rep == 0U) {
#line 171
    goto case_0;
  }
#line 190
  if ((unsigned int )rep == 1U) {
#line 190
    goto case_1___0;
  }
#line 217
  if ((unsigned int )rep == 2U) {
#line 217
    goto case_2___1;
  }
#line 168
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 175
  if ((unsigned int )((struct scm_port_table *)((scm_cell *)port)->cdr)->representation == 1U) {
#line 175
    goto case_1;
  }
#line 175
  if ((unsigned int )((struct scm_port_table *)((scm_cell *)port)->cdr)->representation == 0U) {
#line 175
    goto case_1;
  }
#line 178
  if ((unsigned int )((struct scm_port_table *)((scm_cell *)port)->cdr)->representation == 2U) {
#line 178
    goto case_2;
  }
#line 172
  goto switch_break___0;
  case_1: /* CIL Label */ 
  case_0___0: /* CIL Label */ 
  {
#line 176
  scm_puts(str_data, port);
  }
#line 177
  return;
  case_2: /* CIL Label */ 
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 180
    if (! *str_data) {
#line 180
      goto while_break;
    }
    {
#line 182
    scm_putc(0, port);
#line 183
    scm_putc((int )*str_data, port);
#line 184
    str_data ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  return;
  switch_break___0: /* CIL Label */ ;
  }
  case_1___0: /* CIL Label */ 
  {
#line 194
  if ((unsigned int )((struct scm_port_table *)((scm_cell *)port)->cdr)->representation == 1U) {
#line 194
    goto case_1___1;
  }
#line 194
  if ((unsigned int )((struct scm_port_table *)((scm_cell *)port)->cdr)->representation == 0U) {
#line 194
    goto case_1___1;
  }
#line 197
  if ((unsigned int )((struct scm_port_table *)((scm_cell *)port)->cdr)->representation == 2U) {
#line 197
    goto case_2___0;
  }
#line 191
  goto switch_break___1;
  case_1___1: /* CIL Label */ 
  case_0___1: /* CIL Label */ 
  {
#line 195
  scm_puts(str_data, port);
  }
#line 196
  return;
  case_2___0: /* CIL Label */ 
  {
#line 203
  tmp = strlen((char const   *)str_data);
#line 203
  size = (int )tmp;
  }
  {
#line 204
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 204
    if (! size) {
#line 204
      goto while_break___0;
    }
    {
#line 206
    len = xmbtowc(& output, (unsigned char const   *)str_data, (size_t )size);
    }
#line 207
    if (! (len > 0)) {
      {
#line 207
      scm_wta((long )((int )*str_data << 2) + 2L, (char *)"bogus character", (char *)"scm_gen_puts");
      }
    }
    {
#line 208
    scm_putc(((int )output >> 8) & 255, port);
#line 209
    scm_putc((int )output & 255, port);
#line 210
    size -= len;
#line 211
    str_data += len;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 213
  return;
  switch_break___1: /* CIL Label */ ;
  }
  case_2___1: /* CIL Label */ 
#line 221
  wstr_data = (xwchar_t *)str_data;
  {
#line 224
  if ((unsigned int )((struct scm_port_table *)((scm_cell *)port)->cdr)->representation == 0U) {
#line 224
    goto case_0___2;
  }
#line 232
  if ((unsigned int )((struct scm_port_table *)((scm_cell *)port)->cdr)->representation == 1U) {
#line 232
    goto case_1___2;
  }
#line 256
  if ((unsigned int )((struct scm_port_table *)((scm_cell *)port)->cdr)->representation == 2U) {
#line 256
    goto case_2___2;
  }
#line 222
  goto switch_break___2;
  case_0___2: /* CIL Label */ 
  {
#line 225
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 225
    if (! *wstr_data) {
#line 225
      goto while_break___1;
    }
    {
#line 227
    scm_putc((int )((unsigned char )*wstr_data), port);
#line 228
    wstr_data ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 230
  return;
  case_1___2: /* CIL Label */ 
#line 235
  if (! (4UL < sizeof(buf))) {
    {
#line 235
    scm_wta((long )(16 << 9) + 372L, (char *)"huge translation", (char *)"scm_gen_puts");
    }
  }
  {
#line 238
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 238
    if (! *wstr_data) {
#line 238
      goto while_break___2;
    }
    {
#line 242
    len___0 = xwctomb(buf, (int )*wstr_data);
    }
#line 244
    if (! (len___0 > 0)) {
      {
#line 244
      scm_wta((long )((int )*wstr_data << 2) + 2L, (char *)"bogus character", (char *)"scm_gen_puts");
      }
    }
#line 248
    x = 0;
    {
#line 248
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 248
      if (! (x < len___0)) {
#line 248
        goto while_break___3;
      }
      {
#line 249
      scm_putc((int )buf[x], port);
#line 248
      x ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 251
    wstr_data ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 253
  return;
  case_2___2: /* CIL Label */ 
#line 259
  len___1 = 0;
  {
#line 259
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 259
    if (! *(wstr_data + len___1)) {
#line 259
      goto while_break___4;
    }
#line 259
    len___1 ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 261
  scm_lfwrite(str_data, sizeof(xwchar_t ), (size_t )len___1, port);
  }
#line 262
  return;
  switch_break___2: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
#line 267
  return;
}
}
#line 273 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/genio.c"
void scm_gen_write(enum scm_string_representation_type rep , char *str_data , size_t nitems ,
                   SCM port ) 
{ 
  xwchar_t output ;
  int len ;
  xwchar_t *wstr_data ;
  char buf[256] ;
  int len___0 ;
  int x ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 284
  if ((unsigned int )rep == 0U) {
#line 284
    goto case_0;
  }
#line 304
  if ((unsigned int )rep == 1U) {
#line 304
    goto case_1___0;
  }
#line 330
  if ((unsigned int )rep == 2U) {
#line 330
    goto case_2___1;
  }
#line 282
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 288
  if ((unsigned int )((struct scm_port_table *)((scm_cell *)port)->cdr)->representation == 1U) {
#line 288
    goto case_1;
  }
#line 288
  if ((unsigned int )((struct scm_port_table *)((scm_cell *)port)->cdr)->representation == 0U) {
#line 288
    goto case_1;
  }
#line 291
  if ((unsigned int )((struct scm_port_table *)((scm_cell *)port)->cdr)->representation == 2U) {
#line 291
    goto case_2;
  }
#line 285
  goto switch_break___0;
  case_1: /* CIL Label */ 
  case_0___0: /* CIL Label */ 
  {
#line 289
  scm_lfwrite(str_data, (size_t )1, nitems, port);
  }
#line 290
  return;
  case_2: /* CIL Label */ 
  {
#line 293
  while (1) {
    while_continue: /* CIL Label */ ;
#line 293
    if (! nitems) {
#line 293
      goto while_break;
    }
    {
#line 295
    scm_putc(0, port);
#line 296
    scm_putc((int )*str_data, port);
#line 297
    str_data ++;
#line 298
    nitems --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 300
  return;
  switch_break___0: /* CIL Label */ ;
  }
  case_1___0: /* CIL Label */ 
  {
#line 308
  if ((unsigned int )((struct scm_port_table *)((scm_cell *)port)->cdr)->representation == 1U) {
#line 308
    goto case_1___1;
  }
#line 308
  if ((unsigned int )((struct scm_port_table *)((scm_cell *)port)->cdr)->representation == 0U) {
#line 308
    goto case_1___1;
  }
#line 312
  if ((unsigned int )((struct scm_port_table *)((scm_cell *)port)->cdr)->representation == 2U) {
#line 312
    goto case_2___0;
  }
#line 305
  goto switch_break___1;
  case_1___1: /* CIL Label */ 
  case_0___1: /* CIL Label */ 
  {
#line 309
  scm_lfwrite(str_data, (size_t )1, nitems, port);
  }
#line 310
  return;
  case_2___0: /* CIL Label */ 
  {
#line 317
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 317
    if (! nitems) {
#line 317
      goto while_break___0;
    }
    {
#line 319
    len = xmbtowc(& output, (unsigned char const   *)str_data, nitems);
    }
#line 320
    if (! (len > 0)) {
      {
#line 320
      scm_wta((long )((int )*str_data << 2) + 2L, (char *)"bogus character", (char *)"scm_gen_puts");
      }
    }
    {
#line 321
    scm_putc(((int )output >> 8) & 255, port);
#line 322
    scm_putc((int )output & 255, port);
#line 323
    nitems -= (size_t )len;
#line 324
    str_data += len;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 326
  return;
  switch_break___1: /* CIL Label */ ;
  }
  case_2___1: /* CIL Label */ 
#line 334
  wstr_data = (xwchar_t *)str_data;
  {
#line 337
  if ((unsigned int )((struct scm_port_table *)((scm_cell *)port)->cdr)->representation == 0U) {
#line 337
    goto case_0___2;
  }
#line 346
  if ((unsigned int )((struct scm_port_table *)((scm_cell *)port)->cdr)->representation == 1U) {
#line 346
    goto case_1___2;
  }
#line 371
  if ((unsigned int )((struct scm_port_table *)((scm_cell *)port)->cdr)->representation == 2U) {
#line 371
    goto case_2___2;
  }
#line 335
  goto switch_break___2;
  case_0___2: /* CIL Label */ 
  {
#line 338
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 338
    if (! nitems) {
#line 338
      goto while_break___1;
    }
    {
#line 340
    scm_putc((int )((unsigned char )*wstr_data), port);
#line 341
    wstr_data ++;
#line 342
    nitems --;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 344
  return;
  case_1___2: /* CIL Label */ 
#line 349
  if (! (4UL < sizeof(buf))) {
    {
#line 349
    scm_wta((long )(16 << 9) + 372L, (char *)"huge translation", (char *)"scm_gen_puts");
    }
  }
  {
#line 352
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 352
    if (! nitems) {
#line 352
      goto while_break___2;
    }
    {
#line 356
    len___0 = xwctomb(buf, (int )*wstr_data);
    }
#line 358
    if (! (len___0 > 0)) {
      {
#line 358
      scm_wta((long )((int )*wstr_data << 2) + 2L, (char *)"bogus character", (char *)"scm_gen_puts");
      }
    }
#line 362
    x = 0;
    {
#line 362
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 362
      if (! (x < len___0)) {
#line 362
        goto while_break___3;
      }
      {
#line 363
      scm_putc((int )buf[x], port);
#line 362
      x ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 365
    wstr_data ++;
#line 366
    nitems --;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 368
  return;
  case_2___2: /* CIL Label */ 
  {
#line 373
  scm_lfwrite(str_data, sizeof(xwchar_t ), nitems, port);
  }
#line 374
  return;
  switch_break___2: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
#line 379
  return;
}
}
#line 385
static int scm_getc(SCM port ) ;
#line 387 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/genio.c"
static int scm_getc(SCM port ) 
{ 
  SCM f ;
  int c ;
  size_t i ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 395
  f = ((struct scm_port_table *)((scm_cell *)port)->cdr)->stream;
#line 396
  i = (size_t )(255L & (((scm_cell *)port)->car >> 8));
  {
#line 397
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 397
    tmp = __errno_location();
#line 397
    *tmp = 0;
#line 397
    c = (*((scm_ptobs + i)->fgetc))(f);
#line 397
    tmp___0 = __errno_location();
    }
#line 397
    if (! (4 == *tmp___0)) {
#line 397
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 398
  return (c);
}
}
#line 402 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/genio.c"
int scm_gen_getc(SCM port ) 
{ 
  int c ;
  int x ;
  unsigned char buf[256] ;
  xwchar_t out ;
  int tmp ;
  int hi ;
  int lo ;
  int tmp___0 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 409
  if (((scm_cell *)port)->car & (32L << 16)) {
#line 411
    c = ((struct scm_port_table *)((scm_cell *)port)->cdr)->unchr;
#line 412
    ((scm_cell *)port)->car &= 2097151L;
    return_c: 
#line 415
    if (c == 10) {
#line 417
      (((struct scm_port_table *)((scm_cell *)port)->cdr)->line_number) ++;
#line 417
      ((struct scm_port_table *)((scm_cell *)port)->cdr)->column_number = 0;
    } else
#line 419
    if (c == 9) {
#line 421
      ((struct scm_port_table *)((scm_cell *)port)->cdr)->column_number += 8 - ((struct scm_port_table *)((scm_cell *)port)->cdr)->column_number % 8;
    } else {
#line 425
      (((struct scm_port_table *)((scm_cell *)port)->cdr)->column_number) ++;
    }
#line 427
    return (c);
  }
  {
#line 433
  if ((unsigned int )((struct scm_port_table *)((scm_cell *)port)->cdr)->representation == 0U) {
#line 433
    goto case_0;
  }
#line 437
  if ((unsigned int )((struct scm_port_table *)((scm_cell *)port)->cdr)->representation == 1U) {
#line 437
    goto case_1;
  }
#line 469
  if ((unsigned int )((struct scm_port_table *)((scm_cell *)port)->cdr)->representation == 2U) {
#line 469
    goto case_2;
  }
#line 484
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 434
  c = scm_getc(port);
  }
#line 435
  goto return_c;
  case_1: /* CIL Label */ 
#line 442
  if (! (4UL < sizeof(buf))) {
    {
#line 442
    scm_wta((long )(16 << 9) + 372L, (char *)"huge translation", (char *)"scm_gen_puts");
    }
  }
#line 445
  x = 0;
  {
#line 446
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 449
    c = scm_getc(port);
    }
#line 451
    if (c == -1) {
#line 452
      return (-1);
    }
    {
#line 454
    buf[x] = (unsigned char )c;
#line 456
    tmp = xmbtowc(& out, (unsigned char const   *)(buf), (size_t )(x + 1));
    }
#line 456
    if (tmp > 0) {
#line 458
      c = (int )out;
#line 459
      goto return_c;
    }
#line 462
    if (! ((unsigned long )x < sizeof(buf))) {
      {
#line 462
      scm_wta((long )(16 << 9) + 372L, (char *)"huge translation", (char *)"scm_gen_getc");
      }
    }
#line 464
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  case_2: /* CIL Label */ 
  {
#line 473
  hi = scm_getc(port);
  }
#line 474
  if (hi == -1) {
#line 474
    lo = -1;
  } else {
    {
#line 474
    tmp___0 = scm_getc(port);
#line 474
    lo = tmp___0;
    }
  }
#line 477
  if (hi == -1) {
#line 477
    c = -1;
  } else {
#line 477
    c = (hi << 8) | lo;
  }
#line 480
  goto return_c;
  switch_default: /* CIL Label */ 
#line 485
  return (-1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 490 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/genio.c"
void scm_gen_ungetc(int c , SCM port ) 
{ 


  {
#line 496
  ((struct scm_port_table *)((scm_cell *)port)->cdr)->unchr = c;
#line 496
  ((scm_cell *)port)->car |= 32L << 16;
#line 497
  if (c == 10) {
#line 502
    (((struct scm_port_table *)((scm_cell *)port)->cdr)->line_number) --;
  } else {
#line 505
    (((struct scm_port_table *)((scm_cell *)port)->cdr)->column_number) --;
  }
#line 506
  return;
}
}
#line 88 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.h"
int scm_cellp(SCM value ) ;
#line 141 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.h"
SCM scm_ceval(SCM x , SCM env ) ;
#line 159
SCM scm_top_level_env(SCM thunk ) ;
#line 54 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gdbint.h"
int scm_print_carefully_p  ;
#line 60 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gdb_interface.h"
unsigned short gdb_options ;
#line 65
char *gdb_language ;
#line 69 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gdb_interface.h"
SCM gdb_result  ;
#line 76 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gdb_interface.h"
char *gdb_output  ;
#line 78 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gdb_interface.h"
int gdb_output_length  ;
#line 87
int gdb_maybe_valid_type_p(SCM value ) ;
#line 96
int gdb_read(char *str ) ;
#line 105
int gdb_eval(SCM exp___0 ) ;
#line 113
int gdb_print(SCM obj ) ;
#line 125
int gdb_binding(SCM name , SCM value ) ;
#line 110 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gdbint.c"
unsigned short gdb_options  =    (unsigned short)1;
#line 112 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gdbint.c"
char *gdb_language  =    (char *)"lisp/c";
#line 122 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gdbint.c"
static SCM gdb_input_port  ;
#line 123 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gdbint.c"
static int port_mark_p  ;
#line 123 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gdbint.c"
static int stream_mark_p  ;
#line 123 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gdbint.c"
static int string_mark_p  ;
#line 125 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gdbint.c"
static SCM tok_buf  ;
#line 126 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gdbint.c"
static int tok_buf_mark_p  ;
#line 128 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gdbint.c"
static SCM gdb_output_port  ;
#line 129 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gdbint.c"
static int old_ints  ;
#line 129 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gdbint.c"
static int old_gc  ;
#line 132
static void unmark_port(SCM port ) ;
#line 134 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gdbint.c"
static void unmark_port(SCM port ) 
{ 
  SCM stream ;
  SCM string ;

  {
#line 139
  port_mark_p = 128 & (int )((scm_cell *)port)->car;
#line 140
  ((scm_cell *)port)->car &= -129L;
#line 141
  stream = ((struct scm_port_table *)((scm_cell *)port)->cdr)->stream;
#line 142
  stream_mark_p = 1 & (int )((scm_cell *)stream)->cdr;
#line 143
  ((scm_cell *)stream)->cdr &= -2L;
#line 144
  string = ((scm_cell *)stream)->cdr;
#line 145
  string_mark_p = 128 & (int )((scm_cell *)string)->car;
#line 146
  ((scm_cell *)string)->car &= -129L;
#line 147
  return;
}
}
#line 150
static void remark_port(SCM port ) ;
#line 152 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gdbint.c"
static void remark_port(SCM port ) 
{ 
  SCM stream ;
  SCM string ;

  {
#line 156
  stream = ((struct scm_port_table *)((scm_cell *)port)->cdr)->stream;
#line 157
  string = ((scm_cell *)stream)->cdr;
#line 158
  if (string_mark_p) {
#line 158
    ((scm_cell *)string)->car |= 128L;
  }
#line 159
  if (stream_mark_p) {
#line 159
    ((scm_cell *)stream)->cdr |= 1L;
  }
#line 160
  if (port_mark_p) {
#line 160
    ((scm_cell *)port)->car |= 128L;
  }
#line 161
  return;
}
}
#line 164 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gdbint.c"
int gdb_maybe_valid_type_p(SCM value ) 
{ 
  SCM tmp ;
  int tmp___0 ;

  {
#line 168
  if (6 & (int )value) {
    {
#line 169
    tmp = scm_tag(value);
    }
#line 169
    return (tmp != (long )(-1 << 2) + 2L);
  } else {
    {
#line 168
    tmp___0 = scm_cellp(value);
    }
#line 168
    if (tmp___0) {
      {
#line 169
      tmp = scm_tag(value);
      }
#line 169
      return (tmp != (long )(-1 << 2) + 2L);
    }
  }
#line 170
  return (0);
}
}
#line 174 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gdbint.c"
int gdb_read(char *str ) 
{ 
  SCM ans ;
  int status ;
  char *p ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 179
  status = 0;
#line 180
  gdb_output_length = 0;
#line 182
  if (scm_gc_heap_lock) {
#line 185
    p = str;
    {
#line 185
    while (1) {
      while_continue: /* CIL Label */ ;
#line 185
      if (! ((int )*p != 0)) {
#line 185
        goto while_break;
      }
      {
#line 190
      if ((int )*p == 34) {
#line 190
        goto case_34;
      }
#line 190
      if ((int )*p == 39) {
#line 190
        goto case_34;
      }
#line 190
      if ((int )*p == 40) {
#line 190
        goto case_34;
      }
#line 193
      if ((int )*p == 35) {
#line 193
        goto case_35;
      }
#line 204
      goto switch_default;
      case_34: /* CIL Label */ 
      case_39: /* CIL Label */ 
      case_40: /* CIL Label */ 
      {
#line 191
      gdb_output = (char *)"Can\'t read this kind of expressions during gc";
#line 191
      tmp = strlen("Can\'t read this kind of expressions during gc");
#line 191
      gdb_output_length = (int )tmp;
      }
#line 192
      return (-1);
      case_35: /* CIL Label */ 
#line 194
      p ++;
#line 194
      if ((int )*p == 0) {
#line 195
        goto premature;
      }
#line 196
      if ((int )*p == 92) {
#line 198
        p ++;
#line 198
        if ((int )*p != 0) {
#line 199
          goto __Cont;
        }
        premature: 
        {
#line 201
        gdb_output = (char *)"Premature end of lisp expression";
#line 201
        tmp___0 = strlen("Premature end of lisp expression");
#line 201
        gdb_output_length = (int )tmp___0;
        }
#line 202
        return (-1);
      }
      switch_default: /* CIL Label */ 
#line 205
      goto __Cont;
      switch_break: /* CIL Label */ ;
      }
      __Cont: /* CIL Label */ 
#line 185
      p ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 208
  old_ints = scm_ints_disabled;
#line 208
  scm_ints_disabled = 1;
#line 208
  old_gc = scm_block_gc;
#line 208
  scm_block_gc = 1;
#line 208
  scm_print_carefully_p = 1;
#line 209
  unmark_port(gdb_input_port);
#line 211
  ans = ((scm_cell *)((struct scm_port_table *)((scm_cell *)gdb_input_port)->cdr)->stream)->cdr;
#line 212
  ((scm_cell *)ans)->cdr = (SCM )str;
#line 213
  tmp___1 = strlen((char const   *)str);
#line 213
  ((scm_cell *)ans)->car = (SCM )((tmp___1 << 8) + 21UL);
#line 214
  ((scm_cell *)((struct scm_port_table *)((scm_cell *)gdb_input_port)->cdr)->stream)->car = (SCM )2;
#line 216
  tok_buf_mark_p = 128 & (int )((scm_cell *)tok_buf)->car;
#line 217
  ((scm_cell *)tok_buf)->car &= -129L;
#line 218
  ans = scm_lreadr(& tok_buf, gdb_input_port, 0, (long )(16 << 9) + 372L, & ans);
  }
#line 219
  if (scm_gc_heap_lock) {
#line 221
    if (! (6 & (int )ans)) {
      {
#line 223
      gdb_output = (char *)"Non-immediate created during gc.  Memory may be trashed.";
#line 223
      tmp___2 = strlen("Non-immediate created during gc.  Memory may be trashed.");
#line 223
      gdb_output_length = (int )tmp___2;
#line 224
      status = -1;
      }
#line 225
      goto exit;
    }
  }
#line 228
  gdb_result = ans;
#line 230
  if (! (6 & (int )ans)) {
    {
#line 231
    scm_permanent_object(ans);
    }
  }
  exit: 
#line 233
  if (tok_buf_mark_p) {
#line 234
    ((scm_cell *)tok_buf)->car |= 128L;
  }
  {
#line 235
  remark_port(gdb_input_port);
#line 236
  scm_print_carefully_p = 0;
#line 236
  scm_block_gc = old_gc;
#line 236
  scm_ints_disabled = old_ints;
  }
#line 237
  return (status);
}
}
#line 241 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gdbint.c"
int gdb_eval(SCM exp___0 ) 
{ 
  size_t tmp ;
  SCM env ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 245
  gdb_output_length = 0;
#line 246
  if (6 & (int )exp___0) {
#line 248
    gdb_result = exp___0;
#line 249
    return (0);
  }
#line 251
  if (scm_gc_heap_lock) {
    {
#line 253
    gdb_output = (char *)"Can\'t evaluate lisp expressions during gc";
#line 253
    tmp = strlen("Can\'t evaluate lisp expressions during gc");
#line 253
    gdb_output_length = (int )tmp;
    }
#line 254
    return (-1);
  }
  {
#line 256
  old_ints = scm_ints_disabled;
#line 256
  scm_ints_disabled = 1;
#line 256
  old_gc = scm_block_gc;
#line 256
  scm_block_gc = 1;
#line 256
  scm_print_carefully_p = 1;
#line 258
  tmp___0 = scm_top_level_env(((scm_cell *)scm_root->top_level_lookup_closure_var)->cdr);
#line 258
  env = tmp___0;
#line 259
  tmp___1 = scm_ceval(exp___0, env);
#line 259
  gdb_result = scm_permanent_object(tmp___1);
#line 261
  scm_print_carefully_p = 0;
#line 261
  scm_block_gc = old_gc;
#line 261
  scm_ints_disabled = old_ints;
  }
#line 262
  return (0);
}
}
#line 266 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gdbint.c"
int gdb_print(SCM obj ) 
{ 
  size_t tmp ;

  {
  {
#line 270
  gdb_output_length = 0;
#line 271
  old_ints = scm_ints_disabled;
#line 271
  scm_ints_disabled = 1;
#line 271
  old_gc = scm_block_gc;
#line 271
  scm_block_gc = 1;
#line 271
  scm_print_carefully_p = 1;
#line 273
  ((scm_cell *)((struct scm_port_table *)((scm_cell *)gdb_output_port)->cdr)->stream)->car = (SCM )2;
#line 274
  scm_write(obj, gdb_output_port);
#line 275
  scm_display((SCM )244, gdb_output_port);
#line 276
  gdb_output = (char *)((scm_cell *)((scm_cell *)((struct scm_port_table *)((scm_cell *)gdb_output_port)->cdr)->stream)->cdr)->cdr;
#line 276
  tmp = strlen((char const   *)((char *)((scm_cell *)((scm_cell *)((struct scm_port_table *)((scm_cell *)gdb_output_port)->cdr)->stream)->cdr)->cdr));
#line 276
  gdb_output_length = (int )tmp;
#line 277
  scm_print_carefully_p = 0;
#line 277
  scm_block_gc = old_gc;
#line 277
  scm_ints_disabled = old_ints;
  }
#line 278
  return (0);
}
}
#line 282 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gdbint.c"
int gdb_binding(SCM name , SCM value ) 
{ 
  size_t tmp ;
  SCM vcell ;
  SCM tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 287
  gdb_output_length = 0;
#line 288
  if (scm_gc_heap_lock) {
    {
#line 290
    gdb_output = (char *)"Can\'t create new bindings during gc";
#line 290
    tmp = strlen("Can\'t create new bindings during gc");
#line 290
    gdb_output_length = (int )tmp;
    }
#line 291
    return (-1);
  }
  {
#line 293
  old_ints = scm_ints_disabled;
#line 293
  scm_ints_disabled = 1;
#line 293
  old_gc = scm_block_gc;
#line 293
  scm_block_gc = 1;
#line 293
  scm_print_carefully_p = 1;
#line 295
  tmp___0 = scm_sym2vcell(name, ((scm_cell *)scm_root->top_level_lookup_closure_var)->cdr,
                          (long )(17 << 9) + 372L);
#line 295
  vcell = tmp___0;
#line 298
  ((scm_cell *)vcell)->cdr = value;
#line 300
  scm_print_carefully_p = 0;
#line 300
  scm_block_gc = old_gc;
#line 300
  scm_ints_disabled = old_ints;
  }
#line 301
  return (0);
}
}
#line 307 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gdbint.c"
static char *s  =    (char *)"scm_init_gdb_interface";
#line 304 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gdbint.c"
void scm_init_gdbint(void) 
{ 
  SCM port ;
  SCM tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;

  {
  {
#line 310
  scm_print_carefully_p = 0;
#line 312
  tmp = scm_make_string((long )(80 << 2) + 2L, (long )(18 << 9) + 372L);
#line 312
  port = scm_mkstrport((SCM )2, tmp, (1L << 16) | (4L << 16), s);
#line 316
  gdb_output_port = scm_permanent_object(port);
#line 318
  tmp___0 = scm_make_string(2L, (long )(18 << 9) + 372L);
#line 318
  port = scm_mkstrport((SCM )2, tmp___0, (1L << 16) | (2L << 16), s);
#line 322
  gdb_input_port = scm_permanent_object(port);
#line 324
  tmp___1 = scm_makstr(30L, 0);
#line 324
  tok_buf = scm_permanent_object(tmp___1);
  }
#line 325
  return;
}
}
#line 53 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.h"
struct scm_heap_seg_data *scm_heap_table ;
#line 54
int scm_n_heap_segs ;
#line 61
long scm_heap_size ;
#line 62 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.h"
SCM_CELLPTR scm_heap_org  ;
#line 64 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.h"
unsigned long scm_gc_cells_collected  ;
#line 65 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.h"
unsigned long scm_gc_malloc_collected  ;
#line 66 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.h"
unsigned long scm_gc_ports_collected  ;
#line 69 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.h"
long scm_mtrigger  ;
#line 77
SCM scm_object_addr(SCM obj ) ;
#line 78
SCM scm_unhash_name(SCM name ) ;
#line 79
SCM scm_gc_stats(void) ;
#line 80
void scm_gc_start(char *what ) ;
#line 81
void scm_gc_end(void) ;
#line 82
SCM scm_gc(void) ;
#line 83
void scm_gc_for_alloc(int ncells , SCM *freelistp ) ;
#line 85
void scm_igc(char *what ) ;
#line 87
void scm_mark_locations(SCM_STACKITEM *x , size_t n ) ;
#line 89
void scm_gc_sweep(void) ;
#line 97
SCM scm_protect_object(SCM obj ) ;
#line 98
SCM scm_unprotect_object(SCM obj ) ;
#line 143 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
SCM scm_freelist  =    (long )(20 << 9) + 372L;
#line 155 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
int scm_gc_heap_lock  =    0;
#line 162 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
int scm_block_gc  =    1;
#line 172 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
SCM *scm_weak_vectors  ;
#line 173 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
int scm_weak_size  ;
#line 174 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
int scm_n_weak  ;
#line 178 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
unsigned long scm_cells_allocated  =    0UL;
#line 179 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
unsigned long scm_mallocated  =    0UL;
#line 183 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
unsigned long scm_gc_rt  ;
#line 184 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
unsigned long scm_gc_time_taken  =    0UL;
#line 186 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
static SCM sym_cells_allocated  =    (long )(16 << 9) + 372L;
#line 187 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
static SCM sym_heap_size  =    (long )(16 << 9) + 372L;
#line 188 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
static SCM sym_mallocated  =    (long )(16 << 9) + 372L;
#line 189 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
static SCM sym_mtrigger  =    (long )(16 << 9) + 372L;
#line 190 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
static SCM sym_heap_segments  =    (long )(16 << 9) + 372L;
#line 191 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
static SCM sym_gc_time_taken  =    (long )(16 << 9) + 372L;
#line 216
static void scm_mark_weak_vector_spines(void) ;
#line 217
static size_t init_heap_seg(SCM_CELLPTR seg_org , size_t size , int ncells , SCM *freelistp ) ;
#line 218
static void alloc_some_heap(int ncells , SCM *freelistp ) ;
#line 320 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
static char s_gc_stats[9]  = 
#line 320
  {      (char )'g',      (char )'c',      (char )'-',      (char )'s', 
        (char )'t',      (char )'a',      (char )'t',      (char )'s', 
        (char )'\000'};
#line 321 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
SCM scm_gc_stats(void) 
{ 
  int i ;
  int n ;
  SCM heap_segs ;
  SCM local_scm_mtrigger ;
  SCM local_scm_mallocated ;
  SCM local_scm_heap_size ;
  SCM local_scm_cells_allocated ;
  SCM local_scm_gc_time_taken ;
  SCM answer ;
  SCM tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  int tmp___2 ;
  SCM tmp___3 ;
  SCM tmp___4 ;
  SCM tmp___5 ;
  SCM tmp___6 ;
  SCM tmp___7 ;
  SCM tmp___8 ;
  SCM tmp___9 ;
  SCM tmp___10 ;
  SCM tmp___11 ;
  SCM tmp___12 ;
  SCM tmp___13 ;

  {
#line 334
  scm_ints_disabled = 1;
#line 335
  scm_block_gc = 1;
  retry: 
#line 337
  heap_segs = (long )(20 << 9) + 372L;
#line 338
  n = scm_n_heap_segs;
#line 339
  i = scm_n_heap_segs;
  {
#line 339
  while (1) {
    while_continue: /* CIL Label */ ;
#line 339
    tmp___2 = i;
#line 339
    i --;
#line 339
    if (! tmp___2) {
#line 339
      goto while_break;
    }
    {
#line 340
    tmp = scm_ulong2num((unsigned long )(scm_heap_table + i)->bounds[0]);
#line 340
    tmp___0 = scm_ulong2num((unsigned long )(scm_heap_table + i)->bounds[1]);
#line 340
    tmp___1 = scm_cons(tmp___0, tmp);
#line 340
    heap_segs = scm_cons(tmp___1, heap_segs);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 343
  if (scm_n_heap_segs != n) {
#line 344
    goto retry;
  }
  {
#line 345
  scm_block_gc = 0;
#line 347
  local_scm_mtrigger = scm_mtrigger;
#line 348
  local_scm_mallocated = (SCM )scm_mallocated;
#line 349
  local_scm_heap_size = scm_heap_size;
#line 350
  local_scm_cells_allocated = (SCM )scm_cells_allocated;
#line 351
  local_scm_gc_time_taken = (SCM )scm_gc_time_taken;
#line 353
  tmp___3 = scm_cons(sym_heap_segments, heap_segs);
#line 353
  tmp___4 = scm_ulong2num((unsigned long )local_scm_mtrigger);
#line 353
  tmp___5 = scm_cons(sym_mtrigger, tmp___4);
#line 353
  tmp___6 = scm_ulong2num((unsigned long )local_scm_mallocated);
#line 353
  tmp___7 = scm_cons(sym_mallocated, tmp___6);
#line 353
  tmp___8 = scm_ulong2num((unsigned long )local_scm_heap_size);
#line 353
  tmp___9 = scm_cons(sym_heap_size, tmp___8);
#line 353
  tmp___10 = scm_ulong2num((unsigned long )local_scm_cells_allocated);
#line 353
  tmp___11 = scm_cons(sym_cells_allocated, tmp___10);
#line 353
  tmp___12 = scm_ulong2num((unsigned long )local_scm_gc_time_taken);
#line 353
  tmp___13 = scm_cons(sym_gc_time_taken, tmp___12);
#line 353
  answer = scm_listify(tmp___13, tmp___11, tmp___9, tmp___7, tmp___5, tmp___3, (long )(18 << 9) + 372L);
#line 360
  scm_ints_disabled = 0;
#line 360
  scm_async_clock --;
  }
#line 360
  if (0U == scm_async_clock) {
    {
#line 360
    scm_async_click();
    }
  }
#line 361
  return (answer);
}
}
#line 365 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
void scm_gc_start(char *what ) 
{ 
  SCM tmp ;

  {
  {
#line 369
  tmp = scm_get_internal_run_time();
#line 369
  scm_gc_rt = (unsigned long )(tmp >> 2);
#line 370
  scm_gc_cells_collected = 0UL;
#line 371
  scm_gc_malloc_collected = 0UL;
#line 372
  scm_gc_ports_collected = 0UL;
  }
#line 373
  return;
}
}
#line 375 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
void scm_gc_end(void) 
{ 
  SCM tmp ;

  {
  {
#line 378
  tmp = scm_get_internal_run_time();
#line 378
  scm_gc_rt = (unsigned long )(tmp >> 2) - scm_gc_rt;
#line 379
  scm_gc_time_taken += scm_gc_rt;
#line 380
  scm_take_signal(20);
  }
#line 381
  return;
}
}
#line 384 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
static char s_object_address[15]  = 
#line 384
  {      (char )'o',      (char )'b',      (char )'j',      (char )'e', 
        (char )'c',      (char )'t',      (char )'-',      (char )'a', 
        (char )'d',      (char )'d',      (char )'r',      (char )'e', 
        (char )'s',      (char )'s',      (char )'\000'};
#line 385 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
SCM scm_object_addr(SCM obj ) 
{ 
  SCM tmp ;

  {
  {
#line 389
  tmp = scm_ulong2num((unsigned long )obj);
  }
#line 389
  return (tmp);
}
}
#line 393 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
static char s_gc[3]  = {      (char )'g',      (char )'c',      (char )'\000'};
#line 394 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
SCM scm_gc(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
#line 397
  scm_ints_disabled = 1;
#line 398
  scm_igc((char *)"call");
#line 399
  scm_ints_disabled = 0;
#line 399
  scm_async_clock --;
  }
#line 399
  if (0U == scm_async_clock) {
    {
#line 399
    scm_async_click();
    }
  }
#line 400
  return ((long )(21 << 9) + 372L);
}
}
#line 408 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
void scm_gc_for_alloc(int ncells , SCM *freelistp ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 413
  scm_ints_disabled ++;
#line 414
  scm_igc((char *)"cells");
  }
#line 415
  if (scm_gc_cells_collected < (unsigned long )(scm_heap_size / 4L)) {
    {
#line 417
    alloc_some_heap(ncells, freelistp);
    }
  } else
#line 415
  if (6 & (int )*freelistp) {
    {
#line 417
    alloc_some_heap(ncells, freelistp);
    }
  }
#line 419
  scm_ints_disabled --;
#line 419
  if (! scm_ints_disabled) {
#line 419
    scm_async_clock --;
#line 419
    if (0U == scm_async_clock) {
      {
#line 419
      scm_async_click();
      }
    }
  }
#line 420
  return;
}
}
#line 423 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
SCM scm_gc_for_newcell(void) 
{ 
  SCM fl ;

  {
  {
#line 427
  scm_gc_for_alloc(1, & scm_freelist);
#line 428
  fl = scm_freelist;
#line 429
  scm_freelist = ((scm_cell *)fl)->cdr;
  }
#line 430
  return (fl);
}
}
#line 433 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
void scm_igc(char *what ) 
{ 
  int j ;
  int x ;
  int bound ;
  SCM *elts ;
  long stack_len ;
  long tmp ;
  int tmp___0 ;

  {
  {
#line 444
  scm_gc_start(what);
  }
#line 445
  if (! scm_root->stack_base) {
    {
#line 447
    scm_gc_end();
    }
#line 448
    return;
  } else
#line 445
  if (scm_block_gc) {
    {
#line 447
    scm_gc_end();
    }
#line 448
    return;
  }
#line 451
  scm_gc_heap_lock ++;
#line 452
  scm_n_weak = 0;
#line 481
  elts = (SCM *)((scm_cell *)scm_root->continuation_stack)->cdr;
#line 482
  bound = (int )((unsigned long )((scm_cell *)scm_root->continuation_stack)->car >> 8);
#line 483
  x = (int )(scm_root->continuation_stack_ptr >> 2);
  {
#line 484
  while (1) {
    while_continue: /* CIL Label */ ;
#line 484
    if (! (x < bound)) {
#line 484
      goto while_break;
    }
#line 486
    *(elts + x) = (long )(16 << 9) + 372L;
#line 487
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 503
  _setjmp((struct __jmp_buf_tag *)(scm_root->save_regs_gc_mark));
#line 504
  scm_mark_locations((SCM_STACKITEM *)(scm_root->save_regs_gc_mark), ((sizeof(SCM_STACKITEM ) - 1UL) + sizeof(scm_root->save_regs_gc_mark)) / sizeof(SCM_STACKITEM ));
#line 523
  tmp = scm_stack_size(scm_root->stack_base);
#line 523
  stack_len = tmp;
#line 525
  scm_mark_locations(scm_root->stack_base - stack_len, (size_t )stack_len);
#line 540
  j = 17;
  }
  {
#line 541
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 541
    tmp___0 = j;
#line 541
    j --;
#line 541
    if (! tmp___0) {
#line 541
      goto while_break___0;
    }
    {
#line 542
    scm_gc_mark(scm_sys_protects[j]);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 545
  scm_gc_mark(scm_root->handle);
#line 548
  scm_mark_weak_vector_spines();
#line 550
  scm_gc_sweep();
#line 552
  scm_gc_heap_lock --;
#line 553
  scm_gc_end();
  }
#line 558
  return;
}
}
#line 568 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
void scm_gc_mark(SCM p ) 
{ 
  register long i ;
  register SCM ptr ;
  SCM vcell ;
  SCM layout ;
  SCM *vtable_data ;
  int len ;
  char *fields_desc ;
  register SCM *mem ;
  register int x ;
  int tmp ;
  int *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  int x___0 ;
  int len___0 ;
  int weak_keys ;
  int weak_values ;
  int tmp___3 ;
  int tmp___4 ;
  SCM alist ;
  SCM kvpair ;
  SCM next_alist ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 575
  ptr = p;
  gc_mark_loop: 
#line 578
  if (6 & (int )ptr) {
#line 579
    return;
  }
  gc_mark_nimp: 
#line 582
  if ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )ptr)) {
    {
#line 583
    scm_wta(ptr, (char *)"rogue pointer in ", (char *)"heap");
    }
  }
  {
#line 587
  if ((127 & (int )((scm_cell *)ptr)->car) == 120) {
#line 587
    goto case_120;
  }
#line 587
  if ((127 & (int )((scm_cell *)ptr)->car) == 112) {
#line 587
    goto case_120;
  }
#line 587
  if ((127 & (int )((scm_cell *)ptr)->car) == 104) {
#line 587
    goto case_120;
  }
#line 587
  if ((127 & (int )((scm_cell *)ptr)->car) == 96) {
#line 587
    goto case_120;
  }
#line 587
  if ((127 & (int )((scm_cell *)ptr)->car) == 88) {
#line 587
    goto case_120;
  }
#line 587
  if ((127 & (int )((scm_cell *)ptr)->car) == 80) {
#line 587
    goto case_120;
  }
#line 587
  if ((127 & (int )((scm_cell *)ptr)->car) == 72) {
#line 587
    goto case_120;
  }
#line 587
  if ((127 & (int )((scm_cell *)ptr)->car) == 64) {
#line 587
    goto case_120;
  }
#line 587
  if ((127 & (int )((scm_cell *)ptr)->car) == 56) {
#line 587
    goto case_120;
  }
#line 587
  if ((127 & (int )((scm_cell *)ptr)->car) == 48) {
#line 587
    goto case_120;
  }
#line 587
  if ((127 & (int )((scm_cell *)ptr)->car) == 40) {
#line 587
    goto case_120;
  }
#line 587
  if ((127 & (int )((scm_cell *)ptr)->car) == 32) {
#line 587
    goto case_120;
  }
#line 587
  if ((127 & (int )((scm_cell *)ptr)->car) == 24) {
#line 587
    goto case_120;
  }
#line 587
  if ((127 & (int )((scm_cell *)ptr)->car) == 16) {
#line 587
    goto case_120;
  }
#line 587
  if ((127 & (int )((scm_cell *)ptr)->car) == 8) {
#line 587
    goto case_120;
  }
#line 587
  if ((127 & (int )((scm_cell *)ptr)->car) == 0) {
#line 587
    goto case_120;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 126) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 124) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 122) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 118) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 116) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 114) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 110) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 108) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 106) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 102) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 100) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 98) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 94) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 92) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 90) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 86) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 84) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 82) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 78) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 76) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 74) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 70) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 68) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 66) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 62) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 60) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 58) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 54) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 52) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 50) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 46) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 44) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 42) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 38) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 36) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 34) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 30) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 28) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 26) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 22) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 20) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 18) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 14) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 12) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 10) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 6) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 4) {
#line 599
    goto case_126;
  }
#line 599
  if ((127 & (int )((scm_cell *)ptr)->car) == 2) {
#line 599
    goto case_126;
  }
#line 605
  if ((127 & (int )((scm_cell *)ptr)->car) == 121) {
#line 605
    goto case_121;
  }
#line 605
  if ((127 & (int )((scm_cell *)ptr)->car) == 113) {
#line 605
    goto case_121;
  }
#line 605
  if ((127 & (int )((scm_cell *)ptr)->car) == 105) {
#line 605
    goto case_121;
  }
#line 605
  if ((127 & (int )((scm_cell *)ptr)->car) == 97) {
#line 605
    goto case_121;
  }
#line 605
  if ((127 & (int )((scm_cell *)ptr)->car) == 89) {
#line 605
    goto case_121;
  }
#line 605
  if ((127 & (int )((scm_cell *)ptr)->car) == 81) {
#line 605
    goto case_121;
  }
#line 605
  if ((127 & (int )((scm_cell *)ptr)->car) == 73) {
#line 605
    goto case_121;
  }
#line 605
  if ((127 & (int )((scm_cell *)ptr)->car) == 65) {
#line 605
    goto case_121;
  }
#line 605
  if ((127 & (int )((scm_cell *)ptr)->car) == 57) {
#line 605
    goto case_121;
  }
#line 605
  if ((127 & (int )((scm_cell *)ptr)->car) == 49) {
#line 605
    goto case_121;
  }
#line 605
  if ((127 & (int )((scm_cell *)ptr)->car) == 41) {
#line 605
    goto case_121;
  }
#line 605
  if ((127 & (int )((scm_cell *)ptr)->car) == 33) {
#line 605
    goto case_121;
  }
#line 605
  if ((127 & (int )((scm_cell *)ptr)->car) == 25) {
#line 605
    goto case_121;
  }
#line 605
  if ((127 & (int )((scm_cell *)ptr)->car) == 17) {
#line 605
    goto case_121;
  }
#line 605
  if ((127 & (int )((scm_cell *)ptr)->car) == 9) {
#line 605
    goto case_121;
  }
#line 605
  if ((127 & (int )((scm_cell *)ptr)->car) == 1) {
#line 605
    goto case_121;
  }
#line 660
  if ((127 & (int )((scm_cell *)ptr)->car) == 123) {
#line 660
    goto case_123;
  }
#line 660
  if ((127 & (int )((scm_cell *)ptr)->car) == 115) {
#line 660
    goto case_123;
  }
#line 660
  if ((127 & (int )((scm_cell *)ptr)->car) == 107) {
#line 660
    goto case_123;
  }
#line 660
  if ((127 & (int )((scm_cell *)ptr)->car) == 99) {
#line 660
    goto case_123;
  }
#line 660
  if ((127 & (int )((scm_cell *)ptr)->car) == 91) {
#line 660
    goto case_123;
  }
#line 660
  if ((127 & (int )((scm_cell *)ptr)->car) == 83) {
#line 660
    goto case_123;
  }
#line 660
  if ((127 & (int )((scm_cell *)ptr)->car) == 75) {
#line 660
    goto case_123;
  }
#line 660
  if ((127 & (int )((scm_cell *)ptr)->car) == 67) {
#line 660
    goto case_123;
  }
#line 660
  if ((127 & (int )((scm_cell *)ptr)->car) == 59) {
#line 660
    goto case_123;
  }
#line 660
  if ((127 & (int )((scm_cell *)ptr)->car) == 51) {
#line 660
    goto case_123;
  }
#line 660
  if ((127 & (int )((scm_cell *)ptr)->car) == 43) {
#line 660
    goto case_123;
  }
#line 660
  if ((127 & (int )((scm_cell *)ptr)->car) == 35) {
#line 660
    goto case_123;
  }
#line 660
  if ((127 & (int )((scm_cell *)ptr)->car) == 27) {
#line 660
    goto case_123;
  }
#line 660
  if ((127 & (int )((scm_cell *)ptr)->car) == 19) {
#line 660
    goto case_123;
  }
#line 660
  if ((127 & (int )((scm_cell *)ptr)->car) == 11) {
#line 660
    goto case_123;
  }
#line 660
  if ((127 & (int )((scm_cell *)ptr)->car) == 3) {
#line 660
    goto case_123;
  }
#line 675
  if ((127 & (int )((scm_cell *)ptr)->car) == 63) {
#line 675
    goto case_63;
  }
#line 675
  if ((127 & (int )((scm_cell *)ptr)->car) == 39) {
#line 675
    goto case_63;
  }
#line 675
  if ((127 & (int )((scm_cell *)ptr)->car) == 13) {
#line 675
    goto case_63;
  }
#line 688
  if ((127 & (int )((scm_cell *)ptr)->car) == 61) {
#line 688
    goto case_61;
  }
#line 711
  if ((127 & (int )((scm_cell *)ptr)->car) == 23) {
#line 711
    goto case_23;
  }
#line 711
  if ((127 & (int )((scm_cell *)ptr)->car) == 21) {
#line 711
    goto case_23;
  }
#line 711
  if ((127 & (int )((scm_cell *)ptr)->car) == 55) {
#line 711
    goto case_23;
  }
#line 711
  if ((127 & (int )((scm_cell *)ptr)->car) == 53) {
#line 711
    goto case_23;
  }
#line 711
  if ((127 & (int )((scm_cell *)ptr)->car) == 47) {
#line 711
    goto case_23;
  }
#line 711
  if ((127 & (int )((scm_cell *)ptr)->car) == 45) {
#line 711
    goto case_23;
  }
#line 711
  if ((127 & (int )((scm_cell *)ptr)->car) == 37) {
#line 711
    goto case_23;
  }
#line 711
  if ((127 & (int )((scm_cell *)ptr)->car) == 79) {
#line 711
    goto case_23;
  }
#line 711
  if ((127 & (int )((scm_cell *)ptr)->car) == 77) {
#line 711
    goto case_23;
  }
#line 711
  if ((127 & (int )((scm_cell *)ptr)->car) == 71) {
#line 711
    goto case_23;
  }
#line 716
  if ((127 & (int )((scm_cell *)ptr)->car) == 31) {
#line 716
    goto case_31;
  }
#line 716
  if ((127 & (int )((scm_cell *)ptr)->car) == 29) {
#line 716
    goto case_31;
  }
#line 723
  if ((127 & (int )((scm_cell *)ptr)->car) == 15) {
#line 723
    goto case_15;
  }
#line 802
  if ((127 & (int )((scm_cell *)ptr)->car) == 7) {
#line 802
    goto case_7;
  }
#line 809
  if ((127 & (int )((scm_cell *)ptr)->car) == 5) {
#line 809
    goto case_5;
  }
#line 814
  if ((127 & (int )((scm_cell *)ptr)->car) == 119) {
#line 814
    goto case_119;
  }
#line 814
  if ((127 & (int )((scm_cell *)ptr)->car) == 117) {
#line 814
    goto case_119;
  }
#line 814
  if ((127 & (int )((scm_cell *)ptr)->car) == 111) {
#line 814
    goto case_119;
  }
#line 814
  if ((127 & (int )((scm_cell *)ptr)->car) == 109) {
#line 814
    goto case_119;
  }
#line 814
  if ((127 & (int )((scm_cell *)ptr)->car) == 69) {
#line 814
    goto case_119;
  }
#line 814
  if ((127 & (int )((scm_cell *)ptr)->car) == 101) {
#line 814
    goto case_119;
  }
#line 814
  if ((127 & (int )((scm_cell *)ptr)->car) == 95) {
#line 814
    goto case_119;
  }
#line 814
  if ((127 & (int )((scm_cell *)ptr)->car) == 93) {
#line 814
    goto case_119;
  }
#line 814
  if ((127 & (int )((scm_cell *)ptr)->car) == 87) {
#line 814
    goto case_119;
  }
#line 814
  if ((127 & (int )((scm_cell *)ptr)->car) == 85) {
#line 814
    goto case_119;
  }
#line 814
  if ((127 & (int )((scm_cell *)ptr)->car) == 103) {
#line 814
    goto case_119;
  }
#line 817
  if ((127 & (int )((scm_cell *)ptr)->car) == 125) {
#line 817
    goto case_125;
  }
#line 828
  if ((127 & (int )((scm_cell *)ptr)->car) == 127) {
#line 828
    goto case_127;
  }
#line 850
  goto def;
  case_120: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_96: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_64: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_48: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_32: /* CIL Label */ 
  case_24: /* CIL Label */ 
  case_16: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 588
  if (1 & (int )((scm_cell *)ptr)->cdr) {
#line 589
    goto switch_break;
  }
#line 590
  ((scm_cell *)ptr)->cdr |= 1L;
#line 591
  if (6 & (int )((scm_cell *)ptr)->cdr) {
#line 593
    ptr = ((scm_cell *)ptr)->car;
#line 594
    goto gc_mark_nimp;
  }
  {
#line 596
  scm_gc_mark(((scm_cell *)ptr)->car);
#line 597
  ptr = -2L & ((scm_cell *)ptr)->cdr;
  }
#line 598
  goto gc_mark_nimp;
  case_126: /* CIL Label */ 
  case_124: /* CIL Label */ 
  case_122: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_94: /* CIL Label */ 
  case_92: /* CIL Label */ 
  case_90: /* CIL Label */ 
  case_86: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_82: /* CIL Label */ 
  case_78: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_62: /* CIL Label */ 
  case_60: /* CIL Label */ 
  case_58: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_46: /* CIL Label */ 
  case_44: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_38: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_34: /* CIL Label */ 
  case_30: /* CIL Label */ 
  case_28: /* CIL Label */ 
  case_26: /* CIL Label */ 
  case_22: /* CIL Label */ 
  case_20: /* CIL Label */ 
  case_18: /* CIL Label */ 
  case_14: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 600
  if (1 & (int )((scm_cell *)ptr)->cdr) {
#line 601
    goto switch_break;
  }
#line 602
  ((scm_cell *)ptr)->cdr |= 1L;
#line 603
  ptr = -2L & ((scm_cell *)ptr)->cdr;
#line 604
  goto gc_mark_loop;
  case_121: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_97: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_65: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_25: /* CIL Label */ 
  case_17: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 606
  if (1 & (int )((scm_cell *)ptr)->cdr) {
#line 607
    goto switch_break;
  }
#line 608
  ((scm_cell *)ptr)->cdr |= 1L;
#line 611
  vcell = ((scm_cell *)ptr)->car - 1L;
  {
#line 619
  if (((scm_cell *)vcell)->cdr == 0L) {
#line 619
    goto case_0___0;
  }
#line 619
  if (((scm_cell *)vcell)->cdr == 1L) {
#line 619
    goto case_0___0;
  }
#line 614
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 615
  scm_gc_mark(vcell);
#line 616
  ptr = -2L & ((scm_cell *)ptr)->cdr;
  }
#line 617
  goto gc_mark_loop;
  case_0___0: /* CIL Label */ 
  case_1___0: /* CIL Label */ 
#line 628
  vtable_data = (SCM *)vcell;
#line 629
  layout = *(vtable_data + 0);
#line 630
  len = (int )((unsigned long )((scm_cell *)layout)->car >> 8);
#line 631
  fields_desc = (char *)((scm_cell *)layout)->cdr;
#line 634
  mem = (SCM *)(-2L & ((scm_cell *)ptr)->cdr);
#line 636
  if (len) {
#line 638
    x = 0;
    {
#line 638
    while (1) {
      while_continue: /* CIL Label */ ;
#line 638
      if (! (x < len - 2)) {
#line 638
        goto while_break;
      }
#line 639
      if ((int )*(fields_desc + x) == 112) {
        {
#line 640
        scm_gc_mark(*mem);
        }
      }
#line 638
      x += 2;
#line 638
      mem ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 641
    if ((int )*(fields_desc + x) == 112) {
#line 643
      if (((int )*(fields_desc + (x + 1)) & 32) == 0) {
#line 644
        x = (int )*mem;
        {
#line 644
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 644
          if (! x) {
#line 644
            goto while_break___0;
          }
          {
#line 645
          mem ++;
#line 645
          scm_gc_mark(*mem);
#line 644
          x --;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
        {
#line 647
        scm_gc_mark(*mem);
        }
      }
    }
  }
#line 650
  if (! ((scm_cell *)vcell)->cdr) {
#line 652
    ((scm_cell *)vcell)->cdr |= 1L;
#line 653
    ptr = *(vtable_data + 2);
#line 654
    goto gc_mark_loop;
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 659
  goto switch_break;
  case_123: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_91: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_59: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_35: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_19: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 661
  if (1 & (int )((scm_cell *)ptr)->cdr) {
#line 662
    goto switch_break;
  }
#line 663
  ((scm_cell *)ptr)->cdr |= 1L;
#line 664
  if (6 & (int )((scm_cell *)ptr)->cdr) {
#line 666
    ptr = ((scm_cell *)ptr)->car - 3L;
#line 667
    goto gc_mark_nimp;
  }
  {
#line 669
  scm_gc_mark(((scm_cell *)ptr)->car - 3L);
#line 670
  ptr = -2L & ((scm_cell *)ptr)->cdr;
  }
#line 671
  goto gc_mark_nimp;
  case_63: /* CIL Label */ 
  case_39: /* CIL Label */ 
  case_13: /* CIL Label */ 
#line 677
  if (128 & (int )((scm_cell *)ptr)->car) {
#line 678
    goto switch_break;
  }
#line 679
  ((scm_cell *)ptr)->car |= 128L;
#line 680
  i = (long )((unsigned long )((scm_cell *)ptr)->car >> 8);
#line 681
  if (i == 0L) {
#line 682
    goto switch_break;
  }
  {
#line 683
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 683
    i --;
#line 683
    if (! (i > 0L)) {
#line 683
      goto while_break___1;
    }
#line 684
    if (! (6 & (int )*((SCM *)((scm_cell *)ptr)->cdr + i))) {
      {
#line 685
      scm_gc_mark(*((SCM *)((scm_cell *)ptr)->cdr + i));
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 686
  ptr = *((SCM *)((scm_cell *)ptr)->cdr + 0);
#line 687
  goto gc_mark_loop;
  case_61: /* CIL Label */ 
#line 689
  if (128 & (int )((scm_cell *)ptr)->car) {
#line 689
    goto switch_break;
  }
  {
#line 691
  ((scm_cell *)ptr)->car |= 128L;
#line 692
  scm_mark_locations((SCM *)((scm_cell *)ptr)->cdr, ((unsigned long )((scm_cell *)ptr)->car >> 8) + ((sizeof(SCM_STACKITEM ) + 0xffffffffffffffffUL) + sizeof(scm_contregs )) / sizeof(SCM_STACKITEM ));
  }
#line 697
  goto switch_break;
  case_23: /* CIL Label */ 
  case_21: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_71: /* CIL Label */ 
#line 712
  ((scm_cell *)ptr)->car |= 128L;
#line 713
  goto switch_break;
  case_31: /* CIL Label */ 
  case_29: /* CIL Label */ 
#line 717
  if (128 & (int )((scm_cell *)ptr)->car) {
#line 718
    goto switch_break;
  }
#line 719
  ((scm_cell *)ptr)->car |= 128L;
#line 720
  ptr = ((scm_cell *)ptr)->cdr;
#line 721
  goto gc_mark_loop;
  case_15: /* CIL Label */ 
#line 724
  if (128 & (int )((scm_cell *)ptr)->car) {
#line 725
    goto switch_break;
  }
#line 726
  tmp = scm_n_weak;
#line 726
  scm_n_weak ++;
#line 726
  *(scm_weak_vectors + tmp) = ptr;
#line 727
  if (scm_n_weak >= scm_weak_size) {
    {
#line 729
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 729
      tmp___0 = __errno_location();
#line 729
      *tmp___0 = 0;
#line 729
      scm_weak_size *= 2;
#line 729
      tmp___1 = realloc((void *)((char *)scm_weak_vectors), sizeof(SCM *) * (unsigned long )scm_weak_size);
#line 729
      scm_weak_vectors = (SCM *)tmp___1;
#line 729
      tmp___2 = __errno_location();
      }
#line 729
      if (! (4 == *tmp___2)) {
#line 729
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 732
    if ((unsigned long )scm_weak_vectors == (unsigned long )((void *)0)) {
      {
#line 734
      scm_gen_puts((enum scm_string_representation_type )0, (char *)"weak vector table",
                   scm_root->cur_errp);
#line 737
      scm_gen_puts((enum scm_string_representation_type )0, (char *)"\nFATAL ERROR DURING CRITICAL SCM_CODE SECTION\n",
                   scm_root->cur_errp);
#line 740
      exit(1);
      }
    }
  }
#line 743
  ((scm_cell *)ptr)->car |= 128L;
#line 744
  if (*((SCM *)((scm_cell *)ptr)->cdr + -1)) {
#line 751
    len___0 = (int )((unsigned long )((scm_cell *)ptr)->car >> 8);
#line 752
    if (*((SCM *)((scm_cell *)ptr)->cdr + -1) == 1L) {
#line 752
      tmp___3 = 1;
    } else
#line 752
    if (*((SCM *)((scm_cell *)ptr)->cdr + -1) == 3L) {
#line 752
      tmp___3 = 1;
    } else {
#line 752
      tmp___3 = 0;
    }
#line 752
    weak_keys = tmp___3;
#line 753
    if (*((SCM *)((scm_cell *)ptr)->cdr + -1) == 2L) {
#line 753
      tmp___4 = 1;
    } else
#line 753
    if (*((SCM *)((scm_cell *)ptr)->cdr + -1) == 3L) {
#line 753
      tmp___4 = 1;
    } else {
#line 753
      tmp___4 = 0;
    }
#line 753
    weak_values = tmp___4;
#line 755
    x___0 = 0;
    {
#line 755
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 755
      if (! (x___0 < len___0)) {
#line 755
        goto while_break___3;
      }
#line 758
      alist = *((SCM *)((scm_cell *)ptr)->cdr + x___0);
      {
#line 762
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 762
        if (! (6 & (int )alist)) {
#line 762
          if (! (1 & (int )((scm_cell *)alist)->car)) {
#line 762
            if (! (1 & (int )((scm_cell *)alist)->cdr)) {
#line 762
              if (! (6 & (int )((scm_cell *)alist)->car)) {
#line 762
                if (! (! (1 & (int )((scm_cell *)((scm_cell *)alist)->car)->car))) {
#line 762
                  goto while_break___4;
                }
              } else {
#line 762
                goto while_break___4;
              }
            } else {
#line 762
              goto while_break___4;
            }
          } else {
#line 762
            goto while_break___4;
          }
        } else {
#line 762
          goto while_break___4;
        }
#line 771
        kvpair = ((scm_cell *)alist)->car;
#line 772
        next_alist = ((scm_cell *)alist)->cdr;
#line 790
        if (! weak_keys) {
          {
#line 791
          scm_gc_mark(((scm_cell *)kvpair)->car);
          }
        }
#line 792
        if (! weak_values) {
          {
#line 793
          scm_gc_mark(-2L & ((scm_cell *)kvpair)->cdr);
          }
        }
#line 794
        alist = next_alist;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 796
      if (! (6 & (int )alist)) {
        {
#line 797
        scm_gc_mark(alist);
        }
      }
#line 755
      x___0 ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 800
  goto switch_break;
  case_7: /* CIL Label */ 
#line 803
  if (128 & (int )((scm_cell *)ptr)->car) {
#line 804
    goto switch_break;
  }
  {
#line 805
  ((scm_cell *)ptr)->car |= 128L;
#line 806
  scm_gc_mark(*((SCM *)*((SCM *)((char *)((scm_cell *)ptr)->cdr) - 1) + 0));
#line 807
  ptr = *((SCM *)*((SCM *)((char *)((scm_cell *)ptr)->cdr) - 1) + 1);
  }
#line 808
  goto gc_mark_loop;
  case_5: /* CIL Label */ 
#line 810
  if (128 & (int )((scm_cell *)ptr)->car) {
#line 811
    goto switch_break;
  }
#line 812
  ((scm_cell *)ptr)->car |= 128L;
#line 813
  goto switch_break;
  case_119: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_95: /* CIL Label */ 
  case_93: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_103: /* CIL Label */ 
#line 815
  ptr = (SCM )(scm_heap_org + ((unsigned long )((scm_cell *)ptr)->car >> 8));
#line 816
  goto gc_mark_loop;
  case_125: /* CIL Label */ 
#line 818
  i = 255L & (((scm_cell *)ptr)->car >> 8);
#line 819
  if (! ((size_t )i < scm_numptob)) {
#line 820
    goto def;
  }
#line 821
  if (128 & (int )((scm_cell *)ptr)->car) {
#line 822
    goto switch_break;
  }
#line 823
  if ((struct scm_port_table *)((scm_cell *)ptr)->cdr) {
    {
#line 824
    scm_gc_mark(((struct scm_port_table *)((scm_cell *)ptr)->cdr)->file_name);
    }
  }
  {
#line 825
  ptr = (*((scm_ptobs + i)->mark))(ptr);
  }
#line 826
  goto gc_mark_loop;
#line 827
  goto switch_break;
  case_127: /* CIL Label */ 
#line 829
  if (128 & (int )((scm_cell *)ptr)->car) {
#line 830
    goto switch_break;
  }
  {
#line 833
  if ((65535 & (int )((scm_cell *)ptr)->car) == 127) {
#line 833
    goto case_127___0;
  }
#line 839
  if ((65535 & (int )((scm_cell *)ptr)->car) == 383) {
#line 839
    goto case_383;
  }
#line 839
  if ((65535 & (int )((scm_cell *)ptr)->car) == 895) {
#line 839
    goto case_383;
  }
#line 839
  if ((65535 & (int )((scm_cell *)ptr)->car) == 639) {
#line 839
    goto case_383;
  }
#line 842
  goto switch_default___0;
  case_127___0: /* CIL Label */ 
#line 835
  ((scm_cell *)ptr)->car |= 128L;
#line 836
  ((scm_cell *)ptr)->cdr = (long )(20 << 9) + 372L;
#line 837
  goto switch_break___1;
  case_383: /* CIL Label */ 
  case_895: /* CIL Label */ 
  case_639: /* CIL Label */ 
#line 840
  ((scm_cell *)ptr)->car |= 128L;
#line 841
  goto switch_break___1;
  switch_default___0: /* CIL Label */ 
#line 843
  i = 255L & (((scm_cell *)ptr)->car >> 8);
#line 844
  if (! ((size_t )i < scm_numsmob)) {
#line 845
    goto def;
  }
  {
#line 846
  ptr = (*((scm_smobs + i)->mark))(ptr);
  }
#line 847
  goto gc_mark_loop;
  switch_break___1: /* CIL Label */ ;
  }
#line 849
  goto switch_break;
  def: 
  switch_default___1: /* CIL Label */ 
  {
#line 851
  scm_wta(ptr, (char *)"unknown type in ", (char *)"gc_mark");
  }
  switch_break: /* CIL Label */ ;
  }
#line 853
  return;
}
}
#line 859 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
void scm_mark_locations(SCM_STACKITEM *x , size_t n ) 
{ 
  register long m ;
  register int i ;
  register int j ;
  register SCM_CELLPTR ptr ;
  int seg_id ;
  int k ;
  int tmp ;

  {
#line 864
  m = (long )n;
  {
#line 868
  while (1) {
    while_continue: /* CIL Label */ ;
#line 868
    m --;
#line 868
    if (! (0L <= m)) {
#line 868
      goto while_break;
    }
#line 869
    if (! ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )*((SCM **)(x + m))))) {
#line 871
      ptr = (SCM_CELLPTR )*((SCM **)(x + m));
#line 872
      i = 0;
#line 873
      j = scm_n_heap_segs - 1;
#line 874
      if (! ((unsigned long )ptr < (unsigned long )(scm_heap_table + i)->bounds[0])) {
#line 874
        if ((unsigned long )ptr < (unsigned long )(scm_heap_table + j)->bounds[1]) {
          {
#line 877
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 877
            if (! (i <= j)) {
#line 877
              goto while_break___0;
            }
#line 880
            seg_id = -1;
#line 881
            if (i == j) {
#line 883
              seg_id = i;
            } else
#line 881
            if ((unsigned long )ptr < (unsigned long )(scm_heap_table + i)->bounds[1]) {
#line 883
              seg_id = i;
            } else
#line 884
            if (! ((unsigned long )ptr < (unsigned long )(scm_heap_table + j)->bounds[0])) {
#line 885
              seg_id = j;
            } else {
#line 889
              k = (i + j) / 2;
#line 890
              if (k == i) {
#line 891
                goto while_break___0;
              }
#line 892
              if ((unsigned long )ptr < (unsigned long )(scm_heap_table + k)->bounds[1]) {
#line 894
                j = k;
#line 895
                i ++;
#line 896
                if (! ((unsigned long )ptr < (unsigned long )(scm_heap_table + i)->bounds[0])) {
#line 897
                  goto while_continue___0;
                } else {
#line 899
                  goto while_break___0;
                }
              } else
#line 901
              if (! ((unsigned long )ptr < (unsigned long )(scm_heap_table + k)->bounds[0])) {
#line 903
                i = k;
#line 904
                j --;
#line 905
                if ((unsigned long )ptr < (unsigned long )(scm_heap_table + j)->bounds[1]) {
#line 906
                  goto while_continue___0;
                } else {
#line 908
                  goto while_break___0;
                }
              }
            }
#line 911
            if (! (scm_heap_table + seg_id)->valid) {
              {
#line 914
              scm_gc_mark(*(x + m));
              }
            } else {
              {
#line 911
              tmp = (*((scm_heap_table + seg_id)->valid))(ptr, scm_heap_table + seg_id);
              }
#line 911
              if (tmp) {
                {
#line 914
                scm_gc_mark(*(x + m));
                }
              }
            }
#line 915
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 920
  return;
}
}
#line 928 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
int scm_cellp(SCM value ) 
{ 
  register int i ;
  register int j ;
  register SCM_CELLPTR ptr ;
  int seg_id ;
  int k ;
  int tmp ;

  {
#line 935
  if (! ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )*((SCM **)(& value))))) {
#line 937
    ptr = (SCM_CELLPTR )*((SCM **)(& value));
#line 938
    i = 0;
#line 939
    j = scm_n_heap_segs - 1;
#line 940
    if (! ((unsigned long )ptr < (unsigned long )(scm_heap_table + i)->bounds[0])) {
#line 940
      if ((unsigned long )ptr < (unsigned long )(scm_heap_table + j)->bounds[1]) {
        {
#line 943
        while (1) {
          while_continue: /* CIL Label */ ;
#line 943
          if (! (i <= j)) {
#line 943
            goto while_break;
          }
#line 946
          seg_id = -1;
#line 947
          if (i == j) {
#line 949
            seg_id = i;
          } else
#line 947
          if ((unsigned long )ptr < (unsigned long )(scm_heap_table + i)->bounds[1]) {
#line 949
            seg_id = i;
          } else
#line 950
          if (! ((unsigned long )ptr < (unsigned long )(scm_heap_table + j)->bounds[0])) {
#line 951
            seg_id = j;
          } else {
#line 955
            k = (i + j) / 2;
#line 956
            if (k == i) {
#line 957
              goto while_break;
            }
#line 958
            if ((unsigned long )ptr < (unsigned long )(scm_heap_table + k)->bounds[1]) {
#line 960
              j = k;
#line 961
              i ++;
#line 962
              if (! ((unsigned long )ptr < (unsigned long )(scm_heap_table + i)->bounds[0])) {
#line 963
                goto while_continue;
              } else {
#line 965
                goto while_break;
              }
            } else
#line 967
            if (! ((unsigned long )ptr < (unsigned long )(scm_heap_table + k)->bounds[0])) {
#line 969
              i = k;
#line 970
              j --;
#line 971
              if ((unsigned long )ptr < (unsigned long )(scm_heap_table + j)->bounds[1]) {
#line 972
                goto while_continue;
              } else {
#line 974
                goto while_break;
              }
            }
          }
#line 977
          if (! (scm_heap_table + seg_id)->valid) {
#line 980
            return (1);
          } else {
            {
#line 977
            tmp = (*((scm_heap_table + seg_id)->valid))(ptr, scm_heap_table + seg_id);
            }
#line 977
            if (tmp) {
#line 980
              return (1);
            }
          }
#line 981
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 986
  return (0);
}
}
#line 990 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
static void scm_mark_weak_vector_spines(void) 
{ 
  int i ;
  SCM *ptr ;
  SCM obj ;
  int j ;
  int n ;
  SCM alist ;

  {
#line 995
  i = 0;
  {
#line 995
  while (1) {
    while_continue: /* CIL Label */ ;
#line 995
    if (! (i < scm_n_weak)) {
#line 995
      goto while_break;
    }
#line 997
    if (*((SCM *)((scm_cell *)*(scm_weak_vectors + i))->cdr + -1)) {
#line 1004
      obj = *(scm_weak_vectors + i);
#line 1005
      ptr = (SCM *)((scm_cell *)*(scm_weak_vectors + i))->cdr;
#line 1006
      n = (int )((unsigned long )((scm_cell *)*(scm_weak_vectors + i))->car >> 8);
#line 1007
      j = 0;
      {
#line 1007
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1007
        if (! (j < n)) {
#line 1007
          goto while_break___0;
        }
#line 1011
        alist = *(ptr + j);
        {
#line 1012
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1012
          if (! (6 & (int )alist)) {
#line 1012
            if (! (1 & (int )((scm_cell *)alist)->car)) {
#line 1012
              if (! (1 & (int )((scm_cell *)alist)->cdr)) {
#line 1012
                if (! (6 & (int )((scm_cell *)alist)->car)) {
#line 1012
                  if (! (! (1 & (int )((scm_cell *)((scm_cell *)alist)->car)->car))) {
#line 1012
                    goto while_break___1;
                  }
                } else {
#line 1012
                  goto while_break___1;
                }
              } else {
#line 1012
                goto while_break___1;
              }
            } else {
#line 1012
              goto while_break___1;
            }
          } else {
#line 1012
            goto while_break___1;
          }
#line 1018
          ((scm_cell *)alist)->cdr |= 1L;
#line 1019
          ((scm_cell *)((scm_cell *)alist)->car)->cdr |= 1L;
#line 1020
          alist = -2L & ((scm_cell *)alist)->cdr;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1007
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 995
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1025
  return;
}
}
#line 1029 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
void scm_gc_sweep(void) 
{ 
  register SCM_CELLPTR ptr ;
  register SCM nfreelist ;
  register SCM *hp_freelist ;
  register long n ;
  register long m ;
  register size_t j ;
  register int span ;
  size_t i ;
  size_t seg_size ;
  SCM vcell ;
  SCM *p ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  int k ;
  int tmp___7 ;
  int k___0 ;
  size_t tmp___8 ;
  SCM *ptr___0 ;
  SCM obj ;
  SCM *fixup ;
  SCM alist ;
  int weak_keys ;
  int weak_values ;
  int tmp___9 ;
  int tmp___10 ;
  SCM key ;
  SCM value ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
#line 1048
  n = 0L;
#line 1049
  m = 0L;
#line 1053
  i = (size_t )0;
  {
#line 1053
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1053
    if (! (i < (size_t )scm_n_heap_segs)) {
#line 1053
      goto while_break;
    }
#line 1054
    *((scm_heap_table + i)->freelistp) = (long )(20 << 9) + 372L;
#line 1053
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1056
  i = (size_t )0;
  {
#line 1056
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1056
    if (! (i < (size_t )scm_n_heap_segs)) {
#line 1056
      goto while_break___0;
    }
#line 1064
    hp_freelist = (scm_heap_table + i)->freelistp;
#line 1065
    nfreelist = *hp_freelist;
#line 1067
    span = (scm_heap_table + i)->ncells;
#line 1068
    ptr = (SCM_CELLPTR )(~ (sizeof(scm_cell ) - 1UL) & (((unsigned long )((long )(scm_heap_table + i)->bounds[0]) + sizeof(scm_cell )) - 1UL));
#line 1069
    seg_size = (size_t )((SCM_CELLPTR )(~ (sizeof(scm_cell ) - 1UL) & (unsigned long )((long )(scm_heap_table + i)->bounds[1])) - ptr);
#line 1070
    j = seg_size + (size_t )span;
    {
#line 1070
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1070
      j -= (size_t )span;
#line 1070
      if (! j) {
#line 1070
        goto while_break___1;
      }
      {
#line 1077
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 121) {
#line 1077
        goto case_121;
      }
#line 1077
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 113) {
#line 1077
        goto case_121;
      }
#line 1077
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 105) {
#line 1077
        goto case_121;
      }
#line 1077
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 97) {
#line 1077
        goto case_121;
      }
#line 1077
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 89) {
#line 1077
        goto case_121;
      }
#line 1077
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 81) {
#line 1077
        goto case_121;
      }
#line 1077
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 73) {
#line 1077
        goto case_121;
      }
#line 1077
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 65) {
#line 1077
        goto case_121;
      }
#line 1077
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 57) {
#line 1077
        goto case_121;
      }
#line 1077
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 49) {
#line 1077
        goto case_121;
      }
#line 1077
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 41) {
#line 1077
        goto case_121;
      }
#line 1077
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 33) {
#line 1077
        goto case_121;
      }
#line 1077
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 25) {
#line 1077
        goto case_121;
      }
#line 1077
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 17) {
#line 1077
        goto case_121;
      }
#line 1077
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 9) {
#line 1077
        goto case_121;
      }
#line 1077
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 1) {
#line 1077
        goto case_121;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 123) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 115) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 107) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 99) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 91) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 83) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 75) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 67) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 59) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 51) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 43) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 35) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 27) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 19) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 11) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 3) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 120) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 112) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 104) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 96) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 88) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 80) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 72) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 64) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 56) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 48) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 40) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 32) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 24) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 16) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 8) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 0) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 126) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 124) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 122) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 118) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 116) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 114) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 110) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 108) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 106) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 102) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 100) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 98) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 94) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 92) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 90) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 86) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 84) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 82) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 78) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 76) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 74) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 70) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 68) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 66) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 62) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 60) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 58) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 54) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 52) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 50) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 46) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 44) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 42) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 38) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 36) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 34) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 30) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 28) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 26) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 22) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 20) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 18) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 14) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 12) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 10) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 6) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 4) {
#line 1099
        goto case_123;
      }
#line 1099
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 2) {
#line 1099
        goto case_123;
      }
#line 1103
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 15) {
#line 1103
        goto case_15;
      }
#line 1118
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 63) {
#line 1118
        goto case_63;
      }
#line 1118
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 39) {
#line 1118
        goto case_63;
      }
#line 1118
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 13) {
#line 1118
        goto case_63;
      }
#line 1128
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 71) {
#line 1128
        goto case_71;
      }
#line 1133
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 77) {
#line 1133
        goto case_77;
      }
#line 1139
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 37) {
#line 1139
        goto case_37;
      }
#line 1139
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 79) {
#line 1139
        goto case_37;
      }
#line 1144
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 55) {
#line 1144
        goto case_55;
      }
#line 1156
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 45) {
#line 1156
        goto case_45;
      }
#line 1161
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 47) {
#line 1161
        goto case_47;
      }
#line 1166
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 53) {
#line 1166
        goto case_53;
      }
#line 1172
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 31) {
#line 1172
        goto case_31;
      }
#line 1172
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 29) {
#line 1172
        goto case_31;
      }
#line 1177
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 23) {
#line 1177
        goto case_23;
      }
#line 1177
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 21) {
#line 1177
        goto case_23;
      }
#line 1182
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 7) {
#line 1182
        goto case_7;
      }
#line 1190
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 61) {
#line 1190
        goto case_61;
      }
#line 1195
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 5) {
#line 1195
        goto case_5;
      }
#line 1199
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 119) {
#line 1199
        goto case_119;
      }
#line 1199
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 117) {
#line 1199
        goto case_119;
      }
#line 1199
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 111) {
#line 1199
        goto case_119;
      }
#line 1199
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 109) {
#line 1199
        goto case_119;
      }
#line 1199
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 69) {
#line 1199
        goto case_119;
      }
#line 1199
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 101) {
#line 1199
        goto case_119;
      }
#line 1199
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 95) {
#line 1199
        goto case_119;
      }
#line 1199
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 93) {
#line 1199
        goto case_119;
      }
#line 1199
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 87) {
#line 1199
        goto case_119;
      }
#line 1199
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 85) {
#line 1199
        goto case_119;
      }
#line 1199
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 103) {
#line 1199
        goto case_119;
      }
#line 1201
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 125) {
#line 1201
        goto case_125;
      }
#line 1222
      if ((127 & (int )((scm_cell *)((SCM )ptr))->car) == 127) {
#line 1222
        goto case_127;
      }
#line 1267
      goto sweeperr;
      case_121: /* CIL Label */ 
      case_113: /* CIL Label */ 
      case_105: /* CIL Label */ 
      case_97: /* CIL Label */ 
      case_89: /* CIL Label */ 
      case_81: /* CIL Label */ 
      case_73: /* CIL Label */ 
      case_65: /* CIL Label */ 
      case_57: /* CIL Label */ 
      case_49: /* CIL Label */ 
      case_41: /* CIL Label */ 
      case_33: /* CIL Label */ 
      case_25: /* CIL Label */ 
      case_17: /* CIL Label */ 
      case_9: /* CIL Label */ 
      case_1: /* CIL Label */ 
#line 1078
      if (1 & (int )((scm_cell *)((SCM )ptr))->cdr) {
#line 1080
        if (((scm_cell *)(((scm_cell *)((SCM )ptr))->car - 1L))->cdr == 1L) {
#line 1081
          ((scm_cell *)(((scm_cell *)((SCM )ptr))->car - 1L))->cdr = (SCM )0;
        }
#line 1082
        goto cmrkcontinue;
      }
#line 1086
      vcell = ((scm_cell *)((SCM )ptr))->car - 1L;
#line 1088
      if (((scm_cell *)vcell)->cdr == 0L) {
        {
#line 1090
        p = (SCM *)(-2L & ((scm_cell *)((SCM )ptr))->cdr);
#line 1091
        m = (long )((unsigned long )m + (unsigned long )*(p + -2) * sizeof(SCM ));
#line 1093
        free((void *)((char *)*(p + -3)));
        }
      } else
#line 1088
      if (((scm_cell *)vcell)->cdr == 1L) {
        {
#line 1090
        p = (SCM *)(-2L & ((scm_cell *)((SCM )ptr))->cdr);
#line 1091
        m = (long )((unsigned long )m + (unsigned long )*(p + -2) * sizeof(SCM ));
#line 1093
        free((void *)((char *)*(p + -3)));
        }
      }
#line 1096
      goto switch_break;
      case_123: /* CIL Label */ 
      case_115: /* CIL Label */ 
      case_107: /* CIL Label */ 
      case_99: /* CIL Label */ 
      case_91: /* CIL Label */ 
      case_83: /* CIL Label */ 
      case_75: /* CIL Label */ 
      case_67: /* CIL Label */ 
      case_59: /* CIL Label */ 
      case_51: /* CIL Label */ 
      case_43: /* CIL Label */ 
      case_35: /* CIL Label */ 
      case_27: /* CIL Label */ 
      case_19: /* CIL Label */ 
      case_11: /* CIL Label */ 
      case_3: /* CIL Label */ 
      case_120: /* CIL Label */ 
      case_112: /* CIL Label */ 
      case_104: /* CIL Label */ 
      case_96: /* CIL Label */ 
      case_88: /* CIL Label */ 
      case_80: /* CIL Label */ 
      case_72: /* CIL Label */ 
      case_64: /* CIL Label */ 
      case_56: /* CIL Label */ 
      case_48: /* CIL Label */ 
      case_40: /* CIL Label */ 
      case_32: /* CIL Label */ 
      case_24: /* CIL Label */ 
      case_16: /* CIL Label */ 
      case_8: /* CIL Label */ 
      case_0: /* CIL Label */ 
      case_126: /* CIL Label */ 
      case_124: /* CIL Label */ 
      case_122: /* CIL Label */ 
      case_118: /* CIL Label */ 
      case_116: /* CIL Label */ 
      case_114: /* CIL Label */ 
      case_110: /* CIL Label */ 
      case_108: /* CIL Label */ 
      case_106: /* CIL Label */ 
      case_102: /* CIL Label */ 
      case_100: /* CIL Label */ 
      case_98: /* CIL Label */ 
      case_94: /* CIL Label */ 
      case_92: /* CIL Label */ 
      case_90: /* CIL Label */ 
      case_86: /* CIL Label */ 
      case_84: /* CIL Label */ 
      case_82: /* CIL Label */ 
      case_78: /* CIL Label */ 
      case_76: /* CIL Label */ 
      case_74: /* CIL Label */ 
      case_70: /* CIL Label */ 
      case_68: /* CIL Label */ 
      case_66: /* CIL Label */ 
      case_62: /* CIL Label */ 
      case_60: /* CIL Label */ 
      case_58: /* CIL Label */ 
      case_54: /* CIL Label */ 
      case_52: /* CIL Label */ 
      case_50: /* CIL Label */ 
      case_46: /* CIL Label */ 
      case_44: /* CIL Label */ 
      case_42: /* CIL Label */ 
      case_38: /* CIL Label */ 
      case_36: /* CIL Label */ 
      case_34: /* CIL Label */ 
      case_30: /* CIL Label */ 
      case_28: /* CIL Label */ 
      case_26: /* CIL Label */ 
      case_22: /* CIL Label */ 
      case_20: /* CIL Label */ 
      case_18: /* CIL Label */ 
      case_14: /* CIL Label */ 
      case_12: /* CIL Label */ 
      case_10: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_4: /* CIL Label */ 
      case_2: /* CIL Label */ 
#line 1100
      if (1 & (int )((scm_cell *)((SCM )ptr))->cdr) {
#line 1101
        goto cmrkcontinue;
      }
#line 1102
      goto switch_break;
      case_15: /* CIL Label */ 
#line 1104
      if (128 & (int )((scm_cell *)((SCM )ptr))->car) {
#line 1106
        goto c8mrkcontinue;
      } else {
        {
#line 1110
        m = (long )((unsigned long )m + (1UL + ((unsigned long )((scm_cell *)((SCM )ptr))->car >> 8)) * sizeof(SCM ));
#line 1111
        scm_must_free((char *)((SCM *)((scm_cell *)((SCM )ptr))->cdr - 1));
        }
#line 1112
        goto switch_break;
      }
      case_63: /* CIL Label */ 
      case_39: /* CIL Label */ 
      case_13: /* CIL Label */ 
#line 1120
      if (128 & (int )((scm_cell *)((SCM )ptr))->car) {
#line 1121
        goto c8mrkcontinue;
      }
#line 1123
      m = (long )((unsigned long )m + ((unsigned long )((scm_cell *)((SCM )ptr))->car >> 8) * sizeof(SCM ));
      freechars: 
      {
#line 1125
      scm_must_free((char *)((scm_cell *)((SCM )ptr))->cdr);
      }
#line 1127
      goto switch_break;
      case_71: /* CIL Label */ 
#line 1129
      if (128 & (int )((scm_cell *)((SCM )ptr))->car) {
#line 1130
        goto c8mrkcontinue;
      }
#line 1131
      if (16777215UL == (unsigned long )((scm_cell *)((SCM )ptr))->car >> 8) {
#line 1131
        tmp = (unsigned long )*((SCM *)((scm_cell *)((SCM )ptr))->cdr);
      } else {
#line 1131
        tmp = (unsigned long )((scm_cell *)((SCM )ptr))->car >> 8;
      }
#line 1131
      m = (long )((unsigned long )m + sizeof(long ) * (((tmp + (8UL * sizeof(long )) / sizeof(char )) - 1UL) / ((8UL * sizeof(long )) / sizeof(char ))));
#line 1132
      goto freechars;
      case_77: /* CIL Label */ 
#line 1134
      if (128 & (int )((scm_cell *)((SCM )ptr))->car) {
#line 1135
        goto c8mrkcontinue;
      }
#line 1136
      if (16777215UL == (unsigned long )((scm_cell *)((SCM )ptr))->car >> 8) {
#line 1136
        tmp___0 = (unsigned long )*((SCM *)((scm_cell *)((SCM )ptr))->cdr);
      } else {
#line 1136
        tmp___0 = (unsigned long )((scm_cell *)((SCM )ptr))->car >> 8;
      }
#line 1136
      m = (long )((unsigned long )m + tmp___0 * sizeof(char ));
#line 1137
      goto freechars;
      case_37: /* CIL Label */ 
      case_79: /* CIL Label */ 
#line 1140
      if (128 & (int )((scm_cell *)((SCM )ptr))->car) {
#line 1141
        goto c8mrkcontinue;
      }
#line 1142
      if (16777215UL == (unsigned long )((scm_cell *)((SCM )ptr))->car >> 8) {
#line 1142
        tmp___1 = (unsigned long )*((SCM *)((scm_cell *)((SCM )ptr))->cdr);
      } else {
#line 1142
        tmp___1 = (unsigned long )((scm_cell *)((SCM )ptr))->car >> 8;
      }
#line 1142
      m = (long )((unsigned long )m + tmp___1 * sizeof(long ));
#line 1143
      goto freechars;
      case_55: /* CIL Label */ 
#line 1145
      if (128 & (int )((scm_cell *)((SCM )ptr))->car) {
#line 1146
        goto c8mrkcontinue;
      }
#line 1147
      if (16777215UL == (unsigned long )((scm_cell *)((SCM )ptr))->car >> 8) {
#line 1147
        tmp___2 = (unsigned long )*((SCM *)((scm_cell *)((SCM )ptr))->cdr);
      } else {
#line 1147
        tmp___2 = (unsigned long )((scm_cell *)((SCM )ptr))->car >> 8;
      }
#line 1147
      m = (long )((unsigned long )m + tmp___2 * sizeof(short ));
#line 1148
      goto freechars;
      case_45: /* CIL Label */ 
#line 1157
      if (128 & (int )((scm_cell *)((SCM )ptr))->car) {
#line 1158
        goto c8mrkcontinue;
      }
#line 1159
      if (16777215UL == (unsigned long )((scm_cell *)((SCM )ptr))->car >> 8) {
#line 1159
        tmp___3 = (unsigned long )*((SCM *)((scm_cell *)((SCM )ptr))->cdr);
      } else {
#line 1159
        tmp___3 = (unsigned long )((scm_cell *)((SCM )ptr))->car >> 8;
      }
#line 1159
      m = (long )((unsigned long )m + tmp___3 * sizeof(float ));
#line 1160
      goto freechars;
      case_47: /* CIL Label */ 
#line 1162
      if (128 & (int )((scm_cell *)((SCM )ptr))->car) {
#line 1163
        goto c8mrkcontinue;
      }
#line 1164
      if (16777215UL == (unsigned long )((scm_cell *)((SCM )ptr))->car >> 8) {
#line 1164
        tmp___4 = (unsigned long )*((SCM *)((scm_cell *)((SCM )ptr))->cdr);
      } else {
#line 1164
        tmp___4 = (unsigned long )((scm_cell *)((SCM )ptr))->car >> 8;
      }
#line 1164
      m = (long )((unsigned long )m + tmp___4 * sizeof(double ));
#line 1165
      goto freechars;
      case_53: /* CIL Label */ 
#line 1167
      if (128 & (int )((scm_cell *)((SCM )ptr))->car) {
#line 1168
        goto c8mrkcontinue;
      }
#line 1169
      if (16777215UL == (unsigned long )((scm_cell *)((SCM )ptr))->car >> 8) {
#line 1169
        tmp___5 = (unsigned long )*((SCM *)((scm_cell *)((SCM )ptr))->cdr);
      } else {
#line 1169
        tmp___5 = (unsigned long )((scm_cell *)((SCM )ptr))->car >> 8;
      }
#line 1169
      m = (long )((unsigned long )m + (tmp___5 * 2UL) * sizeof(double ));
#line 1170
      goto freechars;
      case_31: /* CIL Label */ 
      case_29: /* CIL Label */ 
#line 1173
      if (128 & (int )((scm_cell *)((SCM )ptr))->car) {
#line 1174
        goto c8mrkcontinue;
      }
#line 1175
      goto switch_break;
      case_23: /* CIL Label */ 
      case_21: /* CIL Label */ 
#line 1178
      if (128 & (int )((scm_cell *)((SCM )ptr))->car) {
#line 1179
        goto c8mrkcontinue;
      }
#line 1180
      if (16777215UL == (unsigned long )((scm_cell *)((SCM )ptr))->car >> 8) {
#line 1180
        tmp___6 = (unsigned long )*((SCM *)((scm_cell *)((SCM )ptr))->cdr);
      } else {
#line 1180
        tmp___6 = (unsigned long )((scm_cell *)((SCM )ptr))->car >> 8;
      }
#line 1180
      m = (long )((unsigned long )m + (tmp___6 + 1UL));
#line 1181
      goto freechars;
      case_7: /* CIL Label */ 
#line 1183
      if (128 & (int )((scm_cell *)((SCM )ptr))->car) {
#line 1184
        goto c8mrkcontinue;
      }
      {
#line 1185
      m = (long )((unsigned long )m + ((((unsigned long )((scm_cell *)((SCM )ptr))->car >> 8) + 1UL) + sizeof(SCM ) * (unsigned long )((SCM *)((char *)((scm_cell *)((SCM )ptr))->cdr) - (SCM *)*((SCM *)((char *)((scm_cell *)((SCM )ptr))->cdr) - 1))));
#line 1188
      scm_must_free((char *)((SCM *)*((SCM *)((char *)((scm_cell *)((SCM )ptr))->cdr) - 1)));
      }
#line 1189
      goto switch_break;
      case_61: /* CIL Label */ 
#line 1191
      if (128 & (int )((scm_cell *)((SCM )ptr))->car) {
#line 1192
        goto c8mrkcontinue;
      }
#line 1193
      m = (long )((unsigned long )m + (((unsigned long )((scm_cell *)((SCM )ptr))->car >> 8) * sizeof(SCM_STACKITEM ) + sizeof(scm_contregs )));
#line 1194
      goto freechars;
      case_5: /* CIL Label */ 
#line 1196
      if (128 & (int )((scm_cell *)((SCM )ptr))->car) {
#line 1197
        goto c8mrkcontinue;
      }
#line 1198
      goto switch_break;
      case_119: /* CIL Label */ 
      case_117: /* CIL Label */ 
      case_111: /* CIL Label */ 
      case_109: /* CIL Label */ 
      case_69: /* CIL Label */ 
      case_101: /* CIL Label */ 
      case_95: /* CIL Label */ 
      case_93: /* CIL Label */ 
      case_87: /* CIL Label */ 
      case_85: /* CIL Label */ 
      case_103: /* CIL Label */ 
#line 1200
      goto __Cont;
      case_125: /* CIL Label */ 
#line 1202
      if (128 & (int )((scm_cell *)((SCM )ptr))->car) {
#line 1203
        goto c8mrkcontinue;
      }
#line 1204
      if ((1L << 16) & ((scm_cell *)((SCM )ptr))->car) {
#line 1206
        k = (int )(255L & (((scm_cell *)((SCM )ptr))->car >> 8));
#line 1207
        if (! ((size_t )k < scm_numptob)) {
#line 1208
          goto sweeperr;
        }
        {
#line 1210
        tmp___7 = scm_revealed_count((SCM )ptr);
        }
#line 1210
        if (tmp___7 > 0) {
#line 1211
          goto __Cont;
        }
        {
#line 1215
        (*((scm_ptobs + k)->free))(((struct scm_port_table *)((scm_cell *)((SCM )ptr))->cdr)->stream);
#line 1216
        ((struct scm_port_table *)((scm_cell *)((SCM )ptr))->cdr)->stream = (SCM )0;
#line 1217
        scm_remove_from_port_table((SCM )ptr);
#line 1218
        scm_gc_ports_collected ++;
#line 1219
        ((scm_cell *)((SCM )ptr))->car &= ~ (1L << 16);
        }
      }
#line 1221
      goto switch_break;
      case_127: /* CIL Label */ 
      {
#line 1225
      if ((65407 & (int )((scm_cell *)((SCM )ptr))->car) == 127) {
#line 1225
        goto case_127___0;
      }
#line 1230
      if ((65407 & (int )((scm_cell *)((SCM )ptr))->car) == 895) {
#line 1230
        goto case_895;
      }
#line 1230
      if ((65407 & (int )((scm_cell *)((SCM )ptr))->car) == 639) {
#line 1230
        goto case_895;
      }
#line 1236
      if ((65407 & (int )((scm_cell *)((SCM )ptr))->car) == 383) {
#line 1236
        goto case_383;
      }
#line 1253
      goto switch_default___0;
      case_127___0: /* CIL Label */ 
#line 1226
      if (128 & (int )((scm_cell *)((SCM )ptr))->car) {
#line 1227
        goto c8mrkcontinue;
      }
#line 1228
      goto switch_break___0;
      case_895: /* CIL Label */ 
      case_639: /* CIL Label */ 
#line 1231
      if (128 & (int )((scm_cell *)((SCM )ptr))->car) {
#line 1232
        goto c8mrkcontinue;
      }
#line 1233
      m = (long )((size_t )m + ((size_t )(((scm_cell *)((SCM )ptr))->car >> 16) * (sizeof(unsigned short ) * 8UL)) / 8UL);
#line 1234
      goto freechars;
      case_383: /* CIL Label */ 
#line 1237
      if (128 & (int )((scm_cell *)((SCM )ptr))->car) {
#line 1238
        goto c8mrkcontinue;
      }
      {
#line 1241
      if ((int )(((scm_cell *)((SCM )ptr))->car >> 16) == (int )(((2L << 16) | (1L << 16)) >> 16)) {
#line 1241
        goto case_exp;
      }
#line 1244
      if ((int )(((scm_cell *)((SCM )ptr))->car >> 16) == (int )((2L << 16) >> 16)) {
#line 1244
        goto case_exp___0;
      }
#line 1244
      if ((int )(((scm_cell *)((SCM )ptr))->car >> 16) == (int )((1L << 16) >> 16)) {
#line 1244
        goto case_exp___0;
      }
#line 1247
      if ((int )(((scm_cell *)((SCM )ptr))->car >> 16) == 0) {
#line 1247
        goto case_0___0;
      }
#line 1249
      goto switch_default;
      case_exp: /* CIL Label */ 
#line 1242
      m = (long )((unsigned long )m + sizeof(double ));
      case_exp___0: /* CIL Label */ 
      case_exp___1: /* CIL Label */ 
#line 1245
      m = (long )((unsigned long )m + sizeof(double ));
#line 1246
      goto freechars;
      case_0___0: /* CIL Label */ 
#line 1248
      goto switch_break___1;
      switch_default: /* CIL Label */ 
#line 1250
      goto sweeperr;
      switch_break___1: /* CIL Label */ ;
      }
#line 1252
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 1254
      if (128 & (int )((scm_cell *)((SCM )ptr))->car) {
#line 1255
        goto c8mrkcontinue;
      }
#line 1259
      k___0 = (int )(255L & (((scm_cell *)((SCM )ptr))->car >> 8));
#line 1260
      if (! ((size_t )k___0 < scm_numsmob)) {
#line 1261
        goto sweeperr;
      }
      {
#line 1262
      tmp___8 = (*((scm_smobs + k___0)->free))((SCM )ptr);
#line 1262
      m = (long )((size_t )m + tmp___8);
      }
#line 1263
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 1266
      goto switch_break;
      sweeperr: 
      switch_default___1: /* CIL Label */ 
      {
#line 1268
      scm_wta((SCM )ptr, (char *)"unknown type in ", (char *)"gc_sweep");
      }
      switch_break: /* CIL Label */ ;
      }
#line 1270
      n += (long )span;
#line 1276
      ((scm_cell *)((SCM )ptr))->car = (SCM )127;
#line 1277
      ((scm_cell *)((SCM )ptr))->cdr = nfreelist;
#line 1278
      nfreelist = (SCM )ptr;
#line 1280
      goto __Cont;
      c8mrkcontinue: 
#line 1282
      ((scm_cell *)((SCM )ptr))->car &= -129L;
#line 1283
      goto __Cont;
      cmrkcontinue: 
#line 1285
      ((scm_cell *)((SCM )ptr))->cdr &= -2L;
      __Cont: /* CIL Label */ 
#line 1070
      ptr += span;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1288
    if ((size_t )n == seg_size) {
      {
#line 1290
      scm_heap_size = (long )((size_t )scm_heap_size - seg_size);
#line 1291
      free((void *)((char *)(scm_heap_table + i)->bounds[0]));
#line 1292
      (scm_heap_table + i)->bounds[0] = (SCM_CELLPTR )0;
#line 1293
      j = i + 1UL;
      }
      {
#line 1293
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1293
        if (! (j < (size_t )scm_n_heap_segs)) {
#line 1293
          goto while_break___2;
        }
#line 1294
        *(scm_heap_table + (j - 1UL)) = *(scm_heap_table + j);
#line 1293
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1295
      scm_n_heap_segs --;
#line 1296
      i --;
    } else {
#line 1302
      *hp_freelist = nfreelist;
    }
#line 1309
    scm_gc_cells_collected += (unsigned long )n;
#line 1310
    n = 0L;
#line 1056
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1315
  i = (size_t )0;
  {
#line 1315
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1315
    if (! (i < (size_t )scm_n_weak)) {
#line 1315
      goto while_break___3;
    }
#line 1317
    if (! *((SCM *)((scm_cell *)*(scm_weak_vectors + i))->cdr + -1)) {
#line 1319
      ptr___0 = (SCM *)((scm_cell *)*(scm_weak_vectors + i))->cdr;
#line 1320
      n = (long )((unsigned long )((scm_cell *)*(scm_weak_vectors + i))->car >> 8);
#line 1321
      j = (size_t )0;
      {
#line 1321
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1321
        if (! (j < (size_t )n)) {
#line 1321
          goto while_break___4;
        }
#line 1322
        if (! (6 & (int )*(ptr___0 + j))) {
#line 1322
          if (((scm_cell *)*(ptr___0 + j))->car == 127L) {
#line 1323
            *(ptr___0 + j) = (long )(16 << 9) + 372L;
          }
        }
#line 1321
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else {
#line 1328
      obj = *(scm_weak_vectors + i);
#line 1329
      ptr___0 = (SCM *)((scm_cell *)*(scm_weak_vectors + i))->cdr;
#line 1330
      n = (long )((unsigned long )((scm_cell *)*(scm_weak_vectors + i))->car >> 8);
#line 1331
      j = (size_t )0;
      {
#line 1331
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1331
        if (! (j < (size_t )n)) {
#line 1331
          goto while_break___5;
        }
#line 1338
        if (*((SCM *)((scm_cell *)obj)->cdr + -1) == 1L) {
#line 1338
          tmp___9 = 1;
        } else
#line 1338
        if (*((SCM *)((scm_cell *)obj)->cdr + -1) == 3L) {
#line 1338
          tmp___9 = 1;
        } else {
#line 1338
          tmp___9 = 0;
        }
#line 1338
        weak_keys = tmp___9;
#line 1339
        if (*((SCM *)((scm_cell *)obj)->cdr + -1) == 2L) {
#line 1339
          tmp___10 = 1;
        } else
#line 1339
        if (*((SCM *)((scm_cell *)obj)->cdr + -1) == 3L) {
#line 1339
          tmp___10 = 1;
        } else {
#line 1339
          tmp___10 = 0;
        }
#line 1339
        weak_values = tmp___10;
#line 1341
        fixup = ptr___0 + j;
#line 1342
        alist = *fixup;
        {
#line 1344
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 1344
          if (! (6 & (int )alist)) {
#line 1344
            if (! (1 & (int )((scm_cell *)alist)->car)) {
#line 1344
              if (! (6 & (int )((scm_cell *)alist)->car)) {
#line 1344
                if (! (! (1 & (int )((scm_cell *)((scm_cell *)alist)->car)->car))) {
#line 1344
                  goto while_break___6;
                }
              } else {
#line 1344
                goto while_break___6;
              }
            } else {
#line 1344
              goto while_break___6;
            }
          } else {
#line 1344
            goto while_break___6;
          }
#line 1352
          key = ((scm_cell *)((scm_cell *)alist)->car)->car;
#line 1353
          value = ((scm_cell *)((scm_cell *)alist)->car)->cdr;
#line 1354
          if (weak_keys) {
#line 1354
            if (! (6 & (int )key)) {
#line 1354
              if (((scm_cell *)key)->car == 127L) {
#line 1357
                *fixup = ((scm_cell *)alist)->cdr;
              } else {
#line 1354
                goto _L___0;
              }
            } else {
#line 1354
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
#line 1354
          if (weak_values) {
#line 1354
            if (! (6 & (int )value)) {
#line 1354
              if (((scm_cell *)value)->car == 127L) {
#line 1357
                *fixup = ((scm_cell *)alist)->cdr;
              } else {
#line 1360
                fixup = & ((scm_cell *)alist)->cdr;
              }
            } else {
#line 1360
              fixup = & ((scm_cell *)alist)->cdr;
            }
          } else {
#line 1360
            fixup = & ((scm_cell *)alist)->cdr;
          }
#line 1361
          alist = ((scm_cell *)alist)->cdr;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 1331
        j ++;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 1315
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1367
  scm_cells_allocated = (unsigned long )scm_heap_size - scm_gc_cells_collected;
#line 1368
  scm_mallocated -= (unsigned long )m;
#line 1369
  scm_gc_malloc_collected = (unsigned long )m;
#line 1370
  return;
}
}
#line 1395 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
char *scm_must_malloc(long len , char *what ) 
{ 
  char *ptr ;
  size_t size ;
  long nm ;
  int *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;

  {
#line 1401
  size = (size_t )len;
#line 1402
  nm = (long )(scm_mallocated + size);
#line 1403
  if ((size_t )len != size) {
    malerr: 
    {
#line 1405
    scm_wta((len << 2) + 2L, (char *)11, what);
    }
  }
#line 1406
  if (nm <= scm_mtrigger) {
    {
#line 1408
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1408
      tmp = __errno_location();
#line 1408
      *tmp = 0;
#line 1408
      tmp___0 = malloc(size);
#line 1408
      ptr = (char *)tmp___0;
#line 1408
      tmp___1 = __errno_location();
      }
#line 1408
      if (! (4 == *tmp___1)) {
#line 1408
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1409
    if ((unsigned long )((void *)0) != (unsigned long )ptr) {
#line 1411
      scm_mallocated = (unsigned long )nm;
#line 1412
      return (ptr);
    }
  }
  {
#line 1416
  scm_igc(what);
#line 1417
  nm = (long )(scm_mallocated + size);
  }
  {
#line 1418
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1418
    tmp___2 = __errno_location();
#line 1418
    *tmp___2 = 0;
#line 1418
    tmp___3 = malloc(size);
#line 1418
    ptr = (char *)tmp___3;
#line 1418
    tmp___4 = __errno_location();
    }
#line 1418
    if (! (4 == *tmp___4)) {
#line 1418
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1419
  if ((unsigned long )((void *)0) != (unsigned long )ptr) {
#line 1421
    scm_mallocated = (unsigned long )nm;
#line 1422
    if (nm > scm_mtrigger - 10000L) {
#line 1423
      if (nm > scm_mtrigger) {
#line 1424
        scm_mtrigger = nm + nm / 2L;
      } else {
#line 1426
        scm_mtrigger += scm_mtrigger / 2L;
      }
    }
#line 1428
    return (ptr);
  }
#line 1430
  goto malerr;
}
}
#line 1437 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
char *scm_must_realloc(char *where , long olen , long len , char *what ) 
{ 
  char *ptr ;
  size_t size ;
  long nm ;
  int *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;

  {
#line 1445
  size = (size_t )len;
#line 1446
  nm = (long )((scm_mallocated + size) - (unsigned long )olen);
#line 1447
  if ((size_t )len != size) {
    ralerr: 
    {
#line 1449
    scm_wta((len << 2) + 2L, (char *)11, what);
    }
  }
#line 1450
  if (nm <= scm_mtrigger) {
    {
#line 1452
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1452
      tmp = __errno_location();
#line 1452
      *tmp = 0;
#line 1452
      tmp___0 = realloc((void *)where, size);
#line 1452
      ptr = (char *)tmp___0;
#line 1452
      tmp___1 = __errno_location();
      }
#line 1452
      if (! (4 == *tmp___1)) {
#line 1452
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1453
    if ((unsigned long )((void *)0) != (unsigned long )ptr) {
#line 1455
      scm_mallocated = (unsigned long )nm;
#line 1456
      return (ptr);
    }
  }
  {
#line 1459
  scm_igc(what);
#line 1460
  nm = (long )((scm_mallocated + size) - (unsigned long )olen);
  }
  {
#line 1461
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1461
    tmp___2 = __errno_location();
#line 1461
    *tmp___2 = 0;
#line 1461
    tmp___3 = realloc((void *)where, size);
#line 1461
    ptr = (char *)tmp___3;
#line 1461
    tmp___4 = __errno_location();
    }
#line 1461
    if (! (4 == *tmp___4)) {
#line 1461
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1462
  if ((unsigned long )((void *)0) != (unsigned long )ptr) {
#line 1464
    scm_mallocated = (unsigned long )nm;
#line 1465
    if (nm > scm_mtrigger - 10000L) {
#line 1466
      if (nm > scm_mtrigger) {
#line 1467
        scm_mtrigger = nm + nm / 2L;
      } else {
#line 1469
        scm_mtrigger += scm_mtrigger / 2L;
      }
    }
#line 1471
    return (ptr);
  }
#line 1473
  goto ralerr;
}
}
#line 1476 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
void scm_must_free(char *obj ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
#line 1480
  if (obj) {
    {
#line 1481
    free((void *)obj);
    }
  } else {
    {
#line 1483
    scm_wta((SCM )2, (char *)"already free", (char *)"");
    }
  }
#line 1484
  return;
}
}
#line 1504 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
int scm_expmem  =    0;
#line 1511 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
struct scm_heap_seg_data *scm_heap_table  =    (struct scm_heap_seg_data *)0;
#line 1512 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
int scm_n_heap_segs  =    0;
#line 1517 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
long scm_heap_size  =    0L;
#line 1530 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
static size_t init_heap_seg(SCM_CELLPTR seg_org , size_t size , int ncells , SCM *freelistp ) 
{ 
  register SCM_CELLPTR ptr ;
  SCM_CELLPTR seg_end ;
  size_t new_seg_index ;
  size_t n_new_objects ;
  int i ;

  {
#line 1548
  if ((unsigned long )seg_org == (unsigned long )((void *)0)) {
#line 1549
    return ((size_t )0);
  }
#line 1551
  ptr = seg_org;
#line 1555
  seg_end = (SCM_CELLPTR )(~ (sizeof(scm_cell ) - 1UL) & (unsigned long )((long )((char *)ptr + size)));
#line 1560
  new_seg_index = (size_t )0;
  {
#line 1560
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1560
    if (new_seg_index < (size_t )scm_n_heap_segs) {
#line 1560
      if (! (! ((unsigned long )seg_org < (unsigned long )(scm_heap_table + new_seg_index)->bounds[0]))) {
#line 1560
        goto while_break;
      }
    } else {
#line 1560
      goto while_break;
    }
#line 1560
    new_seg_index ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1568
  i = scm_n_heap_segs;
  {
#line 1568
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1568
    if (! ((size_t )i > new_seg_index)) {
#line 1568
      goto while_break___0;
    }
#line 1569
    *(scm_heap_table + i) = *(scm_heap_table + (i - 1));
#line 1568
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1572
  scm_n_heap_segs ++;
#line 1574
  (scm_heap_table + new_seg_index)->valid = (int (*)())0;
#line 1575
  (scm_heap_table + new_seg_index)->ncells = ncells;
#line 1576
  (scm_heap_table + new_seg_index)->freelistp = freelistp;
#line 1577
  (scm_heap_table + new_seg_index)->bounds[0] = ptr;
#line 1578
  (scm_heap_table + new_seg_index)->bounds[1] = seg_end;
#line 1583
  ptr = (SCM_CELLPTR )(~ (sizeof(scm_cell ) - 1UL) & (((unsigned long )((long )ptr) + sizeof(scm_cell )) - 1UL));
#line 1586
  n_new_objects = (size_t )(seg_end - ptr);
  {
#line 1590
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1590
    if (! ((unsigned long )ptr < (unsigned long )seg_end)) {
#line 1590
      goto while_break___1;
    }
#line 1595
    ptr->car = (SCM )127;
#line 1596
    ptr->cdr = (SCM )(ptr + ncells);
#line 1597
    ptr += ncells;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1600
  ptr -= ncells;
#line 1605
  ((scm_cell *)((SCM )ptr))->cdr = *freelistp;
#line 1606
  *freelistp = (SCM )((SCM_CELLPTR )(~ (sizeof(scm_cell ) - 1UL) & (((unsigned long )((long )seg_org) + sizeof(scm_cell )) - 1UL)));
#line 1608
  scm_heap_size = (long )((size_t )scm_heap_size + (size_t )ncells * n_new_objects);
#line 1609
  return (size);
}
}
#line 1616 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
static void alloc_some_heap(int ncells , SCM *freelistp ) 
{ 
  struct scm_heap_seg_data *tmptable ;
  SCM_CELLPTR ptr ;
  size_t len ;
  int *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  size_t smallest ;
  int *tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 1628
  if (scm_gc_heap_lock) {
    {
#line 1629
    scm_wta((long )(18 << 9) + 372L, (char *)"need larger initial", (char *)"heap");
    }
  }
#line 1635
  len = (unsigned long )(1 + scm_n_heap_segs) * sizeof(struct scm_heap_seg_data );
  {
#line 1637
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1637
    tmp = __errno_location();
#line 1637
    *tmp = 0;
#line 1637
    tmp___0 = realloc((void *)((char *)scm_heap_table), len);
#line 1637
    tmptable = (struct scm_heap_seg_data *)tmp___0;
#line 1637
    tmp___1 = __errno_location();
    }
#line 1637
    if (! (4 == *tmp___1)) {
#line 1637
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1639
  if (! tmptable) {
    {
#line 1640
    scm_wta((long )(18 << 9) + 372L, (char *)"could not grow", (char *)"hplims");
    }
  } else {
#line 1642
    scm_heap_table = tmptable;
  }
#line 1649
  if (scm_expmem) {
#line 1651
    len = (unsigned long )(scm_heap_size * 2L) * sizeof(scm_cell );
#line 1652
    if ((unsigned long )(scm_heap_size * 2L) * sizeof(scm_cell ) != len) {
#line 1653
      len = (size_t )0;
    }
  } else {
#line 1656
    len = 16384UL * sizeof(scm_cell );
  }
#line 1661
  smallest = (unsigned long )ncells * sizeof(scm_cell );
#line 1662
  if (len < smallest) {
#line 1663
    len = (unsigned long )ncells * sizeof(scm_cell );
  }
  {
#line 1666
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1666
    if (len >= 2048UL * sizeof(scm_cell )) {
#line 1666
      if (! (len >= smallest)) {
#line 1666
        goto while_break___0;
      }
    } else {
#line 1666
      goto while_break___0;
    }
    {
#line 1669
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1669
      tmp___2 = __errno_location();
#line 1669
      *tmp___2 = 0;
#line 1669
      tmp___3 = malloc(len);
#line 1669
      ptr = (SCM_CELLPTR )tmp___3;
#line 1669
      tmp___4 = __errno_location();
      }
#line 1669
      if (! (4 == *tmp___4)) {
#line 1669
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1670
    if (ptr) {
      {
#line 1672
      init_heap_seg(ptr, len, ncells, freelistp);
      }
#line 1673
      return;
    }
#line 1675
    len /= 2UL;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1679
  scm_wta((long )(18 << 9) + 372L, (char *)"could not grow", (char *)"heap");
  }
#line 1680
  return;
}
}
#line 1684 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
static char s_unhash_name[12]  = 
#line 1684
  {      (char )'u',      (char )'n',      (char )'h',      (char )'a', 
        (char )'s',      (char )'h',      (char )'-',      (char )'n', 
        (char )'a',      (char )'m',      (char )'e',      (char )'\000'};
#line 1685 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
SCM scm_unhash_name(SCM name ) 
{ 
  int x ;
  int bound ;
  SCM_CELLPTR p ;
  SCM_CELLPTR pbound ;
  SCM incar ;

  {
#line 1691
  if (! (6 & (int )name)) {
#line 1691
    if (! ((125 & (int )((scm_cell *)name)->car) == 5)) {
      {
#line 1691
      scm_wta(name, (char *)1, s_unhash_name);
      }
    }
  } else {
    {
#line 1691
    scm_wta(name, (char *)1, s_unhash_name);
    }
  }
#line 1692
  scm_ints_disabled = 1;
#line 1693
  bound = scm_n_heap_segs;
#line 1694
  x = 0;
  {
#line 1694
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1694
    if (! (x < bound)) {
#line 1694
      goto while_break;
    }
#line 1698
    p = (scm_heap_table + x)->bounds[0];
#line 1699
    pbound = (scm_heap_table + x)->bounds[1];
    {
#line 1700
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1700
      if (! ((unsigned long )p < (unsigned long )pbound)) {
#line 1700
        goto while_break___0;
      }
#line 1703
      incar = p->car;
#line 1704
      if (1 == (7 & (int )incar)) {
#line 1706
        incar --;
#line 1707
        if (name == (long )(17 << 9) + 372L) {
#line 1707
          goto _L;
        } else
#line 1707
        if (((scm_cell *)incar)->car == name) {
          _L: /* CIL Label */ 
#line 1707
          if (((scm_cell *)incar)->cdr != 0L) {
#line 1707
            if (((scm_cell *)incar)->cdr != 1L) {
#line 1711
              p->car = name;
            }
          }
        }
      }
#line 1714
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1694
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1717
  scm_ints_disabled = 0;
#line 1717
  scm_async_clock --;
#line 1717
  if (0U == scm_async_clock) {
    {
#line 1717
    scm_async_click();
    }
  }
#line 1718
  return (name);
}
}
#line 1727 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
void scm_remember(SCM *ptr ) 
{ 


  {
#line 1730
  return;
}
}
#line 1734 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
SCM scm_return_first(SCM elt  , ...) 
{ 


  {
#line 1743
  return (elt);
}
}
#line 1747 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
SCM scm_permanent_object(SCM obj ) 
{ 


  {
  {
#line 1751
  scm_ints_disabled ++;
#line 1752
  scm_sys_protects[13] = scm_cons(obj, scm_sys_protects[13]);
#line 1753
  scm_ints_disabled --;
  }
#line 1753
  if (! scm_ints_disabled) {
#line 1753
    scm_async_clock --;
#line 1753
    if (0U == scm_async_clock) {
      {
#line 1753
      scm_async_click();
      }
    }
  }
#line 1754
  return (obj);
}
}
#line 1771 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
SCM scm_protect_object(SCM obj ) 
{ 


  {
  {
#line 1777
  scm_sys_protects[15] = scm_cons(obj, scm_sys_protects[15]);
  }
#line 1779
  return (obj);
}
}
#line 1787 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
SCM scm_unprotect_object(SCM obj ) 
{ 


  {
  {
#line 1791
  scm_sys_protects[15] = scm_delq_x(obj, scm_sys_protects[15]);
  }
#line 1793
  return (obj);
}
}
#line 1798 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
int scm_init_storage(long init_heap_size ) 
{ 
  size_t j ;
  char *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 1804
  j = (size_t )17;
  {
#line 1805
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1805
    if (! j) {
#line 1805
      goto while_break;
    }
#line 1806
    j --;
#line 1806
    scm_sys_protects[j] = (long )(16 << 9) + 372L;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1807
  scm_block_gc = 1;
#line 1808
  scm_freelist = (long )(20 << 9) + 372L;
#line 1809
  scm_expmem = 0;
#line 1811
  j = 16384UL * sizeof(scm_cell );
#line 1812
  scm_mtrigger = 100000L;
#line 1813
  tmp = scm_must_malloc((long )sizeof(struct scm_heap_seg_data ), (char *)"hplims");
#line 1813
  scm_heap_table = (struct scm_heap_seg_data *)tmp;
  }
#line 1815
  if (0L == init_heap_size) {
#line 1816
    init_heap_size = (long )(32768UL * sizeof(scm_cell ));
  }
#line 1817
  j = (size_t )init_heap_size;
#line 1818
  if ((size_t )init_heap_size != j) {
#line 1818
    goto _L;
  } else {
    {
#line 1818
    tmp___2 = malloc(j);
#line 1818
    tmp___3 = init_heap_seg((SCM_CELLPTR )tmp___2, j, 1, & scm_freelist);
    }
#line 1818
    if (tmp___3) {
#line 1826
      scm_expmem = 1;
    } else {
      _L: /* CIL Label */ 
      {
#line 1821
      j = 16384UL * sizeof(scm_cell );
#line 1822
      tmp___0 = malloc(j);
#line 1822
      tmp___1 = init_heap_seg((SCM_CELLPTR )tmp___0, j, 1, & scm_freelist);
      }
#line 1822
      if (! tmp___1) {
#line 1823
        return (1);
      }
    }
  }
  {
#line 1827
  scm_heap_org = (SCM_CELLPTR )(~ (sizeof(scm_cell ) - 1UL) & (((unsigned long )((long )(scm_heap_table + 0)->bounds[0]) + sizeof(scm_cell )) - 1UL));
#line 1829
  scm_weak_size = 32;
#line 1829
  tmp___4 = malloc((unsigned long )scm_weak_size * sizeof(SCM *));
#line 1829
  scm_weak_vectors = (SCM *)tmp___4;
  }
#line 1829
  if (! scm_weak_vectors) {
#line 1830
    return (1);
  }
  {
#line 1833
  tmp___5 = malloc((size_t )((long )(sizeof(struct scm_port_table ) * (unsigned long )scm_port_table_room)));
#line 1833
  scm_port_table = (struct scm_port_table **)tmp___5;
  }
#line 1835
  if (! scm_port_table) {
#line 1836
    return (1);
  }
  {
#line 1839
  scm_sys_protects[2] = scm_cons((long )(18 << 9) + 372L, (long )(20 << 9) + 372L);
#line 1840
  ((scm_cell *)scm_sys_protects[2])->cdr = scm_sys_protects[2];
#line 1842
  scm_sys_protects[1] = scm_cons((long )(20 << 9) + 372L, (long )(20 << 9) + 372L);
#line 1843
  scm_sys_protects[4] = scm_makstr(0L, 0);
#line 1844
  scm_sys_protects[3] = scm_make_vector((SCM )2, (long )(18 << 9) + 372L, (long )(18 << 9) + 372L);
#line 1845
  scm_sys_protects[5] = scm_make_vector((long )(scm_symhash_dim << 2) + 2L, (long )(20 << 9) + 372L,
                                        (long )(18 << 9) + 372L);
#line 1846
  scm_sys_protects[6] = scm_make_weak_key_hash_table((long )(scm_symhash_dim << 2) + 2L);
#line 1847
  scm_sys_protects[7] = scm_make_vector((long )(scm_symhash_dim << 2) + 2L, (long )(20 << 9) + 372L,
                                        (long )(18 << 9) + 372L);
#line 1848
  scm_sys_protects[11] = (long )(20 << 9) + 372L;
#line 1849
  scm_sys_protects[13] = (long )(20 << 9) + 372L;
#line 1850
  scm_sys_protects[15] = (long )(20 << 9) + 372L;
#line 1851
  scm_sys_protects[14] = (long )(20 << 9) + 372L;
#line 1852
  scm_sysintern((char *)"most-positive-fixnum", ((9223372036854775807L >> 2) << 2) + 2L);
#line 1853
  scm_sysintern((char *)"most-negative-fixnum", (((-0x7FFFFFFFFFFFFFFF-1) >> 2) << 2) + 2L);
#line 1855
  scm_sysintern((char *)"bignum-radix", ((1L << sizeof(unsigned short ) * 8UL) << 2) + 2L);
  }
#line 1857
  return (0);
}
}
#line 1861 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
void scm_init_gc(void) 
{ 
  SCM tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  SCM tmp___2 ;
  SCM tmp___3 ;
  SCM tmp___4 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.x"
  tmp = scm_intern0((char *)"cells-allocated");
#line 1
  sym_cells_allocated = scm_permanent_object(((scm_cell *)tmp)->car);
#line 2
  tmp___0 = scm_intern0((char *)"cell-heap-size");
#line 2
  sym_heap_size = scm_permanent_object(((scm_cell *)tmp___0)->car);
#line 3
  tmp___1 = scm_intern0((char *)"bytes-malloced");
#line 3
  sym_mallocated = scm_permanent_object(((scm_cell *)tmp___1)->car);
#line 4
  tmp___2 = scm_intern0((char *)"gc-malloc-threshold");
#line 4
  sym_mtrigger = scm_permanent_object(((scm_cell *)tmp___2)->car);
#line 5
  tmp___3 = scm_intern0((char *)"cell-heap-segments");
#line 5
  sym_heap_segments = scm_permanent_object(((scm_cell *)tmp___3)->car);
#line 6
  tmp___4 = scm_intern0((char *)"gc-time-taken");
#line 6
  sym_gc_time_taken = scm_permanent_object(((scm_cell *)tmp___4)->car);
#line 7
  scm_make_gsubr(s_gc_stats, 0, 0, 0, & scm_gc_stats);
#line 8
  scm_make_gsubr(s_object_address, 1, 0, 0, (SCM (*)())(& scm_object_addr));
#line 9
  scm_make_gsubr(s_gc, 0, 0, 0, & scm_gc);
#line 10
  scm_make_gsubr(s_unhash_name, 1, 0, 0, (SCM (*)())(& scm_unhash_name));
  }
#line 1865 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/gc.c"
  return;
}
}
#line 249 "/usr/include/stdio.h"
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 309
extern  __attribute__((__nothrow__)) void setbuf(FILE * __restrict  __stream , char * __restrict  __buf ) ;
#line 513
extern int fgetc(FILE *__stream ) ;
#line 555
extern int fputc(int __c , FILE *__stream ) ;
#line 801
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
#line 70 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/error.h"
 __attribute__((__noreturn__)) void scm_syserror_msg(char *subr , char *message ,
                                                     SCM args ) ;
#line 135 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 62 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/fports.h"
SCM scm_port_mode(SCM port ) ;
#line 92 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/fports.c"
SCM scm_setbuf0(SCM port ) 
{ 
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 100
    tmp = __errno_location();
#line 100
    *tmp = 0;
#line 100
    setbuf((FILE */* __restrict  */)((FILE *)((struct scm_port_table *)((scm_cell *)port)->cdr)->stream),
           (char */* __restrict  */)0);
#line 100
    tmp___0 = __errno_location();
    }
#line 100
    if (! (4 == *tmp___0)) {
#line 100
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  return ((long )(21 << 9) + 372L);
}
}
#line 114 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/fports.c"
long scm_mode_bits(char *modes ) 
{ 
  long tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  long tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  long tmp___12 ;
  char *tmp___13 ;

  {
  {
#line 118
  tmp___2 = strchr((char const   *)modes, 'r');
  }
#line 118
  if (tmp___2) {
#line 118
    tmp___1 = 2L << 16;
  } else {
    {
#line 118
    tmp___3 = strchr((char const   *)modes, '+');
    }
#line 118
    if (tmp___3) {
#line 118
      tmp___1 = 2L << 16;
    } else {
#line 118
      tmp___1 = 0L;
    }
  }
  {
#line 118
  tmp___8 = strchr((char const   *)modes, 'w');
  }
#line 118
  if (tmp___8) {
#line 118
    tmp___7 = 4L << 16;
  } else {
    {
#line 118
    tmp___9 = strchr((char const   *)modes, 'a');
    }
#line 118
    if (tmp___9) {
#line 118
      tmp___7 = 4L << 16;
    } else {
      {
#line 118
      tmp___10 = strchr((char const   *)modes, '+');
      }
#line 118
      if (tmp___10) {
#line 118
        tmp___7 = 4L << 16;
      } else {
#line 118
        tmp___7 = 0L;
      }
    }
  }
  {
#line 118
  tmp___13 = strchr((char const   *)modes, '0');
  }
#line 118
  if (tmp___13) {
#line 118
    tmp___12 = 8L << 16;
  } else {
#line 118
    tmp___12 = 0L;
  }
#line 118
  return ((((1L << 16) | tmp___1) | tmp___7) | tmp___12);
}
}
#line 135 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/fports.c"
static char s_open_file[10]  = 
#line 135
  {      (char )'o',      (char )'p',      (char )'e',      (char )'n', 
        (char )'-',      (char )'f',      (char )'i',      (char )'l', 
        (char )'e',      (char )'\000'};
#line 137 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/fports.c"
SCM scm_open_file(SCM filename , SCM modes ) 
{ 
  SCM port ;
  FILE *f ;
  char *file ;
  char *mode ;
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  SCM tmp___5 ;
  SCM tmp___6 ;
  struct scm_port_table *pt ;
  long tmp___7 ;
  char *__cil_tmp17 ;

  {
#line 147
  if (! (6 & (int )filename)) {
#line 147
    if (! ((117 & (int )((scm_cell *)filename)->car) == 21)) {
#line 147
      if (! ((125 & (int )((scm_cell *)filename)->car) == 5)) {
        {
#line 147
        scm_wta(filename, (char *)1, s_open_file);
        }
      }
    }
  } else {
    {
#line 147
    scm_wta(filename, (char *)1, s_open_file);
    }
  }
#line 148
  if (! (6 & (int )modes)) {
#line 148
    if (! ((117 & (int )((scm_cell *)modes)->car) == 21)) {
#line 148
      if (! ((125 & (int )((scm_cell *)modes)->car) == 5)) {
        {
#line 148
        scm_wta(modes, (char *)2, s_open_file);
        }
      }
    }
  } else {
    {
#line 148
    scm_wta(modes, (char *)2, s_open_file);
    }
  }
#line 149
  if ((125 & (int )((scm_cell *)filename)->car) == 29) {
#line 150
    if ((127 & (int )((scm_cell *)filename)->car) == 29) {
#line 150
      tmp = (char *)((scm_cell *)((scm_cell *)((scm_cell *)filename)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)filename)->cdr)->car >> 2);
    } else {
#line 150
      tmp = (char *)((scm_cell *)filename)->cdr;
    }
    {
#line 150
    filename = scm_makfromstr((char const   *)tmp, (unsigned long )((scm_cell *)filename)->car >> 8,
                              0);
    }
  }
#line 151
  if ((125 & (int )((scm_cell *)modes)->car) == 29) {
#line 152
    if ((127 & (int )((scm_cell *)modes)->car) == 29) {
#line 152
      tmp___0 = (char *)((scm_cell *)((scm_cell *)((scm_cell *)modes)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)modes)->cdr)->car >> 2);
    } else {
#line 152
      tmp___0 = (char *)((scm_cell *)modes)->cdr;
    }
    {
#line 152
    modes = scm_makfromstr((char const   *)tmp___0, (unsigned long )((scm_cell *)modes)->car >> 8,
                           0);
    }
  }
#line 154
  if ((127 & (int )((scm_cell *)filename)->car) == 29) {
#line 154
    file = (char *)((scm_cell *)((scm_cell *)((scm_cell *)filename)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)filename)->cdr)->car >> 2);
  } else {
#line 154
    file = (char *)((scm_cell *)filename)->cdr;
  }
#line 155
  if ((127 & (int )((scm_cell *)modes)->car) == 29) {
#line 155
    mode = (char *)((scm_cell *)((scm_cell *)((scm_cell *)modes)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)modes)->cdr)->car >> 2);
  } else {
#line 155
    mode = (char *)((scm_cell *)modes)->cdr;
  }
#line 157
  if (6 & (int )scm_freelist) {
    {
#line 157
    port = scm_gc_for_newcell();
    }
  } else {
#line 157
    port = scm_freelist;
#line 157
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 157
    scm_cells_allocated ++;
  }
#line 158
  scm_ints_disabled = 1;
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 159
    tmp___1 = __errno_location();
#line 159
    *tmp___1 = 0;
#line 159
    f = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)mode);
#line 159
    tmp___2 = __errno_location();
    }
#line 159
    if (! (4 == *tmp___2)) {
#line 159
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  if (! f) {
    {
#line 162
    tmp___3 = __errno_location();
#line 162
    tmp___4 = strerror(*tmp___3);
#line 162
    tmp___5 = scm_makfrom0str((char const   *)tmp___4);
#line 162
    tmp___6 = scm_listify(tmp___5, filename, (long )(18 << 9) + 372L);
#line 162
    scm_syserror_msg(s_open_file, (char *)"%s: %S", tmp___6);
    }
  } else {
    {
#line 171
    pt = scm_add_to_port_table(port);
#line 172
    ((scm_cell *)port)->cdr = (SCM )pt;
#line 173
    tmp___7 = scm_mode_bits(mode);
#line 173
    ((scm_cell *)port)->car = 125L | tmp___7;
#line 174
    ((struct scm_port_table *)((scm_cell *)port)->cdr)->stream = (SCM )f;
    }
#line 175
    if ((8L << 16) & ((scm_cell *)port)->car) {
      {
#line 176
      scm_setbuf0(port);
      }
    }
#line 177
    ((struct scm_port_table *)((scm_cell *)port)->cdr)->file_name = filename;
  }
#line 179
  scm_ints_disabled = 0;
#line 179
  scm_async_clock --;
#line 179
  if (0U == scm_async_clock) {
    {
#line 179
    scm_async_click();
    }
  }
#line 180
  return (port);
}
}
#line 192 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/fports.c"
SCM scm_stdio_to_port(FILE *file , char *mode , char *name ) 
{ 
  long mode_bits ;
  long tmp ;
  SCM port ;
  struct scm_port_table *pt ;

  {
  {
#line 198
  tmp = scm_mode_bits(mode);
#line 198
  mode_bits = tmp;
  }
#line 202
  if (6 & (int )scm_freelist) {
    {
#line 202
    port = scm_gc_for_newcell();
    }
  } else {
#line 202
    port = scm_freelist;
#line 202
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 202
    scm_cells_allocated ++;
  }
  {
#line 203
  scm_ints_disabled = 1;
#line 205
  pt = scm_add_to_port_table(port);
#line 206
  ((scm_cell *)port)->cdr = (SCM )pt;
#line 207
  ((scm_cell *)port)->car = 125L | mode_bits;
#line 208
  ((struct scm_port_table *)((scm_cell *)port)->cdr)->stream = (SCM )file;
  }
#line 209
  if ((8L << 16) & ((scm_cell *)port)->car) {
    {
#line 210
    scm_setbuf0(port);
    }
  }
  {
#line 211
  ((struct scm_port_table *)((scm_cell *)port)->cdr)->file_name = scm_makfrom0str((char const   *)name);
#line 213
  scm_ints_disabled = 0;
#line 213
  scm_async_clock --;
  }
#line 213
  if (0U == scm_async_clock) {
    {
#line 213
    scm_async_click();
    }
  }
  {
#line 214
  scm_set_port_revealed_x(port, (long )(1 << 2) + 2L);
  }
#line 215
  return (port);
}
}
#line 223 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/fports.c"
static char s_port_mode[10]  = 
#line 223
  {      (char )'p',      (char )'o',      (char )'r',      (char )'t', 
        (char )'-',      (char )'m',      (char )'o',      (char )'d', 
        (char )'e',      (char )'\000'};
#line 225 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/fports.c"
SCM scm_port_mode(SCM port ) 
{ 
  char modes[3] ;
  size_t tmp ;
  SCM tmp___0 ;
  void *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 230
  modes[0] = (char )'\000';
#line 231
  if (! (6 & (int )port)) {
#line 231
    if (! (((127L | (1L << 16)) & ((scm_cell *)port)->car) == (125L | (1L << 16)))) {
      {
#line 231
      scm_wta(port, (char *)1, s_port_mode);
      }
    }
  } else {
    {
#line 231
    scm_wta(port, (char *)1, s_port_mode);
    }
  }
#line 232
  if (((scm_cell *)port)->car & (2L << 16)) {
#line 233
    if (((scm_cell *)port)->car & (4L << 16)) {
      {
#line 234
      strcpy((char */* __restrict  */)(modes), (char const   */* __restrict  */)"r+");
      }
    } else {
      {
#line 236
      strcpy((char */* __restrict  */)(modes), (char const   */* __restrict  */)"r");
      }
    }
  } else
#line 238
  if (((scm_cell *)port)->car & (4L << 16)) {
    {
#line 239
    strcpy((char */* __restrict  */)(modes), (char const   */* __restrict  */)"w");
    }
  }
#line 240
  if (((scm_cell *)port)->car & (8L << 16)) {
    {
#line 241
    strcat((char */* __restrict  */)(modes), (char const   */* __restrict  */)"0");
    }
  }
  {
#line 242
  tmp = strlen((char const   *)(modes));
#line 242
  tmp___0 = scm_makfromstr((char const   *)(modes), tmp, 0);
  }
#line 242
  return (tmp___0);
}
}
#line 247
static int prinfport(SCM exp___0 , SCM port , scm_print_state *pstate ) ;
#line 249 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/fports.c"
static int prinfport(SCM exp___0 , SCM port , scm_print_state *pstate ) 
{ 
  SCM name ;
  char *c ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 257
  if (! ((1L << 16) & ((scm_cell *)exp___0)->car)) {
#line 259
    c = (char *)"file";
  } else {
#line 263
    name = ((struct scm_port_table *)((scm_cell *)exp___0)->cdr)->file_name;
#line 264
    if (! (6 & (int )name)) {
#line 264
      if ((117 & (int )((scm_cell *)name)->car) == 21) {
#line 264
        goto _L;
      } else
#line 264
      if ((125 & (int )((scm_cell *)name)->car) == 5) {
        _L: /* CIL Label */ 
#line 265
        if ((127 & (int )((scm_cell *)name)->car) == 29) {
#line 265
          c = (char *)((scm_cell *)((scm_cell *)((scm_cell *)name)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)name)->cdr)->car >> 2);
        } else {
#line 265
          c = (char *)((scm_cell *)name)->cdr;
        }
      } else {
#line 267
        c = (char *)"file";
      }
    } else {
#line 267
      c = (char *)"file";
    }
  }
  {
#line 270
  scm_prinport(exp___0, port, c);
  }
#line 271
  return (1);
}
}
#line 276
static int scm_fgetc(FILE *s___0 ) ;
#line 278 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/fports.c"
static int scm_fgetc(FILE *s___0 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 282
  tmp___0 = feof(s___0);
  }
#line 282
  if (tmp___0) {
#line 283
    return (-1);
  } else {
    {
#line 285
    tmp = fgetc(s___0);
    }
#line 285
    return (tmp);
  }
}
}
#line 315
static int local_fclose(FILE *fp ) ;
#line 317 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/fports.c"
static int local_fclose(FILE *fp ) 
{ 
  int tmp ;

  {
  {
#line 321
  tmp = fclose(fp);
  }
#line 321
  return (tmp);
}
}
#line 324
static int local_fflush(FILE *fp ) ;
#line 326 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/fports.c"
static int local_fflush(FILE *fp ) 
{ 
  int tmp ;

  {
  {
#line 330
  tmp = fflush(fp);
  }
#line 330
  return (tmp);
}
}
#line 333
static int local_fputc(int c , FILE *fp ) ;
#line 335 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/fports.c"
static int local_fputc(int c , FILE *fp ) 
{ 
  int tmp ;

  {
  {
#line 340
  tmp = fputc(c, fp);
  }
#line 340
  return (tmp);
}
}
#line 343
static int local_fputs(char *s___0 , FILE *fp ) ;
#line 345 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/fports.c"
static int local_fputs(char *s___0 , FILE *fp ) 
{ 
  int tmp ;

  {
  {
#line 350
  tmp = fputs((char const   */* __restrict  */)s___0, (FILE */* __restrict  */)fp);
  }
#line 350
  return (tmp);
}
}
#line 353
static size_t local_ffwrite(void *ptr , int size , int nitems , FILE *fp ) ;
#line 355 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/fports.c"
static size_t local_ffwrite(void *ptr , int size , int nitems , FILE *fp ) 
{ 
  size_t tmp ;

  {
  {
#line 362
  tmp = fwrite((void const   */* __restrict  */)ptr, (size_t )size, (size_t )nitems,
               (FILE */* __restrict  */)fp);
  }
#line 362
  return (tmp);
}
}
#line 366 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/fports.c"
scm_ptobfuns scm_fptob  = 
#line 366
     {& scm_mark0, (int (*)(SCM  ))(& local_fclose), & prinfport, (SCM (*)(SCM  , SCM  ))0,
    (int (*)(int  , SCM  ))(& local_fputc), (int (*)(char * , SCM  ))(& local_fputs),
    (size_t (*)(char * , size_t  , size_t  , SCM  ))(& local_ffwrite), (int (*)(SCM  ))(& local_fflush),
    (int (*)(SCM  ))(& scm_fgetc), (int (*)(SCM  ))(& local_fclose)};
#line 382 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/fports.c"
scm_ptobfuns scm_pipob  = 
#line 382
     {& scm_mark0, (int (*)(SCM  ))0, (int (*)(SCM exp , SCM port , scm_print_state *pstate ))0,
    (SCM (*)(SCM  , SCM  ))0, (int (*)(int  , SCM  ))(& local_fputc), (int (*)(char * ,
                                                                               SCM  ))(& local_fputs),
    (size_t (*)(char * , size_t  , size_t  , SCM  ))(& local_ffwrite), (int (*)(SCM  ))(& local_fflush),
    (int (*)(SCM  ))(& scm_fgetc), (int (*)(SCM stream ))0};
#line 396 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/fports.c"
void scm_init_fports(void) 
{ 


  {
  {
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/fports.x"
  scm_make_gsubr(s_open_file, 2, 0, 0, (SCM (*)())(& scm_open_file));
#line 2
  scm_make_gsubr(s_port_mode, 1, 0, 0, (SCM (*)())(& scm_port_mode));
  }
#line 400 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/fports.c"
  return;
}
}
#line 109 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 157 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
#line 52 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.h"
long scm_tc16_fd  ;
#line 67 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.h"
long scm_tc16_dir  ;
#line 74
SCM scm_sys_chown(SCM path , SCM owner , SCM group ) ;
#line 75
SCM scm_sys_chmod(SCM port_or_path , SCM mode ) ;
#line 76
SCM scm_umask(SCM mode ) ;
#line 77
SCM scm_intern_fd(int fd , int flags ) ;
#line 78
SCM scm_sys_open(SCM path , SCM flags , SCM mode ) ;
#line 79
SCM scm_sys_create(SCM path , SCM mode ) ;
#line 80
SCM scm_sys_close(SCM sfd ) ;
#line 81
SCM scm_sys_write_fd(SCM sfd , SCM buf ) ;
#line 82
SCM scm_sys_read_fd(SCM sfd , SCM buf , SCM offset , SCM length ) ;
#line 83
SCM scm_sys_lseek(SCM sfd , SCM offset , SCM whence ) ;
#line 84
SCM scm_sys_dup(SCM oldfd , SCM newfd ) ;
#line 85
SCM scm_sys_stat(SCM fd_or_path ) ;
#line 86
SCM scm_sys_link(SCM oldpath , SCM newpath ) ;
#line 87
SCM scm_sys_rename(SCM oldname , SCM newname ) ;
#line 88
SCM scm_sys_delete_file(SCM str ) ;
#line 89
SCM scm_sys_mkdir(SCM path , SCM mode ) ;
#line 90
SCM scm_sys_rmdir(SCM path ) ;
#line 91
SCM scm_sys_opendir(SCM dirname ) ;
#line 92
SCM scm_sys_readdir(SCM port ) ;
#line 93
SCM scm_rewinddir(SCM port ) ;
#line 94
SCM scm_sys_closedir(SCM port ) ;
#line 95
SCM scm_sys_chdir(SCM str ) ;
#line 96
SCM scm_sys_getcwd(void) ;
#line 97
SCM scm_sys_select(SCM reads , SCM writes , SCM excepts , SCM secs , SCM msecs ) ;
#line 99
SCM scm_sys_symlink(SCM oldpath , SCM newpath ) ;
#line 100
SCM scm_sys_readlink(SCM path ) ;
#line 101
SCM scm_sys_lstat(SCM str ) ;
#line 102
SCM scm_sys_copy_file(SCM oldfile , SCM newfile ) ;
#line 331 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
#line 357
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 363
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 469
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chown)(char const   *__file ,
                                                                                  __uid_t __owner ,
                                                                                  __gid_t __group ) ;
#line 493
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chdir)(char const   *__path ) ;
#line 507
extern  __attribute__((__nothrow__)) char *getcwd(char *__buf , size_t __size ) ;
#line 806
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) link)(char const   *__from ,
                                                                                   char const   *__to ) ;
#line 819
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) symlink)(char const   *__from ,
                                                                                      char const   *__to ) ;
#line 825
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__nonnull__(1,2))) readlink)(char const   * __restrict  __path ,
                                                                                           char * __restrict  __buf ,
                                                                                           size_t __len ) ;
#line 842
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) unlink)(char const   *__name ) ;
#line 851
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) rmdir)(char const   *__path ) ;
#line 214 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) fstat)(int __fd ,
                                                                                  struct stat *__buf ) ;
#line 263
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) lstat)(char const   * __restrict  __file ,
                                                                                    struct stat * __restrict  __buf ) ;
#line 284
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chmod)(char const   *__file ,
                                                                                  __mode_t __mode ) ;
#line 297
extern  __attribute__((__nothrow__)) int fchmod(int __fd , __mode_t __mode ) ;
#line 312
extern  __attribute__((__nothrow__)) __mode_t umask(__mode_t __mask ) ;
#line 321
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) mkdir)(char const   *__path ,
                                                                                  __mode_t __mode ) ;
#line 73 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 118
extern int ( __attribute__((__nonnull__(1))) creat)(char const   *__file , __mode_t __mode ) ;
#line 135 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 150
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 163
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 209
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1))) rewinddir)(DIR *__dirp ) ;
#line 120 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static SCM scm_O_CREAT  =    (long )(16 << 9) + 372L;
#line 124 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static SCM scm_O_EXCL  =    (long )(16 << 9) + 372L;
#line 128 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static SCM scm_O_NOCTTY  =    (long )(16 << 9) + 372L;
#line 132 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static SCM scm_O_TRUNC  =    (long )(16 << 9) + 372L;
#line 136 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static SCM scm_O_APPEND  =    (long )(16 << 9) + 372L;
#line 140 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static SCM scm_O_NONBLOCK  =    (long )(16 << 9) + 372L;
#line 144 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static SCM scm_O_NDELAY  =    (long )(16 << 9) + 372L;
#line 148 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static SCM scm_O_SYNC  =    (long )(16 << 9) + 372L;
#line 158 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static char s_sys_chown[6]  = {      (char )'c',      (char )'h',      (char )'o',      (char )'w', 
        (char )'n',      (char )'\000'};
#line 160 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
SCM scm_sys_chown(SCM path , SCM owner , SCM group ) 
{ 
  int val ;
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;

  {
#line 168
  if (! (6 & (int )path)) {
#line 168
    if (! ((117 & (int )((scm_cell *)path)->car) == 21)) {
#line 168
      if (! ((125 & (int )((scm_cell *)path)->car) == 5)) {
        {
#line 168
        scm_wta(path, (char *)1, s_sys_chown);
        }
      }
    }
  } else {
    {
#line 168
    scm_wta(path, (char *)1, s_sys_chown);
    }
  }
#line 169
  if ((125 & (int )((scm_cell *)path)->car) == 29) {
#line 170
    if ((127 & (int )((scm_cell *)path)->car) == 29) {
#line 170
      tmp = (char *)((scm_cell *)((scm_cell *)((scm_cell *)path)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)path)->cdr)->car >> 2);
    } else {
#line 170
      tmp = (char *)((scm_cell *)path)->cdr;
    }
    {
#line 170
    path = scm_makfromstr((char const   *)tmp, (unsigned long )((scm_cell *)path)->car >> 8,
                          0);
    }
  }
#line 171
  if (! (2 & (int )owner)) {
    {
#line 171
    scm_wta(owner, (char *)2, s_sys_chown);
    }
  }
#line 172
  if (! (2 & (int )group)) {
    {
#line 172
    scm_wta(group, (char *)3, s_sys_chown);
    }
  }
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 173
    tmp___0 = __errno_location();
#line 173
    *tmp___0 = 0;
    }
#line 173
    if ((127 & (int )((scm_cell *)path)->car) == 29) {
#line 173
      tmp___1 = (char *)((scm_cell *)((scm_cell *)((scm_cell *)path)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)path)->cdr)->car >> 2);
    } else {
#line 173
      tmp___1 = (char *)((scm_cell *)path)->cdr;
    }
    {
#line 173
    val = chown((char const   *)tmp___1, (__uid_t )(owner >> 2), (__gid_t )(group >> 2));
#line 173
    tmp___2 = __errno_location();
    }
#line 173
    if (! (4 == *tmp___2)) {
#line 173
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  if (val != 0) {
    {
#line 176
    scm_syserror(s_sys_chown);
    }
  }
#line 177
  return ((long )(21 << 9) + 372L);
}
}
#line 181 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static char s_sys_chmod[6]  = {      (char )'c',      (char )'h',      (char )'m',      (char )'o', 
        (char )'d',      (char )'\000'};
#line 183 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
SCM scm_sys_chmod(SCM port_or_path , SCM mode ) 
{ 
  int rv ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
#line 189
  if (! (2 & (int )mode)) {
    {
#line 189
    scm_wta(mode, (char *)2, s_sys_chmod);
    }
  }
#line 190
  if (! (! (6 & (int )port_or_path))) {
    {
#line 190
    scm_wta(port_or_path, (char *)1, s_sys_chmod);
    }
  }
#line 191
  if ((125 & (int )((scm_cell *)port_or_path)->car) == 21) {
    {
#line 192
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 192
      tmp = __errno_location();
#line 192
      *tmp = 0;
#line 192
      rv = chmod((char const   *)((char *)((scm_cell *)port_or_path)->cdr), (__mode_t )(mode >> 2));
#line 192
      tmp___0 = __errno_location();
      }
#line 192
      if (! (4 == *tmp___0)) {
#line 192
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 195
    if (! (((65279L | (1L << 16)) & ((scm_cell *)port_or_path)->car) == (125L | (1L << 16)))) {
      {
#line 195
      scm_wta(port_or_path, (char *)1, s_sys_chmod);
      }
    }
    {
#line 196
    rv = fileno((FILE *)((struct scm_port_table *)((scm_cell *)port_or_path)->cdr)->stream);
    }
#line 197
    if (rv != -1) {
      {
#line 198
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 198
        tmp___1 = __errno_location();
#line 198
        *tmp___1 = 0;
#line 198
        rv = fchmod(rv, (__mode_t )(mode >> 2));
#line 198
        tmp___2 = __errno_location();
        }
#line 198
        if (! (4 == *tmp___2)) {
#line 198
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 200
  if (rv != 0) {
    {
#line 201
    scm_syserror(s_sys_chmod);
    }
  }
#line 202
  return ((long )(21 << 9) + 372L);
}
}
#line 205 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static char s_umask[6]  = {      (char )'u',      (char )'m',      (char )'a',      (char )'s', 
        (char )'k',      (char )'\000'};
#line 207 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
SCM scm_umask(SCM mode ) 
{ 
  mode_t mask ;

  {
#line 212
  if ((long )(18 << 9) + 372L == mode) {
    {
#line 214
    mask = umask((__mode_t )0);
#line 215
    umask(mask);
    }
  } else {
#line 219
    if (! (2 & (int )mode)) {
      {
#line 219
      scm_wta(mode, (char *)1, s_umask);
      }
    }
    {
#line 220
    mask = umask((__mode_t )(mode >> 2));
    }
  }
#line 222
  return ((long )(mask << 2) + 2L);
}
}
#line 231
static int scm_fd_print(SCM sexp , SCM port , scm_print_state *pstate ) ;
#line 233 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static int scm_fd_print(SCM sexp , SCM port , scm_print_state *pstate ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 239
  scm_gen_puts((enum scm_string_representation_type )0, (char *)"#<fd ", port);
#line 240
  scm_intprint(((scm_cell *)sexp)->cdr, 10, port);
#line 241
  scm_gen_puts((enum scm_string_representation_type )0, (char *)">", port);
  }
#line 242
  return (1);
}
}
#line 246
static size_t scm_fd_free(SCM p ) ;
#line 248 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static size_t scm_fd_free(SCM p ) 
{ 
  SCM flags ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 254
  flags = ((scm_cell *)p)->car >> 16;
#line 255
  if (2L & flags) {
#line 255
    if (1L & flags) {
      {
#line 257
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 257
        tmp = __errno_location();
#line 257
        *tmp = 0;
#line 257
        close((int )((scm_cell *)p)->cdr);
#line 257
        tmp___0 = __errno_location();
        }
#line 257
        if (! (4 == *tmp___0)) {
#line 257
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 259
  return ((size_t )0);
}
}
#line 262 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static scm_smobfuns fd_smob  =    {& scm_mark0, & scm_fd_free, & scm_fd_print, (SCM (*)(SCM  , SCM  ))0};
#line 265 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
SCM scm_intern_fd(int fd , int flags ) 
{ 
  SCM it ;

  {
#line 271
  if (6 & (int )scm_freelist) {
    {
#line 271
    it = scm_gc_for_newcell();
    }
  } else {
#line 271
    it = scm_freelist;
#line 271
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 271
    scm_cells_allocated ++;
  }
#line 272
  scm_ints_disabled ++;
#line 273
  ((scm_cell *)it)->car = scm_tc16_fd | (long )(flags << 16);
#line 274
  ((scm_cell *)it)->cdr = (SCM )fd;
#line 275
  scm_ints_disabled --;
#line 275
  if (! scm_ints_disabled) {
#line 275
    scm_async_clock --;
#line 275
    if (0U == scm_async_clock) {
      {
#line 275
      scm_async_click();
      }
    }
  }
#line 276
  return (it);
}
}
#line 281 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static char s_sys_open[5]  = {      (char )'o',      (char )'p',      (char )'e',      (char )'n', 
        (char )'\000'};
#line 283 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
SCM scm_sys_open(SCM path , SCM flags , SCM mode ) 
{ 
  int fd ;
  SCM sfd ;
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  SCM tmp___3 ;

  {
#line 292
  if (! (6 & (int )path)) {
#line 292
    if (! ((117 & (int )((scm_cell *)path)->car) == 21)) {
#line 292
      if (! ((125 & (int )((scm_cell *)path)->car) == 5)) {
        {
#line 292
        scm_wta(path, (char *)1, s_sys_open);
        }
      }
    }
  } else {
    {
#line 292
    scm_wta(path, (char *)1, s_sys_open);
    }
  }
#line 293
  if (! (2 & (int )flags)) {
    {
#line 293
    scm_wta(flags, (char *)2, s_sys_open);
    }
  }
#line 294
  if (! (2 & (int )mode)) {
    {
#line 294
    scm_wta(mode, (char *)3, s_sys_open);
    }
  }
#line 296
  if ((125 & (int )((scm_cell *)path)->car) == 29) {
#line 297
    if ((127 & (int )((scm_cell *)path)->car) == 29) {
#line 297
      tmp = (char *)((scm_cell *)((scm_cell *)((scm_cell *)path)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)path)->cdr)->car >> 2);
    } else {
#line 297
      tmp = (char *)((scm_cell *)path)->cdr;
    }
    {
#line 297
    path = scm_makfromstr((char const   *)tmp, (unsigned long )((scm_cell *)path)->car >> 8,
                          0);
    }
  }
#line 299
  scm_ints_disabled = 1;
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 300
    tmp___0 = __errno_location();
#line 300
    *tmp___0 = 0;
    }
#line 300
    if ((127 & (int )((scm_cell *)path)->car) == 29) {
#line 300
      tmp___1 = (char *)((scm_cell *)((scm_cell *)((scm_cell *)path)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)path)->cdr)->car >> 2);
    } else {
#line 300
      tmp___1 = (char *)((scm_cell *)path)->cdr;
    }
    {
#line 300
    fd = open((char const   *)tmp___1, (int )(flags >> 2), mode >> 2);
#line 300
    tmp___2 = __errno_location();
    }
#line 300
    if (! (4 == *tmp___2)) {
#line 300
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 301
  if (fd == -1) {
    {
#line 302
    scm_syserror(s_sys_open);
    }
  }
  {
#line 303
  sfd = scm_intern_fd(fd, 3);
#line 304
  scm_ints_disabled = 0;
#line 304
  scm_async_clock --;
  }
#line 304
  if (0U == scm_async_clock) {
    {
#line 304
    scm_async_click();
    }
  }
  {
#line 306
  tmp___3 = scm_return_first(sfd, path);
  }
#line 306
  return (tmp___3);
}
}
#line 310 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static char s_sys_create[7]  = {      (char )'c',      (char )'r',      (char )'e',      (char )'a', 
        (char )'t',      (char )'e',      (char )'\000'};
#line 312 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
SCM scm_sys_create(SCM path , SCM mode ) 
{ 
  int fd ;
  SCM sfd ;
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  SCM tmp___3 ;

  {
#line 320
  if (! (6 & (int )path)) {
#line 320
    if (! ((117 & (int )((scm_cell *)path)->car) == 21)) {
#line 320
      if (! ((125 & (int )((scm_cell *)path)->car) == 5)) {
        {
#line 320
        scm_wta(path, (char *)1, s_sys_create);
        }
      }
    }
  } else {
    {
#line 320
    scm_wta(path, (char *)1, s_sys_create);
    }
  }
#line 321
  if (! (2 & (int )mode)) {
    {
#line 321
    scm_wta(mode, (char *)2, s_sys_create);
    }
  }
#line 323
  if ((125 & (int )((scm_cell *)path)->car) == 29) {
#line 324
    if ((127 & (int )((scm_cell *)path)->car) == 29) {
#line 324
      tmp = (char *)((scm_cell *)((scm_cell *)((scm_cell *)path)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)path)->cdr)->car >> 2);
    } else {
#line 324
      tmp = (char *)((scm_cell *)path)->cdr;
    }
    {
#line 324
    path = scm_makfromstr((char const   *)tmp, (unsigned long )((scm_cell *)path)->car >> 8,
                          0);
    }
  }
#line 326
  scm_ints_disabled = 1;
  {
#line 327
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 327
    tmp___0 = __errno_location();
#line 327
    *tmp___0 = 0;
    }
#line 327
    if ((127 & (int )((scm_cell *)path)->car) == 29) {
#line 327
      tmp___1 = (char *)((scm_cell *)((scm_cell *)((scm_cell *)path)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)path)->cdr)->car >> 2);
    } else {
#line 327
      tmp___1 = (char *)((scm_cell *)path)->cdr;
    }
    {
#line 327
    fd = creat((char const   *)tmp___1, (__mode_t )(mode >> 2));
#line 327
    tmp___2 = __errno_location();
    }
#line 327
    if (! (4 == *tmp___2)) {
#line 327
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 328
  if (fd == -1) {
    {
#line 329
    scm_syserror(s_sys_create);
    }
  }
  {
#line 330
  sfd = scm_intern_fd(fd, 3);
#line 331
  scm_ints_disabled = 0;
#line 331
  scm_async_clock --;
  }
#line 331
  if (0U == scm_async_clock) {
    {
#line 331
    scm_async_click();
    }
  }
  {
#line 333
  tmp___3 = scm_return_first(sfd, path);
  }
#line 333
  return (tmp___3);
}
}
#line 337 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static char s_sys_close[6]  = {      (char )'c',      (char )'l',      (char )'o',      (char )'s', 
        (char )'e',      (char )'\000'};
#line 339 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
SCM scm_sys_close(SCM sfd ) 
{ 
  int fd ;
  int got ;

  {
#line 345
  if (! (6 & (int )sfd)) {
#line 345
    if (! ((long )(65535 & (int )((scm_cell *)sfd)->car) == scm_tc16_fd)) {
      {
#line 345
      scm_wta(sfd, (char *)1, s_sys_close);
      }
    }
  } else {
    {
#line 345
    scm_wta(sfd, (char *)1, s_sys_close);
    }
  }
  {
#line 346
  fd = (int )((scm_cell *)sfd)->cdr;
#line 348
  scm_ints_disabled = 1;
#line 349
  got = close(fd);
#line 350
  ((scm_cell *)sfd)->car = scm_tc16_fd;
#line 351
  scm_ints_disabled = 0;
#line 351
  scm_async_clock --;
  }
#line 351
  if (0U == scm_async_clock) {
    {
#line 351
    scm_async_click();
    }
  }
#line 352
  if (got == -1) {
    {
#line 353
    scm_syserror(s_sys_close);
    }
  }
#line 354
  return ((long )(21 << 9) + 372L);
}
}
#line 358 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static char s_sys_write_fd[9]  = 
#line 358
  {      (char )'w',      (char )'r',      (char )'i',      (char )'t', 
        (char )'e',      (char )'-',      (char )'f',      (char )'d', 
        (char )'\000'};
#line 360 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
SCM scm_sys_write_fd(SCM sfd , SCM buf ) 
{ 
  SCM answer ;
  int fd ;
  size_t written ;
  char *tmp ;
  ssize_t tmp___0 ;
  SCM tmp___1 ;

  {
#line 368
  if (! (6 & (int )sfd)) {
#line 368
    if (! ((long )(65535 & (int )((scm_cell *)sfd)->car) == scm_tc16_fd)) {
      {
#line 368
      scm_wta(sfd, (char *)1, s_sys_write_fd);
      }
    }
  } else {
    {
#line 368
    scm_wta(sfd, (char *)1, s_sys_write_fd);
    }
  }
#line 369
  if (! (6 & (int )buf)) {
#line 369
    if (! ((117 & (int )((scm_cell *)buf)->car) == 21)) {
#line 369
      if (! ((125 & (int )((scm_cell *)buf)->car) == 5)) {
        {
#line 369
        scm_wta(buf, (char *)2, s_sys_write_fd);
        }
      }
    }
  } else {
    {
#line 369
    scm_wta(buf, (char *)2, s_sys_write_fd);
    }
  }
#line 370
  fd = (int )((scm_cell *)sfd)->cdr;
#line 371
  scm_ints_disabled = 1;
#line 372
  if ((127 & (int )((scm_cell *)buf)->car) == 29) {
#line 372
    tmp = (char *)((scm_cell *)((scm_cell *)((scm_cell *)buf)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)buf)->cdr)->car >> 2);
  } else {
#line 372
    tmp = (char *)((scm_cell *)buf)->cdr;
  }
  {
#line 372
  tmp___0 = write(fd, (void const   *)tmp, (unsigned long )((scm_cell *)buf)->car >> 8);
#line 372
  written = (size_t )tmp___0;
  }
#line 373
  if (written == 0xffffffffffffffffUL) {
    {
#line 374
    scm_syserror(s_sys_write_fd);
    }
  }
  {
#line 375
  answer = scm_long2num((long )written);
#line 376
  scm_ints_disabled = 0;
#line 376
  scm_async_clock --;
  }
#line 376
  if (0U == scm_async_clock) {
    {
#line 376
    scm_async_click();
    }
  }
  {
#line 377
  tmp___1 = scm_return_first(answer, buf);
  }
#line 377
  return (tmp___1);
}
}
#line 381 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static char s_sys_read_fd[8]  = 
#line 381
  {      (char )'r',      (char )'e',      (char )'a',      (char )'d', 
        (char )'-',      (char )'f',      (char )'d',      (char )'\000'};
#line 383 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
SCM scm_sys_read_fd(SCM sfd , SCM buf , SCM offset , SCM length ) 
{ 
  SCM answer ;
  int fd ;
  char *bytes ;
  int off ;
  int len ;
  size_t got ;
  ssize_t tmp ;
  SCM tmp___0 ;

  {
#line 397
  if (! (6 & (int )sfd)) {
#line 397
    if (! ((long )(65535 & (int )((scm_cell *)sfd)->car) == scm_tc16_fd)) {
      {
#line 397
      scm_wta(sfd, (char *)1, s_sys_read_fd);
      }
    }
  } else {
    {
#line 397
    scm_wta(sfd, (char *)1, s_sys_read_fd);
    }
  }
#line 398
  fd = (int )((scm_cell *)sfd)->cdr;
#line 400
  if (! (6 & (int )buf)) {
#line 400
    if (! ((125 & (int )((scm_cell *)buf)->car) == 21)) {
      {
#line 400
      scm_wta(buf, (char *)2, s_sys_read_fd);
      }
    }
  } else {
    {
#line 400
    scm_wta(buf, (char *)2, s_sys_read_fd);
    }
  }
#line 401
  bytes = (char *)((scm_cell *)buf)->cdr;
#line 403
  if ((long )(18 << 9) + 372L == offset) {
#line 404
    off = 0;
  } else {
#line 407
    if (! (2 & (int )offset)) {
      {
#line 407
      scm_wta(offset, (char *)3, s_sys_read_fd);
      }
    }
#line 408
    off = (int )(offset >> 2);
  }
#line 411
  if ((long )(18 << 9) + 372L == length) {
#line 412
    len = (int )((unsigned long )((scm_cell *)buf)->car >> 8);
  } else {
#line 415
    if (! (2 & (int )length)) {
      {
#line 415
      scm_wta(length, (char *)3, s_sys_read_fd);
      }
    }
#line 416
    len = (int )(length >> 2);
  }
  {
#line 419
  scm_ints_disabled = 1;
#line 420
  tmp = read(fd, (void *)(bytes + off), (size_t )len);
#line 420
  got = (size_t )tmp;
  }
#line 421
  if (got == 0xffffffffffffffffUL) {
    {
#line 422
    scm_syserror(s_sys_read_fd);
    }
  }
  {
#line 423
  answer = scm_long2num((long )got);
#line 424
  scm_ints_disabled = 0;
#line 424
  scm_async_clock --;
  }
#line 424
  if (0U == scm_async_clock) {
    {
#line 424
    scm_async_click();
    }
  }
  {
#line 425
  tmp___0 = scm_return_first(answer, buf);
  }
#line 425
  return (tmp___0);
}
}
#line 428 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static char s_sys_lseek[6]  = {      (char )'l',      (char )'s',      (char )'e',      (char )'e', 
        (char )'k',      (char )'\000'};
#line 430 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
SCM scm_sys_lseek(SCM sfd , SCM offset , SCM whence ) 
{ 
  SCM answer ;
  int fd ;
  long off ;
  int wh ;
  long got ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 442
  if (! (6 & (int )sfd)) {
#line 442
    if (! ((long )(65535 & (int )((scm_cell *)sfd)->car) == scm_tc16_fd)) {
      {
#line 442
      scm_wta(sfd, (char *)1, s_sys_lseek);
      }
    }
  } else {
    {
#line 442
    scm_wta(sfd, (char *)1, s_sys_lseek);
    }
  }
  {
#line 443
  fd = (int )((scm_cell *)sfd)->cdr;
#line 445
  off = scm_num2long(offset, (char *)2, s_sys_lseek);
  }
#line 446
  if ((long )(18 << 9) + 372L == whence) {
#line 447
    wh = 0;
  } else {
#line 450
    if (! (2 & (int )whence)) {
      {
#line 450
      scm_wta(whence, (char *)3, s_sys_lseek);
      }
    }
#line 451
    wh = (int )(whence >> 2);
  }
#line 454
  scm_ints_disabled = 1;
  {
#line 455
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 455
    tmp = __errno_location();
#line 455
    *tmp = 0;
#line 455
    got = lseek(fd, off, wh);
#line 455
    tmp___0 = __errno_location();
    }
#line 455
    if (! (4 == *tmp___0)) {
#line 455
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 456
  if (got == -1L) {
    {
#line 457
    scm_syserror(s_sys_lseek);
    }
  }
  {
#line 458
  answer = scm_long2num(got);
#line 459
  scm_ints_disabled = 0;
#line 459
  scm_async_clock --;
  }
#line 459
  if (0U == scm_async_clock) {
    {
#line 459
    scm_async_click();
    }
  }
#line 460
  return (answer);
}
}
#line 464 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static char s_sys_dup[4]  = {      (char )'d',      (char )'u',      (char )'p',      (char )'\000'};
#line 466 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
SCM scm_sys_dup(SCM oldfd , SCM newfd ) 
{ 
  SCM answer ;
  int fd ;
  int nfd ;
  int (*fn)() ;

  {
#line 476
  if (! (6 & (int )oldfd)) {
#line 476
    if (! ((long )(65535 & (int )((scm_cell *)oldfd)->car) == scm_tc16_fd)) {
      {
#line 476
      scm_wta(oldfd, (char *)1, s_sys_dup);
      }
    }
  } else {
    {
#line 476
    scm_wta(oldfd, (char *)1, s_sys_dup);
    }
  }
#line 477
  if (! ((long )(18 << 9) + 372L == newfd)) {
#line 477
    if (! (2 & (int )newfd)) {
      {
#line 477
      scm_wta(newfd, (char *)2, s_sys_dup);
      }
    }
  }
#line 478
  fd = (int )((scm_cell *)oldfd)->cdr;
#line 479
  if (2 & (int )newfd) {
#line 479
    nfd = (int )(newfd >> 2);
  } else {
#line 479
    nfd = -1;
  }
#line 481
  scm_ints_disabled = 1;
#line 482
  if (nfd == -1) {
#line 482
    fn = (int (*)())(& dup);
  } else {
#line 482
    fn = (int (*)())(& dup2);
  }
  {
#line 483
  nfd = (*fn)(fd, nfd);
  }
#line 484
  if (nfd == -1) {
    {
#line 485
    scm_syserror(s_sys_dup);
    }
  }
#line 486
  answer = (long )(nfd << 2) + 2L;
#line 487
  scm_ints_disabled = 0;
#line 487
  scm_async_clock --;
#line 487
  if (0U == scm_async_clock) {
    {
#line 487
    scm_async_click();
    }
  }
#line 488
  return (answer);
}
}
#line 496 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static SCM scm_sym_regular  =    (long )(16 << 9) + 372L;
#line 497 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static SCM scm_sym_directory  =    (long )(16 << 9) + 372L;
#line 498 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static SCM scm_sym_symlink  =    (long )(16 << 9) + 372L;
#line 499 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static SCM scm_sym_block_special  =    (long )(16 << 9) + 372L;
#line 500 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static SCM scm_sym_char_special  =    (long )(16 << 9) + 372L;
#line 501 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static SCM scm_sym_fifo  =    (long )(16 << 9) + 372L;
#line 502 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static SCM scm_sym_sock  =    (long )(16 << 9) + 372L;
#line 503 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static SCM scm_sym_unknown  =    (long )(16 << 9) + 372L;
#line 505
static SCM scm_stat2scm(struct stat *stat_temp ) ;
#line 507 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static SCM scm_stat2scm(struct stat *stat_temp ) 
{ 
  SCM ans ;
  SCM tmp ;
  SCM *ve ;
  int mode ;

  {
  {
#line 511
  tmp = scm_make_vector((long )(15 << 2) + 2L, (long )(21 << 9) + 372L, (long )(16 << 9) + 372L);
#line 511
  ans = tmp;
#line 512
  ve = (SCM *)((scm_cell *)ans)->cdr;
#line 514
  *(ve + 0) = scm_ulong2num(stat_temp->st_dev);
#line 515
  *(ve + 1) = scm_ulong2num(stat_temp->st_ino);
#line 516
  *(ve + 2) = scm_ulong2num((unsigned long )stat_temp->st_mode);
#line 517
  *(ve + 3) = scm_ulong2num(stat_temp->st_nlink);
#line 518
  *(ve + 4) = scm_ulong2num((unsigned long )stat_temp->st_uid);
#line 519
  *(ve + 5) = scm_ulong2num((unsigned long )stat_temp->st_gid);
#line 521
  *(ve + 6) = scm_ulong2num(stat_temp->st_rdev);
#line 525
  *(ve + 7) = scm_ulong2num((unsigned long )stat_temp->st_size);
#line 526
  *(ve + 8) = scm_ulong2num((unsigned long )stat_temp->st_atim.tv_sec);
#line 527
  *(ve + 9) = scm_ulong2num((unsigned long )stat_temp->st_mtim.tv_sec);
#line 528
  *(ve + 10) = scm_ulong2num((unsigned long )stat_temp->st_ctim.tv_sec);
#line 530
  *(ve + 11) = scm_ulong2num((unsigned long )stat_temp->st_blksize);
#line 535
  *(ve + 12) = scm_ulong2num((unsigned long )stat_temp->st_blocks);
#line 540
  mode = (int )stat_temp->st_mode;
  }
#line 542
  if ((mode & 61440) == 32768) {
#line 543
    *(ve + 13) = scm_sym_regular;
  } else
#line 544
  if ((mode & 61440) == 16384) {
#line 545
    *(ve + 13) = scm_sym_directory;
  } else
#line 546
  if ((mode & 61440) == 40960) {
#line 547
    *(ve + 13) = scm_sym_symlink;
  } else
#line 548
  if ((mode & 61440) == 24576) {
#line 549
    *(ve + 13) = scm_sym_block_special;
  } else
#line 550
  if ((mode & 61440) == 8192) {
#line 551
    *(ve + 13) = scm_sym_char_special;
  } else
#line 552
  if ((mode & 61440) == 4096) {
#line 553
    *(ve + 13) = scm_sym_fifo;
  } else
#line 554
  if ((mode & 61440) == 49152) {
#line 555
    *(ve + 13) = scm_sym_sock;
  } else {
#line 557
    *(ve + 13) = scm_sym_unknown;
  }
#line 559
  *(ve + 14) = (long )((-61441 & mode) << 2) + 2L;
#line 593
  return (ans);
}
}
#line 596 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static char s_sys_stat[5]  = {      (char )'s',      (char )'t',      (char )'a',      (char )'t', 
        (char )'\000'};
#line 598 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
SCM scm_sys_stat(SCM fd_or_path ) 
{ 
  int rv ;
  struct stat stat_temp ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  SCM tmp___8 ;
  SCM tmp___9 ;
  SCM tmp___10 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 602
  rv = 1;
#line 605
  if (2 & (int )fd_or_path) {
#line 607
    rv = (int )(fd_or_path >> 2);
    {
#line 608
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 608
      tmp = __errno_location();
#line 608
      *tmp = 0;
#line 608
      rv = fstat(rv, & stat_temp);
#line 608
      tmp___0 = __errno_location();
      }
#line 608
      if (! (4 == *tmp___0)) {
#line 608
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 610
  if (! (6 & (int )fd_or_path)) {
#line 610
    if ((long )(65535 & (int )((scm_cell *)fd_or_path)->car) == scm_tc16_fd) {
#line 612
      rv = (int )((scm_cell *)fd_or_path)->cdr;
      {
#line 613
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 613
        tmp___1 = __errno_location();
#line 613
        *tmp___1 = 0;
#line 613
        rv = fstat(rv, & stat_temp);
#line 613
        tmp___2 = __errno_location();
        }
#line 613
        if (! (4 == *tmp___2)) {
#line 613
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 610
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 617
    if (! (! (6 & (int )fd_or_path))) {
      {
#line 617
      scm_wta(fd_or_path, (char *)1, s_sys_stat);
      }
    }
#line 618
    if (! ((117 & (int )((scm_cell *)fd_or_path)->car) == 21)) {
#line 618
      if (! ((125 & (int )((scm_cell *)fd_or_path)->car) == 5)) {
        {
#line 618
        scm_wta(fd_or_path, (char *)1, s_sys_stat);
        }
      }
    }
#line 619
    if ((117 & (int )((scm_cell *)fd_or_path)->car) == 21) {
#line 619
      goto _L;
    } else
#line 619
    if ((125 & (int )((scm_cell *)fd_or_path)->car) == 5) {
      _L: /* CIL Label */ 
#line 621
      if ((125 & (int )((scm_cell *)fd_or_path)->car) == 29) {
#line 622
        if ((127 & (int )((scm_cell *)fd_or_path)->car) == 29) {
#line 622
          tmp___3 = (char *)((scm_cell *)((scm_cell *)((scm_cell *)fd_or_path)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)fd_or_path)->cdr)->car >> 2);
        } else {
#line 622
          tmp___3 = (char *)((scm_cell *)fd_or_path)->cdr;
        }
        {
#line 622
        fd_or_path = scm_makfromstr((char const   *)tmp___3, (unsigned long )((scm_cell *)fd_or_path)->car >> 8,
                                    0);
        }
      }
      {
#line 623
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 623
        tmp___4 = __errno_location();
#line 623
        *tmp___4 = 0;
#line 623
        rv = stat((char const   */* __restrict  */)((char *)((scm_cell *)fd_or_path)->cdr),
                  (struct stat */* __restrict  */)(& stat_temp));
#line 623
        tmp___5 = __errno_location();
        }
#line 623
        if (! (4 == *tmp___5)) {
#line 623
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
#line 627
  if (rv != 0) {
    {
#line 628
    tmp___6 = __errno_location();
#line 628
    tmp___7 = strerror(*tmp___6);
#line 628
    tmp___8 = scm_makfrom0str((char const   *)tmp___7);
#line 628
    tmp___9 = scm_listify(tmp___8, fd_or_path, (long )(18 << 9) + 372L);
#line 628
    scm_syserror_msg(s_sys_stat, (char *)"%s: %S", tmp___9);
    }
  }
  {
#line 632
  tmp___10 = scm_stat2scm(& stat_temp);
  }
#line 632
  return (tmp___10);
}
}
#line 640 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static char s_sys_link[5]  = {      (char )'l',      (char )'i',      (char )'n',      (char )'k', 
        (char )'\000'};
#line 642 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
SCM scm_sys_link(SCM oldpath , SCM newpath ) 
{ 
  int val ;
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;

  {
#line 649
  if (! (6 & (int )oldpath)) {
#line 649
    if (! ((117 & (int )((scm_cell *)oldpath)->car) == 21)) {
#line 649
      if (! ((125 & (int )((scm_cell *)oldpath)->car) == 5)) {
        {
#line 649
        scm_wta(oldpath, (char *)1, s_sys_link);
        }
      }
    }
  } else {
    {
#line 649
    scm_wta(oldpath, (char *)1, s_sys_link);
    }
  }
#line 650
  if ((125 & (int )((scm_cell *)oldpath)->car) == 29) {
#line 651
    if ((127 & (int )((scm_cell *)oldpath)->car) == 29) {
#line 651
      tmp = (char *)((scm_cell *)((scm_cell *)((scm_cell *)oldpath)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)oldpath)->cdr)->car >> 2);
    } else {
#line 651
      tmp = (char *)((scm_cell *)oldpath)->cdr;
    }
    {
#line 651
    oldpath = scm_makfromstr((char const   *)tmp, (unsigned long )((scm_cell *)oldpath)->car >> 8,
                             0);
    }
  }
#line 652
  if (! (6 & (int )newpath)) {
#line 652
    if (! ((117 & (int )((scm_cell *)newpath)->car) == 21)) {
#line 652
      if (! ((125 & (int )((scm_cell *)newpath)->car) == 5)) {
        {
#line 652
        scm_wta(newpath, (char *)2, s_sys_link);
        }
      }
    }
  } else {
    {
#line 652
    scm_wta(newpath, (char *)2, s_sys_link);
    }
  }
#line 653
  if ((125 & (int )((scm_cell *)newpath)->car) == 29) {
#line 654
    if ((127 & (int )((scm_cell *)newpath)->car) == 29) {
#line 654
      tmp___0 = (char *)((scm_cell *)((scm_cell *)((scm_cell *)newpath)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)newpath)->cdr)->car >> 2);
    } else {
#line 654
      tmp___0 = (char *)((scm_cell *)newpath)->cdr;
    }
    {
#line 654
    newpath = scm_makfromstr((char const   *)tmp___0, (unsigned long )((scm_cell *)newpath)->car >> 8,
                             0);
    }
  }
  {
#line 655
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 655
    tmp___1 = __errno_location();
#line 655
    *tmp___1 = 0;
    }
#line 655
    if ((127 & (int )((scm_cell *)newpath)->car) == 29) {
#line 655
      tmp___2 = (char *)((scm_cell *)((scm_cell *)((scm_cell *)newpath)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)newpath)->cdr)->car >> 2);
    } else {
#line 655
      tmp___2 = (char *)((scm_cell *)newpath)->cdr;
    }
#line 655
    if ((127 & (int )((scm_cell *)oldpath)->car) == 29) {
#line 655
      tmp___3 = (char *)((scm_cell *)((scm_cell *)((scm_cell *)oldpath)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)oldpath)->cdr)->car >> 2);
    } else {
#line 655
      tmp___3 = (char *)((scm_cell *)oldpath)->cdr;
    }
    {
#line 655
    val = link((char const   *)tmp___3, (char const   *)tmp___2);
#line 655
    tmp___4 = __errno_location();
    }
#line 655
    if (! (4 == *tmp___4)) {
#line 655
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 656
  if (val != 0) {
    {
#line 657
    scm_syserror(s_sys_link);
    }
  }
#line 658
  return ((long )(21 << 9) + 372L);
}
}
#line 663 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static char s_sys_rename[12]  = 
#line 663
  {      (char )'r',      (char )'e',      (char )'n',      (char )'a', 
        (char )'m',      (char )'e',      (char )'-',      (char )'f', 
        (char )'i',      (char )'l',      (char )'e',      (char )'\000'};
#line 665 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
SCM scm_sys_rename(SCM oldname , SCM newname ) 
{ 
  int rv ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 671
  if (! (6 & (int )oldname)) {
#line 671
    if (! ((125 & (int )((scm_cell *)oldname)->car) == 21)) {
      {
#line 671
      scm_wta(oldname, (char *)1, s_sys_rename);
      }
    }
  } else {
    {
#line 671
    scm_wta(oldname, (char *)1, s_sys_rename);
    }
  }
#line 672
  if (! (6 & (int )newname)) {
#line 672
    if (! ((125 & (int )((scm_cell *)newname)->car) == 21)) {
      {
#line 672
      scm_wta(newname, (char *)2, s_sys_rename);
      }
    }
  } else {
    {
#line 672
    scm_wta(newname, (char *)2, s_sys_rename);
    }
  }
  {
#line 674
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 674
    tmp = __errno_location();
#line 674
    *tmp = 0;
#line 674
    rv = rename((char const   *)((char *)((scm_cell *)oldname)->cdr), (char const   *)((char *)((scm_cell *)newname)->cdr));
#line 674
    tmp___0 = __errno_location();
    }
#line 674
    if (! (4 == *tmp___0)) {
#line 674
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 675
  if (rv != 0) {
    {
#line 676
    scm_syserror(s_sys_rename);
    }
  }
#line 677
  return ((long )(21 << 9) + 372L);
}
}
#line 696 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static char s_sys_delete_file[12]  = 
#line 696
  {      (char )'d',      (char )'e',      (char )'l',      (char )'e', 
        (char )'t',      (char )'e',      (char )'-',      (char )'f', 
        (char )'i',      (char )'l',      (char )'e',      (char )'\000'};
#line 698 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
SCM scm_sys_delete_file(SCM str ) 
{ 
  int ans ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 703
  if (! (6 & (int )str)) {
#line 703
    if (! ((125 & (int )((scm_cell *)str)->car) == 21)) {
      {
#line 703
      scm_wta(str, (char *)1, s_sys_delete_file);
      }
    }
  } else {
    {
#line 703
    scm_wta(str, (char *)1, s_sys_delete_file);
    }
  }
  {
#line 704
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 704
    tmp = __errno_location();
#line 704
    *tmp = 0;
#line 704
    ans = unlink((char const   *)((char *)((scm_cell *)str)->cdr));
#line 704
    tmp___0 = __errno_location();
    }
#line 704
    if (! (4 == *tmp___0)) {
#line 704
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 705
  if (ans != 0) {
    {
#line 706
    scm_syserror(s_sys_delete_file);
    }
  }
#line 707
  return ((long )(21 << 9) + 372L);
}
}
#line 711 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static char s_sys_mkdir[6]  = {      (char )'m',      (char )'k',      (char )'d',      (char )'i', 
        (char )'r',      (char )'\000'};
#line 713 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
SCM scm_sys_mkdir(SCM path , SCM mode ) 
{ 
  int rv ;
  mode_t mask ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
#line 721
  if (! (6 & (int )path)) {
#line 721
    if (! ((125 & (int )((scm_cell *)path)->car) == 21)) {
      {
#line 721
      scm_wta(path, (char *)1, s_sys_mkdir);
      }
    }
  } else {
    {
#line 721
    scm_wta(path, (char *)1, s_sys_mkdir);
    }
  }
#line 722
  if ((long )(18 << 9) + 372L == mode) {
    {
#line 724
    mask = umask((__mode_t )0);
#line 725
    umask(mask);
    }
    {
#line 726
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 726
      tmp = __errno_location();
#line 726
      *tmp = 0;
#line 726
      rv = mkdir((char const   *)((char *)((scm_cell *)path)->cdr), 511U ^ mask);
#line 726
      tmp___0 = __errno_location();
      }
#line 726
      if (! (4 == *tmp___0)) {
#line 726
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 730
    if (! (2 & (int )mode)) {
      {
#line 730
      scm_wta(mode, (char *)2, s_sys_mkdir);
      }
    }
    {
#line 731
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 731
      tmp___1 = __errno_location();
#line 731
      *tmp___1 = 0;
#line 731
      rv = mkdir((char const   *)((char *)((scm_cell *)path)->cdr), (__mode_t )(mode >> 2));
#line 731
      tmp___2 = __errno_location();
      }
#line 731
      if (! (4 == *tmp___2)) {
#line 731
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 733
  if (rv != 0) {
    {
#line 734
    scm_syserror(s_sys_mkdir);
    }
  }
#line 735
  return ((long )(21 << 9) + 372L);
}
}
#line 744 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static char s_sys_rmdir[6]  = {      (char )'r',      (char )'m',      (char )'d',      (char )'i', 
        (char )'r',      (char )'\000'};
#line 746 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
SCM scm_sys_rmdir(SCM path ) 
{ 
  int val ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 753
  if (! (6 & (int )path)) {
#line 753
    if (! ((125 & (int )((scm_cell *)path)->car) == 21)) {
      {
#line 753
      scm_wta(path, (char *)1, s_sys_rmdir);
      }
    }
  } else {
    {
#line 753
    scm_wta(path, (char *)1, s_sys_rmdir);
    }
  }
  {
#line 754
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 754
    tmp = __errno_location();
#line 754
    *tmp = 0;
#line 754
    val = rmdir((char const   *)((char *)((scm_cell *)path)->cdr));
#line 754
    tmp___0 = __errno_location();
    }
#line 754
    if (! (4 == *tmp___0)) {
#line 754
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 755
  if (val != 0) {
    {
#line 756
    scm_syserror(s_sys_rmdir);
    }
  }
#line 757
  return ((long )(21 << 9) + 372L);
}
}
#line 771 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static char s_sys_opendir[8]  = 
#line 771
  {      (char )'o',      (char )'p',      (char )'e',      (char )'n', 
        (char )'d',      (char )'i',      (char )'r',      (char )'\000'};
#line 773 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
SCM scm_sys_opendir(SCM dirname ) 
{ 
  DIR *ds ;
  SCM dir ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 779
  if (! (6 & (int )dirname)) {
#line 779
    if (! ((125 & (int )((scm_cell *)dirname)->car) == 21)) {
      {
#line 779
      scm_wta(dirname, (char *)1, s_sys_opendir);
      }
    }
  } else {
    {
#line 779
    scm_wta(dirname, (char *)1, s_sys_opendir);
    }
  }
#line 780
  if (6 & (int )scm_freelist) {
    {
#line 780
    dir = scm_gc_for_newcell();
    }
  } else {
#line 780
    dir = scm_freelist;
#line 780
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 780
    scm_cells_allocated ++;
  }
#line 781
  scm_ints_disabled = 1;
  {
#line 782
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 782
    tmp = __errno_location();
#line 782
    *tmp = 0;
#line 782
    ds = opendir((char const   *)((char *)((scm_cell *)dirname)->cdr));
#line 782
    tmp___0 = __errno_location();
    }
#line 782
    if (! (4 == *tmp___0)) {
#line 782
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 783
  if ((unsigned long )ds == (unsigned long )((void *)0)) {
    {
#line 784
    scm_syserror(s_sys_opendir);
    }
  }
#line 785
  ((scm_cell *)dir)->car = scm_tc16_dir | (1L << 16);
#line 786
  ((scm_cell *)dir)->cdr = (SCM )ds;
#line 787
  scm_ints_disabled = 0;
#line 787
  scm_async_clock --;
#line 787
  if (0U == scm_async_clock) {
    {
#line 787
    scm_async_click();
    }
  }
#line 788
  return (dir);
}
}
#line 792 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static char s_sys_readdir[8]  = 
#line 792
  {      (char )'r',      (char )'e',      (char )'a',      (char )'d', 
        (char )'d',      (char )'i',      (char )'r',      (char )'\000'};
#line 794 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
SCM scm_sys_readdir(SCM port ) 
{ 
  struct dirent *rdent ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  size_t tmp___3 ;
  SCM tmp___4 ;
  SCM tmp___5 ;

  {
#line 799
  scm_ints_disabled = 1;
#line 800
  if (! (6 & (int )port)) {
#line 800
    if (! (((scm_cell *)port)->car == (scm_tc16_dir | (1L << 16)))) {
      {
#line 800
      scm_wta(port, (char *)1, s_sys_readdir);
      }
    }
  } else {
    {
#line 800
    scm_wta(port, (char *)1, s_sys_readdir);
    }
  }
  {
#line 801
  tmp = __errno_location();
#line 801
  *tmp = 0;
  }
  {
#line 802
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 802
    tmp___0 = __errno_location();
#line 802
    *tmp___0 = 0;
#line 802
    rdent = readdir((DIR *)((scm_cell *)port)->cdr);
#line 802
    tmp___1 = __errno_location();
    }
#line 802
    if (! (4 == *tmp___1)) {
#line 802
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 803
  scm_ints_disabled = 0;
#line 803
  scm_async_clock --;
#line 803
  if (0U == scm_async_clock) {
    {
#line 803
    scm_async_click();
    }
  }
  {
#line 804
  tmp___2 = __errno_location();
  }
#line 804
  if (*tmp___2 != 0) {
    {
#line 805
    scm_syserror(s_sys_readdir);
    }
  }
#line 806
  if (rdent) {
    {
#line 806
    tmp___3 = strlen((char const   *)(rdent->d_name));
#line 806
    tmp___4 = scm_makfromstr((char const   *)(rdent->d_name), tmp___3, 0);
#line 806
    tmp___5 = tmp___4;
    }
  } else {
#line 806
    tmp___5 = (long )(19 << 9) + 372L;
  }
#line 806
  return (tmp___5);
}
}
#line 812 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static char s_rewinddir[10]  = 
#line 812
  {      (char )'r',      (char )'e',      (char )'w',      (char )'i', 
        (char )'n',      (char )'d',      (char )'d',      (char )'i', 
        (char )'r',      (char )'\000'};
#line 814 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
SCM scm_rewinddir(SCM port ) 
{ 


  {
#line 818
  if (! (6 & (int )port)) {
#line 818
    if (! (((scm_cell *)port)->car == (scm_tc16_dir | (1L << 16)))) {
      {
#line 818
      scm_wta(port, (char *)1, s_rewinddir);
      }
    }
  } else {
    {
#line 818
    scm_wta(port, (char *)1, s_rewinddir);
    }
  }
  {
#line 819
  rewinddir((DIR *)((scm_cell *)port)->cdr);
  }
#line 820
  return ((long )(21 << 9) + 372L);
}
}
#line 825 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static char s_sys_closedir[9]  = 
#line 825
  {      (char )'c',      (char )'l',      (char )'o',      (char )'s', 
        (char )'e',      (char )'d',      (char )'i',      (char )'r', 
        (char )'\000'};
#line 827 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
SCM scm_sys_closedir(SCM port ) 
{ 
  int sts ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 833
  if (! (6 & (int )port)) {
#line 833
    if (! ((long )(65535 & (int )((scm_cell *)port)->car) == scm_tc16_dir)) {
      {
#line 833
      scm_wta(port, (char *)1, s_sys_closedir);
      }
    }
  } else {
    {
#line 833
    scm_wta(port, (char *)1, s_sys_closedir);
    }
  }
#line 834
  scm_ints_disabled = 1;
#line 835
  if (! ((1L << 16) & ((scm_cell *)port)->car)) {
#line 837
    scm_ints_disabled = 0;
#line 837
    scm_async_clock --;
#line 837
    if (0U == scm_async_clock) {
      {
#line 837
      scm_async_click();
      }
    }
#line 838
    return ((long )(21 << 9) + 372L);
  }
  {
#line 840
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 840
    tmp = __errno_location();
#line 840
    *tmp = 0;
#line 840
    sts = closedir((DIR *)((scm_cell *)port)->cdr);
#line 840
    tmp___0 = __errno_location();
    }
#line 840
    if (! (4 == *tmp___0)) {
#line 840
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 841
  if (sts != 0) {
    {
#line 842
    scm_syserror(s_sys_closedir);
    }
  }
#line 843
  ((scm_cell *)port)->car = scm_tc16_dir;
#line 844
  scm_ints_disabled = 0;
#line 844
  scm_async_clock --;
#line 844
  if (0U == scm_async_clock) {
    {
#line 844
    scm_async_click();
    }
  }
#line 845
  return ((long )(21 << 9) + 372L);
}
}
#line 851
static int scm_dir_print(SCM sexp , SCM port , scm_print_state *pstate ) ;
#line 853 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static int scm_dir_print(SCM sexp , SCM port , scm_print_state *pstate ) 
{ 
  char *__cil_tmp4 ;

  {
  {
#line 859
  scm_prinport(sexp, port, (char *)"directory");
  }
#line 860
  return (1);
}
}
#line 864
static size_t scm_dir_free(SCM p ) ;
#line 866 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static size_t scm_dir_free(SCM p ) 
{ 


  {
#line 870
  if ((1L << 16) & ((scm_cell *)p)->car) {
    {
#line 871
    closedir((DIR *)((scm_cell *)p)->cdr);
    }
  }
#line 872
  return ((size_t )0);
}
}
#line 875 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static scm_smobfuns dir_smob  =    {& scm_mark0, & scm_dir_free, & scm_dir_print, (SCM (*)(SCM  , SCM  ))0};
#line 882 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static char s_sys_chdir[6]  = {      (char )'c',      (char )'h',      (char )'d',      (char )'i', 
        (char )'r',      (char )'\000'};
#line 884 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
SCM scm_sys_chdir(SCM str ) 
{ 
  int ans ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 890
  if (! (6 & (int )str)) {
#line 890
    if (! ((125 & (int )((scm_cell *)str)->car) == 21)) {
      {
#line 890
      scm_wta(str, (char *)1, s_sys_chdir);
      }
    }
  } else {
    {
#line 890
    scm_wta(str, (char *)1, s_sys_chdir);
    }
  }
  {
#line 891
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 891
    tmp = __errno_location();
#line 891
    *tmp = 0;
#line 891
    ans = chdir((char const   *)((char *)((scm_cell *)str)->cdr));
#line 891
    tmp___0 = __errno_location();
    }
#line 891
    if (! (4 == *tmp___0)) {
#line 891
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 892
  if (ans != 0) {
    {
#line 893
    scm_syserror(s_sys_chdir);
    }
  }
#line 894
  return ((long )(21 << 9) + 372L);
}
}
#line 899 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static char s_sys_getcwd[7]  = {      (char )'g',      (char )'e',      (char )'t',      (char )'c', 
        (char )'w',      (char )'d',      (char )'\000'};
#line 901 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
SCM scm_sys_getcwd(void) 
{ 
  char *rv ;
  size_t size ;
  char *wd ;
  SCM result ;
  int *tmp ;
  size_t tmp___0 ;

  {
  {
#line 907
  size = (size_t )100;
#line 911
  scm_ints_disabled = 1;
#line 912
  wd = scm_must_malloc((long )size, s_sys_getcwd);
  }
  {
#line 913
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 913
    rv = getcwd(wd, size);
    }
#line 913
    if ((unsigned long )rv == (unsigned long )((char *)0)) {
      {
#line 913
      tmp = __errno_location();
      }
#line 913
      if (! (*tmp == 34)) {
#line 913
        goto while_break;
      }
    } else {
#line 913
      goto while_break;
    }
    {
#line 915
    scm_must_free(wd);
#line 916
    size *= 2UL;
#line 917
    wd = scm_must_malloc((long )size, s_sys_getcwd);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 919
  if ((unsigned long )rv == (unsigned long )((char *)0)) {
    {
#line 920
    scm_syserror(s_sys_getcwd);
    }
  }
  {
#line 921
  tmp___0 = strlen((char const   *)wd);
#line 921
  result = scm_makfromstr((char const   *)wd, tmp___0, 0);
#line 922
  scm_must_free(wd);
#line 923
  scm_ints_disabled = 0;
#line 923
  scm_async_clock --;
  }
#line 923
  if (0U == scm_async_clock) {
    {
#line 923
    scm_async_click();
    }
  }
#line 924
  return (result);
}
}
#line 935
static void fill_select_type(fd_set *set , SCM list ) ;
#line 937 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static void fill_select_type(fd_set *set , SCM list ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 942
  while (1) {
    while_continue: /* CIL Label */ ;
#line 942
    if (! (list != (long )(20 << 9) + 372L)) {
#line 942
      goto while_break;
    }
#line 944
    if (! (6 & (int )((scm_cell *)list)->car)) {
#line 944
      if (125L == (long )(65535 & (int )((scm_cell *)((scm_cell *)list)->car)->car)) {
#line 944
        if (((127L | (1L << 16)) & ((scm_cell *)((scm_cell *)list)->car)->car) == (125L | (1L << 16))) {
          {
#line 947
          tmp = fileno((FILE *)((struct scm_port_table *)((scm_cell *)((scm_cell *)list)->car)->cdr)->stream);
#line 947
          tmp___0 = fileno((FILE *)((struct scm_port_table *)((scm_cell *)((scm_cell *)list)->car)->cdr)->stream);
#line 947
          set->__fds_bits[tmp / (8 * (int )sizeof(__fd_mask ))] |= 1L << tmp___0 % (8 * (int )sizeof(__fd_mask ));
          }
        } else {
#line 944
          goto _L___0;
        }
      } else {
#line 944
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 948
    if (2 & (int )((scm_cell *)list)->car) {
#line 949
      set->__fds_bits[(((scm_cell *)list)->car >> 2) / (SCM )(8 * (int )sizeof(__fd_mask ))] |= 1L << (((scm_cell *)list)->car >> 2) % (long )(8 * (int )sizeof(__fd_mask ));
    } else
#line 950
    if (! (6 & (int )((scm_cell *)list)->car)) {
#line 950
      if ((long )(65535 & (int )((scm_cell *)((scm_cell *)list)->car)->car) == scm_tc16_fd) {
#line 951
        set->__fds_bits[(int )((scm_cell *)((scm_cell *)list)->car)->cdr / (8 * (int )sizeof(__fd_mask ))] |= 1L << (int )((scm_cell *)((scm_cell *)list)->car)->cdr % (8 * (int )sizeof(__fd_mask ));
      }
    }
#line 952
    list = ((scm_cell *)list)->cdr;
  }
  while_break: /* CIL Label */ ;
  }
#line 954
  return;
}
}
#line 957
static SCM retrieve_select_type(fd_set *set , SCM list ) ;
#line 959 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static SCM retrieve_select_type(fd_set *set , SCM list ) 
{ 
  SCM answer ;
  int tmp ;
  int tmp___0 ;

  {
#line 965
  answer = (long )(20 << 9) + 372L;
  {
#line 966
  while (1) {
    while_continue: /* CIL Label */ ;
#line 966
    if (! (list != (long )(20 << 9) + 372L)) {
#line 966
      goto while_break;
    }
#line 968
    if (! (6 & (int )((scm_cell *)list)->car)) {
#line 968
      if (125L == (long )(65535 & (int )((scm_cell *)((scm_cell *)list)->car)->car)) {
#line 968
        if (((127L | (1L << 16)) & ((scm_cell *)((scm_cell *)list)->car)->car) == (125L | (1L << 16))) {
          {
#line 972
          tmp = fileno((FILE *)((struct scm_port_table *)((scm_cell *)((scm_cell *)list)->car)->cdr)->stream);
#line 972
          tmp___0 = fileno((FILE *)((struct scm_port_table *)((scm_cell *)((scm_cell *)list)->car)->cdr)->stream);
          }
#line 972
          if ((set->__fds_bits[tmp / (8 * (int )sizeof(__fd_mask ))] & (1L << tmp___0 % (8 * (int )sizeof(__fd_mask )))) != 0L) {
            {
#line 973
            answer = scm_cons(((scm_cell *)list)->car, answer);
            }
          }
        } else {
#line 968
          goto _L___0;
        }
      } else {
#line 968
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 975
    if (2 & (int )((scm_cell *)list)->car) {
#line 977
      if ((set->__fds_bits[(((scm_cell *)list)->car >> 2) / (SCM )(8 * (int )sizeof(__fd_mask ))] & (1L << (((scm_cell *)list)->car >> 2) % (long )(8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 978
        answer = scm_cons(((scm_cell *)list)->car, answer);
        }
      }
    } else
#line 980
    if (! (6 & (int )((scm_cell *)list)->car)) {
#line 980
      if ((long )(65535 & (int )((scm_cell *)((scm_cell *)list)->car)->car) == scm_tc16_fd) {
#line 982
        if ((set->__fds_bits[(int )((scm_cell *)((scm_cell *)list)->car)->cdr / (8 * (int )sizeof(__fd_mask ))] & (1L << (int )((scm_cell *)((scm_cell *)list)->car)->cdr % (8 * (int )sizeof(__fd_mask )))) != 0L) {
          {
#line 983
          answer = scm_cons(((scm_cell *)list)->car, answer);
          }
        }
      }
    }
#line 985
    list = ((scm_cell *)list)->cdr;
  }
  while_break: /* CIL Label */ ;
  }
#line 987
  return (answer);
}
}
#line 994 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static char s_sys_select[7]  = {      (char )'s',      (char )'e',      (char )'l',      (char )'e', 
        (char )'c',      (char )'t',      (char )'\000'};
#line 996 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
SCM scm_sys_select(SCM reads , SCM writes , SCM excepts , SCM secs , SCM msecs ) 
{ 
  struct timeval timeout ;
  struct timeval *time_p ;
  fd_set read_set ;
  fd_set write_set ;
  fd_set except_set ;
  int sreturn ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int __d0___1 ;
  int __d1___1 ;
  SCM tmp___2 ;
  SCM tmp___3 ;
  SCM tmp___4 ;
  SCM tmp___5 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;

  {
  {
#line 1012
  tmp = scm_ilength(reads);
  }
#line 1012
  if (! (-1L < tmp)) {
    {
#line 1012
    scm_wta(reads, (char *)1, s_sys_select);
    }
  }
  {
#line 1013
  tmp___0 = scm_ilength(writes);
  }
#line 1013
  if (! (-1L < tmp___0)) {
    {
#line 1013
    scm_wta(reads, (char *)1, s_sys_select);
    }
  }
  {
#line 1014
  tmp___1 = scm_ilength(excepts);
  }
#line 1014
  if (! (-1L < tmp___1)) {
    {
#line 1014
    scm_wta(reads, (char *)1, s_sys_select);
    }
  }
  {
#line 1016
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1016
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& read_set.__fds_bits[0]): "memory");
#line 1016
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1017
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1017
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& write_set.__fds_bits[0]): "memory");
#line 1017
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1018
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1018
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0___1), "=D" (__d1___1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& except_set.__fds_bits[0]): "memory");
#line 1018
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1020
  fill_select_type(& read_set, reads);
#line 1021
  fill_select_type(& write_set, writes);
#line 1022
  fill_select_type(& except_set, excepts);
  }
#line 1024
  if ((long )(18 << 9) + 372L == secs) {
#line 1025
    time_p = (struct timeval *)0;
  } else {
#line 1028
    if (! (2 & (int )secs)) {
      {
#line 1028
      scm_wta(secs, (char *)4, s_sys_select);
      }
    }
#line 1029
    if ((long )(18 << 9) + 372L == msecs) {
#line 1030
      msecs = (SCM )2;
    } else
#line 1032
    if (! (2 & (int )msecs)) {
      {
#line 1032
      scm_wta(msecs, (char *)5, s_sys_select);
      }
    }
#line 1034
    timeout.tv_sec = secs >> 2;
#line 1035
    timeout.tv_usec = 1000L * (msecs >> 2);
#line 1036
    time_p = & timeout;
  }
  {
#line 1039
  scm_ints_disabled = 1;
#line 1040
  sreturn = select(1024, (fd_set */* __restrict  */)(& read_set), (fd_set */* __restrict  */)(& write_set),
                   (fd_set */* __restrict  */)(& except_set), (struct timeval */* __restrict  */)time_p);
  }
#line 1042
  if (sreturn < 0) {
    {
#line 1043
    scm_syserror(s_sys_select);
    }
  }
#line 1044
  scm_ints_disabled = 0;
#line 1044
  scm_async_clock --;
#line 1044
  if (0U == scm_async_clock) {
    {
#line 1044
    scm_async_click();
    }
  }
  {
#line 1045
  tmp___2 = retrieve_select_type(& except_set, excepts);
#line 1045
  tmp___3 = retrieve_select_type(& write_set, writes);
#line 1045
  tmp___4 = retrieve_select_type(& read_set, reads);
#line 1045
  tmp___5 = scm_listify(tmp___4, tmp___3, tmp___2, (long )(18 << 9) + 372L);
  }
#line 1045
  return (tmp___5);
}
}
#line 1098 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
int scm_input_waiting_p(FILE *f , char *caller ) 
{ 
  int tmp ;
  struct timeval timeout ;
  fd_set read_set ;
  fd_set write_set ;
  fd_set except_set ;
  int fno ;
  int tmp___0 ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int __d0___1 ;
  int __d1___1 ;
  int tmp___1 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;

  {
  {
#line 1104
  tmp = feof(f);
  }
#line 1104
  if (tmp) {
#line 1105
    return (1);
  }
#line 1117
  if ((unsigned long )f->_IO_read_end != (unsigned long )f->_IO_read_ptr) {
#line 1118
    return (1);
  }
  {
#line 1134
  tmp___0 = fileno(f);
#line 1134
  fno = tmp___0;
  }
  {
#line 1136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1136
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& read_set.__fds_bits[0]): "memory");
#line 1136
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1137
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1137
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& write_set.__fds_bits[0]): "memory");
#line 1137
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1138
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1138
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0___1), "=D" (__d1___1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& except_set.__fds_bits[0]): "memory");
#line 1138
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1140
  read_set.__fds_bits[fno / (8 * (int )sizeof(__fd_mask ))] |= 1L << fno % (8 * (int )sizeof(__fd_mask ));
#line 1142
  timeout.tv_sec = (__time_t )0;
#line 1143
  timeout.tv_usec = (__suseconds_t )0;
#line 1145
  scm_ints_disabled = 1;
#line 1146
  tmp___1 = select(1024, (fd_set */* __restrict  */)(& read_set), (fd_set */* __restrict  */)(& write_set),
                   (fd_set */* __restrict  */)(& except_set), (struct timeval */* __restrict  */)(& timeout));
  }
#line 1146
  if (tmp___1 < 0) {
    {
#line 1149
    scm_syserror(caller);
    }
  }
#line 1150
  scm_ints_disabled = 0;
#line 1150
  scm_async_clock --;
#line 1150
  if (0U == scm_async_clock) {
    {
#line 1150
    scm_async_click();
    }
  }
#line 1151
  return ((read_set.__fds_bits[fno / (8 * (int )sizeof(__fd_mask ))] & (1L << fno % (8 * (int )sizeof(__fd_mask )))) != 0L);
}
}
#line 1171 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static char s_sys_symlink[8]  = 
#line 1171
  {      (char )'s',      (char )'y',      (char )'m',      (char )'l', 
        (char )'i',      (char )'n',      (char )'k',      (char )'\000'};
#line 1173 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
SCM scm_sys_symlink(SCM oldpath , SCM newpath ) 
{ 
  int val ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 1181
  if (! (6 & (int )oldpath)) {
#line 1181
    if (! ((125 & (int )((scm_cell *)oldpath)->car) == 21)) {
      {
#line 1181
      scm_wta(oldpath, (char *)1, s_sys_symlink);
      }
    }
  } else {
    {
#line 1181
    scm_wta(oldpath, (char *)1, s_sys_symlink);
    }
  }
#line 1182
  if (! (6 & (int )newpath)) {
#line 1182
    if (! ((125 & (int )((scm_cell *)newpath)->car) == 21)) {
      {
#line 1182
      scm_wta(newpath, (char *)2, s_sys_symlink);
      }
    }
  } else {
    {
#line 1182
    scm_wta(newpath, (char *)2, s_sys_symlink);
    }
  }
  {
#line 1183
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1183
    tmp = __errno_location();
#line 1183
    *tmp = 0;
#line 1183
    val = symlink((char const   *)((char *)((scm_cell *)oldpath)->cdr), (char const   *)((char *)((scm_cell *)newpath)->cdr));
#line 1183
    tmp___0 = __errno_location();
    }
#line 1183
    if (! (4 == *tmp___0)) {
#line 1183
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1184
  if (val != 0) {
    {
#line 1185
    scm_syserror(s_sys_symlink);
    }
  }
#line 1186
  return ((long )(21 << 9) + 372L);
}
}
#line 1195 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static char s_sys_readlink[9]  = 
#line 1195
  {      (char )'r',      (char )'e',      (char )'a',      (char )'d', 
        (char )'l',      (char )'i',      (char )'n',      (char )'k', 
        (char )'\000'};
#line 1197 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
SCM scm_sys_readlink(SCM path ) 
{ 
  size_t rv ;
  size_t size ;
  char *buf ;
  SCM result ;
  ssize_t tmp ;

  {
#line 1203
  size = (size_t )100;
#line 1206
  if (! (6 & (int )path)) {
#line 1206
    if (! ((125 & (int )((scm_cell *)path)->car) == 21)) {
      {
#line 1206
      scm_wta(path, (char *)1, s_sys_readlink);
      }
    }
  } else {
    {
#line 1206
    scm_wta(path, (char *)1, s_sys_readlink);
    }
  }
  {
#line 1207
  scm_ints_disabled = 1;
#line 1208
  buf = scm_must_malloc((long )size, s_sys_readlink);
  }
  {
#line 1209
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1209
    tmp = readlink((char const   */* __restrict  */)((char *)((scm_cell *)path)->cdr),
                   (char */* __restrict  */)buf, size);
#line 1209
    rv = (size_t )tmp;
    }
#line 1209
    if (! (rv == size)) {
#line 1209
      goto while_break;
    }
    {
#line 1211
    scm_must_free(buf);
#line 1212
    size *= 2UL;
#line 1213
    buf = scm_must_malloc((long )size, s_sys_readlink);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1215
  if (rv == 0xffffffffffffffffUL) {
    {
#line 1216
    scm_syserror(s_sys_readlink);
    }
  }
  {
#line 1217
  result = scm_makfromstr((char const   *)buf, rv, 0);
#line 1218
  scm_must_free(buf);
#line 1219
  scm_ints_disabled = 0;
#line 1219
  scm_async_clock --;
  }
#line 1219
  if (0U == scm_async_clock) {
    {
#line 1219
    scm_async_click();
    }
  }
#line 1220
  return (result);
}
}
#line 1229 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static char s_sys_lstat[6]  = {      (char )'l',      (char )'s',      (char )'t',      (char )'a', 
        (char )'t',      (char )'\000'};
#line 1231 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
SCM scm_sys_lstat(SCM str ) 
{ 
  int rv ;
  struct stat stat_temp ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  SCM tmp___3 ;
  SCM tmp___4 ;
  SCM tmp___5 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 1239
  if (! (6 & (int )str)) {
#line 1239
    if (! ((125 & (int )((scm_cell *)str)->car) == 21)) {
      {
#line 1239
      scm_wta(str, (char *)1, s_sys_lstat);
      }
    }
  } else {
    {
#line 1239
    scm_wta(str, (char *)1, s_sys_lstat);
    }
  }
  {
#line 1240
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1240
    tmp = __errno_location();
#line 1240
    *tmp = 0;
#line 1240
    rv = lstat((char const   */* __restrict  */)((char *)((scm_cell *)str)->cdr),
               (struct stat */* __restrict  */)(& stat_temp));
#line 1240
    tmp___0 = __errno_location();
    }
#line 1240
    if (! (4 == *tmp___0)) {
#line 1240
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1241
  if (rv != 0) {
    {
#line 1242
    tmp___1 = __errno_location();
#line 1242
    tmp___2 = strerror(*tmp___1);
#line 1242
    tmp___3 = scm_makfrom0str((char const   *)tmp___2);
#line 1242
    tmp___4 = scm_listify(tmp___3, str, (long )(18 << 9) + 372L);
#line 1242
    scm_syserror_msg(s_sys_lstat, (char *)"%s: %S", tmp___4);
    }
  }
  {
#line 1246
  tmp___5 = scm_stat2scm(& stat_temp);
  }
#line 1246
  return (tmp___5);
}
}
#line 1255 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
static char s_sys_copy_file[10]  = 
#line 1255
  {      (char )'c',      (char )'o',      (char )'p',      (char )'y', 
        (char )'-',      (char )'f',      (char )'i',      (char )'l', 
        (char )'e',      (char )'\000'};
#line 1257 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
SCM scm_sys_copy_file(SCM oldfile , SCM newfile ) 
{ 
  int oldfd ;
  int newfd ;
  int n ;
  char buf[8192] ;
  struct stat oldstat ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  ssize_t tmp___5 ;
  ssize_t tmp___6 ;
  int tmp___7 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;

  {
#line 1267
  if (! (6 & (int )oldfile)) {
#line 1267
    if (! ((117 & (int )((scm_cell *)oldfile)->car) == 21)) {
#line 1267
      if (! ((125 & (int )((scm_cell *)oldfile)->car) == 5)) {
        {
#line 1267
        scm_wta(oldfile, (char *)1, s_sys_copy_file);
        }
      }
    }
  } else {
    {
#line 1267
    scm_wta(oldfile, (char *)1, s_sys_copy_file);
    }
  }
#line 1268
  if ((125 & (int )((scm_cell *)oldfile)->car) == 29) {
#line 1269
    if ((127 & (int )((scm_cell *)oldfile)->car) == 29) {
#line 1269
      tmp = (char *)((scm_cell *)((scm_cell *)((scm_cell *)oldfile)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)oldfile)->cdr)->car >> 2);
    } else {
#line 1269
      tmp = (char *)((scm_cell *)oldfile)->cdr;
    }
    {
#line 1269
    oldfile = scm_makfromstr((char const   *)tmp, (unsigned long )((scm_cell *)oldfile)->car >> 8,
                             0);
    }
  }
#line 1270
  if (! (6 & (int )newfile)) {
#line 1270
    if (! ((117 & (int )((scm_cell *)newfile)->car) == 21)) {
#line 1270
      if (! ((125 & (int )((scm_cell *)newfile)->car) == 5)) {
        {
#line 1270
        scm_wta(newfile, (char *)2, s_sys_copy_file);
        }
      }
    }
  } else {
    {
#line 1270
    scm_wta(newfile, (char *)2, s_sys_copy_file);
    }
  }
#line 1271
  if ((125 & (int )((scm_cell *)newfile)->car) == 29) {
#line 1272
    if ((127 & (int )((scm_cell *)newfile)->car) == 29) {
#line 1272
      tmp___0 = (char *)((scm_cell *)((scm_cell *)((scm_cell *)newfile)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)newfile)->cdr)->car >> 2);
    } else {
#line 1272
      tmp___0 = (char *)((scm_cell *)newfile)->cdr;
    }
    {
#line 1272
    newfile = scm_makfromstr((char const   *)tmp___0, (unsigned long )((scm_cell *)newfile)->car >> 8,
                             0);
    }
  }
#line 1273
  if ((127 & (int )((scm_cell *)oldfile)->car) == 29) {
#line 1273
    tmp___1 = (char *)((scm_cell *)((scm_cell *)((scm_cell *)oldfile)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)oldfile)->cdr)->car >> 2);
  } else {
#line 1273
    tmp___1 = (char *)((scm_cell *)oldfile)->cdr;
  }
  {
#line 1273
  tmp___2 = stat((char const   */* __restrict  */)tmp___1, (struct stat */* __restrict  */)(& oldstat));
  }
#line 1273
  if (tmp___2 == -1) {
    {
#line 1274
    scm_syserror(s_sys_copy_file);
    }
  }
#line 1275
  scm_ints_disabled = 1;
#line 1276
  if ((127 & (int )((scm_cell *)oldfile)->car) == 29) {
#line 1276
    tmp___3 = (char *)((scm_cell *)((scm_cell *)((scm_cell *)oldfile)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)oldfile)->cdr)->car >> 2);
  } else {
#line 1276
    tmp___3 = (char *)((scm_cell *)oldfile)->cdr;
  }
  {
#line 1276
  oldfd = open((char const   *)tmp___3, 0);
  }
#line 1277
  if (oldfd == -1) {
    {
#line 1278
    scm_syserror(s_sys_copy_file);
    }
  }
#line 1281
  if ((127 & (int )((scm_cell *)newfile)->car) == 29) {
#line 1281
    tmp___4 = (char *)((scm_cell *)((scm_cell *)((scm_cell *)newfile)->cdr)->cdr)->cdr + (((scm_cell *)((scm_cell *)newfile)->cdr)->car >> 2);
  } else {
#line 1281
    tmp___4 = (char *)((scm_cell *)newfile)->cdr;
  }
  {
#line 1281
  newfd = open((char const   *)tmp___4, 577, oldstat.st_mode & 4095U);
  }
#line 1283
  if (newfd == -1) {
    {
#line 1284
    scm_syserror(s_sys_copy_file);
    }
  }
  {
#line 1286
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1286
    tmp___6 = read(oldfd, (void *)(buf), sizeof(buf));
#line 1286
    n = (int )tmp___6;
    }
#line 1286
    if (! (n > 0)) {
#line 1286
      goto while_break;
    }
    {
#line 1287
    tmp___5 = write(newfd, (void const   *)(buf), (size_t )n);
    }
#line 1287
    if (tmp___5 != (ssize_t )n) {
      {
#line 1289
      close(oldfd);
#line 1290
      close(newfd);
#line 1291
      scm_syserror(s_sys_copy_file);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1293
  close(oldfd);
#line 1294
  tmp___7 = close(newfd);
  }
#line 1294
  if (tmp___7 == -1) {
    {
#line 1295
    scm_syserror(s_sys_copy_file);
    }
  }
#line 1296
  scm_ints_disabled = 0;
#line 1296
  scm_async_clock --;
#line 1296
  if (0U == scm_async_clock) {
    {
#line 1296
    scm_async_click();
    }
  }
#line 1297
  return ((long )(21 << 9) + 372L);
}
}
#line 1302 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
void scm_init_filesys(void) 
{ 
  SCM tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  SCM tmp___2 ;
  SCM tmp___3 ;
  SCM tmp___4 ;
  SCM tmp___5 ;
  SCM tmp___6 ;
  SCM tmp___7 ;
  SCM tmp___8 ;
  SCM tmp___9 ;
  SCM tmp___10 ;
  SCM tmp___11 ;
  SCM tmp___12 ;
  SCM tmp___13 ;
  SCM tmp___14 ;
  SCM tmp___15 ;
  SCM tmp___16 ;
  SCM tmp___17 ;
  SCM tmp___18 ;
  SCM tmp___19 ;
  SCM tmp___20 ;
  SCM tmp___21 ;
  SCM tmp___22 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;

  {
  {
#line 1305
  scm_add_feature((char *)"i/o-extensions");
#line 1307
  scm_tc16_fd = scm_newsmob(& fd_smob);
#line 1308
  scm_tc16_dir = scm_newsmob(& dir_smob);
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.x"
  tmp = scm_intern0((char *)"O_CREAT");
#line 1
  scm_O_CREAT = scm_permanent_object(tmp);
#line 1
  tmp___0 = scm_long2num(64L);
#line 1
  ((scm_cell *)scm_O_CREAT)->cdr = tmp___0;
#line 2
  tmp___1 = scm_intern0((char *)"O_EXCL");
#line 2
  scm_O_EXCL = scm_permanent_object(tmp___1);
#line 2
  tmp___2 = scm_long2num(128L);
#line 2
  ((scm_cell *)scm_O_EXCL)->cdr = tmp___2;
#line 3
  tmp___3 = scm_intern0((char *)"O_NOCTTY");
#line 3
  scm_O_NOCTTY = scm_permanent_object(tmp___3);
#line 3
  tmp___4 = scm_long2num(256L);
#line 3
  ((scm_cell *)scm_O_NOCTTY)->cdr = tmp___4;
#line 4
  tmp___5 = scm_intern0((char *)"O_TRUNC");
#line 4
  scm_O_TRUNC = scm_permanent_object(tmp___5);
#line 4
  tmp___6 = scm_long2num(512L);
#line 4
  ((scm_cell *)scm_O_TRUNC)->cdr = tmp___6;
#line 5
  tmp___7 = scm_intern0((char *)"O_APPEND");
#line 5
  scm_O_APPEND = scm_permanent_object(tmp___7);
#line 5
  tmp___8 = scm_long2num(1024L);
#line 5
  ((scm_cell *)scm_O_APPEND)->cdr = tmp___8;
#line 6
  tmp___9 = scm_intern0((char *)"O_NONBLOCK");
#line 6
  scm_O_NONBLOCK = scm_permanent_object(tmp___9);
#line 6
  tmp___10 = scm_long2num(2048L);
#line 6
  ((scm_cell *)scm_O_NONBLOCK)->cdr = tmp___10;
#line 7
  tmp___11 = scm_intern0((char *)"O_NDELAY");
#line 7
  scm_O_NDELAY = scm_permanent_object(tmp___11);
#line 7
  tmp___12 = scm_long2num(2048L);
#line 7
  ((scm_cell *)scm_O_NDELAY)->cdr = tmp___12;
#line 8
  tmp___13 = scm_intern0((char *)"O_SYNC");
#line 8
  scm_O_SYNC = scm_permanent_object(tmp___13);
#line 8
  tmp___14 = scm_long2num(4096L);
#line 8
  ((scm_cell *)scm_O_SYNC)->cdr = tmp___14;
#line 9
  scm_make_gsubr(s_sys_chown, 3, 0, 0, (SCM (*)())(& scm_sys_chown));
#line 10
  scm_make_gsubr(s_sys_chmod, 2, 0, 0, (SCM (*)())(& scm_sys_chmod));
#line 11
  scm_make_gsubr(s_umask, 0, 1, 0, (SCM (*)())(& scm_umask));
#line 12
  scm_make_gsubr(s_sys_open, 3, 0, 0, (SCM (*)())(& scm_sys_open));
#line 13
  scm_make_gsubr(s_sys_create, 2, 0, 0, (SCM (*)())(& scm_sys_create));
#line 14
  scm_make_gsubr(s_sys_close, 1, 0, 0, (SCM (*)())(& scm_sys_close));
#line 15
  scm_make_gsubr(s_sys_write_fd, 2, 0, 0, (SCM (*)())(& scm_sys_write_fd));
#line 16
  scm_make_gsubr(s_sys_read_fd, 2, 2, 0, (SCM (*)())(& scm_sys_read_fd));
#line 17
  scm_make_gsubr(s_sys_lseek, 2, 1, 0, (SCM (*)())(& scm_sys_lseek));
#line 18
  scm_make_gsubr(s_sys_dup, 1, 1, 0, (SCM (*)())(& scm_sys_dup));
#line 19
  tmp___15 = scm_intern0((char *)"regular");
#line 19
  scm_sym_regular = scm_permanent_object(((scm_cell *)tmp___15)->car);
#line 20
  tmp___16 = scm_intern0((char *)"directory");
#line 20
  scm_sym_directory = scm_permanent_object(((scm_cell *)tmp___16)->car);
#line 21
  tmp___17 = scm_intern0((char *)"symlink");
#line 21
  scm_sym_symlink = scm_permanent_object(((scm_cell *)tmp___17)->car);
#line 22
  tmp___18 = scm_intern0((char *)"block-special");
#line 22
  scm_sym_block_special = scm_permanent_object(((scm_cell *)tmp___18)->car);
#line 23
  tmp___19 = scm_intern0((char *)"char-special");
#line 23
  scm_sym_char_special = scm_permanent_object(((scm_cell *)tmp___19)->car);
#line 24
  tmp___20 = scm_intern0((char *)"fifo");
#line 24
  scm_sym_fifo = scm_permanent_object(((scm_cell *)tmp___20)->car);
#line 25
  tmp___21 = scm_intern0((char *)"socket");
#line 25
  scm_sym_sock = scm_permanent_object(((scm_cell *)tmp___21)->car);
#line 26
  tmp___22 = scm_intern0((char *)"unknown");
#line 26
  scm_sym_unknown = scm_permanent_object(((scm_cell *)tmp___22)->car);
#line 27
  scm_make_gsubr(s_sys_stat, 1, 0, 0, (SCM (*)())(& scm_sys_stat));
#line 28
  scm_make_gsubr(s_sys_link, 2, 0, 0, (SCM (*)())(& scm_sys_link));
#line 29
  scm_make_gsubr(s_sys_rename, 2, 0, 0, (SCM (*)())(& scm_sys_rename));
#line 30
  scm_make_gsubr(s_sys_delete_file, 1, 0, 0, (SCM (*)())(& scm_sys_delete_file));
#line 31
  scm_make_gsubr(s_sys_mkdir, 1, 1, 0, (SCM (*)())(& scm_sys_mkdir));
#line 32
  scm_make_gsubr(s_sys_rmdir, 1, 0, 0, (SCM (*)())(& scm_sys_rmdir));
#line 33
  scm_make_gsubr(s_sys_opendir, 1, 0, 0, (SCM (*)())(& scm_sys_opendir));
#line 34
  scm_make_gsubr(s_sys_readdir, 1, 0, 0, (SCM (*)())(& scm_sys_readdir));
#line 35
  scm_make_gsubr(s_rewinddir, 1, 0, 0, (SCM (*)())(& scm_rewinddir));
#line 36
  scm_make_gsubr(s_sys_closedir, 1, 0, 0, (SCM (*)())(& scm_sys_closedir));
#line 37
  scm_make_gsubr(s_sys_chdir, 1, 0, 0, (SCM (*)())(& scm_sys_chdir));
#line 38
  scm_make_gsubr(s_sys_getcwd, 0, 0, 0, & scm_sys_getcwd);
#line 39
  scm_make_gsubr(s_sys_select, 3, 2, 0, (SCM (*)())(& scm_sys_select));
#line 40
  scm_make_gsubr(s_sys_symlink, 2, 0, 0, (SCM (*)())(& scm_sys_symlink));
#line 41
  scm_make_gsubr(s_sys_readlink, 1, 0, 0, (SCM (*)())(& scm_sys_readlink));
#line 42
  scm_make_gsubr(s_sys_lstat, 1, 0, 0, (SCM (*)())(& scm_sys_lstat));
#line 43
  scm_make_gsubr(s_sys_copy_file, 2, 0, 0, (SCM (*)())(& scm_sys_copy_file));
  }
#line 1311 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/filesys.c"
  return;
}
}
#line 50 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/feature.h"
SCM scm_program_arguments(void) ;
#line 53 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/feature.c"
static SCM *scm_loc_features  ;
#line 55 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/feature.c"
void scm_add_feature(char *str ) 
{ 
  size_t tmp ;
  SCM tmp___0 ;

  {
  {
#line 59
  tmp = strlen((char const   *)str);
#line 59
  tmp___0 = scm_intern(str, tmp);
#line 59
  *scm_loc_features = scm_cons(((scm_cell *)tmp___0)->car, *scm_loc_features);
  }
#line 61
  return;
}
}
#line 65 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/feature.c"
static char s_program_arguments[18]  = 
#line 65
  {      (char )'p',      (char )'r',      (char )'o',      (char )'g', 
        (char )'r',      (char )'a',      (char )'m',      (char )'-', 
        (char )'a',      (char )'r',      (char )'g',      (char )'u', 
        (char )'m',      (char )'e',      (char )'n',      (char )'t', 
        (char )'s',      (char )'\000'};
#line 67 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/feature.c"
SCM scm_program_arguments(void) 
{ 


  {
#line 70
  return (scm_root->progargs);
}
}
#line 79 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/feature.c"
void scm_set_program_arguments(int argc , char **argv , char *first___0 ) 
{ 
  SCM tmp ;

  {
  {
#line 85
  scm_root->progargs = scm_makfromstrs(argc, argv);
  }
#line 86
  if (first___0) {
    {
#line 87
    tmp = scm_makfrom0str((char const   *)first___0);
#line 87
    scm_root->progargs = scm_cons(tmp, scm_root->progargs);
    }
  }
#line 88
  return;
}
}
#line 93 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/feature.c"
void scm_init_feature(void) 
{ 
  SCM tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 96
  tmp = scm_sysintern((char *)"*features*", (long )(20 << 9) + 372L);
#line 96
  scm_loc_features = & ((scm_cell *)tmp)->cdr;
#line 101
  scm_add_feature((char *)"system");
#line 110
  scm_add_feature((char *)"char-ready?");
#line 113
  scm_add_feature((char *)"full-continuation");
#line 119
  scm_sysintern((char *)"char-code-limit", (256L << 2) + 2L);
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/feature.x"
  scm_make_gsubr(s_program_arguments, 0, 0, 0, & scm_program_arguments);
  }
#line 121 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/feature.c"
  return;
}
}
#line 50 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/extchrs.c"
int xmblen(char const   *str , size_t size ) 
{ 
  int tmp ;

  {
#line 55
  if (! str) {
#line 56
    return (0);
  }
#line 58
  if ((int )*((unsigned char *)str) > 127) {
#line 59
    if (size < 4UL) {
#line 59
      tmp = -1;
    } else {
#line 59
      tmp = 4;
    }
#line 59
    return (tmp);
  } else
#line 62
  if (! *str) {
#line 63
    return (0);
  } else {
#line 65
    return (1);
  }
}
}
#line 69 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/extchrs.c"
int xwctomb(char *_str , int c ) 
{ 
  unsigned char *str ;

  {
#line 75
  str = (unsigned char *)_str;
#line 76
  if (! str) {
#line 77
    return (0);
  }
#line 79
  if (! c) {
#line 81
    *str = (unsigned char)0;
#line 82
    return (0);
  }
#line 86
  if (c < 127) {
#line 88
    *str = (unsigned char )c;
#line 89
    return (1);
  }
#line 92
  *(str + 0) = (unsigned char)255;
#line 93
  *(str + 1) = (unsigned char )(128 | ((c >> 10) & 63));
#line 94
  *(str + 2) = (unsigned char )(128 | ((c >> 4) & 63));
#line 95
  *(str + 3) = (unsigned char )(128 | (c & 15));
#line 96
  return (4);
}
}
#line 100 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/extchrs.c"
int xmbtowc(xwchar_t *result , unsigned char const   *_str , size_t size ) 
{ 
  unsigned char const   *str ;

  {
#line 107
  str = _str;
#line 108
  if (! str) {
#line 109
    return (0);
  }
#line 111
  if (size == 0UL) {
#line 113
    *result = (xwchar_t )0;
#line 114
    return (0);
  } else
#line 111
  if (! *str) {
#line 113
    *result = (xwchar_t )0;
#line 114
    return (0);
  }
#line 117
  if ((int const   )*str < 128) {
#line 119
    *result = (xwchar_t )*str;
#line 120
    return (1);
  }
#line 123
  if ((int const   )*str != 255) {
#line 125
    return (-1);
  } else
#line 123
  if (size < 4UL) {
#line 125
    return (-1);
  }
#line 127
  *result = (xwchar_t )(((((int const   )*(str + 1) & 63) << 10) | (((int const   )*(str + 2) & 63) << 4)) | ((int const   )*(str + 3) & 15));
#line 130
  return (4);
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 85 "../libguile/debug.h"
scm_option scm_evaluator_trap_table[3] ;
#line 92 "../libguile/debug.h"
SCM (*scm_ceval_ptr)(SCM exp , SCM env )  ;
#line 94 "../libguile/debug.h"
int scm_debug_mode  ;
#line 95 "../libguile/debug.h"
int scm_check_entry_p  ;
#line 95 "../libguile/debug.h"
int scm_check_apply_p  ;
#line 95 "../libguile/debug.h"
int scm_check_exit_p  ;
#line 121 "../libguile/debug.h"
int scm_debug_eframe_size  ;
#line 132 "../libguile/debug.h"
scm_debug_frame *scm_last_debug_frame  ;
#line 201
SCM scm_make_debugobj(scm_debug_frame *frame ) ;
#line 51 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/append.h"
SCM scm_append(SCM objs ) ;
#line 73 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/continuations.h"
SCM scm_make_cont(SCM *answer ) ;
#line 75
SCM scm_call_continuation(SCM cont , SCM val ) ;
#line 89 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.h"
SCM scm_i_dot  ;
#line 90 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.h"
SCM scm_i_quote  ;
#line 91 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.h"
SCM scm_i_quasiquote  ;
#line 92 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.h"
SCM scm_i_lambda  ;
#line 93 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.h"
SCM scm_i_let  ;
#line 94 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.h"
SCM scm_i_arrow  ;
#line 95 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.h"
SCM scm_i_else  ;
#line 96 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.h"
SCM scm_i_unquote  ;
#line 97 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.h"
SCM scm_i_uq_splicing  ;
#line 98 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.h"
SCM scm_i_apply  ;
#line 112
SCM *scm_ilookup(SCM iloc , SCM env ) ;
#line 113
SCM *scm_lookupcar(SCM vloc , SCM genv ) ;
#line 114
SCM scm_unmemocar(SCM form , SCM env ) ;
#line 116
SCM scm_eval_car(SCM pair , SCM env ) ;
#line 117
SCM scm_eval_args(SCM l , SCM env ) ;
#line 118
SCM scm_deval_args(SCM l , SCM env , SCM *lloc ) ;
#line 119
SCM scm_m_quote(SCM xorig , SCM env ) ;
#line 120
SCM scm_m_begin(SCM xorig , SCM env ) ;
#line 121
SCM scm_m_if(SCM xorig , SCM env ) ;
#line 122
SCM scm_m_set(SCM xorig , SCM env ) ;
#line 125
SCM scm_m_and(SCM xorig , SCM env ) ;
#line 126
SCM scm_m_or(SCM xorig , SCM env ) ;
#line 127
SCM scm_m_case(SCM xorig , SCM env ) ;
#line 128
SCM scm_m_cond(SCM xorig , SCM env ) ;
#line 129
SCM scm_m_lambda(SCM xorig , SCM env ) ;
#line 130
SCM scm_m_letstar(SCM xorig , SCM env ) ;
#line 131
SCM scm_m_do(SCM xorig , SCM env ) ;
#line 132
SCM scm_m_quasiquote(SCM xorig , SCM env ) ;
#line 133
SCM scm_m_delay(SCM xorig , SCM env ) ;
#line 134
SCM scm_m_define(SCM x , SCM env ) ;
#line 135
SCM scm_m_letrec(SCM xorig , SCM env ) ;
#line 136
SCM scm_m_let(SCM xorig , SCM env ) ;
#line 137
SCM scm_m_apply(SCM xorig , SCM env ) ;
#line 138
SCM scm_m_cont(SCM xorig , SCM env ) ;
#line 139
SCM scm_m_undefine(SCM x , SCM env ) ;
#line 140
int scm_badargsp(SCM formals , SCM args ) ;
#line 142
SCM scm_deval(SCM x , SCM env ) ;
#line 143
SCM scm_procedure_documentation(SCM proc ) ;
#line 144
SCM scm_nconc2last(SCM lst ) ;
#line 146
SCM scm_dapply(SCM proc , SCM arg1 , SCM args ) ;
#line 148
SCM scm_map(SCM proc , SCM arg1 , SCM args ) ;
#line 149
SCM scm_for_each(SCM proc , SCM arg1 , SCM args ) ;
#line 151
SCM scm_makprom(SCM code ) ;
#line 152
SCM scm_makacro(SCM code ) ;
#line 153
SCM scm_makmacro(SCM code ) ;
#line 154
SCM scm_makmmacro(SCM code ) ;
#line 155
SCM scm_force(SCM x ) ;
#line 156
SCM scm_promise_p(SCM x ) ;
#line 157
SCM scm_copy_tree(SCM obj ) ;
#line 158
SCM scm_eval_3(SCM obj , int copyp , SCM env ) ;
#line 160
SCM scm_eval2(SCM obj , SCM env_thunk ) ;
#line 161
SCM scm_eval(SCM obj ) ;
#line 163
SCM scm_macro_eval_x(SCM exp___0 , SCM env ) ;
#line 164
SCM scm_definedp(SCM sym ) ;
#line 165
SCM scm_make_synt(char *name , SCM (*macroizer)(SCM  ) , SCM (*fcn)() ) ;
#line 148 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM *scm_ilookup(SCM iloc , SCM env ) 
{ 
  register int ir ;
  register SCM er ;

  {
#line 153
  ir = (int )(524032L >> 8) & ((int )iloc >> 8);
#line 154
  er = env;
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    if (! (0 != ir)) {
#line 155
      goto while_break;
    }
#line 156
    er = ((scm_cell *)er)->cdr;
#line 155
    ir --;
  }
  while_break: /* CIL Label */ ;
  }
#line 157
  er = ((scm_cell *)er)->car;
#line 158
  ir = (int )((unsigned long )iloc >> 20);
  {
#line 158
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 158
    if (! (0 != ir)) {
#line 158
      goto while_break___0;
    }
#line 159
    er = ((scm_cell *)er)->cdr;
#line 158
    ir --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 160
  if (524288L & iloc) {
#line 161
    return (& ((scm_cell *)er)->cdr);
  }
#line 162
  return (& ((scm_cell *)((scm_cell *)er)->cdr)->car);
}
}
#line 167 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM *scm_lookupcar(SCM vloc , SCM genv ) 
{ 
  SCM env ;
  register SCM *al ;
  register SCM fl ;
  register SCM var ;
  register SCM iloc ;
  SCM tmp ;
  SCM top_thunk ;
  SCM vcell ;
  SCM tmp___0 ;
  char const   *tmp___1 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 172
  env = genv;
#line 173
  var = ((scm_cell *)vloc)->car;
#line 175
  iloc = 252L;
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 177
    if (! (! (6 & (int )env))) {
#line 177
      goto while_break;
    }
    {
#line 179
    tmp = scm_procedure_p(((scm_cell *)env)->car);
    }
#line 179
    if ((long )(17 << 9) + 372L == tmp) {
#line 180
      goto while_break;
    }
#line 181
    al = & ((scm_cell *)env)->car;
#line 182
    fl = ((scm_cell *)*al)->car;
    {
#line 182
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 182
      if (! (! (6 & (int )fl))) {
#line 182
        goto while_break___0;
      }
#line 184
      if (1 & (int )((scm_cell *)fl)->car) {
#line 185
        if (fl == var) {
#line 188
          ((scm_cell *)vloc)->car = iloc + 524288L;
#line 190
          return (& ((scm_cell *)*al)->cdr);
        } else {
#line 193
          goto while_break___0;
        }
      }
#line 194
      al = & ((scm_cell *)*al)->cdr;
#line 195
      if (((scm_cell *)fl)->car == var) {
#line 199
        if ((long )(18 << 9) + 372L == ((scm_cell *)*al)->car) {
#line 201
          env = (long )(20 << 9) + 372L;
#line 202
          goto errout;
        }
#line 205
        ((scm_cell *)vloc)->car = iloc;
#line 207
        return (& ((scm_cell *)*al)->car);
      }
#line 210
      iloc += 1048576L;
#line 182
      fl = ((scm_cell *)fl)->cdr;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 214
    iloc = 1048575L & (iloc + 256L);
#line 177
    env = ((scm_cell *)env)->cdr;
  }
  while_break: /* CIL Label */ ;
  }
#line 219
  if (! (6 & (int )env)) {
#line 221
    top_thunk = ((scm_cell *)env)->car;
#line 222
    env = ((scm_cell *)env)->cdr;
  } else {
#line 225
    top_thunk = (long )(16 << 9) + 372L;
  }
  {
#line 226
  vcell = scm_sym2vcell(var, top_thunk, (long )(16 << 9) + 372L);
  }
#line 227
  if (vcell == (long )(16 << 9) + 372L) {
#line 228
    goto errout;
  } else {
#line 230
    var = vcell;
  }
#line 233
  if ((long )(20 << 9) + 372L != env) {
#line 233
    goto _L;
  } else
#line 233
  if ((long )(18 << 9) + 372L == ((scm_cell *)var)->cdr) {
    _L: /* CIL Label */ 
#line 235
    var = ((scm_cell *)var)->car;
    errout: 
    {
#line 238
    tmp___0 = scm_listify(var, (long )(18 << 9) + 372L);
    }
#line 238
    if ((long )(20 << 9) + 372L == env) {
#line 238
      tmp___1 = "Unbound variable: %S";
    } else {
#line 238
      tmp___1 = "Damaged environment: %S";
    }
    {
#line 238
    scm_misc_error((char *)((void *)0), (char *)tmp___1, tmp___0);
    }
  }
#line 245
  ((scm_cell *)vloc)->car = var + 1L;
#line 249
  return (& ((scm_cell *)var)->cdr);
}
}
#line 254 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_unmemocar(SCM form , SCM env ) 
{ 
  register int ir ;
  SCM c ;
  SCM tmp ;

  {
#line 264
  if (6 & (int )form) {
#line 265
    return (form);
  }
#line 266
  c = ((scm_cell *)form)->car;
#line 267
  if (1L == (c & 7L)) {
#line 268
    ((scm_cell *)form)->car = ((scm_cell *)(c - 1L))->car;
  } else
#line 271
  if (((int )c & 255) == 252) {
#line 273
    ir = (int )(524032L >> 8) & ((int )c >> 8);
    {
#line 273
    while (1) {
      while_continue: /* CIL Label */ ;
#line 273
      if (! (ir != 0)) {
#line 273
        goto while_break;
      }
#line 274
      env = ((scm_cell *)env)->cdr;
#line 273
      ir --;
    }
    while_break: /* CIL Label */ ;
    }
#line 275
    env = ((scm_cell *)((scm_cell *)env)->car)->car;
#line 276
    ir = (int )((unsigned long )c >> 20);
    {
#line 276
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 276
      if (! (ir != 0)) {
#line 276
        goto while_break___0;
      }
#line 277
      env = ((scm_cell *)env)->cdr;
#line 276
      ir --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 278
    if (524288L & c) {
#line 278
      tmp = env;
    } else {
#line 278
      tmp = ((scm_cell *)env)->car;
    }
#line 278
    ((scm_cell *)form)->car = tmp;
  }
#line 282
  return (form);
}
}
#line 286 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_eval_car(SCM pair , SCM env ) 
{ 
  SCM *tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  SCM *tmp___2 ;
  SCM tmp___3 ;
  SCM tmp___4 ;
  SCM tmp___5 ;

  {
#line 291
  if ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )((scm_cell *)pair)->car)) {
#line 291
    if (6 & (int )((scm_cell *)pair)->car) {
#line 291
      if (((int )((scm_cell *)pair)->car & 255) == 252) {
        {
#line 291
        tmp = scm_ilookup(((scm_cell *)pair)->car, env);
#line 291
        tmp___0 = *tmp;
        }
      } else {
#line 291
        tmp___0 = ((scm_cell *)pair)->car;
      }
#line 291
      tmp___1 = tmp___0;
    } else {
#line 291
      tmp___1 = ((scm_cell *)(((scm_cell *)pair)->car - 1L))->cdr;
    }
#line 291
    tmp___5 = tmp___1;
  } else {
#line 291
    if ((125 & (int )((scm_cell *)((scm_cell *)pair)->car)->car) == 5) {
      {
#line 291
      tmp___2 = scm_lookupcar(pair, env);
#line 291
      tmp___4 = *tmp___2;
      }
    } else {
      {
#line 291
      tmp___3 = (*scm_ceval_ptr)(((scm_cell *)pair)->car, env);
#line 291
      tmp___4 = tmp___3;
      }
    }
#line 291
    tmp___5 = tmp___4;
  }
#line 291
  return (tmp___5);
}
}
#line 300 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
static char s_expression[28]  = 
#line 300
  {      (char )'m',      (char )'i',      (char )'s',      (char )'s', 
        (char )'i',      (char )'n',      (char )'g',      (char )' ', 
        (char )'o',      (char )'r',      (char )' ',      (char )'e', 
        (char )'x',      (char )'t',      (char )'r',      (char )'a', 
        (char )' ',      (char )'e',      (char )'x',      (char )'p', 
        (char )'r',      (char )'e',      (char )'s',      (char )'s', 
        (char )'i',      (char )'o',      (char )'n',      (char )'\000'};
#line 301 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
static char s_test[9]  = 
#line 301
  {      (char )'b',      (char )'a',      (char )'d',      (char )' ', 
        (char )'t',      (char )'e',      (char )'s',      (char )'t', 
        (char )'\000'};
#line 302 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
static char s_body[9]  = 
#line 302
  {      (char )'b',      (char )'a',      (char )'d',      (char )' ', 
        (char )'b',      (char )'o',      (char )'d',      (char )'y', 
        (char )'\000'};
#line 303 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
static char s_bindings[13]  = 
#line 303
  {      (char )'b',      (char )'a',      (char )'d',      (char )' ', 
        (char )'b',      (char )'i',      (char )'n',      (char )'d', 
        (char )'i',      (char )'n',      (char )'g',      (char )'s', 
        (char )'\000'};
#line 304 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
static char s_variable[13]  = 
#line 304
  {      (char )'b',      (char )'a',      (char )'d',      (char )' ', 
        (char )'v',      (char )'a',      (char )'r',      (char )'i', 
        (char )'a',      (char )'b',      (char )'l',      (char )'e', 
        (char )'\000'};
#line 305 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
static char s_clauses[23]  = 
#line 305
  {      (char )'b',      (char )'a',      (char )'d',      (char )' ', 
        (char )'o',      (char )'r',      (char )' ',      (char )'m', 
        (char )'i',      (char )'s',      (char )'s',      (char )'i', 
        (char )'n',      (char )'g',      (char )' ',      (char )'c', 
        (char )'l',      (char )'a',      (char )'u',      (char )'s', 
        (char )'e',      (char )'s',      (char )'\000'};
#line 306 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
static char s_formals[12]  = 
#line 306
  {      (char )'b',      (char )'a',      (char )'d',      (char )' ', 
        (char )'f',      (char )'o',      (char )'r',      (char )'m', 
        (char )'a',      (char )'l',      (char )'s',      (char )'\000'};
#line 311 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_i_define  ;
#line 311 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_i_and  ;
#line 311 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_i_begin  ;
#line 311 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_i_case  ;
#line 311 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_i_cond  ;
#line 311 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_i_do  ;
#line 311 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_i_if  ;
#line 311 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_i_letrec  ;
#line 311 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_i_letstar  ;
#line 311 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_i_or  ;
#line 311 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_i_set  ;
#line 311 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_i_atapply  ;
#line 311 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_i_atcall_cc  ;
#line 314 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
static char s_quasiquote[11]  = 
#line 314
  {      (char )'q',      (char )'u',      (char )'a',      (char )'s', 
        (char )'i',      (char )'q',      (char )'u',      (char )'o', 
        (char )'t',      (char )'e',      (char )'\000'};
#line 315 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
static char s_delay[6]  = {      (char )'d',      (char )'e',      (char )'l',      (char )'a', 
        (char )'y',      (char )'\000'};
#line 316 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
static char s_undefine[9]  = 
#line 316
  {      (char )'u',      (char )'n',      (char )'d',      (char )'e', 
        (char )'f',      (char )'i',      (char )'n',      (char )'e', 
        (char )'\000'};
#line 318 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_i_enter_frame  ;
#line 318 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_i_apply_frame  ;
#line 318 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_i_exit_frame  ;
#line 319 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_i_trace  ;
#line 326
static void bodycheck(SCM xorig , SCM *bodyloc , char *what ) ;
#line 328 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
static void bodycheck(SCM xorig , SCM *bodyloc , char *what ) 
{ 
  long tmp ;

  {
  {
#line 334
  tmp = scm_ilength(*bodyloc);
  }
#line 334
  if (! (tmp >= 1L)) {
    {
#line 334
    scm_wta(xorig, s_expression, what);
    }
  }
#line 335
  return;
}
}
#line 339 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_m_quote(SCM xorig , SCM env ) 
{ 
  long tmp ;
  SCM tmp___0 ;
  char *__cil_tmp5 ;

  {
  {
#line 344
  tmp = scm_ilength(((scm_cell *)xorig)->cdr);
  }
#line 344
  if (! (tmp == 1L)) {
    {
#line 344
    scm_wta(xorig, s_expression, (char *)"quote");
    }
  }
  {
#line 345
  tmp___0 = scm_cons((long )((11 << 9) + (11 << 3)) + 4L, ((scm_cell *)xorig)->cdr);
  }
#line 345
  return (tmp___0);
}
}
#line 350 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_m_begin(SCM xorig , SCM env ) 
{ 
  long tmp ;
  SCM tmp___0 ;
  char *__cil_tmp5 ;

  {
  {
#line 355
  tmp = scm_ilength(((scm_cell *)xorig)->cdr);
  }
#line 355
  if (! (tmp >= 1L)) {
    {
#line 355
    scm_wta(xorig, s_expression, (char *)"begin");
    }
  }
  {
#line 356
  tmp___0 = scm_cons((long )((1 << 9) + (1 << 3)) + 4L, ((scm_cell *)xorig)->cdr);
  }
#line 356
  return (tmp___0);
}
}
#line 361 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_m_if(SCM xorig , SCM env ) 
{ 
  int len ;
  long tmp ;
  SCM tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 366
  tmp = scm_ilength(((scm_cell *)xorig)->cdr);
#line 366
  len = (int )tmp;
  }
#line 367
  if (len >= 2) {
#line 367
    if (! (len <= 3)) {
      {
#line 367
      scm_wta(xorig, s_expression, (char *)"if");
      }
    }
  } else {
    {
#line 367
    scm_wta(xorig, s_expression, (char *)"if");
    }
  }
  {
#line 368
  tmp___0 = scm_cons((long )((5 << 9) + (5 << 3)) + 4L, ((scm_cell *)xorig)->cdr);
  }
#line 368
  return (tmp___0);
}
}
#line 373 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_m_set(SCM xorig , SCM env ) 
{ 
  SCM x ;
  long tmp ;
  SCM tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 378
  x = ((scm_cell *)xorig)->cdr;
#line 379
  tmp = scm_ilength(x);
  }
#line 379
  if (! (2L == tmp)) {
    {
#line 379
    scm_wta(xorig, s_expression, (char *)"set!");
    }
  }
#line 380
  if (! (6 & (int )((scm_cell *)x)->car)) {
#line 380
    if (! ((125 & (int )((scm_cell *)((scm_cell *)x)->car)->car) == 5)) {
      {
#line 380
      scm_wta(xorig, s_variable, (char *)"set!");
      }
    }
  } else {
    {
#line 380
    scm_wta(xorig, s_variable, (char *)"set!");
    }
  }
  {
#line 382
  tmp___0 = scm_cons((long )((12 << 9) + (12 << 3)) + 4L, x);
  }
#line 382
  return (tmp___0);
}
}
#line 426 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_m_and(SCM xorig , SCM env ) 
{ 
  int len ;
  long tmp ;
  SCM tmp___0 ;
  char *__cil_tmp6 ;

  {
  {
#line 431
  tmp = scm_ilength(((scm_cell *)xorig)->cdr);
#line 431
  len = (int )tmp;
  }
#line 432
  if (! (len >= 0)) {
    {
#line 432
    scm_wta(xorig, s_test, (char *)"and");
    }
  }
#line 433
  if (len >= 1) {
    {
#line 434
    tmp___0 = scm_cons(4L, ((scm_cell *)xorig)->cdr);
    }
#line 434
    return (tmp___0);
  } else {
#line 436
    return ((long )(17 << 9) + 372L);
  }
}
}
#line 441 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_m_or(SCM xorig , SCM env ) 
{ 
  int len ;
  long tmp ;
  SCM tmp___0 ;
  char *__cil_tmp6 ;

  {
  {
#line 446
  tmp = scm_ilength(((scm_cell *)xorig)->cdr);
#line 446
  len = (int )tmp;
  }
#line 447
  if (! (len >= 0)) {
    {
#line 447
    scm_wta(xorig, s_test, (char *)"or");
    }
  }
#line 448
  if (len >= 1) {
    {
#line 449
    tmp___0 = scm_cons((long )((10 << 9) + (10 << 3)) + 4L, ((scm_cell *)xorig)->cdr);
    }
#line 449
    return (tmp___0);
  } else {
#line 451
    return ((long )(16 << 9) + 372L);
  }
}
}
#line 456 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_m_case(SCM xorig , SCM env ) 
{ 
  SCM proc ;
  SCM x ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  SCM tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 461
  x = ((scm_cell *)xorig)->cdr;
#line 462
  tmp = scm_ilength(x);
  }
#line 462
  if (! (tmp >= 2L)) {
    {
#line 462
    scm_wta(xorig, s_clauses, (char *)"case");
    }
  }
  {
#line 463
  while (1) {
    while_continue: /* CIL Label */ ;
#line 463
    x = ((scm_cell *)x)->cdr;
#line 463
    if (6 & (int )x) {
#line 463
      goto while_break;
    }
    {
#line 465
    proc = ((scm_cell *)x)->car;
#line 466
    tmp___0 = scm_ilength(proc);
    }
#line 466
    if (! (tmp___0 >= 2L)) {
      {
#line 466
      scm_wta(xorig, s_clauses, (char *)"case");
      }
    }
    {
#line 467
    tmp___1 = scm_ilength(((scm_cell *)proc)->car);
    }
#line 467
    if (! (tmp___1 >= 0L)) {
#line 467
      if (! (scm_i_else == ((scm_cell *)proc)->car)) {
        {
#line 467
        scm_wta(xorig, s_clauses, (char *)"case");
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 470
  tmp___2 = scm_cons((long )((2 << 9) + (2 << 3)) + 4L, ((scm_cell *)xorig)->cdr);
  }
#line 470
  return (tmp___2);
}
}
#line 475 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_m_cond(SCM xorig , SCM env ) 
{ 
  SCM arg1 ;
  SCM x ;
  int len ;
  long tmp ;
  long tmp___0 ;
  SCM tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 480
  x = ((scm_cell *)xorig)->cdr;
#line 481
  tmp = scm_ilength(x);
#line 481
  len = (int )tmp;
  }
#line 482
  if (! (len >= 1)) {
    {
#line 482
    scm_wta(xorig, s_clauses, (char *)"cond");
    }
  }
  {
#line 483
  while (1) {
    while_continue: /* CIL Label */ ;
#line 483
    if (! (! (6 & (int )x))) {
#line 483
      goto while_break;
    }
    {
#line 485
    arg1 = ((scm_cell *)x)->car;
#line 486
    tmp___0 = scm_ilength(arg1);
#line 486
    len = (int )tmp___0;
    }
#line 487
    if (! (len >= 1)) {
      {
#line 487
      scm_wta(xorig, s_clauses, (char *)"cond");
      }
    }
#line 488
    if (scm_i_else == ((scm_cell *)arg1)->car) {
#line 490
      if ((long )(20 << 9) + 372L == ((scm_cell *)x)->cdr) {
#line 490
        if (! (len >= 2)) {
          {
#line 490
          scm_wta(xorig, (char *)"bad ELSE clause", (char *)"cond");
          }
        }
      } else {
        {
#line 490
        scm_wta(xorig, (char *)"bad ELSE clause", (char *)"cond");
        }
      }
#line 491
      ((scm_cell *)arg1)->car = (long )(17 << 9) + 372L;
    }
#line 493
    if (len >= 2) {
#line 493
      if (scm_i_arrow == ((scm_cell *)((scm_cell *)arg1)->cdr)->car) {
#line 494
        if (3 == len) {
#line 494
          if (! (! (6 & (int )((scm_cell *)((scm_cell *)((scm_cell *)arg1)->cdr)->cdr)->car))) {
            {
#line 494
            scm_wta(xorig, (char *)"bad recipient", (char *)"cond");
            }
          }
        } else {
          {
#line 494
          scm_wta(xorig, (char *)"bad recipient", (char *)"cond");
          }
        }
      }
    }
#line 496
    x = ((scm_cell *)x)->cdr;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 498
  tmp___1 = scm_cons((long )((3 << 9) + (3 << 3)) + 4L, ((scm_cell *)xorig)->cdr);
  }
#line 498
  return (tmp___1);
}
}
#line 503 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_m_lambda(SCM xorig , SCM env ) 
{ 
  SCM proc ;
  SCM x ;
  long tmp ;
  SCM tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 508
  x = ((scm_cell *)xorig)->cdr;
#line 509
  tmp = scm_ilength(x);
  }
#line 509
  if (tmp < 2L) {
#line 510
    goto badforms;
  }
#line 511
  proc = ((scm_cell *)x)->car;
#line 512
  if ((long )(20 << 9) + 372L == proc) {
#line 512
    goto memlambda;
  }
#line 514
  if (6 & (int )proc) {
#line 514
    goto badforms;
  }
#line 516
  if ((125 & (int )((scm_cell *)proc)->car) == 5) {
#line 516
    goto memlambda;
  }
#line 518
  if (1 & (int )((scm_cell *)proc)->car) {
#line 518
    goto badforms;
  }
  {
#line 520
  while (1) {
    while_continue: /* CIL Label */ ;
#line 520
    if (! (! (6 & (int )proc))) {
#line 520
      goto while_break;
    }
#line 523
    if (1 & (int )((scm_cell *)proc)->car) {
#line 525
      if (! ((125 & (int )((scm_cell *)proc)->car) == 5)) {
#line 526
        goto badforms;
      } else {
#line 528
        goto memlambda;
      }
    }
#line 529
    if (! (6 & (int )((scm_cell *)proc)->car)) {
#line 529
      if (! ((125 & (int )((scm_cell *)((scm_cell *)proc)->car)->car) == 5)) {
#line 530
        goto badforms;
      }
    } else {
#line 530
      goto badforms;
    }
#line 531
    proc = ((scm_cell *)proc)->cdr;
  }
  while_break: /* CIL Label */ ;
  }
#line 533
  if ((long )(20 << 9) + 372L != proc) {
    badforms: 
    {
#line 535
    scm_wta(xorig, s_formals, (char *)"lambda");
    }
  }
  memlambda: 
  {
#line 537
  bodycheck(xorig, & ((scm_cell *)x)->cdr, (char *)"lambda");
#line 538
  tmp___0 = scm_cons((long )((6 << 9) + (6 << 3)) + 4L, ((scm_cell *)xorig)->cdr);
  }
#line 538
  return (tmp___0);
}
}
#line 543 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_m_letstar(SCM xorig , SCM env ) 
{ 
  SCM x ;
  SCM arg1 ;
  SCM proc ;
  SCM vars ;
  SCM *varloc ;
  int len ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  SCM tmp___2 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 548
  x = ((scm_cell *)xorig)->cdr;
#line 548
  vars = (long )(20 << 9) + 372L;
#line 548
  varloc = & vars;
#line 549
  tmp = scm_ilength(x);
#line 549
  len = (int )tmp;
  }
#line 550
  if (! (len >= 2)) {
    {
#line 550
    scm_wta(xorig, s_body, (char *)"let*");
    }
  }
  {
#line 551
  proc = ((scm_cell *)x)->car;
#line 552
  tmp___0 = scm_ilength(proc);
  }
#line 552
  if (! (tmp___0 >= 0L)) {
    {
#line 552
    scm_wta(xorig, s_bindings, (char *)"let*");
    }
  }
  {
#line 553
  while (1) {
    while_continue: /* CIL Label */ ;
#line 553
    if (! (! (6 & (int )proc))) {
#line 553
      goto while_break;
    }
    {
#line 555
    arg1 = ((scm_cell *)proc)->car;
#line 556
    tmp___1 = scm_ilength(arg1);
    }
#line 556
    if (! (2L == tmp___1)) {
      {
#line 556
      scm_wta(xorig, s_bindings, (char *)"let*");
      }
    }
#line 557
    if (! (6 & (int )((scm_cell *)arg1)->car)) {
#line 557
      if (! ((125 & (int )((scm_cell *)((scm_cell *)arg1)->car)->car) == 5)) {
        {
#line 557
        scm_wta(xorig, s_variable, (char *)"let*");
        }
      }
    } else {
      {
#line 557
      scm_wta(xorig, s_variable, (char *)"let*");
      }
    }
    {
#line 558
    *varloc = scm_cons2(((scm_cell *)arg1)->car, ((scm_cell *)((scm_cell *)arg1)->cdr)->car,
                        (long )(20 << 9) + 372L);
#line 559
    varloc = & ((scm_cell *)((scm_cell *)*varloc)->cdr)->cdr;
#line 560
    proc = ((scm_cell *)proc)->cdr;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 562
  x = scm_cons(vars, ((scm_cell *)x)->cdr);
#line 563
  bodycheck(xorig, & ((scm_cell *)x)->cdr, (char *)"let*");
#line 564
  tmp___2 = scm_cons((long )((8 << 9) + (8 << 3)) + 4L, x);
  }
#line 564
  return (tmp___2);
}
}
#line 583 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_m_do(SCM xorig , SCM env ) 
{ 
  SCM x ;
  SCM arg1 ;
  SCM proc ;
  SCM vars ;
  SCM inits ;
  SCM steps ;
  SCM *initloc ;
  SCM *steploc ;
  int len ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  SCM tmp___2 ;
  long tmp___3 ;
  SCM tmp___4 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
#line 588
  x = ((scm_cell *)xorig)->cdr;
#line 589
  vars = (long )(20 << 9) + 372L;
#line 589
  inits = (long )(20 << 9) + 372L;
#line 589
  steps = (long )(20 << 9) + 372L;
#line 590
  initloc = & inits;
#line 590
  steploc = & steps;
#line 591
  tmp = scm_ilength(x);
#line 591
  len = (int )tmp;
  }
#line 592
  if (! (len >= 2)) {
    {
#line 592
    scm_wta(xorig, s_test, (char *)"do");
    }
  }
  {
#line 593
  proc = ((scm_cell *)x)->car;
#line 594
  tmp___0 = scm_ilength(proc);
  }
#line 594
  if (! (tmp___0 >= 0L)) {
    {
#line 594
    scm_wta(xorig, s_bindings, (char *)"do");
    }
  }
  {
#line 595
  while (1) {
    while_continue: /* CIL Label */ ;
#line 595
    if (! (! (6 & (int )proc))) {
#line 595
      goto while_break;
    }
    {
#line 598
    arg1 = ((scm_cell *)proc)->car;
#line 599
    tmp___1 = scm_ilength(arg1);
#line 599
    len = (int )tmp___1;
    }
#line 600
    if (! (2 == len)) {
#line 600
      if (! (3 == len)) {
        {
#line 600
        scm_wta(xorig, s_bindings, (char *)"do");
        }
      }
    }
#line 601
    if (! (6 & (int )((scm_cell *)arg1)->car)) {
#line 601
      if (! ((125 & (int )((scm_cell *)((scm_cell *)arg1)->car)->car) == 5)) {
        {
#line 601
        scm_wta(xorig, s_variable, (char *)"do");
        }
      }
    } else {
      {
#line 601
      scm_wta(xorig, s_variable, (char *)"do");
      }
    }
    {
#line 603
    vars = scm_cons(((scm_cell *)arg1)->car, vars);
#line 604
    arg1 = ((scm_cell *)arg1)->cdr;
#line 605
    *initloc = scm_cons(((scm_cell *)arg1)->car, (long )(20 << 9) + 372L);
#line 606
    initloc = & ((scm_cell *)*initloc)->cdr;
#line 607
    arg1 = ((scm_cell *)arg1)->cdr;
    }
#line 608
    if (6 & (int )arg1) {
#line 608
      tmp___2 = ((scm_cell *)vars)->car;
    } else {
#line 608
      tmp___2 = ((scm_cell *)arg1)->car;
    }
    {
#line 608
    *steploc = scm_cons(tmp___2, (long )(20 << 9) + 372L);
#line 609
    steploc = & ((scm_cell *)*steploc)->cdr;
#line 610
    proc = ((scm_cell *)proc)->cdr;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 612
  x = ((scm_cell *)x)->cdr;
#line 613
  tmp___3 = scm_ilength(((scm_cell *)x)->car);
  }
#line 613
  if (! (tmp___3 >= 1L)) {
    {
#line 613
    scm_wta(xorig, s_test, (char *)"do");
    }
  }
  {
#line 614
  x = scm_cons2(((scm_cell *)x)->car, ((scm_cell *)x)->cdr, steps);
#line 615
  x = scm_cons2(vars, inits, x);
#line 616
  bodycheck(xorig, & ((scm_cell *)((scm_cell *)((scm_cell *)x)->cdr)->cdr)->car, (char *)"do");
#line 617
  tmp___4 = scm_cons((long )((4 << 9) + (4 << 3)) + 4L, x);
  }
#line 617
  return (tmp___4);
}
}
#line 626
static SCM iqq(SCM form , SCM env , int depth ) ;
#line 628 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
static SCM iqq(SCM form , SCM env , int depth ) 
{ 
  SCM tmp ;
  int edepth ;
  long i ;
  SCM *data ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  SCM tmp___2 ;
  SCM tmp___3 ;
  SCM tmp___4 ;
  SCM tmp___5 ;
  SCM tmp___6 ;
  SCM tmp___7 ;
  SCM tmp___8 ;
  SCM tmp___9 ;
  SCM tmp___10 ;
  SCM tmp___11 ;

  {
#line 635
  edepth = depth;
#line 636
  if (6 & (int )form) {
#line 636
    return (form);
  }
#line 638
  if ((125 & (int )((scm_cell *)form)->car) == 13) {
#line 640
    i = (long )((unsigned long )((scm_cell *)form)->car >> 8);
#line 641
    data = (SCM *)((scm_cell *)form)->cdr;
#line 642
    tmp = (long )(20 << 9) + 372L;
    {
#line 643
    while (1) {
      while_continue: /* CIL Label */ ;
#line 643
      i --;
#line 643
      if (! (i >= 0L)) {
#line 643
        goto while_break;
      }
      {
#line 644
      tmp = scm_cons(*(data + i), tmp);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 645
    tmp___0 = iqq(tmp, env, depth);
#line 645
    tmp___1 = scm_vector(tmp___0);
    }
#line 645
    return (tmp___1);
  }
#line 647
  if (1 & (int )((scm_cell *)form)->car) {
#line 647
    return (form);
  }
#line 649
  tmp = ((scm_cell *)form)->car;
#line 650
  if (scm_i_quasiquote == tmp) {
#line 652
    depth ++;
#line 653
    goto label;
  }
#line 655
  if (scm_i_unquote == tmp) {
#line 657
    depth --;
    label: 
#line 659
    form = ((scm_cell *)form)->cdr;
#line 661
    if (! (6 & (int )form)) {
#line 661
      if (! (1 & (int )((scm_cell *)form)->car)) {
#line 661
        goto _L;
      } else
#line 661
      if (1 == (7 & (int )((scm_cell *)form)->car)) {
        _L: /* CIL Label */ 
#line 661
        if (! ((long )(20 << 9) + 372L == ((scm_cell *)form)->cdr)) {
          {
#line 661
          scm_wta(form, (char *)1, s_quasiquote);
          }
        }
      } else {
        {
#line 661
        scm_wta(form, (char *)1, s_quasiquote);
        }
      }
    } else {
      {
#line 661
      scm_wta(form, (char *)1, s_quasiquote);
      }
    }
#line 663
    if (0 == depth) {
      {
#line 664
      tmp___2 = scm_eval_car(form, env);
      }
#line 664
      return (tmp___2);
    }
    {
#line 665
    tmp___3 = iqq(((scm_cell *)form)->car, env, depth);
#line 665
    tmp___4 = scm_cons2(tmp, tmp___3, (long )(20 << 9) + 372L);
    }
#line 665
    return (tmp___4);
  }
#line 667
  if (! (6 & (int )tmp)) {
#line 667
    if (scm_i_uq_splicing == ((scm_cell *)tmp)->car) {
#line 669
      tmp = ((scm_cell *)tmp)->cdr;
#line 670
      edepth --;
#line 670
      if (0 == edepth) {
        {
#line 671
        tmp___5 = iqq(((scm_cell *)form)->cdr, env, depth);
#line 671
        tmp___6 = scm_eval_car(tmp, env);
#line 671
        tmp___7 = scm_cons2(tmp___6, tmp___5, (long )(20 << 9) + 372L);
#line 671
        tmp___8 = scm_append(tmp___7);
        }
#line 671
        return (tmp___8);
      }
    }
  }
  {
#line 673
  tmp___9 = iqq(((scm_cell *)form)->cdr, env, depth);
#line 673
  tmp___10 = iqq(((scm_cell *)form)->car, env, edepth);
#line 673
  tmp___11 = scm_cons(tmp___10, tmp___9);
  }
#line 673
  return (tmp___11);
}
}
#line 679 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_m_quasiquote(SCM xorig , SCM env ) 
{ 
  SCM x ;
  long tmp ;
  SCM tmp___0 ;

  {
  {
#line 684
  x = ((scm_cell *)xorig)->cdr;
#line 685
  tmp = scm_ilength(x);
  }
#line 685
  if (! (tmp == 1L)) {
    {
#line 685
    scm_wta(xorig, s_expression, s_quasiquote);
    }
  }
  {
#line 686
  tmp___0 = iqq(((scm_cell *)x)->car, env, 1);
  }
#line 686
  return (tmp___0);
}
}
#line 690 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_m_delay(SCM xorig , SCM env ) 
{ 
  long tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  SCM tmp___2 ;

  {
  {
#line 695
  tmp = scm_ilength(xorig);
  }
#line 695
  if (! (tmp == 2L)) {
    {
#line 695
    scm_wta(xorig, s_expression, s_delay);
    }
  }
  {
#line 696
  xorig = ((scm_cell *)xorig)->cdr;
#line 697
  tmp___0 = scm_cons2((long )(20 << 9) + 372L, ((scm_cell *)xorig)->car, ((scm_cell *)xorig)->cdr);
#line 697
  tmp___1 = scm_closure(tmp___0, env);
#line 697
  tmp___2 = scm_makprom(tmp___1);
  }
#line 697
  return (tmp___2);
}
}
#line 702
static SCM env_top_level(SCM env ) ;
#line 704 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
static SCM env_top_level(SCM env ) 
{ 
  SCM tmp ;

  {
  {
#line 708
  while (1) {
    while_continue: /* CIL Label */ ;
#line 708
    if (! (! (6 & (int )env))) {
#line 708
      goto while_break;
    }
    {
#line 710
    tmp = scm_procedure_p(((scm_cell *)env)->car);
    }
#line 710
    if ((long )(17 << 9) + 372L == tmp) {
#line 711
      return (((scm_cell *)env)->car);
    }
#line 712
    env = ((scm_cell *)env)->cdr;
  }
  while_break: /* CIL Label */ ;
  }
#line 714
  return ((long )(16 << 9) + 372L);
}
}
#line 718 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_m_define(SCM x , SCM env ) 
{ 
  SCM proc ;
  SCM arg1 ;
  long tmp ;
  SCM tmp___0 ;
  long tmp___1 ;
  SCM tmp___2 ;
  SCM tmp___3 ;
  SCM tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 723
  arg1 = x;
#line 724
  x = ((scm_cell *)x)->cdr;
#line 726
  tmp = scm_ilength(x);
  }
#line 726
  if (! (tmp >= 2L)) {
    {
#line 726
    scm_wta(arg1, s_expression, (char *)"define");
    }
  }
#line 727
  proc = ((scm_cell *)x)->car;
#line 728
  x = ((scm_cell *)x)->cdr;
  {
#line 729
  while (1) {
    while_continue: /* CIL Label */ ;
#line 729
    if (! (6 & (int )proc)) {
#line 729
      if (! (! (1 & (int )((scm_cell *)proc)->car))) {
#line 729
        goto while_break;
      }
    } else {
#line 729
      goto while_break;
    }
    {
#line 731
    tmp___0 = scm_cons2(scm_i_lambda, ((scm_cell *)proc)->cdr, x);
#line 731
    x = scm_cons(tmp___0, (long )(20 << 9) + 372L);
#line 732
    proc = ((scm_cell *)proc)->car;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 734
  if (! (6 & (int )proc)) {
#line 734
    if (! ((125 & (int )((scm_cell *)proc)->car) == 5)) {
      {
#line 734
      scm_wta(arg1, s_variable, (char *)"define");
      }
    }
  } else {
    {
#line 734
    scm_wta(arg1, s_variable, (char *)"define");
    }
  }
  {
#line 735
  tmp___1 = scm_ilength(x);
  }
#line 735
  if (! (1L == tmp___1)) {
    {
#line 735
    scm_wta(arg1, s_expression, (char *)"define");
    }
  }
#line 736
  if ((long )(20 << 9) + 372L == env) {
#line 736
    goto _L;
  } else {
    {
#line 736
    tmp___3 = scm_procedure_p(((scm_cell *)env)->car);
    }
#line 736
    if ((long )(17 << 9) + 372L == tmp___3) {
      _L: /* CIL Label */ 
      {
#line 738
      x = scm_eval_car(x, env);
      }
#line 740
      if (scm_debug_opts[3].val) {
        {
#line 741
        scm_set_procedure_property_x(x, scm_i_name, proc);
        }
      }
      {
#line 743
      tmp___2 = env_top_level(env);
#line 743
      arg1 = scm_sym2vcell(proc, tmp___2, (long )(17 << 9) + 372L);
#line 754
      ((scm_cell *)arg1)->cdr = x;
      }
#line 758
      return ((long )(21 << 9) + 372L);
    }
  }
  {
#line 761
  tmp___4 = scm_cons2((long )((13 << 9) + (13 << 3)) + 4L, proc, x);
  }
#line 761
  return (tmp___4);
}
}
#line 764 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_m_undefine(SCM x , SCM env ) 
{ 
  SCM arg1 ;
  SCM tmp ;
  SCM tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 768
  arg1 = x;
#line 769
  x = ((scm_cell *)x)->cdr;
#line 770
  if (! ((long )(20 << 9) + 372L == env)) {
    {
#line 770
    tmp = scm_procedure_p(((scm_cell *)env)->car);
    }
#line 770
    if (! ((long )(17 << 9) + 372L == tmp)) {
      {
#line 770
      scm_wta(arg1, (char *)"bad placement ", s_undefine);
      }
    }
  }
#line 771
  if (! (6 & (int )x)) {
#line 771
    if (! (1 & (int )((scm_cell *)x)->car)) {
#line 771
      if (! (((scm_cell *)x)->cdr == (long )(20 << 9) + 372L)) {
        {
#line 771
        scm_wta(arg1, s_expression, s_undefine);
        }
      }
    } else {
      {
#line 771
      scm_wta(arg1, s_expression, s_undefine);
      }
    }
  } else {
    {
#line 771
    scm_wta(arg1, s_expression, s_undefine);
    }
  }
#line 773
  x = ((scm_cell *)x)->car;
#line 774
  if (! (6 & (int )x)) {
#line 774
    if (! ((125 & (int )((scm_cell *)x)->car) == 5)) {
      {
#line 774
      scm_wta(arg1, s_variable, s_undefine);
      }
    }
  } else {
    {
#line 774
    scm_wta(arg1, s_variable, s_undefine);
    }
  }
  {
#line 775
  tmp___0 = env_top_level(env);
#line 775
  arg1 = scm_sym2vcell(x, tmp___0, (long )(16 << 9) + 372L);
  }
#line 776
  if ((long )(16 << 9) + 372L != arg1) {
#line 776
    if (! (! ((long )(18 << 9) + 372L == ((scm_cell *)arg1)->cdr))) {
      {
#line 776
      scm_wta(x, (char *)"variable already unbound ", s_undefine);
      }
    }
  } else {
    {
#line 776
    scm_wta(x, (char *)"variable already unbound ", s_undefine);
    }
  }
#line 787
  ((scm_cell *)arg1)->cdr = (long )(18 << 9) + 372L;
#line 791
  return ((long )(21 << 9) + 372L);
}
}
#line 798 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_m_letrec(SCM xorig , SCM env ) 
{ 
  SCM cdrx ;
  char *what ;
  SCM x ;
  SCM proc ;
  SCM arg1 ;
  SCM vars ;
  SCM inits ;
  SCM *initloc ;
  long tmp ;
  SCM tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  SCM tmp___3 ;

  {
  {
#line 803
  cdrx = ((scm_cell *)xorig)->cdr;
#line 804
  what = (char *)((scm_cell *)((scm_cell *)xorig)->car)->cdr;
#line 805
  x = cdrx;
#line 806
  vars = (long )(20 << 9) + 372L;
#line 806
  inits = (long )(20 << 9) + 372L;
#line 806
  initloc = & inits;
#line 808
  tmp = scm_ilength(x);
  }
#line 808
  if (! (tmp >= 2L)) {
    {
#line 808
    scm_wta(xorig, s_body, what);
    }
  }
#line 809
  proc = ((scm_cell *)x)->car;
#line 810
  if ((long )(20 << 9) + 372L == proc) {
    {
#line 810
    tmp___0 = scm_m_letstar(xorig, env);
    }
#line 810
    return (tmp___0);
  }
  {
#line 812
  tmp___1 = scm_ilength(proc);
  }
#line 812
  if (! (tmp___1 >= 1L)) {
    {
#line 812
    scm_wta(xorig, s_bindings, what);
    }
  }
  {
#line 813
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 816
    arg1 = ((scm_cell *)proc)->car;
#line 817
    tmp___2 = scm_ilength(arg1);
    }
#line 817
    if (! (2L == tmp___2)) {
      {
#line 817
      scm_wta(xorig, s_bindings, what);
      }
    }
#line 818
    if (! (6 & (int )((scm_cell *)arg1)->car)) {
#line 818
      if (! ((125 & (int )((scm_cell *)((scm_cell *)arg1)->car)->car) == 5)) {
        {
#line 818
        scm_wta(xorig, s_variable, what);
        }
      }
    } else {
      {
#line 818
      scm_wta(xorig, s_variable, what);
      }
    }
    {
#line 819
    vars = scm_cons(((scm_cell *)arg1)->car, vars);
#line 820
    *initloc = scm_cons(((scm_cell *)((scm_cell *)arg1)->cdr)->car, (long )(20 << 9) + 372L);
#line 821
    initloc = & ((scm_cell *)*initloc)->cdr;
#line 813
    proc = ((scm_cell *)proc)->cdr;
    }
#line 813
    if (6 & (int )proc) {
#line 813
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 825
  cdrx = scm_cons2(vars, inits, ((scm_cell *)x)->cdr);
#line 826
  bodycheck(xorig, & ((scm_cell *)((scm_cell *)cdrx)->cdr)->cdr, what);
#line 827
  tmp___3 = scm_cons((long )((9 << 9) + (9 << 3)) + 4L, cdrx);
  }
#line 827
  return (tmp___3);
}
}
#line 831 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_m_let(SCM xorig , SCM env ) 
{ 
  SCM cdrx ;
  SCM x ;
  SCM proc ;
  SCM arg1 ;
  SCM name ;
  SCM vars ;
  SCM inits ;
  SCM *varloc ;
  SCM *initloc ;
  long tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  SCM tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  SCM tmp___6 ;
  SCM tmp___7 ;
  SCM tmp___8 ;
  SCM tmp___9 ;
  SCM tmp___10 ;
  SCM tmp___11 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
  {
#line 836
  cdrx = ((scm_cell *)xorig)->cdr;
#line 837
  x = cdrx;
#line 838
  vars = (long )(20 << 9) + 372L;
#line 838
  inits = (long )(20 << 9) + 372L;
#line 838
  varloc = & vars;
#line 838
  initloc = & inits;
#line 840
  tmp = scm_ilength(x);
  }
#line 840
  if (! (tmp >= 2L)) {
    {
#line 840
    scm_wta(xorig, s_body, (char *)"let");
    }
  }
#line 841
  proc = ((scm_cell *)x)->car;
#line 842
  if ((long )(20 << 9) + 372L == proc) {
    {
#line 845
    tmp___0 = scm_m_letstar(xorig, env);
    }
#line 845
    return (tmp___0);
  } else
#line 842
  if (! (6 & (int )proc)) {
#line 842
    if (! (1 & (int )((scm_cell *)proc)->car)) {
#line 842
      if (! (6 & (int )((scm_cell *)proc)->car)) {
#line 842
        if (! (1 & (int )((scm_cell *)((scm_cell *)proc)->car)->car)) {
#line 842
          if ((long )(20 << 9) + 372L == ((scm_cell *)proc)->cdr) {
            {
#line 845
            tmp___0 = scm_m_letstar(xorig, env);
            }
#line 845
            return (tmp___0);
          }
        }
      }
    }
  }
#line 846
  if (! (! (6 & (int )proc))) {
    {
#line 846
    scm_wta(xorig, s_bindings, (char *)"let");
    }
  }
#line 847
  if (! (1 & (int )((scm_cell *)proc)->car)) {
    {
#line 848
    tmp___1 = scm_m_letrec(xorig, env);
#line 848
    tmp___2 = scm_cons((long )((7 << 9) + (7 << 3)) + 4L, ((scm_cell *)tmp___1)->cdr);
    }
#line 848
    return (tmp___2);
  }
#line 849
  if (! ((125 & (int )((scm_cell *)proc)->car) == 5)) {
    {
#line 850
    scm_wta(xorig, s_bindings, (char *)"let");
    }
  }
  {
#line 851
  name = proc;
#line 852
  x = ((scm_cell *)x)->cdr;
#line 853
  tmp___3 = scm_ilength(x);
  }
#line 853
  if (! (tmp___3 >= 2L)) {
    {
#line 853
    scm_wta(xorig, s_body, (char *)"let");
    }
  }
  {
#line 854
  proc = ((scm_cell *)x)->car;
#line 855
  tmp___4 = scm_ilength(proc);
  }
#line 855
  if (! (tmp___4 >= 0L)) {
    {
#line 855
    scm_wta(xorig, s_bindings, (char *)"let");
    }
  }
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (! (! (6 & (int )proc))) {
#line 856
      goto while_break;
    }
    {
#line 859
    arg1 = ((scm_cell *)proc)->car;
#line 860
    tmp___5 = scm_ilength(arg1);
    }
#line 860
    if (! (2L == tmp___5)) {
      {
#line 860
      scm_wta(xorig, s_bindings, (char *)"let");
      }
    }
#line 861
    if (! (6 & (int )((scm_cell *)arg1)->car)) {
#line 861
      if (! ((125 & (int )((scm_cell *)((scm_cell *)arg1)->car)->car) == 5)) {
        {
#line 861
        scm_wta(xorig, s_variable, (char *)"let");
        }
      }
    } else {
      {
#line 861
      scm_wta(xorig, s_variable, (char *)"let");
      }
    }
    {
#line 862
    *varloc = scm_cons(((scm_cell *)arg1)->car, (long )(20 << 9) + 372L);
#line 863
    varloc = & ((scm_cell *)*varloc)->cdr;
#line 864
    *initloc = scm_cons(((scm_cell *)((scm_cell *)arg1)->cdr)->car, (long )(20 << 9) + 372L);
#line 865
    initloc = & ((scm_cell *)*initloc)->cdr;
#line 866
    proc = ((scm_cell *)proc)->cdr;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 868
  tmp___6 = scm_acons(name, inits, (long )(20 << 9) + 372L);
#line 868
  tmp___7 = scm_cons2(scm_i_lambda, vars, ((scm_cell *)x)->cdr);
#line 868
  tmp___8 = scm_cons2(name, tmp___7, (long )(20 << 9) + 372L);
#line 868
  tmp___9 = scm_cons(tmp___8, (long )(20 << 9) + 372L);
#line 868
  tmp___10 = scm_cons2(scm_i_let, tmp___9, tmp___6);
#line 868
  tmp___11 = scm_m_letrec(tmp___10, env);
  }
#line 868
  return (tmp___11);
}
}
#line 877 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_m_apply(SCM xorig , SCM env ) 
{ 
  long tmp ;
  SCM tmp___0 ;
  char *__cil_tmp5 ;

  {
  {
#line 882
  tmp = scm_ilength(((scm_cell *)xorig)->cdr);
  }
#line 882
  if (! (tmp == 2L)) {
    {
#line 882
    scm_wta(xorig, s_expression, (char *)"@apply");
    }
  }
  {
#line 883
  tmp___0 = scm_cons((long )(14 << 9) + 116L, ((scm_cell *)xorig)->cdr);
  }
#line 883
  return (tmp___0);
}
}
#line 889 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_m_cont(SCM xorig , SCM env ) 
{ 
  long tmp ;
  SCM tmp___0 ;
  char *__cil_tmp5 ;

  {
  {
#line 894
  tmp = scm_ilength(((scm_cell *)xorig)->cdr);
  }
#line 894
  if (! (tmp == 1L)) {
    {
#line 894
    scm_wta(xorig, s_expression, (char *)"@call-with-current-continuation");
    }
  }
  {
#line 895
  tmp___0 = scm_cons((long )(15 << 9) + 116L, ((scm_cell *)xorig)->cdr);
  }
#line 895
  return (tmp___0);
}
}
#line 907
static SCM unmemocopy(SCM x , SCM env ) ;
#line 909 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
static SCM unmemocopy(SCM x , SCM env ) 
{ 
  SCM ls ;
  SCM z ;
  SCM p ;
  SCM f ;
  SCM v ;
  SCM e ;
  SCM s___0 ;
  SCM tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  SCM tmp___2 ;
  SCM tmp___3 ;
  long tmp___4 ;
  SCM tmp___5 ;
  SCM tmp___6 ;
  SCM tmp___7 ;
  SCM b ;
  SCM y ;
  SCM tmp___8 ;
  SCM tmp___9 ;
  SCM tmp___10 ;
  SCM tmp___11 ;
  SCM tmp___12 ;
  SCM tmp___13 ;
  SCM tmp___14 ;
  SCM n ;
  SCM tmp___15 ;
  SCM tmp___16 ;
  SCM tmp___17 ;
  SCM tmp___18 ;
  SCM tmp___19 ;
  SCM tmp___20 ;
  register SCM w ;
  SCM tmp___21 ;

  {
#line 918
  if ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )x)) {
#line 919
    return (x);
  } else
#line 918
  if (1 & (int )((scm_cell *)x)->car) {
#line 918
    if (1 != (7 & (int )((scm_cell *)x)->car)) {
#line 919
      return (x);
    }
  }
  {
#line 921
  p = scm_hash_fn_ref(scm_sys_protects[16], x, (long )(16 << 9) + 372L, (unsigned int (*)())(& scm_ihashq),
                      (SCM (*)())(& scm_sloppy_assq), (void *)0);
  }
  {
#line 925
  if ((127 & (int )((scm_cell *)x)->car) == 4) {
#line 925
    goto case_4;
  }
#line 928
  if ((127 & (int )((scm_cell *)x)->car) == (int )(127L & ((long )((1 << 9) + (1 << 3)) + 4L))) {
#line 928
    goto case_exp;
  }
#line 931
  if ((127 & (int )((scm_cell *)x)->car) == (int )(127L & ((long )((2 << 9) + (2 << 3)) + 4L))) {
#line 931
    goto case_exp___0;
  }
#line 934
  if ((127 & (int )((scm_cell *)x)->car) == (int )(127L & ((long )((3 << 9) + (3 << 3)) + 4L))) {
#line 934
    goto case_exp___1;
  }
#line 937
  if ((127 & (int )((scm_cell *)x)->car) == (int )(127L & ((long )((4 << 9) + (4 << 3)) + 4L))) {
#line 937
    goto case_exp___2;
  }
#line 940
  if ((127 & (int )((scm_cell *)x)->car) == (int )(127L & ((long )((5 << 9) + (5 << 3)) + 4L))) {
#line 940
    goto case_exp___3;
  }
#line 943
  if ((127 & (int )((scm_cell *)x)->car) == (int )(127L & ((long )((7 << 9) + (7 << 3)) + 4L))) {
#line 943
    goto case_exp___4;
  }
#line 946
  if ((127 & (int )((scm_cell *)x)->car) == (int )(127L & ((long )((9 << 9) + (9 << 3)) + 4L))) {
#line 946
    goto case_exp___5;
  }
#line 987
  if ((127 & (int )((scm_cell *)x)->car) == (int )(127L & ((long )((8 << 9) + (8 << 3)) + 4L))) {
#line 987
    goto case_exp___6;
  }
#line 1026
  if ((127 & (int )((scm_cell *)x)->car) == (int )(127L & ((long )((10 << 9) + (10 << 3)) + 4L))) {
#line 1026
    goto case_exp___7;
  }
#line 1029
  if ((127 & (int )((scm_cell *)x)->car) == (int )(127L & ((long )((6 << 9) + (6 << 3)) + 4L))) {
#line 1029
    goto case_exp___8;
  }
#line 1035
  if ((127 & (int )((scm_cell *)x)->car) == (int )(127L & ((long )((11 << 9) + (11 << 3)) + 4L))) {
#line 1035
    goto case_exp___9;
  }
#line 1038
  if ((127 & (int )((scm_cell *)x)->car) == (int )(127L & ((long )((12 << 9) + (12 << 3)) + 4L))) {
#line 1038
    goto case_exp___10;
  }
#line 1041
  if ((127 & (int )((scm_cell *)x)->car) == (int )(127L & ((long )((13 << 9) + (13 << 3)) + 4L))) {
#line 1041
    goto case_exp___11;
  }
#line 1051
  if ((127 & (int )((scm_cell *)x)->car) == 116) {
#line 1051
    goto case_116;
  }
#line 1067
  goto unmemo;
  case_4: /* CIL Label */ 
  {
#line 926
  z = scm_cons(scm_i_and, (long )(21 << 9) + 372L);
#line 926
  ls = z;
  }
#line 927
  goto switch_break;
  case_exp: /* CIL Label */ 
  {
#line 929
  z = scm_cons(scm_i_begin, (long )(21 << 9) + 372L);
#line 929
  ls = z;
  }
#line 930
  goto switch_break;
  case_exp___0: /* CIL Label */ 
  {
#line 932
  z = scm_cons(scm_i_case, (long )(21 << 9) + 372L);
#line 932
  ls = z;
  }
#line 933
  goto switch_break;
  case_exp___1: /* CIL Label */ 
  {
#line 935
  z = scm_cons(scm_i_cond, (long )(21 << 9) + 372L);
#line 935
  ls = z;
  }
#line 936
  goto switch_break;
  case_exp___2: /* CIL Label */ 
  {
#line 938
  ls = scm_cons(scm_i_do, (long )(21 << 9) + 372L);
  }
#line 939
  goto transform;
  case_exp___3: /* CIL Label */ 
  {
#line 941
  z = scm_cons(scm_i_if, (long )(21 << 9) + 372L);
#line 941
  ls = z;
  }
#line 942
  goto switch_break;
  case_exp___4: /* CIL Label */ 
  {
#line 944
  ls = scm_cons(scm_i_let, (long )(21 << 9) + 372L);
  }
#line 945
  goto transform;
  case_exp___5: /* CIL Label */ 
  {
#line 949
  ls = scm_cons(scm_i_letrec, (long )(21 << 9) + 372L);
  }
  transform: 
  {
#line 951
  x = ((scm_cell *)x)->cdr;
#line 952
  v = ((scm_cell *)x)->car;
#line 952
  f = v;
#line 953
  x = ((scm_cell *)x)->cdr;
#line 954
  z = scm_acons(f, (long )(20 << 9) + 372L, env);
  }
#line 955
  if (((scm_cell *)ls)->car == scm_i_letrec) {
#line 955
    tmp = z;
  } else {
#line 955
    tmp = env;
  }
  {
#line 955
  tmp___0 = unmemocopy(((scm_cell *)x)->car, tmp);
#line 955
  e = scm_reverse(tmp___0);
#line 957
  env = z;
  }
#line 958
  if (((scm_cell *)ls)->car == scm_i_do) {
    {
#line 958
    tmp___1 = unmemocopy(((scm_cell *)((scm_cell *)((scm_cell *)x)->cdr)->cdr)->cdr,
                         env);
#line 958
    tmp___2 = scm_reverse(tmp___1);
#line 958
    s___0 = tmp___2;
    }
  } else {
#line 958
    s___0 = f;
  }
#line 961
  z = (long )(20 << 9) + 372L;
  {
#line 962
  while (1) {
    while_continue: /* CIL Label */ ;
#line 964
    if (((scm_cell *)s___0)->car == ((scm_cell *)v)->car) {
#line 964
      tmp___4 = (long )(20 << 9) + 372L;
    } else {
      {
#line 964
      tmp___3 = scm_cons(((scm_cell *)s___0)->car, (long )(20 << 9) + 372L);
#line 964
      tmp___4 = tmp___3;
      }
    }
    {
#line 964
    tmp___5 = scm_cons(((scm_cell *)e)->car, tmp___4);
#line 964
    z = scm_acons(((scm_cell *)v)->car, tmp___5, z);
#line 970
    v = ((scm_cell *)v)->cdr;
#line 971
    e = ((scm_cell *)e)->cdr;
#line 972
    s___0 = ((scm_cell *)s___0)->cdr;
    }
#line 962
    if (! (! (6 & (int )v))) {
#line 962
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 975
  z = scm_cons(z, (long )(21 << 9) + 372L);
#line 976
  ((scm_cell *)ls)->cdr = z;
  }
#line 977
  if (((scm_cell *)ls)->car == scm_i_do) {
    {
#line 979
    x = ((scm_cell *)x)->cdr;
#line 980
    tmp___6 = unmemocopy(((scm_cell *)x)->car, env);
#line 980
    tmp___7 = scm_cons(tmp___6, (long )(21 << 9) + 372L);
#line 980
    ((scm_cell *)z)->cdr = tmp___7;
#line 982
    z = ((scm_cell *)z)->cdr;
#line 983
    x = (SCM )(& ((scm_cell *)((scm_cell *)x)->cdr)->car - 1);
    }
  }
#line 985
  goto switch_break;
  case_exp___6: /* CIL Label */ 
#line 990
  x = ((scm_cell *)x)->cdr;
#line 991
  b = ((scm_cell *)x)->car;
#line 992
  y = (long )(20 << 9) + 372L;
#line 993
  if (6 & (int )b) {
    {
#line 995
    env = scm_acons((long )(20 << 9) + 372L, (long )(20 << 9) + 372L, env);
    }
#line 996
    goto letstar;
  }
  {
#line 998
  tmp___8 = unmemocopy(((scm_cell *)((scm_cell *)b)->cdr)->car, env);
#line 998
  tmp___9 = scm_cons(tmp___8, (long )(20 << 9) + 372L);
#line 998
  tmp___10 = scm_unmemocar(tmp___9, env);
#line 998
  z = scm_acons(((scm_cell *)b)->car, tmp___10, (long )(21 << 9) + 372L);
#line 998
  y = z;
#line 1002
  env = scm_acons(((scm_cell *)b)->car, (long )(16 << 9) + 372L, env);
#line 1003
  b = ((scm_cell *)((scm_cell *)b)->cdr)->cdr;
  }
#line 1004
  if (6 & (int )b) {
    {
#line 1006
    ((scm_cell *)y)->cdr = (long )(20 << 9) + 372L;
#line 1007
    z = scm_cons(y, (long )(21 << 9) + 372L);
#line 1007
    ls = scm_cons(scm_i_let, z);
    }
#line 1008
    goto switch_break;
  }
  {
#line 1010
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1012
    tmp___11 = unmemocopy(((scm_cell *)((scm_cell *)b)->cdr)->car, env);
#line 1012
    tmp___12 = scm_cons(tmp___11, (long )(20 << 9) + 372L);
#line 1012
    tmp___13 = scm_unmemocar(tmp___12, env);
#line 1012
    tmp___14 = scm_acons(((scm_cell *)b)->car, tmp___13, (long )(21 << 9) + 372L);
#line 1012
    ((scm_cell *)z)->cdr = tmp___14;
#line 1016
    z = ((scm_cell *)z)->cdr;
#line 1017
    env = scm_acons(((scm_cell *)b)->car, (long )(16 << 9) + 372L, env);
#line 1018
    b = ((scm_cell *)((scm_cell *)b)->cdr)->cdr;
    }
#line 1010
    if (! (! (6 & (int )b))) {
#line 1010
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1021
  ((scm_cell *)z)->cdr = (long )(20 << 9) + 372L;
  letstar: 
  {
#line 1023
  z = scm_cons(y, (long )(21 << 9) + 372L);
#line 1023
  ls = scm_cons(scm_i_letstar, z);
  }
#line 1024
  goto switch_break;
  case_exp___7: /* CIL Label */ 
  {
#line 1027
  z = scm_cons(scm_i_or, (long )(21 << 9) + 372L);
#line 1027
  ls = z;
  }
#line 1028
  goto switch_break;
  case_exp___8: /* CIL Label */ 
  {
#line 1030
  x = ((scm_cell *)x)->cdr;
#line 1031
  z = scm_cons(((scm_cell *)x)->car, (long )(21 << 9) + 372L);
#line 1031
  ls = scm_cons(scm_i_lambda, z);
#line 1033
  env = scm_acons(((scm_cell *)x)->car, (long )(20 << 9) + 372L, env);
  }
#line 1034
  goto switch_break;
  case_exp___9: /* CIL Label */ 
  {
#line 1036
  z = scm_cons(scm_i_quote, (long )(21 << 9) + 372L);
#line 1036
  ls = z;
  }
#line 1037
  goto switch_break;
  case_exp___10: /* CIL Label */ 
  {
#line 1039
  z = scm_cons(scm_i_set, (long )(21 << 9) + 372L);
#line 1039
  ls = z;
  }
#line 1040
  goto switch_break;
  case_exp___11: /* CIL Label */ 
  {
#line 1044
  x = ((scm_cell *)x)->cdr;
#line 1045
  n = ((scm_cell *)x)->car;
#line 1045
  z = scm_cons(n, (long )(21 << 9) + 372L);
#line 1045
  ls = scm_cons(scm_i_define, z);
  }
#line 1047
  if ((long )(20 << 9) + 372L != env) {
    {
#line 1048
    tmp___15 = scm_cons(n, ((scm_cell *)((scm_cell *)env)->car)->car);
#line 1048
    ((scm_cell *)((scm_cell *)env)->car)->car = tmp___15;
    }
  }
#line 1049
  goto switch_break;
  case_116: /* CIL Label */ 
#line 1052
  z = ((scm_cell *)x)->car;
#line 1053
  if (! ((391 & (int )z) == 4)) {
#line 1054
    goto unmemo;
  }
  {
#line 1057
  if ((int )(z >> 9) == (int )(((long )(14 << 9) + 116L) >> 9)) {
#line 1057
    goto case_exp___12;
  }
#line 1060
  if ((int )(z >> 9) == (int )(((long )(15 << 9) + 116L) >> 9)) {
#line 1060
    goto case_exp___13;
  }
#line 1063
  goto switch_default;
  case_exp___12: /* CIL Label */ 
  {
#line 1058
  z = scm_cons(scm_i_atapply, (long )(21 << 9) + 372L);
#line 1058
  ls = z;
  }
#line 1059
  goto loop;
  case_exp___13: /* CIL Label */ 
  {
#line 1061
  z = scm_cons(scm_i_atcall_cc, (long )(21 << 9) + 372L);
#line 1061
  ls = z;
  }
#line 1062
  goto loop;
  switch_default: /* CIL Label */ 
#line 1064
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  unmemo: 
  switch_default___0: /* CIL Label */ 
  {
#line 1068
  tmp___16 = unmemocopy(((scm_cell *)x)->car, env);
#line 1068
  tmp___17 = scm_cons(tmp___16, (long )(21 << 9) + 372L);
#line 1068
  z = scm_unmemocar(tmp___17, env);
#line 1068
  ls = z;
  }
  switch_break: /* CIL Label */ ;
  }
  loop: 
  {
#line 1073
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1073
    x = ((scm_cell *)x)->cdr;
#line 1073
    if ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )x)) {
#line 1073
      goto while_break___1;
    } else
#line 1073
    if (! (! (1 & (int )((scm_cell *)x)->car))) {
#line 1073
      if (! (1 == (7 & (int )((scm_cell *)x)->car))) {
#line 1073
        goto while_break___1;
      }
    }
    {
#line 1075
    tmp___18 = unmemocopy(((scm_cell *)x)->car, env);
#line 1075
    tmp___19 = scm_cons(tmp___18, (long )(21 << 9) + 372L);
#line 1075
    tmp___20 = scm_unmemocar(tmp___19, env);
#line 1075
    ((scm_cell *)z)->cdr = tmp___20;
#line 1078
    z = ((scm_cell *)z)->cdr;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1080
  ((scm_cell *)z)->cdr = x;
#line 1082
  if ((long )(16 << 9) + 372L != p) {
    {
#line 1083
    w = scm_sys_protects[16];
#line 1083
    tmp___21 = scm_hash_fn_create_handle_x(w, ls, (long )(21 << 9) + 372L, (unsigned int (*)())(& scm_ihashq),
                                           (SCM (*)())(& scm_sloppy_assq), (void *)0);
#line 1083
    ((scm_cell *)tmp___21)->cdr = p;
    }
  }
#line 1085
  return (ls);
}
}
#line 1089 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_unmemocopy(SCM x , SCM env ) 
{ 
  SCM tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;

  {
#line 1094
  if ((long )(20 << 9) + 372L != env) {
    {
#line 1097
    tmp = scm_cons(((scm_cell *)env)->car, ((scm_cell *)env)->cdr);
#line 1097
    tmp___0 = unmemocopy(x, tmp);
    }
#line 1097
    return (tmp___0);
  } else {
    {
#line 1099
    tmp___1 = unmemocopy(x, env);
    }
#line 1099
    return (tmp___1);
  }
}
}
#line 1104 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
int scm_badargsp(SCM formals , SCM args ) 
{ 
  int tmp ;

  {
  {
#line 1109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1109
    if (! (! (6 & (int )formals))) {
#line 1109
      goto while_break;
    }
#line 1112
    if (1 & (int )((scm_cell *)formals)->car) {
#line 1112
      return (0);
    }
#line 1114
    if (6 & (int )args) {
#line 1114
      return (1);
    }
#line 1116
    formals = ((scm_cell *)formals)->cdr;
#line 1117
    args = ((scm_cell *)args)->cdr;
  }
  while_break: /* CIL Label */ ;
  }
#line 1119
  if ((long )(20 << 9) + 372L != args) {
#line 1119
    tmp = 1;
  } else {
#line 1119
    tmp = 0;
  }
#line 1119
  return (tmp);
}
}
#line 1125 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
long scm_tc16_macro  ;
#line 1128 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_eval_args(SCM l , SCM env ) 
{ 
  SCM res ;
  SCM *lloc ;
  SCM *tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  SCM *tmp___2 ;
  SCM tmp___3 ;
  SCM tmp___4 ;
  SCM tmp___5 ;

  {
#line 1133
  res = (long )(20 << 9) + 372L;
#line 1133
  lloc = & res;
  {
#line 1134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1134
    if (! (! (6 & (int )l))) {
#line 1134
      goto while_break;
    }
#line 1136
    if ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )((scm_cell *)l)->car)) {
#line 1136
      if (6 & (int )((scm_cell *)l)->car) {
#line 1136
        if (((int )((scm_cell *)l)->car & 255) == 252) {
          {
#line 1136
          tmp = scm_ilookup(((scm_cell *)l)->car, env);
#line 1136
          tmp___0 = *tmp;
          }
        } else {
#line 1136
          tmp___0 = ((scm_cell *)l)->car;
        }
#line 1136
        tmp___1 = tmp___0;
      } else {
#line 1136
        tmp___1 = ((scm_cell *)(((scm_cell *)l)->car - 1L))->cdr;
      }
#line 1136
      tmp___5 = tmp___1;
    } else {
#line 1136
      if ((125 & (int )((scm_cell *)((scm_cell *)l)->car)->car) == 5) {
        {
#line 1136
        tmp___2 = scm_lookupcar(l, env);
#line 1136
        tmp___4 = *tmp___2;
        }
      } else {
        {
#line 1136
        tmp___3 = scm_ceval(((scm_cell *)l)->car, env);
#line 1136
        tmp___4 = tmp___3;
        }
      }
#line 1136
      tmp___5 = tmp___4;
    }
    {
#line 1136
    *lloc = scm_cons(tmp___5, (long )(20 << 9) + 372L);
#line 1137
    lloc = & ((scm_cell *)*lloc)->cdr;
#line 1138
    l = ((scm_cell *)l)->cdr;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1140
  return (res);
}
}
#line 1306 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_ceval(SCM x , SCM env ) 
{ 
  union __anonunion_t_25 t ;
  SCM proc ;
  SCM arg2 ;
  SCM *tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  SCM *tmp___2 ;
  SCM tmp___3 ;
  SCM tmp___4 ;
  SCM tmp___5 ;
  SCM *tmp___6 ;
  SCM tmp___7 ;
  SCM tmp___8 ;
  SCM *tmp___9 ;
  SCM *tmp___10 ;
  SCM tmp___11 ;
  SCM tmp___12 ;
  SCM *tmp___13 ;
  SCM tmp___14 ;
  SCM tmp___15 ;
  SCM tmp___16 ;
  SCM *tmp___17 ;
  SCM tmp___18 ;
  SCM tmp___19 ;
  SCM *tmp___20 ;
  SCM tmp___21 ;
  SCM tmp___22 ;
  SCM *tmp___23 ;
  SCM tmp___24 ;
  SCM tmp___25 ;
  SCM *tmp___26 ;
  SCM tmp___27 ;
  SCM tmp___28 ;
  SCM *tmp___29 ;
  SCM tmp___30 ;
  SCM tmp___31 ;
  SCM *tmp___32 ;
  SCM tmp___33 ;
  SCM tmp___34 ;
  SCM tmp___35 ;
  SCM *tmp___36 ;
  SCM tmp___37 ;
  SCM tmp___38 ;
  SCM *tmp___39 ;
  SCM tmp___40 ;
  SCM tmp___41 ;
  SCM tmp___42 ;
  SCM *tmp___43 ;
  SCM tmp___44 ;
  SCM tmp___45 ;
  SCM *tmp___46 ;
  SCM tmp___47 ;
  SCM tmp___48 ;
  SCM tmp___49 ;
  SCM *tmp___50 ;
  SCM tmp___51 ;
  SCM tmp___52 ;
  SCM *tmp___53 ;
  SCM tmp___54 ;
  SCM tmp___55 ;
  SCM tmp___56 ;
  SCM *tmp___57 ;
  SCM tmp___58 ;
  SCM tmp___59 ;
  SCM *tmp___60 ;
  SCM tmp___61 ;
  SCM tmp___62 ;
  SCM tmp___63 ;
  SCM *tmp___64 ;
  SCM tmp___65 ;
  SCM tmp___66 ;
  SCM *tmp___67 ;
  SCM tmp___68 ;
  SCM tmp___69 ;
  SCM tmp___70 ;
  SCM *tmp___71 ;
  SCM tmp___72 ;
  SCM tmp___73 ;
  SCM *tmp___74 ;
  SCM tmp___75 ;
  SCM tmp___76 ;
  SCM tmp___77 ;
  SCM *tmp___78 ;
  SCM tmp___79 ;
  SCM tmp___80 ;
  SCM *tmp___81 ;
  SCM tmp___82 ;
  SCM tmp___83 ;
  SCM tmp___84 ;
  SCM *tmp___85 ;
  SCM tmp___86 ;
  SCM tmp___87 ;
  SCM *tmp___88 ;
  SCM tmp___89 ;
  SCM tmp___90 ;
  SCM tmp___91 ;
  SCM tmp___92 ;
  SCM *tmp___93 ;
  SCM tmp___94 ;
  SCM tmp___95 ;
  SCM *tmp___96 ;
  SCM tmp___97 ;
  SCM tmp___98 ;
  SCM *tmp___99 ;
  SCM tmp___100 ;
  SCM tmp___101 ;
  SCM *tmp___102 ;
  SCM tmp___103 ;
  SCM tmp___104 ;
  int tmp___105 ;
  SCM val ;
  int tmp___106 ;
  SCM tmp___107 ;
  SCM *tmp___108 ;
  SCM *tmp___109 ;
  SCM tmp___110 ;
  long tmp___111 ;
  SCM tmp___112 ;
  SCM tmp___113 ;
  SCM tmp___114 ;
  SCM tmp___115 ;
  SCM *tmp___116 ;
  SCM tmp___117 ;
  SCM tmp___118 ;
  SCM *tmp___119 ;
  SCM tmp___120 ;
  SCM tmp___121 ;
  SCM tmp___122 ;
  SCM tmp___123 ;
  double tmp___124 ;
  SCM tmp___125 ;
  double tmp___126 ;
  SCM tmp___127 ;
  double tmp___128 ;
  double tmp___129 ;
  SCM tmp___130 ;
  SCM tmp___131 ;
  SCM tmp___132 ;
  char *chrs ;
  SCM tmp___133 ;
  SCM tmp___134 ;
  SCM tmp___135 ;
  SCM tmp___136 ;
  SCM *tmp___137 ;
  SCM tmp___138 ;
  SCM tmp___139 ;
  SCM *tmp___140 ;
  SCM tmp___141 ;
  SCM tmp___142 ;
  SCM tmp___143 ;
  SCM tmp___144 ;
  SCM tmp___145 ;
  SCM tmp___146 ;
  SCM tmp___147 ;
  SCM tmp___148 ;
  SCM tmp___149 ;
  SCM tmp___150 ;
  SCM tmp___151 ;
  SCM tmp___152 ;
  SCM *tmp___153 ;
  SCM tmp___154 ;
  SCM tmp___155 ;
  SCM *tmp___156 ;
  SCM tmp___157 ;
  SCM tmp___158 ;
  SCM tmp___159 ;
  SCM tmp___160 ;
  SCM tmp___161 ;
  SCM tmp___162 ;
  SCM tmp___163 ;
  SCM tmp___164 ;
  SCM tmp___165 ;
  SCM tmp___166 ;
  SCM tmp___167 ;
  SCM tmp___168 ;
  SCM tmp___169 ;
  SCM tmp___170 ;
  void *__cil_tmp180 ;
  char *__cil_tmp181 ;

  {
#line 1329
  if ((unsigned long )(((scm_contregs *)((char *)((scm_cell *)scm_root->rootcont)->cdr))->base - & proc) > scm_debug_opts[11].val * sizeof(SCM_STACKITEM )) {
#line 1329
    if (scm_stack_checking_enabled_p) {
      {
#line 1336
      scm_report_stack_overflow();
      }
    }
  }
  loopnoap: ;
  loop: 
#line 1404
  scm_async_clock --;
#line 1404
  if (0U == scm_async_clock) {
    {
#line 1404
    scm_async_click();
    }
  }
  {
#line 1407
  if ((127 & (int )((scm_cell *)x)->car) == 7) {
#line 1407
    goto case_7;
  }
#line 1407
  if ((127 & (int )((scm_cell *)x)->car) == 5) {
#line 1407
    goto case_7;
  }
#line 1413
  if ((127 & (int )((scm_cell *)x)->car) == 4) {
#line 1413
    goto case_4;
  }
#line 1426
  if ((127 & (int )((scm_cell *)x)->car) == (int )(127L & ((long )((1 << 9) + (1 << 3)) + 4L))) {
#line 1426
    goto cdrxnoap;
  }
#line 1457
  if ((127 & (int )((scm_cell *)x)->car) == (int )(127L & ((long )((2 << 9) + (2 << 3)) + 4L))) {
#line 1457
    goto case_exp___0;
  }
#line 1484
  if ((127 & (int )((scm_cell *)x)->car) == (int )(127L & ((long )((3 << 9) + (3 << 3)) + 4L))) {
#line 1484
    goto case_exp___1;
  }
#line 1512
  if ((127 & (int )((scm_cell *)x)->car) == (int )(127L & ((long )((4 << 9) + (4 << 3)) + 4L))) {
#line 1512
    goto case_exp___2;
  }
#line 1541
  if ((127 & (int )((scm_cell *)x)->car) == (int )(127L & ((long )((5 << 9) + (5 << 3)) + 4L))) {
#line 1541
    goto case_exp___3;
  }
#line 1553
  if ((127 & (int )((scm_cell *)x)->car) == (int )(127L & ((long )((7 << 9) + (7 << 3)) + 4L))) {
#line 1553
    goto case_exp___4;
  }
#line 1567
  if ((127 & (int )((scm_cell *)x)->car) == (int )(127L & ((long )((9 << 9) + (9 << 3)) + 4L))) {
#line 1567
    goto case_exp___5;
  }
#line 1582
  if ((127 & (int )((scm_cell *)x)->car) == (int )(127L & ((long )((8 << 9) + (8 << 3)) + 4L))) {
#line 1582
    goto case_exp___6;
  }
#line 1599
  if ((127 & (int )((scm_cell *)x)->car) == (int )(127L & ((long )((10 << 9) + (10 << 3)) + 4L))) {
#line 1599
    goto case_exp___7;
  }
#line 1615
  if ((127 & (int )((scm_cell *)x)->car) == (int )(127L & ((long )((6 << 9) + (6 << 3)) + 4L))) {
#line 1615
    goto case_exp___8;
  }
#line 1619
  if ((127 & (int )((scm_cell *)x)->car) == (int )(127L & ((long )((11 << 9) + (11 << 3)) + 4L))) {
#line 1619
    goto case_exp___9;
  }
#line 1623
  if ((127 & (int )((scm_cell *)x)->car) == (int )(127L & ((long )((12 << 9) + (12 << 3)) + 4L))) {
#line 1623
    goto case_exp___10;
  }
#line 1649
  if ((127 & (int )((scm_cell *)x)->car) == (int )(127L & ((long )((13 << 9) + (13 << 3)) + 4L))) {
#line 1649
    goto case_exp___11;
  }
#line 1667
  if ((127 & (int )((scm_cell *)x)->car) == 116) {
#line 1667
    goto case_116;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 119) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 117) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 111) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 109) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 69) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 101) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 95) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 93) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 87) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 85) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 103) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 123) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 115) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 107) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 99) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 91) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 83) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 75) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 67) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 59) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 51) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 43) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 35) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 27) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 19) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 11) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 3) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 127) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 31) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 29) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 23) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 21) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 53) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 47) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 45) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 37) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 79) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 55) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 77) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 71) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 15) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 13) {
#line 1753
    goto case_119;
  }
#line 1757
  if ((127 & (int )((scm_cell *)x)->car) == 124) {
#line 1757
    goto case_124;
  }
#line 1769
  if ((127 & (int )((scm_cell *)x)->car) == 121) {
#line 1769
    goto case_121;
  }
#line 1769
  if ((127 & (int )((scm_cell *)x)->car) == 113) {
#line 1769
    goto case_121;
  }
#line 1769
  if ((127 & (int )((scm_cell *)x)->car) == 105) {
#line 1769
    goto case_121;
  }
#line 1769
  if ((127 & (int )((scm_cell *)x)->car) == 97) {
#line 1769
    goto case_121;
  }
#line 1769
  if ((127 & (int )((scm_cell *)x)->car) == 89) {
#line 1769
    goto case_121;
  }
#line 1769
  if ((127 & (int )((scm_cell *)x)->car) == 81) {
#line 1769
    goto case_121;
  }
#line 1769
  if ((127 & (int )((scm_cell *)x)->car) == 73) {
#line 1769
    goto case_121;
  }
#line 1769
  if ((127 & (int )((scm_cell *)x)->car) == 65) {
#line 1769
    goto case_121;
  }
#line 1769
  if ((127 & (int )((scm_cell *)x)->car) == 57) {
#line 1769
    goto case_121;
  }
#line 1769
  if ((127 & (int )((scm_cell *)x)->car) == 49) {
#line 1769
    goto case_121;
  }
#line 1769
  if ((127 & (int )((scm_cell *)x)->car) == 41) {
#line 1769
    goto case_121;
  }
#line 1769
  if ((127 & (int )((scm_cell *)x)->car) == 33) {
#line 1769
    goto case_121;
  }
#line 1769
  if ((127 & (int )((scm_cell *)x)->car) == 25) {
#line 1769
    goto case_121;
  }
#line 1769
  if ((127 & (int )((scm_cell *)x)->car) == 17) {
#line 1769
    goto case_121;
  }
#line 1769
  if ((127 & (int )((scm_cell *)x)->car) == 9) {
#line 1769
    goto case_121;
  }
#line 1769
  if ((127 & (int )((scm_cell *)x)->car) == 1) {
#line 1769
    goto case_121;
  }
#line 1780
  if ((127 & (int )((scm_cell *)x)->car) == 120) {
#line 1780
    goto case_120;
  }
#line 1780
  if ((127 & (int )((scm_cell *)x)->car) == 112) {
#line 1780
    goto case_120;
  }
#line 1780
  if ((127 & (int )((scm_cell *)x)->car) == 104) {
#line 1780
    goto case_120;
  }
#line 1780
  if ((127 & (int )((scm_cell *)x)->car) == 96) {
#line 1780
    goto case_120;
  }
#line 1780
  if ((127 & (int )((scm_cell *)x)->car) == 88) {
#line 1780
    goto case_120;
  }
#line 1780
  if ((127 & (int )((scm_cell *)x)->car) == 80) {
#line 1780
    goto case_120;
  }
#line 1780
  if ((127 & (int )((scm_cell *)x)->car) == 72) {
#line 1780
    goto case_120;
  }
#line 1780
  if ((127 & (int )((scm_cell *)x)->car) == 64) {
#line 1780
    goto case_120;
  }
#line 1780
  if ((127 & (int )((scm_cell *)x)->car) == 56) {
#line 1780
    goto case_120;
  }
#line 1780
  if ((127 & (int )((scm_cell *)x)->car) == 48) {
#line 1780
    goto case_120;
  }
#line 1780
  if ((127 & (int )((scm_cell *)x)->car) == 40) {
#line 1780
    goto case_120;
  }
#line 1780
  if ((127 & (int )((scm_cell *)x)->car) == 32) {
#line 1780
    goto case_120;
  }
#line 1780
  if ((127 & (int )((scm_cell *)x)->car) == 24) {
#line 1780
    goto case_120;
  }
#line 1780
  if ((127 & (int )((scm_cell *)x)->car) == 16) {
#line 1780
    goto case_120;
  }
#line 1780
  if ((127 & (int )((scm_cell *)x)->car) == 8) {
#line 1780
    goto case_120;
  }
#line 1780
  if ((127 & (int )((scm_cell *)x)->car) == 0) {
#line 1780
    goto case_120;
  }
#line 1727
  goto switch_default___0;
  case_7: /* CIL Label */ 
  case_5: /* CIL Label */ 
  {
#line 1410
  x = scm_cons(x, (long )(18 << 9) + 372L);
  }
#line 1411
  goto retval;
  case_4: /* CIL Label */ 
#line 1414
  x = ((scm_cell *)x)->cdr;
#line 1415
  t.arg1 = x;
  {
#line 1416
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1416
    t.arg1 = ((scm_cell *)t.arg1)->cdr;
#line 1416
    if (! ((long )(20 << 9) + 372L != t.arg1)) {
#line 1416
      goto while_break;
    }
#line 1417
    if ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )((scm_cell *)x)->car)) {
#line 1417
      if (6 & (int )((scm_cell *)x)->car) {
#line 1417
        if (((int )((scm_cell *)x)->car & 255) == 252) {
          {
#line 1417
          tmp = scm_ilookup(((scm_cell *)x)->car, env);
#line 1417
          tmp___0 = *tmp;
          }
        } else {
#line 1417
          tmp___0 = ((scm_cell *)x)->car;
        }
#line 1417
        tmp___1 = tmp___0;
      } else {
#line 1417
        tmp___1 = ((scm_cell *)(((scm_cell *)x)->car - 1L))->cdr;
      }
#line 1417
      tmp___5 = tmp___1;
    } else {
#line 1417
      if ((125 & (int )((scm_cell *)((scm_cell *)x)->car)->car) == 5) {
        {
#line 1417
        tmp___2 = scm_lookupcar(x, env);
#line 1417
        tmp___4 = *tmp___2;
        }
      } else {
        {
#line 1417
        tmp___3 = scm_ceval(((scm_cell *)x)->car, env);
#line 1417
        tmp___4 = tmp___3;
        }
      }
#line 1417
      tmp___5 = tmp___4;
    }
#line 1417
    if ((long )(16 << 9) + 372L == tmp___5) {
#line 1419
      return ((long )(16 << 9) + 372L);
    } else {
#line 1422
      x = t.arg1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1424
  goto carloop;
  cdrxnoap: 
  case_exp: /* CIL Label */ ;
  cdrxbegin: 
#line 1430
  x = ((scm_cell *)x)->cdr;
  begin: 
#line 1433
  t.arg1 = x;
  {
#line 1434
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1434
    t.arg1 = ((scm_cell *)t.arg1)->cdr;
#line 1434
    if (! ((long )(20 << 9) + 372L != t.arg1)) {
#line 1434
      goto while_break___0;
    }
#line 1436
    if (! (6 & (int )((scm_cell *)x)->car)) {
      {
#line 1436
      scm_ceval(((scm_cell *)x)->car, env);
      }
    }
#line 1437
    x = t.arg1;
  }
  while_break___0: /* CIL Label */ ;
  }
  carloop: 
#line 1441
  if ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )((scm_cell *)x)->car)) {
#line 1443
    x = ((scm_cell *)x)->car;
#line 1444
    if (6 & (int )x) {
#line 1444
      if (((int )x & 255) == 252) {
        {
#line 1444
        tmp___6 = scm_ilookup(x, env);
#line 1444
        tmp___7 = *tmp___6;
        }
      } else {
#line 1444
        tmp___7 = x;
      }
#line 1444
      tmp___8 = tmp___7;
    } else {
#line 1444
      tmp___8 = ((scm_cell *)(x - 1L))->cdr;
    }
#line 1444
    return (tmp___8);
  }
#line 1447
  if ((125 & (int )((scm_cell *)((scm_cell *)x)->car)->car) == 5) {
    retval: 
    {
#line 1450
    tmp___9 = scm_lookupcar(x, env);
    }
#line 1450
    return (*tmp___9);
  }
#line 1453
  x = ((scm_cell *)x)->car;
#line 1454
  goto loop;
  case_exp___0: /* CIL Label */ 
#line 1458
  x = ((scm_cell *)x)->cdr;
#line 1459
  if ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )((scm_cell *)x)->car)) {
#line 1459
    if (6 & (int )((scm_cell *)x)->car) {
#line 1459
      if (((int )((scm_cell *)x)->car & 255) == 252) {
        {
#line 1459
        tmp___10 = scm_ilookup(((scm_cell *)x)->car, env);
#line 1459
        tmp___11 = *tmp___10;
        }
      } else {
#line 1459
        tmp___11 = ((scm_cell *)x)->car;
      }
#line 1459
      tmp___12 = tmp___11;
    } else {
#line 1459
      tmp___12 = ((scm_cell *)(((scm_cell *)x)->car - 1L))->cdr;
    }
#line 1459
    t.arg1 = tmp___12;
  } else {
#line 1459
    if ((125 & (int )((scm_cell *)((scm_cell *)x)->car)->car) == 5) {
      {
#line 1459
      tmp___13 = scm_lookupcar(x, env);
#line 1459
      tmp___15 = *tmp___13;
      }
    } else {
      {
#line 1459
      tmp___14 = scm_ceval(((scm_cell *)x)->car, env);
#line 1459
      tmp___15 = tmp___14;
      }
    }
#line 1459
    t.arg1 = tmp___15;
  }
  {
#line 1460
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1460
    x = ((scm_cell *)x)->cdr;
#line 1460
    if (6 & (int )x) {
#line 1460
      goto while_break___1;
    }
#line 1462
    proc = ((scm_cell *)x)->car;
#line 1463
    if (scm_i_else == ((scm_cell *)proc)->car) {
#line 1465
      x = ((scm_cell *)proc)->cdr;
#line 1467
      goto begin;
    }
#line 1469
    proc = ((scm_cell *)proc)->car;
    {
#line 1470
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1470
      if (! (! (6 & (int )proc))) {
#line 1470
        goto while_break___2;
      }
#line 1472
      if (((scm_cell *)proc)->car == t.arg1) {
#line 1474
        x = ((scm_cell *)((scm_cell *)x)->car)->cdr;
#line 1476
        goto begin;
      } else {
        {
#line 1472
        tmp___16 = scm_eqv_p(((scm_cell *)proc)->car, t.arg1);
        }
#line 1472
        if ((long )(16 << 9) + 372L != tmp___16) {
#line 1474
          x = ((scm_cell *)((scm_cell *)x)->car)->cdr;
#line 1476
          goto begin;
        }
      }
#line 1478
      proc = ((scm_cell *)proc)->cdr;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1481
  return ((long )(21 << 9) + 372L);
  case_exp___1: /* CIL Label */ 
  {
#line 1485
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1485
    x = ((scm_cell *)x)->cdr;
#line 1485
    if (6 & (int )x) {
#line 1485
      goto while_break___3;
    }
#line 1487
    proc = ((scm_cell *)x)->car;
#line 1488
    if ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )((scm_cell *)proc)->car)) {
#line 1488
      if (6 & (int )((scm_cell *)proc)->car) {
#line 1488
        if (((int )((scm_cell *)proc)->car & 255) == 252) {
          {
#line 1488
          tmp___17 = scm_ilookup(((scm_cell *)proc)->car, env);
#line 1488
          tmp___18 = *tmp___17;
          }
        } else {
#line 1488
          tmp___18 = ((scm_cell *)proc)->car;
        }
#line 1488
        tmp___19 = tmp___18;
      } else {
#line 1488
        tmp___19 = ((scm_cell *)(((scm_cell *)proc)->car - 1L))->cdr;
      }
#line 1488
      t.arg1 = tmp___19;
    } else {
#line 1488
      if ((125 & (int )((scm_cell *)((scm_cell *)proc)->car)->car) == 5) {
        {
#line 1488
        tmp___20 = scm_lookupcar(proc, env);
#line 1488
        tmp___22 = *tmp___20;
        }
      } else {
        {
#line 1488
        tmp___21 = scm_ceval(((scm_cell *)proc)->car, env);
#line 1488
        tmp___22 = tmp___21;
        }
      }
#line 1488
      t.arg1 = tmp___22;
    }
#line 1489
    if ((long )(16 << 9) + 372L != t.arg1) {
#line 1491
      x = ((scm_cell *)proc)->cdr;
#line 1492
      if ((long )(20 << 9) + 372L == x) {
#line 1494
        return (t.arg1);
      }
#line 1496
      if (scm_i_arrow != ((scm_cell *)x)->car) {
#line 1499
        goto begin;
      }
#line 1501
      proc = ((scm_cell *)x)->cdr;
#line 1502
      if ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )((scm_cell *)proc)->car)) {
#line 1502
        if (6 & (int )((scm_cell *)proc)->car) {
#line 1502
          if (((int )((scm_cell *)proc)->car & 255) == 252) {
            {
#line 1502
            tmp___23 = scm_ilookup(((scm_cell *)proc)->car, env);
#line 1502
            tmp___24 = *tmp___23;
            }
          } else {
#line 1502
            tmp___24 = ((scm_cell *)proc)->car;
          }
#line 1502
          tmp___25 = tmp___24;
        } else {
#line 1502
          tmp___25 = ((scm_cell *)(((scm_cell *)proc)->car - 1L))->cdr;
        }
#line 1502
        proc = tmp___25;
      } else {
#line 1502
        if ((125 & (int )((scm_cell *)((scm_cell *)proc)->car)->car) == 5) {
          {
#line 1502
          tmp___26 = scm_lookupcar(proc, env);
#line 1502
          tmp___28 = *tmp___26;
          }
        } else {
          {
#line 1502
          tmp___27 = scm_ceval(((scm_cell *)proc)->car, env);
#line 1502
          tmp___28 = tmp___27;
          }
        }
#line 1502
        proc = tmp___28;
      }
#line 1503
      if (! (! (6 & (int )proc))) {
#line 1503
        goto badfun;
      }
#line 1506
      goto evap1;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1509
  return ((long )(21 << 9) + 372L);
  case_exp___2: /* CIL Label */ 
#line 1513
  x = ((scm_cell *)x)->cdr;
#line 1514
  proc = ((scm_cell *)((scm_cell *)x)->cdr)->car;
#line 1515
  t.arg1 = (long )(20 << 9) + 372L;
  {
#line 1516
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1516
    if (! (! (6 & (int )proc))) {
#line 1516
      goto while_break___4;
    }
#line 1518
    if ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )((scm_cell *)proc)->car)) {
#line 1518
      if (6 & (int )((scm_cell *)proc)->car) {
#line 1518
        if (((int )((scm_cell *)proc)->car & 255) == 252) {
          {
#line 1518
          tmp___29 = scm_ilookup(((scm_cell *)proc)->car, env);
#line 1518
          tmp___30 = *tmp___29;
          }
        } else {
#line 1518
          tmp___30 = ((scm_cell *)proc)->car;
        }
#line 1518
        tmp___31 = tmp___30;
      } else {
#line 1518
        tmp___31 = ((scm_cell *)(((scm_cell *)proc)->car - 1L))->cdr;
      }
#line 1518
      tmp___35 = tmp___31;
    } else {
#line 1518
      if ((125 & (int )((scm_cell *)((scm_cell *)proc)->car)->car) == 5) {
        {
#line 1518
        tmp___32 = scm_lookupcar(proc, env);
#line 1518
        tmp___34 = *tmp___32;
        }
      } else {
        {
#line 1518
        tmp___33 = scm_ceval(((scm_cell *)proc)->car, env);
#line 1518
        tmp___34 = tmp___33;
        }
      }
#line 1518
      tmp___35 = tmp___34;
    }
    {
#line 1518
    t.arg1 = scm_cons(tmp___35, t.arg1);
#line 1519
    proc = ((scm_cell *)proc)->cdr;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 1521
  env = scm_acons(((scm_cell *)x)->car, t.arg1, env);
#line 1522
  x = ((scm_cell *)((scm_cell *)x)->cdr)->cdr;
  }
  {
#line 1523
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1523
    proc = ((scm_cell *)x)->car;
#line 1523
    if ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )((scm_cell *)proc)->car)) {
#line 1523
      if (6 & (int )((scm_cell *)proc)->car) {
#line 1523
        if (((int )((scm_cell *)proc)->car & 255) == 252) {
          {
#line 1523
          tmp___43 = scm_ilookup(((scm_cell *)proc)->car, env);
#line 1523
          tmp___44 = *tmp___43;
          }
        } else {
#line 1523
          tmp___44 = ((scm_cell *)proc)->car;
        }
#line 1523
        tmp___45 = tmp___44;
      } else {
#line 1523
        tmp___45 = ((scm_cell *)(((scm_cell *)proc)->car - 1L))->cdr;
      }
#line 1523
      tmp___49 = tmp___45;
    } else {
#line 1523
      if ((125 & (int )((scm_cell *)((scm_cell *)proc)->car)->car) == 5) {
        {
#line 1523
        tmp___46 = scm_lookupcar(proc, env);
#line 1523
        tmp___48 = *tmp___46;
        }
      } else {
        {
#line 1523
        tmp___47 = scm_ceval(((scm_cell *)proc)->car, env);
#line 1523
        tmp___48 = tmp___47;
        }
      }
#line 1523
      tmp___49 = tmp___48;
    }
#line 1523
    if (! ((long )(16 << 9) + 372L == tmp___49)) {
#line 1523
      goto while_break___5;
    }
#line 1525
    proc = ((scm_cell *)((scm_cell *)x)->cdr)->car;
    {
#line 1525
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1525
      if (! (! (6 & (int )proc))) {
#line 1525
        goto while_break___6;
      }
#line 1527
      t.arg1 = ((scm_cell *)proc)->car;
#line 1528
      if (! (6 & (int )t.arg1)) {
        {
#line 1528
        scm_ceval(t.arg1, env);
        }
      }
#line 1525
      proc = ((scm_cell *)proc)->cdr;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 1530
    t.arg1 = (long )(20 << 9) + 372L;
#line 1530
    proc = ((scm_cell *)((scm_cell *)x)->cdr)->cdr;
    {
#line 1530
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1530
      if (! (! (6 & (int )proc))) {
#line 1530
        goto while_break___7;
      }
#line 1531
      if ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )((scm_cell *)proc)->car)) {
#line 1531
        if (6 & (int )((scm_cell *)proc)->car) {
#line 1531
          if (((int )((scm_cell *)proc)->car & 255) == 252) {
            {
#line 1531
            tmp___36 = scm_ilookup(((scm_cell *)proc)->car, env);
#line 1531
            tmp___37 = *tmp___36;
            }
          } else {
#line 1531
            tmp___37 = ((scm_cell *)proc)->car;
          }
#line 1531
          tmp___38 = tmp___37;
        } else {
#line 1531
          tmp___38 = ((scm_cell *)(((scm_cell *)proc)->car - 1L))->cdr;
        }
#line 1531
        tmp___42 = tmp___38;
      } else {
#line 1531
        if ((125 & (int )((scm_cell *)((scm_cell *)proc)->car)->car) == 5) {
          {
#line 1531
          tmp___39 = scm_lookupcar(proc, env);
#line 1531
          tmp___41 = *tmp___39;
          }
        } else {
          {
#line 1531
          tmp___40 = scm_ceval(((scm_cell *)proc)->car, env);
#line 1531
          tmp___41 = tmp___40;
          }
        }
#line 1531
        tmp___42 = tmp___41;
      }
      {
#line 1531
      t.arg1 = scm_cons(tmp___42, t.arg1);
#line 1530
      proc = ((scm_cell *)proc)->cdr;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 1532
    env = scm_acons(((scm_cell *)((scm_cell *)env)->car)->car, t.arg1, ((scm_cell *)env)->cdr);
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 1534
  x = ((scm_cell *)proc)->cdr;
#line 1535
  if ((long )(20 << 9) + 372L == x) {
#line 1536
    return ((long )(21 << 9) + 372L);
  }
#line 1538
  goto begin;
  case_exp___3: /* CIL Label */ 
#line 1542
  x = ((scm_cell *)x)->cdr;
#line 1543
  if ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )((scm_cell *)x)->car)) {
#line 1543
    if (6 & (int )((scm_cell *)x)->car) {
#line 1543
      if (((int )((scm_cell *)x)->car & 255) == 252) {
        {
#line 1543
        tmp___50 = scm_ilookup(((scm_cell *)x)->car, env);
#line 1543
        tmp___51 = *tmp___50;
        }
      } else {
#line 1543
        tmp___51 = ((scm_cell *)x)->car;
      }
#line 1543
      tmp___52 = tmp___51;
    } else {
#line 1543
      tmp___52 = ((scm_cell *)(((scm_cell *)x)->car - 1L))->cdr;
    }
#line 1543
    tmp___56 = tmp___52;
  } else {
#line 1543
    if ((125 & (int )((scm_cell *)((scm_cell *)x)->car)->car) == 5) {
      {
#line 1543
      tmp___53 = scm_lookupcar(x, env);
#line 1543
      tmp___55 = *tmp___53;
      }
    } else {
      {
#line 1543
      tmp___54 = scm_ceval(((scm_cell *)x)->car, env);
#line 1543
      tmp___55 = tmp___54;
      }
    }
#line 1543
    tmp___56 = tmp___55;
  }
#line 1543
  if ((long )(16 << 9) + 372L != tmp___56) {
#line 1544
    x = ((scm_cell *)x)->cdr;
  } else {
#line 1545
    x = ((scm_cell *)((scm_cell *)x)->cdr)->cdr;
#line 1545
    if (6 & (int )x) {
#line 1547
      return ((long )(21 << 9) + 372L);
    }
  }
#line 1550
  goto carloop;
  case_exp___4: /* CIL Label */ 
#line 1554
  x = ((scm_cell *)x)->cdr;
#line 1555
  proc = ((scm_cell *)((scm_cell *)x)->cdr)->car;
#line 1556
  t.arg1 = (long )(20 << 9) + 372L;
  {
#line 1557
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 1559
    if ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )((scm_cell *)proc)->car)) {
#line 1559
      if (6 & (int )((scm_cell *)proc)->car) {
#line 1559
        if (((int )((scm_cell *)proc)->car & 255) == 252) {
          {
#line 1559
          tmp___57 = scm_ilookup(((scm_cell *)proc)->car, env);
#line 1559
          tmp___58 = *tmp___57;
          }
        } else {
#line 1559
          tmp___58 = ((scm_cell *)proc)->car;
        }
#line 1559
        tmp___59 = tmp___58;
      } else {
#line 1559
        tmp___59 = ((scm_cell *)(((scm_cell *)proc)->car - 1L))->cdr;
      }
#line 1559
      tmp___63 = tmp___59;
    } else {
#line 1559
      if ((125 & (int )((scm_cell *)((scm_cell *)proc)->car)->car) == 5) {
        {
#line 1559
        tmp___60 = scm_lookupcar(proc, env);
#line 1559
        tmp___62 = *tmp___60;
        }
      } else {
        {
#line 1559
        tmp___61 = scm_ceval(((scm_cell *)proc)->car, env);
#line 1559
        tmp___62 = tmp___61;
        }
      }
#line 1559
      tmp___63 = tmp___62;
    }
    {
#line 1559
    t.arg1 = scm_cons(tmp___63, t.arg1);
#line 1557
    proc = ((scm_cell *)proc)->cdr;
    }
#line 1557
    if (6 & (int )proc) {
#line 1557
      goto while_break___8;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 1562
  env = scm_acons(((scm_cell *)x)->car, t.arg1, env);
#line 1563
  x = ((scm_cell *)x)->cdr;
  }
#line 1564
  goto cdrxnoap;
  case_exp___5: /* CIL Label */ 
  {
#line 1568
  x = ((scm_cell *)x)->cdr;
#line 1569
  env = scm_acons(((scm_cell *)x)->car, scm_sys_protects[2], env);
#line 1570
  x = ((scm_cell *)x)->cdr;
#line 1571
  proc = ((scm_cell *)x)->car;
#line 1572
  t.arg1 = (long )(20 << 9) + 372L;
  }
  {
#line 1573
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 1575
    if ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )((scm_cell *)proc)->car)) {
#line 1575
      if (6 & (int )((scm_cell *)proc)->car) {
#line 1575
        if (((int )((scm_cell *)proc)->car & 255) == 252) {
          {
#line 1575
          tmp___64 = scm_ilookup(((scm_cell *)proc)->car, env);
#line 1575
          tmp___65 = *tmp___64;
          }
        } else {
#line 1575
          tmp___65 = ((scm_cell *)proc)->car;
        }
#line 1575
        tmp___66 = tmp___65;
      } else {
#line 1575
        tmp___66 = ((scm_cell *)(((scm_cell *)proc)->car - 1L))->cdr;
      }
#line 1575
      tmp___70 = tmp___66;
    } else {
#line 1575
      if ((125 & (int )((scm_cell *)((scm_cell *)proc)->car)->car) == 5) {
        {
#line 1575
        tmp___67 = scm_lookupcar(proc, env);
#line 1575
        tmp___69 = *tmp___67;
        }
      } else {
        {
#line 1575
        tmp___68 = scm_ceval(((scm_cell *)proc)->car, env);
#line 1575
        tmp___69 = tmp___68;
        }
      }
#line 1575
      tmp___70 = tmp___69;
    }
    {
#line 1575
    t.arg1 = scm_cons(tmp___70, t.arg1);
#line 1573
    proc = ((scm_cell *)proc)->cdr;
    }
#line 1573
    if (6 & (int )proc) {
#line 1573
      goto while_break___9;
    }
  }
  while_break___9: /* CIL Label */ ;
  }
#line 1578
  ((scm_cell *)((scm_cell *)env)->car)->cdr = t.arg1;
#line 1579
  goto cdrxnoap;
  case_exp___6: /* CIL Label */ 
#line 1583
  x = ((scm_cell *)x)->cdr;
#line 1584
  proc = ((scm_cell *)x)->car;
#line 1585
  if (6 & (int )proc) {
    {
#line 1587
    env = scm_acons((long )(20 << 9) + 372L, (long )(20 << 9) + 372L, env);
    }
#line 1588
    goto cdrxnoap;
  }
  {
#line 1590
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 1592
    t.arg1 = ((scm_cell *)proc)->car;
#line 1593
    proc = ((scm_cell *)proc)->cdr;
#line 1594
    if ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )((scm_cell *)proc)->car)) {
#line 1594
      if (6 & (int )((scm_cell *)proc)->car) {
#line 1594
        if (((int )((scm_cell *)proc)->car & 255) == 252) {
          {
#line 1594
          tmp___71 = scm_ilookup(((scm_cell *)proc)->car, env);
#line 1594
          tmp___72 = *tmp___71;
          }
        } else {
#line 1594
          tmp___72 = ((scm_cell *)proc)->car;
        }
#line 1594
        tmp___73 = tmp___72;
      } else {
#line 1594
        tmp___73 = ((scm_cell *)(((scm_cell *)proc)->car - 1L))->cdr;
      }
#line 1594
      tmp___77 = tmp___73;
    } else {
#line 1594
      if ((125 & (int )((scm_cell *)((scm_cell *)proc)->car)->car) == 5) {
        {
#line 1594
        tmp___74 = scm_lookupcar(proc, env);
#line 1594
        tmp___76 = *tmp___74;
        }
      } else {
        {
#line 1594
        tmp___75 = scm_ceval(((scm_cell *)proc)->car, env);
#line 1594
        tmp___76 = tmp___75;
        }
      }
#line 1594
      tmp___77 = tmp___76;
    }
    {
#line 1594
    env = scm_acons(t.arg1, tmp___77, env);
#line 1590
    proc = ((scm_cell *)proc)->cdr;
    }
#line 1590
    if (6 & (int )proc) {
#line 1590
      goto while_break___10;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
#line 1597
  goto cdrxnoap;
  case_exp___7: /* CIL Label */ 
#line 1600
  x = ((scm_cell *)x)->cdr;
#line 1601
  t.arg1 = x;
  {
#line 1602
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 1602
    t.arg1 = ((scm_cell *)t.arg1)->cdr;
#line 1602
    if (! ((long )(20 << 9) + 372L != t.arg1)) {
#line 1602
      goto while_break___11;
    }
#line 1604
    if ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )((scm_cell *)x)->car)) {
#line 1604
      if (6 & (int )((scm_cell *)x)->car) {
#line 1604
        if (((int )((scm_cell *)x)->car & 255) == 252) {
          {
#line 1604
          tmp___78 = scm_ilookup(((scm_cell *)x)->car, env);
#line 1604
          tmp___79 = *tmp___78;
          }
        } else {
#line 1604
          tmp___79 = ((scm_cell *)x)->car;
        }
#line 1604
        tmp___80 = tmp___79;
      } else {
#line 1604
        tmp___80 = ((scm_cell *)(((scm_cell *)x)->car - 1L))->cdr;
      }
#line 1604
      x = tmp___80;
    } else {
#line 1604
      if ((125 & (int )((scm_cell *)((scm_cell *)x)->car)->car) == 5) {
        {
#line 1604
        tmp___81 = scm_lookupcar(x, env);
#line 1604
        tmp___83 = *tmp___81;
        }
      } else {
        {
#line 1604
        tmp___82 = scm_ceval(((scm_cell *)x)->car, env);
#line 1604
        tmp___83 = tmp___82;
        }
      }
#line 1604
      x = tmp___83;
    }
#line 1605
    if ((long )(16 << 9) + 372L != x) {
#line 1607
      return (x);
    }
#line 1609
    x = t.arg1;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 1612
  goto carloop;
  case_exp___8: /* CIL Label */ 
  {
#line 1616
  tmp___84 = scm_closure(((scm_cell *)x)->cdr, env);
  }
#line 1616
  return (tmp___84);
  case_exp___9: /* CIL Label */ 
#line 1620
  return (((scm_cell *)((scm_cell *)x)->cdr)->car);
  case_exp___10: /* CIL Label */ 
#line 1624
  x = ((scm_cell *)x)->cdr;
#line 1625
  proc = ((scm_cell *)x)->car;
  {
#line 1628
  if ((7 & (int )proc) == 0) {
#line 1628
    goto case_0;
  }
#line 1631
  if ((7 & (int )proc) == 1) {
#line 1631
    goto case_1;
  }
#line 1635
  if ((7 & (int )proc) == 4) {
#line 1635
    goto case_4___0;
  }
#line 1626
  goto switch_break___0;
  case_0: /* CIL Label */ 
  {
#line 1629
  t.lloc = scm_lookupcar(x, env);
  }
#line 1630
  goto switch_break___0;
  case_1: /* CIL Label */ 
#line 1632
  t.lloc = & ((scm_cell *)(proc - 1L))->cdr;
#line 1633
  goto switch_break___0;
  case_4___0: /* CIL Label */ 
  {
#line 1636
  t.lloc = scm_ilookup(proc, env);
  }
#line 1637
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1640
  x = ((scm_cell *)x)->cdr;
#line 1641
  if ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )((scm_cell *)x)->car)) {
#line 1641
    if (6 & (int )((scm_cell *)x)->car) {
#line 1641
      if (((int )((scm_cell *)x)->car & 255) == 252) {
        {
#line 1641
        tmp___85 = scm_ilookup(((scm_cell *)x)->car, env);
#line 1641
        tmp___86 = *tmp___85;
        }
      } else {
#line 1641
        tmp___86 = ((scm_cell *)x)->car;
      }
#line 1641
      tmp___87 = tmp___86;
    } else {
#line 1641
      tmp___87 = ((scm_cell *)(((scm_cell *)x)->car - 1L))->cdr;
    }
#line 1641
    *(t.lloc) = tmp___87;
  } else {
#line 1641
    if ((125 & (int )((scm_cell *)((scm_cell *)x)->car)->car) == 5) {
      {
#line 1641
      tmp___88 = scm_lookupcar(x, env);
#line 1641
      tmp___90 = *tmp___88;
      }
    } else {
      {
#line 1641
      tmp___89 = scm_ceval(((scm_cell *)x)->car, env);
#line 1641
      tmp___90 = tmp___89;
      }
    }
#line 1641
    *(t.lloc) = tmp___90;
  }
#line 1645
  return ((long )(21 << 9) + 372L);
  case_exp___11: /* CIL Label */ 
  {
#line 1650
  x = ((scm_cell *)x)->cdr;
#line 1651
  proc = ((scm_cell *)x)->car;
#line 1652
  x = ((scm_cell *)x)->cdr;
#line 1653
  x = scm_eval_car(x, env);
  }
#line 1655
  if (scm_debug_opts[3].val) {
#line 1655
    if (! (6 & (int )x)) {
#line 1655
      if ((7 & (int )((scm_cell *)x)->car) == 3) {
        {
#line 1656
        scm_set_procedure_property_x(x, scm_i_name, proc);
        }
      }
    }
  }
  {
#line 1658
  env = ((scm_cell *)env)->car;
#line 1659
  scm_ints_disabled = 1;
#line 1660
  tmp___91 = scm_cons(proc, ((scm_cell *)env)->car);
#line 1660
  ((scm_cell *)env)->car = tmp___91;
#line 1661
  tmp___92 = scm_cons(x, ((scm_cell *)env)->cdr);
#line 1661
  ((scm_cell *)env)->cdr = tmp___92;
#line 1662
  scm_ints_disabled = 0;
#line 1662
  scm_async_clock --;
  }
#line 1662
  if (0U == scm_async_clock) {
    {
#line 1662
    scm_async_click();
    }
  }
#line 1663
  return ((long )(21 << 9) + 372L);
  case_116: /* CIL Label */ 
#line 1668
  proc = ((scm_cell *)x)->car;
#line 1669
  if (! ((391 & (int )proc) == 4)) {
#line 1669
    goto badfun;
  }
  {
#line 1685
  if ((int )(proc >> 9) == (int )(((long )(14 << 9) + 116L) >> 9)) {
#line 1685
    goto case_exp___12;
  }
#line 1708
  if ((int )(proc >> 9) == (int )(((long )(15 << 9) + 116L) >> 9)) {
#line 1708
    goto case_exp___13;
  }
#line 1723
  goto switch_default;
  case_exp___12: /* CIL Label */ 
#line 1686
  proc = ((scm_cell *)x)->cdr;
#line 1687
  if ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )((scm_cell *)proc)->car)) {
#line 1687
    if (6 & (int )((scm_cell *)proc)->car) {
#line 1687
      if (((int )((scm_cell *)proc)->car & 255) == 252) {
        {
#line 1687
        tmp___93 = scm_ilookup(((scm_cell *)proc)->car, env);
#line 1687
        tmp___94 = *tmp___93;
        }
      } else {
#line 1687
        tmp___94 = ((scm_cell *)proc)->car;
      }
#line 1687
      tmp___95 = tmp___94;
    } else {
#line 1687
      tmp___95 = ((scm_cell *)(((scm_cell *)proc)->car - 1L))->cdr;
    }
#line 1687
    proc = tmp___95;
  } else {
#line 1687
    if ((125 & (int )((scm_cell *)((scm_cell *)proc)->car)->car) == 5) {
      {
#line 1687
      tmp___96 = scm_lookupcar(proc, env);
#line 1687
      tmp___98 = *tmp___96;
      }
    } else {
      {
#line 1687
      tmp___97 = scm_ceval(((scm_cell *)proc)->car, env);
#line 1687
      tmp___98 = tmp___97;
      }
    }
#line 1687
    proc = tmp___98;
  }
#line 1688
  if (! (! (6 & (int )proc))) {
#line 1688
    goto badfun;
  }
#line 1689
  if ((7 & (int )((scm_cell *)proc)->car) == 3) {
#line 1692
    t.arg1 = ((scm_cell *)((scm_cell *)x)->cdr)->cdr;
#line 1693
    if ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )((scm_cell *)t.arg1)->car)) {
#line 1693
      if (6 & (int )((scm_cell *)t.arg1)->car) {
#line 1693
        if (((int )((scm_cell *)t.arg1)->car & 255) == 252) {
          {
#line 1693
          tmp___99 = scm_ilookup(((scm_cell *)t.arg1)->car, env);
#line 1693
          tmp___100 = *tmp___99;
          }
        } else {
#line 1693
          tmp___100 = ((scm_cell *)t.arg1)->car;
        }
#line 1693
        tmp___101 = tmp___100;
      } else {
#line 1693
        tmp___101 = ((scm_cell *)(((scm_cell *)t.arg1)->car - 1L))->cdr;
      }
#line 1693
      t.arg1 = tmp___101;
    } else {
#line 1693
      if ((125 & (int )((scm_cell *)((scm_cell *)t.arg1)->car)->car) == 5) {
        {
#line 1693
        tmp___102 = scm_lookupcar(t.arg1, env);
#line 1693
        tmp___104 = *tmp___102;
        }
      } else {
        {
#line 1693
        tmp___103 = scm_ceval(((scm_cell *)t.arg1)->car, env);
#line 1693
        tmp___104 = tmp___103;
        }
      }
#line 1693
      t.arg1 = tmp___104;
    }
    {
#line 1698
    tmp___105 = scm_badargsp(((scm_cell *)((scm_cell *)(((scm_cell *)proc)->car - 3L))->car)->car,
                             t.arg1);
    }
#line 1698
    if (tmp___105) {
#line 1699
      goto wrongnumargs;
    }
    {
#line 1701
    env = scm_acons(((scm_cell *)((scm_cell *)(((scm_cell *)proc)->car - 3L))->car)->car,
                    t.arg1, ((scm_cell *)proc)->cdr);
#line 1702
    x = ((scm_cell *)(((scm_cell *)proc)->car - 3L))->car;
    }
#line 1703
    goto cdrxbegin;
  }
#line 1705
  proc = scm_i_apply;
#line 1706
  goto evapply;
  case_exp___13: /* CIL Label */ 
  {
#line 1709
  scm_make_cont(& t.arg1);
#line 1710
  tmp___106 = _setjmp((struct __jmp_buf_tag *)(((scm_contregs *)((char *)((scm_cell *)t.arg1)->cdr))->jmpbuf));
  }
#line 1710
  if (tmp___106) {
#line 1713
    val = ((scm_contregs *)((char *)((scm_cell *)t.arg1)->cdr))->throw_value;
#line 1714
    return (val);
  }
  {
#line 1716
  proc = ((scm_cell *)x)->cdr;
#line 1717
  proc = scm_eval_car(proc, env);
  }
#line 1718
  if (! (! (6 & (int )proc))) {
#line 1718
    goto badfun;
  }
#line 1721
  goto evap1;
  switch_default: /* CIL Label */ 
#line 1724
  goto badfun;
  switch_break___1: /* CIL Label */ ;
  }
  switch_default___0: /* CIL Label */ 
#line 1728
  proc = x;
  badfun: 
  {
#line 1731
  tmp___107 = scm_listify(proc, (long )(18 << 9) + 372L);
#line 1731
  scm_misc_error((char *)((void *)0), (char *)"Wrong type to apply: %S", tmp___107);
  }
  case_119: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_95: /* CIL Label */ 
  case_93: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_123: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_91: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_59: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_35: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_19: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_127: /* CIL Label */ 
  case_31: /* CIL Label */ 
  case_29: /* CIL Label */ 
  case_23: /* CIL Label */ 
  case_21: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_15: /* CIL Label */ 
  case_13: /* CIL Label */ 
#line 1754
  return (x);
  case_124: /* CIL Label */ 
  {
#line 1758
  tmp___108 = scm_ilookup(((scm_cell *)x)->car, env);
#line 1758
  proc = *tmp___108;
  }
#line 1759
  if (! (! (6 & (int )proc))) {
#line 1759
    goto badfun;
  }
#line 1762
  goto checkargs;
#line 1765
  goto switch_break;
  case_121: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_97: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_65: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_25: /* CIL Label */ 
  case_17: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_1___0: /* CIL Label */ 
#line 1770
  proc = ((scm_cell *)(((scm_cell *)x)->car - 1L))->cdr;
#line 1771
  if (! (! (6 & (int )proc))) {
#line 1771
    goto badfun;
  }
#line 1774
  goto checkargs;
#line 1777
  goto switch_break;
  case_120: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_96: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_64: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_48: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_32: /* CIL Label */ 
  case_24: /* CIL Label */ 
  case_16: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_0___0: /* CIL Label */ 
#line 1781
  if ((125 & (int )((scm_cell *)((scm_cell *)x)->car)->car) == 5) {
    {
#line 1783
    tmp___109 = scm_lookupcar(x, env);
#line 1783
    proc = *tmp___109;
    }
#line 1784
    if (6 & (int )proc) {
      {
#line 1786
      scm_unmemocar(x, env);
      }
#line 1787
      goto badfun;
    }
#line 1789
    if (scm_tc16_macro == (long )(65535 & (int )((scm_cell *)proc)->car)) {
      {
#line 1791
      scm_unmemocar(x, env);
      }
      handle_a_macro: 
      {
#line 1794
      tmp___110 = scm_cons(env, scm_sys_protects[1]);
#line 1794
      t.arg1 = scm_apply(((scm_cell *)proc)->cdr, x, tmp___110);
      }
      {
#line 1797
      if ((int )(((scm_cell *)proc)->car >> 16) == 2) {
#line 1797
        goto case_2;
      }
#line 1828
      if ((int )(((scm_cell *)proc)->car >> 16) == 1) {
#line 1828
        goto case_1___1;
      }
#line 1831
      if ((int )(((scm_cell *)proc)->car >> 16) == 0) {
#line 1831
        goto case_0___1;
      }
#line 1795
      goto switch_break___2;
      case_2: /* CIL Label */ 
      {
#line 1798
      tmp___111 = scm_ilength(t.arg1);
      }
#line 1798
      if (tmp___111 <= 0L) {
        {
#line 1799
        t.arg1 = scm_cons2((long )((1 << 9) + (1 << 3)) + 4L, t.arg1, (long )(20 << 9) + 372L);
        }
      }
#line 1823
      scm_ints_disabled = 1;
#line 1824
      ((scm_cell *)x)->car = ((scm_cell *)t.arg1)->car;
#line 1825
      ((scm_cell *)x)->cdr = ((scm_cell *)t.arg1)->cdr;
#line 1826
      scm_ints_disabled = 0;
#line 1826
      scm_async_clock --;
#line 1826
      if (0U == scm_async_clock) {
        {
#line 1826
        scm_async_click();
        }
      }
#line 1827
      goto loopnoap;
      case_1___1: /* CIL Label */ 
#line 1829
      x = t.arg1;
#line 1829
      if (! (6 & (int )x)) {
#line 1830
        goto loopnoap;
      }
      case_0___1: /* CIL Label */ 
#line 1832
      return (t.arg1);
      switch_break___2: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 1837
    proc = scm_ceval(((scm_cell *)x)->car, env);
    }
  }
#line 1838
  if (! (! (6 & (int )proc))) {
#line 1838
    goto badfun;
  }
  checkargs: 
#line 1843
  if ((7 & (int )((scm_cell *)proc)->car) == 3) {
#line 1845
    arg2 = ((scm_cell *)((scm_cell *)(((scm_cell *)proc)->car - 3L))->car)->car;
#line 1846
    t.arg1 = ((scm_cell *)x)->cdr;
    {
#line 1847
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 1847
      if (! (! (6 & (int )arg2))) {
#line 1847
        goto while_break___12;
      }
#line 1849
      if (1 & (int )((scm_cell *)arg2)->car) {
#line 1850
        goto evapply;
      }
#line 1851
      if (6 & (int )t.arg1) {
#line 1852
        goto umwrongnumargs;
      }
#line 1853
      arg2 = ((scm_cell *)arg2)->cdr;
#line 1854
      t.arg1 = ((scm_cell *)t.arg1)->cdr;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 1856
    if ((long )(20 << 9) + 372L != t.arg1) {
#line 1857
      goto umwrongnumargs;
    }
  } else
#line 1859
  if (scm_tc16_macro == (long )(65535 & (int )((scm_cell *)proc)->car)) {
#line 1860
    goto handle_a_macro;
  }
  switch_break: /* CIL Label */ ;
  }
  evapply: ;
#line 1867
  if ((long )(20 << 9) + 372L == ((scm_cell *)x)->cdr) {
    {
#line 1871
    if ((127 & (int )((scm_cell *)proc)->car) == 85) {
#line 1871
      goto case_85___0;
    }
#line 1873
    if ((127 & (int )((scm_cell *)proc)->car) == 109) {
#line 1873
      goto case_109___0;
    }
#line 1875
    if ((127 & (int )((scm_cell *)proc)->car) == 119) {
#line 1875
      goto case_119___0;
    }
#line 1877
    if ((127 & (int )((scm_cell *)proc)->car) == 69) {
#line 1877
      goto case_69___0;
    }
#line 1879
    if ((127 & (int )((scm_cell *)proc)->car) == 103) {
#line 1879
      goto case_103___0;
    }
#line 1882
    if ((127 & (int )((scm_cell *)proc)->car) == 63) {
#line 1882
      goto case_63;
    }
#line 1891
    if ((127 & (int )((scm_cell *)proc)->car) == 123) {
#line 1891
      goto case_123___0;
    }
#line 1891
    if ((127 & (int )((scm_cell *)proc)->car) == 115) {
#line 1891
      goto case_123___0;
    }
#line 1891
    if ((127 & (int )((scm_cell *)proc)->car) == 107) {
#line 1891
      goto case_123___0;
    }
#line 1891
    if ((127 & (int )((scm_cell *)proc)->car) == 99) {
#line 1891
      goto case_123___0;
    }
#line 1891
    if ((127 & (int )((scm_cell *)proc)->car) == 91) {
#line 1891
      goto case_123___0;
    }
#line 1891
    if ((127 & (int )((scm_cell *)proc)->car) == 83) {
#line 1891
      goto case_123___0;
    }
#line 1891
    if ((127 & (int )((scm_cell *)proc)->car) == 75) {
#line 1891
      goto case_123___0;
    }
#line 1891
    if ((127 & (int )((scm_cell *)proc)->car) == 67) {
#line 1891
      goto case_123___0;
    }
#line 1891
    if ((127 & (int )((scm_cell *)proc)->car) == 59) {
#line 1891
      goto case_123___0;
    }
#line 1891
    if ((127 & (int )((scm_cell *)proc)->car) == 51) {
#line 1891
      goto case_123___0;
    }
#line 1891
    if ((127 & (int )((scm_cell *)proc)->car) == 43) {
#line 1891
      goto case_123___0;
    }
#line 1891
    if ((127 & (int )((scm_cell *)proc)->car) == 35) {
#line 1891
      goto case_123___0;
    }
#line 1891
    if ((127 & (int )((scm_cell *)proc)->car) == 27) {
#line 1891
      goto case_123___0;
    }
#line 1891
    if ((127 & (int )((scm_cell *)proc)->car) == 19) {
#line 1891
      goto case_123___0;
    }
#line 1891
    if ((127 & (int )((scm_cell *)proc)->car) == 11) {
#line 1891
      goto case_123___0;
    }
#line 1891
    if ((127 & (int )((scm_cell *)proc)->car) == 3) {
#line 1891
      goto case_123___0;
    }
#line 1901
    if ((127 & (int )((scm_cell *)proc)->car) == 117) {
#line 1901
      goto umwrongnumargs;
    }
#line 1901
    if ((127 & (int )((scm_cell *)proc)->car) == 95) {
#line 1901
      goto umwrongnumargs;
    }
#line 1901
    if ((127 & (int )((scm_cell *)proc)->car) == 93) {
#line 1901
      goto umwrongnumargs;
    }
#line 1901
    if ((127 & (int )((scm_cell *)proc)->car) == 111) {
#line 1901
      goto umwrongnumargs;
    }
#line 1901
    if ((127 & (int )((scm_cell *)proc)->car) == 101) {
#line 1901
      goto umwrongnumargs;
    }
#line 1901
    if ((127 & (int )((scm_cell *)proc)->car) == 87) {
#line 1901
      goto umwrongnumargs;
    }
#line 1901
    if ((127 & (int )((scm_cell *)proc)->car) == 61) {
#line 1901
      goto umwrongnumargs;
    }
#line 1907
    goto switch_default___1;
    case_85___0: /* CIL Label */ 
    {
#line 1872
    tmp___112 = (*(((scm_subr *)proc)->cproc))();
    }
#line 1872
    return (tmp___112);
    case_109___0: /* CIL Label */ 
    {
#line 1874
    tmp___113 = (*(((scm_subr *)proc)->cproc))((long )(18 << 9) + 372L);
    }
#line 1874
    return (tmp___113);
    case_119___0: /* CIL Label */ 
    {
#line 1876
    tmp___114 = (*(((scm_subr *)proc)->cproc))((long )(20 << 9) + 372L);
    }
#line 1876
    return (tmp___114);
    case_69___0: /* CIL Label */ 
#line 1878
    return ((long )(17 << 9) + 372L);
    case_103___0: /* CIL Label */ 
    {
#line 1880
    tmp___115 = (*(((scm_subr *)proc)->cproc))((long )(18 << 9) + 372L, (long )(18 << 9) + 372L);
    }
#line 1880
    return (tmp___115);
    case_63: /* CIL Label */ 
#line 1883
    t.arg1 = proc;
#line 1884
    proc = *((SCM *)((scm_cell *)proc)->cdr + 0);
#line 1889
    goto evap1;
    case_123___0: /* CIL Label */ 
    case_115___0: /* CIL Label */ 
    case_107___0: /* CIL Label */ 
    case_99___0: /* CIL Label */ 
    case_91___0: /* CIL Label */ 
    case_83___0: /* CIL Label */ 
    case_75___0: /* CIL Label */ 
    case_67___0: /* CIL Label */ 
    case_59___0: /* CIL Label */ 
    case_51___0: /* CIL Label */ 
    case_43___0: /* CIL Label */ 
    case_35___0: /* CIL Label */ 
    case_27___0: /* CIL Label */ 
    case_19___0: /* CIL Label */ 
    case_11___0: /* CIL Label */ 
    case_3___0: /* CIL Label */ 
    {
#line 1892
    x = ((scm_cell *)(((scm_cell *)proc)->car - 3L))->car;
#line 1893
    env = scm_acons(((scm_cell *)x)->car, (long )(20 << 9) + 372L, ((scm_cell *)proc)->cdr);
    }
#line 1894
    goto cdrxbegin;
    umwrongnumargs: 
    case_117___0: /* CIL Label */ 
    case_95___0: /* CIL Label */ 
    case_93___0: /* CIL Label */ 
    case_111___0: /* CIL Label */ 
    case_101___0: /* CIL Label */ 
    case_87___0: /* CIL Label */ 
    case_61: /* CIL Label */ 
    {
#line 1903
    scm_unmemocar(x, env);
    }
    wrongnumargs: 
    {
#line 1906
    scm_wrong_num_args(proc);
    }
    switch_default___1: /* CIL Label */ 
#line 1909
    goto badfun;
    switch_break___3: /* CIL Label */ ;
    }
  }
#line 1914
  x = ((scm_cell *)x)->cdr;
#line 1916
  if (6 & (int )x) {
#line 1917
    goto wrongnumargs;
  }
#line 1919
  if ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )((scm_cell *)x)->car)) {
#line 1919
    if (6 & (int )((scm_cell *)x)->car) {
#line 1919
      if (((int )((scm_cell *)x)->car & 255) == 252) {
        {
#line 1919
        tmp___116 = scm_ilookup(((scm_cell *)x)->car, env);
#line 1919
        tmp___117 = *tmp___116;
        }
      } else {
#line 1919
        tmp___117 = ((scm_cell *)x)->car;
      }
#line 1919
      tmp___118 = tmp___117;
    } else {
#line 1919
      tmp___118 = ((scm_cell *)(((scm_cell *)x)->car - 1L))->cdr;
    }
#line 1919
    t.arg1 = tmp___118;
  } else {
#line 1919
    if ((125 & (int )((scm_cell *)((scm_cell *)x)->car)->car) == 5) {
      {
#line 1919
      tmp___119 = scm_lookupcar(x, env);
#line 1919
      tmp___121 = *tmp___119;
      }
    } else {
      {
#line 1919
      tmp___120 = scm_ceval(((scm_cell *)x)->car, env);
#line 1919
      tmp___121 = tmp___120;
      }
    }
#line 1919
    t.arg1 = tmp___121;
  }
#line 1923
  x = ((scm_cell *)x)->cdr;
#line 1924
  if ((long )(20 << 9) + 372L == x) {
    evap1: 
    {
#line 1930
    if ((127 & (int )((scm_cell *)proc)->car) == 111) {
#line 1930
      goto case_111___1;
    }
#line 1933
    if ((127 & (int )((scm_cell *)proc)->car) == 109) {
#line 1933
      goto case_109___1;
    }
#line 1933
    if ((127 & (int )((scm_cell *)proc)->car) == 87) {
#line 1933
      goto case_109___1;
    }
#line 1935
    if ((127 & (int )((scm_cell *)proc)->car) == 93) {
#line 1935
      goto case_93___1;
    }
#line 1970
    if ((127 & (int )((scm_cell *)proc)->car) == 69) {
#line 1970
      goto case_69___1;
    }
#line 1972
    if ((127 & (int )((scm_cell *)proc)->car) == 103) {
#line 1972
      goto case_103___1;
    }
#line 1974
    if ((127 & (int )((scm_cell *)proc)->car) == 119) {
#line 1974
      goto case_119___1;
    }
#line 1981
    if ((127 & (int )((scm_cell *)proc)->car) == 63) {
#line 1981
      goto case_63___0;
    }
#line 1991
    if ((127 & (int )((scm_cell *)proc)->car) == 123) {
#line 1991
      goto case_123___1;
    }
#line 1991
    if ((127 & (int )((scm_cell *)proc)->car) == 115) {
#line 1991
      goto case_123___1;
    }
#line 1991
    if ((127 & (int )((scm_cell *)proc)->car) == 107) {
#line 1991
      goto case_123___1;
    }
#line 1991
    if ((127 & (int )((scm_cell *)proc)->car) == 99) {
#line 1991
      goto case_123___1;
    }
#line 1991
    if ((127 & (int )((scm_cell *)proc)->car) == 91) {
#line 1991
      goto case_123___1;
    }
#line 1991
    if ((127 & (int )((scm_cell *)proc)->car) == 83) {
#line 1991
      goto case_123___1;
    }
#line 1991
    if ((127 & (int )((scm_cell *)proc)->car) == 75) {
#line 1991
      goto case_123___1;
    }
#line 1991
    if ((127 & (int )((scm_cell *)proc)->car) == 67) {
#line 1991
      goto case_123___1;
    }
#line 1991
    if ((127 & (int )((scm_cell *)proc)->car) == 59) {
#line 1991
      goto case_123___1;
    }
#line 1991
    if ((127 & (int )((scm_cell *)proc)->car) == 51) {
#line 1991
      goto case_123___1;
    }
#line 1991
    if ((127 & (int )((scm_cell *)proc)->car) == 43) {
#line 1991
      goto case_123___1;
    }
#line 1991
    if ((127 & (int )((scm_cell *)proc)->car) == 35) {
#line 1991
      goto case_123___1;
    }
#line 1991
    if ((127 & (int )((scm_cell *)proc)->car) == 27) {
#line 1991
      goto case_123___1;
    }
#line 1991
    if ((127 & (int )((scm_cell *)proc)->car) == 19) {
#line 1991
      goto case_123___1;
    }
#line 1991
    if ((127 & (int )((scm_cell *)proc)->car) == 11) {
#line 1991
      goto case_123___1;
    }
#line 1991
    if ((127 & (int )((scm_cell *)proc)->car) == 3) {
#line 1991
      goto case_123___1;
    }
#line 1999
    if ((127 & (int )((scm_cell *)proc)->car) == 61) {
#line 1999
      goto case_61___0;
    }
#line 2004
    if ((127 & (int )((scm_cell *)proc)->car) == 117) {
#line 2004
      goto case_117___1;
    }
#line 2004
    if ((127 & (int )((scm_cell *)proc)->car) == 95) {
#line 2004
      goto case_117___1;
    }
#line 2004
    if ((127 & (int )((scm_cell *)proc)->car) == 85) {
#line 2004
      goto case_117___1;
    }
#line 2004
    if ((127 & (int )((scm_cell *)proc)->car) == 101) {
#line 2004
      goto case_117___1;
    }
#line 2006
    goto switch_default___2;
    case_111___1: /* CIL Label */ 
    {
#line 1931
    tmp___122 = (*(((scm_subr *)proc)->cproc))(t.arg1, (long )(18 << 9) + 372L);
    }
#line 1931
    return (tmp___122);
    case_109___1: /* CIL Label */ 
    case_87___1: /* CIL Label */ 
    {
#line 1934
    tmp___123 = (*(((scm_subr *)proc)->cproc))(t.arg1);
    }
#line 1934
    return (tmp___123);
    case_93___1: /* CIL Label */ 
#line 1937
    if (((scm_subr *)proc)->cproc) {
#line 1939
      if (2 & (int )t.arg1) {
        {
#line 1941
        tmp___124 = (*(((scm_dsubr *)proc)->dproc))((double )(t.arg1 >> 2));
#line 1941
        tmp___125 = scm_makdbl(tmp___124, 0.0);
        }
#line 1941
        return (tmp___125);
      }
#line 1944
      if (! (! (6 & (int )t.arg1))) {
#line 1944
        goto floerr;
      }
#line 1945
      if (((scm_cell *)t.arg1)->car == (383L | (1L << 16))) {
        {
#line 1947
        tmp___126 = (*(((scm_dsubr *)proc)->dproc))(*(((scm_dbl *)t.arg1)->real));
#line 1947
        tmp___127 = scm_makdbl(tmp___126, 0.0);
        }
#line 1947
        return (tmp___127);
      }
#line 1950
      if ((65279 & (int )((scm_cell *)t.arg1)->car) == 639) {
        {
#line 1952
        tmp___128 = scm_big2dbl(t.arg1);
#line 1952
        tmp___129 = (*(((scm_dsubr *)proc)->dproc))(tmp___128);
#line 1952
        tmp___130 = scm_makdbl(tmp___129, 0.0);
        }
#line 1952
        return (tmp___130);
      }
      floerr: 
#line 1956
      if (((scm_cell *)proc)->car >> 8) {
#line 1956
        tmp___131 = (SCM )(scm_heap_org + (((scm_cell *)proc)->car >> 8));
      } else {
#line 1956
        tmp___131 = scm_sys_protects[4];
      }
      {
#line 1956
      scm_wta(t.arg1, (char *)1, (char *)((scm_cell *)tmp___131)->cdr);
      }
    }
#line 1959
    if (((scm_cell *)proc)->car >> 8) {
#line 1959
      tmp___132 = (SCM )(scm_heap_org + (((scm_cell *)proc)->car >> 8));
    } else {
#line 1959
      tmp___132 = scm_sys_protects[4];
    }
#line 1959
    proc = tmp___132;
#line 1961
    chrs = ((char *)((scm_cell *)proc)->cdr + ((unsigned long )((scm_cell *)proc)->car >> 8)) - 1;
    {
#line 1962
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 1962
      chrs --;
#line 1962
      if (! (99 != (int )*chrs)) {
#line 1962
        goto while_break___13;
      }
#line 1964
      if (! (6 & (int )t.arg1)) {
#line 1964
        if (! (! (1 & (int )((scm_cell *)t.arg1)->car))) {
          {
#line 1964
          scm_wta(t.arg1, (char *)1, (char *)((scm_cell *)proc)->cdr);
          }
        }
      } else {
        {
#line 1964
        scm_wta(t.arg1, (char *)1, (char *)((scm_cell *)proc)->cdr);
        }
      }
#line 1966
      if (97 == (int )*chrs) {
#line 1966
        t.arg1 = ((scm_cell *)t.arg1)->car;
      } else {
#line 1966
        t.arg1 = ((scm_cell *)t.arg1)->cdr;
      }
    }
    while_break___13: /* CIL Label */ ;
    }
#line 1968
    return (t.arg1);
    case_69___1: /* CIL Label */ 
#line 1971
    return ((long )(17 << 9) + 372L);
    case_103___1: /* CIL Label */ 
    {
#line 1973
    tmp___133 = (*(((scm_subr *)proc)->cproc))(t.arg1, (long )(18 << 9) + 372L);
    }
#line 1973
    return (tmp___133);
    case_119___1: /* CIL Label */ 
    {
#line 1978
    tmp___134 = scm_cons(t.arg1, (long )(20 << 9) + 372L);
#line 1978
    tmp___135 = (*(((scm_subr *)proc)->cproc))(tmp___134);
    }
#line 1978
    return (tmp___135);
    case_63___0: /* CIL Label */ 
#line 1982
    arg2 = t.arg1;
#line 1983
    t.arg1 = proc;
#line 1984
    proc = *((SCM *)((scm_cell *)proc)->cdr + 0);
#line 1989
    goto evap2;
    case_123___1: /* CIL Label */ 
    case_115___1: /* CIL Label */ 
    case_107___1: /* CIL Label */ 
    case_99___1: /* CIL Label */ 
    case_91___1: /* CIL Label */ 
    case_83___1: /* CIL Label */ 
    case_75___1: /* CIL Label */ 
    case_67___1: /* CIL Label */ 
    case_59___1: /* CIL Label */ 
    case_51___1: /* CIL Label */ 
    case_43___1: /* CIL Label */ 
    case_35___1: /* CIL Label */ 
    case_27___1: /* CIL Label */ 
    case_19___1: /* CIL Label */ 
    case_11___1: /* CIL Label */ 
    case_3___1: /* CIL Label */ 
    {
#line 1992
    x = ((scm_cell *)(((scm_cell *)proc)->car - 3L))->car;
#line 1996
    tmp___136 = scm_cons(t.arg1, (long )(20 << 9) + 372L);
#line 1996
    env = scm_acons(((scm_cell *)x)->car, tmp___136, ((scm_cell *)proc)->cdr);
    }
#line 1998
    goto cdrxbegin;
    case_61___0: /* CIL Label */ 
    {
#line 2000
    scm_call_continuation(proc, t.arg1);
    }
    case_117___1: /* CIL Label */ 
    case_95___1: /* CIL Label */ 
    case_85___1: /* CIL Label */ 
    case_101___1: /* CIL Label */ 
#line 2005
    goto wrongnumargs;
    switch_default___2: /* CIL Label */ 
#line 2007
    goto badfun;
    switch_break___4: /* CIL Label */ ;
    }
  }
#line 2011
  if (6 & (int )x) {
#line 2012
    goto wrongnumargs;
  }
#line 2015
  if ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )((scm_cell *)x)->car)) {
#line 2015
    if (6 & (int )((scm_cell *)x)->car) {
#line 2015
      if (((int )((scm_cell *)x)->car & 255) == 252) {
        {
#line 2015
        tmp___137 = scm_ilookup(((scm_cell *)x)->car, env);
#line 2015
        tmp___138 = *tmp___137;
        }
      } else {
#line 2015
        tmp___138 = ((scm_cell *)x)->car;
      }
#line 2015
      tmp___139 = tmp___138;
    } else {
#line 2015
      tmp___139 = ((scm_cell *)(((scm_cell *)x)->car - 1L))->cdr;
    }
#line 2015
    arg2 = tmp___139;
  } else {
#line 2015
    if ((125 & (int )((scm_cell *)((scm_cell *)x)->car)->car) == 5) {
      {
#line 2015
      tmp___140 = scm_lookupcar(x, env);
#line 2015
      tmp___142 = *tmp___140;
      }
    } else {
      {
#line 2015
      tmp___141 = scm_ceval(((scm_cell *)x)->car, env);
#line 2015
      tmp___142 = tmp___141;
      }
    }
#line 2015
    arg2 = tmp___142;
  }
#line 2019
  x = ((scm_cell *)x)->cdr;
#line 2020
  if ((long )(20 << 9) + 372L == x) {
    evap2: 
    {
#line 2028
    if ((127 & (int )((scm_cell *)proc)->car) == 111) {
#line 2028
      goto case_111___2;
    }
#line 2028
    if ((127 & (int )((scm_cell *)proc)->car) == 101) {
#line 2028
      goto case_111___2;
    }
#line 2030
    if ((127 & (int )((scm_cell *)proc)->car) == 119) {
#line 2030
      goto case_119___2;
    }
#line 2036
    if ((127 & (int )((scm_cell *)proc)->car) == 117) {
#line 2036
      goto case_117___2;
    }
#line 2039
    if ((127 & (int )((scm_cell *)proc)->car) == 103) {
#line 2039
      goto case_103___2;
    }
#line 2039
    if ((127 & (int )((scm_cell *)proc)->car) == 69) {
#line 2039
      goto case_103___2;
    }
#line 2043
    if ((127 & (int )((scm_cell *)proc)->car) == 63) {
#line 2043
      goto cclon;
    }
#line 2064
    if ((127 & (int )((scm_cell *)proc)->car) == 61) {
#line 2064
      goto case_61___1;
    }
#line 2064
    if ((127 & (int )((scm_cell *)proc)->car) == 95) {
#line 2064
      goto case_61___1;
    }
#line 2064
    if ((127 & (int )((scm_cell *)proc)->car) == 87) {
#line 2064
      goto case_61___1;
    }
#line 2064
    if ((127 & (int )((scm_cell *)proc)->car) == 109) {
#line 2064
      goto case_61___1;
    }
#line 2064
    if ((127 & (int )((scm_cell *)proc)->car) == 93) {
#line 2064
      goto case_61___1;
    }
#line 2064
    if ((127 & (int )((scm_cell *)proc)->car) == 85) {
#line 2064
      goto case_61___1;
    }
#line 2068
    if ((127 & (int )((scm_cell *)proc)->car) == 123) {
#line 2068
      goto case_123___2;
    }
#line 2068
    if ((127 & (int )((scm_cell *)proc)->car) == 115) {
#line 2068
      goto case_123___2;
    }
#line 2068
    if ((127 & (int )((scm_cell *)proc)->car) == 107) {
#line 2068
      goto case_123___2;
    }
#line 2068
    if ((127 & (int )((scm_cell *)proc)->car) == 99) {
#line 2068
      goto case_123___2;
    }
#line 2068
    if ((127 & (int )((scm_cell *)proc)->car) == 91) {
#line 2068
      goto case_123___2;
    }
#line 2068
    if ((127 & (int )((scm_cell *)proc)->car) == 83) {
#line 2068
      goto case_123___2;
    }
#line 2068
    if ((127 & (int )((scm_cell *)proc)->car) == 75) {
#line 2068
      goto case_123___2;
    }
#line 2068
    if ((127 & (int )((scm_cell *)proc)->car) == 67) {
#line 2068
      goto case_123___2;
    }
#line 2068
    if ((127 & (int )((scm_cell *)proc)->car) == 59) {
#line 2068
      goto case_123___2;
    }
#line 2068
    if ((127 & (int )((scm_cell *)proc)->car) == 51) {
#line 2068
      goto case_123___2;
    }
#line 2068
    if ((127 & (int )((scm_cell *)proc)->car) == 43) {
#line 2068
      goto case_123___2;
    }
#line 2068
    if ((127 & (int )((scm_cell *)proc)->car) == 35) {
#line 2068
      goto case_123___2;
    }
#line 2068
    if ((127 & (int )((scm_cell *)proc)->car) == 27) {
#line 2068
      goto case_123___2;
    }
#line 2068
    if ((127 & (int )((scm_cell *)proc)->car) == 19) {
#line 2068
      goto case_123___2;
    }
#line 2068
    if ((127 & (int )((scm_cell *)proc)->car) == 11) {
#line 2068
      goto case_123___2;
    }
#line 2068
    if ((127 & (int )((scm_cell *)proc)->car) == 3) {
#line 2068
      goto case_123___2;
    }
#line 2066
    goto switch_default___3;
    case_111___2: /* CIL Label */ 
    case_101___2: /* CIL Label */ 
    {
#line 2029
    tmp___143 = (*(((scm_subr *)proc)->cproc))(t.arg1, arg2);
    }
#line 2029
    return (tmp___143);
    case_119___2: /* CIL Label */ 
    {
#line 2034
    tmp___144 = scm_cons2(t.arg1, arg2, (long )(20 << 9) + 372L);
#line 2034
    tmp___145 = (*(((scm_subr *)proc)->cproc))(tmp___144);
    }
#line 2034
    return (tmp___145);
    case_117___2: /* CIL Label */ 
    {
#line 2037
    tmp___146 = (*(((scm_subr *)proc)->cproc))(t.arg1, arg2, (long )(20 << 9) + 372L);
    }
#line 2037
    return (tmp___146);
    case_103___2: /* CIL Label */ 
    case_69___2: /* CIL Label */ 
    {
#line 2040
    tmp___147 = (*(((scm_subr *)proc)->cproc))(t.arg1, arg2);
    }
#line 2040
    return (tmp___147);
    cclon: 
    case_63___1: /* CIL Label */ 
    {
#line 2048
    tmp___148 = scm_eval_args(x, env);
#line 2048
    tmp___149 = scm_cons(tmp___148, (long )(20 << 9) + 372L);
#line 2048
    tmp___150 = scm_cons2(t.arg1, arg2, tmp___149);
#line 2048
    tmp___151 = scm_apply(*((SCM *)((scm_cell *)proc)->cdr + 0), proc, tmp___150);
    }
#line 2048
    return (tmp___151);
    case_61___1: /* CIL Label */ 
    case_95___2: /* CIL Label */ 
    case_87___2: /* CIL Label */ 
    case_109___2: /* CIL Label */ 
    case_93___2: /* CIL Label */ 
    case_85___2: /* CIL Label */ 
#line 2065
    goto wrongnumargs;
    switch_default___3: /* CIL Label */ 
#line 2067
    goto badfun;
    case_123___2: /* CIL Label */ 
    case_115___2: /* CIL Label */ 
    case_107___2: /* CIL Label */ 
    case_99___2: /* CIL Label */ 
    case_91___2: /* CIL Label */ 
    case_83___2: /* CIL Label */ 
    case_75___2: /* CIL Label */ 
    case_67___2: /* CIL Label */ 
    case_59___2: /* CIL Label */ 
    case_51___2: /* CIL Label */ 
    case_43___2: /* CIL Label */ 
    case_35___2: /* CIL Label */ 
    case_27___2: /* CIL Label */ 
    case_19___2: /* CIL Label */ 
    case_11___2: /* CIL Label */ 
    case_3___2: /* CIL Label */ 
    {
#line 2072
    tmp___152 = scm_cons2(t.arg1, arg2, (long )(20 << 9) + 372L);
#line 2072
    env = scm_acons(((scm_cell *)((scm_cell *)(((scm_cell *)proc)->car - 3L))->car)->car,
                    tmp___152, ((scm_cell *)proc)->cdr);
#line 2074
    x = ((scm_cell *)(((scm_cell *)proc)->car - 3L))->car;
    }
#line 2075
    goto cdrxbegin;
    switch_break___5: /* CIL Label */ ;
    }
  }
  {
#line 2114
  if ((127 & (int )((scm_cell *)proc)->car) == 95) {
#line 2114
    goto case_95___3;
  }
#line 2124
  if ((127 & (int )((scm_cell *)proc)->car) == 69) {
#line 2124
    goto case_69___3;
  }
#line 2124
  if ((127 & (int )((scm_cell *)proc)->car) == 103) {
#line 2124
    goto case_69___3;
  }
#line 2126
  if ((127 & (int )((scm_cell *)proc)->car) == 117) {
#line 2126
    goto case_117___3;
  }
#line 2128
  if ((127 & (int )((scm_cell *)proc)->car) == 119) {
#line 2128
    goto case_119___3;
  }
#line 2131
  if ((127 & (int )((scm_cell *)proc)->car) == 63) {
#line 2131
    goto case_63___2;
  }
#line 2134
  if ((127 & (int )((scm_cell *)proc)->car) == 123) {
#line 2134
    goto case_123___3;
  }
#line 2134
  if ((127 & (int )((scm_cell *)proc)->car) == 115) {
#line 2134
    goto case_123___3;
  }
#line 2134
  if ((127 & (int )((scm_cell *)proc)->car) == 107) {
#line 2134
    goto case_123___3;
  }
#line 2134
  if ((127 & (int )((scm_cell *)proc)->car) == 99) {
#line 2134
    goto case_123___3;
  }
#line 2134
  if ((127 & (int )((scm_cell *)proc)->car) == 91) {
#line 2134
    goto case_123___3;
  }
#line 2134
  if ((127 & (int )((scm_cell *)proc)->car) == 83) {
#line 2134
    goto case_123___3;
  }
#line 2134
  if ((127 & (int )((scm_cell *)proc)->car) == 75) {
#line 2134
    goto case_123___3;
  }
#line 2134
  if ((127 & (int )((scm_cell *)proc)->car) == 67) {
#line 2134
    goto case_123___3;
  }
#line 2134
  if ((127 & (int )((scm_cell *)proc)->car) == 59) {
#line 2134
    goto case_123___3;
  }
#line 2134
  if ((127 & (int )((scm_cell *)proc)->car) == 51) {
#line 2134
    goto case_123___3;
  }
#line 2134
  if ((127 & (int )((scm_cell *)proc)->car) == 43) {
#line 2134
    goto case_123___3;
  }
#line 2134
  if ((127 & (int )((scm_cell *)proc)->car) == 35) {
#line 2134
    goto case_123___3;
  }
#line 2134
  if ((127 & (int )((scm_cell *)proc)->car) == 27) {
#line 2134
    goto case_123___3;
  }
#line 2134
  if ((127 & (int )((scm_cell *)proc)->car) == 19) {
#line 2134
    goto case_123___3;
  }
#line 2134
  if ((127 & (int )((scm_cell *)proc)->car) == 11) {
#line 2134
    goto case_123___3;
  }
#line 2134
  if ((127 & (int )((scm_cell *)proc)->car) == 3) {
#line 2134
    goto case_123___3;
  }
#line 2150
  if ((127 & (int )((scm_cell *)proc)->car) == 61) {
#line 2150
    goto case_61___2;
  }
#line 2150
  if ((127 & (int )((scm_cell *)proc)->car) == 87) {
#line 2150
    goto case_61___2;
  }
#line 2150
  if ((127 & (int )((scm_cell *)proc)->car) == 93) {
#line 2150
    goto case_61___2;
  }
#line 2150
  if ((127 & (int )((scm_cell *)proc)->car) == 85) {
#line 2150
    goto case_61___2;
  }
#line 2150
  if ((127 & (int )((scm_cell *)proc)->car) == 111) {
#line 2150
    goto case_61___2;
  }
#line 2150
  if ((127 & (int )((scm_cell *)proc)->car) == 109) {
#line 2150
    goto case_61___2;
  }
#line 2150
  if ((127 & (int )((scm_cell *)proc)->car) == 101) {
#line 2150
    goto case_61___2;
  }
#line 2152
  goto switch_default___4;
  case_95___3: /* CIL Label */ 
#line 2115
  if (! ((long )(20 << 9) + 372L == ((scm_cell *)x)->cdr)) {
#line 2115
    goto wrongnumargs;
  }
#line 2116
  if ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )((scm_cell *)x)->car)) {
#line 2116
    if (6 & (int )((scm_cell *)x)->car) {
#line 2116
      if (((int )((scm_cell *)x)->car & 255) == 252) {
        {
#line 2116
        tmp___153 = scm_ilookup(((scm_cell *)x)->car, env);
#line 2116
        tmp___154 = *tmp___153;
        }
      } else {
#line 2116
        tmp___154 = ((scm_cell *)x)->car;
      }
#line 2116
      tmp___155 = tmp___154;
    } else {
#line 2116
      tmp___155 = ((scm_cell *)(((scm_cell *)x)->car - 1L))->cdr;
    }
#line 2116
    tmp___159 = tmp___155;
  } else {
#line 2116
    if ((125 & (int )((scm_cell *)((scm_cell *)x)->car)->car) == 5) {
      {
#line 2116
      tmp___156 = scm_lookupcar(x, env);
#line 2116
      tmp___158 = *tmp___156;
      }
    } else {
      {
#line 2116
      tmp___157 = scm_ceval(((scm_cell *)x)->car, env);
#line 2116
      tmp___158 = tmp___157;
      }
    }
#line 2116
    tmp___159 = tmp___158;
  }
  {
#line 2116
  tmp___160 = (*(((scm_subr *)proc)->cproc))(t.arg1, arg2, tmp___159);
  }
#line 2116
  return (tmp___160);
  case_69___3: /* CIL Label */ 
  case_103___3: /* CIL Label */ 
  {
#line 2125
  tmp___161 = scm_eval_args(x, env);
#line 2125
  tmp___162 = scm_acons(arg2, tmp___161, (long )(20 << 9) + 372L);
#line 2125
  tmp___163 = scm_apply(proc, t.arg1, tmp___162);
  }
#line 2125
  return (tmp___163);
  case_117___3: /* CIL Label */ 
  {
#line 2127
  tmp___164 = scm_eval_args(x, env);
#line 2127
  tmp___165 = (*(((scm_subr *)proc)->cproc))(t.arg1, arg2, tmp___164);
  }
#line 2127
  return (tmp___165);
  case_119___3: /* CIL Label */ 
  {
#line 2129
  tmp___166 = scm_eval_args(x, env);
#line 2129
  tmp___167 = scm_cons2(t.arg1, arg2, tmp___166);
#line 2129
  tmp___168 = (*(((scm_subr *)proc)->cproc))(tmp___167);
  }
#line 2129
  return (tmp___168);
  case_63___2: /* CIL Label */ 
#line 2132
  goto cclon;
  case_123___3: /* CIL Label */ 
  case_115___3: /* CIL Label */ 
  case_107___3: /* CIL Label */ 
  case_99___3: /* CIL Label */ 
  case_91___3: /* CIL Label */ 
  case_83___3: /* CIL Label */ 
  case_75___3: /* CIL Label */ 
  case_67___3: /* CIL Label */ 
  case_59___3: /* CIL Label */ 
  case_51___3: /* CIL Label */ 
  case_43___3: /* CIL Label */ 
  case_35___3: /* CIL Label */ 
  case_27___3: /* CIL Label */ 
  case_19___3: /* CIL Label */ 
  case_11___3: /* CIL Label */ 
  case_3___3: /* CIL Label */ 
  {
#line 2138
  tmp___169 = scm_eval_args(x, env);
#line 2138
  tmp___170 = scm_cons2(t.arg1, arg2, tmp___169);
#line 2138
  env = scm_acons(((scm_cell *)((scm_cell *)(((scm_cell *)proc)->car - 3L))->car)->car,
                  tmp___170, ((scm_cell *)proc)->cdr);
#line 2141
  x = ((scm_cell *)(((scm_cell *)proc)->car - 3L))->car;
  }
#line 2142
  goto cdrxbegin;
  case_61___2: /* CIL Label */ 
  case_87___3: /* CIL Label */ 
  case_93___3: /* CIL Label */ 
  case_85___3: /* CIL Label */ 
  case_111___3: /* CIL Label */ 
  case_109___3: /* CIL Label */ 
  case_101___3: /* CIL Label */ 
#line 2151
  goto wrongnumargs;
  switch_default___4: /* CIL Label */ 
#line 2153
  goto badfun;
  switch_break___6: /* CIL Label */ ;
  }
}
}
#line 2189 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
static char s_procedure_documentation[24]  = 
#line 2189
  {      (char )'p',      (char )'r',      (char )'o',      (char )'c', 
        (char )'e',      (char )'d',      (char )'u',      (char )'r', 
        (char )'e',      (char )'-',      (char )'d',      (char )'o', 
        (char )'c',      (char )'u',      (char )'m',      (char )'e', 
        (char )'n',      (char )'t',      (char )'a',      (char )'t', 
        (char )'i',      (char )'o',      (char )'n',      (char )'\000'};
#line 2191 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_procedure_documentation(SCM proc ) 
{ 
  SCM code ;
  SCM tmp ;

  {
  {
#line 2196
  tmp = scm_procedure_p(proc);
  }
#line 2196
  if ((long )(17 << 9) + 372L == tmp) {
#line 2196
    if (! (6 & (int )proc)) {
#line 2196
      if (! ((127 & (int )((scm_cell *)proc)->car) != 61)) {
        {
#line 2196
        scm_wta(proc, (char *)1, s_procedure_documentation);
        }
      }
    } else {
      {
#line 2196
      scm_wta(proc, (char *)1, s_procedure_documentation);
      }
    }
  } else {
    {
#line 2196
    scm_wta(proc, (char *)1, s_procedure_documentation);
    }
  }
  {
#line 2200
  if ((127 & (int )((scm_cell *)proc)->car) == 123) {
#line 2200
    goto case_123;
  }
#line 2200
  if ((127 & (int )((scm_cell *)proc)->car) == 115) {
#line 2200
    goto case_123;
  }
#line 2200
  if ((127 & (int )((scm_cell *)proc)->car) == 107) {
#line 2200
    goto case_123;
  }
#line 2200
  if ((127 & (int )((scm_cell *)proc)->car) == 99) {
#line 2200
    goto case_123;
  }
#line 2200
  if ((127 & (int )((scm_cell *)proc)->car) == 91) {
#line 2200
    goto case_123;
  }
#line 2200
  if ((127 & (int )((scm_cell *)proc)->car) == 83) {
#line 2200
    goto case_123;
  }
#line 2200
  if ((127 & (int )((scm_cell *)proc)->car) == 75) {
#line 2200
    goto case_123;
  }
#line 2200
  if ((127 & (int )((scm_cell *)proc)->car) == 67) {
#line 2200
    goto case_123;
  }
#line 2200
  if ((127 & (int )((scm_cell *)proc)->car) == 59) {
#line 2200
    goto case_123;
  }
#line 2200
  if ((127 & (int )((scm_cell *)proc)->car) == 51) {
#line 2200
    goto case_123;
  }
#line 2200
  if ((127 & (int )((scm_cell *)proc)->car) == 43) {
#line 2200
    goto case_123;
  }
#line 2200
  if ((127 & (int )((scm_cell *)proc)->car) == 35) {
#line 2200
    goto case_123;
  }
#line 2200
  if ((127 & (int )((scm_cell *)proc)->car) == 27) {
#line 2200
    goto case_123;
  }
#line 2200
  if ((127 & (int )((scm_cell *)proc)->car) == 19) {
#line 2200
    goto case_123;
  }
#line 2200
  if ((127 & (int )((scm_cell *)proc)->car) == 11) {
#line 2200
    goto case_123;
  }
#line 2200
  if ((127 & (int )((scm_cell *)proc)->car) == 3) {
#line 2200
    goto case_123;
  }
#line 2209
  goto switch_default;
  case_123: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_91: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_59: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_35: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_19: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 2201
  code = ((scm_cell *)((scm_cell *)(((scm_cell *)proc)->car - 3L))->car)->cdr;
#line 2202
  if (6 & (int )((scm_cell *)code)->cdr) {
#line 2203
    return ((long )(16 << 9) + 372L);
  }
#line 2204
  code = ((scm_cell *)code)->car;
#line 2205
  if (6 & (int )code) {
#line 2206
    return ((long )(16 << 9) + 372L);
  }
#line 2207
  if ((125 & (int )((scm_cell *)code)->car) == 21) {
#line 2208
    return (code);
  }
  switch_default: /* CIL Label */ 
#line 2210
  return ((long )(16 << 9) + 372L);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 2235 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
static char s_nconc2last[17]  = 
#line 2235
  {      (char )'a',      (char )'p',      (char )'p',      (char )'l', 
        (char )'y',      (char )':',      (char )'n',      (char )'c', 
        (char )'o',      (char )'n',      (char )'c',      (char )'2', 
        (char )'l',      (char )'a',      (char )'s',      (char )'t', 
        (char )'\000'};
#line 2237 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_nconc2last(SCM lst ) 
{ 
  SCM *lloc ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 2242
  tmp = scm_ilength(lst);
  }
#line 2242
  if (! (tmp > 0L)) {
    {
#line 2242
    scm_wta(lst, (char *)1, s_nconc2last);
    }
  }
#line 2243
  lloc = & lst;
  {
#line 2244
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2244
    if (! ((long )(20 << 9) + 372L != ((scm_cell *)*lloc)->cdr)) {
#line 2244
      goto while_break;
    }
#line 2245
    lloc = & ((scm_cell *)*lloc)->cdr;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2246
  tmp___0 = scm_ilength(((scm_cell *)*lloc)->car);
  }
#line 2246
  if (! (tmp___0 >= 0L)) {
    {
#line 2246
    scm_wta(lst, (char *)1, s_nconc2last);
    }
  }
#line 2247
  *lloc = ((scm_cell *)*lloc)->car;
#line 2248
  return (lst);
}
}
#line 2279 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_apply(SCM proc , SCM arg1 , SCM args ) 
{ 
  SCM tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  SCM tmp___2 ;
  SCM tmp___3 ;
  double tmp___4 ;
  SCM tmp___5 ;
  double tmp___6 ;
  SCM tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  SCM tmp___10 ;
  SCM tmp___11 ;
  SCM tmp___12 ;
  char *chrs ;
  SCM tmp___13 ;
  SCM tmp___14 ;
  long tmp___15 ;
  SCM tmp___16 ;
  SCM tmp___17 ;
  SCM tmp___18 ;
  SCM tmp___19 ;
  SCM tmp___20 ;
  int tmp___21 ;
  SCM *tmp___22 ;
  SCM tmp___23 ;
  SCM tmp___24 ;
  SCM *tmp___25 ;
  SCM tmp___26 ;
  SCM tmp___27 ;
  SCM tmp___28 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
#line 2296
  if (scm_debug_mode) {
    {
#line 2297
    tmp = scm_dapply(proc, arg1, args);
    }
#line 2297
    return (tmp);
  }
#line 2301
  if (! (! (6 & (int )proc))) {
#line 2301
    goto badproc;
  }
#line 2302
  if ((long )(20 << 9) + 372L == args) {
#line 2304
    if ((long )(20 << 9) + 372L == arg1) {
#line 2305
      arg1 = (long )(18 << 9) + 372L;
    } else {
#line 2308
      args = ((scm_cell *)arg1)->cdr;
#line 2309
      arg1 = ((scm_cell *)arg1)->car;
    }
  } else {
    {
#line 2315
    args = scm_nconc2last(args);
    }
  }
  tail: 
  {
#line 2342
  if ((127 & (int )((scm_cell *)proc)->car) == 111) {
#line 2342
    goto case_111;
  }
#line 2345
  if ((127 & (int )((scm_cell *)proc)->car) == 101) {
#line 2345
    goto case_101;
  }
#line 2349
  if ((127 & (int )((scm_cell *)proc)->car) == 85) {
#line 2349
    goto case_85;
  }
#line 2353
  if ((127 & (int )((scm_cell *)proc)->car) == 109) {
#line 2353
    goto case_109;
  }
#line 2353
  if ((127 & (int )((scm_cell *)proc)->car) == 87) {
#line 2353
    goto case_109;
  }
#line 2356
  if ((127 & (int )((scm_cell *)proc)->car) == 93) {
#line 2356
    goto case_93;
  }
#line 2390
  if ((127 & (int )((scm_cell *)proc)->car) == 95) {
#line 2390
    goto case_95;
  }
#line 2392
  if ((127 & (int )((scm_cell *)proc)->car) == 119) {
#line 2392
    goto case_119;
  }
#line 2398
  if ((127 & (int )((scm_cell *)proc)->car) == 117) {
#line 2398
    goto case_117;
  }
#line 2401
  if ((127 & (int )((scm_cell *)proc)->car) == 103) {
#line 2401
    goto case_103;
  }
#line 2411
  if ((127 & (int )((scm_cell *)proc)->car) == 69) {
#line 2411
    goto case_69;
  }
#line 2423
  if ((127 & (int )((scm_cell *)proc)->car) == 123) {
#line 2423
    goto case_123;
  }
#line 2423
  if ((127 & (int )((scm_cell *)proc)->car) == 115) {
#line 2423
    goto case_123;
  }
#line 2423
  if ((127 & (int )((scm_cell *)proc)->car) == 107) {
#line 2423
    goto case_123;
  }
#line 2423
  if ((127 & (int )((scm_cell *)proc)->car) == 99) {
#line 2423
    goto case_123;
  }
#line 2423
  if ((127 & (int )((scm_cell *)proc)->car) == 91) {
#line 2423
    goto case_123;
  }
#line 2423
  if ((127 & (int )((scm_cell *)proc)->car) == 83) {
#line 2423
    goto case_123;
  }
#line 2423
  if ((127 & (int )((scm_cell *)proc)->car) == 75) {
#line 2423
    goto case_123;
  }
#line 2423
  if ((127 & (int )((scm_cell *)proc)->car) == 67) {
#line 2423
    goto case_123;
  }
#line 2423
  if ((127 & (int )((scm_cell *)proc)->car) == 59) {
#line 2423
    goto case_123;
  }
#line 2423
  if ((127 & (int )((scm_cell *)proc)->car) == 51) {
#line 2423
    goto case_123;
  }
#line 2423
  if ((127 & (int )((scm_cell *)proc)->car) == 43) {
#line 2423
    goto case_123;
  }
#line 2423
  if ((127 & (int )((scm_cell *)proc)->car) == 35) {
#line 2423
    goto case_123;
  }
#line 2423
  if ((127 & (int )((scm_cell *)proc)->car) == 27) {
#line 2423
    goto case_123;
  }
#line 2423
  if ((127 & (int )((scm_cell *)proc)->car) == 19) {
#line 2423
    goto case_123;
  }
#line 2423
  if ((127 & (int )((scm_cell *)proc)->car) == 11) {
#line 2423
    goto case_123;
  }
#line 2423
  if ((127 & (int )((scm_cell *)proc)->car) == 3) {
#line 2423
    goto case_123;
  }
#line 2438
  if ((127 & (int )((scm_cell *)proc)->car) == 61) {
#line 2438
    goto case_61;
  }
#line 2442
  if ((127 & (int )((scm_cell *)proc)->car) == 63) {
#line 2442
    goto case_63;
  }
#line 2458
  goto badproc;
  case_111: /* CIL Label */ 
#line 2343
  if ((long )(20 << 9) + 372L == args) {
#line 2343
    args = (long )(18 << 9) + 372L;
  } else {
#line 2343
    args = ((scm_cell *)args)->car;
  }
  {
#line 2344
  tmp___0 = (*(((scm_subr *)proc)->cproc))(arg1, args);
  }
#line 2344
  return (tmp___0);
  case_101: /* CIL Label */ 
#line 2346
  if (! ((long )(20 << 9) + 372L == ((scm_cell *)args)->cdr)) {
#line 2346
    goto wrongnumargs;
  }
  {
#line 2347
  args = ((scm_cell *)args)->car;
#line 2348
  tmp___1 = (*(((scm_subr *)proc)->cproc))(arg1, args);
  }
#line 2348
  return (tmp___1);
  case_85: /* CIL Label */ 
#line 2350
  if (! ((long )(18 << 9) + 372L == arg1)) {
#line 2350
    goto wrongnumargs;
  }
  {
#line 2351
  tmp___2 = (*(((scm_subr *)proc)->cproc))();
  }
#line 2351
  return (tmp___2);
  case_109: /* CIL Label */ 
  case_87: /* CIL Label */ 
#line 2354
  if (! ((long )(20 << 9) + 372L == args)) {
#line 2354
    goto wrongnumargs;
  }
  {
#line 2355
  tmp___3 = (*(((scm_subr *)proc)->cproc))(arg1);
  }
#line 2355
  return (tmp___3);
  case_93: /* CIL Label */ 
#line 2357
  if (! ((long )(20 << 9) + 372L == args)) {
#line 2357
    goto wrongnumargs;
  }
#line 2359
  if (((scm_subr *)proc)->cproc) {
#line 2361
    if (2 & (int )arg1) {
      {
#line 2363
      tmp___4 = (*(((scm_dsubr *)proc)->dproc))((double )(arg1 >> 2));
#line 2363
      tmp___5 = scm_makdbl(tmp___4, 0.0);
      }
#line 2363
      return (tmp___5);
    }
#line 2365
    if (! (! (6 & (int )arg1))) {
#line 2365
      goto floerr;
    }
#line 2366
    if (((scm_cell *)arg1)->car == (383L | (1L << 16))) {
      {
#line 2368
      tmp___6 = (*(((scm_dsubr *)proc)->dproc))(*(((scm_dbl *)arg1)->real));
#line 2368
      tmp___7 = scm_makdbl(tmp___6, 0.0);
      }
#line 2368
      return (tmp___7);
    }
#line 2371
    if ((65279 & (int )((scm_cell *)arg1)->car) == 639) {
      {
#line 2373
      tmp___8 = scm_big2dbl(arg1);
#line 2373
      tmp___9 = (*(((scm_dsubr *)proc)->dproc))(tmp___8);
#line 2373
      tmp___10 = scm_makdbl(tmp___9, 0.0);
      }
#line 2373
      return (tmp___10);
    }
    floerr: 
#line 2376
    if (((scm_cell *)proc)->car >> 8) {
#line 2376
      tmp___11 = (SCM )(scm_heap_org + (((scm_cell *)proc)->car >> 8));
    } else {
#line 2376
      tmp___11 = scm_sys_protects[4];
    }
    {
#line 2376
    scm_wta(arg1, (char *)1, (char *)((scm_cell *)tmp___11)->cdr);
    }
  }
#line 2379
  if (((scm_cell *)proc)->car >> 8) {
#line 2379
    tmp___12 = (SCM )(scm_heap_org + (((scm_cell *)proc)->car >> 8));
  } else {
#line 2379
    tmp___12 = scm_sys_protects[4];
  }
#line 2379
  proc = tmp___12;
#line 2381
  chrs = ((char *)((scm_cell *)proc)->cdr + ((unsigned long )((scm_cell *)proc)->car >> 8)) - 1;
  {
#line 2382
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2382
    chrs --;
#line 2382
    if (! (99 != (int )*chrs)) {
#line 2382
      goto while_break;
    }
#line 2384
    if (! (6 & (int )arg1)) {
#line 2384
      if (! (! (1 & (int )((scm_cell *)arg1)->car))) {
        {
#line 2384
        scm_wta(arg1, (char *)1, (char *)((scm_cell *)proc)->cdr);
        }
      }
    } else {
      {
#line 2384
      scm_wta(arg1, (char *)1, (char *)((scm_cell *)proc)->cdr);
      }
    }
#line 2386
    if (97 == (int )*chrs) {
#line 2386
      arg1 = ((scm_cell *)arg1)->car;
    } else {
#line 2386
      arg1 = ((scm_cell *)arg1)->cdr;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2388
  return (arg1);
  case_95: /* CIL Label */ 
  {
#line 2391
  tmp___13 = (*(((scm_subr *)proc)->cproc))(arg1, ((scm_cell *)args)->car, ((scm_cell *)((scm_cell *)args)->cdr)->car);
  }
#line 2391
  return (tmp___13);
  case_119: /* CIL Label */ 
#line 2396
  if ((long )(18 << 9) + 372L == arg1) {
#line 2396
    tmp___15 = (long )(20 << 9) + 372L;
  } else {
    {
#line 2396
    tmp___14 = scm_cons(arg1, args);
#line 2396
    tmp___15 = tmp___14;
    }
  }
  {
#line 2396
  tmp___16 = (*(((scm_subr *)proc)->cproc))(tmp___15);
  }
#line 2396
  return (tmp___16);
  case_117: /* CIL Label */ 
#line 2399
  if (! (6 & (int )args)) {
#line 2399
    if (! (! (1 & (int )((scm_cell *)args)->car))) {
#line 2399
      goto wrongnumargs;
    }
  } else {
#line 2399
    goto wrongnumargs;
  }
  {
#line 2400
  tmp___17 = (*(((scm_subr *)proc)->cproc))(arg1, ((scm_cell *)args)->car, ((scm_cell *)args)->cdr);
  }
#line 2400
  return (tmp___17);
  case_103: /* CIL Label */ 
#line 2402
  if ((long )(20 << 9) + 372L == args) {
    {
#line 2403
    tmp___18 = (*(((scm_subr *)proc)->cproc))(arg1, (long )(18 << 9) + 372L);
    }
#line 2403
    return (tmp___18);
  }
  {
#line 2404
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2404
    if (! (! (6 & (int )args))) {
#line 2404
      goto while_break___0;
    }
#line 2406
    if (! (! (1 & (int )((scm_cell *)args)->car))) {
      {
#line 2406
      scm_wta(args, (char *)2, (char *)"apply");
      }
    }
    {
#line 2407
    arg1 = (*(((scm_subr *)proc)->cproc))(arg1, ((scm_cell *)args)->car);
#line 2408
    args = ((scm_cell *)args)->cdr;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2410
  return (arg1);
  case_69: /* CIL Label */ 
#line 2412
  if ((long )(20 << 9) + 372L == args) {
#line 2413
    return ((long )(17 << 9) + 372L);
  }
  {
#line 2414
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2414
    if (! (! (6 & (int )args))) {
#line 2414
      goto while_break___1;
    }
#line 2416
    if (! (! (1 & (int )((scm_cell *)args)->car))) {
      {
#line 2416
      scm_wta(args, (char *)2, (char *)"apply");
      }
    }
    {
#line 2417
    tmp___19 = (*(((scm_subr *)proc)->cproc))(arg1, ((scm_cell *)args)->car);
    }
#line 2417
    if ((long )(16 << 9) + 372L == tmp___19) {
#line 2418
      return ((long )(16 << 9) + 372L);
    }
#line 2419
    arg1 = ((scm_cell *)args)->car;
#line 2420
    args = ((scm_cell *)args)->cdr;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2422
  return ((long )(17 << 9) + 372L);
  case_123: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_91: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_59: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_35: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_19: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 2427
  if ((long )(18 << 9) + 372L == arg1) {
#line 2427
    arg1 = (long )(20 << 9) + 372L;
  } else {
    {
#line 2427
    tmp___20 = scm_cons(arg1, args);
#line 2427
    arg1 = tmp___20;
    }
  }
  {
#line 2430
  tmp___21 = scm_badargsp(((scm_cell *)((scm_cell *)(((scm_cell *)proc)->car - 3L))->car)->car,
                          arg1);
  }
#line 2430
  if (tmp___21) {
#line 2431
    goto wrongnumargs;
  }
  {
#line 2433
  args = scm_acons(((scm_cell *)((scm_cell *)(((scm_cell *)proc)->car - 3L))->car)->car,
                   arg1, ((scm_cell *)proc)->cdr);
#line 2434
  proc = ((scm_cell *)(((scm_cell *)proc)->car - 3L))->car;
  }
  {
#line 2435
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2435
    proc = ((scm_cell *)proc)->cdr;
#line 2435
    if (! ((long )(20 << 9) + 372L != proc)) {
#line 2435
      goto while_break___2;
    }
#line 2436
    if ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )((scm_cell *)proc)->car)) {
#line 2436
      if (6 & (int )((scm_cell *)proc)->car) {
#line 2436
        if (((int )((scm_cell *)proc)->car & 255) == 252) {
          {
#line 2436
          tmp___22 = scm_ilookup(((scm_cell *)proc)->car, args);
#line 2436
          tmp___23 = *tmp___22;
          }
        } else {
#line 2436
          tmp___23 = ((scm_cell *)proc)->car;
        }
#line 2436
        tmp___24 = tmp___23;
      } else {
#line 2436
        tmp___24 = ((scm_cell *)(((scm_cell *)proc)->car - 1L))->cdr;
      }
#line 2436
      arg1 = tmp___24;
    } else {
#line 2436
      if ((125 & (int )((scm_cell *)((scm_cell *)proc)->car)->car) == 5) {
        {
#line 2436
        tmp___25 = scm_lookupcar(proc, args);
#line 2436
        tmp___27 = *tmp___25;
        }
      } else {
        {
#line 2436
        tmp___26 = scm_ceval(((scm_cell *)proc)->car, args);
#line 2436
        tmp___27 = tmp___26;
        }
      }
#line 2436
      arg1 = tmp___27;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2437
  return (arg1);
  case_61: /* CIL Label */ 
#line 2439
  if (! ((long )(20 << 9) + 372L == args)) {
#line 2439
    goto wrongnumargs;
  }
  {
#line 2440
  scm_call_continuation(proc, arg1);
  }
  case_63: /* CIL Label */ 
#line 2450
  if ((long )(18 << 9) + 372L == arg1) {
#line 2450
    args = (long )(20 << 9) + 372L;
  } else {
    {
#line 2450
    tmp___28 = scm_cons(arg1, args);
#line 2450
    args = tmp___28;
    }
  }
#line 2451
  arg1 = proc;
#line 2452
  proc = *((SCM *)((scm_cell *)proc)->cdr + 0);
#line 2454
  goto tail;
  wrongnumargs: 
  {
#line 2457
  scm_wrong_num_args(proc);
  }
  badproc: 
  switch_default: /* CIL Label */ 
  {
#line 2460
  scm_wta(proc, (char *)1, (char *)"apply");
  }
#line 2461
  return (arg1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 2496 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
static char s_map[4]  = {      (char )'m',      (char )'a',      (char )'p',      (char )'\000'};
#line 2498 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_map(SCM proc , SCM arg1 , SCM args ) 
{ 
  long i ;
  SCM res ;
  SCM *pres ;
  SCM *ve ;
  SCM tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;

  {
#line 2505
  res = (long )(20 << 9) + 372L;
#line 2506
  pres = & res;
#line 2507
  ve = & args;
#line 2509
  if ((long )(20 << 9) + 372L == arg1) {
#line 2510
    return (res);
  }
#line 2511
  if (! (! (6 & (int )arg1))) {
    {
#line 2511
    scm_wta(arg1, (char *)2, s_map);
    }
  }
#line 2512
  if ((long )(20 << 9) + 372L == args) {
    {
#line 2514
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2514
      if (! (! (6 & (int )arg1))) {
#line 2514
        goto while_break;
      }
#line 2516
      if (! (! (1 & (int )((scm_cell *)arg1)->car))) {
        {
#line 2516
        scm_wta(arg1, (char *)2, s_map);
        }
      }
      {
#line 2517
      tmp = scm_apply(proc, ((scm_cell *)arg1)->car, scm_sys_protects[1]);
#line 2517
      *pres = scm_cons(tmp, (long )(20 << 9) + 372L);
#line 2518
      pres = & ((scm_cell *)*pres)->cdr;
#line 2519
      arg1 = ((scm_cell *)arg1)->cdr;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 2521
    return (res);
  }
  {
#line 2523
  tmp___0 = scm_cons(arg1, args);
#line 2523
  args = scm_vector(tmp___0);
#line 2524
  ve = (SCM *)((scm_cell *)args)->cdr;
#line 2526
  i = (long )(((unsigned long )((scm_cell *)args)->car >> 8) - 1UL);
  }
  {
#line 2526
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2526
    if (! (i >= 0L)) {
#line 2526
      goto while_break___0;
    }
#line 2527
    if (! (6 & (int )*(ve + i))) {
#line 2527
      if (! (! (1 & (int )((scm_cell *)*(ve + i))->car))) {
        {
#line 2527
        scm_wta(args, (char *)2, s_map);
        }
      }
    } else {
      {
#line 2527
      scm_wta(args, (char *)2, s_map);
      }
    }
#line 2526
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2529
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2531
    arg1 = (long )(20 << 9) + 372L;
#line 2532
    i = (long )(((unsigned long )((scm_cell *)args)->car >> 8) - 1UL);
    {
#line 2532
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2532
      if (! (i >= 0L)) {
#line 2532
        goto while_break___2;
      }
#line 2534
      if (6 & (int )*(ve + i)) {
#line 2534
        return (res);
      }
      {
#line 2536
      arg1 = scm_cons(((scm_cell *)*(ve + i))->car, arg1);
#line 2537
      *(ve + i) = ((scm_cell *)*(ve + i))->cdr;
#line 2532
      i --;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 2539
    tmp___1 = scm_apply(proc, arg1, (long )(20 << 9) + 372L);
#line 2539
    *pres = scm_cons(tmp___1, (long )(20 << 9) + 372L);
#line 2540
    pres = & ((scm_cell *)*pres)->cdr;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
}
}
#line 2545 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
static char s_for_each[9]  = 
#line 2545
  {      (char )'f',      (char )'o',      (char )'r',      (char )'-', 
        (char )'e',      (char )'a',      (char )'c',      (char )'h', 
        (char )'\000'};
#line 2547 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_for_each(SCM proc , SCM arg1 , SCM args ) 
{ 
  SCM *ve ;
  long i ;
  SCM tmp ;

  {
#line 2553
  ve = & args;
#line 2555
  if ((long )(20 << 9) + 372L == arg1) {
#line 2556
    return ((long )(21 << 9) + 372L);
  }
#line 2557
  if (! (! (6 & (int )arg1))) {
    {
#line 2557
    scm_wta(arg1, (char *)2, s_for_each);
    }
  }
#line 2558
  if ((long )(20 << 9) + 372L == args) {
    {
#line 2560
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2560
      if (! (! (6 & (int )arg1))) {
#line 2560
        goto while_break;
      }
#line 2562
      if (! (! (1 & (int )((scm_cell *)arg1)->car))) {
        {
#line 2562
        scm_wta(arg1, (char *)2, s_for_each);
        }
      }
      {
#line 2563
      scm_apply(proc, ((scm_cell *)arg1)->car, scm_sys_protects[1]);
#line 2564
      arg1 = ((scm_cell *)arg1)->cdr;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 2566
    return ((long )(21 << 9) + 372L);
  }
  {
#line 2568
  tmp = scm_cons(arg1, args);
#line 2568
  args = scm_vector(tmp);
#line 2569
  ve = (SCM *)((scm_cell *)args)->cdr;
#line 2571
  i = (long )(((unsigned long )((scm_cell *)args)->car >> 8) - 1UL);
  }
  {
#line 2571
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2571
    if (! (i >= 0L)) {
#line 2571
      goto while_break___0;
    }
#line 2572
    if (! (6 & (int )*(ve + i))) {
#line 2572
      if (! (! (1 & (int )((scm_cell *)*(ve + i))->car))) {
        {
#line 2572
        scm_wta(args, (char *)2, s_for_each);
        }
      }
    } else {
      {
#line 2572
      scm_wta(args, (char *)2, s_for_each);
      }
    }
#line 2571
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2574
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2576
    arg1 = (long )(20 << 9) + 372L;
#line 2577
    i = (long )(((unsigned long )((scm_cell *)args)->car >> 8) - 1UL);
    {
#line 2577
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2577
      if (! (i >= 0L)) {
#line 2577
        goto while_break___2;
      }
#line 2579
      if (6 & (int )*(ve + i)) {
#line 2579
        return ((long )(21 << 9) + 372L);
      }
      {
#line 2581
      arg1 = scm_cons(((scm_cell *)*(ve + i))->car, arg1);
#line 2582
      *(ve + i) = ((scm_cell *)*(ve + i))->cdr;
#line 2577
      i --;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 2584
    scm_apply(proc, arg1, (long )(20 << 9) + 372L);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
}
}
#line 2590 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_closure(SCM code , SCM env ) 
{ 
  register SCM z ;
  SCM tmp ;

  {
#line 2596
  if (6 & (int )scm_freelist) {
    {
#line 2596
    z = scm_gc_for_newcell();
    }
  } else {
#line 2596
    z = scm_freelist;
#line 2596
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 2596
    scm_cells_allocated ++;
  }
  {
#line 2597
  tmp = scm_cons(code, (long )(20 << 9) + 372L);
#line 2597
  ((scm_cell *)z)->car = tmp + 3L;
#line 2598
  ((scm_cell *)z)->cdr = env;
  }
#line 2599
  return (z);
}
}
#line 2603 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
long scm_tc16_promise  ;
#line 2605 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_makprom(SCM code ) 
{ 
  register SCM z ;

  {
#line 2610
  if (6 & (int )scm_freelist) {
    {
#line 2610
    z = scm_gc_for_newcell();
    }
  } else {
#line 2610
    z = scm_freelist;
#line 2610
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 2610
    scm_cells_allocated ++;
  }
#line 2611
  ((scm_cell *)z)->cdr = code;
#line 2612
  ((scm_cell *)z)->car = scm_tc16_promise;
#line 2613
  return (z);
}
}
#line 2618
static int prinprom(SCM exp___0 , SCM port , scm_print_state *pstate ) ;
#line 2620 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
static int prinprom(SCM exp___0 , SCM port , scm_print_state *pstate ) 
{ 
  int writingp ;
  char *__cil_tmp5 ;

  {
  {
#line 2626
  writingp = (int )pstate->writingp;
#line 2627
  scm_gen_puts((enum scm_string_representation_type )0, (char *)"#<promise ", port);
#line 2628
  pstate->writingp = 1UL;
#line 2629
  scm_iprin1(((scm_cell *)exp___0)->cdr, port, pstate);
#line 2630
  pstate->writingp = (unsigned long )writingp;
#line 2631
  scm_gen_putc('>', port);
  }
#line 2632
  return (1);
}
}
#line 2636 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
static char s_makacro[18]  = 
#line 2636
  {      (char )'p',      (char )'r',      (char )'o',      (char )'c', 
        (char )'e',      (char )'d',      (char )'u',      (char )'r', 
        (char )'e',      (char )'-',      (char )'>',      (char )'s', 
        (char )'y',      (char )'n',      (char )'t',      (char )'a', 
        (char )'x',      (char )'\000'};
#line 2638 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_makacro(SCM code ) 
{ 
  register SCM z ;

  {
#line 2643
  if (6 & (int )scm_freelist) {
    {
#line 2643
    z = scm_gc_for_newcell();
    }
  } else {
#line 2643
    z = scm_freelist;
#line 2643
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 2643
    scm_cells_allocated ++;
  }
#line 2644
  ((scm_cell *)z)->cdr = code;
#line 2645
  ((scm_cell *)z)->car = scm_tc16_macro;
#line 2646
  return (z);
}
}
#line 2650 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
static char s_makmacro[17]  = 
#line 2650
  {      (char )'p',      (char )'r',      (char )'o',      (char )'c', 
        (char )'e',      (char )'d',      (char )'u',      (char )'r', 
        (char )'e',      (char )'-',      (char )'>',      (char )'m', 
        (char )'a',      (char )'c',      (char )'r',      (char )'o', 
        (char )'\000'};
#line 2652 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_makmacro(SCM code ) 
{ 
  register SCM z ;

  {
#line 2657
  if (6 & (int )scm_freelist) {
    {
#line 2657
    z = scm_gc_for_newcell();
    }
  } else {
#line 2657
    z = scm_freelist;
#line 2657
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 2657
    scm_cells_allocated ++;
  }
#line 2658
  ((scm_cell *)z)->cdr = code;
#line 2659
  ((scm_cell *)z)->car = scm_tc16_macro | (1L << 16);
#line 2660
  return (z);
}
}
#line 2664 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
static char s_makmmacro[27]  = 
#line 2664
  {      (char )'p',      (char )'r',      (char )'o',      (char )'c', 
        (char )'e',      (char )'d',      (char )'u',      (char )'r', 
        (char )'e',      (char )'-',      (char )'>',      (char )'m', 
        (char )'e',      (char )'m',      (char )'o',      (char )'i', 
        (char )'z',      (char )'i',      (char )'n',      (char )'g', 
        (char )'-',      (char )'m',      (char )'a',      (char )'c', 
        (char )'r',      (char )'o',      (char )'\000'};
#line 2666 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_makmmacro(SCM code ) 
{ 
  register SCM z ;

  {
#line 2671
  if (6 & (int )scm_freelist) {
    {
#line 2671
    z = scm_gc_for_newcell();
    }
  } else {
#line 2671
    z = scm_freelist;
#line 2671
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 2671
    scm_cells_allocated ++;
  }
#line 2672
  ((scm_cell *)z)->cdr = code;
#line 2673
  ((scm_cell *)z)->car = scm_tc16_macro | (2L << 16);
#line 2674
  return (z);
}
}
#line 2679
static int prinmacro(SCM exp___0 , SCM port , scm_print_state *pstate ) ;
#line 2681 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
static int prinmacro(SCM exp___0 , SCM port , scm_print_state *pstate ) 
{ 
  int writingp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 2687
  writingp = (int )pstate->writingp;
#line 2688
  if (((scm_cell *)exp___0)->car & (3L << 16)) {
    {
#line 2689
    scm_gen_puts((enum scm_string_representation_type )0, (char *)"#<macro", port);
    }
  } else {
    {
#line 2691
    scm_gen_puts((enum scm_string_representation_type )0, (char *)"#<syntax", port);
    }
  }
#line 2692
  if (((scm_cell *)exp___0)->car & (2L << 16)) {
    {
#line 2693
    scm_gen_putc('!', port);
    }
  }
  {
#line 2694
  scm_gen_putc(' ', port);
#line 2695
  pstate->writingp = 1UL;
#line 2696
  scm_iprin1(((scm_cell *)exp___0)->cdr, port, pstate);
#line 2697
  pstate->writingp = (unsigned long )writingp;
#line 2698
  scm_gen_putc('>', port);
  }
#line 2699
  return (1);
}
}
#line 2702 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
static char s_force[6]  = {      (char )'f',      (char )'o',      (char )'r',      (char )'c', 
        (char )'e',      (char )'\000'};
#line 2704 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_force(SCM x ) 
{ 
  SCM ans ;
  SCM tmp ;

  {
#line 2708
  if (! ((long )(65535 & (int )((scm_cell *)x)->car) == scm_tc16_promise)) {
    {
#line 2708
    scm_wta(x, (char *)1, s_force);
    }
  }
#line 2709
  if (! ((1L << 16) & ((scm_cell *)x)->car)) {
    {
#line 2711
    tmp = scm_apply(((scm_cell *)x)->cdr, (long )(20 << 9) + 372L, (long )(20 << 9) + 372L);
#line 2711
    ans = tmp;
    }
#line 2712
    if (! ((1L << 16) & ((scm_cell *)x)->car)) {
#line 2714
      scm_ints_disabled = 1;
#line 2715
      ((scm_cell *)x)->cdr = ans;
#line 2716
      ((scm_cell *)x)->car |= 1L << 16;
#line 2717
      scm_ints_disabled = 0;
#line 2717
      scm_async_clock --;
#line 2717
      if (0U == scm_async_clock) {
        {
#line 2717
        scm_async_click();
        }
      }
    }
  }
#line 2720
  return (((scm_cell *)x)->cdr);
}
}
#line 2723 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
static char s_promise_p[9]  = 
#line 2723
  {      (char )'p',      (char )'r',      (char )'o',      (char )'m', 
        (char )'i',      (char )'s',      (char )'e',      (char )'?', 
        (char )'\000'};
#line 2725 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_promise_p(SCM x ) 
{ 
  long tmp ;

  {
#line 2729
  if (! (6 & (int )x)) {
#line 2729
    if ((long )(65535 & (int )((scm_cell *)x)->car) == scm_tc16_promise) {
#line 2729
      tmp = (long )(17 << 9) + 372L;
    } else {
#line 2729
      tmp = (long )(16 << 9) + 372L;
    }
  } else {
#line 2729
    tmp = (long )(16 << 9) + 372L;
  }
#line 2729
  return (tmp);
}
}
#line 2734 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
static char s_copy_tree[10]  = 
#line 2734
  {      (char )'c',      (char )'o',      (char )'p',      (char )'y', 
        (char )'-',      (char )'t',      (char )'r',      (char )'e', 
        (char )'e',      (char )'\000'};
#line 2736 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_copy_tree(SCM obj ) 
{ 
  SCM ans ;
  SCM tl ;
  size_t i ;
  size_t tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  SCM tmp___2 ;

  {
#line 2741
  if (6 & (int )obj) {
#line 2741
    return (obj);
  }
#line 2743
  if ((125 & (int )((scm_cell *)obj)->car) == 13) {
    {
#line 2745
    i = (unsigned long )((scm_cell *)obj)->car >> 8;
#line 2746
    ans = scm_make_vector((SCM )((i << 2) + 2UL), (long )(21 << 9) + 372L, (long )(18 << 9) + 372L);
    }
    {
#line 2747
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2747
      tmp = i;
#line 2747
      i --;
#line 2747
      if (! tmp) {
#line 2747
        goto while_break;
      }
      {
#line 2748
      *((SCM *)((scm_cell *)ans)->cdr + i) = scm_copy_tree(*((SCM *)((scm_cell *)obj)->cdr + i));
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 2749
    return (ans);
  }
#line 2751
  if (1 & (int )((scm_cell *)obj)->car) {
#line 2752
    return (obj);
  }
  {
#line 2754
  tmp___0 = scm_copy_tree(((scm_cell *)obj)->car);
#line 2754
  tl = scm_cons(tmp___0, (long )(21 << 9) + 372L);
#line 2754
  ans = tl;
  }
  {
#line 2755
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2755
    obj = ((scm_cell *)obj)->cdr;
#line 2755
    if (6 & (int )obj) {
#line 2755
      goto while_break___0;
    } else
#line 2755
    if (! (! (1 & (int )((scm_cell *)obj)->car))) {
#line 2755
      goto while_break___0;
    }
    {
#line 2757
    tmp___1 = scm_copy_tree(((scm_cell *)obj)->car);
#line 2757
    tmp___2 = scm_cons(tmp___1, (long )(21 << 9) + 372L);
#line 2757
    ((scm_cell *)tl)->cdr = tmp___2;
#line 2759
    tl = ((scm_cell *)tl)->cdr;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2761
  ((scm_cell *)tl)->cdr = obj;
#line 2762
  return (ans);
}
}
#line 2766 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_eval_3(SCM obj , int copyp , SCM env ) 
{ 
  SCM tmp ;
  SCM tmp___0 ;

  {
#line 2772
  if (! (6 & (int )((scm_cell *)scm_root->system_transformer)->cdr)) {
    {
#line 2773
    obj = scm_apply(((scm_cell *)scm_root->system_transformer)->cdr, obj, scm_sys_protects[1]);
    }
  } else
#line 2774
  if (copyp) {
    {
#line 2775
    obj = scm_copy_tree(obj);
    }
  }
#line 2776
  if (6 & (int )obj) {
#line 2776
    tmp___0 = obj;
  } else {
    {
#line 2776
    tmp = (*scm_ceval_ptr)(obj, env);
#line 2776
    tmp___0 = tmp;
    }
  }
#line 2776
  return (tmp___0);
}
}
#line 2780 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_top_level_env(SCM thunk ) 
{ 
  SCM tmp ;

  {
#line 2784
  if (6 & (int )thunk) {
#line 2785
    return ((long )(20 << 9) + 372L);
  } else {
    {
#line 2787
    tmp = scm_cons(thunk, (long )(20 << 9) + 372L);
    }
#line 2787
    return (tmp);
  }
}
}
#line 2790 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
static char s_eval2[6]  = {      (char )'e',      (char )'v',      (char )'a',      (char )'l', 
        (char )'2',      (char )'\000'};
#line 2792 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_eval2(SCM obj , SCM env_thunk ) 
{ 
  SCM tmp ;
  SCM tmp___0 ;

  {
  {
#line 2797
  tmp = scm_top_level_env(env_thunk);
#line 2797
  tmp___0 = scm_eval_3(obj, 1, tmp);
  }
#line 2797
  return (tmp___0);
}
}
#line 2800 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
static char s_eval[5]  = {      (char )'e',      (char )'v',      (char )'a',      (char )'l', 
        (char )'\000'};
#line 2802 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_eval(SCM obj ) 
{ 
  SCM tmp ;
  SCM tmp___0 ;

  {
  {
#line 2806
  tmp = scm_top_level_env(((scm_cell *)scm_root->top_level_lookup_closure_var)->cdr);
#line 2806
  tmp___0 = scm_eval_3(obj, 1, tmp);
  }
#line 2806
  return (tmp___0);
}
}
#line 2812 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_eval_x(SCM obj ) 
{ 
  SCM tmp ;
  SCM tmp___0 ;

  {
  {
#line 2816
  tmp = scm_top_level_env(((scm_cell *)scm_root->top_level_lookup_closure_var)->cdr);
#line 2816
  tmp___0 = scm_eval_3(obj, 0, tmp);
  }
#line 2816
  return (tmp___0);
}
}
#line 2822 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
static char s_macro_eval_x[12]  = 
#line 2822
  {      (char )'m',      (char )'a',      (char )'c',      (char )'r', 
        (char )'o',      (char )'-',      (char )'e',      (char )'v', 
        (char )'a',      (char )'l',      (char )'!',      (char )'\000'};
#line 2824 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_macro_eval_x(SCM exp___0 , SCM env ) 
{ 
  SCM tmp ;

  {
  {
#line 2829
  tmp = scm_eval_3(exp___0, 0, env);
  }
#line 2829
  return (tmp);
}
}
#line 2833 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
static char s_definedp[9]  = 
#line 2833
  {      (char )'d',      (char )'e',      (char )'f',      (char )'i', 
        (char )'n',      (char )'e',      (char )'d',      (char )'?', 
        (char )'\000'};
#line 2835 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_definedp(SCM sym ) 
{ 
  SCM vcell ;
  long tmp ;

  {
#line 2841
  if ((391 & (int )sym) == 4) {
#line 2842
    return ((long )(17 << 9) + 372L);
  }
#line 2844
  if (! (6 & (int )sym)) {
#line 2844
    if (! ((125 & (int )((scm_cell *)sym)->car) == 5)) {
      {
#line 2844
      scm_wta(sym, (char *)1, s_definedp);
      }
    }
  } else {
    {
#line 2844
    scm_wta(sym, (char *)1, s_definedp);
    }
  }
  {
#line 2846
  vcell = scm_sym2vcell(sym, ((scm_cell *)scm_root->top_level_lookup_closure_var)->cdr,
                        (long )(16 << 9) + 372L);
  }
#line 2849
  if (vcell == (long )(16 << 9) + 372L) {
#line 2849
    tmp = (long )(16 << 9) + 372L;
  } else
#line 2849
  if ((long )(18 << 9) + 372L == ((scm_cell *)vcell)->cdr) {
#line 2849
    tmp = (long )(16 << 9) + 372L;
  } else {
#line 2849
    tmp = (long )(17 << 9) + 372L;
  }
#line 2849
  return (tmp);
}
}
#line 2853 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
static scm_smobfuns promsmob  =    {& scm_markcdr, & scm_free0, & prinprom, (SCM (*)(SCM  , SCM  ))0};
#line 2856 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
static scm_smobfuns macrosmob  =    {& scm_markcdr, & scm_free0, & prinmacro, (SCM (*)(SCM  , SCM  ))0};
#line 2860 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_make_synt(char *name , SCM (*macroizer)(SCM  ) , SCM (*fcn)() ) 
{ 
  SCM symcell ;
  SCM tmp ;
  long tmp___0 ;
  register SCM z ;
  SCM tmp___1 ;

  {
  {
#line 2866
  tmp = scm_sysintern(name, (long )(18 << 9) + 372L);
#line 2866
  symcell = tmp;
#line 2867
  tmp___0 = ((SCM_CELLPTR )((scm_cell *)symcell)->car - scm_heap_org) << 8;
  }
#line 2869
  if (tmp___0 >> 8 != (SCM_CELLPTR )((scm_cell *)symcell)->car - scm_heap_org) {
#line 2870
    tmp___0 = 0L;
  }
#line 2871
  if (6 & (int )scm_freelist) {
    {
#line 2871
    z = scm_gc_for_newcell();
    }
  } else {
#line 2871
    z = scm_freelist;
#line 2871
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 2871
    scm_cells_allocated ++;
  }
  {
#line 2872
  ((scm_subr *)z)->cproc = fcn;
#line 2873
  ((scm_cell *)z)->car = tmp___0 + 101L;
#line 2874
  tmp___1 = (*macroizer)(z);
#line 2874
  ((scm_cell *)symcell)->cdr = tmp___1;
  }
#line 2875
  return (((scm_cell *)symcell)->car);
}
}
#line 1229 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
scm_option scm_debug_opts[12]  = 
#line 1229
  {      {0, (char *)"cheap", 1UL, (char *)"*Flyweight representation of the stack at traps."}, 
        {0,
      (char *)"breakpoints", 0UL, (char *)"*Check for breakpoints."}, 
        {0, (char *)"trace", 0UL, (char *)"*Trace mode."}, 
        {0, (char *)"procnames", 1UL, (char *)"Record procedure names at definition."}, 
        {0,
      (char *)"backwards", 0UL, (char *)"Display backtrace in anti-chronological order."}, 
        {1,
      (char *)"indent", 10UL, (char *)"Maximal indentation in backtrace."}, 
        {1, (char *)"frames", 3UL, (char *)"Maximum number of tail-recursive frames in backtrace."}, 
        {1,
      (char *)"maxdepth", 1000UL, (char *)"Maximal number of stored backtrace frames."}, 
        {1,
      (char *)"depth", 20UL, (char *)"Maximal length of printed backtrace."}, 
        {0, (char *)"backtrace", 0UL, (char *)"Show backtrace on error."}, 
        {0, (char *)"debug", 0UL, (char *)"Use the debugging evaluator."}, 
        {1, (char *)"stack", 20000UL, (char *)"Stack size limit (0 = no check)."}};
#line 1249 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
scm_option scm_evaluator_trap_table[3]  = {      {0, (char *)"enter-frame", 0UL, (char *)"Trap when eval enters new frame."}, 
        {0, (char *)"apply-frame", 0UL, (char *)"Trap when entering apply."}, 
        {0, (char *)"exit-frame", 0UL, (char *)"Trap when exiting eval or apply."}};
#line 1255 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_deval_args(SCM l , SCM env , SCM *lloc ) 
{ 
  SCM *res ;
  SCM *tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  SCM *tmp___2 ;
  SCM tmp___3 ;
  SCM tmp___4 ;
  SCM tmp___5 ;

  {
#line 1259
  res = lloc;
  {
#line 1260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1260
    if (! (! (6 & (int )l))) {
#line 1260
      goto while_break;
    }
#line 1262
    if ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )((scm_cell *)l)->car)) {
#line 1262
      if (6 & (int )((scm_cell *)l)->car) {
#line 1262
        if (((int )((scm_cell *)l)->car & 255) == 252) {
          {
#line 1262
          tmp = scm_ilookup(((scm_cell *)l)->car, env);
#line 1262
          tmp___0 = *tmp;
          }
        } else {
#line 1262
          tmp___0 = ((scm_cell *)l)->car;
        }
#line 1262
        tmp___1 = tmp___0;
      } else {
#line 1262
        tmp___1 = ((scm_cell *)(((scm_cell *)l)->car - 1L))->cdr;
      }
#line 1262
      tmp___5 = tmp___1;
    } else {
#line 1262
      if ((125 & (int )((scm_cell *)((scm_cell *)l)->car)->car) == 5) {
        {
#line 1262
        tmp___2 = scm_lookupcar(l, env);
#line 1262
        tmp___4 = *tmp___2;
        }
      } else {
        {
#line 1262
        tmp___3 = scm_deval(((scm_cell *)l)->car, env);
#line 1262
        tmp___4 = tmp___3;
        }
      }
#line 1262
      tmp___5 = tmp___4;
    }
    {
#line 1262
    *lloc = scm_cons(tmp___5, (long )(20 << 9) + 372L);
#line 1263
    lloc = & ((scm_cell *)*lloc)->cdr;
#line 1264
    l = ((scm_cell *)l)->cdr;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1266
  return (*res);
}
}
#line 1306 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_deval(SCM x , SCM env ) 
{ 
  union __anonunion_t_26 t ;
  SCM proc ;
  SCM arg2 ;
  scm_debug_frame debug ;
  scm_debug_info *debug_info_end ;
  void *tmp ;
  SCM tail ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  SCM tmp___3 ;
  SCM tmp___4 ;
  SCM tmp___5 ;
  SCM *tmp___6 ;
  SCM tmp___7 ;
  SCM tmp___8 ;
  SCM *tmp___9 ;
  SCM tmp___10 ;
  SCM tmp___11 ;
  SCM tmp___12 ;
  SCM *tmp___13 ;
  SCM tmp___14 ;
  SCM *tmp___15 ;
  SCM *tmp___16 ;
  SCM tmp___17 ;
  SCM tmp___18 ;
  SCM *tmp___19 ;
  SCM tmp___20 ;
  SCM tmp___21 ;
  SCM tmp___22 ;
  SCM *tmp___23 ;
  SCM tmp___24 ;
  SCM tmp___25 ;
  SCM *tmp___26 ;
  SCM tmp___27 ;
  SCM tmp___28 ;
  SCM *tmp___29 ;
  SCM tmp___30 ;
  SCM tmp___31 ;
  SCM *tmp___32 ;
  SCM tmp___33 ;
  SCM tmp___34 ;
  SCM tmp___35 ;
  SCM tail___0 ;
  long tmp___36 ;
  SCM tmp___37 ;
  SCM tmp___38 ;
  int tmp___39 ;
  SCM tmp___40 ;
  SCM *tmp___41 ;
  SCM tmp___42 ;
  SCM tmp___43 ;
  SCM *tmp___44 ;
  SCM tmp___45 ;
  SCM tmp___46 ;
  SCM tmp___47 ;
  SCM *tmp___48 ;
  SCM tmp___49 ;
  SCM tmp___50 ;
  SCM *tmp___51 ;
  SCM tmp___52 ;
  SCM tmp___53 ;
  SCM tmp___54 ;
  SCM *tmp___55 ;
  SCM tmp___56 ;
  SCM tmp___57 ;
  SCM *tmp___58 ;
  SCM tmp___59 ;
  SCM tmp___60 ;
  SCM tmp___61 ;
  SCM *tmp___62 ;
  SCM tmp___63 ;
  SCM tmp___64 ;
  SCM *tmp___65 ;
  SCM tmp___66 ;
  SCM tmp___67 ;
  SCM tmp___68 ;
  SCM *tmp___69 ;
  SCM tmp___70 ;
  SCM tmp___71 ;
  SCM *tmp___72 ;
  SCM tmp___73 ;
  SCM tmp___74 ;
  SCM tmp___75 ;
  SCM *tmp___76 ;
  SCM tmp___77 ;
  SCM tmp___78 ;
  SCM *tmp___79 ;
  SCM tmp___80 ;
  SCM tmp___81 ;
  SCM tmp___82 ;
  SCM *tmp___83 ;
  SCM tmp___84 ;
  SCM tmp___85 ;
  SCM *tmp___86 ;
  SCM tmp___87 ;
  SCM tmp___88 ;
  SCM tmp___89 ;
  SCM *tmp___90 ;
  SCM tmp___91 ;
  SCM tmp___92 ;
  SCM *tmp___93 ;
  SCM tmp___94 ;
  SCM tmp___95 ;
  SCM *tmp___96 ;
  SCM tmp___97 ;
  SCM tmp___98 ;
  SCM *tmp___99 ;
  SCM tmp___100 ;
  SCM tmp___101 ;
  SCM tmp___102 ;
  SCM tmp___103 ;
  SCM *tmp___104 ;
  SCM tmp___105 ;
  SCM tmp___106 ;
  SCM *tmp___107 ;
  SCM tmp___108 ;
  SCM tmp___109 ;
  SCM *tmp___110 ;
  SCM tmp___111 ;
  SCM tmp___112 ;
  SCM *tmp___113 ;
  SCM tmp___114 ;
  SCM tmp___115 ;
  int tmp___116 ;
  SCM val ;
  int tmp___117 ;
  SCM tmp___118 ;
  SCM tail___1 ;
  long tmp___119 ;
  SCM tmp___120 ;
  SCM tmp___121 ;
  int tmp___122 ;
  SCM tmp___123 ;
  SCM tmp___124 ;
  SCM *tmp___125 ;
  SCM *tmp___126 ;
  SCM tmp___127 ;
  long tmp___128 ;
  SCM tmp___129 ;
  SCM tmp___130 ;
  SCM tail___2 ;
  long tmp___131 ;
  SCM tmp___132 ;
  SCM tmp___133 ;
  int tmp___134 ;
  SCM tmp___135 ;
  SCM *tmp___136 ;
  SCM tmp___137 ;
  SCM tmp___138 ;
  SCM *tmp___139 ;
  SCM tmp___140 ;
  SCM tmp___141 ;
  SCM tmp___142 ;
  SCM tail___3 ;
  long tmp___143 ;
  SCM tmp___144 ;
  SCM tmp___145 ;
  int tmp___146 ;
  SCM tmp___147 ;
  double tmp___148 ;
  double tmp___149 ;
  double tmp___150 ;
  double tmp___151 ;
  SCM tmp___152 ;
  SCM tmp___153 ;
  char *chrs ;
  SCM *tmp___154 ;
  SCM tmp___155 ;
  SCM tmp___156 ;
  SCM *tmp___157 ;
  SCM tmp___158 ;
  SCM tmp___159 ;
  SCM tmp___160 ;
  SCM tail___4 ;
  long tmp___161 ;
  SCM tmp___162 ;
  SCM tmp___163 ;
  int tmp___164 ;
  SCM tmp___165 ;
  SCM tmp___166 ;
  SCM tmp___167 ;
  SCM tmp___168 ;
  SCM tail___5 ;
  long tmp___169 ;
  SCM tmp___170 ;
  SCM tmp___171 ;
  int tmp___172 ;
  SCM tmp___173 ;
  SCM tmp___174 ;
  int tmp___175 ;
  int tmp___176 ;
  SCM tmp___177 ;
  void *__cil_tmp196 ;
  void *__cil_tmp197 ;
  char *__cil_tmp198 ;

  {
  {
#line 1320
  debug.prev = scm_last_debug_frame;
#line 1321
  debug.status = (long )scm_debug_eframe_size;
#line 1322
  tmp = __builtin_alloca((unsigned long )scm_debug_eframe_size * sizeof(*(debug.vect + 0)));
#line 1322
  debug.vect = (scm_debug_info *)tmp;
#line 1324
  debug.info = debug.vect;
#line 1325
  debug_info_end = debug.vect + scm_debug_eframe_size;
#line 1326
  scm_last_debug_frame = & debug;
  }
#line 1329
  if ((unsigned long )(((scm_contregs *)((char *)((scm_cell *)scm_root->rootcont)->cdr))->base - & proc) > scm_debug_opts[11].val * sizeof(SCM_STACKITEM )) {
#line 1329
    if (scm_stack_checking_enabled_p) {
      {
#line 1333
      (debug.info)->e.exp = x;
#line 1334
      (debug.info)->e.env = env;
#line 1336
      scm_report_stack_overflow();
      }
    }
  }
#line 1340
  goto start;
  loopnoap: 
#line 1343
  (debug.info) ++;
#line 1343
  (debug.info)->a.proc = (long )(18 << 9) + 372L;
#line 1343
  (debug.info)->a.args = (long )(20 << 9) + 372L;
  loop: 
#line 1361
  debug.status &= ~ (1L << 7);
#line 1362
  if ((debug.status & (1L << 6)) != 0L) {
#line 1363
    (debug.info) --;
  } else {
#line 1364
    (debug.info) ++;
#line 1364
    if ((unsigned long )debug.info >= (unsigned long )debug_info_end) {
#line 1366
      debug.status |= 1L << 6;
#line 1367
      debug.info -= 2;
    }
  }
  start: 
#line 1370
  (debug.info)->e.exp = x;
#line 1371
  (debug.info)->e.env = env;
#line 1372
  if (scm_check_entry_p) {
#line 1373
    if (scm_evaluator_trap_table[0].val) {
#line 1373
      goto _L;
    } else
#line 1373
    if (scm_debug_opts[1].val) {
      {
#line 1373
      t.arg1 = scm_hash_fn_ref(scm_sys_protects[16], x, (long )(16 << 9) + 372L, (unsigned int (*)())(& scm_ihashq),
                               (SCM (*)())(& scm_sloppy_assq), (void *)0);
      }
#line 1373
      if (! (6 & (int )t.arg1)) {
#line 1373
        if ((long )(65535 & (int )((scm_cell *)t.arg1)->car) == scm_tc16_srcprops) {
#line 1373
          if ((1L << 16) & ((scm_cell *)t.arg1)->car) {
            _L: /* CIL Label */ 
#line 1375
            if ((debug.status & (1L << 9)) != 0L) {
#line 1375
              tmp___0 = (long )(17 << 9) + 372L;
            } else {
#line 1375
              tmp___0 = (long )(16 << 9) + 372L;
            }
#line 1375
            tail = tmp___0;
#line 1376
            debug.status |= 1L << 9;
#line 1377
            scm_evaluator_trap_table[0].val = 0UL;
#line 1378
            if (scm_evaluator_trap_table[0].val) {
#line 1378
              scm_check_entry_p = 1;
            } else
#line 1378
            if (scm_debug_opts[1].val) {
#line 1378
              scm_check_entry_p = 1;
            }
#line 1378
            if (scm_evaluator_trap_table[1].val) {
#line 1378
              scm_check_apply_p = 1;
            } else
#line 1378
            if (scm_debug_opts[2].val) {
#line 1378
              scm_check_apply_p = 1;
            }
#line 1378
            if (scm_evaluator_trap_table[2].val) {
#line 1378
              scm_check_exit_p = 1;
            } else
#line 1378
            if (scm_debug_opts[2].val) {
#line 1378
              scm_check_exit_p = 1;
            }
#line 1378
            if (scm_debug_opts[10].val) {
#line 1378
              tmp___1 = 1;
            } else
#line 1378
            if (scm_check_entry_p) {
#line 1378
              tmp___1 = 1;
            } else
#line 1378
            if (scm_check_apply_p) {
#line 1378
              tmp___1 = 1;
            } else
#line 1378
            if (scm_check_exit_p) {
#line 1378
              tmp___1 = 1;
            } else {
#line 1378
              tmp___1 = 0;
            }
#line 1378
            scm_debug_mode = tmp___1;
#line 1378
            if (scm_debug_mode) {
#line 1378
              scm_ceval_ptr = & scm_deval;
            } else {
#line 1378
              scm_ceval_ptr = & scm_ceval;
            }
#line 1379
            if (scm_debug_opts[0].val) {
              {
#line 1380
              t.arg1 = scm_make_debugobj(& debug);
              }
            } else {
              {
#line 1383
              scm_make_cont(& t.arg1);
#line 1384
              tmp___2 = _setjmp((struct __jmp_buf_tag *)(((scm_contregs *)((char *)((scm_cell *)t.arg1)->cdr))->jmpbuf));
              }
#line 1384
              if (tmp___2) {
#line 1386
                x = ((scm_contregs *)((char *)((scm_cell *)t.arg1)->cdr))->throw_value;
#line 1387
                if (6 & (int )x) {
#line 1389
                  proc = x;
#line 1389
                  goto exit;
                } else {
#line 1394
                  goto dispatch;
                }
              }
            }
            {
#line 1397
            tmp___3 = scm_unmemocopy(x, env);
#line 1397
            tmp___4 = scm_cons(tmp___3, (long )(20 << 9) + 372L);
#line 1397
            tmp___5 = scm_cons2(t.arg1, tail, tmp___4);
#line 1397
            scm_ithrow(scm_i_enter_frame, tmp___5, 0);
            }
          }
        }
      }
    }
  }
  dispatch: 
#line 1404
  scm_async_clock --;
#line 1404
  if (0U == scm_async_clock) {
    {
#line 1404
    scm_async_click();
    }
  }
  {
#line 1407
  if ((127 & (int )((scm_cell *)x)->car) == 7) {
#line 1407
    goto case_7;
  }
#line 1407
  if ((127 & (int )((scm_cell *)x)->car) == 5) {
#line 1407
    goto case_7;
  }
#line 1413
  if ((127 & (int )((scm_cell *)x)->car) == 4) {
#line 1413
    goto case_4;
  }
#line 1426
  if ((127 & (int )((scm_cell *)x)->car) == (int )(127L & ((long )((1 << 9) + (1 << 3)) + 4L))) {
#line 1426
    goto cdrxnoap;
  }
#line 1457
  if ((127 & (int )((scm_cell *)x)->car) == (int )(127L & ((long )((2 << 9) + (2 << 3)) + 4L))) {
#line 1457
    goto case_exp___0;
  }
#line 1484
  if ((127 & (int )((scm_cell *)x)->car) == (int )(127L & ((long )((3 << 9) + (3 << 3)) + 4L))) {
#line 1484
    goto case_exp___1;
  }
#line 1512
  if ((127 & (int )((scm_cell *)x)->car) == (int )(127L & ((long )((4 << 9) + (4 << 3)) + 4L))) {
#line 1512
    goto case_exp___2;
  }
#line 1541
  if ((127 & (int )((scm_cell *)x)->car) == (int )(127L & ((long )((5 << 9) + (5 << 3)) + 4L))) {
#line 1541
    goto case_exp___3;
  }
#line 1553
  if ((127 & (int )((scm_cell *)x)->car) == (int )(127L & ((long )((7 << 9) + (7 << 3)) + 4L))) {
#line 1553
    goto case_exp___4;
  }
#line 1567
  if ((127 & (int )((scm_cell *)x)->car) == (int )(127L & ((long )((9 << 9) + (9 << 3)) + 4L))) {
#line 1567
    goto case_exp___5;
  }
#line 1582
  if ((127 & (int )((scm_cell *)x)->car) == (int )(127L & ((long )((8 << 9) + (8 << 3)) + 4L))) {
#line 1582
    goto case_exp___6;
  }
#line 1599
  if ((127 & (int )((scm_cell *)x)->car) == (int )(127L & ((long )((10 << 9) + (10 << 3)) + 4L))) {
#line 1599
    goto case_exp___7;
  }
#line 1615
  if ((127 & (int )((scm_cell *)x)->car) == (int )(127L & ((long )((6 << 9) + (6 << 3)) + 4L))) {
#line 1615
    goto case_exp___8;
  }
#line 1619
  if ((127 & (int )((scm_cell *)x)->car) == (int )(127L & ((long )((11 << 9) + (11 << 3)) + 4L))) {
#line 1619
    goto case_exp___9;
  }
#line 1623
  if ((127 & (int )((scm_cell *)x)->car) == (int )(127L & ((long )((12 << 9) + (12 << 3)) + 4L))) {
#line 1623
    goto case_exp___10;
  }
#line 1649
  if ((127 & (int )((scm_cell *)x)->car) == (int )(127L & ((long )((13 << 9) + (13 << 3)) + 4L))) {
#line 1649
    goto case_exp___11;
  }
#line 1667
  if ((127 & (int )((scm_cell *)x)->car) == 116) {
#line 1667
    goto case_116;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 119) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 117) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 111) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 109) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 69) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 101) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 95) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 93) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 87) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 85) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 103) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 123) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 115) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 107) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 99) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 91) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 83) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 75) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 67) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 59) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 51) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 43) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 35) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 27) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 19) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 11) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 3) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 127) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 31) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 29) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 23) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 21) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 53) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 47) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 45) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 37) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 79) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 55) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 77) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 71) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 15) {
#line 1753
    goto case_119;
  }
#line 1753
  if ((127 & (int )((scm_cell *)x)->car) == 13) {
#line 1753
    goto case_119;
  }
#line 1757
  if ((127 & (int )((scm_cell *)x)->car) == 124) {
#line 1757
    goto case_124;
  }
#line 1769
  if ((127 & (int )((scm_cell *)x)->car) == 121) {
#line 1769
    goto case_121;
  }
#line 1769
  if ((127 & (int )((scm_cell *)x)->car) == 113) {
#line 1769
    goto case_121;
  }
#line 1769
  if ((127 & (int )((scm_cell *)x)->car) == 105) {
#line 1769
    goto case_121;
  }
#line 1769
  if ((127 & (int )((scm_cell *)x)->car) == 97) {
#line 1769
    goto case_121;
  }
#line 1769
  if ((127 & (int )((scm_cell *)x)->car) == 89) {
#line 1769
    goto case_121;
  }
#line 1769
  if ((127 & (int )((scm_cell *)x)->car) == 81) {
#line 1769
    goto case_121;
  }
#line 1769
  if ((127 & (int )((scm_cell *)x)->car) == 73) {
#line 1769
    goto case_121;
  }
#line 1769
  if ((127 & (int )((scm_cell *)x)->car) == 65) {
#line 1769
    goto case_121;
  }
#line 1769
  if ((127 & (int )((scm_cell *)x)->car) == 57) {
#line 1769
    goto case_121;
  }
#line 1769
  if ((127 & (int )((scm_cell *)x)->car) == 49) {
#line 1769
    goto case_121;
  }
#line 1769
  if ((127 & (int )((scm_cell *)x)->car) == 41) {
#line 1769
    goto case_121;
  }
#line 1769
  if ((127 & (int )((scm_cell *)x)->car) == 33) {
#line 1769
    goto case_121;
  }
#line 1769
  if ((127 & (int )((scm_cell *)x)->car) == 25) {
#line 1769
    goto case_121;
  }
#line 1769
  if ((127 & (int )((scm_cell *)x)->car) == 17) {
#line 1769
    goto case_121;
  }
#line 1769
  if ((127 & (int )((scm_cell *)x)->car) == 9) {
#line 1769
    goto case_121;
  }
#line 1769
  if ((127 & (int )((scm_cell *)x)->car) == 1) {
#line 1769
    goto case_121;
  }
#line 1780
  if ((127 & (int )((scm_cell *)x)->car) == 120) {
#line 1780
    goto case_120;
  }
#line 1780
  if ((127 & (int )((scm_cell *)x)->car) == 112) {
#line 1780
    goto case_120;
  }
#line 1780
  if ((127 & (int )((scm_cell *)x)->car) == 104) {
#line 1780
    goto case_120;
  }
#line 1780
  if ((127 & (int )((scm_cell *)x)->car) == 96) {
#line 1780
    goto case_120;
  }
#line 1780
  if ((127 & (int )((scm_cell *)x)->car) == 88) {
#line 1780
    goto case_120;
  }
#line 1780
  if ((127 & (int )((scm_cell *)x)->car) == 80) {
#line 1780
    goto case_120;
  }
#line 1780
  if ((127 & (int )((scm_cell *)x)->car) == 72) {
#line 1780
    goto case_120;
  }
#line 1780
  if ((127 & (int )((scm_cell *)x)->car) == 64) {
#line 1780
    goto case_120;
  }
#line 1780
  if ((127 & (int )((scm_cell *)x)->car) == 56) {
#line 1780
    goto case_120;
  }
#line 1780
  if ((127 & (int )((scm_cell *)x)->car) == 48) {
#line 1780
    goto case_120;
  }
#line 1780
  if ((127 & (int )((scm_cell *)x)->car) == 40) {
#line 1780
    goto case_120;
  }
#line 1780
  if ((127 & (int )((scm_cell *)x)->car) == 32) {
#line 1780
    goto case_120;
  }
#line 1780
  if ((127 & (int )((scm_cell *)x)->car) == 24) {
#line 1780
    goto case_120;
  }
#line 1780
  if ((127 & (int )((scm_cell *)x)->car) == 16) {
#line 1780
    goto case_120;
  }
#line 1780
  if ((127 & (int )((scm_cell *)x)->car) == 8) {
#line 1780
    goto case_120;
  }
#line 1780
  if ((127 & (int )((scm_cell *)x)->car) == 0) {
#line 1780
    goto case_120;
  }
#line 1727
  goto switch_default___0;
  case_7: /* CIL Label */ 
  case_5: /* CIL Label */ 
  {
#line 1410
  x = scm_cons(x, (long )(18 << 9) + 372L);
  }
#line 1411
  goto retval;
  case_4: /* CIL Label */ 
#line 1414
  x = ((scm_cell *)x)->cdr;
#line 1415
  t.arg1 = x;
  {
#line 1416
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1416
    t.arg1 = ((scm_cell *)t.arg1)->cdr;
#line 1416
    if (! ((long )(20 << 9) + 372L != t.arg1)) {
#line 1416
      goto while_break;
    }
#line 1417
    if ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )((scm_cell *)x)->car)) {
#line 1417
      if (6 & (int )((scm_cell *)x)->car) {
#line 1417
        if (((int )((scm_cell *)x)->car & 255) == 252) {
          {
#line 1417
          tmp___6 = scm_ilookup(((scm_cell *)x)->car, env);
#line 1417
          tmp___7 = *tmp___6;
          }
        } else {
#line 1417
          tmp___7 = ((scm_cell *)x)->car;
        }
#line 1417
        tmp___8 = tmp___7;
      } else {
#line 1417
        tmp___8 = ((scm_cell *)(((scm_cell *)x)->car - 1L))->cdr;
      }
#line 1417
      tmp___12 = tmp___8;
    } else {
#line 1417
      if ((125 & (int )((scm_cell *)((scm_cell *)x)->car)->car) == 5) {
        {
#line 1417
        tmp___9 = scm_lookupcar(x, env);
#line 1417
        tmp___11 = *tmp___9;
        }
      } else {
        {
#line 1417
        tmp___10 = scm_deval(((scm_cell *)x)->car, env);
#line 1417
        tmp___11 = tmp___10;
        }
      }
#line 1417
      tmp___12 = tmp___11;
    }
#line 1417
    if ((long )(16 << 9) + 372L == tmp___12) {
#line 1419
      proc = (long )(16 << 9) + 372L;
#line 1419
      goto exit;
    } else {
#line 1422
      x = t.arg1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1423
  (debug.info) ++;
#line 1423
  (debug.info)->a.proc = (long )(18 << 9) + 372L;
#line 1423
  (debug.info)->a.args = (long )(20 << 9) + 372L;
#line 1424
  goto carloop;
  cdrxnoap: 
  case_exp: /* CIL Label */ 
#line 1428
  (debug.info) ++;
#line 1428
  (debug.info)->a.proc = (long )(18 << 9) + 372L;
#line 1428
  (debug.info)->a.args = (long )(20 << 9) + 372L;
  cdrxbegin: 
#line 1430
  x = ((scm_cell *)x)->cdr;
  begin: 
#line 1433
  t.arg1 = x;
  {
#line 1434
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1434
    t.arg1 = ((scm_cell *)t.arg1)->cdr;
#line 1434
    if (! ((long )(20 << 9) + 372L != t.arg1)) {
#line 1434
      goto while_break___0;
    }
#line 1436
    if (! (6 & (int )((scm_cell *)x)->car)) {
      {
#line 1436
      scm_deval(((scm_cell *)x)->car, env);
      }
    }
#line 1437
    x = t.arg1;
  }
  while_break___0: /* CIL Label */ ;
  }
  carloop: 
#line 1441
  if ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )((scm_cell *)x)->car)) {
#line 1443
    x = ((scm_cell *)x)->car;
#line 1444
    if (6 & (int )x) {
#line 1444
      if (((int )x & 255) == 252) {
        {
#line 1444
        tmp___13 = scm_ilookup(x, env);
#line 1444
        tmp___14 = *tmp___13;
        }
      } else {
#line 1444
        tmp___14 = x;
      }
#line 1444
      proc = tmp___14;
    } else {
#line 1444
      proc = ((scm_cell *)(x - 1L))->cdr;
    }
#line 1444
    goto exit;
  }
#line 1447
  if ((125 & (int )((scm_cell *)((scm_cell *)x)->car)->car) == 5) {
    retval: 
    {
#line 1450
    tmp___15 = scm_lookupcar(x, env);
#line 1450
    proc = *tmp___15;
    }
#line 1450
    goto exit;
  }
#line 1453
  x = ((scm_cell *)x)->car;
#line 1454
  goto loop;
  case_exp___0: /* CIL Label */ 
#line 1458
  x = ((scm_cell *)x)->cdr;
#line 1459
  if ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )((scm_cell *)x)->car)) {
#line 1459
    if (6 & (int )((scm_cell *)x)->car) {
#line 1459
      if (((int )((scm_cell *)x)->car & 255) == 252) {
        {
#line 1459
        tmp___16 = scm_ilookup(((scm_cell *)x)->car, env);
#line 1459
        tmp___17 = *tmp___16;
        }
      } else {
#line 1459
        tmp___17 = ((scm_cell *)x)->car;
      }
#line 1459
      tmp___18 = tmp___17;
    } else {
#line 1459
      tmp___18 = ((scm_cell *)(((scm_cell *)x)->car - 1L))->cdr;
    }
#line 1459
    t.arg1 = tmp___18;
  } else {
#line 1459
    if ((125 & (int )((scm_cell *)((scm_cell *)x)->car)->car) == 5) {
      {
#line 1459
      tmp___19 = scm_lookupcar(x, env);
#line 1459
      tmp___21 = *tmp___19;
      }
    } else {
      {
#line 1459
      tmp___20 = scm_deval(((scm_cell *)x)->car, env);
#line 1459
      tmp___21 = tmp___20;
      }
    }
#line 1459
    t.arg1 = tmp___21;
  }
  {
#line 1460
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1460
    x = ((scm_cell *)x)->cdr;
#line 1460
    if (6 & (int )x) {
#line 1460
      goto while_break___1;
    }
#line 1462
    proc = ((scm_cell *)x)->car;
#line 1463
    if (scm_i_else == ((scm_cell *)proc)->car) {
#line 1465
      x = ((scm_cell *)proc)->cdr;
#line 1466
      (debug.info) ++;
#line 1466
      (debug.info)->a.proc = (long )(18 << 9) + 372L;
#line 1466
      (debug.info)->a.args = (long )(20 << 9) + 372L;
#line 1467
      goto begin;
    }
#line 1469
    proc = ((scm_cell *)proc)->car;
    {
#line 1470
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1470
      if (! (! (6 & (int )proc))) {
#line 1470
        goto while_break___2;
      }
#line 1472
      if (((scm_cell *)proc)->car == t.arg1) {
#line 1474
        x = ((scm_cell *)((scm_cell *)x)->car)->cdr;
#line 1475
        (debug.info) ++;
#line 1475
        (debug.info)->a.proc = (long )(18 << 9) + 372L;
#line 1475
        (debug.info)->a.args = (long )(20 << 9) + 372L;
#line 1476
        goto begin;
      } else {
        {
#line 1472
        tmp___22 = scm_eqv_p(((scm_cell *)proc)->car, t.arg1);
        }
#line 1472
        if ((long )(16 << 9) + 372L != tmp___22) {
#line 1474
          x = ((scm_cell *)((scm_cell *)x)->car)->cdr;
#line 1475
          (debug.info) ++;
#line 1475
          (debug.info)->a.proc = (long )(18 << 9) + 372L;
#line 1475
          (debug.info)->a.args = (long )(20 << 9) + 372L;
#line 1476
          goto begin;
        }
      }
#line 1478
      proc = ((scm_cell *)proc)->cdr;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1481
  proc = (long )(21 << 9) + 372L;
#line 1481
  goto exit;
  case_exp___1: /* CIL Label */ 
  {
#line 1485
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1485
    x = ((scm_cell *)x)->cdr;
#line 1485
    if (6 & (int )x) {
#line 1485
      goto while_break___3;
    }
#line 1487
    proc = ((scm_cell *)x)->car;
#line 1488
    if ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )((scm_cell *)proc)->car)) {
#line 1488
      if (6 & (int )((scm_cell *)proc)->car) {
#line 1488
        if (((int )((scm_cell *)proc)->car & 255) == 252) {
          {
#line 1488
          tmp___23 = scm_ilookup(((scm_cell *)proc)->car, env);
#line 1488
          tmp___24 = *tmp___23;
          }
        } else {
#line 1488
          tmp___24 = ((scm_cell *)proc)->car;
        }
#line 1488
        tmp___25 = tmp___24;
      } else {
#line 1488
        tmp___25 = ((scm_cell *)(((scm_cell *)proc)->car - 1L))->cdr;
      }
#line 1488
      t.arg1 = tmp___25;
    } else {
#line 1488
      if ((125 & (int )((scm_cell *)((scm_cell *)proc)->car)->car) == 5) {
        {
#line 1488
        tmp___26 = scm_lookupcar(proc, env);
#line 1488
        tmp___28 = *tmp___26;
        }
      } else {
        {
#line 1488
        tmp___27 = scm_deval(((scm_cell *)proc)->car, env);
#line 1488
        tmp___28 = tmp___27;
        }
      }
#line 1488
      t.arg1 = tmp___28;
    }
#line 1489
    if ((long )(16 << 9) + 372L != t.arg1) {
#line 1491
      x = ((scm_cell *)proc)->cdr;
#line 1492
      if ((long )(20 << 9) + 372L == x) {
#line 1494
        proc = t.arg1;
#line 1494
        goto exit;
      }
#line 1496
      if (scm_i_arrow != ((scm_cell *)x)->car) {
#line 1498
        (debug.info) ++;
#line 1498
        (debug.info)->a.proc = (long )(18 << 9) + 372L;
#line 1498
        (debug.info)->a.args = (long )(20 << 9) + 372L;
#line 1499
        goto begin;
      }
#line 1501
      proc = ((scm_cell *)x)->cdr;
#line 1502
      if ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )((scm_cell *)proc)->car)) {
#line 1502
        if (6 & (int )((scm_cell *)proc)->car) {
#line 1502
          if (((int )((scm_cell *)proc)->car & 255) == 252) {
            {
#line 1502
            tmp___29 = scm_ilookup(((scm_cell *)proc)->car, env);
#line 1502
            tmp___30 = *tmp___29;
            }
          } else {
#line 1502
            tmp___30 = ((scm_cell *)proc)->car;
          }
#line 1502
          tmp___31 = tmp___30;
        } else {
#line 1502
          tmp___31 = ((scm_cell *)(((scm_cell *)proc)->car - 1L))->cdr;
        }
#line 1502
        proc = tmp___31;
      } else {
#line 1502
        if ((125 & (int )((scm_cell *)((scm_cell *)proc)->car)->car) == 5) {
          {
#line 1502
          tmp___32 = scm_lookupcar(proc, env);
#line 1502
          tmp___34 = *tmp___32;
          }
        } else {
          {
#line 1502
          tmp___33 = scm_deval(((scm_cell *)proc)->car, env);
#line 1502
          tmp___34 = tmp___33;
          }
        }
#line 1502
        proc = tmp___34;
      }
#line 1503
      if (! (! (6 & (int )proc))) {
#line 1503
        goto badfun;
      }
      {
#line 1504
      (debug.info) ++;
#line 1504
      (debug.info)->a.proc = proc;
#line 1504
      (debug.info)->a.args = scm_cons(t.arg1, (long )(20 << 9) + 372L);
#line 1505
      debug.status |= 1L << 7;
      }
#line 1505
      if (scm_check_apply_p) {
#line 1505
        if (scm_evaluator_trap_table[1].val) {
#line 1505
          goto _L___0;
        } else
#line 1505
        if (scm_debug_opts[2].val) {
          {
#line 1505
          tmp___40 = scm_procedure_property(proc, scm_i_trace);
          }
#line 1505
          if ((long )(16 << 9) + 372L != tmp___40) {
            _L___0: /* CIL Label */ 
#line 1505
            if ((debug.status & (1L << 8)) != 0L) {
#line 1505
              tmp___36 = (long )(17 << 9) + 372L;
            } else {
#line 1505
              tmp___36 = (long )(16 << 9) + 372L;
            }
#line 1505
            tail___0 = tmp___36;
#line 1505
            debug.status |= 1L << 8;
#line 1505
            if (scm_debug_opts[0].val) {
              {
#line 1505
              tmp___35 = scm_make_debugobj(& debug);
#line 1505
              tmp___37 = scm_cons2(tmp___35, tail___0, (long )(20 << 9) + 372L);
#line 1505
              scm_ithrow(scm_i_apply_frame, tmp___37, 0);
              }
            } else {
              {
#line 1505
              scm_make_cont(& tmp___35);
#line 1505
              tmp___39 = _setjmp((struct __jmp_buf_tag *)(((scm_contregs *)((char *)((scm_cell *)tmp___35)->cdr))->jmpbuf));
              }
#line 1505
              if (! tmp___39) {
                {
#line 1505
                tmp___38 = scm_cons2(tmp___35, tail___0, (long )(20 << 9) + 372L);
#line 1505
                scm_ithrow(scm_i_apply_frame, tmp___38, 0);
                }
              }
            }
          }
        }
      }
#line 1506
      goto evap1;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1509
  proc = (long )(21 << 9) + 372L;
#line 1509
  goto exit;
  case_exp___2: /* CIL Label */ 
#line 1513
  x = ((scm_cell *)x)->cdr;
#line 1514
  proc = ((scm_cell *)((scm_cell *)x)->cdr)->car;
#line 1515
  t.arg1 = (long )(20 << 9) + 372L;
  {
#line 1516
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1516
    if (! (! (6 & (int )proc))) {
#line 1516
      goto while_break___4;
    }
#line 1518
    if ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )((scm_cell *)proc)->car)) {
#line 1518
      if (6 & (int )((scm_cell *)proc)->car) {
#line 1518
        if (((int )((scm_cell *)proc)->car & 255) == 252) {
          {
#line 1518
          tmp___41 = scm_ilookup(((scm_cell *)proc)->car, env);
#line 1518
          tmp___42 = *tmp___41;
          }
        } else {
#line 1518
          tmp___42 = ((scm_cell *)proc)->car;
        }
#line 1518
        tmp___43 = tmp___42;
      } else {
#line 1518
        tmp___43 = ((scm_cell *)(((scm_cell *)proc)->car - 1L))->cdr;
      }
#line 1518
      tmp___47 = tmp___43;
    } else {
#line 1518
      if ((125 & (int )((scm_cell *)((scm_cell *)proc)->car)->car) == 5) {
        {
#line 1518
        tmp___44 = scm_lookupcar(proc, env);
#line 1518
        tmp___46 = *tmp___44;
        }
      } else {
        {
#line 1518
        tmp___45 = scm_deval(((scm_cell *)proc)->car, env);
#line 1518
        tmp___46 = tmp___45;
        }
      }
#line 1518
      tmp___47 = tmp___46;
    }
    {
#line 1518
    t.arg1 = scm_cons(tmp___47, t.arg1);
#line 1519
    proc = ((scm_cell *)proc)->cdr;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 1521
  env = scm_acons(((scm_cell *)x)->car, t.arg1, env);
#line 1522
  x = ((scm_cell *)((scm_cell *)x)->cdr)->cdr;
  }
  {
#line 1523
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1523
    proc = ((scm_cell *)x)->car;
#line 1523
    if ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )((scm_cell *)proc)->car)) {
#line 1523
      if (6 & (int )((scm_cell *)proc)->car) {
#line 1523
        if (((int )((scm_cell *)proc)->car & 255) == 252) {
          {
#line 1523
          tmp___55 = scm_ilookup(((scm_cell *)proc)->car, env);
#line 1523
          tmp___56 = *tmp___55;
          }
        } else {
#line 1523
          tmp___56 = ((scm_cell *)proc)->car;
        }
#line 1523
        tmp___57 = tmp___56;
      } else {
#line 1523
        tmp___57 = ((scm_cell *)(((scm_cell *)proc)->car - 1L))->cdr;
      }
#line 1523
      tmp___61 = tmp___57;
    } else {
#line 1523
      if ((125 & (int )((scm_cell *)((scm_cell *)proc)->car)->car) == 5) {
        {
#line 1523
        tmp___58 = scm_lookupcar(proc, env);
#line 1523
        tmp___60 = *tmp___58;
        }
      } else {
        {
#line 1523
        tmp___59 = scm_deval(((scm_cell *)proc)->car, env);
#line 1523
        tmp___60 = tmp___59;
        }
      }
#line 1523
      tmp___61 = tmp___60;
    }
#line 1523
    if (! ((long )(16 << 9) + 372L == tmp___61)) {
#line 1523
      goto while_break___5;
    }
#line 1525
    proc = ((scm_cell *)((scm_cell *)x)->cdr)->car;
    {
#line 1525
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1525
      if (! (! (6 & (int )proc))) {
#line 1525
        goto while_break___6;
      }
#line 1527
      t.arg1 = ((scm_cell *)proc)->car;
#line 1528
      if (! (6 & (int )t.arg1)) {
        {
#line 1528
        scm_deval(t.arg1, env);
        }
      }
#line 1525
      proc = ((scm_cell *)proc)->cdr;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 1530
    t.arg1 = (long )(20 << 9) + 372L;
#line 1530
    proc = ((scm_cell *)((scm_cell *)x)->cdr)->cdr;
    {
#line 1530
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1530
      if (! (! (6 & (int )proc))) {
#line 1530
        goto while_break___7;
      }
#line 1531
      if ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )((scm_cell *)proc)->car)) {
#line 1531
        if (6 & (int )((scm_cell *)proc)->car) {
#line 1531
          if (((int )((scm_cell *)proc)->car & 255) == 252) {
            {
#line 1531
            tmp___48 = scm_ilookup(((scm_cell *)proc)->car, env);
#line 1531
            tmp___49 = *tmp___48;
            }
          } else {
#line 1531
            tmp___49 = ((scm_cell *)proc)->car;
          }
#line 1531
          tmp___50 = tmp___49;
        } else {
#line 1531
          tmp___50 = ((scm_cell *)(((scm_cell *)proc)->car - 1L))->cdr;
        }
#line 1531
        tmp___54 = tmp___50;
      } else {
#line 1531
        if ((125 & (int )((scm_cell *)((scm_cell *)proc)->car)->car) == 5) {
          {
#line 1531
          tmp___51 = scm_lookupcar(proc, env);
#line 1531
          tmp___53 = *tmp___51;
          }
        } else {
          {
#line 1531
          tmp___52 = scm_deval(((scm_cell *)proc)->car, env);
#line 1531
          tmp___53 = tmp___52;
          }
        }
#line 1531
        tmp___54 = tmp___53;
      }
      {
#line 1531
      t.arg1 = scm_cons(tmp___54, t.arg1);
#line 1530
      proc = ((scm_cell *)proc)->cdr;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 1532
    env = scm_acons(((scm_cell *)((scm_cell *)env)->car)->car, t.arg1, ((scm_cell *)env)->cdr);
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 1534
  x = ((scm_cell *)proc)->cdr;
#line 1535
  if ((long )(20 << 9) + 372L == x) {
#line 1536
    proc = (long )(21 << 9) + 372L;
#line 1536
    goto exit;
  }
#line 1537
  (debug.info) ++;
#line 1537
  (debug.info)->a.proc = (long )(18 << 9) + 372L;
#line 1537
  (debug.info)->a.args = (long )(20 << 9) + 372L;
#line 1538
  goto begin;
  case_exp___3: /* CIL Label */ 
#line 1542
  x = ((scm_cell *)x)->cdr;
#line 1543
  if ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )((scm_cell *)x)->car)) {
#line 1543
    if (6 & (int )((scm_cell *)x)->car) {
#line 1543
      if (((int )((scm_cell *)x)->car & 255) == 252) {
        {
#line 1543
        tmp___62 = scm_ilookup(((scm_cell *)x)->car, env);
#line 1543
        tmp___63 = *tmp___62;
        }
      } else {
#line 1543
        tmp___63 = ((scm_cell *)x)->car;
      }
#line 1543
      tmp___64 = tmp___63;
    } else {
#line 1543
      tmp___64 = ((scm_cell *)(((scm_cell *)x)->car - 1L))->cdr;
    }
#line 1543
    tmp___68 = tmp___64;
  } else {
#line 1543
    if ((125 & (int )((scm_cell *)((scm_cell *)x)->car)->car) == 5) {
      {
#line 1543
      tmp___65 = scm_lookupcar(x, env);
#line 1543
      tmp___67 = *tmp___65;
      }
    } else {
      {
#line 1543
      tmp___66 = scm_deval(((scm_cell *)x)->car, env);
#line 1543
      tmp___67 = tmp___66;
      }
    }
#line 1543
    tmp___68 = tmp___67;
  }
#line 1543
  if ((long )(16 << 9) + 372L != tmp___68) {
#line 1544
    x = ((scm_cell *)x)->cdr;
  } else {
#line 1545
    x = ((scm_cell *)((scm_cell *)x)->cdr)->cdr;
#line 1545
    if (6 & (int )x) {
#line 1547
      proc = (long )(21 << 9) + 372L;
#line 1547
      goto exit;
    }
  }
#line 1549
  (debug.info) ++;
#line 1549
  (debug.info)->a.proc = (long )(18 << 9) + 372L;
#line 1549
  (debug.info)->a.args = (long )(20 << 9) + 372L;
#line 1550
  goto carloop;
  case_exp___4: /* CIL Label */ 
#line 1554
  x = ((scm_cell *)x)->cdr;
#line 1555
  proc = ((scm_cell *)((scm_cell *)x)->cdr)->car;
#line 1556
  t.arg1 = (long )(20 << 9) + 372L;
  {
#line 1557
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 1559
    if ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )((scm_cell *)proc)->car)) {
#line 1559
      if (6 & (int )((scm_cell *)proc)->car) {
#line 1559
        if (((int )((scm_cell *)proc)->car & 255) == 252) {
          {
#line 1559
          tmp___69 = scm_ilookup(((scm_cell *)proc)->car, env);
#line 1559
          tmp___70 = *tmp___69;
          }
        } else {
#line 1559
          tmp___70 = ((scm_cell *)proc)->car;
        }
#line 1559
        tmp___71 = tmp___70;
      } else {
#line 1559
        tmp___71 = ((scm_cell *)(((scm_cell *)proc)->car - 1L))->cdr;
      }
#line 1559
      tmp___75 = tmp___71;
    } else {
#line 1559
      if ((125 & (int )((scm_cell *)((scm_cell *)proc)->car)->car) == 5) {
        {
#line 1559
        tmp___72 = scm_lookupcar(proc, env);
#line 1559
        tmp___74 = *tmp___72;
        }
      } else {
        {
#line 1559
        tmp___73 = scm_deval(((scm_cell *)proc)->car, env);
#line 1559
        tmp___74 = tmp___73;
        }
      }
#line 1559
      tmp___75 = tmp___74;
    }
    {
#line 1559
    t.arg1 = scm_cons(tmp___75, t.arg1);
#line 1557
    proc = ((scm_cell *)proc)->cdr;
    }
#line 1557
    if (6 & (int )proc) {
#line 1557
      goto while_break___8;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 1562
  env = scm_acons(((scm_cell *)x)->car, t.arg1, env);
#line 1563
  x = ((scm_cell *)x)->cdr;
  }
#line 1564
  goto cdrxnoap;
  case_exp___5: /* CIL Label */ 
  {
#line 1568
  x = ((scm_cell *)x)->cdr;
#line 1569
  env = scm_acons(((scm_cell *)x)->car, scm_sys_protects[2], env);
#line 1570
  x = ((scm_cell *)x)->cdr;
#line 1571
  proc = ((scm_cell *)x)->car;
#line 1572
  t.arg1 = (long )(20 << 9) + 372L;
  }
  {
#line 1573
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 1575
    if ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )((scm_cell *)proc)->car)) {
#line 1575
      if (6 & (int )((scm_cell *)proc)->car) {
#line 1575
        if (((int )((scm_cell *)proc)->car & 255) == 252) {
          {
#line 1575
          tmp___76 = scm_ilookup(((scm_cell *)proc)->car, env);
#line 1575
          tmp___77 = *tmp___76;
          }
        } else {
#line 1575
          tmp___77 = ((scm_cell *)proc)->car;
        }
#line 1575
        tmp___78 = tmp___77;
      } else {
#line 1575
        tmp___78 = ((scm_cell *)(((scm_cell *)proc)->car - 1L))->cdr;
      }
#line 1575
      tmp___82 = tmp___78;
    } else {
#line 1575
      if ((125 & (int )((scm_cell *)((scm_cell *)proc)->car)->car) == 5) {
        {
#line 1575
        tmp___79 = scm_lookupcar(proc, env);
#line 1575
        tmp___81 = *tmp___79;
        }
      } else {
        {
#line 1575
        tmp___80 = scm_deval(((scm_cell *)proc)->car, env);
#line 1575
        tmp___81 = tmp___80;
        }
      }
#line 1575
      tmp___82 = tmp___81;
    }
    {
#line 1575
    t.arg1 = scm_cons(tmp___82, t.arg1);
#line 1573
    proc = ((scm_cell *)proc)->cdr;
    }
#line 1573
    if (6 & (int )proc) {
#line 1573
      goto while_break___9;
    }
  }
  while_break___9: /* CIL Label */ ;
  }
#line 1578
  ((scm_cell *)((scm_cell *)env)->car)->cdr = t.arg1;
#line 1579
  goto cdrxnoap;
  case_exp___6: /* CIL Label */ 
#line 1583
  x = ((scm_cell *)x)->cdr;
#line 1584
  proc = ((scm_cell *)x)->car;
#line 1585
  if (6 & (int )proc) {
    {
#line 1587
    env = scm_acons((long )(20 << 9) + 372L, (long )(20 << 9) + 372L, env);
    }
#line 1588
    goto cdrxnoap;
  }
  {
#line 1590
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 1592
    t.arg1 = ((scm_cell *)proc)->car;
#line 1593
    proc = ((scm_cell *)proc)->cdr;
#line 1594
    if ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )((scm_cell *)proc)->car)) {
#line 1594
      if (6 & (int )((scm_cell *)proc)->car) {
#line 1594
        if (((int )((scm_cell *)proc)->car & 255) == 252) {
          {
#line 1594
          tmp___83 = scm_ilookup(((scm_cell *)proc)->car, env);
#line 1594
          tmp___84 = *tmp___83;
          }
        } else {
#line 1594
          tmp___84 = ((scm_cell *)proc)->car;
        }
#line 1594
        tmp___85 = tmp___84;
      } else {
#line 1594
        tmp___85 = ((scm_cell *)(((scm_cell *)proc)->car - 1L))->cdr;
      }
#line 1594
      tmp___89 = tmp___85;
    } else {
#line 1594
      if ((125 & (int )((scm_cell *)((scm_cell *)proc)->car)->car) == 5) {
        {
#line 1594
        tmp___86 = scm_lookupcar(proc, env);
#line 1594
        tmp___88 = *tmp___86;
        }
      } else {
        {
#line 1594
        tmp___87 = scm_deval(((scm_cell *)proc)->car, env);
#line 1594
        tmp___88 = tmp___87;
        }
      }
#line 1594
      tmp___89 = tmp___88;
    }
    {
#line 1594
    env = scm_acons(t.arg1, tmp___89, env);
#line 1590
    proc = ((scm_cell *)proc)->cdr;
    }
#line 1590
    if (6 & (int )proc) {
#line 1590
      goto while_break___10;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
#line 1597
  goto cdrxnoap;
  case_exp___7: /* CIL Label */ 
#line 1600
  x = ((scm_cell *)x)->cdr;
#line 1601
  t.arg1 = x;
  {
#line 1602
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 1602
    t.arg1 = ((scm_cell *)t.arg1)->cdr;
#line 1602
    if (! ((long )(20 << 9) + 372L != t.arg1)) {
#line 1602
      goto while_break___11;
    }
#line 1604
    if ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )((scm_cell *)x)->car)) {
#line 1604
      if (6 & (int )((scm_cell *)x)->car) {
#line 1604
        if (((int )((scm_cell *)x)->car & 255) == 252) {
          {
#line 1604
          tmp___90 = scm_ilookup(((scm_cell *)x)->car, env);
#line 1604
          tmp___91 = *tmp___90;
          }
        } else {
#line 1604
          tmp___91 = ((scm_cell *)x)->car;
        }
#line 1604
        tmp___92 = tmp___91;
      } else {
#line 1604
        tmp___92 = ((scm_cell *)(((scm_cell *)x)->car - 1L))->cdr;
      }
#line 1604
      x = tmp___92;
    } else {
#line 1604
      if ((125 & (int )((scm_cell *)((scm_cell *)x)->car)->car) == 5) {
        {
#line 1604
        tmp___93 = scm_lookupcar(x, env);
#line 1604
        tmp___95 = *tmp___93;
        }
      } else {
        {
#line 1604
        tmp___94 = scm_deval(((scm_cell *)x)->car, env);
#line 1604
        tmp___95 = tmp___94;
        }
      }
#line 1604
      x = tmp___95;
    }
#line 1605
    if ((long )(16 << 9) + 372L != x) {
#line 1607
      proc = x;
#line 1607
      goto exit;
    }
#line 1609
    x = t.arg1;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 1611
  (debug.info) ++;
#line 1611
  (debug.info)->a.proc = (long )(18 << 9) + 372L;
#line 1611
  (debug.info)->a.args = (long )(20 << 9) + 372L;
#line 1612
  goto carloop;
  case_exp___8: /* CIL Label */ 
  {
#line 1616
  proc = scm_closure(((scm_cell *)x)->cdr, env);
  }
#line 1616
  goto exit;
  case_exp___9: /* CIL Label */ 
#line 1620
  proc = ((scm_cell *)((scm_cell *)x)->cdr)->car;
#line 1620
  goto exit;
  case_exp___10: /* CIL Label */ 
#line 1624
  x = ((scm_cell *)x)->cdr;
#line 1625
  proc = ((scm_cell *)x)->car;
  {
#line 1628
  if ((7 & (int )proc) == 0) {
#line 1628
    goto case_0;
  }
#line 1631
  if ((7 & (int )proc) == 1) {
#line 1631
    goto case_1;
  }
#line 1635
  if ((7 & (int )proc) == 4) {
#line 1635
    goto case_4___0;
  }
#line 1626
  goto switch_break___0;
  case_0: /* CIL Label */ 
  {
#line 1629
  t.lloc = scm_lookupcar(x, env);
  }
#line 1630
  goto switch_break___0;
  case_1: /* CIL Label */ 
#line 1632
  t.lloc = & ((scm_cell *)(proc - 1L))->cdr;
#line 1633
  goto switch_break___0;
  case_4___0: /* CIL Label */ 
  {
#line 1636
  t.lloc = scm_ilookup(proc, env);
  }
#line 1637
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1640
  x = ((scm_cell *)x)->cdr;
#line 1641
  if ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )((scm_cell *)x)->car)) {
#line 1641
    if (6 & (int )((scm_cell *)x)->car) {
#line 1641
      if (((int )((scm_cell *)x)->car & 255) == 252) {
        {
#line 1641
        tmp___96 = scm_ilookup(((scm_cell *)x)->car, env);
#line 1641
        tmp___97 = *tmp___96;
        }
      } else {
#line 1641
        tmp___97 = ((scm_cell *)x)->car;
      }
#line 1641
      tmp___98 = tmp___97;
    } else {
#line 1641
      tmp___98 = ((scm_cell *)(((scm_cell *)x)->car - 1L))->cdr;
    }
#line 1641
    *(t.lloc) = tmp___98;
  } else {
#line 1641
    if ((125 & (int )((scm_cell *)((scm_cell *)x)->car)->car) == 5) {
      {
#line 1641
      tmp___99 = scm_lookupcar(x, env);
#line 1641
      tmp___101 = *tmp___99;
      }
    } else {
      {
#line 1641
      tmp___100 = scm_deval(((scm_cell *)x)->car, env);
#line 1641
      tmp___101 = tmp___100;
      }
    }
#line 1641
    *(t.lloc) = tmp___101;
  }
#line 1645
  proc = (long )(21 << 9) + 372L;
#line 1645
  goto exit;
  case_exp___11: /* CIL Label */ 
  {
#line 1650
  x = ((scm_cell *)x)->cdr;
#line 1651
  proc = ((scm_cell *)x)->car;
#line 1652
  x = ((scm_cell *)x)->cdr;
#line 1653
  x = scm_eval_car(x, env);
  }
#line 1655
  if (scm_debug_opts[3].val) {
#line 1655
    if (! (6 & (int )x)) {
#line 1655
      if ((7 & (int )((scm_cell *)x)->car) == 3) {
        {
#line 1656
        scm_set_procedure_property_x(x, scm_i_name, proc);
        }
      }
    }
  }
  {
#line 1658
  env = ((scm_cell *)env)->car;
#line 1659
  scm_ints_disabled = 1;
#line 1660
  tmp___102 = scm_cons(proc, ((scm_cell *)env)->car);
#line 1660
  ((scm_cell *)env)->car = tmp___102;
#line 1661
  tmp___103 = scm_cons(x, ((scm_cell *)env)->cdr);
#line 1661
  ((scm_cell *)env)->cdr = tmp___103;
#line 1662
  scm_ints_disabled = 0;
#line 1662
  scm_async_clock --;
  }
#line 1662
  if (0U == scm_async_clock) {
    {
#line 1662
    scm_async_click();
    }
  }
#line 1663
  proc = (long )(21 << 9) + 372L;
#line 1663
  goto exit;
  case_116: /* CIL Label */ 
#line 1668
  proc = ((scm_cell *)x)->car;
#line 1669
  if (! ((391 & (int )proc) == 4)) {
#line 1669
    goto badfun;
  }
  {
#line 1685
  if ((int )(proc >> 9) == (int )(((long )(14 << 9) + 116L) >> 9)) {
#line 1685
    goto case_exp___12;
  }
#line 1708
  if ((int )(proc >> 9) == (int )(((long )(15 << 9) + 116L) >> 9)) {
#line 1708
    goto case_exp___13;
  }
#line 1723
  goto switch_default;
  case_exp___12: /* CIL Label */ 
#line 1686
  proc = ((scm_cell *)x)->cdr;
#line 1687
  if ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )((scm_cell *)proc)->car)) {
#line 1687
    if (6 & (int )((scm_cell *)proc)->car) {
#line 1687
      if (((int )((scm_cell *)proc)->car & 255) == 252) {
        {
#line 1687
        tmp___104 = scm_ilookup(((scm_cell *)proc)->car, env);
#line 1687
        tmp___105 = *tmp___104;
        }
      } else {
#line 1687
        tmp___105 = ((scm_cell *)proc)->car;
      }
#line 1687
      tmp___106 = tmp___105;
    } else {
#line 1687
      tmp___106 = ((scm_cell *)(((scm_cell *)proc)->car - 1L))->cdr;
    }
#line 1687
    proc = tmp___106;
  } else {
#line 1687
    if ((125 & (int )((scm_cell *)((scm_cell *)proc)->car)->car) == 5) {
      {
#line 1687
      tmp___107 = scm_lookupcar(proc, env);
#line 1687
      tmp___109 = *tmp___107;
      }
    } else {
      {
#line 1687
      tmp___108 = scm_deval(((scm_cell *)proc)->car, env);
#line 1687
      tmp___109 = tmp___108;
      }
    }
#line 1687
    proc = tmp___109;
  }
#line 1688
  if (! (! (6 & (int )proc))) {
#line 1688
    goto badfun;
  }
#line 1689
  if ((7 & (int )((scm_cell *)proc)->car) == 3) {
#line 1691
    (debug.info) ++;
#line 1691
    (debug.info)->a.proc = proc;
#line 1691
    (debug.info)->a.args = (long )(20 << 9) + 372L;
#line 1692
    t.arg1 = ((scm_cell *)((scm_cell *)x)->cdr)->cdr;
#line 1693
    if ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )((scm_cell *)t.arg1)->car)) {
#line 1693
      if (6 & (int )((scm_cell *)t.arg1)->car) {
#line 1693
        if (((int )((scm_cell *)t.arg1)->car & 255) == 252) {
          {
#line 1693
          tmp___110 = scm_ilookup(((scm_cell *)t.arg1)->car, env);
#line 1693
          tmp___111 = *tmp___110;
          }
        } else {
#line 1693
          tmp___111 = ((scm_cell *)t.arg1)->car;
        }
#line 1693
        tmp___112 = tmp___111;
      } else {
#line 1693
        tmp___112 = ((scm_cell *)(((scm_cell *)t.arg1)->car - 1L))->cdr;
      }
#line 1693
      t.arg1 = tmp___112;
    } else {
#line 1693
      if ((125 & (int )((scm_cell *)((scm_cell *)t.arg1)->car)->car) == 5) {
        {
#line 1693
        tmp___113 = scm_lookupcar(t.arg1, env);
#line 1693
        tmp___115 = *tmp___113;
        }
      } else {
        {
#line 1693
        tmp___114 = scm_deval(((scm_cell *)t.arg1)->car, env);
#line 1693
        tmp___115 = tmp___114;
        }
      }
#line 1693
      t.arg1 = tmp___115;
    }
    {
#line 1695
    (debug.info)->a.args = t.arg1;
#line 1698
    tmp___116 = scm_badargsp(((scm_cell *)((scm_cell *)(((scm_cell *)proc)->car - 3L))->car)->car,
                             t.arg1);
    }
#line 1698
    if (tmp___116) {
#line 1699
      goto wrongnumargs;
    }
    {
#line 1701
    env = scm_acons(((scm_cell *)((scm_cell *)(((scm_cell *)proc)->car - 3L))->car)->car,
                    t.arg1, ((scm_cell *)proc)->cdr);
#line 1702
    x = ((scm_cell *)(((scm_cell *)proc)->car - 3L))->car;
    }
#line 1703
    goto cdrxbegin;
  }
#line 1705
  proc = scm_i_apply;
#line 1706
  goto evapply;
  case_exp___13: /* CIL Label */ 
  {
#line 1709
  scm_make_cont(& t.arg1);
#line 1710
  tmp___117 = _setjmp((struct __jmp_buf_tag *)(((scm_contregs *)((char *)((scm_cell *)t.arg1)->cdr))->jmpbuf));
  }
#line 1710
  if (tmp___117) {
#line 1713
    val = ((scm_contregs *)((char *)((scm_cell *)t.arg1)->cdr))->throw_value;
#line 1714
    proc = val;
#line 1714
    goto exit;
  }
  {
#line 1716
  proc = ((scm_cell *)x)->cdr;
#line 1717
  proc = scm_eval_car(proc, env);
  }
#line 1718
  if (! (! (6 & (int )proc))) {
#line 1718
    goto badfun;
  }
  {
#line 1719
  (debug.info) ++;
#line 1719
  (debug.info)->a.proc = proc;
#line 1719
  (debug.info)->a.args = scm_cons(t.arg1, (long )(20 << 9) + 372L);
#line 1720
  debug.status |= 1L << 7;
  }
#line 1720
  if (scm_check_apply_p) {
#line 1720
    if (scm_evaluator_trap_table[1].val) {
#line 1720
      goto _L___1;
    } else
#line 1720
    if (scm_debug_opts[2].val) {
      {
#line 1720
      tmp___123 = scm_procedure_property(proc, scm_i_trace);
      }
#line 1720
      if ((long )(16 << 9) + 372L != tmp___123) {
        _L___1: /* CIL Label */ 
#line 1720
        if ((debug.status & (1L << 8)) != 0L) {
#line 1720
          tmp___119 = (long )(17 << 9) + 372L;
        } else {
#line 1720
          tmp___119 = (long )(16 << 9) + 372L;
        }
#line 1720
        tail___1 = tmp___119;
#line 1720
        debug.status |= 1L << 8;
#line 1720
        if (scm_debug_opts[0].val) {
          {
#line 1720
          tmp___118 = scm_make_debugobj(& debug);
#line 1720
          tmp___120 = scm_cons2(tmp___118, tail___1, (long )(20 << 9) + 372L);
#line 1720
          scm_ithrow(scm_i_apply_frame, tmp___120, 0);
          }
        } else {
          {
#line 1720
          scm_make_cont(& tmp___118);
#line 1720
          tmp___122 = _setjmp((struct __jmp_buf_tag *)(((scm_contregs *)((char *)((scm_cell *)tmp___118)->cdr))->jmpbuf));
          }
#line 1720
          if (! tmp___122) {
            {
#line 1720
            tmp___121 = scm_cons2(tmp___118, tail___1, (long )(20 << 9) + 372L);
#line 1720
            scm_ithrow(scm_i_apply_frame, tmp___121, 0);
            }
          }
        }
      }
    }
  }
#line 1721
  goto evap1;
  switch_default: /* CIL Label */ 
#line 1724
  goto badfun;
  switch_break___1: /* CIL Label */ ;
  }
  switch_default___0: /* CIL Label */ 
#line 1728
  proc = x;
  badfun: 
  {
#line 1731
  tmp___124 = scm_listify(proc, (long )(18 << 9) + 372L);
#line 1731
  scm_misc_error((char *)((void *)0), (char *)"Wrong type to apply: %S", tmp___124);
  }
  case_119: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_95: /* CIL Label */ 
  case_93: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_123: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_91: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_59: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_35: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_19: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_127: /* CIL Label */ 
  case_31: /* CIL Label */ 
  case_29: /* CIL Label */ 
  case_23: /* CIL Label */ 
  case_21: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_15: /* CIL Label */ 
  case_13: /* CIL Label */ 
#line 1754
  proc = x;
#line 1754
  goto exit;
  case_124: /* CIL Label */ 
  {
#line 1758
  tmp___125 = scm_ilookup(((scm_cell *)x)->car, env);
#line 1758
  proc = *tmp___125;
  }
#line 1759
  if (! (! (6 & (int )proc))) {
#line 1759
    goto badfun;
  }
#line 1762
  goto checkargs;
#line 1765
  goto switch_break;
  case_121: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_97: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_65: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_25: /* CIL Label */ 
  case_17: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_1___0: /* CIL Label */ 
#line 1770
  proc = ((scm_cell *)(((scm_cell *)x)->car - 1L))->cdr;
#line 1771
  if (! (! (6 & (int )proc))) {
#line 1771
    goto badfun;
  }
#line 1774
  goto checkargs;
#line 1777
  goto switch_break;
  case_120: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_96: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_64: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_48: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_32: /* CIL Label */ 
  case_24: /* CIL Label */ 
  case_16: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_0___0: /* CIL Label */ 
#line 1781
  if ((125 & (int )((scm_cell *)((scm_cell *)x)->car)->car) == 5) {
    {
#line 1783
    tmp___126 = scm_lookupcar(x, env);
#line 1783
    proc = *tmp___126;
    }
#line 1784
    if (6 & (int )proc) {
      {
#line 1786
      scm_unmemocar(x, env);
      }
#line 1787
      goto badfun;
    }
#line 1789
    if (scm_tc16_macro == (long )(65535 & (int )((scm_cell *)proc)->car)) {
      {
#line 1791
      scm_unmemocar(x, env);
      }
      handle_a_macro: 
      {
#line 1794
      tmp___127 = scm_cons(env, scm_sys_protects[1]);
#line 1794
      t.arg1 = scm_dapply(((scm_cell *)proc)->cdr, x, tmp___127);
      }
      {
#line 1797
      if ((int )(((scm_cell *)proc)->car >> 16) == 2) {
#line 1797
        goto case_2;
      }
#line 1828
      if ((int )(((scm_cell *)proc)->car >> 16) == 1) {
#line 1828
        goto case_1___1;
      }
#line 1831
      if ((int )(((scm_cell *)proc)->car >> 16) == 0) {
#line 1831
        goto case_0___1;
      }
#line 1795
      goto switch_break___2;
      case_2: /* CIL Label */ 
      {
#line 1798
      tmp___128 = scm_ilength(t.arg1);
      }
#line 1798
      if (tmp___128 <= 0L) {
        {
#line 1799
        t.arg1 = scm_cons2((long )((1 << 9) + (1 << 3)) + 4L, t.arg1, (long )(20 << 9) + 372L);
        }
      }
#line 1801
      if (! ((7 & (int )((scm_cell *)((scm_cell *)proc)->cdr)->car) == 3)) {
#line 1812
        scm_ints_disabled = 1;
#line 1813
        ((scm_cell *)x)->car = ((scm_cell *)t.arg1)->car;
#line 1814
        ((scm_cell *)x)->cdr = ((scm_cell *)t.arg1)->cdr;
#line 1815
        scm_ints_disabled = 0;
#line 1815
        scm_async_clock --;
#line 1815
        if (0U == scm_async_clock) {
          {
#line 1815
          scm_async_click();
          }
        }
#line 1816
        goto dispatch;
      }
      {
#line 1819
      (debug.info)->e.exp = scm_cons(((scm_cell *)x)->car, ((scm_cell *)x)->cdr);
#line 1820
      tmp___129 = scm_source_properties(x);
#line 1820
      scm_set_source_properties_x((debug.info)->e.exp, tmp___129);
#line 1823
      scm_ints_disabled = 1;
#line 1824
      ((scm_cell *)x)->car = ((scm_cell *)t.arg1)->car;
#line 1825
      ((scm_cell *)x)->cdr = ((scm_cell *)t.arg1)->cdr;
#line 1826
      scm_ints_disabled = 0;
#line 1826
      scm_async_clock --;
      }
#line 1826
      if (0U == scm_async_clock) {
        {
#line 1826
        scm_async_click();
        }
      }
#line 1827
      goto loopnoap;
      case_1___1: /* CIL Label */ 
#line 1829
      x = t.arg1;
#line 1829
      if (! (6 & (int )x)) {
#line 1830
        goto loopnoap;
      }
      case_0___1: /* CIL Label */ 
#line 1832
      proc = t.arg1;
#line 1832
      goto exit;
      switch_break___2: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 1837
    proc = scm_deval(((scm_cell *)x)->car, env);
    }
  }
#line 1838
  if (! (! (6 & (int )proc))) {
#line 1838
    goto badfun;
  }
  checkargs: 
#line 1843
  if ((7 & (int )((scm_cell *)proc)->car) == 3) {
#line 1845
    arg2 = ((scm_cell *)((scm_cell *)(((scm_cell *)proc)->car - 3L))->car)->car;
#line 1846
    t.arg1 = ((scm_cell *)x)->cdr;
    {
#line 1847
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 1847
      if (! (! (6 & (int )arg2))) {
#line 1847
        goto while_break___12;
      }
#line 1849
      if (1 & (int )((scm_cell *)arg2)->car) {
#line 1850
        goto evapply;
      }
#line 1851
      if (6 & (int )t.arg1) {
#line 1852
        goto umwrongnumargs;
      }
#line 1853
      arg2 = ((scm_cell *)arg2)->cdr;
#line 1854
      t.arg1 = ((scm_cell *)t.arg1)->cdr;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 1856
    if ((long )(20 << 9) + 372L != t.arg1) {
#line 1857
      goto umwrongnumargs;
    }
  } else
#line 1859
  if (scm_tc16_macro == (long )(65535 & (int )((scm_cell *)proc)->car)) {
#line 1860
    goto handle_a_macro;
  }
  switch_break: /* CIL Label */ ;
  }
  evapply: 
#line 1866
  (debug.info) ++;
#line 1866
  (debug.info)->a.proc = proc;
#line 1866
  (debug.info)->a.args = (long )(20 << 9) + 372L;
#line 1867
  if ((long )(20 << 9) + 372L == ((scm_cell *)x)->cdr) {
#line 1868
    debug.status |= 1L << 7;
#line 1868
    if (scm_check_apply_p) {
#line 1868
      if (scm_evaluator_trap_table[1].val) {
#line 1868
        goto _L___2;
      } else
#line 1868
      if (scm_debug_opts[2].val) {
        {
#line 1868
        tmp___135 = scm_procedure_property(proc, scm_i_trace);
        }
#line 1868
        if ((long )(16 << 9) + 372L != tmp___135) {
          _L___2: /* CIL Label */ 
#line 1868
          if ((debug.status & (1L << 8)) != 0L) {
#line 1868
            tmp___131 = (long )(17 << 9) + 372L;
          } else {
#line 1868
            tmp___131 = (long )(16 << 9) + 372L;
          }
#line 1868
          tail___2 = tmp___131;
#line 1868
          debug.status |= 1L << 8;
#line 1868
          if (scm_debug_opts[0].val) {
            {
#line 1868
            tmp___130 = scm_make_debugobj(& debug);
#line 1868
            tmp___132 = scm_cons2(tmp___130, tail___2, (long )(20 << 9) + 372L);
#line 1868
            scm_ithrow(scm_i_apply_frame, tmp___132, 0);
            }
          } else {
            {
#line 1868
            scm_make_cont(& tmp___130);
#line 1868
            tmp___134 = _setjmp((struct __jmp_buf_tag *)(((scm_contregs *)((char *)((scm_cell *)tmp___130)->cdr))->jmpbuf));
            }
#line 1868
            if (! tmp___134) {
              {
#line 1868
              tmp___133 = scm_cons2(tmp___130, tail___2, (long )(20 << 9) + 372L);
#line 1868
              scm_ithrow(scm_i_apply_frame, tmp___133, 0);
              }
            }
          }
        }
      }
    }
    {
#line 1871
    if ((127 & (int )((scm_cell *)proc)->car) == 85) {
#line 1871
      goto case_85___0;
    }
#line 1873
    if ((127 & (int )((scm_cell *)proc)->car) == 109) {
#line 1873
      goto case_109___0;
    }
#line 1875
    if ((127 & (int )((scm_cell *)proc)->car) == 119) {
#line 1875
      goto case_119___0;
    }
#line 1877
    if ((127 & (int )((scm_cell *)proc)->car) == 69) {
#line 1877
      goto case_69___0;
    }
#line 1879
    if ((127 & (int )((scm_cell *)proc)->car) == 103) {
#line 1879
      goto case_103___0;
    }
#line 1882
    if ((127 & (int )((scm_cell *)proc)->car) == 63) {
#line 1882
      goto case_63;
    }
#line 1891
    if ((127 & (int )((scm_cell *)proc)->car) == 123) {
#line 1891
      goto case_123___0;
    }
#line 1891
    if ((127 & (int )((scm_cell *)proc)->car) == 115) {
#line 1891
      goto case_123___0;
    }
#line 1891
    if ((127 & (int )((scm_cell *)proc)->car) == 107) {
#line 1891
      goto case_123___0;
    }
#line 1891
    if ((127 & (int )((scm_cell *)proc)->car) == 99) {
#line 1891
      goto case_123___0;
    }
#line 1891
    if ((127 & (int )((scm_cell *)proc)->car) == 91) {
#line 1891
      goto case_123___0;
    }
#line 1891
    if ((127 & (int )((scm_cell *)proc)->car) == 83) {
#line 1891
      goto case_123___0;
    }
#line 1891
    if ((127 & (int )((scm_cell *)proc)->car) == 75) {
#line 1891
      goto case_123___0;
    }
#line 1891
    if ((127 & (int )((scm_cell *)proc)->car) == 67) {
#line 1891
      goto case_123___0;
    }
#line 1891
    if ((127 & (int )((scm_cell *)proc)->car) == 59) {
#line 1891
      goto case_123___0;
    }
#line 1891
    if ((127 & (int )((scm_cell *)proc)->car) == 51) {
#line 1891
      goto case_123___0;
    }
#line 1891
    if ((127 & (int )((scm_cell *)proc)->car) == 43) {
#line 1891
      goto case_123___0;
    }
#line 1891
    if ((127 & (int )((scm_cell *)proc)->car) == 35) {
#line 1891
      goto case_123___0;
    }
#line 1891
    if ((127 & (int )((scm_cell *)proc)->car) == 27) {
#line 1891
      goto case_123___0;
    }
#line 1891
    if ((127 & (int )((scm_cell *)proc)->car) == 19) {
#line 1891
      goto case_123___0;
    }
#line 1891
    if ((127 & (int )((scm_cell *)proc)->car) == 11) {
#line 1891
      goto case_123___0;
    }
#line 1891
    if ((127 & (int )((scm_cell *)proc)->car) == 3) {
#line 1891
      goto case_123___0;
    }
#line 1901
    if ((127 & (int )((scm_cell *)proc)->car) == 117) {
#line 1901
      goto umwrongnumargs;
    }
#line 1901
    if ((127 & (int )((scm_cell *)proc)->car) == 95) {
#line 1901
      goto umwrongnumargs;
    }
#line 1901
    if ((127 & (int )((scm_cell *)proc)->car) == 93) {
#line 1901
      goto umwrongnumargs;
    }
#line 1901
    if ((127 & (int )((scm_cell *)proc)->car) == 111) {
#line 1901
      goto umwrongnumargs;
    }
#line 1901
    if ((127 & (int )((scm_cell *)proc)->car) == 101) {
#line 1901
      goto umwrongnumargs;
    }
#line 1901
    if ((127 & (int )((scm_cell *)proc)->car) == 87) {
#line 1901
      goto umwrongnumargs;
    }
#line 1901
    if ((127 & (int )((scm_cell *)proc)->car) == 61) {
#line 1901
      goto umwrongnumargs;
    }
#line 1907
    goto switch_default___1;
    case_85___0: /* CIL Label */ 
    {
#line 1872
    proc = (*(((scm_subr *)proc)->cproc))();
    }
#line 1872
    goto exit;
    case_109___0: /* CIL Label */ 
    {
#line 1874
    proc = (*(((scm_subr *)proc)->cproc))((long )(18 << 9) + 372L);
    }
#line 1874
    goto exit;
    case_119___0: /* CIL Label */ 
    {
#line 1876
    proc = (*(((scm_subr *)proc)->cproc))((long )(20 << 9) + 372L);
    }
#line 1876
    goto exit;
    case_69___0: /* CIL Label */ 
#line 1878
    proc = (long )(17 << 9) + 372L;
#line 1878
    goto exit;
    case_103___0: /* CIL Label */ 
    {
#line 1880
    proc = (*(((scm_subr *)proc)->cproc))((long )(18 << 9) + 372L, (long )(18 << 9) + 372L);
    }
#line 1880
    goto exit;
    case_63: /* CIL Label */ 
    {
#line 1883
    t.arg1 = proc;
#line 1884
    proc = *((SCM *)((scm_cell *)proc)->cdr + 0);
#line 1886
    (debug.info)->a.proc = proc;
#line 1887
    (debug.info)->a.args = scm_cons(t.arg1, (long )(20 << 9) + 372L);
    }
#line 1889
    goto evap1;
    case_123___0: /* CIL Label */ 
    case_115___0: /* CIL Label */ 
    case_107___0: /* CIL Label */ 
    case_99___0: /* CIL Label */ 
    case_91___0: /* CIL Label */ 
    case_83___0: /* CIL Label */ 
    case_75___0: /* CIL Label */ 
    case_67___0: /* CIL Label */ 
    case_59___0: /* CIL Label */ 
    case_51___0: /* CIL Label */ 
    case_43___0: /* CIL Label */ 
    case_35___0: /* CIL Label */ 
    case_27___0: /* CIL Label */ 
    case_19___0: /* CIL Label */ 
    case_11___0: /* CIL Label */ 
    case_3___0: /* CIL Label */ 
    {
#line 1892
    x = ((scm_cell *)(((scm_cell *)proc)->car - 3L))->car;
#line 1893
    env = scm_acons(((scm_cell *)x)->car, (long )(20 << 9) + 372L, ((scm_cell *)proc)->cdr);
    }
#line 1894
    goto cdrxbegin;
    umwrongnumargs: 
    case_117___0: /* CIL Label */ 
    case_95___0: /* CIL Label */ 
    case_93___0: /* CIL Label */ 
    case_111___0: /* CIL Label */ 
    case_101___0: /* CIL Label */ 
    case_87___0: /* CIL Label */ 
    case_61: /* CIL Label */ 
    {
#line 1903
    scm_unmemocar(x, env);
    }
    wrongnumargs: 
    {
#line 1906
    scm_wrong_num_args(proc);
    }
    switch_default___1: /* CIL Label */ 
#line 1909
    goto badfun;
    switch_break___3: /* CIL Label */ ;
    }
  }
#line 1914
  x = ((scm_cell *)x)->cdr;
#line 1916
  if (6 & (int )x) {
#line 1917
    goto wrongnumargs;
  }
#line 1919
  if ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )((scm_cell *)x)->car)) {
#line 1919
    if (6 & (int )((scm_cell *)x)->car) {
#line 1919
      if (((int )((scm_cell *)x)->car & 255) == 252) {
        {
#line 1919
        tmp___136 = scm_ilookup(((scm_cell *)x)->car, env);
#line 1919
        tmp___137 = *tmp___136;
        }
      } else {
#line 1919
        tmp___137 = ((scm_cell *)x)->car;
      }
#line 1919
      tmp___138 = tmp___137;
    } else {
#line 1919
      tmp___138 = ((scm_cell *)(((scm_cell *)x)->car - 1L))->cdr;
    }
#line 1919
    t.arg1 = tmp___138;
  } else {
#line 1919
    if ((125 & (int )((scm_cell *)((scm_cell *)x)->car)->car) == 5) {
      {
#line 1919
      tmp___139 = scm_lookupcar(x, env);
#line 1919
      tmp___141 = *tmp___139;
      }
    } else {
      {
#line 1919
      tmp___140 = scm_deval(((scm_cell *)x)->car, env);
#line 1919
      tmp___141 = tmp___140;
      }
    }
#line 1919
    t.arg1 = tmp___141;
  }
  {
#line 1921
  (debug.info)->a.args = scm_cons(t.arg1, (long )(20 << 9) + 372L);
#line 1923
  x = ((scm_cell *)x)->cdr;
  }
#line 1924
  if ((long )(20 << 9) + 372L == x) {
#line 1926
    debug.status |= 1L << 7;
#line 1926
    if (scm_check_apply_p) {
#line 1926
      if (scm_evaluator_trap_table[1].val) {
#line 1926
        goto _L___3;
      } else
#line 1926
      if (scm_debug_opts[2].val) {
        {
#line 1926
        tmp___147 = scm_procedure_property(proc, scm_i_trace);
        }
#line 1926
        if ((long )(16 << 9) + 372L != tmp___147) {
          _L___3: /* CIL Label */ 
#line 1926
          if ((debug.status & (1L << 8)) != 0L) {
#line 1926
            tmp___143 = (long )(17 << 9) + 372L;
          } else {
#line 1926
            tmp___143 = (long )(16 << 9) + 372L;
          }
#line 1926
          tail___3 = tmp___143;
#line 1926
          debug.status |= 1L << 8;
#line 1926
          if (scm_debug_opts[0].val) {
            {
#line 1926
            tmp___142 = scm_make_debugobj(& debug);
#line 1926
            tmp___144 = scm_cons2(tmp___142, tail___3, (long )(20 << 9) + 372L);
#line 1926
            scm_ithrow(scm_i_apply_frame, tmp___144, 0);
            }
          } else {
            {
#line 1926
            scm_make_cont(& tmp___142);
#line 1926
            tmp___146 = _setjmp((struct __jmp_buf_tag *)(((scm_contregs *)((char *)((scm_cell *)tmp___142)->cdr))->jmpbuf));
            }
#line 1926
            if (! tmp___146) {
              {
#line 1926
              tmp___145 = scm_cons2(tmp___142, tail___3, (long )(20 << 9) + 372L);
#line 1926
              scm_ithrow(scm_i_apply_frame, tmp___145, 0);
              }
            }
          }
        }
      }
    }
    evap1: 
    {
#line 1930
    if ((127 & (int )((scm_cell *)proc)->car) == 111) {
#line 1930
      goto case_111___1;
    }
#line 1933
    if ((127 & (int )((scm_cell *)proc)->car) == 109) {
#line 1933
      goto case_109___1;
    }
#line 1933
    if ((127 & (int )((scm_cell *)proc)->car) == 87) {
#line 1933
      goto case_109___1;
    }
#line 1935
    if ((127 & (int )((scm_cell *)proc)->car) == 93) {
#line 1935
      goto case_93___1;
    }
#line 1970
    if ((127 & (int )((scm_cell *)proc)->car) == 69) {
#line 1970
      goto case_69___1;
    }
#line 1972
    if ((127 & (int )((scm_cell *)proc)->car) == 103) {
#line 1972
      goto case_103___1;
    }
#line 1974
    if ((127 & (int )((scm_cell *)proc)->car) == 119) {
#line 1974
      goto case_119___1;
    }
#line 1981
    if ((127 & (int )((scm_cell *)proc)->car) == 63) {
#line 1981
      goto case_63___0;
    }
#line 1991
    if ((127 & (int )((scm_cell *)proc)->car) == 123) {
#line 1991
      goto case_123___1;
    }
#line 1991
    if ((127 & (int )((scm_cell *)proc)->car) == 115) {
#line 1991
      goto case_123___1;
    }
#line 1991
    if ((127 & (int )((scm_cell *)proc)->car) == 107) {
#line 1991
      goto case_123___1;
    }
#line 1991
    if ((127 & (int )((scm_cell *)proc)->car) == 99) {
#line 1991
      goto case_123___1;
    }
#line 1991
    if ((127 & (int )((scm_cell *)proc)->car) == 91) {
#line 1991
      goto case_123___1;
    }
#line 1991
    if ((127 & (int )((scm_cell *)proc)->car) == 83) {
#line 1991
      goto case_123___1;
    }
#line 1991
    if ((127 & (int )((scm_cell *)proc)->car) == 75) {
#line 1991
      goto case_123___1;
    }
#line 1991
    if ((127 & (int )((scm_cell *)proc)->car) == 67) {
#line 1991
      goto case_123___1;
    }
#line 1991
    if ((127 & (int )((scm_cell *)proc)->car) == 59) {
#line 1991
      goto case_123___1;
    }
#line 1991
    if ((127 & (int )((scm_cell *)proc)->car) == 51) {
#line 1991
      goto case_123___1;
    }
#line 1991
    if ((127 & (int )((scm_cell *)proc)->car) == 43) {
#line 1991
      goto case_123___1;
    }
#line 1991
    if ((127 & (int )((scm_cell *)proc)->car) == 35) {
#line 1991
      goto case_123___1;
    }
#line 1991
    if ((127 & (int )((scm_cell *)proc)->car) == 27) {
#line 1991
      goto case_123___1;
    }
#line 1991
    if ((127 & (int )((scm_cell *)proc)->car) == 19) {
#line 1991
      goto case_123___1;
    }
#line 1991
    if ((127 & (int )((scm_cell *)proc)->car) == 11) {
#line 1991
      goto case_123___1;
    }
#line 1991
    if ((127 & (int )((scm_cell *)proc)->car) == 3) {
#line 1991
      goto case_123___1;
    }
#line 1999
    if ((127 & (int )((scm_cell *)proc)->car) == 61) {
#line 1999
      goto case_61___0;
    }
#line 2004
    if ((127 & (int )((scm_cell *)proc)->car) == 117) {
#line 2004
      goto case_117___1;
    }
#line 2004
    if ((127 & (int )((scm_cell *)proc)->car) == 95) {
#line 2004
      goto case_117___1;
    }
#line 2004
    if ((127 & (int )((scm_cell *)proc)->car) == 85) {
#line 2004
      goto case_117___1;
    }
#line 2004
    if ((127 & (int )((scm_cell *)proc)->car) == 101) {
#line 2004
      goto case_117___1;
    }
#line 2006
    goto switch_default___2;
    case_111___1: /* CIL Label */ 
    {
#line 1931
    proc = (*(((scm_subr *)proc)->cproc))(t.arg1, (long )(18 << 9) + 372L);
    }
#line 1931
    goto exit;
    case_109___1: /* CIL Label */ 
    case_87___1: /* CIL Label */ 
    {
#line 1934
    proc = (*(((scm_subr *)proc)->cproc))(t.arg1);
    }
#line 1934
    goto exit;
    case_93___1: /* CIL Label */ 
#line 1937
    if (((scm_subr *)proc)->cproc) {
#line 1939
      if (2 & (int )t.arg1) {
        {
#line 1941
        tmp___148 = (*(((scm_dsubr *)proc)->dproc))((double )(t.arg1 >> 2));
#line 1941
        proc = scm_makdbl(tmp___148, 0.0);
        }
#line 1941
        goto exit;
      }
#line 1944
      if (! (! (6 & (int )t.arg1))) {
#line 1944
        goto floerr;
      }
#line 1945
      if (((scm_cell *)t.arg1)->car == (383L | (1L << 16))) {
        {
#line 1947
        tmp___149 = (*(((scm_dsubr *)proc)->dproc))(*(((scm_dbl *)t.arg1)->real));
#line 1947
        proc = scm_makdbl(tmp___149, 0.0);
        }
#line 1947
        goto exit;
      }
#line 1950
      if ((65279 & (int )((scm_cell *)t.arg1)->car) == 639) {
        {
#line 1952
        tmp___150 = scm_big2dbl(t.arg1);
#line 1952
        tmp___151 = (*(((scm_dsubr *)proc)->dproc))(tmp___150);
#line 1952
        proc = scm_makdbl(tmp___151, 0.0);
        }
#line 1952
        goto exit;
      }
      floerr: 
#line 1956
      if (((scm_cell *)proc)->car >> 8) {
#line 1956
        tmp___152 = (SCM )(scm_heap_org + (((scm_cell *)proc)->car >> 8));
      } else {
#line 1956
        tmp___152 = scm_sys_protects[4];
      }
      {
#line 1956
      scm_wta(t.arg1, (char *)1, (char *)((scm_cell *)tmp___152)->cdr);
      }
    }
#line 1959
    if (((scm_cell *)proc)->car >> 8) {
#line 1959
      tmp___153 = (SCM )(scm_heap_org + (((scm_cell *)proc)->car >> 8));
    } else {
#line 1959
      tmp___153 = scm_sys_protects[4];
    }
#line 1959
    proc = tmp___153;
#line 1961
    chrs = ((char *)((scm_cell *)proc)->cdr + ((unsigned long )((scm_cell *)proc)->car >> 8)) - 1;
    {
#line 1962
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 1962
      chrs --;
#line 1962
      if (! (99 != (int )*chrs)) {
#line 1962
        goto while_break___13;
      }
#line 1964
      if (! (6 & (int )t.arg1)) {
#line 1964
        if (! (! (1 & (int )((scm_cell *)t.arg1)->car))) {
          {
#line 1964
          scm_wta(t.arg1, (char *)1, (char *)((scm_cell *)proc)->cdr);
          }
        }
      } else {
        {
#line 1964
        scm_wta(t.arg1, (char *)1, (char *)((scm_cell *)proc)->cdr);
        }
      }
#line 1966
      if (97 == (int )*chrs) {
#line 1966
        t.arg1 = ((scm_cell *)t.arg1)->car;
      } else {
#line 1966
        t.arg1 = ((scm_cell *)t.arg1)->cdr;
      }
    }
    while_break___13: /* CIL Label */ ;
    }
#line 1968
    proc = t.arg1;
#line 1968
    goto exit;
    case_69___1: /* CIL Label */ 
#line 1971
    proc = (long )(17 << 9) + 372L;
#line 1971
    goto exit;
    case_103___1: /* CIL Label */ 
    {
#line 1973
    proc = (*(((scm_subr *)proc)->cproc))(t.arg1, (long )(18 << 9) + 372L);
    }
#line 1973
    goto exit;
    case_119___1: /* CIL Label */ 
    {
#line 1976
    proc = (*(((scm_subr *)proc)->cproc))((debug.info)->a.args);
    }
#line 1976
    goto exit;
    case_63___0: /* CIL Label */ 
    {
#line 1982
    arg2 = t.arg1;
#line 1983
    t.arg1 = proc;
#line 1984
    proc = *((SCM *)((scm_cell *)proc)->cdr + 0);
#line 1986
    (debug.info)->a.args = scm_cons(t.arg1, (debug.info)->a.args);
#line 1987
    (debug.info)->a.proc = proc;
    }
#line 1989
    goto evap2;
    case_123___1: /* CIL Label */ 
    case_115___1: /* CIL Label */ 
    case_107___1: /* CIL Label */ 
    case_99___1: /* CIL Label */ 
    case_91___1: /* CIL Label */ 
    case_83___1: /* CIL Label */ 
    case_75___1: /* CIL Label */ 
    case_67___1: /* CIL Label */ 
    case_59___1: /* CIL Label */ 
    case_51___1: /* CIL Label */ 
    case_43___1: /* CIL Label */ 
    case_35___1: /* CIL Label */ 
    case_27___1: /* CIL Label */ 
    case_19___1: /* CIL Label */ 
    case_11___1: /* CIL Label */ 
    case_3___1: /* CIL Label */ 
    {
#line 1992
    x = ((scm_cell *)(((scm_cell *)proc)->car - 3L))->car;
#line 1994
    env = scm_acons(((scm_cell *)x)->car, (debug.info)->a.args, ((scm_cell *)proc)->cdr);
    }
#line 1998
    goto cdrxbegin;
    case_61___0: /* CIL Label */ 
    {
#line 2000
    scm_call_continuation(proc, t.arg1);
    }
    case_117___1: /* CIL Label */ 
    case_95___1: /* CIL Label */ 
    case_85___1: /* CIL Label */ 
    case_101___1: /* CIL Label */ 
#line 2005
    goto wrongnumargs;
    switch_default___2: /* CIL Label */ 
#line 2007
    goto badfun;
    switch_break___4: /* CIL Label */ ;
    }
  }
#line 2011
  if (6 & (int )x) {
#line 2012
    goto wrongnumargs;
  }
#line 2015
  if ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )((scm_cell *)x)->car)) {
#line 2015
    if (6 & (int )((scm_cell *)x)->car) {
#line 2015
      if (((int )((scm_cell *)x)->car & 255) == 252) {
        {
#line 2015
        tmp___154 = scm_ilookup(((scm_cell *)x)->car, env);
#line 2015
        tmp___155 = *tmp___154;
        }
      } else {
#line 2015
        tmp___155 = ((scm_cell *)x)->car;
      }
#line 2015
      tmp___156 = tmp___155;
    } else {
#line 2015
      tmp___156 = ((scm_cell *)(((scm_cell *)x)->car - 1L))->cdr;
    }
#line 2015
    arg2 = tmp___156;
  } else {
#line 2015
    if ((125 & (int )((scm_cell *)((scm_cell *)x)->car)->car) == 5) {
      {
#line 2015
      tmp___157 = scm_lookupcar(x, env);
#line 2015
      tmp___159 = *tmp___157;
      }
    } else {
      {
#line 2015
      tmp___158 = scm_deval(((scm_cell *)x)->car, env);
#line 2015
      tmp___159 = tmp___158;
      }
    }
#line 2015
    arg2 = tmp___159;
  }
  {
#line 2017
  (debug.info)->a.args = scm_cons2(t.arg1, arg2, (long )(20 << 9) + 372L);
#line 2019
  x = ((scm_cell *)x)->cdr;
  }
#line 2020
  if ((long )(20 << 9) + 372L == x) {
#line 2021
    debug.status |= 1L << 7;
#line 2021
    if (scm_check_apply_p) {
#line 2021
      if (scm_evaluator_trap_table[1].val) {
#line 2021
        goto _L___4;
      } else
#line 2021
      if (scm_debug_opts[2].val) {
        {
#line 2021
        tmp___165 = scm_procedure_property(proc, scm_i_trace);
        }
#line 2021
        if ((long )(16 << 9) + 372L != tmp___165) {
          _L___4: /* CIL Label */ 
#line 2021
          if ((debug.status & (1L << 8)) != 0L) {
#line 2021
            tmp___161 = (long )(17 << 9) + 372L;
          } else {
#line 2021
            tmp___161 = (long )(16 << 9) + 372L;
          }
#line 2021
          tail___4 = tmp___161;
#line 2021
          debug.status |= 1L << 8;
#line 2021
          if (scm_debug_opts[0].val) {
            {
#line 2021
            tmp___160 = scm_make_debugobj(& debug);
#line 2021
            tmp___162 = scm_cons2(tmp___160, tail___4, (long )(20 << 9) + 372L);
#line 2021
            scm_ithrow(scm_i_apply_frame, tmp___162, 0);
            }
          } else {
            {
#line 2021
            scm_make_cont(& tmp___160);
#line 2021
            tmp___164 = _setjmp((struct __jmp_buf_tag *)(((scm_contregs *)((char *)((scm_cell *)tmp___160)->cdr))->jmpbuf));
            }
#line 2021
            if (! tmp___164) {
              {
#line 2021
              tmp___163 = scm_cons2(tmp___160, tail___4, (long )(20 << 9) + 372L);
#line 2021
              scm_ithrow(scm_i_apply_frame, tmp___163, 0);
              }
            }
          }
        }
      }
    }
    evap2: 
    {
#line 2028
    if ((127 & (int )((scm_cell *)proc)->car) == 111) {
#line 2028
      goto case_111___2;
    }
#line 2028
    if ((127 & (int )((scm_cell *)proc)->car) == 101) {
#line 2028
      goto case_111___2;
    }
#line 2030
    if ((127 & (int )((scm_cell *)proc)->car) == 119) {
#line 2030
      goto case_119___2;
    }
#line 2036
    if ((127 & (int )((scm_cell *)proc)->car) == 117) {
#line 2036
      goto case_117___2;
    }
#line 2039
    if ((127 & (int )((scm_cell *)proc)->car) == 103) {
#line 2039
      goto case_103___2;
    }
#line 2039
    if ((127 & (int )((scm_cell *)proc)->car) == 69) {
#line 2039
      goto case_103___2;
    }
#line 2043
    if ((127 & (int )((scm_cell *)proc)->car) == 63) {
#line 2043
      goto cclon;
    }
#line 2064
    if ((127 & (int )((scm_cell *)proc)->car) == 61) {
#line 2064
      goto case_61___1;
    }
#line 2064
    if ((127 & (int )((scm_cell *)proc)->car) == 95) {
#line 2064
      goto case_61___1;
    }
#line 2064
    if ((127 & (int )((scm_cell *)proc)->car) == 87) {
#line 2064
      goto case_61___1;
    }
#line 2064
    if ((127 & (int )((scm_cell *)proc)->car) == 109) {
#line 2064
      goto case_61___1;
    }
#line 2064
    if ((127 & (int )((scm_cell *)proc)->car) == 93) {
#line 2064
      goto case_61___1;
    }
#line 2064
    if ((127 & (int )((scm_cell *)proc)->car) == 85) {
#line 2064
      goto case_61___1;
    }
#line 2068
    if ((127 & (int )((scm_cell *)proc)->car) == 123) {
#line 2068
      goto case_123___2;
    }
#line 2068
    if ((127 & (int )((scm_cell *)proc)->car) == 115) {
#line 2068
      goto case_123___2;
    }
#line 2068
    if ((127 & (int )((scm_cell *)proc)->car) == 107) {
#line 2068
      goto case_123___2;
    }
#line 2068
    if ((127 & (int )((scm_cell *)proc)->car) == 99) {
#line 2068
      goto case_123___2;
    }
#line 2068
    if ((127 & (int )((scm_cell *)proc)->car) == 91) {
#line 2068
      goto case_123___2;
    }
#line 2068
    if ((127 & (int )((scm_cell *)proc)->car) == 83) {
#line 2068
      goto case_123___2;
    }
#line 2068
    if ((127 & (int )((scm_cell *)proc)->car) == 75) {
#line 2068
      goto case_123___2;
    }
#line 2068
    if ((127 & (int )((scm_cell *)proc)->car) == 67) {
#line 2068
      goto case_123___2;
    }
#line 2068
    if ((127 & (int )((scm_cell *)proc)->car) == 59) {
#line 2068
      goto case_123___2;
    }
#line 2068
    if ((127 & (int )((scm_cell *)proc)->car) == 51) {
#line 2068
      goto case_123___2;
    }
#line 2068
    if ((127 & (int )((scm_cell *)proc)->car) == 43) {
#line 2068
      goto case_123___2;
    }
#line 2068
    if ((127 & (int )((scm_cell *)proc)->car) == 35) {
#line 2068
      goto case_123___2;
    }
#line 2068
    if ((127 & (int )((scm_cell *)proc)->car) == 27) {
#line 2068
      goto case_123___2;
    }
#line 2068
    if ((127 & (int )((scm_cell *)proc)->car) == 19) {
#line 2068
      goto case_123___2;
    }
#line 2068
    if ((127 & (int )((scm_cell *)proc)->car) == 11) {
#line 2068
      goto case_123___2;
    }
#line 2068
    if ((127 & (int )((scm_cell *)proc)->car) == 3) {
#line 2068
      goto case_123___2;
    }
#line 2066
    goto switch_default___3;
    case_111___2: /* CIL Label */ 
    case_101___2: /* CIL Label */ 
    {
#line 2029
    proc = (*(((scm_subr *)proc)->cproc))(t.arg1, arg2);
    }
#line 2029
    goto exit;
    case_119___2: /* CIL Label */ 
    {
#line 2032
    proc = (*(((scm_subr *)proc)->cproc))((debug.info)->a.args);
    }
#line 2032
    goto exit;
    case_117___2: /* CIL Label */ 
    {
#line 2037
    proc = (*(((scm_subr *)proc)->cproc))(t.arg1, arg2, (long )(20 << 9) + 372L);
    }
#line 2037
    goto exit;
    case_103___2: /* CIL Label */ 
    case_69___2: /* CIL Label */ 
    {
#line 2040
    proc = (*(((scm_subr *)proc)->cproc))(t.arg1, arg2);
    }
#line 2040
    goto exit;
    cclon: 
    case_63___1: /* CIL Label */ 
    {
#line 2045
    tmp___166 = scm_cons((debug.info)->a.args, (long )(20 << 9) + 372L);
#line 2045
    proc = scm_dapply(*((SCM *)((scm_cell *)proc)->cdr + 0), proc, tmp___166);
    }
#line 2045
    goto exit;
    case_61___1: /* CIL Label */ 
    case_95___2: /* CIL Label */ 
    case_87___2: /* CIL Label */ 
    case_109___2: /* CIL Label */ 
    case_93___2: /* CIL Label */ 
    case_85___2: /* CIL Label */ 
#line 2065
    goto wrongnumargs;
    switch_default___3: /* CIL Label */ 
#line 2067
    goto badfun;
    case_123___2: /* CIL Label */ 
    case_115___2: /* CIL Label */ 
    case_107___2: /* CIL Label */ 
    case_99___2: /* CIL Label */ 
    case_91___2: /* CIL Label */ 
    case_83___2: /* CIL Label */ 
    case_75___2: /* CIL Label */ 
    case_67___2: /* CIL Label */ 
    case_59___2: /* CIL Label */ 
    case_51___2: /* CIL Label */ 
    case_43___2: /* CIL Label */ 
    case_35___2: /* CIL Label */ 
    case_27___2: /* CIL Label */ 
    case_19___2: /* CIL Label */ 
    case_11___2: /* CIL Label */ 
    case_3___2: /* CIL Label */ 
    {
#line 2070
    env = scm_acons(((scm_cell *)((scm_cell *)(((scm_cell *)proc)->car - 3L))->car)->car,
                    (debug.info)->a.args, ((scm_cell *)proc)->cdr);
#line 2074
    x = ((scm_cell *)(((scm_cell *)proc)->car - 3L))->car;
    }
#line 2075
    goto cdrxbegin;
    switch_break___5: /* CIL Label */ ;
    }
  }
  {
#line 2079
  tmp___167 = scm_deval_args(x, env, & ((scm_cell *)((scm_cell *)(debug.info)->a.args)->cdr)->cdr);
#line 2079
  (debug.info)->a.args = scm_cons2(t.arg1, arg2, tmp___167);
#line 2082
  debug.status |= 1L << 7;
  }
#line 2082
  if (scm_check_apply_p) {
#line 2082
    if (scm_evaluator_trap_table[1].val) {
#line 2082
      goto _L___5;
    } else
#line 2082
    if (scm_debug_opts[2].val) {
      {
#line 2082
      tmp___173 = scm_procedure_property(proc, scm_i_trace);
      }
#line 2082
      if ((long )(16 << 9) + 372L != tmp___173) {
        _L___5: /* CIL Label */ 
#line 2082
        if ((debug.status & (1L << 8)) != 0L) {
#line 2082
          tmp___169 = (long )(17 << 9) + 372L;
        } else {
#line 2082
          tmp___169 = (long )(16 << 9) + 372L;
        }
#line 2082
        tail___5 = tmp___169;
#line 2082
        debug.status |= 1L << 8;
#line 2082
        if (scm_debug_opts[0].val) {
          {
#line 2082
          tmp___168 = scm_make_debugobj(& debug);
#line 2082
          tmp___170 = scm_cons2(tmp___168, tail___5, (long )(20 << 9) + 372L);
#line 2082
          scm_ithrow(scm_i_apply_frame, tmp___170, 0);
          }
        } else {
          {
#line 2082
          scm_make_cont(& tmp___168);
#line 2082
          tmp___172 = _setjmp((struct __jmp_buf_tag *)(((scm_contregs *)((char *)((scm_cell *)tmp___168)->cdr))->jmpbuf));
          }
#line 2082
          if (! tmp___172) {
            {
#line 2082
            tmp___171 = scm_cons2(tmp___168, tail___5, (long )(20 << 9) + 372L);
#line 2082
            scm_ithrow(scm_i_apply_frame, tmp___171, 0);
            }
          }
        }
      }
    }
  }
  {
#line 2086
  if ((127 & (int )((scm_cell *)proc)->car) == 95) {
#line 2086
    goto case_95___3;
  }
#line 2096
  if ((127 & (int )((scm_cell *)proc)->car) == 69) {
#line 2096
    goto case_69___3;
  }
#line 2096
  if ((127 & (int )((scm_cell *)proc)->car) == 103) {
#line 2096
    goto case_69___3;
  }
#line 2098
  if ((127 & (int )((scm_cell *)proc)->car) == 117) {
#line 2098
    goto case_117___3;
  }
#line 2100
  if ((127 & (int )((scm_cell *)proc)->car) == 119) {
#line 2100
    goto case_119___3;
  }
#line 2103
  if ((127 & (int )((scm_cell *)proc)->car) == 63) {
#line 2103
    goto case_63___2;
  }
#line 2106
  if ((127 & (int )((scm_cell *)proc)->car) == 123) {
#line 2106
    goto case_123___3;
  }
#line 2106
  if ((127 & (int )((scm_cell *)proc)->car) == 115) {
#line 2106
    goto case_123___3;
  }
#line 2106
  if ((127 & (int )((scm_cell *)proc)->car) == 107) {
#line 2106
    goto case_123___3;
  }
#line 2106
  if ((127 & (int )((scm_cell *)proc)->car) == 99) {
#line 2106
    goto case_123___3;
  }
#line 2106
  if ((127 & (int )((scm_cell *)proc)->car) == 91) {
#line 2106
    goto case_123___3;
  }
#line 2106
  if ((127 & (int )((scm_cell *)proc)->car) == 83) {
#line 2106
    goto case_123___3;
  }
#line 2106
  if ((127 & (int )((scm_cell *)proc)->car) == 75) {
#line 2106
    goto case_123___3;
  }
#line 2106
  if ((127 & (int )((scm_cell *)proc)->car) == 67) {
#line 2106
    goto case_123___3;
  }
#line 2106
  if ((127 & (int )((scm_cell *)proc)->car) == 59) {
#line 2106
    goto case_123___3;
  }
#line 2106
  if ((127 & (int )((scm_cell *)proc)->car) == 51) {
#line 2106
    goto case_123___3;
  }
#line 2106
  if ((127 & (int )((scm_cell *)proc)->car) == 43) {
#line 2106
    goto case_123___3;
  }
#line 2106
  if ((127 & (int )((scm_cell *)proc)->car) == 35) {
#line 2106
    goto case_123___3;
  }
#line 2106
  if ((127 & (int )((scm_cell *)proc)->car) == 27) {
#line 2106
    goto case_123___3;
  }
#line 2106
  if ((127 & (int )((scm_cell *)proc)->car) == 19) {
#line 2106
    goto case_123___3;
  }
#line 2106
  if ((127 & (int )((scm_cell *)proc)->car) == 11) {
#line 2106
    goto case_123___3;
  }
#line 2106
  if ((127 & (int )((scm_cell *)proc)->car) == 3) {
#line 2106
    goto case_123___3;
  }
#line 2150
  if ((127 & (int )((scm_cell *)proc)->car) == 61) {
#line 2150
    goto case_61___2;
  }
#line 2150
  if ((127 & (int )((scm_cell *)proc)->car) == 87) {
#line 2150
    goto case_61___2;
  }
#line 2150
  if ((127 & (int )((scm_cell *)proc)->car) == 93) {
#line 2150
    goto case_61___2;
  }
#line 2150
  if ((127 & (int )((scm_cell *)proc)->car) == 85) {
#line 2150
    goto case_61___2;
  }
#line 2150
  if ((127 & (int )((scm_cell *)proc)->car) == 111) {
#line 2150
    goto case_61___2;
  }
#line 2150
  if ((127 & (int )((scm_cell *)proc)->car) == 109) {
#line 2150
    goto case_61___2;
  }
#line 2150
  if ((127 & (int )((scm_cell *)proc)->car) == 101) {
#line 2150
    goto case_61___2;
  }
#line 2152
  goto switch_default___4;
  case_95___3: /* CIL Label */ 
#line 2087
  if (! ((long )(20 << 9) + 372L == ((scm_cell *)x)->cdr)) {
#line 2087
    goto wrongnumargs;
  }
  {
#line 2088
  proc = (*(((scm_subr *)proc)->cproc))(t.arg1, arg2, ((scm_cell *)((scm_cell *)((scm_cell *)(debug.info)->a.args)->cdr)->cdr)->car);
  }
#line 2088
  goto exit;
  case_69___3: /* CIL Label */ 
  case_103___3: /* CIL Label */ 
  {
#line 2097
  tmp___174 = scm_acons(arg2, ((scm_cell *)((scm_cell *)(debug.info)->a.args)->cdr)->cdr,
                        (long )(20 << 9) + 372L);
#line 2097
  proc = scm_dapply(proc, t.arg1, tmp___174);
  }
#line 2097
  goto exit;
  case_117___3: /* CIL Label */ 
  {
#line 2099
  proc = (*(((scm_subr *)proc)->cproc))(t.arg1, arg2, ((scm_cell *)((scm_cell *)(debug.info)->a.args)->cdr)->cdr);
  }
#line 2099
  goto exit;
  case_119___3: /* CIL Label */ 
  {
#line 2101
  proc = (*(((scm_subr *)proc)->cproc))((debug.info)->a.args);
  }
#line 2101
  goto exit;
  case_63___2: /* CIL Label */ 
#line 2104
  goto cclon;
  case_123___3: /* CIL Label */ 
  case_115___3: /* CIL Label */ 
  case_107___3: /* CIL Label */ 
  case_99___3: /* CIL Label */ 
  case_91___3: /* CIL Label */ 
  case_83___3: /* CIL Label */ 
  case_75___3: /* CIL Label */ 
  case_67___3: /* CIL Label */ 
  case_59___3: /* CIL Label */ 
  case_51___3: /* CIL Label */ 
  case_43___3: /* CIL Label */ 
  case_35___3: /* CIL Label */ 
  case_27___3: /* CIL Label */ 
  case_19___3: /* CIL Label */ 
  case_11___3: /* CIL Label */ 
  case_3___3: /* CIL Label */ 
  {
#line 2107
  debug.status |= 1L << 7;
#line 2108
  env = scm_acons(((scm_cell *)((scm_cell *)(((scm_cell *)proc)->car - 3L))->car)->car,
                  (debug.info)->a.args, ((scm_cell *)proc)->cdr);
#line 2111
  x = ((scm_cell *)(((scm_cell *)proc)->car - 3L))->car;
  }
#line 2112
  goto cdrxbegin;
  case_61___2: /* CIL Label */ 
  case_87___3: /* CIL Label */ 
  case_93___3: /* CIL Label */ 
  case_85___3: /* CIL Label */ 
  case_111___3: /* CIL Label */ 
  case_109___3: /* CIL Label */ 
  case_101___3: /* CIL Label */ 
#line 2151
  goto wrongnumargs;
  switch_default___4: /* CIL Label */ 
#line 2153
  goto badfun;
  switch_break___6: /* CIL Label */ ;
  }
  exit: 
#line 2158
  if (scm_check_exit_p) {
#line 2159
    if (scm_evaluator_trap_table[2].val) {
#line 2159
      goto _L___6;
    } else
#line 2159
    if (scm_debug_opts[2].val) {
#line 2159
      if ((debug.status & (1L << 8)) != 0L) {
        _L___6: /* CIL Label */ 
#line 2161
        scm_evaluator_trap_table[2].val = 0UL;
#line 2162
        if (scm_evaluator_trap_table[0].val) {
#line 2162
          scm_check_entry_p = 1;
        } else
#line 2162
        if (scm_debug_opts[1].val) {
#line 2162
          scm_check_entry_p = 1;
        }
#line 2162
        if (scm_evaluator_trap_table[1].val) {
#line 2162
          scm_check_apply_p = 1;
        } else
#line 2162
        if (scm_debug_opts[2].val) {
#line 2162
          scm_check_apply_p = 1;
        }
#line 2162
        if (scm_evaluator_trap_table[2].val) {
#line 2162
          scm_check_exit_p = 1;
        } else
#line 2162
        if (scm_debug_opts[2].val) {
#line 2162
          scm_check_exit_p = 1;
        }
#line 2162
        if (scm_debug_opts[10].val) {
#line 2162
          tmp___175 = 1;
        } else
#line 2162
        if (scm_check_entry_p) {
#line 2162
          tmp___175 = 1;
        } else
#line 2162
        if (scm_check_apply_p) {
#line 2162
          tmp___175 = 1;
        } else
#line 2162
        if (scm_check_exit_p) {
#line 2162
          tmp___175 = 1;
        } else {
#line 2162
          tmp___175 = 0;
        }
#line 2162
        scm_debug_mode = tmp___175;
#line 2162
        if (scm_debug_mode) {
#line 2162
          scm_ceval_ptr = & scm_deval;
        } else {
#line 2162
          scm_ceval_ptr = & scm_ceval;
        }
#line 2163
        debug.status &= ~ (1L << 8);
#line 2164
        if (scm_debug_opts[0].val) {
          {
#line 2165
          t.arg1 = scm_make_debugobj(& debug);
          }
        } else {
          {
#line 2168
          scm_make_cont(& t.arg1);
#line 2169
          tmp___176 = _setjmp((struct __jmp_buf_tag *)(((scm_contregs *)((char *)((scm_cell *)t.arg1)->cdr))->jmpbuf));
          }
#line 2169
          if (tmp___176) {
#line 2171
            proc = ((scm_contregs *)((char *)((scm_cell *)t.arg1)->cdr))->throw_value;
#line 2172
            goto ret;
          }
        }
        {
#line 2175
        tmp___177 = scm_cons2(t.arg1, proc, (long )(20 << 9) + 372L);
#line 2175
        scm_ithrow(scm_i_exit_frame, tmp___177, 0);
        }
      }
    }
  }
  ret: 
#line 2178
  scm_last_debug_frame = debug.prev;
#line 2179
  return (proc);
}
}
#line 2279 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
SCM scm_dapply(SCM proc , SCM arg1 , SCM args ) 
{ 
  scm_debug_frame debug ;
  scm_debug_info debug_vect_body ;
  SCM tmp ;
  int tmp___0 ;
  int tmp___1 ;
  SCM tmp___2 ;
  SCM tmp___3 ;
  SCM tail ;
  long tmp___4 ;
  SCM tmp___5 ;
  SCM tmp___6 ;
  int tmp___7 ;
  SCM tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  SCM tmp___13 ;
  SCM tmp___14 ;
  char *chrs ;
  long tmp___15 ;
  SCM tmp___16 ;
  int tmp___17 ;
  SCM *tmp___18 ;
  SCM tmp___19 ;
  SCM tmp___20 ;
  SCM *tmp___21 ;
  SCM tmp___22 ;
  SCM tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  SCM tmp___26 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;

  {
#line 2289
  debug.prev = scm_last_debug_frame;
#line 2290
  debug.status = 1L << 10;
#line 2291
  debug.vect = & debug_vect_body;
#line 2292
  (debug.vect + 0)->a.proc = proc;
#line 2293
  (debug.vect + 0)->a.args = (long )(20 << 9) + 372L;
#line 2294
  scm_last_debug_frame = & debug;
#line 2301
  if (! (! (6 & (int )proc))) {
#line 2301
    goto badproc;
  }
#line 2302
  if ((long )(20 << 9) + 372L == args) {
#line 2304
    if ((long )(20 << 9) + 372L == arg1) {
#line 2305
      arg1 = (long )(18 << 9) + 372L;
    } else {
#line 2308
      args = ((scm_cell *)arg1)->cdr;
#line 2309
      arg1 = ((scm_cell *)arg1)->car;
    }
  } else {
    {
#line 2315
    args = scm_nconc2last(args);
    }
  }
  {
#line 2318
  (debug.vect + 0)->a.args = scm_cons(arg1, args);
  }
#line 2319
  if (scm_evaluator_trap_table[0].val) {
#line 2322
    scm_evaluator_trap_table[0].val = 0UL;
#line 2323
    if (scm_evaluator_trap_table[0].val) {
#line 2323
      scm_check_entry_p = 1;
    } else
#line 2323
    if (scm_debug_opts[1].val) {
#line 2323
      scm_check_entry_p = 1;
    }
#line 2323
    if (scm_evaluator_trap_table[1].val) {
#line 2323
      scm_check_apply_p = 1;
    } else
#line 2323
    if (scm_debug_opts[2].val) {
#line 2323
      scm_check_apply_p = 1;
    }
#line 2323
    if (scm_evaluator_trap_table[2].val) {
#line 2323
      scm_check_exit_p = 1;
    } else
#line 2323
    if (scm_debug_opts[2].val) {
#line 2323
      scm_check_exit_p = 1;
    }
#line 2323
    if (scm_debug_opts[10].val) {
#line 2323
      tmp___0 = 1;
    } else
#line 2323
    if (scm_check_entry_p) {
#line 2323
      tmp___0 = 1;
    } else
#line 2323
    if (scm_check_apply_p) {
#line 2323
      tmp___0 = 1;
    } else
#line 2323
    if (scm_check_exit_p) {
#line 2323
      tmp___0 = 1;
    } else {
#line 2323
      tmp___0 = 0;
    }
#line 2323
    scm_debug_mode = tmp___0;
#line 2323
    if (scm_debug_mode) {
#line 2323
      scm_ceval_ptr = & scm_deval;
    } else {
#line 2323
      scm_ceval_ptr = & scm_ceval;
    }
#line 2324
    if (scm_debug_opts[0].val) {
      {
#line 2325
      tmp = scm_make_debugobj(& debug);
      }
    } else {
      {
#line 2328
      scm_make_cont(& tmp);
#line 2329
      tmp___1 = _setjmp((struct __jmp_buf_tag *)(((scm_contregs *)((char *)((scm_cell *)tmp)->cdr))->jmpbuf));
      }
#line 2329
      if (tmp___1) {
#line 2330
        goto entap;
      }
    }
    {
#line 2332
    tmp___2 = scm_cons(tmp, (long )(20 << 9) + 372L);
#line 2332
    scm_ithrow(scm_i_enter_frame, tmp___2, 0);
    }
  }
  entap: 
#line 2335
  debug.status |= 1L << 7;
#line 2335
  if (scm_check_apply_p) {
#line 2335
    if (scm_evaluator_trap_table[1].val) {
#line 2335
      goto _L;
    } else
#line 2335
    if (scm_debug_opts[2].val) {
      {
#line 2335
      tmp___8 = scm_procedure_property(proc, scm_i_trace);
      }
#line 2335
      if ((long )(16 << 9) + 372L != tmp___8) {
        _L: /* CIL Label */ 
#line 2335
        if ((debug.status & (1L << 8)) != 0L) {
#line 2335
          tmp___4 = (long )(17 << 9) + 372L;
        } else {
#line 2335
          tmp___4 = (long )(16 << 9) + 372L;
        }
#line 2335
        tail = tmp___4;
#line 2335
        debug.status |= 1L << 8;
#line 2335
        if (scm_debug_opts[0].val) {
          {
#line 2335
          tmp___3 = scm_make_debugobj(& debug);
#line 2335
          tmp___5 = scm_cons2(tmp___3, tail, (long )(20 << 9) + 372L);
#line 2335
          scm_ithrow(scm_i_apply_frame, tmp___5, 0);
          }
        } else {
          {
#line 2335
          scm_make_cont(& tmp___3);
#line 2335
          tmp___7 = _setjmp((struct __jmp_buf_tag *)(((scm_contregs *)((char *)((scm_cell *)tmp___3)->cdr))->jmpbuf));
          }
#line 2335
          if (! tmp___7) {
            {
#line 2335
            tmp___6 = scm_cons2(tmp___3, tail, (long )(20 << 9) + 372L);
#line 2335
            scm_ithrow(scm_i_apply_frame, tmp___6, 0);
            }
          }
        }
      }
    }
  }
  tail: 
  {
#line 2342
  if ((127 & (int )((scm_cell *)proc)->car) == 111) {
#line 2342
    goto case_111;
  }
#line 2345
  if ((127 & (int )((scm_cell *)proc)->car) == 101) {
#line 2345
    goto case_101;
  }
#line 2349
  if ((127 & (int )((scm_cell *)proc)->car) == 85) {
#line 2349
    goto case_85;
  }
#line 2353
  if ((127 & (int )((scm_cell *)proc)->car) == 109) {
#line 2353
    goto case_109;
  }
#line 2353
  if ((127 & (int )((scm_cell *)proc)->car) == 87) {
#line 2353
    goto case_109;
  }
#line 2356
  if ((127 & (int )((scm_cell *)proc)->car) == 93) {
#line 2356
    goto case_93;
  }
#line 2390
  if ((127 & (int )((scm_cell *)proc)->car) == 95) {
#line 2390
    goto case_95;
  }
#line 2392
  if ((127 & (int )((scm_cell *)proc)->car) == 119) {
#line 2392
    goto case_119;
  }
#line 2398
  if ((127 & (int )((scm_cell *)proc)->car) == 117) {
#line 2398
    goto case_117;
  }
#line 2401
  if ((127 & (int )((scm_cell *)proc)->car) == 103) {
#line 2401
    goto case_103;
  }
#line 2411
  if ((127 & (int )((scm_cell *)proc)->car) == 69) {
#line 2411
    goto case_69;
  }
#line 2423
  if ((127 & (int )((scm_cell *)proc)->car) == 123) {
#line 2423
    goto case_123;
  }
#line 2423
  if ((127 & (int )((scm_cell *)proc)->car) == 115) {
#line 2423
    goto case_123;
  }
#line 2423
  if ((127 & (int )((scm_cell *)proc)->car) == 107) {
#line 2423
    goto case_123;
  }
#line 2423
  if ((127 & (int )((scm_cell *)proc)->car) == 99) {
#line 2423
    goto case_123;
  }
#line 2423
  if ((127 & (int )((scm_cell *)proc)->car) == 91) {
#line 2423
    goto case_123;
  }
#line 2423
  if ((127 & (int )((scm_cell *)proc)->car) == 83) {
#line 2423
    goto case_123;
  }
#line 2423
  if ((127 & (int )((scm_cell *)proc)->car) == 75) {
#line 2423
    goto case_123;
  }
#line 2423
  if ((127 & (int )((scm_cell *)proc)->car) == 67) {
#line 2423
    goto case_123;
  }
#line 2423
  if ((127 & (int )((scm_cell *)proc)->car) == 59) {
#line 2423
    goto case_123;
  }
#line 2423
  if ((127 & (int )((scm_cell *)proc)->car) == 51) {
#line 2423
    goto case_123;
  }
#line 2423
  if ((127 & (int )((scm_cell *)proc)->car) == 43) {
#line 2423
    goto case_123;
  }
#line 2423
  if ((127 & (int )((scm_cell *)proc)->car) == 35) {
#line 2423
    goto case_123;
  }
#line 2423
  if ((127 & (int )((scm_cell *)proc)->car) == 27) {
#line 2423
    goto case_123;
  }
#line 2423
  if ((127 & (int )((scm_cell *)proc)->car) == 19) {
#line 2423
    goto case_123;
  }
#line 2423
  if ((127 & (int )((scm_cell *)proc)->car) == 11) {
#line 2423
    goto case_123;
  }
#line 2423
  if ((127 & (int )((scm_cell *)proc)->car) == 3) {
#line 2423
    goto case_123;
  }
#line 2438
  if ((127 & (int )((scm_cell *)proc)->car) == 61) {
#line 2438
    goto case_61;
  }
#line 2442
  if ((127 & (int )((scm_cell *)proc)->car) == 63) {
#line 2442
    goto case_63;
  }
#line 2458
  goto badproc;
  case_111: /* CIL Label */ 
#line 2343
  if ((long )(20 << 9) + 372L == args) {
#line 2343
    args = (long )(18 << 9) + 372L;
  } else {
#line 2343
    args = ((scm_cell *)args)->car;
  }
  {
#line 2344
  proc = (*(((scm_subr *)proc)->cproc))(arg1, args);
  }
#line 2344
  goto exit;
  case_101: /* CIL Label */ 
#line 2346
  if (! ((long )(20 << 9) + 372L == ((scm_cell *)args)->cdr)) {
#line 2346
    goto wrongnumargs;
  }
  {
#line 2347
  args = ((scm_cell *)args)->car;
#line 2348
  proc = (*(((scm_subr *)proc)->cproc))(arg1, args);
  }
#line 2348
  goto exit;
  case_85: /* CIL Label */ 
#line 2350
  if (! ((long )(18 << 9) + 372L == arg1)) {
#line 2350
    goto wrongnumargs;
  }
  {
#line 2351
  proc = (*(((scm_subr *)proc)->cproc))();
  }
#line 2351
  goto exit;
  case_109: /* CIL Label */ 
  case_87: /* CIL Label */ 
#line 2354
  if (! ((long )(20 << 9) + 372L == args)) {
#line 2354
    goto wrongnumargs;
  }
  {
#line 2355
  proc = (*(((scm_subr *)proc)->cproc))(arg1);
  }
#line 2355
  goto exit;
  case_93: /* CIL Label */ 
#line 2357
  if (! ((long )(20 << 9) + 372L == args)) {
#line 2357
    goto wrongnumargs;
  }
#line 2359
  if (((scm_subr *)proc)->cproc) {
#line 2361
    if (2 & (int )arg1) {
      {
#line 2363
      tmp___9 = (*(((scm_dsubr *)proc)->dproc))((double )(arg1 >> 2));
#line 2363
      proc = scm_makdbl(tmp___9, 0.0);
      }
#line 2363
      goto exit;
    }
#line 2365
    if (! (! (6 & (int )arg1))) {
#line 2365
      goto floerr;
    }
#line 2366
    if (((scm_cell *)arg1)->car == (383L | (1L << 16))) {
      {
#line 2368
      tmp___10 = (*(((scm_dsubr *)proc)->dproc))(*(((scm_dbl *)arg1)->real));
#line 2368
      proc = scm_makdbl(tmp___10, 0.0);
      }
#line 2368
      goto exit;
    }
#line 2371
    if ((65279 & (int )((scm_cell *)arg1)->car) == 639) {
      {
#line 2373
      tmp___11 = scm_big2dbl(arg1);
#line 2373
      tmp___12 = (*(((scm_dsubr *)proc)->dproc))(tmp___11);
#line 2373
      proc = scm_makdbl(tmp___12, 0.0);
      }
#line 2373
      goto exit;
    }
    floerr: 
#line 2376
    if (((scm_cell *)proc)->car >> 8) {
#line 2376
      tmp___13 = (SCM )(scm_heap_org + (((scm_cell *)proc)->car >> 8));
    } else {
#line 2376
      tmp___13 = scm_sys_protects[4];
    }
    {
#line 2376
    scm_wta(arg1, (char *)1, (char *)((scm_cell *)tmp___13)->cdr);
    }
  }
#line 2379
  if (((scm_cell *)proc)->car >> 8) {
#line 2379
    tmp___14 = (SCM )(scm_heap_org + (((scm_cell *)proc)->car >> 8));
  } else {
#line 2379
    tmp___14 = scm_sys_protects[4];
  }
#line 2379
  proc = tmp___14;
#line 2381
  chrs = ((char *)((scm_cell *)proc)->cdr + ((unsigned long )((scm_cell *)proc)->car >> 8)) - 1;
  {
#line 2382
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2382
    chrs --;
#line 2382
    if (! (99 != (int )*chrs)) {
#line 2382
      goto while_break;
    }
#line 2384
    if (! (6 & (int )arg1)) {
#line 2384
      if (! (! (1 & (int )((scm_cell *)arg1)->car))) {
        {
#line 2384
        scm_wta(arg1, (char *)1, (char *)((scm_cell *)proc)->cdr);
        }
      }
    } else {
      {
#line 2384
      scm_wta(arg1, (char *)1, (char *)((scm_cell *)proc)->cdr);
      }
    }
#line 2386
    if (97 == (int )*chrs) {
#line 2386
      arg1 = ((scm_cell *)arg1)->car;
    } else {
#line 2386
      arg1 = ((scm_cell *)arg1)->cdr;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2388
  proc = arg1;
#line 2388
  goto exit;
  case_95: /* CIL Label */ 
  {
#line 2391
  proc = (*(((scm_subr *)proc)->cproc))(arg1, ((scm_cell *)args)->car, ((scm_cell *)((scm_cell *)args)->cdr)->car);
  }
#line 2391
  goto exit;
  case_119: /* CIL Label */ 
#line 2394
  if ((long )(18 << 9) + 372L == arg1) {
#line 2394
    tmp___15 = (long )(20 << 9) + 372L;
  } else {
#line 2394
    tmp___15 = (debug.vect + 0)->a.args;
  }
  {
#line 2394
  proc = (*(((scm_subr *)proc)->cproc))(tmp___15);
  }
#line 2394
  goto exit;
  case_117: /* CIL Label */ 
#line 2399
  if (! (6 & (int )args)) {
#line 2399
    if (! (! (1 & (int )((scm_cell *)args)->car))) {
#line 2399
      goto wrongnumargs;
    }
  } else {
#line 2399
    goto wrongnumargs;
  }
  {
#line 2400
  proc = (*(((scm_subr *)proc)->cproc))(arg1, ((scm_cell *)args)->car, ((scm_cell *)args)->cdr);
  }
#line 2400
  goto exit;
  case_103: /* CIL Label */ 
#line 2402
  if ((long )(20 << 9) + 372L == args) {
    {
#line 2403
    proc = (*(((scm_subr *)proc)->cproc))(arg1, (long )(18 << 9) + 372L);
    }
#line 2403
    goto exit;
  }
  {
#line 2404
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2404
    if (! (! (6 & (int )args))) {
#line 2404
      goto while_break___0;
    }
#line 2406
    if (! (! (1 & (int )((scm_cell *)args)->car))) {
      {
#line 2406
      scm_wta(args, (char *)2, (char *)"apply");
      }
    }
    {
#line 2407
    arg1 = (*(((scm_subr *)proc)->cproc))(arg1, ((scm_cell *)args)->car);
#line 2408
    args = ((scm_cell *)args)->cdr;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2410
  proc = arg1;
#line 2410
  goto exit;
  case_69: /* CIL Label */ 
#line 2412
  if ((long )(20 << 9) + 372L == args) {
#line 2413
    proc = (long )(17 << 9) + 372L;
#line 2413
    goto exit;
  }
  {
#line 2414
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2414
    if (! (! (6 & (int )args))) {
#line 2414
      goto while_break___1;
    }
#line 2416
    if (! (! (1 & (int )((scm_cell *)args)->car))) {
      {
#line 2416
      scm_wta(args, (char *)2, (char *)"apply");
      }
    }
    {
#line 2417
    tmp___16 = (*(((scm_subr *)proc)->cproc))(arg1, ((scm_cell *)args)->car);
    }
#line 2417
    if ((long )(16 << 9) + 372L == tmp___16) {
#line 2418
      proc = (long )(16 << 9) + 372L;
#line 2418
      goto exit;
    }
#line 2419
    arg1 = ((scm_cell *)args)->car;
#line 2420
    args = ((scm_cell *)args)->cdr;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2422
  proc = (long )(17 << 9) + 372L;
#line 2422
  goto exit;
  case_123: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_91: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_59: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_35: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_19: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 2425
  if ((long )(18 << 9) + 372L == arg1) {
#line 2425
    arg1 = (long )(20 << 9) + 372L;
  } else {
#line 2425
    arg1 = (debug.vect + 0)->a.args;
  }
  {
#line 2430
  tmp___17 = scm_badargsp(((scm_cell *)((scm_cell *)(((scm_cell *)proc)->car - 3L))->car)->car,
                          arg1);
  }
#line 2430
  if (tmp___17) {
#line 2431
    goto wrongnumargs;
  }
  {
#line 2433
  args = scm_acons(((scm_cell *)((scm_cell *)(((scm_cell *)proc)->car - 3L))->car)->car,
                   arg1, ((scm_cell *)proc)->cdr);
#line 2434
  proc = ((scm_cell *)(((scm_cell *)proc)->car - 3L))->car;
  }
  {
#line 2435
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2435
    proc = ((scm_cell *)proc)->cdr;
#line 2435
    if (! ((long )(20 << 9) + 372L != proc)) {
#line 2435
      goto while_break___2;
    }
#line 2436
    if ((sizeof(scm_cell ) - 1UL) & (unsigned long )((int )((scm_cell *)proc)->car)) {
#line 2436
      if (6 & (int )((scm_cell *)proc)->car) {
#line 2436
        if (((int )((scm_cell *)proc)->car & 255) == 252) {
          {
#line 2436
          tmp___18 = scm_ilookup(((scm_cell *)proc)->car, args);
#line 2436
          tmp___19 = *tmp___18;
          }
        } else {
#line 2436
          tmp___19 = ((scm_cell *)proc)->car;
        }
#line 2436
        tmp___20 = tmp___19;
      } else {
#line 2436
        tmp___20 = ((scm_cell *)(((scm_cell *)proc)->car - 1L))->cdr;
      }
#line 2436
      arg1 = tmp___20;
    } else {
#line 2436
      if ((125 & (int )((scm_cell *)((scm_cell *)proc)->car)->car) == 5) {
        {
#line 2436
        tmp___21 = scm_lookupcar(proc, args);
#line 2436
        tmp___23 = *tmp___21;
        }
      } else {
        {
#line 2436
        tmp___22 = scm_deval(((scm_cell *)proc)->car, args);
#line 2436
        tmp___23 = tmp___22;
        }
      }
#line 2436
      arg1 = tmp___23;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2437
  proc = arg1;
#line 2437
  goto exit;
  case_61: /* CIL Label */ 
#line 2439
  if (! ((long )(20 << 9) + 372L == args)) {
#line 2439
    goto wrongnumargs;
  }
  {
#line 2440
  scm_call_continuation(proc, arg1);
  }
  case_63: /* CIL Label */ 
#line 2444
  if ((long )(18 << 9) + 372L == arg1) {
#line 2444
    args = (long )(20 << 9) + 372L;
  } else {
#line 2444
    args = (debug.vect + 0)->a.args;
  }
  {
#line 2445
  arg1 = proc;
#line 2446
  proc = *((SCM *)((scm_cell *)proc)->cdr + 0);
#line 2447
  (debug.vect + 0)->a.proc = proc;
#line 2448
  (debug.vect + 0)->a.args = scm_cons(arg1, args);
  }
#line 2454
  goto tail;
  wrongnumargs: 
  {
#line 2457
  scm_wrong_num_args(proc);
  }
  badproc: 
  switch_default: /* CIL Label */ 
  {
#line 2460
  scm_wta(proc, (char *)1, (char *)"apply");
#line 2461
  proc = arg1;
  }
#line 2461
  goto exit;
  switch_break: /* CIL Label */ ;
  }
  exit: 
#line 2465
  if (scm_check_exit_p) {
#line 2466
    if (scm_evaluator_trap_table[2].val) {
#line 2466
      goto _L___0;
    } else
#line 2466
    if (scm_debug_opts[2].val) {
#line 2466
      if ((debug.status & (1L << 8)) != 0L) {
        _L___0: /* CIL Label */ 
#line 2468
        scm_evaluator_trap_table[2].val = 0UL;
#line 2469
        if (scm_evaluator_trap_table[0].val) {
#line 2469
          scm_check_entry_p = 1;
        } else
#line 2469
        if (scm_debug_opts[1].val) {
#line 2469
          scm_check_entry_p = 1;
        }
#line 2469
        if (scm_evaluator_trap_table[1].val) {
#line 2469
          scm_check_apply_p = 1;
        } else
#line 2469
        if (scm_debug_opts[2].val) {
#line 2469
          scm_check_apply_p = 1;
        }
#line 2469
        if (scm_evaluator_trap_table[2].val) {
#line 2469
          scm_check_exit_p = 1;
        } else
#line 2469
        if (scm_debug_opts[2].val) {
#line 2469
          scm_check_exit_p = 1;
        }
#line 2469
        if (scm_debug_opts[10].val) {
#line 2469
          tmp___24 = 1;
        } else
#line 2469
        if (scm_check_entry_p) {
#line 2469
          tmp___24 = 1;
        } else
#line 2469
        if (scm_check_apply_p) {
#line 2469
          tmp___24 = 1;
        } else
#line 2469
        if (scm_check_exit_p) {
#line 2469
          tmp___24 = 1;
        } else {
#line 2469
          tmp___24 = 0;
        }
#line 2469
        scm_debug_mode = tmp___24;
#line 2469
        if (scm_debug_mode) {
#line 2469
          scm_ceval_ptr = & scm_deval;
        } else {
#line 2469
          scm_ceval_ptr = & scm_ceval;
        }
#line 2470
        debug.status &= ~ (1L << 8);
#line 2471
        if (scm_debug_opts[0].val) {
          {
#line 2472
          arg1 = scm_make_debugobj(& debug);
          }
        } else {
          {
#line 2475
          scm_make_cont(& arg1);
#line 2476
          tmp___25 = _setjmp((struct __jmp_buf_tag *)(((scm_contregs *)((char *)((scm_cell *)arg1)->cdr))->jmpbuf));
          }
#line 2476
          if (tmp___25) {
#line 2478
            proc = ((scm_contregs *)((char *)((scm_cell *)arg1)->cdr))->throw_value;
#line 2479
            goto ret;
          }
        }
        {
#line 2482
        tmp___26 = scm_cons2(arg1, proc, (long )(20 << 9) + 372L);
#line 2482
        scm_ithrow(scm_i_exit_frame, tmp___26, 0);
        }
      }
    }
  }
  ret: 
#line 2485
  scm_last_debug_frame = debug.prev;
#line 2486
  return (proc);
}
}
#line 2889 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
void scm_init_eval(void) 
{ 
  SCM tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  SCM tmp___2 ;
  SCM tmp___3 ;
  SCM tmp___4 ;
  SCM tmp___5 ;
  SCM tmp___6 ;
  SCM tmp___7 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
  {
#line 2892
  scm_tc16_promise = scm_newsmob(& promsmob);
#line 2893
  scm_tc16_macro = scm_newsmob(& macrosmob);
#line 2894
  scm_i_apply = scm_make_subr((char *)"apply", 117, (SCM (*)())(& scm_apply));
#line 2895
  scm_root->system_transformer = scm_sysintern((char *)"scm:eval-transformer", (long )(18 << 9) + 372L);
#line 2896
  tmp = scm_sysintern((char *)".", (long )(18 << 9) + 372L);
#line 2896
  scm_i_dot = ((scm_cell *)tmp)->car;
#line 2897
  tmp___0 = scm_sysintern((char *)"=>", (long )(18 << 9) + 372L);
#line 2897
  scm_i_arrow = ((scm_cell *)tmp___0)->car;
#line 2898
  tmp___1 = scm_sysintern((char *)"else", (long )(18 << 9) + 372L);
#line 2898
  scm_i_else = ((scm_cell *)tmp___1)->car;
#line 2899
  tmp___2 = scm_sysintern((char *)"unquote", (long )(18 << 9) + 372L);
#line 2899
  scm_i_unquote = ((scm_cell *)tmp___2)->car;
#line 2900
  tmp___3 = scm_sysintern((char *)"unquote-splicing", (long )(18 << 9) + 372L);
#line 2900
  scm_i_uq_splicing = ((scm_cell *)tmp___3)->car;
#line 2903
  scm_i_quasiquote = scm_make_synt(s_quasiquote, & scm_makacro, (SCM (*)())(& scm_m_quasiquote));
#line 2904
  scm_make_synt(s_undefine, & scm_makacro, (SCM (*)())(& scm_m_undefine));
#line 2905
  scm_make_synt(s_delay, & scm_makacro, (SCM (*)())(& scm_m_delay));
#line 2908
  scm_root->top_level_lookup_closure_var = scm_sysintern((char *)"*top-level-lookup-closure*",
                                                         (long )(16 << 9) + 372L);
#line 2911
  scm_i_and = scm_make_synt((char *)"and", & scm_makmmacro, (SCM (*)())(& scm_m_and));
#line 2912
  scm_i_begin = scm_make_synt((char *)"begin", & scm_makmmacro, (SCM (*)())(& scm_m_begin));
#line 2913
  scm_i_case = scm_make_synt((char *)"case", & scm_makmmacro, (SCM (*)())(& scm_m_case));
#line 2914
  scm_i_cond = scm_make_synt((char *)"cond", & scm_makmmacro, (SCM (*)())(& scm_m_cond));
#line 2915
  scm_i_define = scm_make_synt((char *)"define", & scm_makmmacro, (SCM (*)())(& scm_m_define));
#line 2916
  scm_i_do = scm_make_synt((char *)"do", & scm_makmmacro, (SCM (*)())(& scm_m_do));
#line 2917
  scm_i_if = scm_make_synt((char *)"if", & scm_makmmacro, (SCM (*)())(& scm_m_if));
#line 2918
  scm_i_lambda = scm_make_synt((char *)"lambda", & scm_makmmacro, (SCM (*)())(& scm_m_lambda));
#line 2919
  scm_i_let = scm_make_synt((char *)"let", & scm_makmmacro, (SCM (*)())(& scm_m_let));
#line 2920
  scm_i_letrec = scm_make_synt((char *)"letrec", & scm_makmmacro, (SCM (*)())(& scm_m_letrec));
#line 2921
  scm_i_letstar = scm_make_synt((char *)"let*", & scm_makmmacro, (SCM (*)())(& scm_m_letstar));
#line 2922
  scm_i_or = scm_make_synt((char *)"or", & scm_makmmacro, (SCM (*)())(& scm_m_or));
#line 2923
  scm_i_quote = scm_make_synt((char *)"quote", & scm_makmmacro, (SCM (*)())(& scm_m_quote));
#line 2924
  scm_i_set = scm_make_synt((char *)"set!", & scm_makmmacro, (SCM (*)())(& scm_m_set));
#line 2925
  scm_i_atapply = scm_make_synt((char *)"@apply", & scm_makmmacro, (SCM (*)())(& scm_m_apply));
#line 2926
  scm_i_atcall_cc = scm_make_synt((char *)"@call-with-current-continuation", & scm_makmmacro,
                                  (SCM (*)())(& scm_m_cont));
#line 2930
  tmp___4 = scm_sysintern((char *)"enter-frame", (long )(18 << 9) + 372L);
#line 2930
  scm_i_enter_frame = ((scm_cell *)tmp___4)->car;
#line 2931
  tmp___5 = scm_sysintern((char *)"apply-frame", (long )(18 << 9) + 372L);
#line 2931
  scm_i_apply_frame = ((scm_cell *)tmp___5)->car;
#line 2932
  tmp___6 = scm_sysintern((char *)"exit-frame", (long )(18 << 9) + 372L);
#line 2932
  scm_i_exit_frame = ((scm_cell *)tmp___6)->car;
#line 2933
  tmp___7 = scm_sysintern((char *)"trace", (long )(18 << 9) + 372L);
#line 2933
  scm_i_trace = ((scm_cell *)tmp___7)->car;
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.x"
  scm_make_gsubr(s_procedure_documentation, 1, 0, 0, (SCM (*)())(& scm_procedure_documentation));
#line 2
  scm_make_gsubr(s_nconc2last, 1, 0, 0, (SCM (*)())(& scm_nconc2last));
#line 3
  scm_make_gsubr(s_map, 2, 0, 1, (SCM (*)())(& scm_map));
#line 4
  scm_make_gsubr(s_for_each, 2, 0, 1, (SCM (*)())(& scm_for_each));
#line 5
  scm_make_gsubr(s_makacro, 1, 0, 0, (SCM (*)())(& scm_makacro));
#line 6
  scm_make_gsubr(s_makmacro, 1, 0, 0, (SCM (*)())(& scm_makmacro));
#line 7
  scm_make_gsubr(s_makmmacro, 1, 0, 0, (SCM (*)())(& scm_makmmacro));
#line 8
  scm_make_gsubr(s_force, 1, 0, 0, (SCM (*)())(& scm_force));
#line 9
  scm_make_gsubr(s_promise_p, 1, 0, 0, (SCM (*)())(& scm_promise_p));
#line 10
  scm_make_gsubr(s_copy_tree, 1, 0, 0, (SCM (*)())(& scm_copy_tree));
#line 11
  scm_make_gsubr(s_eval2, 2, 0, 0, (SCM (*)())(& scm_eval2));
#line 12
  scm_make_gsubr(s_eval, 1, 0, 0, (SCM (*)())(& scm_eval));
#line 13
  scm_make_gsubr(s_macro_eval_x, 2, 0, 0, (SCM (*)())(& scm_macro_eval_x));
#line 14
  scm_make_gsubr(s_definedp, 1, 0, 0, (SCM (*)())(& scm_definedp));
  }
#line 2937 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eval.c"
  return;
}
}
#line 819 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 63 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/error.h"
SCM scm_errno(SCM arg ) ;
#line 64
SCM scm_perror(SCM arg ) ;
#line 67
void (*scm_error_callback)(SCM key , char *subr , char *message , SCM args , SCM rest ) ;
#line 72
 __attribute__((__noreturn__)) void scm_sysmissing(char *subr ) ;
#line 64 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/error.c"
int scm_ints_disabled  =    1;
#line 68
static void err_head(char *str ) ;
#line 70 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/error.c"
static void err_head(char *str ) 
{ 
  int oerrno ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 74
  tmp = __errno_location();
#line 74
  oerrno = *tmp;
  }
#line 75
  if (! (6 & (int )scm_root->cur_outp)) {
    {
#line 76
    scm_fflush(scm_root->cur_outp);
    }
  }
  {
#line 77
  scm_gen_putc('\n', scm_root->cur_errp);
#line 87
  scm_fflush(scm_root->cur_errp);
#line 88
  tmp___0 = __errno_location();
#line 88
  *tmp___0 = oerrno;
  }
#line 89
  if (scm_root->cur_errp == scm_root->def_errp) {
    {
#line 91
    tmp___1 = __errno_location();
    }
#line 91
    if (*tmp___1 > 0) {
      {
#line 92
      perror((char const   *)str);
      }
    }
    {
#line 93
    fflush(stderr);
    }
#line 94
    return;
  }
#line 96
  return;
}
}
#line 99 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/error.c"
static char s_errno[6]  = {      (char )'e',      (char )'r',      (char )'r',      (char )'n', 
        (char )'o',      (char )'\000'};
#line 100 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/error.c"
SCM scm_errno(SCM arg ) 
{ 
  int old ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 104
  tmp = __errno_location();
#line 104
  old = *tmp;
  }
#line 105
  if (! ((long )(18 << 9) + 372L == arg)) {
#line 107
    if ((long )(16 << 9) + 372L == arg) {
      {
#line 108
      tmp___0 = __errno_location();
#line 108
      *tmp___0 = 0;
      }
    } else {
      {
#line 110
      tmp___1 = __errno_location();
#line 110
      *tmp___1 = (int )(arg >> 2);
      }
    }
  }
#line 112
  return ((long )(old << 2) + 2L);
}
}
#line 115 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/error.c"
static char s_perror[7]  = {      (char )'p',      (char )'e',      (char )'r',      (char )'r', 
        (char )'o',      (char )'r',      (char )'\000'};
#line 116 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/error.c"
SCM scm_perror(SCM arg ) 
{ 


  {
#line 120
  if (! (6 & (int )arg)) {
#line 120
    if (! ((125 & (int )((scm_cell *)arg)->car) == 21)) {
      {
#line 120
      scm_wta(arg, (char *)1, s_perror);
      }
    }
  } else {
    {
#line 120
    scm_wta(arg, (char *)1, s_perror);
    }
  }
  {
#line 121
  err_head((char *)((scm_cell *)arg)->cdr);
  }
#line 122
  return ((long )(21 << 9) + 372L);
}
}
#line 125 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/error.c"
void (*scm_error_callback)(SCM key , char *subr , char *message , SCM args , SCM rest )  =    (void (*)(SCM key ,
             char *subr , char *message , SCM args , SCM rest ))0;
#line 128
 __attribute__((__noreturn__)) void scm_error(SCM key , char *subr , char *message ,
                                              SCM args , SCM rest ) ;
#line 128 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/error.c"
void scm_error(SCM key , char *subr , char *message , SCM args , SCM rest ) 
{ 
  SCM arg_list ;
  SCM tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  SCM tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 137
  if (scm_error_callback) {
    {
#line 138
    (*scm_error_callback)(key, subr, message, args, rest);
    }
  }
#line 140
  if (message) {
    {
#line 140
    tmp = scm_makfrom0str((char const   *)message);
#line 140
    tmp___0 = tmp;
    }
  } else {
#line 140
    tmp___0 = (long )(16 << 9) + 372L;
  }
#line 140
  if (subr) {
    {
#line 140
    tmp___1 = scm_makfrom0str((char const   *)subr);
#line 140
    tmp___2 = tmp___1;
    }
  } else {
#line 140
    tmp___2 = (long )(16 << 9) + 372L;
  }
  {
#line 140
  arg_list = scm_listify(tmp___2, tmp___0, args, rest, (long )(18 << 9) + 372L);
#line 145
  scm_ithrow(key, arg_list, 1);
#line 149
  write(2, (void const   *)"unhandled system error", sizeof("unhandled system error") - 1UL);
#line 150
  exit(1);
  }
}
}
#line 153 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/error.c"
static SCM scm_system_error_key  =    (long )(16 << 9) + 372L;
#line 154
 __attribute__((__noreturn__)) void scm_syserror(char *subr ) ;
#line 154 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/error.c"
void scm_syserror(char *subr ) 
{ 
  int *tmp ;
  SCM tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  SCM tmp___3 ;
  SCM tmp___4 ;
  char *__cil_tmp8 ;

  {
  {
#line 158
  tmp = __errno_location();
#line 158
  tmp___0 = scm_listify((long )(*tmp << 2) + 2L, (long )(18 << 9) + 372L);
#line 158
  tmp___1 = __errno_location();
#line 158
  tmp___2 = strerror(*tmp___1);
#line 158
  tmp___3 = scm_makfrom0str((char const   *)tmp___2);
#line 158
  tmp___4 = scm_listify(tmp___3, (long )(18 << 9) + 372L);
#line 158
  scm_error(scm_system_error_key, subr, (char *)"%s", tmp___4, tmp___0);
  }
}
}
#line 166
 __attribute__((__noreturn__)) void scm_syserror_msg(char *subr , char *message ,
                                                     SCM args ) ;
#line 166 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/error.c"
void scm_syserror_msg(char *subr , char *message , SCM args ) 
{ 
  int *tmp ;
  SCM tmp___0 ;

  {
  {
#line 172
  tmp = __errno_location();
#line 172
  tmp___0 = scm_listify((long )(*tmp << 2) + 2L, (long )(18 << 9) + 372L);
#line 172
  scm_error(scm_system_error_key, subr, message, args, tmp___0);
  }
}
}
#line 179
 __attribute__((__noreturn__)) void scm_sysmissing(char *subr ) ;
#line 179 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/error.c"
void scm_sysmissing(char *subr ) 
{ 
  SCM tmp ;
  char *tmp___0 ;
  SCM tmp___1 ;
  SCM tmp___2 ;
  char *__cil_tmp6 ;

  {
  {
#line 184
  tmp = scm_listify((long )(38 << 2) + 2L, (long )(18 << 9) + 372L);
#line 184
  tmp___0 = strerror(38);
#line 184
  tmp___1 = scm_makfrom0str((char const   *)tmp___0);
#line 184
  tmp___2 = scm_listify(tmp___1, (long )(18 << 9) + 372L);
#line 184
  scm_error(scm_system_error_key, subr, (char *)"%s", tmp___2, tmp);
  }
}
}
#line 198 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/error.c"
static SCM scm_num_overflow_key  =    (long )(16 << 9) + 372L;
#line 199
 __attribute__((__noreturn__)) void scm_num_overflow(char *subr ) ;
#line 199 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/error.c"
void scm_num_overflow(char *subr ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 203
  scm_error(scm_num_overflow_key, subr, (char *)"Numerical overflow", (long )(16 << 9) + 372L,
            (long )(16 << 9) + 372L);
  }
}
}
#line 210 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/error.c"
static SCM scm_out_of_range_key  =    (long )(16 << 9) + 372L;
#line 211
 __attribute__((__noreturn__)) void scm_out_of_range(char *subr , SCM bad_value ) ;
#line 211 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/error.c"
void scm_out_of_range(char *subr , SCM bad_value ) 
{ 
  SCM tmp ;
  char *__cil_tmp4 ;

  {
  {
#line 216
  tmp = scm_listify(bad_value, (long )(18 << 9) + 372L);
#line 216
  scm_error(scm_out_of_range_key, subr, (char *)"Argument out of range: %S", tmp,
            (long )(16 << 9) + 372L);
  }
}
}
#line 223 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/error.c"
static SCM scm_args_number_key  =    (long )(16 << 9) + 372L;
#line 224
 __attribute__((__noreturn__)) void scm_wrong_num_args(SCM proc ) ;
#line 224 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/error.c"
void scm_wrong_num_args(SCM proc ) 
{ 
  SCM tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 228
  tmp = scm_listify(proc, (long )(18 << 9) + 372L);
#line 228
  scm_error(scm_args_number_key, (char *)((void *)0), (char *)"Wrong number of arguments to %s",
            tmp, (long )(16 << 9) + 372L);
  }
}
}
#line 235 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/error.c"
static SCM scm_arg_type_key  =    (long )(16 << 9) + 372L;
#line 236
 __attribute__((__noreturn__)) void scm_wrong_type_arg(char *subr , int pos , SCM bad_value ) ;
#line 236 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/error.c"
void scm_wrong_type_arg(char *subr , int pos , SCM bad_value ) 
{ 
  SCM tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  char const   *tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 242
  if (pos == 0) {
    {
#line 242
    tmp = scm_listify(bad_value, (long )(18 << 9) + 372L);
#line 242
    tmp___1 = tmp;
    }
  } else {
    {
#line 242
    tmp___0 = scm_listify((long )(pos << 2) + 2L, bad_value, (long )(18 << 9) + 372L);
#line 242
    tmp___1 = tmp___0;
    }
  }
#line 242
  if (pos == 0) {
#line 242
    tmp___2 = "Wrong type argument: %S";
  } else {
#line 242
    tmp___2 = "Wrong type argument in position %s: %S";
  }
  {
#line 242
  scm_error(scm_arg_type_key, subr, (char *)tmp___2, tmp___1, (long )(16 << 9) + 372L);
  }
}
}
#line 251 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/error.c"
static SCM scm_memory_alloc_key  =    (long )(16 << 9) + 372L;
#line 252
 __attribute__((__noreturn__)) void scm_memory_error(char *subr ) ;
#line 252 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/error.c"
void scm_memory_error(char *subr ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 256
  scm_error(scm_memory_alloc_key, subr, (char *)"Memory allocation error", (long )(16 << 9) + 372L,
            (long )(16 << 9) + 372L);
  }
}
}
#line 263 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/error.c"
static SCM scm_misc_error_key  =    (long )(16 << 9) + 372L;
#line 264
 __attribute__((__noreturn__)) void scm_misc_error(char *subr , char *message , SCM args ) ;
#line 264 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/error.c"
void scm_misc_error(char *subr , char *message , SCM args ) 
{ 


  {
  {
#line 270
  scm_error(scm_misc_error_key, subr, message, args, (long )(16 << 9) + 372L);
  }
}
}
#line 274 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/error.c"
SCM scm_wta(SCM arg , char *pos , char *s_subr ) 
{ 
  int error ;
  char *__cil_tmp5 ;

  {
#line 280
  if (! s_subr) {
#line 281
    s_subr = (char *)((void *)0);
  } else
#line 280
  if (! *s_subr) {
#line 281
    s_subr = (char *)((void *)0);
  }
#line 282
  if (-32L & (long )pos) {
    {
#line 285
    scm_misc_error(s_subr, pos, (long )(16 << 9) + 372L);
    }
  } else {
#line 290
    error = (int )((long )pos);
    {
#line 294
    if (error == 0) {
#line 294
      goto case_0;
    }
#line 296
    if (error == 1) {
#line 296
      goto case_1;
    }
#line 298
    if (error == 2) {
#line 298
      goto case_2;
    }
#line 300
    if (error == 3) {
#line 300
      goto case_3;
    }
#line 302
    if (error == 4) {
#line 302
      goto case_4;
    }
#line 304
    if (error == 5) {
#line 304
      goto case_5;
    }
#line 306
    if (error == 8) {
#line 306
      goto case_8;
    }
#line 308
    if (error == 10) {
#line 308
      goto case_10;
    }
#line 310
    if (error == 11) {
#line 310
      goto case_11;
    }
#line 312
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 295
    scm_wrong_type_arg(s_subr, 0, arg);
    }
    case_1: /* CIL Label */ 
    {
#line 297
    scm_wrong_type_arg(s_subr, 1, arg);
    }
    case_2: /* CIL Label */ 
    {
#line 299
    scm_wrong_type_arg(s_subr, 2, arg);
    }
    case_3: /* CIL Label */ 
    {
#line 301
    scm_wrong_type_arg(s_subr, 3, arg);
    }
    case_4: /* CIL Label */ 
    {
#line 303
    scm_wrong_type_arg(s_subr, 4, arg);
    }
    case_5: /* CIL Label */ 
    {
#line 305
    scm_wrong_type_arg(s_subr, 5, arg);
    }
    case_8: /* CIL Label */ 
    {
#line 307
    scm_wrong_num_args(arg);
    }
    case_10: /* CIL Label */ 
    {
#line 309
    scm_out_of_range(s_subr, arg);
    }
    case_11: /* CIL Label */ 
    {
#line 311
    scm_memory_error(s_subr);
    }
    switch_default: /* CIL Label */ 
    {
#line 314
    scm_misc_error(s_subr, (char *)"Unknown error", (long )(16 << 9) + 372L);
    }
    switch_break: /* CIL Label */ ;
    }
  }
#line 317
  return ((long )(21 << 9) + 372L);
}
}
#line 323 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/error.c"
void scm_init_error(void) 
{ 
  SCM tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  SCM tmp___2 ;
  SCM tmp___3 ;
  SCM tmp___4 ;
  SCM tmp___5 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/error.x"
  scm_make_gsubr(s_errno, 0, 1, 0, (SCM (*)())(& scm_errno));
#line 2
  scm_make_gsubr(s_perror, 1, 0, 0, (SCM (*)())(& scm_perror));
#line 3
  tmp = scm_intern0((char *)"system-error");
#line 3
  scm_system_error_key = scm_permanent_object(((scm_cell *)tmp)->car);
#line 4
  tmp___0 = scm_intern0((char *)"numerical-overflow");
#line 4
  scm_num_overflow_key = scm_permanent_object(((scm_cell *)tmp___0)->car);
#line 5
  tmp___1 = scm_intern0((char *)"out-of-range");
#line 5
  scm_out_of_range_key = scm_permanent_object(((scm_cell *)tmp___1)->car);
#line 6
  tmp___2 = scm_intern0((char *)"wrong-number-of-args");
#line 6
  scm_args_number_key = scm_permanent_object(((scm_cell *)tmp___2)->car);
#line 7
  tmp___3 = scm_intern0((char *)"wrong-type-arg");
#line 7
  scm_arg_type_key = scm_permanent_object(((scm_cell *)tmp___3)->car);
#line 8
  tmp___4 = scm_intern0((char *)"memory-allocation-error");
#line 8
  scm_memory_alloc_key = scm_permanent_object(((scm_cell *)tmp___4)->car);
#line 9
  tmp___5 = scm_intern0((char *)"misc-error");
#line 9
  scm_misc_error_key = scm_permanent_object(((scm_cell *)tmp___5)->car);
  }
#line 327 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/error.c"
  return;
}
}
#line 52 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eq.c"
static char s_eq_p___0[4]  = {      (char )'e',      (char )'q',      (char )'?',      (char )'\000'};
#line 54 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eq.c"
SCM scm_eq_p(SCM x , SCM y ) 
{ 
  long tmp ;

  {
#line 59
  if (x == y) {
#line 59
    tmp = (long )(17 << 9) + 372L;
  } else {
#line 59
    tmp = (long )(16 << 9) + 372L;
  }
#line 59
  return (tmp);
}
}
#line 65 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eq.c"
static char s_eqv_p[5]  = {      (char )'e',      (char )'q',      (char )'v',      (char )'?', 
        (char )'\000'};
#line 67 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eq.c"
SCM scm_eqv_p(SCM x , SCM y ) 
{ 
  long tmp___0 ;
  int tmp___1 ;

  {
#line 72
  if (x == y) {
#line 72
    return ((long )(17 << 9) + 372L);
  }
#line 73
  if (6 & (int )x) {
#line 73
    return ((long )(16 << 9) + 372L);
  }
#line 74
  if (6 & (int )y) {
#line 74
    return ((long )(16 << 9) + 372L);
  }
#line 76
  if (((scm_cell *)x)->car != ((scm_cell *)y)->car) {
#line 76
    return ((long )(16 << 9) + 372L);
  }
#line 77
  if ((64767 & (int )((scm_cell *)x)->car) == 127) {
#line 79
    if ((65279 & (int )((scm_cell *)x)->car) == 639) {
      {
#line 79
      tmp___1 = scm_bigcomp(x, y);
      }
#line 79
      if (0 == tmp___1) {
#line 79
        tmp___0 = (long )(17 << 9) + 372L;
      } else {
#line 79
        tmp___0 = (long )(16 << 9) + 372L;
      }
#line 79
      return (tmp___0);
    }
#line 82
    if (*(((scm_dbl *)x)->real) != *(((scm_dbl *)y)->real)) {
#line 82
      return ((long )(16 << 9) + 372L);
    }
#line 83
    if (((scm_cell *)x)->car == ((383L | (1L << 16)) | (2L << 16))) {
#line 83
      if (*((double *)((char *)((scm_cell *)x)->cdr + sizeof(double ))) != *((double *)((char *)((scm_cell *)y)->cdr + sizeof(double )))) {
#line 83
        return ((long )(16 << 9) + 372L);
      }
    }
#line 85
    return ((long )(17 << 9) + 372L);
  }
#line 87
  return ((long )(16 << 9) + 372L);
}
}
#line 91 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eq.c"
static char s_equal_p[7]  = {      (char )'e',      (char )'q',      (char )'u',      (char )'a', 
        (char )'l',      (char )'?',      (char )'\000'};
#line 93 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eq.c"
SCM scm_equal_p(SCM x , SCM y ) 
{ 
  SCM_STACKITEM stack ;
  SCM tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  int i ;
  SCM tmp___2 ;
  SCM tmp___3 ;

  {
#line 98
  if ((unsigned long )(((scm_contregs *)((char *)((scm_cell *)scm_root->rootcont)->cdr))->base - & stack) > scm_debug_opts[11].val * sizeof(SCM_STACKITEM )) {
#line 98
    if (scm_stack_checking_enabled_p) {
      {
#line 98
      scm_report_stack_overflow();
      }
    }
  }
  tailrecurse: 
#line 99
  scm_async_clock --;
#line 99
  if (0U == scm_async_clock) {
    {
#line 99
    scm_async_click();
    }
  }
#line 100
  if (x == y) {
#line 100
    return ((long )(17 << 9) + 372L);
  }
#line 101
  if (6 & (int )x) {
#line 101
    return ((long )(16 << 9) + 372L);
  }
#line 102
  if (6 & (int )y) {
#line 102
    return ((long )(16 << 9) + 372L);
  }
#line 103
  if (! (1 & (int )((scm_cell *)x)->car)) {
#line 103
    if (! (1 & (int )((scm_cell *)y)->car)) {
      {
#line 104
      tmp = scm_equal_p(((scm_cell *)x)->car, ((scm_cell *)y)->car);
      }
#line 104
      if ((long )(16 << 9) + 372L == tmp) {
#line 104
        return ((long )(16 << 9) + 372L);
      }
#line 105
      x = ((scm_cell *)x)->cdr;
#line 106
      y = ((scm_cell *)y)->cdr;
#line 107
      goto tailrecurse;
    }
  }
#line 110
  if (((scm_cell *)x)->car != ((scm_cell *)y)->car) {
#line 110
    return ((long )(16 << 9) + 372L);
  }
  {
#line 116
  if ((127 & (int )((scm_cell *)x)->car) == 21) {
#line 116
    goto case_21;
  }
#line 116
  if ((127 & (int )((scm_cell *)x)->car) == 23) {
#line 116
    goto case_21;
  }
#line 116
  if ((127 & (int )((scm_cell *)x)->car) == 31) {
#line 116
    goto case_21;
  }
#line 116
  if ((127 & (int )((scm_cell *)x)->car) == 29) {
#line 116
    goto case_21;
  }
#line 118
  if ((127 & (int )((scm_cell *)x)->car) == 15) {
#line 118
    goto case_15;
  }
#line 118
  if ((127 & (int )((scm_cell *)x)->car) == 13) {
#line 118
    goto case_15;
  }
#line 120
  if ((127 & (int )((scm_cell *)x)->car) == 127) {
#line 120
    goto case_127;
  }
#line 134
  if ((127 & (int )((scm_cell *)x)->car) == 77) {
#line 134
    goto case_77;
  }
#line 134
  if ((127 & (int )((scm_cell *)x)->car) == 55) {
#line 134
    goto case_77;
  }
#line 134
  if ((127 & (int )((scm_cell *)x)->car) == 47) {
#line 134
    goto case_77;
  }
#line 134
  if ((127 & (int )((scm_cell *)x)->car) == 53) {
#line 134
    goto case_77;
  }
#line 134
  if ((127 & (int )((scm_cell *)x)->car) == 45) {
#line 134
    goto case_77;
  }
#line 134
  if ((127 & (int )((scm_cell *)x)->car) == 79) {
#line 134
    goto case_77;
  }
#line 134
  if ((127 & (int )((scm_cell *)x)->car) == 37) {
#line 134
    goto case_77;
  }
#line 134
  if ((127 & (int )((scm_cell *)x)->car) == 71) {
#line 134
    goto case_77;
  }
#line 112
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 112
  return ((long )(16 << 9) + 372L);
  case_21: /* CIL Label */ 
  case_23: /* CIL Label */ 
  case_31: /* CIL Label */ 
  case_29: /* CIL Label */ 
  {
#line 116
  tmp___0 = scm_string_equal_p(x, y);
  }
#line 116
  return (tmp___0);
  case_15: /* CIL Label */ 
  case_13: /* CIL Label */ 
  {
#line 119
  tmp___1 = scm_vector_equal_p(x, y);
  }
#line 119
  return (tmp___1);
  case_127: /* CIL Label */ 
#line 121
  i = (int )(255L & (((scm_cell *)x)->car >> 8));
#line 122
  if (! ((size_t )i < scm_numsmob)) {
#line 122
    return ((long )(16 << 9) + 372L);
  }
#line 123
  if ((scm_smobs + i)->equalp) {
    {
#line 124
    tmp___2 = (*((scm_smobs + i)->equalp))(x, y);
    }
#line 124
    return (tmp___2);
  } else {
#line 126
    return ((long )(16 << 9) + 372L);
  }
  case_77: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_71: /* CIL Label */ 
#line 135
  if (scm_tc16_array) {
#line 135
    if ((scm_smobs + (255L & (scm_tc16_array >> 8)))->equalp) {
      {
#line 137
      tmp___3 = scm_array_equal_p(x, y);
      }
#line 137
      return (tmp___3);
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 139
  return ((long )(16 << 9) + 372L);
}
}
#line 147 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eq.c"
void scm_init_eq(void) 
{ 


  {
  {
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eq.x"
  scm_make_subr(s_eq_p___0, 69, (SCM (*)())(& scm_eq_p));
#line 2
  scm_make_subr(s_eqv_p, 69, (SCM (*)())(& scm_eqv_p));
#line 3
  scm_make_subr(s_equal_p, 69, (SCM (*)())(& scm_equal_p));
  }
#line 151 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/eq.c"
  return;
}
}
#line 50 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/dynwind.h"
SCM scm_dynamic_wind(SCM thunk1 , SCM thunk2 , SCM thunk3 ) ;
#line 56 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/dynwind.c"
static char s_dynamic_wind[13]  = 
#line 56 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/dynwind.c"
  {      (char )'d',      (char )'y',      (char )'n',      (char )'a', 
        (char )'m',      (char )'i',      (char )'c',      (char )'-', 
        (char )'w',      (char )'i',      (char )'n',      (char )'d', 
        (char )'\000'};
#line 58 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/dynwind.c"
SCM scm_dynamic_wind(SCM thunk1 , SCM thunk2 , SCM thunk3 ) 
{ 
  SCM ans ;

  {
  {
#line 65
  scm_apply(thunk1, (long )(20 << 9) + 372L, (long )(20 << 9) + 372L);
#line 66
  scm_root->dynwinds = scm_acons(thunk1, thunk3, scm_root->dynwinds);
#line 67
  ans = scm_apply(thunk2, (long )(20 << 9) + 372L, (long )(20 << 9) + 372L);
#line 68
  scm_root->dynwinds = ((scm_cell *)scm_root->dynwinds)->cdr;
#line 69
  scm_apply(thunk3, (long )(20 << 9) + 372L, (long )(20 << 9) + 372L);
  }
#line 70
  return (ans);
}
}
#line 74 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/dynwind.c"
void scm_dowinds(SCM to , long delta ) 
{ 
  SCM wind_elt ;
  SCM wind_key ;
  SCM from ;
  SCM wind_elt___0 ;
  SCM wind_key___0 ;

  {
  tail: 
#line 80
  if (! (scm_root->dynwinds == to)) {
#line 81
    if (0L > delta) {
      {
#line 86
      scm_dowinds(((scm_cell *)to)->cdr, 1L + delta);
#line 87
      wind_elt = ((scm_cell *)to)->car;
#line 96
      wind_key = ((scm_cell *)wind_elt)->car;
      }
#line 97
      if (! (6 & (int )wind_key)) {
#line 97
        if (! ((125 & (int )((scm_cell *)wind_key)->car) == 5)) {
#line 97
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 97
      if (wind_key != (long )(16 << 9) + 372L) {
#line 97
        if (wind_key != (long )(17 << 9) + 372L) {
          {
#line 100
          scm_apply(wind_key, (long )(20 << 9) + 372L, (long )(20 << 9) + 372L);
          }
        }
      }
#line 102
      scm_root->dynwinds = to;
    } else {
#line 110
      from = ((scm_cell *)((scm_cell *)scm_root->dynwinds)->car)->cdr;
#line 111
      wind_elt___0 = ((scm_cell *)scm_root->dynwinds)->car;
#line 112
      scm_root->dynwinds = ((scm_cell *)scm_root->dynwinds)->cdr;
#line 121
      wind_key___0 = ((scm_cell *)wind_elt___0)->car;
#line 122
      if (! (6 & (int )wind_key___0)) {
#line 122
        if (! ((125 & (int )((scm_cell *)wind_key___0)->car) == 5)) {
#line 122
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 122
      if (wind_key___0 != (long )(16 << 9) + 372L) {
#line 122
        if (wind_key___0 != (long )(17 << 9) + 372L) {
          {
#line 125
          scm_apply(from, (long )(20 << 9) + 372L, (long )(20 << 9) + 372L);
          }
        }
      }
#line 127
      delta --;
#line 128
      goto tail;
    }
  }
#line 130
  return;
}
}
#line 134 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/dynwind.c"
void scm_init_dynwind(void) 
{ 


  {
  {
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/dynwind.x"
  scm_make_gsubr(s_dynamic_wind, 3, 0, 0, (SCM (*)())(& scm_dynamic_wind));
  }
#line 138 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/dynwind.c"
  return;
}
}
#line 143 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/dynl.c"
void scm_init_dynamic_linking(void) 
{ 


  {
#line 146
  return;
}
}
#line 166 "../libguile/debug.h"
long scm_tc16_debugobj  ;
#line 175 "../libguile/debug.h"
long scm_tc16_memoized  ;
#line 189
SCM scm_debug_object_p(SCM obj ) ;
#line 190
SCM scm_local_eval(SCM exp___0 , SCM env ) ;
#line 191
SCM scm_procedure_environment(SCM proc ) ;
#line 192
SCM scm_procedure_source(SCM proc ) ;
#line 193
SCM scm_procedure_name(SCM proc ) ;
#line 194
SCM scm_memoized_environment(SCM m ) ;
#line 196
SCM scm_memoized_p(SCM obj ) ;
#line 197
SCM scm_single_step(SCM cont , SCM val ) ;
#line 198
SCM scm_evaluator_traps(SCM setting ) ;
#line 199
SCM scm_debug_options(SCM setting ) ;
#line 200
SCM scm_unmemoize(SCM m ) ;
#line 66 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/debug.c"
static char s_debug_options[24]  = 
#line 66 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/debug.c"
  {      (char )'d',      (char )'e',      (char )'b',      (char )'u', 
        (char )'g',      (char )'-',      (char )'o',      (char )'p', 
        (char )'t',      (char )'i',      (char )'o',      (char )'n', 
        (char )'s',      (char )'-',      (char )'i',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'f', 
        (char )'a',      (char )'c',      (char )'e',      (char )'\000'};
#line 68 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/debug.c"
SCM scm_debug_options(SCM setting ) 
{ 
  SCM ans ;
  int tmp ;

  {
  {
#line 73
  scm_ints_disabled = 1;
#line 74
  ans = scm_options(setting, scm_debug_opts, 12, s_debug_options);
  }
#line 79
  if (1UL <= scm_debug_opts[6].val) {
#line 79
    if (! (scm_debug_opts[6].val <= 63UL)) {
      {
#line 81
      scm_options(ans, scm_debug_opts, 12, s_debug_options);
#line 82
      scm_out_of_range(s_debug_options, setting);
      }
    }
  } else {
    {
#line 81
    scm_options(ans, scm_debug_opts, 12, s_debug_options);
#line 82
    scm_out_of_range(s_debug_options, setting);
    }
  }
#line 85
  if (scm_evaluator_trap_table[0].val) {
#line 85
    scm_check_entry_p = 1;
  } else
#line 85
  if (scm_debug_opts[1].val) {
#line 85
    scm_check_entry_p = 1;
  }
#line 85
  if (scm_evaluator_trap_table[1].val) {
#line 85
    scm_check_apply_p = 1;
  } else
#line 85
  if (scm_debug_opts[2].val) {
#line 85
    scm_check_apply_p = 1;
  }
#line 85
  if (scm_evaluator_trap_table[2].val) {
#line 85
    scm_check_exit_p = 1;
  } else
#line 85
  if (scm_debug_opts[2].val) {
#line 85
    scm_check_exit_p = 1;
  }
#line 85
  if (scm_debug_opts[10].val) {
#line 85
    tmp = 1;
  } else
#line 85
  if (scm_check_entry_p) {
#line 85
    tmp = 1;
  } else
#line 85
  if (scm_check_apply_p) {
#line 85
    tmp = 1;
  } else
#line 85
  if (scm_check_exit_p) {
#line 85
    tmp = 1;
  } else {
#line 85
    tmp = 0;
  }
#line 85
  scm_debug_mode = tmp;
#line 85
  if (scm_debug_mode) {
#line 85
    scm_ceval_ptr = & scm_deval;
  } else {
#line 85
    scm_ceval_ptr = & scm_ceval;
  }
#line 86
  scm_debug_eframe_size = (int )(2UL * scm_debug_opts[6].val);
#line 87
  scm_ints_disabled = 0;
#line 87
  scm_async_clock --;
#line 87
  if (0U == scm_async_clock) {
    {
#line 87
    scm_async_click();
    }
  }
#line 88
  return (ans);
}
}
#line 91 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/debug.c"
static char s_evaluator_traps[26]  = 
#line 91
  {      (char )'e',      (char )'v',      (char )'a',      (char )'l', 
        (char )'u',      (char )'a',      (char )'t',      (char )'o', 
        (char )'r',      (char )'-',      (char )'t',      (char )'r', 
        (char )'a',      (char )'p',      (char )'s',      (char )'-', 
        (char )'i',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'f',      (char )'a',      (char )'c', 
        (char )'e',      (char )'\000'};
#line 93 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/debug.c"
SCM scm_evaluator_traps(SCM setting ) 
{ 
  SCM ans ;
  int tmp ;

  {
  {
#line 98
  scm_ints_disabled = 1;
#line 99
  ans = scm_options(setting, scm_evaluator_trap_table, 3, s_evaluator_traps);
  }
#line 103
  if (scm_evaluator_trap_table[0].val) {
#line 103
    scm_check_entry_p = 1;
  } else
#line 103
  if (scm_debug_opts[1].val) {
#line 103
    scm_check_entry_p = 1;
  }
#line 103
  if (scm_evaluator_trap_table[1].val) {
#line 103
    scm_check_apply_p = 1;
  } else
#line 103
  if (scm_debug_opts[2].val) {
#line 103
    scm_check_apply_p = 1;
  }
#line 103
  if (scm_evaluator_trap_table[2].val) {
#line 103
    scm_check_exit_p = 1;
  } else
#line 103
  if (scm_debug_opts[2].val) {
#line 103
    scm_check_exit_p = 1;
  }
#line 103
  if (scm_debug_opts[10].val) {
#line 103
    tmp = 1;
  } else
#line 103
  if (scm_check_entry_p) {
#line 103
    tmp = 1;
  } else
#line 103
  if (scm_check_apply_p) {
#line 103
    tmp = 1;
  } else
#line 103
  if (scm_check_exit_p) {
#line 103
    tmp = 1;
  } else {
#line 103
    tmp = 0;
  }
#line 103
  scm_debug_mode = tmp;
#line 103
  if (scm_debug_mode) {
#line 103
    scm_ceval_ptr = & scm_deval;
  } else {
#line 103
    scm_ceval_ptr = & scm_ceval;
  }
#line 104
  scm_ints_disabled = 0;
#line 104
  scm_async_clock --;
#line 104
  if (0U == scm_async_clock) {
    {
#line 104
    scm_async_click();
    }
  }
#line 105
  return (ans);
}
}
#line 108 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/debug.c"
static char s_single_step[12]  = 
#line 108
  {      (char )'s',      (char )'i',      (char )'n',      (char )'g', 
        (char )'l',      (char )'e',      (char )'-',      (char )'s', 
        (char )'t',      (char )'e',      (char )'p',      (char )'\000'};
#line 110 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/debug.c"
SCM scm_single_step(SCM cont , SCM val ) 
{ 
  int tmp ;

  {
#line 115
  scm_ints_disabled = 1;
#line 116
  scm_evaluator_trap_table[2].val = 1UL;
#line 116
  scm_evaluator_trap_table[0].val = scm_evaluator_trap_table[2].val;
#line 117
  if (scm_evaluator_trap_table[0].val) {
#line 117
    scm_check_entry_p = 1;
  } else
#line 117
  if (scm_debug_opts[1].val) {
#line 117
    scm_check_entry_p = 1;
  }
#line 117
  if (scm_evaluator_trap_table[1].val) {
#line 117
    scm_check_apply_p = 1;
  } else
#line 117
  if (scm_debug_opts[2].val) {
#line 117
    scm_check_apply_p = 1;
  }
#line 117
  if (scm_evaluator_trap_table[2].val) {
#line 117
    scm_check_exit_p = 1;
  } else
#line 117
  if (scm_debug_opts[2].val) {
#line 117
    scm_check_exit_p = 1;
  }
#line 117
  if (scm_debug_opts[10].val) {
#line 117
    tmp = 1;
  } else
#line 117
  if (scm_check_entry_p) {
#line 117
    tmp = 1;
  } else
#line 117
  if (scm_check_apply_p) {
#line 117
    tmp = 1;
  } else
#line 117
  if (scm_check_exit_p) {
#line 117
    tmp = 1;
  } else {
#line 117
    tmp = 0;
  }
#line 117
  scm_debug_mode = tmp;
#line 117
  if (scm_debug_mode) {
#line 117
    scm_ceval_ptr = & scm_deval;
  } else {
#line 117
    scm_ceval_ptr = & scm_ceval;
  }
#line 118
  scm_ints_disabled = 0;
#line 118
  scm_async_clock --;
#line 118
  if (0U == scm_async_clock) {
    {
#line 118
    scm_async_click();
    }
  }
  {
#line 119
  scm_throw(cont, val);
  }
#line 120
  return ((long )(16 << 9) + 372L);
}
}
#line 124 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/debug.c"
static SCM scm_i_source  ;
#line 124 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/debug.c"
static SCM scm_i_more  ;
#line 125 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/debug.c"
static SCM scm_i_proc  ;
#line 125 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/debug.c"
static SCM scm_i_args  ;
#line 125 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/debug.c"
static SCM scm_i_eval_args  ;
#line 126 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/debug.c"
static SCM scm_i_procname  ;
#line 134
static int prinmemoized(SCM obj , SCM port , scm_print_state *pstate ) ;
#line 136 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/debug.c"
static int prinmemoized(SCM obj , SCM port , scm_print_state *pstate ) 
{ 
  int writingp ;
  SCM tmp ;
  char *__cil_tmp6 ;

  {
  {
#line 142
  writingp = (int )pstate->writingp;
#line 143
  scm_gen_puts((enum scm_string_representation_type )0, (char *)"#<memoized ", port);
#line 144
  pstate->writingp = 1UL;
#line 145
  tmp = scm_unmemoize(obj);
#line 145
  scm_iprin1(tmp, port, pstate);
#line 146
  pstate->writingp = (unsigned long )writingp;
#line 147
  scm_gen_putc('>', port);
  }
#line 148
  return (1);
}
}
#line 151 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/debug.c"
static scm_smobfuns memoizedsmob  =    {& scm_markcdr, & scm_free0, & prinmemoized, (SCM (*)(SCM  , SCM  ))0};
#line 154 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/debug.c"
static char s_memoized_p[10]  = 
#line 154
  {      (char )'m',      (char )'e',      (char )'m',      (char )'o', 
        (char )'i',      (char )'z',      (char )'e',      (char )'d', 
        (char )'?',      (char )'\000'};
#line 156 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/debug.c"
SCM scm_memoized_p(SCM obj ) 
{ 
  long tmp ;

  {
#line 160
  if (! (6 & (int )obj)) {
#line 160
    if (scm_tc16_memoized == (long )(65535 & (int )((scm_cell *)obj)->car)) {
#line 160
      tmp = (long )(17 << 9) + 372L;
    } else {
#line 160
      tmp = (long )(16 << 9) + 372L;
    }
  } else {
#line 160
    tmp = (long )(16 << 9) + 372L;
  }
#line 160
  return (tmp);
}
}
#line 163 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/debug.c"
SCM scm_make_memoized(SCM exp___0 , SCM env ) 
{ 
  register SCM z ;
  register SCM ans ;

  {
#line 170
  scm_ints_disabled = 1;
#line 171
  if (6 & (int )scm_freelist) {
    {
#line 171
    z = scm_gc_for_newcell();
    }
  } else {
#line 171
    z = scm_freelist;
#line 171
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 171
    scm_cells_allocated ++;
  }
#line 172
  ((scm_cell *)z)->car = exp___0;
#line 173
  ((scm_cell *)z)->cdr = env;
#line 174
  if (6 & (int )scm_freelist) {
    {
#line 174
    ans = scm_gc_for_newcell();
    }
  } else {
#line 174
    ans = scm_freelist;
#line 174
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 174
    scm_cells_allocated ++;
  }
#line 175
  ((scm_cell *)ans)->car = scm_tc16_memoized;
#line 176
  ((scm_cell *)ans)->cdr = z;
#line 177
  scm_ints_disabled = 0;
#line 177
  scm_async_clock --;
#line 177
  if (0U == scm_async_clock) {
    {
#line 177
    scm_async_click();
    }
  }
#line 178
  return (ans);
}
}
#line 181 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/debug.c"
static char s_unmemoize[10]  = 
#line 181
  {      (char )'u',      (char )'n',      (char )'m',      (char )'e', 
        (char )'m',      (char )'o',      (char )'i',      (char )'z', 
        (char )'e',      (char )'\000'};
#line 183 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/debug.c"
SCM scm_unmemoize(SCM m ) 
{ 
  SCM tmp ;

  {
#line 187
  if (! (6 & (int )m)) {
#line 187
    if (! (scm_tc16_memoized == (long )(65535 & (int )((scm_cell *)m)->car))) {
      {
#line 187
      scm_wta(m, (char *)1, s_unmemoize);
      }
    }
  } else {
    {
#line 187
    scm_wta(m, (char *)1, s_unmemoize);
    }
  }
  {
#line 188
  tmp = scm_unmemocopy(((scm_cell *)((scm_cell *)m)->cdr)->car, ((scm_cell *)((scm_cell *)m)->cdr)->cdr);
  }
#line 188
  return (tmp);
}
}
#line 191 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/debug.c"
static char s_memoized_environment[21]  = 
#line 191
  {      (char )'m',      (char )'e',      (char )'m',      (char )'o', 
        (char )'i',      (char )'z',      (char )'e',      (char )'d', 
        (char )'-',      (char )'e',      (char )'n',      (char )'v', 
        (char )'i',      (char )'r',      (char )'o',      (char )'n', 
        (char )'m',      (char )'e',      (char )'n',      (char )'t', 
        (char )'\000'};
#line 193 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/debug.c"
SCM scm_memoized_environment(SCM m ) 
{ 


  {
#line 197
  if (! (6 & (int )m)) {
#line 197
    if (! (scm_tc16_memoized == (long )(65535 & (int )((scm_cell *)m)->car))) {
      {
#line 197
      scm_wta(m, (char *)1, s_unmemoize);
      }
    }
  } else {
    {
#line 197
    scm_wta(m, (char *)1, s_unmemoize);
    }
  }
#line 198
  return (((scm_cell *)((scm_cell *)m)->cdr)->cdr);
}
}
#line 201 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/debug.c"
static char s_procedure_name[15]  = 
#line 201
  {      (char )'p',      (char )'r',      (char )'o',      (char )'c', 
        (char )'e',      (char )'d',      (char )'u',      (char )'r', 
        (char )'e',      (char )'-',      (char )'n',      (char )'a', 
        (char )'m',      (char )'e',      (char )'\000'};
#line 203 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/debug.c"
SCM scm_procedure_name(SCM proc ) 
{ 
  SCM tmp ;
  SCM name ;
  SCM tmp___0 ;
  SCM tmp___1 ;

  {
  {
#line 207
  tmp = scm_procedure_p(proc);
  }
#line 207
  if (! (tmp == (long )(17 << 9) + 372L)) {
    {
#line 207
    scm_wta(proc, (char *)1, s_procedure_name);
    }
  }
  {
#line 213
  if ((127 & (int )((scm_cell *)proc)->car) == 63) {
#line 213
    goto case_63;
  }
#line 213
  if ((127 & (int )((scm_cell *)proc)->car) == 123) {
#line 213
    goto case_63;
  }
#line 213
  if ((127 & (int )((scm_cell *)proc)->car) == 115) {
#line 213
    goto case_63;
  }
#line 213
  if ((127 & (int )((scm_cell *)proc)->car) == 107) {
#line 213
    goto case_63;
  }
#line 213
  if ((127 & (int )((scm_cell *)proc)->car) == 99) {
#line 213
    goto case_63;
  }
#line 213
  if ((127 & (int )((scm_cell *)proc)->car) == 91) {
#line 213
    goto case_63;
  }
#line 213
  if ((127 & (int )((scm_cell *)proc)->car) == 83) {
#line 213
    goto case_63;
  }
#line 213
  if ((127 & (int )((scm_cell *)proc)->car) == 75) {
#line 213
    goto case_63;
  }
#line 213
  if ((127 & (int )((scm_cell *)proc)->car) == 67) {
#line 213
    goto case_63;
  }
#line 213
  if ((127 & (int )((scm_cell *)proc)->car) == 59) {
#line 213
    goto case_63;
  }
#line 213
  if ((127 & (int )((scm_cell *)proc)->car) == 51) {
#line 213
    goto case_63;
  }
#line 213
  if ((127 & (int )((scm_cell *)proc)->car) == 43) {
#line 213
    goto case_63;
  }
#line 213
  if ((127 & (int )((scm_cell *)proc)->car) == 35) {
#line 213
    goto case_63;
  }
#line 213
  if ((127 & (int )((scm_cell *)proc)->car) == 27) {
#line 213
    goto case_63;
  }
#line 213
  if ((127 & (int )((scm_cell *)proc)->car) == 19) {
#line 213
    goto case_63;
  }
#line 213
  if ((127 & (int )((scm_cell *)proc)->car) == 11) {
#line 213
    goto case_63;
  }
#line 213
  if ((127 & (int )((scm_cell *)proc)->car) == 3) {
#line 213
    goto case_63;
  }
#line 224
  if ((127 & (int )((scm_cell *)proc)->car) == 119) {
#line 224
    goto case_119;
  }
#line 224
  if ((127 & (int )((scm_cell *)proc)->car) == 117) {
#line 224
    goto case_119;
  }
#line 224
  if ((127 & (int )((scm_cell *)proc)->car) == 111) {
#line 224
    goto case_119;
  }
#line 224
  if ((127 & (int )((scm_cell *)proc)->car) == 109) {
#line 224
    goto case_119;
  }
#line 224
  if ((127 & (int )((scm_cell *)proc)->car) == 69) {
#line 224
    goto case_119;
  }
#line 224
  if ((127 & (int )((scm_cell *)proc)->car) == 101) {
#line 224
    goto case_119;
  }
#line 224
  if ((127 & (int )((scm_cell *)proc)->car) == 95) {
#line 224
    goto case_119;
  }
#line 224
  if ((127 & (int )((scm_cell *)proc)->car) == 93) {
#line 224
    goto case_119;
  }
#line 224
  if ((127 & (int )((scm_cell *)proc)->car) == 87) {
#line 224
    goto case_119;
  }
#line 224
  if ((127 & (int )((scm_cell *)proc)->car) == 85) {
#line 224
    goto case_119;
  }
#line 224
  if ((127 & (int )((scm_cell *)proc)->car) == 103) {
#line 224
    goto case_119;
  }
#line 226
  goto switch_default;
  case_63: /* CIL Label */ 
  case_123: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_91: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_59: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_35: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_19: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 215
  tmp___0 = scm_procedure_property(proc, scm_i_name);
#line 215
  name = tmp___0;
  }
#line 222
  return (name);
  case_119: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_95: /* CIL Label */ 
  case_93: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_103: /* CIL Label */ 
#line 225
  if (((scm_cell *)proc)->car >> 8) {
#line 225
    tmp___1 = (SCM )(scm_heap_org + (((scm_cell *)proc)->car >> 8));
  } else {
#line 225
    tmp___1 = scm_sys_protects[4];
  }
#line 225
  return (tmp___1);
  switch_default: /* CIL Label */ 
#line 227
  return ((long )(16 << 9) + 372L);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 231 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/debug.c"
static char s_procedure_source[17]  = 
#line 231
  {      (char )'p',      (char )'r',      (char )'o',      (char )'c', 
        (char )'e',      (char )'d',      (char )'u',      (char )'r', 
        (char )'e',      (char )'-',      (char )'s',      (char )'o', 
        (char )'u',      (char )'r',      (char )'c',      (char )'e', 
        (char )'\000'};
#line 233 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/debug.c"
SCM scm_procedure_source(SCM proc ) 
{ 
  SCM src ;
  SCM tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  SCM tmp___2 ;
  SCM tmp___3 ;

  {
#line 237
  if (! (! (6 & (int )proc))) {
    {
#line 237
    scm_wta(proc, (char *)1, s_procedure_source);
    }
  }
  {
#line 239
  if ((127 & (int )((scm_cell *)proc)->car) == 123) {
#line 239
    goto case_123;
  }
#line 239
  if ((127 & (int )((scm_cell *)proc)->car) == 115) {
#line 239
    goto case_123;
  }
#line 239
  if ((127 & (int )((scm_cell *)proc)->car) == 107) {
#line 239
    goto case_123;
  }
#line 239
  if ((127 & (int )((scm_cell *)proc)->car) == 99) {
#line 239
    goto case_123;
  }
#line 239
  if ((127 & (int )((scm_cell *)proc)->car) == 91) {
#line 239
    goto case_123;
  }
#line 239
  if ((127 & (int )((scm_cell *)proc)->car) == 83) {
#line 239
    goto case_123;
  }
#line 239
  if ((127 & (int )((scm_cell *)proc)->car) == 75) {
#line 239
    goto case_123;
  }
#line 239
  if ((127 & (int )((scm_cell *)proc)->car) == 67) {
#line 239
    goto case_123;
  }
#line 239
  if ((127 & (int )((scm_cell *)proc)->car) == 59) {
#line 239
    goto case_123;
  }
#line 239
  if ((127 & (int )((scm_cell *)proc)->car) == 51) {
#line 239
    goto case_123;
  }
#line 239
  if ((127 & (int )((scm_cell *)proc)->car) == 43) {
#line 239
    goto case_123;
  }
#line 239
  if ((127 & (int )((scm_cell *)proc)->car) == 35) {
#line 239
    goto case_123;
  }
#line 239
  if ((127 & (int )((scm_cell *)proc)->car) == 27) {
#line 239
    goto case_123;
  }
#line 239
  if ((127 & (int )((scm_cell *)proc)->car) == 19) {
#line 239
    goto case_123;
  }
#line 239
  if ((127 & (int )((scm_cell *)proc)->car) == 11) {
#line 239
    goto case_123;
  }
#line 239
  if ((127 & (int )((scm_cell *)proc)->car) == 3) {
#line 239
    goto case_123;
  }
#line 255
  if ((127 & (int )((scm_cell *)proc)->car) == 63) {
#line 255
    goto case_63;
  }
#line 255
  if ((127 & (int )((scm_cell *)proc)->car) == 119) {
#line 255
    goto case_63;
  }
#line 255
  if ((127 & (int )((scm_cell *)proc)->car) == 117) {
#line 255
    goto case_63;
  }
#line 255
  if ((127 & (int )((scm_cell *)proc)->car) == 111) {
#line 255
    goto case_63;
  }
#line 255
  if ((127 & (int )((scm_cell *)proc)->car) == 109) {
#line 255
    goto case_63;
  }
#line 255
  if ((127 & (int )((scm_cell *)proc)->car) == 69) {
#line 255
    goto case_63;
  }
#line 255
  if ((127 & (int )((scm_cell *)proc)->car) == 101) {
#line 255
    goto case_63;
  }
#line 255
  if ((127 & (int )((scm_cell *)proc)->car) == 95) {
#line 255
    goto case_63;
  }
#line 255
  if ((127 & (int )((scm_cell *)proc)->car) == 93) {
#line 255
    goto case_63;
  }
#line 255
  if ((127 & (int )((scm_cell *)proc)->car) == 87) {
#line 255
    goto case_63;
  }
#line 255
  if ((127 & (int )((scm_cell *)proc)->car) == 85) {
#line 255
    goto case_63;
  }
#line 255
  if ((127 & (int )((scm_cell *)proc)->car) == 103) {
#line 255
    goto case_63;
  }
#line 255
  if ((127 & (int )((scm_cell *)proc)->car) == 61) {
#line 255
    goto case_63;
  }
#line 260
  goto switch_default;
  case_123: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_91: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_59: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_35: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_19: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 242
  src = scm_source_property(((scm_cell *)((scm_cell *)(((scm_cell *)proc)->car - 3L))->car)->cdr,
                            scm_i_copy);
  }
#line 243
  if (src != (long )(16 << 9) + 372L) {
    {
#line 244
    tmp = scm_cons2(scm_i_lambda, ((scm_cell *)((scm_cell *)(((scm_cell *)proc)->car - 3L))->car)->car,
                    src);
    }
#line 244
    return (tmp);
  }
  {
#line 245
  src = ((scm_cell *)(((scm_cell *)proc)->car - 3L))->car;
#line 246
  tmp___0 = scm_acons(((scm_cell *)src)->car, (long )(20 << 9) + 372L, ((scm_cell *)proc)->cdr);
#line 246
  tmp___1 = scm_unmemocopy(src, tmp___0);
#line 246
  tmp___2 = scm_cons(scm_i_lambda, tmp___1);
  }
#line 246
  return (tmp___2);
  case_63: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_95: /* CIL Label */ 
  case_93: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_61: /* CIL Label */ 
  {
#line 259
  tmp___3 = scm_procedure_property(proc, scm_i_source);
  }
#line 259
  return (tmp___3);
  switch_default: /* CIL Label */ 
  {
#line 261
  scm_wta(proc, (char *)1, s_procedure_source);
  }
#line 262
  return ((SCM )0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 266 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/debug.c"
static char s_procedure_environment[22]  = 
#line 266
  {      (char )'p',      (char )'r',      (char )'o',      (char )'c', 
        (char )'e',      (char )'d',      (char )'u',      (char )'r', 
        (char )'e',      (char )'-',      (char )'e',      (char )'n', 
        (char )'v',      (char )'i',      (char )'r',      (char )'o', 
        (char )'n',      (char )'m',      (char )'e',      (char )'n', 
        (char )'t',      (char )'\000'};
#line 268 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/debug.c"
SCM scm_procedure_environment(SCM proc ) 
{ 


  {
#line 272
  if (! (! (6 & (int )proc))) {
    {
#line 272
    scm_wta(proc, (char *)1, s_procedure_environment);
    }
  }
  {
#line 274
  if ((127 & (int )((scm_cell *)proc)->car) == 123) {
#line 274
    goto case_123;
  }
#line 274
  if ((127 & (int )((scm_cell *)proc)->car) == 115) {
#line 274
    goto case_123;
  }
#line 274
  if ((127 & (int )((scm_cell *)proc)->car) == 107) {
#line 274
    goto case_123;
  }
#line 274
  if ((127 & (int )((scm_cell *)proc)->car) == 99) {
#line 274
    goto case_123;
  }
#line 274
  if ((127 & (int )((scm_cell *)proc)->car) == 91) {
#line 274
    goto case_123;
  }
#line 274
  if ((127 & (int )((scm_cell *)proc)->car) == 83) {
#line 274
    goto case_123;
  }
#line 274
  if ((127 & (int )((scm_cell *)proc)->car) == 75) {
#line 274
    goto case_123;
  }
#line 274
  if ((127 & (int )((scm_cell *)proc)->car) == 67) {
#line 274
    goto case_123;
  }
#line 274
  if ((127 & (int )((scm_cell *)proc)->car) == 59) {
#line 274
    goto case_123;
  }
#line 274
  if ((127 & (int )((scm_cell *)proc)->car) == 51) {
#line 274
    goto case_123;
  }
#line 274
  if ((127 & (int )((scm_cell *)proc)->car) == 43) {
#line 274
    goto case_123;
  }
#line 274
  if ((127 & (int )((scm_cell *)proc)->car) == 35) {
#line 274
    goto case_123;
  }
#line 274
  if ((127 & (int )((scm_cell *)proc)->car) == 27) {
#line 274
    goto case_123;
  }
#line 274
  if ((127 & (int )((scm_cell *)proc)->car) == 19) {
#line 274
    goto case_123;
  }
#line 274
  if ((127 & (int )((scm_cell *)proc)->car) == 11) {
#line 274
    goto case_123;
  }
#line 274
  if ((127 & (int )((scm_cell *)proc)->car) == 3) {
#line 274
    goto case_123;
  }
#line 279
  if ((127 & (int )((scm_cell *)proc)->car) == 63) {
#line 279
    goto case_63;
  }
#line 279
  if ((127 & (int )((scm_cell *)proc)->car) == 119) {
#line 279
    goto case_63;
  }
#line 279
  if ((127 & (int )((scm_cell *)proc)->car) == 117) {
#line 279
    goto case_63;
  }
#line 279
  if ((127 & (int )((scm_cell *)proc)->car) == 111) {
#line 279
    goto case_63;
  }
#line 279
  if ((127 & (int )((scm_cell *)proc)->car) == 109) {
#line 279
    goto case_63;
  }
#line 279
  if ((127 & (int )((scm_cell *)proc)->car) == 69) {
#line 279
    goto case_63;
  }
#line 279
  if ((127 & (int )((scm_cell *)proc)->car) == 101) {
#line 279
    goto case_63;
  }
#line 279
  if ((127 & (int )((scm_cell *)proc)->car) == 95) {
#line 279
    goto case_63;
  }
#line 279
  if ((127 & (int )((scm_cell *)proc)->car) == 93) {
#line 279
    goto case_63;
  }
#line 279
  if ((127 & (int )((scm_cell *)proc)->car) == 87) {
#line 279
    goto case_63;
  }
#line 279
  if ((127 & (int )((scm_cell *)proc)->car) == 85) {
#line 279
    goto case_63;
  }
#line 279
  if ((127 & (int )((scm_cell *)proc)->car) == 103) {
#line 279
    goto case_63;
  }
#line 279
  if ((127 & (int )((scm_cell *)proc)->car) == 61) {
#line 279
    goto case_63;
  }
#line 282
  goto switch_default;
  case_123: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_91: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_59: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_35: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_19: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 275
  return (((scm_cell *)proc)->cdr);
  case_63: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_95: /* CIL Label */ 
  case_93: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_61: /* CIL Label */ 
#line 281
  return ((long )(20 << 9) + 372L);
  switch_default: /* CIL Label */ 
  {
#line 283
  scm_wta(proc, (char *)1, s_procedure_environment);
  }
#line 284
  return ((SCM )0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 296 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/debug.c"
static char s_local_eval[11]  = 
#line 296
  {      (char )'l',      (char )'o',      (char )'c',      (char )'a', 
        (char )'l',      (char )'-',      (char )'e',      (char )'v', 
        (char )'a',      (char )'l',      (char )'\000'};
#line 298 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/debug.c"
SCM scm_local_eval(SCM exp___0 , SCM env ) 
{ 
  SCM tmp ;
  SCM tmp___0 ;

  {
#line 303
  if ((long )(18 << 9) + 372L == env) {
#line 305
    if (! (6 & (int )exp___0)) {
#line 305
      if (! (scm_tc16_memoized == (long )(65535 & (int )((scm_cell *)exp___0)->car))) {
        {
#line 305
        scm_wta(exp___0, (char *)1, s_local_eval);
        }
      }
    } else {
      {
#line 305
      scm_wta(exp___0, (char *)1, s_local_eval);
      }
    }
    {
#line 306
    tmp = scm_eval_3(((scm_cell *)((scm_cell *)exp___0)->cdr)->car, 0, ((scm_cell *)((scm_cell *)exp___0)->cdr)->cdr);
    }
#line 306
    return (tmp);
  }
  {
#line 308
  tmp___0 = scm_eval_3(exp___0, 1, env);
  }
#line 308
  return (tmp___0);
}
}
#line 311 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/debug.c"
static char s_start_stack[12]  = 
#line 311
  {      (char )'s',      (char )'t',      (char )'a',      (char )'r', 
        (char )'t',      (char )'-',      (char )'s',      (char )'t', 
        (char )'a',      (char )'c',      (char )'k',      (char )'\000'};
#line 312 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/debug.c"
SCM scm_m_start_stack(SCM exp___0 , SCM env ) 
{ 
  SCM answer ;
  scm_debug_frame vframe ;
  scm_debug_info vframe_vect_body ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;

  {
#line 320
  exp___0 = ((scm_cell *)exp___0)->cdr;
#line 321
  if (! (6 & (int )exp___0)) {
#line 321
    if (! (1 & (int )((scm_cell *)exp___0)->car)) {
#line 321
      goto _L___0;
    } else
#line 321
    if (1 == (7 & (int )((scm_cell *)exp___0)->car)) {
      _L___0: /* CIL Label */ 
#line 321
      if (! (6 & (int )((scm_cell *)exp___0)->cdr)) {
#line 321
        if (! (1 & (int )((scm_cell *)((scm_cell *)exp___0)->cdr)->car)) {
#line 321
          goto _L;
        } else
#line 321
        if (1 == (7 & (int )((scm_cell *)((scm_cell *)exp___0)->cdr)->car)) {
          _L: /* CIL Label */ 
#line 321
          if (! ((long )(20 << 9) + 372L == ((scm_cell *)((scm_cell *)exp___0)->cdr)->cdr)) {
            {
#line 321
            scm_wta(exp___0, (char *)8, s_start_stack);
            }
          }
        } else {
          {
#line 321
          scm_wta(exp___0, (char *)8, s_start_stack);
          }
        }
      } else {
        {
#line 321
        scm_wta(exp___0, (char *)8, s_start_stack);
        }
      }
    } else {
      {
#line 321
      scm_wta(exp___0, (char *)8, s_start_stack);
      }
    }
  } else {
    {
#line 321
    scm_wta(exp___0, (char *)8, s_start_stack);
    }
  }
  {
#line 329
  vframe.prev = scm_last_debug_frame;
#line 330
  vframe.status = 2L << 10;
#line 331
  vframe.vect = & vframe_vect_body;
#line 332
  (vframe.vect + 0)->id = scm_eval_car(exp___0, env);
#line 333
  scm_last_debug_frame = & vframe;
#line 334
  answer = scm_eval_car(((scm_cell *)exp___0)->cdr, env);
#line 335
  scm_last_debug_frame = vframe.prev;
  }
#line 336
  return (answer);
}
}
#line 346
static int prindebugobj(SCM obj , SCM port , scm_print_state *pstate ) ;
#line 348 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/debug.c"
static int prindebugobj(SCM obj , SCM port , scm_print_state *pstate ) 
{ 
  char *__cil_tmp4 ;

  {
  {
#line 354
  scm_gen_puts((enum scm_string_representation_type )0, (char *)"#<debug-object ",
               port);
#line 355
  scm_intprint(((scm_cell *)obj)->cdr, 16, port);
#line 356
  scm_gen_putc('>', port);
  }
#line 357
  return (1);
}
}
#line 360 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/debug.c"
static scm_smobfuns debugobjsmob  =    {& scm_mark0, & scm_free0, & prindebugobj, (SCM (*)(SCM  , SCM  ))0};
#line 363 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/debug.c"
static char s_debug_object_p[14]  = 
#line 363
  {      (char )'d',      (char )'e',      (char )'b',      (char )'u', 
        (char )'g',      (char )'-',      (char )'o',      (char )'b', 
        (char )'j',      (char )'e',      (char )'c',      (char )'t', 
        (char )'?',      (char )'\000'};
#line 365 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/debug.c"
SCM scm_debug_object_p(SCM obj ) 
{ 
  long tmp ;

  {
#line 369
  if (! (6 & (int )obj)) {
#line 369
    if (scm_tc16_debugobj == (long )(65535 & (int )((scm_cell *)obj)->car)) {
#line 369
      tmp = (long )(17 << 9) + 372L;
    } else {
#line 369
      tmp = (long )(16 << 9) + 372L;
    }
  } else {
#line 369
    tmp = (long )(16 << 9) + 372L;
  }
#line 369
  return (tmp);
}
}
#line 373 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/debug.c"
SCM scm_make_debugobj(scm_debug_frame *frame ) 
{ 
  register SCM z ;

  {
#line 378
  scm_ints_disabled = 1;
#line 379
  if (6 & (int )scm_freelist) {
    {
#line 379
    z = scm_gc_for_newcell();
    }
  } else {
#line 379
    z = scm_freelist;
#line 379
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 379
    scm_cells_allocated ++;
  }
#line 380
  ((scm_cell *)z)->car = scm_tc16_debugobj;
#line 381
  ((scm_cell *)z)->cdr = (SCM )frame;
#line 382
  scm_ints_disabled = 0;
#line 382
  scm_async_clock --;
#line 382
  if (0U == scm_async_clock) {
    {
#line 382
    scm_async_click();
    }
  }
#line 383
  return (z);
}
}
#line 388 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/debug.c"
static char s_debug_hang[11]  = 
#line 388
  {      (char )'d',      (char )'e',      (char )'b',      (char )'u', 
        (char )'g',      (char )'-',      (char )'h',      (char )'a', 
        (char )'n',      (char )'g',      (char )'\000'};
#line 390 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/debug.c"
SCM scm_debug_hang(SCM obj ) 
{ 
  int go ;

  {
#line 394
  go = 0;
  {
#line 395
  while (1) {
    while_continue: /* CIL Label */ ;
#line 395
    if (! (! go)) {
#line 395
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 396
  return ((long )(21 << 9) + 372L);
}
}
#line 401 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/debug.c"
void scm_init_debug(void) 
{ 
  SCM tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  SCM tmp___2 ;
  SCM tmp___3 ;
  SCM tmp___4 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 404
  scm_init_opts(& scm_debug_options, scm_debug_opts, 12);
#line 405
  scm_init_opts(& scm_evaluator_traps, scm_evaluator_trap_table, 3);
#line 409
  scm_tc16_memoized = scm_newsmob(& memoizedsmob);
#line 410
  scm_tc16_debugobj = scm_newsmob(& debugobjsmob);
#line 412
  tmp = scm_sysintern((char *)"procname", (long )(18 << 9) + 372L);
#line 412
  scm_i_procname = ((scm_cell *)tmp)->car;
#line 413
  tmp___0 = scm_sysintern((char *)"...", (long )(18 << 9) + 372L);
#line 413
  scm_i_more = ((scm_cell *)tmp___0)->car;
#line 414
  tmp___1 = scm_sysintern((char *)"source", (long )(18 << 9) + 372L);
#line 414
  scm_i_source = ((scm_cell *)tmp___1)->car;
#line 415
  tmp___2 = scm_sysintern((char *)"proc", (long )(18 << 9) + 372L);
#line 415
  scm_i_proc = ((scm_cell *)tmp___2)->car;
#line 416
  tmp___3 = scm_sysintern((char *)"args", (long )(18 << 9) + 372L);
#line 416
  scm_i_args = ((scm_cell *)tmp___3)->car;
#line 417
  tmp___4 = scm_sysintern((char *)"eval-args", (long )(18 << 9) + 372L);
#line 417
  scm_i_eval_args = ((scm_cell *)tmp___4)->car;
#line 419
  scm_make_synt(s_start_stack, & scm_makacro, (SCM (*)())(& scm_m_start_stack));
#line 421
  scm_add_feature((char *)"debug-extensions");
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/debug.x"
  scm_make_gsubr(s_debug_options, 0, 1, 0, (SCM (*)())(& scm_debug_options));
#line 2
  scm_make_gsubr(s_evaluator_traps, 0, 1, 0, (SCM (*)())(& scm_evaluator_traps));
#line 3
  scm_make_gsubr(s_single_step, 2, 0, 0, (SCM (*)())(& scm_single_step));
#line 4
  scm_make_gsubr(s_memoized_p, 1, 0, 0, (SCM (*)())(& scm_memoized_p));
#line 5
  scm_make_gsubr(s_unmemoize, 1, 0, 0, (SCM (*)())(& scm_unmemoize));
#line 6
  scm_make_gsubr(s_memoized_environment, 1, 0, 0, (SCM (*)())(& scm_memoized_environment));
#line 7
  scm_make_gsubr(s_procedure_name, 1, 0, 0, (SCM (*)())(& scm_procedure_name));
#line 8
  scm_make_gsubr(s_procedure_source, 1, 0, 0, (SCM (*)())(& scm_procedure_source));
#line 9
  scm_make_gsubr(s_procedure_environment, 1, 0, 0, (SCM (*)())(& scm_procedure_environment));
#line 10
  scm_make_gsubr(s_local_eval, 1, 1, 0, (SCM (*)())(& scm_local_eval));
#line 11
  scm_make_gsubr(s_debug_object_p, 1, 0, 0, (SCM (*)())(& scm_debug_object_p));
#line 12
  scm_make_gsubr(s_debug_hang, 0, 1, 0, (SCM (*)())(& scm_debug_hang));
  }
#line 424 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/debug.c"
  return;
}
}
#line 74 "../libguile/continuations.h"
void scm_dynthrow(SCM *a ) ;
#line 57 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/continuations.c"
static char s_cont[13]  = 
#line 57 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/continuations.c"
  {      (char )'c',      (char )'o',      (char )'n',      (char )'t', 
        (char )'i',      (char )'n',      (char )'u',      (char )'a', 
        (char )'t',      (char )'i',      (char )'o',      (char )'n', 
        (char )'\000'};
#line 60 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/continuations.c"
SCM scm_make_cont(SCM *answer ) 
{ 
  long j ;
  SCM cont ;
  register SCM_STACKITEM *src ;
  register SCM_STACKITEM *dst ;
  char *tmp ;
  SCM_STACKITEM *tmp___0 ;
  SCM_STACKITEM *tmp___1 ;
  SCM_STACKITEM *tmp___2 ;

  {
#line 95
  if (6 & (int )scm_freelist) {
    {
#line 95
    cont = scm_gc_for_newcell();
    }
  } else {
#line 95
    cont = scm_freelist;
#line 95
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 95
    scm_cells_allocated ++;
  }
  {
#line 96
  *answer = cont;
#line 97
  scm_ints_disabled = 1;
#line 99
  j = scm_stack_size(((scm_contregs *)((char *)((scm_cell *)scm_root->rootcont)->cdr))->base);
#line 100
  tmp = scm_must_malloc((long )(sizeof(scm_contregs ) + (unsigned long )j * sizeof(SCM_STACKITEM )),
                        s_cont);
#line 100
  ((scm_cell *)cont)->cdr = (SCM )tmp;
#line 103
  ((scm_cell *)cont)->car = (j << 8) + 61L;
#line 104
  ((scm_contregs *)((char *)((scm_cell *)cont)->cdr))->dynenv = scm_root->dynwinds;
#line 105
  ((scm_contregs *)((char *)((scm_cell *)cont)->cdr))->throw_value = (long )(20 << 9) + 372L;
#line 106
  tmp___0 = ((scm_contregs *)((char *)((scm_cell *)scm_root->rootcont)->cdr))->base;
#line 106
  ((scm_contregs *)((char *)((scm_cell *)cont)->cdr))->base = tmp___0;
#line 106
  src = tmp___0;
#line 107
  ((scm_contregs *)((char *)((scm_cell *)cont)->cdr))->seq = ((scm_contregs *)((char *)((scm_cell *)scm_root->rootcont)->cdr))->seq;
#line 108
  scm_ints_disabled = 0;
#line 108
  scm_async_clock --;
  }
#line 108
  if (0U == scm_async_clock) {
    {
#line 108
    scm_async_click();
    }
  }
#line 110
  src -= (unsigned long )((scm_cell *)cont)->car >> 8;
#line 112
  dst = (SCM_STACKITEM *)((char *)((scm_cell *)cont)->cdr + sizeof(scm_contregs ));
#line 113
  j = (long )((unsigned long )((scm_cell *)cont)->car >> 8);
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    j --;
#line 113
    if (! (0L <= j)) {
#line 113
      goto while_break;
    }
#line 114
    tmp___1 = dst;
#line 114
    dst ++;
#line 114
    tmp___2 = src;
#line 114
    src ++;
#line 114
    *tmp___1 = *tmp___2;
  }
  while_break: /* CIL Label */ ;
  }
#line 117
  ((scm_contregs *)((char *)((scm_cell *)cont)->cdr))->dframe = scm_last_debug_frame;
#line 119
  return (cont);
}
}
#line 126
static void grow_throw(SCM *a ) ;
#line 128 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/continuations.c"
static void grow_throw(SCM *a ) 
{ 
  SCM growth[100] ;
  void *__cil_tmp3 ;

  {
  {
#line 133
  growth[0] = *(a + 0);
#line 134
  growth[1] = *(a + 1);
#line 135
  growth[2] = *(a + 2) + 1L;
#line 136
  growth[3] = (SCM )a;
#line 137
  scm_dynthrow(growth);
  }
#line 138
  return;
}
}
#line 142 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/continuations.c"
void scm_dynthrow(SCM *a ) 
{ 
  SCM cont ;
  SCM val ;
  register long j ;
  register SCM_STACKITEM *src ;
  register SCM_STACKITEM *dst ;
  SCM_STACKITEM *tmp ;
  SCM_STACKITEM *tmp___0 ;
  char *__cil_tmp9 ;

  {
#line 146
  cont = *(a + 0);
#line 146
  val = *(a + 1);
#line 149
  dst = ((scm_contregs *)((char *)((scm_cell *)scm_root->rootcont)->cdr))->base;
#line 153
  if (*(a + 2)) {
#line 153
    if ((SCM *)*(a + 3) - a < 100L) {
      {
#line 155
      fputs((char const   */* __restrict  */)"grow_throw: check if SCM growth[100]; being optimized out\n",
            (FILE */* __restrict  */)stderr);
      }
    }
  }
#line 163
  dst -= (unsigned long )((scm_cell *)cont)->car >> 8;
#line 164
  if (! ((unsigned long )((SCM_STACKITEM *)(& a)) < (unsigned long )dst)) {
    {
#line 165
    grow_throw(a);
    }
  }
#line 168
  src = (SCM_STACKITEM *)((char *)((scm_cell *)cont)->cdr + sizeof(scm_contregs ));
#line 169
  j = (long )((unsigned long )((scm_cell *)cont)->car >> 8);
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    j --;
#line 169
    if (! (0L <= j)) {
#line 169
      goto while_break;
    }
#line 170
    tmp = dst;
#line 170
    dst ++;
#line 170
    tmp___0 = src;
#line 170
    src ++;
#line 170
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 178
  scm_last_debug_frame = ((scm_contregs *)((char *)((scm_cell *)cont)->cdr))->dframe;
#line 180
  ((scm_contregs *)((char *)((scm_cell *)cont)->cdr))->throw_value = val;
#line 181
  longjmp((struct __jmp_buf_tag *)(((scm_contregs *)((char *)((scm_cell *)cont)->cdr))->jmpbuf),
          1);
  }
}
}
#line 185 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/continuations.c"
SCM scm_call_continuation(SCM cont , SCM val ) 
{ 
  SCM a[3] ;
  long tmp ;
  long tmp___0 ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 191
  a[0] = cont;
#line 192
  a[1] = val;
#line 193
  a[2] = (SCM )0;
#line 194
  if (((scm_contregs *)((char *)((scm_cell *)cont)->cdr))->seq != ((scm_contregs *)((char *)((scm_cell *)scm_root->rootcont)->cdr))->seq) {
    {
#line 196
    scm_wta(cont, (char *)"continuation from wrong top level", s_cont);
    }
  } else
#line 194
  if ((unsigned long )((scm_contregs *)((char *)((scm_cell *)cont)->cdr))->base != (unsigned long )((scm_contregs *)((char *)((scm_cell *)scm_root->rootcont)->cdr))->base) {
    {
#line 196
    scm_wta(cont, (char *)"continuation from wrong top level", s_cont);
    }
  }
  {
#line 198
  tmp = scm_ilength(scm_root->dynwinds);
#line 198
  tmp___0 = scm_ilength(((scm_contregs *)((char *)((scm_cell *)cont)->cdr))->dynenv);
#line 198
  scm_dowinds(((scm_contregs *)((char *)((scm_cell *)cont)->cdr))->dynenv, tmp - tmp___0);
#line 201
  scm_dynthrow(a);
  }
#line 202
  return ((long )(21 << 9) + 372L);
}
}
#line 207 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/continuations.c"
void scm_init_continuations(void) 
{ 


  {
#line 211
  return;
}
}
#line 64 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.h"
SCM scm_char_p(SCM x ) ;
#line 65
SCM scm_char_eq_p(SCM x , SCM y ) ;
#line 66
SCM scm_char_less_p(SCM x , SCM y ) ;
#line 67
SCM scm_char_leq_p(SCM x , SCM y ) ;
#line 68
SCM scm_char_gr_p(SCM x , SCM y ) ;
#line 69
SCM scm_char_geq_p(SCM x , SCM y ) ;
#line 70
SCM scm_char_ci_eq_p(SCM x , SCM y ) ;
#line 71
SCM scm_char_ci_less_p(SCM x , SCM y ) ;
#line 72
SCM scm_char_ci_leq_p(SCM x , SCM y ) ;
#line 73
SCM scm_char_ci_gr_p(SCM x , SCM y ) ;
#line 74
SCM scm_char_ci_geq_p(SCM x , SCM y ) ;
#line 75
SCM scm_char_alphabetic_p(SCM chr ) ;
#line 76
SCM scm_char_numeric_p(SCM chr ) ;
#line 77
SCM scm_char_whitespace_p(SCM chr ) ;
#line 78
SCM scm_char_upper_case_p(SCM chr ) ;
#line 79
SCM scm_char_lower_case_p(SCM chr ) ;
#line 80
SCM scm_char_is_both_p(SCM chr ) ;
#line 81
SCM scm_char_to_integer(SCM chr ) ;
#line 82
SCM scm_integer_to_char(SCM n ) ;
#line 83
SCM scm_char_upcase(SCM chr ) ;
#line 84
SCM scm_char_downcase(SCM chr ) ;
#line 52 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
static char s_char_p[6]  = {      (char )'c',      (char )'h',      (char )'a',      (char )'r', 
        (char )'?',      (char )'\000'};
#line 54 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
SCM scm_char_p(SCM x ) 
{ 
  long tmp ;

  {
#line 58
  if (((int )x & 255) == 244) {
#line 58
    tmp = (long )(17 << 9) + 372L;
  } else {
#line 58
    tmp = (long )(16 << 9) + 372L;
  }
#line 58
  return (tmp);
}
}
#line 61 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
static char s_char_eq_p[7]  = {      (char )'c',      (char )'h',      (char )'a',      (char )'r', 
        (char )'=',      (char )'?',      (char )'\000'};
#line 63 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
SCM scm_char_eq_p(SCM x , SCM y ) 
{ 
  long tmp ;

  {
#line 68
  if (! (((int )x & 255) == 244)) {
    {
#line 68
    scm_wta(x, (char *)1, s_char_eq_p);
    }
  }
#line 69
  if (! (((int )y & 255) == 244)) {
    {
#line 69
    scm_wta(y, (char *)2, s_char_eq_p);
    }
  }
#line 70
  if ((unsigned int )(x >> 8) == (unsigned int )(y >> 8)) {
#line 70
    tmp = (long )(17 << 9) + 372L;
  } else {
#line 70
    tmp = (long )(16 << 9) + 372L;
  }
#line 70
  return (tmp);
}
}
#line 74 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
static char s_char_less_p[7]  = {      (char )'c',      (char )'h',      (char )'a',      (char )'r', 
        (char )'<',      (char )'?',      (char )'\000'};
#line 76 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
SCM scm_char_less_p(SCM x , SCM y ) 
{ 
  long tmp ;

  {
#line 81
  if (! (((int )x & 255) == 244)) {
    {
#line 81
    scm_wta(x, (char *)1, s_char_less_p);
    }
  }
#line 82
  if (! (((int )y & 255) == 244)) {
    {
#line 82
    scm_wta(y, (char *)2, s_char_less_p);
    }
  }
#line 83
  if ((unsigned int )(x >> 8) < (unsigned int )(y >> 8)) {
#line 83
    tmp = (long )(17 << 9) + 372L;
  } else {
#line 83
    tmp = (long )(16 << 9) + 372L;
  }
#line 83
  return (tmp);
}
}
#line 86 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
static char s_char_leq_p[8]  = 
#line 86
  {      (char )'c',      (char )'h',      (char )'a',      (char )'r', 
        (char )'<',      (char )'=',      (char )'?',      (char )'\000'};
#line 88 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
SCM scm_char_leq_p(SCM x , SCM y ) 
{ 
  long tmp ;

  {
#line 93
  if (! (((int )x & 255) == 244)) {
    {
#line 93
    scm_wta(x, (char *)1, s_char_leq_p);
    }
  }
#line 94
  if (! (((int )y & 255) == 244)) {
    {
#line 94
    scm_wta(y, (char *)2, s_char_leq_p);
    }
  }
#line 95
  if ((unsigned int )(x >> 8) <= (unsigned int )(y >> 8)) {
#line 95
    tmp = (long )(17 << 9) + 372L;
  } else {
#line 95
    tmp = (long )(16 << 9) + 372L;
  }
#line 95
  return (tmp);
}
}
#line 98 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
static char s_char_gr_p[7]  = {      (char )'c',      (char )'h',      (char )'a',      (char )'r', 
        (char )'>',      (char )'?',      (char )'\000'};
#line 100 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
SCM scm_char_gr_p(SCM x , SCM y ) 
{ 
  long tmp ;

  {
#line 105
  if (! (((int )x & 255) == 244)) {
    {
#line 105
    scm_wta(x, (char *)1, s_char_gr_p);
    }
  }
#line 106
  if (! (((int )y & 255) == 244)) {
    {
#line 106
    scm_wta(y, (char *)2, s_char_gr_p);
    }
  }
#line 107
  if ((unsigned int )(x >> 8) > (unsigned int )(y >> 8)) {
#line 107
    tmp = (long )(17 << 9) + 372L;
  } else {
#line 107
    tmp = (long )(16 << 9) + 372L;
  }
#line 107
  return (tmp);
}
}
#line 110 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
static char s_char_geq_p[8]  = 
#line 110
  {      (char )'c',      (char )'h',      (char )'a',      (char )'r', 
        (char )'>',      (char )'=',      (char )'?',      (char )'\000'};
#line 112 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
SCM scm_char_geq_p(SCM x , SCM y ) 
{ 
  long tmp ;

  {
#line 117
  if (! (((int )x & 255) == 244)) {
    {
#line 117
    scm_wta(x, (char *)1, s_char_geq_p);
    }
  }
#line 118
  if (! (((int )y & 255) == 244)) {
    {
#line 118
    scm_wta(y, (char *)2, s_char_geq_p);
    }
  }
#line 119
  if ((unsigned int )(x >> 8) >= (unsigned int )(y >> 8)) {
#line 119
    tmp = (long )(17 << 9) + 372L;
  } else {
#line 119
    tmp = (long )(16 << 9) + 372L;
  }
#line 119
  return (tmp);
}
}
#line 122 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
static char s_char_ci_eq_p[10]  = 
#line 122
  {      (char )'c',      (char )'h',      (char )'a',      (char )'r', 
        (char )'-',      (char )'c',      (char )'i',      (char )'=', 
        (char )'?',      (char )'\000'};
#line 124 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
SCM scm_char_ci_eq_p(SCM x , SCM y ) 
{ 
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 129
  if (! (((int )x & 255) == 244)) {
    {
#line 129
    scm_wta(x, (char *)1, s_char_ci_eq_p);
    }
  }
#line 130
  if (! (((int )y & 255) == 244)) {
    {
#line 130
    scm_wta(y, (char *)2, s_char_ci_eq_p);
    }
  }
  {
#line 131
  tmp___2 = scm_upcase((unsigned int )(x >> 8));
#line 131
  tmp___3 = scm_upcase((unsigned int )(y >> 8));
  }
#line 131
  if (tmp___2 == tmp___3) {
#line 131
    tmp___1 = (long )(17 << 9) + 372L;
  } else {
#line 131
    tmp___1 = (long )(16 << 9) + 372L;
  }
#line 131
  return (tmp___1);
}
}
#line 134 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
static char s_char_ci_less_p[10]  = 
#line 134
  {      (char )'c',      (char )'h',      (char )'a',      (char )'r', 
        (char )'-',      (char )'c',      (char )'i',      (char )'<', 
        (char )'?',      (char )'\000'};
#line 136 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
SCM scm_char_ci_less_p(SCM x , SCM y ) 
{ 
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 141
  if (! (((int )x & 255) == 244)) {
    {
#line 141
    scm_wta(x, (char *)1, s_char_ci_less_p);
    }
  }
#line 142
  if (! (((int )y & 255) == 244)) {
    {
#line 142
    scm_wta(y, (char *)2, s_char_ci_less_p);
    }
  }
  {
#line 143
  tmp___2 = scm_upcase((unsigned int )(x >> 8));
#line 143
  tmp___3 = scm_upcase((unsigned int )(y >> 8));
  }
#line 143
  if (tmp___2 < tmp___3) {
#line 143
    tmp___1 = (long )(17 << 9) + 372L;
  } else {
#line 143
    tmp___1 = (long )(16 << 9) + 372L;
  }
#line 143
  return (tmp___1);
}
}
#line 146 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
static char s_char_ci_leq_p[11]  = 
#line 146
  {      (char )'c',      (char )'h',      (char )'a',      (char )'r', 
        (char )'-',      (char )'c',      (char )'i',      (char )'<', 
        (char )'=',      (char )'?',      (char )'\000'};
#line 148 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
SCM scm_char_ci_leq_p(SCM x , SCM y ) 
{ 
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 153
  if (! (((int )x & 255) == 244)) {
    {
#line 153
    scm_wta(x, (char *)1, s_char_ci_leq_p);
    }
  }
#line 154
  if (! (((int )y & 255) == 244)) {
    {
#line 154
    scm_wta(y, (char *)2, s_char_ci_leq_p);
    }
  }
  {
#line 155
  tmp___2 = scm_upcase((unsigned int )(x >> 8));
#line 155
  tmp___3 = scm_upcase((unsigned int )(y >> 8));
  }
#line 155
  if (tmp___2 <= tmp___3) {
#line 155
    tmp___1 = (long )(17 << 9) + 372L;
  } else {
#line 155
    tmp___1 = (long )(16 << 9) + 372L;
  }
#line 155
  return (tmp___1);
}
}
#line 158 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
static char s_char_ci_gr_p[10]  = 
#line 158
  {      (char )'c',      (char )'h',      (char )'a',      (char )'r', 
        (char )'-',      (char )'c',      (char )'i',      (char )'>', 
        (char )'?',      (char )'\000'};
#line 160 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
SCM scm_char_ci_gr_p(SCM x , SCM y ) 
{ 
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 165
  if (! (((int )x & 255) == 244)) {
    {
#line 165
    scm_wta(x, (char *)1, s_char_ci_gr_p);
    }
  }
#line 166
  if (! (((int )y & 255) == 244)) {
    {
#line 166
    scm_wta(y, (char *)2, s_char_ci_gr_p);
    }
  }
  {
#line 167
  tmp___2 = scm_upcase((unsigned int )(x >> 8));
#line 167
  tmp___3 = scm_upcase((unsigned int )(y >> 8));
  }
#line 167
  if (tmp___2 > tmp___3) {
#line 167
    tmp___1 = (long )(17 << 9) + 372L;
  } else {
#line 167
    tmp___1 = (long )(16 << 9) + 372L;
  }
#line 167
  return (tmp___1);
}
}
#line 170 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
static char s_char_ci_geq_p[11]  = 
#line 170
  {      (char )'c',      (char )'h',      (char )'a',      (char )'r', 
        (char )'-',      (char )'c',      (char )'i',      (char )'>', 
        (char )'=',      (char )'?',      (char )'\000'};
#line 172 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
SCM scm_char_ci_geq_p(SCM x , SCM y ) 
{ 
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 177
  if (! (((int )x & 255) == 244)) {
    {
#line 177
    scm_wta(x, (char *)1, s_char_ci_geq_p);
    }
  }
#line 178
  if (! (((int )y & 255) == 244)) {
    {
#line 178
    scm_wta(y, (char *)2, s_char_ci_geq_p);
    }
  }
  {
#line 179
  tmp___2 = scm_upcase((unsigned int )(x >> 8));
#line 179
  tmp___3 = scm_upcase((unsigned int )(y >> 8));
  }
#line 179
  if (tmp___2 >= tmp___3) {
#line 179
    tmp___1 = (long )(17 << 9) + 372L;
  } else {
#line 179
    tmp___1 = (long )(16 << 9) + 372L;
  }
#line 179
  return (tmp___1);
}
}
#line 183 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
static char s_char_alphabetic_p[17]  = 
#line 183
  {      (char )'c',      (char )'h',      (char )'a',      (char )'r', 
        (char )'-',      (char )'a',      (char )'l',      (char )'p', 
        (char )'h',      (char )'a',      (char )'b',      (char )'e', 
        (char )'t',      (char )'i',      (char )'c',      (char )'?', 
        (char )'\000'};
#line 185 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
SCM scm_char_alphabetic_p(SCM chr ) 
{ 
  long tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 189
  if (! (((int )chr & 255) == 244)) {
    {
#line 189
    scm_wta(chr, (char *)1, s_char_alphabetic_p);
    }
  }
#line 190
  if (((unsigned int )(chr >> 8) & 4294967168U) == 0U) {
    {
#line 190
    tmp___1 = __ctype_b_loc();
    }
#line 190
    if ((int const   )*(*tmp___1 + (int )((unsigned int )(chr >> 8))) & 1024) {
#line 190
      tmp___0 = (long )(17 << 9) + 372L;
    } else {
#line 190
      tmp___0 = (long )(16 << 9) + 372L;
    }
  } else {
#line 190
    tmp___0 = (long )(16 << 9) + 372L;
  }
#line 190
  return (tmp___0);
}
}
#line 193 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
static char s_char_numeric_p[14]  = 
#line 193
  {      (char )'c',      (char )'h',      (char )'a',      (char )'r', 
        (char )'-',      (char )'n',      (char )'u',      (char )'m', 
        (char )'e',      (char )'r',      (char )'i',      (char )'c', 
        (char )'?',      (char )'\000'};
#line 195 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
SCM scm_char_numeric_p(SCM chr ) 
{ 
  long tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 199
  if (! (((int )chr & 255) == 244)) {
    {
#line 199
    scm_wta(chr, (char *)1, s_char_numeric_p);
    }
  }
#line 200
  if (((unsigned int )(chr >> 8) & 4294967168U) == 0U) {
    {
#line 200
    tmp___1 = __ctype_b_loc();
    }
#line 200
    if ((int const   )*(*tmp___1 + (int )((unsigned int )(chr >> 8))) & 2048) {
#line 200
      tmp___0 = (long )(17 << 9) + 372L;
    } else {
#line 200
      tmp___0 = (long )(16 << 9) + 372L;
    }
  } else {
#line 200
    tmp___0 = (long )(16 << 9) + 372L;
  }
#line 200
  return (tmp___0);
}
}
#line 203 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
static char s_char_whitespace_p[17]  = 
#line 203
  {      (char )'c',      (char )'h',      (char )'a',      (char )'r', 
        (char )'-',      (char )'w',      (char )'h',      (char )'i', 
        (char )'t',      (char )'e',      (char )'s',      (char )'p', 
        (char )'a',      (char )'c',      (char )'e',      (char )'?', 
        (char )'\000'};
#line 205 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
SCM scm_char_whitespace_p(SCM chr ) 
{ 
  long tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 209
  if (! (((int )chr & 255) == 244)) {
    {
#line 209
    scm_wta(chr, (char *)1, s_char_whitespace_p);
    }
  }
#line 210
  if (((unsigned int )(chr >> 8) & 4294967168U) == 0U) {
    {
#line 210
    tmp___1 = __ctype_b_loc();
    }
#line 210
    if ((int const   )*(*tmp___1 + (int )((unsigned int )(chr >> 8))) & 8192) {
#line 210
      tmp___0 = (long )(17 << 9) + 372L;
    } else {
#line 210
      tmp___0 = (long )(16 << 9) + 372L;
    }
  } else {
#line 210
    tmp___0 = (long )(16 << 9) + 372L;
  }
#line 210
  return (tmp___0);
}
}
#line 215 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
static char s_char_upper_case_p[17]  = 
#line 215
  {      (char )'c',      (char )'h',      (char )'a',      (char )'r', 
        (char )'-',      (char )'u',      (char )'p',      (char )'p', 
        (char )'e',      (char )'r',      (char )'-',      (char )'c', 
        (char )'a',      (char )'s',      (char )'e',      (char )'?', 
        (char )'\000'};
#line 217 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
SCM scm_char_upper_case_p(SCM chr ) 
{ 
  long tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 221
  if (! (((int )chr & 255) == 244)) {
    {
#line 221
    scm_wta(chr, (char *)1, s_char_upper_case_p);
    }
  }
#line 222
  if (((unsigned int )(chr >> 8) & 4294967168U) == 0U) {
    {
#line 222
    tmp___1 = __ctype_b_loc();
    }
#line 222
    if ((int const   )*(*tmp___1 + (int )((unsigned int )(chr >> 8))) & 256) {
#line 222
      tmp___0 = (long )(17 << 9) + 372L;
    } else {
#line 222
      tmp___0 = (long )(16 << 9) + 372L;
    }
  } else {
#line 222
    tmp___0 = (long )(16 << 9) + 372L;
  }
#line 222
  return (tmp___0);
}
}
#line 226 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
static char s_char_lower_case_p[17]  = 
#line 226
  {      (char )'c',      (char )'h',      (char )'a',      (char )'r', 
        (char )'-',      (char )'l',      (char )'o',      (char )'w', 
        (char )'e',      (char )'r',      (char )'-',      (char )'c', 
        (char )'a',      (char )'s',      (char )'e',      (char )'?', 
        (char )'\000'};
#line 228 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
SCM scm_char_lower_case_p(SCM chr ) 
{ 
  long tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 232
  if (! (((int )chr & 255) == 244)) {
    {
#line 232
    scm_wta(chr, (char *)1, s_char_lower_case_p);
    }
  }
#line 233
  if (((unsigned int )(chr >> 8) & 4294967168U) == 0U) {
    {
#line 233
    tmp___1 = __ctype_b_loc();
    }
#line 233
    if ((int const   )*(*tmp___1 + (int )((unsigned int )(chr >> 8))) & 512) {
#line 233
      tmp___0 = (long )(17 << 9) + 372L;
    } else {
#line 233
      tmp___0 = (long )(16 << 9) + 372L;
    }
  } else {
#line 233
    tmp___0 = (long )(16 << 9) + 372L;
  }
#line 233
  return (tmp___0);
}
}
#line 238 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
static char s_char_is_both_p[14]  = 
#line 238
  {      (char )'c',      (char )'h',      (char )'a',      (char )'r', 
        (char )'-',      (char )'i',      (char )'s',      (char )'-', 
        (char )'b',      (char )'o',      (char )'t',      (char )'h', 
        (char )'?',      (char )'\000'};
#line 240 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
SCM scm_char_is_both_p(SCM chr ) 
{ 
  long tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
#line 244
  if (! (((int )chr & 255) == 244)) {
    {
#line 244
    scm_wta(chr, (char *)1, s_char_upper_case_p);
    }
  }
#line 245
  if (((unsigned int )(chr >> 8) & 4294967168U) == 0U) {
    {
#line 245
    tmp___2 = __ctype_b_loc();
    }
#line 245
    if ((int const   )*(*tmp___2 + (int )((unsigned int )(chr >> 8))) & 256) {
#line 245
      tmp___1 = (long )(17 << 9) + 372L;
    } else {
      {
#line 245
      tmp___3 = __ctype_b_loc();
      }
#line 245
      if ((int const   )*(*tmp___3 + (int )((unsigned int )(chr >> 8))) & 512) {
#line 245
        tmp___1 = (long )(17 << 9) + 372L;
      } else {
#line 245
        tmp___1 = (long )(16 << 9) + 372L;
      }
    }
  } else {
#line 245
    tmp___1 = (long )(16 << 9) + 372L;
  }
#line 245
  return (tmp___1);
}
}
#line 253 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
static char s_char_to_integer[14]  = 
#line 253
  {      (char )'c',      (char )'h',      (char )'a',      (char )'r', 
        (char )'-',      (char )'>',      (char )'i',      (char )'n', 
        (char )'t',      (char )'e',      (char )'g',      (char )'e', 
        (char )'r',      (char )'\000'};
#line 255 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
SCM scm_char_to_integer(SCM chr ) 
{ 
  SCM tmp ;

  {
#line 259
  if (! (((int )chr & 255) == 244)) {
    {
#line 259
    scm_wta(chr, (char *)1, s_char_to_integer);
    }
  }
  {
#line 260
  tmp = scm_ulong2num((unsigned long )((unsigned int )(chr >> 8)));
  }
#line 260
  return (tmp);
}
}
#line 265 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
static char s_integer_to_char[14]  = 
#line 265
  {      (char )'i',      (char )'n',      (char )'t',      (char )'e', 
        (char )'g',      (char )'e',      (char )'r',      (char )'-', 
        (char )'>',      (char )'c',      (char )'h',      (char )'a', 
        (char )'r',      (char )'\000'};
#line 267 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
SCM scm_integer_to_char(SCM n ) 
{ 
  unsigned long ni ;
  unsigned long tmp ;

  {
  {
#line 273
  tmp = scm_num2ulong(n, (char *)1, s_integer_to_char);
#line 273
  ni = 65535UL & tmp;
  }
#line 274
  return (((n >> 2) << 8) + 244L);
}
}
#line 278 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
static char s_char_upcase[12]  = 
#line 278
  {      (char )'c',      (char )'h',      (char )'a',      (char )'r', 
        (char )'-',      (char )'u',      (char )'p',      (char )'c', 
        (char )'a',      (char )'s',      (char )'e',      (char )'\000'};
#line 280 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
SCM scm_char_upcase(SCM chr ) 
{ 
  int tmp ;

  {
#line 284
  if (! (((int )chr & 255) == 244)) {
    {
#line 284
    scm_wta(chr, (char *)1, s_char_upcase);
    }
  }
  {
#line 285
  tmp = scm_upcase((unsigned int )(chr >> 8));
  }
#line 285
  return ((SCM )((tmp << 8) + 244));
}
}
#line 289 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
static char s_char_downcase[14]  = 
#line 289
  {      (char )'c',      (char )'h',      (char )'a',      (char )'r', 
        (char )'-',      (char )'d',      (char )'o',      (char )'w', 
        (char )'n',      (char )'c',      (char )'a',      (char )'s', 
        (char )'e',      (char )'\000'};
#line 291 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
SCM scm_char_downcase(SCM chr ) 
{ 
  int tmp ;

  {
#line 295
  if (! (((int )chr & 255) == 244)) {
    {
#line 295
    scm_wta(chr, (char *)1, s_char_downcase);
    }
  }
  {
#line 296
  tmp = scm_downcase((unsigned int )(chr >> 8));
  }
#line 296
  return ((SCM )((tmp << 8) + 244));
}
}
#line 303 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
static unsigned char scm_upcase_table[256L]  ;
#line 304 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
static unsigned char scm_downcase_table[256L]  ;
#line 305 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
static unsigned char scm_lowers[27]  = 
#line 305
  {      (unsigned char )'a',      (unsigned char )'b',      (unsigned char )'c',      (unsigned char )'d', 
        (unsigned char )'e',      (unsigned char )'f',      (unsigned char )'g',      (unsigned char )'h', 
        (unsigned char )'i',      (unsigned char )'j',      (unsigned char )'k',      (unsigned char )'l', 
        (unsigned char )'m',      (unsigned char )'n',      (unsigned char )'o',      (unsigned char )'p', 
        (unsigned char )'q',      (unsigned char )'r',      (unsigned char )'s',      (unsigned char )'t', 
        (unsigned char )'u',      (unsigned char )'v',      (unsigned char )'w',      (unsigned char )'x', 
        (unsigned char )'y',      (unsigned char )'z',      (unsigned char )'\000'};
#line 306 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
static unsigned char scm_uppers[27]  = 
#line 306
  {      (unsigned char )'A',      (unsigned char )'B',      (unsigned char )'C',      (unsigned char )'D', 
        (unsigned char )'E',      (unsigned char )'F',      (unsigned char )'G',      (unsigned char )'H', 
        (unsigned char )'I',      (unsigned char )'J',      (unsigned char )'K',      (unsigned char )'L', 
        (unsigned char )'M',      (unsigned char )'N',      (unsigned char )'O',      (unsigned char )'P', 
        (unsigned char )'Q',      (unsigned char )'R',      (unsigned char )'S',      (unsigned char )'T', 
        (unsigned char )'U',      (unsigned char )'V',      (unsigned char )'W',      (unsigned char )'X', 
        (unsigned char )'Y',      (unsigned char )'Z',      (unsigned char )'\000'};
#line 309 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
void scm_tables_prehistory(void) 
{ 
  int i ;
  unsigned char tmp ;

  {
#line 313
  i = 0;
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 313
    if (! ((long )i < 256L)) {
#line 313
      goto while_break;
    }
#line 314
    tmp = (unsigned char )i;
#line 314
    scm_downcase_table[i] = tmp;
#line 314
    scm_upcase_table[i] = tmp;
#line 313
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 315
  i = 0;
  {
#line 315
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 315
    if (! ((unsigned long )i < sizeof(scm_lowers) / sizeof(char ))) {
#line 315
      goto while_break___0;
    }
#line 317
    scm_upcase_table[scm_lowers[i]] = scm_uppers[i];
#line 318
    scm_downcase_table[scm_uppers[i]] = scm_lowers[i];
#line 315
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 320
  return;
}
}
#line 323 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
int scm_upcase(unsigned int c ) 
{ 


  {
#line 327
  if ((unsigned long )c < sizeof(scm_upcase_table)) {
#line 328
    return ((int )scm_upcase_table[c]);
  } else {
#line 330
    return ((int )c);
  }
}
}
#line 334 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
int scm_downcase(unsigned int c ) 
{ 


  {
#line 338
  if ((unsigned long )c < sizeof(scm_downcase_table)) {
#line 339
    return ((int )scm_downcase_table[c]);
  } else {
#line 341
    return ((int )c);
  }
}
}
#line 382 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
char *scm_charnames[40]  = 
#line 382
  {      (char *)"nul",      (char *)"soh",      (char *)"stx",      (char *)"etx", 
        (char *)"eot",      (char *)"enq",      (char *)"ack",      (char *)"bel", 
        (char *)"bs",      (char *)"ht",      (char *)"nl",      (char *)"vt", 
        (char *)"np",      (char *)"cr",      (char *)"so",      (char *)"si", 
        (char *)"dle",      (char *)"dc1",      (char *)"dc2",      (char *)"dc3", 
        (char *)"dc4",      (char *)"nak",      (char *)"syn",      (char *)"etb", 
        (char *)"can",      (char *)"em",      (char *)"sub",      (char *)"esc", 
        (char *)"fs",      (char *)"gs",      (char *)"rs",      (char *)"us", 
        (char *)"space",      (char *)"newline",      (char *)"tab",      (char *)"backspace", 
        (char *)"return",      (char *)"page",      (char *)"null",      (char *)"del"};
#line 389 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
char scm_charnums[41]  = 
#line 389
  {      (char )'\000',      (char )'\001',      (char )'\002',      (char )'\003', 
        (char )'\004',      (char )'\005',      (char )'\006',      (char )'\a', 
        (char )'\b',      (char )'\t',      (char )'\n',      (char )'\v', 
        (char )'\f',      (char )'\r',      (char )'\016',      (char )'\017', 
        (char )'\020',      (char )'\021',      (char )'\022',      (char )'\023', 
        (char )'\024',      (char )'\025',      (char )'\026',      (char )'\027', 
        (char )'\030',      (char )'\031',      (char )'\032',      (char )'\033', 
        (char )'\034',      (char )'\035',      (char )'\036',      (char )'\037', 
        (char )' ',      (char )'\n',      (char )'\t',      (char )'\b', 
        (char )'\r',      (char )'\f',      (char )'\000',      (char )'\177', 
        (char )'\000'};
#line 397 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
int scm_n_charnames  =    (int )(sizeof(scm_charnames) / sizeof(char *));
#line 403 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
void scm_init_chars(void) 
{ 


  {
  {
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.x"
  scm_make_gsubr(s_char_p, 1, 0, 0, (SCM (*)())(& scm_char_p));
#line 2
  scm_make_subr(s_char_eq_p, 69, (SCM (*)())(& scm_char_eq_p));
#line 3
  scm_make_subr(s_char_less_p, 69, (SCM (*)())(& scm_char_less_p));
#line 4
  scm_make_subr(s_char_leq_p, 69, (SCM (*)())(& scm_char_leq_p));
#line 5
  scm_make_subr(s_char_gr_p, 69, (SCM (*)())(& scm_char_gr_p));
#line 6
  scm_make_subr(s_char_geq_p, 69, (SCM (*)())(& scm_char_geq_p));
#line 7
  scm_make_subr(s_char_ci_eq_p, 69, (SCM (*)())(& scm_char_ci_eq_p));
#line 8
  scm_make_subr(s_char_ci_less_p, 69, (SCM (*)())(& scm_char_ci_less_p));
#line 9
  scm_make_subr(s_char_ci_leq_p, 69, (SCM (*)())(& scm_char_ci_leq_p));
#line 10
  scm_make_subr(s_char_ci_gr_p, 69, (SCM (*)())(& scm_char_ci_gr_p));
#line 11
  scm_make_subr(s_char_ci_geq_p, 69, (SCM (*)())(& scm_char_ci_geq_p));
#line 12
  scm_make_gsubr(s_char_alphabetic_p, 1, 0, 0, (SCM (*)())(& scm_char_alphabetic_p));
#line 13
  scm_make_gsubr(s_char_numeric_p, 1, 0, 0, (SCM (*)())(& scm_char_numeric_p));
#line 14
  scm_make_gsubr(s_char_whitespace_p, 1, 0, 0, (SCM (*)())(& scm_char_whitespace_p));
#line 15
  scm_make_gsubr(s_char_upper_case_p, 1, 0, 0, (SCM (*)())(& scm_char_upper_case_p));
#line 16
  scm_make_gsubr(s_char_lower_case_p, 1, 0, 0, (SCM (*)())(& scm_char_lower_case_p));
#line 17
  scm_make_gsubr(s_char_is_both_p, 1, 0, 0, (SCM (*)())(& scm_char_is_both_p));
#line 18
  scm_make_gsubr(s_char_to_integer, 1, 0, 0, (SCM (*)())(& scm_char_to_integer));
#line 19
  scm_make_gsubr(s_integer_to_char, 1, 0, 0, (SCM (*)())(& scm_integer_to_char));
#line 20
  scm_make_gsubr(s_char_upcase, 1, 0, 0, (SCM (*)())(& scm_char_upcase));
#line 21
  scm_make_gsubr(s_char_downcase, 1, 0, 0, (SCM (*)())(& scm_char_downcase));
  }
#line 407 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/chars.c"
  return;
}
}
#line 63 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/boolean.h"
SCM scm_not(SCM x ) ;
#line 64
SCM scm_boolean_p(SCM obj ) ;
#line 50 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/boolean.c"
static char s_not[4]  = {      (char )'n',      (char )'o',      (char )'t',      (char )'\000'};
#line 52 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/boolean.c"
SCM scm_not(SCM x ) 
{ 
  long tmp ;

  {
#line 56
  if ((long )(16 << 9) + 372L == x) {
#line 56
    tmp = (long )(17 << 9) + 372L;
  } else {
#line 56
    tmp = (long )(16 << 9) + 372L;
  }
#line 56
  return (tmp);
}
}
#line 60 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/boolean.c"
static char s_boolean_p[9]  = 
#line 60
  {      (char )'b',      (char )'o',      (char )'o',      (char )'l', 
        (char )'e',      (char )'a',      (char )'n',      (char )'?', 
        (char )'\000'};
#line 62 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/boolean.c"
SCM scm_boolean_p(SCM obj ) 
{ 


  {
#line 66
  if ((long )(16 << 9) + 372L == obj) {
#line 66
    return ((long )(17 << 9) + 372L);
  }
#line 67
  if ((long )(17 << 9) + 372L == obj) {
#line 67
    return ((long )(17 << 9) + 372L);
  }
#line 68
  return ((long )(16 << 9) + 372L);
}
}
#line 73 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/boolean.c"
void scm_init_boolean(void) 
{ 


  {
  {
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/boolean.x"
  scm_make_gsubr(s_not, 1, 0, 0, (SCM (*)())(& scm_not));
#line 2
  scm_make_gsubr(s_boolean_p, 1, 0, 0, (SCM (*)())(& scm_boolean_p));
  }
#line 77 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/boolean.c"
  return;
}
}
#line 53 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/backtrace.h"
SCM scm_display_error(SCM stack , SCM port , SCM subr , SCM message , SCM args , SCM rest ) ;
#line 54
SCM scm_display_backtrace(SCM stack , SCM port , SCM first___0 , SCM depth ) ;
#line 69 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/backtrace.c"
static void display_header(SCM source , SCM port ) ;
#line 70 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/backtrace.c"
static void display_header(SCM source , SCM port ) 
{ 
  SCM fname ;
  SCM tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  SCM tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 75
  if (! (6 & (int )source)) {
#line 75
    if (scm_tc16_memoized == (long )(65535 & (int )((scm_cell *)source)->car)) {
      {
#line 75
      tmp = scm_source_property(source, scm_i_filename);
#line 75
      tmp___0 = tmp;
      }
    } else {
#line 75
      tmp___0 = (long )(16 << 9) + 372L;
    }
  } else {
#line 75
    tmp___0 = (long )(16 << 9) + 372L;
  }
#line 75
  fname = tmp___0;
#line 78
  if (! (6 & (int )fname)) {
#line 78
    if ((125 & (int )((scm_cell *)fname)->car) == 21) {
      {
#line 80
      scm_prin1(fname, port, 0);
#line 81
      scm_gen_putc(':', port);
#line 82
      tmp___1 = scm_source_property(source, scm_i_line);
#line 82
      scm_prin1(tmp___1, port, 0);
#line 83
      scm_gen_putc(':', port);
#line 84
      tmp___2 = scm_source_property(source, scm_i_column);
#line 84
      scm_prin1(tmp___2, port, 0);
      }
    } else {
      {
#line 87
      scm_gen_puts((enum scm_string_representation_type )0, (char *)"ERROR", port);
      }
    }
  } else {
    {
#line 87
    scm_gen_puts((enum scm_string_representation_type )0, (char *)"ERROR", port);
    }
  }
  {
#line 88
  scm_gen_puts((enum scm_string_representation_type )0, (char *)": ", port);
  }
#line 89
  return;
}
}
#line 92 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/backtrace.c"
void scm_display_error_message(SCM message , SCM args , SCM port ) 
{ 
  int writingp ;
  char *start ;
  char *p ;
  SCM tmp ;

  {
#line 102
  if (! ((125 & (int )((scm_cell *)message)->car) == 21)) {
    {
#line 104
    scm_prin1(message, port, 0);
#line 105
    scm_gen_putc('\n', port);
    }
#line 106
    return;
  } else
#line 102
  if (6 & (int )args) {
    {
#line 104
    scm_prin1(message, port, 0);
#line 105
    scm_gen_putc('\n', port);
    }
#line 106
    return;
  } else {
    {
#line 102
    tmp = scm_list_p(args);
    }
#line 102
    if (! tmp) {
      {
#line 104
      scm_prin1(message, port, 0);
#line 105
      scm_gen_putc('\n', port);
      }
#line 106
      return;
    }
  }
#line 109
  start = (char *)((scm_cell *)message)->cdr;
#line 110
  p = start;
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (! ((int )*p != 0)) {
#line 110
      goto while_break;
    }
#line 111
    if ((int )*p == 37) {
#line 113
      if (6 & (int )args) {
#line 114
        goto __Cont;
      } else
#line 113
      if (1 & (int )((scm_cell *)args)->car) {
#line 114
        goto __Cont;
      }
#line 116
      p ++;
#line 117
      if ((int )*p == 115) {
#line 118
        writingp = 0;
      } else
#line 119
      if ((int )*p == 83) {
#line 120
        writingp = 1;
      } else {
#line 122
        goto __Cont;
      }
      {
#line 124
      scm_gen_write((enum scm_string_representation_type )0, start, (size_t )((p - start) - 1L),
                    port);
#line 125
      scm_prin1(((scm_cell *)args)->car, port, writingp);
#line 126
      args = ((scm_cell *)args)->cdr;
#line 127
      start = p + 1;
      }
    }
    __Cont: /* CIL Label */ 
#line 110
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 129
  scm_gen_write((enum scm_string_representation_type )0, start, (size_t )(p - start),
                port);
#line 130
  scm_gen_putc('\n', port);
  }
#line 131
  return;
}
}
#line 133
static void display_expression(SCM frame , SCM pname , SCM source , SCM port ) ;
#line 134 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/backtrace.c"
static void display_expression(SCM frame , SCM pname , SCM source , SCM port ) 
{ 
  SCM print_state ;
  SCM tmp ;
  scm_print_state *pstate ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 141
  tmp = scm_make_print_state();
#line 141
  print_state = tmp;
#line 142
  pstate = (scm_print_state *)((SCM *)((scm_cell *)print_state)->cdr);
#line 143
  pstate->writingp = 0UL;
#line 144
  pstate->fancyp = 1UL;
#line 145
  pstate->level = 2UL;
#line 146
  pstate->length = 3UL;
  }
#line 147
  if (! (6 & (int )pname)) {
#line 147
    if ((117 & (int )((scm_cell *)pname)->car) == 21) {
#line 147
      goto _L___0;
    } else
#line 147
    if ((125 & (int )((scm_cell *)pname)->car) == 5) {
      _L___0: /* CIL Label */ 
#line 149
      if (! (6 & (int )frame)) {
#line 149
        if (! (1 & (int )((scm_cell *)frame)->car)) {
#line 149
          if (! (6 & (int )((scm_cell *)frame)->car)) {
#line 149
            if ((7 & (int )((scm_cell *)((scm_cell *)frame)->car)->car) == 1) {
#line 149
              if (*((SCM *)(((scm_cell *)((scm_cell *)frame)->car)->car - 1L) + 2) == scm_stack_type) {
#line 149
                if (2 & (int )((scm_cell *)frame)->cdr) {
#line 149
                  if ((((scm_stack *)((SCM *)((scm_cell *)((scm_cell *)frame)->car)->cdr))->frames + (((scm_cell *)frame)->cdr >> 2))->flags & (1L << 5)) {
                    {
#line 152
                    scm_gen_puts((enum scm_string_representation_type )0, (char *)"While evaluating arguments to ",
                                 port);
                    }
                  } else {
                    {
#line 154
                    scm_gen_puts((enum scm_string_representation_type )0, (char *)"In procedure ",
                                 port);
                    }
                  }
                } else {
                  {
#line 154
                  scm_gen_puts((enum scm_string_representation_type )0, (char *)"In procedure ",
                               port);
                  }
                }
              } else {
                {
#line 154
                scm_gen_puts((enum scm_string_representation_type )0, (char *)"In procedure ",
                             port);
                }
              }
            } else {
              {
#line 154
              scm_gen_puts((enum scm_string_representation_type )0, (char *)"In procedure ",
                           port);
              }
            }
          } else {
            {
#line 154
            scm_gen_puts((enum scm_string_representation_type )0, (char *)"In procedure ",
                         port);
            }
          }
        } else {
          {
#line 154
          scm_gen_puts((enum scm_string_representation_type )0, (char *)"In procedure ",
                       port);
          }
        }
      } else {
        {
#line 154
        scm_gen_puts((enum scm_string_representation_type )0, (char *)"In procedure ",
                     port);
        }
      }
      {
#line 155
      scm_iprin1(pname, port, pstate);
      }
#line 156
      if (! (6 & (int )source)) {
#line 156
        if (scm_tc16_memoized == (long )(65535 & (int )((scm_cell *)source)->car)) {
          {
#line 158
          scm_gen_puts((enum scm_string_representation_type )0, (char *)" in expression ",
                       port);
#line 159
          pstate->writingp = 1UL;
#line 160
          tmp___0 = scm_unmemoize(source);
#line 160
          scm_iprin1(tmp___0, port, pstate);
          }
        }
      }
    } else {
#line 147
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 163
  if (! (6 & (int )source)) {
    {
#line 165
    scm_gen_puts((enum scm_string_representation_type )0, (char *)"In expression ",
                 port);
#line 166
    pstate->writingp = 1UL;
#line 167
    tmp___1 = scm_unmemoize(source);
#line 167
    scm_iprin1(tmp___1, port, pstate);
    }
  }
  {
#line 169
  scm_gen_puts((enum scm_string_representation_type )0, (char *)":\n", port);
#line 170
  scm_free_print_state(print_state);
  }
#line 171
  return;
}
}
#line 173 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/backtrace.c"
static char s_display_error[14]  = 
#line 173
  {      (char )'d',      (char )'i',      (char )'s',      (char )'p', 
        (char )'l',      (char )'a',      (char )'y',      (char )'-', 
        (char )'e',      (char )'r',      (char )'r',      (char )'o', 
        (char )'r',      (char )'\000'};
#line 174 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/backtrace.c"
SCM scm_display_error(SCM stack , SCM port , SCM subr , SCM message , SCM args , SCM rest ) 
{ 
  SCM current_frame ;
  SCM source ;
  SCM pname ;
  SCM tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;

  {
#line 183
  current_frame = (long )(16 << 9) + 372L;
#line 184
  source = (long )(16 << 9) + 372L;
#line 185
  pname = (long )(16 << 9) + 372L;
#line 186
  if (scm_debug_mode) {
#line 186
    if (! (6 & (int )stack)) {
#line 186
      if ((7 & (int )((scm_cell *)stack)->car) == 1) {
#line 186
        if (*((SCM *)(((scm_cell *)stack)->car - 1L) + 2) == scm_stack_type) {
#line 186
          if (((scm_stack *)((SCM *)((scm_cell *)stack)->cdr))->length > 0U) {
            {
#line 191
            current_frame = scm_stack_ref(stack, (SCM )2);
#line 192
            source = (((scm_stack *)((SCM *)((scm_cell *)((scm_cell *)current_frame)->car)->cdr))->frames + (((scm_cell *)current_frame)->cdr >> 2))->source;
            }
#line 193
            if (! (6 & (int )source)) {
#line 193
              if (! (scm_tc16_memoized == (long )(65535 & (int )((scm_cell *)source)->car))) {
                {
#line 194
                tmp = scm_frame_previous(current_frame);
#line 194
                tmp___0 = scm_frame_previous(current_frame);
#line 194
                source = (((scm_stack *)((SCM *)((scm_cell *)((scm_cell *)tmp)->car)->cdr))->frames + (((scm_cell *)tmp___0)->cdr >> 2))->source;
                }
              }
            } else {
              {
#line 194
              tmp = scm_frame_previous(current_frame);
#line 194
              tmp___0 = scm_frame_previous(current_frame);
#line 194
              source = (((scm_stack *)((SCM *)((scm_cell *)((scm_cell *)tmp)->car)->cdr))->frames + (((scm_cell *)tmp___0)->cdr >> 2))->source;
              }
            }
#line 195
            if ((((scm_stack *)((SCM *)((scm_cell *)((scm_cell *)current_frame)->car)->cdr))->frames + (((scm_cell *)current_frame)->cdr >> 2))->flags & (1L << 4)) {
              {
#line 195
              tmp___1 = scm_procedure_p((((scm_stack *)((SCM *)((scm_cell *)((scm_cell *)current_frame)->car)->cdr))->frames + (((scm_cell *)current_frame)->cdr >> 2))->proc);
              }
#line 195
              if (tmp___1 == (long )(17 << 9) + 372L) {
                {
#line 197
                pname = scm_procedure_name((((scm_stack *)((SCM *)((scm_cell *)((scm_cell *)current_frame)->car)->cdr))->frames + (((scm_cell *)current_frame)->cdr >> 2))->proc);
                }
              }
            }
          }
        }
      }
    }
  }
#line 199
  if (! (6 & (int )pname)) {
#line 199
    if (! ((117 & (int )((scm_cell *)pname)->car) == 21)) {
#line 199
      if (! ((125 & (int )((scm_cell *)pname)->car) == 5)) {
#line 200
        pname = subr;
      }
    }
  } else {
#line 200
    pname = subr;
  }
#line 201
  if (! (6 & (int )source)) {
#line 201
    if (scm_tc16_memoized == (long )(65535 & (int )((scm_cell *)source)->car)) {
      {
#line 204
      display_header(source, port);
#line 205
      display_expression(current_frame, pname, source, port);
      }
    } else {
#line 201
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 201
  if (! (6 & (int )pname)) {
#line 201
    if ((117 & (int )((scm_cell *)pname)->car) == 21) {
      {
#line 204
      display_header(source, port);
#line 205
      display_expression(current_frame, pname, source, port);
      }
    } else
#line 201
    if ((125 & (int )((scm_cell *)pname)->car) == 5) {
      {
#line 204
      display_header(source, port);
#line 205
      display_expression(current_frame, pname, source, port);
      }
    }
  }
  {
#line 207
  display_header(source, port);
#line 208
  scm_display_error_message(message, args, port);
  }
#line 209
  return ((long )(21 << 9) + 372L);
}
}
#line 212
static void indent(int n , SCM port ) ;
#line 213 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/backtrace.c"
static void indent(int n , SCM port ) 
{ 
  int i ;

  {
#line 219
  i = 0;
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if (! (i < n)) {
#line 219
      goto while_break;
    }
    {
#line 220
    scm_gen_putc(' ', port);
#line 219
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 221
  return;
}
}
#line 223
static void display_frame_expr(char *hdr , SCM exp___0 , char *tlr , int indentation ,
                               SCM sport , SCM port , scm_print_state *pstate ) ;
#line 224 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/backtrace.c"
static void display_frame_expr(char *hdr , SCM exp___0 , char *tlr , int indentation ,
                               SCM sport , SCM port , scm_print_state *pstate ) 
{ 


  {
#line 234
  pstate->level = 2UL;
#line 235
  pstate->length = 3UL;
#line 236
  if (! (6 & (int )exp___0)) {
#line 236
    if (! (1 & (int )((scm_cell *)exp___0)->car)) {
      {
#line 238
      scm_iprlist(hdr, exp___0, *(tlr + 0), port, pstate);
#line 239
      scm_gen_puts((enum scm_string_representation_type )0, tlr + 1, port);
      }
    } else {
      {
#line 242
      scm_iprin1(exp___0, port, pstate);
      }
    }
  } else {
    {
#line 242
    scm_iprin1(exp___0, port, pstate);
    }
  }
  {
#line 243
  scm_gen_putc('\n', port);
  }
#line 244
  return;
}
}
#line 246
static void display_frame(SCM frame , int nfield , int indentation , SCM sport , SCM port ,
                          scm_print_state *pstate ) ;
#line 247 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/backtrace.c"
static void display_frame(SCM frame , int nfield , int indentation , SCM sport , SCM port ,
                          scm_print_state *pstate ) 
{ 
  int n ;
  int i ;
  int j ;
  int tmp ;
  int tmp___0 ;
  SCM proc ;
  SCM name ;
  SCM tmp___2 ;
  SCM tmp___3 ;
  SCM tmp___4 ;
  char const   *tmp___5 ;
  SCM tmp___6 ;
  SCM tmp___7 ;
  SCM source ;
  SCM copy ;
  SCM tmp___8 ;
  SCM tmp___9 ;
  SCM tmp___10 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
#line 259
  if (! scm_debug_opts[4].val) {
#line 259
    if ((((scm_stack *)((SCM *)((scm_cell *)((scm_cell *)frame)->car)->cdr))->frames + (((scm_cell *)frame)->cdr >> 2))->flags & (1L << 6)) {
      {
#line 261
      indent((nfield + 1) + indentation, port);
#line 262
      scm_gen_puts((enum scm_string_representation_type )0, (char *)"...\n", port);
      }
    }
  }
#line 266
  if (scm_debug_opts[4].val) {
#line 266
    n = (int )(((scm_cell *)frame)->cdr >> 2);
  } else {
#line 266
    n = (int )(((SCM )((scm_stack *)((SCM *)((scm_cell *)((scm_cell *)frame)->car)->cdr))->length - (((scm_cell *)frame)->cdr >> 2)) - 1L);
  }
#line 267
  i = 0;
#line 267
  j = n;
  {
#line 267
  while (1) {
    while_continue: /* CIL Label */ ;
#line 267
    if (! (j > 0)) {
#line 267
      goto while_break;
    }
#line 267
    j /= 10;
#line 267
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 270
  if (i) {
#line 270
    tmp = i;
  } else {
#line 270
    tmp = 1;
  }
  {
#line 270
  indent(nfield - tmp, port);
#line 273
  scm_iprin1((long )(n << 2) + 2L, port, pstate);
  }
#line 276
  if ((((scm_stack *)((SCM *)((scm_cell *)((scm_cell *)frame)->car)->cdr))->frames + (((scm_cell *)frame)->cdr >> 2))->flags & (1L << 3)) {
#line 276
    tmp___0 = '*';
  } else {
#line 276
    tmp___0 = ' ';
  }
  {
#line 276
  scm_gen_putc(tmp___0, port);
#line 279
  indent(indentation, port);
  }
#line 281
  if ((((scm_stack *)((SCM *)((scm_cell *)((scm_cell *)frame)->car)->cdr))->frames + (((scm_cell *)frame)->cdr >> 2))->flags & (1L << 4)) {
    {
#line 284
    proc = (((scm_stack *)((SCM *)((scm_cell *)((scm_cell *)frame)->car)->cdr))->frames + (((scm_cell *)frame)->cdr >> 2))->proc;
#line 285
    tmp___4 = scm_procedure_p(proc);
    }
#line 285
    if ((long )(16 << 9) + 372L != tmp___4) {
      {
#line 285
      tmp___2 = scm_procedure_name(proc);
#line 285
      tmp___3 = tmp___2;
      }
    } else {
#line 285
      tmp___3 = (long )(16 << 9) + 372L;
    }
#line 285
    name = tmp___3;
#line 288
    if ((((scm_stack *)((SCM *)((scm_cell *)((scm_cell *)frame)->car)->cdr))->frames + (((scm_cell *)frame)->cdr >> 2))->flags & (1L << 5)) {
#line 288
      tmp___5 = " ...";
    } else {
#line 288
      tmp___5 = "]";
    }
#line 288
    if ((long )(16 << 9) + 372L != name) {
#line 288
      tmp___6 = name;
    } else {
#line 288
      tmp___6 = proc;
    }
    {
#line 288
    tmp___7 = scm_cons(tmp___6, (((scm_stack *)((SCM *)((scm_cell *)((scm_cell *)frame)->car)->cdr))->frames + (((scm_cell *)frame)->cdr >> 2))->args);
#line 288
    display_frame_expr((char *)"[", tmp___7, (char *)tmp___5, (nfield + 1) + indentation,
                       sport, port, pstate);
    }
  } else {
    {
#line 300
    source = (((scm_stack *)((SCM *)((scm_cell *)((scm_cell *)frame)->car)->cdr))->frames + (((scm_cell *)frame)->cdr >> 2))->source;
#line 301
    tmp___8 = scm_source_property(source, scm_i_copy);
#line 301
    copy = tmp___8;
    }
#line 302
    if (! (6 & (int )copy)) {
#line 302
      if (! (1 & (int )((scm_cell *)copy)->car)) {
#line 302
        tmp___10 = copy;
      } else {
        {
#line 302
        tmp___9 = scm_unmemoize(source);
#line 302
        tmp___10 = tmp___9;
        }
      }
    } else {
      {
#line 302
      tmp___9 = scm_unmemoize(source);
#line 302
      tmp___10 = tmp___9;
      }
    }
    {
#line 302
    display_frame_expr((char *)"(", tmp___10, (char *)")", (nfield + 1) + indentation,
                       sport, port, pstate);
    }
  }
#line 314
  if (scm_debug_opts[4].val) {
#line 314
    if ((((scm_stack *)((SCM *)((scm_cell *)((scm_cell *)frame)->car)->cdr))->frames + (((scm_cell *)frame)->cdr >> 2))->flags & (1L << 6)) {
      {
#line 316
      indent((nfield + 1) + indentation, port);
#line 317
      scm_gen_puts((enum scm_string_representation_type )0, (char *)"...\n", port);
      }
    }
  }
#line 319
  return;
}
}
#line 321 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/backtrace.c"
static char s_display_backtrace[18]  = 
#line 321
  {      (char )'d',      (char )'i',      (char )'s',      (char )'p', 
        (char )'l',      (char )'a',      (char )'y',      (char )'-', 
        (char )'b',      (char )'a',      (char )'c',      (char )'k', 
        (char )'t',      (char )'r',      (char )'a',      (char )'c', 
        (char )'e',      (char )'\000'};
#line 322 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/backtrace.c"
SCM scm_display_backtrace(SCM stack , SCM port , SCM first___0 , SCM depth ) 
{ 
  int n_frames ;
  int beg ;
  int end ;
  int n ;
  int i ;
  int j ;
  int nfield ;
  int indent_p ;
  int indentation ;
  SCM frame ;
  SCM sport ;
  SCM print_state ;
  scm_print_state *pstate ;
  SCM tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  SCM tmp___2 ;
  SCM tmp___3 ;
  SCM tmp___4 ;
  SCM tmp___5 ;
  SCM tmp___6 ;
  SCM tmp___7 ;
  char *__cil_tmp27 ;

  {
#line 335
  if (! (6 & (int )stack)) {
#line 335
    if ((7 & (int )((scm_cell *)stack)->car) == 1) {
#line 335
      if (! (*((SCM *)(((scm_cell *)stack)->car - 1L) + 2) == scm_stack_type)) {
#line 335
        return ((long )(16 << 9) + 372L);
      }
    } else {
#line 335
      return ((long )(16 << 9) + 372L);
    }
  } else {
#line 335
    return ((long )(16 << 9) + 372L);
  }
#line 339
  if (! (6 & (int )port)) {
#line 339
    if (! ((((127L | (1L << 16)) | (4L << 16)) & ((scm_cell *)port)->car) == ((125L | (1L << 16)) | (4L << 16)))) {
#line 339
      return ((long )(16 << 9) + 372L);
    }
  } else {
#line 339
    return ((long )(16 << 9) + 372L);
  }
  {
#line 343
  tmp = scm_stack_length(stack);
#line 343
  n_frames = (int )(tmp >> 2);
  }
#line 344
  if (2 & (int )depth) {
#line 344
    n = (int )(depth >> 2);
  } else {
#line 344
    n = (int )scm_debug_opts[8].val;
  }
#line 345
  if (scm_debug_opts[4].val) {
#line 347
    if (2 & (int )first___0) {
#line 347
      beg = (int )(first___0 >> 2);
    } else {
#line 347
      beg = 0;
    }
#line 348
    end = (beg + n) - 1;
#line 349
    if (end >= n_frames) {
#line 350
      end = n_frames - 1;
    }
#line 351
    n = (end - beg) + 1;
  } else {
#line 355
    if (2 & (int )first___0) {
#line 357
      beg = (int )(first___0 >> 2);
#line 358
      end = (beg - n) + 1;
#line 359
      if (end < 0) {
#line 360
        end = 0;
      }
    } else {
#line 364
      beg = n - 1;
#line 365
      end = 0;
#line 366
      if (beg >= n_frames) {
#line 367
        beg = n_frames - 1;
      }
    }
#line 369
    n = (beg - end) + 1;
  }
#line 371
  if (beg >= 0) {
#line 371
    if (! (beg < n_frames)) {
#line 371
      return ((long )(16 << 9) + 372L);
    }
  } else {
#line 371
    return ((long )(16 << 9) + 372L);
  }
#line 372
  if (! (n > 0)) {
#line 372
    return ((long )(16 << 9) + 372L);
  }
  {
#line 375
  tmp___0 = scm_make_string((long )(240 << 2) + 2L, (long )(18 << 9) + 372L);
#line 375
  sport = scm_mkstrport((SCM )2, tmp___0, (1L << 16) | (4L << 16), s_display_backtrace);
#line 381
  print_state = scm_make_print_state();
#line 382
  pstate = (scm_print_state *)((SCM *)((scm_cell *)print_state)->cdr);
#line 383
  pstate->writingp = 1UL;
#line 384
  pstate->fancyp = 1UL;
  }
#line 387
  if (scm_debug_opts[4].val) {
#line 388
    indent_p = 0;
  } else {
    {
#line 391
    indent_p = 1;
#line 392
    frame = scm_stack_ref(stack, (long )(beg << 2) + 2L);
#line 393
    i = 0;
#line 393
    j = 0;
    }
    {
#line 393
    while (1) {
      while_continue: /* CIL Label */ ;
#line 393
      if (! (i < n)) {
#line 393
        goto while_break;
      }
#line 395
      if ((((scm_stack *)((SCM *)((scm_cell *)((scm_cell *)frame)->car)->cdr))->frames + (((scm_cell *)frame)->cdr >> 2))->flags & (1L << 3)) {
#line 396
        j ++;
      }
#line 397
      if ((unsigned long )j > scm_debug_opts[5].val) {
#line 399
        indent_p = 0;
#line 400
        goto while_break;
      }
#line 402
      if (scm_debug_opts[4].val) {
        {
#line 402
        tmp___1 = scm_frame_previous(frame);
#line 402
        frame = tmp___1;
        }
      } else {
        {
#line 402
        tmp___2 = scm_frame_next(frame);
#line 402
        frame = tmp___2;
        }
      }
#line 393
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 409
  if (scm_debug_opts[4].val) {
    {
#line 409
    tmp___3 = scm_stack_ref(stack, (long )(end << 2) + 2L);
#line 409
    j = (int )(((scm_cell *)tmp___3)->cdr >> 2);
    }
  } else {
    {
#line 409
    tmp___4 = scm_stack_ref(stack, (long )(end << 2) + 2L);
#line 409
    tmp___5 = scm_stack_ref(stack, (long )(end << 2) + 2L);
#line 409
    j = (int )(((SCM )((scm_stack *)((SCM *)((scm_cell *)((scm_cell *)tmp___4)->car)->cdr))->length - (((scm_cell *)tmp___5)->cdr >> 2)) - 1L);
    }
  }
#line 410
  i = 0;
  {
#line 410
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 410
    if (! (j > 0)) {
#line 410
      goto while_break___0;
    }
#line 410
    j /= 10;
#line 410
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 411
  if (i) {
#line 411
    nfield = i;
  } else {
#line 411
    nfield = 1;
  }
  {
#line 413
  scm_gen_puts((enum scm_string_representation_type )0, (char *)"Backtrace:\n", port);
#line 416
  frame = scm_stack_ref(stack, (long )(beg << 2) + 2L);
#line 417
  indentation = 1;
#line 418
  display_frame(frame, nfield, indentation, sport, port, pstate);
#line 419
  i = 1;
  }
  {
#line 419
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 419
    if (! (i < n)) {
#line 419
      goto while_break___1;
    }
#line 421
    if (indent_p) {
#line 421
      if ((((scm_stack *)((SCM *)((scm_cell *)((scm_cell *)frame)->car)->cdr))->frames + (((scm_cell *)frame)->cdr >> 2))->flags & (1L << 5)) {
#line 422
        indentation ++;
      }
    }
#line 423
    if (scm_debug_opts[4].val) {
      {
#line 423
      tmp___6 = scm_frame_previous(frame);
#line 423
      frame = tmp___6;
      }
    } else {
      {
#line 423
      tmp___7 = scm_frame_next(frame);
#line 423
      frame = tmp___7;
      }
    }
    {
#line 424
    display_frame(frame, nfield, indentation, sport, port, pstate);
#line 419
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 427
  return ((long )(21 << 9) + 372L);
}
}
#line 432 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/backtrace.c"
void scm_init_backtrace(void) 
{ 


  {
  {
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/backtrace.x"
  scm_make_gsubr(s_display_error, 6, 0, 0, (SCM (*)())(& scm_display_error));
#line 2
  scm_make_gsubr(s_display_backtrace, 2, 2, 0, (SCM (*)())(& scm_display_backtrace));
  }
#line 436 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/backtrace.c"
  return;
}
}
#line 52 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.h"
unsigned int scm_mask_ints ;
#line 57
void scm_switch(void) ;
#line 58
SCM scm_async(SCM thunk ) ;
#line 59
SCM scm_system_async(SCM thunk ) ;
#line 60
SCM scm_async_mark(SCM a ) ;
#line 61
SCM scm_system_async_mark(SCM a ) ;
#line 62
SCM scm_run_asyncs(SCM list_of_a ) ;
#line 63
SCM scm_noop(SCM args ) ;
#line 64
SCM scm_set_tick_rate(SCM n ) ;
#line 65
SCM scm_set_switch_rate(SCM n ) ;
#line 67
SCM scm_unmask_signals(void) ;
#line 68
SCM scm_mask_signals(void) ;
#line 89 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
unsigned int scm_async_clock  =    20U;
#line 90 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
static unsigned int scm_async_rate  =    20U;
#line 91 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
unsigned int scm_mask_ints  =    1U;
#line 93 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
static unsigned int scm_tick_clock  =    0U;
#line 94 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
static unsigned int scm_tick_rate  =    0U;
#line 95 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
static unsigned int scm_desired_tick_rate  =    0U;
#line 96 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
static unsigned int scm_switch_clock  =    0U;
#line 97 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
static unsigned int scm_switch_rate  =    0U;
#line 98 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
static unsigned int scm_desired_switch_rate  =    0U;
#line 100 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
static SCM system_signal_asyncs[8]  ;
#line 101 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
static SCM handler_var  ;
#line 102 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
static SCM symbol_signal  ;
#line 112 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
static long scm_tc16_async  ;
#line 122
static int asyncs_pending(void) ;
#line 124 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
static int asyncs_pending(void) 
{ 
  SCM pos ;
  SCM a ;
  struct scm_async *it ;

  {
#line 128
  pos = scm_sys_protects[14];
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    if (! (pos != (long )(20 << 9) + 372L)) {
#line 129
      goto while_break;
    }
#line 133
    a = ((scm_cell *)pos)->car;
#line 134
    it = (struct scm_async *)((scm_cell *)a)->cdr;
#line 135
    if (it->got_it) {
#line 136
      return (1);
    }
#line 137
    pos = ((scm_cell *)pos)->cdr;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  return (0);
}
}
#line 144 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
void scm_async_click(void) 
{ 
  int owe_switch ;
  int owe_tick ;
  unsigned int r ;
  int tmp ;

  {
#line 150
  if (! scm_switch_rate) {
#line 152
    owe_switch = 0;
#line 153
    scm_switch_rate = scm_desired_switch_rate;
#line 153
    scm_switch_clock = scm_switch_rate;
#line 154
    scm_desired_switch_rate = 0U;
  } else {
#line 158
    owe_switch = scm_async_rate >= scm_switch_clock;
#line 159
    if (owe_switch) {
#line 161
      if (scm_desired_switch_rate) {
#line 163
        scm_switch_rate = scm_desired_switch_rate;
#line 163
        scm_switch_clock = scm_switch_rate;
#line 164
        scm_desired_switch_rate = 0U;
      } else {
#line 167
        scm_switch_clock = scm_switch_rate;
      }
    } else
#line 171
    if (scm_desired_switch_rate) {
#line 173
      scm_switch_rate = scm_desired_switch_rate;
#line 173
      scm_switch_clock = scm_switch_rate;
#line 174
      scm_desired_switch_rate = 0U;
    } else {
#line 177
      scm_switch_clock -= scm_async_rate;
    }
  }
#line 181
  if (scm_mask_ints) {
#line 183
    if (owe_switch) {
      {
#line 184
      scm_switch();
      }
    }
#line 185
    scm_async_clock = 1U;
#line 186
    return;
  }
#line 189
  if (! scm_tick_rate) {
#line 192
    owe_tick = 0;
#line 193
    r = scm_desired_tick_rate;
#line 194
    if (r) {
#line 196
      scm_desired_tick_rate = 0U;
#line 197
      scm_tick_rate = r;
#line 198
      scm_tick_clock = r;
    }
  } else {
#line 203
    owe_tick = scm_async_rate >= scm_tick_clock;
#line 204
    if (owe_tick) {
#line 206
      scm_tick_rate = scm_desired_tick_rate;
#line 206
      scm_tick_clock = scm_tick_rate;
#line 207
      scm_desired_tick_rate = 0U;
    } else
#line 211
    if (scm_desired_tick_rate) {
#line 213
      scm_tick_rate = scm_desired_tick_rate;
#line 213
      scm_tick_clock = scm_tick_rate;
#line 214
      scm_desired_tick_rate = 0U;
    } else {
#line 217
      scm_tick_clock -= scm_async_rate;
    }
  }
#line 221
  if (owe_tick) {
    {
#line 222
    scm_async_mark(system_signal_asyncs[7]);
    }
  }
#line 224
  scm_ints_disabled = 1;
#line 225
  if (scm_tick_rate) {
#line 225
    if (scm_switch_rate) {
#line 227
      if (scm_tick_clock <= scm_switch_clock) {
#line 227
        scm_async_rate = scm_tick_clock;
      } else {
#line 227
        scm_async_rate = scm_switch_clock;
      }
#line 228
      scm_async_clock = scm_async_rate;
    } else {
#line 225
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 230
  if (scm_tick_rate) {
#line 232
    scm_async_rate = scm_tick_clock;
#line 232
    scm_async_clock = scm_async_rate;
  } else
#line 234
  if (scm_switch_rate) {
#line 236
    scm_async_rate = scm_switch_clock;
#line 236
    scm_async_clock = scm_async_rate;
  } else {
#line 239
    scm_async_rate = (unsigned int )(1 << 16);
#line 239
    scm_async_clock = scm_async_rate;
  }
#line 240
  scm_ints_disabled = 0;
  tail: 
  {
#line 243
  scm_run_asyncs(scm_sys_protects[14]);
#line 245
  scm_ints_disabled = 1;
#line 246
  tmp = asyncs_pending();
  }
#line 246
  if (tmp) {
#line 248
    scm_ints_disabled = 0;
#line 249
    goto tail;
  }
#line 251
  scm_ints_disabled = 0;
#line 251
  scm_async_clock --;
#line 251
  if (0U == scm_async_clock) {
    {
#line 251
    scm_async_click();
    }
  }
#line 253
  if (owe_switch) {
    {
#line 254
    scm_switch();
    }
  }
#line 255
  return;
}
}
#line 261 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
void scm_switch(void) 
{ 


  {
#line 269
  return;
}
}
#line 273
static void scm_deliver_signal(int num ) ;
#line 275 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
static void scm_deliver_signal(int num ) 
{ 
  SCM handler ;
  SCM tmp ;

  {
#line 280
  handler = ((scm_cell *)handler_var)->cdr;
#line 281
  if (handler != (long )(16 << 9) + 372L) {
    {
#line 282
    scm_apply(handler, (long )(num << 2) + 2L, scm_sys_protects[1]);
    }
  } else {
    {
#line 285
    scm_mask_ints = 0U;
#line 286
    tmp = scm_listify((long )(num << 2) + 2L, (long )(18 << 9) + 372L);
#line 286
    scm_throw(symbol_signal, tmp);
    }
  }
#line 289
  return;
}
}
#line 295
static int print_async(SCM exp___0 , SCM port , scm_print_state *pstate ) ;
#line 297 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
static int print_async(SCM exp___0 , SCM port , scm_print_state *pstate ) 
{ 
  char *__cil_tmp4 ;

  {
  {
#line 303
  scm_gen_puts((enum scm_string_representation_type )0, (char *)"#<async ", port);
#line 304
  scm_intprint(exp___0, 16, port);
#line 305
  scm_gen_putc('>', port);
  }
#line 306
  return (1);
}
}
#line 310
static SCM mark_async(SCM obj ) ;
#line 312 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
static SCM mark_async(SCM obj ) 
{ 
  struct scm_async *it ;

  {
#line 317
  if (128 & (int )((scm_cell *)obj)->car) {
#line 318
    return ((long )(16 << 9) + 372L);
  }
#line 319
  ((scm_cell *)obj)->car |= 128L;
#line 320
  it = (struct scm_async *)((scm_cell *)obj)->cdr;
#line 321
  return (it->thunk);
}
}
#line 325
static size_t free_async(SCM obj ) ;
#line 327 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
static size_t free_async(SCM obj ) 
{ 
  struct scm_async *it ;

  {
  {
#line 332
  it = (struct scm_async *)((scm_cell *)obj)->cdr;
#line 333
  scm_must_free((char *)it);
  }
#line 334
  return (sizeof(*it));
}
}
#line 338 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
static scm_smobfuns async_smob  =    {& mark_async, & free_async, & print_async, (SCM (*)(SCM  , SCM  ))0};
#line 349 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
static char s_async[6]  = {      (char )'a',      (char )'s',      (char )'y',      (char )'n', 
        (char )'c',      (char )'\000'};
#line 351 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
SCM scm_async(SCM thunk ) 
{ 
  SCM it ;
  struct scm_async *async ;
  char *tmp ;

  {
#line 358
  if (6 & (int )scm_freelist) {
    {
#line 358
    it = scm_gc_for_newcell();
    }
  } else {
#line 358
    it = scm_freelist;
#line 358
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 358
    scm_cells_allocated ++;
  }
  {
#line 359
  scm_ints_disabled = 1;
#line 360
  ((scm_cell *)it)->cdr = (long )(20 << 9) + 372L;
#line 361
  tmp = scm_must_malloc((long )sizeof(*async), s_async);
#line 361
  async = (struct scm_async *)tmp;
#line 362
  async->got_it = 0;
#line 363
  async->thunk = thunk;
#line 364
  ((scm_cell *)it)->cdr = (SCM )async;
#line 365
  ((scm_cell *)it)->car = scm_tc16_async;
#line 366
  scm_ints_disabled = 0;
#line 366
  scm_async_clock --;
  }
#line 366
  if (0U == scm_async_clock) {
    {
#line 366
    scm_async_click();
    }
  }
#line 367
  return (it);
}
}
#line 370 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
static char s_system_async[13]  = 
#line 370
  {      (char )'s',      (char )'y',      (char )'s',      (char )'t', 
        (char )'e',      (char )'m',      (char )'-',      (char )'a', 
        (char )'s',      (char )'y',      (char )'n',      (char )'c', 
        (char )'\000'};
#line 372 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
SCM scm_system_async(SCM thunk ) 
{ 
  SCM it ;
  SCM list ;

  {
  {
#line 379
  it = scm_async(thunk);
  }
#line 380
  if (6 & (int )scm_freelist) {
    {
#line 380
    list = scm_gc_for_newcell();
    }
  } else {
#line 380
    list = scm_freelist;
#line 380
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 380
    scm_cells_allocated ++;
  }
#line 381
  scm_ints_disabled = 1;
#line 382
  ((scm_cell *)list)->car = it;
#line 383
  ((scm_cell *)list)->cdr = scm_sys_protects[14];
#line 384
  scm_sys_protects[14] = list;
#line 385
  scm_ints_disabled = 0;
#line 385
  scm_async_clock --;
#line 385
  if (0U == scm_async_clock) {
    {
#line 385
    scm_async_click();
    }
  }
#line 386
  return (it);
}
}
#line 389 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
static char s_async_mark[11]  = 
#line 389
  {      (char )'a',      (char )'s',      (char )'y',      (char )'n', 
        (char )'c',      (char )'-',      (char )'m',      (char )'a', 
        (char )'r',      (char )'k',      (char )'\000'};
#line 391 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
SCM scm_async_mark(SCM a ) 
{ 
  struct scm_async *it ;

  {
#line 396
  if (! (6 & (int )a)) {
#line 396
    if (! (scm_tc16_async == (long )(65407 & (int )((scm_cell *)a)->car))) {
      {
#line 396
      scm_wta(a, (char *)1, s_async_mark);
      }
    }
  } else {
    {
#line 396
    scm_wta(a, (char *)1, s_async_mark);
    }
  }
#line 397
  it = (struct scm_async *)((scm_cell *)a)->cdr;
#line 398
  it->got_it = 1;
#line 399
  return ((long )(21 << 9) + 372L);
}
}
#line 403 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
static char s_system_async_mark[18]  = 
#line 403
  {      (char )'s',      (char )'y',      (char )'s',      (char )'t', 
        (char )'e',      (char )'m',      (char )'-',      (char )'a', 
        (char )'s',      (char )'y',      (char )'n',      (char )'c', 
        (char )'-',      (char )'m',      (char )'a',      (char )'r', 
        (char )'k',      (char )'\000'};
#line 405 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
SCM scm_system_async_mark(SCM a ) 
{ 
  struct scm_async *it ;

  {
#line 410
  if (! (6 & (int )a)) {
#line 410
    if (! (scm_tc16_async == (long )(65407 & (int )((scm_cell *)a)->car))) {
      {
#line 410
      scm_wta(a, (char *)1, s_async_mark);
      }
    }
  } else {
    {
#line 410
    scm_wta(a, (char *)1, s_async_mark);
    }
  }
#line 411
  it = (struct scm_async *)((scm_cell *)a)->cdr;
#line 412
  scm_ints_disabled ++;
#line 413
  it->got_it = 1;
#line 414
  scm_async_rate = (1U + scm_async_rate) - scm_async_clock;
#line 415
  scm_async_clock = 1U;
#line 416
  scm_ints_disabled --;
#line 416
  if (! scm_ints_disabled) {
#line 416
    scm_async_clock --;
#line 416
    if (0U == scm_async_clock) {
      {
#line 416
      scm_async_click();
      }
    }
  }
#line 417
  return ((long )(21 << 9) + 372L);
}
}
#line 421 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
static char s_run_asyncs[11]  = 
#line 421
  {      (char )'r',      (char )'u',      (char )'n',      (char )'-', 
        (char )'a',      (char )'s',      (char )'y',      (char )'n', 
        (char )'c',      (char )'s',      (char )'\000'};
#line 423 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
SCM scm_run_asyncs(SCM list_of_a ) 
{ 
  SCM pos ;
  SCM a ;
  struct scm_async *it ;

  {
#line 429
  if (scm_mask_ints) {
#line 430
    return ((long )(16 << 9) + 372L);
  }
#line 431
  pos = list_of_a;
  {
#line 432
  while (1) {
    while_continue: /* CIL Label */ ;
#line 432
    if (! (pos != (long )(20 << 9) + 372L)) {
#line 432
      goto while_break;
    }
#line 436
    if (! (6 & (int )pos)) {
#line 436
      if (! (! (1 & (int )((scm_cell *)pos)->car))) {
        {
#line 436
        scm_wta(pos, (char *)1, s_run_asyncs);
        }
      }
    } else {
      {
#line 436
      scm_wta(pos, (char *)1, s_run_asyncs);
      }
    }
#line 437
    a = ((scm_cell *)pos)->car;
#line 438
    if (! (6 & (int )a)) {
#line 438
      if (! (scm_tc16_async == (long )(65407 & (int )((scm_cell *)a)->car))) {
        {
#line 438
        scm_wta(a, (char *)1, s_run_asyncs);
        }
      }
    } else {
      {
#line 438
      scm_wta(a, (char *)1, s_run_asyncs);
      }
    }
#line 439
    it = (struct scm_async *)((scm_cell *)a)->cdr;
#line 440
    scm_mask_ints = 1U;
#line 441
    if (it->got_it) {
      {
#line 443
      it->got_it = 0;
#line 444
      scm_apply(it->thunk, (long )(20 << 9) + 372L, (long )(20 << 9) + 372L);
      }
    }
#line 446
    scm_mask_ints = 0U;
#line 447
    pos = ((scm_cell *)pos)->cdr;
  }
  while_break: /* CIL Label */ ;
  }
#line 449
  return ((long )(17 << 9) + 372L);
}
}
#line 455 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
static char s_noop[5]  = {      (char )'n',      (char )'o',      (char )'o',      (char )'p', 
        (char )'\000'};
#line 457 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
SCM scm_noop(SCM args ) 
{ 
  long tmp ;

  {
#line 461
  if ((long )(20 << 9) + 372L == args) {
#line 461
    tmp = (long )(16 << 9) + 372L;
  } else {
#line 461
    tmp = ((scm_cell *)args)->car;
  }
#line 461
  return (tmp);
}
}
#line 469 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
static char s_set_tick_rate[14]  = 
#line 469
  {      (char )'s',      (char )'e',      (char )'t',      (char )'-', 
        (char )'t',      (char )'i',      (char )'c',      (char )'k', 
        (char )'-',      (char )'r',      (char )'a',      (char )'t', 
        (char )'e',      (char )'\000'};
#line 471 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
SCM scm_set_tick_rate(SCM n ) 
{ 
  unsigned int old_n ;

  {
#line 476
  if (! (2 & (int )n)) {
    {
#line 476
    scm_wta(n, (char *)1, s_set_tick_rate);
    }
  }
#line 477
  old_n = scm_tick_rate;
#line 478
  scm_desired_tick_rate = (unsigned int )(n >> 2);
#line 479
  scm_async_rate = (1U + scm_async_rate) - scm_async_clock;
#line 480
  scm_async_clock = 1U;
#line 481
  return ((long )(old_n << 2) + 2L);
}
}
#line 487 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
static char s_set_switch_rate[16]  = 
#line 487
  {      (char )'s',      (char )'e',      (char )'t',      (char )'-', 
        (char )'s',      (char )'w',      (char )'i',      (char )'t', 
        (char )'c',      (char )'h',      (char )'-',      (char )'r', 
        (char )'a',      (char )'t',      (char )'e',      (char )'\000'};
#line 489 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
SCM scm_set_switch_rate(SCM n ) 
{ 
  unsigned int old_n ;

  {
#line 494
  if (! (2 & (int )n)) {
    {
#line 494
    scm_wta(n, (char *)1, s_set_switch_rate);
    }
  }
#line 495
  old_n = scm_switch_rate;
#line 496
  scm_desired_switch_rate = (unsigned int )(n >> 2);
#line 497
  scm_async_rate = (1U + scm_async_rate) - scm_async_clock;
#line 498
  scm_async_clock = 1U;
#line 499
  return ((long )(old_n << 2) + 2L);
}
}
#line 505
static SCM scm_sys_hup_async_thunk(void) ;
#line 507 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
static SCM scm_sys_hup_async_thunk(void) 
{ 


  {
  {
#line 510
  scm_deliver_signal(14);
  }
#line 511
  return ((long )(16 << 9) + 372L);
}
}
#line 515
static SCM scm_sys_int_async_thunk(void) ;
#line 517 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
static SCM scm_sys_int_async_thunk(void) 
{ 


  {
  {
#line 520
  scm_deliver_signal(15);
  }
#line 521
  return ((long )(16 << 9) + 372L);
}
}
#line 525
static SCM scm_sys_fpe_async_thunk(void) ;
#line 527 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
static SCM scm_sys_fpe_async_thunk(void) 
{ 


  {
  {
#line 530
  scm_deliver_signal(16);
  }
#line 531
  return ((long )(16 << 9) + 372L);
}
}
#line 535
static SCM scm_sys_bus_async_thunk(void) ;
#line 537 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
static SCM scm_sys_bus_async_thunk(void) 
{ 


  {
  {
#line 540
  scm_deliver_signal(17);
  }
#line 541
  return ((long )(16 << 9) + 372L);
}
}
#line 545
static SCM scm_sys_segv_async_thunk(void) ;
#line 547 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
static SCM scm_sys_segv_async_thunk(void) 
{ 


  {
  {
#line 550
  scm_deliver_signal(18);
  }
#line 551
  return ((long )(16 << 9) + 372L);
}
}
#line 555
static SCM scm_sys_alrm_async_thunk(void) ;
#line 557 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
static SCM scm_sys_alrm_async_thunk(void) 
{ 


  {
  {
#line 560
  scm_deliver_signal(19);
  }
#line 561
  return ((long )(16 << 9) + 372L);
}
}
#line 565
static SCM scm_sys_gc_async_thunk(void) ;
#line 567 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
static SCM scm_sys_gc_async_thunk(void) 
{ 


  {
  {
#line 570
  scm_deliver_signal(20);
  }
#line 571
  return ((long )(16 << 9) + 372L);
}
}
#line 575
static SCM scm_sys_tick_async_thunk(void) ;
#line 577 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
static SCM scm_sys_tick_async_thunk(void) 
{ 


  {
  {
#line 580
  scm_deliver_signal(21);
  }
#line 581
  return ((long )(16 << 9) + 372L);
}
}
#line 589 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
SCM scm_take_signal(int n ) 
{ 
  SCM ignored ;

  {
#line 594
  if (! scm_ints_disabled) {
#line 607
    if (6 & (int )scm_freelist) {
      {
#line 607
      ignored = scm_gc_for_newcell();
      }
    } else {
#line 607
      ignored = scm_freelist;
#line 607
      scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 607
      scm_cells_allocated ++;
    }
  }
  {
#line 609
  scm_system_async_mark(system_signal_asyncs[n - 14]);
  }
#line 610
  return ((long )(16 << 9) + 372L);
}
}
#line 615 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
static char s_unmask_signals[15]  = 
#line 615
  {      (char )'u',      (char )'n',      (char )'m',      (char )'a', 
        (char )'s',      (char )'k',      (char )'-',      (char )'s', 
        (char )'i',      (char )'g',      (char )'n',      (char )'a', 
        (char )'l',      (char )'s',      (char )'\000'};
#line 617 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
SCM scm_unmask_signals(void) 
{ 


  {
#line 620
  scm_mask_ints = 0U;
#line 621
  return ((long )(21 << 9) + 372L);
}
}
#line 625 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
static char s_mask_signals[13]  = 
#line 625
  {      (char )'m',      (char )'a',      (char )'s',      (char )'k', 
        (char )'-',      (char )'s',      (char )'i',      (char )'g', 
        (char )'n',      (char )'a',      (char )'l',      (char )'s', 
        (char )'\000'};
#line 627 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
SCM scm_mask_signals(void) 
{ 


  {
#line 630
  scm_mask_ints = 1U;
#line 631
  return ((long )(21 << 9) + 372L);
}
}
#line 637 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
void scm_init_async(void) 
{ 
  SCM a_thunk ;
  SCM tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 641
  scm_tc16_async = scm_newsmob(& async_smob);
#line 642
  tmp = scm_sysintern((char *)"signal", (long )(18 << 9) + 372L);
#line 642
  symbol_signal = ((scm_cell *)tmp)->car;
#line 643
  scm_permanent_object(symbol_signal);
#line 649
  a_thunk = scm_make_gsubr((char *)"%hup-thunk", 0, 0, 0, & scm_sys_hup_async_thunk);
#line 650
  system_signal_asyncs[0] = scm_system_async(a_thunk);
#line 651
  a_thunk = scm_make_gsubr((char *)"%int-thunk", 0, 0, 0, & scm_sys_int_async_thunk);
#line 652
  system_signal_asyncs[1] = scm_system_async(a_thunk);
#line 653
  a_thunk = scm_make_gsubr((char *)"%fpe-thunk", 0, 0, 0, & scm_sys_fpe_async_thunk);
#line 654
  system_signal_asyncs[2] = scm_system_async(a_thunk);
#line 655
  a_thunk = scm_make_gsubr((char *)"%bus-thunk", 0, 0, 0, & scm_sys_bus_async_thunk);
#line 656
  system_signal_asyncs[3] = scm_system_async(a_thunk);
#line 657
  a_thunk = scm_make_gsubr((char *)"%segv-thunk", 0, 0, 0, & scm_sys_segv_async_thunk);
#line 658
  system_signal_asyncs[4] = scm_system_async(a_thunk);
#line 661
  a_thunk = scm_make_gsubr((char *)"%gc-thunk", 0, 0, 0, & scm_sys_gc_async_thunk);
#line 662
  system_signal_asyncs[6] = scm_system_async(a_thunk);
#line 665
  a_thunk = scm_make_gsubr((char *)"%tick-thunk", 0, 0, 0, & scm_sys_tick_async_thunk);
#line 666
  system_signal_asyncs[7] = scm_system_async(a_thunk);
#line 667
  a_thunk = scm_make_gsubr((char *)"%alrm-thunk", 0, 0, 0, & scm_sys_alrm_async_thunk);
#line 668
  system_signal_asyncs[5] = scm_system_async(a_thunk);
#line 670
  handler_var = scm_sysintern((char *)"signal-handler", (long )(18 << 9) + 372L);
#line 671
  ((scm_cell *)handler_var)->cdr = (long )(16 << 9) + 372L;
#line 672
  scm_permanent_object(handler_var);
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.x"
  scm_make_gsubr(s_async, 1, 0, 0, (SCM (*)())(& scm_async));
#line 2
  scm_make_gsubr(s_system_async, 1, 0, 0, (SCM (*)())(& scm_system_async));
#line 3
  scm_make_gsubr(s_async_mark, 1, 0, 0, (SCM (*)())(& scm_async_mark));
#line 4
  scm_make_gsubr(s_system_async_mark, 1, 0, 0, (SCM (*)())(& scm_system_async_mark));
#line 5
  scm_make_gsubr(s_run_asyncs, 1, 0, 0, (SCM (*)())(& scm_run_asyncs));
#line 6
  scm_make_gsubr(s_noop, 0, 0, 1, (SCM (*)())(& scm_noop));
#line 7
  scm_make_gsubr(s_set_tick_rate, 1, 0, 0, (SCM (*)())(& scm_set_tick_rate));
#line 8
  scm_make_gsubr(s_set_switch_rate, 1, 0, 0, (SCM (*)())(& scm_set_switch_rate));
#line 9
  scm_make_gsubr(s_unmask_signals, 0, 0, 0, & scm_unmask_signals);
#line 10
  scm_make_gsubr(s_mask_signals, 0, 0, 0, & scm_mask_signals);
  }
#line 674 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/async.c"
  return;
}
}
#line 51 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/arbiters.h"
SCM scm_make_arbiter(SCM name ) ;
#line 52
SCM scm_try_arbiter(SCM arb ) ;
#line 53
SCM scm_release_arbiter(SCM arb ) ;
#line 57 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/arbiters.c"
static long scm_tc16_arbiter  ;
#line 60 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/arbiters.c"
static int prinarb(SCM exp___0 , SCM port , scm_print_state *pstate ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 66
  scm_gen_puts((enum scm_string_representation_type )0, (char *)"#<arbiter ", port);
  }
#line 67
  if (((scm_cell *)exp___0)->car & (1L << 16)) {
    {
#line 68
    scm_gen_puts((enum scm_string_representation_type )0, (char *)"locked ", port);
    }
  }
  {
#line 69
  scm_iprin1(((scm_cell *)exp___0)->cdr, port, pstate);
#line 70
  scm_gen_putc('>', port);
  }
#line 71
  return (1);
}
}
#line 74 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/arbiters.c"
static scm_smobfuns arbsmob  =    {& scm_markcdr, & scm_free0, & prinarb, (SCM (*)(SCM  , SCM  ))0};
#line 79 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/arbiters.c"
static char s_make_arbiter[13]  = 
#line 79
  {      (char )'m',      (char )'a',      (char )'k',      (char )'e', 
        (char )'-',      (char )'a',      (char )'r',      (char )'b', 
        (char )'i',      (char )'t',      (char )'e',      (char )'r', 
        (char )'\000'};
#line 81 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/arbiters.c"
SCM scm_make_arbiter(SCM name ) 
{ 
  register SCM z ;

  {
#line 86
  if (6 & (int )scm_freelist) {
    {
#line 86
    z = scm_gc_for_newcell();
    }
  } else {
#line 86
    z = scm_freelist;
#line 86
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 86
    scm_cells_allocated ++;
  }
#line 87
  ((scm_cell *)z)->cdr = name;
#line 88
  ((scm_cell *)z)->car = scm_tc16_arbiter;
#line 89
  return (z);
}
}
#line 92 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/arbiters.c"
static char s_try_arbiter[12]  = 
#line 92
  {      (char )'t',      (char )'r',      (char )'y',      (char )'-', 
        (char )'a',      (char )'r',      (char )'b',      (char )'i', 
        (char )'t',      (char )'e',      (char )'r',      (char )'\000'};
#line 94 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/arbiters.c"
SCM scm_try_arbiter(SCM arb ) 
{ 


  {
#line 98
  if (! ((long )(65535 & (int )((scm_cell *)arb)->car) == scm_tc16_arbiter)) {
    {
#line 98
    scm_wta(arb, (char *)1, s_try_arbiter);
    }
  }
#line 99
  scm_ints_disabled = 1;
#line 100
  if (((scm_cell *)arb)->car & (1L << 16)) {
#line 101
    arb = (long )(16 << 9) + 372L;
  } else {
#line 104
    ((scm_cell *)arb)->car = scm_tc16_arbiter | (1L << 16);
#line 105
    arb = (long )(17 << 9) + 372L;
  }
#line 107
  scm_ints_disabled = 0;
#line 107
  scm_async_clock --;
#line 107
  if (0U == scm_async_clock) {
    {
#line 107
    scm_async_click();
    }
  }
#line 108
  return (arb);
}
}
#line 112 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/arbiters.c"
static char s_release_arbiter[16]  = 
#line 112
  {      (char )'r',      (char )'e',      (char )'l',      (char )'e', 
        (char )'a',      (char )'s',      (char )'e',      (char )'-', 
        (char )'a',      (char )'r',      (char )'b',      (char )'i', 
        (char )'t',      (char )'e',      (char )'r',      (char )'\000'};
#line 114 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/arbiters.c"
SCM scm_release_arbiter(SCM arb ) 
{ 


  {
#line 118
  if (! ((long )(65535 & (int )((scm_cell *)arb)->car) == scm_tc16_arbiter)) {
    {
#line 118
    scm_wta(arb, (char *)1, s_release_arbiter);
    }
  }
#line 119
  if (! (((scm_cell *)arb)->car & (1L << 16))) {
#line 120
    return ((long )(16 << 9) + 372L);
  }
#line 121
  ((scm_cell *)arb)->car = scm_tc16_arbiter;
#line 122
  return ((long )(17 << 9) + 372L);
}
}
#line 127 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/arbiters.c"
void scm_init_arbiters(void) 
{ 


  {
  {
#line 130
  scm_tc16_arbiter = scm_newsmob(& arbsmob);
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/arbiters.x"
  scm_make_gsubr(s_make_arbiter, 1, 0, 0, (SCM (*)())(& scm_make_arbiter));
#line 2
  scm_make_gsubr(s_try_arbiter, 1, 0, 0, (SCM (*)())(& scm_try_arbiter));
#line 3
  scm_make_gsubr(s_release_arbiter, 1, 0, 0, (SCM (*)())(& scm_release_arbiter));
  }
#line 132 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/arbiters.c"
  return;
}
}
#line 49 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/appinit.c"
void scm_appinit(void) 
{ 


  {
#line 52
  return;
}
}
#line 52 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/append.h"
SCM scm_append_x(SCM objs ) ;
#line 51 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/append.c"
static char s_append[7]  = {      (char )'a',      (char )'p',      (char )'p',      (char )'e', 
        (char )'n',      (char )'d',      (char )'\000'};
#line 53 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/append.c"
SCM scm_append(SCM objs ) 
{ 
  SCM tmp ;

  {
  {
#line 57
  tmp = scm_list_append(objs);
  }
#line 57
  return (tmp);
}
}
#line 61 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/append.c"
static char s_append_x[8]  = 
#line 61
  {      (char )'a',      (char )'p',      (char )'p',      (char )'e', 
        (char )'n',      (char )'d',      (char )'!',      (char )'\000'};
#line 63 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/append.c"
SCM scm_append_x(SCM objs ) 
{ 
  SCM tmp ;

  {
  {
#line 67
  tmp = scm_list_append_x(objs);
  }
#line 67
  return (tmp);
}
}
#line 73 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/append.c"
void scm_init_append(void) 
{ 


  {
  {
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/append.x"
  scm_make_gsubr(s_append, 0, 0, 1, (SCM (*)())(& scm_append));
#line 2
  scm_make_gsubr(s_append_x, 0, 0, 1, (SCM (*)())(& scm_append_x));
  }
#line 77 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/append.c"
  return;
}
}
#line 56 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/alist.h"
SCM scm_assv(SCM x , SCM alist ) ;
#line 58
SCM scm_assq_ref(SCM alist , SCM key ) ;
#line 59
SCM scm_assv_ref(SCM alist , SCM key ) ;
#line 60
SCM scm_assoc_ref(SCM alist , SCM key ) ;
#line 61
SCM scm_assq_set_x(SCM alist , SCM key , SCM val ) ;
#line 62
SCM scm_assv_set_x(SCM alist , SCM key , SCM val ) ;
#line 63
SCM scm_assoc_set_x(SCM alist , SCM key , SCM val ) ;
#line 64
SCM scm_assq_remove_x(SCM alist , SCM key ) ;
#line 65
SCM scm_assv_remove_x(SCM alist , SCM key ) ;
#line 66
SCM scm_assoc_remove_x(SCM alist , SCM key ) ;
#line 51 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/alist.c"
static char s_acons[6]  = {      (char )'a',      (char )'c',      (char )'o',      (char )'n', 
        (char )'s',      (char )'\000'};
#line 53 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/alist.c"
SCM scm_acons(SCM w , SCM x , SCM y ) 
{ 
  register SCM z ;

  {
#line 60
  if (6 & (int )scm_freelist) {
    {
#line 60
    z = scm_gc_for_newcell();
    }
  } else {
#line 60
    z = scm_freelist;
#line 60
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 60
    scm_cells_allocated ++;
  }
#line 61
  ((scm_cell *)z)->car = w;
#line 62
  ((scm_cell *)z)->cdr = x;
#line 63
  x = z;
#line 64
  if (6 & (int )scm_freelist) {
    {
#line 64
    z = scm_gc_for_newcell();
    }
  } else {
#line 64
    z = scm_freelist;
#line 64
    scm_freelist = ((scm_cell *)scm_freelist)->cdr;
#line 64
    scm_cells_allocated ++;
  }
#line 65
  ((scm_cell *)z)->car = x;
#line 66
  ((scm_cell *)z)->cdr = y;
#line 67
  return (z);
}
}
#line 72 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/alist.c"
static char s_sloppy_assq[12]  = 
#line 72
  {      (char )'s',      (char )'l',      (char )'o',      (char )'p', 
        (char )'p',      (char )'y',      (char )'-',      (char )'a', 
        (char )'s',      (char )'s',      (char )'q',      (char )'\000'};
#line 74 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/alist.c"
SCM scm_sloppy_assq(SCM x , SCM alist ) 
{ 
  SCM tmp ;

  {
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    if (! (6 & (int )alist)) {
#line 80
      if (! (! (1 & (int )((scm_cell *)alist)->car))) {
#line 80
        goto while_break;
      }
    } else {
#line 80
      goto while_break;
    }
#line 82
    tmp = ((scm_cell *)alist)->car;
#line 83
    if (! (6 & (int )tmp)) {
#line 83
      if (! (1 & (int )((scm_cell *)tmp)->car)) {
#line 83
        if (((scm_cell *)tmp)->car == x) {
#line 84
          return (tmp);
        }
      }
    }
#line 80
    alist = ((scm_cell *)alist)->cdr;
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  return ((long )(16 << 9) + 372L);
}
}
#line 91 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/alist.c"
static char s_sloppy_assv[12]  = 
#line 91
  {      (char )'s',      (char )'l',      (char )'o',      (char )'p', 
        (char )'p',      (char )'y',      (char )'-',      (char )'a', 
        (char )'s',      (char )'s',      (char )'v',      (char )'\000'};
#line 93 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/alist.c"
SCM scm_sloppy_assv(SCM x , SCM alist ) 
{ 
  SCM tmp ;
  SCM tmp___0 ;

  {
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (6 & (int )alist)) {
#line 98
      if (! (! (1 & (int )((scm_cell *)alist)->car))) {
#line 98
        goto while_break;
      }
    } else {
#line 98
      goto while_break;
    }
#line 100
    tmp = ((scm_cell *)alist)->car;
#line 101
    if (! (6 & (int )tmp)) {
#line 101
      if (! (1 & (int )((scm_cell *)tmp)->car)) {
        {
#line 101
        tmp___0 = scm_eqv_p(((scm_cell *)tmp)->car, x);
        }
#line 101
        if ((long )(16 << 9) + 372L != tmp___0) {
#line 104
          return (tmp);
        }
      }
    }
#line 98
    alist = ((scm_cell *)alist)->cdr;
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  return ((long )(16 << 9) + 372L);
}
}
#line 110 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/alist.c"
static char s_sloppy_assoc[13]  = 
#line 110
  {      (char )'s',      (char )'l',      (char )'o',      (char )'p', 
        (char )'p',      (char )'y',      (char )'-',      (char )'a', 
        (char )'s',      (char )'s',      (char )'o',      (char )'c', 
        (char )'\000'};
#line 112 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/alist.c"
SCM scm_sloppy_assoc(SCM x , SCM alist ) 
{ 
  SCM tmp ;
  SCM tmp___0 ;

  {
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! (6 & (int )alist)) {
#line 117
      if (! (! (1 & (int )((scm_cell *)alist)->car))) {
#line 117
        goto while_break;
      }
    } else {
#line 117
      goto while_break;
    }
#line 119
    tmp = ((scm_cell *)alist)->car;
#line 120
    if (! (6 & (int )tmp)) {
#line 120
      if (! (1 & (int )((scm_cell *)tmp)->car)) {
        {
#line 120
        tmp___0 = scm_equal_p(((scm_cell *)tmp)->car, x);
        }
#line 120
        if ((long )(16 << 9) + 372L != tmp___0) {
#line 123
          return (tmp);
        }
      }
    }
#line 117
    alist = ((scm_cell *)alist)->cdr;
  }
  while_break: /* CIL Label */ ;
  }
#line 125
  return ((long )(16 << 9) + 372L);
}
}
#line 131 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/alist.c"
static char s_assq[5]  = {      (char )'a',      (char )'s',      (char )'s',      (char )'q', 
        (char )'\000'};
#line 133 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/alist.c"
SCM scm_assq(SCM x , SCM alist ) 
{ 
  SCM tmp ;

  {
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    if (! (! (6 & (int )alist))) {
#line 139
      goto while_break;
    }
#line 140
    if (! (! (1 & (int )((scm_cell *)alist)->car))) {
      {
#line 140
      scm_wta(alist, (char *)2, s_assq);
      }
    }
#line 141
    tmp = ((scm_cell *)alist)->car;
#line 142
    if (! (6 & (int )tmp)) {
#line 142
      if (! (! (1 & (int )((scm_cell *)tmp)->car))) {
        {
#line 142
        scm_wta(alist, (char *)2, s_assq);
        }
      }
    } else {
      {
#line 142
      scm_wta(alist, (char *)2, s_assq);
      }
    }
#line 143
    if (((scm_cell *)tmp)->car == x) {
#line 143
      return (tmp);
    }
#line 139
    alist = ((scm_cell *)alist)->cdr;
  }
  while_break: /* CIL Label */ ;
  }
#line 145
  if (! ((long )(20 << 9) + 372L == alist)) {
    {
#line 145
    scm_wta(alist, (char *)2, s_assq);
    }
  }
#line 146
  return ((long )(16 << 9) + 372L);
}
}
#line 150 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/alist.c"
static char s_assv[5]  = {      (char )'a',      (char )'s',      (char )'s',      (char )'v', 
        (char )'\000'};
#line 152 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/alist.c"
SCM scm_assv(SCM x , SCM alist ) 
{ 
  SCM tmp ;
  SCM tmp___0 ;

  {
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (! (! (6 & (int )alist))) {
#line 158
      goto while_break;
    }
#line 159
    if (! (! (1 & (int )((scm_cell *)alist)->car))) {
#line 159
      goto badlst;
    }
#line 160
    tmp = ((scm_cell *)alist)->car;
#line 161
    if (! (6 & (int )tmp)) {
#line 161
      if (! (! (1 & (int )((scm_cell *)tmp)->car))) {
#line 161
        goto badlst;
      }
    } else {
#line 161
      goto badlst;
    }
    {
#line 162
    tmp___0 = scm_eqv_p(((scm_cell *)tmp)->car, x);
    }
#line 162
    if ((long )(16 << 9) + 372L != tmp___0) {
#line 162
      return (tmp);
    }
#line 158
    alist = ((scm_cell *)alist)->cdr;
  }
  while_break: /* CIL Label */ ;
  }
#line 165
  if (! ((long )(20 << 9) + 372L == alist)) {
    badlst: 
    {
#line 166
    scm_wta(alist, (char *)2, s_assv);
    }
  }
#line 168
  return ((long )(16 << 9) + 372L);
}
}
#line 172 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/alist.c"
static char s_assoc[6]  = {      (char )'a',      (char )'s',      (char )'s',      (char )'o', 
        (char )'c',      (char )'\000'};
#line 174 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/alist.c"
SCM scm_assoc(SCM x , SCM alist ) 
{ 
  SCM tmp ;
  SCM tmp___0 ;

  {
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 180
    if (! (! (6 & (int )alist))) {
#line 180
      goto while_break;
    }
#line 181
    if (! (! (1 & (int )((scm_cell *)alist)->car))) {
      {
#line 181
      scm_wta(alist, (char *)2, s_assoc);
      }
    }
#line 182
    tmp = ((scm_cell *)alist)->car;
#line 183
    if (! (6 & (int )tmp)) {
#line 183
      if (! (! (1 & (int )((scm_cell *)tmp)->car))) {
        {
#line 183
        scm_wta(alist, (char *)2, s_assoc);
        }
      }
    } else {
      {
#line 183
      scm_wta(alist, (char *)2, s_assoc);
      }
    }
    {
#line 184
    tmp___0 = scm_equal_p(((scm_cell *)tmp)->car, x);
    }
#line 184
    if ((long )(16 << 9) + 372L != tmp___0) {
#line 184
      return (tmp);
    }
#line 180
    alist = ((scm_cell *)alist)->cdr;
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  if (! ((long )(20 << 9) + 372L == alist)) {
    {
#line 186
    scm_wta(alist, (char *)2, s_assoc);
    }
  }
#line 187
  return ((long )(16 << 9) + 372L);
}
}
#line 193 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/alist.c"
static char s_assq_ref[9]  = 
#line 193
  {      (char )'a',      (char )'s',      (char )'s',      (char )'q', 
        (char )'-',      (char )'r',      (char )'e',      (char )'f', 
        (char )'\000'};
#line 195 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/alist.c"
SCM scm_assq_ref(SCM alist , SCM key ) 
{ 
  SCM handle ;

  {
  {
#line 202
  handle = scm_sloppy_assq(key, alist);
  }
#line 203
  if (! (6 & (int )handle)) {
#line 203
    if (! (1 & (int )((scm_cell *)handle)->car)) {
#line 205
      return (((scm_cell *)handle)->cdr);
    }
  }
#line 207
  return ((long )(16 << 9) + 372L);
}
}
#line 211 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/alist.c"
static char s_assv_ref[9]  = 
#line 211
  {      (char )'a',      (char )'s',      (char )'s',      (char )'v', 
        (char )'-',      (char )'r',      (char )'e',      (char )'f', 
        (char )'\000'};
#line 213 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/alist.c"
SCM scm_assv_ref(SCM alist , SCM key ) 
{ 
  SCM handle ;

  {
  {
#line 220
  handle = scm_sloppy_assv(key, alist);
  }
#line 221
  if (! (6 & (int )handle)) {
#line 221
    if (! (1 & (int )((scm_cell *)handle)->car)) {
#line 223
      return (((scm_cell *)handle)->cdr);
    }
  }
#line 225
  return ((long )(16 << 9) + 372L);
}
}
#line 229 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/alist.c"
static char s_assoc_ref[10]  = 
#line 229
  {      (char )'a',      (char )'s',      (char )'s',      (char )'o', 
        (char )'c',      (char )'-',      (char )'r',      (char )'e', 
        (char )'f',      (char )'\000'};
#line 231 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/alist.c"
SCM scm_assoc_ref(SCM alist , SCM key ) 
{ 
  SCM handle ;

  {
  {
#line 238
  handle = scm_sloppy_assoc(key, alist);
  }
#line 239
  if (! (6 & (int )handle)) {
#line 239
    if (! (1 & (int )((scm_cell *)handle)->car)) {
#line 241
      return (((scm_cell *)handle)->cdr);
    }
  }
#line 243
  return ((long )(16 << 9) + 372L);
}
}
#line 251 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/alist.c"
static char s_assq_set_x[10]  = 
#line 251
  {      (char )'a',      (char )'s',      (char )'s',      (char )'q', 
        (char )'-',      (char )'s',      (char )'e',      (char )'t', 
        (char )'!',      (char )'\000'};
#line 253 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/alist.c"
SCM scm_assq_set_x(SCM alist , SCM key , SCM val ) 
{ 
  SCM handle ;
  SCM tmp ;

  {
  {
#line 261
  handle = scm_sloppy_assq(key, alist);
  }
#line 262
  if (! (6 & (int )handle)) {
#line 262
    if (! (1 & (int )((scm_cell *)handle)->car)) {
#line 264
      ((scm_cell *)handle)->cdr = val;
#line 265
      return (alist);
    } else {
      {
#line 268
      tmp = scm_acons(key, val, alist);
      }
#line 268
      return (tmp);
    }
  } else {
    {
#line 268
    tmp = scm_acons(key, val, alist);
    }
#line 268
    return (tmp);
  }
}
}
#line 271 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/alist.c"
static char s_assv_set_x[10]  = 
#line 271
  {      (char )'a',      (char )'s',      (char )'s',      (char )'v', 
        (char )'-',      (char )'s',      (char )'e',      (char )'t', 
        (char )'!',      (char )'\000'};
#line 273 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/alist.c"
SCM scm_assv_set_x(SCM alist , SCM key , SCM val ) 
{ 
  SCM handle ;
  SCM tmp ;

  {
  {
#line 281
  handle = scm_sloppy_assv(key, alist);
  }
#line 282
  if (! (6 & (int )handle)) {
#line 282
    if (! (1 & (int )((scm_cell *)handle)->car)) {
#line 284
      ((scm_cell *)handle)->cdr = val;
#line 285
      return (alist);
    } else {
      {
#line 288
      tmp = scm_acons(key, val, alist);
      }
#line 288
      return (tmp);
    }
  } else {
    {
#line 288
    tmp = scm_acons(key, val, alist);
    }
#line 288
    return (tmp);
  }
}
}
#line 291 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/alist.c"
static char s_assoc_set_x[11]  = 
#line 291
  {      (char )'a',      (char )'s',      (char )'s',      (char )'o', 
        (char )'c',      (char )'-',      (char )'s',      (char )'e', 
        (char )'t',      (char )'!',      (char )'\000'};
#line 293 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/alist.c"
SCM scm_assoc_set_x(SCM alist , SCM key , SCM val ) 
{ 
  SCM handle ;
  SCM tmp ;

  {
  {
#line 301
  handle = scm_sloppy_assoc(key, alist);
  }
#line 302
  if (! (6 & (int )handle)) {
#line 302
    if (! (1 & (int )((scm_cell *)handle)->car)) {
#line 304
      ((scm_cell *)handle)->cdr = val;
#line 305
      return (alist);
    } else {
      {
#line 308
      tmp = scm_acons(key, val, alist);
      }
#line 308
      return (tmp);
    }
  } else {
    {
#line 308
    tmp = scm_acons(key, val, alist);
    }
#line 308
    return (tmp);
  }
}
}
#line 314 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/alist.c"
static char s_assq_remove_x[13]  = 
#line 314
  {      (char )'a',      (char )'s',      (char )'s',      (char )'q', 
        (char )'-',      (char )'r',      (char )'e',      (char )'m', 
        (char )'o',      (char )'v',      (char )'e',      (char )'!', 
        (char )'\000'};
#line 316 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/alist.c"
SCM scm_assq_remove_x(SCM alist , SCM key ) 
{ 
  SCM handle ;
  SCM tmp ;

  {
  {
#line 323
  handle = scm_sloppy_assq(key, alist);
  }
#line 324
  if (! (6 & (int )handle)) {
#line 324
    if (! (1 & (int )((scm_cell *)handle)->car)) {
      {
#line 326
      tmp = scm_delq_x(handle, alist);
      }
#line 326
      return (tmp);
    } else {
#line 329
      return (alist);
    }
  } else {
#line 329
    return (alist);
  }
}
}
#line 333 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/alist.c"
static char s_assv_remove_x[13]  = 
#line 333
  {      (char )'a',      (char )'s',      (char )'s',      (char )'v', 
        (char )'-',      (char )'r',      (char )'e',      (char )'m', 
        (char )'o',      (char )'v',      (char )'e',      (char )'!', 
        (char )'\000'};
#line 335 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/alist.c"
SCM scm_assv_remove_x(SCM alist , SCM key ) 
{ 
  SCM handle ;
  SCM tmp ;

  {
  {
#line 342
  handle = scm_sloppy_assv(key, alist);
  }
#line 343
  if (! (6 & (int )handle)) {
#line 343
    if (! (1 & (int )((scm_cell *)handle)->car)) {
      {
#line 345
      tmp = scm_delv_x(handle, alist);
      }
#line 345
      return (tmp);
    } else {
#line 348
      return (alist);
    }
  } else {
#line 348
    return (alist);
  }
}
}
#line 352 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/alist.c"
static char s_assoc_remove_x[14]  = 
#line 352
  {      (char )'a',      (char )'s',      (char )'s',      (char )'o', 
        (char )'c',      (char )'-',      (char )'r',      (char )'e', 
        (char )'m',      (char )'o',      (char )'v',      (char )'e', 
        (char )'!',      (char )'\000'};
#line 354 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/alist.c"
SCM scm_assoc_remove_x(SCM alist , SCM key ) 
{ 
  SCM handle ;
  SCM tmp ;

  {
  {
#line 361
  handle = scm_sloppy_assoc(key, alist);
  }
#line 362
  if (! (6 & (int )handle)) {
#line 362
    if (! (1 & (int )((scm_cell *)handle)->car)) {
      {
#line 364
      tmp = scm_delete_x(handle, alist);
      }
#line 364
      return (tmp);
    } else {
#line 367
      return (alist);
    }
  } else {
#line 367
    return (alist);
  }
}
}
#line 375 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/alist.c"
void scm_init_alist(void) 
{ 


  {
  {
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/alist.x"
  scm_make_gsubr(s_acons, 3, 0, 0, (SCM (*)())(& scm_acons));
#line 2
  scm_make_gsubr(s_sloppy_assq, 2, 0, 0, (SCM (*)())(& scm_sloppy_assq));
#line 3
  scm_make_gsubr(s_sloppy_assv, 2, 0, 0, (SCM (*)())(& scm_sloppy_assv));
#line 4
  scm_make_gsubr(s_sloppy_assoc, 2, 0, 0, (SCM (*)())(& scm_sloppy_assoc));
#line 5
  scm_make_gsubr(s_assq, 2, 0, 0, (SCM (*)())(& scm_assq));
#line 6
  scm_make_gsubr(s_assv, 2, 0, 0, (SCM (*)())(& scm_assv));
#line 7
  scm_make_gsubr(s_assoc, 2, 0, 0, (SCM (*)())(& scm_assoc));
#line 8
  scm_make_gsubr(s_assq_ref, 2, 0, 0, (SCM (*)())(& scm_assq_ref));
#line 9
  scm_make_gsubr(s_assv_ref, 2, 0, 0, (SCM (*)())(& scm_assv_ref));
#line 10
  scm_make_gsubr(s_assoc_ref, 2, 0, 0, (SCM (*)())(& scm_assoc_ref));
#line 11
  scm_make_gsubr(s_assq_set_x, 3, 0, 0, (SCM (*)())(& scm_assq_set_x));
#line 12
  scm_make_gsubr(s_assv_set_x, 3, 0, 0, (SCM (*)())(& scm_assv_set_x));
#line 13
  scm_make_gsubr(s_assoc_set_x, 3, 0, 0, (SCM (*)())(& scm_assoc_set_x));
#line 14
  scm_make_gsubr(s_assq_remove_x, 2, 0, 0, (SCM (*)())(& scm_assq_remove_x));
#line 15
  scm_make_gsubr(s_assv_remove_x, 2, 0, 0, (SCM (*)())(& scm_assv_remove_x));
#line 16
  scm_make_gsubr(s_assoc_remove_x, 2, 0, 0, (SCM (*)())(& scm_assoc_remove_x));
  }
#line 379 "/home/wslee/gnu_benchmarks/guile-1.0/libguile/alist.c"
  return;
}
}
#line 113 "./gh.h"
int gh_boolean_p(SCM val ) ;
#line 114
int gh_symbol_p(SCM val ) ;
#line 115
int gh_char_p(SCM val ) ;
#line 116
int gh_vector_p(SCM val ) ;
#line 117
int gh_pair_p(SCM val ) ;
#line 118
int gh_number_p(SCM val ) ;
#line 119
int gh_string_p(SCM val ) ;
#line 120
int gh_procedure_p(SCM val ) ;
#line 121
int gh_list_p(SCM val ) ;
#line 122
int gh_inexact_p(SCM val ) ;
#line 123
int gh_exact_p(SCM val ) ;
#line 126
int gh_eq_p(SCM x , SCM y ) ;
#line 127
int gh_eqv_p(SCM x , SCM y ) ;
#line 128
int gh_equal_p(SCM x , SCM y ) ;
#line 50 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_predicates.c"
int gh_boolean_p(SCM val ) 
{ 
  int tmp___0 ;
  SCM tmp___1 ;

  {
  {
#line 52
  tmp___1 = scm_boolean_p(val);
  }
#line 52
  if (tmp___1 == (long )(17 << 9) + 372L) {
#line 52
    tmp___0 = 1;
  } else {
#line 52
    tmp___0 = 0;
  }
#line 52
  return (tmp___0);
}
}
#line 54 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_predicates.c"
int gh_symbol_p(SCM val ) 
{ 
  int tmp___0 ;
  SCM tmp___1 ;

  {
  {
#line 56
  tmp___1 = scm_symbol_p(val);
  }
#line 56
  if (tmp___1 == (long )(17 << 9) + 372L) {
#line 56
    tmp___0 = 1;
  } else {
#line 56
    tmp___0 = 0;
  }
#line 56
  return (tmp___0);
}
}
#line 58 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_predicates.c"
int gh_char_p(SCM val ) 
{ 
  int tmp___0 ;
  SCM tmp___1 ;

  {
  {
#line 60
  tmp___1 = scm_char_p(val);
  }
#line 60
  if (tmp___1 == (long )(17 << 9) + 372L) {
#line 60
    tmp___0 = 1;
  } else {
#line 60
    tmp___0 = 0;
  }
#line 60
  return (tmp___0);
}
}
#line 62 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_predicates.c"
int gh_vector_p(SCM val ) 
{ 
  int tmp___0 ;
  SCM tmp___1 ;

  {
  {
#line 64
  tmp___1 = scm_vector_p(val);
  }
#line 64
  if (tmp___1 == (long )(17 << 9) + 372L) {
#line 64
    tmp___0 = 1;
  } else {
#line 64
    tmp___0 = 0;
  }
#line 64
  return (tmp___0);
}
}
#line 66 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_predicates.c"
int gh_pair_p(SCM val ) 
{ 
  int tmp___0 ;
  SCM tmp___1 ;

  {
  {
#line 68
  tmp___1 = scm_pair_p(val);
  }
#line 68
  if (tmp___1 == (long )(17 << 9) + 372L) {
#line 68
    tmp___0 = 1;
  } else {
#line 68
    tmp___0 = 0;
  }
#line 68
  return (tmp___0);
}
}
#line 70 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_predicates.c"
int gh_number_p(SCM val ) 
{ 
  int tmp___0 ;
  SCM tmp___1 ;

  {
  {
#line 72
  tmp___1 = scm_number_p(val);
  }
#line 72
  if (tmp___1 == (long )(17 << 9) + 372L) {
#line 72
    tmp___0 = 1;
  } else {
#line 72
    tmp___0 = 0;
  }
#line 72
  return (tmp___0);
}
}
#line 74 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_predicates.c"
int gh_string_p(SCM val ) 
{ 
  int tmp___0 ;
  SCM tmp___1 ;

  {
  {
#line 76
  tmp___1 = scm_pair_p(val);
  }
#line 76
  if (tmp___1 == (long )(17 << 9) + 372L) {
#line 76
    tmp___0 = 1;
  } else {
#line 76
    tmp___0 = 0;
  }
#line 76
  return (tmp___0);
}
}
#line 78 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_predicates.c"
int gh_procedure_p(SCM val ) 
{ 
  int tmp___0 ;
  SCM tmp___1 ;

  {
  {
#line 80
  tmp___1 = scm_procedure_p(val);
  }
#line 80
  if (tmp___1 == (long )(17 << 9) + 372L) {
#line 80
    tmp___0 = 1;
  } else {
#line 80
    tmp___0 = 0;
  }
#line 80
  return (tmp___0);
}
}
#line 82 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_predicates.c"
int gh_list_p(SCM val ) 
{ 
  int tmp___0 ;
  SCM tmp___1 ;

  {
  {
#line 84
  tmp___1 = scm_list_p(val);
  }
#line 84
  if (tmp___1 == (long )(17 << 9) + 372L) {
#line 84
    tmp___0 = 1;
  } else {
#line 84
    tmp___0 = 0;
  }
#line 84
  return (tmp___0);
}
}
#line 86 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_predicates.c"
int gh_inexact_p(SCM val ) 
{ 
  int tmp___0 ;
  SCM tmp___1 ;

  {
  {
#line 88
  tmp___1 = scm_inexact_p(val);
  }
#line 88
  if (tmp___1 == (long )(17 << 9) + 372L) {
#line 88
    tmp___0 = 1;
  } else {
#line 88
    tmp___0 = 0;
  }
#line 88
  return (tmp___0);
}
}
#line 90 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_predicates.c"
int gh_exact_p(SCM val ) 
{ 
  int tmp___0 ;
  SCM tmp___1 ;

  {
  {
#line 92
  tmp___1 = scm_exact_p(val);
  }
#line 92
  if (tmp___1 == (long )(17 << 9) + 372L) {
#line 92
    tmp___0 = 1;
  } else {
#line 92
    tmp___0 = 0;
  }
#line 92
  return (tmp___0);
}
}
#line 96 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_predicates.c"
int gh_eq_p(SCM x , SCM y ) 
{ 
  int tmp___0 ;
  SCM tmp___1 ;

  {
  {
#line 98
  tmp___1 = scm_eq_p(x, y);
  }
#line 98
  if (tmp___1 == (long )(17 << 9) + 372L) {
#line 98
    tmp___0 = 1;
  } else {
#line 98
    tmp___0 = 0;
  }
#line 98
  return (tmp___0);
}
}
#line 100 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_predicates.c"
int gh_eqv_p(SCM x , SCM y ) 
{ 
  int tmp___0 ;
  SCM tmp___1 ;

  {
  {
#line 102
  tmp___1 = scm_eqv_p(x, y);
  }
#line 102
  if (tmp___1 != (long )(17 << 9) + 372L) {
#line 102
    tmp___0 = 1;
  } else {
#line 102
    tmp___0 = 0;
  }
#line 102
  return (tmp___0);
}
}
#line 104 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_predicates.c"
int gh_equal_p(SCM x , SCM y ) 
{ 
  int tmp___0 ;
  SCM tmp___1 ;

  {
  {
#line 106
  tmp___1 = scm_equal_p(x, y);
  }
#line 106
  if (tmp___1 != (long )(17 << 9) + 372L) {
#line 106
    tmp___0 = 1;
  } else {
#line 106
    tmp___0 = 0;
  }
#line 106
  return (tmp___0);
}
}
#line 105 "./gh.h"
unsigned long gh_scm2ulong(SCM obj ) ;
#line 136
SCM gh_cons(SCM x , SCM y ) ;
#line 138
unsigned long gh_list_length(SCM l ) ;
#line 140
SCM gh_car(SCM x ) ;
#line 141
SCM gh_cdr(SCM x ) ;
#line 143
SCM gh_caar(SCM x ) ;
#line 144
SCM gh_cadr(SCM x ) ;
#line 145
SCM gh_cdar(SCM x ) ;
#line 146
SCM gh_cddr(SCM x ) ;
#line 148
SCM gh_caaar(SCM x ) ;
#line 149
SCM gh_caadr(SCM x ) ;
#line 150
SCM gh_cadar(SCM x ) ;
#line 151
SCM gh_caddr(SCM x ) ;
#line 152
SCM gh_cdaar(SCM x ) ;
#line 153
SCM gh_cdadr(SCM x ) ;
#line 154
SCM gh_cddar(SCM x ) ;
#line 155
SCM gh_cdddr(SCM x ) ;
#line 50 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_list.c"
unsigned long gh_list_length(SCM l ) 
{ 
  SCM tmp ;
  unsigned long tmp___0 ;

  {
  {
#line 52
  tmp = scm_list_length(l);
#line 52
  tmp___0 = gh_scm2ulong(tmp);
  }
#line 52
  return (tmp___0);
}
}
#line 58 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_list.c"
SCM gh_cons(SCM x , SCM y ) 
{ 
  SCM tmp ;

  {
  {
#line 60
  tmp = scm_cons(x, y);
  }
#line 60
  return (tmp);
}
}
#line 66 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_list.c"
SCM gh_car(SCM x ) 
{ 


  {
#line 68
  return (((scm_cell *)x)->car);
}
}
#line 72 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_list.c"
SCM gh_cdr(SCM x ) 
{ 


  {
#line 74
  return (((scm_cell *)x)->cdr);
}
}
#line 78 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_list.c"
SCM gh_caar(SCM x ) 
{ 


  {
#line 80
  return (((scm_cell *)((scm_cell *)x)->car)->car);
}
}
#line 82 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_list.c"
SCM gh_cadr(SCM x ) 
{ 


  {
#line 84
  return (((scm_cell *)((scm_cell *)x)->cdr)->car);
}
}
#line 86 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_list.c"
SCM gh_cdar(SCM x ) 
{ 


  {
#line 88
  return (((scm_cell *)((scm_cell *)x)->car)->cdr);
}
}
#line 90 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_list.c"
SCM gh_cddr(SCM x ) 
{ 


  {
#line 92
  return (((scm_cell *)((scm_cell *)x)->cdr)->cdr);
}
}
#line 95 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_list.c"
SCM gh_caaar(SCM x ) 
{ 


  {
#line 97
  return (((scm_cell *)((scm_cell *)((scm_cell *)x)->car)->car)->car);
}
}
#line 99 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_list.c"
SCM gh_caadr(SCM x ) 
{ 


  {
#line 101
  return (((scm_cell *)((scm_cell *)((scm_cell *)x)->cdr)->car)->car);
}
}
#line 103 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_list.c"
SCM gh_cadar(SCM x ) 
{ 


  {
#line 105
  return (((scm_cell *)((scm_cell *)((scm_cell *)x)->car)->cdr)->car);
}
}
#line 107 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_list.c"
SCM gh_caddr(SCM x ) 
{ 


  {
#line 109
  return (((scm_cell *)((scm_cell *)((scm_cell *)x)->cdr)->cdr)->car);
}
}
#line 111 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_list.c"
SCM gh_cdaar(SCM x ) 
{ 


  {
#line 113
  return (((scm_cell *)((scm_cell *)((scm_cell *)x)->car)->car)->cdr);
}
}
#line 115 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_list.c"
SCM gh_cdadr(SCM x ) 
{ 


  {
#line 117
  return (((scm_cell *)((scm_cell *)((scm_cell *)x)->cdr)->car)->cdr);
}
}
#line 119 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_list.c"
SCM gh_cddar(SCM x ) 
{ 


  {
#line 121
  return (((scm_cell *)((scm_cell *)((scm_cell *)x)->car)->cdr)->cdr);
}
}
#line 123 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_list.c"
SCM gh_cdddr(SCM x ) 
{ 


  {
#line 125
  return (((scm_cell *)((scm_cell *)((scm_cell *)x)->cdr)->cdr)->cdr);
}
}
#line 47 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_io.c"
void gh_display(SCM x ) 
{ 
  SCM tmp ;

  {
  {
#line 49
  tmp = scm_current_output_port();
#line 49
  scm_display(x, tmp);
  }
#line 50
  return;
}
}
#line 333 "/usr/include/stdio.h"
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 59 "./gh.h"
void gh_enter(int argc , char **argv , void (*c_main_prog)(int argc , char **argv ) ) ;
#line 60
void gh_repl(void) ;
#line 61
SCM gh_catch(SCM tag , SCM (*body)(void *data , SCM jmpbuf ) , void *body_data , SCM (*handler)(void *data ,
                                                                                                SCM tag ,
                                                                                                SCM throw_args ) ,
             void *handler_data ) ;
#line 63
SCM gh_standard_handler(void *data , SCM tag , SCM throw_args ) ;
#line 69
void gh_eval_str(char *scheme_code ) ;
#line 63 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_init.c"
static void gh_launch_pad(void *closure , int argc , char **argv ) 
{ 
  void (*c_main_prog)(int argc , char **argv ) ;
  char *__cil_tmp5 ;

  {
  {
#line 65
  c_main_prog = (void (*)(int argc , char **argv ))closure;
#line 67
  gh_eval_str((char *)"(primitive-load-path \"ice-9/boot-9.scm\")");
#line 68
  (*c_main_prog)(argc, argv);
#line 71
  exit(0);
  }
}
}
#line 78 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_init.c"
void gh_enter(int argc , char **argv , void (*c_main_prog)(int argc , char **argv ) ) 
{ 


  {
  {
#line 80
  scm_boot_guile(argc, argv, & gh_launch_pad, (void *)c_main_prog);
  }
#line 82
  return;
}
}
#line 86 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_init.c"
void gh_repl(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;

  {
  {
#line 88
  gh_eval_str((char *)"(primitive-load-path \"ice-9/boot-9.scm\")");
#line 89
  gh_eval_str((char *)"(top-repl)");
  }
#line 90
  return;
}
}
#line 98 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_init.c"
SCM gh_catch(SCM tag , SCM (*body)(void *data , SCM jmpbuf ) , void *body_data , SCM (*handler)(void *data ,
                                                                                                SCM tag ,
                                                                                                SCM throw_args ) ,
             void *handler_data ) 
{ 


  {
  {
#line 101
  scm_internal_catch(tag, body, body_data, handler, handler_data);
  }
#line 102
  return (0L);
}
}
#line 104 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_init.c"
SCM gh_standard_handler(void *data , SCM tag , SCM throw_args ) 
{ 
  SCM tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  char *__cil_tmp7 ;

  {
  {
#line 106
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nJust got an error; tag is\n        ");
#line 107
  tmp = scm_current_output_port();
#line 107
  scm_display(tag, tmp);
#line 108
  tmp___0 = scm_current_output_port();
#line 108
  scm_newline(tmp___0);
#line 109
  tmp___1 = scm_current_output_port();
#line 109
  scm_newline(tmp___1);
  }
#line 110
  return (0L);
}
}
#line 79 "./gh.h"
SCM gh_new_procedure(char *proc_name , SCM (*fn)() , int n_required_args , int n_optional_args ,
                     int varp ) ;
#line 81
SCM gh_new_procedure0_0(char *proc_name , SCM (*fn)() ) ;
#line 82
SCM gh_new_procedure0_1(char *proc_name , SCM (*fn)() ) ;
#line 83
SCM gh_new_procedure0_2(char *proc_name , SCM (*fn)() ) ;
#line 84
SCM gh_new_procedure1_0(char *proc_name , SCM (*fn)() ) ;
#line 85
SCM gh_new_procedure1_1(char *proc_name , SCM (*fn)() ) ;
#line 86
SCM gh_new_procedure1_2(char *proc_name , SCM (*fn)() ) ;
#line 87
SCM gh_new_procedure2_0(char *proc_name , SCM (*fn)() ) ;
#line 88
SCM gh_new_procedure2_1(char *proc_name , SCM (*fn)() ) ;
#line 89
SCM gh_new_procedure2_2(char *proc_name , SCM (*fn)() ) ;
#line 90
SCM gh_new_procedure3_0(char *proc_name , SCM (*fn)() ) ;
#line 91
SCM gh_new_procedure4_0(char *proc_name , SCM (*fn)() ) ;
#line 92
SCM gh_new_procedure5_0(char *proc_name , SCM (*fn)() ) ;
#line 50 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_funcs.c"
SCM gh_new_procedure(char *proc_name , SCM (*fn)() , int n_required_args , int n_optional_args ,
                     int varp ) 
{ 
  SCM tmp ;

  {
  {
#line 54
  tmp = scm_make_gsubr(proc_name, n_required_args, n_optional_args, varp, fn);
  }
#line 54
  return (tmp);
}
}
#line 58 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_funcs.c"
SCM gh_new_procedure0_0(char *proc_name , SCM (*fn)() ) 
{ 
  SCM tmp ;

  {
  {
#line 60
  tmp = gh_new_procedure(proc_name, fn, 0, 0, 0);
  }
#line 60
  return (tmp);
}
}
#line 62 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_funcs.c"
SCM gh_new_procedure0_1(char *proc_name , SCM (*fn)() ) 
{ 
  SCM tmp ;

  {
  {
#line 64
  tmp = gh_new_procedure(proc_name, fn, 0, 1, 0);
  }
#line 64
  return (tmp);
}
}
#line 66 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_funcs.c"
SCM gh_new_procedure0_2(char *proc_name , SCM (*fn)() ) 
{ 
  SCM tmp ;

  {
  {
#line 68
  tmp = gh_new_procedure(proc_name, fn, 0, 2, 0);
  }
#line 68
  return (tmp);
}
}
#line 70 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_funcs.c"
SCM gh_new_procedure1_0(char *proc_name , SCM (*fn)() ) 
{ 
  SCM tmp ;

  {
  {
#line 72
  tmp = gh_new_procedure(proc_name, fn, 1, 0, 0);
  }
#line 72
  return (tmp);
}
}
#line 74 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_funcs.c"
SCM gh_new_procedure1_1(char *proc_name , SCM (*fn)() ) 
{ 
  SCM tmp ;

  {
  {
#line 76
  tmp = gh_new_procedure(proc_name, fn, 1, 1, 0);
  }
#line 76
  return (tmp);
}
}
#line 78 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_funcs.c"
SCM gh_new_procedure1_2(char *proc_name , SCM (*fn)() ) 
{ 
  SCM tmp ;

  {
  {
#line 80
  tmp = gh_new_procedure(proc_name, fn, 1, 2, 0);
  }
#line 80
  return (tmp);
}
}
#line 82 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_funcs.c"
SCM gh_new_procedure2_0(char *proc_name , SCM (*fn)() ) 
{ 
  SCM tmp ;

  {
  {
#line 84
  tmp = gh_new_procedure(proc_name, fn, 2, 0, 0);
  }
#line 84
  return (tmp);
}
}
#line 86 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_funcs.c"
SCM gh_new_procedure2_1(char *proc_name , SCM (*fn)() ) 
{ 
  SCM tmp ;

  {
  {
#line 88
  tmp = gh_new_procedure(proc_name, fn, 2, 1, 0);
  }
#line 88
  return (tmp);
}
}
#line 90 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_funcs.c"
SCM gh_new_procedure2_2(char *proc_name , SCM (*fn)() ) 
{ 
  SCM tmp ;

  {
  {
#line 92
  tmp = gh_new_procedure(proc_name, fn, 2, 2, 0);
  }
#line 92
  return (tmp);
}
}
#line 94 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_funcs.c"
SCM gh_new_procedure3_0(char *proc_name , SCM (*fn)() ) 
{ 
  SCM tmp ;

  {
  {
#line 96
  tmp = gh_new_procedure(proc_name, fn, 3, 0, 0);
  }
#line 96
  return (tmp);
}
}
#line 98 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_funcs.c"
SCM gh_new_procedure4_0(char *proc_name , SCM (*fn)() ) 
{ 
  SCM tmp ;

  {
  {
#line 100
  tmp = gh_new_procedure(proc_name, fn, 4, 0, 0);
  }
#line 100
  return (tmp);
}
}
#line 102 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_funcs.c"
SCM gh_new_procedure5_0(char *proc_name , SCM (*fn)() ) 
{ 
  SCM tmp ;

  {
  {
#line 104
  tmp = gh_new_procedure(proc_name, fn, 5, 0, 0);
  }
#line 104
  return (tmp);
}
}
#line 70 "./gh.h"
void gh_eval_str_with_catch(char *scheme_code , SCM (*handler)(void *data , SCM tag ,
                                                               SCM throw_args ) ) ;
#line 71
void gh_eval_str_with_standard_handler(char *scheme_code ) ;
#line 72
void gh_eval_file(char *fname ) ;
#line 73
void gh_eval_file_with_catch(char *scheme_code , SCM (*handler)(void *data , SCM tag ,
                                                                SCM throw_args ) ) ;
#line 74
void gh_eval_file_with_standard_handler(char *scheme_code ) ;
#line 101
SCM gh_str02scm(char *s___0 ) ;
#line 52 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_eval.c"
void gh_eval_str(char *scheme_code ) 
{ 
  SCM port ;
  SCM tmp ;
  SCM tmp___0 ;
  SCM form ;
  char *__cil_tmp6 ;

  {
  {
#line 56
  tmp = scm_makfrom0str((char const   *)scheme_code);
#line 56
  tmp___0 = scm_mkstrport(2L, tmp, (1L << 16) | (2L << 16), (char *)"guile_main");
#line 56
  port = tmp___0;
  }
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 63
    form = scm_read(port, (long )(16 << 9) + 372L, (long )(16 << 9) + 372L);
    }
#line 63
    if (! (form != (long )(19 << 9) + 372L)) {
#line 63
      goto while_break;
    }
    {
#line 64
    scm_eval_x(form);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 67
  scm_close_port(port);
  }
#line 68
  return;
}
}
#line 71 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_eval.c"
void gh_eval_file(char *fname ) 
{ 
  SCM tmp ;

  {
  {
#line 74
  tmp = gh_str02scm(fname);
#line 74
  scm_primitive_load(tmp, (long )(16 << 9) + 372L, (long )(16 << 9) + 372L);
  }
#line 75
  return;
}
}
#line 77 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_eval.c"
static SCM eval_str_wrapper(void *data , SCM jmpbuf ) 
{ 
  char *scheme_code ;

  {
  {
#line 82
  scheme_code = (char *)data;
#line 83
  gh_eval_str(scheme_code);
  }
#line 84
  return (0L);
}
}
#line 86 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_eval.c"
void gh_eval_str_with_catch(char *scheme_code , SCM (*handler)(void *data , SCM tag ,
                                                               SCM throw_args ) ) 
{ 


  {
  {
#line 90
  gh_catch((long )(17 << 9) + 372L, & eval_str_wrapper, (void *)scheme_code, & gh_standard_handler,
           (void *)scheme_code);
  }
#line 92
  return;
}
}
#line 94 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_eval.c"
void gh_eval_str_with_standard_handler(char *scheme_code ) 
{ 


  {
  {
#line 97
  gh_eval_str_with_catch(scheme_code, & gh_standard_handler);
  }
#line 98
  return;
}
}
#line 101 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_eval.c"
static SCM eval_file_wrapper(void *data , SCM jmpbuf ) 
{ 
  char *scheme_code ;

  {
  {
#line 106
  scheme_code = (char *)data;
#line 107
  gh_eval_file(scheme_code);
  }
#line 108
  return (0L);
}
}
#line 110 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_eval.c"
void gh_eval_file_with_catch(char *scheme_code , SCM (*handler)(void *data , SCM tag ,
                                                                SCM throw_args ) ) 
{ 


  {
  {
#line 114
  gh_catch((long )(17 << 9) + 372L, & eval_file_wrapper, (void *)scheme_code, & gh_standard_handler,
           (void *)scheme_code);
  }
#line 116
  return;
}
}
#line 118 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_eval.c"
void gh_eval_file_with_standard_handler(char *scheme_code ) 
{ 


  {
  {
#line 121
  gh_eval_file_with_catch(scheme_code, & gh_standard_handler);
  }
#line 122
  return;
}
}
#line 95 "./gh.h"
SCM gh_int2scm(int x ) ;
#line 96
SCM gh_ulong2scm(unsigned long x ) ;
#line 97
SCM gh_long2scm(long x ) ;
#line 98
SCM gh_double2scm(double x ) ;
#line 99
SCM gh_char2scm(char c ) ;
#line 100
SCM gh_str2scm(char *s___0 , int len ) ;
#line 103
int gh_scm2bool(SCM obj ) ;
#line 104
int gh_scm2int(SCM obj ) ;
#line 106
long gh_scm2long(SCM obj ) ;
#line 107
char gh_scm2char(SCM obj ) ;
#line 108
double gh_scm2double(SCM obj ) ;
#line 109
void gh_scm2str(SCM obj , char **return_str , int *len ) ;
#line 110
void gh_scm2str0(SCM obj , char *return_str0 , int max_len ) ;
#line 131
SCM gh_vector(SCM length , SCM val ) ;
#line 132
SCM gh_vset(SCM vec , SCM pos , SCM val ) ;
#line 133
SCM gh_vref(SCM vec , SCM pos ) ;
#line 134
unsigned long gh_vector_length(SCM v ) ;
#line 50 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_data.c"
SCM gh_int2scmb(int x ) 
{ 
  long tmp ;

  {
#line 52
  if (x) {
#line 52
    tmp = (long )(17 << 9) + 372L;
  } else {
#line 52
    tmp = (long )(16 << 9) + 372L;
  }
#line 52
  return (tmp);
}
}
#line 54 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_data.c"
SCM gh_int2scm(int x ) 
{ 
  SCM tmp ;

  {
  {
#line 56
  tmp = scm_long2num((long )x);
  }
#line 56
  return (tmp);
}
}
#line 58 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_data.c"
SCM gh_ulong2scm(unsigned long x ) 
{ 
  SCM tmp ;

  {
  {
#line 60
  tmp = scm_ulong2num(x);
  }
#line 60
  return (tmp);
}
}
#line 62 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_data.c"
SCM gh_long2scm(long x ) 
{ 
  SCM tmp ;

  {
  {
#line 64
  tmp = scm_long2num(x);
  }
#line 64
  return (tmp);
}
}
#line 66 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_data.c"
SCM gh_double2scm(double x ) 
{ 
  SCM tmp ;

  {
  {
#line 68
  tmp = scm_makdbl(x, 0.0);
  }
#line 68
  return (tmp);
}
}
#line 70 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_data.c"
SCM gh_char2scm(char c ) 
{ 


  {
#line 72
  return ((SCM )(((int )c << 8) + 244));
}
}
#line 74 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_data.c"
SCM gh_str2scm(char *s___0 , int len ) 
{ 
  SCM tmp ;

  {
  {
#line 76
  tmp = scm_makfromstr((char const   *)s___0, (size_t )len, 0);
  }
#line 76
  return (tmp);
}
}
#line 78 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_data.c"
SCM gh_str02scm(char *s___0 ) 
{ 
  SCM tmp ;

  {
  {
#line 80
  tmp = scm_makfrom0str((char const   *)s___0);
  }
#line 80
  return (tmp);
}
}
#line 85 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_data.c"
int gh_scm2bool(SCM obj ) 
{ 
  int tmp ;

  {
#line 87
  if (obj == (long )(16 << 9) + 372L) {
#line 87
    tmp = 0;
  } else {
#line 87
    tmp = 1;
  }
#line 87
  return (tmp);
}
}
#line 89 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_data.c"
unsigned long gh_scm2ulong(SCM obj ) 
{ 
  unsigned long tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 91
  tmp = scm_num2ulong(obj, (char *)1, (char *)"gh_scm2ulong");
  }
#line 91
  return (tmp);
}
}
#line 93 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_data.c"
long gh_scm2long(SCM obj ) 
{ 
  long tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 95
  tmp = scm_num2long(obj, (char *)1, (char *)"gh_scm2long");
  }
#line 95
  return (tmp);
}
}
#line 97 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_data.c"
int gh_scm2int(SCM obj ) 
{ 
  long tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 100
  tmp = scm_num2long(obj, (char *)1, (char *)"gh_scm2int");
  }
#line 100
  return ((int )tmp);
}
}
#line 102 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_data.c"
double gh_scm2double(SCM obj ) 
{ 
  double tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 104
  tmp = scm_num2dbl(obj, (char *)"gh_scm2double");
  }
#line 104
  return (tmp);
}
}
#line 106 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_data.c"
char gh_scm2char(SCM obj ) 
{ 


  {
#line 108
  return ((char )((unsigned int )(obj >> 8)));
}
}
#line 114 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_data.c"
void gh_scm2str(SCM obj , char **return_str , int *len ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 116
  if (! (6 & (int )obj)) {
#line 116
    if (! ((125 & (int )((scm_cell *)obj)->car) == 21)) {
      {
#line 116
      scm_wta(obj, (char *)3, (char *)"gh_scm2str");
      }
    }
  } else {
    {
#line 116
    scm_wta(obj, (char *)3, (char *)"gh_scm2str");
    }
  }
#line 118
  if (return_str) {
#line 119
    *return_str = (char *)((scm_cell *)obj)->cdr;
  }
#line 120
  if (len) {
#line 121
    *len = (int )((unsigned long )((scm_cell *)obj)->car >> 8);
  }
#line 122
  return;
}
}
#line 126 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_data.c"
void gh_scm2str0(SCM obj , char *return_str0 , int max_len ) 
{ 
  char *ret_str ;
  int i ;
  int len ;

  {
  {
#line 130
  scm_protect_object(obj);
#line 131
  gh_scm2str(obj, & ret_str, & len);
#line 132
  i = 0;
  }
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
#line 132
    if (i < len) {
#line 132
      if (! (i < max_len - 1)) {
#line 132
        goto while_break;
      }
    } else {
#line 132
      goto while_break;
    }
#line 133
    *(return_str0 + i) = *(ret_str + i);
#line 132
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 136
  *(return_str0 + i) = (char )'\000';
#line 139
  scm_unprotect_object(obj);
  }
#line 140
  return;
}
}
#line 144 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_data.c"
SCM gh_vector(SCM length , SCM val ) 
{ 
  SCM tmp ;

  {
  {
#line 146
  tmp = scm_make_vector(length, val, (long )(18 << 9) + 372L);
  }
#line 146
  return (tmp);
}
}
#line 150 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_data.c"
SCM gh_vset(SCM vec , SCM pos , SCM val ) 
{ 
  SCM tmp ;

  {
  {
#line 152
  tmp = scm_vector_set_x(vec, pos, val);
  }
#line 152
  return (tmp);
}
}
#line 156 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_data.c"
SCM gh_vref(SCM vec , SCM pos ) 
{ 
  SCM tmp ;

  {
  {
#line 158
  tmp = scm_vector_ref(vec, pos);
  }
#line 158
  return (tmp);
}
}
#line 162 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_data.c"
unsigned long gh_vector_length(SCM v ) 
{ 
  SCM tmp ;
  unsigned long tmp___0 ;

  {
  {
#line 164
  tmp = scm_vector_length(v);
#line 164
  tmp___0 = gh_scm2ulong(tmp);
  }
#line 164
  return (tmp___0);
}
}
#line 169 "/home/wslee/gnu_benchmarks/guile-1.0/gh/gh_data.c"
SCM gh_symbol2scm(char *symbol_str ) 
{ 
  size_t tmp ;
  SCM tmp___0 ;

  {
  {
#line 171
  tmp = strlen((char const   *)symbol_str);
#line 171
  tmp___0 = scm_intern(symbol_str, tmp);
  }
#line 171
  return (((scm_cell *)tmp___0)->car);
}
}
#line 260 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
#line 32 "/home/wslee/gnu_benchmarks/guile-1.0/guile/getopt.h"
extern char *optarg ;
#line 46
extern int optind ;
#line 107
extern int getopt_long(int argc , char * const  *argv , char const   *shortopts ,
                       struct option  const  *longopts , int *longind ) ;
#line 60 "/home/wslee/gnu_benchmarks/guile-1.0/guile/guile.c"
void *gdb_interface[10]  = 
#line 60 "/home/wslee/gnu_benchmarks/guile-1.0/guile/guile.c"
  {      (void *)(& gdb_options),      (void *)(& gdb_language),      (void *)(& gdb_result),      (void *)(& gdb_output), 
        (void *)(& gdb_output_length),      (void *)(& gdb_maybe_valid_type_p),      (void *)(& gdb_read),      (void *)(& gdb_eval), 
        (void *)(& gdb_print),      (void *)(& gdb_binding)};
#line 66 "/home/wslee/gnu_benchmarks/guile-1.0/guile/guile.c"
char *program_name  =    (char *)((void *)0);
#line 68 "/home/wslee/gnu_benchmarks/guile-1.0/guile/guile.c"
char usage[64]  = 
#line 68
  {      (char )'U',      (char )'s',      (char )'a',      (char )'g', 
        (char )'e',      (char )':',      (char )' ',      (char )'%', 
        (char )'s',      (char )' ',      (char )'[',      (char )'-', 
        (char )'h',      (char )'e',      (char )'v',      (char )']', 
        (char )' ',      (char )'[',      (char )'-',      (char )'-', 
        (char )'h',      (char )'e',      (char )'l',      (char )'p', 
        (char )']',      (char )' ',      (char )'[',      (char )'-', 
        (char )'-',      (char )'e',      (char )'m',      (char )'a', 
        (char )'c',      (char )'s',      (char )']',      (char )' ', 
        (char )'[',      (char )'-',      (char )'-',      (char )'v', 
        (char )'e',      (char )'r',      (char )'s',      (char )'i', 
        (char )'o',      (char )'n',      (char )']',      (char )' ', 
        (char )'[',      (char )'-',      (char )'s',      (char )' ', 
        (char )'F',      (char )'I',      (char )'L',      (char )'E', 
        (char )' ',      (char )'A',      (char )'R',      (char )'G', 
        (char )'S',      (char )']',      (char )'\n',      (char )'\000'};
#line 71 "/home/wslee/gnu_benchmarks/guile-1.0/guile/guile.c"
struct option long_opts[4]  = {      {"version", 0, (int *)0, 'v'}, 
        {"emacs", 0, (int *)0, 'e'}, 
        {"help", 0, (int *)0, 'h'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 79 "/home/wslee/gnu_benchmarks/guile-1.0/guile/guile.c"
void initplugs(void) 
{ 


  {
  {
#line 1 "/home/wslee/gnu_benchmarks/guile-1.0/guile/initplugs.c"
  scm_init_rgx();
  }
#line 83 "/home/wslee/gnu_benchmarks/guile-1.0/guile/guile.c"
  return;
}
}
#line 85 "/home/wslee/gnu_benchmarks/guile-1.0/guile/guile.c"
static void guile_main(void *closure , int argc , char **argv ) 
{ 
  char *boot_cmd ;
  char *script ;
  int optchar ;
  int show_version ;
  int show_help ;
  int use_emacs_interface ;
  int opt_error ;
  SCM pathname ;
  SCM tmp ;
  SCM tmp___0 ;
  SCM tmp___1 ;
  char *home ;
  char *tmp___2 ;
  int len ;
  size_t tmp___3 ;
  char *namebuf ;
  char *tmp___4 ;
  struct stat mode ;
  SCM tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;

  {
  {
#line 88
  boot_cmd = (char *)closure;
#line 89
  script = (char *)0;
#line 91
  show_version = 0;
#line 92
  show_help = 0;
#line 93
  use_emacs_interface = 0;
#line 94
  opt_error = 0;
#line 96
  initplugs();
#line 98
  program_name = strrchr((char const   *)*(argv + 0), '/');
  }
#line 99
  if (! program_name) {
#line 100
    program_name = *(argv + 0);
  } else {
#line 102
    program_name ++;
  }
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 106
    optchar = getopt_long(argc, (char * const  *)argv, "+hevs:", (struct option  const  *)(long_opts),
                          (int *)0);
    }
#line 107
    if (optchar == -1) {
#line 108
      goto while_break;
    }
#line 110
    if (optchar == 115) {
#line 112
      script = optarg;
#line 113
      goto while_break;
    }
    {
#line 118
    if (optchar == 104) {
#line 118
      goto case_104;
    }
#line 121
    if (optchar == 101) {
#line 121
      goto case_101;
    }
#line 124
    if (optchar == 118) {
#line 124
      goto case_118;
    }
#line 127
    goto switch_default;
    case_104: /* CIL Label */ 
#line 119
    show_help = 1;
#line 120
    goto switch_break;
    case_101: /* CIL Label */ 
#line 122
    use_emacs_interface = 1;
#line 123
    goto switch_break;
    case_118: /* CIL Label */ 
#line 125
    show_version = 1;
#line 126
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 128
    opt_error = 1;
#line 129
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 133
  if (opt_error) {
    {
#line 136
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)(usage),
            program_name, program_name);
#line 137
    exit(1);
    }
  }
#line 140
  if (show_version) {
    {
#line 143
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Guile %s\n",
            "1.0");
#line 144
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Copyright (c) 1995, 1996 Free Software Foundation\n");
#line 145
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Guile may be distributed under the terms of the GNU General Public Licence;\ncertain other uses are permitted as well.  For details, see the `COPYING\',\nwhich is included in the Guile distribution.\nThere is no warranty, to the extent permitted by law.\n");
    }
  }
#line 152
  if (show_help) {
    {
#line 155
    fputs((char const   */* __restrict  */)"This is Guile, a Scheme interpreter.\n",
          (FILE */* __restrict  */)stdout);
#line 156
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)(usage),
            program_name, program_name);
#line 157
    fputs((char const   */* __restrict  */)"  -h, --help          Print a summary of the options\n",
          (FILE */* __restrict  */)stdout);
#line 158
    fputs((char const   */* __restrict  */)"  -e, --emacs         Running under Emacs\n",
          (FILE */* __restrict  */)stdout);
#line 159
    fputs((char const   */* __restrict  */)"  -v, --version       Print the version number\n",
          (FILE */* __restrict  */)stdout);
#line 160
    fputs((char const   */* __restrict  */)"  -s FILE ARGS        Run scheme code in FILE; remaining ARGS passed to script\n",
          (FILE */* __restrict  */)stdout);
#line 161
    fputs((char const   */* __restrict  */)"                      must be final option\n",
          (FILE */* __restrict  */)stdout);
#line 162
    fputs((char const   */* __restrict  */)"Send bug reports to bug-guile@prep.ai.mit.edu.\n",
          (FILE */* __restrict  */)stdout);
    }
  }
#line 165
  if (show_version) {
    {
#line 166
    exit(0);
    }
  } else
#line 165
  if (show_help) {
    {
#line 166
    exit(0);
    }
  }
  {
#line 173
  tmp = scm_makfrom0str("init.scm");
#line 173
  tmp___0 = scm_sys_search_load_path(tmp);
#line 173
  pathname = tmp___0;
#line 175
  scm_eval_0str(boot_cmd);
  }
#line 177
  if ((long )(16 << 9) + 372L != pathname) {
    {
#line 178
    scm_primitive_load(pathname, (long )(18 << 9) + 372L, (long )(18 << 9) + 372L);
    }
  }
#line 181
  if (script) {
    {
#line 183
    scm_set_program_arguments(argc - optind, argv + optind, script);
#line 184
    tmp___1 = scm_makfrom0str((char const   *)script);
#line 184
    scm_primitive_load(tmp___1, (long )(18 << 9) + 372L, (long )(18 << 9) + 372L);
    }
  } else {
    {
#line 190
    tmp___2 = getenv("HOME");
#line 190
    home = tmp___2;
    }
#line 191
    if (home) {
      {
#line 193
      tmp___3 = strlen((char const   *)home);
#line 193
      len = (int )tmp___3;
#line 194
      tmp___4 = scm_must_malloc((long )(((unsigned long )len + sizeof("/.guile")) + 1UL),
                                (char *)"guile_main");
#line 194
      namebuf = tmp___4;
#line 198
      strcpy((char */* __restrict  */)namebuf, (char const   */* __restrict  */)home);
      }
#line 199
      if (len >= 1) {
#line 199
        if ((int )*(namebuf + (len - 1)) == 47) {
#line 200
          len --;
        }
      }
      {
#line 201
      strcpy((char */* __restrict  */)(namebuf + len), (char const   */* __restrict  */)"/.guile");
#line 203
      tmp___6 = stat((char const   */* __restrict  */)namebuf, (struct stat */* __restrict  */)(& mode));
      }
#line 203
      if (tmp___6 >= 0) {
#line 203
        if (! (mode.st_mode & 16384U)) {
          {
#line 204
          tmp___5 = scm_makfrom0str((char const   *)namebuf);
#line 204
          scm_primitive_load(tmp___5, (long )(18 << 9) + 372L, (long )(18 << 9) + 372L);
          }
        }
      }
      {
#line 206
      scm_must_free(namebuf);
      }
    }
    {
#line 209
    scm_set_program_arguments(argc - optind, argv + optind, *(argv + 0));
#line 210
    scm_eval_0str((char *)"(top-repl)");
    }
  }
#line 212
  return;
}
}
#line 215 "/home/wslee/gnu_benchmarks/guile-1.0/guile/guile.c"
int main(int argc , char **argv ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 220
  scm_boot_guile(argc, argv, & guile_main, (void *)"(primitive-load-path \"ice-9/boot-9.scm\")");
  }
#line 221
  return (0);
}
}
