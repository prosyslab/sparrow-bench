/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 37 "/home/june/repo/benchmarks/collector/temp/csv2latex-0.18/csv2latex.c"
struct __anonstruct_texcape_29 {
   char *tab ;
   int size ;
};
#line 37 "/home/june/repo/benchmarks/collector/temp/csv2latex-0.18/csv2latex.c"
typedef struct __anonstruct_texcape_29 texcape;
#line 42 "/home/june/repo/benchmarks/collector/temp/csv2latex-0.18/csv2latex.c"
struct __anonstruct_config_30 {
   char block ;
   char sep ;
   unsigned int cols ;
   unsigned int chars ;
   unsigned int rows ;
   char pos ;
   unsigned int lines ;
   unsigned int guess ;
   unsigned int header ;
   unsigned int red ;
   unsigned int longtable ;
   unsigned int escape ;
   unsigned int repeat ;
   unsigned int vlines ;
   unsigned int hlines ;
   char *clrrow ;
   texcape *tex ;
};
#line 42 "/home/june/repo/benchmarks/collector/temp/csv2latex-0.18/csv2latex.c"
typedef struct __anonstruct_config_30 config;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 435
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 34 "/usr/include/libgen.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) __xpg_basename)(char *__path ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 173
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 64 "/home/june/repo/benchmarks/collector/temp/csv2latex-0.18/csv2latex.c"
void rtfm(char *prog ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 65
  tmp = __xpg_basename(prog);
#line 65
  printf((char const   */* __restrict  */)"%s translates a csv file to a LaTeX file\n",
         tmp);
#line 66
  tmp___0 = __xpg_basename(prog);
#line 66
  printf((char const   */* __restrict  */)"Example: %s january_stats.csv > january_stats.tex\n",
         tmp___0);
#line 67
  tmp___1 = __xpg_basename(prog);
#line 67
  printf((char const   */* __restrict  */)"Usage: %s [--nohead] (LaTeX) no document header: useful for inclusion\n",
         tmp___1);
#line 68
  printf((char const   */* __restrict  */)"\t[--longtable] (LaTeX) use package longtable: useful for long input\n");
#line 69
  printf((char const   */* __restrict  */)"\t[--noescape] (LaTeX) do not escape text: useful for mixed CSV/TeX input\n");
#line 70
  printf((char const   */* __restrict  */)"\t[--guess] (CSV) guess separator and block |\n\t[--separator <(c)omma|(s)emicolon|(t)ab|s(p)ace|co(l)on>] (CSV\'s comma)\n\t[--block <(q)uote|(d)ouble|(n)one>] (CSV) block delimiter (e.g: none)\n");
#line 73
  printf((char const   */* __restrict  */)"\t[--lines n] (LaTeX) rows per table: useful for long tabulars\n");
#line 74
  printf((char const   */* __restrict  */)"\t[--position <l|c|r>] (LaTeX) text align in cells\n");
#line 75
  printf((char const   */* __restrict  */)"\t[--colorrows graylevel] (LaTeX) alternate gray rows (e.g: 0.75)\n");
#line 76
  printf((char const   */* __restrict  */)"\t[--reduce level] (LaTeX) reduce table size (e.g: 1)\n");
#line 77
  printf((char const   */* __restrict  */)"\t[--repeatheader] (LaTeX) repeat table header (for long tables)\n");
#line 78
  printf((char const   */* __restrict  */)"\t[--nohlines] (LaTeX) don\'t put hline between table rows\n");
#line 79
  printf((char const   */* __restrict  */)"\t[--novlines] (LaTeX) don\'t put vline between columns\n");
#line 80
  printf((char const   */* __restrict  */)"\t\tcsv_file.csv\n");
#line 81
  printf((char const   */* __restrict  */)"The \"longtable\" option needs the {longtable} LaTeX package\n");
#line 82
  printf((char const   */* __restrict  */)"The \"colorrows\" option needs the {colortbl} LaTeX package\n");
#line 83
  printf((char const   */* __restrict  */)"The \"reduce\" option needs the {relsize} LaTeX package\n");
  }
#line 84
  return;
}
}
#line 95
config *parseOptions(config *conf , int argc , char **argv ) ;
#line 95 "/home/june/repo/benchmarks/collector/temp/csv2latex-0.18/csv2latex.c"
static struct option long_options[16]  = 
#line 95
  {      {"help", 0, (int *)((void *)0), 'h'}, 
        {"guess", 0, (int *)((void *)0), 'g'}, 
        {"block", 1, (int *)((void *)0), 'b'}, 
        {"lines", 1, (int *)((void *)0), 'l'}, 
        {"noescape", 0, (int *)((void *)0), 'x'}, 
        {"nohead", 0, (int *)((void *)0), 'n'}, 
        {"version", 0, (int *)((void *)0), 'v'}, 
        {"position", 1, (int *)((void *)0), 'p'}, 
        {"separator", 1, (int *)((void *)0), 's'}, 
        {"colorrows", 1, (int *)((void *)0), 'c'}, 
        {"reduce", 1, (int *)((void *)0), 'r'}, 
        {"longtable", 0, (int *)((void *)0), 't'}, 
        {"repeatheader", 0, (int *)((void *)0), 'e'}, 
        {"novlines", 0, (int *)((void *)0), 'y'}, 
        {"nohlines", 0, (int *)((void *)0), 'z'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 87 "/home/june/repo/benchmarks/collector/temp/csv2latex-0.18/csv2latex.c"
config *parseOptions(config *conf , int argc , char **argv ) 
{ 
  int opt ;
  int tmp ;
  int longopt_index ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  unsigned short const   **tmp___6 ;

  {
#line 94
  longopt_index = 0;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 117
    opt = getopt_long(argc, (char * const  *)argv, "hvgnxteyz?b:l:p:s:c:r:", (struct option  const  *)(long_options),
                      & longopt_index);
    }
#line 117
    if (! (opt > 0)) {
#line 117
      goto while_break;
    }
    {
#line 121
    if (opt == 104) {
#line 121
      goto case_104;
    }
#line 121
    if (opt == 63) {
#line 121
      goto case_104;
    }
#line 125
    if (opt == 103) {
#line 125
      goto case_103;
    }
#line 128
    if (opt == 116) {
#line 128
      goto case_116;
    }
#line 131
    if (opt == 98) {
#line 131
      goto case_98;
    }
#line 139
    if (opt == 108) {
#line 139
      goto case_108;
    }
#line 148
    if (opt == 110) {
#line 148
      goto case_110;
    }
#line 151
    if (opt == 120) {
#line 151
      goto case_120;
    }
#line 154
    if (opt == 118) {
#line 154
      goto case_118;
    }
#line 159
    if (opt == 112) {
#line 159
      goto case_112;
    }
#line 162
    if (opt == 115) {
#line 162
      goto case_115;
    }
#line 174
    if (opt == 99) {
#line 174
      goto case_99;
    }
#line 184
    if (opt == 114) {
#line 184
      goto case_114;
    }
#line 195
    if (opt == 101) {
#line 195
      goto case_101;
    }
#line 198
    if (opt == 121) {
#line 198
      goto case_121;
    }
#line 201
    if (opt == 122) {
#line 201
      goto case_122;
    }
#line 119
    goto switch_break;
    case_104: /* CIL Label */ 
    case_63: /* CIL Label */ 
    {
#line 122
    rtfm(*(argv + 0));
#line 123
    exit(0);
    }
#line 124
    goto switch_break;
    case_103: /* CIL Label */ 
#line 126
    conf->guess = 1U;
#line 127
    goto switch_break;
    case_116: /* CIL Label */ 
#line 129
    conf->longtable = 1U;
#line 130
    goto switch_break;
    case_98: /* CIL Label */ 
#line 132
    if ((int )*(optarg + 0) == 113) {
#line 133
      conf->block = (char )'\'';
    } else
#line 134
    if ((int )*(optarg + 0) == 100) {
#line 135
      conf->block = (char )'\"';
    } else
#line 136
    if ((int )*(optarg + 0) == 110) {
#line 137
      conf->block = (char)0;
    }
#line 138
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 140
    tmp___1 = __ctype_b_loc();
    }
#line 140
    if ((int const   )*(*tmp___1 + (int )*(optarg + 0)) & 2048) {
      {
#line 141
      tmp___0 = atoi((char const   *)optarg);
#line 141
      conf->lines = (unsigned int )tmp___0;
      }
    } else {
      {
#line 143
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"option \"lines\" need a positive integer value\n");
#line 145
      exit(1);
      }
    }
#line 147
    goto switch_break;
    case_110: /* CIL Label */ 
#line 149
    conf->header = 0U;
#line 150
    goto switch_break;
    case_120: /* CIL Label */ 
#line 152
    conf->escape = 0U;
#line 153
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 155
    printf((char const   */* __restrict  */)"%s \302\251 2002- Beno\303\256t Rouits <brouits@free.fr>\n\tVersion %s (%s)\n",
           "csv2latex", "0.18", "2010-04-27");
#line 157
    exit(0);
    }
#line 158
    goto switch_break;
    case_112: /* CIL Label */ 
#line 160
    conf->pos = *(optarg + 0);
#line 161
    goto switch_break;
    case_115: /* CIL Label */ 
#line 163
    if ((int )*(optarg + 0) == 99) {
#line 164
      conf->sep = (char )',';
    } else
#line 165
    if ((int )*(optarg + 0) == 115) {
#line 166
      conf->sep = (char )';';
    } else
#line 167
    if ((int )*(optarg + 0) == 116) {
#line 168
      conf->sep = (char )'\t';
    } else
#line 169
    if ((int )*(optarg + 0) == 112) {
#line 170
      conf->sep = (char )' ';
    } else
#line 171
    if ((int )*(optarg + 0) == 108) {
#line 172
      conf->sep = (char )':';
    }
#line 173
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 175
    tmp___4 = __ctype_b_loc();
    }
#line 175
    if ((int const   )*(*tmp___4 + (int )*(optarg + 0)) & 2048) {
      {
#line 176
      tmp___2 = strlen((char const   *)optarg);
#line 176
      tmp___3 = malloc(tmp___2 + 1UL);
#line 176
      conf->clrrow = (char *)tmp___3;
#line 177
      strcpy((char */* __restrict  */)conf->clrrow, (char const   */* __restrict  */)optarg);
      }
    } else {
      {
#line 179
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"option \"colorrows\" needs a real value between 0 and 1\n");
#line 181
      exit(1);
      }
    }
#line 183
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 186
    tmp___6 = __ctype_b_loc();
    }
#line 186
    if ((int const   )*(*tmp___6 + (int )*(optarg + 0)) & 2048) {
      {
#line 187
      tmp = atoi((char const   *)optarg);
      }
#line 188
      if (tmp > 4) {
#line 188
        conf->red = 4U;
      } else {
#line 188
        if (tmp < 0) {
#line 188
          tmp___5 = 0;
        } else {
#line 188
          tmp___5 = tmp;
        }
#line 188
        conf->red = (unsigned int )tmp___5;
      }
    } else {
      {
#line 190
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"option \"reduce\" needs an integer value between 1 and 4\n");
#line 192
      exit(1);
      }
    }
#line 194
    goto switch_break;
    case_101: /* CIL Label */ 
#line 196
    conf->repeat = 1U;
#line 197
    goto switch_break;
    case_121: /* CIL Label */ 
#line 199
    conf->vlines = 0U;
#line 200
    goto switch_break;
    case_122: /* CIL Label */ 
#line 202
    conf->hlines = 0U;
#line 203
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 206
  return (conf);
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/csv2latex-0.18/csv2latex.c"
int guessCSV(config *conf , FILE *in ) 
{ 
  int token ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
  {
#line 212
  token = _IO_getc(in);
  }
#line 213
  if (token == -1) {
    {
#line 214
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: emtpy file ?\n");
    }
#line 215
    return (-1);
  } else {
    {
#line 216
    tmp___2 = __ctype_b_loc();
    }
#line 216
    if ((int const   )*(*tmp___2 + token) & 4) {
#line 216
      goto _L;
    } else
#line 216
    if (token == 32) {
      _L: /* CIL Label */ 
      {
#line 218
      conf->block = (char )token;
#line 219
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Guessed \'%c\' as Block Delimiter\n",
              (int )conf->block);
      }
      {
#line 222
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 222
        token = _IO_getc(in);
        }
#line 222
        if (token != (int )conf->block) {
#line 222
          if (token != 10) {
#line 222
            if (! (token != -1)) {
#line 222
              goto while_break;
            }
          } else {
#line 222
            goto while_break;
          }
        } else {
#line 222
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 226
      if (token == (int )conf->block) {
        {
#line 228
        tmp = _IO_getc(in);
#line 228
        conf->sep = (char )tmp;
#line 229
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Guessed \'%c\' as Separator\n",
                (int )conf->sep);
        }
#line 231
        return (0);
      } else {
#line 233
        return (-1);
      }
    } else {
      {
#line 236
      conf->block = (char)0;
#line 237
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Guessed No Block Delimiter\n");
      }
      {
#line 239
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 239
        tmp___0 = __ctype_b_loc();
#line 239
        token = _IO_getc(in);
        }
#line 239
        if ((int const   )*(*tmp___0 + token) & 8) {
#line 239
          if (token != 10) {
#line 239
            if (! (token != -1)) {
#line 239
              goto while_break___0;
            }
          } else {
#line 239
            goto while_break___0;
          }
        } else {
#line 239
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 244
      tmp___1 = __ctype_b_loc();
      }
#line 244
      if ((int const   )*(*tmp___1 + token) & 4) {
        {
#line 245
        conf->sep = (char )token;
#line 246
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Guessed %c as Separator\n",
                (int )conf->sep);
        }
#line 247
        return (0);
      } else
#line 244
      if (token == 9) {
        {
#line 245
        conf->sep = (char )token;
#line 246
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Guessed %c as Separator\n",
                (int )conf->sep);
        }
#line 247
        return (0);
      } else
#line 244
      if (token == 32) {
        {
#line 245
        conf->sep = (char )token;
#line 246
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Guessed %c as Separator\n",
                (int )conf->sep);
        }
#line 247
        return (0);
      } else {
        {
#line 249
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: Did not guess any Separator!\n");
        }
#line 250
        return (-1);
      }
    }
  }
#line 253
  return (0);
}
}
#line 256 "/home/june/repo/benchmarks/collector/temp/csv2latex-0.18/csv2latex.c"
void getMaximums(config *conf , FILE *in ) 
{ 
  int token ;
  unsigned int curcol ;
  unsigned int curchar ;
  unsigned int inblock ;

  {
#line 258
  token = 0;
#line 259
  curcol = 0U;
#line 260
  curchar = 0U;
#line 261
  inblock = 0U;
#line 263
  conf->chars = 0U;
#line 264
  conf->cols = 0U;
#line 265
  conf->rows = 0U;
  {
#line 267
  while (1) {
    while_continue: /* CIL Label */ ;
#line 267
    if (! (token != -1)) {
#line 267
      goto while_break;
    }
    {
#line 268
    token = _IO_getc(in);
    }
#line 271
    if (token == -1) {
#line 272
      goto while_continue;
    }
#line 276
    if (token == 10) {
#line 277
      curcol ++;
#line 278
      if (conf->cols < curcol) {
#line 278
        conf->cols = curcol;
      } else {
#line 278
        conf->cols = conf->cols;
      }
#line 279
      if (conf->chars < curchar) {
#line 279
        conf->chars = curchar;
      } else {
#line 279
        conf->chars = conf->chars;
      }
#line 280
      (conf->rows) ++;
#line 281
      curcol = 0U;
#line 282
      curchar = 0U;
#line 283
      inblock = 0U;
#line 284
      goto while_continue;
    }
#line 288
    if (conf->block) {
#line 288
      if (token == (int )conf->block) {
#line 289
        inblock = (unsigned int )(! inblock);
#line 290
        goto while_continue;
      }
    }
#line 294
    if (token == (int )conf->sep) {
#line 294
      if (conf->block) {
#line 294
        if (! inblock) {
#line 295
          curcol ++;
#line 296
          goto while_continue;
        } else {
#line 294
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 294
      if (! conf->block) {
#line 295
        curcol ++;
#line 296
        goto while_continue;
      }
    }
#line 300
    if (token != (int )conf->block) {
#line 300
      if (conf->block) {
#line 300
        if (inblock) {
#line 301
          curchar ++;
#line 302
          goto while_continue;
        } else {
#line 300
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 300
      if (! conf->block) {
#line 301
        curchar ++;
#line 302
        goto while_continue;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 305
  return;
}
}
#line 308 "/home/june/repo/benchmarks/collector/temp/csv2latex-0.18/csv2latex.c"
void doTeXsub(config *conf , char newsep , FILE *in , FILE *out ) 
{ 
  int token ;
  int max ;
  int numcols ;
  unsigned int lines ;
  int inblock ;
  int csvrows ;
  int firstrow ;
  int nosep ;
  int token1 ;
  int token2 ;
  char headerrow[1000] ;
  char tmp[12] ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char tmp___2[2] ;
  int i ;
  char tmp___3[17] ;
  char tmp___4[3] ;
  char tmp___5[2] ;

  {
#line 310
  token = 0;
#line 314
  inblock = 0;
#line 316
  firstrow = 1;
#line 317
  nosep = 0;
#line 318
  token1 = 0;
#line 319
  token2 = 0;
#line 321
  headerrow[0] = (char )'\000';
#line 323
  numcols = (int )conf->cols;
#line 323
  max = numcols;
#line 324
  csvrows = (int )conf->rows;
#line 326
  if (conf->lines) {
#line 326
    lines = conf->lines;
  } else {
#line 326
    lines = 4294967295U;
  }
  {
#line 328
  while (1) {
    while_continue: /* CIL Label */ ;
#line 328
    if (! (token != -1)) {
#line 328
      goto while_break;
    }
    {
#line 329
    token2 = token1;
#line 330
    token1 = token;
#line 331
    token = _IO_getc(in);
    }
#line 334
    if (token == -1) {
#line 335
      goto while_continue;
    }
#line 339
    if (token == 10) {
#line 340
      inblock = 0;
      {
#line 342
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 342
        if (! (numcols > 1)) {
#line 342
          goto while_break___0;
        }
        {
#line 343
        _IO_putc((int )newsep, out);
#line 344
        numcols --;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 346
      if (firstrow) {
#line 346
        if (conf->longtable) {
#line 346
          if (conf->repeat) {
            {
#line 349
            fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s\\\\\n",
                    headerrow);
            }
          } else {
            {
#line 347
            fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\\\\\n");
            }
          }
        } else {
          {
#line 347
          fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\\\\\n");
          }
        }
      } else {
        {
#line 347
        fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\\\\\n");
        }
      }
#line 351
      if (conf->hlines) {
        {
#line 352
        fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\\hline\n");
        }
      }
#line 354
      if (firstrow) {
#line 354
        if (conf->longtable) {
#line 354
          if (conf->repeat) {
            {
#line 355
            fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s",
                    "\\endhead\n");
            }
          }
        }
      }
#line 357
      if (firstrow) {
#line 357
        if (conf->repeat) {
#line 359
          if (conf->hlines) {
#line 359
            tmp___0 = "\\\\\n\\hline";
          } else {
#line 359
            tmp___0 = "\\\\\n";
          }
          {
#line 359
          sprintf((char */* __restrict  */)(tmp), (char const   */* __restrict  */)tmp___0);
#line 360
          strcat((char */* __restrict  */)(headerrow), (char const   */* __restrict  */)(tmp));
          }
        }
      }
#line 362
      firstrow = 0;
#line 363
      numcols = max;
#line 364
      lines --;
#line 365
      csvrows --;
#line 367
      if (conf->clrrow) {
#line 367
        if (lines % 2U) {
          {
#line 368
          fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\\colorrow ");
          }
        }
      }
#line 371
      if (! lines) {
#line 371
        if (csvrows) {
#line 371
          if (! conf->longtable) {
            {
#line 372
            fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\\end{tabular}\n");
#line 373
            fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\\newline\n");
#line 374
            fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\\begin{tabular}{");
            }
#line 375
            if (conf->vlines) {
              {
#line 376
              _IO_putc('|', out);
              }
            }
            {
#line 378
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 378
              tmp___1 = numcols;
#line 378
              numcols --;
#line 378
              if (! tmp___1) {
#line 378
                goto while_break___1;
              }
              {
#line 379
              _IO_putc((int )conf->pos, out);
              }
#line 380
              if (conf->vlines) {
                {
#line 381
                _IO_putc('|', out);
                }
              }
            }
            while_break___1: /* CIL Label */ ;
            }
            {
#line 384
            fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"}\n");
            }
#line 385
            if (conf->hlines) {
              {
#line 386
              fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\\hline\n");
              }
            }
#line 388
            if (conf->repeat) {
#line 388
              if (! conf->longtable) {
                {
#line 389
                fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s",
                        headerrow);
#line 390
                _IO_putc('\n', out);
                }
              }
            }
#line 392
            numcols = max;
#line 393
            if (conf->lines) {
#line 393
              lines = conf->lines;
            } else {
#line 393
              lines = 4294967295U;
            }
          }
        }
      }
#line 396
      goto while_continue;
    }
#line 401
    if (token == 34) {
#line 402
      if (nosep == 0) {
#line 403
        nosep = 1;
      } else {
#line 405
        nosep = 0;
      }
    }
#line 409
    if (token == (int )conf->sep) {
#line 409
      if (conf->block) {
#line 409
        if (! inblock) {
#line 409
          goto _L;
        } else {
#line 409
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 409
      if (! conf->block) {
        _L: /* CIL Label */ 
#line 409
        if (nosep == 0) {
#line 410
          if (firstrow) {
#line 410
            if (conf->longtable) {
#line 410
              if (! conf->repeat) {
                {
#line 411
                _IO_putc((int )newsep, out);
                }
              }
            } else {
              {
#line 411
              _IO_putc((int )newsep, out);
              }
            }
          } else {
            {
#line 411
            _IO_putc((int )newsep, out);
            }
          }
#line 412
          numcols --;
#line 413
          if (firstrow) {
#line 413
            if (conf->repeat) {
              {
#line 416
              tmp___2[0] = newsep;
#line 417
              tmp___2[1] = (char )'\000';
#line 418
              strcat((char */* __restrict  */)(headerrow), (char const   */* __restrict  */)(tmp___2));
              }
            }
          }
#line 420
          goto while_continue;
        }
      }
    }
#line 424
    if (conf->block) {
#line 424
      if (token == (int )conf->block) {
#line 425
        inblock = ! inblock;
#line 426
        goto while_continue;
      }
    }
#line 430
    if (token != (int )conf->block) {
#line 430
      if (conf->block) {
#line 430
        if (inblock) {
#line 430
          goto _L___5;
        } else {
#line 430
          goto _L___6;
        }
      } else
      _L___6: /* CIL Label */ 
#line 430
      if (! conf->block) {
        _L___5: /* CIL Label */ 
#line 430
        if (token == 34) {
#line 430
          if (token1 == 34) {
#line 430
            if (token2 == 34) {
#line 430
              goto _L___2;
            } else {
#line 430
              goto _L___4;
            }
          } else {
#line 430
            goto _L___4;
          }
        } else
        _L___4: /* CIL Label */ 
#line 430
        if (token != 34) {
          _L___2: /* CIL Label */ 
#line 433
          i = 0;
#line 434
          if (conf->escape) {
#line 435
            i = 0;
            {
#line 435
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 435
              if (! (i < (conf->tex)->size)) {
#line 435
                goto while_break___2;
              }
#line 436
              if (token == (int )*((conf->tex)->tab + i)) {
                {
#line 438
                if (token == 92) {
#line 438
                  goto case_92;
                }
#line 447
                goto switch_default;
                case_92: /* CIL Label */ 
                {
#line 439
                fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\\textbackslash{}");
                }
#line 440
                if (firstrow) {
#line 440
                  if (conf->repeat) {
                    {
#line 443
                    sprintf((char */* __restrict  */)(tmp___3), (char const   */* __restrict  */)"\\textbackslash{}");
#line 444
                    strcat((char */* __restrict  */)(headerrow), (char const   */* __restrict  */)(tmp___3));
                    }
                  }
                }
#line 446
                goto switch_break;
                switch_default: /* CIL Label */ 
                {
#line 448
                fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\\%c",
                        token);
                }
#line 449
                if (firstrow) {
#line 449
                  if (conf->repeat) {
                    {
#line 452
                    tmp___4[0] = (char )'\\';
#line 453
                    tmp___4[1] = (char )token;
#line 454
                    tmp___4[2] = (char )'\000';
#line 455
                    strcat((char */* __restrict  */)(headerrow), (char const   */* __restrict  */)(tmp___4));
                    }
                  }
                }
#line 457
                goto switch_break;
                switch_break: /* CIL Label */ ;
                }
#line 459
                goto while_break___2;
              }
#line 435
              i ++;
            }
            while_break___2: /* CIL Label */ ;
            }
          }
#line 463
          if (i >= (conf->tex)->size) {
#line 463
            goto _L___1;
          } else
#line 463
          if (! conf->escape) {
            _L___1: /* CIL Label */ 
#line 464
            if (firstrow) {
#line 464
              if (conf->longtable) {
#line 464
                if (! conf->repeat) {
                  {
#line 465
                  _IO_putc(token, out);
                  }
                }
              } else {
                {
#line 465
                _IO_putc(token, out);
                }
              }
            } else {
              {
#line 465
              _IO_putc(token, out);
              }
            }
#line 466
            if (firstrow) {
#line 466
              if (conf->repeat) {
                {
#line 469
                tmp___5[0] = (char )token;
#line 470
                tmp___5[1] = (char )'\000';
#line 471
                strcat((char */* __restrict  */)(headerrow), (char const   */* __restrict  */)(tmp___5));
                }
              }
            }
          }
#line 474
          goto while_continue;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 478
  return;
}
}
#line 481 "/home/june/repo/benchmarks/collector/temp/csv2latex-0.18/csv2latex.c"
void doTeXdoc(config *conf , FILE *in , FILE *out ) 
{ 
  int maxcols ;
  int numcols ;
  char *relsize[5] ;
  char *tabcolsep[5] ;
  int tmp ;

  {
#line 485
  relsize[0] = (char *)"0";
#line 485
  relsize[1] = (char *)"0.5";
#line 485
  relsize[2] = (char *)"1";
#line 485
  relsize[3] = (char *)"2";
#line 485
  relsize[4] = (char *)"4";
#line 486
  tabcolsep[0] = (char *)"0";
#line 486
  tabcolsep[1] = (char *)"0.05";
#line 486
  tabcolsep[2] = (char *)"0.1";
#line 486
  tabcolsep[3] = (char *)"0.2";
#line 486
  tabcolsep[4] = (char *)"0.4";
#line 488
  maxcols = (int )conf->cols;
#line 488
  numcols = maxcols;
#line 489
  if (conf->header) {
    {
#line 490
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\\documentclass[a4paper]{article}\n");
#line 491
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\\usepackage[T1]{fontenc}\n");
#line 492
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\\usepackage[latin1]{inputenc}\n");
    }
#line 493
    if (conf->red) {
      {
#line 494
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\\usepackage{relsize}\n");
      }
    }
#line 496
    if (conf->clrrow) {
      {
#line 497
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\\usepackage{colortbl}\n");
      }
    }
#line 499
    if (conf->longtable) {
      {
#line 500
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\\usepackage{longtable}\n");
      }
    }
    {
#line 502
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\\begin{document}\n");
    }
  }
#line 504
  if (conf->clrrow) {
    {
#line 505
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\\def\\colorrow{\\rowcolor[gray]{%s}}\n",
            conf->clrrow);
    }
  }
#line 508
  if (conf->red) {
    {
#line 509
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\\relsize{-%s}\n",
            relsize[conf->red]);
#line 510
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\\addtolength\\tabcolsep{-%sem}\n",
            tabcolsep[conf->red]);
    }
  }
#line 512
  if (conf->longtable) {
    {
#line 514
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\\begin{longtable}{");
    }
#line 515
    if (conf->vlines) {
      {
#line 516
      _IO_putc('|', out);
      }
    }
  } else {
    {
#line 520
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\\begin{tabular}{");
    }
#line 521
    if (conf->vlines) {
      {
#line 522
      _IO_putc('|', out);
      }
    }
  }
  {
#line 524
  while (1) {
    while_continue: /* CIL Label */ ;
#line 524
    tmp = numcols;
#line 524
    numcols --;
#line 524
    if (! tmp) {
#line 524
      goto while_break;
    }
    {
#line 526
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%c", (int )conf->pos);
    }
#line 527
    if (conf->vlines) {
      {
#line 528
      _IO_putc('|', out);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 530
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"}\n");
  }
#line 531
  if (conf->hlines) {
    {
#line 532
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\\hline\n");
    }
  }
  {
#line 533
  doTeXsub(conf, (char )'&', in, out);
  }
#line 534
  if (conf->longtable) {
    {
#line 535
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\\end{longtable}\n");
    }
  } else {
    {
#line 537
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\\end{tabular}\n");
    }
  }
#line 539
  if (conf->red) {
    {
#line 540
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\\addtolength\\tabcolsep{+%sem}\n",
            tabcolsep[conf->red]);
#line 541
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\\relsize{+%s}\n",
            relsize[conf->red]);
    }
  }
#line 543
  if (conf->header) {
    {
#line 544
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\\end{document}\n");
    }
  }
#line 546
  return;
}
}
#line 549 "/home/june/repo/benchmarks/collector/temp/csv2latex-0.18/csv2latex.c"
int main(int argc , char **argv ) 
{ 
  FILE *fp ;
  config *conf ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 555
  if (argc == 1) {
    {
#line 556
    rtfm(*(argv + 0));
#line 557
    exit(0);
    }
  }
  {
#line 559
  tmp = malloc(sizeof(config ));
#line 559
  conf = (config *)tmp;
#line 561
  conf->cols = 1U;
#line 562
  conf->rows = 0U;
#line 563
  conf->chars = 0U;
#line 564
  conf->pos = (char )'l';
#line 565
  conf->lines = 40U;
#line 566
  conf->guess = 0U;
#line 567
  conf->sep = (char )',';
#line 568
  conf->block = (char)0;
#line 569
  conf->header = 1U;
#line 570
  conf->escape = 1U;
#line 571
  conf->clrrow = (char *)((void *)0);
#line 572
  conf->red = 0U;
#line 573
  conf->longtable = 0U;
#line 574
  conf->repeat = 0U;
#line 575
  conf->vlines = 1U;
#line 576
  conf->hlines = 1U;
#line 579
  tmp___0 = malloc(sizeof(texcape ));
#line 579
  conf->tex = (texcape *)tmp___0;
#line 580
  (conf->tex)->tab = (char *)"\\_#$%^&{}~";
#line 581
  (conf->tex)->size = 10;
#line 583
  conf = parseOptions(conf, argc, argv);
#line 584
  fp = fopen((char const   */* __restrict  */)*(argv + optind), (char const   */* __restrict  */)"r");
  }
#line 585
  if (! fp) {
    {
#line 586
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t open file %s\n",
            *(argv + optind));
#line 587
    exit(1);
    }
  }
#line 589
  if (conf->guess) {
    {
#line 590
    tmp___1 = guessCSV(conf, fp);
    }
#line 590
    if (tmp___1) {
      {
#line 591
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Please run again by using -- delimiter (if any) and --separator\n");
#line 592
      exit(1);
      }
    }
    {
#line 594
    rewind(fp);
    }
  }
  {
#line 596
  getMaximums(conf, fp);
#line 597
  rewind(fp);
#line 598
  doTeXdoc(conf, fp, stdout);
#line 599
  free((void *)conf->tex);
  }
#line 600
  if (conf->clrrow) {
    {
#line 600
    free((void *)conf->clrrow);
    }
  }
  {
#line 600
  conf->clrrow = (char *)((void *)0);
#line 601
  free((void *)conf);
#line 602
  fclose(fp);
  }
#line 603
  return (0);
}
}
