/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 150 "/usr/include/curses.h"
typedef unsigned long chtype;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 358 "/usr/include/curses.h"
struct _win_st;
#line 358 "/usr/include/curses.h"
typedef struct _win_st WINDOW;
#line 360 "/usr/include/curses.h"
typedef chtype attr_t;
#line 405
struct ldat;
#line 407 "/usr/include/curses.h"
struct pdat {
   short _pad_y ;
   short _pad_x ;
   short _pad_top ;
   short _pad_left ;
   short _pad_bottom ;
   short _pad_right ;
};
#line 407 "/usr/include/curses.h"
struct _win_st {
   short _cury ;
   short _curx ;
   short _maxy ;
   short _maxx ;
   short _begy ;
   short _begx ;
   short _flags ;
   attr_t _attrs ;
   chtype _bkgd ;
   _Bool _notimeout ;
   _Bool _clear ;
   _Bool _leaveok ;
   _Bool _scroll ;
   _Bool _idlok ;
   _Bool _idcok ;
   _Bool _immed ;
   _Bool _sync ;
   _Bool _use_keypad ;
   int _delay ;
   struct ldat *_line ;
   short _regtop ;
   short _regbottom ;
   int _parx ;
   int _pary ;
   WINDOW *_parent ;
   struct pdat _pad ;
   short _yoffset ;
};
#line 18 "/home/june/repo/benchmarks/collector/temp/empire-1.11/empire.h"
typedef unsigned char uchar;
#line 20 "/home/june/repo/benchmarks/collector/temp/empire-1.11/empire.h"
typedef long loc_t;
#line 62 "/home/june/repo/benchmarks/collector/temp/empire-1.11/empire.h"
struct city_info {
   loc_t loc ;
   uchar owner ;
   long func[9] ;
   long work ;
   char prod ;
};
#line 62 "/home/june/repo/benchmarks/collector/temp/empire-1.11/empire.h"
typedef struct city_info city_info_t;
#line 108
struct piece_info;
#line 108 "/home/june/repo/benchmarks/collector/temp/empire-1.11/empire.h"
struct __anonstruct_link_t_7 {
   struct piece_info *next ;
   struct piece_info *prev ;
};
#line 108 "/home/june/repo/benchmarks/collector/temp/empire-1.11/empire.h"
typedef struct __anonstruct_link_t_7 link_t;
#line 113 "/home/june/repo/benchmarks/collector/temp/empire-1.11/empire.h"
struct piece_info {
   link_t piece_link ;
   link_t loc_link ;
   link_t cargo_link ;
   int owner ;
   int type ;
   loc_t loc ;
   long func ;
   short hits ;
   int moved ;
   struct piece_info *ship ;
   struct piece_info *cargo ;
   short count ;
   short range ;
};
#line 113 "/home/june/repo/benchmarks/collector/temp/empire-1.11/empire.h"
typedef struct piece_info piece_info_t;
#line 201 "/home/june/repo/benchmarks/collector/temp/empire-1.11/empire.h"
struct real_map {
   char contents ;
   _Bool on_board ;
   city_info_t *cityp ;
   piece_info_t *objp ;
};
#line 201 "/home/june/repo/benchmarks/collector/temp/empire-1.11/empire.h"
typedef struct real_map real_map_t;
#line 208 "/home/june/repo/benchmarks/collector/temp/empire-1.11/empire.h"
struct view_map {
   char contents ;
   long seen ;
};
#line 208 "/home/june/repo/benchmarks/collector/temp/empire-1.11/empire.h"
typedef struct view_map view_map_t;
#line 215 "/home/june/repo/benchmarks/collector/temp/empire-1.11/empire.h"
struct __anonstruct_path_map_t_8 {
   int cost ;
   int inc_cost ;
   char terrain ;
};
#line 215 "/home/june/repo/benchmarks/collector/temp/empire-1.11/empire.h"
typedef struct __anonstruct_path_map_t_8 path_map_t;
#line 166 "/home/june/repo/benchmarks/collector/temp/empire-1.11/empire.h"
struct piece_attr {
   char sname ;
   char name[20] ;
   char nickname[20] ;
   char article[20] ;
   char plural[20] ;
   char terrain[4] ;
   uchar build_time ;
   uchar strength ;
   uchar max_hits ;
   uchar speed ;
   uchar capacity ;
   long range ;
};
#line 166 "/home/june/repo/benchmarks/collector/temp/empire-1.11/empire.h"
typedef struct piece_attr piece_attr_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 22 "/home/june/repo/benchmarks/collector/temp/empire-1.11/empire.h"
typedef long count_t;
#line 283 "/home/june/repo/benchmarks/collector/temp/empire-1.11/game.c"
struct cont {
   long value ;
   int ncity ;
   city_info_t *cityp[70] ;
};
#line 283 "/home/june/repo/benchmarks/collector/temp/empire-1.11/game.c"
typedef struct cont cont_t;
#line 289 "/home/june/repo/benchmarks/collector/temp/empire-1.11/game.c"
struct pair {
   long value ;
   int user_cont ;
   int comp_cont ;
};
#line 289 "/home/june/repo/benchmarks/collector/temp/empire-1.11/game.c"
typedef struct pair pair_t;
#line 229 "/home/june/repo/benchmarks/collector/temp/empire-1.11/empire.h"
struct __anonstruct_scan_counts_t_3 {
   int user_cities ;
   int user_objects[9] ;
   int comp_cities ;
   int comp_objects[9] ;
   int size ;
   int unowned_cities ;
   int unexplored ;
};
#line 229 "/home/june/repo/benchmarks/collector/temp/empire-1.11/empire.h"
typedef struct __anonstruct_scan_counts_t_3 scan_counts_t;
#line 249 "/home/june/repo/benchmarks/collector/temp/empire-1.11/empire.h"
struct __anonstruct_move_info_t_4 {
   char city_owner ;
   char *objectives ;
   int weights[11] ;
};
#line 249 "/home/june/repo/benchmarks/collector/temp/empire-1.11/empire.h"
typedef struct __anonstruct_move_info_t_4 move_info_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 260 "/home/june/repo/benchmarks/collector/temp/empire-1.11/empire.h"
struct __anonstruct_perimeter_t_5 {
   long len ;
   long list[6000] ;
};
#line 260 "/home/june/repo/benchmarks/collector/temp/empire-1.11/empire.h"
typedef struct __anonstruct_perimeter_t_5 perimeter_t;
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 379
extern  __attribute__((__nothrow__)) int vsprintf(char * __restrict  __s , char const   * __restrict  __format ,
                                                  __gnuc_va_list __arg ) ;
#line 581 "/usr/include/curses.h"
extern int beep(void) ;
#line 587
extern int cbreak(void) ;
#line 590
extern int clearok(WINDOW * , _Bool  ) ;
#line 611
extern int endwin(void) ;
#line 632
extern WINDOW *initscr(void) ;
#line 634
extern int init_pair(short  , short  , short  ) ;
#line 647
extern int keypad(WINDOW * , _Bool  ) ;
#line 704
extern int napms(int  ) ;
#line 711
extern int noecho(void) ;
#line 764
extern int start_color(void) ;
#line 785
extern int waddch(WINDOW * , chtype const    ) ;
#line 788
extern int waddnstr(WINDOW * , char const   * , int  ) ;
#line 794
extern int wattr_on(WINDOW * , attr_t  , void * ) ;
#line 795
extern int wattr_off(WINDOW * , attr_t  , void * ) ;
#line 801
extern int wclear(WINDOW * ) ;
#line 803
extern int wclrtoeol(WINDOW * ) ;
#line 824
extern int wmove(WINDOW * , int  , int  ) ;
#line 829
extern int wrefresh(WINDOW * ) ;
#line 1384
extern WINDOW *curscr ;
#line 1386
extern WINDOW *stdscr ;
#line 1390
extern int COLS ;
#line 1392
extern int LINES ;
#line 13 "/home/june/repo/benchmarks/collector/temp/empire-1.11/extern.h"
int SMOOTH  ;
#line 14 "/home/june/repo/benchmarks/collector/temp/empire-1.11/extern.h"
int WATER_RATIO  ;
#line 15 "/home/june/repo/benchmarks/collector/temp/empire-1.11/extern.h"
int MIN_CITY_DIST  ;
#line 16 "/home/june/repo/benchmarks/collector/temp/empire-1.11/extern.h"
int delay_time  ;
#line 17 "/home/june/repo/benchmarks/collector/temp/empire-1.11/extern.h"
int save_interval  ;
#line 19 "/home/june/repo/benchmarks/collector/temp/empire-1.11/extern.h"
real_map_t map[6000]  ;
#line 20 "/home/june/repo/benchmarks/collector/temp/empire-1.11/extern.h"
view_map_t comp_map[6000]  ;
#line 21 "/home/june/repo/benchmarks/collector/temp/empire-1.11/extern.h"
view_map_t user_map[6000]  ;
#line 23 "/home/june/repo/benchmarks/collector/temp/empire-1.11/extern.h"
city_info_t city[70]  ;
#line 31 "/home/june/repo/benchmarks/collector/temp/empire-1.11/extern.h"
piece_info_t *free_list  ;
#line 32 "/home/june/repo/benchmarks/collector/temp/empire-1.11/extern.h"
piece_info_t *user_obj[9]  ;
#line 33 "/home/june/repo/benchmarks/collector/temp/empire-1.11/extern.h"
piece_info_t *comp_obj[9]  ;
#line 34 "/home/june/repo/benchmarks/collector/temp/empire-1.11/extern.h"
piece_info_t object[5000]  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/empire-1.11/extern.h"
int lines  ;
#line 38 "/home/june/repo/benchmarks/collector/temp/empire-1.11/extern.h"
int cols  ;
#line 73 "/home/june/repo/benchmarks/collector/temp/empire-1.11/extern.h"
long date  ;
#line 74 "/home/june/repo/benchmarks/collector/temp/empire-1.11/extern.h"
_Bool automove  ;
#line 75 "/home/june/repo/benchmarks/collector/temp/empire-1.11/extern.h"
_Bool resigned  ;
#line 76 "/home/june/repo/benchmarks/collector/temp/empire-1.11/extern.h"
_Bool debug  ;
#line 77 "/home/june/repo/benchmarks/collector/temp/empire-1.11/extern.h"
_Bool print_debug  ;
#line 78 "/home/june/repo/benchmarks/collector/temp/empire-1.11/extern.h"
_Bool print_vmap  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/empire-1.11/extern.h"
_Bool trace_pmap  ;
#line 80 "/home/june/repo/benchmarks/collector/temp/empire-1.11/extern.h"
int win  ;
#line 81 "/home/june/repo/benchmarks/collector/temp/empire-1.11/extern.h"
char jnkbuf[80]  ;
#line 82 "/home/june/repo/benchmarks/collector/temp/empire-1.11/extern.h"
_Bool save_movie  ;
#line 83 "/home/june/repo/benchmarks/collector/temp/empire-1.11/extern.h"
int user_score  ;
#line 84 "/home/june/repo/benchmarks/collector/temp/empire-1.11/extern.h"
int comp_score  ;
#line 85 "/home/june/repo/benchmarks/collector/temp/empire-1.11/extern.h"
char *savefile  ;
#line 141
void announce(char *msg ) ;
#line 142
void redisplay(void) ;
#line 143
void kill_display(void) ;
#line 144
void sector_change(void) ;
#line 145
int cur_sector(void) ;
#line 146
long cur_cursor(void) ;
#line 147
void display_loc(int whose , view_map_t *vmap , long loc ) ;
#line 148
void display_locx(int whose , view_map_t *vmap , long loc ) ;
#line 149
void print_sector(int whose , view_map_t *vmap , int sector ) ;
#line 150
_Bool move_cursor(long *cursor , int offset ) ;
#line 151
void print_zoom(view_map_t *vmap ) ;
#line 152
void print_pzoom(char *s , path_map_t *pmap , view_map_t *vmap ) ;
#line 153
void print_xzoom(view_map_t *vmap ) ;
#line 154
void display_score(void) ;
#line 156
void init_colors(void) ;
#line 158
void redraw(void) ;
#line 159
void clear_screen(void) ;
#line 160
void complain(void) ;
#line 161
void delay(void) ;
#line 162
void close_disp(void) ;
#line 163
void pos_str(int row , int col , char *str  , ...) ;
#line 164
int direction(chtype c ) ;
#line 174
char get_chx(void) ;
#line 210
void clreol(int linep , int colp ) ;
#line 212
void prompt(char *fmt  , ...) ;
#line 223
void ttinit(void) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/empire-1.11/display.c"
static int whose_map  =    0;
#line 26 "/home/june/repo/benchmarks/collector/temp/empire-1.11/display.c"
static int ref_row  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/empire-1.11/display.c"
static int ref_col  ;
#line 28 "/home/june/repo/benchmarks/collector/temp/empire-1.11/display.c"
static int save_sector  ;
#line 29 "/home/june/repo/benchmarks/collector/temp/empire-1.11/display.c"
static int save_cursor  ;
#line 30 "/home/june/repo/benchmarks/collector/temp/empire-1.11/display.c"
static _Bool change_ok  =    (_Bool)1;
#line 32
static void show_loc(view_map_t *vmap , loc_t loc ) ;
#line 33
static void disp_square(view_map_t *vp ) ;
#line 34
static _Bool on_screen(loc_t loc ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/empire-1.11/display.c"
void init_colors(void) 
{ 


  {
  {
#line 39
  start_color();
#line 41
  init_pair((short)0, (short)0, (short)0);
#line 42
  init_pair((short)2, (short)2, (short)0);
#line 43
  init_pair((short)1, (short)1, (short)0);
#line 44
  init_pair((short)6, (short)6, (short)0);
#line 45
  init_pair((short)7, (short)7, (short)0);
#line 46
  init_pair((short)5, (short)5, (short)0);
#line 47
  init_pair((short)4, (short)4, (short)0);
#line 48
  init_pair((short)3, (short)3, (short)0);
#line 49
  wattr_on(stdscr, 1UL << 21, (void *)0);
#line 50
  keypad(stdscr, (_Bool)1);
  }
#line 51
  return;
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/empire-1.11/display.c"
void announce(char *msg ) 
{ 


  {
  {
#line 59
  waddnstr(stdscr, (char const   *)msg, -1);
  }
#line 60
  return;
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/empire-1.11/display.c"
int direction(chtype c ) 
{ 


  {
  {
#line 73
  if (c == 259UL) {
#line 73
    goto case_259;
  }
#line 73
  if (c == 87UL) {
#line 73
    goto case_259;
  }
#line 73
  if (c == 119UL) {
#line 73
    goto case_259;
  }
#line 79
  if (c == 339UL) {
#line 79
    goto case_339;
  }
#line 79
  if (c == 349UL) {
#line 79
    goto case_339;
  }
#line 79
  if (c == 69UL) {
#line 79
    goto case_339;
  }
#line 79
  if (c == 101UL) {
#line 79
    goto case_339;
  }
#line 84
  if (c == 261UL) {
#line 84
    goto case_261;
  }
#line 84
  if (c == 68UL) {
#line 84
    goto case_261;
  }
#line 84
  if (c == 100UL) {
#line 84
    goto case_261;
  }
#line 90
  if (c == 338UL) {
#line 90
    goto case_338;
  }
#line 90
  if (c == 352UL) {
#line 90
    goto case_338;
  }
#line 90
  if (c == 67UL) {
#line 90
    goto case_338;
  }
#line 90
  if (c == 99UL) {
#line 90
    goto case_338;
  }
#line 95
  if (c == 258UL) {
#line 95
    goto case_258;
  }
#line 95
  if (c == 88UL) {
#line 95
    goto case_258;
  }
#line 95
  if (c == 120UL) {
#line 95
    goto case_258;
  }
#line 101
  if (c == 360UL) {
#line 101
    goto case_360;
  }
#line 101
  if (c == 351UL) {
#line 101
    goto case_360;
  }
#line 101
  if (c == 90UL) {
#line 101
    goto case_360;
  }
#line 101
  if (c == 122UL) {
#line 101
    goto case_360;
  }
#line 106
  if (c == 260UL) {
#line 106
    goto case_260;
  }
#line 106
  if (c == 65UL) {
#line 106
    goto case_260;
  }
#line 106
  if (c == 97UL) {
#line 106
    goto case_260;
  }
#line 112
  if (c == 262UL) {
#line 112
    goto case_262;
  }
#line 112
  if (c == 348UL) {
#line 112
    goto case_262;
  }
#line 112
  if (c == 81UL) {
#line 112
    goto case_262;
  }
#line 112
  if (c == 113UL) {
#line 112
    goto case_262;
  }
#line 115
  goto switch_default;
  case_259: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_119: /* CIL Label */ 
#line 74
  return (0);
  case_339: /* CIL Label */ 
  case_349: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_101: /* CIL Label */ 
#line 80
  return (1);
  case_261: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_100: /* CIL Label */ 
#line 85
  return (2);
  case_338: /* CIL Label */ 
  case_352: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_99: /* CIL Label */ 
#line 91
  return (3);
  case_258: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_120: /* CIL Label */ 
#line 96
  return (4);
  case_360: /* CIL Label */ 
  case_351: /* CIL Label */ 
  case_90: /* CIL Label */ 
  case_122: /* CIL Label */ 
#line 102
  return (5);
  case_260: /* CIL Label */ 
  case_65: /* CIL Label */ 
  case_97: /* CIL Label */ 
#line 107
  return (6);
  case_262: /* CIL Label */ 
  case_348: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_113: /* CIL Label */ 
#line 113
  return (7);
  switch_default: /* CIL Label */ 
#line 116
  return (-1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/empire-1.11/display.c"
void kill_display(void) 
{ 


  {
#line 127
  whose_map = 0;
#line 128
  return;
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/empire-1.11/display.c"
void sector_change(void) 
{ 


  {
#line 137
  change_ok = (_Bool)1;
#line 138
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/empire-1.11/display.c"
int cur_sector(void) 
{ 


  {
#line 147
  if (whose_map != 1) {
#line 148
    return (-1);
  }
#line 149
  return (save_sector);
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/empire-1.11/display.c"
long cur_cursor(void) 
{ 


  {
#line 159
  if (whose_map != 1) {
#line 160
    return (-1L);
  }
#line 161
  return ((long )save_cursor);
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/empire-1.11/display.c"
void display_loc(int whose , view_map_t *vmap , long loc ) 
{ 
  _Bool tmp ;

  {
#line 177
  if (change_ok) {
    {
#line 178
    print_sector(whose, vmap, (int )(((loc % 100L) / 50L) * 5L + (loc / 100L) / 12L));
    }
  } else
#line 177
  if (whose != whose_map) {
    {
#line 178
    print_sector(whose, vmap, (int )(((loc % 100L) / 50L) * 5L + (loc / 100L) / 12L));
    }
  } else {
    {
#line 177
    tmp = on_screen(loc);
    }
#line 177
    if (! tmp) {
      {
#line 178
      print_sector(whose, vmap, (int )(((loc % 100L) / 50L) * 5L + (loc / 100L) / 12L));
      }
    }
  }
  {
#line 180
  show_loc(vmap, loc);
  }
#line 181
  return;
}
}
#line 187 "/home/june/repo/benchmarks/collector/temp/empire-1.11/display.c"
void display_locx(int whose , view_map_t *vmap , long loc ) 
{ 
  _Bool tmp ;

  {
#line 191
  if (whose == whose_map) {
    {
#line 191
    tmp = on_screen(loc);
    }
#line 191
    if (tmp) {
      {
#line 192
      show_loc(vmap, loc);
      }
    }
  }
#line 193
  return;
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/empire-1.11/display.c"
static void show_loc(view_map_t *vmap , loc_t loc ) 
{ 
  int r ;
  int c ;

  {
  {
#line 204
  r = (int )(loc / 100L);
#line 205
  c = (int )(loc % 100L);
#line 206
  wmove(stdscr, (r - ref_row) + 3, c - ref_col);
#line 207
  disp_square(vmap + loc);
#line 208
  save_cursor = (int )loc;
#line 209
  wmove(stdscr, (r - ref_row) + 3, c - ref_col);
  }
#line 210
  return;
}
}
#line 235
void display_screen(view_map_t *vmap ) ;
#line 231 "/home/june/repo/benchmarks/collector/temp/empire-1.11/display.c"
void print_sector(int whose , view_map_t *vmap , int sector ) 
{ 
  int first_row ;
  int first_col ;
  int last_row ;
  int last_col ;
  int display_rows ;
  int display_cols ;
  int r ;
  int c ;

  {
#line 241
  save_sector = sector;
#line 242
  change_ok = (_Bool)0;
#line 244
  display_rows = (lines - 3) - 1;
#line 245
  display_cols = cols - 6;
#line 248
  first_row = (sector % 5) * 12;
#line 249
  first_col = (sector / 5) * 50;
#line 250
  last_row = (first_row + 12) - 1;
#line 251
  last_col = (first_col + 50) - 1;
#line 253
  if (whose == whose_map) {
#line 253
    if (ref_row <= first_row) {
#line 253
      if (ref_col <= first_col) {
#line 253
        if ((ref_row + display_rows) - 1 >= last_row) {
#line 253
          if (! ((ref_col + display_cols) - 1 >= last_col)) {
            {
#line 258
            wclear(stdscr);
            }
          }
        } else {
          {
#line 258
          wclear(stdscr);
          }
        }
      } else {
        {
#line 258
        wclear(stdscr);
        }
      }
    } else {
      {
#line 258
      wclear(stdscr);
      }
    }
  } else {
    {
#line 258
    wclear(stdscr);
    }
  }
#line 263
  ref_row = first_row - (display_rows - 12) / 2;
#line 264
  ref_col = first_col - (display_cols - 50) / 2;
#line 267
  if ((ref_row + display_rows) - 1 > 59) {
#line 268
    ref_row = 59 - (display_rows - 1);
  }
#line 271
  if (ref_row < 0) {
#line 271
    ref_row = 0;
  }
#line 274
  if ((ref_col + display_cols) - 1 > 99) {
#line 275
    ref_col = 99 - (display_cols - 1);
  }
#line 277
  if (ref_col < 0) {
#line 277
    ref_col = 0;
  }
  {
#line 279
  whose_map = whose;
#line 280
  display_screen(vmap);
#line 283
  c = ref_col;
  }
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 283
    if (c < ref_col + display_cols) {
#line 283
      if (! (c < 100)) {
#line 283
        goto while_break;
      }
    } else {
#line 283
      goto while_break;
    }
#line 284
    if (c % 10 == 0) {
      {
#line 285
      pos_str(lines - 1, c - ref_col, (char *)"%d", c);
      }
    }
#line 283
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  r = ref_row;
  {
#line 288
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 288
    if (r < ref_row + display_rows) {
#line 288
      if (! (r < 60)) {
#line 288
        goto while_break___0;
      }
    } else {
#line 288
      goto while_break___0;
    }
#line 289
    if (r % 2 == 0) {
      {
#line 290
      pos_str((r - ref_row) + 3, (cols - 6) + 1, (char *)"%2d", r);
      }
    } else {
      {
#line 292
      pos_str((r - ref_row) + 3, (cols - 6) + 1, (char *)"  ");
      }
    }
#line 288
    r ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 295
  sprintf((char */* __restrict  */)(jnkbuf), (char const   */* __restrict  */)"Sector %d Round %ld",
          sector, date);
#line 296
  r = 0;
  }
  {
#line 296
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 296
    if (! ((int )jnkbuf[r] != 0)) {
#line 296
      goto while_break___1;
    }
#line 297
    if (r + 3 >= 60) {
#line 297
      goto while_break___1;
    }
    {
#line 298
    wmove(stdscr, r + 3, (cols - 6) + 4);
#line 299
    waddch(stdscr, (chtype const   )((chtype )jnkbuf[r]));
#line 296
    r ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 301
  return;
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/empire-1.11/display.c"
static void disp_square(view_map_t *vp ) 
{ 
  chtype attr ;

  {
  {
#line 319
  if ((int )vp->contents == 43) {
#line 319
    goto case_43;
  }
#line 322
  if ((int )vp->contents == 46) {
#line 322
    goto case_46;
  }
#line 334
  if ((int )vp->contents == 88) {
#line 334
    goto case_88;
  }
#line 334
  if ((int )vp->contents == 122) {
#line 334
    goto case_88;
  }
#line 334
  if ((int )vp->contents == 115) {
#line 334
    goto case_88;
  }
#line 334
  if ((int )vp->contents == 99) {
#line 334
    goto case_88;
  }
#line 334
  if ((int )vp->contents == 116) {
#line 334
    goto case_88;
  }
#line 334
  if ((int )vp->contents == 98) {
#line 334
    goto case_88;
  }
#line 334
  if ((int )vp->contents == 100) {
#line 334
    goto case_88;
  }
#line 334
  if ((int )vp->contents == 112) {
#line 334
    goto case_88;
  }
#line 334
  if ((int )vp->contents == 102) {
#line 334
    goto case_88;
  }
#line 334
  if ((int )vp->contents == 97) {
#line 334
    goto case_88;
  }
#line 337
  goto switch_default;
  case_43: /* CIL Label */ 
#line 320
  attr = 2UL << 8;
#line 321
  goto switch_break;
  case_46: /* CIL Label */ 
#line 323
  attr = 6UL << 8;
#line 324
  goto switch_break;
  case_88: /* CIL Label */ 
  case_122: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_97: /* CIL Label */ 
#line 335
  attr = 1UL << 8;
#line 336
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 338
  attr = 7UL << 8;
#line 339
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 341
  wattr_on(stdscr, attr, (void *)0);
#line 343
  waddch(stdscr, (chtype const   )((chtype )vp->contents));
#line 345
  wattr_off(stdscr, attr, (void *)0);
#line 346
  wattr_on(stdscr, 7UL << 8, (void *)0);
  }
#line 348
  return;
}
}
#line 355 "/home/june/repo/benchmarks/collector/temp/empire-1.11/display.c"
void display_screen(view_map_t *vmap ) 
{ 
  int display_rows ;
  int display_cols ;
  int r ;
  int c ;
  loc_t t ;

  {
#line 361
  display_rows = (lines - 3) - 1;
#line 362
  display_cols = cols - 6;
#line 364
  r = ref_row;
  {
#line 364
  while (1) {
    while_continue: /* CIL Label */ ;
#line 364
    if (r < ref_row + display_rows) {
#line 364
      if (! (r < 60)) {
#line 364
        goto while_break;
      }
    } else {
#line 364
      goto while_break;
    }
#line 365
    c = ref_col;
    {
#line 365
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 365
      if (c < ref_col + display_cols) {
#line 365
        if (! (c < 100)) {
#line 365
          goto while_break___0;
        }
      } else {
#line 365
        goto while_break___0;
      }
      {
#line 366
      t = (long )(r * 100 + c);
#line 367
      wmove(stdscr, (r - ref_row) + 3, c - ref_col);
#line 368
      disp_square(vmap + t);
#line 365
      c ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 364
    r ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 370
  return;
}
}
#line 378 "/home/june/repo/benchmarks/collector/temp/empire-1.11/display.c"
_Bool move_cursor(long *cursor , int offset ) 
{ 
  loc_t t ;
  int r ;
  int c ;
  _Bool tmp ;

  {
#line 385
  t = *cursor + (long )offset;
#line 386
  if (! map[t].on_board) {
#line 386
    return ((_Bool)0);
  }
  {
#line 387
  tmp = on_screen(t);
  }
#line 387
  if (! tmp) {
#line 387
    return ((_Bool)0);
  }
  {
#line 389
  *cursor = t;
#line 390
  save_cursor = (int )*cursor;
#line 392
  r = save_cursor / 100;
#line 393
  c = save_cursor % 100;
#line 394
  wmove(stdscr, (r - ref_row) + 3, c - ref_col);
  }
#line 396
  return ((_Bool)1);
}
}
#line 403 "/home/june/repo/benchmarks/collector/temp/empire-1.11/display.c"
static _Bool on_screen(loc_t loc ) 
{ 
  int new_r ;
  int new_c ;

  {
#line 407
  new_r = (int )(loc / 100L);
#line 408
  new_c = (int )(loc % 100L);
#line 410
  if (new_r < ref_row) {
#line 414
    return ((_Bool)0);
  } else
#line 410
  if (new_r - ref_row > (lines - 3) - 1) {
#line 414
    return ((_Bool)0);
  } else
#line 410
  if (new_c < ref_col) {
#line 414
    return ((_Bool)0);
  } else
#line 410
  if (new_c - ref_col > cols - 6) {
#line 414
    return ((_Bool)0);
  }
#line 416
  return ((_Bool)1);
}
}
#line 421 "/home/june/repo/benchmarks/collector/temp/empire-1.11/display.c"
void print_xzoom(view_map_t *vmap ) 
{ 


  {
  {
#line 424
  print_zoom(vmap);
  }
#line 429
  return;
}
}
#line 435 "/home/june/repo/benchmarks/collector/temp/empire-1.11/display.c"
char zoom_list[25]  = 
#line 435
  {      (char )'X',      (char )'O',      (char )'*',      (char )'t', 
        (char )'c',      (char )'b',      (char )'s',      (char )'d', 
        (char )'p',      (char )'f',      (char )'a',      (char )'T', 
        (char )'C',      (char )'B',      (char )'S',      (char )'D', 
        (char )'P',      (char )'F',      (char )'A',      (char )'z', 
        (char )'Z',      (char )'+',      (char )'.',      (char )' ', 
        (char )'\000'};
#line 440
void print_zoom_cell(view_map_t *vmap , int row , int col , int row_inc , int col_inc ) ;
#line 437 "/home/june/repo/benchmarks/collector/temp/empire-1.11/display.c"
void print_zoom(view_map_t *vmap ) 
{ 
  int row_inc ;
  int col_inc ;
  int r ;
  int c ;

  {
  {
#line 445
  kill_display();
#line 447
  row_inc = (((60 + lines) - 3) - 1) / (lines - 3);
#line 448
  col_inc = ((100 + cols) - 1) / (cols - 1);
#line 450
  r = 0;
  }
  {
#line 450
  while (1) {
    while_continue: /* CIL Label */ ;
#line 450
    if (! (r < 60)) {
#line 450
      goto while_break;
    }
#line 451
    c = 0;
    {
#line 451
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 451
      if (! (c < 100)) {
#line 451
        goto while_break___0;
      }
      {
#line 452
      print_zoom_cell(vmap, r, c, row_inc, col_inc);
#line 451
      c += col_inc;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 450
    r += row_inc;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 454
  pos_str(0, 0, (char *)"Round #%d", date);
#line 456
  wrefresh(stdscr);
  }
#line 457
  return;
}
}
#line 463 "/home/june/repo/benchmarks/collector/temp/empire-1.11/display.c"
void print_zoom_cell(view_map_t *vmap , int row , int col , int row_inc , int col_inc ) 
{ 
  int r ;
  int c ;
  char cell ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 470
  cell = (char )' ';
#line 471
  r = row;
  {
#line 471
  while (1) {
    while_continue: /* CIL Label */ ;
#line 471
    if (! (r < row + row_inc)) {
#line 471
      goto while_break;
    }
#line 472
    c = col;
    {
#line 472
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 472
      if (! (c < col + col_inc)) {
#line 472
        goto while_break___0;
      }
      {
#line 473
      tmp = strchr((char const   *)(zoom_list), (int )(vmap + (long )(r * 100 + c))->contents);
#line 473
      tmp___0 = strchr((char const   *)(zoom_list), (int )cell);
      }
#line 473
      if ((unsigned long )tmp < (unsigned long )tmp___0) {
#line 475
        cell = (vmap + (long )(r * 100 + c))->contents;
      }
#line 472
      c ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 471
    r ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 477
  wmove(stdscr, row / row_inc + 3, col / col_inc);
#line 478
  waddch(stdscr, (chtype const   )((chtype )cell));
  }
#line 479
  return;
}
}
#line 488
void print_pzoom_cell(path_map_t *pmap , view_map_t *vmap , int row , int col , int row_inc ,
                      int col_inc ) ;
#line 485 "/home/june/repo/benchmarks/collector/temp/empire-1.11/display.c"
void print_pzoom(char *s , path_map_t *pmap , view_map_t *vmap ) 
{ 
  int row_inc ;
  int col_inc ;
  int r ;
  int c ;

  {
  {
#line 493
  kill_display();
#line 495
  row_inc = (((60 + lines) - 3) - 1) / (lines - 3);
#line 496
  col_inc = ((100 + cols) - 1) / (cols - 1);
#line 498
  r = 0;
  }
  {
#line 498
  while (1) {
    while_continue: /* CIL Label */ ;
#line 498
    if (! (r < 60)) {
#line 498
      goto while_break;
    }
#line 499
    c = 0;
    {
#line 499
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 499
      if (! (c < 100)) {
#line 499
        goto while_break___0;
      }
      {
#line 500
      print_pzoom_cell(pmap, vmap, r, c, row_inc, col_inc);
#line 499
      c += col_inc;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 498
    r += row_inc;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 502
  prompt(s, 0, 0, 0, 0, 0, 0, 0, 0);
#line 503
  get_chx();
#line 505
  wrefresh(stdscr);
  }
#line 506
  return;
}
}
#line 517 "/home/june/repo/benchmarks/collector/temp/empire-1.11/display.c"
void print_pzoom_cell(path_map_t *pmap , view_map_t *vmap , int row , int col , int row_inc ,
                      int col_inc ) 
{ 
  int r ;
  int c ;
  int sum ;
  int d ;
  char cell ;

  {
#line 525
  sum = 0;
#line 526
  d = 0;
#line 528
  r = row;
  {
#line 528
  while (1) {
    while_continue: /* CIL Label */ ;
#line 528
    if (! (r < row + row_inc)) {
#line 528
      goto while_break;
    }
#line 529
    c = col;
    {
#line 529
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 529
      if (! (c < col + col_inc)) {
#line 529
        goto while_break___0;
      }
#line 530
      sum += (pmap + (long )(r * 100 + c))->cost;
#line 531
      d ++;
#line 529
      c ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 528
    r ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 533
  sum /= d;
#line 535
  if ((int )(pmap + (long )(row * 100 + col))->terrain == 1) {
#line 535
    cell = (char )'-';
  } else
#line 536
  if (sum < 0) {
#line 536
    cell = (char )'!';
  } else
#line 537
  if (sum == 5000000) {
#line 537
    cell = (char )'P';
  } else
#line 538
  if (sum == 10000000) {
#line 538
    cell = (char )' ';
  } else
#line 539
  if (sum > 5000000) {
#line 539
    cell = (char )'U';
  } else {
#line 541
    sum %= 36;
#line 542
    if (sum < 10) {
#line 542
      cell = (char )(sum + 48);
    } else {
#line 543
      cell = (char )((sum - 10) + 97);
    }
  }
#line 546
  if ((int )cell == 32) {
    {
#line 547
    print_zoom_cell(vmap, row, col, row_inc, col_inc);
    }
  } else {
    {
#line 549
    wmove(stdscr, row / row_inc + 3, col / col_inc);
#line 550
    waddch(stdscr, (chtype const   )((chtype )cell));
    }
  }
#line 552
  return;
}
}
#line 558 "/home/june/repo/benchmarks/collector/temp/empire-1.11/display.c"
void display_score(void) 
{ 


  {
  {
#line 561
  pos_str(1, cols - 12, (char *)" User  Comp");
#line 562
  pos_str(2, cols - 12, (char *)"%5d %5d", user_score, comp_score);
  }
#line 563
  return;
}
}
#line 569 "/home/june/repo/benchmarks/collector/temp/empire-1.11/display.c"
void clreol(int linep , int colp ) 
{ 


  {
  {
#line 572
  wmove(stdscr, linep, colp);
#line 573
  wclrtoeol(stdscr);
  }
#line 574
  return;
}
}
#line 580 "/home/june/repo/benchmarks/collector/temp/empire-1.11/display.c"
void ttinit(void) 
{ 


  {
  {
#line 583
  initscr();
#line 584
  noecho();
#line 585
  cbreak();
#line 587
  init_colors();
#line 589
  lines = LINES;
#line 590
  cols = COLS;
  }
#line 591
  if (lines > 64) {
#line 592
    lines = 64;
  }
#line 593
  if (cols > 106) {
#line 594
    cols = 106;
  }
#line 595
  return;
}
}
#line 603 "/home/june/repo/benchmarks/collector/temp/empire-1.11/display.c"
void clear_screen(void) 
{ 


  {
  {
#line 606
  wclear(stdscr);
#line 607
  wrefresh(stdscr);
#line 608
  kill_display();
  }
#line 609
  return;
}
}
#line 615 "/home/june/repo/benchmarks/collector/temp/empire-1.11/display.c"
void complain(void) 
{ 


  {
  {
#line 618
  beep();
  }
#line 619
  return;
}
}
#line 625 "/home/june/repo/benchmarks/collector/temp/empire-1.11/display.c"
void redisplay(void) 
{ 


  {
  {
#line 628
  wrefresh(stdscr);
  }
#line 629
  return;
}
}
#line 631 "/home/june/repo/benchmarks/collector/temp/empire-1.11/display.c"
void redraw(void) 
{ 


  {
  {
#line 634
  clearok(curscr, (_Bool)1);
#line 635
  wrefresh(stdscr);
  }
#line 636
  return;
}
}
#line 643 "/home/june/repo/benchmarks/collector/temp/empire-1.11/display.c"
void delay(void) 
{ 
  int t ;
  int i ;
  int tmp ;

  {
  {
#line 646
  t = delay_time;
#line 647
  i = 500;
#line 648
  wrefresh(stdscr);
  }
#line 649
  if (t > i) {
    {
#line 650
    wmove(stdscr, LINES - 1, 0);
    }
  }
  {
#line 652
  while (1) {
    while_continue: /* CIL Label */ ;
#line 652
    if (! (t > 0)) {
#line 652
      goto while_break;
    }
#line 653
    if (t > i) {
#line 653
      tmp = i;
    } else {
#line 653
      tmp = t;
    }
    {
#line 653
    napms(tmp);
    }
#line 654
    if (t > i) {
      {
#line 655
      waddnstr(stdscr, "*", -1);
#line 656
      wrefresh(stdscr);
      }
    }
#line 652
    t -= i;
  }
  while_break: /* CIL Label */ ;
  }
#line 659
  return;
}
}
#line 665 "/home/june/repo/benchmarks/collector/temp/empire-1.11/display.c"
void close_disp(void) 
{ 


  {
  {
#line 668
  wmove(stdscr, LINES - 1, 0);
#line 669
  wclrtoeol(stdscr);
#line 670
  wrefresh(stdscr);
#line 671
  endwin();
  }
#line 672
  return;
}
}
#line 678 "/home/june/repo/benchmarks/collector/temp/empire-1.11/display.c"
void pos_str(int row , int col , char *str  , ...) 
{ 
  va_list ap ;
  char junkbuf[80] ;

  {
  {
#line 684
  __builtin_va_start(ap, str);
#line 685
  wmove(stdscr, row, col);
#line 686
  vsprintf((char */* __restrict  */)(junkbuf), (char const   */* __restrict  */)str,
           ap);
#line 687
  waddnstr(stdscr, (char const   *)(junkbuf), -1);
#line 688
  __builtin_va_end(ap);
  }
#line 689
  return;
}
}
#line 697 "/home/june/repo/benchmarks/collector/temp/empire-1.11/display.c"
void print_movie_cell(char *mbuf , int row , int col , int row_inc , int col_inc ) 
{ 
  int r ;
  int c ;
  char cell ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 703
  cell = (char )' ';
#line 704
  r = row;
  {
#line 704
  while (1) {
    while_continue: /* CIL Label */ ;
#line 704
    if (! (r < row + row_inc)) {
#line 704
      goto while_break;
    }
#line 705
    c = col;
    {
#line 705
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 705
      if (! (c < col + col_inc)) {
#line 705
        goto while_break___0;
      }
      {
#line 706
      tmp = strchr((char const   *)(zoom_list), (int )*(mbuf + (long )(r * 100 + c)));
#line 706
      tmp___0 = strchr((char const   *)(zoom_list), (int )cell);
      }
#line 706
      if ((unsigned long )tmp < (unsigned long )tmp___0) {
#line 708
        cell = *(mbuf + (long )(r * 100 + c));
      }
#line 705
      c ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 704
    r ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 710
  wmove(stdscr, row / row_inc + 3, col / col_inc);
#line 711
  waddch(stdscr, (chtype const   )((chtype )cell));
  }
#line 712
  return;
}
}
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/empire-1.11/extern.h"
piece_attr_t piece_attr[9] ;
#line 42
int dir_offset[8] ;
#line 43
char *func_name[19] ;
#line 182
long irand(long high ) ;
#line 183
int dist(long a , long b ) ;
#line 186
int find_nearest_city(long loc , int owner , long *city_loc ) ;
#line 187
city_info_t *find_city(long loc ) ;
#line 188
piece_info_t *find_obj(int type , long loc ) ;
#line 189
piece_info_t *find_nfull(int type , long loc ) ;
#line 190
long find_transport(int owner , long loc ) ;
#line 191
piece_info_t *find_obj_at_loc(long loc ) ;
#line 192
int obj_moves(piece_info_t *obj ) ;
#line 193
int obj_capacity(piece_info_t *obj ) ;
#line 194
void kill_obj(piece_info_t *obj , long loc ) ;
#line 195
void kill_city(city_info_t *cityp ) ;
#line 196
void produce(city_info_t *cityp ) ;
#line 197
void move_obj(piece_info_t *obj , long new_loc ) ;
#line 198
void move_sat(piece_info_t *obj ) ;
#line 199
_Bool good_loc(piece_info_t *obj , long loc ) ;
#line 200
void embark(piece_info_t *ship , piece_info_t *obj ) ;
#line 201
void disembark(piece_info_t *obj ) ;
#line 202
void describe_obj(piece_info_t *obj ) ;
#line 203
void scan(view_map_t *vmap , long loc ) ;
#line 204
void scan_sat(view_map_t *vmap , long loc ) ;
#line 205
void set_prod(city_info_t *cityp ) ;
#line 213
void error(char *fmt  , ...) ;
#line 215
void comment(char *fmt  , ...) ;
#line 220
void ksend(char *fmt  , ...) ;
#line 224
void assert(char *expression , char *file , int line ) ;
#line 229
int loc_disp(int loc ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/empire-1.11/object.c"
int get_piece_name(void) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/empire-1.11/object.c"
int find_nearest_city(long loc , int owner , long *city_loc ) 
{ 
  loc_t best_loc___0 ;
  long best_dist ;
  long new_dist ;
  long i ;
  int tmp ;

  {
#line 33
  best_dist = 10000000L;
#line 34
  best_loc___0 = loc;
#line 36
  i = 0L;
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! (i < 70L)) {
#line 36
      goto while_break;
    }
#line 37
    if ((int )city[i].owner == owner) {
      {
#line 38
      tmp = dist(loc, city[i].loc);
#line 38
      new_dist = (long )tmp;
      }
#line 39
      if (new_dist < best_dist) {
#line 40
        best_dist = new_dist;
#line 41
        best_loc___0 = city[i].loc;
      }
    }
#line 36
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 44
  *city_loc = best_loc___0;
#line 45
  return ((int )best_dist);
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/empire-1.11/object.c"
city_info_t *find_city(long loc ) 
{ 


  {
#line 54
  return (map[loc].cityp);
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/empire-1.11/object.c"
int obj_moves(piece_info_t *obj ) 
{ 


  {
#line 68
  return ((((int )piece_attr[obj->type].speed * (int )obj->hits + (int )piece_attr[obj->type].max_hits) - 1) / (int )piece_attr[obj->type].max_hits);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/empire-1.11/object.c"
int obj_capacity(piece_info_t *obj ) 
{ 


  {
#line 79
  return ((((int )piece_attr[obj->type].capacity * (int )obj->hits + (int )piece_attr[obj->type].max_hits) - 1) / (int )piece_attr[obj->type].max_hits);
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/empire-1.11/object.c"
piece_info_t *find_obj(int type , long loc ) 
{ 
  piece_info_t *p ;

  {
#line 93
  p = map[loc].objp;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 93
      goto while_break;
    }
#line 94
    if (p->type == type) {
#line 94
      return (p);
    }
#line 93
    p = p->loc_link.next;
  }
  while_break: /* CIL Label */ ;
  }
#line 96
  return ((piece_info_t *)((void *)0));
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/empire-1.11/object.c"
piece_info_t *find_nfull(int type , long loc ) 
{ 
  piece_info_t *p ;
  int tmp ;

  {
#line 107
  p = map[loc].objp;
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 107
      goto while_break;
    }
#line 108
    if (p->type == type) {
      {
#line 109
      tmp = obj_capacity(p);
      }
#line 109
      if (tmp > (int )p->count) {
#line 109
        return (p);
      }
    }
#line 107
    p = p->loc_link.next;
  }
  while_break: /* CIL Label */ ;
  }
#line 111
  return ((piece_info_t *)((void *)0));
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/empire-1.11/object.c"
long find_transport(int owner , long loc ) 
{ 
  int i ;
  loc_t new_loc ;
  piece_info_t *t ;

  {
#line 126
  i = 0;
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    if (! (i < 8)) {
#line 126
      goto while_break;
    }
    {
#line 127
    new_loc = loc + (long )dir_offset[i];
#line 128
    t = find_nfull(5, new_loc);
    }
#line 129
    if ((unsigned long )t != (unsigned long )((void *)0)) {
#line 129
      if (t->owner == owner) {
#line 129
        return (new_loc);
      }
    }
#line 126
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 131
  return (loc);
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/empire-1.11/object.c"
piece_info_t *find_obj_at_loc(long loc ) 
{ 
  piece_info_t *p ;
  piece_info_t *best ;

  {
#line 144
  best = map[loc].objp;
#line 145
  if ((unsigned long )best == (unsigned long )((void *)0)) {
#line 145
    return ((piece_info_t *)((void *)0));
  }
#line 147
  p = best->loc_link.next;
  {
#line 147
  while (1) {
    while_continue: /* CIL Label */ ;
#line 147
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 147
      goto while_break;
    }
#line 148
    if (p->type > best->type) {
#line 148
      if (p->type != 8) {
#line 149
        best = p;
      }
    }
#line 147
    p = p->loc_link.next;
  }
  while_break: /* CIL Label */ ;
  }
#line 151
  return (best);
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/empire-1.11/object.c"
void disembark(piece_info_t *obj ) 
{ 


  {
#line 160
  if (obj->ship) {
#line 161
    if (obj->cargo_link.next) {
#line 161
      (obj->cargo_link.next)->cargo_link.prev = obj->cargo_link.prev;
    }
#line 161
    if (obj->cargo_link.prev) {
#line 161
      (obj->cargo_link.prev)->cargo_link.next = obj->cargo_link.next;
    } else {
#line 161
      (obj->ship)->cargo = obj->cargo_link.next;
    }
#line 161
    obj->cargo_link.next = (struct piece_info *)((void *)0);
#line 161
    obj->cargo_link.prev = (struct piece_info *)((void *)0);
#line 162
    (obj->ship)->count = (short )((int )(obj->ship)->count - 1);
#line 163
    obj->ship = (struct piece_info *)((void *)0);
  }
#line 165
  return;
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/empire-1.11/object.c"
void embark(piece_info_t *ship , piece_info_t *obj ) 
{ 


  {
#line 173
  obj->ship = ship;
#line 174
  obj->cargo_link.prev = (struct piece_info *)((void *)0);
#line 174
  obj->cargo_link.next = ship->cargo;
#line 174
  if (ship->cargo) {
#line 174
    (ship->cargo)->cargo_link.prev = obj;
  }
#line 174
  ship->cargo = obj;
#line 175
  ship->count = (short )((int )ship->count + 1);
#line 176
  return;
}
}
#line 185
void kill_one(piece_info_t **list , piece_info_t *obj ) ;
#line 183 "/home/june/repo/benchmarks/collector/temp/empire-1.11/object.c"
void kill_obj(piece_info_t *obj , long loc ) 
{ 
  piece_info_t **list ;
  view_map_t *vmap ;

  {
#line 190
  if (obj->owner == 1) {
#line 190
    vmap = user_map;
  } else {
#line 190
    vmap = comp_map;
  }
#line 191
  if (obj->owner == 1) {
#line 191
    list = user_obj;
  } else {
#line 191
    list = comp_obj;
  }
  {
#line 193
  while (1) {
    while_continue: /* CIL Label */ ;
#line 193
    if (! ((unsigned long )obj->cargo != (unsigned long )((void *)0))) {
#line 193
      goto while_break;
    }
    {
#line 194
    kill_one(list, obj->cargo);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 196
  kill_one(list, obj);
#line 197
  scan(vmap, loc);
  }
#line 198
  return;
}
}
#line 202 "/home/june/repo/benchmarks/collector/temp/empire-1.11/object.c"
void kill_one(piece_info_t **list , piece_info_t *obj ) 
{ 


  {
#line 204
  if (obj->piece_link.next) {
#line 204
    (obj->piece_link.next)->piece_link.prev = obj->piece_link.prev;
  }
#line 204
  if (obj->piece_link.prev) {
#line 204
    (obj->piece_link.prev)->piece_link.next = obj->piece_link.next;
  } else {
#line 204
    *(list + obj->type) = obj->piece_link.next;
  }
#line 204
  obj->piece_link.next = (struct piece_info *)((void *)0);
#line 204
  obj->piece_link.prev = (struct piece_info *)((void *)0);
#line 205
  if (obj->loc_link.next) {
#line 205
    (obj->loc_link.next)->loc_link.prev = obj->loc_link.prev;
  }
#line 205
  if (obj->loc_link.prev) {
#line 205
    (obj->loc_link.prev)->loc_link.next = obj->loc_link.next;
  } else {
#line 205
    map[obj->loc].objp = obj->loc_link.next;
  }
  {
#line 205
  obj->loc_link.next = (struct piece_info *)((void *)0);
#line 205
  obj->loc_link.prev = (struct piece_info *)((void *)0);
#line 206
  disembark(obj);
#line 208
  obj->piece_link.prev = (struct piece_info *)((void *)0);
#line 208
  obj->piece_link.next = free_list;
  }
#line 208
  if (free_list) {
#line 208
    free_list->piece_link.prev = obj;
  }
#line 208
  free_list = obj;
#line 209
  obj->hits = (short)0;
#line 210
  obj->moved = (int )piece_attr[obj->type].speed;
#line 211
  return;
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/empire-1.11/object.c"
void kill_city(city_info_t *cityp ) 
{ 
  view_map_t *vmap ;
  piece_info_t *p ;
  piece_info_t *next_p ;
  piece_info_t **list ;
  int i ;

  {
#line 227
  p = map[cityp->loc].objp;
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 227
    if (! p) {
#line 227
      goto while_break;
    }
#line 228
    next_p = p->loc_link.next;
#line 230
    if (p->type == 0) {
      {
#line 230
      kill_obj(p, cityp->loc);
      }
    } else
#line 231
    if (p->type != 8) {
#line 232
      if (p->type == 5) {
#line 233
        if (p->owner == 1) {
#line 233
          list = user_obj;
        } else {
#line 233
          list = comp_obj;
        }
        {
#line 235
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 235
          if (! ((unsigned long )p->cargo != (unsigned long )((void *)0))) {
#line 235
            goto while_break___0;
          }
          {
#line 236
          kill_one(list, p->cargo);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 238
      if (p->owner == 1) {
#line 238
        list = user_obj;
      } else {
#line 238
        list = comp_obj;
      }
#line 239
      if (p->piece_link.next) {
#line 239
        (p->piece_link.next)->piece_link.prev = p->piece_link.prev;
      }
#line 239
      if (p->piece_link.prev) {
#line 239
        (p->piece_link.prev)->piece_link.next = p->piece_link.next;
      } else {
#line 239
        *(list + p->type) = p->piece_link.next;
      }
#line 239
      p->piece_link.next = (struct piece_info *)((void *)0);
#line 239
      p->piece_link.prev = (struct piece_info *)((void *)0);
#line 240
      if (p->owner == 1) {
#line 240
        p->owner = 2;
      } else {
#line 240
        p->owner = 1;
      }
#line 241
      if (p->owner == 1) {
#line 241
        list = user_obj;
      } else {
#line 241
        list = comp_obj;
      }
#line 242
      p->piece_link.prev = (struct piece_info *)((void *)0);
#line 242
      p->piece_link.next = *(list + p->type);
#line 242
      if (*(list + p->type)) {
#line 242
        (*(list + p->type))->piece_link.prev = p;
      }
#line 242
      *(list + p->type) = p;
#line 244
      p->func = -1L;
    }
#line 227
    p = next_p;
  }
  while_break: /* CIL Label */ ;
  }
#line 248
  if ((int )cityp->owner != 0) {
#line 249
    if ((int )cityp->owner == 1) {
#line 249
      vmap = user_map;
    } else {
#line 249
      vmap = comp_map;
    }
#line 250
    cityp->owner = (uchar )0;
#line 251
    cityp->work = 0L;
#line 252
    cityp->prod = (char)-1;
#line 254
    i = 0;
    {
#line 254
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 254
      if (! (i < 9)) {
#line 254
        goto while_break___1;
      }
#line 255
      cityp->func[i] = -1L;
#line 254
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 257
    scan(vmap, cityp->loc);
    }
  }
#line 259
  return;
}
}
#line 265 "/home/june/repo/benchmarks/collector/temp/empire-1.11/object.c"
static int sat_dir[4]  = {      -19,      -17,      -13,      -15};
#line 267 "/home/june/repo/benchmarks/collector/temp/empire-1.11/object.c"
void produce(city_info_t *cityp ) 
{ 
  piece_info_t **list ;
  piece_info_t *new ;
  long tmp ;

  {
#line 273
  if ((int )cityp->owner == 1) {
#line 273
    list = user_obj;
  } else {
#line 273
    list = comp_obj;
  }
#line 275
  cityp->work -= (long )piece_attr[(int )cityp->prod].build_time;
#line 277
  if (! free_list) {
    {
#line 277
    assert((char *)"x", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/object.c",
           277);
    }
  }
#line 278
  new = free_list;
#line 279
  if (new->piece_link.next) {
#line 279
    (new->piece_link.next)->piece_link.prev = new->piece_link.prev;
  }
#line 279
  if (new->piece_link.prev) {
#line 279
    (new->piece_link.prev)->piece_link.next = new->piece_link.next;
  } else {
#line 279
    free_list = new->piece_link.next;
  }
#line 279
  new->piece_link.next = (struct piece_info *)((void *)0);
#line 279
  new->piece_link.prev = (struct piece_info *)((void *)0);
#line 280
  new->piece_link.prev = (struct piece_info *)((void *)0);
#line 280
  new->piece_link.next = *(list + (int )cityp->prod);
#line 280
  if (*(list + (int )cityp->prod)) {
#line 280
    (*(list + (int )cityp->prod))->piece_link.prev = new;
  }
#line 280
  *(list + (int )cityp->prod) = new;
#line 281
  new->loc_link.prev = (struct piece_info *)((void *)0);
#line 281
  new->loc_link.next = map[cityp->loc].objp;
#line 281
  if (map[cityp->loc].objp) {
#line 281
    (map[cityp->loc].objp)->loc_link.prev = new;
  }
#line 281
  map[cityp->loc].objp = new;
#line 282
  new->cargo_link.next = (struct piece_info *)((void *)0);
#line 283
  new->cargo_link.prev = (struct piece_info *)((void *)0);
#line 285
  new->loc = cityp->loc;
#line 286
  new->func = -1L;
#line 287
  new->hits = (short )piece_attr[(int )cityp->prod].max_hits;
#line 288
  new->owner = (int )cityp->owner;
#line 289
  new->type = (int )cityp->prod;
#line 290
  new->moved = 0;
#line 291
  new->cargo = (struct piece_info *)((void *)0);
#line 292
  new->ship = (struct piece_info *)((void *)0);
#line 293
  new->count = (short)0;
#line 294
  new->range = (short )piece_attr[(int )cityp->prod].range;
#line 296
  if (new->type == 8) {
    {
#line 297
    tmp = irand(4L);
#line 297
    new->func = (long )sat_dir[tmp];
    }
  }
#line 299
  return;
}
}
#line 309 "/home/june/repo/benchmarks/collector/temp/empire-1.11/object.c"
void move_obj(piece_info_t *obj , long new_loc ) 
{ 
  view_map_t *vmap ;
  loc_t old_loc ;
  piece_info_t *p ;

  {
#line 315
  if (! obj->hits) {
    {
#line 315
    assert((char *)"x", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/object.c",
           315);
    }
  }
#line 316
  if (obj->owner == 1) {
#line 316
    vmap = user_map;
  } else {
#line 316
    vmap = comp_map;
  }
  {
#line 318
  old_loc = obj->loc;
#line 319
  (obj->moved) ++;
#line 320
  obj->loc = new_loc;
#line 321
  obj->range = (short )((int )obj->range - 1);
#line 323
  disembark(obj);
  }
#line 325
  if (obj->loc_link.next) {
#line 325
    (obj->loc_link.next)->loc_link.prev = obj->loc_link.prev;
  }
#line 325
  if (obj->loc_link.prev) {
#line 325
    (obj->loc_link.prev)->loc_link.next = obj->loc_link.next;
  } else {
#line 325
    map[old_loc].objp = obj->loc_link.next;
  }
#line 325
  obj->loc_link.next = (struct piece_info *)((void *)0);
#line 325
  obj->loc_link.prev = (struct piece_info *)((void *)0);
#line 326
  obj->loc_link.prev = (struct piece_info *)((void *)0);
#line 326
  obj->loc_link.next = map[new_loc].objp;
#line 326
  if (map[new_loc].objp) {
#line 326
    (map[new_loc].objp)->loc_link.prev = obj;
  }
#line 326
  map[new_loc].objp = obj;
#line 329
  p = obj->cargo;
  {
#line 329
  while (1) {
    while_continue: /* CIL Label */ ;
#line 329
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 329
      goto while_break;
    }
#line 330
    p->loc = new_loc;
#line 331
    if (p->loc_link.next) {
#line 331
      (p->loc_link.next)->loc_link.prev = p->loc_link.prev;
    }
#line 331
    if (p->loc_link.prev) {
#line 331
      (p->loc_link.prev)->loc_link.next = p->loc_link.next;
    } else {
#line 331
      map[old_loc].objp = p->loc_link.next;
    }
#line 331
    p->loc_link.next = (struct piece_info *)((void *)0);
#line 331
    p->loc_link.prev = (struct piece_info *)((void *)0);
#line 332
    p->loc_link.prev = (struct piece_info *)((void *)0);
#line 332
    p->loc_link.next = map[new_loc].objp;
#line 332
    if (map[new_loc].objp) {
#line 332
      (map[new_loc].objp)->loc_link.prev = p;
    }
#line 332
    map[new_loc].objp = p;
#line 329
    p = p->cargo_link.next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 336
  if (obj->type == 1) {
#line 336
    goto case_1;
  }
#line 343
  if (obj->type == 0) {
#line 343
    goto case_0;
  }
#line 335
  goto switch_break;
  case_1: /* CIL Label */ 
#line 337
  if ((unsigned long )map[obj->loc].cityp == (unsigned long )((void *)0)) {
    {
#line 338
    p = find_nfull(6, obj->loc);
    }
#line 339
    if ((unsigned long )p != (unsigned long )((void *)0)) {
      {
#line 339
      embark(p, obj);
      }
    }
  }
#line 341
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 344
  p = find_nfull(5, obj->loc);
  }
#line 345
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 345
    embark(p, obj);
    }
  }
#line 346
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 349
  if (obj->type == 8) {
    {
#line 350
    scan_sat(vmap, obj->loc);
    }
  }
  {
#line 351
  scan(vmap, obj->loc);
  }
#line 352
  return;
}
}
#line 363 "/home/june/repo/benchmarks/collector/temp/empire-1.11/object.c"
static loc_t bounce(loc_t loc , loc_t dir1 , loc_t dir2 , loc_t dir3 ) 
{ 
  int new_loc ;

  {
#line 368
  new_loc = (int )(loc + (loc_t )dir_offset[- dir1 + -12L]);
#line 369
  if (map[new_loc].on_board) {
#line 369
    return (dir1);
  }
#line 371
  new_loc = (int )(loc + (loc_t )dir_offset[- dir2 + -12L]);
#line 372
  if (map[new_loc].on_board) {
#line 372
    return (dir2);
  }
#line 374
  return (dir3);
}
}
#line 379 "/home/june/repo/benchmarks/collector/temp/empire-1.11/object.c"
static void move_sat1(piece_info_t *obj ) 
{ 
  int dir ;
  loc_t new_loc ;

  {
#line 385
  dir = (int )(- obj->func + -12L);
#line 386
  new_loc = obj->loc + (loc_t )dir_offset[dir];
#line 388
  if (! map[new_loc].on_board) {
    {
#line 390
    if (obj->func == -13L) {
#line 390
      goto case_neg_13;
    }
#line 393
    if (obj->func == -19L) {
#line 393
      goto case_neg_19;
    }
#line 396
    if (obj->func == -15L) {
#line 396
      goto case_neg_15;
    }
#line 399
    if (obj->func == -17L) {
#line 399
      goto case_neg_17;
    }
#line 402
    goto switch_default;
    case_neg_13: /* CIL Label */ 
    {
#line 391
    obj->func = bounce(obj->loc, (loc_t )-19, (loc_t )-15, (loc_t )-17);
    }
#line 392
    goto switch_break;
    case_neg_19: /* CIL Label */ 
    {
#line 394
    obj->func = bounce(obj->loc, (loc_t )-13, (loc_t )-17, (loc_t )-15);
    }
#line 395
    goto switch_break;
    case_neg_15: /* CIL Label */ 
    {
#line 397
    obj->func = bounce(obj->loc, (loc_t )-17, (loc_t )-13, (loc_t )-19);
    }
#line 398
    goto switch_break;
    case_neg_17: /* CIL Label */ 
    {
#line 400
    obj->func = bounce(obj->loc, (loc_t )-15, (loc_t )-19, (loc_t )-13);
    }
#line 401
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 402
    assert((char *)"aborting", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/object.c",
           402);
    }
    switch_break: /* CIL Label */ ;
    }
#line 404
    dir = (int )(- obj->func + -12L);
#line 405
    new_loc = obj->loc + (loc_t )dir_offset[dir];
  }
  {
#line 407
  move_obj(obj, new_loc);
  }
#line 408
  return;
}
}
#line 415 "/home/june/repo/benchmarks/collector/temp/empire-1.11/object.c"
void move_sat(piece_info_t *obj ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 418
  obj->moved = 0;
  {
#line 420
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 420
    tmp___1 = obj_moves(obj);
    }
#line 420
    if (! (obj->moved < tmp___1)) {
#line 420
      goto while_break;
    }
    {
#line 421
    move_sat1(obj);
    }
#line 422
    if ((int )obj->range == 0) {
#line 423
      if (obj->owner == 1) {
        {
#line 424
        tmp = loc_disp((int )obj->loc);
#line 424
        comment((char *)"Satellite at %d crashed and burned.", tmp);
        }
      }
      {
#line 425
      tmp___0 = loc_disp((int )obj->loc);
#line 425
      ksend((char *)"Satellite at %d crashed and burned.", tmp___0);
#line 426
      kill_obj(obj, obj->loc);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 429
  return;
}
}
#line 439 "/home/june/repo/benchmarks/collector/temp/empire-1.11/object.c"
_Bool good_loc(piece_info_t *obj , long loc ) 
{ 
  view_map_t *vmap ;
  piece_info_t *p ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 444
  if (! map[loc].on_board) {
#line 444
    return ((_Bool)0);
  }
#line 446
  if (obj->owner == 1) {
#line 446
    vmap = user_map;
  } else {
#line 446
    vmap = comp_map;
  }
  {
#line 448
  tmp = strchr((char const   *)(piece_attr[obj->type].terrain), (int )(vmap + loc)->contents);
  }
#line 448
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 449
    return ((_Bool)1);
  }
#line 452
  if (obj->type == 0) {
    {
#line 453
    p = find_nfull(5, loc);
    }
#line 454
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 454
      if (p->owner == obj->owner) {
#line 454
        tmp___0 = 1;
      } else {
#line 454
        tmp___0 = 0;
      }
    } else {
#line 454
      tmp___0 = 0;
    }
#line 454
    return ((_Bool )tmp___0);
  }
#line 458
  if (map[loc].cityp) {
#line 458
    if ((int )(map[loc].cityp)->owner == obj->owner) {
#line 459
      return ((_Bool)1);
    }
  }
#line 462
  if (obj->type == 1) {
    {
#line 463
    p = find_nfull(6, loc);
    }
#line 464
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 464
      if (p->owner == obj->owner) {
#line 464
        tmp___1 = 1;
      } else {
#line 464
        tmp___1 = 0;
      }
    } else {
#line 464
      tmp___1 = 0;
    }
#line 464
    return ((_Bool )tmp___1);
  }
#line 467
  return ((_Bool)0);
}
}
#line 470 "/home/june/repo/benchmarks/collector/temp/empire-1.11/object.c"
void describe_obj(piece_info_t *obj ) 
{ 
  char func[80] ;
  char other[80] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 475
  if (obj->func >= 0L) {
    {
#line 475
    tmp = loc_disp((int )obj->func);
#line 475
    sprintf((char */* __restrict  */)(func), (char const   */* __restrict  */)"%d",
            tmp);
    }
  } else {
    {
#line 476
    sprintf((char */* __restrict  */)(func), (char const   */* __restrict  */)func_name[- obj->func - 1L]);
    }
  }
#line 478
  other[0] = (char)0;
  {
#line 481
  if (obj->type == 1) {
#line 481
    goto case_1;
  }
#line 485
  if (obj->type == 5) {
#line 485
    goto case_5;
  }
#line 489
  if (obj->type == 6) {
#line 489
    goto case_6;
  }
#line 480
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 482
  sprintf((char */* __restrict  */)(other), (char const   */* __restrict  */)"; range = %d",
          (int )obj->range);
  }
#line 483
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 486
  sprintf((char */* __restrict  */)(other), (char const   */* __restrict  */)"; armies = %d",
          (int )obj->count);
  }
#line 487
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 490
  sprintf((char */* __restrict  */)(other), (char const   */* __restrict  */)"; fighters = %d",
          (int )obj->count);
  }
#line 491
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 494
  tmp___0 = obj_moves(obj);
#line 494
  tmp___1 = loc_disp((int )obj->loc);
#line 494
  prompt((char *)"%s at %d:  moves = %d; hits = %d; func = %s%s", piece_attr[obj->type].name,
         tmp___1, tmp___0 - obj->moved, (int )obj->hits, func, other);
  }
#line 501
  return;
}
}
#line 515
void update(view_map_t *vmap , loc_t loc ) ;
#line 512 "/home/june/repo/benchmarks/collector/temp/empire-1.11/object.c"
void scan(view_map_t *vmap , long loc ) 
{ 
  int i ;
  loc_t xloc ;

  {
#line 523
  if (! map[loc].on_board) {
    {
#line 523
    assert((char *)"x", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/object.c",
           523);
    }
  }
#line 525
  i = 0;
  {
#line 525
  while (1) {
    while_continue: /* CIL Label */ ;
#line 525
    if (! (i < 8)) {
#line 525
      goto while_break;
    }
    {
#line 526
    xloc = loc + (long )dir_offset[i];
#line 527
    update(vmap, xloc);
#line 525
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 529
  update(vmap, loc);
  }
#line 530
  return;
}
}
#line 536 "/home/june/repo/benchmarks/collector/temp/empire-1.11/object.c"
void scan_sat(view_map_t *vmap , long loc ) 
{ 
  int i ;
  loc_t xloc ;

  {
#line 542
  if (! map[loc].on_board) {
    {
#line 542
    assert((char *)"x", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/object.c",
           542);
    }
  }
#line 544
  i = 0;
  {
#line 544
  while (1) {
    while_continue: /* CIL Label */ ;
#line 544
    if (! (i < 8)) {
#line 544
      goto while_break;
    }
#line 545
    xloc = loc + (long )(2 * dir_offset[i]);
#line 546
    if (xloc >= 0L) {
#line 546
      if (xloc < 6000L) {
#line 546
        if (map[xloc].on_board) {
          {
#line 547
          scan(vmap, xloc);
          }
        }
      }
    }
#line 544
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 549
  scan(vmap, loc);
  }
#line 550
  return;
}
}
#line 558 "/home/june/repo/benchmarks/collector/temp/empire-1.11/object.c"
char city_char[3]  = {      (char )'*',      (char )'O',      (char )'X'};
#line 560 "/home/june/repo/benchmarks/collector/temp/empire-1.11/object.c"
void update(view_map_t *vmap , loc_t loc ) 
{ 
  piece_info_t *p ;
  piece_info_t *tmp ;
  int tmp___0 ;

  {
#line 563
  (vmap + loc)->seen = date;
#line 565
  if (map[loc].cityp) {
#line 566
    (vmap + loc)->contents = city_char[(map[loc].cityp)->owner];
  } else {
    {
#line 569
    tmp = find_obj_at_loc(loc);
#line 569
    p = tmp;
    }
#line 571
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 572
      (vmap + loc)->contents = map[loc].contents;
    } else
#line 573
    if (p->owner == 1) {
#line 574
      (vmap + loc)->contents = piece_attr[p->type].sname;
    } else {
      {
#line 576
      tmp___0 = tolower((int )piece_attr[p->type].sname);
#line 576
      (vmap + loc)->contents = (char )tmp___0;
      }
    }
  }
#line 578
  if ((unsigned long )vmap == (unsigned long )(comp_map)) {
    {
#line 579
    display_locx(2, comp_map, loc);
    }
  } else
#line 580
  if ((unsigned long )vmap == (unsigned long )(user_map)) {
    {
#line 581
    display_locx(1, user_map, loc);
    }
  }
#line 582
  return;
}
}
#line 590 "/home/june/repo/benchmarks/collector/temp/empire-1.11/object.c"
void set_prod(city_info_t *cityp ) 
{ 
  int i ;
  int tmp ;

  {
  {
#line 595
  scan(user_map, cityp->loc);
#line 596
  display_loc(1, user_map, cityp->loc);
  }
  {
#line 598
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 599
    tmp = loc_disp((int )cityp->loc);
#line 599
    prompt((char *)"What do you want the city at %d to produce? ", tmp);
#line 601
    i = get_piece_name();
    }
#line 603
    if (i == -1) {
      {
#line 604
      error((char *)"I don\'t know how to build those.");
      }
    } else {
#line 607
      cityp->prod = (char )i;
#line 608
      cityp->work = (long )(- ((int )piece_attr[i].build_time / 5));
#line 609
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 616 "/home/june/repo/benchmarks/collector/temp/empire-1.11/object.c"
int get_piece_name(void) 
{ 
  char c ;
  int i ;

  {
  {
#line 622
  c = get_chx();
#line 624
  i = 0;
  }
  {
#line 624
  while (1) {
    while_continue: /* CIL Label */ ;
#line 624
    if (! (i < 9)) {
#line 624
      goto while_break;
    }
#line 625
    if ((int )piece_attr[i].sname == (int )c) {
#line 626
      return (i);
    }
#line 624
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 628
  return (-1);
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/empire-1.11/extern.h"
void attack(piece_info_t *att_obj , long loc ) ;
#line 211
void topmsg(int line , char *fmt  , ...) ;
#line 216
void extra(char *fmt  , ...) ;
#line 219
void set_need_delay(void) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/empire-1.11/attack.c"
void attack_city(piece_info_t *att_obj , loc_t loc ) 
{ 
  city_info_t *cityp ;
  int att_owner ;
  int city_owner ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  view_map_t *tmp___6 ;

  {
  {
#line 35
  cityp = find_city(loc);
  }
#line 36
  if (! cityp) {
    {
#line 36
    assert((char *)"x", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/attack.c",
           36);
    }
  }
  {
#line 38
  att_owner = att_obj->owner;
#line 39
  city_owner = (int )cityp->owner;
#line 41
  tmp___5 = irand(2L);
  }
#line 41
  if (tmp___5 == 0L) {
#line 42
    if (att_owner == 1) {
      {
#line 43
      comment((char *)"The scum defending the city crushed your attacking blitzkrieger.");
#line 44
      ksend((char *)"The scum defending the city crushed your attacking blitzkrieger.\n");
      }
    } else
#line 46
    if (city_owner == 1) {
      {
#line 47
      tmp = loc_disp((int )cityp->loc);
#line 47
      ksend((char *)"Your city at %d is under attack.\n", tmp);
#line 48
      tmp___0 = loc_disp((int )cityp->loc);
#line 48
      comment((char *)"Your city at %d is under attack.", tmp___0);
      }
    }
    {
#line 50
    kill_obj(att_obj, loc);
    }
  } else {
    {
#line 53
    kill_city(cityp);
#line 54
    cityp->owner = (uchar )att_owner;
#line 55
    kill_obj(att_obj, loc);
    }
#line 57
    if (att_owner == 1) {
      {
#line 58
      tmp___1 = loc_disp((int )cityp->loc);
#line 58
      ksend((char *)"City at %d has been subjugated!\n", tmp___1);
#line 59
      tmp___2 = loc_disp((int )cityp->loc);
#line 59
      error((char *)"City at %d has been subjugated!", tmp___2);
#line 61
      extra((char *)"Your army has been dispersed to enforce control.");
#line 62
      ksend((char *)"Your army has been dispersed to enforce control.\n");
#line 63
      set_prod(cityp);
      }
    } else
#line 65
    if (city_owner == 1) {
      {
#line 66
      tmp___3 = loc_disp((int )cityp->loc);
#line 66
      ksend((char *)"City at %d has been lost to the enemy!\n", tmp___3);
#line 67
      tmp___4 = loc_disp((int )cityp->loc);
#line 67
      comment((char *)"City at %d has been lost to the enemy!", tmp___4);
      }
    }
  }
#line 71
  if (city_owner != 0) {
#line 71
    if (city_owner == 1) {
#line 71
      tmp___6 = user_map;
    } else {
#line 71
      tmp___6 = comp_map;
    }
    {
#line 71
    scan(tmp___6, loc);
    }
  }
#line 72
  return;
}
}
#line 82
void describe(piece_info_t *win_obj , piece_info_t *lose_obj , loc_t loc ) ;
#line 82
void survive(piece_info_t *obj , loc_t loc ) ;
#line 79 "/home/june/repo/benchmarks/collector/temp/empire-1.11/attack.c"
void attack_obj(piece_info_t *att_obj , loc_t loc ) 
{ 
  piece_info_t *def_obj ;
  int owner ;
  long tmp ;
  view_map_t *tmp___0 ;

  {
  {
#line 87
  def_obj = find_obj_at_loc(loc);
  }
#line 88
  if (! ((unsigned long )def_obj != (unsigned long )((piece_info_t *)0))) {
    {
#line 88
    assert((char *)"x", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/attack.c",
           88);
    }
  }
#line 90
  if (def_obj->type == 8) {
#line 90
    return;
  }
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if ((int )att_obj->hits > 0) {
#line 92
      if (! ((int )def_obj->hits > 0)) {
#line 92
        goto while_break;
      }
    } else {
#line 92
      goto while_break;
    }
    {
#line 93
    tmp = irand(2L);
    }
#line 93
    if (tmp == 0L) {
#line 94
      att_obj->hits = (short )((int )att_obj->hits - (int )piece_attr[def_obj->type].strength);
    } else {
#line 95
      def_obj->hits = (short )((int )def_obj->hits - (int )piece_attr[att_obj->type].strength);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  if ((int )att_obj->hits > 0) {
    {
#line 99
    describe(att_obj, def_obj, loc);
#line 100
    owner = def_obj->owner;
#line 101
    kill_obj(def_obj, loc);
#line 102
    survive(att_obj, loc);
    }
  } else {
    {
#line 105
    describe(def_obj, att_obj, loc);
#line 106
    owner = att_obj->owner;
#line 107
    kill_obj(att_obj, loc);
#line 108
    survive(def_obj, loc);
    }
  }
#line 111
  if (owner == 1) {
#line 111
    tmp___0 = user_map;
  } else {
#line 111
    tmp___0 = comp_map;
  }
  {
#line 111
  scan(tmp___0, loc);
  }
#line 112
  return;
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/empire-1.11/attack.c"
void attack(piece_info_t *att_obj , long loc ) 
{ 


  {
#line 117
  if ((int )map[loc].contents == 42) {
    {
#line 118
    attack_city(att_obj, loc);
    }
  } else {
    {
#line 119
    attack_obj(att_obj, loc);
    }
  }
#line 120
  return;
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/empire-1.11/attack.c"
void survive(piece_info_t *obj , loc_t loc ) 
{ 
  int tmp ;

  {
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 132
    tmp = obj_capacity(obj);
    }
#line 132
    if (! (tmp < (int )obj->count)) {
#line 132
      goto while_break;
    }
    {
#line 133
    kill_obj(obj->cargo, loc);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 135
  move_obj(obj, loc);
  }
#line 136
  return;
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/empire-1.11/attack.c"
void describe(piece_info_t *win_obj , piece_info_t *lose_obj , loc_t loc ) 
{ 
  char buf[80] ;
  char buf2[80] ;
  int diff ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 144
  buf[0] = (char )'\000';
#line 145
  buf2[0] = (char )'\000';
#line 147
  if (win_obj->owner != lose_obj->owner) {
#line 148
    if (win_obj->owner == 1) {
      {
#line 150
      user_score += (int )piece_attr[lose_obj->type].build_time;
#line 151
      tmp = loc_disp((int )loc);
#line 151
      ksend((char *)"Enemy %s at %d destroyed.\n", piece_attr[lose_obj->type].name,
            tmp);
#line 152
      tmp___0 = loc_disp((int )loc);
#line 152
      topmsg(1, (char *)"Enemy %s at %d destroyed.", piece_attr[lose_obj->type].name,
             tmp___0);
#line 153
      ksend((char *)"Your %s has %d hits left\n", piece_attr[win_obj->type].name,
            (int )win_obj->hits);
#line 154
      topmsg(2, (char *)"Your %s has %d hits left.", piece_attr[win_obj->type].name,
             (int )win_obj->hits);
#line 156
      tmp___1 = obj_capacity(win_obj);
#line 156
      diff = (int )win_obj->count - tmp___1;
      }
#line 157
      if (diff > 0) {
        {
#line 158
        if ((win_obj->cargo)->type == 0) {
#line 158
          goto case_0;
        }
#line 162
        if ((win_obj->cargo)->type == 1) {
#line 162
          goto case_1;
        }
#line 157
        goto switch_break;
        case_0: /* CIL Label */ 
        {
#line 159
        ksend((char *)"%d armies fell overboard and drowned in the assault.\n", diff);
#line 160
        topmsg(3, (char *)"%d armies fell overboard and drowned in the assault.",
               diff);
        }
#line 161
        goto switch_break;
        case_1: /* CIL Label */ 
        {
#line 163
        ksend((char *)"%d fighters fell overboard and were lost in the assult.\n",
              diff);
#line 164
        topmsg(3, (char *)"%d fighters fell overboard and were lost in the assault.",
               diff);
        }
#line 165
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    } else {
      {
#line 169
      comp_score += (int )piece_attr[lose_obj->type].build_time;
#line 170
      tmp___2 = loc_disp((int )loc);
#line 170
      ksend((char *)"Your %s at %d destroyed.\n", piece_attr[lose_obj->type].name,
            tmp___2);
#line 171
      tmp___3 = loc_disp((int )loc);
#line 171
      topmsg(3, (char *)"Your %s at %d destroyed.", piece_attr[lose_obj->type].name,
             tmp___3);
      }
    }
    {
#line 173
    set_need_delay();
    }
  }
#line 175
  return;
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 608 "/usr/include/curses.h"
extern int echo(void) ;
#line 709
extern int nocbreak(void) ;
#line 810
extern int wgetch(WINDOW * ) ;
#line 811
extern int wgetnstr(WINDOW * , char * , int  ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 172 "/home/june/repo/benchmarks/collector/temp/empire-1.11/extern.h"
void get_str(char *buf , int sizep ) ;
#line 173
void get_strq(char *buf , int sizep ) ;
#line 175
int getint(char *message ) ;
#line 176
char get_c(void) ;
#line 177
char get_cq(void) ;
#line 178
_Bool getyn(char *message ) ;
#line 179
int get_range(char *message , int low , int high ) ;
#line 208
void pdebug(char *fmt  , ...) ;
#line 209
void topini(void) ;
#line 214
void info(char *a , char *b , char *c ) ;
#line 217
void huh(void) ;
#line 218
void help(char **text , int nlines ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/empire-1.11/term.c"
static _Bool need_delay  ;
#line 41 "/home/june/repo/benchmarks/collector/temp/empire-1.11/term.c"
static FILE *my_stream  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/empire-1.11/term.c"
void topini(void) 
{ 


  {
  {
#line 52
  info((char *)0, (char *)0, (char *)0);
  }
#line 53
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/empire-1.11/term.c"
static void vtopmsg(int line , char const   *fmt , va_list varglist ) 
{ 
  char junkbuf[80] ;

  {
#line 63
  if (line < 1) {
#line 64
    line = 1;
  } else
#line 63
  if (line > 3) {
#line 64
    line = 1;
  }
  {
#line 65
  wmove(stdscr, line - 1, 0);
#line 66
  vsprintf((char */* __restrict  */)(junkbuf), (char const   */* __restrict  */)fmt,
           varglist);
#line 67
  waddnstr(stdscr, (char const   *)(junkbuf), -1);
#line 68
  wclrtoeol(stdscr);
  }
#line 69
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/empire-1.11/term.c"
void topmsg(int line , char *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 76
  __builtin_va_start(ap, fmt);
#line 77
  vtopmsg(line, (char const   *)fmt, ap);
#line 78
  __builtin_va_end(ap);
  }
#line 79
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/empire-1.11/term.c"
void prompt(char *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 90
  __builtin_va_start(ap, fmt);
#line 91
  vtopmsg(1, (char const   *)fmt, ap);
#line 92
  __builtin_va_end(ap);
  }
#line 93
  return;
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/empire-1.11/term.c"
void error(char *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 104
  __builtin_va_start(ap, fmt);
#line 105
  vtopmsg(2, (char const   *)fmt, ap);
#line 106
  __builtin_va_end(ap);
  }
#line 107
  return;
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/empire-1.11/term.c"
void extra(char *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 118
  __builtin_va_start(ap, fmt);
#line 119
  vtopmsg(3, (char const   *)fmt, ap);
#line 120
  __builtin_va_end(ap);
  }
#line 121
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/empire-1.11/term.c"
void huh(void) 
{ 


  {
  {
#line 131
  error((char *)"Type H for Help.");
  }
#line 132
  return;
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/empire-1.11/term.c"
void info(char *a , char *b , char *c ) 
{ 
  int tmp ;

  {
#line 143
  if (need_delay) {
    {
#line 143
    delay();
    }
  }
  {
#line 144
  topmsg(1, a);
#line 145
  topmsg(2, b);
#line 146
  topmsg(3, c);
  }
#line 147
  if (a) {
#line 147
    tmp = 1;
  } else
#line 147
  if (b) {
#line 147
    tmp = 1;
  } else
#line 147
  if (c) {
#line 147
    tmp = 1;
  } else {
#line 147
    tmp = 0;
  }
#line 147
  need_delay = (_Bool )tmp;
#line 148
  return;
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/empire-1.11/term.c"
void set_need_delay(void) 
{ 


  {
#line 153
  need_delay = (_Bool)1;
#line 154
  return;
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/empire-1.11/term.c"
void comment(char *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 161
  __builtin_va_start(ap, fmt);
  }
#line 162
  if (need_delay) {
    {
#line 163
    delay();
    }
  }
  {
#line 164
  topmsg(1, (char *)"");
#line 165
  topmsg(2, (char *)"");
#line 166
  vtopmsg(3, (char const   *)fmt, ap);
#line 167
  need_delay = (_Bool )((unsigned long )fmt != (unsigned long )((char *)0));
#line 168
  __builtin_va_end(ap);
  }
#line 169
  return;
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/empire-1.11/term.c"
void pdebug(char *fmt  , ...) 
{ 
  va_list ap ;

  {
#line 176
  if (! print_debug) {
#line 176
    return;
  }
  {
#line 178
  __builtin_va_start(ap, fmt);
  }
#line 179
  if (need_delay) {
    {
#line 180
    delay();
    }
  }
  {
#line 181
  topmsg(1, (char *)"");
#line 182
  topmsg(2, (char *)"");
#line 183
  vtopmsg(3, (char const   *)fmt, ap);
#line 184
  need_delay = (_Bool )((unsigned long )fmt != (unsigned long )((char *)0));
#line 185
  __builtin_va_end(ap);
  }
#line 186
  return;
}
}
#line 190 "/home/june/repo/benchmarks/collector/temp/empire-1.11/term.c"
void vksend(char const   *fmt , va_list varglist ) 
{ 


  {
  {
#line 193
  my_stream = fopen((char const   */* __restrict  */)"info_list.txt", (char const   */* __restrict  */)"a");
  }
#line 193
  if (! my_stream) {
    {
#line 195
    error((char *)"Cannot open info_list.txt");
    }
#line 196
    return;
  }
  {
#line 198
  vfprintf((FILE */* __restrict  */)my_stream, (char const   */* __restrict  */)fmt,
           varglist);
#line 199
  fclose(my_stream);
  }
#line 200
  return;
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/empire-1.11/term.c"
void ksend(char *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 208
  __builtin_va_start(ap, fmt);
#line 209
  vksend((char const   *)fmt, ap);
#line 210
  __builtin_va_end(ap);
  }
#line 211
  return;
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/empire-1.11/term.c"
void get_str(char *buf , int sizep ) 
{ 


  {
  {
#line 221
  echo();
#line 222
  get_strq(buf, sizep);
#line 223
  noecho();
  }
#line 224
  return;
}
}
#line 230 "/home/june/repo/benchmarks/collector/temp/empire-1.11/term.c"
void get_strq(char *buf , int sizep ) 
{ 


  {
  {
#line 233
  nocbreak();
#line 234
  wrefresh(stdscr);
#line 235
  wgetnstr(stdscr, buf, sizep);
#line 236
  need_delay = (_Bool)0;
#line 237
  info((char *)0, (char *)0, (char *)0);
#line 238
  cbreak();
  }
#line 239
  return;
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/empire-1.11/term.c"
char get_chx(void) 
{ 
  char c ;
  int tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 250
  c = get_cq();
#line 252
  tmp___0 = __ctype_b_loc();
  }
#line 252
  if ((int const   )*(*tmp___0 + (int )c) & 512) {
    {
#line 253
    tmp = toupper((int )c);
    }
#line 253
    return ((char )tmp);
  } else {
#line 255
    return (c);
  }
}
}
#line 262 "/home/june/repo/benchmarks/collector/temp/empire-1.11/term.c"
int getint(char *message ) 
{ 
  char buf[80] ;
  char *p ;
  int tmp ;

  {
  {
#line 268
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 269
    prompt(message, 0, 0, 0, 0, 0, 0, 0, 0);
#line 270
    get_str(buf, (int )sizeof(buf));
#line 272
    p = buf;
    }
    {
#line 272
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 272
      if (! *p) {
#line 272
        goto while_break___0;
      }
#line 273
      if ((int )*p < 48) {
        {
#line 274
        error((char *)"Please enter an integer.", 0, 0, 0, 0, 0, 0, 0, 0);
        }
#line 275
        goto while_break___0;
      } else
#line 273
      if ((int )*p > 57) {
        {
#line 274
        error((char *)"Please enter an integer.", 0, 0, 0, 0, 0, 0, 0, 0);
        }
#line 275
        goto while_break___0;
      }
#line 272
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 278
    if ((int )*p == 0) {
#line 279
      if (p - buf > 7L) {
        {
#line 280
        error((char *)"Please enter a small integer.", 0, 0, 0, 0, 0, 0, 0, 0);
        }
      } else {
        {
#line 281
        tmp = atoi((char const   *)(buf));
        }
#line 281
        return (tmp);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 290 "/home/june/repo/benchmarks/collector/temp/empire-1.11/term.c"
char get_c(void) 
{ 
  char c ;

  {
  {
#line 295
  echo();
#line 296
  c = get_cq();
#line 297
  noecho();
  }
#line 298
  return (c);
}
}
#line 305 "/home/june/repo/benchmarks/collector/temp/empire-1.11/term.c"
char get_cq(void) 
{ 
  char c ;
  int tmp ;

  {
  {
#line 310
  cbreak();
#line 311
  wrefresh(stdscr);
#line 312
  tmp = wgetch(stdscr);
#line 312
  c = (char )tmp;
#line 313
  topini();
#line 314
  nocbreak();
  }
#line 315
  return (c);
}
}
#line 323 "/home/june/repo/benchmarks/collector/temp/empire-1.11/term.c"
_Bool getyn(char *message ) 
{ 
  char c ;

  {
  {
#line 328
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 329
    prompt(message, 0, 0, 0, 0, 0, 0, 0, 0);
#line 330
    c = get_chx();
    }
#line 332
    if ((int )c == 89) {
#line 332
      return ((_Bool)1);
    }
#line 333
    if ((int )c == 78) {
#line 333
      return ((_Bool)0);
    }
    {
#line 335
    error((char *)"Please answer Y or N.", 0, 0, 0, 0, 0, 0, 0, 0);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 343 "/home/june/repo/benchmarks/collector/temp/empire-1.11/term.c"
int get_range(char *message , int low , int high ) 
{ 
  int result ;

  {
  {
#line 348
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 349
    result = getint(message);
    }
#line 351
    if (result >= low) {
#line 351
      if (result <= high) {
#line 351
        return (result);
      }
    }
    {
#line 353
    error((char *)"Please enter an integer in the range %d..%d.", low, high);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 361 "/home/june/repo/benchmarks/collector/temp/empire-1.11/term.c"
void help(char **text , int nlines ) 
{ 
  int i ;
  int r ;
  int c ;
  int text_lines ;
  int tmp ;

  {
  {
#line 367
  text_lines = (nlines + 1) / 2;
#line 369
  clear_screen();
#line 371
  pos_str(3, 1, *(text + 0));
#line 372
  pos_str(3, 41, (char *)"See empire(6) for more information.");
#line 374
  i = 1;
  }
  {
#line 374
  while (1) {
    while_continue: /* CIL Label */ ;
#line 374
    if (! (i < nlines)) {
#line 374
      goto while_break;
    }
#line 375
    if (i > text_lines) {
      {
#line 376
      pos_str(((i - text_lines) + 3) + 1, 41, *(text + i));
      }
    } else {
      {
#line 377
      pos_str((i + 3) + 1, 1, *(text + i));
      }
    }
#line 374
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 380
  pos_str((text_lines + 3) + 2, 1, (char *)"--Piece---Yours-Enemy-Moves-Hits-Cost");
#line 381
  pos_str((text_lines + 3) + 2, 41, (char *)"--Piece---Yours-Enemy-Moves-Hits-Cost");
#line 383
  i = 0;
  }
  {
#line 383
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 383
    if (! (i < 9)) {
#line 383
      goto while_break___0;
    }
#line 384
    if (i >= 5) {
#line 385
      r = i - 5;
#line 386
      c = 41;
    } else {
#line 389
      r = i;
#line 390
      c = 1;
    }
    {
#line 392
    tmp = tolower((int )piece_attr[i].sname);
#line 392
    pos_str(((r + text_lines) + 3) + 3, c, (char *)"%-12s%c     %c%6d%5d%6d", piece_attr[i].nickname,
            (int )piece_attr[i].sname, tmp, (int )piece_attr[i].speed, (int )piece_attr[i].max_hits,
            (int )piece_attr[i].build_time, 0, 0);
#line 383
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 401
  wrefresh(stdscr);
  }
#line 402
  return;
}
}
#line 406 "/home/june/repo/benchmarks/collector/temp/empire-1.11/term.c"
int loc_disp(int loc ) 
{ 
  int row ;
  int nrow ;
  int col ;
  int i ;

  {
#line 409
  row = loc / 100;
#line 410
  nrow = row;
#line 411
  col = loc % 100;
#line 412
  if (! (loc == row * 100 + col)) {
    {
#line 412
    assert((char *)"x", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/term.c",
           412);
    }
  }
#line 414
  i = 2;
  {
#line 414
  while (1) {
    while_continue: /* CIL Label */ ;
#line 414
    if (! (i > 0)) {
#line 414
      goto while_break;
    }
#line 415
    nrow *= 10;
#line 414
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 416
  wmove(stdscr, LINES - 1, 0);
  }
#line 417
  return (nrow + col);
}
}
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 136 "/home/june/repo/benchmarks/collector/temp/empire-1.11/extern.h"
_Bool rmap_shore(long loc ) ;
#line 166
void init_game(void) ;
#line 167
void save_game(void) ;
#line 168
int restore_game(void) ;
#line 169
void save_movie_screen(void) ;
#line 170
void replay_movie(void) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/empire-1.11/game.c"
count_t remove_land(loc_t loc , count_t num_land ) ;
#line 20
_Bool select_cities(void) ;
#line 21
_Bool find_next(loc_t *mapi ) ;
#line 22
_Bool good_cont(loc_t mapi ) ;
#line 23
_Bool xread(FILE *f , char *buf , int size ) ;
#line 24
_Bool xwrite(FILE *f , char *buf , int size ) ;
#line 25
void stat_display(char *mbuf , int round ) ;
#line 35
void make_map(void) ;
#line 35
void place_cities(void) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/empire-1.11/game.c"
void init_game(void) 
{ 
  count_t i ;
  piece_info_t *obj ;
  _Bool tmp ;

  {
  {
#line 39
  kill_display();
#line 40
  automove = (_Bool)0;
#line 41
  resigned = (_Bool)0;
#line 42
  debug = (_Bool)0;
#line 43
  print_debug = (_Bool)0;
#line 44
  print_vmap = (_Bool)0;
#line 45
  trace_pmap = (_Bool)0;
#line 46
  save_movie = (_Bool)0;
#line 47
  win = 0;
#line 48
  date = 0L;
#line 49
  user_score = 0;
#line 50
  comp_score = 0;
#line 52
  i = (count_t )0;
  }
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    if (! (i < 6000L)) {
#line 52
      goto while_break;
    }
#line 53
    user_map[i].contents = (char )' ';
#line 54
    user_map[i].seen = 0L;
#line 55
    comp_map[i].contents = (char )' ';
#line 56
    comp_map[i].seen = 0L;
#line 52
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 58
  i = (count_t )0;
  {
#line 58
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 58
    if (! (i < 9L)) {
#line 58
      goto while_break___0;
    }
#line 59
    user_obj[i] = (piece_info_t *)((void *)0);
#line 60
    comp_obj[i] = (piece_info_t *)((void *)0);
#line 58
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 62
  free_list = (piece_info_t *)((void *)0);
#line 63
  i = (count_t )0;
  {
#line 63
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 63
    if (! (i < 5000L)) {
#line 63
      goto while_break___1;
    }
#line 64
    obj = & object[i];
#line 65
    obj->hits = (short)0;
#line 66
    obj->owner = 0;
#line 67
    obj->piece_link.prev = (struct piece_info *)((void *)0);
#line 67
    obj->piece_link.next = free_list;
#line 67
    if (free_list) {
#line 67
      free_list->piece_link.prev = obj;
    }
#line 67
    free_list = obj;
#line 63
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 70
  make_map();
  }
  {
#line 72
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 73
    i = (count_t )0;
    {
#line 73
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 73
      if (! (i < 6000L)) {
#line 73
        goto while_break___3;
      }
#line 74
      if ((int )map[i].contents == 42) {
#line 75
        map[i].contents = (char )'+';
      }
#line 73
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 77
    place_cities();
#line 72
    tmp = select_cities();
    }
#line 72
    if (tmp) {
#line 72
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 80
  return;
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/empire-1.11/game.c"
static int height[2][6000]  ;
#line 98 "/home/june/repo/benchmarks/collector/temp/empire-1.11/game.c"
static int height_count[1000]  ;
#line 100 "/home/june/repo/benchmarks/collector/temp/empire-1.11/game.c"
void make_map(void) 
{ 
  int from ;
  int to ;
  int k ;
  count_t i ;
  count_t j ;
  count_t sum ;
  loc_t loc ;
  long tmp ;
  int tmp___0 ;

  {
#line 106
  i = (count_t )0;
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if (! (i < 6000L)) {
#line 106
      goto while_break;
    }
    {
#line 107
    tmp = irand(999L);
#line 107
    height[0][i] = (int )tmp;
#line 106
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 109
  from = 0;
#line 110
  to = 1;
#line 111
  i = (count_t )0;
  {
#line 111
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 111
    if (! (i < (count_t )SMOOTH)) {
#line 111
      goto while_break___0;
    }
#line 112
    j = (count_t )0;
    {
#line 112
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 112
      if (! (j < 6000L)) {
#line 112
        goto while_break___1;
      }
#line 113
      sum = (count_t )height[from][j];
#line 114
      k = 0;
      {
#line 114
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 114
        if (! (k < 8)) {
#line 114
          goto while_break___2;
        }
#line 115
        loc = j + (count_t )dir_offset[k];
#line 117
        if (loc < 0L) {
#line 117
          loc = j;
        } else
#line 117
        if (loc >= 6000L) {
#line 117
          loc = j;
        }
#line 118
        sum += (count_t )height[from][loc];
#line 114
        k ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 120
      height[to][j] = (int )(sum / 9L);
#line 112
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 122
    k = to;
#line 123
    to = from;
#line 124
    from = k;
#line 111
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 128
  i = (count_t )0;
  {
#line 128
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 128
    if (! (i <= 999L)) {
#line 128
      goto while_break___3;
    }
#line 129
    height_count[i] = 0;
#line 128
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 131
  i = (count_t )0;
  {
#line 131
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 131
    if (! (i <= 6000L)) {
#line 131
      goto while_break___4;
    }
#line 132
    (height_count[height[from][i]]) ++;
#line 131
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 135
  loc = (loc_t )999;
#line 136
  sum = (count_t )0;
#line 137
  i = (count_t )0;
  {
#line 137
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 137
    if (! (i <= 999L)) {
#line 137
      goto while_break___5;
    }
#line 138
    sum += (count_t )height_count[i];
#line 139
    if ((sum * 100L) / 6000L > (count_t )WATER_RATIO) {
#line 139
      if (sum >= 70L) {
#line 140
        loc = i;
#line 141
        goto while_break___5;
      }
    }
#line 137
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 146
  i = (count_t )0;
  {
#line 146
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 146
    if (! (i < 6000L)) {
#line 146
      goto while_break___6;
    }
#line 147
    if ((loc_t )height[from][i] > loc) {
#line 148
      map[i].contents = (char )'+';
    } else {
#line 149
      map[i].contents = (char )'.';
    }
#line 151
    map[i].objp = (piece_info_t *)((void *)0);
#line 152
    map[i].cityp = (city_info_t *)((void *)0);
#line 154
    j = i % 100L;
#line 155
    k = (int )(i / 100L);
#line 157
    if (j == 0L) {
#line 157
      tmp___0 = 0;
    } else
#line 157
    if (j == 99L) {
#line 157
      tmp___0 = 0;
    } else
#line 157
    if (k == 0) {
#line 157
      tmp___0 = 0;
    } else
#line 157
    if (k == 59) {
#line 157
      tmp___0 = 0;
    } else {
#line 157
      tmp___0 = 1;
    }
#line 157
    map[i].on_board = (_Bool )tmp___0;
#line 146
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 160
  return;
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/empire-1.11/game.c"
static loc_t land[6000]  ;
#line 175
count_t regen_land(count_t placed ) ;
#line 173 "/home/june/repo/benchmarks/collector/temp/empire-1.11/game.c"
void place_cities(void) 
{ 
  count_t placed ;
  count_t i ;
  loc_t loc ;
  count_t num_land ;

  {
#line 181
  num_land = (count_t )0;
#line 182
  placed = (count_t )0;
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 183
    if (! (placed < 70L)) {
#line 183
      goto while_break;
    }
    {
#line 184
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 184
      if (! (num_land == 0L)) {
#line 184
        goto while_break___0;
      }
      {
#line 184
      num_land = regen_land(placed);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 185
    i = irand(num_land - 1L);
#line 186
    loc = land[i];
#line 188
    city[placed].loc = loc;
#line 189
    city[placed].owner = (uchar )0;
#line 190
    city[placed].work = 0L;
#line 191
    city[placed].prod = (char)-1;
#line 193
    i = (count_t )0;
    }
    {
#line 193
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 193
      if (! (i < 9L)) {
#line 193
        goto while_break___1;
      }
#line 194
      city[placed].func[i] = -1L;
#line 193
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 196
    map[loc].contents = (char )'*';
#line 197
    map[loc].cityp = & city[placed];
#line 198
    placed ++;
#line 201
    num_land = remove_land(loc, num_land);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 203
  return;
}
}
#line 211 "/home/june/repo/benchmarks/collector/temp/empire-1.11/game.c"
count_t regen_land(count_t placed ) 
{ 
  count_t num_land ;
  count_t i ;

  {
#line 216
  num_land = (count_t )0;
#line 217
  i = (count_t )0;
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
#line 217
    if (! (i < 6000L)) {
#line 217
      goto while_break;
    }
#line 218
    if (map[i].on_board) {
#line 218
      if ((int )map[i].contents == 43) {
#line 219
        land[num_land] = i;
#line 220
        num_land ++;
      }
    }
#line 217
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  if (placed > 0L) {
#line 224
    MIN_CITY_DIST --;
#line 225
    if (! (MIN_CITY_DIST >= 0)) {
      {
#line 225
      assert((char *)"x", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/game.c",
             225);
      }
    }
  }
#line 227
  i = (count_t )0;
  {
#line 227
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 227
    if (! (i < placed)) {
#line 227
      goto while_break___0;
    }
    {
#line 228
    num_land = remove_land(city[i].loc, num_land);
#line 227
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 230
  return (num_land);
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/empire-1.11/game.c"
count_t remove_land(loc_t loc , count_t num_land ) 
{ 
  count_t new ;
  count_t i ;
  int tmp ;

  {
#line 241
  new = (count_t )0;
#line 242
  i = (count_t )0;
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 242
    if (! (i < num_land)) {
#line 242
      goto while_break;
    }
    {
#line 243
    tmp = dist(loc, land[i]);
    }
#line 243
    if (tmp >= MIN_CITY_DIST) {
#line 244
      land[new] = land[i];
#line 245
      new ++;
    }
#line 242
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 248
  return (new);
}
}
#line 295 "/home/june/repo/benchmarks/collector/temp/empire-1.11/game.c"
static int marked[6000]  ;
#line 296 "/home/june/repo/benchmarks/collector/temp/empire-1.11/game.c"
static int ncont  ;
#line 297 "/home/june/repo/benchmarks/collector/temp/empire-1.11/game.c"
static cont_t cont_tab[10]  ;
#line 298 "/home/june/repo/benchmarks/collector/temp/empire-1.11/game.c"
static int rank_tab[10]  ;
#line 299 "/home/june/repo/benchmarks/collector/temp/empire-1.11/game.c"
static pair_t pair_tab[100]  ;
#line 303
void find_cont(void) ;
#line 303
void make_pair(void) ;
#line 301 "/home/june/repo/benchmarks/collector/temp/empire-1.11/game.c"
_Bool select_cities(void) 
{ 
  loc_t compi ;
  loc_t useri ;
  city_info_t *compp ;
  city_info_t *userp ;
  int comp_cont ;
  int user_cont ;
  int pair ;
  int tmp ;

  {
  {
#line 310
  find_cont();
  }
#line 311
  if (ncont == 0) {
#line 311
    return ((_Bool)0);
  }
  {
#line 313
  make_pair();
#line 315
  sprintf((char */* __restrict  */)(jnkbuf), (char const   */* __restrict  */)"Choose a difficulty level where 0 is easy and %d is hard: ",
          ncont * ncont - 1);
#line 319
  pair = get_range(jnkbuf, 0, ncont * ncont - 1);
#line 320
  comp_cont = pair_tab[pair].comp_cont;
#line 321
  user_cont = pair_tab[pair].user_cont;
#line 323
  compi = irand((long )cont_tab[comp_cont].ncity);
#line 324
  compp = cont_tab[comp_cont].cityp[compi];
  }
  {
#line 326
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 327
    useri = irand((long )cont_tab[user_cont].ncity);
#line 328
    userp = cont_tab[user_cont].cityp[useri];
    }
#line 326
    if (! ((unsigned long )userp == (unsigned long )compp)) {
#line 326
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 331
  tmp = loc_disp((int )userp->loc);
#line 331
  topmsg(1, (char *)"Your city is at %d.", tmp);
#line 332
  delay();
#line 335
  compp->owner = (uchar )2;
#line 336
  compp->prod = (char)0;
#line 337
  compp->work = 0L;
#line 338
  scan(comp_map, compp->loc);
#line 340
  userp->owner = (uchar )1;
#line 341
  userp->work = 0L;
#line 342
  scan(user_map, userp->loc);
#line 343
  set_prod(userp);
  }
#line 344
  return ((_Bool)1);
}
}
#line 352 "/home/june/repo/benchmarks/collector/temp/empire-1.11/game.c"
void find_cont(void) 
{ 
  loc_t i ;
  loc_t mapi ;
  _Bool tmp ;

  {
#line 357
  i = (loc_t )0;
  {
#line 357
  while (1) {
    while_continue: /* CIL Label */ ;
#line 357
    if (! (i < 6000L)) {
#line 357
      goto while_break;
    }
#line 357
    marked[i] = 0;
#line 357
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 359
  ncont = 0;
#line 360
  mapi = (loc_t )0;
  {
#line 362
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 362
    if (! (ncont < 10)) {
#line 362
      goto while_break___0;
    }
    {
#line 363
    tmp = find_next(& mapi);
    }
#line 363
    if (! tmp) {
#line 364
      return;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 365
  return;
}
}
#line 372 "/home/june/repo/benchmarks/collector/temp/empire-1.11/game.c"
_Bool find_next(loc_t *mapi ) 
{ 
  count_t i ;
  long val ;
  _Bool tmp ;

  {
  {
#line 377
  while (1) {
    while_continue: /* CIL Label */ ;
#line 378
    if (*mapi >= 6000L) {
#line 378
      return ((_Bool)0);
    }
#line 380
    if (! map[*mapi].on_board) {
#line 382
      (*mapi) ++;
    } else
#line 380
    if (marked[*mapi]) {
#line 382
      (*mapi) ++;
    } else
#line 380
    if ((int )map[*mapi].contents == 46) {
#line 382
      (*mapi) ++;
    } else {
      {
#line 383
      tmp = good_cont(*mapi);
      }
#line 383
      if (tmp) {
#line 384
        rank_tab[ncont] = ncont;
#line 385
        val = cont_tab[ncont].value;
#line 387
        i = (count_t )ncont;
        {
#line 387
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 387
          if (! (i > 0L)) {
#line 387
            goto while_break___0;
          }
#line 388
          if (val > cont_tab[rank_tab[i - 1L]].value) {
#line 389
            rank_tab[i] = rank_tab[i - 1L];
#line 390
            rank_tab[i - 1L] = ncont;
          } else {
#line 392
            goto while_break___0;
          }
#line 387
          i --;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 394
        ncont ++;
#line 395
        return ((_Bool)1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 407 "/home/june/repo/benchmarks/collector/temp/empire-1.11/game.c"
static count_t ncity  ;
#line 407 "/home/june/repo/benchmarks/collector/temp/empire-1.11/game.c"
static count_t nland  ;
#line 407 "/home/june/repo/benchmarks/collector/temp/empire-1.11/game.c"
static count_t nshore  ;
#line 408
static void mark_cont(loc_t mapi ) ;
#line 410 "/home/june/repo/benchmarks/collector/temp/empire-1.11/game.c"
_Bool good_cont(loc_t mapi ) 
{ 
  long val ;

  {
  {
#line 414
  ncity = (count_t )0;
#line 415
  nland = (count_t )0;
#line 416
  nshore = (count_t )0;
#line 418
  mark_cont(mapi);
  }
#line 420
  if (nshore < 1L) {
#line 420
    return ((_Bool)0);
  } else
#line 420
  if (ncity < 2L) {
#line 420
    return ((_Bool)0);
  }
#line 427
  if (ncity == nshore) {
#line 427
    val = (nshore - 2L) * 3L;
  } else {
#line 428
    val = (nshore - 1L) * 3L + ((ncity - nshore) - 1L) * 2L;
  }
#line 430
  val *= 1000L;
#line 431
  val += nland;
#line 432
  cont_tab[ncont].value = val;
#line 433
  cont_tab[ncont].ncity = (int )ncity;
#line 434
  return ((_Bool)1);
}
}
#line 444 "/home/june/repo/benchmarks/collector/temp/empire-1.11/game.c"
static void mark_cont(loc_t mapi ) 
{ 
  int i ;
  _Bool tmp ;

  {
#line 449
  if (marked[mapi]) {
#line 452
    return;
  } else
#line 449
  if ((int )map[mapi].contents == 46) {
#line 452
    return;
  } else
#line 449
  if (! map[mapi].on_board) {
#line 452
    return;
  }
#line 454
  marked[mapi] = 1;
#line 455
  nland ++;
#line 457
  if ((int )map[mapi].contents == 42) {
    {
#line 458
    cont_tab[ncont].cityp[ncity] = map[mapi].cityp;
#line 459
    ncity ++;
#line 460
    tmp = rmap_shore(mapi);
    }
#line 460
    if (tmp) {
#line 460
      nshore ++;
    }
  }
#line 463
  i = 0;
  {
#line 463
  while (1) {
    while_continue: /* CIL Label */ ;
#line 463
    if (! (i < 8)) {
#line 463
      goto while_break;
    }
    {
#line 464
    mark_cont(mapi + (loc_t )dir_offset[i]);
#line 463
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 465
  return;
}
}
#line 474 "/home/june/repo/benchmarks/collector/temp/empire-1.11/game.c"
void make_pair(void) 
{ 
  int i ;
  int j ;
  int k ;
  int npair ;
  long val ;

  {
#line 479
  npair = 0;
#line 481
  i = 0;
  {
#line 481
  while (1) {
    while_continue: /* CIL Label */ ;
#line 481
    if (! (i < ncont)) {
#line 481
      goto while_break;
    }
#line 482
    j = 0;
    {
#line 482
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 482
      if (! (j < ncont)) {
#line 482
        goto while_break___0;
      }
#line 483
      val = cont_tab[i].value - cont_tab[j].value;
#line 484
      pair_tab[npair].value = val;
#line 485
      pair_tab[npair].user_cont = i;
#line 486
      pair_tab[npair].comp_cont = j;
#line 488
      k = npair;
      {
#line 488
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 488
        if (! (k > 0)) {
#line 488
          goto while_break___1;
        }
#line 489
        if (val > pair_tab[k - 1].value) {
#line 490
          pair_tab[k] = pair_tab[k - 1];
#line 491
          pair_tab[k - 1].user_cont = i;
#line 492
          pair_tab[k - 1].comp_cont = j;
        } else {
#line 494
          goto while_break___1;
        }
#line 488
        k --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 496
      npair ++;
#line 482
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 481
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 498
  return;
}
}
#line 510 "/home/june/repo/benchmarks/collector/temp/empire-1.11/game.c"
void save_game(void) 
{ 
  FILE *f ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;
  _Bool tmp___10 ;
  _Bool tmp___11 ;
  _Bool tmp___12 ;
  _Bool tmp___13 ;
  _Bool tmp___14 ;

  {
  {
#line 514
  f = fopen((char const   */* __restrict  */)savefile, (char const   */* __restrict  */)"w");
  }
#line 515
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 516
    perror("Cannot save saved game");
    }
#line 517
    return;
  }
  {
#line 519
  tmp = xwrite(f, (char *)(map), (int )sizeof(map));
  }
#line 519
  if (! tmp) {
#line 519
    return;
  }
  {
#line 520
  tmp___0 = xwrite(f, (char *)(comp_map), (int )sizeof(comp_map));
  }
#line 520
  if (! tmp___0) {
#line 520
    return;
  }
  {
#line 521
  tmp___1 = xwrite(f, (char *)(user_map), (int )sizeof(user_map));
  }
#line 521
  if (! tmp___1) {
#line 521
    return;
  }
  {
#line 522
  tmp___2 = xwrite(f, (char *)(city), (int )sizeof(city));
  }
#line 522
  if (! tmp___2) {
#line 522
    return;
  }
  {
#line 523
  tmp___3 = xwrite(f, (char *)(object), (int )sizeof(object));
  }
#line 523
  if (! tmp___3) {
#line 523
    return;
  }
  {
#line 524
  tmp___4 = xwrite(f, (char *)(user_obj), (int )sizeof(user_obj));
  }
#line 524
  if (! tmp___4) {
#line 524
    return;
  }
  {
#line 525
  tmp___5 = xwrite(f, (char *)(comp_obj), (int )sizeof(comp_obj));
  }
#line 525
  if (! tmp___5) {
#line 525
    return;
  }
  {
#line 526
  tmp___6 = xwrite(f, (char *)(& free_list), (int )sizeof(free_list));
  }
#line 526
  if (! tmp___6) {
#line 526
    return;
  }
  {
#line 527
  tmp___7 = xwrite(f, (char *)(& date), (int )sizeof(date));
  }
#line 527
  if (! tmp___7) {
#line 527
    return;
  }
  {
#line 528
  tmp___8 = xwrite(f, (char *)(& automove), (int )sizeof(automove));
  }
#line 528
  if (! tmp___8) {
#line 528
    return;
  }
  {
#line 529
  tmp___9 = xwrite(f, (char *)(& resigned), (int )sizeof(resigned));
  }
#line 529
  if (! tmp___9) {
#line 529
    return;
  }
  {
#line 530
  tmp___10 = xwrite(f, (char *)(& debug), (int )sizeof(debug));
  }
#line 530
  if (! tmp___10) {
#line 530
    return;
  }
  {
#line 531
  tmp___11 = xwrite(f, (char *)(& win), (int )sizeof(win));
  }
#line 531
  if (! tmp___11) {
#line 531
    return;
  }
  {
#line 532
  tmp___12 = xwrite(f, (char *)(& save_movie), (int )sizeof(save_movie));
  }
#line 532
  if (! tmp___12) {
#line 532
    return;
  }
  {
#line 533
  tmp___13 = xwrite(f, (char *)(& user_score), (int )sizeof(user_score));
  }
#line 533
  if (! tmp___13) {
#line 533
    return;
  }
  {
#line 534
  tmp___14 = xwrite(f, (char *)(& comp_score), (int )sizeof(comp_score));
  }
#line 534
  if (! tmp___14) {
#line 534
    return;
  }
  {
#line 536
  fclose(f);
#line 537
  topmsg(3, (char *)"Game saved.");
  }
#line 538
  return;
}
}
#line 550
void read_embark(piece_info_t *list , int piece_type ) ;
#line 548 "/home/june/repo/benchmarks/collector/temp/empire-1.11/game.c"
int restore_game(void) 
{ 
  FILE *f ;
  long i ;
  piece_info_t **list ;
  piece_info_t *obj ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;
  _Bool tmp___10 ;
  _Bool tmp___11 ;
  _Bool tmp___12 ;
  _Bool tmp___13 ;
  _Bool tmp___14 ;

  {
  {
#line 557
  f = fopen((char const   */* __restrict  */)savefile, (char const   */* __restrict  */)"r");
  }
#line 558
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 559
    perror("Cannot open saved game");
    }
#line 560
    return (0);
  }
  {
#line 562
  tmp = xread(f, (char *)(map), (int )sizeof(map));
  }
#line 562
  if (! tmp) {
#line 562
    return (0);
  }
  {
#line 563
  tmp___0 = xread(f, (char *)(comp_map), (int )sizeof(comp_map));
  }
#line 563
  if (! tmp___0) {
#line 563
    return (0);
  }
  {
#line 564
  tmp___1 = xread(f, (char *)(user_map), (int )sizeof(user_map));
  }
#line 564
  if (! tmp___1) {
#line 564
    return (0);
  }
  {
#line 565
  tmp___2 = xread(f, (char *)(city), (int )sizeof(city));
  }
#line 565
  if (! tmp___2) {
#line 565
    return (0);
  }
  {
#line 566
  tmp___3 = xread(f, (char *)(object), (int )sizeof(object));
  }
#line 566
  if (! tmp___3) {
#line 566
    return (0);
  }
  {
#line 567
  tmp___4 = xread(f, (char *)(user_obj), (int )sizeof(user_obj));
  }
#line 567
  if (! tmp___4) {
#line 567
    return (0);
  }
  {
#line 568
  tmp___5 = xread(f, (char *)(comp_obj), (int )sizeof(comp_obj));
  }
#line 568
  if (! tmp___5) {
#line 568
    return (0);
  }
  {
#line 569
  tmp___6 = xread(f, (char *)(& free_list), (int )sizeof(free_list));
  }
#line 569
  if (! tmp___6) {
#line 569
    return (0);
  }
  {
#line 570
  tmp___7 = xread(f, (char *)(& date), (int )sizeof(date));
  }
#line 570
  if (! tmp___7) {
#line 570
    return (0);
  }
  {
#line 571
  tmp___8 = xread(f, (char *)(& automove), (int )sizeof(automove));
  }
#line 571
  if (! tmp___8) {
#line 571
    return (0);
  }
  {
#line 572
  tmp___9 = xread(f, (char *)(& resigned), (int )sizeof(resigned));
  }
#line 572
  if (! tmp___9) {
#line 572
    return (0);
  }
  {
#line 573
  tmp___10 = xread(f, (char *)(& debug), (int )sizeof(debug));
  }
#line 573
  if (! tmp___10) {
#line 573
    return (0);
  }
  {
#line 574
  tmp___11 = xread(f, (char *)(& win), (int )sizeof(win));
  }
#line 574
  if (! tmp___11) {
#line 574
    return (0);
  }
  {
#line 575
  tmp___12 = xread(f, (char *)(& save_movie), (int )sizeof(save_movie));
  }
#line 575
  if (! tmp___12) {
#line 575
    return (0);
  }
  {
#line 576
  tmp___13 = xread(f, (char *)(& user_score), (int )sizeof(user_score));
  }
#line 576
  if (! tmp___13) {
#line 576
    return (0);
  }
  {
#line 577
  tmp___14 = xread(f, (char *)(& comp_score), (int )sizeof(comp_score));
  }
#line 577
  if (! tmp___14) {
#line 577
    return (0);
  }
#line 582
  free_list = (piece_info_t *)((void *)0);
#line 583
  i = 0L;
  {
#line 583
  while (1) {
    while_continue: /* CIL Label */ ;
#line 583
    if (! (i < 6000L)) {
#line 583
      goto while_break;
    }
#line 584
    map[i].cityp = (city_info_t *)((void *)0);
#line 585
    map[i].objp = (piece_info_t *)((void *)0);
#line 583
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 587
  i = 0L;
  {
#line 587
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 587
    if (! (i < 5000L)) {
#line 587
      goto while_break___0;
    }
#line 588
    object[i].loc_link.next = (struct piece_info *)((void *)0);
#line 589
    object[i].loc_link.prev = (struct piece_info *)((void *)0);
#line 590
    object[i].cargo_link.next = (struct piece_info *)((void *)0);
#line 591
    object[i].cargo_link.prev = (struct piece_info *)((void *)0);
#line 592
    object[i].piece_link.next = (struct piece_info *)((void *)0);
#line 593
    object[i].piece_link.prev = (struct piece_info *)((void *)0);
#line 594
    object[i].ship = (struct piece_info *)((void *)0);
#line 595
    object[i].cargo = (struct piece_info *)((void *)0);
#line 587
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 597
  i = 0L;
  {
#line 597
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 597
    if (! (i < 9L)) {
#line 597
      goto while_break___1;
    }
#line 598
    comp_obj[i] = (piece_info_t *)((void *)0);
#line 599
    user_obj[i] = (piece_info_t *)((void *)0);
#line 597
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 602
  i = 0L;
  {
#line 602
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 602
    if (! (i < 70L)) {
#line 602
      goto while_break___2;
    }
#line 603
    map[city[i].loc].cityp = & city[i];
#line 602
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 606
  i = 0L;
  {
#line 606
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 606
    if (! (i < 5000L)) {
#line 606
      goto while_break___3;
    }
#line 607
    obj = & object[i];
#line 608
    if (object[i].owner == 0) {
#line 608
      goto _L;
    } else
#line 608
    if ((int )object[i].hits == 0) {
      _L: /* CIL Label */ 
#line 609
      obj->piece_link.prev = (struct piece_info *)((void *)0);
#line 609
      obj->piece_link.next = free_list;
#line 609
      if (free_list) {
#line 609
        free_list->piece_link.prev = obj;
      }
#line 609
      free_list = obj;
    } else {
#line 612
      if (object[i].owner == 1) {
#line 612
        list = user_obj;
      } else {
#line 612
        list = comp_obj;
      }
#line 613
      obj->piece_link.prev = (struct piece_info *)((void *)0);
#line 613
      obj->piece_link.next = *(list + object[i].type);
#line 613
      if (*(list + object[i].type)) {
#line 613
        (*(list + object[i].type))->piece_link.prev = obj;
      }
#line 613
      *(list + object[i].type) = obj;
#line 614
      obj->loc_link.prev = (struct piece_info *)((void *)0);
#line 614
      obj->loc_link.next = map[object[i].loc].objp;
#line 614
      if (map[object[i].loc].objp) {
#line 614
        (map[object[i].loc].objp)->loc_link.prev = obj;
      }
#line 614
      map[object[i].loc].objp = obj;
    }
#line 606
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 619
  read_embark(user_obj[5], 0);
#line 620
  read_embark(user_obj[6], 1);
#line 621
  read_embark(comp_obj[5], 0);
#line 622
  read_embark(comp_obj[6], 1);
#line 624
  fclose(f);
#line 625
  kill_display();
#line 626
  topmsg(3, (char *)"Game restored from save file.");
  }
#line 627
  return (1);
}
}
#line 638
void inconsistent(void) ;
#line 636 "/home/june/repo/benchmarks/collector/temp/empire-1.11/game.c"
void read_embark(piece_info_t *list , int piece_type ) 
{ 
  piece_info_t *ship ;
  piece_info_t *obj ;
  int count ;

  {
#line 644
  ship = list;
  {
#line 644
  while (1) {
    while_continue: /* CIL Label */ ;
#line 644
    if (! ((unsigned long )ship != (unsigned long )((void *)0))) {
#line 644
      goto while_break;
    }
#line 645
    count = (int )ship->count;
#line 646
    if (count < 0) {
      {
#line 646
      inconsistent();
      }
    }
#line 647
    ship->count = (short)0;
#line 648
    obj = map[ship->loc].objp;
    {
#line 648
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 648
      if (obj) {
#line 648
        if (! count) {
#line 648
          goto while_break___0;
        }
      } else {
#line 648
        goto while_break___0;
      }
#line 650
      if ((unsigned long )obj->ship == (unsigned long )((void *)0)) {
#line 650
        if (obj->type == piece_type) {
          {
#line 651
          embark(ship, obj);
#line 652
          count --;
          }
        }
      }
#line 648
      obj = obj->loc_link.next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 655
    if (count) {
      {
#line 655
      inconsistent();
      }
    }
#line 644
    ship = ship->piece_link.next;
  }
  while_break: /* CIL Label */ ;
  }
#line 657
  return;
}
}
#line 659 "/home/june/repo/benchmarks/collector/temp/empire-1.11/game.c"
void inconsistent(void) 
{ 


  {
  {
#line 661
  printf((char const   */* __restrict  */)"saved game is inconsistent.  Please remove it.\n");
#line 662
  exit(1);
  }
}
}
#line 670 "/home/june/repo/benchmarks/collector/temp/empire-1.11/game.c"
_Bool xwrite(FILE *f , char *buf , int size ) 
{ 
  int bytes ;
  size_t tmp ;

  {
  {
#line 674
  tmp = fwrite((void const   */* __restrict  */)buf, (size_t )1, (size_t )size, (FILE */* __restrict  */)f);
#line 674
  bytes = (int )tmp;
  }
#line 675
  if (bytes == -1) {
    {
#line 676
    perror("Write to save file failed");
    }
#line 677
    return ((_Bool)0);
  }
#line 679
  if (bytes != size) {
    {
#line 680
    perror("Cannot complete write to save file.\n");
    }
#line 681
    return ((_Bool)0);
  }
#line 683
  return ((_Bool)1);
}
}
#line 691 "/home/june/repo/benchmarks/collector/temp/empire-1.11/game.c"
_Bool xread(FILE *f , char *buf , int size ) 
{ 
  int bytes ;
  size_t tmp ;

  {
  {
#line 695
  tmp = fread((void */* __restrict  */)buf, (size_t )1, (size_t )size, (FILE */* __restrict  */)f);
#line 695
  bytes = (int )tmp;
  }
#line 696
  if (bytes == -1) {
    {
#line 697
    perror("Read from save file failed");
    }
#line 698
    return ((_Bool)0);
  }
#line 700
  if (bytes != size) {
    {
#line 701
    perror("Saved file is too short.\n");
    }
#line 702
    return ((_Bool)0);
  }
#line 704
  return ((_Bool)1);
}
}
#line 714 "/home/june/repo/benchmarks/collector/temp/empire-1.11/game.c"
static char mapbuf[6000]  ;
#line 716 "/home/june/repo/benchmarks/collector/temp/empire-1.11/game.c"
void save_movie_screen(void) 
{ 
  FILE *f ;
  count_t i ;
  piece_info_t *p ;
  int tmp ;
  _Bool tmp___0 ;

  {
  {
#line 723
  f = fopen((char const   */* __restrict  */)"empmovie.dat", (char const   */* __restrict  */)"a");
  }
#line 724
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 725
    perror("Cannot open empmovie.dat");
    }
#line 726
    return;
  }
#line 729
  i = (count_t )0;
  {
#line 729
  while (1) {
    while_continue: /* CIL Label */ ;
#line 729
    if (! (i < 6000L)) {
#line 729
      goto while_break;
    }
#line 730
    if (map[i].cityp) {
#line 730
      mapbuf[i] = city_char[(map[i].cityp)->owner];
    } else {
      {
#line 732
      p = find_obj_at_loc(i);
      }
#line 734
      if (! p) {
#line 734
        mapbuf[i] = map[i].contents;
      } else
#line 735
      if (p->owner == 1) {
#line 736
        mapbuf[i] = piece_attr[p->type].sname;
      } else {
        {
#line 737
        tmp = tolower((int )piece_attr[p->type].sname);
#line 737
        mapbuf[i] = (char )tmp;
        }
      }
    }
#line 729
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 740
  tmp___0 = xwrite(f, mapbuf, (int )sizeof(mapbuf));
  }
#line 740
  if (! tmp___0) {
#line 740
    return;
  }
  {
#line 741
  fclose(f);
  }
#line 742
  return;
}
}
#line 749 "/home/june/repo/benchmarks/collector/temp/empire-1.11/game.c"
void replay_movie(void) 
{ 
  FILE *f ;
  int row_inc ;
  int col_inc ;
  int r ;
  int c ;
  int round ;
  size_t tmp ;

  {
  {
#line 760
  f = fopen((char const   */* __restrict  */)"empmovie.dat", (char const   */* __restrict  */)"r");
  }
#line 761
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 762
    perror("Cannot open empmovie.dat");
    }
#line 763
    return;
  }
  {
#line 765
  round = 0;
#line 766
  clear_screen();
  }
  {
#line 767
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 768
    tmp = fread((void */* __restrict  */)(mapbuf), (size_t )1, sizeof(mapbuf), (FILE */* __restrict  */)f);
    }
#line 768
    if (tmp != sizeof(mapbuf)) {
#line 769
      goto while_break;
    }
    {
#line 770
    round ++;
#line 772
    stat_display(mapbuf, round);
#line 774
    row_inc = (((60 + lines) - 3) - 1) / (lines - 3);
#line 775
    col_inc = ((100 + cols) - 1) / (cols - 1);
#line 777
    r = 0;
    }
    {
#line 777
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 777
      if (! (r < 60)) {
#line 777
        goto while_break___0;
      }
#line 778
      c = 0;
      {
#line 778
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 778
        if (! (c < 100)) {
#line 778
          goto while_break___1;
        }
        {
#line 779
        print_movie_cell(mapbuf, r, c, row_inc, col_inc);
#line 778
        c += col_inc;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 777
      r += row_inc;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 781
    redisplay();
#line 782
    delay();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 784
  fclose(f);
  }
#line 785
  return;
}
}
#line 799 "/home/june/repo/benchmarks/collector/temp/empire-1.11/game.c"
static char *pieces  =    (char *)"OAFPDSTCBZXafpdstcbz";
#line 801 "/home/june/repo/benchmarks/collector/temp/empire-1.11/game.c"
void stat_display(char *mbuf , int round ) 
{ 
  count_t i ;
  int counts[20] ;
  int user_cost ;
  int comp_cost ;
  char *p ;

  {
  {
#line 808
  memset((void *)((char *)(counts)), '\000', sizeof(counts));
#line 810
  i = (count_t )0;
  }
  {
#line 810
  while (1) {
    while_continue: /* CIL Label */ ;
#line 810
    if (! (i < 6000L)) {
#line 810
      goto while_break;
    }
    {
#line 811
    p = strchr((char const   *)pieces, (int )*(mbuf + i));
    }
#line 812
    if (p) {
#line 812
      (counts[p - pieces]) ++;
    }
#line 810
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 814
  user_cost = 0;
#line 815
  i = (count_t )1;
  {
#line 815
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 815
    if (! (i <= 9L)) {
#line 815
      goto while_break___0;
    }
#line 816
    user_cost += counts[i] * (int )piece_attr[i - 1L].build_time;
#line 815
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 818
  comp_cost = 0;
#line 819
  i = (count_t )11;
  {
#line 819
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 819
    if (! (i <= 19L)) {
#line 819
      goto while_break___1;
    }
#line 820
    comp_cost += counts[i] * (int )piece_attr[(i - 9L) - 2L].build_time;
#line 819
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 822
  i = (count_t )0;
  {
#line 822
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 822
    if (! (i < 10L)) {
#line 822
      goto while_break___2;
    }
    {
#line 823
    pos_str(1, (int )i * 6, (char *)"%2d %c  ", counts[i], (int )*(pieces + i));
#line 824
    pos_str(2, (int )i * 6, (char *)"%2d %c  ", counts[(i + 9L) + 1L], (int )*(pieces + ((i + 9L) + 1L)));
#line 822
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 827
  pos_str(1, (int )i * 6, (char *)"%5d", user_cost);
#line 828
  pos_str(2, (int )i * 6, (char *)"%5d", comp_cost);
#line 829
  pos_str(0, 0, (char *)"Round %3d", (round + 1) / 2);
  }
#line 830
  return;
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/empire-1.11/extern.h"
int move_order[9] ;
#line 46
char tt_attack[2] ;
#line 47
char army_attack[11] ;
#line 48
char fighter_attack[9] ;
#line 49
char ship_attack[7] ;
#line 51
move_info_t tt_load ;
#line 52
move_info_t tt_explore ;
#line 53
move_info_t tt_unload ;
#line 54
move_info_t army_fight ;
#line 55
move_info_t army_load ;
#line 56
move_info_t fighter_fight ;
#line 57
move_info_t ship_fight ;
#line 58
move_info_t ship_repair ;
#line 112
void comp_move(int nmoves ) ;
#line 117
void vmap_cont(int *cont_map , view_map_t *vmap , long loc , char bad_terrain ) ;
#line 119
void vmap_mark_up_cont(int *cont_map , view_map_t *vmap , long loc , char bad_terrain ) ;
#line 120
scan_counts_t vmap_cont_scan(int *cont_map , view_map_t *vmap ) ;
#line 123
long vmap_find_aobj(path_map_t *path_map___0 , view_map_t *vmap , long loc , move_info_t *move_info ) ;
#line 124
long vmap_find_wobj(path_map_t *path_map___0 , view_map_t *vmap , long loc , move_info_t *move_info ) ;
#line 125
long vmap_find_lobj(path_map_t *path_map___0 , view_map_t *vmap , long loc , move_info_t *move_info ) ;
#line 126
long vmap_find_lwobj(path_map_t *path_map___0 , view_map_t *vmap , long loc , move_info_t *move_info ,
                     int beat_cost ) ;
#line 127
long vmap_find_wlobj(path_map_t *path_map___0 , view_map_t *vmap , long loc , move_info_t *move_info ) ;
#line 128
long vmap_find_dest(path_map_t *path_map___0 , view_map_t *vmap , long cur_loc , long dest_loc ,
                    int owner , int terrain ) ;
#line 129
void vmap_prune_explore_locs(view_map_t *vmap ) ;
#line 130
void vmap_mark_path(path_map_t *path_map___0 , view_map_t *vmap , long dest ) ;
#line 131
void vmap_mark_adjacent(path_map_t *path_map___0 , long loc ) ;
#line 132
void vmap_mark_near_path(path_map_t *path_map___0 , long loc ) ;
#line 133
long vmap_find_dir(path_map_t *path_map___0 , view_map_t *vmap , long loc , char *terrain ,
                   char *adj_char ) ;
#line 137
_Bool vmap_at_sea(view_map_t *vmap , long loc ) ;
#line 225
void empend(void) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/empire-1.11/compmove.c"
static view_map_t emap[6000]  ;
#line 24
_Bool load_army(piece_info_t *obj ) ;
#line 25
_Bool lake(loc_t loc ) ;
#line 26
_Bool overproduced(city_info_t *cityp , int *city_count ) ;
#line 27
_Bool nearby_load(piece_info_t *obj , loc_t loc ) ;
#line 28
count_t nearby_count(loc_t loc ) ;
#line 29
void move_objective(piece_info_t *obj , path_map_t *pathmap , loc_t new_loc , char *adj_list ) ;
#line 30
void comp_set_prod(city_info_t *cityp , int type ) ;
#line 31
void comp_set_needed(city_info_t *cityp , int *city_count , _Bool army_ok , _Bool is_lake ) ;
#line 32
void comp_prod(city_info_t *cityp , _Bool is_lake ) ;
#line 37
void do_cities(void) ;
#line 37
void do_pieces(void) ;
#line 37
void check_endgame(void) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/empire-1.11/compmove.c"
void comp_move(int nmoves ) 
{ 
  int i ;
  piece_info_t *obj ;

  {
#line 44
  i = 0;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! (i < 9)) {
#line 44
      goto while_break;
    }
#line 45
    obj = comp_obj[i];
    {
#line 45
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 45
      if (! ((unsigned long )obj != (unsigned long )((void *)0))) {
#line 45
        goto while_break___0;
      }
      {
#line 46
      scan(comp_map, obj->loc);
#line 45
      obj = obj->piece_link.next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 44
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 48
  i = 1;
  {
#line 48
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 48
    if (! (i <= nmoves)) {
#line 48
      goto while_break___1;
    }
    {
#line 49
    comment((char *)"Thinking...");
#line 51
    memcpy((void */* __restrict  */)(emap), (void const   */* __restrict  */)(comp_map),
           6000UL * sizeof(view_map_t ));
#line 52
    vmap_prune_explore_locs(emap);
#line 54
    do_cities();
#line 55
    do_pieces();
    }
#line 57
    if (save_movie) {
      {
#line 57
      save_movie_screen();
      }
    }
    {
#line 58
    check_endgame();
#line 60
    topini();
#line 61
    redisplay();
#line 48
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 63
  return;
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/empire-1.11/compmove.c"
void do_cities(void) 
{ 
  int i ;
  _Bool is_lake ;
  _Bool tmp ;
  long tmp___0 ;

  {
#line 86
  i = 0;
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (! (i < 70)) {
#line 86
      goto while_break;
    }
#line 87
    if ((int )city[i].owner == 2) {
      {
#line 88
      scan(comp_map, city[i].loc);
      }
#line 90
      if ((int )city[i].prod == -1) {
        {
#line 91
        tmp = lake(city[i].loc);
#line 91
        comp_prod(& city[i], tmp);
        }
      }
    }
#line 86
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  i = 0;
  {
#line 93
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 93
    if (! (i < 70)) {
#line 93
      goto while_break___0;
    }
#line 94
    if ((int )city[i].owner == 2) {
      {
#line 95
      is_lake = lake(city[i].loc);
#line 96
      tmp___0 = city[i].work;
#line 96
      (city[i].work) ++;
      }
#line 96
      if (tmp___0 >= (long )piece_attr[(int )city[i].prod].build_time) {
        {
#line 97
        produce(& city[i]);
#line 98
        comp_prod(& city[i], is_lake);
        }
      } else
#line 101
      if ((int )city[i].prod > 1) {
#line 101
        if ((int )city[i].prod != 8) {
#line 101
          if (is_lake) {
            {
#line 102
            comp_prod(& city[i], is_lake);
            }
          }
        }
      }
    }
#line 93
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 104
  return;
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/empire-1.11/compmove.c"
static int ratio1[9]  = 
#line 115
  {      60,      0,      10,      0, 
        0,      20,      0,      0, 
        0};
#line 116 "/home/june/repo/benchmarks/collector/temp/empire-1.11/compmove.c"
static int ratio2[9]  = 
#line 116
  {      90,      10,      10,      10, 
        10,      40,      0,      0, 
        0};
#line 117 "/home/june/repo/benchmarks/collector/temp/empire-1.11/compmove.c"
static int ratio3[9]  = 
#line 117
  {      120,      20,      20,      10, 
        10,      60,      10,      10, 
        0};
#line 118 "/home/june/repo/benchmarks/collector/temp/empire-1.11/compmove.c"
static int ratio4[9]  = 
#line 118
  {      150,      30,      30,      20, 
        20,      70,      10,      10, 
        0};
#line 119 "/home/june/repo/benchmarks/collector/temp/empire-1.11/compmove.c"
static int *ratio  ;
#line 134 "/home/june/repo/benchmarks/collector/temp/empire-1.11/compmove.c"
void comp_prod(city_info_t *cityp , _Bool is_lake ) 
{ 
  int city_count[9] ;
  int cont_map[6000] ;
  int total_cities ;
  count_t i ;
  int comp_ac ;
  city_info_t *p ;
  int need_count ;
  int interest ;
  scan_counts_t counts ;
  int tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  _Bool tmp___2 ;

  {
  {
#line 149
  vmap_cont(cont_map, comp_map, cityp->loc, (char )'.');
#line 152
  counts = vmap_cont_scan(cont_map, comp_map);
#line 153
  comp_ac = 0;
#line 155
  i = (count_t )0;
  }
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    if (! (i < 6000L)) {
#line 155
      goto while_break;
    }
#line 156
    if (cont_map[i]) {
#line 157
      if ((int )comp_map[i].contents == 88) {
        {
#line 158
        p = find_city(i);
        }
#line 159
        if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 159
          if (! ((int )p->owner == 2)) {
            {
#line 159
            assert((char *)"x", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/compmove.c",
                   159);
            }
          }
        } else {
          {
#line 159
          assert((char *)"x", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/compmove.c",
                 159);
          }
        }
#line 160
        if ((int )p->prod == 0) {
#line 160
          comp_ac ++;
        }
      }
    }
#line 155
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  if (counts.unexplored) {
#line 164
    tmp = 1;
  } else
#line 164
  if (counts.user_cities) {
#line 164
    tmp = 1;
  } else
#line 164
  if (counts.user_objects[0]) {
#line 164
    tmp = 1;
  } else
#line 164
  if (counts.unowned_cities) {
#line 164
    tmp = 1;
  } else {
#line 164
    tmp = 0;
  }
#line 164
  interest = tmp;
#line 170
  need_count = (counts.user_cities - comp_ac) + interest;
#line 171
  if (counts.user_cities) {
#line 171
    need_count ++;
  }
#line 173
  if (need_count > 0) {
    {
#line 174
    comp_set_prod(cityp, 0);
    }
#line 175
    return;
  }
#line 179
  if (counts.user_cities) {
#line 179
    if ((int )cityp->prod == -1) {
      {
#line 180
      comp_set_prod(cityp, 0);
      }
#line 181
      return;
    }
  }
#line 187
  i = (count_t )0;
  {
#line 187
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 187
    if (! (i < 9L)) {
#line 187
      goto while_break___0;
    }
#line 188
    city_count[i] = 0;
#line 187
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 190
  total_cities = 0;
#line 192
  i = (count_t )0;
  {
#line 192
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 192
    if (! (i < 70L)) {
#line 192
      goto while_break___1;
    }
#line 193
    if ((int )city[i].owner == 2) {
#line 193
      if ((int )city[i].prod != -1) {
#line 194
        (city_count[(int )city[i].prod]) ++;
#line 195
        total_cities ++;
      }
    }
#line 192
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 197
  if (total_cities <= 10) {
#line 198
    ratio = ratio1;
  } else
#line 199
  if (total_cities <= 20) {
#line 200
    ratio = ratio2;
  } else
#line 201
  if (total_cities <= 30) {
#line 202
    ratio = ratio3;
  } else {
#line 203
    ratio = ratio4;
  }
#line 206
  if (city_count[0] == 1) {
#line 206
    if ((int )cityp->prod == 0) {
#line 206
      return;
    }
  }
#line 209
  if (city_count[5] == 0) {
#line 210
    if (! is_lake) {
      {
#line 211
      comp_set_prod(cityp, 5);
      }
#line 212
      return;
    }
#line 216
    if (city_count[0] == 1) {
#line 217
      i = (count_t )0;
      {
#line 217
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 217
        if (! (i < 70L)) {
#line 217
          goto while_break___2;
        }
#line 218
        if ((int )city[i].owner == 2) {
#line 218
          if ((int )city[i].prod == 0) {
#line 218
            goto while_break___2;
          }
        }
#line 217
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 220
      tmp___0 = lake(city[i].loc);
      }
#line 220
      if (! tmp___0) {
        {
#line 221
        comp_set_prod(cityp, 0);
        }
#line 222
        return;
      }
    }
  }
#line 236
  if ((int )cityp->prod == 0) {
#line 236
    if (interest) {
#line 236
      return;
    }
  }
#line 239
  if (counts.unowned_cities) {
#line 239
    if ((int )cityp->prod == -1) {
      {
#line 240
      comp_set_prod(cityp, 0);
      }
#line 241
      return;
    }
  }
#line 250
  if (counts.comp_cities != 1) {
#line 250
    tmp___1 = 1;
  } else
#line 250
  if (interest) {
#line 250
    tmp___1 = 1;
  } else {
#line 250
    tmp___1 = 0;
  }
#line 250
  interest = tmp___1;
#line 252
  if ((int )cityp->prod == -1) {
    {
#line 256
    comp_set_needed(cityp, city_count, (_Bool )interest, is_lake);
    }
  } else
#line 252
  if ((int )cityp->prod == 0) {
#line 252
    if (counts.comp_cities == 1) {
      {
#line 256
      comp_set_needed(cityp, city_count, (_Bool )interest, is_lake);
      }
    } else {
#line 252
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 252
    tmp___2 = overproduced(cityp, city_count);
    }
#line 252
    if (tmp___2) {
      {
#line 256
      comp_set_needed(cityp, city_count, (_Bool )interest, is_lake);
      }
    } else
#line 252
    if ((int )cityp->prod > 1) {
#line 252
      if (is_lake) {
        {
#line 256
        comp_set_needed(cityp, city_count, (_Bool )interest, is_lake);
        }
      }
    }
  }
#line 257
  return;
}
}
#line 264 "/home/june/repo/benchmarks/collector/temp/empire-1.11/compmove.c"
void comp_set_prod(city_info_t *cityp , int type ) 
{ 
  int tmp ;

  {
#line 267
  if ((int )cityp->prod == type) {
#line 267
    return;
  }
  {
#line 269
  tmp = loc_disp((int )cityp->loc);
#line 269
  pdebug((char *)"Changing city prod at %d from %d to %d\n", tmp, (int )cityp->prod,
         type);
#line 270
  cityp->prod = (char )type;
#line 271
  cityp->work = (long )(- ((int )piece_attr[type].build_time / 5));
  }
#line 272
  return;
}
}
#line 278 "/home/june/repo/benchmarks/collector/temp/empire-1.11/compmove.c"
_Bool overproduced(city_info_t *cityp , int *city_count ) 
{ 
  int i ;

  {
#line 283
  i = 0;
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 283
    if (! (i < 9)) {
#line 283
      goto while_break;
    }
#line 285
    if (i != (int )cityp->prod) {
#line 285
      if ((*(city_count + (int )cityp->prod) - 1) * *(ratio + i) > (*(city_count + i) + 1) * *(ratio + (int )cityp->prod)) {
#line 288
        return ((_Bool)1);
      }
    }
#line 283
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 290
  return ((_Bool)0);
}
}
#line 298 "/home/june/repo/benchmarks/collector/temp/empire-1.11/compmove.c"
int need_more(int *city_count , int prod1 , int prod2 ) 
{ 


  {
#line 301
  if (*(city_count + prod1) * *(ratio + prod2) <= *(city_count + prod2) * *(ratio + prod1)) {
#line 303
    return (prod1);
  } else {
#line 305
    return (prod2);
  }
}
}
#line 313 "/home/june/repo/benchmarks/collector/temp/empire-1.11/compmove.c"
void comp_set_needed(city_info_t *cityp , int *city_count , _Bool army_ok , _Bool is_lake ) 
{ 
  int best_prod ;
  int prod ;
  int tmp ;

  {
#line 319
  if (! army_ok) {
#line 319
    *(city_count + 0) = 10000000;
  }
#line 321
  if (is_lake) {
    {
#line 322
    tmp = need_more(city_count, 0, 1);
#line 322
    comp_set_prod(cityp, tmp);
    }
#line 323
    return;
  }
#line 326
  *(city_count + 1) = 10000000;
#line 328
  best_prod = 0;
#line 329
  prod = 0;
  {
#line 329
  while (1) {
    while_continue: /* CIL Label */ ;
#line 329
    if (! (prod < 9)) {
#line 329
      goto while_break;
    }
    {
#line 330
    best_prod = need_more(city_count, best_prod, prod);
#line 329
    prod ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 332
  comp_set_prod(cityp, best_prod);
  }
#line 333
  return;
}
}
#line 347 "/home/june/repo/benchmarks/collector/temp/empire-1.11/compmove.c"
_Bool lake(loc_t loc ) 
{ 
  int cont_map[6000] ;
  scan_counts_t counts ;
  int tmp ;

  {
  {
#line 353
  vmap_cont(cont_map, emap, loc, (char )'+');
#line 354
  counts = vmap_cont_scan(cont_map, emap);
  }
#line 356
  if (counts.unowned_cities) {
#line 356
    tmp = 0;
  } else
#line 356
  if (counts.user_cities) {
#line 356
    tmp = 0;
  } else
#line 356
  if (counts.unexplored) {
#line 356
    tmp = 0;
  } else {
#line 356
    tmp = 1;
  }
#line 356
  return ((_Bool )tmp);
}
}
#line 363 "/home/june/repo/benchmarks/collector/temp/empire-1.11/compmove.c"
static view_map_t amap[6000]  ;
#line 364 "/home/june/repo/benchmarks/collector/temp/empire-1.11/compmove.c"
static path_map_t path_map[6000]  ;
#line 369
void cpiece_move(piece_info_t *obj ) ;
#line 366 "/home/june/repo/benchmarks/collector/temp/empire-1.11/compmove.c"
void do_pieces(void) 
{ 
  int i ;
  piece_info_t *obj ;
  piece_info_t *next_obj ;

  {
#line 374
  i = 0;
  {
#line 374
  while (1) {
    while_continue: /* CIL Label */ ;
#line 374
    if (! (i < 9)) {
#line 374
      goto while_break;
    }
#line 375
    obj = comp_obj[move_order[i]];
    {
#line 375
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 375
      if (! ((unsigned long )obj != (unsigned long )((void *)0))) {
#line 375
        goto while_break___0;
      }
      {
#line 377
      next_obj = obj->piece_link.next;
#line 378
      cpiece_move(obj);
#line 375
      obj = next_obj;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 374
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 381
  return;
}
}
#line 392
void move1(piece_info_t *obj ) ;
#line 389 "/home/june/repo/benchmarks/collector/temp/empire-1.11/compmove.c"
void cpiece_move(piece_info_t *obj ) 
{ 
  _Bool changed_loc ;
  int max_hits ;
  loc_t saved_loc ;
  city_info_t *cityp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 399
  if (obj->type == 8) {
    {
#line 400
    move_sat(obj);
    }
#line 401
    return;
  }
#line 404
  obj->moved = 0;
#line 405
  changed_loc = (_Bool)0;
#line 406
  max_hits = (int )piece_attr[obj->type].max_hits;
#line 408
  if (obj->type == 1) {
    {
#line 409
    cityp = find_city(obj->loc);
    }
#line 410
    if ((unsigned long )cityp != (unsigned long )((void *)0)) {
#line 410
      obj->range = (short )piece_attr[1].range;
    }
  }
  {
#line 413
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 413
    tmp___1 = obj_moves(obj);
    }
#line 413
    if (! (obj->moved < tmp___1)) {
#line 413
      goto while_break;
    }
    {
#line 414
    saved_loc = obj->loc;
#line 415
    move1(obj);
    }
#line 416
    if (saved_loc != obj->loc) {
#line 416
      changed_loc = (_Bool)1;
    }
#line 418
    if (obj->type == 1) {
#line 418
      if ((int )obj->hits > 0) {
#line 419
        if ((int )comp_map[obj->loc].contents == 88) {
#line 420
          obj->moved = (int )piece_attr[1].speed;
        } else
#line 421
        if ((int )obj->range == 0) {
          {
#line 422
          tmp = loc_disp((int )obj->loc);
#line 422
          pdebug((char *)"Fighter at %d crashed and burned\n", tmp);
#line 423
          tmp___0 = loc_disp((int )obj->loc);
#line 423
          ksend((char *)"Fighter at %d crashed and burned\n", tmp___0);
#line 424
          kill_obj(obj, obj->loc);
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 429
  if ((int )obj->hits > 0) {
#line 429
    if (! changed_loc) {
#line 429
      if (obj->type != 0) {
#line 429
        if (obj->type != 1) {
#line 429
          if ((int )obj->hits != max_hits) {
#line 429
            if ((int )comp_map[obj->loc].contents == 88) {
#line 434
              obj->hits = (short )((int )obj->hits + 1);
            }
          }
        }
      }
    }
  }
#line 435
  return;
}
}
#line 444
void army_move(piece_info_t *obj ) ;
#line 444
void transport_move(piece_info_t *obj ) ;
#line 444
void fighter_move(piece_info_t *obj ) ;
#line 444
void ship_move(piece_info_t *obj ) ;
#line 441 "/home/june/repo/benchmarks/collector/temp/empire-1.11/compmove.c"
void move1(piece_info_t *obj ) 
{ 


  {
  {
#line 447
  if (obj->type == 0) {
#line 447
    goto case_0;
  }
#line 448
  if (obj->type == 5) {
#line 448
    goto case_5;
  }
#line 449
  if (obj->type == 1) {
#line 449
    goto case_1;
  }
#line 450
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 447
  army_move(obj);
  }
#line 447
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 448
  transport_move(obj);
  }
#line 448
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 449
  fighter_move(obj);
  }
#line 449
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 450
  ship_move(obj);
  }
#line 450
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 452
  return;
}
}
#line 486
loc_t move_away(view_map_t *vmap , loc_t loc , char *terrain ) ;
#line 487
loc_t find_attack(loc_t loc , char *obj_list , char *terrain ) ;
#line 488
void make_army_load_map(piece_info_t *obj , view_map_t *xmap , view_map_t *vmap ) ;
#line 488
void make_unload_map(view_map_t *xmap , view_map_t *vmap ) ;
#line 488
void make_tt_load_map(view_map_t *xmap , view_map_t *vmap ) ;
#line 489
void board_ship(piece_info_t *obj , path_map_t *pmap , loc_t dest ) ;
#line 483 "/home/june/repo/benchmarks/collector/temp/empire-1.11/compmove.c"
void army_move(piece_info_t *obj ) 
{ 
  loc_t new_loc ;
  path_map_t path_map2[6000] ;
  int cross_cost ;
  _Bool tmp ;
  _Bool tmp___0 ;
  loc_t new_loc2 ;

  {
  {
#line 493
  cross_cost = 0;
#line 495
  obj->func = 0L;
#line 496
  tmp = vmap_at_sea(comp_map, obj->loc);
  }
#line 496
  if (tmp) {
    {
#line 497
    load_army(obj);
#line 498
    obj->moved = (int )piece_attr[0].speed;
    }
#line 499
    if (! obj->ship) {
#line 499
      obj->func = 1L;
    }
#line 500
    return;
  }
#line 502
  if (obj->ship) {
    {
#line 503
    new_loc = find_attack(obj->loc, army_attack, "+*");
    }
  } else {
    {
#line 504
    new_loc = find_attack(obj->loc, army_attack, ".+*");
    }
  }
#line 506
  if (new_loc != obj->loc) {
    {
#line 507
    attack(obj, new_loc);
    }
#line 508
    if ((int )map[new_loc].contents == 46) {
#line 508
      if ((int )obj->hits > 0) {
        {
#line 510
        kill_obj(obj, new_loc);
#line 511
        scan(user_map, new_loc);
        }
      }
    }
#line 513
    return;
  }
#line 515
  if (obj->ship) {
#line 516
    if ((obj->ship)->func == 0L) {
      {
#line 517
      tmp___0 = load_army(obj);
      }
#line 517
      if (! tmp___0) {
        {
#line 517
        assert((char *)"aborting", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/compmove.c",
               517);
        }
      }
#line 518
      return;
    }
    {
#line 520
    make_unload_map(amap, comp_map);
#line 521
    new_loc = vmap_find_wlobj(path_map, amap, obj->loc, & tt_unload);
#line 522
    move_objective(obj, path_map, new_loc, (char *)" ");
    }
#line 523
    return;
  }
  {
#line 526
  new_loc = vmap_find_lobj(path_map, comp_map, obj->loc, & army_fight);
  }
#line 528
  if (new_loc != obj->loc) {
    {
#line 531
    if ((int )comp_map[new_loc].contents == 79) {
#line 531
      goto case_79;
    }
#line 531
    if ((int )comp_map[new_loc].contents == 65) {
#line 531
      goto case_79;
    }
#line 534
    if ((int )comp_map[new_loc].contents == 42) {
#line 534
      goto case_42;
    }
#line 537
    if ((int )comp_map[new_loc].contents == 32) {
#line 537
      goto case_32;
    }
#line 540
    goto switch_default;
    case_79: /* CIL Label */ 
    case_65: /* CIL Label */ 
#line 532
    cross_cost = 60;
#line 533
    goto switch_break;
    case_42: /* CIL Label */ 
#line 535
    cross_cost = 30;
#line 536
    goto switch_break;
    case_32: /* CIL Label */ 
#line 538
    cross_cost = 14;
#line 539
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 541
    assert((char *)"aborting", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/compmove.c",
           541);
    }
    switch_break: /* CIL Label */ ;
    }
#line 543
    cross_cost = path_map[new_loc].cost * 2 - cross_cost;
  } else {
#line 545
    cross_cost = 10000000;
  }
#line 547
  if (new_loc == obj->loc) {
#line 547
    goto _L;
  } else
#line 547
  if (cross_cost > 0) {
    _L: /* CIL Label */ 
    {
#line 550
    make_army_load_map(obj, amap, comp_map);
#line 551
    new_loc2 = vmap_find_lwobj(path_map2, amap, obj->loc, & army_load, cross_cost);
    }
#line 553
    if (new_loc2 != obj->loc) {
      {
#line 554
      board_ship(obj, path_map2, new_loc2);
      }
#line 555
      return;
    }
  }
  {
#line 559
  move_objective(obj, path_map, new_loc, (char *)" ");
  }
#line 560
  return;
}
}
#line 566 "/home/june/repo/benchmarks/collector/temp/empire-1.11/compmove.c"
void unmark_explore_locs(view_map_t *xmap ) 
{ 
  count_t i ;

  {
#line 571
  i = (count_t )0;
  {
#line 571
  while (1) {
    while_continue: /* CIL Label */ ;
#line 571
    if (! (i < 6000L)) {
#line 571
      goto while_break;
    }
#line 572
    if (map[i].on_board) {
#line 572
      if ((int )(xmap + i)->contents == 32) {
#line 573
        (xmap + i)->contents = emap[i].contents;
      }
    }
#line 571
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 574
  return;
}
}
#line 581 "/home/june/repo/benchmarks/collector/temp/empire-1.11/compmove.c"
void make_army_load_map(piece_info_t *obj , view_map_t *xmap , view_map_t *vmap ) 
{ 
  piece_info_t *p ;
  int i ;
  count_t tmp ;
  _Bool tmp___0 ;

  {
  {
#line 587
  memcpy((void */* __restrict  */)xmap, (void const   */* __restrict  */)vmap, sizeof(view_map_t ) * 6000UL);
#line 590
  p = comp_obj[5];
  }
  {
#line 590
  while (1) {
    while_continue: /* CIL Label */ ;
#line 590
    if (! p) {
#line 590
      goto while_break;
    }
#line 591
    if (p->func == 0L) {
#line 592
      (xmap + p->loc)->contents = (char )'$';
    }
#line 590
    p = p->piece_link.next;
  }
  while_break: /* CIL Label */ ;
  }
#line 594
  i = 0;
  {
#line 594
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 594
    if (! (i < 70)) {
#line 594
      goto while_break___0;
    }
#line 595
    if ((int )city[i].owner == 2) {
#line 595
      if ((int )city[i].prod == 5) {
        {
#line 596
        tmp___0 = nearby_load(obj, city[i].loc);
        }
#line 596
        if (tmp___0) {
#line 597
          (xmap + city[i].loc)->contents = (char )'x';
        } else {
          {
#line 598
          tmp = nearby_count(city[i].loc);
          }
#line 598
          if (tmp < (count_t )piece_attr[5].capacity) {
#line 599
            (xmap + city[i].loc)->contents = (char )'x';
          }
        }
      }
    }
#line 594
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 602
  if ((int )print_vmap == 65) {
    {
#line 602
    print_xzoom(xmap);
    }
  }
#line 603
  return;
}
}
#line 607 "/home/june/repo/benchmarks/collector/temp/empire-1.11/compmove.c"
_Bool nearby_load(piece_info_t *obj , loc_t loc ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 610
  if (obj->func == 1L) {
    {
#line 610
    tmp = dist(obj->loc, loc);
    }
#line 610
    if (tmp <= 2) {
#line 610
      tmp___0 = 1;
    } else {
#line 610
      tmp___0 = 0;
    }
  } else {
#line 610
    tmp___0 = 0;
  }
#line 610
  return ((_Bool )tmp___0);
}
}
#line 615 "/home/june/repo/benchmarks/collector/temp/empire-1.11/compmove.c"
count_t nearby_count(loc_t loc ) 
{ 
  piece_info_t *obj ;
  int count ;
  _Bool tmp ;

  {
#line 621
  count = 0;
#line 622
  obj = comp_obj[0];
  {
#line 622
  while (1) {
    while_continue: /* CIL Label */ ;
#line 622
    if (! obj) {
#line 622
      goto while_break;
    }
    {
#line 623
    tmp = nearby_load(obj, loc);
    }
#line 623
    if (tmp) {
#line 623
      count ++;
    }
#line 622
    obj = obj->piece_link.next;
  }
  while_break: /* CIL Label */ ;
  }
#line 625
  return ((count_t )count);
}
}
#line 630 "/home/june/repo/benchmarks/collector/temp/empire-1.11/compmove.c"
void make_tt_load_map(view_map_t *xmap , view_map_t *vmap ) 
{ 
  piece_info_t *p ;

  {
  {
#line 635
  memcpy((void */* __restrict  */)xmap, (void const   */* __restrict  */)vmap, sizeof(view_map_t ) * 6000UL);
#line 638
  p = comp_obj[0];
  }
  {
#line 638
  while (1) {
    while_continue: /* CIL Label */ ;
#line 638
    if (! p) {
#line 638
      goto while_break;
    }
#line 639
    if (p->func == 1L) {
#line 640
      (xmap + p->loc)->contents = (char )'$';
    }
#line 638
    p = p->piece_link.next;
  }
  while_break: /* CIL Label */ ;
  }
#line 642
  if ((int )print_vmap == 76) {
    {
#line 643
    print_xzoom(xmap);
    }
  }
#line 644
  return;
}
}
#line 673 "/home/june/repo/benchmarks/collector/temp/empire-1.11/compmove.c"
static int owncont_map[6000]  ;
#line 674 "/home/june/repo/benchmarks/collector/temp/empire-1.11/compmove.c"
static int tcont_map[6000]  ;
#line 676 "/home/june/repo/benchmarks/collector/temp/empire-1.11/compmove.c"
void make_unload_map(view_map_t *xmap , view_map_t *vmap ) 
{ 
  count_t i ;
  scan_counts_t counts ;
  int total_cities ;
  char *tmp ;

  {
  {
#line 682
  memcpy((void */* __restrict  */)xmap, (void const   */* __restrict  */)vmap, sizeof(view_map_t ) * 6000UL);
#line 683
  unmark_explore_locs(xmap);
#line 685
  i = (count_t )0;
  }
  {
#line 685
  while (1) {
    while_continue: /* CIL Label */ ;
#line 685
    if (! (i < 6000L)) {
#line 685
      goto while_break;
    }
#line 686
    owncont_map[i] = 0;
#line 685
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 688
  i = (count_t )0;
  {
#line 688
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 688
    if (! (i < 70L)) {
#line 688
      goto while_break___0;
    }
#line 689
    if ((int )city[i].owner == 2) {
      {
#line 690
      vmap_mark_up_cont(owncont_map, xmap, city[i].loc, (char )'.');
      }
    }
#line 688
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 692
  i = (count_t )0;
  {
#line 692
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 692
    if (! (i < 6000L)) {
#line 692
      goto while_break___1;
    }
    {
#line 693
    tmp = strchr("O*", (int )(vmap + i)->contents);
    }
#line 693
    if (tmp) {
      {
#line 696
      vmap_cont(tcont_map, xmap, i, (char )'.');
#line 697
      counts = vmap_cont_scan(tcont_map, xmap);
#line 699
      total_cities = (counts.unowned_cities + counts.user_cities) + counts.comp_cities;
      }
#line 703
      if (total_cities > 9) {
#line 703
        total_cities = 0;
      }
#line 705
      if (counts.user_cities) {
#line 705
        if (counts.comp_cities) {
#line 706
          (xmap + i)->contents = (char )(48 + total_cities);
        } else {
#line 705
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 708
      if (counts.unowned_cities > counts.user_cities) {
#line 708
        if (counts.comp_cities == 0) {
#line 710
          (xmap + i)->contents = (char )(48 + total_cities);
        } else {
#line 708
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 712
      if (counts.user_cities == 1) {
#line 712
        if (counts.comp_cities == 0) {
#line 713
          (xmap + i)->contents = (char )'2';
        } else {
#line 715
          (xmap + i)->contents = (char )'0';
        }
      } else {
#line 715
        (xmap + i)->contents = (char )'0';
      }
    }
#line 692
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 717
  if ((int )print_vmap == 85) {
    {
#line 717
    print_xzoom(xmap);
    }
  }
#line 718
  return;
}
}
#line 726 "/home/june/repo/benchmarks/collector/temp/empire-1.11/compmove.c"
void board_ship(piece_info_t *obj , path_map_t *pmap , loc_t dest ) 
{ 
  _Bool tmp ;

  {
  {
#line 729
  tmp = load_army(obj);
  }
#line 729
  if (! tmp) {
    {
#line 730
    obj->func = 1L;
#line 731
    move_objective(obj, pmap, dest, (char *)"t.");
    }
  }
#line 733
  return;
}
}
#line 741 "/home/june/repo/benchmarks/collector/temp/empire-1.11/compmove.c"
piece_info_t *find_best_tt(piece_info_t *best , loc_t loc ) 
{ 
  piece_info_t *p ;
  int tmp ;

  {
#line 746
  p = map[loc].objp;
  {
#line 746
  while (1) {
    while_continue: /* CIL Label */ ;
#line 746
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 746
      goto while_break;
    }
#line 747
    if (p->type == 5) {
      {
#line 747
      tmp = obj_capacity(p);
      }
#line 747
      if (tmp > (int )p->count) {
#line 748
        if (! best) {
#line 748
          best = p;
        } else
#line 749
        if ((int )p->count >= (int )best->count) {
#line 749
          best = p;
        }
      }
    }
#line 746
    p = p->loc_link.next;
  }
  while_break: /* CIL Label */ ;
  }
#line 751
  return (best);
}
}
#line 758 "/home/june/repo/benchmarks/collector/temp/empire-1.11/compmove.c"
_Bool load_army(piece_info_t *obj ) 
{ 
  piece_info_t *p ;
  int i ;
  loc_t x_loc ;

  {
  {
#line 765
  p = find_best_tt(obj->ship, obj->loc);
#line 767
  i = 0;
  }
  {
#line 767
  while (1) {
    while_continue: /* CIL Label */ ;
#line 767
    if (! (i < 8)) {
#line 767
      goto while_break;
    }
#line 768
    x_loc = obj->loc + (loc_t )dir_offset[i];
#line 769
    if (map[x_loc].on_board) {
      {
#line 770
      p = find_best_tt(p, x_loc);
      }
    }
#line 767
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 773
  if (! p) {
#line 773
    return ((_Bool)0);
  }
#line 775
  if (p->loc == obj->loc) {
#line 776
    obj->moved = (int )piece_attr[0].speed;
  } else {
    {
#line 778
    move_obj(obj, p->loc);
    }
  }
#line 780
  if ((unsigned long )p->ship != (unsigned long )obj->ship) {
    {
#line 781
    disembark(obj);
#line 782
    embark(p, obj);
    }
  }
#line 784
  return ((_Bool)1);
}
}
#line 792 "/home/june/repo/benchmarks/collector/temp/empire-1.11/compmove.c"
loc_t move_away(view_map_t *vmap , loc_t loc , char *terrain ) 
{ 
  loc_t new_loc ;
  int i ;
  char *tmp ;

  {
#line 798
  i = 0;
  {
#line 798
  while (1) {
    while_continue: /* CIL Label */ ;
#line 798
    if (! (i < 8)) {
#line 798
      goto while_break;
    }
#line 799
    new_loc = loc + (loc_t )dir_offset[i];
#line 800
    if (map[new_loc].on_board) {
      {
#line 800
      tmp = strchr((char const   *)terrain, (int )(vmap + new_loc)->contents);
      }
#line 800
      if (tmp) {
#line 802
        return (new_loc);
      }
    }
#line 798
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 804
  return (loc);
}
}
#line 815 "/home/june/repo/benchmarks/collector/temp/empire-1.11/compmove.c"
loc_t find_attack(loc_t loc , char *obj_list , char *terrain ) 
{ 
  loc_t new_loc ;
  loc_t best_loc___0 ;
  int i ;
  int best_val ;
  char *p ;
  char *tmp ;

  {
#line 822
  best_loc___0 = loc;
#line 823
  best_val = 10000000;
#line 824
  i = 0;
  {
#line 824
  while (1) {
    while_continue: /* CIL Label */ ;
#line 824
    if (! (i < 8)) {
#line 824
      goto while_break;
    }
#line 825
    new_loc = loc + (loc_t )dir_offset[i];
#line 827
    if (map[new_loc].on_board) {
      {
#line 827
      tmp = strchr((char const   *)terrain, (int )map[new_loc].contents);
      }
#line 827
      if (tmp) {
        {
#line 829
        p = strchr((char const   *)obj_list, (int )comp_map[new_loc].contents);
        }
#line 830
        if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 830
          if (p - obj_list < (long )best_val) {
#line 831
            best_val = (int )(p - obj_list);
#line 832
            best_loc___0 = new_loc;
          }
        }
      }
    }
#line 824
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 836
  return (best_loc___0);
}
}
#line 851 "/home/june/repo/benchmarks/collector/temp/empire-1.11/compmove.c"
void transport_move(piece_info_t *obj ) 
{ 
  loc_t new_loc ;
  int tmp ;

  {
#line 859
  if ((int )obj->count == 0) {
    {
#line 860
    obj->func = 0L;
#line 861
    new_loc = find_attack(obj->loc, tt_attack, (char *)".");
    }
#line 862
    if (new_loc != obj->loc) {
      {
#line 863
      attack(obj, new_loc);
      }
#line 864
      return;
    }
  }
  {
#line 868
  tmp = obj_capacity(obj);
  }
#line 868
  if ((int )obj->count == tmp) {
#line 869
    obj->func = 1L;
  }
#line 871
  if (obj->func == 0L) {
    {
#line 872
    make_tt_load_map(amap, comp_map);
#line 873
    new_loc = vmap_find_wlobj(path_map, amap, obj->loc, & tt_load);
    }
#line 875
    if (new_loc == obj->loc) {
      {
#line 876
      memcpy((void */* __restrict  */)(amap), (void const   */* __restrict  */)(comp_map),
             6000UL * sizeof(view_map_t ));
#line 877
      unmark_explore_locs(amap);
      }
#line 878
      if ((int )print_vmap == 83) {
        {
#line 878
        print_xzoom(amap);
        }
      }
      {
#line 879
      new_loc = vmap_find_wobj(path_map, amap, obj->loc, & tt_explore);
      }
    }
    {
#line 882
    move_objective(obj, path_map, new_loc, (char *)"a ");
    }
  } else {
    {
#line 885
    make_unload_map(amap, comp_map);
#line 886
    new_loc = vmap_find_wlobj(path_map, amap, obj->loc, & tt_unload);
#line 887
    move_objective(obj, path_map, new_loc, (char *)" ");
    }
  }
#line 889
  return;
}
}
#line 903 "/home/june/repo/benchmarks/collector/temp/empire-1.11/compmove.c"
void fighter_move(piece_info_t *obj ) 
{ 
  loc_t new_loc ;
  int tmp ;

  {
  {
#line 908
  new_loc = find_attack(obj->loc, fighter_attack, (char *)".+");
  }
#line 909
  if (new_loc != obj->loc) {
    {
#line 910
    attack(obj, new_loc);
    }
#line 911
    return;
  }
  {
#line 914
  tmp = find_nearest_city(obj->loc, 2, & new_loc);
  }
#line 914
  if ((int )obj->range <= tmp + 2) {
#line 915
    if (new_loc != obj->loc) {
      {
#line 916
      new_loc = vmap_find_dest(path_map, comp_map, obj->loc, new_loc, 2, 6);
      }
    }
  } else {
#line 919
    new_loc = obj->loc;
  }
#line 921
  if (new_loc == obj->loc) {
    {
#line 922
    new_loc = vmap_find_aobj(path_map, comp_map, obj->loc, & fighter_fight);
    }
  }
  {
#line 925
  move_objective(obj, path_map, new_loc, (char *)" ");
  }
#line 926
  return;
}
}
#line 935 "/home/june/repo/benchmarks/collector/temp/empire-1.11/compmove.c"
void ship_move(piece_info_t *obj ) 
{ 
  loc_t new_loc ;
  char *adj_list ;

  {
#line 941
  if ((int )obj->hits < (int )piece_attr[obj->type].max_hits) {
#line 942
    if ((int )comp_map[obj->loc].contents == 88) {
#line 943
      obj->moved = (int )piece_attr[obj->type].speed;
#line 944
      return;
    }
    {
#line 946
    new_loc = vmap_find_wobj(path_map, comp_map, obj->loc, & ship_repair);
#line 947
    adj_list = (char *)".";
    }
  } else {
    {
#line 951
    new_loc = find_attack(obj->loc, ship_attack, (char *)".");
    }
#line 952
    if (new_loc != obj->loc) {
      {
#line 953
      attack(obj, new_loc);
      }
#line 954
      return;
    }
    {
#line 957
    memcpy((void */* __restrict  */)(amap), (void const   */* __restrict  */)(comp_map),
           6000UL * sizeof(view_map_t ));
#line 958
    unmark_explore_locs(amap);
    }
#line 959
    if ((int )print_vmap == 83) {
      {
#line 959
      print_xzoom(amap);
      }
    }
    {
#line 961
    new_loc = vmap_find_wobj(path_map, amap, obj->loc, & ship_fight);
#line 962
    adj_list = ship_fight.objectives;
    }
  }
  {
#line 965
  move_objective(obj, path_map, new_loc, adj_list);
  }
#line 966
  return;
}
}
#line 972 "/home/june/repo/benchmarks/collector/temp/empire-1.11/compmove.c"
void move_objective(piece_info_t *obj , path_map_t *pathmap , loc_t new_loc , char *adj_list ) 
{ 
  char *terrain ;
  int d ;
  _Bool reuse ;
  loc_t old_loc ;
  loc_t old_dest ;
  int tmp ;
  int tmp___0 ;
  char *attack_list ;
  loc_t tmp___1 ;
  int tmp___2 ;

  {
#line 982
  if (new_loc == obj->loc) {
    {
#line 983
    obj->moved = (int )piece_attr[obj->type].speed;
#line 984
    obj->range = (short )((int )obj->range - 1);
#line 985
    tmp = loc_disp((int )obj->loc);
#line 985
    pdebug((char *)"No destination found for %d at %d; func=%d\n", obj->type, tmp,
           obj->func);
    }
#line 986
    return;
  }
  {
#line 988
  old_loc = obj->loc;
#line 989
  old_dest = new_loc;
#line 991
  d = dist(new_loc, obj->loc);
#line 992
  reuse = (_Bool)1;
  }
#line 994
  if ((int )comp_map[new_loc].contents == 32) {
#line 994
    if (d == 2) {
      {
#line 995
      vmap_mark_adjacent(pathmap, obj->loc);
#line 996
      reuse = (_Bool)0;
      }
    } else {
      {
#line 998
      vmap_mark_path(pathmap, comp_map, new_loc);
      }
    }
  } else {
    {
#line 998
    vmap_mark_path(pathmap, comp_map, new_loc);
    }
  }
  {
#line 1002
  if (obj->type == 0) {
#line 1002
    goto case_0;
  }
#line 1003
  if (obj->type == 1) {
#line 1003
    goto case_1;
  }
#line 1004
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1002
  terrain = (char *)"+";
#line 1002
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1003
  terrain = (char *)"+.X";
#line 1003
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1004
  terrain = (char *)".X";
#line 1004
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1007
  new_loc = vmap_find_dir(pathmap, comp_map, obj->loc, terrain, adj_list);
  }
#line 1010
  if (new_loc == obj->loc) {
#line 1010
    if (obj->type != 0) {
      {
#line 1012
      vmap_mark_near_path(pathmap, obj->loc);
#line 1013
      reuse = (_Bool)0;
#line 1014
      new_loc = vmap_find_dir(pathmap, comp_map, obj->loc, terrain, adj_list);
      }
    } else
#line 1010
    if (! obj->ship) {
      {
#line 1012
      vmap_mark_near_path(pathmap, obj->loc);
#line 1013
      reuse = (_Bool)0;
#line 1014
      new_loc = vmap_find_dir(pathmap, comp_map, obj->loc, terrain, adj_list);
      }
    }
  }
#line 1019
  if (new_loc == obj->loc) {
#line 1019
    if ((unsigned long )map[obj->loc].cityp != (unsigned long )((void *)0)) {
#line 1019
      if (obj->type == 0) {
        {
#line 1021
        new_loc = move_away(comp_map, obj->loc, (char *)"+");
#line 1022
        reuse = (_Bool)0;
        }
      }
    }
  }
#line 1024
  if (new_loc == obj->loc) {
#line 1025
    obj->moved = (int )piece_attr[obj->type].speed;
#line 1027
    if (obj->type == 0) {
#line 1027
      if (! obj->ship) {
        {
#line 1028
        tmp___0 = loc_disp((int )obj->loc);
#line 1028
        pdebug((char *)"Cannot move %d at %d toward objective; func=%d\n", obj->type,
               tmp___0, obj->func);
        }
      }
    } else {
      {
#line 1028
      tmp___0 = loc_disp((int )obj->loc);
#line 1028
      pdebug((char *)"Cannot move %d at %d toward objective; func=%d\n", obj->type,
             tmp___0, obj->func);
      }
    }
  } else {
    {
#line 1030
    move_obj(obj, new_loc);
    }
  }
#line 1033
  if (reuse) {
    {
#line 1033
    tmp___2 = obj_moves(obj);
    }
#line 1033
    if (obj->moved < tmp___2) {
#line 1033
      if (obj->loc != old_dest) {
        {
#line 1037
        if (obj->type == 1) {
#line 1037
          goto case_1___0;
        }
#line 1044
        if (obj->type == 0) {
#line 1044
          goto case_0___0;
        }
#line 1049
        if (obj->type == 5) {
#line 1049
          goto case_5;
        }
#line 1054
        goto switch_default___0;
        case_1___0: /* CIL Label */ 
#line 1038
        if ((int )comp_map[old_dest].contents != 88) {
#line 1038
          if ((long )obj->range <= piece_attr[1].range / 2L) {
#line 1040
            return;
          }
        }
#line 1041
        attack_list = fighter_attack;
#line 1042
        terrain = (char *)"+.";
#line 1043
        goto switch_break___0;
        case_0___0: /* CIL Label */ 
#line 1045
        attack_list = army_attack;
#line 1046
        if (obj->ship) {
#line 1046
          terrain = (char *)"+*";
        } else {
#line 1047
          terrain = (char *)"+.*";
        }
#line 1048
        goto switch_break___0;
        case_5: /* CIL Label */ 
#line 1050
        terrain = (char *)".*";
#line 1051
        if (obj->cargo) {
#line 1051
          attack_list = tt_attack;
        } else {
#line 1052
          attack_list = (char *)"*O";
        }
#line 1053
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
#line 1055
        attack_list = ship_attack;
#line 1056
        terrain = (char *)".";
#line 1057
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
        {
#line 1059
        tmp___1 = find_attack(obj->loc, attack_list, terrain);
        }
#line 1059
        if (tmp___1 != obj->loc) {
#line 1060
          return;
        }
#line 1063
        (pathmap + old_loc)->terrain = (char)0;
#line 1064
        d = 0;
        {
#line 1064
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1064
          if (! (d < 8)) {
#line 1064
            goto while_break;
          }
#line 1065
          new_loc = old_loc + (loc_t )dir_offset[d];
#line 1066
          (pathmap + new_loc)->terrain = (char)0;
#line 1064
          d ++;
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 1069
        move_objective(obj, pathmap, old_dest, adj_list);
        }
      }
    }
  }
#line 1071
  return;
}
}
#line 1080 "/home/june/repo/benchmarks/collector/temp/empire-1.11/compmove.c"
void check_endgame(void) 
{ 
  int nuser_city ;
  int ncomp_city ;
  int nuser_army ;
  int ncomp_army ;
  piece_info_t *p ;
  int i ;
  char tmp ;

  {
#line 1088
  date ++;
#line 1089
  if (win != 0) {
#line 1089
    return;
  }
#line 1091
  nuser_city = 0;
#line 1092
  ncomp_city = 0;
#line 1093
  nuser_army = 0;
#line 1094
  ncomp_army = 0;
#line 1096
  i = 0;
  {
#line 1096
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1096
    if (! (i < 70)) {
#line 1096
      goto while_break;
    }
#line 1097
    if ((int )city[i].owner == 1) {
#line 1097
      nuser_city ++;
    } else
#line 1098
    if ((int )city[i].owner == 2) {
#line 1098
      ncomp_city ++;
    }
#line 1096
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1101
  p = user_obj[0];
  {
#line 1101
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1101
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 1101
      goto while_break___0;
    }
#line 1102
    nuser_army ++;
#line 1101
    p = p->piece_link.next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1104
  p = comp_obj[0];
  {
#line 1104
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1104
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 1104
      goto while_break___1;
    }
#line 1105
    ncomp_army ++;
#line 1104
    p = p->piece_link.next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1107
  if (ncomp_city < nuser_city / 3) {
#line 1107
    if (ncomp_army < nuser_army / 3) {
      {
#line 1108
      clear_screen();
#line 1109
      prompt((char *)"The computer acknowledges defeat. Do");
#line 1110
      ksend((char *)"The computer acknowledges defeat.");
#line 1111
      error((char *)"you wish to smash the rest of the enemy?");
#line 1113
      tmp = get_chx();
      }
#line 1113
      if ((int )tmp != 89) {
        {
#line 1113
        empend();
        }
      }
      {
#line 1114
      announce((char *)"\nThe enemy inadvertantly revealed its code used for");
#line 1115
      announce((char *)"\nreceiving battle information. You can display what");
#line 1116
      announce((char *)"\nthey\'ve learned with the \'\'E\'\' command.");
#line 1117
      resigned = (_Bool)1;
#line 1118
      win = 2;
#line 1119
      automove = (_Bool)0;
      }
    } else {
#line 1107
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1121
  if (ncomp_city == 0) {
#line 1121
    if (ncomp_army == 0) {
      {
#line 1122
      clear_screen();
#line 1123
      announce((char *)"The enemy is incapable of defeating you.\n");
#line 1124
      announce((char *)"You are free to rape the empire as you wish.\n");
#line 1125
      announce((char *)"There may be, however, remnants of the enemy fleet\n");
#line 1126
      announce((char *)"to be routed out and destroyed.\n");
#line 1127
      win = 1;
#line 1128
      automove = (_Bool)0;
      }
    } else {
#line 1121
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1130
  if (nuser_city == 0) {
#line 1130
    if (nuser_army == 0) {
      {
#line 1131
      clear_screen();
#line 1132
      announce((char *)"You have been rendered incapable of\n");
#line 1133
      announce((char *)"defeating the rampaging enemy fascists! The\n");
#line 1134
      announce((char *)"empire is lost. If you have any ships left, you\n");
#line 1135
      announce((char *)"may attempt to harass enemy shipping.");
#line 1136
      win = 1;
#line 1137
      automove = (_Bool)0;
      }
    }
  }
#line 1139
  return;
}
}
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 228 "/home/june/repo/benchmarks/collector/temp/empire-1.11/extern.h"
void check(void) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/empire-1.11/util.c"
void assert(char *expression , char *file , int line ) 
{ 
  char buf[80] ;
  __pid_t tmp ;

  {
  {
#line 30
  wmove(stdscr, lines, 0);
#line 31
  close_disp();
#line 33
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"assert failed: file %s line %d: %s",
          file, line, expression);
#line 36
  tmp = getpid();
#line 36
  kill(tmp, 11);
  }
#line 37
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/empire-1.11/util.c"
void empend(void) 
{ 


  {
  {
#line 46
  close_disp();
#line 47
  exit(0);
  }
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/empire-1.11/util.c"
static _Bool in_free[5000]  ;
#line 76 "/home/june/repo/benchmarks/collector/temp/empire-1.11/util.c"
static _Bool in_obj[5000]  ;
#line 77 "/home/june/repo/benchmarks/collector/temp/empire-1.11/util.c"
static _Bool in_loc[5000]  ;
#line 78 "/home/june/repo/benchmarks/collector/temp/empire-1.11/util.c"
static _Bool in_cargo[5000]  ;
#line 83
void check_cargo(piece_info_t *list , int cargo_type ) ;
#line 83
void check_obj(piece_info_t **list , int owner ) ;
#line 83
void check_obj_cargo(piece_info_t **list ) ;
#line 80 "/home/june/repo/benchmarks/collector/temp/empire-1.11/util.c"
void check(void) 
{ 
  long i ;
  long j ;
  piece_info_t *p ;
  int tmp ;

  {
#line 89
  i = 0L;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! (i < 5000L)) {
#line 89
      goto while_break;
    }
#line 90
    in_free[i] = (_Bool)0;
#line 91
    in_obj[i] = (_Bool)0;
#line 92
    in_loc[i] = (_Bool)0;
#line 93
    in_cargo[i] = (_Bool)0;
#line 89
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  p = free_list;
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 99
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 99
      goto while_break___0;
    }
#line 100
    i = p - object;
#line 101
    if (! (! in_free[i])) {
      {
#line 101
      assert((char *)"x", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/util.c",
             101);
      }
    }
#line 102
    in_free[i] = (_Bool)1;
#line 103
    if (! ((int )p->hits == 0)) {
      {
#line 103
      assert((char *)"x", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/util.c",
             103);
      }
    }
#line 104
    if (p->piece_link.prev) {
#line 105
      if (! ((unsigned long )(p->piece_link.prev)->piece_link.next == (unsigned long )p)) {
        {
#line 105
        assert((char *)"x", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/util.c",
               105);
        }
      }
    }
#line 99
    p = p->piece_link.next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 113
  i = 0L;
  {
#line 113
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 113
    if (! (i < 6000L)) {
#line 113
      goto while_break___1;
    }
#line 114
    if (map[i].cityp) {
#line 114
      if (! ((map[i].cityp)->loc == i)) {
        {
#line 114
        assert((char *)"x", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/util.c",
               114);
        }
      }
    }
#line 116
    p = map[i].objp;
    {
#line 116
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 116
      if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 116
        goto while_break___2;
      }
#line 117
      if (! (p->loc == i)) {
        {
#line 117
        assert((char *)"x", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/util.c",
               117);
        }
      }
#line 118
      if (! ((int )p->hits > 0)) {
        {
#line 118
        assert((char *)"x", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/util.c",
               118);
        }
      }
#line 119
      if (! (p->owner == 1)) {
#line 119
        if (! (p->owner == 2)) {
          {
#line 119
          assert((char *)"x", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/util.c",
                 119);
          }
        }
      }
#line 121
      j = p - object;
#line 122
      if (! (! in_loc[j])) {
        {
#line 122
        assert((char *)"x", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/util.c",
               122);
        }
      }
#line 123
      in_loc[j] = (_Bool)1;
#line 125
      if (p->loc_link.prev) {
#line 126
        if (! ((unsigned long )(p->loc_link.prev)->loc_link.next == (unsigned long )p)) {
          {
#line 126
          assert((char *)"x", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/util.c",
                 126);
          }
        }
      }
#line 116
      p = p->loc_link.next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 113
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 132
  i = 0L;
  {
#line 132
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 132
    if (! (i < 70L)) {
#line 132
      goto while_break___3;
    }
#line 133
    if (! ((unsigned long )map[city[i].loc].cityp == (unsigned long )(& city[i]))) {
      {
#line 133
      assert((char *)"x", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/util.c",
             133);
      }
    }
#line 132
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 137
  check_obj(comp_obj, 2);
#line 138
  check_obj(user_obj, 1);
#line 142
  check_cargo(user_obj[5], 0);
#line 143
  check_cargo(comp_obj[5], 0);
#line 144
  check_cargo(user_obj[6], 1);
#line 145
  check_cargo(comp_obj[6], 1);
#line 149
  check_obj_cargo(comp_obj);
#line 150
  check_obj_cargo(user_obj);
#line 154
  i = 0L;
  }
  {
#line 154
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 154
    if (! (i < 5000L)) {
#line 154
      goto while_break___4;
    }
#line 155
    if (in_loc[i]) {
#line 155
      if (in_obj[i]) {
#line 155
        tmp = 1;
      } else {
#line 155
        tmp = 0;
      }
    } else {
#line 155
      tmp = 0;
    }
#line 155
    if (! ((int )in_free[i] != tmp)) {
      {
#line 155
      assert((char *)"x", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/util.c",
             155);
      }
    }
#line 154
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 156
  return;
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/empire-1.11/util.c"
void check_obj(piece_info_t **list , int owner ) 
{ 
  long i ;
  long j ;
  piece_info_t *p ;

  {
#line 176
  i = 0L;
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    if (! (i < 9L)) {
#line 176
      goto while_break;
    }
#line 177
    p = *(list + i);
    {
#line 177
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 177
      if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 177
        goto while_break___0;
      }
#line 178
      if (! (p->owner == owner)) {
        {
#line 178
        assert((char *)"x", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/util.c",
               178);
        }
      }
#line 179
      if (! ((long )p->type == i)) {
        {
#line 179
        assert((char *)"x", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/util.c",
               179);
        }
      }
#line 180
      if (! ((int )p->hits > 0)) {
        {
#line 180
        assert((char *)"x", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/util.c",
               180);
        }
      }
#line 182
      j = p - object;
#line 183
      if (! (! in_obj[j])) {
        {
#line 183
        assert((char *)"x", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/util.c",
               183);
        }
      }
#line 184
      in_obj[j] = (_Bool)1;
#line 186
      if (p->piece_link.prev) {
#line 187
        if (! ((unsigned long )(p->piece_link.prev)->piece_link.next == (unsigned long )p)) {
          {
#line 187
          assert((char *)"x", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/util.c",
                 187);
          }
        }
      }
#line 177
      p = p->piece_link.next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 176
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 189
  return;
}
}
#line 211 "/home/june/repo/benchmarks/collector/temp/empire-1.11/util.c"
void check_cargo(piece_info_t *list , int cargo_type ) 
{ 
  piece_info_t *p ;
  piece_info_t *q ;
  long j ;
  long count ;

  {
#line 217
  p = list;
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
#line 217
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 217
      goto while_break;
    }
#line 218
    count = 0L;
#line 219
    q = p->cargo;
    {
#line 219
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 219
      if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 219
        goto while_break___0;
      }
#line 220
      count ++;
#line 221
      if (! (q->type == cargo_type)) {
        {
#line 221
        assert((char *)"x", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/util.c",
               221);
        }
      }
#line 222
      if (! (q->owner == p->owner)) {
        {
#line 222
        assert((char *)"x", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/util.c",
               222);
        }
      }
#line 223
      if (! ((int )q->hits > 0)) {
        {
#line 223
        assert((char *)"x", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/util.c",
               223);
        }
      }
#line 224
      if (! ((unsigned long )q->ship == (unsigned long )p)) {
        {
#line 224
        assert((char *)"x", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/util.c",
               224);
        }
      }
#line 225
      if (! (q->loc == p->loc)) {
        {
#line 225
        assert((char *)"x", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/util.c",
               225);
        }
      }
#line 227
      j = q - object;
#line 228
      if (! (! in_cargo[j])) {
        {
#line 228
        assert((char *)"x", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/util.c",
               228);
        }
      }
#line 229
      in_cargo[j] = (_Bool)1;
#line 231
      if (p->cargo_link.prev) {
#line 232
        if (! ((unsigned long )(p->cargo_link.prev)->cargo_link.next == (unsigned long )p)) {
          {
#line 232
          assert((char *)"x", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/util.c",
                 232);
          }
        }
      }
#line 219
      q = q->cargo_link.next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 234
    if (! (count == (long )p->count)) {
      {
#line 234
      assert((char *)"x", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/util.c",
             234);
      }
    }
#line 217
    p = p->piece_link.next;
  }
  while_break: /* CIL Label */ ;
  }
#line 236
  return;
}
}
#line 244 "/home/june/repo/benchmarks/collector/temp/empire-1.11/util.c"
void check_obj_cargo(piece_info_t **list ) 
{ 
  piece_info_t *p ;
  long i ;

  {
#line 250
  i = 0L;
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    if (! (i < 9L)) {
#line 250
      goto while_break;
    }
#line 251
    p = *(list + i);
    {
#line 251
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 251
      if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 251
        goto while_break___0;
      }
#line 252
      if (p->ship) {
#line 252
        if (! in_cargo[p - object]) {
          {
#line 252
          assert((char *)"x", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/util.c",
                 252);
          }
        }
      }
#line 251
      p = p->piece_link.next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 250
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 254
  return;
}
}
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 181 "/home/june/repo/benchmarks/collector/temp/empire-1.11/extern.h"
void rndini(void) ;
#line 184
int isqrt(int n ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/empire-1.11/math.c"
void rndini(void) 
{ 
  time_t tmp ;

  {
  {
#line 30
  tmp = time((time_t *)0);
#line 30
  srand((unsigned int )(tmp & 65535L));
  }
#line 31
  return;
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/empire-1.11/math.c"
long irand(long high ) 
{ 
  int tmp ;

  {
#line 35
  if (high < 2L) {
#line 36
    return (0L);
  }
  {
#line 38
  tmp = rand();
  }
#line 38
  return ((long )tmp % high);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/empire-1.11/math.c"
int dist(long a , long b ) 
{ 
  int ax ;
  int ay ;
  int bx ;
  int by ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 65
  ax = (int )(a / 100L);
#line 66
  ay = (int )(a % 100L);
#line 67
  bx = (int )(b / 100L);
#line 68
  by = (int )(b % 100L);
#line 70
  if (ax - bx < 0) {
#line 70
    tmp___4 = - (ax - bx);
  } else {
#line 70
    tmp___4 = ax - bx;
  }
#line 70
  if (ay - by < 0) {
#line 70
    tmp___5 = - (ay - by);
  } else {
#line 70
    tmp___5 = ay - by;
  }
#line 70
  if (tmp___4 > tmp___5) {
#line 70
    if (ax - bx < 0) {
#line 70
      tmp___1 = - (ax - bx);
    } else {
#line 70
      tmp___1 = ax - bx;
    }
#line 70
    tmp___3 = tmp___1;
  } else {
#line 70
    if (ay - by < 0) {
#line 70
      tmp___2 = - (ay - by);
    } else {
#line 70
      tmp___2 = ay - by;
    }
#line 70
    tmp___3 = tmp___2;
  }
#line 70
  return (tmp___3);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/empire-1.11/math.c"
int isqrt(int n ) 
{ 
  int guess ;

  {
#line 82
  if (! (n >= 0)) {
    {
#line 82
    assert((char *)"x", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/math.c",
           82);
    }
  }
#line 84
  if (n <= 1) {
#line 84
    return (n);
  }
#line 86
  guess = 2;
#line 87
  guess = (guess + n / guess) / 2;
#line 88
  guess = (guess + n / guess) / 2;
#line 89
  guess = (guess + n / guess) / 2;
#line 90
  guess = (guess + n / guess) / 2;
#line 91
  guess = (guess + n / guess) / 2;
#line 93
  if (guess * guess > n) {
#line 93
    guess --;
  }
#line 94
  return (guess);
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/empire-1.11/extern.h"
move_info_t user_army ;
#line 60
move_info_t user_army_attack ;
#line 61
move_info_t user_fighter ;
#line 62
move_info_t user_ship ;
#line 63
move_info_t user_ship_repair ;
#line 67
char *help_user[22] ;
#line 70
int user_lines ;
#line 113
void user_move(void) ;
#line 114
void edit(long edit_cursor ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c"
void fatal(piece_info_t *obj , loc_t loc , char *message , char *response ) ;
#line 19
void move_to_dest(piece_info_t *obj , loc_t dest ) ;
#line 20
void move_army_to_city(piece_info_t *obj , loc_t city_loc ) ;
#line 21
_Bool awake(piece_info_t *obj ) ;
#line 27
void piece_move(piece_info_t *obj ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c"
void user_move(void) 
{ 
  int i ;
  int j ;
  int sec ;
  int sec_start ;
  piece_info_t *obj ;
  piece_info_t *next_obj ;
  int prod ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;

  {
#line 40
  i = 0;
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    if (! (i < 9)) {
#line 40
      goto while_break;
    }
#line 41
    obj = user_obj[i];
    {
#line 41
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 41
      if (! ((unsigned long )obj != (unsigned long )((void *)0))) {
#line 41
        goto while_break___0;
      }
      {
#line 42
      obj->moved = 0;
#line 43
      scan(user_map, obj->loc);
#line 41
      obj = obj->piece_link.next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 40
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 47
  i = 0;
  {
#line 47
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 47
    if (! (i < 70)) {
#line 47
      goto while_break___1;
    }
#line 48
    if ((int )city[i].owner == 1) {
      {
#line 49
      scan(user_map, city[i].loc);
#line 50
      prod = (int )city[i].prod;
      }
#line 52
      if (prod == -1) {
        {
#line 53
        set_prod(& city[i]);
        }
      } else {
#line 55
        tmp___1 = city[i].work;
#line 55
        (city[i].work) ++;
#line 55
        if (tmp___1 >= (long )piece_attr[prod].build_time) {
          {
#line 57
          tmp = loc_disp((int )city[i].loc);
#line 57
          ksend((char *)"%s has been completed at city %d.\n", piece_attr[prod].article,
                tmp);
#line 59
          tmp___0 = loc_disp((int )city[i].loc);
#line 59
          comment((char *)"%s has been completed at city %d.\n", piece_attr[prod].article,
                  tmp___0);
#line 61
          produce(& city[i]);
          }
        }
      }
    }
#line 47
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 67
  obj = user_obj[8];
  {
#line 67
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 67
    if (! ((unsigned long )obj != (unsigned long )((void *)0))) {
#line 67
      goto while_break___2;
    }
    {
#line 68
    next_obj = obj->piece_link.next;
#line 69
    move_sat(obj);
#line 67
    obj = next_obj;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 72
  sec_start = cur_sector();
  }
#line 73
  if (sec_start == -1) {
#line 73
    sec_start = 0;
  }
#line 76
  i = sec_start;
  {
#line 76
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 76
    if (! (i < sec_start + 10)) {
#line 76
      goto while_break___3;
    }
    {
#line 77
    sec = i % 10;
#line 78
    sector_change();
#line 80
    j = 0;
    }
    {
#line 80
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 80
      if (! (j < 9)) {
#line 80
        goto while_break___4;
      }
#line 81
      obj = user_obj[move_order[j]];
      {
#line 81
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 81
        if (! ((unsigned long )obj != (unsigned long )((void *)0))) {
#line 81
          goto while_break___5;
        }
#line 83
        next_obj = obj->piece_link.next;
#line 85
        if (! obj->moved) {
#line 86
          if ((int )(((obj->loc % 100L) / 50L) * 5L + (obj->loc / 100L) / 12L) == sec) {
            {
#line 87
            piece_move(obj);
            }
          }
        }
#line 81
        obj = next_obj;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 80
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 89
    tmp___2 = cur_sector();
    }
#line 89
    if (tmp___2 == sec) {
      {
#line 90
      print_sector(1, user_map, sec);
#line 91
      redisplay();
      }
    }
#line 76
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 94
  if (save_movie) {
    {
#line 94
    save_movie_screen();
    }
  }
#line 95
  return;
}
}
#line 107
void move_random(piece_info_t *obj ) ;
#line 107
void move_fill(piece_info_t *obj ) ;
#line 107
void move_land(piece_info_t *obj ) ;
#line 107
void move_explore(piece_info_t *obj ) ;
#line 108
void move_path(piece_info_t *obj ) ;
#line 108
void move_dir(piece_info_t *obj ) ;
#line 108
void move_armyload(piece_info_t *obj ) ;
#line 108
void ask_user(piece_info_t *obj ) ;
#line 109
void move_armyattack(piece_info_t *obj ) ;
#line 109
void move_ttload(piece_info_t *obj ) ;
#line 109
void move_repair(piece_info_t *obj ) ;
#line 110
void move_transport(piece_info_t *obj ) ;
#line 104 "/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c"
void piece_move(piece_info_t *obj ) 
{ 
  _Bool changed_loc ;
  int speed ;
  int max_hits ;
  int saved_moves ;
  _Bool need_input ;
  loc_t saved_loc ;
  city_info_t *cityp ;
  _Bool tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 120
  cityp = find_city(obj->loc);
  }
#line 121
  if ((unsigned long )cityp != (unsigned long )((void *)0)) {
#line 122
    if (cityp->func[obj->type] != -1L) {
#line 123
      obj->func = cityp->func[obj->type];
    }
  }
#line 125
  changed_loc = (_Bool)0;
#line 126
  speed = (int )piece_attr[obj->type].speed;
#line 127
  max_hits = (int )piece_attr[obj->type].max_hits;
#line 128
  need_input = (_Bool)0;
  {
#line 130
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 130
    tmp___1 = obj_moves(obj);
    }
#line 130
    if (! (obj->moved < tmp___1)) {
#line 130
      goto while_break;
    }
    {
#line 131
    saved_moves = obj->moved;
#line 132
    saved_loc = obj->loc;
#line 134
    tmp = awake(obj);
    }
#line 134
    if (tmp) {
      {
#line 135
      ask_user(obj);
#line 136
      topini();
#line 137
      display_loc(1, user_map, obj->loc);
#line 138
      redisplay();
#line 139
      need_input = (_Bool)0;
      }
    } else
#line 134
    if (need_input) {
      {
#line 135
      ask_user(obj);
#line 136
      topini();
#line 137
      display_loc(1, user_map, obj->loc);
#line 138
      redisplay();
#line 139
      need_input = (_Bool)0;
      }
    }
#line 142
    if (obj->moved == saved_moves) {
      {
#line 144
      if (obj->func == -1L) {
#line 144
        goto case_neg_1;
      }
#line 145
      if (obj->func == -2L) {
#line 145
        goto case_neg_2;
      }
#line 146
      if (obj->func == -3L) {
#line 146
        goto case_neg_3;
      }
#line 147
      if (obj->func == -4L) {
#line 147
        goto case_neg_4;
      }
#line 148
      if (obj->func == -5L) {
#line 148
        goto case_neg_5;
      }
#line 149
      if (obj->func == -6L) {
#line 149
        goto case_neg_6;
      }
#line 150
      if (obj->func == -7L) {
#line 150
        goto case_neg_7;
      }
#line 151
      if (obj->func == -8L) {
#line 151
        goto case_neg_8;
      }
#line 152
      if (obj->func == -9L) {
#line 152
        goto case_neg_9;
      }
#line 153
      if (obj->func == -10L) {
#line 153
        goto case_neg_10;
      }
#line 154
      if (obj->func == -11L) {
#line 154
        goto case_neg_11;
      }
#line 163
      if (obj->func == -19L) {
#line 163
        goto case_neg_19;
      }
#line 163
      if (obj->func == -18L) {
#line 163
        goto case_neg_19;
      }
#line 163
      if (obj->func == -17L) {
#line 163
        goto case_neg_19;
      }
#line 163
      if (obj->func == -16L) {
#line 163
        goto case_neg_19;
      }
#line 163
      if (obj->func == -15L) {
#line 163
        goto case_neg_19;
      }
#line 163
      if (obj->func == -14L) {
#line 163
        goto case_neg_19;
      }
#line 163
      if (obj->func == -13L) {
#line 163
        goto case_neg_19;
      }
#line 163
      if (obj->func == -12L) {
#line 163
        goto case_neg_19;
      }
#line 166
      goto switch_default;
      case_neg_1: /* CIL Label */ 
#line 144
      goto switch_break;
      case_neg_2: /* CIL Label */ 
      {
#line 145
      move_random(obj);
      }
#line 145
      goto switch_break;
      case_neg_3: /* CIL Label */ 
#line 146
      obj->moved = speed;
#line 146
      goto switch_break;
      case_neg_4: /* CIL Label */ 
      {
#line 147
      move_fill(obj);
      }
#line 147
      goto switch_break;
      case_neg_5: /* CIL Label */ 
      {
#line 148
      move_land(obj);
      }
#line 148
      goto switch_break;
      case_neg_6: /* CIL Label */ 
      {
#line 149
      move_explore(obj);
      }
#line 149
      goto switch_break;
      case_neg_7: /* CIL Label */ 
      {
#line 150
      move_armyload(obj);
      }
#line 150
      goto switch_break;
      case_neg_8: /* CIL Label */ 
      {
#line 151
      move_armyattack(obj);
      }
#line 151
      goto switch_break;
      case_neg_9: /* CIL Label */ 
      {
#line 152
      move_ttload(obj);
      }
#line 152
      goto switch_break;
      case_neg_10: /* CIL Label */ 
      {
#line 153
      move_repair(obj);
      }
#line 153
      goto switch_break;
      case_neg_11: /* CIL Label */ 
      {
#line 154
      move_transport(obj);
      }
#line 154
      goto switch_break;
      case_neg_19: /* CIL Label */ 
      case_neg_18: /* CIL Label */ 
      case_neg_17: /* CIL Label */ 
      case_neg_16: /* CIL Label */ 
      case_neg_15: /* CIL Label */ 
      case_neg_14: /* CIL Label */ 
      case_neg_13: /* CIL Label */ 
      case_neg_12: /* CIL Label */ 
      {
#line 164
      move_dir(obj);
      }
#line 164
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 166
      move_path(obj);
      }
#line 166
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 169
    if (obj->moved == saved_moves) {
#line 169
      need_input = (_Bool)1;
    }
#line 175
    if (obj->type == 1) {
#line 175
      if ((int )obj->hits > 0) {
#line 176
        if ((int )user_map[obj->loc].contents == 79) {
#line 176
          goto _L___0;
        } else
#line 176
        if ((int )user_map[obj->loc].contents == 67) {
          _L___0: /* CIL Label */ 
#line 176
          if (obj->moved > 0) {
            {
#line 179
            obj->range = (short )piece_attr[1].range;
#line 180
            obj->moved = speed;
#line 181
            obj->func = -1L;
#line 182
            comment((char *)"Landing confirmed.");
            }
          } else {
#line 176
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 184
        if ((int )obj->range == 0) {
          {
#line 185
          tmp___0 = loc_disp((int )obj->loc);
#line 185
          comment((char *)"Fighter at %d crashed and burned.", tmp___0);
#line 186
          kill_obj(obj, obj->loc);
          }
        }
      }
    }
#line 190
    if (saved_loc != obj->loc) {
#line 190
      changed_loc = (_Bool)1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  if ((int )obj->hits > 0) {
#line 193
    if (! changed_loc) {
#line 193
      if (obj->type != 0) {
#line 193
        if (obj->type != 1) {
#line 193
          if ((int )obj->hits < max_hits) {
#line 193
            if ((int )user_map[obj->loc].contents == 79) {
#line 198
              obj->hits = (short )((int )obj->hits + 1);
            }
          }
        }
      }
    }
  }
#line 199
  return;
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c"
void move_random(piece_info_t *obj ) 
{ 
  loc_t loc_list[8] ;
  int i ;
  int nloc ;
  loc_t loc ;
  _Bool tmp ;
  long tmp___0 ;

  {
#line 213
  nloc = 0;
#line 215
  i = 0;
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    if (! (i < 8)) {
#line 215
      goto while_break;
    }
    {
#line 216
    loc = obj->loc + (loc_t )dir_offset[i];
#line 217
    tmp = good_loc(obj, loc);
    }
#line 217
    if (tmp) {
#line 218
      loc_list[nloc] = loc;
#line 219
      nloc ++;
    }
#line 215
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  if (nloc == 0) {
#line 222
    return;
  }
  {
#line 223
  tmp___0 = irand((long )nloc - 1L);
#line 223
  i = (int )tmp___0;
#line 224
  move_obj(obj, loc_list[i]);
  }
#line 225
  return;
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c"
void move_explore(piece_info_t *obj ) 
{ 
  path_map_t path_map___0[6000] ;
  loc_t loc ;
  char *terrain ;

  {
  {
#line 240
  if (obj->type == 0) {
#line 240
    goto case_0;
  }
#line 244
  if (obj->type == 1) {
#line 244
    goto case_1;
  }
#line 248
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 241
  loc = vmap_find_lobj(path_map___0, user_map, obj->loc, & user_army);
#line 242
  terrain = (char *)"+";
  }
#line 243
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 245
  loc = vmap_find_aobj(path_map___0, user_map, obj->loc, & user_fighter);
#line 246
  terrain = (char *)"+.O";
  }
#line 247
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 249
  loc = vmap_find_wobj(path_map___0, user_map, obj->loc, & user_ship);
#line 250
  terrain = (char *)".O";
  }
#line 251
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 254
  if (loc == obj->loc) {
#line 254
    return;
  }
#line 256
  if ((int )user_map[loc].contents == 32) {
#line 256
    if (path_map___0[loc].cost == 2) {
      {
#line 257
      vmap_mark_adjacent(path_map___0, obj->loc);
      }
    } else {
      {
#line 258
      vmap_mark_path(path_map___0, user_map, loc);
      }
    }
  } else {
    {
#line 258
    vmap_mark_path(path_map___0, user_map, loc);
    }
  }
  {
#line 260
  loc = vmap_find_dir(path_map___0, user_map, obj->loc, terrain, (char *)" ");
  }
#line 261
  if (loc != obj->loc) {
    {
#line 261
    move_obj(obj, loc);
    }
  }
#line 262
  return;
}
}
#line 270 "/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c"
void move_transport(piece_info_t *obj ) 
{ 
  loc_t loc ;

  {
  {
#line 276
  loc = find_transport(1, obj->loc);
  }
#line 278
  if (loc != obj->loc) {
    {
#line 279
    move_obj(obj, loc);
#line 280
    obj->func = -1L;
    }
  } else {
#line 282
    obj->moved = (int )piece_attr[obj->type].speed;
  }
#line 283
  return;
}
}
#line 291 "/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c"
static view_map_t amap___0[6000]  ;
#line 293 "/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c"
void move_armyload(piece_info_t *obj ) 
{ 
  loc_t loc ;
  piece_info_t *p ;
  int i ;
  int tmp ;

  {
  {
#line 299
  assert((char *)"aborting", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c",
         299);
#line 302
  loc = find_transport(1, obj->loc);
  }
#line 304
  if (loc != obj->loc) {
    {
#line 305
    move_obj(obj, loc);
#line 306
    obj->func = -1L;
    }
  } else {
    {
#line 310
    memcpy((void */* __restrict  */)(amap___0), (void const   */* __restrict  */)(user_map),
           sizeof(view_map_t ) * 6000UL);
#line 313
    p = user_obj[5];
    }
    {
#line 313
    while (1) {
      while_continue: /* CIL Label */ ;
#line 313
      if (! p) {
#line 313
        goto while_break;
      }
      {
#line 314
      tmp = obj_capacity(p);
      }
#line 314
      if ((int )p->count < tmp) {
#line 315
        amap___0[p->loc].contents = (char )'$';
      }
#line 313
      p = p->piece_link.next;
    }
    while_break: /* CIL Label */ ;
    }
#line 317
    i = 0;
    {
#line 317
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 317
      if (! (i < 70)) {
#line 317
        goto while_break___0;
      }
#line 318
      if ((int )city[i].owner == 1) {
#line 318
        if ((int )city[i].prod == 5) {
#line 319
          amap___0[city[i].loc].contents = (char )'$';
        }
      }
#line 317
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 321
  return;
}
}
#line 327 "/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c"
void move_armyattack(piece_info_t *obj ) 
{ 
  path_map_t path_map___0[6000] ;
  loc_t loc ;

  {
#line 333
  if (! (obj->type == 0)) {
    {
#line 333
    assert((char *)"x", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c",
           333);
    }
  }
  {
#line 335
  loc = vmap_find_lobj(path_map___0, user_map, obj->loc, & user_army_attack);
  }
#line 337
  if (loc == obj->loc) {
#line 337
    return;
  }
  {
#line 339
  vmap_mark_path(path_map___0, user_map, loc);
#line 341
  loc = vmap_find_dir(path_map___0, user_map, obj->loc, (char *)"+", (char *)"X*a");
  }
#line 342
  if (loc != obj->loc) {
    {
#line 342
    move_obj(obj, loc);
    }
  }
#line 343
  return;
}
}
#line 345 "/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c"
void move_ttload(piece_info_t *obj ) 
{ 


  {
  {
#line 348
  assert((char *)"aborting", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c",
         348);
  }
#line 349
  return;
}
}
#line 355 "/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c"
void move_repair(piece_info_t *obj ) 
{ 
  path_map_t path_map___0[6000] ;
  loc_t loc ;

  {
#line 361
  if (! (obj->type > 1)) {
    {
#line 361
    assert((char *)"x", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c",
           361);
    }
  }
#line 363
  if ((int )obj->hits == (int )piece_attr[obj->type].max_hits) {
#line 364
    obj->func = -1L;
#line 365
    return;
  }
#line 368
  if ((int )user_map[obj->loc].contents == 79) {
#line 369
    (obj->moved) ++;
#line 370
    return;
  }
  {
#line 373
  loc = vmap_find_wobj(path_map___0, user_map, obj->loc, & user_ship_repair);
  }
#line 375
  if (loc == obj->loc) {
#line 375
    return;
  }
  {
#line 377
  vmap_mark_path(path_map___0, user_map, loc);
#line 380
  loc = vmap_find_dir(path_map___0, user_map, obj->loc, (char *)".O", (char *)".");
  }
#line 381
  if (loc != obj->loc) {
    {
#line 381
    move_obj(obj, loc);
    }
  }
#line 382
  return;
}
}
#line 390 "/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c"
void move_fill(piece_info_t *obj ) 
{ 
  int tmp ;

  {
  {
#line 392
  tmp = obj_capacity(obj);
  }
#line 392
  if ((int )obj->count == tmp) {
#line 393
    obj->func = -1L;
  } else {
#line 394
    obj->moved = (int )piece_attr[obj->type].speed;
  }
#line 395
  return;
}
}
#line 404 "/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c"
void move_land(piece_info_t *obj ) 
{ 
  long best_dist ;
  loc_t best_loc___0 ;
  long new_dist ;
  piece_info_t *p ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 412
  tmp = find_nearest_city(obj->loc, 1, & best_loc___0);
#line 412
  best_dist = (long )tmp;
#line 414
  p = user_obj[6];
  }
  {
#line 414
  while (1) {
    while_continue: /* CIL Label */ ;
#line 414
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 414
      goto while_break;
    }
    {
#line 415
    tmp___0 = dist(obj->loc, p->loc);
#line 415
    new_dist = (long )tmp___0;
    }
#line 416
    if (new_dist < best_dist) {
#line 417
      best_dist = new_dist;
#line 418
      best_loc___0 = p->loc;
    }
#line 414
    p = p->piece_link.next;
  }
  while_break: /* CIL Label */ ;
  }
#line 421
  if (best_dist == 0L) {
#line 421
    (obj->moved) ++;
  } else
#line 423
  if (best_dist <= (long )obj->range) {
    {
#line 424
    move_to_dest(obj, best_loc___0);
    }
  } else {
#line 426
    obj->func = -1L;
  }
#line 427
  return;
}
}
#line 435 "/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c"
void move_dir(piece_info_t *obj ) 
{ 
  loc_t loc ;
  int dir ;
  _Bool tmp ;

  {
  {
#line 440
  dir = (int )(- obj->func + -12L);
#line 441
  loc = obj->loc + (loc_t )dir_offset[dir];
#line 443
  tmp = good_loc(obj, loc);
  }
#line 443
  if (tmp) {
    {
#line 444
    move_obj(obj, loc);
    }
  }
#line 445
  return;
}
}
#line 454 "/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c"
void move_path(piece_info_t *obj ) 
{ 


  {
#line 456
  if (obj->loc == obj->func) {
#line 457
    obj->func = -1L;
  } else {
    {
#line 458
    move_to_dest(obj, obj->func);
    }
  }
#line 459
  return;
}
}
#line 468 "/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c"
void move_to_dest(piece_info_t *obj , loc_t dest ) 
{ 
  path_map_t path_map___0[6000] ;
  int fterrain ;
  char *mterrain ;
  loc_t new_loc ;
  _Bool tmp ;

  {
  {
#line 476
  if (obj->type == 0) {
#line 476
    goto case_0;
  }
#line 480
  if (obj->type == 1) {
#line 480
    goto case_1;
  }
#line 484
  goto switch_default;
  case_0: /* CIL Label */ 
#line 477
  fterrain = 2;
#line 478
  mterrain = (char *)"+";
#line 479
  goto switch_break;
  case_1: /* CIL Label */ 
#line 481
  fterrain = 6;
#line 482
  mterrain = (char *)"+.O";
#line 483
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 485
  fterrain = 4;
#line 486
  mterrain = (char *)".O";
#line 487
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 490
  new_loc = vmap_find_dest(path_map___0, user_map, obj->loc, dest, 1, fterrain);
  }
#line 492
  if (new_loc == obj->loc) {
#line 492
    return;
  }
  {
#line 494
  vmap_mark_path(path_map___0, user_map, dest);
#line 495
  new_loc = vmap_find_dir(path_map___0, user_map, obj->loc, mterrain, (char *)" .");
  }
#line 496
  if (new_loc == obj->loc) {
#line 496
    return;
  }
  {
#line 497
  tmp = good_loc(obj, new_loc);
  }
#line 497
  if (! tmp) {
    {
#line 497
    assert((char *)"x", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c",
           497);
    }
  }
  {
#line 498
  move_obj(obj, new_loc);
  }
#line 499
  return;
}
}
#line 507
void user_skip(piece_info_t *obj ) ;
#line 507
void user_fill(piece_info_t *obj ) ;
#line 507
void user_dir(piece_info_t *obj , int dir ) ;
#line 507
void user_set_dir(piece_info_t *obj ) ;
#line 508
void user_wake(piece_info_t *obj ) ;
#line 508
void user_set_city_func(piece_info_t *obj ) ;
#line 508
void user_cancel_auto(void) ;
#line 509
void user_redraw(void) ;
#line 509
void user_random(piece_info_t *obj ) ;
#line 509
void user_land(piece_info_t *obj ) ;
#line 509
void user_sentry(piece_info_t *obj ) ;
#line 510
void user_help(void) ;
#line 510
void reset_func(piece_info_t *obj ) ;
#line 510
void user_explore(piece_info_t *obj ) ;
#line 511
void user_build(piece_info_t *obj ) ;
#line 511
void user_transport(piece_info_t *obj ) ;
#line 512
void user_armyattack(piece_info_t *obj ) ;
#line 512
void user_repair(piece_info_t *obj ) ;
#line 505 "/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c"
void ask_user(piece_info_t *obj ) 
{ 
  char c ;

  {
  {
#line 516
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 517
    display_loc(1, user_map, obj->loc);
#line 518
    describe_obj(obj);
#line 519
    display_score();
#line 520
    display_loc(1, user_map, obj->loc);
#line 522
    c = get_chx();
    }
    {
#line 524
    if ((int )c == 81) {
#line 524
      goto case_81;
    }
#line 525
    if ((int )c == 87) {
#line 525
      goto case_87;
    }
#line 526
    if ((int )c == 69) {
#line 526
      goto case_69;
    }
#line 527
    if ((int )c == 68) {
#line 527
      goto case_68;
    }
#line 528
    if ((int )c == 67) {
#line 528
      goto case_67;
    }
#line 529
    if ((int )c == 88) {
#line 529
      goto case_88;
    }
#line 530
    if ((int )c == 90) {
#line 530
      goto case_90;
    }
#line 531
    if ((int )c == 65) {
#line 531
      goto case_65;
    }
#line 533
    if ((int )c == 74) {
#line 533
      goto case_74;
    }
#line 534
    if ((int )c == 86) {
#line 534
      goto case_86;
    }
#line 536
    if ((int )c == 32) {
#line 536
      goto case_32;
    }
#line 537
    if ((int )c == 70) {
#line 537
      goto case_70;
    }
#line 538
    if ((int )c == 73) {
#line 538
      goto case_73;
    }
#line 539
    if ((int )c == 82) {
#line 539
      goto case_82;
    }
#line 540
    if ((int )c == 83) {
#line 540
      goto case_83;
    }
#line 541
    if ((int )c == 76) {
#line 541
      goto case_76;
    }
#line 542
    if ((int )c == 71) {
#line 542
      goto case_71;
    }
#line 543
    if ((int )c == 84) {
#line 543
      goto case_84;
    }
#line 544
    if ((int )c == 85) {
#line 544
      goto case_85;
    }
#line 545
    if ((int )c == 89) {
#line 545
      goto case_89;
    }
#line 547
    if ((int )c == 66) {
#line 547
      goto case_66;
    }
#line 548
    if ((int )c == 72) {
#line 548
      goto case_72;
    }
#line 549
    if ((int )c == 75) {
#line 549
      goto case_75;
    }
#line 550
    if ((int )c == 79) {
#line 550
      goto case_79;
    }
#line 552
    if ((int )c == 80) {
#line 552
      goto case_80;
    }
#line 552
    if ((int )c == 12) {
#line 552
      goto case_80;
    }
#line 553
    if ((int )c == 63) {
#line 553
      goto case_63;
    }
#line 555
    goto switch_default;
    case_81: /* CIL Label */ 
    {
#line 524
    user_dir(obj, 7);
    }
#line 524
    return;
    case_87: /* CIL Label */ 
    {
#line 525
    user_dir(obj, 0);
    }
#line 525
    return;
    case_69: /* CIL Label */ 
    {
#line 526
    user_dir(obj, 1);
    }
#line 526
    return;
    case_68: /* CIL Label */ 
    {
#line 527
    user_dir(obj, 2);
    }
#line 527
    return;
    case_67: /* CIL Label */ 
    {
#line 528
    user_dir(obj, 3);
    }
#line 528
    return;
    case_88: /* CIL Label */ 
    {
#line 529
    user_dir(obj, 4);
    }
#line 529
    return;
    case_90: /* CIL Label */ 
    {
#line 530
    user_dir(obj, 5);
    }
#line 530
    return;
    case_65: /* CIL Label */ 
    {
#line 531
    user_dir(obj, 6);
    }
#line 531
    return;
    case_74: /* CIL Label */ 
    {
#line 533
    edit(obj->loc);
#line 533
    reset_func(obj);
    }
#line 533
    return;
    case_86: /* CIL Label */ 
    {
#line 534
    user_set_city_func(obj);
#line 534
    reset_func(obj);
    }
#line 534
    return;
    case_32: /* CIL Label */ 
    {
#line 536
    user_skip(obj);
    }
#line 536
    return;
    case_70: /* CIL Label */ 
    {
#line 537
    user_fill(obj);
    }
#line 537
    return;
    case_73: /* CIL Label */ 
    {
#line 538
    user_set_dir(obj);
    }
#line 538
    return;
    case_82: /* CIL Label */ 
    {
#line 539
    user_random(obj);
    }
#line 539
    return;
    case_83: /* CIL Label */ 
    {
#line 540
    user_sentry(obj);
    }
#line 540
    return;
    case_76: /* CIL Label */ 
    {
#line 541
    user_land(obj);
    }
#line 541
    return;
    case_71: /* CIL Label */ 
    {
#line 542
    user_explore(obj);
    }
#line 542
    return;
    case_84: /* CIL Label */ 
    {
#line 543
    user_transport(obj);
    }
#line 543
    return;
    case_85: /* CIL Label */ 
    {
#line 544
    user_repair(obj);
    }
#line 544
    return;
    case_89: /* CIL Label */ 
    {
#line 545
    user_armyattack(obj);
    }
#line 545
    return;
    case_66: /* CIL Label */ 
    {
#line 547
    user_build(obj);
    }
#line 547
    goto switch_break;
    case_72: /* CIL Label */ 
    {
#line 548
    user_help();
    }
#line 548
    goto switch_break;
    case_75: /* CIL Label */ 
    {
#line 549
    user_wake(obj);
    }
#line 549
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 550
    user_cancel_auto();
    }
#line 550
    goto switch_break;
    case_80: /* CIL Label */ 
    case_12: /* CIL Label */ 
    {
#line 552
    user_redraw();
    }
#line 552
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 553
    describe_obj(obj);
    }
#line 553
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 555
    complain();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 567 "/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c"
void reset_func(piece_info_t *obj ) 
{ 
  city_info_t *cityp ;

  {
  {
#line 572
  cityp = find_city(obj->loc);
  }
#line 574
  if ((unsigned long )cityp != (unsigned long )((void *)0)) {
#line 575
    if (cityp->func[obj->type] != -1L) {
      {
#line 576
      obj->func = cityp->func[obj->type];
#line 577
      awake(obj);
      }
    }
  }
#line 579
  return;
}
}
#line 587 "/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c"
void user_skip(piece_info_t *obj ) 
{ 


  {
#line 590
  if (obj->type == 0) {
#line 590
    if ((int )user_map[obj->loc].contents == 79) {
      {
#line 591
      move_army_to_city(obj, obj->loc);
      }
    } else {
#line 592
      (obj->moved) ++;
    }
  } else {
#line 592
    (obj->moved) ++;
  }
#line 593
  return;
}
}
#line 600 "/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c"
void user_fill(piece_info_t *obj ) 
{ 


  {
#line 603
  if (obj->type != 5) {
#line 603
    if (obj->type != 6) {
      {
#line 603
      complain();
      }
    } else {
#line 604
      obj->func = -4L;
    }
  } else {
#line 604
    obj->func = -4L;
  }
#line 605
  return;
}
}
#line 611 "/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c"
void user_help(void) 
{ 


  {
  {
#line 614
  help(help_user, user_lines);
#line 615
  prompt((char *)"Press any key to continue: ");
#line 616
  get_chx();
  }
#line 617
  return;
}
}
#line 623 "/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c"
void user_set_dir(piece_info_t *obj ) 
{ 
  char c ;

  {
  {
#line 628
  c = get_chx();
  }
  {
#line 630
  if ((int )c == 81) {
#line 630
    goto case_81;
  }
#line 631
  if ((int )c == 87) {
#line 631
    goto case_87;
  }
#line 632
  if ((int )c == 69) {
#line 632
    goto case_69;
  }
#line 633
  if ((int )c == 68) {
#line 633
    goto case_68;
  }
#line 634
  if ((int )c == 67) {
#line 634
    goto case_67;
  }
#line 635
  if ((int )c == 88) {
#line 635
    goto case_88;
  }
#line 636
  if ((int )c == 90) {
#line 636
    goto case_90;
  }
#line 637
  if ((int )c == 65) {
#line 637
    goto case_65;
  }
#line 638
  goto switch_default;
  case_81: /* CIL Label */ 
#line 630
  obj->func = -19L;
#line 630
  goto switch_break;
  case_87: /* CIL Label */ 
#line 631
  obj->func = -12L;
#line 631
  goto switch_break;
  case_69: /* CIL Label */ 
#line 632
  obj->func = -13L;
#line 632
  goto switch_break;
  case_68: /* CIL Label */ 
#line 633
  obj->func = -14L;
#line 633
  goto switch_break;
  case_67: /* CIL Label */ 
#line 634
  obj->func = -15L;
#line 634
  goto switch_break;
  case_88: /* CIL Label */ 
#line 635
  obj->func = -16L;
#line 635
  goto switch_break;
  case_90: /* CIL Label */ 
#line 636
  obj->func = -17L;
#line 636
  goto switch_break;
  case_65: /* CIL Label */ 
#line 637
  obj->func = -18L;
#line 637
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 638
  complain();
  }
#line 638
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 640
  return;
}
}
#line 646 "/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c"
void user_wake(piece_info_t *obj ) 
{ 


  {
#line 649
  obj->func = -1L;
#line 650
  return;
}
}
#line 656 "/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c"
void user_random(piece_info_t *obj ) 
{ 


  {
#line 659
  obj->func = -2L;
#line 660
  return;
}
}
#line 666 "/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c"
void user_sentry(piece_info_t *obj ) 
{ 


  {
#line 669
  obj->func = -3L;
#line 670
  return;
}
}
#line 676 "/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c"
void user_land(piece_info_t *obj ) 
{ 


  {
#line 679
  if (obj->type != 1) {
    {
#line 680
    complain();
    }
  } else {
#line 682
    obj->func = -5L;
  }
#line 683
  return;
}
}
#line 689 "/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c"
void user_explore(piece_info_t *obj ) 
{ 


  {
#line 692
  obj->func = -6L;
#line 693
  return;
}
}
#line 699 "/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c"
void user_transport(piece_info_t *obj ) 
{ 


  {
#line 702
  if (obj->type != 0) {
    {
#line 703
    complain();
    }
  } else {
#line 705
    obj->func = -11L;
  }
#line 706
  return;
}
}
#line 712 "/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c"
void user_armyattack(piece_info_t *obj ) 
{ 


  {
#line 715
  if (obj->type != 0) {
    {
#line 716
    complain();
    }
  } else {
#line 718
    obj->func = -8L;
  }
#line 719
  return;
}
}
#line 725 "/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c"
void user_repair(piece_info_t *obj ) 
{ 


  {
#line 728
  if (obj->type == 0) {
    {
#line 729
    complain();
    }
  } else
#line 728
  if (obj->type == 1) {
    {
#line 729
    complain();
    }
  } else {
#line 731
    obj->func = -10L;
  }
#line 732
  return;
}
}
#line 741
void e_city_fill(city_info_t *cityp , int type ) ;
#line 741
void e_city_explore(city_info_t *cityp , loc_t type ) ;
#line 741
void e_city_stasis(city_info_t *cityp , int type ) ;
#line 742
void e_city_wake(city_info_t *cityp , int type ) ;
#line 742
void e_city_random(city_info_t *cityp , int type ) ;
#line 742
void e_city_repair(city_info_t *cityp , int type ) ;
#line 743
void e_city_attack(city_info_t *cityp , int type ) ;
#line 738 "/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c"
void user_set_city_func(piece_info_t *obj ) 
{ 
  int type ;
  char e ;
  city_info_t *cityp ;

  {
  {
#line 749
  cityp = find_city(obj->loc);
  }
#line 750
  if (! cityp) {
    {
#line 751
    complain();
    }
#line 752
    return;
  } else
#line 750
  if ((int )cityp->owner != 1) {
    {
#line 751
    complain();
    }
#line 752
    return;
  }
  {
#line 755
  type = get_piece_name();
  }
#line 756
  if (type == -1) {
    {
#line 757
    complain();
    }
#line 758
    return;
  }
  {
#line 761
  e = get_chx();
  }
  {
#line 764
  if ((int )e == 70) {
#line 764
    goto case_70;
  }
#line 767
  if ((int )e == 71) {
#line 767
    goto case_71;
  }
#line 770
  if ((int )e == 73) {
#line 770
    goto case_73;
  }
#line 773
  if ((int )e == 75) {
#line 773
    goto case_75;
  }
#line 776
  if ((int )e == 82) {
#line 776
    goto case_82;
  }
#line 779
  if ((int )e == 85) {
#line 779
    goto case_85;
  }
#line 782
  if ((int )e == 89) {
#line 782
    goto case_89;
  }
#line 785
  goto switch_default;
  case_70: /* CIL Label */ 
  {
#line 765
  e_city_fill(cityp, type);
  }
#line 766
  goto switch_break;
  case_71: /* CIL Label */ 
  {
#line 768
  e_city_explore(cityp, type);
  }
#line 769
  goto switch_break;
  case_73: /* CIL Label */ 
  {
#line 771
  e_city_stasis(cityp, type);
  }
#line 772
  goto switch_break;
  case_75: /* CIL Label */ 
  {
#line 774
  e_city_wake(cityp, type);
  }
#line 775
  goto switch_break;
  case_82: /* CIL Label */ 
  {
#line 777
  e_city_random(cityp, type);
  }
#line 778
  goto switch_break;
  case_85: /* CIL Label */ 
  {
#line 780
  e_city_repair(cityp, type);
  }
#line 781
  goto switch_break;
  case_89: /* CIL Label */ 
  {
#line 783
  e_city_attack(cityp, type);
  }
#line 784
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 786
  complain();
  }
#line 787
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 789
  return;
}
}
#line 795 "/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c"
void user_build(piece_info_t *obj ) 
{ 
  city_info_t *cityp ;

  {
#line 800
  if ((int )user_map[obj->loc].contents != 79) {
    {
#line 801
    complain();
    }
#line 802
    return;
  }
  {
#line 804
  cityp = find_city(obj->loc);
  }
#line 805
  if (! ((unsigned long )cityp != (unsigned long )((void *)0))) {
    {
#line 805
    assert((char *)"x", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c",
           805);
    }
  }
  {
#line 806
  set_prod(cityp);
  }
#line 807
  return;
}
}
#line 817
void user_dir_army(piece_info_t *obj , loc_t loc ) ;
#line 817
void user_dir_fighter(piece_info_t *obj , loc_t loc ) ;
#line 817
void user_dir_ship(piece_info_t *obj , loc_t loc ) ;
#line 814 "/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c"
void user_dir(piece_info_t *obj , int dir ) 
{ 
  loc_t loc ;
  _Bool tmp ;

  {
  {
#line 821
  loc = obj->loc + (loc_t )dir_offset[dir];
#line 823
  tmp = good_loc(obj, loc);
  }
#line 823
  if (tmp) {
    {
#line 824
    move_obj(obj, loc);
    }
#line 825
    return;
  }
#line 827
  if (! map[loc].on_board) {
    {
#line 828
    error((char *)"You cannot move to the edge of the world.");
#line 829
    delay();
    }
#line 830
    return;
  }
  {
#line 833
  if (obj->type == 0) {
#line 833
    goto case_0;
  }
#line 834
  if (obj->type == 1) {
#line 834
    goto case_1;
  }
#line 835
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 833
  user_dir_army(obj, loc);
  }
#line 833
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 834
  user_dir_fighter(obj, loc);
  }
#line 834
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 835
  user_dir_ship(obj, loc);
  }
#line 835
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 837
  return;
}
}
#line 845 "/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c"
void user_dir_army(piece_info_t *obj , loc_t loc ) 
{ 
  _Bool enemy_killed ;
  _Bool tmp ;
  unsigned short const   **tmp___0 ;
  _Bool tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
#line 848
  if ((int )user_map[loc].contents == 79) {
    {
#line 849
    move_army_to_city(obj, loc);
    }
  } else
#line 851
  if ((int )user_map[loc].contents == 84) {
    {
#line 852
    fatal(obj, loc, (char *)"Sorry, sir.  There is no more room on the transport.  Do you insist? ",
          (char *)"Your army jumped into the briny and drowned.");
    }
  } else
#line 856
  if ((int )map[loc].contents == 46) {
    {
#line 857
    enemy_killed = (_Bool)0;
#line 859
    tmp = getyn((char *)"Troops can\'t walk on water, sir.  Do you really want to go to sea? ");
    }
#line 859
    if (! tmp) {
#line 861
      return;
    }
#line 863
    if ((int )user_map[obj->loc].contents == 84) {
      {
#line 865
      comment((char *)"Your army jumped into the briny and drowned.");
#line 866
      ksend((char *)"Your army jumped into the briny and drowned.\n");
      }
    } else
#line 868
    if ((int )user_map[loc].contents == 46) {
      {
#line 870
      comment((char *)"Your army marched dutifully into the sea and drowned.");
#line 871
      ksend((char *)"Your army marched dutifully into the sea and drowned.\n");
      }
    } else {
      {
#line 874
      tmp___0 = __ctype_b_loc();
#line 874
      enemy_killed = (_Bool )((int const   )*(*tmp___0 + (int )user_map[loc].contents) & 512);
#line 875
      attack(obj, loc);
      }
#line 877
      if ((int )obj->hits > 0) {
        {
#line 879
        comment((char *)"Your army regretfully drowns after its successful assault.");
#line 880
        ksend((char *)"Your army regretfully drowns after its successful assault.");
        }
      }
    }
#line 883
    if ((int )obj->hits > 0) {
      {
#line 884
      kill_obj(obj, loc);
      }
#line 885
      if (enemy_killed) {
        {
#line 886
        scan(comp_map, loc);
        }
      }
    }
  } else {
    {
#line 890
    tmp___2 = __ctype_b_loc();
    }
#line 890
    if ((int const   )*(*tmp___2 + (int )user_map[loc].contents) & 256) {
#line 890
      if ((int )user_map[loc].contents != 88) {
        {
#line 892
        tmp___1 = getyn((char *)"Sir, those are our men!  Do you really want to attack them? ");
        }
#line 892
        if (! tmp___1) {
#line 894
          return;
        }
        {
#line 896
        attack(obj, loc);
        }
      } else {
        {
#line 899
        attack(obj, loc);
        }
      }
    } else {
      {
#line 899
      attack(obj, loc);
      }
    }
  }
#line 900
  return;
}
}
#line 907 "/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c"
void user_dir_fighter(piece_info_t *obj , loc_t loc ) 
{ 
  _Bool tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 910
  if ((int )map[loc].contents == 42) {
    {
#line 911
    fatal(obj, loc, (char *)"That\'s never worked before, sir.  Do you really want to try? ",
          (char *)"Your fighter was shot down.");
    }
  } else {
    {
#line 915
    tmp___0 = __ctype_b_loc();
    }
#line 915
    if ((int const   )*(*tmp___0 + (int )user_map[loc].contents) & 256) {
      {
#line 916
      tmp = getyn((char *)"Sir, those are our men!  Do you really want to attack them? ");
      }
#line 916
      if (! tmp) {
#line 918
        return;
      }
      {
#line 920
      attack(obj, loc);
      }
    } else {
      {
#line 923
      attack(obj, loc);
      }
    }
  }
#line 924
  return;
}
}
#line 932 "/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c"
void user_dir_ship(piece_info_t *obj , loc_t loc ) 
{ 
  _Bool enemy_killed ;
  _Bool tmp ;
  unsigned short const   **tmp___0 ;
  _Bool tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
#line 935
  if ((int )map[loc].contents == 42) {
    {
#line 936
    sprintf((char */* __restrict  */)(jnkbuf), (char const   */* __restrict  */)"Your %s broke up on shore.",
            piece_attr[obj->type].name);
#line 939
    fatal(obj, loc, (char *)"That\'s never worked before, sir.  Do you really want to try? ",
          jnkbuf);
    }
  } else
#line 944
  if ((int )map[loc].contents == 43) {
    {
#line 945
    enemy_killed = (_Bool)0;
#line 947
    tmp = getyn((char *)"Ships need sea to float, sir.  Do you really want to go ashore? ");
    }
#line 947
    if (! tmp) {
#line 947
      return;
    }
#line 949
    if ((int )user_map[loc].contents == 43) {
      {
#line 951
      comment((char *)"Your %s broke up on shore.", piece_attr[obj->type].name);
#line 952
      ksend((char *)"Your %s broke up on shore.", piece_attr[obj->type].name);
      }
    } else {
      {
#line 955
      tmp___0 = __ctype_b_loc();
#line 955
      enemy_killed = (_Bool )((int const   )*(*tmp___0 + (int )user_map[loc].contents) & 512);
#line 956
      attack(obj, loc);
      }
#line 958
      if ((int )obj->hits > 0) {
        {
#line 960
        comment((char *)"Your %s breaks up after its successful assault.", piece_attr[obj->type].name);
#line 961
        ksend((char *)"Your %s breaks up after its successful assault.", piece_attr[obj->type].name);
        }
      }
    }
#line 964
    if ((int )obj->hits > 0) {
      {
#line 965
      kill_obj(obj, loc);
      }
#line 966
      if (enemy_killed) {
        {
#line 967
        scan(comp_map, loc);
        }
      }
    }
  } else {
    {
#line 971
    tmp___2 = __ctype_b_loc();
    }
#line 971
    if ((int const   )*(*tmp___2 + (int )user_map[loc].contents) & 256) {
      {
#line 972
      tmp___1 = getyn((char *)"Sir, those are our men!  Do you really want to attack them? ");
      }
#line 972
      if (! tmp___1) {
#line 974
        return;
      }
      {
#line 976
      attack(obj, loc);
      }
    } else {
      {
#line 979
      attack(obj, loc);
      }
    }
  }
#line 980
  return;
}
}
#line 988 "/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c"
void move_army_to_city(piece_info_t *obj , loc_t city_loc ) 
{ 
  piece_info_t *tt ;

  {
  {
#line 993
  tt = find_nfull(5, city_loc);
  }
#line 995
  if ((unsigned long )tt != (unsigned long )((void *)0)) {
    {
#line 995
    move_obj(obj, city_loc);
    }
  } else {
    {
#line 997
    fatal(obj, city_loc, (char *)"That\'s our city, sir!  Do you really want to attack the garrison? ",
          (char *)"Your rebel army was liquidated.");
    }
  }
#line 1000
  return;
}
}
#line 1006 "/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c"
void user_cancel_auto(void) 
{ 


  {
#line 1009
  if (! automove) {
    {
#line 1010
    comment((char *)"Not in auto mode!");
    }
  } else {
    {
#line 1012
    automove = (_Bool)0;
#line 1013
    comment((char *)"Auto mode cancelled.");
    }
  }
#line 1015
  return;
}
}
#line 1021 "/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c"
void user_redraw(void) 
{ 


  {
  {
#line 1024
  redraw();
  }
#line 1025
  return;
}
}
#line 1036 "/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c"
_Bool awake(piece_info_t *obj ) 
{ 
  int i ;
  char c ;
  long t ;
  _Bool tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 1043
  if (obj->type == 0) {
    {
#line 1043
    tmp = vmap_at_sea(user_map, obj->loc);
    }
#line 1043
    if (tmp) {
#line 1044
      obj->moved = (int )piece_attr[0].range;
#line 1045
      return ((_Bool)0);
    }
  }
#line 1047
  if (obj->func == -1L) {
#line 1047
    return ((_Bool)1);
  }
#line 1049
  if (obj->type == 1) {
#line 1049
    if (obj->func != -5L) {
#line 1049
      if (obj->func < 0L) {
        {
#line 1049
        tmp___0 = find_nearest_city(obj->loc, 1, & t);
        }
#line 1049
        if ((int )obj->range <= tmp___0 + 2) {
#line 1053
          obj->func = -1L;
#line 1054
          return ((_Bool)1);
        }
      }
    }
  }
#line 1056
  i = 0;
  {
#line 1056
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1056
    if (! (i < 8)) {
#line 1056
      goto while_break;
    }
    {
#line 1057
    c = user_map[obj->loc + (loc_t )dir_offset[i]].contents;
#line 1059
    tmp___1 = __ctype_b_loc();
    }
#line 1059
    if ((int const   )*(*tmp___1 + (int )c) & 512) {
#line 1059
      goto _L;
    } else
#line 1059
    if ((int )c == 42) {
#line 1059
      goto _L;
    } else
#line 1059
    if ((int )c == 88) {
      _L: /* CIL Label */ 
#line 1060
      if (obj->func < 0L) {
#line 1060
        obj->func = -1L;
      }
#line 1061
      return ((_Bool)1);
    }
#line 1056
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1064
  return ((_Bool)0);
}
}
#line 1072 "/home/june/repo/benchmarks/collector/temp/empire-1.11/usermove.c"
void fatal(piece_info_t *obj , loc_t loc , char *message , char *response ) 
{ 
  _Bool tmp ;

  {
  {
#line 1075
  tmp = getyn(message);
  }
#line 1075
  if (tmp) {
    {
#line 1076
    comment(response);
#line 1077
    kill_obj(obj, loc);
    }
  }
#line 1079
  return;
}
}
#line 27 "/home/june/repo/benchmarks/collector/temp/empire-1.11/data.c"
piece_attr_t piece_attr[9]  = 
#line 27 "/home/june/repo/benchmarks/collector/temp/empire-1.11/data.c"
  {      {(char )'A', {(char )'a', (char )'r', (char )'m', (char )'y', (char )'\000'},
      {(char )'a', (char )'r', (char )'m', (char )'y', (char )'\000'}, {(char )'a',
                                                                        (char )'n',
                                                                        (char )' ',
                                                                        (char )'a',
                                                                        (char )'r',
                                                                        (char )'m',
                                                                        (char )'y',
                                                                        (char )'\000'},
      {(char )'a', (char )'r', (char )'m', (char )'i', (char )'e', (char )'s', (char )'\000'},
      {(char )'+', (char )'\000'}, (uchar )5, (uchar )1, (uchar )1, (uchar )1, (uchar )0,
      10000000L}, 
        {(char )'F', {(char )'f', (char )'i', (char )'g', (char )'h', (char )'t', (char )'e',
                   (char )'r', (char )'\000'}, {(char )'f', (char )'i', (char )'g',
                                                (char )'h', (char )'t', (char )'e',
                                                (char )'r', (char )'\000'}, {(char )'a',
                                                                             (char )' ',
                                                                             (char )'f',
                                                                             (char )'i',
                                                                             (char )'g',
                                                                             (char )'h',
                                                                             (char )'t',
                                                                             (char )'e',
                                                                             (char )'r',
                                                                             (char )'\000'},
      {(char )'f', (char )'i', (char )'g', (char )'h', (char )'t', (char )'e', (char )'r',
       (char )'s', (char )'\000'}, {(char )'.', (char )'+', (char )'\000'}, (uchar )10,
      (uchar )1, (uchar )1, (uchar )8, (uchar )0, 32L}, 
        {(char )'P', {(char )'p', (char )'a', (char )'t', (char )'r', (char )'o', (char )'l',
                   (char )' ', (char )'b', (char )'o', (char )'a', (char )'t', (char )'\000'},
      {(char )'p', (char )'a', (char )'t', (char )'r', (char )'o', (char )'l', (char )'\000'},
      {(char )'a', (char )' ', (char )'p', (char )'a', (char )'t', (char )'r', (char )'o',
       (char )'l', (char )' ', (char )'b', (char )'o', (char )'a', (char )'t', (char )'\000'},
      {(char )'p', (char )'a', (char )'t', (char )'r', (char )'o', (char )'l', (char )' ',
       (char )'b', (char )'o', (char )'a', (char )'t', (char )'s', (char )'\000'},
      {(char )'.', (char )'\000'}, (uchar )15, (uchar )1, (uchar )1, (uchar )4, (uchar )0,
      10000000L}, 
        {(char )'D', {(char )'d', (char )'e', (char )'s', (char )'t', (char )'r', (char )'o',
                   (char )'y', (char )'e', (char )'r', (char )'\000'}, {(char )'d',
                                                                        (char )'e',
                                                                        (char )'s',
                                                                        (char )'t',
                                                                        (char )'r',
                                                                        (char )'o',
                                                                        (char )'y',
                                                                        (char )'e',
                                                                        (char )'r',
                                                                        (char )'\000'},
      {(char )'a', (char )' ', (char )'d', (char )'e', (char )'s', (char )'t', (char )'r',
       (char )'o', (char )'y', (char )'e', (char )'r', (char )'\000'}, {(char )'d',
                                                                        (char )'e',
                                                                        (char )'s',
                                                                        (char )'t',
                                                                        (char )'r',
                                                                        (char )'o',
                                                                        (char )'y',
                                                                        (char )'e',
                                                                        (char )'r',
                                                                        (char )'s',
                                                                        (char )'\000'},
      {(char )'.', (char )'\000'}, (uchar )20, (uchar )1, (uchar )3, (uchar )2, (uchar )0,
      10000000L}, 
        {(char )'S', {(char )'s', (char )'u', (char )'b', (char )'m', (char )'a', (char )'r',
                   (char )'i', (char )'n', (char )'e', (char )'\000'}, {(char )'s',
                                                                        (char )'u',
                                                                        (char )'b',
                                                                        (char )'m',
                                                                        (char )'a',
                                                                        (char )'r',
                                                                        (char )'i',
                                                                        (char )'n',
                                                                        (char )'e',
                                                                        (char )'\000'},
      {(char )'a', (char )' ', (char )'s', (char )'u', (char )'b', (char )'m', (char )'a',
       (char )'r', (char )'i', (char )'n', (char )'e', (char )'\000'}, {(char )'s',
                                                                        (char )'u',
                                                                        (char )'b',
                                                                        (char )'m',
                                                                        (char )'a',
                                                                        (char )'r',
                                                                        (char )'i',
                                                                        (char )'n',
                                                                        (char )'e',
                                                                        (char )'s',
                                                                        (char )'\000'},
      {(char )'.', (char )'\000'}, (uchar )20, (uchar )3, (uchar )2, (uchar )2, (uchar )0,
      10000000L}, 
        {(char )'T', {(char )'t', (char )'r', (char )'o', (char )'o', (char )'p', (char )' ',
                   (char )'t', (char )'r', (char )'a', (char )'n', (char )'s', (char )'p',
                   (char )'o', (char )'r', (char )'t', (char )'\000'}, {(char )'t',
                                                                        (char )'r',
                                                                        (char )'a',
                                                                        (char )'n',
                                                                        (char )'s',
                                                                        (char )'p',
                                                                        (char )'o',
                                                                        (char )'r',
                                                                        (char )'t',
                                                                        (char )'\000'},
      {(char )'a', (char )' ', (char )'t', (char )'r', (char )'o', (char )'o', (char )'p',
       (char )' ', (char )'t', (char )'r', (char )'a', (char )'n', (char )'s', (char )'p',
       (char )'o', (char )'r', (char )'t', (char )'\000'}, {(char )'t', (char )'r',
                                                            (char )'o', (char )'o',
                                                            (char )'p', (char )' ',
                                                            (char )'t', (char )'r',
                                                            (char )'a', (char )'n',
                                                            (char )'s', (char )'p',
                                                            (char )'o', (char )'r',
                                                            (char )'t', (char )'s',
                                                            (char )'\000'}, {(char )'.',
                                                                             (char )'\000'},
      (uchar )30, (uchar )1, (uchar )1, (uchar )2, (uchar )6, 10000000L}, 
        {(char )'C', {(char )'a', (char )'i', (char )'r', (char )'c', (char )'r', (char )'a',
                   (char )'f', (char )'t', (char )' ', (char )'c', (char )'a', (char )'r',
                   (char )'r', (char )'i', (char )'e', (char )'r', (char )'\000'},
      {(char )'c', (char )'a', (char )'r', (char )'r', (char )'i', (char )'e', (char )'r',
       (char )'\000'}, {(char )'a', (char )'n', (char )' ', (char )'a', (char )'i',
                        (char )'r', (char )'c', (char )'r', (char )'a', (char )'f',
                        (char )'t', (char )' ', (char )'c', (char )'a', (char )'r',
                        (char )'r', (char )'i', (char )'e', (char )'r', (char )'\000'},
      {(char )'a', (char )'i', (char )'r', (char )'c', (char )'r', (char )'a', (char )'f',
       (char )'t', (char )' ', (char )'c', (char )'a', (char )'r', (char )'r', (char )'i',
       (char )'e', (char )'r', (char )'s', (char )'\000'}, {(char )'.', (char )'\000'},
      (uchar )30, (uchar )1, (uchar )8, (uchar )2, (uchar )8, 10000000L}, 
        {(char )'B', {(char )'b', (char )'a', (char )'t', (char )'t', (char )'l', (char )'e',
                   (char )'s', (char )'h', (char )'i', (char )'p', (char )'\000'},
      {(char )'b', (char )'a', (char )'t', (char )'t', (char )'l', (char )'e', (char )'s',
       (char )'h', (char )'i', (char )'p', (char )'\000'}, {(char )'a', (char )' ',
                                                            (char )'b', (char )'a',
                                                            (char )'t', (char )'t',
                                                            (char )'l', (char )'e',
                                                            (char )'s', (char )'h',
                                                            (char )'i', (char )'p',
                                                            (char )'\000'}, {(char )'b',
                                                                             (char )'a',
                                                                             (char )'t',
                                                                             (char )'t',
                                                                             (char )'l',
                                                                             (char )'e',
                                                                             (char )'s',
                                                                             (char )'h',
                                                                             (char )'i',
                                                                             (char )'p',
                                                                             (char )'s',
                                                                             (char )'\000'},
      {(char )'.', (char )'\000'}, (uchar )40, (uchar )2, (uchar )10, (uchar )2, (uchar )0,
      10000000L}, 
        {(char )'Z', {(char )'s', (char )'a', (char )'t', (char )'e', (char )'l', (char )'l',
                   (char )'i', (char )'t', (char )'e', (char )'\000'}, {(char )'s',
                                                                        (char )'a',
                                                                        (char )'t',
                                                                        (char )'e',
                                                                        (char )'l',
                                                                        (char )'l',
                                                                        (char )'i',
                                                                        (char )'t',
                                                                        (char )'e',
                                                                        (char )'\000'},
      {(char )'a', (char )' ', (char )'s', (char )'a', (char )'t', (char )'e', (char )'l',
       (char )'l', (char )'i', (char )'t', (char )'e', (char )'\000'}, {(char )'s',
                                                                        (char )'a',
                                                                        (char )'t',
                                                                        (char )'e',
                                                                        (char )'l',
                                                                        (char )'l',
                                                                        (char )'i',
                                                                        (char )'t',
                                                                        (char )'e',
                                                                        (char )'s',
                                                                        (char )'\000'},
      {(char )'.', (char )'+', (char )'\000'}, (uchar )50, (uchar )0, (uchar )1, (uchar )10,
      (uchar )0, 500L}};
#line 74 "/home/june/repo/benchmarks/collector/temp/empire-1.11/data.c"
int dir_offset[8]  = 
#line 74
  {      -100,      -99,      1,      101, 
        100,      99,      -1,      -101};
#line 85 "/home/june/repo/benchmarks/collector/temp/empire-1.11/data.c"
char *func_name[19]  = 
#line 85
  {      (char *)"none",      (char *)"random",      (char *)"sentry",      (char *)"fill", 
        (char *)"land",      (char *)"explore",      (char *)"load",      (char *)"attack", 
        (char *)"load",      (char *)"repair",      (char *)"transport",      (char *)"W", 
        (char *)"E",      (char *)"D",      (char *)"C",      (char *)"X", 
        (char *)"Z",      (char *)"A",      (char *)"Q"};
#line 91 "/home/june/repo/benchmarks/collector/temp/empire-1.11/data.c"
int move_order[9]  = 
#line 91
  {      8,      5,      6,      7, 
        2,      4,      3,      0, 
        1};
#line 95 "/home/june/repo/benchmarks/collector/temp/empire-1.11/data.c"
char type_chars[10]  = 
#line 95
  {      (char )'A',      (char )'F',      (char )'P',      (char )'D', 
        (char )'S',      (char )'T',      (char )'C',      (char )'B', 
        (char )'Z',      (char )'\000'};
#line 99 "/home/june/repo/benchmarks/collector/temp/empire-1.11/data.c"
char tt_attack[2]  = {      (char )'T',      (char )'\000'};
#line 100 "/home/june/repo/benchmarks/collector/temp/empire-1.11/data.c"
char army_attack[11]  = 
#line 100
  {      (char )'O',      (char )'*',      (char )'T',      (char )'A', 
        (char )'C',      (char )'F',      (char )'B',      (char )'S', 
        (char )'D',      (char )'P',      (char )'\000'};
#line 101 "/home/june/repo/benchmarks/collector/temp/empire-1.11/data.c"
char fighter_attack[9]  = 
#line 101
  {      (char )'T',      (char )'C',      (char )'F',      (char )'B', 
        (char )'S',      (char )'D',      (char )'P',      (char )'A', 
        (char )'\000'};
#line 102 "/home/june/repo/benchmarks/collector/temp/empire-1.11/data.c"
char ship_attack[7]  = {      (char )'T',      (char )'C',      (char )'B',      (char )'S', 
        (char )'D',      (char )'P',      (char )'\000'};
#line 106 "/home/june/repo/benchmarks/collector/temp/empire-1.11/data.c"
move_info_t tt_explore  =    {(char)2, (char *)" ", {1}};
#line 111 "/home/june/repo/benchmarks/collector/temp/empire-1.11/data.c"
move_info_t tt_load  =    {(char)2, (char *)"$", {1}};
#line 143 "/home/june/repo/benchmarks/collector/temp/empire-1.11/data.c"
move_info_t tt_unload  =    {(char)2, (char *)"9876543210 ", {1, 1, 1, 1, 1, 1, 11, 21, 41, 101, 61}};
#line 152 "/home/june/repo/benchmarks/collector/temp/empire-1.11/data.c"
move_info_t army_fight  =    {(char)2, (char *)"O*TA ", {1, 1, 1, 1, 11}};
#line 155 "/home/june/repo/benchmarks/collector/temp/empire-1.11/data.c"
move_info_t army_load  =    {(char)2, (char *)"$x", {1, -1}};
#line 159 "/home/june/repo/benchmarks/collector/temp/empire-1.11/data.c"
move_info_t fighter_fight  =    {(char)2, (char *)"TCFBSDPA ", {1, 1, 5, 5, 5, 5, 5, 5, 9}};
#line 162 "/home/june/repo/benchmarks/collector/temp/empire-1.11/data.c"
move_info_t ship_fight  =    {(char)2, (char *)"TCBSDP ", {1, 1, 3, 3, 3, 3, 21}};
#line 165 "/home/june/repo/benchmarks/collector/temp/empire-1.11/data.c"
move_info_t ship_repair  =    {(char)2, (char *)"X", {1}};
#line 169 "/home/june/repo/benchmarks/collector/temp/empire-1.11/data.c"
move_info_t user_army  =    {(char)1, (char *)" ", {1}};
#line 172 "/home/june/repo/benchmarks/collector/temp/empire-1.11/data.c"
move_info_t user_army_attack  =    {(char)1, (char *)"*Xa ", {1, 1, 1, 12}};
#line 175 "/home/june/repo/benchmarks/collector/temp/empire-1.11/data.c"
move_info_t user_fighter  =    {(char)1, (char *)" ", {1}};
#line 178 "/home/june/repo/benchmarks/collector/temp/empire-1.11/data.c"
move_info_t user_ship  =    {(char)1, (char *)" ", {1}};
#line 181 "/home/june/repo/benchmarks/collector/temp/empire-1.11/data.c"
move_info_t user_ship_repair  =    {(char)1, (char *)"O", {1}};
#line 189 "/home/june/repo/benchmarks/collector/temp/empire-1.11/data.c"
char *help_cmd[19]  = 
#line 189
  {      (char *)"COMMAND MODE",      (char *)"Auto:     enter automove mode",      (char *)"City:     give city to computer",      (char *)"Date:     print round", 
        (char *)"Examine:  examine enemy map",      (char *)"File:     print map to file",      (char *)"Give:     give move to computer",      (char *)"Help:     display this text", 
        (char *)"J:        enter edit mode",      (char *)"Move:     make a move",      (char *)"N:        give N moves to computer",      (char *)"Print:    print a sector", 
        (char *)"Quit:     quit game",      (char *)"Restore:  restore game",      (char *)"Save:     save game",      (char *)"Trace:    save movie in empmovie.dat", 
        (char *)"Watch:    watch movie",      (char *)"Zoom:     display compressed map",      (char *)"<ctrl-L>: redraw screen"};
#line 210 "/home/june/repo/benchmarks/collector/temp/empire-1.11/data.c"
int cmd_lines  =    19;
#line 212 "/home/june/repo/benchmarks/collector/temp/empire-1.11/data.c"
char *help_user[22]  = 
#line 212
  {      (char *)"USER MODE",      (char *)"QWE",      (char *)"A D       movement directions",      (char *)"ZXC", 
        (char *)"<space>:  sit",      (char *)"Build:    change city production",      (char *)"Fill:     set func to fill",      (char *)"Grope:    set func to explore", 
        (char *)"Help:     display this text",      (char *)"I <dir>:  set func to dir",      (char *)"J:        enter edit mode",      (char *)"Kill:     set func to awake", 
        (char *)"Land:     set func to land",      (char *)"Out:      leave automove mode",      (char *)"Print:    redraw screen",      (char *)"Random:   set func to random", 
        (char *)"Sentry:   set func to sentry",      (char *)"Upgrade:  set func to repair",      (char *)"V <piece> <func>:  set city func",      (char *)"Y:        set func to attack", 
        (char *)"<ctrl-L>: redraw screen",      (char *)"?:        describe piece"};
#line 236 "/home/june/repo/benchmarks/collector/temp/empire-1.11/data.c"
int user_lines  =    22;
#line 238 "/home/june/repo/benchmarks/collector/temp/empire-1.11/data.c"
char *help_edit[22]  = 
#line 238
  {      (char *)"EDIT MODE",      (char *)"QWE",      (char *)"A D       movement directions",      (char *)"ZXC", 
        (char *)"Build:    change city production",      (char *)"Fill:     set func to fill",      (char *)"Grope:    set func to explore",      (char *)"Help:     display this text", 
        (char *)"I <dir>:  set func to dir",      (char *)"Kill:     set func to awake",      (char *)"Land:     set func to land",      (char *)"Mark:     mark piece", 
        (char *)"N:        set dest for marked piece",      (char *)"Out:      exit edit mode",      (char *)"Print:    print sector",      (char *)"Random:   set func to random", 
        (char *)"Sentry:   set func to sentry",      (char *)"Upgrade:  set func to repair",      (char *)"V <piece> <func>:  set city func",      (char *)"Y:        set func to attack", 
        (char *)"<ctrl-L>: redraw screen",      (char *)"?:        describe piece"};
#line 262 "/home/june/repo/benchmarks/collector/temp/empire-1.11/data.c"
int edit_lines  =    22;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/empire-1.11/edit.c"
void e_move(loc_t *path_start , loc_t loc ) ;
#line 25
char e_cursor(loc_t *edit_cursor ) ;
#line 26
void e_leave(void) ;
#line 26
void e_print(loc_t *edit_cursor ) ;
#line 26
void e_random(loc_t loc ) ;
#line 27
void e_stasis(loc_t loc ) ;
#line 27
void e_end(loc_t *path_start , loc_t loc , int path_type ) ;
#line 27
void e_wake(loc_t loc ) ;
#line 27
void e_sleep(loc_t loc ) ;
#line 28
void e_info(loc_t edit_cursor ) ;
#line 28
void e_prod(loc_t loc ) ;
#line 28
void e_help(void) ;
#line 28
void e_explore(loc_t loc ) ;
#line 29
void e_fill(loc_t loc ) ;
#line 29
void e_land(loc_t loc ) ;
#line 29
void e_city_func(loc_t *path_start , loc_t loc , int *path_type ) ;
#line 29
void e_transport(loc_t loc ) ;
#line 30
void e_attack(loc_t loc ) ;
#line 30
void e_repair(loc_t loc ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/empire-1.11/edit.c"
void edit(long edit_cursor ) 
{ 
  loc_t path_start ;
  int path_type ;
  char e ;

  {
#line 36
  path_start = (loc_t )-1;
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 39
    display_loc(1, user_map, edit_cursor);
#line 40
    e = e_cursor(& edit_cursor);
    }
    {
#line 43
    if ((int )e == 66) {
#line 43
      goto case_66;
    }
#line 46
    if ((int )e == 70) {
#line 46
      goto case_70;
    }
#line 49
    if ((int )e == 71) {
#line 49
      goto case_71;
    }
#line 52
    if ((int )e == 72) {
#line 52
      goto case_72;
    }
#line 55
    if ((int )e == 73) {
#line 55
      goto case_73;
    }
#line 58
    if ((int )e == 75) {
#line 58
      goto case_75;
    }
#line 61
    if ((int )e == 76) {
#line 61
      goto case_76;
    }
#line 64
    if ((int )e == 77) {
#line 64
      goto case_77;
    }
#line 68
    if ((int )e == 78) {
#line 68
      goto case_78;
    }
#line 71
    if ((int )e == 79) {
#line 71
      goto case_79;
    }
#line 74
    if ((int )e == 80) {
#line 74
      goto case_80;
    }
#line 77
    if ((int )e == 82) {
#line 77
      goto case_82;
    }
#line 80
    if ((int )e == 83) {
#line 80
      goto case_83;
    }
#line 83
    if ((int )e == 84) {
#line 83
      goto case_84;
    }
#line 86
    if ((int )e == 85) {
#line 86
      goto case_85;
    }
#line 89
    if ((int )e == 86) {
#line 89
      goto case_86;
    }
#line 92
    if ((int )e == 89) {
#line 92
      goto case_89;
    }
#line 95
    if ((int )e == 63) {
#line 95
      goto case_63;
    }
#line 98
    if ((int )e == 12) {
#line 98
      goto case_12;
    }
#line 101
    goto switch_default;
    case_66: /* CIL Label */ 
    {
#line 44
    e_prod(edit_cursor);
    }
#line 45
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 47
    e_fill(edit_cursor);
    }
#line 48
    goto switch_break;
    case_71: /* CIL Label */ 
    {
#line 50
    e_explore(edit_cursor);
    }
#line 51
    goto switch_break;
    case_72: /* CIL Label */ 
    {
#line 53
    e_help();
    }
#line 54
    goto switch_break;
    case_73: /* CIL Label */ 
    {
#line 56
    e_stasis(edit_cursor);
    }
#line 57
    goto switch_break;
    case_75: /* CIL Label */ 
    {
#line 59
    e_wake(edit_cursor);
    }
#line 60
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 62
    e_land(edit_cursor);
    }
#line 63
    goto switch_break;
    case_77: /* CIL Label */ 
    {
#line 65
    path_type = -1;
#line 66
    e_move(& path_start, edit_cursor);
    }
#line 67
    goto switch_break;
    case_78: /* CIL Label */ 
    {
#line 69
    e_end(& path_start, edit_cursor, path_type);
    }
#line 70
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 72
    e_leave();
    }
#line 73
    return;
    case_80: /* CIL Label */ 
    {
#line 75
    e_print(& edit_cursor);
    }
#line 76
    goto switch_break;
    case_82: /* CIL Label */ 
    {
#line 78
    e_random(edit_cursor);
    }
#line 79
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 81
    e_sleep(edit_cursor);
    }
#line 82
    goto switch_break;
    case_84: /* CIL Label */ 
    {
#line 84
    e_transport(edit_cursor);
    }
#line 85
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 87
    e_repair(edit_cursor);
    }
#line 88
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 90
    e_city_func(& path_start, edit_cursor, & path_type);
    }
#line 91
    goto switch_break;
    case_89: /* CIL Label */ 
    {
#line 93
    e_attack(edit_cursor);
    }
#line 94
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 96
    e_info(edit_cursor);
    }
#line 97
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 99
    redraw();
    }
#line 100
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 102
    huh();
    }
#line 103
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/empire-1.11/edit.c"
char e_cursor(loc_t *edit_cursor ) 
{ 
  chtype e ;
  int p ;
  int tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 121
  cbreak();
#line 122
  wrefresh(stdscr);
#line 123
  tmp = wgetch(stdscr);
#line 123
  e = (chtype )tmp;
#line 124
  topini();
  }
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 127
    p = direction(e);
    }
#line 128
    if (p == -1) {
#line 128
      goto while_break;
    }
    {
#line 130
    tmp___0 = move_cursor(edit_cursor, dir_offset[p]);
    }
#line 130
    if (! tmp___0) {
      {
#line 131
      beep();
      }
    }
    {
#line 133
    wrefresh(stdscr);
#line 134
    tmp___1 = wgetch(stdscr);
#line 134
    e = (chtype )tmp___1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 136
  nocbreak();
#line 137
  tmp___2 = toupper((int )e);
  }
#line 137
  return ((char )tmp___2);
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/empire-1.11/edit.c"
void e_leave(void) 
{ 


  {
#line 147
  return;
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/empire-1.11/edit.c"
void e_print(loc_t *edit_cursor ) 
{ 
  int sector ;

  {
  {
#line 158
  sector = get_range((char *)"New Sector? ", 0, 9);
#line 161
  *edit_cursor = (long )(((sector % 5) * 12 + 6) * 100 + ((sector / 5) * 50 + 25));
#line 162
  sector_change();
  }
#line 163
  return;
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/empire-1.11/edit.c"
void e_set_func(loc_t loc , long func ) 
{ 
  piece_info_t *obj ;

  {
  {
#line 173
  obj = find_obj_at_loc(loc);
  }
#line 174
  if ((unsigned long )obj != (unsigned long )((void *)0)) {
#line 174
    if (obj->owner == 1) {
#line 175
      obj->func = func;
#line 176
      return;
    }
  }
  {
#line 178
  huh();
  }
#line 179
  return;
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/empire-1.11/edit.c"
void e_set_city_func(city_info_t *cityp , int type , long func ) 
{ 


  {
#line 186
  cityp->func[type] = func;
#line 187
  return;
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/empire-1.11/edit.c"
void e_random(loc_t loc ) 
{ 


  {
  {
#line 196
  e_set_func(loc, -2L);
  }
#line 197
  return;
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/empire-1.11/edit.c"
void e_city_random(city_info_t *cityp , int type ) 
{ 


  {
  {
#line 202
  e_set_city_func(cityp, type, -2L);
  }
#line 203
  return;
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/empire-1.11/edit.c"
void e_fill(loc_t loc ) 
{ 


  {
#line 212
  if ((int )user_map[loc].contents == 84) {
    {
#line 213
    e_set_func(loc, -4L);
    }
  } else
#line 212
  if ((int )user_map[loc].contents == 67) {
    {
#line 213
    e_set_func(loc, -4L);
    }
  } else {
    {
#line 214
    huh();
    }
  }
#line 215
  return;
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/empire-1.11/edit.c"
void e_city_fill(city_info_t *cityp , int type ) 
{ 


  {
#line 220
  if (type == 5) {
    {
#line 221
    e_set_city_func(cityp, type, -4L);
    }
  } else
#line 220
  if (type == 6) {
    {
#line 221
    e_set_city_func(cityp, type, -4L);
    }
  } else {
    {
#line 222
    huh();
    }
  }
#line 223
  return;
}
}
#line 229 "/home/june/repo/benchmarks/collector/temp/empire-1.11/edit.c"
void e_explore(loc_t loc ) 
{ 


  {
  {
#line 232
  e_set_func(loc, -6L);
  }
#line 233
  return;
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/empire-1.11/edit.c"
void e_city_explore(city_info_t *cityp , loc_t type ) 
{ 


  {
  {
#line 238
  e_set_city_func(cityp, (int )type, -6L);
  }
#line 239
  return;
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/empire-1.11/edit.c"
void e_land(loc_t loc ) 
{ 


  {
#line 248
  if ((int )user_map[loc].contents == 70) {
    {
#line 249
    e_set_func(loc, -5L);
    }
  } else {
    {
#line 250
    huh();
    }
  }
#line 251
  return;
}
}
#line 257 "/home/june/repo/benchmarks/collector/temp/empire-1.11/edit.c"
void e_transport(loc_t loc ) 
{ 


  {
#line 260
  if ((int )user_map[loc].contents == 65) {
    {
#line 261
    e_set_func(loc, -11L);
    }
  } else {
    {
#line 262
    huh();
    }
  }
#line 263
  return;
}
}
#line 269 "/home/june/repo/benchmarks/collector/temp/empire-1.11/edit.c"
void e_attack(loc_t loc ) 
{ 


  {
#line 272
  if ((int )user_map[loc].contents == 65) {
    {
#line 273
    e_set_func(loc, -8L);
    }
  } else {
    {
#line 274
    huh();
    }
  }
#line 275
  return;
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/empire-1.11/edit.c"
void e_city_attack(city_info_t *cityp , int type ) 
{ 


  {
#line 280
  if (type == 0) {
    {
#line 281
    e_set_city_func(cityp, type, -8L);
    }
  } else {
    {
#line 282
    huh();
    }
  }
#line 283
  return;
}
}
#line 289 "/home/june/repo/benchmarks/collector/temp/empire-1.11/edit.c"
void e_repair(loc_t loc ) 
{ 
  char *tmp ;

  {
  {
#line 292
  tmp = strchr("PDSTBC", (int )user_map[loc].contents);
  }
#line 292
  if (tmp) {
    {
#line 293
    e_set_func(loc, -10L);
    }
  } else {
    {
#line 294
    huh();
    }
  }
#line 295
  return;
}
}
#line 297 "/home/june/repo/benchmarks/collector/temp/empire-1.11/edit.c"
void e_city_repair(city_info_t *cityp , int type ) 
{ 


  {
#line 300
  if (type == 0) {
    {
#line 301
    huh();
    }
  } else
#line 300
  if (type == 1) {
    {
#line 301
    huh();
    }
  } else
#line 300
  if (type == 8) {
    {
#line 301
    huh();
    }
  } else {
    {
#line 302
    e_set_city_func(cityp, type, -10L);
    }
  }
#line 303
  return;
}
}
#line 309 "/home/june/repo/benchmarks/collector/temp/empire-1.11/edit.c"
static char dirs[9]  = 
#line 309
  {      (char )'W',      (char )'E',      (char )'D',      (char )'C', 
        (char )'X',      (char )'Z',      (char )'A',      (char )'Q', 
        (char )'\000'};
#line 311 "/home/june/repo/benchmarks/collector/temp/empire-1.11/edit.c"
void e_stasis(loc_t loc ) 
{ 
  char e ;
  char tmp ;
  char *p ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  {
#line 314
  tmp___1 = __ctype_b_loc();
  }
#line 314
  if ((int const   )*(*tmp___1 + (int )user_map[loc].contents) & 256) {
#line 316
    if ((int )user_map[loc].contents == 88) {
      {
#line 317
      huh();
      }
    } else {
      {
#line 319
      tmp = get_chx();
#line 319
      e = tmp;
#line 320
      tmp___0 = strchr((char const   *)(dirs), (int )e);
#line 320
      p = tmp___0;
      }
#line 322
      if ((unsigned long )p == (unsigned long )((void *)0)) {
        {
#line 323
        huh();
        }
      } else {
        {
#line 325
        e_set_func(loc, -12L - (p - dirs));
        }
      }
    }
  } else {
    {
#line 315
    huh();
    }
  }
#line 327
  return;
}
}
#line 329 "/home/june/repo/benchmarks/collector/temp/empire-1.11/edit.c"
void e_city_stasis(city_info_t *cityp , int type ) 
{ 
  char e ;
  char *p ;

  {
  {
#line 335
  e = get_chx();
#line 336
  p = strchr((char const   *)(dirs), (int )e);
  }
#line 338
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 339
    huh();
    }
  } else {
    {
#line 341
    e_set_city_func(cityp, type, -12L - (p - dirs));
    }
  }
#line 342
  return;
}
}
#line 348 "/home/june/repo/benchmarks/collector/temp/empire-1.11/edit.c"
void e_wake(loc_t loc ) 
{ 
  city_info_t *cityp ;
  piece_info_t *obj ;
  int i ;

  {
  {
#line 355
  cityp = find_city(loc);
  }
#line 356
  if ((unsigned long )cityp != (unsigned long )((void *)0)) {
#line 357
    i = 0;
    {
#line 357
    while (1) {
      while_continue: /* CIL Label */ ;
#line 357
      if (! (i < 9)) {
#line 357
        goto while_break;
      }
#line 358
      cityp->func[i] = -1L;
#line 357
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 360
  obj = map[loc].objp;
  {
#line 360
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 360
    if (! ((unsigned long )obj != (unsigned long )((void *)0))) {
#line 360
      goto while_break___0;
    }
#line 361
    obj->func = -1L;
#line 360
    obj = obj->loc_link.next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 362
  return;
}
}
#line 364 "/home/june/repo/benchmarks/collector/temp/empire-1.11/edit.c"
void e_city_wake(city_info_t *cityp , int type ) 
{ 


  {
  {
#line 367
  e_set_city_func(cityp, type, -1L);
  }
#line 368
  return;
}
}
#line 375 "/home/june/repo/benchmarks/collector/temp/empire-1.11/edit.c"
void e_city_func(loc_t *path_start , loc_t loc , int *path_type ) 
{ 
  int type ;
  char e ;
  city_info_t *cityp ;

  {
  {
#line 382
  cityp = find_city(loc);
  }
#line 383
  if (! cityp) {
    {
#line 384
    huh();
    }
#line 385
    return;
  } else
#line 383
  if ((int )cityp->owner != 1) {
    {
#line 384
    huh();
    }
#line 385
    return;
  }
  {
#line 388
  type = get_piece_name();
  }
#line 389
  if (type == -1) {
    {
#line 390
    huh();
    }
#line 391
    return;
  }
  {
#line 394
  e = get_chx();
  }
  {
#line 397
  if ((int )e == 70) {
#line 397
    goto case_70;
  }
#line 400
  if ((int )e == 71) {
#line 400
    goto case_71;
  }
#line 403
  if ((int )e == 73) {
#line 403
    goto case_73;
  }
#line 406
  if ((int )e == 75) {
#line 406
    goto case_75;
  }
#line 409
  if ((int )e == 77) {
#line 409
    goto case_77;
  }
#line 413
  if ((int )e == 82) {
#line 413
    goto case_82;
  }
#line 416
  if ((int )e == 85) {
#line 416
    goto case_85;
  }
#line 419
  if ((int )e == 89) {
#line 419
    goto case_89;
  }
#line 422
  goto switch_default;
  case_70: /* CIL Label */ 
  {
#line 398
  e_city_fill(cityp, type);
  }
#line 399
  goto switch_break;
  case_71: /* CIL Label */ 
  {
#line 401
  e_city_explore(cityp, (loc_t )type);
  }
#line 402
  goto switch_break;
  case_73: /* CIL Label */ 
  {
#line 404
  e_city_stasis(cityp, type);
  }
#line 405
  goto switch_break;
  case_75: /* CIL Label */ 
  {
#line 407
  e_city_wake(cityp, type);
  }
#line 408
  goto switch_break;
  case_77: /* CIL Label */ 
  {
#line 410
  *path_type = type;
#line 411
  e_move(path_start, loc);
  }
#line 412
  goto switch_break;
  case_82: /* CIL Label */ 
  {
#line 414
  e_city_random(cityp, type);
  }
#line 415
  goto switch_break;
  case_85: /* CIL Label */ 
  {
#line 417
  e_city_repair(cityp, type);
  }
#line 418
  goto switch_break;
  case_89: /* CIL Label */ 
  {
#line 420
  e_city_attack(cityp, type);
  }
#line 421
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 423
  huh();
  }
#line 424
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 426
  return;
}
}
#line 432 "/home/june/repo/benchmarks/collector/temp/empire-1.11/edit.c"
void e_move(loc_t *path_start , loc_t loc ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 435
  tmp = __ctype_b_loc();
  }
#line 435
  if ((int const   )*(*tmp + (int )user_map[loc].contents) & 256) {
#line 436
    if ((int )user_map[loc].contents == 88) {
      {
#line 436
      huh();
      }
    } else {
#line 437
      *path_start = loc;
    }
  } else {
    {
#line 435
    huh();
    }
  }
#line 438
  return;
}
}
#line 444 "/home/june/repo/benchmarks/collector/temp/empire-1.11/edit.c"
void e_end(loc_t *path_start , loc_t loc , int path_type ) 
{ 
  city_info_t *cityp ;
  city_info_t *tmp ;

  {
#line 447
  if (*path_start == -1L) {
    {
#line 448
    huh();
    }
  } else
#line 449
  if (path_type == -1) {
    {
#line 450
    e_set_func(*path_start, loc);
    }
  } else {
    {
#line 452
    tmp = find_city(*path_start);
#line 452
    cityp = tmp;
    }
#line 453
    if (! cityp) {
      {
#line 453
      assert((char *)"x", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/edit.c",
             453);
      }
    }
    {
#line 454
    e_set_city_func(cityp, path_type, loc);
    }
  }
#line 457
  *path_start = (loc_t )-1;
#line 458
  return;
}
}
#line 464 "/home/june/repo/benchmarks/collector/temp/empire-1.11/edit.c"
void e_sleep(loc_t loc ) 
{ 


  {
#line 467
  if ((int )user_map[loc].contents == 79) {
    {
#line 467
    huh();
    }
  } else {
    {
#line 468
    e_set_func(loc, -3L);
    }
  }
#line 469
  return;
}
}
#line 478
void e_city_info(loc_t edit_cursor ) ;
#line 478
void e_piece_info(loc_t edit_cursor , char ab ) ;
#line 475 "/home/june/repo/benchmarks/collector/temp/empire-1.11/edit.c"
void e_info(loc_t edit_cursor ) 
{ 
  char ab ;

  {
#line 482
  ab = user_map[edit_cursor].contents;
#line 484
  if ((int )ab == 79) {
    {
#line 485
    e_city_info(edit_cursor);
    }
  } else
#line 486
  if ((int )ab == 88) {
#line 486
    if (debug) {
      {
#line 487
      e_city_info(edit_cursor);
      }
    } else {
#line 486
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 488
  if ((int )ab >= 65) {
#line 488
    if ((int )ab <= 84) {
      {
#line 489
      e_piece_info(edit_cursor, ab);
      }
    } else {
#line 488
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 490
  if ((int )ab >= 97) {
#line 490
    if ((int )ab <= 116) {
#line 490
      if (debug) {
        {
#line 491
        e_piece_info(edit_cursor, ab);
        }
      } else {
        {
#line 493
        huh();
        }
      }
    } else {
      {
#line 493
      huh();
      }
    }
  } else {
    {
#line 493
    huh();
    }
  }
#line 494
  return;
}
}
#line 500 "/home/june/repo/benchmarks/collector/temp/empire-1.11/edit.c"
void e_piece_info(loc_t edit_cursor , char ab ) 
{ 
  piece_info_t *obj ;
  int type ;
  char *p ;
  int tmp ;

  {
  {
#line 507
  tmp = toupper((int )ab);
#line 507
  ab = (char )tmp;
#line 508
  p = strchr((char const   *)(type_chars), (int )ab);
#line 509
  type = (int )(p - type_chars);
#line 511
  obj = find_obj(type, edit_cursor);
  }
#line 512
  if (! ((unsigned long )obj != (unsigned long )((void *)0))) {
    {
#line 512
    assert((char *)"x", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/edit.c",
           512);
    }
  }
  {
#line 513
  describe_obj(obj);
  }
#line 514
  return;
}
}
#line 520 "/home/june/repo/benchmarks/collector/temp/empire-1.11/edit.c"
void e_city_info(loc_t edit_cursor ) 
{ 
  piece_info_t *obj ;
  city_info_t *cityp ;
  int f ;
  int s ;
  char func_buf[80] ;
  char temp_buf[80] ;
  char junk_buf2[80] ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 530
  error((char *)"");
#line 532
  f = 0;
#line 533
  obj = map[edit_cursor].objp;
  }
  {
#line 533
  while (1) {
    while_continue: /* CIL Label */ ;
#line 533
    if (! ((unsigned long )obj != (unsigned long )((void *)0))) {
#line 533
      goto while_break;
    }
#line 535
    if (obj->type == 1) {
#line 535
      f ++;
    }
#line 533
    obj = obj->loc_link.next;
  }
  while_break: /* CIL Label */ ;
  }
#line 537
  s = 0;
#line 538
  obj = map[edit_cursor].objp;
  {
#line 538
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 538
    if (! ((unsigned long )obj != (unsigned long )((void *)0))) {
#line 538
      goto while_break___0;
    }
#line 540
    if (obj->type >= 3) {
#line 540
      s ++;
    }
#line 538
    obj = obj->loc_link.next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 542
  if (f == 1) {
#line 542
    if (s == 1) {
      {
#line 543
      sprintf((char */* __restrict  */)(jnkbuf), (char const   */* __restrict  */)"1 fighter landed, 1 ship docked");
      }
    } else {
#line 542
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 544
  if (f == 1) {
    {
#line 545
    sprintf((char */* __restrict  */)(jnkbuf), (char const   */* __restrict  */)"1 fighter landed, %d ships docked",
            s);
    }
  } else
#line 546
  if (s == 1) {
    {
#line 547
    sprintf((char */* __restrict  */)(jnkbuf), (char const   */* __restrict  */)"%d fighters landed, 1 ship docked",
            f);
    }
  } else {
    {
#line 549
    sprintf((char */* __restrict  */)(jnkbuf), (char const   */* __restrict  */)"%d fighters landed, %d ships docked",
            f, s);
    }
  }
  {
#line 551
  cityp = find_city(edit_cursor);
  }
#line 552
  if (! ((unsigned long )cityp != (unsigned long )((void *)0))) {
    {
#line 552
    assert((char *)"x", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/edit.c",
           552);
    }
  }
#line 554
  func_buf[0] = (char)0;
#line 555
  s = 0;
  {
#line 555
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 555
    if (! (s < 9)) {
#line 555
      goto while_break___1;
    }
#line 556
    if (cityp->func[s] < 0L) {
      {
#line 557
      sprintf((char */* __restrict  */)(temp_buf), (char const   */* __restrict  */)"%c:%s; ",
              (int )piece_attr[s].sname, func_name[- cityp->func[s] - 1L]);
      }
    } else {
      {
#line 560
      tmp = loc_disp((int )cityp->func[s]);
#line 560
      sprintf((char */* __restrict  */)(temp_buf), (char const   */* __restrict  */)"%c: %d;",
              (int )piece_attr[s].sname, tmp);
      }
    }
    {
#line 564
    strcat((char */* __restrict  */)(func_buf), (char const   */* __restrict  */)(temp_buf));
#line 555
    s ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 567
  tmp___0 = loc_disp((int )cityp->loc);
#line 567
  sprintf((char */* __restrict  */)(junk_buf2), (char const   */* __restrict  */)"City at location %d will complete %s on round %ld",
          tmp___0, piece_attr[(int )cityp->prod].article, (date + (long )piece_attr[(int )cityp->prod].build_time) - cityp->work);
#line 573
  info(junk_buf2, jnkbuf, func_buf);
  }
#line 574
  return;
}
}
#line 580 "/home/june/repo/benchmarks/collector/temp/empire-1.11/edit.c"
void e_prod(loc_t loc ) 
{ 
  city_info_t *cityp ;

  {
  {
#line 585
  cityp = find_city(loc);
  }
#line 587
  if ((unsigned long )cityp == (unsigned long )((void *)0)) {
    {
#line 587
    huh();
    }
  } else {
    {
#line 588
    set_prod(cityp);
    }
  }
#line 589
  return;
}
}
#line 595 "/home/june/repo/benchmarks/collector/temp/empire-1.11/edit.c"
void e_help(void) 
{ 


  {
  {
#line 598
  help(help_edit, edit_lines);
#line 599
  prompt((char *)"Press any key to continue: ");
#line 600
  get_chx();
  }
#line 601
  return;
}
}
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 109 "/home/june/repo/benchmarks/collector/temp/empire-1.11/extern.h"
void empire(void) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/empire-1.11/main.c"
int main(int argc , char **argv ) 
{ 
  int c ;
  int errflg ;
  int wflg ;
  int sflg ;
  int dflg ;
  int Sflg ;
  int land___0 ;

  {
#line 42
  errflg = 0;
#line 46
  wflg = 70;
#line 47
  sflg = 5;
#line 48
  dflg = 2000;
#line 49
  Sflg = 10;
#line 50
  savefile = (char *)"empsave.dat";
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 56
    c = getopt(argc, (char * const  *)argv, "w:s:d:S:f:");
    }
#line 56
    if (! (c != -1)) {
#line 56
      goto while_break;
    }
    {
#line 58
    if (c == 119) {
#line 58
      goto case_119;
    }
#line 61
    if (c == 115) {
#line 61
      goto case_115;
    }
#line 64
    if (c == 100) {
#line 64
      goto case_100;
    }
#line 67
    if (c == 83) {
#line 67
      goto case_83;
    }
#line 70
    if (c == 102) {
#line 70
      goto case_102;
    }
#line 73
    if (c == 63) {
#line 73
      goto case_63;
    }
#line 57
    goto switch_break;
    case_119: /* CIL Label */ 
    {
#line 59
    wflg = atoi((char const   *)optarg);
    }
#line 60
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 62
    sflg = atoi((char const   *)optarg);
    }
#line 63
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 65
    dflg = atoi((char const   *)optarg);
    }
#line 66
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 68
    Sflg = atoi((char const   *)optarg);
    }
#line 69
    goto switch_break;
    case_102: /* CIL Label */ 
#line 71
    savefile = optarg;
#line 72
    goto switch_break;
    case_63: /* CIL Label */ 
#line 74
    errflg ++;
#line 75
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  if (errflg) {
    {
#line 79
    printf((char const   */* __restrict  */)"empire: usage: empire [-w water] [-s smooth] [-d delay]\n");
#line 80
    exit(1);
    }
  } else
#line 78
  if (argc - optind != 0) {
    {
#line 79
    printf((char const   */* __restrict  */)"empire: usage: empire [-w water] [-s smooth] [-d delay]\n");
#line 80
    exit(1);
    }
  }
#line 83
  if (wflg < 10) {
    {
#line 84
    printf((char const   */* __restrict  */)"empire: -w argument must be in the range 0..90.\n");
#line 85
    exit(1);
    }
  } else
#line 83
  if (wflg > 90) {
    {
#line 84
    printf((char const   */* __restrict  */)"empire: -w argument must be in the range 0..90.\n");
#line 85
    exit(1);
    }
  }
#line 87
  if (sflg < 0) {
    {
#line 88
    printf((char const   */* __restrict  */)"empire: -s argument must be greater or equal to zero.\n");
#line 89
    exit(1);
    }
  }
#line 92
  if (dflg < 0) {
    {
#line 93
    printf((char const   */* __restrict  */)"empire: -d argument must be in the range 0..30000.\n");
#line 94
    exit(1);
    }
  } else
#line 92
  if (dflg > 30000) {
    {
#line 93
    printf((char const   */* __restrict  */)"empire: -d argument must be in the range 0..30000.\n");
#line 94
    exit(1);
    }
  }
  {
#line 97
  SMOOTH = sflg;
#line 98
  WATER_RATIO = wflg;
#line 99
  delay_time = dflg;
#line 100
  save_interval = Sflg;
#line 103
  land___0 = (6000 * (100 - WATER_RATIO)) / 100;
#line 104
  land___0 /= 70;
#line 105
  MIN_CITY_DIST = isqrt(land___0);
#line 107
  empire();
  }
#line 108
  return (0);
}
}
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 118 "/home/june/repo/benchmarks/collector/temp/empire-1.11/extern.h"
void rmap_cont(int *cont_map , long loc , char bad_terrain ) ;
#line 121
scan_counts_t rmap_cont_scan(int *cont_map ) ;
#line 122
_Bool map_cont_edge(int *cont_map , long loc ) ;
#line 134
int vmap_count_adjacent(view_map_t *vmap , long loc , char *adj_char ) ;
#line 135
_Bool vmap_shore(view_map_t *vmap , long loc ) ;
#line 138
_Bool rmap_at_sea(long loc ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/empire-1.11/map.c"
static void expand_perimeter(path_map_t *pmap , view_map_t *vmap , move_info_t *move_info ,
                             perimeter_t *curp , int type , int cur_cost , int inc_wcost ,
                             int inc_lcost , perimeter_t *waterp , perimeter_t *landp ) ;
#line 27
static void expand_prune(view_map_t *vmap , path_map_t *pmap , loc_t loc , int type ,
                         perimeter_t *to , int *explored ) ;
#line 29
static int objective_cost(view_map_t *vmap , move_info_t *move_info , loc_t loc ,
                          int base_cost ) ;
#line 30
static int terrain_type(path_map_t *pmap , view_map_t *vmap , move_info_t *move_info ,
                        loc_t from_loc , loc_t to_loc ) ;
#line 31
static void start_perimeter(path_map_t *pmap , perimeter_t *perim , loc_t loc , int terrain ) ;
#line 32
static void add_cell(path_map_t *pmap , loc_t new_loc , perimeter_t *perim , int terrain ,
                     int cur_cost , int inc_cost ) ;
#line 33
static int vmap_count_path(path_map_t *pmap , loc_t loc ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/empire-1.11/map.c"
static perimeter_t p1  ;
#line 36 "/home/june/repo/benchmarks/collector/temp/empire-1.11/map.c"
static perimeter_t p2  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/empire-1.11/map.c"
static perimeter_t p3  ;
#line 38 "/home/june/repo/benchmarks/collector/temp/empire-1.11/map.c"
static perimeter_t p4  ;
#line 40 "/home/june/repo/benchmarks/collector/temp/empire-1.11/map.c"
static int best_cost  ;
#line 41 "/home/june/repo/benchmarks/collector/temp/empire-1.11/map.c"
static loc_t best_loc  ;
#line 51 "/home/june/repo/benchmarks/collector/temp/empire-1.11/map.c"
void vmap_cont(int *cont_map , view_map_t *vmap , long loc , char bad_terrain ) 
{ 


  {
  {
#line 54
  memset((void *)((char *)cont_map), '\000', 6000UL * sizeof(int ));
#line 55
  vmap_mark_up_cont(cont_map, vmap, loc, bad_terrain);
  }
#line 56
  return;
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/empire-1.11/map.c"
void vmap_mark_up_cont(int *cont_map , view_map_t *vmap , long loc , char bad_terrain ) 
{ 
  int i ;
  int j ;
  loc_t new_loc ;
  char this_terrain ;
  perimeter_t *from ;
  perimeter_t *to ;
  int tmp ;
  perimeter_t *x ;

  {
#line 72
  from = & p1;
#line 73
  to = & p2;
#line 75
  from->len = 1L;
#line 76
  from->list[0] = loc;
#line 77
  *(cont_map + loc) = 1;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! from->len) {
#line 79
      goto while_break;
    }
#line 80
    to->len = 0L;
#line 82
    i = 0;
    {
#line 82
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 82
      if (! ((long )i < from->len)) {
#line 82
        goto while_break___0;
      }
#line 83
      j = 0;
      {
#line 83
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 83
        if (j < 8) {
#line 83
          new_loc = from->list[i] + (long )dir_offset[j];
#line 83
          tmp = 1;
        } else {
#line 83
          tmp = 0;
        }
#line 83
        if (! tmp) {
#line 83
          goto while_break___1;
        }
#line 83
        if (map[new_loc].on_board) {
#line 84
          if (! *(cont_map + new_loc)) {
#line 86
            if ((int )(vmap + new_loc)->contents == 32) {
#line 87
              *(cont_map + new_loc) = 1;
            } else {
#line 89
              if ((int )(vmap + new_loc)->contents == 43) {
#line 90
                this_terrain = (char )'+';
              } else
#line 91
              if ((int )(vmap + new_loc)->contents == 46) {
#line 92
                this_terrain = (char )'.';
              } else {
#line 93
                this_terrain = map[new_loc].contents;
              }
#line 95
              if ((int )this_terrain != (int )bad_terrain) {
#line 96
                *(cont_map + new_loc) = 1;
#line 97
                to->list[to->len] = new_loc;
#line 98
                (to->len) ++;
              }
            }
          }
        }
#line 83
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 82
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 102
    x = from;
#line 102
    from = to;
#line 102
    to = x;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  return;
}
}
#line 114
static void rmap_mark_up_cont(int *cont_map , loc_t loc , char bad_terrain ) ;
#line 116 "/home/june/repo/benchmarks/collector/temp/empire-1.11/map.c"
void rmap_cont(int *cont_map , long loc , char bad_terrain ) 
{ 


  {
  {
#line 119
  memset((void *)((char *)cont_map), '\000', 6000UL * sizeof(int ));
#line 120
  rmap_mark_up_cont(cont_map, loc, bad_terrain);
  }
#line 121
  return;
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/empire-1.11/map.c"
static void rmap_mark_up_cont(int *cont_map , loc_t loc , char bad_terrain ) 
{ 
  int i ;
  loc_t new_loc ;
  int tmp ;

  {
#line 137
  if (! map[loc].on_board) {
#line 137
    return;
  }
#line 138
  if (*(cont_map + loc)) {
#line 138
    return;
  }
#line 139
  if ((int )map[loc].contents == (int )bad_terrain) {
#line 139
    return;
  }
#line 141
  *(cont_map + loc) = 1;
#line 143
  i = 0;
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (i < 8) {
#line 143
      new_loc = loc + (loc_t )dir_offset[i];
#line 143
      tmp = 1;
    } else {
#line 143
      tmp = 0;
    }
#line 143
    if (! tmp) {
#line 143
      goto while_break;
    }
    {
#line 144
    rmap_mark_up_cont(cont_map, new_loc, bad_terrain);
#line 143
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 145
  return;
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/empire-1.11/map.c"
scan_counts_t vmap_cont_scan(int *cont_map , view_map_t *vmap ) 
{ 
  scan_counts_t counts ;
  count_t i ;

  {
  {
#line 161
  memset((void *)((char *)(& counts)), '\000', sizeof(scan_counts_t ));
#line 163
  i = (count_t )0;
  }
  {
#line 163
  while (1) {
    while_continue: /* CIL Label */ ;
#line 163
    if (! (i < 6000L)) {
#line 163
      goto while_break;
    }
#line 164
    if (*(cont_map + i)) {
#line 165
      (counts.size) ++;
      {
#line 168
      if ((int )(vmap + i)->contents == 32) {
#line 168
        goto case_32;
      }
#line 169
      if ((int )(vmap + i)->contents == 79) {
#line 169
        goto case_79;
      }
#line 170
      if ((int )(vmap + i)->contents == 65) {
#line 170
        goto case_65;
      }
#line 171
      if ((int )(vmap + i)->contents == 70) {
#line 171
        goto case_70;
      }
#line 172
      if ((int )(vmap + i)->contents == 80) {
#line 172
        goto case_80;
      }
#line 173
      if ((int )(vmap + i)->contents == 68) {
#line 173
        goto case_68;
      }
#line 174
      if ((int )(vmap + i)->contents == 83) {
#line 174
        goto case_83;
      }
#line 175
      if ((int )(vmap + i)->contents == 84) {
#line 175
        goto case_84;
      }
#line 176
      if ((int )(vmap + i)->contents == 67) {
#line 176
        goto case_67;
      }
#line 177
      if ((int )(vmap + i)->contents == 66) {
#line 177
        goto case_66;
      }
#line 178
      if ((int )(vmap + i)->contents == 88) {
#line 178
        goto case_88;
      }
#line 179
      if ((int )(vmap + i)->contents == 97) {
#line 179
        goto case_97;
      }
#line 180
      if ((int )(vmap + i)->contents == 102) {
#line 180
        goto case_102;
      }
#line 181
      if ((int )(vmap + i)->contents == 112) {
#line 181
        goto case_112;
      }
#line 182
      if ((int )(vmap + i)->contents == 100) {
#line 182
        goto case_100;
      }
#line 183
      if ((int )(vmap + i)->contents == 115) {
#line 183
        goto case_115;
      }
#line 184
      if ((int )(vmap + i)->contents == 116) {
#line 184
        goto case_116;
      }
#line 185
      if ((int )(vmap + i)->contents == 99) {
#line 185
        goto case_99;
      }
#line 186
      if ((int )(vmap + i)->contents == 98) {
#line 186
        goto case_98;
      }
#line 187
      if ((int )(vmap + i)->contents == 42) {
#line 187
        goto case_42;
      }
#line 188
      if ((int )(vmap + i)->contents == 43) {
#line 188
        goto case_43;
      }
#line 189
      if ((int )(vmap + i)->contents == 46) {
#line 189
        goto case_46;
      }
#line 190
      goto switch_default;
      case_32: /* CIL Label */ 
#line 168
      (counts.unexplored) ++;
#line 168
      goto switch_break;
      case_79: /* CIL Label */ 
#line 169
      (counts.user_cities) ++;
#line 169
      goto switch_break;
      case_65: /* CIL Label */ 
#line 170
      (counts.user_objects[0]) ++;
#line 170
      goto switch_break;
      case_70: /* CIL Label */ 
#line 171
      (counts.user_objects[1]) ++;
#line 171
      goto switch_break;
      case_80: /* CIL Label */ 
#line 172
      (counts.user_objects[2]) ++;
#line 172
      goto switch_break;
      case_68: /* CIL Label */ 
#line 173
      (counts.user_objects[3]) ++;
#line 173
      goto switch_break;
      case_83: /* CIL Label */ 
#line 174
      (counts.user_objects[4]) ++;
#line 174
      goto switch_break;
      case_84: /* CIL Label */ 
#line 175
      (counts.user_objects[5]) ++;
#line 175
      goto switch_break;
      case_67: /* CIL Label */ 
#line 176
      (counts.user_objects[6]) ++;
#line 176
      goto switch_break;
      case_66: /* CIL Label */ 
#line 177
      (counts.user_objects[7]) ++;
#line 177
      goto switch_break;
      case_88: /* CIL Label */ 
#line 178
      (counts.comp_cities) ++;
#line 178
      goto switch_break;
      case_97: /* CIL Label */ 
#line 179
      (counts.comp_objects[0]) ++;
#line 179
      goto switch_break;
      case_102: /* CIL Label */ 
#line 180
      (counts.comp_objects[1]) ++;
#line 180
      goto switch_break;
      case_112: /* CIL Label */ 
#line 181
      (counts.comp_objects[2]) ++;
#line 181
      goto switch_break;
      case_100: /* CIL Label */ 
#line 182
      (counts.comp_objects[3]) ++;
#line 182
      goto switch_break;
      case_115: /* CIL Label */ 
#line 183
      (counts.comp_objects[4]) ++;
#line 183
      goto switch_break;
      case_116: /* CIL Label */ 
#line 184
      (counts.comp_objects[5]) ++;
#line 184
      goto switch_break;
      case_99: /* CIL Label */ 
#line 185
      (counts.comp_objects[6]) ++;
#line 185
      goto switch_break;
      case_98: /* CIL Label */ 
#line 186
      (counts.comp_objects[7]) ++;
#line 186
      goto switch_break;
      case_42: /* CIL Label */ 
#line 187
      (counts.unowned_cities) ++;
#line 187
      goto switch_break;
      case_43: /* CIL Label */ 
#line 188
      goto switch_break;
      case_46: /* CIL Label */ 
#line 189
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 191
      if ((int )map[i].contents == 42) {
        {
#line 193
        if ((int )(map[i].cityp)->owner == 1) {
#line 193
          goto case_1;
        }
#line 194
        if ((int )(map[i].cityp)->owner == 2) {
#line 194
          goto case_2;
        }
#line 195
        if ((int )(map[i].cityp)->owner == 0) {
#line 195
          goto case_0;
        }
#line 192
        goto switch_break___0;
        case_1: /* CIL Label */ 
#line 193
        (counts.user_cities) ++;
#line 193
        goto switch_break___0;
        case_2: /* CIL Label */ 
#line 194
        (counts.comp_cities) ++;
#line 194
        goto switch_break___0;
        case_0: /* CIL Label */ 
#line 195
        (counts.unowned_cities) ++;
#line 195
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
      }
      switch_break: /* CIL Label */ ;
      }
    }
#line 163
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 201
  return (counts);
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/empire-1.11/map.c"
scan_counts_t rmap_cont_scan(int *cont_map ) 
{ 
  scan_counts_t counts ;
  count_t i ;

  {
  {
#line 215
  memset((void *)((char *)(& counts)), '\000', sizeof(scan_counts_t ));
#line 217
  i = (count_t )0;
  }
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
#line 217
    if (! (i < 6000L)) {
#line 217
      goto while_break;
    }
#line 218
    if (*(cont_map + i)) {
#line 219
      (counts.size) ++;
#line 220
      if ((int )map[i].contents == 42) {
#line 221
        (counts.unowned_cities) ++;
      }
    }
#line 217
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  return (counts);
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/empire-1.11/map.c"
_Bool map_cont_edge(int *cont_map , long loc ) 
{ 
  loc_t i ;
  loc_t j ;
  int tmp ;

  {
#line 236
  if (! *(cont_map + loc)) {
#line 236
    return ((_Bool)0);
  }
#line 238
  i = (loc_t )0;
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;
#line 238
    if (i < 8L) {
#line 238
      j = loc + (long )dir_offset[i];
#line 238
      tmp = 1;
    } else {
#line 238
      tmp = 0;
    }
#line 238
    if (! tmp) {
#line 238
      goto while_break;
    }
#line 239
    if (! *(cont_map + j)) {
#line 239
      return ((_Bool)1);
    }
#line 238
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 241
  return ((_Bool)0);
}
}
#line 276 "/home/june/repo/benchmarks/collector/temp/empire-1.11/map.c"
loc_t vmap_find_xobj(path_map_t *path_map___0 , view_map_t *vmap , loc_t loc , move_info_t *move_info ,
                     int start , int expand ) 
{ 
  perimeter_t *from ;
  perimeter_t *to ;
  int cur_cost ;
  perimeter_t *x ;

  {
  {
#line 284
  from = & p1;
#line 285
  to = & p2;
#line 287
  start_perimeter(path_map___0, from, loc, start);
#line 288
  cur_cost = 0;
  }
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 291
    to->len = 0L;
#line 292
    expand_perimeter(path_map___0, vmap, move_info, from, expand, cur_cost, 1, 1,
                     to, to);
    }
#line 295
    if (trace_pmap) {
      {
#line 296
      print_pzoom((char *)"After xobj loop:", path_map___0, vmap);
      }
    }
#line 298
    cur_cost ++;
#line 299
    if (to->len == 0L) {
#line 300
      return (best_loc);
    } else
#line 299
    if (best_cost <= cur_cost) {
#line 300
      return (best_loc);
    }
#line 302
    x = from;
#line 302
    from = to;
#line 302
    to = x;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 308 "/home/june/repo/benchmarks/collector/temp/empire-1.11/map.c"
long vmap_find_aobj(path_map_t *path_map___0 , view_map_t *vmap , long loc , move_info_t *move_info ) 
{ 
  loc_t tmp ;

  {
  {
#line 312
  tmp = vmap_find_xobj(path_map___0, vmap, loc, move_info, 2, 6);
  }
#line 312
  return (tmp);
}
}
#line 317 "/home/june/repo/benchmarks/collector/temp/empire-1.11/map.c"
long vmap_find_wobj(path_map_t *path_map___0 , view_map_t *vmap , long loc , move_info_t *move_info ) 
{ 
  loc_t tmp ;

  {
  {
#line 321
  tmp = vmap_find_xobj(path_map___0, vmap, loc, move_info, 4, 4);
  }
#line 321
  return (tmp);
}
}
#line 326 "/home/june/repo/benchmarks/collector/temp/empire-1.11/map.c"
long vmap_find_lobj(path_map_t *path_map___0 , view_map_t *vmap , long loc , move_info_t *move_info ) 
{ 
  loc_t tmp ;

  {
  {
#line 330
  tmp = vmap_find_xobj(path_map___0, vmap, loc, move_info, 2, 2);
  }
#line 330
  return (tmp);
}
}
#line 345 "/home/june/repo/benchmarks/collector/temp/empire-1.11/map.c"
long vmap_find_lwobj(path_map_t *path_map___0 , view_map_t *vmap , long loc , move_info_t *move_info ,
                     int beat_cost ) 
{ 
  perimeter_t *cur_land ;
  perimeter_t *cur_water ;
  perimeter_t *new_land ;
  perimeter_t *new_water ;
  int cur_cost ;
  perimeter_t *x ;

  {
  {
#line 355
  cur_land = & p1;
#line 356
  cur_water = & p2;
#line 357
  new_water = & p3;
#line 358
  new_land = & p4;
#line 360
  start_perimeter(path_map___0, cur_land, loc, 2);
#line 361
  cur_water->len = 0L;
#line 362
  best_cost = beat_cost;
#line 363
  cur_cost = 0;
  }
  {
#line 365
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 367
    new_water->len = 0L;
#line 368
    new_land->len = 0L;
#line 369
    expand_perimeter(path_map___0, vmap, move_info, cur_water, 4, cur_cost, 1, 1,
                     new_water, (perimeter_t *)((void *)0));
#line 372
    expand_perimeter(path_map___0, vmap, move_info, cur_land, 6, cur_cost, 1, 2, new_water,
                     new_land);
#line 376
    cur_water->len = 0L;
#line 377
    expand_perimeter(path_map___0, vmap, move_info, new_water, 4, cur_cost + 1, 1,
                     1, cur_water, (perimeter_t *)((void *)0));
    }
#line 380
    if (trace_pmap) {
      {
#line 381
      print_pzoom((char *)"After lwobj loop:", path_map___0, vmap);
      }
    }
#line 383
    cur_cost += 2;
#line 384
    if (cur_water->len == 0L) {
#line 384
      if (new_land->len == 0L) {
#line 386
        return (best_loc);
      } else {
#line 384
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 384
    if (best_cost <= cur_cost) {
#line 386
      return (best_loc);
    }
#line 389
    x = cur_land;
#line 389
    cur_land = new_land;
#line 389
    new_land = x;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 427 "/home/june/repo/benchmarks/collector/temp/empire-1.11/map.c"
long vmap_find_wlobj(path_map_t *path_map___0 , view_map_t *vmap , long loc , move_info_t *move_info ) 
{ 
  perimeter_t *cur_land ;
  perimeter_t *cur_water ;
  perimeter_t *new_land ;
  perimeter_t *new_water ;
  int cur_cost ;
  perimeter_t *x ;

  {
  {
#line 437
  cur_land = & p1;
#line 438
  cur_water = & p2;
#line 439
  new_water = & p3;
#line 440
  new_land = & p4;
#line 442
  start_perimeter(path_map___0, cur_water, loc, 4);
#line 443
  cur_land->len = 0L;
#line 444
  cur_cost = 0;
  }
  {
#line 446
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 448
    new_water->len = 0L;
#line 449
    new_land->len = 0L;
#line 450
    expand_perimeter(path_map___0, vmap, move_info, cur_water, 6, cur_cost, 1, 2,
                     new_water, new_land);
#line 453
    expand_perimeter(path_map___0, vmap, move_info, cur_land, 2, cur_cost, 1, 2, (perimeter_t *)((void *)0),
                     new_land);
#line 457
    cur_water->len = 0L;
#line 458
    expand_perimeter(path_map___0, vmap, move_info, new_water, 4, cur_cost + 1, 1,
                     1, cur_water, (perimeter_t *)((void *)0));
    }
#line 461
    if (trace_pmap) {
      {
#line 462
      print_pzoom((char *)"After wlobj loop:", path_map___0, vmap);
      }
    }
#line 464
    cur_cost += 2;
#line 465
    if (cur_water->len == 0L) {
#line 465
      if (new_land->len == 0L) {
#line 467
        return (best_loc);
      } else {
#line 465
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 465
    if (best_cost <= cur_cost) {
#line 467
      return (best_loc);
    }
#line 469
    x = cur_land;
#line 469
    cur_land = new_land;
#line 469
    new_land = x;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 481 "/home/june/repo/benchmarks/collector/temp/empire-1.11/map.c"
static path_map_t pmap_init[6000]  ;
#line 482 "/home/june/repo/benchmarks/collector/temp/empire-1.11/map.c"
static _Bool init_done  =    (_Bool)0;
#line 484 "/home/june/repo/benchmarks/collector/temp/empire-1.11/map.c"
static void start_perimeter(path_map_t *pmap , perimeter_t *perim , loc_t loc , int terrain ) 
{ 
  int i ;

  {
#line 488
  if (! init_done) {
#line 491
    init_done = (_Bool)1;
#line 492
    i = 0;
    {
#line 492
    while (1) {
      while_continue: /* CIL Label */ ;
#line 492
      if (! (i < 6000)) {
#line 492
        goto while_break;
      }
#line 493
      pmap_init[i].cost = 10000000;
#line 494
      pmap_init[i].terrain = (char)0;
#line 492
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 497
  memcpy((void */* __restrict  */)((char *)pmap), (void const   */* __restrict  */)((char *)(pmap_init)),
         sizeof(pmap_init));
#line 500
  (pmap + loc)->cost = 0;
#line 501
  (pmap + loc)->inc_cost = 0;
#line 502
  (pmap + loc)->terrain = (char )terrain;
#line 504
  perim->len = 1L;
#line 505
  perim->list[0] = loc;
#line 507
  best_cost = 10000000;
#line 508
  best_loc = loc;
  }
#line 509
  return;
}
}
#line 526 "/home/june/repo/benchmarks/collector/temp/empire-1.11/map.c"
static void expand_perimeter(path_map_t *pmap , view_map_t *vmap , move_info_t *move_info ,
                             perimeter_t *curp , int type , int cur_cost , int inc_wcost ,
                             int inc_lcost , perimeter_t *waterp , perimeter_t *landp ) 
{ 
  register long i ;
  register int j ;
  loc_t new_loc ;
  int obj_cost ;
  register int new_type ;
  register path_map_t *pm ;
  int tmp ;

  {
#line 547
  i = 0L;
  {
#line 547
  while (1) {
    while_continue: /* CIL Label */ ;
#line 547
    if (! (i < curp->len)) {
#line 547
      goto while_break;
    }
#line 548
    j = 0;
    {
#line 548
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 548
      if (j < 8) {
#line 548
        new_loc = curp->list[i] + (long )dir_offset[j];
#line 548
        tmp = 1;
      } else {
#line 548
        tmp = 0;
      }
#line 548
      if (! tmp) {
#line 548
        goto while_break___0;
      }
#line 548
      if (map[new_loc].on_board) {
#line 549
        pm = pmap + new_loc;
#line 551
        if (pm->cost == 10000000) {
          {
#line 552
          new_type = terrain_type(pmap, vmap, move_info, curp->list[i], new_loc);
          }
#line 554
          if (new_type == 2) {
#line 554
            if (type & 2) {
              {
#line 555
              add_cell(pmap, new_loc, landp, new_type, cur_cost, inc_lcost);
              }
            } else {
#line 554
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
#line 556
          if (new_type == 4) {
#line 556
            if (type & 4) {
              {
#line 557
              add_cell(pmap, new_loc, waterp, new_type, cur_cost, inc_wcost);
              }
            } else {
#line 556
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 558
          if (new_type == 0) {
#line 559
            pm->terrain = (char )new_type;
#line 560
            pm->cost = cur_cost + 5000000;
#line 561
            pm->inc_cost = 5000000;
          }
#line 563
          if ((pmap + new_loc)->cost != 10000000) {
            {
#line 564
            obj_cost = objective_cost(vmap, move_info, new_loc, cur_cost);
            }
#line 565
            if (obj_cost < best_cost) {
#line 566
              best_cost = obj_cost;
#line 567
              best_loc = new_loc;
#line 568
              if (new_type == 0) {
#line 569
                pm->cost = cur_cost + 2;
#line 570
                pm->inc_cost = 2;
              }
            }
          }
        }
      }
#line 548
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 547
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 576
  return;
}
}
#line 580 "/home/june/repo/benchmarks/collector/temp/empire-1.11/map.c"
static void add_cell(path_map_t *pmap , loc_t new_loc , perimeter_t *perim , int terrain ,
                     int cur_cost , int inc_cost ) 
{ 
  register path_map_t *pm ;

  {
#line 584
  pm = pmap + new_loc;
#line 586
  pm->terrain = (char )terrain;
#line 587
  pm->inc_cost = inc_cost;
#line 588
  pm->cost = cur_cost + inc_cost;
#line 590
  perim->list[perim->len] = new_loc;
#line 591
  (perim->len) ++;
#line 592
  return;
}
}
#line 596 "/home/june/repo/benchmarks/collector/temp/empire-1.11/map.c"
static int objective_cost(view_map_t *vmap , move_info_t *move_info , loc_t loc ,
                          int base_cost ) 
{ 
  char *p ;
  int w ;
  city_info_t *cityp ;

  {
  {
#line 604
  p = strchr((char const   *)move_info->objectives, (int )(vmap + loc)->contents);
  }
#line 605
  if (! p) {
#line 605
    return (10000000);
  }
#line 607
  w = move_info->weights[p - move_info->objectives];
#line 608
  if (w >= 0) {
#line 608
    return (w + base_cost);
  }
  {
#line 611
  if (w == -1) {
#line 611
    goto case_neg_1;
  }
#line 623
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 613
  cityp = find_city(loc);
  }
#line 614
  if (! cityp) {
#line 614
    return (base_cost + 2);
  }
#line 615
  if ((int )cityp->prod != 5) {
#line 615
    return (base_cost + 2);
  }
#line 618
  w = (int )((long )piece_attr[5].build_time - cityp->work);
#line 619
  w *= 2;
#line 620
  if (w < base_cost + 2) {
#line 620
    w = base_cost + 2;
  }
#line 621
  return (w);
  switch_default: /* CIL Label */ 
  {
#line 624
  assert((char *)"aborting", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/map.c",
         624);
  }
#line 626
  return (-1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 634 "/home/june/repo/benchmarks/collector/temp/empire-1.11/map.c"
static int terrain_type(path_map_t *pmap , view_map_t *vmap , move_info_t *move_info ,
                        loc_t from_loc , loc_t to_loc ) 
{ 


  {
#line 638
  if ((int )(vmap + to_loc)->contents == 43) {
#line 638
    return (2);
  }
#line 639
  if ((int )(vmap + to_loc)->contents == 46) {
#line 639
    return (4);
  }
#line 640
  if ((int )(vmap + to_loc)->contents == 37) {
#line 640
    return (0);
  }
#line 641
  if ((int )(vmap + to_loc)->contents == 32) {
#line 641
    return ((int )(pmap + from_loc)->terrain);
  }
  {
#line 644
  if ((int )map[to_loc].contents == 46) {
#line 644
    goto case_46;
  }
#line 645
  if ((int )map[to_loc].contents == 43) {
#line 645
    goto case_43;
  }
#line 646
  if ((int )map[to_loc].contents == 42) {
#line 646
    goto case_42;
  }
#line 643
  goto switch_break;
  case_46: /* CIL Label */ 
#line 644
  return (4);
  case_43: /* CIL Label */ 
#line 645
  return (2);
  case_42: /* CIL Label */ 
#line 647
  if ((int )(map[to_loc].cityp)->owner == (int )move_info->city_owner) {
#line 648
    return (4);
  } else {
#line 650
    return (0);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 652
  assert((char *)"aborting", (char *)"/home/june/repo/benchmarks/collector/temp/empire-1.11/map.c",
         652);
  }
#line 654
  return (-1);
}
}
#line 687 "/home/june/repo/benchmarks/collector/temp/empire-1.11/map.c"
void vmap_prune_explore_locs(view_map_t *vmap ) 
{ 
  path_map_t pmap[6000] ;
  perimeter_t *from ;
  perimeter_t *to ;
  int explored ;
  loc_t loc ;
  loc_t new_loc ;
  count_t i ;
  long copied ;
  int tmp ;
  perimeter_t *x ;
  perimeter_t *x___0 ;
  perimeter_t *x___1 ;

  {
  {
#line 697
  memset((void *)(pmap), '\000', sizeof(pmap));
#line 698
  from = & p1;
#line 699
  to = & p2;
#line 700
  from->len = 0L;
#line 701
  explored = 0;
#line 704
  loc = (loc_t )0;
  }
  {
#line 704
  while (1) {
    while_continue: /* CIL Label */ ;
#line 704
    if (! (loc < 6000L)) {
#line 704
      goto while_break;
    }
#line 705
    if ((int )(vmap + loc)->contents != 32) {
#line 706
      explored ++;
    } else {
#line 708
      i = (count_t )0;
      {
#line 708
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 708
        if (i < 8L) {
#line 708
          new_loc = loc + (loc_t )dir_offset[i];
#line 708
          tmp = 1;
        } else {
#line 708
          tmp = 0;
        }
#line 708
        if (! tmp) {
#line 708
          goto while_break___0;
        }
#line 709
        if (! (new_loc < 0L)) {
#line 709
          if (! (new_loc >= 6000L)) {
#line 710
            if (! ((int )(vmap + new_loc)->contents == 32)) {
#line 711
              if ((int )map[new_loc].contents != 46) {
#line 712
                (pmap[loc].cost) ++;
              } else {
#line 713
                (pmap[loc].inc_cost) ++;
              }
            }
          }
        }
#line 708
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 715
      if (pmap[loc].cost) {
#line 716
        from->list[from->len] = loc;
#line 717
        (from->len) ++;
      } else
#line 715
      if (pmap[loc].inc_cost) {
#line 716
        from->list[from->len] = loc;
#line 717
        (from->len) ++;
      }
    }
#line 704
    loc ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 722
  if ((int )print_vmap == 73) {
    {
#line 723
    print_xzoom(vmap);
    }
  }
  {
#line 725
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 726
    if (from->len + (long )explored == 6000L) {
#line 726
      return;
    }
#line 727
    to->len = 0L;
#line 728
    copied = 0L;
#line 730
    i = (count_t )0;
    {
#line 730
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 730
      if (! (i < from->len)) {
#line 730
        goto while_break___2;
      }
#line 731
      loc = from->list[i];
#line 732
      if (pmap[loc].cost >= 5) {
        {
#line 733
        expand_prune(vmap, pmap, loc, 2, to, & explored);
        }
      } else
#line 734
      if (pmap[loc].inc_cost >= 5) {
        {
#line 735
        expand_prune(vmap, pmap, loc, 4, to, & explored);
        }
      } else
#line 736
      if (loc < 100L) {
#line 736
        goto _L___5;
      } else
#line 736
      if (loc >= 5900L) {
        _L___5: /* CIL Label */ 
#line 736
        if (pmap[loc].cost >= 3) {
          {
#line 737
          expand_prune(vmap, pmap, loc, 2, to, & explored);
          }
        } else {
#line 736
          goto _L___4;
        }
      } else
      _L___4: /* CIL Label */ 
#line 738
      if (loc < 100L) {
#line 738
        goto _L___3;
      } else
#line 738
      if (loc >= 5900L) {
        _L___3: /* CIL Label */ 
#line 738
        if (pmap[loc].inc_cost >= 3) {
          {
#line 739
          expand_prune(vmap, pmap, loc, 4, to, & explored);
          }
        } else {
#line 738
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 740
      if (loc == 0L) {
#line 740
        goto _L___1;
      } else
#line 740
      if (loc == 5999L) {
        _L___1: /* CIL Label */ 
#line 740
        if (pmap[loc].cost >= 2) {
          {
#line 741
          expand_prune(vmap, pmap, loc, 2, to, & explored);
          }
        } else {
#line 740
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 742
      if (loc == 0L) {
#line 742
        goto _L;
      } else
#line 742
      if (loc == 5999L) {
        _L: /* CIL Label */ 
#line 742
        if (pmap[loc].inc_cost >= 2) {
          {
#line 743
          expand_prune(vmap, pmap, loc, 4, to, & explored);
          }
        } else {
#line 745
          to->list[to->len] = loc;
#line 746
          (to->len) ++;
#line 747
          copied ++;
        }
      } else {
#line 745
        to->list[to->len] = loc;
#line 746
        (to->len) ++;
#line 747
        copied ++;
      }
#line 730
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 750
    if (copied == from->len) {
#line 750
      goto while_break___1;
    }
#line 751
    x = from;
#line 751
    from = to;
#line 751
    to = x;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 754
  if ((int )print_vmap == 73) {
    {
#line 755
    print_xzoom(vmap);
    }
  }
#line 758
  if (from->len + (long )explored == 6000L) {
#line 759
    return;
  }
#line 760
  to->len = 0L;
#line 762
  i = (count_t )0;
  {
#line 762
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 762
    if (! (i < from->len)) {
#line 762
      goto while_break___3;
    }
#line 763
    loc = from->list[i];
#line 764
    if (pmap[loc].cost > pmap[loc].inc_cost) {
      {
#line 765
      expand_prune(vmap, pmap, loc, 2, to, & explored);
      }
    } else
#line 766
    if (pmap[loc].cost < pmap[loc].inc_cost) {
      {
#line 767
      expand_prune(vmap, pmap, loc, 4, to, & explored);
      }
    } else {
#line 769
      to->list[to->len] = loc;
#line 770
      (to->len) ++;
    }
#line 762
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 773
  x___0 = from;
#line 773
  from = to;
#line 773
  to = x___0;
#line 775
  if ((int )print_vmap == 73) {
    {
#line 775
    print_xzoom(vmap);
    }
  }
  {
#line 778
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 780
    if (from->len + (long )explored >= 5940L) {
#line 781
      if ((int )print_vmap == 73) {
        {
#line 781
        print_xzoom(vmap);
        }
      }
#line 782
      return;
    }
#line 784
    to->len = 0L;
#line 785
    copied = 0L;
#line 787
    i = (count_t )0;
    {
#line 787
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 787
      if (! (i < from->len)) {
#line 787
        goto while_break___5;
      }
#line 788
      loc = from->list[i];
#line 789
      if (pmap[loc].cost >= 4) {
#line 789
        if (pmap[loc].inc_cost < 4) {
          {
#line 790
          expand_prune(vmap, pmap, loc, 2, to, & explored);
          }
        } else {
#line 789
          goto _L___10;
        }
      } else
      _L___10: /* CIL Label */ 
#line 791
      if (pmap[loc].inc_cost >= 4) {
#line 791
        if (pmap[loc].cost < 4) {
          {
#line 792
          expand_prune(vmap, pmap, loc, 4, to, & explored);
          }
        } else {
#line 791
          goto _L___9;
        }
      } else
      _L___9: /* CIL Label */ 
#line 793
      if (loc < 100L) {
#line 793
        goto _L___8;
      } else
#line 793
      if (loc >= 5900L) {
        _L___8: /* CIL Label */ 
#line 793
        if (pmap[loc].cost > pmap[loc].inc_cost) {
          {
#line 794
          expand_prune(vmap, pmap, loc, 2, to, & explored);
          }
        } else {
#line 793
          goto _L___7;
        }
      } else
      _L___7: /* CIL Label */ 
#line 795
      if (loc < 100L) {
#line 795
        goto _L___6;
      } else
#line 795
      if (loc >= 5900L) {
        _L___6: /* CIL Label */ 
#line 795
        if (pmap[loc].inc_cost > pmap[loc].cost) {
          {
#line 796
          expand_prune(vmap, pmap, loc, 4, to, & explored);
          }
        } else {
#line 798
          to->list[to->len] = loc;
#line 799
          (to->len) ++;
#line 800
          copied ++;
        }
      } else {
#line 798
        to->list[to->len] = loc;
#line 799
        (to->len) ++;
#line 800
        copied ++;
      }
#line 787
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 803
    if (copied == from->len) {
#line 803
      goto while_break___4;
    }
#line 804
    x___1 = from;
#line 804
    from = to;
#line 804
    to = x___1;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 806
  if ((int )print_vmap == 73) {
    {
#line 806
    print_xzoom(vmap);
    }
  }
#line 807
  return;
}
}
#line 818 "/home/june/repo/benchmarks/collector/temp/empire-1.11/map.c"
static void expand_prune(view_map_t *vmap , path_map_t *pmap , loc_t loc , int type ,
                         perimeter_t *to , int *explored ) 
{ 
  int i ;
  loc_t new_loc ;
  int tmp ;

  {
#line 825
  (*explored) ++;
#line 827
  if (type == 2) {
#line 828
    (vmap + loc)->contents = (char )'+';
  } else {
#line 830
    (vmap + loc)->contents = (char )'.';
  }
#line 832
  i = 0;
  {
#line 832
  while (1) {
    while_continue: /* CIL Label */ ;
#line 832
    if (i < 8) {
#line 832
      new_loc = loc + (loc_t )dir_offset[i];
#line 832
      tmp = 1;
    } else {
#line 832
      tmp = 0;
    }
#line 832
    if (! tmp) {
#line 832
      goto while_break;
    }
#line 833
    if (new_loc >= 0L) {
#line 833
      if (new_loc < 6000L) {
#line 833
        if ((int )(vmap + new_loc)->contents == 32) {
#line 834
          if (! (pmap + new_loc)->cost) {
#line 834
            if (! (pmap + new_loc)->inc_cost) {
#line 835
              to->list[to->len] = new_loc;
#line 836
              (to->len) ++;
            }
          }
#line 838
          if (type == 2) {
#line 839
            ((pmap + new_loc)->cost) ++;
          } else {
#line 840
            ((pmap + new_loc)->inc_cost) ++;
          }
        }
      }
    }
#line 832
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 842
  return;
}
}
#line 853 "/home/june/repo/benchmarks/collector/temp/empire-1.11/map.c"
long vmap_find_dest(path_map_t *path_map___0 , view_map_t *vmap , long cur_loc , long dest_loc ,
                    int owner , int terrain ) 
{ 
  perimeter_t *from ;
  perimeter_t *to ;
  int cur_cost ;
  int start_terrain ;
  move_info_t move_info ;
  char old_contents ;
  perimeter_t *x ;

  {
#line 868
  old_contents = (vmap + dest_loc)->contents;
#line 869
  (vmap + dest_loc)->contents = (char )'%';
#line 870
  move_info.city_owner = (char )owner;
#line 871
  move_info.objectives = (char *)"%";
#line 872
  move_info.weights[0] = 1;
#line 874
  from = & p1;
#line 875
  to = & p2;
#line 877
  if (terrain == 6) {
#line 877
    start_terrain = 2;
  } else {
#line 878
    start_terrain = terrain;
  }
  {
#line 880
  start_perimeter(path_map___0, from, cur_loc, start_terrain);
#line 881
  cur_cost = 0;
  }
  {
#line 883
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 884
    to->len = 0L;
#line 885
    expand_perimeter(path_map___0, vmap, & move_info, from, terrain, cur_cost, 1,
                     1, to, to);
#line 887
    cur_cost ++;
    }
#line 888
    if (to->len == 0L) {
#line 889
      (vmap + dest_loc)->contents = old_contents;
#line 890
      return (best_loc);
    } else
#line 888
    if (best_cost <= cur_cost) {
#line 889
      (vmap + dest_loc)->contents = old_contents;
#line 890
      return (best_loc);
    }
#line 892
    x = from;
#line 892
    from = to;
#line 892
    to = x;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 911 "/home/june/repo/benchmarks/collector/temp/empire-1.11/map.c"
void vmap_mark_path(path_map_t *path_map___0 , view_map_t *vmap , long dest ) 
{ 
  int n ;
  loc_t new_dest ;
  int tmp ;

  {
#line 917
  if ((path_map___0 + dest)->cost == 0) {
#line 917
    return;
  }
#line 918
  if ((int )(path_map___0 + dest)->terrain == 1) {
#line 918
    return;
  }
#line 920
  (path_map___0 + dest)->terrain = (char)1;
#line 923
  n = 0;
  {
#line 923
  while (1) {
    while_continue: /* CIL Label */ ;
#line 923
    if (n < 8) {
#line 923
      new_dest = dest + (long )dir_offset[n];
#line 923
      tmp = 1;
    } else {
#line 923
      tmp = 0;
    }
#line 923
    if (! tmp) {
#line 923
      goto while_break;
    }
#line 924
    if ((path_map___0 + new_dest)->cost == (path_map___0 + dest)->cost - (path_map___0 + dest)->inc_cost) {
      {
#line 925
      vmap_mark_path(path_map___0, vmap, new_dest);
      }
    }
#line 923
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 927
  return;
}
}
#line 935 "/home/june/repo/benchmarks/collector/temp/empire-1.11/map.c"
void vmap_mark_adjacent(path_map_t *path_map___0 , long loc ) 
{ 
  int i ;
  loc_t new_loc ;
  int tmp ;

  {
#line 941
  i = 0;
  {
#line 941
  while (1) {
    while_continue: /* CIL Label */ ;
#line 941
    if (i < 8) {
#line 941
      new_loc = loc + (long )dir_offset[i];
#line 941
      tmp = 1;
    } else {
#line 941
      tmp = 0;
    }
#line 941
    if (! tmp) {
#line 941
      goto while_break;
    }
#line 941
    if (map[new_loc].on_board) {
#line 942
      (path_map___0 + new_loc)->terrain = (char)1;
    }
#line 941
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 943
  return;
}
}
#line 951 "/home/june/repo/benchmarks/collector/temp/empire-1.11/map.c"
void vmap_mark_near_path(path_map_t *path_map___0 , long loc ) 
{ 
  int i ;
  int j ;
  loc_t new_loc ;
  loc_t xloc ;
  int hit_loc[8] ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 958
  memset((void *)((char *)(hit_loc)), '\000', sizeof(int ) * 8UL);
#line 960
  i = 0;
  }
  {
#line 960
  while (1) {
    while_continue: /* CIL Label */ ;
#line 960
    if (i < 8) {
#line 960
      new_loc = loc + (long )dir_offset[i];
#line 960
      tmp___0 = 1;
    } else {
#line 960
      tmp___0 = 0;
    }
#line 960
    if (! tmp___0) {
#line 960
      goto while_break;
    }
#line 960
    if (map[new_loc].on_board) {
#line 961
      j = 0;
      {
#line 961
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 961
        if (j < 8) {
#line 961
          xloc = new_loc + (loc_t )dir_offset[j];
#line 961
          tmp = 1;
        } else {
#line 961
          tmp = 0;
        }
#line 961
        if (! tmp) {
#line 961
          goto while_break___0;
        }
#line 961
        if (map[xloc].on_board) {
#line 962
          if (xloc != loc) {
#line 962
            if ((int )(path_map___0 + xloc)->terrain == 1) {
#line 963
              hit_loc[i] = 1;
#line 964
              goto while_break___0;
            }
          }
        }
#line 961
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 960
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 967
  i = 0;
  {
#line 967
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 967
    if (! (i < 8)) {
#line 967
      goto while_break___1;
    }
#line 968
    if (hit_loc[i]) {
#line 969
      (path_map___0 + (loc + (long )dir_offset[i]))->terrain = (char)1;
    }
#line 967
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 970
  return;
}
}
#line 998 "/home/june/repo/benchmarks/collector/temp/empire-1.11/map.c"
static int order[8]  = 
#line 998
  {      7,      1,      5,      3, 
        6,      2,      0,      4};
#line 1001 "/home/june/repo/benchmarks/collector/temp/empire-1.11/map.c"
long vmap_find_dir(path_map_t *path_map___0 , view_map_t *vmap , long loc , char *terrain ,
                   char *adj_char ) 
{ 
  int i ;
  int count ;
  int bestcount ;
  loc_t bestloc ;
  loc_t new_loc ;
  int path_count ;
  int bestpath ;
  char *p ;

  {
#line 1010
  if (trace_pmap) {
    {
#line 1011
    print_pzoom((char *)"Before vmap_find_dir:", path_map___0, vmap);
    }
  }
#line 1013
  bestcount = -10000000;
#line 1014
  bestpath = -1;
#line 1015
  bestloc = loc;
#line 1017
  i = 0;
  {
#line 1017
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1017
    if (! (i < 8)) {
#line 1017
      goto while_break;
    }
#line 1018
    new_loc = loc + (long )dir_offset[order[i]];
#line 1019
    if ((int )(path_map___0 + new_loc)->terrain == 1) {
      {
#line 1020
      p = strchr((char const   *)terrain, (int )(vmap + new_loc)->contents);
      }
#line 1022
      if ((unsigned long )p != (unsigned long )((void *)0)) {
        {
#line 1023
        count = vmap_count_adjacent(vmap, new_loc, adj_char);
#line 1024
        path_count = vmap_count_path(path_map___0, new_loc);
        }
#line 1027
        if (count > bestcount) {
#line 1029
          bestcount = count;
#line 1030
          bestpath = path_count;
#line 1031
          bestloc = new_loc;
        } else
#line 1027
        if (count == bestcount) {
#line 1027
          if (path_count > bestpath) {
#line 1029
            bestcount = count;
#line 1030
            bestpath = path_count;
#line 1031
            bestloc = new_loc;
          }
        }
      }
    }
#line 1017
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1036
  return (bestloc);
}
}
#line 1045 "/home/june/repo/benchmarks/collector/temp/empire-1.11/map.c"
int vmap_count_adjacent(view_map_t *vmap , long loc , char *adj_char ) 
{ 
  int i ;
  int count ;
  loc_t new_loc ;
  char *p ;
  int len ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 1053
  tmp = strlen((char const   *)adj_char);
#line 1053
  len = (int )tmp;
#line 1055
  count = 0;
#line 1057
  i = 0;
  }
  {
#line 1057
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1057
    if (i < 8) {
#line 1057
      new_loc = loc + (long )dir_offset[i];
#line 1057
      tmp___0 = 1;
    } else {
#line 1057
      tmp___0 = 0;
    }
#line 1057
    if (! tmp___0) {
#line 1057
      goto while_break;
    }
#line 1057
    if (map[new_loc].on_board) {
      {
#line 1058
      p = strchr((char const   *)adj_char, (int )(vmap + new_loc)->contents);
      }
#line 1059
      if (p) {
#line 1059
        count = (int )((long )count + 8L * ((long )len - (p - adj_char)));
      }
    }
#line 1057
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1061
  return (count);
}
}
#line 1068 "/home/june/repo/benchmarks/collector/temp/empire-1.11/map.c"
static int vmap_count_path(path_map_t *pmap , loc_t loc ) 
{ 
  int i ;
  int count ;
  loc_t new_loc ;
  int tmp ;

  {
#line 1074
  count = 0;
#line 1076
  i = 0;
  {
#line 1076
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1076
    if (i < 8) {
#line 1076
      new_loc = loc + (loc_t )dir_offset[i];
#line 1076
      tmp = 1;
    } else {
#line 1076
      tmp = 0;
    }
#line 1076
    if (! tmp) {
#line 1076
      goto while_break;
    }
#line 1076
    if (map[new_loc].on_board) {
#line 1077
      if ((int )(pmap + new_loc)->terrain == 1) {
#line 1078
        count ++;
      }
    }
#line 1076
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1080
  return (count);
}
}
#line 1088 "/home/june/repo/benchmarks/collector/temp/empire-1.11/map.c"
_Bool rmap_shore(long loc ) 
{ 
  loc_t i ;
  loc_t j ;
  int tmp ;

  {
#line 1093
  i = (loc_t )0;
  {
#line 1093
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1093
    if (i < 8L) {
#line 1093
      j = loc + (long )dir_offset[i];
#line 1093
      tmp = 1;
    } else {
#line 1093
      tmp = 0;
    }
#line 1093
    if (! tmp) {
#line 1093
      goto while_break;
    }
#line 1093
    if (map[j].on_board) {
#line 1094
      if ((int )map[j].contents == 46) {
#line 1095
        return ((_Bool)1);
      }
    }
#line 1093
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1097
  return ((_Bool)0);
}
}
#line 1100 "/home/june/repo/benchmarks/collector/temp/empire-1.11/map.c"
_Bool vmap_shore(view_map_t *vmap , long loc ) 
{ 
  loc_t i ;
  loc_t j ;
  int tmp ;

  {
#line 1105
  i = (loc_t )0;
  {
#line 1105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1105
    if (i < 8L) {
#line 1105
      j = loc + (long )dir_offset[i];
#line 1105
      tmp = 1;
    } else {
#line 1105
      tmp = 0;
    }
#line 1105
    if (! tmp) {
#line 1105
      goto while_break;
    }
#line 1105
    if (map[j].on_board) {
#line 1106
      if ((int )(vmap + j)->contents != 32) {
#line 1106
        if ((int )(vmap + j)->contents != 43) {
#line 1106
          if ((int )map[j].contents == 46) {
#line 1109
            return ((_Bool)1);
          }
        }
      }
    }
#line 1105
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1111
  return ((_Bool)0);
}
}
#line 1119 "/home/june/repo/benchmarks/collector/temp/empire-1.11/map.c"
_Bool vmap_at_sea(view_map_t *vmap , long loc ) 
{ 
  loc_t i ;
  loc_t j ;
  int tmp ;

  {
#line 1124
  if ((int )map[loc].contents != 46) {
#line 1125
    return ((_Bool)0);
  }
#line 1126
  i = (loc_t )0;
  {
#line 1126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1126
    if (i < 8L) {
#line 1126
      j = loc + (long )dir_offset[i];
#line 1126
      tmp = 1;
    } else {
#line 1126
      tmp = 0;
    }
#line 1126
    if (! tmp) {
#line 1126
      goto while_break;
    }
#line 1126
    if (map[j].on_board) {
#line 1127
      if ((int )(vmap + j)->contents == 32) {
#line 1130
        return ((_Bool)0);
      } else
#line 1127
      if ((int )(vmap + j)->contents == 43) {
#line 1130
        return ((_Bool)0);
      } else
#line 1127
      if ((int )map[j].contents != 46) {
#line 1130
        return ((_Bool)0);
      }
    }
#line 1126
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1132
  return ((_Bool)1);
}
}
#line 1135 "/home/june/repo/benchmarks/collector/temp/empire-1.11/map.c"
_Bool rmap_at_sea(long loc ) 
{ 
  loc_t i ;
  loc_t j ;
  int tmp ;

  {
#line 1140
  if ((int )map[loc].contents != 46) {
#line 1141
    return ((_Bool)0);
  }
#line 1142
  i = (loc_t )0;
  {
#line 1142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1142
    if (i < 8L) {
#line 1142
      j = loc + (long )dir_offset[i];
#line 1142
      tmp = 1;
    } else {
#line 1142
      tmp = 0;
    }
#line 1142
    if (! tmp) {
#line 1142
      goto while_break;
    }
#line 1142
    if (map[j].on_board) {
#line 1143
      if ((int )map[j].contents != 46) {
#line 1144
        return ((_Bool)0);
      }
    }
#line 1142
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1146
  return ((_Bool)1);
}
}
#line 689 "/usr/include/stdio.h"
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/empire-1.11/empire.c"
void c_examine(void) ;
#line 17
void c_movie(void) ;
#line 30
void do_command(char orders ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/empire-1.11/empire.c"
void empire(void) 
{ 
  char order___0 ;
  int turn ;
  int tmp ;

  {
  {
#line 34
  turn = 0;
#line 36
  ttinit();
#line 37
  rndini();
#line 39
  clear_screen();
#line 40
  pos_str(7, 0, (char *)"EMPIRE, Version 5.00 site Amdahl 1-Apr-1988");
#line 41
  pos_str(8, 0, (char *)"Detailed directions are in EMPIRE.DOC\n");
#line 42
  redisplay();
#line 44
  tmp = restore_game();
  }
#line 44
  if (! tmp) {
    {
#line 45
    init_game();
    }
  }
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 50
    if (automove) {
      {
#line 51
      user_move();
#line 52
      comp_move(1);
#line 53
      turn ++;
      }
#line 53
      if (turn % save_interval == 0) {
        {
#line 54
        save_game();
        }
      }
    } else {
      {
#line 57
      prompt((char *)"");
#line 58
      redisplay();
#line 59
      prompt((char *)"Your orders? ");
#line 60
      order___0 = get_chx();
#line 61
      do_command(order___0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 73
void c_debug(char order___0 ) ;
#line 73
void c_quit(void) ;
#line 73
void c_sector(void) ;
#line 73
void c_map(void) ;
#line 74
void c_give(void) ;
#line 70 "/home/june/repo/benchmarks/collector/temp/empire-1.11/empire.c"
void do_command(char orders ) 
{ 
  char e ;
  int ncycle ;
  int tmp ;

  {
  {
#line 80
  if ((int )orders == 65) {
#line 80
    goto case_65;
  }
#line 88
  if ((int )orders == 67) {
#line 88
    goto case_67;
  }
#line 92
  if ((int )orders == 68) {
#line 92
    goto case_68;
  }
#line 96
  if ((int )orders == 69) {
#line 96
    goto case_69;
  }
#line 101
  if ((int )orders == 70) {
#line 101
    goto case_70;
  }
#line 105
  if ((int )orders == 71) {
#line 105
    goto case_71;
  }
#line 109
  if ((int )orders == 72) {
#line 109
    goto case_72;
  }
#line 113
  if ((int )orders == 74) {
#line 113
    goto case_74;
  }
#line 119
  if ((int )orders == 77) {
#line 119
    goto case_77;
  }
#line 125
  if ((int )orders == 78) {
#line 125
    goto case_78;
  }
#line 131
  if ((int )orders == 80) {
#line 131
    goto case_80;
  }
#line 136
  if ((int )orders == 81) {
#line 136
    goto case_81;
  }
#line 136
  if ((int )orders == 22) {
#line 136
    goto case_81;
  }
#line 140
  if ((int )orders == 82) {
#line 140
    goto case_82;
  }
#line 145
  if ((int )orders == 83) {
#line 145
    goto case_83;
  }
#line 149
  if ((int )orders == 84) {
#line 149
    goto case_84;
  }
#line 155
  if ((int )orders == 87) {
#line 155
    goto case_87;
  }
#line 160
  if ((int )orders == 90) {
#line 160
    goto case_90;
  }
#line 164
  if ((int )orders == 12) {
#line 164
    goto case_12;
  }
#line 168
  if ((int )orders == 43) {
#line 168
    goto case_43;
  }
#line 177
  goto switch_default;
  case_65: /* CIL Label */ 
  {
#line 81
  automove = (_Bool)1;
#line 82
  error((char *)"Now in Auto-Mode");
#line 83
  user_move();
#line 84
  comp_move(1);
#line 85
  save_game();
  }
#line 86
  goto switch_break;
  case_67: /* CIL Label */ 
  {
#line 89
  c_give();
  }
#line 90
  goto switch_break;
  case_68: /* CIL Label */ 
  {
#line 93
  error((char *)"Round #%d", date);
  }
#line 94
  goto switch_break;
  case_69: /* CIL Label */ 
#line 97
  if (resigned) {
    {
#line 97
    c_examine();
    }
  } else {
    {
#line 98
    huh();
    }
  }
#line 99
  goto switch_break;
  case_70: /* CIL Label */ 
  {
#line 102
  c_map();
  }
#line 103
  goto switch_break;
  case_71: /* CIL Label */ 
  {
#line 106
  comp_move(1);
  }
#line 107
  goto switch_break;
  case_72: /* CIL Label */ 
  {
#line 110
  help(help_cmd, cmd_lines);
  }
#line 111
  goto switch_break;
  case_74: /* CIL Label */ 
  {
#line 114
  ncycle = cur_sector();
  }
#line 115
  if (ncycle == -1) {
#line 115
    ncycle = 0;
  }
  {
#line 116
  edit((long )(((ncycle % 5) * 12 + 6) * 100 + ((ncycle / 5) * 50 + 25)));
  }
#line 117
  goto switch_break;
  case_77: /* CIL Label */ 
  {
#line 120
  user_move();
#line 121
  comp_move(1);
#line 122
  save_game();
  }
#line 123
  goto switch_break;
  case_78: /* CIL Label */ 
  {
#line 126
  ncycle = getint((char *)"Number of free enemy moves: ");
#line 127
  comp_move(ncycle);
#line 128
  save_game();
  }
#line 129
  goto switch_break;
  case_80: /* CIL Label */ 
  {
#line 132
  c_sector();
  }
#line 133
  goto switch_break;
  case_81: /* CIL Label */ 
  case_22: /* CIL Label */ 
  {
#line 137
  c_quit();
  }
#line 138
  goto switch_break;
  case_82: /* CIL Label */ 
  {
#line 141
  clear_screen();
#line 142
  tmp = restore_game();
#line 142
  e = (char )tmp;
  }
#line 143
  goto switch_break;
  case_83: /* CIL Label */ 
  {
#line 146
  save_game();
  }
#line 147
  goto switch_break;
  case_84: /* CIL Label */ 
#line 150
  save_movie = (_Bool )(! save_movie);
#line 151
  if (save_movie) {
    {
#line 151
    comment((char *)"Saving movie screens to \'empmovie.dat\'.");
    }
  } else {
    {
#line 152
    comment((char *)"No longer saving movie screens.");
    }
  }
#line 153
  goto switch_break;
  case_87: /* CIL Label */ 
#line 156
  if (resigned) {
    {
#line 156
    replay_movie();
    }
  } else
#line 156
  if (debug) {
    {
#line 156
    replay_movie();
    }
  } else {
    {
#line 157
    error((char *)"You cannot watch movie until computer resigns.");
    }
  }
#line 158
  goto switch_break;
  case_90: /* CIL Label */ 
  {
#line 161
  print_zoom(user_map);
  }
#line 162
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 165
  redraw();
  }
#line 166
  goto switch_break;
  case_43: /* CIL Label */ 
  {
#line 169
  e = get_chx();
  }
#line 170
  if ((int )e == 43) {
#line 171
    debug = (_Bool)1;
  } else
#line 172
  if ((int )e == 45) {
#line 173
    debug = (_Bool)0;
  } else {
    {
#line 174
    huh();
    }
  }
#line 175
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 178
  if (debug) {
    {
#line 179
    c_debug(orders);
    }
  } else {
    {
#line 181
    huh();
    }
  }
#line 182
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 184
  return;
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/empire-1.11/empire.c"
void c_give(void) 
{ 
  int unowned[70] ;
  count_t i ;
  count_t count ;

  {
#line 198
  count = (count_t )0;
#line 199
  i = (count_t )0;
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 199
    if (! (i < 70L)) {
#line 199
      goto while_break;
    }
#line 200
    if ((int )city[i].owner == 0) {
#line 201
      unowned[count] = (int )i;
#line 202
      count ++;
    }
#line 199
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  if (count == 0L) {
    {
#line 206
    error((char *)"There are no unowned cities.");
#line 207
    ksend((char *)"There are no unowned cities.");
    }
#line 208
    return;
  }
  {
#line 210
  i = irand(count);
#line 211
  i = (count_t )unowned[i];
#line 212
  city[i].owner = (uchar )2;
#line 213
  city[i].prod = (char)-1;
#line 214
  city[i].work = 0L;
#line 215
  scan(comp_map, city[i].loc);
  }
#line 216
  return;
}
}
#line 223 "/home/june/repo/benchmarks/collector/temp/empire-1.11/empire.c"
void c_debug(char order___0 ) 
{ 
  char e ;
  char tmp ;

  {
  {
#line 229
  if ((int )order___0 == 35) {
#line 229
    goto case_35;
  }
#line 230
  if ((int )order___0 == 37) {
#line 230
    goto case_37;
  }
#line 232
  if ((int )order___0 == 64) {
#line 232
    goto case_64;
  }
#line 242
  if ((int )order___0 == 36) {
#line 242
    goto case_36;
  }
#line 252
  if ((int )order___0 == 38) {
#line 252
    goto case_38;
  }
#line 256
  goto switch_default;
  case_35: /* CIL Label */ 
  {
#line 229
  c_examine();
  }
#line 229
  goto switch_break;
  case_37: /* CIL Label */ 
  {
#line 230
  c_movie();
  }
#line 230
  goto switch_break;
  case_64: /* CIL Label */ 
  {
#line 233
  e = get_chx();
  }
#line 234
  if ((int )e == 43) {
#line 235
    trace_pmap = (_Bool)1;
  } else
#line 236
  if ((int )e == 45) {
#line 237
    trace_pmap = (_Bool)0;
  } else {
    {
#line 239
    huh();
    }
  }
#line 240
  goto switch_break;
  case_36: /* CIL Label */ 
  {
#line 243
  e = get_chx();
  }
#line 244
  if ((int )e == 43) {
#line 245
    print_debug = (_Bool)1;
  } else
#line 246
  if ((int )e == 45) {
#line 247
    print_debug = (_Bool)0;
  } else {
    {
#line 249
    huh();
    }
  }
#line 250
  goto switch_break;
  case_38: /* CIL Label */ 
  {
#line 253
  tmp = get_chx();
#line 253
  print_vmap = (_Bool )tmp;
  }
#line 254
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 256
  huh();
  }
#line 256
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 258
  return;
}
}
#line 264 "/home/june/repo/benchmarks/collector/temp/empire-1.11/empire.c"
void c_quit(void) 
{ 
  _Bool tmp ;

  {
  {
#line 267
  tmp = getyn((char *)"QUIT - Are you sure? ");
  }
#line 267
  if (tmp) {
    {
#line 268
    empend();
    }
  }
#line 270
  return;
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/empire-1.11/empire.c"
void c_sector(void) 
{ 
  int num ;

  {
  {
#line 282
  num = get_range((char *)"Sector number? ", 0, 9);
#line 283
  print_sector(1, user_map, num);
  }
#line 284
  return;
}
}
#line 293 "/home/june/repo/benchmarks/collector/temp/empire-1.11/empire.c"
void c_map(void) 
{ 
  FILE *f ;
  int i ;
  int j ;
  char line[62] ;

  {
  {
#line 300
  prompt((char *)"Filename? ");
#line 301
  get_str(jnkbuf, 80);
#line 303
  f = fopen((char const   */* __restrict  */)(jnkbuf), (char const   */* __restrict  */)"w");
  }
#line 304
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 305
    error((char *)"I can\'t open that file.");
    }
#line 306
    return;
  }
#line 308
  i = 0;
  {
#line 308
  while (1) {
    while_continue: /* CIL Label */ ;
#line 308
    if (! (i < 100)) {
#line 308
      goto while_break;
    }
#line 309
    j = 59;
    {
#line 309
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 309
      if (! (j >= 0)) {
#line 309
        goto while_break___0;
      }
#line 310
      line[59 - j] = user_map[(long )(j * 100 + i)].contents;
#line 309
      j --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 312
    j = 59;
    {
#line 313
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 313
      if (j >= 0) {
#line 313
        if (! ((int )line[j] == 32)) {
#line 313
          goto while_break___1;
        }
      } else {
#line 313
        goto while_break___1;
      }
#line 314
      j --;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 316
    j ++;
#line 316
    line[j] = (char )'\n';
#line 317
    j ++;
#line 317
    line[j] = (char)0;
#line 318
    fputs((char const   */* __restrict  */)(line), (FILE */* __restrict  */)f);
#line 308
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 320
  fclose(f);
  }
#line 321
  return;
}
}
#line 327 "/home/june/repo/benchmarks/collector/temp/empire-1.11/empire.c"
void c_examine(void) 
{ 
  int num ;

  {
  {
#line 332
  num = get_range((char *)"Sector number? ", 0, 9);
#line 333
  print_sector(2, comp_map, num);
  }
#line 334
  return;
}
}
#line 341 "/home/june/repo/benchmarks/collector/temp/empire-1.11/empire.c"
void c_movie(void) 
{ 


  {
  {
#line 344
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 345
    comp_move(1);
#line 346
    print_zoom(comp_map);
#line 347
    save_game();
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
