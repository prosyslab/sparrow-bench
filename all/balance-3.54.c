/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 144 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __key_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 90 "/usr/include/stdio.h"
typedef __off_t off_t;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 122 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __key_t key_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_7 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_7 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_8 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_8 fd_set;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 162 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr_storage {
   sa_family_t ss_family ;
   unsigned long __ss_align ;
   char __ss_padding[128UL - 2UL * sizeof(unsigned long )] ;
};
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 209 "/usr/include/netinet/in.h"
union __anonunion___in6_u_25 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 209 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_25 __in6_u ;
};
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 252 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 257 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_28 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_29 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_30 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_31 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_32 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_33 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_34 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_27 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_28 _kill ;
   struct __anonstruct__timer_29 _timer ;
   struct __anonstruct__rt_30 _rt ;
   struct __anonstruct__sigchld_31 _sigchld ;
   struct __anonstruct__sigfault_32 _sigfault ;
   struct __anonstruct__sigpoll_33 _sigpoll ;
   struct __anonstruct__sigsys_34 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_26 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_27 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_26 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_46 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_46 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 131 "/usr/include/x86_64-linux-gnu/bits/resource.h"
typedef __rlim_t rlim_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 42 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __rlimit_resource_t;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __off_t l_start ;
   __off_t l_len ;
   __pid_t l_pid ;
};
#line 79 "./balance.h"
struct __anonstruct_CHANNEL_79 {
   int status ;
   int port ;
   struct in_addr ipaddr ;
   int c ;
   int tc ;
   int maxc ;
   unsigned long long bsent ;
   unsigned long long breceived ;
};
#line 79 "./balance.h"
typedef struct __anonstruct_CHANNEL_79 CHANNEL;
#line 93 "./balance.h"
struct __anonstruct_GROUP_80 {
   int nchannels ;
   int current ;
   int type ;
   CHANNEL channels[64] ;
};
#line 93 "./balance.h"
typedef struct __anonstruct_GROUP_80 GROUP;
#line 100 "./balance.h"
struct __anonstruct_COMMON_81 {
   int release ;
   int subrelease ;
   int pid ;
   GROUP groups[16] ;
};
#line 100 "./balance.h"
typedef struct __anonstruct_COMMON_81 COMMON;
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 133 "./balance.h"
unsigned int hash_fold(char *s , int len ) ;
#line 134
ssize_t writen(int fd , unsigned char *ptr , size_t nbytes ) ;
#line 13 "/home/june/collector/temp/balance-3.54/butils.c"
char *butils_rcsid  =    (char *)"$Id: butils.c,v 1.1 2010/01/29 10:40:16 t Exp $";
#line 15 "/home/june/collector/temp/balance-3.54/butils.c"
unsigned int hash_fold(char *s , int len ) 
{ 
  unsigned int rc ;
  int i ;

  {
#line 17
  rc = 0U;
#line 19
  i = 0;
  {
#line 19
  while (1) {
    while_continue: /* CIL Label */ ;
#line 19
    if (! (i < len)) {
#line 19
      goto while_break;
    }
#line 20
    rc = (unsigned int )*(s + i) + 31U * rc;
#line 19
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 23
  return (rc);
}
}
#line 26 "/home/june/collector/temp/balance-3.54/butils.c"
ssize_t writen(int fd , unsigned char *ptr , size_t nbytes ) 
{ 
  int nleft ;
  ssize_t nwritten ;

  {
#line 31
  nleft = (int )nbytes;
  {
#line 33
  while (1) {
    while_continue: /* CIL Label */ ;
#line 33
    if (! (nleft > 0)) {
#line 33
      goto while_break;
    }
    {
#line 34
    nwritten = write(fd, (void const   *)ptr, (size_t )nleft);
    }
#line 35
    if (nwritten <= 0L) {
#line 36
      return (nwritten);
    }
#line 38
    nleft = (int )((ssize_t )nleft - nwritten);
#line 39
    ptr += nwritten;
  }
  while_break: /* CIL Label */ ;
  }
#line 42
  return ((ssize_t )(nbytes - (size_t )nleft));
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 336
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setvbuf)(FILE * __restrict  __stream ,
                                                                              char * __restrict  __buf ,
                                                                              int __modes ,
                                                                              size_t __n ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 50 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1), __leaf__)) bzero)(void *__s ,
                                                                                             size_t __n ) ;
#line 76
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) index)(char const   *__s ,
                                                                                              int __c )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 144 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 290
extern struct servent *getservbyname(char const   *__name , char const   *__proto ) ;
#line 662
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 671
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) gai_strerror)(int __ecode ) ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 215
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 181 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 432
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 660
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setpgrp)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 1016 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ftruncate)(int __fd ,
                                                                                __off_t __length ) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mmap)(void *__addr ,
                                                                             size_t __len ,
                                                                             int __prot ,
                                                                             int __flags ,
                                                                             int __fd ,
                                                                             __off_t __offset ) ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getrlimit)(__rlimit_resource_t __resource ,
                                                                                struct rlimit *__rlimits ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setrlimit)(__rlimit_resource_t __resource ,
                                                                                struct rlimit  const  *__rlimits ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 312
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 321
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 146
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 54 "/usr/include/x86_64-linux-gnu/sys/ipc.h"
extern  __attribute__((__nothrow__)) key_t ( __attribute__((__leaf__)) ftok)(char const   *__pathname ,
                                                                             int __proj_id ) ;
#line 53 "/usr/include/x86_64-linux-gnu/sys/shm.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) shmget)(key_t __key ,
                                                                             size_t __size ,
                                                                             int __shmflg ) ;
#line 56
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) shmat)(int __shmid ,
                                                                              void const   *__shmaddr ,
                                                                              int __shmflg ) ;
#line 34 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t ( __attribute__((__leaf__)) inet_addr)(char const   *__cp ) ;
#line 53
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 64
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) inet_ntop)(int __af ,
                                                                                          void const   * __restrict  __cp ,
                                                                                          char * __restrict  __buf ,
                                                                                          socklen_t __len ) ;
#line 111 "/home/june/collector/temp/balance-3.54/balance.c"
char const   *balance_rcsid  =    "$Id: balance.c,v 3.54 2010/12/03 12:47:10 t Exp $";
#line 112 "/home/june/collector/temp/balance-3.54/balance.c"
static char *revision  =    (char *)"$Revision: 3.54 $";
#line 114 "/home/june/collector/temp/balance-3.54/balance.c"
static int release  ;
#line 115 "/home/june/collector/temp/balance-3.54/balance.c"
static int subrelease  ;
#line 117 "/home/june/collector/temp/balance-3.54/balance.c"
static char rendezvousfile[1024]  ;
#line 118 "/home/june/collector/temp/balance-3.54/balance.c"
static int rendezvousfd  ;
#line 120 "/home/june/collector/temp/balance-3.54/balance.c"
static int shmfilefd  ;
#line 123 "/home/june/collector/temp/balance-3.54/balance.c"
static int err_dump(char *text ) 
{ 


  {
  {
#line 124
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"balance: %s\n",
          text);
#line 125
  fflush(stderr);
#line 126
  exit(69);
  }
}
}
#line 129 "/home/june/collector/temp/balance-3.54/balance.c"
COMMON *common  ;
#line 131 "/home/june/collector/temp/balance-3.54/balance.c"
static int hashfailover  =    0;
#line 132 "/home/june/collector/temp/balance-3.54/balance.c"
static int autodisable  =    0;
#line 133 "/home/june/collector/temp/balance-3.54/balance.c"
static int debugflag  =    0;
#line 134 "/home/june/collector/temp/balance-3.54/balance.c"
static int foreground  =    0;
#line 135 "/home/june/collector/temp/balance-3.54/balance.c"
static int packetdump  =    0;
#line 136 "/home/june/collector/temp/balance-3.54/balance.c"
static int interactive  =    0;
#line 137 "/home/june/collector/temp/balance-3.54/balance.c"
static int shmmapfile  =    0;
#line 138 "/home/june/collector/temp/balance-3.54/balance.c"
static int bindipv6  =    0;
#line 140 "/home/june/collector/temp/balance-3.54/balance.c"
static int sockbufsize  =    32768;
#line 142 "/home/june/collector/temp/balance-3.54/balance.c"
static int connect_timeout  ;
#line 144 "/home/june/collector/temp/balance-3.54/balance.c"
static char *bindhost  =    (char *)((void *)0);
#line 145 "/home/june/collector/temp/balance-3.54/balance.c"
static char *outbindhost  =    (char *)((void *)0);
#line 147 "/home/june/collector/temp/balance-3.54/balance.c"
static struct timeval sel_tmout  =    {(__time_t )0, (__suseconds_t )0};
#line 148 "/home/june/collector/temp/balance-3.54/balance.c"
static struct timeval save_tmout  =    {(__time_t )0, (__suseconds_t )0};
#line 150 "/home/june/collector/temp/balance-3.54/balance.c"
int create_serversocket(char *node , char *service ) 
{ 
  struct addrinfo hints ;
  struct addrinfo *results ;
  int srv_socket ;
  int status ;
  int sockopton ;
  int sockoptoff ;
  char const   *tmp ;

  {
  {
#line 155
  bzero((void *)(& hints), sizeof(hints));
#line 156
  hints.ai_flags = 1;
  }
#line 158
  if (bindipv6) {
#line 159
    if (debugflag) {
      {
#line 160
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"using AF_INET6\n");
      }
    }
#line 162
    hints.ai_family = 10;
  } else {
#line 164
    if (debugflag) {
      {
#line 165
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"using AF_UNSPEC\n");
      }
    }
#line 167
    hints.ai_family = 0;
  }
  {
#line 169
  hints.ai_socktype = 1;
#line 170
  hints.ai_protocol = 6;
#line 172
  status = getaddrinfo((char const   */* __restrict  */)node, (char const   */* __restrict  */)service,
                       (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& results));
  }
#line 173
  if (status != 0) {
    {
#line 174
    tmp = gai_strerror(status);
#line 174
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error at getaddrinfo: %s\n",
            tmp);
#line 175
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"exiting.\n");
#line 176
    exit(71);
    }
  }
#line 179
  if ((unsigned long )results == (unsigned long )((void *)0)) {
    {
#line 180
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"no matching results at getaddrinfo\n");
#line 181
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"exiting.\n");
#line 182
    exit(71);
    }
  }
  {
#line 185
  srv_socket = socket(results->ai_family, results->ai_socktype, results->ai_protocol);
  }
#line 186
  if (srv_socket < 0) {
    {
#line 187
    perror("socket()");
#line 188
    exit(71);
    }
  }
  {
#line 191
  sockoptoff = 0;
#line 194
  status = setsockopt(srv_socket, 41, 26, (void const   *)((char *)(& sockoptoff)),
                      (socklen_t )sizeof(sockoptoff));
  }
#line 195
  if (status < 0) {
    {
#line 196
    syslog(4, "setsockopt(IPV6_V6ONLY=0) failed");
    }
  }
  {
#line 200
  sockopton = 1;
#line 202
  status = setsockopt(srv_socket, 1, 2, (void const   *)((char *)(& sockopton)), (socklen_t )sizeof(sockopton));
  }
#line 204
  if (status < 0) {
    {
#line 205
    perror("setsockopt(SO_REUSEADDR=1)");
#line 206
    exit(71);
    }
  }
  {
#line 209
  status = bind(srv_socket, (struct sockaddr  const  *)results->ai_addr, results->ai_addrlen);
  }
#line 210
  if (status < 0) {
    {
#line 211
    perror("bind()");
#line 212
    exit(71);
    }
  }
  {
#line 215
  status = listen(srv_socket, 128);
  }
#line 216
  if (status < 0) {
    {
#line 217
    perror("listen()");
#line 218
    exit(71);
    }
  }
#line 221
  return (srv_socket);
}
}
#line 226 "/home/june/collector/temp/balance-3.54/balance.c"
int a_readlock(off_t start , off_t len ) 
{ 
  int rc ;
  struct flock fdata ;
  int *tmp ;

  {
#line 229
  fdata.l_type = (short)0;
#line 230
  fdata.l_whence = (short)0;
#line 231
  fdata.l_start = (__off_t )0;
#line 232
  fdata.l_len = (__off_t )0;
  repeat: 
  {
#line 236
  rc = fcntl(rendezvousfd, 7, & fdata);
  }
#line 236
  if (rc < 0) {
    {
#line 237
    tmp = __errno_location();
    }
#line 237
    if (*tmp == 4) {
#line 238
      goto repeat;
    } else {
      {
#line 240
      perror("readlock");
#line 241
      exit(71);
      }
    }
  }
#line 244
  return (rc);
}
}
#line 247 "/home/june/collector/temp/balance-3.54/balance.c"
void b_readlock(void) 
{ 


  {
  {
#line 248
  a_readlock((off_t )0, (off_t )0);
  }
#line 249
  return;
}
}
#line 251 "/home/june/collector/temp/balance-3.54/balance.c"
void c_readlock(int group , int channel ) 
{ 


  {
  {
#line 252
  a_readlock((char *)(& common->groups[group].channels[channel]) - (char *)common,
             (off_t )sizeof(CHANNEL ));
  }
#line 254
  return;
}
}
#line 256 "/home/june/collector/temp/balance-3.54/balance.c"
int a_writelock(off_t start , off_t len ) 
{ 
  int rc ;
  struct flock fdata ;
  int *tmp ;

  {
#line 259
  fdata.l_type = (short)1;
#line 260
  fdata.l_whence = (short)0;
#line 261
  fdata.l_start = (__off_t )0;
#line 262
  fdata.l_len = (__off_t )0;
  repeat: 
  {
#line 266
  rc = fcntl(rendezvousfd, 7, & fdata);
  }
#line 266
  if (rc < 0) {
    {
#line 267
    tmp = __errno_location();
    }
#line 267
    if (*tmp == 4) {
#line 268
      goto repeat;
    } else {
      {
#line 270
      perror("a_writelock");
#line 271
      exit(71);
      }
    }
  }
#line 274
  return (rc);
}
}
#line 277 "/home/june/collector/temp/balance-3.54/balance.c"
void b_writelock(void) 
{ 


  {
  {
#line 278
  a_writelock((off_t )0, (off_t )0);
  }
#line 279
  return;
}
}
#line 281 "/home/june/collector/temp/balance-3.54/balance.c"
void c_writelock(int group , int channel ) 
{ 


  {
  {
#line 283
  a_writelock((char *)(& common->groups[group].channels[channel]) - (char *)common,
              (off_t )sizeof(CHANNEL ));
  }
#line 285
  return;
}
}
#line 287 "/home/june/collector/temp/balance-3.54/balance.c"
int a_unlock(off_t start , off_t len ) 
{ 
  int rc ;
  struct flock fdata ;
  int *tmp ;

  {
#line 291
  fdata.l_type = (short)2;
#line 292
  fdata.l_whence = (short)0;
#line 293
  fdata.l_start = (__off_t )0;
#line 294
  fdata.l_len = (__off_t )0;
  repeat: 
  {
#line 298
  rc = fcntl(rendezvousfd, 6, & fdata);
  }
#line 298
  if (rc < 0) {
    {
#line 299
    tmp = __errno_location();
    }
#line 299
    if (*tmp == 4) {
#line 300
      goto repeat;
    } else {
      {
#line 302
      perror("a_unlock");
#line 303
      exit(71);
      }
    }
  }
#line 306
  return (rc);
}
}
#line 309 "/home/june/collector/temp/balance-3.54/balance.c"
void b_unlock(void) 
{ 


  {
  {
#line 311
  a_unlock((off_t )0, (off_t )0);
  }
#line 312
  return;
}
}
#line 314 "/home/june/collector/temp/balance-3.54/balance.c"
void c_unlock(int group , int channel ) 
{ 


  {
  {
#line 316
  a_unlock((char *)(& common->groups[group].channels[channel]) - (char *)common, (off_t )sizeof(CHANNEL ));
  }
#line 318
  return;
}
}
#line 320 "/home/june/collector/temp/balance-3.54/balance.c"
void *shm_malloc(char *file , int size ) 
{ 
  char *data ;
  key_t key ;
  int shmid ;
  char shmfile[1024] ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 322
  data = (char *)((void *)0);
#line 326
  if (shmmapfile) {
    {
#line 330
    strcpy((char */* __restrict  */)(shmfile), (char const   */* __restrict  */)file);
#line 331
    strcat((char */* __restrict  */)(shmfile), (char const   */* __restrict  */)".shm");
#line 332
    shmfilefd = open((char const   *)(shmfile), 66, 420);
    }
#line 333
    if (shmfilefd < 0) {
      {
#line 334
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Cannot open file `%s\', switching to IPC\n",
              shmfile);
#line 335
      shmmapfile = 0;
      }
    }
#line 337
    if (shmmapfile) {
      {
#line 338
      tmp = ftruncate(shmfilefd, (__off_t )size);
      }
#line 338
      if (tmp < 0) {
        {
#line 339
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Cannot set file size on `%s\', switching to IPC\n",
                shmfile);
#line 340
        close(shmfilefd);
#line 341
        shmmapfile = 0;
        }
      }
    }
#line 344
    if (shmmapfile) {
      {
#line 345
      tmp___0 = mmap((void *)0, (size_t )size, 3, 1, shmfilefd, (__off_t )0);
#line 345
      data = (char *)tmp___0;
      }
#line 346
      if (! data) {
        {
#line 347
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Cannot map file `%s\', switching to IPC\n",
                shmfile);
#line 348
        close(shmfilefd);
#line 349
        shmmapfile = 0;
        }
      } else
#line 346
      if ((unsigned long )data == (unsigned long )((void *)-1)) {
        {
#line 347
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Cannot map file `%s\', switching to IPC\n",
                shmfile);
#line 348
        close(shmfilefd);
#line 349
        shmmapfile = 0;
        }
      }
    }
  }
#line 356
  if (! shmmapfile) {
    {
#line 399
    key = ftok((char const   *)file, 'x');
    }
#line 399
    if (key == -1) {
      {
#line 400
      perror("ftok");
#line 401
      exit(70);
      }
    }
    {
#line 405
    shmid = shmget(key, (size_t )size, 932);
    }
#line 405
    if (shmid == -1) {
      {
#line 406
      perror("shmget");
#line 407
      exit(71);
      }
    }
    {
#line 410
    tmp___1 = shmat(shmid, (void const   *)((void *)0), 0);
#line 410
    data = (char *)tmp___1;
    }
#line 411
    if ((unsigned long )data == (unsigned long )((char *)-1)) {
      {
#line 412
      perror("shmat");
#line 413
      exit(71);
      }
    }
  }
#line 417
  return ((void *)data);
}
}
#line 422 "/home/june/collector/temp/balance-3.54/balance.c"
void print_packet(unsigned char *s , int l ) 
{ 
  int i ;
  int cc ;
  unsigned short const   **tmp ;

  {
#line 425
  cc = 0;
#line 426
  i = 0;
  {
#line 426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 426
    if (! (i < l)) {
#line 426
      goto while_break;
    }
    {
#line 427
    tmp = __ctype_b_loc();
    }
#line 427
    if ((int const   )*(*tmp + (int )*(s + i)) & 16384) {
#line 427
      if (((int )*(s + i) & -128) == 0) {
#line 428
        if ((int )*(s + i) == 92) {
          {
#line 429
          printf((char const   */* __restrict  */)"\\\\");
#line 430
          cc += 2;
          }
        } else {
          {
#line 432
          printf((char const   */* __restrict  */)"%c", (int )*(s + i));
#line 433
          cc ++;
          }
        }
      } else {
#line 427
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 436
      printf((char const   */* __restrict  */)"\\%02X", (int )*(s + i));
#line 437
      cc += 3;
      }
#line 438
      if ((int )*(s + i) == 10) {
        {
#line 439
        printf((char const   */* __restrict  */)"\n");
#line 440
        cc = 0;
        }
      }
    }
#line 443
    if (cc > 80) {
      {
#line 444
      printf((char const   */* __restrict  */)"\n");
#line 445
      cc = 0;
      }
    }
#line 426
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 448
  printf((char const   */* __restrict  */)"\n");
  }
#line 449
  return;
}
}
#line 451 "/home/june/collector/temp/balance-3.54/balance.c"
int getport(char *port ) 
{ 
  struct servent *sp ;
  int tmp ;
  uint16_t tmp___0 ;

  {
  {
#line 454
  sp = getservbyname((char const   *)port, "tcp");
  }
#line 455
  if ((unsigned long )sp == (unsigned long )((void *)0)) {
    {
#line 456
    tmp = atoi((char const   *)port);
    }
#line 456
    return (tmp);
  } else {
    {
#line 458
    tmp___0 = ntohs((uint16_t )sp->s_port);
    }
#line 458
    return ((int )tmp___0);
  }
}
}
#line 462 "/home/june/collector/temp/balance-3.54/balance.c"
void setipaddress(struct in_addr *ipaddr , char *string ) 
{ 
  struct hostent *hent ;
  in_addr_t tmp ;

  {
  {
#line 465
  hent = gethostbyname((char const   *)string);
  }
#line 466
  if ((unsigned long )hent == (unsigned long )((void *)0)) {
    {
#line 467
    tmp = inet_addr((char const   *)string);
#line 467
    ipaddr->s_addr = tmp;
    }
#line 467
    if (tmp == 4294967295U) {
      {
#line 468
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unknown or invalid address [%s]\n",
              string);
#line 469
      exit(65);
      }
    }
  } else {
    {
#line 472
    memcpy((void */* __restrict  */)ipaddr, (void const   */* __restrict  */)*(hent->h_addr_list + 0),
           (size_t )hent->h_length);
    }
  }
#line 474
  return;
}
}
#line 476 "/home/june/collector/temp/balance-3.54/balance.c"
void setaddress(struct in_addr *ipaddr , int *port , char *string , int default_port ,
                int *maxc ) 
{ 
  char *host_string ;
  char *port_string ;
  char *maxc_string ;
  char *dup_string ;
  char *p ;
  char *q ;
  struct hostent *hent ;
  int tmp ;
  int tmp___0 ;
  in_addr_t tmp___1 ;

  {
  {
#line 479
  host_string = (char *)((void *)0);
#line 480
  port_string = (char *)((void *)0);
#line 481
  maxc_string = (char *)((void *)0);
#line 482
  dup_string = (char *)((void *)0);
#line 483
  p = (char *)((void *)0);
#line 484
  q = (char *)((void *)0);
#line 488
  dup_string = strdup((char const   *)string);
  }
#line 488
  if ((unsigned long )dup_string == (unsigned long )((void *)0)) {
    {
#line 489
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"strdup() failed\n");
#line 490
    exit(71);
    }
  }
  {
#line 493
  host_string = dup_string;
#line 494
  p = index((char const   *)dup_string, ':');
  }
#line 496
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 497
    *p = (char )'\000';
#line 498
    port_string = p + 1;
#line 499
    q = index((char const   *)port_string, ':');
    }
#line 499
    if ((unsigned long )q != (unsigned long )((void *)0)) {
#line 500
      *q = (char )'\000';
#line 501
      maxc_string = q + 1;
    } else {
#line 503
      maxc_string = (char *)"";
    }
  } else {
#line 506
    port_string = (char *)"";
#line 507
    maxc_string = (char *)"";
  }
#line 512
  if ((unsigned long )port_string != (unsigned long )((void *)0)) {
    {
#line 512
    tmp = strcmp((char const   *)port_string, "");
    }
#line 512
    if (! tmp) {
#line 513
      port_string = (char *)((void *)0);
    }
  }
#line 514
  if ((unsigned long )maxc_string != (unsigned long )((void *)0)) {
    {
#line 514
    tmp___0 = strcmp((char const   *)maxc_string, "");
    }
#line 514
    if (! tmp___0) {
#line 515
      maxc_string = (char *)((void *)0);
    }
  }
  {
#line 517
  hent = gethostbyname((char const   *)dup_string);
  }
#line 518
  if ((unsigned long )hent == (unsigned long )((void *)0)) {
    {
#line 519
    tmp___1 = inet_addr((char const   *)dup_string);
#line 519
    ipaddr->s_addr = tmp___1;
    }
#line 519
    if (tmp___1 == 4294967295U) {
      {
#line 520
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unknown or invalid address [%s]\n",
              dup_string);
#line 521
      exit(65);
      }
    }
  } else {
    {
#line 524
    memcpy((void */* __restrict  */)ipaddr, (void const   */* __restrict  */)*(hent->h_addr_list + 0),
           (size_t )hent->h_length);
    }
  }
#line 527
  if ((unsigned long )port_string != (unsigned long )((void *)0)) {
    {
#line 528
    *port = getport(port_string);
    }
  } else {
#line 530
    *port = default_port;
  }
#line 533
  if ((unsigned long )maxc_string != (unsigned long )((void *)0)) {
    {
#line 534
    *maxc = atoi((char const   *)maxc_string);
    }
  }
  {
#line 536
  free((void *)dup_string);
  }
#line 537
  return;
}
}
#line 539 "/home/june/collector/temp/balance-3.54/balance.c"
int setaddress_noexitonerror(struct in_addr *ipaddr , int *port , char *string , int default_port ) 
{ 
  char *host_string ;
  char *port_string ;
  struct hostent *hent ;
  in_addr_t tmp ;

  {
  {
#line 545
  host_string = strtok((char */* __restrict  */)string, (char const   */* __restrict  */)":");
#line 546
  port_string = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)":");
#line 547
  hent = gethostbyname((char const   *)string);
  }
#line 548
  if ((unsigned long )hent == (unsigned long )((void *)0)) {
    {
#line 549
    tmp = inet_addr((char const   *)string);
#line 549
    ipaddr->s_addr = tmp;
    }
#line 549
    if (tmp == 4294967295U) {
#line 550
      return (0);
    }
  } else {
    {
#line 553
    memcpy((void */* __restrict  */)ipaddr, (void const   */* __restrict  */)*(hent->h_addr_list + 0),
           (size_t )hent->h_length);
    }
  }
#line 556
  if ((unsigned long )port_string != (unsigned long )((void *)0)) {
    {
#line 557
    *port = getport(port_string);
    }
  } else {
#line 559
    *port = default_port;
  }
#line 561
  return (1);
}
}
#line 564 "/home/june/collector/temp/balance-3.54/balance.c"
int readline(int fd , char *ptr , int maxlen ) 
{ 
  int n ;
  int rc ;
  char c ;
  char *tmp ;
  ssize_t tmp___0 ;

  {
#line 569
  n = 1;
  {
#line 569
  while (1) {
    while_continue: /* CIL Label */ ;
#line 569
    if (! (n < maxlen)) {
#line 569
      goto while_break;
    }
    {
#line 570
    tmp___0 = read(fd, (void *)(& c), (size_t )1);
#line 570
    rc = (int )tmp___0;
    }
#line 570
    if (rc == 1) {
#line 571
      tmp = ptr;
#line 571
      ptr ++;
#line 571
      *tmp = c;
#line 572
      if ((int )c == 10) {
#line 573
        goto while_break;
      }
    } else
#line 575
    if (rc == 0) {
#line 576
      if (n == 1) {
#line 577
        return (0);
      } else {
#line 579
        goto while_break;
      }
    } else {
#line 582
      return (-1);
    }
#line 569
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 585
  *ptr = (char)0;
#line 586
  return (n);
}
}
#line 589 "/home/june/collector/temp/balance-3.54/balance.c"
int forward(int fromfd , int tofd , int groupindex , int channelindex ) 
{ 
  ssize_t rc ;
  unsigned char buffer[32768] ;
  ssize_t tmp ;

  {
  {
#line 594
  rc = read(fromfd, (void *)(buffer), (size_t )32768);
  }
#line 596
  if (packetdump) {
    {
#line 597
    printf((char const   */* __restrict  */)"-> %d\n", (int )rc);
#line 598
    print_packet(buffer, (int )rc);
    }
  }
#line 601
  if (rc <= 0L) {
#line 602
    return (-1);
  } else {
    {
#line 604
    tmp = writen(tofd, buffer, (size_t )rc);
    }
#line 604
    if (tmp != rc) {
#line 605
      return (-1);
    }
    {
#line 607
    c_writelock(groupindex, channelindex);
#line 608
    common->groups[groupindex].channels[channelindex].bsent += (unsigned long long )rc;
#line 609
    c_unlock(groupindex, channelindex);
    }
  }
#line 611
  return (0);
}
}
#line 614 "/home/june/collector/temp/balance-3.54/balance.c"
int backward(int fromfd , int tofd , int groupindex , int channelindex ) 
{ 
  ssize_t rc ;
  unsigned char buffer[32768] ;
  ssize_t tmp ;

  {
  {
#line 619
  rc = read(fromfd, (void *)(buffer), (size_t )32768);
  }
#line 621
  if (packetdump) {
    {
#line 622
    printf((char const   */* __restrict  */)"-< %d\n", (int )rc);
#line 623
    print_packet(buffer, (int )rc);
    }
  }
#line 626
  if (rc <= 0L) {
#line 627
    return (-1);
  } else {
    {
#line 629
    tmp = writen(tofd, buffer, (size_t )rc);
    }
#line 629
    if (tmp != rc) {
#line 630
      return (-1);
    }
    {
#line 632
    c_writelock(groupindex, channelindex);
#line 633
    common->groups[groupindex].channels[channelindex].breceived += (unsigned long long )rc;
#line 634
    c_unlock(groupindex, channelindex);
    }
  }
#line 636
  return (0);
}
}
#line 644 "/home/june/collector/temp/balance-3.54/balance.c"
void stream2(int clientfd , int serverfd , int groupindex , int channelindex ) 
{ 
  fd_set readfds ;
  int fdset_width ;
  int sr ;
  int optone ;
  int tmp ;
  int __d0 ;
  int __d1 ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 649
  optone = 1;
#line 651
  if (clientfd > serverfd) {
#line 651
    tmp = clientfd;
  } else {
#line 651
    tmp = serverfd;
  }
  {
#line 651
  fdset_width = tmp + 1;
#line 654
  setsockopt(serverfd, 6, 1, (void const   *)((char *)(& optone)), (socklen_t )sizeof(optone));
#line 656
  setsockopt(clientfd, 6, 1, (void const   *)((char *)(& optone)), (socklen_t )sizeof(optone));
#line 658
  setsockopt(serverfd, 1, 9, (void const   *)((char *)(& optone)), (socklen_t )sizeof(optone));
#line 660
  setsockopt(clientfd, 1, 9, (void const   *)((char *)(& optone)), (socklen_t )sizeof(optone));
  }
  {
#line 663
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 665
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 665
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& readfds.__fds_bits[0]): "memory");
#line 665
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 666
    readfds.__fds_bits[clientfd / (8 * (int )sizeof(__fd_mask ))] |= 1L << clientfd % (8 * (int )sizeof(__fd_mask ));
#line 667
    readfds.__fds_bits[serverfd / (8 * (int )sizeof(__fd_mask ))] |= 1L << serverfd % (8 * (int )sizeof(__fd_mask ));
#line 672
    sel_tmout = save_tmout;
    {
#line 674
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 675
      if (sel_tmout.tv_sec) {
        {
#line 676
        sr = select(fdset_width, (fd_set */* __restrict  */)(& readfds), (fd_set */* __restrict  */)((void *)0),
                    (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& sel_tmout));
        }
      } else
#line 675
      if (sel_tmout.tv_usec) {
        {
#line 676
        sr = select(fdset_width, (fd_set */* __restrict  */)(& readfds), (fd_set */* __restrict  */)((void *)0),
                    (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& sel_tmout));
        }
      } else {
        {
#line 678
        sr = select(fdset_width, (fd_set */* __restrict  */)(& readfds), (fd_set */* __restrict  */)((void *)0),
                    (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
        }
      }
#line 680
      if (save_tmout.tv_sec) {
#line 680
        goto _L;
      } else
#line 680
      if (save_tmout.tv_usec) {
        _L: /* CIL Label */ 
#line 680
        if (! sr) {
          {
#line 681
          c_writelock(groupindex, channelindex);
#line 682
          (common->groups[groupindex].channels[channelindex].c) --;
#line 683
          c_unlock(groupindex, channelindex);
#line 684
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"timed out after %d seconds\n",
                  (int )save_tmout.tv_sec);
#line 686
          exit(69);
          }
        }
      }
#line 688
      if (sr < 0) {
        {
#line 688
        tmp___0 = __errno_location();
        }
#line 688
        if (*tmp___0 != 4) {
          {
#line 689
          c_writelock(groupindex, channelindex);
#line 690
          (common->groups[groupindex].channels[channelindex].c) --;
#line 691
          c_unlock(groupindex, channelindex);
#line 692
          err_dump((char *)"select error");
          }
        }
      }
#line 694
      if (sr > 0) {
#line 695
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 698
    if ((readfds.__fds_bits[clientfd / (8 * (int )sizeof(__fd_mask ))] & (1L << clientfd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 699
      tmp___1 = forward(clientfd, serverfd, groupindex, channelindex);
      }
#line 699
      if (tmp___1 < 0) {
#line 700
        goto while_break;
      }
    } else {
      {
#line 703
      tmp___2 = backward(serverfd, clientfd, groupindex, channelindex);
      }
#line 703
      if (tmp___2 < 0) {
#line 704
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 708
  c_writelock(groupindex, channelindex);
#line 709
  (common->groups[groupindex].channels[channelindex].c) --;
#line 710
  c_unlock(groupindex, channelindex);
#line 711
  exit(0);
  }
}
}
#line 714 "/home/june/collector/temp/balance-3.54/balance.c"
void alrm_handler(int signo ) 
{ 


  {
#line 715
  return;
}
}
#line 717 "/home/june/collector/temp/balance-3.54/balance.c"
void usr1_handler(int signo ) 
{ 


  {
#line 718
  return;
}
}
#line 720 "/home/june/collector/temp/balance-3.54/balance.c"
void chld_handler(int signo ) 
{ 
  int status ;
  __pid_t tmp ;

  {
  {
#line 722
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 722
    tmp = waitpid(-1, & status, 1);
    }
#line 722
    if (! (tmp > 0)) {
#line 722
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 723
  return;
}
}
#line 729 "/home/june/collector/temp/balance-3.54/balance.c"
void *stream(int arg , int groupindex , int index___0 , char *client_address , int client_address_size ) 
{ 
  int startindex ;
  int sockfd ;
  int clientfd ;
  struct sigaction alrm_action ;
  struct sockaddr_in serv_addr ;
  struct sockaddr_in outbind_addr ;
  int tmp ;
  int *tmp___0 ;
  uint16_t tmp___1 ;
  char *tmp___2 ;
  uint16_t tmp___3 ;
  char *tmp___4 ;
  unsigned int uindex ;
  int tmp___5 ;

  {
#line 737
  startindex = index___0;
#line 738
  clientfd = arg;
  {
#line 740
  while (1) {
    while_continue: /* CIL Label */ ;
#line 742
    if (debugflag) {
      {
#line 743
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"trying group %d channel %d ... ",
              groupindex, index___0);
#line 745
      fflush(stderr);
      }
    }
    {
#line 748
    sockfd = socket(2, 1, 0);
    }
#line 748
    if (sockfd < 0) {
      {
#line 749
      err_dump((char *)"can\'t open stream socket");
      }
    }
    {
#line 752
    setsockopt(sockfd, 1, 7, (void const   *)(& sockbufsize), (socklen_t )sizeof(sockbufsize));
#line 754
    setsockopt(sockfd, 1, 8, (void const   *)(& sockbufsize), (socklen_t )sizeof(sockbufsize));
    }
#line 762
    if ((unsigned long )outbindhost != (unsigned long )((void *)0)) {
      {
#line 764
      bzero((void *)((char *)(& outbind_addr)), sizeof(outbind_addr));
#line 765
      outbind_addr.sin_family = (sa_family_t )2;
#line 766
      setipaddress(& outbind_addr.sin_addr, outbindhost);
#line 767
      tmp = bind(sockfd, (struct sockaddr  const  *)((struct sockaddr *)(& outbind_addr)),
                 (socklen_t )sizeof(outbind_addr));
      }
    }
    {
#line 773
    b_readlock();
#line 774
    bzero((void *)((char *)(& serv_addr)), sizeof(serv_addr));
#line 775
    serv_addr.sin_family = (sa_family_t )2;
#line 776
    serv_addr.sin_addr.s_addr = common->groups[groupindex].channels[index___0].ipaddr.s_addr;
#line 778
    serv_addr.sin_port = htons((uint16_t )common->groups[groupindex].channels[index___0].port);
#line 779
    b_unlock();
#line 781
    alrm_action.__sigaction_handler.sa_handler = & alrm_handler;
#line 782
    alrm_action.sa_flags = 0;
#line 783
    sigemptyset(& alrm_action.sa_mask);
#line 784
    sigaction(14, (struct sigaction  const  */* __restrict  */)(& alrm_action), (struct sigaction */* __restrict  */)((void *)0));
#line 785
    alarm((unsigned int )connect_timeout);
#line 787
    tmp___5 = connect(sockfd, (struct sockaddr  const  *)((struct sockaddr *)(& serv_addr)),
                      (socklen_t )sizeof(serv_addr));
    }
#line 787
    if (tmp___5 < 0) {
#line 788
      if (debugflag) {
        {
#line 789
        tmp___0 = __errno_location();
        }
#line 789
        if (*tmp___0 == 4) {
          {
#line 790
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"timeout group %d channel %d\n",
                  groupindex, index___0);
          }
        } else {
          {
#line 793
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"connection refused group %d channel %d\n",
                  groupindex, index___0);
          }
        }
      }
      {
#line 802
      c_writelock(groupindex, index___0);
#line 803
      (common->groups[groupindex].channels[index___0].c) --;
      }
#line 804
      if (autodisable) {
#line 805
        if (common->groups[groupindex].channels[index___0].status != 0) {
#line 806
          if (foreground) {
            {
#line 807
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"connection failed group %d channel %d\n",
                    groupindex, index___0);
#line 808
            tmp___1 = ntohs(serv_addr.sin_port);
#line 808
            tmp___2 = inet_ntoa(serv_addr.sin_addr);
#line 808
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d needs to be enabled manually using balance -i after the problem is solved\n",
                    tmp___2, (int )tmp___1);
            }
          } else {
            {
#line 810
            syslog(5, "connection failed group %d channel %d", groupindex, index___0);
#line 811
            tmp___3 = ntohs(serv_addr.sin_port);
#line 811
            tmp___4 = inet_ntoa(serv_addr.sin_addr);
#line 811
            syslog(5, "%s:%d needs to be enabled manually using balance -i after the problem is solved",
                   tmp___4, (int )tmp___3);
            }
          }
#line 813
          common->groups[groupindex].channels[index___0].status = 0;
        }
      }
      {
#line 816
      c_unlock(groupindex, index___0);
#line 818
      b_readlock();
      }
      {
#line 819
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 820
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 821
          if (common->groups[groupindex].type == 0) {
#line 821
            goto _L;
          } else
#line 821
          if (hashfailover == 1) {
            _L: /* CIL Label */ 
#line 822
            index___0 ++;
#line 823
            if (index___0 >= common->groups[groupindex].nchannels) {
#line 824
              index___0 = 0;
            }
#line 826
            if (index___0 == startindex) {
#line 827
              index___0 = -1;
#line 828
              goto while_break___1;
            }
#line 830
            if (common->groups[groupindex].channels[index___0].status == 1) {
#line 830
              if (common->groups[groupindex].channels[index___0].maxc == 0) {
#line 834
                goto while_break___1;
              } else
#line 830
              if (common->groups[groupindex].channels[index___0].c < common->groups[groupindex].channels[index___0].maxc) {
#line 834
                goto while_break___1;
              } else {
#line 836
                goto __Cont;
              }
            } else {
#line 836
              goto __Cont;
            }
          } else
#line 838
          if (common->groups[groupindex].type == 1) {
#line 841
            index___0 = -1;
#line 842
            goto while_break___1;
          } else {
            {
#line 844
            err_dump((char *)"PANIC: invalid group in stream()");
            }
          }
          __Cont: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 848
        if (index___0 >= 0) {
#line 850
          goto while_break___0;
        } else {
          again: 
#line 853
          groupindex ++;
#line 854
          if (groupindex >= 16) {
#line 856
            goto while_break___0;
          } else
#line 858
          if (common->groups[groupindex].type == 0) {
#line 860
            if (common->groups[groupindex].nchannels > 0) {
#line 861
              index___0 = common->groups[groupindex].current;
#line 862
              startindex = index___0;
            } else {
#line 866
              goto again;
            }
#line 868
            goto while_break___0;
          } else
#line 869
          if (common->groups[groupindex].type == 1) {
            {
#line 871
            uindex = hash_fold((char *)((unsigned char *)(& ((struct sockaddr_in6 *)(& client_address))->sin6_addr)),
                               client_address_size);
            }
#line 873
            if (debugflag) {
              {
#line 874
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"HASH-method: fold returns %u\n",
                      uindex);
              }
            }
#line 877
            index___0 = (int )(uindex % (unsigned int )common->groups[groupindex].nchannels);
#line 878
            if (debugflag) {
              {
#line 879
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"modulo %d gives %d\n",
                      common->groups[groupindex].nchannels, index___0);
              }
            }
#line 882
            if (common->groups[groupindex].channels[index___0].status == 1) {
#line 882
              if (common->groups[groupindex].channels[index___0].maxc == 0) {
#line 887
                goto while_break___0;
              } else
#line 882
              if (common->groups[groupindex].channels[index___0].c < common->groups[groupindex].channels[index___0].maxc) {
#line 887
                goto while_break___0;
              } else {
#line 889
                goto again;
              }
            } else {
#line 889
              goto again;
            }
          } else {
            {
#line 892
            err_dump((char *)"PANIC: invalid group in stream()");
            }
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 899
      b_unlock();
      }
#line 901
      if (index___0 >= 0) {
        {
#line 903
        close(sockfd);
#line 904
        c_writelock(groupindex, index___0);
#line 905
        (common->groups[groupindex].channels[index___0].c) ++;
#line 906
        (common->groups[groupindex].channels[index___0].tc) ++;
#line 907
        c_unlock(groupindex, index___0);
        }
#line 908
        goto __Cont___0;
      } else {
#line 910
        goto while_break;
      }
    } else {
      {
#line 914
      alarm(0U);
      }
#line 915
      if (debugflag) {
        {
#line 916
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"connect to channel %d successful\n",
                index___0);
        }
      }
      {
#line 920
      b_writelock();
#line 921
      common->groups[groupindex].current = index___0;
#line 922
      (common->groups[groupindex].current) ++;
      }
#line 923
      if (common->groups[groupindex].current >= common->groups[groupindex].nchannels) {
#line 925
        common->groups[groupindex].current = 0;
      }
      {
#line 927
      b_unlock();
#line 931
      stream2(clientfd, sockfd, groupindex, index___0);
      }
#line 934
      goto while_break;
    }
    __Cont___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 938
  close(sockfd);
#line 939
  exit(0);
  }
}
}
#line 942 "/home/june/collector/temp/balance-3.54/balance.c"
static void initialize_release_variables(void) 
{ 
  char *version ;
  char *revision_copy ;
  char *token ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 949
  tmp___0 = strlen((char const   *)revision);
#line 949
  tmp___1 = malloc(tmp___0 + 1UL);
#line 949
  revision_copy = (char *)tmp___1;
  }
#line 949
  if ((unsigned long )revision_copy == (unsigned long )((void *)0)) {
    {
#line 950
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"malloc problem in initialize_release_variables()\n");
    }
  } else {
    {
#line 952
    strcpy((char */* __restrict  */)revision_copy, (char const   */* __restrict  */)revision);
#line 953
    token = strtok((char */* __restrict  */)revision_copy, (char const   */* __restrict  */)" ");
#line 954
    token = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
    }
#line 955
    if ((unsigned long )token != (unsigned long )((void *)0)) {
#line 955
      version = token;
    } else {
#line 955
      version = (char *)"0.0";
    }
    {
#line 956
    release = atoi((char const   *)version);
#line 957
    tmp = strlen((char const   *)version);
    }
#line 957
    if (tmp >= 3UL) {
      {
#line 958
      subrelease = atoi((char const   *)(version + 2));
      }
    } else {
#line 960
      subrelease = 0;
    }
    {
#line 962
    free((void *)revision_copy);
    }
  }
#line 964
  return;
}
}
#line 966 "/home/june/collector/temp/balance-3.54/balance.c"
static void usage(void) 
{ 


  {
  {
#line 969
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" _           _\n");
#line 970
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"| |__   __ _| | __ _ _ __   ___ ___\n");
#line 971
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"| \'_ \\ / _` | |/ _` | \'_ \\ / __/ _ \\\n");
#line 972
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"| |_) | (_| | | (_| | | | | (_|  __/\n");
#line 973
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"|_.__/ \\__,_|_|\\__,_|_| |_|\\___\\___|\n");
#line 976
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  this is balance %d.%d\n",
          release, subrelease);
#line 977
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  Copyright (c) 2000-2009,2010\n");
#line 978
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  by Inlab Software GmbH, Gruenwald, Germany.\n");
#line 979
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  All rights reserved.\n");
#line 980
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 982
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage:\n");
#line 983
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  balance [-b addr] [-B addr] [-t sec] [-T sec] [-adfpHM] \\\n");
#line 984
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"          port [h1[:p1[:maxc1]] [!%%] [ ... hN[:pN[:maxcN]]]]\n");
#line 985
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  balance [-b addr] -i [-d] port\n");
#line 986
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  balance [-b addr] -c cmd  [-d] port\n");
#line 987
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 988
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -a        enable channel autodisable option\n");
#line 989
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -b host   bind to specific address on listen\n");
#line 990
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -B host   bind to specific address for outgoing connections\n");
#line 991
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -c cmd    execute specified interactive command\n");
#line 992
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -d        debugging on\n");
#line 993
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -f        stay in foregound\n");
#line 994
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -i        interactive control\n");
#line 995
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -H        failover even if Hash Type is used\n");
#line 996
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -M        use MMAP instead of SHM for IPC\n");
#line 997
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -p        packetdump\n");
#line 998
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -t sec    specify connect timeout in seconds (default=%d)\n",
          5);
#line 999
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -T sec    timeout (seconds) for select (0 => never) (default=%d)\n",
          0);
#line 1000
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   !        separates channelgroups (declaring previous to be Round Robin)\n");
#line 1001
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   %%        as !, but declaring previous group to be a Hash Type\n");
#line 1003
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 1004
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"examples:\n");
#line 1005
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  balance smtp mailhost1:smtp mailhost2:25 mailhost3\n");
#line 1006
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  balance -i smtp\n");
#line 1007
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  balance -b 2001:DB8::1 80 10.1.1.1 10.1.1.2\n");
#line 1008
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  balance -b 2001:DB8::1 80\n");
#line 1009
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 1011
  exit(64);
  }
}
}
#line 1016 "/home/june/collector/temp/balance-3.54/balance.c"
void background(void) 
{ 
  int childpid ;
  int tmp ;

  {
  {
#line 1018
  childpid = fork();
  }
#line 1018
  if (childpid < 0) {
    {
#line 1019
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cannot fork\n");
#line 1020
    exit(71);
    }
  } else
#line 1022
  if (childpid > 0) {
    {
#line 1023
    exit(0);
    }
  }
  {
#line 1029
  setpgrp();
#line 1031
  tmp = chdir("/");
  }
#line 1031
  if (tmp < 0) {
    {
#line 1032
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cannot chdir\n");
    }
  }
  {
#line 1033
  close(0);
#line 1034
  close(1);
#line 1035
  close(2);
  }
#line 1036
  return;
}
}
#line 1038 "/home/june/collector/temp/balance-3.54/balance.c"
COMMON *makecommon(int argc , char **argv , int source_port ) 
{ 
  int i ;
  int group ;
  int channel ;
  COMMON *mycommon ;
  int numchannels ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 1044
  numchannels = argc - 1;
#line 1046
  if (numchannels >= 64) {
    {
#line 1047
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"MAXCHANNELS exceeded...\n");
#line 1048
    exit(64);
    }
  }
  {
#line 1051
  rendezvousfd = open((char const   *)(rendezvousfile), 2, 0);
  }
#line 1051
  if (rendezvousfd < 0) {
    {
#line 1052
    perror("open");
#line 1053
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"check rendezvousfile permissions [%s]\n",
            rendezvousfile);
#line 1054
    exit(66);
    }
  }
  {
#line 1057
  b_writelock();
#line 1059
  tmp = shm_malloc(rendezvousfile, (int )sizeof(COMMON ));
#line 1059
  mycommon = (COMMON *)tmp;
  }
#line 1059
  if ((unsigned long )mycommon == (unsigned long )((void *)0)) {
    {
#line 1061
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cannot alloc COMMON struct\n");
#line 1062
    exit(71);
    }
  }
  {
#line 1065
  mycommon->pid = getpid();
#line 1066
  mycommon->release = release;
#line 1067
  mycommon->subrelease = subrelease;
#line 1069
  group = 0;
  }
  {
#line 1069
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1069
    if (! (group < 16)) {
#line 1069
      goto while_break;
    }
#line 1070
    mycommon->groups[group].nchannels = 0;
#line 1071
    mycommon->groups[group].current = 0;
#line 1072
    mycommon->groups[group].type = 0;
#line 1069
    group ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1075
  group = 0;
#line 1076
  channel = 0;
#line 1078
  i = 1;
  {
#line 1078
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1078
    if (! (i < argc)) {
#line 1078
      goto while_break___0;
    }
    {
#line 1079
    tmp___1 = strcmp((char const   *)*(argv + i), "!");
    }
#line 1079
    if (tmp___1) {
      {
#line 1090
      tmp___0 = strcmp((char const   *)*(argv + i), "%");
      }
#line 1090
      if (tmp___0) {
        {
#line 1102
        mycommon->groups[group].channels[channel].status = 1;
#line 1103
        mycommon->groups[group].channels[channel].c = 0;
#line 1104
        mycommon->groups[group].channels[channel].tc = 0;
#line 1105
        mycommon->groups[group].channels[channel].maxc = 0;
#line 1106
        setaddress(& mycommon->groups[group].channels[channel].ipaddr, & mycommon->groups[group].channels[channel].port,
                   *(argv + i), source_port, & mycommon->groups[group].channels[channel].maxc);
#line 1110
        mycommon->groups[group].channels[channel].bsent = 0ULL;
#line 1111
        mycommon->groups[group].channels[channel].breceived = 0ULL;
#line 1113
        (mycommon->groups[group].nchannels) ++;
#line 1114
        channel ++;
        }
#line 1115
        if (channel >= 64) {
          {
#line 1116
          err_dump((char *)"too many channels in one group");
          }
        }
      } else {
#line 1092
        if (channel <= 0) {
          {
#line 1093
          err_dump((char *)"no channels in group");
          }
        }
#line 1095
        mycommon->groups[group].type = 1;
#line 1096
        group ++;
#line 1097
        channel = 0;
#line 1098
        if (group >= 16) {
          {
#line 1099
          err_dump((char *)"too many groups");
          }
        }
      }
    } else {
#line 1081
      if (channel <= 0) {
        {
#line 1082
        err_dump((char *)"no channels in group");
        }
      }
#line 1084
      mycommon->groups[group].type = 0;
#line 1085
      group ++;
#line 1086
      channel = 0;
#line 1087
      if (group >= 16) {
        {
#line 1088
        err_dump((char *)"too many groups");
        }
      }
    }
#line 1078
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1121
  if (debugflag) {
    {
#line 1122
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"the following channels are active:\n");
#line 1123
    group = 0;
    }
    {
#line 1123
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1123
      if (! (group <= 16)) {
#line 1123
        goto while_break___1;
      }
#line 1124
      i = 0;
      {
#line 1124
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1124
        if (! (i < mycommon->groups[group].nchannels)) {
#line 1124
          goto while_break___2;
        }
        {
#line 1125
        tmp___2 = inet_ntoa(mycommon->groups[group].channels[i].ipaddr);
#line 1125
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%3d %2d %s:%d:%d\n",
                group, i, tmp___2, mycommon->groups[group].channels[i].port, mycommon->groups[group].channels[i].maxc);
#line 1124
        i ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1123
      group ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 1135
  b_unlock();
  }
#line 1136
  return (mycommon);
}
}
#line 1139 "/home/june/collector/temp/balance-3.54/balance.c"
int mycmp(char *s1 , char *s2 ) 
{ 
  int l ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;

  {
  {
#line 1142
  tmp___3 = strlen((char const   *)s1);
#line 1142
  tmp___4 = strlen((char const   *)s2);
  }
#line 1142
  if (tmp___3 < tmp___4) {
    {
#line 1142
    tmp___1 = strlen((char const   *)s1);
#line 1142
    l = (int )tmp___1;
    }
  } else {
    {
#line 1142
    tmp___2 = strlen((char const   *)s2);
#line 1142
    l = (int )tmp___2;
    }
  }
  {
#line 1143
  tmp___7 = strlen((char const   *)s1);
#line 1143
  tmp___8 = strlen((char const   *)s2);
  }
#line 1143
  if (tmp___7 > tmp___8) {
#line 1144
    return (0);
  } else {
    {
#line 1146
    tmp___5 = strncmp((char const   *)s1, (char const   *)s2, (size_t )l);
    }
#line 1146
    if (tmp___5) {
#line 1146
      tmp___6 = 0;
    } else {
#line 1146
      tmp___6 = 1;
    }
#line 1146
    return (tmp___6);
  }
}
}
#line 1150 "/home/june/collector/temp/balance-3.54/balance.c"
int shell(char *argument ) 
{ 
  int i ;
  int currentgroup ;
  char line[128] ;
  char *command ;
  int tmp ;
  char *tmp___0 ;
  int group ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  char *arg ;
  int n ;
  char *arg___0 ;
  char n___0 ;
  int tmp___5 ;
  char *arg___1 ;
  int n___1 ;
  char *arg___2 ;
  int n___2 ;
  char *arg1 ;
  char *arg2 ;
  int tmp___6 ;
  int tmp___7 ;
  char *arg1___0 ;
  char *arg2___0 ;
  char *arg3 ;
  int chn ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *arg1___1 ;
  char *arg2___1 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  char *arg1___2 ;
  char *arg2___2 ;
  int mygroup ;
  int mychannel ;
  char *arg1___3 ;
  char *arg2___3 ;
  int mygroup___0 ;
  int mychannel___0 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;

  {
  {
#line 1153
  currentgroup = 0;
#line 1160
  setvbuf((FILE */* __restrict  */)stdout, (char */* __restrict  */)((void *)0), 2,
          (size_t )0);
#line 1161
  setvbuf((FILE */* __restrict  */)stderr, (char */* __restrict  */)((void *)0), 2,
          (size_t )0);
  }
#line 1163
  if (common->release == 0) {
    {
#line 1164
    printf((char const   */* __restrict  */)"no master process, exiting.\n");
#line 1165
    exit(69);
    }
  }
#line 1168
  if (common->release != release) {
    {
#line 1169
    printf((char const   */* __restrict  */)"release mismatch, expecting %d.%d, got %d.%d, exiting.\n",
           release, subrelease, common->release, common->subrelease);
#line 1171
    exit(65);
    }
  } else
#line 1168
  if (common->subrelease != subrelease) {
    {
#line 1169
    printf((char const   */* __restrict  */)"release mismatch, expecting %d.%d, got %d.%d, exiting.\n",
           release, subrelease, common->release, common->subrelease);
#line 1171
    exit(65);
    }
  }
  {
#line 1174
  tmp = kill(common->pid, 10);
  }
#line 1174
  if (tmp == -1) {
    {
#line 1175
    printf((char const   */* __restrict  */)"no master process with pid %d, exiting.\n",
           common->pid);
#line 1176
    exit(69);
    }
  }
#line 1179
  if ((unsigned long )argument == (unsigned long )((void *)0)) {
    {
#line 1180
    printf((char const   */* __restrict  */)"\nbalance %d.%d interactive command shell\n",
           release, subrelease);
#line 1182
    printf((char const   */* __restrict  */)"PID of master process is %d\n\n", common->pid);
    }
  }
  {
#line 1185
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1187
    if ((unsigned long )argument == (unsigned long )((void *)0)) {
      {
#line 1188
      printf((char const   */* __restrict  */)"balance[%d] ", currentgroup);
#line 1189
      tmp___0 = fgets((char */* __restrict  */)(line), 128, (FILE */* __restrict  */)stdin);
      }
#line 1189
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
        {
#line 1190
        printf((char const   */* __restrict  */)"\n");
#line 1191
        exit(0);
        }
      }
    } else {
      {
#line 1194
      strncpy((char */* __restrict  */)(line), (char const   */* __restrict  */)argument,
              (size_t )128);
      }
    }
    {
#line 1197
    command = strtok((char */* __restrict  */)(line), (char const   */* __restrict  */)" \t\n");
    }
#line 1197
    if ((unsigned long )command != (unsigned long )((void *)0)) {
      {
#line 1198
      tmp___33 = mycmp(command, (char *)"quit");
      }
#line 1198
      if (tmp___33) {
        {
#line 1199
        exit(0);
        }
      } else {
        {
#line 1200
        tmp___32 = mycmp(command, (char *)"show");
        }
#line 1200
        if (tmp___32) {
          {
#line 1201
          b_readlock();
#line 1205
          printf((char const   */* __restrict  */)"%3s %4s %2s %3s %16s %5s %4s %11s %4s %11s %11s\n",
                 "GRP", "Type", "#", "S", "ip-address", "port", "c", "totalc", "maxc",
                 "sent", "rcvd");
#line 1208
          group = 0;
          }
          {
#line 1208
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 1208
            if (! (group <= 16)) {
#line 1208
              goto while_break___0;
            }
#line 1209
            i = 0;
            {
#line 1209
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 1209
              if (! (i < common->groups[group].nchannels)) {
#line 1209
                goto while_break___1;
              }
              {
#line 1210
              tmp___1 = inet_ntoa(common->groups[group].channels[i].ipaddr);
              }
#line 1210
              if (common->groups[group].channels[i].status == 1) {
#line 1210
                tmp___2 = "ENA";
              } else {
#line 1210
                tmp___2 = "dis";
              }
#line 1210
              if (common->groups[group].type == 0) {
#line 1210
                tmp___3 = "RR";
              } else {
#line 1210
                tmp___3 = "Hash";
              }
              {
#line 1210
              printf((char const   */* __restrict  */)"%3d %4s %2d %3s %16s %5d %4d %11u %4d %11llu %11llu\n",
                     group, tmp___3, i, tmp___2, tmp___1, common->groups[group].channels[i].port,
                     common->groups[group].channels[i].c, common->groups[group].channels[i].tc,
                     common->groups[group].channels[i].maxc, common->groups[group].channels[i].bsent,
                     common->groups[group].channels[i].breceived);
#line 1209
              i ++;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
#line 1208
            group ++;
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 1226
          b_unlock();
          }
        } else {
          {
#line 1227
          tmp___30 = mycmp(command, (char *)"help");
          }
#line 1227
          if (tmp___30) {
#line 1227
            goto _L;
          } else {
            {
#line 1227
            tmp___31 = mycmp(command, (char *)"?");
            }
#line 1227
            if (tmp___31) {
              _L: /* CIL Label */ 
              {
#line 1228
              printf((char const   */* __restrict  */)"available commands:\n");
#line 1230
              printf((char const   */* __restrict  */)"  create <host> <port>           creates a channel in the current group\n");
#line 1231
              printf((char const   */* __restrict  */)"  assign <channel> <host> <port> reassigns a channel in the current group\n");
#line 1232
              printf((char const   */* __restrict  */)"  disable <channel>              disables specified channel in current group\n");
#line 1233
              printf((char const   */* __restrict  */)"  enable <channel>               enables channel in current group\n");
#line 1234
              printf((char const   */* __restrict  */)"  group <group>                  changes current group to <group>\n");
#line 1235
              printf((char const   */* __restrict  */)"  hash                           sets distribution scheme of current group to Hash\n");
#line 1236
              printf((char const   */* __restrict  */)"  help                           prints this message\n");
#line 1237
              printf((char const   */* __restrict  */)"  kill                           kills master process and quits interactive mode\n");
#line 1238
              printf((char const   */* __restrict  */)"  maxc <channel> <maxc>          specifies new maxc for channel of current group\n");
#line 1239
              printf((char const   */* __restrict  */)"  mrtg-bytes <grp> <ch>          print bytes in/out in MRTG format\n");
#line 1240
              printf((char const   */* __restrict  */)"  mrtg-conns <grp> <ch>          print total connections in MRTG format\n");
#line 1241
              printf((char const   */* __restrict  */)"  quit                           quit interactive mode\n");
#line 1242
              printf((char const   */* __restrict  */)"  reset <channel>                reset all counters of channel in current group\n");
#line 1243
              printf((char const   */* __restrict  */)"  rr                             sets distribution scheme of current group to Round Robin\n");
#line 1244
              printf((char const   */* __restrict  */)"  show                           show all channels in all groups\n");
#line 1245
              printf((char const   */* __restrict  */)"  version                        show version id\n");
              }
            } else {
              {
#line 1247
              tmp___29 = mycmp(command, (char *)"kill");
              }
#line 1247
              if (tmp___29) {
                {
#line 1248
                kill(common->pid, 9);
#line 1249
                sleep(1U);
#line 1250
                tmp___4 = kill(common->pid, 10);
                }
#line 1250
                if (tmp___4 == -1) {
                  {
#line 1251
                  printf((char const   */* __restrict  */)"shutdown complete, exiting.\n");
#line 1252
                  common->release = 0;
#line 1253
                  exit(0);
                  }
                } else {
                  {
#line 1255
                  printf((char const   */* __restrict  */)"shutdown failed.\n");
#line 1256
                  exit(69);
                  }
                }
              } else {
                {
#line 1258
                tmp___28 = mycmp(command, (char *)"disable");
                }
#line 1258
                if (tmp___28) {
                  {
#line 1261
                  arg = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\n");
                  }
#line 1261
                  if ((unsigned long )arg != (unsigned long )((void *)0)) {
                    {
#line 1262
                    n = atoi((char const   *)arg);
                    }
#line 1263
                    if (n < 0) {
                      {
#line 1264
                      printf((char const   */* __restrict  */)"no such channel %d\n",
                             n);
                      }
                    } else
#line 1263
                    if (n >= common->groups[currentgroup].nchannels) {
                      {
#line 1264
                      printf((char const   */* __restrict  */)"no such channel %d\n",
                             n);
                      }
                    } else {
                      {
#line 1266
                      c_writelock(currentgroup, n);
                      }
#line 1267
                      if (common->groups[currentgroup].channels[n].status == 0) {
                        {
#line 1268
                        printf((char const   */* __restrict  */)"channel %d already disabled\n",
                               n);
                        }
                      } else {
                        {
#line 1270
                        common->groups[currentgroup].channels[n].status = 0;
#line 1271
                        printf((char const   */* __restrict  */)"channel %d disabled\n",
                               n);
                        }
                      }
                      {
#line 1273
                      c_unlock(currentgroup, n);
                      }
                    }
                  } else {
                    {
#line 1276
                    printf((char const   */* __restrict  */)"syntax error\n");
                    }
                  }
                } else {
                  {
#line 1278
                  tmp___27 = mycmp(command, (char *)"group");
                  }
#line 1278
                  if (tmp___27) {
                    {
#line 1280
                    arg___0 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\n");
                    }
#line 1280
                    if ((unsigned long )arg___0 != (unsigned long )((void *)0)) {
                      {
#line 1281
                      tmp___5 = atoi((char const   *)arg___0);
#line 1281
                      n___0 = (char )tmp___5;
                      }
#line 1282
                      if ((int )n___0 >= 16) {
                        {
#line 1283
                        printf((char const   */* __restrict  */)"value out of range\n");
                        }
                      } else
#line 1282
                      if ((int )n___0 < 0) {
                        {
#line 1283
                        printf((char const   */* __restrict  */)"value out of range\n");
                        }
                      } else {
#line 1285
                        currentgroup = (int )n___0;
                      }
                    } else {
                      {
#line 1288
                      printf((char const   */* __restrict  */)"syntax error\n");
                      }
                    }
                  } else {
                    {
#line 1291
                    tmp___26 = mycmp(command, (char *)"reset");
                    }
#line 1291
                    if (tmp___26) {
                      {
#line 1295
                      arg___1 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\n");
                      }
#line 1295
                      if ((unsigned long )arg___1 != (unsigned long )((void *)0)) {
                        {
#line 1296
                        n___1 = atoi((char const   *)arg___1);
                        }
#line 1297
                        if (n___1 < 0) {
                          {
#line 1298
                          printf((char const   */* __restrict  */)"no such channel %d\n",
                                 n___1);
                          }
                        } else
#line 1297
                        if (n___1 >= common->groups[currentgroup].nchannels) {
                          {
#line 1298
                          printf((char const   */* __restrict  */)"no such channel %d\n",
                                 n___1);
                          }
                        } else {
                          {
#line 1300
                          c_writelock(currentgroup, n___1);
#line 1301
                          common->groups[currentgroup].channels[n___1].breceived = 0ULL;
#line 1302
                          common->groups[currentgroup].channels[n___1].bsent = 0ULL;
#line 1303
                          common->groups[currentgroup].channels[n___1].tc = 0;
#line 1304
                          c_unlock(currentgroup, n___1);
#line 1305
                          printf((char const   */* __restrict  */)"channel %d counters reset\n",
                                 n___1);
                          }
                        }
                      } else {
                        {
#line 1308
                        printf((char const   */* __restrict  */)"syntax error\n");
                        }
                      }
                    } else {
                      {
#line 1311
                      tmp___25 = mycmp(command, (char *)"enable");
                      }
#line 1311
                      if (tmp___25) {
                        {
#line 1315
                        arg___2 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\n");
                        }
#line 1315
                        if ((unsigned long )arg___2 != (unsigned long )((void *)0)) {
                          {
#line 1316
                          n___2 = atoi((char const   *)arg___2);
                          }
#line 1317
                          if (n___2 < 0) {
                            {
#line 1318
                            printf((char const   */* __restrict  */)"no such channel %d\n",
                                   n___2);
                            }
                          } else
#line 1317
                          if (n___2 >= common->groups[currentgroup].nchannels) {
                            {
#line 1318
                            printf((char const   */* __restrict  */)"no such channel %d\n",
                                   n___2);
                            }
                          } else {
                            {
#line 1320
                            c_writelock(currentgroup, n___2);
                            }
#line 1321
                            if (common->groups[currentgroup].channels[n___2].status == 1) {
                              {
#line 1322
                              printf((char const   */* __restrict  */)"channel %d already enabled\n",
                                     n___2);
                              }
                            } else {
                              {
#line 1324
                              common->groups[currentgroup].channels[n___2].status = 1;
#line 1325
                              printf((char const   */* __restrict  */)"channel %d enabled\n",
                                     n___2);
                              }
                            }
                            {
#line 1327
                            c_unlock(currentgroup, n___2);
                            }
                          }
                        } else {
                          {
#line 1330
                          printf((char const   */* __restrict  */)"syntax error\n");
                          }
                        }
                      } else {
                        {
#line 1333
                        tmp___24 = mycmp(command, (char *)"create");
                        }
#line 1333
                        if (tmp___24) {
                          {
#line 1335
                          b_writelock();
                          }
#line 1336
                          if (common->groups[currentgroup].nchannels >= 64) {
                            {
#line 1337
                            printf((char const   */* __restrict  */)"no channel slots available\n");
                            }
                          } else {
                            {
#line 1339
                            arg1 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\n");
                            }
#line 1339
                            if ((unsigned long )arg1 != (unsigned long )((void *)0)) {
                              {
#line 1340
                              arg2 = strtok((char */* __restrict  */)((void *)0),
                                            (char const   */* __restrict  */)" \t\n");
                              }
#line 1340
                              if ((unsigned long )arg2 != (unsigned long )((void *)0)) {
                                {
#line 1341
                                common->groups[currentgroup].channels[common->groups[currentgroup].nchannels].status = 0;
#line 1343
                                tmp___6 = getport(arg2);
#line 1343
                                tmp___7 = setaddress_noexitonerror(& common->groups[currentgroup].channels[common->groups[currentgroup].nchannels].ipaddr,
                                                                   & common->groups[currentgroup].channels[common->groups[currentgroup].nchannels].port,
                                                                   arg1, tmp___6);
                                }
#line 1343
                                if (tmp___7) {
                                  {
#line 1352
                                  common->groups[currentgroup].channels[common->groups[currentgroup].nchannels].bsent = 0ULL;
#line 1354
                                  common->groups[currentgroup].channels[common->groups[currentgroup].nchannels].breceived = 0ULL;
#line 1356
                                  (common->groups[currentgroup].nchannels) ++;
#line 1357
                                  printf((char const   */* __restrict  */)"channel created\n");
                                  }
                                } else {
                                  {
#line 1359
                                  printf((char const   */* __restrict  */)"invalid address\n");
                                  }
                                }
                              } else {
                                {
#line 1362
                                printf((char const   */* __restrict  */)"syntax error\n");
                                }
                              }
                            } else {
                              {
#line 1365
                              printf((char const   */* __restrict  */)"syntax error\n");
                              }
                            }
                          }
                          {
#line 1368
                          b_unlock();
                          }
                        } else {
                          {
#line 1370
                          tmp___23 = mycmp(command, (char *)"assign");
                          }
#line 1370
                          if (tmp___23) {
                            {
#line 1373
                            arg1___0 = strtok((char */* __restrict  */)((void *)0),
                                              (char const   */* __restrict  */)" \t\n");
                            }
#line 1373
                            if ((unsigned long )arg1___0 != (unsigned long )((void *)0)) {
                              {
#line 1374
                              tmp___8 = atoi((char const   *)arg1___0);
#line 1374
                              chn = tmp___8;
                              }
#line 1375
                              if (chn < 0) {
                                {
#line 1377
                                printf((char const   */* __restrict  */)"unknown channel\n");
                                }
                              } else
#line 1375
                              if (chn >= 64) {
                                {
#line 1377
                                printf((char const   */* __restrict  */)"unknown channel\n");
                                }
                              } else
#line 1375
                              if (chn >= common->groups[currentgroup].nchannels) {
                                {
#line 1377
                                printf((char const   */* __restrict  */)"unknown channel\n");
                                }
                              } else {
                                {
#line 1379
                                c_writelock(currentgroup, chn);
                                }
#line 1380
                                if (common->groups[currentgroup].channels[chn].status != 0) {
                                  {
#line 1381
                                  printf((char const   */* __restrict  */)"channel must be disabled to assign new address\n");
                                  }
                                } else {
                                  {
#line 1382
                                  arg2___0 = strtok((char */* __restrict  */)((void *)0),
                                                    (char const   */* __restrict  */)" \t\n");
                                  }
#line 1382
                                  if ((unsigned long )arg2___0 != (unsigned long )((void *)0)) {
                                    {
#line 1383
                                    arg3 = strtok((char */* __restrict  */)((void *)0),
                                                  (char const   */* __restrict  */)" \t\n");
                                    }
#line 1383
                                    if ((unsigned long )arg3 != (unsigned long )((void *)0)) {
                                      {
#line 1384
                                      tmp___9 = getport(arg3);
#line 1384
                                      tmp___10 = setaddress_noexitonerror(& common->groups[currentgroup].channels[chn].ipaddr,
                                                                          & common->groups[currentgroup].channels[chn].port,
                                                                          arg2___0,
                                                                          tmp___9);
                                      }
#line 1384
                                      if (tmp___10) {
                                        {
#line 1388
                                        printf((char const   */* __restrict  */)"channel reassigned\n");
                                        }
                                      } else {
                                        {
#line 1390
                                        printf((char const   */* __restrict  */)"invalid address\n");
                                        }
                                      }
                                    } else {
                                      {
#line 1393
                                      printf((char const   */* __restrict  */)"syntax error\n");
                                      }
                                    }
                                  } else {
                                    {
#line 1396
                                    printf((char const   */* __restrict  */)"syntax error\n");
                                    }
                                  }
                                }
                                {
#line 1398
                                c_unlock(currentgroup, chn);
                                }
                              }
                            } else {
                              {
#line 1401
                              printf((char const   */* __restrict  */)"syntax error\n");
                              }
                            }
                          } else {
                            {
#line 1404
                            tmp___22 = mycmp(command, (char *)"maxc");
                            }
#line 1404
                            if (tmp___22) {
                              {
#line 1406
                              b_writelock();
#line 1407
                              arg1___1 = strtok((char */* __restrict  */)((void *)0),
                                                (char const   */* __restrict  */)" \t\n");
                              }
#line 1407
                              if ((unsigned long )arg1___1 != (unsigned long )((void *)0)) {
                                {
#line 1408
                                arg2___1 = strtok((char */* __restrict  */)((void *)0),
                                                  (char const   */* __restrict  */)" \t\n");
                                }
#line 1408
                                if ((unsigned long )arg2___1 != (unsigned long )((void *)0)) {
                                  {
#line 1409
                                  tmp___14 = atoi((char const   *)arg1___1);
                                  }
#line 1409
                                  if (tmp___14 < 0) {
                                    {
#line 1411
                                    printf((char const   */* __restrict  */)"unknown channel\n");
                                    }
                                  } else {
                                    {
#line 1409
                                    tmp___15 = atoi((char const   *)arg1___1);
                                    }
#line 1409
                                    if (tmp___15 >= 64) {
                                      {
#line 1411
                                      printf((char const   */* __restrict  */)"unknown channel\n");
                                      }
                                    } else {
                                      {
#line 1409
                                      tmp___16 = atoi((char const   *)arg1___1);
                                      }
#line 1409
                                      if (tmp___16 + 1 > common->groups[currentgroup].nchannels) {
                                        {
#line 1411
                                        printf((char const   */* __restrict  */)"unknown channel\n");
                                        }
                                      } else {
                                        {
#line 1413
                                        tmp___11 = atoi((char const   *)arg1___1);
#line 1413
                                        common->groups[currentgroup].channels[tmp___11].maxc = atoi((char const   *)arg2___1);
#line 1414
                                        tmp___12 = atoi((char const   *)arg2___1);
#line 1414
                                        tmp___13 = atoi((char const   *)arg1___1);
#line 1414
                                        printf((char const   */* __restrict  */)"maxc of channel %d changed to %d\n",
                                               tmp___13, tmp___12);
                                        }
                                      }
                                    }
                                  }
                                } else {
                                  {
#line 1418
                                  printf((char const   */* __restrict  */)"syntax error\n");
                                  }
                                }
                              } else {
                                {
#line 1421
                                printf((char const   */* __restrict  */)"syntax error\n");
                                }
                              }
                              {
#line 1423
                              b_unlock();
                              }
                            } else {
                              {
#line 1425
                              tmp___21 = mycmp(command, (char *)"mrtg-bytes");
                              }
#line 1425
                              if (tmp___21) {
                                {
#line 1428
                                b_writelock();
#line 1429
                                arg1___2 = strtok((char */* __restrict  */)((void *)0),
                                                  (char const   */* __restrict  */)" \t\n");
                                }
#line 1429
                                if ((unsigned long )arg1___2 != (unsigned long )((void *)0)) {
                                  {
#line 1430
                                  arg2___2 = strtok((char */* __restrict  */)((void *)0),
                                                    (char const   */* __restrict  */)" \t\n");
                                  }
#line 1430
                                  if ((unsigned long )arg2___2 != (unsigned long )((void *)0)) {
                                    {
#line 1431
                                    mygroup = atoi((char const   *)arg1___2);
#line 1432
                                    mychannel = atoi((char const   *)arg2___2);
                                    }
#line 1433
                                    if (mygroup < 0) {
                                      {
#line 1434
                                      printf((char const   */* __restrict  */)"unknown group\n");
                                      }
                                    } else
#line 1433
                                    if (mygroup > 16) {
                                      {
#line 1434
                                      printf((char const   */* __restrict  */)"unknown group\n");
                                      }
                                    } else
#line 1436
                                    if (mychannel < 0) {
                                      {
#line 1437
                                      printf((char const   */* __restrict  */)"unknown channel\n");
                                      }
                                    } else
#line 1436
                                    if (mychannel > common->groups[currentgroup].nchannels) {
                                      {
#line 1437
                                      printf((char const   */* __restrict  */)"unknown channel\n");
                                      }
                                    } else {
                                      {
#line 1440
                                      printf((char const   */* __restrict  */)"%llu\n",
                                             common->groups[mygroup].channels[mychannel].breceived);
#line 1441
                                      printf((char const   */* __restrict  */)"%llu\n",
                                             common->groups[mygroup].channels[mychannel].bsent);
#line 1442
                                      printf((char const   */* __restrict  */)"UNKNOWN\n");
#line 1443
                                      printf((char const   */* __restrict  */)"group %d channel %d\n",
                                             mygroup, mychannel);
                                      }
                                    }
                                  } else {
                                    {
#line 1447
                                    printf((char const   */* __restrict  */)"syntax error\n");
                                    }
                                  }
                                } else {
                                  {
#line 1450
                                  printf((char const   */* __restrict  */)"syntax error\n");
                                  }
                                }
                                {
#line 1452
                                b_unlock();
                                }
                              } else {
                                {
#line 1454
                                tmp___20 = mycmp(command, (char *)"mrtg-conns");
                                }
#line 1454
                                if (tmp___20) {
                                  {
#line 1457
                                  b_writelock();
#line 1458
                                  arg1___3 = strtok((char */* __restrict  */)((void *)0),
                                                    (char const   */* __restrict  */)" \t\n");
                                  }
#line 1458
                                  if ((unsigned long )arg1___3 != (unsigned long )((void *)0)) {
                                    {
#line 1459
                                    arg2___3 = strtok((char */* __restrict  */)((void *)0),
                                                      (char const   */* __restrict  */)" \t\n");
                                    }
#line 1459
                                    if ((unsigned long )arg2___3 != (unsigned long )((void *)0)) {
                                      {
#line 1460
                                      mygroup___0 = atoi((char const   *)arg1___3);
#line 1461
                                      mychannel___0 = atoi((char const   *)arg2___3);
                                      }
#line 1462
                                      if (mygroup___0 < 0) {
                                        {
#line 1463
                                        printf((char const   */* __restrict  */)"unknown group\n");
                                        }
                                      } else
#line 1462
                                      if (mygroup___0 > 16) {
                                        {
#line 1463
                                        printf((char const   */* __restrict  */)"unknown group\n");
                                        }
                                      } else
#line 1465
                                      if (mychannel___0 < 0) {
                                        {
#line 1466
                                        printf((char const   */* __restrict  */)"unknown channel\n");
                                        }
                                      } else
#line 1465
                                      if (mychannel___0 > common->groups[currentgroup].nchannels) {
                                        {
#line 1466
                                        printf((char const   */* __restrict  */)"unknown channel\n");
                                        }
                                      } else {
                                        {
#line 1469
                                        printf((char const   */* __restrict  */)"%u\n",
                                               common->groups[mygroup___0].channels[mychannel___0].tc);
#line 1470
                                        printf((char const   */* __restrict  */)"UNKNOWN\n");
#line 1471
                                        printf((char const   */* __restrict  */)"UNKNOWN\n");
#line 1472
                                        printf((char const   */* __restrict  */)"group %d channel %d\n",
                                               mygroup___0, mychannel___0);
                                        }
                                      }
                                    } else {
                                      {
#line 1476
                                      printf((char const   */* __restrict  */)"syntax error\n");
                                      }
                                    }
                                  } else {
                                    {
#line 1479
                                    printf((char const   */* __restrict  */)"syntax error\n");
                                    }
                                  }
                                  {
#line 1481
                                  b_unlock();
                                  }
                                } else {
                                  {
#line 1483
                                  tmp___19 = mycmp(command, (char *)"version");
                                  }
#line 1483
                                  if (tmp___19) {
                                    {
#line 1484
                                    printf((char const   */* __restrict  */)"  This is balance %d.%d\n",
                                           release, subrelease);
#line 1485
                                    printf((char const   */* __restrict  */)"  MAXGROUPS=%d\n",
                                           16);
#line 1486
                                    printf((char const   */* __restrict  */)"  MAXCHANNELS=%d\n",
                                           64);
                                    }
                                  } else {
                                    {
#line 1487
                                    tmp___18 = mycmp(command, (char *)"hash");
                                    }
#line 1487
                                    if (tmp___18) {
                                      {
#line 1488
                                      b_writelock();
#line 1489
                                      common->groups[currentgroup].type = 1;
#line 1490
                                      b_unlock();
#line 1491
                                      printf((char const   */* __restrict  */)"group %d set to hash\n",
                                             currentgroup);
                                      }
                                    } else {
                                      {
#line 1493
                                      tmp___17 = mycmp(command, (char *)"rr");
                                      }
#line 1493
                                      if (tmp___17) {
                                        {
#line 1494
                                        b_writelock();
#line 1495
                                        common->groups[currentgroup].type = 0;
#line 1496
                                        b_unlock();
#line 1497
                                        printf((char const   */* __restrict  */)"group %d set to round robin\n",
                                               currentgroup);
                                        }
                                      } else {
                                        {
#line 1500
                                        printf((char const   */* __restrict  */)"syntax error\n");
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 1504
    if ((unsigned long )argument != (unsigned long )((void *)0)) {
      {
#line 1505
      exit(0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1509 "/home/june/collector/temp/balance-3.54/balance.c"
char bindhost_address[1024]  ;
#line 1511 "/home/june/collector/temp/balance-3.54/balance.c"
int main(int argc , char **argv ) 
{ 
  int startindex ;
  int sockfd ;
  int newsockfd ;
  int childpid ;
  unsigned int clilen ;
  int c ;
  int source_port ;
  int fd ;
  char *argument ;
  struct stat buffer ;
  struct sockaddr_storage cli_addr ;
  struct sigaction usr1_action ;
  struct sigaction chld_action ;
  struct rlimit r ;
  int tmp ;
  char const   *tmp___0 ;
  mode_t old ;
  __mode_t tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int index___0 ;
  unsigned int uindex ;
  int groupindex ;
  int *tmp___6 ;
  char buf[1024] ;

  {
  {
#line 1519
  argument = (char *)((void *)0);
#line 1528
  connect_timeout = 5;
#line 1529
  initialize_release_variables();
  }
  {
#line 1531
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1531
    c = getopt(argc, (char * const  *)argv, "c:b:B:t:T:adfpiHM6");
    }
#line 1531
    if (! (c != -1)) {
#line 1531
      goto while_break;
    }
    {
#line 1533
    if (c == 54) {
#line 1533
      goto case_54;
    }
#line 1536
    if (c == 97) {
#line 1536
      goto case_97;
    }
#line 1539
    if (c == 98) {
#line 1539
      goto case_98;
    }
#line 1542
    if (c == 66) {
#line 1542
      goto case_66;
    }
#line 1545
    if (c == 99) {
#line 1545
      goto case_99;
    }
#line 1551
    if (c == 116) {
#line 1551
      goto case_116;
    }
#line 1557
    if (c == 84) {
#line 1557
      goto case_84;
    }
#line 1564
    if (c == 102) {
#line 1564
      goto case_102;
    }
#line 1567
    if (c == 100) {
#line 1567
      goto case_100;
    }
#line 1570
    if (c == 112) {
#line 1570
      goto case_112;
    }
#line 1573
    if (c == 105) {
#line 1573
      goto case_105;
    }
#line 1578
    if (c == 72) {
#line 1578
      goto case_72;
    }
#line 1581
    if (c == 77) {
#line 1581
      goto case_77;
    }
#line 1589
    goto switch_default;
    case_54: /* CIL Label */ 
#line 1534
    bindipv6 = 1;
#line 1535
    goto switch_break;
    case_97: /* CIL Label */ 
#line 1537
    autodisable = 1;
#line 1538
    goto switch_break;
    case_98: /* CIL Label */ 
#line 1540
    bindhost = optarg;
#line 1541
    goto switch_break;
    case_66: /* CIL Label */ 
#line 1543
    outbindhost = optarg;
#line 1544
    goto switch_break;
    case_99: /* CIL Label */ 
#line 1546
    argument = optarg;
#line 1547
    interactive = 1;
#line 1548
    foreground = 1;
#line 1549
    packetdump = 0;
#line 1550
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 1552
    connect_timeout = atoi((char const   *)optarg);
    }
#line 1553
    if (connect_timeout < 1) {
      {
#line 1554
      usage();
      }
    }
#line 1556
    goto switch_break;
    case_84: /* CIL Label */ 
    {
#line 1558
    tmp = atoi((char const   *)optarg);
#line 1558
    sel_tmout.tv_sec = (__time_t )tmp;
#line 1559
    sel_tmout.tv_usec = (__suseconds_t )0;
    }
#line 1560
    if (sel_tmout.tv_sec < 1L) {
      {
#line 1561
      usage();
      }
    }
#line 1562
    save_tmout = sel_tmout;
#line 1563
    goto switch_break;
    case_102: /* CIL Label */ 
#line 1565
    foreground = 1;
#line 1566
    goto switch_break;
    case_100: /* CIL Label */ 
#line 1568
    debugflag = 1;
#line 1569
    goto switch_break;
    case_112: /* CIL Label */ 
#line 1571
    packetdump = 1;
#line 1572
    goto switch_break;
    case_105: /* CIL Label */ 
#line 1574
    interactive = 1;
#line 1575
    foreground = 1;
#line 1576
    packetdump = 0;
#line 1577
    goto switch_break;
    case_72: /* CIL Label */ 
#line 1579
    hashfailover = 1;
#line 1580
    goto switch_break;
    case_77: /* CIL Label */ 
#line 1585
    shmmapfile = 1;
#line 1587
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1590
    usage();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1594
  if (debugflag) {
    {
#line 1595
    printf((char const   */* __restrict  */)"argv[0]=%s\n", *(argv + 0));
    }
#line 1596
    if ((unsigned long )bindhost == (unsigned long )((void *)0)) {
#line 1596
      tmp___0 = "NULL";
    } else {
#line 1596
      tmp___0 = (char const   *)bindhost;
    }
    {
#line 1596
    printf((char const   */* __restrict  */)"bindhost=%s\n", tmp___0);
    }
  }
#line 1599
  if (interactive) {
#line 1600
    foreground = 1;
#line 1601
    packetdump = 0;
  }
#line 1604
  argc -= optind;
#line 1605
  argv += optind;
#line 1607
  if (! interactive) {
#line 1608
    if (argc < 1) {
      {
#line 1609
      usage();
      }
    }
  } else
#line 1612
  if (argc != 1) {
    {
#line 1613
    usage();
    }
  }
  {
#line 1616
  usr1_action.__sigaction_handler.sa_handler = & usr1_handler;
#line 1617
  usr1_action.sa_flags = 268435456;
#line 1618
  sigemptyset(& usr1_action.sa_mask);
#line 1619
  sigaction(10, (struct sigaction  const  */* __restrict  */)(& usr1_action), (struct sigaction */* __restrict  */)((void *)0));
#line 1621
  chld_action.__sigaction_handler.sa_handler = & chld_handler;
#line 1622
  chld_action.sa_flags = 268435456;
#line 1623
  sigemptyset(& chld_action.sa_mask);
#line 1624
  sigaction(17, (struct sigaction  const  */* __restrict  */)(& chld_action), (struct sigaction */* __restrict  */)((void *)0));
#line 1629
  getrlimit(4, & r);
#line 1630
  r.rlim_cur = r.rlim_max;
#line 1631
  setrlimit(4, (struct rlimit  const  *)(& r));
#line 1636
  source_port = getport(*(argv + 0));
  }
#line 1636
  if (source_port == 0) {
    {
#line 1637
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid port [%s], exiting.\n",
            *(argv + 0));
#line 1638
    exit(64);
    }
  }
#line 1641
  if (debugflag) {
    {
#line 1642
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"source port %d\n",
            source_port);
    }
  }
#line 1650
  if ((unsigned long )bindhost != (unsigned long )((void *)0)) {
    {
#line 1651
    snprintf((char */* __restrict  */)(bindhost_address), (size_t )1024, (char const   */* __restrict  */)"%s",
             bindhost);
    }
  } else {
    {
#line 1653
    snprintf((char */* __restrict  */)(bindhost_address), (size_t )1024, (char const   */* __restrict  */)"%s",
             "0.0.0.0");
    }
  }
  {
#line 1656
  stat((char const   */* __restrict  */)"/var/run/balance/", (struct stat */* __restrict  */)(& buffer));
  }
#line 1657
  if (! ((buffer.st_mode & 61440U) == 16384U)) {
    {
#line 1658
    tmp___1 = umask((__mode_t )0);
#line 1658
    old = tmp___1;
#line 1659
    tmp___3 = mkdir("/var/run/balance/", (__mode_t )1023);
    }
#line 1659
    if (tmp___3 < 0) {
      {
#line 1660
      tmp___2 = __errno_location();
      }
#line 1660
      if (*tmp___2 != 17) {
        {
#line 1661
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: rendezvous directory not available and/or creatable\n");
#line 1662
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"       please create %s with mode 01777 like this: \n",
                "/var/run/balance/");
#line 1663
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"       # mkdir -m 01777 %s\n",
                "/var/run/balance/");
#line 1664
        umask(old);
#line 1665
        exit(69);
        }
      }
    }
    {
#line 1668
    umask(old);
    }
  }
  {
#line 1671
  sprintf((char */* __restrict  */)(rendezvousfile), (char const   */* __restrict  */)"%sbalance.%d.%s",
          "/var/run/balance/", source_port, bindhost_address);
#line 1674
  tmp___4 = stat((char const   */* __restrict  */)(rendezvousfile), (struct stat */* __restrict  */)(& buffer));
  }
#line 1674
  if (tmp___4 == -1) {
    {
#line 1676
    fd = open((char const   *)(rendezvousfile), 66, 438);
    }
#line 1676
    if (fd == -1) {
      {
#line 1677
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cannot create rendezvous file %s\n",
              rendezvousfile);
#line 1679
      exit(71);
      }
    } else {
#line 1681
      if (debugflag) {
        {
#line 1682
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s created\n",
                rendezvousfile);
        }
      }
      {
#line 1683
      close(fd);
      }
    }
  } else
#line 1686
  if (debugflag) {
    {
#line 1687
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s already exists\n",
            rendezvousfile);
    }
  }
#line 1690
  if (interactive) {
    {
#line 1692
    rendezvousfd = open((char const   *)(rendezvousfile), 2, 0);
    }
#line 1692
    if (rendezvousfd < 0) {
      {
#line 1693
      perror("open");
#line 1694
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"check rendezvousfile permissions [%s]\n",
              rendezvousfile);
#line 1695
      exit(71);
      }
    }
    {
#line 1697
    tmp___5 = shm_malloc(rendezvousfile, (int )sizeof(COMMON ));
#line 1697
    common = (COMMON *)tmp___5;
    }
#line 1697
    if ((unsigned long )common == (unsigned long )((void *)0)) {
      {
#line 1699
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cannot alloc COMMON struct\n");
#line 1700
      exit(71);
      }
    }
    {
#line 1702
    shell(argument);
    }
  }
  {
#line 1705
  openlog("Balance", 7, 3 << 3);
#line 1709
  sockfd = create_serversocket(bindhost, *(argv + 0));
#line 1711
  setsockopt(sockfd, 1, 7, (void const   *)(& sockbufsize), (socklen_t )sizeof(sockbufsize));
#line 1712
  setsockopt(sockfd, 1, 8, (void const   *)(& sockbufsize), (socklen_t )sizeof(sockbufsize));
  }
#line 1716
  if (! foreground) {
    {
#line 1717
    background();
    }
  }
  {
#line 1720
  common = makecommon(argc, argv, source_port);
  }
  {
#line 1722
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1725
    groupindex = 0;
#line 1727
    clilen = (unsigned int )sizeof(cli_addr);
#line 1729
    newsockfd = accept(sockfd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& cli_addr)),
                       (socklen_t */* __restrict  */)(& clilen));
    }
#line 1730
    if (newsockfd < 0) {
#line 1731
      if (debugflag) {
        {
#line 1732
        tmp___6 = __errno_location();
#line 1732
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"accept error %d\n",
                *tmp___6);
        }
      }
#line 1734
      goto __Cont;
    }
#line 1737
    if (debugflag) {
      {
#line 1739
      inet_ntop(10, (void const   */* __restrict  */)(& ((struct sockaddr_in6 *)(& cli_addr))->sin6_addr),
                (char */* __restrict  */)(buf), (socklen_t )1024);
#line 1740
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"connect from %s clilen=%d\n",
              buf, clilen);
      }
    }
    {
#line 1751
    b_writelock();
    }
    {
#line 1752
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1753
      index___0 = common->groups[groupindex].current;
      {
#line 1754
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1755
        if (common->groups[groupindex].type == 0) {
#line 1756
          if (common->groups[groupindex].channels[index___0].status == 1) {
#line 1756
            if (common->groups[groupindex].channels[index___0].maxc == 0) {
#line 1760
              goto while_break___2;
            } else
#line 1756
            if (common->groups[groupindex].channels[index___0].c < common->groups[groupindex].channels[index___0].maxc) {
#line 1760
              goto while_break___2;
            } else {
#line 1756
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 1762
            index___0 ++;
#line 1763
            if (index___0 >= common->groups[groupindex].nchannels) {
#line 1764
              index___0 = 0;
            }
#line 1766
            if (index___0 == common->groups[groupindex].current) {
#line 1767
              index___0 = -1;
#line 1768
              goto while_break___2;
            }
          }
        } else
#line 1771
        if (common->groups[groupindex].type == 1) {
          {
#line 1772
          uindex = hash_fold((char *)((unsigned char *)(& ((struct sockaddr_in6 *)(& cli_addr))->sin6_addr)),
                             (int )clilen);
          }
#line 1774
          if (debugflag) {
            {
#line 1775
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"HASH-method: fold returns %u\n",
                    uindex);
            }
          }
#line 1778
          index___0 = (int )(uindex % (unsigned int )common->groups[groupindex].nchannels);
#line 1779
          if (debugflag) {
            {
#line 1780
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"modulo %d gives %d\n",
                    common->groups[groupindex].nchannels, index___0);
            }
          }
#line 1782
          if (common->groups[groupindex].channels[index___0].status == 1) {
#line 1782
            if (common->groups[groupindex].channels[index___0].maxc == 0) {
#line 1787
              goto while_break___2;
            } else
#line 1782
            if (common->groups[groupindex].channels[index___0].c < common->groups[groupindex].channels[index___0].maxc) {
#line 1787
              goto while_break___2;
            } else {
#line 1782
              goto _L___1;
            }
          } else {
            _L___1: /* CIL Label */ 
#line 1789
            if (hashfailover == 1) {
#line 1791
              if (debugflag) {
                {
#line 1792
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"channel disabled - hashfailover.\n");
                }
              }
#line 1793
              startindex = index___0;
              {
#line 1794
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 1795
                index___0 ++;
#line 1796
                if (index___0 >= common->groups[groupindex].nchannels) {
#line 1797
                  index___0 = 0;
                }
#line 1799
                if (index___0 == startindex) {
#line 1800
                  if (debugflag) {
                    {
#line 1801
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"no valid channel in group %d.\n",
                            groupindex);
                    }
                  }
#line 1803
                  index___0 = -1;
#line 1804
                  goto while_break___3;
                }
#line 1806
                if (common->groups[groupindex].channels[index___0].status == 1) {
#line 1806
                  if (common->groups[groupindex].channels[index___0].maxc == 0) {
#line 1806
                    goto _L___0;
                  } else
#line 1806
                  if (common->groups[groupindex].channels[index___0].c < common->groups[groupindex].channels[index___0].maxc) {
                    _L___0: /* CIL Label */ 
#line 1811
                    if (debugflag) {
                      {
#line 1812
                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"channel choosen: %d in group %d.\n",
                              index___0, groupindex);
                      }
                    }
#line 1814
                    goto while_break___3;
                  }
                }
              }
              while_break___3: /* CIL Label */ ;
              }
            } else {
#line 1819
              if (debugflag) {
                {
#line 1820
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"no valid channel in group %d. Failover?\n",
                        groupindex);
                }
              }
#line 1823
              index___0 = -1;
            }
#line 1825
            goto while_break___2;
          }
        } else {
          {
#line 1828
          err_dump((char *)"PANIC: invalid group type");
          }
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1835
      common->groups[groupindex].current = index___0;
#line 1836
      (common->groups[groupindex].current) ++;
#line 1841
      if (common->groups[groupindex].current >= common->groups[groupindex].nchannels) {
#line 1843
        common->groups[groupindex].current = 0;
      }
#line 1846
      if (index___0 >= 0) {
#line 1847
        (common->groups[groupindex].channels[index___0].c) ++;
#line 1848
        (common->groups[groupindex].channels[index___0].tc) ++;
#line 1850
        goto while_break___1;
      } else {
#line 1852
        groupindex ++;
#line 1853
        if (groupindex >= 16) {
#line 1854
          goto while_break___1;
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1859
    b_unlock();
    }
#line 1861
    if (index___0 >= 0) {
      {
#line 1862
      childpid = fork();
      }
#line 1862
      if (childpid < 0) {
#line 1867
        if (debugflag) {
          {
#line 1868
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fork error\n");
          }
        }
      } else
#line 1870
      if (childpid == 0) {
        {
#line 1871
        close(sockfd);
#line 1874
        stream(newsockfd, groupindex, index___0, (char *)(& cli_addr), (int )clilen);
#line 1875
        exit(0);
        }
      }
    }
    {
#line 1879
    close(newsockfd);
    }
    __Cont: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
