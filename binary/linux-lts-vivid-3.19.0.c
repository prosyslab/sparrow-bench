/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 141 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/basic/fixdep.c"
struct item {
   struct item *next ;
   unsigned int len ;
   unsigned int hash ;
   char name[0] ;
};
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 20 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.h"
struct file {
   struct file *next ;
   struct file *parent ;
   char const   *name ;
   int lineno ;
};
#line 27
enum tristate {
    no = 0,
    mod = 1,
    yes = 2
} ;
#line 27 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.h"
typedef enum tristate tristate;
#line 31
enum expr_type {
    E_NONE = 0,
    E_OR = 1,
    E_AND = 2,
    E_NOT = 3,
    E_EQUAL = 4,
    E_UNEQUAL = 5,
    E_LIST = 6,
    E_SYMBOL = 7,
    E_RANGE = 8
} ;
#line 35
struct expr;
#line 35
struct symbol;
#line 35 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.h"
union expr_data {
   struct expr *expr ;
   struct symbol *sym ;
};
#line 40 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.h"
struct expr {
   enum expr_type type ;
   union expr_data left ;
   union expr_data right ;
};
#line 52 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.h"
struct expr_value {
   struct expr *expr ;
   tristate tri ;
};
#line 57 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.h"
struct symbol_value {
   void *val ;
   tristate tri ;
};
#line 62
enum symbol_type {
    S_UNKNOWN = 0,
    S_BOOLEAN = 1,
    S_TRISTATE = 2,
    S_INT = 3,
    S_HEX = 4,
    S_STRING = 5,
    S_OTHER = 6
} ;
#line 75
struct property;
#line 75 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.h"
struct symbol {
   struct symbol *next ;
   char *name ;
   enum symbol_type type ;
   struct symbol_value curr ;
   struct symbol_value def[4] ;
   tristate visible ;
   int flags ;
   struct property *prop ;
   struct expr_value dir_dep ;
   struct expr_value rev_dep ;
};
#line 129
enum prop_type {
    P_UNKNOWN = 0,
    P_PROMPT = 1,
    P_COMMENT = 2,
    P_MENU = 3,
    P_DEFAULT = 4,
    P_CHOICE = 5,
    P_SELECT = 6,
    P_RANGE = 7,
    P_ENV = 8,
    P_SYMBOL = 9
} ;
#line 142
struct menu;
#line 142 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.h"
struct property {
   struct property *next ;
   struct symbol *sym ;
   enum prop_type type ;
   char const   *text ;
   struct expr_value visible ;
   struct expr *expr ;
   struct menu *menu ;
   struct file *file ;
   int lineno ;
};
#line 165 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.h"
struct menu {
   struct menu *next ;
   struct menu *parent ;
   struct menu *list ;
   struct symbol *sym ;
   struct property *prompt ;
   struct expr *visibility ;
   struct expr *dep ;
   unsigned int flags ;
   char *help ;
   struct file *file ;
   int lineno ;
   void *data ;
};
#line 224
struct gstr;
#line 53 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/lkc.h"
enum conf_def_mode {
    def_default = 0,
    def_yes = 1,
    def_mod = 2,
    def_no = 3,
    def_random = 4
} ;
#line 132 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/lkc.h"
struct gstr {
   size_t len ;
   char *s ;
   int max_width ;
};
#line 24 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/conf.c"
enum input_mode {
    oldaskconfig = 0,
    silentoldconfig = 1,
    oldconfig = 2,
    allnoconfig = 3,
    allyesconfig = 4,
    allmodconfig = 5,
    alldefconfig = 6,
    randconfig = 7,
    defconfig = 8,
    savedefconfig = 9,
    listnewconfig = 10,
    olddefconfig = 11
} ;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 90 "/usr/include/stdio.h"
typedef __off_t off_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 23 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/list.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 183 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.h"
struct jump_key {
   struct list_head entries ;
   size_t offset ;
   struct menu *target ;
   int index ;
};
#line 66 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/lkc.h"
struct kconf_id {
   int name ;
   int token ;
   unsigned int flags ;
   enum symbol_type stype ;
};
#line 93 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/lkc.h"
struct conf_printer {
   void (*print_symbol)(FILE * , struct symbol * , char const   * , void * ) ;
   void (*print_comment)(FILE * , char const   * , void * ) ;
};
#line 175 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/zconf.tab.c"
union YYSTYPE {
   char *string ;
   struct file *file ;
   struct symbol *symbol ;
   struct expr *expr ;
   struct menu *menu ;
   struct kconf_id  const  *id ;
};
#line 175 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/zconf.tab.c"
typedef union YYSTYPE YYSTYPE;
#line 69 "scripts/kconfig/zconf.gperf"
struct kconf_id_strings_t {
   char kconf_id_strings_str2[sizeof("if")] ;
   char kconf_id_strings_str3[sizeof("int")] ;
   char kconf_id_strings_str5[sizeof("endif")] ;
   char kconf_id_strings_str7[sizeof("default")] ;
   char kconf_id_strings_str8[sizeof("tristate")] ;
   char kconf_id_strings_str9[sizeof("endchoice")] ;
   char kconf_id_strings_str12[sizeof("def_tristate")] ;
   char kconf_id_strings_str13[sizeof("def_bool")] ;
   char kconf_id_strings_str14[sizeof("defconfig_list")] ;
   char kconf_id_strings_str17[sizeof("on")] ;
   char kconf_id_strings_str18[sizeof("optional")] ;
   char kconf_id_strings_str21[sizeof("option")] ;
   char kconf_id_strings_str22[sizeof("endmenu")] ;
   char kconf_id_strings_str23[sizeof("mainmenu")] ;
   char kconf_id_strings_str25[sizeof("menuconfig")] ;
   char kconf_id_strings_str27[sizeof("modules")] ;
   char kconf_id_strings_str28[sizeof("allnoconfig_y")] ;
   char kconf_id_strings_str29[sizeof("menu")] ;
   char kconf_id_strings_str31[sizeof("select")] ;
   char kconf_id_strings_str32[sizeof("comment")] ;
   char kconf_id_strings_str33[sizeof("env")] ;
   char kconf_id_strings_str35[sizeof("range")] ;
   char kconf_id_strings_str36[sizeof("choice")] ;
   char kconf_id_strings_str39[sizeof("bool")] ;
   char kconf_id_strings_str41[sizeof("source")] ;
   char kconf_id_strings_str42[sizeof("visible")] ;
   char kconf_id_strings_str43[sizeof("hex")] ;
   char kconf_id_strings_str46[sizeof("config")] ;
   char kconf_id_strings_str47[sizeof("boolean")] ;
   char kconf_id_strings_str51[sizeof("string")] ;
   char kconf_id_strings_str54[sizeof("help")] ;
   char kconf_id_strings_str56[sizeof("prompt")] ;
   char kconf_id_strings_str72[sizeof("depends")] ;
};
#line 210 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/zconf.tab.c"
typedef unsigned char yytype_uint8;
#line 217 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/zconf.tab.c"
typedef signed char yytype_int8;
#line 225 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/zconf.tab.c"
typedef unsigned short yytype_uint16;
#line 231 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/zconf.tab.c"
typedef short yytype_int16;
#line 362 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/zconf.tab.c"
union yyalloc {
   yytype_int16 yyss_alloc ;
   YYSTYPE yyvs_alloc ;
};
#line 70 "scripts/kconfig/zconf.lex.c_shipped"
typedef short flex_int16_t;
#line 71 "scripts/kconfig/zconf.lex.c_shipped"
typedef int flex_int32_t;
#line 171
struct yy_buffer_state;
#line 171 "scripts/kconfig/zconf.lex.c_shipped"
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#line 202 "scripts/kconfig/zconf.lex.c_shipped"
typedef size_t yy_size_t;
#line 207 "scripts/kconfig/zconf.lex.c_shipped"
struct yy_buffer_state {
   FILE *yy_input_file ;
   char *yy_ch_buf ;
   char *yy_buf_pos ;
   yy_size_t yy_buf_size ;
   int yy_n_chars ;
   int yy_is_our_buffer ;
   int yy_is_interactive ;
   int yy_at_bol ;
   int yy_bs_lineno ;
   int yy_bs_column ;
   int yy_fill_buffer ;
   int yy_buffer_status ;
};
#line 360 "scripts/kconfig/zconf.lex.c_shipped"
typedef int yy_state_type;
#line 783 "scripts/kconfig/zconf.lex.c_shipped"
struct __anonstruct_current_pos_31 {
   struct file *file ;
   int lineno ;
};
#line 791 "scripts/kconfig/zconf.lex.c_shipped"
struct buffer {
   struct buffer *parent ;
   YY_BUFFER_STATE state ;
};
#line 43 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *__buffer ;
   unsigned long __allocated ;
   unsigned long __used ;
   reg_syntax_t __syntax ;
   char *__fastmap ;
   unsigned char *__translate ;
   size_t re_nsub ;
   unsigned int __can_be_null : 1 ;
   unsigned int __regs_allocated : 2 ;
   unsigned int __fastmap_accurate : 1 ;
   unsigned int __no_sub : 1 ;
   unsigned int __not_bol : 1 ;
   unsigned int __not_eol : 1 ;
   unsigned int __newline_anchor : 1 ;
};
#line 434 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 437 "/usr/include/regex.h"
typedef int regoff_t;
#line 463 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_33 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 463 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_33 regmatch_t;
#line 48 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
struct utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char __domainname[65] ;
};
#line 958 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
struct sym_match {
   struct symbol *sym ;
   off_t so ;
   off_t eo ;
};
#line 1052 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
struct dep_stack {
   struct dep_stack *prev ;
   struct dep_stack *next ;
   struct symbol *sym ;
   struct property *prop ;
   struct expr *expr ;
};
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 31 "/usr/include/elf.h"
typedef uint16_t Elf32_Half;
#line 35 "/usr/include/elf.h"
typedef uint32_t Elf32_Word;
#line 47 "/usr/include/elf.h"
typedef uint32_t Elf32_Addr;
#line 51 "/usr/include/elf.h"
typedef uint32_t Elf32_Off;
#line 55 "/usr/include/elf.h"
typedef uint16_t Elf32_Section;
#line 67 "/usr/include/elf.h"
struct __anonstruct_Elf32_Ehdr_29 {
   unsigned char e_ident[16] ;
   Elf32_Half e_type ;
   Elf32_Half e_machine ;
   Elf32_Word e_version ;
   Elf32_Addr e_entry ;
   Elf32_Off e_phoff ;
   Elf32_Off e_shoff ;
   Elf32_Word e_flags ;
   Elf32_Half e_ehsize ;
   Elf32_Half e_phentsize ;
   Elf32_Half e_phnum ;
   Elf32_Half e_shentsize ;
   Elf32_Half e_shnum ;
   Elf32_Half e_shstrndx ;
};
#line 67 "/usr/include/elf.h"
typedef struct __anonstruct_Elf32_Ehdr_29 Elf32_Ehdr;
#line 272 "/usr/include/elf.h"
struct __anonstruct_Elf32_Shdr_31 {
   Elf32_Word sh_name ;
   Elf32_Word sh_type ;
   Elf32_Word sh_flags ;
   Elf32_Addr sh_addr ;
   Elf32_Off sh_offset ;
   Elf32_Word sh_size ;
   Elf32_Word sh_link ;
   Elf32_Word sh_info ;
   Elf32_Word sh_addralign ;
   Elf32_Word sh_entsize ;
};
#line 272 "/usr/include/elf.h"
typedef struct __anonstruct_Elf32_Shdr_31 Elf32_Shdr;
#line 381 "/usr/include/elf.h"
struct __anonstruct_Elf32_Sym_33 {
   Elf32_Word st_name ;
   Elf32_Addr st_value ;
   Elf32_Word st_size ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf32_Section st_shndx ;
};
#line 381 "/usr/include/elf.h"
typedef struct __anonstruct_Elf32_Sym_33 Elf32_Sym;
#line 496 "/usr/include/elf.h"
struct __anonstruct_Elf32_Rel_37 {
   Elf32_Addr r_offset ;
   Elf32_Word r_info ;
};
#line 496 "/usr/include/elf.h"
typedef struct __anonstruct_Elf32_Rel_37 Elf32_Rel;
#line 541 "/usr/include/elf.h"
struct __anonstruct_Elf32_Phdr_41 {
   Elf32_Word p_type ;
   Elf32_Off p_offset ;
   Elf32_Addr p_vaddr ;
   Elf32_Addr p_paddr ;
   Elf32_Word p_filesz ;
   Elf32_Word p_memsz ;
   Elf32_Word p_flags ;
   Elf32_Word p_align ;
};
#line 541 "/usr/include/elf.h"
typedef struct __anonstruct_Elf32_Phdr_41 Elf32_Phdr;
#line 23 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.h"
enum symtype {
    S_ABS = 0,
    S_REL = 1,
    S_SEG = 2,
    S_LIN = 3,
    S_NSYMTYPES = 4
} ;
#line 15 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
struct relocs {
   uint32_t *offset ;
   unsigned long count ;
   unsigned long size ;
};
#line 28 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
struct section {
   Elf32_Shdr shdr ;
   struct section *link ;
   Elf32_Sym *symtab ;
   Elf32_Rel *reltab ;
   char *strtab ;
};
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef int int32_t;
#line 197 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef long int64_t;
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 32 "/usr/include/elf.h"
typedef uint16_t Elf64_Half;
#line 43 "/usr/include/elf.h"
typedef uint64_t Elf64_Xword;
#line 44 "/usr/include/elf.h"
typedef int64_t Elf64_Sxword;
#line 48 "/usr/include/elf.h"
typedef uint64_t Elf64_Addr;
#line 52 "/usr/include/elf.h"
typedef uint64_t Elf64_Off;
#line 56 "/usr/include/elf.h"
typedef uint16_t Elf64_Section;
#line 85 "/usr/include/elf.h"
struct __anonstruct_Elf64_Ehdr_30 {
   unsigned char e_ident[16] ;
   Elf64_Half e_type ;
   Elf64_Half e_machine ;
   Elf32_Word e_version ;
   Elf64_Addr e_entry ;
   Elf64_Off e_phoff ;
   Elf64_Off e_shoff ;
   Elf32_Word e_flags ;
   Elf64_Half e_ehsize ;
   Elf64_Half e_phentsize ;
   Elf64_Half e_phnum ;
   Elf64_Half e_shentsize ;
   Elf64_Half e_shnum ;
   Elf64_Half e_shstrndx ;
};
#line 85 "/usr/include/elf.h"
typedef struct __anonstruct_Elf64_Ehdr_30 Elf64_Ehdr;
#line 286 "/usr/include/elf.h"
struct __anonstruct_Elf64_Shdr_32 {
   Elf32_Word sh_name ;
   Elf32_Word sh_type ;
   Elf64_Xword sh_flags ;
   Elf64_Addr sh_addr ;
   Elf64_Off sh_offset ;
   Elf64_Xword sh_size ;
   Elf32_Word sh_link ;
   Elf32_Word sh_info ;
   Elf64_Xword sh_addralign ;
   Elf64_Xword sh_entsize ;
};
#line 286 "/usr/include/elf.h"
typedef struct __anonstruct_Elf64_Shdr_32 Elf64_Shdr;
#line 391 "/usr/include/elf.h"
struct __anonstruct_Elf64_Sym_34 {
   Elf32_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Section st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 391 "/usr/include/elf.h"
typedef struct __anonstruct_Elf64_Sym_34 Elf64_Sym;
#line 522 "/usr/include/elf.h"
struct __anonstruct_Elf64_Rela_40 {
   Elf64_Addr r_offset ;
   Elf64_Xword r_info ;
   Elf64_Sxword r_addend ;
};
#line 522 "/usr/include/elf.h"
typedef struct __anonstruct_Elf64_Rela_40 Elf64_Rela;
#line 553 "/usr/include/elf.h"
struct __anonstruct_Elf64_Phdr_42 {
   Elf32_Word p_type ;
   Elf32_Word p_flags ;
   Elf64_Off p_offset ;
   Elf64_Addr p_vaddr ;
   Elf64_Addr p_paddr ;
   Elf64_Xword p_filesz ;
   Elf64_Xword p_memsz ;
   Elf64_Xword p_align ;
};
#line 553 "/usr/include/elf.h"
typedef struct __anonstruct_Elf64_Phdr_42 Elf64_Phdr;
#line 28 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
struct section___0 {
   Elf64_Shdr shdr ;
   struct section___0 *link ;
   Elf64_Sym *symtab ;
   Elf64_Rela *reltab ;
   char *strtab ;
};
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mmap)(void *__addr ,
                                                                             size_t __len ,
                                                                             int __prot ,
                                                                             int __flags ,
                                                                             int __fd ,
                                                                             __off_t __offset ) ;
#line 76
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munmap)(void *__addr ,
                                                                             size_t __len ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 580
extern int putchar(int __c ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 123 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/basic/fixdep.c"
char *target  ;
#line 124 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/basic/fixdep.c"
char *depfile  ;
#line 125 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/basic/fixdep.c"
char *cmdline  ;
#line 127 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/basic/fixdep.c"
static void usage(void) 
{ 


  {
  {
#line 129
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: fixdep <depfile> <target> <cmdline>\n");
#line 130
  exit(1);
  }
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/basic/fixdep.c"
static void print_cmdline(void) 
{ 


  {
  {
#line 138
  printf((char const   */* __restrict  */)"cmd_%s := %s\n\n", target, cmdline);
  }
#line 139
  return;
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/basic/fixdep.c"
static struct item *hashtab[256]  ;
#line 151 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/basic/fixdep.c"
static unsigned int strhash(char const   *str , unsigned int sz ) 
{ 
  unsigned int i ;
  unsigned int hash ;

  {
#line 154
  hash = 2166136261U;
#line 156
  i = 0U;
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (! (i < sz)) {
#line 156
      goto while_break;
    }
#line 157
    hash = (hash ^ (unsigned int )*(str + i)) * 16777619U;
#line 156
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 158
  return (hash);
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/basic/fixdep.c"
static int is_defined_config(char const   *name , int len , unsigned int hash ) 
{ 
  struct item *aux ;
  int tmp ;

  {
#line 168
  aux = hashtab[hash % 256U];
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 168
    if (! aux) {
#line 168
      goto while_break;
    }
#line 169
    if (aux->hash == hash) {
#line 169
      if (aux->len == (unsigned int )len) {
        {
#line 169
        tmp = memcmp((void const   *)(aux->name), (void const   *)name, (size_t )len);
        }
#line 169
        if (tmp == 0) {
#line 171
          return (1);
        }
      }
    }
#line 168
    aux = aux->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 173
  return (0);
}
}
#line 179 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/basic/fixdep.c"
static void define_config(char const   *name , int len , unsigned int hash ) 
{ 
  struct item *aux ;
  void *tmp ;

  {
  {
#line 181
  tmp = malloc(sizeof(*aux) + (unsigned long )len);
#line 181
  aux = (struct item *)tmp;
  }
#line 183
  if (! aux) {
    {
#line 184
    perror("fixdep:malloc");
#line 185
    exit(1);
    }
  }
  {
#line 187
  memcpy((void */* __restrict  */)(aux->name), (void const   */* __restrict  */)name,
         (size_t )len);
#line 188
  aux->len = (unsigned int )len;
#line 189
  aux->hash = hash;
#line 190
  aux->next = hashtab[hash % 256U];
#line 191
  hashtab[hash % 256U] = aux;
  }
#line 192
  return;
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/basic/fixdep.c"
static void clear_config(void) 
{ 
  struct item *aux ;
  struct item *next ;
  unsigned int i ;

  {
#line 202
  i = 0U;
  {
#line 202
  while (1) {
    while_continue: /* CIL Label */ ;
#line 202
    if (! (i < 256U)) {
#line 202
      goto while_break;
    }
#line 203
    aux = hashtab[i];
    {
#line 203
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 203
      if (! aux) {
#line 203
        goto while_break___0;
      }
      {
#line 204
      next = aux->next;
#line 205
      free((void *)aux);
#line 203
      aux = next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 207
    hashtab[i] = (struct item *)((void *)0);
#line 202
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 209
  return;
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/basic/fixdep.c"
static void use_config(char const   *m , int slen ) 
{ 
  unsigned int hash ;
  unsigned int tmp ;
  int c ;
  int i ;
  int tmp___0 ;

  {
  {
#line 216
  tmp = strhash(m, (unsigned int )slen);
#line 216
  hash = tmp;
#line 219
  tmp___0 = is_defined_config(m, slen, hash);
  }
#line 219
  if (tmp___0) {
#line 220
    return;
  }
  {
#line 222
  define_config(m, slen, hash);
#line 224
  printf((char const   */* __restrict  */)"    $(wildcard include/config/");
#line 225
  i = 0;
  }
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 225
    if (! (i < slen)) {
#line 225
      goto while_break;
    }
#line 226
    c = (int )*(m + i);
#line 227
    if (c == 95) {
#line 228
      c = '/';
    } else {
      {
#line 230
      c = tolower(c);
      }
    }
    {
#line 231
    putchar(c);
#line 225
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 233
  printf((char const   */* __restrict  */)".h) \\\n");
  }
#line 234
  return;
}
}
#line 236 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/basic/fixdep.c"
static void parse_config_file(char const   *map , size_t len ) 
{ 
  int const   *end ;
  int const   *m ;
  char const   *p ;
  char const   *q ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;

  {
#line 238
  end = (int const   *)(map + len);
#line 240
  m = (int const   *)map + 1;
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 243
    if (! ((unsigned long )m < (unsigned long )end)) {
#line 243
      goto while_break;
    }
    {
#line 244
    tmp = ntohl((uint32_t )1129270854);
    }
#line 244
    if ((uint32_t )*m == tmp) {
#line 244
      p = (char const   *)((char *)m);
#line 244
      goto conf;
    }
    {
#line 245
    tmp___0 = ntohl((uint32_t )1330529865);
    }
#line 245
    if ((uint32_t )*m == tmp___0) {
#line 245
      p = (char const   *)((char *)m - 1);
#line 245
      goto conf;
    }
    {
#line 246
    tmp___1 = ntohl((uint32_t )1313229127);
    }
#line 246
    if ((uint32_t )*m == tmp___1) {
#line 246
      p = (char const   *)((char *)m - 2);
#line 246
      goto conf;
    }
    {
#line 247
    tmp___2 = ntohl((uint32_t )1179207519);
    }
#line 247
    if ((uint32_t )*m == tmp___2) {
#line 247
      p = (char const   *)((char *)m - 3);
#line 247
      goto conf;
    }
#line 248
    goto __Cont;
    conf: 
#line 250
    if ((unsigned long )p > (unsigned long )((map + len) - 7)) {
#line 251
      goto __Cont;
    }
    {
#line 252
    tmp___3 = memcmp((void const   *)p, (void const   *)"CONFIG_", (size_t )7);
    }
#line 252
    if (tmp___3) {
#line 253
      goto __Cont;
    }
#line 254
    q = p + 7;
    {
#line 254
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 254
      if (! ((unsigned long )q < (unsigned long )(map + len))) {
#line 254
        goto while_break___0;
      }
      {
#line 255
      tmp___4 = __ctype_b_loc();
      }
#line 255
      if (! ((int const   )*(*tmp___4 + (int )*q) & 8)) {
#line 255
        if (! ((int const   )*q == 95)) {
#line 256
          goto found;
        }
      }
#line 254
      q ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 258
    goto __Cont;
    found: 
    {
#line 261
    tmp___5 = memcmp((void const   *)(q - 7), (void const   *)"_MODULE", (size_t )7);
    }
#line 261
    if (! tmp___5) {
#line 262
      q -= 7;
    }
#line 263
    if ((q - p) - 7L < 0L) {
#line 264
      goto __Cont;
    }
    {
#line 265
    use_config(p + 7, (int )((q - p) - 7L));
    }
    __Cont: /* CIL Label */ 
#line 243
    m ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 267
  return;
}
}
#line 270 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/basic/fixdep.c"
static int strrcmp(char *s , char *sub ) 
{ 
  int slen ;
  size_t tmp ;
  int sublen ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 272
  tmp = strlen((char const   *)s);
#line 272
  slen = (int )tmp;
#line 273
  tmp___0 = strlen((char const   *)sub);
#line 273
  sublen = (int )tmp___0;
  }
#line 275
  if (sublen > slen) {
#line 276
    return (1);
  }
  {
#line 278
  tmp___1 = memcmp((void const   *)((s + slen) - sublen), (void const   *)sub, (size_t )sublen);
  }
#line 278
  return (tmp___1);
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/basic/fixdep.c"
static void do_config_file(char const   *filename ) 
{ 
  struct stat st ;
  int fd ;
  void *map ;

  {
  {
#line 287
  fd = open(filename, 0);
  }
#line 288
  if (fd < 0) {
    {
#line 289
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fixdep: error opening config file: ");
#line 290
    perror(filename);
#line 291
    exit(2);
    }
  }
  {
#line 293
  fstat(fd, & st);
  }
#line 294
  if (st.st_size == 0L) {
    {
#line 295
    close(fd);
    }
#line 296
    return;
  }
  {
#line 298
  map = mmap((void *)0, (size_t )st.st_size, 1, 2, fd, (__off_t )0);
  }
#line 299
  if ((long )map == -1L) {
    {
#line 300
    perror("fixdep: mmap");
#line 301
    close(fd);
    }
#line 302
    return;
  }
  {
#line 305
  parse_config_file((char const   *)map, (size_t )st.st_size);
#line 307
  munmap(map, (size_t )st.st_size);
#line 309
  close(fd);
  }
#line 310
  return;
}
}
#line 317 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/basic/fixdep.c"
static void parse_dep_file(void *map , size_t len ) 
{ 
  char *m ;
  char *end ;
  char *p ;
  char s[4096] ;
  int is_target ;
  int saw_any_target ;
  int is_first_dep ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 319
  m = (char *)map;
#line 320
  end = m + len;
#line 324
  saw_any_target = 0;
#line 325
  is_first_dep = 0;
#line 327
  clear_config();
  }
  {
#line 329
  while (1) {
    while_continue: /* CIL Label */ ;
#line 329
    if (! ((unsigned long )m < (unsigned long )end)) {
#line 329
      goto while_break;
    }
    {
#line 331
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 331
      if ((unsigned long )m < (unsigned long )end) {
#line 331
        if (! ((int )*m == 32)) {
#line 331
          if (! ((int )*m == 92)) {
#line 331
            if (! ((int )*m == 10)) {
#line 331
              goto while_break___0;
            }
          }
        }
      } else {
#line 331
        goto while_break___0;
      }
#line 332
      m ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 334
    p = m;
    {
#line 335
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 335
      if ((unsigned long )p < (unsigned long )end) {
#line 335
        if ((int )*p != 32) {
#line 335
          if ((int )*p != 92) {
#line 335
            if (! ((int )*p != 10)) {
#line 335
              goto while_break___1;
            }
          } else {
#line 335
            goto while_break___1;
          }
        } else {
#line 335
          goto while_break___1;
        }
      } else {
#line 335
        goto while_break___1;
      }
#line 336
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 338
    is_target = (int )*(p - 1) == 58;
#line 340
    if (is_target) {
#line 342
      is_first_dep = 1;
    } else {
      {
#line 345
      memcpy((void */* __restrict  */)(s), (void const   */* __restrict  */)m, (size_t )(p - m));
#line 346
      s[p - m] = (char)0;
#line 349
      tmp = strrcmp(s, (char *)"include/generated/autoconf.h");
      }
#line 349
      if (tmp) {
        {
#line 349
        tmp___0 = strrcmp(s, (char *)"arch/um/include/uml-config.h");
        }
#line 349
        if (tmp___0) {
          {
#line 349
          tmp___1 = strrcmp(s, (char *)"include/linux/kconfig.h");
          }
#line 349
          if (tmp___1) {
            {
#line 349
            tmp___2 = strrcmp(s, (char *)".ver");
            }
#line 349
            if (tmp___2) {
#line 360
              if (is_first_dep) {
#line 370
                if (! saw_any_target) {
                  {
#line 371
                  saw_any_target = 1;
#line 372
                  printf((char const   */* __restrict  */)"source_%s := %s\n\n", target,
                         s);
#line 374
                  printf((char const   */* __restrict  */)"deps_%s := \\\n", target);
                  }
                }
#line 377
                is_first_dep = 0;
              } else {
                {
#line 379
                printf((char const   */* __restrict  */)"  %s \\\n", s);
                }
              }
              {
#line 380
              do_config_file((char const   *)(s));
              }
            }
          }
        }
      }
    }
#line 387
    m = p + 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 390
  if (! saw_any_target) {
    {
#line 391
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fixdep: parse error; no targets found\n");
#line 392
    exit(1);
    }
  }
  {
#line 395
  printf((char const   */* __restrict  */)"\n%s: $(deps_%s)\n\n", target, target);
#line 396
  printf((char const   */* __restrict  */)"$(deps_%s):\n", target);
  }
#line 397
  return;
}
}
#line 399 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/basic/fixdep.c"
static void print_deps(void) 
{ 
  struct stat st ;
  int fd ;
  void *map ;
  int tmp ;

  {
  {
#line 405
  fd = open((char const   *)depfile, 0);
  }
#line 406
  if (fd < 0) {
    {
#line 407
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fixdep: error opening depfile: ");
#line 408
    perror((char const   *)depfile);
#line 409
    exit(2);
    }
  }
  {
#line 411
  tmp = fstat(fd, & st);
  }
#line 411
  if (tmp < 0) {
    {
#line 412
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fixdep: error fstat\'ing depfile: ");
#line 413
    perror((char const   *)depfile);
#line 414
    exit(2);
    }
  }
#line 416
  if (st.st_size == 0L) {
    {
#line 417
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fixdep: %s is empty\n",
            depfile);
#line 418
    close(fd);
    }
#line 419
    return;
  }
  {
#line 421
  map = mmap((void *)0, (size_t )st.st_size, 1, 2, fd, (__off_t )0);
  }
#line 422
  if ((long )map == -1L) {
    {
#line 423
    perror("fixdep: mmap");
#line 424
    close(fd);
    }
#line 425
    return;
  }
  {
#line 428
  parse_dep_file(map, (size_t )st.st_size);
#line 430
  munmap(map, (size_t )st.st_size);
#line 432
  close(fd);
  }
#line 433
  return;
}
}
#line 437
static void traps(void) ;
#line 437 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/basic/fixdep.c"
static char test[5]  __attribute__((__aligned__(sizeof(int ))))  = {      (char )'C',      (char )'O',      (char )'N',      (char )'F', 
        (char )'\000'};
#line 435 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/basic/fixdep.c"
static void traps(void) 
{ 
  int *p ;
  uint32_t tmp ;

  {
  {
#line 438
  p = (int *)(test);
#line 440
  tmp = ntohl((uint32_t )1129270854);
  }
#line 440
  if ((uint32_t )*p != tmp) {
    {
#line 441
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fixdep: sizeof(int) != 4 or wrong endianness? %#x\n",
            *p);
#line 443
    exit(2);
    }
  }
#line 445
  return;
}
}
#line 447 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/basic/fixdep.c"
int main(int argc , char **argv ) 
{ 


  {
  {
#line 449
  traps();
  }
#line 451
  if (argc != 4) {
    {
#line 452
    usage();
    }
  }
  {
#line 454
  depfile = *(argv + 1);
#line 455
  target = *(argv + 2);
#line 456
  cmdline = *(argv + 3);
#line 458
  print_cmdline();
#line 459
  print_deps();
  }
#line 461
  return (0);
}
}
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 183
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 779 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 173
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 39 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) gettext)(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 82
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) textdomain)(char const   *__domainname ) ;
#line 86
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) bindtextdomain)(char const   *__domainname ,
                                                                                       char const   *__dirname ) ;
#line 4 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/lkc_proto.h"
void conf_parse(char const   *name ) ;
#line 5
int conf_read(char const   *name ) ;
#line 6
int conf_read_simple(char const   *name , int def ) ;
#line 7
int conf_write_defconfig(char const   *filename ) ;
#line 8
int conf_write(char const   *name ) ;
#line 9
int conf_write_autoconf(void) ;
#line 10
_Bool conf_get_changed(void) ;
#line 15
struct menu rootmenu ;
#line 18
_Bool menu_is_visible(struct menu *menu ) ;
#line 20
char const   *menu_get_prompt(struct menu *menu ) ;
#line 22
struct menu *menu_get_parent_menu(struct menu *menu ) ;
#line 23
_Bool menu_has_help(struct menu *menu ) ;
#line 29
void menu_get_ext_help(struct menu *menu , struct gstr *help ) ;
#line 40
void sym_calc_value(struct symbol *sym ) ;
#line 41
enum symbol_type sym_get_type(struct symbol *sym ) ;
#line 42
_Bool sym_tristate_within_range(struct symbol *sym , tristate val ) ;
#line 43
_Bool sym_set_tristate_value(struct symbol *sym , tristate val ) ;
#line 47
_Bool sym_set_string_value(struct symbol *sym , char const   *newval ) ;
#line 48
_Bool sym_is_changable(struct symbol *sym ) ;
#line 51
char const   *sym_get_string_value(struct symbol *sym ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/lkc.h"
__inline static char const   *CONFIG_prefix(void) 
{ 
  char const   *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 44
  tmp___1 = getenv("CONFIG_");
#line 44
  tmp___0 = (char const   *)tmp___1;
  }
#line 44
  if (! tmp___0) {
#line 44
    tmp___0 = "CONFIG_";
  }
#line 44
  return (tmp___0);
}
}
#line 85
char const   *conf_get_configname(void) ;
#line 87
char *conf_get_default_confname(void) ;
#line 90
_Bool conf_set_all_new_symbols(enum conf_def_mode mode ) ;
#line 141
struct gstr str_new(void) ;
#line 143
void str_free(struct gstr *gs ) ;
#line 146
char const   *str_get(struct gstr *gs ) ;
#line 162 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/lkc.h"
__inline static tristate sym_get_tristate_value(struct symbol *sym ) 
{ 


  {
#line 164
  return (sym->curr.tri);
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/lkc.h"
__inline static struct symbol *sym_get_choice_value(struct symbol *sym ) 
{ 


  {
#line 170
  return ((struct symbol *)sym->curr.val);
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/lkc.h"
__inline static _Bool sym_set_choice_value(struct symbol *ch , struct symbol *chval ) 
{ 
  _Bool tmp ;

  {
  {
#line 175
  tmp = sym_set_tristate_value(chval, (tristate )2);
  }
#line 175
  return (tmp);
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/lkc.h"
__inline static _Bool sym_is_choice(struct symbol *sym ) 
{ 
  int tmp ;

  {
#line 180
  if (sym->flags & 16) {
#line 180
    tmp = 1;
  } else {
#line 180
    tmp = 0;
  }
#line 180
  return ((_Bool )tmp);
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/lkc.h"
__inline static _Bool sym_is_choice_value(struct symbol *sym ) 
{ 
  int tmp ;

  {
#line 185
  if (sym->flags & 32) {
#line 185
    tmp = 1;
  } else {
#line 185
    tmp = 0;
  }
#line 185
  return ((_Bool )tmp);
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/lkc.h"
__inline static _Bool sym_has_value(struct symbol *sym ) 
{ 
  int tmp ;

  {
#line 195
  if (sym->flags & 65536) {
#line 195
    tmp = 1;
  } else {
#line 195
    tmp = 0;
  }
#line 195
  return ((_Bool )tmp);
}
}
#line 20 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/conf.c"
static void conf(struct menu *menu ) ;
#line 21
static void check_conf(struct menu *menu ) ;
#line 22
static void xfgets(char *str , int size , FILE *in ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/conf.c"
enum input_mode input_mode  =    (enum input_mode )0;
#line 39 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/conf.c"
static int indent  =    1;
#line 40 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/conf.c"
static int tty_stdio  ;
#line 41 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/conf.c"
static int valid_stdin  =    1;
#line 42 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/conf.c"
static int sync_kconfig  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/conf.c"
static int conf_cnt  ;
#line 44 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/conf.c"
static char line[128]  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/conf.c"
static struct menu *rootEntry  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/conf.c"
static void print_help(struct menu *menu ) 
{ 
  struct gstr help ;
  struct gstr tmp ;
  char const   *tmp___0 ;

  {
  {
#line 49
  tmp = str_new();
#line 49
  help = tmp;
#line 51
  menu_get_ext_help(menu, & help);
#line 53
  tmp___0 = str_get(& help);
#line 53
  printf((char const   */* __restrict  */)"\n%s\n", tmp___0);
#line 54
  str_free(& help);
  }
#line 55
  return;
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/conf.c"
static void strip(char *str ) 
{ 
  char *p ;
  int l ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
#line 59
  p = str;
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 62
    tmp = __ctype_b_loc();
    }
#line 62
    if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 62
      goto while_break;
    }
#line 63
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 64
  tmp___0 = strlen((char const   *)p);
#line 64
  l = (int )tmp___0;
  }
#line 65
  if ((unsigned long )p != (unsigned long )str) {
    {
#line 66
    memmove((void *)str, (void const   *)p, (size_t )(l + 1));
    }
  }
#line 67
  if (! l) {
#line 68
    return;
  }
#line 69
  p = (str + l) - 1;
  {
#line 70
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 70
    tmp___2 = __ctype_b_loc();
    }
#line 70
    if (! ((int const   )*(*tmp___2 + (int )*p) & 8192)) {
#line 70
      goto while_break___0;
    }
#line 71
    tmp___1 = p;
#line 71
    p --;
#line 71
    *tmp___1 = (char)0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 72
  return;
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/conf.c"
static void check_stdin(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 76
  if (! valid_stdin) {
    {
#line 77
    tmp = gettext("aborted!\n\n");
#line 77
    printf((char const   */* __restrict  */)tmp);
#line 78
    tmp___0 = gettext("Console input/output is redirected. ");
#line 78
    printf((char const   */* __restrict  */)tmp___0);
#line 79
    tmp___1 = gettext("Run \'make oldconfig\' to update configuration.\n\n");
#line 79
    printf((char const   */* __restrict  */)tmp___1);
#line 80
    exit(1);
    }
  }
#line 82
  return;
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/conf.c"
static int conf_askvalue(struct symbol *sym , char const   *def ) 
{ 
  enum symbol_type type ;
  enum symbol_type tmp ;
  char *tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;

  {
  {
#line 86
  tmp = sym_get_type(sym);
#line 86
  type = tmp;
#line 88
  tmp___1 = sym_has_value(sym);
  }
#line 88
  if (! tmp___1) {
    {
#line 89
    tmp___0 = gettext("(NEW) ");
#line 89
    printf((char const   */* __restrict  */)tmp___0);
    }
  }
  {
#line 91
  line[0] = (char )'\n';
#line 92
  line[1] = (char)0;
#line 94
  tmp___2 = sym_is_changable(sym);
  }
#line 94
  if (! tmp___2) {
    {
#line 95
    printf((char const   */* __restrict  */)"%s\n", def);
#line 96
    line[0] = (char )'\n';
#line 97
    line[1] = (char)0;
    }
#line 98
    return (0);
  }
  {
#line 103
  if ((unsigned int )input_mode == 1U) {
#line 103
    goto case_1;
  }
#line 103
  if ((unsigned int )input_mode == 2U) {
#line 103
    goto case_1;
  }
#line 110
  if ((unsigned int )input_mode == 0U) {
#line 110
    goto case_0;
  }
#line 116
  goto switch_default;
  case_1: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 104
  tmp___3 = sym_has_value(sym);
  }
#line 104
  if (tmp___3) {
    {
#line 105
    printf((char const   */* __restrict  */)"%s\n", def);
    }
#line 106
    return (0);
  }
  {
#line 108
  check_stdin();
  }
  case_0: /* CIL Label */ 
  {
#line 111
  fflush(stdout);
#line 112
  xfgets(line, 128, stdin);
  }
#line 113
  if (! tty_stdio) {
    {
#line 114
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 115
  return (1);
  switch_default: /* CIL Label */ 
#line 117
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 123
  if ((unsigned int )type == 5U) {
#line 123
    goto case_5;
  }
#line 123
  if ((unsigned int )type == 4U) {
#line 123
    goto case_5;
  }
#line 123
  if ((unsigned int )type == 3U) {
#line 123
    goto case_5;
  }
#line 126
  goto switch_default___0;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 124
  printf((char const   */* __restrict  */)"%s\n", def);
  }
#line 125
  return (1);
  switch_default___0: /* CIL Label */ ;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 129
  printf((char const   */* __restrict  */)"%s", line);
  }
#line 130
  return (1);
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/conf.c"
static int conf_string(struct menu *menu ) 
{ 
  struct symbol *sym ;
  char const   *def ;
  char *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  _Bool tmp___3 ;

  {
#line 135
  sym = menu->sym;
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 139
    tmp = gettext((menu->prompt)->text);
#line 139
    printf((char const   */* __restrict  */)"%*s%s ", indent - 1, "", tmp);
#line 140
    printf((char const   */* __restrict  */)"(%s) ", sym->name);
#line 141
    def = sym_get_string_value(sym);
#line 142
    tmp___0 = sym_get_string_value(sym);
    }
#line 142
    if (tmp___0) {
      {
#line 143
      printf((char const   */* __restrict  */)"[%s] ", def);
      }
    }
    {
#line 144
    tmp___1 = conf_askvalue(sym, def);
    }
#line 144
    if (! tmp___1) {
#line 145
      return (0);
    }
    {
#line 147
    if ((int )line[0] == 10) {
#line 147
      goto case_10;
    }
#line 149
    if ((int )line[0] == 63) {
#line 149
      goto case_63;
    }
#line 157
    goto switch_default;
    case_10: /* CIL Label */ 
#line 148
    goto switch_break;
    case_63: /* CIL Label */ 
#line 151
    if ((int )line[1] == 10) {
      {
#line 152
      print_help(menu);
#line 153
      def = (char const   *)((void *)0);
      }
#line 154
      goto switch_break;
    }
    switch_default: /* CIL Label */ 
    {
#line 158
    tmp___2 = strlen((char const   *)(line));
#line 158
    line[tmp___2 - 1UL] = (char)0;
#line 159
    def = (char const   *)(line);
    }
    switch_break: /* CIL Label */ ;
    }
#line 161
    if (def) {
      {
#line 161
      tmp___3 = sym_set_string_value(sym, def);
      }
#line 161
      if (tmp___3) {
#line 162
        return (0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/conf.c"
static int conf_sym(struct menu *menu ) 
{ 
  struct symbol *sym ;
  tristate oldval ;
  tristate newval ;
  char *tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  _Bool tmp___8 ;

  {
#line 168
  sym = menu->sym;
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 172
    tmp = gettext((menu->prompt)->text);
#line 172
    printf((char const   */* __restrict  */)"%*s%s ", indent - 1, "", tmp);
    }
#line 173
    if (sym->name) {
      {
#line 174
      printf((char const   */* __restrict  */)"(%s) ", sym->name);
      }
    }
    {
#line 175
    putchar('[');
#line 176
    oldval = sym_get_tristate_value(sym);
    }
    {
#line 178
    if ((unsigned int )oldval == 0U) {
#line 178
      goto case_0;
    }
#line 181
    if ((unsigned int )oldval == 1U) {
#line 181
      goto case_1;
    }
#line 184
    if ((unsigned int )oldval == 2U) {
#line 184
      goto case_2;
    }
#line 177
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 179
    putchar('N');
    }
#line 180
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 182
    putchar('M');
    }
#line 183
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 185
    putchar('Y');
    }
#line 186
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 188
    if ((unsigned int )oldval != 0U) {
      {
#line 188
      tmp___0 = sym_tristate_within_range(sym, (tristate )0);
      }
#line 188
      if (tmp___0) {
        {
#line 189
        printf((char const   */* __restrict  */)"/n");
        }
      }
    }
#line 190
    if ((unsigned int )oldval != 1U) {
      {
#line 190
      tmp___1 = sym_tristate_within_range(sym, (tristate )1);
      }
#line 190
      if (tmp___1) {
        {
#line 191
        printf((char const   */* __restrict  */)"/m");
        }
      }
    }
#line 192
    if ((unsigned int )oldval != 2U) {
      {
#line 192
      tmp___2 = sym_tristate_within_range(sym, (tristate )2);
      }
#line 192
      if (tmp___2) {
        {
#line 193
        printf((char const   */* __restrict  */)"/y");
        }
      }
    }
    {
#line 194
    tmp___3 = menu_has_help(menu);
    }
#line 194
    if (tmp___3) {
      {
#line 195
      printf((char const   */* __restrict  */)"/?");
      }
    }
    {
#line 196
    printf((char const   */* __restrict  */)"] ");
#line 197
    tmp___4 = sym_get_string_value(sym);
#line 197
    tmp___5 = conf_askvalue(sym, tmp___4);
    }
#line 197
    if (! tmp___5) {
#line 198
      return (0);
    }
    {
#line 199
    strip(line);
    }
    {
#line 203
    if ((int )line[0] == 78) {
#line 203
      goto case_78;
    }
#line 203
    if ((int )line[0] == 110) {
#line 203
      goto case_78;
    }
#line 209
    if ((int )line[0] == 77) {
#line 209
      goto case_77;
    }
#line 209
    if ((int )line[0] == 109) {
#line 209
      goto case_77;
    }
#line 215
    if ((int )line[0] == 89) {
#line 215
      goto case_89;
    }
#line 215
    if ((int )line[0] == 121) {
#line 215
      goto case_89;
    }
#line 220
    if ((int )line[0] == 0) {
#line 220
      goto case_0___0;
    }
#line 223
    if ((int )line[0] == 63) {
#line 223
      goto case_63;
    }
#line 225
    goto switch_default;
    case_78: /* CIL Label */ 
    case_110: /* CIL Label */ 
#line 204
    newval = (tristate )0;
#line 205
    if (! line[1]) {
#line 206
      goto switch_break___0;
    } else {
      {
#line 205
      tmp___6 = strcmp((char const   *)(& line[1]), "o");
      }
#line 205
      if (! tmp___6) {
#line 206
        goto switch_break___0;
      }
    }
#line 207
    goto while_continue;
    case_77: /* CIL Label */ 
    case_109: /* CIL Label */ 
#line 210
    newval = (tristate )1;
#line 211
    if (! line[1]) {
#line 212
      goto switch_break___0;
    }
#line 213
    goto while_continue;
    case_89: /* CIL Label */ 
    case_121: /* CIL Label */ 
#line 216
    newval = (tristate )2;
#line 217
    if (! line[1]) {
#line 218
      goto switch_break___0;
    } else {
      {
#line 217
      tmp___7 = strcmp((char const   *)(& line[1]), "es");
      }
#line 217
      if (! tmp___7) {
#line 218
        goto switch_break___0;
      }
    }
#line 219
    goto while_continue;
    case_0___0: /* CIL Label */ 
#line 221
    newval = oldval;
#line 222
    goto switch_break___0;
    case_63: /* CIL Label */ 
#line 224
    goto help;
    switch_default: /* CIL Label */ 
#line 226
    goto while_continue;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 228
    tmp___8 = sym_set_tristate_value(sym, newval);
    }
#line 228
    if (tmp___8) {
#line 229
      return (0);
    }
    help: 
    {
#line 231
    print_help(menu);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/conf.c"
static int conf_choice(struct menu *menu ) 
{ 
  struct symbol *sym ;
  struct symbol *def_sym ;
  struct menu *child ;
  _Bool is_new ;
  _Bool tmp ;
  int tmp___0 ;
  tristate tmp___1 ;
  tristate tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  _Bool tmp___5 ;
  int cnt ;
  int def ;
  char const   *tmp___6 ;
  char *tmp___7 ;
  _Bool tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  _Bool tmp___14 ;
  char *tmp___15 ;
  _Bool tmp___16 ;
  unsigned short const   **tmp___17 ;
  _Bool tmp___18 ;
  size_t tmp___19 ;

  {
  {
#line 241
  sym = menu->sym;
#line 242
  tmp = sym_has_value(sym);
  }
#line 242
  if (tmp) {
#line 242
    tmp___0 = 0;
  } else {
#line 242
    tmp___0 = 1;
  }
  {
#line 242
  is_new = (_Bool )tmp___0;
#line 243
  tmp___5 = sym_is_changable(sym);
  }
#line 243
  if (tmp___5) {
    {
#line 244
    conf_sym(menu);
#line 245
    sym_calc_value(sym);
#line 246
    tmp___1 = sym_get_tristate_value(sym);
    }
    {
#line 247
    if ((unsigned int )tmp___1 == 0U) {
#line 247
      goto case_0;
    }
#line 249
    if ((unsigned int )tmp___1 == 1U) {
#line 249
      goto case_1;
    }
#line 251
    if ((unsigned int )tmp___1 == 2U) {
#line 251
      goto case_2;
    }
#line 246
    goto switch_break;
    case_0: /* CIL Label */ 
#line 248
    return (1);
    case_1: /* CIL Label */ 
#line 250
    return (0);
    case_2: /* CIL Label */ 
#line 252
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 255
    tmp___2 = sym_get_tristate_value(sym);
    }
    {
#line 256
    if ((unsigned int )tmp___2 == 0U) {
#line 256
      goto case_0___0;
    }
#line 258
    if ((unsigned int )tmp___2 == 1U) {
#line 258
      goto case_1___0;
    }
#line 261
    if ((unsigned int )tmp___2 == 2U) {
#line 261
      goto case_2___0;
    }
#line 255
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
#line 257
    return (1);
    case_1___0: /* CIL Label */ 
    {
#line 259
    tmp___3 = menu_get_prompt(menu);
#line 259
    tmp___4 = gettext(tmp___3);
#line 259
    printf((char const   */* __restrict  */)"%*s%s\n", indent - 1, "", tmp___4);
    }
#line 260
    return (0);
    case_2___0: /* CIL Label */ 
#line 262
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  {
#line 266
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 269
    tmp___6 = menu_get_prompt(menu);
#line 269
    tmp___7 = gettext(tmp___6);
#line 269
    printf((char const   */* __restrict  */)"%*s%s\n", indent - 1, "", tmp___7);
#line 270
    def_sym = sym_get_choice_value(sym);
#line 271
    def = 0;
#line 271
    cnt = def;
#line 272
    line[0] = (char)0;
#line 273
    child = menu->list;
    }
    {
#line 273
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 273
      if (! child) {
#line 273
        goto while_break___0;
      }
      {
#line 274
      tmp___8 = menu_is_visible(child);
      }
#line 274
      if (! tmp___8) {
#line 275
        goto __Cont;
      }
#line 276
      if (! child->sym) {
        {
#line 277
        tmp___9 = menu_get_prompt(child);
#line 277
        tmp___10 = gettext(tmp___9);
#line 277
        printf((char const   */* __restrict  */)"%*c %s\n", indent, '*', tmp___10);
        }
#line 278
        goto __Cont;
      }
#line 280
      cnt ++;
#line 281
      if ((unsigned long )child->sym == (unsigned long )def_sym) {
        {
#line 282
        def = cnt;
#line 283
        printf((char const   */* __restrict  */)"%*c", indent, '>');
        }
      } else {
        {
#line 285
        printf((char const   */* __restrict  */)"%*c", indent, ' ');
        }
      }
      {
#line 286
      tmp___11 = menu_get_prompt(child);
#line 286
      tmp___12 = gettext(tmp___11);
#line 286
      printf((char const   */* __restrict  */)" %d. %s", cnt, tmp___12);
      }
#line 287
      if ((child->sym)->name) {
        {
#line 288
        printf((char const   */* __restrict  */)" (%s)", (child->sym)->name);
        }
      }
      {
#line 289
      tmp___14 = sym_has_value(child->sym);
      }
#line 289
      if (! tmp___14) {
        {
#line 290
        tmp___13 = gettext(" (NEW)");
#line 290
        printf((char const   */* __restrict  */)tmp___13);
        }
      }
      {
#line 291
      printf((char const   */* __restrict  */)"\n");
      }
      __Cont: /* CIL Label */ 
#line 273
      child = child->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 293
    tmp___15 = gettext("%*schoice");
#line 293
    printf((char const   */* __restrict  */)tmp___15, indent - 1, "");
    }
#line 294
    if (cnt == 1) {
      {
#line 295
      printf((char const   */* __restrict  */)"[1]: 1\n");
      }
#line 296
      goto conf_childs;
    }
    {
#line 298
    printf((char const   */* __restrict  */)"[1-%d", cnt);
#line 299
    tmp___16 = menu_has_help(menu);
    }
#line 299
    if (tmp___16) {
      {
#line 300
      printf((char const   */* __restrict  */)"?");
      }
    }
    {
#line 301
    printf((char const   */* __restrict  */)"]: ");
    }
    {
#line 304
    if ((unsigned int )input_mode == 1U) {
#line 304
      goto case_1___1;
    }
#line 304
    if ((unsigned int )input_mode == 2U) {
#line 304
      goto case_1___1;
    }
#line 312
    if ((unsigned int )input_mode == 0U) {
#line 312
      goto case_0___1;
    }
#line 327
    goto switch_default;
    case_1___1: /* CIL Label */ 
    case_2___1: /* CIL Label */ 
#line 305
    if (! is_new) {
      {
#line 306
      cnt = def;
#line 307
      printf((char const   */* __restrict  */)"%d\n", cnt);
      }
#line 308
      goto switch_break___1;
    }
    {
#line 310
    check_stdin();
    }
    case_0___1: /* CIL Label */ 
    {
#line 313
    fflush(stdout);
#line 314
    xfgets(line, 128, stdin);
#line 315
    strip(line);
    }
#line 316
    if ((int )line[0] == 63) {
      {
#line 317
      print_help(menu);
      }
#line 318
      goto while_continue;
    }
#line 320
    if (! line[0]) {
#line 321
      cnt = def;
    } else {
      {
#line 322
      tmp___17 = __ctype_b_loc();
      }
#line 322
      if ((int const   )*(*tmp___17 + (int )line[0]) & 2048) {
        {
#line 323
        cnt = atoi((char const   *)(line));
        }
      } else {
#line 325
        goto while_continue;
      }
    }
#line 326
    goto switch_break___1;
    switch_default: /* CIL Label */ 
#line 328
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
    conf_childs: 
#line 332
    child = menu->list;
    {
#line 332
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 332
      if (! child) {
#line 332
        goto while_break___1;
      }
#line 333
      if (! child->sym) {
#line 334
        goto __Cont___0;
      } else {
        {
#line 333
        tmp___18 = menu_is_visible(child);
        }
#line 333
        if (! tmp___18) {
#line 334
          goto __Cont___0;
        }
      }
#line 335
      cnt --;
#line 335
      if (! cnt) {
#line 336
        goto while_break___1;
      }
      __Cont___0: /* CIL Label */ 
#line 332
      child = child->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 338
    if (! child) {
#line 339
      goto while_continue;
    }
#line 340
    if (line[0]) {
      {
#line 340
      tmp___19 = strlen((char const   *)(line));
      }
#line 340
      if ((int )line[tmp___19 - 1UL] == 63) {
        {
#line 341
        print_help(child);
        }
#line 342
        goto while_continue;
      }
    }
    {
#line 344
    sym_set_choice_value(sym, child->sym);
#line 345
    child = child->list;
    }
    {
#line 345
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 345
      if (! child) {
#line 345
        goto while_break___2;
      }
      {
#line 346
      indent += 2;
#line 347
      conf(child);
#line 348
      indent -= 2;
#line 345
      child = child->next;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 350
    return (1);
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 354 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/conf.c"
static void conf(struct menu *menu ) 
{ 
  struct symbol *sym ;
  struct property *prop ;
  struct menu *child ;
  _Bool tmp ;
  char const   *prompt ;
  char *tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 360
  tmp = menu_is_visible(menu);
  }
#line 360
  if (! tmp) {
#line 361
    return;
  }
#line 363
  sym = menu->sym;
#line 364
  prop = menu->prompt;
#line 365
  if (prop) {
    {
#line 369
    if ((unsigned int )prop->type == 3U) {
#line 369
      goto case_3;
    }
#line 378
    if ((unsigned int )prop->type == 2U) {
#line 378
      goto case_2;
    }
#line 385
    goto switch_default;
    case_3: /* CIL Label */ 
#line 370
    if ((unsigned int )input_mode == 1U) {
#line 370
      goto _L;
    } else
#line 370
    if ((unsigned int )input_mode == 10U) {
#line 370
      goto _L;
    } else
#line 370
    if ((unsigned int )input_mode == 11U) {
      _L: /* CIL Label */ 
#line 370
      if ((unsigned long )rootEntry != (unsigned long )menu) {
        {
#line 374
        check_conf(menu);
        }
#line 375
        return;
      }
    }
    case_2: /* CIL Label */ 
    {
#line 379
    prompt = menu_get_prompt(menu);
    }
#line 380
    if (prompt) {
      {
#line 381
      tmp___0 = gettext(prompt);
#line 381
      printf((char const   */* __restrict  */)"%*c\n%*c %s\n%*c\n", indent, '*', indent,
             '*', tmp___0, indent, '*');
      }
    }
    switch_default: /* CIL Label */ ;
    switch_break: /* CIL Label */ ;
    }
  }
#line 390
  if (! sym) {
#line 391
    goto conf_childs;
  }
  {
#line 393
  tmp___1 = sym_is_choice(sym);
  }
#line 393
  if (tmp___1) {
    {
#line 394
    conf_choice(menu);
    }
#line 395
    if ((unsigned int )sym->curr.tri != 1U) {
#line 396
      return;
    }
#line 397
    goto conf_childs;
  }
  {
#line 403
  if ((unsigned int )sym->type == 5U) {
#line 403
    goto case_5;
  }
#line 403
  if ((unsigned int )sym->type == 4U) {
#line 403
    goto case_5;
  }
#line 403
  if ((unsigned int )sym->type == 3U) {
#line 403
    goto case_5;
  }
#line 406
  goto switch_default___0;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3___0: /* CIL Label */ 
  {
#line 404
  conf_string(menu);
  }
#line 405
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 407
  conf_sym(menu);
  }
#line 408
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  conf_childs: 
#line 412
  if (sym) {
#line 413
    indent += 2;
  }
#line 414
  child = menu->list;
  {
#line 414
  while (1) {
    while_continue: /* CIL Label */ ;
#line 414
    if (! child) {
#line 414
      goto while_break;
    }
    {
#line 415
    conf(child);
#line 414
    child = child->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 416
  if (sym) {
#line 417
    indent -= 2;
  }
#line 418
  return;
}
}
#line 420 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/conf.c"
static void check_conf(struct menu *menu ) 
{ 
  struct symbol *sym ;
  struct menu *child ;
  _Bool tmp ;
  char const   *tmp___0 ;
  _Bool tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  tristate tmp___6 ;
  _Bool tmp___7 ;

  {
  {
#line 425
  tmp = menu_is_visible(menu);
  }
#line 425
  if (! tmp) {
#line 426
    return;
  }
#line 428
  sym = menu->sym;
#line 429
  if (sym) {
    {
#line 429
    tmp___7 = sym_has_value(sym);
    }
#line 429
    if (! tmp___7) {
      {
#line 430
      tmp___4 = sym_is_changable(sym);
      }
#line 430
      if (tmp___4) {
#line 430
        goto _L;
      } else {
        {
#line 430
        tmp___5 = sym_is_choice(sym);
        }
#line 430
        if (tmp___5) {
          {
#line 430
          tmp___6 = sym_get_tristate_value(sym);
          }
#line 430
          if ((unsigned int )tmp___6 == 2U) {
            _L: /* CIL Label */ 
#line 432
            if ((unsigned int )input_mode == 10U) {
#line 433
              if (sym->name) {
                {
#line 433
                tmp___1 = sym_is_choice_value(sym);
                }
#line 433
                if (! tmp___1) {
                  {
#line 434
                  tmp___0 = CONFIG_prefix();
#line 434
                  printf((char const   */* __restrict  */)"%s%s\n", tmp___0, sym->name);
                  }
                }
              }
            } else
#line 436
            if ((unsigned int )input_mode != 11U) {
#line 437
              tmp___3 = conf_cnt;
#line 437
              conf_cnt ++;
#line 437
              if (! tmp___3) {
                {
#line 438
                tmp___2 = gettext("*\n* Restart config...\n*\n");
#line 438
                printf((char const   */* __restrict  */)tmp___2);
                }
              }
              {
#line 439
              rootEntry = menu_get_parent_menu(menu);
#line 440
              conf(rootEntry);
              }
            }
          }
        }
      }
    }
  }
#line 445
  child = menu->list;
  {
#line 445
  while (1) {
    while_continue: /* CIL Label */ ;
#line 445
    if (! child) {
#line 445
      goto while_break;
    }
    {
#line 446
    check_conf(child);
#line 445
    child = child->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 447
  return;
}
}
#line 449 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/conf.c"
static struct option long_opts[14]  = 
#line 449
  {      {"oldaskconfig", 0, (int *)((void *)0), 0}, 
        {"oldconfig", 0, (int *)((void *)0), 2}, 
        {"silentoldconfig", 0, (int *)((void *)0), 1}, 
        {"defconfig", 2, (int *)((void *)0), 8}, 
        {"savedefconfig", 1, (int *)((void *)0), 9}, 
        {"allnoconfig", 0, (int *)((void *)0), 3}, 
        {"allyesconfig", 0, (int *)((void *)0), 4}, 
        {"allmodconfig", 0, (int *)((void *)0), 5}, 
        {"alldefconfig", 0, (int *)((void *)0), 6}, 
        {"randconfig", 0, (int *)((void *)0), 7}, 
        {"listnewconfig", 0, (int *)((void *)0), 10}, 
        {"olddefconfig", 0, (int *)((void *)0), 11}, 
        {"oldnoconfig", 0, (int *)((void *)0), 11}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 471 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/conf.c"
static void conf_usage(char const   *progname ) 
{ 


  {
  {
#line 474
  printf((char const   */* __restrict  */)"Usage: %s [option] <kconfig-file>\n", progname);
#line 475
  printf((char const   */* __restrict  */)"[option] is _one_ of the following:\n");
#line 476
  printf((char const   */* __restrict  */)"  --listnewconfig         List new options\n");
#line 477
  printf((char const   */* __restrict  */)"  --oldaskconfig          Start a new configuration using a line-oriented program\n");
#line 478
  printf((char const   */* __restrict  */)"  --oldconfig             Update a configuration using a provided .config as base\n");
#line 479
  printf((char const   */* __restrict  */)"  --silentoldconfig       Same as oldconfig, but quietly, additionally update deps\n");
#line 480
  printf((char const   */* __restrict  */)"  --olddefconfig          Same as silentoldconfig but sets new symbols to their default value\n");
#line 481
  printf((char const   */* __restrict  */)"  --oldnoconfig           An alias of olddefconfig\n");
#line 482
  printf((char const   */* __restrict  */)"  --defconfig <file>      New config with default defined in <file>\n");
#line 483
  printf((char const   */* __restrict  */)"  --savedefconfig <file>  Save the minimal current configuration to <file>\n");
#line 484
  printf((char const   */* __restrict  */)"  --allnoconfig           New config where all options are answered with no\n");
#line 485
  printf((char const   */* __restrict  */)"  --allyesconfig          New config where all options are answered with yes\n");
#line 486
  printf((char const   */* __restrict  */)"  --allmodconfig          New config where all options are answered with mod\n");
#line 487
  printf((char const   */* __restrict  */)"  --alldefconfig          New config with all symbols set to default\n");
#line 488
  printf((char const   */* __restrict  */)"  --randconfig            New config with random answer to all options\n");
  }
#line 489
  return;
}
}
#line 714 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/conf.c"
static void xfgets(char *str , int size , FILE *in ) 
{ 
  char *tmp ;

  {
  {
#line 716
  tmp = fgets((char */* __restrict  */)str, size, (FILE */* __restrict  */)in);
  }
#line 716
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 717
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nError in reading or end of file.\n");
    }
  }
#line 718
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 127 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 435
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 180 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 377
extern int vprintf(char const   * __restrict  __format , __gnuc_va_list __arg ) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 390
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 826
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) clearerr)(FILE *__stream ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 209 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1), __leaf__)) strtoll)(char const   * __restrict  __nptr ,
                                                                                                    char ** __restrict  __endptr ,
                                                                                                    int __base ) ;
#line 374
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 765
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 285
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 315
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 70 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/list.h"
__inline static int list_empty(struct list_head  const  *head ) 
{ 


  {
#line 72
  return ((unsigned long )head->next == (unsigned long )head);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/list.h"
__inline static void __list_add(struct list_head *_new , struct list_head *prev ,
                                struct list_head *next ) 
{ 


  {
#line 85
  next->prev = _new;
#line 86
  _new->next = next;
#line 87
  _new->prev = prev;
#line 88
  prev->next = _new;
#line 89
  return;
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/list.h"
__inline static void list_add_tail(struct list_head *_new , struct list_head *head ) 
{ 


  {
  {
#line 101
  __list_add(_new, head->prev, head);
  }
#line 102
  return;
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.h"
struct file *file_list  ;
#line 193 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.h"
struct file *current_file  ;
#line 196
struct symbol symbol_yes ;
#line 196
struct symbol symbol_no ;
#line 196
struct symbol symbol_mod ;
#line 197 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.h"
struct symbol *modules_sym  ;
#line 198 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.h"
struct symbol *sym_defconfig_list  ;
#line 199
int cdebug ;
#line 200
struct expr *expr_alloc_symbol(struct symbol *sym ) ;
#line 201
struct expr *expr_alloc_one(enum expr_type type , struct expr *ce ) ;
#line 202
struct expr *expr_alloc_two(enum expr_type type , struct expr *e1 , struct expr *e2 ) ;
#line 203
struct expr *expr_alloc_comp(enum expr_type type , struct symbol *s1 , struct symbol *s2 ) ;
#line 204
struct expr *expr_alloc_and(struct expr *e1 , struct expr *e2 ) ;
#line 205
struct expr *expr_alloc_or(struct expr *e1 , struct expr *e2 ) ;
#line 206
struct expr *expr_copy(struct expr  const  *org ) ;
#line 207
void expr_free(struct expr *e ) ;
#line 208
int expr_eq(struct expr *e1 , struct expr *e2 ) ;
#line 209
void expr_eliminate_eq(struct expr **ep1 , struct expr **ep2 ) ;
#line 210
tristate expr_calc_value(struct expr *e ) ;
#line 211
struct expr *expr_eliminate_yn(struct expr *e ) ;
#line 212
struct expr *expr_trans_bool(struct expr *e ) ;
#line 213
struct expr *expr_eliminate_dups(struct expr *e ) ;
#line 214
struct expr *expr_transform(struct expr *e ) ;
#line 215
int expr_contains_symbol(struct expr *dep , struct symbol *sym ) ;
#line 216
_Bool expr_depends_symbol(struct expr *dep , struct symbol *sym ) ;
#line 217
struct expr *expr_extract_eq_and(struct expr **ep1 , struct expr **ep2 ) ;
#line 218
struct expr *expr_extract_eq_or(struct expr **ep1 , struct expr **ep2 ) ;
#line 219
void expr_extract_eq(enum expr_type type , struct expr **ep , struct expr **ep1 ,
                     struct expr **ep2 ) ;
#line 220
struct expr *expr_trans_compare(struct expr *e , enum expr_type type , struct symbol *sym ) ;
#line 221
struct expr *expr_simplify_unmet_dep(struct expr *e1 , struct expr *e2 ) ;
#line 223
void expr_fprint(struct expr *e , FILE *out ) ;
#line 225
void expr_gstr_print(struct expr *e , struct gstr *gs ) ;
#line 227 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.h"
__inline static int expr_is_yes(struct expr *e ) 
{ 
  int tmp ;

  {
#line 229
  if (! e) {
#line 229
    tmp = 1;
  } else
#line 229
  if ((unsigned int )e->type == 7U) {
#line 229
    if ((unsigned long )e->left.sym == (unsigned long )(& symbol_yes)) {
#line 229
      tmp = 1;
    } else {
#line 229
      tmp = 0;
    }
  } else {
#line 229
    tmp = 0;
  }
#line 229
  return (tmp);
}
}
#line 232 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.h"
__inline static int expr_is_no(struct expr *e ) 
{ 
  int tmp ;

  {
#line 234
  if (e) {
#line 234
    if ((unsigned int )e->type == 7U) {
#line 234
      if ((unsigned long )e->left.sym == (unsigned long )(& symbol_no)) {
#line 234
        tmp = 1;
      } else {
#line 234
        tmp = 0;
      }
    } else {
#line 234
      tmp = 0;
    }
  } else {
#line 234
    tmp = 0;
  }
#line 234
  return (tmp);
}
}
#line 11 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/lkc_proto.h"
void conf_set_changed_callback(void (*fn)(void) ) ;
#line 12
void conf_set_message_callback(void (*fn)(char const   *fmt , va_list ap ) ) ;
#line 15 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/lkc_proto.h"
struct menu rootmenu  ;
#line 17
_Bool menu_is_empty(struct menu *menu ) ;
#line 19
_Bool menu_has_prompt(struct menu *menu ) ;
#line 21
struct menu *menu_get_root_menu(struct menu *menu ) ;
#line 24
char const   *menu_get_help(struct menu *menu ) ;
#line 25
void get_symbol_str(struct gstr *r , struct symbol *sym , struct list_head *head ) ;
#line 27
struct gstr get_relations_str(struct symbol **sym_arr , struct list_head *head ) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/lkc_proto.h"
struct symbol *symbol_hash[9973]  ;
#line 34
struct symbol *sym_lookup(char const   *name , int flags ) ;
#line 35
struct symbol *sym_find(char const   *name ) ;
#line 36
char const   *sym_expand_string_value(char const   *in ) ;
#line 37
char const   *sym_escape_string_value(char const   *in ) ;
#line 38
struct symbol **sym_re_search(char const   *pattern ) ;
#line 39
char const   *sym_type_name(enum symbol_type type ) ;
#line 44
tristate sym_toggle_tristate_value(struct symbol *sym ) ;
#line 45
_Bool sym_string_valid(struct symbol *sym , char const   *str ) ;
#line 46
_Bool sym_string_within_range(struct symbol *sym , char const   *str ) ;
#line 49
struct property *sym_get_choice_prop(struct symbol *sym ) ;
#line 50
struct property *sym_get_default_prop(struct symbol *sym ) ;
#line 53
char const   *prop_get_type_name(enum prop_type type ) ;
#line 56
int expr_compare_type(enum expr_type t1 , enum expr_type t2 ) ;
#line 57
void expr_print(struct expr *e , void (*fn)(void * , struct symbol * , char const   * ) ,
                void *data , int prevtoken ) ;
#line 73 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/lkc.h"
int zconfdebug  ;
#line 75
int zconfparse(void) ;
#line 76
void zconfdump(FILE *out ) ;
#line 77
void zconf_starthelp(void) ;
#line 78
FILE *zconf_fopen(char const   *name ) ;
#line 79
void zconf_initscan(char const   *name ) ;
#line 80
void zconf_nextfile(char const   *name ) ;
#line 81
int zconf_lineno(void) ;
#line 82
char const   *zconf_curname(void) ;
#line 86
char const   *conf_get_autoconfig_name(void) ;
#line 88
void sym_set_change_count(int count ) ;
#line 89
void sym_add_change_count(int count ) ;
#line 91
void set_all_choice_values(struct symbol *csym ) ;
#line 99 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/lkc.h"
__inline static void xfwrite(void const   *str , size_t len , size_t count , FILE *out ) 
{ 
  size_t tmp ;

  {
#line 102
  if (len == 0UL) {
#line 103
    return;
  }
  {
#line 105
  tmp = fwrite((void const   */* __restrict  */)str, len, count, (FILE */* __restrict  */)out);
  }
#line 105
  if (tmp != count) {
    {
#line 106
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error in writing or end of file.\n");
    }
  }
#line 107
  return;
}
}
#line 110
void _menu_init(void) ;
#line 111
void menu_warn(struct menu *menu , char const   *fmt  , ...) ;
#line 112
struct menu *menu_add_menu(void) ;
#line 113
void menu_end_menu(void) ;
#line 114
void menu_add_entry(struct symbol *sym ) ;
#line 115
void menu_end_entry(void) ;
#line 116
void menu_add_dep(struct expr *dep ) ;
#line 117
void menu_add_visibility(struct expr *expr ) ;
#line 118
struct property *menu_add_prop(enum prop_type type , char *prompt , struct expr *expr ,
                               struct expr *dep ) ;
#line 119
struct property *menu_add_prompt(enum prop_type type , char *prompt , struct expr *dep ) ;
#line 120
void menu_add_expr(enum prop_type type , struct expr *expr , struct expr *dep ) ;
#line 121
void menu_add_symbol(enum prop_type type , struct symbol *sym , struct expr *dep ) ;
#line 122
void menu_add_option(int token , char *arg ) ;
#line 123
void menu_finalize(struct menu *parent ) ;
#line 124
void menu_set_type(int type ) ;
#line 127
struct file *file_lookup(char const   *name ) ;
#line 128
int file_write_dep(char const   *name ) ;
#line 129
void *xmalloc(size_t size ) ;
#line 130
void *xcalloc(size_t nmemb , size_t size ) ;
#line 142
struct gstr str_assign(char const   *s ) ;
#line 144
void str_append(struct gstr *gs , char const   *s ) ;
#line 145
void str_printf(struct gstr *gs , char const   *fmt  , ...) ;
#line 149 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/lkc.h"
struct expr *sym_env_list  ;
#line 151
void sym_init(void) ;
#line 152
void sym_clear_all_valid(void) ;
#line 153
void sym_set_all_changed(void) ;
#line 154
void sym_set_changed(struct symbol *sym ) ;
#line 155
struct symbol *sym_choice_default(struct symbol *sym ) ;
#line 156
char const   *sym_get_string_default(struct symbol *sym ) ;
#line 157
struct symbol *sym_check_deps(struct symbol *sym ) ;
#line 158
struct property *prop_alloc(enum prop_type type , struct symbol *sym ) ;
#line 159
struct symbol *prop_get_symbol(struct property *prop ) ;
#line 160
struct property *sym_get_env_prop(struct symbol *sym ) ;
#line 188 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/lkc.h"
__inline static _Bool sym_is_optional(struct symbol *sym ) 
{ 
  int tmp ;

  {
#line 190
  if (sym->flags & 256) {
#line 190
    tmp = 1;
  } else {
#line 190
    tmp = 0;
  }
#line 190
  return ((_Bool )tmp);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/zconf.tab.c"
int cdebug  =    1;
#line 98
int zconflex(void) ;
#line 99
static void zconfprint(char const   *err  , ...) ;
#line 100
static void zconf_error(char const   *err  , ...) ;
#line 101
static void zconferror(char const   *err ) ;
#line 102
static _Bool zconf_endtoken(struct kconf_id  const  *id , int starttoken , int endtoken ) ;
#line 106 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/zconf.tab.c"
static struct menu *current_menu  ;
#line 106 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/zconf.tab.c"
static struct menu *current_entry  ;
#line 12 "scripts/kconfig/zconf.gperf"
__inline static struct kconf_id  const __attribute__((__gnu_inline__)) *kconf_id_lookup(char const   *str ,
                                                                                        unsigned int len ) ;
#line 25
__inline static unsigned int kconf_id_hash(char const   *str , unsigned int len ) ;
#line 25 "scripts/kconfig/zconf.gperf"
static unsigned char const   asso_values[256]  = 
#line 25
  {      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )5,      (unsigned char const   )25,      (unsigned char const   )25, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )5, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )5,      (unsigned char const   )0,      (unsigned char const   )10,      (unsigned char const   )5, 
        (unsigned char const   )45,      (unsigned char const   )73,      (unsigned char const   )20,      (unsigned char const   )20, 
        (unsigned char const   )0,      (unsigned char const   )15,      (unsigned char const   )15,      (unsigned char const   )73, 
        (unsigned char const   )20,      (unsigned char const   )5,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73};
#line 16 "scripts/kconfig/zconf.gperf"
__inline static unsigned int kconf_id_hash(char const   *str , unsigned int len ) 
{ 
  register int hval ;

  {
#line 54
  hval = (int )len;
  {
#line 62
  if (hval == 1) {
#line 62
    goto case_1;
  }
#line 62
  if (hval == 2) {
#line 62
    goto case_1;
  }
#line 58
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 59
  hval += (int )asso_values[(unsigned char )*(str + 2)];
  case_1: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 63
  hval += (int )asso_values[(unsigned char )*(str + 0)];
#line 64
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 66
  return ((unsigned int )(hval + (int )asso_values[(unsigned char )*(str + (len - 1U))]));
}
}
#line 105 "scripts/kconfig/zconf.gperf"
static struct kconf_id_strings_t  const  kconf_id_strings_contents  = 
#line 105
     {{(char )'i', (char )'f', (char )'\000'}, {(char )'i', (char )'n', (char )'t',
                                              (char )'\000'}, {(char )'e', (char )'n',
                                                               (char )'d', (char )'i',
                                                               (char )'f', (char )'\000'},
    {(char )'d', (char )'e', (char )'f', (char )'a', (char )'u', (char )'l', (char )'t',
     (char )'\000'}, {(char )'t', (char )'r', (char )'i', (char )'s', (char )'t',
                      (char )'a', (char )'t', (char )'e', (char )'\000'}, {(char )'e',
                                                                           (char )'n',
                                                                           (char )'d',
                                                                           (char )'c',
                                                                           (char )'h',
                                                                           (char )'o',
                                                                           (char )'i',
                                                                           (char )'c',
                                                                           (char )'e',
                                                                           (char )'\000'},
    {(char )'d', (char )'e', (char )'f', (char )'_', (char )'t', (char )'r', (char )'i',
     (char )'s', (char )'t', (char )'a', (char )'t', (char )'e', (char )'\000'}, {(char )'d',
                                                                                  (char )'e',
                                                                                  (char )'f',
                                                                                  (char )'_',
                                                                                  (char )'b',
                                                                                  (char )'o',
                                                                                  (char )'o',
                                                                                  (char )'l',
                                                                                  (char )'\000'},
    {(char )'d', (char )'e', (char )'f', (char )'c', (char )'o', (char )'n', (char )'f',
     (char )'i', (char )'g', (char )'_', (char )'l', (char )'i', (char )'s', (char )'t',
     (char )'\000'}, {(char )'o', (char )'n', (char )'\000'}, {(char )'o', (char )'p',
                                                               (char )'t', (char )'i',
                                                               (char )'o', (char )'n',
                                                               (char )'a', (char )'l',
                                                               (char )'\000'}, {(char )'o',
                                                                                (char )'p',
                                                                                (char )'t',
                                                                                (char )'i',
                                                                                (char )'o',
                                                                                (char )'n',
                                                                                (char )'\000'},
    {(char )'e', (char )'n', (char )'d', (char )'m', (char )'e', (char )'n', (char )'u',
     (char )'\000'}, {(char )'m', (char )'a', (char )'i', (char )'n', (char )'m',
                      (char )'e', (char )'n', (char )'u', (char )'\000'}, {(char )'m',
                                                                           (char )'e',
                                                                           (char )'n',
                                                                           (char )'u',
                                                                           (char )'c',
                                                                           (char )'o',
                                                                           (char )'n',
                                                                           (char )'f',
                                                                           (char )'i',
                                                                           (char )'g',
                                                                           (char )'\000'},
    {(char )'m', (char )'o', (char )'d', (char )'u', (char )'l', (char )'e', (char )'s',
     (char )'\000'}, {(char )'a', (char )'l', (char )'l', (char )'n', (char )'o',
                      (char )'c', (char )'o', (char )'n', (char )'f', (char )'i',
                      (char )'g', (char )'_', (char )'y', (char )'\000'}, {(char )'m',
                                                                           (char )'e',
                                                                           (char )'n',
                                                                           (char )'u',
                                                                           (char )'\000'},
    {(char )'s', (char )'e', (char )'l', (char )'e', (char )'c', (char )'t', (char )'\000'},
    {(char )'c', (char )'o', (char )'m', (char )'m', (char )'e', (char )'n', (char )'t',
     (char )'\000'}, {(char )'e', (char )'n', (char )'v', (char )'\000'}, {(char )'r',
                                                                           (char )'a',
                                                                           (char )'n',
                                                                           (char )'g',
                                                                           (char )'e',
                                                                           (char )'\000'},
    {(char )'c', (char )'h', (char )'o', (char )'i', (char )'c', (char )'e', (char )'\000'},
    {(char )'b', (char )'o', (char )'o', (char )'l', (char )'\000'}, {(char )'s',
                                                                      (char )'o',
                                                                      (char )'u',
                                                                      (char )'r',
                                                                      (char )'c',
                                                                      (char )'e',
                                                                      (char )'\000'},
    {(char )'v', (char )'i', (char )'s', (char )'i', (char )'b', (char )'l', (char )'e',
     (char )'\000'}, {(char )'h', (char )'e', (char )'x', (char )'\000'}, {(char )'c',
                                                                           (char )'o',
                                                                           (char )'n',
                                                                           (char )'f',
                                                                           (char )'i',
                                                                           (char )'g',
                                                                           (char )'\000'},
    {(char )'b', (char )'o', (char )'o', (char )'l', (char )'e', (char )'a', (char )'n',
     (char )'\000'}, {(char )'s', (char )'t', (char )'r', (char )'i', (char )'n',
                      (char )'g', (char )'\000'}, {(char )'h', (char )'e', (char )'l',
                                                   (char )'p', (char )'\000'}, {(char )'p',
                                                                                (char )'r',
                                                                                (char )'o',
                                                                                (char )'m',
                                                                                (char )'p',
                                                                                (char )'t',
                                                                                (char )'\000'},
    {(char )'d', (char )'e', (char )'p', (char )'e', (char )'n', (char )'d', (char )'s',
     (char )'\000'}};
#line 160 "scripts/kconfig/zconf.gperf"
static struct kconf_id  const  wordlist[73]  = 
#line 160
  {      {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str2)),
      269, 3U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str3)),
      274, 1U, (enum symbol_type )3}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str5)),
      270, 1U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str7)),
      275, 1U, (enum symbol_type )0}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str8)),
      274, 1U, (enum symbol_type )2}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str9)),
      263, 1U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str12)),
      275, 1U, (enum symbol_type )2}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str13)),
      275, 1U, (enum symbol_type )1}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str14)),
      2, 4U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str17)),
      280, 2U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str18)),
      272, 1U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str21)),
      279, 1U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str22)),
      260, 1U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str23)),
      258, 1U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str25)),
      266, 1U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str27)),
      1, 4U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str28)),
      4, 4U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str29)),
      259, 1U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str31)),
      276, 1U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str32)),
      264, 1U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str33)),
      3, 4U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str35)),
      277, 1U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str36)),
      262, 1U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str39)),
      274, 1U, (enum symbol_type )1}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str41)),
      261, 1U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str42)),
      278, 1U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str43)),
      274, 1U, (enum symbol_type )4}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str46)),
      265, 1U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str47)),
      274, 1U, (enum symbol_type )1}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str51)),
      274, 1U, (enum symbol_type )5}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str54)),
      267, 1U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str56)),
      273, 1U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str72)),
      271, 1U, 0U}};
#line 143 "scripts/kconfig/zconf.gperf"
__inline static struct kconf_id  const __attribute__((__gnu_inline__)) *kconf_id_lookup(char const   *str ,
                                                                                        unsigned int len ) 
{ 
  register int key ;
  unsigned int tmp ;
  register int o ;
  register char const   *s ;
  int tmp___0 ;

  {
#line 30
  if (len <= 14U) {
#line 30
    if (len >= 2U) {
      {
#line 32
      tmp = kconf_id_hash(str, len);
#line 32
      key = (int )tmp;
      }
#line 34
      if (key <= 72) {
#line 34
        if (key >= 0) {
#line 36
          o = (int )wordlist[key].name;
#line 37
          if (o >= 0) {
#line 39
            s = (char const   *)(& kconf_id_strings_contents) + o;
#line 41
            if ((int const   )*str == (int const   )*s) {
              {
#line 41
              tmp___0 = strncmp(str + 1, s + 1, (size_t )(len - 1U));
              }
#line 41
              if (! tmp___0) {
#line 41
                if ((int const   )*(s + len) == 0) {
#line 42
                  return ((struct kconf_id  const __attribute__((__gnu_inline__)) *)(& wordlist[key]));
                }
              }
            }
          }
        }
      }
    }
  }
#line 46
  return ((struct kconf_id  const __attribute__((__gnu_inline__)) *)0);
}
}
#line 439 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/zconf.tab.c"
static yytype_uint8 const   yytranslate[291]  = 
#line 439 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/zconf.tab.c"
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )35};
#line 476 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/zconf.tab.c"
static yytype_uint16 const   yyprhs[119]  = 
#line 476
  {      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )3,      (yytype_uint16 const   )6, 
        (yytype_uint16 const   )8,      (yytype_uint16 const   )11,      (yytype_uint16 const   )13,      (yytype_uint16 const   )14, 
        (yytype_uint16 const   )17,      (yytype_uint16 const   )20,      (yytype_uint16 const   )23,      (yytype_uint16 const   )26, 
        (yytype_uint16 const   )31,      (yytype_uint16 const   )36,      (yytype_uint16 const   )40,      (yytype_uint16 const   )42, 
        (yytype_uint16 const   )44,      (yytype_uint16 const   )46,      (yytype_uint16 const   )48,      (yytype_uint16 const   )50, 
        (yytype_uint16 const   )52,      (yytype_uint16 const   )54,      (yytype_uint16 const   )56,      (yytype_uint16 const   )58, 
        (yytype_uint16 const   )60,      (yytype_uint16 const   )62,      (yytype_uint16 const   )64,      (yytype_uint16 const   )66, 
        (yytype_uint16 const   )68,      (yytype_uint16 const   )72,      (yytype_uint16 const   )75,      (yytype_uint16 const   )79, 
        (yytype_uint16 const   )82,      (yytype_uint16 const   )86,      (yytype_uint16 const   )89,      (yytype_uint16 const   )90, 
        (yytype_uint16 const   )93,      (yytype_uint16 const   )96,      (yytype_uint16 const   )99,      (yytype_uint16 const   )102, 
        (yytype_uint16 const   )105,      (yytype_uint16 const   )108,      (yytype_uint16 const   )112,      (yytype_uint16 const   )117, 
        (yytype_uint16 const   )122,      (yytype_uint16 const   )127,      (yytype_uint16 const   )133,      (yytype_uint16 const   )137, 
        (yytype_uint16 const   )138,      (yytype_uint16 const   )142,      (yytype_uint16 const   )143,      (yytype_uint16 const   )146, 
        (yytype_uint16 const   )150,      (yytype_uint16 const   )153,      (yytype_uint16 const   )155,      (yytype_uint16 const   )159, 
        (yytype_uint16 const   )160,      (yytype_uint16 const   )163,      (yytype_uint16 const   )166,      (yytype_uint16 const   )169, 
        (yytype_uint16 const   )172,      (yytype_uint16 const   )175,      (yytype_uint16 const   )180,      (yytype_uint16 const   )184, 
        (yytype_uint16 const   )187,      (yytype_uint16 const   )192,      (yytype_uint16 const   )193,      (yytype_uint16 const   )196, 
        (yytype_uint16 const   )200,      (yytype_uint16 const   )202,      (yytype_uint16 const   )206,      (yytype_uint16 const   )207, 
        (yytype_uint16 const   )210,      (yytype_uint16 const   )213,      (yytype_uint16 const   )216,      (yytype_uint16 const   )220, 
        (yytype_uint16 const   )224,      (yytype_uint16 const   )228,      (yytype_uint16 const   )230,      (yytype_uint16 const   )234, 
        (yytype_uint16 const   )235,      (yytype_uint16 const   )238,      (yytype_uint16 const   )241,      (yytype_uint16 const   )244, 
        (yytype_uint16 const   )248,      (yytype_uint16 const   )252,      (yytype_uint16 const   )255,      (yytype_uint16 const   )258, 
        (yytype_uint16 const   )261,      (yytype_uint16 const   )262,      (yytype_uint16 const   )265,      (yytype_uint16 const   )268, 
        (yytype_uint16 const   )271,      (yytype_uint16 const   )276,      (yytype_uint16 const   )277,      (yytype_uint16 const   )280, 
        (yytype_uint16 const   )283,      (yytype_uint16 const   )286,      (yytype_uint16 const   )287,      (yytype_uint16 const   )290, 
        (yytype_uint16 const   )292,      (yytype_uint16 const   )294,      (yytype_uint16 const   )297,      (yytype_uint16 const   )300, 
        (yytype_uint16 const   )303,      (yytype_uint16 const   )305,      (yytype_uint16 const   )308,      (yytype_uint16 const   )309, 
        (yytype_uint16 const   )312,      (yytype_uint16 const   )314,      (yytype_uint16 const   )318,      (yytype_uint16 const   )322, 
        (yytype_uint16 const   )326,      (yytype_uint16 const   )329,      (yytype_uint16 const   )333,      (yytype_uint16 const   )337, 
        (yytype_uint16 const   )339,      (yytype_uint16 const   )341,      (yytype_uint16 const   )342};
#line 493 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/zconf.tab.c"
static yytype_int8 const   yyrhs[344]  = 
#line 493
  {      (yytype_int8 const   )37,      (yytype_int8 const   )0,      (yytype_int8 const   )-1,      (yytype_int8 const   )81, 
        (yytype_int8 const   )38,      (yytype_int8 const   )-1,      (yytype_int8 const   )38,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )63,      (yytype_int8 const   )39,      (yytype_int8 const   )-1,      (yytype_int8 const   )39, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )39,      (yytype_int8 const   )41, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )39,      (yytype_int8 const   )55,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )39,      (yytype_int8 const   )67,      (yytype_int8 const   )-1,      (yytype_int8 const   )39, 
        (yytype_int8 const   )80,      (yytype_int8 const   )-1,      (yytype_int8 const   )39,      (yytype_int8 const   )26, 
        (yytype_int8 const   )1,      (yytype_int8 const   )31,      (yytype_int8 const   )-1,      (yytype_int8 const   )39, 
        (yytype_int8 const   )40,      (yytype_int8 const   )1,      (yytype_int8 const   )31,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )39,      (yytype_int8 const   )1,      (yytype_int8 const   )31,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )16,      (yytype_int8 const   )-1,      (yytype_int8 const   )18,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )19,      (yytype_int8 const   )-1,      (yytype_int8 const   )21,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )17,      (yytype_int8 const   )-1,      (yytype_int8 const   )22,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )20,      (yytype_int8 const   )-1,      (yytype_int8 const   )23,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )31,      (yytype_int8 const   )-1,      (yytype_int8 const   )61,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )71,      (yytype_int8 const   )-1,      (yytype_int8 const   )44,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )46,      (yytype_int8 const   )-1,      (yytype_int8 const   )69,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )26,      (yytype_int8 const   )1,      (yytype_int8 const   )31,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )1,      (yytype_int8 const   )31,      (yytype_int8 const   )-1,      (yytype_int8 const   )10, 
        (yytype_int8 const   )26,      (yytype_int8 const   )31,      (yytype_int8 const   )-1,      (yytype_int8 const   )43, 
        (yytype_int8 const   )47,      (yytype_int8 const   )-1,      (yytype_int8 const   )11,      (yytype_int8 const   )26, 
        (yytype_int8 const   )31,      (yytype_int8 const   )-1,      (yytype_int8 const   )45,      (yytype_int8 const   )47, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )47,      (yytype_int8 const   )48, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )47,      (yytype_int8 const   )49,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )47,      (yytype_int8 const   )75,      (yytype_int8 const   )-1,      (yytype_int8 const   )47, 
        (yytype_int8 const   )73,      (yytype_int8 const   )-1,      (yytype_int8 const   )47,      (yytype_int8 const   )42, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )47,      (yytype_int8 const   )31,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )19,      (yytype_int8 const   )78,      (yytype_int8 const   )31,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )18,      (yytype_int8 const   )79,      (yytype_int8 const   )82,      (yytype_int8 const   )31, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )20,      (yytype_int8 const   )83,      (yytype_int8 const   )82, 
        (yytype_int8 const   )31,      (yytype_int8 const   )-1,      (yytype_int8 const   )21,      (yytype_int8 const   )26, 
        (yytype_int8 const   )82,      (yytype_int8 const   )31,      (yytype_int8 const   )-1,      (yytype_int8 const   )22, 
        (yytype_int8 const   )84,      (yytype_int8 const   )84,      (yytype_int8 const   )82,      (yytype_int8 const   )31, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )24,      (yytype_int8 const   )50,      (yytype_int8 const   )31, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )50,      (yytype_int8 const   )26, 
        (yytype_int8 const   )51,      (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )34, 
        (yytype_int8 const   )79,      (yytype_int8 const   )-1,      (yytype_int8 const   )7,      (yytype_int8 const   )85, 
        (yytype_int8 const   )31,      (yytype_int8 const   )-1,      (yytype_int8 const   )52,      (yytype_int8 const   )56, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )80,      (yytype_int8 const   )-1,      (yytype_int8 const   )53, 
        (yytype_int8 const   )58,      (yytype_int8 const   )54,      (yytype_int8 const   )-1,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )56,      (yytype_int8 const   )57,      (yytype_int8 const   )-1,      (yytype_int8 const   )56, 
        (yytype_int8 const   )75,      (yytype_int8 const   )-1,      (yytype_int8 const   )56,      (yytype_int8 const   )73, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )56,      (yytype_int8 const   )31,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )56,      (yytype_int8 const   )42,      (yytype_int8 const   )-1,      (yytype_int8 const   )18, 
        (yytype_int8 const   )79,      (yytype_int8 const   )82,      (yytype_int8 const   )31,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )19,      (yytype_int8 const   )78,      (yytype_int8 const   )31,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )17,      (yytype_int8 const   )31,      (yytype_int8 const   )-1,      (yytype_int8 const   )20, 
        (yytype_int8 const   )26,      (yytype_int8 const   )82,      (yytype_int8 const   )31,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )58,      (yytype_int8 const   )41,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )14,      (yytype_int8 const   )83,      (yytype_int8 const   )81,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )80,      (yytype_int8 const   )-1,      (yytype_int8 const   )59,      (yytype_int8 const   )62, 
        (yytype_int8 const   )60,      (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )62, 
        (yytype_int8 const   )41,      (yytype_int8 const   )-1,      (yytype_int8 const   )62,      (yytype_int8 const   )67, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )62,      (yytype_int8 const   )55,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )3,      (yytype_int8 const   )79,      (yytype_int8 const   )81,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )4,      (yytype_int8 const   )79,      (yytype_int8 const   )31,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )64,      (yytype_int8 const   )76,      (yytype_int8 const   )74,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )80,      (yytype_int8 const   )-1,      (yytype_int8 const   )65,      (yytype_int8 const   )68, 
        (yytype_int8 const   )66,      (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )68, 
        (yytype_int8 const   )41,      (yytype_int8 const   )-1,      (yytype_int8 const   )68,      (yytype_int8 const   )67, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )68,      (yytype_int8 const   )55,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )6,      (yytype_int8 const   )79,      (yytype_int8 const   )31,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )9,      (yytype_int8 const   )79,      (yytype_int8 const   )31,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )70,      (yytype_int8 const   )74,      (yytype_int8 const   )-1,      (yytype_int8 const   )12, 
        (yytype_int8 const   )31,      (yytype_int8 const   )-1,      (yytype_int8 const   )72,      (yytype_int8 const   )13, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )74,      (yytype_int8 const   )75, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )74,      (yytype_int8 const   )31,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )74,      (yytype_int8 const   )42,      (yytype_int8 const   )-1,      (yytype_int8 const   )16, 
        (yytype_int8 const   )25,      (yytype_int8 const   )83,      (yytype_int8 const   )31,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )76,      (yytype_int8 const   )77,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )76,      (yytype_int8 const   )31,      (yytype_int8 const   )-1,      (yytype_int8 const   )23, 
        (yytype_int8 const   )82,      (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )79, 
        (yytype_int8 const   )82,      (yytype_int8 const   )-1,      (yytype_int8 const   )26,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )27,      (yytype_int8 const   )-1,      (yytype_int8 const   )5,      (yytype_int8 const   )31, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )8,      (yytype_int8 const   )31,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )15,      (yytype_int8 const   )31,      (yytype_int8 const   )-1,      (yytype_int8 const   )31, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )81,      (yytype_int8 const   )31,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )14,      (yytype_int8 const   )83,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )84,      (yytype_int8 const   )-1,      (yytype_int8 const   )84,      (yytype_int8 const   )34, 
        (yytype_int8 const   )84,      (yytype_int8 const   )-1,      (yytype_int8 const   )84,      (yytype_int8 const   )28, 
        (yytype_int8 const   )84,      (yytype_int8 const   )-1,      (yytype_int8 const   )30,      (yytype_int8 const   )83, 
        (yytype_int8 const   )29,      (yytype_int8 const   )-1,      (yytype_int8 const   )35,      (yytype_int8 const   )83, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )83,      (yytype_int8 const   )32,      (yytype_int8 const   )83, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )83,      (yytype_int8 const   )33,      (yytype_int8 const   )83, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )26,      (yytype_int8 const   )-1,      (yytype_int8 const   )27, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )26,      (yytype_int8 const   )-1};
#line 533 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/zconf.tab.c"
static yytype_uint16 const   yyrline[119]  = 
#line 533
  {      (yytype_uint16 const   )0,      (yytype_uint16 const   )103,      (yytype_uint16 const   )103,      (yytype_uint16 const   )103, 
        (yytype_uint16 const   )105,      (yytype_uint16 const   )105,      (yytype_uint16 const   )107,      (yytype_uint16 const   )109, 
        (yytype_uint16 const   )110,      (yytype_uint16 const   )111,      (yytype_uint16 const   )112,      (yytype_uint16 const   )113, 
        (yytype_uint16 const   )114,      (yytype_uint16 const   )118,      (yytype_uint16 const   )122,      (yytype_uint16 const   )122, 
        (yytype_uint16 const   )122,      (yytype_uint16 const   )122,      (yytype_uint16 const   )122,      (yytype_uint16 const   )122, 
        (yytype_uint16 const   )122,      (yytype_uint16 const   )122,      (yytype_uint16 const   )126,      (yytype_uint16 const   )127, 
        (yytype_uint16 const   )128,      (yytype_uint16 const   )129,      (yytype_uint16 const   )130,      (yytype_uint16 const   )131, 
        (yytype_uint16 const   )135,      (yytype_uint16 const   )136,      (yytype_uint16 const   )142,      (yytype_uint16 const   )150, 
        (yytype_uint16 const   )156,      (yytype_uint16 const   )164,      (yytype_uint16 const   )174,      (yytype_uint16 const   )176, 
        (yytype_uint16 const   )177,      (yytype_uint16 const   )178,      (yytype_uint16 const   )179,      (yytype_uint16 const   )180, 
        (yytype_uint16 const   )181,      (yytype_uint16 const   )184,      (yytype_uint16 const   )192,      (yytype_uint16 const   )198, 
        (yytype_uint16 const   )208,      (yytype_uint16 const   )214,      (yytype_uint16 const   )220,      (yytype_uint16 const   )223, 
        (yytype_uint16 const   )225,      (yytype_uint16 const   )236,      (yytype_uint16 const   )237,      (yytype_uint16 const   )242, 
        (yytype_uint16 const   )251,      (yytype_uint16 const   )256,      (yytype_uint16 const   )264,      (yytype_uint16 const   )267, 
        (yytype_uint16 const   )269,      (yytype_uint16 const   )270,      (yytype_uint16 const   )271,      (yytype_uint16 const   )272, 
        (yytype_uint16 const   )273,      (yytype_uint16 const   )276,      (yytype_uint16 const   )282,      (yytype_uint16 const   )293, 
        (yytype_uint16 const   )299,      (yytype_uint16 const   )309,      (yytype_uint16 const   )311,      (yytype_uint16 const   )316, 
        (yytype_uint16 const   )324,      (yytype_uint16 const   )332,      (yytype_uint16 const   )335,      (yytype_uint16 const   )337, 
        (yytype_uint16 const   )338,      (yytype_uint16 const   )339,      (yytype_uint16 const   )344,      (yytype_uint16 const   )351, 
        (yytype_uint16 const   )358,      (yytype_uint16 const   )363,      (yytype_uint16 const   )371,      (yytype_uint16 const   )374, 
        (yytype_uint16 const   )376,      (yytype_uint16 const   )377,      (yytype_uint16 const   )378,      (yytype_uint16 const   )381, 
        (yytype_uint16 const   )389,      (yytype_uint16 const   )396,      (yytype_uint16 const   )403,      (yytype_uint16 const   )409, 
        (yytype_uint16 const   )416,      (yytype_uint16 const   )418,      (yytype_uint16 const   )419,      (yytype_uint16 const   )420, 
        (yytype_uint16 const   )423,      (yytype_uint16 const   )431,      (yytype_uint16 const   )433,      (yytype_uint16 const   )434, 
        (yytype_uint16 const   )437,      (yytype_uint16 const   )444,      (yytype_uint16 const   )446,      (yytype_uint16 const   )451, 
        (yytype_uint16 const   )452,      (yytype_uint16 const   )455,      (yytype_uint16 const   )456,      (yytype_uint16 const   )457, 
        (yytype_uint16 const   )461,      (yytype_uint16 const   )462,      (yytype_uint16 const   )465,      (yytype_uint16 const   )466, 
        (yytype_uint16 const   )469,      (yytype_uint16 const   )470,      (yytype_uint16 const   )471,      (yytype_uint16 const   )472, 
        (yytype_uint16 const   )473,      (yytype_uint16 const   )474,      (yytype_uint16 const   )475,      (yytype_uint16 const   )478, 
        (yytype_uint16 const   )479,      (yytype_uint16 const   )482,      (yytype_uint16 const   )483};
#line 553 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/zconf.tab.c"
static char const   * const  yytname[87]  = 
#line 553
  {      (char const   */* const  */)"$end",      (char const   */* const  */)"error",      (char const   */* const  */)"$undefined",      (char const   */* const  */)"T_MAINMENU", 
        (char const   */* const  */)"T_MENU",      (char const   */* const  */)"T_ENDMENU",      (char const   */* const  */)"T_SOURCE",      (char const   */* const  */)"T_CHOICE", 
        (char const   */* const  */)"T_ENDCHOICE",      (char const   */* const  */)"T_COMMENT",      (char const   */* const  */)"T_CONFIG",      (char const   */* const  */)"T_MENUCONFIG", 
        (char const   */* const  */)"T_HELP",      (char const   */* const  */)"T_HELPTEXT",      (char const   */* const  */)"T_IF",      (char const   */* const  */)"T_ENDIF", 
        (char const   */* const  */)"T_DEPENDS",      (char const   */* const  */)"T_OPTIONAL",      (char const   */* const  */)"T_PROMPT",      (char const   */* const  */)"T_TYPE", 
        (char const   */* const  */)"T_DEFAULT",      (char const   */* const  */)"T_SELECT",      (char const   */* const  */)"T_RANGE",      (char const   */* const  */)"T_VISIBLE", 
        (char const   */* const  */)"T_OPTION",      (char const   */* const  */)"T_ON",      (char const   */* const  */)"T_WORD",      (char const   */* const  */)"T_WORD_QUOTE", 
        (char const   */* const  */)"T_UNEQUAL",      (char const   */* const  */)"T_CLOSE_PAREN",      (char const   */* const  */)"T_OPEN_PAREN",      (char const   */* const  */)"T_EOL", 
        (char const   */* const  */)"T_OR",      (char const   */* const  */)"T_AND",      (char const   */* const  */)"T_EQUAL",      (char const   */* const  */)"T_NOT", 
        (char const   */* const  */)"$accept",      (char const   */* const  */)"input",      (char const   */* const  */)"start",      (char const   */* const  */)"stmt_list", 
        (char const   */* const  */)"option_name",      (char const   */* const  */)"common_stmt",      (char const   */* const  */)"option_error",      (char const   */* const  */)"config_entry_start", 
        (char const   */* const  */)"config_stmt",      (char const   */* const  */)"menuconfig_entry_start",      (char const   */* const  */)"menuconfig_stmt",      (char const   */* const  */)"config_option_list", 
        (char const   */* const  */)"config_option",      (char const   */* const  */)"symbol_option",      (char const   */* const  */)"symbol_option_list",      (char const   */* const  */)"symbol_option_arg", 
        (char const   */* const  */)"choice",      (char const   */* const  */)"choice_entry",      (char const   */* const  */)"choice_end",      (char const   */* const  */)"choice_stmt", 
        (char const   */* const  */)"choice_option_list",      (char const   */* const  */)"choice_option",      (char const   */* const  */)"choice_block",      (char const   */* const  */)"if_entry", 
        (char const   */* const  */)"if_end",      (char const   */* const  */)"if_stmt",      (char const   */* const  */)"if_block",      (char const   */* const  */)"mainmenu_stmt", 
        (char const   */* const  */)"menu",      (char const   */* const  */)"menu_entry",      (char const   */* const  */)"menu_end",      (char const   */* const  */)"menu_stmt", 
        (char const   */* const  */)"menu_block",      (char const   */* const  */)"source_stmt",      (char const   */* const  */)"comment",      (char const   */* const  */)"comment_stmt", 
        (char const   */* const  */)"help_start",      (char const   */* const  */)"help",      (char const   */* const  */)"depends_list",      (char const   */* const  */)"depends", 
        (char const   */* const  */)"visibility_list",      (char const   */* const  */)"visible",      (char const   */* const  */)"prompt_stmt_opt",      (char const   */* const  */)"prompt", 
        (char const   */* const  */)"end",      (char const   */* const  */)"nl",      (char const   */* const  */)"if_expr",      (char const   */* const  */)"expr", 
        (char const   */* const  */)"symbol",      (char const   */* const  */)"word_opt",      (char const   */* const  */)0};
#line 588 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/zconf.tab.c"
static yytype_uint8 const   yyr1[119]  = 
#line 588
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )36,      (yytype_uint8 const   )37,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )38,      (yytype_uint8 const   )39,      (yytype_uint8 const   )39, 
        (yytype_uint8 const   )39,      (yytype_uint8 const   )39,      (yytype_uint8 const   )39,      (yytype_uint8 const   )39, 
        (yytype_uint8 const   )39,      (yytype_uint8 const   )39,      (yytype_uint8 const   )40,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )40,      (yytype_uint8 const   )40,      (yytype_uint8 const   )40,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )40,      (yytype_uint8 const   )40,      (yytype_uint8 const   )41,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )41,      (yytype_uint8 const   )41,      (yytype_uint8 const   )41,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )42,      (yytype_uint8 const   )43,      (yytype_uint8 const   )44, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )46,      (yytype_uint8 const   )47,      (yytype_uint8 const   )47, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )47,      (yytype_uint8 const   )47,      (yytype_uint8 const   )47, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )48,      (yytype_uint8 const   )48,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )48,      (yytype_uint8 const   )48,      (yytype_uint8 const   )49,      (yytype_uint8 const   )50, 
        (yytype_uint8 const   )50,      (yytype_uint8 const   )51,      (yytype_uint8 const   )51,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )53,      (yytype_uint8 const   )54,      (yytype_uint8 const   )55,      (yytype_uint8 const   )56, 
        (yytype_uint8 const   )56,      (yytype_uint8 const   )56,      (yytype_uint8 const   )56,      (yytype_uint8 const   )56, 
        (yytype_uint8 const   )56,      (yytype_uint8 const   )57,      (yytype_uint8 const   )57,      (yytype_uint8 const   )57, 
        (yytype_uint8 const   )57,      (yytype_uint8 const   )58,      (yytype_uint8 const   )58,      (yytype_uint8 const   )59, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )61,      (yytype_uint8 const   )62,      (yytype_uint8 const   )62, 
        (yytype_uint8 const   )62,      (yytype_uint8 const   )62,      (yytype_uint8 const   )63,      (yytype_uint8 const   )64, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )66,      (yytype_uint8 const   )67,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )68,      (yytype_uint8 const   )68,      (yytype_uint8 const   )69, 
        (yytype_uint8 const   )70,      (yytype_uint8 const   )71,      (yytype_uint8 const   )72,      (yytype_uint8 const   )73, 
        (yytype_uint8 const   )74,      (yytype_uint8 const   )74,      (yytype_uint8 const   )74,      (yytype_uint8 const   )74, 
        (yytype_uint8 const   )75,      (yytype_uint8 const   )76,      (yytype_uint8 const   )76,      (yytype_uint8 const   )76, 
        (yytype_uint8 const   )77,      (yytype_uint8 const   )78,      (yytype_uint8 const   )78,      (yytype_uint8 const   )79, 
        (yytype_uint8 const   )79,      (yytype_uint8 const   )80,      (yytype_uint8 const   )80,      (yytype_uint8 const   )80, 
        (yytype_uint8 const   )81,      (yytype_uint8 const   )81,      (yytype_uint8 const   )82,      (yytype_uint8 const   )82, 
        (yytype_uint8 const   )83,      (yytype_uint8 const   )83,      (yytype_uint8 const   )83,      (yytype_uint8 const   )83, 
        (yytype_uint8 const   )83,      (yytype_uint8 const   )83,      (yytype_uint8 const   )83,      (yytype_uint8 const   )84, 
        (yytype_uint8 const   )84,      (yytype_uint8 const   )85,      (yytype_uint8 const   )85};
#line 605 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/zconf.tab.c"
static yytype_uint8 const   yyr2[119]  = 
#line 605
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )5,      (yytype_uint8 const   )3,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )4,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1};
#line 624 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/zconf.tab.c"
static yytype_uint8 const   yydefact[191]  = 
#line 624
  {      (yytype_uint8 const   )6,      (yytype_uint8 const   )0,      (yytype_uint8 const   )104,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )6,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )99,      (yytype_uint8 const   )100,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )117,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )14, 
        (yytype_uint8 const   )18,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )19,      (yytype_uint8 const   )21,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )22,      (yytype_uint8 const   )0,      (yytype_uint8 const   )7,      (yytype_uint8 const   )34, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )34,      (yytype_uint8 const   )26,      (yytype_uint8 const   )55, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )8,      (yytype_uint8 const   )70,      (yytype_uint8 const   )23, 
        (yytype_uint8 const   )93,      (yytype_uint8 const   )79,      (yytype_uint8 const   )9,      (yytype_uint8 const   )27, 
        (yytype_uint8 const   )88,      (yytype_uint8 const   )24,      (yytype_uint8 const   )10,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )105,      (yytype_uint8 const   )2,      (yytype_uint8 const   )74,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )101,      (yytype_uint8 const   )0,      (yytype_uint8 const   )118, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )102,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )115,      (yytype_uint8 const   )116,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )108,      (yytype_uint8 const   )103, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )88, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )75,      (yytype_uint8 const   )83, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )84,      (yytype_uint8 const   )30,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )112,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )67,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )11, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )97,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )47,      (yytype_uint8 const   )0,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )39,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )37,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )97,      (yytype_uint8 const   )0,      (yytype_uint8 const   )59,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )56,      (yytype_uint8 const   )58,      (yytype_uint8 const   )57,      (yytype_uint8 const   )66, 
        (yytype_uint8 const   )54,      (yytype_uint8 const   )53,      (yytype_uint8 const   )71,      (yytype_uint8 const   )73, 
        (yytype_uint8 const   )69,      (yytype_uint8 const   )72,      (yytype_uint8 const   )68,      (yytype_uint8 const   )106, 
        (yytype_uint8 const   )95,      (yytype_uint8 const   )0,      (yytype_uint8 const   )94,      (yytype_uint8 const   )80, 
        (yytype_uint8 const   )82,      (yytype_uint8 const   )78,      (yytype_uint8 const   )81,      (yytype_uint8 const   )77, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )91,      (yytype_uint8 const   )89,      (yytype_uint8 const   )111, 
        (yytype_uint8 const   )113,      (yytype_uint8 const   )114,      (yytype_uint8 const   )110,      (yytype_uint8 const   )109, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )86,      (yytype_uint8 const   )0,      (yytype_uint8 const   )106, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )106,      (yytype_uint8 const   )106,      (yytype_uint8 const   )106, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )87, 
        (yytype_uint8 const   )63,      (yytype_uint8 const   )106,      (yytype_uint8 const   )0,      (yytype_uint8 const   )106, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )96,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )41,      (yytype_uint8 const   )98,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )106,      (yytype_uint8 const   )49,      (yytype_uint8 const   )46,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )62,      (yytype_uint8 const   )0,      (yytype_uint8 const   )107, 
        (yytype_uint8 const   )92,      (yytype_uint8 const   )42,      (yytype_uint8 const   )43,      (yytype_uint8 const   )44, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )48,      (yytype_uint8 const   )61, 
        (yytype_uint8 const   )64,      (yytype_uint8 const   )45,      (yytype_uint8 const   )50};
#line 649 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/zconf.tab.c"
static yytype_int16 const   yydefgoto[50]  = 
#line 649
  {      (yytype_int16 const   )-1,      (yytype_int16 const   )3,      (yytype_int16 const   )4,      (yytype_int16 const   )5, 
        (yytype_int16 const   )33,      (yytype_int16 const   )34,      (yytype_int16 const   )108,      (yytype_int16 const   )35, 
        (yytype_int16 const   )36,      (yytype_int16 const   )37,      (yytype_int16 const   )38,      (yytype_int16 const   )74, 
        (yytype_int16 const   )109,      (yytype_int16 const   )110,      (yytype_int16 const   )157,      (yytype_int16 const   )186, 
        (yytype_int16 const   )39,      (yytype_int16 const   )40,      (yytype_int16 const   )124,      (yytype_int16 const   )41, 
        (yytype_int16 const   )76,      (yytype_int16 const   )120,      (yytype_int16 const   )77,      (yytype_int16 const   )42, 
        (yytype_int16 const   )128,      (yytype_int16 const   )43,      (yytype_int16 const   )78,      (yytype_int16 const   )6, 
        (yytype_int16 const   )44,      (yytype_int16 const   )45,      (yytype_int16 const   )137,      (yytype_int16 const   )46, 
        (yytype_int16 const   )80,      (yytype_int16 const   )47,      (yytype_int16 const   )48,      (yytype_int16 const   )49, 
        (yytype_int16 const   )111,      (yytype_int16 const   )112,      (yytype_int16 const   )81,      (yytype_int16 const   )113, 
        (yytype_int16 const   )79,      (yytype_int16 const   )134,      (yytype_int16 const   )152,      (yytype_int16 const   )153, 
        (yytype_int16 const   )50,      (yytype_int16 const   )7,      (yytype_int16 const   )165,      (yytype_int16 const   )69, 
        (yytype_int16 const   )70,      (yytype_int16 const   )60};
#line 661 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/zconf.tab.c"
static yytype_int16 const   yypact[191]  = 
#line 661
  {      (yytype_int16 const   )4,      (yytype_int16 const   )42,      (yytype_int16 const   )-90,      (yytype_int16 const   )96, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )111,      (yytype_int16 const   )-90,      (yytype_int16 const   )15, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )75,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )82,      (yytype_int16 const   )42,      (yytype_int16 const   )104,      (yytype_int16 const   )42, 
        (yytype_int16 const   )110,      (yytype_int16 const   )107,      (yytype_int16 const   )42,      (yytype_int16 const   )115, 
        (yytype_int16 const   )125,      (yytype_int16 const   )-4,      (yytype_int16 const   )121,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )162, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )163,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )139, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )138,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )142,      (yytype_int16 const   )-90,      (yytype_int16 const   )143,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )152,      (yytype_int16 const   )-90,      (yytype_int16 const   )164,      (yytype_int16 const   )167, 
        (yytype_int16 const   )168,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-4, 
        (yytype_int16 const   )-4,      (yytype_int16 const   )77,      (yytype_int16 const   )-18,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )177,      (yytype_int16 const   )185,      (yytype_int16 const   )33,      (yytype_int16 const   )71, 
        (yytype_int16 const   )195,      (yytype_int16 const   )247,      (yytype_int16 const   )236,      (yytype_int16 const   )-2, 
        (yytype_int16 const   )236,      (yytype_int16 const   )171,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )41,      (yytype_int16 const   )-90,      (yytype_int16 const   )-4,      (yytype_int16 const   )-4, 
        (yytype_int16 const   )138,      (yytype_int16 const   )97,      (yytype_int16 const   )97,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )186,      (yytype_int16 const   )187,      (yytype_int16 const   )194, 
        (yytype_int16 const   )42,      (yytype_int16 const   )42,      (yytype_int16 const   )-4,      (yytype_int16 const   )196, 
        (yytype_int16 const   )97,      (yytype_int16 const   )-90,      (yytype_int16 const   )219,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )210, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )204,      (yytype_int16 const   )42, 
        (yytype_int16 const   )42,      (yytype_int16 const   )199,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )222, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )223,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )215,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-4,      (yytype_int16 const   )222, 
        (yytype_int16 const   )228,      (yytype_int16 const   )222,      (yytype_int16 const   )-5,      (yytype_int16 const   )222, 
        (yytype_int16 const   )97,      (yytype_int16 const   )35,      (yytype_int16 const   )229,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )222,      (yytype_int16 const   )232,      (yytype_int16 const   )222, 
        (yytype_int16 const   )-4,      (yytype_int16 const   )-90,      (yytype_int16 const   )135,      (yytype_int16 const   )233, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )234,      (yytype_int16 const   )235, 
        (yytype_int16 const   )222,      (yytype_int16 const   )240,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )237,      (yytype_int16 const   )-90,      (yytype_int16 const   )239,      (yytype_int16 const   )-13, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )244,      (yytype_int16 const   )42,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90};
#line 686 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/zconf.tab.c"
static yytype_int16 const   yypgoto[50]  = 
#line 686
  {      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )269,      (yytype_int16 const   )271, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )23,      (yytype_int16 const   )-70,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )243, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-48, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-20, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )206,      (yytype_int16 const   )205,      (yytype_int16 const   )-68, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )169,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )27,      (yytype_int16 const   )-7,      (yytype_int16 const   )118,      (yytype_int16 const   )-66, 
        (yytype_int16 const   )-89,      (yytype_int16 const   )-90};
#line 699 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/zconf.tab.c"
static yytype_int16 const   yytable[291]  = 
#line 699
  {      (yytype_int16 const   )10,      (yytype_int16 const   )88,      (yytype_int16 const   )89,      (yytype_int16 const   )54, 
        (yytype_int16 const   )146,      (yytype_int16 const   )147,      (yytype_int16 const   )119,      (yytype_int16 const   )1, 
        (yytype_int16 const   )122,      (yytype_int16 const   )164,      (yytype_int16 const   )93,      (yytype_int16 const   )141, 
        (yytype_int16 const   )56,      (yytype_int16 const   )142,      (yytype_int16 const   )58,      (yytype_int16 const   )156, 
        (yytype_int16 const   )94,      (yytype_int16 const   )62,      (yytype_int16 const   )1,      (yytype_int16 const   )90, 
        (yytype_int16 const   )91,      (yytype_int16 const   )131,      (yytype_int16 const   )65,      (yytype_int16 const   )66, 
        (yytype_int16 const   )144,      (yytype_int16 const   )145,      (yytype_int16 const   )67,      (yytype_int16 const   )90, 
        (yytype_int16 const   )91,      (yytype_int16 const   )132,      (yytype_int16 const   )127,      (yytype_int16 const   )68, 
        (yytype_int16 const   )136,      (yytype_int16 const   )-31,      (yytype_int16 const   )97,      (yytype_int16 const   )2, 
        (yytype_int16 const   )154,      (yytype_int16 const   )-31,      (yytype_int16 const   )-31,      (yytype_int16 const   )-31, 
        (yytype_int16 const   )-31,      (yytype_int16 const   )-31,      (yytype_int16 const   )-31,      (yytype_int16 const   )-31, 
        (yytype_int16 const   )-31,      (yytype_int16 const   )98,      (yytype_int16 const   )52,      (yytype_int16 const   )-31, 
        (yytype_int16 const   )-31,      (yytype_int16 const   )99,      (yytype_int16 const   )-31,      (yytype_int16 const   )100, 
        (yytype_int16 const   )101,      (yytype_int16 const   )102,      (yytype_int16 const   )103,      (yytype_int16 const   )104, 
        (yytype_int16 const   )-31,      (yytype_int16 const   )105,      (yytype_int16 const   )129,      (yytype_int16 const   )106, 
        (yytype_int16 const   )138,      (yytype_int16 const   )173,      (yytype_int16 const   )92,      (yytype_int16 const   )141, 
        (yytype_int16 const   )107,      (yytype_int16 const   )142,      (yytype_int16 const   )174,      (yytype_int16 const   )172, 
        (yytype_int16 const   )8,      (yytype_int16 const   )9,      (yytype_int16 const   )143,      (yytype_int16 const   )-33, 
        (yytype_int16 const   )97,      (yytype_int16 const   )90,      (yytype_int16 const   )91,      (yytype_int16 const   )-33, 
        (yytype_int16 const   )-33,      (yytype_int16 const   )-33,      (yytype_int16 const   )-33,      (yytype_int16 const   )-33, 
        (yytype_int16 const   )-33,      (yytype_int16 const   )-33,      (yytype_int16 const   )-33,      (yytype_int16 const   )98, 
        (yytype_int16 const   )166,      (yytype_int16 const   )-33,      (yytype_int16 const   )-33,      (yytype_int16 const   )99, 
        (yytype_int16 const   )-33,      (yytype_int16 const   )100,      (yytype_int16 const   )101,      (yytype_int16 const   )102, 
        (yytype_int16 const   )103,      (yytype_int16 const   )104,      (yytype_int16 const   )-33,      (yytype_int16 const   )105, 
        (yytype_int16 const   )11,      (yytype_int16 const   )106,      (yytype_int16 const   )179,      (yytype_int16 const   )151, 
        (yytype_int16 const   )123,      (yytype_int16 const   )126,      (yytype_int16 const   )107,      (yytype_int16 const   )135, 
        (yytype_int16 const   )125,      (yytype_int16 const   )130,      (yytype_int16 const   )2,      (yytype_int16 const   )139, 
        (yytype_int16 const   )2,      (yytype_int16 const   )90,      (yytype_int16 const   )91,      (yytype_int16 const   )-5, 
        (yytype_int16 const   )12,      (yytype_int16 const   )55,      (yytype_int16 const   )161,      (yytype_int16 const   )13, 
        (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17, 
        (yytype_int16 const   )18,      (yytype_int16 const   )19,      (yytype_int16 const   )20,      (yytype_int16 const   )65, 
        (yytype_int16 const   )66,      (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )23, 
        (yytype_int16 const   )24,      (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )27, 
        (yytype_int16 const   )28,      (yytype_int16 const   )29,      (yytype_int16 const   )30,      (yytype_int16 const   )57, 
        (yytype_int16 const   )59,      (yytype_int16 const   )31,      (yytype_int16 const   )61,      (yytype_int16 const   )-4, 
        (yytype_int16 const   )12,      (yytype_int16 const   )63,      (yytype_int16 const   )32,      (yytype_int16 const   )13, 
        (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17, 
        (yytype_int16 const   )18,      (yytype_int16 const   )19,      (yytype_int16 const   )20,      (yytype_int16 const   )64, 
        (yytype_int16 const   )71,      (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )23, 
        (yytype_int16 const   )24,      (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )27, 
        (yytype_int16 const   )28,      (yytype_int16 const   )29,      (yytype_int16 const   )30,      (yytype_int16 const   )72, 
        (yytype_int16 const   )73,      (yytype_int16 const   )31,      (yytype_int16 const   )180,      (yytype_int16 const   )90, 
        (yytype_int16 const   )91,      (yytype_int16 const   )52,      (yytype_int16 const   )32,      (yytype_int16 const   )-85, 
        (yytype_int16 const   )97,      (yytype_int16 const   )82,      (yytype_int16 const   )83,      (yytype_int16 const   )-85, 
        (yytype_int16 const   )-85,      (yytype_int16 const   )-85,      (yytype_int16 const   )-85,      (yytype_int16 const   )-85, 
        (yytype_int16 const   )-85,      (yytype_int16 const   )-85,      (yytype_int16 const   )-85,      (yytype_int16 const   )84, 
        (yytype_int16 const   )190,      (yytype_int16 const   )-85,      (yytype_int16 const   )-85,      (yytype_int16 const   )99, 
        (yytype_int16 const   )-85,      (yytype_int16 const   )-85,      (yytype_int16 const   )-85,      (yytype_int16 const   )-85, 
        (yytype_int16 const   )-85,      (yytype_int16 const   )-85,      (yytype_int16 const   )-85,      (yytype_int16 const   )85, 
        (yytype_int16 const   )97,      (yytype_int16 const   )106,      (yytype_int16 const   )86,      (yytype_int16 const   )87, 
        (yytype_int16 const   )-52,      (yytype_int16 const   )-52,      (yytype_int16 const   )140,      (yytype_int16 const   )-52, 
        (yytype_int16 const   )-52,      (yytype_int16 const   )-52,      (yytype_int16 const   )-52,      (yytype_int16 const   )98, 
        (yytype_int16 const   )95,      (yytype_int16 const   )-52,      (yytype_int16 const   )-52,      (yytype_int16 const   )99, 
        (yytype_int16 const   )114,      (yytype_int16 const   )115,      (yytype_int16 const   )116,      (yytype_int16 const   )117, 
        (yytype_int16 const   )96,      (yytype_int16 const   )148,      (yytype_int16 const   )149,      (yytype_int16 const   )150, 
        (yytype_int16 const   )158,      (yytype_int16 const   )106,      (yytype_int16 const   )155,      (yytype_int16 const   )159, 
        (yytype_int16 const   )97,      (yytype_int16 const   )163,      (yytype_int16 const   )118,      (yytype_int16 const   )-76, 
        (yytype_int16 const   )-76,      (yytype_int16 const   )-76,      (yytype_int16 const   )-76,      (yytype_int16 const   )-76, 
        (yytype_int16 const   )-76,      (yytype_int16 const   )-76,      (yytype_int16 const   )-76,      (yytype_int16 const   )160, 
        (yytype_int16 const   )164,      (yytype_int16 const   )-76,      (yytype_int16 const   )-76,      (yytype_int16 const   )99, 
        (yytype_int16 const   )13,      (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16, 
        (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )19,      (yytype_int16 const   )20, 
        (yytype_int16 const   )91,      (yytype_int16 const   )106,      (yytype_int16 const   )21,      (yytype_int16 const   )22, 
        (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )140,      (yytype_int16 const   )17, 
        (yytype_int16 const   )18,      (yytype_int16 const   )19,      (yytype_int16 const   )20,      (yytype_int16 const   )168, 
        (yytype_int16 const   )175,      (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )177, 
        (yytype_int16 const   )181,      (yytype_int16 const   )182,      (yytype_int16 const   )183,      (yytype_int16 const   )32, 
        (yytype_int16 const   )187,      (yytype_int16 const   )167,      (yytype_int16 const   )188,      (yytype_int16 const   )169, 
        (yytype_int16 const   )170,      (yytype_int16 const   )171,      (yytype_int16 const   )185,      (yytype_int16 const   )189, 
        (yytype_int16 const   )53,      (yytype_int16 const   )51,      (yytype_int16 const   )32,      (yytype_int16 const   )176, 
        (yytype_int16 const   )75,      (yytype_int16 const   )178,      (yytype_int16 const   )121,      (yytype_int16 const   )0, 
        (yytype_int16 const   )133,      (yytype_int16 const   )162,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )184};
#line 739 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/zconf.tab.c"
static yytype_int16 const   yycheck[291]  = 
#line 739
  {      (yytype_int16 const   )1,      (yytype_int16 const   )67,      (yytype_int16 const   )68,      (yytype_int16 const   )10, 
        (yytype_int16 const   )93,      (yytype_int16 const   )94,      (yytype_int16 const   )76,      (yytype_int16 const   )3, 
        (yytype_int16 const   )76,      (yytype_int16 const   )14,      (yytype_int16 const   )28,      (yytype_int16 const   )81, 
        (yytype_int16 const   )13,      (yytype_int16 const   )81,      (yytype_int16 const   )15,      (yytype_int16 const   )104, 
        (yytype_int16 const   )34,      (yytype_int16 const   )18,      (yytype_int16 const   )3,      (yytype_int16 const   )32, 
        (yytype_int16 const   )33,      (yytype_int16 const   )23,      (yytype_int16 const   )26,      (yytype_int16 const   )27, 
        (yytype_int16 const   )90,      (yytype_int16 const   )91,      (yytype_int16 const   )30,      (yytype_int16 const   )32, 
        (yytype_int16 const   )33,      (yytype_int16 const   )31,      (yytype_int16 const   )78,      (yytype_int16 const   )35, 
        (yytype_int16 const   )80,      (yytype_int16 const   )0,      (yytype_int16 const   )1,      (yytype_int16 const   )31, 
        (yytype_int16 const   )102,      (yytype_int16 const   )4,      (yytype_int16 const   )5,      (yytype_int16 const   )6, 
        (yytype_int16 const   )7,      (yytype_int16 const   )8,      (yytype_int16 const   )9,      (yytype_int16 const   )10, 
        (yytype_int16 const   )11,      (yytype_int16 const   )12,      (yytype_int16 const   )31,      (yytype_int16 const   )14, 
        (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )18, 
        (yytype_int16 const   )19,      (yytype_int16 const   )20,      (yytype_int16 const   )21,      (yytype_int16 const   )22, 
        (yytype_int16 const   )23,      (yytype_int16 const   )24,      (yytype_int16 const   )78,      (yytype_int16 const   )26, 
        (yytype_int16 const   )80,      (yytype_int16 const   )26,      (yytype_int16 const   )69,      (yytype_int16 const   )133, 
        (yytype_int16 const   )31,      (yytype_int16 const   )133,      (yytype_int16 const   )31,      (yytype_int16 const   )156, 
        (yytype_int16 const   )26,      (yytype_int16 const   )27,      (yytype_int16 const   )29,      (yytype_int16 const   )0, 
        (yytype_int16 const   )1,      (yytype_int16 const   )32,      (yytype_int16 const   )33,      (yytype_int16 const   )4, 
        (yytype_int16 const   )5,      (yytype_int16 const   )6,      (yytype_int16 const   )7,      (yytype_int16 const   )8, 
        (yytype_int16 const   )9,      (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )12, 
        (yytype_int16 const   )150,      (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16, 
        (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )19,      (yytype_int16 const   )20, 
        (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )23,      (yytype_int16 const   )24, 
        (yytype_int16 const   )0,      (yytype_int16 const   )26,      (yytype_int16 const   )164,      (yytype_int16 const   )100, 
        (yytype_int16 const   )77,      (yytype_int16 const   )78,      (yytype_int16 const   )31,      (yytype_int16 const   )80, 
        (yytype_int16 const   )77,      (yytype_int16 const   )78,      (yytype_int16 const   )31,      (yytype_int16 const   )80, 
        (yytype_int16 const   )31,      (yytype_int16 const   )32,      (yytype_int16 const   )33,      (yytype_int16 const   )0, 
        (yytype_int16 const   )1,      (yytype_int16 const   )31,      (yytype_int16 const   )115,      (yytype_int16 const   )4, 
        (yytype_int16 const   )5,      (yytype_int16 const   )6,      (yytype_int16 const   )7,      (yytype_int16 const   )8, 
        (yytype_int16 const   )9,      (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )26, 
        (yytype_int16 const   )27,      (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16, 
        (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )19,      (yytype_int16 const   )20, 
        (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )23,      (yytype_int16 const   )31, 
        (yytype_int16 const   )26,      (yytype_int16 const   )26,      (yytype_int16 const   )31,      (yytype_int16 const   )0, 
        (yytype_int16 const   )1,      (yytype_int16 const   )26,      (yytype_int16 const   )31,      (yytype_int16 const   )4, 
        (yytype_int16 const   )5,      (yytype_int16 const   )6,      (yytype_int16 const   )7,      (yytype_int16 const   )8, 
        (yytype_int16 const   )9,      (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )26, 
        (yytype_int16 const   )31,      (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16, 
        (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )19,      (yytype_int16 const   )20, 
        (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )23,      (yytype_int16 const   )1, 
        (yytype_int16 const   )1,      (yytype_int16 const   )26,      (yytype_int16 const   )31,      (yytype_int16 const   )32, 
        (yytype_int16 const   )33,      (yytype_int16 const   )31,      (yytype_int16 const   )31,      (yytype_int16 const   )0, 
        (yytype_int16 const   )1,      (yytype_int16 const   )31,      (yytype_int16 const   )31,      (yytype_int16 const   )4, 
        (yytype_int16 const   )5,      (yytype_int16 const   )6,      (yytype_int16 const   )7,      (yytype_int16 const   )8, 
        (yytype_int16 const   )9,      (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )31, 
        (yytype_int16 const   )185,      (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16, 
        (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )19,      (yytype_int16 const   )20, 
        (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )23,      (yytype_int16 const   )31, 
        (yytype_int16 const   )1,      (yytype_int16 const   )26,      (yytype_int16 const   )31,      (yytype_int16 const   )31, 
        (yytype_int16 const   )5,      (yytype_int16 const   )6,      (yytype_int16 const   )31,      (yytype_int16 const   )8, 
        (yytype_int16 const   )9,      (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )12, 
        (yytype_int16 const   )31,      (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16, 
        (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )19,      (yytype_int16 const   )20, 
        (yytype_int16 const   )31,      (yytype_int16 const   )31,      (yytype_int16 const   )31,      (yytype_int16 const   )25, 
        (yytype_int16 const   )1,      (yytype_int16 const   )26,      (yytype_int16 const   )26,      (yytype_int16 const   )13, 
        (yytype_int16 const   )1,      (yytype_int16 const   )26,      (yytype_int16 const   )31,      (yytype_int16 const   )4, 
        (yytype_int16 const   )5,      (yytype_int16 const   )6,      (yytype_int16 const   )7,      (yytype_int16 const   )8, 
        (yytype_int16 const   )9,      (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )31, 
        (yytype_int16 const   )14,      (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16, 
        (yytype_int16 const   )4,      (yytype_int16 const   )5,      (yytype_int16 const   )6,      (yytype_int16 const   )7, 
        (yytype_int16 const   )8,      (yytype_int16 const   )9,      (yytype_int16 const   )10,      (yytype_int16 const   )11, 
        (yytype_int16 const   )33,      (yytype_int16 const   )26,      (yytype_int16 const   )14,      (yytype_int16 const   )15, 
        (yytype_int16 const   )5,      (yytype_int16 const   )6,      (yytype_int16 const   )31,      (yytype_int16 const   )8, 
        (yytype_int16 const   )9,      (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )31, 
        (yytype_int16 const   )31,      (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )31, 
        (yytype_int16 const   )31,      (yytype_int16 const   )31,      (yytype_int16 const   )31,      (yytype_int16 const   )31, 
        (yytype_int16 const   )31,      (yytype_int16 const   )151,      (yytype_int16 const   )31,      (yytype_int16 const   )153, 
        (yytype_int16 const   )154,      (yytype_int16 const   )155,      (yytype_int16 const   )34,      (yytype_int16 const   )31, 
        (yytype_int16 const   )7,      (yytype_int16 const   )6,      (yytype_int16 const   )31,      (yytype_int16 const   )161, 
        (yytype_int16 const   )37,      (yytype_int16 const   )163,      (yytype_int16 const   )76,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )79,      (yytype_int16 const   )116,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )172};
#line 775 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/zconf.tab.c"
static yytype_uint8 const   yystos[191]  = 
#line 775
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )3,      (yytype_uint8 const   )31,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )39,      (yytype_uint8 const   )63,      (yytype_uint8 const   )81, 
        (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )79,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )4,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )10, 
        (yytype_uint8 const   )11,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )23,      (yytype_uint8 const   )26, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )40,      (yytype_uint8 const   )41,      (yytype_uint8 const   )43, 
        (yytype_uint8 const   )44,      (yytype_uint8 const   )45,      (yytype_uint8 const   )46,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )53,      (yytype_uint8 const   )55,      (yytype_uint8 const   )59,      (yytype_uint8 const   )61, 
        (yytype_uint8 const   )64,      (yytype_uint8 const   )65,      (yytype_uint8 const   )67,      (yytype_uint8 const   )69, 
        (yytype_uint8 const   )70,      (yytype_uint8 const   )71,      (yytype_uint8 const   )80,      (yytype_uint8 const   )39, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )38,      (yytype_uint8 const   )81,      (yytype_uint8 const   )31, 
        (yytype_uint8 const   )79,      (yytype_uint8 const   )31,      (yytype_uint8 const   )79,      (yytype_uint8 const   )26, 
        (yytype_uint8 const   )85,      (yytype_uint8 const   )31,      (yytype_uint8 const   )79,      (yytype_uint8 const   )26, 
        (yytype_uint8 const   )26,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )30, 
        (yytype_uint8 const   )35,      (yytype_uint8 const   )83,      (yytype_uint8 const   )84,      (yytype_uint8 const   )31, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )47,      (yytype_uint8 const   )47, 
        (yytype_uint8 const   )56,      (yytype_uint8 const   )58,      (yytype_uint8 const   )62,      (yytype_uint8 const   )76, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )74,      (yytype_uint8 const   )31,      (yytype_uint8 const   )31, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )31,      (yytype_uint8 const   )31,      (yytype_uint8 const   )31, 
        (yytype_uint8 const   )83,      (yytype_uint8 const   )83,      (yytype_uint8 const   )32,      (yytype_uint8 const   )33, 
        (yytype_uint8 const   )81,      (yytype_uint8 const   )28,      (yytype_uint8 const   )34,      (yytype_uint8 const   )31, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )1,      (yytype_uint8 const   )12,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )22,      (yytype_uint8 const   )24,      (yytype_uint8 const   )26,      (yytype_uint8 const   )31, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )48,      (yytype_uint8 const   )49,      (yytype_uint8 const   )72, 
        (yytype_uint8 const   )73,      (yytype_uint8 const   )75,      (yytype_uint8 const   )17,      (yytype_uint8 const   )18, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )31,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )57,      (yytype_uint8 const   )73,      (yytype_uint8 const   )75,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )54,      (yytype_uint8 const   )80,      (yytype_uint8 const   )41,      (yytype_uint8 const   )55, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )67,      (yytype_uint8 const   )80,      (yytype_uint8 const   )23, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )74,      (yytype_uint8 const   )77,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )55,      (yytype_uint8 const   )66,      (yytype_uint8 const   )67,      (yytype_uint8 const   )80, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )42,      (yytype_uint8 const   )75,      (yytype_uint8 const   )29, 
        (yytype_uint8 const   )83,      (yytype_uint8 const   )83,      (yytype_uint8 const   )84,      (yytype_uint8 const   )84, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )31,      (yytype_uint8 const   )25,      (yytype_uint8 const   )79, 
        (yytype_uint8 const   )78,      (yytype_uint8 const   )79,      (yytype_uint8 const   )83,      (yytype_uint8 const   )26, 
        (yytype_uint8 const   )84,      (yytype_uint8 const   )50,      (yytype_uint8 const   )1,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )79,      (yytype_uint8 const   )78,      (yytype_uint8 const   )26, 
        (yytype_uint8 const   )14,      (yytype_uint8 const   )82,      (yytype_uint8 const   )83,      (yytype_uint8 const   )82, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )82,      (yytype_uint8 const   )82,      (yytype_uint8 const   )82, 
        (yytype_uint8 const   )84,      (yytype_uint8 const   )26,      (yytype_uint8 const   )31,      (yytype_uint8 const   )31, 
        (yytype_uint8 const   )82,      (yytype_uint8 const   )31,      (yytype_uint8 const   )82,      (yytype_uint8 const   )83, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )31,      (yytype_uint8 const   )31,      (yytype_uint8 const   )31, 
        (yytype_uint8 const   )82,      (yytype_uint8 const   )34,      (yytype_uint8 const   )51,      (yytype_uint8 const   )31, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )31,      (yytype_uint8 const   )79};
#line 921 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/zconf.tab.c"
static void yy_symbol_value_print(FILE *yyoutput , int yytype , YYSTYPE const   * const  yyvaluep ) 
{ 


  {
#line 931
  if (! yyvaluep) {
#line 932
    return;
  }
  {
#line 941
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 942
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 944
  return;
}
}
#line 953 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/zconf.tab.c"
static void yy_symbol_print(FILE *yyoutput , int yytype , YYSTYPE const   * const  yyvaluep ) 
{ 


  {
#line 963
  if (yytype < 36) {
    {
#line 964
    fprintf((FILE */* __restrict  */)yyoutput, (char const   */* __restrict  */)"token %s (",
            yytname[yytype]);
    }
  } else {
    {
#line 966
    fprintf((FILE */* __restrict  */)yyoutput, (char const   */* __restrict  */)"nterm %s (",
            yytname[yytype]);
    }
  }
  {
#line 968
  yy_symbol_value_print(yyoutput, yytype, yyvaluep);
#line 969
  fprintf((FILE */* __restrict  */)yyoutput, (char const   */* __restrict  */)")");
  }
#line 970
  return;
}
}
#line 979 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/zconf.tab.c"
static void yy_stack_print(yytype_int16 *yybottom , yytype_int16 *yytop ) 
{ 
  int yybot ;

  {
  {
#line 988
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack now");
  }
  {
#line 989
  while (1) {
    while_continue: /* CIL Label */ ;
#line 989
    if (! ((unsigned long )yybottom <= (unsigned long )yytop)) {
#line 989
      goto while_break;
    }
    {
#line 991
    yybot = (int )*yybottom;
#line 992
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %d",
            yybot);
#line 989
    yybottom ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 994
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 995
  return;
}
}
#line 1010 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/zconf.tab.c"
static void yy_reduce_print(YYSTYPE *yyvsp , int yyrule ) 
{ 
  int yynrhs ;
  int yyi ;
  unsigned long yylno ;

  {
  {
#line 1019
  yynrhs = (int )yyr2[yyrule];
#line 1021
  yylno = (unsigned long )yyrline[yyrule];
#line 1022
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reducing stack by rule %d (line %lu):\n",
          yyrule - 1, yylno);
#line 1025
  yyi = 0;
  }
  {
#line 1025
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1025
    if (! (yyi < yynrhs)) {
#line 1025
      goto while_break;
    }
    {
#line 1027
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   $%d = ",
            yyi + 1);
#line 1028
    yy_symbol_print(stderr, (int )yyrhs[(int const   )yyprhs[yyrule] + (int const   )yyi],
                    (YYSTYPE const   */* const  */)(yyvsp + ((yyi + 1) - yynrhs)));
#line 1031
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 1025
    yyi ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1033
  return;
}
}
#line 1314 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/zconf.tab.c"
static void yydestruct(char const   *yymsg , int yytype , YYSTYPE *yyvaluep ) 
{ 


  {
#line 1326
  if (! yymsg) {
#line 1327
    yymsg = "Deleting";
  }
  {
#line 1328
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1328
    if (zconfdebug) {
      {
#line 1328
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              yymsg);
#line 1328
      yy_symbol_print(stderr, yytype, (YYSTYPE const   */* const  */)yyvaluep);
#line 1328
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 1328
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1332
  if (yytype == 53) {
#line 1332
    goto case_53;
  }
#line 1342
  if (yytype == 59) {
#line 1342
    goto case_59;
  }
#line 1352
  if (yytype == 65) {
#line 1352
    goto case_65;
  }
#line 1363
  goto switch_default;
  case_53: /* CIL Label */ 
  {
#line 1335
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: missing end statement for this entry\n",
          ((yyvaluep->menu)->file)->name, (yyvaluep->menu)->lineno);
  }
#line 1337
  if ((unsigned long )current_menu == (unsigned long )yyvaluep->menu) {
    {
#line 1338
    menu_end_menu();
    }
  }
#line 1341
  goto switch_break;
  case_59: /* CIL Label */ 
  {
#line 1345
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: missing end statement for this entry\n",
          ((yyvaluep->menu)->file)->name, (yyvaluep->menu)->lineno);
  }
#line 1347
  if ((unsigned long )current_menu == (unsigned long )yyvaluep->menu) {
    {
#line 1348
    menu_end_menu();
    }
  }
#line 1351
  goto switch_break;
  case_65: /* CIL Label */ 
  {
#line 1355
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: missing end statement for this entry\n",
          ((yyvaluep->menu)->file)->name, (yyvaluep->menu)->lineno);
  }
#line 1357
  if ((unsigned long )current_menu == (unsigned long )yyvaluep->menu) {
    {
#line 1358
    menu_end_menu();
    }
  }
#line 1361
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1364
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1366
  return;
}
}
#line 1386 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/zconf.tab.c"
int zconfchar  ;
#line 1389 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/zconf.tab.c"
YYSTYPE zconflval  ;
#line 1392 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/zconf.tab.c"
int zconfnerrs  ;
#line 1412 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/zconf.tab.c"
int zconfparse(void) 
{ 
  int yystate ;
  int yyerrstatus ;
  yytype_int16 yyssa[200] ;
  yytype_int16 *yyss ;
  yytype_int16 *yyssp ;
  YYSTYPE yyvsa[200] ;
  YYSTYPE *yyvs ;
  YYSTYPE *yyvsp ;
  unsigned long yystacksize ;
  int yyn ;
  int yyresult ;
  int yytoken ;
  YYSTYPE yyval ;
  int yylen ;
  unsigned long yysize ;
  yytype_int16 *yyss1 ;
  union yyalloc *yyptr ;
  void *tmp ;
  unsigned long yynewbytes ;
  unsigned long yynewbytes___0 ;
  struct symbol *sym ;
  struct symbol *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  struct symbol *sym___0 ;
  struct symbol *tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  char const   *tmp___13 ;
  int tmp___14 ;
  char const   *tmp___15 ;
  struct symbol *tmp___16 ;
  int tmp___17 ;
  char const   *tmp___18 ;
  struct expr *tmp___19 ;
  int tmp___20 ;
  char const   *tmp___21 ;
  struct kconf_id  const  *id ;
  size_t tmp___22 ;
  struct kconf_id  const __attribute__((__gnu_inline__)) *tmp___23 ;
  struct symbol *sym___1 ;
  struct symbol *tmp___24 ;
  int tmp___25 ;
  char const   *tmp___26 ;
  int tmp___27 ;
  char const   *tmp___28 ;
  _Bool tmp___29 ;
  int tmp___30 ;
  char const   *tmp___31 ;
  int tmp___32 ;
  char const   *tmp___33 ;
  int tmp___34 ;
  char const   *tmp___35 ;
  struct symbol *tmp___36 ;
  int tmp___37 ;
  char const   *tmp___38 ;
  int tmp___39 ;
  char const   *tmp___40 ;
  int tmp___41 ;
  char const   *tmp___42 ;
  _Bool tmp___43 ;
  int tmp___44 ;
  char const   *tmp___45 ;
  int tmp___46 ;
  char const   *tmp___47 ;
  _Bool tmp___48 ;
  int tmp___49 ;
  char const   *tmp___50 ;
  int tmp___51 ;
  char const   *tmp___52 ;
  int tmp___53 ;
  char const   *tmp___54 ;
  int tmp___55 ;
  char const   *tmp___56 ;
  int tmp___57 ;

  {
#line 1463
  yylen = 0;
#line 1465
  yytoken = 0;
#line 1466
  yyss = yyssa;
#line 1467
  yyvs = yyvsa;
#line 1468
  yystacksize = 200UL;
  {
#line 1470
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1470
    if (zconfdebug) {
      {
#line 1470
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Starting parse\n");
      }
    }
#line 1470
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1472
  yystate = 0;
#line 1473
  yyerrstatus = 0;
#line 1474
  zconfnerrs = 0;
#line 1475
  zconfchar = -2;
#line 1481
  yyssp = yyss;
#line 1482
  yyvsp = yyvs;
#line 1484
  goto yysetstate;
  yynewstate: 
#line 1492
  yyssp ++;
  yysetstate: 
#line 1495
  *yyssp = (yytype_int16 )yystate;
#line 1497
  if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1500
    yysize = (unsigned long )((yyssp - yyss) + 1L);
#line 1527
    if (10000UL <= yystacksize) {
#line 1528
      goto yyexhaustedlab;
    }
#line 1529
    yystacksize *= 2UL;
#line 1530
    if (10000UL < yystacksize) {
#line 1531
      yystacksize = 10000UL;
    }
    {
#line 1534
    yyss1 = yyss;
#line 1535
    tmp = malloc(yystacksize * (sizeof(yytype_int16 ) + sizeof(YYSTYPE )) + (sizeof(union yyalloc ) - 1UL));
#line 1535
    yyptr = (union yyalloc *)tmp;
    }
#line 1537
    if (! yyptr) {
#line 1538
      goto yyexhaustedlab;
    }
    {
#line 1539
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1539
      __builtin_memcpy((void *)(& yyptr->yyss_alloc), (void const   *)yyss, yysize * sizeof(*yyss));
#line 1539
      yyss = & yyptr->yyss_alloc;
#line 1539
      yynewbytes = yystacksize * sizeof(*yyss) + (sizeof(union yyalloc ) - 1UL);
#line 1539
      yyptr += yynewbytes / sizeof(*yyptr);
      }
#line 1539
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1540
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1540
      __builtin_memcpy((void *)(& yyptr->yyvs_alloc), (void const   *)yyvs, yysize * sizeof(*yyvs));
#line 1540
      yyvs = & yyptr->yyvs_alloc;
#line 1540
      yynewbytes___0 = yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc ) - 1UL);
#line 1540
      yyptr += yynewbytes___0 / sizeof(*yyptr);
      }
#line 1540
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1542
    if ((unsigned long )yyss1 != (unsigned long )(yyssa)) {
      {
#line 1543
      free((void *)yyss1);
      }
    }
#line 1548
    yyssp = (yyss + yysize) - 1;
#line 1549
    yyvsp = (yyvs + yysize) - 1;
    {
#line 1551
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1551
      if (zconfdebug) {
        {
#line 1551
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack size increased to %lu\n",
                yystacksize);
        }
      }
#line 1551
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1554
    if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1555
      goto yyabortlab;
    }
  }
  {
#line 1558
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1558
    if (zconfdebug) {
      {
#line 1558
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Entering state %d\n",
              yystate);
      }
    }
#line 1558
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1560
  if (yystate == 11) {
#line 1561
    goto yyacceptlab;
  }
#line 1563
  goto yybackup;
  yybackup: 
#line 1574
  yyn = (int )yypact[yystate];
#line 1575
  if (yyn == -90) {
#line 1576
    goto yydefault;
  }
#line 1581
  if (zconfchar == -2) {
    {
#line 1583
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1583
      if (zconfdebug) {
        {
#line 1583
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reading a token: ");
        }
      }
#line 1583
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 1584
    zconfchar = zconflex();
    }
  }
#line 1587
  if (zconfchar <= 0) {
#line 1589
    yytoken = 0;
#line 1589
    zconfchar = yytoken;
    {
#line 1590
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1590
      if (zconfdebug) {
        {
#line 1590
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Now at end of input.\n");
        }
      }
#line 1590
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  } else {
#line 1594
    if ((unsigned int )zconfchar <= 290U) {
#line 1594
      yytoken = (int )yytranslate[zconfchar];
    } else {
#line 1594
      yytoken = 2;
    }
    {
#line 1595
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1595
      if (zconfdebug) {
        {
#line 1595
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
                "Next token is");
#line 1595
        yy_symbol_print(stderr, yytoken, (YYSTYPE const   */* const  */)(& zconflval));
#line 1595
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
        }
      }
#line 1595
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 1600
  yyn += yytoken;
#line 1601
  if (yyn < 0) {
#line 1602
    goto yydefault;
  } else
#line 1601
  if (290 < yyn) {
#line 1602
    goto yydefault;
  } else
#line 1601
  if ((int const   )yycheck[yyn] != (int const   )yytoken) {
#line 1602
    goto yydefault;
  }
#line 1603
  yyn = (int )yytable[yyn];
#line 1604
  if (yyn <= 0) {
#line 1608
    yyn = - yyn;
#line 1609
    goto yyreduce;
  }
#line 1614
  if (yyerrstatus) {
#line 1615
    yyerrstatus --;
  }
  {
#line 1618
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 1618
    if (zconfdebug) {
      {
#line 1618
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              "Shifting");
#line 1618
      yy_symbol_print(stderr, yytoken, (YYSTYPE const   */* const  */)(& zconflval));
#line 1618
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 1618
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 1621
  zconfchar = -2;
#line 1623
  yystate = yyn;
#line 1624
  yyvsp ++;
#line 1624
  *yyvsp = zconflval;
#line 1626
  goto yynewstate;
  yydefault: 
#line 1633
  yyn = (int )yydefact[yystate];
#line 1634
  if (yyn == 0) {
#line 1635
    goto yyerrlab;
  }
#line 1636
  goto yyreduce;
  yyreduce: 
#line 1644
  yylen = (int )yyr2[yyn];
#line 1654
  yyval = *(yyvsp + (1 - yylen));
  {
#line 1657
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 1657
    if (zconfdebug) {
      {
#line 1657
      yy_reduce_print(yyvsp, yyn);
      }
    }
#line 1657
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 1660
  if (yyn == 10) {
#line 1660
    goto case_10;
  }
#line 1665
  if (yyn == 11) {
#line 1665
    goto case_11;
  }
#line 1670
  if (yyn == 12) {
#line 1670
    goto case_12;
  }
#line 1677
  if (yyn == 13) {
#line 1677
    goto case_13;
  }
#line 1682
  if (yyn == 28) {
#line 1682
    goto case_28;
  }
#line 1687
  if (yyn == 29) {
#line 1687
    goto case_29;
  }
#line 1692
  if (yyn == 30) {
#line 1692
    goto case_30;
  }
#line 1702
  if (yyn == 31) {
#line 1702
    goto case_31;
  }
#line 1710
  if (yyn == 32) {
#line 1710
    goto case_32;
  }
#line 1720
  if (yyn == 33) {
#line 1720
    goto case_33;
  }
#line 1732
  if (yyn == 41) {
#line 1732
    goto case_41;
  }
#line 1742
  if (yyn == 42) {
#line 1742
    goto case_42;
  }
#line 1750
  if (yyn == 43) {
#line 1750
    goto case_43;
  }
#line 1762
  if (yyn == 44) {
#line 1762
    goto case_44;
  }
#line 1770
  if (yyn == 45) {
#line 1770
    goto case_45;
  }
#line 1778
  if (yyn == 48) {
#line 1778
    goto case_48;
  }
#line 1790
  if (yyn == 49) {
#line 1790
    goto case_49;
  }
#line 1795
  if (yyn == 50) {
#line 1795
    goto case_50;
  }
#line 1800
  if (yyn == 51) {
#line 1800
    goto case_51;
  }
#line 1811
  if (yyn == 52) {
#line 1811
    goto case_52;
  }
#line 1818
  if (yyn == 53) {
#line 1818
    goto case_53;
  }
#line 1828
  if (yyn == 61) {
#line 1828
    goto case_61;
  }
#line 1836
  if (yyn == 62) {
#line 1836
    goto case_62;
  }
#line 1849
  if (yyn == 63) {
#line 1849
    goto case_63;
  }
#line 1857
  if (yyn == 64) {
#line 1857
    goto case_64;
  }
#line 1869
  if (yyn == 67) {
#line 1869
    goto case_67;
  }
#line 1879
  if (yyn == 68) {
#line 1879
    goto case_68;
  }
#line 1889
  if (yyn == 74) {
#line 1889
    goto case_74;
  }
#line 1896
  if (yyn == 75) {
#line 1896
    goto case_75;
  }
#line 1905
  if (yyn == 76) {
#line 1905
    goto case_76;
  }
#line 1912
  if (yyn == 77) {
#line 1912
    goto case_77;
  }
#line 1922
  if (yyn == 83) {
#line 1922
    goto case_83;
  }
#line 1930
  if (yyn == 84) {
#line 1930
    goto case_84;
  }
#line 1939
  if (yyn == 85) {
#line 1939
    goto case_85;
  }
#line 1946
  if (yyn == 86) {
#line 1946
    goto case_86;
  }
#line 1954
  if (yyn == 87) {
#line 1954
    goto case_87;
  }
#line 1961
  if (yyn == 92) {
#line 1961
    goto case_92;
  }
#line 1969
  if (yyn == 96) {
#line 1969
    goto case_96;
  }
#line 1976
  if (yyn == 98) {
#line 1976
    goto case_98;
  }
#line 1983
  if (yyn == 101) {
#line 1983
    goto case_101;
  }
#line 1988
  if (yyn == 102) {
#line 1988
    goto case_102;
  }
#line 1993
  if (yyn == 103) {
#line 1993
    goto case_103;
  }
#line 1998
  if (yyn == 106) {
#line 1998
    goto case_106;
  }
#line 2003
  if (yyn == 107) {
#line 2003
    goto case_107;
  }
#line 2008
  if (yyn == 108) {
#line 2008
    goto case_108;
  }
#line 2013
  if (yyn == 109) {
#line 2013
    goto case_109;
  }
#line 2018
  if (yyn == 110) {
#line 2018
    goto case_110;
  }
#line 2023
  if (yyn == 111) {
#line 2023
    goto case_111;
  }
#line 2028
  if (yyn == 112) {
#line 2028
    goto case_112;
  }
#line 2033
  if (yyn == 113) {
#line 2033
    goto case_113;
  }
#line 2038
  if (yyn == 114) {
#line 2038
    goto case_114;
  }
#line 2043
  if (yyn == 115) {
#line 2043
    goto case_115;
  }
#line 2048
  if (yyn == 116) {
#line 2048
    goto case_116;
  }
#line 2053
  if (yyn == 117) {
#line 2053
    goto case_117;
  }
#line 2060
  goto switch_default;
  case_10: /* CIL Label */ 
  {
#line 1662
  zconf_error("unexpected end statement");
  }
#line 1663
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 1667
  zconf_error("unknown statement \"%s\"", (yyvsp + -2)->string);
  }
#line 1668
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 1673
  zconf_error("unexpected option \"%s\"", (char const   *)(& kconf_id_strings_contents) + ((yyvsp + -2)->id)->name);
  }
#line 1675
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 1679
  zconf_error("invalid statement");
  }
#line 1680
  goto switch_break;
  case_28: /* CIL Label */ 
  {
#line 1684
  zconf_error("unknown option \"%s\"", (yyvsp + -2)->string);
  }
#line 1685
  goto switch_break;
  case_29: /* CIL Label */ 
  {
#line 1689
  zconf_error("invalid option");
  }
#line 1690
  goto switch_break;
  case_30: /* CIL Label */ 
  {
#line 1695
  tmp___0 = sym_lookup((char const   *)(yyvsp + -1)->string, 0);
#line 1695
  sym = tmp___0;
#line 1696
  sym->flags |= 256;
#line 1697
  menu_add_entry(sym);
  }
#line 1698
  if (cdebug & 2) {
    {
#line 1698
    tmp___1 = zconf_lineno();
#line 1698
    tmp___2 = zconf_curname();
#line 1698
    printf((char const   */* __restrict  */)"%s:%d:config %s\n", tmp___2, tmp___1,
           (yyvsp + -1)->string);
    }
  }
#line 1700
  goto switch_break;
  case_31: /* CIL Label */ 
  {
#line 1705
  menu_end_entry();
  }
#line 1706
  if (cdebug & 2) {
    {
#line 1706
    tmp___3 = zconf_lineno();
#line 1706
    tmp___4 = zconf_curname();
#line 1706
    printf((char const   */* __restrict  */)"%s:%d:endconfig\n", tmp___4, tmp___3);
    }
  }
#line 1708
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 1713
  tmp___5 = sym_lookup((char const   *)(yyvsp + -1)->string, 0);
#line 1713
  sym___0 = tmp___5;
#line 1714
  sym___0->flags |= 256;
#line 1715
  menu_add_entry(sym___0);
  }
#line 1716
  if (cdebug & 2) {
    {
#line 1716
    tmp___6 = zconf_lineno();
#line 1716
    tmp___7 = zconf_curname();
#line 1716
    printf((char const   */* __restrict  */)"%s:%d:menuconfig %s\n", tmp___7, tmp___6,
           (yyvsp + -1)->string);
    }
  }
#line 1718
  goto switch_break;
  case_33: /* CIL Label */ 
#line 1723
  if (current_entry->prompt) {
#line 1724
    (current_entry->prompt)->type = (enum prop_type )3;
  } else {
    {
#line 1726
    zconfprint("warning: menuconfig statement without prompt");
    }
  }
  {
#line 1727
  menu_end_entry();
  }
#line 1728
  if (cdebug & 2) {
    {
#line 1728
    tmp___8 = zconf_lineno();
#line 1728
    tmp___9 = zconf_curname();
#line 1728
    printf((char const   */* __restrict  */)"%s:%d:endconfig\n", tmp___9, tmp___8);
    }
  }
#line 1730
  goto switch_break;
  case_41: /* CIL Label */ 
  {
#line 1735
  menu_set_type((int )((yyvsp + -2)->id)->stype);
  }
#line 1736
  if (cdebug & 2) {
    {
#line 1736
    tmp___10 = zconf_lineno();
#line 1736
    tmp___11 = zconf_curname();
#line 1736
    printf((char const   */* __restrict  */)"%s:%d:type(%u)\n", tmp___11, tmp___10,
           (unsigned int const   )((yyvsp + -2)->id)->stype);
    }
  }
#line 1740
  goto switch_break;
  case_42: /* CIL Label */ 
  {
#line 1745
  menu_add_prompt((enum prop_type )1, (yyvsp + -2)->string, (yyvsp + -1)->expr);
  }
#line 1746
  if (cdebug & 2) {
    {
#line 1746
    tmp___12 = zconf_lineno();
#line 1746
    tmp___13 = zconf_curname();
#line 1746
    printf((char const   */* __restrict  */)"%s:%d:prompt\n", tmp___13, tmp___12);
    }
  }
#line 1748
  goto switch_break;
  case_43: /* CIL Label */ 
  {
#line 1753
  menu_add_expr((enum prop_type )4, (yyvsp + -2)->expr, (yyvsp + -1)->expr);
  }
#line 1754
  if ((unsigned int const   )((yyvsp + -3)->id)->stype != 0U) {
    {
#line 1755
    menu_set_type((int )((yyvsp + -3)->id)->stype);
    }
  }
#line 1756
  if (cdebug & 2) {
    {
#line 1756
    tmp___14 = zconf_lineno();
#line 1756
    tmp___15 = zconf_curname();
#line 1756
    printf((char const   */* __restrict  */)"%s:%d:default(%u)\n", tmp___15, tmp___14,
           (unsigned int const   )((yyvsp + -3)->id)->stype);
    }
  }
#line 1760
  goto switch_break;
  case_44: /* CIL Label */ 
  {
#line 1765
  tmp___16 = sym_lookup((char const   *)(yyvsp + -2)->string, 0);
#line 1765
  menu_add_symbol((enum prop_type )6, tmp___16, (yyvsp + -1)->expr);
  }
#line 1766
  if (cdebug & 2) {
    {
#line 1766
    tmp___17 = zconf_lineno();
#line 1766
    tmp___18 = zconf_curname();
#line 1766
    printf((char const   */* __restrict  */)"%s:%d:select\n", tmp___18, tmp___17);
    }
  }
#line 1768
  goto switch_break;
  case_45: /* CIL Label */ 
  {
#line 1773
  tmp___19 = expr_alloc_comp((enum expr_type )8, (yyvsp + -3)->symbol, (yyvsp + -2)->symbol);
#line 1773
  menu_add_expr((enum prop_type )7, tmp___19, (yyvsp + -1)->expr);
  }
#line 1774
  if (cdebug & 2) {
    {
#line 1774
    tmp___20 = zconf_lineno();
#line 1774
    tmp___21 = zconf_curname();
#line 1774
    printf((char const   */* __restrict  */)"%s:%d:range\n", tmp___21, tmp___20);
    }
  }
#line 1776
  goto switch_break;
  case_48: /* CIL Label */ 
  {
#line 1781
  tmp___22 = strlen((char const   *)(yyvsp + -1)->string);
#line 1781
  tmp___23 = kconf_id_lookup((char const   *)(yyvsp + -1)->string, (unsigned int )tmp___22);
#line 1781
  id = (struct kconf_id  const  *)tmp___23;
  }
#line 1782
  if (id) {
#line 1782
    if (id->flags & 4U) {
      {
#line 1783
      menu_add_option((int )id->token, (yyvsp + 0)->string);
      }
    } else {
      {
#line 1785
      zconfprint("warning: ignoring unknown option %s", (yyvsp + -1)->string);
      }
    }
  } else {
    {
#line 1785
    zconfprint("warning: ignoring unknown option %s", (yyvsp + -1)->string);
    }
  }
  {
#line 1786
  free((void *)(yyvsp + -1)->string);
  }
#line 1788
  goto switch_break;
  case_49: /* CIL Label */ 
#line 1792
  yyval.string = (char *)((void *)0);
#line 1793
  goto switch_break;
  case_50: /* CIL Label */ 
#line 1797
  yyval.string = (yyvsp + 0)->string;
#line 1798
  goto switch_break;
  case_51: /* CIL Label */ 
  {
#line 1803
  tmp___24 = sym_lookup((char const   *)(yyvsp + -1)->string, 16);
#line 1803
  sym___1 = tmp___24;
#line 1804
  sym___1->flags |= 4096;
#line 1805
  menu_add_entry(sym___1);
#line 1806
  menu_add_expr((enum prop_type )5, (struct expr *)((void *)0), (struct expr *)((void *)0));
  }
#line 1807
  if (cdebug & 2) {
    {
#line 1807
    tmp___25 = zconf_lineno();
#line 1807
    tmp___26 = zconf_curname();
#line 1807
    printf((char const   */* __restrict  */)"%s:%d:choice\n", tmp___26, tmp___25);
    }
  }
#line 1809
  goto switch_break;
  case_52: /* CIL Label */ 
  {
#line 1814
  yyval.menu = menu_add_menu();
  }
#line 1816
  goto switch_break;
  case_53: /* CIL Label */ 
  {
#line 1821
  tmp___29 = zconf_endtoken((yyvsp + 0)->id, 262, 263);
  }
#line 1821
  if (tmp___29) {
    {
#line 1822
    menu_end_menu();
    }
#line 1823
    if (cdebug & 2) {
      {
#line 1823
      tmp___27 = zconf_lineno();
#line 1823
      tmp___28 = zconf_curname();
#line 1823
      printf((char const   */* __restrict  */)"%s:%d:endchoice\n", tmp___28, tmp___27);
      }
    }
  }
#line 1826
  goto switch_break;
  case_61: /* CIL Label */ 
  {
#line 1831
  menu_add_prompt((enum prop_type )1, (yyvsp + -2)->string, (yyvsp + -1)->expr);
  }
#line 1832
  if (cdebug & 2) {
    {
#line 1832
    tmp___30 = zconf_lineno();
#line 1832
    tmp___31 = zconf_curname();
#line 1832
    printf((char const   */* __restrict  */)"%s:%d:prompt\n", tmp___31, tmp___30);
    }
  }
#line 1834
  goto switch_break;
  case_62: /* CIL Label */ 
#line 1839
  if ((unsigned int const   )((yyvsp + -2)->id)->stype == 1U) {
#line 1839
    goto _L;
  } else
#line 1839
  if ((unsigned int const   )((yyvsp + -2)->id)->stype == 2U) {
    _L: /* CIL Label */ 
    {
#line 1840
    menu_set_type((int )((yyvsp + -2)->id)->stype);
    }
#line 1841
    if (cdebug & 2) {
      {
#line 1841
      tmp___32 = zconf_lineno();
#line 1841
      tmp___33 = zconf_curname();
#line 1841
      printf((char const   */* __restrict  */)"%s:%d:type(%u)\n", tmp___33, tmp___32,
             (unsigned int const   )((yyvsp + -2)->id)->stype);
      }
    }
  } else {
#line 1845
    goto yyerrorlab;
  }
#line 1847
  goto switch_break;
  case_63: /* CIL Label */ 
#line 1852
  (current_entry->sym)->flags |= 256;
#line 1853
  if (cdebug & 2) {
    {
#line 1853
    tmp___34 = zconf_lineno();
#line 1853
    tmp___35 = zconf_curname();
#line 1853
    printf((char const   */* __restrict  */)"%s:%d:optional\n", tmp___35, tmp___34);
    }
  }
#line 1855
  goto switch_break;
  case_64: /* CIL Label */ 
#line 1860
  if ((unsigned int const   )((yyvsp + -3)->id)->stype == 0U) {
    {
#line 1861
    tmp___36 = sym_lookup((char const   *)(yyvsp + -2)->string, 0);
#line 1861
    menu_add_symbol((enum prop_type )4, tmp___36, (yyvsp + -1)->expr);
    }
#line 1862
    if (cdebug & 2) {
      {
#line 1862
      tmp___37 = zconf_lineno();
#line 1862
      tmp___38 = zconf_curname();
#line 1862
      printf((char const   */* __restrict  */)"%s:%d:default\n", tmp___38, tmp___37);
      }
    }
  } else {
#line 1865
    goto yyerrorlab;
  }
#line 1867
  goto switch_break;
  case_67: /* CIL Label */ 
#line 1872
  if (cdebug & 2) {
    {
#line 1872
    tmp___39 = zconf_lineno();
#line 1872
    tmp___40 = zconf_curname();
#line 1872
    printf((char const   */* __restrict  */)"%s:%d:if\n", tmp___40, tmp___39);
    }
  }
  {
#line 1873
  menu_add_entry((struct symbol *)((void *)0));
#line 1874
  menu_add_dep((yyvsp + -1)->expr);
#line 1875
  yyval.menu = menu_add_menu();
  }
#line 1877
  goto switch_break;
  case_68: /* CIL Label */ 
  {
#line 1882
  tmp___43 = zconf_endtoken((yyvsp + 0)->id, 269, 270);
  }
#line 1882
  if (tmp___43) {
    {
#line 1883
    menu_end_menu();
    }
#line 1884
    if (cdebug & 2) {
      {
#line 1884
      tmp___41 = zconf_lineno();
#line 1884
      tmp___42 = zconf_curname();
#line 1884
      printf((char const   */* __restrict  */)"%s:%d:endif\n", tmp___42, tmp___41);
      }
    }
  }
#line 1887
  goto switch_break;
  case_74: /* CIL Label */ 
  {
#line 1892
  menu_add_prompt((enum prop_type )3, (yyvsp + -1)->string, (struct expr *)((void *)0));
  }
#line 1894
  goto switch_break;
  case_75: /* CIL Label */ 
  {
#line 1899
  menu_add_entry((struct symbol *)((void *)0));
#line 1900
  menu_add_prompt((enum prop_type )3, (yyvsp + -1)->string, (struct expr *)((void *)0));
  }
#line 1901
  if (cdebug & 2) {
    {
#line 1901
    tmp___44 = zconf_lineno();
#line 1901
    tmp___45 = zconf_curname();
#line 1901
    printf((char const   */* __restrict  */)"%s:%d:menu\n", tmp___45, tmp___44);
    }
  }
#line 1903
  goto switch_break;
  case_76: /* CIL Label */ 
  {
#line 1908
  yyval.menu = menu_add_menu();
  }
#line 1910
  goto switch_break;
  case_77: /* CIL Label */ 
  {
#line 1915
  tmp___48 = zconf_endtoken((yyvsp + 0)->id, 259, 260);
  }
#line 1915
  if (tmp___48) {
    {
#line 1916
    menu_end_menu();
    }
#line 1917
    if (cdebug & 2) {
      {
#line 1917
      tmp___46 = zconf_lineno();
#line 1917
      tmp___47 = zconf_curname();
#line 1917
      printf((char const   */* __restrict  */)"%s:%d:endmenu\n", tmp___47, tmp___46);
      }
    }
  }
#line 1920
  goto switch_break;
  case_83: /* CIL Label */ 
#line 1925
  if (cdebug & 2) {
    {
#line 1925
    tmp___49 = zconf_lineno();
#line 1925
    tmp___50 = zconf_curname();
#line 1925
    printf((char const   */* __restrict  */)"%s:%d:source %s\n", tmp___50, tmp___49,
           (yyvsp + -1)->string);
    }
  }
  {
#line 1926
  zconf_nextfile((char const   *)(yyvsp + -1)->string);
  }
#line 1928
  goto switch_break;
  case_84: /* CIL Label */ 
  {
#line 1933
  menu_add_entry((struct symbol *)((void *)0));
#line 1934
  menu_add_prompt((enum prop_type )2, (yyvsp + -1)->string, (struct expr *)((void *)0));
  }
#line 1935
  if (cdebug & 2) {
    {
#line 1935
    tmp___51 = zconf_lineno();
#line 1935
    tmp___52 = zconf_curname();
#line 1935
    printf((char const   */* __restrict  */)"%s:%d:comment\n", tmp___52, tmp___51);
    }
  }
#line 1937
  goto switch_break;
  case_85: /* CIL Label */ 
  {
#line 1942
  menu_end_entry();
  }
#line 1944
  goto switch_break;
  case_86: /* CIL Label */ 
#line 1949
  if (cdebug & 2) {
    {
#line 1949
    tmp___53 = zconf_lineno();
#line 1949
    tmp___54 = zconf_curname();
#line 1949
    printf((char const   */* __restrict  */)"%s:%d:help\n", tmp___54, tmp___53);
    }
  }
  {
#line 1950
  zconf_starthelp();
  }
#line 1952
  goto switch_break;
  case_87: /* CIL Label */ 
#line 1957
  current_entry->help = (yyvsp + 0)->string;
#line 1959
  goto switch_break;
  case_92: /* CIL Label */ 
  {
#line 1964
  menu_add_dep((yyvsp + -1)->expr);
  }
#line 1965
  if (cdebug & 2) {
    {
#line 1965
    tmp___55 = zconf_lineno();
#line 1965
    tmp___56 = zconf_curname();
#line 1965
    printf((char const   */* __restrict  */)"%s:%d:depends on\n", tmp___56, tmp___55);
    }
  }
#line 1967
  goto switch_break;
  case_96: /* CIL Label */ 
  {
#line 1972
  menu_add_visibility((yyvsp + 0)->expr);
  }
#line 1974
  goto switch_break;
  case_98: /* CIL Label */ 
  {
#line 1979
  menu_add_prompt((enum prop_type )1, (yyvsp + -1)->string, (yyvsp + 0)->expr);
  }
#line 1981
  goto switch_break;
  case_101: /* CIL Label */ 
#line 1985
  yyval.id = (yyvsp + -1)->id;
#line 1986
  goto switch_break;
  case_102: /* CIL Label */ 
#line 1990
  yyval.id = (yyvsp + -1)->id;
#line 1991
  goto switch_break;
  case_103: /* CIL Label */ 
#line 1995
  yyval.id = (yyvsp + -1)->id;
#line 1996
  goto switch_break;
  case_106: /* CIL Label */ 
#line 2000
  yyval.expr = (struct expr *)((void *)0);
#line 2001
  goto switch_break;
  case_107: /* CIL Label */ 
#line 2005
  yyval.expr = (yyvsp + 0)->expr;
#line 2006
  goto switch_break;
  case_108: /* CIL Label */ 
  {
#line 2010
  yyval.expr = expr_alloc_symbol((yyvsp + 0)->symbol);
  }
#line 2011
  goto switch_break;
  case_109: /* CIL Label */ 
  {
#line 2015
  yyval.expr = expr_alloc_comp((enum expr_type )4, (yyvsp + -2)->symbol, (yyvsp + 0)->symbol);
  }
#line 2016
  goto switch_break;
  case_110: /* CIL Label */ 
  {
#line 2020
  yyval.expr = expr_alloc_comp((enum expr_type )5, (yyvsp + -2)->symbol, (yyvsp + 0)->symbol);
  }
#line 2021
  goto switch_break;
  case_111: /* CIL Label */ 
#line 2025
  yyval.expr = (yyvsp + -1)->expr;
#line 2026
  goto switch_break;
  case_112: /* CIL Label */ 
  {
#line 2030
  yyval.expr = expr_alloc_one((enum expr_type )3, (yyvsp + 0)->expr);
  }
#line 2031
  goto switch_break;
  case_113: /* CIL Label */ 
  {
#line 2035
  yyval.expr = expr_alloc_two((enum expr_type )1, (yyvsp + -2)->expr, (yyvsp + 0)->expr);
  }
#line 2036
  goto switch_break;
  case_114: /* CIL Label */ 
  {
#line 2040
  yyval.expr = expr_alloc_two((enum expr_type )2, (yyvsp + -2)->expr, (yyvsp + 0)->expr);
  }
#line 2041
  goto switch_break;
  case_115: /* CIL Label */ 
  {
#line 2045
  yyval.symbol = sym_lookup((char const   *)(yyvsp + 0)->string, 0);
#line 2045
  free((void *)(yyvsp + 0)->string);
  }
#line 2046
  goto switch_break;
  case_116: /* CIL Label */ 
  {
#line 2050
  yyval.symbol = sym_lookup((char const   *)(yyvsp + 0)->string, 1);
#line 2050
  free((void *)(yyvsp + 0)->string);
  }
#line 2051
  goto switch_break;
  case_117: /* CIL Label */ 
#line 2055
  yyval.string = (char *)((void *)0);
#line 2056
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2060
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 2073
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 2073
    if (zconfdebug) {
      {
#line 2073
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              "-> $$ =");
#line 2073
      yy_symbol_print(stderr, (int )yyr1[yyn], (YYSTYPE const   */* const  */)(& yyval));
#line 2073
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 2073
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 2075
  yyvsp -= yylen;
#line 2075
  yyssp -= yylen;
#line 2076
  yylen = 0;
  {
#line 2077
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 2077
    if (zconfdebug) {
      {
#line 2077
      yy_stack_print(yyss, yyssp);
      }
    }
#line 2077
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 2079
  yyvsp ++;
#line 2079
  *yyvsp = yyval;
#line 2085
  yyn = (int )yyr1[yyn];
#line 2087
  yystate = (int )((int const   )yypgoto[yyn - 36] + (int const   )*yyssp);
#line 2088
  if (0 <= yystate) {
#line 2088
    if (yystate <= 290) {
#line 2088
      if ((int const   )yycheck[yystate] == (int const   )*yyssp) {
#line 2089
        yystate = (int )yytable[yystate];
      } else {
#line 2091
        yystate = (int )yydefgoto[yyn - 36];
      }
    } else {
#line 2091
      yystate = (int )yydefgoto[yyn - 36];
    }
  } else {
#line 2091
    yystate = (int )yydefgoto[yyn - 36];
  }
#line 2093
  goto yynewstate;
  yyerrlab: 
#line 2102
  if (zconfchar == -2) {
#line 2102
    yytoken = -2;
  } else {
#line 2102
    if ((unsigned int )zconfchar <= 290U) {
#line 2102
      tmp___57 = (int const   )yytranslate[zconfchar];
    } else {
#line 2102
      tmp___57 = (int const   )2;
    }
#line 2102
    yytoken = (int )tmp___57;
  }
#line 2105
  if (! yyerrstatus) {
    {
#line 2107
    zconfnerrs ++;
#line 2109
    zconferror("syntax error");
    }
  }
#line 2146
  if (yyerrstatus == 3) {
#line 2151
    if (zconfchar <= 0) {
#line 2154
      if (zconfchar == 0) {
#line 2155
        goto yyabortlab;
      }
    } else {
      {
#line 2159
      yydestruct("Error: discarding", yytoken, & zconflval);
#line 2161
      zconfchar = -2;
      }
    }
  }
#line 2167
  goto yyerrlab1;
  yyerrorlab: 
#line 2183
  yyvsp -= yylen;
#line 2183
  yyssp -= yylen;
#line 2184
  yylen = 0;
  {
#line 2185
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 2185
    if (zconfdebug) {
      {
#line 2185
      yy_stack_print(yyss, yyssp);
      }
    }
#line 2185
    goto while_break___11;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 2186
  yystate = (int )*yyssp;
#line 2187
  goto yyerrlab1;
  yyerrlab1: 
#line 2194
  yyerrstatus = 3;
  {
#line 2196
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 2198
    yyn = (int )yypact[yystate];
#line 2199
    if (! (yyn == -90)) {
#line 2201
      yyn ++;
#line 2202
      if (0 <= yyn) {
#line 2202
        if (yyn <= 290) {
#line 2202
          if ((int const   )yycheck[yyn] == 1) {
#line 2204
            yyn = (int )yytable[yyn];
#line 2205
            if (0 < yyn) {
#line 2206
              goto while_break___12;
            }
          }
        }
      }
    }
#line 2211
    if ((unsigned long )yyssp == (unsigned long )yyss) {
#line 2212
      goto yyabortlab;
    }
    {
#line 2215
    yydestruct("Error: popping", (int )yystos[yystate], yyvsp);
#line 2217
    yyvsp --;
#line 2217
    yyssp --;
#line 2218
    yystate = (int )*yyssp;
    }
    {
#line 2219
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 2219
      if (zconfdebug) {
        {
#line 2219
        yy_stack_print(yyss, yyssp);
        }
      }
#line 2219
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
  }
  while_break___12: /* CIL Label */ ;
  }
#line 2222
  yyvsp ++;
#line 2222
  *yyvsp = zconflval;
  {
#line 2226
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 2226
    if (zconfdebug) {
      {
#line 2226
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              "Shifting");
#line 2226
      yy_symbol_print(stderr, (int )yystos[yyn], (YYSTYPE const   */* const  */)yyvsp);
#line 2226
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 2226
    goto while_break___14;
  }
  while_break___14: /* CIL Label */ ;
  }
#line 2228
  yystate = yyn;
#line 2229
  goto yynewstate;
  yyacceptlab: 
#line 2236
  yyresult = 0;
#line 2237
  goto yyreturn;
  yyabortlab: 
#line 2243
  yyresult = 1;
#line 2244
  goto yyreturn;
  yyexhaustedlab: 
  {
#line 2251
  zconferror("memory exhausted");
#line 2252
  yyresult = 2;
  }
  yyreturn: 
#line 2257
  if (zconfchar != -2) {
#line 2261
    if ((unsigned int )zconfchar <= 290U) {
#line 2261
      yytoken = (int )yytranslate[zconfchar];
    } else {
#line 2261
      yytoken = 2;
    }
    {
#line 2262
    yydestruct("Cleanup: discarding lookahead", yytoken, & zconflval);
    }
  }
#line 2267
  yyvsp -= yylen;
#line 2267
  yyssp -= yylen;
  {
#line 2268
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 2268
    if (zconfdebug) {
      {
#line 2268
      yy_stack_print(yyss, yyssp);
      }
    }
#line 2268
    goto while_break___15;
  }
  while_break___15: /* CIL Label */ ;
  }
  {
#line 2269
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 2269
    if (! ((unsigned long )yyssp != (unsigned long )yyss)) {
#line 2269
      goto while_break___16;
    }
    {
#line 2271
    yydestruct("Cleanup: popping", (int )yystos[*yyssp], yyvsp);
#line 2273
    yyvsp --;
#line 2273
    yyssp --;
    }
  }
  while_break___16: /* CIL Label */ ;
  }
#line 2276
  if ((unsigned long )yyss != (unsigned long )(yyssa)) {
    {
#line 2277
    free((void *)yyss);
    }
  }
#line 2284
  return (yyresult);
}
}
#line 2291 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/zconf.tab.c"
void conf_parse(char const   *name ) 
{ 
  struct symbol *sym ;
  int i ;
  char *tmp ;
  char *tmp___0 ;
  struct symbol *tmp___1 ;

  {
  {
#line 2296
  zconf_initscan(name);
#line 2298
  sym_init();
#line 2299
  _menu_init();
#line 2300
  rootmenu.prompt = menu_add_prompt((enum prop_type )3, (char *)"Linux Kernel Configuration",
                                    (struct expr *)((void *)0));
#line 2302
  tmp = getenv("ZCONF_DEBUG");
  }
#line 2302
  if (tmp) {
#line 2303
    zconfdebug = 1;
  }
  {
#line 2304
  zconfparse();
  }
#line 2305
  if (zconfnerrs) {
    {
#line 2306
    exit(1);
    }
  }
#line 2307
  if (! modules_sym) {
    {
#line 2308
    modules_sym = sym_find("n");
    }
  }
  {
#line 2310
  tmp___0 = gettext((rootmenu.prompt)->text);
#line 2310
  (rootmenu.prompt)->text = (char const   *)tmp___0;
#line 2311
  (rootmenu.prompt)->text = sym_expand_string_value((rootmenu.prompt)->text);
#line 2313
  menu_finalize(& rootmenu);
#line 2314
  i = 0;
  }
  {
#line 2314
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2314
    if (! (i < 9973)) {
#line 2314
      goto while_break;
    }
#line 2314
    sym = symbol_hash[i];
    {
#line 2314
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2314
      if (! sym) {
#line 2314
        goto while_break___0;
      }
#line 2314
      if ((unsigned int )sym->type != 6U) {
        {
#line 2315
        tmp___1 = sym_check_deps(sym);
        }
#line 2315
        if (tmp___1) {
#line 2316
          zconfnerrs ++;
        }
      }
#line 2314
      sym = sym->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2314
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2318
  if (zconfnerrs) {
    {
#line 2319
    exit(1);
    }
  }
  {
#line 2320
  sym_set_change_count(1);
  }
#line 2321
  return;
}
}
#line 2323 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/zconf.tab.c"
static char const   *zconf_tokenname(int token ) 
{ 


  {
  {
#line 2326
  if (token == 259) {
#line 2326
    goto case_259;
  }
#line 2327
  if (token == 260) {
#line 2327
    goto case_260;
  }
#line 2328
  if (token == 262) {
#line 2328
    goto case_262;
  }
#line 2329
  if (token == 263) {
#line 2329
    goto case_263;
  }
#line 2330
  if (token == 269) {
#line 2330
    goto case_269;
  }
#line 2331
  if (token == 270) {
#line 2331
    goto case_270;
  }
#line 2332
  if (token == 271) {
#line 2332
    goto case_271;
  }
#line 2333
  if (token == 278) {
#line 2333
    goto case_278;
  }
#line 2325
  goto switch_break;
  case_259: /* CIL Label */ 
#line 2326
  return ("menu");
  case_260: /* CIL Label */ 
#line 2327
  return ("endmenu");
  case_262: /* CIL Label */ 
#line 2328
  return ("choice");
  case_263: /* CIL Label */ 
#line 2329
  return ("endchoice");
  case_269: /* CIL Label */ 
#line 2330
  return ("if");
  case_270: /* CIL Label */ 
#line 2331
  return ("endif");
  case_271: /* CIL Label */ 
#line 2332
  return ("depends");
  case_278: /* CIL Label */ 
#line 2333
  return ("visible");
  switch_break: /* CIL Label */ ;
  }
#line 2335
  return ("<token>");
}
}
#line 2338 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/zconf.tab.c"
static _Bool zconf_endtoken(struct kconf_id  const  *id , int starttoken , int endtoken ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 2340
  if (id->token != (int const   )endtoken) {
    {
#line 2341
    tmp = zconf_tokenname(starttoken);
#line 2341
    zconf_error("unexpected \'%s\' within %s block", (char const   *)(& kconf_id_strings_contents) + id->name,
                tmp);
#line 2343
    zconfnerrs ++;
    }
#line 2344
    return ((_Bool)0);
  }
#line 2346
  if ((unsigned long )current_menu->file != (unsigned long )current_file) {
    {
#line 2347
    tmp___0 = zconf_tokenname(starttoken);
#line 2347
    zconf_error("\'%s\' in different file than \'%s\'", (char const   *)(& kconf_id_strings_contents) + id->name,
                tmp___0);
#line 2349
    tmp___1 = zconf_tokenname(starttoken);
#line 2349
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: location of the \'%s\'\n",
            (current_menu->file)->name, current_menu->lineno, tmp___1);
#line 2352
    zconfnerrs ++;
    }
#line 2353
    return ((_Bool)0);
  }
#line 2355
  return ((_Bool)1);
}
}
#line 2358 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/zconf.tab.c"
static void zconfprint(char const   *err  , ...) 
{ 
  va_list ap ;
  int tmp ;
  char const   *tmp___0 ;

  {
  {
#line 2362
  tmp = zconf_lineno();
#line 2362
  tmp___0 = zconf_curname();
#line 2362
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: ",
          tmp___0, tmp);
#line 2363
  __builtin_va_start(ap, err);
#line 2364
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)err,
           ap);
#line 2365
  __builtin_va_end(ap);
#line 2366
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 2367
  return;
}
}
#line 2369 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/zconf.tab.c"
static void zconf_error(char const   *err  , ...) 
{ 
  va_list ap ;
  int tmp ;
  char const   *tmp___0 ;

  {
  {
#line 2373
  zconfnerrs ++;
#line 2374
  tmp = zconf_lineno();
#line 2374
  tmp___0 = zconf_curname();
#line 2374
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: ",
          tmp___0, tmp);
#line 2375
  __builtin_va_start(ap, err);
#line 2376
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)err,
           ap);
#line 2377
  __builtin_va_end(ap);
#line 2378
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 2379
  return;
}
}
#line 2381 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/zconf.tab.c"
static void zconferror(char const   *err ) 
{ 
  int tmp ;
  char const   *tmp___0 ;

  {
  {
#line 2383
  tmp = zconf_lineno();
#line 2383
  tmp___0 = zconf_curname();
#line 2383
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: %s\n",
          tmp___0, tmp + 1, err);
  }
#line 2384
  return;
}
}
#line 2386 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/zconf.tab.c"
static void print_quoted_string(FILE *out , char const   *str ) 
{ 
  char const   *p ;
  int len ;
  char *tmp ;

  {
  {
#line 2391
  _IO_putc('\"', out);
  }
  {
#line 2392
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2392
    tmp = strchr(str, '\"');
#line 2392
    p = (char const   *)tmp;
    }
#line 2392
    if (! p) {
#line 2392
      goto while_break;
    }
#line 2393
    len = (int )(p - str);
#line 2394
    if (len) {
      {
#line 2395
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%.*s",
              len, str);
      }
    }
    {
#line 2396
    fputs((char const   */* __restrict  */)"\\\"", (FILE */* __restrict  */)out);
#line 2397
    str = p + 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2399
  fputs((char const   */* __restrict  */)str, (FILE */* __restrict  */)out);
#line 2400
  _IO_putc('\"', out);
  }
#line 2401
  return;
}
}
#line 2403 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/zconf.tab.c"
static void print_symbol(FILE *out , struct menu *menu ) 
{ 
  struct symbol *sym ;
  struct property *prop ;
  _Bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int len ;
  size_t tmp___2 ;

  {
  {
#line 2405
  sym = menu->sym;
#line 2408
  tmp = sym_is_choice(sym);
  }
#line 2408
  if (tmp) {
    {
#line 2409
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\nchoice\n");
    }
  } else {
    {
#line 2411
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\nconfig %s\n",
            sym->name);
    }
  }
  {
#line 2413
  if ((unsigned int )sym->type == 1U) {
#line 2413
    goto case_1;
  }
#line 2416
  if ((unsigned int )sym->type == 2U) {
#line 2416
    goto case_2;
  }
#line 2419
  if ((unsigned int )sym->type == 5U) {
#line 2419
    goto case_5;
  }
#line 2422
  if ((unsigned int )sym->type == 3U) {
#line 2422
    goto case_3;
  }
#line 2425
  if ((unsigned int )sym->type == 4U) {
#line 2425
    goto case_4;
  }
#line 2428
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 2414
  fputs((char const   */* __restrict  */)"  boolean\n", (FILE */* __restrict  */)out);
  }
#line 2415
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 2417
  fputs((char const   */* __restrict  */)"  tristate\n", (FILE */* __restrict  */)out);
  }
#line 2418
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 2420
  fputs((char const   */* __restrict  */)"  string\n", (FILE */* __restrict  */)out);
  }
#line 2421
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 2423
  fputs((char const   */* __restrict  */)"  integer\n", (FILE */* __restrict  */)out);
  }
#line 2424
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 2426
  fputs((char const   */* __restrict  */)"  hex\n", (FILE */* __restrict  */)out);
  }
#line 2427
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 2429
  fputs((char const   */* __restrict  */)"  ???\n", (FILE */* __restrict  */)out);
  }
#line 2430
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2432
  prop = sym->prop;
  {
#line 2432
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2432
    if (! prop) {
#line 2432
      goto while_break;
    }
#line 2433
    if ((unsigned long )prop->menu != (unsigned long )menu) {
#line 2434
      goto __Cont;
    }
    {
#line 2436
    if ((unsigned int )prop->type == 1U) {
#line 2436
      goto case_1___0;
    }
#line 2445
    if ((unsigned int )prop->type == 4U) {
#line 2445
      goto case_4___0;
    }
#line 2454
    if ((unsigned int )prop->type == 5U) {
#line 2454
      goto case_5___0;
    }
#line 2457
    if ((unsigned int )prop->type == 6U) {
#line 2457
      goto case_6;
    }
#line 2462
    if ((unsigned int )prop->type == 7U) {
#line 2462
      goto case_7;
    }
#line 2467
    if ((unsigned int )prop->type == 3U) {
#line 2467
      goto case_3___0;
    }
#line 2472
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
    {
#line 2437
    fputs((char const   */* __restrict  */)"  prompt ", (FILE */* __restrict  */)out);
#line 2438
    print_quoted_string(out, prop->text);
#line 2439
    tmp___0 = expr_is_yes(prop->visible.expr);
    }
#line 2439
    if (! tmp___0) {
      {
#line 2440
      fputs((char const   */* __restrict  */)" if ", (FILE */* __restrict  */)out);
#line 2441
      expr_fprint(prop->visible.expr, out);
      }
    }
    {
#line 2443
    fputc('\n', out);
    }
#line 2444
    goto switch_break___0;
    case_4___0: /* CIL Label */ 
    {
#line 2446
    fputs((char const   */* __restrict  */)"  default ", (FILE */* __restrict  */)out);
#line 2447
    expr_fprint(prop->expr, out);
#line 2448
    tmp___1 = expr_is_yes(prop->visible.expr);
    }
#line 2448
    if (! tmp___1) {
      {
#line 2449
      fputs((char const   */* __restrict  */)" if ", (FILE */* __restrict  */)out);
#line 2450
      expr_fprint(prop->visible.expr, out);
      }
    }
    {
#line 2452
    fputc('\n', out);
    }
#line 2453
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
    {
#line 2455
    fputs((char const   */* __restrict  */)"  #choice value\n", (FILE */* __restrict  */)out);
    }
#line 2456
    goto switch_break___0;
    case_6: /* CIL Label */ 
    {
#line 2458
    fputs((char const   */* __restrict  */)"  select ", (FILE */* __restrict  */)out);
#line 2459
    expr_fprint(prop->expr, out);
#line 2460
    fputc('\n', out);
    }
#line 2461
    goto switch_break___0;
    case_7: /* CIL Label */ 
    {
#line 2463
    fputs((char const   */* __restrict  */)"  range ", (FILE */* __restrict  */)out);
#line 2464
    expr_fprint(prop->expr, out);
#line 2465
    fputc('\n', out);
    }
#line 2466
    goto switch_break___0;
    case_3___0: /* CIL Label */ 
    {
#line 2468
    fputs((char const   */* __restrict  */)"  menu ", (FILE */* __restrict  */)out);
#line 2469
    print_quoted_string(out, prop->text);
#line 2470
    fputc('\n', out);
    }
#line 2471
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 2473
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"  unknown prop %d!\n",
            (unsigned int )prop->type);
    }
#line 2474
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 2432
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2477
  if (menu->help) {
    {
#line 2478
    tmp___2 = strlen((char const   *)menu->help);
#line 2478
    len = (int )tmp___2;
    }
    {
#line 2479
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2479
      len --;
#line 2479
      if (! ((int )*(menu->help + len) == 10)) {
#line 2479
        goto while_break___0;
      }
#line 2480
      *(menu->help + len) = (char)0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2481
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"  help\n%s\n",
            menu->help);
    }
  }
#line 2483
  return;
}
}
#line 2485 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/zconf.tab.c"
void zconfdump(FILE *out ) 
{ 
  struct property *prop ;
  struct symbol *sym ;
  struct menu *menu ;
  int tmp ;

  {
#line 2491
  menu = rootmenu.list;
  {
#line 2492
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2492
    if (! menu) {
#line 2492
      goto while_break;
    }
#line 2493
    sym = menu->sym;
#line 2493
    if (sym) {
      {
#line 2494
      print_symbol(out, menu);
      }
    } else {
#line 2495
      prop = menu->prompt;
#line 2495
      if (prop) {
        {
#line 2497
        if ((unsigned int )prop->type == 2U) {
#line 2497
          goto case_2;
        }
#line 2502
        if ((unsigned int )prop->type == 3U) {
#line 2502
          goto case_3;
        }
#line 2507
        goto switch_default;
        case_2: /* CIL Label */ 
        {
#line 2498
        fputs((char const   */* __restrict  */)"\ncomment ", (FILE */* __restrict  */)out);
#line 2499
        print_quoted_string(out, prop->text);
#line 2500
        fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)out);
        }
#line 2501
        goto switch_break;
        case_3: /* CIL Label */ 
        {
#line 2503
        fputs((char const   */* __restrict  */)"\nmenu ", (FILE */* __restrict  */)out);
#line 2504
        print_quoted_string(out, prop->text);
#line 2505
        fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)out);
        }
#line 2506
        goto switch_break;
        switch_default: /* CIL Label */ ;
        switch_break: /* CIL Label */ ;
        }
        {
#line 2510
        tmp = expr_is_yes(prop->visible.expr);
        }
#line 2510
        if (! tmp) {
          {
#line 2511
          fputs((char const   */* __restrict  */)"  depends ", (FILE */* __restrict  */)out);
#line 2512
          expr_fprint(prop->visible.expr, out);
#line 2513
          fputc('\n', out);
          }
        }
      }
    }
#line 2517
    if (menu->list) {
#line 2518
      menu = menu->list;
    } else
#line 2519
    if (menu->next) {
#line 2520
      menu = menu->next;
    } else {
      {
#line 2521
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2521
        menu = menu->parent;
#line 2521
        if (! menu) {
#line 2521
          goto while_break___0;
        }
#line 2522
        if (menu->prompt) {
#line 2522
          if ((unsigned int )(menu->prompt)->type == 3U) {
            {
#line 2523
            fputs((char const   */* __restrict  */)"\nendmenu\n", (FILE */* __restrict  */)out);
            }
          }
        }
#line 2524
        if (menu->next) {
#line 2525
          menu = menu->next;
#line 2526
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2530
  return;
}
}
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 174 "scripts/kconfig/zconf.lex.c_shipped"
int zconfleng  ;
#line 176
FILE *zconfin ;
#line 176
FILE *zconfout ;
#line 271 "scripts/kconfig/zconf.lex.c_shipped"
static size_t yy_buffer_stack_top  =    (size_t )0;
#line 272 "scripts/kconfig/zconf.lex.c_shipped"
static size_t yy_buffer_stack_max  =    (size_t )0;
#line 273 "scripts/kconfig/zconf.lex.c_shipped"
static YY_BUFFER_STATE *yy_buffer_stack  =    (YY_BUFFER_STATE *)0;
#line 291 "scripts/kconfig/zconf.lex.c_shipped"
static char yy_hold_char  ;
#line 292 "scripts/kconfig/zconf.lex.c_shipped"
static int yy_n_chars  ;
#line 296 "scripts/kconfig/zconf.lex.c_shipped"
static char *yy_c_buf_p  =    (char *)0;
#line 297 "scripts/kconfig/zconf.lex.c_shipped"
static int yy_init  =    0;
#line 298 "scripts/kconfig/zconf.lex.c_shipped"
static int yy_start  =    0;
#line 303 "scripts/kconfig/zconf.lex.c_shipped"
static int yy_did_buffer_switch_on_eof  ;
#line 305
void zconfrestart(FILE *input_file ) ;
#line 306
void zconf_switch_to_buffer(YY_BUFFER_STATE new_buffer ) ;
#line 307
YY_BUFFER_STATE zconf_create_buffer(FILE *file , int size ) ;
#line 308
void zconf_delete_buffer(YY_BUFFER_STATE b ) ;
#line 309
void zconf_flush_buffer(YY_BUFFER_STATE b ) ;
#line 310
void zconfpush_buffer_state(YY_BUFFER_STATE new_buffer ) ;
#line 311
void zconfpop_buffer_state(void) ;
#line 313
static void zconfensure_buffer_stack(void) ;
#line 314
static void zconf_load_buffer_state(void) ;
#line 315
static void zconf_init_buffer(YY_BUFFER_STATE b , FILE *file ) ;
#line 319
YY_BUFFER_STATE zconf_scan_buffer(char *base , yy_size_t size ) ;
#line 320
YY_BUFFER_STATE zconf_scan_string(char const   *yystr ) ;
#line 321
YY_BUFFER_STATE zconf_scan_bytes(char const   *yybytes , int _yybytes_len ) ;
#line 323
void *zconfalloc(yy_size_t size ) ;
#line 324
void *zconfrealloc(void *ptr , yy_size_t size ) ;
#line 325
void zconffree(void *ptr ) ;
#line 358 "scripts/kconfig/zconf.lex.c_shipped"
FILE *zconfin  =    (FILE *)0;
#line 358 "scripts/kconfig/zconf.lex.c_shipped"
FILE *zconfout  =    (FILE *)0;
#line 362
int zconflineno ;
#line 364 "scripts/kconfig/zconf.lex.c_shipped"
int zconflineno  =    1;
#line 366 "scripts/kconfig/zconf.lex.c_shipped"
char *zconftext  ;
#line 368 "scripts/kconfig/zconf.lex.c_shipped"
static flex_int16_t const   yy_nxt[61][17]  = 
#line 368
  { {        (flex_int16_t const   )0,        (flex_int16_t const   )0,        (flex_int16_t const   )0,        (flex_int16_t const   )0, 
            (flex_int16_t const   )0,        (flex_int16_t const   )0,        (flex_int16_t const   )0,        (flex_int16_t const   )0, 
            (flex_int16_t const   )0,        (flex_int16_t const   )0,        (flex_int16_t const   )0,        (flex_int16_t const   )0, 
            (flex_int16_t const   )0,        (flex_int16_t const   )0,        (flex_int16_t const   )0,        (flex_int16_t const   )0, 
            (flex_int16_t const   )0}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )12,        (flex_int16_t const   )13,        (flex_int16_t const   )14, 
            (flex_int16_t const   )12,        (flex_int16_t const   )12,        (flex_int16_t const   )15,        (flex_int16_t const   )12, 
            (flex_int16_t const   )12,        (flex_int16_t const   )12,        (flex_int16_t const   )12,        (flex_int16_t const   )12, 
            (flex_int16_t const   )12,        (flex_int16_t const   )12,        (flex_int16_t const   )12,        (flex_int16_t const   )12, 
            (flex_int16_t const   )12}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )12,        (flex_int16_t const   )13,        (flex_int16_t const   )14, 
            (flex_int16_t const   )12,        (flex_int16_t const   )12,        (flex_int16_t const   )15,        (flex_int16_t const   )12, 
            (flex_int16_t const   )12,        (flex_int16_t const   )12,        (flex_int16_t const   )12,        (flex_int16_t const   )12, 
            (flex_int16_t const   )12,        (flex_int16_t const   )12,        (flex_int16_t const   )12,        (flex_int16_t const   )12, 
            (flex_int16_t const   )12}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )16,        (flex_int16_t const   )16,        (flex_int16_t const   )17, 
            (flex_int16_t const   )16,        (flex_int16_t const   )16,        (flex_int16_t const   )16,        (flex_int16_t const   )16, 
            (flex_int16_t const   )16,        (flex_int16_t const   )16,        (flex_int16_t const   )16,        (flex_int16_t const   )16, 
            (flex_int16_t const   )16,        (flex_int16_t const   )18,        (flex_int16_t const   )16,        (flex_int16_t const   )16, 
            (flex_int16_t const   )16}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )16,        (flex_int16_t const   )16,        (flex_int16_t const   )17, 
            (flex_int16_t const   )16,        (flex_int16_t const   )16,        (flex_int16_t const   )16,        (flex_int16_t const   )16, 
            (flex_int16_t const   )16,        (flex_int16_t const   )16,        (flex_int16_t const   )16,        (flex_int16_t const   )16, 
            (flex_int16_t const   )16,        (flex_int16_t const   )18,        (flex_int16_t const   )16,        (flex_int16_t const   )16, 
            (flex_int16_t const   )16}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )19,        (flex_int16_t const   )20,        (flex_int16_t const   )21, 
            (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19, 
            (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19, 
            (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19, 
            (flex_int16_t const   )19}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )19,        (flex_int16_t const   )20,        (flex_int16_t const   )21, 
            (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19, 
            (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19, 
            (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19, 
            (flex_int16_t const   )19}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )22,        (flex_int16_t const   )22,        (flex_int16_t const   )23, 
            (flex_int16_t const   )22,        (flex_int16_t const   )24,        (flex_int16_t const   )22,        (flex_int16_t const   )22, 
            (flex_int16_t const   )24,        (flex_int16_t const   )22,        (flex_int16_t const   )22,        (flex_int16_t const   )22, 
            (flex_int16_t const   )22,        (flex_int16_t const   )22,        (flex_int16_t const   )22,        (flex_int16_t const   )25, 
            (flex_int16_t const   )22}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )22,        (flex_int16_t const   )22,        (flex_int16_t const   )23, 
            (flex_int16_t const   )22,        (flex_int16_t const   )24,        (flex_int16_t const   )22,        (flex_int16_t const   )22, 
            (flex_int16_t const   )24,        (flex_int16_t const   )22,        (flex_int16_t const   )22,        (flex_int16_t const   )22, 
            (flex_int16_t const   )22,        (flex_int16_t const   )22,        (flex_int16_t const   )22,        (flex_int16_t const   )25, 
            (flex_int16_t const   )22}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )26,        (flex_int16_t const   )26,        (flex_int16_t const   )27, 
            (flex_int16_t const   )28,        (flex_int16_t const   )29,        (flex_int16_t const   )30,        (flex_int16_t const   )31, 
            (flex_int16_t const   )29,        (flex_int16_t const   )32,        (flex_int16_t const   )33,        (flex_int16_t const   )34, 
            (flex_int16_t const   )35,        (flex_int16_t const   )35,        (flex_int16_t const   )36,        (flex_int16_t const   )37, 
            (flex_int16_t const   )38}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )26,        (flex_int16_t const   )26,        (flex_int16_t const   )27, 
            (flex_int16_t const   )28,        (flex_int16_t const   )29,        (flex_int16_t const   )30,        (flex_int16_t const   )31, 
            (flex_int16_t const   )29,        (flex_int16_t const   )32,        (flex_int16_t const   )33,        (flex_int16_t const   )34, 
            (flex_int16_t const   )35,        (flex_int16_t const   )35,        (flex_int16_t const   )36,        (flex_int16_t const   )37, 
            (flex_int16_t const   )38}, 
   {        (flex_int16_t const   )-11,        (flex_int16_t const   )-11,        (flex_int16_t const   )-11,        (flex_int16_t const   )-11, 
            (flex_int16_t const   )-11,        (flex_int16_t const   )-11,        (flex_int16_t const   )-11,        (flex_int16_t const   )-11, 
            (flex_int16_t const   )-11,        (flex_int16_t const   )-11,        (flex_int16_t const   )-11,        (flex_int16_t const   )-11, 
            (flex_int16_t const   )-11,        (flex_int16_t const   )-11,        (flex_int16_t const   )-11,        (flex_int16_t const   )-11, 
            (flex_int16_t const   )-11}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-12,        (flex_int16_t const   )-12,        (flex_int16_t const   )-12, 
            (flex_int16_t const   )-12,        (flex_int16_t const   )-12,        (flex_int16_t const   )-12,        (flex_int16_t const   )-12, 
            (flex_int16_t const   )-12,        (flex_int16_t const   )-12,        (flex_int16_t const   )-12,        (flex_int16_t const   )-12, 
            (flex_int16_t const   )-12,        (flex_int16_t const   )-12,        (flex_int16_t const   )-12,        (flex_int16_t const   )-12, 
            (flex_int16_t const   )-12}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-13,        (flex_int16_t const   )39,        (flex_int16_t const   )40, 
            (flex_int16_t const   )-13,        (flex_int16_t const   )-13,        (flex_int16_t const   )41,        (flex_int16_t const   )-13, 
            (flex_int16_t const   )-13,        (flex_int16_t const   )-13,        (flex_int16_t const   )-13,        (flex_int16_t const   )-13, 
            (flex_int16_t const   )-13,        (flex_int16_t const   )-13,        (flex_int16_t const   )-13,        (flex_int16_t const   )-13, 
            (flex_int16_t const   )-13}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-14,        (flex_int16_t const   )-14,        (flex_int16_t const   )-14, 
            (flex_int16_t const   )-14,        (flex_int16_t const   )-14,        (flex_int16_t const   )-14,        (flex_int16_t const   )-14, 
            (flex_int16_t const   )-14,        (flex_int16_t const   )-14,        (flex_int16_t const   )-14,        (flex_int16_t const   )-14, 
            (flex_int16_t const   )-14,        (flex_int16_t const   )-14,        (flex_int16_t const   )-14,        (flex_int16_t const   )-14, 
            (flex_int16_t const   )-14}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )43, 
            (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42, 
            (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42, 
            (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42, 
            (flex_int16_t const   )42}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-16,        (flex_int16_t const   )-16,        (flex_int16_t const   )-16, 
            (flex_int16_t const   )-16,        (flex_int16_t const   )-16,        (flex_int16_t const   )-16,        (flex_int16_t const   )-16, 
            (flex_int16_t const   )-16,        (flex_int16_t const   )-16,        (flex_int16_t const   )-16,        (flex_int16_t const   )-16, 
            (flex_int16_t const   )-16,        (flex_int16_t const   )-16,        (flex_int16_t const   )-16,        (flex_int16_t const   )-16, 
            (flex_int16_t const   )-16}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-17,        (flex_int16_t const   )-17,        (flex_int16_t const   )-17, 
            (flex_int16_t const   )-17,        (flex_int16_t const   )-17,        (flex_int16_t const   )-17,        (flex_int16_t const   )-17, 
            (flex_int16_t const   )-17,        (flex_int16_t const   )-17,        (flex_int16_t const   )-17,        (flex_int16_t const   )-17, 
            (flex_int16_t const   )-17,        (flex_int16_t const   )-17,        (flex_int16_t const   )-17,        (flex_int16_t const   )-17, 
            (flex_int16_t const   )-17}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-18,        (flex_int16_t const   )-18,        (flex_int16_t const   )-18, 
            (flex_int16_t const   )-18,        (flex_int16_t const   )-18,        (flex_int16_t const   )-18,        (flex_int16_t const   )-18, 
            (flex_int16_t const   )-18,        (flex_int16_t const   )-18,        (flex_int16_t const   )-18,        (flex_int16_t const   )-18, 
            (flex_int16_t const   )-18,        (flex_int16_t const   )44,        (flex_int16_t const   )-18,        (flex_int16_t const   )-18, 
            (flex_int16_t const   )-18}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )-19, 
            (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45, 
            (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45, 
            (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45, 
            (flex_int16_t const   )45}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-20,        (flex_int16_t const   )46,        (flex_int16_t const   )47, 
            (flex_int16_t const   )-20,        (flex_int16_t const   )-20,        (flex_int16_t const   )-20,        (flex_int16_t const   )-20, 
            (flex_int16_t const   )-20,        (flex_int16_t const   )-20,        (flex_int16_t const   )-20,        (flex_int16_t const   )-20, 
            (flex_int16_t const   )-20,        (flex_int16_t const   )-20,        (flex_int16_t const   )-20,        (flex_int16_t const   )-20, 
            (flex_int16_t const   )-20}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )48,        (flex_int16_t const   )-21,        (flex_int16_t const   )-21, 
            (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48, 
            (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48, 
            (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48, 
            (flex_int16_t const   )48}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )49,        (flex_int16_t const   )49,        (flex_int16_t const   )50, 
            (flex_int16_t const   )49,        (flex_int16_t const   )-22,        (flex_int16_t const   )49,        (flex_int16_t const   )49, 
            (flex_int16_t const   )-22,        (flex_int16_t const   )49,        (flex_int16_t const   )49,        (flex_int16_t const   )49, 
            (flex_int16_t const   )49,        (flex_int16_t const   )49,        (flex_int16_t const   )49,        (flex_int16_t const   )-22, 
            (flex_int16_t const   )49}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-23,        (flex_int16_t const   )-23,        (flex_int16_t const   )-23, 
            (flex_int16_t const   )-23,        (flex_int16_t const   )-23,        (flex_int16_t const   )-23,        (flex_int16_t const   )-23, 
            (flex_int16_t const   )-23,        (flex_int16_t const   )-23,        (flex_int16_t const   )-23,        (flex_int16_t const   )-23, 
            (flex_int16_t const   )-23,        (flex_int16_t const   )-23,        (flex_int16_t const   )-23,        (flex_int16_t const   )-23, 
            (flex_int16_t const   )-23}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-24,        (flex_int16_t const   )-24,        (flex_int16_t const   )-24, 
            (flex_int16_t const   )-24,        (flex_int16_t const   )-24,        (flex_int16_t const   )-24,        (flex_int16_t const   )-24, 
            (flex_int16_t const   )-24,        (flex_int16_t const   )-24,        (flex_int16_t const   )-24,        (flex_int16_t const   )-24, 
            (flex_int16_t const   )-24,        (flex_int16_t const   )-24,        (flex_int16_t const   )-24,        (flex_int16_t const   )-24, 
            (flex_int16_t const   )-24}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )51,        (flex_int16_t const   )51,        (flex_int16_t const   )52, 
            (flex_int16_t const   )51,        (flex_int16_t const   )51,        (flex_int16_t const   )51,        (flex_int16_t const   )51, 
            (flex_int16_t const   )51,        (flex_int16_t const   )51,        (flex_int16_t const   )51,        (flex_int16_t const   )51, 
            (flex_int16_t const   )51,        (flex_int16_t const   )51,        (flex_int16_t const   )51,        (flex_int16_t const   )51, 
            (flex_int16_t const   )51}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-26,        (flex_int16_t const   )-26,        (flex_int16_t const   )-26, 
            (flex_int16_t const   )-26,        (flex_int16_t const   )-26,        (flex_int16_t const   )-26,        (flex_int16_t const   )-26, 
            (flex_int16_t const   )-26,        (flex_int16_t const   )-26,        (flex_int16_t const   )-26,        (flex_int16_t const   )-26, 
            (flex_int16_t const   )-26,        (flex_int16_t const   )-26,        (flex_int16_t const   )-26,        (flex_int16_t const   )-26, 
            (flex_int16_t const   )-26}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-27,        (flex_int16_t const   )-27,        (flex_int16_t const   )-27, 
            (flex_int16_t const   )-27,        (flex_int16_t const   )-27,        (flex_int16_t const   )-27,        (flex_int16_t const   )-27, 
            (flex_int16_t const   )-27,        (flex_int16_t const   )-27,        (flex_int16_t const   )-27,        (flex_int16_t const   )-27, 
            (flex_int16_t const   )-27,        (flex_int16_t const   )-27,        (flex_int16_t const   )-27,        (flex_int16_t const   )-27, 
            (flex_int16_t const   )-27}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-28,        (flex_int16_t const   )-28,        (flex_int16_t const   )-28, 
            (flex_int16_t const   )-28,        (flex_int16_t const   )-28,        (flex_int16_t const   )-28,        (flex_int16_t const   )-28, 
            (flex_int16_t const   )-28,        (flex_int16_t const   )-28,        (flex_int16_t const   )-28,        (flex_int16_t const   )-28, 
            (flex_int16_t const   )-28,        (flex_int16_t const   )-28,        (flex_int16_t const   )53,        (flex_int16_t const   )-28, 
            (flex_int16_t const   )-28}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-29,        (flex_int16_t const   )-29,        (flex_int16_t const   )-29, 
            (flex_int16_t const   )-29,        (flex_int16_t const   )-29,        (flex_int16_t const   )-29,        (flex_int16_t const   )-29, 
            (flex_int16_t const   )-29,        (flex_int16_t const   )-29,        (flex_int16_t const   )-29,        (flex_int16_t const   )-29, 
            (flex_int16_t const   )-29,        (flex_int16_t const   )-29,        (flex_int16_t const   )-29,        (flex_int16_t const   )-29, 
            (flex_int16_t const   )-29}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )-30, 
            (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )54, 
            (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )54, 
            (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )54, 
            (flex_int16_t const   )54}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-31,        (flex_int16_t const   )-31,        (flex_int16_t const   )-31, 
            (flex_int16_t const   )-31,        (flex_int16_t const   )-31,        (flex_int16_t const   )-31,        (flex_int16_t const   )55, 
            (flex_int16_t const   )-31,        (flex_int16_t const   )-31,        (flex_int16_t const   )-31,        (flex_int16_t const   )-31, 
            (flex_int16_t const   )-31,        (flex_int16_t const   )-31,        (flex_int16_t const   )-31,        (flex_int16_t const   )-31, 
            (flex_int16_t const   )-31}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-32,        (flex_int16_t const   )-32,        (flex_int16_t const   )-32, 
            (flex_int16_t const   )-32,        (flex_int16_t const   )-32,        (flex_int16_t const   )-32,        (flex_int16_t const   )-32, 
            (flex_int16_t const   )-32,        (flex_int16_t const   )-32,        (flex_int16_t const   )-32,        (flex_int16_t const   )-32, 
            (flex_int16_t const   )-32,        (flex_int16_t const   )-32,        (flex_int16_t const   )-32,        (flex_int16_t const   )-32, 
            (flex_int16_t const   )-32}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-33,        (flex_int16_t const   )-33,        (flex_int16_t const   )-33, 
            (flex_int16_t const   )-33,        (flex_int16_t const   )-33,        (flex_int16_t const   )-33,        (flex_int16_t const   )-33, 
            (flex_int16_t const   )-33,        (flex_int16_t const   )-33,        (flex_int16_t const   )-33,        (flex_int16_t const   )-33, 
            (flex_int16_t const   )-33,        (flex_int16_t const   )-33,        (flex_int16_t const   )-33,        (flex_int16_t const   )-33, 
            (flex_int16_t const   )-33}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-34,        (flex_int16_t const   )-34,        (flex_int16_t const   )-34, 
            (flex_int16_t const   )-34,        (flex_int16_t const   )-34,        (flex_int16_t const   )-34,        (flex_int16_t const   )-34, 
            (flex_int16_t const   )-34,        (flex_int16_t const   )-34,        (flex_int16_t const   )-34,        (flex_int16_t const   )56, 
            (flex_int16_t const   )57,        (flex_int16_t const   )57,        (flex_int16_t const   )-34,        (flex_int16_t const   )-34, 
            (flex_int16_t const   )-34}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-35,        (flex_int16_t const   )-35,        (flex_int16_t const   )-35, 
            (flex_int16_t const   )-35,        (flex_int16_t const   )-35,        (flex_int16_t const   )-35,        (flex_int16_t const   )-35, 
            (flex_int16_t const   )-35,        (flex_int16_t const   )-35,        (flex_int16_t const   )-35,        (flex_int16_t const   )57, 
            (flex_int16_t const   )57,        (flex_int16_t const   )57,        (flex_int16_t const   )-35,        (flex_int16_t const   )-35, 
            (flex_int16_t const   )-35}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-36,        (flex_int16_t const   )-36,        (flex_int16_t const   )-36, 
            (flex_int16_t const   )-36,        (flex_int16_t const   )-36,        (flex_int16_t const   )-36,        (flex_int16_t const   )-36, 
            (flex_int16_t const   )-36,        (flex_int16_t const   )-36,        (flex_int16_t const   )-36,        (flex_int16_t const   )-36, 
            (flex_int16_t const   )-36,        (flex_int16_t const   )-36,        (flex_int16_t const   )-36,        (flex_int16_t const   )-36, 
            (flex_int16_t const   )-36}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-37,        (flex_int16_t const   )-37,        (flex_int16_t const   )58, 
            (flex_int16_t const   )-37,        (flex_int16_t const   )-37,        (flex_int16_t const   )-37,        (flex_int16_t const   )-37, 
            (flex_int16_t const   )-37,        (flex_int16_t const   )-37,        (flex_int16_t const   )-37,        (flex_int16_t const   )-37, 
            (flex_int16_t const   )-37,        (flex_int16_t const   )-37,        (flex_int16_t const   )-37,        (flex_int16_t const   )-37, 
            (flex_int16_t const   )-37}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-38,        (flex_int16_t const   )-38,        (flex_int16_t const   )-38, 
            (flex_int16_t const   )-38,        (flex_int16_t const   )-38,        (flex_int16_t const   )-38,        (flex_int16_t const   )-38, 
            (flex_int16_t const   )-38,        (flex_int16_t const   )-38,        (flex_int16_t const   )-38,        (flex_int16_t const   )-38, 
            (flex_int16_t const   )-38,        (flex_int16_t const   )-38,        (flex_int16_t const   )-38,        (flex_int16_t const   )-38, 
            (flex_int16_t const   )59}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-39,        (flex_int16_t const   )39,        (flex_int16_t const   )40, 
            (flex_int16_t const   )-39,        (flex_int16_t const   )-39,        (flex_int16_t const   )41,        (flex_int16_t const   )-39, 
            (flex_int16_t const   )-39,        (flex_int16_t const   )-39,        (flex_int16_t const   )-39,        (flex_int16_t const   )-39, 
            (flex_int16_t const   )-39,        (flex_int16_t const   )-39,        (flex_int16_t const   )-39,        (flex_int16_t const   )-39, 
            (flex_int16_t const   )-39}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-40,        (flex_int16_t const   )-40,        (flex_int16_t const   )-40, 
            (flex_int16_t const   )-40,        (flex_int16_t const   )-40,        (flex_int16_t const   )-40,        (flex_int16_t const   )-40, 
            (flex_int16_t const   )-40,        (flex_int16_t const   )-40,        (flex_int16_t const   )-40,        (flex_int16_t const   )-40, 
            (flex_int16_t const   )-40,        (flex_int16_t const   )-40,        (flex_int16_t const   )-40,        (flex_int16_t const   )-40, 
            (flex_int16_t const   )-40}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )43, 
            (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42, 
            (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42, 
            (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42, 
            (flex_int16_t const   )42}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )43, 
            (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42, 
            (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42, 
            (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42, 
            (flex_int16_t const   )42}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-43,        (flex_int16_t const   )-43,        (flex_int16_t const   )-43, 
            (flex_int16_t const   )-43,        (flex_int16_t const   )-43,        (flex_int16_t const   )-43,        (flex_int16_t const   )-43, 
            (flex_int16_t const   )-43,        (flex_int16_t const   )-43,        (flex_int16_t const   )-43,        (flex_int16_t const   )-43, 
            (flex_int16_t const   )-43,        (flex_int16_t const   )-43,        (flex_int16_t const   )-43,        (flex_int16_t const   )-43, 
            (flex_int16_t const   )-43}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-44,        (flex_int16_t const   )-44,        (flex_int16_t const   )-44, 
            (flex_int16_t const   )-44,        (flex_int16_t const   )-44,        (flex_int16_t const   )-44,        (flex_int16_t const   )-44, 
            (flex_int16_t const   )-44,        (flex_int16_t const   )-44,        (flex_int16_t const   )-44,        (flex_int16_t const   )-44, 
            (flex_int16_t const   )-44,        (flex_int16_t const   )44,        (flex_int16_t const   )-44,        (flex_int16_t const   )-44, 
            (flex_int16_t const   )-44}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )-45, 
            (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45, 
            (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45, 
            (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45, 
            (flex_int16_t const   )45}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-46,        (flex_int16_t const   )46,        (flex_int16_t const   )47, 
            (flex_int16_t const   )-46,        (flex_int16_t const   )-46,        (flex_int16_t const   )-46,        (flex_int16_t const   )-46, 
            (flex_int16_t const   )-46,        (flex_int16_t const   )-46,        (flex_int16_t const   )-46,        (flex_int16_t const   )-46, 
            (flex_int16_t const   )-46,        (flex_int16_t const   )-46,        (flex_int16_t const   )-46,        (flex_int16_t const   )-46, 
            (flex_int16_t const   )-46}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )48,        (flex_int16_t const   )-47,        (flex_int16_t const   )-47, 
            (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48, 
            (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48, 
            (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48, 
            (flex_int16_t const   )48}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-48,        (flex_int16_t const   )-48,        (flex_int16_t const   )-48, 
            (flex_int16_t const   )-48,        (flex_int16_t const   )-48,        (flex_int16_t const   )-48,        (flex_int16_t const   )-48, 
            (flex_int16_t const   )-48,        (flex_int16_t const   )-48,        (flex_int16_t const   )-48,        (flex_int16_t const   )-48, 
            (flex_int16_t const   )-48,        (flex_int16_t const   )-48,        (flex_int16_t const   )-48,        (flex_int16_t const   )-48, 
            (flex_int16_t const   )-48}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )49,        (flex_int16_t const   )49,        (flex_int16_t const   )50, 
            (flex_int16_t const   )49,        (flex_int16_t const   )-49,        (flex_int16_t const   )49,        (flex_int16_t const   )49, 
            (flex_int16_t const   )-49,        (flex_int16_t const   )49,        (flex_int16_t const   )49,        (flex_int16_t const   )49, 
            (flex_int16_t const   )49,        (flex_int16_t const   )49,        (flex_int16_t const   )49,        (flex_int16_t const   )-49, 
            (flex_int16_t const   )49}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-50,        (flex_int16_t const   )-50,        (flex_int16_t const   )-50, 
            (flex_int16_t const   )-50,        (flex_int16_t const   )-50,        (flex_int16_t const   )-50,        (flex_int16_t const   )-50, 
            (flex_int16_t const   )-50,        (flex_int16_t const   )-50,        (flex_int16_t const   )-50,        (flex_int16_t const   )-50, 
            (flex_int16_t const   )-50,        (flex_int16_t const   )-50,        (flex_int16_t const   )-50,        (flex_int16_t const   )-50, 
            (flex_int16_t const   )-50}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-51,        (flex_int16_t const   )-51,        (flex_int16_t const   )52, 
            (flex_int16_t const   )-51,        (flex_int16_t const   )-51,        (flex_int16_t const   )-51,        (flex_int16_t const   )-51, 
            (flex_int16_t const   )-51,        (flex_int16_t const   )-51,        (flex_int16_t const   )-51,        (flex_int16_t const   )-51, 
            (flex_int16_t const   )-51,        (flex_int16_t const   )-51,        (flex_int16_t const   )-51,        (flex_int16_t const   )-51, 
            (flex_int16_t const   )-51}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-52,        (flex_int16_t const   )-52,        (flex_int16_t const   )-52, 
            (flex_int16_t const   )-52,        (flex_int16_t const   )-52,        (flex_int16_t const   )-52,        (flex_int16_t const   )-52, 
            (flex_int16_t const   )-52,        (flex_int16_t const   )-52,        (flex_int16_t const   )-52,        (flex_int16_t const   )-52, 
            (flex_int16_t const   )-52,        (flex_int16_t const   )-52,        (flex_int16_t const   )-52,        (flex_int16_t const   )-52, 
            (flex_int16_t const   )-52}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-53,        (flex_int16_t const   )-53,        (flex_int16_t const   )-53, 
            (flex_int16_t const   )-53,        (flex_int16_t const   )-53,        (flex_int16_t const   )-53,        (flex_int16_t const   )-53, 
            (flex_int16_t const   )-53,        (flex_int16_t const   )-53,        (flex_int16_t const   )-53,        (flex_int16_t const   )-53, 
            (flex_int16_t const   )-53,        (flex_int16_t const   )-53,        (flex_int16_t const   )-53,        (flex_int16_t const   )-53, 
            (flex_int16_t const   )-53}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )-54, 
            (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )54, 
            (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )54, 
            (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )54, 
            (flex_int16_t const   )54}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-55,        (flex_int16_t const   )-55,        (flex_int16_t const   )-55, 
            (flex_int16_t const   )-55,        (flex_int16_t const   )-55,        (flex_int16_t const   )-55,        (flex_int16_t const   )-55, 
            (flex_int16_t const   )-55,        (flex_int16_t const   )-55,        (flex_int16_t const   )-55,        (flex_int16_t const   )-55, 
            (flex_int16_t const   )-55,        (flex_int16_t const   )-55,        (flex_int16_t const   )-55,        (flex_int16_t const   )-55, 
            (flex_int16_t const   )-55}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-56,        (flex_int16_t const   )-56,        (flex_int16_t const   )-56, 
            (flex_int16_t const   )-56,        (flex_int16_t const   )-56,        (flex_int16_t const   )-56,        (flex_int16_t const   )-56, 
            (flex_int16_t const   )-56,        (flex_int16_t const   )-56,        (flex_int16_t const   )-56,        (flex_int16_t const   )60, 
            (flex_int16_t const   )57,        (flex_int16_t const   )57,        (flex_int16_t const   )-56,        (flex_int16_t const   )-56, 
            (flex_int16_t const   )-56}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-57,        (flex_int16_t const   )-57,        (flex_int16_t const   )-57, 
            (flex_int16_t const   )-57,        (flex_int16_t const   )-57,        (flex_int16_t const   )-57,        (flex_int16_t const   )-57, 
            (flex_int16_t const   )-57,        (flex_int16_t const   )-57,        (flex_int16_t const   )-57,        (flex_int16_t const   )57, 
            (flex_int16_t const   )57,        (flex_int16_t const   )57,        (flex_int16_t const   )-57,        (flex_int16_t const   )-57, 
            (flex_int16_t const   )-57}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-58,        (flex_int16_t const   )-58,        (flex_int16_t const   )-58, 
            (flex_int16_t const   )-58,        (flex_int16_t const   )-58,        (flex_int16_t const   )-58,        (flex_int16_t const   )-58, 
            (flex_int16_t const   )-58,        (flex_int16_t const   )-58,        (flex_int16_t const   )-58,        (flex_int16_t const   )-58, 
            (flex_int16_t const   )-58,        (flex_int16_t const   )-58,        (flex_int16_t const   )-58,        (flex_int16_t const   )-58, 
            (flex_int16_t const   )-58}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-59,        (flex_int16_t const   )-59,        (flex_int16_t const   )-59, 
            (flex_int16_t const   )-59,        (flex_int16_t const   )-59,        (flex_int16_t const   )-59,        (flex_int16_t const   )-59, 
            (flex_int16_t const   )-59,        (flex_int16_t const   )-59,        (flex_int16_t const   )-59,        (flex_int16_t const   )-59, 
            (flex_int16_t const   )-59,        (flex_int16_t const   )-59,        (flex_int16_t const   )-59,        (flex_int16_t const   )-59, 
            (flex_int16_t const   )-59}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-60,        (flex_int16_t const   )-60,        (flex_int16_t const   )-60, 
            (flex_int16_t const   )-60,        (flex_int16_t const   )-60,        (flex_int16_t const   )-60,        (flex_int16_t const   )-60, 
            (flex_int16_t const   )-60,        (flex_int16_t const   )-60,        (flex_int16_t const   )-60,        (flex_int16_t const   )57, 
            (flex_int16_t const   )57,        (flex_int16_t const   )57,        (flex_int16_t const   )-60,        (flex_int16_t const   )-60, 
            (flex_int16_t const   )-60}};
#line 689
static yy_state_type yy_get_previous_state(void) ;
#line 690
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) ;
#line 691
static int yy_get_next_buffer(void) ;
#line 692
static void yy_fatal_error(char const   *msg ) ;
#line 713 "scripts/kconfig/zconf.lex.c_shipped"
static flex_int16_t const   yy_accept[61]  = 
#line 713
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )34, 
        (flex_int16_t const   )5,      (flex_int16_t const   )4,      (flex_int16_t const   )2,      (flex_int16_t const   )3, 
        (flex_int16_t const   )7,      (flex_int16_t const   )8,      (flex_int16_t const   )6,      (flex_int16_t const   )32, 
        (flex_int16_t const   )29,      (flex_int16_t const   )31,      (flex_int16_t const   )24,      (flex_int16_t const   )28, 
        (flex_int16_t const   )27,      (flex_int16_t const   )26,      (flex_int16_t const   )22,      (flex_int16_t const   )17, 
        (flex_int16_t const   )13,      (flex_int16_t const   )16,      (flex_int16_t const   )20,      (flex_int16_t const   )22, 
        (flex_int16_t const   )11,      (flex_int16_t const   )12,      (flex_int16_t const   )19,      (flex_int16_t const   )19, 
        (flex_int16_t const   )14,      (flex_int16_t const   )22,      (flex_int16_t const   )22,      (flex_int16_t const   )4, 
        (flex_int16_t const   )2,      (flex_int16_t const   )3,      (flex_int16_t const   )3,      (flex_int16_t const   )1, 
        (flex_int16_t const   )6,      (flex_int16_t const   )32,      (flex_int16_t const   )29,      (flex_int16_t const   )31, 
        (flex_int16_t const   )30,      (flex_int16_t const   )24,      (flex_int16_t const   )23,      (flex_int16_t const   )26, 
        (flex_int16_t const   )25,      (flex_int16_t const   )15,      (flex_int16_t const   )20,      (flex_int16_t const   )9, 
        (flex_int16_t const   )19,      (flex_int16_t const   )19,      (flex_int16_t const   )21,      (flex_int16_t const   )10, 
        (flex_int16_t const   )18};
#line 723 "scripts/kconfig/zconf.lex.c_shipped"
static flex_int32_t const   yy_ec[256]  = 
#line 723
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )3,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )2,      (flex_int32_t const   )4,      (flex_int32_t const   )5,      (flex_int32_t const   )6, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )7,      (flex_int32_t const   )8, 
        (flex_int32_t const   )9,      (flex_int32_t const   )10,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )11,      (flex_int32_t const   )12,      (flex_int32_t const   )12, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )14,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )1, 
        (flex_int32_t const   )15,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )13, 
        (flex_int32_t const   )1,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )1, 
        (flex_int32_t const   )16,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1};
#line 755
int zconf_flex_debug ;
#line 756 "scripts/kconfig/zconf.lex.c_shipped"
int zconf_flex_debug  =    0;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 783 "scripts/kconfig/zconf.lex.c_shipped"
static struct __anonstruct_current_pos_31 current_pos  ;
#line 788 "scripts/kconfig/zconf.lex.c_shipped"
static char *text  ;
#line 789 "scripts/kconfig/zconf.lex.c_shipped"
static int text_size  ;
#line 789 "scripts/kconfig/zconf.lex.c_shipped"
static int text_asize  ;
#line 796 "scripts/kconfig/zconf.lex.c_shipped"
struct buffer *current_buf  ;
#line 798 "scripts/kconfig/zconf.lex.c_shipped"
static int last_ts  ;
#line 798 "scripts/kconfig/zconf.lex.c_shipped"
static int first_ts  ;
#line 800
static void zconf_endhelp(void) ;
#line 801
static void zconf_endfile(void) ;
#line 803 "scripts/kconfig/zconf.lex.c_shipped"
static void new_string(void) 
{ 
  void *tmp ;

  {
  {
#line 805
  tmp = xmalloc((size_t )16);
#line 805
  text = (char *)tmp;
#line 806
  text_asize = 16;
#line 807
  text_size = 0;
#line 808
  *text = (char)0;
  }
#line 809
  return;
}
}
#line 811 "scripts/kconfig/zconf.lex.c_shipped"
static void append_string(char const   *str , int size ) 
{ 
  int new_size ;
  void *tmp ;

  {
#line 813
  new_size = (text_size + size) + 1;
#line 814
  if (new_size > text_asize) {
    {
#line 815
    new_size += 15;
#line 816
    new_size &= -16;
#line 817
    tmp = realloc((void *)text, (size_t )new_size);
#line 817
    text = (char *)tmp;
#line 818
    text_asize = new_size;
    }
  }
  {
#line 820
  memcpy((void */* __restrict  */)(text + text_size), (void const   */* __restrict  */)str,
         (size_t )size);
#line 821
  text_size += size;
#line 822
  *(text + text_size) = (char)0;
  }
#line 823
  return;
}
}
#line 825 "scripts/kconfig/zconf.lex.c_shipped"
static void alloc_string(char const   *str , int size ) 
{ 
  void *tmp ;

  {
  {
#line 827
  tmp = xmalloc((size_t )(size + 1));
#line 827
  text = (char *)tmp;
#line 828
  memcpy((void */* __restrict  */)text, (void const   */* __restrict  */)str, (size_t )size);
#line 829
  *(text + size) = (char)0;
  }
#line 830
  return;
}
}
#line 850
static int yy_init_globals(void) ;
#line 855
int zconflex_destroy(void) ;
#line 857
int zconfget_debug(void) ;
#line 859
void zconfset_debug(int bdebug ) ;
#line 865
FILE *zconfget_in(void) ;
#line 867
void zconfset_in(FILE *in_str ) ;
#line 869
FILE *zconfget_out(void) ;
#line 871
void zconfset_out(FILE *out_str ) ;
#line 873
int zconfget_leng(void) ;
#line 875
char *zconfget_text(void) ;
#line 877
int zconfget_lineno(void) ;
#line 879
void zconfset_lineno(int line_number ) ;
#line 893
static void yyunput(int c , char *yy_bp ) ;
#line 994 "scripts/kconfig/zconf.lex.c_shipped"
int zconflex(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register char *yy_bp ;
  register int yy_act ;
  int str ;
  int ts ;
  int i ;
  YY_BUFFER_STATE tmp ;
  struct kconf_id  const  *id ;
  struct kconf_id  const __attribute__((__gnu_inline__)) *tmp___0 ;
  struct kconf_id  const  *id___0 ;
  struct kconf_id  const __attribute__((__gnu_inline__)) *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int yy_amount_of_matched_text ;
  yy_state_type yy_next_state ;
  int tmp___4 ;

  {
#line 1000
  str = 0;
#line 1003
  if (! yy_init) {
#line 1005
    yy_init = 1;
#line 1011
    if (! yy_start) {
#line 1012
      yy_start = 1;
    }
#line 1014
    if (! zconfin) {
#line 1015
      zconfin = stdin;
    }
#line 1017
    if (! zconfout) {
#line 1018
      zconfout = stdout;
    }
#line 1020
    if (yy_buffer_stack) {
#line 1020
      tmp = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 1020
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
#line 1020
    if (! tmp) {
      {
#line 1021
      zconfensure_buffer_stack();
#line 1022
      *(yy_buffer_stack + yy_buffer_stack_top) = zconf_create_buffer(zconfin, 16384);
      }
    }
    {
#line 1026
    zconf_load_buffer_state();
    }
  }
  {
#line 1029
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1031
    yy_cp = yy_c_buf_p;
#line 1034
    *yy_cp = yy_hold_char;
#line 1039
    yy_bp = yy_cp;
#line 1041
    yy_current_state = yy_start;
    yy_match: 
    {
#line 1043
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1043
      yy_current_state = (yy_state_type )yy_nxt[yy_current_state][yy_ec[(unsigned int )((unsigned char )*yy_cp)]];
#line 1043
      if (! (yy_current_state > 0)) {
#line 1043
        goto while_break___0;
      }
#line 1044
      yy_cp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1046
    yy_current_state = - yy_current_state;
    yy_find_action: 
#line 1049
    yy_act = (int )yy_accept[yy_current_state];
#line 1051
    zconftext = yy_bp;
#line 1051
    zconfleng = (int )((size_t )(yy_cp - yy_bp));
#line 1051
    yy_hold_char = *yy_cp;
#line 1051
    *yy_cp = (char )'\000';
#line 1051
    yy_c_buf_p = yy_cp;
    do_action: 
    {
#line 1059
    if (yy_act == 2) {
#line 1059
      goto case_2;
    }
#line 1059
    if (yy_act == 1) {
#line 1059
      goto case_2;
    }
#line 1067
    if (yy_act == 3) {
#line 1067
      goto case_3;
    }
#line 1071
    if (yy_act == 4) {
#line 1071
      goto case_4;
    }
#line 1077
    if (yy_act == 5) {
#line 1077
      goto case_5;
    }
#line 1085
    if (yy_act == 6) {
#line 1085
      goto case_6;
    }
#line 1101
    if (yy_act == 7) {
#line 1101
      goto case_7;
    }
#line 1105
    if (yy_act == 8) {
#line 1105
      goto case_8;
    }
#line 1115
    if (yy_act == 9) {
#line 1115
      goto case_9;
    }
#line 1119
    if (yy_act == 10) {
#line 1119
      goto case_10;
    }
#line 1123
    if (yy_act == 11) {
#line 1123
      goto case_11;
    }
#line 1127
    if (yy_act == 12) {
#line 1127
      goto case_12;
    }
#line 1131
    if (yy_act == 13) {
#line 1131
      goto case_13;
    }
#line 1135
    if (yy_act == 14) {
#line 1135
      goto case_14;
    }
#line 1139
    if (yy_act == 15) {
#line 1139
      goto case_15;
    }
#line 1143
    if (yy_act == 16) {
#line 1143
      goto case_16;
    }
#line 1151
    if (yy_act == 17) {
#line 1151
      goto case_17;
    }
#line 1156
    if (yy_act == 18) {
#line 1156
      goto case_18;
    }
#line 1160
    if (yy_act == 19) {
#line 1160
      goto case_19;
    }
#line 1173
    if (yy_act == 20) {
#line 1173
      goto case_20;
    }
#line 1177
    if (yy_act == 21) {
#line 1177
      goto case_21;
    }
#line 1182
    if (yy_act == 22) {
#line 1182
      goto case_22;
    }
#line 1186
    if (yy_act == 39) {
#line 1186
      goto case_39;
    }
#line 1192
    if (yy_act == 23) {
#line 1192
      goto case_23;
    }
#line 1204
    if (yy_act == 24) {
#line 1204
      goto case_24;
    }
#line 1210
    if (yy_act == 25) {
#line 1210
      goto case_25;
    }
#line 1222
    if (yy_act == 26) {
#line 1222
      goto case_26;
    }
#line 1228
    if (yy_act == 27) {
#line 1228
      goto case_27;
    }
#line 1239
    if (yy_act == 28) {
#line 1239
      goto case_28;
    }
#line 1249
    if (yy_act == 38) {
#line 1249
      goto case_38;
    }
#line 1255
    if (yy_act == 29) {
#line 1255
      goto case_29;
    }
#line 1280
    if (yy_act == 30) {
#line 1280
      goto case_30;
    }
#line 1292
    if (yy_act == 31) {
#line 1292
      goto case_31;
    }
#line 1300
    if (yy_act == 32) {
#line 1300
      goto case_32;
    }
#line 1313
    if (yy_act == 37) {
#line 1313
      goto case_37;
    }
#line 1321
    if (yy_act == 36) {
#line 1321
      goto case_36;
    }
#line 1321
    if (yy_act == 35) {
#line 1321
      goto case_36;
    }
#line 1331
    if (yy_act == 33) {
#line 1331
      goto case_33;
    }
#line 1336
    if (yy_act == 34) {
#line 1336
      goto case_34;
    }
#line 1458
    goto switch_default;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 1063
    (current_file->lineno) ++;
#line 1064
    return (286);
#line 1066
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1070
    goto switch_break;
    case_4: /* CIL Label */ 
#line 1074
    yy_start = 3;
#line 1076
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 1080
    yyunput((int )*(zconftext + 0), zconftext);
#line 1081
    yy_start = 3;
    }
#line 1083
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 1088
    tmp___0 = kconf_id_lookup((char const   *)zconftext, (unsigned int )zconfleng);
#line 1088
    id = (struct kconf_id  const  *)tmp___0;
#line 1089
    yy_start = 9;
#line 1090
    current_pos.file = current_file;
#line 1091
    current_pos.lineno = current_file->lineno;
    }
#line 1092
    if (id) {
#line 1092
      if (id->flags & 1U) {
#line 1093
        zconflval.id = id;
#line 1094
        return ((int )id->token);
      }
    }
    {
#line 1096
    alloc_string((char const   *)zconftext, zconfleng);
#line 1097
    zconflval.string = text;
    }
#line 1098
    return (281);
#line 1100
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1104
    goto switch_break;
    case_8: /* CIL Label */ 
#line 1109
    yy_start = 1;
#line 1110
    (current_file->lineno) ++;
#line 1111
    return (286);
#line 1113
    goto switch_break;
    case_9: /* CIL Label */ 
#line 1117
    return (288);
#line 1118
    goto switch_break;
    case_10: /* CIL Label */ 
#line 1121
    return (287);
#line 1122
    goto switch_break;
    case_11: /* CIL Label */ 
#line 1125
    return (285);
#line 1126
    goto switch_break;
    case_12: /* CIL Label */ 
#line 1129
    return (284);
#line 1130
    goto switch_break;
    case_13: /* CIL Label */ 
#line 1133
    return (290);
#line 1134
    goto switch_break;
    case_14: /* CIL Label */ 
#line 1137
    return (289);
#line 1138
    goto switch_break;
    case_15: /* CIL Label */ 
#line 1141
    return (283);
#line 1142
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 1146
    str = (int )*(zconftext + 0);
#line 1147
    new_string();
#line 1148
    yy_start = 7;
    }
#line 1150
    goto switch_break;
    case_17: /* CIL Label */ 
#line 1154
    yy_start = 1;
#line 1154
    (current_file->lineno) ++;
#line 1154
    return (286);
#line 1155
    goto switch_break;
    case_18: /* CIL Label */ 
#line 1159
    goto switch_break;
    case_19: /* CIL Label */ 
    {
#line 1163
    tmp___1 = kconf_id_lookup((char const   *)zconftext, (unsigned int )zconfleng);
#line 1163
    id___0 = (struct kconf_id  const  *)tmp___1;
    }
#line 1164
    if (id___0) {
#line 1164
      if (id___0->flags & 2U) {
#line 1165
        zconflval.id = id___0;
#line 1166
        return ((int )id___0->token);
      }
    }
    {
#line 1168
    alloc_string((char const   *)zconftext, zconfleng);
#line 1169
    zconflval.string = text;
    }
#line 1170
    return (281);
#line 1172
    goto switch_break;
    case_20: /* CIL Label */ 
#line 1176
    goto switch_break;
    case_21: /* CIL Label */ 
#line 1180
    (current_file->lineno) ++;
#line 1181
    goto switch_break;
    case_22: /* CIL Label */ 
#line 1185
    goto switch_break;
    case_39: /* CIL Label */ 
#line 1188
    yy_start = 1;
#line 1190
    goto switch_break;
    case_23: /* CIL Label */ 
    {
#line 1194
    *yy_cp = yy_hold_char;
#line 1195
    yy_cp --;
#line 1195
    yy_c_buf_p = yy_cp;
#line 1196
    zconftext = yy_bp;
#line 1196
    zconfleng = (int )((size_t )(yy_cp - yy_bp));
#line 1196
    yy_hold_char = *yy_cp;
#line 1196
    *yy_cp = (char )'\000';
#line 1196
    yy_c_buf_p = yy_cp;
#line 1199
    append_string((char const   *)zconftext, zconfleng);
#line 1200
    zconflval.string = text;
    }
#line 1201
    return (282);
#line 1203
    goto switch_break;
    case_24: /* CIL Label */ 
    {
#line 1207
    append_string((char const   *)zconftext, zconfleng);
    }
#line 1209
    goto switch_break;
    case_25: /* CIL Label */ 
    {
#line 1212
    *yy_cp = yy_hold_char;
#line 1213
    yy_cp --;
#line 1213
    yy_c_buf_p = yy_cp;
#line 1214
    zconftext = yy_bp;
#line 1214
    zconfleng = (int )((size_t )(yy_cp - yy_bp));
#line 1214
    yy_hold_char = *yy_cp;
#line 1214
    *yy_cp = (char )'\000';
#line 1214
    yy_c_buf_p = yy_cp;
#line 1217
    append_string((char const   *)(zconftext + 1), zconfleng - 1);
#line 1218
    zconflval.string = text;
    }
#line 1219
    return (282);
#line 1221
    goto switch_break;
    case_26: /* CIL Label */ 
    {
#line 1225
    append_string((char const   *)(zconftext + 1), zconfleng - 1);
    }
#line 1227
    goto switch_break;
    case_27: /* CIL Label */ 
#line 1231
    if (str == (int )*(zconftext + 0)) {
#line 1232
      yy_start = 9;
#line 1233
      zconflval.string = text;
#line 1234
      return (282);
    } else {
      {
#line 1236
      append_string((char const   *)zconftext, 1);
      }
    }
#line 1238
    goto switch_break;
    case_28: /* CIL Label */ 
    {
#line 1243
    tmp___2 = zconf_lineno();
#line 1243
    tmp___3 = zconf_curname();
#line 1243
    printf((char const   */* __restrict  */)"%s:%d:warning: multi-line strings not supported\n",
           tmp___3, tmp___2);
#line 1244
    (current_file->lineno) ++;
#line 1245
    yy_start = 1;
    }
#line 1246
    return (286);
#line 1248
    goto switch_break;
    case_38: /* CIL Label */ 
#line 1251
    yy_start = 1;
#line 1253
    goto switch_break;
    case_29: /* CIL Label */ 
#line 1258
    ts = 0;
#line 1259
    i = 0;
    {
#line 1259
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1259
      if (! (i < zconfleng)) {
#line 1259
        goto while_break___1;
      }
#line 1260
      if ((int )*(zconftext + i) == 9) {
#line 1261
        ts = (ts & -8) + 8;
      } else {
#line 1263
        ts ++;
      }
#line 1259
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1265
    last_ts = ts;
#line 1266
    if (first_ts) {
#line 1267
      if (ts < first_ts) {
        {
#line 1268
        zconf_endhelp();
        }
#line 1269
        return (268);
      }
#line 1271
      ts -= first_ts;
      {
#line 1272
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1272
        if (! (ts > 8)) {
#line 1272
          goto while_break___2;
        }
        {
#line 1273
        append_string("        ", 8);
#line 1274
        ts -= 8;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 1276
      append_string("        ", ts);
      }
    }
#line 1279
    goto switch_break;
    case_30: /* CIL Label */ 
    {
#line 1282
    *yy_cp = yy_hold_char;
#line 1283
    yy_cp --;
#line 1283
    yy_c_buf_p = yy_cp;
#line 1284
    zconftext = yy_bp;
#line 1284
    zconfleng = (int )((size_t )(yy_cp - yy_bp));
#line 1284
    yy_hold_char = *yy_cp;
#line 1284
    *yy_cp = (char )'\000';
#line 1284
    yy_c_buf_p = yy_cp;
#line 1287
    (current_file->lineno) ++;
#line 1288
    zconf_endhelp();
    }
#line 1289
    return (268);
#line 1291
    goto switch_break;
    case_31: /* CIL Label */ 
    {
#line 1296
    (current_file->lineno) ++;
#line 1297
    append_string("\n", 1);
    }
#line 1299
    goto switch_break;
    case_32: /* CIL Label */ 
    {
#line 1303
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1303
      if (! zconfleng) {
#line 1303
        goto while_break___3;
      }
#line 1304
      if ((int )*(zconftext + (zconfleng - 1)) != 32) {
#line 1304
        if ((int )*(zconftext + (zconfleng - 1)) != 9) {
#line 1305
          goto while_break___3;
        }
      }
#line 1306
      zconfleng --;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 1308
    append_string((char const   *)zconftext, zconfleng);
    }
#line 1309
    if (! first_ts) {
#line 1310
      first_ts = last_ts;
    }
#line 1312
    goto switch_break;
    case_37: /* CIL Label */ 
    {
#line 1315
    zconf_endhelp();
    }
#line 1316
    return (268);
#line 1318
    goto switch_break;
    case_36: /* CIL Label */ 
    case_35: /* CIL Label */ 
#line 1323
    if (current_file) {
      {
#line 1324
      zconf_endfile();
      }
#line 1325
      return (286);
    }
    {
#line 1327
    fclose(zconfin);
    }
#line 1328
    return (0);
#line 1330
    goto switch_break;
    case_33: /* CIL Label */ 
    {
#line 1333
    yy_fatal_error("flex scanner jammed");
    }
#line 1334
    goto switch_break;
    case_34: /* CIL Label */ 
#line 1339
    yy_amount_of_matched_text = (int )(yy_cp - zconftext) - 1;
#line 1342
    *yy_cp = yy_hold_char;
#line 1345
    if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status == 0) {
#line 1356
      yy_n_chars = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars;
#line 1357
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_input_file = zconfin;
#line 1358
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status = 1;
    }
#line 1368
    if ((unsigned long )yy_c_buf_p <= (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars)) {
      {
#line 1372
      yy_c_buf_p = zconftext + yy_amount_of_matched_text;
#line 1374
      yy_current_state = yy_get_previous_state();
#line 1385
      yy_next_state = yy_try_NUL_trans(yy_current_state);
#line 1387
      yy_bp = zconftext + 0;
      }
#line 1389
      if (yy_next_state) {
#line 1392
        yy_c_buf_p ++;
#line 1392
        yy_cp = yy_c_buf_p;
#line 1393
        yy_current_state = yy_next_state;
#line 1394
        goto yy_match;
      } else {
#line 1399
        yy_cp = yy_c_buf_p;
#line 1400
        goto yy_find_action;
      }
    } else {
      {
#line 1404
      tmp___4 = yy_get_next_buffer();
      }
      {
#line 1406
      if (tmp___4 == 1) {
#line 1406
        goto case_1___0;
      }
#line 1435
      if (tmp___4 == 0) {
#line 1435
        goto case_0;
      }
#line 1445
      if (tmp___4 == 2) {
#line 1445
        goto case_2___0;
      }
#line 1404
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
#line 1408
      yy_did_buffer_switch_on_eof = 0;
#line 1421
      yy_c_buf_p = zconftext + 0;
#line 1423
      yy_act = (34 + (yy_start - 1) / 2) + 1;
#line 1424
      goto do_action;
#line 1432
      goto switch_break___0;
      case_0: /* CIL Label */ 
      {
#line 1436
      yy_c_buf_p = zconftext + yy_amount_of_matched_text;
#line 1439
      yy_current_state = yy_get_previous_state();
#line 1441
      yy_cp = yy_c_buf_p;
#line 1442
      yy_bp = zconftext + 0;
      }
#line 1443
      goto yy_match;
      case_2___0: /* CIL Label */ 
      {
#line 1446
      yy_c_buf_p = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars;
#line 1449
      yy_current_state = yy_get_previous_state();
#line 1451
      yy_cp = yy_c_buf_p;
#line 1452
      yy_bp = zconftext + 0;
      }
#line 1453
      goto yy_find_action;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 1455
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1459
    yy_fatal_error("fatal flex scanner internal error--no action found");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1472 "scripts/kconfig/zconf.lex.c_shipped"
static int yy_get_next_buffer(void) 
{ 
  register char *dest ;
  register char *source ;
  register int number_to_move ;
  register int i ;
  int ret_val ;
  char *tmp ;
  char *tmp___0 ;
  int num_to_read ;
  YY_BUFFER_STATE b ;
  YY_BUFFER_STATE tmp___1 ;
  int yy_c_buf_p_offset ;
  int new_size ;
  void *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  ssize_t tmp___7 ;
  yy_size_t new_size___0 ;
  void *tmp___8 ;

  {
#line 1474
  dest = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf;
#line 1475
  source = zconftext;
#line 1479
  if ((unsigned long )yy_c_buf_p > (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + (yy_n_chars + 1))) {
    {
#line 1480
    yy_fatal_error("fatal flex scanner internal error--end of buffer missed");
    }
  }
#line 1483
  if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_fill_buffer == 0) {
#line 1485
    if (yy_c_buf_p - zconftext == 1L) {
#line 1490
      return (1);
    } else {
#line 1498
      return (2);
    }
  }
#line 1505
  number_to_move = (int )(yy_c_buf_p - zconftext) - 1;
#line 1507
  i = 0;
  {
#line 1507
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1507
    if (! (i < number_to_move)) {
#line 1507
      goto while_break;
    }
#line 1508
    tmp = dest;
#line 1508
    dest ++;
#line 1508
    tmp___0 = source;
#line 1508
    source ++;
#line 1508
    *tmp = *tmp___0;
#line 1507
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1510
  if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status == 2) {
#line 1514
    yy_n_chars = 0;
#line 1514
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  } else {
#line 1518
    num_to_read = (int )(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size - (yy_size_t )number_to_move) - 1UL);
    {
#line 1521
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1521
      if (! (num_to_read <= 0)) {
#line 1521
        goto while_break___0;
      }
#line 1525
      if (yy_buffer_stack) {
#line 1525
        tmp___1 = *(yy_buffer_stack + yy_buffer_stack_top);
      } else {
#line 1525
        tmp___1 = (YY_BUFFER_STATE )((void *)0);
      }
#line 1525
      b = tmp___1;
#line 1527
      yy_c_buf_p_offset = (int )(yy_c_buf_p - b->yy_ch_buf);
#line 1530
      if (b->yy_is_our_buffer) {
#line 1532
        new_size = (int )(b->yy_buf_size * 2UL);
#line 1534
        if (new_size <= 0) {
#line 1535
          b->yy_buf_size += b->yy_buf_size / 8UL;
        } else {
#line 1537
          b->yy_buf_size *= 2UL;
        }
        {
#line 1539
        tmp___2 = zconfrealloc((void *)b->yy_ch_buf, b->yy_buf_size + 2UL);
#line 1539
        b->yy_ch_buf = (char *)tmp___2;
        }
      } else {
#line 1545
        b->yy_ch_buf = (char *)0;
      }
#line 1547
      if (! b->yy_ch_buf) {
        {
#line 1548
        yy_fatal_error("fatal error - scanner input buffer overflow");
        }
      }
#line 1551
      yy_c_buf_p = b->yy_ch_buf + yy_c_buf_p_offset;
#line 1553
      num_to_read = (int )(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size - (yy_size_t )number_to_move) - 1UL);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1558
    if (num_to_read > 8192) {
#line 1559
      num_to_read = 8192;
    }
    {
#line 1562
    tmp___3 = __errno_location();
#line 1562
    *tmp___3 = 0;
    }
    {
#line 1562
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1562
      tmp___6 = fileno(zconfin);
#line 1562
      tmp___7 = read(tmp___6, (void *)((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move),
                     (size_t )num_to_read);
#line 1562
      yy_n_chars = (int )tmp___7;
      }
#line 1562
      if (! (yy_n_chars < 0)) {
#line 1562
        goto while_break___1;
      }
      {
#line 1562
      tmp___4 = __errno_location();
      }
#line 1562
      if (*tmp___4 != 4) {
        {
#line 1562
        yy_fatal_error("input in flex scanner failed");
        }
#line 1562
        goto while_break___1;
      }
      {
#line 1562
      tmp___5 = __errno_location();
#line 1562
      *tmp___5 = 0;
#line 1562
      clearerr(zconfin);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1565
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
#line 1568
  if (yy_n_chars == 0) {
#line 1570
    if (number_to_move == 0) {
      {
#line 1572
      ret_val = 1;
#line 1573
      zconfrestart(zconfin);
      }
    } else {
#line 1578
      ret_val = 2;
#line 1579
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status = 2;
    }
  } else {
#line 1585
    ret_val = 0;
  }
#line 1587
  if ((yy_size_t )(yy_n_chars + number_to_move) > (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size) {
    {
#line 1589
    new_size___0 = (yy_size_t )((yy_n_chars + number_to_move) + (yy_n_chars >> 1));
#line 1590
    tmp___8 = zconfrealloc((void *)(*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf,
                           new_size___0);
#line 1590
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf = (char *)tmp___8;
    }
#line 1591
    if (! (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf) {
      {
#line 1592
      yy_fatal_error("out of dynamic memory in yy_get_next_buffer()");
      }
    }
  }
#line 1595
  yy_n_chars += number_to_move;
#line 1596
  *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars) = (char)0;
#line 1597
  *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + (yy_n_chars + 1)) = (char)0;
#line 1599
  zconftext = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + 0;
#line 1601
  return (ret_val);
}
}
#line 1606 "scripts/kconfig/zconf.lex.c_shipped"
static yy_state_type yy_get_previous_state(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  flex_int32_t tmp ;

  {
#line 1611
  yy_current_state = yy_start;
#line 1613
  yy_cp = zconftext + 0;
  {
#line 1613
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1613
    if (! ((unsigned long )yy_cp < (unsigned long )yy_c_buf_p)) {
#line 1613
      goto while_break;
    }
#line 1615
    if (*yy_cp) {
#line 1615
      tmp = yy_ec[(unsigned int )((unsigned char )*yy_cp)];
    } else {
#line 1615
      tmp = (flex_int32_t const   )1;
    }
#line 1615
    yy_current_state = (yy_state_type )yy_nxt[yy_current_state][tmp];
#line 1613
    yy_cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1618
  return (yy_current_state);
}
}
#line 1626 "scripts/kconfig/zconf.lex.c_shipped"
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) 
{ 
  register int yy_is_jam ;
  int tmp ;

  {
#line 1630
  yy_current_state = (yy_state_type )yy_nxt[yy_current_state][1];
#line 1631
  yy_is_jam = yy_current_state <= 0;
#line 1633
  if (yy_is_jam) {
#line 1633
    tmp = 0;
  } else {
#line 1633
    tmp = yy_current_state;
  }
#line 1633
  return (tmp);
}
}
#line 1636 "scripts/kconfig/zconf.lex.c_shipped"
static void yyunput(int c , char *yy_bp ) 
{ 
  register char *yy_cp ;
  register int number_to_move ;
  register char *dest ;
  register char *source ;

  {
#line 1640
  yy_cp = yy_c_buf_p;
#line 1643
  *yy_cp = yy_hold_char;
#line 1645
  if ((unsigned long )yy_cp < (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + 2)) {
#line 1648
    number_to_move = yy_n_chars + 2;
#line 1649
    dest = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size + 2UL);
#line 1651
    source = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move;
    {
#line 1654
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1654
      if (! ((unsigned long )source > (unsigned long )(*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf)) {
#line 1654
        goto while_break;
      }
#line 1655
      dest --;
#line 1655
      source --;
#line 1655
      *dest = *source;
    }
    while_break: /* CIL Label */ ;
    }
#line 1657
    yy_cp += (int )(dest - source);
#line 1658
    yy_bp += (int )(dest - source);
#line 1659
    yy_n_chars = (int )(*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size;
#line 1659
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
#line 1662
    if ((unsigned long )yy_cp < (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + 2)) {
      {
#line 1663
      yy_fatal_error("flex scanner push-back overflow");
      }
    }
  }
#line 1666
  yy_cp --;
#line 1666
  *yy_cp = (char )c;
#line 1668
  zconftext = yy_bp;
#line 1669
  yy_hold_char = *yy_cp;
#line 1670
  yy_c_buf_p = yy_cp;
#line 1671
  return;
}
}
#line 1752 "scripts/kconfig/zconf.lex.c_shipped"
void zconfrestart(FILE *input_file ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1755
  if (yy_buffer_stack) {
#line 1755
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1755
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1755
  if (! tmp) {
    {
#line 1756
    zconfensure_buffer_stack();
#line 1757
    *(yy_buffer_stack + yy_buffer_stack_top) = zconf_create_buffer(zconfin, 16384);
    }
  }
#line 1761
  if (yy_buffer_stack) {
#line 1761
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1761
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 1761
  zconf_init_buffer(tmp___0, input_file);
#line 1762
  zconf_load_buffer_state();
  }
#line 1763
  return;
}
}
#line 1769 "scripts/kconfig/zconf.lex.c_shipped"
void zconf_switch_to_buffer(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 1777
  zconfensure_buffer_stack();
  }
#line 1778
  if (yy_buffer_stack) {
#line 1778
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1778
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1778
  if ((unsigned long )tmp == (unsigned long )new_buffer) {
#line 1779
    return;
  }
#line 1781
  if (yy_buffer_stack) {
#line 1781
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1781
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1781
  if (tmp___0) {
#line 1784
    *yy_c_buf_p = yy_hold_char;
#line 1785
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos = yy_c_buf_p;
#line 1786
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
  {
#line 1789
  *(yy_buffer_stack + yy_buffer_stack_top) = new_buffer;
#line 1790
  zconf_load_buffer_state();
#line 1797
  yy_did_buffer_switch_on_eof = 1;
  }
#line 1798
  return;
}
}
#line 1800 "scripts/kconfig/zconf.lex.c_shipped"
static void zconf_load_buffer_state(void) 
{ 


  {
#line 1802
  yy_n_chars = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars;
#line 1803
  yy_c_buf_p = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos;
#line 1803
  zconftext = yy_c_buf_p;
#line 1804
  zconfin = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_input_file;
#line 1805
  yy_hold_char = *yy_c_buf_p;
#line 1806
  return;
}
}
#line 1814 "scripts/kconfig/zconf.lex.c_shipped"
YY_BUFFER_STATE zconf_create_buffer(FILE *file , int size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 1818
  tmp = zconfalloc(sizeof(struct yy_buffer_state ));
#line 1818
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1819
  if (! b) {
    {
#line 1820
    yy_fatal_error("out of dynamic memory in zconf_create_buffer()");
    }
  }
  {
#line 1822
  b->yy_buf_size = (yy_size_t )size;
#line 1827
  tmp___0 = zconfalloc(b->yy_buf_size + 2UL);
#line 1827
  b->yy_ch_buf = (char *)tmp___0;
  }
#line 1828
  if (! b->yy_ch_buf) {
    {
#line 1829
    yy_fatal_error("out of dynamic memory in zconf_create_buffer()");
    }
  }
  {
#line 1831
  b->yy_is_our_buffer = 1;
#line 1833
  zconf_init_buffer(b, file);
  }
#line 1835
  return (b);
}
}
#line 1842 "scripts/kconfig/zconf.lex.c_shipped"
void zconf_delete_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 1845
  if (! b) {
#line 1846
    return;
  }
#line 1848
  if (yy_buffer_stack) {
#line 1848
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1848
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1848
  if ((unsigned long )b == (unsigned long )tmp) {
#line 1849
    *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )0;
  }
#line 1851
  if (b->yy_is_our_buffer) {
    {
#line 1852
    zconffree((void *)b->yy_ch_buf);
    }
  }
  {
#line 1854
  zconffree((void *)b);
  }
#line 1855
  return;
}
}
#line 1861 "scripts/kconfig/zconf.lex.c_shipped"
static void zconf_init_buffer(YY_BUFFER_STATE b , FILE *file ) 
{ 
  int oerrno ;
  int *tmp ;
  YY_BUFFER_STATE tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 1864
  tmp = __errno_location();
#line 1864
  oerrno = *tmp;
#line 1866
  zconf_flush_buffer(b);
#line 1868
  b->yy_input_file = file;
#line 1869
  b->yy_fill_buffer = 1;
  }
#line 1875
  if (yy_buffer_stack) {
#line 1875
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1875
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1875
  if ((unsigned long )b != (unsigned long )tmp___0) {
#line 1876
    b->yy_bs_lineno = 1;
#line 1877
    b->yy_bs_column = 0;
  }
  {
#line 1880
  b->yy_is_interactive = 0;
#line 1882
  tmp___1 = __errno_location();
#line 1882
  *tmp___1 = oerrno;
  }
#line 1883
  return;
}
}
#line 1889 "scripts/kconfig/zconf.lex.c_shipped"
void zconf_flush_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 1891
  if (! b) {
#line 1892
    return;
  }
#line 1894
  b->yy_n_chars = 0;
#line 1900
  *(b->yy_ch_buf + 0) = (char)0;
#line 1901
  *(b->yy_ch_buf + 1) = (char)0;
#line 1903
  b->yy_buf_pos = b->yy_ch_buf + 0;
#line 1905
  b->yy_at_bol = 1;
#line 1906
  b->yy_buffer_status = 0;
#line 1908
  if (yy_buffer_stack) {
#line 1908
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1908
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1908
  if ((unsigned long )b == (unsigned long )tmp) {
    {
#line 1909
    zconf_load_buffer_state();
    }
  }
#line 1910
  return;
}
}
#line 1918 "scripts/kconfig/zconf.lex.c_shipped"
void zconfpush_buffer_state(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1920
  if ((unsigned long )new_buffer == (unsigned long )((void *)0)) {
#line 1921
    return;
  }
  {
#line 1923
  zconfensure_buffer_stack();
  }
#line 1926
  if (yy_buffer_stack) {
#line 1926
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1926
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1926
  if (tmp) {
#line 1929
    *yy_c_buf_p = yy_hold_char;
#line 1930
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos = yy_c_buf_p;
#line 1931
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
#line 1935
  if (yy_buffer_stack) {
#line 1935
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1935
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1935
  if (tmp___0) {
#line 1936
    yy_buffer_stack_top ++;
  }
  {
#line 1937
  *(yy_buffer_stack + yy_buffer_stack_top) = new_buffer;
#line 1940
  zconf_load_buffer_state();
#line 1941
  yy_did_buffer_switch_on_eof = 1;
  }
#line 1942
  return;
}
}
#line 1948 "scripts/kconfig/zconf.lex.c_shipped"
void zconfpop_buffer_state(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
#line 1950
  if (yy_buffer_stack) {
#line 1950
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1950
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1950
  if (! tmp) {
#line 1951
    return;
  }
#line 1953
  if (yy_buffer_stack) {
#line 1953
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1953
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 1953
  zconf_delete_buffer(tmp___0);
#line 1954
  *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
  }
#line 1955
  if (yy_buffer_stack_top > 0UL) {
#line 1956
    yy_buffer_stack_top --;
  }
#line 1958
  if (yy_buffer_stack) {
#line 1958
    tmp___1 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1958
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1958
  if (tmp___1) {
    {
#line 1959
    zconf_load_buffer_state();
#line 1960
    yy_did_buffer_switch_on_eof = 1;
    }
  }
#line 1962
  return;
}
}
#line 1967 "scripts/kconfig/zconf.lex.c_shipped"
static void zconfensure_buffer_stack(void) 
{ 
  int num_to_alloc ;
  void *tmp ;
  int grow_size ;
  void *tmp___0 ;

  {
#line 1971
  if (! yy_buffer_stack) {
    {
#line 1977
    num_to_alloc = 1;
#line 1978
    tmp = zconfalloc((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *));
#line 1978
    yy_buffer_stack = (struct yy_buffer_state **)tmp;
    }
#line 1981
    if (! yy_buffer_stack) {
      {
#line 1982
      yy_fatal_error("out of dynamic memory in zconfensure_buffer_stack()");
      }
    }
    {
#line 1984
    memset((void *)yy_buffer_stack, 0, (unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *));
#line 1986
    yy_buffer_stack_max = (size_t )num_to_alloc;
#line 1987
    yy_buffer_stack_top = (size_t )0;
    }
#line 1988
    return;
  }
#line 1991
  if (yy_buffer_stack_top >= yy_buffer_stack_max - 1UL) {
    {
#line 1994
    grow_size = 8;
#line 1996
    num_to_alloc = (int )(yy_buffer_stack_max + (size_t )grow_size);
#line 1997
    tmp___0 = zconfrealloc((void *)yy_buffer_stack, (unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *));
#line 1997
    yy_buffer_stack = (struct yy_buffer_state **)tmp___0;
    }
#line 2001
    if (! yy_buffer_stack) {
      {
#line 2002
      yy_fatal_error("out of dynamic memory in zconfensure_buffer_stack()");
      }
    }
    {
#line 2005
    memset((void *)(yy_buffer_stack + yy_buffer_stack_max), 0, (unsigned long )grow_size * sizeof(struct yy_buffer_state *));
#line 2006
    yy_buffer_stack_max = (size_t )num_to_alloc;
    }
  }
#line 2008
  return;
}
}
#line 2016 "scripts/kconfig/zconf.lex.c_shipped"
YY_BUFFER_STATE zconf_scan_buffer(char *base , yy_size_t size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 2020
  if (size < 2UL) {
#line 2024
    return ((YY_BUFFER_STATE )0);
  } else
#line 2020
  if ((int )*(base + (size - 2UL)) != 0) {
#line 2024
    return ((YY_BUFFER_STATE )0);
  } else
#line 2020
  if ((int )*(base + (size - 1UL)) != 0) {
#line 2024
    return ((YY_BUFFER_STATE )0);
  }
  {
#line 2026
  tmp = zconfalloc(sizeof(struct yy_buffer_state ));
#line 2026
  b = (YY_BUFFER_STATE )tmp;
  }
#line 2027
  if (! b) {
    {
#line 2028
    yy_fatal_error("out of dynamic memory in zconf_scan_buffer()");
    }
  }
  {
#line 2030
  b->yy_buf_size = size - 2UL;
#line 2031
  tmp___0 = base;
#line 2031
  b->yy_ch_buf = tmp___0;
#line 2031
  b->yy_buf_pos = tmp___0;
#line 2032
  b->yy_is_our_buffer = 0;
#line 2033
  b->yy_input_file = (FILE *)0;
#line 2034
  b->yy_n_chars = (int )b->yy_buf_size;
#line 2035
  b->yy_is_interactive = 0;
#line 2036
  b->yy_at_bol = 1;
#line 2037
  b->yy_fill_buffer = 0;
#line 2038
  b->yy_buffer_status = 0;
#line 2040
  zconf_switch_to_buffer(b);
  }
#line 2042
  return (b);
}
}
#line 2053 "scripts/kconfig/zconf.lex.c_shipped"
YY_BUFFER_STATE zconf_scan_string(char const   *yystr ) 
{ 
  size_t tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 2056
  tmp = strlen(yystr);
#line 2056
  tmp___0 = zconf_scan_bytes(yystr, (int )tmp);
  }
#line 2056
  return (tmp___0);
}
}
#line 2066 "scripts/kconfig/zconf.lex.c_shipped"
YY_BUFFER_STATE zconf_scan_bytes(char const   *yybytes , int _yybytes_len ) 
{ 
  YY_BUFFER_STATE b ;
  char *buf ;
  yy_size_t n ;
  int i ;
  void *tmp ;
  char tmp___0 ;

  {
  {
#line 2074
  n = (yy_size_t )(_yybytes_len + 2);
#line 2075
  tmp = zconfalloc(n);
#line 2075
  buf = (char *)tmp;
  }
#line 2076
  if (! buf) {
    {
#line 2077
    yy_fatal_error("out of dynamic memory in zconf_scan_bytes()");
    }
  }
#line 2079
  i = 0;
  {
#line 2079
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2079
    if (! (i < _yybytes_len)) {
#line 2079
      goto while_break;
    }
#line 2080
    *(buf + i) = (char )*(yybytes + i);
#line 2079
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2082
  tmp___0 = (char)0;
#line 2082
  *(buf + (_yybytes_len + 1)) = tmp___0;
#line 2082
  *(buf + _yybytes_len) = tmp___0;
#line 2084
  b = zconf_scan_buffer(buf, n);
  }
#line 2085
  if (! b) {
    {
#line 2086
    yy_fatal_error("bad buffer in zconf_scan_bytes()");
    }
  }
#line 2091
  b->yy_is_our_buffer = 1;
#line 2093
  return (b);
}
}
#line 2100 "scripts/kconfig/zconf.lex.c_shipped"
static void yy_fatal_error(char const   *msg ) 
{ 


  {
  {
#line 2102
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg);
#line 2103
  exit(2);
  }
}
}
#line 2128 "scripts/kconfig/zconf.lex.c_shipped"
int zconfget_lineno(void) 
{ 


  {
#line 2131
  return (zconflineno);
}
}
#line 2137 "scripts/kconfig/zconf.lex.c_shipped"
FILE *zconfget_in(void) 
{ 


  {
#line 2139
  return (zconfin);
}
}
#line 2145 "scripts/kconfig/zconf.lex.c_shipped"
FILE *zconfget_out(void) 
{ 


  {
#line 2147
  return (zconfout);
}
}
#line 2153 "scripts/kconfig/zconf.lex.c_shipped"
int zconfget_leng(void) 
{ 


  {
#line 2155
  return (zconfleng);
}
}
#line 2162 "scripts/kconfig/zconf.lex.c_shipped"
char *zconfget_text(void) 
{ 


  {
#line 2164
  return (zconftext);
}
}
#line 2171 "scripts/kconfig/zconf.lex.c_shipped"
void zconfset_lineno(int line_number ) 
{ 


  {
#line 2174
  zconflineno = line_number;
#line 2175
  return;
}
}
#line 2183 "scripts/kconfig/zconf.lex.c_shipped"
void zconfset_in(FILE *in_str ) 
{ 


  {
#line 2185
  zconfin = in_str;
#line 2186
  return;
}
}
#line 2188 "scripts/kconfig/zconf.lex.c_shipped"
void zconfset_out(FILE *out_str ) 
{ 


  {
#line 2190
  zconfout = out_str;
#line 2191
  return;
}
}
#line 2193 "scripts/kconfig/zconf.lex.c_shipped"
int zconfget_debug(void) 
{ 


  {
#line 2195
  return (zconf_flex_debug);
}
}
#line 2198 "scripts/kconfig/zconf.lex.c_shipped"
void zconfset_debug(int bdebug ) 
{ 


  {
#line 2200
  zconf_flex_debug = bdebug;
#line 2201
  return;
}
}
#line 2203 "scripts/kconfig/zconf.lex.c_shipped"
static int yy_init_globals(void) 
{ 


  {
#line 2209
  yy_buffer_stack = (YY_BUFFER_STATE *)0;
#line 2210
  yy_buffer_stack_top = (size_t )0;
#line 2211
  yy_buffer_stack_max = (size_t )0;
#line 2212
  yy_c_buf_p = (char *)0;
#line 2213
  yy_init = 0;
#line 2214
  yy_start = 0;
#line 2221
  zconfin = (FILE *)0;
#line 2222
  zconfout = (FILE *)0;
#line 2228
  return (0);
}
}
#line 2232 "scripts/kconfig/zconf.lex.c_shipped"
int zconflex_destroy(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 2236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2236
    if (yy_buffer_stack) {
#line 2236
      tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 2236
      tmp___0 = (YY_BUFFER_STATE )((void *)0);
    }
#line 2236
    if (! tmp___0) {
#line 2236
      goto while_break;
    }
#line 2237
    if (yy_buffer_stack) {
#line 2237
      tmp = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 2237
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
    {
#line 2237
    zconf_delete_buffer(tmp);
#line 2238
    *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
#line 2239
    zconfpop_buffer_state();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2243
  zconffree((void *)yy_buffer_stack);
#line 2244
  yy_buffer_stack = (YY_BUFFER_STATE *)((void *)0);
#line 2248
  yy_init_globals();
  }
#line 2250
  return (0);
}
}
#line 2277 "scripts/kconfig/zconf.lex.c_shipped"
void *zconfalloc(yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 2279
  tmp = malloc(size);
  }
#line 2279
  return (tmp);
}
}
#line 2282 "scripts/kconfig/zconf.lex.c_shipped"
void *zconfrealloc(void *ptr , yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 2291
  tmp = realloc((void *)((char *)ptr), size);
  }
#line 2291
  return (tmp);
}
}
#line 2294 "scripts/kconfig/zconf.lex.c_shipped"
void zconffree(void *ptr ) 
{ 


  {
  {
#line 2296
  free((void *)((char *)ptr));
  }
#line 2297
  return;
}
}
#line 2301 "scripts/kconfig/zconf.lex.c_shipped"
void zconf_starthelp(void) 
{ 


  {
  {
#line 2303
  new_string();
#line 2304
  first_ts = 0;
#line 2304
  last_ts = first_ts;
#line 2305
  yy_start = 5;
  }
#line 2306
  return;
}
}
#line 2308 "scripts/kconfig/zconf.lex.c_shipped"
static void zconf_endhelp(void) 
{ 


  {
#line 2310
  zconflval.string = text;
#line 2311
  yy_start = 1;
#line 2312
  return;
}
}
#line 2322 "scripts/kconfig/zconf.lex.c_shipped"
FILE *zconf_fopen(char const   *name ) 
{ 
  char *env ;
  char fullname___0[4097] ;
  FILE *f ;

  {
  {
#line 2327
  f = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"r");
  }
#line 2328
  if (! f) {
#line 2328
    if ((unsigned long )name != (unsigned long )((void *)0)) {
#line 2328
      if ((int const   )*(name + 0) != 47) {
        {
#line 2329
        env = getenv("srctree");
        }
#line 2330
        if (env) {
          {
#line 2331
          sprintf((char */* __restrict  */)(fullname___0), (char const   */* __restrict  */)"%s/%s",
                  env, name);
#line 2332
          f = fopen((char const   */* __restrict  */)(fullname___0), (char const   */* __restrict  */)"r");
          }
        }
      }
    }
  }
#line 2335
  return (f);
}
}
#line 2338 "scripts/kconfig/zconf.lex.c_shipped"
void zconf_initscan(char const   *name ) 
{ 
  void *tmp ;

  {
  {
#line 2340
  zconfin = zconf_fopen(name);
  }
#line 2341
  if (! zconfin) {
    {
#line 2342
    printf((char const   */* __restrict  */)"can\'t find file %s\n", name);
#line 2343
    exit(1);
    }
  }
  {
#line 2346
  tmp = xmalloc(sizeof(*current_buf));
#line 2346
  current_buf = (struct buffer *)tmp;
#line 2347
  memset((void *)current_buf, 0, sizeof(*current_buf));
#line 2349
  current_file = file_lookup(name);
#line 2350
  current_file->lineno = 1;
  }
#line 2351
  return;
}
}
#line 2353 "scripts/kconfig/zconf.lex.c_shipped"
void zconf_nextfile(char const   *name ) 
{ 
  struct file *iter ;
  struct file *file ;
  struct file *tmp ;
  struct buffer *buf ;
  void *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  YY_BUFFER_STATE tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 2356
  tmp = file_lookup(name);
#line 2356
  file = tmp;
#line 2357
  tmp___0 = xmalloc(sizeof(*buf));
#line 2357
  buf = (struct buffer *)tmp___0;
#line 2358
  memset((void *)buf, 0, sizeof(*buf));
  }
#line 2360
  if (yy_buffer_stack) {
#line 2360
    current_buf->state = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 2360
    current_buf->state = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 2361
  zconfin = zconf_fopen(file->name);
  }
#line 2362
  if (! zconfin) {
    {
#line 2363
    tmp___1 = zconf_lineno();
#line 2363
    tmp___2 = zconf_curname();
#line 2363
    printf((char const   */* __restrict  */)"%s:%d: can\'t open file \"%s\"\n", tmp___2,
           tmp___1, file->name);
#line 2365
    exit(1);
    }
  }
  {
#line 2367
  tmp___3 = zconf_create_buffer(zconfin, 16384);
#line 2367
  zconf_switch_to_buffer(tmp___3);
#line 2368
  buf->parent = current_buf;
#line 2369
  current_buf = buf;
#line 2371
  iter = current_file->parent;
  }
  {
#line 2371
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2371
    if (! iter) {
#line 2371
      goto while_break;
    }
    {
#line 2372
    tmp___8 = strcmp(current_file->name, iter->name);
    }
#line 2372
    if (! tmp___8) {
      {
#line 2373
      tmp___4 = zconf_curname();
#line 2373
      tmp___5 = zconf_lineno();
#line 2373
      tmp___6 = zconf_curname();
#line 2373
      printf((char const   */* __restrict  */)"%s:%d: recursive inclusion detected. Inclusion path:\n  current file : \'%s\'\n",
             tmp___6, tmp___5, tmp___4);
#line 2377
      iter = current_file->parent;
      }
      {
#line 2378
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2378
        if (iter) {
          {
#line 2378
          tmp___7 = strcmp(iter->name, current_file->name);
          }
#line 2378
          if (! tmp___7) {
#line 2378
            goto while_break___0;
          }
        } else {
#line 2378
          goto while_break___0;
        }
        {
#line 2380
        printf((char const   */* __restrict  */)"  included from: \'%s:%d\'\n", iter->name,
               iter->lineno - 1);
#line 2382
        iter = iter->parent;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2384
      if (iter) {
        {
#line 2385
        printf((char const   */* __restrict  */)"  included from: \'%s:%d\'\n", iter->name,
               iter->lineno + 1);
        }
      }
      {
#line 2387
      exit(1);
      }
    }
#line 2371
    iter = iter->parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 2390
  file->lineno = 1;
#line 2391
  file->parent = current_file;
#line 2392
  current_file = file;
#line 2393
  return;
}
}
#line 2395 "scripts/kconfig/zconf.lex.c_shipped"
static void zconf_endfile(void) 
{ 
  struct buffer *parent ;
  YY_BUFFER_STATE tmp ;

  {
#line 2399
  current_file = current_file->parent;
#line 2401
  parent = current_buf->parent;
#line 2402
  if (parent) {
    {
#line 2403
    fclose(zconfin);
    }
#line 2404
    if (yy_buffer_stack) {
#line 2404
      tmp = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 2404
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
    {
#line 2404
    zconf_delete_buffer(tmp);
#line 2405
    zconf_switch_to_buffer(parent->state);
    }
  }
  {
#line 2407
  free((void *)current_buf);
#line 2408
  current_buf = parent;
  }
#line 2409
  return;
}
}
#line 2411 "scripts/kconfig/zconf.lex.c_shipped"
int zconf_lineno(void) 
{ 


  {
#line 2413
  return (current_pos.lineno);
}
}
#line 2416 "scripts/kconfig/zconf.lex.c_shipped"
char const   *zconf_curname(void) 
{ 
  char const   *tmp ;

  {
#line 2418
  if (current_pos.file) {
#line 2418
    tmp = (current_pos.file)->name;
  } else {
#line 2418
    tmp = "<none>";
  }
#line 2418
  return (tmp);
}
}
#line 14 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/util.c"
struct file *file_lookup(char const   *name ) 
{ 
  struct file *file ;
  char const   *file_name ;
  char const   *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 17
  tmp = sym_expand_string_value(name);
#line 17
  file_name = tmp;
#line 19
  file = file_list;
  }
  {
#line 19
  while (1) {
    while_continue: /* CIL Label */ ;
#line 19
    if (! file) {
#line 19
      goto while_break;
    }
    {
#line 20
    tmp___0 = strcmp(name, file->name);
    }
#line 20
    if (! tmp___0) {
      {
#line 21
      free((void *)file_name);
      }
#line 22
      return (file);
    }
#line 19
    file = file->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 26
  tmp___1 = xmalloc(sizeof(*file));
#line 26
  file = (struct file *)tmp___1;
#line 27
  memset((void *)file, 0, sizeof(*file));
#line 28
  file->name = file_name;
#line 29
  file->next = file_list;
#line 30
  file_list = file;
  }
#line 31
  return (file);
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/util.c"
int file_write_dep(char const   *name ) 
{ 
  struct symbol *sym ;
  struct symbol *env_sym ;
  struct expr *e ;
  struct file *file ;
  FILE *out ;
  char const   *tmp ;
  struct property *prop ;
  char const   *value ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 42
  if (! name) {
#line 43
    name = ".kconfig.d";
  }
  {
#line 44
  out = fopen((char const   */* __restrict  */)"..config.tmp", (char const   */* __restrict  */)"w");
  }
#line 45
  if (! out) {
#line 46
    return (1);
  }
  {
#line 47
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"deps_config := \\\n");
#line 48
  file = file_list;
  }
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! file) {
#line 48
      goto while_break;
    }
#line 49
    if (file->next) {
      {
#line 50
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\t%s \\\n",
              file->name);
      }
    } else {
      {
#line 52
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\t%s\n",
              file->name);
      }
    }
#line 48
    file = file->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 54
  tmp = conf_get_autoconfig_name();
#line 54
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\n%s: \\\n\t$(deps_config)\n\n",
          tmp);
#line 57
  e = sym_env_list;
  }
  {
#line 57
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 57
    if (e) {
#line 57
      sym = e->right.sym;
#line 57
      if (! sym) {
#line 57
        goto while_break___0;
      }
    } else {
#line 57
      goto while_break___0;
    }
    {
#line 61
    prop = sym_get_env_prop(sym);
#line 62
    env_sym = prop_get_symbol(prop);
    }
#line 63
    if (! env_sym) {
#line 64
      goto __Cont;
    }
    {
#line 65
    tmp___0 = getenv((char const   *)env_sym->name);
#line 65
    value = (char const   *)tmp___0;
    }
#line 66
    if (! value) {
#line 67
      value = "";
    }
    {
#line 68
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"ifneq \"$(%s)\" \"%s\"\n",
            env_sym->name, value);
#line 69
    tmp___1 = conf_get_autoconfig_name();
#line 69
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s: FORCE\n",
            tmp___1);
#line 70
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"endif\n");
    }
    __Cont: /* CIL Label */ 
#line 57
    e = e->left.expr;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 73
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\n$(deps_config): ;\n");
#line 74
  fclose(out);
#line 75
  rename("..config.tmp", name);
  }
#line 76
  return (0);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/util.c"
struct gstr str_new(void) 
{ 
  struct gstr gs ;
  void *tmp ;

  {
  {
#line 84
  tmp = xmalloc(sizeof(char ) * 64UL);
#line 84
  gs.s = (char *)tmp;
#line 85
  gs.len = (size_t )64;
#line 86
  gs.max_width = 0;
#line 87
  strcpy((char */* __restrict  */)gs.s, (char const   */* __restrict  */)"\000");
  }
#line 88
  return (gs);
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/util.c"
struct gstr str_assign(char const   *s ) 
{ 
  struct gstr gs ;
  size_t tmp ;

  {
  {
#line 95
  gs.s = strdup(s);
#line 96
  tmp = strlen(s);
#line 96
  gs.len = tmp + 1UL;
#line 97
  gs.max_width = 0;
  }
#line 98
  return (gs);
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/util.c"
void str_free(struct gstr *gs ) 
{ 


  {
#line 104
  if (gs->s) {
    {
#line 105
    free((void *)gs->s);
    }
  }
#line 106
  gs->s = (char *)((void *)0);
#line 107
  gs->len = (size_t )0;
#line 108
  return;
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/util.c"
void str_append(struct gstr *gs , char const   *s ) 
{ 
  size_t l ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 114
  if (s) {
    {
#line 115
    tmp = strlen((char const   *)gs->s);
#line 115
    tmp___0 = strlen(s);
#line 115
    l = (tmp + tmp___0) + 1UL;
    }
#line 116
    if (l > gs->len) {
      {
#line 117
      tmp___1 = realloc((void *)gs->s, l);
#line 117
      gs->s = (char *)tmp___1;
#line 118
      gs->len = l;
      }
    }
    {
#line 120
    strcat((char */* __restrict  */)gs->s, (char const   */* __restrict  */)s);
    }
  }
#line 122
  return;
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/util.c"
void str_printf(struct gstr *gs , char const   *fmt  , ...) 
{ 
  va_list ap ;
  char s[10000] ;

  {
  {
#line 129
  __builtin_va_start(ap, fmt);
#line 130
  vsnprintf((char */* __restrict  */)(s), sizeof(s), (char const   */* __restrict  */)fmt,
            ap);
#line 131
  str_append(gs, (char const   *)(s));
#line 132
  __builtin_va_end(ap);
  }
#line 133
  return;
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/util.c"
char const   *str_get(struct gstr *gs ) 
{ 


  {
#line 138
  return ((char const   *)gs->s);
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/util.c"
void *xmalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;

  {
  {
#line 143
  tmp = malloc(size);
#line 143
  p = tmp;
  }
#line 144
  if (p) {
#line 145
    return (p);
  }
  {
#line 146
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory.\n");
#line 147
  exit(1);
  }
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/util.c"
void *xcalloc(size_t nmemb , size_t size ) 
{ 
  void *p ;
  void *tmp ;

  {
  {
#line 152
  tmp = calloc(nmemb, size);
#line 152
  p = tmp;
  }
#line 153
  if (p) {
#line 154
    return (p);
  }
  {
#line 155
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory.\n");
#line 156
  exit(1);
  }
}
}
#line 321 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/confdata.c"
static void ( /* format attribute */  conf_warning)(char const   *fmt  , ...) ;
#line 22
static void ( /* format attribute */  conf_message)(char const   *fmt  , ...) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/confdata.c"
static char const   *conf_filename  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/confdata.c"
static int conf_lineno  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/confdata.c"
static int conf_warnings  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/confdata.c"
static int conf_unsaved  ;
#line 28 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/confdata.c"
char const   conf_defname[21]  = 
#line 28
  {      (char const   )'a',      (char const   )'r',      (char const   )'c',      (char const   )'h', 
        (char const   )'/',      (char const   )'$',      (char const   )'A',      (char const   )'R', 
        (char const   )'C',      (char const   )'H',      (char const   )'/',      (char const   )'d', 
        (char const   )'e',      (char const   )'f',      (char const   )'c',      (char const   )'o', 
        (char const   )'n',      (char const   )'f',      (char const   )'i',      (char const   )'g', 
        (char const   )'\000'};
#line 30 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/confdata.c"
static void ( /* format attribute */  conf_warning)(char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 33
  __builtin_va_start(ap, fmt);
#line 34
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d:warning: ",
          conf_filename, conf_lineno);
#line 35
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           ap);
#line 36
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 37
  __builtin_va_end(ap);
#line 38
  conf_warnings ++;
  }
#line 39
  return;
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/confdata.c"
static void conf_default_message_callback(char const   *fmt , va_list ap ) 
{ 


  {
  {
#line 43
  printf((char const   */* __restrict  */)"#\n# ");
#line 44
  vprintf((char const   */* __restrict  */)fmt, ap);
#line 45
  printf((char const   */* __restrict  */)"\n#\n");
  }
#line 46
  return;
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/confdata.c"
static void (*conf_message_callback)(char const   *fmt , va_list ap )  =    & conf_default_message_callback;
#line 50 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/confdata.c"
void conf_set_message_callback(void (*fn)(char const   *fmt , va_list ap ) ) 
{ 


  {
#line 52
  conf_message_callback = fn;
#line 53
  return;
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/confdata.c"
static void ( /* format attribute */  conf_message)(char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 59
  __builtin_va_start(ap, fmt);
  }
#line 60
  if (conf_message_callback) {
    {
#line 61
    (*conf_message_callback)(fmt, ap);
    }
  }
#line 62
  return;
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/confdata.c"
char const   *conf_get_configname(void) 
{ 
  char *name ;
  char *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 66
  tmp = getenv("KCONFIG_CONFIG");
#line 66
  name = tmp;
  }
#line 68
  if (name) {
#line 68
    tmp___0 = (char const   *)name;
  } else {
#line 68
    tmp___0 = ".config";
  }
#line 68
  return (tmp___0);
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/confdata.c"
char const   *conf_get_autoconfig_name(void) 
{ 
  char *name ;
  char *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 73
  tmp = getenv("KCONFIG_AUTOCONFIG");
#line 73
  name = tmp;
  }
#line 75
  if (name) {
#line 75
    tmp___0 = (char const   *)name;
  } else {
#line 75
    tmp___0 = "include/config/auto.conf";
  }
#line 75
  return (tmp___0);
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/confdata.c"
static char res_value[256]  ;
#line 78 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/confdata.c"
static char *conf_expand_value(char const   *in ) 
{ 
  struct symbol *sym ;
  char const   *src ;
  char *dst ;
  char name[256] ;
  char *tmp ;
  char const   *tmp___0 ;
  unsigned short const   **tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;

  {
#line 85
  res_value[0] = (char)0;
#line 86
  dst = name;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 87
    tmp___3 = strchr(in, '$');
#line 87
    src = (char const   *)tmp___3;
    }
#line 87
    if (! src) {
#line 87
      goto while_break;
    }
    {
#line 88
    strncat((char */* __restrict  */)(res_value), (char const   */* __restrict  */)in,
            (size_t )(src - in));
#line 89
    src ++;
#line 90
    dst = name;
    }
    {
#line 91
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 91
      tmp___1 = __ctype_b_loc();
      }
#line 91
      if (! ((int const   )*(*tmp___1 + (int )*src) & 8)) {
#line 91
        if (! ((int const   )*src == 95)) {
#line 91
          goto while_break___0;
        }
      }
#line 92
      tmp = dst;
#line 92
      dst ++;
#line 92
      tmp___0 = src;
#line 92
      src ++;
#line 92
      *tmp = (char )*tmp___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 93
    *dst = (char)0;
#line 94
    sym = sym_lookup((char const   *)(name), 0);
#line 95
    sym_calc_value(sym);
#line 96
    tmp___2 = sym_get_string_value(sym);
#line 96
    strcat((char */* __restrict  */)(res_value), (char const   */* __restrict  */)tmp___2);
#line 97
    in = src;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 99
  strcat((char */* __restrict  */)(res_value), (char const   */* __restrict  */)in);
  }
#line 101
  return (res_value);
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/confdata.c"
static char fullname[4097]  ;
#line 104 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/confdata.c"
char *conf_get_default_confname(void) 
{ 
  struct stat buf ;
  char *env ;
  char *name ;
  int tmp ;

  {
  {
#line 110
  name = conf_expand_value(conf_defname);
#line 111
  env = getenv("srctree");
  }
#line 112
  if (env) {
    {
#line 113
    sprintf((char */* __restrict  */)(fullname), (char const   */* __restrict  */)"%s/%s",
            env, name);
#line 114
    tmp = stat((char const   */* __restrict  */)(fullname), (struct stat */* __restrict  */)(& buf));
    }
#line 114
    if (! tmp) {
#line 115
      return (fullname);
    }
  }
#line 117
  return (name);
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/confdata.c"
static int conf_set_sym_val(struct symbol *sym , int def , int def_flags , char *p ) 
{ 
  char *p2 ;
  unsigned short const   **tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  _Bool tmp___3 ;

  {
  {
#line 125
  if ((unsigned int )sym->type == 2U) {
#line 125
    goto case_2;
  }
#line 132
  if ((unsigned int )sym->type == 1U) {
#line 132
    goto case_1;
  }
#line 147
  if ((unsigned int )sym->type == 6U) {
#line 147
    goto case_6;
  }
#line 155
  if ((unsigned int )sym->type == 5U) {
#line 155
    goto case_5;
  }
#line 172
  if ((unsigned int )sym->type == 4U) {
#line 172
    goto done;
  }
#line 172
  if ((unsigned int )sym->type == 3U) {
#line 172
    goto done;
  }
#line 184
  goto switch_default;
  case_2: /* CIL Label */ 
#line 126
  if ((int )*(p + 0) == 109) {
#line 127
    sym->def[def].tri = (tristate )1;
#line 128
    sym->flags |= def_flags;
#line 129
    goto switch_break;
  }
  case_1: /* CIL Label */ 
#line 133
  if ((int )*(p + 0) == 121) {
#line 134
    sym->def[def].tri = (tristate )2;
#line 135
    sym->flags |= def_flags;
#line 136
    goto switch_break;
  }
#line 138
  if ((int )*(p + 0) == 110) {
#line 139
    sym->def[def].tri = (tristate )0;
#line 140
    sym->flags |= def_flags;
#line 141
    goto switch_break;
  }
#line 143
  if (def != 1) {
    {
#line 144
    conf_warning("symbol value \'%s\' invalid for %s", p, sym->name);
    }
  }
#line 146
  return (1);
  case_6: /* CIL Label */ 
#line 148
  if ((int )*p != 34) {
#line 149
    p2 = p;
    {
#line 149
    while (1) {
      while_continue: /* CIL Label */ ;
#line 149
      if (*p2) {
        {
#line 149
        tmp = __ctype_b_loc();
        }
#line 149
        if ((int const   )*(*tmp + (int )*p2) & 8192) {
#line 149
          goto while_break;
        }
      } else {
#line 149
        goto while_break;
      }
#line 149
      p2 ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 151
    sym->type = (enum symbol_type )5;
#line 152
    goto done;
  }
  case_5: /* CIL Label */ 
#line 156
  tmp___0 = p;
#line 156
  p ++;
#line 156
  if ((int )*tmp___0 != 34) {
#line 157
    goto switch_break;
  }
#line 158
  p2 = p;
  {
#line 158
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 158
    p2 = strpbrk((char const   *)p2, "\"\\");
    }
#line 158
    if (! p2) {
#line 158
      goto while_break___0;
    }
#line 159
    if ((int )*p2 == 34) {
#line 160
      *p2 = (char)0;
#line 161
      goto while_break___0;
    }
    {
#line 163
    tmp___1 = strlen((char const   *)p2);
#line 163
    memmove((void *)p2, (void const   *)(p2 + 1), tmp___1);
#line 158
    p2 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 165
  if (! p2) {
#line 166
    if (def != 1) {
      {
#line 167
      conf_warning("invalid string found");
      }
    }
#line 168
    return (1);
  }
  done: 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 174
  tmp___3 = sym_string_valid(sym, (char const   *)p);
  }
#line 174
  if (tmp___3) {
    {
#line 175
    tmp___2 = strdup((char const   *)p);
#line 175
    sym->def[def].val = (void *)tmp___2;
#line 176
    sym->flags |= def_flags;
    }
  } else {
#line 178
    if (def != 1) {
      {
#line 179
      conf_warning("symbol value \'%s\' invalid for %s", p, sym->name);
      }
    }
#line 181
    return (1);
  }
#line 183
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 187
  return (0);
}
}
#line 191 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/confdata.c"
static int add_byte(int c , char **lineptr , size_t slen , size_t *n ) 
{ 
  char *nline ;
  size_t new_size ;
  void *tmp ;

  {
#line 194
  new_size = slen + 1UL;
#line 195
  if (new_size > *n) {
    {
#line 196
    new_size += 15UL;
#line 197
    new_size *= 2UL;
#line 198
    tmp = realloc((void *)*lineptr, new_size);
#line 198
    nline = (char *)tmp;
    }
#line 199
    if (! nline) {
#line 200
      return (-1);
    }
#line 202
    *lineptr = nline;
#line 203
    *n = new_size;
  }
#line 206
  *(*lineptr + slen) = (char )c;
#line 208
  return (0);
}
}
#line 211 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/confdata.c"
static ssize_t compat_getline(char **lineptr , size_t *n , FILE *stream ) 
{ 
  char *line___0 ;
  size_t slen ;
  int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 213
  line___0 = *lineptr;
#line 214
  slen = (size_t )0;
  {
#line 216
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 217
    tmp = _IO_getc(stream);
#line 217
    c = tmp;
    }
    {
#line 220
    if (c == 10) {
#line 220
      goto case_10;
    }
#line 225
    if (c == -1) {
#line 225
      goto case_neg_1;
    }
#line 232
    goto switch_default;
    case_10: /* CIL Label */ 
    {
#line 221
    tmp___0 = add_byte(c, & line___0, slen, n);
    }
#line 221
    if (tmp___0 < 0) {
#line 222
      goto e_out;
    }
#line 223
    slen ++;
    case_neg_1: /* CIL Label */ 
    {
#line 226
    tmp___1 = add_byte('\000', & line___0, slen, n);
    }
#line 226
    if (tmp___1 < 0) {
#line 227
      goto e_out;
    }
#line 228
    *lineptr = line___0;
#line 229
    if (slen == 0UL) {
#line 230
      return ((ssize_t )-1);
    }
#line 231
    return ((ssize_t )slen);
    switch_default: /* CIL Label */ 
    {
#line 233
    tmp___2 = add_byte(c, & line___0, slen, n);
    }
#line 233
    if (tmp___2 < 0) {
#line 234
      goto e_out;
    }
#line 235
    slen ++;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  e_out: 
#line 240
  *(line___0 + (slen - 1UL)) = (char )'\000';
#line 241
  *lineptr = line___0;
#line 242
  return ((ssize_t )-1);
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/confdata.c"
int conf_read_simple(char const   *name , int def ) 
{ 
  FILE *in ;
  char *line___0 ;
  size_t line_asize ;
  char *p ;
  char *p2 ;
  struct symbol *sym ;
  int i ;
  int def_flags ;
  struct property *prop ;
  tristate tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  _Bool tmp___2 ;
  char const   *tmp___3 ;
  size_t tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  size_t tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  size_t tmp___12 ;
  char const   *tmp___13 ;
  size_t tmp___14 ;
  char const   *tmp___15 ;
  size_t tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char const   *tmp___19 ;
  size_t tmp___20 ;
  char const   *tmp___21 ;
  size_t tmp___22 ;
  int tmp___23 ;
  char const   *tmp___24 ;
  size_t tmp___25 ;
  char const   *tmp___26 ;
  int tmp___27 ;
  struct symbol *cs ;
  struct property *tmp___28 ;
  struct symbol *tmp___29 ;
  _Bool tmp___30 ;
  ssize_t tmp___31 ;

  {
#line 247
  in = (FILE *)((void *)0);
#line 248
  line___0 = (char *)((void *)0);
#line 249
  line_asize = (size_t )0;
#line 254
  if (name) {
    {
#line 255
    in = zconf_fopen(name);
    }
  } else {
    {
#line 259
    name = conf_get_configname();
#line 260
    in = zconf_fopen(name);
    }
#line 261
    if (in) {
#line 262
      goto load;
    }
    {
#line 263
    sym_add_change_count(1);
    }
#line 264
    if (! sym_defconfig_list) {
#line 265
      if (modules_sym) {
        {
#line 266
        sym_calc_value(modules_sym);
        }
      }
#line 267
      return (1);
    }
#line 270
    prop = sym_defconfig_list->prop;
    {
#line 270
    while (1) {
      while_continue: /* CIL Label */ ;
#line 270
      if (! prop) {
#line 270
        goto while_break;
      }
#line 270
      if ((unsigned int )prop->type == 4U) {
        {
#line 271
        tmp = expr_calc_value(prop->visible.expr);
        }
#line 271
        if ((unsigned int )tmp == 0U) {
#line 273
          goto __Cont;
        } else
#line 271
        if ((unsigned int )(prop->expr)->type != 7U) {
#line 273
          goto __Cont;
        }
        {
#line 274
        tmp___0 = conf_expand_value((char const   *)((prop->expr)->left.sym)->name);
#line 274
        name = (char const   *)tmp___0;
#line 275
        in = zconf_fopen(name);
        }
#line 276
        if (in) {
          {
#line 277
          tmp___1 = gettext("using defaults found in %s");
#line 277
          conf_message((char const   *)tmp___1, name);
          }
#line 279
          goto load;
        }
      }
      __Cont: /* CIL Label */ 
#line 270
      prop = prop->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 283
  if (! in) {
#line 284
    return (1);
  }
  load: 
#line 287
  conf_filename = name;
#line 288
  conf_lineno = 0;
#line 289
  conf_warnings = 0;
#line 290
  conf_unsaved = 0;
#line 292
  def_flags = 65536 << def;
#line 293
  i = 0;
  {
#line 293
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 293
    if (! (i < 9973)) {
#line 293
      goto while_break___0;
    }
#line 293
    sym = symbol_hash[i];
    {
#line 293
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 293
      if (! sym) {
#line 293
        goto while_break___1;
      }
#line 293
      if ((unsigned int )sym->type != 6U) {
        {
#line 294
        sym->flags |= 1024;
#line 295
        sym->flags &= ~ (def_flags | 128);
#line 296
        tmp___2 = sym_is_choice(sym);
        }
#line 296
        if (tmp___2) {
#line 297
          sym->flags |= def_flags;
        }
        {
#line 301
        if ((unsigned int )sym->type == 5U) {
#line 301
          goto case_5;
        }
#line 301
        if ((unsigned int )sym->type == 4U) {
#line 301
          goto case_5;
        }
#line 301
        if ((unsigned int )sym->type == 3U) {
#line 301
          goto case_5;
        }
#line 305
        goto switch_default;
        case_5: /* CIL Label */ 
        case_4: /* CIL Label */ 
        case_3: /* CIL Label */ 
#line 302
        if (sym->def[def].val) {
          {
#line 303
          free(sym->def[def].val);
          }
        }
        switch_default: /* CIL Label */ 
#line 306
        sym->def[def].val = (void *)0;
#line 307
        sym->def[def].tri = (tristate )0;
        switch_break: /* CIL Label */ ;
        }
      }
#line 293
      sym = sym->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 293
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 311
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 311
    tmp___31 = compat_getline(& line___0, & line_asize, in);
    }
#line 311
    if (! (tmp___31 != -1L)) {
#line 311
      goto while_break___2;
    }
#line 312
    conf_lineno ++;
#line 313
    sym = (struct symbol *)((void *)0);
#line 314
    if ((int )*(line___0 + 0) == 35) {
      {
#line 315
      tmp___3 = CONFIG_prefix();
#line 315
      tmp___4 = strlen(tmp___3);
#line 315
      tmp___5 = CONFIG_prefix();
#line 315
      tmp___6 = memcmp((void const   *)(line___0 + 2), (void const   *)tmp___5, tmp___4);
      }
#line 315
      if (tmp___6) {
#line 316
        goto while_continue___2;
      }
      {
#line 317
      tmp___7 = CONFIG_prefix();
#line 317
      tmp___8 = strlen(tmp___7);
#line 317
      p = strchr((char const   *)((line___0 + 2) + tmp___8), ' ');
      }
#line 318
      if (! p) {
#line 319
        goto while_continue___2;
      }
      {
#line 320
      tmp___9 = p;
#line 320
      p ++;
#line 320
      *tmp___9 = (char)0;
#line 321
      tmp___10 = strncmp((char const   *)p, "is not set", (size_t )10);
      }
#line 321
      if (tmp___10) {
#line 322
        goto while_continue___2;
      }
#line 323
      if (def == 0) {
        {
#line 324
        tmp___11 = CONFIG_prefix();
#line 324
        tmp___12 = strlen(tmp___11);
#line 324
        sym = sym_find((char const   *)((line___0 + 2) + tmp___12));
        }
#line 325
        if (! sym) {
          {
#line 326
          sym_add_change_count(1);
          }
#line 327
          goto setsym;
        }
      } else {
        {
#line 330
        tmp___13 = CONFIG_prefix();
#line 330
        tmp___14 = strlen(tmp___13);
#line 330
        sym = sym_lookup((char const   *)((line___0 + 2) + tmp___14), 0);
        }
#line 331
        if ((unsigned int )sym->type == 0U) {
#line 332
          sym->type = (enum symbol_type )1;
        }
      }
#line 334
      if (sym->flags & def_flags) {
        {
#line 335
        conf_warning("override: reassigning to symbol %s", sym->name);
        }
      }
      {
#line 339
      if ((unsigned int )sym->type == 2U) {
#line 339
        goto case_2;
      }
#line 339
      if ((unsigned int )sym->type == 1U) {
#line 339
        goto case_2;
      }
#line 343
      goto switch_default___0;
      case_2: /* CIL Label */ 
      case_1: /* CIL Label */ 
#line 340
      sym->def[def].tri = (tristate )0;
#line 341
      sym->flags |= def_flags;
#line 342
      goto switch_break___0;
      switch_default___0: /* CIL Label */ ;
      switch_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 346
      tmp___24 = CONFIG_prefix();
#line 346
      tmp___25 = strlen(tmp___24);
#line 346
      tmp___26 = CONFIG_prefix();
#line 346
      tmp___27 = memcmp((void const   *)line___0, (void const   *)tmp___26, tmp___25);
      }
#line 346
      if (tmp___27 == 0) {
        {
#line 347
        tmp___15 = CONFIG_prefix();
#line 347
        tmp___16 = strlen(tmp___15);
#line 347
        p = strchr((char const   *)(line___0 + tmp___16), '=');
        }
#line 348
        if (! p) {
#line 349
          goto while_continue___2;
        }
        {
#line 350
        tmp___17 = p;
#line 350
        p ++;
#line 350
        *tmp___17 = (char)0;
#line 351
        p2 = strchr((char const   *)p, '\n');
        }
#line 352
        if (p2) {
#line 353
          tmp___18 = p2;
#line 353
          p2 --;
#line 353
          *tmp___18 = (char)0;
#line 354
          if ((int )*p2 == 13) {
#line 355
            *p2 = (char)0;
          }
        }
#line 357
        if (def == 0) {
          {
#line 358
          tmp___19 = CONFIG_prefix();
#line 358
          tmp___20 = strlen(tmp___19);
#line 358
          sym = sym_find((char const   *)(line___0 + tmp___20));
          }
#line 359
          if (! sym) {
            {
#line 360
            sym_add_change_count(1);
            }
#line 361
            goto setsym;
          }
        } else {
          {
#line 364
          tmp___21 = CONFIG_prefix();
#line 364
          tmp___22 = strlen(tmp___21);
#line 364
          sym = sym_lookup((char const   *)(line___0 + tmp___22), 0);
          }
#line 365
          if ((unsigned int )sym->type == 0U) {
#line 366
            sym->type = (enum symbol_type )6;
          }
        }
#line 368
        if (sym->flags & def_flags) {
          {
#line 369
          conf_warning("override: reassigning to symbol %s", sym->name);
          }
        }
        {
#line 371
        tmp___23 = conf_set_sym_val(sym, def, def_flags, p);
        }
#line 371
        if (tmp___23) {
#line 372
          goto while_continue___2;
        }
      } else {
#line 374
        if ((int )*(line___0 + 0) != 13) {
#line 374
          if ((int )*(line___0 + 0) != 10) {
            {
#line 375
            conf_warning("unexpected data");
            }
          }
        }
#line 376
        goto while_continue___2;
      }
    }
    setsym: 
#line 379
    if (sym) {
      {
#line 379
      tmp___30 = sym_is_choice_value(sym);
      }
#line 379
      if (tmp___30) {
        {
#line 380
        tmp___28 = sym_get_choice_prop(sym);
#line 380
        tmp___29 = prop_get_symbol(tmp___28);
#line 380
        cs = tmp___29;
        }
        {
#line 382
        if ((unsigned int )sym->def[def].tri == 0U) {
#line 382
          goto case_0;
        }
#line 384
        if ((unsigned int )sym->def[def].tri == 1U) {
#line 384
          goto case_1___0;
        }
#line 390
        if ((unsigned int )sym->def[def].tri == 2U) {
#line 390
          goto case_2___0;
        }
#line 381
        goto switch_break___1;
        case_0: /* CIL Label */ 
#line 383
        goto switch_break___1;
        case_1___0: /* CIL Label */ 
#line 385
        if ((unsigned int )cs->def[def].tri == 2U) {
          {
#line 386
          conf_warning("%s creates inconsistent choice state", sym->name);
#line 387
          cs->flags &= ~ def_flags;
          }
        }
#line 389
        goto switch_break___1;
        case_2___0: /* CIL Label */ 
#line 391
        if ((unsigned int )cs->def[def].tri != 0U) {
          {
#line 392
          conf_warning("override: %s changes choice state", sym->name);
          }
        }
#line 393
        cs->def[def].val = (void *)sym;
#line 394
        goto switch_break___1;
        switch_break___1: /* CIL Label */ ;
        }
#line 396
        if ((unsigned int )cs->def[def].tri > (unsigned int )sym->def[def].tri) {
#line 396
          cs->def[def].tri = cs->def[def].tri;
        } else {
#line 396
          cs->def[def].tri = sym->def[def].tri;
        }
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 399
  free((void *)line___0);
#line 400
  fclose(in);
  }
#line 402
  if (modules_sym) {
    {
#line 403
    sym_calc_value(modules_sym);
    }
  }
#line 404
  return (0);
}
}
#line 407 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/confdata.c"
int conf_read(char const   *name ) 
{ 
  struct symbol *sym ;
  int i ;
  int tmp ;
  _Bool tmp___0 ;
  tristate tmp___1 ;
  _Bool tmp___2 ;
  int tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;
  int tmp___9 ;

  {
  {
#line 412
  sym_set_change_count(0);
#line 414
  tmp = conf_read_simple(name, 0);
  }
#line 414
  if (tmp) {
#line 415
    return (1);
  }
#line 417
  i = 0;
  {
#line 417
  while (1) {
    while_continue: /* CIL Label */ ;
#line 417
    if (! (i < 9973)) {
#line 417
      goto while_break;
    }
#line 417
    sym = symbol_hash[i];
    {
#line 417
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 417
      if (! sym) {
#line 417
        goto while_break___0;
      }
#line 417
      if ((unsigned int )sym->type != 6U) {
        {
#line 418
        sym_calc_value(sym);
#line 419
        tmp___0 = sym_is_choice(sym);
        }
#line 419
        if (tmp___0) {
#line 420
          goto __Cont;
        } else
#line 419
        if (sym->flags & 4096) {
#line 420
          goto __Cont;
        }
        {
#line 421
        tmp___5 = sym_has_value(sym);
        }
#line 421
        if (tmp___5) {
#line 421
          if (sym->flags & 512) {
            {
#line 425
            if ((unsigned int )sym->type == 2U) {
#line 425
              goto case_2;
            }
#line 425
            if ((unsigned int )sym->type == 1U) {
#line 425
              goto case_2;
            }
#line 431
            goto switch_default;
            case_2: /* CIL Label */ 
            case_1: /* CIL Label */ 
            {
#line 426
            tmp___1 = sym_get_tristate_value(sym);
            }
#line 426
            if ((unsigned int )sym->def[0].tri != (unsigned int )tmp___1) {
#line 427
              goto switch_break;
            }
            {
#line 428
            tmp___2 = sym_is_choice(sym);
            }
#line 428
            if (! tmp___2) {
#line 429
              goto __Cont;
            }
            switch_default: /* CIL Label */ 
            {
#line 432
            tmp___3 = strcmp((char const   *)sym->curr.val, (char const   *)sym->def[0].val);
            }
#line 432
            if (! tmp___3) {
#line 433
              goto __Cont;
            }
#line 434
            goto switch_break;
            switch_break: /* CIL Label */ ;
            }
          } else {
#line 421
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 436
          tmp___4 = sym_has_value(sym);
          }
#line 436
          if (! tmp___4) {
#line 436
            if (! (sym->flags & 512)) {
#line 438
              goto __Cont;
            }
          }
        }
#line 439
        conf_unsaved ++;
      }
      __Cont: /* CIL Label */ 
#line 417
      sym = sym->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 417
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 443
  i = 0;
  {
#line 443
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 443
    if (! (i < 9973)) {
#line 443
      goto while_break___1;
    }
#line 443
    sym = symbol_hash[i];
    {
#line 443
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 443
      if (! sym) {
#line 443
        goto while_break___2;
      }
#line 443
      if ((unsigned int )sym->type != 6U) {
        {
#line 444
        tmp___7 = sym_has_value(sym);
        }
#line 444
        if (tmp___7) {
          {
#line 444
          tmp___8 = sym_is_choice_value(sym);
          }
#line 444
          if (! tmp___8) {
#line 450
            if ((unsigned int )sym->visible == 0U) {
#line 450
              if (! conf_unsaved) {
#line 451
                sym->flags &= -65537;
              }
            }
            {
#line 455
            if ((unsigned int )sym->type == 4U) {
#line 455
              goto case_4;
            }
#line 455
            if ((unsigned int )sym->type == 3U) {
#line 455
              goto case_4;
            }
#line 455
            if ((unsigned int )sym->type == 5U) {
#line 455
              goto case_4;
            }
#line 462
            goto switch_default___0;
            case_4: /* CIL Label */ 
            case_3: /* CIL Label */ 
            case_5: /* CIL Label */ 
            {
#line 457
            tmp___6 = sym_string_within_range(sym, (char const   *)sym->def[0].val);
            }
#line 457
            if (tmp___6) {
#line 458
              goto switch_break___0;
            }
#line 459
            sym->flags &= -65665;
#line 460
            conf_unsaved ++;
#line 461
            goto switch_break___0;
            switch_default___0: /* CIL Label */ 
#line 463
            goto switch_break___0;
            switch_break___0: /* CIL Label */ ;
            }
          }
        }
      }
#line 443
      sym = sym->next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 443
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 468
  if (conf_warnings) {
#line 468
    tmp___9 = 1;
  } else
#line 468
  if (conf_unsaved) {
#line 468
    tmp___9 = 1;
  } else {
#line 468
    tmp___9 = 0;
  }
  {
#line 468
  sym_add_change_count(tmp___9);
  }
#line 470
  return (0);
}
}
#line 481 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/confdata.c"
static void kconfig_print_symbol(FILE *fp , struct symbol *sym , char const   *value ,
                                 void *arg ) 
{ 
  _Bool skip_unset ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 487
  if ((unsigned int )sym->type == 2U) {
#line 487
    goto case_2;
  }
#line 487
  if ((unsigned int )sym->type == 1U) {
#line 487
    goto case_2;
  }
#line 497
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 488
  if ((int const   )*value == 110) {
#line 489
    skip_unset = (_Bool )((unsigned long )arg != (unsigned long )((void *)0));
#line 491
    if (! skip_unset) {
      {
#line 492
      tmp = CONFIG_prefix();
#line 492
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"# %s%s is not set\n",
              tmp, sym->name);
      }
    }
#line 494
    return;
  }
#line 496
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 498
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 501
  tmp___0 = CONFIG_prefix();
#line 501
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s%s=%s\n",
          tmp___0, sym->name, value);
  }
#line 502
  return;
}
}
#line 504 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/confdata.c"
static void kconfig_print_comment(FILE *fp , char const   *value , void *arg ) 
{ 
  char const   *p ;
  size_t l ;
  char const   *tmp ;

  {
#line 507
  p = value;
  {
#line 510
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 511
    l = strcspn(p, "\n");
#line 512
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#");
    }
#line 513
    if (l) {
      {
#line 514
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" ");
#line 515
      xfwrite((void const   *)p, l, (size_t )1, fp);
#line 516
      p += l;
      }
    }
    {
#line 518
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
#line 519
    tmp = p;
#line 519
    p ++;
    }
#line 519
    if ((int const   )*tmp == 0) {
#line 520
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 522
  return;
}
}
#line 524 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/confdata.c"
static struct conf_printer kconfig_printer_cb  =    {& kconfig_print_symbol, & kconfig_print_comment};
#line 535 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/confdata.c"
static void header_print_symbol(FILE *fp , struct symbol *sym , char const   *value ,
                                void *arg ) 
{ 
  char const   *suffix ;
  char const   *tmp ;
  char const   *prefix ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 541
  if ((unsigned int )sym->type == 2U) {
#line 541
    goto case_2;
  }
#line 541
  if ((unsigned int )sym->type == 1U) {
#line 541
    goto case_2;
  }
#line 556
  if ((unsigned int )sym->type == 4U) {
#line 556
    goto case_4;
  }
#line 566
  if ((unsigned int )sym->type == 3U) {
#line 566
    goto case_3;
  }
#line 566
  if ((unsigned int )sym->type == 5U) {
#line 566
    goto case_3;
  }
#line 570
  goto switch_default___0;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 542
  suffix = "";
  {
#line 545
  if ((int const   )*value == 110) {
#line 545
    goto case_110;
  }
#line 547
  if ((int const   )*value == 109) {
#line 547
    goto case_109;
  }
#line 550
  goto switch_default;
  case_110: /* CIL Label */ 
#line 546
  goto switch_break___0;
  case_109: /* CIL Label */ 
#line 548
  suffix = "_MODULE";
  switch_default: /* CIL Label */ 
  {
#line 551
  tmp = CONFIG_prefix();
#line 551
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#define %s%s%s 1\n",
          tmp, sym->name, suffix);
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 554
  goto switch_break;
  case_4: /* CIL Label */ 
#line 557
  prefix = "";
#line 559
  if ((int const   )*(value + 0) != 48) {
#line 560
    prefix = "0x";
  } else
#line 559
  if ((int const   )*(value + 1) != 120) {
#line 559
    if ((int const   )*(value + 1) != 88) {
#line 560
      prefix = "0x";
    }
  }
  {
#line 561
  tmp___0 = CONFIG_prefix();
#line 561
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#define %s%s %s%s\n",
          tmp___0, sym->name, prefix, value);
  }
#line 563
  goto switch_break;
  case_3: /* CIL Label */ 
  case_5: /* CIL Label */ 
  {
#line 567
  tmp___1 = CONFIG_prefix();
#line 567
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#define %s%s %s\n",
          tmp___1, sym->name, value);
  }
#line 569
  goto switch_break;
  switch_default___0: /* CIL Label */ 
#line 571
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 574
  return;
}
}
#line 576 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/confdata.c"
static void header_print_comment(FILE *fp , char const   *value , void *arg ) 
{ 
  char const   *p ;
  size_t l ;
  char const   *tmp ;

  {
  {
#line 579
  p = value;
#line 582
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"/*\n");
  }
  {
#line 583
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 584
    l = strcspn(p, "\n");
#line 585
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" *");
    }
#line 586
    if (l) {
      {
#line 587
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" ");
#line 588
      xfwrite((void const   *)p, l, (size_t )1, fp);
#line 589
      p += l;
      }
    }
    {
#line 591
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
#line 592
    tmp = p;
#line 592
    p ++;
    }
#line 592
    if ((int const   )*tmp == 0) {
#line 593
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 595
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" */\n");
  }
#line 596
  return;
}
}
#line 598 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/confdata.c"
static struct conf_printer header_printer_cb  =    {& header_print_symbol, & header_print_comment};
#line 609 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/confdata.c"
static void tristate_print_symbol(FILE *fp , struct symbol *sym , char const   *value ,
                                  void *arg ) 
{ 
  int tmp ;
  char const   *tmp___0 ;

  {
#line 613
  if ((unsigned int )sym->type == 2U) {
#line 613
    if ((int const   )*value != 110) {
      {
#line 614
      tmp = toupper((int )*value);
#line 614
      tmp___0 = CONFIG_prefix();
#line 614
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s%s=%c\n",
              tmp___0, sym->name, (int )((char )tmp));
      }
    }
  }
#line 615
  return;
}
}
#line 617 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/confdata.c"
static struct conf_printer tristate_printer_cb  =    {& tristate_print_symbol, & kconfig_print_comment};
#line 623 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/confdata.c"
static void conf_write_symbol(FILE *fp , struct symbol *sym , struct conf_printer *printer ,
                              void *printer_arg ) 
{ 
  char const   *str ;

  {
  {
#line 630
  if ((unsigned int )sym->type == 0U) {
#line 630
    goto case_0;
  }
#line 630
  if ((unsigned int )sym->type == 6U) {
#line 630
    goto case_0;
  }
#line 632
  if ((unsigned int )sym->type == 5U) {
#line 632
    goto case_5;
  }
#line 638
  goto switch_default;
  case_0: /* CIL Label */ 
  case_6: /* CIL Label */ 
#line 631
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 633
  str = sym_get_string_value(sym);
#line 634
  str = sym_escape_string_value(str);
#line 635
  (*(printer->print_symbol))(fp, sym, str, printer_arg);
#line 636
  free((void *)str);
  }
#line 637
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 639
  str = sym_get_string_value(sym);
#line 640
  (*(printer->print_symbol))(fp, sym, str, printer_arg);
  }
  switch_break: /* CIL Label */ ;
  }
#line 642
  return;
}
}
#line 644 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/confdata.c"
static void conf_write_heading(FILE *fp , struct conf_printer *printer , void *printer_arg ) 
{ 
  char buf[256] ;

  {
  {
#line 649
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"\nAutomatically generated file; DO NOT EDIT.\n%s\n",
           (rootmenu.prompt)->text);
#line 655
  (*(printer->print_comment))(fp, (char const   *)(buf), printer_arg);
  }
#line 656
  return;
}
}
#line 662 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/confdata.c"
int conf_write_defconfig(char const   *filename ) 
{ 
  struct symbol *sym ;
  struct menu *menu ;
  FILE *out ;
  _Bool tmp ;
  _Bool tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  struct symbol *cs ;
  struct symbol *ds ;
  struct property *tmp___4 ;
  tristate tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;

  {
  {
#line 668
  out = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"w");
  }
#line 669
  if (! out) {
#line 670
    return (1);
  }
  {
#line 672
  sym_clear_all_valid();
#line 675
  menu = rootmenu.list;
  }
  {
#line 677
  while (1) {
    while_continue: /* CIL Label */ ;
#line 677
    if (! ((unsigned long )menu != (unsigned long )((void *)0))) {
#line 677
      goto while_break;
    }
#line 679
    sym = menu->sym;
#line 680
    if ((unsigned long )sym == (unsigned long )((void *)0)) {
      {
#line 681
      tmp = menu_is_visible(menu);
      }
#line 681
      if (! tmp) {
#line 682
        goto next_menu;
      }
    } else {
      {
#line 683
      tmp___8 = sym_is_choice(sym);
      }
#line 683
      if (! tmp___8) {
        {
#line 684
        sym_calc_value(sym);
        }
#line 685
        if (! (sym->flags & 512)) {
#line 686
          goto next_menu;
        }
        {
#line 687
        sym->flags &= -513;
#line 689
        tmp___0 = sym_is_changable(sym);
        }
#line 689
        if (! tmp___0) {
#line 690
          goto next_menu;
        }
        {
#line 692
        tmp___1 = sym_get_string_default(sym);
#line 692
        tmp___2 = sym_get_string_value(sym);
#line 692
        tmp___3 = strcmp(tmp___2, tmp___1);
        }
#line 692
        if (tmp___3 == 0) {
#line 693
          goto next_menu;
        }
        {
#line 702
        tmp___7 = sym_is_choice_value(sym);
        }
#line 702
        if (tmp___7) {
          {
#line 706
          tmp___4 = sym_get_choice_prop(sym);
#line 706
          cs = prop_get_symbol(tmp___4);
#line 707
          ds = sym_choice_default(cs);
#line 708
          tmp___6 = sym_is_optional(cs);
          }
#line 708
          if (! tmp___6) {
#line 708
            if ((unsigned long )sym == (unsigned long )ds) {
#line 709
              if ((unsigned int )sym->type == 1U) {
                {
#line 709
                tmp___5 = sym_get_tristate_value(sym);
                }
#line 709
                if ((unsigned int )tmp___5 == 2U) {
#line 711
                  goto next_menu;
                }
              }
            }
          }
        }
        {
#line 714
        conf_write_symbol(out, sym, & kconfig_printer_cb, (void *)0);
        }
      }
    }
    next_menu: 
#line 717
    if ((unsigned long )menu->list != (unsigned long )((void *)0)) {
#line 718
      menu = menu->list;
    } else
#line 720
    if ((unsigned long )menu->next != (unsigned long )((void *)0)) {
#line 721
      menu = menu->next;
    } else {
      {
#line 723
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 723
        menu = menu->parent;
#line 723
        if (! menu) {
#line 723
          goto while_break___0;
        }
#line 724
        if ((unsigned long )menu->next != (unsigned long )((void *)0)) {
#line 725
          menu = menu->next;
#line 726
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 731
  fclose(out);
  }
#line 732
  return (0);
}
}
#line 735 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/confdata.c"
int conf_write(char const   *name ) 
{ 
  FILE *out ;
  struct symbol *sym ;
  struct menu *menu ;
  char const   *basename ;
  char const   *str ;
  char dirname[4097] ;
  char tmpname[4097] ;
  char newname[4097] ;
  char *env ;
  struct stat st ;
  char *slash ;
  int size ;
  int tmp ;
  __pid_t tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
#line 745
  dirname[0] = (char)0;
#line 746
  if (name) {
#line 746
    if (*(name + 0)) {
      {
#line 750
      tmp = stat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& st));
      }
#line 750
      if (tmp) {
        _L: /* CIL Label */ 
        {
#line 754
        slash = strrchr(name, '/');
        }
#line 754
        if (slash) {
          {
#line 755
          size = (int )((slash - (char *)name) + 1L);
#line 756
          memcpy((void */* __restrict  */)(dirname), (void const   */* __restrict  */)name,
                 (size_t )size);
#line 757
          dirname[size] = (char)0;
          }
#line 758
          if (*(slash + 1)) {
#line 759
            basename = (char const   *)(slash + 1);
          } else {
            {
#line 761
            basename = conf_get_configname();
            }
          }
        } else {
#line 763
          basename = name;
        }
      } else
#line 750
      if ((st.st_mode & 61440U) == 16384U) {
        {
#line 751
        strcpy((char */* __restrict  */)(dirname), (char const   */* __restrict  */)name);
#line 752
        strcat((char */* __restrict  */)(dirname), (char const   */* __restrict  */)"/");
#line 753
        basename = conf_get_configname();
        }
      } else {
#line 750
        goto _L;
      }
    } else {
      {
#line 765
      basename = conf_get_configname();
      }
    }
  } else {
    {
#line 765
    basename = conf_get_configname();
    }
  }
  {
#line 767
  sprintf((char */* __restrict  */)(newname), (char const   */* __restrict  */)"%s%s",
          dirname, basename);
#line 768
  env = getenv("KCONFIG_OVERWRITECONFIG");
  }
#line 769
  if (! env) {
    {
#line 770
    tmp___0 = getpid();
#line 770
    sprintf((char */* __restrict  */)(tmpname), (char const   */* __restrict  */)"%s.tmpconfig.%d",
            dirname, tmp___0);
#line 771
    out = fopen((char const   */* __restrict  */)(tmpname), (char const   */* __restrict  */)"w");
    }
  } else
#line 769
  if (! *env) {
    {
#line 770
    tmp___0 = getpid();
#line 770
    sprintf((char */* __restrict  */)(tmpname), (char const   */* __restrict  */)"%s.tmpconfig.%d",
            dirname, tmp___0);
#line 771
    out = fopen((char const   */* __restrict  */)(tmpname), (char const   */* __restrict  */)"w");
    }
  } else {
    {
#line 773
    tmpname[0] = (char)0;
#line 774
    out = fopen((char const   */* __restrict  */)(newname), (char const   */* __restrict  */)"w");
    }
  }
#line 776
  if (! out) {
#line 777
    return (1);
  }
  {
#line 779
  conf_write_heading(out, & kconfig_printer_cb, (void *)0);
#line 781
  tmp___1 = conf_get_changed();
  }
#line 781
  if (! tmp___1) {
    {
#line 782
    sym_clear_all_valid();
    }
  }
#line 784
  menu = rootmenu.list;
  {
#line 785
  while (1) {
    while_continue: /* CIL Label */ ;
#line 785
    if (! menu) {
#line 785
      goto while_break;
    }
#line 786
    sym = menu->sym;
#line 787
    if (! sym) {
      {
#line 788
      tmp___2 = menu_is_visible(menu);
      }
#line 788
      if (! tmp___2) {
#line 789
        goto next;
      }
      {
#line 790
      str = menu_get_prompt(menu);
#line 791
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\n#\n# %s\n#\n",
              str);
      }
    } else
#line 795
    if (! (sym->flags & 16)) {
      {
#line 796
      sym_calc_value(sym);
      }
#line 797
      if (! (sym->flags & 512)) {
#line 798
        goto next;
      }
      {
#line 799
      sym->flags &= -513;
#line 801
      conf_write_symbol(out, sym, & kconfig_printer_cb, (void *)0);
      }
    }
    next: 
#line 805
    if (menu->list) {
#line 806
      menu = menu->list;
#line 807
      goto while_continue;
    }
#line 809
    if (menu->next) {
#line 810
      menu = menu->next;
    } else {
      {
#line 811
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 811
        menu = menu->parent;
#line 811
        if (! menu) {
#line 811
          goto while_break___0;
        }
#line 812
        if (menu->next) {
#line 813
          menu = menu->next;
#line 814
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 818
  fclose(out);
  }
#line 820
  if (tmpname[0]) {
    {
#line 821
    strcat((char */* __restrict  */)(dirname), (char const   */* __restrict  */)basename);
#line 822
    strcat((char */* __restrict  */)(dirname), (char const   */* __restrict  */)".old");
#line 823
    rename((char const   *)(newname), (char const   *)(dirname));
#line 824
    tmp___3 = rename((char const   *)(tmpname), (char const   *)(newname));
    }
#line 824
    if (tmp___3) {
#line 825
      return (1);
    }
  }
  {
#line 828
  tmp___4 = gettext("configuration written to %s");
#line 828
  conf_message((char const   *)tmp___4, newname);
#line 830
  sym_set_change_count(0);
  }
#line 832
  return (0);
}
}
#line 835 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/confdata.c"
static int conf_split_config(void) 
{ 
  char const   *name ;
  char path[4097] ;
  char *s ;
  char *d ;
  char c ;
  struct symbol *sym ;
  struct stat sb ;
  int res ;
  int i ;
  int fd ;
  int tmp ;
  tristate tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  tristate tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;

  {
  {
#line 844
  name = conf_get_autoconfig_name();
#line 845
  conf_read_simple(name, 1);
#line 847
  tmp = chdir("include/config");
  }
#line 847
  if (tmp) {
#line 848
    return (1);
  }
#line 850
  res = 0;
#line 851
  i = 0;
  {
#line 851
  while (1) {
    while_continue: /* CIL Label */ ;
#line 851
    if (! (i < 9973)) {
#line 851
      goto while_break;
    }
#line 851
    sym = symbol_hash[i];
    {
#line 851
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 851
      if (! sym) {
#line 851
        goto while_break___0;
      }
#line 851
      if ((unsigned int )sym->type != 6U) {
        {
#line 852
        sym_calc_value(sym);
        }
#line 853
        if (sym->flags & 4096) {
#line 854
          goto __Cont;
        } else
#line 853
        if (! sym->name) {
#line 854
          goto __Cont;
        }
#line 855
        if (sym->flags & 512) {
#line 856
          if (sym->flags & 131072) {
            {
#line 863
            if ((unsigned int )sym->type == 2U) {
#line 863
              goto case_2;
            }
#line 863
            if ((unsigned int )sym->type == 1U) {
#line 863
              goto case_2;
            }
#line 870
            if ((unsigned int )sym->type == 3U) {
#line 870
              goto case_3;
            }
#line 870
            if ((unsigned int )sym->type == 4U) {
#line 870
              goto case_3;
            }
#line 870
            if ((unsigned int )sym->type == 5U) {
#line 870
              goto case_3;
            }
#line 875
            goto switch_default;
            case_2: /* CIL Label */ 
            case_1: /* CIL Label */ 
            {
#line 864
            tmp___0 = sym_get_tristate_value(sym);
            }
#line 864
            if ((unsigned int )tmp___0 == (unsigned int )sym->def[1].tri) {
#line 866
              goto __Cont;
            }
#line 867
            goto switch_break;
            case_3: /* CIL Label */ 
            case_4: /* CIL Label */ 
            case_5: /* CIL Label */ 
            {
#line 871
            tmp___1 = sym_get_string_value(sym);
#line 871
            tmp___2 = strcmp(tmp___1, (char const   *)sym->def[1].val);
            }
#line 871
            if (! tmp___2) {
#line 873
              goto __Cont;
            }
#line 874
            goto switch_break;
            switch_default: /* CIL Label */ 
#line 876
            goto switch_break;
            switch_break: /* CIL Label */ ;
            }
          } else {
            {
#line 885
            if ((unsigned int )sym->type == 2U) {
#line 885
              goto case_2___0;
            }
#line 885
            if ((unsigned int )sym->type == 1U) {
#line 885
              goto case_2___0;
            }
#line 889
            goto switch_default___0;
            case_2___0: /* CIL Label */ 
            case_1___0: /* CIL Label */ 
            {
#line 886
            tmp___3 = sym_get_tristate_value(sym);
            }
#line 886
            if ((unsigned int )tmp___3 == 0U) {
#line 887
              goto __Cont;
            }
#line 888
            goto switch_break___0;
            switch_default___0: /* CIL Label */ 
#line 890
            goto switch_break___0;
            switch_break___0: /* CIL Label */ ;
            }
          }
        } else
#line 893
        if (! (sym->flags & 131072)) {
#line 895
          goto __Cont;
        }
#line 903
        s = sym->name;
#line 904
        d = path;
        {
#line 905
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 905
          tmp___6 = s;
#line 905
          s ++;
#line 905
          c = *tmp___6;
#line 905
          if (! c) {
#line 905
            goto while_break___1;
          }
          {
#line 906
          tmp___4 = tolower((int )c);
#line 906
          c = (char )tmp___4;
#line 907
          tmp___5 = d;
#line 907
          d ++;
          }
#line 907
          if ((int )c == 95) {
#line 907
            *tmp___5 = (char )'/';
          } else {
#line 907
            *tmp___5 = c;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 909
        strcpy((char */* __restrict  */)d, (char const   */* __restrict  */)".h");
#line 912
        fd = open((char const   *)(path), 577, 420);
        }
#line 913
        if (fd == -1) {
          {
#line 914
          tmp___7 = __errno_location();
          }
#line 914
          if (*tmp___7 != 2) {
#line 915
            res = 1;
#line 916
            goto while_break___0;
          }
#line 922
          d = path;
          {
#line 923
          while (1) {
            while_continue___2: /* CIL Label */ ;
            {
#line 923
            d = strchr((char const   *)d, '/');
            }
#line 923
            if (! d) {
#line 923
              goto while_break___2;
            }
            {
#line 924
            *d = (char)0;
#line 925
            tmp___8 = stat((char const   */* __restrict  */)(path), (struct stat */* __restrict  */)(& sb));
            }
#line 925
            if (tmp___8) {
              {
#line 925
              tmp___9 = mkdir((char const   *)(path), (__mode_t )493);
              }
#line 925
              if (tmp___9) {
#line 926
                res = 1;
#line 927
                goto out;
              }
            }
#line 929
            tmp___10 = d;
#line 929
            d ++;
#line 929
            *tmp___10 = (char )'/';
          }
          while_break___2: /* CIL Label */ ;
          }
          {
#line 932
          fd = open((char const   *)(path), 577, 420);
          }
#line 933
          if (fd == -1) {
#line 934
            res = 1;
#line 935
            goto while_break___0;
          }
        }
        {
#line 938
        close(fd);
        }
      }
      __Cont: /* CIL Label */ 
#line 851
      sym = sym->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 851
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  out: 
  {
#line 941
  tmp___11 = chdir("../..");
  }
#line 941
  if (tmp___11) {
#line 942
    return (1);
  }
#line 944
  return (res);
}
}
#line 947 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/confdata.c"
int conf_write_autoconf(void) 
{ 
  struct symbol *sym ;
  char const   *name ;
  FILE *out ;
  FILE *tristate___0 ;
  FILE *out_h ;
  int i ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 954
  sym_clear_all_valid();
#line 956
  file_write_dep("include/config/auto.conf.cmd");
#line 958
  tmp = conf_split_config();
  }
#line 958
  if (tmp) {
#line 959
    return (1);
  }
  {
#line 961
  out = fopen((char const   */* __restrict  */)".tmpconfig", (char const   */* __restrict  */)"w");
  }
#line 962
  if (! out) {
#line 963
    return (1);
  }
  {
#line 965
  tristate___0 = fopen((char const   */* __restrict  */)".tmpconfig_tristate", (char const   */* __restrict  */)"w");
  }
#line 966
  if (! tristate___0) {
    {
#line 967
    fclose(out);
    }
#line 968
    return (1);
  }
  {
#line 971
  out_h = fopen((char const   */* __restrict  */)".tmpconfig.h", (char const   */* __restrict  */)"w");
  }
#line 972
  if (! out_h) {
    {
#line 973
    fclose(out);
#line 974
    fclose(tristate___0);
    }
#line 975
    return (1);
  }
  {
#line 978
  conf_write_heading(out, & kconfig_printer_cb, (void *)0);
#line 980
  conf_write_heading(tristate___0, & tristate_printer_cb, (void *)0);
#line 982
  conf_write_heading(out_h, & header_printer_cb, (void *)0);
#line 984
  i = 0;
  }
  {
#line 984
  while (1) {
    while_continue: /* CIL Label */ ;
#line 984
    if (! (i < 9973)) {
#line 984
      goto while_break;
    }
#line 984
    sym = symbol_hash[i];
    {
#line 984
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 984
      if (! sym) {
#line 984
        goto while_break___0;
      }
#line 984
      if ((unsigned int )sym->type != 6U) {
        {
#line 985
        sym_calc_value(sym);
        }
#line 986
        if (! (sym->flags & 512)) {
#line 987
          goto __Cont;
        } else
#line 986
        if (! sym->name) {
#line 987
          goto __Cont;
        }
        {
#line 990
        conf_write_symbol(out, sym, & kconfig_printer_cb, (void *)1);
#line 992
        conf_write_symbol(tristate___0, sym, & tristate_printer_cb, (void *)1);
#line 994
        conf_write_symbol(out_h, sym, & header_printer_cb, (void *)0);
        }
      }
      __Cont: /* CIL Label */ 
#line 984
      sym = sym->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 984
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 996
  fclose(out);
#line 997
  fclose(tristate___0);
#line 998
  fclose(out_h);
#line 1000
  tmp___0 = getenv("KCONFIG_AUTOHEADER");
#line 1000
  name = (char const   *)tmp___0;
  }
#line 1001
  if (! name) {
#line 1002
    name = "include/generated/autoconf.h";
  }
  {
#line 1003
  tmp___1 = rename(".tmpconfig.h", name);
  }
#line 1003
  if (tmp___1) {
#line 1004
    return (1);
  }
  {
#line 1005
  tmp___2 = getenv("KCONFIG_TRISTATE");
#line 1005
  name = (char const   *)tmp___2;
  }
#line 1006
  if (! name) {
#line 1007
    name = "include/config/tristate.conf";
  }
  {
#line 1008
  tmp___3 = rename(".tmpconfig_tristate", name);
  }
#line 1008
  if (tmp___3) {
#line 1009
    return (1);
  }
  {
#line 1010
  name = conf_get_autoconfig_name();
#line 1015
  tmp___4 = rename(".tmpconfig", name);
  }
#line 1015
  if (tmp___4) {
#line 1016
    return (1);
  }
#line 1018
  return (0);
}
}
#line 1021 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/confdata.c"
static int sym_change_count  ;
#line 1022 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/confdata.c"
static void (*conf_changed_callback)(void)  ;
#line 1024 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/confdata.c"
void sym_set_change_count(int count ) 
{ 
  int _sym_change_count ;

  {
#line 1026
  _sym_change_count = sym_change_count;
#line 1027
  sym_change_count = count;
#line 1028
  if (conf_changed_callback) {
#line 1028
    if ((int )((_Bool )_sym_change_count) != (int )((_Bool )count)) {
      {
#line 1030
      (*conf_changed_callback)();
      }
    }
  }
#line 1031
  return;
}
}
#line 1033 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/confdata.c"
void sym_add_change_count(int count ) 
{ 


  {
  {
#line 1035
  sym_set_change_count(count + sym_change_count);
  }
#line 1036
  return;
}
}
#line 1038 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/confdata.c"
_Bool conf_get_changed(void) 
{ 


  {
#line 1040
  return ((_Bool )sym_change_count);
}
}
#line 1043 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/confdata.c"
void conf_set_changed_callback(void (*fn)(void) ) 
{ 


  {
#line 1045
  conf_changed_callback = fn;
#line 1046
  return;
}
}
#line 1048 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/confdata.c"
static _Bool randomize_choice_values(struct symbol *csym ) 
{ 
  struct property *prop ;
  struct symbol *sym ;
  struct expr *e ;
  int cnt ;
  int def ;
  int tmp ;
  int tmp___0 ;

  {
#line 1060
  if ((unsigned int )csym->curr.tri != 2U) {
#line 1061
    return ((_Bool)0);
  }
  {
#line 1063
  prop = sym_get_choice_prop(csym);
#line 1066
  cnt = 0;
#line 1067
  e = prop->expr;
  }
  {
#line 1067
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1067
    if (e) {
#line 1067
      sym = e->right.sym;
#line 1067
      if (! sym) {
#line 1067
        goto while_break;
      }
    } else {
#line 1067
      goto while_break;
    }
#line 1068
    cnt ++;
#line 1067
    e = e->left.expr;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1074
  tmp = rand();
#line 1074
  def = tmp % cnt;
#line 1076
  cnt = 0;
#line 1077
  e = prop->expr;
  }
  {
#line 1077
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1077
    if (e) {
#line 1077
      sym = e->right.sym;
#line 1077
      if (! sym) {
#line 1077
        goto while_break___0;
      }
    } else {
#line 1077
      goto while_break___0;
    }
#line 1078
    tmp___0 = cnt;
#line 1078
    cnt ++;
#line 1078
    if (def == tmp___0) {
#line 1079
      sym->def[0].tri = (tristate )2;
#line 1080
      csym->def[0].val = (void *)sym;
    } else {
#line 1083
      sym->def[0].tri = (tristate )0;
    }
#line 1085
    sym->flags |= 65536;
#line 1087
    sym->flags &= -129;
#line 1077
    e = e->left.expr;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1089
  csym->flags |= 65536;
#line 1091
  csym->flags &= -129;
#line 1093
  return ((_Bool)1);
}
}
#line 1096 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/confdata.c"
void set_all_choice_values(struct symbol *csym ) 
{ 
  struct property *prop ;
  struct symbol *sym ;
  struct expr *e ;
  _Bool tmp ;

  {
  {
#line 1102
  prop = sym_get_choice_prop(csym);
#line 1107
  e = prop->expr;
  }
  {
#line 1107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1107
    if (e) {
#line 1107
      sym = e->right.sym;
#line 1107
      if (! sym) {
#line 1107
        goto while_break;
      }
    } else {
#line 1107
      goto while_break;
    }
    {
#line 1108
    tmp = sym_has_value(sym);
    }
#line 1108
    if (! tmp) {
#line 1109
      sym->def[0].tri = (tristate )0;
    }
#line 1107
    e = e->left.expr;
  }
  while_break: /* CIL Label */ ;
  }
#line 1111
  csym->flags |= 65536;
#line 1113
  csym->flags &= -1048705;
#line 1114
  return;
}
}
#line 1116 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/confdata.c"
_Bool conf_set_all_new_symbols(enum conf_def_mode mode ) 
{ 
  struct symbol *sym ;
  struct symbol *csym ;
  int i ;
  int cnt ;
  int pby ;
  int pty ;
  int ptm ;
  int n ;
  int p[3] ;
  char *env ;
  char *tmp ;
  char *endp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  _Bool has_changed ;
  _Bool tmp___5 ;
  enum symbol_type tmp___6 ;
  int tmp___7 ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;
  _Bool tmp___10 ;
  _Bool tmp___11 ;
  _Bool tmp___12 ;
  _Bool tmp___13 ;

  {
#line 1124
  pby = 50;
#line 1124
  ptm = 33;
#line 1124
  pty = ptm;
#line 1127
  if ((unsigned int )mode == 4U) {
    {
#line 1129
    tmp = getenv("KCONFIG_PROBABILITY");
#line 1129
    env = tmp;
#line 1130
    n = 0;
    }
    {
#line 1131
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1131
      if (env) {
#line 1131
        if (! *env) {
#line 1131
          goto while_break;
        }
      } else {
#line 1131
        goto while_break;
      }
      {
#line 1133
      tmp___1 = strtol((char const   */* __restrict  */)env, (char **/* __restrict  */)(& endp),
                       10);
#line 1133
      tmp___0 = (int )tmp___1;
      }
#line 1134
      if (tmp___0 >= 0) {
#line 1134
        if (tmp___0 <= 100) {
#line 1135
          tmp___2 = n;
#line 1135
          n ++;
#line 1135
          p[tmp___2] = tmp___0;
        } else {
          {
#line 1137
          tmp___3 = __errno_location();
#line 1137
          *tmp___3 = 34;
#line 1138
          perror("KCONFIG_PROBABILITY");
#line 1139
          exit(1);
          }
        }
      } else {
        {
#line 1137
        tmp___3 = __errno_location();
#line 1137
        *tmp___3 = 34;
#line 1138
        perror("KCONFIG_PROBABILITY");
#line 1139
        exit(1);
        }
      }
#line 1141
      if ((int )*endp == 58) {
#line 1141
        env = endp + 1;
      } else {
#line 1141
        env = endp;
      }
#line 1142
      if (n >= 3) {
#line 1143
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1147
    if (n == 1) {
#line 1147
      goto case_1;
    }
#line 1150
    if (n == 2) {
#line 1150
      goto case_2;
    }
#line 1153
    if (n == 3) {
#line 1153
      goto case_3;
    }
#line 1146
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1148
    pby = p[0];
#line 1148
    ptm = pby / 2;
#line 1148
    pty = pby - ptm;
#line 1149
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1151
    pty = p[0];
#line 1151
    ptm = p[1];
#line 1151
    pby = pty + ptm;
#line 1152
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1154
    pby = p[0];
#line 1154
    pty = p[1];
#line 1154
    ptm = p[2];
#line 1155
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1158
    if (pty + ptm > 100) {
      {
#line 1159
      tmp___4 = __errno_location();
#line 1159
      *tmp___4 = 34;
#line 1160
      perror("KCONFIG_PROBABILITY");
#line 1161
      exit(1);
      }
    }
  }
#line 1164
  has_changed = (_Bool)0;
#line 1166
  i = 0;
  {
#line 1166
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1166
    if (! (i < 9973)) {
#line 1166
      goto while_break___0;
    }
#line 1166
    sym = symbol_hash[i];
    {
#line 1166
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1166
      if (! sym) {
#line 1166
        goto while_break___1;
      }
#line 1166
      if ((unsigned int )sym->type != 6U) {
        {
#line 1167
        tmp___5 = sym_has_value(sym);
        }
#line 1167
        if (tmp___5) {
#line 1168
          goto __Cont;
        } else
#line 1167
        if (sym->flags & 128) {
#line 1168
          goto __Cont;
        }
        {
#line 1169
        tmp___6 = sym_get_type(sym);
        }
        {
#line 1171
        if ((unsigned int )tmp___6 == 2U) {
#line 1171
          goto case_2___0;
        }
#line 1171
        if ((unsigned int )tmp___6 == 1U) {
#line 1171
          goto case_2___0;
        }
#line 1203
        goto switch_default___0;
        case_2___0: /* CIL Label */ 
        case_1___0: /* CIL Label */ 
#line 1172
        has_changed = (_Bool)1;
        {
#line 1174
        if ((unsigned int )mode == 1U) {
#line 1174
          goto case_1___1;
        }
#line 1177
        if ((unsigned int )mode == 2U) {
#line 1177
          goto case_2___1;
        }
#line 1180
        if ((unsigned int )mode == 3U) {
#line 1180
          goto case_3___0;
        }
#line 1186
        if ((unsigned int )mode == 4U) {
#line 1186
          goto case_4;
        }
#line 1197
        goto switch_default;
        case_1___1: /* CIL Label */ 
#line 1175
        sym->def[0].tri = (tristate )2;
#line 1176
        goto switch_break___1;
        case_2___1: /* CIL Label */ 
#line 1178
        sym->def[0].tri = (tristate )1;
#line 1179
        goto switch_break___1;
        case_3___0: /* CIL Label */ 
#line 1181
        if (sym->flags & 2097152) {
#line 1182
          sym->def[0].tri = (tristate )2;
        } else {
#line 1184
          sym->def[0].tri = (tristate )0;
        }
#line 1185
        goto switch_break___1;
        case_4: /* CIL Label */ 
        {
#line 1187
        sym->def[0].tri = (tristate )0;
#line 1188
        tmp___7 = rand();
#line 1188
        cnt = tmp___7 % 100;
        }
#line 1189
        if ((unsigned int )sym->type == 2U) {
#line 1190
          if (cnt < pty) {
#line 1191
            sym->def[0].tri = (tristate )2;
          } else
#line 1192
          if (cnt < pty + ptm) {
#line 1193
            sym->def[0].tri = (tristate )1;
          }
        } else
#line 1194
        if (cnt < pby) {
#line 1195
          sym->def[0].tri = (tristate )2;
        }
#line 1196
        goto switch_break___1;
        switch_default: /* CIL Label */ 
#line 1198
        goto __Cont;
        switch_break___1: /* CIL Label */ ;
        }
        {
#line 1200
        tmp___8 = sym_is_choice(sym);
        }
#line 1200
        if (tmp___8) {
#line 1200
          if (! ((unsigned int )mode == 4U)) {
#line 1201
            sym->flags |= 65536;
          }
        } else {
#line 1201
          sym->flags |= 65536;
        }
#line 1202
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
#line 1204
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
      }
      __Cont: /* CIL Label */ 
#line 1166
      sym = sym->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1166
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1209
  sym_clear_all_valid();
  }
#line 1220
  if ((unsigned int )mode != 4U) {
#line 1221
    i = 0;
    {
#line 1221
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1221
      if (! (i < 9973)) {
#line 1221
        goto while_break___2;
      }
#line 1221
      csym = symbol_hash[i];
      {
#line 1221
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1221
        if (! csym) {
#line 1221
          goto while_break___3;
        }
#line 1221
        if ((unsigned int )csym->type != 6U) {
          {
#line 1222
          tmp___9 = sym_is_choice(csym);
          }
#line 1222
          if (tmp___9) {
            {
#line 1222
            tmp___10 = sym_has_value(csym);
            }
#line 1222
            if (tmp___10) {
#line 1222
              goto _L;
            } else {
#line 1224
              csym->flags |= 1048576;
            }
          } else {
            _L: /* CIL Label */ 
            {
#line 1222
            tmp___11 = sym_is_choice_value(csym);
            }
#line 1222
            if (tmp___11) {
#line 1224
              csym->flags |= 1048576;
            }
          }
        }
#line 1221
        csym = csym->next;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1221
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 1228
  i = 0;
  {
#line 1228
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1228
    if (! (i < 9973)) {
#line 1228
      goto while_break___4;
    }
#line 1228
    csym = symbol_hash[i];
    {
#line 1228
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1228
      if (! csym) {
#line 1228
        goto while_break___5;
      }
#line 1228
      if ((unsigned int )csym->type != 6U) {
        {
#line 1229
        tmp___12 = sym_has_value(csym);
        }
#line 1229
        if (tmp___12) {
#line 1230
          goto __Cont___0;
        } else {
          {
#line 1229
          tmp___13 = sym_is_choice(csym);
          }
#line 1229
          if (! tmp___13) {
#line 1230
            goto __Cont___0;
          }
        }
        {
#line 1232
        sym_calc_value(csym);
        }
#line 1233
        if ((unsigned int )mode == 4U) {
          {
#line 1234
          has_changed = randomize_choice_values(csym);
          }
        } else {
          {
#line 1236
          set_all_choice_values(csym);
#line 1237
          has_changed = (_Bool)1;
          }
        }
      }
      __Cont___0: /* CIL Label */ 
#line 1228
      csym = csym->next;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1228
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1241
  return (has_changed);
}
}
#line 14 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.c"
struct expr *expr_alloc_symbol(struct symbol *sym ) 
{ 
  struct expr *e ;
  void *tmp ;

  {
  {
#line 16
  tmp = xcalloc((size_t )1, sizeof(*e));
#line 16
  e = (struct expr *)tmp;
#line 17
  e->type = (enum expr_type )7;
#line 18
  e->left.sym = sym;
  }
#line 19
  return (e);
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.c"
struct expr *expr_alloc_one(enum expr_type type , struct expr *ce ) 
{ 
  struct expr *e ;
  void *tmp ;

  {
  {
#line 24
  tmp = xcalloc((size_t )1, sizeof(*e));
#line 24
  e = (struct expr *)tmp;
#line 25
  e->type = type;
#line 26
  e->left.expr = ce;
  }
#line 27
  return (e);
}
}
#line 30 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.c"
struct expr *expr_alloc_two(enum expr_type type , struct expr *e1 , struct expr *e2 ) 
{ 
  struct expr *e ;
  void *tmp ;

  {
  {
#line 32
  tmp = xcalloc((size_t )1, sizeof(*e));
#line 32
  e = (struct expr *)tmp;
#line 33
  e->type = type;
#line 34
  e->left.expr = e1;
#line 35
  e->right.expr = e2;
  }
#line 36
  return (e);
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.c"
struct expr *expr_alloc_comp(enum expr_type type , struct symbol *s1 , struct symbol *s2 ) 
{ 
  struct expr *e ;
  void *tmp ;

  {
  {
#line 41
  tmp = xcalloc((size_t )1, sizeof(*e));
#line 41
  e = (struct expr *)tmp;
#line 42
  e->type = type;
#line 43
  e->left.sym = s1;
#line 44
  e->right.sym = s2;
  }
#line 45
  return (e);
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.c"
struct expr *expr_alloc_and(struct expr *e1 , struct expr *e2 ) 
{ 
  struct expr *tmp ;
  struct expr *tmp___0 ;

  {
#line 50
  if (! e1) {
#line 51
    return (e2);
  }
#line 52
  if (e2) {
    {
#line 52
    tmp = expr_alloc_two((enum expr_type )2, e1, e2);
#line 52
    tmp___0 = tmp;
    }
  } else {
#line 52
    tmp___0 = e1;
  }
#line 52
  return (tmp___0);
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.c"
struct expr *expr_alloc_or(struct expr *e1 , struct expr *e2 ) 
{ 
  struct expr *tmp ;
  struct expr *tmp___0 ;

  {
#line 57
  if (! e1) {
#line 58
    return (e2);
  }
#line 59
  if (e2) {
    {
#line 59
    tmp = expr_alloc_two((enum expr_type )1, e1, e2);
#line 59
    tmp___0 = tmp;
    }
  } else {
#line 59
    tmp___0 = e1;
  }
#line 59
  return (tmp___0);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.c"
struct expr *expr_copy(struct expr  const  *org ) 
{ 
  struct expr *e ;
  void *tmp ;

  {
#line 66
  if (! org) {
#line 67
    return ((struct expr *)((void *)0));
  }
  {
#line 69
  tmp = xmalloc(sizeof(*org));
#line 69
  e = (struct expr *)tmp;
#line 70
  memcpy((void */* __restrict  */)e, (void const   */* __restrict  */)org, sizeof(*org));
  }
  {
#line 72
  if ((unsigned int const   )org->type == 7U) {
#line 72
    goto case_7;
  }
#line 75
  if ((unsigned int const   )org->type == 3U) {
#line 75
    goto case_3;
  }
#line 79
  if ((unsigned int const   )org->type == 5U) {
#line 79
    goto case_5;
  }
#line 79
  if ((unsigned int const   )org->type == 4U) {
#line 79
    goto case_5;
  }
#line 85
  if ((unsigned int const   )org->type == 6U) {
#line 85
    goto case_6;
  }
#line 85
  if ((unsigned int const   )org->type == 1U) {
#line 85
    goto case_6;
  }
#line 85
  if ((unsigned int const   )org->type == 2U) {
#line 85
    goto case_6;
  }
#line 89
  goto switch_default;
  case_7: /* CIL Label */ 
#line 73
  e->left = (union expr_data )org->left;
#line 74
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 76
  e->left.expr = expr_copy((struct expr  const  *)org->left.expr);
  }
#line 77
  goto switch_break;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 80
  e->left.sym = (struct symbol *)org->left.sym;
#line 81
  e->right.sym = (struct symbol *)org->right.sym;
#line 82
  goto switch_break;
  case_6: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 86
  e->left.expr = expr_copy((struct expr  const  *)org->left.expr);
#line 87
  e->right.expr = expr_copy((struct expr  const  *)org->right.expr);
  }
#line 88
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 90
  printf((char const   */* __restrict  */)"can\'t copy type %d\n", (unsigned int )e->type);
#line 91
  free((void *)e);
#line 92
  e = (struct expr *)((void *)0);
  }
#line 93
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 96
  return (e);
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.c"
void expr_free(struct expr *e ) 
{ 


  {
#line 101
  if (! e) {
#line 102
    return;
  }
  {
#line 105
  if ((unsigned int )e->type == 7U) {
#line 105
    goto case_7;
  }
#line 107
  if ((unsigned int )e->type == 3U) {
#line 107
    goto case_3;
  }
#line 111
  if ((unsigned int )e->type == 5U) {
#line 111
    goto case_5;
  }
#line 111
  if ((unsigned int )e->type == 4U) {
#line 111
    goto case_5;
  }
#line 114
  if ((unsigned int )e->type == 2U) {
#line 114
    goto case_2;
  }
#line 114
  if ((unsigned int )e->type == 1U) {
#line 114
    goto case_2;
  }
#line 118
  goto switch_default;
  case_7: /* CIL Label */ 
#line 106
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 108
  expr_free(e->left.expr);
  }
#line 109
  return;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 112
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 115
  expr_free(e->left.expr);
#line 116
  expr_free(e->right.expr);
  }
#line 117
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 119
  printf((char const   */* __restrict  */)"how to free type %d?\n", (unsigned int )e->type);
  }
#line 120
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 122
  free((void *)e);
  }
#line 123
  return;
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.c"
static int trans_count  ;
#line 130 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.c"
static void __expr_eliminate_eq(enum expr_type type , struct expr **ep1 , struct expr **ep2 ) 
{ 
  int tmp ;

  {
#line 132
  if ((unsigned int )(*ep1)->type == (unsigned int )type) {
    {
#line 133
    __expr_eliminate_eq(type, & (*ep1)->left.expr, ep2);
#line 134
    __expr_eliminate_eq(type, & (*ep1)->right.expr, ep2);
    }
#line 135
    return;
  }
#line 137
  if ((unsigned int )(*ep2)->type == (unsigned int )type) {
    {
#line 138
    __expr_eliminate_eq(type, ep1, & (*ep2)->left.expr);
#line 139
    __expr_eliminate_eq(type, ep1, & (*ep2)->right.expr);
    }
#line 140
    return;
  }
#line 142
  if ((unsigned int )(*ep1)->type == 7U) {
#line 142
    if ((unsigned int )(*ep2)->type == 7U) {
#line 142
      if ((unsigned long )(*ep1)->left.sym == (unsigned long )(*ep2)->left.sym) {
#line 142
        if ((unsigned long )(*ep1)->left.sym == (unsigned long )(& symbol_yes)) {
#line 145
          return;
        } else
#line 142
        if ((unsigned long )(*ep1)->left.sym == (unsigned long )(& symbol_no)) {
#line 145
          return;
        }
      }
    }
  }
  {
#line 146
  tmp = expr_eq(*ep1, *ep2);
  }
#line 146
  if (! tmp) {
#line 147
    return;
  }
  {
#line 148
  trans_count ++;
#line 149
  expr_free(*ep1);
#line 149
  expr_free(*ep2);
  }
  {
#line 151
  if ((unsigned int )type == 1U) {
#line 151
    goto case_1;
  }
#line 155
  if ((unsigned int )type == 2U) {
#line 155
    goto case_2;
  }
#line 159
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 152
  *ep1 = expr_alloc_symbol(& symbol_no);
#line 153
  *ep2 = expr_alloc_symbol(& symbol_no);
  }
#line 154
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 156
  *ep1 = expr_alloc_symbol(& symbol_yes);
#line 157
  *ep2 = expr_alloc_symbol(& symbol_yes);
  }
#line 158
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 162
  return;
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.c"
void expr_eliminate_eq(struct expr **ep1 , struct expr **ep2 ) 
{ 


  {
#line 166
  if (! *ep1) {
#line 167
    return;
  } else
#line 166
  if (! *ep2) {
#line 167
    return;
  }
  {
#line 170
  if ((unsigned int )(*ep1)->type == 2U) {
#line 170
    goto case_2;
  }
#line 170
  if ((unsigned int )(*ep1)->type == 1U) {
#line 170
    goto case_2;
  }
#line 172
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 171
  __expr_eliminate_eq((*ep1)->type, ep1, ep2);
  }
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 175
  if ((unsigned int )(*ep1)->type != (unsigned int )(*ep2)->type) {
    {
#line 177
    if ((unsigned int )(*ep2)->type == 2U) {
#line 177
      goto case_2___0;
    }
#line 177
    if ((unsigned int )(*ep2)->type == 1U) {
#line 177
      goto case_2___0;
    }
#line 179
    goto switch_default___0;
    case_2___0: /* CIL Label */ 
    case_1___0: /* CIL Label */ 
    {
#line 178
    __expr_eliminate_eq((*ep2)->type, ep1, ep2);
    }
    switch_default___0: /* CIL Label */ ;
    switch_break___0: /* CIL Label */ ;
    }
  }
  {
#line 182
  *ep1 = expr_eliminate_yn(*ep1);
#line 183
  *ep2 = expr_eliminate_yn(*ep2);
  }
#line 184
  return;
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.c"
int expr_eq(struct expr *e1 , struct expr *e2 ) 
{ 
  int res ;
  int old_count ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 193
  if ((unsigned int )e1->type != (unsigned int )e2->type) {
#line 194
    return (0);
  }
  {
#line 197
  if ((unsigned int )e1->type == 5U) {
#line 197
    goto case_5;
  }
#line 197
  if ((unsigned int )e1->type == 4U) {
#line 197
    goto case_5;
  }
#line 199
  if ((unsigned int )e1->type == 7U) {
#line 199
    goto case_7;
  }
#line 201
  if ((unsigned int )e1->type == 3U) {
#line 201
    goto case_3;
  }
#line 204
  if ((unsigned int )e1->type == 1U) {
#line 204
    goto case_1;
  }
#line 204
  if ((unsigned int )e1->type == 2U) {
#line 204
    goto case_1;
  }
#line 217
  if ((unsigned int )e1->type == 0U) {
#line 217
    goto case_0;
  }
#line 217
  if ((unsigned int )e1->type == 8U) {
#line 217
    goto case_0;
  }
#line 217
  if ((unsigned int )e1->type == 6U) {
#line 217
    goto case_0;
  }
#line 195
  goto switch_break;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 198
  if ((unsigned long )e1->left.sym == (unsigned long )e2->left.sym) {
#line 198
    if ((unsigned long )e1->right.sym == (unsigned long )e2->right.sym) {
#line 198
      tmp = 1;
    } else {
#line 198
      tmp = 0;
    }
  } else {
#line 198
    tmp = 0;
  }
#line 198
  return (tmp);
  case_7: /* CIL Label */ 
#line 200
  return ((unsigned long )e1->left.sym == (unsigned long )e2->left.sym);
  case_3: /* CIL Label */ 
  {
#line 202
  tmp___0 = expr_eq(e1->left.expr, e2->left.expr);
  }
#line 202
  return (tmp___0);
  case_1: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 205
  e1 = expr_copy((struct expr  const  *)e1);
#line 206
  e2 = expr_copy((struct expr  const  *)e2);
#line 207
  old_count = trans_count;
#line 208
  expr_eliminate_eq(& e1, & e2);
  }
#line 209
  if ((unsigned int )e1->type == 7U) {
#line 209
    if ((unsigned int )e2->type == 7U) {
#line 209
      if ((unsigned long )e1->left.sym == (unsigned long )e2->left.sym) {
#line 209
        tmp___1 = 1;
      } else {
#line 209
        tmp___1 = 0;
      }
    } else {
#line 209
      tmp___1 = 0;
    }
  } else {
#line 209
    tmp___1 = 0;
  }
  {
#line 209
  res = tmp___1;
#line 211
  expr_free(e1);
#line 212
  expr_free(e2);
#line 213
  trans_count = old_count;
  }
#line 214
  return (res);
  case_0: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_6: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 228
  return (0);
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.c"
struct expr *expr_eliminate_yn(struct expr *e ) 
{ 
  struct expr *tmp ;

  {
#line 235
  if (e) {
    {
#line 236
    if ((unsigned int )e->type == 2U) {
#line 236
      goto case_2;
    }
#line 272
    if ((unsigned int )e->type == 1U) {
#line 272
      goto case_1;
    }
#line 308
    goto switch_default;
    case_2: /* CIL Label */ 
    {
#line 237
    e->left.expr = expr_eliminate_yn(e->left.expr);
#line 238
    e->right.expr = expr_eliminate_yn(e->right.expr);
    }
#line 239
    if ((unsigned int )(e->left.expr)->type == 7U) {
#line 240
      if ((unsigned long )(e->left.expr)->left.sym == (unsigned long )(& symbol_no)) {
        {
#line 241
        expr_free(e->left.expr);
#line 242
        expr_free(e->right.expr);
#line 243
        e->type = (enum expr_type )7;
#line 244
        e->left.sym = & symbol_no;
#line 245
        e->right.expr = (struct expr *)((void *)0);
        }
#line 246
        return (e);
      } else
#line 247
      if ((unsigned long )(e->left.expr)->left.sym == (unsigned long )(& symbol_yes)) {
        {
#line 248
        free((void *)e->left.expr);
#line 249
        tmp = e->right.expr;
#line 250
        *e = *(e->right.expr);
#line 251
        free((void *)tmp);
        }
#line 252
        return (e);
      }
    }
#line 255
    if ((unsigned int )(e->right.expr)->type == 7U) {
#line 256
      if ((unsigned long )(e->right.expr)->left.sym == (unsigned long )(& symbol_no)) {
        {
#line 257
        expr_free(e->left.expr);
#line 258
        expr_free(e->right.expr);
#line 259
        e->type = (enum expr_type )7;
#line 260
        e->left.sym = & symbol_no;
#line 261
        e->right.expr = (struct expr *)((void *)0);
        }
#line 262
        return (e);
      } else
#line 263
      if ((unsigned long )(e->right.expr)->left.sym == (unsigned long )(& symbol_yes)) {
        {
#line 264
        free((void *)e->right.expr);
#line 265
        tmp = e->left.expr;
#line 266
        *e = *(e->left.expr);
#line 267
        free((void *)tmp);
        }
#line 268
        return (e);
      }
    }
#line 271
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 273
    e->left.expr = expr_eliminate_yn(e->left.expr);
#line 274
    e->right.expr = expr_eliminate_yn(e->right.expr);
    }
#line 275
    if ((unsigned int )(e->left.expr)->type == 7U) {
#line 276
      if ((unsigned long )(e->left.expr)->left.sym == (unsigned long )(& symbol_no)) {
        {
#line 277
        free((void *)e->left.expr);
#line 278
        tmp = e->right.expr;
#line 279
        *e = *(e->right.expr);
#line 280
        free((void *)tmp);
        }
#line 281
        return (e);
      } else
#line 282
      if ((unsigned long )(e->left.expr)->left.sym == (unsigned long )(& symbol_yes)) {
        {
#line 283
        expr_free(e->left.expr);
#line 284
        expr_free(e->right.expr);
#line 285
        e->type = (enum expr_type )7;
#line 286
        e->left.sym = & symbol_yes;
#line 287
        e->right.expr = (struct expr *)((void *)0);
        }
#line 288
        return (e);
      }
    }
#line 291
    if ((unsigned int )(e->right.expr)->type == 7U) {
#line 292
      if ((unsigned long )(e->right.expr)->left.sym == (unsigned long )(& symbol_no)) {
        {
#line 293
        free((void *)e->right.expr);
#line 294
        tmp = e->left.expr;
#line 295
        *e = *(e->left.expr);
#line 296
        free((void *)tmp);
        }
#line 297
        return (e);
      } else
#line 298
      if ((unsigned long )(e->right.expr)->left.sym == (unsigned long )(& symbol_yes)) {
        {
#line 299
        expr_free(e->left.expr);
#line 300
        expr_free(e->right.expr);
#line 301
        e->type = (enum expr_type )7;
#line 302
        e->left.sym = & symbol_yes;
#line 303
        e->right.expr = (struct expr *)((void *)0);
        }
#line 304
        return (e);
      }
    }
#line 307
    goto switch_break;
    switch_default: /* CIL Label */ ;
    switch_break: /* CIL Label */ ;
    }
  }
#line 311
  return (e);
}
}
#line 317 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.c"
struct expr *expr_trans_bool(struct expr *e ) 
{ 


  {
#line 319
  if (! e) {
#line 320
    return ((struct expr *)((void *)0));
  }
  {
#line 324
  if ((unsigned int )e->type == 3U) {
#line 324
    goto case_3;
  }
#line 324
  if ((unsigned int )e->type == 1U) {
#line 324
    goto case_3;
  }
#line 324
  if ((unsigned int )e->type == 2U) {
#line 324
    goto case_3;
  }
#line 328
  if ((unsigned int )e->type == 5U) {
#line 328
    goto case_5;
  }
#line 337
  goto switch_default;
  case_3: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 325
  e->left.expr = expr_trans_bool(e->left.expr);
#line 326
  e->right.expr = expr_trans_bool(e->right.expr);
  }
#line 327
  goto switch_break;
  case_5: /* CIL Label */ 
#line 330
  if ((unsigned int )(e->left.sym)->type == 2U) {
#line 331
    if ((unsigned long )e->right.sym == (unsigned long )(& symbol_no)) {
#line 332
      e->type = (enum expr_type )7;
#line 333
      e->right.sym = (struct symbol *)((void *)0);
    }
  }
#line 336
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 340
  return (e);
}
}
#line 346 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.c"
static struct expr *expr_join_or(struct expr *e1 , struct expr *e2 ) 
{ 
  struct expr *tmp ;
  struct symbol *sym1 ;
  struct symbol *sym2 ;
  struct expr *tmp___0 ;
  int tmp___1 ;
  struct expr *tmp___2 ;
  struct expr *tmp___3 ;
  struct expr *tmp___4 ;
  struct expr *tmp___5 ;

  {
  {
#line 351
  tmp___1 = expr_eq(e1, e2);
  }
#line 351
  if (tmp___1) {
    {
#line 352
    tmp___0 = expr_copy((struct expr  const  *)e1);
    }
#line 352
    return (tmp___0);
  }
#line 353
  if ((unsigned int )e1->type != 4U) {
#line 353
    if ((unsigned int )e1->type != 5U) {
#line 353
      if ((unsigned int )e1->type != 7U) {
#line 353
        if ((unsigned int )e1->type != 3U) {
#line 354
          return ((struct expr *)((void *)0));
        }
      }
    }
  }
#line 355
  if ((unsigned int )e2->type != 4U) {
#line 355
    if ((unsigned int )e2->type != 5U) {
#line 355
      if ((unsigned int )e2->type != 7U) {
#line 355
        if ((unsigned int )e2->type != 3U) {
#line 356
          return ((struct expr *)((void *)0));
        }
      }
    }
  }
#line 357
  if ((unsigned int )e1->type == 3U) {
#line 358
    tmp = e1->left.expr;
#line 359
    if ((unsigned int )tmp->type != 4U) {
#line 359
      if ((unsigned int )tmp->type != 5U) {
#line 359
        if ((unsigned int )tmp->type != 7U) {
#line 360
          return ((struct expr *)((void *)0));
        }
      }
    }
#line 361
    sym1 = tmp->left.sym;
  } else {
#line 363
    sym1 = e1->left.sym;
  }
#line 364
  if ((unsigned int )e2->type == 3U) {
#line 365
    if ((unsigned int )(e2->left.expr)->type != 7U) {
#line 366
      return ((struct expr *)((void *)0));
    }
#line 367
    sym2 = (e2->left.expr)->left.sym;
  } else {
#line 369
    sym2 = e2->left.sym;
  }
#line 370
  if ((unsigned long )sym1 != (unsigned long )sym2) {
#line 371
    return ((struct expr *)((void *)0));
  }
#line 372
  if ((unsigned int )sym1->type != 1U) {
#line 372
    if ((unsigned int )sym1->type != 2U) {
#line 373
      return ((struct expr *)((void *)0));
    }
  }
#line 374
  if ((unsigned int )sym1->type == 2U) {
#line 375
    if ((unsigned int )e1->type == 4U) {
#line 375
      if ((unsigned int )e2->type == 4U) {
#line 375
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_yes)) {
#line 375
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_mod)) {
            {
#line 379
            tmp___2 = expr_alloc_comp((enum expr_type )5, sym1, & symbol_no);
            }
#line 379
            return (tmp___2);
          } else {
#line 375
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 375
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_mod)) {
#line 375
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_yes)) {
            {
#line 379
            tmp___2 = expr_alloc_comp((enum expr_type )5, sym1, & symbol_no);
            }
#line 379
            return (tmp___2);
          }
        }
      }
    }
#line 381
    if ((unsigned int )e1->type == 4U) {
#line 381
      if ((unsigned int )e2->type == 4U) {
#line 381
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_yes)) {
#line 381
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_no)) {
            {
#line 385
            tmp___3 = expr_alloc_comp((enum expr_type )5, sym1, & symbol_mod);
            }
#line 385
            return (tmp___3);
          } else {
#line 381
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 381
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_no)) {
#line 381
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_yes)) {
            {
#line 385
            tmp___3 = expr_alloc_comp((enum expr_type )5, sym1, & symbol_mod);
            }
#line 385
            return (tmp___3);
          }
        }
      }
    }
#line 387
    if ((unsigned int )e1->type == 4U) {
#line 387
      if ((unsigned int )e2->type == 4U) {
#line 387
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_mod)) {
#line 387
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_no)) {
            {
#line 391
            tmp___4 = expr_alloc_comp((enum expr_type )5, sym1, & symbol_yes);
            }
#line 391
            return (tmp___4);
          } else {
#line 387
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 387
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_no)) {
#line 387
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_mod)) {
            {
#line 391
            tmp___4 = expr_alloc_comp((enum expr_type )5, sym1, & symbol_yes);
            }
#line 391
            return (tmp___4);
          }
        }
      }
    }
  }
#line 394
  if ((unsigned int )sym1->type == 1U) {
#line 394
    if ((unsigned long )sym1 == (unsigned long )sym2) {
#line 395
      if ((unsigned int )e1->type == 3U) {
#line 395
        if ((unsigned int )(e1->left.expr)->type == 7U) {
#line 395
          if ((unsigned int )e2->type == 7U) {
            {
#line 397
            tmp___5 = expr_alloc_symbol(& symbol_yes);
            }
#line 397
            return (tmp___5);
          } else {
#line 395
            goto _L___3;
          }
        } else {
#line 395
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 395
      if ((unsigned int )e2->type == 3U) {
#line 395
        if ((unsigned int )(e2->left.expr)->type == 7U) {
#line 395
          if ((unsigned int )e1->type == 7U) {
            {
#line 397
            tmp___5 = expr_alloc_symbol(& symbol_yes);
            }
#line 397
            return (tmp___5);
          }
        }
      }
    }
  }
#line 407
  return ((struct expr *)((void *)0));
}
}
#line 410 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.c"
static struct expr *expr_join_and(struct expr *e1 , struct expr *e2 ) 
{ 
  struct expr *tmp ;
  struct symbol *sym1 ;
  struct symbol *sym2 ;
  struct expr *tmp___0 ;
  int tmp___1 ;
  struct expr *tmp___2 ;
  struct expr *tmp___3 ;
  struct expr *tmp___4 ;
  struct expr *tmp___5 ;
  struct expr *tmp___6 ;
  struct expr *tmp___7 ;
  struct expr *tmp___8 ;
  struct expr *tmp___9 ;
  struct expr *tmp___10 ;
  struct expr *tmp___11 ;
  struct expr *tmp___12 ;
  struct expr *tmp___13 ;

  {
  {
#line 415
  tmp___1 = expr_eq(e1, e2);
  }
#line 415
  if (tmp___1) {
    {
#line 416
    tmp___0 = expr_copy((struct expr  const  *)e1);
    }
#line 416
    return (tmp___0);
  }
#line 417
  if ((unsigned int )e1->type != 4U) {
#line 417
    if ((unsigned int )e1->type != 5U) {
#line 417
      if ((unsigned int )e1->type != 7U) {
#line 417
        if ((unsigned int )e1->type != 3U) {
#line 418
          return ((struct expr *)((void *)0));
        }
      }
    }
  }
#line 419
  if ((unsigned int )e2->type != 4U) {
#line 419
    if ((unsigned int )e2->type != 5U) {
#line 419
      if ((unsigned int )e2->type != 7U) {
#line 419
        if ((unsigned int )e2->type != 3U) {
#line 420
          return ((struct expr *)((void *)0));
        }
      }
    }
  }
#line 421
  if ((unsigned int )e1->type == 3U) {
#line 422
    tmp = e1->left.expr;
#line 423
    if ((unsigned int )tmp->type != 4U) {
#line 423
      if ((unsigned int )tmp->type != 5U) {
#line 423
        if ((unsigned int )tmp->type != 7U) {
#line 424
          return ((struct expr *)((void *)0));
        }
      }
    }
#line 425
    sym1 = tmp->left.sym;
  } else {
#line 427
    sym1 = e1->left.sym;
  }
#line 428
  if ((unsigned int )e2->type == 3U) {
#line 429
    if ((unsigned int )(e2->left.expr)->type != 7U) {
#line 430
      return ((struct expr *)((void *)0));
    }
#line 431
    sym2 = (e2->left.expr)->left.sym;
  } else {
#line 433
    sym2 = e2->left.sym;
  }
#line 434
  if ((unsigned long )sym1 != (unsigned long )sym2) {
#line 435
    return ((struct expr *)((void *)0));
  }
#line 436
  if ((unsigned int )sym1->type != 1U) {
#line 436
    if ((unsigned int )sym1->type != 2U) {
#line 437
      return ((struct expr *)((void *)0));
    }
  }
#line 439
  if ((unsigned int )e1->type == 7U) {
#line 439
    if ((unsigned int )e2->type == 4U) {
#line 439
      if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_yes)) {
        {
#line 442
        tmp___2 = expr_alloc_comp((enum expr_type )4, sym1, & symbol_yes);
        }
#line 442
        return (tmp___2);
      } else {
#line 439
        goto _L___0;
      }
    } else {
#line 439
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 439
  if ((unsigned int )e2->type == 7U) {
#line 439
    if ((unsigned int )e1->type == 4U) {
#line 439
      if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_yes)) {
        {
#line 442
        tmp___2 = expr_alloc_comp((enum expr_type )4, sym1, & symbol_yes);
        }
#line 442
        return (tmp___2);
      }
    }
  }
#line 444
  if ((unsigned int )e1->type == 7U) {
#line 444
    if ((unsigned int )e2->type == 5U) {
#line 444
      if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_no)) {
        {
#line 447
        tmp___3 = expr_alloc_symbol(sym1);
        }
#line 447
        return (tmp___3);
      } else {
#line 444
        goto _L___2;
      }
    } else {
#line 444
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 444
  if ((unsigned int )e2->type == 7U) {
#line 444
    if ((unsigned int )e1->type == 5U) {
#line 444
      if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_no)) {
        {
#line 447
        tmp___3 = expr_alloc_symbol(sym1);
        }
#line 447
        return (tmp___3);
      }
    }
  }
#line 449
  if ((unsigned int )e1->type == 7U) {
#line 449
    if ((unsigned int )e2->type == 5U) {
#line 449
      if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_mod)) {
        {
#line 452
        tmp___4 = expr_alloc_comp((enum expr_type )4, sym1, & symbol_yes);
        }
#line 452
        return (tmp___4);
      } else {
#line 449
        goto _L___4;
      }
    } else {
#line 449
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 449
  if ((unsigned int )e2->type == 7U) {
#line 449
    if ((unsigned int )e1->type == 5U) {
#line 449
      if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_mod)) {
        {
#line 452
        tmp___4 = expr_alloc_comp((enum expr_type )4, sym1, & symbol_yes);
        }
#line 452
        return (tmp___4);
      }
    }
  }
#line 454
  if ((unsigned int )sym1->type == 2U) {
#line 455
    if ((unsigned int )e1->type == 4U) {
#line 455
      if ((unsigned int )e2->type == 5U) {
#line 457
        sym2 = e1->right.sym;
#line 458
        if ((e2->right.sym)->flags & 1) {
#line 458
          if (sym2->flags & 1) {
#line 459
            if ((unsigned long )sym2 != (unsigned long )e2->right.sym) {
              {
#line 459
              tmp___5 = expr_alloc_comp((enum expr_type )4, sym1, sym2);
#line 459
              tmp___7 = tmp___5;
              }
            } else {
              {
#line 459
              tmp___6 = expr_alloc_symbol(& symbol_no);
#line 459
              tmp___7 = tmp___6;
              }
            }
#line 459
            return (tmp___7);
          }
        }
      }
    }
#line 462
    if ((unsigned int )e1->type == 5U) {
#line 462
      if ((unsigned int )e2->type == 4U) {
#line 464
        sym2 = e2->right.sym;
#line 465
        if ((e1->right.sym)->flags & 1) {
#line 465
          if (sym2->flags & 1) {
#line 466
            if ((unsigned long )sym2 != (unsigned long )e1->right.sym) {
              {
#line 466
              tmp___8 = expr_alloc_comp((enum expr_type )4, sym1, sym2);
#line 466
              tmp___10 = tmp___8;
              }
            } else {
              {
#line 466
              tmp___9 = expr_alloc_symbol(& symbol_no);
#line 466
              tmp___10 = tmp___9;
              }
            }
#line 466
            return (tmp___10);
          }
        }
      }
    }
#line 469
    if ((unsigned int )e1->type == 5U) {
#line 469
      if ((unsigned int )e2->type == 5U) {
#line 469
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_yes)) {
#line 469
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_no)) {
            {
#line 473
            tmp___11 = expr_alloc_comp((enum expr_type )4, sym1, & symbol_mod);
            }
#line 473
            return (tmp___11);
          } else {
#line 469
            goto _L___5;
          }
        } else
        _L___5: /* CIL Label */ 
#line 469
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_no)) {
#line 469
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_yes)) {
            {
#line 473
            tmp___11 = expr_alloc_comp((enum expr_type )4, sym1, & symbol_mod);
            }
#line 473
            return (tmp___11);
          }
        }
      }
    }
#line 475
    if ((unsigned int )e1->type == 5U) {
#line 475
      if ((unsigned int )e2->type == 5U) {
#line 475
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_yes)) {
#line 475
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_mod)) {
            {
#line 479
            tmp___12 = expr_alloc_comp((enum expr_type )4, sym1, & symbol_no);
            }
#line 479
            return (tmp___12);
          } else {
#line 475
            goto _L___6;
          }
        } else
        _L___6: /* CIL Label */ 
#line 475
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_mod)) {
#line 475
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_yes)) {
            {
#line 479
            tmp___12 = expr_alloc_comp((enum expr_type )4, sym1, & symbol_no);
            }
#line 479
            return (tmp___12);
          }
        }
      }
    }
#line 481
    if ((unsigned int )e1->type == 5U) {
#line 481
      if ((unsigned int )e2->type == 5U) {
#line 481
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_mod)) {
#line 481
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_no)) {
            {
#line 485
            tmp___13 = expr_alloc_comp((enum expr_type )4, sym1, & symbol_yes);
            }
#line 485
            return (tmp___13);
          } else {
#line 481
            goto _L___7;
          }
        } else
        _L___7: /* CIL Label */ 
#line 481
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_no)) {
#line 481
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_mod)) {
            {
#line 485
            tmp___13 = expr_alloc_comp((enum expr_type )4, sym1, & symbol_yes);
            }
#line 485
            return (tmp___13);
          }
        }
      }
    }
#line 487
    if ((unsigned int )e1->type == 7U) {
#line 487
      if ((unsigned int )e2->type == 4U) {
#line 487
        if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_mod)) {
#line 491
          return ((struct expr *)((void *)0));
        } else {
#line 487
          goto _L___13;
        }
      } else {
#line 487
        goto _L___13;
      }
    } else
    _L___13: /* CIL Label */ 
#line 487
    if ((unsigned int )e2->type == 7U) {
#line 487
      if ((unsigned int )e1->type == 4U) {
#line 487
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_mod)) {
#line 491
          return ((struct expr *)((void *)0));
        } else {
#line 487
          goto _L___11;
        }
      } else {
#line 487
        goto _L___11;
      }
    } else
    _L___11: /* CIL Label */ 
#line 487
    if ((unsigned int )e1->type == 7U) {
#line 487
      if ((unsigned int )e2->type == 5U) {
#line 487
        if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_yes)) {
#line 491
          return ((struct expr *)((void *)0));
        } else {
#line 487
          goto _L___9;
        }
      } else {
#line 487
        goto _L___9;
      }
    } else
    _L___9: /* CIL Label */ 
#line 487
    if ((unsigned int )e2->type == 7U) {
#line 487
      if ((unsigned int )e1->type == 5U) {
#line 487
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_yes)) {
#line 491
          return ((struct expr *)((void *)0));
        }
      }
    }
  }
#line 501
  return ((struct expr *)((void *)0));
}
}
#line 504 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.c"
static void expr_eliminate_dups1(enum expr_type type , struct expr **ep1 , struct expr **ep2 ) 
{ 
  struct expr *tmp ;

  {
#line 510
  if ((unsigned int )(*ep1)->type == (unsigned int )type) {
    {
#line 511
    expr_eliminate_dups1(type, & (*ep1)->left.expr, ep2);
#line 512
    expr_eliminate_dups1(type, & (*ep1)->right.expr, ep2);
    }
#line 513
    return;
  }
#line 515
  if ((unsigned int )(*ep2)->type == (unsigned int )type) {
    {
#line 516
    expr_eliminate_dups1(type, ep1, & (*ep2)->left.expr);
#line 517
    expr_eliminate_dups1(type, ep1, & (*ep2)->right.expr);
    }
#line 518
    return;
  }
#line 520
  if ((unsigned long )*ep1 == (unsigned long )*ep2) {
#line 521
    return;
  }
  {
#line 524
  if ((unsigned int )(*ep1)->type == 2U) {
#line 524
    goto case_2;
  }
#line 524
  if ((unsigned int )(*ep1)->type == 1U) {
#line 524
    goto case_2;
  }
#line 526
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 525
  expr_eliminate_dups1((*ep1)->type, ep1, ep1);
  }
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
  {
#line 531
  if ((unsigned int )type == 1U) {
#line 531
    goto case_1___0;
  }
#line 540
  if ((unsigned int )type == 2U) {
#line 540
    goto case_2___0;
  }
#line 549
  goto switch_default___0;
  case_1___0: /* CIL Label */ 
  {
#line 532
  tmp = expr_join_or(*ep1, *ep2);
  }
#line 533
  if (tmp) {
    {
#line 534
    expr_free(*ep1);
#line 534
    expr_free(*ep2);
#line 535
    *ep1 = expr_alloc_symbol(& symbol_no);
#line 536
    *ep2 = tmp;
#line 537
    trans_count ++;
    }
  }
#line 539
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
  {
#line 541
  tmp = expr_join_and(*ep1, *ep2);
  }
#line 542
  if (tmp) {
    {
#line 543
    expr_free(*ep1);
#line 543
    expr_free(*ep2);
#line 544
    *ep1 = expr_alloc_symbol(& symbol_yes);
#line 545
    *ep2 = tmp;
#line 546
    trans_count ++;
    }
  }
#line 548
  goto switch_break___0;
  switch_default___0: /* CIL Label */ ;
  switch_break___0: /* CIL Label */ ;
  }
#line 554
  return;
}
}
#line 556 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.c"
static void expr_eliminate_dups2(enum expr_type type , struct expr **ep1 , struct expr **ep2 ) 
{ 
  struct expr *tmp ;
  struct expr *tmp1 ;
  struct expr *tmp2 ;
  struct expr *tmp___0 ;
  struct expr *tmp___1 ;
  int tmp___2 ;
  struct expr *tmp___3 ;
  struct expr *tmp___4 ;
  int tmp___5 ;

  {
#line 562
  if ((unsigned int )(*ep1)->type == (unsigned int )type) {
    {
#line 563
    expr_eliminate_dups2(type, & (*ep1)->left.expr, ep2);
#line 564
    expr_eliminate_dups2(type, & (*ep1)->right.expr, ep2);
    }
#line 565
    return;
  }
#line 567
  if ((unsigned int )(*ep2)->type == (unsigned int )type) {
    {
#line 568
    expr_eliminate_dups2(type, ep1, & (*ep2)->left.expr);
#line 569
    expr_eliminate_dups2(type, ep1, & (*ep2)->right.expr);
    }
  }
#line 571
  if ((unsigned long )*ep1 == (unsigned long )*ep2) {
#line 572
    return;
  }
  {
#line 575
  if ((unsigned int )(*ep1)->type == 1U) {
#line 575
    goto case_1;
  }
#line 590
  if ((unsigned int )(*ep1)->type == 2U) {
#line 590
    goto case_2;
  }
#line 605
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 576
  expr_eliminate_dups2((*ep1)->type, ep1, ep1);
#line 578
  tmp___0 = expr_copy((struct expr  const  *)*ep1);
#line 578
  tmp___1 = expr_alloc_one((enum expr_type )3, tmp___0);
#line 578
  tmp1 = expr_transform(tmp___1);
#line 579
  tmp2 = expr_copy((struct expr  const  *)*ep2);
#line 580
  tmp = expr_extract_eq_and(& tmp1, & tmp2);
#line 581
  tmp___2 = expr_is_yes(tmp1);
  }
#line 581
  if (tmp___2) {
    {
#line 582
    expr_free(*ep1);
#line 583
    *ep1 = expr_alloc_symbol(& symbol_no);
#line 584
    trans_count ++;
    }
  }
  {
#line 586
  expr_free(tmp2);
#line 587
  expr_free(tmp1);
#line 588
  expr_free(tmp);
  }
#line 589
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 591
  expr_eliminate_dups2((*ep1)->type, ep1, ep1);
#line 593
  tmp___3 = expr_copy((struct expr  const  *)*ep1);
#line 593
  tmp___4 = expr_alloc_one((enum expr_type )3, tmp___3);
#line 593
  tmp1 = expr_transform(tmp___4);
#line 594
  tmp2 = expr_copy((struct expr  const  *)*ep2);
#line 595
  tmp = expr_extract_eq_or(& tmp1, & tmp2);
#line 596
  tmp___5 = expr_is_no(tmp1);
  }
#line 596
  if (tmp___5) {
    {
#line 597
    expr_free(*ep1);
#line 598
    *ep1 = expr_alloc_symbol(& symbol_yes);
#line 599
    trans_count ++;
    }
  }
  {
#line 601
  expr_free(tmp2);
#line 602
  expr_free(tmp1);
#line 603
  expr_free(tmp);
  }
#line 604
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 610
  return;
}
}
#line 612 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.c"
struct expr *expr_eliminate_dups(struct expr *e ) 
{ 
  int oldcount ;

  {
#line 615
  if (! e) {
#line 616
    return (e);
  }
#line 618
  oldcount = trans_count;
  {
#line 619
  while (1) {
    while_continue: /* CIL Label */ ;
#line 620
    trans_count = 0;
    {
#line 622
    if ((unsigned int )e->type == 2U) {
#line 622
      goto case_2;
    }
#line 622
    if ((unsigned int )e->type == 1U) {
#line 622
      goto case_2;
    }
#line 625
    goto switch_default;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
    {
#line 623
    expr_eliminate_dups1(e->type, & e, & e);
#line 624
    expr_eliminate_dups2(e->type, & e, & e);
    }
    switch_default: /* CIL Label */ ;
    switch_break: /* CIL Label */ ;
    }
#line 628
    if (! trans_count) {
#line 629
      goto while_break;
    }
    {
#line 630
    e = expr_eliminate_yn(e);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 632
  trans_count = oldcount;
#line 633
  return (e);
}
}
#line 636 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.c"
struct expr *expr_transform(struct expr *e ) 
{ 
  struct expr *tmp ;

  {
#line 640
  if (! e) {
#line 641
    return ((struct expr *)((void *)0));
  }
  {
#line 646
  if ((unsigned int )e->type == 6U) {
#line 646
    goto case_6;
  }
#line 646
  if ((unsigned int )e->type == 7U) {
#line 646
    goto case_6;
  }
#line 646
  if ((unsigned int )e->type == 5U) {
#line 646
    goto case_6;
  }
#line 646
  if ((unsigned int )e->type == 4U) {
#line 646
    goto case_6;
  }
#line 648
  goto switch_default;
  case_6: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 647
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 649
  e->left.expr = expr_transform(e->left.expr);
#line 650
  e->right.expr = expr_transform(e->right.expr);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 654
  if ((unsigned int )e->type == 4U) {
#line 654
    goto case_4___0;
  }
#line 676
  if ((unsigned int )e->type == 5U) {
#line 676
    goto case_5___0;
  }
#line 698
  if ((unsigned int )e->type == 3U) {
#line 698
    goto case_3;
  }
#line 767
  goto switch_default___1;
  case_4___0: /* CIL Label */ 
#line 655
  if ((unsigned int )(e->left.sym)->type != 1U) {
#line 656
    goto switch_break___0;
  }
#line 657
  if ((unsigned long )e->right.sym == (unsigned long )(& symbol_no)) {
    {
#line 658
    e->type = (enum expr_type )3;
#line 659
    e->left.expr = expr_alloc_symbol(e->left.sym);
#line 660
    e->right.sym = (struct symbol *)((void *)0);
    }
#line 661
    goto switch_break___0;
  }
#line 663
  if ((unsigned long )e->right.sym == (unsigned long )(& symbol_mod)) {
    {
#line 664
    printf((char const   */* __restrict  */)"boolean symbol %s tested for \'m\'? test forced to \'n\'\n",
           (e->left.sym)->name);
#line 665
    e->type = (enum expr_type )7;
#line 666
    e->left.sym = & symbol_no;
#line 667
    e->right.sym = (struct symbol *)((void *)0);
    }
#line 668
    goto switch_break___0;
  }
#line 670
  if ((unsigned long )e->right.sym == (unsigned long )(& symbol_yes)) {
#line 671
    e->type = (enum expr_type )7;
#line 672
    e->right.sym = (struct symbol *)((void *)0);
#line 673
    goto switch_break___0;
  }
#line 675
  goto switch_break___0;
  case_5___0: /* CIL Label */ 
#line 677
  if ((unsigned int )(e->left.sym)->type != 1U) {
#line 678
    goto switch_break___0;
  }
#line 679
  if ((unsigned long )e->right.sym == (unsigned long )(& symbol_no)) {
#line 680
    e->type = (enum expr_type )7;
#line 681
    e->right.sym = (struct symbol *)((void *)0);
#line 682
    goto switch_break___0;
  }
#line 684
  if ((unsigned long )e->right.sym == (unsigned long )(& symbol_mod)) {
    {
#line 685
    printf((char const   */* __restrict  */)"boolean symbol %s tested for \'m\'? test forced to \'y\'\n",
           (e->left.sym)->name);
#line 686
    e->type = (enum expr_type )7;
#line 687
    e->left.sym = & symbol_yes;
#line 688
    e->right.sym = (struct symbol *)((void *)0);
    }
#line 689
    goto switch_break___0;
  }
#line 691
  if ((unsigned long )e->right.sym == (unsigned long )(& symbol_yes)) {
    {
#line 692
    e->type = (enum expr_type )3;
#line 693
    e->left.expr = expr_alloc_symbol(e->left.sym);
#line 694
    e->right.sym = (struct symbol *)((void *)0);
    }
#line 695
    goto switch_break___0;
  }
#line 697
  goto switch_break___0;
  case_3: /* CIL Label */ 
  {
#line 700
  if ((unsigned int )(e->left.expr)->type == 3U) {
#line 700
    goto case_3___0;
  }
#line 709
  if ((unsigned int )(e->left.expr)->type == 5U) {
#line 709
    goto case_5___1;
  }
#line 709
  if ((unsigned int )(e->left.expr)->type == 4U) {
#line 709
    goto case_5___1;
  }
#line 716
  if ((unsigned int )(e->left.expr)->type == 1U) {
#line 716
    goto case_1;
  }
#line 725
  if ((unsigned int )(e->left.expr)->type == 2U) {
#line 725
    goto case_2;
  }
#line 734
  if ((unsigned int )(e->left.expr)->type == 7U) {
#line 734
    goto case_7___0;
  }
#line 763
  goto switch_default___0;
  case_3___0: /* CIL Label */ 
  {
#line 702
  tmp = (e->left.expr)->left.expr;
#line 703
  free((void *)e->left.expr);
#line 704
  free((void *)e);
#line 705
  e = tmp;
#line 706
  e = expr_transform(e);
  }
#line 707
  goto switch_break___1;
  case_5___1: /* CIL Label */ 
  case_4___1: /* CIL Label */ 
  {
#line 711
  tmp = e->left.expr;
#line 712
  free((void *)e);
#line 713
  e = tmp;
  }
#line 714
  if ((unsigned int )e->type == 4U) {
#line 714
    e->type = (enum expr_type )5;
  } else {
#line 714
    e->type = (enum expr_type )4;
  }
#line 715
  goto switch_break___1;
  case_1: /* CIL Label */ 
  {
#line 718
  tmp = e->left.expr;
#line 719
  e->type = (enum expr_type )2;
#line 720
  e->right.expr = expr_alloc_one((enum expr_type )3, tmp->right.expr);
#line 721
  tmp->type = (enum expr_type )3;
#line 722
  tmp->right.expr = (struct expr *)((void *)0);
#line 723
  e = expr_transform(e);
  }
#line 724
  goto switch_break___1;
  case_2: /* CIL Label */ 
  {
#line 727
  tmp = e->left.expr;
#line 728
  e->type = (enum expr_type )1;
#line 729
  e->right.expr = expr_alloc_one((enum expr_type )3, tmp->right.expr);
#line 730
  tmp->type = (enum expr_type )3;
#line 731
  tmp->right.expr = (struct expr *)((void *)0);
#line 732
  e = expr_transform(e);
  }
#line 733
  goto switch_break___1;
  case_7___0: /* CIL Label */ 
#line 735
  if ((unsigned long )(e->left.expr)->left.sym == (unsigned long )(& symbol_yes)) {
    {
#line 737
    tmp = e->left.expr;
#line 738
    free((void *)e);
#line 739
    e = tmp;
#line 740
    e->type = (enum expr_type )7;
#line 741
    e->left.sym = & symbol_no;
    }
#line 742
    goto switch_break___1;
  }
#line 744
  if ((unsigned long )(e->left.expr)->left.sym == (unsigned long )(& symbol_mod)) {
    {
#line 746
    tmp = e->left.expr;
#line 747
    free((void *)e);
#line 748
    e = tmp;
#line 749
    e->type = (enum expr_type )7;
#line 750
    e->left.sym = & symbol_mod;
    }
#line 751
    goto switch_break___1;
  }
#line 753
  if ((unsigned long )(e->left.expr)->left.sym == (unsigned long )(& symbol_no)) {
    {
#line 755
    tmp = e->left.expr;
#line 756
    free((void *)e);
#line 757
    e = tmp;
#line 758
    e->type = (enum expr_type )7;
#line 759
    e->left.sym = & symbol_yes;
    }
#line 760
    goto switch_break___1;
  }
#line 762
  goto switch_break___1;
  switch_default___0: /* CIL Label */ ;
  switch_break___1: /* CIL Label */ ;
  }
#line 766
  goto switch_break___0;
  switch_default___1: /* CIL Label */ ;
  switch_break___0: /* CIL Label */ ;
  }
#line 770
  return (e);
}
}
#line 773 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.c"
int expr_contains_symbol(struct expr *dep , struct symbol *sym ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 775
  if (! dep) {
#line 776
    return (0);
  }
  {
#line 780
  if ((unsigned int )dep->type == 1U) {
#line 780
    goto case_1;
  }
#line 780
  if ((unsigned int )dep->type == 2U) {
#line 780
    goto case_1;
  }
#line 783
  if ((unsigned int )dep->type == 7U) {
#line 783
    goto case_7;
  }
#line 786
  if ((unsigned int )dep->type == 5U) {
#line 786
    goto case_5;
  }
#line 786
  if ((unsigned int )dep->type == 4U) {
#line 786
    goto case_5;
  }
#line 789
  if ((unsigned int )dep->type == 3U) {
#line 789
    goto case_3;
  }
#line 791
  goto switch_default;
  case_1: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 781
  tmp = expr_contains_symbol(dep->left.expr, sym);
  }
#line 781
  if (tmp) {
#line 781
    tmp___1 = 1;
  } else {
    {
#line 781
    tmp___0 = expr_contains_symbol(dep->right.expr, sym);
    }
#line 781
    if (tmp___0) {
#line 781
      tmp___1 = 1;
    } else {
#line 781
      tmp___1 = 0;
    }
  }
#line 781
  return (tmp___1);
  case_7: /* CIL Label */ 
#line 784
  return ((unsigned long )dep->left.sym == (unsigned long )sym);
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 787
  if ((unsigned long )dep->left.sym == (unsigned long )sym) {
#line 787
    tmp___2 = 1;
  } else
#line 787
  if ((unsigned long )dep->right.sym == (unsigned long )sym) {
#line 787
    tmp___2 = 1;
  } else {
#line 787
    tmp___2 = 0;
  }
#line 787
  return (tmp___2);
  case_3: /* CIL Label */ 
  {
#line 790
  tmp___3 = expr_contains_symbol(dep->left.expr, sym);
  }
#line 790
  return (tmp___3);
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 794
  return (0);
}
}
#line 797 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.c"
_Bool expr_depends_symbol(struct expr *dep , struct symbol *sym ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;

  {
#line 799
  if (! dep) {
#line 800
    return ((_Bool)0);
  }
  {
#line 803
  if ((unsigned int )dep->type == 2U) {
#line 803
    goto case_2;
  }
#line 806
  if ((unsigned int )dep->type == 7U) {
#line 806
    goto case_7;
  }
#line 808
  if ((unsigned int )dep->type == 4U) {
#line 808
    goto case_4;
  }
#line 814
  if ((unsigned int )dep->type == 5U) {
#line 814
    goto case_5;
  }
#line 820
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 804
  tmp = expr_depends_symbol(dep->left.expr, sym);
  }
#line 804
  if (tmp) {
#line 804
    tmp___1 = 1;
  } else {
    {
#line 804
    tmp___0 = expr_depends_symbol(dep->right.expr, sym);
    }
#line 804
    if (tmp___0) {
#line 804
      tmp___1 = 1;
    } else {
#line 804
      tmp___1 = 0;
    }
  }
#line 804
  return ((_Bool )tmp___1);
  case_7: /* CIL Label */ 
#line 807
  return ((_Bool )((unsigned long )dep->left.sym == (unsigned long )sym));
  case_4: /* CIL Label */ 
#line 809
  if ((unsigned long )dep->left.sym == (unsigned long )sym) {
#line 810
    if ((unsigned long )dep->right.sym == (unsigned long )(& symbol_yes)) {
#line 811
      return ((_Bool)1);
    } else
#line 810
    if ((unsigned long )dep->right.sym == (unsigned long )(& symbol_mod)) {
#line 811
      return ((_Bool)1);
    }
  }
#line 813
  goto switch_break;
  case_5: /* CIL Label */ 
#line 815
  if ((unsigned long )dep->left.sym == (unsigned long )sym) {
#line 816
    if ((unsigned long )dep->right.sym == (unsigned long )(& symbol_no)) {
#line 817
      return ((_Bool)1);
    }
  }
#line 819
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 823
  return ((_Bool)0);
}
}
#line 826 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.c"
struct expr *expr_extract_eq_and(struct expr **ep1 , struct expr **ep2 ) 
{ 
  struct expr *tmp ;

  {
  {
#line 828
  tmp = (struct expr *)((void *)0);
#line 829
  expr_extract_eq((enum expr_type )2, & tmp, ep1, ep2);
  }
#line 830
  if (tmp) {
    {
#line 831
    *ep1 = expr_eliminate_yn(*ep1);
#line 832
    *ep2 = expr_eliminate_yn(*ep2);
    }
  }
#line 834
  return (tmp);
}
}
#line 837 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.c"
struct expr *expr_extract_eq_or(struct expr **ep1 , struct expr **ep2 ) 
{ 
  struct expr *tmp ;

  {
  {
#line 839
  tmp = (struct expr *)((void *)0);
#line 840
  expr_extract_eq((enum expr_type )1, & tmp, ep1, ep2);
  }
#line 841
  if (tmp) {
    {
#line 842
    *ep1 = expr_eliminate_yn(*ep1);
#line 843
    *ep2 = expr_eliminate_yn(*ep2);
    }
  }
#line 845
  return (tmp);
}
}
#line 848 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.c"
void expr_extract_eq(enum expr_type type , struct expr **ep , struct expr **ep1 ,
                     struct expr **ep2 ) 
{ 
  struct expr *tmp ;
  int tmp___0 ;

  {
#line 852
  if ((unsigned int )(*ep1)->type == (unsigned int )type) {
    {
#line 853
    expr_extract_eq(type, ep, & (*ep1)->left.expr, ep2);
#line 854
    expr_extract_eq(type, ep, & (*ep1)->right.expr, ep2);
    }
#line 855
    return;
  }
#line 857
  if ((unsigned int )(*ep2)->type == (unsigned int )type) {
    {
#line 858
    expr_extract_eq(type, ep, ep1, & (*ep2)->left.expr);
#line 859
    expr_extract_eq(type, ep, ep1, & (*ep2)->right.expr);
    }
#line 860
    return;
  }
  {
#line 862
  tmp___0 = expr_eq(*ep1, *ep2);
  }
#line 862
  if (tmp___0) {
#line 863
    if (*ep) {
      {
#line 863
      tmp = expr_alloc_two(type, *ep, *ep1);
#line 863
      *ep = tmp;
      }
    } else {
#line 863
      *ep = *ep1;
    }
    {
#line 864
    expr_free(*ep2);
    }
#line 865
    if ((unsigned int )type == 2U) {
      {
#line 866
      *ep1 = expr_alloc_symbol(& symbol_yes);
#line 867
      *ep2 = expr_alloc_symbol(& symbol_yes);
      }
    } else
#line 868
    if ((unsigned int )type == 1U) {
      {
#line 869
      *ep1 = expr_alloc_symbol(& symbol_no);
#line 870
      *ep2 = expr_alloc_symbol(& symbol_no);
      }
    }
  }
#line 875
  return;
}
}
#line 877 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.c"
struct expr *expr_trans_compare(struct expr *e , enum expr_type type , struct symbol *sym ) 
{ 
  struct expr *e1 ;
  struct expr *e2 ;
  int tmp ;
  struct expr *tmp___0 ;
  struct expr *tmp___1 ;
  struct expr *tmp___2 ;
  struct expr *tmp___3 ;
  struct expr *tmp___4 ;
  struct expr *tmp___5 ;
  struct expr *tmp___6 ;
  struct expr *tmp___7 ;
  struct expr *tmp___8 ;
  struct expr *tmp___9 ;

  {
#line 881
  if (! e) {
    {
#line 882
    e = expr_alloc_symbol(sym);
    }
#line 883
    if ((unsigned int )type == 5U) {
      {
#line 884
      e = expr_alloc_one((enum expr_type )3, e);
      }
    }
#line 885
    return (e);
  }
  {
#line 888
  if ((unsigned int )e->type == 2U) {
#line 888
    goto case_2;
  }
#line 898
  if ((unsigned int )e->type == 1U) {
#line 898
    goto case_1;
  }
#line 908
  if ((unsigned int )e->type == 3U) {
#line 908
    goto case_3;
  }
#line 911
  if ((unsigned int )e->type == 4U) {
#line 911
    goto case_4;
  }
#line 911
  if ((unsigned int )e->type == 5U) {
#line 911
    goto case_4;
  }
#line 928
  if ((unsigned int )e->type == 7U) {
#line 928
    goto case_7;
  }
#line 932
  if ((unsigned int )e->type == 0U) {
#line 932
    goto case_0;
  }
#line 932
  if ((unsigned int )e->type == 8U) {
#line 932
    goto case_0;
  }
#line 932
  if ((unsigned int )e->type == 6U) {
#line 932
    goto case_0;
  }
#line 887
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 889
  e1 = expr_trans_compare(e->left.expr, (enum expr_type )4, sym);
#line 890
  e2 = expr_trans_compare(e->right.expr, (enum expr_type )4, sym);
  }
#line 891
  if ((unsigned long )sym == (unsigned long )(& symbol_yes)) {
    {
#line 892
    e = expr_alloc_two((enum expr_type )2, e1, e2);
    }
  }
#line 893
  if ((unsigned long )sym == (unsigned long )(& symbol_no)) {
    {
#line 894
    e = expr_alloc_two((enum expr_type )1, e1, e2);
    }
  }
#line 895
  if ((unsigned int )type == 5U) {
    {
#line 896
    e = expr_alloc_one((enum expr_type )3, e);
    }
  }
#line 897
  return (e);
  case_1: /* CIL Label */ 
  {
#line 899
  e1 = expr_trans_compare(e->left.expr, (enum expr_type )4, sym);
#line 900
  e2 = expr_trans_compare(e->right.expr, (enum expr_type )4, sym);
  }
#line 901
  if ((unsigned long )sym == (unsigned long )(& symbol_yes)) {
    {
#line 902
    e = expr_alloc_two((enum expr_type )1, e1, e2);
    }
  }
#line 903
  if ((unsigned long )sym == (unsigned long )(& symbol_no)) {
    {
#line 904
    e = expr_alloc_two((enum expr_type )2, e1, e2);
    }
  }
#line 905
  if ((unsigned int )type == 5U) {
    {
#line 906
    e = expr_alloc_one((enum expr_type )3, e);
    }
  }
#line 907
  return (e);
  case_3: /* CIL Label */ 
#line 909
  if ((unsigned int )type == 4U) {
#line 909
    tmp = 5;
  } else {
#line 909
    tmp = 4;
  }
  {
#line 909
  tmp___0 = expr_trans_compare(e->left.expr, (enum expr_type )tmp, sym);
  }
#line 909
  return (tmp___0);
  case_4: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 912
  if ((unsigned int )type == 4U) {
#line 913
    if ((unsigned long )sym == (unsigned long )(& symbol_yes)) {
      {
#line 914
      tmp___1 = expr_copy((struct expr  const  *)e);
      }
#line 914
      return (tmp___1);
    }
#line 915
    if ((unsigned long )sym == (unsigned long )(& symbol_mod)) {
      {
#line 916
      tmp___2 = expr_alloc_symbol(& symbol_no);
      }
#line 916
      return (tmp___2);
    }
#line 917
    if ((unsigned long )sym == (unsigned long )(& symbol_no)) {
      {
#line 918
      tmp___3 = expr_copy((struct expr  const  *)e);
#line 918
      tmp___4 = expr_alloc_one((enum expr_type )3, tmp___3);
      }
#line 918
      return (tmp___4);
    }
  } else {
#line 920
    if ((unsigned long )sym == (unsigned long )(& symbol_yes)) {
      {
#line 921
      tmp___5 = expr_copy((struct expr  const  *)e);
#line 921
      tmp___6 = expr_alloc_one((enum expr_type )3, tmp___5);
      }
#line 921
      return (tmp___6);
    }
#line 922
    if ((unsigned long )sym == (unsigned long )(& symbol_mod)) {
      {
#line 923
      tmp___7 = expr_alloc_symbol(& symbol_yes);
      }
#line 923
      return (tmp___7);
    }
#line 924
    if ((unsigned long )sym == (unsigned long )(& symbol_no)) {
      {
#line 925
      tmp___8 = expr_copy((struct expr  const  *)e);
      }
#line 925
      return (tmp___8);
    }
  }
#line 927
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 929
  tmp___9 = expr_alloc_comp(type, e->left.sym, sym);
  }
#line 929
  return (tmp___9);
  case_0: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_6: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 935
  return ((struct expr *)((void *)0));
}
}
#line 938 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.c"
tristate expr_calc_value(struct expr *e ) 
{ 
  tristate val1 ;
  tristate val2 ;
  char const   *str1 ;
  char const   *str2 ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 943
  if (! e) {
#line 944
    return ((tristate )2);
  }
  {
#line 947
  if ((unsigned int )e->type == 7U) {
#line 947
    goto case_7;
  }
#line 950
  if ((unsigned int )e->type == 2U) {
#line 950
    goto case_2;
  }
#line 954
  if ((unsigned int )e->type == 1U) {
#line 954
    goto case_1;
  }
#line 958
  if ((unsigned int )e->type == 3U) {
#line 958
    goto case_3;
  }
#line 961
  if ((unsigned int )e->type == 4U) {
#line 961
    goto case_4;
  }
#line 967
  if ((unsigned int )e->type == 5U) {
#line 967
    goto case_5;
  }
#line 973
  goto switch_default;
  case_7: /* CIL Label */ 
  {
#line 948
  sym_calc_value(e->left.sym);
  }
#line 949
  return ((e->left.sym)->curr.tri);
  case_2: /* CIL Label */ 
  {
#line 951
  val1 = expr_calc_value(e->left.expr);
#line 952
  val2 = expr_calc_value(e->right.expr);
  }
#line 953
  if ((unsigned int )val1 < (unsigned int )val2) {
#line 953
    tmp = (unsigned int )val1;
  } else {
#line 953
    tmp = (unsigned int )val2;
  }
#line 953
  return ((tristate )tmp);
  case_1: /* CIL Label */ 
  {
#line 955
  val1 = expr_calc_value(e->left.expr);
#line 956
  val2 = expr_calc_value(e->right.expr);
  }
#line 957
  if ((unsigned int )val1 > (unsigned int )val2) {
#line 957
    tmp___0 = (unsigned int )val1;
  } else {
#line 957
    tmp___0 = (unsigned int )val2;
  }
#line 957
  return ((tristate )tmp___0);
  case_3: /* CIL Label */ 
  {
#line 959
  val1 = expr_calc_value(e->left.expr);
  }
#line 960
  return ((tristate )(2U - (unsigned int )val1));
  case_4: /* CIL Label */ 
  {
#line 962
  sym_calc_value(e->left.sym);
#line 963
  sym_calc_value(e->right.sym);
#line 964
  str1 = sym_get_string_value(e->left.sym);
#line 965
  str2 = sym_get_string_value(e->right.sym);
#line 966
  tmp___3 = strcmp(str1, str2);
  }
#line 966
  if (tmp___3) {
#line 966
    tmp___2 = 0;
  } else {
#line 966
    tmp___2 = 2;
  }
#line 966
  return ((tristate )tmp___2);
  case_5: /* CIL Label */ 
  {
#line 968
  sym_calc_value(e->left.sym);
#line 969
  sym_calc_value(e->right.sym);
#line 970
  str1 = sym_get_string_value(e->left.sym);
#line 971
  str2 = sym_get_string_value(e->right.sym);
#line 972
  tmp___6 = strcmp(str1, str2);
  }
#line 972
  if (tmp___6) {
#line 972
    tmp___5 = 2;
  } else {
#line 972
    tmp___5 = 0;
  }
#line 972
  return ((tristate )tmp___5);
  switch_default: /* CIL Label */ 
  {
#line 974
  printf((char const   */* __restrict  */)"expr_calc_value: %d?\n", (unsigned int )e->type);
  }
#line 975
  return ((tristate )0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 979 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.c"
int expr_compare_type(enum expr_type t1 , enum expr_type t2 ) 
{ 


  {
#line 984
  if ((unsigned int )t1 == (unsigned int )t2) {
#line 985
    return (0);
  }
  {
#line 988
  if ((unsigned int )t1 == 5U) {
#line 988
    goto case_5;
  }
#line 988
  if ((unsigned int )t1 == 4U) {
#line 988
    goto case_5;
  }
#line 991
  if ((unsigned int )t1 == 3U) {
#line 991
    goto case_3;
  }
#line 994
  if ((unsigned int )t1 == 2U) {
#line 994
    goto case_2;
  }
#line 997
  if ((unsigned int )t1 == 1U) {
#line 997
    goto case_1;
  }
#line 1000
  if ((unsigned int )t1 == 6U) {
#line 1000
    goto case_6;
  }
#line 1003
  goto switch_default;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 989
  if ((unsigned int )t2 == 3U) {
#line 990
    return (1);
  }
  case_3: /* CIL Label */ 
#line 992
  if ((unsigned int )t2 == 2U) {
#line 993
    return (1);
  }
  case_2: /* CIL Label */ 
#line 995
  if ((unsigned int )t2 == 1U) {
#line 996
    return (1);
  }
  case_1: /* CIL Label */ 
#line 998
  if ((unsigned int )t2 == 6U) {
#line 999
    return (1);
  }
  case_6: /* CIL Label */ 
#line 1001
  if ((unsigned int )t2 == 0U) {
#line 1002
    return (1);
  }
  switch_default: /* CIL Label */ 
#line 1004
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1006
  printf((char const   */* __restrict  */)"[%dgt%d?]", (unsigned int )t1, (unsigned int )t2);
  }
#line 1007
  return (0);
}
}
#line 1011 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.c"
__inline static struct expr *expr_get_leftmost_symbol(struct expr  const  *e ) 
{ 
  struct expr *tmp ;

  {
#line 1015
  if ((unsigned long )e == (unsigned long )((void *)0)) {
#line 1016
    return ((struct expr *)((void *)0));
  }
  {
#line 1018
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1018
    if (! ((unsigned int const   )e->type != 7U)) {
#line 1018
      goto while_break;
    }
#line 1019
    e = (struct expr  const  *)e->left.expr;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1021
  tmp = expr_copy(e);
  }
#line 1021
  return (tmp);
}
}
#line 1028 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.c"
struct expr *expr_simplify_unmet_dep(struct expr *e1 , struct expr *e2 ) 
{ 
  struct expr *ret ;
  struct expr *tmp ;
  struct expr *tmp___0 ;
  struct expr *tmp___1 ;
  struct expr *e ;
  struct expr *tmp___2 ;
  struct expr *tmp___3 ;
  int tmp___5 ;
  struct expr *tmp___6 ;

  {
  {
#line 1033
  if ((unsigned int )e1->type == 1U) {
#line 1033
    goto case_1;
  }
#line 1037
  if ((unsigned int )e1->type == 2U) {
#line 1037
    goto case_2;
  }
#line 1045
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 1034
  tmp = expr_simplify_unmet_dep(e1->right.expr, e2);
#line 1034
  tmp___0 = expr_simplify_unmet_dep(e1->left.expr, e2);
#line 1034
  tmp___1 = expr_alloc_and(tmp___0, tmp);
  }
#line 1034
  return (tmp___1);
  case_2: /* CIL Label */ 
  {
#line 1039
  tmp___2 = expr_copy((struct expr  const  *)e2);
#line 1039
  tmp___3 = expr_copy((struct expr  const  *)e1);
#line 1039
  e = expr_alloc_and(tmp___3, tmp___2);
#line 1040
  e = expr_eliminate_dups(e);
#line 1041
  tmp___5 = expr_eq(e, e1);
  }
#line 1041
  if (tmp___5) {
#line 1041
    ret = (struct expr *)((void *)0);
  } else {
#line 1041
    ret = e1;
  }
  {
#line 1042
  expr_free(e);
  }
#line 1043
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1046
  ret = e1;
#line 1047
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1050
  tmp___6 = expr_get_leftmost_symbol((struct expr  const  *)ret);
  }
#line 1050
  return (tmp___6);
}
}
#line 1053 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.c"
void expr_print(struct expr *e , void (*fn)(void * , struct symbol * , char const   * ) ,
                void *data , int prevtoken ) 
{ 
  int tmp ;
  char buf[32] ;
  int tmp___0 ;

  {
#line 1055
  if (! e) {
    {
#line 1056
    (*fn)(data, (struct symbol *)((void *)0), "y");
    }
#line 1057
    return;
  }
  {
#line 1060
  tmp = expr_compare_type((enum expr_type )prevtoken, e->type);
  }
#line 1060
  if (tmp > 0) {
    {
#line 1061
    (*fn)(data, (struct symbol *)((void *)0), "(");
    }
  }
  {
#line 1063
  if ((unsigned int )e->type == 7U) {
#line 1063
    goto case_7;
  }
#line 1069
  if ((unsigned int )e->type == 3U) {
#line 1069
    goto case_3;
  }
#line 1073
  if ((unsigned int )e->type == 4U) {
#line 1073
    goto case_4;
  }
#line 1081
  if ((unsigned int )e->type == 5U) {
#line 1081
    goto case_5;
  }
#line 1089
  if ((unsigned int )e->type == 1U) {
#line 1089
    goto case_1;
  }
#line 1094
  if ((unsigned int )e->type == 2U) {
#line 1094
    goto case_2;
  }
#line 1099
  if ((unsigned int )e->type == 6U) {
#line 1099
    goto case_6;
  }
#line 1106
  if ((unsigned int )e->type == 8U) {
#line 1106
    goto case_8;
  }
#line 1113
  goto switch_default;
  case_7: /* CIL Label */ 
#line 1064
  if ((e->left.sym)->name) {
    {
#line 1065
    (*fn)(data, e->left.sym, (char const   *)(e->left.sym)->name);
    }
  } else {
    {
#line 1067
    (*fn)(data, (struct symbol *)((void *)0), "<choice>");
    }
  }
#line 1068
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1070
  (*fn)(data, (struct symbol *)((void *)0), "!");
#line 1071
  expr_print(e->left.expr, fn, data, 3);
  }
#line 1072
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1074
  if ((e->left.sym)->name) {
    {
#line 1075
    (*fn)(data, e->left.sym, (char const   *)(e->left.sym)->name);
    }
  } else {
    {
#line 1077
    (*fn)(data, (struct symbol *)((void *)0), "<choice>");
    }
  }
  {
#line 1078
  (*fn)(data, (struct symbol *)((void *)0), "=");
#line 1079
  (*fn)(data, e->right.sym, (char const   *)(e->right.sym)->name);
  }
#line 1080
  goto switch_break;
  case_5: /* CIL Label */ 
#line 1082
  if ((e->left.sym)->name) {
    {
#line 1083
    (*fn)(data, e->left.sym, (char const   *)(e->left.sym)->name);
    }
  } else {
    {
#line 1085
    (*fn)(data, (struct symbol *)((void *)0), "<choice>");
    }
  }
  {
#line 1086
  (*fn)(data, (struct symbol *)((void *)0), "!=");
#line 1087
  (*fn)(data, e->right.sym, (char const   *)(e->right.sym)->name);
  }
#line 1088
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1090
  expr_print(e->left.expr, fn, data, 1);
#line 1091
  (*fn)(data, (struct symbol *)((void *)0), " || ");
#line 1092
  expr_print(e->right.expr, fn, data, 1);
  }
#line 1093
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1095
  expr_print(e->left.expr, fn, data, 2);
#line 1096
  (*fn)(data, (struct symbol *)((void *)0), " && ");
#line 1097
  expr_print(e->right.expr, fn, data, 2);
  }
#line 1098
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 1100
  (*fn)(data, e->right.sym, (char const   *)(e->right.sym)->name);
  }
#line 1101
  if (e->left.expr) {
    {
#line 1102
    (*fn)(data, (struct symbol *)((void *)0), " ^ ");
#line 1103
    expr_print(e->left.expr, fn, data, 6);
    }
  }
#line 1105
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 1107
  (*fn)(data, (struct symbol *)((void *)0), "[");
#line 1108
  (*fn)(data, e->left.sym, (char const   *)(e->left.sym)->name);
#line 1109
  (*fn)(data, (struct symbol *)((void *)0), " ");
#line 1110
  (*fn)(data, e->right.sym, (char const   *)(e->right.sym)->name);
#line 1111
  (*fn)(data, (struct symbol *)((void *)0), "]");
  }
#line 1112
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1116
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"<unknown type %d>",
          (unsigned int )e->type);
#line 1117
  (*fn)(data, (struct symbol *)((void *)0), (char const   *)(buf));
  }
#line 1118
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1121
  tmp___0 = expr_compare_type((enum expr_type )prevtoken, e->type);
  }
#line 1121
  if (tmp___0 > 0) {
    {
#line 1122
    (*fn)(data, (struct symbol *)((void *)0), ")");
    }
  }
#line 1123
  return;
}
}
#line 1125 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.c"
static void expr_print_file_helper(void *data , struct symbol *sym , char const   *str ) 
{ 
  size_t tmp ;

  {
  {
#line 1127
  tmp = strlen(str);
#line 1127
  xfwrite((void const   *)str, tmp, (size_t )1, (FILE *)data);
  }
#line 1128
  return;
}
}
#line 1130 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.c"
void expr_fprint(struct expr *e , FILE *out ) 
{ 


  {
  {
#line 1132
  expr_print(e, & expr_print_file_helper, (void *)out, 0);
  }
#line 1133
  return;
}
}
#line 1135 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.c"
static void expr_print_gstr_helper(void *data , struct symbol *sym , char const   *str ) 
{ 
  struct gstr *gs ;
  char const   *sym_str ;
  unsigned int extra_length ;
  size_t tmp ;
  char const   *last_cr ;
  char *tmp___0 ;
  unsigned int last_line_length ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 1137
  gs = (struct gstr *)data;
#line 1138
  sym_str = (char const   *)((void *)0);
#line 1140
  if (sym) {
    {
#line 1141
    sym_str = sym_get_string_value(sym);
    }
  }
#line 1143
  if (gs->max_width) {
    {
#line 1144
    tmp = strlen(str);
#line 1144
    extra_length = (unsigned int )tmp;
#line 1145
    tmp___0 = strrchr((char const   *)gs->s, '\n');
#line 1145
    last_cr = (char const   *)tmp___0;
    }
#line 1148
    if (sym_str) {
      {
#line 1149
      tmp___1 = strlen(sym_str);
#line 1149
      extra_length = (unsigned int )((size_t )extra_length + (4UL + tmp___1));
      }
    }
#line 1151
    if (! last_cr) {
#line 1152
      last_cr = (char const   *)gs->s;
    }
    {
#line 1154
    tmp___2 = strlen((char const   *)gs->s);
#line 1154
    last_line_length = (unsigned int )(tmp___2 - (size_t )(last_cr - (char const   *)gs->s));
    }
#line 1156
    if (last_line_length + extra_length > (unsigned int )gs->max_width) {
      {
#line 1157
      str_append(gs, "\\\n");
      }
    }
  }
  {
#line 1160
  str_append(gs, str);
  }
#line 1161
  if (sym) {
#line 1161
    if ((unsigned int )sym->type != 0U) {
      {
#line 1162
      str_printf(gs, " [=%s]", sym_str);
      }
    }
  }
#line 1163
  return;
}
}
#line 1165 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/expr.c"
void expr_gstr_print(struct expr *e , struct gstr *gs ) 
{ 


  {
  {
#line 1167
  expr_print(e, & expr_print_gstr_helper, (void *)gs, 0);
  }
#line 1168
  return;
}
}
#line 573 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 577
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 585
extern void regfree(regex_t *__preg ) ;
#line 81 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) uname)(struct utsname *__name ) ;
#line 14 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
struct symbol symbol_yes  = 
#line 14 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
     {(struct symbol *)0, (char *)"y", 0U, {(void *)"y", (tristate )2}, {{(void *)0,
                                                                        0U}, {(void *)0,
                                                                              0U},
                                                                       {(void *)0,
                                                                        0U}, {(void *)0,
                                                                              0U}},
    0U, 129, (struct property *)0, {(struct expr *)0, 0U}, {(struct expr *)0, 0U}};
#line 14 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
struct symbol symbol_mod  = 
#line 14
     {(struct symbol *)0, (char *)"m", 0U, {(void *)"m", (tristate )1}, {{(void *)0,
                                                                        0U}, {(void *)0,
                                                                              0U},
                                                                       {(void *)0,
                                                                        0U}, {(void *)0,
                                                                              0U}},
    0U, 129, (struct property *)0, {(struct expr *)0, 0U}, {(struct expr *)0, 0U}};
#line 14 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
struct symbol symbol_no  = 
#line 14
     {(struct symbol *)0, (char *)"n", 0U, {(void *)"n", (tristate )0}, {{(void *)0,
                                                                        0U}, {(void *)0,
                                                                              0U},
                                                                       {(void *)0,
                                                                        0U}, {(void *)0,
                                                                              0U}},
    0U, 129, (struct property *)0, {(struct expr *)0, 0U}, {(struct expr *)0, 0U}};
#line 14 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
struct symbol symbol_empty  = 
#line 14
     {(struct symbol *)0, (char *)"", 0U, {(void *)"", (tristate )0}, {{(void *)0, 0U},
                                                                     {(void *)0, 0U},
                                                                     {(void *)0, 0U},
                                                                     {(void *)0, 0U}},
    0U, 128, (struct property *)0, {(struct expr *)0, 0U}, {(struct expr *)0, 0U}};
#line 34 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
tristate modules_val  ;
#line 38 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
static void sym_add_default(struct symbol *sym , char const   *def ) 
{ 
  struct property *prop ;
  struct property *tmp ;
  struct symbol *tmp___0 ;

  {
  {
#line 40
  tmp = prop_alloc((enum prop_type )4, sym);
#line 40
  prop = tmp;
#line 42
  tmp___0 = sym_lookup(def, 1);
#line 42
  prop->expr = expr_alloc_symbol(tmp___0);
  }
#line 43
  return;
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
static _Bool inited  =    (_Bool)0;
#line 45 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
void sym_init(void) 
{ 
  struct symbol *sym ;
  struct utsname uts ;

  {
#line 51
  if (inited) {
#line 52
    return;
  }
  {
#line 53
  inited = (_Bool)1;
#line 55
  uname(& uts);
#line 57
  sym = sym_lookup("UNAME_RELEASE", 0);
#line 58
  sym->type = (enum symbol_type )5;
#line 59
  sym->flags |= 4096;
#line 60
  sym_add_default(sym, (char const   *)(uts.release));
  }
#line 61
  return;
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
enum symbol_type sym_get_type(struct symbol *sym ) 
{ 
  enum symbol_type type ;
  _Bool tmp ;

  {
#line 65
  type = sym->type;
#line 67
  if ((unsigned int )type == 2U) {
    {
#line 68
    tmp = sym_is_choice_value(sym);
    }
#line 68
    if (tmp) {
#line 68
      if ((unsigned int )sym->visible == 2U) {
#line 69
        type = (enum symbol_type )1;
      } else {
#line 68
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 70
    if ((unsigned int )modules_val == 0U) {
#line 71
      type = (enum symbol_type )1;
    }
  }
#line 73
  return (type);
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
char const   *sym_type_name(enum symbol_type type ) 
{ 


  {
  {
#line 79
  if ((unsigned int )type == 1U) {
#line 79
    goto case_1;
  }
#line 81
  if ((unsigned int )type == 2U) {
#line 81
    goto case_2;
  }
#line 83
  if ((unsigned int )type == 3U) {
#line 83
    goto case_3;
  }
#line 85
  if ((unsigned int )type == 4U) {
#line 85
    goto case_4;
  }
#line 87
  if ((unsigned int )type == 5U) {
#line 87
    goto case_5;
  }
#line 89
  if ((unsigned int )type == 0U) {
#line 89
    goto case_0;
  }
#line 91
  if ((unsigned int )type == 6U) {
#line 91
    goto case_6;
  }
#line 78
  goto switch_break;
  case_1: /* CIL Label */ 
#line 80
  return ("boolean");
  case_2: /* CIL Label */ 
#line 82
  return ("tristate");
  case_3: /* CIL Label */ 
#line 84
  return ("integer");
  case_4: /* CIL Label */ 
#line 86
  return ("hex");
  case_5: /* CIL Label */ 
#line 88
  return ("string");
  case_0: /* CIL Label */ 
#line 90
  return ("unknown");
  case_6: /* CIL Label */ 
#line 92
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 94
  return ("???");
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
struct property *sym_get_choice_prop(struct symbol *sym ) 
{ 
  struct property *prop ;

  {
#line 101
  prop = sym->prop;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! prop) {
#line 101
      goto while_break;
    }
#line 101
    if ((unsigned int )prop->type == 5U) {
#line 102
      return (prop);
    }
#line 101
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  return ((struct property *)((void *)0));
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
struct property *sym_get_env_prop(struct symbol *sym ) 
{ 
  struct property *prop ;

  {
#line 110
  prop = sym->prop;
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (! prop) {
#line 110
      goto while_break;
    }
#line 110
    if ((unsigned int )prop->type == 8U) {
#line 111
      return (prop);
    }
#line 110
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  return ((struct property *)((void *)0));
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
struct property *sym_get_default_prop(struct symbol *sym ) 
{ 
  struct property *prop ;

  {
#line 119
  prop = sym->prop;
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 119
    if (! prop) {
#line 119
      goto while_break;
    }
#line 119
    if ((unsigned int )prop->type == 4U) {
      {
#line 120
      prop->visible.tri = expr_calc_value(prop->visible.expr);
      }
#line 121
      if ((unsigned int )prop->visible.tri != 0U) {
#line 122
        return (prop);
      }
    }
#line 119
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 124
  return ((struct property *)((void *)0));
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
static struct property *sym_get_range_prop(struct symbol *sym ) 
{ 
  struct property *prop ;

  {
#line 131
  prop = sym->prop;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! prop) {
#line 131
      goto while_break;
    }
#line 131
    if ((unsigned int )prop->type == 7U) {
      {
#line 132
      prop->visible.tri = expr_calc_value(prop->visible.expr);
      }
#line 133
      if ((unsigned int )prop->visible.tri != 0U) {
#line 134
        return (prop);
      }
    }
#line 131
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 136
  return ((struct property *)((void *)0));
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
static long long sym_get_range_val(struct symbol *sym , int base ) 
{ 
  long long tmp ;

  {
  {
#line 141
  sym_calc_value(sym);
  }
  {
#line 143
  if ((unsigned int )sym->type == 3U) {
#line 143
    goto case_3;
  }
#line 146
  if ((unsigned int )sym->type == 4U) {
#line 146
    goto case_4;
  }
#line 149
  goto switch_default;
  case_3: /* CIL Label */ 
#line 144
  base = 10;
#line 145
  goto switch_break;
  case_4: /* CIL Label */ 
#line 147
  base = 16;
#line 148
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 150
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 152
  tmp = strtoll((char const   */* __restrict  */)sym->curr.val, (char **/* __restrict  */)((void *)0),
                base);
  }
#line 152
  return (tmp);
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
static void sym_validate_range(struct symbol *sym ) 
{ 
  struct property *prop ;
  int base ;
  long long val ;
  long long val2 ;
  char str[64] ;
  char *tmp ;

  {
  {
#line 163
  if ((unsigned int )sym->type == 3U) {
#line 163
    goto case_3;
  }
#line 166
  if ((unsigned int )sym->type == 4U) {
#line 166
    goto case_4;
  }
#line 169
  goto switch_default;
  case_3: /* CIL Label */ 
#line 164
  base = 10;
#line 165
  goto switch_break;
  case_4: /* CIL Label */ 
#line 167
  base = 16;
#line 168
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 170
  return;
  switch_break: /* CIL Label */ ;
  }
  {
#line 172
  prop = sym_get_range_prop(sym);
  }
#line 173
  if (! prop) {
#line 174
    return;
  }
  {
#line 175
  val = strtoll((char const   */* __restrict  */)sym->curr.val, (char **/* __restrict  */)((void *)0),
                base);
#line 176
  val2 = sym_get_range_val((prop->expr)->left.sym, base);
  }
#line 177
  if (val >= val2) {
    {
#line 178
    val2 = sym_get_range_val((prop->expr)->right.sym, base);
    }
#line 179
    if (val <= val2) {
#line 180
      return;
    }
  }
#line 182
  if ((unsigned int )sym->type == 3U) {
    {
#line 183
    sprintf((char */* __restrict  */)(str), (char const   */* __restrict  */)"%lld",
            val2);
    }
  } else {
    {
#line 185
    sprintf((char */* __restrict  */)(str), (char const   */* __restrict  */)"0x%llx",
            val2);
    }
  }
  {
#line 186
  tmp = strdup((char const   *)(str));
#line 186
  sym->curr.val = (void *)tmp;
  }
#line 187
  return;
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
static void sym_calc_visibility(struct symbol *sym ) 
{ 
  struct property *prop ;
  tristate tri ;
  _Bool tmp ;
  enum symbol_type tmp___0 ;

  {
#line 195
  tri = (tristate )0;
#line 196
  prop = sym->prop;
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 196
    if (! prop) {
#line 196
      goto while_break;
    }
#line 196
    if (prop->text) {
      {
#line 197
      prop->visible.tri = expr_calc_value(prop->visible.expr);
      }
#line 198
      if ((unsigned int )tri > (unsigned int )prop->visible.tri) {
#line 198
        tri = tri;
      } else {
#line 198
        tri = prop->visible.tri;
      }
    }
#line 196
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 200
  if ((unsigned int )tri == 1U) {
#line 200
    if ((unsigned int )sym->type != 2U) {
#line 201
      tri = (tristate )2;
    } else
#line 200
    if ((unsigned int )modules_val == 0U) {
#line 201
      tri = (tristate )2;
    }
  }
#line 202
  if ((unsigned int )sym->visible != (unsigned int )tri) {
    {
#line 203
    sym->visible = tri;
#line 204
    sym_set_changed(sym);
    }
  }
  {
#line 206
  tmp = sym_is_choice_value(sym);
  }
#line 206
  if (tmp) {
#line 207
    return;
  }
#line 209
  tri = (tristate )2;
#line 210
  if (sym->dir_dep.expr) {
    {
#line 211
    tri = expr_calc_value(sym->dir_dep.expr);
    }
  }
#line 212
  if ((unsigned int )tri == 1U) {
#line 213
    tri = (tristate )2;
  }
#line 214
  if ((unsigned int )sym->dir_dep.tri != (unsigned int )tri) {
    {
#line 215
    sym->dir_dep.tri = tri;
#line 216
    sym_set_changed(sym);
    }
  }
#line 218
  tri = (tristate )0;
#line 219
  if (sym->rev_dep.expr) {
    {
#line 220
    tri = expr_calc_value(sym->rev_dep.expr);
    }
  }
#line 221
  if ((unsigned int )tri == 1U) {
    {
#line 221
    tmp___0 = sym_get_type(sym);
    }
#line 221
    if ((unsigned int )tmp___0 == 1U) {
#line 222
      tri = (tristate )2;
    }
  }
#line 223
  if ((unsigned int )sym->rev_dep.tri != (unsigned int )tri) {
    {
#line 224
    sym->rev_dep.tri = tri;
#line 225
    sym_set_changed(sym);
    }
  }
#line 227
  return;
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
struct symbol *sym_choice_default(struct symbol *sym ) 
{ 
  struct symbol *def_sym ;
  struct property *prop ;
  struct expr *e ;

  {
#line 242
  prop = sym->prop;
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 242
    if (! prop) {
#line 242
      goto while_break;
    }
#line 242
    if ((unsigned int )prop->type == 4U) {
      {
#line 243
      prop->visible.tri = expr_calc_value(prop->visible.expr);
      }
#line 244
      if ((unsigned int )prop->visible.tri == 0U) {
#line 245
        goto __Cont;
      }
      {
#line 246
      def_sym = prop_get_symbol(prop);
      }
#line 247
      if ((unsigned int )def_sym->visible != 0U) {
#line 248
        return (def_sym);
      }
    }
    __Cont: /* CIL Label */ 
#line 242
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 252
  prop = sym_get_choice_prop(sym);
#line 253
  e = prop->expr;
  }
  {
#line 253
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 253
    if (e) {
#line 253
      def_sym = e->right.sym;
#line 253
      if (! def_sym) {
#line 253
        goto while_break___0;
      }
    } else {
#line 253
      goto while_break___0;
    }
#line 254
    if ((unsigned int )def_sym->visible != 0U) {
#line 255
      return (def_sym);
    }
#line 253
    e = e->left.expr;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 258
  return ((struct symbol *)((void *)0));
}
}
#line 261 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
static struct symbol *sym_calc_choice(struct symbol *sym ) 
{ 
  struct symbol *def_sym ;
  struct property *prop ;
  struct expr *e ;
  int flags ;

  {
  {
#line 269
  flags = sym->flags;
#line 270
  prop = sym_get_choice_prop(sym);
#line 271
  e = prop->expr;
  }
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
#line 271
    if (e) {
#line 271
      def_sym = e->right.sym;
#line 271
      if (! def_sym) {
#line 271
        goto while_break;
      }
    } else {
#line 271
      goto while_break;
    }
    {
#line 272
    sym_calc_visibility(def_sym);
    }
#line 273
    if ((unsigned int )def_sym->visible != 0U) {
#line 274
      flags &= def_sym->flags;
    }
#line 271
    e = e->left.expr;
  }
  while_break: /* CIL Label */ ;
  }
#line 277
  sym->flags &= flags | -65537;
#line 280
  def_sym = (struct symbol *)sym->def[0].val;
#line 281
  if (def_sym) {
#line 281
    if ((unsigned int )def_sym->visible != 0U) {
#line 282
      return (def_sym);
    }
  }
  {
#line 284
  def_sym = sym_choice_default(sym);
  }
#line 286
  if ((unsigned long )def_sym == (unsigned long )((void *)0)) {
#line 288
    sym->curr.tri = (tristate )0;
  }
#line 290
  return (def_sym);
}
}
#line 293 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
void sym_calc_value(struct symbol *sym ) 
{ 
  struct symbol_value newval ;
  struct symbol_value oldval ;
  struct property *prop ;
  struct expr *e ;
  struct symbol *tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  enum symbol_type tmp___2 ;
  struct symbol *tmp___4 ;
  _Bool tmp___5 ;
  tristate tmp___7 ;
  tristate tmp___8 ;
  _Bool tmp___9 ;
  struct expr *e___0 ;
  _Bool tmp___10 ;
  enum symbol_type tmp___11 ;
  _Bool tmp___12 ;
  struct symbol *ds ;
  struct symbol *tmp___13 ;
  struct symbol *tmp___14 ;
  _Bool tmp___15 ;
  int tmp___16 ;
  struct symbol *choice_sym ;
  _Bool tmp___17 ;

  {
#line 299
  if (! sym) {
#line 300
    return;
  }
#line 302
  if (sym->flags & 128) {
#line 303
    return;
  }
  {
#line 305
  tmp___0 = sym_is_choice_value(sym);
  }
#line 305
  if (tmp___0) {
#line 305
    if (sym->flags & 1048576) {
      {
#line 307
      sym->flags &= -1048577;
#line 308
      prop = sym_get_choice_prop(sym);
#line 309
      tmp = prop_get_symbol(prop);
#line 309
      sym_calc_value(tmp);
      }
    }
  }
#line 312
  sym->flags |= 128;
#line 314
  oldval = sym->curr;
  {
#line 319
  if ((unsigned int )sym->type == 5U) {
#line 319
    goto case_5;
  }
#line 319
  if ((unsigned int )sym->type == 4U) {
#line 319
    goto case_5;
  }
#line 319
  if ((unsigned int )sym->type == 3U) {
#line 319
    goto case_5;
  }
#line 323
  if ((unsigned int )sym->type == 2U) {
#line 323
    goto case_2;
  }
#line 323
  if ((unsigned int )sym->type == 1U) {
#line 323
    goto case_2;
  }
#line 326
  goto switch_default;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 320
  newval = symbol_empty.curr;
#line 321
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 324
  newval = symbol_no.curr;
#line 325
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 327
  sym->curr.val = (void *)sym->name;
#line 328
  sym->curr.tri = (tristate )0;
#line 329
  return;
  switch_break: /* CIL Label */ ;
  }
  {
#line 331
  tmp___1 = sym_is_choice_value(sym);
  }
#line 331
  if (! tmp___1) {
#line 332
    sym->flags &= -513;
  }
  {
#line 334
  sym_calc_visibility(sym);
#line 337
  sym->curr = newval;
#line 339
  tmp___2 = sym_get_type(sym);
  }
  {
#line 341
  if ((unsigned int )tmp___2 == 2U) {
#line 341
    goto case_2___0;
  }
#line 341
  if ((unsigned int )tmp___2 == 1U) {
#line 341
    goto case_2___0;
  }
#line 387
  if ((unsigned int )tmp___2 == 3U) {
#line 387
    goto case_3___0;
  }
#line 387
  if ((unsigned int )tmp___2 == 4U) {
#line 387
    goto case_3___0;
  }
#line 387
  if ((unsigned int )tmp___2 == 5U) {
#line 387
    goto case_3___0;
  }
#line 405
  goto switch_default___0;
  case_2___0: /* CIL Label */ 
  case_1___0: /* CIL Label */ 
  {
#line 342
  tmp___10 = sym_is_choice_value(sym);
  }
#line 342
  if (tmp___10) {
#line 342
    if ((unsigned int )sym->visible == 2U) {
      {
#line 343
      prop = sym_get_choice_prop(sym);
#line 344
      tmp___4 = prop_get_symbol(prop);
      }
#line 344
      if ((unsigned long )tmp___4->curr.val == (unsigned long )sym) {
#line 344
        newval.tri = (tristate )2;
      } else {
#line 344
        newval.tri = (tristate )0;
      }
    } else {
#line 342
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 346
    if ((unsigned int )sym->visible != 0U) {
      {
#line 350
      sym->flags |= 512;
#line 351
      tmp___5 = sym_has_value(sym);
      }
#line 351
      if (tmp___5) {
#line 352
        if ((unsigned int )sym->def[0].tri < (unsigned int )sym->visible) {
#line 352
          newval.tri = sym->def[0].tri;
        } else {
#line 352
          newval.tri = sym->visible;
        }
#line 354
        goto calc_newval;
      }
    }
#line 357
    if ((unsigned int )sym->rev_dep.tri != 0U) {
#line 358
      sym->flags |= 512;
    }
    {
#line 359
    tmp___9 = sym_is_choice(sym);
    }
#line 359
    if (! tmp___9) {
      {
#line 360
      prop = sym_get_default_prop(sym);
      }
#line 361
      if (prop) {
        {
#line 362
        sym->flags |= 512;
#line 363
        tmp___8 = expr_calc_value(prop->expr);
        }
#line 363
        if ((unsigned int )tmp___8 < (unsigned int )prop->visible.tri) {
          {
#line 363
          tmp___7 = expr_calc_value(prop->expr);
#line 363
          newval.tri = tmp___7;
          }
        } else {
#line 363
          newval.tri = prop->visible.tri;
        }
      }
    }
    calc_newval: 
#line 368
    if ((unsigned int )sym->dir_dep.tri == 0U) {
#line 368
      if ((unsigned int )sym->rev_dep.tri != 0U) {
        {
#line 370
        e___0 = expr_simplify_unmet_dep(sym->rev_dep.expr, sym->dir_dep.expr);
#line 372
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"warning: (");
#line 373
        expr_fprint(e___0, stderr);
#line 374
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)") selects %s which has unmet direct dependencies (",
                sym->name);
#line 376
        expr_fprint(sym->dir_dep.expr, stderr);
#line 377
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)")\n");
#line 378
        expr_free(e___0);
        }
      }
    }
#line 380
    if ((unsigned int )newval.tri > (unsigned int )sym->rev_dep.tri) {
#line 380
      newval.tri = newval.tri;
    } else {
#line 380
      newval.tri = sym->rev_dep.tri;
    }
  }
#line 382
  if ((unsigned int )newval.tri == 1U) {
    {
#line 382
    tmp___11 = sym_get_type(sym);
    }
#line 382
    if ((unsigned int )tmp___11 == 1U) {
#line 383
      newval.tri = (tristate )2;
    }
  }
#line 384
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
  case_4___0: /* CIL Label */ 
  case_5___0: /* CIL Label */ 
#line 388
  if ((unsigned int )sym->visible != 0U) {
    {
#line 389
    sym->flags |= 512;
#line 390
    tmp___12 = sym_has_value(sym);
    }
#line 390
    if (tmp___12) {
#line 391
      newval.val = sym->def[0].val;
#line 392
      goto switch_break___0;
    }
  }
  {
#line 395
  prop = sym_get_default_prop(sym);
  }
#line 396
  if (prop) {
    {
#line 397
    tmp___13 = prop_get_symbol(prop);
#line 397
    ds = tmp___13;
    }
#line 398
    if (ds) {
      {
#line 399
      sym->flags |= 512;
#line 400
      sym_calc_value(ds);
#line 401
      newval.val = ds->curr.val;
      }
    }
  }
#line 404
  goto switch_break___0;
  switch_default___0: /* CIL Label */ ;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 409
  sym->curr = newval;
#line 410
  tmp___15 = sym_is_choice(sym);
  }
#line 410
  if (tmp___15) {
#line 410
    if ((unsigned int )newval.tri == 2U) {
      {
#line 411
      tmp___14 = sym_calc_choice(sym);
#line 411
      sym->curr.val = (void *)tmp___14;
      }
    }
  }
  {
#line 412
  sym_validate_range(sym);
#line 414
  tmp___16 = memcmp((void const   *)(& oldval), (void const   *)(& sym->curr), sizeof(oldval));
  }
#line 414
  if (tmp___16) {
    {
#line 415
    sym_set_changed(sym);
    }
#line 416
    if ((unsigned long )modules_sym == (unsigned long )sym) {
      {
#line 417
      sym_set_all_changed();
#line 418
      modules_val = modules_sym->curr.tri;
      }
    }
  }
  {
#line 422
  tmp___17 = sym_is_choice(sym);
  }
#line 422
  if (tmp___17) {
    {
#line 425
    prop = sym_get_choice_prop(sym);
#line 426
    e = prop->expr;
    }
    {
#line 426
    while (1) {
      while_continue: /* CIL Label */ ;
#line 426
      if (e) {
#line 426
        choice_sym = e->right.sym;
#line 426
        if (! choice_sym) {
#line 426
          goto while_break;
        }
      } else {
#line 426
        goto while_break;
      }
#line 427
      if (sym->flags & 512) {
#line 427
        if ((unsigned int )choice_sym->visible != 0U) {
#line 429
          choice_sym->flags |= 512;
        }
      }
#line 430
      if (sym->flags & 1024) {
        {
#line 431
        sym_set_changed(choice_sym);
        }
      }
#line 426
      e = e->left.expr;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 435
  if (sym->flags & 4096) {
#line 436
    sym->flags &= -513;
  }
#line 438
  if (sym->flags & 1048576) {
    {
#line 439
    set_all_choice_values(sym);
    }
  }
#line 440
  return;
}
}
#line 442 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
void sym_clear_all_valid(void) 
{ 
  struct symbol *sym ;
  int i ;

  {
#line 447
  i = 0;
  {
#line 447
  while (1) {
    while_continue: /* CIL Label */ ;
#line 447
    if (! (i < 9973)) {
#line 447
      goto while_break;
    }
#line 447
    sym = symbol_hash[i];
    {
#line 447
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 447
      if (! sym) {
#line 447
        goto while_break___0;
      }
#line 447
      if ((unsigned int )sym->type != 6U) {
#line 448
        sym->flags &= -129;
      }
#line 447
      sym = sym->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 447
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 449
  sym_add_change_count(1);
  }
#line 450
  if (modules_sym) {
    {
#line 451
    sym_calc_value(modules_sym);
    }
  }
#line 452
  return;
}
}
#line 454 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
void sym_set_changed(struct symbol *sym ) 
{ 
  struct property *prop ;

  {
#line 458
  sym->flags |= 1024;
#line 459
  prop = sym->prop;
  {
#line 459
  while (1) {
    while_continue: /* CIL Label */ ;
#line 459
    if (! prop) {
#line 459
      goto while_break;
    }
#line 460
    if (prop->menu) {
#line 461
      (prop->menu)->flags |= 1U;
    }
#line 459
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 463
  return;
}
}
#line 465 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
void sym_set_all_changed(void) 
{ 
  struct symbol *sym ;
  int i ;

  {
#line 470
  i = 0;
  {
#line 470
  while (1) {
    while_continue: /* CIL Label */ ;
#line 470
    if (! (i < 9973)) {
#line 470
      goto while_break;
    }
#line 470
    sym = symbol_hash[i];
    {
#line 470
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 470
      if (! sym) {
#line 470
        goto while_break___0;
      }
#line 470
      if ((unsigned int )sym->type != 6U) {
        {
#line 471
        sym_set_changed(sym);
        }
      }
#line 470
      sym = sym->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 470
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 472
  return;
}
}
#line 474 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
_Bool sym_tristate_within_range(struct symbol *sym , tristate val ) 
{ 
  int type ;
  enum symbol_type tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;

  {
  {
#line 476
  tmp = sym_get_type(sym);
#line 476
  type = (int )tmp;
  }
#line 478
  if ((unsigned int )sym->visible == 0U) {
#line 479
    return ((_Bool)0);
  }
#line 481
  if (type != 1) {
#line 481
    if (type != 2) {
#line 482
      return ((_Bool)0);
    }
  }
#line 484
  if (type == 1) {
#line 484
    if ((unsigned int )val == 1U) {
#line 485
      return ((_Bool)0);
    }
  }
#line 486
  if ((unsigned int )sym->visible <= (unsigned int )sym->rev_dep.tri) {
#line 487
    return ((_Bool)0);
  }
  {
#line 488
  tmp___0 = sym_is_choice_value(sym);
  }
#line 488
  if (tmp___0) {
#line 488
    if ((unsigned int )sym->visible == 2U) {
#line 489
      return ((_Bool )((unsigned int )val == 2U));
    }
  }
#line 490
  if ((unsigned int )val >= (unsigned int )sym->rev_dep.tri) {
#line 490
    if ((unsigned int )val <= (unsigned int )sym->visible) {
#line 490
      tmp___1 = 1;
    } else {
#line 490
      tmp___1 = 0;
    }
  } else {
#line 490
    tmp___1 = 0;
  }
#line 490
  return ((_Bool )tmp___1);
}
}
#line 493 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
_Bool sym_set_tristate_value(struct symbol *sym , tristate val ) 
{ 
  tristate oldval ;
  tristate tmp ;
  _Bool tmp___0 ;
  struct symbol *cs ;
  struct property *tmp___1 ;
  struct symbol *tmp___2 ;
  struct property *prop ;
  struct expr *e ;
  _Bool tmp___3 ;

  {
  {
#line 495
  tmp = sym_get_tristate_value(sym);
#line 495
  oldval = tmp;
  }
#line 497
  if ((unsigned int )oldval != (unsigned int )val) {
    {
#line 497
    tmp___0 = sym_tristate_within_range(sym, val);
    }
#line 497
    if (! tmp___0) {
#line 498
      return ((_Bool)0);
    }
  }
#line 500
  if (! (sym->flags & 65536)) {
    {
#line 501
    sym->flags |= 65536;
#line 502
    sym_set_changed(sym);
    }
  }
  {
#line 508
  tmp___3 = sym_is_choice_value(sym);
  }
#line 508
  if (tmp___3) {
#line 508
    if ((unsigned int )val == 2U) {
      {
#line 509
      tmp___1 = sym_get_choice_prop(sym);
#line 509
      tmp___2 = prop_get_symbol(tmp___1);
#line 509
      cs = tmp___2;
#line 513
      cs->def[0].val = (void *)sym;
#line 514
      cs->flags |= 65536;
#line 515
      prop = sym_get_choice_prop(cs);
#line 516
      e = prop->expr;
      }
      {
#line 516
      while (1) {
        while_continue: /* CIL Label */ ;
#line 516
        if (! e) {
#line 516
          goto while_break;
        }
#line 517
        if ((unsigned int )(e->right.sym)->visible != 0U) {
#line 518
          (e->right.sym)->flags |= 65536;
        }
#line 516
        e = e->left.expr;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 522
  sym->def[0].tri = val;
#line 523
  if ((unsigned int )oldval != (unsigned int )val) {
    {
#line 524
    sym_clear_all_valid();
    }
  }
#line 526
  return ((_Bool)1);
}
}
#line 529 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
tristate sym_toggle_tristate_value(struct symbol *sym ) 
{ 
  tristate oldval ;
  tristate newval ;
  _Bool tmp ;

  {
  {
#line 533
  newval = sym_get_tristate_value(sym);
#line 533
  oldval = newval;
  }
  {
#line 534
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 536
    if ((unsigned int )newval == 0U) {
#line 536
      goto case_0;
    }
#line 539
    if ((unsigned int )newval == 1U) {
#line 539
      goto case_1;
    }
#line 542
    if ((unsigned int )newval == 2U) {
#line 542
      goto case_2;
    }
#line 535
    goto switch_break;
    case_0: /* CIL Label */ 
#line 537
    newval = (tristate )1;
#line 538
    goto switch_break;
    case_1: /* CIL Label */ 
#line 540
    newval = (tristate )2;
#line 541
    goto switch_break;
    case_2: /* CIL Label */ 
#line 543
    newval = (tristate )0;
#line 544
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 546
    tmp = sym_set_tristate_value(sym, newval);
    }
#line 546
    if (tmp) {
#line 547
      goto while_break;
    }
#line 534
    if (! ((unsigned int )oldval != (unsigned int )newval)) {
#line 534
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 549
  return (newval);
}
}
#line 552 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
_Bool sym_string_valid(struct symbol *sym , char const   *str ) 
{ 
  signed char ch ;
  char const   *tmp ;
  char const   *tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  unsigned short const   **tmp___5 ;
  char const   *tmp___6 ;

  {
  {
#line 557
  if ((unsigned int )sym->type == 5U) {
#line 557
    goto case_5;
  }
#line 559
  if ((unsigned int )sym->type == 3U) {
#line 559
    goto case_3;
  }
#line 572
  if ((unsigned int )sym->type == 4U) {
#line 572
    goto case_4;
  }
#line 582
  if ((unsigned int )sym->type == 2U) {
#line 582
    goto case_2;
  }
#line 582
  if ((unsigned int )sym->type == 1U) {
#line 582
    goto case_2;
  }
#line 590
  goto switch_default;
  case_5: /* CIL Label */ 
#line 558
  return ((_Bool)1);
  case_3: /* CIL Label */ 
#line 560
  tmp = str;
#line 560
  str ++;
#line 560
  ch = (signed char )*tmp;
#line 561
  if ((int )ch == 45) {
#line 562
    tmp___0 = str;
#line 562
    str ++;
#line 562
    ch = (signed char )*tmp___0;
  }
  {
#line 563
  tmp___1 = __ctype_b_loc();
  }
#line 563
  if (! ((int const   )*(*tmp___1 + (int )ch) & 2048)) {
#line 564
    return ((_Bool)0);
  }
#line 565
  if ((int )ch == 48) {
#line 565
    if ((int const   )*str != 0) {
#line 566
      return ((_Bool)0);
    }
  }
  {
#line 567
  while (1) {
    while_continue: /* CIL Label */ ;
#line 567
    tmp___3 = str;
#line 567
    str ++;
#line 567
    ch = (signed char )*tmp___3;
#line 567
    if (! ch) {
#line 567
      goto while_break;
    }
    {
#line 568
    tmp___2 = __ctype_b_loc();
    }
#line 568
    if (! ((int const   )*(*tmp___2 + (int )ch) & 2048)) {
#line 569
      return ((_Bool)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 571
  return ((_Bool)1);
  case_4: /* CIL Label */ 
#line 573
  if ((int const   )*(str + 0) == 48) {
#line 573
    if ((int const   )*(str + 1) == 120) {
#line 574
      str += 2;
    } else
#line 573
    if ((int const   )*(str + 1) == 88) {
#line 574
      str += 2;
    }
  }
#line 575
  tmp___4 = str;
#line 575
  str ++;
#line 575
  ch = (signed char )*tmp___4;
  {
#line 576
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 577
    tmp___5 = __ctype_b_loc();
    }
#line 577
    if (! ((int const   )*(*tmp___5 + (int )ch) & 4096)) {
#line 578
      return ((_Bool)0);
    }
#line 576
    tmp___6 = str;
#line 576
    str ++;
#line 576
    ch = (signed char )*tmp___6;
#line 576
    if (! ch) {
#line 576
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 580
  return ((_Bool)1);
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 586
  if ((int const   )*(str + 0) == 78) {
#line 586
    goto case_78;
  }
#line 586
  if ((int const   )*(str + 0) == 110) {
#line 586
    goto case_78;
  }
#line 586
  if ((int const   )*(str + 0) == 77) {
#line 586
    goto case_78;
  }
#line 586
  if ((int const   )*(str + 0) == 109) {
#line 586
    goto case_78;
  }
#line 586
  if ((int const   )*(str + 0) == 89) {
#line 586
    goto case_78;
  }
#line 586
  if ((int const   )*(str + 0) == 121) {
#line 586
    goto case_78;
  }
#line 583
  goto switch_break___0;
  case_78: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_121: /* CIL Label */ 
#line 587
  return ((_Bool)1);
  switch_break___0: /* CIL Label */ ;
  }
#line 589
  return ((_Bool)0);
  switch_default: /* CIL Label */ 
#line 591
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 595 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
_Bool sym_string_within_range(struct symbol *sym , char const   *str ) 
{ 
  struct property *prop ;
  long long val ;
  _Bool tmp ;
  _Bool tmp___0 ;
  long long tmp___1 ;
  long long tmp___2 ;
  int tmp___3 ;
  _Bool tmp___4 ;
  long long tmp___5 ;
  long long tmp___6 ;
  int tmp___7 ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;
  _Bool tmp___10 ;

  {
  {
#line 601
  if ((unsigned int )sym->type == 5U) {
#line 601
    goto case_5;
  }
#line 603
  if ((unsigned int )sym->type == 3U) {
#line 603
    goto case_3;
  }
#line 612
  if ((unsigned int )sym->type == 4U) {
#line 612
    goto case_4;
  }
#line 622
  if ((unsigned int )sym->type == 2U) {
#line 622
    goto case_2;
  }
#line 622
  if ((unsigned int )sym->type == 1U) {
#line 622
    goto case_2;
  }
#line 632
  goto switch_default;
  case_5: /* CIL Label */ 
  {
#line 602
  tmp = sym_string_valid(sym, str);
  }
#line 602
  return (tmp);
  case_3: /* CIL Label */ 
  {
#line 604
  tmp___0 = sym_string_valid(sym, str);
  }
#line 604
  if (! tmp___0) {
#line 605
    return ((_Bool)0);
  }
  {
#line 606
  prop = sym_get_range_prop(sym);
  }
#line 607
  if (! prop) {
#line 608
    return ((_Bool)1);
  }
  {
#line 609
  val = strtoll((char const   */* __restrict  */)str, (char **/* __restrict  */)((void *)0),
                10);
#line 610
  tmp___1 = sym_get_range_val((prop->expr)->left.sym, 10);
  }
#line 610
  if (val >= tmp___1) {
    {
#line 610
    tmp___2 = sym_get_range_val((prop->expr)->right.sym, 10);
    }
#line 610
    if (val <= tmp___2) {
#line 610
      tmp___3 = 1;
    } else {
#line 610
      tmp___3 = 0;
    }
  } else {
#line 610
    tmp___3 = 0;
  }
#line 610
  return ((_Bool )tmp___3);
  case_4: /* CIL Label */ 
  {
#line 613
  tmp___4 = sym_string_valid(sym, str);
  }
#line 613
  if (! tmp___4) {
#line 614
    return ((_Bool)0);
  }
  {
#line 615
  prop = sym_get_range_prop(sym);
  }
#line 616
  if (! prop) {
#line 617
    return ((_Bool)1);
  }
  {
#line 618
  val = strtoll((char const   */* __restrict  */)str, (char **/* __restrict  */)((void *)0),
                16);
#line 619
  tmp___5 = sym_get_range_val((prop->expr)->left.sym, 16);
  }
#line 619
  if (val >= tmp___5) {
    {
#line 619
    tmp___6 = sym_get_range_val((prop->expr)->right.sym, 16);
    }
#line 619
    if (val <= tmp___6) {
#line 619
      tmp___7 = 1;
    } else {
#line 619
      tmp___7 = 0;
    }
  } else {
#line 619
    tmp___7 = 0;
  }
#line 619
  return ((_Bool )tmp___7);
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 624
  if ((int const   )*(str + 0) == 89) {
#line 624
    goto case_89;
  }
#line 624
  if ((int const   )*(str + 0) == 121) {
#line 624
    goto case_89;
  }
#line 626
  if ((int const   )*(str + 0) == 77) {
#line 626
    goto case_77;
  }
#line 626
  if ((int const   )*(str + 0) == 109) {
#line 626
    goto case_77;
  }
#line 628
  if ((int const   )*(str + 0) == 78) {
#line 628
    goto case_78;
  }
#line 628
  if ((int const   )*(str + 0) == 110) {
#line 628
    goto case_78;
  }
#line 623
  goto switch_break___0;
  case_89: /* CIL Label */ 
  case_121: /* CIL Label */ 
  {
#line 625
  tmp___8 = sym_tristate_within_range(sym, (tristate )2);
  }
#line 625
  return (tmp___8);
  case_77: /* CIL Label */ 
  case_109: /* CIL Label */ 
  {
#line 627
  tmp___9 = sym_tristate_within_range(sym, (tristate )1);
  }
#line 627
  return (tmp___9);
  case_78: /* CIL Label */ 
  case_110: /* CIL Label */ 
  {
#line 629
  tmp___10 = sym_tristate_within_range(sym, (tristate )0);
  }
#line 629
  return (tmp___10);
  switch_break___0: /* CIL Label */ ;
  }
#line 631
  return ((_Bool)0);
  switch_default: /* CIL Label */ 
#line 633
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 637 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
_Bool sym_set_string_value(struct symbol *sym , char const   *newval ) 
{ 
  char const   *oldval ;
  char *val ;
  int size ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;

  {
  {
#line 645
  if ((unsigned int )sym->type == 2U) {
#line 645
    goto case_2;
  }
#line 645
  if ((unsigned int )sym->type == 1U) {
#line 645
    goto case_2;
  }
#line 655
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 647
  if ((int const   )*(newval + 0) == 89) {
#line 647
    goto case_89;
  }
#line 647
  if ((int const   )*(newval + 0) == 121) {
#line 647
    goto case_89;
  }
#line 649
  if ((int const   )*(newval + 0) == 77) {
#line 649
    goto case_77;
  }
#line 649
  if ((int const   )*(newval + 0) == 109) {
#line 649
    goto case_77;
  }
#line 651
  if ((int const   )*(newval + 0) == 78) {
#line 651
    goto case_78;
  }
#line 651
  if ((int const   )*(newval + 0) == 110) {
#line 651
    goto case_78;
  }
#line 646
  goto switch_break___0;
  case_89: /* CIL Label */ 
  case_121: /* CIL Label */ 
  {
#line 648
  tmp = sym_set_tristate_value(sym, (tristate )2);
  }
#line 648
  return (tmp);
  case_77: /* CIL Label */ 
  case_109: /* CIL Label */ 
  {
#line 650
  tmp___0 = sym_set_tristate_value(sym, (tristate )1);
  }
#line 650
  return (tmp___0);
  case_78: /* CIL Label */ 
  case_110: /* CIL Label */ 
  {
#line 652
  tmp___1 = sym_set_tristate_value(sym, (tristate )0);
  }
#line 652
  return (tmp___1);
  switch_break___0: /* CIL Label */ ;
  }
#line 654
  return ((_Bool)0);
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
  {
#line 659
  tmp___2 = sym_string_within_range(sym, newval);
  }
#line 659
  if (! tmp___2) {
#line 660
    return ((_Bool)0);
  }
#line 662
  if (! (sym->flags & 65536)) {
    {
#line 663
    sym->flags |= 65536;
#line 664
    sym_set_changed(sym);
    }
  }
  {
#line 667
  oldval = (char const   *)sym->def[0].val;
#line 668
  tmp___3 = strlen(newval);
#line 668
  size = (int )(tmp___3 + 1UL);
  }
#line 669
  if ((unsigned int )sym->type == 4U) {
#line 669
    if ((int const   )*(newval + 0) != 48) {
#line 669
      goto _L___0;
    } else
#line 669
    if ((int const   )*(newval + 1) != 120) {
#line 669
      if ((int const   )*(newval + 1) != 88) {
        _L___0: /* CIL Label */ 
        {
#line 670
        size += 2;
#line 671
        tmp___4 = xmalloc((size_t )size);
#line 671
        val = (char *)tmp___4;
#line 671
        sym->def[0].val = (void *)val;
#line 672
        tmp___5 = val;
#line 672
        val ++;
#line 672
        *tmp___5 = (char )'0';
#line 673
        tmp___6 = val;
#line 673
        val ++;
#line 673
        *tmp___6 = (char )'x';
        }
      } else {
#line 669
        goto _L;
      }
    } else {
#line 669
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 674
  if (! oldval) {
    {
#line 675
    tmp___7 = xmalloc((size_t )size);
#line 675
    val = (char *)tmp___7;
#line 675
    sym->def[0].val = (void *)val;
    }
  } else {
    {
#line 674
    tmp___8 = strcmp(oldval, newval);
    }
#line 674
    if (tmp___8) {
      {
#line 675
      tmp___7 = xmalloc((size_t )size);
#line 675
      val = (char *)tmp___7;
#line 675
      sym->def[0].val = (void *)val;
      }
    } else {
#line 677
      return ((_Bool)1);
    }
  }
  {
#line 679
  strcpy((char */* __restrict  */)val, (char const   */* __restrict  */)newval);
#line 680
  free((void *)oldval);
#line 681
  sym_clear_all_valid();
  }
#line 683
  return ((_Bool)1);
}
}
#line 693 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
char const   *sym_get_string_default(struct symbol *sym ) 
{ 
  struct property *prop ;
  struct symbol *ds ;
  char const   *str ;
  tristate val ;
  tristate tmp___0 ;
  tristate tmp___1 ;
  _Bool tmp___2 ;

  {
  {
#line 700
  sym_calc_visibility(sym);
#line 701
  sym_calc_value(modules_sym);
#line 702
  val = symbol_no.curr.tri;
#line 703
  str = (char const   *)symbol_empty.curr.val;
#line 706
  prop = sym_get_default_prop(sym);
  }
#line 707
  if ((unsigned long )prop != (unsigned long )((void *)0)) {
    {
#line 710
    if ((unsigned int )sym->type == 2U) {
#line 710
      goto case_2;
    }
#line 710
    if ((unsigned int )sym->type == 1U) {
#line 710
      goto case_2;
    }
#line 714
    goto switch_default;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
    {
#line 712
    tmp___1 = expr_calc_value(prop->expr);
    }
#line 712
    if ((unsigned int )tmp___1 < (unsigned int )prop->visible.tri) {
      {
#line 712
      tmp___0 = expr_calc_value(prop->expr);
#line 712
      val = tmp___0;
      }
    } else {
#line 712
      val = prop->visible.tri;
    }
#line 713
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 720
    ds = prop_get_symbol(prop);
    }
#line 721
    if ((unsigned long )ds != (unsigned long )((void *)0)) {
      {
#line 722
      sym_calc_value(ds);
#line 723
      str = (char const   *)ds->curr.val;
      }
    }
    switch_break: /* CIL Label */ ;
    }
  }
#line 729
  if ((unsigned int )val > (unsigned int )sym->rev_dep.tri) {
#line 729
    val = val;
  } else {
#line 729
    val = sym->rev_dep.tri;
  }
#line 732
  if ((unsigned int )val == 1U) {
    {
#line 733
    tmp___2 = sym_is_choice_value(sym);
    }
#line 733
    if (! tmp___2) {
#line 733
      if ((unsigned int )modules_sym->curr.tri == 0U) {
#line 734
        val = (tristate )2;
      }
    }
  }
#line 737
  if ((unsigned int )sym->type == 1U) {
#line 737
    if ((unsigned int )val == 1U) {
#line 738
      val = (tristate )2;
    }
  }
  {
#line 742
  if ((unsigned int )sym->type == 2U) {
#line 742
    goto case_2___0;
  }
#line 742
  if ((unsigned int )sym->type == 1U) {
#line 742
    goto case_2___0;
  }
#line 749
  if ((unsigned int )sym->type == 4U) {
#line 749
    goto case_4;
  }
#line 749
  if ((unsigned int )sym->type == 3U) {
#line 749
    goto case_4;
  }
#line 751
  if ((unsigned int )sym->type == 5U) {
#line 751
    goto case_5;
  }
#line 754
  if ((unsigned int )sym->type == 0U) {
#line 754
    goto case_0___0;
  }
#line 754
  if ((unsigned int )sym->type == 6U) {
#line 754
    goto case_0___0;
  }
#line 740
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
  case_1___0: /* CIL Label */ 
  {
#line 744
  if ((unsigned int )val == 0U) {
#line 744
    goto case_0;
  }
#line 745
  if ((unsigned int )val == 1U) {
#line 745
    goto case_1___1;
  }
#line 746
  if ((unsigned int )val == 2U) {
#line 746
    goto case_2___1;
  }
#line 743
  goto switch_break___1;
  case_0: /* CIL Label */ 
#line 744
  return ("n");
  case_1___1: /* CIL Label */ 
#line 745
  return ("m");
  case_2___1: /* CIL Label */ 
#line 746
  return ("y");
  switch_break___1: /* CIL Label */ ;
  }
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 750
  return (str);
  case_5: /* CIL Label */ 
#line 752
  return (str);
  case_0___0: /* CIL Label */ 
  case_6: /* CIL Label */ 
#line 755
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 757
  return ("");
}
}
#line 760 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
char const   *sym_get_string_value(struct symbol *sym ) 
{ 
  tristate val ;
  char const   *tmp ;

  {
  {
#line 766
  if ((unsigned int )sym->type == 2U) {
#line 766
    goto case_2;
  }
#line 766
  if ((unsigned int )sym->type == 1U) {
#line 766
    goto case_2;
  }
#line 778
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 767
  val = sym_get_tristate_value(sym);
  }
  {
#line 769
  if ((unsigned int )val == 0U) {
#line 769
    goto case_0;
  }
#line 771
  if ((unsigned int )val == 1U) {
#line 771
    goto case_1___0;
  }
#line 774
  if ((unsigned int )val == 2U) {
#line 774
    goto case_2___0;
  }
#line 768
  goto switch_break___0;
  case_0: /* CIL Label */ 
#line 770
  return ("n");
  case_1___0: /* CIL Label */ 
  {
#line 772
  sym_calc_value(modules_sym);
  }
#line 773
  if ((unsigned int )modules_sym->curr.tri == 0U) {
#line 773
    tmp = "n";
  } else {
#line 773
    tmp = "m";
  }
#line 773
  return (tmp);
  case_2___0: /* CIL Label */ 
#line 775
  return ("y");
  switch_break___0: /* CIL Label */ ;
  }
#line 777
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 781
  return ((char const   *)sym->curr.val);
}
}
#line 784 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
_Bool sym_is_changable(struct symbol *sym ) 
{ 


  {
#line 786
  return ((_Bool )((unsigned int )sym->visible > (unsigned int )sym->rev_dep.tri));
}
}
#line 789 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
static unsigned int strhash___0(char const   *s ) 
{ 
  unsigned int hash ;

  {
#line 792
  hash = 2166136261U;
  {
#line 793
  while (1) {
    while_continue: /* CIL Label */ ;
#line 793
    if (! *s) {
#line 793
      goto while_break;
    }
#line 794
    hash = (hash ^ (unsigned int )*s) * 16777619U;
#line 793
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 795
  return (hash);
}
}
#line 798 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
struct symbol *sym_lookup(char const   *name , int flags ) 
{ 
  struct symbol *symbol ;
  char *new_name ;
  int hash ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 804
  if (name) {
#line 805
    if (*(name + 0)) {
#line 805
      if (! *(name + 1)) {
        {
#line 807
        if ((int const   )*(name + 0) == 121) {
#line 807
          goto case_121;
        }
#line 808
        if ((int const   )*(name + 0) == 109) {
#line 808
          goto case_109;
        }
#line 809
        if ((int const   )*(name + 0) == 110) {
#line 809
          goto case_110;
        }
#line 806
        goto switch_break;
        case_121: /* CIL Label */ 
#line 807
        return (& symbol_yes);
        case_109: /* CIL Label */ 
#line 808
        return (& symbol_mod);
        case_110: /* CIL Label */ 
#line 809
        return (& symbol_no);
        switch_break: /* CIL Label */ ;
        }
      }
    }
    {
#line 812
    tmp = strhash___0(name);
#line 812
    hash = (int )(tmp % 9973U);
#line 814
    symbol = symbol_hash[hash];
    }
    {
#line 814
    while (1) {
      while_continue: /* CIL Label */ ;
#line 814
      if (! symbol) {
#line 814
        goto while_break;
      }
#line 815
      if (symbol->name) {
        {
#line 815
        tmp___0 = strcmp((char const   *)symbol->name, name);
        }
#line 815
        if (! tmp___0) {
#line 815
          if (flags) {
#line 815
            tmp___1 = symbol->flags & flags;
          } else {
#line 815
            tmp___1 = ! (symbol->flags & 17);
          }
#line 815
          if (tmp___1) {
#line 819
            return (symbol);
          }
        }
      }
#line 814
      symbol = symbol->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 821
    new_name = strdup(name);
    }
  } else {
#line 823
    new_name = (char *)((void *)0);
#line 824
    hash = 0;
  }
  {
#line 827
  tmp___2 = xmalloc(sizeof(*symbol));
#line 827
  symbol = (struct symbol *)tmp___2;
#line 828
  memset((void *)symbol, 0, sizeof(*symbol));
#line 829
  symbol->name = new_name;
#line 830
  symbol->type = (enum symbol_type )0;
#line 831
  symbol->flags |= flags;
#line 833
  symbol->next = symbol_hash[hash];
#line 834
  symbol_hash[hash] = symbol;
  }
#line 836
  return (symbol);
}
}
#line 839 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
struct symbol *sym_find(char const   *name ) 
{ 
  struct symbol *symbol ;
  int hash ;
  unsigned int tmp ;
  int tmp___0 ;

  {
#line 841
  symbol = (struct symbol *)((void *)0);
#line 842
  hash = 0;
#line 844
  if (! name) {
#line 845
    return ((struct symbol *)((void *)0));
  }
#line 847
  if (*(name + 0)) {
#line 847
    if (! *(name + 1)) {
      {
#line 849
      if ((int const   )*(name + 0) == 121) {
#line 849
        goto case_121;
      }
#line 850
      if ((int const   )*(name + 0) == 109) {
#line 850
        goto case_109;
      }
#line 851
      if ((int const   )*(name + 0) == 110) {
#line 851
        goto case_110;
      }
#line 848
      goto switch_break;
      case_121: /* CIL Label */ 
#line 849
      return (& symbol_yes);
      case_109: /* CIL Label */ 
#line 850
      return (& symbol_mod);
      case_110: /* CIL Label */ 
#line 851
      return (& symbol_no);
      switch_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 854
  tmp = strhash___0(name);
#line 854
  hash = (int )(tmp % 9973U);
#line 856
  symbol = symbol_hash[hash];
  }
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (! symbol) {
#line 856
      goto while_break;
    }
#line 857
    if (symbol->name) {
      {
#line 857
      tmp___0 = strcmp((char const   *)symbol->name, name);
      }
#line 857
      if (! tmp___0) {
#line 857
        if (! (symbol->flags & 1)) {
#line 860
          goto while_break;
        }
      }
    }
#line 856
    symbol = symbol->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 863
  return (symbol);
}
}
#line 871 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
char const   *sym_expand_string_value(char const   *in ) 
{ 
  char const   *src ;
  char *res ;
  size_t reslen ;
  size_t tmp ;
  void *tmp___0 ;
  char *p ;
  char name[256] ;
  char const   *symval ;
  struct symbol *sym ;
  size_t newlen ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  unsigned short const   **tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  char *tmp___8 ;

  {
  {
#line 877
  tmp = strlen(in);
#line 877
  reslen = tmp + 1UL;
#line 878
  tmp___0 = xmalloc(reslen);
#line 878
  res = (char *)tmp___0;
#line 879
  *(res + 0) = (char )'\000';
  }
  {
#line 881
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 881
    tmp___8 = strchr(in, '$');
#line 881
    src = (char const   *)tmp___8;
    }
#line 881
    if (! src) {
#line 881
      goto while_break;
    }
    {
#line 883
    symval = "";
#line 887
    strncat((char */* __restrict  */)res, (char const   */* __restrict  */)in, (size_t )(src - in));
#line 888
    src ++;
#line 890
    p = name;
    }
    {
#line 891
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 891
      tmp___3 = __ctype_b_loc();
      }
#line 891
      if (! ((int const   )*(*tmp___3 + (int )*src) & 8)) {
#line 891
        if (! ((int const   )*src == 95)) {
#line 891
          goto while_break___0;
        }
      }
#line 892
      tmp___1 = p;
#line 892
      p ++;
#line 892
      tmp___2 = src;
#line 892
      src ++;
#line 892
      *tmp___1 = (char )*tmp___2;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 893
    *p = (char )'\000';
#line 895
    sym = sym_find((char const   *)(name));
    }
#line 896
    if ((unsigned long )sym != (unsigned long )((void *)0)) {
      {
#line 897
      sym_calc_value(sym);
#line 898
      symval = sym_get_string_value(sym);
      }
    }
    {
#line 901
    tmp___4 = strlen((char const   *)res);
#line 901
    tmp___5 = strlen(symval);
#line 901
    tmp___6 = strlen(src);
#line 901
    newlen = ((tmp___4 + tmp___5) + tmp___6) + 1UL;
    }
#line 902
    if (newlen > reslen) {
      {
#line 903
      reslen = newlen;
#line 904
      tmp___7 = realloc((void *)res, reslen);
#line 904
      res = (char *)tmp___7;
      }
    }
    {
#line 907
    strcat((char */* __restrict  */)res, (char const   */* __restrict  */)symval);
#line 908
    in = src;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 910
  strcat((char */* __restrict  */)res, (char const   */* __restrict  */)in);
  }
#line 912
  return ((char const   *)res);
}
}
#line 915 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
char const   *sym_escape_string_value(char const   *in ) 
{ 
  char const   *p ;
  size_t reslen ;
  char *res ;
  size_t l ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___2 ;

  {
  {
#line 922
  tmp = strlen(in);
#line 922
  tmp___0 = strlen("\"\"");
#line 922
  reslen = (tmp + tmp___0) + 1UL;
#line 924
  p = in;
  }
  {
#line 925
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 926
    l = strcspn(p, "\"\\");
#line 927
    p += l;
    }
#line 929
    if ((int const   )*(p + 0) == 0) {
#line 930
      goto while_break;
    }
#line 932
    reslen ++;
#line 933
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 936
  tmp___1 = xmalloc(reslen);
#line 936
  res = (char *)tmp___1;
#line 937
  *(res + 0) = (char )'\000';
#line 939
  strcat((char */* __restrict  */)res, (char const   */* __restrict  */)"\"");
#line 941
  p = in;
  }
  {
#line 942
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 943
    l = strcspn(p, "\"\\");
#line 944
    strncat((char */* __restrict  */)res, (char const   */* __restrict  */)p, l);
#line 945
    p += l;
    }
#line 947
    if ((int const   )*(p + 0) == 0) {
#line 948
      goto while_break___0;
    }
    {
#line 950
    strcat((char */* __restrict  */)res, (char const   */* __restrict  */)"\\");
#line 951
    tmp___2 = p;
#line 951
    p ++;
#line 951
    strncat((char */* __restrict  */)res, (char const   */* __restrict  */)tmp___2,
            (size_t )1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 954
  strcat((char */* __restrict  */)res, (char const   */* __restrict  */)"\"");
  }
#line 955
  return ((char const   *)res);
}
}
#line 967 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
static int sym_rel_comp(void const   *sym1 , void const   *sym2 ) 
{ 
  struct sym_match  const  *s1 ;
  struct sym_match  const  *s2 ;
  int exact1 ;
  int exact2 ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 969
  s1 = (struct sym_match  const  *)sym1;
#line 970
  s2 = (struct sym_match  const  *)sym2;
#line 982
  tmp = strlen((char const   *)(s1->sym)->name);
#line 982
  exact1 = (size_t )(s1->eo - s1->so) == tmp;
#line 983
  tmp___0 = strlen((char const   *)(s2->sym)->name);
#line 983
  exact2 = (size_t )(s2->eo - s2->so) == tmp___0;
  }
#line 984
  if (exact1) {
#line 984
    if (! exact2) {
#line 985
      return (-1);
    }
  }
#line 986
  if (! exact1) {
#line 986
    if (exact2) {
#line 987
      return (1);
    }
  }
  {
#line 990
  tmp___1 = strcmp((char const   *)(s1->sym)->name, (char const   *)(s2->sym)->name);
  }
#line 990
  return (tmp___1);
}
}
#line 993 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
struct symbol **sym_re_search(char const   *pattern ) 
{ 
  struct symbol *sym ;
  struct symbol **sym_arr ;
  struct sym_match *sym_match_arr ;
  int i ;
  int cnt ;
  int size ;
  regex_t re ;
  regmatch_t match[1] ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 995
  sym_arr = (struct symbol **)((void *)0);
#line 996
  sym_match_arr = (struct sym_match *)((void *)0);
#line 1001
  size = 0;
#line 1001
  cnt = size;
#line 1003
  tmp = strlen(pattern);
  }
#line 1003
  if (tmp == 0UL) {
#line 1004
    return ((struct symbol **)((void *)0));
  }
  {
#line 1005
  tmp___0 = regcomp((regex_t */* __restrict  */)(& re), (char const   */* __restrict  */)pattern,
                    1 | (1 << 1));
  }
#line 1005
  if (tmp___0) {
#line 1006
    return ((struct symbol **)((void *)0));
  }
#line 1008
  i = 0;
  {
#line 1008
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1008
    if (! (i < 9973)) {
#line 1008
      goto while_break;
    }
#line 1008
    sym = symbol_hash[i];
    {
#line 1008
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1008
      if (! sym) {
#line 1008
        goto while_break___0;
      }
#line 1008
      if ((unsigned int )sym->type != 6U) {
#line 1009
        if (sym->flags & 1) {
#line 1010
          goto __Cont;
        } else
#line 1009
        if (! sym->name) {
#line 1010
          goto __Cont;
        }
        {
#line 1011
        tmp___1 = regexec((regex_t const   */* __restrict  */)(& re), (char const   */* __restrict  */)sym->name,
                          (size_t )1, (regmatch_t */* __restrict  */)(match), 0);
        }
#line 1011
        if (tmp___1) {
#line 1012
          goto __Cont;
        }
#line 1013
        if (cnt >= size) {
          {
#line 1015
          size += 16;
#line 1016
          tmp___2 = realloc((void *)sym_match_arr, (unsigned long )size * sizeof(struct sym_match ));
          }
#line 1017
          if (! tmp___2) {
#line 1018
            goto sym_re_search_free;
          }
#line 1019
          sym_match_arr = (struct sym_match *)tmp___2;
        }
        {
#line 1021
        sym_calc_value(sym);
#line 1025
        (sym_match_arr + cnt)->so = (off_t )match[0].rm_so;
#line 1026
        (sym_match_arr + cnt)->eo = (off_t )match[0].rm_eo;
#line 1027
        tmp___3 = cnt;
#line 1027
        cnt ++;
#line 1027
        (sym_match_arr + tmp___3)->sym = sym;
        }
      }
      __Cont: /* CIL Label */ 
#line 1008
      sym = sym->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1008
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1029
  if (sym_match_arr) {
    {
#line 1030
    qsort((void *)sym_match_arr, (size_t )cnt, sizeof(struct sym_match ), & sym_rel_comp);
#line 1031
    tmp___4 = malloc((unsigned long )(cnt + 1) * sizeof(struct symbol ));
#line 1031
    sym_arr = (struct symbol **)tmp___4;
    }
#line 1032
    if (! sym_arr) {
#line 1033
      goto sym_re_search_free;
    }
#line 1034
    i = 0;
    {
#line 1034
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1034
      if (! (i < cnt)) {
#line 1034
        goto while_break___1;
      }
#line 1035
      *(sym_arr + i) = (sym_match_arr + i)->sym;
#line 1034
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1036
    *(sym_arr + cnt) = (struct symbol *)((void *)0);
  }
  sym_re_search_free: 
  {
#line 1040
  free((void *)sym_match_arr);
#line 1041
  regfree(& re);
  }
#line 1043
  return (sym_arr);
}
}
#line 1052 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
static struct dep_stack *check_top  ;
#line 1059 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
static void dep_stack_insert(struct dep_stack *stack , struct symbol *sym ) 
{ 


  {
  {
#line 1061
  memset((void *)stack, 0, sizeof(*stack));
  }
#line 1062
  if (check_top) {
#line 1063
    check_top->next = stack;
  }
#line 1064
  stack->prev = check_top;
#line 1065
  stack->sym = sym;
#line 1066
  check_top = stack;
#line 1067
  return;
}
}
#line 1069 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
static void dep_stack_remove(void) 
{ 


  {
#line 1071
  check_top = check_top->prev;
#line 1072
  if (check_top) {
#line 1073
    check_top->next = (struct dep_stack *)((void *)0);
  }
#line 1074
  return;
}
}
#line 1081 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
static void sym_check_print_recursive(struct symbol *last_sym ) 
{ 
  struct dep_stack *stack ;
  struct symbol *sym ;
  struct symbol *next_sym ;
  struct menu *menu ;
  struct property *prop ;
  struct dep_stack cv_stack ;
  struct property *tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  _Bool tmp___14 ;
  _Bool tmp___15 ;

  {
  {
#line 1085
  menu = (struct menu *)((void *)0);
#line 1089
  tmp___0 = sym_is_choice_value(last_sym);
  }
#line 1089
  if (tmp___0) {
    {
#line 1090
    dep_stack_insert(& cv_stack, last_sym);
#line 1091
    tmp = sym_get_choice_prop(last_sym);
#line 1091
    last_sym = prop_get_symbol(tmp);
    }
  }
#line 1094
  stack = check_top;
  {
#line 1094
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1094
    if (! ((unsigned long )stack != (unsigned long )((void *)0))) {
#line 1094
      goto while_break;
    }
#line 1095
    if ((unsigned long )stack->sym == (unsigned long )last_sym) {
#line 1096
      goto while_break;
    }
#line 1094
    stack = stack->prev;
  }
  while_break: /* CIL Label */ ;
  }
#line 1097
  if (! stack) {
    {
#line 1098
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unexpected recursive dependency error\n");
    }
#line 1099
    return;
  }
  {
#line 1102
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1102
    if (! stack) {
#line 1102
      goto while_break___0;
    }
#line 1103
    sym = stack->sym;
#line 1104
    if (stack->next) {
#line 1104
      next_sym = (stack->next)->sym;
    } else {
#line 1104
      next_sym = last_sym;
    }
#line 1105
    prop = stack->prop;
#line 1106
    if ((unsigned long )prop == (unsigned long )((void *)0)) {
#line 1107
      prop = (stack->sym)->prop;
    }
    {
#line 1110
    tmp___1 = sym_is_choice(sym);
    }
#line 1110
    if (tmp___1) {
#line 1110
      goto _L;
    } else {
      {
#line 1110
      tmp___2 = sym_is_choice_value(sym);
      }
#line 1110
      if (tmp___2) {
        _L: /* CIL Label */ 
#line 1111
        prop = sym->prop;
        {
#line 1111
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1111
          if (! prop) {
#line 1111
            goto while_break___1;
          }
#line 1112
          menu = prop->menu;
#line 1113
          if (prop->menu) {
#line 1114
            goto while_break___1;
          }
#line 1111
          prop = prop->next;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
#line 1117
    if ((unsigned long )stack->sym == (unsigned long )last_sym) {
      {
#line 1118
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d:error: recursive dependency detected!\n",
              (prop->file)->name, prop->lineno);
      }
    }
#line 1120
    if (stack->expr) {
#line 1121
      if (next_sym->name) {
#line 1121
        tmp___3 = (char const   *)next_sym->name;
      } else {
#line 1121
        tmp___3 = "<choice>";
      }
      {
#line 1121
      tmp___4 = prop_get_type_name(prop->type);
      }
#line 1121
      if (sym->name) {
#line 1121
        tmp___5 = (char const   *)sym->name;
      } else {
#line 1121
        tmp___5 = "<choice>";
      }
      {
#line 1121
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d:\tsymbol %s %s value contains %s\n",
              (prop->file)->name, prop->lineno, tmp___5, tmp___4, tmp___3);
      }
    } else
#line 1126
    if (stack->prop) {
#line 1127
      if (next_sym->name) {
#line 1127
        tmp___6 = (char const   *)next_sym->name;
      } else {
#line 1127
        tmp___6 = "<choice>";
      }
#line 1127
      if (sym->name) {
#line 1127
        tmp___7 = (char const   *)sym->name;
      } else {
#line 1127
        tmp___7 = "<choice>";
      }
      {
#line 1127
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d:\tsymbol %s depends on %s\n",
              (prop->file)->name, prop->lineno, tmp___7, tmp___6);
      }
    } else {
      {
#line 1131
      tmp___15 = sym_is_choice(sym);
      }
#line 1131
      if (tmp___15) {
#line 1132
        if (next_sym->name) {
#line 1132
          tmp___8 = (char const   *)next_sym->name;
        } else {
#line 1132
          tmp___8 = "<choice>";
        }
#line 1132
        if (sym->name) {
#line 1132
          tmp___9 = (char const   *)sym->name;
        } else {
#line 1132
          tmp___9 = "<choice>";
        }
        {
#line 1132
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d:\tchoice %s contains symbol %s\n",
                (menu->file)->name, menu->lineno, tmp___9, tmp___8);
        }
      } else {
        {
#line 1136
        tmp___14 = sym_is_choice_value(sym);
        }
#line 1136
        if (tmp___14) {
#line 1137
          if (next_sym->name) {
#line 1137
            tmp___10 = (char const   *)next_sym->name;
          } else {
#line 1137
            tmp___10 = "<choice>";
          }
#line 1137
          if (sym->name) {
#line 1137
            tmp___11 = (char const   *)sym->name;
          } else {
#line 1137
            tmp___11 = "<choice>";
          }
          {
#line 1137
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d:\tsymbol %s is part of choice %s\n",
                  (menu->file)->name, menu->lineno, tmp___11, tmp___10);
          }
        } else {
#line 1142
          if (next_sym->name) {
#line 1142
            tmp___12 = (char const   *)next_sym->name;
          } else {
#line 1142
            tmp___12 = "<choice>";
          }
#line 1142
          if (sym->name) {
#line 1142
            tmp___13 = (char const   *)sym->name;
          } else {
#line 1142
            tmp___13 = "<choice>";
          }
          {
#line 1142
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d:\tsymbol %s is selected by %s\n",
                  (prop->file)->name, prop->lineno, tmp___13, tmp___12);
          }
        }
      }
    }
#line 1102
    stack = stack->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1149
  if ((unsigned long )check_top == (unsigned long )(& cv_stack)) {
    {
#line 1150
    dep_stack_remove();
    }
  }
#line 1151
  return;
}
}
#line 1153 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
static struct symbol *sym_check_expr_deps(struct expr *e ) 
{ 
  struct symbol *sym ;
  struct symbol *tmp ;
  struct symbol *tmp___0 ;
  struct symbol *tmp___1 ;
  struct symbol *tmp___2 ;

  {
#line 1157
  if (! e) {
#line 1158
    return ((struct symbol *)((void *)0));
  }
  {
#line 1161
  if ((unsigned int )e->type == 2U) {
#line 1161
    goto case_2;
  }
#line 1161
  if ((unsigned int )e->type == 1U) {
#line 1161
    goto case_2;
  }
#line 1166
  if ((unsigned int )e->type == 3U) {
#line 1166
    goto case_3;
  }
#line 1169
  if ((unsigned int )e->type == 5U) {
#line 1169
    goto case_5;
  }
#line 1169
  if ((unsigned int )e->type == 4U) {
#line 1169
    goto case_5;
  }
#line 1174
  if ((unsigned int )e->type == 7U) {
#line 1174
    goto case_7;
  }
#line 1176
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 1162
  sym = sym_check_expr_deps(e->left.expr);
  }
#line 1163
  if (sym) {
#line 1164
    return (sym);
  }
  {
#line 1165
  tmp = sym_check_expr_deps(e->right.expr);
  }
#line 1165
  return (tmp);
  case_3: /* CIL Label */ 
  {
#line 1167
  tmp___0 = sym_check_expr_deps(e->left.expr);
  }
#line 1167
  return (tmp___0);
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  {
#line 1170
  sym = sym_check_deps(e->left.sym);
  }
#line 1171
  if (sym) {
#line 1172
    return (sym);
  }
  {
#line 1173
  tmp___1 = sym_check_deps(e->right.sym);
  }
#line 1173
  return (tmp___1);
  case_7: /* CIL Label */ 
  {
#line 1175
  tmp___2 = sym_check_deps(e->left.sym);
  }
#line 1175
  return (tmp___2);
  switch_default: /* CIL Label */ 
#line 1177
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1179
  printf((char const   */* __restrict  */)"Oops! How to check %d?\n", (unsigned int )e->type);
  }
#line 1180
  return ((struct symbol *)((void *)0));
}
}
#line 1184 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
static struct symbol *sym_check_sym_deps(struct symbol *sym ) 
{ 
  struct symbol *sym2 ;
  struct property *prop ;
  struct dep_stack stack ;
  _Bool tmp ;

  {
  {
#line 1190
  dep_stack_insert(& stack, sym);
#line 1192
  sym2 = sym_check_expr_deps(sym->rev_dep.expr);
  }
#line 1193
  if (sym2) {
#line 1194
    goto out;
  }
#line 1196
  prop = sym->prop;
  {
#line 1196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1196
    if (! prop) {
#line 1196
      goto while_break;
    }
#line 1197
    if ((unsigned int )prop->type == 5U) {
#line 1198
      goto __Cont;
    } else
#line 1197
    if ((unsigned int )prop->type == 6U) {
#line 1198
      goto __Cont;
    }
    {
#line 1199
    stack.prop = prop;
#line 1200
    sym2 = sym_check_expr_deps(prop->visible.expr);
    }
#line 1201
    if (sym2) {
#line 1202
      goto while_break;
    }
#line 1203
    if ((unsigned int )prop->type != 4U) {
#line 1204
      goto __Cont;
    } else {
      {
#line 1203
      tmp = sym_is_choice(sym);
      }
#line 1203
      if (tmp) {
#line 1204
        goto __Cont;
      }
    }
    {
#line 1205
    stack.expr = prop->expr;
#line 1206
    sym2 = sym_check_expr_deps(prop->expr);
    }
#line 1207
    if (sym2) {
#line 1208
      goto while_break;
    }
#line 1209
    stack.expr = (struct expr *)((void *)0);
    __Cont: /* CIL Label */ 
#line 1196
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
  out: 
  {
#line 1213
  dep_stack_remove();
  }
#line 1215
  return (sym2);
}
}
#line 1218 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
static struct symbol *sym_check_choice_deps(struct symbol *choice ) 
{ 
  struct symbol *sym ;
  struct symbol *sym2 ;
  struct property *prop ;
  struct expr *e ;
  struct dep_stack stack ;
  _Bool tmp ;
  struct property *tmp___0 ;
  struct symbol *tmp___1 ;

  {
  {
#line 1225
  dep_stack_insert(& stack, choice);
#line 1227
  prop = sym_get_choice_prop(choice);
#line 1228
  e = prop->expr;
  }
  {
#line 1228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1228
    if (e) {
#line 1228
      sym = e->right.sym;
#line 1228
      if (! sym) {
#line 1228
        goto while_break;
      }
    } else {
#line 1228
      goto while_break;
    }
#line 1229
    sym->flags |= 8200;
#line 1228
    e = e->left.expr;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1231
  choice->flags |= 8200;
#line 1232
  sym2 = sym_check_sym_deps(choice);
#line 1233
  choice->flags &= -9;
  }
#line 1234
  if (sym2) {
#line 1235
    goto out;
  }
#line 1237
  e = prop->expr;
  {
#line 1237
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1237
    if (e) {
#line 1237
      sym = e->right.sym;
#line 1237
      if (! sym) {
#line 1237
        goto while_break___0;
      }
    } else {
#line 1237
      goto while_break___0;
    }
    {
#line 1238
    sym2 = sym_check_sym_deps(sym);
    }
#line 1239
    if (sym2) {
#line 1240
      goto while_break___0;
    }
#line 1237
    e = e->left.expr;
  }
  while_break___0: /* CIL Label */ ;
  }
  out: 
#line 1243
  e = prop->expr;
  {
#line 1243
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1243
    if (e) {
#line 1243
      sym = e->right.sym;
#line 1243
      if (! sym) {
#line 1243
        goto while_break___1;
      }
    } else {
#line 1243
      goto while_break___1;
    }
#line 1244
    sym->flags &= -9;
#line 1243
    e = e->left.expr;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1246
  if (sym2) {
    {
#line 1246
    tmp = sym_is_choice_value(sym2);
    }
#line 1246
    if (tmp) {
      {
#line 1246
      tmp___0 = sym_get_choice_prop(sym2);
#line 1246
      tmp___1 = prop_get_symbol(tmp___0);
      }
#line 1246
      if ((unsigned long )tmp___1 == (unsigned long )choice) {
#line 1248
        sym2 = choice;
      }
    }
  }
  {
#line 1250
  dep_stack_remove();
  }
#line 1252
  return (sym2);
}
}
#line 1255 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
struct symbol *sym_check_deps(struct symbol *sym ) 
{ 
  struct symbol *sym2 ;
  struct property *prop ;
  struct dep_stack stack ;
  struct symbol *tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;

  {
#line 1260
  if (sym->flags & 8) {
    {
#line 1261
    sym_check_print_recursive(sym);
    }
#line 1262
    return (sym);
  }
#line 1264
  if (sym->flags & 8192) {
#line 1265
    return ((struct symbol *)((void *)0));
  }
  {
#line 1267
  tmp___1 = sym_is_choice_value(sym);
  }
#line 1267
  if (tmp___1) {
    {
#line 1271
    dep_stack_insert(& stack, sym);
#line 1272
    prop = sym_get_choice_prop(sym);
#line 1273
    tmp = prop_get_symbol(prop);
#line 1273
    sym2 = sym_check_deps(tmp);
#line 1274
    dep_stack_remove();
    }
  } else {
    {
#line 1275
    tmp___0 = sym_is_choice(sym);
    }
#line 1275
    if (tmp___0) {
      {
#line 1276
      sym2 = sym_check_choice_deps(sym);
      }
    } else {
      {
#line 1278
      sym->flags |= 8200;
#line 1279
      sym2 = sym_check_sym_deps(sym);
#line 1280
      sym->flags &= -9;
      }
    }
  }
#line 1283
  if (sym2) {
#line 1283
    if ((unsigned long )sym2 == (unsigned long )sym) {
#line 1284
      sym2 = (struct symbol *)((void *)0);
    }
  }
#line 1286
  return (sym2);
}
}
#line 1289 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
struct property *prop_alloc(enum prop_type type , struct symbol *sym ) 
{ 
  struct property *prop ;
  struct property **propp ;
  void *tmp ;

  {
  {
#line 1294
  tmp = xmalloc(sizeof(*prop));
#line 1294
  prop = (struct property *)tmp;
#line 1295
  memset((void *)prop, 0, sizeof(*prop));
#line 1296
  prop->type = type;
#line 1297
  prop->sym = sym;
#line 1298
  prop->file = current_file;
#line 1299
  prop->lineno = zconf_lineno();
  }
#line 1302
  if (sym) {
#line 1303
    propp = & sym->prop;
    {
#line 1303
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1303
      if (! *propp) {
#line 1303
        goto while_break;
      }
#line 1303
      propp = & (*propp)->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 1305
    *propp = prop;
  }
#line 1308
  return (prop);
}
}
#line 1311 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
struct symbol *prop_get_symbol(struct property *prop ) 
{ 


  {
#line 1313
  if (prop->expr) {
#line 1313
    if ((unsigned int )(prop->expr)->type == 7U) {
#line 1315
      return ((prop->expr)->left.sym);
    } else
#line 1313
    if ((unsigned int )(prop->expr)->type == 6U) {
#line 1315
      return ((prop->expr)->left.sym);
    }
  }
#line 1316
  return ((struct symbol *)((void *)0));
}
}
#line 1319 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
char const   *prop_get_type_name(enum prop_type type ) 
{ 


  {
  {
#line 1322
  if ((unsigned int )type == 1U) {
#line 1322
    goto case_1;
  }
#line 1324
  if ((unsigned int )type == 8U) {
#line 1324
    goto case_8;
  }
#line 1326
  if ((unsigned int )type == 2U) {
#line 1326
    goto case_2;
  }
#line 1328
  if ((unsigned int )type == 3U) {
#line 1328
    goto case_3;
  }
#line 1330
  if ((unsigned int )type == 4U) {
#line 1330
    goto case_4;
  }
#line 1332
  if ((unsigned int )type == 5U) {
#line 1332
    goto case_5;
  }
#line 1334
  if ((unsigned int )type == 6U) {
#line 1334
    goto case_6;
  }
#line 1336
  if ((unsigned int )type == 7U) {
#line 1336
    goto case_7;
  }
#line 1338
  if ((unsigned int )type == 9U) {
#line 1338
    goto case_9;
  }
#line 1340
  if ((unsigned int )type == 0U) {
#line 1340
    goto case_0;
  }
#line 1321
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1323
  return ("prompt");
  case_8: /* CIL Label */ 
#line 1325
  return ("env");
  case_2: /* CIL Label */ 
#line 1327
  return ("comment");
  case_3: /* CIL Label */ 
#line 1329
  return ("menu");
  case_4: /* CIL Label */ 
#line 1331
  return ("default");
  case_5: /* CIL Label */ 
#line 1333
  return ("choice");
  case_6: /* CIL Label */ 
#line 1335
  return ("select");
  case_7: /* CIL Label */ 
#line 1337
  return ("range");
  case_9: /* CIL Label */ 
#line 1339
  return ("symbol");
  case_0: /* CIL Label */ 
#line 1341
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1343
  return ("unknown");
}
}
#line 1346 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/symbol.c"
static void prop_add_env(char const   *env ) 
{ 
  struct symbol *sym ;
  struct symbol *sym2 ;
  struct property *prop ;
  char *p ;
  int tmp ;
  struct symbol *tmp___0 ;

  {
#line 1352
  sym = current_entry->sym;
#line 1353
  sym->flags |= 4096;
#line 1354
  prop = sym->prop;
  {
#line 1354
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1354
    if (! prop) {
#line 1354
      goto while_break;
    }
#line 1354
    if ((unsigned int )prop->type == 8U) {
      {
#line 1355
      sym2 = prop_get_symbol(prop);
#line 1356
      tmp = strcmp((char const   *)sym2->name, env);
      }
#line 1356
      if (tmp) {
        {
#line 1357
        menu_warn(current_entry, "redefining environment symbol from %s", sym2->name);
        }
      }
#line 1359
      return;
    }
#line 1354
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1362
  prop = prop_alloc((enum prop_type )8, sym);
#line 1363
  tmp___0 = sym_lookup(env, 1);
#line 1363
  prop->expr = expr_alloc_symbol(tmp___0);
#line 1365
  sym_env_list = expr_alloc_one((enum expr_type )6, sym_env_list);
#line 1366
  sym_env_list->right.sym = sym;
#line 1368
  p = getenv(env);
  }
#line 1369
  if (p) {
    {
#line 1370
    sym_add_default(sym, (char const   *)p);
    }
  } else {
    {
#line 1372
    menu_warn(current_entry, "environment variable %s undefined", env);
    }
  }
#line 1373
  return;
}
}
#line 13 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/menu.c"
static char const   nohelp_text[44]  = 
#line 13 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/menu.c"
  {      (char const   )'T',      (char const   )'h',      (char const   )'e',      (char const   )'r', 
        (char const   )'e',      (char const   )' ',      (char const   )'i',      (char const   )'s', 
        (char const   )' ',      (char const   )'n',      (char const   )'o',      (char const   )' ', 
        (char const   )'h',      (char const   )'e',      (char const   )'l',      (char const   )'p', 
        (char const   )' ',      (char const   )'a',      (char const   )'v',      (char const   )'a', 
        (char const   )'i',      (char const   )'l',      (char const   )'a',      (char const   )'b', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'f', 
        (char const   )'o',      (char const   )'r',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'i',      (char const   )'s',      (char const   )' ', 
        (char const   )'o',      (char const   )'p',      (char const   )'t',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )'.',      (char const   )'\000'};
#line 16 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/menu.c"
static struct menu **last_entry_ptr  ;
#line 21 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/menu.c"
void menu_warn(struct menu *menu , char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 24
  __builtin_va_start(ap, fmt);
#line 25
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d:warning: ",
          (menu->file)->name, menu->lineno);
#line 26
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           ap);
#line 27
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 28
  __builtin_va_end(ap);
  }
#line 29
  return;
}
}
#line 31 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/menu.c"
static void prop_warn(struct property *prop , char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 34
  __builtin_va_start(ap, fmt);
#line 35
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d:warning: ",
          (prop->file)->name, prop->lineno);
#line 36
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           ap);
#line 37
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 38
  __builtin_va_end(ap);
  }
#line 39
  return;
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/menu.c"
void _menu_init(void) 
{ 


  {
#line 43
  current_menu = & rootmenu;
#line 43
  current_entry = current_menu;
#line 44
  last_entry_ptr = & rootmenu.list;
#line 45
  return;
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/menu.c"
void menu_add_entry(struct symbol *sym ) 
{ 
  struct menu *menu ;
  void *tmp ;

  {
  {
#line 51
  tmp = xmalloc(sizeof(*menu));
#line 51
  menu = (struct menu *)tmp;
#line 52
  memset((void *)menu, 0, sizeof(*menu));
#line 53
  menu->sym = sym;
#line 54
  menu->parent = current_menu;
#line 55
  menu->file = current_file;
#line 56
  menu->lineno = zconf_lineno();
#line 58
  *last_entry_ptr = menu;
#line 59
  last_entry_ptr = & menu->next;
#line 60
  current_entry = menu;
  }
#line 61
  if (sym) {
    {
#line 62
    menu_add_symbol((enum prop_type )9, sym, (struct expr *)((void *)0));
    }
  }
#line 63
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/menu.c"
void menu_end_entry(void) 
{ 


  {
#line 67
  return;
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/menu.c"
struct menu *menu_add_menu(void) 
{ 


  {
  {
#line 71
  menu_end_entry();
#line 72
  last_entry_ptr = & current_entry->list;
#line 73
  current_menu = current_entry;
  }
#line 73
  return (current_menu);
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/menu.c"
void menu_end_menu(void) 
{ 


  {
#line 78
  last_entry_ptr = & current_menu->next;
#line 79
  current_menu = current_menu->parent;
#line 80
  return;
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/menu.c"
static struct expr *menu_check_dep(struct expr *e ) 
{ 
  struct expr *tmp ;
  struct expr *tmp___0 ;

  {
#line 84
  if (! e) {
#line 85
    return (e);
  }
  {
#line 88
  if ((unsigned int )e->type == 3U) {
#line 88
    goto case_3;
  }
#line 92
  if ((unsigned int )e->type == 2U) {
#line 92
    goto case_2;
  }
#line 92
  if ((unsigned int )e->type == 1U) {
#line 92
    goto case_2;
  }
#line 96
  if ((unsigned int )e->type == 7U) {
#line 96
    goto case_7;
  }
#line 101
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 89
  e->left.expr = menu_check_dep(e->left.expr);
  }
#line 90
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 93
  e->left.expr = menu_check_dep(e->left.expr);
#line 94
  e->right.expr = menu_check_dep(e->right.expr);
  }
#line 95
  goto switch_break;
  case_7: /* CIL Label */ 
#line 98
  if ((unsigned long )e->left.sym == (unsigned long )(& symbol_mod)) {
    {
#line 99
    tmp = expr_alloc_symbol(modules_sym);
#line 99
    tmp___0 = expr_alloc_and(e, tmp);
    }
#line 99
    return (tmp___0);
  }
#line 100
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 102
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 104
  return (e);
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/menu.c"
void menu_add_dep(struct expr *dep ) 
{ 
  struct expr *tmp ;

  {
  {
#line 109
  tmp = menu_check_dep(dep);
#line 109
  current_entry->dep = expr_alloc_and(current_entry->dep, tmp);
  }
#line 110
  return;
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/menu.c"
void menu_set_type(int type ) 
{ 
  struct symbol *sym ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 114
  sym = current_entry->sym;
#line 116
  if ((unsigned int )sym->type == (unsigned int )type) {
#line 117
    return;
  }
#line 118
  if ((unsigned int )sym->type == 0U) {
#line 119
    sym->type = (enum symbol_type )type;
#line 120
    return;
  }
  {
#line 122
  tmp = sym_type_name((enum symbol_type )type);
#line 122
  tmp___0 = sym_type_name(sym->type);
  }
#line 122
  if (sym->name) {
#line 122
    tmp___1 = (char const   *)sym->name;
  } else {
#line 122
    tmp___1 = "<choice>";
  }
  {
#line 122
  menu_warn(current_entry, "ignoring type redefinition of \'%s\' from \'%s\' to \'%s\'",
            tmp___1, tmp___0, tmp);
  }
#line 126
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/menu.c"
struct property *menu_add_prop(enum prop_type type , char *prompt , struct expr *expr ,
                               struct expr *dep ) 
{ 
  struct property *prop ;
  struct property *tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  struct menu *menu ;
  struct expr *dup_expr ;

  {
  {
#line 130
  tmp = prop_alloc(type, current_entry->sym);
#line 130
  prop = tmp;
#line 132
  prop->menu = current_entry;
#line 133
  prop->expr = expr;
#line 134
  prop->visible.expr = menu_check_dep(dep);
  }
#line 136
  if (prompt) {
    {
#line 137
    tmp___1 = __ctype_b_loc();
    }
#line 137
    if ((int const   )*(*tmp___1 + (int )*prompt) & 8192) {
      {
#line 138
      prop_warn(prop, "leading whitespace ignored");
      }
      {
#line 139
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 139
        tmp___0 = __ctype_b_loc();
        }
#line 139
        if (! ((int const   )*(*tmp___0 + (int )*prompt) & 8192)) {
#line 139
          goto while_break;
        }
#line 140
        prompt ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 142
    if (current_entry->prompt) {
#line 142
      if ((unsigned long )current_entry != (unsigned long )(& rootmenu)) {
        {
#line 143
        prop_warn(prop, "prompt redefined");
        }
      }
    }
#line 146
    if ((unsigned int )type == 1U) {
#line 147
      menu = current_entry;
      {
#line 149
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 149
        menu = menu->parent;
#line 149
        if (! ((unsigned long )menu != (unsigned long )((void *)0))) {
#line 149
          goto while_break___0;
        }
#line 152
        if (! menu->visibility) {
#line 153
          goto while_continue___0;
        }
        {
#line 163
        dup_expr = expr_copy((struct expr  const  *)menu->visibility);
#line 165
        prop->visible.expr = expr_alloc_and(prop->visible.expr, dup_expr);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 171
    current_entry->prompt = prop;
  }
#line 173
  prop->text = (char const   *)prompt;
#line 175
  return (prop);
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/menu.c"
struct property *menu_add_prompt(enum prop_type type , char *prompt , struct expr *dep ) 
{ 
  struct property *tmp ;

  {
  {
#line 180
  tmp = menu_add_prop(type, prompt, (struct expr *)((void *)0), dep);
  }
#line 180
  return (tmp);
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/menu.c"
void menu_add_visibility(struct expr *expr ) 
{ 


  {
  {
#line 185
  current_entry->visibility = expr_alloc_and(current_entry->visibility, expr);
  }
#line 187
  return;
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/menu.c"
void menu_add_expr(enum prop_type type , struct expr *expr , struct expr *dep ) 
{ 


  {
  {
#line 191
  menu_add_prop(type, (char *)((void *)0), expr, dep);
  }
#line 192
  return;
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/menu.c"
void menu_add_symbol(enum prop_type type , struct symbol *sym , struct expr *dep ) 
{ 
  struct expr *tmp ;

  {
  {
#line 196
  tmp = expr_alloc_symbol(sym);
#line 196
  menu_add_prop(type, (char *)((void *)0), tmp, dep);
  }
#line 197
  return;
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/menu.c"
void menu_add_option(int token , char *arg ) 
{ 


  {
  {
#line 202
  if (token == 1) {
#line 202
    goto case_1;
  }
#line 211
  if (token == 2) {
#line 211
    goto case_2;
  }
#line 217
  if (token == 3) {
#line 217
    goto case_3;
  }
#line 220
  if (token == 4) {
#line 220
    goto case_4;
  }
#line 201
  goto switch_break;
  case_1: /* CIL Label */ 
#line 203
  if (modules_sym) {
    {
#line 204
    zconf_error("symbol \'%s\' redefines option \'modules\' already defined by symbol \'%s\'",
                (current_entry->sym)->name, modules_sym->name);
    }
  }
#line 209
  modules_sym = current_entry->sym;
#line 210
  goto switch_break;
  case_2: /* CIL Label */ 
#line 212
  if (! sym_defconfig_list) {
#line 213
    sym_defconfig_list = current_entry->sym;
  } else
#line 214
  if ((unsigned long )sym_defconfig_list != (unsigned long )current_entry->sym) {
    {
#line 215
    zconf_error("trying to redefine defconfig symbol");
    }
  }
#line 216
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 218
  prop_add_env((char const   *)arg);
  }
#line 219
  goto switch_break;
  case_4: /* CIL Label */ 
#line 221
  (current_entry->sym)->flags |= 2097152;
#line 222
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 224
  return;
}
}
#line 226 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/menu.c"
static int menu_validate_number(struct symbol *sym , struct symbol *sym2 ) 
{ 
  _Bool tmp ;
  int tmp___0 ;

  {
#line 228
  if ((unsigned int )sym2->type == 3U) {
#line 228
    tmp___0 = 1;
  } else
#line 228
  if ((unsigned int )sym2->type == 4U) {
#line 228
    tmp___0 = 1;
  } else
#line 228
  if ((unsigned int )sym2->type == 0U) {
    {
#line 228
    tmp = sym_string_valid(sym, (char const   *)sym2->name);
    }
#line 228
    if (tmp) {
#line 228
      tmp___0 = 1;
    } else {
#line 228
      tmp___0 = 0;
    }
  } else {
#line 228
    tmp___0 = 0;
  }
#line 228
  return (tmp___0);
}
}
#line 232 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/menu.c"
static void sym_check_prop(struct symbol *sym ) 
{ 
  struct property *prop ;
  struct symbol *sym2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 236
  prop = sym->prop;
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if (! prop) {
#line 236
      goto while_break;
    }
    {
#line 238
    if ((unsigned int )prop->type == 4U) {
#line 238
      goto case_4;
    }
#line 254
    if ((unsigned int )prop->type == 6U) {
#line 254
      goto case_6;
    }
#line 268
    if ((unsigned int )prop->type == 7U) {
#line 268
      goto case_7;
    }
#line 276
    goto switch_default;
    case_4: /* CIL Label */ 
#line 239
    if ((unsigned int )sym->type == 5U) {
#line 239
      goto _L;
    } else
#line 239
    if ((unsigned int )sym->type == 3U) {
#line 239
      goto _L;
    } else
#line 239
    if ((unsigned int )sym->type == 4U) {
      _L: /* CIL Label */ 
#line 239
      if ((unsigned int )(prop->expr)->type != 7U) {
        {
#line 241
        prop_warn(prop, "default for config symbol \'%s\' must be a single symbol",
                  sym->name);
        }
      }
    }
#line 244
    if ((unsigned int )(prop->expr)->type != 7U) {
#line 245
      goto switch_break;
    }
    {
#line 246
    sym2 = prop_get_symbol(prop);
    }
#line 247
    if ((unsigned int )sym->type == 4U) {
#line 247
      goto _L___0;
    } else
#line 247
    if ((unsigned int )sym->type == 3U) {
      _L___0: /* CIL Label */ 
      {
#line 248
      tmp = menu_validate_number(sym, sym2);
      }
#line 248
      if (! tmp) {
        {
#line 249
        prop_warn(prop, "\'%s\': number is invalid", sym->name);
        }
      }
    }
#line 253
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 255
    sym2 = prop_get_symbol(prop);
    }
#line 256
    if ((unsigned int )sym->type != 1U) {
#line 256
      if ((unsigned int )sym->type != 2U) {
        {
#line 257
        prop_warn(prop, "config symbol \'%s\' uses select, but is not boolean or tristate",
                  sym->name);
        }
      } else {
#line 256
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 260
    if ((unsigned int )sym2->type != 0U) {
#line 260
      if ((unsigned int )sym2->type != 1U) {
#line 260
        if ((unsigned int )sym2->type != 2U) {
          {
#line 263
          prop_warn(prop, "\'%s\' has wrong type. \'select\' only accept arguments of boolean and tristate type",
                    sym2->name);
          }
        }
      }
    }
#line 267
    goto switch_break;
    case_7: /* CIL Label */ 
#line 269
    if ((unsigned int )sym->type != 3U) {
#line 269
      if ((unsigned int )sym->type != 4U) {
        {
#line 270
        prop_warn(prop, "range is only allowed for int or hex symbols");
        }
      }
    }
    {
#line 272
    tmp___0 = menu_validate_number(sym, (prop->expr)->left.sym);
    }
#line 272
    if (tmp___0) {
      {
#line 272
      tmp___1 = menu_validate_number(sym, (prop->expr)->right.sym);
      }
#line 272
      if (! tmp___1) {
        {
#line 274
        prop_warn(prop, "range is invalid");
        }
      }
    } else {
      {
#line 274
      prop_warn(prop, "range is invalid");
      }
    }
#line 275
    goto switch_break;
    switch_default: /* CIL Label */ ;
    switch_break: /* CIL Label */ ;
    }
#line 236
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 280
  return;
}
}
#line 282 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/menu.c"
void menu_finalize(struct menu *parent ) 
{ 
  struct menu *menu ;
  struct menu *last_menu ;
  struct symbol *sym ;
  struct property *prop ;
  struct expr *parentdep ;
  struct expr *basedep ;
  struct expr *dep ;
  struct expr *dep2 ;
  struct expr **ep ;
  _Bool tmp ;
  struct expr *tmp___0 ;
  struct expr *tmp___1 ;
  struct symbol *es ;
  struct symbol *tmp___2 ;
  struct expr *tmp___3 ;
  struct expr *tmp___4 ;
  struct expr *tmp___5 ;
  struct expr *tmp___6 ;
  int tmp___7 ;
  _Bool tmp___8 ;
  struct expr *tmp___9 ;
  int tmp___10 ;
  struct expr *tmp___11 ;
  _Bool tmp___12 ;
  _Bool tmp___13 ;
  _Bool tmp___14 ;
  struct expr *tmp___15 ;
  struct expr *tmp___16 ;
  _Bool tmp___17 ;

  {
#line 289
  sym = parent->sym;
#line 290
  if (parent->list) {
#line 291
    if (sym) {
      {
#line 291
      tmp = sym_is_choice(sym);
      }
#line 291
      if (tmp) {
#line 292
        if ((unsigned int )sym->type == 0U) {
#line 294
          current_entry = parent;
#line 295
          menu = parent->list;
          {
#line 295
          while (1) {
            while_continue: /* CIL Label */ ;
#line 295
            if (! menu) {
#line 295
              goto while_break;
            }
#line 296
            if (menu->sym) {
#line 296
              if ((unsigned int )(menu->sym)->type != 0U) {
                {
#line 297
                menu_set_type((int )(menu->sym)->type);
                }
#line 298
                goto while_break;
              }
            }
#line 295
            menu = menu->next;
          }
          while_break: /* CIL Label */ ;
          }
        }
#line 303
        menu = parent->list;
        {
#line 303
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 303
          if (! menu) {
#line 303
            goto while_break___0;
          }
#line 304
          current_entry = menu;
#line 305
          if (menu->sym) {
#line 305
            if ((unsigned int )(menu->sym)->type == 0U) {
              {
#line 306
              menu_set_type((int )sym->type);
              }
            }
          }
#line 303
          menu = menu->next;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 308
        parentdep = expr_alloc_symbol(sym);
        }
      } else {
#line 291
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 309
    if (parent->prompt) {
#line 310
      parentdep = (parent->prompt)->visible.expr;
    } else {
#line 312
      parentdep = parent->dep;
    }
#line 314
    menu = parent->list;
    {
#line 314
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 314
      if (! menu) {
#line 314
        goto while_break___1;
      }
      {
#line 315
      basedep = expr_transform(menu->dep);
#line 316
      tmp___0 = expr_copy((struct expr  const  *)parentdep);
#line 316
      basedep = expr_alloc_and(tmp___0, basedep);
#line 317
      basedep = expr_eliminate_dups(basedep);
#line 318
      menu->dep = basedep;
      }
#line 319
      if (menu->sym) {
#line 320
        prop = (menu->sym)->prop;
      } else {
#line 322
        prop = menu->prompt;
      }
      {
#line 323
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 323
        if (! prop) {
#line 323
          goto while_break___2;
        }
#line 324
        if ((unsigned long )prop->menu != (unsigned long )menu) {
#line 325
          goto __Cont;
        }
        {
#line 326
        dep = expr_transform(prop->visible.expr);
#line 327
        tmp___1 = expr_copy((struct expr  const  *)basedep);
#line 327
        dep = expr_alloc_and(tmp___1, dep);
#line 328
        dep = expr_eliminate_dups(dep);
        }
#line 329
        if (menu->sym) {
#line 329
          if ((unsigned int )(menu->sym)->type != 2U) {
            {
#line 330
            dep = expr_trans_bool(dep);
            }
          }
        }
#line 331
        prop->visible.expr = dep;
#line 332
        if ((unsigned int )prop->type == 6U) {
          {
#line 333
          tmp___2 = prop_get_symbol(prop);
#line 333
          es = tmp___2;
#line 334
          tmp___3 = expr_copy((struct expr  const  *)dep);
#line 334
          tmp___4 = expr_alloc_symbol(menu->sym);
#line 334
          tmp___5 = expr_alloc_and(tmp___4, tmp___3);
#line 334
          es->rev_dep.expr = expr_alloc_or(es->rev_dep.expr, tmp___5);
          }
        }
        __Cont: /* CIL Label */ 
#line 323
        prop = prop->next;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 314
      menu = menu->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 339
    menu = parent->list;
    {
#line 339
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 339
      if (! menu) {
#line 339
        goto while_break___3;
      }
      {
#line 340
      menu_finalize(menu);
#line 339
      menu = menu->next;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  } else
#line 341
  if (sym) {
#line 342
    if (parent->prompt) {
#line 342
      basedep = (parent->prompt)->visible.expr;
    } else {
#line 342
      basedep = (struct expr *)((void *)0);
    }
    {
#line 343
    basedep = expr_trans_compare(basedep, (enum expr_type )5, & symbol_no);
#line 344
    tmp___6 = expr_transform(basedep);
#line 344
    basedep = expr_eliminate_dups(tmp___6);
#line 345
    last_menu = (struct menu *)((void *)0);
#line 346
    menu = parent->next;
    }
    {
#line 346
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 346
      if (! menu) {
#line 346
        goto while_break___4;
      }
#line 347
      if (menu->prompt) {
#line 347
        dep = (menu->prompt)->visible.expr;
      } else {
#line 347
        dep = menu->dep;
      }
      {
#line 348
      tmp___7 = expr_contains_symbol(dep, sym);
      }
#line 348
      if (! tmp___7) {
#line 349
        goto while_break___4;
      }
      {
#line 350
      tmp___8 = expr_depends_symbol(dep, sym);
      }
#line 350
      if (tmp___8) {
#line 351
        goto next;
      }
      {
#line 352
      dep = expr_trans_compare(dep, (enum expr_type )5, & symbol_no);
#line 353
      tmp___9 = expr_transform(dep);
#line 353
      dep = expr_eliminate_dups(tmp___9);
#line 354
      dep2 = expr_copy((struct expr  const  *)basedep);
#line 355
      expr_eliminate_eq(& dep, & dep2);
#line 356
      expr_free(dep);
#line 357
      tmp___10 = expr_is_yes(dep2);
      }
#line 357
      if (! tmp___10) {
        {
#line 358
        expr_free(dep2);
        }
#line 359
        goto while_break___4;
      }
      {
#line 361
      expr_free(dep2);
      }
      next: 
      {
#line 363
      menu_finalize(menu);
#line 364
      menu->parent = parent;
#line 365
      last_menu = menu;
#line 346
      menu = menu->next;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 367
    if (last_menu) {
#line 368
      parent->list = parent->next;
#line 369
      parent->next = last_menu->next;
#line 370
      last_menu->next = (struct menu *)((void *)0);
    }
    {
#line 373
    sym->dir_dep.expr = expr_alloc_or(sym->dir_dep.expr, parent->dep);
    }
  }
#line 375
  menu = parent->list;
  {
#line 375
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 375
    if (! menu) {
#line 375
      goto while_break___5;
    }
#line 376
    if (sym) {
      {
#line 376
      tmp___12 = sym_is_choice(sym);
      }
#line 376
      if (tmp___12) {
#line 376
        if (menu->sym) {
          {
#line 376
          tmp___13 = sym_is_choice_value(menu->sym);
          }
#line 376
          if (! tmp___13) {
#line 378
            current_entry = menu;
#line 379
            (menu->sym)->flags |= 32;
#line 380
            if (! menu->prompt) {
              {
#line 381
              menu_warn(menu, "choice value must have a prompt");
              }
            }
#line 382
            prop = (menu->sym)->prop;
            {
#line 382
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 382
              if (! prop) {
#line 382
                goto while_break___6;
              }
#line 383
              if ((unsigned int )prop->type == 4U) {
                {
#line 384
                prop_warn(prop, "defaults for choice values not supported");
                }
              }
#line 386
              if ((unsigned long )prop->menu == (unsigned long )menu) {
#line 387
                goto __Cont___0;
              }
#line 388
              if ((unsigned int )prop->type == 1U) {
#line 388
                if ((unsigned long )((prop->menu)->parent)->sym != (unsigned long )sym) {
                  {
#line 390
                  prop_warn(prop, "choice value used outside its choice group");
                  }
                }
              }
              __Cont___0: /* CIL Label */ 
#line 382
              prop = prop->next;
            }
            while_break___6: /* CIL Label */ ;
            }
#line 398
            if ((unsigned int )sym->type == 2U) {
#line 398
              if ((unsigned int )(menu->sym)->type != 2U) {
                {
#line 399
                basedep = expr_alloc_comp((enum expr_type )4, sym, & symbol_yes);
#line 400
                menu->dep = expr_alloc_and(basedep, menu->dep);
#line 401
                prop = (menu->sym)->prop;
                }
                {
#line 401
                while (1) {
                  while_continue___7: /* CIL Label */ ;
#line 401
                  if (! prop) {
#line 401
                    goto while_break___7;
                  }
#line 402
                  if ((unsigned long )prop->menu != (unsigned long )menu) {
#line 403
                    goto __Cont___1;
                  }
                  {
#line 404
                  tmp___11 = expr_copy((struct expr  const  *)basedep);
#line 404
                  prop->visible.expr = expr_alloc_and(tmp___11, prop->visible.expr);
                  }
                  __Cont___1: /* CIL Label */ 
#line 401
                  prop = prop->next;
                }
                while_break___7: /* CIL Label */ ;
                }
              }
            }
            {
#line 408
            menu_add_symbol((enum prop_type )5, sym, (struct expr *)((void *)0));
#line 409
            prop = sym_get_choice_prop(sym);
#line 410
            ep = & prop->expr;
            }
            {
#line 410
            while (1) {
              while_continue___8: /* CIL Label */ ;
#line 410
              if (! *ep) {
#line 410
                goto while_break___8;
              }
#line 410
              ep = & (*ep)->left.expr;
            }
            while_break___8: /* CIL Label */ ;
            }
            {
#line 412
            *ep = expr_alloc_one((enum expr_type )6, (struct expr *)((void *)0));
#line 413
            (*ep)->right.sym = menu->sym;
            }
          }
        }
      }
    }
#line 415
    if (menu->list) {
#line 415
      if (! menu->prompt) {
#line 415
        goto _L___0;
      } else
#line 415
      if (! (menu->prompt)->text) {
        _L___0: /* CIL Label */ 
#line 416
        last_menu = menu->list;
        {
#line 416
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 417
          last_menu->parent = parent;
#line 418
          if (! last_menu->next) {
#line 419
            goto while_break___9;
          }
#line 416
          last_menu = last_menu->next;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 421
        last_menu->next = menu->next;
#line 422
        menu->next = menu->list;
#line 423
        menu->list = (struct menu *)((void *)0);
      }
    }
#line 375
    menu = menu->next;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 427
  if (sym) {
#line 427
    if (! (sym->flags & 32768)) {
#line 428
      if ((unsigned int )sym->type == 0U) {
        {
#line 429
        menu_warn(parent, "config symbol defined without type");
        }
      }
      {
#line 431
      tmp___14 = sym_is_choice(sym);
      }
#line 431
      if (tmp___14) {
#line 431
        if (! parent->prompt) {
          {
#line 432
          menu_warn(parent, "choice must have a prompt");
          }
        }
      }
      {
#line 435
      sym_check_prop(sym);
#line 436
      sym->flags |= 32768;
      }
    }
  }
#line 439
  if (sym) {
    {
#line 439
    tmp___17 = sym_is_optional(sym);
    }
#line 439
    if (! tmp___17) {
#line 439
      if (parent->prompt) {
        {
#line 440
        tmp___15 = expr_alloc_symbol(& symbol_mod);
#line 440
        tmp___16 = expr_alloc_and((parent->prompt)->visible.expr, tmp___15);
#line 440
        sym->rev_dep.expr = expr_alloc_or(sym->rev_dep.expr, tmp___16);
        }
      }
    }
  }
#line 444
  return;
}
}
#line 446 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/menu.c"
_Bool menu_has_prompt(struct menu *menu ) 
{ 


  {
#line 448
  if (! menu->prompt) {
#line 449
    return ((_Bool)0);
  }
#line 450
  return ((_Bool)1);
}
}
#line 458 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/menu.c"
_Bool menu_is_empty(struct menu *menu ) 
{ 
  struct menu *child ;
  _Bool tmp ;

  {
#line 462
  child = menu->list;
  {
#line 462
  while (1) {
    while_continue: /* CIL Label */ ;
#line 462
    if (! child) {
#line 462
      goto while_break;
    }
    {
#line 463
    tmp = menu_is_visible(child);
    }
#line 463
    if (tmp) {
#line 464
      return ((_Bool)0);
    }
#line 462
    child = child->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 466
  return ((_Bool)1);
}
}
#line 469 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/menu.c"
_Bool menu_is_visible(struct menu *menu ) 
{ 
  struct menu *child ;
  struct symbol *sym ;
  tristate visible ;
  tristate tmp ;
  tristate tmp___0 ;
  tristate tmp___1 ;
  _Bool tmp___2 ;

  {
#line 475
  if (! menu->prompt) {
#line 476
    return ((_Bool)0);
  }
#line 478
  if (menu->visibility) {
    {
#line 479
    tmp = expr_calc_value(menu->visibility);
    }
#line 479
    if ((unsigned int )tmp == 0U) {
#line 480
      return ((_Bool)0);
    }
  }
#line 483
  sym = menu->sym;
#line 484
  if (sym) {
    {
#line 485
    sym_calc_value(sym);
#line 486
    visible = (menu->prompt)->visible.tri;
    }
  } else {
    {
#line 488
    tmp___0 = expr_calc_value((menu->prompt)->visible.expr);
#line 488
    (menu->prompt)->visible.tri = tmp___0;
#line 488
    visible = tmp___0;
    }
  }
#line 490
  if ((unsigned int )visible != 0U) {
#line 491
    return ((_Bool)1);
  }
#line 493
  if (! sym) {
#line 494
    return ((_Bool)0);
  } else {
    {
#line 493
    tmp___1 = sym_get_tristate_value(menu->sym);
    }
#line 493
    if ((unsigned int )tmp___1 == 0U) {
#line 494
      return ((_Bool)0);
    }
  }
#line 496
  child = menu->list;
  {
#line 496
  while (1) {
    while_continue: /* CIL Label */ ;
#line 496
    if (! child) {
#line 496
      goto while_break;
    }
    {
#line 497
    tmp___2 = menu_is_visible(child);
    }
#line 497
    if (tmp___2) {
#line 498
      if (sym) {
#line 499
        sym->flags |= 65536;
      }
#line 500
      return ((_Bool)1);
    }
#line 496
    child = child->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 504
  return ((_Bool)0);
}
}
#line 507 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/menu.c"
char const   *menu_get_prompt(struct menu *menu ) 
{ 


  {
#line 509
  if (menu->prompt) {
#line 510
    return ((menu->prompt)->text);
  } else
#line 511
  if (menu->sym) {
#line 512
    return ((char const   *)(menu->sym)->name);
  }
#line 513
  return ((char const   *)((void *)0));
}
}
#line 516 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/menu.c"
struct menu *menu_get_root_menu(struct menu *menu ) 
{ 


  {
#line 518
  return (& rootmenu);
}
}
#line 521 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/menu.c"
struct menu *menu_get_parent_menu(struct menu *menu ) 
{ 
  enum prop_type type ;

  {
  {
#line 525
  while (1) {
    while_continue: /* CIL Label */ ;
#line 525
    if (! ((unsigned long )menu != (unsigned long )(& rootmenu))) {
#line 525
      goto while_break;
    }
#line 526
    if (menu->prompt) {
#line 526
      type = (menu->prompt)->type;
    } else {
#line 526
      type = (enum prop_type )0;
    }
#line 527
    if ((unsigned int )type == 3U) {
#line 528
      goto while_break;
    }
#line 525
    menu = menu->parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 530
  return (menu);
}
}
#line 533 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/menu.c"
_Bool menu_has_help(struct menu *menu ) 
{ 


  {
#line 535
  return ((_Bool )((unsigned long )menu->help != (unsigned long )((void *)0)));
}
}
#line 538 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/menu.c"
char const   *menu_get_help(struct menu *menu ) 
{ 


  {
#line 540
  if (menu->help) {
#line 541
    return ((char const   *)menu->help);
  } else {
#line 543
    return ("");
  }
}
}
#line 546 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/menu.c"
static void get_prompt_str(struct gstr *r , struct property *prop , struct list_head *head ) 
{ 
  int i ;
  int j ;
  struct menu *submenu[8] ;
  struct menu *menu ;
  struct menu *location ;
  struct jump_key *jump ;
  char *tmp ;
  char *tmp___0 ;
  _Bool accessible ;
  _Bool tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  _Bool tmp___4 ;
  struct list_head  const  *__mptr ;
  int tmp___5 ;
  char *tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;

  {
  {
#line 550
  location = (struct menu *)((void *)0);
#line 551
  jump = (struct jump_key *)((void *)0);
#line 553
  tmp = gettext(prop->text);
#line 553
  tmp___0 = gettext("Prompt: %s\n");
#line 553
  str_printf(r, (char const   *)tmp___0, tmp);
#line 554
  menu = (prop->menu)->parent;
#line 555
  i = 0;
  }
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    if ((unsigned long )menu != (unsigned long )(& rootmenu)) {
#line 555
      if (! (i < 8)) {
#line 555
        goto while_break;
      }
    } else {
#line 555
      goto while_break;
    }
    {
#line 556
    tmp___1 = menu_is_visible(menu);
#line 556
    accessible = tmp___1;
#line 558
    tmp___2 = i;
#line 558
    i ++;
#line 558
    submenu[tmp___2] = menu;
    }
#line 559
    if ((unsigned long )location == (unsigned long )((void *)0)) {
#line 559
      if (accessible) {
#line 560
        location = menu;
      }
    }
#line 555
    menu = menu->parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 562
  if (head) {
#line 562
    if (location) {
      {
#line 563
      tmp___3 = xmalloc(sizeof(struct jump_key ));
#line 563
      jump = (struct jump_key *)tmp___3;
#line 565
      tmp___4 = menu_is_visible(prop->menu);
      }
#line 565
      if (tmp___4) {
#line 572
        jump->target = prop->menu;
      } else {
#line 574
        jump->target = location;
      }
      {
#line 576
      tmp___5 = list_empty((struct list_head  const  *)head);
      }
#line 576
      if (tmp___5) {
#line 577
        jump->index = 0;
      } else {
#line 579
        __mptr = (struct list_head  const  *)head->prev;
#line 579
        jump->index = ((struct jump_key *)((char *)__mptr - (size_t )(& ((struct jump_key *)0)->entries)))->index + 1;
      }
      {
#line 582
      list_add_tail(& jump->entries, head);
      }
    }
  }
#line 585
  if (i > 0) {
    {
#line 586
    tmp___6 = gettext("  Location:\n");
#line 586
    str_printf(r, (char const   *)tmp___6);
#line 587
    j = 4;
    }
    {
#line 587
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 587
      i --;
#line 587
      if (! (i >= 0)) {
#line 587
        goto while_break___0;
      }
#line 588
      menu = submenu[i];
#line 589
      if (jump) {
#line 589
        if ((unsigned long )menu == (unsigned long )location) {
          {
#line 590
          jump->offset = strlen((char const   *)r->s);
          }
        }
      }
      {
#line 591
      tmp___7 = menu_get_prompt(menu);
#line 591
      tmp___8 = gettext(tmp___7);
#line 591
      str_printf(r, "%*c-> %s", j, ' ', tmp___8);
      }
#line 593
      if (menu->sym) {
        {
#line 594
        tmp___9 = sym_get_string_value(menu->sym);
        }
#line 594
        if ((menu->sym)->name) {
#line 594
          tmp___11 = (menu->sym)->name;
        } else {
          {
#line 594
          tmp___10 = gettext("<choice>");
#line 594
          tmp___11 = tmp___10;
          }
        }
        {
#line 594
        str_printf(r, " (%s [=%s])", tmp___11, tmp___9);
        }
      }
      {
#line 598
      str_append(r, "\n");
#line 587
      j += 2;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 601
  return;
}
}
#line 606 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/menu.c"
static struct property *get_symbol_prop(struct symbol *sym ) 
{ 
  struct property *prop ;

  {
#line 608
  prop = (struct property *)((void *)0);
#line 610
  prop = sym->prop;
  {
#line 610
  while (1) {
    while_continue: /* CIL Label */ ;
#line 610
    if (! prop) {
#line 610
      goto while_break;
    }
#line 610
    if ((unsigned int )prop->type == 9U) {
#line 611
      goto while_break;
    }
#line 610
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 612
  return (prop);
}
}
#line 618 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/menu.c"
void get_symbol_str(struct gstr *r , struct symbol *sym , struct list_head *head ) 
{ 
  _Bool hit ;
  struct property *prop ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
#line 624
  if (sym) {
#line 624
    if (sym->name) {
      {
#line 625
      tmp = sym_get_string_value(sym);
#line 625
      str_printf(r, "Symbol: %s [=%s]\n", sym->name, tmp);
#line 627
      tmp___0 = sym_type_name(sym->type);
#line 627
      str_printf(r, "Type  : %s\n", tmp___0);
      }
#line 628
      if ((unsigned int )sym->type == 3U) {
#line 628
        goto _L;
      } else
#line 628
      if ((unsigned int )sym->type == 4U) {
        _L: /* CIL Label */ 
        {
#line 629
        prop = sym_get_range_prop(sym);
        }
#line 630
        if (prop) {
          {
#line 631
          str_printf(r, "Range : ");
#line 632
          expr_gstr_print(prop->expr, r);
#line 633
          str_append(r, "\n");
          }
        }
      }
    }
  }
#line 637
  prop = sym->prop;
  {
#line 637
  while (1) {
    while_continue: /* CIL Label */ ;
#line 637
    if (! prop) {
#line 637
      goto while_break;
    }
#line 637
    if (prop->text) {
      {
#line 638
      get_prompt_str(r, prop, head);
      }
    }
#line 637
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 640
  prop = get_symbol_prop(sym);
  }
#line 641
  if (prop) {
    {
#line 642
    tmp___1 = gettext("  Defined at %s:%d\n");
#line 642
    str_printf(r, (char const   *)tmp___1, ((prop->menu)->file)->name, (prop->menu)->lineno);
#line 644
    tmp___3 = expr_is_yes(prop->visible.expr);
    }
#line 644
    if (! tmp___3) {
      {
#line 645
      tmp___2 = gettext("  Depends on: ");
#line 645
      str_append(r, (char const   *)tmp___2);
#line 646
      expr_gstr_print(prop->visible.expr, r);
#line 647
      str_append(r, "\n");
      }
    }
  }
#line 651
  hit = (_Bool)0;
#line 652
  prop = sym->prop;
  {
#line 652
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 652
    if (! prop) {
#line 652
      goto while_break___0;
    }
#line 652
    if ((unsigned int )prop->type == 6U) {
#line 653
      if (! hit) {
        {
#line 654
        str_append(r, "  Selects: ");
#line 655
        hit = (_Bool)1;
        }
      } else {
        {
#line 657
        str_printf(r, " && ");
        }
      }
      {
#line 658
      expr_gstr_print(prop->expr, r);
      }
    }
#line 652
    prop = prop->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 660
  if (hit) {
    {
#line 661
    str_append(r, "\n");
    }
  }
#line 662
  if (sym->rev_dep.expr) {
    {
#line 663
    tmp___4 = gettext("  Selected by: ");
#line 663
    str_append(r, (char const   *)tmp___4);
#line 664
    expr_gstr_print(sym->rev_dep.expr, r);
#line 665
    str_append(r, "\n");
    }
  }
  {
#line 667
  str_append(r, "\n\n");
  }
#line 668
  return;
}
}
#line 670 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/menu.c"
struct gstr get_relations_str(struct symbol **sym_arr , struct list_head *head ) 
{ 
  struct symbol *sym ;
  struct gstr res ;
  struct gstr tmp ;
  int i ;
  char *tmp___0 ;

  {
  {
#line 673
  tmp = str_new();
#line 673
  res = tmp;
#line 676
  i = 0;
  }
  {
#line 676
  while (1) {
    while_continue: /* CIL Label */ ;
#line 676
    if (sym_arr) {
#line 676
      sym = *(sym_arr + i);
#line 676
      if (! sym) {
#line 676
        goto while_break;
      }
    } else {
#line 676
      goto while_break;
    }
    {
#line 677
    get_symbol_str(& res, sym, head);
#line 676
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 678
  if (! i) {
    {
#line 679
    tmp___0 = gettext("No matches found.\n");
#line 679
    str_append(& res, (char const   *)tmp___0);
    }
  }
#line 680
  return (res);
}
}
#line 684 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/scripts/kconfig/menu.c"
void menu_get_ext_help(struct menu *menu , struct gstr *help ) 
{ 
  struct symbol *sym ;
  char const   *help_text ;
  char const   *tmp ;
  _Bool tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 686
  sym = menu->sym;
#line 687
  help_text = nohelp_text;
#line 689
  tmp___0 = menu_has_help(menu);
  }
#line 689
  if (tmp___0) {
#line 690
    if (sym->name) {
      {
#line 691
      tmp = CONFIG_prefix();
#line 691
      str_printf(help, "%s%s:\n\n", tmp, sym->name);
      }
    }
    {
#line 692
    help_text = menu_get_help(menu);
    }
  }
  {
#line 694
  tmp___1 = gettext(help_text);
#line 694
  str_printf(help, "%s\n", tmp___1);
  }
#line 695
  if (sym) {
    {
#line 696
    get_symbol_str(help, sym, (struct list_head *)((void *)0));
    }
  }
#line 697
  return;
}
}
#line 709 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 582 "/usr/include/regex.h"
extern size_t regerror(int __errcode , regex_t const   * __restrict  __preg , char * __restrict  __errbuf ,
                       size_t __errbuf_size ) ;
#line 22 "./tools/include/tools/le_byteshift.h"
__inline static void __put_unaligned_le16(uint16_t val , uint8_t *p ) 
{ 
  uint8_t *tmp ;
  uint8_t *tmp___0 ;

  {
#line 24
  tmp = p;
#line 24
  p ++;
#line 24
  *tmp = (uint8_t )val;
#line 25
  tmp___0 = p;
#line 25
  p ++;
#line 25
  *tmp___0 = (uint8_t )((int )val >> 8);
#line 26
  return;
}
}
#line 28 "./tools/include/tools/le_byteshift.h"
__inline static void __put_unaligned_le32(uint32_t val , uint8_t *p ) 
{ 


  {
  {
#line 30
  __put_unaligned_le16((uint16_t )(val >> 16), p + 2);
#line 31
  __put_unaligned_le16((uint16_t )val, p);
  }
#line 32
  return;
}
}
#line 60 "./tools/include/tools/le_byteshift.h"
__inline static void put_unaligned_le32(uint32_t val , void *p ) 
{ 


  {
  {
#line 62
  __put_unaligned_le32(val, (uint8_t *)p);
  }
#line 63
  return;
}
}
#line 19 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.h"
void die(char *fmt  , ...) ;
#line 31
void process_32(FILE *fp , int use_real_mode , int as_text , int show_absolute_syms ,
                int show_absolute_relocs , int show_reloc_info ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static Elf32_Ehdr ehdr  ;
#line 21 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static struct relocs relocs16  ;
#line 22 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static struct relocs relocs32  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static struct section *secs  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static char const   * const  sym_regex_kernel[4]  = {      (char const   */* const  */)"^(xen_irq_disable_direct_reloc$|xen_save_fl_direct_reloc$|VDSO|__crc_)",      (char const   */* const  */)"^(__init_(begin|end)|__x86_cpu_dev_(start|end)|(__parainstructions|__alt_instructions)(|_end)|(__iommu_table|__apicdrivers|__smp_locks)(|_end)|__(start|end)_pci_.*|__(start|end)_builtin_fw|__(start|stop)___ksymtab(|_gpl|_unused|_unused_gpl|_gpl_future)|__(start|stop)___kcrctab(|_gpl|_unused|_unused_gpl|_gpl_future)|__(start|stop)___param|__(start|stop)___modver|__(start|stop)___bug_table|__tracedata_(start|end)|__(start|stop)_notes|__end_rodata|__initramfs_start|(jiffies|jiffies_64)|__vvar_page|_end)$"};
#line 81 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static char const   * const  sym_regex_realmode[4]  = {      (char const   */* const  */)0,      (char const   */* const  */)"^pa_",      (char const   */* const  */)"^real_mode_seg$",      (char const   */* const  */)"^pa_"};
#line 103 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static char const   * const  *sym_regex  ;
#line 105 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static regex_t sym_regex_c[4]  ;
#line 106 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static int is_reloc(enum symtype type , char const   *sym_name___1 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 108
  if (*(sym_regex + type)) {
    {
#line 108
    tmp = regexec((regex_t const   */* __restrict  */)(& sym_regex_c[type]), (char const   */* __restrict  */)sym_name___1,
                  (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
    }
#line 108
    if (tmp) {
#line 108
      tmp___0 = 0;
    } else {
#line 108
      tmp___0 = 1;
    }
  } else {
#line 108
    tmp___0 = 0;
  }
#line 108
  return (tmp___0);
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static void regex_init(int use_real_mode ) 
{ 
  char errbuf[128] ;
  int err ;
  int i ;

  {
#line 118
  if (use_real_mode) {
#line 119
    sym_regex = sym_regex_realmode;
  } else {
#line 121
    sym_regex = sym_regex_kernel;
  }
#line 123
  i = 0;
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 123
    if (! (i < 4)) {
#line 123
      goto while_break;
    }
#line 124
    if (! *(sym_regex + i)) {
#line 125
      goto __Cont;
    }
    {
#line 127
    err = regcomp((regex_t */* __restrict  */)(& sym_regex_c[i]), (char const   */* __restrict  */)*(sym_regex + i),
                  1 | (((1 << 1) << 1) << 1));
    }
#line 130
    if (err) {
      {
#line 131
      regerror(err, (regex_t const   */* __restrict  */)(& sym_regex_c[i]), (char */* __restrict  */)(errbuf),
               sizeof(errbuf));
#line 132
      die((char *)"%s", errbuf);
      }
    }
    __Cont: /* CIL Label */ 
#line 123
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 135
  return;
}
}
#line 139
static char const   *sym_type(unsigned int type ) ;
#line 139 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static char const   *type_name[7]  = {      "STT_NOTYPE",      "STT_OBJECT",      "STT_FUNC",      "STT_SECTION", 
        "STT_FILE",      "STT_COMMON",      "STT_TLS"};
#line 137 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static char const   *sym_type(unsigned int type ) 
{ 
  char const   *name ;

  {
#line 150
  name = "unknown sym type name";
#line 151
  if ((unsigned long )type < sizeof(type_name) / sizeof(type_name[0])) {
#line 152
    name = type_name[type];
  }
#line 154
  return (name);
}
}
#line 159
static char const   *sym_bind(unsigned int bind ) ;
#line 159 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static char const   *bind_name[3]  = {      "STB_LOCAL",      "STB_GLOBAL",      "STB_WEAK"};
#line 157 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static char const   *sym_bind(unsigned int bind ) 
{ 
  char const   *name ;

  {
#line 166
  name = "unknown sym bind name";
#line 167
  if ((unsigned long )bind < sizeof(bind_name) / sizeof(bind_name[0])) {
#line 168
    name = bind_name[bind];
  }
#line 170
  return (name);
}
}
#line 175
static char const   *sym_visibility(unsigned int visibility ) ;
#line 175 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static char const   *visibility_name[4]  = {      "STV_DEFAULT",      "STV_INTERNAL",      "STV_HIDDEN",      "STV_PROTECTED"};
#line 173 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static char const   *sym_visibility(unsigned int visibility ) 
{ 
  char const   *name ;

  {
#line 183
  name = "unknown sym visibility name";
#line 184
  if ((unsigned long )visibility < sizeof(visibility_name) / sizeof(visibility_name[0])) {
#line 185
    name = visibility_name[visibility];
  }
#line 187
  return (name);
}
}
#line 192
static char const   *rel_type(unsigned int type ) ;
#line 192 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static char const   *type_name___0[24]  = 
#line 192
  {      "R_386_NONE",      "R_386_32",      "R_386_PC32",      "R_386_GOT32", 
        "R_386_PLT32",      "R_386_COPY",      "R_386_GLOB_DAT",      "R_386_JMP_SLOT", 
        "R_386_RELATIVE",      "R_386_GOTOFF",      "R_386_GOTPC",      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        "R_386_16",      "R_386_PC16",      "R_386_8",      "R_386_PC8"};
#line 190 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static char const   *rel_type(unsigned int type ) 
{ 
  char const   *name ;

  {
#line 230
  name = "unknown type rel type name";
#line 231
  if ((unsigned long )type < sizeof(type_name___0) / sizeof(type_name___0[0])) {
#line 231
    if (type_name___0[type]) {
#line 232
      name = type_name___0[type];
    }
  }
#line 234
  return (name);
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static char const   *sec_name(unsigned int shndx ) 
{ 
  char const   *sec_strtab ;
  char const   *name ;

  {
#line 241
  sec_strtab = (char const   *)(secs + ehdr.e_shstrndx)->strtab;
#line 242
  name = "<noname>";
#line 243
  if (shndx < (unsigned int )ehdr.e_shnum) {
#line 244
    name = sec_strtab + (secs + shndx)->shdr.sh_name;
  } else
#line 246
  if (shndx == 65521U) {
#line 247
    name = "ABSOLUTE";
  } else
#line 249
  if (shndx == 65522U) {
#line 250
    name = "COMMON";
  }
#line 252
  return (name);
}
}
#line 255 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static char const   *sym_name(char const   *sym_strtab , Elf32_Sym *sym ) 
{ 
  char const   *name ;

  {
#line 258
  name = "<noname>";
#line 259
  if (sym->st_name) {
#line 260
    name = sym_strtab + sym->st_name;
  } else {
    {
#line 263
    name = sec_name((unsigned int )sym->st_shndx);
    }
  }
#line 265
  return (name);
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static uint16_t elf16_to_cpu(uint16_t val ) 
{ 


  {
#line 308
  return (val);
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static uint32_t elf32_to_cpu(uint32_t val ) 
{ 


  {
#line 313
  return (val);
}
}
#line 333 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static void read_ehdr(FILE *fp ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 335
  tmp___1 = fread((void */* __restrict  */)(& ehdr), sizeof(ehdr), (size_t )1, (FILE */* __restrict  */)fp);
  }
#line 335
  if (tmp___1 != 1UL) {
    {
#line 336
    tmp = __errno_location();
#line 336
    tmp___0 = strerror(*tmp);
#line 336
    die((char *)"Cannot read ELF header: %s\n", tmp___0);
    }
  }
  {
#line 339
  tmp___2 = memcmp((void const   *)(ehdr.e_ident), (void const   *)"\177ELF", (size_t )4);
  }
#line 339
  if (tmp___2 != 0) {
    {
#line 340
    die((char *)"No ELF magic\n");
    }
  }
#line 342
  if ((int )ehdr.e_ident[4] != 1) {
    {
#line 343
    die((char *)"Not a %d bit executable\n", 32);
    }
  }
#line 345
  if ((int )ehdr.e_ident[5] != 1) {
    {
#line 346
    die((char *)"Not a LSB ELF executable\n");
    }
  }
#line 348
  if ((int )ehdr.e_ident[6] != 1) {
    {
#line 349
    die((char *)"Unknown ELF version\n");
    }
  }
  {
#line 352
  ehdr.e_type = elf16_to_cpu(ehdr.e_type);
#line 353
  ehdr.e_machine = elf16_to_cpu(ehdr.e_machine);
#line 354
  ehdr.e_version = elf32_to_cpu(ehdr.e_version);
#line 355
  ehdr.e_entry = elf32_to_cpu(ehdr.e_entry);
#line 356
  ehdr.e_phoff = elf32_to_cpu(ehdr.e_phoff);
#line 357
  ehdr.e_shoff = elf32_to_cpu(ehdr.e_shoff);
#line 358
  ehdr.e_flags = elf32_to_cpu(ehdr.e_flags);
#line 359
  ehdr.e_ehsize = elf16_to_cpu(ehdr.e_ehsize);
#line 360
  ehdr.e_phentsize = elf16_to_cpu(ehdr.e_phentsize);
#line 361
  ehdr.e_phnum = elf16_to_cpu(ehdr.e_phnum);
#line 362
  ehdr.e_shentsize = elf16_to_cpu(ehdr.e_shentsize);
#line 363
  ehdr.e_shnum = elf16_to_cpu(ehdr.e_shnum);
#line 364
  ehdr.e_shstrndx = elf16_to_cpu(ehdr.e_shstrndx);
  }
#line 366
  if ((int )ehdr.e_type != 2) {
#line 366
    if ((int )ehdr.e_type != 3) {
      {
#line 367
      die((char *)"Unsupported ELF header type\n");
      }
    }
  }
#line 369
  if ((int )ehdr.e_machine != 3) {
    {
#line 370
    die((char *)"Not for %s\n", "i386");
    }
  }
#line 372
  if (ehdr.e_version != 1U) {
    {
#line 373
    die((char *)"Unknown ELF version\n");
    }
  }
#line 375
  if ((unsigned long )ehdr.e_ehsize != sizeof(Elf32_Ehdr )) {
    {
#line 376
    die((char *)"Bad Elf header size\n");
    }
  }
#line 378
  if ((unsigned long )ehdr.e_phentsize != sizeof(Elf32_Phdr )) {
    {
#line 379
    die((char *)"Bad program header entry\n");
    }
  }
#line 381
  if ((unsigned long )ehdr.e_shentsize != sizeof(Elf32_Shdr )) {
    {
#line 382
    die((char *)"Bad section header entry\n");
    }
  }
#line 384
  if ((int )ehdr.e_shstrndx >= (int )ehdr.e_shnum) {
    {
#line 385
    die((char *)"String table index out of bounds\n");
    }
  }
#line 387
  return;
}
}
#line 389 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static void read_shdrs(FILE *fp ) 
{ 
  int i ;
  Elf32_Shdr shdr ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  struct section *sec ;
  int *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;

  {
  {
#line 394
  tmp = calloc((size_t )ehdr.e_shnum, sizeof(struct section ));
#line 394
  secs = (struct section *)tmp;
  }
#line 395
  if (! secs) {
    {
#line 396
    die((char *)"Unable to allocate %d section headers\n", (int )ehdr.e_shnum);
    }
  }
  {
#line 399
  tmp___2 = fseek(fp, (long )ehdr.e_shoff, 0);
  }
#line 399
  if (tmp___2 < 0) {
    {
#line 400
    tmp___0 = __errno_location();
#line 400
    tmp___1 = strerror(*tmp___0);
#line 400
    die((char *)"Seek to %d failed: %s\n", ehdr.e_shoff, tmp___1);
    }
  }
#line 403
  i = 0;
  {
#line 403
  while (1) {
    while_continue: /* CIL Label */ ;
#line 403
    if (! (i < (int )ehdr.e_shnum)) {
#line 403
      goto while_break;
    }
    {
#line 404
    sec = secs + i;
#line 405
    tmp___5 = fread((void */* __restrict  */)(& shdr), sizeof(shdr), (size_t )1, (FILE */* __restrict  */)fp);
    }
#line 405
    if (tmp___5 != 1UL) {
      {
#line 406
      tmp___3 = __errno_location();
#line 406
      tmp___4 = strerror(*tmp___3);
#line 406
      die((char *)"Cannot read ELF section headers %d/%d: %s\n", i, (int )ehdr.e_shnum,
          tmp___4);
      }
    }
    {
#line 408
    sec->shdr.sh_name = elf32_to_cpu(shdr.sh_name);
#line 409
    sec->shdr.sh_type = elf32_to_cpu(shdr.sh_type);
#line 410
    sec->shdr.sh_flags = elf32_to_cpu(shdr.sh_flags);
#line 411
    sec->shdr.sh_addr = elf32_to_cpu(shdr.sh_addr);
#line 412
    sec->shdr.sh_offset = elf32_to_cpu(shdr.sh_offset);
#line 413
    sec->shdr.sh_size = elf32_to_cpu(shdr.sh_size);
#line 414
    sec->shdr.sh_link = elf32_to_cpu(shdr.sh_link);
#line 415
    sec->shdr.sh_info = elf32_to_cpu(shdr.sh_info);
#line 416
    sec->shdr.sh_addralign = elf32_to_cpu(shdr.sh_addralign);
#line 417
    sec->shdr.sh_entsize = elf32_to_cpu(shdr.sh_entsize);
    }
#line 418
    if (sec->shdr.sh_link < (Elf32_Word )ehdr.e_shnum) {
#line 419
      sec->link = secs + sec->shdr.sh_link;
    }
#line 403
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 422
  return;
}
}
#line 424 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static void read_strtabs(FILE *fp ) 
{ 
  int i ;
  struct section *sec ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;

  {
#line 427
  i = 0;
  {
#line 427
  while (1) {
    while_continue: /* CIL Label */ ;
#line 427
    if (! (i < (int )ehdr.e_shnum)) {
#line 427
      goto while_break;
    }
#line 428
    sec = secs + i;
#line 429
    if (sec->shdr.sh_type != 3U) {
#line 430
      goto __Cont;
    }
    {
#line 432
    tmp = malloc((size_t )sec->shdr.sh_size);
#line 432
    sec->strtab = (char *)tmp;
    }
#line 433
    if (! sec->strtab) {
      {
#line 434
      die((char *)"malloc of %d bytes for strtab failed\n", sec->shdr.sh_size);
      }
    }
    {
#line 437
    tmp___2 = fseek(fp, (long )sec->shdr.sh_offset, 0);
    }
#line 437
    if (tmp___2 < 0) {
      {
#line 438
      tmp___0 = __errno_location();
#line 438
      tmp___1 = strerror(*tmp___0);
#line 438
      die((char *)"Seek to %d failed: %s\n", sec->shdr.sh_offset, tmp___1);
      }
    }
    {
#line 441
    tmp___5 = fread((void */* __restrict  */)sec->strtab, (size_t )1, (size_t )sec->shdr.sh_size,
                    (FILE */* __restrict  */)fp);
    }
#line 441
    if (tmp___5 != (size_t )sec->shdr.sh_size) {
      {
#line 443
      tmp___3 = __errno_location();
#line 443
      tmp___4 = strerror(*tmp___3);
#line 443
      die((char *)"Cannot read symbol table: %s\n", tmp___4);
      }
    }
    __Cont: /* CIL Label */ 
#line 427
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 447
  return;
}
}
#line 449 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static void read_symtabs(FILE *fp ) 
{ 
  int i ;
  int j ;
  struct section *sec ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  Elf32_Sym *sym ;

  {
#line 452
  i = 0;
  {
#line 452
  while (1) {
    while_continue: /* CIL Label */ ;
#line 452
    if (! (i < (int )ehdr.e_shnum)) {
#line 452
      goto while_break;
    }
#line 453
    sec = secs + i;
#line 454
    if (sec->shdr.sh_type != 2U) {
#line 455
      goto __Cont;
    }
    {
#line 457
    tmp = malloc((size_t )sec->shdr.sh_size);
#line 457
    sec->symtab = (Elf32_Sym *)tmp;
    }
#line 458
    if (! sec->symtab) {
      {
#line 459
      die((char *)"malloc of %d bytes for symtab failed\n", sec->shdr.sh_size);
      }
    }
    {
#line 462
    tmp___2 = fseek(fp, (long )sec->shdr.sh_offset, 0);
    }
#line 462
    if (tmp___2 < 0) {
      {
#line 463
      tmp___0 = __errno_location();
#line 463
      tmp___1 = strerror(*tmp___0);
#line 463
      die((char *)"Seek to %d failed: %s\n", sec->shdr.sh_offset, tmp___1);
      }
    }
    {
#line 466
    tmp___5 = fread((void */* __restrict  */)sec->symtab, (size_t )1, (size_t )sec->shdr.sh_size,
                    (FILE */* __restrict  */)fp);
    }
#line 466
    if (tmp___5 != (size_t )sec->shdr.sh_size) {
      {
#line 468
      tmp___3 = __errno_location();
#line 468
      tmp___4 = strerror(*tmp___3);
#line 468
      die((char *)"Cannot read symbol table: %s\n", tmp___4);
      }
    }
#line 471
    j = 0;
    {
#line 471
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 471
      if (! ((unsigned long )j < (unsigned long )sec->shdr.sh_size / sizeof(Elf32_Sym ))) {
#line 471
        goto while_break___0;
      }
      {
#line 472
      sym = sec->symtab + j;
#line 473
      sym->st_name = elf32_to_cpu(sym->st_name);
#line 474
      sym->st_value = elf32_to_cpu(sym->st_value);
#line 475
      sym->st_size = elf32_to_cpu(sym->st_size);
#line 476
      sym->st_shndx = elf16_to_cpu(sym->st_shndx);
#line 471
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 452
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 479
  return;
}
}
#line 482 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static void read_relocs(FILE *fp ) 
{ 
  int i ;
  int j ;
  struct section *sec ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  Elf32_Rel *rel ;

  {
#line 485
  i = 0;
  {
#line 485
  while (1) {
    while_continue: /* CIL Label */ ;
#line 485
    if (! (i < (int )ehdr.e_shnum)) {
#line 485
      goto while_break;
    }
#line 486
    sec = secs + i;
#line 487
    if (sec->shdr.sh_type != 9U) {
#line 488
      goto __Cont;
    }
    {
#line 490
    tmp = malloc((size_t )sec->shdr.sh_size);
#line 490
    sec->reltab = (Elf32_Rel *)tmp;
    }
#line 491
    if (! sec->reltab) {
      {
#line 492
      die((char *)"malloc of %d bytes for relocs failed\n", sec->shdr.sh_size);
      }
    }
    {
#line 495
    tmp___2 = fseek(fp, (long )sec->shdr.sh_offset, 0);
    }
#line 495
    if (tmp___2 < 0) {
      {
#line 496
      tmp___0 = __errno_location();
#line 496
      tmp___1 = strerror(*tmp___0);
#line 496
      die((char *)"Seek to %d failed: %s\n", sec->shdr.sh_offset, tmp___1);
      }
    }
    {
#line 499
    tmp___5 = fread((void */* __restrict  */)sec->reltab, (size_t )1, (size_t )sec->shdr.sh_size,
                    (FILE */* __restrict  */)fp);
    }
#line 499
    if (tmp___5 != (size_t )sec->shdr.sh_size) {
      {
#line 501
      tmp___3 = __errno_location();
#line 501
      tmp___4 = strerror(*tmp___3);
#line 501
      die((char *)"Cannot read symbol table: %s\n", tmp___4);
      }
    }
#line 504
    j = 0;
    {
#line 504
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 504
      if (! ((unsigned long )j < (unsigned long )sec->shdr.sh_size / sizeof(Elf32_Rel ))) {
#line 504
        goto while_break___0;
      }
      {
#line 505
      rel = sec->reltab + j;
#line 506
      rel->r_offset = elf32_to_cpu(rel->r_offset);
#line 507
      rel->r_info = elf32_to_cpu(rel->r_info);
#line 504
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 485
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 513
  return;
}
}
#line 516 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static void print_absolute_symbols(void) 
{ 
  int i ;
  char const   *format ;
  struct section *sec ;
  char *sym_strtab ;
  int j ;
  Elf32_Sym *sym ;
  char const   *name ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 524
  format = "%5d %08x  %5d %10s %10s %12s %s\n";
#line 526
  printf((char const   */* __restrict  */)"Absolute symbols\n");
#line 527
  printf((char const   */* __restrict  */)" Num:    Value Size  Type       Bind        Visibility  Name\n");
#line 528
  i = 0;
  }
  {
#line 528
  while (1) {
    while_continue: /* CIL Label */ ;
#line 528
    if (! (i < (int )ehdr.e_shnum)) {
#line 528
      goto while_break;
    }
#line 529
    sec = secs + i;
#line 533
    if (sec->shdr.sh_type != 2U) {
#line 534
      goto __Cont;
    }
#line 536
    sym_strtab = (sec->link)->strtab;
#line 537
    j = 0;
    {
#line 537
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 537
      if (! ((unsigned long )j < (unsigned long )sec->shdr.sh_size / sizeof(Elf32_Sym ))) {
#line 537
        goto while_break___0;
      }
      {
#line 540
      sym = sec->symtab + j;
#line 541
      name = sym_name((char const   *)sym_strtab, sym);
      }
#line 542
      if ((int )sym->st_shndx != 65521) {
#line 543
        goto __Cont___0;
      }
      {
#line 545
      tmp = sym_visibility((unsigned int )((int )sym->st_other & 3));
#line 545
      tmp___0 = sym_bind((unsigned int )((int )sym->st_info >> 4));
#line 545
      tmp___1 = sym_type((unsigned int )((int )sym->st_info & 15));
#line 545
      printf((char const   */* __restrict  */)format, j, sym->st_value, sym->st_size,
             tmp___1, tmp___0, tmp, name);
      }
      __Cont___0: /* CIL Label */ 
#line 537
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 528
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 553
  printf((char const   */* __restrict  */)"\n");
  }
#line 554
  return;
}
}
#line 556 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static void print_absolute_relocs(void) 
{ 
  int i ;
  int printed ;
  char const   *format ;
  struct section *sec ;
  struct section *sec_applies ;
  struct section *sec_symtab ;
  char *sym_strtab ;
  Elf32_Sym *sh_symtab ;
  int j ;
  Elf32_Rel *rel ;
  Elf32_Sym *sym ;
  char const   *name ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
#line 558
  printed = 0;
#line 564
  format = "%08x %08x %10s %08x  %s\n";
#line 566
  i = 0;
  {
#line 566
  while (1) {
    while_continue: /* CIL Label */ ;
#line 566
    if (! (i < (int )ehdr.e_shnum)) {
#line 566
      goto while_break;
    }
#line 567
    sec = secs + i;
#line 572
    if (sec->shdr.sh_type != 9U) {
#line 573
      goto __Cont;
    }
#line 575
    sec_symtab = sec->link;
#line 576
    sec_applies = secs + sec->shdr.sh_info;
#line 577
    if (! (sec_applies->shdr.sh_flags & (unsigned int )(1 << 1))) {
#line 578
      goto __Cont;
    }
#line 580
    sh_symtab = sec_symtab->symtab;
#line 581
    sym_strtab = (sec_symtab->link)->strtab;
#line 582
    j = 0;
    {
#line 582
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 582
      if (! ((unsigned long )j < (unsigned long )sec->shdr.sh_size / sizeof(Elf32_Rel ))) {
#line 582
        goto while_break___0;
      }
      {
#line 586
      rel = sec->reltab + j;
#line 587
      sym = sh_symtab + (rel->r_info >> 8);
#line 588
      name = sym_name((char const   *)sym_strtab, sym);
      }
#line 589
      if ((int )sym->st_shndx != 65521) {
#line 590
        goto __Cont___0;
      }
      {
#line 606
      tmp = is_reloc((enum symtype )0, name);
      }
#line 606
      if (tmp) {
#line 607
        goto __Cont___0;
      } else {
        {
#line 606
        tmp___0 = is_reloc((enum symtype )1, name);
        }
#line 606
        if (tmp___0) {
#line 607
          goto __Cont___0;
        }
      }
#line 609
      if (! printed) {
        {
#line 610
        printf((char const   */* __restrict  */)"WARNING: Absolute relocations present\n");
#line 612
        printf((char const   */* __restrict  */)"Offset     Info     Type     Sym.Value Sym.Name\n");
#line 614
        printed = 1;
        }
      }
      {
#line 617
      tmp___1 = rel_type(rel->r_info & 255U);
#line 617
      printf((char const   */* __restrict  */)format, rel->r_offset, rel->r_info,
             tmp___1, sym->st_value, name);
      }
      __Cont___0: /* CIL Label */ 
#line 582
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 566
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 626
  if (printed) {
    {
#line 627
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 628
  return;
}
}
#line 630 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static void add_reloc(struct relocs *r , uint32_t offset ) 
{ 
  unsigned long newsize ;
  void *mem ;
  void *tmp ;
  unsigned long tmp___0 ;

  {
#line 632
  if (r->count == r->size) {
    {
#line 633
    newsize = r->size + 50000UL;
#line 634
    tmp = realloc((void *)r->offset, newsize * sizeof(*(r->offset + 0)));
#line 634
    mem = tmp;
    }
#line 636
    if (! mem) {
      {
#line 637
      die((char *)"realloc of %ld entries for relocs failed\n", newsize);
      }
    }
#line 639
    r->offset = (uint32_t *)mem;
#line 640
    r->size = newsize;
  }
#line 642
  tmp___0 = r->count;
#line 642
  (r->count) ++;
#line 642
  *(r->offset + tmp___0) = offset;
#line 643
  return;
}
}
#line 645 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static void walk_relocs(int (*process)(struct section *sec , Elf32_Rel *rel , Elf32_Sym *sym ,
                                       char const   *symname ) ) 
{ 
  int i ;
  char *sym_strtab ;
  Elf32_Sym *sh_symtab ;
  struct section *sec_applies ;
  struct section *sec_symtab ;
  int j ;
  struct section *sec ;
  Elf32_Rel *rel ;
  Elf32_Sym *sym ;
  char const   *symname ;
  char const   *tmp ;

  {
#line 650
  i = 0;
  {
#line 650
  while (1) {
    while_continue: /* CIL Label */ ;
#line 650
    if (! (i < (int )ehdr.e_shnum)) {
#line 650
      goto while_break;
    }
#line 655
    sec = secs + i;
#line 657
    if (sec->shdr.sh_type != 9U) {
#line 658
      goto __Cont;
    }
#line 660
    sec_symtab = sec->link;
#line 661
    sec_applies = secs + sec->shdr.sh_info;
#line 662
    if (! (sec_applies->shdr.sh_flags & (unsigned int )(1 << 1))) {
#line 663
      goto __Cont;
    }
#line 665
    sh_symtab = sec_symtab->symtab;
#line 666
    sym_strtab = (sec_symtab->link)->strtab;
#line 667
    j = 0;
    {
#line 667
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 667
      if (! ((unsigned long )j < (unsigned long )sec->shdr.sh_size / sizeof(Elf32_Rel ))) {
#line 667
        goto while_break___0;
      }
      {
#line 668
      rel = sec->reltab + j;
#line 669
      sym = sh_symtab + (rel->r_info >> 8);
#line 670
      tmp = sym_name((char const   *)sym_strtab, sym);
#line 670
      symname = tmp;
#line 672
      (*process)(sec, rel, sym, symname);
#line 667
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 650
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 675
  return;
}
}
#line 828 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static int do_reloc32(struct section *sec , Elf32_Rel *rel , Elf32_Sym *sym , char const   *symname ) 
{ 
  unsigned int r_type ;
  int shn_abs ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 831
  r_type = rel->r_info & 255U;
#line 832
  if ((int )sym->st_shndx == 65521) {
    {
#line 832
    tmp = is_reloc((enum symtype )1, symname);
    }
#line 832
    if (tmp) {
#line 832
      tmp___0 = 0;
    } else {
#line 832
      tmp___0 = 1;
    }
  } else {
#line 832
    tmp___0 = 0;
  }
#line 832
  shn_abs = tmp___0;
  {
#line 838
  if (r_type == 23U) {
#line 838
    goto case_23;
  }
#line 838
  if (r_type == 21U) {
#line 838
    goto case_23;
  }
#line 838
  if (r_type == 2U) {
#line 838
    goto case_23;
  }
#line 838
  if (r_type == 0U) {
#line 838
    goto case_23;
  }
#line 845
  if (r_type == 1U) {
#line 845
    goto case_1;
  }
#line 862
  goto switch_default;
  case_23: /* CIL Label */ 
  case_21: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 843
  goto switch_break;
  case_1: /* CIL Label */ 
#line 846
  if (shn_abs) {
    {
#line 851
    tmp___1 = is_reloc((enum symtype )0, symname);
    }
#line 851
    if (tmp___1) {
#line 852
      goto switch_break;
    }
    {
#line 854
    tmp___2 = rel_type(r_type);
#line 854
    die((char *)"Invalid absolute %s relocation: %s\n", tmp___2, symname);
    }
#line 856
    goto switch_break;
  }
  {
#line 859
  add_reloc(& relocs32, rel->r_offset);
  }
#line 860
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 863
  tmp___3 = rel_type(r_type);
#line 863
  die((char *)"Unsupported relocation type: %s (%d)\n", tmp___3, r_type);
  }
#line 865
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 868
  return (0);
}
}
#line 871 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static int do_reloc_real(struct section *sec , Elf32_Rel *rel , Elf32_Sym *sym , char const   *symname ) 
{ 
  unsigned int r_type ;
  int shn_abs ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;

  {
#line 874
  r_type = rel->r_info & 255U;
#line 875
  if ((int )sym->st_shndx == 65521) {
    {
#line 875
    tmp = is_reloc((enum symtype )1, symname);
    }
#line 875
    if (tmp) {
#line 875
      tmp___0 = 0;
    } else {
#line 875
      tmp___0 = 1;
    }
  } else {
#line 875
    tmp___0 = 0;
  }
#line 875
  shn_abs = tmp___0;
  {
#line 881
  if (r_type == 23U) {
#line 881
    goto case_23;
  }
#line 881
  if (r_type == 21U) {
#line 881
    goto case_23;
  }
#line 881
  if (r_type == 2U) {
#line 881
    goto case_23;
  }
#line 881
  if (r_type == 0U) {
#line 881
    goto case_23;
  }
#line 888
  if (r_type == 20U) {
#line 888
    goto case_20;
  }
#line 910
  if (r_type == 1U) {
#line 910
    goto case_1;
  }
#line 933
  goto switch_default;
  case_23: /* CIL Label */ 
  case_21: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 886
  goto switch_break;
  case_20: /* CIL Label */ 
#line 889
  if (shn_abs) {
    {
#line 894
    tmp___1 = is_reloc((enum symtype )0, symname);
    }
#line 894
    if (tmp___1) {
#line 895
      goto switch_break;
    }
    {
#line 897
    tmp___2 = is_reloc((enum symtype )2, symname);
    }
#line 897
    if (tmp___2) {
      {
#line 898
      add_reloc(& relocs16, rel->r_offset);
      }
#line 899
      goto switch_break;
    }
  } else {
    {
#line 902
    tmp___3 = is_reloc((enum symtype )3, symname);
    }
#line 902
    if (! tmp___3) {
#line 903
      goto switch_break;
    }
  }
  {
#line 905
  tmp___4 = rel_type(r_type);
  }
#line 905
  if (shn_abs) {
#line 905
    tmp___5 = "absolute";
  } else {
#line 905
    tmp___5 = "relative";
  }
  {
#line 905
  die((char *)"Invalid %s %s relocation: %s\n", tmp___5, tmp___4, symname);
  }
#line 908
  goto switch_break;
  case_1: /* CIL Label */ 
#line 911
  if (shn_abs) {
    {
#line 916
    tmp___6 = is_reloc((enum symtype )0, symname);
    }
#line 916
    if (tmp___6) {
#line 917
      goto switch_break;
    }
    {
#line 919
    tmp___7 = is_reloc((enum symtype )1, symname);
    }
#line 919
    if (tmp___7) {
      {
#line 920
      add_reloc(& relocs32, rel->r_offset);
      }
#line 921
      goto switch_break;
    }
  } else {
    {
#line 924
    tmp___8 = is_reloc((enum symtype )3, symname);
    }
#line 924
    if (tmp___8) {
      {
#line 925
      add_reloc(& relocs32, rel->r_offset);
      }
    }
#line 926
    goto switch_break;
  }
  {
#line 928
  tmp___9 = rel_type(r_type);
  }
#line 928
  if (shn_abs) {
#line 928
    tmp___10 = "absolute";
  } else {
#line 928
    tmp___10 = "relative";
  }
  {
#line 928
  die((char *)"Invalid %s %s relocation: %s\n", tmp___10, tmp___9, symname);
  }
#line 931
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 934
  tmp___11 = rel_type(r_type);
#line 934
  die((char *)"Unsupported relocation type: %s (%d)\n", tmp___11, r_type);
  }
#line 936
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 939
  return (0);
}
}
#line 944 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static int cmp_relocs(void const   *va , void const   *vb ) 
{ 
  uint32_t const   *a ;
  uint32_t const   *b ;
  int tmp ;
  int tmp___0 ;

  {
#line 947
  a = (uint32_t const   *)va;
#line 947
  b = (uint32_t const   *)vb;
#line 948
  if (*a == *b) {
#line 948
    tmp___0 = 0;
  } else {
#line 948
    if (*a > *b) {
#line 948
      tmp = 1;
    } else {
#line 948
      tmp = -1;
    }
#line 948
    tmp___0 = tmp;
  }
#line 948
  return (tmp___0);
}
}
#line 951 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static void sort_relocs(struct relocs *r ) 
{ 


  {
  {
#line 953
  qsort((void *)r->offset, r->count, sizeof(*(r->offset + 0)), & cmp_relocs);
  }
#line 954
  return;
}
}
#line 956 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static int write32(uint32_t v , FILE *f ) 
{ 
  unsigned char buf[4] ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 960
  put_unaligned_le32(v, (void *)(buf));
#line 961
  tmp___1 = fwrite((void const   */* __restrict  */)(buf), (size_t )1, (size_t )4,
                   (FILE */* __restrict  */)f);
  }
#line 961
  if (tmp___1 == 4UL) {
#line 961
    tmp___0 = 0;
  } else {
#line 961
    tmp___0 = -1;
  }
#line 961
  return (tmp___0);
}
}
#line 964 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static int write32_as_text(uint32_t v , FILE *f ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 966
  tmp___1 = fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\t.long 0x%08x\n",
                    v);
  }
#line 966
  if (tmp___1 > 0) {
#line 966
    tmp___0 = 0;
  } else {
#line 966
    tmp___0 = -1;
  }
#line 966
  return (tmp___0);
}
}
#line 969 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static void emit_relocs(int as_text , int use_real_mode ) 
{ 
  int i ;
  int (*write_reloc)(uint32_t  , FILE * ) ;
  int (*do_reloc)(struct section *sec , Elf32_Rel *rel , Elf32_Sym *sym , char const   *symname ) ;

  {
#line 972
  write_reloc = & write32;
#line 982
  if (! use_real_mode) {
#line 983
    do_reloc = & do_reloc32;
  } else {
#line 985
    do_reloc = & do_reloc_real;
  }
  {
#line 989
  walk_relocs(do_reloc);
  }
#line 991
  if (relocs16.count) {
#line 991
    if (! use_real_mode) {
      {
#line 992
      die((char *)"Segment relocations found but --realmode not specified\n");
      }
    }
  }
  {
#line 995
  sort_relocs(& relocs16);
#line 996
  sort_relocs(& relocs32);
  }
#line 1003
  if (as_text) {
    {
#line 1007
    printf((char const   */* __restrict  */)".section \".data.reloc\",\"a\"\n");
#line 1008
    printf((char const   */* __restrict  */)".balign 4\n");
#line 1009
    write_reloc = & write32_as_text;
    }
  }
#line 1012
  if (use_real_mode) {
    {
#line 1013
    (*write_reloc)((uint32_t )relocs16.count, stdout);
#line 1014
    i = 0;
    }
    {
#line 1014
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1014
      if (! ((unsigned long )i < relocs16.count)) {
#line 1014
        goto while_break;
      }
      {
#line 1015
      (*write_reloc)(*(relocs16.offset + i), stdout);
#line 1014
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1017
    (*write_reloc)((uint32_t )relocs32.count, stdout);
#line 1018
    i = 0;
    }
    {
#line 1018
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1018
      if (! ((unsigned long )i < relocs32.count)) {
#line 1018
        goto while_break___0;
      }
      {
#line 1019
      (*write_reloc)(*(relocs32.offset + i), stdout);
#line 1018
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 1038
    (*write_reloc)((uint32_t )0, stdout);
#line 1041
    i = 0;
    }
    {
#line 1041
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1041
      if (! ((unsigned long )i < relocs32.count)) {
#line 1041
        goto while_break___1;
      }
      {
#line 1042
      (*write_reloc)(*(relocs32.offset + i), stdout);
#line 1041
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1044
  return;
}
}
#line 1052 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static int do_reloc_info(struct section *sec , Elf32_Rel *rel , Elf32_Sym *sym , char const   *symname ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 1055
  tmp = sec_name((unsigned int )sym->st_shndx);
#line 1055
  tmp___0 = rel_type(rel->r_info & 255U);
#line 1055
  tmp___1 = sec_name(sec->shdr.sh_info);
#line 1055
  printf((char const   */* __restrict  */)"%s\t%s\t%s\t%s\n", tmp___1, tmp___0, symname,
         tmp);
  }
#line 1060
  return (0);
}
}
#line 1063 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static void print_reloc_info(void) 
{ 


  {
  {
#line 1065
  printf((char const   */* __restrict  */)"reloc section\treloc type\tsymbol\tsymbol section\n");
#line 1066
  walk_relocs(& do_reloc_info);
  }
#line 1067
  return;
}
}
#line 1075 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
void process_32(FILE *fp , int use_real_mode , int as_text , int show_absolute_syms ,
                int show_absolute_relocs , int show_reloc_info ) 
{ 


  {
  {
#line 1079
  regex_init(use_real_mode);
#line 1080
  read_ehdr(fp);
#line 1081
  read_shdrs(fp);
#line 1082
  read_strtabs(fp);
#line 1083
  read_symtabs(fp);
#line 1084
  read_relocs(fp);
  }
#line 1087
  if (show_absolute_syms) {
    {
#line 1088
    print_absolute_symbols();
    }
#line 1089
    return;
  }
#line 1091
  if (show_absolute_relocs) {
    {
#line 1092
    print_absolute_relocs();
    }
#line 1093
    return;
  }
#line 1095
  if (show_reloc_info) {
    {
#line 1096
    print_reloc_info();
    }
#line 1097
    return;
  }
  {
#line 1099
  emit_relocs(as_text, use_real_mode);
  }
#line 1100
  return;
}
}
#line 759 "/usr/include/stdio.h"
extern void rewind(FILE *__stream ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.h"
void process_64(FILE *fp , int use_real_mode , int as_text , int show_absolute_syms ,
                int show_absolute_relocs , int show_reloc_info ) ;
#line 3 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs_common.c"
void die(char *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 6
  __builtin_va_start(ap, fmt);
#line 7
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           ap);
#line 8
  __builtin_va_end(ap);
#line 9
  exit(1);
  }
}
}
#line 12 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs_common.c"
static void usage___0(void) 
{ 


  {
  {
#line 14
  die((char *)"relocs [--abs-syms|--abs-relocs|--reloc-info|--text|--realmode] vmlinux\n");
  }
#line 16
  return;
}
}
#line 13 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static Elf64_Ehdr ehdr___0  ;
#line 21 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static struct relocs relocs16___0  ;
#line 22 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static struct relocs relocs32___0  ;
#line 24 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static struct relocs relocs32neg  ;
#line 25 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static struct relocs relocs64  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static struct section___0 *secs___0  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static char const   * const  sym_regex_kernel___0[4]  = {      (char const   */* const  */)"^(xen_irq_disable_direct_reloc$|xen_save_fl_direct_reloc$|VDSO|__crc_)",      (char const   */* const  */)"^(__init_(begin|end)|__x86_cpu_dev_(start|end)|(__parainstructions|__alt_instructions)(|_end)|(__iommu_table|__apicdrivers|__smp_locks)(|_end)|__(start|end)_pci_.*|__(start|end)_builtin_fw|__(start|stop)___ksymtab(|_gpl|_unused|_unused_gpl|_gpl_future)|__(start|stop)___kcrctab(|_gpl|_unused|_unused_gpl|_gpl_future)|__(start|stop)___param|__(start|stop)___modver|__(start|stop)___bug_table|__tracedata_(start|end)|__(start|stop)_notes|__end_rodata|__initramfs_start|(jiffies|jiffies_64)|__per_cpu_load|init_per_cpu__.*|__end_rodata_hpage_align|__vvar_page|_end)$"};
#line 81 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static char const   * const  sym_regex_realmode___0[4]  = {      (char const   */* const  */)0,      (char const   */* const  */)"^pa_",      (char const   */* const  */)"^real_mode_seg$",      (char const   */* const  */)"^pa_"};
#line 103 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static char const   * const  *sym_regex___0  ;
#line 105 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static regex_t sym_regex_c___0[4]  ;
#line 106 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static int is_reloc___0(enum symtype type , char const   *sym_name___1 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 108
  if (*(sym_regex___0 + type)) {
    {
#line 108
    tmp = regexec((regex_t const   */* __restrict  */)(& sym_regex_c___0[type]), (char const   */* __restrict  */)sym_name___1,
                  (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
    }
#line 108
    if (tmp) {
#line 108
      tmp___0 = 0;
    } else {
#line 108
      tmp___0 = 1;
    }
  } else {
#line 108
    tmp___0 = 0;
  }
#line 108
  return (tmp___0);
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static void regex_init___0(int use_real_mode ) 
{ 
  char errbuf[128] ;
  int err ;
  int i ;

  {
#line 118
  if (use_real_mode) {
#line 119
    sym_regex___0 = sym_regex_realmode___0;
  } else {
#line 121
    sym_regex___0 = sym_regex_kernel___0;
  }
#line 123
  i = 0;
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 123
    if (! (i < 4)) {
#line 123
      goto while_break;
    }
#line 124
    if (! *(sym_regex___0 + i)) {
#line 125
      goto __Cont;
    }
    {
#line 127
    err = regcomp((regex_t */* __restrict  */)(& sym_regex_c___0[i]), (char const   */* __restrict  */)*(sym_regex___0 + i),
                  1 | (((1 << 1) << 1) << 1));
    }
#line 130
    if (err) {
      {
#line 131
      regerror(err, (regex_t const   */* __restrict  */)(& sym_regex_c___0[i]), (char */* __restrict  */)(errbuf),
               sizeof(errbuf));
#line 132
      die((char *)"%s", errbuf);
      }
    }
    __Cont: /* CIL Label */ 
#line 123
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 135
  return;
}
}
#line 139
static char const   *sym_type___0(unsigned int type ) ;
#line 139 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static char const   *type_name___1[7]  = {      "STT_NOTYPE",      "STT_OBJECT",      "STT_FUNC",      "STT_SECTION", 
        "STT_FILE",      "STT_COMMON",      "STT_TLS"};
#line 137 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static char const   *sym_type___0(unsigned int type ) 
{ 
  char const   *name ;

  {
#line 150
  name = "unknown sym type name";
#line 151
  if ((unsigned long )type < sizeof(type_name___1) / sizeof(type_name___1[0])) {
#line 152
    name = type_name___1[type];
  }
#line 154
  return (name);
}
}
#line 159
static char const   *sym_bind___0(unsigned int bind ) ;
#line 159 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static char const   *bind_name___0[3]  = {      "STB_LOCAL",      "STB_GLOBAL",      "STB_WEAK"};
#line 157 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static char const   *sym_bind___0(unsigned int bind ) 
{ 
  char const   *name ;

  {
#line 166
  name = "unknown sym bind name";
#line 167
  if ((unsigned long )bind < sizeof(bind_name___0) / sizeof(bind_name___0[0])) {
#line 168
    name = bind_name___0[bind];
  }
#line 170
  return (name);
}
}
#line 175
static char const   *sym_visibility___0(unsigned int visibility ) ;
#line 175 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static char const   *visibility_name___0[4]  = {      "STV_DEFAULT",      "STV_INTERNAL",      "STV_HIDDEN",      "STV_PROTECTED"};
#line 173 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static char const   *sym_visibility___0(unsigned int visibility ) 
{ 
  char const   *name ;

  {
#line 183
  name = "unknown sym visibility name";
#line 184
  if ((unsigned long )visibility < sizeof(visibility_name___0) / sizeof(visibility_name___0[0])) {
#line 185
    name = visibility_name___0[visibility];
  }
#line 187
  return (name);
}
}
#line 192
static char const   *rel_type___0(unsigned int type ) ;
#line 192 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static char const   *type_name___2[16]  = 
#line 192
  {      "R_X86_64_NONE",      "R_X86_64_64",      "R_X86_64_PC32",      "R_X86_64_GOT32", 
        "R_X86_64_PLT32",      "R_X86_64_COPY",      "R_X86_64_GLOB_DAT",      "R_X86_64_JUMP_SLOT", 
        "R_X86_64_RELATIVE",      "R_X86_64_GOTPCREL",      "R_X86_64_32",      "R_X86_64_32S", 
        "R_X86_64_16",      "R_X86_64_PC16",      "R_X86_64_8",      "R_X86_64_PC8"};
#line 190 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static char const   *rel_type___0(unsigned int type ) 
{ 
  char const   *name ;

  {
#line 230
  name = "unknown type rel type name";
#line 231
  if ((unsigned long )type < sizeof(type_name___2) / sizeof(type_name___2[0])) {
#line 231
    if (type_name___2[type]) {
#line 232
      name = type_name___2[type];
    }
  }
#line 234
  return (name);
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static char const   *sec_name___0(unsigned int shndx ) 
{ 
  char const   *sec_strtab ;
  char const   *name ;

  {
#line 241
  sec_strtab = (char const   *)(secs___0 + ehdr___0.e_shstrndx)->strtab;
#line 242
  name = "<noname>";
#line 243
  if (shndx < (unsigned int )ehdr___0.e_shnum) {
#line 244
    name = sec_strtab + (secs___0 + shndx)->shdr.sh_name;
  } else
#line 246
  if (shndx == 65521U) {
#line 247
    name = "ABSOLUTE";
  } else
#line 249
  if (shndx == 65522U) {
#line 250
    name = "COMMON";
  }
#line 252
  return (name);
}
}
#line 255 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static char const   *sym_name___0(char const   *sym_strtab , Elf64_Sym *sym ) 
{ 
  char const   *name ;

  {
#line 258
  name = "<noname>";
#line 259
  if (sym->st_name) {
#line 260
    name = sym_strtab + sym->st_name;
  } else {
    {
#line 263
    name = sec_name___0((unsigned int )sym->st_shndx);
    }
  }
#line 265
  return (name);
}
}
#line 268 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static Elf64_Sym *sym_lookup___0(char const   *symname ) 
{ 
  int i ;
  struct section___0 *sec ;
  long nsyms ;
  char *strtab ;
  Elf64_Sym *symtab ;
  Elf64_Sym *sym ;
  int tmp ;

  {
#line 271
  i = 0;
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
#line 271
    if (! (i < (int )ehdr___0.e_shnum)) {
#line 271
      goto while_break;
    }
#line 272
    sec = secs___0 + i;
#line 278
    if (sec->shdr.sh_type != 2U) {
#line 279
      goto __Cont;
    }
#line 281
    nsyms = (long )(sec->shdr.sh_size / sizeof(Elf64_Sym ));
#line 282
    symtab = sec->symtab;
#line 283
    strtab = (sec->link)->strtab;
#line 285
    sym = symtab;
    {
#line 285
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 285
      nsyms --;
#line 285
      if (! (nsyms >= 0L)) {
#line 285
        goto while_break___0;
      }
#line 286
      if (! sym->st_name) {
#line 287
        goto __Cont___0;
      }
      {
#line 288
      tmp = strcmp(symname, (char const   *)(strtab + sym->st_name));
      }
#line 288
      if (tmp == 0) {
#line 289
        return (sym);
      }
      __Cont___0: /* CIL Label */ 
#line 285
      sym ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 271
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 292
  return ((Elf64_Sym *)0);
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static uint16_t elf16_to_cpu___0(uint16_t val ) 
{ 


  {
#line 308
  return (val);
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static uint32_t elf32_to_cpu___0(uint32_t val ) 
{ 


  {
#line 313
  return (val);
}
}
#line 320 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static uint64_t elf64_to_cpu(uint64_t val ) 
{ 


  {
#line 322
  return (val);
}
}
#line 333 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static void read_ehdr___0(FILE *fp ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 335
  tmp___1 = fread((void */* __restrict  */)(& ehdr___0), sizeof(ehdr___0), (size_t )1,
                  (FILE */* __restrict  */)fp);
  }
#line 335
  if (tmp___1 != 1UL) {
    {
#line 336
    tmp = __errno_location();
#line 336
    tmp___0 = strerror(*tmp);
#line 336
    die((char *)"Cannot read ELF header: %s\n", tmp___0);
    }
  }
  {
#line 339
  tmp___2 = memcmp((void const   *)(ehdr___0.e_ident), (void const   *)"\177ELF",
                   (size_t )4);
  }
#line 339
  if (tmp___2 != 0) {
    {
#line 340
    die((char *)"No ELF magic\n");
    }
  }
#line 342
  if ((int )ehdr___0.e_ident[4] != 2) {
    {
#line 343
    die((char *)"Not a %d bit executable\n", 64);
    }
  }
#line 345
  if ((int )ehdr___0.e_ident[5] != 1) {
    {
#line 346
    die((char *)"Not a LSB ELF executable\n");
    }
  }
#line 348
  if ((int )ehdr___0.e_ident[6] != 1) {
    {
#line 349
    die((char *)"Unknown ELF version\n");
    }
  }
  {
#line 352
  ehdr___0.e_type = elf16_to_cpu___0(ehdr___0.e_type);
#line 353
  ehdr___0.e_machine = elf16_to_cpu___0(ehdr___0.e_machine);
#line 354
  ehdr___0.e_version = elf32_to_cpu___0(ehdr___0.e_version);
#line 355
  ehdr___0.e_entry = elf64_to_cpu(ehdr___0.e_entry);
#line 356
  ehdr___0.e_phoff = elf64_to_cpu(ehdr___0.e_phoff);
#line 357
  ehdr___0.e_shoff = elf64_to_cpu(ehdr___0.e_shoff);
#line 358
  ehdr___0.e_flags = elf32_to_cpu___0(ehdr___0.e_flags);
#line 359
  ehdr___0.e_ehsize = elf16_to_cpu___0(ehdr___0.e_ehsize);
#line 360
  ehdr___0.e_phentsize = elf16_to_cpu___0(ehdr___0.e_phentsize);
#line 361
  ehdr___0.e_phnum = elf16_to_cpu___0(ehdr___0.e_phnum);
#line 362
  ehdr___0.e_shentsize = elf16_to_cpu___0(ehdr___0.e_shentsize);
#line 363
  ehdr___0.e_shnum = elf16_to_cpu___0(ehdr___0.e_shnum);
#line 364
  ehdr___0.e_shstrndx = elf16_to_cpu___0(ehdr___0.e_shstrndx);
  }
#line 366
  if ((int )ehdr___0.e_type != 2) {
#line 366
    if ((int )ehdr___0.e_type != 3) {
      {
#line 367
      die((char *)"Unsupported ELF header type\n");
      }
    }
  }
#line 369
  if ((int )ehdr___0.e_machine != 62) {
    {
#line 370
    die((char *)"Not for %s\n", "x86_64");
    }
  }
#line 372
  if (ehdr___0.e_version != 1U) {
    {
#line 373
    die((char *)"Unknown ELF version\n");
    }
  }
#line 375
  if ((unsigned long )ehdr___0.e_ehsize != sizeof(Elf64_Ehdr )) {
    {
#line 376
    die((char *)"Bad Elf header size\n");
    }
  }
#line 378
  if ((unsigned long )ehdr___0.e_phentsize != sizeof(Elf64_Phdr )) {
    {
#line 379
    die((char *)"Bad program header entry\n");
    }
  }
#line 381
  if ((unsigned long )ehdr___0.e_shentsize != sizeof(Elf64_Shdr )) {
    {
#line 382
    die((char *)"Bad section header entry\n");
    }
  }
#line 384
  if ((int )ehdr___0.e_shstrndx >= (int )ehdr___0.e_shnum) {
    {
#line 385
    die((char *)"String table index out of bounds\n");
    }
  }
#line 387
  return;
}
}
#line 389 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static void read_shdrs___0(FILE *fp ) 
{ 
  int i ;
  Elf64_Shdr shdr ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  struct section___0 *sec ;
  int *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;

  {
  {
#line 394
  tmp = calloc((size_t )ehdr___0.e_shnum, sizeof(struct section___0 ));
#line 394
  secs___0 = (struct section___0 *)tmp;
  }
#line 395
  if (! secs___0) {
    {
#line 396
    die((char *)"Unable to allocate %d section headers\n", (int )ehdr___0.e_shnum);
    }
  }
  {
#line 399
  tmp___2 = fseek(fp, (long )ehdr___0.e_shoff, 0);
  }
#line 399
  if (tmp___2 < 0) {
    {
#line 400
    tmp___0 = __errno_location();
#line 400
    tmp___1 = strerror(*tmp___0);
#line 400
    die((char *)"Seek to %d failed: %s\n", ehdr___0.e_shoff, tmp___1);
    }
  }
#line 403
  i = 0;
  {
#line 403
  while (1) {
    while_continue: /* CIL Label */ ;
#line 403
    if (! (i < (int )ehdr___0.e_shnum)) {
#line 403
      goto while_break;
    }
    {
#line 404
    sec = secs___0 + i;
#line 405
    tmp___5 = fread((void */* __restrict  */)(& shdr), sizeof(shdr), (size_t )1, (FILE */* __restrict  */)fp);
    }
#line 405
    if (tmp___5 != 1UL) {
      {
#line 406
      tmp___3 = __errno_location();
#line 406
      tmp___4 = strerror(*tmp___3);
#line 406
      die((char *)"Cannot read ELF section headers %d/%d: %s\n", i, (int )ehdr___0.e_shnum,
          tmp___4);
      }
    }
    {
#line 408
    sec->shdr.sh_name = elf32_to_cpu___0(shdr.sh_name);
#line 409
    sec->shdr.sh_type = elf32_to_cpu___0(shdr.sh_type);
#line 410
    sec->shdr.sh_flags = elf64_to_cpu(shdr.sh_flags);
#line 411
    sec->shdr.sh_addr = elf64_to_cpu(shdr.sh_addr);
#line 412
    sec->shdr.sh_offset = elf64_to_cpu(shdr.sh_offset);
#line 413
    sec->shdr.sh_size = elf64_to_cpu(shdr.sh_size);
#line 414
    sec->shdr.sh_link = elf32_to_cpu___0(shdr.sh_link);
#line 415
    sec->shdr.sh_info = elf32_to_cpu___0(shdr.sh_info);
#line 416
    sec->shdr.sh_addralign = elf64_to_cpu(shdr.sh_addralign);
#line 417
    sec->shdr.sh_entsize = elf64_to_cpu(shdr.sh_entsize);
    }
#line 418
    if (sec->shdr.sh_link < (Elf32_Word )ehdr___0.e_shnum) {
#line 419
      sec->link = secs___0 + sec->shdr.sh_link;
    }
#line 403
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 422
  return;
}
}
#line 424 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static void read_strtabs___0(FILE *fp ) 
{ 
  int i ;
  struct section___0 *sec ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;

  {
#line 427
  i = 0;
  {
#line 427
  while (1) {
    while_continue: /* CIL Label */ ;
#line 427
    if (! (i < (int )ehdr___0.e_shnum)) {
#line 427
      goto while_break;
    }
#line 428
    sec = secs___0 + i;
#line 429
    if (sec->shdr.sh_type != 3U) {
#line 430
      goto __Cont;
    }
    {
#line 432
    tmp = malloc(sec->shdr.sh_size);
#line 432
    sec->strtab = (char *)tmp;
    }
#line 433
    if (! sec->strtab) {
      {
#line 434
      die((char *)"malloc of %d bytes for strtab failed\n", sec->shdr.sh_size);
      }
    }
    {
#line 437
    tmp___2 = fseek(fp, (long )sec->shdr.sh_offset, 0);
    }
#line 437
    if (tmp___2 < 0) {
      {
#line 438
      tmp___0 = __errno_location();
#line 438
      tmp___1 = strerror(*tmp___0);
#line 438
      die((char *)"Seek to %d failed: %s\n", sec->shdr.sh_offset, tmp___1);
      }
    }
    {
#line 441
    tmp___5 = fread((void */* __restrict  */)sec->strtab, (size_t )1, sec->shdr.sh_size,
                    (FILE */* __restrict  */)fp);
    }
#line 441
    if (tmp___5 != sec->shdr.sh_size) {
      {
#line 443
      tmp___3 = __errno_location();
#line 443
      tmp___4 = strerror(*tmp___3);
#line 443
      die((char *)"Cannot read symbol table: %s\n", tmp___4);
      }
    }
    __Cont: /* CIL Label */ 
#line 427
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 447
  return;
}
}
#line 449 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static void read_symtabs___0(FILE *fp ) 
{ 
  int i ;
  int j ;
  struct section___0 *sec ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  Elf64_Sym *sym ;

  {
#line 452
  i = 0;
  {
#line 452
  while (1) {
    while_continue: /* CIL Label */ ;
#line 452
    if (! (i < (int )ehdr___0.e_shnum)) {
#line 452
      goto while_break;
    }
#line 453
    sec = secs___0 + i;
#line 454
    if (sec->shdr.sh_type != 2U) {
#line 455
      goto __Cont;
    }
    {
#line 457
    tmp = malloc(sec->shdr.sh_size);
#line 457
    sec->symtab = (Elf64_Sym *)tmp;
    }
#line 458
    if (! sec->symtab) {
      {
#line 459
      die((char *)"malloc of %d bytes for symtab failed\n", sec->shdr.sh_size);
      }
    }
    {
#line 462
    tmp___2 = fseek(fp, (long )sec->shdr.sh_offset, 0);
    }
#line 462
    if (tmp___2 < 0) {
      {
#line 463
      tmp___0 = __errno_location();
#line 463
      tmp___1 = strerror(*tmp___0);
#line 463
      die((char *)"Seek to %d failed: %s\n", sec->shdr.sh_offset, tmp___1);
      }
    }
    {
#line 466
    tmp___5 = fread((void */* __restrict  */)sec->symtab, (size_t )1, sec->shdr.sh_size,
                    (FILE */* __restrict  */)fp);
    }
#line 466
    if (tmp___5 != sec->shdr.sh_size) {
      {
#line 468
      tmp___3 = __errno_location();
#line 468
      tmp___4 = strerror(*tmp___3);
#line 468
      die((char *)"Cannot read symbol table: %s\n", tmp___4);
      }
    }
#line 471
    j = 0;
    {
#line 471
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 471
      if (! ((Elf64_Xword )j < sec->shdr.sh_size / sizeof(Elf64_Sym ))) {
#line 471
        goto while_break___0;
      }
      {
#line 472
      sym = sec->symtab + j;
#line 473
      sym->st_name = elf32_to_cpu___0(sym->st_name);
#line 474
      sym->st_value = elf64_to_cpu(sym->st_value);
#line 475
      sym->st_size = elf64_to_cpu(sym->st_size);
#line 476
      sym->st_shndx = elf16_to_cpu___0(sym->st_shndx);
#line 471
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 452
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 479
  return;
}
}
#line 482 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static void read_relocs___0(FILE *fp ) 
{ 
  int i ;
  int j ;
  struct section___0 *sec ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  Elf64_Rela *rel ;
  uint64_t tmp___6 ;

  {
#line 485
  i = 0;
  {
#line 485
  while (1) {
    while_continue: /* CIL Label */ ;
#line 485
    if (! (i < (int )ehdr___0.e_shnum)) {
#line 485
      goto while_break;
    }
#line 486
    sec = secs___0 + i;
#line 487
    if (sec->shdr.sh_type != 4U) {
#line 488
      goto __Cont;
    }
    {
#line 490
    tmp = malloc(sec->shdr.sh_size);
#line 490
    sec->reltab = (Elf64_Rela *)tmp;
    }
#line 491
    if (! sec->reltab) {
      {
#line 492
      die((char *)"malloc of %d bytes for relocs failed\n", sec->shdr.sh_size);
      }
    }
    {
#line 495
    tmp___2 = fseek(fp, (long )sec->shdr.sh_offset, 0);
    }
#line 495
    if (tmp___2 < 0) {
      {
#line 496
      tmp___0 = __errno_location();
#line 496
      tmp___1 = strerror(*tmp___0);
#line 496
      die((char *)"Seek to %d failed: %s\n", sec->shdr.sh_offset, tmp___1);
      }
    }
    {
#line 499
    tmp___5 = fread((void */* __restrict  */)sec->reltab, (size_t )1, sec->shdr.sh_size,
                    (FILE */* __restrict  */)fp);
    }
#line 499
    if (tmp___5 != sec->shdr.sh_size) {
      {
#line 501
      tmp___3 = __errno_location();
#line 501
      tmp___4 = strerror(*tmp___3);
#line 501
      die((char *)"Cannot read symbol table: %s\n", tmp___4);
      }
    }
#line 504
    j = 0;
    {
#line 504
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 504
      if (! ((Elf64_Xword )j < sec->shdr.sh_size / sizeof(Elf64_Rela ))) {
#line 504
        goto while_break___0;
      }
      {
#line 505
      rel = sec->reltab + j;
#line 506
      rel->r_offset = elf64_to_cpu(rel->r_offset);
#line 507
      rel->r_info = elf64_to_cpu(rel->r_info);
#line 509
      tmp___6 = elf64_to_cpu((uint64_t )rel->r_addend);
#line 509
      rel->r_addend = (Elf64_Sxword )tmp___6;
#line 504
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 485
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 513
  return;
}
}
#line 516 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static void print_absolute_symbols___0(void) 
{ 
  int i ;
  char const   *format ;
  struct section___0 *sec ;
  char *sym_strtab ;
  int j ;
  Elf64_Sym *sym ;
  char const   *name ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 522
  format = "%5d %016lx %5ld %10s %10s %12s %s\n";
#line 526
  printf((char const   */* __restrict  */)"Absolute symbols\n");
#line 527
  printf((char const   */* __restrict  */)" Num:    Value Size  Type       Bind        Visibility  Name\n");
#line 528
  i = 0;
  }
  {
#line 528
  while (1) {
    while_continue: /* CIL Label */ ;
#line 528
    if (! (i < (int )ehdr___0.e_shnum)) {
#line 528
      goto while_break;
    }
#line 529
    sec = secs___0 + i;
#line 533
    if (sec->shdr.sh_type != 2U) {
#line 534
      goto __Cont;
    }
#line 536
    sym_strtab = (sec->link)->strtab;
#line 537
    j = 0;
    {
#line 537
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 537
      if (! ((Elf64_Xword )j < sec->shdr.sh_size / sizeof(Elf64_Sym ))) {
#line 537
        goto while_break___0;
      }
      {
#line 540
      sym = sec->symtab + j;
#line 541
      name = sym_name___0((char const   *)sym_strtab, sym);
      }
#line 542
      if ((int )sym->st_shndx != 65521) {
#line 543
        goto __Cont___0;
      }
      {
#line 545
      tmp = sym_visibility___0((unsigned int )((int )sym->st_other & 3));
#line 545
      tmp___0 = sym_bind___0((unsigned int )((int )sym->st_info >> 4));
#line 545
      tmp___1 = sym_type___0((unsigned int )((int )sym->st_info & 15));
#line 545
      printf((char const   */* __restrict  */)format, j, sym->st_value, sym->st_size,
             tmp___1, tmp___0, tmp, name);
      }
      __Cont___0: /* CIL Label */ 
#line 537
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 528
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 553
  printf((char const   */* __restrict  */)"\n");
  }
#line 554
  return;
}
}
#line 556 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static void print_absolute_relocs___0(void) 
{ 
  int i ;
  int printed ;
  char const   *format ;
  struct section___0 *sec ;
  struct section___0 *sec_applies ;
  struct section___0 *sec_symtab ;
  char *sym_strtab ;
  Elf64_Sym *sh_symtab ;
  int j ;
  Elf64_Rela *rel ;
  Elf64_Sym *sym ;
  char const   *name ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
#line 558
  printed = 0;
#line 562
  format = "%016lx %016lx %10s %016lx  %s\n";
#line 566
  i = 0;
  {
#line 566
  while (1) {
    while_continue: /* CIL Label */ ;
#line 566
    if (! (i < (int )ehdr___0.e_shnum)) {
#line 566
      goto while_break;
    }
#line 567
    sec = secs___0 + i;
#line 572
    if (sec->shdr.sh_type != 4U) {
#line 573
      goto __Cont;
    }
#line 575
    sec_symtab = sec->link;
#line 576
    sec_applies = secs___0 + sec->shdr.sh_info;
#line 577
    if (! (sec_applies->shdr.sh_flags & (unsigned long )(1 << 1))) {
#line 578
      goto __Cont;
    }
#line 580
    sh_symtab = sec_symtab->symtab;
#line 581
    sym_strtab = (sec_symtab->link)->strtab;
#line 582
    j = 0;
    {
#line 582
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 582
      if (! ((Elf64_Xword )j < sec->shdr.sh_size / sizeof(Elf64_Rela ))) {
#line 582
        goto while_break___0;
      }
      {
#line 586
      rel = sec->reltab + j;
#line 587
      sym = sh_symtab + (rel->r_info >> 32);
#line 588
      name = sym_name___0((char const   *)sym_strtab, sym);
      }
#line 589
      if ((int )sym->st_shndx != 65521) {
#line 590
        goto __Cont___0;
      }
      {
#line 606
      tmp = is_reloc___0((enum symtype )0, name);
      }
#line 606
      if (tmp) {
#line 607
        goto __Cont___0;
      } else {
        {
#line 606
        tmp___0 = is_reloc___0((enum symtype )1, name);
        }
#line 606
        if (tmp___0) {
#line 607
          goto __Cont___0;
        }
      }
#line 609
      if (! printed) {
        {
#line 610
        printf((char const   */* __restrict  */)"WARNING: Absolute relocations present\n");
#line 612
        printf((char const   */* __restrict  */)"Offset     Info     Type     Sym.Value Sym.Name\n");
#line 614
        printed = 1;
        }
      }
      {
#line 617
      tmp___1 = rel_type___0((unsigned int )(rel->r_info & 4294967295UL));
#line 617
      printf((char const   */* __restrict  */)format, rel->r_offset, rel->r_info,
             tmp___1, sym->st_value, name);
      }
      __Cont___0: /* CIL Label */ 
#line 582
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 566
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 626
  if (printed) {
    {
#line 627
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 628
  return;
}
}
#line 630 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static void add_reloc___0(struct relocs *r , uint32_t offset ) 
{ 
  unsigned long newsize ;
  void *mem ;
  void *tmp ;
  unsigned long tmp___0 ;

  {
#line 632
  if (r->count == r->size) {
    {
#line 633
    newsize = r->size + 50000UL;
#line 634
    tmp = realloc((void *)r->offset, newsize * sizeof(*(r->offset + 0)));
#line 634
    mem = tmp;
    }
#line 636
    if (! mem) {
      {
#line 637
      die((char *)"realloc of %ld entries for relocs failed\n", newsize);
      }
    }
#line 639
    r->offset = (uint32_t *)mem;
#line 640
    r->size = newsize;
  }
#line 642
  tmp___0 = r->count;
#line 642
  (r->count) ++;
#line 642
  *(r->offset + tmp___0) = offset;
#line 643
  return;
}
}
#line 645 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static void walk_relocs___0(int (*process)(struct section___0 *sec , Elf64_Rela *rel ,
                                           Elf64_Sym *sym , char const   *symname ) ) 
{ 
  int i ;
  char *sym_strtab ;
  Elf64_Sym *sh_symtab ;
  struct section___0 *sec_applies ;
  struct section___0 *sec_symtab ;
  int j ;
  struct section___0 *sec ;
  Elf64_Rela *rel ;
  Elf64_Sym *sym ;
  char const   *symname ;
  char const   *tmp ;

  {
#line 650
  i = 0;
  {
#line 650
  while (1) {
    while_continue: /* CIL Label */ ;
#line 650
    if (! (i < (int )ehdr___0.e_shnum)) {
#line 650
      goto while_break;
    }
#line 655
    sec = secs___0 + i;
#line 657
    if (sec->shdr.sh_type != 4U) {
#line 658
      goto __Cont;
    }
#line 660
    sec_symtab = sec->link;
#line 661
    sec_applies = secs___0 + sec->shdr.sh_info;
#line 662
    if (! (sec_applies->shdr.sh_flags & (unsigned long )(1 << 1))) {
#line 663
      goto __Cont;
    }
#line 665
    sh_symtab = sec_symtab->symtab;
#line 666
    sym_strtab = (sec_symtab->link)->strtab;
#line 667
    j = 0;
    {
#line 667
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 667
      if (! ((Elf64_Xword )j < sec->shdr.sh_size / sizeof(Elf64_Rela ))) {
#line 667
        goto while_break___0;
      }
      {
#line 668
      rel = sec->reltab + j;
#line 669
      sym = sh_symtab + (rel->r_info >> 32);
#line 670
      tmp = sym_name___0((char const   *)sym_strtab, sym);
#line 670
      symname = tmp;
#line 672
      (*process)(sec, rel, sym, symname);
#line 667
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 650
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 675
  return;
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static int per_cpu_shndx  =    -1;
#line 701 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static Elf64_Addr per_cpu_load_addr  ;
#line 703 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static void percpu_init(void) 
{ 
  int i ;
  Elf64_Sym *sym ;
  char const   *tmp ;
  int tmp___0 ;

  {
#line 706
  i = 0;
  {
#line 706
  while (1) {
    while_continue: /* CIL Label */ ;
#line 706
    if (! (i < (int )ehdr___0.e_shnum)) {
#line 706
      goto while_break;
    }
    {
#line 708
    tmp = sec_name___0((unsigned int )i);
#line 708
    tmp___0 = strcmp(tmp, ".data..percpu");
    }
#line 708
    if (tmp___0) {
#line 709
      goto __Cont;
    }
#line 711
    if ((secs___0 + i)->shdr.sh_addr != 0UL) {
#line 712
      return;
    }
    {
#line 714
    sym = sym_lookup___0("__per_cpu_load");
    }
#line 715
    if (! sym) {
      {
#line 716
      die((char *)"can\'t find __per_cpu_load\n");
      }
    }
#line 718
    per_cpu_shndx = i;
#line 719
    per_cpu_load_addr = sym->st_value;
#line 720
    return;
    __Cont: /* CIL Label */ 
#line 706
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 722
  return;
}
}
#line 741 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static int is_percpu_sym(Elf64_Sym *sym , char const   *symname ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 743
  if ((int )sym->st_shndx == per_cpu_shndx) {
    {
#line 743
    tmp = strcmp(symname, "__init_begin");
    }
#line 743
    if (tmp) {
      {
#line 743
      tmp___0 = strcmp(symname, "__per_cpu_load");
      }
#line 743
      if (tmp___0) {
        {
#line 743
        tmp___1 = strncmp(symname, "init_per_cpu_", (size_t )13);
        }
#line 743
        if (tmp___1) {
#line 743
          tmp___2 = 1;
        } else {
#line 743
          tmp___2 = 0;
        }
      } else {
#line 743
        tmp___2 = 0;
      }
    } else {
#line 743
      tmp___2 = 0;
    }
  } else {
#line 743
    tmp___2 = 0;
  }
#line 743
  return (tmp___2);
}
}
#line 750 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static int do_reloc64(struct section___0 *sec , Elf64_Rela *rel , Elf64_Sym *sym ,
                      char const   *symname ) 
{ 
  unsigned int r_type ;
  Elf64_Addr offset ;
  int shn_abs ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;

  {
#line 753
  r_type = (unsigned int )(rel->r_info & 4294967295UL);
#line 754
  offset = rel->r_offset;
#line 755
  if ((int )sym->st_shndx == 65521) {
    {
#line 755
    tmp = is_reloc___0((enum symtype )1, symname);
    }
#line 755
    if (tmp) {
#line 755
      tmp___0 = 0;
    } else {
#line 755
      tmp___0 = 1;
    }
  } else {
#line 755
    tmp___0 = 0;
  }
#line 755
  shn_abs = tmp___0;
#line 757
  if ((int )sym->st_shndx == 0) {
#line 758
    return (0);
  }
#line 763
  if (sec->shdr.sh_info == (Elf32_Word )per_cpu_shndx) {
#line 764
    offset += per_cpu_load_addr;
  }
  {
#line 767
  if (r_type == 0U) {
#line 767
    goto case_0;
  }
#line 771
  if (r_type == 2U) {
#line 771
    goto case_2;
  }
#line 782
  if (r_type == 1U) {
#line 782
    goto case_1;
  }
#line 782
  if (r_type == 11U) {
#line 782
    goto case_1;
  }
#line 782
  if (r_type == 10U) {
#line 782
    goto case_1;
  }
#line 817
  goto switch_default;
  case_0: /* CIL Label */ 
#line 769
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 776
  tmp___1 = is_percpu_sym(sym, symname);
  }
#line 776
  if (tmp___1) {
    {
#line 777
    add_reloc___0(& relocs32neg, (uint32_t )offset);
    }
  }
#line 778
  goto switch_break;
  case_1: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_10: /* CIL Label */ 
  {
#line 786
  tmp___2 = is_percpu_sym(sym, symname);
  }
#line 786
  if (tmp___2) {
#line 787
    goto switch_break;
  }
#line 789
  if (shn_abs) {
    {
#line 794
    tmp___3 = is_reloc___0((enum symtype )0, symname);
    }
#line 794
    if (tmp___3) {
#line 795
      goto switch_break;
    }
    {
#line 797
    tmp___4 = rel_type___0(r_type);
#line 797
    die((char *)"Invalid absolute %s relocation: %s\n", tmp___4, symname);
    }
#line 799
    goto switch_break;
  }
#line 808
  if ((int64_t )((int32_t )offset) != (int64_t )offset) {
    {
#line 809
    die((char *)"Relocation offset doesn\'t fit in 32 bits\n");
    }
  }
#line 811
  if (r_type == 1U) {
    {
#line 812
    add_reloc___0(& relocs64, (uint32_t )offset);
    }
  } else {
    {
#line 814
    add_reloc___0(& relocs32___0, (uint32_t )offset);
    }
  }
#line 815
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 818
  tmp___5 = rel_type___0(r_type);
#line 818
  die((char *)"Unsupported relocation type: %s (%d)\n", tmp___5, r_type);
  }
#line 820
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 823
  return (0);
}
}
#line 944 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static int cmp_relocs___0(void const   *va , void const   *vb ) 
{ 
  uint32_t const   *a ;
  uint32_t const   *b ;
  int tmp ;
  int tmp___0 ;

  {
#line 947
  a = (uint32_t const   *)va;
#line 947
  b = (uint32_t const   *)vb;
#line 948
  if (*a == *b) {
#line 948
    tmp___0 = 0;
  } else {
#line 948
    if (*a > *b) {
#line 948
      tmp = 1;
    } else {
#line 948
      tmp = -1;
    }
#line 948
    tmp___0 = tmp;
  }
#line 948
  return (tmp___0);
}
}
#line 951 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static void sort_relocs___0(struct relocs *r ) 
{ 


  {
  {
#line 953
  qsort((void *)r->offset, r->count, sizeof(*(r->offset + 0)), & cmp_relocs___0);
  }
#line 954
  return;
}
}
#line 956 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static int write32___0(uint32_t v , FILE *f ) 
{ 
  unsigned char buf[4] ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 960
  put_unaligned_le32(v, (void *)(buf));
#line 961
  tmp___1 = fwrite((void const   */* __restrict  */)(buf), (size_t )1, (size_t )4,
                   (FILE */* __restrict  */)f);
  }
#line 961
  if (tmp___1 == 4UL) {
#line 961
    tmp___0 = 0;
  } else {
#line 961
    tmp___0 = -1;
  }
#line 961
  return (tmp___0);
}
}
#line 964 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static int write32_as_text___0(uint32_t v , FILE *f ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 966
  tmp___1 = fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\t.long 0x%08x\n",
                    v);
  }
#line 966
  if (tmp___1 > 0) {
#line 966
    tmp___0 = 0;
  } else {
#line 966
    tmp___0 = -1;
  }
#line 966
  return (tmp___0);
}
}
#line 969 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static void emit_relocs___0(int as_text , int use_real_mode ) 
{ 
  int i ;
  int (*write_reloc)(uint32_t  , FILE * ) ;
  int (*do_reloc)(struct section___0 *sec , Elf64_Rela *rel , Elf64_Sym *sym , char const   *symname ) ;

  {
#line 972
  write_reloc = & write32___0;
#line 977
  if (! use_real_mode) {
#line 978
    do_reloc = & do_reloc64;
  } else {
    {
#line 980
    die((char *)"--realmode not valid for a 64-bit ELF file");
    }
  }
  {
#line 989
  walk_relocs___0(do_reloc);
  }
#line 991
  if (relocs16___0.count) {
#line 991
    if (! use_real_mode) {
      {
#line 992
      die((char *)"Segment relocations found but --realmode not specified\n");
      }
    }
  }
  {
#line 995
  sort_relocs___0(& relocs16___0);
#line 996
  sort_relocs___0(& relocs32___0);
#line 998
  sort_relocs___0(& relocs32neg);
#line 999
  sort_relocs___0(& relocs64);
  }
#line 1003
  if (as_text) {
    {
#line 1007
    printf((char const   */* __restrict  */)".section \".data.reloc\",\"a\"\n");
#line 1008
    printf((char const   */* __restrict  */)".balign 4\n");
#line 1009
    write_reloc = & write32_as_text___0;
    }
  }
#line 1012
  if (use_real_mode) {
    {
#line 1013
    (*write_reloc)((uint32_t )relocs16___0.count, stdout);
#line 1014
    i = 0;
    }
    {
#line 1014
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1014
      if (! ((unsigned long )i < relocs16___0.count)) {
#line 1014
        goto while_break;
      }
      {
#line 1015
      (*write_reloc)(*(relocs16___0.offset + i), stdout);
#line 1014
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1017
    (*write_reloc)((uint32_t )relocs32___0.count, stdout);
#line 1018
    i = 0;
    }
    {
#line 1018
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1018
      if (! ((unsigned long )i < relocs32___0.count)) {
#line 1018
        goto while_break___0;
      }
      {
#line 1019
      (*write_reloc)(*(relocs32___0.offset + i), stdout);
#line 1018
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 1023
    (*write_reloc)((uint32_t )0, stdout);
#line 1026
    i = 0;
    }
    {
#line 1026
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1026
      if (! ((unsigned long )i < relocs64.count)) {
#line 1026
        goto while_break___1;
      }
      {
#line 1027
      (*write_reloc)(*(relocs64.offset + i), stdout);
#line 1026
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1030
    (*write_reloc)((uint32_t )0, stdout);
#line 1033
    i = 0;
    }
    {
#line 1033
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1033
      if (! ((unsigned long )i < relocs32neg.count)) {
#line 1033
        goto while_break___2;
      }
      {
#line 1034
      (*write_reloc)(*(relocs32neg.offset + i), stdout);
#line 1033
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1038
    (*write_reloc)((uint32_t )0, stdout);
#line 1041
    i = 0;
    }
    {
#line 1041
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1041
      if (! ((unsigned long )i < relocs32___0.count)) {
#line 1041
        goto while_break___3;
      }
      {
#line 1042
      (*write_reloc)(*(relocs32___0.offset + i), stdout);
#line 1041
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 1044
  return;
}
}
#line 1052 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static int do_reloc_info___0(struct section___0 *sec , Elf64_Rela *rel , Elf64_Sym *sym ,
                             char const   *symname ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 1055
  tmp = sec_name___0((unsigned int )sym->st_shndx);
#line 1055
  tmp___0 = rel_type___0((unsigned int )(rel->r_info & 4294967295UL));
#line 1055
  tmp___1 = sec_name___0(sec->shdr.sh_info);
#line 1055
  printf((char const   */* __restrict  */)"%s\t%s\t%s\t%s\n", tmp___1, tmp___0, symname,
         tmp);
  }
#line 1060
  return (0);
}
}
#line 1063 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
static void print_reloc_info___0(void) 
{ 


  {
  {
#line 1065
  printf((char const   */* __restrict  */)"reloc section\treloc type\tsymbol\tsymbol section\n");
#line 1066
  walk_relocs___0(& do_reloc_info___0);
  }
#line 1067
  return;
}
}
#line 1075 "/home/june/repo/benchmarks/collector/temp/linux-lts-vivid-3.19.0/arch/x86/tools/relocs.c"
void process_64(FILE *fp , int use_real_mode , int as_text , int show_absolute_syms ,
                int show_absolute_relocs , int show_reloc_info ) 
{ 


  {
  {
#line 1079
  regex_init___0(use_real_mode);
#line 1080
  read_ehdr___0(fp);
#line 1081
  read_shdrs___0(fp);
#line 1082
  read_strtabs___0(fp);
#line 1083
  read_symtabs___0(fp);
#line 1084
  read_relocs___0(fp);
#line 1086
  percpu_init();
  }
#line 1087
  if (show_absolute_syms) {
    {
#line 1088
    print_absolute_symbols___0();
    }
#line 1089
    return;
  }
#line 1091
  if (show_absolute_relocs) {
    {
#line 1092
    print_absolute_relocs___0();
    }
#line 1093
    return;
  }
#line 1095
  if (show_reloc_info) {
    {
#line 1096
    print_reloc_info___0();
    }
#line 1097
    return;
  }
  {
#line 1099
  emit_relocs___0(as_text, use_real_mode);
  }
#line 1100
  return;
}
}
