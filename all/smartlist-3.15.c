/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 65 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 77 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.h"
struct varstr {
   char const   * const  sname ;
   char const   *sval ;
};
#line 86 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off_t off_t;
#line 514 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/includes.h"
typedef unsigned char uschar;
#line 104 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.h"
struct dyna_long;
#line 20 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/cstdio.h"
struct dynstring;
#line 3 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.h"
union __anonunion_vals_55 {
   int i ;
   off_t o ;
   long l ;
};
#line 3 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.h"
struct dyna_long {
   int filled ;
   int tspace ;
   union __anonunion_vals_55 *vals ;
};
#line 4 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.h"
struct dynstring {
   struct dynstring *enext ;
   char ename[255] ;
};
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 68 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.h"
struct varval {
   char const   * const  name ;
   long val ;
};
#line 3 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/regexp.h"
union seps {
   struct eps *awn ;
   int sopc ;
   void *irrelevoid ;
};
#line 3 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/regexp.h"
struct eps {
   unsigned int opc ;
   struct eps *next ;
   union seps sp ;
};
#line 80 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/regexp.c"
struct __anonstruct_aleps_56 {
   unsigned int topc ;
   union seps au ;
};
#line 85 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/regexp.c"
union __anonunion_nextj__57 {
   struct eps *nextj ;
   void *Irrelevoid ;
};
#line 85 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/regexp.c"
struct jump {
   unsigned int opcj_ ;
   union __anonunion_nextj__57 nextj_ ;
};
#line 86 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/regexp.c"
struct evoi {
   struct eps *st_ ;
   void const   *wh_ ;
};
#line 86 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/regexp.c"
struct mchar {
   unsigned int opcc_ ;
   struct eps *next1_ ;
   struct evoi p1_ ;
   struct evoi p2_ ;
};
#line 88 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/regexp.c"
struct chclass {
   unsigned int opc_ ;
   struct eps *next_ ;
   struct evoi pos1 ;
   struct evoi pos2 ;
   unsigned int c[(((unsigned long )(1 << 8) + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL)] ;
};
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 42 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 6 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/authenticate.h"
struct auth_identity;
#line 6 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/authenticate.h"
typedef struct auth_identity auth_identity;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __off_t l_start ;
   __off_t l_len ;
   __pid_t l_pid ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 48 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
struct utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char __domainname[65] ;
};
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 51 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/authenticate.c"
struct auth_identity {
   struct passwd  const  *pw ;
   char *mbox ;
   int sock ;
};
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 257 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 761 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
struct __anonstruct_regsp_63 {
   char const   *regkey ;
   char const   *regsubst ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_terminated_22 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_stopped_23 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_22 __wait_terminated ;
   struct __anonstruct___wait_stopped_23 __wait_stopped ;
};
#line 74 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/common.c"
union __anonunion_56 {
   int __in ;
   int __i ;
};
#line 79 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/common.c"
union __anonunion_57 {
   int __in ;
   int __i ;
};
#line 79 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/common.c"
union __anonunion_58 {
   int __in ;
   int __i ;
};
#line 79 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/common.c"
union __anonunion_59 {
   int __in ;
   int __i ;
};
#line 79 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/common.c"
union __anonunion_60 {
   int __in ;
   int __i ;
};
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 59 "/usr/include/time.h"
typedef __clock_t clock_t;
#line 71 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/sublib.c"
typedef unsigned int chartype;
#line 326 "/usr/include/netdb.h"
struct protoent {
   char *p_name ;
   char **p_aliases ;
   int p_proto ;
};
#line 473 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chown)(char const   *__file ,
                                                                                            __uid_t __owner ,
                                                                                            __gid_t __group ) ;
#line 717
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgid)(__gid_t __gid ) ;
#line 180 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 263
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 284
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
#line 321
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 190 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 77 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.h"
struct varstr strenstr[10] ;
#line 94
char *buf ;
#line 94
char *buf2 ;
#line 95
char const   dirsep[2] ;
#line 95
char const   empty[1] ;
#line 95
char const   lgname[8] ;
#line 95
char const   *defdeflock ;
#line 95
char const   slogstr[8] ;
#line 101 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.h"
int accspooldir  ;
#line 105
size_t linebuf ;
#line 108
uid_t uid ;
#line 109
gid_t gid ;
#line 109
gid_t sgid ;
#line 13 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.h"
void elog(char const   * const  newt ) ;
#line 13
void checkroot(int const   c , unsigned long const   Xid ) ;
#line 13
void setids(void) ;
#line 13
void nlog(char const   * const  a ) ;
#line 13
void logqnl(char const   * const  a ) ;
#line 13
void skipped(char const   * const  x ) ;
#line 13
void Terminate(void) ;
#line 13
void suspend(void) ;
#line 13
void rcst_nosgid(void) ;
#line 61
char *tstrdup(char const   * const  a ) ;
#line 3 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/lastdirsep.h"
char *lastdirsep(char const   *filename___0 ) ;
#line 3 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/robust.h"
void doumask(mode_t const   mask ) ;
#line 22
mode_t cumask ;
#line 17 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/foldinfo.h"
int foldertype(int type , int forcedir , mode_t * const  modep , struct stat * const  paranoid ) ;
#line 17
int screenmailbox(char *chp , gid_t const   egid , int const   Deliverymode ) ;
#line 22
char const   maildirnew[5] ;
#line 19 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/foldinfo.c"
static char const   maildirtmp[5]  = {      (char const   )'/',      (char const   )'t',      (char const   )'m',      (char const   )'p', 
        (char const   )'\000'};
#line 19 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/foldinfo.c"
static char const   maildircur[5]  = {      (char const   )'/',      (char const   )'c',      (char const   )'u',      (char const   )'r', 
        (char const   )'\000'};
#line 21 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/foldinfo.c"
char const   maildirnew[5]  = {      (char const   )'/',      (char const   )'n',      (char const   )'e',      (char const   )'w', 
        (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/foldinfo.c"
static int folderparse(void) 
{ 
  char *chp ;
  int type ;
  char *tmp ;

  {
  {
#line 29
  type = 3;
#line 29
  chp = strchr((char const   *)buf, '\000');
  }
  {
#line 31
  if (chp - buf == 2L) {
#line 31
    goto case_2;
  }
#line 34
  if (chp - buf == 1L) {
#line 34
    goto case_1;
  }
#line 34
  if (chp - buf == 0L) {
#line 34
    goto case_1;
  }
#line 30
  goto switch_break;
  case_2: /* CIL Label */ 
#line 32
  if ((int )*(chp + -1) == (int )*((dirsep + (sizeof("/") - 1UL)) - 1)) {
#line 33
    chp --;
#line 33
    type = 1;
  }
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 35
  goto ret;
  switch_break: /* CIL Label */ ;
  }
#line 37
  if ((int )*(chp + -1) == 46) {
#line 37
    if ((int )*(chp + -2) == (int )*((dirsep + (sizeof("/") - 1UL)) - 1)) {
#line 38
      chp -= 2;
#line 38
      type = 2;
    } else {
#line 37
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 39
  if ((int )*(chp + -1) == (int )*((dirsep + (sizeof("/") - 1UL)) - 1)) {
#line 40
    chp --;
#line 40
    type = 1;
  } else {
#line 42
    goto ret;
  }
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    if ((unsigned long )(chp - 1) > (unsigned long )buf) {
      {
#line 43
      tmp = strchr(dirsep, (int )*(chp + -1));
      }
#line 43
      if (! tmp) {
#line 43
        goto while_break;
      }
    } else {
#line 43
      goto while_break;
    }
#line 44
    chp --;
  }
  while_break: /* CIL Label */ ;
  }
  ret: 
#line 46
  *chp = (char )'\000';
#line 47
  return (type);
}
}
#line 52
int rnmbogus(char const   * const  name___1 , struct stat  const  * const  stbuf ,
             int const   i___0 , int const   dolog ) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/foldinfo.c"
static char const   renbogus[29]  = 
#line 52
  {      (char const   )'R',      (char const   )'e',      (char const   )'n',      (char const   )'a', 
        (char const   )'m',      (char const   )'e',      (char const   )'d',      (char const   )' ', 
        (char const   )'b',      (char const   )'o',      (char const   )'g',      (char const   )'u', 
        (char const   )'s',      (char const   )' ',      (char const   )'\"',      (char const   )'%', 
        (char const   )'s',      (char const   )'\"',      (char const   )' ',      (char const   )'i', 
        (char const   )'n',      (char const   )'t',      (char const   )'o',      (char const   )' ', 
        (char const   )'\"',      (char const   )'%',      (char const   )'s',      (char const   )'\"', 
        (char const   )'\000'};
#line 52 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/foldinfo.c"
static char const   renfbogus[37]  = 
#line 52
  {      (char const   )'C',      (char const   )'o',      (char const   )'u',      (char const   )'l', 
        (char const   )'d',      (char const   )'n',      (char const   )'\'',      (char const   )'t', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'n', 
        (char const   )'a',      (char const   )'m',      (char const   )'e',      (char const   )' ', 
        (char const   )'b',      (char const   )'o',      (char const   )'g',      (char const   )'u', 
        (char const   )'s',      (char const   )' ',      (char const   )'\"',      (char const   )'%', 
        (char const   )'s',      (char const   )'\"',      (char const   )' ',      (char const   )'i', 
        (char const   )'n',      (char const   )'t',      (char const   )'o',      (char const   )' ', 
        (char const   )'\"',      (char const   )'%',      (char const   )'s',      (char const   )'\"', 
        (char const   )'\000'};
#line 52 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/foldinfo.c"
static char const   bogusprefix[7]  = {      (char const   )'B',      (char const   )'O',      (char const   )'G',      (char const   )'U', 
        (char const   )'S',      (char const   )'.',      (char const   )'\000'};
#line 57
char *ultoan(unsigned long val , char *dest ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/foldinfo.c"
int rnmbogus(char const   * const  name___1 , struct stat  const  * const  stbuf ,
             int const   i___0 , int const   dolog ) 
{ 
  char *p___0 ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 55
  tmp = getenv(lgname);
#line 55
  tmp___0 = strcpy((char */* __restrict  */)(buf2 + i___0), (char const   */* __restrict  */)(bogusprefix));
#line 55
  tmp___1 = strcpy((char */* __restrict  */)(tmp___0 + (sizeof(bogusprefix) - 1UL)),
                   (char const   */* __restrict  */)tmp);
#line 55
  p___0 = strchr((char const   *)tmp___1, '\000');
#line 57
  tmp___2 = p___0;
#line 57
  p___0 ++;
#line 57
  *tmp___2 = (char )'.';
#line 57
  ultoan((unsigned long )stbuf->st_ino, p___0);
  }
#line 58
  if (dolog) {
    {
#line 59
    nlog((char const   */* const  */)"Renaming bogus mailbox \"");
#line 59
    elog(name___1);
#line 59
    elog((char const   */* const  */)"\" info");
#line 60
    logqnl((char const   */* const  */)buf2);
    }
  }
  {
#line 62
  tmp___3 = rename((char const   *)name___1, (char const   *)buf2);
  }
#line 62
  if (tmp___3) {
    {
#line 63
    syslog(1, renfbogus, name___1, buf2);
    }
#line 64
    return (1);
  }
  {
#line 66
  syslog(2, renbogus, name___1, buf2);
  }
#line 67
  return (0);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/foldinfo.c"
static mode_t trymkdir(char const   * const  dir , int const   paranoid , int const   i___0 ) 
{ 
  struct stat stbuf ;
  int tries ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 75
  tries = 2;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (paranoid) {
      {
#line 77
      tmp___3 = lstat((char const   */* __restrict  */)dir, (struct stat */* __restrict  */)(& stbuf));
#line 77
      tmp___5 = tmp___3;
      }
    } else {
      {
#line 77
      tmp___4 = stat((char const   */* __restrict  */)dir, (struct stat */* __restrict  */)(& stbuf));
#line 77
      tmp___5 = tmp___4;
      }
    }
#line 77
    if (tmp___5) {
      {
#line 86
      tmp___2 = __errno_location();
      }
#line 86
      if (*tmp___2 != 2) {
#line 87
        goto while_break;
      } else {
        {
#line 88
        tmp___1 = mkdir((char const   *)dir, (__mode_t )((448 | (448 >> 3)) | ((448 >> 3) >> 3)));
        }
#line 88
        if (! tmp___1) {
#line 89
          if (! paranoid) {
#line 90
            return (16384U | ((unsigned int )((448 | (448 >> 3)) | ((448 >> 3) >> 3)) & ~ cumask));
          }
#line 91
          tries ++;
        }
      }
    } else
#line 78
    if (! paranoid) {
#line 82
      return (stbuf.st_mode);
    } else
#line 78
    if ((stbuf.st_mode & 61440U) == 16384U) {
#line 78
      if (stbuf.st_uid == uid) {
#line 82
        return (stbuf.st_mode);
      } else
#line 78
      if (! stbuf.st_uid) {
        {
#line 78
        tmp___0 = chown((char const   *)dir, uid, sgid);
        }
#line 78
        if (tmp___0) {
#line 78
          goto _L;
        } else {
#line 82
          return (stbuf.st_mode);
        }
      } else {
#line 78
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 83
      tmp = rnmbogus(dir, (struct stat  const  */* const  */)(& stbuf), i___0, (int const   )1);
      }
#line 83
      if (tmp) {
#line 84
        goto while_break;
      }
    }
#line 76
    tmp___6 = tries;
#line 76
    tries --;
#line 76
    if (! (tmp___6 > 0)) {
#line 76
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  return ((mode_t )0);
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/foldinfo.c"
static int mkmaildir(char * const  buffer , char * const  chp , int const   paranoid ) 
{ 
  mode_t mode ;
  int i___0 ;
  int tmp ;

  {
#line 100
  if (paranoid) {
    {
#line 101
    i___0 = (int )((chp - buffer) + 1L);
#line 101
    strncpy((char */* __restrict  */)buf2, (char const   */* __restrict  */)buffer,
            (size_t )i___0);
#line 101
    *(buf2 + (i___0 - 1)) = (char )*((dirsep + (sizeof("/") - 1UL)) - 1);
#line 101
    *(buf2 + i___0) = (char )'\000';
    }
  }
  {
#line 102
  strcpy((char */* __restrict  */)chp, (char const   */* __restrict  */)(maildirnew));
#line 102
  mode = trymkdir((char const   */* const  */)buffer, paranoid, (int const   )i___0);
  }
#line 102
  if ((mode & 61440U) == 16384U) {
    {
#line 102
    strcpy((char */* __restrict  */)chp, (char const   */* __restrict  */)(maildircur));
#line 102
    mode = trymkdir((char const   */* const  */)buffer, paranoid, (int const   )i___0);
    }
#line 102
    if ((mode & 61440U) == 16384U) {
      {
#line 102
      strcpy((char */* __restrict  */)chp, (char const   */* __restrict  */)(maildirtmp));
#line 102
      mode = trymkdir((char const   */* const  */)buffer, paranoid, (int const   )i___0);
      }
#line 102
      if ((mode & 61440U) == 16384U) {
#line 102
        tmp = 1;
      } else {
#line 102
        tmp = 0;
      }
    } else {
#line 102
      tmp = 0;
    }
  } else {
#line 102
    tmp = 0;
  }
#line 102
  return (tmp);
}
}
#line 133
void ltstr(int const   minwidth , long const   val , char *dest ) ;
#line 108 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/foldinfo.c"
int foldertype(int type , int forcedir , mode_t * const  modep , struct stat * const  paranoid ) 
{ 
  struct stat stbuf ;
  mode_t mode ;
  int i___0 ;
  char *chp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 111
  if (! type) {
    {
#line 112
    type = folderparse();
    }
  }
  {
#line 114
  if (type == 1) {
#line 114
    goto case_1;
  }
#line 115
  if (type == 2) {
#line 115
    goto case_2;
  }
#line 116
  if (type == 3) {
#line 116
    goto case_3;
  }
#line 131
  goto switch_default;
  case_1: /* CIL Label */ 
#line 114
  i___0 = (int )(sizeof("/new") - 1UL);
#line 114
  goto switch_break;
  case_2: /* CIL Label */ 
#line 115
  i___0 = 0;
#line 115
  goto switch_break;
  case_3: /* CIL Label */ 
#line 117
  i___0 = 0;
#line 118
  if (! forcedir) {
#line 119
    if (paranoid) {
      {
#line 119
      tmp = lstat((char const   */* __restrict  */)buf, (struct stat */* __restrict  */)(& stbuf));
#line 119
      tmp___1 = tmp;
      }
    } else {
      {
#line 119
      tmp___0 = stat((char const   */* __restrict  */)buf, (struct stat */* __restrict  */)(& stbuf));
#line 119
      tmp___1 = tmp___0;
      }
    }
#line 119
    if (tmp___1) {
#line 120
      if (paranoid) {
#line 121
        type = -3;
#line 122
        goto ret;
      }
#line 124
      goto newfile;
    } else {
#line 126
      mode = stbuf.st_mode;
#line 126
      if (! ((mode & 61440U) == 16384U)) {
#line 127
        goto file;
      }
    }
  }
#line 129
  type = 4;
#line 130
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 132
  nlog((char const   */* const  */)"Internal error: improper type (");
#line 133
  ltstr(0, type, buf2);
#line 133
  elog((char const   */* const  */)buf2);
#line 134
  elog((char const   */* const  */)") passed to foldertype for folder ");
#line 134
  logqnl((char const   */* const  */)buf);
#line 135
  Terminate();
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 137
  chp = strchr((char const   *)buf, '\000');
  }
#line 138
  if ((size_t )((((chp - buf) + 24L) + 1L) + (long )i___0) > linebuf) {
#line 139
    type = -1;
#line 140
    goto ret;
  }
#line 142
  if (type == 4) {
#line 142
    if (! forcedir) {
#line 143
      goto done;
    }
  }
#line 144
  if (paranoid) {
    {
#line 145
    tmp___2 = lastdirsep((char const   *)buf);
#line 145
    i___0 = (int )(tmp___2 - buf);
#line 145
    strncpy((char */* __restrict  */)buf2, (char const   */* __restrict  */)buf, (size_t )i___0);
#line 145
    *(buf2 + i___0) = (char )'\000';
    }
  }
  {
#line 146
  mode = trymkdir((char const   */* const  */)buf, (int const   )((unsigned long )paranoid != (unsigned long )((struct stat */* const  */)0)),
                  (int const   )i___0);
  }
#line 147
  if (! ((mode & 61440U) == 16384U)) {
#line 147
    goto _L;
  } else
#line 147
  if (type == 1) {
    {
#line 147
    forcedir = 1;
#line 147
    tmp___3 = mkmaildir((char */* const  */)buf, (char */* const  */)chp, (int const   )((unsigned long )paranoid != (unsigned long )((struct stat */* const  */)0)));
    }
#line 147
    if (tmp___3) {
#line 147
      tmp___4 = 0;
    } else {
#line 147
      tmp___4 = 1;
    }
#line 147
    if (tmp___4) {
      _L: /* CIL Label */ 
      {
#line 149
      nlog((char const   */* const  */)"Unable to treat as directory");
#line 149
      logqnl((char const   */* const  */)buf);
      }
#line 150
      if (forcedir) {
        {
#line 151
        *chp = (char )'\000';
#line 151
        skipped((char const   */* const  */)buf);
#line 151
        type = -2;
        }
#line 152
        goto ret;
      }
#line 154
      if (! mode) {
        newfile: 
#line 155
        mode = 32768U | ((unsigned int )(((((384 | (256 >> 3)) | (128 >> 3)) | ((256 >> 3) >> 3)) | ((128 >> 3) >> 3)) | ((64 >> 3) >> 3)) & ~ cumask);
      }
      file: 
#line 156
      type = 3;
    }
  }
  done: 
#line 159
  if (paranoid) {
#line 160
    *paranoid = stbuf;
  } else {
#line 162
    *modep = mode;
  }
  ret: 
#line 164
  return (type);
}
}
#line 269 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/foldinfo.c"
static char const   enfperm[34]  = 
#line 269
  {      (char const   )'E',      (char const   )'n',      (char const   )'f',      (char const   )'o', 
        (char const   )'r',      (char const   )'c',      (char const   )'i',      (char const   )'n', 
        (char const   )'g',      (char const   )' ',      (char const   )'s',      (char const   )'t', 
        (char const   )'r',      (char const   )'i',      (char const   )'c',      (char const   )'t', 
        (char const   )'e',      (char const   )'r',      (char const   )' ',      (char const   )'p', 
        (char const   )'e',      (char const   )'r',      (char const   )'m',      (char const   )'i', 
        (char const   )'s',      (char const   )'s',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )'s',      (char const   )' ',      (char const   )'o', 
        (char const   )'n',      (char const   )'\000'};
#line 280
int xcreat(char const   * const  name___1 , mode_t const   mode , time_t * const  tim ,
           int const   chownit ) ;
#line 168 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/foldinfo.c"
int screenmailbox(char *chp , gid_t const   egid , int const   Deliverymode ) 
{ 
  char ch ;
  struct stat stbuf ;
  int type ;
  unsigned int wwsdir ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int checkiter ;
  int i___0 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  mode_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int isgrpwrite ;
  char *tmp___14 ;
  int i___1 ;
  char *tmp___15 ;
  int tmp___16 ;

  {
  {
#line 174
  accspooldir = 3;
#line 175
  sgid = gid;
#line 176
  strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)chp);
#line 177
  type = folderparse();
  }
#line 178
  if ((int )*(buf + 0) == 0) {
#line 179
    return (0);
  }
  {
#line 180
  chp = lastdirsep((char const   *)buf);
#line 180
  ch = *chp;
  }
#line 181
  if ((unsigned long )chp > (unsigned long )buf) {
#line 182
    *chp = (char )'\000';
  }
  {
#line 183
  tmp___0 = stat((char const   */* __restrict  */)buf, (struct stat */* __restrict  */)(& stbuf));
  }
#line 183
  if (tmp___0) {
    {
#line 205
    setids();
#line 205
    mkdir((char const   *)buf, (__mode_t )((448 | (448 >> 3)) | ((448 >> 3) >> 3)));
    }
  } else {
#line 185
    wwsdir = (unsigned int )((((unsigned int )((((128 >> 3) | (64 >> 3)) | ((128 >> 3) >> 3)) | ((64 >> 3) >> 3)) & stbuf.st_mode) == (unsigned int )(((((128 >> 3) | (64 >> 3)) | ((128 >> 3) >> 3)) | ((64 >> 3) >> 3)) << 1)) | (uid == stbuf.st_uid));
#line 185
    accspooldir = (int )wwsdir;
#line 190
    if (accspooldir) {
      {
#line 191
      rcst_nosgid();
      }
    }
#line 192
    if (uid != stbuf.st_uid) {
#line 192
      if (stbuf.st_mode & 1024U) {
#line 192
        goto _L___0;
      } else
#line 192
      if (! wwsdir) {
        _L___0: /* CIL Label */ 
#line 194
        if (stbuf.st_gid == (__gid_t )egid) {
          {
#line 195
          doumask(((448 >> 3) | ((448 >> 3) >> 3)) & ~ (448 >> 3));
          }
        }
#line 196
        goto keepgid;
      } else {
#line 192
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 198
    if (stbuf.st_mode & 1024U) {
      keepgid: 
#line 200
      sgid = stbuf.st_gid;
#line 200
      if (sgid != (gid_t )egid) {
        {
#line 200
        tmp = setgid(sgid);
        }
#line 200
        if (tmp) {
          {
#line 202
          checkroot((int const   )'g', (unsigned long const   )((unsigned long )sgid));
          }
        }
      }
    }
  }
  {
#line 207
  *chp = ch;
#line 213
  tmp___1 = strchr((char const   *)buf, '\000');
#line 213
  chp = tmp___1 - 1;
  }
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 215
    type = foldertype(type, 0, (mode_t */* const  */)0, (struct stat */* const  */)(& stbuf));
    }
#line 216
    if (type == -3) {
      {
#line 217
      tmp___2 = __errno_location();
      }
#line 217
      if (*tmp___2 != 13) {
#line 218
        goto nobox;
      } else {
        {
#line 217
        setids();
#line 217
        tmp___3 = lstat((char const   */* __restrict  */)buf, (struct stat */* __restrict  */)(& stbuf));
        }
#line 217
        if (tmp___3) {
#line 218
          goto nobox;
        }
      }
    } else
#line 220
    if (! (type > 2)) {
      {
#line 221
      setids();
      }
#line 222
      if (type < 0) {
#line 223
        goto fishy;
      }
#line 224
      goto nl;
    }
#line 235
    checkiter = 1;
    {
#line 236
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 237
      if (stbuf.st_uid != uid) {
#line 237
        goto _L___1;
      } else
#line 237
      if (! (stbuf.st_mode & 128U)) {
#line 237
        goto _L___1;
      } else
#line 237
      if ((stbuf.st_mode & 61440U) == 40960U) {
#line 237
        goto _L___1;
      } else {
#line 237
        if ((stbuf.st_mode & 61440U) == 16384U) {
#line 237
          tmp___7 = ! (stbuf.st_mode & 64U);
        } else {
#line 237
          tmp___7 = stbuf.st_nlink != 1UL;
        }
#line 237
        if (tmp___7) {
          _L___1: /* CIL Label */ 
#line 246
          tmp___6 = checkiter;
#line 246
          checkiter --;
#line 246
          if (tmp___6) {
            {
#line 247
            suspend();
            }
          } else {
            {
#line 249
            tmp___4 = lastdirsep((char const   *)buf);
#line 249
            i___0 = (int )(tmp___4 - buf);
#line 250
            strncpy((char */* __restrict  */)buf2, (char const   */* __restrict  */)buf,
                    (size_t )i___0);
#line 250
            *(buf2 + i___0) = (char )'\000';
#line 251
            tmp___5 = rnmbogus((char const   */* const  */)buf, (struct stat  const  */* const  */)(& stbuf),
                               (int const   )i___0, (int const   )1);
            }
#line 251
            if (tmp___5) {
#line 252
              goto fishy;
            }
#line 253
            goto nobox;
          }
        } else {
#line 256
          goto while_break___0;
        }
      }
      {
#line 257
      tmp___8 = lstat((char const   */* __restrict  */)buf, (struct stat */* __restrict  */)(& stbuf));
      }
#line 257
      if (tmp___8) {
#line 258
        goto nobox;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 260
    if (Deliverymode) {
#line 260
      if (stbuf.st_mode & 2048U) {
        {
#line 262
        nlog((char const   */* const  */)"Autoforwarding mailbox found\n");
#line 263
        exit(67);
        }
      } else
#line 260
      if (! ((stbuf.st_mode & 61440U) == 16384U)) {
#line 260
        if (stbuf.st_mode & 1024U) {
          {
#line 262
          nlog((char const   */* const  */)"Autoforwarding mailbox found\n");
#line 263
          exit(67);
          }
        } else {
#line 260
          goto _L___2;
        }
      } else {
#line 260
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
#line 266
      if (! (stbuf.st_mode & 3648U)) {
#line 266
        if (accspooldir) {
#line 266
          tmp___9 = ~ ((mode_t )0);
        } else {
#line 266
          tmp___9 = (mode_t )(~ ((256 >> 3) | (128 >> 3)));
        }
#line 266
        if ((stbuf.st_mode & cumask) & tmp___9) {
          {
#line 271
          nlog((char const   */* const  */)(enfperm));
#line 271
          logqnl((char const   */* const  */)buf);
#line 272
          syslog(5, slogstr, enfperm, buf);
#line 272
          setids();
#line 273
          stbuf.st_mode &= ~ cumask;
#line 273
          chmod((char const   *)buf, stbuf.st_mode);
          }
        }
      }
#line 275
      goto while_break;
    }
    nobox: 
#line 279
    if (! (accspooldir & 1)) {
      {
#line 280
      tmp___10 = xcreat(buf, ((((384 | (256 >> 3)) | (128 >> 3)) | ((256 >> 3) >> 3)) | ((128 >> 3) >> 3)) | ((64 >> 3) >> 3),
                        (time_t *)0, 3);
      }
#line 280
      if (! tmp___10) {
#line 281
        goto while_break;
      }
      {
#line 282
      tmp___11 = lstat((char const   */* __restrict  */)buf, (struct stat */* __restrict  */)(& stbuf));
      }
#line 282
      if (! tmp___11) {
#line 283
        goto __Cont;
      }
    }
    {
#line 285
    setids();
#line 286
    tmp___12 = xcreat(buf, ((((384 | (256 >> 3)) | (128 >> 3)) | ((256 >> 3) >> 3)) | ((128 >> 3) >> 3)) | ((64 >> 3) >> 3),
                      (time_t *)0, 2);
    }
#line 286
    if (! tmp___12) {
#line 287
      goto while_break;
    }
    {
#line 288
    tmp___13 = lstat((char const   */* __restrict  */)buf, (struct stat */* __restrict  */)(& stbuf));
    }
#line 288
    if (tmp___13) {
      fishy: 
      {
#line 290
      nlog((char const   */* const  */)"Couldn\'t create");
#line 290
      logqnl((char const   */* const  */)buf);
      }
#line 291
      return (0);
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 294
  if (! ((stbuf.st_mode & 61440U) == 16384U)) {
    {
#line 295
    isgrpwrite = (int )(stbuf.st_mode & (unsigned int )(128 >> 3));
#line 296
    chp = strchr((char const   *)buf, '\000');
#line 296
    strcpy((char */* __restrict  */)chp, (char const   */* __restrict  */)strenstr[1].sval);
#line 297
    tmp___14 = tstrdup((char const   */* const  */)buf);
#line 297
    defdeflock = (char const   *)tmp___14;
    }
#line 298
    if (! isgrpwrite) {
      {
#line 298
      tmp___16 = lstat((char const   */* __restrict  */)defdeflock, (struct stat */* __restrict  */)(& stbuf));
      }
#line 298
      if (! tmp___16) {
#line 298
        if (stbuf.st_uid != uid) {
#line 298
          if (stbuf.st_uid != 0U) {
            {
#line 300
            tmp___15 = lastdirsep((char const   *)buf);
#line 300
            i___1 = (int )(tmp___15 - buf);
#line 301
            strncpy((char */* __restrict  */)buf2, (char const   */* __restrict  */)buf,
                    (size_t )i___1);
#line 301
            *(buf2 + i___1) = (char )'\000';
#line 302
            rnmbogus((char const   */* const  */)defdeflock, (struct stat  const  */* const  */)(& stbuf),
                     (int const   )i___1, (int const   )0);
            }
          }
        }
      }
    }
#line 304
    *chp = (char )'\000';
  } else {
    nl: 
#line 307
    defdeflock = empty;
  }
#line 308
  return (1);
}
}
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 95 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.h"
char const   *sgetcp ;
#line 95
char const   devnull[10] ;
#line 95
char const   exceededlb[18] ;
#line 101
int rc ;
#line 101
int skiprc ;
#line 101
int ifdepth ;
#line 104
struct dyna_long ifstack ;
#line 13 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/robust.h"
int ropen(char const   * const  name___1 , int const   mode , mode_t const   mask ) ;
#line 13
int rclose(int const   fd ) ;
#line 13
int rread(int const   fd , void * const  a , int const   len ) ;
#line 3 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/cstdio.h"
void pushrc(char const   * const  name___1 ) ;
#line 3
void changerc(char const   * const  name___1 ) ;
#line 3
void duprcs(void) ;
#line 3
void closerc(void) ;
#line 3
void ungetb(int const   x ) ;
#line 3
void skipline(void) ;
#line 10
int poprc(void) ;
#line 10
int bopen(char const   * const  name___1 ) ;
#line 10
int getbl(char *p___0 , char *end ) ;
#line 10
int getb(void) ;
#line 10
int testB(int const   x ) ;
#line 10
int sgetc(void) ;
#line 10
int skipspace(void) ;
#line 10
int getlline(char *target , char *end ) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/cstdio.h"
struct dynstring *incnamed  ;
#line 13 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.h"
void readerr(char const   * const  file ) ;
#line 13
void *app_val_(struct dyna_long * const  sp ) ;
#line 13
void setoverflow(void) ;
#line 68
char const   *tgetenv(char const   * const  a ) ;
#line 68
char const   *newdynstring(struct dynstring ** const  adrp , char const   * const  chp ) ;
#line 74
char const   maildir[8] ;
#line 18 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/cstdio.c"
static uschar rcbuf[1024]  ;
#line 18 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/cstdio.c"
static uschar *rcbufp  ;
#line 18 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/cstdio.c"
static uschar *rcbufend  ;
#line 19 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/cstdio.c"
static off_t blasttell  ;
#line 20 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/cstdio.c"
static struct dyna_long inced  ;
#line 23 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/cstdio.c"
static void refill(int const   offset ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 24
  tmp___1 = rread((int const   )rc, (void */* const  */)(rcbuf), (int const   )1024);
#line 24
  rcbufend = rcbuf + tmp___1;
  }
#line 24
  if ((unsigned long )(rcbuf) == (unsigned long )rcbufend) {
#line 24
    tmp___0 = 1;
  } else {
#line 24
    tmp___0 = (int )offset;
  }
#line 24
  rcbufp = rcbuf + tmp___0;
#line 25
  return;
}
}
#line 27 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/cstdio.c"
void pushrc(char const   * const  name___1 ) 
{ 
  struct stat stbuf ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 28
  if (*name___1) {
    {
#line 28
    tmp___5 = strcmp((char const   *)name___1, devnull);
    }
#line 28
    if (tmp___5) {
      {
#line 30
      tmp = stat((char const   */* __restrict  */)name___1, (struct stat */* __restrict  */)(& stbuf));
      }
#line 30
      if (tmp) {
#line 31
        goto rerr;
      } else
#line 30
      if (! ((stbuf.st_mode & 61440U) == 32768U)) {
#line 31
        goto rerr;
      }
#line 32
      if (stbuf.st_size) {
        {
#line 33
        tmp___0 = app_val_((struct dyna_long */* const  */)(& inced));
        }
#line 33
        if (rcbufp) {
#line 33
          *((int *)tmp___0) = (int )(rcbufp - rcbuf);
        } else {
#line 33
          *((int *)tmp___0) = 0;
        }
        {
#line 34
        tmp___1 = app_val_((struct dyna_long */* const  */)(& inced));
#line 34
        *((off_t *)tmp___1) = blasttell;
#line 34
        tmp___2 = app_val_((struct dyna_long */* const  */)(& inced));
#line 34
        *((int *)tmp___2) = ifdepth;
#line 35
        tmp___3 = app_val_((struct dyna_long */* const  */)(& inced));
#line 35
        *((int *)tmp___3) = rc;
#line 36
        ifdepth = ifstack.filled;
#line 37
        tmp___4 = bopen(name___1);
        }
#line 37
        if (tmp___4 < 0) {
          {
#line 38
          poprc();
          }
          rerr: 
          {
#line 39
          readerr(name___1);
          }
        }
      }
    }
  }
#line 43
  return;
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/cstdio.c"
void changerc(char const   * const  name___1 ) 
{ 
  int tmp ;
  struct stat stbuf ;
  int orc ;
  uschar *orbp ;
  uschar *orbe ;
  struct dynstring *dp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 46
  if (! *name___1) {
#line 46
    goto pr;
  } else {
    {
#line 46
    tmp = strcmp((char const   *)name___1, devnull);
    }
#line 46
    if (! tmp) {
      pr: 
      {
#line 47
      ifstack.filled = ifdepth;
#line 48
      poprc();
      }
#line 49
      return;
    }
  }
  {
#line 51
  tmp___2 = strcmp((char const   *)name___1, (char const   *)(incnamed->ename));
  }
#line 51
  if (tmp___2) {
    {
#line 55
    tmp___0 = stat((char const   */* __restrict  */)name___1, (struct stat */* __restrict  */)(& stbuf));
    }
#line 55
    if (tmp___0) {
#line 55
      goto rerr;
    } else
#line 55
    if (! ((stbuf.st_mode & 61440U) == 32768U)) {
      rerr: 
      {
#line 56
      readerr(name___1);
      }
#line 57
      return;
    }
#line 59
    if (! stbuf.st_size) {
#line 60
      goto pr;
    }
    {
#line 61
    orbp = rcbufp;
#line 61
    orbe = rcbufend;
#line 61
    orc = rc;
#line 61
    tmp___1 = bopen(name___1);
    }
#line 61
    if (tmp___1 < 0) {
#line 62
      rcbufp = orbp;
#line 62
      rcbufend = orbe;
#line 62
      rc = orc;
#line 63
      goto rerr;
    }
    {
#line 65
    rclose((int const   )orc);
#line 66
    dp = incnamed->enext;
    }
#line 66
    if (dp) {
      {
#line 67
      incnamed->enext = dp->enext;
#line 67
      free((void *)dp);
      }
    }
  } else {
    {
#line 52
    lseek(rc, (__off_t )0, 0);
#line 52
    refill((int const   )0);
    }
  }
#line 69
  ifstack.filled = ifdepth;
#line 70
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/cstdio.c"
void duprcs(void) 
{ 
  size_t i___0 ;
  struct dynstring *dp ;
  int fd ;

  {
  {
#line 74
  dp = incnamed;
#line 74
  rclose((int const   )rc);
#line 75
  rc = ropen(dp->ename, 0, 0);
  }
#line 75
  if (0 > rc) {
#line 76
    goto dupfailed;
  }
  {
#line 77
  lseek(rc, blasttell + 1024L, 0);
#line 78
  i___0 = (size_t )inced.filled;
  }
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    dp = dp->enext;
#line 78
    if (! i___0) {
#line 78
      goto while_break;
    }
    {
#line 80
    i___0 --;
#line 80
    rclose((int const   )(inced.vals + i___0)->i);
#line 81
    fd = ropen(dp->ename, 0, 0);
    }
#line 81
    if (0 > fd) {
      dupfailed: 
      {
#line 83
      nlog((char const   */* const  */)"Lost");
#line 83
      logqnl((char const   */* const  */)(dp->ename));
#line 83
      exit(66);
      }
    }
#line 84
    (inced.vals + i___0)->i = fd;
#line 78
    i___0 -= 3UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  return;
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/cstdio.c"
static void closeonerc(void) 
{ 
  struct dynstring *last ;

  {
#line 90
  if (rc >= 0) {
    {
#line 91
    rclose((int const   )rc);
#line 91
    rc = -1;
#line 91
    last = incnamed;
#line 91
    incnamed = last->enext;
#line 91
    free((void *)last);
    }
  }
#line 92
  return;
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/cstdio.c"
int poprc(void) 
{ 


  {
  {
#line 95
  closeonerc();
  }
#line 96
  if (ifstack.filled > ifdepth) {
    {
#line 97
    ifstack.filled = ifdepth;
#line 97
    nlog((char const   */* const  */)"Missing closing brace\n");
    }
  }
#line 98
  skiprc = 0;
#line 99
  if (! inced.filled) {
#line 100
    return (0);
  }
  {
#line 101
  (inced.filled) --;
#line 101
  rc = (inced.vals + inced.filled)->i;
#line 102
  (inced.filled) --;
#line 102
  ifdepth = (inced.vals + inced.filled)->i;
#line 103
  (inced.filled) --;
#line 103
  blasttell = lseek(rc, (inced.vals + inced.filled)->o, 0);
#line 104
  (inced.filled) --;
#line 104
  refill((int const   )(inced.vals + inced.filled)->i);
  }
#line 105
  return (1);
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/cstdio.c"
void closerc(void) 
{ 


  {
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 109
    closeonerc();
    }
#line 109
    if (! inced.filled) {
#line 109
      goto while_break;
    }
#line 110
    rc = (inced.vals + (inced.filled - 1))->i;
#line 110
    inced.filled -= 4;
  }
  while_break: /* CIL Label */ ;
  }
#line 111
  ifdepth = 0;
#line 111
  ifstack.filled = ifdepth;
#line 112
  return;
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/cstdio.c"
int bopen(char const   * const  name___1 ) 
{ 
  char *md ;
  size_t len ;
  char *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 115
  rcbufend = (uschar *)0;
#line 115
  rcbufp = rcbufend;
#line 115
  rc = ropen(name___1, 0, 0);
  }
#line 116
  if (rc >= 0) {
    {
#line 118
    tmp = strchr(dirsep, (int )*name___1);
    }
#line 118
    if (tmp) {
#line 126
      md = (char *)name___1;
    } else {
      {
#line 118
      tmp___0 = tgetenv((char const   */* const  */)(maildir));
#line 118
      md = (char *)tmp___0;
      }
#line 118
      if (*md) {
        {
#line 118
        tmp___1 = strchr(dirsep, (int )*md);
        }
#line 118
        if (tmp___1) {
          {
#line 118
          len = strlen((char const   *)md);
#line 118
          tmp___2 = strlen((char const   *)name___1);
          }
#line 118
          if ((len + tmp___2) + 2UL < linebuf) {
            {
#line 122
            strcpy((char */* __restrict  */)buf2, (char const   */* __restrict  */)md);
#line 122
            md = buf2 + len;
#line 122
            *md = (char )dirsep[0];
#line 122
            md ++;
#line 122
            strcpy((char */* __restrict  */)md, (char const   */* __restrict  */)name___1);
#line 123
            md = buf2;
            }
          } else {
#line 126
            md = (char *)name___1;
          }
        } else {
#line 126
          md = (char *)name___1;
        }
      } else {
#line 126
        md = (char *)name___1;
      }
    }
    {
#line 127
    newdynstring((struct dynstring **/* const  */)(& incnamed), (char const   */* const  */)md);
    }
  }
#line 129
  return (rc);
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/cstdio.c"
int getbl(char *p___0 , char *end ) 
{ 
  int i___0 ;
  int overflow ;
  char *q ;
  int tmp ;
  char *tmp___0 ;

  {
#line 133
  overflow = 0;
#line 134
  q = p___0;
#line 134
  end --;
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 135
    i___0 = getb();
    }
    {
#line 136
    if (i___0 == -1) {
#line 136
      goto case_neg_1;
    }
#line 136
    if (i___0 == 10) {
#line 136
      goto case_neg_1;
    }
#line 135
    goto switch_break;
    case_neg_1: /* CIL Label */ 
    case_10: /* CIL Label */ 
#line 136
    *q = (char )'\000';
#line 137
    if (overflow) {
#line 137
      tmp = -1;
    } else {
#line 137
      tmp = (unsigned long )p___0 != (unsigned long )q;
    }
#line 137
    return (tmp);
    switch_break: /* CIL Label */ ;
    }
#line 139
    if ((unsigned long )q == (unsigned long )end) {
#line 140
      q = p___0;
#line 140
      overflow = 1;
    }
#line 141
    tmp___0 = q;
#line 141
    q ++;
#line 141
    *tmp___0 = (char )i___0;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/cstdio.c"
int getb(void) 
{ 
  uschar *tmp ;
  int tmp___0 ;

  {
#line 146
  if ((unsigned long )rcbufp == (unsigned long )rcbufend) {
    {
#line 147
    blasttell = lseek(rc, (off_t )0, 1);
#line 147
    refill((int const   )0);
    }
  }
#line 148
  if ((unsigned long )rcbufp < (unsigned long )rcbufend) {
#line 148
    tmp = rcbufp;
#line 148
    rcbufp ++;
#line 148
    tmp___0 = (int )*tmp;
  } else {
#line 148
    tmp___0 = -1;
  }
#line 148
  return (tmp___0);
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/cstdio.c"
void ungetb(int const   x ) 
{ 


  {
#line 152
  if (x != -1) {
#line 153
    rcbufp --;
  }
#line 154
  return;
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/cstdio.c"
int testB(int const   x ) 
{ 
  int i___0 ;

  {
  {
#line 158
  i___0 = getb();
  }
#line 158
  if (i___0 == (int )x) {
#line 159
    return (1);
  }
  {
#line 160
  ungetb((int const   )i___0);
  }
#line 161
  return (0);
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/cstdio.c"
int sgetc(void) 
{ 
  char const   *tmp ;
  int tmp___0 ;

  {
#line 165
  if (*sgetcp) {
#line 165
    tmp = sgetcp;
#line 165
    sgetcp ++;
#line 165
    tmp___0 = (int )*((uschar *)tmp);
  } else {
#line 165
    tmp___0 = -1;
  }
#line 165
  return (tmp___0);
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/cstdio.c"
int skipspace(void) 
{ 
  int any ;
  int tmp ;
  int tmp___0 ;

  {
#line 169
  any = 0;
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 170
    tmp = testB((int const   )' ');
    }
#line 170
    if (! tmp) {
      {
#line 170
      tmp___0 = testB((int const   )'\t');
      }
#line 170
      if (! tmp___0) {
#line 170
        goto while_break;
      }
    }
#line 171
    any = 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 172
  return (any);
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/cstdio.c"
void skipline(void) 
{ 
  int tmp ;

  {
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 177
    tmp = getb();
    }
    {
#line 180
    if (tmp == -1) {
#line 180
      goto case_neg_1;
    }
#line 180
    if (tmp == 10) {
#line 180
      goto case_neg_1;
    }
#line 178
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 179
    goto __Cont;
    case_neg_1: /* CIL Label */ 
    case_10: /* CIL Label */ 
#line 181
    return;
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 185 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/cstdio.c"
int getlline(char *target , char *end ) 
{ 
  char *chp2 ;
  int overflow ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 187
  overflow = 0;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 188
    chp2 = target;
#line 188
    tmp___0 = getbl(chp2, end);
    }
    {
#line 189
    if (tmp___0 == -1) {
#line 189
      goto case_neg_1;
    }
#line 190
    if (tmp___0 == 1) {
#line 190
      goto case_1;
    }
#line 198
    if (tmp___0 == 0) {
#line 198
      goto case_0;
    }
#line 188
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 189
    overflow = 1;
    case_1: /* CIL Label */ 
    {
#line 191
    tmp___1 = strchr((char const   *)target, '\000');
#line 191
    target = tmp___1 - 1;
    }
#line 191
    if ((int )*target == 92) {
#line 192
      if ((unsigned long )chp2 != (unsigned long )target) {
#line 193
        target ++;
      }
#line 194
      if ((unsigned long )target > (unsigned long )(end - 2)) {
#line 195
        target = end - linebuf;
#line 195
        overflow = 1;
      }
#line 196
      goto __Cont;
    }
    case_0: /* CIL Label */ 
#line 199
    if (overflow) {
      {
#line 200
      nlog((char const   */* const  */)(exceededlb));
#line 200
      setoverflow();
      }
    }
#line 202
    return (overflow);
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 187
    tmp = target;
#line 187
    target ++;
#line 187
    *tmp = (char )'\n';
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 432 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 68 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.h"
struct varval strenvvar[7] ;
#line 94
char *Stdout ;
#line 94
char *themail ;
#line 95
char const   shell[6] ;
#line 95
char const   * const  *restargv ;
#line 95
char const   executing[10] ;
#line 95
char const   oquote[3] ;
#line 95
char const   cquote[3] ;
#line 95
char const   procmailn[9] ;
#line 100
long filled ;
#line 101
int sh ;
#line 101
int pwait ;
#line 101
int retval ;
#line 101
int ignwerr ;
#line 101
int lexitcode ;
#line 101
int crestarg ;
#line 3 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/robust.h"
void *tmalloc(size_t const   len ) ;
#line 3
void *trealloc(void * const  old___0 , size_t const   len ) ;
#line 3
void tfree(void * const  p___0 ) ;
#line 11
pid_t sfork(void) ;
#line 13
int rpipe(int *fd ) ;
#line 13
int rdup(int const   p___0 ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.h"
void shutdesc(void) ;
#line 13
void writeerr(char const   * const  line ) ;
#line 13
void progerr(char const   * const  line , int xitcode , int okay ) ;
#line 13
void yell(char const   * const  a , char const   * const  b ) ;
#line 13
void metaparse(char const   *p___0 ) ;
#line 13
void setlastfolder(char const   * const  folder ) ;
#line 13
void concatenate(char *p___0 ) ;
#line 52
int forkerr(pid_t const   pid , char const   * const  a ) ;
#line 61
char *cstr(char * const  a , char const   * const  b ) ;
#line 71
long renvint(long const   i___0 , char const   * const  env ) ;
#line 3 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/pipes.h"
void inittmout(char const   * const  progname ) ;
#line 3
void ftimeout(void) ;
#line 3
void resettmout(void) ;
#line 3
void exectrap(char const   * const  tp ) ;
#line 8
int pipthrough(char *line , char *source , long const   len ) ;
#line 10
long pipin(char * const  line , char *source , long len ) ;
#line 12
char *readdyn(char *bf , long * const  filled___0 ) ;
#line 12
char *fromprog(char *name___1 , char * const  dest , size_t max ) ;
#line 23
char const   exitcode[9] ;
#line 24 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/pipes.h"
int setxit  ;
#line 25 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/pipes.h"
pid_t pidchild  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/pipes.h"
time_t volatile   alrmtime  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/pipes.h"
int volatile   toutflag  ;
#line 28 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/pipes.h"
int pipw  ;
#line 3 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/common.h"
void shexec(char const   * const  *argv ) ;
#line 3
void ultstr(int minwidth , unsigned long val , char *dest ) ;
#line 9
int waitfor(pid_t const   pid ) ;
#line 3 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/mcommon.h"
void qsignal(int const   sig , void (*action)(void) ) ;
#line 7 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/goodies.h"
void primeStdout(char const   * const  varname ) ;
#line 7
void retStdout(char * const  newmyenv , int unset ) ;
#line 13
char const   *sputenv(char const   * const  a ) ;
#line 19
long Stdfilled ;
#line 22
char const   *Tmnate ;
#line 22
char const   *All_args ;
#line 3 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/mailfold.h"
long dump(int const   s , int const   type , char const   *source , long len ) ;
#line 8
void concon(int const   ch ) ;
#line 15
int rawnonl ;
#line 24 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/pipes.c"
char const   exitcode[9]  = 
#line 24 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/pipes.c"
  {      (char const   )'E',      (char const   )'X',      (char const   )'I',      (char const   )'T', 
        (char const   )'C',      (char const   )'O',      (char const   )'D',      (char const   )'E', 
        (char const   )'\000'};
#line 25 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/pipes.c"
static char const   comma[2]  = {      (char const   )',',      (char const   )'\000'};
#line 30 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/pipes.c"
static char *lastexec  ;
#line 30 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/pipes.c"
static char *backblock  ;
#line 31 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/pipes.c"
static long backlen  ;
#line 32 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/pipes.c"
static pid_t pidfilt  ;
#line 33 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/pipes.c"
static int pbackfd[2]  ;
#line 36 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/pipes.c"
void inittmout(char const   * const  progname ) 
{ 
  time_t tmp ;

  {
  {
#line 37
  lastexec = cstr((char */* const  */)lastexec, progname);
#line 37
  toutflag = (int volatile   )0;
  }
#line 38
  if (strenvvar[4].val) {
    {
#line 38
    tmp = time((time_t *)0);
#line 38
    alrmtime = (time_t volatile   )(tmp + (time_t )((unsigned int )strenvvar[4].val));
    }
  } else {
#line 38
    alrmtime = (time_t volatile   )0;
  }
  {
#line 39
  alarm((unsigned int )strenvvar[4].val);
  }
#line 40
  return;
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/pipes.c"
void ftimeout(void) 
{ 
  char const   *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 43
  alarm(0U);
#line 43
  alrmtime = (time_t volatile   )0;
#line 43
  toutflag = (int volatile   )1;
#line 43
  nlog((char const   */* const  */)"Timeout, ");
  }
#line 44
  if (pidchild > 0) {
    {
#line 44
    tmp___1 = kill(pidchild, 15);
    }
#line 44
    if (tmp___1) {
#line 44
      tmp___0 = "was waiting for";
    } else {
#line 44
      tmp___0 = "terminating";
    }
  } else {
#line 44
    tmp___0 = "was waiting for";
  }
  {
#line 44
  elog((char const   */* const  */)tmp___0);
#line 45
  logqnl((char const   */* const  */)lastexec);
#line 45
  signal(14, (void (*)(int  ))(& ftimeout));
  }
#line 46
  return;
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/pipes.c"
void resettmout(void) 
{ 


  {
#line 49
  if (alrmtime) {
    {
#line 50
    alrmtime = (time_t volatile   )0;
#line 50
    alarm((unsigned int )alrmtime);
    }
  }
#line 51
  return;
}
}
#line 54
static void stermchild(void) ;
#line 54 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/pipes.c"
static char const   rescdata[27]  = 
#line 54
  {      (char const   )'R',      (char const   )'e',      (char const   )'s',      (char const   )'c', 
        (char const   )'u',      (char const   )'e',      (char const   )' ',      (char const   )'o', 
        (char const   )'f',      (char const   )' ',      (char const   )'u',      (char const   )'n', 
        (char const   )'f',      (char const   )'i',      (char const   )'l',      (char const   )'t', 
        (char const   )'e',      (char const   )'r',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'d',      (char const   )'a',      (char const   )'t', 
        (char const   )'a',      (char const   )' ',      (char const   )'\000'};
#line 53 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/pipes.c"
static void stermchild(void) 
{ 
  long tmp ;

  {
#line 55
  if (pidfilt > 0) {
    {
#line 56
    kill(pidfilt, 15);
    }
  }
#line 57
  rawnonl = 1;
#line 58
  if (! (pbackfd[1] < 0)) {
    {
#line 59
    tmp = dump((int const   )pbackfd[1], (int const   )0, (char const   *)backblock,
               backlen);
    }
#line 59
    if (tmp) {
      {
#line 60
      nlog((char const   */* const  */)(rescdata));
#line 60
      elog((char const   */* const  */)"failed\n");
      }
    } else
#line 61
    if (*((long volatile   *)(& strenvvar[5].val))) {
      {
#line 62
      nlog((char const   */* const  */)(rescdata));
#line 62
      elog((char const   */* const  */)"succeeded\n");
      }
    } else
#line 61
    if (pwait != 4) {
      {
#line 62
      nlog((char const   */* const  */)(rescdata));
#line 62
      elog((char const   */* const  */)"succeeded\n");
      }
    }
  }
  {
#line 63
  exit(lexitcode);
  }
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/pipes.c"
static void childsetup(void) 
{ 


  {
  {
#line 67
  lexitcode = 69;
#line 67
  qsignal((int const   )15, & stermchild);
#line 68
  qsignal((int const   )2, & stermchild);
#line 68
  qsignal((int const   )1, & stermchild);
#line 69
  qsignal((int const   )3, & stermchild);
#line 69
  shutdesc();
  }
#line 70
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/pipes.c"
static void getstdin(int const   pip ) 
{ 


  {
  {
#line 73
  rclose((int const   )0);
#line 73
  rdup(pip);
#line 73
  rclose(pip);
  }
#line 74
  return;
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/pipes.c"
static void callnewprog(char const   * const  newname ) 
{ 
  char const   *newargv[4] ;
  register char const   *p___0 ;
  int argc ;
  char const   *tmp ;
  char const   * const  *walkargs ;
  char const   **newargv___0 ;
  void *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char const   * const  *walkargs___0 ;
  char const   *tmp___3 ;
  char const   * const  *tmp___4 ;

  {
#line 85
  if (sh) {
    {
#line 87
    yell((char const   */* const  */)(executing), newname);
#line 87
    newargv[3] = (char const   *)0;
#line 87
    newargv[2] = (char const   *)newname;
#line 88
    newargv[1] = strenstr[5].sval;
#line 88
    newargv[0] = tgetenv((char const   */* const  */)(shell));
#line 88
    shexec((char const   * const  *)(newargv));
    }
  }
#line 91
  argc = 1;
#line 91
  p___0 = (char const   *)newname;
#line 92
  if (*((long volatile   *)(& strenvvar[5].val))) {
    {
#line 93
    nlog((char const   */* const  */)(executing));
#line 93
    elog((char const   */* const  */)(oquote));
    }
#line 94
    goto no_1st_comma;
  }
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (*((long volatile   *)(& strenvvar[5].val))) {
      {
#line 98
      elog((char const   */* const  */)(comma));
      }
      no_1st_comma: 
      {
#line 100
      elog((char const   */* const  */)p___0);
      }
    }
    {
#line 102
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 102
      tmp = p___0;
#line 102
      p___0 ++;
#line 102
      if (! *tmp) {
#line 102
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 103
    if (*((long volatile   *)(& strenvvar[5].val))) {
#line 103
      if ((unsigned long )(p___0 - 1) == (unsigned long )All_args) {
#line 103
        if (crestarg) {
#line 104
          walkargs = restargv;
#line 105
          goto No_1st_comma;
          {
#line 106
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 107
            elog((char const   */* const  */)(comma));
            }
            No_1st_comma: 
            {
#line 108
            elog(*walkargs);
#line 106
            walkargs ++;
            }
#line 106
            if (! *walkargs) {
#line 106
              goto while_break___1;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
        }
      }
    }
#line 112
    if ((unsigned long )(p___0 - 1) == (unsigned long )All_args) {
#line 113
      argc += crestarg - 1;
    }
#line 96
    argc ++;
#line 96
    if (! ((unsigned long )p___0 != (unsigned long )Tmnate)) {
#line 96
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 116
  if (*((long volatile   *)(& strenvvar[5].val))) {
    {
#line 117
    elog((char const   */* const  */)(cquote));
    }
  }
  {
#line 119
  tmp___0 = tmalloc((unsigned long )argc * sizeof(*newargv___0));
#line 119
  newargv___0 = (char const   **)tmp___0;
#line 119
  p___0 = (char const   *)newname;
#line 119
  argc = 0;
  }
  {
#line 120
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 121
    tmp___1 = argc;
#line 121
    argc ++;
#line 121
    *(newargv___0 + tmp___1) = p___0;
    {
#line 122
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 122
      tmp___2 = p___0;
#line 122
      p___0 ++;
#line 122
      if (! *tmp___2) {
#line 122
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 123
    if ((unsigned long )(p___0 - 1) == (unsigned long )All_args) {
#line 123
      if (crestarg) {
#line 124
        walkargs___0 = restargv;
#line 125
        argc --;
        {
#line 126
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 126
          tmp___4 = walkargs___0;
#line 126
          walkargs___0 ++;
#line 126
          tmp___3 = (char const   *)*tmp___4;
#line 126
          *(newargv___0 + argc) = tmp___3;
#line 126
          if (! tmp___3) {
#line 126
            goto while_break___4;
          }
#line 127
          argc ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
    }
#line 120
    if (! ((unsigned long )p___0 != (unsigned long )Tmnate)) {
#line 120
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 131
  *(newargv___0 + argc) = (char const   *)0;
#line 131
  shexec((char const   * const  *)newargv___0);
  }
#line 134
  return;
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/pipes.c"
int pipthrough(char *line , char *source , long const   len ) 
{ 
  int pinfd[2] ;
  int poutfd[2] ;
  char *eq ;
  char *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  int excode ;
  int tmp___4 ;
  char *name___1 ;
  int tmp___5 ;

  {
#line 138
  if (Stdout) {
    {
#line 138
    tmp = strchr((char const   *)Stdout, '\000');
#line 138
    eq = tmp - 1;
#line 138
    *eq = (char )'\000';
#line 138
    backblock = getenv((char const   *)Stdout);
    }
#line 138
    if (backblock) {
#line 138
      tmp___0 = 0;
    } else {
#line 138
      tmp___0 = 1;
    }
#line 138
    if (tmp___0) {
#line 140
      pbackfd[1] = -1;
#line 140
      pbackfd[0] = pbackfd[1];
    } else {
      {
#line 142
      rpipe((int *)(pbackfd));
      }
    }
  } else {
    {
#line 142
    rpipe((int *)(pbackfd));
    }
  }
  {
#line 143
  rpipe((int *)(pinfd));
#line 144
  pidchild = sfork();
  }
#line 144
  if (! pidchild) {
#line 145
    if (Stdout) {
#line 145
      if (backblock) {
        {
#line 146
        tmp___1 = strlen((char const   *)backblock);
#line 146
        backlen = (long )tmp___1;
        }
      } else {
#line 148
        backblock = source;
#line 148
        backlen = (long )len;
      }
    } else {
#line 148
      backblock = source;
#line 148
      backlen = (long )len;
    }
    {
#line 149
    childsetup();
#line 149
    rclose((int const   )pinfd[0]);
#line 149
    rclose((int const   )pbackfd[0]);
#line 150
    rpipe((int *)(poutfd));
#line 150
    rclose((int const   )1);
#line 151
    pidfilt = sfork();
    }
#line 151
    if (! pidfilt) {
      {
#line 152
      rclose((int const   )pbackfd[1]);
#line 152
      rclose((int const   )poutfd[1]);
#line 152
      rdup((int const   )pinfd[1]);
#line 152
      rclose((int const   )pinfd[1]);
#line 152
      getstdin((int const   )poutfd[0]);
#line 153
      callnewprog((char const   */* const  */)line);
      }
    }
    {
#line 155
    rclose((int const   )pinfd[1]);
#line 155
    rclose((int const   )poutfd[0]);
#line 156
    tmp___2 = forkerr(pidfilt, line);
    }
#line 156
    if (tmp___2) {
      {
#line 157
      rclose((int const   )poutfd[1]);
#line 157
      stermchild();
      }
    }
    {
#line 158
    tmp___3 = dump((int const   )poutfd[1], (int const   )0, (char const   *)source,
                   (long )len);
    }
#line 158
    if (tmp___3) {
#line 158
      if (! ignwerr) {
        {
#line 159
        writeerr((char const   */* const  */)line);
#line 159
        lexitcode = 74;
#line 159
        stermchild();
        }
      }
    }
#line 161
    if (pwait) {
      {
#line 161
      excode = waitfor(pidfilt);
      }
#line 161
      if (excode != 0) {
#line 162
        pidfilt = 0;
#line 163
        if (pwait & 2) {
#line 164
          pwait = 4;
#line 165
          if (*((long volatile   *)(& strenvvar[5].val))) {
#line 166
            goto perr;
          }
        } else {
          perr: 
          {
#line 169
          progerr((char const   */* const  */)line, excode, pwait == 4);
          }
        }
        {
#line 170
        stermchild();
        }
      }
    }
    {
#line 173
    rclose((int const   )pbackfd[1]);
#line 173
    exit(0);
    }
  }
  {
#line 175
  rclose((int const   )pbackfd[1]);
#line 175
  rclose((int const   )pinfd[1]);
#line 175
  getstdin((int const   )pinfd[0]);
#line 176
  tmp___4 = forkerr(pidchild, procmailn);
  }
#line 176
  if (tmp___4) {
#line 177
    return (-1);
  }
#line 178
  if (Stdout) {
    {
#line 180
    *eq = (char )'=';
#line 180
    name___1 = Stdout;
#line 180
    Stdout = (char *)0;
#line 180
    primeStdout((char const   */* const  */)name___1);
#line 180
    tfree((void */* const  */)name___1);
#line 181
    Stdout = readdyn(Stdout, (long */* const  */)(& Stdfilled));
    }
#line 182
    if (! backblock) {
#line 182
      if (pwait) {
#line 182
        if (pipw) {
#line 182
          tmp___5 = 1;
        } else {
#line 182
          tmp___5 = 0;
        }
      } else {
#line 182
        tmp___5 = 0;
      }
    } else {
#line 182
      tmp___5 = 0;
    }
    {
#line 182
    retStdout((char */* const  */)Stdout, tmp___5);
    }
#line 183
    return (pipw);
  }
#line 185
  return (0);
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/pipes.c"
long pipin(char * const  line , char *source , long len ) 
{ 
  int poutfd[2] ;
  int tmp ;
  int excode ;

  {
  {
#line 220
  rpipe((int *)(poutfd));
#line 221
  pidchild = sfork();
  }
#line 221
  if (! pidchild) {
    {
#line 222
    rclose((int const   )poutfd[1]);
#line 222
    shutdesc();
#line 222
    getstdin((int const   )poutfd[0]);
#line 222
    callnewprog((char const   */* const  */)line);
    }
  }
  {
#line 223
  rclose((int const   )poutfd[0]);
#line 224
  tmp = forkerr(pidchild, line);
  }
#line 224
  if (tmp) {
    {
#line 225
    rclose((int const   )poutfd[1]);
    }
#line 226
    return (-1L);
  }
  {
#line 228
  len = dump((int const   )poutfd[1], (int const   )0, (char const   *)source, len);
  }
#line 228
  if (len) {
#line 228
    if (! ignwerr) {
      {
#line 229
      writeerr((char const   */* const  */)line);
      }
    } else {
#line 228
      len = 0L;
#line 228
      if (len) {
        {
#line 229
        writeerr((char const   */* const  */)line);
        }
      }
    }
  }
#line 231
  if (pwait) {
    {
#line 231
    excode = waitfor(pidchild);
    }
#line 231
    if (excode != 0) {
#line 232
      if (! (pwait & 2)) {
        {
#line 233
        progerr((char const   */* const  */)line, excode, pwait & 2);
        }
      } else
#line 232
      if (*((long volatile   *)(& strenvvar[5].val))) {
        {
#line 233
        progerr((char const   */* const  */)line, excode, pwait & 2);
        }
      }
#line 234
      len = 1L;
    }
  }
#line 237
  pidchild = 0;
#line 239
  if (! sh) {
    {
#line 240
    concatenate((char *)line);
    }
  }
  {
#line 241
  setlastfolder((char const   */* const  */)line);
  }
#line 242
  return (len);
}
}
#line 247 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/pipes.c"
char *readdyn(char *bf , long * const  filled___0 ) 
{ 
  int blksiz ;
  long oldsize ;
  unsigned int shift___0 ;
  char *np ;
  void *tmp___0 ;
  int got ;
  int left ;
  long tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  char *tmp___6 ;
  void *tmp___7 ;

  {
#line 248
  blksiz = 16384;
#line 248
  oldsize = *filled___0;
#line 248
  shift___0 = 0U;
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 256
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 256
      goto while_break___0;
#line 257
      blksiz >>= 1;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 258
    tmp___0 = trealloc(bf, (size_t )(*filled___0 + (long )blksiz));
#line 258
    bf = (char *)tmp___0;
    }
    jumpback: 
#line 260
    left = blksiz;
    {
#line 261
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 262
      got = rread((int const   )0, (void */* const  */)(bf + *filled___0), (int const   )left);
      }
#line 262
      if (0 >= got) {
#line 263
        goto eoffound;
      }
#line 261
      *filled___0 += (long )got;
#line 261
      left -= got;
#line 261
      if (! left) {
#line 261
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  eoffound: 
#line 273
  if (pidchild > 0) {
#line 274
    if (pbackfd[0] >= 0) {
      {
#line 275
      getstdin((int const   )pbackfd[0]);
#line 276
      tmp___4 = rread((int const   )0, (void */* const  */)buf, (int const   )1);
      }
#line 276
      if (1 == tmp___4) {
        {
#line 277
        tmp___2 = oldsize + 1L;
#line 277
        *filled___0 = tmp___2;
#line 277
        tmp___3 = trealloc(bf, (size_t )(tmp___2 + (long )blksiz));
#line 277
        bf = (char *)tmp___3;
#line 278
        *(bf + oldsize) = *buf;
#line 279
        pbackfd[0] = -1;
#line 279
        pwait = 2;
        }
#line 280
        goto jumpback;
      }
    }
#line 283
    if (pwait) {
      {
#line 284
      pipw = waitfor(pidchild);
      }
    }
  }
  {
#line 286
  pidchild = 0;
#line 287
  tmp___7 = realloc((void *)bf, (size_t )(*filled___0 + 1L));
#line 287
  np = (char *)tmp___7;
  }
#line 287
  if (np) {
#line 287
    tmp___6 = np;
  } else {
#line 287
    tmp___6 = bf;
  }
#line 287
  return (tmp___6);
}
}
#line 292 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/pipes.c"
char *fromprog(char *name___1 , char * const  dest , size_t max ) 
{ 
  int pinfd[2] ;
  int poutfd[2] ;
  int i___0 ;
  char *p___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 294
  concon((int const   )'\n');
#line 294
  rpipe((int *)(pinfd));
#line 294
  inittmout((char const   */* const  */)name___1);
#line 295
  pidchild = sfork();
  }
#line 295
  if (! pidchild) {
    {
#line 296
    Stdout = name___1;
#line 296
    childsetup();
#line 296
    rclose((int const   )pinfd[0]);
#line 296
    rpipe((int *)(poutfd));
#line 296
    rclose((int const   )1);
#line 297
    pidfilt = sfork();
    }
#line 297
    if (! pidfilt) {
      {
#line 298
      rclose((int const   )poutfd[1]);
#line 298
      rdup((int const   )pinfd[1]);
#line 298
      rclose((int const   )pinfd[1]);
#line 298
      getstdin((int const   )poutfd[0]);
#line 298
      callnewprog((char const   */* const  */)name___1);
      }
    }
    {
#line 299
    rclose((int const   )pinfd[1]);
#line 299
    rclose((int const   )poutfd[0]);
#line 300
    tmp = forkerr(pidfilt, name___1);
    }
#line 300
    if (tmp) {
      {
#line 301
      rclose((int const   )poutfd[1]);
#line 301
      stermchild();
      }
    }
    {
#line 302
    dump((int const   )poutfd[1], (int const   )0, (char const   *)themail, filled);
#line 302
    waitfor(pidfilt);
#line 302
    exit(lexitcode);
    }
  }
  {
#line 304
  rclose((int const   )pinfd[1]);
#line 304
  p___0 = (char *)dest;
#line 305
  tmp___1 = forkerr(pidchild, name___1);
  }
#line 305
  if (tmp___1) {
    {
#line 315
    rclose((int const   )pinfd[0]);
    }
  } else {
    {
#line 306
    name___1 = tstrdup((char const   */* const  */)name___1);
    }
    {
#line 307
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 307
      i___0 = rread((int const   )pinfd[0], (void */* const  */)p___0, (int const   )((int )max));
      }
#line 307
      if (0 < i___0) {
#line 307
        p___0 += i___0;
#line 307
        max -= (size_t )i___0;
#line 307
        if (! max) {
#line 307
          goto while_break;
        }
      } else {
#line 307
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 308
    tmp___0 = rread((int const   )pinfd[0], (void */* const  */)p___0, (int const   )1);
    }
#line 308
    if (0 < tmp___0) {
      {
#line 309
      nlog((char const   */* const  */)"Excessive output quenched from");
#line 309
      logqnl((char const   */* const  */)name___1);
      }
    }
    {
#line 310
    rclose((int const   )pinfd[0]);
#line 310
    tfree((void */* const  */)name___1);
    }
    {
#line 311
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 311
      p___0 --;
#line 311
      if ((unsigned long )p___0 >= (unsigned long )dest) {
#line 311
        if (! ((int )*p___0 == 10)) {
#line 311
          goto while_break___0;
        }
      } else {
#line 311
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 312
    p___0 ++;
#line 312
    waitfor(pidchild);
    }
  }
#line 316
  pidchild = 0;
#line 316
  *p___0 = (char )'\000';
#line 317
  return (p___0);
}
}
#line 320 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/pipes.c"
void exectrap(char const   * const  tp ) 
{ 
  int forceret ;
  char *p___0 ;
  long tmp ;
  int poutfd[2] ;
  int newret ;
  int tmp___0 ;

  {
#line 323
  if (setxit) {
    {
#line 323
    p___0 = getenv(exitcode);
    }
#line 323
    if (p___0) {
      {
#line 324
      tmp = renvint((long const   )-2L, (char const   */* const  */)p___0);
#line 324
      forceret = (int )tmp;
      }
#line 324
      if (forceret >= 0) {
#line 325
        retval = forceret;
      }
    } else {
#line 323
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 327
  if (*tp) {
    {
#line 328
    p___0 = buf2;
#line 328
    strcpy((char */* __restrict  */)p___0, (char const   */* __restrict  */)(exitcode));
#line 328
    p___0 += sizeof(exitcode) - 1UL;
#line 328
    *p___0 = (char )'=';
#line 329
    ultstr(0, (unsigned long )retval, p___0 + 1);
#line 329
    sputenv((char const   */* const  */)buf2);
#line 329
    forceret = -1;
    }
  }
#line 332
  if (*tp) {
    {
#line 334
    metaparse((char const   *)tp);
#line 334
    concon((int const   )'\n');
#line 334
    rpipe((int *)(poutfd));
#line 334
    inittmout((char const   */* const  */)buf);
#line 335
    pidchild = sfork();
    }
#line 335
    if (! pidchild) {
      {
#line 336
      rclose((int const   )poutfd[1]);
#line 336
      getstdin((int const   )poutfd[0]);
#line 336
      rclose((int const   )1);
#line 336
      rdup((int const   )2);
#line 337
      callnewprog((char const   */* const  */)buf);
      }
    }
    {
#line 339
    rclose((int const   )poutfd[0]);
#line 340
    tmp___0 = forkerr(pidchild, buf);
    }
#line 340
    if (tmp___0) {
      {
#line 348
      rclose((int const   )poutfd[1]);
      }
    } else {
      {
#line 342
      dump((int const   )poutfd[1], (int const   )0, (char const   *)themail, filled);
#line 343
      newret = waitfor(pidchild);
      }
#line 343
      if (newret != 0) {
#line 343
        if (forceret == -2) {
#line 344
          retval = newret;
        }
      }
#line 345
      pidchild = 0;
    }
  }
#line 350
  return;
}
}
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 3 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/regexp.h"
struct eps *bregcomp(char const   * const  a , unsigned int const   ign_case ) ;
#line 8
char *bregexec(struct eps *code , uschar const   * const  text , uschar const   *str ,
               size_t len , unsigned int ign_case ) ;
#line 7 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/goodies.h"
void retbStdout(char * const  newmyenv ) ;
#line 79 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/regexp.c"
static struct eps *r  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/regexp.c"
static struct eps *opcfin  ;
#line 80 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/regexp.c"
static struct __anonstruct_aleps_56 aleps  ;
#line 81 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/regexp.c"
static uschar *p  ;
#line 81 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/regexp.c"
static uschar *cachea  ;
#line 81 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/regexp.c"
static uschar *cachep  ;
#line 82 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/regexp.c"
static size_t cacher  ;
#line 83 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/regexp.c"
static unsigned int case_ignore  ;
#line 83 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/regexp.c"
static unsigned int errorno  ;
#line 91 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/regexp.c"
static char skplen[6]  = {      (char )sizeof(struct eps ),      (char )sizeof(struct jump ),      (char )sizeof(struct chclass ),      (char)0, 
        (char )sizeof(union seps ),      (char)0};
#line 94 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/regexp.c"
static void puteps(struct eps * const  spot , struct eps  const  * const  to ) 
{ 


  {
#line 95
  spot->opc = (unsigned int )((1 << 8) + 5);
#line 95
  spot->next = (struct eps *)to;
#line 95
  spot->sp.awn = (struct eps *)0;
#line 96
  return;
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/regexp.c"
static void bseti(unsigned int i___0 , int const   j ) 
{ 


  {
#line 102
  if (j) {
#line 102
    ((struct chclass *)r)->c[(unsigned long )i___0 / (sizeof(unsigned int ) * 8UL)] |= 1U << (unsigned long )i___0 % (sizeof(unsigned int ) * 8UL);
  } else {
#line 102
    ((struct chclass *)r)->c[(unsigned long )i___0 / (sizeof(unsigned int ) * 8UL)] &= ~ (1U << (unsigned long )i___0 % (sizeof(unsigned int ) * 8UL));
  }
#line 103
  if (case_ignore) {
#line 104
    if (i___0 - 65U <= 25U) {
#line 105
      i___0 += 32U;
    } else
#line 106
    if (i___0 - 97U <= 25U) {
#line 107
      i___0 -= 32U;
    } else {
#line 109
      return;
    }
#line 110
    if (j) {
#line 110
      ((struct chclass *)r)->c[(unsigned long )i___0 / (sizeof(unsigned int ) * 8UL)] |= 1U << (unsigned long )i___0 % (sizeof(unsigned int ) * 8UL);
    } else {
#line 110
      ((struct chclass *)r)->c[(unsigned long )i___0 / (sizeof(unsigned int ) * 8UL)] &= ~ (1U << (unsigned long )i___0 % (sizeof(unsigned int ) * 8UL));
    }
  }
#line 112
  return;
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/regexp.c"
static struct eps *skiplen(struct eps  const  * const  ep ) 
{ 
  unsigned long tmp ;

  {
#line 115
  if ((ep->opc & (unsigned int const   )(((1 << 8) << 1) - 1)) < (unsigned int const   )((1 << 8) + 5)) {
#line 115
    tmp = sizeof(struct mchar );
  } else {
#line 115
    tmp = (unsigned long )skplen[(ep->opc & (unsigned int const   )(((1 << 8) << 1) - 1)) - (unsigned int const   )((1 << 8) + 5)];
  }
#line 115
  return ((struct eps *)((char *)ep + tmp));
}
}
#line 119
static int por(struct eps  const  * const  e ) ;
#line 121 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/regexp.c"
static void psimp(struct eps  const  * const  e ) 
{ 
  int tmp ;
  unsigned int i___0 ;
  unsigned int j ;
  struct eps *tmp___0 ;
  unsigned int tmp___1 ;
  uschar *pold ;
  struct eps *tmp___2 ;

  {
  {
#line 123
  if ((int )*p == 40) {
#line 123
    goto case_40;
  }
#line 127
  if ((int )*p == 91) {
#line 127
    goto case_91;
  }
#line 169
  if ((int )*p == 0) {
#line 169
    goto case_0___1;
  }
#line 171
  if ((int )*p == 46) {
#line 171
    goto case_46;
  }
#line 177
  if ((int )*p == 94) {
#line 177
    goto case_94;
  }
#line 186
  if ((int )*p == 36) {
#line 186
    goto case_36;
  }
#line 192
  if ((int )*p == 92) {
#line 192
    goto case_92;
  }
#line 122
  goto switch_break;
  case_40: /* CIL Label */ 
  {
#line 123
  p ++;
#line 124
  tmp = por(e);
  }
#line 124
  if (tmp) {
#line 125
    errorno = 1U;
  }
#line 126
  return;
  case_91: /* CIL Label */ 
#line 128
  p ++;
#line 128
  j = (unsigned int )(94 == (int )*p);
#line 129
  if (e) {
#line 130
    r->opc = (unsigned int )((1 << 8) + 7);
#line 130
    r->next = (struct eps *)e;
#line 130
    tmp___0 = (struct eps *)0;
#line 130
    ((struct chclass *)r)->pos2.st_ = tmp___0;
#line 130
    ((struct chclass *)r)->pos1.st_ = tmp___0;
#line 131
    i___0 = (unsigned int )(sizeof(((struct chclass *)r)->c) / sizeof(((struct chclass *)r)->c[0]) - 1UL);
    {
#line 132
    while (1) {
      while_continue: /* CIL Label */ ;
#line 132
      if (j) {
#line 132
        ((struct chclass *)r)->c[i___0] = (unsigned int )(~ 0);
      } else {
#line 132
        ((struct chclass *)r)->c[i___0] = 0U;
      }
#line 132
      tmp___1 = i___0;
#line 132
      i___0 --;
#line 132
      if (! tmp___1) {
#line 132
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 135
  if (j) {
#line 136
    p ++;
#line 137
    if (e) {
#line 138
      ((struct chclass *)r)->c[10UL / (sizeof(unsigned int ) * 8UL)] ^= 1U << 10UL % (sizeof(unsigned int ) * 8UL);
    }
  }
#line 140
  if ((int )*p == 93) {
#line 141
    p ++;
#line 142
    if (e) {
#line 143
      i___0 = (unsigned int )']';
#line 143
      ((struct chclass *)r)->c[93UL / (sizeof(unsigned int ) * 8UL)] ^= 1U << 93UL % (sizeof(unsigned int ) * 8UL);
    }
  } else
#line 145
  if ((int )*p == 45) {
#line 146
    p ++;
#line 147
    if (e) {
#line 148
      i___0 = (unsigned int )'-';
#line 148
      ((struct chclass *)r)->c[45UL / (sizeof(unsigned int ) * 8UL)] ^= 1U << 45UL % (sizeof(unsigned int ) * 8UL);
    }
  }
  {
#line 150
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 152
    if ((int )*p == 93) {
#line 152
      goto case_93;
    }
#line 153
    if ((int )*p == 0) {
#line 153
      goto case_0;
    }
#line 155
    if ((int )*p == 45) {
#line 155
      goto case_45;
    }
#line 151
    goto switch_break___0;
    case_93: /* CIL Label */ 
#line 152
    p ++;
    case_0: /* CIL Label */ 
#line 153
    r = (struct eps *)((char *)r + sizeof(struct chclass ));
#line 154
    return;
    case_45: /* CIL Label */ 
#line 156
    p ++;
    {
#line 162
    if ((int )*p == 93) {
#line 162
      goto case_93___0;
    }
#line 162
    if ((int )*p == 0) {
#line 162
      goto case_93___0;
    }
#line 157
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 158
    if (e) {
      {
#line 159
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 159
        i___0 ++;
#line 159
        if (! (i___0 < (unsigned int )*p)) {
#line 159
          goto while_break___1;
        }
        {
#line 160
        bseti(i___0, (int const   )(! j));
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 161
    goto switch_break___1;
    case_93___0: /* CIL Label */ 
    case_0___0: /* CIL Label */ 
#line 162
    p --;
    switch_break___1: /* CIL Label */ ;
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 165
    if (e) {
      {
#line 166
      i___0 = (unsigned int )*p;
#line 166
      bseti(i___0, (int const   )(! j));
      }
    }
#line 150
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  case_0___1: /* CIL Label */ 
#line 170
  return;
  case_46: /* CIL Label */ 
#line 172
  if (e) {
#line 173
    r->opc = (unsigned int )((1 << 8) + 2);
#line 174
    goto fine;
  }
#line 176
  goto fine2;
  case_94: /* CIL Label */ 
#line 178
  if ((int )*(p + 1) == 94) {
#line 179
    p ++;
#line 180
    if (e) {
#line 181
      if ((unsigned long )e == (unsigned long )opcfin) {
#line 181
        r->opc = (unsigned int )((1 << 8) + 4);
      } else {
#line 181
        r->opc = (unsigned int )((1 << 8) + 3);
      }
#line 182
      goto fine;
    }
  } else
  case_36: /* CIL Label */ 
#line 187
  if (e) {
#line 188
    r->opc = (unsigned int )'\n';
#line 189
    goto fine;
  }
#line 191
  goto fine2;
  case_92: /* CIL Label */ 
#line 193
  p ++;
  {
#line 194
  if ((int )*p == 47) {
#line 194
    goto case_47;
  }
#line 199
  if ((int )*p == 62) {
#line 199
    goto case_62;
  }
#line 199
  if ((int )*p == 60) {
#line 199
    goto case_62;
  }
#line 206
  if ((int )*p == 0) {
#line 206
    goto case_0___2;
  }
#line 193
  goto switch_break___2;
  case_47: /* CIL Label */ 
#line 195
  if (e) {
#line 196
    r->opc = (unsigned int )((1 << 8) + 9);
  }
#line 197
  r = (struct eps *)((char *)r + sizeof(union seps ));
#line 198
  goto fine3;
  case_62: /* CIL Label */ 
  case_60: /* CIL Label */ 
  {
#line 200
  pold = p;
#line 201
  p = (uschar *)"[^a-zA-Z0-9_]";
#line 201
  psimp(e);
#line 201
  p = pold + 1;
  }
#line 202
  if (e) {
#line 203
    ((struct chclass *)((struct eps *)((char *)r + - ((int )sizeof(struct chclass )))))->c[10UL / (sizeof(unsigned int ) * 8UL)] ^= 1U << 10UL % (sizeof(unsigned int ) * 8UL);
  }
#line 204
  return;
  case_0___2: /* CIL Label */ 
#line 206
  p --;
  switch_break___2: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
#line 209
  if (e) {
#line 210
    if (case_ignore) {
#line 210
      if ((unsigned int )*p - 65U <= 25U) {
#line 210
        r->opc = (unsigned int )(((int )*p + 97) - 65);
      } else {
#line 210
        r->opc = (unsigned int )*p;
      }
    } else {
#line 210
      r->opc = (unsigned int )*p;
    }
    fine: 
#line 212
    r->next = (struct eps *)e;
#line 212
    tmp___2 = (struct eps *)0;
#line 212
    ((struct chclass *)r)->pos2.st_ = tmp___2;
#line 212
    ((struct chclass *)r)->pos1.st_ = tmp___2;
  }
  fine2: 
#line 215
  r = (struct eps *)((char *)r + sizeof(struct mchar ));
  fine3: 
#line 217
  p ++;
#line 218
  return;
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/regexp.c"
static int endgroup(uschar const   * const  p___0 ) 
{ 


  {
  {
#line 224
  if ((int const   )*p___0 == 0) {
#line 224
    goto case_0;
  }
#line 224
  if ((int const   )*p___0 == 41) {
#line 224
    goto case_0;
  }
#line 224
  if ((int const   )*p___0 == 124) {
#line 224
    goto case_0;
  }
#line 223
  goto switch_break;
  case_0: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_124: /* CIL Label */ 
#line 225
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 227
  return (0);
}
}
#line 230 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/regexp.c"
static void pnorm(struct eps  const  * const  e ) 
{ 
  void *pold ;
  struct eps *rold ;
  int tmp ;
  struct eps *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 233
    pold = (void *)p;
#line 233
    rold = r;
#line 233
    psimp((struct eps  const  */* const  */)((struct eps *)0));
#line 233
    aleps.topc = (unsigned int )*p;
#line 234
    tmp = endgroup((uschar const   */* const  */)p);
    }
#line 234
    if (tmp) {
#line 235
      if (e) {
        {
#line 236
        p = (uschar *)pold;
#line 236
        r = rold;
#line 236
        psimp(e);
        }
      }
#line 237
      return;
    }
    {
#line 239
    aleps.au.sopc = endgroup((uschar const   */* const  */)(p + 1));
    }
#line 240
    if (e) {
#line 241
      p = (uschar *)pold;
#line 241
      pold = (void *)r;
    }
    {
#line 243
    if (aleps.topc == 42U) {
#line 243
      goto case_42;
    }
#line 247
    if (aleps.topc == 43U) {
#line 247
      goto case_43;
    }
#line 258
    if (aleps.topc == 63U) {
#line 258
      goto case_63;
    }
#line 242
    goto switch_break;
    case_42: /* CIL Label */ 
#line 243
    r ++;
#line 244
    if (e) {
#line 245
      if (aleps.au.sopc) {
#line 245
        tmp___0 = (struct eps *)e;
      } else {
#line 245
        tmp___0 = r;
      }
      {
#line 245
      puteps((struct eps */* const  */)rold, (struct eps  const  */* const  */)tmp___0);
#line 245
      r = rold + 1;
#line 245
      psimp((struct eps  const  */* const  */)rold);
      }
    }
#line 246
    goto incagoon;
    case_43: /* CIL Label */ 
#line 248
    if (e) {
      {
#line 249
      puteps((struct eps */* const  */)r, (struct eps  const  */* const  */)rold);
      }
#line 250
      if (aleps.au.sopc) {
#line 251
        (r + 1)->opc = (unsigned int )((1 << 8) + 6);
#line 251
        (r + 1)->next = (struct eps *)e;
      }
      {
#line 252
      r = rold;
#line 252
      psimp((struct eps  const  */* const  */)((struct eps *)pold));
      }
    }
    {
#line 254
    r ++;
#line 255
    tmp___1 = endgroup((uschar const   */* const  */)(p + 1));
    }
#line 255
    if (tmp___1) {
#line 256
      r = (struct eps *)((char *)r + sizeof(struct jump ));
    }
#line 257
    goto incagoon;
    case_63: /* CIL Label */ 
#line 258
    r ++;
#line 259
    if (e) {
#line 260
      if (aleps.au.sopc) {
#line 260
        r = (struct eps *)e;
      } else {
#line 260
        r = r;
      }
      {
#line 260
      puteps((struct eps */* const  */)rold, (struct eps  const  */* const  */)r);
#line 260
      pold = (void *)r;
#line 260
      r = rold + 1;
#line 260
      psimp((struct eps  const  */* const  */)((struct eps *)pold));
      }
    }
    incagoon: 
    {
#line 261
    p ++;
#line 261
    tmp___2 = endgroup((uschar const   */* const  */)p);
    }
#line 261
    if (tmp___2) {
#line 262
      return;
    }
#line 263
    goto __Cont;
    switch_break: /* CIL Label */ ;
    }
#line 265
    if (e) {
      {
#line 266
      r = rold;
#line 266
      psimp((struct eps  const  */* const  */)((struct eps *)pold));
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 270 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/regexp.c"
static int por(struct eps  const  * const  e ) 
{ 
  uschar *pvold ;
  struct eps *rvold ;
  uschar *pold ;
  struct eps *rold ;

  {
#line 272
  if (! e) {
#line 273
    rvold = r;
#line 274
    pvold = p;
#line 274
    if ((unsigned long )cachea == (unsigned long )pvold) {
#line 275
      p = cachep;
#line 275
      r = (struct eps *)((char *)rvold + cacher);
#line 276
      goto ret0;
    }
  }
  {
#line 279
  while (1) {
    while_continue: /* CIL Label */ ;
#line 281
    pold = p;
#line 281
    rold = r;
    {
#line 281
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 286
      if ((int )*p == 41) {
#line 286
        goto case_41;
      }
#line 286
      if ((int )*p == 0) {
#line 286
        goto case_41;
      }
#line 305
      if ((int )*p == 124) {
#line 305
        goto case_124;
      }
#line 283
      goto switch_default;
      switch_default: /* CIL Label */ 
      {
#line 284
      pnorm((struct eps  const  */* const  */)((struct eps *)0));
#line 284
      r = rold;
      }
#line 285
      goto __Cont;
      case_41: /* CIL Label */ 
      case_0: /* CIL Label */ 
#line 287
      if ((unsigned long )p == (unsigned long )pold) {
#line 288
        if (e) {
#line 289
          r->opc = (unsigned int )((1 << 8) + 6);
#line 289
          r->next = (struct eps *)e;
        }
#line 290
        r = (struct eps *)((char *)r + sizeof(struct jump ));
      } else {
        {
#line 293
        p = pold;
#line 293
        pnorm(e);
        }
      }
#line 294
      if (! e) {
#line 295
        if (*p) {
#line 296
          p ++;
        }
#line 297
        cachea = pvold;
#line 297
        cachep = p;
#line 297
        cacher = (size_t )((char *)r - (char *)rvold);
#line 298
        goto ret0;
      }
#line 300
      if (*p) {
#line 301
        p ++;
        ret0: 
#line 302
        return (0);
      }
#line 304
      return (1);
      case_124: /* CIL Label */ 
#line 305
      r ++;
#line 306
      if ((unsigned long )p == (unsigned long )pold) {
#line 307
        if (e) {
          {
#line 308
          puteps((struct eps */* const  */)rold, e);
          }
        }
      } else {
        {
#line 311
        p = pold;
#line 311
        pnorm(e);
        }
#line 312
        if (e) {
          {
#line 313
          puteps((struct eps */* const  */)rold, (struct eps  const  */* const  */)r);
          }
        }
      }
#line 315
      p ++;
      switch_break: /* CIL Label */ ;
      }
#line 317
      goto while_break___0;
      __Cont: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 322 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/regexp.c"
static struct eps *maxback(struct eps *down ) 
{ 
  struct eps *tmp ;
  struct eps *left ;
  struct eps *right ;
  struct eps *tmp___0 ;

  {
#line 323
  aleps.topc = 0U;
  {
#line 324
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 328
    if ((down->opc & (unsigned int )(((1 << 8) << 2) - 1)) == (unsigned int )((1 << 8) + 6)) {
#line 328
      goto case_exp;
    }
#line 329
    if ((down->opc & (unsigned int )(((1 << 8) << 2) - 1)) == (unsigned int )(((1 << 8) + 6) | ((1 << 8) << 1))) {
#line 329
      goto case_exp___0;
    }
#line 331
    if ((down->opc & (unsigned int )(((1 << 8) << 2) - 1)) == (unsigned int )(((1 << 8) + 5) | ((1 << 8) << 1))) {
#line 331
      goto case_exp___1;
    }
#line 333
    if ((down->opc & (unsigned int )(((1 << 8) << 2) - 1)) == (unsigned int )((1 << 8) + 5)) {
#line 333
      goto case_exp___2;
    }
#line 326
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 327
    goto ret0;
    case_exp: /* CIL Label */ 
#line 328
    down->opc = (unsigned int )(((1 << 8) + 6) | ((1 << 8) << 1));
    case_exp___0: /* CIL Label */ 
#line 329
    down = down->next;
#line 330
    goto __Cont;
    case_exp___1: /* CIL Label */ 
#line 331
    aleps.topc = 1U;
#line 332
    if ((unsigned long )down->sp.awn == (unsigned long )((struct eps *)(& aleps))) {
#line 332
      tmp = down;
    } else {
#line 332
      tmp = down->sp.awn;
    }
#line 332
    return (tmp);
    case_exp___2: /* CIL Label */ ;
    switch_break: /* CIL Label */ ;
    }
#line 335
    goto while_break;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 337
  if (! down->sp.awn) {
    {
#line 339
    down->opc = (unsigned int )(((1 << 8) + 5) | ((1 << 8) << 1));
#line 339
    down->sp.awn = (struct eps *)(& aleps);
#line 340
    left = maxback(down->next);
    }
#line 341
    if (aleps.topc) {
#line 342
      down->opc |= (unsigned int )((1 << 8) << 2);
    }
    {
#line 344
    right = maxback(down + 1);
    }
#line 344
    if (right) {
#line 344
      if ((unsigned long )((char *)left) > (unsigned long )((char *)right)) {
#line 345
        left = right;
      }
    }
#line 347
    if (aleps.topc) {
#line 348
      down->opc |= (unsigned int )((1 << 8) << 3);
#line 349
      if (! (down->opc & (unsigned int )((1 << 8) << 2))) {
#line 350
        aleps.topc = 0U;
      }
    }
#line 352
    if (! left) {
#line 353
      down->sp.awn = down;
#line 354
      goto ret0;
    }
#line 356
    tmp___0 = left;
#line 356
    down->sp.awn = tmp___0;
#line 356
    if ((unsigned long )tmp___0 != (unsigned long )down) {
#line 357
      return (left);
    }
  }
  ret0: 
#line 360
  return ((struct eps *)0);
}
}
#line 363 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/regexp.c"
struct eps *bregcomp(char const   * const  a , unsigned int const   ign_case ) 
{ 
  struct eps *st ;
  size_t i___0 ;
  void *tmp ;
  int tmp___0 ;
  register struct eps *i___1 ;
  register struct eps *f ;
  register struct eps *i___2 ;

  {
  {
#line 365
  skplen[((1 << 8) + 10) - ((1 << 8) + 5)] = (char )(sizeof(struct eps ) - (unsigned long )((int )((unsigned long )(& ((struct eps *)0)->sp))));
#line 366
  errorno = 0U;
#line 366
  p = (uschar *)a;
#line 366
  case_ignore = (unsigned int )ign_case;
#line 366
  r = (struct eps *)(& aleps);
#line 366
  cachea = (uschar *)0;
#line 367
  por((struct eps  const  */* const  */)((struct eps *)0));
#line 367
  i___0 = (size_t )((char *)r - (char *)(& aleps));
#line 367
  tmp = tmalloc(i___0 + sizeof(r->opc));
#line 367
  r = (struct eps *)tmp;
#line 367
  st = r;
#line 368
  p = (uschar *)a;
#line 369
  opcfin = (struct eps *)((char *)st + i___0);
#line 369
  tmp___0 = por((struct eps  const  */* const  */)opcfin);
  }
#line 369
  if (! tmp___0) {
#line 370
    errorno = 1U;
  }
#line 371
  r->opc = (unsigned int )((1 << 8) + 8);
#line 372
  if (errorno) {
    {
#line 373
    nlog((char const   */* const  */)"Invalid regexp");
#line 373
    logqnl(a);
    }
  }
#line 374
  r = st;
  {
#line 374
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 376
    if (st->opc == (unsigned int )((1 << 8) + 8)) {
#line 376
      goto case_exp;
    }
#line 378
    if (st->opc == (unsigned int )((1 << 8) + 5)) {
#line 378
      goto case_exp___0;
    }
#line 375
    goto switch_break;
    case_exp: /* CIL Label */ 
#line 377
    return (r);
    case_exp___0: /* CIL Label */ 
#line 379
    if (! st->sp.awn) {
      {
#line 380
      maxback(st);
#line 382
      i___1 = r;
      }
      {
#line 382
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 392
        if ((i___1->opc & (unsigned int )(((1 << 8) << 2) - 1)) == (unsigned int )((1 << 8) + 9)) {
#line 392
          goto case_exp___1;
        }
#line 392
        if ((i___1->opc & (unsigned int )(((1 << 8) << 2) - 1)) == (unsigned int )((1 << 8) + 10)) {
#line 392
          goto case_exp___1;
        }
#line 392
        if ((i___1->opc & (unsigned int )(((1 << 8) << 2) - 1)) == (unsigned int )(((1 << 8) + 6) | ((1 << 8) << 1))) {
#line 392
          goto case_exp___1;
        }
#line 392
        if ((i___1->opc & (unsigned int )(((1 << 8) << 2) - 1)) == (unsigned int )(((1 << 8) + 5) | ((1 << 8) << 1))) {
#line 392
          goto case_exp___1;
        }
#line 394
        if ((i___1->opc & (unsigned int )(((1 << 8) << 2) - 1)) == (unsigned int )((1 << 8) + 8)) {
#line 394
          goto case_exp___5;
        }
#line 384
        goto switch_default;
        switch_default: /* CIL Label */ 
#line 386
        f = i___1->next;
#line 386
        if ((f->opc & (unsigned int )(((1 << 8) << 1) - 1)) == (unsigned int )((1 << 8) + 5)) {
#line 386
          if (f->sp.awn) {
            {
#line 387
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 387
              if (! ((unsigned long )f->sp.awn != (unsigned long )f)) {
#line 387
                goto while_break___1;
              }
#line 387
              f = f->sp.awn;
            }
            while_break___1: /* CIL Label */ ;
            }
#line 388
            i___1->next = f;
          }
        }
        case_exp___1: /* CIL Label */ 
        case_exp___2: /* CIL Label */ 
        case_exp___3: /* CIL Label */ 
        case_exp___4: /* CIL Label */ 
#line 393
        goto __Cont;
        case_exp___5: /* CIL Label */ ;
        switch_break___0: /* CIL Label */ ;
        }
#line 396
        goto while_break___0;
        __Cont: /* CIL Label */ 
        {
#line 382
        i___1 = skiplen((struct eps  const  */* const  */)i___1);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 400
      i___2 = r;
      {
#line 400
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 402
        if (i___2->opc == (unsigned int )((((1 << 8) + 5) | ((1 << 8) << 1)) | ((1 << 8) << 2))) {
#line 402
          goto case_exp___6;
        }
#line 403
        if (i___2->opc == (unsigned int )((((1 << 8) + 5) | ((1 << 8) << 1)) | ((1 << 8) << 3))) {
#line 403
          goto case_exp___7;
        }
#line 404
        if (i___2->opc == (unsigned int )(((1 << 8) + 6) | ((1 << 8) << 1))) {
#line 404
          goto case_exp___8;
        }
#line 407
        if (i___2->opc == (unsigned int )(((1 << 8) + 5) | ((1 << 8) << 1))) {
#line 407
          goto case_exp___9;
        }
#line 407
        if (i___2->opc == (unsigned int )(((((1 << 8) + 5) | ((1 << 8) << 1)) | ((1 << 8) << 2)) | ((1 << 8) << 3))) {
#line 407
          goto case_exp___9;
        }
#line 410
        if (i___2->opc == (unsigned int )((1 << 8) + 8)) {
#line 410
          goto case_exp___11;
        }
#line 408
        goto switch_default___0;
        case_exp___6: /* CIL Label */ 
#line 402
        i___2->next = i___2 + 1;
        case_exp___7: /* CIL Label */ 
#line 403
        i___2->sp.sopc = (1 << 8) + 10;
        case_exp___8: /* CIL Label */ 
#line 404
        i___2->opc = (unsigned int )((1 << 8) + 6);
#line 405
        goto __Cont___0;
        case_exp___9: /* CIL Label */ 
        case_exp___10: /* CIL Label */ 
#line 407
        i___2->opc = (unsigned int )((1 << 8) + 5);
        switch_default___0: /* CIL Label */ 
#line 409
        goto __Cont___0;
        case_exp___11: /* CIL Label */ ;
        switch_break___1: /* CIL Label */ ;
        }
#line 412
        goto while_break___2;
        __Cont___0: /* CIL Label */ 
        {
#line 400
        i___2 = skiplen((struct eps  const  */* const  */)i___2);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 374
    st = skiplen((struct eps  const  */* const  */)st);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 426 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/regexp.c"
static struct mchar tswitch  =    {(unsigned int )((1 << 8) + 1), (struct eps *)(& tswitch), {(struct eps *)0, (void const   *)0},
    {(struct eps *)0, (void const   *)0}};
#line 428 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/regexp.c"
static struct eps *cleantail(char const   * const  start , struct eps *thiss , unsigned int const   th1 ) 
{ 
  register struct eps **reg ;
  register struct eps *save ;
  register struct eps *oldthis ;

  {
#line 430
  save = (struct eps *)(& tswitch);
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    oldthis = thiss;
#line 431
    reg = & ((struct evoi *)((char *)oldthis + th1))->st_;
#line 431
    thiss = *reg;
#line 431
    if (! thiss) {
#line 431
      goto while_break;
    }
#line 432
    if ((unsigned long )start < (unsigned long )((char *)*((void const   **)((char *)reg + ((int )((unsigned long )(& ((struct evoi *)0)->wh_)) - (int )((unsigned long )(& ((struct evoi *)0)->st_))))))) {
#line 433
      *reg = (struct eps *)0;
    } else {
#line 435
      *reg = save;
#line 435
      save = oldthis;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 436
  return (save);
}
}
#line 443 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/regexp.c"
static struct eps sempty  =    {(unsigned int )(1 << 8), & sempty, {(struct eps *)0}};
#line 444 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/regexp.c"
static struct jump  const  nop  =    {(unsigned int )((1 << 8) + 10), {(struct eps *)0}};
#line 591 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/regexp.c"
static char const   match[6]  = {      (char const   )'M',      (char const   )'A',      (char const   )'T',      (char const   )'C', 
        (char const   )'H',      (char const   )'\000'};
#line 591 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/regexp.c"
static char const   amatch[7]  = {      (char const   )'M',      (char const   )'A',      (char const   )'T',      (char const   )'C', 
        (char const   )'H',      (char const   )'=',      (char const   )'\000'};
#line 439 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/regexp.c"
char *bregexec(struct eps *code , uschar const   * const  text , uschar const   *str ,
               size_t len , unsigned int ign_case ) 
{ 
  register struct eps *reg ;
  register struct eps *stack ;
  register struct eps *other ;
  register struct eps *thiss ;
  unsigned int i___0 ;
  unsigned int th1 ;
  unsigned int ot1 ;
  struct eps *initcode ;
  char const   *eom ;
  char const   *pend ;
  uschar const   *tmp ;
  char const   *start ;
  char const   *bom ;
  char *q ;
  char *p___0 ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
#line 445
  sempty.sp.awn = & sempty;
#line 446
  if (ign_case) {
#line 446
    ign_case = ~ 0U;
  } else {
#line 446
    ign_case = 0U;
  }
#line 446
  eom = (char const   *)0;
#line 446
  stack = & sempty;
#line 446
  initcode = code;
#line 447
  th1 = (unsigned int )((int )((unsigned long )(& ((struct chclass *)0)->pos1)));
#line 447
  ot1 = (unsigned int )((int )((unsigned long )(& ((struct chclass *)0)->pos2)));
#line 448
  other = (struct eps *)(& tswitch);
#line 448
  pend = ((char const   *)str + len) + 1;
#line 449
  tmp = str;
#line 449
  str --;
#line 449
  if ((unsigned long )tmp == (unsigned long )text) {
#line 450
    goto begofline;
  } else
#line 449
  if ((int const   )*str == 10) {
#line 450
    goto begofline;
  }
#line 451
  if (! len) {
#line 452
    str ++;
    begofline: 
#line 454
    i___0 = (unsigned int )'\n';
#line 454
    len ++;
#line 455
    if (initcode->opc != (unsigned int )((1 << 8) + 3)) {
#line 456
      goto setups;
    }
#line 457
    reg = initcode;
#line 457
    initcode = (struct eps *)(& nop);
#line 457
    thiss = (struct eps *)(& tswitch);
#line 458
    goto dobotext;
  }
  {
#line 460
  while (1) {
    while_continue: /* CIL Label */ ;
#line 461
    str ++;
#line 461
    i___0 = (unsigned int )*str;
#line 462
    if (i___0 - 65U <= 25U) {
#line 463
      i___0 += ign_case & 32U;
    }
    setups: 
#line 465
    th1 ^= (unsigned int )((int )((unsigned long )(& ((struct chclass *)0)->pos1)) ^ (int )((unsigned long )(& ((struct chclass *)0)->pos2)));
#line 465
    ot1 ^= (unsigned int )((int )((unsigned long )(& ((struct chclass *)0)->pos1)) ^ (int )((unsigned long )(& ((struct chclass *)0)->pos2)));
#line 465
    thiss = other;
#line 465
    other = (struct eps *)(& tswitch);
#line 465
    reg = initcode;
    {
#line 466
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 467
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 468
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 474
          if (reg->opc - (unsigned int )(1 << 8) == (unsigned int )(((1 << 8) + 5) - (1 << 8))) {
#line 474
            goto case_exp;
          }
#line 476
          if (reg->opc - (unsigned int )(1 << 8) == (unsigned int )(((1 << 8) + 6) - (1 << 8))) {
#line 476
            goto case_exp___0;
          }
#line 478
          if (reg->opc - (unsigned int )(1 << 8) == (unsigned int )(((1 << 8) + 9) - (1 << 8))) {
#line 478
            goto case_exp___1;
          }
#line 480
          if (reg->opc - (unsigned int )(1 << 8) == (unsigned int )(((1 << 8) + 10) - (1 << 8))) {
#line 480
            goto case_exp___2;
          }
#line 483
          if (reg->opc - (unsigned int )(1 << 8) == (unsigned int )((1 << 8) - (1 << 8))) {
#line 483
            goto case_exp___3;
          }
#line 485
          if (reg->opc - (unsigned int )(1 << 8) == (unsigned int )(((1 << 8) + 1) - (1 << 8))) {
#line 485
            goto case_exp___4;
          }
#line 487
          if (reg->opc - (unsigned int )(1 << 8) == (unsigned int )(((1 << 8) + 4) - (1 << 8))) {
#line 487
            goto case_exp___5;
          }
#line 489
          if (reg->opc - (unsigned int )(1 << 8) == (unsigned int )(((1 << 8) + 8) - (1 << 8))) {
#line 489
            goto case_exp___6;
          }
#line 491
          if (reg->opc - (unsigned int )(1 << 8) == (unsigned int )(((1 << 8) + 3) - (1 << 8))) {
#line 491
            goto dobotext;
          }
#line 495
          if (reg->opc - (unsigned int )(1 << 8) == (unsigned int )(((1 << 8) + 7) - (1 << 8))) {
#line 495
            goto case_exp___8;
          }
#line 499
          if (reg->opc - (unsigned int )(1 << 8) == (unsigned int )(((1 << 8) + 2) - (1 << 8))) {
#line 499
            goto case_exp___9;
          }
#line 470
          goto switch_default;
          switch_default: /* CIL Label */ 
#line 471
          if (i___0 == reg->opc) {
#line 472
            goto yep;
          }
#line 473
          goto switch_break;
          case_exp: /* CIL Label */ 
#line 474
          reg->sp.awn = stack;
#line 474
          stack = reg;
#line 474
          reg = stack + 1;
#line 475
          goto __Cont;
          case_exp___0: /* CIL Label */ 
#line 476
          reg = reg->next;
#line 477
          goto __Cont;
          case_exp___1: /* CIL Label */ 
#line 479
          goto foundbom;
          case_exp___2: /* CIL Label */ 
#line 481
          if ((unsigned long )thiss == (unsigned long )((struct eps *)(& tswitch))) {
#line 482
            goto nomatch;
          }
          case_exp___3: /* CIL Label */ 
#line 484
          goto empty_stack;
          case_exp___4: /* CIL Label */ 
#line 486
          goto pcstack_switch;
          case_exp___5: /* CIL Label */ 
#line 488
          if (ign_case == 2U) {
            case_exp___6: /* CIL Label */ 
#line 490
            goto nobom;
          }
          dobotext: 
          case_exp___7: /* CIL Label */ 
#line 492
          if ((unsigned long )str < (unsigned long )text) {
#line 493
            goto yep;
          }
#line 494
          goto switch_break;
          case_exp___8: /* CIL Label */ 
#line 496
          if (! (! (((struct chclass *)reg)->c[(unsigned long )i___0 / (sizeof(unsigned int ) * 8UL)] & (1U << (unsigned long )i___0 % (sizeof(unsigned int ) * 8UL))))) {
#line 497
            goto yep;
          }
#line 498
          goto switch_break;
          case_exp___9: /* CIL Label */ 
#line 500
          if (i___0 != 10U) {
            yep: 
#line 501
            if (! ((struct evoi *)((char *)reg + ot1))->st_) {
#line 502
              ((struct evoi *)((char *)reg + ot1))->st_ = other;
#line 502
              other = reg;
#line 502
              ((struct evoi *)((char *)other + ot1))->wh_ = (void const   *)pend;
            }
          }
          switch_break: /* CIL Label */ ;
          }
#line 504
          goto while_break___2;
          __Cont: /* CIL Label */ ;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 467
        reg = stack->next;
#line 467
        stack = stack->sp.awn;
      }
      while_break___1: /* CIL Label */ ;
      }
      empty_stack: 
#line 466
      reg = thiss;
#line 466
      thiss = ((struct evoi *)((char *)reg + th1))->st_;
#line 466
      ((struct evoi *)((char *)reg + th1))->st_ = (struct eps *)0;
#line 466
      reg = reg->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    pcstack_switch: 
#line 460
    len --;
#line 460
    if (! len) {
#line 460
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 511
  goto wrapup;
  {
#line 513
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 514
    str ++;
#line 514
    i___0 = (unsigned int )*str;
#line 515
    if (i___0 - 65U <= 25U) {
#line 516
      i___0 += ign_case & 32U;
    }
#line 517
    th1 ^= (unsigned int )((int )((unsigned long )(& ((struct chclass *)0)->pos1)) ^ (int )((unsigned long )(& ((struct chclass *)0)->pos2)));
#line 517
    ot1 ^= (unsigned int )((int )((unsigned long )(& ((struct chclass *)0)->pos1)) ^ (int )((unsigned long )(& ((struct chclass *)0)->pos2)));
#line 517
    start = pend;
#line 517
    thiss = other;
#line 517
    other = (struct eps *)(& tswitch);
#line 518
    reg = initcode;
    {
#line 519
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 522
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 523
        while (1) {
          while_continue___6: /* CIL Label */ ;
          {
#line 529
          if (reg->opc - (unsigned int )(1 << 8) == (unsigned int )(((1 << 8) + 5) - (1 << 8))) {
#line 529
            goto case_exp___10;
          }
#line 531
          if (reg->opc - (unsigned int )(1 << 8) == (unsigned int )(((1 << 8) + 6) - (1 << 8))) {
#line 531
            goto case_exp___11;
          }
#line 533
          if (reg->opc - (unsigned int )(1 << 8) == (unsigned int )(((1 << 8) + 9) - (1 << 8))) {
#line 533
            goto case_exp___12;
          }
#line 538
          if (reg->opc - (unsigned int )(1 << 8) == (unsigned int )(((1 << 8) + 10) - (1 << 8))) {
#line 538
            goto case_exp___13;
          }
#line 541
          if (reg->opc - (unsigned int )(1 << 8) == (unsigned int )((1 << 8) - (1 << 8))) {
#line 541
            goto case_exp___14;
          }
#line 543
          if (reg->opc - (unsigned int )(1 << 8) == (unsigned int )(((1 << 8) + 1) - (1 << 8))) {
#line 543
            goto case_exp___15;
          }
#line 545
          if (reg->opc - (unsigned int )(1 << 8) == (unsigned int )(((1 << 8) + 4) - (1 << 8))) {
#line 545
            goto case_exp___16;
          }
#line 547
          if (reg->opc - (unsigned int )(1 << 8) == (unsigned int )(((1 << 8) + 8) - (1 << 8))) {
#line 547
            goto case_exp___17;
          }
#line 558
          if (reg->opc - (unsigned int )(1 << 8) == (unsigned int )(((1 << 8) + 3) - (1 << 8))) {
#line 558
            goto case_exp___18;
          }
#line 562
          if (reg->opc - (unsigned int )(1 << 8) == (unsigned int )(((1 << 8) + 7) - (1 << 8))) {
#line 562
            goto case_exp___19;
          }
#line 566
          if (reg->opc - (unsigned int )(1 << 8) == (unsigned int )(((1 << 8) + 2) - (1 << 8))) {
#line 566
            goto case_exp___20;
          }
#line 525
          goto switch_default___0;
          switch_default___0: /* CIL Label */ 
#line 526
          if (i___0 == reg->opc) {
#line 527
            goto Yep;
          }
#line 528
          goto switch_break___0;
          case_exp___10: /* CIL Label */ 
#line 529
          reg->sp.awn = stack;
#line 529
          stack = reg;
#line 529
          reg = stack + 1;
#line 530
          goto __Cont___0;
          case_exp___11: /* CIL Label */ 
#line 531
          reg = reg->next;
#line 532
          goto __Cont___0;
          case_exp___12: /* CIL Label */ 
#line 534
          if (! eom) {
            foundbom: 
#line 535
            start = (char const   *)str;
          }
#line 536
          reg = (struct eps *)((char *)reg + sizeof(union seps ));
#line 537
          goto __Cont___0;
          case_exp___13: /* CIL Label */ 
#line 539
          if ((unsigned long )thiss == (unsigned long )((struct eps *)(& tswitch))) {
#line 540
            goto checkmatch;
          }
          case_exp___14: /* CIL Label */ 
#line 542
          goto Empty_stack;
          case_exp___15: /* CIL Label */ 
#line 544
          goto Pcstack_switch;
          case_exp___16: /* CIL Label */ 
#line 546
          if (ign_case == 2U) {
            case_exp___17: /* CIL Label */ 
#line 548
            if ((unsigned long )start < (unsigned long )pend) {
              {
#line 549
              bom = start;
#line 549
              thiss = cleantail((char const   */* const  */)bom, thiss, (unsigned int const   )th1);
#line 550
              other = cleantail((char const   */* const  */)start, other, (unsigned int const   )ot1);
#line 551
              eom = (char const   *)str;
#line 551
              initcode = (struct eps *)(& nop);
              }
#line 552
              goto switch_break___0;
            }
            nobom: 
            {
#line 554
            pend --;
#line 554
            cleantail((char const   */* const  */)pend, thiss, (unsigned int const   )th1);
#line 555
            cleantail((char const   */* const  */)pend, other, (unsigned int const   )ot1);
            }
#line 556
            return ((char *)str);
          }
          case_exp___18: /* CIL Label */ 
#line 559
          if ((unsigned long )str < (unsigned long )text) {
#line 560
            goto Yep;
          }
#line 561
          goto switch_break___0;
          case_exp___19: /* CIL Label */ 
#line 563
          if (! (! (((struct chclass *)reg)->c[(unsigned long )i___0 / (sizeof(unsigned int ) * 8UL)] & (1U << (unsigned long )i___0 % (sizeof(unsigned int ) * 8UL))))) {
#line 564
            goto Yep;
          }
#line 565
          goto switch_break___0;
          case_exp___20: /* CIL Label */ 
#line 567
          if (i___0 != 10U) {
            Yep: 
#line 568
            if (! ((struct evoi *)((char *)reg + ot1))->st_) {
#line 569
              ((struct evoi *)((char *)reg + ot1))->st_ = other;
#line 569
              other = reg;
              earlier: 
#line 570
              ((struct evoi *)((char *)reg + ot1))->wh_ = (void const   *)start;
            } else
#line 572
            if ((unsigned long )start < (unsigned long )((char *)((struct evoi *)((char *)reg + ot1))->wh_)) {
#line 573
              goto earlier;
            }
          }
          switch_break___0: /* CIL Label */ ;
          }
#line 575
          goto while_break___6;
          __Cont___0: /* CIL Label */ ;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 522
        reg = stack->next;
#line 522
        stack = stack->sp.awn;
      }
      while_break___5: /* CIL Label */ ;
      }
      Empty_stack: 
#line 519
      reg = thiss;
#line 519
      thiss = ((struct evoi *)((char *)reg + th1))->st_;
#line 519
      ((struct evoi *)((char *)reg + th1))->st_ = (struct eps *)0;
#line 519
      start = (char const   *)((struct evoi *)((char *)reg + th1))->wh_;
#line 519
      reg = reg->next;
    }
    while_break___4: /* CIL Label */ ;
    }
    Pcstack_switch: 
#line 513
    len --;
#line 513
    if (! len) {
#line 513
      goto while_break___3;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  wrapup: 
  {
#line 584
  if (ign_case == 4294967295U) {
#line 584
    goto case_4294967295;
  }
#line 584
  if (ign_case == 0U) {
#line 584
    goto case_4294967295;
  }
#line 585
  if (ign_case == 2U) {
#line 585
    goto case_2;
  }
#line 583
  goto switch_break___1;
  case_4294967295: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 584
  ign_case = 1U;
#line 584
  i___0 = (unsigned int )'\n';
  case_2: /* CIL Label */ 
#line 585
  ign_case ++;
#line 585
  str ++;
#line 585
  len = (size_t )1;
#line 585
  th1 ^= (unsigned int )((int )((unsigned long )(& ((struct chclass *)0)->pos1)) ^ (int )((unsigned long )(& ((struct chclass *)0)->pos2)));
#line 585
  ot1 ^= (unsigned int )((int )((unsigned long )(& ((struct chclass *)0)->pos1)) ^ (int )((unsigned long )(& ((struct chclass *)0)->pos2)));
#line 585
  start = pend;
#line 586
  thiss = other;
#line 586
  other = (struct eps *)(& tswitch);
#line 587
  goto Empty_stack;
  switch_break___1: /* CIL Label */ ;
  }
  checkmatch: 
#line 590
  if (eom) {
#line 592
    if ((unsigned long )bom < (unsigned long )((char *)text)) {
#line 593
      bom = (char const   *)text;
    }
#line 594
    pend --;
#line 594
    if ((unsigned long )eom > (unsigned long )pend) {
#line 595
      eom = pend;
    }
#line 596
    if ((unsigned long )eom > (unsigned long )bom) {
#line 596
      len = (size_t )(eom - bom);
    } else {
#line 596
      len = (size_t )0;
    }
    {
#line 597
    tmp___1 = getenv(match);
    }
#line 597
    if ((unsigned long )tmp___1 == (unsigned long )((char const   *)text)) {
      {
#line 598
      q = (char *)text;
#line 598
      memmove((void *)q, (void const   *)bom, len);
#line 598
      *(q + len) = (char )'\000';
#line 598
      bom = (char const   *)q;
      }
    } else {
      {
#line 601
      primeStdout((char const   */* const  */)(amatch));
#line 601
      Stdfilled = (long )((size_t )Stdfilled + len);
#line 601
      tmp___0 = trealloc(Stdout, (size_t )(Stdfilled + 1L));
#line 601
      p___0 = (char *)tmp___0;
#line 602
      q = (p___0 + Stdfilled) - (int )len;
#line 602
      memmove((void *)q, (void const   *)bom, len);
#line 602
      retbStdout((char */* const  */)p___0);
      }
    }
    {
#line 604
    yell((char const   */* const  */)"Matched", (char const   */* const  */)q);
    }
  }
  nomatch: 
#line 608
  return ((char *)eom);
}
}
#line 497 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 681
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getgid)(void) ;
#line 684
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getegid)(void) ;
#line 700
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 332
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) setbuf)(FILE * __restrict  __stream ,
                                                                              char * __restrict  __buf ) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 264 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
#line 71 "/usr/include/grp.h"
extern void endgrent(void) ;
#line 105
extern struct group *getgrgid(__gid_t __gid ) ;
#line 201
extern int initgroups(char const   *__user , __gid_t __group ) ;
#line 78 "/usr/include/pwd.h"
extern void endpwent(void) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 285
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 315
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 181 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 279 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/includes.h"
extern char **environ ;
#line 89 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.h"
int eqFrom_(char const   * const  a ) ;
#line 91
char const   *skipFrom_(char const   *startchar , long *tobesentp ) ;
#line 94 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.h"
char *buf  ;
#line 94 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.h"
char *buf2  ;
#line 94 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.h"
char *loclock  ;
#line 94 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.h"
char *tolock  ;
#line 94 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.h"
char *Stdout  ;
#line 94 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.h"
char *themail  ;
#line 94 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.h"
char *thebody  ;
#line 95
char const   lockfile[9] ;
#line 95
char const   newline[2] ;
#line 95
char const   binsh[8] ;
#line 95
char const   unexpeof[16] ;
#line 95 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.h"
char const   * const  *gargv  ;
#line 95 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.h"
char const   *sgetcp  ;
#line 95
char const   pmrc[18] ;
#line 95
char const   *rcfile ;
#line 95
char const   whilstwfor[21] ;
#line 95
char const   home[5] ;
#line 95
char const   host[5] ;
#line 95
char const   *argv0 ;
#line 95
char const   conflicting[13] ;
#line 95
char const   orgmail[8] ;
#line 95
char const   insufprivs[25] ;
#line 95
char const   errwwriting[23] ;
#line 100 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.h"
long filled  ;
#line 100 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.h"
long lastscore  ;
#line 101 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.h"
int sh  ;
#line 101 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.h"
int pwait  ;
#line 101
int retvl2 ;
#line 101 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.h"
int lcking  ;
#line 101 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.h"
int rcstate  ;
#line 101 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.h"
int ignwerr  ;
#line 101 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.h"
int asgnlastf  ;
#line 101 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.h"
int crestarg  ;
#line 101 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.h"
int skiprc  ;
#line 101 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.h"
int savstdout  ;
#line 101 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.h"
int berkeley  ;
#line 101 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.h"
int mailfilter  ;
#line 101 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.h"
int erestrict  ;
#line 101 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.h"
int ifdepth  ;
#line 104 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.h"
struct dyna_long ifstack  ;
#line 106 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.h"
int volatile   nextexit  ;
#line 107 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.h"
pid_t thepid  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.h"
uid_t uid  ;
#line 109 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.h"
gid_t gid  ;
#line 109 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.h"
gid_t sgid  ;
#line 3 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/acommon.h"
char const   *hostname(void) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/robust.h"
int opena(char const   * const  a ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.h"
void chderr(char const   * const  dir ) ;
#line 13
void verboff(void) ;
#line 13
void verbon(void) ;
#line 13
void newid(void) ;
#line 13
void zombiecollect(void) ;
#line 13
void onguard(void) ;
#line 13
void offguard(void) ;
#line 13
void setmaildir(char const   * const  newdir ) ;
#line 13
void srequeue(void) ;
#line 13
void slose(void) ;
#line 13
void sbounce(void) ;
#line 13
void setdef(char const   * const  name___1 , char const   * const  contents ) ;
#line 13
void mallocbuffers(size_t lineb , int setenv___0 ) ;
#line 13
void asenv(char const   * const  chp ) ;
#line 13
void initdefenv(void) ;
#line 52
int nextrcfile(void) ;
#line 52
int asenvcpy(char *src ) ;
#line 52
int enoughprivs(auth_identity const   * const  passinvk , uid_t const   euid , gid_t const   egid ,
                uid_t const   uid___0 , gid_t const   gid___0 ) ;
#line 52
int conditions(char *flags___0 , int const   prevcond , int const   lastsucc , int const   lastcond ,
               int nrcond ) ;
#line 61
char *pmrc2buf(void) ;
#line 61
char *gobenv(char *chp , char *end ) ;
#line 74
char const   lastfolder[11] ;
#line 75
int didchd ;
#line 76
char *globlock ;
#line 7 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/common.h"
char *skpspace(char const   *chp ) ;
#line 3 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/goodies.h"
int readparse(char *p___0 , int (* const  fpgetc)() , int const   sarg ) ;
#line 5
char *simplesplit(char *to , char const   *from , char const   *fencepost , int *gotp ) ;
#line 7
void postStdout(void) ;
#line 13
char const   *eputenv(char const   * const  src , char * const  dst ) ;
#line 3 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/locking.h"
void lcllock(void) ;
#line 3
void unlock(char ** const  lockp ) ;
#line 5 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/mailfold.h"
int writefolder(char *boxname , char *linkfolder , char const   *source , long len ,
                int const   ignwerr___0 , int const   dolock___0 ) ;
#line 8
void logabstract(char const   * const  lstfolder ) ;
#line 8
void readmail(int rhead , long const   tobesent ) ;
#line 12
char *findtstamp(char const   *start , char const   *end ) ;
#line 16
off_t lasttell ;
#line 13 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/authenticate.h"
auth_identity *auth_finduser(char * const  user , int const   sock ) ;
#line 13
auth_identity *auth_finduid(uid_t const   uid___0 , int const   sock ) ;
#line 16
auth_identity *auth_newid(void) ;
#line 18
int auth_filledid(auth_identity const   *pass ) ;
#line 22
char const   *auth_mailboxname(auth_identity * const  pass ) ;
#line 22
char const   *auth_homedir(auth_identity const   * const  pass ) ;
#line 22
char const   *auth_shell(auth_identity const   * const  pass ) ;
#line 22
char const   *auth_username(auth_identity const   * const  pass ) ;
#line 28
uid_t auth_whatuid(auth_identity const   * const  pass ) ;
#line 28
uid_t auth_whatgid(auth_identity const   * const  pass ) ;
#line 31
void auth_copyid(auth_identity *newpass , auth_identity const   *oldpass ) ;
#line 31
void auth_freeid(auth_identity *pass ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
static char const   * const  nullp  ;
#line 39 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
static char const   From_[6]  = {      (char const   )'F',      (char const   )'r',      (char const   )'o',      (char const   )'m', 
        (char const   )' ',      (char const   )'\000'};
#line 39 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
static char const   exflags[16]  = 
#line 39
  {      (char const   )'H',      (char const   )'B',      (char const   )'D',      (char const   )'A', 
        (char const   )'a',      (char const   )'h',      (char const   )'b',      (char const   )'f', 
        (char const   )'c',      (char const   )'w',      (char const   )'W',      (char const   )'i', 
        (char const   )'E',      (char const   )'e',      (char const   )'r',      (char const   )'\000'};
#line 39 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
static char const   drcfile[8]  = 
#line 39
  {      (char const   )'R',      (char const   )'c',      (char const   )'f',      (char const   )'i', 
        (char const   )'l',      (char const   )'e',      (char const   )':',      (char const   )'\000'};
#line 39 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
static char const   pmusage[218]  = 
#line 39
  {      (char const   )'U',      (char const   )'s',      (char const   )'a',      (char const   )'g', 
        (char const   )'e',      (char const   )':',      (char const   )' ',      (char const   )'p', 
        (char const   )'r',      (char const   )'o',      (char const   )'c',      (char const   )'m', 
        (char const   )'a',      (char const   )'i',      (char const   )'l',      (char const   )' ', 
        (char const   )'[',      (char const   )'-',      (char const   )'v',      (char const   )'p', 
        (char const   )'t',      (char const   )'o',      (char const   )'Y',      (char const   )']', 
        (char const   )' ',      (char const   )'[',      (char const   )'-',      (char const   )'f', 
        (char const   )' ',      (char const   )'f',      (char const   )'r',      (char const   )'o', 
        (char const   )'m',      (char const   )'w',      (char const   )'h',      (char const   )'o', 
        (char const   )'m',      (char const   )']',      (char const   )' ',      (char const   )'[', 
        (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'a', 
        (char const   )'m',      (char const   )'e',      (char const   )'t',      (char const   )'e', 
        (char const   )'r',      (char const   )'=',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'u',      (char const   )'e',      (char const   )' ', 
        (char const   )'|',      (char const   )' ',      (char const   )'r',      (char const   )'c', 
        (char const   )'f',      (char const   )'i',      (char const   )'l',      (char const   )'e', 
        (char const   )']',      (char const   )' ',      (char const   )'.',      (char const   )'.', 
        (char const   )'.',      (char const   )'\n',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'O',      (char const   )'r',      (char const   )':', 
        (char const   )' ',      (char const   )'p',      (char const   )'r',      (char const   )'o', 
        (char const   )'c',      (char const   )'m',      (char const   )'a',      (char const   )'i', 
        (char const   )'l',      (char const   )' ',      (char const   )'[',      (char const   )'-', 
        (char const   )'t',      (char const   )'o',      (char const   )'Y',      (char const   )']', 
        (char const   )' ',      (char const   )'[',      (char const   )'-',      (char const   )'f', 
        (char const   )' ',      (char const   )'f',      (char const   )'r',      (char const   )'o', 
        (char const   )'m',      (char const   )'w',      (char const   )'h',      (char const   )'o', 
        (char const   )'m',      (char const   )']',      (char const   )' ',      (char const   )'[', 
        (char const   )'-',      (char const   )'a',      (char const   )' ',      (char const   )'a', 
        (char const   )'r',      (char const   )'g',      (char const   )'u',      (char const   )'m', 
        (char const   )'e',      (char const   )'n',      (char const   )'t',      (char const   )']', 
        (char const   )' ',      (char const   )'-',      (char const   )'d',      (char const   )' ', 
        (char const   )'r',      (char const   )'e',      (char const   )'c',      (char const   )'i', 
        (char const   )'p',      (char const   )'i',      (char const   )'e',      (char const   )'n', 
        (char const   )'t',      (char const   )' ',      (char const   )'.',      (char const   )'.', 
        (char const   )'.',      (char const   )'\n',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'O',      (char const   )'r',      (char const   )':', 
        (char const   )' ',      (char const   )'p',      (char const   )'r',      (char const   )'o', 
        (char const   )'c',      (char const   )'m',      (char const   )'a',      (char const   )'i', 
        (char const   )'l',      (char const   )' ',      (char const   )'[',      (char const   )'-', 
        (char const   )'p',      (char const   )'t',      (char const   )'Y',      (char const   )']', 
        (char const   )' ',      (char const   )'[',      (char const   )'-',      (char const   )'f', 
        (char const   )' ',      (char const   )'f',      (char const   )'r',      (char const   )'o', 
        (char const   )'m',      (char const   )'w',      (char const   )'h',      (char const   )'o', 
        (char const   )'m',      (char const   )']',      (char const   )' ',      (char const   )'-', 
        (char const   )'m',      (char const   )' ',      (char const   )'[',      (char const   )'p', 
        (char const   )'a',      (char const   )'r',      (char const   )'a',      (char const   )'m', 
        (char const   )'e',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )'=',      (char const   )'v',      (char const   )'a',      (char const   )'l', 
        (char const   )'u',      (char const   )'e',      (char const   )']',      (char const   )' ', 
        (char const   )'.',      (char const   )'.',      (char const   )'.',      (char const   )' ', 
        (char const   )'r',      (char const   )'c',      (char const   )'f',      (char const   )'i', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'[', 
        (char const   )'a',      (char const   )'r',      (char const   )'g',      (char const   )']', 
        (char const   )' ',      (char const   )'.',      (char const   )'.',      (char const   )'.', 
        (char const   )'\n',      (char const   )'\000'};
#line 39 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
static char const   *etcrc  =    "/etc/procmailrc";
#line 39 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
static char const   misrecpt[19]  = 
#line 39
  {      (char const   )'M',      (char const   )'i',      (char const   )'s',      (char const   )'s', 
        (char const   )'i',      (char const   )'n',      (char const   )'g',      (char const   )' ', 
        (char const   )'r',      (char const   )'e',      (char const   )'c',      (char const   )'i', 
        (char const   )'p',      (char const   )'i',      (char const   )'e',      (char const   )'n', 
        (char const   )'t',      (char const   )'\n',      (char const   )'\000'};
#line 39 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
static char const   extrns[12]  = 
#line 39
  {      (char const   )'E',      (char const   )'x',      (char const   )'t',      (char const   )'r', 
        (char const   )'a',      (char const   )'n',      (char const   )'e',      (char const   )'o', 
        (char const   )'u',      (char const   )'s',      (char const   )' ',      (char const   )'\000'};
#line 39 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
static char const   ignrd[10]  = 
#line 39
  {      (char const   )' ',      (char const   )'i',      (char const   )'g',      (char const   )'n', 
        (char const   )'o',      (char const   )'r',      (char const   )'e',      (char const   )'d', 
        (char const   )'\n',      (char const   )'\000'};
#line 39 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
static char const   pardir[3]  = {      (char const   )'.',      (char const   )'.',      (char const   )'\000'};
#line 39 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
static char const   curdir[2]  = {      (char const   )'.',      (char const   )'\000'};
#line 39 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
static char const   defspath[34]  = 
#line 39
  {      (char const   )'P',      (char const   )'A',      (char const   )'T',      (char const   )'H', 
        (char const   )'=',      (char const   )'/',      (char const   )'u',      (char const   )'s', 
        (char const   )'r',      (char const   )'/',      (char const   )'l',      (char const   )'o', 
        (char const   )'c',      (char const   )'a',      (char const   )'l',      (char const   )'/', 
        (char const   )'b',      (char const   )'i',      (char const   )'n',      (char const   )':', 
        (char const   )'/',      (char const   )'u',      (char const   )'s',      (char const   )'r', 
        (char const   )'/',      (char const   )'b',      (char const   )'i',      (char const   )'n', 
        (char const   )':',      (char const   )'/',      (char const   )'b',      (char const   )'i', 
        (char const   )'n',      (char const   )'\000'};
#line 39 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
static char const   defpath[44]  = 
#line 39
  {      (char const   )'P',      (char const   )'A',      (char const   )'T',      (char const   )'H', 
        (char const   )'=',      (char const   )'$',      (char const   )'H',      (char const   )'O', 
        (char const   )'M',      (char const   )'E',      (char const   )'/',      (char const   )'b', 
        (char const   )'i',      (char const   )'n',      (char const   )':',      (char const   )'/', 
        (char const   )'u',      (char const   )'s',      (char const   )'r',      (char const   )'/', 
        (char const   )'l',      (char const   )'o',      (char const   )'c',      (char const   )'a', 
        (char const   )'l',      (char const   )'/',      (char const   )'b',      (char const   )'i', 
        (char const   )'n',      (char const   )':',      (char const   )'/',      (char const   )'u', 
        (char const   )'s',      (char const   )'r',      (char const   )'/',      (char const   )'b', 
        (char const   )'i',      (char const   )'n',      (char const   )':',      (char const   )'/', 
        (char const   )'b',      (char const   )'i',      (char const   )'n',      (char const   )'\000'};
#line 39 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
static char const   attemptst[25]  = 
#line 39
  {      (char const   )'A',      (char const   )'t',      (char const   )'t',      (char const   )'e', 
        (char const   )'m',      (char const   )'p',      (char const   )'t',      (char const   )' ', 
        (char const   )'t',      (char const   )'o',      (char const   )' ',      (char const   )'f', 
        (char const   )'a',      (char const   )'k',      (char const   )'e',      (char const   )' ', 
        (char const   )'s',      (char const   )'t',      (char const   )'a',      (char const   )'m', 
        (char const   )'p',      (char const   )' ',      (char const   )'b',      (char const   )'y', 
        (char const   )'\000'};
#line 45 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
char const   shell[6]  = {      (char const   )'S',      (char const   )'H',      (char const   )'E',      (char const   )'L', 
        (char const   )'L',      (char const   )'\000'};
#line 45 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
char const   lockfile[9]  = 
#line 45
  {      (char const   )'L',      (char const   )'O',      (char const   )'C',      (char const   )'K', 
        (char const   )'F',      (char const   )'I',      (char const   )'L',      (char const   )'E', 
        (char const   )'\000'};
#line 45 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
char const   newline[2]  = {      (char const   )'\n',      (char const   )'\000'};
#line 45 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
char const   binsh[8]  = 
#line 45
  {      (char const   )'/',      (char const   )'b',      (char const   )'i',      (char const   )'n', 
        (char const   )'/',      (char const   )'s',      (char const   )'h',      (char const   )'\000'};
#line 45 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
char const   unexpeof[16]  = 
#line 45
  {      (char const   )'U',      (char const   )'n',      (char const   )'e',      (char const   )'x', 
        (char const   )'p',      (char const   )'e',      (char const   )'c',      (char const   )'t', 
        (char const   )'e',      (char const   )'d',      (char const   )' ',      (char const   )'E', 
        (char const   )'O',      (char const   )'L',      (char const   )'\n',      (char const   )'\000'};
#line 45 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
char const   * const  *restargv  =    & nullp;
#line 45 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
char const   pmrc[18]  = 
#line 45
  {      (char const   )'$',      (char const   )'H',      (char const   )'O',      (char const   )'M', 
        (char const   )'E',      (char const   )'/',      (char const   )'.',      (char const   )'p', 
        (char const   )'r',      (char const   )'o',      (char const   )'c',      (char const   )'m', 
        (char const   )'a',      (char const   )'i',      (char const   )'l',      (char const   )'r', 
        (char const   )'c',      (char const   )'\000'};
#line 45 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
char const   *rcfile  =    pmrc;
#line 45 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
char const   dirsep[2]  = {      (char const   )'/',      (char const   )'\000'};
#line 45 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
char const   devnull[10]  = 
#line 45
  {      (char const   )'/',      (char const   )'d',      (char const   )'e',      (char const   )'v', 
        (char const   )'/',      (char const   )'n',      (char const   )'u',      (char const   )'l', 
        (char const   )'l',      (char const   )'\000'};
#line 45 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
char const   empty[1]  = {      (char const   )'\000'};
#line 45 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
char const   lgname[8]  = 
#line 45
  {      (char const   )'L',      (char const   )'O',      (char const   )'G',      (char const   )'N', 
        (char const   )'A',      (char const   )'M',      (char const   )'E',      (char const   )'\000'};
#line 45 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
char const   executing[10]  = 
#line 45
  {      (char const   )'E',      (char const   )'x',      (char const   )'e',      (char const   )'c', 
        (char const   )'u',      (char const   )'t',      (char const   )'i',      (char const   )'n', 
        (char const   )'g',      (char const   )'\000'};
#line 45 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
char const   oquote[3]  = {      (char const   )' ',      (char const   )'\"',      (char const   )'\000'};
#line 45 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
char const   cquote[3]  = {      (char const   )'\"',      (char const   )'\n',      (char const   )'\000'};
#line 45 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
char const   procmailn[9]  = 
#line 45
  {      (char const   )'p',      (char const   )'r',      (char const   )'o',      (char const   )'c', 
        (char const   )'m',      (char const   )'a',      (char const   )'i',      (char const   )'l', 
        (char const   )'\000'};
#line 45 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
char const   whilstwfor[21]  = 
#line 45
  {      (char const   )' ',      (char const   )'w',      (char const   )'h',      (char const   )'i', 
        (char const   )'l',      (char const   )'s',      (char const   )'t',      (char const   )' ', 
        (char const   )'w',      (char const   )'a',      (char const   )'i',      (char const   )'t', 
        (char const   )'i',      (char const   )'n',      (char const   )'g',      (char const   )' ', 
        (char const   )'f',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'\000'};
#line 45 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
char const   home[5]  = {      (char const   )'H',      (char const   )'O',      (char const   )'M',      (char const   )'E', 
        (char const   )'\000'};
#line 45 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
char const   host[5]  = {      (char const   )'H',      (char const   )'O',      (char const   )'S',      (char const   )'T', 
        (char const   )'\000'};
#line 45 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
char const   *defdeflock  =    empty;
#line 45 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
char const   *argv0  =    empty;
#line 45 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
char const   pathtoolong[15]  = 
#line 45
  {      (char const   )' ',      (char const   )'p',      (char const   )'a',      (char const   )'t', 
        (char const   )'h',      (char const   )' ',      (char const   )'t',      (char const   )'o', 
        (char const   )'o',      (char const   )' ',      (char const   )'l',      (char const   )'o', 
        (char const   )'n',      (char const   )'g',      (char const   )'\000'};
#line 45 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
char const   slogstr[8]  = 
#line 45
  {      (char const   )'%',      (char const   )'s',      (char const   )' ',      (char const   )'\"', 
        (char const   )'%',      (char const   )'s',      (char const   )'\"',      (char const   )'\000'};
#line 45 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
char const   conflicting[13]  = 
#line 45
  {      (char const   )'C',      (char const   )'o',      (char const   )'n',      (char const   )'f', 
        (char const   )'l',      (char const   )'i',      (char const   )'c',      (char const   )'t', 
        (char const   )'i',      (char const   )'n',      (char const   )'g',      (char const   )' ', 
        (char const   )'\000'};
#line 45 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
char const   orgmail[8]  = 
#line 45
  {      (char const   )'O',      (char const   )'R',      (char const   )'G',      (char const   )'M', 
        (char const   )'A',      (char const   )'I',      (char const   )'L',      (char const   )'\000'};
#line 45 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
char const   insufprivs[25]  = 
#line 45
  {      (char const   )'I',      (char const   )'n',      (char const   )'s',      (char const   )'u', 
        (char const   )'f',      (char const   )'f',      (char const   )'i',      (char const   )'c', 
        (char const   )'i',      (char const   )'e',      (char const   )'n',      (char const   )'t', 
        (char const   )' ',      (char const   )'p',      (char const   )'r',      (char const   )'i', 
        (char const   )'v',      (char const   )'i',      (char const   )'l',      (char const   )'e', 
        (char const   )'g',      (char const   )'e',      (char const   )'s',      (char const   )'\n', 
        (char const   )'\000'};
#line 45 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
char const   exceededlb[18]  = 
#line 45
  {      (char const   )'E',      (char const   )'x',      (char const   )'c',      (char const   )'e', 
        (char const   )'e',      (char const   )'d',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'L',      (char const   )'I',      (char const   )'N', 
        (char const   )'E',      (char const   )'B',      (char const   )'U',      (char const   )'F', 
        (char const   )'\n',      (char const   )'\000'};
#line 45 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
char const   errwwriting[23]  = 
#line 45
  {      (char const   )'E',      (char const   )'r',      (char const   )'r',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'w',      (char const   )'h', 
        (char const   )'i',      (char const   )'l',      (char const   )'e',      (char const   )' ', 
        (char const   )'w',      (char const   )'r',      (char const   )'i',      (char const   )'t', 
        (char const   )'i',      (char const   )'n',      (char const   )'g',      (char const   )' ', 
        (char const   )'t',      (char const   )'o',      (char const   )'\000'};
#line 55 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
int retval  =    73;
#line 55 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
int retvl2  =    0;
#line 55 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
int rc  =    -1;
#line 55 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
int lexitcode  =    0;
#line 59 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
size_t linebuf  =    (size_t )2048;
#line 67 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
static auth_identity *savepass(auth_identity * const  spass , uid_t const   uid___0 ) 
{ 
  auth_identity const   *tpass ;
  int tmp ;
  uid_t tmp___0 ;
  auth_identity *tmp___1 ;

  {
  {
#line 70
  tmp = auth_filledid((auth_identity const   *)spass);
  }
#line 70
  if (tmp) {
    {
#line 70
    tmp___0 = auth_whatuid((auth_identity const   */* const  */)spass);
    }
#line 70
    if (tmp___0 == (uid_t )uid___0) {
#line 71
      goto ret;
    }
  }
  {
#line 72
  tmp___1 = auth_finduid(uid___0, 0);
#line 72
  tpass = (auth_identity const   *)tmp___1;
  }
#line 72
  if (tpass) {
    {
#line 73
    auth_copyid((auth_identity *)spass, tpass);
    }
    ret: 
#line 74
    return ((auth_identity *)spass);
  }
#line 76
  return ((auth_identity *)0);
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
static int wipetcrc(void) 
{ 


  {
#line 83
  if (etcrc) {
    {
#line 84
    etcrc = (char const   *)0;
#line 84
    closerc();
#line 85
    eputenv((char const   */* const  */)(defpath), (char */* const  */)buf);
    }
#line 86
    return (1);
  }
#line 88
  return (0);
}
}
#line 149
int main(int argc , char const   * const  *argv ) ;
#line 149 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
static char const   *argv1[2]  = {      empty,      (char const   *)0};
#line 200 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
static char const   * const  keepenv[2]  = {      (char const   */* const  */)"TZ",      (char const   */* const  */)0};
#line 228 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
static char const   * const  trusted_ids[11]  = 
#line 228
  {      (char const   */* const  */)"root",      (char const   */* const  */)"daemon",      (char const   */* const  */)"uucp",      (char const   */* const  */)"mail", 
        (char const   */* const  */)"x400",      (char const   */* const  */)"network",      (char const   */* const  */)"list",      (char const   */* const  */)"slist", 
        (char const   */* const  */)"lists",      (char const   */* const  */)"news",      (char const   */* const  */)0};
#line 296 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
static char const   Fakefield[7]  = {      (char const   )'>',      (char const   )'F',      (char const   )'r',      (char const   )'o', 
        (char const   )'m',      (char const   )' ',      (char const   )'\000'};
#line 386 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
static char const   unkuser[13]  = 
#line 386
  {      (char const   )'U',      (char const   )'n',      (char const   )'k',      (char const   )'n', 
        (char const   )'o',      (char const   )'w',      (char const   )'n',      (char const   )' ', 
        (char const   )'u',      (char const   )'s',      (char const   )'e',      (char const   )'r', 
        (char const   )'\000'};
#line 410 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
static char const   etcrcs[18]  = 
#line 410
  {      (char const   )'/',      (char const   )'e',      (char const   )'t',      (char const   )'c', 
        (char const   )'/',      (char const   )'p',      (char const   )'r',      (char const   )'o', 
        (char const   )'c',      (char const   )'m',      (char const   )'a',      (char const   )'i', 
        (char const   )'l',      (char const   )'r',      (char const   )'c',      (char const   )'s', 
        (char const   )'/',      (char const   )'\000'};
#line 449 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
static char const   densppr[31]  = 
#line 449
  {      (char const   )'D',      (char const   )'e',      (char const   )'n',      (char const   )'y', 
        (char const   )'i',      (char const   )'n',      (char const   )'g',      (char const   )' ', 
        (char const   )'s',      (char const   )'p',      (char const   )'e',      (char const   )'c', 
        (char const   )'i',      (char const   )'a',      (char const   )'l',      (char const   )' ', 
        (char const   )'p',      (char const   )'r',      (char const   )'i',      (char const   )'v', 
        (char const   )'i',      (char const   )'l',      (char const   )'e',      (char const   )'g', 
        (char const   )'e',      (char const   )'s',      (char const   )' ',      (char const   )'f', 
        (char const   )'o',      (char const   )'r',      (char const   )'\000'};
#line 490 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
static char const   * const  prestenv[4]  = {      (char const   */* const  */)"IFS",      (char const   */* const  */)"ENV",      (char const   */* const  */)"PWD",      (char const   */* const  */)0};
#line 593 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
static char const   susprcf[18]  = 
#line 593
  {      (char const   )'S',      (char const   )'u',      (char const   )'s',      (char const   )'p', 
        (char const   )'i',      (char const   )'c',      (char const   )'i',      (char const   )'o', 
        (char const   )'u',      (char const   )'s',      (char const   )' ',      (char const   )'r', 
        (char const   )'c',      (char const   )'f',      (char const   )'i',      (char const   )'l', 
        (char const   )'e',      (char const   )'\000'};
#line 666 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
static char flags[15UL]  ;
#line 92 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
int main(int argc , char const   * const  *argv ) 
{ 
  register char *chp ;
  register char *chp2 ;
  register int i___0 ;
  int suppmunreadable ;
  int presenviron ;
  int Deliverymode ;
  int override ;
  char *fromwhom ;
  char const   *idhint ;
  gid_t egid ;
  __gid_t tmp ;
  char *tmp___0 ;
  __uid_t tmp___1 ;
  auth_identity *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  char const   **emax ;
  char const   **ep ;
  char const   * const  *kp ;
  size_t tmp___5 ;
  char const   **tmp___6 ;
  int tmp___7 ;
  auth_identity *pass ;
  auth_identity *passinvk ;
  auth_identity *spassinvk ;
  int privs ;
  uid_t euid ;
  __uid_t tmp___8 ;
  struct group *grp ;
  char const   * const  *kp___0 ;
  char const   *tmp___9 ;
  char const   * const  *tmp___10 ;
  int tmp___11 ;
  char const   * const  *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char const   *tmp___15 ;
  char const   *fwhom ;
  size_t lfr ;
  size_t linv ;
  int tstamp ;
  int tmp___16 ;
  int tmp___17 ;
  void *tmp___18 ;
  char *rstart ;
  int r___0 ;
  time_t t___1 ;
  char *tmp___19 ;
  char *tmp___20 ;
  size_t tmp___21 ;
  size_t tfrl ;
  char *tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  uid_t tmp___31 ;
  uid_t tmp___32 ;
  int tmp___33 ;
  struct stat stbuf ;
  int tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  auth_identity *tmp___38 ;
  int tmp___39 ;
  char const   *tmp___40 ;
  char const   *tmp___41 ;
  char const   *tmp___42 ;
  char const   *tmp___43 ;
  uid_t tmp___44 ;
  uid_t tmp___45 ;
  char const   *tmp___46 ;
  char const   * const  *kp___1 ;
  char const   * const  *tmp___47 ;
  char const   *tmp___48 ;
  int tmp___49 ;
  char *tmp___50 ;
  char *tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int lastsucc ;
  int lastcond ;
  int prevcond ;
  int tmp___55 ;
  struct stat stbuf___0 ;
  int tmp___56 ;
  char *tmp___57 ;
  char *tmp___58 ;
  char *tmp___59 ;
  char *tmp___60 ;
  char *tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  register char c ;
  int tmp___66 ;
  int tmp___67 ;
  char *tmp___68 ;
  char const   *tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int locknext ;
  int succeed ;
  char *startchar ;
  long tobesent ;
  int nrcond ;
  int tmp___74 ;
  char *chp3 ;
  long tmp___75 ;
  int tmp___76 ;
  char *tmp___77 ;
  char *tmp___78 ;
  char *fencepost ;
  char *q ;
  int got ;
  int tmp___79 ;
  char const   *tmp___80 ;
  int tmp___81 ;
  char const   *tmp___82 ;
  size_t tmp___83 ;
  int tmp___84 ;
  char *tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;
  int tmp___88 ;
  long tmp___89 ;
  int ofiltflag ;
  char *end ;
  int tmp___90 ;
  int c___0 ;
  char *tmp___91 ;
  int tmp___92 ;
  int tmp___93 ;
  void *tmp___94 ;
  void *tmp___95 ;
  int excode ;
  int tmp___96 ;
  int tmp___97 ;
  char *tmp___98 ;
  int tmp___99 ;
  int tmp___100 ;
  int tmp___101 ;
  int tmp___102 ;
  int tmp___103 ;
  char *tmp___104 ;
  int tmp___105 ;
  char const   *tmp___106 ;
  int tmp___107 ;
  int tmp___108 ;
  int tmp___109 ;
  char *end___0 ;
  int tmp___110 ;
  int tmp___111 ;
  int tmp___112 ;
  int tmp___113 ;
  char const   *tmp___114 ;
  int tmp___115 ;
  int tmp___116 ;
  int tmp___117 ;
  int tmp___118 ;
  int tmp___119 ;
  int succeed___0 ;
  int len ;
  size_t tmp___120 ;
  size_t tmp___121 ;
  int tmp___122 ;
  int tmp___123 ;
  char const   *tmp___124 ;
  int tmp___125 ;

  {
  {
#line 97
  newid();
#line 98
  fromwhom = (char *)0;
#line 99
  idhint = (char const   *)0;
#line 99
  tmp = getegid();
#line 99
  egid = tmp;
#line 100
  override = 0;
#line 100
  mailfilter = override;
#line 100
  Deliverymode = mailfilter;
#line 101
  openlog(procmailn, 1, 2 << 3);
  }
#line 102
  if (argc) {
    {
#line 103
    argv0 = (char const   *)*(argv + 0);
#line 103
    tmp___0 = lastdirsep(argv0);
#line 103
    Deliverymode = strncmp((char const   *)tmp___0, procmailn, sizeof(procmailn) - 1UL);
#line 105
    argc = 0;
#line 105
    presenviron = argc;
    }
    {
#line 105
    while (1) {
      while_continue: /* CIL Label */ ;
#line 105
      argc ++;
#line 105
      chp2 = (char *)*(argv + argc);
#line 105
      if (chp2) {
#line 105
        if (! ((int )*chp2 == 45)) {
#line 105
          goto while_break;
        }
      } else {
#line 105
        goto while_break;
      }
      {
#line 106
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 107
        chp2 ++;
        {
#line 108
        if ((int )*chp2 == 118) {
#line 108
          goto case_118;
        }
#line 127
        if ((int )*chp2 == 63) {
#line 127
          goto case_63;
        }
#line 127
        if ((int )*chp2 == 104) {
#line 127
          goto case_63;
        }
#line 130
        if ((int )*chp2 == 112) {
#line 130
          goto case_112;
        }
#line 132
        if ((int )*chp2 == 109) {
#line 132
          goto case_109;
        }
#line 134
        if ((int )*chp2 == 111) {
#line 134
          goto case_111;
        }
#line 136
        if ((int )*chp2 == 121) {
#line 136
          goto case_121;
        }
#line 136
        if ((int )*chp2 == 89) {
#line 136
          goto case_121;
        }
#line 138
        if ((int )*chp2 == 116) {
#line 138
          goto case_116;
        }
#line 140
        if ((int )*chp2 == 114) {
#line 140
          goto case_114;
        }
#line 140
        if ((int )*chp2 == 102) {
#line 140
          goto case_114;
        }
#line 148
        if ((int )*chp2 == 97) {
#line 148
          goto case_97;
        }
#line 160
        if ((int )*chp2 == 100) {
#line 160
          goto case_100;
        }
#line 169
        if ((int )*chp2 == 45) {
#line 169
          goto case_45;
        }
#line 176
        if ((int )*chp2 == 0) {
#line 176
          goto case_0;
        }
#line 174
        goto switch_default;
        case_118: /* CIL Label */ 
        {
#line 108
        elog((char const   */* const  */)(procmailn));
#line 108
        elog((char const   */* const  */)" v3.15 2000/08/25\n    Copyright (c) 1990-1999, Stephen R. van den Berg\t<srb@cuci.nl>\n    Copyright (c) 1999-2000, Philip A. Guenther\t\t<guenther@gac.edu>\n\nSubmit questions/answers to the procmail-related mailinglist by sending to:\n\t<procmail-users@procmail.org>\n\nAnd of course, subscription and information requests for this list to:\n\t<procmail-users-request@procmail.org>\n");
#line 109
        elog((char const   */* const  */)"\nLocking strategies:\tdotlocking");
#line 111
        elog((char const   */* const  */)", fcntl()");
#line 119
        elog((char const   */* const  */)"\nDefault rcfile:\t\t");
#line 119
        elog((char const   */* const  */)(pmrc));
#line 121
        elog((char const   */* const  */)"\n\tIt may be writable by your primary group");
#line 123
        elog((char const   */* const  */)"\nYour system mailbox:\t");
#line 124
        tmp___1 = getuid();
#line 124
        tmp___2 = auth_finduid(tmp___1, 0);
#line 124
        tmp___3 = auth_mailboxname((auth_identity */* const  */)tmp___2);
#line 124
        elog((char const   */* const  */)tmp___3);
#line 125
        elog((char const   */* const  */)(newline));
        }
#line 126
        return (0);
        case_63: /* CIL Label */ 
        case_104: /* CIL Label */ 
        {
#line 127
        elog((char const   */* const  */)(pmusage));
#line 127
        elog((char const   */* const  */)"\t-v\t\tdisplay the version number and exit\n\t-p\t\tpreserve (most of) the environment upon startup\n\t-t\t\tfail softly if mail is undeliverable\n\t-f fromwhom\t(re)generate the leading \'From \' line\n\t-o\t\toverride the leading \'From \' line if necessary\n\t-Y\t\tBerkeley format mailbox, disregard Content-Length:\n\t-a argument\twill set $1\n\t-d recipient\texplicit delivery mode\n\t-m\t\tact as a general purpose mail filter\n");
#line 128
        elog((char const   */* const  */)"Recipe flag quick reference:\n\tH  egrep header (default)\tB  egrep body\n\tD  distinguish case\n\tA  also execute this recipe if the common condition matched\n\ta  same as \'A\', but only if the previous recipe was successful\n\tE  else execute this recipe, if the preceding condition didn\'t match\n\te  on error execute this recipe, if the previous recipe failed\n\th  deliver header (default)\tb  deliver body (default)\n\tf  filter\t\t\ti  ignore write errors\n\tc  carbon copy or clone message\n\tw  wait for a program\t\tr  raw mode, mail as is\n\tW  same as \'w\', but suppress \'Program failure\' messages\n");
        }
#line 129
        return (64);
        case_112: /* CIL Label */ 
#line 130
        presenviron = 1;
#line 131
        goto __Cont;
        case_109: /* CIL Label */ 
#line 132
        mailfilter = 1;
#line 133
        goto __Cont;
        case_111: /* CIL Label */ 
#line 134
        override = 1;
#line 135
        goto __Cont;
        case_121: /* CIL Label */ 
        case_89: /* CIL Label */ 
#line 136
        berkeley = 1;
#line 137
        goto __Cont;
        case_116: /* CIL Label */ 
#line 138
        retval = 75;
#line 139
        goto __Cont;
        case_114: /* CIL Label */ 
        case_102: /* CIL Label */ 
#line 141
        chp2 ++;
#line 141
        if (*chp2) {
#line 142
          fromwhom = chp2;
        } else {
#line 143
          chp2 = (char *)*(argv + (argc + 1));
#line 143
          if (chp2) {
#line 144
            argc ++;
#line 144
            fromwhom = chp2;
          } else {
            {
#line 146
            nlog((char const   */* const  */)"Missing name\n");
            }
          }
        }
#line 147
        goto switch_break;
        case_97: /* CIL Label */ 
#line 150
        chp2 ++;
#line 150
        if (*chp2) {
#line 151
          goto setarg;
        } else {
#line 152
          chp2 = (char *)*(argv + (argc + 1));
#line 152
          if (chp2) {
#line 153
            argc ++;
            setarg: 
#line 154
            argv1[0] = (char const   *)chp2;
#line 154
            restargv = (char const   * const  *)(argv1);
#line 154
            crestarg = 1;
          } else {
            {
#line 157
            nlog((char const   */* const  */)"Missing argument\n");
            }
          }
        }
#line 158
        goto switch_break;
        case_100: /* CIL Label */ 
#line 161
        chp2 ++;
#line 161
        chp = chp2;
#line 161
        if (*chp) {
#line 166
          Deliverymode = 1;
#line 167
          goto last_option;
        } else {
#line 161
          argc ++;
#line 161
          chp = (char *)*(argv + argc);
#line 161
          if (chp) {
#line 166
            Deliverymode = 1;
#line 167
            goto last_option;
          } else {
            {
#line 162
            nlog((char const   */* const  */)(misrecpt));
            }
#line 163
            goto switch_break;
          }
        }
        case_45: /* CIL Label */ 
#line 170
        if (! *chp2) {
#line 171
          argc ++;
#line 172
          goto last_option;
        }
        switch_default: /* CIL Label */ 
        {
#line 174
        nlog((char const   */* const  */)"Unrecognised options:");
#line 174
        logqnl((char const   */* const  */)chp2);
#line 175
        elog((char const   */* const  */)(pmusage));
#line 175
        elog((char const   */* const  */)"Processing continued\n");
        }
        case_0: /* CIL Label */ ;
        switch_break: /* CIL Label */ ;
        }
#line 178
        goto while_break___0;
        __Cont: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 181
  if (Deliverymode) {
#line 181
    chp = chp2;
#line 181
    if (! chp) {
      {
#line 182
      nlog((char const   */* const  */)(misrecpt));
#line 182
      Deliverymode = 0;
      }
    }
  }
  last_option: 
#line 184
  if (Deliverymode) {
#line 184
    if (presenviron) {
#line 185
      presenviron = 0;
#line 186
      goto conflopt;
    }
  }
#line 188
  if (mailfilter) {
#line 189
    if (Deliverymode) {
#line 190
      mailfilter = 0;
#line 191
      goto conflopt;
    }
#line 193
    if (crestarg) {
      conflopt: 
      {
#line 194
      nlog((char const   */* const  */)(conflicting));
#line 194
      elog((char const   */* const  */)"options\n");
#line 194
      elog((char const   */* const  */)(pmusage));
      }
    }
  }
#line 196
  if (! Deliverymode) {
    {
#line 197
    tmp___4 = getenv(lgname);
#line 197
    idhint = (char const   *)tmp___4;
    }
  }
#line 198
  if (! presenviron) {
#line 199
    emax = (char const   **)environ;
#line 201
    kp = keepenv;
    {
#line 201
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 201
      if (! *kp) {
#line 201
        goto while_break___1;
      }
      {
#line 202
      tmp___5 = strlen((char const   *)*kp);
#line 202
      i___0 = (int )tmp___5;
#line 202
      ep = emax;
      }
      {
#line 202
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 202
        chp2 = (char *)*ep;
#line 202
        if (! chp2) {
#line 202
          goto while_break___2;
        }
        {
#line 203
        tmp___7 = strncmp((char const   *)*kp, (char const   *)chp2, (size_t )i___0);
        }
#line 203
        if (! tmp___7) {
#line 203
          if ((int )*(chp2 + i___0) == 61) {
#line 204
            *ep = *emax;
#line 204
            tmp___6 = emax;
#line 204
            emax ++;
#line 204
            *tmp___6 = (char const   *)chp2;
#line 205
            goto while_break___2;
          } else
#line 203
          if ((int )*(chp2 + (i___0 - 1)) == 95) {
#line 204
            *ep = *emax;
#line 204
            tmp___6 = emax;
#line 204
            emax ++;
#line 204
            *tmp___6 = (char const   *)chp2;
#line 205
            goto while_break___2;
          }
        }
#line 202
        ep ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 201
      kp ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 207
    *emax = (char const   *)0;
  }
  {
#line 225
  tmp___8 = geteuid();
#line 225
  euid = tmp___8;
#line 226
  spassinvk = auth_newid();
#line 226
  uid = getuid();
#line 226
  passinvk = savepass((auth_identity */* const  */)spassinvk, (uid_t const   )uid);
#line 227
  privs = 1;
#line 227
  gid = getgid();
  }
#line 229
  if (Deliverymode) {
#line 229
    if (trusted_ids[0]) {
#line 229
      if (uid != euid) {
#line 231
        if (passinvk) {
          {
#line 232
          tmp___9 = auth_username((auth_identity const   */* const  */)passinvk);
#line 232
          chp2 = (char *)tmp___9;
#line 232
          kp___0 = trusted_ids;
          }
          {
#line 232
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 232
            if (! *kp___0) {
#line 232
              goto while_break___3;
            }
            {
#line 233
            tmp___10 = kp___0;
#line 233
            kp___0 ++;
#line 233
            tmp___11 = strcmp((char const   *)chp2, (char const   *)*tmp___10);
            }
#line 233
            if (! tmp___11) {
#line 234
              goto privileged;
            }
          }
          while_break___3: /* CIL Label */ ;
          }
        }
        {
#line 235
        grp = getgrgid(gid);
        }
#line 235
        if (grp) {
#line 236
          chp2 = grp->gr_name;
#line 236
          kp___0 = trusted_ids;
          {
#line 236
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 236
            if (! *kp___0) {
#line 236
              goto while_break___4;
            }
            {
#line 237
            tmp___12 = kp___0;
#line 237
            kp___0 ++;
#line 237
            tmp___13 = strcmp((char const   *)chp2, (char const   *)*tmp___12);
            }
#line 237
            if (! tmp___13) {
#line 238
              goto privileged;
            }
          }
          while_break___4: /* CIL Label */ ;
          }
        }
#line 239
        privs = 0;
      }
    }
  }
  privileged: 
  {
#line 243
  endgrent();
#line 243
  doumask((448 >> 3) | ((448 >> 3) >> 3));
  }
  {
#line 244
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 244
    savstdout = rdup((int const   )1);
    }
#line 244
    if (! (savstdout <= 2)) {
#line 244
      goto while_break___5;
    }
    {
#line 245
    rclose((int const   )savstdout);
#line 246
    savstdout = opena((char const   */* const  */)(devnull));
    }
#line 246
    if (0 > savstdout) {
#line 247
      goto nodevnull;
    }
    {
#line 248
    syslog(1, "Descriptor %d was not open\n", savstdout);
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 250
  fclose(stdout);
#line 250
  rclose((int const   )1);
#line 251
  tmp___14 = opena((char const   */* const  */)(devnull));
  }
#line 251
  if (0 > tmp___14) {
    nodevnull: 
    {
#line 253
    writeerr((char const   */* const  */)(devnull));
#line 253
    syslog(0, slogstr, errwwriting, devnull);
    }
#line 254
    return (72);
  }
  {
#line 259
  setbuf((FILE */* __restrict  */)stdin, (char */* __restrict  */)((char *)0));
#line 259
  mallocbuffers(linebuf, 1);
#line 261
  signal(24, (void (*)(int  ))1);
#line 261
  signal(25, (void (*)(int  ))1);
#line 269
  verbon();
#line 269
  verboff();
#line 272
  signal(17, (void (*)(int  ))0);
#line 274
  signal(13, (void (*)(int  ))1);
#line 274
  qsignal((int const   )15, & srequeue);
#line 275
  qsignal((int const   )2, & sbounce);
#line 275
  qsignal((int const   )1, & sbounce);
#line 276
  qsignal((int const   )3, & slose);
#line 276
  signal(14, (void (*)(int  ))(& ftimeout));
#line 277
  ultstr(0, (unsigned long )uid, buf);
#line 277
  filled = 0L;
  }
#line 278
  if (! passinvk) {
#line 279
    chp2 = buf;
  } else {
    {
#line 278
    tmp___15 = auth_username((auth_identity const   */* const  */)passinvk);
#line 278
    chp2 = (char *)tmp___15;
    }
#line 278
    if (! chp2) {
#line 279
      chp2 = buf;
    }
  }
#line 281
  if (fromwhom) {
#line 281
    if ((int )*fromwhom == 45) {
#line 281
      if (! *(fromwhom + 1)) {
#line 281
        tmp___16 = 1;
      } else {
#line 281
        tmp___16 = 0;
      }
    } else {
#line 281
      tmp___16 = 0;
    }
  } else {
#line 281
    tmp___16 = 0;
  }
#line 281
  tstamp = tmp___16;
#line 281
  fwhom = (char const   *)chp2;
#line 282
  if (fromwhom) {
#line 282
    if (! tstamp) {
#line 283
      if (! privs) {
        {
#line 283
        tmp___17 = strcmp((char const   *)fromwhom, fwhom);
        }
#line 283
        if (! tmp___17) {
#line 284
          privs = 1;
        }
      }
#line 285
      if (! privs) {
#line 285
        if (fromwhom) {
#line 285
          if (override) {
#line 286
            if (*((long volatile   *)(& strenvvar[5].val))) {
              {
#line 287
              nlog((char const   */* const  */)(insufprivs));
              }
            }
            {
#line 288
            syslog(3, slogstr, attemptst, fwhom);
#line 288
            fromwhom = (char *)0;
            }
          } else {
#line 291
            fwhom = (char const   *)fromwhom;
          }
        } else {
#line 291
          fwhom = (char const   *)fromwhom;
        }
      } else {
#line 291
        fwhom = (char const   *)fromwhom;
      }
    }
  }
  {
#line 293
  lfr = strlen(fwhom);
#line 293
  linv = strlen((char const   *)chp2);
#line 293
  tmp___18 = tmalloc((2UL * linebuf + lfr) + linv);
#line 293
  themail = (char *)tmp___18;
#line 293
  thebody = themail;
  }
#line 295
  if (Deliverymode) {
#line 295
    goto _L___2;
  } else
#line 295
  if (fromwhom) {
    _L___2: /* CIL Label */ 
    {
#line 298
    t___1 = time((time_t *)0);
#line 298
    tmp___19 = ctime((time_t const   *)(& t___1));
#line 298
    tmp___20 = strcpy((char */* __restrict  */)buf2, (char const   */* __restrict  */)"  ");
#line 298
    strcat((char */* __restrict  */)tmp___20, (char const   */* __restrict  */)tmp___19);
#line 300
    tmp___21 = strlen((char const   *)buf2);
#line 300
    r___0 = (int )tmp___21;
#line 300
    lfr += (sizeof(From_) - 1UL) + (unsigned long )r___0;
    }
#line 301
    if (tstamp) {
#line 302
      tstamp = r___0;
    }
#line 303
    if (privs) {
#line 304
      linv = (size_t )0;
    } else {
#line 306
      linv += (sizeof(Fakefield) - 1UL) + (unsigned long )r___0;
    }
    {
#line 307
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 307
      r___0 = rread((int const   )0, (void */* const  */)themail, (int const   )1);
      }
#line 307
      if (1 == r___0) {
#line 307
        if (! ((int )*themail == 10)) {
#line 307
          goto while_break___6;
        }
      } else {
#line 307
        goto while_break___6;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
#line 308
    i___0 = 0;
#line 308
    rstart = themail;
#line 309
    if (r___0 > 0) {
      {
#line 309
      tmp___23 = rread((int const   )0, (void */* const  */)(rstart + 1), (int const   )((int )((linebuf - 2UL) - 1UL)));
#line 309
      i___0 = tmp___23 + 1;
      }
#line 309
      if (sizeof(From_) - 1UL <= (unsigned long )i___0) {
        {
#line 309
        tmp___24 = eqFrom_((char const   */* const  */)themail);
        }
#line 309
        if (tmp___24) {
          {
#line 311
          *(rstart + i___0) = (char )'\000';
#line 312
          rstart = strchr((char const   *)rstart, '\n');
          }
#line 312
          if (! rstart) {
            {
#line 313
            while (1) {
              while_continue___7: /* CIL Label */ ;
              {
#line 314
              i___0 = rread((int const   )0, (void */* const  */)themail, (int const   )((int )(linebuf - 2UL)));
              }
#line 314
              if (i___0 <= 0) {
#line 315
                goto while_break___7;
              }
              {
#line 316
              *(themail + i___0) = (char )'\000';
#line 313
              rstart = strchr((char const   *)themail, '\n');
              }
#line 313
              if (rstart) {
#line 313
                goto while_break___7;
              }
            }
            while_break___7: /* CIL Label */ ;
            }
#line 319
            if (rstart) {
#line 319
              rstart ++;
#line 319
              i___0 = (int )((long )i___0 - (rstart - themail));
            } else {
#line 319
              i___0 = 0;
            }
#line 320
            goto no_from;
          }
#line 323
          rstart ++;
#line 323
          tfrl = (size_t )(rstart - themail);
#line 323
          i___0 = (int )((size_t )i___0 - tfrl);
#line 324
          if (Deliverymode) {
#line 324
            if (override) {
#line 324
              if (! privs) {
#line 325
                if (*((long volatile   *)(& strenvvar[5].val))) {
                  {
#line 326
                  nlog((char const   */* const  */)(insufprivs));
                  }
                }
                {
#line 327
                syslog(3, slogstr, attemptst, fwhom);
                }
#line 328
                goto no_from;
              }
            }
          }
#line 330
          if (tstamp) {
            {
#line 331
            tmp___22 = findtstamp((char const   *)(themail + (sizeof(From_) - 1UL)),
                                  (char const   *)rstart);
#line 331
            lfr = (size_t )((tmp___22 - themail) + (long )tstamp);
            }
          } else
#line 333
          if (! fromwhom) {
#line 334
            if (linv) {
#line 335
              lfr = tfrl;
            } else {
#line 337
              lfr = (size_t )0;
#line 337
              i___0 = (int )((size_t )i___0 + tfrl);
            }
          }
        } else {
#line 309
          goto no_from;
        }
      } else {
#line 309
        goto no_from;
      }
    } else {
      no_from: 
#line 341
      tstamp = 0;
#line 342
      if (! fromwhom) {
#line 343
        linv = (size_t )0;
      }
    }
#line 345
    filled = (long )((lfr + linv) + (size_t )i___0);
#line 346
    if (lfr) {
#line 346
      goto _L___1;
    } else
#line 346
    if (linv) {
      _L___1: /* CIL Label */ 
      {
#line 347
      r___0 = (int )*rstart;
#line 347
      memmove((void *)((themail + lfr) + linv), (void const   *)rstart, (size_t )i___0);
#line 348
      rstart = themail + lfr;
      }
#line 349
      if (! linv) {
#line 350
        *(rstart + - tstamp) = (char )'\000';
#line 351
        if (! tstamp) {
          {
#line 352
          tmp___25 = strcpy((char */* __restrict  */)themail, (char const   */* __restrict  */)(From_));
#line 352
          strcat((char */* __restrict  */)tmp___25, (char const   */* __restrict  */)fwhom);
          }
        }
      } else {
#line 355
        if (lfr) {
#line 356
          if (tstamp) {
            {
#line 357
            strcpy((char */* __restrict  */)(rstart - tstamp), (char const   */* __restrict  */)buf2);
            }
          } else
#line 358
          if (fromwhom) {
            {
#line 359
            tmp___26 = strcpy((char */* __restrict  */)themail, (char const   */* __restrict  */)(From_));
#line 359
            tmp___27 = strcat((char */* __restrict  */)tmp___26, (char const   */* __restrict  */)fwhom);
#line 359
            strcat((char */* __restrict  */)tmp___27, (char const   */* __restrict  */)buf2);
            }
          }
        }
        {
#line 360
        tmp___28 = strcpy((char */* __restrict  */)rstart, (char const   */* __restrict  */)(Fakefield));
#line 360
        strcat((char */* __restrict  */)tmp___28, (char const   */* __restrict  */)chp2);
        }
      }
      {
#line 362
      strcat((char */* __restrict  */)themail, (char const   */* __restrict  */)buf2);
#line 362
      *(themail + (lfr + linv)) = (char )r___0;
      }
    }
  }
  {
#line 366
  readmail(0, (long const   )0L);
  }
#line 367
  if (Deliverymode) {
    {
#line 368
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 369
      chp2 = chp;
#line 370
      argc ++;
#line 370
      if (*(argv + argc)) {
        {
#line 371
        pidchild = sfork();
        }
#line 371
        if (pidchild) {
          {
#line 372
          tmp___29 = forkerr(pidchild, procmailn);
          }
#line 372
          if (tmp___29) {
#line 374
            retvl2 = retval;
          } else {
            {
#line 372
            tmp___30 = waitfor(pidchild);
            }
#line 372
            if (tmp___30 != 0) {
#line 374
              retvl2 = retval;
            }
          }
#line 375
          pidchild = 0;
        } else {
          {
#line 378
          newid();
          }
          {
#line 379
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 379
            argc ++;
#line 379
            if (! *(argv + argc)) {
#line 379
              goto while_break___9;
            }
          }
          while_break___9: /* CIL Label */ ;
          }
        }
      }
#line 368
      chp = (char *)*(argv + argc);
#line 368
      if (! chp) {
#line 368
        goto while_break___8;
      }
    }
    while_break___8: /* CIL Label */ ;
    }
  }
#line 383
  gargv = argv + argc;
#line 383
  suppmunreadable = (int )*((long volatile   *)(& strenvvar[5].val));
#line 384
  if (Deliverymode) {
    {
#line 385
    pass = auth_finduser((char */* const  */)chp2, (int const   )-1);
    }
#line 385
    if (! pass) {
      {
#line 387
      nlog((char const   */* const  */)(unkuser));
#line 387
      logqnl((char const   */* const  */)chp2);
#line 387
      syslog(3, slogstr, unkuser, chp2);
      }
#line 388
      return (67);
    }
    {
#line 390
    tmp___31 = auth_whatgid((auth_identity const   */* const  */)pass);
#line 390
    tmp___32 = auth_whatuid((auth_identity const   */* const  */)pass);
#line 390
    tmp___33 = enoughprivs(passinvk, euid, egid, tmp___32, tmp___31);
    }
#line 390
    if (tmp___33) {
#line 392
      goto Setuser;
    }
    {
#line 393
    nlog((char const   */* const  */)(insufprivs));
#line 394
    syslog(2, "Insufficient privileges to deliver to \"%s\"\n", chp2);
    }
#line 396
    return (77);
  } else {
    {
#line 399
    suppmunreadable = nextrcfile();
    }
#line 400
    if (presenviron) {
#line 401
      etcrc = (char const   *)0;
    }
#line 402
    if (suppmunreadable) {
#line 403
      etcrc = (char const   *)0;
#line 403
      strenstr[3].sval = "no";
    }
#line 404
    if (mailfilter) {
#line 405
      if (! suppmunreadable) {
        {
#line 406
        nlog((char const   */* const  */)"Missing rcfile\n");
        }
#line 407
        return (66);
      }
      {
#line 411
      tmp___39 = strncmp(etcrcs, rcfile, sizeof(etcrcs) - 1UL);
      }
#line 411
      if (! tmp___39) {
#line 419
        chp = ((char *)rcfile + (sizeof(etcrcs) - 1UL)) - 1;
        {
#line 419
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 419
          if (! chp) {
#line 419
            goto while_break___10;
          }
          {
#line 422
          chp ++;
#line 422
          tmp___34 = strncmp(pardir, (char const   *)chp, sizeof(pardir) - 1UL);
          }
#line 422
          if (! tmp___34) {
            {
#line 422
            chp += sizeof(pardir) - 1UL;
#line 422
            tmp___35 = strchr(dirsep, (int )*chp);
            }
#line 422
            if (tmp___35) {
#line 424
              goto nospecial;
            }
          }
          {
#line 419
          chp = strpbrk((char const   *)chp, dirsep);
          }
        }
        while_break___10: /* CIL Label */ ;
        }
#line 433
        if (presenviron) {
#line 433
          goto nospecial;
        } else
#line 433
        if (suppmunreadable != 2) {
#line 433
          goto nospecial;
        } else {
          {
#line 433
          tmp___36 = lstat((char const   */* __restrict  */)rcfile, (struct stat */* __restrict  */)(& stbuf));
          }
#line 433
          if (tmp___36) {
#line 433
            goto nospecial;
          } else {
            {
#line 433
            tmp___37 = enoughprivs(passinvk, euid, egid, stbuf.st_uid, stbuf.st_gid);
            }
#line 433
            if (tmp___37) {
#line 433
              if ((stbuf.st_mode & 61440U) == 16384U) {
#line 433
                goto nospecial;
              } else {
                {
#line 433
                tmp___38 = savepass((auth_identity */* const  */)spassinvk, (uid_t const   )stbuf.st_uid);
                }
#line 433
                if (tmp___38) {
#line 455
                  mailfilter = 2;
#line 455
                  passinvk = spassinvk;
                } else {
                  nospecial: 
                  {
#line 451
                  nlog((char const   */* const  */)(densppr));
#line 451
                  logqnl((char const   */* const  */)rcfile);
#line 452
                  syslog(1, slogstr, densppr, rcfile);
                  }
                }
              }
            } else {
#line 433
              goto nospecial;
            }
          }
        }
      }
    }
  }
#line 461
  if (idhint) {
    {
#line 461
    pass = auth_finduser((char */* const  */)((char *)idhint), (int const   )0);
    }
#line 461
    if (pass) {
#line 461
      if (passinvk) {
        {
#line 461
        tmp___44 = auth_whatuid((auth_identity const   */* const  */)passinvk);
#line 461
        tmp___45 = auth_whatuid((auth_identity const   */* const  */)pass);
        }
#line 461
        if (tmp___44 == tmp___45) {
#line 461
          goto Setuser;
        } else {
#line 461
          goto _L___7;
        }
      } else {
#line 461
        goto _L___7;
      }
    } else {
#line 461
      goto _L___7;
    }
  } else {
    _L___7: /* CIL Label */ 
#line 461
    pass = passinvk;
#line 461
    if (pass) {
      Setuser: 
      {
#line 467
      gid = auth_whatgid((auth_identity const   */* const  */)pass);
#line 467
      uid = auth_whatuid((auth_identity const   */* const  */)pass);
#line 468
      tmp___40 = auth_username((auth_identity const   */* const  */)pass);
#line 468
      chp = (char *)tmp___40;
      }
#line 468
      if (! *chp) {
#line 469
        chp = buf;
      }
      {
#line 470
      setdef((char const   */* const  */)(lgname), (char const   */* const  */)chp);
#line 470
      tmp___41 = auth_homedir((auth_identity const   */* const  */)pass);
#line 470
      setdef((char const   */* const  */)(home), (char const   */* const  */)tmp___41);
      }
#line 471
      if (euid == 0U) {
        {
#line 472
        initgroups((char const   *)chp, gid);
        }
      }
      {
#line 473
      endgrent();
#line 474
      tmp___42 = auth_shell((auth_identity const   */* const  */)pass);
#line 474
      chp = (char *)tmp___42;
      }
#line 474
      if (! *chp) {
#line 475
        chp = (char *)(binsh);
      }
      {
#line 476
      setdef((char const   */* const  */)(shell), (char const   */* const  */)chp);
#line 476
      tmp___43 = auth_mailboxname((auth_identity */* const  */)pass);
#line 476
      setdef((char const   */* const  */)(orgmail), (char const   */* const  */)tmp___43);
      }
    } else {
      {
#line 482
      setdef((char const   */* const  */)(lgname), (char const   */* const  */)buf);
#line 482
      setdef((char const   */* const  */)(home), (char const   */* const  */)"/");
#line 482
      setdef((char const   */* const  */)(shell), (char const   */* const  */)(binsh));
#line 483
      setdef((char const   */* const  */)(orgmail), (char const   */* const  */)"/tmp/dead.letter");
#line 483
      setids();
      }
    }
  }
  {
#line 485
  endpwent();
#line 485
  auth_freeid(spassinvk);
  }
#line 487
  if (! presenviron) {
#line 487
    goto _L___8;
  } else
#line 487
  if (! mailfilter) {
    _L___8: /* CIL Label */ 
    {
#line 488
    tmp___46 = hostname();
#line 488
    setdef((char const   */* const  */)(host), (char const   */* const  */)tmp___46);
#line 488
    sputenv((char const   */* const  */)(lastfolder));
#line 488
    sputenv((char const   */* const  */)(exitcode));
#line 489
    initdefenv();
#line 491
    kp___1 = prestenv;
    }
    {
#line 491
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 491
      if (! *kp___1) {
#line 491
        goto while_break___11;
      }
      {
#line 492
      tmp___47 = kp___1;
#line 492
      kp___1 ++;
#line 492
      tmp___48 = eputenv(*tmp___47, (char */* const  */)buf);
      }
#line 492
      if (! tmp___48) {
        {
#line 493
        setoverflow();
        }
      }
    }
    while_break___11: /* CIL Label */ ;
    }
  }
  {
#line 499
  sgetcp = (char const   *)*((char const   * volatile  *)(& strenstr[6].sval));
#line 500
  tmp___49 = readparse(buf, (int (*/* const  */)())(& sgetc), (int const   )2);
  }
#line 500
  if (tmp___49) {
    {
#line 501
    nlog((char const   */* const  */)(orgmail));
#line 501
    elog((char const   */* const  */)(pathtoolong));
#line 501
    elog((char const   */* const  */)(newline));
#line 502
    syslog(2, "%s%s for LINEBUF for uid \"%lu\"\n", orgmail, pathtoolong, (unsigned long )uid);
#line 504
    *((char const   * volatile  *)(& strenstr[6].sval)) = (char const   */* volatile  */)(empty);
    }
#line 505
    goto nix_sysmbox;
  }
  {
#line 507
  tmp___50 = tstrdup((char const   */* const  */)buf);
#line 507
  *((char const   * volatile  *)(& strenstr[6].sval)) = (char const   */* volatile  */)tmp___50;
#line 507
  sgid = egid;
#line 508
  tmp___51 = getenv(orgmail);
#line 508
  chp = tmp___51;
  }
#line 509
  if (mailfilter) {
#line 509
    goto nix_sysmbox;
  } else {
    {
#line 509
    tmp___53 = screenmailbox(chp, egid, Deliverymode);
    }
#line 509
    if (! tmp___53) {
      nix_sysmbox: 
      {
#line 511
      rcst_nosgid();
#line 511
      sputenv((char const   */* const  */)(orgmail));
#line 512
      tmp___52 = strcmp((char const   *)chp, (char const   *)*((char const   * volatile  *)(& strenstr[6].sval)));
      }
#line 512
      if (! tmp___52) {
        {
#line 513
        tfree((void */* const  */)((char *)*((char const   * volatile  *)(& strenstr[6].sval))));
#line 513
        *((char const   * volatile  *)(& strenstr[6].sval)) = (char const   */* volatile  */)(empty);
        }
      }
    }
  }
  {
#line 515
  doumask((448 >> 3) | ((448 >> 3) >> 3));
#line 515
  eputenv((char const   */* const  */)(defpath), (char */* const  */)buf);
  }
  {
#line 516
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 516
    chp = (char *)*(argv + argc);
#line 516
    if (! chp) {
#line 516
      goto while_break___12;
    }
    {
#line 517
    argc ++;
#line 518
    tmp___54 = asenvcpy(chp);
    }
#line 518
    if (! tmp___54) {
#line 518
      if (mailfilter) {
#line 519
        gargv = & nullp;
#line 520
        restargv = argv + argc;
        {
#line 520
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 520
          if (! *(restargv + crestarg)) {
#line 520
            goto while_break___13;
          }
#line 520
          crestarg ++;
        }
        while_break___13: /* CIL Label */ ;
        }
#line 521
        goto while_break___12;
      }
    }
    {
#line 523
    resettmout();
    }
  }
  while_break___12: /* CIL Label */ ;
  }
#line 527
  if (etcrc) {
    {
#line 528
    tmp___55 = bopen((char const   */* const  */)etcrc);
    }
#line 528
    if (0 <= tmp___55) {
      {
#line 529
      yell((char const   */* const  */)(drcfile), (char const   */* const  */)etcrc);
      }
#line 531
      if (rcstate != 2) {
#line 532
        *((long volatile   *)(& strenvvar[5].val)) = (long volatile   )0;
      }
      {
#line 534
      eputenv((char const   */* const  */)(defspath), (char */* const  */)buf);
      }
#line 535
      goto startrc;
    }
#line 537
    etcrc = (char const   *)0;
  }
  {
#line 539
  while (1) {
    while_continue___14: /* CIL Label */ ;
    {
#line 540
    resettmout();
    }
#line 541
    if (rc < 0) {
#line 550
      goto findrc;
      {
#line 551
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 552
        if (suppmunreadable) {
          fake_rc: 
          {
#line 553
          readerr((char const   */* const  */)buf);
          }
        }
        {
#line 554
        tmp___56 = nextrcfile();
        }
#line 554
        if (! tmp___56) {
#line 555
          skiprc = 0;
#line 556
          goto nomore_rc;
        }
#line 558
        suppmunreadable = 0;
        findrc: 
#line 559
        i___0 = 0;
#line 560
        if ((unsigned long )rcfile == (unsigned long )(pmrc)) {
#line 560
          i___0 = 2;
#line 560
          if (i___0) {
            {
#line 561
            tmp___57 = pmrc2buf();
#line 561
            rcfile = (char const   *)buf2;
#line 561
            tmp___58 = strcpy((char */* __restrict  */)((char *)rcfile), (char const   */* __restrict  */)tmp___57);
            }
#line 561
            if ((int )*tmp___58 == 0) {
              pm_overflow: 
              {
#line 562
              strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)(pmrc));
              }
#line 563
              goto fake_rc;
            }
          } else {
#line 560
            goto _L___13;
          }
        } else {
          _L___13: /* CIL Label */ 
          {
#line 566
          tmp___60 = strchr(dirsep, (int )*rcfile);
          }
#line 566
          if (tmp___60) {
            {
#line 569
            strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)rcfile);
            }
          } else
#line 566
          if (mailfilter) {
#line 566
            goto _L___11;
          } else
#line 566
          if ((int const   )*rcfile == 46) {
            {
#line 566
            tmp___61 = strchr(dirsep, (int )*(rcfile + 1));
            }
#line 566
            if (tmp___61) {
              _L___11: /* CIL Label */ 
#line 566
              i___0 = 1;
#line 566
              if (i___0) {
                {
#line 569
                strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)rcfile);
                }
              } else {
#line 566
                goto _L___12;
              }
            } else {
#line 566
              goto _L___12;
            }
          } else {
            _L___12: /* CIL Label */ 
            {
#line 571
            tmp___59 = pmrc2buf();
#line 571
            chp = lastdirsep((char const   *)tmp___59);
#line 571
            *chp = (char )'\000';
            }
#line 572
            if ((int )*(buf + 0) == 0) {
#line 573
              goto pm_overflow;
            } else {
              {
#line 575
              strcpy((char */* __restrict  */)chp, (char const   */* __restrict  */)rcfile);
              }
            }
          }
        }
#line 577
        if (mailfilter != 2) {
#line 577
          if (rcstate == 1) {
            {
#line 579
            setids();
            }
          } else
#line 577
          if (! rcstate) {
            {
#line 577
            tmp___62 = stat((char const   */* __restrict  */)buf, (struct stat */* __restrict  */)(& stbuf___0));
            }
#line 577
            if (! tmp___62) {
              {
#line 579
              setids();
              }
            }
          }
        }
        {
#line 551
        tmp___63 = bopen((char const   */* const  */)buf);
        }
#line 551
        if (! (0 > tmp___63)) {
#line 551
          goto while_break___15;
        }
      }
      while_break___15: /* CIL Label */ ;
      }
#line 582
      if (rcstate != 2) {
#line 582
        if (mailfilter != 2) {
          {
#line 583
          closerc();
#line 584
          setids();
#line 585
          tmp___64 = bopen((char const   */* const  */)buf);
          }
#line 585
          if (0 > tmp___64) {
#line 586
            goto fake_rc;
          }
        }
      }
      {
#line 589
      tmp___65 = fstat(rc, & stbuf___0);
      }
#line 589
      if (tmp___65) {
        susp_rc: 
        {
#line 594
        closerc();
#line 594
        nlog((char const   */* const  */)(susprcf));
#line 594
        logqnl((char const   */* const  */)buf);
#line 595
        syslog(1, slogstr, susprcf, buf);
        }
#line 596
        goto fake_rc;
      }
#line 598
      if (mailfilter == 2) {
        {
#line 599
        setids();
        }
      }
#line 600
      erestrict = 1;
#line 601
      if (i___0 == 1) {
#line 602
        if (! didchd) {
          {
#line 603
          setmaildir((char const   */* const  */)(curdir));
          }
        }
      } else {
        {
#line 613
        chp = lastdirsep((char const   *)buf);
#line 613
        c = *chp;
        }
#line 614
        if (stbuf___0.st_uid != uid) {
#line 614
          if (stbuf___0.st_uid != 0U) {
#line 614
            goto _L___15;
          } else {
#line 614
            goto _L___18;
          }
        } else
        _L___18: /* CIL Label */ 
#line 614
        if (stbuf___0.st_mode & (unsigned int )((128 >> 3) >> 3)) {
#line 614
          goto _L___15;
        } else
#line 614
        if (i___0) {
#line 614
          if (stbuf___0.st_mode & (unsigned int )(128 >> 3)) {
#line 614
            if (stbuf___0.st_gid != gid) {
              _L___15: /* CIL Label */ 
              {
#line 614
              tmp___66 = strcmp(devnull, (char const   *)buf);
              }
#line 614
              if (tmp___66) {
#line 626
                *chp = c;
#line 627
                goto susp_rc;
              } else {
#line 614
                goto _L___17;
              }
            } else {
#line 614
              goto _L___17;
            }
          } else {
#line 614
            goto _L___17;
          }
        } else {
          _L___17: /* CIL Label */ 
          {
#line 614
          *chp = (char )'\000';
#line 614
          tmp___67 = stat((char const   */* __restrict  */)buf, (struct stat */* __restrict  */)(& stbuf___0));
          }
#line 614
          if (tmp___67) {
#line 626
            *chp = c;
#line 627
            goto susp_rc;
          } else
#line 614
          if (! (stbuf___0.st_mode & 512U)) {
#line 614
            if ((stbuf___0.st_mode & (unsigned int )(((128 >> 3) >> 3) | ((64 >> 3) >> 3))) == (unsigned int )(((128 >> 3) >> 3) | ((64 >> 3) >> 3))) {
#line 626
              *chp = c;
#line 627
              goto susp_rc;
            } else
#line 614
            if (i___0) {
#line 614
              if ((stbuf___0.st_mode & (unsigned int )((128 >> 3) | (64 >> 3))) == (unsigned int )((128 >> 3) | (64 >> 3))) {
#line 614
                if (stbuf___0.st_gid != gid) {
#line 626
                  *chp = c;
#line 627
                  goto susp_rc;
                }
              }
            }
          }
        }
#line 629
        *chp = c;
      }
      {
#line 636
      yell((char const   */* const  */)(drcfile), (char const   */* const  */)buf);
      }
#line 637
      if (! didchd) {
        {
#line 638
        tmp___68 = pmrc2buf();
#line 638
        chp = lastdirsep((char const   *)tmp___68);
        }
#line 638
        if ((unsigned long )chp > (unsigned long )(buf + 1)) {
#line 639
          chp --;
        }
#line 640
        *chp = (char )'\000';
#line 641
        if ((unsigned long )chp == (unsigned long )buf) {
          {
#line 642
          nlog((char const   */* const  */)"procmailrc");
#line 642
          elog((char const   */* const  */)(pathtoolong));
#line 642
          elog((char const   */* const  */)(newline));
#line 643
          syslog(2, "procmailrc%s for LINEBUF for uid \"%lu\"\n", pathtoolong, (unsigned long )uid);
          }
#line 645
          goto nomore_rc;
        }
        {
#line 647
        chp = buf;
#line 647
        tmp___71 = chdir((char const   *)chp);
        }
#line 647
        if (tmp___71) {
          {
#line 648
          chderr((char const   */* const  */)buf);
#line 649
          tmp___69 = tgetenv((char const   */* const  */)(home));
#line 649
          chp = (char *)tmp___69;
#line 649
          tmp___70 = chdir((char const   *)chp);
          }
#line 649
          if (tmp___70) {
            {
#line 650
            chderr((char const   */* const  */)chp);
#line 650
            chp = (char *)(curdir);
            }
          }
        }
        {
#line 652
        setmaildir((char const   */* const  */)chp);
        }
      }
      startrc: 
#line 654
      prevcond = 0;
#line 654
      lastcond = prevcond;
#line 654
      lastsucc = lastcond;
    }
    {
#line 656
    unlock((char **/* const  */)(& loclock));
    }
#line 657
    goto commint;
    {
#line 658
    while (1) {
      while_continue___16: /* CIL Label */ ;
      {
#line 659
      skipline();
      }
      commint: 
      {
#line 660
      while (1) {
        while_continue___17: /* CIL Label */ ;
        {
#line 660
        skipspace();
#line 660
        tmp___72 = testB((int const   )'\n');
        }
#line 660
        if (! tmp___72) {
#line 660
          goto while_break___17;
        }
      }
      while_break___17: /* CIL Label */ ;
      }
      {
#line 658
      tmp___73 = testB((int const   )'#');
      }
#line 658
      if (! tmp___73) {
#line 658
        goto while_break___16;
      }
    }
    while_break___16: /* CIL Label */ ;
    }
    {
#line 664
    tmp___116 = testB((int const   )':');
    }
#line 664
    if (tmp___116) {
      {
#line 667
      while (1) {
        while_continue___18: /* CIL Label */ ;
        {
#line 669
        tmp___74 = readparse(buf, (int (*/* const  */)())(& getb), (int const   )0);
        }
#line 669
        if (tmp___74) {
#line 670
          goto nextrc;
        }
        {
#line 672
        tmp___75 = strtol((char const   */* __restrict  */)buf, (char **/* __restrict  */)(& chp3),
                          10);
#line 672
        nrcond = (int )tmp___75;
#line 672
        chp = chp3;
        }
#line 674
        if ((unsigned long )chp == (unsigned long )buf) {
#line 675
          nrcond = -1;
        }
#line 676
        if (tolock) {
          {
#line 677
          tfree((void */* const  */)tolock);
          }
        }
#line 678
        i___0 = (int )(sizeof(flags) / sizeof(flags[0]) - 1UL);
        {
#line 678
        while (1) {
          while_continue___19: /* CIL Label */ ;
#line 678
          flags[i___0] = (char)0;
#line 678
          tmp___76 = i___0;
#line 678
          i___0 --;
#line 678
          if (! tmp___76) {
#line 678
            goto while_break___19;
          }
        }
        while_break___19: /* CIL Label */ ;
        }
#line 679
        tolock = (char *)0;
#line 679
        locknext = 0;
        {
#line 679
        while (1) {
          while_continue___20: /* CIL Label */ ;
          {
#line 680
          chp = skpspace((char const   *)chp);
#line 681
          tmp___77 = chp;
#line 681
          chp ++;
#line 681
          i___0 = (int )*tmp___77;
          }
          {
#line 688
          if (i___0 == 0) {
#line 688
            goto case_0___0;
          }
#line 692
          if (i___0 == 58) {
#line 692
            goto case_58;
          }
#line 682
          goto switch_default___0;
          switch_default___0: /* CIL Label */ 
          {
#line 683
          chp2 = strchr(exflags, i___0);
          }
#line 683
          if (! chp2) {
#line 684
            chp --;
#line 685
            goto switch_break___0;
          }
#line 687
          flags[chp2 - (char *)(exflags)] = (char)1;
          case_0___0: /* CIL Label */ 
#line 689
          if ((unsigned long )chp != (unsigned long )Tmnate) {
#line 690
            goto __Cont___0;
          }
#line 691
          goto switch_break___0;
          case_58: /* CIL Label */ 
#line 692
          locknext = 1;
#line 693
          if (*chp) {
            {
#line 694
            tolock = tstrdup((char const   */* const  */)chp);
#line 694
            tmp___78 = strchr((char const   *)chp, '\000');
#line 694
            chp = tmp___78 + 1;
            }
          } else {
#line 693
            chp ++;
#line 693
            if ((unsigned long )chp != (unsigned long )Tmnate) {
              {
#line 694
              tolock = tstrdup((char const   */* const  */)chp);
#line 694
              tmp___78 = strchr((char const   *)chp, '\000');
#line 694
              chp = tmp___78 + 1;
              }
            }
          }
          switch_break___0: /* CIL Label */ ;
          }
          {
#line 696
          concatenate(chp);
#line 696
          skipped((char const   */* const  */)chp);
          }
#line 697
          goto while_break___20;
          __Cont___0: /* CIL Label */ ;
        }
        while_break___20: /* CIL Label */ ;
        }
        {
#line 699
        i___0 = conditions(flags, (int const   )prevcond, (int const   )lastsucc,
                           (int const   )lastcond, nrcond);
        }
#line 700
        if (! skiprc) {
#line 701
          if (! flags[3]) {
#line 701
            if (! flags[4]) {
#line 702
              lastcond = i___0 == 1;
            }
          }
#line 703
          if (! prevcond) {
#line 704
            prevcond = i___0 == 1;
          } else
#line 703
          if (! flags[12]) {
#line 704
            prevcond = i___0 == 1;
          }
        }
#line 667
        if (! (i___0 == 2)) {
#line 667
          goto while_break___18;
        }
      }
      while_break___18: /* CIL Label */ ;
      }
#line 708
      startchar = themail;
#line 708
      tobesent = filled;
#line 709
      if (flags[5]) {
#line 710
        if (! flags[6]) {
#line 711
          tobesent = thebody - themail;
        }
      } else
#line 713
      if (flags[6]) {
#line 714
        startchar = thebody;
#line 714
        tobesent -= startchar - themail;
      }
      {
#line 715
      Stdout = (char *)0;
#line 715
      sh = 0;
#line 715
      succeed = sh;
#line 716
      pwait = (int )flags[9] | ((int )flags[10] << 1);
#line 717
      ignwerr = (int )flags[11];
#line 717
      skipspace();
      }
#line 718
      if (i___0) {
        {
#line 719
        zombiecollect();
#line 719
        concon((int const   )'\n');
        }
      }
      progrm: 
      {
#line 720
      tmp___109 = testB((int const   )'!');
      }
#line 720
      if (tmp___109) {
#line 721
        fencepost = (buf + linebuf) - 1;
#line 722
        if (! i___0) {
#line 723
          skiprc |= 1;
        }
        {
#line 724
        *fencepost = (char )'\000';
#line 725
        strncpy((char */* __restrict  */)buf, (char const   */* __restrict  */)strenstr[7].sval,
                linebuf - 1UL);
#line 726
        chp = strchr((char const   *)buf, '\000');
        }
#line 726
        if ((unsigned long )chp == (unsigned long )fencepost) {
#line 727
          goto fail;
        }
#line 728
        if (*(strenstr[8].sval)) {
          {
#line 729
          got = 0;
#line 730
          q = simplesplit(chp + 1, strenstr[8].sval, (char const   *)fencepost, & got);
          }
#line 730
          if (! q) {
#line 731
            goto fail;
          }
#line 732
          chp = q;
#line 732
          *chp = (char )'\000';
        }
        {
#line 734
        tmp___79 = readparse(chp + 1, (int (*/* const  */)())(& getb), (int const   )0);
        }
#line 734
        if (tmp___79) {
#line 735
          goto fail;
        }
#line 736
        if (i___0) {
#line 737
          if ((unsigned long )startchar == (unsigned long )themail) {
            {
#line 738
            *(startchar + filled) = (char )'\000';
#line 739
            tmp___80 = skipFrom_((char const   *)startchar, & tobesent);
#line 739
            startchar = (char *)tmp___80;
            }
          }
#line 741
          goto forward;
        }
#line 743
        skiprc --;
      } else {
        {
#line 745
        tmp___108 = testB((int const   )'|');
        }
#line 745
        if (tmp___108) {
          {
#line 746
          chp = buf2;
#line 747
          tmp___81 = getlline(chp, buf2 + linebuf);
          }
#line 747
          if (tmp___81) {
#line 748
            goto commint;
          }
#line 749
          if (i___0) {
            {
#line 750
            metaparse((char const   *)buf2);
            }
#line 751
            if (! sh) {
#line 751
              if ((unsigned long )(buf + 1) == (unsigned long )Tmnate) {
#line 752
                *buf = (char )'|';
#line 752
                tmp___82 = Tmnate;
#line 752
                Tmnate ++;
#line 752
                *((char *)tmp___82) = (char )'\000';
#line 753
                goto tostdout;
              }
            }
            forward: 
#line 755
            if (locknext) {
#line 756
              if (! tolock) {
#line 757
                *buf2 = (char )'\000';
#line 758
                chp = buf;
                {
#line 758
                while (1) {
                  while_continue___21: /* CIL Label */ ;
#line 758
                  tmp___85 = chp;
#line 758
                  chp ++;
#line 758
                  i___0 = (int )*tmp___85;
#line 758
                  if (! i___0) {
#line 758
                    goto while_break___21;
                  }
#line 759
                  if (i___0 == 62) {
#line 759
                    if ((int )*chp == 62) {
                      {
#line 760
                      chp = skpspace((char const   *)(chp + 1));
#line 761
                      tmp___83 = strcspn((char const   *)chp, " \t\n#`\'\");");
#line 761
                      i___0 = (int )tmp___83;
#line 761
                      memmove((void *)buf2, (void const   *)chp, (size_t )i___0);
#line 762
                      *(buf2 + i___0) = (char )'\000';
                      }
#line 763
                      if (sh) {
                        {
#line 764
                        chp = tstrdup((char const   */* const  */)buf);
#line 764
                        sgetcp = (char const   *)buf2;
#line 765
                        tmp___84 = readparse(buf, (int (*/* const  */)())(& sgetc),
                                             (int const   )0);
                        }
#line 765
                        if (tmp___84) {
#line 766
                          *buf2 = (char )'\000';
#line 767
                          goto nolock;
                        }
                        {
#line 769
                        strcpy((char */* __restrict  */)buf2, (char const   */* __restrict  */)buf);
#line 769
                        strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)chp);
#line 769
                        tfree((void */* const  */)chp);
                        }
                      }
#line 771
                      goto while_break___21;
                    }
                  }
                }
                while_break___21: /* CIL Label */ ;
                }
#line 773
                if (! *buf2) {
                  nolock: 
                  {
#line 774
                  nlog((char const   */* const  */)"Couldn\'t determine implicit lockfile from");
#line 775
                  logqnl((char const   */* const  */)buf);
                  }
                }
              }
              {
#line 778
              lcllock();
              }
#line 779
              if (! pwait) {
#line 780
                pwait = 2;
              }
            }
            {
#line 782
            rawnonl = (int )flags[14];
#line 782
            inittmout((char const   */* const  */)buf);
#line 782
            asgnlastf = 1;
            }
#line 783
            if (flags[8]) {
#line 783
              if (flags[7]) {
                {
#line 784
                nlog((char const   */* const  */)(extrns));
#line 784
                elog((char const   */* const  */)"copy-flag");
#line 784
                elog((char const   */* const  */)(ignrd));
                }
              } else
#line 783
              if (Stdout) {
                {
#line 784
                nlog((char const   */* const  */)(extrns));
#line 784
                elog((char const   */* const  */)"copy-flag");
#line 784
                elog((char const   */* const  */)(ignrd));
                }
              }
            }
#line 785
            if (flags[7]) {
#line 786
              if ((unsigned long )startchar == (unsigned long )themail) {
#line 786
                if (tobesent != filled) {
                  {
#line 787
                  tmp___86 = pipthrough(buf, startchar, (long const   )tobesent);
                  }
#line 787
                  if (! tmp___86) {
                    {
#line 788
                    readmail(1, (long const   )tobesent);
#line 788
                    succeed = ! pipw;
                    }
                  }
                } else {
#line 786
                  goto _L___19;
                }
              } else {
                _L___19: /* CIL Label */ 
                {
#line 790
                tmp___87 = pipthrough(buf, startchar, (long const   )tobesent);
                }
#line 790
                if (! tmp___87) {
                  {
#line 791
                  filled = startchar - themail;
#line 791
                  readmail(0, (long const   )0L);
#line 791
                  succeed = ! pipw;
                  }
                }
              }
            } else
#line 793
            if (Stdout) {
              {
#line 794
              tmp___88 = pipthrough(buf, startchar, (long const   )tobesent);
              }
#line 794
              if (! tmp___88) {
                {
#line 795
                succeed = 1;
#line 795
                postStdout();
                }
              }
            } else {
              {
#line 797
              tmp___89 = pipin((char */* const  */)buf, startchar, tobesent);
              }
#line 797
              if (! tmp___89) {
#line 798
                succeed = 1;
#line 798
                if (flags[8]) {
#line 799
                  goto logsetlsucc;
                } else {
#line 801
                  goto frmailed;
                }
              }
            }
#line 802
            goto setlsucc;
          }
        } else {
          {
#line 805
          tmp___107 = testB((int const   )-1);
          }
#line 805
          if (tmp___107) {
            {
#line 806
            nlog((char const   */* const  */)"Incomplete recipe\n");
            }
          } else {
#line 808
            end = (buf + linebuf) - 4;
#line 809
            ofiltflag = (int )flags[7];
#line 809
            if (ofiltflag) {
              {
#line 810
              flags[7] = (char)0;
#line 810
              nlog((char const   */* const  */)(extrns));
#line 810
              elog((char const   */* const  */)"filter-flag");
#line 810
              elog((char const   */* const  */)(ignrd));
              }
            }
            {
#line 811
            chp = gobenv(buf, end);
            }
#line 811
            if (chp) {
#line 812
              if ((unsigned long )chp == (unsigned long )end) {
                {
#line 813
                getlline(buf, buf + linebuf);
                }
#line 814
                goto fail;
              }
              {
#line 816
              tmp___90 = skipspace();
              }
#line 816
              if (tmp___90) {
#line 817
                chp ++;
              }
              {
#line 818
              tmp___93 = testB((int const   )'=');
              }
#line 818
              if (tmp___93) {
                {
#line 820
                tmp___91 = chp;
#line 820
                chp ++;
#line 820
                *tmp___91 = (char )'=';
#line 820
                *chp = (char )'\000';
#line 821
                tmp___92 = skipspace();
                }
#line 821
                if (tmp___92) {
#line 822
                  chp ++;
                }
                {
#line 823
                c___0 = getb();
#line 823
                ungetb((int const   )c___0);
                }
                {
#line 825
                if (c___0 == 124) {
#line 825
                  goto case_124;
                }
#line 825
                if (c___0 == 33) {
#line 825
                  goto case_124;
                }
#line 824
                goto switch_break___1;
                case_124: /* CIL Label */ 
                case_33: /* CIL Label */ 
#line 826
                if (i___0) {
                  {
#line 827
                  Stdout = tstrdup((char const   */* const  */)buf);
                  }
                }
#line 828
                goto progrm;
                switch_break___1: /* CIL Label */ ;
                }
              }
            } else {
              {
#line 832
              chp = strchr((char const   *)buf, '\000');
              }
#line 832
              if ((unsigned long )chp == (unsigned long )buf) {
                {
#line 832
                tmp___97 = testB((int const   )'{');
                }
#line 832
                if (tmp___97) {
                  {
#line 832
                  tmp___98 = chp;
#line 832
                  chp ++;
#line 832
                  *tmp___98 = (char )'{';
#line 832
                  *chp = (char )'\000';
#line 832
                  tmp___99 = testB((int const   )' ');
                  }
#line 832
                  if (tmp___99) {
#line 832
                    tmp___102 = 1;
                  } else {
                    {
#line 832
                    tmp___100 = testB((int const   )'\t');
                    }
#line 832
                    if (tmp___100) {
#line 832
                      tmp___102 = 1;
                    } else {
                      {
#line 832
                      tmp___101 = testB((int const   )'\n');
                      }
#line 832
                      if (tmp___101) {
#line 832
                        tmp___102 = 1;
                      } else {
#line 832
                        tmp___102 = 0;
                      }
                    }
                  }
#line 832
                  if (tmp___102) {
#line 837
                    if (locknext) {
#line 837
                      if (! flags[8]) {
                        {
#line 838
                        nlog((char const   */* const  */)(extrns));
#line 838
                        elog((char const   */* const  */)"locallockfile");
#line 838
                        elog((char const   */* const  */)(ignrd));
                        }
                      }
                    }
#line 839
                    if (flags[6]) {
                      {
#line 840
                      nlog((char const   */* const  */)(extrns));
#line 840
                      elog((char const   */* const  */)"deliver-body flag");
#line 840
                      elog((char const   */* const  */)(ignrd));
                      }
                    }
#line 841
                    if (flags[5]) {
                      {
#line 842
                      nlog((char const   */* const  */)(extrns));
#line 842
                      elog((char const   */* const  */)"deliver-head flag");
#line 842
                      elog((char const   */* const  */)(ignrd));
                      }
                    }
#line 843
                    if (flags[11]) {
                      {
#line 844
                      nlog((char const   */* const  */)(extrns));
#line 844
                      elog((char const   */* const  */)"ignore-write-error flag");
#line 844
                      elog((char const   */* const  */)(ignrd));
                      }
                    }
#line 845
                    if (flags[14]) {
                      {
#line 846
                      nlog((char const   */* const  */)(extrns));
#line 846
                      elog((char const   */* const  */)"raw-mode flag");
#line 846
                      elog((char const   */* const  */)(ignrd));
                      }
                    }
#line 847
                    if (! i___0) {
#line 848
                      skiprc += 2;
                    } else {
                      {
#line 850
                      tmp___94 = app_val_((struct dyna_long */* const  */)(& ifstack));
#line 850
                      *((int *)tmp___94) = prevcond;
#line 851
                      tmp___95 = app_val_((struct dyna_long */* const  */)(& ifstack));
#line 851
                      *((int *)tmp___95) = lastcond;
                      }
#line 852
                      if (locknext) {
                        {
#line 853
                        *buf2 = (char )'\000';
#line 853
                        lcllock();
                        }
#line 854
                        if (! pwait) {
#line 855
                          pwait = 2;
                        }
                      }
#line 857
                      succeed = 1;
#line 858
                      if (flags[8]) {
                        {
#line 859
                        yell((char const   */* const  */)"Forking", (char const   */* const  */)(procmailn));
#line 859
                        inittmout((char const   */* const  */)(procmailn));
#line 860
                        onguard();
#line 861
                        pidchild = sfork();
                        }
#line 861
                        if (pidchild) {
                          {
#line 869
                          offguard();
#line 870
                          tmp___96 = forkerr(pidchild, procmailn);
                          }
#line 870
                          if (tmp___96) {
#line 871
                            succeed = 0;
                          } else {
#line 874
                            if (pwait) {
                              {
#line 874
                              excode = waitfor(pidchild);
                              }
#line 874
                              if (excode != 0) {
#line 876
                                if (! (pwait & 2)) {
                                  {
#line 877
                                  progerr((char const   */* const  */)(procmailn),
                                          excode, pwait & 2);
                                  }
                                } else
#line 876
                                if (*((long volatile   *)(& strenvvar[5].val))) {
                                  {
#line 877
                                  progerr((char const   */* const  */)(procmailn),
                                          excode, pwait & 2);
                                  }
                                }
#line 878
                                succeed = 0;
                              }
                            }
#line 880
                            pidchild = 0;
#line 880
                            skiprc += 2;
#line 881
                            ifstack.filled -= 2;
                          }
                        } else {
#line 862
                          if (loclock) {
                            {
#line 863
                            tfree((void */* const  */)loclock);
#line 863
                            loclock = (char *)0;
                            }
                          }
#line 864
                          if (globlock) {
                            {
#line 865
                            tfree((void */* const  */)globlock);
#line 865
                            globlock = (char *)0;
                            }
                          }
                          {
#line 866
                          newid();
#line 866
                          offguard();
#line 866
                          duprcs();
                          }
                        }
                      }
#line 885
                      goto jsetlsucc;
                    }
#line 887
                    goto __Cont___1;
                  }
                }
              }
            }
#line 889
            if (! i___0) {
#line 890
              skiprc |= 1;
            }
            {
#line 891
            tmp___103 = readparse(chp, (int (*/* const  */)())(& getb), (int const   )0);
            }
#line 891
            if (tmp___103) {
              fail: 
              {
#line 892
              succeed = 0;
#line 892
              setoverflow();
              }
#line 893
              goto setlsucc;
            }
#line 895
            if (i___0) {
#line 896
              if (ofiltflag) {
#line 897
                startchar = themail;
#line 897
                tobesent = filled;
              }
              tostdout: 
#line 898
              rawnonl = (int )flags[14];
#line 899
              if (locknext) {
#line 900
                if (! tolock) {
                  {
#line 900
                  strcpy((char */* __restrict  */)buf2, (char const   */* __restrict  */)buf);
                  }
                }
                {
#line 901
                lcllock();
                }
              }
              {
#line 903
              inittmout((char const   */* const  */)buf);
#line 904
              tmp___104 = strchr((char const   *)buf, '\000');
#line 904
              tmp___105 = writefolder(buf, tmp___104 + 1, (char const   *)startchar,
                                      tobesent, (int const   )ignwerr, (int const   )0);
              }
#line 904
              if (tmp___105) {
#line 904
                succeed = 1;
#line 904
                if (! flags[8]) {
                  frmailed: 
#line 907
                  if (ifstack.vals) {
                    {
#line 908
                    tfree((void */* const  */)ifstack.vals);
                    }
                  }
#line 909
                  goto mailed;
                }
              }
              logsetlsucc: 
#line 911
              if (succeed) {
#line 911
                if (flags[8]) {
#line 911
                  if (strenvvar[6].val == 2L) {
                    {
#line 912
                    tmp___106 = tgetenv((char const   */* const  */)(lastfolder));
#line 912
                    logabstract((char const   */* const  */)tmp___106);
                    }
                  }
                }
              }
              setlsucc: 
#line 913
              rawnonl = 0;
              jsetlsucc: 
#line 914
              lastsucc = succeed;
#line 914
              lasttell = (off_t )-1;
            }
#line 916
            skiprc &= -2;
          }
        }
      }
    } else {
      {
#line 919
      tmp___115 = testB((int const   )'}');
      }
#line 919
      if (tmp___115) {
#line 920
        if (skiprc > 1) {
#line 921
          skiprc -= 2;
        } else
#line 922
        if (ifstack.filled > ifdepth) {
#line 923
          (ifstack.filled) --;
#line 923
          lastcond = (ifstack.vals + ifstack.filled)->i;
#line 924
          (ifstack.filled) --;
#line 924
          prevcond = (ifstack.vals + ifstack.filled)->i;
        } else {
          {
#line 927
          nlog((char const   */* const  */)"Closing brace unexpected\n");
          }
        }
      } else {
        {
#line 930
        end___0 = buf + linebuf;
#line 931
        chp = gobenv(buf, end___0);
        }
#line 931
        if (! chp) {
#line 932
          if (! *buf) {
            {
#line 933
            getbl(buf, end___0);
            }
          }
          {
#line 934
          skipped((char const   */* const  */)buf);
          }
#line 935
          goto __Cont___1;
        }
#line 937
        if ((unsigned long )chp == (unsigned long )end___0) {
          nextrc: 
          {
#line 938
          tmp___110 = poprc();
          }
#line 938
          if (tmp___110) {
#line 939
            goto __Cont___1;
          } else {
            {
#line 938
            tmp___111 = wipetcrc();
            }
#line 938
            if (tmp___111) {
#line 939
              goto __Cont___1;
            } else {
#line 941
              goto while_break___14;
            }
          }
        }
        {
#line 942
        skipspace();
#line 943
        tmp___113 = testB((int const   )'=');
        }
#line 943
        if (tmp___113) {
          {
#line 944
          *chp = (char )'=';
#line 945
          chp ++;
#line 945
          tmp___112 = readparse(chp, (int (*/* const  */)())(& getb), (int const   )1);
          }
#line 945
          if (tmp___112) {
            {
#line 946
            setoverflow();
            }
#line 947
            goto __Cont___1;
          }
        } else {
#line 951
          chp ++;
#line 951
          *chp = (char )'\000';
        }
#line 952
        if (! skiprc) {
          {
#line 953
          tmp___114 = sputenv((char const   */* const  */)buf);
#line 953
          chp2 = (char *)tmp___114;
#line 953
          *(chp + -1) = (char )'\000';
#line 953
          asenv((char const   */* const  */)chp2);
          }
        }
      }
    }
    __Cont___1: /* CIL Label */ 
#line 539
    if (! (rc < 0)) {
      {
#line 539
      tmp___117 = testB((int const   )-1);
      }
#line 539
      if (tmp___117) {
        {
#line 539
        tmp___118 = poprc();
        }
#line 539
        if (! tmp___118) {
          {
#line 539
          tmp___119 = wipetcrc();
          }
#line 539
          if (! tmp___119) {
#line 539
            goto while_break___14;
          }
        }
      }
    }
  }
  while_break___14: /* CIL Label */ ;
  }
  nomore_rc: 
#line 959
  if (ifstack.vals) {
    {
#line 960
    tfree((void */* const  */)ifstack.vals);
    }
  }
  {
#line 962
  concon((int const   )'\n');
#line 962
  succeed___0 = 0;
#line 963
  chp = (char *)*((char const   * volatile  *)(& strenstr[6].sval));
  }
#line 963
  if (*chp) {
    {
#line 965
    setuid(uid);
#line 966
    tmp___120 = strlen((char const   *)chp);
#line 966
    tmp___121 = strlen(strenstr[1].sval);
#line 966
    len = (int )((tmp___120 + tmp___121) + 24UL);
    }
#line 966
    if (linebuf < (size_t )len) {
      {
#line 967
      linebuf = (size_t )len;
#line 967
      mallocbuffers(linebuf, 1);
      }
    }
    {
#line 968
    tmp___122 = writefolder(chp, (char *)0, (char const   *)themail, filled, (int const   )0,
                            (int const   )1);
    }
#line 968
    if (tmp___122) {
#line 969
      succeed___0 = 1;
    }
  }
#line 971
  if (! succeed___0) {
    {
#line 971
    tmp___124 = tgetenv((char const   */* const  */)(orgmail));
#line 971
    chp2 = (char *)tmp___124;
    }
#line 971
    if (*chp2) {
      {
#line 971
      tmp___125 = strcmp((char const   *)chp2, (char const   *)chp);
      }
#line 971
      if (tmp___125) {
        {
#line 972
        rawnonl = 0;
#line 973
        tmp___123 = writefolder(chp2, (char *)0, (char const   *)themail, filled,
                                (int const   )0, (int const   )0);
        }
#line 973
        if (tmp___123) {
#line 974
          succeed___0 = 1;
        }
      }
    }
  }
#line 976
  if (succeed___0) {
    mailed: 
#line 977
    rawnonl = 0;
#line 977
    retval = 0;
  }
  {
#line 979
  unlock((char **/* const  */)(& loclock));
#line 979
  Terminate();
  }
#line 980
  return (0);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
int eqFrom_(char const   * const  a ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 983
  tmp = strncmp((char const   *)a, From_, sizeof(From_) - 1UL);
  }
#line 983
  if (tmp) {
#line 983
    tmp___0 = 0;
  } else {
#line 983
    tmp___0 = 1;
  }
#line 983
  return (tmp___0);
}
}
#line 986 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/procmail.c"
char const   *skipFrom_(char const   *startchar , long *tobesentp ) 
{ 
  long tobesent ;
  char i___0 ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 987
  tmp___1 = eqFrom_((char const   */* const  */)startchar);
  }
#line 987
  if (tmp___1) {
#line 989
    tobesent = *tobesentp;
    {
#line 990
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 991
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 991
        tmp = startchar;
#line 991
        startchar ++;
#line 991
        i___0 = (char )*tmp;
#line 991
        tobesent --;
#line 991
        if (tobesent) {
#line 991
          if ((int )i___0 != 10) {
#line 991
            tmp___0 = 1;
          } else {
#line 991
            tmp___0 = 0;
          }
        } else {
#line 991
          tmp___0 = 0;
        }
#line 991
        if (! tmp___0) {
#line 991
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 990
      if (! ((int const   )*startchar == 62)) {
#line 990
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 993
    *tobesentp = tobesent;
  }
#line 995
  return (startchar);
}
}
#line 826 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 956
extern int fsync(int __fd ) ;
#line 993
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) truncate)(char const   *__file ,
                                                                                               __off_t __length ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 342 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 3 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/robust.h"
void ssleep(unsigned int const   seconds ) ;
#line 13
int rwrite(int const   fd , void const   * const  a , int const   len ) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.h"
char *egrepin(char *expr , char const   *source , long const   len , int casesens ) ;
#line 3 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/common.h"
void detab(char *p___0 ) ;
#line 3 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/exopen.h"
int unique(char * const  full , char *p___0 , size_t const   len , mode_t const   mode ,
           int const   verbos , int const   chownit ) ;
#line 3
int rlink(char const   * const  old___0 , char const   * const  newn , struct stat *st ) ;
#line 3
int hlink(char const   * const  old___0 , char const   * const  newn ) ;
#line 3 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/locking.h"
void lockit(char *name___1 , char ** const  lockp ) ;
#line 20
int fdlock(int fd ) ;
#line 20
int fdunlock(void) ;
#line 15 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/mailfold.h"
int logopened  ;
#line 15 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/mailfold.h"
int rawnonl  ;
#line 16 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/mailfold.h"
off_t lasttell  ;
#line 30 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/mailfold.c"
static long lastdump  ;
#line 31 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/mailfold.c"
static int volatile   mailread  ;
#line 32 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/mailfold.c"
static struct dyna_long confield  ;
#line 33 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/mailfold.c"
static char const   *realstart  ;
#line 33 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/mailfold.c"
static char const   *restbody  ;
#line 34 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/mailfold.c"
static char const   from_expr[7]  = {      (char const   )'\n',      (char const   )'F',      (char const   )'r',      (char const   )'o', 
        (char const   )'m',      (char const   )' ',      (char const   )'\000'};
#line 36 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/mailfold.c"
static char const   *fifrom(char const   *fromw , char const   * const  lbound , char * const  ubound ) 
{ 
  int i___0 ;
  char const   *tmp ;
  char *tmp___0 ;

  {
#line 39
  i___0 = (int )*ubound;
#line 39
  *ubound = (char )'\000';
#line 39
  if ((unsigned long )fromw > (unsigned long )lbound) {
#line 39
    tmp = (char const   */* const  */)fromw;
  } else {
#line 39
    tmp = lbound;
  }
  {
#line 39
  tmp___0 = strstr((char const   *)tmp, from_expr);
#line 39
  fromw = (char const   *)tmp___0;
#line 39
  *ubound = (char )i___0;
  }
#line 40
  return (fromw);
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/mailfold.c"
static int doesc  ;
#line 46
static long getchunk(int const   s , char const   *fromw , long const   len ) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/mailfold.c"
static char const   esc[2]  = {      (char const   )'>',      (char const   )'\000'};
#line 46 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/mailfold.c"
static char const   *ffrom  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/mailfold.c"
static char const   *endp  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/mailfold.c"
static long getchunk(int const   s , char const   *fromw , long const   len ) 
{ 
  long tmp ;

  {
#line 47
  if (doesc) {
    {
#line 48
    doesc = 0;
#line 48
    rwrite(s, (void const   */* const  */)(esc), (int const   )(sizeof(esc) - 1UL));
#line 48
    lastdump ++;
    }
  }
#line 49
  ffrom = (char const   *)0;
#line 50
  if ((unsigned long )fromw < (unsigned long )thebody) {
    {
#line 51
    ffrom = fifrom(fromw, (char const   */* const  */)realstart, (char */* const  */)thebody);
    }
  }
#line 52
  if (! ffrom) {
#line 52
    endp = fromw + len;
#line 52
    if ((unsigned long )endp > (unsigned long )restbody) {
#line 53
      endp += (sizeof(from_expr) - 1UL) - 1UL;
#line 53
      ffrom = (char const   *)(themail + filled);
#line 53
      if ((unsigned long )endp > (unsigned long )ffrom) {
#line 54
        endp = (char const   *)((char *)ffrom);
      }
      {
#line 55
      ffrom = fifrom(fromw, (char const   */* const  */)restbody, (char */* const  */)endp);
      }
    }
  }
#line 57
  if (ffrom) {
#line 57
    doesc = 1;
#line 57
    tmp = (ffrom - fromw) + 1L;
  } else {
#line 57
    tmp = (long )len;
  }
#line 57
  return (tmp);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/mailfold.c"
long dump(int const   s , int const   type , char const   *source , long len ) 
{ 
  int i___0 ;
  long part ;
  int *tmp ;
  int tmp___0 ;
  long tmp___1 ;
  struct stat stbuf ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int serrno ;
  int *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  long tmp___13 ;

  {
  {
#line 80
  i___0 = -1;
#line 80
  lasttell = (off_t )i___0;
#line 80
  tmp = __errno_location();
#line 80
  *tmp = 9;
  }
#line 81
  if (s >= 0) {
#line 82
    if (type > 1) {
      {
#line 82
      lseek((int )s, (off_t )0, 2);
#line 82
      tmp___0 = fdlock((int )s);
      }
#line 82
      if (tmp___0) {
        {
#line 83
        nlog((char const   */* const  */)"Kernel-lock failed\n");
        }
      }
    }
#line 84
    lastdump = len;
#line 84
    doesc = 0;
#line 85
    if (type == 3) {
#line 85
      if (! rawnonl) {
        {
#line 85
        tmp___1 = getchunk(s, source, (long const   )len);
#line 85
        part = tmp___1;
        }
      } else {
#line 85
        part = len;
      }
    } else {
#line 85
      part = len;
    }
    {
#line 86
    lasttell = lseek((int )s, (off_t )0, 2);
    }
#line 87
    if (! rawnonl) {
#line 90
      if (part) {
#line 90
        if (type == 3) {
          {
#line 92
          tmp___2 = source;
#line 92
          source ++;
#line 92
          rwrite(s, (void const   */* const  */)tmp___2, (int const   )1);
#line 92
          len --;
#line 92
          part --;
#line 93
          tmp___3 = fstat((int )s, & stbuf);
          }
#line 93
          if (tmp___3) {
            {
#line 95
            ssleep((unsigned int const   )1);
            }
          } else
#line 93
          if (stbuf.st_mtim.tv_sec == stbuf.st_atim.tv_sec) {
            {
#line 95
            ssleep((unsigned int const   )1);
            }
          }
        }
      }
    }
#line 99
    goto jin;
    {
#line 100
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 101
      part = getchunk(s, source, (long const   )len);
      }
      jin: 
      {
#line 102
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 102
        if (part) {
#line 102
          if (16384L < part) {
#line 102
            tmp___4 = 16384;
          } else {
#line 102
            tmp___4 = (int )part;
          }
          {
#line 102
          i___0 = rwrite(s, (void const   */* const  */)source, (int const   )tmp___4);
          }
#line 102
          if (! i___0) {
#line 102
            goto while_break___0;
          }
        } else {
#line 102
          goto while_break___0;
        }
#line 103
        if (i___0 < 0) {
#line 104
          goto writefin;
        }
#line 105
        part -= (long )i___0;
#line 105
        len -= (long )i___0;
#line 105
        source += i___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 100
      if (! len) {
#line 100
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 109
    if (! rawnonl) {
#line 110
      if (! len) {
#line 110
        if (lastdump < 2L) {
          {
#line 111
          lastdump ++;
#line 111
          rwrite(s, (void const   */* const  */)(newline), (int const   )1);
          }
        } else
#line 110
        if ((int const   )*(source + -1) == 10) {
#line 110
          if (! ((int const   )*(source + -2) == 10)) {
            {
#line 111
            lastdump ++;
#line 111
            rwrite(s, (void const   */* const  */)(newline), (int const   )1);
            }
          }
        } else {
          {
#line 111
          lastdump ++;
#line 111
          rwrite(s, (void const   */* const  */)(newline), (int const   )1);
          }
        }
      }
    }
    writefin: 
#line 115
    if (type != 0) {
      {
#line 115
      tmp___5 = fsync((int )s);
      }
#line 115
      if (tmp___5) {
        {
#line 115
        tmp___6 = __errno_location();
        }
#line 115
        if (*tmp___6 != 22) {
#line 115
          tmp___7 = 1;
        } else {
#line 115
          tmp___7 = 0;
        }
      } else {
#line 115
        tmp___7 = 0;
      }
    } else {
#line 115
      tmp___7 = 0;
    }
#line 115
    i___0 = tmp___7;
#line 116
    if (type > 1) {
      {
#line 117
      tmp___8 = __errno_location();
#line 117
      serrno = *tmp___8;
#line 118
      tmp___9 = fdunlock();
      }
#line 118
      if (tmp___9) {
        {
#line 119
        nlog((char const   */* const  */)"Kernel-unlock failed\n");
        }
      }
      {
#line 120
      tmp___10 = __errno_location();
#line 120
      *tmp___10 = serrno;
      }
    }
    {
#line 122
    tmp___11 = rclose(s);
    }
#line 122
    if (tmp___11) {
#line 122
      tmp___12 = 1;
    } else
#line 122
    if (i___0) {
#line 122
      tmp___12 = 1;
    } else {
#line 122
      tmp___12 = 0;
    }
#line 122
    i___0 = tmp___12;
  }
#line 124
  if (i___0) {
#line 124
    if (! len) {
#line 124
      tmp___13 = -1L;
    } else {
#line 124
      tmp___13 = len;
    }
  } else {
#line 124
    tmp___13 = len;
  }
#line 124
  return (tmp___13);
}
}
#line 128
static int dirfile(char * const  chp , int const   linkonly , int const   type ) ;
#line 128 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/mailfold.c"
static char const   lkingto[11]  = 
#line 128
  {      (char const   )'L',      (char const   )'i',      (char const   )'n',      (char const   )'k', 
        (char const   )'i',      (char const   )'n',      (char const   )'g',      (char const   )' ', 
        (char const   )'t',      (char const   )'o',      (char const   )'\000'};
#line 127 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/mailfold.c"
static int dirfile(char * const  chp , int const   linkonly , int const   type ) 
{ 
  long i___0 ;
  long j ;
  DIR *dirp ;
  struct dirent *dp ;
  char *chp2 ;
  int ok ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  struct stat stbuf ;
  size_t mpl ;
  size_t tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  size_t len ;
  char *p___0 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 129
  if (type == 2) {
    {
#line 130
    i___0 = 0L;
#line 133
    dirp = opendir((char const   *)buf);
    }
#line 133
    if (dirp) {
      {
#line 134
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 134
        dp = readdir(dirp);
        }
#line 134
        if (! dp) {
#line 134
          goto while_break;
        }
        {
#line 135
        j = strtol((char const   */* __restrict  */)(dp->d_name), (char **/* __restrict  */)(& chp2),
                   10);
        }
#line 135
        if (j > i___0) {
#line 135
          if (! *chp2) {
#line 136
            i___0 = j;
          }
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 137
      closedir(dirp);
      }
    } else {
      {
#line 140
      readerr((char const   */* const  */)buf);
      }
    }
#line 142
    if ((unsigned long )(chp - (char */* const  */)buf) + ((((8UL * sizeof(i___0)) * 4UL) / 10UL + 1UL) + 1UL) > linebuf) {
      exlb: 
      {
#line 143
      nlog((char const   */* const  */)(exceededlb));
#line 143
      setoverflow();
      }
#line 144
      goto ret;
    }
    {
#line 147
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 147
      i___0 ++;
#line 147
      ultstr(0, (unsigned long )i___0, (char *)chp);
      }
#line 147
      if (linkonly) {
        {
#line 147
        tmp = rlink(buf2, buf, 0);
#line 147
        ok = tmp;
        }
      } else {
        {
#line 147
        tmp___0 = hlink((char const   */* const  */)buf2, (char const   */* const  */)buf);
#line 147
        ok = tmp___0;
        }
      }
#line 147
      if (ok) {
        {
#line 147
        tmp___1 = __errno_location();
        }
#line 147
        if (! (*tmp___1 == 17)) {
#line 147
          goto while_break___0;
        }
      } else {
#line 147
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 149
    if (linkonly) {
      {
#line 150
      yell((char const   */* const  */)(lkingto), (char const   */* const  */)buf);
      }
#line 151
      if (ok) {
#line 152
        goto nolnk;
      }
#line 153
      goto didlnk;
    }
    {
#line 156
    unlink((char const   *)buf2);
    }
#line 157
    goto opn;
  } else
#line 159
  if (type == 1) {
    {
#line 160
    tmp___2 = unique(buf, chp, linebuf, ((((384 | (256 >> 3)) | (128 >> 3)) | ((256 >> 3) >> 3)) | ((128 >> 3) >> 3)) | ((64 >> 3) >> 3),
                     *((long volatile   *)(& strenvvar[5].val)), 0);
    }
#line 160
    if (! tmp___2) {
#line 162
      goto ret;
    }
    {
#line 163
    unlink((char const   *)buf);
#line 164
    strncpy((char */* __restrict  */)((chp - (sizeof("/new") - 1UL)) - 1), (char const   */* __restrict  */)(maildirnew),
            sizeof("/new") - 1UL);
    }
  } else {
    {
#line 168
    tmp___3 = strlen(strenstr[2].sval);
#line 168
    mpl = tmp___3;
    }
#line 169
    if (((size_t )(chp - (char */* const  */)buf) + mpl) + ((((8UL * sizeof(stbuf.st_ino)) * 4UL) / 10UL + 1UL) + 1UL) > linebuf) {
#line 170
      goto exlb;
    }
    {
#line 171
    stat((char const   */* __restrict  */)buf2, (struct stat */* __restrict  */)(& stbuf));
#line 172
    tmp___4 = strcpy((char */* __restrict  */)chp, (char const   */* __restrict  */)strenstr[2].sval);
#line 172
    ultoan(stbuf.st_ino, tmp___4 + mpl);
    }
#line 173
    if (! linkonly) {
      {
#line 173
      tmp___5 = stat((char const   */* __restrict  */)buf, (struct stat */* __restrict  */)(& stbuf));
      }
#line 173
      if (tmp___5) {
        {
#line 173
        tmp___6 = __errno_location();
        }
#line 173
        if (*tmp___6 != 2) {
#line 174
          goto ret;
        }
      } else {
#line 174
        goto ret;
      }
    }
  }
#line 176
  if (linkonly) {
    {
#line 177
    yell((char const   */* const  */)(lkingto), (char const   */* const  */)buf);
#line 178
    tmp___10 = rlink(buf2, buf, 0);
    }
#line 178
    if (tmp___10) {
      nolnk: 
      {
#line 179
      nlog((char const   */* const  */)"Couldn\'t make link to");
#line 179
      logqnl((char const   */* const  */)buf);
      }
    } else {
      didlnk: 
      {
#line 183
      Stdout = buf;
#line 183
      primeStdout((char const   */* const  */)(empty));
#line 184
      tmp___7 = strlen((char const   *)(Stdout + Stdfilled));
#line 184
      len = (size_t )Stdfilled + tmp___7;
#line 185
      tmp___8 = strlen((char const   *)buf);
#line 185
      Stdfilled = (long )((len + 1UL) + tmp___8);
#line 185
      tmp___9 = trealloc(Stdout, (size_t )(Stdfilled + 1L));
#line 185
      p___0 = (char *)tmp___9;
#line 186
      *(p___0 + len) = (char )' ';
#line 186
      strcpy((char */* __restrict  */)((p___0 + len) + 1), (char const   */* __restrict  */)buf);
#line 186
      retbStdout((char */* const  */)p___0);
      }
    }
#line 188
    goto ret;
  }
  {
#line 190
  tmp___12 = rename((char const   *)buf2, (char const   *)buf);
  }
#line 190
  if (! tmp___12) {
    opn: 
    {
#line 191
    tmp___11 = opena((char const   */* const  */)buf);
    }
#line 191
    return (tmp___11);
  }
  ret: 
#line 193
  return (-1);
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/mailfold.c"
int writefolder(char *boxname , char *linkfolder , char const   *source , long len ,
                int const   ignwerr___0 , int const   dolock___0 ) 
{ 
  char *chp ;
  char *chp2 ;
  mode_t mode ;
  int fd ;
  int type ;
  size_t blen ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  char *tmp___7 ;
  long tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  long tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;

  {
#line 199
  asgnlastf = 1;
#line 200
  if ((int )*boxname == 124) {
#line 200
    if (! linkfolder) {
      {
#line 201
      setlastfolder((char const   */* const  */)boxname);
#line 202
      fd = rdup((int const   )savstdout);
#line 203
      type = 0;
      }
#line 204
      goto dumpc;
    } else
#line 200
    if ((unsigned long )linkfolder == (unsigned long )Tmnate) {
      {
#line 201
      setlastfolder((char const   */* const  */)boxname);
#line 202
      fd = rdup((int const   )savstdout);
#line 203
      type = 0;
      }
#line 204
      goto dumpc;
    }
  }
#line 206
  if ((unsigned long )boxname != (unsigned long )buf) {
    {
#line 207
    strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)boxname);
    }
  }
#line 208
  if (linkfolder) {
#line 210
    blen = (size_t )(Tmnate - (char const   *)linkfolder);
#line 210
    if (blen) {
      {
#line 211
      tmp = tmalloc(blen);
#line 211
      tmp___0 = memmove(tmp, (void const   *)linkfolder, blen);
#line 211
      linkfolder = (char *)tmp___0;
#line 211
      Tmnate = (char const   *)(linkfolder + blen);
      }
    } else {
#line 213
      linkfolder = (char *)0;
    }
  }
  {
#line 215
  type = foldertype(0, 0, & mode, 0);
#line 216
  chp = strchr((char const   *)buf, '\000');
  }
  {
#line 218
  if (type == 3) {
#line 218
    goto case_3;
  }
#line 247
  if (type == -1) {
#line 247
    goto exlb;
  }
#line 249
  if (type == -2) {
#line 249
    goto retf;
  }
#line 253
  if (type == 1) {
#line 253
    goto case_1;
  }
#line 279
  goto switch_default___0;
  case_3: /* CIL Label */ 
#line 219
  if (linkfolder) {
    {
#line 220
    concatenate(linkfolder);
#line 220
    skipped((char const   */* const  */)linkfolder);
#line 220
    tfree((void */* const  */)linkfolder);
    }
  }
  {
#line 221
  tmp___1 = strcmp(devnull, (char const   *)buf);
  }
#line 221
  if (tmp___1) {
#line 223
    if (! ((unsigned int )((64 >> 3) >> 3) & (mode | cumask))) {
      {
#line 224
      chmod((char const   *)boxname, mode | (unsigned int )((64 >> 3) >> 3));
      }
    }
  } else {
#line 222
    type = 0;
#line 222
    rawnonl = 1;
  }
#line 225
  if (dolock___0) {
#line 225
    if (type != 0) {
      {
#line 226
      strcpy((char */* __restrict  */)chp, (char const   */* __restrict  */)strenstr[1].sval);
      }
#line 227
      if (! globlock) {
        {
#line 228
        tmp___2 = tstrdup((char const   */* const  */)buf);
#line 228
        lockit(tmp___2, (char **/* const  */)(& loclock));
        }
      } else {
        {
#line 227
        tmp___3 = strcmp((char const   *)buf, (char const   *)globlock);
        }
#line 227
        if (tmp___3) {
          {
#line 228
          tmp___2 = tstrdup((char const   */* const  */)buf);
#line 228
          lockit(tmp___2, (char **/* const  */)(& loclock));
          }
        }
      }
#line 229
      *chp = (char )'\000';
    }
  }
  {
#line 231
  fd = opena((char const   */* const  */)boxname);
  }
  dumpc: 
  {
#line 232
  tmp___6 = dump((int const   )fd, (int const   )type, source, len);
  }
#line 232
  if (tmp___6) {
#line 232
    if (! ignwerr___0) {
      dumpf: 
      {
#line 233
      tmp___4 = __errno_location();
      }
      {
#line 234
      if (*tmp___4 == 28) {
#line 234
        goto case_28;
      }
#line 237
      if (*tmp___4 == 122) {
#line 237
        goto case_122;
      }
#line 240
      goto switch_default;
      case_28: /* CIL Label */ 
      {
#line 234
      nlog((char const   */* const  */)"No space left to finish writing");
#line 234
      logqnl((char const   */* const  */)buf);
      }
#line 235
      goto switch_break___0;
      case_122: /* CIL Label */ 
      {
#line 237
      nlog((char const   */* const  */)"Quota exceeded while writing");
#line 237
      logqnl((char const   */* const  */)buf);
      }
#line 238
      goto switch_break___0;
      switch_default: /* CIL Label */ 
      {
#line 240
      writeerr((char const   */* const  */)buf);
      }
      switch_break___0: /* CIL Label */ ;
      }
#line 242
      if (lasttell >= 0L) {
        {
#line 242
        tmp___5 = truncate((char const   *)boxname, lasttell);
        }
#line 242
        if (! tmp___5) {
#line 242
          if (logopened) {
            {
#line 243
            nlog((char const   */* const  */)"Truncated file to former size\n");
            }
          } else
#line 242
          if (*((long volatile   *)(& strenvvar[5].val))) {
            {
#line 243
            nlog((char const   */* const  */)"Truncated file to former size\n");
            }
          }
        }
      }
      ret0: 
#line 244
      return (0);
    }
  }
#line 246
  return (1);
  exlb: 
  case_neg_1: /* CIL Label */ 
  {
#line 248
  nlog((char const   */* const  */)(exceededlb));
#line 248
  setoverflow();
  }
  retf: 
  case_neg_2: /* CIL Label */ 
#line 250
  if (linkfolder) {
    {
#line 251
    tfree((void */* const  */)linkfolder);
    }
  }
#line 252
  goto ret0;
  case_1: /* CIL Label */ 
#line 254
  if ((unsigned long )source == (unsigned long )themail) {
    {
#line 255
    source = skipFrom_(source, & len);
    }
  }
  {
#line 256
  strcpy((char */* __restrict  */)buf2, (char const   */* __restrict  */)buf);
#line 257
  chp2 = (buf2 + (chp - buf)) - (sizeof("/new") - 1UL);
#line 258
  tmp___7 = chp;
#line 258
  chp ++;
#line 258
  *tmp___7 = (char )*((dirsep + (sizeof("/") - 1UL)) - 1);
#line 259
  fd = unique(buf, chp, linebuf, ((((384 | (256 >> 3)) | (128 >> 3)) | ((256 >> 3) >> 3)) | ((128 >> 3) >> 3)) | ((64 >> 3) >> 3),
              *((long volatile   *)(& strenvvar[5].val)), 8);
  }
#line 259
  if (0 > fd) {
#line 260
    goto nfail;
  }
  {
#line 261
  tmp___8 = dump((int const   )fd, (int const   )1, source, len);
  }
#line 261
  if (tmp___8) {
#line 261
    if (! ignwerr___0) {
#line 262
      goto failed;
    }
  }
  {
#line 263
  strcpy((char */* __restrict  */)chp2, (char const   */* __restrict  */)(maildirnew));
#line 264
  chp2 += sizeof("/new") - 1UL;
#line 265
  tmp___9 = chp2;
#line 265
  chp2 ++;
#line 265
  *tmp___9 = (char )*((dirsep + (sizeof("/") - 1UL)) - 1);
#line 266
  strcpy((char */* __restrict  */)chp2, (char const   */* __restrict  */)chp);
#line 267
  tmp___10 = rename((char const   *)buf, (char const   *)buf2);
  }
#line 267
  if (tmp___10) {
    {
#line 268
    unlink((char const   *)buf);
    }
    nfail: 
    {
#line 269
    nlog((char const   */* const  */)"Couldn\'t create or rename temp file");
#line 269
    logqnl((char const   */* const  */)buf);
    }
#line 270
    goto retf;
  }
  {
#line 272
  setlastfolder((char const   */* const  */)buf2);
  }
#line 273
  goto switch_break;
  switch_default___0: /* CIL Label */ 
  {
#line 280
  tmp___11 = chp;
#line 280
  chp ++;
#line 280
  *tmp___11 = (char )*((dirsep + (sizeof("/") - 1UL)) - 1);
#line 281
  strcpy((char */* __restrict  */)buf2, (char const   */* __restrict  */)buf);
#line 282
  chp2 = buf2 + (chp - buf);
#line 283
  tmp___12 = unique(buf2, chp2, linebuf, ((((384 | (256 >> 3)) | (128 >> 3)) | ((256 >> 3) >> 3)) | ((128 >> 3) >> 3)) | ((64 >> 3) >> 3),
                    *((long volatile   *)(& strenvvar[5].val)), 0);
  }
#line 283
  if (tmp___12) {
    {
#line 283
    fd = dirfile((char */* const  */)chp, (int const   )0, (int const   )type);
    }
#line 283
    if (0 > fd) {
#line 285
      goto nfail;
    }
  } else {
#line 285
    goto nfail;
  }
  {
#line 286
  tmp___13 = dump((int const   )fd, (int const   )type, source, len);
  }
#line 286
  if (tmp___13) {
#line 286
    if (! ignwerr___0) {
      {
#line 287
      strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)buf2);
      }
      failed: 
      {
#line 288
      unlink((char const   *)buf);
#line 288
      lasttell = (off_t )-1;
      }
#line 289
      if (linkfolder) {
        {
#line 290
        tfree((void */* const  */)linkfolder);
        }
      }
#line 291
      goto dumpf;
    }
  }
  {
#line 293
  strcpy((char */* __restrict  */)buf2, (char const   */* __restrict  */)buf);
  }
#line 294
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 296
  if (! ((unsigned int )((64 >> 3) >> 3) & (mode | cumask))) {
    {
#line 297
    *(chp + -1) = (char )'\000';
#line 298
    chmod((char const   *)buf, mode | (unsigned int )((64 >> 3) >> 3));
    }
  }
#line 300
  if (linkfolder) {
#line 301
    boxname = linkfolder;
    {
#line 301
    while (1) {
      while_continue: /* CIL Label */ ;
#line 301
      if (! ((unsigned long )boxname != (unsigned long )Tmnate)) {
#line 301
        goto while_break;
      }
      {
#line 302
      strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)boxname);
#line 303
      type = foldertype(0, 1, & mode, 0);
      }
      {
#line 304
      if (type == -1) {
#line 304
        goto case_neg_1___0;
      }
#line 305
      if (type == -2) {
#line 305
        goto case_neg_2___0;
      }
#line 306
      if (type == 1) {
#line 306
        goto case_1___0;
      }
#line 306
      if (type == 2) {
#line 306
        goto case_1___0;
      }
#line 306
      if (type == 4) {
#line 306
        goto case_1___0;
      }
#line 303
      goto switch_break___1;
      case_neg_1___0: /* CIL Label */ 
#line 304
      goto exlb;
      case_neg_2___0: /* CIL Label */ 
#line 305
      goto __Cont;
      case_1___0: /* CIL Label */ 
      case_2: /* CIL Label */ 
      case_4: /* CIL Label */ 
      {
#line 307
      chp = strchr((char const   *)buf, '\000');
#line 308
      *chp = (char )*((dirsep + (sizeof("/") - 1UL)) - 1);
#line 309
      tmp___15 = dirfile((char */* const  */)(chp + 1), (int const   )1, (int const   )type);
      }
#line 309
      if (tmp___15) {
#line 310
        if (! ((unsigned int )((64 >> 3) >> 3) & (mode | cumask))) {
          {
#line 311
          *chp = (char )'\000';
#line 312
          chmod((char const   *)buf, mode | (unsigned int )((64 >> 3) >> 3));
          }
        }
      }
#line 314
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
      __Cont: /* CIL Label */ 
      {
#line 301
      tmp___14 = strchr((char const   *)boxname, '\000');
#line 301
      boxname = tmp___14 + 1;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 317
    tfree((void */* const  */)linkfolder);
    }
  }
#line 319
  return (1);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/mailfold.c"
static char const   sfolder[11]  = 
#line 324
  {      (char const   )' ',      (char const   )' ',      (char const   )'F',      (char const   )'o', 
        (char const   )'l',      (char const   )'d',      (char const   )'e',      (char const   )'r', 
        (char const   )':',      (char const   )' ',      (char const   )'\000'};
#line 322 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/mailfold.c"
void logabstract(char const   * const  lstfolder ) 
{ 
  char *chp ;
  char *chp2 ;
  int i___0 ;
  int tmp ;
  size_t subjlen ;
  void *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;

  {
#line 323
  if (strenvvar[6].val > 0L) {
#line 323
    goto _L;
  } else
#line 323
  if (logopened) {
#line 323
    goto _L___0;
  } else
#line 323
  if (*((long volatile   *)(& strenvvar[5].val))) {
    _L___0: /* CIL Label */ 
#line 323
    if (strenvvar[6].val) {
      _L: /* CIL Label */ 
#line 325
      if (mailread) {
        {
#line 326
        i___0 = (int )*thebody;
#line 326
        *thebody = (char )'\000';
#line 327
        chp = themail;
#line 327
        tmp = eqFrom_((char const   */* const  */)chp);
        }
#line 327
        if (tmp) {
          {
#line 328
          chp = strchr((char const   *)themail, '\n');
          }
#line 328
          if (chp) {
#line 329
            *chp = (char )'\000';
          } else {
#line 331
            chp = thebody;
          }
          {
#line 332
          elog((char const   */* const  */)themail);
#line 332
          elog((char const   */* const  */)(newline));
#line 332
          *chp = (char )'\n';
          }
        }
#line 334
        *thebody = (char )i___0;
#line 335
        if (! (lcking & 2)) {
          {
#line 335
          chp = egrepin((char *)"^Subject:.*$", (char const   *)chp, (long const   )(thebody - chp),
                        0);
          }
#line 335
          if (chp) {
#line 338
            chp --;
#line 338
            chp2 = chp;
            {
#line 338
            while (1) {
              while_continue: /* CIL Label */ ;
#line 338
              chp2 --;
#line 338
              if (! ((int )*chp2 != 10)) {
#line 338
                goto while_break;
              }
            }
            while_break: /* CIL Label */ ;
            }
#line 339
            chp2 ++;
#line 339
            subjlen = (size_t )(chp - chp2);
#line 339
            if (subjlen > 78UL) {
#line 340
              subjlen = (size_t )78;
            }
            {
#line 341
            tmp___0 = memmove((void *)buf, (void const   *)chp2, subjlen);
#line 341
            *((char *)tmp___0 + subjlen) = (char )'\000';
#line 341
            detab(buf);
#line 342
            elog((char const   */* const  */)" ");
#line 342
            elog((char const   */* const  */)buf);
#line 342
            elog((char const   */* const  */)(newline));
            }
          }
        }
      }
      {
#line 345
      elog((char const   */* const  */)(sfolder));
#line 345
      tmp___1 = strncpy((char */* __restrict  */)buf, (char const   */* __restrict  */)lstfolder,
                        (72UL - (sizeof(sfolder) - 1UL)) - 1UL);
#line 345
      tmp___2 = strlen((char const   *)tmp___1);
#line 345
      i___0 = (int )(tmp___2 + (sizeof(sfolder) - 1UL));
#line 346
      *(buf + ((72UL - (sizeof(sfolder) - 1UL)) - 1UL)) = (char )'\000';
#line 346
      detab(buf);
#line 346
      elog((char const   */* const  */)buf);
#line 346
      i___0 -= i___0 % 8;
      }
      {
#line 347
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 347
        elog((char const   */* const  */)"\t");
#line 347
        i___0 += 8;
        }
#line 347
        if (! (i___0 < 72)) {
#line 347
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 349
      ultstr(7, (unsigned long )lastdump, buf);
#line 349
      elog((char const   */* const  */)buf);
#line 349
      elog((char const   */* const  */)(newline));
      }
    }
  }
#line 351
  return;
}
}
#line 353 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/mailfold.c"
static int concnd  ;
#line 355 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/mailfold.c"
void concon(int const   ch ) 
{ 
  size_t i___0 ;

  {
#line 357
  if (concnd != (int )ch) {
#line 358
    concnd = (int )ch;
#line 359
    i___0 = (size_t )confield.filled;
    {
#line 359
    while (1) {
      while_continue: /* CIL Label */ ;
#line 359
      if (! i___0) {
#line 359
        goto while_break;
      }
#line 360
      i___0 --;
#line 360
      *(themail + (confield.vals + i___0)->l) = (char )ch;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 362
  return;
}
}
#line 365 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/mailfold.c"
static size_t contlengthoffset  ;
#line 364 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/mailfold.c"
void readmail(int rhead , long const   tobesent ) 
{ 
  char *chp ;
  char *pastend ;
  long dfilled ;
  void *tmp ;
  char *oldp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  unsigned int places ;
  long cntlen ;
  long actcntlen ;
  char num[(((8UL * sizeof(cntlen)) * 4UL) / 10UL + 1UL) + 1UL] ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 367
  if (rhead) {
    {
#line 368
    mailread = (int volatile   )0;
#line 368
    dfilled = (long )mailread;
#line 368
    tmp = tmalloc((size_t )1);
#line 368
    chp = readdyn((char *)tmp, (long */* const  */)(& dfilled));
#line 368
    filled -= (long )tobesent;
    }
#line 369
    if (tobesent < (long const   )dfilled) {
      {
#line 370
      oldp = themail;
#line 371
      tmp___0 = trealloc(themail, (size_t )(dfilled + filled));
#line 371
      themail = (char *)tmp___0;
#line 371
      thebody = themail + (thebody - oldp);
      }
    }
    {
#line 373
    memmove((void *)(themail + dfilled), (void const   *)thebody, (size_t )filled);
#line 373
    memmove((void *)themail, (void const   *)chp, (size_t )dfilled);
#line 374
    tfree((void */* const  */)chp);
#line 374
    filled += dfilled;
#line 374
    tmp___1 = trealloc(themail, (size_t )(1L + filled));
#line 374
    themail = (char *)tmp___1;
    }
  } else {
#line 377
    if (! mailread) {
#line 378
      rhead = 1;
    } else
#line 377
    if (! filled) {
#line 378
      rhead = 1;
    }
    {
#line 379
    mailread = (int volatile   )0;
#line 379
    dfilled = thebody - themail;
#line 379
    themail = readdyn(themail, (long */* const  */)(& filled));
    }
  }
#line 381
  thebody = themail;
#line 381
  pastend = thebody + filled;
#line 381
  *pastend = (char )'\000';
  {
#line 382
  while (1) {
    while_continue: /* CIL Label */ ;
#line 382
    if ((unsigned long )thebody < (unsigned long )pastend) {
#line 382
      tmp___2 = thebody;
#line 382
      thebody ++;
#line 382
      if (! ((int )*tmp___2 == 10)) {
#line 382
        goto while_break;
      }
    } else {
#line 382
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 383
  realstart = (char const   *)thebody;
#line 384
  if (rhead) {
#line 385
    confield.filled = 0;
#line 385
    concnd = '\n';
    {
#line 386
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 386
      thebody = strchr((char const   *)thebody, '\n');
      }
#line 386
      if (! thebody) {
#line 386
        goto while_break___0;
      }
#line 387
      thebody ++;
      {
#line 388
      if ((int )*thebody == 32) {
#line 388
        goto case_32;
      }
#line 388
      if ((int )*thebody == 9) {
#line 388
        goto case_32;
      }
#line 391
      if ((int )*thebody == 10) {
#line 391
        goto case_10;
      }
#line 389
      goto switch_default;
      case_32: /* CIL Label */ 
      case_9: /* CIL Label */ 
      {
#line 388
      tmp___3 = app_val_((struct dyna_long */* const  */)(& confield));
#line 388
      *((long *)tmp___3) = (thebody - 1) - themail;
      }
      switch_default: /* CIL Label */ 
#line 390
      goto while_continue___0;
      case_10: /* CIL Label */ 
#line 391
      thebody ++;
#line 392
      goto eofheader;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 394
    thebody = pastend;
    eofheader: 
#line 396
    contlengthoffset = (size_t )0;
#line 397
    if (! berkeley) {
      {
#line 397
      chp = egrepin((char *)"^Content-Length:", (char const   *)themail, (long const   )(thebody - themail),
                    0);
      }
#line 397
      if (chp) {
#line 399
        contlengthoffset = (size_t )(chp - themail);
      }
    }
  } else {
#line 402
    thebody = themail + dfilled;
  }
#line 404
  chp = thebody;
#line 404
  if ((unsigned long )chp > (unsigned long )themail) {
#line 405
    chp --;
  }
#line 406
  if (contlengthoffset) {
#line 408
    chp = themail + contlengthoffset;
#line 408
    cntlen = filled - (thebody - themail);
#line 409
    if (filled > 1L) {
#line 409
      if ((int )*(themail + (filled - 2L)) == 10) {
#line 410
        cntlen --;
      }
    }
#line 411
    places = 0U;
#line 411
    actcntlen = (long )places;
    {
#line 411
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 419
      if ((int )*chp == 0) {
#line 419
        goto case_0;
      }
#line 419
      if ((int )*chp == 10) {
#line 419
        goto case_0;
      }
#line 413
      goto switch_default___0;
      switch_default___0: /* CIL Label */ 
#line 414
      if ((unsigned long )places <= sizeof(num) - 2UL) {
#line 415
        tmp___4 = chp;
#line 415
        chp ++;
#line 415
        *tmp___4 = (char )'9';
#line 415
        places ++;
#line 415
        actcntlen = (long )((unsigned long )actcntlen * 10UL + 9UL);
      } else {
#line 417
        tmp___5 = chp;
#line 417
        chp ++;
#line 417
        *tmp___5 = (char )' ';
      }
#line 418
      goto __Cont;
      case_0: /* CIL Label */ 
      case_10___0: /* CIL Label */ ;
      switch_break___0: /* CIL Label */ ;
      }
#line 421
      goto while_break___1;
      __Cont: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 423
    if (cntlen <= 0L) {
#line 424
      cntlen = 0L;
    }
    {
#line 425
    ultstr((int )places, (unsigned long )cntlen, num);
    }
#line 426
    if (! num[places]) {
      {
#line 427
      memmove((void *)(themail + contlengthoffset), (void const   *)(num), (size_t )places);
#line 427
      actcntlen = cntlen;
      }
    }
#line 428
    chp = thebody + actcntlen;
  }
#line 430
  restbody = (char const   *)chp;
#line 430
  mailread = (int volatile   )1;
#line 431
  return;
}
}
#line 433 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/mailfold.c"
char *findtstamp(char const   *start , char const   *end ) 
{ 
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  int spc ;
  char const   *tmp___2 ;

  {
#line 434
  end -= 25;
#line 435
  if ((int const   )*start == 32) {
#line 435
    start ++;
#line 435
    if ((unsigned long )start == (unsigned long )end) {
#line 436
      return ((char *)start - 1);
    } else
#line 435
    if ((int const   )*start == 32) {
#line 435
      start ++;
#line 435
      if ((unsigned long )start == (unsigned long )end) {
#line 436
        return ((char *)start - 1);
      }
    }
  }
  {
#line 437
  tmp = skpspace(start);
#line 437
  start = (char const   *)tmp;
#line 437
  tmp___0 = strcspn(start, " \t\n");
#line 437
  start += tmp___0;
#line 438
  tmp___1 = skpspace(start);
  }
#line 438
  if ((unsigned long )tmp___1 >= (unsigned long )end) {
#line 439
    return ((char *)start);
  }
  {
#line 440
  while (1) {
    while_continue: /* CIL Label */ ;
#line 440
    if ((int const   )*(end + 13) == 58) {
#line 440
      if ((int const   )*(end + 16) == 58) {
#line 440
        goto while_break;
      } else {
#line 440
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 440
      end --;
#line 440
      if (! ((unsigned long )end > (unsigned long )start)) {
#line 440
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 441
  spc = 0;
  {
#line 442
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 442
    tmp___2 = end;
#line 442
    end --;
#line 442
    if (! ((unsigned long )tmp___2 > (unsigned long )start)) {
#line 442
      goto while_break___0;
    }
    {
#line 444
    if ((int const   )*end == 9) {
#line 444
      goto case_9;
    }
#line 444
    if ((int const   )*end == 32) {
#line 444
      goto case_9;
    }
#line 443
    goto switch_break;
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 444
    spc = 1;
#line 445
    goto while_continue___0;
    switch_break: /* CIL Label */ ;
    }
#line 447
    if (! spc) {
#line 448
      goto while_continue___0;
    }
#line 449
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 451
  return ((char *)end + 1);
}
}
#line 16 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/lastdirsep.c"
char *lastdirsep(char const   *filename___0 ) 
{ 
  char const   *p___0 ;
  char *tmp ;

  {
  {
#line 18
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 18
    tmp = strpbrk(filename___0, dirsep);
#line 18
    p___0 = (char const   *)tmp;
    }
#line 18
    if (! p___0) {
#line 18
      goto while_break;
    }
#line 19
    filename___0 = p___0 + 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 20
  return ((char *)filename___0);
}
}
#line 727 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setegid)(__gid_t __gid ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 3 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/exopen.h"
int myrename(char const   * const  old___0 , char const   * const  newn ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/locking.c"
void lockit(char *name___1 , char ** const  lockp ) 
{ 
  int permanent ;
  int triedforce ;
  int locktype ;
  struct stat stbuf ;
  time_t t___1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int i___0 ;
  size_t tmp___7 ;
  char *tmp___8 ;

  {
  {
#line 22
  permanent = 8;
#line 22
  triedforce = 0;
#line 22
  locktype = 4;
#line 23
  zombiecollect();
  }
#line 24
  if (*lockp) {
    {
#line 25
    tmp = strcmp((char const   *)name___1, (char const   *)*lockp);
    }
#line 25
    if (! tmp) {
      {
#line 26
      tfree((void */* const  */)name___1);
      }
#line 26
      return;
    }
    {
#line 28
    unlock(lockp);
    }
  }
#line 30
  if (! *name___1) {
    {
#line 31
    tfree((void */* const  */)name___1);
    }
#line 31
    return;
  }
  {
#line 33
  tmp___1 = strcmp((char const   *)name___1, defdeflock);
  }
#line 33
  if (! tmp___1) {
#line 34
    locktype = 6;
#line 35
    if (sgid != gid) {
      {
#line 35
      tmp___0 = setegid(sgid);
      }
#line 35
      if (tmp___0) {
#line 37
        if (! accspooldir) {
          {
#line 38
          yell((char const   */* const  */)"Bypassed locking", (char const   */* const  */)name___1);
#line 39
          tfree((void */* const  */)name___1);
          }
#line 39
          return;
        }
      }
    }
  }
#line 44
  lcking |= 1;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 45
    yell((char const   */* const  */)"Locking", (char const   */* const  */)name___1);
#line 46
    tmp___2 = xcreat(name___1, (256 | (256 >> 3)) | ((256 >> 3) >> 3), & t___1, locktype);
    }
#line 46
    if (! tmp___2) {
#line 47
      *lockp = name___1;
#line 48
      goto while_break;
    }
    {
#line 50
    tmp___3 = __errno_location();
    }
    {
#line 51
    if (*tmp___3 == 17) {
#line 51
      goto case_17;
    }
#line 73
    if (*tmp___3 == 5) {
#line 73
      goto case_5;
    }
#line 73
    if (*tmp___3 == 20) {
#line 73
      goto case_5;
    }
#line 73
    if (*tmp___3 == 2) {
#line 73
      goto case_5;
    }
#line 73
    if (*tmp___3 == 122) {
#line 73
      goto case_5;
    }
#line 73
    if (*tmp___3 == 28) {
#line 73
      goto case_5;
    }
#line 78
    if (*tmp___3 == 36) {
#line 78
      goto case_36;
    }
#line 87
    goto faillock;
    case_17: /* CIL Label */ 
    {
#line 52
    tmp___5 = lstat((char const   */* __restrict  */)name___1, (struct stat */* __restrict  */)(& stbuf));
    }
#line 52
    if (tmp___5) {
#line 67
      triedforce = 0;
    } else
#line 52
    if (stbuf.st_size <= 16L) {
#line 52
      if (strenvvar[1].val) {
        {
#line 52
        tmp___6 = lstat((char const   */* __restrict  */)name___1, (struct stat */* __restrict  */)(& stbuf));
        }
#line 52
        if (tmp___6) {
#line 67
          triedforce = 0;
        } else
#line 52
        if (strenvvar[1].val < t___1 - stbuf.st_mtim.tv_sec) {
#line 57
          if (triedforce) {
#line 58
            goto faillock;
          }
#line 59
          if ((stbuf.st_mode & 61440U) == 16384U) {
            {
#line 60
            triedforce = 1;
#line 60
            nlog((char const   */* const  */)"Forced unlock denied on");
#line 60
            logqnl((char const   */* const  */)name___1);
            }
          } else {
            {
#line 59
            tmp___4 = unlink((char const   *)name___1);
            }
#line 59
            if (tmp___4) {
              {
#line 60
              triedforce = 1;
#line 60
              nlog((char const   */* const  */)"Forced unlock denied on");
#line 60
              logqnl((char const   */* const  */)name___1);
              }
            } else {
              {
#line 62
              nlog((char const   */* const  */)"Forcing lock on");
#line 62
              logqnl((char const   */* const  */)name___1);
#line 62
              suspend();
              }
#line 63
              goto ce;
            }
          }
        } else {
#line 67
          triedforce = 0;
        }
      } else {
#line 67
        triedforce = 0;
      }
    } else {
#line 67
      triedforce = 0;
    }
#line 68
    goto switch_break;
    case_5: /* CIL Label */ 
    case_20: /* CIL Label */ 
    case_2: /* CIL Label */ 
    case_122: /* CIL Label */ 
    case_28: /* CIL Label */ 
#line 74
    permanent --;
#line 74
    if (permanent) {
#line 75
      goto ds;
    }
#line 76
    goto faillock;
    case_36: /* CIL Label */ 
    {
#line 80
    tmp___7 = strlen((char const   *)name___1);
#line 80
    i___0 = (int )(tmp___7 - 1UL);
    }
#line 80
    if (0 < i___0) {
      {
#line 80
      tmp___8 = strchr(dirsep, (int )*(name___1 + (i___0 - 1)));
      }
#line 80
      if (! tmp___8) {
        {
#line 81
        nlog((char const   */* const  */)"Truncating");
#line 81
        logqnl((char const   */* const  */)name___1);
#line 81
        elog((char const   */* const  */)" and retrying lock\n");
#line 82
        *(name___1 + i___0) = (char )'\000';
#line 82
        permanent = 8;
        }
#line 83
        goto ce;
      }
    }
    faillock: 
    switch_default: /* CIL Label */ 
    {
#line 88
    nlog((char const   */* const  */)"Lock failure on");
#line 88
    logqnl((char const   */* const  */)name___1);
    }
#line 89
    goto term;
    switch_break: /* CIL Label */ ;
    }
#line 91
    permanent = 8;
    ds: 
    {
#line 92
    ssleep((unsigned int const   )((unsigned int )strenvvar[0].val));
    }
    ce: 
#line 93
    if (nextexit) {
      term: 
      {
#line 94
      tfree((void */* const  */)name___1);
      }
#line 95
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  if (rcstate == 2) {
    {
#line 99
    setegid(gid);
    }
  }
#line 100
  lcking &= -2;
#line 101
  if (nextexit) {
    {
#line 102
    elog((char const   */* const  */)(whilstwfor));
#line 102
    elog((char const   */* const  */)"lockfile");
#line 102
    logqnl((char const   */* const  */)name___1);
#line 102
    Terminate();
    }
  }
#line 103
  return;
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/locking.c"
void lcllock(void) 
{ 
  char *lckfile ;
  int len ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 107
  if (tolock) {
#line 107
    goto _L;
  } else {
    {
#line 107
    tmp___4 = strcmp((char const   *)buf2, devnull);
    }
#line 107
    if (tmp___4) {
      {
#line 107
      tmp___5 = strcmp((char const   *)buf2, "|");
      }
#line 107
      if (tmp___5) {
        _L: /* CIL Label */ 
#line 108
        if (tolock) {
          {
#line 109
          lckfile = tstrdup((char const   */* const  */)tolock);
          }
        } else {
          {
#line 111
          tmp = strlen((char const   *)buf2);
#line 111
          len = (int )tmp;
#line 112
          tmp___0 = strlen(strenstr[1].sval);
#line 112
          tmp___1 = tmalloc(((size_t )len + tmp___0) + 1UL);
#line 112
          lckfile = (char *)tmp___1;
#line 112
          tmp___2 = strcpy((char */* __restrict  */)lckfile, (char const   */* __restrict  */)buf2);
#line 112
          strcpy((char */* __restrict  */)(tmp___2 + len), (char const   */* __restrict  */)strenstr[1].sval);
          }
        }
#line 114
        if (globlock) {
          {
#line 114
          tmp___3 = strcmp((char const   *)lckfile, (char const   *)globlock);
          }
#line 114
          if (tmp___3) {
            {
#line 119
            lockit(lckfile, (char **/* const  */)(& loclock));
            }
          } else {
            {
#line 115
            nlog((char const   */* const  */)"Deadlock attempted on");
#line 115
            logqnl((char const   */* const  */)lckfile);
#line 116
            tfree((void */* const  */)lckfile);
            }
          }
        } else {
          {
#line 119
          lockit(lckfile, (char **/* const  */)(& loclock));
          }
        }
      }
    }
  }
#line 121
  return;
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/locking.c"
void unlock(char ** const  lockp ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 124
  lcking |= 1;
#line 125
  if (*lockp) {
    {
#line 126
    tmp = strcmp((char const   *)*lockp, defdeflock);
    }
#line 126
    if (! tmp) {
      {
#line 127
      setegid(sgid);
      }
    }
    {
#line 128
    yell((char const   */* const  */)"Unlocking", (char const   */* const  */)*lockp);
#line 129
    tmp___0 = unlink((char const   *)*lockp);
    }
#line 129
    if (tmp___0) {
      {
#line 130
      nlog((char const   */* const  */)"Couldn\'t unlock");
#line 130
      logqnl((char const   */* const  */)*lockp);
      }
    }
#line 131
    if (rcstate == 2) {
      {
#line 132
      setegid(gid);
      }
    }
#line 133
    if (! nextexit) {
      {
#line 134
      tfree((void */* const  */)*lockp);
      }
    }
#line 135
    *lockp = (char *)0;
  }
  {
#line 137
  offguard();
  }
#line 138
  return;
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/locking.c"
int xcreat(char const   * const  name___1 , mode_t const   mode , time_t * const  tim ,
           int const   chownit ) 
{ 
  char *p___0 ;
  int j ;
  size_t i___0 ;
  char *tmp ;
  void *tmp___0 ;
  struct stat stbuf ;
  int tmp___1 ;

  {
  {
#line 142
  j = -2;
#line 143
  tmp = lastdirsep((char const   *)name___1);
#line 143
  i___0 = (size_t )(tmp - (char *)name___1);
#line 143
  tmp___0 = tmalloc(i___0 + 24UL);
#line 143
  p___0 = (char *)tmp___0;
#line 143
  strncpy((char */* __restrict  */)p___0, (char const   */* __restrict  */)name___1,
          i___0);
#line 144
  tmp___1 = unique(p___0, p___0 + i___0, 0, mode, *((long volatile   *)(& strenvvar[5].val)),
                   chownit);
  }
#line 144
  if (tmp___1) {
#line 145
    if (tim) {
      {
#line 147
      stat((char const   */* __restrict  */)p___0, (struct stat */* __restrict  */)(& stbuf));
#line 147
      *tim = stbuf.st_mtim.tv_sec;
      }
    }
    {
#line 149
    j = myrename((char const   */* const  */)p___0, name___1);
    }
  }
  {
#line 151
  tfree((void */* const  */)p___0);
  }
#line 152
  return (j);
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/locking.c"
static int oldfdlock  =    -1;
#line 166 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/locking.c"
static struct flock flck  ;
#line 178 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/locking.c"
int fdlock(int fd ) 
{ 
  int ret ;

  {
#line 180
  if (*((long volatile   *)(& strenvvar[5].val))) {
    {
#line 181
    nlog((char const   */* const  */)"Acquiring kernel-lock\n");
    }
  }
  {
#line 186
  zombiecollect();
#line 191
  flck.l_type = (short)1;
#line 191
  flck.l_whence = (short)0;
#line 191
  flck.l_len = (__off_t )0;
#line 195
  flck.l_start = lseek(fd, (off_t )0, 1);
#line 198
  lcking |= 32;
#line 200
  ret = fcntl(fd, 7, & flck);
#line 240
  oldfdlock = fd;
#line 240
  lcking &= -33;
  }
#line 241
  return (ret);
#line 243
  return (1);
}
}
#line 246 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/locking.c"
int fdunlock(void) 
{ 
  int i___0 ;
  int tmp ;

  {
#line 248
  if (oldfdlock < 0) {
#line 249
    return (-1);
  }
  {
#line 250
  i___0 = 0;
#line 261
  flck.l_type = (short)2;
#line 261
  tmp = fcntl(oldfdlock, 6, & flck);
#line 261
  i___0 |= tmp;
#line 263
  oldfdlock = -1;
  }
#line 264
  return (i___0);
}
}
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 417
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 531
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 312 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 3 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/robust.h"
void nomemerr(size_t const   len ) ;
#line 3
void opnlog(char const   *file ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/robust.h"
mode_t cumask  ;
#line 24 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/robust.c"
static char const   outofmem[14]  = 
#line 24 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/robust.c"
  {      (char const   )'O',      (char const   )'u',      (char const   )'t',      (char const   )' ', 
        (char const   )'o',      (char const   )'f',      (char const   )' ',      (char const   )'m', 
        (char const   )'e',      (char const   )'m',      (char const   )'o',      (char const   )'r', 
        (char const   )'y',      (char const   )'\000'};
#line 23 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/robust.c"
void nomemerr(size_t const   len ) 
{ 
  char tmp ;

  {
  {
#line 25
  nextexit = (int volatile   )2;
#line 25
  nlog((char const   */* const  */)(outofmem));
#line 25
  elog((char const   */* const  */)"\n");
#line 26
  syslog(5, "%s as I tried to allocate %ld bytes\n", outofmem, (long )len);
  }
#line 28
  if (rcstate == 2) {
#line 28
    if (buf2) {
      {
#line 29
      tmp = (char )'\000';
#line 29
      *(buf2 + (linebuf - 1UL)) = tmp;
#line 29
      *(buf + (linebuf - 1UL)) = tmp;
#line 29
      elog((char const   */* const  */)"buffer 0:");
#line 29
      logqnl((char const   */* const  */)buf);
#line 30
      elog((char const   */* const  */)"buffer 1:");
#line 30
      logqnl((char const   */* const  */)buf2);
      }
    }
  }
#line 32
  if (retval != 75) {
#line 33
    retval = 71;
  }
  {
#line 34
  Terminate();
  }
#line 35
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/robust.c"
static void heapdefrag(void) 
{ 
  register void *p___0 ;

  {
  {
#line 39
  lcking |= 4;
#line 40
  p___0 = malloc((size_t )1);
  }
#line 40
  if (p___0) {
    {
#line 41
    free(p___0);
    }
  }
#line 42
  return;
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/robust.c"
void *tmalloc(size_t const   len ) 
{ 
  void *p___0 ;
  int i___0 ;
  int tmp ;

  {
  {
#line 46
  lcking |= 2;
#line 47
  p___0 = malloc((size_t )len);
  }
#line 47
  if (p___0) {
#line 48
    goto ret;
  }
  {
#line 49
  heapdefrag();
#line 49
  heapdefrag();
#line 50
  i___0 = (int )strenvvar[3].val;
  }
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 50
    if (! (i___0 < 0)) {
#line 50
      tmp = i___0;
#line 50
      i___0 --;
#line 50
      if (! tmp) {
#line 50
        goto while_break;
      }
    }
    {
#line 51
    suspend();
#line 52
    p___0 = malloc((size_t )len);
    }
#line 52
    if (p___0) {
      ret: 
#line 53
      lcking &= -7;
#line 54
      return (p___0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 57
  nomemerr(len);
  }
#line 58
  return ((void *)0);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/robust.c"
void *trealloc(void * const  old___0 , size_t const   len ) 
{ 
  void *p___0 ;
  int i___0 ;
  int tmp ;

  {
  {
#line 62
  lcking |= 2;
#line 63
  p___0 = realloc((void *)old___0, (size_t )len);
  }
#line 63
  if (p___0) {
#line 64
    goto ret;
  }
  {
#line 65
  heapdefrag();
#line 65
  heapdefrag();
#line 66
  i___0 = (int )strenvvar[3].val;
  }
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! (i___0 < 0)) {
#line 66
      tmp = i___0;
#line 66
      i___0 --;
#line 66
      if (! tmp) {
#line 66
        goto while_break;
      }
    }
    {
#line 67
    suspend();
#line 68
    p___0 = realloc((void *)old___0, (size_t )len);
    }
#line 68
    if (p___0) {
      ret: 
#line 69
      lcking &= -7;
#line 70
      return (p___0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 73
  nomemerr(len);
  }
#line 74
  return ((void *)0);
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/robust.c"
void tfree(void * const  p___0 ) 
{ 


  {
  {
#line 77
  lcking |= 2;
#line 77
  free((void *)p___0);
#line 77
  lcking &= -3;
  }
#line 78
  return;
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/robust.c"
pid_t sfork(void) 
{ 
  pid_t i___0 ;
  int r___0 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 84
  zombiecollect();
#line 84
  elog((char const   */* const  */)(empty));
#line 84
  r___0 = (int )strenvvar[3].val;
  }
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 85
    i___0 = fork();
    }
#line 85
    if (! (i___0 == -1)) {
#line 85
      goto while_break;
    }
#line 86
    lcking |= 8;
#line 87
    if (! (r___0 < 0)) {
#line 87
      tmp = r___0;
#line 87
      r___0 --;
#line 87
      if (! tmp) {
#line 88
        goto while_break;
      }
    }
    {
#line 89
    tmp___0 = waitfor(0);
    }
#line 89
    if (tmp___0 == -256) {
      {
#line 90
      suspend();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  lcking &= -9;
#line 93
  return (i___0);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/robust.c"
void opnlog(char const   *file ) 
{ 
  int i___0 ;

  {
  {
#line 98
  elog((char const   */* const  */)(empty));
  }
#line 99
  if (! *file) {
#line 100
    file = devnull;
  }
  {
#line 101
  i___0 = opena((char const   */* const  */)file);
  }
#line 101
  if (0 > i___0) {
    {
#line 102
    writeerr((char const   */* const  */)file);
#line 102
    syslog(5, slogstr, errwwriting, file);
    }
  } else {
    {
#line 104
    rclose((int const   )2);
#line 104
    rdup((int const   )i___0);
#line 104
    rclose((int const   )i___0);
#line 104
    logopened = 1;
    }
  }
#line 105
  return;
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/robust.c"
int opena(char const   * const  a ) 
{ 
  int tmp ;

  {
  {
#line 108
  setlastfolder(a);
#line 108
  yell((char const   */* const  */)"Opening", a);
#line 110
  tmp = ropen(a, 1089, ((((384 | (256 >> 3)) | (128 >> 3)) | ((256 >> 3) >> 3)) | ((128 >> 3) >> 3)) | ((64 >> 3) >> 3));
  }
#line 110
  return (tmp);
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/robust.c"
int ropen(char const   * const  name___1 , int const   mode , mode_t const   mask ) 
{ 
  int i___0 ;
  int r___0 ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
#line 121
  r___0 = (int )strenvvar[3].val;
#line 121
  lcking |= 16;
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 121
    i___0 = open((char const   *)name___1, (int )mode, mask);
    }
#line 121
    if (! (0 > i___0)) {
#line 121
      goto while_break;
    }
    {
#line 122
    tmp = __errno_location();
    }
#line 122
    if (*tmp != 4) {
      {
#line 122
      tmp___0 = __errno_location();
      }
#line 122
      if (*tmp___0 == 23) {
#line 122
        if (! (r___0 < 0)) {
#line 122
          tmp___1 = r___0;
#line 122
          r___0 --;
#line 122
          if (! tmp___1) {
#line 123
            goto while_break;
          }
        }
      } else {
#line 123
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 124
  lcking &= -17;
#line 125
  return (i___0);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/robust.c"
int rpipe(int *fd ) 
{ 
  int i___0 ;
  int r___0 ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
#line 130
  r___0 = (int )strenvvar[3].val;
#line 130
  lcking |= 16;
  {
#line 130
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 130
    i___0 = pipe(fd);
    }
#line 130
    if (! (0 > i___0)) {
#line 130
      goto while_break;
    }
    {
#line 131
    tmp___0 = __errno_location();
    }
#line 131
    if (*tmp___0 == 23) {
#line 131
      if (! (r___0 < 0)) {
#line 131
        tmp___1 = r___0;
#line 131
        r___0 --;
#line 131
        if (! tmp___1) {
#line 132
          tmp = -1;
#line 132
          *(fd + 1) = tmp;
#line 132
          *fd = tmp;
#line 133
          goto while_break;
        }
      }
    } else {
#line 132
      tmp = -1;
#line 132
      *(fd + 1) = tmp;
#line 132
      *fd = tmp;
#line 133
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 135
  lcking &= -17;
#line 136
  return (i___0);
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/robust.c"
int rdup(int const   p___0 ) 
{ 
  int i___0 ;
  int r___0 ;
  int *tmp ;
  int tmp___0 ;

  {
#line 141
  r___0 = (int )strenvvar[3].val;
#line 141
  lcking |= 16;
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 141
    i___0 = dup((int )p___0);
    }
#line 141
    if (! (0 > i___0)) {
#line 141
      goto while_break;
    }
    {
#line 142
    tmp = __errno_location();
    }
#line 142
    if (*tmp == 23) {
#line 142
      if (! (r___0 < 0)) {
#line 142
        tmp___0 = r___0;
#line 142
        r___0 --;
#line 142
        if (! tmp___0) {
#line 143
          goto while_break;
        }
      }
    } else {
#line 143
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 144
  lcking &= -17;
#line 145
  return (i___0);
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/robust.c"
int rclose(int const   fd ) 
{ 
  int i___0 ;
  int *tmp ;

  {
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 150
    i___0 = close((int )fd);
    }
#line 150
    if (i___0) {
      {
#line 150
      tmp = __errno_location();
      }
#line 150
      if (! (*tmp == 4)) {
#line 150
        goto while_break;
      }
    } else {
#line 150
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 151
  return (i___0);
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/robust.c"
int rread(int const   fd , void * const  a , int const   len ) 
{ 
  int i___0 ;
  ssize_t tmp ;
  int *tmp___0 ;

  {
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 156
    tmp = read((int )fd, (void *)a, (size_t )len);
#line 156
    i___0 = (int )tmp;
    }
#line 156
    if (0 > i___0) {
      {
#line 156
      tmp___0 = __errno_location();
      }
#line 156
      if (! (*tmp___0 == 4)) {
#line 156
        goto while_break;
      }
    } else {
#line 156
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 157
  return (i___0);
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/robust.c"
int rwrite(int const   fd , void const   * const  a , int const   len ) 
{ 
  int i___0 ;
  ssize_t tmp ;
  int *tmp___0 ;

  {
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 162
    tmp = write((int )fd, (void const   *)a, (size_t )len);
#line 162
    i___0 = (int )tmp;
    }
#line 162
    if (0 > i___0) {
      {
#line 162
      tmp___0 = __errno_location();
      }
#line 162
      if (! (*tmp___0 == 4)) {
#line 162
        goto while_break;
      }
    } else {
#line 162
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 163
  return (i___0);
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/robust.c"
void ssleep(unsigned int const   seconds ) 
{ 
  long t___1 ;
  time_t tmp ;

  {
  {
#line 168
  sleep((unsigned int )seconds);
  }
#line 169
  if (alrmtime) {
    {
#line 170
    tmp = time((time_t *)0);
#line 170
    t___1 = (long )(alrmtime - (time_t volatile   )tmp);
    }
#line 170
    if (t___1 <= 1L) {
      {
#line 171
      ftimeout();
      }
    } else {
      {
#line 173
      alarm((unsigned int )t___1);
      }
    }
  }
#line 174
  return;
}
}
#line 176 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/robust.c"
void doumask(mode_t const   mask ) 
{ 


  {
  {
#line 177
  cumask = (mode_t )mask;
#line 177
  umask(cumask);
  }
#line 178
  return;
}
}
#line 81 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) uname)(struct utsname *__name ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/acommon.c"
static char *name  =    (char *)0;
#line 16 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/acommon.c"
char const   *hostname(void) 
{ 
  struct utsname names ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 27
  if (! name) {
    {
#line 29
    (*((int (*)(struct utsname * ))(& uname)))(& names);
#line 30
    tmp = strlen((char const   *)(names.nodename));
#line 30
    tmp___0 = tmalloc(tmp + 1UL);
#line 30
    name = (char *)tmp___0;
    }
#line 30
    if (! name) {
#line 31
      return ("");
    }
    {
#line 32
    strcpy((char */* __restrict  */)name, (char const   */* __restrict  */)(names.nodename));
    }
  }
#line 35
  return ((char const   *)name);
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/acommon.c"
char *ultoan(unsigned long val , char *dest ) 
{ 
  register int i___0 ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 41
    i___0 = (int )(val & 63UL);
#line 42
    tmp = dest;
#line 42
    dest ++;
#line 42
    if (i___0 < 26) {
#line 42
      tmp___3 = 'A';
    } else {
#line 42
      if (i___0 < 52) {
#line 42
        tmp___2 = 71;
      } else {
#line 42
        if (i___0 < 62) {
#line 42
          tmp___1 = -4;
        } else {
#line 42
          if (i___0 == 62) {
#line 42
            tmp___0 = -17;
          } else {
#line 42
            tmp___0 = 32;
          }
#line 42
          tmp___1 = tmp___0;
        }
#line 42
        tmp___2 = tmp___1;
      }
#line 42
      tmp___3 = tmp___2;
    }
#line 42
    *tmp = (char )(i___0 + tmp___3);
#line 40
    val >>= 6;
#line 40
    if (! val) {
#line 40
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 46
  *dest = (char )'\000';
#line 47
  return (dest);
}
}
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 116
extern struct passwd *getpwnam(char const   *__name ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/authenticate.h"
void auth_end(void) ;
#line 57 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/authenticate.c"
static auth_identity authi  ;
#line 59 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/authenticate.c"
static void castlower(char *str ) 
{ 


  {
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (! *str) {
#line 60
      goto while_break;
    }
#line 61
    if ((unsigned int )*str - 65U <= 25U) {
#line 62
      *str = (char )((int )*str + 32);
    }
#line 60
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 63
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/authenticate.c"
static struct passwd  const  *cgetpwnam(char const   * const  user , int const   sock ) 
{ 
  struct passwd *tmp ;

  {
  {
#line 67
  tmp = getpwnam((char const   *)user);
  }
#line 67
  return ((struct passwd  const  *)tmp);
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/authenticate.c"
static struct passwd  const  *cgetpwuid(uid_t const   uid___0 , int const   sock ) 
{ 
  struct passwd *tmp ;

  {
  {
#line 71
  tmp = getpwuid((__uid_t )uid___0);
  }
#line 71
  return ((struct passwd  const  *)tmp);
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/authenticate.c"
auth_identity *auth_finduser(char * const  user , int const   sock ) 
{ 
  char *p___0 ;

  {
  {
#line 75
  authi.pw = cgetpwnam((char const   */* const  */)user, sock);
  }
#line 75
  if (! authi.pw) {
    {
#line 77
    p___0 = strchr((char const   *)user, '@');
    }
#line 77
    if (p___0) {
#line 78
      *p___0 = (char )'\000';
    }
    {
#line 79
    castlower((char *)user);
#line 80
    authi.pw = cgetpwnam((char const   */* const  */)user, sock);
    }
#line 80
    if (! authi.pw) {
#line 81
      return ((auth_identity *)0);
    }
  }
#line 83
  authi.sock = (int )sock;
#line 84
  if (authi.mbox) {
    {
#line 85
    tfree((void */* const  */)authi.mbox);
#line 85
    authi.mbox = (char *)0;
    }
  }
#line 86
  return (& authi);
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/authenticate.c"
auth_identity *auth_finduid(uid_t const   uid___0 , int const   sock ) 
{ 


  {
  {
#line 90
  authi.pw = cgetpwuid(uid___0, sock);
  }
#line 90
  if (! authi.pw) {
#line 91
    return ((auth_identity *)0);
  }
#line 92
  authi.sock = (int )sock;
#line 93
  if (authi.mbox) {
    {
#line 94
    tfree((void */* const  */)authi.mbox);
#line 94
    authi.mbox = (char *)0;
    }
  }
#line 95
  return (& authi);
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/authenticate.c"
auth_identity *auth_newid(void) 
{ 
  auth_identity *pass ;
  void *tmp ;

  {
  {
#line 120
  tmp = tmalloc(sizeof(*pass));
#line 120
  pass = (auth_identity *)tmp;
#line 120
  pass->pw = (struct passwd  const  *)0;
#line 120
  pass->mbox = (char *)0;
  }
#line 120
  return (pass);
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/authenticate.c"
void auth_copyid(auth_identity *newpass , auth_identity const   *oldpass ) 
{ 
  struct passwd *np ;
  struct passwd  const  *op ;
  struct passwd  const  *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 126
  if (newpass->mbox) {
    {
#line 127
    tfree((void */* const  */)newpass->mbox);
#line 127
    newpass->mbox = (char *)0;
    }
  }
#line 128
  newpass->sock = (int )oldpass->sock;
#line 129
  np = (struct passwd *)newpass->pw;
#line 129
  if (! np) {
    {
#line 130
    tmp___0 = tmalloc(sizeof(*np));
#line 130
    tmp = (struct passwd  const  *)tmp___0;
#line 130
    newpass->pw = tmp;
#line 130
    np = (struct passwd *)tmp;
#line 131
    tmp___2 = (char *)0;
#line 131
    np->pw_shell = tmp___2;
#line 131
    tmp___1 = tmp___2;
#line 131
    np->pw_dir = tmp___1;
#line 131
    np->pw_name = tmp___1;
    }
  }
  {
#line 133
  op = (struct passwd  const  *)oldpass->pw;
#line 133
  np->pw_uid = (__uid_t )op->pw_uid;
#line 133
  np->pw_gid = (__gid_t )op->pw_gid;
#line 134
  np->pw_name = cstr((char */* const  */)np->pw_name, (char const   */* const  */)op->pw_name);
#line 135
  np->pw_dir = cstr((char */* const  */)np->pw_dir, (char const   */* const  */)op->pw_dir);
#line 136
  np->pw_shell = cstr((char */* const  */)np->pw_shell, (char const   */* const  */)op->pw_shell);
  }
#line 137
  return;
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/authenticate.c"
void auth_freeid(auth_identity *pass ) 
{ 
  struct passwd *p___0 ;

  {
#line 141
  p___0 = (struct passwd *)pass->pw;
#line 141
  if (p___0) {
    {
#line 142
    tfree((void */* const  */)p___0->pw_name);
#line 142
    tfree((void */* const  */)p___0->pw_dir);
#line 142
    tfree((void */* const  */)p___0->pw_shell);
#line 142
    tfree((void */* const  */)p___0);
    }
  }
#line 143
  if (pass->mbox) {
    {
#line 144
    tfree((void */* const  */)pass->mbox);
    }
  }
  {
#line 145
  tfree((void */* const  */)pass);
  }
#line 146
  return;
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/authenticate.c"
int auth_filledid(auth_identity const   *pass ) 
{ 


  {
#line 149
  return (! (! pass->pw));
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/authenticate.c"
static char const   mailspooldir[17]  = 
#line 162
  {      (char const   )'/',      (char const   )'v',      (char const   )'a',      (char const   )'r', 
        (char const   )'/',      (char const   )'s',      (char const   )'p',      (char const   )'o', 
        (char const   )'o',      (char const   )'l',      (char const   )'/',      (char const   )'m', 
        (char const   )'a',      (char const   )'i',      (char const   )'l',      (char const   )'/', 
        (char const   )'\000'};
#line 153 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/authenticate.c"
char const   *auth_mailboxname(auth_identity * const  pass ) 
{ 
  char *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *p___0 ;
  char *n ;
  size_t i___0 ;
  int c ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;

  {
#line 154
  if (! pass->mbox) {
    {
#line 163
    tmp___0 = strlen((char const   *)(pass->pw)->pw_name);
#line 163
    tmp___1 = tmalloc((((sizeof(mailspooldir) - 1UL) + tmp___0) + 1UL) + (sizeof("") - 1UL));
#line 163
    tmp = (char *)tmp___1;
#line 163
    pass->mbox = tmp;
    }
#line 163
    if (! tmp) {
#line 165
      return ("");
    }
    {
#line 166
    strcpy((char */* __restrict  */)pass->mbox, (char const   */* __restrict  */)(mailspooldir));
#line 168
    p___0 = pass->mbox + (sizeof(mailspooldir) - 1UL);
#line 168
    n = (char *)(pass->pw)->pw_name;
#line 168
    i___0 = (size_t )0;
    }
    {
#line 168
    while (1) {
      while_continue: /* CIL Label */ ;
#line 168
      tmp___5 = i___0;
#line 168
      i___0 --;
#line 168
      if (! tmp___5) {
#line 168
        goto while_break;
      }
#line 170
      if (*n) {
#line 171
        tmp___3 = n;
#line 171
        n ++;
#line 171
        c = (int )*tmp___3;
      }
#line 172
      tmp___4 = p___0;
#line 172
      p___0 ++;
#line 172
      *tmp___4 = (char )c;
#line 168
      tmp___2 = p___0;
#line 168
      p___0 ++;
#line 168
      *tmp___2 = (char )'/';
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 174
    strcpy((char */* __restrict  */)p___0, (char const   */* __restrict  */)(pass->pw)->pw_name);
    }
#line 175
    if (sizeof("") - 1UL) {
      {
#line 176
      strcat((char */* __restrict  */)p___0, (char const   */* __restrict  */)"");
      }
    }
  }
#line 180
  return ((char const   *)pass->mbox);
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/authenticate.c"
uid_t auth_whatuid(auth_identity const   * const  pass ) 
{ 


  {
#line 184
  return ((uid_t )(pass->pw)->pw_uid);
}
}
#line 187 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/authenticate.c"
uid_t auth_whatgid(auth_identity const   * const  pass ) 
{ 


  {
#line 188
  return ((uid_t )(pass->pw)->pw_gid);
}
}
#line 191 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/authenticate.c"
char const   *auth_homedir(auth_identity const   * const  pass ) 
{ 


  {
#line 192
  return ((char const   *)(pass->pw)->pw_dir);
}
}
#line 195 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/authenticate.c"
char const   *auth_shell(auth_identity const   * const  pass ) 
{ 


  {
#line 196
  return ((char const   *)(pass->pw)->pw_shell);
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/authenticate.c"
char const   *auth_username(auth_identity const   * const  pass ) 
{ 


  {
#line 200
  return ((char const   *)(pass->pw)->pw_name);
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/authenticate.c"
void auth_end(void) 
{ 


  {
#line 204
  if (authi.mbox) {
    {
#line 205
    tfree((void */* const  */)authi.mbox);
#line 205
    authi.mbox = (char *)0;
    }
  }
  {
#line 206
  endpwent();
  }
#line 210
  return;
}
}
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 705
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setreuid)(__uid_t __ruid ,
                                                                               __uid_t __euid ) ;
#line 722
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setregid)(__gid_t __rgid ,
                                                                               __gid_t __egid ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) pow)(double __x ,
                                                                             double __y ) ;
#line 175 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void closelog(void) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.h"
void ignoreterm(void) ;
#line 13
void sterminate(void) ;
#line 13
void catlim(char const   *src ) ;
#line 13
void squeeze(char *target ) ;
#line 52
int alphanum(unsigned int const   c ) ;
#line 61
char *cat(char const   * const  a , char const   * const  b ) ;
#line 75 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.h"
int didchd  ;
#line 76 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.h"
char *globlock  ;
#line 9 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/common.h"
int strnIcmp(char const   *a , char const   *b , size_t l ) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/goodies.h"
double stod(char const   *str , char const   ** const  ptr ) ;
#line 20
char const   test[5] ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 163
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  *__addr , socklen_t __addr_len ) ;
#line 379 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 123 "/usr/include/netdb.h"
extern void endhostent(void) ;
#line 144
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 276
extern void endservent(void) ;
#line 290
extern struct servent *getservbyname(char const   *__name , char const   *__proto ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
struct varval strenvvar[7]  = {      {(char const   */* const  */)"LOCKSLEEP", 8L}, 
        {(char const   */* const  */)"LOCKTIMEOUT", 1024L}, 
        {(char const   */* const  */)"SUSPEND", 16L}, 
        {(char const   */* const  */)"NORESRETRY", 4L}, 
        {(char const   */* const  */)"TIMEOUT", 960L}, 
        {(char const   */* const  */)"VERBOSE", 0L}, 
        {(char const   */* const  */)"LOGABSTRACT", -1L}};
#line 38 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
struct varstr strenstr[10]  = 
#line 38
  {      {(char const   */* const  */)"SHELLMETAS", "&|<>~;?*["}, 
        {(char const   */* const  */)"LOCKEXT", ".lock"}, 
        {(char const   */* const  */)"MSGPREFIX", "msg."}, 
        {(char const   */* const  */)"COMSAT", empty}, 
        {(char const   */* const  */)"TRAP", empty}, 
        {(char const   */* const  */)"SHELLFLAGS", "-c"}, 
        {(char const   */* const  */)"DEFAULT", "$ORGMAIL"}, 
        {(char const   */* const  */)"SENDMAIL", "/usr/sbin/sendmail"}, 
        {(char const   */* const  */)"SENDMAILFLAGS", "-oi"}, 
        {(char const   */* const  */)"PROCMAIL_VERSION", "3.15"}};
#line 46 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
char const   lastfolder[11]  = 
#line 46
  {      (char const   )'L',      (char const   )'A',      (char const   )'S',      (char const   )'T', 
        (char const   )'F',      (char const   )'O',      (char const   )'L',      (char const   )'D', 
        (char const   )'E',      (char const   )'R',      (char const   )'\000'};
#line 46 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
char const   maildir[8]  = 
#line 46
  {      (char const   )'M',      (char const   )'A',      (char const   )'I',      (char const   )'L', 
        (char const   )'D',      (char const   )'I',      (char const   )'R',      (char const   )'\000'};
#line 46 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
char const   slinebuf[8]  = 
#line 46
  {      (char const   )'L',      (char const   )'I',      (char const   )'N',      (char const   )'E', 
        (char const   )'B',      (char const   )'U',      (char const   )'F',      (char const   )'\000'};
#line 49 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
static time_t oldtime  ;
#line 50 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
static int fakedelivery  ;
#line 53 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
static int lold  ;
#line 53 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
static char *old  ;
#line 52 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
void elog(char const   * const  newt ) 
{ 
  int lnew ;
  size_t i___0 ;
  char *p___0 ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 57
  tmp = strlen((char const   *)newt);
#line 57
  lnew = (int )tmp;
  }
#line 57
  if (lnew) {
#line 57
    if (nextexit) {
#line 58
      goto flush;
    }
  } else {
#line 58
    goto flush;
  }
#line 59
  i___0 = (size_t )(lold + lnew);
#line 60
  if (lold) {
    {
#line 60
    tmp___0 = realloc((void *)old, i___0);
#line 60
    p___0 = (char *)tmp___0;
    }
  } else {
    {
#line 60
    tmp___1 = malloc(i___0);
#line 60
    p___0 = (char *)tmp___1;
    }
  }
#line 60
  if (p___0) {
    {
#line 61
    old = p___0;
#line 61
    memmove((void *)(old + lold), (void const   *)newt, (size_t )lnew);
#line 62
    lold = (int )i___0;
    }
#line 62
    if ((int )*(p___0 + (lold - 1)) == 10) {
      {
#line 63
      rwrite((int const   )2, (void const   */* const  */)p___0, (int const   )((int )i___0));
#line 63
      lold = 0;
#line 63
      free((void *)p___0);
      }
    }
  } else {
    flush: 
#line 67
    if (lold) {
      {
#line 68
      rwrite((int const   )2, (void const   */* const  */)old, (int const   )lold);
#line 68
      lold = 0;
      }
#line 69
      if (! nextexit) {
        {
#line 70
        free((void *)old);
        }
      }
    }
#line 72
    if (lnew) {
      {
#line 73
      rwrite((int const   )2, (void const   */* const  */)newt, (int const   )lnew);
      }
    }
  }
#line 75
  return;
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
void ignoreterm(void) 
{ 


  {
  {
#line 80
  signal(15, (void (*)(int  ))1);
#line 80
  signal(1, (void (*)(int  ))1);
#line 80
  signal(2, (void (*)(int  ))1);
#line 81
  signal(3, (void (*)(int  ))1);
  }
#line 82
  return;
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
void shutdesc(void) 
{ 


  {
  {
#line 85
  rclose((int const   )savstdout);
#line 85
  closelog();
#line 85
  closerc();
  }
#line 86
  return;
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
void checkroot(int const   c , unsigned long const   Xid ) 
{ 
  uid_t eff ;
  __uid_t tmp ;
  __uid_t tmp___0 ;

  {
  {
#line 90
  eff = geteuid();
  }
#line 90
  if (eff != 0U) {
    {
#line 90
    tmp = getuid();
    }
#line 90
    if (tmp != 0U) {
#line 91
      return;
    }
  }
  {
#line 92
  tmp___0 = getuid();
#line 92
  syslog(2, "set%cid(%lu) failed with ruid/euid = %lu/%lu", c, Xid, (unsigned long )tmp___0,
         eff);
#line 94
  nlog((char const   */* const  */)(insufprivs));
#line 95
  exit(77);
  }
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
void setids(void) 
{ 
  int tmp ;
  __gid_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 99
  if (rcstate != 2) {
    {
#line 100
    tmp = setregid(gid, (__gid_t )-1);
    }
#line 100
    if (tmp) {
#line 100
      goto _L;
    } else {
      {
#line 100
      tmp___0 = getgid();
      }
#line 100
      if (tmp___0 != gid) {
        _L: /* CIL Label */ 
        {
#line 100
        tmp___1 = setgid(gid);
        }
#line 100
        if (tmp___1) {
          {
#line 102
          checkroot((int const   )'g', (unsigned long const   )((unsigned long )gid));
          }
        }
      }
    }
    {
#line 103
    setreuid(uid, (__uid_t )-1);
#line 104
    tmp___2 = setuid(uid);
    }
#line 104
    if (tmp___2) {
      {
#line 105
      checkroot((int const   )'u', (unsigned long const   )((unsigned long )uid));
      }
    }
    {
#line 106
    setegid(gid);
#line 106
    rcstate = 2;
#line 108
    *((long volatile   *)(& strenvvar[5].val)) = (long volatile   )0;
    }
  }
#line 111
  return;
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
void writeerr(char const   * const  line ) 
{ 


  {
  {
#line 114
  nlog((char const   */* const  */)(errwwriting));
#line 114
  logqnl(line);
  }
#line 115
  return;
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
int forkerr(pid_t const   pid , char const   * const  a ) 
{ 


  {
#line 118
  if (pid == -1) {
    {
#line 119
    nlog((char const   */* const  */)"Failed forking");
#line 119
    logqnl(a);
    }
#line 120
    return (1);
  }
#line 122
  return (0);
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
void progerr(char const   * const  line , int xitcode , int okay ) 
{ 
  char num[(((8UL * sizeof(thepid)) * 4UL) / 10UL + 1UL) + 1UL] ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 127
  if (okay) {
#line 127
    tmp = "Non-zero exitcode (";
  } else {
#line 127
    tmp = "Program failure (";
  }
  {
#line 127
  nlog((char const   */* const  */)tmp);
#line 128
  ltstr((int const   )0, (long const   )((long )xitcode), num);
#line 128
  elog((char const   */* const  */)(num));
  }
#line 128
  if (okay) {
#line 128
    tmp___0 = ") from";
  } else {
#line 128
    tmp___0 = ") of";
  }
  {
#line 128
  elog((char const   */* const  */)tmp___0);
#line 129
  logqnl(line);
  }
#line 130
  return;
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
void chderr(char const   * const  dir ) 
{ 


  {
  {
#line 133
  nlog((char const   */* const  */)"Couldn\'t chdir to");
#line 133
  logqnl(dir);
  }
#line 134
  return;
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
void readerr(char const   * const  file ) 
{ 


  {
  {
#line 137
  nlog((char const   */* const  */)"Couldn\'t read");
#line 137
  logqnl(file);
  }
#line 138
  return;
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
void verboff(void) 
{ 


  {
  {
#line 141
  *((long volatile   *)(& strenvvar[5].val)) = (long volatile   )0;
#line 143
  qsignal((int const   )10, & verboff);
  }
#line 145
  return;
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
void verbon(void) 
{ 


  {
  {
#line 148
  *((long volatile   *)(& strenvvar[5].val)) = (long volatile   )1;
#line 150
  qsignal((int const   )12, & verbon);
  }
#line 152
  return;
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
void yell(char const   * const  a , char const   * const  b ) 
{ 


  {
#line 155
  if (*((long volatile   *)(& strenvvar[5].val))) {
    {
#line 156
    nlog(a);
#line 156
    logqnl(b);
    }
  }
#line 157
  return;
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
void newid(void) 
{ 


  {
  {
#line 160
  thepid = getpid();
#line 160
  oldtime = (time_t )0;
  }
#line 161
  return;
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
void zombiecollect(void) 
{ 
  __pid_t tmp ;

  {
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 164
    tmp = waitpid(-1, (int *)0, 1);
    }
#line 164
    if (! (tmp > 0)) {
#line 164
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 165
  return;
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
static char const   colnsp[3]  = {      (char const   )':',      (char const   )' ',      (char const   )'\000'};
#line 167 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
void nlog(char const   * const  a ) 
{ 
  time_t newtime ;
  char num[(((8UL * sizeof(thepid)) * 4UL) / 10UL + 1UL) + 1UL] ;
  char *tmp ;

  {
  {
#line 170
  elog((char const   */* const  */)(procmailn));
#line 170
  elog((char const   */* const  */)(colnsp));
  }
#line 171
  if (*((long volatile   *)(& strenvvar[5].val))) {
    {
#line 171
    newtime = time((time_t *)0);
    }
#line 171
    if (oldtime != newtime) {
      {
#line 173
      elog((char const   */* const  */)"[");
#line 173
      oldtime = newtime;
#line 173
      ultstr(0, (unsigned long )thepid, num);
#line 173
      elog((char const   */* const  */)(num));
#line 174
      elog((char const   */* const  */)"] ");
#line 174
      tmp = ctime((time_t const   *)(& oldtime));
#line 174
      elog((char const   */* const  */)tmp);
#line 174
      elog((char const   */* const  */)(procmailn));
#line 174
      elog((char const   */* const  */)(colnsp));
      }
    }
  }
  {
#line 176
  elog(a);
  }
#line 177
  return;
}
}
#line 179 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
void logqnl(char const   * const  a ) 
{ 


  {
  {
#line 180
  elog((char const   */* const  */)(oquote));
#line 180
  elog(a);
#line 180
  elog((char const   */* const  */)(cquote));
  }
#line 181
  return;
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
void skipped(char const   * const  x ) 
{ 


  {
#line 184
  if (*x) {
    {
#line 185
    nlog((char const   */* const  */)"Skipped");
#line 185
    logqnl(x);
    }
  }
#line 186
  return;
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
int nextrcfile(void) 
{ 
  char const   *p___0 ;
  int rval ;
  size_t tmp ;
  char *tmp___0 ;

  {
#line 189
  rval = 2;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    p___0 = (char const   *)*gargv;
#line 190
    if (! p___0) {
#line 190
      goto while_break;
    }
    {
#line 191
    gargv ++;
#line 192
    tmp___0 = strchr(p___0, '=');
    }
#line 192
    if (! tmp___0) {
      {
#line 193
      tmp = strlen(p___0);
      }
#line 193
      if (tmp > linebuf - 1UL) {
        {
#line 194
        nlog((char const   */* const  */)"Excessively long rcfile path skipped\n");
        }
#line 195
        goto while_continue;
      }
#line 197
      rcfile = p___0;
#line 198
      return (rval);
    }
#line 200
    rval = 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 202
  return (0);
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
void onguard(void) 
{ 


  {
#line 206
  lcking |= 1;
#line 207
  return;
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
void offguard(void) 
{ 


  {
#line 210
  lcking &= -2;
#line 211
  if (nextexit == (int volatile   )1) {
    {
#line 212
    elog((char const   */* const  */)(newline));
#line 212
    Terminate();
    }
  }
#line 213
  return;
}
}
#line 216 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
static char const   * const  msg[4]  = {      (char const   */* const  */)"memory",      (char const   */* const  */)"fork",      (char const   */* const  */)"a file descriptor",      (char const   */* const  */)"a kernel-lock"};
#line 215 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
void sterminate(void) 
{ 
  register unsigned int i___0 ;
  register unsigned int j ;

  {
  {
#line 218
  ignoreterm();
  }
#line 219
  if (pidchild > 0) {
    {
#line 220
    kill(pidchild, 15);
    }
  }
#line 221
  if (! nextexit) {
    {
#line 222
    nextexit = (int volatile   )1;
#line 222
    nlog((char const   */* const  */)"Terminating prematurely");
    }
#line 223
    if (! (lcking & 1)) {
#line 225
      i___0 = (unsigned int )((lcking & -4) >> 1);
#line 225
      if (i___0) {
        {
#line 226
        elog((char const   */* const  */)(whilstwfor));
#line 227
        j = 0U;
        }
        {
#line 227
        while (1) {
          while_continue: /* CIL Label */ ;
#line 227
          i___0 >>= 1;
#line 227
          if (i___0 & 1U) {
#line 227
            goto while_break;
          }
#line 227
          j ++;
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 228
        elog(msg[j]);
        }
      }
      {
#line 230
      elog((char const   */* const  */)(newline));
#line 230
      Terminate();
      }
    }
  }
#line 233
  return;
}
}
#line 264 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
static unsigned char const   ip_localhost[4]  = {      (unsigned char const   )163,      (unsigned char const   )152,      (unsigned char const   )51,      (unsigned char const   )12};
#line 235 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
void Terminate(void) 
{ 
  char const   *chp ;
  char const   *lstfolder ;
  char const   *tmp ;
  int s ;
  struct sockaddr_in addr ;
  char *chad ;
  char *tmp___0 ;
  long tmp___1 ;
  struct hostent  const  *host___0 ;
  struct hostent *tmp___2 ;
  long tmp___3 ;
  struct servent  const  *serv ;
  struct servent *tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  __pid_t tmp___9 ;
  int tmp___10 ;

  {
  {
#line 237
  ignoreterm();
  }
#line 238
  if (retvl2 != 0) {
#line 239
    fakedelivery = 0;
#line 239
    retval = retvl2;
  }
  {
#line 240
  tmp___9 = getpid();
  }
#line 240
  if (tmp___9 == thepid) {
#line 242
    if (retval != 0) {
#line 243
      lasttell = (off_t )-1;
#line 244
      if (fakedelivery) {
#line 244
        lstfolder = "**Lost**";
      } else {
#line 244
        if (retval == 75) {
#line 244
          tmp = "**Requeued**";
        } else {
#line 244
          tmp = "**Bounced**";
        }
#line 244
        lstfolder = tmp;
      }
    } else {
      {
#line 248
      lstfolder = tgetenv((char const   */* const  */)(lastfolder));
      }
    }
    {
#line 249
    logabstract((char const   */* const  */)lstfolder);
#line 251
    chp = tgetenv((char const   */* const  */)(lgname));
#line 251
    tmp___8 = strlen(chp);
    }
#line 251
    if (tmp___8 + 2UL <= linebuf) {
      {
#line 253
      cat((char const   */* const  */)chp, (char const   */* const  */)"@");
#line 254
      chp = (char const   *)((char *)strenstr[3].sval);
#line 254
      chad = strchr(chp, '@');
      }
#line 254
      if (chad) {
#line 255
        tmp___0 = chad;
#line 255
        chad ++;
#line 255
        *tmp___0 = (char )'\000';
      } else {
        {
#line 256
        tmp___1 = renvint((long const   )-1L, (char const   */* const  */)chp);
        }
#line 256
        if (tmp___1) {
#line 259
          chp = empty;
        } else {
#line 257
          goto nocomsat;
        }
      }
#line 260
      if (! chad) {
        {
#line 265
        addr.sin_family = (sa_family_t )2;
#line 266
        memmove((void *)(& addr.sin_addr), (void const   *)(ip_localhost), sizeof(ip_localhost));
        }
      } else
#line 260
      if (! *chad) {
        {
#line 265
        addr.sin_family = (sa_family_t )2;
#line 266
        memmove((void *)(& addr.sin_addr), (void const   *)(ip_localhost), sizeof(ip_localhost));
        }
      } else {
        {
#line 271
        tmp___2 = gethostbyname((char const   *)chad);
#line 271
        host___0 = (struct hostent  const  *)tmp___2;
        }
#line 271
        if (host___0) {
#line 271
          if (! *(host___0->h_addr_list + 0)) {
            {
#line 272
            endhostent();
            }
#line 273
            goto nocomsat;
          }
        } else {
          {
#line 272
          endhostent();
          }
#line 273
          goto nocomsat;
        }
        {
#line 275
        addr.sin_family = (sa_family_t )host___0->h_addrtype;
#line 276
        memmove((void *)(& addr.sin_addr), (void const   *)*(host___0->h_addr_list + 0),
                (size_t )host___0->h_length);
#line 277
        endhostent();
        }
      }
#line 279
      if (! *chp) {
#line 280
        chp = "512";
      }
      {
#line 281
      tmp___3 = strtol((char const   */* __restrict  */)chp, (char **/* __restrict  */)(& chad),
                       10);
#line 281
      s = (int )tmp___3;
      }
#line 282
      if ((unsigned long )chp == (unsigned long )chad) {
        {
#line 284
        tmp___4 = getservbyname(chp, "udp");
#line 284
        serv = (struct servent  const  *)tmp___4;
        }
#line 284
        if (! serv) {
          {
#line 285
          endservent();
          }
#line 286
          goto nocomsat;
        }
        {
#line 288
        addr.sin_port = (in_port_t )serv->s_port;
#line 288
        endservent();
        }
      } else {
        {
#line 291
        addr.sin_port = htons((uint16_t )((short )s));
        }
      }
#line 292
      if (lasttell >= 0L) {
        {
#line 293
        ultstr(0, (unsigned long )lasttell, buf2);
#line 293
        catlim((char const   *)buf2);
        }
      }
      {
#line 294
      catlim(":");
      }
#line 295
      if (lasttell >= 0L) {
        {
#line 295
        tmp___6 = strchr(dirsep, (int )*lstfolder);
        }
#line 295
        if (! tmp___6) {
          {
#line 296
          tmp___5 = tgetenv((char const   */* const  */)(maildir));
#line 296
          catlim(tmp___5);
#line 296
          catlim((dirsep + (sizeof("/") - 1UL)) - 1);
          }
        }
      }
      {
#line 297
      catlim(lstfolder);
#line 297
      s = socket(2, 2, 17);
#line 298
      tmp___7 = strlen((char const   *)buf);
#line 298
      sendto(s, (void const   *)buf, tmp___7, 0, (struct sockaddr  const  *)((void const   *)(& addr)),
             (socklen_t )sizeof(addr));
#line 298
      rclose((int const   )s);
#line 299
      yell((char const   */* const  */)"Notified comsat:", (char const   */* const  */)buf);
      }
    }
    nocomsat: 
    {
#line 303
    shutdesc();
    }
#line 304
    if (! (lcking & 2)) {
      {
#line 305
      exectrap((char const   */* const  */)strenstr[4].sval);
      }
    }
    {
#line 306
    nextexit = (int volatile   )2;
#line 306
    unlock((char **/* const  */)(& loclock));
#line 306
    unlock((char **/* const  */)(& globlock));
#line 306
    fdunlock();
    }
  }
  {
#line 308
  elog((char const   */* const  */)(empty));
  }
#line 308
  if (fakedelivery == 2) {
#line 308
    tmp___10 = 0;
  } else {
#line 308
    tmp___10 = retval;
  }
  {
#line 308
  exit(tmp___10);
  }
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
void suspend(void) 
{ 


  {
  {
#line 312
  ssleep((unsigned int const   )((unsigned int )strenvvar[2].val));
  }
#line 313
  return;
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
void *app_val_(struct dyna_long * const  sp ) 
{ 
  size_t len ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 316
  if (sp->filled == sp->tspace) {
#line 317
    tmp = sp->tspace + 4;
#line 317
    sp->tspace = tmp;
#line 317
    len = (unsigned long )tmp * sizeof(*(sp->vals));
#line 318
    if (sp->vals) {
      {
#line 318
      tmp___0 = trealloc(sp->vals, len);
#line 318
      sp->vals = (union __anonunion_vals_55 *)tmp___0;
      }
    } else {
      {
#line 318
      tmp___1 = tmalloc(len);
#line 318
      sp->vals = (union __anonunion_vals_55 *)tmp___1;
      }
    }
  }
#line 320
  tmp___2 = sp->filled;
#line 320
  (sp->filled) ++;
#line 320
  return ((void *)(sp->vals + tmp___2));
}
}
#line 323 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
int alphanum(unsigned int const   c ) 
{ 
  int tmp ;

  {
#line 324
  if ((unsigned int )c - 48U <= 9U) {
#line 324
    tmp = 1;
  } else
#line 324
  if (c - 97U <= 25U) {
#line 324
    tmp = 1;
  } else
#line 324
  if (c - 65U <= 25U) {
#line 324
    tmp = 1;
  } else
#line 324
  if (c == 95U) {
#line 324
    tmp = 1;
  } else {
#line 324
    tmp = 0;
  }
#line 324
  return (tmp);
}
}
#line 327 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
char *pmrc2buf(void) 
{ 
  int tmp ;

  {
  {
#line 328
  sgetcp = pmrc;
#line 329
  tmp = readparse(buf, (int (*/* const  */)())(& sgetc), (int const   )2);
  }
#line 329
  if (tmp) {
#line 330
    *(buf + 0) = (char )'\000';
  }
#line 331
  return (buf);
}
}
#line 334 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
void setmaildir(char const   * const  newdir ) 
{ 
  char *chp ;
  char *tmp ;

  {
  {
#line 336
  didchd = 1;
#line 336
  tmp = strcpy((char */* __restrict  */)buf2, (char const   */* __restrict  */)(maildir));
#line 336
  chp = tmp + (sizeof(maildir) - 1UL);
#line 336
  *chp = (char )'=';
#line 337
  chp ++;
#line 337
  strcpy((char */* __restrict  */)chp, (char const   */* __restrict  */)newdir);
#line 337
  sputenv((char const   */* const  */)buf2);
  }
#line 338
  return;
}
}
#line 340 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
void setoverflow(void) 
{ 


  {
  {
#line 341
  sputenv((char const   */* const  */)"PROCMAIL_OVERFLOW=yes");
  }
#line 342
  return;
}
}
#line 344 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
void srequeue(void) 
{ 


  {
  {
#line 345
  retval = 75;
#line 345
  sterminate();
  }
#line 346
  return;
}
}
#line 348 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
void slose(void) 
{ 


  {
  {
#line 349
  fakedelivery = 2;
#line 349
  sterminate();
  }
#line 350
  return;
}
}
#line 352 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
void sbounce(void) 
{ 


  {
  {
#line 353
  retval = 73;
#line 353
  sterminate();
  }
#line 354
  return;
}
}
#line 356 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
void catlim(char const   *src ) 
{ 
  register char *dest ;
  register size_t lim ;
  char *tmp ;
  char tmp___0 ;
  char const   *tmp___1 ;

  {
#line 357
  dest = buf;
#line 357
  lim = linebuf;
  {
#line 358
  while (1) {
    while_continue: /* CIL Label */ ;
#line 358
    if (lim) {
#line 358
      if (! *dest) {
#line 358
        goto while_break;
      }
    } else {
#line 358
      goto while_break;
    }
#line 359
    dest ++;
#line 359
    lim --;
  }
  while_break: /* CIL Label */ ;
  }
#line 360
  if (lim) {
    {
#line 361
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 361
      lim --;
#line 361
      if (lim) {
#line 361
        tmp = dest;
#line 361
        dest ++;
#line 361
        tmp___1 = src;
#line 361
        src ++;
#line 361
        tmp___0 = (char )*tmp___1;
#line 361
        *tmp = tmp___0;
#line 361
        if (! tmp___0) {
#line 361
          goto while_break___0;
        }
      } else {
#line 361
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 362
    *dest = (char )'\000';
  }
#line 364
  return;
}
}
#line 366 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
void setdef(char const   * const  name___1 , char const   * const  contents ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 367
  sgetcp = (char const   *)buf2;
#line 367
  tmp = strcpy((char */* __restrict  */)((char *)sgetcp), (char const   */* __restrict  */)name___1);
#line 367
  tmp___0 = strcat((char */* __restrict  */)tmp, (char const   */* __restrict  */)"=");
#line 367
  strcat((char */* __restrict  */)tmp___0, (char const   */* __restrict  */)contents);
#line 368
  tmp___1 = readparse(buf, (int (*/* const  */)())(& sgetc), (int const   )2);
  }
#line 368
  if (! tmp___1) {
    {
#line 369
    sputenv((char const   */* const  */)buf);
    }
  }
#line 370
  return;
}
}
#line 372 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
void metaparse(char const   *p___0 ) 
{ 
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 373
  tmp___2 = strpbrk(p___0, strenstr[0].sval);
  }
#line 373
  if (tmp___2) {
#line 373
    tmp___3 = 1;
  } else {
#line 373
    tmp___3 = 0;
  }
#line 373
  sh = tmp___3;
#line 373
  if (sh) {
    {
#line 374
    strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)p___0);
    }
  } else {
    {
#line 376
    tmp = tstrdup((char const   */* const  */)p___0);
#line 376
    p___0 = (char const   *)tmp;
#line 376
    sgetcp = p___0;
#line 377
    tmp___0 = readparse(buf, (int (*/* const  */)())(& sgetc), (int const   )0);
    }
#line 377
    if (tmp___0) {
      {
#line 382
      strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)p___0);
#line 382
      sh = 1;
      }
    } else {
      {
#line 377
      tmp___1 = strcmp(test, (char const   *)buf);
      }
#line 377
      if (! tmp___1) {
        {
#line 382
        strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)p___0);
#line 382
        sh = 1;
        }
      }
    }
    {
#line 383
    tfree((void */* const  */)((char *)p___0));
    }
  }
#line 385
  return;
}
}
#line 387 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
void concatenate(char *p___0 ) 
{ 
  char *tmp ;
  char tmp___0 ;

  {
  {
#line 388
  while (1) {
    while_continue: /* CIL Label */ ;
#line 388
    if (! ((unsigned long )p___0 != (unsigned long )Tmnate)) {
#line 388
      goto while_break;
    }
    {
#line 389
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 389
      tmp = p___0;
#line 389
      p___0 ++;
#line 389
      if (! *tmp) {
#line 389
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 390
    *(p___0 + -1) = (char )' ';
  }
  while_break: /* CIL Label */ ;
  }
#line 392
  tmp___0 = (char )'\000';
#line 392
  *(p___0 + -1) = tmp___0;
#line 392
  *p___0 = tmp___0;
#line 393
  return;
}
}
#line 395 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
char *cat(char const   * const  a , char const   * const  b ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 396
  tmp = strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)a);
#line 396
  tmp___0 = strcat((char */* __restrict  */)tmp, (char const   */* __restrict  */)b);
  }
#line 396
  return (tmp___0);
}
}
#line 399 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
char *tstrdup(char const   * const  a ) 
{ 
  int i___0 ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 401
  tmp = strlen((char const   *)a);
#line 401
  i___0 = (int )(tmp + 1UL);
#line 402
  tmp___0 = tmalloc((size_t )i___0);
#line 402
  tmp___1 = memmove(tmp___0, (void const   *)a, (size_t )i___0);
  }
#line 402
  return ((char *)tmp___1);
}
}
#line 405 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
char const   *tgetenv(char const   * const  a ) 
{ 
  char const   *b ;
  char const   *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 407
  tmp___1 = getenv((char const   *)a);
#line 407
  b = (char const   *)tmp___1;
  }
#line 407
  if (b) {
#line 407
    tmp___0 = b;
  } else {
#line 407
    tmp___0 = empty;
  }
#line 407
  return (tmp___0);
}
}
#line 410 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
char *cstr(char * const  a , char const   * const  b ) 
{ 
  char *tmp ;

  {
#line 411
  if (a) {
    {
#line 412
    tfree((void */* const  */)a);
    }
  }
  {
#line 413
  tmp = tstrdup(b);
  }
#line 413
  return (tmp);
}
}
#line 416 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
void setlastfolder(char const   * const  folder ) 
{ 
  char *chp ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 417
  if (asgnlastf) {
    {
#line 419
    asgnlastf = 0;
#line 420
    tmp = strlen((char const   *)folder);
#line 420
    tmp___0 = tmalloc((((sizeof(lastfolder) - 1UL) + 1UL) + tmp) + 1UL);
#line 420
    chp = (char *)tmp___0;
#line 420
    strcpy((char */* __restrict  */)chp, (char const   */* __restrict  */)(lastfolder));
#line 421
    *(chp + (sizeof(lastfolder) - 1UL)) = (char )'=';
#line 421
    strcpy((char */* __restrict  */)((chp + (sizeof(lastfolder) - 1UL)) + 1), (char const   */* __restrict  */)folder);
#line 422
    sputenv((char const   */* const  */)chp);
#line 422
    tfree((void */* const  */)chp);
    }
  }
#line 424
  return;
}
}
#line 426 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
char *gobenv(char *chp , char *end ) 
{ 
  int found ;
  int i___0 ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 428
  found = 0;
#line 428
  end --;
#line 429
  i___0 = getb();
#line 429
  tmp___2 = alphanum((unsigned int const   )i___0);
  }
#line 429
  if (tmp___2) {
#line 429
    if (! ((unsigned int )i___0 - 48U <= 9U)) {
#line 430
      found = 1;
      {
#line 430
      while (1) {
        while_continue: /* CIL Label */ ;
#line 430
        tmp = chp;
#line 430
        chp ++;
#line 430
        *tmp = (char )i___0;
#line 430
        if ((unsigned long )chp < (unsigned long )end) {
          {
#line 430
          i___0 = getb();
#line 430
          tmp___0 = alphanum((unsigned int const   )i___0);
          }
#line 430
          if (tmp___0) {
#line 430
            tmp___1 = 1;
          } else {
#line 430
            tmp___1 = 0;
          }
        } else {
#line 430
          tmp___1 = 0;
        }
#line 430
        if (! tmp___1) {
#line 430
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 431
  *chp = (char )'\000';
#line 431
  ungetb((int const   )i___0);
  }
#line 432
  if ((unsigned long )chp == (unsigned long )end) {
    {
#line 433
    nlog((char const   */* const  */)(exceededlb));
#line 433
    setoverflow();
    }
#line 434
    return (end + 1);
  }
  {
#line 437
  if (i___0 == 61) {
#line 437
    goto case_61;
  }
#line 437
  if (i___0 == 10) {
#line 437
    goto case_61;
  }
#line 437
  if (i___0 == 9) {
#line 437
    goto case_61;
  }
#line 437
  if (i___0 == 32) {
#line 437
    goto case_61;
  }
#line 436
  goto switch_break;
  case_61: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_32: /* CIL Label */ 
#line 438
  if (found) {
#line 439
    return (chp);
  }
  switch_break: /* CIL Label */ ;
  }
#line 441
  return ((char *)0);
}
}
#line 444 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
int asenvcpy(char *src ) 
{ 
  char const   *chp ;
  char *tmp ;

  {
  {
#line 446
  tmp = strchr((char const   *)src, '=');
#line 446
  chp = (char const   *)tmp;
  }
#line 446
  if (chp) {
    {
#line 451
    erestrict = 1;
#line 451
    setids();
#line 451
    chp ++;
#line 451
    strncpy((char */* __restrict  */)buf, (char const   */* __restrict  */)src, (size_t )(chp - (char const   *)src));
#line 452
    src = buf + (chp - (char const   *)src);
#line 453
    chp = eputenv((char const   */* const  */)chp, (char */* const  */)src);
    }
#line 453
    if (chp) {
      {
#line 454
      *(src + -1) = (char )'\000';
#line 455
      asenv((char const   */* const  */)chp);
      }
    }
#line 457
    return (1);
  }
#line 459
  return (0);
}
}
#line 462 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
void mallocbuffers(size_t lineb , int setenv___0 ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  char *chp ;
  char *tmp___1 ;

  {
#line 463
  if (buf) {
    {
#line 464
    tfree((void */* const  */)buf);
#line 465
    tfree((void */* const  */)buf2);
    }
  }
  {
#line 467
  tmp = tmalloc(lineb + 2UL);
#line 467
  buf = (char *)tmp;
#line 467
  tmp___0 = tmalloc(lineb + 2UL);
#line 467
  buf2 = (char *)tmp___0;
  }
#line 468
  if (setenv___0) {
    {
#line 470
    tmp___1 = strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)(slinebuf));
#line 470
    chp = tmp___1 + (sizeof(slinebuf) - 1UL);
#line 470
    *chp = (char )'=';
#line 471
    ultstr(0, lineb, chp + 1);
#line 472
    sputenv((char const   */* const  */)buf);
    }
  }
#line 474
  return;
}
}
#line 477 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
static char const   logfile[8]  = 
#line 477
  {      (char const   )'L',      (char const   )'O',      (char const   )'G',      (char const   )'F', 
        (char const   )'I',      (char const   )'L',      (char const   )'E',      (char const   )'\000'};
#line 477 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
static char const   Log[4]  = {      (char const   )'L',      (char const   )'O',      (char const   )'G',      (char const   )'\000'};
#line 477 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
static char const   sdelivered[10]  = 
#line 477
  {      (char const   )'D',      (char const   )'E',      (char const   )'L',      (char const   )'I', 
        (char const   )'V',      (char const   )'E',      (char const   )'R',      (char const   )'E', 
        (char const   )'D',      (char const   )'\000'};
#line 477 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
static char const   includerc[10]  = 
#line 477
  {      (char const   )'I',      (char const   )'N',      (char const   )'C',      (char const   )'L', 
        (char const   )'U',      (char const   )'D',      (char const   )'E',      (char const   )'R', 
        (char const   )'C',      (char const   )'\000'};
#line 477 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
static char const   eumask[6]  = {      (char const   )'U',      (char const   )'M',      (char const   )'A',      (char const   )'S', 
        (char const   )'K',      (char const   )'\000'};
#line 477 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
static char const   dropprivs[10]  = 
#line 477
  {      (char const   )'D',      (char const   )'R',      (char const   )'O',      (char const   )'P', 
        (char const   )'P',      (char const   )'R',      (char const   )'I',      (char const   )'V', 
        (char const   )'S',      (char const   )'\000'};
#line 477 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
static char const   shift[6]  = {      (char const   )'S',      (char const   )'H',      (char const   )'I',      (char const   )'F', 
        (char const   )'T',      (char const   )'\000'};
#line 477 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
static char const   switchrc[9]  = 
#line 477
  {      (char const   )'S',      (char const   )'W',      (char const   )'I',      (char const   )'T', 
        (char const   )'C',      (char const   )'H',      (char const   )'R',      (char const   )'C', 
        (char const   )'\000'};
#line 476 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
void asenv(char const   * const  chp ) 
{ 
  long lineb ;
  int tmp ;
  int i___0 ;
  long tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  char *tmp___4 ;
  long tmp___5 ;
  char const   *name___1 ;
  int tmp___6 ;
  int tmp___7 ;
  int i___1 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;

  {
  {
#line 480
  tmp___24 = strcmp((char const   *)buf, slinebuf);
  }
#line 480
  if (tmp___24) {
    {
#line 486
    tmp___23 = strcmp((char const   *)buf, maildir);
    }
#line 486
    if (tmp___23) {
      {
#line 491
      tmp___22 = strcmp((char const   *)buf, logfile);
      }
#line 491
      if (tmp___22) {
        {
#line 493
        tmp___21 = strcmp((char const   *)buf, Log);
        }
#line 493
        if (tmp___21) {
          {
#line 495
          tmp___20 = strcmp((char const   *)buf, exitcode);
          }
#line 495
          if (tmp___20) {
            {
#line 497
            tmp___19 = strcmp((char const   *)buf, shift);
            }
#line 497
            if (tmp___19) {
              {
#line 505
              tmp___18 = strcmp((char const   *)buf, dropprivs);
              }
#line 505
              if (tmp___18) {
                {
#line 512
                tmp___17 = strcmp((char const   *)buf, sdelivered);
                }
#line 512
                if (tmp___17) {
                  {
#line 522
                  tmp___16 = strcmp((char const   *)buf, lockfile);
                  }
#line 522
                  if (tmp___16) {
                    {
#line 524
                    tmp___15 = strcmp((char const   *)buf, eumask);
                    }
#line 524
                    if (tmp___15) {
                      {
#line 526
                      tmp___14 = strcmp((char const   *)buf, includerc);
                      }
#line 526
                      if (tmp___14) {
                        {
#line 528
                        tmp___13 = strcmp((char const   *)buf, switchrc);
                        }
#line 528
                        if (tmp___13) {
                          {
#line 530
                          tmp___12 = strcmp((char const   *)buf, host);
                          }
#line 530
                          if (tmp___12) {
#line 540
                            i___1 = (int )(sizeof(strenvvar) / sizeof(strenvvar[0]) - 1UL);
                            {
#line 541
                            while (1) {
                              while_continue: /* CIL Label */ ;
                              {
#line 542
                              tmp___8 = strcmp((char const   *)buf, (char const   *)strenvvar[i___1].name);
                              }
#line 542
                              if (! tmp___8) {
                                {
#line 543
                                strenvvar[i___1].val = renvint((long const   )strenvvar[i___1].val,
                                                               chp);
                                }
                              }
#line 541
                              tmp___9 = i___1;
#line 541
                              i___1 --;
#line 541
                              if (! tmp___9) {
#line 541
                                goto while_break;
                              }
                            }
                            while_break: /* CIL Label */ ;
                            }
#line 545
                            i___1 = (int )(sizeof(strenstr) / sizeof(strenstr[0]) - 1UL);
                            {
#line 546
                            while (1) {
                              while_continue___0: /* CIL Label */ ;
                              {
#line 547
                              tmp___10 = strcmp((char const   *)buf, (char const   *)strenstr[i___1].sname);
                              }
#line 547
                              if (! tmp___10) {
#line 548
                                strenstr[i___1].sval = (char const   *)chp;
                              }
#line 546
                              tmp___11 = i___1;
#line 546
                              i___1 --;
#line 546
                              if (! tmp___11) {
#line 546
                                goto while_break___0;
                              }
                            }
                            while_break___0: /* CIL Label */ ;
                            }
                          } else {
                            {
#line 532
                            name___1 = hostname();
#line 532
                            tmp___7 = strcmp((char const   *)chp, name___1);
                            }
#line 532
                            if (tmp___7) {
                              {
#line 533
                              yell((char const   */* const  */)"HOST mismatched",
                                   (char const   */* const  */)name___1);
                              }
#line 534
                              if (rc < 0) {
                                {
#line 535
                                retval = 0;
#line 535
                                Terminate();
                                }
                              } else {
                                {
#line 534
                                tmp___6 = nextrcfile();
                                }
#line 534
                                if (! tmp___6) {
                                  {
#line 535
                                  retval = 0;
#line 535
                                  Terminate();
                                  }
                                }
                              }
                              {
#line 536
                              closerc();
                              }
                            }
                          }
                        } else {
                          {
#line 529
                          changerc(chp);
                          }
                        }
                      } else {
                        {
#line 527
                        pushrc(chp);
                        }
                      }
                    } else {
                      {
#line 525
                      tmp___5 = strtol((char const   */* __restrict  */)chp, (char **/* __restrict  */)((char **)0),
                                       8);
#line 525
                      doumask((mode_t )tmp___5);
                      }
                    }
                  } else {
                    {
#line 523
                    tmp___4 = tstrdup((char const   */* const  */)((char *)chp));
#line 523
                    lockit(tmp___4, (char **/* const  */)(& globlock));
                    }
                  }
                } else {
                  {
#line 513
                  tmp___3 = renvint((long const   )0L, chp);
                  }
#line 513
                  if (tmp___3) {
                    {
#line 514
                    onguard();
#line 515
                    thepid = sfork();
                    }
#line 515
                    if (thepid > 0) {
                      {
#line 516
                      nextexit = (int volatile   )2;
#line 516
                      lcking &= -2;
#line 516
                      exit(retvl2);
                      }
                    }
                    {
#line 517
                    tmp___2 = forkerr((pid_t const   )thepid, (char const   */* const  */)(procmailn));
                    }
#line 517
                    if (! tmp___2) {
#line 518
                      fakedelivery = 1;
                    }
                    {
#line 519
                    newid();
#line 519
                    offguard();
                    }
                  }
                }
              } else {
                {
#line 506
                tmp___1 = renvint((long const   )0L, chp);
                }
#line 506
                if (tmp___1) {
#line 507
                  if (*((long volatile   *)(& strenvvar[5].val))) {
                    {
#line 508
                    nlog((char const   */* const  */)"Assuming identity of the recipient, VERBOSE=off\n");
                    }
                  }
                  {
#line 509
                  setids();
                  }
                }
              }
            } else {
              {
#line 499
              tmp___0 = renvint((long const   )0L, chp);
#line 499
              i___0 = (int )tmp___0;
              }
#line 499
              if (i___0 > 0) {
#line 500
                if (i___0 > crestarg) {
#line 501
                  i___0 = crestarg;
                }
#line 502
                crestarg -= i___0;
#line 502
                restargv += i___0;
              }
            }
          } else {
#line 496
            setxit = 1;
          }
        } else {
          {
#line 494
          elog(chp);
          }
        }
      } else {
        {
#line 492
        opnlog((char const   *)chp);
        }
      }
    } else {
      {
#line 487
      tmp = chdir((char const   *)chp);
      }
#line 487
      if (tmp) {
        {
#line 488
        chderr(chp);
        }
      } else {
#line 490
        didchd = 1;
      }
    }
  } else {
    {
#line 482
    lineb = renvint((long const   )0L, chp);
    }
#line 482
    if (lineb < 128L) {
#line 483
      lineb = 128L;
    }
    {
#line 484
    linebuf = (size_t )lineb;
#line 484
    mallocbuffers(linebuf, 0);
    }
  }
#line 551
  return;
}
}
#line 553 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
long renvint(long const   i___0 , char const   * const  env ) 
{ 
  char const   *p___0 ;
  long t___1 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 555
  t___1 = strtol((char const   */* __restrict  */)env, (char **/* __restrict  */)((char **)(& p___0)),
                 10);
  }
#line 556
  if ((unsigned long )p___0 == (unsigned long )env) {
    {
#line 557
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 559
      if ((int const   )*p___0 == 13) {
#line 559
        goto case_13;
      }
#line 559
      if ((int const   )*p___0 == 12) {
#line 559
        goto case_13;
      }
#line 559
      if ((int const   )*p___0 == 11) {
#line 559
        goto case_13;
      }
#line 559
      if ((int const   )*p___0 == 10) {
#line 559
        goto case_13;
      }
#line 559
      if ((int const   )*p___0 == 9) {
#line 559
        goto case_13;
      }
#line 559
      if ((int const   )*p___0 == 32) {
#line 559
        goto case_13;
      }
#line 561
      if ((int const   )*p___0 == 79) {
#line 561
        goto case_79;
      }
#line 561
      if ((int const   )*p___0 == 111) {
#line 561
        goto case_79;
      }
#line 566
      if ((int const   )*p___0 == 68) {
#line 566
        goto case_68;
      }
#line 566
      if ((int const   )*p___0 == 100) {
#line 566
        goto case_68;
      }
#line 566
      if ((int const   )*p___0 == 70) {
#line 566
        goto case_68;
      }
#line 566
      if ((int const   )*p___0 == 102) {
#line 566
        goto case_68;
      }
#line 566
      if ((int const   )*p___0 == 78) {
#line 566
        goto case_68;
      }
#line 566
      if ((int const   )*p___0 == 110) {
#line 566
        goto case_68;
      }
#line 563
      if ((int const   )*p___0 == 69) {
#line 563
        goto case_69;
      }
#line 563
      if ((int const   )*p___0 == 101) {
#line 563
        goto case_69;
      }
#line 563
      if ((int const   )*p___0 == 84) {
#line 563
        goto case_69;
      }
#line 563
      if ((int const   )*p___0 == 116) {
#line 563
        goto case_69;
      }
#line 563
      if ((int const   )*p___0 == 89) {
#line 563
        goto case_69;
      }
#line 563
      if ((int const   )*p___0 == 121) {
#line 563
        goto case_69;
      }
#line 572
      if ((int const   )*p___0 == 65) {
#line 572
        goto case_65;
      }
#line 572
      if ((int const   )*p___0 == 97) {
#line 572
        goto case_65;
      }
#line 569
      goto switch_default;
      case_13: /* CIL Label */ 
      case_12: /* CIL Label */ 
      case_11: /* CIL Label */ 
      case_10: /* CIL Label */ 
      case_9: /* CIL Label */ 
      case_32: /* CIL Label */ 
#line 560
      goto __Cont;
      case_79: /* CIL Label */ 
      case_111: /* CIL Label */ 
      {
#line 562
      tmp___0 = strnIcmp(p___0 + 1, "n", (size_t )1);
      }
#line 562
      if (tmp___0) {
        {
#line 565
        tmp = strnIcmp(p___0 + 1, "ff", (size_t )2);
        }
#line 565
        if (tmp) {
          switch_default: /* CIL Label */ 
#line 570
          t___1 = (long )i___0;
        } else {
          case_68: /* CIL Label */ 
          case_100: /* CIL Label */ 
          case_70: /* CIL Label */ 
          case_102: /* CIL Label */ 
          case_78: /* CIL Label */ 
          case_110: /* CIL Label */ 
#line 567
          t___1 = 0L;
        }
      } else {
        case_69: /* CIL Label */ 
        case_101: /* CIL Label */ 
        case_84: /* CIL Label */ 
        case_116: /* CIL Label */ 
        case_89: /* CIL Label */ 
        case_121: /* CIL Label */ 
#line 564
        t___1 = 1L;
      }
#line 571
      goto switch_break;
      case_65: /* CIL Label */ 
      case_97: /* CIL Label */ 
#line 572
      t___1 = 2L;
#line 573
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 575
      goto while_break;
      __Cont: /* CIL Label */ 
#line 557
      p___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 577
  return (t___1);
}
}
#line 580 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
void squeeze(char *target ) 
{ 
  int state ;
  char *src ;
  char tmp ;

  {
#line 582
  state = 0;
#line 582
  src = target;
  {
#line 582
  while (1) {
    while_continue: /* CIL Label */ ;
#line 583
    tmp = *src;
#line 583
    *target = tmp;
    {
#line 584
    if ((int )tmp == 10) {
#line 584
      goto case_10;
    }
#line 589
    if ((int )tmp == 92) {
#line 589
      goto case_92;
    }
#line 591
    if ((int )tmp == 9) {
#line 591
      goto case_9;
    }
#line 591
    if ((int )tmp == 32) {
#line 591
      goto case_9;
    }
#line 598
    if ((int )tmp == 0) {
#line 598
      goto case_0;
    }
#line 596
    goto switch_default;
    case_10: /* CIL Label */ 
#line 585
    if (state == 1) {
#line 586
      target -= 2;
    }
#line 587
    state = 2;
#line 588
    goto __Cont;
    case_92: /* CIL Label */ 
#line 589
    state = 1;
#line 590
    goto __Cont;
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 592
    if (state == 2) {
#line 593
      target --;
#line 594
      goto __Cont;
    }
    switch_default: /* CIL Label */ 
#line 596
    state = 0;
#line 597
    goto __Cont;
    case_0: /* CIL Label */ ;
    switch_break: /* CIL Label */ ;
    }
#line 600
    goto while_break;
    __Cont: /* CIL Label */ 
#line 582
    target ++;
#line 582
    src ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 602
  return;
}
}
#line 604 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
char *egrepin(char *expr , char const   *source , long const   len , int casesens ) 
{ 
  size_t tmp ;
  struct eps *tmp___0 ;
  char *tmp___1 ;

  {
#line 606
  if (*expr) {
#line 607
    if (len > 0L) {
#line 607
      tmp = (size_t )len;
    } else {
#line 607
      tmp = (size_t )0;
    }
    {
#line 607
    tmp___0 = bregcomp((char const   */* const  */)expr, (unsigned int const   )(! casesens));
#line 607
    expr = (char *)tmp___0;
#line 607
    tmp___1 = bregexec((struct eps *)expr, (uschar const   *)source, (uschar const   *)source,
                       tmp, ! casesens);
#line 607
    source = (char const   *)tmp___1;
#line 610
    tfree((void */* const  */)expr);
    }
  }
#line 612
  return ((char *)source);
}
}
#line 615 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
int enoughprivs(auth_identity const   * const  passinvk , uid_t const   euid , gid_t const   egid ,
                uid_t const   uid___0 , gid_t const   gid___0 ) 
{ 
  uid_t tmp ;
  int tmp___0 ;

  {
#line 617
  if (euid == 0U) {
#line 617
    tmp___0 = 1;
  } else
#line 617
  if (passinvk) {
    {
#line 617
    tmp = auth_whatuid(passinvk);
    }
#line 617
    if (tmp == (uid_t )uid___0) {
#line 617
      tmp___0 = 1;
    } else {
#line 617
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 617
  if (euid == uid___0) {
#line 617
    if (egid == gid___0) {
#line 617
      tmp___0 = 1;
    } else {
#line 617
      tmp___0 = 0;
    }
  } else {
#line 617
    tmp___0 = 0;
  }
#line 617
  return (tmp___0);
}
}
#line 622 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
void initdefenv(void) 
{ 
  int i___0 ;
  int tmp ;

  {
#line 623
  i___0 = (int )(sizeof(strenstr) / sizeof(strenstr[0]) - 1UL);
  {
#line 624
  while (1) {
    while_continue: /* CIL Label */ ;
#line 625
    if (*(strenstr[i___0].sval)) {
      {
#line 626
      setdef(strenstr[i___0].sname, (char const   */* const  */)strenstr[i___0].sval);
      }
    }
#line 624
    tmp = i___0;
#line 624
    i___0 --;
#line 624
    if (! tmp) {
#line 624
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 628
  return;
}
}
#line 630 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
char const   *newdynstring(struct dynstring ** const  adrp , char const   * const  chp ) 
{ 
  struct dynstring *curr ;
  size_t len ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 633
  tmp = strlen((char const   *)chp);
#line 633
  len = tmp + 1UL;
#line 633
  tmp___0 = tmalloc((size_t )((int )((unsigned long )(& ((struct dynstring *)0)->ename[0]))) + len);
#line 633
  curr = (struct dynstring *)tmp___0;
#line 634
  memmove((void *)(curr->ename), (void const   *)chp, len);
#line 634
  curr->enext = *adrp;
#line 634
  *adrp = curr;
  }
#line 635
  return ((char const   *)(curr->ename));
}
}
#line 638 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
void rcst_nosgid(void) 
{ 


  {
#line 639
  if (! rcstate) {
#line 640
    rcstate = 1;
  }
#line 641
  return;
}
}
#line 647 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
static char const   suppressed[13]  = 
#line 647
  {      (char const   )' ',      (char const   )'s',      (char const   )'u',      (char const   )'p', 
        (char const   )'p',      (char const   )'r',      (char const   )'e',      (char const   )'s', 
        (char const   )'s',      (char const   )'e',      (char const   )'d',      (char const   )'\n', 
        (char const   )'\000'};
#line 761 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
static struct __anonstruct_regsp_63  const  *regsp  ;
#line 761 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
static struct __anonstruct_regsp_63  const  regs[5]  = {      {"^FROM_DAEMON", "(^(Mailing-List:|Precedence:.*(junk|bulk|list)|To: Multiple recipients of |(((Resent-)?(From|Sender)|X-Envelope-From):|>?From )([^>]*[^(.%@a-z0-9])?(Post(ma?(st(e?r)?|n)|office)|(send)?Mail(er)?|daemon|m(mdf|ajordomo)|n?uucp|LIST(SERV|proc)|NETSERV|o(wner|ps)|r(e(quest|sponse)|oot)|b(ounce|bs\\.smtp)|echo|mirror|s(erv(ices?|er)|mtp(error)?|ystem)|A(dmin(istrator)?|MMGR|utoanswer))(([^).!:a-z0-9][-_a-z0-9]*)?[%@>\t ][^<)]*(\\(.*\\).*)?)?$([^>]|$)))"}, 
        {"^TO_",
      "(^((Original-)?(Resent-)?(To|Cc|Bcc)|(X-Envelope|Apparently(-Resent)?)-To):(.*[^-a-zA-Z0-9_.])?)"}, 
        {"^TO",
      "(^((Original-)?(Resent-)?(To|Cc|Bcc)|(X-Envelope|Apparently(-Resent)?)-To):(.*[^a-zA-Z])?)"}, 
        {"^FROM_MAILER",
      "(^(((Resent-)?(From|Sender)|X-Envelope-From):|>?From )([^>]*[^(.%@a-z0-9])?(Post(ma(st(er)?|n)|office)|(send)?Mail(er)?|daemon|mmdf|n?uucp|ops|r(esponse|oot)|(bbs\\.)?smtp(error)?|s(erv(ices?|er)|ystem)|A(dmin(istrator)?|MMGR))(([^).!:a-z0-9][-_a-z0-9]*)?[%@>\t ][^<)]*(\\(.*\\).*)?)?$([^>]|$))"}, 
        {(char const   *)0,
      (char const   *)0}};
#line 644 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/misc.c"
int conditions(char *flags___0 , int const   prevcond , int const   lastsucc , int const   lastcond ,
               int nrcond ) 
{ 
  char *chp ;
  char *chp2 ;
  char *startchar ;
  double score ;
  int scored ;
  int i___0 ;
  int skippedempty ;
  long tobesent ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int negate ;
  int scoreany ;
  double weight ;
  double xponent ;
  double lscore ;
  char *lstartchar ;
  long ltobesent ;
  long sizecheck ;
  char *chp3 ;
  double w ;
  double x ;
  long tmp___8 ;
  char *chp3___0 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char const   *tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int or_nocase ;
  size_t lregs ;
  size_t lregk ;
  size_t tmp___16 ;
  int igncase ;
  int tmp___17 ;
  struct eps *re ;
  char *tmp___18 ;
  double oweight ;
  long tmp___19 ;
  long tmp___20 ;
  long tmp___21 ;
  double volatile   nweight ;
  long tmp___22 ;
  long tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  char *tmp___27 ;
  int j ;
  long tmp___28 ;
  long tmp___29 ;
  double tmp___30 ;
  long pivot ;
  int tmp___31 ;
  char *chp3___1 ;
  char *tmp___32 ;
  double f ;
  double tmp___33 ;
  int tmp___34 ;
  long tmp___35 ;
  long tmp___36 ;
  long tmp___37 ;
  char num[(((8UL * sizeof(long )) * 4UL) / 10UL + 1UL) + 1UL] ;
  long iscore ;
  char const   *tmp___38 ;

  {
#line 648
  scored = 0;
#line 648
  score = (double )scored;
#line 649
  if (nrcond < 0) {
#line 650
    if (! *(flags___0 + 3)) {
#line 650
      if (! *(flags___0 + 4)) {
#line 650
        if (! *(flags___0 + 12)) {
#line 650
          if (! *(flags___0 + 13)) {
#line 650
            tmp = 1;
          } else {
#line 650
            tmp = 0;
          }
        } else {
#line 650
          tmp = 0;
        }
      } else {
#line 650
        tmp = 0;
      }
    } else {
#line 650
      tmp = 0;
    }
#line 650
    nrcond = tmp;
  }
#line 652
  startchar = themail;
#line 652
  tobesent = thebody - themail;
#line 653
  if (*(flags___0 + 1)) {
#line 654
    if (*(flags___0 + 0)) {
#line 655
      tobesent = filled;
    } else {
#line 657
      startchar = thebody;
#line 657
      tobesent = filled - tobesent;
#line 658
      goto noconcat;
    }
  }
#line 660
  if (! skiprc) {
    {
#line 661
    concon((int const   )' ');
    }
  }
  noconcat: 
#line 663
  i___0 = ! skiprc;
#line 664
  if (*(flags___0 + 13)) {
#line 665
    if (prevcond) {
#line 665
      if (! lastsucc) {
#line 665
        tmp___0 = 1;
      } else {
#line 665
        tmp___0 = 0;
      }
    } else {
#line 665
      tmp___0 = 0;
    }
#line 665
    i___0 &= tmp___0;
#line 666
    if (*(flags___0 + 12)) {
      {
#line 667
      nlog((char const   */* const  */)(conflicting));
#line 667
      elog((char const   */* const  */)"else-if-flag");
#line 667
      elog((char const   */* const  */)(suppressed));
#line 667
      *(flags___0 + 12) = (char)0;
      }
    }
#line 669
    if (*(flags___0 + 4)) {
      {
#line 670
      nlog((char const   */* const  */)(conflicting));
#line 670
      elog((char const   */* const  */)"also-if-succeeded-flag");
#line 670
      elog((char const   */* const  */)(suppressed));
#line 670
      *(flags___0 + 4) = (char)0;
      }
    }
  }
#line 673
  if (*(flags___0 + 12)) {
#line 674
    i___0 &= ! prevcond;
  }
#line 675
  if (*(flags___0 + 4)) {
#line 676
    if (lastcond) {
#line 676
      if (lastsucc) {
#line 676
        tmp___1 = 1;
      } else {
#line 676
        tmp___1 = 0;
      }
    } else {
#line 676
      tmp___1 = 0;
    }
#line 676
    i___0 &= tmp___1;
  }
#line 677
  if (*(flags___0 + 3)) {
#line 678
    if (i___0) {
#line 678
      if (lastcond) {
#line 678
        tmp___2 = 1;
      } else {
#line 678
        tmp___2 = 0;
      }
    } else {
#line 678
      tmp___2 = 0;
    }
#line 678
    i___0 = tmp___2;
  }
#line 679
  skippedempty = 0;
  {
#line 679
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 680
    skipspace();
#line 680
    nrcond --;
#line 681
    tmp___6 = testB((int const   )'*');
    }
#line 681
    if (! tmp___6) {
#line 682
      if (nrcond < 0) {
        {
#line 683
        tmp___3 = testB((int const   )'#');
        }
#line 683
        if (tmp___3) {
          {
#line 684
          skipline();
          }
#line 685
          goto __Cont;
        }
        {
#line 687
        tmp___4 = testB((int const   )'\n');
        }
#line 687
        if (tmp___4) {
#line 688
          skippedempty = 1;
#line 689
          goto __Cont;
        }
#line 691
        if (skippedempty) {
          {
#line 691
          tmp___5 = testB((int const   )':');
          }
#line 691
          if (tmp___5) {
            {
#line 692
            nlog((char const   */* const  */)"Missing action\n");
#line 692
            i___0 = 2;
            }
#line 693
            goto ret;
          }
        }
#line 695
        goto while_break;
      }
    }
    {
#line 697
    skipspace();
#line 698
    tmp___7 = getlline(buf2, buf2 + linebuf);
    }
#line 698
    if (tmp___7) {
#line 699
      i___0 = 0;
    }
#line 700
    if (i___0) {
      {
#line 702
      lstartchar = startchar;
#line 702
      ltobesent = tobesent;
#line 702
      sizecheck = filled;
#line 703
      chp = strchr((char const   *)buf2, '\000');
      }
      {
#line 703
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 703
        chp --;
#line 703
        if (! ((unsigned long )chp >= (unsigned long )buf2)) {
#line 703
          goto while_break___0;
        }
        {
#line 705
        if ((int )*chp == 9) {
#line 705
          goto case_9;
        }
#line 705
        if ((int )*chp == 32) {
#line 705
          goto case_9;
        }
#line 704
        goto switch_break;
        case_9: /* CIL Label */ 
        case_32: /* CIL Label */ 
#line 705
        *chp = (char )'\000';
#line 706
        goto __Cont___0;
        switch_break: /* CIL Label */ ;
        }
#line 708
        goto while_break___0;
        __Cont___0: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 710
      scoreany = 0;
#line 710
      negate = scoreany;
#line 710
      lscore = score;
#line 711
      chp = buf2 + 1;
      {
#line 711
      while (1) {
        while_continue___1: /* CIL Label */ ;
        copydone: 
#line 712
        sgetcp = (char const   *)buf2;
        {
#line 714
        if ((int const   )*sgetcp == 44) {
#line 714
          goto case_44;
        }
#line 714
        if ((int const   )*sgetcp == 46) {
#line 714
          goto case_44;
        }
#line 714
        if ((int const   )*sgetcp == 43) {
#line 714
          goto case_44;
        }
#line 714
        if ((int const   )*sgetcp == 45) {
#line 714
          goto case_44;
        }
#line 714
        if ((int const   )*sgetcp == 57) {
#line 714
          goto case_44;
        }
#line 714
        if ((int const   )*sgetcp == 56) {
#line 714
          goto case_44;
        }
#line 714
        if ((int const   )*sgetcp == 55) {
#line 714
          goto case_44;
        }
#line 714
        if ((int const   )*sgetcp == 54) {
#line 714
          goto case_44;
        }
#line 714
        if ((int const   )*sgetcp == 53) {
#line 714
          goto case_44;
        }
#line 714
        if ((int const   )*sgetcp == 52) {
#line 714
          goto case_44;
        }
#line 714
        if ((int const   )*sgetcp == 51) {
#line 714
          goto case_44;
        }
#line 714
        if ((int const   )*sgetcp == 50) {
#line 714
          goto case_44;
        }
#line 714
        if ((int const   )*sgetcp == 49) {
#line 714
          goto case_44;
        }
#line 714
        if ((int const   )*sgetcp == 48) {
#line 714
          goto case_44;
        }
#line 759
        if ((int const   )*sgetcp == 92) {
#line 759
          goto normalregexp;
        }
#line 828
        if ((int const   )*sgetcp == 36) {
#line 828
          goto case_36;
        }
#line 833
        if ((int const   )*sgetcp == 33) {
#line 833
          goto case_33;
        }
#line 836
        if ((int const   )*sgetcp == 63) {
#line 836
          goto case_63;
        }
#line 850
        if ((int const   )*sgetcp == 60) {
#line 850
          goto case_60;
        }
#line 850
        if ((int const   )*sgetcp == 62) {
#line 850
          goto case_60;
        }
#line 731
        goto switch_default;
        case_44: /* CIL Label */ 
        case_46: /* CIL Label */ 
        case_43: /* CIL Label */ 
        case_45: /* CIL Label */ 
        case_57: /* CIL Label */ 
        case_56: /* CIL Label */ 
        case_55: /* CIL Label */ 
        case_54: /* CIL Label */ 
        case_53: /* CIL Label */ 
        case_52: /* CIL Label */ 
        case_51: /* CIL Label */ 
        case_50: /* CIL Label */ 
        case_49: /* CIL Label */ 
        case_48: /* CIL Label */ 
        {
#line 716
        w = stod((char const   *)buf2, (char const   **/* const  */)((char const   **)(& chp3)));
#line 716
        chp2 = chp3;
        }
#line 717
        if ((unsigned long )chp2 > (unsigned long )buf2) {
          {
#line 717
          chp2 = skpspace((char const   *)chp2);
          }
#line 717
          if ((int )*chp2 == 94) {
            {
#line 719
            x = stod((char const   *)(chp2 + 1), (char const   **/* const  */)((char const   **)(& chp3)));
            }
#line 720
            if ((unsigned long )chp3 > (unsigned long )(chp2 + 1)) {
#line 721
              if ((long )(0xffffffffffffffffUL >> 1) > 2147483647L) {
#line 721
                tmp___8 = 2147483647L;
              } else {
#line 721
                tmp___8 = (long )(0xffffffffffffffffUL >> 1);
              }
#line 721
              if (score >= (double )tmp___8) {
#line 722
                goto skiptrue;
              }
              {
#line 723
              xponent = x;
#line 723
              weight = w;
#line 723
              scoreany = 1;
#line 723
              scored = scoreany;
#line 724
              chp2 = skpspace((char const   *)chp3);
              }
#line 725
              goto copyrest;
            }
          }
        }
#line 728
        chp --;
#line 729
        goto normalregexp;
        switch_default: /* CIL Label */ 
        {
#line 731
        chp --;
#line 732
        chp2 = chp;
#line 732
        tmp___15 = alphanum((unsigned int const   )*chp2);
        }
#line 732
        if (tmp___15) {
          {
#line 734
          while (1) {
            while_continue___2: /* CIL Label */ ;
            {
#line 734
            chp2 ++;
#line 734
            tmp___9 = alphanum((unsigned int const   )*chp2);
            }
#line 734
            if (! tmp___9) {
#line 734
              goto while_break___2;
            }
          }
          while_break___2: /* CIL Label */ ;
          }
          {
#line 735
          chp3___0 = skpspace((char const   *)chp2);
#line 735
          tmp___14 = strncmp((char const   *)chp3___0, "??", (size_t )2);
          }
#line 735
          if (! tmp___14) {
#line 736
            *chp2 = (char )'\000';
#line 736
            lstartchar = themail;
#line 737
            if (! *(chp + 1)) {
#line 738
              ltobesent = thebody - themail;
              {
#line 740
              if ((int )*chp == 66) {
#line 740
                goto case_66;
              }
#line 743
              if ((int )*chp == 72) {
#line 743
                goto case_72;
              }
#line 739
              goto switch_break___1;
              case_66: /* CIL Label */ 
#line 740
              lstartchar = thebody;
#line 741
              ltobesent = filled - ltobesent;
#line 742
              goto partition;
              case_72: /* CIL Label */ 
#line 744
              goto docon;
              switch_break___1: /* CIL Label */ ;
              }
            } else {
              {
#line 747
              tmp___10 = strcmp("HB", (char const   *)chp);
              }
#line 747
              if (tmp___10) {
                {
#line 747
                tmp___11 = strcmp("BH", (char const   *)chp);
                }
#line 747
                if (! tmp___11) {
                  _L: /* CIL Label */ 
#line 749
                  ltobesent = filled;
                  docon: 
                  {
#line 750
                  concon((int const   )' ');
                  }
#line 751
                  goto partition;
                }
              } else {
#line 747
                goto _L;
              }
            }
            {
#line 753
            tmp___12 = tgetenv((char const   */* const  */)chp);
#line 753
            lstartchar = (char *)tmp___12;
#line 753
            tmp___13 = strlen((char const   *)lstartchar);
#line 753
            ltobesent = (long )tmp___13;
            }
            partition: 
            {
#line 754
            chp2 = skpspace((char const   *)(chp3___0 + 2));
#line 754
            chp ++;
#line 754
            sizecheck = ltobesent;
            }
#line 755
            goto copyrest;
          }
        }
        normalregexp: 
        case_92: /* CIL Label */ 
        {
#line 769
        squeeze(chp);
#line 769
        or_nocase = 0;
        }
#line 770
        goto jinregs;
        {
#line 771
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 772
          chp2 = strstr((char const   *)chp, (char const   *)regsp->regkey);
          }
#line 772
          if (chp2) {
#line 772
            if ((unsigned long )chp2 == (unsigned long )buf2) {
#line 772
              goto _L___0;
            } else
#line 772
            if ((int )*(chp2 + -1) != 92) {
              _L___0: /* CIL Label */ 
              {
#line 775
              lregk = strlen((char const   *)regsp->regkey);
#line 776
              tmp___16 = strlen((char const   *)chp2);
#line 776
              lregs = strlen((char const   *)regsp->regsubst);
#line 776
              memmove((void *)(chp2 + lregs), (void const   *)(chp2 + lregk), (tmp___16 - lregk) + 1UL);
#line 778
              memmove((void *)chp2, (void const   *)regsp->regsubst, lregs);
              }
#line 779
              if ((unsigned long )regsp == (unsigned long )(regs)) {
#line 780
                or_nocase = 1;
              }
              jinregs: 
#line 781
              regsp = regs;
            } else {
#line 784
              regsp ++;
            }
          } else {
#line 784
            regsp ++;
          }
#line 771
          if (! regsp->regkey) {
#line 771
            goto while_break___3;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 787
        if (or_nocase) {
#line 787
          tmp___17 = 1;
        } else
#line 787
        if (! *(flags___0 + 2)) {
#line 787
          tmp___17 = 1;
        } else {
#line 787
          tmp___17 = 0;
        }
#line 787
        igncase = tmp___17;
#line 788
        if (scoreany) {
          {
#line 790
          re = bregcomp((char const   */* const  */)chp, (unsigned int const   )igncase);
#line 790
          chp = lstartchar;
          }
#line 791
          if (negate) {
#line 792
            if (weight) {
              {
#line 792
              tmp___18 = bregexec(re, (uschar const   *)chp, (uschar const   *)chp,
                                  (size_t )ltobesent, igncase);
              }
#line 792
              if (! tmp___18) {
#line 794
                score += weight;
              }
            }
          } else {
#line 797
            oweight = weight * weight;
            {
#line 798
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 798
              if (weight != (double )0) {
#line 798
                if ((long )(0xffffffffffffffffUL >> 1) > 2147483647L) {
#line 798
                  tmp___22 = 2147483647L;
                } else {
#line 798
                  tmp___22 = (long )(0xffffffffffffffffUL >> 1);
                }
#line 798
                if ((double )(- tmp___22) < score) {
#line 798
                  if ((long )(0xffffffffffffffffUL >> 1) > 2147483647L) {
#line 798
                    tmp___23 = 2147483647L;
                  } else {
#line 798
                    tmp___23 = (long )(0xffffffffffffffffUL >> 1);
                  }
#line 798
                  if (score < (double )tmp___23) {
#line 798
                    if (ltobesent >= 0L) {
                      {
#line 798
                      chp2 = bregexec(re, (uschar const   *)lstartchar, (uschar const   *)chp,
                                      (size_t )ltobesent, igncase);
                      }
#line 798
                      if (! chp2) {
#line 798
                        goto while_break___4;
                      }
                    } else {
#line 798
                      goto while_break___4;
                    }
                  } else {
#line 798
                    goto while_break___4;
                  }
                } else {
#line 798
                  goto while_break___4;
                }
              } else {
#line 798
                goto while_break___4;
              }
#line 805
              score += weight;
#line 805
              weight *= xponent;
#line 806
              if ((unsigned long )chp >= (unsigned long )chp2) {
#line 807
                if ((double )0 < xponent) {
#line 807
                  if (xponent < (double )1) {
#line 808
                    score += weight / ((double )1 - xponent);
                  } else {
#line 807
                    goto _L___1;
                  }
                } else
                _L___1: /* CIL Label */ 
#line 809
                if (xponent >= (double )1) {
#line 809
                  if (weight != (double )0) {
#line 810
                    if (weight < (double )0) {
#line 810
                      if ((long )(0xffffffffffffffffUL >> 1) > 2147483647L) {
#line 810
                        tmp___19 = 2147483647L;
                      } else {
#line 810
                        tmp___19 = (long )(0xffffffffffffffffUL >> 1);
                      }
#line 810
                      tmp___21 = - tmp___19;
                    } else {
#line 810
                      if ((long )(0xffffffffffffffffUL >> 1) > 2147483647L) {
#line 810
                        tmp___20 = 2147483647L;
                      } else {
#line 810
                        tmp___20 = (long )(0xffffffffffffffffUL >> 1);
                      }
#line 810
                      tmp___21 = tmp___20;
                    }
#line 810
                    score += (double )tmp___21;
                  }
                }
#line 811
                goto while_break___4;
              }
#line 813
              nweight = (double volatile   )(weight * weight);
#line 814
              if (nweight < (double volatile   )oweight) {
#line 814
                if (oweight < (double )1) {
#line 815
                  goto while_break___4;
                }
              }
#line 816
              oweight = (double )nweight;
#line 818
              ltobesent -= chp2 - chp;
#line 818
              chp = chp2;
            }
            while_break___4: /* CIL Label */ ;
            }
          }
          {
#line 821
          tfree((void */* const  */)re);
          }
        } else {
          {
#line 824
          tmp___24 = egrepin(chp, (char const   *)lstartchar, (long const   )ltobesent,
                             ! igncase);
          }
#line 824
          if (tmp___24) {
#line 824
            tmp___25 = 1;
          } else {
#line 824
            tmp___25 = 0;
          }
#line 824
          i___0 = tmp___25 ^ negate;
        }
#line 826
        goto switch_break___0;
        case_36: /* CIL Label */ 
        {
#line 828
        *buf2 = (char )'\"';
#line 828
        squeeze(chp);
#line 829
        tmp___26 = readparse(buf, (int (*/* const  */)())(& sgetc), (int const   )2);
        }
#line 829
        if (tmp___26) {
#line 829
          i___0 = 0;
#line 830
          goto switch_break___0;
        }
        {
#line 831
        tmp___27 = skpspace((char const   *)buf);
#line 831
        strcpy((char */* __restrict  */)buf2, (char const   */* __restrict  */)tmp___27);
        }
#line 832
        goto copydone;
        case_33: /* CIL Label */ 
        {
#line 833
        negate ^= 1;
#line 833
        chp2 = skpspace((char const   *)chp);
        }
        copyrest: 
        {
#line 834
        strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)chp2);
        }
#line 835
        goto __Cont___1;
        case_63: /* CIL Label */ 
        {
#line 836
        pwait = 2;
#line 836
        metaparse((char const   *)chp);
#line 836
        inittmout((char const   */* const  */)buf);
#line 836
        ignwerr = 1;
#line 837
        pipin((char */* const  */)buf, lstartchar, ltobesent);
        }
#line 838
        if (scoreany) {
#line 838
          if (lexitcode >= 0) {
#line 839
            j = lexitcode;
#line 840
            if (negate) {
              {
#line 841
              while (1) {
                while_continue___5: /* CIL Label */ ;
#line 841
                j --;
#line 841
                if (j >= 0) {
#line 841
                  score += weight;
#line 841
                  if ((long )(0xffffffffffffffffUL >> 1) > 2147483647L) {
#line 841
                    tmp___28 = 2147483647L;
                  } else {
#line 841
                    tmp___28 = (long )(0xffffffffffffffffUL >> 1);
                  }
#line 841
                  if (score < (double )tmp___28) {
#line 841
                    if ((long )(0xffffffffffffffffUL >> 1) > 2147483647L) {
#line 841
                      tmp___29 = 2147483647L;
                    } else {
#line 841
                      tmp___29 = (long )(0xffffffffffffffffUL >> 1);
                    }
#line 841
                    if (! (score > (double )(- tmp___29))) {
#line 841
                      goto while_break___5;
                    }
                  } else {
#line 841
                    goto while_break___5;
                  }
                } else {
#line 841
                  goto while_break___5;
                }
#line 842
                weight *= xponent;
              }
              while_break___5: /* CIL Label */ ;
              }
            } else {
#line 844
              if (j) {
#line 844
                tmp___30 = xponent;
              } else {
#line 844
                tmp___30 = weight;
              }
#line 844
              score += tmp___30;
            }
          } else {
#line 838
            goto _L___2;
          }
        } else
        _L___2: /* CIL Label */ 
#line 846
        if (! (! lexitcode) ^ negate) {
#line 847
          i___0 = 0;
        }
        {
#line 848
        strcpy((char */* __restrict  */)buf2, (char const   */* __restrict  */)buf);
        }
#line 849
        goto switch_break___0;
        case_60: /* CIL Label */ 
        case_62: /* CIL Label */ 
        {
#line 852
        tmp___31 = readparse(buf, (int (*/* const  */)())(& sgetc), (int const   )2);
        }
#line 852
        if (tmp___31) {
#line 852
          i___0 = 0;
#line 853
          goto switch_break___0;
        }
        {
#line 855
        pivot = strtol((char const   */* __restrict  */)(buf + 1), (char **/* __restrict  */)(& chp3___1),
                       10);
#line 855
        chp = chp3___1;
#line 857
        tmp___32 = skpspace((char const   *)chp);
#line 857
        skipped((char const   */* const  */)tmp___32);
#line 857
        strcpy((char */* __restrict  */)buf2, (char const   */* __restrict  */)buf);
        }
#line 858
        if (scoreany) {
#line 860
          if (((int )*buf == 60) ^ negate) {
#line 861
            if (sizecheck) {
#line 862
              f = (double )pivot / (double )sizecheck;
            } else
#line 863
            if (pivot > 0L) {
#line 864
              goto plusinfty;
            } else {
#line 866
              goto mininfty;
            }
          } else
#line 867
          if (pivot) {
#line 868
            f = (double )sizecheck / (double )pivot;
          } else {
#line 870
            goto plusinfty;
          }
          {
#line 871
          tmp___33 = pow(f, xponent);
#line 871
          score += weight * tmp___33;
          }
        } else {
#line 873
          if ((int )*buf == 60) {
#line 873
            tmp___34 = sizecheck < pivot;
          } else {
#line 873
            tmp___34 = sizecheck > pivot;
          }
#line 873
          if (! (tmp___34 ^ negate)) {
#line 875
            i___0 = 0;
          }
        }
        switch_break___0: /* CIL Label */ ;
        }
#line 878
        goto while_break___1;
        __Cont___1: /* CIL Label */ 
        {
#line 711
        strcpy((char */* __restrict  */)buf2, (char const   */* __restrict  */)buf);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 880
      if ((long )(0xffffffffffffffffUL >> 1) > 2147483647L) {
#line 880
        tmp___35 = 2147483647L;
      } else {
#line 880
        tmp___35 = (long )(0xffffffffffffffffUL >> 1);
      }
#line 880
      if (score > (double )tmp___35) {
        plusinfty: 
#line 881
        if ((long )(0xffffffffffffffffUL >> 1) > 2147483647L) {
#line 881
          score = (double )2147483647L;
        } else {
#line 881
          score = (double )((long )(0xffffffffffffffffUL >> 1));
        }
      }
#line 882
      if ((long )(0xffffffffffffffffUL >> 1) > 2147483647L) {
#line 882
        tmp___37 = 2147483647L;
      } else {
#line 882
        tmp___37 = (long )(0xffffffffffffffffUL >> 1);
      }
#line 882
      if (score <= (double )(- tmp___37)) {
        mininfty: 
#line 883
        if ((long )(0xffffffffffffffffUL >> 1) > 2147483647L) {
#line 883
          tmp___36 = 2147483647L;
        } else {
#line 883
          tmp___36 = (long )(0xffffffffffffffffUL >> 1);
        }
#line 883
        score = (double )(- tmp___36);
#line 883
        i___0 = 0;
      }
#line 884
      if (*((long volatile   *)(& strenvvar[5].val))) {
#line 885
        if (scoreany) {
          {
#line 887
          nlog((char const   */* const  */)"Score: ");
#line 887
          ltstr((int const   )7, (long const   )((long )(score - lscore)), num);
#line 888
          elog((char const   */* const  */)(num));
#line 888
          elog((char const   */* const  */)" ");
#line 889
          iscore = (long )score;
#line 890
          ltstr((int const   )7, (long const   )iscore, num);
          }
#line 891
          if (! iscore) {
#line 891
            if (score > (double )0) {
#line 892
              num[5] = (char )'+';
            }
          }
          {
#line 894
          elog((char const   */* const  */)(num));
          }
        } else {
#line 897
          if (i___0) {
#line 897
            tmp___38 = "M";
          } else {
#line 897
            tmp___38 = "No m";
          }
          {
#line 897
          nlog((char const   */* const  */)tmp___38);
#line 897
          elog((char const   */* const  */)"atch on");
          }
        }
#line 898
        if (negate) {
          {
#line 899
          elog((char const   */* const  */)" !");
          }
        }
        {
#line 900
        logqnl((char const   */* const  */)buf2);
        }
      }
      skiptrue: ;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 905
  lastscore = (long )score;
#line 905
  if (! lastscore) {
#line 905
    if (score > (double )0) {
#line 906
      lastscore = 1L;
    }
  }
#line 907
  if (scored) {
#line 907
    if (i___0) {
#line 907
      if (score <= (double )0) {
#line 908
        i___0 = 0;
      }
    }
  }
  ret: 
#line 910
  return (i___0);
}
}
#line 563 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execv)(char const   *__path ,
                                                                                              char * const  *__argv ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
#line 102 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/common.c"
void shexec(char const   * const  *argv ) 
{ 
  int i___0 ;
  char **newargv ;
  char const   **p___0 ;
  char const   **tmp ;
  void *tmp___0 ;
  char const   *tmp___1 ;
  char const   * const  *tmp___2 ;

  {
  {
#line 21
  signal(24, (void (*)(int  ))0);
#line 21
  signal(25, (void (*)(int  ))0);
#line 26
  signal(13, (void (*)(int  ))0);
#line 26
  execvp((char const   *)*argv, (char * const  *)argv);
#line 27
  p___0 = (char const   **)argv;
#line 27
  i___0 = 1;
  }
  {
#line 27
  while (1) {
    while_continue: /* CIL Label */ ;
#line 27
    i___0 ++;
#line 27
    tmp = p___0;
#line 27
    p___0 ++;
#line 27
    if (! *tmp) {
#line 27
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 28
  tmp___0 = tmalloc((unsigned long )i___0 * sizeof(*p___0));
#line 28
  newargv = (char **)tmp___0;
#line 29
  p___0 = (char const   **)newargv;
#line 29
  *p___0 = binsh;
  }
  {
#line 29
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 29
    p___0 ++;
#line 29
    tmp___2 = argv;
#line 29
    argv ++;
#line 29
    tmp___1 = (char const   *)*tmp___2;
#line 29
    *p___0 = tmp___1;
#line 29
    if (! tmp___1) {
#line 29
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 30
  execv((char const   *)*newargv, (char * const  *)newargv);
#line 30
  tfree((void */* const  */)newargv);
#line 30
  nlog((char const   */* const  */)"Failed to execute");
#line 31
  logqnl(*argv);
#line 32
  exit(69);
  }
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/common.c"
void detab(char *p___0 ) 
{ 


  {
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 36
    p___0 = strpbrk((char const   *)p___0, "\t\n\v\f\r");
    }
#line 36
    if (! p___0) {
#line 36
      goto while_break;
    }
#line 37
    *p___0 = (char )' ';
  }
  while_break: /* CIL Label */ ;
  }
#line 38
  return;
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/common.c"
char *skpspace(char const   *chp ) 
{ 


  {
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 43
    if ((int const   )*chp == 9) {
#line 43
      goto case_9;
    }
#line 43
    if ((int const   )*chp == 32) {
#line 43
      goto case_9;
    }
#line 45
    goto switch_default;
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 44
    goto __Cont;
    switch_default: /* CIL Label */ 
#line 46
    return ((char *)chp);
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 41
    chp ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/common.c"
void ultstr(int minwidth , unsigned long val , char *dest ) 
{ 
  int i___0 ;
  unsigned long j ;
  char *tmp ;

  {
#line 62
  j = val;
#line 62
  i___0 = 0;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    i___0 ++;
#line 63
    j /= 10UL;
#line 63
    if (! j) {
#line 63
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 65
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 65
    minwidth --;
#line 65
    if (! (minwidth >= i___0)) {
#line 65
      goto while_break___0;
    }
#line 66
    tmp = dest;
#line 66
    dest ++;
#line 66
    *tmp = (char )' ';
  }
  while_break___0: /* CIL Label */ ;
  }
#line 67
  dest += i___0;
#line 67
  *dest = (char )'\000';
  {
#line 68
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 68
    dest --;
#line 68
    *dest = (char )(48UL + val % 10UL);
#line 68
    val /= 10UL;
#line 68
    if (! val) {
#line 68
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 70
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/common.c"
int waitfor(pid_t const   pid ) 
{ 
  int i___0 ;
  pid_t j ;
  union __anonunion_56 __constr_expr_0 ;
  union __anonunion_58 __constr_expr_2 ;
  union __anonunion_59 __constr_expr_3 ;
  union __anonunion_60 __constr_expr_4 ;

  {
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 74
    j = wait((union wait *)(& i___0));
    }
#line 74
    if (! (pid != (pid_t const   )j)) {
#line 74
      __constr_expr_0.__in = i___0;
#line 74
      if (! ((__constr_expr_0.__i & 255) == 127)) {
#line 74
        goto while_break;
      }
    }
#line 75
    if (-1 == j) {
#line 76
      return (-256);
    } else
#line 77
    if (! pid) {
#line 78
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  __constr_expr_4.__in = i___0;
#line 79
  if ((__constr_expr_4.__i & 127) == 0) {
#line 79
    __constr_expr_2.__in = i___0;
#line 79
    lexitcode = (__constr_expr_2.__i & 65280) >> 8;
  } else {
#line 79
    __constr_expr_3.__in = i___0;
#line 79
    lexitcode = - (__constr_expr_3.__i & 127);
  }
#line 79
  return (lexitcode);
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/common.c"
int strnIcmp(char const   *a , char const   *b , size_t l ) 
{ 
  unsigned int i___0 ;
  unsigned int j ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 84
  if (l) {
    {
#line 85
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 86
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 86
        if (*a) {
#line 86
          if ((int const   )*a == (int const   )*b) {
#line 86
            l --;
#line 86
            if (! l) {
#line 86
              goto while_break___0;
            }
          } else {
#line 86
            goto while_break___0;
          }
        } else {
#line 86
          goto while_break___0;
        }
#line 87
        a ++;
#line 87
        b ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 88
      if (! l) {
#line 89
        goto while_break;
      }
#line 90
      tmp = a;
#line 90
      a ++;
#line 90
      i___0 = (unsigned int )*tmp;
#line 90
      if (i___0 - 65U <= 25U) {
#line 91
        i___0 += 32U;
      }
#line 92
      tmp___0 = b;
#line 92
      b ++;
#line 92
      j = (unsigned int )*tmp___0;
#line 92
      if (j - 65U <= 25U) {
#line 93
        j += 32U;
      }
#line 94
      if (j != i___0) {
#line 95
        if (i___0 > j) {
#line 95
          tmp___1 = 1;
        } else {
#line 95
          tmp___1 = -1;
        }
#line 95
        return (tmp___1);
      }
#line 85
      if (i___0) {
#line 85
        if (j) {
#line 85
          l --;
#line 85
          if (! l) {
#line 85
            goto while_break;
          }
        } else {
#line 85
          goto while_break;
        }
      } else {
#line 85
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 98
  return (0);
}
}
#line 179 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/sublib.c"
int sublib_dummy_var  ;
#line 598 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) nice)(int __inc ) ;
#line 790
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) link)(char const   *__from ,
                                                                                             char const   *__to ) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/exopen.c"
static char const   s2c[5]  = {      (char const   )'.',      (char const   )',',      (char const   )'+',      (char const   )'%', 
        (char const   )'\000'};
#line 23 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/exopen.c"
static int serial  =    (int )(sizeof(s2c) - 1UL);
#line 24 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/exopen.c"
static time_t t  ;
#line 21 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/exopen.c"
int unique(char * const  full , char *p___0 , size_t const   len , mode_t const   mode ,
           int const   verbos , int const   chownit ) 
{ 
  char *dot ;
  char *end ;
  char *op ;
  char *ldp ;
  struct stat filebuf ;
  int nicediff ;
  int i___0 ;
  int didnice ;
  int retry ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  time_t t2 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  struct stat fdbuf ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 24
  end = (char *)(full + len);
#line 25
  retry = 8;
#line 26
  if (chownit & 1) {
    {
#line 27
    nicediff = nice(0);
#line 27
    tmp = __errno_location();
#line 27
    *tmp = 0;
#line 27
    tmp___0 = nice(-39);
#line 27
    nicediff -= tmp___0;
#line 28
    tmp___1 = __errno_location();
#line 28
    didnice = *tmp___1;
    }
  }
#line 30
  if (len) {
#line 30
    end = (char *)((full + len) - 1);
  } else {
#line 30
    end = (p___0 + 24) - 1;
  }
  {
#line 30
  *end = (char )'\000';
#line 31
  op = p___0;
#line 31
  *op = (char )'_';
#line 31
  dot = ultoan((unsigned long )((long )thepid), p___0 + 1);
  }
#line 32
  if ((unsigned long )serial < sizeof(s2c) - 1UL) {
#line 33
    goto in;
  }
  {
#line 34
  while (1) {
    while_continue: /* CIL Label */ ;
#line 35
    if ((unsigned long )serial > (sizeof(s2c) - 1UL) - 1UL) {
      {
#line 37
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 37
        t2 = time((time_t *)0);
        }
#line 37
        if (! (t == t2)) {
#line 37
          goto while_break___0;
        }
        {
#line 38
        ssleep((unsigned int const   )1);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 39
      serial = 0;
#line 39
      t = t2;
      in: 
      {
#line 41
      p___0 = ultoan((unsigned long )t, dot + 1);
#line 42
      tmp___2 = p___0;
#line 42
      p___0 ++;
#line 42
      *tmp___2 = (char )'.';
#line 43
      tmp___3 = hostname();
#line 43
      strncpy((char */* __restrict  */)p___0, (char const   */* __restrict  */)tmp___3,
              (size_t )(end - p___0));
      }
    }
    {
#line 45
    tmp___4 = serial;
#line 45
    serial ++;
#line 45
    *dot = (char )s2c[tmp___4];
#line 46
    i___0 = lstat((char const   */* __restrict  */)full, (struct stat */* __restrict  */)(& filebuf));
    }
#line 48
    if (i___0) {
      {
#line 48
      tmp___7 = __errno_location();
      }
#line 48
      if (*tmp___7 == 36) {
#line 49
        if (*op) {
#line 50
          if ((unsigned long )op != (unsigned long )full) {
            {
#line 50
            tmp___5 = strchr(dirsep, (int )*(op + -1));
            }
#line 50
            if (! tmp___5) {
              {
#line 51
              op = lastdirsep((char const   *)full);
              }
            }
          }
#line 52
          ldp = op;
#line 53
          op += 15;
#line 53
          if ((unsigned long )op > (unsigned long )end) {
#line 54
            op = end;
          }
        }
        {
#line 56
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 57
          op --;
#line 57
          *op = (char )'\000';
#line 56
          i___0 = lstat((char const   */* __restrict  */)full, (struct stat */* __restrict  */)(& filebuf));
          }
#line 56
          if (i___0) {
            {
#line 56
            tmp___6 = __errno_location();
            }
#line 56
            if (*tmp___6 == 36) {
#line 56
              if (! ((unsigned long )op > (unsigned long )ldp)) {
#line 56
                goto while_break___1;
              }
            } else {
#line 56
              goto while_break___1;
            }
          } else {
#line 56
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
#line 34
    if (! i___0) {
#line 34
      goto _L;
    } else {
      {
#line 34
      tmp___8 = __errno_location();
      }
#line 34
      if (*tmp___8 != 2) {
#line 34
        goto _L;
      } else {
        {
#line 34
        i___0 = ropen(full, 193, mode);
        }
#line 34
        if (0 > i___0) {
          {
#line 34
          tmp___9 = __errno_location();
          }
#line 34
          if (*tmp___9 == 17) {
            _L: /* CIL Label */ 
#line 34
            i___0 = -1;
#line 34
            tmp___10 = retry;
#line 34
            retry --;
#line 34
            if (! tmp___10) {
#line 34
              goto while_break;
            }
          } else {
#line 34
            goto while_break;
          }
        } else {
#line 34
          goto while_break;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 68
  if (chownit & 1) {
#line 68
    if (didnice) {
      {
#line 69
      nice(nicediff);
      }
    }
  }
#line 70
  if (i___0 < 0) {
#line 71
    if (verbos) {
      {
#line 72
      writeerr((char const   */* const  */)full);
      }
    }
#line 73
    goto ret0;
  }
#line 79
  if (chownit & 2) {
    {
#line 81
    fstat(i___0, & fdbuf);
#line 83
    tmp___12 = lstat((char const   */* __restrict  */)full, (struct stat */* __restrict  */)(& filebuf));
    }
#line 83
    if (tmp___12) {
#line 83
      goto _L___0;
    } else
#line 83
    if (filebuf.st_nlink != 1UL) {
#line 83
      goto _L___0;
    } else
#line 83
    if (filebuf.st_size) {
#line 83
      goto _L___0;
    } else
#line 83
    if (fdbuf.st_dev != filebuf.st_dev) {
#line 83
      goto _L___0;
    } else
#line 83
    if (fdbuf.st_ino != filebuf.st_ino) {
#line 83
      goto _L___0;
    } else
#line 83
    if (fdbuf.st_uid != filebuf.st_uid) {
#line 83
      goto _L___0;
    } else
#line 83
    if (fdbuf.st_gid != filebuf.st_gid) {
#line 83
      goto _L___0;
    } else
#line 83
    if (chownit & 1) {
      {
#line 83
      tmp___13 = chown((char const   *)full, uid, sgid);
      }
#line 83
      if (tmp___13) {
        _L___0: /* CIL Label */ 
        {
#line 88
        rclose((int const   )i___0);
#line 88
        unlink((char const   *)full);
        }
        ret0: 
#line 89
        if (chownit & 8) {
#line 89
          tmp___11 = -1;
        } else {
#line 89
          tmp___11 = 0;
        }
#line 89
        return (tmp___11);
      }
    }
  }
#line 92
  if (chownit & 4) {
    {
#line 93
    rwrite((int const   )i___0, (void const   */* const  */)"0", (int const   )1);
    }
  }
#line 94
  if (chownit & 8) {
#line 95
    return (i___0);
  }
  {
#line 96
  rclose((int const   )i___0);
  }
#line 97
  return (1);
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/exopen.c"
int myrename(char const   * const  old___0 , char const   * const  newn ) 
{ 
  int fd ;
  int serrno ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 102
  fd = hlink(old___0, newn);
#line 102
  tmp = __errno_location();
#line 102
  serrno = *tmp;
#line 102
  unlink((char const   *)old___0);
  }
#line 103
  if (fd > 0) {
    {
#line 103
    rclose((int const   )(fd - 1));
    }
  }
  {
#line 104
  tmp___0 = __errno_location();
#line 104
  *tmp___0 = serrno;
  }
#line 105
  if (fd < 0) {
#line 105
    tmp___1 = -1;
  } else {
#line 105
    tmp___1 = 0;
  }
#line 105
  return (tmp___1);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/exopen.c"
int rlink(char const   * const  old___0 , char const   * const  newn , struct stat *st ) 
{ 
  register int serrno ;
  register int ret ;
  struct stat sto ;
  struct stat stn ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 110
  tmp___4 = link((char const   *)old___0, (char const   *)newn);
  }
#line 110
  if (tmp___4) {
    {
#line 112
    tmp = __errno_location();
#line 112
    serrno = *tmp;
#line 112
    ret = -1;
#line 115
    tmp___1 = lstat((char const   */* __restrict  */)old___0, (struct stat */* __restrict  */)(& sto));
    }
#line 115
    if (tmp___1) {
#line 115
      goto _L;
    } else {
      {
#line 115
      ret = 1;
#line 115
      tmp___2 = lstat((char const   */* __restrict  */)newn, (struct stat */* __restrict  */)(& stn));
      }
#line 115
      if (tmp___2) {
#line 115
        tmp___3 = 1;
      } else
#line 115
      if (sto.st_dev != stn.st_dev) {
#line 115
        tmp___3 = 1;
      } else
#line 115
      if (sto.st_ino != stn.st_ino) {
#line 115
        tmp___3 = 1;
      } else
#line 115
      if (sto.st_uid != stn.st_uid) {
#line 115
        tmp___3 = 1;
      } else
#line 115
      if (sto.st_gid != stn.st_gid) {
#line 115
        tmp___3 = 1;
      } else
#line 115
      if ((sto.st_mode & 61440U) == 40960U) {
#line 115
        tmp___3 = 1;
      } else {
#line 115
        tmp___3 = 0;
      }
#line 115
      if (tmp___3) {
        _L: /* CIL Label */ 
        {
#line 118
        tmp___0 = __errno_location();
#line 118
        *tmp___0 = serrno;
        }
#line 119
        if (st) {
#line 119
          if (ret > 0) {
#line 120
            *st = sto;
#line 121
            return (ret);
          }
        }
#line 123
        return (-1);
      }
    }
  }
#line 127
  return (0);
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/exopen.c"
int hlink(char const   * const  old___0 , char const   * const  newn ) 
{ 
  int ret ;
  struct stat stbuf ;
  int fd ;
  int *tmp ;

  {
  {
#line 132
  ret = rlink(old___0, newn, & stbuf);
  }
#line 132
  if (0 < ret) {
#line 135
    if (stbuf.st_nlink < 2UL) {
      {
#line 135
      tmp = __errno_location();
      }
#line 135
      if (*tmp == 18) {
        {
#line 135
        fd = ropen(newn, 193, stbuf.st_mode);
        }
#line 135
        if (0 <= fd) {
#line 137
          return (fd + 1);
        }
      }
    }
#line 139
    return (-1);
  }
#line 141
  return (ret);
}
}
#line 19 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/goodies.h"
long Stdfilled  ;
#line 22 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/goodies.h"
char const   *Tmnate  ;
#line 22 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/goodies.h"
char const   *All_args  ;
#line 22 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/goodies.c"
char const   test[5]  = {      (char const   )'t',      (char const   )'e',      (char const   )'s',      (char const   )'t', 
        (char const   )'\000'};
#line 25 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/goodies.c"
static char const   *evalenv(void) 
{ 
  int j ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 27
  if (skiprc) {
#line 27
    tmp___3 = (char const   */* const  */)((char const   *)0);
  } else {
#line 27
    j = (int )*buf2 - 48;
#line 27
    if ((unsigned int )j > 9U) {
      {
#line 27
      tmp = getenv((char const   *)buf2);
#line 27
      tmp___2 = (char const   */* const  */)tmp;
      }
    } else {
#line 27
      if (! j) {
#line 27
        tmp___1 = (char const   */* const  */)argv0;
      } else {
#line 27
        if (j <= crestarg) {
#line 27
          tmp___0 = *(restargv + (j - 1));
        } else {
#line 27
          tmp___0 = (char const   */* const  */)((char const   *)0);
        }
#line 27
        tmp___1 = tmp___0;
      }
#line 27
      tmp___2 = tmp___1;
    }
#line 27
    tmp___3 = tmp___2;
  }
#line 27
  return ((char const   *)tmp___3);
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/goodies.c"
static int i  ;
#line 48 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/goodies.c"
static int skipbracelev  ;
#line 48 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/goodies.c"
static int bracegot  ;
#line 51 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/goodies.c"
static char *skipback  ;
#line 51 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/goodies.c"
static char const   *oldstartb  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/goodies.c"
int readparse(char *p___0 , int (* const  fpgetc)() , int const   sarg ) 
{ 
  int got ;
  int bracelev ;
  int qbracelev ;
  int overflow ;
  char num[(((8UL * sizeof(long )) * 4UL) / 10UL + 1UL) + 1UL] ;
  char *startb ;
  char *fencepost ;
  char *fencepost2 ;
  char *tmp ;
  char *tmp___0 ;
  int osh ;
  char const   *save ;
  char const   *sAll_args ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  int quoted ;
  char *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  char const   *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  char *q ;
  char *tmp___24 ;
  char *tmp___25 ;

  {
#line 49
  fencepost = buf + linebuf;
#line 49
  fencepost2 = buf2 + linebuf;
#line 52
  qbracelev = 0;
#line 52
  bracelev = qbracelev;
#line 52
  overflow = bracelev;
#line 52
  All_args = (char const   *)0;
#line 53
  got = -1;
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
    loop: 
    {
#line 55
    i = (*fpgetc)();
    }
    newchar: 
#line 57
    *(fencepost + 1) = (char )'\000';
#line 57
    if ((unsigned long )fencepost < (unsigned long )p___0) {
#line 57
      skiprc |= 1;
#line 57
      overflow = 1;
#line 57
      p___0 = fencepost;
    }
    {
#line 59
    if (i == -1) {
#line 59
      goto case_neg_1;
    }
#line 70
    if (i == 92) {
#line 70
      goto case_92;
    }
#line 95
    if (i == 96) {
#line 95
      goto case_96___0;
    }
#line 148
    if (i == 34) {
#line 148
      goto case_34___2;
    }
#line 159
    if (i == 39) {
#line 159
      goto case_39___0;
    }
#line 168
    if (i == 125) {
#line 168
      goto case_125___0;
    }
#line 180
    if (i == 35) {
#line 180
      goto case_35___0;
    }
#line 185
    if (i == 36) {
#line 185
      goto case_36___1;
    }
#line 326
    if (i == 9) {
#line 326
      goto case_9___0;
    }
#line 326
    if (i == 32) {
#line 326
      goto case_9___0;
    }
#line 335
    if (i == 10) {
#line 335
      goto case_10___1;
    }
#line 58
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 60
    if (sarg < 2) {
#line 60
      if (got > 1) {
        early_eof: 
        {
#line 61
        nlog((char const   */* const  */)(unexpeof));
        }
      }
    }
    ready: 
#line 62
    if (got != 0) {
#line 63
      tmp = p___0;
#line 63
      p___0 ++;
#line 63
      *tmp = (char )'\000';
    } else
#line 62
    if (sarg) {
#line 63
      tmp = p___0;
#line 63
      p___0 ++;
#line 63
      *tmp = (char )'\000';
    }
#line 64
    Tmnate = (char const   *)p___0;
#line 65
    if (overflow) {
      {
#line 66
      skiprc &= -2;
#line 67
      nlog((char const   */* const  */)(exceededlb));
#line 67
      setoverflow();
      }
    }
#line 69
    return (overflow);
    case_92: /* CIL Label */ 
#line 71
    if (got == 3) {
#line 72
      goto switch_break;
    }
    {
#line 73
    i = (*fpgetc)();
    }
    Quoted: 
    {
#line 75
    if (i == -1) {
#line 75
      goto case_neg_1___0;
    }
#line 77
    if (i == 10) {
#line 77
      goto case_10;
    }
#line 79
    if (i == 35) {
#line 79
      goto case_35;
    }
#line 82
    if (i == 39) {
#line 82
      goto case_39;
    }
#line 82
    if (i == 9) {
#line 82
      goto case_39;
    }
#line 82
    if (i == 32) {
#line 82
      goto case_39;
    }
#line 85
    if (i == 96) {
#line 85
      goto case_96;
    }
#line 85
    if (i == 36) {
#line 85
      goto case_96;
    }
#line 85
    if (i == 92) {
#line 85
      goto case_96;
    }
#line 85
    if (i == 34) {
#line 85
      goto case_96;
    }
#line 87
    if (i == 125) {
#line 87
      goto case_125;
    }
#line 74
    goto switch_break___0;
    case_neg_1___0: /* CIL Label */ 
#line 76
    goto early_eof;
    case_10: /* CIL Label */ 
#line 78
    goto __Cont;
    case_35: /* CIL Label */ 
#line 80
    if (got > 0) {
#line 81
      goto noesc;
    }
    case_39: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 83
    if (got == 2) {
#line 84
      goto noesc;
    }
    case_96: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_92___0: /* CIL Label */ 
    case_34: /* CIL Label */ 
#line 86
    goto nodelim;
    case_125: /* CIL Label */ 
#line 88
    if (got <= 1) {
#line 88
      if (bracelev) {
#line 90
        goto nodelim;
      } else {
#line 88
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 88
    if (got == 2) {
#line 88
      if (bracelev > qbracelev) {
#line 90
        goto nodelim;
      }
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 92
    if (got > 1) {
      noesc: 
#line 93
      tmp___0 = p___0;
#line 93
      p___0 ++;
#line 93
      *tmp___0 = (char )'\\';
    }
#line 94
    goto switch_break;
    case_96___0: /* CIL Label */ 
#line 96
    if (got == 3) {
#line 97
      goto nodelim;
    }
#line 98
    startb = p___0;
    {
#line 98
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 99
      i = (*fpgetc)();
      }
      {
#line 100
      if (i == 34) {
#line 100
        goto case_34___0;
      }
#line 103
      if (i == 96) {
#line 103
        goto forcebquote;
      }
#line 103
      if (i == -1) {
#line 103
        goto forcebquote;
      }
#line 132
      if (i == 92) {
#line 132
        goto case_92___1;
      }
#line 99
      goto switch_break___1;
      case_34___0: /* CIL Label */ 
#line 101
      if (got != 2) {
#line 102
        goto switch_break___1;
      }
      forcebquote: 
      case_96___1: /* CIL Label */ 
      case_neg_1___1: /* CIL Label */ 
#line 104
      if (skiprc) {
#line 105
        p___0 = startb;
#line 105
        *p___0 = (char )'\000';
      } else {
        {
#line 107
        osh = sh;
#line 108
        *p___0 = (char )'\000';
#line 109
        tmp___3 = strpbrk((char const   *)startb, strenstr[0].sval);
        }
#line 109
        if (tmp___3) {
#line 109
          tmp___4 = 1;
        } else {
#line 109
          tmp___4 = 0;
        }
#line 109
        sh = tmp___4;
#line 109
        if (! sh) {
          {
#line 110
          save = sgetcp;
#line 111
          p___0 = tstrdup((char const   */* const  */)startb);
#line 111
          sgetcp = (char const   *)p___0;
#line 111
          sAll_args = All_args;
#line 112
          tmp___1 = readparse(startb, (int (*/* const  */)())(& sgetc), (int const   )0);
          }
#line 112
          if (tmp___1) {
            {
#line 116
            strcpy((char */* __restrict  */)startb, (char const   */* __restrict  */)p___0);
#line 116
            sh = 1;
            }
          } else {
            {
#line 112
            tmp___2 = strcmp(test, (char const   *)startb);
            }
#line 112
            if (! tmp___2) {
              {
#line 116
              strcpy((char */* __restrict  */)startb, (char const   */* __restrict  */)p___0);
#line 116
              sh = 1;
              }
            }
          }
          {
#line 117
          All_args = sAll_args;
#line 118
          tfree((void */* const  */)p___0);
#line 118
          sgetcp = save;
          }
        }
        {
#line 120
        p___0 = startb;
#line 120
        startb = fromprog(p___0, startb, ((size_t )(buf - startb) + linebuf) - 3UL);
#line 122
        sh = osh;
        }
      }
#line 124
      if (got != 2) {
#line 125
        i = 0;
#line 125
        startb = p___0;
#line 126
        goto simplsplit;
      }
#line 128
      if (i == 34) {
#line 129
        got = 1;
      } else
#line 128
      if (got <= 0) {
#line 129
        got = 1;
      }
#line 130
      p___0 = startb;
#line 131
      goto loop;
      case_92___1: /* CIL Label */ 
      {
#line 133
      i = (*fpgetc)();
      }
      {
#line 134
      if (i == -1) {
#line 134
        goto case_neg_1___2;
      }
#line 136
      if (i == 10) {
#line 136
        goto case_10___0;
      }
#line 138
      if (i == 34) {
#line 138
        goto case_34___1;
      }
#line 141
      if (i == 96) {
#line 141
        goto case_96___2;
      }
#line 141
      if (i == 36) {
#line 141
        goto case_96___2;
      }
#line 141
      if (i == 92) {
#line 141
        goto case_96___2;
      }
#line 133
      goto switch_break___2;
      case_neg_1___2: /* CIL Label */ 
      {
#line 134
      nlog((char const   */* const  */)(unexpeof));
      }
#line 135
      goto forcebquote;
      case_10___0: /* CIL Label */ 
#line 137
      goto __Cont___0;
      case_34___1: /* CIL Label */ 
#line 139
      if (got != 2) {
#line 140
        goto switch_break___2;
      }
      case_96___2: /* CIL Label */ 
      case_36___0: /* CIL Label */ 
      case_92___2: /* CIL Label */ 
#line 142
      goto escaped;
      switch_break___2: /* CIL Label */ ;
      }
#line 144
      tmp___5 = p___0;
#line 144
      p___0 ++;
#line 144
      *tmp___5 = (char )'\\';
      switch_break___1: /* CIL Label */ ;
      }
      escaped: 
#line 146
      if ((unsigned long )fencepost < (unsigned long )p___0) {
#line 146
        skiprc |= 1;
#line 146
        overflow = 1;
#line 146
        p___0 = fencepost;
      }
#line 146
      tmp___6 = p___0;
#line 146
      p___0 ++;
#line 146
      *tmp___6 = (char )i;
      __Cont___0: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    case_34___2: /* CIL Label */ 
    {
#line 150
    if (got == 2) {
#line 150
      goto case_2;
    }
#line 152
    if (got == 3) {
#line 152
      goto case_3;
    }
#line 149
    goto switch_break___3;
    case_2: /* CIL Label */ 
#line 151
    if (qbracelev < bracelev) {
      case_3: /* CIL Label */ 
#line 153
      goto nodelim;
    }
#line 154
    got = 1;
#line 155
    goto __Cont;
    switch_break___3: /* CIL Label */ ;
    }
#line 157
    qbracelev = bracelev;
#line 157
    got = 2;
#line 158
    goto __Cont;
    case_39___0: /* CIL Label */ 
    {
#line 161
    if (got == 2) {
#line 161
      goto case_2___0;
    }
#line 163
    if (got == 3) {
#line 163
      goto case_3___0;
    }
#line 160
    goto switch_break___4;
    case_2___0: /* CIL Label */ 
#line 162
    goto nodelim;
    case_3___0: /* CIL Label */ 
#line 163
    got = 1;
#line 164
    goto __Cont;
    switch_break___4: /* CIL Label */ ;
    }
#line 166
    got = 3;
#line 167
    goto __Cont;
    case_125___0: /* CIL Label */ 
#line 169
    if (got <= 1) {
#line 169
      if (bracelev) {
#line 169
        goto _L___0;
      } else {
#line 169
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 169
    if (got == 2) {
#line 169
      if (bracelev > qbracelev) {
        _L___0: /* CIL Label */ 
#line 171
        bracelev --;
#line 172
        if (skipback) {
#line 172
          if (bracelev == skipbracelev) {
#line 173
            skiprc -= 2;
#line 173
            p___0 = skipback;
#line 173
            skipback = (char *)0;
#line 173
            startb = (char *)oldstartb;
#line 174
            got = bracegot;
#line 175
            goto closebrace;
          }
        }
#line 177
        goto __Cont;
      }
    }
#line 179
    goto nodelim;
    case_35___0: /* CIL Label */ 
#line 181
    if (got > 0) {
#line 182
      goto switch_break;
    }
    {
#line 183
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 183
      i = (*fpgetc)();
      }
#line 183
      if (i != -1) {
#line 183
        if (! (i != 10)) {
#line 183
          goto while_break___1;
        }
      } else {
#line 183
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 184
    goto ready;
    case_36___1: /* CIL Label */ 
#line 186
    if (got == 3) {
#line 187
      goto switch_break;
    }
    {
#line 188
    startb = buf2;
#line 189
    i = (*fpgetc)();
    }
    {
#line 190
    if (i == -1) {
#line 190
      goto case_neg_1___3;
    }
#line 192
    if (i == 64) {
#line 192
      goto case_64;
    }
#line 198
    if (i == 123) {
#line 198
      goto case_123;
    }
#line 242
    if (i == 36) {
#line 242
      goto case_36___2;
    }
#line 244
    if (i == 63) {
#line 244
      goto case_63;
    }
#line 246
    if (i == 35) {
#line 246
      goto case_35___1;
    }
#line 248
    if (i == 61) {
#line 248
      goto case_61;
    }
#line 251
    if (i == 95) {
#line 251
      goto case_95;
    }
#line 253
    if (i == 45) {
#line 253
      goto case_45___1;
    }
#line 256
    goto switch_default___1;
    case_neg_1___3: /* CIL Label */ 
#line 190
    tmp___7 = p___0;
#line 190
    p___0 ++;
#line 190
    *tmp___7 = (char )'$';
#line 190
    got = 1;
#line 191
    goto ready;
    case_64: /* CIL Label */ 
#line 193
    if (got != 2) {
#line 194
      goto normchar;
    }
#line 195
    if (! skiprc) {
#line 196
      All_args = (char const   *)p___0;
    }
#line 197
    goto __Cont;
    case_123: /* CIL Label */ 
    {
#line 199
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 199
      i = (*fpgetc)();
      }
#line 199
      if (-1 != i) {
        {
#line 199
        tmp___9 = alphanum((unsigned int const   )i);
        }
#line 199
        if (! tmp___9) {
#line 199
          goto while_break___2;
        }
      } else {
#line 199
        goto while_break___2;
      }
#line 200
      if ((unsigned long )startb >= (unsigned long )fencepost2) {
#line 201
        startb = buf2 + 2;
#line 201
        skiprc |= 1;
#line 201
        overflow = 1;
      }
#line 202
      tmp___8 = startb;
#line 202
      startb ++;
#line 202
      *tmp___8 = (char )i;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 204
    *startb = (char )'\000';
#line 205
    if ((unsigned int )*buf2 - 48U <= 9U) {
#line 205
      if (*(buf2 + 1)) {
#line 206
        goto badsub;
      }
    }
    {
#line 207
    tmp___10 = evalenv();
#line 207
    startb = (char *)tmp___10;
    }
    {
#line 211
    if (i == 58) {
#line 211
      goto case_58;
    }
#line 225
    if (i == 43) {
#line 225
      goto case_43___0;
    }
#line 229
    if (i == 45) {
#line 229
      goto case_45___0;
    }
#line 237
    if (i == 125) {
#line 237
      goto closebrace;
    }
#line 209
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 210
    goto badsub;
    case_58: /* CIL Label */ 
    {
#line 212
    i = (*fpgetc)();
    }
    {
#line 216
    if (i == 45) {
#line 216
      goto case_45;
    }
#line 220
    if (i == 43) {
#line 220
      goto case_43;
    }
#line 213
    goto badsub;
    badsub: 
    switch_default___0: /* CIL Label */ 
    {
#line 214
    nlog((char const   */* const  */)"Bad substitution of");
#line 214
    logqnl((char const   */* const  */)buf2);
    }
#line 215
    goto __Cont;
    case_45: /* CIL Label */ 
#line 217
    if (startb) {
#line 217
      if (*startb) {
#line 218
        goto noalt;
      }
    }
#line 219
    goto doalt;
    case_43: /* CIL Label */ 
#line 221
    if (startb) {
#line 221
      if (*startb) {
#line 222
        goto doalt;
      }
    }
#line 223
    startb = (char *)0;
    switch_break___7: /* CIL Label */ ;
    }
    case_43___0: /* CIL Label */ 
#line 226
    if (startb) {
#line 227
      goto doalt;
    }
#line 228
    goto noalt;
    case_45___0: /* CIL Label */ 
#line 230
    if (startb) {
      noalt: 
#line 231
      if (! skiprc) {
#line 232
        skiprc += 2;
#line 232
        skipback = p___0;
#line 232
        skipbracelev = bracelev;
#line 233
        oldstartb = (char const   *)startb;
#line 233
        bracegot = got;
      }
    }
    doalt: 
#line 235
    bracelev ++;
#line 236
    goto __Cont;
    closebrace: 
    case_125___1: /* CIL Label */ 
#line 238
    if (! startb) {
#line 239
      startb = (char *)(empty);
    }
    switch_break___6: /* CIL Label */ ;
    }
#line 241
    goto ibreak;
    case_36___2: /* CIL Label */ 
    {
#line 242
    startb = num;
#line 242
    ultstr(0, (unsigned long )thepid, startb);
    }
#line 243
    goto ieofstr;
    case_63: /* CIL Label */ 
    {
#line 244
    startb = num;
#line 244
    ltstr((int const   )0, (long const   )((long )lexitcode), startb);
    }
#line 245
    goto ieofstr;
    case_35___1: /* CIL Label */ 
    {
#line 246
    startb = num;
#line 246
    ultstr(0, (unsigned long )crestarg, startb);
    }
#line 247
    goto ieofstr;
    case_61: /* CIL Label */ 
    {
#line 248
    startb = num;
#line 248
    ltstr((int const   )0, (long const   )lastscore, startb);
    }
    ieofstr: 
#line 249
    i = '\000';
#line 250
    goto copyit;
    case_95: /* CIL Label */ 
#line 251
    if (incnamed) {
#line 251
      startb = incnamed->ename;
    } else {
#line 251
      startb = (char *)(empty);
    }
#line 252
    goto ibreak;
    case_45___1: /* CIL Label */ 
    {
#line 253
    tmp___11 = tgetenv((char const   */* const  */)(lastfolder));
#line 253
    startb = (char *)tmp___11;
    }
    ibreak: 
#line 254
    i = '\000';
#line 255
    goto switch_break___5;
    switch_default___1: /* CIL Label */ 
#line 257
    quoted = 0;
#line 258
    if ((unsigned int )i - 48U <= 9U) {
#line 259
      tmp___12 = startb;
#line 259
      startb ++;
#line 259
      *tmp___12 = (char )i;
#line 259
      i = '\000';
#line 260
      goto finsb;
    }
#line 262
    if (i == 92) {
      {
#line 263
      quoted = 1;
#line 263
      i = (*fpgetc)();
      }
    }
    {
#line 264
    tmp___23 = alphanum((unsigned int const   )i);
    }
#line 264
    if (tmp___23) {
      {
#line 265
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 266
        if ((unsigned long )startb >= (unsigned long )fencepost2) {
#line 267
          startb = buf2 + 2;
#line 267
          skiprc |= 1;
#line 267
          overflow = 1;
        }
        {
#line 268
        tmp___13 = startb;
#line 268
        startb ++;
#line 268
        *tmp___13 = (char )i;
#line 265
        i = (*fpgetc)();
        }
#line 265
        if (-1 != i) {
          {
#line 265
          tmp___14 = alphanum((unsigned int const   )i);
          }
#line 265
          if (! tmp___14) {
#line 265
            goto while_break___3;
          }
        } else {
#line 265
          goto while_break___3;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 271
      if (i == -1) {
#line 272
        i = '\000';
      }
      finsb: 
      {
#line 273
      *startb = (char )'\000';
#line 274
      tmp___15 = evalenv();
#line 274
      startb = (char *)tmp___15;
      }
#line 274
      if (! startb) {
#line 275
        startb = (char *)(empty);
      }
#line 276
      if (quoted) {
#line 277
        tmp___16 = p___0;
#line 277
        p___0 ++;
#line 277
        *tmp___16 = (char )'(';
#line 277
        if ((unsigned long )fencepost < (unsigned long )p___0) {
#line 277
          skiprc |= 1;
#line 277
          overflow = 1;
#line 277
          p___0 = fencepost;
        }
#line 278
        tmp___17 = p___0;
#line 278
        p___0 ++;
#line 278
        *tmp___17 = (char )')';
        {
#line 279
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 279
          if ((unsigned long )fencepost < (unsigned long )p___0) {
#line 279
            skiprc |= 1;
#line 279
            overflow = 1;
#line 279
            p___0 = fencepost;
          }
#line 279
          if (! *startb) {
#line 279
            goto while_break___4;
          }
          {
#line 280
          tmp___21 = strchr("(|)*?+.^$[\\", (int )*startb);
          }
#line 280
          if (tmp___21) {
#line 281
            tmp___20 = p___0;
#line 281
            p___0 ++;
#line 281
            *tmp___20 = (char )'\\';
          }
#line 279
          tmp___18 = p___0;
#line 279
          p___0 ++;
#line 279
          tmp___19 = startb;
#line 279
          startb ++;
#line 279
          *tmp___18 = *tmp___19;
        }
        while_break___4: /* CIL Label */ ;
        }
        normchar: 
#line 282
        quoted = 0;
      } else {
#line 285
        goto switch_break___5;
      }
    } else {
#line 288
      tmp___22 = p___0;
#line 288
      p___0 ++;
#line 288
      *tmp___22 = (char )'$';
    }
#line 289
    if (got <= 0) {
#line 290
      got = 1;
    }
#line 291
    if (quoted) {
#line 292
      goto Quoted;
    }
#line 293
    goto eeofstr;
    switch_break___5: /* CIL Label */ ;
    }
#line 296
    if (got != 2) {
      simplsplit: 
#line 298
      if (sarg) {
#line 299
        goto copyit;
      }
      {
#line 300
      q = simplesplit(p___0, (char const   *)startb, (char const   *)fencepost, & got);
      }
#line 300
      if (q) {
#line 301
        p___0 = q;
      } else {
#line 303
        skiprc |= 1;
#line 303
        overflow = 1;
#line 303
        p___0 = fencepost;
      }
    } else {
      copyit: 
      {
#line 306
      strncpy((char */* __restrict  */)p___0, (char const   */* __restrict  */)startb,
              (size_t )((fencepost - p___0) + 2L));
      }
#line 307
      if ((int )*(fencepost + 1) != 0) {
#line 308
        skiprc |= 1;
#line 308
        overflow = 1;
#line 308
        *fencepost = (char )'\000';
      }
#line 309
      if (got <= 0) {
#line 310
        got = 1;
      }
      {
#line 311
      p___0 = strchr((char const   *)p___0, '\000');
      }
    }
    eeofstr: 
#line 313
    if (i) {
#line 314
      goto newchar;
    }
#line 315
    goto __Cont;
    case_9___0: /* CIL Label */ 
    case_32___0: /* CIL Label */ 
    {
#line 328
    if (got == 1) {
#line 328
      goto case_1;
    }
#line 332
    if (got == 0) {
#line 332
      goto case_0;
    }
#line 332
    if (got == -1) {
#line 332
      goto case_0;
    }
#line 327
    goto switch_break___8;
    case_1: /* CIL Label */ 
#line 329
    if (sarg == 1) {
#line 330
      goto ready;
    }
#line 331
    got = 0;
#line 331
    tmp___24 = p___0;
#line 331
    p___0 ++;
#line 331
    if (sarg) {
#line 331
      *tmp___24 = (char )' ';
    } else {
#line 331
      *tmp___24 = (char )'\000';
    }
    case_0: /* CIL Label */ 
    case_neg_1___4: /* CIL Label */ 
#line 333
    goto __Cont;
    switch_break___8: /* CIL Label */ ;
    }
    case_10___1: /* CIL Label */ 
#line 336
    if (got <= 1) {
#line 337
      goto ready;
    }
    switch_break: /* CIL Label */ ;
    }
    nodelim: 
#line 340
    tmp___25 = p___0;
#line 340
    p___0 ++;
#line 340
    *tmp___25 = (char )i;
#line 341
    if (got <= 0) {
#line 342
      got = 1;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 346 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/goodies.c"
char *simplesplit(char *to , char const   *from , char const   *fencepost , int *gotp ) 
{ 
  register int got ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 348
  got = *gotp;
  {
#line 349
  while (1) {
    while_continue: /* CIL Label */ ;
#line 349
    if (! ((unsigned long )to <= (unsigned long )fencepost)) {
#line 349
      goto while_break;
    }
    {
#line 351
    if ((int const   )*from == 10) {
#line 351
      goto case_10;
    }
#line 351
    if ((int const   )*from == 9) {
#line 351
      goto case_10;
    }
#line 351
    if ((int const   )*from == 32) {
#line 351
      goto case_10;
    }
#line 355
    if ((int const   )*from == 0) {
#line 355
      goto case_0;
    }
#line 350
    goto switch_break;
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 352
    if (got > 0) {
#line 353
      tmp = to;
#line 353
      to ++;
#line 353
      *tmp = (char )'\000';
#line 353
      got = 0;
    }
#line 354
    goto __Cont;
    case_0: /* CIL Label */ 
#line 356
    goto ret;
    switch_break: /* CIL Label */ ;
    }
#line 358
    tmp___0 = to;
#line 358
    to ++;
#line 358
    *tmp___0 = (char )*from;
#line 358
    got = 1;
    __Cont: /* CIL Label */ 
#line 349
    from ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 360
  to = (char *)0;
  ret: 
#line 362
  *gotp = got;
#line 363
  return (to);
}
}
#line 366 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/goodies.c"
void ltstr(int const   minwidth , long const   val , char *dest ) 
{ 


  {
#line 367
  if (val < 0L) {
    {
#line 368
    *dest = (char )' ';
#line 368
    ultstr((int )(minwidth - 1), (unsigned long )(- val), dest + 1);
    }
    {
#line 369
    while (1) {
      while_continue: /* CIL Label */ ;
#line 369
      dest ++;
#line 369
      if (! ((int )*dest == 32)) {
#line 369
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 370
    *(dest + -1) = (char )'-';
  } else {
    {
#line 373
    ultstr((int )minwidth, (unsigned long )val, dest);
    }
  }
#line 374
  return;
}
}
#line 376 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/goodies.c"
double stod(char const   *str , char const   ** const  ptr ) 
{ 
  int sign ;
  int any ;
  unsigned int i___0 ;
  char *chp ;
  double acc ;
  double fracc ;
  char *tmp ;
  char *tmp___0 ;
  double tmp___1 ;

  {
  {
#line 378
  fracc = (double )1;
#line 378
  sign = 0;
#line 378
  any = sign;
#line 378
  acc = (double )any;
#line 379
  chp = skpspace(str);
  }
  {
#line 380
  if ((int )*chp == 45) {
#line 380
    goto case_45;
  }
#line 381
  if ((int )*chp == 43) {
#line 381
    goto case_43;
  }
#line 379
  goto switch_break;
  case_45: /* CIL Label */ 
#line 380
  sign = 1;
  case_43: /* CIL Label */ 
#line 381
  chp ++;
  switch_break: /* CIL Label */ ;
  }
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
#line 383
    tmp = chp;
#line 383
    chp ++;
#line 383
    i___0 = (unsigned int )*tmp - 48U;
#line 383
    if (! (i___0 <= 9U)) {
#line 383
      goto while_break;
    }
#line 384
    acc = acc * (double )10 + (double )i___0;
#line 384
    any = 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 386
  if (i___0 == 4294967292U) {
#line 386
    goto case_4294967292;
  }
#line 386
  if (i___0 == 4294967294U) {
#line 386
    goto case_4294967292;
  }
#line 385
  goto switch_break___0;
  case_4294967292: /* CIL Label */ 
  case_4294967294: /* CIL Label */ 
  {
#line 387
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 387
    fracc /= (double )10;
#line 387
    tmp___0 = chp;
#line 387
    chp ++;
#line 387
    i___0 = (unsigned int )*tmp___0 - 48U;
#line 387
    if (! (i___0 <= 9U)) {
#line 387
      goto while_break___0;
    }
#line 388
    acc += fracc * (double )i___0;
#line 388
    any = 1;
  }
  while_break___0: /* CIL Label */ ;
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 390
  if (ptr) {
#line 391
    if (any) {
#line 391
      *ptr = (char const   *)(chp - 1);
    } else {
#line 391
      *ptr = str;
    }
  }
#line 392
  if (sign) {
#line 392
    tmp___1 = - acc;
  } else {
#line 392
    tmp___1 = acc;
  }
#line 392
  return (tmp___1);
}
}
#line 395 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/goodies.c"
static struct dynstring *myenv  ;
#line 396 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/goodies.c"
static char **lastenv  ;
#line 399 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/goodies.c"
static int alloced  ;
#line 398 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/goodies.c"
char const   *sputenv(char const   * const  a ) 
{ 
  size_t eq ;
  size_t i___0 ;
  int remove___0 ;
  char const   *split ;
  char **preenv ;
  struct dynstring *curr ;
  struct dynstring **last ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
  {
#line 401
  yell((char const   */* const  */)"Assigning", a);
#line 401
  remove___0 = 0;
#line 402
  tmp___0 = strchr((char const   *)a, '=');
#line 402
  split = (char const   *)tmp___0;
  }
#line 402
  if (! split) {
    {
#line 403
    remove___0 = 1;
#line 403
    tmp = strchr((char const   *)a, '\000');
#line 403
    split = (char const   *)tmp;
    }
  }
#line 404
  eq = (size_t )(split - (char const   *)a);
#line 405
  last = & myenv;
#line 405
  curr = *last;
  {
#line 405
  while (1) {
    while_continue: /* CIL Label */ ;
#line 405
    if (! curr) {
#line 405
      goto while_break;
    }
    {
#line 406
    tmp___1 = strncmp((char const   *)a, (char const   *)(curr->ename), eq);
    }
#line 406
    if (! tmp___1) {
#line 406
      if ((int )curr->ename[eq] == 61) {
        {
#line 407
        split = (char const   *)(curr->ename);
#line 407
        *last = curr->enext;
#line 407
        tfree((void */* const  */)curr);
#line 408
        preenv = environ;
        }
        {
#line 408
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 408
          if (! ((unsigned long )*preenv != (unsigned long )split)) {
#line 408
            goto while_break___0;
          }
#line 408
          preenv ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 409
        goto wipenv;
      }
    }
#line 405
    last = & curr->enext;
#line 405
    curr = *last;
  }
  while_break: /* CIL Label */ ;
  }
#line 411
  preenv = environ;
  {
#line 411
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 411
    if (! *preenv) {
#line 411
      goto while_break___1;
    }
    {
#line 412
    tmp___3 = strncmp((char const   *)a, (char const   *)*preenv, eq);
    }
#line 412
    if (! tmp___3) {
#line 412
      if ((int )*(*preenv + eq) == 61) {
        wipenv: 
        {
#line 414
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 414
          tmp___2 = *(preenv + 1);
#line 414
          *preenv = tmp___2;
#line 414
          if (! tmp___2) {
#line 414
            goto while_break___2;
          }
#line 415
          preenv ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 416
        goto while_break___1;
      }
    }
#line 411
    preenv ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 418
  i___0 = (unsigned long )((preenv - environ) + 2L) * sizeof(*environ);
#line 419
  if (alloced) {
    {
#line 420
    tmp___4 = trealloc(environ, i___0);
#line 420
    environ = (char **)tmp___4;
    }
  } else {
    {
#line 422
    alloced = 1;
#line 422
    tmp___5 = tmalloc(i___0);
#line 422
    tmp___6 = memmove(tmp___5, (void const   *)environ, i___0 - sizeof(*environ));
#line 422
    environ = (char **)tmp___6;
    }
  }
#line 423
  if (! remove___0) {
#line 424
    preenv = environ;
    {
#line 424
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 424
      if (! *preenv) {
#line 424
        goto while_break___3;
      }
#line 424
      preenv ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 425
    *(preenv + 1) = (char *)0;
#line 425
    lastenv = preenv;
#line 425
    split = newdynstring((struct dynstring **/* const  */)(& myenv), a);
#line 425
    *lastenv = (char *)split;
    }
#line 426
    return ((split + eq) + 1);
  }
#line 428
  return (empty);
}
}
#line 431 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/goodies.c"
void primeStdout(char const   * const  varname ) 
{ 
  size_t tmp ;

  {
#line 432
  if (! Stdout) {
    {
#line 433
    sputenv(varname);
    }
  }
  {
#line 434
  Stdout = (char *)myenv;
#line 435
  tmp = strlen((char const   *)varname);
#line 435
  Stdfilled = (long )((size_t )((int )((unsigned long )(& ((struct dynstring *)0)->ename[0]))) + tmp);
  }
#line 436
  return;
}
}
#line 438 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/goodies.c"
void retStdout(char * const  newmyenv , int unset ) 
{ 


  {
#line 440
  if (unset) {
    {
#line 441
    myenv = ((struct dynstring *)newmyenv)->enext;
#line 442
    tfree((void */* const  */)newmyenv);
#line 442
    Stdout = (char *)0;
#line 442
    *lastenv = Stdout;
    }
#line 443
    return;
  }
#line 445
  if ((int )*(newmyenv + (Stdfilled - 1L)) == 10) {
#line 446
    Stdfilled --;
  }
  {
#line 447
  retbStdout(newmyenv);
  }
#line 448
  return;
}
}
#line 450 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/goodies.c"
void retbStdout(char * const  newmyenv ) 
{ 


  {
#line 451
  *(newmyenv + Stdfilled) = (char )'\000';
#line 451
  myenv = (struct dynstring *)newmyenv;
#line 451
  *lastenv = myenv->ename;
#line 452
  Stdout = (char *)0;
#line 453
  return;
}
}
#line 455 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/goodies.c"
void postStdout(void) 
{ 
  char const   *p___0 ;
  size_t i___0 ;
  char *tmp ;

  {
  {
#line 457
  p___0 = (char const   *)*lastenv;
#line 457
  tmp = strchr(p___0, '=');
#line 457
  i___0 = (size_t )(tmp - (char *)p___0);
#line 457
  memmove((void *)buf, (void const   *)p___0, i___0);
#line 457
  *(buf + i___0) = (char )'\000';
#line 457
  asenv((char const   */* const  */)((p___0 + i___0) + 1));
  }
#line 458
  return;
}
}
#line 460 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/goodies.c"
char const   *eputenv(char const   * const  src , char * const  dst ) 
{ 
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 461
  sgetcp = (char const   *)src;
#line 462
  tmp___2 = readparse((char *)dst, (int (*/* const  */)())(& sgetc), (int const   )2);
  }
#line 462
  if (tmp___2) {
#line 462
    tmp___1 = (char const   *)0;
  } else {
    {
#line 462
    tmp___0 = sputenv((char const   */* const  */)buf);
#line 462
    tmp___1 = tmp___0;
    }
  }
#line 462
  return (tmp___1);
}
}
#line 14 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/mcommon.c"
static int volatile   gotsig  ;
#line 16 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/mcommon.c"
static void fakehandler(void) 
{ 


  {
#line 17
  gotsig = (int volatile   )1;
#line 18
  return;
}
}
#line 20 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/mcommon.c"
void qsignal(int const   sig , void (*action)(void) ) 
{ 
  __sighandler_t tmp ;

  {
  {
#line 21
  gotsig = (int volatile   )0;
#line 22
  tmp = signal((int )sig, (void (*)(int  ))(& fakehandler));
  }
#line 22
  if ((unsigned long )((void (*)(int  ))1) == (unsigned long )tmp) {
    {
#line 23
    signal((int )sig, (void (*)(int  ))1);
    }
  } else {
    {
#line 25
    signal((int )sig, (void (*)(int  ))action);
    }
#line 26
    if (gotsig) {
      {
#line 27
      (*action)();
      }
    }
  }
#line 29
  return;
}
}
#line 689 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getgroups)(int __size ,
                                                                                __gid_t *__list ) ;
#line 272 "/usr/include/stdio.h"
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 695
extern int puts(char const   *__s ) ;
#line 189 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) clock_t ( __attribute__((__leaf__)) clock)(void) ;
#line 73 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/sublib.c"
char *sstrstr(char const   * const  phaystack , char const   * const  pneedle ) 
{ 
  register uschar const   *haystack ;
  register uschar const   *needle ;
  register chartype b ;
  register chartype c ;
  register chartype a ;
  register chartype a___0 ;
  register uschar const   *rhaystack ;
  register uschar const   *rneedle ;
  uschar const   *tmp ;

  {
#line 76
  haystack = (uschar const   *)phaystack;
#line 77
  needle = (uschar const   *)pneedle;
#line 77
  b = (chartype )*needle;
#line 77
  if (b) {
#line 78
    haystack --;
    {
#line 79
    while (1) {
      while_continue: /* CIL Label */ ;
#line 80
      haystack ++;
#line 80
      c = (chartype )*haystack;
#line 80
      if (! c) {
#line 81
        goto ret0;
      }
#line 79
      if (! (c != b)) {
#line 79
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 83
    needle ++;
#line 83
    c = (chartype )*needle;
#line 83
    if (! c) {
#line 84
      goto foundneedle;
    }
#line 85
    needle ++;
#line 86
    goto jin;
    {
#line 87
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 89
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 90
        haystack ++;
#line 90
        a = (chartype )*haystack;
#line 90
        if (! a) {
#line 91
          goto ret0;
        }
#line 92
        if (a == b) {
#line 93
          goto while_break___1;
        }
#line 94
        haystack ++;
#line 94
        a = (chartype )*haystack;
#line 94
        if (! a) {
#line 95
          goto ret0;
        }
        shloop: ;
#line 89
        if (! (a != b)) {
#line 89
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      jin: 
#line 98
      haystack ++;
#line 98
      a = (chartype )*haystack;
#line 98
      if (! a) {
#line 99
        goto ret0;
      }
#line 100
      if (a != c) {
#line 101
        goto shloop;
      }
#line 105
      tmp = haystack;
#line 105
      haystack --;
#line 105
      rhaystack = tmp + 1;
#line 105
      rneedle = needle;
#line 105
      a___0 = (chartype )*rneedle;
#line 105
      if ((chartype )*rhaystack == a___0) {
        {
#line 106
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 107
          if (! a___0) {
#line 108
            goto foundneedle;
          }
#line 109
          rhaystack ++;
#line 109
          needle ++;
#line 109
          a___0 = (chartype )*needle;
#line 109
          if ((chartype )*rhaystack != a___0) {
#line 110
            goto while_break___2;
          }
#line 111
          if (! a___0) {
#line 112
            goto foundneedle;
          }
#line 106
          rhaystack ++;
#line 106
          needle ++;
#line 106
          a___0 = (chartype )*needle;
#line 106
          if (! ((chartype )*rhaystack == a___0)) {
#line 106
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 115
      needle = rneedle;
#line 117
      if (! a___0) {
#line 118
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  foundneedle: 
#line 123
  return ((char *)haystack);
  ret0: 
#line 125
  return ((char *)0);
}
}
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 357 "/usr/include/netdb.h"
extern struct protoent *getprotobyname(char const   *__name ) ;
#line 11 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/_autotst.c"
unsigned long dobench(char *(* const  strstr___0)() , unsigned long iter , char const   * const  haystack ) 
{ 
  unsigned long to ;
  clock_t tmp ;
  clock_t tmp___0 ;

  {
  {
#line 14
  tmp = clock();
#line 14
  to = (unsigned long )tmp;
  }
  {
#line 15
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 15
    (*strstr___0)(haystack, "\nFrom ");
#line 15
    iter --;
    }
#line 15
    if (! iter) {
#line 15
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 17
  tmp___0 = clock();
  }
#line 17
  return ((unsigned long )tmp___0 - to);
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/_autotst.c"
static char const   arg[17]  = 
#line 155
  {      (char const   )'e',      (char const   )'%',      (char const   )'0',      (char const   )'4', 
        (char const   )'u',      (char const   )'=',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'0',      (char const   )'1', 
        (char const   )'2',      (char const   )'3',      (char const   )'4',      (char const   )'5', 
        (char const   )'\000'};
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 14 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/mcommon.c"
static int volatile   gotsig___0  ;
#line 16 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/mcommon.c"
static void fakehandler___0(void) 
{ 


  {
#line 17
  gotsig___0 = (int volatile   )1;
#line 18
  return;
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/acommon.c"
static char *name___0  =    (char *)0;
#line 26 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/lockfile.c"
static int volatile   exitflag  ;
#line 31 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/lockfile.c"
static char const   lockext[6]  = {      (char const   )'.',      (char const   )'l',      (char const   )'o',      (char const   )'c', 
        (char const   )'k',      (char const   )'\000'};
#line 31 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/lockfile.c"
static char const   nameprefix[11]  = 
#line 31
  {      (char const   )'l',      (char const   )'o',      (char const   )'c',      (char const   )'k', 
        (char const   )'f',      (char const   )'i',      (char const   )'l',      (char const   )'e', 
        (char const   )':',      (char const   )' ',      (char const   )'\000'};
#line 31 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/lockfile.c"
static char const   lgname___0[8]  = 
#line 31
  {      (char const   )'L',      (char const   )'O',      (char const   )'G',      (char const   )'N', 
        (char const   )'A',      (char const   )'M',      (char const   )'E',      (char const   )'\000'};
#line 34 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/lockfile.c"
static void failure(void) 
{ 


  {
#line 35
  exitflag = (int volatile   )2;
#line 36
  return;
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/lockfile.c"
static int xcreat___0(char const   * const  name___1 , time_t * const  tim ) 
{ 
  char *p___0 ;
  char *q ;
  int j ;
  size_t i___0 ;
  struct stat stbuf ;
  void *tmp ;
  int tmp___0 ;

  {
#line 39
  j = -1;
#line 40
  q = (char *)name___1;
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 40
    p___0 = strpbrk((char const   *)q, dirsep);
    }
#line 40
    if (! p___0) {
#line 40
      goto while_break;
    }
#line 40
    q = p___0 + 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 41
  i___0 = (size_t )(q - (char *)name___1);
#line 42
  tmp = malloc(i___0 + 24UL);
#line 42
  p___0 = (char *)tmp;
  }
#line 42
  if (! p___0) {
#line 43
    exitflag = (int volatile   )1;
#line 43
    return ((int )exitflag);
  }
  {
#line 44
  strncpy((char */* __restrict  */)p___0, (char const   */* __restrict  */)name___1,
          i___0);
#line 45
  tmp___0 = unique(p___0, p___0 + i___0, 0, (256 | (256 >> 3)) | ((256 >> 3) >> 3),
                   0, 6);
  }
#line 45
  if (tmp___0) {
    {
#line 46
    stat((char const   */* __restrict  */)p___0, (struct stat */* __restrict  */)(& stbuf));
#line 46
    *tim = stbuf.st_mtim.tv_sec;
#line 46
    j = myrename((char const   */* const  */)p___0, name___1);
    }
  }
  {
#line 47
  free((void *)p___0);
  }
#line 48
  return (j);
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/lockfile.c"
static char progid[24]  = 
#line 59
  {      (char )'S',      (char )'t',      (char )'e',      (char )'p', 
        (char )'h',      (char )'e',      (char )'n',      (char )' ', 
        (char )'R',      (char )'.',      (char )' ',      (char )'v', 
        (char )'a',      (char )'n',      (char )' ',      (char )'d', 
        (char )'e',      (char )'n',      (char )' ',      (char )'B', 
        (char )'e',      (char )'r',      (char )'g',      (char )'\000'};
#line 64 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/lockfile.c"
static char const   usage[82]  = 
#line 64
  {      (char const   )'U',      (char const   )'s',      (char const   )'a',      (char const   )'g', 
        (char const   )'e',      (char const   )':',      (char const   )' ',      (char const   )'l', 
        (char const   )'o',      (char const   )'c',      (char const   )'k',      (char const   )'f', 
        (char const   )'i',      (char const   )'l',      (char const   )'e',      (char const   )' ', 
        (char const   )'-',      (char const   )'v',      (char const   )' ',      (char const   )'|', 
        (char const   )' ',      (char const   )'-',      (char const   )'n',      (char const   )'n', 
        (char const   )'n',      (char const   )' ',      (char const   )'|',      (char const   )' ', 
        (char const   )'-',      (char const   )'r',      (char const   )' ',      (char const   )'n', 
        (char const   )'n',      (char const   )'n',      (char const   )' ',      (char const   )'|', 
        (char const   )' ',      (char const   )'-',      (char const   )'l',      (char const   )' ', 
        (char const   )'n',      (char const   )'n',      (char const   )'n',      (char const   )' ', 
        (char const   )'|',      (char const   )' ',      (char const   )'-',      (char const   )'s', 
        (char const   )' ',      (char const   )'n',      (char const   )'n',      (char const   )'n', 
        (char const   )' ',      (char const   )'|',      (char const   )' ',      (char const   )'-', 
        (char const   )'!',      (char const   )' ',      (char const   )'|',      (char const   )' ', 
        (char const   )'-',      (char const   )'m',      (char const   )'l',      (char const   )' ', 
        (char const   )'|',      (char const   )' ',      (char const   )'-',      (char const   )'m', 
        (char const   )'u',      (char const   )' ',      (char const   )'|',      (char const   )' ', 
        (char const   )'f',      (char const   )'i',      (char const   )'l',      (char const   )'e', 
        (char const   )' ',      (char const   )'.',      (char const   )'.',      (char const   )'.', 
        (char const   )'\n',      (char const   )'\000'};
#line 122 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/lockfile.c"
static char *ma  ;
#line 57 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/authenticate.c"
static auth_identity authi___0  ;
#line 59 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/authenticate.c"
static void castlower___0(char *str ) 
{ 


  {
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (! *str) {
#line 60
      goto while_break;
    }
#line 61
    if ((unsigned int )*str - 65U <= 25U) {
#line 62
      *str = (char )((int )*str + 32);
    }
#line 60
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 63
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/authenticate.c"
static struct passwd  const  *cgetpwnam___0(char const   * const  user , int const   sock ) 
{ 
  struct passwd *tmp ;

  {
  {
#line 67
  tmp = getpwnam((char const   *)user);
  }
#line 67
  return ((struct passwd  const  *)tmp);
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/authenticate.c"
static struct passwd  const  *cgetpwuid___0(uid_t const   uid___0 , int const   sock ) 
{ 
  struct passwd *tmp ;

  {
  {
#line 71
  tmp = getpwuid((__uid_t )uid___0);
  }
#line 71
  return ((struct passwd  const  *)tmp);
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/authenticate.c"
static char const   mailspooldir___0[17]  = 
#line 162
  {      (char const   )'/',      (char const   )'v',      (char const   )'a',      (char const   )'r', 
        (char const   )'/',      (char const   )'s',      (char const   )'p',      (char const   )'o', 
        (char const   )'o',      (char const   )'l',      (char const   )'/',      (char const   )'m', 
        (char const   )'a',      (char const   )'i',      (char const   )'l',      (char const   )'/', 
        (char const   )'\000'};
#line 23 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/exopen.c"
static char const   s2c___0[5]  = {      (char const   )'.',      (char const   )',',      (char const   )'+',      (char const   )'%', 
        (char const   )'\000'};
#line 23 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/exopen.c"
static int serial___0  =    (int )(sizeof(s2c___0) - 1UL);
#line 24 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/exopen.c"
static time_t t___0  ;
#line 631 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getppid)(void) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 1081
extern int lockf(int __fd , int __cmd , __off_t __len ) ;
#line 242 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/file.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) flock)(int __fd ,
                                                                            int __operation ) ;
#line 58 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/_autotst.c"
int dolock  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/_autotst.c"
int child[8]  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/_autotst.c"
int timeout  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/_autotst.c"
int fdcollect  ;
#line 59 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/_autotst.c"
char dirlocktest[10]  = 
#line 59
  {      (char )'_',      (char )'l',      (char )'o',      (char )'c', 
        (char )'k',      (char )'t',      (char )'e',      (char )'s', 
        (char )'t',      (char )'\000'};
#line 62
int killchildren(void) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/_autotst.c"
void stimeout(void) 
{ 


  {
  {
#line 62
  timeout = 1;
#line 62
  close(fdcollect);
#line 62
  killchildren();
  }
#line 63
  return;
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/_autotst.c"
static unsigned long seed  ;
#line 71 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/_autotst.c"
unsigned int psrand(void) 
{ 


  {
#line 72
  seed *= 69069UL;
#line 72
  return ((unsigned int )seed >> 8);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/_autotst.c"
static char filename[12]  = 
#line 84
  {      (char )'_',      (char )'l',      (char )'o',      (char )'c', 
        (char )'k',      (char )'t',      (char )'s',      (char )'t', 
        (char )'.',      (char )'l',      (char )'0',      (char )'\000'};
#line 145
int sfdlock(int fd ) ;
#line 220 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/_autotst.c"
int killchildren(void) 
{ 
  int i___0 ;

  {
#line 222
  i___0 = 8;
  {
#line 223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 224
    i___0 --;
#line 224
    if (child[i___0] > 0) {
      {
#line 225
      kill(child[i___0], 15);
#line 225
      child[i___0] = 0;
      }
    }
#line 223
    if (! i___0) {
#line 223
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 227
  return (0);
}
}
#line 229 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/_autotst.c"
int sfdlock(int fd ) 
{ 
  int i___0 ;
  unsigned int gobble[256 >> 2] ;
  int tmp ;

  {
#line 231
  i___0 = 256 >> 2;
  {
#line 231
  while (1) {
    while_continue: /* CIL Label */ ;
#line 231
    if (! i___0) {
#line 231
      goto while_break;
    }
#line 231
    i___0 --;
#line 231
    gobble[i___0] = ~ 0U;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 232
  tmp = fdlock(fd);
  }
#line 232
  return (tmp);
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/_autotst.c"
static int oldfdlock___0  ;
#line 237 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/_autotst.c"
static struct flock flck___0  ;
#line 240 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/_autotst.c"
static off_t oldlockoffset  ;
#line 249 "/home/june/repo/benchmarks/collector/temp/smartlist-3.15/src/_autotst.c"
static unsigned int extra  ;
