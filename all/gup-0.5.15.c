/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 50 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.h"
struct group_s;
#line 50 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.h"
typedef struct group_s GROUP;
#line 52
struct tag_s;
#line 52 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.h"
typedef struct tag_s TAG;
#line 54 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.h"
struct tag_s {
   TAG *next ;
   GROUP *group ;
};
#line 59 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.h"
union __anonunion_u_30 {
   int not ;
   TAG *tag ;
};
#line 59 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.h"
struct group_s {
   GROUP *next ;
   char const   *name ;
   char const   *desc ;
   int order ;
   union __anonunion_u_30 u ;
};
#line 70 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.h"
struct __anonstruct_LIST_31 {
   GROUP *head ;
   GROUP *tail ;
   unsigned int length ;
};
#line 70 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.h"
typedef struct __anonstruct_LIST_31 LIST;
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 64 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.c"
struct command_s;
#line 64 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.c"
typedef struct command_s COMMAND;
#line 66 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.c"
struct command_s {
   char const   *name ;
   int (*handler)(char const   ** ) ;
   int args ;
   int needs_site ;
   int sets_quit ;
};
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 873
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 879
extern int pclose(FILE *__stream ) ;
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 94 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.h"
void logit(int lflags , char const   *log_msg  , ...) ;
#line 96
 __attribute__((__noreturn__)) void gupout(int val , char const   *out_msg  , ...) ;
#line 113
char *xstrdup(char const   *str ) ;
#line 116
FILE *mail_open(int open_now , char const   *to , char const   *command , char const   *headers ) ;
#line 117
extern void mail_close(FILE *fp ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/mail.c"
static char *m_to  =    (char *)((void *)0);
#line 14 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/mail.c"
static char *m_command  =    (char *)((void *)0);
#line 15 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/mail.c"
static char *m_headers  =    (char *)((void *)0);
#line 8 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/mail.c"
FILE *mail_open(int open_now , char const   *to , char const   *command , char const   *headers ) 
{ 
  FILE *fp ;
  FILE *hdr_fp ;
  char lbuf[512] ;
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 19
  if (to) {
    {
#line 20
    m_to = xstrdup(to);
    }
  }
#line 21
  if (command) {
    {
#line 23
    m_command = xstrdup(command);
    }
  }
#line 33
  if (headers) {
    {
#line 34
    m_headers = xstrdup(headers);
    }
  }
#line 36
  if (! open_now) {
#line 37
    return ((FILE *)((void *)0));
  }
#line 39
  if (! m_command) {
    {
#line 40
    gupout(1, "Install error. No mail command supplied");
    }
  }
  {
#line 42
  fp = popen((char const   *)m_command, "w");
  }
#line 43
  if (! fp) {
    {
#line 44
    gupout(1, "Could not open a pipe to \'%s\'", m_command);
    }
  }
#line 51
  if (m_to) {
    {
#line 52
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"To: %s\n",
            m_to);
    }
  }
#line 54
  if (m_headers) {
    {
#line 58
    hdr_fp = fopen((char const   */* __restrict  */)m_headers, (char const   */* __restrict  */)"r");
    }
#line 58
    if (hdr_fp) {
      {
#line 59
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 59
        tmp = fgets((char */* __restrict  */)(lbuf), (int )sizeof(lbuf), (FILE */* __restrict  */)hdr_fp);
        }
#line 59
        if (! tmp) {
#line 59
          goto while_break;
        }
        {
#line 60
        fputs((char const   */* __restrict  */)(lbuf), (FILE */* __restrict  */)fp);
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 61
      fclose(hdr_fp);
      }
    } else {
      {
#line 63
      tmp___0 = __errno_location();
#line 63
      tmp___1 = strerror(*tmp___0);
#line 63
      logit(1, "WARNING: Could not open \'%s\' (%s)", m_headers, tmp___1);
      }
    }
  } else {
    {
#line 66
    fputs((char const   */* __restrict  */)"Subject: Results of your request\n", (FILE */* __restrict  */)fp);
    }
  }
  {
#line 68
  fputs((char const   */* __restrict  */)"\n\n", (FILE */* __restrict  */)fp);
  }
#line 69
  return (fp);
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/mail.c"
extern void mail_close(FILE *fp ) 
{ 
  int tmp ;

  {
  {
#line 74
  tmp = pclose(fp);
  }
#line 74
  if (tmp == -1) {
    {
#line 75
    gupout(1, "pclose() of mail command failed");
    }
  }
#line 76
  return;
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/wildmat.c"
static int DoMatch(char const   *text , char const   *p ) ;
#line 53
int wildmat(char const   *text , char const   *p ) ;
#line 59 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/wildmat.c"
static int DoMatch(char const   *text , char const   *p ) 
{ 
  register int last ;
  register int matched ;
  register int reverse ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    if (! *p) {
#line 65
      goto while_break;
    }
#line 66
    if ((int const   )*text == 0) {
#line 66
      if ((int const   )*p != 42) {
#line 67
        return (-1);
      }
    }
    {
#line 69
    if ((int const   )*p == 92) {
#line 69
      goto case_92;
    }
#line 77
    if ((int const   )*p == 63) {
#line 77
      goto case_63;
    }
#line 80
    if ((int const   )*p == 42) {
#line 80
      goto case_42;
    }
#line 91
    if ((int const   )*p == 91) {
#line 91
      goto case_91;
    }
#line 73
    goto switch_default;
    case_92: /* CIL Label */ 
#line 71
    p ++;
    switch_default: /* CIL Label */ 
#line 74
    if ((int const   )*text != (int const   )*p) {
#line 75
      return (0);
    }
#line 76
    goto __Cont;
    case_63: /* CIL Label */ 
#line 79
    goto __Cont;
    case_42: /* CIL Label */ 
    {
#line 81
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 81
      p ++;
#line 81
      if (! ((int const   )*p == 42)) {
#line 81
        goto while_break___0;
      }
#line 83
      goto while_continue___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 84
    if ((int const   )*p == 0) {
#line 86
      return (1);
    }
    {
#line 87
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 87
      if (! *text) {
#line 87
        goto while_break___1;
      }
      {
#line 88
      tmp = text;
#line 88
      text ++;
#line 88
      matched = DoMatch(tmp, p);
      }
#line 88
      if (matched != 0) {
#line 89
        return (matched);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 90
    return (-1);
    case_91: /* CIL Label */ 
#line 92
    if ((int const   )*(p + 1) == 94) {
#line 92
      reverse = 1;
    } else {
#line 92
      reverse = 0;
    }
#line 93
    if (reverse) {
#line 95
      p ++;
    }
#line 96
    matched = 0;
#line 97
    if ((int const   )*(p + 1) == 93) {
#line 97
      goto _L;
    } else
#line 97
    if ((int const   )*(p + 1) == 45) {
      _L: /* CIL Label */ 
#line 98
      p ++;
#line 98
      if ((int const   )*p == (int const   )*text) {
#line 99
        matched = 1;
      }
    }
#line 100
    last = (int )*p;
    {
#line 100
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 100
      p ++;
#line 100
      if (*p) {
#line 100
        if (! ((int const   )*p != 93)) {
#line 100
          goto while_break___2;
        }
      } else {
#line 100
        goto while_break___2;
      }
#line 102
      if ((int const   )*p == 45) {
#line 102
        if ((int const   )*(p + 1) != 93) {
#line 102
          p ++;
#line 102
          if ((int const   )*text <= (int const   )*p) {
#line 102
            if ((int const   )*text >= (int const   )last) {
#line 102
              tmp___0 = 1;
            } else {
#line 102
              tmp___0 = 0;
            }
          } else {
#line 102
            tmp___0 = 0;
          }
#line 102
          tmp___1 = tmp___0;
        } else {
#line 102
          tmp___1 = (int const   )*text == (int const   )*p;
        }
      } else {
#line 102
        tmp___1 = (int const   )*text == (int const   )*p;
      }
#line 102
      if (tmp___1) {
#line 104
        matched = 1;
      }
#line 100
      last = (int )*p;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 105
    if (matched == reverse) {
#line 106
      return (0);
    }
#line 107
    goto __Cont;
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 65
    text ++;
#line 65
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  return ((int const   )*text == 0);
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/wildmat.c"
int wildmat(char const   *text , char const   *p ) 
{ 
  int tmp ;

  {
#line 125
  if ((int const   )*(p + 0) == 42) {
#line 125
    if ((int const   )*(p + 1) == 0) {
#line 126
      return (1);
    }
  }
  {
#line 128
  tmp = DoMatch(text, p);
  }
#line 128
  return (tmp == 1);
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/rfc822.h"
int CrackFrom(char *addr , char *name , char *p ) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/rfc822.c"
int CrackFrom(char *addr , char *name , char *p ) 
{ 
  register char *adp ;
  register char *bp ;
  register char *ap ;
  register char *cp ;
  register char CurrChar ;
  register int comment ;
  register int address ;
  register int addrfound ;
  register int QuoteNext ;
  register int InQuotes ;
  char *xp ;
  char comm[1024] ;
  char commbuf[1024] ;
  char addrbuf[1024] ;
  unsigned short const   **tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char tmp___8 ;
  char *tmp___9 ;
  char tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char tmp___13 ;
  char *tmp___14 ;
  unsigned short const   **tmp___15 ;
  char tmp___16 ;
  char *tmp___17 ;
  unsigned short const   **tmp___18 ;
  unsigned short const   **tmp___19 ;
  char tmp___20 ;
  char *tmp___21 ;
  unsigned short const   **tmp___22 ;

  {
#line 25
  cp = (char *)((void *)0);
#line 38
  *name = (char )'\000';
#line 39
  *addr = (char )'\000';
#line 41
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 42
    return (0);
  }
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
#line 45
    if (*p) {
      {
#line 45
      tmp = __ctype_b_loc();
      }
#line 45
      if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 45
        goto while_break;
      }
    } else {
#line 45
      goto while_break;
    }
#line 46
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 49
  comm[0] = (char )'\000';
#line 50
  commbuf[0] = (char )'\000';
#line 51
  addrbuf[0] = (char )'\000';
#line 52
  adp = addrbuf;
#line 53
  comment = 0;
#line 54
  addrfound = 0;
#line 55
  address = 0;
#line 56
  QuoteNext = 0;
#line 57
  InQuotes = 0;
  {
#line 58
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 58
    if (! *p) {
#line 58
      goto while_break___0;
    }
#line 59
    CurrChar = (char )(((int )*p & 127) | QuoteNext);
#line 60
    if ((int )CurrChar == 92) {
#line 60
      QuoteNext = 128;
    } else {
#line 60
      QuoteNext = 0;
    }
#line 61
    if (! comment) {
#line 61
      if ((int )CurrChar == 34) {
#line 62
        if (InQuotes) {
#line 62
          InQuotes = 0;
        } else {
#line 62
          InQuotes = 128;
        }
      } else {
#line 64
        CurrChar = (char )((int )CurrChar | InQuotes);
      }
    } else {
#line 64
      CurrChar = (char )((int )CurrChar | InQuotes);
    }
    {
#line 66
    if ((int )CurrChar == 40) {
#line 66
      goto case_40;
    }
#line 73
    if ((int )CurrChar == 41) {
#line 73
      goto case_41;
    }
#line 89
    if ((int )CurrChar == 60) {
#line 89
      goto case_60;
    }
#line 98
    if ((int )CurrChar == 62) {
#line 98
      goto case_62;
    }
#line 65
    goto switch_break;
    case_40: /* CIL Label */ 
#line 67
    if (comment == 0) {
#line 68
      cp = commbuf;
#line 69
      *cp = (char )'\000';
    }
#line 71
    comment ++;
#line 72
    goto switch_break;
    case_41: /* CIL Label */ 
#line 74
    if (comment > 0) {
#line 74
      comment --;
#line 74
      if (comment == 0) {
#line 75
        *cp = (char )'\000';
#line 76
        xp = comm;
#line 77
        if (*xp) {
          {
#line 78
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 78
            if (! *xp) {
#line 78
              goto while_break___1;
            }
#line 79
            xp ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 80
          tmp___0 = xp;
#line 80
          xp ++;
#line 80
          *tmp___0 = (char )',';
#line 81
          tmp___1 = xp;
#line 81
          xp ++;
#line 81
          *tmp___1 = (char )' ';
        }
#line 83
        cp = & commbuf[1];
        {
#line 83
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 83
          tmp___2 = xp;
#line 83
          xp ++;
#line 83
          tmp___3 = *cp;
#line 83
          *tmp___2 = tmp___3;
#line 83
          if (! ((int )tmp___3 != 0)) {
#line 83
            goto while_break___2;
          }
#line 84
          goto __Cont;
          __Cont: /* CIL Label */ 
#line 83
          cp ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 85
        cp = (char *)((void *)0);
#line 86
        goto __Cont___0;
      }
    }
#line 88
    goto switch_break;
    case_60: /* CIL Label */ 
#line 90
    if (address) {
#line 91
      return (0);
    }
#line 92
    if (! comment) {
#line 93
      address ++;
#line 94
      *adp = (char )'\000';
#line 95
      adp = addr;
    }
#line 97
    goto switch_break;
    case_62: /* CIL Label */ 
#line 99
    if (! comment) {
#line 99
      if (address) {
#line 100
        address --;
#line 101
        addrfound ++;
#line 102
        *adp = (char )'\000';
#line 102
        adp = addrbuf;
        {
#line 102
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 102
          if (! *adp) {
#line 102
            goto while_break___3;
          }
#line 103
          adp ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 104
        goto __Cont___0;
      }
    }
#line 106
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 109
    if (comment) {
#line 110
      tmp___4 = cp;
#line 110
      cp ++;
#line 110
      *tmp___4 = CurrChar;
    } else
#line 111
    if (! address) {
#line 112
      tmp___5 = adp;
#line 112
      adp ++;
#line 112
      *tmp___5 = CurrChar;
    } else
#line 111
    if ((int )CurrChar != 60) {
#line 112
      tmp___5 = adp;
#line 112
      adp ++;
#line 112
      *tmp___5 = CurrChar;
    }
#line 113
    if ((int )*p == 0) {
#line 114
      goto while_break___0;
    }
    __Cont___0: /* CIL Label */ 
#line 58
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 117
  tmp___6 = adp;
#line 117
  adp ++;
#line 117
  *tmp___6 = (char )'\000';
#line 119
  if (addrfound) {
#line 120
    ap = name;
#line 120
    xp = addrbuf;
    {
#line 120
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 120
      tmp___7 = ap;
#line 120
      ap ++;
#line 120
      tmp___8 = (char )((int )*xp & 127);
#line 120
      *tmp___7 = tmp___8;
#line 120
      if (! ((int )tmp___8 != 0)) {
#line 120
        goto while_break___4;
      }
#line 121
      goto __Cont___1;
      __Cont___1: /* CIL Label */ 
#line 120
      xp ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  } else {
#line 123
    cp = addr;
#line 123
    xp = addrbuf;
    {
#line 123
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 123
      tmp___9 = cp;
#line 123
      cp ++;
#line 123
      tmp___10 = *xp;
#line 123
      *tmp___9 = tmp___10;
#line 123
      if (! ((int )tmp___10 != 0)) {
#line 123
        goto while_break___5;
      }
#line 124
      goto __Cont___2;
      __Cont___2: /* CIL Label */ 
#line 123
      xp ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 125
    *name = (char )'\000';
  }
#line 130
  if (comm[0]) {
#line 131
    ap = name;
#line 132
    if (*ap) {
      {
#line 133
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 133
        if (! *ap) {
#line 133
          goto while_break___6;
        }
#line 134
        ap ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 135
      tmp___11 = ap;
#line 135
      ap ++;
#line 135
      *tmp___11 = (char )',';
#line 136
      tmp___12 = ap;
#line 136
      ap ++;
#line 136
      *tmp___12 = (char )' ';
    }
#line 138
    xp = comm;
    {
#line 138
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 138
      tmp___14 = xp;
#line 138
      xp ++;
#line 138
      tmp___13 = (char )((int )*tmp___14 & 127);
#line 138
      *ap = tmp___13;
#line 138
      if (! ((int )tmp___13 != 0)) {
#line 138
        goto while_break___7;
      }
#line 139
      goto __Cont___3;
      __Cont___3: /* CIL Label */ 
#line 138
      ap ++;
    }
    while_break___7: /* CIL Label */ ;
    }
  }
#line 142
  cp = addr;
  {
#line 142
  while (1) {
    while_continue___8: /* CIL Label */ ;
    {
#line 142
    tmp___15 = __ctype_b_loc();
    }
#line 142
    if (! ((int const   )*(*tmp___15 + (int )*cp) & 8192)) {
#line 142
      goto while_break___8;
    }
#line 143
    goto __Cont___4;
    __Cont___4: /* CIL Label */ 
#line 142
    cp ++;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 144
  xp = addr;
  {
#line 144
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 144
    tmp___17 = cp;
#line 144
    cp ++;
#line 144
    tmp___16 = *tmp___17;
#line 144
    *xp = tmp___16;
#line 144
    if (! ((int )tmp___16 != 0)) {
#line 144
      goto while_break___9;
    }
#line 145
    xp ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 146
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 146
    if (*addr) {
      {
#line 146
      tmp___18 = __ctype_b_loc();
#line 146
      xp --;
      }
#line 146
      if (! ((int const   )*(*tmp___18 + (int )*xp) & 8192)) {
#line 146
        goto while_break___10;
      }
    } else {
#line 146
      goto while_break___10;
    }
#line 147
    *xp = (char )'\000';
  }
  while_break___10: /* CIL Label */ ;
  }
#line 152
  ap = name;
#line 152
  bp = name;
  {
#line 152
  while (1) {
    while_continue___11: /* CIL Label */ ;
    {
#line 152
    tmp___19 = __ctype_b_loc();
    }
#line 152
    if (! ((int const   )*(*tmp___19 + (int )*bp) & 8192)) {
#line 152
      if (! ((int )*bp == 34)) {
#line 152
        if (! ((int )*bp == 40)) {
#line 152
          if (! ((int )*bp == 41)) {
#line 152
            if (! ((int )*bp == 92)) {
#line 152
              goto while_break___11;
            }
          }
        }
      }
    }
#line 153
    goto __Cont___5;
    __Cont___5: /* CIL Label */ 
#line 152
    bp ++;
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 154
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 154
    tmp___21 = bp;
#line 154
    bp ++;
#line 154
    tmp___20 = *tmp___21;
#line 154
    *ap = tmp___20;
#line 154
    if (! ((int )tmp___20 != 0)) {
#line 154
      goto while_break___12;
    }
#line 155
    if (! ((int )*ap == 34)) {
#line 155
      if (! ((int )*ap == 40)) {
#line 155
        if (! ((int )*ap == 41)) {
#line 155
          if (! ((int )*ap == 92)) {
#line 156
            ap ++;
          }
        }
      }
    }
  }
  while_break___12: /* CIL Label */ ;
  }
  {
#line 157
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 157
    if (*name) {
      {
#line 157
      tmp___22 = __ctype_b_loc();
#line 157
      ap --;
      }
#line 157
      if (! ((int const   )*(*tmp___22 + (int )*ap) & 8192)) {
#line 157
        goto while_break___13;
      }
    } else {
#line 157
      goto while_break___13;
    }
#line 158
    *ap = (char )'\000';
  }
  while_break___13: /* CIL Label */ ;
  }
#line 159
  return (1);
}
}
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 106 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.h"
LIST *read_groups(int fd , LIST *exclusion_list ) ;
#line 107
int subscribed(LIST *sub_list , char const   *gname ) ;
#line 108
LIST *create_list(void) ;
#line 109
void add_group(LIST *list___0 , GROUP *group ) ;
#line 110
void remove_group(LIST *list___0 , GROUP *group ) ;
#line 111
extern GROUP *create_group(int not_flag , char const   *name ) ;
#line 112
void destroy_group(GROUP *gp ) ;
#line 8 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/misc.c"
LIST *read_groups(int fd , LIST *exclusion_list ) 
{ 
  LIST *list___0 ;
  GROUP *gp ;
  char *name ;
  int not ;
  int exclude___0 ;
  struct stat sb ;
  int length ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  ssize_t tmp___3 ;
  char *eoln ;
  char *p ;
  int tmp___4 ;

  {
  {
#line 22
  list___0 = create_list();
#line 61
  tmp___1 = fstat(fd, & sb);
  }
#line 61
  if (tmp___1 < 0) {
    {
#line 62
    tmp = __errno_location();
#line 62
    tmp___0 = strerror(*tmp);
#line 62
    logit(1 | (1 << 1), "ERROR: read_groups: could not stat file (%s)", tmp___0);
    }
#line 64
    return (list___0);
  }
  {
#line 67
  tmp___2 = malloc((size_t )(sb.st_size + 1L));
#line 67
  name = (char *)tmp___2;
  }
#line 68
  if (! name) {
    {
#line 69
    gupout(1, "Could not malloc space for groups list");
    }
  }
  {
#line 72
  tmp___3 = read(fd, (void *)name, (size_t )((int )sb.st_size));
#line 72
  length = (int )tmp___3;
  }
#line 73
  if ((__off_t )length != sb.st_size) {
    {
#line 74
    gupout(1, "Error reading groups file");
    }
  }
#line 77
  *(name + length) = (char)0;
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
#line 83
    if (! *name) {
#line 83
      goto while_break;
    }
    {
#line 90
    eoln = strchr((char const   *)name, '\n');
    }
#line 90
    if (eoln) {
#line 91
      *eoln = (char)0;
    } else {
      {
#line 93
      logit(1, "WARNING: premature end of groups file");
      }
    }
    {
#line 96
    p = strchr((char const   *)name, ' ');
    }
#line 96
    if (p) {
#line 97
      *p = (char )'\000';
    }
#line 99
    if ((int )*(name + 0) == 33) {
#line 100
      name ++;
#line 101
      not = 1;
    } else
#line 102
    if ((int )*(name + 0) == 64) {
#line 103
      name ++;
#line 104
      not = 2;
    } else {
#line 106
      not = 0;
    }
#line 109
    exclude___0 = 0;
#line 110
    if (exclusion_list) {
#line 110
      gp = exclusion_list->head;
      {
#line 110
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 110
        if (! gp) {
#line 110
          goto while_break___0;
        }
        {
#line 111
        tmp___4 = wildmat((char const   *)name, gp->name);
        }
#line 111
        if (tmp___4) {
#line 112
          exclude___0 = ! gp->u.not;
        }
#line 110
        gp = gp->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 115
    if (! exclude___0) {
      {
#line 116
      gp = create_group(not, (char const   *)name);
#line 117
      add_group(list___0, gp);
      }
    }
#line 120
    name = eoln + 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 124
  return (list___0);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/misc.c"
int subscribed(LIST *sub_list , char const   *gname ) 
{ 
  int unsub ;
  GROUP *gp ;
  int tmp ;

  {
#line 130
  unsub = 1;
#line 133
  if (sub_list) {
#line 133
    gp = sub_list->head;
    {
#line 133
    while (1) {
      while_continue: /* CIL Label */ ;
#line 133
      if (! gp) {
#line 133
        goto while_break;
      }
#line 134
      if (unsub != gp->u.not) {
        {
#line 134
        tmp = wildmat(gname, gp->name);
        }
#line 134
        if (tmp) {
#line 135
          unsub = gp->u.not;
        }
      }
#line 133
      gp = gp->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 137
  return (! unsub);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/misc.c"
LIST *create_list(void) 
{ 
  LIST *l ;
  void *tmp ;
  GROUP *tmp___0 ;

  {
  {
#line 144
  tmp = malloc(sizeof(LIST ));
#line 144
  l = (LIST *)tmp;
  }
#line 145
  if (! l) {
    {
#line 146
    gupout(1, "malloc of LIST failed");
    }
  }
#line 147
  tmp___0 = (GROUP *)((void *)0);
#line 147
  l->tail = tmp___0;
#line 147
  l->head = tmp___0;
#line 148
  l->length = 0U;
#line 149
  return (l);
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/misc.c"
void add_group(LIST *list___0 , GROUP *group ) 
{ 
  GROUP *tmp ;

  {
#line 154
  if (! list___0->head) {
#line 155
    tmp = group;
#line 155
    list___0->tail = tmp;
#line 155
    list___0->head = tmp;
  } else {
#line 157
    (list___0->tail)->next = group;
#line 158
    list___0->tail = group;
  }
#line 160
  (list___0->length) ++;
#line 161
  group->next = (GROUP *)((void *)0);
#line 162
  return;
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/misc.c"
void remove_group(LIST *list___0 , GROUP *group ) 
{ 
  GROUP *prev ;
  GROUP *tmp ;

  {
#line 168
  prev = (GROUP *)((void *)0);
#line 169
  tmp = list___0->head;
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    if (! tmp) {
#line 169
      goto while_break;
    }
#line 170
    if ((unsigned long )tmp == (unsigned long )group) {
#line 171
      goto while_break;
    }
#line 172
    prev = tmp;
#line 169
    tmp = tmp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  if (! tmp) {
    {
#line 176
    logit(1 | (1 << 1), "ERROR: remove_group can\'t find group");
    }
#line 177
    return;
  }
#line 180
  if (! prev) {
#line 181
    list___0->head = group->next;
  } else {
#line 183
    prev->next = group->next;
  }
#line 185
  if (! group->next) {
#line 186
    list___0->tail = prev;
  }
#line 188
  (list___0->length) --;
#line 195
  return;
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/misc.c"
extern GROUP *create_group(int not_flag , char const   *name ) 
{ 
  GROUP *gp ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 201
  tmp = malloc(sizeof(GROUP ));
#line 201
  gp = (GROUP *)tmp;
  }
#line 202
  if (! gp) {
    {
#line 203
    gupout(1, "malloc of GROUP failed");
    }
  }
  {
#line 205
  gp->next = (GROUP *)((void *)0);
#line 206
  gp->u.not = not_flag;
#line 207
  tmp___0 = xstrdup(name);
#line 207
  gp->name = (char const   *)tmp___0;
#line 208
  gp->desc = "";
  }
#line 210
  return (gp);
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/misc.c"
void destroy_group(GROUP *gp ) 
{ 


  {
  {
#line 215
  free((void *)gp);
  }
#line 216
  return;
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/misc.c"
char *xstrdup(char const   *str ) 
{ 
  char *res ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 222
  tmp = strlen(str);
#line 222
  tmp___0 = malloc(tmp + 1UL);
#line 222
  res = (char *)tmp___0;
  }
#line 223
  if (! res) {
    {
#line 224
    tmp___1 = strlen(str);
#line 224
    gupout(1, "xstrdup of %d failed", tmp___1);
    }
  }
  {
#line 225
  tmp___2 = strcpy((char */* __restrict  */)res, (char const   */* __restrict  */)str);
  }
#line 225
  return (tmp___2);
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.h"
void prune(LIST *active_l , LIST *group_l ) ;
#line 140
int maxgroups ;
#line 17 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/prune.c"
void prune(LIST *active_l , LIST *group_l ) 
{ 
  GROUP *gp ;
  GROUP *ap ;
  int groupcount ;
  TAG *t ;
  void *tmp ;
  int tmp___0 ;
  int effect ;
  TAG *tag ;
  TAG *t___0 ;
  TAG *prev ;
  char const   *tmp___1 ;

  {
#line 23
  groupcount = 0;
#line 25
  if (active_l) {
#line 25
    ap = active_l->head;
    {
#line 25
    while (1) {
      while_continue: /* CIL Label */ ;
#line 25
      if (! ap) {
#line 25
        goto while_break;
      }
#line 26
      ap->u.tag = (TAG *)((void *)0);
#line 28
      if (group_l) {
#line 28
        gp = group_l->head;
        {
#line 28
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 28
          if (! gp) {
#line 28
            goto while_break___0;
          }
          {
#line 29
          tmp___0 = wildmat(ap->name, gp->name);
          }
#line 29
          if (tmp___0) {
            {
#line 30
            tmp = malloc(sizeof(TAG ));
#line 30
            t = (TAG *)tmp;
            }
#line 31
            if (! t) {
              {
#line 32
              logit(1 | (1 << 1), "WARNING: insufficient memory to prune!");
              }
#line 33
              return;
            }
#line 36
            t->group = gp;
#line 37
            t->next = ap->u.tag;
#line 38
            ap->u.tag = t;
          }
#line 28
          gp = gp->next;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 41
      if (ap) {
#line 41
        if (ap->u.tag) {
#line 41
          if ((ap->u.tag)->group) {
#line 42
            if (((ap->u.tag)->group)->u.not == 0) {
#line 43
              groupcount ++;
            }
          }
        }
      }
#line 25
      ap = ap->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 47
  if (groupcount > maxgroups) {
    {
#line 48
    gupout(1, "Too many groups (%d, only %d allowed)", groupcount, maxgroups);
    }
  }
#line 52
  if (group_l) {
#line 52
    gp = group_l->head;
    {
#line 52
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 52
      if (! gp) {
#line 52
        goto while_break___1;
      }
#line 53
      effect = 0;
#line 55
      if (active_l) {
#line 55
        ap = active_l->head;
        {
#line 55
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 55
          if (! ap) {
#line 55
            goto while_break___2;
          }
#line 56
          tag = ap->u.tag;
#line 59
          if (tag) {
#line 59
            if ((unsigned long )tag->group == (unsigned long )gp) {
#line 59
              if (! tag->next) {
#line 59
                if (! gp->u.not) {
#line 61
                  effect = 1;
#line 62
                  goto while_break___2;
                } else {
#line 59
                  goto _L;
                }
              } else
              _L: /* CIL Label */ 
#line 59
              if (tag->next) {
#line 59
                if (((tag->next)->group)->u.not != gp->u.not) {
#line 61
                  effect = 1;
#line 62
                  goto while_break___2;
                }
              }
            }
          }
#line 55
          ap = ap->next;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 66
      if (! effect) {
#line 66
        if (gp->u.not != 2) {
#line 76
          if (active_l) {
#line 76
            ap = active_l->head;
            {
#line 76
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 76
              if (! ap) {
#line 76
                goto while_break___3;
              }
#line 79
              prev = (TAG *)((void *)0);
#line 79
              t___0 = ap->u.tag;
              {
#line 79
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 79
                if (! t___0) {
#line 79
                  goto while_break___4;
                }
#line 80
                if ((unsigned long )t___0->group == (unsigned long )gp) {
#line 81
                  if (! prev) {
#line 82
                    ap->u.tag = t___0->next;
                  } else {
#line 84
                    prev->next = t___0->next;
                  }
                  {
#line 85
                  free((void *)t___0);
                  }
#line 87
                  goto while_break___4;
                }
#line 79
                prev = t___0;
#line 79
                t___0 = t___0->next;
              }
              while_break___4: /* CIL Label */ ;
              }
#line 76
              ap = ap->next;
            }
            while_break___3: /* CIL Label */ ;
            }
          }
          {
#line 92
          remove_group(group_l, gp);
          }
#line 94
          if (gp->u.not) {
#line 94
            tmp___1 = "exclude";
          } else {
#line 94
            tmp___1 = "include";
          }
          {
#line 94
          logit(1 | (1 << 1), "PRUNED: %s %s subsumed", tmp___1, gp->name);
          }
        }
      }
#line 52
      gp = gp->next;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 98
  return;
}
}
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 99 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.h"
extern void print_newsgroups(FILE *fp , char const   *gname ) ;
#line 135
char const   *newsgroups_path ;
#line 137
LIST *active_list ;
#line 138
LIST *group_list ;
#line 3 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/newsgroups.c"
static int newsgroups_loaded  =    0;
#line 5
static void load_newsgroups(void) ;
#line 8 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/newsgroups.c"
extern void print_newsgroups(FILE *fp , char const   *gname ) 
{ 
  GROUP *gp ;
  int glen ;
  int subflag ;
  int gcount ;
  int subcount ;
  size_t tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
#line 13
  gcount = 0;
#line 14
  subcount = 0;
#line 16
  if (! newsgroups_loaded) {
    {
#line 17
    load_newsgroups();
    }
  }
  {
#line 20
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n%-*s Sub Description\n",
          25, "Name");
#line 22
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%-*s --- ----------------------------------------\n",
          25, "---------------");
  }
#line 25
  if (active_list) {
#line 25
    gp = active_list->head;
    {
#line 25
    while (1) {
      while_continue: /* CIL Label */ ;
#line 25
      if (! gp) {
#line 25
        goto while_break;
      }
      {
#line 26
      tmp___2 = wildmat(gp->name, gname);
      }
#line 26
      if (tmp___2) {
        {
#line 27
        gcount ++;
#line 28
        subflag = subscribed(group_list, gp->name);
        }
#line 29
        if (subflag) {
#line 30
          subcount ++;
        }
        {
#line 32
        fputs((char const   */* __restrict  */)gp->name, (FILE */* __restrict  */)fp);
#line 40
        tmp = strlen(gp->name);
#line 40
        glen = (int )tmp;
        }
#line 41
        if (glen > 25) {
          {
#line 42
          glen = 0;
#line 43
          _IO_putc('\n', fp);
          }
        }
#line 45
        glen = (25 - glen) + 1;
        {
#line 46
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 46
          tmp___0 = glen;
#line 46
          glen --;
#line 46
          if (! (tmp___0 > 0)) {
#line 46
            goto while_break___0;
          }
          {
#line 47
          _IO_putc(' ', fp);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 49
        if (subflag) {
#line 49
          tmp___1 = "Yes";
        } else {
#line 49
          tmp___1 = "No ";
        }
        {
#line 49
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s %s\n",
                tmp___1, gp->desc);
        }
      }
#line 25
      gp = gp->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 52
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%-*s --- ----------------------------------------\n",
          25, "---------------");
#line 54
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\nGroups listed: %d, of which you subscribe to %d.\n\n",
          gcount, subcount);
  }
#line 56
  return;
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/newsgroups.c"
static void load_newsgroups(void) 
{ 
  int fd ;
  struct stat sb ;
  char *desc ;
  int length ;
  GROUP *gp ;
  int tmp ;
  void *tmp___0 ;
  ssize_t tmp___1 ;
  char *eoln ;
  char *p ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 72
  gp = (GROUP *)((void *)0);
#line 74
  newsgroups_loaded = 1;
#line 75
  if (! newsgroups_path) {
    {
#line 76
    logit(1 | (1 << 1), "WARNING: No newsgroups file defined - needed for descriptions");
    }
#line 78
    return;
  } else
#line 75
  if (! *newsgroups_path) {
    {
#line 76
    logit(1 | (1 << 1), "WARNING: No newsgroups file defined - needed for descriptions");
    }
#line 78
    return;
  }
  {
#line 119
  fd = open(newsgroups_path, 0);
  }
#line 119
  if (fd < 0) {
    {
#line 120
    logit(1 | (1 << 1), "WARNING: Could not open newsgroups file \'%s\'", newsgroups_path);
    }
#line 122
    return;
  }
  {
#line 125
  tmp = fstat(fd, & sb);
  }
#line 125
  if (tmp < 0) {
    {
#line 126
    logit(1 | (1 << 1), "WARNING: Could not stat newsgroups file \'%s\'", newsgroups_path);
    }
#line 128
    return;
  }
  {
#line 131
  tmp___0 = malloc((size_t )(sb.st_size + 1L));
#line 131
  desc = (char *)tmp___0;
  }
#line 132
  if (! desc) {
    {
#line 133
    logit(1 | (1 << 1), "WARNING: Could not malloc space for newsgroups");
    }
#line 134
    return;
  }
  {
#line 137
  tmp___1 = read(fd, (void *)desc, (size_t )((int )sb.st_size));
#line 137
  length = (int )tmp___1;
  }
#line 138
  if ((__off_t )length != sb.st_size) {
    {
#line 139
    logit(1 | (1 << 1), "WARNING: Error reading newsgroups");
    }
#line 140
    return;
  }
#line 143
  *(desc + length) = (char)0;
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 149
    if (! *desc) {
#line 149
      goto while_break;
    }
    {
#line 156
    eoln = strchr((char const   *)desc, '\n');
    }
#line 156
    if (eoln) {
#line 157
      *eoln = (char)0;
    } else {
      {
#line 159
      logit(1, "WARNING: premature end of newsgroups file");
      }
    }
    {
#line 162
    p = strchr((char const   *)desc, '\t');
    }
#line 162
    if (p) {
#line 163
      *p = (char)0;
      {
#line 165
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 165
        tmp___2 = __ctype_b_loc();
#line 165
        p ++;
        }
#line 165
        if (! ((int const   )*(*tmp___2 + (int )*p) & 8192)) {
#line 165
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 168
      if (*p) {
#line 173
        if (gp) {
          {
#line 173
          tmp___4 = strcmp(gp->name, (char const   *)desc);
          }
#line 173
          if (tmp___4) {
#line 173
            goto _L;
          } else {
#line 174
            gp->desc = (char const   *)p;
          }
        } else
        _L: /* CIL Label */ 
#line 176
        if (active_list) {
#line 176
          gp = active_list->head;
          {
#line 176
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 176
            if (! gp) {
#line 176
              goto while_break___1;
            }
            {
#line 177
            tmp___3 = strcmp(gp->name, (char const   *)desc);
            }
#line 177
            if (! tmp___3) {
#line 177
              if (! *(gp->desc)) {
#line 178
                gp->desc = (char const   *)p;
#line 181
                gp = gp->next;
#line 182
                goto while_break___1;
              }
            }
#line 176
            gp = gp->next;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
      }
    }
#line 189
    desc = eoln + 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 192
  return;
}
}
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 765
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 120 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.h"
extern LIST *sort_groups(LIST *glist ) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/sort.c"
static int mat_compare(GROUP const   **g1 , GROUP const   **g2 ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/sort.c"
extern LIST *sort_groups(LIST *glist ) 
{ 
  LIST *slist ;
  GROUP **stab ;
  GROUP *gp ;
  int st_ix ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 33
  tmp = calloc((size_t )glist->length, sizeof(GROUP *));
#line 33
  stab = (GROUP **)tmp;
  }
#line 34
  if (! stab) {
    {
#line 35
    gupout(1, "Malloc of sort table failed");
    }
  }
#line 37
  st_ix = 0;
#line 38
  if (glist) {
#line 38
    gp = glist->head;
    {
#line 38
    while (1) {
      while_continue: /* CIL Label */ ;
#line 38
      if (! gp) {
#line 38
        goto while_break;
      }
#line 39
      gp->order = st_ix;
#line 40
      tmp___0 = st_ix;
#line 40
      st_ix ++;
#line 40
      *(stab + tmp___0) = gp;
#line 38
      gp = gp->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 44
  qsort((void *)stab, (size_t )glist->length, sizeof(GROUP *), (int (*)(void const   * ,
                                                                        void const   * ))(& mat_compare));
#line 47
  slist = create_list();
#line 49
  st_ix = 0;
  }
  {
#line 49
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 49
    if (! ((unsigned int )st_ix < glist->length)) {
#line 49
      goto while_break___0;
    }
    {
#line 50
    add_group(slist, *(stab + st_ix));
#line 49
    st_ix ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 52
  free((void *)stab);
#line 53
  free((void *)glist);
  }
#line 55
  return (slist);
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/sort.c"
static int mat_compare(GROUP const   **g1 , GROUP const   **g2 ) 
{ 
  register char c1 ;
  register char c2 ;
  char const   *cp1 ;
  char const   *cp2 ;

  {
#line 64
  cp1 = (char const   *)(*g1)->name;
#line 64
  cp2 = (char const   *)(*g2)->name;
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    c1 = (char )*cp1;
#line 66
    c2 = (char )*cp2;
#line 68
    if (! c1) {
#line 69
      return ((int )c1 - (int )c2);
    } else
#line 68
    if (! c2) {
#line 69
      return ((int )c1 - (int )c2);
    }
#line 72
    if ((int )c1 == 92) {
#line 74
      return ((int )((*g1)->order - (*g2)->order));
    } else
#line 72
    if ((int )c1 == 63) {
#line 74
      return ((int )((*g1)->order - (*g2)->order));
    } else
#line 72
    if ((int )c1 == 42) {
#line 74
      return ((int )((*g1)->order - (*g2)->order));
    } else
#line 72
    if ((int )c1 == 91) {
#line 74
      return ((int )((*g1)->order - (*g2)->order));
    } else
#line 72
    if ((int )c2 == 92) {
#line 74
      return ((int )((*g1)->order - (*g2)->order));
    } else
#line 72
    if ((int )c2 == 63) {
#line 74
      return ((int )((*g1)->order - (*g2)->order));
    } else
#line 72
    if ((int )c2 == 42) {
#line 74
      return ((int )((*g1)->order - (*g2)->order));
    } else
#line 72
    if ((int )c2 == 91) {
#line 74
      return ((int )((*g1)->order - (*g2)->order));
    }
#line 75
    if ((int )c1 != (int )c2) {
#line 76
      return ((int )c1 - (int )c2);
    }
#line 64
    cp1 ++;
#line 64
    cp2 ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/file.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) flock)(int __fd ,
                                                                            int __operation ) ;
#line 102 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.h"
int lockit(void) ;
#line 103
void unlockit(void) ;
#line 3 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/lock.c"
static int locked  =    0;
#line 6 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/lock.c"
int lockit(void) 
{ 
  int fd ;
  int tmp ;

  {
  {
#line 15
  fd = open(".", 0);
  }
#line 15
  if (fd >= 0) {
    {
#line 16
    tmp = flock(fd, 2);
    }
#line 16
    if (tmp == 0) {
#line 17
      locked = 1;
#line 18
      return (1);
    }
    {
#line 21
    logit(1, "WARNING: flock failed");
#line 22
    close(fd);
    }
  }
#line 58
  return (0);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/lock.c"
void unlockit(void) 
{ 
  int fd ;
  int tmp ;

  {
#line 64
  if (locked) {
    {
#line 69
    locked = 0;
#line 72
    fd = open(".", 0);
    }
#line 72
    if (fd >= 0) {
      {
#line 73
      tmp = flock(fd, 8);
      }
#line 73
      if (tmp == 0) {
        {
#line 74
        close(fd);
        }
#line 75
        return;
      }
      {
#line 77
      logit(1, "WARNING: unflock failed");
#line 78
      close(fd);
      }
    }
  }
#line 92
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 170
extern struct _IO_FILE *stderr ;
#line 180
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 534 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 497 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 1120 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) crypt)(char const   *__key ,
                                                                                                char const   *__salt ) ;
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 312 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 321
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 95 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.h"
void vlogit(int lflags , char const   *prefix , char const   *log_msg , va_list AP ) ;
#line 98
int help(char const   **tokens ) ;
#line 129
char const   *progname ;
#line 131 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.h"
FILE *log_fp  ;
#line 132 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.h"
FILE *mail_fp  ;
#line 134 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.h"
char const   *active_path  ;
#line 135 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.h"
char const   *newsgroups_path  ;
#line 137 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.h"
LIST *active_list  ;
#line 138 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.h"
LIST *group_list  ;
#line 140 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.h"
int maxgroups  ;
#line 40 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.c"
char const   *progname  =    "gup";
#line 42 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.c"
static char const   *usage  =    "\nUsage: %s\t[-hvP] -a active_path [-d home_directory] [-l log_path]\n\t\t[-m reply_headers] [-n newsgroups_path] [-s sites_directory]\n[-M Mail_command] [-G maxgroups]\n\nGroup Update Program: mail-server for remote newfeed changes.\n\n-a\tThe news system\'s \'active\' file - used to validate newsgroups\n-d\tgup\'s home directory (default: .)\n-h\tPrint usage then exit\n-l\tLog file for writing significant events (default: ./log)\n-m\tfile containing rfc822 headers to send to the recipient\n\n-n\tThe newsgroups file - used for newsgroups descriptions\n-M\tResultant mail piped to this command\n-P\tDo not prune newsgroup selections (prune is CP intensive)\n-s\tLocation of the site directories (default: ./sites)\n-v\tPrint version and build options, then exit.\n-G\tMaximum number of subscriptions allowed\n\n";
#line 75
static void parse_options(int argc , char **argv ) ;
#line 76
static void parse_headers(void) ;
#line 77
static int parse_commands(void) ;
#line 78
static void load_active(LIST *exclusion_list ) ;
#line 79
static void write_groups(void) ;
#line 80
static void print_version(void) ;
#line 81
static void log_mail_headers(void) ;
#line 82
static void item_print(int indent , int *column , char const   *str ) ;
#line 84
static int getoneline(FILE *fp ) ;
#line 85
static int tokenize(char *cp , char const   **tokens , int max_tokens ) ;
#line 86
static int command_cmp(char const   *str , char const   *cmd ) ;
#line 87
static int site(char const   **tokens ) ;
#line 88
static int include(char const   **tokens ) ;
#line 89
static int exclude(char const   **tokens ) ;
#line 90
static int poison(char const   **tokens ) ;
#line 91
static int insert_group(int not_flag , char const   *gname ) ;
#line 92
static int delete(char const   **tokens ) ;
#line 93
static int list(char const   **tokens ) ;
#line 94
static int quit(char const   **tokens ) ;
#line 95
static int newsgroups(char const   **tokens ) ;
#line 99 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.c"
static COMMAND C_list[16]  = 
#line 99
  {      {"inc*lude", & include, 2, 1, 0}, 
        {"+", & include, 2, 1, 0}, 
        {"exc*lude", & exclude, 2, 1, 0}, 
        {"poi*son", & poison, 2, 1, 0}, 
        {"-", & exclude, 2, 1, 0}, 
        {"l*ist", & list, 0, 1, 0}, 
        {"he*lp", & help, 0, 0, 1}, 
        {"del*ete", & delete, 2, 1, 0}, 
        {"s*ite", & site, 3, 0, 0}, 
        {"o*pen", & site, 3, 0, 0}, 
        {"host", & site, 3, 0, 0}, 
        {"news*groups", & newsgroups, 2, 1, 0}, 
        {"q*uit", & quit, 0, 1, 1}, 
        {"--", & quit, 0, 1, 1}, 
        {"c*lose", & quit, 0, 1, 1}, 
        {(char const   *)((void *)0), (int (*)(char const   ** ))0, 0, 0, 0}};
#line 120 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.c"
static int seen_site  =    0;
#line 121 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.c"
static int do_prune  =    1;
#line 122 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.c"
static char *sitename  ;
#line 124 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.c"
static char const   *site_directory  =    "sites";
#line 126 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.c"
static char curr_line[512]  ;
#line 128 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.c"
static int quit_flag  ;
#line 131 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.c"
static char *h_from  =    (char *)((void *)0);
#line 132 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.c"
static char *h_reply_to  =    (char *)((void *)0);
#line 133 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.c"
static char *h_date  =    (char *)((void *)0);
#line 134 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.c"
static char *h_subject  =    (char *)((void *)0);
#line 135 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.c"
static char *h_message_id  =    (char *)((void *)0);
#line 136 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.c"
static char *h_return_path  =    (char *)((void *)0);
#line 155 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.c"
int main(int argc , char **argv ) 
{ 
  int changed ;

  {
  {
#line 159
  umask((__mode_t )18);
#line 161
  parse_options(argc, argv);
#line 163
  quit_flag = 0;
#line 164
  parse_headers();
#line 165
  changed = parse_commands();
  }
#line 167
  if (! seen_site) {
    {
#line 168
    gupout(0, "No \'site\' command found");
    }
  }
#line 170
  if (changed) {
    {
#line 171
    group_list = sort_groups(group_list);
    }
#line 172
    if (do_prune) {
      {
#line 173
      logit(1 << 1, "");
#line 174
      logit((1 | (1 << 1)) | (1 << 2), "Checking new group list");
#line 175
      prune(active_list, group_list);
      }
    }
    {
#line 177
    logit((1 | (1 << 1)) | (1 << 2), "Writing updated group list");
#line 178
    write_groups();
    }
  }
  {
#line 180
  gupout(0, (char const   *)((void *)0));
  }
}
}
#line 185 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.c"
static void parse_options(int argc , char **argv ) 
{ 
  int cc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 189
  active_path = "/var/lib/news/active";
#line 190
  newsgroups_path = "/var/lib/news/newsgroups";
#line 191
  mail_fp = mail_open(0, "news", "/usr/sbin/sendmail -oi -t", (char const   *)((void *)0));
#line 192
  maxgroups = 32767;
  }
  {
#line 194
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 194
    cc = getopt(argc, (char * const  *)argv, "a:d:hs:l:n:m:M:PvG:");
    }
#line 194
    if (! (cc != -1)) {
#line 194
      goto while_break;
    }
    {
#line 196
    if (cc == 97) {
#line 196
      goto case_97;
    }
#line 199
    if (cc == 100) {
#line 199
      goto case_100;
    }
#line 204
    if (cc == 104) {
#line 204
      goto case_104;
    }
#line 207
    if (cc == 115) {
#line 207
      goto case_115;
    }
#line 210
    if (cc == 108) {
#line 210
      goto case_108;
    }
#line 219
    if (cc == 109) {
#line 219
      goto case_109;
    }
#line 222
    if (cc == 77) {
#line 222
      goto case_77;
    }
#line 225
    if (cc == 80) {
#line 225
      goto case_80;
    }
#line 228
    if (cc == 110) {
#line 228
      goto case_110;
    }
#line 231
    if (cc == 118) {
#line 231
      goto case_118;
    }
#line 234
    if (cc == 71) {
#line 234
      goto case_71;
    }
#line 237
    goto switch_default;
    case_97: /* CIL Label */ 
#line 197
    active_path = (char const   *)optarg;
#line 198
    goto switch_break;
    case_100: /* CIL Label */ 
#line 200
    if (optarg) {
      {
#line 201
      tmp = chdir((char const   *)optarg);
      }
#line 201
      if (tmp) {
        {
#line 202
        gupout(1, "Could not chdir to %s", optarg);
        }
      }
    }
#line 203
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 205
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)usage,
            progname);
#line 206
    exit(0);
    }
    case_115: /* CIL Label */ 
#line 208
    site_directory = (char const   *)optarg;
#line 209
    goto switch_break;
    case_108: /* CIL Label */ 
#line 211
    if (optarg) {
      {
#line 212
      log_fp = fopen((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"a");
      }
#line 212
      if (! log_fp) {
        {
#line 213
        gupout(1, "%s: Could not open log file: %s\n", progname, optarg);
        }
      }
      {
#line 215
      tmp___0 = fileno(stderr);
#line 215
      tmp___1 = fileno(log_fp);
#line 215
      tmp___2 = dup2(tmp___1, tmp___0);
      }
#line 215
      if (tmp___2 < 0) {
        {
#line 216
        gupout(1, "dup2() failed");
        }
      }
    }
#line 218
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 220
    mail_fp = mail_open(0, (char const   *)((void *)0), (char const   *)((void *)0),
                        (char const   *)optarg);
    }
#line 221
    goto switch_break;
    case_77: /* CIL Label */ 
    {
#line 223
    mail_fp = mail_open(0, (char const   *)((void *)0), (char const   *)optarg, (char const   *)((void *)0));
    }
#line 224
    goto switch_break;
    case_80: /* CIL Label */ 
#line 226
    do_prune = 0;
#line 227
    goto switch_break;
    case_110: /* CIL Label */ 
#line 229
    newsgroups_path = (char const   *)optarg;
#line 230
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 232
    print_version();
#line 233
    exit(0);
    }
    case_71: /* CIL Label */ 
    {
#line 235
    maxgroups = atoi((char const   *)optarg);
    }
#line 236
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 238
    gupout(1, "Installation problem. Invalid option used");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 244
  if (! active_path) {
    {
#line 245
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Must nominate the active file with -a\n",
            progname);
#line 247
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)usage,
            progname);
#line 248
    gupout(1, (char const   *)((void *)0));
    }
  } else
#line 244
  if (! *active_path) {
    {
#line 245
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Must nominate the active file with -a\n",
            progname);
#line 247
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)usage,
            progname);
#line 248
    gupout(1, (char const   *)((void *)0));
    }
  }
#line 250
  return;
}
}
#line 252 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.c"
static void print_version(void) 
{ 


  {
  {
#line 254
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Version: %s.\n",
          progname, "0.5.7");
#line 255
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"CONFIG_FILENAME:  \'%s\'\n",
          "config");
#line 256
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ACTIVE_PATH:      \'%s\'\n",
          "/var/lib/news/active");
#line 257
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"NEWSGROUPS_PATH:  \'%s\'\n",
          "/var/lib/news/newsgroups");
#line 258
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"MAIL_COMMAND:     \'%s\'\n",
          "/usr/sbin/sendmail -oi -t");
#line 259
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"BACKSTOP_MAILID:  \'%s\'\n",
          "news");
#line 260
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"UMASK:            %03o\n",
          18);
#line 262
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"LOCKING uses:     flock(2)\n");
  }
#line 267
  return;
}
}
#line 276 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.c"
static void parse_headers(void) 
{ 
  char buf1[1024] ;
  char buf2[1024] ;
  int tmp ;
  char buf1___0[1024] ;
  char buf2___0[1024] ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 278
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 278
    tmp___5 = getoneline(stdin);
    }
#line 278
    if (! tmp___5) {
#line 278
      goto while_break;
    }
#line 279
    if (! curr_line[0]) {
#line 280
      return;
    }
    {
#line 282
    tmp = strncasecmp((char const   *)(curr_line), "FROM:", (size_t )5);
    }
#line 282
    if (tmp == 0) {
      {
#line 285
      CrackFrom(buf1, buf2, curr_line + 5);
#line 286
      h_from = xstrdup((char const   *)(buf1));
      }
#line 287
      if (! h_reply_to) {
        {
#line 288
        mail_fp = mail_open(0, (char const   *)h_from, (char const   *)((void *)0),
                            (char const   *)((void *)0));
        }
      }
#line 289
      goto while_continue;
    }
    {
#line 291
    tmp___0 = strncasecmp((char const   *)(curr_line), "REPLY-TO:", (size_t )9);
    }
#line 291
    if (tmp___0 == 0) {
      {
#line 294
      CrackFrom(buf1___0, buf2___0, curr_line + 9);
#line 295
      h_reply_to = xstrdup((char const   *)(buf1___0));
#line 296
      mail_fp = mail_open(0, (char const   *)h_reply_to, (char const   *)((void *)0),
                          (char const   *)((void *)0));
      }
#line 297
      goto while_continue;
    }
    {
#line 299
    tmp___1 = strncasecmp((char const   *)(curr_line), "DATE:", (size_t )5);
    }
#line 299
    if (tmp___1 == 0) {
      {
#line 300
      h_date = xstrdup((char const   *)(curr_line));
      }
#line 301
      goto while_continue;
    }
    {
#line 303
    tmp___2 = strncasecmp((char const   *)(curr_line), "SUBJECT:", (size_t )8);
    }
#line 303
    if (tmp___2 == 0) {
      {
#line 304
      h_subject = xstrdup((char const   *)(curr_line));
      }
#line 305
      goto while_continue;
    }
    {
#line 307
    tmp___3 = strncasecmp((char const   *)(curr_line), "MESSAGE-ID:", (size_t )11);
    }
#line 307
    if (tmp___3 == 0) {
      {
#line 308
      h_message_id = xstrdup((char const   *)(curr_line));
      }
#line 309
      goto while_continue;
    }
    {
#line 311
    tmp___4 = strncasecmp((char const   *)(curr_line), "RETURN-PATH:", (size_t )12);
    }
#line 311
    if (tmp___4 == 0) {
      {
#line 312
      h_return_path = xstrdup((char const   *)(curr_line));
      }
#line 313
      goto while_continue;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 316
  return;
}
}
#line 320 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.c"
static int parse_commands(void) 
{ 
  char const   *command ;
  COMMAND *cmdp ;
  char const   *tokens[10] ;
  int tcount ;
  int changed ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 328
  changed = 0;
  {
#line 330
  while (1) {
    while_continue: /* CIL Label */ ;
#line 330
    if (! quit_flag) {
      {
#line 330
      tmp___1 = getoneline(stdin);
      }
#line 330
      if (! tmp___1) {
#line 330
        goto while_break;
      }
    } else {
#line 330
      goto while_break;
    }
#line 332
    if (! curr_line[0]) {
#line 333
      goto while_continue;
    }
#line 335
    if (seen_site) {
      {
#line 336
      logit(1 << 1, "");
#line 337
      logit(1 | (1 << 1), "%s", curr_line);
      }
    }
    {
#line 339
    tcount = tokenize(curr_line, tokens, 10);
    }
#line 340
    if (tcount == 0) {
#line 341
      goto while_continue;
    }
#line 344
    command = tokens[0];
#line 345
    cmdp = C_list;
    {
#line 345
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 345
      if (! cmdp->name) {
#line 345
        goto while_break___0;
      }
      {
#line 346
      tmp = command_cmp(command, cmdp->name);
      }
#line 346
      if (tmp == 0) {
#line 347
        goto while_break___0;
      }
#line 345
      cmdp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 350
    if (! cmdp->name) {
#line 351
      if (! seen_site) {
        {
#line 352
        logit(1 | (1 << 1), "\n%s %s %s", tokens[0], tokens[1], tokens[2]);
        }
      }
      {
#line 353
      logit(1 | (1 << 1), "\nERROR: Unrecognized command \'%s\' - try \'help\'\nNOTE: No changes made to subscription list.",
            command);
#line 355
      gupout(0, (char const   *)((void *)0));
      }
    }
#line 359
    if (cmdp->needs_site) {
#line 359
      if (! seen_site) {
        {
#line 360
        gupout(0, "\'site\' command must preceed the \'%s\' command", cmdp->name);
        }
      }
    }
#line 364
    if (cmdp->args > 0) {
#line 364
      if (tcount != cmdp->args) {
        {
#line 365
        logit(1 | (1 << 1), "WARNING: %s requires %d parameters, not %d\n", command,
              cmdp->args, tcount);
        }
#line 367
        goto while_continue;
      }
    }
    {
#line 371
    tmp___0 = (*(cmdp->handler))(tokens + 1);
    }
#line 371
    if (tmp___0) {
#line 372
      changed = 1;
    }
#line 375
    if (cmdp->sets_quit) {
#line 376
      quit_flag = 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 379
  return (changed);
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.c"
static int site(char const   **tokens ) 
{ 
  FILE *fp ;
  int fd ;
  char const   *hf_tokens[4] ;
  int found_site ;
  int tcount ;
  LIST *exclusion_list ;
  char lbuf[512] ;
  char *cryptstr ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
#line 390
  exclusion_list = (LIST *)((void *)0);
#line 394
  if (seen_site) {
    {
#line 395
    gupout(0, "Multiple \'site\' commands not allowed");
    }
  }
  {
#line 398
  fp = fopen((char const   */* __restrict  */)"config", (char const   */* __restrict  */)"r");
  }
#line 398
  if (! fp) {
    {
#line 399
    gupout(1, "Install error. Open of \'%s\' failed", "config");
    }
  }
#line 402
  found_site = 0;
  {
#line 403
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 403
    tmp___0 = fgets((char */* __restrict  */)(lbuf), (int )sizeof(lbuf), (FILE */* __restrict  */)fp);
    }
#line 403
    if (! tmp___0) {
#line 403
      goto while_break;
    }
    {
#line 404
    tcount = tokenize(lbuf, hf_tokens, 4);
    }
#line 405
    if (tcount == 0) {
#line 406
      goto while_continue;
    }
#line 407
    if ((int const   )*(hf_tokens[0]) == 35) {
#line 408
      goto while_continue;
    }
#line 409
    if (tcount != 3) {
      {
#line 410
      gupout(1, "%s format incorrect for %s. Need 3 tokens", "config", *(tokens + 0));
      }
    }
    {
#line 412
    tmp = strcasecmp(*(tokens + 0), hf_tokens[0]);
    }
#line 412
    if (tmp == 0) {
#line 413
      found_site = 1;
#line 414
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 418
  fclose(fp);
  }
#line 420
  if (! found_site) {
    {
#line 421
    gupout(0, "Unknown site \'%s\'", *(tokens + 0));
    }
  }
  {
#line 428
  mail_fp = mail_open(1, hf_tokens[2], (char const   *)((void *)0), (char const   *)((void *)0));
#line 434
  logit(1, "");
#line 435
  logit((1 | (1 << 1)) | (1 << 2), "BEGIN: %s %s\n", progname, "0.5.7");
#line 437
  log_mail_headers();
#line 439
  logit(1 | (1 << 1), "site %s", *(tokens + 0));
#line 442
  cryptstr = crypt(*(tokens + 1), hf_tokens[1]);
#line 444
  tmp___1 = strcmp((char const   *)cryptstr, hf_tokens[1]);
  }
#line 444
  if (tmp___1 != 0) {
    {
#line 444
    tmp___2 = strcmp(*(tokens + 1), hf_tokens[1]);
    }
#line 444
    if (tmp___2 != 0) {
      {
#line 448
      gupout(0, "Password incorrect");
      }
    }
  }
  {
#line 450
  sitename = xstrdup(hf_tokens[0]);
#line 451
  seen_site = 1;
  }
  {
#line 454
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 454
    tmp___9 = chdir(site_directory);
    }
#line 454
    if (! tmp___9) {
#line 454
      goto while_break___0;
    }
    {
#line 455
    tmp___8 = __errno_location();
    }
#line 455
    if (*tmp___8 == 2) {
      {
#line 456
      logit(1, "MKDIR: %s", site_directory);
#line 457
      tmp___5 = mkdir(site_directory, (__mode_t )511);
      }
#line 457
      if (tmp___5) {
        {
#line 458
        tmp___3 = __errno_location();
#line 458
        tmp___4 = strerror(*tmp___3);
#line 458
        gupout(1, "Install error: could not MKDIR %s (%s)", site_directory, tmp___4);
        }
      }
    } else {
      {
#line 461
      tmp___6 = __errno_location();
#line 461
      tmp___7 = strerror(*tmp___6);
#line 461
      gupout(1, "Install error: could not CHDIR to %s (%s)", site_directory, tmp___7);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 464
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 464
    tmp___16 = chdir((char const   *)sitename);
    }
#line 464
    if (! tmp___16) {
#line 464
      goto while_break___1;
    }
    {
#line 465
    tmp___15 = __errno_location();
    }
#line 465
    if (*tmp___15 == 2) {
      {
#line 466
      logit(1, "MKDIR: %s", sitename);
#line 467
      tmp___12 = mkdir((char const   *)sitename, (__mode_t )511);
      }
#line 467
      if (tmp___12) {
        {
#line 468
        tmp___10 = __errno_location();
#line 468
        tmp___11 = strerror(*tmp___10);
#line 468
        gupout(1, "Install error: could not MKDIR %s (%s)", sitename, tmp___11);
        }
      }
    } else {
      {
#line 471
      tmp___13 = __errno_location();
#line 471
      tmp___14 = strerror(*tmp___13);
#line 471
      gupout(1, "Install error: could not CHDIR to %s (%s)", sitename, tmp___14);
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 474
  tmp___17 = lockit();
  }
#line 474
  if (! tmp___17) {
    {
#line 475
    gupout(1, "Failed to take lock in %s", lbuf);
    }
  }
  {
#line 476
  fd = open("exclude", 0);
  }
#line 476
  if (fd >= 0) {
    {
#line 477
    exclusion_list = read_groups(fd, (LIST *)((void *)0));
#line 478
    close(fd);
    }
  }
  {
#line 480
  load_active(exclusion_list);
#line 483
  fd = open("groups", 0);
  }
#line 483
  if (fd >= 0) {
    {
#line 484
    group_list = read_groups(fd, (LIST *)((void *)0));
#line 485
    close(fd);
    }
  } else {
    {
#line 487
    group_list = create_list();
#line 488
    logit(1, "WARNING: File \'%s\' not found for %s", "groups", sitename);
    }
  }
#line 492
  return (0);
}
}
#line 495 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.c"
static int quit(char const   **tokens ) 
{ 


  {
#line 497
  return (0);
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.c"
static void load_active(LIST *exclusion_list ) 
{ 
  int fd ;

  {
  {
#line 505
  fd = open(active_path, 0);
  }
#line 505
  if (fd < 0) {
    {
#line 506
    gupout(1, "Could not open active file \'%s\'", active_path);
    }
  }
  {
#line 507
  active_list = read_groups(fd, exclusion_list);
#line 508
  close(fd);
  }
#line 510
  if (! active_list->length) {
    {
#line 511
    gupout(1, "No groups found in active file \'%s\'", active_path);
    }
  }
#line 512
  return;
}
}
#line 517 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.c"
static void write_groups(void) 
{ 
  FILE *fp ;
  GROUP *gp ;
  int write_count ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 523
  fp = fopen((char const   */* __restrict  */)"groups.new", (char const   */* __restrict  */)"w");
  }
#line 523
  if (! fp) {
    {
#line 524
    gupout(1, "Could not open %s for writing", "groups.new");
    }
  }
#line 525
  write_count = 0;
#line 526
  if (group_list) {
#line 526
    gp = group_list->head;
    {
#line 526
    while (1) {
      while_continue: /* CIL Label */ ;
#line 526
      if (! gp) {
#line 526
        goto while_break;
      }
#line 527
      write_count ++;
#line 528
      if (gp->u.not == 1) {
        {
#line 529
        _IO_putc('!', fp);
        }
      } else
#line 530
      if (gp->u.not == 2) {
        {
#line 531
        _IO_putc('@', fp);
        }
      }
      {
#line 532
      fputs((char const   */* __restrict  */)gp->name, (FILE */* __restrict  */)fp);
#line 533
      _IO_putc('\n', fp);
#line 526
      gp = gp->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 536
  fclose(fp);
#line 538
  logit((1 | (1 << 1)) | (1 << 2), "%s: %s: group patterns: %d", progname, sitename,
        write_count);
#line 548
  tmp___0 = rename("groups", "groups.old");
  }
#line 548
  if (tmp___0 == -1) {
    {
#line 548
    tmp___1 = __errno_location();
    }
#line 548
    if (*tmp___1 != 2) {
      {
#line 549
      tmp = __errno_location();
#line 549
      gupout(1, "rename(%s,%s) failed for %s. Errno=%d", "groups", "groups.old", sitename,
             *tmp);
      }
    }
  }
  {
#line 551
  tmp___3 = rename("groups.new", "groups");
  }
#line 551
  if (tmp___3 == -1) {
    {
#line 552
    tmp___2 = __errno_location();
#line 552
    gupout(1, "rename(%s,%s) failed for %s. Errno=%d", "groups.new", "groups", sitename,
           *tmp___2);
    }
  }
#line 554
  return;
}
}
#line 557 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.c"
static int include(char const   **tokens ) 
{ 
  int tmp ;

  {
  {
#line 559
  tmp = insert_group(0, *(tokens + 0));
  }
#line 559
  return (tmp);
}
}
#line 562 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.c"
static int exclude(char const   **tokens ) 
{ 
  int tmp ;

  {
  {
#line 564
  tmp = insert_group(1, *(tokens + 0));
  }
#line 564
  return (tmp);
}
}
#line 567 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.c"
static int poison(char const   **tokens ) 
{ 
  int tmp ;

  {
  {
#line 569
  tmp = insert_group(2, *(tokens + 0));
  }
#line 569
  return (tmp);
}
}
#line 572 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.c"
static int insert_group(int not_flag , char const   *gname ) 
{ 
  GROUP *gp ;
  GROUP *new_gp ;
  int match_count ;
  int column ;
  int indent ;
  int tmp ;

  {
  {
#line 579
  new_gp = create_group(not_flag, gname);
#line 582
  fputs((char const   */* __restrict  */)"  => ", (FILE */* __restrict  */)mail_fp);
#line 583
  indent = 5;
#line 583
  column = indent;
#line 585
  match_count = 0;
  }
#line 586
  if (active_list) {
#line 586
    gp = active_list->head;
    {
#line 586
    while (1) {
      while_continue: /* CIL Label */ ;
#line 586
      if (! gp) {
#line 586
        goto while_break;
      }
      {
#line 587
      tmp = wildmat(gp->name, new_gp->name);
      }
#line 587
      if (tmp) {
#line 588
        match_count ++;
#line 589
        if (match_count <= 50) {
          {
#line 590
          item_print(indent, & column, gp->name);
          }
#line 591
          if (match_count == 50) {
            {
#line 592
            item_print(indent, & column, "...etc...");
            }
          }
        }
      }
#line 586
      gp = gp->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 597
  if (match_count == 0) {
#line 598
    if (not_flag == 0) {
      {
#line 599
      destroy_group(new_gp);
#line 600
      logit(1 << 1, "WARNING: %s pattern not in active - ignored", gname);
      }
#line 601
      return (0);
    } else {
      {
#line 603
      logit(1 << 1, "WARNING: %s pattern not in active", gname);
      }
    }
  }
  {
#line 605
  logit(1 << 1, "");
  }
#line 606
  if (match_count > 1) {
    {
#line 607
    logit(1 << 1, "  [ %d groups ]", match_count);
    }
  }
  {
#line 610
  add_group(group_list, new_gp);
  }
#line 612
  return (1);
}
}
#line 616 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.c"
static int delete(char const   **tokens ) 
{ 
  char const   *gname ;
  GROUP *gp ;
  int match_count ;
  char const   *tmp ;
  int tmp___0 ;

  {
#line 622
  gname = *(tokens + 0);
#line 625
  match_count = 0;
#line 626
  if (group_list) {
#line 626
    gp = group_list->head;
    {
#line 626
    while (1) {
      while_continue: /* CIL Label */ ;
#line 626
      if (! gp) {
#line 626
        goto while_break;
      }
      {
#line 627
      tmp___0 = wildmat(gp->name, gname);
      }
#line 627
      if (tmp___0) {
#line 628
        match_count ++;
#line 629
        if (match_count <= 50) {
#line 630
          if (gp->u.not == 1) {
#line 630
            tmp = "exclude";
          } else {
#line 630
            tmp = "include";
          }
          {
#line 630
          logit(1 << 1, "\tMatches: %s %s", tmp, gp->name);
          }
        }
#line 633
        if (match_count == 50) {
          {
#line 634
          logit(1 << 1, "\tMatches: ...etc...");
          }
        }
        {
#line 635
        remove_group(group_list, gp);
        }
      }
#line 626
      gp = gp->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 639
  logit(1 | (1 << 1), " delete: Match count %d", match_count);
  }
#line 640
  if (match_count == 0) {
    {
#line 641
    logit(1 << 1, "WARNING: %s pattern not in %s - ignored", gname, "groups");
    }
  }
#line 643
  return (match_count > 0);
}
}
#line 646 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.c"
static void item_print(int indent , int *column , char const   *str ) 
{ 
  int len ;
  size_t tmp ;
  int col ;
  char ch ;
  int tmp___0 ;

  {
  {
#line 649
  tmp = strlen(str);
#line 649
  len = (int )tmp;
  }
#line 651
  if (*column + len > 77) {
    {
#line 652
    col = indent;
#line 655
    _IO_putc(',', mail_fp);
#line 656
    _IO_putc('\n', mail_fp);
    }
#line 658
    if (col % 8) {
#line 659
      ch = (char )' ';
    } else {
#line 661
      ch = (char )'\t';
#line 662
      col /= 8;
    }
    {
#line 664
    while (1) {
      while_continue: /* CIL Label */ ;
#line 664
      tmp___0 = col;
#line 664
      col --;
#line 664
      if (! tmp___0) {
#line 664
        goto while_break;
      }
      {
#line 665
      _IO_putc((int )ch, mail_fp);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 667
    *column = indent;
  }
#line 669
  if (*column != indent) {
    {
#line 670
    _IO_putc(',', mail_fp);
#line 671
    _IO_putc(' ', mail_fp);
    }
  }
  {
#line 673
  fputs((char const   */* __restrict  */)str, (FILE */* __restrict  */)mail_fp);
#line 675
  *column += len + 2;
  }
#line 676
  return;
}
}
#line 679 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.c"
static int list(char const   **tokens ) 
{ 
  GROUP *gp ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 683
  group_list = sort_groups(group_list);
  }
#line 684
  if (group_list) {
#line 684
    gp = group_list->head;
    {
#line 684
    while (1) {
      while_continue: /* CIL Label */ ;
#line 684
      if (! gp) {
#line 684
        goto while_break;
      }
#line 685
      if (gp->u.not != 0) {
#line 685
        if (gp->u.not == 2) {
#line 685
          tmp = " poison";
        } else {
#line 685
          tmp = "  exclude";
        }
#line 685
        tmp___0 = tmp;
      } else {
#line 685
        tmp___0 = "include";
      }
      {
#line 685
      logit(1 << 1, "  %s  %s\n", tmp___0, gp->name);
#line 684
      gp = gp->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 691
  return (0);
}
}
#line 695 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.c"
static int newsgroups(char const   **tokens ) 
{ 


  {
  {
#line 697
  print_newsgroups(mail_fp, *(tokens + 0));
  }
#line 698
  return (0);
}
}
#line 705 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.c"
static int getoneline(FILE *fp ) 
{ 
  int len ;
  char *tmp ;
  size_t tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  {
#line 709
  tmp = fgets((char */* __restrict  */)(curr_line), (int )(sizeof(curr_line) - 1UL),
              (FILE */* __restrict  */)fp);
  }
#line 709
  if (! tmp) {
#line 710
    quit_flag = 1;
#line 711
    return (0);
  }
  {
#line 713
  curr_line[sizeof(curr_line) - 1UL] = (char )'\000';
#line 716
  tmp___0 = strlen((char const   *)(curr_line));
#line 716
  len = (int )tmp___0;
  }
  {
#line 717
  while (1) {
    while_continue: /* CIL Label */ ;
#line 717
    if (len > 0) {
      {
#line 717
      tmp___1 = __ctype_b_loc();
      }
#line 717
      if (! ((int const   )*(*tmp___1 + (int )curr_line[len - 1]) & 8192)) {
#line 717
        goto while_break;
      }
    } else {
#line 717
      goto while_break;
    }
#line 718
    len --;
  }
  while_break: /* CIL Label */ ;
  }
#line 719
  curr_line[len] = (char )'\000';
#line 721
  return (1);
}
}
#line 728 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.c"
static int tokenize(char *cp , char const   **tokens , int max_tokens ) 
{ 
  int tix ;
  char *com_cp ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;

  {
#line 734
  com_cp = cp;
  {
#line 734
  while (1) {
    while_continue: /* CIL Label */ ;
#line 734
    if (! *com_cp) {
#line 734
      goto while_break;
    }
#line 735
    if ((int )*com_cp == 35) {
#line 736
      *com_cp = (char )'\000';
#line 737
      goto while_break;
    }
#line 734
    com_cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 741
  tix = 0;
  {
#line 741
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 741
    if (! (tix < max_tokens)) {
#line 741
      goto while_break___0;
    }
#line 742
    *(tokens + tix) = "";
#line 741
    tix ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 744
  tix = 0;
  {
#line 744
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 744
    if (! (tix < max_tokens)) {
#line 744
      goto while_break___1;
    }
    {
#line 745
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 745
      if (*cp) {
        {
#line 745
        tmp = __ctype_b_loc();
        }
#line 745
        if (! ((int const   )*(*tmp + (int )*cp) & 8192)) {
#line 745
          goto while_break___2;
        }
      } else {
#line 745
        goto while_break___2;
      }
#line 746
      cp ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 747
    *(tokens + tix) = (char const   *)cp;
    {
#line 749
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 749
      if (*cp) {
        {
#line 749
        tmp___0 = __ctype_b_loc();
        }
#line 749
        if ((int const   )*(*tmp___0 + (int )*cp) & 8192) {
#line 749
          goto while_break___3;
        }
      } else {
#line 749
        goto while_break___3;
      }
#line 750
      cp ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 752
    if ((unsigned long )cp == (unsigned long )*(tokens + tix)) {
#line 753
      goto while_break___1;
    }
#line 754
    if (*cp) {
#line 755
      tmp___1 = cp;
#line 755
      cp ++;
#line 755
      *tmp___1 = (char )'\000';
    }
#line 744
    tix ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 758
  return (tix);
}
}
#line 761 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.c"
static int command_cmp(char const   *str , char const   *cmd ) 
{ 
  int base ;
  int tmp ;
  int tmp___0 ;

  {
#line 763
  base = 0;
  {
#line 765
  while (1) {
    while_continue: /* CIL Label */ ;
#line 765
    if (*str) {
#line 765
      if (! *cmd) {
#line 765
        goto while_break;
      }
    } else {
#line 765
      goto while_break;
    }
    {
#line 766
    tmp = tolower((int )*str);
    }
#line 766
    if (tmp != (int )*cmd) {
#line 767
      return (1);
    }
#line 768
    str ++;
#line 769
    cmd ++;
#line 770
    if ((int const   )*cmd == 42) {
#line 771
      base = 1;
#line 772
      cmd ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 775
  if (! *str) {
#line 775
    if (base) {
#line 775
      tmp___0 = 0;
    } else
#line 775
    if (! *cmd) {
#line 775
      tmp___0 = 0;
    } else {
#line 775
      tmp___0 = 1;
    }
  } else {
#line 775
    tmp___0 = 1;
  }
#line 775
  return (tmp___0);
}
}
#line 778
 __attribute__((__noreturn__)) void gupout(int val , char const   *out_msg  , ...) ;
#line 778 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.c"
void gupout(int val , char const   *out_msg  , ...) 
{ 
  va_list ap ;

  {
  {
#line 782
  unlockit();
  }
#line 784
  if (out_msg) {
    {
#line 785
    __builtin_va_start(ap, out_msg);
#line 786
    vlogit(1 | (1 << 1), "ERROR", out_msg, ap);
#line 787
    __builtin_va_end(ap);
    }
  }
  {
#line 790
  log_mail_headers();
#line 791
  logit(1 | (1 << 1), "");
#line 792
  logit((1 | (1 << 1)) | (1 << 2), "END: %s", progname);
  }
#line 794
  if (log_fp) {
    {
#line 795
    fclose(log_fp);
    }
  }
#line 796
  if (mail_fp) {
    {
#line 797
    mail_close(mail_fp);
    }
  }
#line 803
  if (val > 0) {
    {
#line 804
    exit(75);
    }
  } else {
    {
#line 806
    exit(0);
    }
  }
}
}
#line 815 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/gup.c"
static void log_mail_headers(void) 
{ 
  int log_count ;

  {
#line 817
  log_count = 0;
#line 819
  if (h_from) {
    {
#line 820
    logit(1 | (1 << 1), "Mail Header: FROM: %s", h_from);
#line 821
    free((void *)h_from);
#line 822
    h_from = (char *)((void *)0);
#line 823
    log_count ++;
    }
  }
#line 825
  if (h_reply_to) {
    {
#line 826
    logit(1 | (1 << 1), "Mail Header: REPLY-TO: %s", h_reply_to);
#line 827
    free((void *)h_reply_to);
#line 828
    h_reply_to = (char *)((void *)0);
#line 829
    log_count ++;
    }
  }
#line 831
  if (h_subject) {
    {
#line 832
    logit(1 | (1 << 1), "Mail Header: %s", h_subject);
#line 833
    free((void *)h_subject);
#line 834
    h_subject = (char *)((void *)0);
#line 835
    log_count ++;
    }
  }
#line 837
  if (h_date) {
    {
#line 838
    logit(1 | (1 << 1), "Mail Header: %s", h_date);
#line 839
    free((void *)h_date);
#line 840
    h_date = (char *)((void *)0);
#line 841
    log_count ++;
    }
  }
#line 843
  if (h_message_id) {
    {
#line 844
    logit(1 | (1 << 1), "Mail Header: %s", h_message_id);
#line 845
    free((void *)h_message_id);
#line 846
    h_message_id = (char *)((void *)0);
#line 847
    log_count ++;
    }
  }
#line 849
  if (h_return_path) {
    {
#line 850
    logit(1 | (1 << 1), "Mail Header: %s", h_return_path);
#line 851
    free((void *)h_return_path);
#line 852
    h_return_path = (char *)((void *)0);
#line 853
    log_count ++;
    }
  }
#line 855
  if (log_count) {
    {
#line 856
    logit(1 | (1 << 1), "");
    }
  }
#line 857
  return;
}
}
#line 3 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/help.c"
static char const   *hlist[56]  = 
#line 3 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/help.c"
  {      "",      "--------------------------------------------------------------------------",      "The automated news update program accepts the following commands:",      "site, include, exclude, poison, delete, list, newsgroups, help and quit.", 
        "",      "The \'site\' command *must* come prior to any of the other commands.",      "After that any order of commands is acceptable. Note that commands are",      "processed in order and that the \'list\' command displays the current state", 
        "as affected by any preceding commands.",      "",      "Syntax:",      "", 
        "site           <sitename>      <password>",      "include        <pattern>",      "exclude        <pattern>",      "pattern        <pattern>", 
        "delete         <pattern>",      "list",      "newsgroups     <pattern>",      "quit", 
        "",      "Where:",      "",      "sitename       must be a valid site registered in the gup config file", 
        "password       Must match the registered password",      "pattern        Is a single \'wildmat\' pattern of a newsgroup.",      "               In the case of \'Include\' and \'Exclude\' it is matched",      "               against the active file.", 
        "               With the \'delete\' command. <pattern> is matched against the",      "               current group list.",      "",      "The \'include\' command adds all groups that match the pattern into your", 
        "current group list. The \'exclude\' command is typically used in conjunction",      "with a wildcard \'include\' command, eg:",      "",      "include        comp.sys.*", 
        "exclude        comp.sys.weirdosystems",      "",      "In the above example, all of the groups in the comp.sys hierarchy will be",      "included, except for comp.sys.weirdosystems. In other words it\'s a merely", 
        "a convenient way of refining a large Include list.",      "",      "You can use the poison command to specify pattern which cause all crossposts",      "to matching groups to be dropped, regardless whether the article would be", 
        "accepted due to other groups. Example:",      "",      "poison         *.binari*",      "", 
        "The \'delete\' command removes all matching \'include\', \'exclude\' and \'poison\'patterns from the current group list.",      "",      "newsgroups lists out all the valid newsgroups that match the pattern.",      "", 
        "quit is used to stop gup from parsing the rest of the mail, that typically",      "has signatures and such baggage on the end of it",      "--------------------------------------------------------------------------",      (char const   *)((void *)0)};
#line 65 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/help.c"
int help(char const   **tokens ) 
{ 
  char const   **hp ;

  {
#line 69
  hp = hlist;
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (! *hp) {
#line 69
      goto while_break;
    }
    {
#line 70
    logit(1 << 1, *hp);
#line 69
    hp ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  return (0);
}
}
/* compiler builtin: 
   void __builtin_va_copy(__builtin_va_list  , __builtin_va_list  ) ;  */
#line 242 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 205
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 5 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/log.c"
static void log_line(FILE *fp , int lflags , char const   *stamp , char const   *prefix ,
                     char const   *out_msg , va_list AP ) 
{ 


  {
#line 8
  if (lflags & (1 << 2)) {
    {
#line 9
    fputs((char const   */* __restrict  */)stamp, (FILE */* __restrict  */)fp);
    }
  }
#line 10
  if (prefix) {
    {
#line 11
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s: ",
            prefix);
    }
  }
  {
#line 12
  vfprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)out_msg,
           AP);
#line 13
  fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)fp);
  }
#line 14
  return;
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/log.c"
static int tried_mail_open  =    0;
#line 17 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/log.c"
void vlogit(int lflags , char const   *prefix , char const   *log_msg , va_list AP ) 
{ 
  time_t secs ;
  struct tm *tm ;
  char stamp[100] ;
  va_list AP2 ;

  {
  {
#line 26
  __builtin_va_copy(AP2, AP);
  }
#line 27
  if (lflags & (1 << 2)) {
    {
#line 28
    time(& secs);
#line 29
    tm = localtime((time_t const   *)(& secs));
#line 30
    strftime((char */* __restrict  */)(stamp), sizeof(stamp), (char const   */* __restrict  */)"%d %h %Y %T: ",
             (struct tm  const  */* __restrict  */)tm);
    }
  }
#line 32
  if (log_fp) {
#line 32
    if (lflags & 1) {
      {
#line 33
      log_line(log_fp, lflags, (char const   *)(stamp), prefix, log_msg, AP);
#line 34
      fflush(log_fp);
      }
    }
  }
#line 36
  if (lflags & (1 << 1)) {
#line 42
    if (! mail_fp) {
#line 42
      if (! tried_mail_open) {
        {
#line 43
        tried_mail_open = 1;
#line 45
        mail_fp = mail_open(1, (char const   *)((void *)0), (char const   *)((void *)0),
                            (char const   *)((void *)0));
        }
      }
    }
#line 48
    if (mail_fp) {
      {
#line 50
      log_line(mail_fp, lflags, (char const   *)(stamp), prefix, log_msg, AP2);
      }
    }
  }
  {
#line 52
  __builtin_va_end(AP2);
  }
#line 53
  return;
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/gup-0.5.15/log.c"
void logit(int lflags , char const   *log_msg  , ...) 
{ 
  va_list ap ;

  {
  {
#line 59
  __builtin_va_start(ap, log_msg);
#line 60
  vlogit(lflags, (char const   *)((void *)0), log_msg, ap);
#line 61
  __builtin_va_end(ap);
  }
#line 62
  return;
}
}
