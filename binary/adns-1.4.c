/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_9 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_9 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 39 "/usr/include/x86_64-linux-gnu/sys/poll.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 33 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/internal.h"
typedef unsigned char byte;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_33 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_34 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_35 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_36 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_37 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_38 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_39 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_32 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_33 _kill ;
   struct __anonstruct__timer_34 _timer ;
   struct __anonstruct__rt_35 _rt ;
   struct __anonstruct__sigchld_36 _sigchld ;
   struct __anonstruct__sigfault_37 _sigfault ;
   struct __anonstruct__sigpoll_38 _sigpoll ;
   struct __anonstruct__sigsys_39 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_31 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_32 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_31 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_51 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_51 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 76 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/adns.h"
struct adns__state;
#line 76 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/adns.h"
typedef struct adns__state *adns_state;
#line 77
struct adns__query;
#line 77 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/adns.h"
typedef struct adns__query *adns_query;
#line 79
enum __anonenum_adns_initflags_59 {
    adns_if_none = 0,
    adns_if_noenv = 1,
    adns_if_noerrprint = 2,
    adns_if_noserverwarn = 4,
    adns_if_debug = 8,
    adns_if_logpid = 128,
    adns_if_noautosys = 16,
    adns_if_eintr = 32,
    adns_if_nosigpipe = 64,
    adns_if_checkc_entex = 256,
    adns_if_checkc_freq = 768
} ;
#line 79 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/adns.h"
typedef enum __anonenum_adns_initflags_59 adns_initflags;
#line 93
enum __anonenum_adns_queryflags_60 {
    adns_qf_none = 0,
    adns_qf_search = 1,
    adns_qf_usevc = 2,
    adns_qf_owner = 4,
    adns_qf_quoteok_query = 16,
    adns_qf_quoteok_cname = 0,
    adns_qf_quoteok_anshost = 64,
    adns_qf_quotefail_cname = 128,
    adns_qf_cname_loose = 256,
    adns_qf_cname_forbid = 512,
    adns__qf_internalmask = 267386880
} ;
#line 93 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/adns.h"
typedef enum __anonenum_adns_queryflags_60 adns_queryflags;
#line 107
enum __anonenum_adns_rrtype_61 {
    adns_rrt_typemask = 65535,
    adns__qtf_deref = 65536,
    adns__qtf_mail822 = 131072,
    adns_r_unknown = 262144,
    adns_r_none = 0,
    adns_r_a = 1,
    adns_r_ns_raw = 2,
    adns_r_ns = 65538,
    adns_r_cname = 5,
    adns_r_soa_raw = 6,
    adns_r_soa = 131078,
    adns_r_ptr_raw = 12,
    adns_r_ptr = 65548,
    adns_r_hinfo = 13,
    adns_r_mx_raw = 15,
    adns_r_mx = 65551,
    adns_r_txt = 16,
    adns_r_rp_raw = 17,
    adns_r_rp = 131089,
    adns_r_srv_raw = 33,
    adns_r_srv = 65569,
    adns_r_addr = 65537
} ;
#line 107 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/adns.h"
typedef enum __anonenum_adns_rrtype_61 adns_rrtype;
#line 233
enum __anonenum_adns_status_62 {
    adns_s_ok = 0,
    adns_s_nomemory = 1,
    adns_s_unknownrrtype = 2,
    adns_s_systemfail = 3,
    adns_s_max_localfail = 29,
    adns_s_timeout = 30,
    adns_s_allservfail = 31,
    adns_s_norecurse = 32,
    adns_s_invalidresponse = 33,
    adns_s_unknownformat = 34,
    adns_s_max_remotefail = 59,
    adns_s_rcodeservfail = 60,
    adns_s_rcodeformaterror = 61,
    adns_s_rcodenotimplemented = 62,
    adns_s_rcoderefused = 63,
    adns_s_rcodeunknown = 64,
    adns_s_max_tempfail = 99,
    adns_s_inconsistent = 100,
    adns_s_prohibitedcname = 101,
    adns_s_answerdomaininvalid = 102,
    adns_s_answerdomaintoolong = 103,
    adns_s_invaliddata = 104,
    adns_s_max_misconfig = 199,
    adns_s_querydomainwrong = 200,
    adns_s_querydomaininvalid = 201,
    adns_s_querydomaintoolong = 202,
    adns_s_max_misquery = 299,
    adns_s_nxdomain = 300,
    adns_s_nodata = 301,
    adns_s_max_permfail = 499
} ;
#line 233 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/adns.h"
typedef enum __anonenum_adns_status_62 adns_status;
#line 285 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/adns.h"
union __anonunion_addr_64 {
   struct sockaddr sa ;
   struct sockaddr_in inet ;
};
#line 285 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/adns.h"
struct __anonstruct_adns_rr_addr_63 {
   int len ;
   union __anonunion_addr_64 addr ;
};
#line 285 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/adns.h"
typedef struct __anonstruct_adns_rr_addr_63 adns_rr_addr;
#line 293 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/adns.h"
struct __anonstruct_adns_rr_hostaddr_65 {
   char *host ;
   adns_status astatus ;
   int naddrs ;
   adns_rr_addr *addrs ;
};
#line 293 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/adns.h"
typedef struct __anonstruct_adns_rr_hostaddr_65 adns_rr_hostaddr;
#line 300 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/adns.h"
struct __anonstruct_adns_rr_strpair_66 {
   char *array[2] ;
};
#line 300 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/adns.h"
typedef struct __anonstruct_adns_rr_strpair_66 adns_rr_strpair;
#line 304 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/adns.h"
struct __anonstruct_adns_rr_inthostaddr_67 {
   int i ;
   adns_rr_hostaddr ha ;
};
#line 304 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/adns.h"
typedef struct __anonstruct_adns_rr_inthostaddr_67 adns_rr_inthostaddr;
#line 309 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/adns.h"
struct __anonstruct_adns_rr_intstr_68 {
   int i ;
   char *str ;
};
#line 309 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/adns.h"
typedef struct __anonstruct_adns_rr_intstr_68 adns_rr_intstr;
#line 320 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/adns.h"
struct __anonstruct_adns_rr_intstrpair_69 {
   adns_rr_intstr array[2] ;
};
#line 320 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/adns.h"
typedef struct __anonstruct_adns_rr_intstrpair_69 adns_rr_intstrpair;
#line 324 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/adns.h"
struct __anonstruct_adns_rr_soa_70 {
   char *mname ;
   char *rname ;
   unsigned long serial ;
   unsigned long refresh ;
   unsigned long retry ;
   unsigned long expire ;
   unsigned long minimum ;
};
#line 324 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/adns.h"
typedef struct __anonstruct_adns_rr_soa_70 adns_rr_soa;
#line 329 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/adns.h"
struct __anonstruct_adns_rr_srvraw_71 {
   int priority ;
   int weight ;
   int port ;
   char *host ;
};
#line 329 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/adns.h"
typedef struct __anonstruct_adns_rr_srvraw_71 adns_rr_srvraw;
#line 334 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/adns.h"
struct __anonstruct_adns_rr_srvha_72 {
   int priority ;
   int weight ;
   int port ;
   adns_rr_hostaddr ha ;
};
#line 334 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/adns.h"
typedef struct __anonstruct_adns_rr_srvha_72 adns_rr_srvha;
#line 339 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/adns.h"
struct __anonstruct_adns_rr_byteblock_73 {
   int len ;
   unsigned char *data ;
};
#line 339 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/adns.h"
typedef struct __anonstruct_adns_rr_byteblock_73 adns_rr_byteblock;
#line 344 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/adns.h"
union __anonunion_rrs_75 {
   void *untyped ;
   unsigned char *bytes ;
   char **str ;
   adns_rr_intstr **manyistr ;
   adns_rr_addr *addr ;
   struct in_addr *inaddr ;
   adns_rr_hostaddr *hostaddr ;
   adns_rr_intstrpair *intstrpair ;
   adns_rr_strpair *strpair ;
   adns_rr_inthostaddr *inthostaddr ;
   adns_rr_intstr *intstr ;
   adns_rr_soa *soa ;
   adns_rr_srvraw *srvraw ;
   adns_rr_srvha *srvha ;
   adns_rr_byteblock *byteblock ;
};
#line 344 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/adns.h"
struct __anonstruct_adns_answer_74 {
   adns_status status ;
   char *cname ;
   char *owner ;
   adns_rrtype type ;
   time_t expires ;
   int nrrs ;
   int rrsz ;
   union __anonunion_rrs_75 rrs ;
};
#line 344 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/adns.h"
typedef struct __anonstruct_adns_answer_74 adns_answer;
#line 422 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/adns.h"
typedef void adns_logcallbackfn(adns_state ads , void *logfndata , char const   *fmt ,
                                va_list al );
#line 101 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/internal.h"
struct __anonstruct_vbuf_79 {
   int used ;
   int avail ;
   byte *buf ;
};
#line 101 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/internal.h"
typedef struct __anonstruct_vbuf_79 vbuf;
#line 106 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/internal.h"
struct __anonstruct_parseinfo_80 {
   adns_state ads ;
   adns_query qu ;
   int serv ;
   byte const   *dgram ;
   int dglen ;
   int nsstart ;
   int nscount ;
   int arcount ;
   struct timeval now ;
};
#line 106 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/internal.h"
typedef struct __anonstruct_parseinfo_80 parseinfo;
#line 115 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/internal.h"
struct typeinfo {
   adns_rrtype typekey ;
   char const   *rrtname ;
   char const   *fmtname ;
   int rrsz ;
   void (*makefinal)(adns_query qu , void *data ) ;
   adns_status (*convstring)(vbuf *vb , void const   *data ) ;
   adns_status (*parse)(parseinfo const   *pai , int cbyte , int max , void *store_r ) ;
   int (*diff_needswap)(adns_state ads , void const   *datap_a , void const   *datap_b ) ;
   adns_status (*qdparselabel)(adns_state ads , char const   **p_io , char const   *pe ,
                               int labelnum , char *label_r , int *ll_io , adns_queryflags flags ,
                               struct typeinfo  const  *typei ) ;
   void (*postsort)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ) ;
};
#line 115 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/internal.h"
typedef struct typeinfo typeinfo;
#line 177 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/internal.h"
struct allocnode {
   struct allocnode *next ;
   struct allocnode *back ;
};
#line 177 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/internal.h"
typedef struct allocnode allocnode;
#line 181 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/internal.h"
union maxalign {
   byte d[1] ;
   struct in_addr ia ;
   long l ;
   void *p ;
   void (*fp)(void) ;
   union maxalign *up ;
};
#line 190 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/internal.h"
union __anonunion_info_82 {
   adns_rr_addr ptr_parent_addr ;
   adns_rr_hostaddr *hostaddr ;
};
#line 190 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/internal.h"
struct __anonstruct_qcontext_81 {
   void *ext ;
   void (*callback)(adns_query parent , adns_query child ) ;
   union __anonunion_info_82 info ;
};
#line 190 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/internal.h"
typedef struct __anonstruct_qcontext_81 qcontext;
#line 199
enum __anonenum_state_83 {
    query_tosend = 0,
    query_tcpw = 1,
    query_childw = 2,
    query_done___0 = 3
} ;
#line 199 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/internal.h"
struct __anonstruct_children_84 {
   adns_query head ;
   adns_query tail ;
};
#line 199 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/internal.h"
struct __anonstruct_siblings_85 {
   adns_query back ;
   adns_query next ;
};
#line 199 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/internal.h"
struct __anonstruct_allocations_86 {
   allocnode *head ;
   allocnode *tail ;
};
#line 199 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/internal.h"
struct adns__query {
   adns_state ads ;
   enum __anonenum_state_83 state ;
   adns_query back ;
   adns_query next ;
   adns_query parent ;
   struct __anonstruct_children_84 children ;
   struct __anonstruct_siblings_85 siblings ;
   struct __anonstruct_allocations_86 allocations ;
   int interim_allocd ;
   int preserved_allocd ;
   void *final_allocspace ;
   typeinfo const   *typei ;
   byte *query_dgram ;
   int query_dglen ;
   vbuf vb ;
   adns_answer *answer ;
   byte *cname_dgram ;
   int cname_dglen ;
   int cname_begin ;
   vbuf search_vb ;
   int search_origlen ;
   int search_pos ;
   int search_doneabs ;
   int id ;
   int flags ;
   int retries ;
   int udpnextserver ;
   unsigned long udpsent ;
   struct timeval timeout ;
   time_t expires ;
   qcontext ctx ;
};
#line 307 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/internal.h"
struct query_queue {
   adns_query head ;
   adns_query tail ;
};
#line 309
enum adns__tcpstate {
    server_disconnected = 0,
    server_connecting = 1,
    server_ok = 2,
    server_broken = 3
} ;
#line 309 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/internal.h"
struct server {
   struct in_addr addr ;
};
#line 309 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/internal.h"
struct sortlist {
   struct in_addr base ;
   struct in_addr mask ;
};
#line 309 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/internal.h"
struct adns__state {
   adns_initflags iflags ;
   adns_logcallbackfn *logfn ;
   void *logfndata ;
   int configerrno ;
   struct query_queue udpw ;
   struct query_queue tcpw ;
   struct query_queue childw ;
   struct query_queue output ;
   adns_query forallnext ;
   int nextid ;
   int udpsocket ;
   int tcpsocket ;
   vbuf tcpsend ;
   vbuf tcprecv ;
   int nservers ;
   int nsortlist ;
   int nsearchlist ;
   int searchndots ;
   int tcpserver ;
   int tcprecv_skip ;
   enum adns__tcpstate tcpstate ;
   struct timeval tcptimeout ;
   struct sigaction stdsigpipe ;
   sigset_t stdsigmask ;
   struct pollfd pollfds_buf[2] ;
   struct server servers[5] ;
   struct sortlist sortlist[15] ;
   char **searchlist ;
   unsigned short rand48xsubi[3] ;
};
#line 604
enum __anonenum_parsedomain_flags_88 {
    pdf_quoteok = 1
} ;
#line 604 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/internal.h"
typedef enum __anonenum_parsedomain_flags_88 parsedomain_flags;
#line 233 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
struct sinfo {
   adns_status st ;
   char const   *abbrev ;
   char const   *string ;
};
#line 299 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
struct stinfo {
   adns_status stmax ;
   char const   *abbrev ;
};
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_10 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_10 fd_set;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 36 "/usr/include/x86_64-linux-gnu/sys/poll.h"
typedef unsigned long nfds_t;
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 43 "/usr/include/x86_64-linux-gnu/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 43 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/harness.h"
struct Terrno {
   char const   *n ;
   int v ;
};
#line 235 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
struct __anonstruct_data_89 {
   double d ;
   long ul ;
   void *p ;
   void (*fp)(void) ;
};
#line 235 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
struct malloced {
   struct malloced *next ;
   struct malloced *back ;
   size_t sz ;
   unsigned long count ;
   struct __anonstruct_data_89 data ;
};
#line 242 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
struct __anonstruct_mallocedlist_90 {
   struct malloced *head ;
   struct malloced *tail ;
};
#line 105 "/usr/include/stdlib.h"
struct __anonstruct_ldiv_t_7 {
   long quot ;
   long rem ;
};
#line 105 "/usr/include/stdlib.h"
typedef struct __anonstruct_ldiv_t_7 ldiv_t;
#line 326 "/usr/include/netdb.h"
struct protoent {
   char *p_name ;
   char **p_aliases ;
   int p_proto ;
};
#line 75 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/internal.h"
enum __anonenum_consistency_checks_76 {
    cc_user = 0,
    cc_entex = 1,
    cc_freq = 2
} ;
#line 75 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/internal.h"
typedef enum __anonenum_consistency_checks_76 consistency_checks;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 56 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnshost.h"
struct optioninfo;
#line 57 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnshost.h"
typedef void optfunc(struct optioninfo  const  *oi , char const   *arg , char const   *arg2 );
#line 59
enum oi_type {
    ot_end = 0,
    ot_desconly = 1,
    ot_flag = 2,
    ot_value = 3,
    ot_func = 4,
    ot_funcarg = 5,
    ot_funcarg2 = 6
} ;
#line 59 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnshost.h"
struct optioninfo {
   enum oi_type type ;
   char const   *desc ;
   char const   *sopt ;
   char const   *lopt ;
   int *storep ;
   int value ;
   optfunc *func ;
   char const   *argdesc ;
   char const   *argdesc2 ;
};
#line 74 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnshost.h"
struct perqueryflags_remember {
   int show_owner ;
   int show_type ;
   int show_cname ;
   int ttl ;
};
#line 96 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnshost.h"
struct query_node {
   struct query_node *next ;
   struct query_node *back ;
   struct perqueryflags_remember pqfr ;
   char *id ;
   char *owner ;
   adns_query qu ;
};
#line 104 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnshost.h"
struct outstanding_list {
   struct query_node *head ;
   struct query_node *tail ;
};
#line 558 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/internal.h"
struct __anonstruct_findlabel_state_87 {
   adns_state ads ;
   adns_query qu ;
   int serv ;
   byte const   *dgram ;
   int dglen ;
   int max ;
   int cbyte ;
   int namelen ;
   int *dmend_r ;
};
#line 558 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/internal.h"
typedef struct __anonstruct_findlabel_state_87 findlabel_state;
#line 310 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
struct configcommandinfo {
   char const   *name ;
   void (*fn)(adns_state ads , char const   *fn , int lno , char const   *buf ) ;
};
#line 325 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
union __anonunion_getline_ctx_89 {
   FILE *file ;
   char const   *text ;
};
#line 325 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
typedef union __anonunion_getline_ctx_89 getline_ctx;
#line 1134 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
union __anonunion_rrtmp_89 {
   adns_rr_srvha ha ;
   adns_rr_srvraw raw ;
};
#line 82 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-main.c"
struct typename {
   adns_rrtype type ;
   char const   *desc ;
};
#line 284 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-opts.c"
typedef int comparer_type(char const   **optp , struct optioninfo  const  *entry );
#line 81 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/internal.h"
enum __anonenum_dns_rcode_77 {
    rcode_noerror = 0,
    rcode_formaterror = 1,
    rcode_servfail = 2,
    rcode_nxdomain = 3,
    rcode_notimp = 4,
    rcode_refused = 5
} ;
#line 81 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/internal.h"
typedef enum __anonenum_dns_rcode_77 dns_rcode;
#line 242 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
struct __anonstruct_mallocedlist_90___0 {
   struct malloced *head ;
   struct malloced *tail ;
};
#line 137 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnslogres.c"
struct logline {
   struct logline *next ;
   char *start ;
   char *addr ;
   char *rest ;
   adns_query query ;
};
#line 137 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnslogres.c"
typedef struct logline logline;
#line 1134 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
union __anonunion_rrtmp_89___0 {
   adns_rr_srvha ha ;
   adns_rr_srvraw raw ;
};
#line 242 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
struct __anonstruct_mallocedlist_90___1 {
   struct malloced *head ;
   struct malloced *tail ;
};
#line 1134 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
union __anonunion_rrtmp_89___1 {
   adns_rr_srvha ha ;
   adns_rr_srvraw raw ;
};
#line 42 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnstest.c"
struct myctx {
   adns_query qu ;
   int doneyet ;
   int found ;
   char const   *fdom ;
};
#line 242 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
struct __anonstruct_mallocedlist_90___2 {
   struct malloced *head ;
   struct malloced *tail ;
};
#line 1134 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
union __anonunion_rrtmp_89___2 {
   adns_rr_srvha ha ;
   adns_rr_srvraw raw ;
};
#line 49 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
struct treething;
#line 49 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
struct outqueuenode {
   struct outqueuenode *next ;
   struct outqueuenode *back ;
   void *buffer ;
   char *textp ;
   int textlen ;
   struct timeval printbefore ;
   struct treething *addr ;
};
#line 65 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
struct __anonstruct_outqueue_55 {
   struct outqueuenode *head ;
   struct outqueuenode *tail ;
};
#line 76 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
struct treething {
   unsigned char bytes[4] ;
   adns_query qu ;
   adns_answer *ans ;
};
#line 242 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
struct __anonstruct_mallocedlist_90___3 {
   struct malloced *head ;
   struct malloced *tail ;
};
#line 1134 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
union __anonunion_rrtmp_89___3 {
   adns_rr_srvha ha ;
   adns_rr_srvraw raw ;
};
#line 65 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
struct __anonstruct_outqueue_55___0 {
   struct outqueuenode *head ;
   struct outqueuenode *tail ;
};
#line 242 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
struct __anonstruct_mallocedlist_90___4 {
   struct malloced *head ;
   struct malloced *tail ;
};
#line 1134 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
union __anonunion_rrtmp_89___4 {
   adns_rr_srvha ha ;
   adns_rr_srvraw raw ;
};
#line 242 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
struct __anonstruct_mallocedlist_90___5 {
   struct malloced *head ;
   struct malloced *tail ;
};
#line 1134 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
union __anonunion_rrtmp_89___5 {
   adns_rr_srvha ha ;
   adns_rr_srvraw raw ;
};
#line 242 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
struct __anonstruct_mallocedlist_90___6 {
   struct malloced *head ;
   struct malloced *tail ;
};
#line 1134 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
union __anonunion_rrtmp_89___6 {
   adns_rr_srvha ha ;
   adns_rr_srvraw raw ;
};
#line 65 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
struct __anonstruct_outqueue_55___1 {
   struct outqueuenode *head ;
   struct outqueuenode *tail ;
};
#line 1134 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
union __anonunion_rrtmp_89___7 {
   adns_rr_srvha ha ;
   adns_rr_srvraw raw ;
};
#line 94 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsheloex.c"
struct logline___0 {
   struct logline___0 *next ;
   char *start ;
   char *name ;
   char *rest ;
   char *addr ;
   adns_query query ;
};
#line 94 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsheloex.c"
typedef struct logline___0 logline___0;
#line 1134 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
union __anonunion_rrtmp_89___8 {
   adns_rr_srvha ha ;
   adns_rr_srvraw raw ;
};
#line 1134 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
union __anonunion_rrtmp_89___9 {
   adns_rr_srvha ha ;
   adns_rr_srvraw raw ;
};
#line 65 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
struct __anonstruct_outqueue_55___2 {
   struct outqueuenode *head ;
   struct outqueuenode *tail ;
};
#line 1134 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
union __anonunion_rrtmp_89___10 {
   adns_rr_srvha ha ;
   adns_rr_srvraw raw ;
};
#line 1134 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
union __anonunion_rrtmp_89___11 {
   adns_rr_srvha ha ;
   adns_rr_srvraw raw ;
};
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 755 "/usr/include/stdlib.h"
extern void *( __attribute__((__nonnull__(1,2,5))) bsearch)(void const   *__key ,
                                                            void const   *__base ,
                                                            size_t __nmemb , size_t __size ,
                                                            int (*__compar)(void const   * ,
                                                                            void const   * ) ) ;
#line 53 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 218 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigfillset)(sigset_t *__set ) ;
#line 224
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigdelset)(sigset_t *__set ,
                                                                                                int __signo ) ;
#line 248
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigprocmask)(int __how ,
                                                                                  sigset_t const   * __restrict  __set ,
                                                                                  sigset_t * __restrict  __oset ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 50
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 848 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/adns.h"
adns_status adns_rr_info(adns_rrtype type , char const   **rrtname_r , char const   **fmtname_r ,
                         int *len_r , void const   *datap , char **data_r ) ;
#line 908
char const   *adns_strerror(adns_status st ) ;
#line 909
char const   *adns_errabbrev(adns_status st ) ;
#line 910
char const   *adns_errtypeabbrev(adns_status st ) ;
#line 27 "./hsyscalls.h"
pid_t Hgetpid(void) ;
#line 29
void Hfree(void *ptr ) ;
#line 30
void *Hrealloc(void *op , size_t nsz ) ;
#line 181 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/internal.h"
union maxalign data  ;
#line 348
void adns__vlprintf(adns_state ads___7 , char const   *fmt , va_list al ) ;
#line 349
void ( /* format attribute */  adns__lprintf)(adns_state ads___7 , char const   *fmt 
                                              , ...) ;
#line 352
void adns__vdiag(adns_state ads___7 , char const   *pfx , adns_initflags prevent ,
                 int serv , adns_query qu , char const   *fmt , va_list al ) ;
#line 355
void ( /* format attribute */  adns__debug)(adns_state ads___7 , int serv , adns_query qu ,
                                            char const   *fmt  , ...) ;
#line 357
void ( /* format attribute */  adns__warn)(adns_state ads___7 , int serv , adns_query qu ,
                                           char const   *fmt  , ...) ;
#line 359
void ( /* format attribute */  adns__diag)(adns_state ads___7 , int serv , adns_query qu ,
                                           char const   *fmt  , ...) ;
#line 362
int adns__vbuf_ensure(vbuf *vb___0 , int want ) ;
#line 363
int adns__vbuf_appendstr(vbuf *vb___0 , char const   *data___0 ) ;
#line 364
int adns__vbuf_append(vbuf *vb___0 , byte const   *data___0 , int len ) ;
#line 366
void adns__vbuf_appendq(vbuf *vb___0 , byte const   *data___0 , int len ) ;
#line 367
void adns__vbuf_init(vbuf *vb___0 ) ;
#line 368
void adns__vbuf_free(vbuf *vb___0 ) ;
#line 370
char const   *adns__diag_domain(adns_state ads___7 , int serv , adns_query qu , vbuf *vb___0 ,
                                byte const   *dgram , int dglen , int cbyte___3 ) ;
#line 384
void adns__isort(void *array , int nobjs , int sz , void *tempbuf , int (*needswap)(void *context ,
                                                                                    void const   *a ,
                                                                                    void const   *b ) ,
                 void *context ) ;
#line 393
void adns__sigpipe_protect(adns_state ads___7 ) ;
#line 394
void adns__sigpipe_unprotect(adns_state ads___7 ) ;
#line 554
typeinfo const   *adns__findtype(adns_rrtype type ) ;
#line 608
adns_status adns__parse_domain(adns_state ads___7 , int serv , adns_query qu , vbuf *vb___0 ,
                               parsedomain_flags flags , byte const   *dgram , int dglen ,
                               int *cbyte_io , int max ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
void adns__vlprintf(adns_state ads___7 , char const   *fmt , va_list al ) 
{ 


  {
  {
#line 41
  (*(ads___7->logfn))(ads___7, ads___7->logfndata, fmt, al);
  }
#line 42
  return;
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
void ( /* format attribute */  adns__lprintf)(adns_state ads___7 , char const   *fmt 
                                              , ...) 
{ 
  va_list al ;

  {
  {
#line 46
  __builtin_va_start(al, fmt);
#line 47
  adns__vlprintf(ads___7, fmt, al);
#line 48
  __builtin_va_end(al);
  }
#line 49
  return;
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
void adns__vdiag(adns_state ads___7 , char const   *pfx , adns_initflags prevent ,
                 int serv , adns_query qu , char const   *fmt , va_list al ) 
{ 
  char const   *bef ;
  char const   *aft ;
  vbuf vb___0 ;
  pid_t tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;

  {
#line 56
  if (! ads___7->logfn) {
#line 59
    return;
  } else
#line 56
  if (! ((unsigned int )ads___7->iflags & 8U)) {
#line 56
    if (! prevent) {
#line 59
      return;
    } else
#line 56
    if ((unsigned int )ads___7->iflags & (unsigned int )prevent) {
#line 59
      return;
    }
  }
#line 61
  if ((unsigned int )ads___7->iflags & 128U) {
    {
#line 62
    tmp = Hgetpid();
#line 62
    adns__lprintf(ads___7, "adns%s [%ld]: ", pfx, (long )tmp);
    }
  } else {
    {
#line 64
    adns__lprintf(ads___7, "adns%s: ", pfx);
    }
  }
  {
#line 67
  adns__vlprintf(ads___7, fmt, al);
#line 69
  bef = " (";
#line 70
  aft = "\n";
  }
#line 72
  if (qu) {
#line 72
    if (qu->query_dgram) {
      {
#line 73
      adns__vbuf_init(& vb___0);
      }
#line 74
      if (qu->typei) {
#line 74
        tmp___0 = (qu->typei)->rrtname;
      } else {
#line 74
        tmp___0 = (char const   */* const  */)"<unknown>";
      }
      {
#line 74
      tmp___1 = adns__diag_domain(qu->ads, -1, (adns_query )0, & vb___0, (byte const   *)qu->query_dgram,
                                  qu->query_dglen, 12);
#line 74
      adns__lprintf(ads___7, "%sQNAME=%s, QTYPE=%s", bef, tmp___1, tmp___0);
      }
#line 79
      if (qu->typei) {
#line 79
        if ((qu->typei)->fmtname) {
          {
#line 80
          adns__lprintf(ads___7, "(%s)", (qu->typei)->fmtname);
          }
        }
      }
      {
#line 81
      bef = ", ";
#line 81
      aft = ")\n";
#line 82
      adns__vbuf_free(& vb___0);
      }
    }
  }
#line 85
  if (serv >= 0) {
    {
#line 86
    tmp___2 = inet_ntoa(ads___7->servers[serv].addr);
#line 86
    adns__lprintf(ads___7, "%sNS=%s", bef, tmp___2);
#line 87
    bef = ", ";
#line 87
    aft = ")\n";
    }
  }
  {
#line 90
  adns__lprintf(ads___7, "%s", aft);
  }
#line 91
  return;
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
void ( /* format attribute */  adns__debug)(adns_state ads___7 , int serv , adns_query qu ,
                                            char const   *fmt  , ...) 
{ 
  va_list al ;

  {
  {
#line 97
  __builtin_va_start(al, fmt);
#line 98
  adns__vdiag(ads___7, " debug", (adns_initflags )0, serv, qu, fmt, al);
#line 99
  __builtin_va_end(al);
  }
#line 100
  return;
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
void ( /* format attribute */  adns__warn)(adns_state ads___7 , int serv , adns_query qu ,
                                           char const   *fmt  , ...) 
{ 
  va_list al ;

  {
  {
#line 106
  __builtin_va_start(al, fmt);
#line 107
  adns__vdiag(ads___7, " warning", (adns_initflags )6, serv, qu, fmt, al);
#line 109
  __builtin_va_end(al);
  }
#line 110
  return;
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
void ( /* format attribute */  adns__diag)(adns_state ads___7 , int serv , adns_query qu ,
                                           char const   *fmt  , ...) 
{ 
  va_list al ;

  {
  {
#line 116
  __builtin_va_start(al, fmt);
#line 117
  adns__vdiag(ads___7, "", (adns_initflags )2, serv, qu, fmt, al);
#line 118
  __builtin_va_end(al);
  }
#line 119
  return;
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
void adns__vbuf_init(vbuf *vb___0 ) 
{ 
  int tmp ;

  {
#line 124
  tmp = 0;
#line 124
  vb___0->avail = tmp;
#line 124
  vb___0->used = tmp;
#line 124
  vb___0->buf = (byte *)0;
#line 125
  return;
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
int adns__vbuf_ensure(vbuf *vb___0 , int want ) 
{ 
  void *nb ;

  {
#line 130
  if (vb___0->avail >= want) {
#line 130
    return (1);
  }
  {
#line 131
  nb = Hrealloc((void *)vb___0->buf, (size_t )want);
  }
#line 131
  if (! nb) {
#line 131
    return (0);
  }
#line 132
  vb___0->buf = (byte *)nb;
#line 133
  vb___0->avail = want;
#line 134
  return (1);
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
void adns__vbuf_appendq(vbuf *vb___0 , byte const   *data___0 , int len ) 
{ 


  {
  {
#line 138
  memcpy((void */* __restrict  */)(vb___0->buf + vb___0->used), (void const   */* __restrict  */)data___0,
         (size_t )len);
#line 139
  vb___0->used += len;
  }
#line 140
  return;
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
int adns__vbuf_append(vbuf *vb___0 , byte const   *data___0 , int len ) 
{ 
  int newlen ;
  void *nb ;

  {
#line 146
  newlen = vb___0->used + len;
#line 147
  if (vb___0->avail < newlen) {
#line 148
    if (newlen < 20) {
#line 148
      newlen = 20;
    }
    {
#line 149
    newlen <<= 1;
#line 150
    nb = Hrealloc((void *)vb___0->buf, (size_t )newlen);
    }
#line 151
    if (! nb) {
      {
#line 151
      newlen = vb___0->used + len;
#line 151
      nb = Hrealloc((void *)vb___0->buf, (size_t )newlen);
      }
    }
#line 152
    if (! nb) {
#line 152
      return (0);
    }
#line 153
    vb___0->buf = (byte *)nb;
#line 154
    vb___0->avail = newlen;
  }
  {
#line 156
  adns__vbuf_appendq(vb___0, data___0, len);
  }
#line 157
  return (1);
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
int adns__vbuf_appendstr(vbuf *vb___0 , char const   *data___0 ) 
{ 
  int l ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 162
  tmp = strlen(data___0);
#line 162
  l = (int )tmp;
#line 163
  tmp___0 = adns__vbuf_append(vb___0, (byte const   *)data___0, l);
  }
#line 163
  return (tmp___0);
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
void adns__vbuf_free(vbuf *vb___0 ) 
{ 


  {
  {
#line 167
  Hfree((void *)vb___0->buf);
#line 168
  adns__vbuf_init(vb___0);
  }
#line 169
  return;
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
char const   *adns__diag_domain(adns_state ads___7 , int serv , adns_query qu , vbuf *vb___0 ,
                                byte const   *dgram , int dglen , int cbyte___3 ) 
{ 
  adns_status st ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 178
  st = adns__parse_domain(ads___7, serv, qu, vb___0, (parsedomain_flags )1, dgram,
                          dglen, & cbyte___3, dglen);
  }
#line 180
  if ((unsigned int )st == 1U) {
#line 181
    return ("<cannot report domain... out of memory>");
  }
#line 183
  if (st) {
    {
#line 184
    vb___0->used = 0;
#line 185
    tmp = adns__vbuf_appendstr(vb___0, "<bad format... ");
    }
#line 185
    if (tmp) {
      {
#line 185
      tmp___0 = adns_strerror(st);
#line 185
      tmp___1 = adns__vbuf_appendstr(vb___0, tmp___0);
      }
#line 185
      if (tmp___1) {
        {
#line 185
        tmp___2 = adns__vbuf_appendstr(vb___0, ">");
        }
#line 185
        if (tmp___2) {
          {
#line 185
          tmp___3 = adns__vbuf_append(vb___0, (byte const   *)"", 1);
          }
#line 185
          if (! tmp___3) {
#line 189
            return ("<cannot report bad format... out of memory>");
          }
        } else {
#line 189
          return ("<cannot report bad format... out of memory>");
        }
      } else {
#line 189
        return ("<cannot report bad format... out of memory>");
      }
    } else {
#line 189
      return ("<cannot report bad format... out of memory>");
    }
  }
#line 192
  if (! vb___0->used) {
    {
#line 193
    adns__vbuf_appendstr(vb___0, "<truncated ...>");
#line 194
    adns__vbuf_append(vb___0, (byte const   *)"", 1);
    }
  }
#line 196
  return ((char const   *)vb___0->buf);
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
adns_status adns_rr_info(adns_rrtype type , char const   **rrtname_r , char const   **fmtname_r ,
                         int *len_r , void const   *datap , char **data_r ) 
{ 
  typeinfo const   *typei ;
  vbuf vb___0 ;
  adns_status st ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 207
  typei = adns__findtype(type);
  }
#line 208
  if (! typei) {
#line 208
    return ((adns_status )2);
  }
#line 210
  if (rrtname_r) {
#line 210
    *rrtname_r = (char const   *)typei->rrtname;
  }
#line 211
  if (fmtname_r) {
#line 211
    *fmtname_r = (char const   *)typei->fmtname;
  }
#line 212
  if (len_r) {
#line 212
    *len_r = (int )typei->rrsz;
  }
#line 214
  if (! datap) {
#line 214
    return ((adns_status )0);
  }
  {
#line 216
  adns__vbuf_init(& vb___0);
#line 217
  st = (*(typei->convstring))(& vb___0, datap);
  }
#line 218
  if (st) {
#line 218
    goto x_freevb;
  }
  {
#line 219
  tmp = adns__vbuf_append(& vb___0, (byte const   *)"", 1);
  }
#line 219
  if (! tmp) {
#line 219
    st = (adns_status )1;
#line 219
    goto x_freevb;
  }
  {
#line 220
  tmp___0 = strlen((char const   *)vb___0.buf);
  }
#line 220
  if (! (tmp___0 == (size_t )(vb___0.used - 1))) {
    {
#line 220
    __assert_fail("strlen(vb.buf) == vb.used-1", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c",
                  220U, "adns_rr_info");
    }
  }
  {
#line 221
  tmp___1 = Hrealloc((void *)vb___0.buf, (size_t )vb___0.used);
#line 221
  *data_r = (char *)tmp___1;
  }
#line 222
  if (! *data_r) {
#line 222
    *data_r = (char *)vb___0.buf;
  }
#line 223
  return ((adns_status )0);
  x_freevb: 
  {
#line 226
  adns__vbuf_free(& vb___0);
  }
#line 227
  return (st);
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
static struct sinfo  const  sinfos[24]  = 
#line 233
  {      {(adns_status )0, "ok", "OK"}, 
        {(adns_status )1, "nomemory", "Out of memory"}, 
        {(adns_status )2, "unknownrrtype", "Query not implemented in DNS library"}, 
        {(adns_status )3, "systemfail", "General resolver or system failure"}, 
        {(adns_status )30, "timeout", "DNS query timed out"}, 
        {(adns_status )31, "allservfail", "All nameservers failed"}, 
        {(adns_status )32, "norecurse", "Recursion denied by nameserver"}, 
        {(adns_status )33, "invalidresponse", "Nameserver sent bad response"}, 
        {(adns_status )34, "unknownformat", "Nameserver used unknown format"}, 
        {(adns_status )60, "rcodeservfail", "Nameserver reports failure"}, 
        {(adns_status )61, "rcodeformaterror", "Query not understood by nameserver"}, 
        {(adns_status )62,
      "rcodenotimplemented", "Query not implemented by nameserver"}, 
        {(adns_status )63, "rcoderefused", "Query refused by nameserver"}, 
        {(adns_status )64, "rcodeunknown", "Nameserver sent unknown response code"}, 
        {(adns_status )100, "inconsistent", "Inconsistent resource records in DNS"}, 
        {(adns_status )101, "prohibitedcname", "DNS alias found where canonical name wanted"}, 
        {(adns_status )102,
      "answerdomaininvalid", "Found syntactically invalid domain name"}, 
        {(adns_status )103, "answerdomaintoolong", "Found overly-long domain name"}, 
        {(adns_status )104, "invaliddata", "Found invalid DNS data"}, 
        {(adns_status )200, "querydomainwrong", "Domain invalid for particular DNS query type"}, 
        {(adns_status )201,
      "querydomaininvalid", "Domain name is syntactically invalid"}, 
        {(adns_status )202, "querydomaintoolong", "Domain name or component is too long"}, 
        {(adns_status )300,
      "nxdomain", "No such domain"}, 
        {(adns_status )301, "nodata", "No such data"}};
#line 270 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
static int si_compar(void const   *key , void const   *elem ) 
{ 
  adns_status const   *st ;
  struct sinfo  const  *si ;
  int tmp ;
  int tmp___0 ;

  {
#line 271
  st = (adns_status const   *)key;
#line 272
  si = (struct sinfo  const  *)elem;
#line 274
  if ((unsigned int const   )*st < (unsigned int const   )si->st) {
#line 274
    tmp___0 = -1;
  } else {
#line 274
    if ((unsigned int const   )*st > (unsigned int const   )si->st) {
#line 274
      tmp = 1;
    } else {
#line 274
      tmp = 0;
    }
#line 274
    tmp___0 = tmp;
  }
#line 274
  return (tmp___0);
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
static struct sinfo  const  *findsinfo(adns_status st ) 
{ 
  void *tmp ;

  {
  {
#line 278
  tmp = bsearch((void const   *)(& st), (void const   *)(sinfos), sizeof(sinfos) / sizeof(sinfos[0]),
                sizeof(sinfos[0]), & si_compar);
  }
#line 278
  return ((struct sinfo  const  *)tmp);
}
}
#line 282 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
char const   *adns_strerror(adns_status st ) 
{ 
  struct sinfo  const  *si ;

  {
  {
#line 285
  si = findsinfo(st);
  }
#line 286
  return ((char const   *)si->string);
}
}
#line 289 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
char const   *adns_errabbrev(adns_status st ) 
{ 
  struct sinfo  const  *si ;

  {
  {
#line 292
  si = findsinfo(st);
  }
#line 293
  return ((char const   *)si->abbrev);
}
}
#line 299 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
static struct stinfo  const  stinfos[7]  = {      {(adns_status )0, "ok"}, 
        {(adns_status )29, "localfail"}, 
        {(adns_status )59, "remotefail"}, 
        {(adns_status )99, "tempfail"}, 
        {(adns_status )199, "misconfig"}, 
        {(adns_status )299, "misquery"}, 
        {(adns_status )499, "permfail"}};
#line 312 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
static int sti_compar(void const   *key , void const   *elem ) 
{ 
  adns_status const   *st ;
  struct stinfo  const  *sti ;
  adns_status here ;
  adns_status min ;
  adns_status max ;
  int tmp ;
  int tmp___0 ;

  {
#line 313
  st = (adns_status const   *)key;
#line 314
  sti = (struct stinfo  const  *)elem;
#line 318
  here = (adns_status )*st;
#line 319
  if ((unsigned long )sti == (unsigned long )(stinfos)) {
#line 319
    min = (adns_status )0;
  } else {
#line 319
    min = (adns_status )((unsigned int const   )(sti + -1)->stmax + 1U);
  }
#line 320
  max = (adns_status )sti->stmax;
#line 322
  if ((unsigned int )here < (unsigned int )min) {
#line 322
    tmp___0 = -1;
  } else {
#line 322
    if ((unsigned int )here > (unsigned int )max) {
#line 322
      tmp = 1;
    } else {
#line 322
      tmp = 0;
    }
#line 322
    tmp___0 = tmp;
  }
#line 322
  return (tmp___0);
}
}
#line 325 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
char const   *adns_errtypeabbrev(adns_status st ) 
{ 
  struct stinfo  const  *sti ;
  void *tmp ;

  {
  {
#line 328
  tmp = bsearch((void const   *)(& st), (void const   *)(stinfos), sizeof(stinfos) / sizeof(stinfos[0]),
                sizeof(stinfos[0]), & sti_compar);
#line 328
  sti = (struct stinfo  const  *)tmp;
  }
#line 330
  return ((char const   *)sti->abbrev);
}
}
#line 334 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
void adns__isort(void *array , int nobjs , int sz , void *tempbuf , int (*needswap)(void *context ,
                                                                                    void const   *a ,
                                                                                    void const   *b ) ,
                 void *context ) 
{ 
  byte *data___0 ;
  int i ;
  int place ;
  int tmp ;

  {
#line 337
  data___0 = (byte *)array;
#line 340
  i = 0;
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;
#line 340
    if (! (i < nobjs)) {
#line 340
      goto while_break;
    }
#line 341
    place = i;
    {
#line 341
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 341
      if (place > 0) {
        {
#line 341
        tmp = (*needswap)(context, (void const   *)(data___0 + (place - 1) * sz),
                          (void const   *)(data___0 + i * sz));
        }
#line 341
        if (! tmp) {
#line 341
          goto while_break___0;
        }
      } else {
#line 341
        goto while_break___0;
      }
#line 341
      place --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 344
    if (place != i) {
      {
#line 345
      memcpy((void */* __restrict  */)tempbuf, (void const   */* __restrict  */)(data___0 + i * sz),
             (size_t )sz);
#line 346
      memmove((void *)(data___0 + (place + 1) * sz), (void const   *)(data___0 + place * sz),
              (size_t )((i - place) * sz));
#line 347
      memcpy((void */* __restrict  */)(data___0 + place * sz), (void const   */* __restrict  */)tempbuf,
             (size_t )sz);
      }
    }
#line 340
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 350
  return;
}
}
#line 354 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
void adns__sigpipe_protect(adns_state ads___7 ) 
{ 
  sigset_t toblock ;
  struct sigaction sa___3 ;
  int r ;

  {
#line 359
  if ((unsigned int )ads___7->iflags & 64U) {
#line 359
    return;
  }
  {
#line 361
  sigfillset(& toblock);
#line 362
  sigdelset(& toblock, 13);
#line 364
  sa___3.__sigaction_handler.sa_handler = (void (*)(int  ))1;
#line 365
  sigfillset(& sa___3.sa_mask);
#line 366
  sa___3.sa_flags = 0;
#line 368
  r = sigprocmask(2, (sigset_t const   */* __restrict  */)(& toblock), (sigset_t */* __restrict  */)(& ads___7->stdsigmask));
  }
#line 368
  if (! (! r)) {
    {
#line 368
    __assert_fail("!r", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c",
                  368U, "adns__sigpipe_protect");
    }
  }
  {
#line 369
  r = sigaction(13, (struct sigaction  const  */* __restrict  */)(& sa___3), (struct sigaction */* __restrict  */)(& ads___7->stdsigpipe));
  }
#line 369
  if (! (! r)) {
    {
#line 369
    __assert_fail("!r", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c",
                  369U, "adns__sigpipe_protect");
    }
  }
#line 370
  return;
}
}
#line 372 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
void adns__sigpipe_unprotect(adns_state ads___7 ) 
{ 
  int r ;

  {
#line 375
  if ((unsigned int )ads___7->iflags & 64U) {
#line 375
    return;
  }
  {
#line 377
  r = sigaction(13, (struct sigaction  const  */* __restrict  */)(& ads___7->stdsigpipe),
                (struct sigaction */* __restrict  */)0);
  }
#line 377
  if (! (! r)) {
    {
#line 377
    __assert_fail("!r", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c",
                  377U, "adns__sigpipe_unprotect");
    }
  }
  {
#line 378
  r = sigprocmask(2, (sigset_t const   */* __restrict  */)(& ads___7->stdsigmask),
                  (sigset_t */* __restrict  */)0);
  }
#line 378
  if (! (! r)) {
    {
#line 378
    __assert_fail("!r", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c",
                  378U, "adns__sigpipe_unprotect");
    }
  }
#line 379
  return;
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/poll.h"
extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 163
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  *__addr , socklen_t __addr_len ) ;
#line 174
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 11 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hsyscalls.h"
int Hselect(int max , fd_set *rfds , fd_set *wfds , fd_set *efds , struct timeval *to ) ;
#line 13
int Hpoll(struct pollfd *fds , int nfds , int timeout___3 ) ;
#line 15
int Hsocket(int domain , int type , int protocol ) ;
#line 16
int Hfcntl(int fd , int cmd  , ...) ;
#line 17
int Hconnect(int fd , struct sockaddr  const  *addr , int addrlen ) ;
#line 18
int Hbind(int fd , struct sockaddr  const  *addr , int addrlen ) ;
#line 19
int Hlisten(int fd , int backlog ) ;
#line 20
int Hclose(int fd ) ;
#line 21
int Hsendto(int fd , void const   *msg___5 , int msglen , unsigned int flags , struct sockaddr  const  *addr ,
            int addrlen ) ;
#line 22
int Hrecvfrom(int fd , void *buf___17 , int buflen , unsigned int flags , struct sockaddr *addr ,
              int *addrlen ) ;
#line 23
int Hread(int fd , void *buf___17 , size_t buflen ) ;
#line 24
int Hwrite(int fd , void const   *buf___17 , size_t len ) ;
#line 9 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/harness.h"
void Qselect(int max , fd_set const   *rfds , fd_set const   *wfds , fd_set const   *efds ,
             struct timeval *to ) ;
#line 11
void Qpoll(struct pollfd  const  *fds , int nfds , int timeout___3 ) ;
#line 13
void Qsocket(int type ) ;
#line 14
void Qfcntl(int fd , int cmd , long arg ) ;
#line 15
void Qconnect(int fd , struct sockaddr  const  *addr , int addrlen ) ;
#line 16
void Qbind(int fd , struct sockaddr  const  *addr , int addrlen ) ;
#line 17
void Qlisten(int fd , int backlog ) ;
#line 18
void Qclose(int fd ) ;
#line 19
void Qsendto(int fd , void const   *msg___5 , int msglen , struct sockaddr  const  *addr ,
             int addrlen ) ;
#line 20
void Qrecvfrom(int fd , int buflen , int addrlen ) ;
#line 21
void Qread(int fd , size_t buflen ) ;
#line 22
void Qwrite(int fd , void const   *buf___17 , size_t len ) ;
#line 23
void Q_vb(void) ;
#line 24
void Tshutdown(void) ;
#line 26
void Tfailed(char const   *why ) ;
#line 27
void Toutputerr(void) ;
#line 28
void Tnomem(void) ;
#line 30
void Tensurerecordfile(void) ;
#line 31
void Tmust(char const   *call , char const   *arg , int cond ) ;
#line 32
void ( /* format attribute */  Tvbf)(char const   *fmt  , ...) ;
#line 34
void Tvbfdset(int max , fd_set const   *fds ) ;
#line 35
void Tvbpollfds(struct pollfd  const  *fds , int nfds ) ;
#line 36
void Tvbaddr(struct sockaddr  const  *addr , int len ) ;
#line 37
void Tvbbytes(void const   *buf___17 , int len ) ;
#line 38
void Tvberrno(int e ) ;
#line 39
void Tvba(char const   *str ) ;
#line 41
vbuf vb ;
#line 42
struct timeval currenttime ;
#line 9 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hrecord.c"
static FILE *Toutputfile___0  ;
#line 10 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hrecord.c"
void Tshutdown(void) 
{ 


  {
#line 11
  return;
}
}
#line 12 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hrecord.c"
static void R_recordtime(void) 
{ 
  int r ;
  struct timeval tv ;
  struct timeval tvrel ;

  {
  {
#line 15
  Tensurerecordfile();
#line 16
  r = gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )0);
  }
#line 16
  if (r) {
    {
#line 16
    Tfailed("gettimeofday syscallbegin");
    }
  }
#line 17
  tvrel.tv_sec = tv.tv_sec - currenttime.tv_sec;
#line 18
  tvrel.tv_usec = tv.tv_usec - currenttime.tv_usec;
#line 19
  if (tv.tv_usec < 0L) {
#line 19
    tvrel.tv_usec += 1000000L;
#line 19
    (tvrel.tv_sec) --;
  }
  {
#line 20
  Tvbf("\n +%ld.%06ld", tvrel.tv_sec, tvrel.tv_usec);
#line 21
  currenttime = tv;
  }
#line 22
  return;
}
}
#line 23 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hrecord.c"
void Tensurerecordfile(void) 
{ 
  char const   *fdstr ;
  int fd ;
  int r ;
  char *tmp ;
  int tmp___0 ;

  {
#line 26
  if (Toutputfile___0) {
#line 26
    return;
  }
  {
#line 27
  Toutputfile___0 = stdout;
#line 28
  tmp = getenv("ADNS_TEST_OUT_FD");
#line 28
  fdstr = (char const   *)tmp;
  }
#line 29
  if (fdstr) {
    {
#line 30
    fd = atoi(fdstr);
#line 31
    Toutputfile___0 = fdopen(fd, "a");
    }
#line 31
    if (! Toutputfile___0) {
      {
#line 31
      Tfailed("fdopen ADNS_TEST_OUT_FD");
      }
    }
  }
  {
#line 33
  r = gettimeofday((struct timeval */* __restrict  */)(& currenttime), (__timezone_ptr_t )0);
  }
#line 33
  if (r) {
    {
#line 33
    Tfailed("gettimeofday syscallbegin");
    }
  }
  {
#line 34
  tmp___0 = fprintf((FILE */* __restrict  */)Toutputfile___0, (char const   */* __restrict  */)" start %ld.%06ld\n",
                    currenttime.tv_sec, currenttime.tv_usec);
  }
#line 34
  if (tmp___0 == -1) {
    {
#line 35
    Toutputerr();
    }
  }
#line 36
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hrecord.c"
void Q_vb(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 38
  tmp = adns__vbuf_append(& vb, (byte const   *)"", 1);
  }
#line 38
  if (! tmp) {
    {
#line 38
    Tnomem();
    }
  }
  {
#line 39
  Tensurerecordfile();
#line 40
  tmp___0 = fprintf((FILE */* __restrict  */)Toutputfile___0, (char const   */* __restrict  */)" %s\n",
                    vb.buf);
  }
#line 40
  if (tmp___0 == -1) {
    {
#line 40
    Toutputerr();
    }
  }
  {
#line 41
  tmp___1 = fflush(Toutputfile___0);
  }
#line 41
  if (tmp___1) {
    {
#line 41
    Toutputerr();
    }
  }
#line 42
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hrecord.c"
static void R_vb(void) 
{ 


  {
  {
#line 44
  Q_vb();
  }
#line 45
  return;
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hrecord.c"
int Hselect(int max , fd_set *rfds , fd_set *wfds , fd_set *efds , struct timeval *to ) 
{ 
  int r ;
  int e ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 48
  Qselect(max, (fd_set const   *)rfds, (fd_set const   *)wfds, (fd_set const   *)efds,
          to);
#line 49
  r = select(max, (fd_set */* __restrict  */)rfds, (fd_set */* __restrict  */)wfds,
             (fd_set */* __restrict  */)efds, (struct timeval */* __restrict  */)to);
#line 50
  tmp = __errno_location();
#line 50
  e = *tmp;
#line 51
  vb.used = 0;
#line 52
  Tvba("select=");
  }
#line 53
  if (r == -1) {
    {
#line 53
    Tvberrno(e);
    }
#line 53
    goto x_error;
  }
  {
#line 54
  Tvbf("%d", r);
#line 55
  Tvba(" rfds=");
#line 55
  Tvbfdset(max, (fd_set const   *)rfds);
#line 56
  Tvba(" wfds=");
#line 56
  Tvbfdset(max, (fd_set const   *)wfds);
#line 57
  Tvba(" efds=");
#line 57
  Tvbfdset(max, (fd_set const   *)efds);
  }
  x_error: 
  {
#line 59
  R_recordtime();
#line 60
  R_vb();
#line 61
  tmp___0 = __errno_location();
#line 61
  *tmp___0 = e;
  }
#line 62
  return (r);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hrecord.c"
int Hpoll(struct pollfd *fds , int nfds , int timeout___3 ) 
{ 
  int r ;
  int e ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 67
  Qpoll((struct pollfd  const  *)fds, nfds, timeout___3);
#line 68
  r = poll(fds, (nfds_t )nfds, timeout___3);
#line 69
  tmp = __errno_location();
#line 69
  e = *tmp;
#line 70
  vb.used = 0;
#line 71
  Tvba("poll=");
  }
#line 72
  if (r == -1) {
    {
#line 72
    Tvberrno(e);
    }
#line 72
    goto x_error;
  }
  {
#line 73
  Tvbf("%d", r);
#line 74
  Tvba(" fds=");
#line 74
  Tvbpollfds((struct pollfd  const  *)fds, nfds);
  }
  x_error: 
  {
#line 76
  R_recordtime();
#line 77
  R_vb();
#line 78
  tmp___0 = __errno_location();
#line 78
  *tmp___0 = e;
  }
#line 79
  return (r);
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hrecord.c"
int Hsocket(int domain , int type , int protocol ) 
{ 
  int r ;
  int e ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 84
  Tmust("socket", "domain", domain == 2);
  }
#line 85
  if (type == 1) {
#line 85
    tmp = 1;
  } else
#line 85
  if (type == 2) {
#line 85
    tmp = 1;
  } else {
#line 85
    tmp = 0;
  }
  {
#line 85
  Tmust("socket", "type", tmp);
#line 86
  Qsocket(type);
#line 87
  r = socket(domain, type, protocol);
#line 88
  tmp___0 = __errno_location();
#line 88
  e = *tmp___0;
#line 89
  vb.used = 0;
#line 90
  Tvba("socket=");
  }
#line 91
  if (r == -1) {
    {
#line 91
    Tvberrno(e);
    }
#line 91
    goto x_error;
  }
  {
#line 92
  Tvbf("%d", r);
  }
  x_error: 
  {
#line 94
  R_recordtime();
#line 95
  R_vb();
#line 96
  tmp___1 = __errno_location();
#line 96
  *tmp___1 = e;
  }
#line 97
  return (r);
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hrecord.c"
int Hfcntl(int fd , int cmd  , ...) 
{ 
  int r ;
  int e ;
  va_list al ;
  long arg ;
  int tmp ;
  long tmp___0 ;
  int *tmp___1 ;
  char const   *tmp___2 ;
  int *tmp___3 ;

  {
#line 102
  if (cmd == 4) {
#line 102
    tmp = 1;
  } else
#line 102
  if (cmd == 3) {
#line 102
    tmp = 1;
  } else {
#line 102
    tmp = 0;
  }
  {
#line 102
  Tmust("fcntl", "cmd", tmp);
  }
#line 103
  if (cmd == 4) {
    {
#line 104
    __builtin_va_start(al, cmd);
#line 104
    tmp___0 = __builtin_va_arg(al, long );
#line 104
    arg = tmp___0;
#line 104
    __builtin_va_end(al);
    }
  } else {
#line 106
    arg = 0L;
  }
  {
#line 108
  Qfcntl(fd, cmd, arg);
#line 109
  r = fcntl(fd, cmd, arg);
#line 110
  tmp___1 = __errno_location();
#line 110
  e = *tmp___1;
#line 111
  vb.used = 0;
#line 112
  Tvba("fcntl=");
  }
#line 113
  if (r == -1) {
    {
#line 113
    Tvberrno(e);
    }
#line 113
    goto x_error;
  }
#line 114
  if (cmd == 3) {
#line 115
    if (r & 2048) {
#line 115
      tmp___2 = "O_NONBLOCK|...";
    } else {
#line 115
      tmp___2 = "~O_NONBLOCK&...";
    }
    {
#line 115
    Tvbf(tmp___2);
    }
  } else {
#line 117
    if (cmd == 4) {
      {
#line 118
      Tmust("fcntl", "return", ! r);
      }
    } else {
      {
#line 120
      Tmust("cmd", "F_GETFL/F_SETFL", 0);
      }
    }
    {
#line 122
    Tvba("OK");
    }
  }
  x_error: 
  {
#line 125
  R_recordtime();
#line 126
  R_vb();
#line 127
  tmp___3 = __errno_location();
#line 127
  *tmp___3 = e;
  }
#line 128
  return (r);
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hrecord.c"
int Hconnect(int fd , struct sockaddr  const  *addr , int addrlen ) 
{ 
  int r ;
  int e ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 132
  Qconnect(fd, addr, addrlen);
#line 133
  r = connect(fd, addr, (socklen_t )addrlen);
#line 134
  tmp = __errno_location();
#line 134
  e = *tmp;
#line 135
  vb.used = 0;
#line 136
  Tvba("connect=");
  }
#line 137
  if (r) {
    {
#line 137
    Tvberrno(e);
    }
#line 137
    goto x_error;
  }
  {
#line 138
  Tvba("OK");
  }
  x_error: 
  {
#line 140
  R_recordtime();
#line 141
  R_vb();
#line 142
  tmp___0 = __errno_location();
#line 142
  *tmp___0 = e;
  }
#line 143
  return (r);
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hrecord.c"
int Hbind(int fd , struct sockaddr  const  *addr , int addrlen ) 
{ 
  int r ;
  int e ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 147
  Qbind(fd, addr, addrlen);
#line 148
  r = bind(fd, addr, (socklen_t )addrlen);
#line 149
  tmp = __errno_location();
#line 149
  e = *tmp;
#line 150
  vb.used = 0;
#line 151
  Tvba("bind=");
  }
#line 152
  if (r) {
    {
#line 152
    Tvberrno(e);
    }
#line 152
    goto x_error;
  }
  {
#line 153
  Tvba("OK");
  }
  x_error: 
  {
#line 155
  R_recordtime();
#line 156
  R_vb();
#line 157
  tmp___0 = __errno_location();
#line 157
  *tmp___0 = e;
  }
#line 158
  return (r);
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hrecord.c"
int Hlisten(int fd , int backlog ) 
{ 
  int r ;
  int e ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 162
  Qlisten(fd, backlog);
#line 163
  r = listen(fd, backlog);
#line 164
  tmp = __errno_location();
#line 164
  e = *tmp;
#line 165
  vb.used = 0;
#line 166
  Tvba("listen=");
  }
#line 167
  if (r) {
    {
#line 167
    Tvberrno(e);
    }
#line 167
    goto x_error;
  }
  {
#line 168
  Tvba("OK");
  }
  x_error: 
  {
#line 170
  R_recordtime();
#line 171
  R_vb();
#line 172
  tmp___0 = __errno_location();
#line 172
  *tmp___0 = e;
  }
#line 173
  return (r);
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hrecord.c"
int Hclose(int fd ) 
{ 
  int r ;
  int e ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 177
  Qclose(fd);
#line 178
  r = close(fd);
#line 179
  tmp = __errno_location();
#line 179
  e = *tmp;
#line 180
  vb.used = 0;
#line 181
  Tvba("close=");
  }
#line 182
  if (r) {
    {
#line 182
    Tvberrno(e);
    }
#line 182
    goto x_error;
  }
  {
#line 183
  Tvba("OK");
  }
  x_error: 
  {
#line 185
  R_recordtime();
#line 186
  R_vb();
#line 187
  tmp___0 = __errno_location();
#line 187
  *tmp___0 = e;
  }
#line 188
  return (r);
}
}
#line 190 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hrecord.c"
int Hsendto(int fd , void const   *msg___5 , int msglen , unsigned int flags , struct sockaddr  const  *addr ,
            int addrlen ) 
{ 
  int r ;
  int e ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 192
  Tmust("sendto", "flags", flags == 0U);
#line 193
  Qsendto(fd, msg___5, msglen, addr, addrlen);
#line 194
  tmp = sendto(fd, msg___5, (size_t )msglen, (int )flags, addr, (socklen_t )addrlen);
#line 194
  r = (int )tmp;
#line 195
  tmp___0 = __errno_location();
#line 195
  e = *tmp___0;
#line 196
  vb.used = 0;
#line 197
  Tvba("sendto=");
  }
#line 198
  if (r == -1) {
    {
#line 198
    Tvberrno(e);
    }
#line 198
    goto x_error;
  }
  {
#line 199
  Tvbf("%d", r);
  }
  x_error: 
  {
#line 201
  R_recordtime();
#line 202
  R_vb();
#line 203
  tmp___1 = __errno_location();
#line 203
  *tmp___1 = e;
  }
#line 204
  return (r);
}
}
#line 206 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hrecord.c"
int Hrecvfrom(int fd , void *buf___17 , int buflen , unsigned int flags , struct sockaddr *addr ,
              int *addrlen ) 
{ 
  int r ;
  int e ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 208
  Tmust("recvfrom", "flags", flags == 0U);
#line 209
  Tmust("recvfrom", "*addrlen", (unsigned long )*addrlen >= sizeof(struct sockaddr_in ));
#line 210
  Qrecvfrom(fd, buflen, *addrlen);
#line 211
  tmp = recvfrom(fd, (void */* __restrict  */)buf___17, (size_t )buflen, (int )flags,
                 (struct sockaddr */* __restrict  */)addr, (socklen_t */* __restrict  */)addrlen);
#line 211
  r = (int )tmp;
#line 212
  tmp___0 = __errno_location();
#line 212
  e = *tmp___0;
#line 213
  vb.used = 0;
#line 214
  Tvba("recvfrom=");
  }
#line 215
  if (r == -1) {
    {
#line 215
    Tvberrno(e);
    }
#line 215
    goto x_error;
  }
  {
#line 216
  Tmust("recvfrom", "return", r <= buflen);
#line 217
  Tvba("OK");
#line 218
  Tvba(" addr=");
#line 218
  Tvbaddr((struct sockaddr  const  *)addr, *addrlen);
#line 219
  Tvbbytes((void const   *)buf___17, r);
  }
  x_error: 
  {
#line 221
  R_recordtime();
#line 222
  R_vb();
#line 223
  tmp___1 = __errno_location();
#line 223
  *tmp___1 = e;
  }
#line 224
  return (r);
}
}
#line 226 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hrecord.c"
int Hread(int fd , void *buf___17 , size_t buflen ) 
{ 
  int r ;
  int e ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 228
  Qread(fd, buflen);
#line 229
  tmp = read(fd, buf___17, buflen);
#line 229
  r = (int )tmp;
#line 230
  tmp___0 = __errno_location();
#line 230
  e = *tmp___0;
#line 231
  vb.used = 0;
#line 232
  Tvba("read=");
  }
#line 233
  if (r == -1) {
    {
#line 233
    Tvberrno(e);
    }
#line 233
    goto x_error;
  }
  {
#line 234
  Tmust("read", "return", (size_t )r <= buflen);
#line 235
  Tvba("OK");
#line 236
  Tvbbytes((void const   *)buf___17, r);
  }
  x_error: 
  {
#line 238
  R_recordtime();
#line 239
  R_vb();
#line 240
  tmp___1 = __errno_location();
#line 240
  *tmp___1 = e;
  }
#line 241
  return (r);
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hrecord.c"
int Hwrite(int fd , void const   *buf___17 , size_t len ) 
{ 
  int r ;
  int e ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 245
  Qwrite(fd, buf___17, len);
#line 246
  tmp = write(fd, buf___17, len);
#line 246
  r = (int )tmp;
#line 247
  tmp___0 = __errno_location();
#line 247
  e = *tmp___0;
#line 248
  vb.used = 0;
#line 249
  Tvba("write=");
  }
#line 250
  if (r == -1) {
    {
#line 250
    Tvberrno(e);
    }
#line 250
    goto x_error;
  }
  {
#line 251
  Tvbf("%d", r);
  }
  x_error: 
  {
#line 253
  R_recordtime();
#line 254
  R_vb();
#line 255
  tmp___1 = __errno_location();
#line 255
  *tmp___1 = e;
  }
#line 256
  return (r);
}
}
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 379 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 390
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hsyscalls.h"
int Hwritev(int fd , struct iovec  const  *vector , size_t count ) ;
#line 26
int Hgettimeofday(struct timeval *tv , struct timezone *tz ) ;
#line 28
void *Hmalloc(size_t sz ) ;
#line 31
 __attribute__((__noreturn__)) void Hexit(int rv ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/harness.h"
void Tvbvf(char const   *fmt , va_list al ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/harness.h"
vbuf vb  ;
#line 42 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/harness.h"
struct timeval currenttime  ;
#line 43
struct Terrno  const  Terrnos[17] ;
#line 14 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
FILE *Toutputfile  =    (FILE *)0;
#line 16 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
struct Terrno  const  Terrnos[17]  = 
#line 16
  {      {"EBADF", 9}, 
        {"EAGAIN", 11}, 
        {"EINPROGRESS", 115}, 
        {"EINTR", 4}, 
        {"EINVAL", 22}, 
        {"EMSGSIZE", 90}, 
        {"ENOBUFS", 105}, 
        {"ENOENT", 2}, 
        {"ENOPROTOOPT", 92}, 
        {"ENOSPC", 28}, 
        {"EWOULDBLOCK", 11}, 
        {"EHOSTUNREACH", 113}, 
        {"ECONNRESET", 104}, 
        {"ECONNREFUSED", 111}, 
        {"EPIPE", 32}, 
        {"ENOTSOCK", 88}, 
        {(char const   *)0, 0}};
#line 35 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
static vbuf vbw  ;
#line 36 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
int Hgettimeofday(struct timeval *tv , struct timezone *tz ) 
{ 


  {
  {
#line 37
  Tensurerecordfile();
#line 38
  Tmust("gettimeofday", "tz", ! tz);
#line 39
  *tv = currenttime;
  }
#line 40
  return (0);
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
int Hwritev(int fd , struct iovec  const  *vector , size_t count ) 
{ 
  size_t i ;
  int tmp ;
  int tmp___0 ;

  {
#line 44
  vbw.used = 0;
#line 45
  i = (size_t )0;
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
#line 45
    if (! (i < count)) {
#line 45
      goto while_break;
    }
    {
#line 46
    tmp = adns__vbuf_append(& vbw, (byte const   *)vector->iov_base, (int )vector->iov_len);
    }
#line 46
    if (! tmp) {
      {
#line 46
      Tnomem();
      }
    }
#line 45
    i ++;
#line 45
    vector ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 48
  tmp___0 = Hwrite(fd, (void const   *)vbw.buf, (size_t )vbw.used);
  }
#line 48
  return (tmp___0);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
void Qselect(int max , fd_set const   *rfds , fd_set const   *wfds , fd_set const   *efds ,
             struct timeval *to ) 
{ 


  {
  {
#line 51
  vb.used = 0;
#line 52
  Tvba("select");
#line 53
  Tvbf(" max=%d", max);
#line 54
  Tvbf(" rfds=");
#line 54
  Tvbfdset(max, rfds);
#line 55
  Tvbf(" wfds=");
#line 55
  Tvbfdset(max, wfds);
#line 56
  Tvbf(" efds=");
#line 56
  Tvbfdset(max, efds);
  }
#line 57
  if (to) {
    {
#line 57
    Tvbf(" to=%ld.%06ld", to->tv_sec, to->tv_usec);
    }
  } else {
    {
#line 58
    Tvba(" to=null");
    }
  }
  {
#line 59
  Q_vb();
  }
#line 60
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
void Qpoll(struct pollfd  const  *fds , int nfds , int timeout___3 ) 
{ 


  {
  {
#line 63
  vb.used = 0;
#line 64
  Tvba("poll");
#line 65
  Tvbf(" fds=");
#line 65
  Tvbpollfds(fds, nfds);
#line 66
  Tvbf(" timeout=%d", timeout___3);
#line 67
  Q_vb();
  }
#line 68
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
void Qsocket(int type ) 
{ 
  char const   *tmp ;

  {
  {
#line 71
  vb.used = 0;
#line 72
  Tvba("socket");
  }
#line 73
  if (type == 1) {
#line 73
    tmp = " type=SOCK_STREAM";
  } else {
#line 73
    tmp = " type=SOCK_DGRAM";
  }
  {
#line 73
  Tvbf(tmp);
#line 74
  Q_vb();
  }
#line 75
  return;
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
void Qfcntl(int fd , int cmd , long arg ) 
{ 
  char const   *tmp ;

  {
  {
#line 77
  vb.used = 0;
#line 78
  Tvba("fcntl");
#line 79
  Tvbf(" fd=%d", fd);
  }
#line 80
  if (cmd == 4) {
#line 81
    if (arg & 2048L) {
#line 81
      tmp = "O_NONBLOCK|...";
    } else {
#line 81
      tmp = "~O_NONBLOCK&...";
    }
    {
#line 81
    Tvbf(" cmd=F_SETFL %s", tmp);
    }
  } else
#line 82
  if (cmd == 3) {
    {
#line 83
    Tvba(" cmd=F_GETFL");
    }
  } else {
    {
#line 85
    Tmust("cmd", "F_GETFL/F_SETFL", 0);
    }
  }
  {
#line 87
  Q_vb();
  }
#line 88
  return;
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
void Qconnect(int fd , struct sockaddr  const  *addr , int addrlen ) 
{ 


  {
  {
#line 90
  vb.used = 0;
#line 91
  Tvba("connect");
#line 92
  Tvbf(" fd=%d", fd);
#line 93
  Tvba(" addr=");
#line 93
  Tvbaddr(addr, addrlen);
#line 94
  Q_vb();
  }
#line 95
  return;
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
void Qbind(int fd , struct sockaddr  const  *addr , int addrlen ) 
{ 


  {
  {
#line 97
  vb.used = 0;
#line 98
  Tvba("bind");
#line 99
  Tvbf(" fd=%d", fd);
#line 100
  Tvba(" addr=");
#line 100
  Tvbaddr(addr, addrlen);
#line 101
  Q_vb();
  }
#line 102
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
void Qlisten(int fd , int backlog ) 
{ 


  {
  {
#line 104
  vb.used = 0;
#line 105
  Tvba("listen");
#line 106
  Tvbf(" fd=%d", fd);
#line 107
  Tvbf(" backlog=%d", backlog);
#line 108
  Q_vb();
  }
#line 109
  return;
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
void Qclose(int fd ) 
{ 


  {
  {
#line 111
  vb.used = 0;
#line 112
  Tvba("close");
#line 113
  Tvbf(" fd=%d", fd);
#line 114
  Q_vb();
  }
#line 115
  return;
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
void Qsendto(int fd , void const   *msg___5 , int msglen , struct sockaddr  const  *addr ,
             int addrlen ) 
{ 


  {
  {
#line 117
  vb.used = 0;
#line 118
  Tvba("sendto");
#line 119
  Tvbf(" fd=%d", fd);
#line 120
  Tvba(" addr=");
#line 120
  Tvbaddr(addr, addrlen);
#line 121
  Tvbbytes(msg___5, msglen);
#line 122
  Q_vb();
  }
#line 123
  return;
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
void Qrecvfrom(int fd , int buflen , int addrlen ) 
{ 


  {
  {
#line 125
  vb.used = 0;
#line 126
  Tvba("recvfrom");
#line 127
  Tvbf(" fd=%d", fd);
#line 128
  Tvbf(" buflen=%lu", (unsigned long )buflen);
#line 129
  Tvbf(" *addrlen=%d", addrlen);
#line 130
  Q_vb();
  }
#line 131
  return;
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
void Qread(int fd , size_t buflen ) 
{ 


  {
  {
#line 133
  vb.used = 0;
#line 134
  Tvba("read");
#line 135
  Tvbf(" fd=%d", fd);
#line 136
  Tvbf(" buflen=%lu", buflen);
#line 137
  Q_vb();
  }
#line 138
  return;
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
void Qwrite(int fd , void const   *buf___17 , size_t len ) 
{ 


  {
  {
#line 140
  vb.used = 0;
#line 141
  Tvba("write");
#line 142
  Tvbf(" fd=%d", fd);
#line 143
  Tvbbytes(buf___17, (int )len);
#line 144
  Q_vb();
  }
#line 145
  return;
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
void Tvbaddr(struct sockaddr  const  *addr , int len ) 
{ 
  struct sockaddr_in  const  *ai ;
  uint16_t tmp ;
  char *tmp___0 ;

  {
#line 147
  ai = (struct sockaddr_in  const  *)addr;
#line 148
  if (! ((unsigned long )len == sizeof(struct sockaddr_in ))) {
    {
#line 148
    __assert_fail("len==sizeof(struct sockaddr_in)", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c",
                  148U, "Tvbaddr");
    }
  }
#line 149
  if (! ((int const   )ai->sin_family == 2)) {
    {
#line 149
    __assert_fail("ai->sin_family==2", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c",
                  149U, "Tvbaddr");
    }
  }
  {
#line 150
  tmp = htons((uint16_t )ai->sin_port);
#line 150
  tmp___0 = inet_ntoa((struct in_addr )ai->sin_addr);
#line 150
  Tvbf("%s:%u", tmp___0, (int )tmp);
  }
#line 151
  return;
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
void Tvbbytes(void const   *buf___17 , int len ) 
{ 
  byte const   *bp ;
  int i ;

  {
#line 155
  if (! len) {
    {
#line 155
    Tvba("\n     .");
    }
#line 155
    return;
  }
#line 156
  i = 0;
#line 156
  bp = (byte const   *)buf___17;
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (! (i < len)) {
#line 156
      goto while_break;
    }
#line 157
    if (! (i & 31)) {
      {
#line 157
      Tvba("\n     ");
      }
    } else
#line 158
    if (! (i & 3)) {
      {
#line 158
      Tvba(" ");
      }
    }
    {
#line 159
    Tvbf("%02x", (int const   )*bp);
#line 156
    i ++;
#line 156
    bp ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 161
  Tvba(".");
  }
#line 162
  return;
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
void Tvbfdset(int max , fd_set const   *fds ) 
{ 
  int i ;
  char const   *comma ;

  {
  {
#line 165
  comma = "";
#line 166
  Tvba("[");
#line 167
  i = 0;
  }
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (! (i < max)) {
#line 167
      goto while_break;
    }
#line 168
    if (! ((fds->__fds_bits[i / (8 * (int )sizeof(__fd_mask ))] & (1L << i % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
#line 168
      goto __Cont;
    }
    {
#line 169
    Tvba(comma);
#line 170
    Tvbf("%d", i);
#line 171
    comma = ",";
    }
    __Cont: /* CIL Label */ 
#line 167
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 173
  Tvba("]");
  }
#line 174
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
static void Tvbpollevents(int events ) 
{ 
  char const   *delim ;

  {
#line 176
  delim = "";
#line 177
  events &= 7;
#line 178
  if (! events) {
    {
#line 178
    Tvba("0");
    }
#line 178
    return;
  }
#line 179
  if (events & 1) {
    {
#line 179
    Tvba("POLLIN");
#line 179
    delim = "|";
    }
  }
#line 180
  if (events & 4) {
    {
#line 180
    Tvba(delim);
#line 180
    Tvba("POLLOUT");
#line 180
    delim = "|";
    }
  }
#line 181
  if (events & 2) {
    {
#line 181
    Tvba(delim);
#line 181
    Tvba("POLLPRI");
    }
  }
#line 182
  return;
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
void Tvbpollfds(struct pollfd  const  *fds , int nfds ) 
{ 
  char const   *comma ;

  {
  {
#line 184
  comma = "";
#line 185
  Tvba("[");
  }
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 186
    if (! (nfds > 0)) {
#line 186
      goto while_break;
    }
    {
#line 187
    Tvba(comma);
#line 188
    Tvbf("{fd=%d, events=", fds->fd);
#line 189
    Tvbpollevents((int )fds->events);
#line 190
    Tvba(", revents=");
#line 191
    Tvbpollevents((int )fds->revents);
#line 192
    Tvba("}");
#line 193
    comma = ", ";
#line 194
    nfds --;
#line 194
    fds ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 196
  Tvba("]");
  }
#line 197
  return;
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
void Tvberrno(int e ) 
{ 
  struct Terrno  const  *te ;

  {
#line 200
  te = Terrnos;
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 200
    if (te->n) {
#line 200
      if (! (te->v != (int const   )e)) {
#line 200
        goto while_break;
      }
    } else {
#line 200
      goto while_break;
    }
#line 200
    te ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 201
  if (! te->n) {
    {
#line 201
    __assert_fail("te->n", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c",
                  201U, "Tvberrno");
    }
  }
  {
#line 202
  Tvba((char const   *)te->n);
  }
#line 203
  return;
}
}
#line 204 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
void Tvba(char const   *str ) 
{ 
  int tmp ;

  {
  {
#line 205
  tmp = adns__vbuf_appendstr(& vb, str);
  }
#line 205
  if (! tmp) {
    {
#line 205
    Tnomem();
    }
  }
#line 206
  return;
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
void Tvbvf(char const   *fmt , va_list al ) 
{ 
  char buf___17[1000] ;

  {
  {
#line 209
  buf___17[sizeof(buf___17) - 2UL] = (char )'\t';
#line 210
  vsnprintf((char */* __restrict  */)(buf___17), sizeof(buf___17), (char const   */* __restrict  */)fmt,
            al);
  }
#line 211
  if (! ((int )buf___17[sizeof(buf___17) - 2UL] == 9)) {
    {
#line 211
    __assert_fail("buf[sizeof(buf)-2] == \'\\t\'", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c",
                  211U, "Tvbvf");
    }
  }
  {
#line 212
  Tvba((char const   *)(buf___17));
  }
#line 213
  return;
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
void ( /* format attribute */  Tvbf)(char const   *fmt  , ...) 
{ 
  va_list al ;

  {
  {
#line 216
  __builtin_va_start(al, fmt);
#line 217
  Tvbvf(fmt, al);
#line 218
  __builtin_va_end(al);
  }
#line 219
  return;
}
}
#line 220 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
void Tmust(char const   *call , char const   *arg , int cond ) 
{ 


  {
#line 221
  if (cond) {
#line 221
    return;
  }
  {
#line 222
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adns test harness: case not handled: system call %s, arg %s",
          call, arg);
#line 223
  exit(-1);
  }
}
}
#line 225 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
void Tfailed(char const   *why ) 
{ 
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 226
  tmp = __errno_location();
#line 226
  tmp___0 = strerror(*tmp);
#line 226
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adns test harness: failure: %s: %s\n",
          why, tmp___0);
#line 227
  exit(-1);
  }
}
}
#line 229 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
void Tnomem(void) 
{ 


  {
  {
#line 230
  Tfailed("unable to malloc/realloc");
  }
#line 231
  return;
}
}
#line 232 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
void Toutputerr(void) 
{ 


  {
  {
#line 233
  Tfailed("write error on test harness output");
  }
#line 234
  return;
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
static unsigned long malloccount  ;
#line 241 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
static unsigned long mallocfailat  ;
#line 242 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
static struct __anonstruct_mallocedlist_90 mallocedlist  ;
#line 244 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
void *Hmalloc(size_t sz ) 
{ 
  struct malloced *newnode ;
  char const   *mfavar ;
  char *ep ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 248
  if (! sz) {
    {
#line 248
    __assert_fail("sz", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c",
                  248U, "Hmalloc");
    }
  }
  {
#line 249
  tmp = malloc((size_t )((char *)(& (mallocedlist.head)->data) - (char *)mallocedlist.head) + sz);
#line 249
  newnode = (struct malloced *)tmp;
  }
#line 249
  if (! newnode) {
    {
#line 249
    Tnomem();
    }
  }
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    newnode->next = (struct malloced *)0;
#line 250
    newnode->back = mallocedlist.tail;
#line 250
    if (mallocedlist.tail) {
#line 250
      (mallocedlist.tail)->next = newnode;
    } else {
#line 250
      mallocedlist.head = newnode;
    }
#line 250
    mallocedlist.tail = newnode;
#line 250
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 251
  newnode->sz = sz;
#line 252
  malloccount ++;
#line 252
  newnode->count = malloccount;
#line 253
  if (! mallocfailat) {
    {
#line 254
    tmp___0 = getenv("ADNS_REGRESS_MALLOCFAILAT");
#line 254
    mfavar = (char const   *)tmp___0;
    }
#line 255
    if (mfavar) {
      {
#line 256
      mallocfailat = strtoul((char const   */* __restrict  */)mfavar, (char **/* __restrict  */)(& ep),
                             10);
      }
#line 257
      if (! mallocfailat) {
        {
#line 257
        Tfailed("ADNS_REGRESS_MALLOCFAILAT bad value");
        }
      } else
#line 257
      if (*ep) {
        {
#line 257
        Tfailed("ADNS_REGRESS_MALLOCFAILAT bad value");
        }
      }
    } else {
#line 259
      mallocfailat = ~ 0UL;
    }
  }
#line 262
  if (! (newnode->count != mallocfailat)) {
    {
#line 262
    __assert_fail("newnode->count != mallocfailat", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c",
                  262U, "Hmalloc");
    }
  }
  {
#line 263
  memset((void *)(& newnode->data), 199, sz);
  }
#line 264
  return ((void *)(& newnode->data));
}
}
#line 266 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
void Hfree(void *ptr ) 
{ 
  struct malloced *oldnode ;

  {
#line 268
  if (! ptr) {
#line 268
    return;
  }
#line 269
  oldnode = (struct malloced *)((void *)((char *)ptr - ((char *)(& (mallocedlist.head)->data) - (char *)mallocedlist.head)));
  {
#line 270
  while (1) {
    while_continue: /* CIL Label */ ;
#line 270
    if (oldnode->back) {
#line 270
      (oldnode->back)->next = oldnode->next;
    } else {
#line 270
      mallocedlist.head = oldnode->next;
    }
#line 270
    if (oldnode->next) {
#line 270
      (oldnode->next)->back = oldnode->back;
    } else {
#line 270
      mallocedlist.tail = oldnode->back;
    }
#line 270
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 271
  memset((void *)(& oldnode->data), 56, oldnode->sz);
#line 272
  free((void *)oldnode);
  }
#line 273
  return;
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
void *Hrealloc(void *op , size_t nsz ) 
{ 
  struct malloced *oldnode ;
  void *np ;
  size_t osz ;
  size_t tmp ;

  {
#line 278
  if (op) {
#line 278
    oldnode = (struct malloced *)((void *)((char *)op - ((char *)(& (mallocedlist.head)->data) - (char *)mallocedlist.head)));
#line 278
    osz = oldnode->sz;
  } else {
#line 278
    osz = (size_t )0;
  }
  {
#line 279
  np = Hmalloc(nsz);
  }
#line 280
  if (osz > nsz) {
#line 280
    tmp = nsz;
  } else {
#line 280
    tmp = osz;
  }
  {
#line 280
  memcpy((void */* __restrict  */)np, (void const   */* __restrict  */)op, tmp);
#line 281
  Hfree(op);
  }
#line 282
  return (np);
}
}
#line 284
 __attribute__((__noreturn__)) void Hexit(int rv ) ;
#line 284 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
void Hexit(int rv ) 
{ 
  struct malloced *loopnode ;
  int tmp ;

  {
  {
#line 286
  Tshutdown();
#line 287
  adns__vbuf_free(& vb);
#line 288
  adns__vbuf_free(& vbw);
  }
#line 289
  if (mallocedlist.head) {
    {
#line 290
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adns test harness: memory leaked:");
#line 291
    loopnode = mallocedlist.head;
    }
    {
#line 291
    while (1) {
      while_continue: /* CIL Label */ ;
#line 291
      if (! loopnode) {
#line 291
        goto while_break;
      }
      {
#line 292
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %lu",
              loopnode->count);
#line 291
      loopnode = loopnode->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 293
    _IO_putc('\n', stderr);
#line 294
    tmp = ferror(stderr);
    }
#line 294
    if (tmp) {
      {
#line 294
      exit(-1);
      }
    }
  }
  {
#line 296
  exit(rv);
  }
}
}
#line 298 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
pid_t Hgetpid(void) 
{ 


  {
#line 299
  return (2264);
}
}
#line 515 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 791
extern  __attribute__((__nothrow__)) ldiv_t ( __attribute__((__leaf__)) ldiv)(long __numer ,
                                                                              long __denom )  __attribute__((__const__)) ;
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 357 "/usr/include/netdb.h"
extern struct protoent *getprotobyname(char const   *__name ) ;
#line 555 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/adns.h"
int adns_check(adns_state ads___7 , adns_query *query_io , adns_answer **answer_r ,
               void **context_r ) ;
#line 560
int adns_wait(adns_state ads___7 , adns_query *query_io , adns_answer **answer_r ,
              void **context_r ) ;
#line 663
int adns_processany(adns_state ads___7 ) ;
#line 670
int adns_processreadable(adns_state ads___7 , int fd , struct timeval  const  *now ) ;
#line 671
int adns_processwriteable(adns_state ads___7 , int fd , struct timeval  const  *now ) ;
#line 672
int adns_processexceptional(adns_state ads___7 , int fd , struct timeval  const  *now ) ;
#line 691
void adns_processtimeouts(adns_state ads___7 , struct timeval  const  *now ) ;
#line 699
void adns_firsttimeout(adns_state ads___7 , struct timeval **tv_io , struct timeval *tvbuf ,
                       struct timeval now ) ;
#line 718
void adns_globalsystemfailure(adns_state ads___7 ) ;
#line 737
void adns_beforeselect(adns_state ads___7 , int *maxfd_io , fd_set *readfds_io , fd_set *writefds_io ,
                       fd_set *exceptfds_io , struct timeval **tv_mod , struct timeval *tv_tobuf ,
                       struct timeval  const  *now ) ;
#line 753
void adns_afterselect(adns_state ads___7 , int maxfd , fd_set const   *readfds , fd_set const   *writefds ,
                      fd_set const   *exceptfds , struct timeval  const  *now ) ;
#line 344 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/internal.h"
int adns__setnonblock(adns_state ads___7 , int fd ) ;
#line 419
void adns__querysend_tcp(adns_query qu , struct timeval now ) ;
#line 425
void adns__query_send(adns_query qu , struct timeval now ) ;
#line 537
void adns__query_fail(adns_query qu , adns_status stat ) ;
#line 541
void adns__procdgram(adns_state ads___7 , byte const   *dgram , int dglen , int serv ,
                     int viatcp , struct timeval now ) ;
#line 690
void adns__tcp_broken(adns_state ads___7 , char const   *what , char const   *why ) ;
#line 693
void adns__tcp_tryconnect(adns_state ads___7 , struct timeval now ) ;
#line 695
void adns__autosys(adns_state ads___7 , struct timeval now ) ;
#line 701
void adns__must_gettimeofday(adns_state ads___7 , struct timeval  const  **now_io ,
                             struct timeval *tv_buf ) ;
#line 704
int adns__pollfds(adns_state ads___7 , struct pollfd *pollfds_buf ) ;
#line 705
void adns__fdevents(adns_state ads___7 , struct pollfd  const  *pollfds , int npollfds ,
                    int maxfd , fd_set const   *readfds , fd_set const   *writefds ,
                    fd_set const   *exceptfds , struct timeval now , int *r_r ) ;
#line 710
int adns__internal_check(adns_state ads___7 , adns_query *query_io , adns_answer **answer ,
                         void **context_r ) ;
#line 715
void adns__timeouts(adns_state ads___7 , int act , struct timeval **tv_io , struct timeval *tvbuf ,
                    struct timeval now ) ;
#line 724
void adns__consistency(adns_state ads___7 , adns_query qu , consistency_checks cc ) ;
#line 742 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/internal.h"
__inline static int errno_resources(int e ) 
{ 
  int tmp ;

  {
#line 742
  if (e == 12) {
#line 742
    tmp = 1;
  } else
#line 742
  if (e == 105) {
#line 742
    tmp = 1;
  } else {
#line 742
    tmp = 0;
  }
#line 742
  return (tmp);
}
}
#line 30 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/tvarith.h"
__inline static void timevaladd(struct timeval *tv_io , long ms ) 
{ 
  struct timeval tmp ;

  {
#line 32
  if (! (ms >= 0L)) {
    {
#line 32
    __assert_fail("ms>=0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/tvarith.h",
                  32U, "timevaladd");
    }
  }
#line 33
  tmp = *tv_io;
#line 34
  tmp.tv_usec += (ms % 1000L) * 1000L;
#line 35
  tmp.tv_sec += ms / 1000L;
#line 36
  if (tmp.tv_usec >= 1000000L) {
#line 36
    (tmp.tv_sec) ++;
#line 36
    tmp.tv_usec -= 1000000L;
  }
#line 37
  *tv_io = tmp;
#line 38
  return;
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void tcp_close(adns_state ads___7 ) 
{ 
  int serv ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 48
  serv = ads___7->tcpserver;
#line 49
  Hclose(ads___7->tcpsocket);
#line 50
  ads___7->tcpsocket = -1;
#line 51
  tmp___0 = 0;
#line 51
  ads___7->tcpsend.used = tmp___0;
#line 51
  tmp = tmp___0;
#line 51
  ads___7->tcprecv_skip = tmp;
#line 51
  ads___7->tcprecv.used = tmp;
  }
#line 52
  return;
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
void adns__tcp_broken(adns_state ads___7 , char const   *what , char const   *why ) 
{ 
  int serv ;
  adns_query qu ;

  {
#line 58
  if (! ((unsigned int )ads___7->tcpstate == 1U)) {
#line 58
    if (! ((unsigned int )ads___7->tcpstate == 2U)) {
      {
#line 58
      __assert_fail("ads->tcpstate == server_connecting || ads->tcpstate == server_ok",
                    "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c",
                    58U, "adns__tcp_broken");
      }
    }
  }
#line 59
  serv = ads___7->tcpserver;
#line 60
  if (what) {
    {
#line 60
    adns__warn(ads___7, serv, (adns_query )0, "TCP connection failed: %s: %s", what,
               why);
    }
  }
#line 62
  if ((unsigned int )ads___7->tcpstate == 1U) {
#line 64
    qu = ads___7->tcpw.head;
    {
#line 64
    while (1) {
      while_continue: /* CIL Label */ ;
#line 64
      if (! qu) {
#line 64
        goto while_break;
      }
#line 65
      (qu->retries) ++;
#line 64
      qu = qu->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 68
  tcp_close(ads___7);
#line 69
  ads___7->tcpstate = (enum adns__tcpstate )3;
#line 70
  ads___7->tcpserver = (serv + 1) % ads___7->nservers;
  }
#line 71
  return;
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void tcp_connected(adns_state ads___7 , struct timeval now ) 
{ 
  adns_query qu ;
  adns_query nqu ;

  {
  {
#line 76
  adns__debug(ads___7, ads___7->tcpserver, (adns_query )0, "TCP connected");
#line 77
  ads___7->tcpstate = (enum adns__tcpstate )2;
#line 78
  qu = ads___7->tcpw.head;
  }
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (qu) {
#line 78
      if (! ((unsigned int )ads___7->tcpstate == 2U)) {
#line 78
        goto while_break;
      }
    } else {
#line 78
      goto while_break;
    }
#line 79
    nqu = qu->next;
#line 80
    if (! ((unsigned int )qu->state == 1U)) {
      {
#line 80
      __assert_fail("qu->state == query_tcpw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c",
                    80U, "tcp_connected");
      }
    }
    {
#line 81
    adns__querysend_tcp(qu, now);
#line 78
    qu = nqu;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void tcp_broken_events(adns_state ads___7 ) 
{ 
  adns_query qu ;
  adns_query nqu ;

  {
#line 88
  if (! ((unsigned int )ads___7->tcpstate == 3U)) {
    {
#line 88
    __assert_fail("ads->tcpstate == server_broken", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c",
                  88U, "tcp_broken_events");
    }
  }
#line 89
  qu = ads___7->tcpw.head;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! qu) {
#line 89
      goto while_break;
    }
#line 90
    nqu = qu->next;
#line 91
    if (! ((unsigned int )qu->state == 1U)) {
      {
#line 91
      __assert_fail("qu->state == query_tcpw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c",
                    91U, "tcp_broken_events");
      }
    }
#line 92
    if (qu->retries > ads___7->nservers) {
      {
#line 93
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 93
        if (qu->back) {
#line 93
          (qu->back)->next = qu->next;
        } else {
#line 93
          ads___7->tcpw.head = qu->next;
        }
#line 93
        if (qu->next) {
#line 93
          (qu->next)->back = qu->back;
        } else {
#line 93
          ads___7->tcpw.tail = qu->back;
        }
#line 93
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 94
      adns__query_fail(qu, (adns_status )31);
      }
    }
#line 89
    qu = nqu;
  }
  while_break: /* CIL Label */ ;
  }
#line 97
  ads___7->tcpstate = (enum adns__tcpstate )0;
#line 98
  return;
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
void adns__tcp_tryconnect(adns_state ads___7 , struct timeval now ) 
{ 
  int r ;
  int fd ;
  int tries ;
  struct sockaddr_in addr ;
  struct protoent *proto ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;

  {
#line 105
  tries = 0;
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    if (! (tries < ads___7->nservers)) {
#line 105
      goto while_break;
    }
    {
#line 109
    if ((unsigned int )ads___7->tcpstate == 3U) {
#line 109
      goto case_3;
    }
#line 109
    if ((unsigned int )ads___7->tcpstate == 2U) {
#line 109
      goto case_3;
    }
#line 109
    if ((unsigned int )ads___7->tcpstate == 1U) {
#line 109
      goto case_3;
    }
#line 111
    if ((unsigned int )ads___7->tcpstate == 0U) {
#line 111
      goto case_0;
    }
#line 113
    goto switch_default;
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 110
    return;
    case_0: /* CIL Label */ 
#line 112
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 114
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
#line 117
    if (! (! ads___7->tcpsend.used)) {
      {
#line 117
      __assert_fail("!ads->tcpsend.used", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c",
                    117U, "adns__tcp_tryconnect");
      }
    }
#line 118
    if (! (! ads___7->tcprecv.used)) {
      {
#line 118
      __assert_fail("!ads->tcprecv.used", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c",
                    118U, "adns__tcp_tryconnect");
      }
    }
#line 119
    if (! (! ads___7->tcprecv_skip)) {
      {
#line 119
      __assert_fail("!ads->tcprecv_skip", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c",
                    119U, "adns__tcp_tryconnect");
      }
    }
    {
#line 121
    proto = getprotobyname("tcp");
    }
#line 122
    if (! proto) {
      {
#line 123
      adns__diag(ads___7, -1, (adns_query )0, "unable to find protocol no. for TCP !");
      }
#line 124
      return;
    }
    {
#line 126
    fd = Hsocket(2, 1, proto->p_proto);
    }
#line 127
    if (fd < 0) {
      {
#line 128
      tmp = __errno_location();
#line 128
      tmp___0 = strerror(*tmp);
#line 128
      adns__diag(ads___7, -1, (adns_query )0, "cannot create TCP socket: %s", tmp___0);
      }
#line 129
      return;
    }
    {
#line 131
    r = adns__setnonblock(ads___7, fd);
    }
#line 132
    if (r) {
      {
#line 133
      tmp___1 = strerror(r);
#line 133
      adns__diag(ads___7, -1, (adns_query )0, "cannot make TCP socket nonblocking: %s",
                 tmp___1);
#line 135
      Hclose(fd);
      }
#line 136
      return;
    }
    {
#line 138
    memset((void *)(& addr), 0, sizeof(addr));
#line 139
    addr.sin_family = (sa_family_t )2;
#line 140
    addr.sin_port = htons((uint16_t )53);
#line 141
    addr.sin_addr = ads___7->servers[ads___7->tcpserver].addr;
#line 142
    r = Hconnect(fd, (struct sockaddr  const  *)(& addr), (int )sizeof(addr));
#line 143
    ads___7->tcpsocket = fd;
#line 144
    ads___7->tcpstate = (enum adns__tcpstate )1;
    }
#line 145
    if (r == 0) {
      {
#line 145
      tcp_connected(ads___7, now);
      }
#line 145
      return;
    }
    {
#line 146
    tmp___2 = __errno_location();
    }
#line 146
    if (*tmp___2 == 11) {
      {
#line 147
      ads___7->tcptimeout = now;
#line 148
      timevaladd(& ads___7->tcptimeout, 14000L);
      }
#line 149
      return;
    } else {
      {
#line 146
      tmp___3 = __errno_location();
      }
#line 146
      if (*tmp___3 == 115) {
        {
#line 147
        ads___7->tcptimeout = now;
#line 148
        timevaladd(& ads___7->tcptimeout, 14000L);
        }
#line 149
        return;
      }
    }
    {
#line 151
    tmp___4 = __errno_location();
#line 151
    tmp___5 = strerror(*tmp___4);
#line 151
    adns__tcp_broken(ads___7, "connect", (char const   *)tmp___5);
#line 152
    tcp_broken_events(ads___7);
#line 105
    tries ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  return;
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
void adns__must_gettimeofday(adns_state ads___7 , struct timeval  const  **now_io ,
                             struct timeval *tv_buf ) 
{ 
  struct timeval  const  *now ;
  int r ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 163
  now = *now_io;
#line 164
  if (now) {
#line 164
    return;
  }
  {
#line 165
  r = Hgettimeofday(tv_buf, (struct timezone *)0);
  }
#line 165
  if (! r) {
#line 165
    *now_io = (struct timeval  const  *)tv_buf;
#line 165
    return;
  }
  {
#line 166
  tmp = __errno_location();
#line 166
  tmp___0 = strerror(*tmp);
#line 166
  adns__diag(ads___7, -1, (adns_query )0, "gettimeofday failed: %s", tmp___0);
#line 167
  adns_globalsystemfailure(ads___7);
  }
#line 168
  return;
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void inter_immed(struct timeval **tv_io , struct timeval *tvbuf ) 
{ 
  struct timeval *rbuf ;
  __suseconds_t tmp ;

  {
#line 174
  if (! tv_io) {
#line 174
    return;
  }
#line 176
  rbuf = *tv_io;
#line 177
  if (! rbuf) {
#line 177
    rbuf = tvbuf;
#line 177
    *tv_io = rbuf;
  }
#line 179
  tmp = (__suseconds_t )0;
#line 179
  rbuf->tv_usec = tmp;
#line 179
  rbuf->tv_sec = tmp;
#line 180
  return;
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void inter_maxto(struct timeval **tv_io , struct timeval *tvbuf , struct timeval maxto ) 
{ 
  struct timeval *rbuf ;
  int tmp ;

  {
#line 186
  if (! tv_io) {
#line 186
    return;
  }
#line 187
  rbuf = *tv_io;
#line 188
  if (! rbuf) {
#line 189
    *tvbuf = maxto;
#line 189
    *tv_io = tvbuf;
  } else {
#line 191
    if (rbuf->tv_sec == maxto.tv_sec) {
#line 191
      tmp = rbuf->tv_usec > maxto.tv_usec;
    } else {
#line 191
      tmp = rbuf->tv_sec > maxto.tv_sec;
    }
#line 191
    if (tmp) {
#line 191
      *rbuf = maxto;
    }
  }
#line 195
  return;
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void inter_maxtoabs(struct timeval **tv_io , struct timeval *tvbuf , struct timeval now ,
                           struct timeval maxtime ) 
{ 
  ldiv_t dr ;

  {
#line 204
  if (! tv_io) {
#line 204
    return;
  }
  {
#line 205
  maxtime.tv_sec -= now.tv_sec + 2L;
#line 206
  maxtime.tv_usec -= now.tv_usec - 2000000L;
#line 207
  dr = ldiv(maxtime.tv_usec, 1000000L);
#line 208
  maxtime.tv_sec += dr.quot;
#line 209
  maxtime.tv_usec -= dr.quot * 1000000L;
  }
#line 210
  if (maxtime.tv_sec < 0L) {
#line 210
    maxtime.tv_usec = (__suseconds_t )0;
#line 210
    maxtime.tv_sec = maxtime.tv_usec;
  }
  {
#line 211
  inter_maxto(tv_io, tvbuf, maxtime);
  }
#line 212
  return;
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void timeouts_queue(adns_state ads___7 , int act , struct timeval **tv_io ,
                           struct timeval *tvbuf , struct timeval now , struct query_queue *queue ) 
{ 
  adns_query qu ;
  adns_query nqu ;
  int tmp ;

  {
#line 219
  qu = queue->head;
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if (! qu) {
#line 219
      goto while_break;
    }
#line 220
    nqu = qu->next;
#line 221
    if (now.tv_sec == qu->timeout.tv_sec) {
#line 221
      tmp = now.tv_usec > qu->timeout.tv_usec;
    } else {
#line 221
      tmp = now.tv_sec > qu->timeout.tv_sec;
    }
#line 221
    if (tmp) {
#line 224
      if (! act) {
        {
#line 224
        inter_immed(tv_io, tvbuf);
        }
#line 224
        return;
      }
      {
#line 225
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 225
        if (qu->back) {
#line 225
          (qu->back)->next = qu->next;
        } else {
#line 225
          queue->head = qu->next;
        }
#line 225
        if (qu->next) {
#line 225
          (qu->next)->back = qu->back;
        } else {
#line 225
          queue->tail = qu->back;
        }
#line 225
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 226
      if ((unsigned int )qu->state != 0U) {
        {
#line 227
        adns__query_fail(qu, (adns_status )30);
        }
      } else {
        {
#line 229
        adns__query_send(qu, now);
        }
      }
#line 231
      nqu = queue->head;
    } else {
      {
#line 222
      inter_maxtoabs(tv_io, tvbuf, now, qu->timeout);
      }
    }
#line 219
    qu = nqu;
  }
  while_break: /* CIL Label */ ;
  }
#line 234
  return;
}
}
#line 236 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void tcp_events(adns_state ads___7 , int act , struct timeval **tv_io , struct timeval *tvbuf ,
                       struct timeval now ) 
{ 
  int tmp ;

  {
  {
#line 239
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 241
    if ((unsigned int )ads___7->tcpstate == 3U) {
#line 241
      goto case_3;
    }
#line 244
    if ((unsigned int )ads___7->tcpstate == 0U) {
#line 244
      goto case_0;
    }
#line 249
    if ((unsigned int )ads___7->tcpstate == 2U) {
#line 249
      goto case_2;
    }
#line 256
    if ((unsigned int )ads___7->tcpstate == 1U) {
#line 256
      goto case_1;
    }
#line 275
    goto switch_default___0;
    case_3: /* CIL Label */ 
#line 242
    if (! act) {
      {
#line 242
      inter_immed(tv_io, tvbuf);
      }
#line 242
      return;
    }
    {
#line 243
    tcp_broken_events(ads___7);
    }
    case_0: /* CIL Label */ 
#line 245
    if (! ads___7->tcpw.head) {
#line 245
      return;
    }
#line 246
    if (! act) {
      {
#line 246
      inter_immed(tv_io, tvbuf);
      }
#line 246
      return;
    }
    {
#line 247
    adns__tcp_tryconnect(ads___7, now);
    }
#line 248
    goto switch_break;
    case_2: /* CIL Label */ 
#line 250
    if (ads___7->tcpw.head) {
#line 250
      return;
    }
#line 251
    if (! ads___7->tcptimeout.tv_sec) {
#line 252
      if (! (! ads___7->tcptimeout.tv_usec)) {
        {
#line 252
        __assert_fail("!ads->tcptimeout.tv_usec", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c",
                      252U, "tcp_events");
        }
      }
      {
#line 253
      ads___7->tcptimeout = now;
#line 254
      timevaladd(& ads___7->tcptimeout, 30000L);
      }
    }
    case_1: /* CIL Label */ 
#line 257
    if (! act) {
      {
#line 258
      inter_maxtoabs(tv_io, tvbuf, now, ads___7->tcptimeout);
      }
#line 259
      return;
    } else {
#line 257
      if (now.tv_sec == ads___7->tcptimeout.tv_sec) {
#line 257
        tmp = now.tv_usec > ads___7->tcptimeout.tv_usec;
      } else {
#line 257
        tmp = now.tv_sec > ads___7->tcptimeout.tv_sec;
      }
#line 257
      if (! tmp) {
        {
#line 258
        inter_maxtoabs(tv_io, tvbuf, now, ads___7->tcptimeout);
        }
#line 259
        return;
      }
    }
    {
#line 263
    if ((unsigned int )ads___7->tcpstate == 1U) {
#line 263
      goto case_1___0;
    }
#line 266
    if ((unsigned int )ads___7->tcpstate == 2U) {
#line 266
      goto case_2___0;
    }
#line 270
    goto switch_default;
    case_1___0: /* CIL Label */ 
    {
#line 264
    adns__tcp_broken(ads___7, "unable to make connection", "timed out");
    }
#line 265
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 267
    tcp_close(ads___7);
#line 268
    ads___7->tcpstate = (enum adns__tcpstate )0;
    }
#line 269
    return;
    switch_default: /* CIL Label */ 
    {
#line 271
    abort();
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 274
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
#line 276
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 279
  return;
}
}
#line 282 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
void adns__timeouts(adns_state ads___7 , int act , struct timeval **tv_io , struct timeval *tvbuf ,
                    struct timeval now ) 
{ 


  {
  {
#line 285
  timeouts_queue(ads___7, act, tv_io, tvbuf, now, & ads___7->udpw);
#line 286
  timeouts_queue(ads___7, act, tv_io, tvbuf, now, & ads___7->tcpw);
#line 287
  tcp_events(ads___7, act, tv_io, tvbuf, now);
  }
#line 288
  return;
}
}
#line 290 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
void adns_firsttimeout(adns_state ads___7 , struct timeval **tv_io , struct timeval *tvbuf ,
                       struct timeval now ) 
{ 


  {
  {
#line 293
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
#line 294
  adns__timeouts(ads___7, 0, tv_io, tvbuf, now);
#line 295
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
  }
#line 296
  return;
}
}
#line 298 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
void adns_processtimeouts(adns_state ads___7 , struct timeval  const  *now ) 
{ 
  struct timeval tv_buf ;

  {
  {
#line 301
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
#line 302
  adns__must_gettimeofday(ads___7, & now, & tv_buf);
  }
#line 303
  if (now) {
    {
#line 303
    adns__timeouts(ads___7, 1, (struct timeval **)0, (struct timeval *)0, (struct timeval )*now);
    }
  }
  {
#line 304
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
  }
#line 305
  return;
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
int adns__pollfds(adns_state ads___7 , struct pollfd *pollfds_buf ) 
{ 


  {
#line 316
  (pollfds_buf + 0)->fd = ads___7->udpsocket;
#line 317
  (pollfds_buf + 0)->events = (short)1;
#line 318
  (pollfds_buf + 0)->revents = (short)0;
  {
#line 322
  if ((unsigned int )ads___7->tcpstate == 3U) {
#line 322
    goto case_3;
  }
#line 322
  if ((unsigned int )ads___7->tcpstate == 0U) {
#line 322
    goto case_3;
  }
#line 324
  if ((unsigned int )ads___7->tcpstate == 1U) {
#line 324
    goto case_1;
  }
#line 327
  if ((unsigned int )ads___7->tcpstate == 2U) {
#line 327
    goto case_2;
  }
#line 331
  goto switch_default;
  case_3: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 323
  return (1);
  case_1: /* CIL Label */ 
#line 325
  (pollfds_buf + 1)->events = (short)4;
#line 326
  goto switch_break;
  case_2: /* CIL Label */ 
#line 328
  if (ads___7->tcpsend.used) {
#line 328
    (pollfds_buf + 1)->events = (short)7;
  } else {
#line 328
    (pollfds_buf + 1)->events = (short)3;
  }
#line 330
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 332
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 334
  (pollfds_buf + 1)->fd = ads___7->tcpsocket;
#line 335
  return (2);
}
}
#line 338 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
int adns_processreadable(adns_state ads___7 , int fd , struct timeval  const  *now ) 
{ 
  int want ;
  int dgramlen ;
  int r ;
  int udpaddrlen ;
  int serv ;
  int old_skip ;
  byte udpbuf[512] ;
  struct sockaddr_in udpaddr ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  int *tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  uint16_t tmp___17 ;
  uint16_t tmp___18 ;
  char *tmp___19 ;

  {
  {
#line 343
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
  }
  {
#line 348
  if ((unsigned int )ads___7->tcpstate == 1U) {
#line 348
    goto case_1;
  }
#line 348
  if ((unsigned int )ads___7->tcpstate == 3U) {
#line 348
    goto case_1;
  }
#line 348
  if ((unsigned int )ads___7->tcpstate == 0U) {
#line 348
    goto case_1;
  }
#line 350
  if ((unsigned int )ads___7->tcpstate == 2U) {
#line 350
    goto case_2;
  }
#line 391
  goto switch_default;
  case_1: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 349
  goto switch_break;
  case_2: /* CIL Label */ 
#line 351
  if (fd != ads___7->tcpsocket) {
#line 351
    goto switch_break;
  }
#line 352
  if (! (! ads___7->tcprecv_skip)) {
    {
#line 352
    __assert_fail("!ads->tcprecv_skip", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c",
                  352U, "adns_processreadable");
    }
  }
  {
#line 353
  while (1) {
    while_continue: /* CIL Label */ ;
#line 354
    if (ads___7->tcprecv.used >= ads___7->tcprecv_skip + 2) {
#line 355
      dgramlen = ((int )*(ads___7->tcprecv.buf + ads___7->tcprecv_skip) << 8) | (int )*(ads___7->tcprecv.buf + (ads___7->tcprecv_skip + 1));
#line 357
      if (ads___7->tcprecv.used >= (ads___7->tcprecv_skip + 2) + dgramlen) {
        {
#line 358
        old_skip = ads___7->tcprecv_skip;
#line 359
        ads___7->tcprecv_skip += 2 + dgramlen;
#line 360
        adns__procdgram(ads___7, (byte const   *)((ads___7->tcprecv.buf + old_skip) + 2),
                        dgramlen, ads___7->tcpserver, 1, (struct timeval )*now);
        }
#line 362
        goto __Cont;
      } else {
#line 364
        want = 2 + dgramlen;
      }
    } else {
#line 367
      want = 2;
    }
    {
#line 369
    ads___7->tcprecv.used -= ads___7->tcprecv_skip;
#line 370
    memmove((void *)ads___7->tcprecv.buf, (void const   *)(ads___7->tcprecv.buf + ads___7->tcprecv_skip),
            (size_t )ads___7->tcprecv.used);
#line 372
    ads___7->tcprecv_skip = 0;
#line 373
    tmp = adns__vbuf_ensure(& ads___7->tcprecv, want);
    }
#line 373
    if (! tmp) {
#line 373
      r = 12;
#line 373
      goto xit;
    }
#line 374
    if (! (ads___7->tcprecv.used <= ads___7->tcprecv.avail)) {
      {
#line 374
      __assert_fail("ads->tcprecv.used <= ads->tcprecv.avail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c",
                    374U, "adns_processreadable");
      }
    }
#line 375
    if (ads___7->tcprecv.used == ads___7->tcprecv.avail) {
#line 375
      goto __Cont;
    }
    {
#line 376
    r = Hread(ads___7->tcpsocket, (void *)(ads___7->tcprecv.buf + ads___7->tcprecv.used),
              (size_t )(ads___7->tcprecv.avail - ads___7->tcprecv.used));
    }
#line 379
    if (r > 0) {
#line 380
      ads___7->tcprecv.used += r;
    } else {
#line 382
      if (r) {
        {
#line 383
        tmp___0 = __errno_location();
        }
#line 383
        if (*tmp___0 == 11) {
#line 383
          r = 0;
#line 383
          goto xit;
        } else {
          {
#line 383
          tmp___1 = __errno_location();
          }
#line 383
          if (*tmp___1 == 11) {
#line 383
            r = 0;
#line 383
            goto xit;
          }
        }
        {
#line 384
        tmp___2 = __errno_location();
        }
#line 384
        if (*tmp___2 == 4) {
#line 384
          goto __Cont;
        }
        {
#line 385
        tmp___4 = __errno_location();
#line 385
        tmp___5 = errno_resources(*tmp___4);
        }
#line 385
        if (tmp___5) {
          {
#line 385
          tmp___3 = __errno_location();
#line 385
          r = *tmp___3;
          }
#line 385
          goto xit;
        }
      }
#line 387
      if (r) {
        {
#line 387
        tmp___6 = __errno_location();
#line 387
        tmp___7 = strerror(*tmp___6);
#line 387
        tmp___8 = (char const   *)tmp___7;
        }
      } else {
#line 387
        tmp___8 = "closed";
      }
      {
#line 387
      adns__tcp_broken(ads___7, "read", tmp___8);
      }
    }
    __Cont: /* CIL Label */ 
#line 353
    if (! ((unsigned int )ads___7->tcpstate == 2U)) {
#line 353
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 390
  r = 0;
#line 390
  goto xit;
  switch_default: /* CIL Label */ 
  {
#line 392
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 394
  if (fd == ads___7->udpsocket) {
    {
#line 395
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 396
      udpaddrlen = (int )sizeof(udpaddr);
#line 397
      r = Hrecvfrom(ads___7->udpsocket, (void *)(udpbuf), (int )sizeof(udpbuf), 0U,
                    (struct sockaddr *)(& udpaddr), & udpaddrlen);
      }
#line 399
      if (r < 0) {
        {
#line 400
        tmp___9 = __errno_location();
        }
#line 400
        if (*tmp___9 == 11) {
#line 400
          r = 0;
#line 400
          goto xit;
        } else {
          {
#line 400
          tmp___10 = __errno_location();
          }
#line 400
          if (*tmp___10 == 11) {
#line 400
            r = 0;
#line 400
            goto xit;
          }
        }
        {
#line 401
        tmp___11 = __errno_location();
        }
#line 401
        if (*tmp___11 == 4) {
#line 401
          goto __Cont___0;
        }
        {
#line 402
        tmp___13 = __errno_location();
#line 402
        tmp___14 = errno_resources(*tmp___13);
        }
#line 402
        if (tmp___14) {
          {
#line 402
          tmp___12 = __errno_location();
#line 402
          r = *tmp___12;
          }
#line 402
          goto xit;
        }
        {
#line 403
        tmp___15 = __errno_location();
#line 403
        tmp___16 = strerror(*tmp___15);
#line 403
        adns__warn(ads___7, -1, (adns_query )0, "datagram receive error: %s", tmp___16);
#line 404
        r = 0;
        }
#line 404
        goto xit;
      }
#line 406
      if ((unsigned long )udpaddrlen != sizeof(udpaddr)) {
        {
#line 407
        adns__diag(ads___7, -1, (adns_query )0, "datagram received with wrong address length %d (expected %lu)",
                   udpaddrlen, sizeof(udpaddr));
        }
#line 410
        goto __Cont___0;
      }
#line 412
      if ((int )udpaddr.sin_family != 2) {
        {
#line 413
        adns__diag(ads___7, -1, (adns_query )0, "datagram received with wrong protocol family %u (expected %u)",
                   (int )udpaddr.sin_family, 2);
        }
#line 415
        goto __Cont___0;
      }
      {
#line 417
      tmp___18 = ntohs(udpaddr.sin_port);
      }
#line 417
      if ((int )tmp___18 != 53) {
        {
#line 418
        tmp___17 = ntohs(udpaddr.sin_port);
#line 418
        adns__diag(ads___7, -1, (adns_query )0, "datagram received from wrong port %u (expected %u)",
                   (int )tmp___17, 53);
        }
#line 420
        goto __Cont___0;
      }
#line 422
      serv = 0;
      {
#line 422
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 422
        if (serv < ads___7->nservers) {
#line 422
          if (! (ads___7->servers[serv].addr.s_addr != udpaddr.sin_addr.s_addr)) {
#line 422
            goto while_break___1;
          }
        } else {
#line 422
          goto while_break___1;
        }
#line 422
        serv ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 426
      if (serv >= ads___7->nservers) {
        {
#line 427
        tmp___19 = inet_ntoa(udpaddr.sin_addr);
#line 427
        adns__warn(ads___7, -1, (adns_query )0, "datagram received from unknown nameserver %s",
                   tmp___19);
        }
#line 429
        goto __Cont___0;
      }
      {
#line 431
      adns__procdgram(ads___7, (byte const   *)(udpbuf), r, serv, 0, (struct timeval )*now);
      }
      __Cont___0: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 434
  r = 0;
  xit: 
  {
#line 436
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
  }
#line 437
  return (r);
}
}
#line 440 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
int adns_processwriteable(adns_state ads___7 , int fd , struct timeval  const  *now ) 
{ 
  int r ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;

  {
  {
#line 443
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
  }
  {
#line 447
  if ((unsigned int )ads___7->tcpstate == 3U) {
#line 447
    goto case_3;
  }
#line 447
  if ((unsigned int )ads___7->tcpstate == 0U) {
#line 447
    goto case_3;
  }
#line 449
  if ((unsigned int )ads___7->tcpstate == 1U) {
#line 449
    goto case_1;
  }
#line 469
  if ((unsigned int )ads___7->tcpstate == 2U) {
#line 469
    goto case_2;
  }
#line 488
  goto switch_default;
  case_3: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 448
  goto switch_break;
  case_1: /* CIL Label */ 
#line 450
  if (fd != ads___7->tcpsocket) {
#line 450
    goto switch_break;
  }
#line 451
  if (! (ads___7->tcprecv.used == 0)) {
    {
#line 451
    __assert_fail("ads->tcprecv.used==0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c",
                  451U, "adns_processwriteable");
    }
  }
#line 452
  if (! (ads___7->tcprecv_skip == 0)) {
    {
#line 452
    __assert_fail("ads->tcprecv_skip==0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c",
                  452U, "adns_processwriteable");
    }
  }
  {
#line 453
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 454
    tmp = adns__vbuf_ensure(& ads___7->tcprecv, 1);
    }
#line 454
    if (! tmp) {
#line 454
      r = 12;
#line 454
      goto xit;
    }
    {
#line 455
    r = Hread(ads___7->tcpsocket, (void *)(& ads___7->tcprecv.buf), (size_t )1);
    }
#line 456
    if (r == 0) {
      {
#line 457
      tcp_connected(ads___7, (struct timeval )*now);
#line 458
      r = 0;
      }
#line 458
      goto xit;
    } else
#line 456
    if (r < 0) {
      {
#line 456
      tmp___0 = __errno_location();
      }
#line 456
      if (*tmp___0 == 11) {
        {
#line 457
        tcp_connected(ads___7, (struct timeval )*now);
#line 458
        r = 0;
        }
#line 458
        goto xit;
      } else {
        {
#line 456
        tmp___1 = __errno_location();
        }
#line 456
        if (*tmp___1 == 11) {
          {
#line 457
          tcp_connected(ads___7, (struct timeval )*now);
#line 458
          r = 0;
          }
#line 458
          goto xit;
        }
      }
    }
#line 460
    if (r > 0) {
      {
#line 461
      adns__tcp_broken(ads___7, "connect/read", "sent data before first request");
#line 462
      r = 0;
      }
#line 462
      goto xit;
    }
    {
#line 464
    tmp___2 = __errno_location();
    }
#line 464
    if (*tmp___2 == 4) {
#line 464
      goto __Cont;
    }
    {
#line 465
    tmp___4 = __errno_location();
#line 465
    tmp___5 = errno_resources(*tmp___4);
    }
#line 465
    if (tmp___5) {
      {
#line 465
      tmp___3 = __errno_location();
#line 465
      r = *tmp___3;
      }
#line 465
      goto xit;
    }
    {
#line 466
    tmp___6 = __errno_location();
#line 466
    tmp___7 = strerror(*tmp___6);
#line 466
    adns__tcp_broken(ads___7, "connect/read", (char const   *)tmp___7);
#line 467
    r = 0;
    }
#line 467
    goto xit;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  case_2: /* CIL Label */ 
#line 470
  if (fd != ads___7->tcpsocket) {
#line 470
    goto switch_break;
  }
  {
#line 471
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 471
    if (! ads___7->tcpsend.used) {
#line 471
      goto while_break___0;
    }
    {
#line 472
    adns__sigpipe_protect(ads___7);
#line 473
    r = Hwrite(ads___7->tcpsocket, (void const   *)ads___7->tcpsend.buf, (size_t )ads___7->tcpsend.used);
#line 474
    adns__sigpipe_unprotect(ads___7);
    }
#line 475
    if (r < 0) {
      {
#line 476
      tmp___8 = __errno_location();
      }
#line 476
      if (*tmp___8 == 4) {
#line 476
        goto while_continue___0;
      }
      {
#line 477
      tmp___9 = __errno_location();
      }
#line 477
      if (*tmp___9 == 11) {
#line 477
        r = 0;
#line 477
        goto xit;
      } else {
        {
#line 477
        tmp___10 = __errno_location();
        }
#line 477
        if (*tmp___10 == 11) {
#line 477
          r = 0;
#line 477
          goto xit;
        }
      }
      {
#line 478
      tmp___12 = __errno_location();
#line 478
      tmp___13 = errno_resources(*tmp___12);
      }
#line 478
      if (tmp___13) {
        {
#line 478
        tmp___11 = __errno_location();
#line 478
        r = *tmp___11;
        }
#line 478
        goto xit;
      }
      {
#line 479
      tmp___14 = __errno_location();
#line 479
      tmp___15 = strerror(*tmp___14);
#line 479
      adns__tcp_broken(ads___7, "write", (char const   *)tmp___15);
#line 480
      r = 0;
      }
#line 480
      goto xit;
    } else
#line 481
    if (r > 0) {
      {
#line 482
      ads___7->tcpsend.used -= r;
#line 483
      memmove((void *)ads___7->tcpsend.buf, (void const   *)(ads___7->tcpsend.buf + r),
              (size_t )ads___7->tcpsend.used);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 486
  r = 0;
#line 487
  goto xit;
  switch_default: /* CIL Label */ 
  {
#line 489
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 491
  r = 0;
  xit: 
  {
#line 493
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
  }
#line 494
  return (r);
}
}
#line 497 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
int adns_processexceptional(adns_state ads___7 , int fd , struct timeval  const  *now ) 
{ 


  {
  {
#line 499
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
  }
  {
#line 502
  if ((unsigned int )ads___7->tcpstate == 3U) {
#line 502
    goto case_3;
  }
#line 502
  if ((unsigned int )ads___7->tcpstate == 0U) {
#line 502
    goto case_3;
  }
#line 505
  if ((unsigned int )ads___7->tcpstate == 2U) {
#line 505
    goto case_2;
  }
#line 505
  if ((unsigned int )ads___7->tcpstate == 1U) {
#line 505
    goto case_2;
  }
#line 509
  goto switch_default;
  case_3: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 503
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 506
  if (fd != ads___7->tcpsocket) {
#line 506
    goto switch_break;
  }
  {
#line 507
  adns__tcp_broken(ads___7, "poll/select", "exceptional condition detected");
  }
#line 508
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 510
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 512
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
  }
#line 513
  return (0);
}
}
#line 516 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void fd_event(adns_state ads___7 , int fd , int revent , int pollflag , int maxfd ,
                     fd_set const   *fds , int (*func)(adns_state  , int fd , struct timeval  const  *now ) ,
                     struct timeval now , int *r_r ) 
{ 
  int r ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 524
  if (! (revent & pollflag)) {
#line 524
    return;
  }
#line 525
  if (fds) {
#line 525
    if (fd < maxfd) {
#line 525
      if (! ((fds->__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
#line 525
        return;
      }
    } else {
#line 525
      return;
    }
  }
  {
#line 526
  r = (*func)(ads___7, fd, (struct timeval  const  *)(& now));
  }
#line 527
  if (r) {
#line 528
    if (r_r) {
#line 529
      *r_r = r;
    } else {
      {
#line 531
      tmp = __errno_location();
#line 531
      tmp___0 = strerror(*tmp);
#line 531
      adns__diag(ads___7, -1, (adns_query )0, "process fd failed after select: %s",
                 tmp___0);
#line 533
      adns_globalsystemfailure(ads___7);
      }
    }
  }
#line 536
  return;
}
}
#line 538 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
void adns__fdevents(adns_state ads___7 , struct pollfd  const  *pollfds , int npollfds ,
                    int maxfd , fd_set const   *readfds , fd_set const   *writefds ,
                    fd_set const   *exceptfds , struct timeval now , int *r_r ) 
{ 
  int i ;
  int fd ;
  int revents ;

  {
#line 545
  i = 0;
  {
#line 545
  while (1) {
    while_continue: /* CIL Label */ ;
#line 545
    if (! (i < npollfds)) {
#line 545
      goto while_break;
    }
#line 546
    fd = (int )(pollfds + i)->fd;
#line 547
    if (fd >= maxfd) {
#line 547
      maxfd = fd + 1;
    }
    {
#line 548
    revents = (int )(pollfds + i)->revents;
#line 551
    fd_event(ads___7, fd, revents, 1, maxfd, readfds, & adns_processreadable, now,
             r_r);
#line 552
    fd_event(ads___7, fd, revents, 4, maxfd, writefds, & adns_processwriteable, now,
             r_r);
#line 553
    fd_event(ads___7, fd, revents, 2, maxfd, exceptfds, & adns_processexceptional,
             now, r_r);
#line 545
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 556
  return;
}
}
#line 560 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
void adns_beforeselect(adns_state ads___7 , int *maxfd_io , fd_set *readfds_io , fd_set *writefds_io ,
                       fd_set *exceptfds_io , struct timeval **tv_mod , struct timeval *tv_tobuf ,
                       struct timeval  const  *now ) 
{ 
  struct timeval tv_nowbuf ;
  struct pollfd pollfds[2] ;
  int i ;
  int fd ;
  int maxfd ;
  int npollfds ;

  {
  {
#line 568
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
  }
#line 570
  if (tv_mod) {
#line 570
    if (! *tv_mod) {
#line 570
      goto _L;
    } else
#line 570
    if ((*tv_mod)->tv_sec) {
#line 570
      goto _L;
    } else
#line 570
    if ((*tv_mod)->tv_usec) {
      _L: /* CIL Label */ 
      {
#line 572
      adns__must_gettimeofday(ads___7, & now, & tv_nowbuf);
      }
#line 573
      if (! now) {
        {
#line 573
        inter_immed(tv_mod, tv_tobuf);
        }
#line 573
        goto xit;
      }
      {
#line 574
      adns__timeouts(ads___7, 0, tv_mod, tv_tobuf, (struct timeval )*now);
      }
    }
  }
  {
#line 577
  npollfds = adns__pollfds(ads___7, (struct pollfd *)(pollfds));
#line 578
  maxfd = *maxfd_io;
#line 579
  i = 0;
  }
  {
#line 579
  while (1) {
    while_continue: /* CIL Label */ ;
#line 579
    if (! (i < npollfds)) {
#line 579
      goto while_break;
    }
#line 580
    fd = pollfds[i].fd;
#line 581
    if (fd >= maxfd) {
#line 581
      maxfd = fd + 1;
    }
#line 582
    if ((int )pollfds[i].events & 1) {
#line 582
      readfds_io->__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
    }
#line 583
    if ((int )pollfds[i].events & 4) {
#line 583
      writefds_io->__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
    }
#line 584
    if ((int )pollfds[i].events & 2) {
#line 584
      exceptfds_io->__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
    }
#line 579
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 586
  *maxfd_io = maxfd;
  xit: 
  {
#line 589
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
  }
#line 590
  return;
}
}
#line 592 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
void adns_afterselect(adns_state ads___7 , int maxfd , fd_set const   *readfds , fd_set const   *writefds ,
                      fd_set const   *exceptfds , struct timeval  const  *now ) 
{ 
  struct timeval tv_buf ;
  struct pollfd pollfds[2] ;
  int npollfds ;
  int i ;

  {
  {
#line 599
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
#line 600
  adns__must_gettimeofday(ads___7, & now, & tv_buf);
  }
#line 601
  if (! now) {
#line 601
    goto xit;
  }
  {
#line 602
  adns_processtimeouts(ads___7, now);
#line 604
  npollfds = adns__pollfds(ads___7, (struct pollfd *)(pollfds));
#line 605
  i = 0;
  }
  {
#line 605
  while (1) {
    while_continue: /* CIL Label */ ;
#line 605
    if (! (i < npollfds)) {
#line 605
      goto while_break;
    }
#line 605
    pollfds[i].revents = (short)7;
#line 605
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 606
  adns__fdevents(ads___7, (struct pollfd  const  *)(pollfds), npollfds, maxfd, readfds,
                 writefds, exceptfds, (struct timeval )*now, (int *)0);
  }
  xit: 
  {
#line 611
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
  }
#line 612
  return;
}
}
#line 616 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
void adns_globalsystemfailure(adns_state ads___7 ) 
{ 


  {
  {
#line 617
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
  }
  {
#line 619
  while (1) {
    while_continue: /* CIL Label */ ;
#line 619
    if (! ads___7->udpw.head) {
#line 619
      goto while_break;
    }
    {
#line 619
    adns__query_fail(ads___7->udpw.head, (adns_status )3);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 620
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 620
    if (! ads___7->tcpw.head) {
#line 620
      goto while_break___0;
    }
    {
#line 620
    adns__query_fail(ads___7->tcpw.head, (adns_status )3);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 624
  if ((unsigned int )ads___7->tcpstate == 2U) {
#line 624
    goto case_2;
  }
#line 624
  if ((unsigned int )ads___7->tcpstate == 1U) {
#line 624
    goto case_2;
  }
#line 628
  if ((unsigned int )ads___7->tcpstate == 3U) {
#line 628
    goto case_3;
  }
#line 628
  if ((unsigned int )ads___7->tcpstate == 0U) {
#line 628
    goto case_3;
  }
#line 630
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 625
  adns__tcp_broken(ads___7, (char const   *)0, (char const   *)0);
  }
#line 626
  goto switch_break;
  case_3: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 629
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 631
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 633
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
  }
#line 634
  return;
}
}
#line 636 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
int adns_processany(adns_state ads___7 ) 
{ 
  int r ;
  int i ;
  struct timeval now ;
  struct pollfd pollfds[2] ;
  int npollfds ;

  {
  {
#line 642
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
#line 644
  r = Hgettimeofday(& now, (struct timezone *)0);
  }
#line 645
  if (! r) {
    {
#line 645
    adns_processtimeouts(ads___7, (struct timeval  const  *)(& now));
    }
  }
  {
#line 651
  npollfds = adns__pollfds(ads___7, (struct pollfd *)(pollfds));
#line 652
  i = 0;
  }
  {
#line 652
  while (1) {
    while_continue: /* CIL Label */ ;
#line 652
    if (! (i < npollfds)) {
#line 652
      goto while_break;
    }
#line 652
    pollfds[i].revents = (short )((int )pollfds[i].events & -3);
#line 652
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 653
  adns__fdevents(ads___7, (struct pollfd  const  *)(pollfds), npollfds, 0, (fd_set const   *)0,
                 (fd_set const   *)0, (fd_set const   *)0, now, & r);
#line 658
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
  }
#line 659
  return (0);
}
}
#line 662 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
void adns__autosys(adns_state ads___7 , struct timeval now ) 
{ 


  {
#line 663
  if ((unsigned int )ads___7->iflags & 16U) {
#line 663
    return;
  }
  {
#line 664
  adns_processany(ads___7);
  }
#line 665
  return;
}
}
#line 667 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
int adns__internal_check(adns_state ads___7 , adns_query *query_io , adns_answer **answer ,
                         void **context_r ) 
{ 
  adns_query qu ;

  {
#line 673
  qu = *query_io;
#line 674
  if (! qu) {
#line 675
    if (ads___7->output.head) {
#line 676
      qu = ads___7->output.head;
    } else
#line 677
    if (ads___7->udpw.head) {
#line 678
      return (11);
    } else
#line 677
    if (ads___7->tcpw.head) {
#line 678
      return (11);
    } else {
#line 680
      return (3);
    }
  } else
#line 683
  if (qu->id >= 0) {
#line 683
    return (11);
  }
  {
#line 685
  while (1) {
    while_continue: /* CIL Label */ ;
#line 685
    if (qu->back) {
#line 685
      (qu->back)->next = qu->next;
    } else {
#line 685
      ads___7->output.head = qu->next;
    }
#line 685
    if (qu->next) {
#line 685
      (qu->next)->back = qu->back;
    } else {
#line 685
      ads___7->output.tail = qu->back;
    }
#line 685
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 686
  *answer = qu->answer;
#line 687
  if (context_r) {
#line 687
    *context_r = qu->ctx.ext;
  }
  {
#line 688
  *query_io = qu;
#line 689
  Hfree((void *)qu);
  }
#line 690
  return (0);
}
}
#line 693 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
int adns_wait(adns_state ads___7 , adns_query *query_io , adns_answer **answer_r ,
              void **context_r ) 
{ 
  int r ;
  int maxfd ;
  int rsel ;
  fd_set readfds ;
  fd_set writefds ;
  fd_set exceptfds ;
  struct timeval tvbuf ;
  struct timeval *tvp ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int __d0___1 ;
  int __d1___1 ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 701
  adns__consistency(ads___7, *query_io, (consistency_checks )1);
  }
  {
#line 702
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 703
    r = adns__internal_check(ads___7, query_io, answer_r, context_r);
    }
#line 704
    if (r != 11) {
#line 704
      goto while_break;
    }
#line 705
    maxfd = 0;
#line 705
    tvp = (struct timeval *)0;
    {
#line 706
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 706
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& readfds.__fds_bits[0]): "memory");
#line 706
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 706
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 706
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& writefds.__fds_bits[0]): "memory");
#line 706
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 706
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 706
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0___1), "=D" (__d1___1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& exceptfds.__fds_bits[0]): "memory");
#line 706
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 707
    adns_beforeselect(ads___7, & maxfd, & readfds, & writefds, & exceptfds, & tvp,
                      & tvbuf, (struct timeval  const  *)0);
    }
#line 708
    if (! tvp) {
      {
#line 708
      __assert_fail("tvp", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c",
                    708U, "adns_wait");
      }
    }
    {
#line 709
    rsel = Hselect(maxfd, & readfds, & writefds, & exceptfds, tvp);
    }
#line 710
    if (rsel == -1) {
      {
#line 711
      tmp___1 = __errno_location();
      }
#line 711
      if (*tmp___1 == 4) {
#line 712
        if ((unsigned int )ads___7->iflags & 32U) {
#line 712
          r = 4;
#line 712
          goto while_break;
        }
      } else {
        {
#line 714
        tmp = __errno_location();
#line 714
        tmp___0 = strerror(*tmp);
#line 714
        adns__diag(ads___7, -1, (adns_query )0, "select failed in wait: %s", tmp___0);
#line 715
        adns_globalsystemfailure(ads___7);
        }
      }
    } else {
#line 718
      if (! (rsel >= 0)) {
        {
#line 718
        __assert_fail("rsel >= 0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c",
                      718U, "adns_wait");
        }
      }
      {
#line 719
      adns_afterselect(ads___7, maxfd, (fd_set const   *)(& readfds), (fd_set const   *)(& writefds),
                       (fd_set const   *)(& exceptfds), (struct timeval  const  *)0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 722
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
  }
#line 723
  return (r);
}
}
#line 726 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
int adns_check(adns_state ads___7 , adns_query *query_io , adns_answer **answer_r ,
               void **context_r ) 
{ 
  struct timeval now ;
  int r ;

  {
  {
#line 733
  adns__consistency(ads___7, *query_io, (consistency_checks )1);
#line 734
  r = Hgettimeofday(& now, (struct timezone *)0);
  }
#line 735
  if (! r) {
    {
#line 735
    adns__autosys(ads___7, now);
    }
  }
  {
#line 737
  r = adns__internal_check(ads___7, query_io, answer_r, context_r);
#line 738
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
  }
#line 739
  return (r);
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 73 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inet_aton)(char const   *__cp ,
                                                                                struct in_addr *__inp ) ;
#line 416 "./../src/adns.h"
int adns_init(adns_state *ads_r , adns_initflags flags , FILE *diagfile ) ;
#line 419
int adns_init_strcfg(adns_state *ads_r , adns_initflags flags , FILE *diagfile , char const   *configtext ) ;
#line 546
int adns_submit(adns_state ads___7 , char const   *owner , adns_rrtype type , adns_queryflags flags ,
                void *context , adns_query *query_r ) ;
#line 571
void adns_cancel(adns_query qu ) ;
#line 585
int adns_submit_reverse(adns_state ads___7 , struct sockaddr  const  *addr , adns_rrtype type ,
                        adns_queryflags flags , void *context , adns_query *query_r ) ;
#line 595
int adns_submit_reverse_any(adns_state ads___7 , struct sockaddr  const  *addr , char const   *zone ,
                            adns_rrtype type , adns_queryflags flags , void *context ,
                            adns_query *query_r ) ;
#line 79 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnshost.h"
int ov_env ;
#line 79
int ov_pipe ;
#line 79
int ov_asynch ;
#line 80
int ov_verbose ;
#line 81
adns_rrtype ov_type ;
#line 82
int ov_search ;
#line 82
int ov_qc_query ;
#line 82
int ov_qc_anshost ;
#line 82
int ov_qc_cname ;
#line 83
int ov_tcp ;
#line 83
int ov_cname ;
#line 83
int ov_format ;
#line 84
char *ov_id ;
#line 85
struct perqueryflags_remember ov_pqfr ;
#line 87
void of_ptr(struct optioninfo  const  *oi , char const   *arg , char const   *arg2 ) ;
#line 87
void of_reverse(struct optioninfo  const  *oi , char const   *arg , char const   *arg2 ) ;
#line 88
void of_asynch_id(struct optioninfo  const  *oi , char const   *arg , char const   *arg2 ) ;
#line 88
void of_cancel_id(struct optioninfo  const  *oi , char const   *arg , char const   *arg2 ) ;
#line 103 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnshost.h"
adns_state ads  ;
#line 104 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnshost.h"
struct outstanding_list outstanding  ;
#line 106
void ensure_adns_init(void) ;
#line 107
void query_do(char const   *domain ) ;
#line 108
void query_done(struct query_node *qun , adns_answer *answer ) ;
#line 110
void type_info(adns_rrtype type , char const   **typename_r , void const   *datap ,
               char **data_r ) ;
#line 118
 __attribute__((__noreturn__)) void sysfail(char const   *what , int errnoval ) ;
#line 119
 __attribute__((__noreturn__)) void ( /* format attribute */  usageerr)(char const   *fmt 
                                                                        , ...) ;
#line 120
 __attribute__((__noreturn__)) void outerr(void) ;
#line 122
void *xmalloc(size_t sz ) ;
#line 123
char *xstrsave(char const   *str ) ;
#line 125
int rcode ;
#line 126
char const   *config_text ;
#line 33 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-query.c"
static unsigned long idcounter  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-query.c"
void ensure_adns_init(void) 
{ 
  adns_initflags initflags___3 ;
  int r ;
  int *tmp ;
  __sighandler_t tmp___0 ;

  {
#line 39
  if (ads) {
#line 39
    return;
  }
  {
#line 41
  tmp___0 = signal(13, (void (*)(int  ))1);
  }
#line 41
  if ((unsigned long )tmp___0 == (unsigned long )((void (*)(int  ))-1)) {
    {
#line 41
    tmp = __errno_location();
#line 41
    sysfail("ignore SIGPIPE", *tmp);
    }
  }
#line 43
  initflags___3 = (adns_initflags )(80 | ov_verbose);
#line 44
  if (! ov_env) {
#line 44
    initflags___3 = (adns_initflags )((unsigned int )initflags___3 | 1U);
  }
#line 46
  if (config_text) {
    {
#line 47
    r = adns_init_strcfg(& ads, initflags___3, stderr, config_text);
    }
  } else {
    {
#line 49
    r = adns_init(& ads, initflags___3, (FILE *)0);
    }
  }
#line 51
  if (r) {
    {
#line 51
    sysfail("adns_init", r);
    }
  }
#line 53
  if (ov_format == 0) {
#line 54
    if (ov_asynch) {
#line 54
      ov_format = 3;
    } else {
#line 54
      ov_format = 1;
    }
  }
#line 55
  return;
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-query.c"
static char buf[12]  ;
#line 57 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-query.c"
void type_info(adns_rrtype type , char const   **typename_r , void const   *datap ,
               char **data_r ) 
{ 
  adns_status st ;

  {
  {
#line 62
  st = adns_rr_info(type, typename_r, (char const   **)0, (int *)0, datap, data_r);
  }
#line 63
  if ((unsigned int )st == 1U) {
    {
#line 63
    sysfail("adns_rr_info failed", 12);
    }
  }
#line 64
  if (! (! st)) {
    {
#line 64
    __assert_fail("!st", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-query.c",
                  64U, "type_info");
    }
  }
#line 65
  if (typename_r) {
#line 65
    if (! *typename_r) {
      {
#line 66
      sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"TYPE%d",
              (int )((unsigned int )type & 65535U));
#line 67
      *typename_r = (char const   *)(buf);
      }
    }
  }
#line 69
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-query.c"
static void prep_query(struct query_node **qun_r , int *quflags_r ) 
{ 
  struct query_node *qun ;
  char idbuf[20] ;
  void *tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 75
  if (ov_pipe) {
#line 75
    if (! ads) {
      {
#line 75
      usageerr("-f/--pipe not consistent with domains on command line");
      }
    }
  }
  {
#line 76
  ensure_adns_init();
#line 78
  tmp = Hmalloc(sizeof(*qun));
#line 78
  qun = (struct query_node *)tmp;
#line 79
  qun->pqfr = ov_pqfr;
  }
#line 80
  if (ov_id) {
    {
#line 81
    qun->id = xstrsave((char const   *)ov_id);
    }
  } else {
    {
#line 83
    tmp___0 = idcounter;
#line 83
    idcounter ++;
#line 83
    sprintf((char */* __restrict  */)(idbuf), (char const   */* __restrict  */)"%lu",
            tmp___0);
#line 84
    idcounter &= 4294967295UL;
#line 85
    qun->id = xstrsave((char const   *)(idbuf));
    }
  }
#line 88
  if (ov_search) {
#line 88
    tmp___1 = 1;
  } else {
#line 88
    tmp___1 = 0;
  }
#line 88
  if (ov_tcp) {
#line 88
    tmp___2 = 2;
  } else {
#line 88
    tmp___2 = 0;
  }
#line 88
  if (ov_pqfr.show_owner) {
#line 88
    tmp___3 = 4;
  } else
#line 88
  if (ov_format == 1) {
#line 88
    tmp___3 = 4;
  } else {
#line 88
    tmp___3 = 0;
  }
#line 88
  if (ov_qc_query) {
#line 88
    tmp___4 = 16;
  } else {
#line 88
    tmp___4 = 0;
  }
#line 88
  if (ov_qc_anshost) {
#line 88
    tmp___5 = 64;
  } else {
#line 88
    tmp___5 = 0;
  }
#line 88
  if (ov_qc_cname) {
#line 88
    tmp___6 = 0;
  } else {
#line 88
    tmp___6 = 0;
  }
#line 88
  *quflags_r = (((((tmp___1 | tmp___2) | tmp___3) | tmp___4) | tmp___5) | tmp___6) | ov_cname;
#line 88
  *qun_r = qun;
#line 98
  return;
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-query.c"
void of_ptr(struct optioninfo  const  *oi , char const   *arg , char const   *arg2 ) 
{ 
  struct query_node *qun ;
  int quflags ;
  int r ;
  struct sockaddr_in sa___3 ;
  int tmp ;
  unsigned int tmp___0 ;

  {
  {
#line 105
  memset((void *)(& sa___3), 0, sizeof(sa___3));
#line 106
  sa___3.sin_family = (sa_family_t )2;
#line 107
  tmp = inet_aton(arg, & sa___3.sin_addr);
  }
#line 107
  if (! tmp) {
    {
#line 107
    usageerr("invalid IP address %s", arg);
    }
  }
  {
#line 109
  prep_query(& qun, & quflags);
#line 110
  qun->owner = xstrsave(arg);
  }
#line 111
  if ((unsigned int )ov_type == 0U) {
#line 111
    tmp___0 = 65548U;
  } else {
#line 111
    tmp___0 = (unsigned int )ov_type;
  }
  {
#line 111
  r = adns_submit_reverse(ads, (struct sockaddr  const  *)((struct sockaddr *)(& sa___3)),
                          (adns_rrtype )tmp___0, (adns_queryflags )quflags, (void *)qun,
                          & qun->qu);
  }
#line 117
  if (r) {
    {
#line 117
    sysfail("adns_submit_reverse", r);
    }
  }
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 119
    qun->next = (struct query_node *)0;
#line 119
    qun->back = outstanding.tail;
#line 119
    if (outstanding.tail) {
#line 119
      (outstanding.tail)->next = qun;
    } else {
#line 119
      outstanding.head = qun;
    }
#line 119
    outstanding.tail = qun;
#line 119
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  return;
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-query.c"
void of_reverse(struct optioninfo  const  *oi , char const   *arg , char const   *arg2 ) 
{ 
  struct query_node *qun ;
  int quflags ;
  int r ;
  struct sockaddr_in sa___3 ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  unsigned int tmp___3 ;

  {
  {
#line 127
  memset((void *)(& sa___3), 0, sizeof(sa___3));
#line 128
  sa___3.sin_family = (sa_family_t )2;
#line 129
  tmp = inet_aton(arg, & sa___3.sin_addr);
  }
#line 129
  if (! tmp) {
    {
#line 129
    usageerr("invalid IP address %s", arg);
    }
  }
  {
#line 131
  prep_query(& qun, & quflags);
#line 132
  tmp___0 = strlen(arg);
#line 132
  tmp___1 = strlen(arg2);
#line 132
  tmp___2 = xmalloc((tmp___0 + tmp___1) + 2UL);
#line 132
  qun->owner = (char *)tmp___2;
#line 133
  sprintf((char */* __restrict  */)qun->owner, (char const   */* __restrict  */)"%s %s",
          arg, arg2);
  }
#line 134
  if ((unsigned int )ov_type == 0U) {
#line 134
    tmp___3 = 16U;
  } else {
#line 134
    tmp___3 = (unsigned int )ov_type;
  }
  {
#line 134
  r = adns_submit_reverse_any(ads, (struct sockaddr  const  *)((struct sockaddr *)(& sa___3)),
                              arg2, (adns_rrtype )tmp___3, (adns_queryflags )quflags,
                              (void *)qun, & qun->qu);
  }
#line 140
  if (r) {
    {
#line 140
    sysfail("adns_submit_reverse", r);
    }
  }
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    qun->next = (struct query_node *)0;
#line 142
    qun->back = outstanding.tail;
#line 142
    if (outstanding.tail) {
#line 142
      (outstanding.tail)->next = qun;
    } else {
#line 142
      outstanding.head = qun;
    }
#line 142
    outstanding.tail = qun;
#line 142
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-query.c"
void query_do(char const   *domain ) 
{ 
  struct query_node *qun ;
  int quflags ;
  int r ;
  unsigned int tmp ;

  {
  {
#line 149
  prep_query(& qun, & quflags);
#line 150
  qun->owner = xstrsave(domain);
  }
#line 151
  if ((unsigned int )ov_type == 0U) {
#line 151
    tmp = 65537U;
  } else {
#line 151
    tmp = (unsigned int )ov_type;
  }
  {
#line 151
  r = adns_submit(ads, domain, (adns_rrtype )tmp, (adns_queryflags )quflags, (void *)qun,
                  & qun->qu);
  }
#line 156
  if (r) {
    {
#line 156
    sysfail("adns_submit", r);
    }
  }
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    qun->next = (struct query_node *)0;
#line 158
    qun->back = outstanding.tail;
#line 158
    if (outstanding.tail) {
#line 158
      (outstanding.tail)->next = qun;
    } else {
#line 158
      outstanding.head = qun;
    }
#line 158
    outstanding.tail = qun;
#line 158
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 159
  return;
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-query.c"
static void dequeue_query(struct query_node *qun ) 
{ 


  {
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 162
    if (qun->back) {
#line 162
      (qun->back)->next = qun->next;
    } else {
#line 162
      outstanding.head = qun->next;
    }
#line 162
    if (qun->next) {
#line 162
      (qun->next)->back = qun->back;
    } else {
#line 162
      outstanding.tail = qun->back;
    }
#line 162
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 163
  Hfree((void *)qun->id);
#line 164
  Hfree((void *)qun->owner);
#line 165
  Hfree((void *)qun);
  }
#line 166
  return;
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-query.c"
static void print_withspace(char const   *str ) 
{ 
  int tmp ;

  {
  {
#line 169
  tmp = printf((char const   */* __restrict  */)"%s ", str);
  }
#line 169
  if (tmp == -1) {
    {
#line 169
    outerr();
    }
  }
#line 170
  return;
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-query.c"
static void print_ttl(struct query_node *qun , adns_answer *answer ) 
{ 
  unsigned long ttl ;
  time_t now ;
  int *tmp ;
  time_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 177
  if (qun->pqfr.ttl == 0) {
#line 177
    goto case_0;
  }
#line 179
  if (qun->pqfr.ttl == 1) {
#line 179
    goto case_1;
  }
#line 183
  if (qun->pqfr.ttl == 2) {
#line 183
    goto case_2;
  }
#line 186
  goto switch_default;
  case_0: /* CIL Label */ 
#line 178
  return;
  case_1: /* CIL Label */ 
  {
#line 180
  tmp___0 = time(& now);
  }
#line 180
  if (tmp___0 == -1L) {
    {
#line 180
    tmp = __errno_location();
#line 180
    sysfail("get current time", *tmp);
    }
  }
#line 181
  if (answer->expires < now) {
#line 181
    ttl = 0UL;
  } else {
#line 181
    ttl = (unsigned long )(answer->expires - now);
  }
#line 182
  goto switch_break;
  case_2: /* CIL Label */ 
#line 184
  ttl = (unsigned long )answer->expires;
#line 185
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 187
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 189
  tmp___1 = printf((char const   */* __restrict  */)"%lu ", ttl);
  }
#line 189
  if (tmp___1 == -1) {
    {
#line 189
    outerr();
    }
  }
#line 190
  return;
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-query.c"
static char const   *owner_show(struct query_node *qun , adns_answer *answer ) 
{ 
  char *tmp ;

  {
#line 193
  if (answer->owner) {
#line 193
    tmp = answer->owner;
  } else {
#line 193
    tmp = qun->owner;
  }
#line 193
  return ((char const   *)tmp);
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-query.c"
static void print_owner_ttl(struct query_node *qun , adns_answer *answer ) 
{ 
  char const   *tmp ;

  {
#line 197
  if (qun->pqfr.show_owner) {
    {
#line 197
    tmp = owner_show(qun, answer);
#line 197
    print_withspace(tmp);
    }
  }
  {
#line 198
  print_ttl(qun, answer);
  }
#line 199
  return;
}
}
#line 202
static void check_status(adns_status st ) ;
#line 202 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-query.c"
static adns_status const   statuspoints[6]  = {      (adns_status const   )0,      (adns_status const   )29,      (adns_status const   )59,      (adns_status const   )99, 
        (adns_status const   )199,      (adns_status const   )299};
#line 201 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-query.c"
static void check_status(adns_status st ) 
{ 
  adns_status const   *spp ;
  int minrcode ;

  {
#line 211
  minrcode = 0;
#line 211
  spp = statuspoints;
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 211
    if (! ((unsigned long )spp < (unsigned long )(statuspoints + sizeof(statuspoints) / sizeof(statuspoints[0])))) {
#line 211
      goto while_break;
    }
#line 214
    if ((unsigned int )st > (unsigned int )*spp) {
#line 214
      minrcode ++;
    }
#line 211
    spp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 215
  if (rcode < minrcode) {
#line 215
    rcode = minrcode;
  }
#line 216
  return;
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-query.c"
static void print_status(adns_status st , struct query_node *qun , adns_answer *answer ) 
{ 
  char const   *statustypeabbrev ;
  char const   *statusabbrev ;
  char const   *statusstring ;
  char *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 221
  statustypeabbrev = adns_errtypeabbrev(st);
#line 222
  statusabbrev = adns_errabbrev(st);
#line 223
  statusstring = adns_strerror(st);
#line 224
  tmp = strchr(statusstring, '\"');
  }
#line 224
  if (tmp) {
    {
#line 224
    __assert_fail("!strchr(statusstring,\'\"\')", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-query.c",
                  224U, "print_status");
    }
  }
  {
#line 226
  tmp___0 = printf((char const   */* __restrict  */)"%s %d %s ", statustypeabbrev,
                   (unsigned int )st, statusabbrev);
  }
#line 226
  if (tmp___0 == -1) {
    {
#line 227
    outerr();
    }
  }
  {
#line 228
  print_owner_ttl(qun, answer);
  }
#line 229
  if (qun->pqfr.show_cname) {
#line 230
    if (answer->cname) {
#line 230
      tmp___1 = (char const   *)answer->cname;
    } else {
#line 230
      tmp___1 = "$";
    }
    {
#line 230
    print_withspace(tmp___1);
    }
  }
  {
#line 231
  tmp___2 = printf((char const   */* __restrict  */)"\"%s\"\n", statusstring);
  }
#line 231
  if (tmp___2 == -1) {
    {
#line 231
    outerr();
    }
  }
#line 232
  return;
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-query.c"
static void print_dnsfail(adns_status st , struct query_node *qun , adns_answer *answer ) 
{ 
  int r ;
  char const   *typename ;
  char const   *statusstring ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int *tmp___3 ;

  {
#line 238
  if (ov_format == 2) {
    {
#line 239
    tmp = fputs((char const   */* __restrict  */)"; failed ", (FILE */* __restrict  */)stdout);
    }
#line 239
    if (tmp == -1) {
      {
#line 239
      outerr();
      }
    }
    {
#line 240
    print_status(st, qun, answer);
    }
#line 241
    return;
  }
#line 243
  if (! (ov_format == 1)) {
    {
#line 243
    __assert_fail("ov_format == fmt_simple", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-query.c",
                  243U, "print_dnsfail");
    }
  }
#line 244
  if ((unsigned int )st == 300U) {
    {
#line 245
    tmp___0 = owner_show(qun, answer);
#line 245
    r = fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s does not exist\n",
                tmp___0);
    }
  } else {
    {
#line 247
    type_info(answer->type, & typename, (void const   *)0, (char **)0);
    }
#line 248
    if ((unsigned int )st == 301U) {
      {
#line 249
      tmp___1 = owner_show(qun, answer);
#line 249
      r = fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s has no %s record\n",
                  tmp___1, typename);
      }
    } else {
      {
#line 251
      statusstring = adns_strerror(st);
#line 252
      tmp___2 = owner_show(qun, answer);
#line 252
      r = fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error during DNS %s lookup for %s: %s\n",
                  typename, tmp___2, statusstring);
      }
    }
  }
#line 256
  if (r == -1) {
    {
#line 256
    tmp___3 = __errno_location();
#line 256
    sysfail("write error message to stderr", *tmp___3);
    }
  }
#line 257
  return;
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-query.c"
void query_done(struct query_node *qun , adns_answer *answer ) 
{ 
  adns_status st ;
  int rrn ;
  int nrrs ;
  char const   *rrp ;
  char const   *realowner ;
  char const   *typename ;
  char *datastr ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 265
  st = answer->status;
#line 266
  nrrs = answer->nrrs;
#line 267
  if (ov_format == 3) {
    {
#line 268
    check_status(st);
#line 269
    tmp = printf((char const   */* __restrict  */)"%s %d ", qun->id, nrrs);
    }
#line 269
    if (tmp == -1) {
      {
#line 269
      outerr();
      }
    }
    {
#line 270
    print_status(st, qun, answer);
    }
  } else {
#line 272
    if (qun->pqfr.show_cname) {
#line 272
      if (answer->cname) {
        {
#line 273
        print_owner_ttl(qun, answer);
        }
#line 274
        if (qun->pqfr.show_type) {
          {
#line 274
          print_withspace("CNAME");
          }
        }
        {
#line 275
        tmp___0 = printf((char const   */* __restrict  */)"%s\n", answer->cname);
        }
#line 275
        if (tmp___0 == -1) {
          {
#line 275
          outerr();
          }
        }
      }
    }
#line 277
    if (st) {
      {
#line 278
      check_status(st);
#line 279
      print_dnsfail(st, qun, answer);
      }
    }
  }
#line 282
  if (qun->pqfr.show_owner) {
#line 283
    if (answer->cname) {
#line 283
      realowner = (char const   *)answer->cname;
    } else {
      {
#line 283
      tmp___1 = owner_show(qun, answer);
#line 283
      realowner = tmp___1;
      }
    }
#line 284
    if (! realowner) {
      {
#line 284
      __assert_fail("realowner", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-query.c",
                    284U, "query_done");
      }
    }
  } else {
#line 286
    realowner = (char const   *)0;
  }
#line 288
  if (nrrs) {
#line 289
    rrn = 0;
#line 289
    rrp = (char const   *)answer->rrs.untyped;
    {
#line 289
    while (1) {
      while_continue: /* CIL Label */ ;
#line 289
      if (! (rrn < nrrs)) {
#line 289
        goto while_break;
      }
#line 292
      if (realowner) {
        {
#line 292
        print_withspace(realowner);
        }
      }
      {
#line 293
      print_ttl(qun, answer);
#line 294
      type_info(answer->type, & typename, (void const   *)rrp, & datastr);
      }
#line 295
      if (qun->pqfr.show_type) {
        {
#line 295
        print_withspace(typename);
        }
      }
      {
#line 296
      tmp___2 = printf((char const   */* __restrict  */)"%s\n", datastr);
      }
#line 296
      if (tmp___2 == -1) {
        {
#line 296
        outerr();
        }
      }
      {
#line 297
      Hfree((void *)datastr);
#line 289
      rrn ++;
#line 289
      rrp += answer->rrsz;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 300
  tmp___3 = fflush(stdout);
  }
#line 300
  if (tmp___3) {
    {
#line 300
    outerr();
    }
  }
  {
#line 301
  Hfree((void *)answer);
#line 302
  dequeue_query(qun);
  }
#line 303
  return;
}
}
#line 305 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-query.c"
void of_asynch_id(struct optioninfo  const  *oi , char const   *arg , char const   *arg2 ) 
{ 


  {
  {
#line 306
  Hfree((void *)ov_id);
#line 307
  ov_id = xstrsave(arg);
  }
#line 308
  return;
}
}
#line 310 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-query.c"
void of_cancel_id(struct optioninfo  const  *oi , char const   *arg , char const   *arg2 ) 
{ 
  struct query_node *qun ;
  int tmp ;

  {
#line 313
  qun = outstanding.head;
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 313
    if (qun) {
      {
#line 313
      tmp = strcmp((char const   *)qun->id, arg);
      }
#line 313
      if (! tmp) {
#line 313
        goto while_break;
      }
    } else {
#line 313
      goto while_break;
    }
#line 313
    qun = qun->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 316
  if (! qun) {
#line 316
    return;
  }
  {
#line 317
  adns_cancel(qun->qu);
#line 318
  dequeue_query(qun);
  }
#line 319
  return;
}
}
#line 567 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/internal.h"
void adns__findlabel_start(findlabel_state *fls , adns_state ads___7 , int serv ,
                           adns_query qu , byte const   *dgram , int dglen , int max ,
                           int dmbegin , int *dmend_rlater ) ;
#line 578
adns_status adns__findlabel_next(findlabel_state *fls , int *lablen_r , int *labstart_r ) ;
#line 620
adns_status adns__parse_domain_more(findlabel_state *fls , adns_state ads___7 , adns_query qu ,
                                    vbuf *vb___0 , parsedomain_flags flags , byte const   *dgram ) ;
#line 630
adns_status adns__findrr(adns_query qu , int serv , byte const   *dgram , int dglen ,
                         int *cbyte_io , int *type_r , int *class_r , unsigned long *ttl_r ,
                         int *rdlen_r , int *rdstart_r , int *ownermatchedquery_r ) ;
#line 659
adns_status adns__findrr_anychk(adns_query qu , int serv , byte const   *dgram , int dglen ,
                                int *cbyte_io , int *type_r , int *class_r , unsigned long *ttl_r ,
                                int *rdlen_r , int *rdstart_r , byte const   *eo_dgram ,
                                int eo_dglen , int eo_cbyte , int *eo_matched_r ) ;
#line 686
int vbuf__append_quoted1035(vbuf *vb___0 , byte const   *buf___17 , int len ) ;
#line 731 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/internal.h"
__inline static int ctype_digit(int c ) 
{ 
  int tmp ;

  {
#line 731
  if (c >= 48) {
#line 731
    if (c <= 57) {
#line 731
      tmp = 1;
    } else {
#line 731
      tmp = 0;
    }
  } else {
#line 731
    tmp = 0;
  }
#line 731
  return (tmp);
}
}
#line 732 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/internal.h"
__inline static int ctype_alpha(int c ) 
{ 
  int tmp ;

  {
#line 733
  if (c >= 97) {
#line 733
    if (c <= 122) {
#line 733
      tmp = 1;
    } else {
#line 733
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 733
  if (c >= 65) {
#line 733
    if (c <= 90) {
#line 733
      tmp = 1;
    } else {
#line 733
      tmp = 0;
    }
  } else {
#line 733
    tmp = 0;
  }
#line 733
  return (tmp);
}
}
#line 738 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/internal.h"
__inline static int ctype_domainunquoted(int c ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 739
  tmp = ctype_alpha(c);
  }
#line 739
  if (tmp) {
#line 739
    tmp___2 = 1;
  } else {
    {
#line 739
    tmp___0 = ctype_digit(c);
    }
#line 739
    if (tmp___0) {
#line 739
      tmp___2 = 1;
    } else {
      {
#line 739
      tmp___1 = strchr("-_/+", c);
      }
#line 739
      if ((unsigned long )tmp___1 != (unsigned long )((char *)0)) {
#line 739
        tmp___2 = 1;
      } else {
#line 739
        tmp___2 = 0;
      }
    }
  }
#line 739
  return (tmp___2);
}
}
#line 29 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/parse.c"
int vbuf__append_quoted1035(vbuf *vb___0 , byte const   *buf___17 , int len ) 
{ 
  char qbuf[10] ;
  int i ;
  int ch ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 33
  while (1) {
    while_continue: /* CIL Label */ ;
#line 33
    if (! len) {
#line 33
      goto while_break;
    }
#line 34
    qbuf[0] = (char)0;
#line 35
    i = 0;
    {
#line 35
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 35
      if (! (i < len)) {
#line 35
        goto while_break___0;
      }
#line 36
      ch = (int )*(buf___17 + i);
#line 37
      if (ch <= 32) {
        {
#line 38
        sprintf((char */* __restrict  */)(qbuf), (char const   */* __restrict  */)"\\%03o",
                ch);
        }
#line 39
        goto while_break___0;
      } else
#line 37
      if (ch >= 127) {
        {
#line 38
        sprintf((char */* __restrict  */)(qbuf), (char const   */* __restrict  */)"\\%03o",
                ch);
        }
#line 39
        goto while_break___0;
      } else {
        {
#line 40
        tmp = ctype_domainunquoted(ch);
        }
#line 40
        if (! tmp) {
          {
#line 41
          sprintf((char */* __restrict  */)(qbuf), (char const   */* __restrict  */)"\\%c",
                  ch);
          }
#line 42
          goto while_break___0;
        }
      }
#line 35
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 45
    tmp___0 = adns__vbuf_append(vb___0, buf___17, i);
    }
#line 45
    if (tmp___0) {
      {
#line 45
      tmp___1 = strlen((char const   *)(qbuf));
#line 45
      tmp___2 = adns__vbuf_append(vb___0, (byte const   *)(qbuf), (int )tmp___1);
      }
#line 45
      if (! tmp___2) {
#line 47
        return (0);
      }
    } else {
#line 47
      return (0);
    }
#line 48
    if (i < len) {
#line 48
      i ++;
    }
#line 49
    buf___17 += i;
#line 50
    len -= i;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  return (1);
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/parse.c"
void adns__findlabel_start(findlabel_state *fls , adns_state ads___7 , int serv ,
                           adns_query qu , byte const   *dgram , int dglen , int max ,
                           int dmbegin , int *dmend_rlater ) 
{ 


  {
#line 59
  fls->ads = ads___7;
#line 60
  fls->qu = qu;
#line 61
  fls->serv = serv;
#line 62
  fls->dgram = dgram;
#line 63
  fls->dglen = dglen;
#line 64
  fls->max = max;
#line 65
  fls->cbyte = dmbegin;
#line 66
  fls->namelen = 0;
#line 67
  fls->dmend_r = dmend_rlater;
#line 68
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/parse.c"
adns_status adns__findlabel_next(findlabel_state *fls , int *lablen_r , int *labstart_r ) 
{ 
  int lablen ;
  int jumpto ;
  char const   *dgram ;
  int tmp ;
  int tmp___0 ;

  {
#line 75
  dgram = (char const   *)fls->dgram;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (fls->cbyte >= fls->dglen) {
#line 77
      goto x_truncated;
    }
#line 78
    if (fls->cbyte >= fls->max) {
#line 78
      goto x_badresponse;
    }
#line 79
    tmp = fls->cbyte;
#line 79
    (fls->cbyte) ++;
#line 79
    lablen = (int )((int const   )*(dgram + tmp) & 255);
#line 80
    if (! (lablen & 192)) {
#line 80
      goto while_break;
    }
#line 81
    if ((lablen & 192) != 192) {
#line 81
      return ((adns_status )34);
    }
#line 82
    if (fls->cbyte >= fls->dglen) {
#line 82
      goto x_truncated;
    }
#line 83
    if (fls->cbyte >= fls->max) {
#line 83
      goto x_badresponse;
    }
#line 84
    tmp___0 = fls->cbyte;
#line 84
    (fls->cbyte) ++;
#line 84
    jumpto = (int )((int const   )*(dgram + tmp___0) & 255);
#line 85
    jumpto |= (lablen & 63) << 8;
#line 86
    if (fls->dmend_r) {
#line 86
      *(fls->dmend_r) = fls->cbyte;
    }
#line 87
    fls->cbyte = jumpto;
#line 88
    fls->dmend_r = (int *)0;
#line 88
    fls->max = fls->dglen + 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  if (labstart_r) {
#line 90
    *labstart_r = fls->cbyte;
  }
#line 91
  if (lablen) {
#line 92
    if (fls->namelen) {
#line 92
      (fls->namelen) ++;
    }
#line 93
    fls->namelen += lablen;
#line 94
    if (fls->namelen > 255) {
#line 94
      return ((adns_status )103);
    }
#line 95
    fls->cbyte += lablen;
#line 96
    if (fls->cbyte > fls->dglen) {
#line 96
      goto x_truncated;
    }
#line 97
    if (fls->cbyte > fls->max) {
#line 97
      goto x_badresponse;
    }
  } else
#line 99
  if (fls->dmend_r) {
#line 99
    *(fls->dmend_r) = fls->cbyte;
  }
#line 101
  *lablen_r = lablen;
#line 102
  return ((adns_status )0);
  x_truncated: 
#line 105
  *lablen_r = -1;
#line 106
  return ((adns_status )0);
  x_badresponse: 
  {
#line 109
  adns__diag(fls->ads, fls->serv, fls->qu, "label in domain runs beyond end of domain");
  }
#line 111
  return ((adns_status )33);
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/parse.c"
adns_status adns__parse_domain(adns_state ads___7 , int serv , adns_query qu , vbuf *vb___0 ,
                               parsedomain_flags flags , byte const   *dgram , int dglen ,
                               int *cbyte_io , int max ) 
{ 
  findlabel_state fls ;
  adns_status tmp ;

  {
  {
#line 120
  adns__findlabel_start(& fls, ads___7, serv, qu, dgram, dglen, max, *cbyte_io, cbyte_io);
#line 122
  vb___0->used = 0;
#line 123
  tmp = adns__parse_domain_more(& fls, ads___7, qu, vb___0, flags, dgram);
  }
#line 123
  return (tmp);
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/parse.c"
adns_status adns__parse_domain_more(findlabel_state *fls , adns_state ads___7 , adns_query qu ,
                                    vbuf *vb___0 , parsedomain_flags flags , byte const   *dgram ) 
{ 
  int lablen ;
  int labstart ;
  int i ;
  int ch ;
  int first ;
  adns_status st ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 133
  first = 1;
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 135
    st = adns__findlabel_next(fls, & lablen, & labstart);
    }
#line 136
    if (st) {
#line 136
      return (st);
    }
#line 137
    if (lablen < 0) {
#line 137
      vb___0->used = 0;
#line 137
      return ((adns_status )0);
    }
#line 138
    if (! lablen) {
#line 138
      goto while_break;
    }
#line 139
    if (first) {
#line 140
      first = 0;
    } else {
      {
#line 142
      tmp = adns__vbuf_append(vb___0, (byte const   *)".", 1);
      }
#line 142
      if (! tmp) {
#line 142
        return ((adns_status )1);
      }
    }
#line 144
    if ((unsigned int )flags & 1U) {
      {
#line 145
      tmp___0 = vbuf__append_quoted1035(vb___0, dgram + labstart, lablen);
      }
#line 145
      if (! tmp___0) {
#line 146
        return ((adns_status )1);
      }
    } else {
      {
#line 148
      ch = (int )*(dgram + labstart);
#line 149
      tmp___1 = ctype_alpha(ch);
      }
#line 149
      if (! tmp___1) {
        {
#line 149
        tmp___2 = ctype_digit(ch);
        }
#line 149
        if (! tmp___2) {
#line 150
          return ((adns_status )102);
        }
      }
#line 151
      i = labstart + 1;
      {
#line 151
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 151
        if (! (i < labstart + lablen)) {
#line 151
          goto while_break___0;
        }
#line 152
        ch = (int )*(dgram + i);
#line 153
        if (ch != 45) {
          {
#line 153
          tmp___3 = ctype_alpha(ch);
          }
#line 153
          if (! tmp___3) {
            {
#line 153
            tmp___4 = ctype_digit(ch);
            }
#line 153
            if (! tmp___4) {
#line 154
              return ((adns_status )102);
            }
          }
        }
#line 151
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 156
      tmp___5 = adns__vbuf_append(vb___0, dgram + labstart, lablen);
      }
#line 156
      if (! tmp___5) {
#line 157
        return ((adns_status )1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 160
  tmp___6 = adns__vbuf_append(vb___0, (byte const   *)"", 1);
  }
#line 160
  if (! tmp___6) {
#line 160
    return ((adns_status )1);
  }
#line 161
  return ((adns_status )0);
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/parse.c"
adns_status adns__findrr_anychk(adns_query qu , int serv , byte const   *dgram , int dglen ,
                                int *cbyte_io , int *type_r , int *class_r , unsigned long *ttl_r ,
                                int *rdlen_r , int *rdstart_r , byte const   *eo_dgram ,
                                int eo_dglen , int eo_cbyte , int *eo_matched_r ) 
{ 
  findlabel_state fls ;
  findlabel_state eo_fls_buf ;
  findlabel_state *eo_fls ;
  int cbyte___3 ;
  int tmp ;
  int rdlen ;
  unsigned long ttl ;
  int lablen ;
  int labstart ;
  int ch ;
  int eo_lablen ;
  int eo_labstart ;
  int eo_ch ;
  adns_status st ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
  {
#line 181
  cbyte___3 = *cbyte_io;
#line 183
  adns__findlabel_start(& fls, qu->ads, serv, qu, dgram, dglen, dglen, cbyte___3,
                        & cbyte___3);
  }
#line 184
  if (eo_dgram) {
    {
#line 185
    eo_fls = & eo_fls_buf;
#line 186
    adns__findlabel_start(eo_fls, qu->ads, -1, (adns_query )0, eo_dgram, eo_dglen,
                          eo_dglen, eo_cbyte, (int *)0);
    }
  } else {
#line 189
    eo_fls = (findlabel_state *)0;
  }
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 193
    st = adns__findlabel_next(& fls, & lablen, & labstart);
    }
#line 194
    if (st) {
#line 194
      return (st);
    }
#line 195
    if (lablen < 0) {
#line 195
      goto x_truncated;
    }
#line 197
    if (eo_fls) {
      {
#line 198
      st = adns__findlabel_next(eo_fls, & eo_lablen, & eo_labstart);
      }
#line 199
      if (! (! st)) {
        {
#line 199
        __assert_fail("!st", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/parse.c",
                      199U, "adns__findrr_anychk");
        }
      }
#line 199
      if (! (eo_lablen >= 0)) {
        {
#line 199
        __assert_fail("eo_lablen>=0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/parse.c",
                      199U, "adns__findrr_anychk");
        }
      }
#line 200
      if (lablen != eo_lablen) {
#line 200
        eo_fls = (findlabel_state *)0;
      }
      {
#line 201
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 201
        if (eo_fls) {
#line 201
          tmp___4 = eo_lablen;
#line 201
          eo_lablen --;
#line 201
          if (! (tmp___4 > 0)) {
#line 201
            goto while_break___0;
          }
        } else {
#line 201
          goto while_break___0;
        }
        {
#line 202
        tmp___0 = labstart;
#line 202
        labstart ++;
#line 202
        ch = (int )*(dgram + tmp___0);
#line 202
        tmp___1 = ctype_alpha(ch);
        }
#line 202
        if (tmp___1) {
#line 202
          ch &= -33;
        }
        {
#line 203
        tmp___2 = eo_labstart;
#line 203
        eo_labstart ++;
#line 203
        eo_ch = (int )*(eo_dgram + tmp___2);
#line 203
        tmp___3 = ctype_alpha(eo_ch);
        }
#line 203
        if (tmp___3) {
#line 203
          eo_ch &= -33;
        }
#line 204
        if (ch != eo_ch) {
#line 204
          eo_fls = (findlabel_state *)0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 207
    if (! lablen) {
#line 207
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 209
  if (eo_matched_r) {
#line 209
    *eo_matched_r = ! (! eo_fls);
  }
#line 211
  if (cbyte___3 + 10 > dglen) {
#line 211
    goto x_truncated;
  }
#line 212
  tmp = 0;
#line 212
  tmp___5 = cbyte___3;
#line 212
  cbyte___3 ++;
#line 212
  tmp |= (int )(((int const   )*(dgram + tmp___5) & 255) << 8);
#line 212
  tmp___6 = cbyte___3;
#line 212
  cbyte___3 ++;
#line 212
  tmp |= (int )((int const   )*(dgram + tmp___6) & 255);
#line 212
  *type_r = tmp;
#line 213
  tmp = 0;
#line 213
  tmp___7 = cbyte___3;
#line 213
  cbyte___3 ++;
#line 213
  tmp |= (int )(((int const   )*(dgram + tmp___7) & 255) << 8);
#line 213
  tmp___8 = cbyte___3;
#line 213
  cbyte___3 ++;
#line 213
  tmp |= (int )((int const   )*(dgram + tmp___8) & 255);
#line 213
  *class_r = tmp;
#line 215
  ttl = 0UL;
#line 215
  tmp___9 = cbyte___3;
#line 215
  cbyte___3 ++;
#line 215
  ttl |= (unsigned long )(((int const   )*(dgram + tmp___9) & 255) << 24);
#line 215
  tmp___10 = cbyte___3;
#line 215
  cbyte___3 ++;
#line 215
  ttl |= (unsigned long )(((int const   )*(dgram + tmp___10) & 255) << 16);
#line 215
  tmp___11 = cbyte___3;
#line 215
  cbyte___3 ++;
#line 215
  ttl |= (unsigned long )(((int const   )*(dgram + tmp___11) & 255) << 8);
#line 215
  tmp___12 = cbyte___3;
#line 215
  cbyte___3 ++;
#line 215
  ttl |= (unsigned long )((int const   )*(dgram + tmp___12) & 255);
#line 216
  if (ttl > 604800UL) {
#line 216
    ttl = 604800UL;
  }
#line 217
  *ttl_r = ttl;
#line 219
  rdlen = 0;
#line 219
  tmp___13 = cbyte___3;
#line 219
  cbyte___3 ++;
#line 219
  rdlen |= (int )(((int const   )*(dgram + tmp___13) & 255) << 8);
#line 219
  tmp___14 = cbyte___3;
#line 219
  cbyte___3 ++;
#line 219
  rdlen |= (int )((int const   )*(dgram + tmp___14) & 255);
#line 219
  if (rdlen_r) {
#line 219
    *rdlen_r = rdlen;
  }
#line 220
  if (rdstart_r) {
#line 220
    *rdstart_r = cbyte___3;
  }
#line 221
  cbyte___3 += rdlen;
#line 222
  if (cbyte___3 > dglen) {
#line 222
    goto x_truncated;
  }
#line 223
  *cbyte_io = cbyte___3;
#line 224
  return ((adns_status )0);
  x_truncated: 
#line 227
  *type_r = -1;
#line 228
  return ((adns_status )0);
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/parse.c"
adns_status adns__findrr(adns_query qu , int serv , byte const   *dgram , int dglen ,
                         int *cbyte_io , int *type_r , int *class_r , unsigned long *ttl_r ,
                         int *rdlen_r , int *rdstart_r , int *ownermatchedquery_r ) 
{ 
  adns_status tmp ;
  adns_status tmp___0 ;
  adns_status tmp___1 ;

  {
#line 236
  if (! ownermatchedquery_r) {
    {
#line 237
    tmp = adns__findrr_anychk(qu, serv, dgram, dglen, cbyte_io, type_r, class_r, ttl_r,
                              rdlen_r, rdstart_r, (byte const   *)0, 0, 0, (int *)0);
    }
#line 237
    return (tmp);
  } else
#line 241
  if (! qu->cname_dgram) {
    {
#line 242
    tmp___0 = adns__findrr_anychk(qu, serv, dgram, dglen, cbyte_io, type_r, class_r,
                                  ttl_r, rdlen_r, rdstart_r, (byte const   *)qu->query_dgram,
                                  qu->query_dglen, 12, ownermatchedquery_r);
    }
#line 242
    return (tmp___0);
  } else {
    {
#line 248
    tmp___1 = adns__findrr_anychk(qu, serv, dgram, dglen, cbyte_io, type_r, class_r,
                                  ttl_r, rdlen_r, rdstart_r, (byte const   *)qu->cname_dgram,
                                  qu->cname_dglen, qu->cname_begin, ownermatchedquery_r);
    }
#line 248
    return (tmp___1);
  }
}
}
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 377
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 285
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 430 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/adns.h"
int adns_init_logfn(adns_state *newstate_r , adns_initflags flags , char const   *configtext ,
                    adns_logcallbackfn *logfn , void *logfndata ) ;
#line 608
void adns_finish(adns_state ads___7 ) ;
#line 614
void adns_forallqueries_begin(adns_state ads___7 ) ;
#line 615
adns_query adns_forallqueries_next(adns_state ads___7 , void **context_r ) ;
#line 728 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/internal.h"
__inline static int ctype_whitespace(int c ) 
{ 
  int tmp ;

  {
#line 729
  if (c == 32) {
#line 729
    tmp = 1;
  } else
#line 729
  if (c == 10) {
#line 729
    tmp = 1;
  } else
#line 729
  if (c == 9) {
#line 729
    tmp = 1;
  } else {
#line 729
    tmp = 0;
  }
#line 729
  return (tmp);
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfig(adns_state ads___7 , char const   *filename , int warnmissing ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void addserver(adns_state ads___7 , struct in_addr addr ) 
{ 
  int i ;
  struct server *ss ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 48
  i = 0;
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (i < ads___7->nservers)) {
#line 48
      goto while_break;
    }
#line 49
    if (ads___7->servers[i].addr.s_addr == addr.s_addr) {
      {
#line 50
      tmp = inet_ntoa(addr);
#line 50
      adns__debug(ads___7, -1, (adns_query )0, "duplicate nameserver %s ignored",
                  tmp);
      }
#line 51
      return;
    }
#line 48
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  if (ads___7->nservers >= 5) {
    {
#line 56
    tmp___0 = inet_ntoa(addr);
#line 56
    adns__diag(ads___7, -1, (adns_query )0, "too many nameservers, ignoring %s", tmp___0);
    }
#line 57
    return;
  }
#line 60
  ss = ads___7->servers + ads___7->nservers;
#line 61
  ss->addr = addr;
#line 62
  (ads___7->nservers) ++;
#line 63
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void freesearchlist(adns_state ads___7 ) 
{ 


  {
#line 66
  if (ads___7->nsearchlist) {
    {
#line 66
    Hfree((void *)*(ads___7->searchlist));
    }
  }
  {
#line 67
  Hfree((void *)ads___7->searchlist);
  }
#line 68
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void saveerr(adns_state ads___7 , int en ) 
{ 


  {
#line 71
  if (! ads___7->configerrno) {
#line 71
    ads___7->configerrno = en;
  }
#line 72
  return;
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void configparseerr(adns_state ads___7 , char const   *fn , int lno , char const   *fmt 
                           , ...) 
{ 
  va_list al ;

  {
  {
#line 78
  saveerr(ads___7, 22);
  }
#line 79
  if (! ads___7->logfn) {
#line 79
    return;
  } else
#line 79
  if ((unsigned int )ads___7->iflags & 2U) {
#line 79
    return;
  }
#line 81
  if (lno == -1) {
    {
#line 81
    adns__lprintf(ads___7, "adns: %s: ", fn);
    }
  } else {
    {
#line 82
    adns__lprintf(ads___7, "adns: %s:%d: ", fn, lno);
    }
  }
  {
#line 83
  __builtin_va_start(al, fmt);
#line 84
  adns__vlprintf(ads___7, fmt, al);
#line 85
  __builtin_va_end(al);
#line 86
  adns__lprintf(ads___7, "\n");
  }
#line 87
  return;
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int nextword(char const   **bufp_io , char const   **word_r , int *l_r ) 
{ 
  char const   *p ;
  char const   *q ;
  int tmp ;
  int tmp___0 ;

  {
#line 92
  p = *bufp_io;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 93
    tmp = ctype_whitespace((int )*p);
    }
#line 93
    if (! tmp) {
#line 93
      goto while_break;
    }
#line 93
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  if (! *p) {
#line 94
    return (0);
  }
#line 96
  q = p;
  {
#line 97
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 97
    if (*q) {
      {
#line 97
      tmp___0 = ctype_whitespace((int )*q);
      }
#line 97
      if (tmp___0) {
#line 97
        goto while_break___0;
      }
    } else {
#line 97
      goto while_break___0;
    }
#line 97
    q ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 99
  *l_r = (int )(q - p);
#line 100
  *word_r = p;
#line 101
  *bufp_io = q;
#line 103
  return (1);
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_nameserver(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  struct in_addr ia ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 110
  tmp = inet_aton(buf___17, & ia);
  }
#line 110
  if (! tmp) {
    {
#line 111
    configparseerr(ads___7, fn, lno, "invalid nameserver address `%s\'", buf___17);
    }
#line 112
    return;
  }
  {
#line 114
  tmp___0 = inet_ntoa(ia);
#line 114
  adns__debug(ads___7, -1, (adns_query )0, "using nameserver %s", tmp___0);
#line 115
  addserver(ads___7, ia);
  }
#line 116
  return;
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_search(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  char const   *bufp ;
  char const   *word ;
  char *newchars ;
  char **newptrs ;
  char **pp ;
  int count ;
  int tl ;
  int l ;
  int tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char **tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
#line 124
  if (! buf___17) {
#line 124
    return;
  }
#line 126
  bufp = buf___17;
#line 127
  count = 0;
#line 128
  tl = 0;
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 129
    tmp = nextword(& bufp, & word, & l);
    }
#line 129
    if (! tmp) {
#line 129
      goto while_break;
    }
#line 129
    count ++;
#line 129
    tl += l + 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 131
  tmp___0 = Hmalloc(sizeof(char *) * (unsigned long )count);
#line 131
  newptrs = (char **)tmp___0;
  }
#line 132
  if (! newptrs) {
    {
#line 132
    tmp___1 = __errno_location();
#line 132
    saveerr(ads___7, *tmp___1);
    }
#line 132
    return;
  }
  {
#line 134
  tmp___2 = Hmalloc((size_t )tl);
#line 134
  newchars = (char *)tmp___2;
  }
#line 135
  if (! newchars) {
    {
#line 135
    tmp___3 = __errno_location();
#line 135
    saveerr(ads___7, *tmp___3);
#line 135
    Hfree((void *)newptrs);
    }
#line 135
    return;
  }
#line 137
  bufp = buf___17;
#line 138
  pp = newptrs;
  {
#line 139
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 139
    tmp___6 = nextword(& bufp, & word, & l);
    }
#line 139
    if (! tmp___6) {
#line 139
      goto while_break___0;
    }
    {
#line 140
    tmp___4 = pp;
#line 140
    pp ++;
#line 140
    *tmp___4 = newchars;
#line 141
    memcpy((void */* __restrict  */)newchars, (void const   */* __restrict  */)word,
           (size_t )l);
#line 142
    newchars += l;
#line 143
    tmp___5 = newchars;
#line 143
    newchars ++;
#line 143
    *tmp___5 = (char)0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 146
  freesearchlist(ads___7);
#line 147
  ads___7->nsearchlist = count;
#line 148
  ads___7->searchlist = newptrs;
  }
#line 149
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_sortlist(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  char const   *word ;
  char tbuf[200] ;
  char *slash ;
  char *ep ;
  struct in_addr base ;
  struct in_addr mask ;
  int l ;
  unsigned long initial ;
  unsigned long baselocal ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  uint32_t tmp___3 ;
  int tmp___4 ;

  {
#line 159
  if (! buf___17) {
#line 159
    return;
  }
#line 161
  ads___7->nsortlist = 0;
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 162
    tmp___4 = nextword(& buf___17, & word, & l);
    }
#line 162
    if (! tmp___4) {
#line 162
      goto while_break;
    }
#line 163
    if (ads___7->nsortlist >= 15) {
      {
#line 164
      adns__diag(ads___7, -1, (adns_query )0, "too many sortlist entries, ignoring %.*s onwards",
                 l, word);
      }
#line 166
      return;
    }
#line 169
    if ((unsigned long )l >= sizeof(tbuf)) {
      {
#line 170
      configparseerr(ads___7, fn, lno, "sortlist entry `%.*s\' too long", l, word);
      }
#line 171
      goto while_continue;
    }
    {
#line 174
    memcpy((void */* __restrict  */)(tbuf), (void const   */* __restrict  */)word,
           (size_t )l);
#line 174
    tbuf[l] = (char)0;
#line 175
    slash = strchr((char const   *)(tbuf), '/');
    }
#line 176
    if (slash) {
#line 176
      tmp = slash;
#line 176
      slash ++;
#line 176
      *tmp = (char)0;
    }
    {
#line 178
    tmp___0 = inet_aton((char const   *)(tbuf), & base);
    }
#line 178
    if (! tmp___0) {
      {
#line 179
      configparseerr(ads___7, fn, lno, "invalid address `%s\' in sortlist", tbuf);
      }
#line 180
      goto while_continue;
    }
#line 183
    if (slash) {
      {
#line 184
      tmp___2 = strchr((char const   *)slash, '.');
      }
#line 184
      if (tmp___2) {
        {
#line 185
        tmp___1 = inet_aton((char const   *)slash, & mask);
        }
#line 185
        if (! tmp___1) {
          {
#line 186
          configparseerr(ads___7, fn, lno, "invalid mask `%s\' in sortlist", slash);
          }
#line 187
          goto while_continue;
        }
#line 189
        if (base.s_addr & ~ mask.s_addr) {
          {
#line 190
          configparseerr(ads___7, fn, lno, "mask `%s\' in sortlist overlaps address `%s\'",
                         slash, tbuf);
          }
#line 192
          goto while_continue;
        }
      } else {
        {
#line 195
        initial = strtoul((char const   */* __restrict  */)slash, (char **/* __restrict  */)(& ep),
                          10);
        }
#line 196
        if (*ep) {
          {
#line 197
          configparseerr(ads___7, fn, lno, "mask length `%s\' invalid", slash);
          }
#line 198
          goto while_continue;
        } else
#line 196
        if (initial > 32UL) {
          {
#line 197
          configparseerr(ads___7, fn, lno, "mask length `%s\' invalid", slash);
          }
#line 198
          goto while_continue;
        }
        {
#line 200
        mask.s_addr = htonl((uint32_t )(4294967295UL << (32UL - initial)));
        }
      }
    } else {
      {
#line 203
      tmp___3 = ntohl(base.s_addr);
#line 203
      baselocal = (unsigned long )tmp___3;
      }
#line 204
      if ((unsigned long )(! baselocal) & 2147483648UL) {
        {
#line 205
        mask.s_addr = htonl((uint32_t )4278190080UL);
        }
      } else
#line 206
      if ((baselocal & 3221225472UL) == 2147483648UL) {
        {
#line 207
        mask.s_addr = htonl((uint32_t )4294901760UL);
        }
      } else
#line 208
      if ((baselocal & 4026531840UL) == 3758096384UL) {
        {
#line 209
        mask.s_addr = htonl((uint32_t )4278190080UL);
        }
      } else {
        {
#line 211
        configparseerr(ads___7, fn, lno, "network address `%s\' in sortlist is not in classed ranges, must specify mask explicitly",
                       tbuf);
        }
#line 214
        goto while_continue;
      }
    }
#line 218
    ads___7->sortlist[ads___7->nsortlist].base = base;
#line 219
    ads___7->sortlist[ads___7->nsortlist].mask = mask;
#line 220
    (ads___7->nsortlist) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  return;
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_options(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  char const   *word ;
  char *ep ;
  unsigned long v ;
  int l ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 231
  if (! buf___17) {
#line 231
    return;
  }
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 233
    tmp___5 = nextword(& buf___17, & word, & l);
    }
#line 233
    if (! tmp___5) {
#line 233
      goto while_break;
    }
#line 234
    if (l == 5) {
      {
#line 234
      tmp = memcmp((void const   *)word, (void const   *)"debug", (size_t )5);
      }
#line 234
      if (! tmp) {
#line 235
        ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 8U);
#line 236
        goto while_continue;
      }
    }
#line 238
    if (l >= 6) {
      {
#line 238
      tmp___0 = memcmp((void const   *)word, (void const   *)"ndots:", (size_t )6);
      }
#line 238
      if (! tmp___0) {
        {
#line 239
        v = strtoul((char const   */* __restrict  */)(word + 6), (char **/* __restrict  */)(& ep),
                    10);
        }
#line 240
        if (l == 6) {
          {
#line 241
          configparseerr(ads___7, fn, lno, "option `%.*s\' malformed or has bad value",
                         l, word);
          }
#line 243
          goto while_continue;
        } else
#line 240
        if ((unsigned long )ep != (unsigned long )(word + l)) {
          {
#line 241
          configparseerr(ads___7, fn, lno, "option `%.*s\' malformed or has bad value",
                         l, word);
          }
#line 243
          goto while_continue;
        } else
#line 240
        if (v > 2147483647UL) {
          {
#line 241
          configparseerr(ads___7, fn, lno, "option `%.*s\' malformed or has bad value",
                         l, word);
          }
#line 243
          goto while_continue;
        }
#line 245
        ads___7->searchndots = (int )v;
#line 246
        goto while_continue;
      }
    }
#line 248
    if (l >= 12) {
      {
#line 248
      tmp___4 = memcmp((void const   *)word, (void const   *)"adns_checkc:", (size_t )12);
      }
#line 248
      if (! tmp___4) {
        {
#line 249
        tmp___3 = strcmp(word + 12, "none");
        }
#line 249
        if (tmp___3) {
          {
#line 252
          tmp___2 = strcmp(word + 12, "entex");
          }
#line 252
          if (tmp___2) {
            {
#line 255
            tmp___1 = strcmp(word + 12, "freq");
            }
#line 255
            if (tmp___1) {
              {
#line 258
              configparseerr(ads___7, fn, lno, "option adns_checkc has bad value `%s\' (must be none, entex or freq",
                             word + 12);
              }
            } else {
#line 256
              ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 768U);
            }
          } else {
#line 253
            ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags & 4294966527U);
#line 254
            ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 256U);
          }
        } else {
#line 250
          ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags & 4294966527U);
#line 251
          ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 256U);
        }
#line 261
        goto while_continue;
      }
    }
    {
#line 263
    adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown option `%.*s\'", fn, lno,
               l, word);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 265
  return;
}
}
#line 267 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_clearnss(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 


  {
#line 269
  ads___7->nservers = 0;
#line 270
  return;
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_include(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 


  {
#line 274
  if (! *buf___17) {
    {
#line 275
    configparseerr(ads___7, fn, lno, "`include\' directive with no filename");
    }
#line 276
    return;
  }
  {
#line 278
  readconfig(ads___7, buf___17, 1);
  }
#line 279
  return;
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_lookup(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  int found_bind ;
  char const   *word ;
  int l ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 283
  found_bind = 0;
#line 287
  if (! *buf___17) {
    {
#line 288
    configparseerr(ads___7, fn, lno, "`lookup\' directive with no databases");
    }
#line 289
    return;
  }
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 292
    tmp___2 = nextword(& buf___17, & word, & l);
    }
#line 292
    if (! tmp___2) {
#line 292
      goto while_break;
    }
#line 293
    if (l == 4) {
      {
#line 293
      tmp___1 = memcmp((void const   *)word, (void const   *)"bind", (size_t )4);
      }
#line 293
      if (tmp___1) {
#line 293
        goto _L___0;
      } else {
#line 294
        found_bind = 1;
      }
    } else
    _L___0: /* CIL Label */ 
#line 295
    if (l == 4) {
      {
#line 295
      tmp___0 = memcmp((void const   *)word, (void const   *)"file", (size_t )4);
      }
#line 295
      if (tmp___0) {
#line 295
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 297
    if (l == 2) {
      {
#line 297
      tmp = memcmp((void const   *)word, (void const   *)"yp", (size_t )2);
      }
#line 297
      if (tmp) {
        {
#line 301
        adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown `lookup\' database `%.*s\'",
                   fn, lno, l, word);
#line 303
        found_bind = -1;
        }
      } else {
        {
#line 298
        adns__diag(ads___7, -1, (adns_query )0, "%s:%d: yp lookups not supported by adns",
                   fn, lno);
#line 299
        found_bind = -1;
        }
      }
    } else {
      {
#line 301
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown `lookup\' database `%.*s\'",
                 fn, lno, l, word);
#line 303
      found_bind = -1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 306
  if (! found_bind) {
    {
#line 307
    adns__diag(ads___7, -1, (adns_query )0, "%s:%d: `lookup\' specified, but not `bind\'",
               fn, lno);
    }
  }
#line 308
  return;
}
}
#line 310 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static struct configcommandinfo  const  configcommandinfos[9]  = 
#line 310
  {      {"nameserver", & ccf_nameserver}, 
        {"domain", & ccf_search}, 
        {"search", & ccf_search}, 
        {"sortlist", & ccf_sortlist}, 
        {"options", & ccf_options}, 
        {"clearnameservers", & ccf_clearnss}, 
        {"include", & ccf_include}, 
        {"lookup", & ccf_lookup}, 
        {(char const   *)0, (void (*)(adns_state ads , char const   *fn , int lno , char const   *buf ))0}};
#line 330 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int gl_file(adns_state ads___7 , getline_ctx *src_io , char const   *filename ,
                   int lno , char *buf___17 , int buflen ) 
{ 
  FILE *file ;
  int c ;
  int i ;
  char *p ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 332
  file = src_io->file;
#line 336
  p = buf___17;
#line 337
  buflen --;
#line 338
  i = 0;
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (i == buflen) {
      {
#line 342
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: line too long, ignored", filename,
                 lno);
      }
#line 343
      goto x_badline;
    }
    {
#line 345
    c = _IO_getc(file);
    }
#line 346
    if (! c) {
      {
#line 347
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: line contains nul, ignored",
                 filename, lno);
      }
#line 348
      goto x_badline;
    } else
#line 349
    if (c == 10) {
#line 350
      goto while_break;
    } else
#line 351
    if (c == -1) {
      {
#line 352
      tmp___2 = ferror(file);
      }
#line 352
      if (tmp___2) {
        {
#line 353
        tmp = __errno_location();
#line 353
        saveerr(ads___7, *tmp);
#line 354
        tmp___0 = __errno_location();
#line 354
        tmp___1 = strerror(*tmp___0);
#line 354
        adns__diag(ads___7, -1, (adns_query )0, "%s:%d: read error: %s", filename,
                   lno, tmp___1);
        }
#line 356
        return (-1);
      }
#line 358
      if (! i) {
#line 358
        return (-1);
      }
#line 359
      goto while_break;
    } else {
#line 361
      tmp___3 = p;
#line 361
      p ++;
#line 361
      *tmp___3 = (char )c;
#line 362
      i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 366
  tmp___4 = p;
#line 366
  p ++;
#line 366
  *tmp___4 = (char)0;
#line 367
  return (i);
  x_badline: 
  {
#line 370
  saveerr(ads___7, 22);
  }
  {
#line 371
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 371
    c = _IO_getc(file);
    }
#line 371
    if (c != -1) {
#line 371
      if (! (c != 10)) {
#line 371
        goto while_break___0;
      }
    } else {
#line 371
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 372
  return (-2);
}
}
#line 375 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int gl_text(adns_state ads___7 , getline_ctx *src_io , char const   *filename ,
                   int lno , char *buf___17 , int buflen ) 
{ 
  char const   *cp ;
  int l ;
  size_t tmp ;

  {
#line 377
  cp = src_io->text;
#line 380
  if (! cp) {
#line 380
    return (-1);
  } else
#line 380
  if (! *cp) {
#line 380
    return (-1);
  }
#line 382
  if ((int const   )*cp == 59) {
#line 382
    cp ++;
  } else
#line 382
  if ((int const   )*cp == 10) {
#line 382
    cp ++;
  }
  {
#line 383
  tmp = strcspn(cp, ";\n");
#line 383
  l = (int )tmp;
#line 384
  src_io->text = cp + l;
  }
#line 386
  if (l >= buflen) {
    {
#line 387
    adns__diag(ads___7, -1, (adns_query )0, "%s:%d: line too long, ignored", filename,
               lno);
#line 388
    saveerr(ads___7, 22);
    }
#line 389
    return (-2);
  }
  {
#line 392
  memcpy((void */* __restrict  */)buf___17, (void const   */* __restrict  */)cp, (size_t )l);
#line 393
  *(buf___17 + l) = (char)0;
  }
#line 394
  return (l);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfiggeneric(adns_state ads___7 , char const   *filename , int (*getline___0)(adns_state ads ,
                                                                                               getline_ctx * ,
                                                                                               char const   *filename ,
                                                                                               int lno ,
                                                                                               char *buf ,
                                                                                               int buflen ) ,
                              getline_ctx gl_ctx ) 
{ 
  char linebuf[2000] ;
  char *p ;
  char *q ;
  int lno ;
  int l ;
  int dirl ;
  struct configcommandinfo  const  *ccip ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 410
  lno = 1;
  {
#line 410
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 410
    l = (*getline___0)(ads___7, & gl_ctx, filename, lno, linebuf, (int )sizeof(linebuf));
    }
#line 410
    if (! (l != -1)) {
#line 410
      goto while_break;
    }
#line 413
    if (l == -2) {
#line 413
      goto __Cont;
    }
    {
#line 414
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 414
      if (l > 0) {
        {
#line 414
        tmp = ctype_whitespace((int )linebuf[l - 1]);
        }
#line 414
        if (! tmp) {
#line 414
          goto while_break___0;
        }
      } else {
#line 414
        goto while_break___0;
      }
#line 414
      l --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 415
    linebuf[l] = (char)0;
#line 416
    p = linebuf;
    {
#line 417
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 417
      tmp___0 = ctype_whitespace((int )*p);
      }
#line 417
      if (! tmp___0) {
#line 417
        goto while_break___1;
      }
#line 417
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 418
    if ((int )*p == 35) {
#line 418
      goto __Cont;
    } else
#line 418
    if ((int )*p == 59) {
#line 418
      goto __Cont;
    } else
#line 418
    if (! *p) {
#line 418
      goto __Cont;
    }
#line 419
    q = p;
    {
#line 420
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 420
      if (*q) {
        {
#line 420
        tmp___1 = ctype_whitespace((int )*q);
        }
#line 420
        if (tmp___1) {
#line 420
          goto while_break___2;
        }
      } else {
#line 420
        goto while_break___2;
      }
#line 420
      q ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 421
    dirl = (int )(q - p);
#line 422
    ccip = configcommandinfos;
    {
#line 422
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 422
      if (ccip->name) {
        {
#line 422
        tmp___2 = strlen((char const   *)ccip->name);
        }
#line 422
        if (tmp___2 == (size_t )dirl) {
          {
#line 422
          tmp___3 = memcmp((void const   *)ccip->name, (void const   *)p, (size_t )(q - p));
          }
#line 422
          if (! tmp___3) {
#line 422
            goto while_break___3;
          }
        }
      } else {
#line 422
        goto while_break___3;
      }
#line 422
      ccip ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 426
    if (! ccip->name) {
      {
#line 427
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown configuration directive `%.*s\'",
                 filename, lno, (int )(q - p), p);
      }
#line 429
      goto __Cont;
    }
    {
#line 431
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 431
      tmp___4 = ctype_whitespace((int )*q);
      }
#line 431
      if (! tmp___4) {
#line 431
        goto while_break___4;
      }
#line 431
      q ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 432
    (*(ccip->fn))(ads___7, filename, lno, (char const   *)q);
    }
    __Cont: /* CIL Label */ 
#line 410
    lno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 434
  return;
}
}
#line 436 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static char const   *instrum_getenv(adns_state ads___7 , char const   *envvar ) 
{ 
  char const   *value ;
  char *tmp ;

  {
  {
#line 439
  tmp = getenv(envvar);
#line 439
  value = (char const   *)tmp;
  }
#line 440
  if (! value) {
    {
#line 440
    adns__debug(ads___7, -1, (adns_query )0, "environment variable %s not set", envvar);
    }
  } else {
    {
#line 441
    adns__debug(ads___7, -1, (adns_query )0, "environment variable %s set to `%s\'",
                envvar, value);
    }
  }
#line 443
  return (value);
}
}
#line 446 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfig(adns_state ads___7 , char const   *filename , int warnmissing ) 
{ 
  getline_ctx gl_ctx ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 449
  gl_ctx.file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 450
  if (! gl_ctx.file) {
    {
#line 451
    tmp = __errno_location();
    }
#line 451
    if (*tmp == 2) {
#line 452
      if (warnmissing) {
        {
#line 453
        adns__debug(ads___7, -1, (adns_query )0, "configuration file `%s\' does not exist",
                    filename);
        }
      }
#line 455
      return;
    }
    {
#line 457
    tmp___0 = __errno_location();
#line 457
    saveerr(ads___7, *tmp___0);
#line 458
    tmp___1 = __errno_location();
#line 458
    tmp___2 = strerror(*tmp___1);
#line 458
    adns__diag(ads___7, -1, (adns_query )0, "cannot open configuration file `%s\': %s",
               filename, tmp___2);
    }
#line 460
    return;
  }
  {
#line 463
  readconfiggeneric(ads___7, filename, & gl_file, gl_ctx);
#line 465
  fclose(gl_ctx.file);
  }
#line 466
  return;
}
}
#line 468 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfigtext(adns_state ads___7 , char const   *text , char const   *showname ) 
{ 
  getline_ctx gl_ctx ;

  {
  {
#line 472
  gl_ctx.text = text;
#line 473
  readconfiggeneric(ads___7, showname, & gl_text, gl_ctx);
  }
#line 474
  return;
}
}
#line 476 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfigenv(adns_state ads___7 , char const   *envvar ) 
{ 
  char const   *filename ;

  {
#line 479
  if ((unsigned int )ads___7->iflags & 1U) {
    {
#line 480
    adns__debug(ads___7, -1, (adns_query )0, "not checking environment variable `%s\'",
                envvar);
    }
#line 481
    return;
  }
  {
#line 483
  filename = instrum_getenv(ads___7, envvar);
  }
#line 484
  if (filename) {
    {
#line 484
    readconfig(ads___7, filename, 1);
    }
  }
#line 485
  return;
}
}
#line 487 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfigenvtext(adns_state ads___7 , char const   *envvar ) 
{ 
  char const   *textdata ;

  {
#line 490
  if ((unsigned int )ads___7->iflags & 1U) {
    {
#line 491
    adns__debug(ads___7, -1, (adns_query )0, "not checking environment variable `%s\'",
                envvar);
    }
#line 492
    return;
  }
  {
#line 494
  textdata = instrum_getenv(ads___7, envvar);
  }
#line 495
  if (textdata) {
    {
#line 495
    readconfigtext(ads___7, textdata, envvar);
    }
  }
#line 496
  return;
}
}
#line 499 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
int adns__setnonblock(adns_state ads___7 , int fd ) 
{ 
  int r ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 502
  r = Hfcntl(fd, 3, 0);
  }
#line 502
  if (r < 0) {
    {
#line 502
    tmp = __errno_location();
    }
#line 502
    return (*tmp);
  }
  {
#line 503
  r |= 2048;
#line 504
  r = Hfcntl(fd, 4, r);
  }
#line 504
  if (r < 0) {
    {
#line 504
    tmp___0 = __errno_location();
    }
#line 504
    return (*tmp___0);
  }
#line 505
  return (0);
}
}
#line 508 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int init_begin(adns_state *ads_r , adns_initflags flags , adns_logcallbackfn *logfn ,
                      void *logfndata ) 
{ 
  adns_state ads___7 ;
  pid_t pid ;
  void *tmp ;
  int *tmp___0 ;
  adns_query tmp___1 ;
  adns_query tmp___2 ;
  adns_query tmp___3 ;
  adns_query tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __suseconds_t tmp___9 ;

  {
  {
#line 513
  tmp = Hmalloc(sizeof(*ads___7));
#line 513
  ads___7 = (adns_state )tmp;
  }
#line 513
  if (! ads___7) {
    {
#line 513
    tmp___0 = __errno_location();
    }
#line 513
    return (*tmp___0);
  }
  {
#line 515
  ads___7->iflags = flags;
#line 516
  ads___7->logfn = logfn;
#line 517
  ads___7->logfndata = logfndata;
#line 518
  ads___7->configerrno = 0;
#line 519
  tmp___1 = (adns_query )0;
#line 519
  ads___7->udpw.tail = tmp___1;
#line 519
  ads___7->udpw.head = tmp___1;
#line 520
  tmp___2 = (adns_query )0;
#line 520
  ads___7->tcpw.tail = tmp___2;
#line 520
  ads___7->tcpw.head = tmp___2;
#line 521
  tmp___3 = (adns_query )0;
#line 521
  ads___7->childw.tail = tmp___3;
#line 521
  ads___7->childw.head = tmp___3;
#line 522
  tmp___4 = (adns_query )0;
#line 522
  ads___7->output.tail = tmp___4;
#line 522
  ads___7->output.head = tmp___4;
#line 523
  ads___7->forallnext = (adns_query )0;
#line 524
  ads___7->nextid = 12575;
#line 525
  tmp___5 = -1;
#line 525
  ads___7->tcpsocket = tmp___5;
#line 525
  ads___7->udpsocket = tmp___5;
#line 526
  adns__vbuf_init(& ads___7->tcpsend);
#line 527
  adns__vbuf_init(& ads___7->tcprecv);
#line 528
  ads___7->tcprecv_skip = 0;
#line 529
  tmp___8 = 0;
#line 529
  ads___7->tcpserver = tmp___8;
#line 529
  tmp___7 = tmp___8;
#line 529
  ads___7->nsearchlist = tmp___7;
#line 529
  tmp___6 = tmp___7;
#line 529
  ads___7->nsortlist = tmp___6;
#line 529
  ads___7->nservers = tmp___6;
#line 530
  ads___7->searchndots = 1;
#line 531
  ads___7->tcpstate = (enum adns__tcpstate )0;
#line 532
  tmp___9 = (__suseconds_t )0;
#line 532
  ads___7->tcptimeout.tv_usec = tmp___9;
#line 532
  ads___7->tcptimeout.tv_sec = tmp___9;
#line 533
  ads___7->searchlist = (char **)0;
#line 535
  pid = Hgetpid();
#line 536
  ads___7->rand48xsubi[0] = (unsigned short )pid;
#line 537
  ads___7->rand48xsubi[1] = (unsigned short )((unsigned long )pid >> 16);
#line 538
  ads___7->rand48xsubi[2] = (unsigned short )((unsigned long )pid ^ ((unsigned long )pid >> 16));
#line 540
  *ads_r = ads___7;
  }
#line 541
  return (0);
}
}
#line 544 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int init_finish(adns_state ads___7 ) 
{ 
  struct in_addr ia ;
  struct protoent *proto ;
  int r ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 549
  if (! ads___7->nservers) {
#line 550
    if (ads___7->logfn) {
#line 550
      if ((unsigned int )ads___7->iflags & 8U) {
        {
#line 551
        adns__lprintf(ads___7, "adns: no nameservers, using localhost\n");
        }
      }
    }
    {
#line 552
    ia.s_addr = htonl((in_addr_t )2130706433);
#line 553
    addserver(ads___7, ia);
    }
  }
  {
#line 556
  proto = getprotobyname("udp");
  }
#line 556
  if (! proto) {
#line 556
    r = 92;
#line 556
    goto x_free;
  }
  {
#line 557
  ads___7->udpsocket = Hsocket(2, 2, proto->p_proto);
  }
#line 558
  if (ads___7->udpsocket < 0) {
    {
#line 558
    tmp = __errno_location();
#line 558
    r = *tmp;
    }
#line 558
    goto x_free;
  }
  {
#line 560
  r = adns__setnonblock(ads___7, ads___7->udpsocket);
  }
#line 561
  if (r) {
    {
#line 561
    tmp___0 = __errno_location();
#line 561
    r = *tmp___0;
    }
#line 561
    goto x_closeudp;
  }
#line 563
  return (0);
  x_closeudp: 
  {
#line 566
  Hclose(ads___7->udpsocket);
  }
  x_free: 
  {
#line 568
  Hfree((void *)ads___7);
  }
#line 569
  return (r);
}
}
#line 572 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void init_abort(adns_state ads___7 ) 
{ 


  {
#line 573
  if (ads___7->nsearchlist) {
    {
#line 574
    Hfree((void *)*(ads___7->searchlist + 0));
#line 575
    Hfree((void *)ads___7->searchlist);
    }
  }
  {
#line 577
  Hfree((void *)ads___7);
  }
#line 578
  return;
}
}
#line 580 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void logfn_file(adns_state ads___7 , void *logfndata , char const   *fmt ,
                       va_list al ) 
{ 


  {
  {
#line 582
  vfprintf((FILE */* __restrict  */)logfndata, (char const   */* __restrict  */)fmt,
           al);
  }
#line 583
  return;
}
}
#line 585 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int init_files(adns_state *ads_r , adns_initflags flags , adns_logcallbackfn *logfn ,
                      void *logfndata ) 
{ 
  adns_state ads___7 ;
  char const   *res_options ;
  char const   *adns_res_options ;
  int r ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 591
  r = init_begin(& ads___7, flags, logfn, logfndata);
  }
#line 592
  if (r) {
#line 592
    return (r);
  }
  {
#line 594
  res_options = instrum_getenv(ads___7, "RES_OPTIONS");
#line 595
  adns_res_options = instrum_getenv(ads___7, "ADNS_RES_OPTIONS");
#line 596
  ccf_options(ads___7, "RES_OPTIONS", -1, res_options);
#line 597
  ccf_options(ads___7, "ADNS_RES_OPTIONS", -1, adns_res_options);
#line 599
  readconfig(ads___7, "/etc/resolv.conf", 1);
#line 600
  readconfig(ads___7, "/etc/resolv-adns.conf", 0);
#line 601
  readconfigenv(ads___7, "RES_CONF");
#line 602
  readconfigenv(ads___7, "ADNS_RES_CONF");
#line 604
  readconfigenvtext(ads___7, "RES_CONF_TEXT");
#line 605
  readconfigenvtext(ads___7, "ADNS_RES_CONF_TEXT");
#line 607
  ccf_options(ads___7, "RES_OPTIONS", -1, res_options);
#line 608
  ccf_options(ads___7, "ADNS_RES_OPTIONS", -1, adns_res_options);
#line 610
  tmp = instrum_getenv(ads___7, "LOCALDOMAIN");
#line 610
  ccf_search(ads___7, "LOCALDOMAIN", -1, tmp);
#line 611
  tmp___0 = instrum_getenv(ads___7, "ADNS_LOCALDOMAIN");
#line 611
  ccf_search(ads___7, "ADNS_LOCALDOMAIN", -1, tmp___0);
  }
#line 613
  if (ads___7->configerrno) {
#line 613
    if (ads___7->configerrno != 22) {
      {
#line 614
      r = ads___7->configerrno;
#line 615
      init_abort(ads___7);
      }
#line 616
      return (r);
    }
  }
  {
#line 619
  r = init_finish(ads___7);
  }
#line 620
  if (r) {
#line 620
    return (r);
  }
  {
#line 622
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
#line 623
  *ads_r = ads___7;
  }
#line 624
  return (0);
}
}
#line 627 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
int adns_init(adns_state *ads_r , adns_initflags flags , FILE *diagfile ) 
{ 
  FILE *tmp ;
  int tmp___0 ;

  {
#line 628
  if (diagfile) {
#line 628
    tmp = diagfile;
  } else {
#line 628
    tmp = stderr;
  }
  {
#line 628
  tmp___0 = init_files(ads_r, flags, & logfn_file, (void *)tmp);
  }
#line 628
  return (tmp___0);
}
}
#line 631 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int init_strcfg(adns_state *ads_r , adns_initflags flags , adns_logcallbackfn *logfn ,
                       void *logfndata , char const   *configtext ) 
{ 
  adns_state ads___7 ;
  int r ;

  {
  {
#line 637
  r = init_begin(& ads___7, flags, logfn, logfndata);
  }
#line 638
  if (r) {
#line 638
    return (r);
  }
  {
#line 640
  readconfigtext(ads___7, configtext, "<supplied configuration text>");
  }
#line 641
  if (ads___7->configerrno) {
    {
#line 642
    r = ads___7->configerrno;
#line 643
    init_abort(ads___7);
    }
#line 644
    return (r);
  }
  {
#line 647
  r = init_finish(ads___7);
  }
#line 647
  if (r) {
#line 647
    return (r);
  }
  {
#line 648
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
#line 649
  *ads_r = ads___7;
  }
#line 650
  return (0);
}
}
#line 653 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
int adns_init_strcfg(adns_state *ads_r , adns_initflags flags , FILE *diagfile , char const   *configtext ) 
{ 
  void (*tmp)(adns_state ads , void *logfndata , char const   *fmt , va_list al ) ;
  int tmp___0 ;

  {
#line 655
  if (diagfile) {
#line 655
    tmp = & logfn_file;
  } else {
#line 655
    tmp = (void (*)(adns_state ads , void *logfndata , char const   *fmt , va_list al ))0;
  }
  {
#line 655
  tmp___0 = init_strcfg(ads_r, flags, tmp, (void *)diagfile, configtext);
  }
#line 655
  return (tmp___0);
}
}
#line 660 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
int adns_init_logfn(adns_state *newstate_r , adns_initflags flags , char const   *configtext ,
                    adns_logcallbackfn *logfn , void *logfndata ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 664
  if (! logfn) {
#line 664
    if (logfndata) {
#line 665
      logfn = & logfn_file;
    }
  }
#line 666
  if (configtext) {
    {
#line 667
    tmp = init_strcfg(newstate_r, flags, logfn, logfndata, configtext);
    }
#line 667
    return (tmp);
  } else {
    {
#line 669
    tmp___0 = init_files(newstate_r, flags, logfn, logfndata);
    }
#line 669
    return (tmp___0);
  }
}
}
#line 672 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
void adns_finish(adns_state ads___7 ) 
{ 


  {
  {
#line 673
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
  }
  {
#line 674
  while (1) {
    while_continue: /* CIL Label */ ;
#line 675
    if (ads___7->udpw.head) {
      {
#line 675
      adns_cancel(ads___7->udpw.head);
      }
    } else
#line 676
    if (ads___7->tcpw.head) {
      {
#line 676
      adns_cancel(ads___7->tcpw.head);
      }
    } else
#line 677
    if (ads___7->childw.head) {
      {
#line 677
      adns_cancel(ads___7->childw.head);
      }
    } else
#line 678
    if (ads___7->output.head) {
      {
#line 678
      adns_cancel(ads___7->output.head);
      }
    } else {
#line 679
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 681
  Hclose(ads___7->udpsocket);
  }
#line 682
  if (ads___7->tcpsocket >= 0) {
    {
#line 682
    Hclose(ads___7->tcpsocket);
    }
  }
  {
#line 683
  adns__vbuf_free(& ads___7->tcpsend);
#line 684
  adns__vbuf_free(& ads___7->tcprecv);
#line 685
  freesearchlist(ads___7);
#line 686
  Hfree((void *)ads___7);
  }
#line 687
  return;
}
}
#line 689 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
void adns_forallqueries_begin(adns_state ads___7 ) 
{ 
  adns_query tmp ;
  adns_query tmp___0 ;

  {
  {
#line 690
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
  }
#line 691
  if (ads___7->udpw.head) {
#line 691
    ads___7->forallnext = ads___7->udpw.head;
  } else {
#line 691
    if (ads___7->tcpw.head) {
#line 691
      tmp___0 = ads___7->tcpw.head;
    } else {
#line 691
      if (ads___7->childw.head) {
#line 691
        tmp = ads___7->childw.head;
      } else {
#line 691
        tmp = ads___7->output.head;
      }
#line 691
      tmp___0 = tmp;
    }
#line 691
    ads___7->forallnext = tmp___0;
  }
#line 696
  return;
}
}
#line 698 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
adns_query adns_forallqueries_next(adns_state ads___7 , void **context_r ) 
{ 
  adns_query qu ;
  adns_query nqu ;
  adns_query tmp ;

  {
  {
#line 701
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
#line 702
  nqu = ads___7->forallnext;
  }
  {
#line 703
  while (1) {
    while_continue: /* CIL Label */ ;
#line 704
    qu = nqu;
#line 705
    if (! qu) {
#line 705
      return ((adns_query )0);
    }
#line 706
    if (qu->next) {
#line 707
      nqu = qu->next;
    } else
#line 708
    if ((unsigned long )qu == (unsigned long )ads___7->udpw.tail) {
#line 709
      if (ads___7->tcpw.head) {
#line 709
        nqu = ads___7->tcpw.head;
      } else {
#line 709
        if (ads___7->childw.head) {
#line 709
          tmp = ads___7->childw.head;
        } else {
#line 709
          tmp = ads___7->output.head;
        }
#line 709
        nqu = tmp;
      }
    } else
#line 713
    if ((unsigned long )qu == (unsigned long )ads___7->tcpw.tail) {
#line 714
      if (ads___7->childw.head) {
#line 714
        nqu = ads___7->childw.head;
      } else {
#line 714
        nqu = ads___7->output.head;
      }
    } else
#line 717
    if ((unsigned long )qu == (unsigned long )ads___7->childw.tail) {
#line 718
      nqu = ads___7->output.head;
    } else {
#line 720
      nqu = (adns_query )0;
    }
#line 722
    if (! qu->parent) {
#line 722
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 724
  ads___7->forallnext = nqu;
#line 725
  if (context_r) {
#line 725
    *context_r = qu->ctx.ext;
  }
#line 726
  return (qu);
}
}
#line 535 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/adns.h"
int adns_synchronous(adns_state ads___7 , char const   *owner , adns_rrtype type ,
                     adns_queryflags flags , adns_answer **answer_r ) ;
#line 404 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/internal.h"
adns_status adns__mkquery(adns_state ads___7 , vbuf *vb___0 , int *id_r , char const   *owner ,
                          int ol , typeinfo const   *typei , adns_rrtype type , adns_queryflags flags ) ;
#line 437
adns_status adns__internal_submit(adns_state ads___7 , adns_query *query_r , typeinfo const   *typei ,
                                  vbuf *qumsg_vb , int id , adns_queryflags flags ,
                                  struct timeval now , qcontext const   *ctx ) ;
#line 466
void adns__search_next(adns_state ads___7 , adns_query qu , struct timeval now ) ;
#line 476
void *adns__alloc_interim(adns_query qu , size_t sz ) ;
#line 477
void *adns__alloc_preserved(adns_query qu , size_t sz ) ;
#line 500
void adns__transfer_interim(adns_query from , adns_query to , void *block , size_t sz ) ;
#line 515
void *adns__alloc_mine(adns_query qu , size_t sz ) ;
#line 521
void *adns__alloc_final(adns_query qu , size_t sz ) ;
#line 525
void adns__makefinal_block(adns_query qu , void **blpp , size_t sz ) ;
#line 526
void adns__makefinal_str(adns_query qu , char **strp ) ;
#line 528
void adns__reset_preserved(adns_query qu ) ;
#line 536
void adns__query_done(adns_query qu ) ;
#line 680
void adns__update_expires(adns_query qu , unsigned long ttl , struct timeval now ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static adns_query query_alloc(adns_state ads___7 , typeinfo const   *typei , adns_rrtype type ,
                              adns_queryflags flags , struct timeval now ) 
{ 
  adns_query qu ;
  void *tmp ;
  void *tmp___0 ;
  adns_query tmp___1 ;
  adns_query tmp___2 ;
  adns_query tmp___3 ;
  adns_query tmp___4 ;
  allocnode *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __suseconds_t tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 45
  tmp = Hmalloc(sizeof(*qu));
#line 45
  qu = (adns_query )tmp;
  }
#line 45
  if (! qu) {
#line 45
    return ((adns_query )0);
  }
  {
#line 46
  tmp___0 = Hmalloc(sizeof(*(qu->answer)));
#line 46
  qu->answer = (adns_answer *)tmp___0;
  }
#line 47
  if (! qu->answer) {
    {
#line 47
    Hfree((void *)qu);
    }
#line 47
    return ((adns_query )0);
  }
  {
#line 49
  qu->ads = ads___7;
#line 50
  qu->state = (enum __anonenum_state_83 )0;
#line 51
  tmp___2 = (adns_query )0;
#line 51
  qu->parent = tmp___2;
#line 51
  tmp___1 = tmp___2;
#line 51
  qu->next = tmp___1;
#line 51
  qu->back = tmp___1;
#line 52
  tmp___3 = (adns_query )0;
#line 52
  qu->children.tail = tmp___3;
#line 52
  qu->children.head = tmp___3;
#line 53
  tmp___4 = (adns_query )0;
#line 53
  qu->siblings.back = tmp___4;
#line 53
  qu->siblings.next = tmp___4;
#line 54
  tmp___5 = (allocnode *)0;
#line 54
  qu->allocations.tail = tmp___5;
#line 54
  qu->allocations.head = tmp___5;
#line 55
  qu->interim_allocd = 0;
#line 56
  qu->preserved_allocd = 0;
#line 57
  qu->final_allocspace = (void *)0;
#line 59
  qu->typei = typei;
#line 60
  qu->query_dgram = (byte *)0;
#line 61
  qu->query_dglen = 0;
#line 62
  adns__vbuf_init(& qu->vb);
#line 64
  qu->cname_dgram = (byte *)0;
#line 65
  tmp___6 = 0;
#line 65
  qu->cname_begin = tmp___6;
#line 65
  qu->cname_dglen = tmp___6;
#line 67
  adns__vbuf_init(& qu->search_vb);
#line 68
  tmp___8 = 0;
#line 68
  qu->search_doneabs = tmp___8;
#line 68
  tmp___7 = tmp___8;
#line 68
  qu->search_pos = tmp___7;
#line 68
  qu->search_origlen = tmp___7;
#line 70
  qu->id = -2;
#line 71
  qu->flags = (int )flags;
#line 72
  qu->retries = 0;
#line 73
  qu->udpnextserver = 0;
#line 74
  qu->udpsent = 0UL;
#line 75
  tmp___9 = (__suseconds_t )0;
#line 75
  qu->timeout.tv_usec = tmp___9;
#line 75
  qu->timeout.tv_sec = tmp___9;
#line 76
  qu->expires = now.tv_sec + 604800L;
#line 78
  memset((void *)(& qu->ctx), 0, sizeof(qu->ctx));
#line 80
  (qu->answer)->status = (adns_status )0;
#line 81
  tmp___10 = (char *)0;
#line 81
  (qu->answer)->owner = tmp___10;
#line 81
  (qu->answer)->cname = tmp___10;
#line 82
  (qu->answer)->type = type;
#line 83
  (qu->answer)->expires = (time_t )-1;
#line 84
  (qu->answer)->nrrs = 0;
#line 85
  (qu->answer)->rrs.untyped = (void *)0;
#line 86
  (qu->answer)->rrsz = (int )typei->rrsz;
  }
#line 88
  return (qu);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void query_submit(adns_state ads___7 , adns_query qu , typeinfo const   *typei ,
                         vbuf *qumsg_vb , int id , adns_queryflags flags , struct timeval now ) 
{ 
  void *tmp ;

  {
  {
#line 98
  qu->vb = *qumsg_vb;
#line 99
  adns__vbuf_init(qumsg_vb);
#line 101
  tmp = Hmalloc((size_t )qu->vb.used);
#line 101
  qu->query_dgram = (byte *)tmp;
  }
#line 102
  if (! qu->query_dgram) {
    {
#line 102
    adns__query_fail(qu, (adns_status )1);
    }
#line 102
    return;
  }
  {
#line 104
  qu->id = id;
#line 105
  qu->query_dglen = qu->vb.used;
#line 106
  memcpy((void */* __restrict  */)qu->query_dgram, (void const   */* __restrict  */)qu->vb.buf,
         (size_t )qu->vb.used);
#line 108
  adns__query_send(qu, now);
  }
#line 109
  return;
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
adns_status adns__internal_submit(adns_state ads___7 , adns_query *query_r , typeinfo const   *typei ,
                                  vbuf *qumsg_vb , int id , adns_queryflags flags ,
                                  struct timeval now , qcontext const   *ctx ) 
{ 
  adns_query qu ;

  {
  {
#line 118
  qu = query_alloc(ads___7, typei, (adns_rrtype )typei->typekey, flags, now);
  }
#line 119
  if (! qu) {
    {
#line 119
    adns__vbuf_free(qumsg_vb);
    }
#line 119
    return ((adns_status )1);
  }
  {
#line 120
  *query_r = qu;
#line 122
  memcpy((void */* __restrict  */)(& qu->ctx), (void const   */* __restrict  */)ctx,
         sizeof(qu->ctx));
#line 123
  query_submit(ads___7, qu, typei, qumsg_vb, id, flags, now);
  }
#line 125
  return ((adns_status )0);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void query_simple(adns_state ads___7 , adns_query qu , char const   *owner ,
                         int ol , typeinfo const   *typei , adns_queryflags flags ,
                         struct timeval now ) 
{ 
  vbuf vb_new ;
  int id ;
  adns_status stat ;

  {
  {
#line 136
  stat = adns__mkquery(ads___7, & qu->vb, & id, owner, ol, typei, (qu->answer)->type,
                       flags);
  }
#line 138
  if (stat) {
#line 139
    if ((unsigned int )stat == 202U) {
#line 139
      if ((unsigned int )flags & 1U) {
        {
#line 140
        adns__search_next(ads___7, qu, now);
        }
#line 141
        return;
      } else {
        {
#line 143
        adns__query_fail(qu, stat);
        }
#line 144
        return;
      }
    } else {
      {
#line 143
      adns__query_fail(qu, stat);
      }
#line 144
      return;
    }
  }
  {
#line 148
  vb_new = qu->vb;
#line 149
  adns__vbuf_init(& qu->vb);
#line 150
  query_submit(ads___7, qu, typei, & vb_new, id, flags, now);
  }
#line 151
  return;
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
void adns__search_next(adns_state ads___7 , adns_query qu , struct timeval now ) 
{ 
  char const   *nextentry ;
  adns_status stat ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 157
  if (qu->search_doneabs < 0) {
#line 158
    nextentry = (char const   *)0;
#line 159
    qu->search_doneabs = 1;
  } else
#line 161
  if (qu->search_pos >= ads___7->nsearchlist) {
#line 162
    if (qu->search_doneabs) {
#line 163
      qu->search_vb.used = qu->search_origlen;
#line 164
      stat = (adns_status )300;
#line 164
      goto x_fail;
    } else {
#line 166
      nextentry = (char const   *)0;
#line 167
      qu->search_doneabs = 1;
    }
  } else {
#line 170
    tmp = qu->search_pos;
#line 170
    (qu->search_pos) ++;
#line 170
    nextentry = (char const   *)*(ads___7->searchlist + tmp);
  }
#line 174
  qu->search_vb.used = qu->search_origlen;
#line 175
  if (nextentry) {
    {
#line 176
    tmp___0 = adns__vbuf_append(& qu->search_vb, (byte const   *)".", 1);
    }
#line 176
    if (tmp___0) {
      {
#line 176
      tmp___1 = adns__vbuf_appendstr(& qu->search_vb, nextentry);
      }
#line 176
      if (! tmp___1) {
#line 178
        goto x_nomemory;
      }
    } else {
#line 178
      goto x_nomemory;
    }
  }
  {
#line 181
  Hfree((void *)qu->query_dgram);
#line 182
  qu->query_dgram = (byte *)0;
#line 182
  qu->query_dglen = 0;
#line 184
  query_simple(ads___7, qu, (char const   *)qu->search_vb.buf, qu->search_vb.used,
               qu->typei, (adns_queryflags )qu->flags, now);
  }
#line 186
  return;
  x_nomemory: 
#line 189
  stat = (adns_status )1;
  x_fail: 
  {
#line 191
  adns__query_fail(qu, stat);
  }
#line 192
  return;
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static int save_owner(adns_query qu , char const   *owner , int ol ) 
{ 
  adns_answer *ans ;
  void *tmp ;

  {
#line 198
  if (! (qu->flags & 4)) {
#line 198
    return (1);
  }
#line 200
  ans = qu->answer;
#line 201
  if (! (! ans->owner)) {
    {
#line 201
    __assert_fail("!ans->owner", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c",
                  201U, "save_owner");
    }
  }
  {
#line 203
  tmp = adns__alloc_preserved(qu, (size_t )(ol + 1));
#line 203
  ans->owner = (char *)tmp;
  }
#line 203
  if (! ans->owner) {
#line 203
    return (0);
  }
  {
#line 205
  memcpy((void */* __restrict  */)ans->owner, (void const   */* __restrict  */)owner,
         (size_t )ol);
#line 206
  *(ans->owner + ol) = (char)0;
  }
#line 207
  return (1);
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
int adns_submit(adns_state ads___7 , char const   *owner , adns_rrtype type , adns_queryflags flags ,
                void *context , adns_query *query_r ) 
{ 
  int r ;
  int ol ;
  int ndots ;
  adns_status stat ;
  typeinfo const   *typei ;
  struct timeval now ;
  adns_query qu ;
  char const   *p ;
  size_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 223
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
#line 225
  typei = adns__findtype(type);
  }
#line 226
  if (! typei) {
#line 226
    return (38);
  }
  {
#line 228
  r = Hgettimeofday(& now, (struct timezone *)0);
  }
#line 228
  if (r) {
#line 228
    goto x_errno;
  }
  {
#line 229
  qu = query_alloc(ads___7, typei, type, flags, now);
  }
#line 229
  if (! qu) {
#line 229
    goto x_errno;
  }
  {
#line 231
  qu->ctx.ext = context;
#line 232
  qu->ctx.callback = (void (*)(adns_query parent , adns_query child ))0;
#line 233
  memset((void *)(& qu->ctx.info), 0, sizeof(qu->ctx.info));
#line 235
  *query_r = qu;
#line 237
  tmp = strlen(owner);
#line 237
  ol = (int )tmp;
  }
#line 238
  if (! ol) {
#line 238
    stat = (adns_status )201;
#line 238
    goto x_adnsfail;
  }
#line 239
  if (ol > 256) {
#line 239
    stat = (adns_status )202;
#line 239
    goto x_adnsfail;
  }
#line 241
  if (ol >= 1) {
#line 241
    if ((int const   )*(owner + (ol - 1)) == 46) {
#line 241
      if (ol < 2) {
#line 242
        flags = (adns_queryflags )((unsigned int )flags & 4294967294U);
#line 243
        qu->flags = (int )flags;
#line 244
        ol --;
      } else
#line 241
      if ((int const   )*(owner + (ol - 2)) != 92) {
#line 242
        flags = (adns_queryflags )((unsigned int )flags & 4294967294U);
#line 243
        qu->flags = (int )flags;
#line 244
        ol --;
      }
    }
  }
#line 247
  if ((unsigned int )flags & 1U) {
    {
#line 248
    r = adns__vbuf_append(& qu->search_vb, (byte const   *)owner, ol);
    }
#line 249
    if (! r) {
#line 249
      stat = (adns_status )1;
#line 249
      goto x_adnsfail;
    }
#line 251
    ndots = 0;
#line 251
    p = owner;
    {
#line 251
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 251
      tmp___0 = strchr(p, '.');
#line 251
      p = (char const   *)tmp___0;
      }
#line 251
      if (! p) {
#line 251
        goto while_break;
      }
#line 251
      p ++;
#line 251
      ndots ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 252
    if (ndots >= ads___7->searchndots) {
#line 252
      qu->search_doneabs = -1;
    } else {
#line 252
      qu->search_doneabs = 0;
    }
    {
#line 253
    qu->search_origlen = ol;
#line 254
    adns__search_next(ads___7, qu, now);
    }
  } else {
#line 256
    if ((unsigned int )flags & 4U) {
      {
#line 257
      tmp___1 = save_owner(qu, owner, ol);
      }
#line 257
      if (! tmp___1) {
#line 257
        stat = (adns_status )1;
#line 257
        goto x_adnsfail;
      }
    }
    {
#line 259
    query_simple(ads___7, qu, owner, ol, typei, flags, now);
    }
  }
  {
#line 261
  adns__autosys(ads___7, now);
#line 262
  adns__consistency(ads___7, qu, (consistency_checks )1);
  }
#line 263
  return (0);
  x_adnsfail: 
  {
#line 266
  adns__query_fail(qu, stat);
#line 267
  adns__consistency(ads___7, qu, (consistency_checks )1);
  }
#line 268
  return (0);
  x_errno: 
  {
#line 271
  tmp___2 = __errno_location();
#line 271
  r = *tmp___2;
  }
#line 272
  if (! r) {
    {
#line 272
    __assert_fail("r", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c",
                  272U, "adns_submit");
    }
  }
  {
#line 273
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
  }
#line 274
  return (r);
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
int adns_submit_reverse_any(adns_state ads___7 , struct sockaddr  const  *addr , char const   *zone ,
                            adns_rrtype type , adns_queryflags flags , void *context ,
                            adns_query *query_r ) 
{ 
  unsigned char const   *iaddr ;
  char *buf___17 ;
  char *buf_free ;
  char shortbuf[100] ;
  int r ;
  int lreq ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;

  {
#line 289
  flags = (adns_queryflags )((unsigned int )flags & 4294967294U);
#line 291
  if ((int const   )addr->sa_family != 2) {
#line 291
    return (38);
  }
  {
#line 292
  iaddr = (unsigned char const   *)(& ((struct sockaddr_in  const  *)addr)->sin_addr);
#line 295
  tmp = strlen(zone);
#line 295
  lreq = (int )((tmp + 16UL) + 1UL);
  }
#line 296
  if ((unsigned long )lreq > sizeof(shortbuf)) {
    {
#line 297
    tmp___0 = strlen(zone);
#line 297
    tmp___1 = Hmalloc((tmp___0 + 16UL) + 1UL);
#line 297
    buf___17 = (char *)tmp___1;
    }
#line 298
    if (! buf___17) {
      {
#line 298
      tmp___2 = __errno_location();
      }
#line 298
      return (*tmp___2);
    }
#line 299
    buf_free = buf___17;
  } else {
#line 301
    buf___17 = shortbuf;
#line 302
    buf_free = (char *)0;
  }
  {
#line 304
  sprintf((char */* __restrict  */)buf___17, (char const   */* __restrict  */)"%d.%d.%d.%d.%s",
          (int const   )*(iaddr + 3), (int const   )*(iaddr + 2), (int const   )*(iaddr + 1),
          (int const   )*(iaddr + 0), zone);
#line 306
  r = adns_submit(ads___7, (char const   *)buf___17, type, flags, context, query_r);
#line 307
  Hfree((void *)buf_free);
  }
#line 308
  return (r);
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
int adns_submit_reverse(adns_state ads___7 , struct sockaddr  const  *addr , adns_rrtype type ,
                        adns_queryflags flags , void *context , adns_query *query_r ) 
{ 
  int tmp ;

  {
#line 317
  if ((unsigned int )type != 65548U) {
#line 317
    if ((unsigned int )type != 12U) {
#line 317
      return (22);
    }
  }
  {
#line 318
  tmp = adns_submit_reverse_any(ads___7, addr, "in-addr.arpa", type, flags, context,
                                query_r);
  }
#line 318
  return (tmp);
}
}
#line 322 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
int adns_synchronous(adns_state ads___7 , char const   *owner , adns_rrtype type ,
                     adns_queryflags flags , adns_answer **answer_r ) 
{ 
  adns_query qu ;
  int r ;

  {
  {
#line 330
  r = adns_submit(ads___7, owner, type, flags, (void *)0, & qu);
  }
#line 331
  if (r) {
#line 331
    return (r);
  }
  {
#line 333
  r = adns_wait(ads___7, & qu, answer_r, (void **)0);
  }
#line 334
  if (r) {
    {
#line 334
    adns_cancel(qu);
    }
  }
#line 336
  return (r);
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void *alloc_common(adns_query qu , size_t sz ) 
{ 
  allocnode *an ;
  void *tmp ;

  {
#line 342
  if (! sz) {
#line 342
    return ((void *)qu);
  }
#line 343
  if (! (! qu->final_allocspace)) {
    {
#line 343
    __assert_fail("!qu->final_allocspace", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c",
                  343U, "alloc_common");
    }
  }
  {
#line 344
  tmp = Hmalloc((((((((sizeof(*an) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ) + sz) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ));
#line 344
  an = (allocnode *)tmp;
  }
#line 345
  if (! an) {
#line 345
    return ((void *)0);
  }
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 346
    an->next = (struct allocnode *)0;
#line 346
    an->back = qu->allocations.tail;
#line 346
    if (qu->allocations.tail) {
#line 346
      (qu->allocations.tail)->next = an;
    } else {
#line 346
      qu->allocations.head = an;
    }
#line 346
    qu->allocations.tail = an;
#line 346
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 347
  return ((void *)((byte *)an + (((sizeof(*an) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign )));
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
void *adns__alloc_interim(adns_query qu , size_t sz ) 
{ 
  void *rv ;

  {
  {
#line 353
  sz = (((sz + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign );
#line 354
  rv = alloc_common(qu, sz);
  }
#line 355
  if (! rv) {
#line 355
    return ((void *)0);
  }
#line 356
  qu->interim_allocd = (int )((size_t )qu->interim_allocd + sz);
#line 357
  return (rv);
}
}
#line 360 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
void *adns__alloc_preserved(adns_query qu , size_t sz ) 
{ 
  void *rv ;

  {
  {
#line 363
  sz = (((sz + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign );
#line 364
  rv = adns__alloc_interim(qu, sz);
  }
#line 365
  if (! rv) {
#line 365
    return ((void *)0);
  }
#line 366
  qu->preserved_allocd = (int )((size_t )qu->preserved_allocd + sz);
#line 367
  return (rv);
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
void *adns__alloc_mine(adns_query qu , size_t sz ) 
{ 
  void *tmp ;

  {
  {
#line 371
  tmp = alloc_common(qu, (((sz + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ));
  }
#line 371
  return (tmp);
}
}
#line 374 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
void adns__transfer_interim(adns_query from , adns_query to , void *block , size_t sz ) 
{ 
  allocnode *an ;

  {
#line 378
  if (! block) {
#line 378
    return;
  }
#line 379
  an = (allocnode *)((void *)((byte *)block - (((sizeof(*an) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign )));
#line 381
  if (! (! to->final_allocspace)) {
    {
#line 381
    __assert_fail("!to->final_allocspace", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c",
                  381U, "adns__transfer_interim");
    }
  }
#line 382
  if (! (! from->final_allocspace)) {
    {
#line 382
    __assert_fail("!from->final_allocspace", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c",
                  382U, "adns__transfer_interim");
    }
  }
  {
#line 384
  while (1) {
    while_continue: /* CIL Label */ ;
#line 384
    if (an->back) {
#line 384
      (an->back)->next = an->next;
    } else {
#line 384
      from->allocations.head = an->next;
    }
#line 384
    if (an->next) {
#line 384
      (an->next)->back = an->back;
    } else {
#line 384
      from->allocations.tail = an->back;
    }
#line 384
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 385
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 385
    an->next = (struct allocnode *)0;
#line 385
    an->back = to->allocations.tail;
#line 385
    if (to->allocations.tail) {
#line 385
      (to->allocations.tail)->next = an;
    } else {
#line 385
      to->allocations.head = an;
    }
#line 385
    to->allocations.tail = an;
#line 385
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 387
  sz = (((sz + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign );
#line 388
  from->interim_allocd = (int )((size_t )from->interim_allocd - sz);
#line 389
  to->interim_allocd = (int )((size_t )to->interim_allocd + sz);
#line 391
  if (to->expires > from->expires) {
#line 391
    to->expires = from->expires;
  }
#line 392
  return;
}
}
#line 394 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
void *adns__alloc_final(adns_query qu , size_t sz ) 
{ 
  void *rp ;

  {
#line 401
  sz = (((sz + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign );
#line 402
  rp = qu->final_allocspace;
#line 403
  if (! rp) {
    {
#line 403
    __assert_fail("rp", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c",
                  403U, "adns__alloc_final");
    }
  }
#line 404
  qu->interim_allocd = (int )((size_t )qu->interim_allocd - sz);
#line 405
  if (! (qu->interim_allocd >= 0)) {
    {
#line 405
    __assert_fail("qu->interim_allocd>=0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c",
                  405U, "adns__alloc_final");
    }
  }
#line 406
  qu->final_allocspace = (void *)((byte *)rp + sz);
#line 407
  return (rp);
}
}
#line 410 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void cancel_children(adns_query qu ) 
{ 
  adns_query cqu ;
  adns_query ncqu ;

  {
#line 413
  cqu = qu->children.head;
  {
#line 413
  while (1) {
    while_continue: /* CIL Label */ ;
#line 413
    if (! cqu) {
#line 413
      goto while_break;
    }
    {
#line 414
    ncqu = cqu->siblings.next;
#line 415
    adns_cancel(cqu);
#line 413
    cqu = ncqu;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 417
  return;
}
}
#line 419 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
void adns__reset_preserved(adns_query qu ) 
{ 


  {
#line 420
  if (! (! qu->final_allocspace)) {
    {
#line 420
    __assert_fail("!qu->final_allocspace", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c",
                  420U, "adns__reset_preserved");
    }
  }
  {
#line 421
  cancel_children(qu);
#line 422
  (qu->answer)->nrrs = 0;
#line 423
  (qu->answer)->rrs.untyped = (void *)0;
#line 424
  qu->interim_allocd = qu->preserved_allocd;
  }
#line 425
  return;
}
}
#line 427 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void free_query_allocs(adns_query qu ) 
{ 
  allocnode *an ;
  allocnode *ann ;
  allocnode *tmp ;

  {
  {
#line 430
  cancel_children(qu);
#line 431
  an = qu->allocations.head;
  }
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    if (! an) {
#line 431
      goto while_break;
    }
    {
#line 431
    ann = an->next;
#line 431
    Hfree((void *)an);
#line 431
    an = ann;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 432
  tmp = (allocnode *)0;
#line 432
  qu->allocations.tail = tmp;
#line 432
  qu->allocations.head = tmp;
#line 433
  adns__vbuf_free(& qu->vb);
#line 434
  adns__vbuf_free(& qu->search_vb);
#line 435
  Hfree((void *)qu->query_dgram);
#line 436
  qu->query_dgram = (byte *)0;
  }
#line 437
  return;
}
}
#line 439 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
void adns_cancel(adns_query qu ) 
{ 
  adns_state ads___7 ;

  {
  {
#line 442
  ads___7 = qu->ads;
#line 443
  adns__consistency(ads___7, qu, (consistency_checks )1);
  }
#line 444
  if (qu->parent) {
    {
#line 444
    while (1) {
      while_continue: /* CIL Label */ ;
#line 444
      if (qu->siblings.back) {
#line 444
        (qu->siblings.back)->siblings.next = qu->siblings.next;
      } else {
#line 444
        (qu->parent)->children.head = qu->siblings.next;
      }
#line 444
      if (qu->siblings.next) {
#line 444
        (qu->siblings.next)->siblings.back = qu->siblings.back;
      } else {
#line 444
        (qu->parent)->children.tail = qu->siblings.back;
      }
#line 444
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 446
  if ((unsigned int )qu->state == 0U) {
#line 446
    goto case_0;
  }
#line 449
  if ((unsigned int )qu->state == 1U) {
#line 449
    goto case_1;
  }
#line 452
  if ((unsigned int )qu->state == 2U) {
#line 452
    goto case_2;
  }
#line 455
  if ((unsigned int )qu->state == 3U) {
#line 455
    goto case_3;
  }
#line 458
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 447
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 447
    if (qu->back) {
#line 447
      (qu->back)->next = qu->next;
    } else {
#line 447
      ads___7->udpw.head = qu->next;
    }
#line 447
    if (qu->next) {
#line 447
      (qu->next)->back = qu->back;
    } else {
#line 447
      ads___7->udpw.tail = qu->back;
    }
#line 447
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 448
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 450
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 450
    if (qu->back) {
#line 450
      (qu->back)->next = qu->next;
    } else {
#line 450
      ads___7->tcpw.head = qu->next;
    }
#line 450
    if (qu->next) {
#line 450
      (qu->next)->back = qu->back;
    } else {
#line 450
      ads___7->tcpw.tail = qu->back;
    }
#line 450
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 451
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 453
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 453
    if (qu->back) {
#line 453
      (qu->back)->next = qu->next;
    } else {
#line 453
      ads___7->childw.head = qu->next;
    }
#line 453
    if (qu->next) {
#line 453
      (qu->next)->back = qu->back;
    } else {
#line 453
      ads___7->childw.tail = qu->back;
    }
#line 453
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 454
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 456
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 456
    if (qu->back) {
#line 456
      (qu->back)->next = qu->next;
    } else {
#line 456
      ads___7->output.head = qu->next;
    }
#line 456
    if (qu->next) {
#line 456
      (qu->next)->back = qu->back;
    } else {
#line 456
      ads___7->output.tail = qu->back;
    }
#line 456
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 457
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 459
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 461
  free_query_allocs(qu);
#line 462
  Hfree((void *)qu->answer);
#line 463
  Hfree((void *)qu);
#line 464
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
  }
#line 465
  return;
}
}
#line 467 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
void adns__update_expires(adns_query qu , unsigned long ttl , struct timeval now ) 
{ 
  time_t max ;

  {
#line 471
  if (! (ttl <= 604800UL)) {
    {
#line 471
    __assert_fail("ttl <= (7*86400)", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c",
                  471U, "adns__update_expires");
    }
  }
#line 472
  max = (time_t )((unsigned long )now.tv_sec + ttl);
#line 473
  if (qu->expires < max) {
#line 473
    return;
  }
#line 474
  qu->expires = max;
#line 475
  return;
}
}
#line 477 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void makefinal_query(adns_query qu ) 
{ 
  adns_answer *ans ;
  int rrn ;
  void *tmp ;

  {
#line 481
  ans = qu->answer;
#line 483
  if (qu->interim_allocd) {
    {
#line 484
    tmp = Hrealloc((void *)qu->answer, (((((((sizeof(*ans) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ) + (unsigned long )qu->interim_allocd) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ));
#line 484
    ans = (adns_answer *)tmp;
    }
#line 486
    if (! ans) {
#line 486
      goto x_nomem;
    }
#line 487
    qu->answer = ans;
  }
  {
#line 490
  qu->final_allocspace = (void *)((byte *)ans + (((sizeof(*ans) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ));
#line 491
  adns__makefinal_str(qu, & ans->cname);
#line 492
  adns__makefinal_str(qu, & ans->owner);
  }
#line 494
  if (ans->nrrs) {
    {
#line 495
    adns__makefinal_block(qu, & ans->rrs.untyped, (size_t )(ans->nrrs * ans->rrsz));
#line 497
    rrn = 0;
    }
    {
#line 497
    while (1) {
      while_continue: /* CIL Label */ ;
#line 497
      if (! (rrn < ans->nrrs)) {
#line 497
        goto while_break;
      }
      {
#line 498
      (*((qu->typei)->makefinal))(qu, (void *)(ans->rrs.bytes + rrn * ans->rrsz));
#line 497
      rrn ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 501
  free_query_allocs(qu);
  }
#line 502
  return;
  x_nomem: 
  {
#line 505
  qu->preserved_allocd = 0;
#line 506
  (qu->answer)->cname = (char *)0;
#line 507
  (qu->answer)->owner = (char *)0;
#line 508
  adns__reset_preserved(qu);
#line 510
  (qu->answer)->status = (adns_status )1;
#line 511
  free_query_allocs(qu);
  }
#line 512
  return;
}
}
#line 514 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
void adns__query_done(adns_query qu ) 
{ 
  adns_answer *ans ;
  adns_query parent ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 518
  cancel_children(qu);
#line 520
  qu->id = -1;
#line 521
  ans = qu->answer;
  }
#line 523
  if (qu->flags & 1) {
#line 523
    if ((unsigned int )ans->status != 1U) {
      {
#line 524
      tmp = save_owner(qu, (char const   *)qu->search_vb.buf, qu->search_vb.used);
      }
#line 524
      if (! tmp) {
        {
#line 525
        adns__query_fail(qu, (adns_status )1);
        }
#line 526
        return;
      }
    }
  }
#line 530
  if (ans->nrrs) {
#line 530
    if ((qu->typei)->diff_needswap) {
      {
#line 531
      tmp___0 = adns__vbuf_ensure(& qu->vb, (int )(qu->typei)->rrsz);
      }
#line 531
      if (! tmp___0) {
        {
#line 532
        adns__query_fail(qu, (adns_status )1);
        }
#line 533
        return;
      }
      {
#line 535
      adns__isort((void *)ans->rrs.bytes, ans->nrrs, ans->rrsz, (void *)qu->vb.buf,
                  (int (*)(void * , void const   * , void const   * ))(qu->typei)->diff_needswap,
                  (void *)qu->ads);
      }
    }
  }
#line 541
  if (ans->nrrs) {
#line 541
    if ((qu->typei)->postsort) {
      {
#line 542
      (*((qu->typei)->postsort))(qu->ads, (void *)ans->rrs.bytes, ans->nrrs, qu->typei);
      }
    }
  }
#line 545
  ans->expires = qu->expires;
#line 546
  parent = qu->parent;
#line 547
  if (parent) {
    {
#line 548
    while (1) {
      while_continue: /* CIL Label */ ;
#line 548
      if (qu->siblings.back) {
#line 548
        (qu->siblings.back)->siblings.next = qu->siblings.next;
      } else {
#line 548
        parent->children.head = qu->siblings.next;
      }
#line 548
      if (qu->siblings.next) {
#line 548
        (qu->siblings.next)->siblings.back = qu->siblings.back;
      } else {
#line 548
        parent->children.tail = qu->siblings.back;
      }
#line 548
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 549
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 549
      if (parent->back) {
#line 549
        (parent->back)->next = parent->next;
      } else {
#line 549
        (qu->ads)->childw.head = parent->next;
      }
#line 549
      if (parent->next) {
#line 549
        (parent->next)->back = parent->back;
      } else {
#line 549
        (qu->ads)->childw.tail = parent->back;
      }
#line 549
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 550
    (*(qu->ctx.callback))(parent, qu);
#line 551
    free_query_allocs(qu);
#line 552
    Hfree((void *)qu->answer);
#line 553
    Hfree((void *)qu);
    }
  } else {
    {
#line 555
    makefinal_query(qu);
    }
    {
#line 556
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 556
      qu->next = (adns_query )0;
#line 556
      qu->back = (qu->ads)->output.tail;
#line 556
      if ((qu->ads)->output.tail) {
#line 556
        ((qu->ads)->output.tail)->next = qu;
      } else {
#line 556
        (qu->ads)->output.head = qu;
      }
#line 556
      (qu->ads)->output.tail = qu;
#line 556
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 557
    qu->state = (enum __anonenum_state_83 )3;
  }
#line 559
  return;
}
}
#line 561 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
void adns__query_fail(adns_query qu , adns_status stat ) 
{ 


  {
  {
#line 562
  adns__reset_preserved(qu);
#line 563
  (qu->answer)->status = stat;
#line 564
  adns__query_done(qu);
  }
#line 565
  return;
}
}
#line 567 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
void adns__makefinal_str(adns_query qu , char **strp ) 
{ 
  int l ;
  char *before ;
  char *after ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 571
  before = *strp;
#line 572
  if (! before) {
#line 572
    return;
  }
  {
#line 573
  tmp = strlen((char const   *)before);
#line 573
  l = (int )(tmp + 1UL);
#line 574
  tmp___0 = adns__alloc_final(qu, (size_t )l);
#line 574
  after = (char *)tmp___0;
#line 575
  memcpy((void */* __restrict  */)after, (void const   */* __restrict  */)before,
         (size_t )l);
#line 576
  *strp = after;
  }
#line 577
  return;
}
}
#line 579 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
void adns__makefinal_block(adns_query qu , void **blpp , size_t sz ) 
{ 
  void *before ;
  void *after ;

  {
#line 582
  before = *blpp;
#line 583
  if (! before) {
#line 583
    return;
  }
  {
#line 584
  after = adns__alloc_final(qu, sz);
#line 585
  memcpy((void */* __restrict  */)after, (void const   */* __restrict  */)before,
         sz);
#line 586
  *blpp = after;
  }
#line 587
  return;
}
}
#line 394 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) nrand48)(unsigned short *__xsubi ) ;
#line 96 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 169 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/internal.h"
adns_status adns__qdpl_normal(adns_state ads___7 , char const   **p_io , char const   *pe ,
                              int labelnum , char *label_r , int *ll_io , adns_queryflags flags ,
                              typeinfo const   *typei ) ;
#line 411
adns_status adns__mkquery_frdgram(adns_state ads___7 , vbuf *vb___0 , int *id_r ,
                                  byte const   *qd_dgram , int qd_dglen , int qd_begin ,
                                  adns_rrtype type , adns_queryflags flags ) ;
#line 735 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/internal.h"
__inline static int ctype_822special(int c ) 
{ 
  char *tmp ;

  {
  {
#line 736
  tmp = strchr("()<>@,;:\\\".[]", c);
  }
#line 736
  return ((unsigned long )tmp != (unsigned long )((char *)0));
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_qstring(parseinfo const   *pai , int *cbyte_io , int max ,
                               int *len_r , char **str_r ) 
{ 
  byte const   *dgram ;
  int l ;
  int cbyte___3 ;
  char *str ;
  int tmp ;
  void *tmp___0 ;

  {
#line 92
  dgram = (byte const   *)pai->dgram;
#line 96
  cbyte___3 = *cbyte_io;
#line 98
  if (cbyte___3 >= max) {
#line 98
    return ((adns_status )104);
  }
#line 99
  tmp = cbyte___3;
#line 99
  cbyte___3 ++;
#line 99
  l = (int )((int const   )*(dgram + tmp) & 255);
#line 100
  if (cbyte___3 + l > max) {
#line 100
    return ((adns_status )104);
  }
  {
#line 102
  tmp___0 = adns__alloc_interim((adns_query )pai->qu, (size_t )(l + 1));
#line 102
  str = (char *)tmp___0;
  }
#line 103
  if (! str) {
#line 103
    return ((adns_status )1);
  }
  {
#line 105
  *(str + l) = (char)0;
#line 106
  memcpy((void */* __restrict  */)str, (void const   */* __restrict  */)(dgram + cbyte___3),
         (size_t )l);
#line 108
  *len_r = l;
#line 109
  *str_r = str;
#line 110
  *cbyte_io = cbyte___3 + l;
  }
#line 112
  return ((adns_status )0);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_qstring(vbuf *vb___0 , char const   *dp , int len ) 
{ 
  unsigned char ch ;
  char buf___17[10] ;
  int cn ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 120
    tmp = adns__vbuf_appendstr(vb___0, "\"");
    }
#line 120
    if (! tmp) {
#line 120
      return ((adns_status )1);
    }
#line 120
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  cn = 0;
  {
#line 121
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 121
    if (! (cn < len)) {
#line 121
      goto while_break___0;
    }
#line 122
    tmp___0 = dp;
#line 122
    dp ++;
#line 122
    ch = (unsigned char )*tmp___0;
#line 123
    if ((int )ch == 92) {
      {
#line 124
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 124
        tmp___1 = adns__vbuf_appendstr(vb___0, "\\\\");
        }
#line 124
        if (! tmp___1) {
#line 124
          return ((adns_status )1);
        }
#line 124
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else
#line 125
    if ((int )ch == 34) {
      {
#line 126
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 126
        tmp___2 = adns__vbuf_appendstr(vb___0, "\\\"");
        }
#line 126
        if (! tmp___2) {
#line 126
          return ((adns_status )1);
        }
#line 126
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else
#line 127
    if ((int )ch >= 32) {
#line 127
      if ((int )ch <= 126) {
        {
#line 128
        tmp___3 = adns__vbuf_append(vb___0, (byte const   *)(& ch), 1);
        }
#line 128
        if (! tmp___3) {
#line 128
          return ((adns_status )1);
        }
      } else {
#line 127
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 130
      sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"\\x%02x",
              (int )ch);
      }
      {
#line 131
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 131
        tmp___4 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
        }
#line 131
        if (! tmp___4) {
#line 131
          return ((adns_status )1);
        }
#line 131
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 121
    cn ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 134
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 134
    tmp___5 = adns__vbuf_appendstr(vb___0, "\"");
    }
#line 134
    if (! tmp___5) {
#line 134
      return ((adns_status )1);
    }
#line 134
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 136
  return ((adns_status )0);
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_str(adns_query qu , void *datap ) 
{ 
  char **rrp ;

  {
  {
#line 144
  rrp = (char **)datap;
#line 146
  adns__makefinal_str(qu, rrp);
  }
#line 147
  return;
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_intstr(adns_query qu , void *datap ) 
{ 
  adns_rr_intstr *rrp ;

  {
  {
#line 154
  rrp = (adns_rr_intstr *)datap;
#line 156
  adns__makefinal_str(qu, & rrp->str);
  }
#line 157
  return;
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_manyistr(adns_query qu , void *datap ) 
{ 
  adns_rr_intstr **rrp ;
  adns_rr_intstr *te ;
  adns_rr_intstr *table ;
  void *tablev ;
  int tc ;

  {
#line 164
  rrp = (adns_rr_intstr **)datap;
#line 169
  tc = 0;
#line 169
  te = *rrp;
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    if (! (te->i >= 0)) {
#line 169
      goto while_break;
    }
#line 169
    te ++;
#line 169
    tc ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 170
  tablev = (void *)*rrp;
#line 171
  adns__makefinal_block(qu, & tablev, sizeof(*te) * (unsigned long )(tc + 1));
#line 172
  table = (adns_rr_intstr *)tablev;
#line 172
  *rrp = table;
#line 173
  te = *rrp;
  }
  {
#line 173
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 173
    if (! (te->i >= 0)) {
#line 173
      goto while_break___0;
    }
    {
#line 174
    adns__makefinal_str(qu, & te->str);
#line 173
    te ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 175
  return;
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_txt(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  adns_rr_intstr **rrp ;
  adns_rr_intstr *table ;
  adns_rr_intstr *te ;
  byte const   *dgram ;
  int ti ;
  int tc ;
  int l ;
  int startbyte ;
  adns_status st ;
  int tmp ;
  void *tmp___0 ;

  {
#line 183
  rrp = (adns_rr_intstr **)datap;
#line 184
  dgram = (byte const   *)pai->dgram;
#line 188
  startbyte = cbyte___3;
#line 189
  if (cbyte___3 >= max) {
#line 189
    return ((adns_status )104);
  }
#line 190
  tc = 0;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! (cbyte___3 < max)) {
#line 191
      goto while_break;
    }
#line 192
    tmp = cbyte___3;
#line 192
    cbyte___3 ++;
#line 192
    l = (int )((int const   )*(dgram + tmp) & 255);
#line 193
    cbyte___3 += l;
#line 194
    tc ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  if (cbyte___3 != max) {
#line 196
    return ((adns_status )104);
  } else
#line 196
  if (! tc) {
#line 196
    return ((adns_status )104);
  }
  {
#line 198
  tmp___0 = adns__alloc_interim((adns_query )pai->qu, sizeof(*table) * (unsigned long )(tc + 1));
#line 198
  table = (adns_rr_intstr *)tmp___0;
  }
#line 199
  if (! table) {
#line 199
    return ((adns_status )1);
  }
#line 201
  cbyte___3 = startbyte;
#line 201
  ti = 0;
#line 201
  te = table;
  {
#line 201
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 201
    if (! (ti < tc)) {
#line 201
      goto while_break___0;
    }
    {
#line 202
    st = pap_qstring(pai, & cbyte___3, max, & te->i, & te->str);
    }
#line 203
    if (st) {
#line 203
      return (st);
    }
#line 201
    ti ++;
#line 201
    te ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 205
  if (! (cbyte___3 == max)) {
    {
#line 205
    __assert_fail("cbyte == max", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  205U, "pa_txt");
    }
  }
#line 207
  te->i = -1;
#line 208
  te->str = (char *)0;
#line 210
  *rrp = table;
#line 211
  return ((adns_status )0);
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_txt(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_intstr const   * const  *rrp ;
  adns_rr_intstr const   *current ;
  adns_status st ;
  int spc ;
  int tmp ;

  {
#line 215
  rrp = (adns_rr_intstr const   * const  *)datap;
#line 220
  current = (adns_rr_intstr const   *)*rrp;
#line 220
  spc = 0;
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    if (! (current->i >= 0)) {
#line 220
      goto while_break;
    }
#line 221
    if (spc) {
      {
#line 221
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 221
        tmp = adns__vbuf_appendstr(vb___0, " ");
        }
#line 221
        if (! tmp) {
#line 221
          return ((adns_status )1);
        }
#line 221
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 222
    st = csp_qstring(vb___0, (char const   *)current->str, (int )current->i);
    }
#line 222
    if (st) {
#line 222
      return (st);
    }
#line 220
    current ++;
#line 220
    spc = 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  return ((adns_status )0);
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_hinfo(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_intstrpair const   *rrp ;
  adns_status st ;
  int tmp ;

  {
  {
#line 232
  rrp = (adns_rr_intstrpair const   *)datap;
#line 235
  st = csp_qstring(vb___0, (char const   *)rrp->array[0].str, (int )rrp->array[0].i);
  }
#line 235
  if (st) {
#line 235
    return (st);
  }
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 236
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 236
    if (! tmp) {
#line 236
      return ((adns_status )1);
    }
#line 236
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 237
  st = csp_qstring(vb___0, (char const   *)rrp->array[1].str, (int )rrp->array[1].i);
  }
#line 237
  if (st) {
#line 237
    return (st);
  }
#line 238
  return ((adns_status )0);
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_inaddr(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  struct in_addr *storeto ;

  {
#line 247
  storeto = (struct in_addr *)datap;
#line 249
  if (max - cbyte___3 != 4) {
#line 249
    return ((adns_status )104);
  }
  {
#line 250
  memcpy((void */* __restrict  */)storeto, (void const   */* __restrict  */)(pai->dgram + cbyte___3),
         (size_t )4);
  }
#line 251
  return ((adns_status )0);
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int search_sortlist(adns_state ads___7 , struct in_addr ad ) 
{ 
  struct sortlist  const  *slp ;
  int i ;

  {
#line 258
  i = 0;
#line 258
  slp = (struct sortlist  const  *)(ads___7->sortlist);
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 258
    if (i < ads___7->nsortlist) {
#line 258
      if (! (! ((ad.s_addr & (unsigned int )slp->mask.s_addr) == (unsigned int )slp->base.s_addr))) {
#line 258
        goto while_break;
      }
    } else {
#line 258
      goto while_break;
    }
#line 258
    i ++;
#line 258
    slp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  return (i);
}
}
#line 265 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int dip_inaddr(adns_state ads___7 , struct in_addr a , struct in_addr b ) 
{ 
  int ai ;
  int bi ;

  {
#line 268
  if (! ads___7->nsortlist) {
#line 268
    return (0);
  }
  {
#line 270
  ai = search_sortlist(ads___7, a);
#line 271
  bi = search_sortlist(ads___7, b);
  }
#line 272
  return (bi < ai);
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_inaddr(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  struct in_addr  const  *ap ;
  struct in_addr  const  *bp ;
  int tmp ;

  {
  {
#line 277
  ap = (struct in_addr  const  *)datap_a;
#line 277
  bp = (struct in_addr  const  *)datap_b;
#line 279
  tmp = dip_inaddr(ads___7, (struct in_addr )*ap, (struct in_addr )*bp);
  }
#line 279
  return (tmp);
}
}
#line 282 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_inaddr(vbuf *vb___0 , void const   *datap ) 
{ 
  struct in_addr  const  *rrp ;
  struct in_addr rr ;
  char const   *ia ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 283
  rrp = (struct in_addr  const  *)datap;
#line 283
  rr = *rrp;
#line 286
  tmp = inet_ntoa(rr);
#line 286
  ia = (char const   *)tmp;
  }
#line 286
  if (! ia) {
    {
#line 286
    __assert_fail("ia", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  286U, "cs_inaddr");
    }
  }
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 287
    tmp___0 = adns__vbuf_appendstr(vb___0, ia);
    }
#line 287
    if (! tmp___0) {
#line 287
      return ((adns_status )1);
    }
#line 287
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  return ((adns_status )0);
}
}
#line 295 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_addr(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  adns_rr_addr *storeto ;
  byte const   *dgram ;

  {
#line 297
  storeto = (adns_rr_addr *)datap;
#line 298
  dgram = (byte const   *)pai->dgram;
#line 300
  if (max - cbyte___3 != 4) {
#line 300
    return ((adns_status )104);
  }
  {
#line 301
  storeto->len = (int )sizeof(storeto->addr.inet);
#line 302
  memset((void *)(& storeto->addr), 0, sizeof(storeto->addr.inet));
#line 303
  storeto->addr.inet.sin_family = (sa_family_t )2;
#line 304
  memcpy((void */* __restrict  */)(& storeto->addr.inet.sin_addr), (void const   */* __restrict  */)(dgram + cbyte___3),
         (size_t )4);
  }
#line 305
  return ((adns_status )0);
}
}
#line 308 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_addr(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_addr const   *ap ;
  adns_rr_addr const   *bp ;
  int tmp ;

  {
#line 309
  ap = (adns_rr_addr const   *)datap_a;
#line 309
  bp = (adns_rr_addr const   *)datap_b;
#line 311
  if (! ((int const   )ap->addr.sa.sa_family == 2)) {
    {
#line 311
    __assert_fail("ap->addr.sa.sa_family == 2", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  311U, "di_addr");
    }
  }
  {
#line 312
  tmp = dip_inaddr(ads___7, (struct in_addr )ap->addr.inet.sin_addr, (struct in_addr )bp->addr.inet.sin_addr);
  }
#line 312
  return (tmp);
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int div_addr(void *context , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_state ads___7 ;
  int tmp ;

  {
  {
#line 316
  ads___7 = (adns_state )context;
#line 318
  tmp = di_addr(ads___7, datap_a, datap_b);
  }
#line 318
  return (tmp);
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_addr(vbuf *vb___0 , adns_rr_addr const   *rrp ) 
{ 
  char const   *ia ;
  char buf___17[30] ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 326
  if ((int const   )rrp->addr.inet.sin_family == 2) {
#line 326
    goto case_2;
  }
#line 331
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 327
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 327
    tmp = adns__vbuf_appendstr(vb___0, "INET ");
    }
#line 327
    if (! tmp) {
#line 327
      return ((adns_status )1);
    }
#line 327
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 328
  tmp___0 = inet_ntoa((struct in_addr )rrp->addr.inet.sin_addr);
#line 328
  ia = (char const   *)tmp___0;
  }
#line 328
  if (! ia) {
    {
#line 328
    __assert_fail("ia", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  328U, "csp_addr");
    }
  }
  {
#line 329
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 329
    tmp___1 = adns__vbuf_appendstr(vb___0, ia);
    }
#line 329
    if (! tmp___1) {
#line 329
      return ((adns_status )1);
    }
#line 329
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 330
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 332
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"AF=%u",
          (int const   )rrp->addr.sa.sa_family);
  }
  {
#line 333
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 333
    tmp___2 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 333
    if (! tmp___2) {
#line 333
      return ((adns_status )1);
    }
#line 333
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 334
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 336
  return ((adns_status )0);
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_addr(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_addr const   *rrp ;
  adns_status tmp ;

  {
  {
#line 340
  rrp = (adns_rr_addr const   *)datap;
#line 342
  tmp = csp_addr(vb___0, rrp);
  }
#line 342
  return (tmp);
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_domain(parseinfo const   *pai , int *cbyte_io , int max , char **domain_r ,
                              parsedomain_flags flags ) 
{ 
  adns_status st ;
  char *dm ;
  void *tmp ;

  {
  {
#line 355
  st = adns__parse_domain((pai->qu)->ads, (int )pai->serv, (adns_query )pai->qu, & (pai->qu)->vb,
                          flags, (byte const   *)pai->dgram, (int )pai->dglen, cbyte_io,
                          max);
  }
#line 357
  if (st) {
#line 357
    return (st);
  }
#line 358
  if (! (pai->qu)->vb.used) {
#line 358
    return ((adns_status )104);
  }
  {
#line 360
  tmp = adns__alloc_interim((adns_query )pai->qu, (size_t )((pai->qu)->vb.used + 1));
#line 360
  dm = (char *)tmp;
  }
#line 361
  if (! dm) {
#line 361
    return ((adns_status )1);
  }
  {
#line 363
  *(dm + (pai->qu)->vb.used) = (char)0;
#line 364
  memcpy((void */* __restrict  */)dm, (void const   */* __restrict  */)(pai->qu)->vb.buf,
         (size_t )(pai->qu)->vb.used);
#line 366
  *domain_r = dm;
  }
#line 367
  return ((adns_status )0);
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_domain(vbuf *vb___0 , char const   *domain ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 371
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 371
    tmp = adns__vbuf_appendstr(vb___0, domain);
    }
#line 371
    if (! tmp) {
#line 371
      return ((adns_status )1);
    }
#line 371
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 372
  if (! *domain) {
    {
#line 372
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 372
      tmp___0 = adns__vbuf_appendstr(vb___0, ".");
      }
#line 372
      if (! tmp___0) {
#line 372
        return ((adns_status )1);
      }
#line 372
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 373
  return ((adns_status )0);
}
}
#line 376 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_domain(vbuf *vb___0 , void const   *datap ) 
{ 
  char const   * const  *domainp ;
  adns_status tmp ;

  {
  {
#line 377
  domainp = (char const   * const  *)datap;
#line 378
  tmp = csp_domain(vb___0, (char const   *)*domainp);
  }
#line 378
  return (tmp);
}
}
#line 381 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_dom_raw(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  char **rrp ;
  adns_status st ;

  {
  {
#line 383
  rrp = (char **)datap;
#line 386
  st = pap_domain(pai, & cbyte___3, max, rrp, (parsedomain_flags )1);
  }
#line 387
  if (st) {
#line 387
    return (st);
  }
#line 389
  if (cbyte___3 != max) {
#line 389
    return ((adns_status )104);
  }
#line 390
  return ((adns_status )0);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_host_raw(parseinfo const   *pai , int cbyte___3 , int max ,
                               void *datap ) 
{ 
  char **rrp ;
  adns_status st ;
  int tmp ;

  {
#line 399
  rrp = (char **)datap;
#line 402
  if ((pai->qu)->flags & 64) {
#line 402
    tmp = 1;
  } else {
#line 402
    tmp = 0;
  }
  {
#line 402
  st = pap_domain(pai, & cbyte___3, max, rrp, (parsedomain_flags )tmp);
  }
#line 404
  if (st) {
#line 404
    return (st);
  }
#line 406
  if (cbyte___3 != max) {
#line 406
    return ((adns_status )104);
  }
#line 407
  return ((adns_status )0);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_findaddrs(parseinfo const   *pai , adns_rr_hostaddr *ha , int *cbyte_io ,
                                 int count , int dmstart ) 
{ 
  int rri ;
  int naddrs ;
  int type ;
  int class ;
  int rdlen ;
  int rdstart ;
  int ownermatched ;
  unsigned long ttl ;
  adns_status st ;
  int tmp ;
  void *tmp___0 ;

  {
#line 421
  rri = 0;
#line 421
  naddrs = -1;
  {
#line 421
  while (1) {
    while_continue: /* CIL Label */ ;
#line 421
    if (! (rri < count)) {
#line 421
      goto while_break;
    }
    {
#line 422
    st = adns__findrr_anychk((adns_query )pai->qu, (int )pai->serv, (byte const   *)pai->dgram,
                             (int )pai->dglen, cbyte_io, & type, & class, & ttl, & rdlen,
                             & rdstart, (byte const   *)pai->dgram, (int )pai->dglen,
                             dmstart, & ownermatched);
    }
#line 426
    if (st) {
#line 426
      return (st);
    }
#line 427
    if (! ownermatched) {
#line 427
      goto _L;
    } else
#line 427
    if (class != 1) {
#line 427
      goto _L;
    } else
#line 427
    if (type != 1) {
      _L: /* CIL Label */ 
#line 428
      if (naddrs > 0) {
#line 428
        goto while_break;
      } else {
#line 428
        goto __Cont;
      }
    }
#line 430
    if (naddrs == -1) {
#line 431
      naddrs = 0;
    }
    {
#line 433
    tmp = adns__vbuf_ensure(& (pai->qu)->vb, (int )((unsigned long )(naddrs + 1) * sizeof(adns_rr_addr )));
    }
#line 433
    if (! tmp) {
#line 434
      return ((adns_status )1);
    }
    {
#line 435
    adns__update_expires((adns_query )pai->qu, ttl, (struct timeval )pai->now);
#line 436
    st = pa_addr(pai, rdstart, rdstart + rdlen, (void *)((pai->qu)->vb.buf + (unsigned long )naddrs * sizeof(adns_rr_addr )));
    }
#line 438
    if (st) {
#line 438
      return (st);
    }
#line 439
    naddrs ++;
    __Cont: /* CIL Label */ 
#line 421
    rri ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 441
  if (naddrs >= 0) {
    {
#line 442
    tmp___0 = adns__alloc_interim((adns_query )pai->qu, (unsigned long )naddrs * sizeof(adns_rr_addr ));
#line 442
    ha->addrs = (adns_rr_addr *)tmp___0;
    }
#line 443
    if (! ha->addrs) {
#line 443
      return ((adns_status )1);
    }
    {
#line 444
    memcpy((void */* __restrict  */)ha->addrs, (void const   */* __restrict  */)(pai->qu)->vb.buf,
           (unsigned long )naddrs * sizeof(adns_rr_addr ));
#line 445
    ha->naddrs = naddrs;
#line 446
    ha->astatus = (adns_status )0;
#line 448
    adns__isort((void *)ha->addrs, naddrs, (int )sizeof(adns_rr_addr ), (void *)(pai->qu)->vb.buf,
                & div_addr, (void *)pai->ads);
    }
  }
#line 451
  return ((adns_status )0);
}
}
#line 454 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void icb_hostaddr(adns_query parent , adns_query child ) 
{ 
  adns_answer *cans ;
  adns_rr_hostaddr *rrp ;
  adns_state ads___7 ;
  adns_status st ;

  {
#line 455
  cans = child->answer;
#line 456
  rrp = child->ctx.info.hostaddr;
#line 457
  ads___7 = parent->ads;
#line 460
  st = cans->status;
#line 461
  rrp->astatus = st;
#line 462
  if ((unsigned int )st > 0U) {
#line 462
    if ((unsigned int )st <= 99U) {
#line 462
      rrp->naddrs = -1;
    } else {
#line 462
      rrp->naddrs = cans->nrrs;
    }
  } else {
#line 462
    rrp->naddrs = cans->nrrs;
  }
  {
#line 463
  rrp->addrs = cans->rrs.addr;
#line 464
  adns__transfer_interim(child, parent, (void *)rrp->addrs, (unsigned long )rrp->naddrs * sizeof(adns_rr_addr ));
  }
#line 467
  if (parent->children.head) {
    {
#line 468
    while (1) {
      while_continue: /* CIL Label */ ;
#line 468
      parent->next = (adns_query )0;
#line 468
      parent->back = ads___7->childw.tail;
#line 468
      if (ads___7->childw.tail) {
#line 468
        (ads___7->childw.tail)->next = parent;
      } else {
#line 468
        ads___7->childw.head = parent;
      }
#line 468
      ads___7->childw.tail = parent;
#line 468
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 470
    adns__query_done(parent);
    }
  }
#line 472
  return;
}
}
#line 474 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_hostaddr(parseinfo const   *pai , int *cbyte_io , int max ,
                                adns_rr_hostaddr *rrp ) 
{ 
  adns_status st ;
  int dmstart ;
  int cbyte___3 ;
  qcontext ctx ;
  int id ;
  adns_query nqu ;
  adns_queryflags nflags ;
  int tmp ;
  typeinfo const   *tmp___0 ;

  {
#line 483
  cbyte___3 = *cbyte_io;
#line 483
  dmstart = cbyte___3;
#line 484
  if ((pai->qu)->flags & 64) {
#line 484
    tmp = 1;
  } else {
#line 484
    tmp = 0;
  }
  {
#line 484
  st = pap_domain(pai, & cbyte___3, max, & rrp->host, (parsedomain_flags )tmp);
  }
#line 486
  if (st) {
#line 486
    return (st);
  }
  {
#line 487
  *cbyte_io = cbyte___3;
#line 489
  rrp->astatus = (adns_status )0;
#line 490
  rrp->naddrs = -1;
#line 491
  rrp->addrs = (adns_rr_addr *)0;
#line 493
  cbyte___3 = (int )pai->nsstart;
#line 495
  st = pap_findaddrs(pai, rrp, & cbyte___3, (int )pai->nscount, dmstart);
  }
#line 496
  if (st) {
#line 496
    return (st);
  }
#line 497
  if (rrp->naddrs != -1) {
#line 497
    return ((adns_status )0);
  }
  {
#line 499
  st = pap_findaddrs(pai, rrp, & cbyte___3, (int )pai->arcount, dmstart);
  }
#line 500
  if (st) {
#line 500
    return (st);
  }
#line 501
  if (rrp->naddrs != -1) {
#line 501
    return ((adns_status )0);
  }
  {
#line 503
  st = adns__mkquery_frdgram((adns_state )pai->ads, & (pai->qu)->vb, & id, (byte const   *)pai->dgram,
                             (int )pai->dglen, dmstart, (adns_rrtype )65537, (adns_queryflags )16);
  }
#line 506
  if (st) {
#line 506
    return (st);
  }
#line 508
  ctx.ext = (void *)0;
#line 509
  ctx.callback = & icb_hostaddr;
#line 510
  ctx.info.hostaddr = rrp;
#line 512
  nflags = (adns_queryflags )16;
#line 513
  if (! ((pai->qu)->flags & 256)) {
#line 513
    nflags = (adns_queryflags )((unsigned int )nflags | 512U);
  }
  {
#line 515
  tmp___0 = adns__findtype((adns_rrtype )65537);
#line 515
  st = adns__internal_submit((adns_state )pai->ads, & nqu, tmp___0, & (pai->qu)->vb,
                             id, nflags, (struct timeval )pai->now, (qcontext const   *)(& ctx));
  }
#line 517
  if (st) {
#line 517
    return (st);
  }
#line 519
  nqu->parent = (adns_query )pai->qu;
  {
#line 520
  while (1) {
    while_continue: /* CIL Label */ ;
#line 520
    nqu->siblings.next = (adns_query )0;
#line 520
    nqu->siblings.back = (pai->qu)->children.tail;
#line 520
    if ((pai->qu)->children.tail) {
#line 520
      ((pai->qu)->children.tail)->siblings.next = nqu;
    } else {
#line 520
      (pai->qu)->children.head = nqu;
    }
#line 520
    (pai->qu)->children.tail = nqu;
#line 520
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 522
  return ((adns_status )0);
}
}
#line 525 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_hostaddr(parseinfo const   *pai , int cbyte___3 , int max ,
                               void *datap ) 
{ 
  adns_rr_hostaddr *rrp ;
  adns_status st ;

  {
  {
#line 527
  rrp = (adns_rr_hostaddr *)datap;
#line 530
  st = pap_hostaddr(pai, & cbyte___3, max, rrp);
  }
#line 531
  if (st) {
#line 531
    return (st);
  }
#line 532
  if (cbyte___3 != max) {
#line 532
    return ((adns_status )104);
  }
#line 534
  return ((adns_status )0);
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int dip_hostaddr(adns_state ads___7 , adns_rr_hostaddr const   *ap , adns_rr_hostaddr const   *bp ) 
{ 
  int tmp ;

  {
#line 539
  if ((unsigned int const   )ap->astatus != (unsigned int const   )bp->astatus) {
#line 539
    return ((int )ap->astatus);
  }
#line 540
  if (ap->astatus) {
#line 540
    return (0);
  }
#line 542
  if (! ((int )(ap->addrs + 0)->addr.sa.sa_family == 2)) {
    {
#line 542
    __assert_fail("ap->addrs[0].addr.sa.sa_family == 2", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  542U, "dip_hostaddr");
    }
  }
#line 543
  if (! ((int )(bp->addrs + 0)->addr.sa.sa_family == 2)) {
    {
#line 543
    __assert_fail("bp->addrs[0].addr.sa.sa_family == 2", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  543U, "dip_hostaddr");
    }
  }
  {
#line 544
  tmp = dip_inaddr(ads___7, (ap->addrs + 0)->addr.inet.sin_addr, (bp->addrs + 0)->addr.inet.sin_addr);
  }
#line 544
  return (tmp);
}
}
#line 549 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_hostaddr(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_hostaddr const   *ap ;
  adns_rr_hostaddr const   *bp ;
  int tmp ;

  {
  {
#line 551
  ap = (adns_rr_hostaddr const   *)datap_a;
#line 551
  bp = (adns_rr_hostaddr const   *)datap_b;
#line 553
  tmp = dip_hostaddr(ads___7, ap, bp);
  }
#line 553
  return (tmp);
}
}
#line 556 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mfp_hostaddr(adns_query qu , adns_rr_hostaddr *rrp ) 
{ 
  void *tablev ;

  {
  {
#line 559
  adns__makefinal_str(qu, & rrp->host);
#line 560
  tablev = (void *)rrp->addrs;
#line 561
  adns__makefinal_block(qu, & tablev, (unsigned long )rrp->naddrs * sizeof(*(rrp->addrs)));
#line 562
  rrp->addrs = (adns_rr_addr *)tablev;
  }
#line 563
  return;
}
}
#line 565 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_hostaddr(adns_query qu , void *datap ) 
{ 
  adns_rr_hostaddr *rrp ;

  {
  {
#line 566
  rrp = (adns_rr_hostaddr *)datap;
#line 568
  mfp_hostaddr(qu, rrp);
  }
#line 569
  return;
}
}
#line 571 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_hostaddr(vbuf *vb___0 , adns_rr_hostaddr const   *rrp ) 
{ 
  char const   *errstr ;
  adns_status st ;
  char buf___17[20] ;
  int i ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 577
  st = csp_domain(vb___0, (char const   *)rrp->host);
  }
#line 577
  if (st) {
#line 577
    return (st);
  }
  {
#line 579
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 579
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 579
    if (! tmp) {
#line 579
      return ((adns_status )1);
    }
#line 579
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 580
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 580
    tmp___0 = adns_errtypeabbrev((adns_status )rrp->astatus);
#line 580
    tmp___1 = adns__vbuf_appendstr(vb___0, tmp___0);
    }
#line 580
    if (! tmp___1) {
#line 580
      return ((adns_status )1);
    }
#line 580
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 582
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %d ",
          (unsigned int const   )rrp->astatus);
  }
  {
#line 583
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 583
    tmp___2 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 583
    if (! tmp___2) {
#line 583
      return ((adns_status )1);
    }
#line 583
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 585
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 585
    tmp___3 = adns_errabbrev((adns_status )rrp->astatus);
#line 585
    tmp___4 = adns__vbuf_appendstr(vb___0, tmp___3);
    }
#line 585
    if (! tmp___4) {
#line 585
      return ((adns_status )1);
    }
#line 585
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 586
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 586
    tmp___5 = adns__vbuf_appendstr(vb___0, " ");
    }
#line 586
    if (! tmp___5) {
#line 586
      return ((adns_status )1);
    }
#line 586
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 588
  errstr = adns_strerror((adns_status )rrp->astatus);
#line 589
  tmp___6 = strlen(errstr);
#line 589
  st = csp_qstring(vb___0, errstr, (int )tmp___6);
  }
#line 589
  if (st) {
#line 589
    return (st);
  }
#line 591
  if (rrp->naddrs >= 0) {
    {
#line 592
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 592
      tmp___7 = adns__vbuf_appendstr(vb___0, " (");
      }
#line 592
      if (! tmp___7) {
#line 592
        return ((adns_status )1);
      }
#line 592
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 593
    i = 0;
    {
#line 593
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 593
      if (! (i < (int )rrp->naddrs)) {
#line 593
        goto while_break___5;
      }
      {
#line 594
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 594
        tmp___8 = adns__vbuf_appendstr(vb___0, " ");
        }
#line 594
        if (! tmp___8) {
#line 594
          return ((adns_status )1);
        }
#line 594
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 595
      st = csp_addr(vb___0, (adns_rr_addr const   *)(rrp->addrs + i));
#line 593
      i ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 597
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 597
      tmp___9 = adns__vbuf_appendstr(vb___0, " )");
      }
#line 597
      if (! tmp___9) {
#line 597
        return ((adns_status )1);
      }
#line 597
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
  } else {
    {
#line 599
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 599
      tmp___10 = adns__vbuf_appendstr(vb___0, " ?");
      }
#line 599
      if (! tmp___10) {
#line 599
        return ((adns_status )1);
      }
#line 599
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
#line 601
  return ((adns_status )0);
}
}
#line 604 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_hostaddr(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_hostaddr const   *rrp ;
  adns_status tmp ;

  {
  {
#line 605
  rrp = (adns_rr_hostaddr const   *)datap;
#line 607
  tmp = csp_hostaddr(vb___0, rrp);
  }
#line 607
  return (tmp);
}
}
#line 614 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_mx_raw(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  byte const   *dgram ;
  adns_rr_intstr *rrp ;
  adns_status st ;
  int pref ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 616
  dgram = (byte const   *)pai->dgram;
#line 617
  rrp = (adns_rr_intstr *)datap;
#line 621
  if (cbyte___3 + 2 > max) {
#line 621
    return ((adns_status )104);
  }
#line 622
  pref = 0;
#line 622
  tmp = cbyte___3;
#line 622
  cbyte___3 ++;
#line 622
  pref |= (int )(((int const   )*(dgram + tmp) & 255) << 8);
#line 622
  tmp___0 = cbyte___3;
#line 622
  cbyte___3 ++;
#line 622
  pref |= (int )((int const   )*(dgram + tmp___0) & 255);
#line 623
  rrp->i = pref;
#line 624
  if ((pai->qu)->flags & 64) {
#line 624
    tmp___1 = 1;
  } else {
#line 624
    tmp___1 = 0;
  }
  {
#line 624
  st = pap_domain(pai, & cbyte___3, max, & rrp->str, (parsedomain_flags )tmp___1);
  }
#line 626
  if (st) {
#line 626
    return (st);
  }
#line 628
  if (cbyte___3 != max) {
#line 628
    return ((adns_status )104);
  }
#line 629
  return ((adns_status )0);
}
}
#line 632 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_mx_raw(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_intstr const   *ap ;
  adns_rr_intstr const   *bp ;

  {
#line 633
  ap = (adns_rr_intstr const   *)datap_a;
#line 633
  bp = (adns_rr_intstr const   *)datap_b;
#line 635
  if (ap->i < bp->i) {
#line 635
    return (0);
  }
#line 636
  if (ap->i > bp->i) {
#line 636
    return (1);
  }
#line 637
  return (0);
}
}
#line 644 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_mx(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  byte const   *dgram ;
  adns_rr_inthostaddr *rrp ;
  adns_status st ;
  int pref ;
  int tmp ;
  int tmp___0 ;

  {
#line 646
  dgram = (byte const   *)pai->dgram;
#line 647
  rrp = (adns_rr_inthostaddr *)datap;
#line 651
  if (cbyte___3 + 2 > max) {
#line 651
    return ((adns_status )104);
  }
  {
#line 652
  pref = 0;
#line 652
  tmp = cbyte___3;
#line 652
  cbyte___3 ++;
#line 652
  pref |= (int )(((int const   )*(dgram + tmp) & 255) << 8);
#line 652
  tmp___0 = cbyte___3;
#line 652
  cbyte___3 ++;
#line 652
  pref |= (int )((int const   )*(dgram + tmp___0) & 255);
#line 653
  rrp->i = pref;
#line 654
  st = pap_hostaddr(pai, & cbyte___3, max, & rrp->ha);
  }
#line 655
  if (st) {
#line 655
    return (st);
  }
#line 657
  if (cbyte___3 != max) {
#line 657
    return ((adns_status )104);
  }
#line 658
  return ((adns_status )0);
}
}
#line 661 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_mx(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_inthostaddr const   *ap ;
  adns_rr_inthostaddr const   *bp ;
  int tmp ;

  {
#line 662
  ap = (adns_rr_inthostaddr const   *)datap_a;
#line 662
  bp = (adns_rr_inthostaddr const   *)datap_b;
#line 664
  if (ap->i < bp->i) {
#line 664
    return (0);
  }
#line 665
  if (ap->i > bp->i) {
#line 665
    return (1);
  }
  {
#line 666
  tmp = dip_hostaddr(ads___7, & ap->ha, & bp->ha);
  }
#line 666
  return (tmp);
}
}
#line 673 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_inthostaddr(adns_query qu , void *datap ) 
{ 
  adns_rr_inthostaddr *rrp ;

  {
  {
#line 674
  rrp = (adns_rr_inthostaddr *)datap;
#line 676
  mfp_hostaddr(qu, & rrp->ha);
  }
#line 677
  return;
}
}
#line 679 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_inthostaddr(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_inthostaddr const   *rrp ;
  char buf___17[10] ;
  int tmp ;
  adns_status tmp___0 ;

  {
  {
#line 680
  rrp = (adns_rr_inthostaddr const   *)datap;
#line 683
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"%u ",
          rrp->i);
  }
  {
#line 684
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 684
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 684
    if (! tmp) {
#line 684
      return ((adns_status )1);
    }
#line 684
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 686
  tmp___0 = csp_hostaddr(vb___0, & rrp->ha);
  }
#line 686
  return (tmp___0);
}
}
#line 693 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_inthost(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_intstr const   *rrp ;
  char buf___17[10] ;
  int tmp ;
  adns_status tmp___0 ;

  {
  {
#line 694
  rrp = (adns_rr_intstr const   *)datap;
#line 697
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"%u ",
          rrp->i);
  }
  {
#line 698
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 698
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 698
    if (! tmp) {
#line 698
      return ((adns_status )1);
    }
#line 698
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 699
  tmp___0 = csp_domain(vb___0, (char const   *)rrp->str);
  }
#line 699
  return (tmp___0);
}
}
#line 706 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void icb_ptr(adns_query parent , adns_query child ) 
{ 
  adns_answer *cans ;
  adns_rr_addr const   *queried ;
  adns_rr_addr const   *found ;
  adns_state ads___7 ;
  int i ;
  int tmp ;

  {
#line 707
  cans = child->answer;
#line 709
  ads___7 = parent->ads;
#line 712
  if ((unsigned int )cans->status == 300U) {
    {
#line 713
    adns__query_fail(parent, (adns_status )100);
    }
#line 714
    return;
  } else
#line 712
  if ((unsigned int )cans->status == 301U) {
    {
#line 713
    adns__query_fail(parent, (adns_status )100);
    }
#line 714
    return;
  } else
#line 715
  if (cans->status) {
    {
#line 716
    adns__query_fail(parent, cans->status);
    }
#line 717
    return;
  }
#line 720
  queried = (adns_rr_addr const   *)(& parent->ctx.info.ptr_parent_addr);
#line 721
  i = 0;
#line 721
  found = (adns_rr_addr const   *)cans->rrs.addr;
  {
#line 721
  while (1) {
    while_continue: /* CIL Label */ ;
#line 721
    if (! (i < cans->nrrs)) {
#line 721
      goto while_break;
    }
#line 722
    if (queried->len == found->len) {
      {
#line 722
      tmp = memcmp((void const   *)(& queried->addr), (void const   *)(& found->addr),
                   (size_t )queried->len);
      }
#line 722
      if (! tmp) {
#line 724
        if (! parent->children.head) {
          {
#line 725
          adns__query_done(parent);
          }
#line 726
          return;
        } else {
          {
#line 728
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 728
            parent->next = (adns_query )0;
#line 728
            parent->back = ads___7->childw.tail;
#line 728
            if (ads___7->childw.tail) {
#line 728
              (ads___7->childw.tail)->next = parent;
            } else {
#line 728
              ads___7->childw.head = parent;
            }
#line 728
            ads___7->childw.tail = parent;
#line 728
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 729
          return;
        }
      }
    }
#line 721
    i ++;
#line 721
    found ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 734
  adns__query_fail(parent, (adns_status )100);
  }
#line 735
  return;
}
}
#line 739
static adns_status pa_ptr(parseinfo const   *pai , int dmstart , int max , void *datap ) ;
#line 739 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static char const   * const  expectdomain[2]  = {      (char const   */* const  */)"in-addr",      (char const   */* const  */)"arpa"};
#line 737 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_ptr(parseinfo const   *pai , int dmstart , int max , void *datap ) 
{ 
  char **rrp ;
  adns_status st ;
  adns_rr_addr *ap ;
  findlabel_state fls ;
  char *ep ;
  byte ipv[4] ;
  char labbuf[4] ;
  int cbyte___3 ;
  int i ;
  int lablen ;
  int labstart ;
  int l ;
  int id ;
  adns_query nqu ;
  qcontext ctx ;
  int tmp ;
  unsigned long tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  typeinfo const   *tmp___3 ;

  {
#line 741
  rrp = (char **)datap;
#line 752
  cbyte___3 = dmstart;
#line 753
  if ((pai->qu)->flags & 64) {
#line 753
    tmp = 1;
  } else {
#line 753
    tmp = 0;
  }
  {
#line 753
  st = pap_domain(pai, & cbyte___3, max, rrp, (parsedomain_flags )tmp);
  }
#line 755
  if (st) {
#line 755
    return (st);
  }
#line 756
  if (cbyte___3 != max) {
#line 756
    return ((adns_status )104);
  }
#line 758
  ap = & (pai->qu)->ctx.info.ptr_parent_addr;
#line 759
  if (! ap->len) {
    {
#line 760
    adns__findlabel_start(& fls, (adns_state )pai->ads, -1, (adns_query )pai->qu,
                          (byte const   *)(pai->qu)->query_dgram, (pai->qu)->query_dglen,
                          (pai->qu)->query_dglen, 12, (int *)0);
#line 763
    i = 0;
    }
    {
#line 763
    while (1) {
      while_continue: /* CIL Label */ ;
#line 763
      if (! (i < 4)) {
#line 763
        goto while_break;
      }
      {
#line 764
      st = adns__findlabel_next(& fls, & lablen, & labstart);
      }
#line 764
      if (! (! st)) {
        {
#line 764
        __assert_fail("!st", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                      764U, "pa_ptr");
        }
      }
#line 765
      if (lablen <= 0) {
#line 765
        return ((adns_status )200);
      } else
#line 765
      if (lablen > 3) {
#line 765
        return ((adns_status )200);
      }
      {
#line 766
      memcpy((void */* __restrict  */)(labbuf), (void const   */* __restrict  */)((pai->qu)->query_dgram + labstart),
             (size_t )lablen);
#line 767
      labbuf[lablen] = (char)0;
#line 768
      tmp___0 = strtoul((char const   */* __restrict  */)(labbuf), (char **/* __restrict  */)(& ep),
                        10);
#line 768
      ipv[3 - i] = (byte )tmp___0;
      }
#line 769
      if (*ep) {
#line 769
        return ((adns_status )200);
      }
#line 770
      if (lablen > 1) {
#line 770
        if ((int )*((pai->qu)->query_dgram + labstart) == 48) {
#line 771
          return ((adns_status )200);
        }
      }
#line 763
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 773
    i = 0;
    {
#line 773
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 773
      if (! ((unsigned long )i < sizeof(expectdomain) / sizeof(expectdomain[0]))) {
#line 773
        goto while_break___0;
      }
      {
#line 774
      st = adns__findlabel_next(& fls, & lablen, & labstart);
      }
#line 774
      if (! (! st)) {
        {
#line 774
        __assert_fail("!st", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                      774U, "pa_ptr");
        }
      }
      {
#line 775
      tmp___1 = strlen((char const   *)expectdomain[i]);
#line 775
      l = (int )tmp___1;
      }
#line 776
      if (lablen != l) {
#line 778
        return ((adns_status )200);
      } else {
        {
#line 776
        tmp___2 = memcmp((void const   *)((pai->qu)->query_dgram + labstart), (void const   *)expectdomain[i],
                         (size_t )l);
        }
#line 776
        if (tmp___2) {
#line 778
          return ((adns_status )200);
        }
      }
#line 773
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 780
    st = adns__findlabel_next(& fls, & lablen, (int *)0);
    }
#line 780
    if (! (! st)) {
      {
#line 780
      __assert_fail("!st", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                    780U, "pa_ptr");
      }
    }
#line 781
    if (lablen) {
#line 781
      return ((adns_status )200);
    }
    {
#line 783
    ap->len = (int )sizeof(struct sockaddr_in );
#line 784
    memset((void *)(& ap->addr), 0, sizeof(ap->addr.inet));
#line 785
    ap->addr.inet.sin_family = (sa_family_t )2;
#line 786
    ap->addr.inet.sin_addr.s_addr = htonl((uint32_t )(((((int )ipv[0] << 24) | ((int )ipv[1] << 16)) | ((int )ipv[2] << 8)) | (int )ipv[3]));
    }
  }
  {
#line 790
  st = adns__mkquery_frdgram((adns_state )pai->ads, & (pai->qu)->vb, & id, (byte const   *)pai->dgram,
                             (int )pai->dglen, dmstart, (adns_rrtype )65537, (adns_queryflags )16);
  }
#line 793
  if (st) {
#line 793
    return (st);
  }
  {
#line 795
  ctx.ext = (void *)0;
#line 796
  ctx.callback = & icb_ptr;
#line 797
  memset((void *)(& ctx.info), 0, sizeof(ctx.info));
#line 798
  tmp___3 = adns__findtype((adns_rrtype )65537);
#line 798
  st = adns__internal_submit((adns_state )pai->ads, & nqu, tmp___3, & (pai->qu)->vb,
                             id, (adns_queryflags )16, (struct timeval )pai->now,
                             (qcontext const   *)(& ctx));
  }
#line 801
  if (st) {
#line 801
    return (st);
  }
#line 803
  nqu->parent = (adns_query )pai->qu;
  {
#line 804
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 804
    nqu->siblings.next = (adns_query )0;
#line 804
    nqu->siblings.back = (pai->qu)->children.tail;
#line 804
    if ((pai->qu)->children.tail) {
#line 804
      ((pai->qu)->children.tail)->siblings.next = nqu;
    } else {
#line 804
      (pai->qu)->children.head = nqu;
    }
#line 804
    (pai->qu)->children.tail = nqu;
#line 804
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 805
  return ((adns_status )0);
}
}
#line 812 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_strpair(adns_query qu , void *datap ) 
{ 
  adns_rr_strpair *rrp ;

  {
  {
#line 813
  rrp = (adns_rr_strpair *)datap;
#line 815
  adns__makefinal_str(qu, & rrp->array[0]);
#line 816
  adns__makefinal_str(qu, & rrp->array[1]);
  }
#line 817
  return;
}
}
#line 823 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_intstrpair(adns_query qu , void *datap ) 
{ 
  adns_rr_intstrpair *rrp ;

  {
  {
#line 824
  rrp = (adns_rr_intstrpair *)datap;
#line 826
  adns__makefinal_str(qu, & rrp->array[0].str);
#line 827
  adns__makefinal_str(qu, & rrp->array[1].str);
  }
#line 828
  return;
}
}
#line 834 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_hinfo(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  adns_rr_intstrpair *rrp ;
  adns_status st ;
  int i ;

  {
#line 836
  rrp = (adns_rr_intstrpair *)datap;
#line 840
  i = 0;
  {
#line 840
  while (1) {
    while_continue: /* CIL Label */ ;
#line 840
    if (! (i < 2)) {
#line 840
      goto while_break;
    }
    {
#line 841
    st = pap_qstring(pai, & cbyte___3, max, & rrp->array[i].i, & rrp->array[i].str);
    }
#line 842
    if (st) {
#line 842
      return (st);
    }
#line 840
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 845
  if (cbyte___3 != max) {
#line 845
    return ((adns_status )104);
  }
#line 847
  return ((adns_status )0);
}
}
#line 854 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_mailbox822(parseinfo const   *pai , int *cbyte_io , int max ,
                                  char **mb_r ) 
{ 
  int lablen ;
  int labstart ;
  int i ;
  int needquote ;
  int c ;
  int r ;
  int neednorm ;
  unsigned char const   *p ;
  char *str ;
  findlabel_state fls ;
  adns_status st ;
  vbuf *vb___0 ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 863
  vb___0 = & (pai->qu)->vb;
#line 864
  vb___0->used = 0;
#line 865
  adns__findlabel_start(& fls, (adns_state )pai->ads, -1, (adns_query )pai->qu, (byte const   *)pai->dgram,
                        (int )pai->dglen, max, *cbyte_io, cbyte_io);
#line 869
  st = adns__findlabel_next(& fls, & lablen, & labstart);
  }
#line 870
  if (! lablen) {
    {
#line 871
    adns__vbuf_appendstr(vb___0, ".");
    }
#line 872
    goto x_ok;
  }
#line 875
  neednorm = 1;
#line 876
  i = 0;
#line 876
  needquote = 0;
#line 876
  p = (unsigned char const   *)(pai->dgram + labstart);
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (! (i < lablen)) {
#line 876
      goto while_break;
    }
#line 877
    tmp = p;
#line 877
    p ++;
#line 877
    c = (int )*tmp;
#line 878
    if ((c & -129) < 32) {
#line 878
      return ((adns_status )104);
    } else
#line 878
    if ((c & -129) == 127) {
#line 878
      return ((adns_status )104);
    }
#line 879
    if (c == 46) {
#line 879
      if (! neednorm) {
#line 879
        neednorm = 1;
      } else {
#line 879
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 880
    if (c == 32) {
#line 880
      needquote ++;
    } else
#line 880
    if (c >= 127) {
#line 880
      needquote ++;
    } else {
      {
#line 880
      tmp___0 = ctype_822special(c);
      }
#line 880
      if (tmp___0) {
#line 880
        needquote ++;
      } else {
#line 881
        neednorm = 0;
      }
    }
#line 876
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 884
  if (needquote) {
#line 884
    goto _L___0;
  } else
#line 884
  if (neednorm) {
    _L___0: /* CIL Label */ 
    {
#line 885
    r = adns__vbuf_ensure(vb___0, (lablen + needquote) + 4);
    }
#line 885
    if (! r) {
#line 885
      return ((adns_status )1);
    }
    {
#line 886
    adns__vbuf_appendq(vb___0, (byte const   *)"\"", 1);
#line 887
    i = 0;
#line 887
    needquote = 0;
#line 887
    p = (unsigned char const   *)(pai->dgram + labstart);
    }
    {
#line 887
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 887
      if (! (i < lablen)) {
#line 887
        goto while_break___0;
      }
#line 888
      c = (int )*p;
#line 889
      if (c == 34) {
        {
#line 889
        adns__vbuf_appendq(vb___0, (byte const   *)"\\", 1);
        }
      } else
#line 889
      if (c == 92) {
        {
#line 889
        adns__vbuf_appendq(vb___0, (byte const   *)"\\", 1);
        }
      }
      {
#line 890
      adns__vbuf_appendq(vb___0, p, 1);
#line 887
      i ++;
#line 887
      p ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 892
    adns__vbuf_appendq(vb___0, (byte const   *)"\"", 1);
    }
  } else {
    {
#line 894
    r = adns__vbuf_append(vb___0, (byte const   *)(pai->dgram + labstart), lablen);
    }
#line 894
    if (! r) {
#line 894
      return ((adns_status )1);
    }
  }
  {
#line 897
  r = adns__vbuf_appendstr(vb___0, "@");
  }
#line 897
  if (! r) {
#line 897
    return ((adns_status )1);
  }
  {
#line 899
  st = adns__parse_domain_more(& fls, (adns_state )pai->ads, (adns_query )pai->qu,
                               vb___0, (parsedomain_flags )0, (byte const   *)pai->dgram);
  }
#line 900
  if (st) {
#line 900
    return (st);
  }
  x_ok: 
  {
#line 903
  tmp___1 = adns__alloc_interim((adns_query )pai->qu, (size_t )(vb___0->used + 1));
#line 903
  str = (char *)tmp___1;
  }
#line 903
  if (! str) {
#line 903
    return ((adns_status )1);
  }
  {
#line 904
  memcpy((void */* __restrict  */)str, (void const   */* __restrict  */)vb___0->buf,
         (size_t )vb___0->used);
#line 905
  *(str + vb___0->used) = (char)0;
#line 906
  *mb_r = str;
  }
#line 907
  return ((adns_status )0);
}
}
#line 910 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_mailbox(parseinfo const   *pai , int *cbyte_io , int max ,
                               char **mb_r ) 
{ 
  adns_status tmp ;
  adns_status tmp___0 ;

  {
#line 912
  if ((unsigned int const   )((pai->qu)->typei)->typekey & 131072U) {
    {
#line 913
    tmp = pap_mailbox822(pai, cbyte_io, max, mb_r);
    }
#line 913
    return (tmp);
  } else {
    {
#line 915
    tmp___0 = pap_domain(pai, cbyte_io, max, mb_r, (parsedomain_flags )1);
    }
#line 915
    return (tmp___0);
  }
}
}
#line 919 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_mailbox(vbuf *vb___0 , char const   *mailbox ) 
{ 
  adns_status tmp ;

  {
  {
#line 920
  tmp = csp_domain(vb___0, mailbox);
  }
#line 920
  return (tmp);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_rp(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  adns_rr_strpair *rrp ;
  adns_status st ;

  {
  {
#line 929
  rrp = (adns_rr_strpair *)datap;
#line 932
  st = pap_mailbox(pai, & cbyte___3, max, & rrp->array[0]);
  }
#line 933
  if (st) {
#line 933
    return (st);
  }
  {
#line 935
  st = pap_domain(pai, & cbyte___3, max, & rrp->array[1], (parsedomain_flags )1);
  }
#line 936
  if (st) {
#line 936
    return (st);
  }
#line 938
  if (cbyte___3 != max) {
#line 938
    return ((adns_status )104);
  }
#line 939
  return ((adns_status )0);
}
}
#line 942 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_rp(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_strpair const   *rrp ;
  adns_status st ;
  int tmp ;

  {
  {
#line 943
  rrp = (adns_rr_strpair const   *)datap;
#line 946
  st = csp_mailbox(vb___0, (char const   *)rrp->array[0]);
  }
#line 946
  if (st) {
#line 946
    return (st);
  }
  {
#line 947
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 947
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 947
    if (! tmp) {
#line 947
      return ((adns_status )1);
    }
#line 947
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 948
  st = csp_domain(vb___0, (char const   *)rrp->array[1]);
  }
#line 948
  if (st) {
#line 948
    return (st);
  }
#line 950
  return ((adns_status )0);
}
}
#line 957 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_soa(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  adns_rr_soa *rrp ;
  byte const   *dgram ;
  adns_status st ;
  int msw ;
  int lsw ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 959
  rrp = (adns_rr_soa *)datap;
#line 960
  dgram = (byte const   *)pai->dgram;
#line 964
  if ((pai->qu)->flags & 64) {
#line 964
    tmp = 1;
  } else {
#line 964
    tmp = 0;
  }
  {
#line 964
  st = pap_domain(pai, & cbyte___3, max, & rrp->mname, (parsedomain_flags )tmp);
  }
#line 966
  if (st) {
#line 966
    return (st);
  }
  {
#line 968
  st = pap_mailbox(pai, & cbyte___3, max, & rrp->rname);
  }
#line 969
  if (st) {
#line 969
    return (st);
  }
#line 971
  if (cbyte___3 + 20 != max) {
#line 971
    return ((adns_status )104);
  }
#line 973
  i = 0;
  {
#line 973
  while (1) {
    while_continue: /* CIL Label */ ;
#line 973
    if (! (i < 5)) {
#line 973
      goto while_break;
    }
#line 974
    msw = 0;
#line 974
    tmp___0 = cbyte___3;
#line 974
    cbyte___3 ++;
#line 974
    msw |= (int )(((int const   )*(dgram + tmp___0) & 255) << 8);
#line 974
    tmp___1 = cbyte___3;
#line 974
    cbyte___3 ++;
#line 974
    msw |= (int )((int const   )*(dgram + tmp___1) & 255);
#line 975
    lsw = 0;
#line 975
    tmp___2 = cbyte___3;
#line 975
    cbyte___3 ++;
#line 975
    lsw |= (int )(((int const   )*(dgram + tmp___2) & 255) << 8);
#line 975
    tmp___3 = cbyte___3;
#line 975
    cbyte___3 ++;
#line 975
    lsw |= (int )((int const   )*(dgram + tmp___3) & 255);
#line 976
    *(& rrp->serial + i) = (unsigned long )((msw << 16) | lsw);
#line 973
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 979
  return ((adns_status )0);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_soa(adns_query qu , void *datap ) 
{ 
  adns_rr_soa *rrp ;

  {
  {
#line 983
  rrp = (adns_rr_soa *)datap;
#line 985
  adns__makefinal_str(qu, & rrp->mname);
#line 986
  adns__makefinal_str(qu, & rrp->rname);
  }
#line 987
  return;
}
}
#line 989 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_soa(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_soa const   *rrp ;
  char buf___17[20] ;
  int i ;
  adns_status st ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 990
  rrp = (adns_rr_soa const   *)datap;
#line 995
  st = csp_domain(vb___0, (char const   *)rrp->mname);
  }
#line 995
  if (st) {
#line 995
    return (st);
  }
  {
#line 996
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 996
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 996
    if (! tmp) {
#line 996
      return ((adns_status )1);
    }
#line 996
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 997
  st = csp_mailbox(vb___0, (char const   *)rrp->rname);
  }
#line 997
  if (st) {
#line 997
    return (st);
  }
#line 999
  i = 0;
  {
#line 999
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 999
    if (! (i < 5)) {
#line 999
      goto while_break___0;
    }
    {
#line 1000
    sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %lu",
            *(& rrp->serial + i));
    }
    {
#line 1001
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1001
      tmp___0 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
      }
#line 1001
      if (! tmp___0) {
#line 1001
        return ((adns_status )1);
      }
#line 1001
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 999
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1004
  return ((adns_status )0);
}
}
#line 1011 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status qdpl_srv(adns_state ads___7 , char const   **p_io , char const   *pe ,
                            int labelnum , char *label_r , int *ll_io , adns_queryflags flags ,
                            typeinfo const   *typei ) 
{ 
  int useflags ;
  char const   *p_orig ;
  adns_status st ;
  int ll ;
  void *tmp ;

  {
#line 1020
  if (labelnum < 2) {
#line 1020
    if (! ((unsigned int )flags & 16U)) {
#line 1021
      useflags = 16;
#line 1022
      p_orig = *p_io;
    } else {
#line 1024
      useflags = (int )flags;
#line 1025
      p_orig = (char const   *)0;
    }
  } else {
#line 1024
    useflags = (int )flags;
#line 1025
    p_orig = (char const   *)0;
  }
  {
#line 1027
  st = adns__qdpl_normal(ads___7, p_io, pe, labelnum, (char *)label_r, ll_io, (adns_queryflags )useflags,
                         typei);
  }
#line 1028
  if (st) {
#line 1028
    return (st);
  }
#line 1030
  if (p_orig) {
#line 1031
    ll = *ll_io;
#line 1032
    if (! ll) {
#line 1033
      return ((adns_status )201);
    } else
#line 1032
    if ((int )*(label_r + 0) != 95) {
#line 1033
      return ((adns_status )201);
    }
    {
#line 1034
    tmp = memchr((void const   *)(p_orig + 1), '\\', (size_t )(pe - (p_orig + 1)));
    }
#line 1034
    if (tmp) {
#line 1035
      return ((adns_status )201);
    }
  }
#line 1037
  return ((adns_status )0);
}
}
#line 1040 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_srv_begin(parseinfo const   *pai , int *cbyte_io , int max ,
                                 adns_rr_srvha *rrp ) 
{ 
  byte const   *dgram ;
  int ti ;
  int cbyte___3 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1043
  dgram = (byte const   *)pai->dgram;
#line 1046
  cbyte___3 = *cbyte_io;
#line 1047
  tmp = *cbyte_io + 6;
#line 1047
  *cbyte_io = tmp;
#line 1047
  if (tmp > max) {
#line 1047
    return ((adns_status )104);
  }
#line 1049
  ti = 0;
#line 1049
  tmp___0 = cbyte___3;
#line 1049
  cbyte___3 ++;
#line 1049
  ti |= (int )(((int const   )*(dgram + tmp___0) & 255) << 8);
#line 1049
  tmp___1 = cbyte___3;
#line 1049
  cbyte___3 ++;
#line 1049
  ti |= (int )((int const   )*(dgram + tmp___1) & 255);
#line 1049
  rrp->priority = ti;
#line 1050
  ti = 0;
#line 1050
  tmp___2 = cbyte___3;
#line 1050
  cbyte___3 ++;
#line 1050
  ti |= (int )(((int const   )*(dgram + tmp___2) & 255) << 8);
#line 1050
  tmp___3 = cbyte___3;
#line 1050
  cbyte___3 ++;
#line 1050
  ti |= (int )((int const   )*(dgram + tmp___3) & 255);
#line 1050
  rrp->weight = ti;
#line 1051
  ti = 0;
#line 1051
  tmp___4 = cbyte___3;
#line 1051
  cbyte___3 ++;
#line 1051
  ti |= (int )(((int const   )*(dgram + tmp___4) & 255) << 8);
#line 1051
  tmp___5 = cbyte___3;
#line 1051
  cbyte___3 ++;
#line 1051
  ti |= (int )((int const   )*(dgram + tmp___5) & 255);
#line 1051
  rrp->port = ti;
#line 1052
  return ((adns_status )0);
}
}
#line 1055 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_srvraw(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  adns_rr_srvraw *rrp ;
  adns_status st ;
  int tmp ;

  {
  {
#line 1057
  rrp = (adns_rr_srvraw *)datap;
#line 1060
  st = pap_srv_begin(pai, & cbyte___3, max, (adns_rr_srvha *)datap);
  }
#line 1061
  if (st) {
#line 1061
    return (st);
  }
#line 1063
  if ((pai->qu)->flags & 64) {
#line 1063
    tmp = 1;
  } else {
#line 1063
    tmp = 0;
  }
  {
#line 1063
  st = pap_domain(pai, & cbyte___3, max, & rrp->host, (parsedomain_flags )tmp);
  }
#line 1065
  if (st) {
#line 1065
    return (st);
  }
#line 1067
  if (cbyte___3 != max) {
#line 1067
    return ((adns_status )104);
  }
#line 1068
  return ((adns_status )0);
}
}
#line 1071 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_srvha(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  adns_rr_srvha *rrp ;
  adns_status st ;

  {
  {
#line 1073
  rrp = (adns_rr_srvha *)datap;
#line 1076
  st = pap_srv_begin(pai, & cbyte___3, max, (adns_rr_srvha *)datap);
  }
#line 1076
  if (st) {
#line 1076
    return (st);
  }
  {
#line 1077
  st = pap_hostaddr(pai, & cbyte___3, max, & rrp->ha);
  }
#line 1077
  if (st) {
#line 1077
    return (st);
  }
#line 1078
  if (cbyte___3 != max) {
#line 1078
    return ((adns_status )104);
  }
#line 1079
  return ((adns_status )0);
}
}
#line 1082 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_srvraw(adns_query qu , void *datap ) 
{ 
  adns_rr_srvraw *rrp ;

  {
  {
#line 1083
  rrp = (adns_rr_srvraw *)datap;
#line 1084
  adns__makefinal_str(qu, & rrp->host);
  }
#line 1085
  return;
}
}
#line 1087 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_srvha(adns_query qu , void *datap ) 
{ 
  adns_rr_srvha *rrp ;

  {
  {
#line 1088
  rrp = (adns_rr_srvha *)datap;
#line 1089
  mfp_hostaddr(qu, & rrp->ha);
  }
#line 1090
  return;
}
}
#line 1092 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_srv(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_srvraw const   *ap ;
  adns_rr_srvraw const   *bp ;

  {
#line 1093
  ap = (adns_rr_srvraw const   *)datap_a;
#line 1093
  bp = (adns_rr_srvraw const   *)datap_b;
#line 1096
  if (ap->priority < bp->priority) {
#line 1096
    return (0);
  }
#line 1097
  if (ap->priority > bp->priority) {
#line 1097
    return (1);
  }
#line 1098
  return (0);
}
}
#line 1101 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_srv_begin(vbuf *vb___0 , adns_rr_srvha const   *rrp ) 
{ 
  char buf___17[30] ;
  int tmp ;

  {
  {
#line 1104
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"%u %u %u ",
          rrp->priority, rrp->weight, rrp->port);
  }
  {
#line 1105
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1105
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 1105
    if (! tmp) {
#line 1105
      return ((adns_status )1);
    }
#line 1105
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1106
  return ((adns_status )0);
}
}
#line 1109 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_srvraw(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_srvraw const   *rrp ;
  adns_status st ;
  adns_status tmp ;

  {
  {
#line 1110
  rrp = (adns_rr_srvraw const   *)datap;
#line 1113
  st = csp_srv_begin(vb___0, (adns_rr_srvha const   *)((void const   *)rrp));
  }
#line 1113
  if (st) {
#line 1113
    return (st);
  }
  {
#line 1114
  tmp = csp_domain(vb___0, (char const   *)rrp->host);
  }
#line 1114
  return (tmp);
}
}
#line 1117 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_srvha(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_srvha const   *rrp ;
  adns_status st ;
  adns_status tmp ;

  {
  {
#line 1118
  rrp = (adns_rr_srvha const   *)datap;
#line 1121
  st = csp_srv_begin(vb___0, (adns_rr_srvha const   *)datap);
  }
#line 1121
  if (st) {
#line 1121
    return (st);
  }
  {
#line 1122
  tmp = csp_hostaddr(vb___0, & rrp->ha);
  }
#line 1122
  return (tmp);
}
}
#line 1125 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void postsort_srv(adns_state ads___7 , void *array , int nrrs , struct typeinfo  const  *typei ) 
{ 
  char *workbegin ;
  char *workend ;
  char *search ;
  char *arrayend ;
  adns_rr_srvha const   *rr ;
  union __anonunion_rrtmp_89 rrtmp ;
  int cpriority ;
  int totalweight ;
  int runtotal ;
  long randval ;

  {
#line 1138
  workbegin = (char *)array;
#line 1138
  arrayend = workbegin + typei->rrsz * (int const   )nrrs;
  {
#line 1138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1138
    if (! ((unsigned long )workbegin < (unsigned long )arrayend)) {
#line 1138
      goto while_break;
    }
#line 1141
    rr = (adns_rr_srvha const   *)((void *)workbegin);
#line 1141
    cpriority = (int )rr->priority;
#line 1143
    workend = workbegin;
#line 1143
    totalweight = 0;
    {
#line 1143
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1143
      if ((unsigned long )workend < (unsigned long )arrayend) {
#line 1143
        rr = (adns_rr_srvha const   *)((void *)workend);
#line 1143
        if (! (rr->priority == (int const   )cpriority)) {
#line 1143
          goto while_break___0;
        }
      } else {
#line 1143
        goto while_break___0;
      }
#line 1146
      totalweight += (int )rr->weight;
#line 1143
      workend += typei->rrsz;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1155
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1155
      if (! ((unsigned long )(workbegin + typei->rrsz) < (unsigned long )workend)) {
#line 1155
        goto while_break___1;
      }
      {
#line 1159
      randval = nrand48((unsigned short *)(ads___7->rand48xsubi));
#line 1160
      randval %= (long )(totalweight + 1);
#line 1167
      search = workbegin;
#line 1167
      runtotal = 0;
      }
      {
#line 1167
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1167
        rr = (adns_rr_srvha const   *)((void *)search);
#line 1167
        runtotal += (int )rr->weight;
#line 1167
        if (! ((long )runtotal < randval)) {
#line 1167
          goto while_break___2;
        }
#line 1167
        search += typei->rrsz;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1170
      if (! ((unsigned long )search < (unsigned long )arrayend)) {
        {
#line 1170
        __assert_fail("search < arrayend", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                      1170U, "postsort_srv");
        }
      }
#line 1171
      totalweight -= (int )rr->weight;
#line 1172
      if ((unsigned long )search != (unsigned long )workbegin) {
        {
#line 1173
        memcpy((void */* __restrict  */)(& rrtmp), (void const   */* __restrict  */)workbegin,
               (size_t )typei->rrsz);
#line 1174
        memcpy((void */* __restrict  */)workbegin, (void const   */* __restrict  */)search,
               (size_t )typei->rrsz);
#line 1175
        memcpy((void */* __restrict  */)search, (void const   */* __restrict  */)(& rrtmp),
               (size_t )typei->rrsz);
        }
      }
#line 1155
      workbegin += typei->rrsz;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1138
    workbegin = workend;
  }
  while_break: /* CIL Label */ ;
  }
#line 1184
  return;
}
}
#line 1190 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_byteblock(adns_query qu , void *datap ) 
{ 
  adns_rr_byteblock *rrp ;
  void *bytes___3 ;

  {
  {
#line 1191
  rrp = (adns_rr_byteblock *)datap;
#line 1192
  bytes___3 = (void *)rrp->data;
#line 1193
  adns__makefinal_block(qu, & bytes___3, (size_t )rrp->len);
#line 1194
  rrp->data = (unsigned char *)bytes___3;
  }
#line 1195
  return;
}
}
#line 1201 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_opaque(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  adns_rr_byteblock *rrp ;
  void *tmp ;

  {
  {
#line 1203
  rrp = (adns_rr_byteblock *)datap;
#line 1205
  rrp->len = max - cbyte___3;
#line 1206
  tmp = adns__alloc_interim((adns_query )pai->qu, (size_t )rrp->len);
#line 1206
  rrp->data = (unsigned char *)tmp;
  }
#line 1207
  if (! rrp->data) {
#line 1207
    return ((adns_status )1);
  }
  {
#line 1208
  memcpy((void */* __restrict  */)rrp->data, (void const   */* __restrict  */)(pai->dgram + cbyte___3),
         (size_t )rrp->len);
  }
#line 1209
  return ((adns_status )0);
}
}
#line 1212 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_opaque(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_byteblock const   *rrp ;
  char buf___17[10] ;
  int l ;
  unsigned char *p ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1213
  rrp = (adns_rr_byteblock const   *)datap;
#line 1218
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"\\# %d",
          rrp->len);
  }
  {
#line 1219
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1219
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 1219
    if (! tmp) {
#line 1219
      return ((adns_status )1);
    }
#line 1219
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1221
  l = (int )rrp->len;
#line 1221
  p = (unsigned char *)rrp->data;
  {
#line 1221
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1221
    if (! (l >= 4)) {
#line 1221
      goto while_break___0;
    }
    {
#line 1224
    sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %02x%02x%02x%02x",
            (int )*(p + 0), (int )*(p + 1), (int )*(p + 2), (int )*(p + 3));
    }
    {
#line 1225
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1225
      tmp___0 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
      }
#line 1225
      if (! tmp___0) {
#line 1225
        return ((adns_status )1);
      }
#line 1225
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1221
    l -= 4;
#line 1221
    p += 4;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1227
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1227
    if (! (l > 0)) {
#line 1227
      goto while_break___2;
    }
    {
#line 1230
    sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %02x",
            (int )*p);
    }
    {
#line 1231
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 1231
      tmp___1 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
      }
#line 1231
      if (! tmp___1) {
#line 1231
        return ((adns_status )1);
      }
#line 1231
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1227
    l --;
#line 1227
    p ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1233
  return ((adns_status )0);
}
}
#line 1240 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_flat(adns_query qu , void *data___0 ) 
{ 


  {
#line 1240
  return;
}
}
#line 1261 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static typeinfo const   typeinfos[17]  = 
#line 1261
  {      {(adns_rrtype )1, "A", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.inaddr)),
      & mf_flat, & cs_inaddr, & pa_inaddr, & di_inaddr, (adns_status (*)(adns_state ads ,
                                                                         char const   **p_io ,
                                                                         char const   *pe ,
                                                                         int labelnum ,
                                                                         char *label_r ,
                                                                         int *ll_io ,
                                                                         adns_queryflags flags ,
                                                                         struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )2,
      "NS", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str, & cs_domain,
      & pa_host_raw, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )5,
      "CNAME", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str,
      & cs_domain, & pa_dom_raw, (int (*)(adns_state ads , void const   *datap_a ,
                                          void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                      char const   **p_io ,
                                                                                      char const   *pe ,
                                                                                      int labelnum ,
                                                                                      char *label_r ,
                                                                                      int *ll_io ,
                                                                                      adns_queryflags flags ,
                                                                                      struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )6,
      "SOA", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.soa)), & mf_soa, & cs_soa,
      & pa_soa, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )12,
      "PTR", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str, & cs_domain,
      & pa_host_raw, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )13,
      "HINFO", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.intstrpair)),
      & mf_intstrpair, & cs_hinfo, & pa_hinfo, (int (*)(adns_state ads , void const   *datap_a ,
                                                        void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )15,
      "MX", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.intstr)), & mf_intstr, & cs_inthost,
      & pa_mx_raw, & di_mx_raw, (adns_status (*)(adns_state ads , char const   **p_io ,
                                                 char const   *pe , int labelnum ,
                                                 char *label_r , int *ll_io , adns_queryflags flags ,
                                                 struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )16,
      "TXT", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.manyistr)),
      & mf_manyistr, & cs_txt, & pa_txt, (int (*)(adns_state ads , void const   *datap_a ,
                                                  void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                              char const   **p_io ,
                                                                                              char const   *pe ,
                                                                                              int labelnum ,
                                                                                              char *label_r ,
                                                                                              int *ll_io ,
                                                                                              adns_queryflags flags ,
                                                                                              struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )17,
      "RP", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.strpair)), & mf_strpair,
      & cs_rp, & pa_rp, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )33,
      "SRV", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.srvraw)), & mf_srvraw,
      & cs_srvraw, & pa_srvraw, & di_srv, & qdpl_srv, & postsort_srv}, 
        {(adns_rrtype )65537, "A", "addr", (int )sizeof(*(((adns_answer *)0)->rrs.addr)),
      & mf_flat, & cs_addr, & pa_addr, & di_addr, (adns_status (*)(adns_state ads ,
                                                                   char const   **p_io ,
                                                                   char const   *pe ,
                                                                   int labelnum ,
                                                                   char *label_r ,
                                                                   int *ll_io , adns_queryflags flags ,
                                                                   struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65538,
      "NS", "+addr", (int )sizeof(*(((adns_answer *)0)->rrs.hostaddr)), & mf_hostaddr,
      & cs_hostaddr, & pa_hostaddr, & di_hostaddr, (adns_status (*)(adns_state ads ,
                                                                    char const   **p_io ,
                                                                    char const   *pe ,
                                                                    int labelnum ,
                                                                    char *label_r ,
                                                                    int *ll_io , adns_queryflags flags ,
                                                                    struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65548,
      "PTR", "checked", (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str, & cs_domain,
      & pa_ptr, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65551,
      "MX", "+addr", (int )sizeof(*(((adns_answer *)0)->rrs.inthostaddr)), & mf_inthostaddr,
      & cs_inthostaddr, & pa_mx, & di_mx, (adns_status (*)(adns_state ads , char const   **p_io ,
                                                           char const   *pe , int labelnum ,
                                                           char *label_r , int *ll_io ,
                                                           adns_queryflags flags ,
                                                           struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65569,
      "SRV", "+addr", (int )sizeof(*(((adns_answer *)0)->rrs.srvha)), & mf_srvha,
      & cs_srvha, & pa_srvha, & di_srv, & qdpl_srv, & postsort_srv}, 
        {(adns_rrtype )131078, "SOA", "822", (int )sizeof(*(((adns_answer *)0)->rrs.soa)),
      & mf_soa, & cs_soa, & pa_soa, (int (*)(adns_state ads , void const   *datap_a ,
                                             void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                         char const   **p_io ,
                                                                                         char const   *pe ,
                                                                                         int labelnum ,
                                                                                         char *label_r ,
                                                                                         int *ll_io ,
                                                                                         adns_queryflags flags ,
                                                                                         struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )131089,
      "RP", "822", (int )sizeof(*(((adns_answer *)0)->rrs.strpair)), & mf_strpair,
      & cs_rp, & pa_rp, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}};
#line 1288 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static struct typeinfo  const  typeinfo_unknown  = 
#line 1288
     {(adns_rrtype )262144, (char const   *)0, "unknown", (int )sizeof(*(((adns_answer *)0)->rrs.byteblock)),
    & mf_byteblock, & cs_opaque, & pa_opaque, (int (*)(adns_state ads , void const   *datap_a ,
                                                       void const   *datap_b ))0,
    (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                     char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
    (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0};
#line 1291 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
typeinfo const   *adns__findtype(adns_rrtype type ) 
{ 
  typeinfo const   *begin ;
  typeinfo const   *end ;
  typeinfo const   *mid ;

  {
#line 1294
  if ((unsigned int )type & 262144U) {
#line 1294
    return (& typeinfo_unknown);
  }
#line 1296
  begin = typeinfos;
#line 1296
  end = typeinfos + sizeof(typeinfos) / sizeof(typeinfo );
  {
#line 1298
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1298
    if (! ((unsigned long )begin < (unsigned long )end)) {
#line 1298
      goto while_break;
    }
#line 1299
    mid = begin + ((end - begin) >> 1);
#line 1300
    if ((unsigned int const   )mid->typekey == (unsigned int const   )type) {
#line 1300
      return (mid);
    }
#line 1301
    if ((unsigned int )type > (unsigned int )mid->typekey) {
#line 1301
      begin = mid + 1;
    } else {
#line 1302
      end = mid;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1304
  return ((typeinfo const   *)0);
}
}
#line 631 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/adns.h"
void adns_checkconsistency(adns_state ads___7 , adns_query qu ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
void adns_checkconsistency(adns_state ads___7 , adns_query qu ) 
{ 


  {
  {
#line 30
  adns__consistency(ads___7, qu, (consistency_checks )0);
  }
#line 31
  return;
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_query_alloc(adns_state ads___7 , adns_query qu ) 
{ 
  allocnode *an ;
  int tmp ;

  {
#line 58
  if (qu->allocations.head) {
#line 58
    if (! (! (qu->allocations.head)->back)) {
      {
#line 58
      __assert_fail("! (qu->allocations).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    59U, "checkc_query_alloc");
      }
    }
#line 58
    an = qu->allocations.head;
    {
#line 58
    while (1) {
      while_continue: /* CIL Label */ ;
#line 58
      if (! an) {
#line 58
        goto while_break;
      }
#line 58
      if (an->next) {
#line 58
        tmp = (unsigned long )an == (unsigned long )(an->next)->back;
      } else {
#line 58
        tmp = (unsigned long )an == (unsigned long )qu->allocations.tail;
      }
#line 58
      if (! tmp) {
        {
#line 58
        __assert_fail("(an)-> next ? (an) == (an)-> next-> back : (an) == (qu->allocations).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      59U, "checkc_query_alloc");
        }
      }
#line 58
      an = an->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 60
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_query(adns_state ads___7 , adns_query qu ) 
{ 
  adns_query child ;

  {
#line 65
  if (! (qu->udpnextserver < ads___7->nservers)) {
    {
#line 65
    __assert_fail("qu->udpnextserver < ads->nservers", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  65U, "checkc_query");
    }
  }
#line 66
  if (! (! (qu->udpsent & (0xffffffffffffffffUL << ads___7->nservers)))) {
    {
#line 66
    __assert_fail("!(qu->udpsent & (~0UL << ads->nservers))", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  66U, "checkc_query");
    }
  }
#line 67
  if (! (qu->search_pos <= ads___7->nsearchlist)) {
    {
#line 67
    __assert_fail("qu->search_pos <= ads->nsearchlist", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  67U, "checkc_query");
    }
  }
#line 68
  if (qu->parent) {
    {
#line 68
    while (1) {
      while_continue: /* CIL Label */ ;
#line 68
      child = (qu->parent)->children.head;
      {
#line 68
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 68
        if (! ((unsigned long )child != (unsigned long )qu)) {
#line 68
          goto while_break___0;
        }
#line 68
        if (! child) {
          {
#line 68
          __assert_fail("(child)", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        68U, "checkc_query");
          }
        }
#line 68
        child = child->siblings.next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 68
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 69
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_notcpbuf(adns_state ads___7 ) 
{ 


  {
#line 72
  if (! (! ads___7->tcpsend.used)) {
    {
#line 72
    __assert_fail("!ads->tcpsend.used", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  72U, "checkc_notcpbuf");
    }
  }
#line 73
  if (! (! ads___7->tcprecv.used)) {
    {
#line 73
    __assert_fail("!ads->tcprecv.used", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  73U, "checkc_notcpbuf");
    }
  }
#line 74
  if (! (! ads___7->tcprecv_skip)) {
    {
#line 74
    __assert_fail("!ads->tcprecv_skip", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  74U, "checkc_notcpbuf");
    }
  }
#line 75
  return;
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_global(adns_state ads___7 ) 
{ 
  int i ;

  {
#line 80
  if (! (ads___7->udpsocket >= 0)) {
    {
#line 80
    __assert_fail("ads->udpsocket >= 0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  80U, "checkc_global");
    }
  }
#line 82
  i = 0;
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! (i < ads___7->nsortlist)) {
#line 82
      goto while_break;
    }
#line 83
    if (! (! (ads___7->sortlist[i].base.s_addr & ~ ads___7->sortlist[i].mask.s_addr))) {
      {
#line 83
      __assert_fail("!(ads->sortlist[i].base.s_addr & ~ads->sortlist[i].mask.s_addr)",
                    "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    83U, "checkc_global");
      }
    }
#line 82
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  if (ads___7->tcpserver >= 0) {
#line 85
    if (! (ads___7->tcpserver < ads___7->nservers)) {
      {
#line 85
      __assert_fail("ads->tcpserver >= 0 && ads->tcpserver < ads->nservers", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    85U, "checkc_global");
      }
    }
  } else {
    {
#line 85
    __assert_fail("ads->tcpserver >= 0 && ads->tcpserver < ads->nservers", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  85U, "checkc_global");
    }
  }
  {
#line 88
  if ((unsigned int )ads___7->tcpstate == 1U) {
#line 88
    goto case_1;
  }
#line 93
  if ((unsigned int )ads___7->tcpstate == 3U) {
#line 93
    goto case_3;
  }
#line 93
  if ((unsigned int )ads___7->tcpstate == 0U) {
#line 93
    goto case_3;
  }
#line 97
  if ((unsigned int )ads___7->tcpstate == 2U) {
#line 97
    goto case_2;
  }
#line 101
  goto switch_default;
  case_1: /* CIL Label */ 
#line 89
  if (! (ads___7->tcpsocket >= 0)) {
    {
#line 89
    __assert_fail("ads->tcpsocket >= 0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  89U, "checkc_global");
    }
  }
  {
#line 90
  checkc_notcpbuf(ads___7);
  }
#line 91
  goto switch_break;
  case_3: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 94
  if (! (ads___7->tcpsocket == -1)) {
    {
#line 94
    __assert_fail("ads->tcpsocket == -1", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  94U, "checkc_global");
    }
  }
  {
#line 95
  checkc_notcpbuf(ads___7);
  }
#line 96
  goto switch_break;
  case_2: /* CIL Label */ 
#line 98
  if (! (ads___7->tcpsocket >= 0)) {
    {
#line 98
    __assert_fail("ads->tcpsocket >= 0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  98U, "checkc_global");
    }
  }
#line 99
  if (! (ads___7->tcprecv_skip <= ads___7->tcprecv.used)) {
    {
#line 99
    __assert_fail("ads->tcprecv_skip <= ads->tcprecv.used", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  99U, "checkc_global");
    }
  }
#line 100
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 102
  __assert_fail("!\"ads->tcpstate value\"", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                102U, "checkc_global");
  }
  switch_break: /* CIL Label */ ;
  }
#line 105
  if (! ads___7->searchlist) {
#line 105
    if (! (! ads___7->nsearchlist)) {
      {
#line 105
      __assert_fail("ads->searchlist || !ads->nsearchlist", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    105U, "checkc_global");
      }
    }
  }
#line 106
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_queue_udpw(adns_state ads___7 ) 
{ 
  adns_query qu ;
  int tmp ;

  {
#line 111
  if (ads___7->udpw.head) {
#line 111
    if (! (! (ads___7->udpw.head)->back)) {
      {
#line 111
      __assert_fail("! (ads->udpw).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    118U, "checkc_queue_udpw");
      }
    }
#line 111
    qu = ads___7->udpw.head;
    {
#line 111
    while (1) {
      while_continue: /* CIL Label */ ;
#line 111
      if (! qu) {
#line 111
        goto while_break;
      }
#line 111
      if (qu->next) {
#line 111
        tmp = (unsigned long )qu == (unsigned long )(qu->next)->back;
      } else {
#line 111
        tmp = (unsigned long )qu == (unsigned long )ads___7->udpw.tail;
      }
#line 111
      if (! tmp) {
        {
#line 111
        __assert_fail("(qu)-> next ? (qu) == (qu)-> next-> back : (qu) == (ads->udpw).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! ((unsigned int )qu->state == 0U)) {
        {
#line 111
        __assert_fail("qu->state==query_tosend", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! (qu->retries <= 15)) {
        {
#line 111
        __assert_fail("qu->retries <= 15", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! qu->udpsent) {
        {
#line 111
        __assert_fail("qu->udpsent", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! qu->children.head) {
#line 111
        if (! (! qu->children.tail)) {
          {
#line 111
          __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        118U, "checkc_queue_udpw");
          }
        }
      } else {
        {
#line 111
        __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
      {
#line 111
      checkc_query(ads___7, qu);
#line 111
      checkc_query_alloc(ads___7, qu);
#line 111
      qu = qu->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 119
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_queue_tcpw(adns_state ads___7 ) 
{ 
  adns_query qu ;
  int tmp ;

  {
#line 124
  if (ads___7->tcpw.head) {
#line 124
    if (! (! (ads___7->tcpw.head)->back)) {
      {
#line 124
      __assert_fail("! (ads->tcpw).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    130U, "checkc_queue_tcpw");
      }
    }
#line 124
    qu = ads___7->tcpw.head;
    {
#line 124
    while (1) {
      while_continue: /* CIL Label */ ;
#line 124
      if (! qu) {
#line 124
        goto while_break;
      }
#line 124
      if (qu->next) {
#line 124
        tmp = (unsigned long )qu == (unsigned long )(qu->next)->back;
      } else {
#line 124
        tmp = (unsigned long )qu == (unsigned long )ads___7->tcpw.tail;
      }
#line 124
      if (! tmp) {
        {
#line 124
        __assert_fail("(qu)-> next ? (qu) == (qu)-> next-> back : (qu) == (ads->tcpw).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
#line 124
      if (! ((unsigned int )qu->state == 1U)) {
        {
#line 124
        __assert_fail("qu->state==query_tcpw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
#line 124
      if (! qu->children.head) {
#line 124
        if (! (! qu->children.tail)) {
          {
#line 124
          __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        130U, "checkc_queue_tcpw");
          }
        }
      } else {
        {
#line 124
        __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
#line 124
      if (! (qu->retries <= ads___7->nservers + 1)) {
        {
#line 124
        __assert_fail("qu->retries <= ads->nservers+1", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
      {
#line 124
      checkc_query(ads___7, qu);
#line 124
      checkc_query_alloc(ads___7, qu);
#line 124
      qu = qu->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 131
  return;
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_queue_childw(adns_state ads___7 ) 
{ 
  adns_query parent ;
  adns_query child ;
  int tmp ;
  int tmp___0 ;

  {
#line 136
  if (ads___7->childw.head) {
#line 136
    if (! (! (ads___7->childw.head)->back)) {
      {
#line 136
      __assert_fail("! (ads->childw).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    145U, "checkc_queue_childw");
      }
    }
#line 136
    parent = ads___7->childw.head;
    {
#line 136
    while (1) {
      while_continue: /* CIL Label */ ;
#line 136
      if (! parent) {
#line 136
        goto while_break;
      }
#line 136
      if (parent->next) {
#line 136
        tmp = (unsigned long )parent == (unsigned long )(parent->next)->back;
      } else {
#line 136
        tmp = (unsigned long )parent == (unsigned long )ads___7->childw.tail;
      }
#line 136
      if (! tmp) {
        {
#line 136
        __assert_fail("(parent)-> next ? (parent) == (parent)-> next-> back : (parent) == (ads->childw).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      145U, "checkc_queue_childw");
        }
      }
#line 136
      if (! ((unsigned int )parent->state == 2U)) {
        {
#line 136
        __assert_fail("parent->state == query_childw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      145U, "checkc_queue_childw");
        }
      }
#line 136
      if (! parent->children.head) {
        {
#line 136
        __assert_fail("parent->children.head", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      145U, "checkc_queue_childw");
        }
      }
#line 136
      if (parent->children.head) {
#line 136
        if (! (! (parent->children.head)->siblings.back)) {
          {
#line 136
          __assert_fail("! (parent->children).head->siblings. back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        145U, "checkc_queue_childw");
          }
        }
#line 136
        child = parent->children.head;
        {
#line 136
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 136
          if (! child) {
#line 136
            goto while_break___0;
          }
#line 136
          if (child->siblings.next) {
#line 136
            tmp___0 = (unsigned long )child == (unsigned long )(child->siblings.next)->siblings.back;
          } else {
#line 136
            tmp___0 = (unsigned long )child == (unsigned long )parent->children.tail;
          }
#line 136
          if (! tmp___0) {
            {
#line 136
            __assert_fail("(child)->siblings. next ? (child) == (child)->siblings. next->siblings. back : (child) == (parent->children).tail",
                          "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                          145U, "checkc_queue_childw");
            }
          }
#line 136
          if (! ((unsigned long )child->parent == (unsigned long )parent)) {
            {
#line 136
            __assert_fail("child->parent == parent", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                          145U, "checkc_queue_childw");
            }
          }
#line 136
          if (! ((unsigned int )child->state != 3U)) {
            {
#line 136
            __assert_fail("child->state != query_done", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                          145U, "checkc_queue_childw");
            }
          }
#line 136
          child = child->siblings.next;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 136
      checkc_query(ads___7, parent);
#line 136
      checkc_query_alloc(ads___7, parent);
#line 136
      parent = parent->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 146
  return;
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_queue_output(adns_state ads___7 ) 
{ 
  adns_query qu ;
  int tmp ;

  {
#line 151
  if (ads___7->output.head) {
#line 151
    if (! (! (ads___7->output.head)->back)) {
      {
#line 151
      __assert_fail("! (ads->output).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    157U, "checkc_queue_output");
      }
    }
#line 151
    qu = ads___7->output.head;
    {
#line 151
    while (1) {
      while_continue: /* CIL Label */ ;
#line 151
      if (! qu) {
#line 151
        goto while_break;
      }
#line 151
      if (qu->next) {
#line 151
        tmp = (unsigned long )qu == (unsigned long )(qu->next)->back;
      } else {
#line 151
        tmp = (unsigned long )qu == (unsigned long )ads___7->output.tail;
      }
#line 151
      if (! tmp) {
        {
#line 151
        __assert_fail("(qu)-> next ? (qu) == (qu)-> next-> back : (qu) == (ads->output).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! ((unsigned int )qu->state == 3U)) {
        {
#line 151
        __assert_fail("qu->state == query_done", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! qu->children.head) {
#line 151
        if (! (! qu->children.tail)) {
          {
#line 151
          __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        157U, "checkc_queue_output");
          }
        }
      } else {
        {
#line 151
        __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! (! qu->parent)) {
        {
#line 151
        __assert_fail("!qu->parent", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! qu->allocations.head) {
#line 151
        if (! (! qu->allocations.tail)) {
          {
#line 151
          __assert_fail("!qu->allocations.head && !qu->allocations.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        157U, "checkc_queue_output");
          }
        }
      } else {
        {
#line 151
        __assert_fail("!qu->allocations.head && !qu->allocations.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
      {
#line 151
      checkc_query(ads___7, qu);
#line 151
      qu = qu->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 158
  return;
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
void adns__consistency(adns_state ads___7 , adns_query qu , consistency_checks cc ) 
{ 
  adns_query search ;

  {
  {
#line 164
  if ((unsigned int )cc == 0U) {
#line 164
    goto case_0;
  }
#line 166
  if ((unsigned int )cc == 1U) {
#line 166
    goto case_1;
  }
#line 169
  if ((unsigned int )cc == 2U) {
#line 169
    goto case_2;
  }
#line 172
  goto switch_default;
  case_0: /* CIL Label */ 
#line 165
  goto switch_break;
  case_1: /* CIL Label */ 
#line 167
  if (! ((unsigned int )ads___7->iflags & 256U)) {
#line 167
    return;
  }
#line 168
  goto switch_break;
  case_2: /* CIL Label */ 
#line 170
  if (((unsigned int )ads___7->iflags & 768U) != 768U) {
#line 170
    return;
  }
#line 171
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 173
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 176
  checkc_global(ads___7);
#line 177
  checkc_queue_udpw(ads___7);
#line 178
  checkc_queue_tcpw(ads___7);
#line 179
  checkc_queue_childw(ads___7);
#line 180
  checkc_queue_output(ads___7);
  }
#line 182
  if (qu) {
    {
#line 184
    if ((unsigned int )qu->state == 0U) {
#line 184
      goto case_0___0;
    }
#line 187
    if ((unsigned int )qu->state == 1U) {
#line 187
      goto case_1___0;
    }
#line 190
    if ((unsigned int )qu->state == 2U) {
#line 190
      goto case_2___0;
    }
#line 193
    if ((unsigned int )qu->state == 3U) {
#line 193
      goto case_3;
    }
#line 196
    goto switch_default___0;
    case_0___0: /* CIL Label */ 
    {
#line 185
    while (1) {
      while_continue: /* CIL Label */ ;
#line 185
      search = ads___7->udpw.head;
      {
#line 185
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 185
        if (! ((unsigned long )search != (unsigned long )qu)) {
#line 185
          goto while_break___0;
        }
#line 185
        if (! search) {
          {
#line 185
          __assert_fail("(search)", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        185U, "adns__consistency");
          }
        }
#line 185
        search = search->next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 185
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 186
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
    {
#line 188
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 188
      search = ads___7->tcpw.head;
      {
#line 188
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 188
        if (! ((unsigned long )search != (unsigned long )qu)) {
#line 188
          goto while_break___2;
        }
#line 188
        if (! search) {
          {
#line 188
          __assert_fail("(search)", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        188U, "adns__consistency");
          }
        }
#line 188
        search = search->next;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 188
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 189
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 191
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 191
      search = ads___7->childw.head;
      {
#line 191
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 191
        if (! ((unsigned long )search != (unsigned long )qu)) {
#line 191
          goto while_break___4;
        }
#line 191
        if (! search) {
          {
#line 191
          __assert_fail("(search)", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        191U, "adns__consistency");
          }
        }
#line 191
        search = search->next;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 191
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 192
    goto switch_break___0;
    case_3: /* CIL Label */ 
    {
#line 194
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 194
      search = ads___7->output.head;
      {
#line 194
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 194
        if (! ((unsigned long )search != (unsigned long )qu)) {
#line 194
          goto while_break___6;
        }
#line 194
        if (! search) {
          {
#line 194
          __assert_fail("(search)", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        194U, "adns__consistency");
          }
        }
#line 194
        search = search->next;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 194
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 195
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 197
    __assert_fail("!\"specific query state\"", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  197U, "adns__consistency");
    }
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 200
  return;
}
}
#line 566 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/adns.h"
int adns_wait_poll(adns_state ads___7 , adns_query *query_io , adns_answer **answer_r ,
                   void **context_r ) ;
#line 787
int adns_beforepoll(adns_state ads___7 , struct pollfd *fds , int *nfds_io , int *timeout_io ,
                    struct timeval  const  *now ) ;
#line 840
void adns_afterpoll(adns_state ads___7 , struct pollfd  const  *fds , int nfds , struct timeval  const  *now ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/poll.c"
int adns_beforepoll(adns_state ads___7 , struct pollfd *fds , int *nfds_io , int *timeout_io ,
                    struct timeval  const  *now ) 
{ 
  struct timeval tv_nowbuf ;
  struct timeval tv_tobuf ;
  struct timeval *tv_to ;
  int space ;
  int found ;
  int timeout_ms ;
  int r ;
  struct pollfd fds_tmp[2] ;

  {
  {
#line 40
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
  }
#line 42
  if (timeout_io) {
    {
#line 43
    adns__must_gettimeofday(ads___7, & now, & tv_nowbuf);
    }
#line 44
    if (! now) {
#line 44
      *nfds_io = 0;
#line 44
      r = 0;
#line 44
      goto xit;
    }
#line 46
    timeout_ms = *timeout_io;
#line 47
    if (timeout_ms == -1) {
#line 48
      tv_to = (struct timeval *)0;
    } else {
#line 50
      tv_tobuf.tv_sec = (__time_t )(timeout_ms / 1000);
#line 51
      tv_tobuf.tv_usec = (__suseconds_t )((timeout_ms % 1000) * 1000);
#line 52
      tv_to = & tv_tobuf;
    }
    {
#line 55
    adns__timeouts(ads___7, 0, & tv_to, & tv_tobuf, (struct timeval )*now);
    }
#line 57
    if (tv_to) {
#line 58
      if (! ((unsigned long )tv_to == (unsigned long )(& tv_tobuf))) {
        {
#line 58
        __assert_fail("tv_to == &tv_tobuf", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/poll.c",
                      58U, "adns_beforepoll");
        }
      }
#line 59
      timeout_ms = (int )((tv_tobuf.tv_usec + 999L) / 1000L);
#line 60
      if (! (tv_tobuf.tv_sec < (__time_t )((2147483647 - timeout_ms) / 1000))) {
        {
#line 60
        __assert_fail("tv_tobuf.tv_sec < (2147483647-timeout_ms)/1000", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/poll.c",
                      60U, "adns_beforepoll");
        }
      }
#line 61
      timeout_ms = (int )((__time_t )timeout_ms + tv_tobuf.tv_sec * 1000L);
    } else {
#line 63
      timeout_ms = -1;
    }
#line 65
    *timeout_io = timeout_ms;
  }
#line 68
  space = *nfds_io;
#line 69
  if (space >= 2) {
    {
#line 70
    found = adns__pollfds(ads___7, (struct pollfd *)fds);
#line 71
    *nfds_io = found;
    }
  } else {
    {
#line 73
    found = adns__pollfds(ads___7, (struct pollfd *)(fds_tmp));
#line 74
    *nfds_io = found;
    }
#line 75
    if (space < found) {
#line 75
      r = 34;
#line 75
      goto xit;
    }
    {
#line 76
    memcpy((void */* __restrict  */)fds, (void const   */* __restrict  */)(fds_tmp),
           sizeof(struct pollfd ) * (unsigned long )found);
    }
  }
#line 78
  r = 0;
  xit: 
  {
#line 80
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
  }
#line 81
  return (r);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/poll.c"
void adns_afterpoll(adns_state ads___7 , struct pollfd  const  *fds , int nfds , struct timeval  const  *now ) 
{ 
  struct timeval tv_buf ;

  {
  {
#line 88
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
#line 89
  adns__must_gettimeofday(ads___7, & now, & tv_buf);
  }
#line 90
  if (now) {
    {
#line 91
    adns__timeouts(ads___7, 1, (struct timeval **)0, (struct timeval *)0, (struct timeval )*now);
#line 92
    adns__fdevents(ads___7, fds, nfds, 0, (fd_set const   *)0, (fd_set const   *)0,
                   (fd_set const   *)0, (struct timeval )*now, (int *)0);
    }
  }
  {
#line 94
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
  }
#line 95
  return;
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/poll.c"
int adns_wait_poll(adns_state ads___7 , adns_query *query_io , adns_answer **answer_r ,
                   void **context_r ) 
{ 
  int r ;
  int nfds ;
  int to ;
  struct pollfd fds[2] ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 104
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
  }
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 107
    r = adns__internal_check(ads___7, query_io, answer_r, context_r);
    }
#line 108
    if (r != 11) {
#line 108
      goto xit;
    }
    {
#line 109
    nfds = 2;
#line 109
    to = -1;
#line 110
    adns_beforepoll(ads___7, fds, & nfds, & to, (struct timeval  const  *)0);
#line 111
    r = Hpoll(fds, nfds, to);
    }
#line 112
    if (r == -1) {
      {
#line 113
      tmp___1 = __errno_location();
      }
#line 113
      if (*tmp___1 == 4) {
#line 114
        if ((unsigned int )ads___7->iflags & 32U) {
#line 114
          r = 4;
#line 114
          goto xit;
        }
      } else {
        {
#line 116
        tmp = __errno_location();
#line 116
        tmp___0 = strerror(*tmp);
#line 116
        adns__diag(ads___7, -1, (adns_query )0, "poll failed in wait: %s", tmp___0);
#line 117
        adns_globalsystemfailure(ads___7);
        }
      }
    } else {
#line 120
      if (! (r >= 0)) {
        {
#line 120
        __assert_fail("r >= 0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/poll.c",
                      120U, "adns_wait_poll");
        }
      }
      {
#line 121
      adns_afterpoll(ads___7, (struct pollfd  const  *)(fds), nfds, (struct timeval  const  *)0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  xit: 
  {
#line 126
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
  }
#line 127
  return (r);
}
}
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/client.h"
 __attribute__((__noreturn__)) void quitnow(int rc ) ;
#line 87 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnshost.h"
void of_config(struct optioninfo  const  *oi , char const   *arg , char const   *arg2 ) ;
#line 87
void of_type(struct optioninfo  const  *oi , char const   *arg , char const   *arg2 ) ;
#line 90
struct optioninfo  const  *opt_findl(char const   *opt ) ;
#line 91
struct optioninfo  const  *opt_finds(char const   **optp ) ;
#line 92
void opt_do(struct optioninfo  const  *oip , int invert , char const   *arg , char const   *arg2 ) ;
#line 125 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnshost.h"
int rcode  ;
#line 126 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnshost.h"
char const   *config_text  ;
#line 33 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-main.c"
static int used  ;
#line 33 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-main.c"
static int avail  ;
#line 34 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-main.c"
static char *buf___0  ;
#line 36
 __attribute__((__noreturn__)) void quitnow(int rc ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-main.c"
void quitnow(int rc ) 
{ 


  {
#line 37
  if (ads) {
    {
#line 37
    adns_finish(ads);
    }
  }
  {
#line 38
  Hfree((void *)buf___0);
#line 39
  Hfree((void *)ov_id);
#line 40
  Hexit(rc);
  }
}
}
#line 43
 __attribute__((__noreturn__)) void sysfail(char const   *what , int errnoval ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-main.c"
void sysfail(char const   *what , int errnoval ) 
{ 
  char *tmp ;

  {
  {
#line 44
  tmp = strerror(errnoval);
#line 44
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adnshost failed: %s: %s\n",
          what, tmp);
#line 45
  quitnow(10);
  }
}
}
#line 48
 __attribute__((__noreturn__)) void ( /* format attribute */  usageerr)(char const   *fmt 
                                                                        , ...) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-main.c"
void ( /* format attribute */  usageerr)(char const   *fmt  , ...) 
{ 
  va_list al ;

  {
  {
#line 50
  fputs((char const   */* __restrict  */)"adnshost usage error: ", (FILE */* __restrict  */)stderr);
#line 51
  __builtin_va_start(al, fmt);
#line 52
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           al);
#line 53
  __builtin_va_end(al);
#line 54
  _IO_putc('\n', stderr);
#line 55
  quitnow(11);
  }
}
}
#line 58
 __attribute__((__noreturn__)) void outerr(void) ;
#line 58 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-main.c"
void outerr(void) 
{ 
  int *tmp ;

  {
  {
#line 59
  tmp = __errno_location();
#line 59
  sysfail("write to stdout", *tmp);
  }
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-main.c"
void *xmalloc(size_t sz ) 
{ 
  void *p ;

  {
  {
#line 65
  p = Hmalloc(sz);
  }
#line 65
  if (! p) {
    {
#line 65
    sysfail("malloc", (int )sz);
    }
  }
#line 66
  return (p);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-main.c"
char *xstrsave(char const   *str ) 
{ 
  char *p ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 72
  tmp = strlen(str);
#line 72
  tmp___0 = xmalloc(tmp + 1UL);
#line 72
  p = (char *)tmp___0;
#line 73
  strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)str);
  }
#line 74
  return (p);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-main.c"
void of_config(struct optioninfo  const  *oi , char const   *arg , char const   *arg2 ) 
{ 


  {
#line 78
  config_text = arg;
#line 79
  return;
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-main.c"
static struct typename  const  typenames[18]  = 
#line 82
  {      {(adns_rrtype )65538, "ns"}, 
        {(adns_rrtype )131078, "soa"}, 
        {(adns_rrtype )65548, "ptr"}, 
        {(adns_rrtype )65551, "mx"}, 
        {(adns_rrtype )131089, "rp"}, 
        {(adns_rrtype )65569, "srv"}, 
        {(adns_rrtype )65537, "addr"}, 
        {(adns_rrtype )5, "cname"}, 
        {(adns_rrtype )13, "hinfo"}, 
        {(adns_rrtype )16, "txt"}, 
        {(adns_rrtype )1, "a"}, 
        {(adns_rrtype )2, "ns-"}, 
        {(adns_rrtype )6, "soa-"}, 
        {(adns_rrtype )12, "ptr-"}, 
        {(adns_rrtype )15, "mx-"}, 
        {(adns_rrtype )17, "rp-"}, 
        {(adns_rrtype )33, "srv-"}, 
        {(adns_rrtype )0, (char const   *)0}};
#line 81 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-main.c"
void of_type(struct optioninfo  const  *oi , char const   *arg , char const   *arg2 ) 
{ 
  struct typename  const  *tnp ;
  unsigned long unknowntype ;
  char *ep ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 116
  tmp = strlen(arg);
  }
#line 116
  if (tmp > 4UL) {
    {
#line 116
    tmp___0 = memcmp((void const   *)arg, (void const   *)"type", (size_t )4);
    }
#line 116
    if (! tmp___0) {
      {
#line 116
      unknowntype = strtoul((char const   */* __restrict  */)(arg + 4), (char **/* __restrict  */)(& ep),
                            10);
      }
#line 116
      if (! *ep) {
#line 116
        if (unknowntype < 65536UL) {
#line 118
          ov_type = (adns_rrtype )(unknowntype | 262144UL);
#line 119
          return;
        }
      }
    }
  }
#line 122
  tnp = typenames;
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 122
    if (tnp->type) {
      {
#line 122
      tmp___1 = strcmp(arg, (char const   *)tnp->desc);
      }
#line 122
      if (! tmp___1) {
#line 122
        goto while_break;
      }
    } else {
#line 122
      goto while_break;
    }
#line 122
    tnp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 125
  if (! tnp->type) {
    {
#line 125
    usageerr("unknown RR type %s", arg);
    }
  }
#line 126
  ov_type = (adns_rrtype )tnp->type;
#line 127
  return;
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-main.c"
static void process_optarg(char const   *arg , char const   * const  **argv_p , char const   *value ) 
{ 
  struct optioninfo  const  *oip ;
  char const   *arg2 ;
  int invert ;
  int tmp ;

  {
#line 136
  if ((int const   )*(arg + 0) == 45) {
#line 136
    goto _L___1;
  } else
#line 136
  if ((int const   )*(arg + 0) == 43) {
    _L___1: /* CIL Label */ 
#line 137
    if ((int const   )*(arg + 0) == 45) {
#line 137
      if ((int const   )*(arg + 1) == 45) {
        {
#line 138
        tmp = strncmp(arg, "--no-", (size_t )5);
        }
#line 138
        if (tmp) {
          {
#line 142
          invert = 0;
#line 143
          oip = opt_findl(arg + 2);
          }
        } else {
          {
#line 139
          invert = 1;
#line 140
          oip = opt_findl(arg + 5);
          }
        }
#line 145
        if ((unsigned int const   )oip->type == 5U) {
#line 146
          if (argv_p) {
#line 146
            (*argv_p) ++;
#line 146
            arg = (char const   *)*(*argv_p);
          } else {
#line 146
            arg = value;
          }
#line 147
          if (! arg) {
            {
#line 147
            usageerr("option --%s requires a value argument", oip->lopt);
            }
          }
#line 148
          arg2 = (char const   *)0;
        } else
#line 149
        if ((unsigned int const   )oip->type == 6U) {
#line 150
          if (! argv_p) {
            {
#line 150
            __assert_fail("argv_p", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-main.c",
                          150U, "process_optarg");
            }
          }
#line 151
          (*argv_p) ++;
#line 151
          arg = (char const   *)*(*argv_p);
#line 152
          if (arg) {
#line 152
            (*argv_p) ++;
#line 152
            arg2 = (char const   *)*(*argv_p);
          } else {
#line 152
            arg2 = (char const   *)0;
          }
#line 153
          if (! arg) {
            {
#line 154
            usageerr("option --%s requires two more arguments", oip->lopt);
            }
          } else
#line 153
          if (! arg2) {
            {
#line 154
            usageerr("option --%s requires two more arguments", oip->lopt);
            }
          }
        } else {
#line 156
          if (value) {
            {
#line 156
            usageerr("option --%s does not take a value", oip->lopt);
            }
          }
#line 157
          arg = (char const   *)0;
#line 158
          arg2 = (char const   *)0;
        }
        {
#line 160
        opt_do(oip, invert, arg, arg2);
        }
      } else {
#line 137
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 161
    if ((int const   )*(arg + 0) == 45) {
#line 161
      if ((int const   )*(arg + 1) == 0) {
#line 162
        if (argv_p) {
#line 162
          (*argv_p) ++;
#line 162
          arg = (char const   *)*(*argv_p);
        } else {
#line 162
          arg = value;
        }
#line 163
        if (! arg) {
          {
#line 163
          usageerr("option `-\' must be followed by a domain");
          }
        }
        {
#line 164
        query_do(arg);
        }
      } else {
#line 161
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 166
      invert = (int const   )*(arg + 0) == 43;
#line 167
      arg ++;
      {
#line 168
      while (1) {
        while_continue: /* CIL Label */ ;
#line 168
        if (! *arg) {
#line 168
          goto while_break;
        }
        {
#line 169
        oip = opt_finds(& arg);
        }
#line 170
        if ((unsigned int const   )oip->type == 5U) {
#line 171
          if (! *arg) {
#line 172
            if (argv_p) {
#line 172
              (*argv_p) ++;
#line 172
              arg = (char const   *)*(*argv_p);
            } else {
#line 172
              arg = value;
            }
#line 173
            if (! arg) {
              {
#line 173
              usageerr("option -%s requires a value argument", oip->sopt);
              }
            }
          } else
#line 175
          if (value) {
            {
#line 175
            usageerr("two values for option -%s given !", oip->sopt);
            }
          }
          {
#line 177
          opt_do(oip, invert, arg, (char const   *)0);
#line 178
          arg = "";
          }
        } else {
#line 180
          if (value) {
            {
#line 180
            usageerr("option -%s does not take a value", oip->sopt);
            }
          }
          {
#line 181
          opt_do(oip, invert, (char const   *)0, (char const   *)0);
          }
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 186
    query_do(arg);
    }
  }
#line 188
  return;
}
}
#line 190 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-main.c"
static void read_stdin(void) 
{ 
  int anydone ;
  int r ;
  char *newline ;
  char *space ;
  void *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
#line 194
  anydone = 0;
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 195
    if (! (! anydone)) {
#line 195
      if (! used) {
#line 195
        goto while_break;
      }
    }
    {
#line 196
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 196
      tmp___4 = memchr((void const   *)buf___0, '\n', (size_t )used);
#line 196
      newline = (char *)tmp___4;
      }
#line 196
      if (newline) {
#line 196
        goto while_break___0;
      }
#line 197
      if (used == avail) {
        {
#line 198
        avail += 20;
#line 198
        avail <<= 1;
#line 199
        tmp = Hrealloc((void *)buf___0, (size_t )avail);
#line 199
        buf___0 = (char *)tmp;
        }
#line 200
        if (! buf___0) {
          {
#line 200
          tmp___0 = __errno_location();
#line 200
          sysfail("realloc stdin buffer", *tmp___0);
          }
        }
      }
      {
#line 202
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 203
        r = Hread(0, (void *)(buf___0 + used), (size_t )(avail - used));
        }
#line 202
        if (r < 0) {
          {
#line 202
          tmp___1 = __errno_location();
          }
#line 202
          if (! (*tmp___1 == 4)) {
#line 202
            goto while_break___1;
          }
        } else {
#line 202
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 205
      if (r == 0) {
#line 206
        if (used) {
#line 208
          tmp___2 = used;
#line 208
          used ++;
#line 208
          *(buf___0 + tmp___2) = (char )'\n';
#line 209
          r = 1;
        } else {
#line 211
          ov_pipe = 0;
#line 212
          return;
        }
      }
#line 215
      if (r < 0) {
        {
#line 215
        tmp___3 = __errno_location();
#line 215
        sysfail("read stdin", *tmp___3);
        }
      }
#line 216
      used += r;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 218
    tmp___5 = newline;
#line 218
    newline ++;
#line 218
    *tmp___5 = (char)0;
#line 219
    space = strchr((char const   *)buf___0, ' ');
    }
#line 220
    if (space) {
#line 220
      tmp___6 = space;
#line 220
      space ++;
#line 220
      *tmp___6 = (char)0;
    }
    {
#line 221
    process_optarg((char const   *)buf___0, (char const   * const  **)0, (char const   *)space);
#line 222
    used = (int )((long )used - (newline - buf___0));
#line 223
    memmove((void *)buf___0, (void const   *)newline, (size_t )used);
#line 224
    anydone = 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 226
  return;
}
}
#line 228 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-main.c"
int main(int argc , char const   * const  *argv ) 
{ 
  struct timeval *tv ;
  struct timeval tvbuf ;
  adns_query qu ;
  void *qun_v ;
  adns_answer *answer ;
  int r ;
  int maxfd ;
  fd_set readfds ;
  fd_set writefds ;
  fd_set exceptfds ;
  char const   *arg ;
  adns_query tmp ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int __d0___1 ;
  int __d1___1 ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 237
  while (1) {
    while_continue: /* CIL Label */ ;
#line 237
    argv ++;
#line 237
    arg = (char const   *)*argv;
#line 237
    if (! arg) {
#line 237
      goto while_break;
    }
    {
#line 237
    process_optarg(arg, & argv, (char const   *)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 239
  if (! ov_pipe) {
#line 239
    if (! ads) {
      {
#line 239
      usageerr("no domains given, and -f/--pipe not used; try --help");
      }
    }
  }
  {
#line 241
  ensure_adns_init();
  }
  {
#line 243
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 244
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 245
      if (ov_asynch) {
#line 245
        qu = (adns_query )0;
      } else {
#line 245
        if (outstanding.head) {
#line 245
          tmp = (outstanding.head)->qu;
        } else {
#line 245
          tmp = (adns_query )0;
        }
#line 245
        qu = tmp;
      }
      {
#line 246
      r = adns_check(ads, & qu, & answer, & qun_v);
      }
#line 247
      if (r == 11) {
#line 247
        goto while_break___1;
      }
#line 248
      if (r == 3) {
#line 248
        if (! ov_pipe) {
#line 248
          goto x_quit;
        } else {
#line 248
          goto while_break___1;
        }
      }
#line 249
      if (! (! r)) {
        {
#line 249
        __assert_fail("!r", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-main.c",
                      249U, "main");
        }
      }
      {
#line 250
      query_done((struct query_node *)qun_v, answer);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 252
    maxfd = 0;
    {
#line 253
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 253
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& readfds.__fds_bits[0]): "memory");
#line 253
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 254
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 254
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& writefds.__fds_bits[0]): "memory");
#line 254
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 255
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 255
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0___1), "=D" (__d1___1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& exceptfds.__fds_bits[0]): "memory");
#line 255
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 256
    if (ov_pipe) {
#line 257
      maxfd = 1;
#line 258
      readfds.__fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] |= 1L << 0 % (8 * (int )sizeof(__fd_mask ));
    }
    {
#line 260
    tv = (struct timeval *)0;
#line 261
    adns_beforeselect(ads, & maxfd, & readfds, & writefds, & exceptfds, & tv, & tvbuf,
                      (struct timeval  const  *)0);
#line 262
    r = Hselect(maxfd, & readfds, & writefds, & exceptfds, tv);
    }
#line 263
    if (r == -1) {
      {
#line 264
      tmp___0 = __errno_location();
      }
#line 264
      if (*tmp___0 == 4) {
#line 264
        goto __Cont;
      }
      {
#line 265
      tmp___1 = __errno_location();
#line 265
      sysfail("select", *tmp___1);
      }
    }
    {
#line 267
    adns_afterselect(ads, maxfd, (fd_set const   *)(& readfds), (fd_set const   *)(& writefds),
                     (fd_set const   *)(& exceptfds), (struct timeval  const  *)0);
    }
#line 268
    if (ov_pipe) {
#line 268
      if ((readfds.__fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] & (1L << 0 % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 268
        read_stdin();
        }
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  x_quit: 
  {
#line 271
  tmp___2 = fclose(stdout);
  }
#line 271
  if (tmp___2) {
    {
#line 271
    outerr();
    }
  }
  {
#line 272
  quitnow(rcode);
  }
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/transmit.c"
static adns_status mkquery_header(adns_state ads___7 , vbuf *vb___0 , int *id_r ,
                                  int qdlen ) 
{ 
  int id ;
  byte *rqp ;
  int tmp ;
  int tmp___0 ;
  byte *tmp___1 ;
  byte *tmp___2 ;
  byte *tmp___3 ;
  byte *tmp___4 ;
  byte *tmp___5 ;
  byte *tmp___6 ;
  byte *tmp___7 ;
  byte *tmp___8 ;
  byte *tmp___9 ;
  byte *tmp___10 ;
  byte *tmp___11 ;
  byte *tmp___12 ;

  {
  {
#line 46
  tmp = adns__vbuf_ensure(vb___0, (12 + qdlen) + 4);
  }
#line 46
  if (! tmp) {
#line 46
    return ((adns_status )1);
  }
#line 48
  vb___0->used = 0;
#line 49
  rqp = vb___0->buf + vb___0->used;
#line 51
  tmp___0 = ads___7->nextid;
#line 51
  (ads___7->nextid) ++;
#line 51
  id = tmp___0 & 65535;
#line 51
  *id_r = id;
#line 52
  tmp___1 = rqp;
#line 52
  rqp ++;
#line 52
  *tmp___1 = (byte )((id >> 8) & 255);
#line 52
  tmp___2 = rqp;
#line 52
  rqp ++;
#line 52
  *tmp___2 = (byte )(id & 255);
#line 53
  tmp___3 = rqp;
#line 53
  rqp ++;
#line 53
  *tmp___3 = (byte )1;
#line 54
  tmp___4 = rqp;
#line 54
  rqp ++;
#line 54
  *tmp___4 = (byte )0;
#line 55
  tmp___5 = rqp;
#line 55
  rqp ++;
#line 55
  *tmp___5 = (byte )((1 >> 8) & 255);
#line 55
  tmp___6 = rqp;
#line 55
  rqp ++;
#line 55
  *tmp___6 = (byte )1;
#line 56
  tmp___7 = rqp;
#line 56
  rqp ++;
#line 56
  *tmp___7 = (byte )0;
#line 56
  tmp___8 = rqp;
#line 56
  rqp ++;
#line 56
  *tmp___8 = (byte )0;
#line 57
  tmp___9 = rqp;
#line 57
  rqp ++;
#line 57
  *tmp___9 = (byte )0;
#line 57
  tmp___10 = rqp;
#line 57
  rqp ++;
#line 57
  *tmp___10 = (byte )0;
#line 58
  tmp___11 = rqp;
#line 58
  rqp ++;
#line 58
  *tmp___11 = (byte )0;
#line 58
  tmp___12 = rqp;
#line 58
  rqp ++;
#line 58
  *tmp___12 = (byte )0;
#line 60
  vb___0->used = (int )(rqp - vb___0->buf);
#line 62
  return ((adns_status )0);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/transmit.c"
static adns_status mkquery_footer(vbuf *vb___0 , adns_rrtype type ) 
{ 
  byte *rqp ;
  byte *tmp ;
  byte *tmp___0 ;
  byte *tmp___1 ;
  byte *tmp___2 ;

  {
#line 68
  rqp = vb___0->buf + vb___0->used;
#line 69
  tmp = rqp;
#line 69
  rqp ++;
#line 69
  *tmp = (byte )((((unsigned int )type & 65535U) >> 8) & 255U);
#line 69
  tmp___0 = rqp;
#line 69
  rqp ++;
#line 69
  *tmp___0 = (byte )(((unsigned int )type & 65535U) & 255U);
#line 70
  tmp___1 = rqp;
#line 70
  rqp ++;
#line 70
  *tmp___1 = (byte )((1 >> 8) & 255);
#line 70
  tmp___2 = rqp;
#line 70
  rqp ++;
#line 70
  *tmp___2 = (byte )1;
#line 71
  vb___0->used = (int )(rqp - vb___0->buf);
#line 72
  if (! (vb___0->used <= vb___0->avail)) {
    {
#line 72
    __assert_fail("vb->used <= vb->avail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/transmit.c",
                  72U, "mkquery_footer");
    }
  }
#line 74
  return ((adns_status )0);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/transmit.c"
adns_status adns__qdpl_normal(adns_state ads___7 , char const   **p_io , char const   *pe ,
                              int labelnum , char *label_r , int *ll_io , adns_queryflags flags ,
                              typeinfo const   *typei ) 
{ 
  int ll ;
  int c ;
  char const   *p ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;

  {
#line 85
  ll = 0;
#line 86
  p = *p_io;
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if ((unsigned long )p != (unsigned long )pe) {
#line 88
      tmp___9 = p;
#line 88
      p ++;
#line 88
      c = (int )*tmp___9;
#line 88
      if (! (c != 46)) {
#line 88
        goto while_break;
      }
    } else {
#line 88
      goto while_break;
    }
#line 89
    if (c == 92) {
#line 90
      if (! ((unsigned int )flags & 16U)) {
#line 90
        return ((adns_status )201);
      }
      {
#line 91
      tmp___5 = ctype_digit((int )*(p + 0));
      }
#line 91
      if (tmp___5) {
#line 92
        if ((unsigned long )(p + 1) == (unsigned long )pe) {
#line 92
          return ((adns_status )201);
        } else
#line 92
        if ((unsigned long )(p + 2) == (unsigned long )pe) {
#line 92
          return ((adns_status )201);
        }
        {
#line 93
        tmp___2 = ctype_digit((int )*(p + 1));
        }
#line 93
        if (tmp___2) {
          {
#line 93
          tmp___3 = ctype_digit((int )*(p + 2));
          }
#line 93
          if (tmp___3) {
#line 94
            tmp = p;
#line 94
            p ++;
#line 94
            c = (int )(((int const   )*tmp - 48) * 100);
#line 95
            tmp___0 = p;
#line 95
            p ++;
#line 95
            c += (int )(((int const   )*tmp___0 - 48) * 10);
#line 96
            tmp___1 = p;
#line 96
            p ++;
#line 96
            c += (int )((int const   )*tmp___1 - 48);
#line 97
            if (c >= 256) {
#line 97
              return ((adns_status )201);
            }
          } else {
#line 99
            return ((adns_status )201);
          }
        } else {
#line 99
          return ((adns_status )201);
        }
      } else {
#line 101
        tmp___4 = p;
#line 101
        p ++;
#line 101
        c = (int )*tmp___4;
#line 101
        if (! c) {
#line 102
          return ((adns_status )201);
        }
      }
    }
#line 105
    if (! ((unsigned int )flags & 16U)) {
#line 106
      if (c == 45) {
#line 107
        if (! ll) {
#line 107
          return ((adns_status )201);
        }
      } else {
        {
#line 108
        tmp___6 = ctype_alpha(c);
        }
#line 108
        if (! tmp___6) {
          {
#line 108
          tmp___7 = ctype_digit(c);
          }
#line 108
          if (! tmp___7) {
#line 109
            return ((adns_status )201);
          }
        }
      }
    }
#line 112
    if (ll == *ll_io) {
#line 112
      return ((adns_status )201);
    }
#line 113
    tmp___8 = ll;
#line 113
    ll ++;
#line 113
    *(label_r + tmp___8) = (char )c;
  }
  while_break: /* CIL Label */ ;
  }
#line 116
  *p_io = p;
#line 117
  *ll_io = ll;
#line 118
  return ((adns_status )0);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/transmit.c"
adns_status adns__mkquery(adns_state ads___7 , vbuf *vb___0 , int *id_r , char const   *owner ,
                          int ol , typeinfo const   *typei , adns_rrtype type , adns_queryflags flags ) 
{ 
  int labelnum ;
  int ll ;
  int nbytes ;
  byte label[255] ;
  byte *rqp ;
  char const   *p ;
  char const   *pe ;
  adns_status st ;
  int tmp ;
  byte *tmp___0 ;
  byte *tmp___1 ;

  {
  {
#line 131
  st = mkquery_header(ads___7, vb___0, id_r, ol + 2);
  }
#line 131
  if (st) {
#line 131
    return (st);
  }
#line 133
  rqp = vb___0->buf + vb___0->used;
#line 135
  p = owner;
#line 135
  pe = owner + ol;
#line 136
  nbytes = 0;
#line 137
  labelnum = 0;
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 138
    if (! ((unsigned long )p != (unsigned long )pe)) {
#line 138
      goto while_break;
    }
    {
#line 139
    ll = (int )sizeof(label);
#line 140
    tmp = labelnum;
#line 140
    labelnum ++;
#line 140
    st = (*(typei->qdparselabel))(ads___7, & p, pe, tmp, (char *)(label), & ll, flags,
                                  typei);
    }
#line 141
    if (st) {
#line 141
      return (st);
    }
#line 142
    if (! ll) {
#line 142
      return ((adns_status )201);
    }
#line 143
    if (ll > 63) {
#line 143
      return ((adns_status )202);
    }
#line 144
    nbytes += ll + 1;
#line 145
    if (nbytes >= 255) {
#line 145
      return ((adns_status )202);
    }
    {
#line 146
    tmp___0 = rqp;
#line 146
    rqp ++;
#line 146
    *tmp___0 = (byte )ll;
#line 147
    memcpy((void */* __restrict  */)rqp, (void const   */* __restrict  */)(label),
           (size_t )ll);
#line 147
    rqp += ll;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 149
  tmp___1 = rqp;
#line 149
  rqp ++;
#line 149
  *tmp___1 = (byte )0;
#line 151
  vb___0->used = (int )(rqp - vb___0->buf);
#line 153
  st = mkquery_footer(vb___0, type);
  }
#line 155
  return ((adns_status )0);
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/transmit.c"
adns_status adns__mkquery_frdgram(adns_state ads___7 , vbuf *vb___0 , int *id_r ,
                                  byte const   *qd_dgram , int qd_dglen , int qd_begin ,
                                  adns_rrtype type , adns_queryflags flags ) 
{ 
  byte *rqp ;
  findlabel_state fls ;
  int lablen ;
  int labstart ;
  adns_status st ;
  byte *tmp ;
  byte *tmp___0 ;

  {
  {
#line 167
  st = mkquery_header(ads___7, vb___0, id_r, qd_dglen);
  }
#line 167
  if (st) {
#line 167
    return (st);
  }
  {
#line 169
  rqp = vb___0->buf + vb___0->used;
#line 171
  adns__findlabel_start(& fls, ads___7, -1, (adns_query )0, qd_dgram, qd_dglen, qd_dglen,
                        qd_begin, (int *)0);
  }
  {
#line 172
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 173
    st = adns__findlabel_next(& fls, & lablen, & labstart);
    }
#line 173
    if (! (! st)) {
      {
#line 173
      __assert_fail("!st", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/transmit.c",
                    173U, "adns__mkquery_frdgram");
      }
    }
#line 174
    if (! lablen) {
#line 174
      goto while_break;
    }
#line 175
    if (! (lablen < 255)) {
      {
#line 175
      __assert_fail("lablen<255", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/transmit.c",
                    175U, "adns__mkquery_frdgram");
      }
    }
    {
#line 176
    tmp = rqp;
#line 176
    rqp ++;
#line 176
    *tmp = (byte )lablen;
#line 177
    memcpy((void */* __restrict  */)rqp, (void const   */* __restrict  */)(qd_dgram + labstart),
           (size_t )lablen);
#line 178
    rqp += lablen;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 180
  tmp___0 = rqp;
#line 180
  rqp ++;
#line 180
  *tmp___0 = (byte )0;
#line 182
  vb___0->used = (int )(rqp - vb___0->buf);
#line 184
  st = mkquery_footer(vb___0, type);
  }
#line 186
  return ((adns_status )0);
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/transmit.c"
void adns__querysend_tcp(adns_query qu , struct timeval now ) 
{ 
  byte length[2] ;
  struct iovec iov[2] ;
  int wr ;
  int r ;
  adns_state ads___7 ;
  int tmp ;
  __suseconds_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;

  {
#line 195
  if ((unsigned int )(qu->ads)->tcpstate != 2U) {
#line 195
    return;
  }
#line 197
  if (! ((unsigned int )qu->state == 1U)) {
    {
#line 197
    __assert_fail("qu->state == query_tcpw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/transmit.c",
                  197U, "adns__querysend_tcp");
    }
  }
  {
#line 199
  length[0] = (byte )(((unsigned int )qu->query_dglen & 65280U) >> 8);
#line 200
  length[1] = (byte )(qu->query_dglen & 255);
#line 202
  ads___7 = qu->ads;
#line 203
  tmp = adns__vbuf_ensure(& ads___7->tcpsend, (ads___7->tcpsend.used + qu->query_dglen) + 2);
  }
#line 203
  if (! tmp) {
#line 204
    return;
  }
#line 206
  (qu->retries) ++;
#line 209
  tmp___0 = (__suseconds_t )0;
#line 209
  ads___7->tcptimeout.tv_usec = tmp___0;
#line 209
  ads___7->tcptimeout.tv_sec = tmp___0;
#line 211
  if (ads___7->tcpsend.used) {
#line 212
    wr = 0;
  } else {
    {
#line 214
    iov[0].iov_base = (void *)(length);
#line 215
    iov[0].iov_len = (size_t )2;
#line 216
    iov[1].iov_base = (void *)qu->query_dgram;
#line 217
    iov[1].iov_len = (size_t )qu->query_dglen;
#line 218
    adns__sigpipe_protect(qu->ads);
#line 219
    wr = Hwritev((qu->ads)->tcpsocket, (struct iovec  const  *)(iov), (size_t )2);
#line 220
    adns__sigpipe_unprotect(qu->ads);
    }
#line 221
    if (wr < 0) {
      {
#line 222
      tmp___3 = __errno_location();
      }
#line 222
      if (! (*tmp___3 == 11)) {
        {
#line 222
        tmp___4 = __errno_location();
        }
#line 222
        if (! (*tmp___4 == 4)) {
          {
#line 222
          tmp___5 = __errno_location();
          }
#line 222
          if (! (*tmp___5 == 28)) {
            {
#line 222
            tmp___6 = __errno_location();
            }
#line 222
            if (! (*tmp___6 == 105)) {
              {
#line 222
              tmp___7 = __errno_location();
              }
#line 222
              if (! (*tmp___7 == 12)) {
                {
#line 224
                tmp___1 = __errno_location();
#line 224
                tmp___2 = strerror(*tmp___1);
#line 224
                adns__tcp_broken(ads___7, "write", (char const   *)tmp___2);
                }
#line 225
                return;
              }
            }
          }
        }
      }
#line 227
      wr = 0;
    }
  }
#line 231
  if (wr < 2) {
    {
#line 232
    r = adns__vbuf_append(& ads___7->tcpsend, (byte const   *)(length), 2 - wr);
    }
#line 232
    if (! r) {
      {
#line 232
      __assert_fail("r", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/transmit.c",
                    232U, "adns__querysend_tcp");
      }
    }
#line 233
    wr = 0;
  } else {
#line 235
    wr -= 2;
  }
#line 237
  if (wr < qu->query_dglen) {
    {
#line 238
    r = adns__vbuf_append(& ads___7->tcpsend, (byte const   *)(qu->query_dgram + wr),
                          qu->query_dglen - wr);
    }
#line 239
    if (! r) {
      {
#line 239
      __assert_fail("r", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/transmit.c",
                    239U, "adns__querysend_tcp");
      }
    }
  }
#line 241
  return;
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/transmit.c"
static void query_usetcp(adns_query qu , struct timeval now ) 
{ 


  {
  {
#line 244
  qu->state = (enum __anonenum_state_83 )1;
#line 245
  qu->timeout = now;
#line 246
  timevaladd(& qu->timeout, 30000L);
  }
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    qu->next = (adns_query )0;
#line 247
    qu->back = (qu->ads)->tcpw.tail;
#line 247
    if ((qu->ads)->tcpw.tail) {
#line 247
      ((qu->ads)->tcpw.tail)->next = qu;
    } else {
#line 247
      (qu->ads)->tcpw.head = qu;
    }
#line 247
    (qu->ads)->tcpw.tail = qu;
#line 247
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 248
  adns__querysend_tcp(qu, now);
#line 249
  adns__tcp_tryconnect(qu->ads, now);
  }
#line 250
  return;
}
}
#line 252 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/transmit.c"
void adns__query_send(adns_query qu , struct timeval now ) 
{ 
  struct sockaddr_in servaddr ;
  int serv ;
  int r ;
  adns_state ads___7 ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;

  {
#line 257
  if (! ((unsigned int )qu->state == 0U)) {
    {
#line 257
    __assert_fail("qu->state == query_tosend", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/transmit.c",
                  257U, "adns__query_send");
    }
  }
#line 258
  if (qu->flags & 2) {
    {
#line 259
    query_usetcp(qu, now);
    }
#line 260
    return;
  } else
#line 258
  if (qu->query_dglen > 512) {
    {
#line 259
    query_usetcp(qu, now);
    }
#line 260
    return;
  }
#line 263
  if (qu->retries >= 15) {
    {
#line 264
    adns__query_fail(qu, (adns_status )30);
    }
#line 265
    return;
  }
  {
#line 268
  serv = qu->udpnextserver;
#line 269
  memset((void *)(& servaddr), 0, sizeof(servaddr));
#line 271
  ads___7 = qu->ads;
#line 272
  servaddr.sin_family = (sa_family_t )2;
#line 273
  servaddr.sin_addr = ads___7->servers[serv].addr;
#line 274
  servaddr.sin_port = htons((uint16_t )53);
#line 276
  r = Hsendto(ads___7->udpsocket, (void const   *)qu->query_dgram, qu->query_dglen,
              0U, (struct sockaddr  const  *)(& servaddr), (int )sizeof(servaddr));
  }
#line 278
  if (r < 0) {
    {
#line 278
    tmp = __errno_location();
    }
#line 278
    if (*tmp == 90) {
      {
#line 279
      qu->retries = 0;
#line 280
      query_usetcp(qu, now);
      }
#line 281
      return;
    }
  }
#line 283
  if (r < 0) {
    {
#line 283
    tmp___2 = __errno_location();
    }
#line 283
    if (*tmp___2 != 11) {
      {
#line 284
      tmp___0 = __errno_location();
#line 284
      tmp___1 = strerror(*tmp___0);
#line 284
      adns__warn(ads___7, serv, (adns_query )0, "sendto failed: %s", tmp___1);
      }
    }
  }
  {
#line 286
  qu->timeout = now;
#line 287
  timevaladd(& qu->timeout, 2000L);
#line 288
  qu->udpsent |= (unsigned long )(1 << serv);
#line 289
  qu->udpnextserver = (serv + 1) % ads___7->nservers;
#line 290
  (qu->retries) ++;
  }
  {
#line 291
  while (1) {
    while_continue: /* CIL Label */ ;
#line 291
    qu->next = (adns_query )0;
#line 291
    qu->back = ads___7->udpw.tail;
#line 291
    if (ads___7->udpw.tail) {
#line 291
      (ads___7->udpw.tail)->next = qu;
    } else {
#line 291
      ads___7->udpw.head = qu;
    }
#line 291
    ads___7->udpw.tail = qu;
#line 291
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 292
  return;
}
}
#line 580 "/usr/include/stdio.h"
extern int putchar(int __c ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 87 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnshost.h"
void of_version(struct optioninfo  const  *oi , char const   *arg , char const   *arg2 ) ;
#line 87
void of_help(struct optioninfo  const  *oi , char const   *arg , char const   *arg2 ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-opts.c"
int ov_env  =    1;
#line 30 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-opts.c"
int ov_pipe  =    0;
#line 30 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-opts.c"
int ov_asynch  =    0;
#line 31 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-opts.c"
int ov_verbose  =    0;
#line 32 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-opts.c"
adns_rrtype ov_type  =    (adns_rrtype )0;
#line 33 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-opts.c"
int ov_search  =    0;
#line 33 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-opts.c"
int ov_qc_query  =    0;
#line 33 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-opts.c"
int ov_qc_anshost  =    0;
#line 33 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-opts.c"
int ov_qc_cname  =    1;
#line 34 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-opts.c"
int ov_tcp  =    0;
#line 34 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-opts.c"
int ov_cname  =    0;
#line 34 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-opts.c"
int ov_format  =    0;
#line 35 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-opts.c"
char *ov_id  =    (char *)0;
#line 36 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-opts.c"
struct perqueryflags_remember ov_pqfr  =    {1, 1, 1, 0};
#line 38 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-opts.c"
static struct optioninfo  const  global_options[17]  = 
#line 38
  {      {(enum oi_type )1, "global binary options:", (char const   *)0, (char const   *)0,
      (int *)0, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )2, "Do not look at environment variables at all", "e", "env",
      & ov_env, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )2, "Read queries on stdin instead of using args", "f", "pipe",
      & ov_pipe, 1, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )2, "Allow answers to be reordered", "a", "asynch", & ov_asynch,
      1, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )1, "answer/error output format and destination (see below):",
      (char const   *)0, (char const   *)0, (int *)0, 0, (optfunc *)0, (char const   *)0,
      (char const   *)0}, 
        {(enum oi_type )3, "Answers to stdout, errors as messages to stderr (default)",
      "Fs", "fmt-simple", & ov_format, 1, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )3,
      "Answers and errors both to stdout in parseable format", "Fi", "fmt-inline",
      & ov_format, 2, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )3, "Fully-parseable output format (default for --asynch)", "Fa",
      "fmt-asynch", & ov_format, 3, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )1,
      "global verbosity level:", (char const   *)0, (char const   *)0, (int *)0, 0,
      (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )3, "Do not print anything to stderr", "Vq", "quiet", & ov_verbose,
      2, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )3, "Report unexpected kinds of problem only  (default)", "Vn",
      "no-quiet", & ov_verbose, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )3,
      "Debugging mode", "Vd", "debug", & ov_verbose, 8, (optfunc *)0, (char const   *)0,
      (char const   *)0}, 
        {(enum oi_type )1, "other global options:", (char const   *)0, (char const   *)0,
      (int *)0, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )5, "Configuration to use instead of /etc/resolv.conf", (char const   *)0,
      "config", (int *)0, 0, & of_config, "<config-text>", (char const   *)0}, 
        {(enum oi_type )4, "Print version number", (char const   *)0, "version", (int *)0,
      0, & of_version, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )4, "Print usage information", (char const   *)0, "help", (int *)0,
      0, & of_help, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )0, (char const   *)0, (char const   *)0, (char const   *)0, (int *)0,
      0, (optfunc *)0, (char const   *)0, (char const   *)0}};
#line 74 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-opts.c"
static struct optioninfo  const  perquery_options[25]  = 
#line 74
  {      {(enum oi_type )1, "per-query options:", (char const   *)0, (char const   *)0,
      (int *)0, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )5, "Query type (see below)", "t", "type", (int *)0, 0, & of_type,
      "type", (char const   *)0}, 
        {(enum oi_type )5, "Do reverse query (address -> name lookup)", "i", "ptr", (int *)0,
      0, & of_ptr, "addr", (char const   *)0}, 
        {(enum oi_type )6, "Lookup in in-addr-like `zone\' (eg MAPS RBL)", (char const   *)0,
      "reverse", (int *)0, 0, & of_reverse, "addr", "zone"}, 
        {(enum oi_type )1, "per-query binary options:", (char const   *)0, (char const   *)0,
      (int *)0, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )2, "Use the search list", "s", "search", & ov_search, 1, (optfunc *)0,
      (char const   *)0, (char const   *)0}, 
        {(enum oi_type )2, "Let query domains contain quote-requiring chars", "Qq", "qc-query",
      & ov_qc_query, 1, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )2, "Let hostnames in answers contain ...", "Qa", "qc-anshost",
      & ov_qc_anshost, 1, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )2, "Prevent CNAME target domains from containing ...", "Qc",
      "qc-cname", & ov_qc_cname, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )2,
      "Force use of a virtual circuit", "u", "tcp", & ov_tcp, 1, (optfunc *)0, (char const   *)0,
      (char const   *)0}, 
        {(enum oi_type )2, "Do not display owner name in output", "Do", "show-owner",
      & ov_pqfr.show_owner, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )2,
      "Do not display RR type in output", "Dt", "show-type", & ov_pqfr.show_type,
      0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )2, "Do not display CNAME target in output", "Dc", "show-cname",
      & ov_pqfr.show_cname, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )1,
      "per-query TTL mode (NB TTL is minimum across all info in reply):", (char const   *)0,
      (char const   *)0, (int *)0, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )3,
      "Show the TTL as a TTL", "Tt", "ttl-ttl", & ov_pqfr.ttl, 1, (optfunc *)0, (char const   *)0,
      (char const   *)0}, 
        {(enum oi_type )3, "Show the TTL as a time_t when the data might expire", "Ta",
      "ttl-abs", & ov_pqfr.ttl, 2, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )3,
      "Do not show the TTL (default)", "Tn", "no-ttl", & ov_pqfr.ttl, 0, (optfunc *)0,
      (char const   *)0, (char const   *)0}, 
        {(enum oi_type )1, "per-query CNAME handling mode:", (char const   *)0, (char const   *)0,
      (int *)0, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )3, "Call it an error if a CNAME is found", "Cf", "cname-reject",
      & ov_cname, 512, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )3, "Allow references to CNAMEs in other RRs", "Cl", "cname-loose",
      & ov_cname, 256, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )3, "CNAME ok for query domain, but not in RRs (default)", "Cs",
      "cname-ok", & ov_cname, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )1,
      "asynchronous/pipe mode options:", (char const   *)0, (char const   *)0, (int *)0,
      0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )5, "Set <id>, default is decimal sequence starting 0", (char const   *)0,
      "asynch-id", (int *)0, 0, & of_asynch_id, "id", (char const   *)0}, 
        {(enum oi_type )5, "Cancel the query with id <id> (no error if not found)", (char const   *)0,
      "cancel-id", (int *)0, 0, & of_cancel_id, "id", (char const   *)0}, 
        {(enum oi_type )0, (char const   *)0, (char const   *)0, (char const   *)0, (int *)0,
      0, (optfunc *)0, (char const   *)0, (char const   *)0}};
#line 127
static void printusage(void) ;
#line 127 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-opts.c"
static struct optioninfo  const  * const  all_optiontables[3]  = {      (struct optioninfo  const  */* const  */)(global_options),      (struct optioninfo  const  */* const  */)(perquery_options),      (struct optioninfo  const  */* const  */)0};
#line 126 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-opts.c"
static void printusage(void) 
{ 
  struct optioninfo  const  * const  *oiap ;
  struct optioninfo  const  *oip ;
  int maxsopt ;
  int maxlopt ;
  int l ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  int tmp___13 ;

  {
#line 131
  oip = (struct optioninfo  const  *)0;
#line 134
  maxlopt = 0;
#line 134
  maxsopt = maxlopt;
#line 136
  oiap = all_optiontables;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (! *oiap) {
#line 136
      goto while_break;
    }
#line 137
    oip = (struct optioninfo  const  *)*oiap;
    {
#line 137
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 137
      if (! ((unsigned int const   )oip->type != 0U)) {
#line 137
        goto while_break___0;
      }
#line 138
      if ((unsigned int const   )oip->type == 5U) {
#line 138
        goto __Cont;
      }
#line 139
      if (oip->sopt) {
        {
#line 139
        tmp = strlen((char const   *)oip->sopt);
#line 139
        l = (int )tmp;
        }
#line 139
        if (l > maxsopt) {
#line 139
          maxsopt = l;
        }
      }
#line 140
      if (oip->lopt) {
        {
#line 141
        tmp___0 = strlen((char const   *)oip->lopt);
#line 141
        l = (int )tmp___0;
        }
#line 142
        if ((unsigned int const   )oip->type == 2U) {
#line 142
          if (! oip->value) {
#line 142
            l += 3;
          }
        }
#line 143
        if (l > maxlopt) {
#line 143
          maxlopt = l;
        }
      }
      __Cont: /* CIL Label */ 
#line 137
      oip ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 136
    oiap ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 148
  fputs((char const   */* __restrict  */)"usage: adnshost [global-opts] [query-opts] query-domain\n                             [[query-opts] query-domain ...]\n       adnshost [global-opts] [query-opts] -f|--pipe\n",
        (FILE */* __restrict  */)stdout);
#line 153
  oiap = all_optiontables;
  }
  {
#line 153
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 153
    if (! *oiap) {
#line 153
      goto while_break___1;
    }
    {
#line 154
    putchar('\n');
#line 155
    oip = (struct optioninfo  const  *)*oiap;
    }
    {
#line 155
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 155
      if (! ((unsigned int const   )oip->type != 0U)) {
#line 155
        goto while_break___2;
      }
      {
#line 157
      if ((unsigned int const   )oip->type == 2U) {
#line 157
        goto case_2;
      }
#line 171
      if ((unsigned int const   )oip->type == 4U) {
#line 171
        goto case_4;
      }
#line 171
      if ((unsigned int const   )oip->type == 3U) {
#line 171
        goto case_4;
      }
#line 183
      if ((unsigned int const   )oip->type == 5U) {
#line 183
        goto case_5;
      }
#line 200
      if ((unsigned int const   )oip->type == 6U) {
#line 200
        goto case_6;
      }
#line 209
      if ((unsigned int const   )oip->type == 1U) {
#line 209
        goto case_1;
      }
#line 212
      goto switch_default;
      case_2: /* CIL Label */ 
#line 158
      if (! oip->value) {
#line 159
        if (oip->sopt) {
          {
#line 160
          printf((char const   */* __restrict  */)" +%-*s --no-%-*s %s\n", maxsopt,
                 oip->sopt, maxlopt - 2, oip->lopt, oip->desc);
          }
        } else {
          {
#line 165
          printf((char const   */* __restrict  */)" --no-%-*s %s\n", (maxlopt + maxsopt) + 1,
                 oip->lopt, oip->desc);
          }
        }
#line 169
        goto switch_break;
      }
      case_4: /* CIL Label */ 
      case_3: /* CIL Label */ 
#line 172
      if (oip->sopt) {
        {
#line 173
        printf((char const   */* __restrict  */)" -%-*s --%-*s %s\n", maxsopt, oip->sopt,
               maxlopt + 1, oip->lopt, oip->desc);
        }
      } else {
        {
#line 178
        printf((char const   */* __restrict  */)" --%-*s %s\n", (maxlopt + maxsopt) + 3,
               oip->lopt, oip->desc);
        }
      }
#line 182
      goto switch_break;
      case_5: /* CIL Label */ 
#line 184
      if (oip->sopt) {
        {
#line 185
        tmp___1 = strlen((char const   *)oip->sopt);
#line 185
        tmp___2 = strlen((char const   *)oip->lopt);
#line 185
        tmp___3 = strlen((char const   *)oip->argdesc);
#line 185
        l = (int )((size_t )((maxlopt + maxsopt) - 9) - ((tmp___1 + tmp___2) + 2UL * tmp___3));
        }
#line 187
        if (l > 2) {
#line 187
          tmp___4 = l;
        } else {
#line 187
          tmp___4 = 2;
        }
        {
#line 187
        printf((char const   */* __restrict  */)" -%s<%s> / --%s <%s>%*s%s\n", oip->sopt,
               oip->argdesc, oip->lopt, oip->argdesc, tmp___4, "", oip->desc);
        }
      } else {
        {
#line 192
        tmp___5 = strlen((char const   *)oip->lopt);
#line 192
        tmp___6 = strlen((char const   *)oip->argdesc);
#line 192
        l = (int )((size_t )((maxlopt + maxsopt) + 1) - (tmp___5 + tmp___6));
        }
#line 194
        if (l > 2) {
#line 194
          tmp___7 = l;
        } else {
#line 194
          tmp___7 = 2;
        }
        {
#line 194
        printf((char const   */* __restrict  */)" --%s <%s>%*s%s\n", oip->lopt, oip->argdesc,
               tmp___7, "", oip->desc);
        }
      }
#line 199
      goto switch_break;
      case_6: /* CIL Label */ 
#line 201
      if (! (! oip->sopt)) {
        {
#line 201
        __assert_fail("!oip->sopt", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-opts.c",
                      201U, "printusage");
        }
      }
      {
#line 202
      tmp___8 = strlen((char const   *)oip->lopt);
#line 202
      tmp___9 = strlen((char const   *)oip->argdesc);
#line 202
      tmp___10 = strlen((char const   *)oip->argdesc2);
#line 202
      l = (int )((size_t )((maxlopt + maxsopt) - 2) - ((tmp___8 + tmp___9) + tmp___10));
      }
#line 204
      if (l > 2) {
#line 204
        tmp___11 = l;
      } else {
#line 204
        tmp___11 = 2;
      }
      {
#line 204
      printf((char const   */* __restrict  */)" --%s <%s> <%s>%*s%s\n", oip->lopt,
             oip->argdesc, oip->argdesc2, tmp___11, "", oip->desc);
      }
#line 208
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 210
      printf((char const   */* __restrict  */)"%s\n", oip->desc);
      }
#line 211
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 213
      abort();
      }
      switch_break: /* CIL Label */ ;
      }
#line 155
      oip ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 153
    oiap ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 218
  printf((char const   */* __restrict  */)"\nEscaping domains which might start with `-\':\n - %-*s Next argument is a domain, but more options may follow\n",
         (maxlopt + maxsopt) + 3, "<domain>");
#line 222
  fputs((char const   */* __restrict  */)"\nQuery domains should always be quoted according to master file format.\n\nFor binary options, --FOO and --no-FOO are opposites, as are\n-X and +X.  In each case the default is the one not listed.\nPer query options stay set a particular way until they are reset,\nwhether they appear on the command line or on stdin.\nAll global options must preceed the first query domain.\n\nWith -f, the input should be lines with either an option, possibly\nwith a value argument (separated from the option by a space if it\'s a long\noption), or a domain (possibly preceded by a hyphen and a space to\ndistinguish it from an option).\n\nOutput format is master file format without class or TTL by default:\n   [<owner>] [<ttl>] [<type>] <data>\nor if the <owner> domain refers to a CNAME and --show-cname is on\n   [<owner>] [<ttl>] CNAME <cname>\n   [<cname>] [<ttl>] <type> <data>\nWhen a query fails you get an error message to stderr (with --fmt-simple).\nSpecify --fmt-inline for lines like this (broken here for readability):\n   ; failed <statustype> <statusnum> <statusabbrev> \\\n       [<owner>] [<ttl>] [<cname>] \"<status string>\"\nIf you use --fmt-asynch, which is the default for --asynch,\neach answer (success or failure) is preceded by a line\n   <id> <nrrs> <statustype> <statusnum> <statusabbrev> \\\n       [<owner>] [<ttl>] [<cname>] \"<status string>\"\nwhere <nrrs> is the number of RRs that follow and <cname> will be `$\' or\nthe CNAME target; the CNAME indirection and error formats above are not used.\n\nExit status:\n 0    all went well\n 1-6  at least one query failed with statustype:\n   1    localfail   )\n   2    remotefail  ) temporary errors\n   3    tempfail  __)_________________\n   4    misconfig   )\n   5    misquery    ) permanent errors\n   6    permfail    )\n 10   system trouble\n 11   usage problems\n\nQuery types (see adns.h; default is addr):\n  ns  soa  ptr  mx  rp  srv  addr       - enhanced versions\n  cname  hinfo  txt                     - types with only one version\n  a  ns-  soa-  ptr-  mx-  rp-  srv-    - _raw versions\n  type<number>                          - `unknown\' type, RFC3597\nDefault is addr, or ptr for -i/--ptr queries\n",
        (FILE */* __restrict  */)stdout);
#line 271
  tmp___13 = ferror(stdout);
  }
#line 271
  if (tmp___13) {
    {
#line 271
    tmp___12 = __errno_location();
#line 271
    sysfail("write usage message", *tmp___12);
    }
  }
#line 272
  return;
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-opts.c"
void of_version(struct optioninfo  const  *oi , char const   *arg , char const   *arg2 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 275
  tmp = fputs((char const   */* __restrict  */)"adnshost (GNU adns) 1.2\n\nCopyright (C) 1997-2000,2003,2006  Ian Jackson\nCopyright (C) 1999-2000,2003,2006  Tony Finch\nCopyright (C) 1991 Massachusetts Institute of Technology\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n",
              (FILE */* __restrict  */)stdout);
  }
#line 275
  if (tmp == -1) {
    {
#line 275
    perror("adnshost: write version message");
#line 275
    quitnow(-1);
    }
  } else {
    {
#line 275
    tmp___0 = fclose(stdout);
    }
#line 275
    if (tmp___0) {
      {
#line 275
      perror("adnshost: write version message");
#line 275
      quitnow(-1);
      }
    }
  }
  {
#line 275
  quitnow(0);
  }
}
}
#line 278 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-opts.c"
void of_help(struct optioninfo  const  *oi , char const   *arg , char const   *arg2 ) 
{ 
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 279
  printusage();
#line 280
  tmp___0 = fclose(stdout);
  }
#line 280
  if (tmp___0) {
    {
#line 280
    tmp = __errno_location();
#line 280
    sysfail("finish writing output", *tmp);
    }
  }
  {
#line 281
  quitnow(0);
  }
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-opts.c"
static int oc_long(char const   **optp , struct optioninfo  const  *entry ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 287
  if (entry->lopt) {
    {
#line 287
    tmp = strcmp(*optp, (char const   *)entry->lopt);
    }
#line 287
    if (tmp) {
#line 287
      tmp___0 = 0;
    } else {
#line 287
      tmp___0 = 1;
    }
  } else {
#line 287
    tmp___0 = 0;
  }
#line 287
  return (tmp___0);
}
}
#line 290 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-opts.c"
static int oc_short(char const   **optp , struct optioninfo  const  *entry ) 
{ 
  char const   *sopt ;
  int l ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 294
  sopt = (char const   *)entry->sopt;
#line 295
  if (! sopt) {
#line 295
    return (0);
  }
  {
#line 296
  tmp = strlen(sopt);
#line 296
  l = (int )tmp;
#line 297
  tmp___0 = memcmp((void const   *)*optp, (void const   *)sopt, (size_t )l);
  }
#line 297
  if (tmp___0) {
#line 297
    return (0);
  }
#line 298
  *optp += l;
#line 299
  return (1);
}
}
#line 302 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-opts.c"
static struct optioninfo  const  *find1(char const   **optp , struct optioninfo  const  *table ,
                                        comparer_type *comparer___3 ) 
{ 
  int tmp ;

  {
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;
#line 306
    if ((unsigned int const   )table->type == 0U) {
#line 306
      return ((struct optioninfo  const  *)0);
    }
    {
#line 307
    tmp = (*comparer___3)(optp, table);
    }
#line 307
    if (tmp) {
#line 307
      return (table);
    }
#line 308
    table ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-opts.c"
static struct optioninfo  const  *find(char const   **optp , char const   *prefix ,
                                       comparer_type *comparer___3 ) 
{ 
  struct optioninfo  const  *oip ;
  char const   *opt ;

  {
  {
#line 318
  opt = *optp;
#line 319
  oip = find1(optp, perquery_options, comparer___3);
  }
#line 320
  if (oip) {
#line 320
    return (oip);
  }
  {
#line 321
  oip = find1(optp, global_options, comparer___3);
  }
#line 322
  if (! oip) {
    {
#line 322
    usageerr("unknown option %s%s", prefix, opt);
    }
  }
#line 323
  if (ads) {
    {
#line 323
    usageerr("global option %s%s specified after query domain(s)", prefix, opt);
    }
  }
#line 324
  return (oip);
}
}
#line 327 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-opts.c"
struct optioninfo  const  *opt_findl(char const   *opt ) 
{ 
  struct optioninfo  const  *tmp ;

  {
  {
#line 327
  tmp = find(& opt, "--", & oc_long);
  }
#line 327
  return (tmp);
}
}
#line 328 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-opts.c"
struct optioninfo  const  *opt_finds(char const   **optp ) 
{ 
  struct optioninfo  const  *tmp ;

  {
  {
#line 328
  tmp = find(optp, "-", & oc_short);
  }
#line 328
  return (tmp);
}
}
#line 330
static  __attribute__((__noreturn__)) void noninvert(struct optioninfo  const  *oip ) ;
#line 331
static  __attribute__((__noreturn__)) void noninvert(struct optioninfo  const  *oip ) ;
#line 331 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-opts.c"
static void noninvert(struct optioninfo  const  *oip ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 332
  if (oip->lopt) {
#line 332
    tmp = oip->lopt;
  } else {
#line 332
    tmp = (char const   */* const  */)"";
  }
#line 332
  if (oip->lopt) {
#line 332
    tmp___0 = "--";
  } else {
#line 332
    tmp___0 = "";
  }
#line 332
  if (oip->lopt) {
#line 332
    if (oip->sopt) {
#line 332
      tmp___1 = " / ";
    } else {
#line 332
      tmp___1 = "";
    }
  } else {
#line 332
    tmp___1 = "";
  }
#line 332
  if (oip->sopt) {
#line 332
    tmp___2 = oip->sopt;
  } else {
#line 332
    tmp___2 = (char const   */* const  */)"";
  }
#line 332
  if (oip->sopt) {
#line 332
    tmp___3 = "-";
  } else {
#line 332
    tmp___3 = "";
  }
  {
#line 332
  usageerr("option %s%s%s%s%s may not be inverted", tmp___3, tmp___2, tmp___1, tmp___0,
           tmp);
  }
}
}
#line 338 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-opts.c"
void opt_do(struct optioninfo  const  *oip , int invert , char const   *arg , char const   *arg2 ) 
{ 


  {
  {
#line 341
  if ((unsigned int const   )oip->type == 2U) {
#line 341
    goto case_2;
  }
#line 345
  if ((unsigned int const   )oip->type == 3U) {
#line 345
    goto case_3;
  }
#line 350
  if ((unsigned int const   )oip->type == 6U) {
#line 350
    goto case_6;
  }
#line 350
  if ((unsigned int const   )oip->type == 5U) {
#line 350
    goto case_6;
  }
#line 350
  if ((unsigned int const   )oip->type == 4U) {
#line 350
    goto case_6;
  }
#line 354
  goto switch_default;
  case_2: /* CIL Label */ 
#line 342
  if (! (! arg)) {
    {
#line 342
    __assert_fail("!arg", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-opts.c",
                  342U, "opt_do");
    }
  }
#line 343
  *(oip->storep) = ! invert;
#line 344
  return;
  case_3: /* CIL Label */ 
#line 346
  if (! (! arg)) {
    {
#line 346
    __assert_fail("!arg", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-opts.c",
                  346U, "opt_do");
    }
  }
#line 347
  if (invert) {
    {
#line 347
    noninvert(oip);
    }
  }
#line 348
  *(oip->storep) = (int )oip->value;
#line 349
  return;
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 351
  if (invert) {
    {
#line 351
    noninvert(oip);
    }
  }
  {
#line 352
  (*(oip->func))(oip, arg, arg2);
  }
#line 353
  return;
  switch_default: /* CIL Label */ 
  {
#line 355
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 31 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/reply.c"
void adns__procdgram(adns_state ads___7 , byte const   *dgram , int dglen , int serv ,
                     int viatcp , struct timeval now ) 
{ 
  int cbyte___3 ;
  int rrstart ;
  int wantedrrs ;
  int rri ;
  int foundsoa ;
  int foundns ;
  int cname_here ;
  int id ;
  int f1 ;
  int f2 ;
  int qdcount ;
  int ancount ;
  int nscount ;
  int arcount ;
  int flg_ra ;
  int flg_rd ;
  int flg_tc ;
  int flg_qr ;
  int opcode ;
  int rrtype ;
  int rrclass ;
  int rdlength ;
  int rdstart ;
  int anstart ;
  int nsstart ;
  int arstart ;
  int ownermatched ;
  int l ;
  int nrrs ;
  unsigned long ttl ;
  unsigned long soattl ;
  typeinfo const   *typei ;
  adns_query qu ;
  adns_query nqu ;
  dns_rcode rcode___0 ;
  adns_status st ;
  vbuf tempvb ;
  byte *newquery ;
  byte *rrsdata ;
  parseinfo pai ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  int tmp___16 ;
  size_t tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  void *tmp___20 ;

  {
#line 48
  if (dglen < 12) {
    {
#line 49
    adns__diag(ads___7, serv, (adns_query )0, "received datagram too short for message header (%d)",
               dglen);
    }
#line 51
    return;
  }
#line 53
  cbyte___3 = 0;
#line 54
  id = 0;
#line 54
  tmp = cbyte___3;
#line 54
  cbyte___3 ++;
#line 54
  id |= (int )(((int const   )*(dgram + tmp) & 255) << 8);
#line 54
  tmp___0 = cbyte___3;
#line 54
  cbyte___3 ++;
#line 54
  id |= (int )((int const   )*(dgram + tmp___0) & 255);
#line 55
  tmp___1 = cbyte___3;
#line 55
  cbyte___3 ++;
#line 55
  f1 = (int )((int const   )*(dgram + tmp___1) & 255);
#line 56
  tmp___2 = cbyte___3;
#line 56
  cbyte___3 ++;
#line 56
  f2 = (int )((int const   )*(dgram + tmp___2) & 255);
#line 57
  qdcount = 0;
#line 57
  tmp___3 = cbyte___3;
#line 57
  cbyte___3 ++;
#line 57
  qdcount |= (int )(((int const   )*(dgram + tmp___3) & 255) << 8);
#line 57
  tmp___4 = cbyte___3;
#line 57
  cbyte___3 ++;
#line 57
  qdcount |= (int )((int const   )*(dgram + tmp___4) & 255);
#line 58
  ancount = 0;
#line 58
  tmp___5 = cbyte___3;
#line 58
  cbyte___3 ++;
#line 58
  ancount |= (int )(((int const   )*(dgram + tmp___5) & 255) << 8);
#line 58
  tmp___6 = cbyte___3;
#line 58
  cbyte___3 ++;
#line 58
  ancount |= (int )((int const   )*(dgram + tmp___6) & 255);
#line 59
  nscount = 0;
#line 59
  tmp___7 = cbyte___3;
#line 59
  cbyte___3 ++;
#line 59
  nscount |= (int )(((int const   )*(dgram + tmp___7) & 255) << 8);
#line 59
  tmp___8 = cbyte___3;
#line 59
  cbyte___3 ++;
#line 59
  nscount |= (int )((int const   )*(dgram + tmp___8) & 255);
#line 60
  arcount = 0;
#line 60
  tmp___9 = cbyte___3;
#line 60
  cbyte___3 ++;
#line 60
  arcount |= (int )(((int const   )*(dgram + tmp___9) & 255) << 8);
#line 60
  tmp___10 = cbyte___3;
#line 60
  cbyte___3 ++;
#line 60
  arcount |= (int )((int const   )*(dgram + tmp___10) & 255);
#line 61
  if (! (cbyte___3 == 12)) {
    {
#line 61
    __assert_fail("cbyte == 12", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/reply.c",
                  61U, "adns__procdgram");
    }
  }
#line 63
  flg_qr = f1 & 128;
#line 64
  opcode = (f1 & 120) >> 3;
#line 65
  flg_tc = f1 & 2;
#line 66
  flg_rd = f1 & 1;
#line 67
  flg_ra = f2 & 128;
#line 68
  rcode___0 = (dns_rcode )(f2 & 15);
#line 70
  cname_here = 0;
#line 72
  if (! flg_qr) {
    {
#line 73
    adns__diag(ads___7, serv, (adns_query )0, "server sent us a query, not a response");
    }
#line 74
    return;
  }
#line 76
  if (opcode) {
    {
#line 77
    adns__diag(ads___7, serv, (adns_query )0, "server sent us unknown opcode %d (wanted 0=QUERY)",
               opcode);
    }
#line 79
    return;
  }
#line 82
  qu = (adns_query )0;
#line 85
  if (qdcount == 1) {
#line 86
    if (viatcp) {
#line 86
      qu = ads___7->tcpw.head;
    } else {
#line 86
      qu = ads___7->udpw.head;
    }
    {
#line 86
    while (1) {
      while_continue: /* CIL Label */ ;
#line 86
      if (! qu) {
#line 86
        goto while_break;
      }
#line 87
      nqu = qu->next;
#line 88
      if (qu->id != id) {
#line 88
        goto __Cont;
      }
#line 89
      if (dglen < qu->query_dglen) {
#line 89
        goto __Cont;
      }
      {
#line 90
      tmp___11 = memcmp((void const   *)(qu->query_dgram + 12), (void const   *)(dgram + 12),
                        (size_t )(qu->query_dglen - 12));
      }
#line 90
      if (tmp___11) {
#line 93
        goto __Cont;
      }
#line 94
      if (viatcp) {
#line 95
        if (! ((unsigned int )qu->state == 1U)) {
          {
#line 95
          __assert_fail("qu->state == query_tcpw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/reply.c",
                        95U, "adns__procdgram");
          }
        }
      } else {
#line 97
        if (! ((unsigned int )qu->state == 0U)) {
          {
#line 97
          __assert_fail("qu->state == query_tosend", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/reply.c",
                        97U, "adns__procdgram");
          }
        }
#line 98
        if (! (qu->udpsent & (unsigned long )(1 << serv))) {
#line 98
          goto __Cont;
        }
      }
#line 100
      goto while_break;
      __Cont: /* CIL Label */ 
#line 86
      qu = nqu;
    }
    while_break: /* CIL Label */ ;
    }
#line 102
    if (qu) {
#line 104
      if (viatcp) {
        {
#line 104
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 104
          if (qu->back) {
#line 104
            (qu->back)->next = qu->next;
          } else {
#line 104
            ads___7->tcpw.head = qu->next;
          }
#line 104
          if (qu->next) {
#line 104
            (qu->next)->back = qu->back;
          } else {
#line 104
            ads___7->tcpw.tail = qu->back;
          }
#line 104
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
        {
#line 105
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 105
          if (qu->back) {
#line 105
            (qu->back)->next = qu->next;
          } else {
#line 105
            ads___7->udpw.head = qu->next;
          }
#line 105
          if (qu->next) {
#line 105
            (qu->next)->back = qu->back;
          } else {
#line 105
            ads___7->udpw.tail = qu->back;
          }
#line 105
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
  }
  {
#line 115
  if ((unsigned int )rcode___0 == 3U) {
#line 115
    goto case_3;
  }
#line 115
  if ((unsigned int )rcode___0 == 0U) {
#line 115
    goto case_3;
  }
#line 117
  if ((unsigned int )rcode___0 == 1U) {
#line 117
    goto case_1;
  }
#line 122
  if ((unsigned int )rcode___0 == 2U) {
#line 122
    goto case_2;
  }
#line 126
  if ((unsigned int )rcode___0 == 4U) {
#line 126
    goto case_4;
  }
#line 130
  if ((unsigned int )rcode___0 == 5U) {
#line 130
    goto case_5;
  }
#line 134
  goto switch_default;
  case_3: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 116
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 118
  adns__warn(ads___7, serv, qu, "server cannot understand our query (Format Error)");
  }
#line 120
  if (qu) {
    {
#line 120
    adns__query_fail(qu, (adns_status )61);
    }
  }
#line 121
  return;
  case_2: /* CIL Label */ 
#line 123
  if (qu) {
    {
#line 123
    adns__query_fail(qu, (adns_status )60);
    }
  } else {
    {
#line 124
    adns__debug(ads___7, serv, qu, "server failure on unidentifiable query");
    }
  }
#line 125
  return;
  case_4: /* CIL Label */ 
  {
#line 127
  adns__warn(ads___7, serv, qu, "server claims not to implement our query");
  }
#line 128
  if (qu) {
    {
#line 128
    adns__query_fail(qu, (adns_status )62);
    }
  }
#line 129
  return;
  case_5: /* CIL Label */ 
  {
#line 131
  adns__debug(ads___7, serv, qu, "server refused our query");
  }
#line 132
  if (qu) {
    {
#line 132
    adns__query_fail(qu, (adns_status )63);
    }
  }
#line 133
  return;
  switch_default: /* CIL Label */ 
  {
#line 135
  adns__warn(ads___7, serv, qu, "server gave unknown response code %d", (unsigned int )rcode___0);
  }
#line 136
  if (qu) {
    {
#line 136
    adns__query_fail(qu, (adns_status )64);
    }
  }
#line 137
  return;
  switch_break: /* CIL Label */ ;
  }
#line 140
  if (! qu) {
#line 141
    if (! qdcount) {
      {
#line 142
      adns__diag(ads___7, serv, (adns_query )0, "server sent reply without quoting our question");
      }
    } else
#line 143
    if (qdcount > 1) {
      {
#line 144
      adns__diag(ads___7, serv, (adns_query )0, "server claimed to answer %d questions with one message",
                 qdcount);
      }
    } else
#line 146
    if ((unsigned int )ads___7->iflags & 8U) {
      {
#line 147
      adns__vbuf_init(& tempvb);
#line 148
      tmp___12 = adns__diag_domain(ads___7, serv, (adns_query )0, & tempvb, dgram,
                                   dglen, 12);
#line 148
      adns__debug(ads___7, serv, (adns_query )0, "reply not found, id %02x, query owner %s",
                  id, tmp___12);
#line 151
      adns__vbuf_free(& tempvb);
      }
    }
#line 153
    return;
  }
#line 159
  anstart = qu->query_dglen;
#line 160
  arstart = -1;
#line 165
  wantedrrs = 0;
#line 166
  cbyte___3 = anstart;
#line 167
  rri = 0;
  {
#line 167
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 167
    if (! (rri < ancount)) {
#line 167
      goto while_break___2;
    }
    {
#line 168
    rrstart = cbyte___3;
#line 169
    st = adns__findrr(qu, serv, dgram, dglen, & cbyte___3, & rrtype, & rrclass, & ttl,
                      & rdlength, & rdstart, & ownermatched);
    }
#line 172
    if (st) {
      {
#line 172
      adns__query_fail(qu, st);
      }
#line 172
      return;
    }
#line 173
    if (rrtype == -1) {
#line 173
      goto x_truncated;
    }
#line 175
    if (rrclass != 1) {
      {
#line 176
      adns__diag(ads___7, serv, qu, "ignoring answer RR with wrong class %d (expected IN=%d)",
                 rrclass, 1);
      }
#line 178
      goto __Cont___0;
    }
#line 180
    if (! ownermatched) {
#line 181
      if ((unsigned int )ads___7->iflags & 8U) {
        {
#line 182
        tmp___13 = adns__diag_domain(ads___7, serv, qu, & qu->vb, dgram, dglen, rrstart);
#line 182
        adns__debug(ads___7, serv, qu, "ignoring RR with an unexpected owner %s",
                    tmp___13);
        }
      }
#line 186
      goto __Cont___0;
    }
#line 188
    if (rrtype == 5) {
#line 188
      if (((unsigned int )(qu->answer)->type & 65535U) != 5U) {
#line 190
        if (qu->flags & 512) {
          {
#line 191
          adns__query_fail(qu, (adns_status )101);
          }
#line 192
          return;
        } else
#line 193
        if (qu->cname_dgram) {
          {
#line 194
          tmp___14 = adns__diag_domain(ads___7, serv, qu, & qu->vb, dgram, dglen,
                                       rdstart);
#line 194
          adns__debug(ads___7, serv, qu, "allegedly canonical name %s is actually alias for %s",
                      (qu->answer)->cname, tmp___14);
#line 198
          adns__query_fail(qu, (adns_status )101);
          }
#line 199
          return;
        } else
#line 200
        if (wantedrrs) {
          {
#line 201
          tmp___15 = adns__diag_domain(ads___7, serv, qu, & qu->vb, dgram, dglen,
                                       rdstart);
#line 201
          adns__debug(ads___7, serv, qu, "ignoring CNAME (to %s) coexisting with RR",
                      tmp___15);
          }
        } else {
#line 205
          qu->cname_begin = rdstart;
#line 206
          qu->cname_dglen = dglen;
#line 207
          if (qu->flags & 128) {
#line 207
            tmp___16 = 0;
          } else {
#line 207
            tmp___16 = 1;
          }
          {
#line 207
          st = adns__parse_domain(ads___7, serv, qu, & qu->vb, (parsedomain_flags )tmp___16,
                                  dgram, dglen, & rdstart, rdstart + rdlength);
          }
#line 211
          if (! qu->vb.used) {
#line 211
            goto x_truncated;
          }
#line 212
          if (st) {
            {
#line 212
            adns__query_fail(qu, st);
            }
#line 212
            return;
          }
          {
#line 213
          tmp___17 = strlen((char const   *)qu->vb.buf);
#line 213
          l = (int )(tmp___17 + 1UL);
#line 214
          tmp___18 = adns__alloc_preserved(qu, (size_t )l);
#line 214
          (qu->answer)->cname = (char *)tmp___18;
          }
#line 215
          if (! (qu->answer)->cname) {
            {
#line 216
            adns__query_fail(qu, (adns_status )1);
            }
#line 217
            return;
          }
          {
#line 220
          tmp___19 = adns__alloc_mine(qu, (size_t )dglen);
#line 220
          qu->cname_dgram = (byte *)tmp___19;
#line 221
          memcpy((void */* __restrict  */)qu->cname_dgram, (void const   */* __restrict  */)dgram,
                 (size_t )dglen);
#line 223
          memcpy((void */* __restrict  */)(qu->answer)->cname, (void const   */* __restrict  */)qu->vb.buf,
                 (size_t )l);
#line 224
          cname_here = 1;
#line 225
          adns__update_expires(qu, ttl, now);
          }
        }
      } else {
#line 188
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 232
    if ((unsigned int )rrtype == ((unsigned int )(qu->answer)->type & 65535U)) {
#line 233
      wantedrrs ++;
    } else {
      {
#line 235
      adns__debug(ads___7, serv, qu, "ignoring answer RR with irrelevant type %d",
                  rrtype);
      }
    }
    __Cont___0: /* CIL Label */ 
#line 167
    rri ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 243
  if (flg_tc) {
#line 243
    goto x_truncated;
  }
#line 245
  nsstart = cbyte___3;
#line 247
  if (! wantedrrs) {
#line 253
    foundsoa = 0;
#line 253
    soattl = 0UL;
#line 253
    foundns = 0;
#line 254
    rri = 0;
    {
#line 254
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 254
      if (! (rri < nscount)) {
#line 254
        goto while_break___3;
      }
      {
#line 255
      rrstart = cbyte___3;
#line 256
      st = adns__findrr(qu, serv, dgram, dglen, & cbyte___3, & rrtype, & rrclass,
                        & ttl, & rdlength, & rdstart, (int *)0);
      }
#line 258
      if (st) {
        {
#line 258
        adns__query_fail(qu, st);
        }
#line 258
        return;
      }
#line 259
      if (rrtype == -1) {
#line 259
        goto x_truncated;
      }
#line 260
      if (rrclass != 1) {
        {
#line 261
        adns__diag(ads___7, serv, qu, "ignoring authority RR with wrong class %d (expected IN=%d)",
                   rrclass, 1);
        }
#line 264
        goto __Cont___1;
      }
#line 266
      if (rrtype == 6) {
#line 266
        foundsoa = 1;
#line 266
        soattl = ttl;
#line 266
        goto while_break___3;
      } else
#line 267
      if (rrtype == 2) {
#line 267
        foundns = 1;
      }
      __Cont___1: /* CIL Label */ 
#line 254
      rri ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 270
    if ((unsigned int )rcode___0 == 3U) {
      {
#line 272
      adns__update_expires(qu, soattl, now);
      }
#line 274
      if (qu->flags & 1) {
#line 274
        if (! qu->cname_dgram) {
          {
#line 275
          adns__search_next(ads___7, qu, now);
          }
        } else {
          {
#line 277
          adns__query_fail(qu, (adns_status )300);
          }
        }
      } else {
        {
#line 277
        adns__query_fail(qu, (adns_status )300);
        }
      }
#line 279
      return;
    }
#line 282
    if (foundsoa) {
      {
#line 284
      adns__update_expires(qu, soattl, now);
#line 285
      adns__query_fail(qu, (adns_status )301);
      }
#line 286
      return;
    } else
#line 282
    if (! foundns) {
      {
#line 284
      adns__update_expires(qu, soattl, now);
#line 285
      adns__query_fail(qu, (adns_status )301);
      }
#line 286
      return;
    }
#line 294
    if (cname_here) {
#line 294
      goto x_restartquery;
    }
#line 297
    if (! flg_ra) {
      {
#line 298
      adns__diag(ads___7, serv, qu, "server is not willing to do recursive lookups for us");
#line 300
      adns__query_fail(qu, (adns_status )32);
      }
    } else {
#line 302
      if (! flg_rd) {
        {
#line 303
        adns__diag(ads___7, serv, qu, "server thinks we didn\'t ask for recursive lookup");
        }
      } else {
        {
#line 306
        adns__debug(ads___7, serv, qu, "server claims to do recursion, but gave us a referral");
        }
      }
      {
#line 308
      adns__query_fail(qu, (adns_status )33);
      }
    }
#line 310
    return;
  }
  {
#line 315
  (qu->answer)->rrs.untyped = adns__alloc_interim(qu, (size_t )((qu->typei)->rrsz * (int const   )wantedrrs));
  }
#line 316
  if (! (qu->answer)->rrs.untyped) {
    {
#line 317
    adns__query_fail(qu, (adns_status )1);
    }
#line 318
    return;
  }
#line 321
  typei = qu->typei;
#line 322
  cbyte___3 = anstart;
#line 323
  rrsdata = (qu->answer)->rrs.bytes;
#line 325
  pai.ads = qu->ads;
#line 326
  pai.qu = qu;
#line 327
  pai.serv = serv;
#line 328
  pai.dgram = dgram;
#line 329
  pai.dglen = dglen;
#line 330
  pai.nsstart = nsstart;
#line 331
  pai.nscount = nscount;
#line 332
  pai.arcount = arcount;
#line 333
  pai.now = now;
#line 335
  rri = 0;
#line 335
  nrrs = 0;
  {
#line 335
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 335
    if (! (rri < ancount)) {
#line 335
      goto while_break___4;
    }
    {
#line 336
    st = adns__findrr(qu, serv, dgram, dglen, & cbyte___3, & rrtype, & rrclass, & ttl,
                      & rdlength, & rdstart, & ownermatched);
    }
#line 339
    if (! (! st)) {
      {
#line 339
      __assert_fail("!st", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/reply.c",
                    339U, "adns__procdgram");
      }
    }
#line 339
    if (! (rrtype != -1)) {
      {
#line 339
      __assert_fail("rrtype != -1", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/reply.c",
                    339U, "adns__procdgram");
      }
    }
#line 340
    if (rrclass != 1) {
#line 343
      goto __Cont___2;
    } else
#line 340
    if ((unsigned int )rrtype != ((unsigned int )(qu->answer)->type & 65535U)) {
#line 343
      goto __Cont___2;
    } else
#line 340
    if (! ownermatched) {
#line 343
      goto __Cont___2;
    }
    {
#line 344
    adns__update_expires(qu, ttl, now);
#line 345
    st = (*(typei->parse))((parseinfo const   *)(& pai), rdstart, rdstart + rdlength,
                           (void *)(rrsdata + nrrs * (int )typei->rrsz));
    }
#line 346
    if (st) {
      {
#line 346
      adns__query_fail(qu, st);
      }
#line 346
      return;
    }
#line 347
    if (rdstart == -1) {
#line 347
      goto x_truncated;
    }
#line 348
    nrrs ++;
    __Cont___2: /* CIL Label */ 
#line 335
    rri ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 350
  if (! (nrrs == wantedrrs)) {
    {
#line 350
    __assert_fail("nrrs==wantedrrs", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/reply.c",
                  350U, "adns__procdgram");
    }
  }
#line 351
  (qu->answer)->nrrs = nrrs;
#line 354
  if (qu->children.head) {
#line 355
    qu->state = (enum __anonenum_state_83 )2;
    {
#line 356
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 356
      qu->next = (adns_query )0;
#line 356
      qu->back = ads___7->childw.tail;
#line 356
      if (ads___7->childw.tail) {
#line 356
        (ads___7->childw.tail)->next = qu;
      } else {
#line 356
        ads___7->childw.head = qu;
      }
#line 356
      ads___7->childw.tail = qu;
#line 356
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 357
    return;
  }
  {
#line 359
  adns__query_done(qu);
  }
#line 360
  return;
  x_truncated: 
#line 364
  if (! flg_tc) {
    {
#line 365
    adns__diag(ads___7, serv, qu, "server sent datagram which points outside itself");
#line 366
    adns__query_fail(qu, (adns_status )33);
    }
#line 367
    return;
  }
#line 369
  qu->flags |= 2;
  x_restartquery: 
#line 372
  if (qu->cname_dgram) {
    {
#line 373
    st = adns__mkquery_frdgram(qu->ads, & qu->vb, & qu->id, (byte const   *)qu->cname_dgram,
                               qu->cname_dglen, qu->cname_begin, (qu->answer)->type,
                               (adns_queryflags )qu->flags);
    }
#line 376
    if (st) {
      {
#line 376
      adns__query_fail(qu, st);
      }
#line 376
      return;
    }
    {
#line 378
    tmp___20 = Hrealloc((void *)qu->query_dgram, (size_t )qu->vb.used);
#line 378
    newquery = (byte *)tmp___20;
    }
#line 379
    if (! newquery) {
      {
#line 379
      adns__query_fail(qu, (adns_status )1);
      }
#line 379
      return;
    }
    {
#line 381
    qu->query_dgram = newquery;
#line 382
    qu->query_dglen = qu->vb.used;
#line 383
    memcpy((void */* __restrict  */)newquery, (void const   */* __restrict  */)qu->vb.buf,
           (size_t )qu->vb.used);
    }
  }
#line 386
  if ((unsigned int )qu->state == 1U) {
#line 386
    qu->state = (enum __anonenum_state_83 )0;
  }
  {
#line 387
  qu->retries = 0;
#line 388
  adns__reset_preserved(qu);
#line 389
  adns__query_send(qu, now);
  }
#line 390
  return;
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfig___0(adns_state ads___7 , char const   *filename , int warnmissing ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void addserver___0(adns_state ads___7 , struct in_addr addr ) 
{ 
  int i ;
  struct server *ss ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 48
  i = 0;
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (i < ads___7->nservers)) {
#line 48
      goto while_break;
    }
#line 49
    if (ads___7->servers[i].addr.s_addr == addr.s_addr) {
      {
#line 50
      tmp = inet_ntoa(addr);
#line 50
      adns__debug(ads___7, -1, (adns_query )0, "duplicate nameserver %s ignored",
                  tmp);
      }
#line 51
      return;
    }
#line 48
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  if (ads___7->nservers >= 5) {
    {
#line 56
    tmp___0 = inet_ntoa(addr);
#line 56
    adns__diag(ads___7, -1, (adns_query )0, "too many nameservers, ignoring %s", tmp___0);
    }
#line 57
    return;
  }
#line 60
  ss = ads___7->servers + ads___7->nservers;
#line 61
  ss->addr = addr;
#line 62
  (ads___7->nservers) ++;
#line 63
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void freesearchlist___0(adns_state ads___7 ) 
{ 


  {
#line 66
  if (ads___7->nsearchlist) {
    {
#line 66
    Hfree((void *)*(ads___7->searchlist));
    }
  }
  {
#line 67
  Hfree((void *)ads___7->searchlist);
  }
#line 68
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void saveerr___0(adns_state ads___7 , int en ) 
{ 


  {
#line 71
  if (! ads___7->configerrno) {
#line 71
    ads___7->configerrno = en;
  }
#line 72
  return;
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void configparseerr___0(adns_state ads___7 , char const   *fn , int lno , char const   *fmt 
                               , ...) 
{ 
  va_list al ;

  {
  {
#line 78
  saveerr___0(ads___7, 22);
  }
#line 79
  if (! ads___7->logfn) {
#line 79
    return;
  } else
#line 79
  if ((unsigned int )ads___7->iflags & 2U) {
#line 79
    return;
  }
#line 81
  if (lno == -1) {
    {
#line 81
    adns__lprintf(ads___7, "adns: %s: ", fn);
    }
  } else {
    {
#line 82
    adns__lprintf(ads___7, "adns: %s:%d: ", fn, lno);
    }
  }
  {
#line 83
  __builtin_va_start(al, fmt);
#line 84
  adns__vlprintf(ads___7, fmt, al);
#line 85
  __builtin_va_end(al);
#line 86
  adns__lprintf(ads___7, "\n");
  }
#line 87
  return;
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int nextword___0(char const   **bufp_io , char const   **word_r , int *l_r ) 
{ 
  char const   *p ;
  char const   *q ;
  int tmp ;
  int tmp___0 ;

  {
#line 92
  p = *bufp_io;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 93
    tmp = ctype_whitespace((int )*p);
    }
#line 93
    if (! tmp) {
#line 93
      goto while_break;
    }
#line 93
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  if (! *p) {
#line 94
    return (0);
  }
#line 96
  q = p;
  {
#line 97
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 97
    if (*q) {
      {
#line 97
      tmp___0 = ctype_whitespace((int )*q);
      }
#line 97
      if (tmp___0) {
#line 97
        goto while_break___0;
      }
    } else {
#line 97
      goto while_break___0;
    }
#line 97
    q ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 99
  *l_r = (int )(q - p);
#line 100
  *word_r = p;
#line 101
  *bufp_io = q;
#line 103
  return (1);
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_nameserver___0(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  struct in_addr ia ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 110
  tmp = inet_aton(buf___17, & ia);
  }
#line 110
  if (! tmp) {
    {
#line 111
    configparseerr___0(ads___7, fn, lno, "invalid nameserver address `%s\'", buf___17);
    }
#line 112
    return;
  }
  {
#line 114
  tmp___0 = inet_ntoa(ia);
#line 114
  adns__debug(ads___7, -1, (adns_query )0, "using nameserver %s", tmp___0);
#line 115
  addserver___0(ads___7, ia);
  }
#line 116
  return;
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_search___0(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  char const   *bufp ;
  char const   *word ;
  char *newchars ;
  char **newptrs ;
  char **pp ;
  int count ;
  int tl ;
  int l ;
  int tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char **tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
#line 124
  if (! buf___17) {
#line 124
    return;
  }
#line 126
  bufp = buf___17;
#line 127
  count = 0;
#line 128
  tl = 0;
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 129
    tmp = nextword___0(& bufp, & word, & l);
    }
#line 129
    if (! tmp) {
#line 129
      goto while_break;
    }
#line 129
    count ++;
#line 129
    tl += l + 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 131
  tmp___0 = Hmalloc(sizeof(char *) * (unsigned long )count);
#line 131
  newptrs = (char **)tmp___0;
  }
#line 132
  if (! newptrs) {
    {
#line 132
    tmp___1 = __errno_location();
#line 132
    saveerr___0(ads___7, *tmp___1);
    }
#line 132
    return;
  }
  {
#line 134
  tmp___2 = Hmalloc((size_t )tl);
#line 134
  newchars = (char *)tmp___2;
  }
#line 135
  if (! newchars) {
    {
#line 135
    tmp___3 = __errno_location();
#line 135
    saveerr___0(ads___7, *tmp___3);
#line 135
    Hfree((void *)newptrs);
    }
#line 135
    return;
  }
#line 137
  bufp = buf___17;
#line 138
  pp = newptrs;
  {
#line 139
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 139
    tmp___6 = nextword___0(& bufp, & word, & l);
    }
#line 139
    if (! tmp___6) {
#line 139
      goto while_break___0;
    }
    {
#line 140
    tmp___4 = pp;
#line 140
    pp ++;
#line 140
    *tmp___4 = newchars;
#line 141
    memcpy((void */* __restrict  */)newchars, (void const   */* __restrict  */)word,
           (size_t )l);
#line 142
    newchars += l;
#line 143
    tmp___5 = newchars;
#line 143
    newchars ++;
#line 143
    *tmp___5 = (char)0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 146
  freesearchlist___0(ads___7);
#line 147
  ads___7->nsearchlist = count;
#line 148
  ads___7->searchlist = newptrs;
  }
#line 149
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_sortlist___0(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  char const   *word ;
  char tbuf[200] ;
  char *slash ;
  char *ep ;
  struct in_addr base ;
  struct in_addr mask ;
  int l ;
  unsigned long initial ;
  unsigned long baselocal ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  uint32_t tmp___3 ;
  int tmp___4 ;

  {
#line 159
  if (! buf___17) {
#line 159
    return;
  }
#line 161
  ads___7->nsortlist = 0;
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 162
    tmp___4 = nextword___0(& buf___17, & word, & l);
    }
#line 162
    if (! tmp___4) {
#line 162
      goto while_break;
    }
#line 163
    if (ads___7->nsortlist >= 15) {
      {
#line 164
      adns__diag(ads___7, -1, (adns_query )0, "too many sortlist entries, ignoring %.*s onwards",
                 l, word);
      }
#line 166
      return;
    }
#line 169
    if ((unsigned long )l >= sizeof(tbuf)) {
      {
#line 170
      configparseerr___0(ads___7, fn, lno, "sortlist entry `%.*s\' too long", l, word);
      }
#line 171
      goto while_continue;
    }
    {
#line 174
    memcpy((void */* __restrict  */)(tbuf), (void const   */* __restrict  */)word,
           (size_t )l);
#line 174
    tbuf[l] = (char)0;
#line 175
    slash = strchr((char const   *)(tbuf), '/');
    }
#line 176
    if (slash) {
#line 176
      tmp = slash;
#line 176
      slash ++;
#line 176
      *tmp = (char)0;
    }
    {
#line 178
    tmp___0 = inet_aton((char const   *)(tbuf), & base);
    }
#line 178
    if (! tmp___0) {
      {
#line 179
      configparseerr___0(ads___7, fn, lno, "invalid address `%s\' in sortlist", tbuf);
      }
#line 180
      goto while_continue;
    }
#line 183
    if (slash) {
      {
#line 184
      tmp___2 = strchr((char const   *)slash, '.');
      }
#line 184
      if (tmp___2) {
        {
#line 185
        tmp___1 = inet_aton((char const   *)slash, & mask);
        }
#line 185
        if (! tmp___1) {
          {
#line 186
          configparseerr___0(ads___7, fn, lno, "invalid mask `%s\' in sortlist", slash);
          }
#line 187
          goto while_continue;
        }
#line 189
        if (base.s_addr & ~ mask.s_addr) {
          {
#line 190
          configparseerr___0(ads___7, fn, lno, "mask `%s\' in sortlist overlaps address `%s\'",
                             slash, tbuf);
          }
#line 192
          goto while_continue;
        }
      } else {
        {
#line 195
        initial = strtoul((char const   */* __restrict  */)slash, (char **/* __restrict  */)(& ep),
                          10);
        }
#line 196
        if (*ep) {
          {
#line 197
          configparseerr___0(ads___7, fn, lno, "mask length `%s\' invalid", slash);
          }
#line 198
          goto while_continue;
        } else
#line 196
        if (initial > 32UL) {
          {
#line 197
          configparseerr___0(ads___7, fn, lno, "mask length `%s\' invalid", slash);
          }
#line 198
          goto while_continue;
        }
        {
#line 200
        mask.s_addr = htonl((uint32_t )(4294967295UL << (32UL - initial)));
        }
      }
    } else {
      {
#line 203
      tmp___3 = ntohl(base.s_addr);
#line 203
      baselocal = (unsigned long )tmp___3;
      }
#line 204
      if ((unsigned long )(! baselocal) & 2147483648UL) {
        {
#line 205
        mask.s_addr = htonl((uint32_t )4278190080UL);
        }
      } else
#line 206
      if ((baselocal & 3221225472UL) == 2147483648UL) {
        {
#line 207
        mask.s_addr = htonl((uint32_t )4294901760UL);
        }
      } else
#line 208
      if ((baselocal & 4026531840UL) == 3758096384UL) {
        {
#line 209
        mask.s_addr = htonl((uint32_t )4278190080UL);
        }
      } else {
        {
#line 211
        configparseerr___0(ads___7, fn, lno, "network address `%s\' in sortlist is not in classed ranges, must specify mask explicitly",
                           tbuf);
        }
#line 214
        goto while_continue;
      }
    }
#line 218
    ads___7->sortlist[ads___7->nsortlist].base = base;
#line 219
    ads___7->sortlist[ads___7->nsortlist].mask = mask;
#line 220
    (ads___7->nsortlist) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  return;
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_options___0(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  char const   *word ;
  char *ep ;
  unsigned long v ;
  int l ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 231
  if (! buf___17) {
#line 231
    return;
  }
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 233
    tmp___5 = nextword___0(& buf___17, & word, & l);
    }
#line 233
    if (! tmp___5) {
#line 233
      goto while_break;
    }
#line 234
    if (l == 5) {
      {
#line 234
      tmp = memcmp((void const   *)word, (void const   *)"debug", (size_t )5);
      }
#line 234
      if (! tmp) {
#line 235
        ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 8U);
#line 236
        goto while_continue;
      }
    }
#line 238
    if (l >= 6) {
      {
#line 238
      tmp___0 = memcmp((void const   *)word, (void const   *)"ndots:", (size_t )6);
      }
#line 238
      if (! tmp___0) {
        {
#line 239
        v = strtoul((char const   */* __restrict  */)(word + 6), (char **/* __restrict  */)(& ep),
                    10);
        }
#line 240
        if (l == 6) {
          {
#line 241
          configparseerr___0(ads___7, fn, lno, "option `%.*s\' malformed or has bad value",
                             l, word);
          }
#line 243
          goto while_continue;
        } else
#line 240
        if ((unsigned long )ep != (unsigned long )(word + l)) {
          {
#line 241
          configparseerr___0(ads___7, fn, lno, "option `%.*s\' malformed or has bad value",
                             l, word);
          }
#line 243
          goto while_continue;
        } else
#line 240
        if (v > 2147483647UL) {
          {
#line 241
          configparseerr___0(ads___7, fn, lno, "option `%.*s\' malformed or has bad value",
                             l, word);
          }
#line 243
          goto while_continue;
        }
#line 245
        ads___7->searchndots = (int )v;
#line 246
        goto while_continue;
      }
    }
#line 248
    if (l >= 12) {
      {
#line 248
      tmp___4 = memcmp((void const   *)word, (void const   *)"adns_checkc:", (size_t )12);
      }
#line 248
      if (! tmp___4) {
        {
#line 249
        tmp___3 = strcmp(word + 12, "none");
        }
#line 249
        if (tmp___3) {
          {
#line 252
          tmp___2 = strcmp(word + 12, "entex");
          }
#line 252
          if (tmp___2) {
            {
#line 255
            tmp___1 = strcmp(word + 12, "freq");
            }
#line 255
            if (tmp___1) {
              {
#line 258
              configparseerr___0(ads___7, fn, lno, "option adns_checkc has bad value `%s\' (must be none, entex or freq",
                                 word + 12);
              }
            } else {
#line 256
              ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 768U);
            }
          } else {
#line 253
            ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags & 4294966527U);
#line 254
            ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 256U);
          }
        } else {
#line 250
          ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags & 4294966527U);
#line 251
          ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 256U);
        }
#line 261
        goto while_continue;
      }
    }
    {
#line 263
    adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown option `%.*s\'", fn, lno,
               l, word);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 265
  return;
}
}
#line 267 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_clearnss___0(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 


  {
#line 269
  ads___7->nservers = 0;
#line 270
  return;
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_include___0(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 


  {
#line 274
  if (! *buf___17) {
    {
#line 275
    configparseerr___0(ads___7, fn, lno, "`include\' directive with no filename");
    }
#line 276
    return;
  }
  {
#line 278
  readconfig___0(ads___7, buf___17, 1);
  }
#line 279
  return;
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_lookup___0(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  int found_bind ;
  char const   *word ;
  int l ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 283
  found_bind = 0;
#line 287
  if (! *buf___17) {
    {
#line 288
    configparseerr___0(ads___7, fn, lno, "`lookup\' directive with no databases");
    }
#line 289
    return;
  }
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 292
    tmp___2 = nextword___0(& buf___17, & word, & l);
    }
#line 292
    if (! tmp___2) {
#line 292
      goto while_break;
    }
#line 293
    if (l == 4) {
      {
#line 293
      tmp___1 = memcmp((void const   *)word, (void const   *)"bind", (size_t )4);
      }
#line 293
      if (tmp___1) {
#line 293
        goto _L___0;
      } else {
#line 294
        found_bind = 1;
      }
    } else
    _L___0: /* CIL Label */ 
#line 295
    if (l == 4) {
      {
#line 295
      tmp___0 = memcmp((void const   *)word, (void const   *)"file", (size_t )4);
      }
#line 295
      if (tmp___0) {
#line 295
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 297
    if (l == 2) {
      {
#line 297
      tmp = memcmp((void const   *)word, (void const   *)"yp", (size_t )2);
      }
#line 297
      if (tmp) {
        {
#line 301
        adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown `lookup\' database `%.*s\'",
                   fn, lno, l, word);
#line 303
        found_bind = -1;
        }
      } else {
        {
#line 298
        adns__diag(ads___7, -1, (adns_query )0, "%s:%d: yp lookups not supported by adns",
                   fn, lno);
#line 299
        found_bind = -1;
        }
      }
    } else {
      {
#line 301
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown `lookup\' database `%.*s\'",
                 fn, lno, l, word);
#line 303
      found_bind = -1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 306
  if (! found_bind) {
    {
#line 307
    adns__diag(ads___7, -1, (adns_query )0, "%s:%d: `lookup\' specified, but not `bind\'",
               fn, lno);
    }
  }
#line 308
  return;
}
}
#line 310 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static struct configcommandinfo  const  configcommandinfos___0[9]  = 
#line 310
  {      {"nameserver", & ccf_nameserver___0}, 
        {"domain", & ccf_search___0}, 
        {"search", & ccf_search___0}, 
        {"sortlist", & ccf_sortlist___0}, 
        {"options", & ccf_options___0}, 
        {"clearnameservers", & ccf_clearnss___0}, 
        {"include", & ccf_include___0}, 
        {"lookup", & ccf_lookup___0}, 
        {(char const   *)0, (void (*)(adns_state ads , char const   *fn , int lno , char const   *buf ))0}};
#line 330 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int gl_file___0(adns_state ads___7 , getline_ctx *src_io , char const   *filename ,
                       int lno , char *buf___17 , int buflen ) 
{ 
  FILE *file ;
  int c ;
  int i ;
  char *p ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 332
  file = src_io->file;
#line 336
  p = buf___17;
#line 337
  buflen --;
#line 338
  i = 0;
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (i == buflen) {
      {
#line 342
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: line too long, ignored", filename,
                 lno);
      }
#line 343
      goto x_badline;
    }
    {
#line 345
    c = _IO_getc(file);
    }
#line 346
    if (! c) {
      {
#line 347
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: line contains nul, ignored",
                 filename, lno);
      }
#line 348
      goto x_badline;
    } else
#line 349
    if (c == 10) {
#line 350
      goto while_break;
    } else
#line 351
    if (c == -1) {
      {
#line 352
      tmp___2 = ferror(file);
      }
#line 352
      if (tmp___2) {
        {
#line 353
        tmp = __errno_location();
#line 353
        saveerr___0(ads___7, *tmp);
#line 354
        tmp___0 = __errno_location();
#line 354
        tmp___1 = strerror(*tmp___0);
#line 354
        adns__diag(ads___7, -1, (adns_query )0, "%s:%d: read error: %s", filename,
                   lno, tmp___1);
        }
#line 356
        return (-1);
      }
#line 358
      if (! i) {
#line 358
        return (-1);
      }
#line 359
      goto while_break;
    } else {
#line 361
      tmp___3 = p;
#line 361
      p ++;
#line 361
      *tmp___3 = (char )c;
#line 362
      i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 366
  tmp___4 = p;
#line 366
  p ++;
#line 366
  *tmp___4 = (char)0;
#line 367
  return (i);
  x_badline: 
  {
#line 370
  saveerr___0(ads___7, 22);
  }
  {
#line 371
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 371
    c = _IO_getc(file);
    }
#line 371
    if (c != -1) {
#line 371
      if (! (c != 10)) {
#line 371
        goto while_break___0;
      }
    } else {
#line 371
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 372
  return (-2);
}
}
#line 375 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int gl_text___0(adns_state ads___7 , getline_ctx *src_io , char const   *filename ,
                       int lno , char *buf___17 , int buflen ) 
{ 
  char const   *cp ;
  int l ;
  size_t tmp ;

  {
#line 377
  cp = src_io->text;
#line 380
  if (! cp) {
#line 380
    return (-1);
  } else
#line 380
  if (! *cp) {
#line 380
    return (-1);
  }
#line 382
  if ((int const   )*cp == 59) {
#line 382
    cp ++;
  } else
#line 382
  if ((int const   )*cp == 10) {
#line 382
    cp ++;
  }
  {
#line 383
  tmp = strcspn(cp, ";\n");
#line 383
  l = (int )tmp;
#line 384
  src_io->text = cp + l;
  }
#line 386
  if (l >= buflen) {
    {
#line 387
    adns__diag(ads___7, -1, (adns_query )0, "%s:%d: line too long, ignored", filename,
               lno);
#line 388
    saveerr___0(ads___7, 22);
    }
#line 389
    return (-2);
  }
  {
#line 392
  memcpy((void */* __restrict  */)buf___17, (void const   */* __restrict  */)cp, (size_t )l);
#line 393
  *(buf___17 + l) = (char)0;
  }
#line 394
  return (l);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfiggeneric___0(adns_state ads___7 , char const   *filename , int (*getline___0)(adns_state ads ,
                                                                                                   getline_ctx * ,
                                                                                                   char const   *filename ,
                                                                                                   int lno ,
                                                                                                   char *buf ,
                                                                                                   int buflen ) ,
                                  getline_ctx gl_ctx ) 
{ 
  char linebuf[2000] ;
  char *p ;
  char *q ;
  int lno ;
  int l ;
  int dirl ;
  struct configcommandinfo  const  *ccip ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 410
  lno = 1;
  {
#line 410
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 410
    l = (*getline___0)(ads___7, & gl_ctx, filename, lno, linebuf, (int )sizeof(linebuf));
    }
#line 410
    if (! (l != -1)) {
#line 410
      goto while_break;
    }
#line 413
    if (l == -2) {
#line 413
      goto __Cont;
    }
    {
#line 414
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 414
      if (l > 0) {
        {
#line 414
        tmp = ctype_whitespace((int )linebuf[l - 1]);
        }
#line 414
        if (! tmp) {
#line 414
          goto while_break___0;
        }
      } else {
#line 414
        goto while_break___0;
      }
#line 414
      l --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 415
    linebuf[l] = (char)0;
#line 416
    p = linebuf;
    {
#line 417
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 417
      tmp___0 = ctype_whitespace((int )*p);
      }
#line 417
      if (! tmp___0) {
#line 417
        goto while_break___1;
      }
#line 417
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 418
    if ((int )*p == 35) {
#line 418
      goto __Cont;
    } else
#line 418
    if ((int )*p == 59) {
#line 418
      goto __Cont;
    } else
#line 418
    if (! *p) {
#line 418
      goto __Cont;
    }
#line 419
    q = p;
    {
#line 420
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 420
      if (*q) {
        {
#line 420
        tmp___1 = ctype_whitespace((int )*q);
        }
#line 420
        if (tmp___1) {
#line 420
          goto while_break___2;
        }
      } else {
#line 420
        goto while_break___2;
      }
#line 420
      q ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 421
    dirl = (int )(q - p);
#line 422
    ccip = configcommandinfos___0;
    {
#line 422
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 422
      if (ccip->name) {
        {
#line 422
        tmp___2 = strlen((char const   *)ccip->name);
        }
#line 422
        if (tmp___2 == (size_t )dirl) {
          {
#line 422
          tmp___3 = memcmp((void const   *)ccip->name, (void const   *)p, (size_t )(q - p));
          }
#line 422
          if (! tmp___3) {
#line 422
            goto while_break___3;
          }
        }
      } else {
#line 422
        goto while_break___3;
      }
#line 422
      ccip ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 426
    if (! ccip->name) {
      {
#line 427
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown configuration directive `%.*s\'",
                 filename, lno, (int )(q - p), p);
      }
#line 429
      goto __Cont;
    }
    {
#line 431
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 431
      tmp___4 = ctype_whitespace((int )*q);
      }
#line 431
      if (! tmp___4) {
#line 431
        goto while_break___4;
      }
#line 431
      q ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 432
    (*(ccip->fn))(ads___7, filename, lno, (char const   *)q);
    }
    __Cont: /* CIL Label */ 
#line 410
    lno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 434
  return;
}
}
#line 436 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static char const   *instrum_getenv___0(adns_state ads___7 , char const   *envvar ) 
{ 
  char const   *value ;
  char *tmp ;

  {
  {
#line 439
  tmp = getenv(envvar);
#line 439
  value = (char const   *)tmp;
  }
#line 440
  if (! value) {
    {
#line 440
    adns__debug(ads___7, -1, (adns_query )0, "environment variable %s not set", envvar);
    }
  } else {
    {
#line 441
    adns__debug(ads___7, -1, (adns_query )0, "environment variable %s set to `%s\'",
                envvar, value);
    }
  }
#line 443
  return (value);
}
}
#line 446 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfig___0(adns_state ads___7 , char const   *filename , int warnmissing ) 
{ 
  getline_ctx gl_ctx ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 449
  gl_ctx.file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 450
  if (! gl_ctx.file) {
    {
#line 451
    tmp = __errno_location();
    }
#line 451
    if (*tmp == 2) {
#line 452
      if (warnmissing) {
        {
#line 453
        adns__debug(ads___7, -1, (adns_query )0, "configuration file `%s\' does not exist",
                    filename);
        }
      }
#line 455
      return;
    }
    {
#line 457
    tmp___0 = __errno_location();
#line 457
    saveerr___0(ads___7, *tmp___0);
#line 458
    tmp___1 = __errno_location();
#line 458
    tmp___2 = strerror(*tmp___1);
#line 458
    adns__diag(ads___7, -1, (adns_query )0, "cannot open configuration file `%s\': %s",
               filename, tmp___2);
    }
#line 460
    return;
  }
  {
#line 463
  readconfiggeneric___0(ads___7, filename, & gl_file___0, gl_ctx);
#line 465
  fclose(gl_ctx.file);
  }
#line 466
  return;
}
}
#line 468 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfigtext___0(adns_state ads___7 , char const   *text , char const   *showname ) 
{ 
  getline_ctx gl_ctx ;

  {
  {
#line 472
  gl_ctx.text = text;
#line 473
  readconfiggeneric___0(ads___7, showname, & gl_text___0, gl_ctx);
  }
#line 474
  return;
}
}
#line 476 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfigenv___0(adns_state ads___7 , char const   *envvar ) 
{ 
  char const   *filename ;

  {
#line 479
  if ((unsigned int )ads___7->iflags & 1U) {
    {
#line 480
    adns__debug(ads___7, -1, (adns_query )0, "not checking environment variable `%s\'",
                envvar);
    }
#line 481
    return;
  }
  {
#line 483
  filename = instrum_getenv___0(ads___7, envvar);
  }
#line 484
  if (filename) {
    {
#line 484
    readconfig___0(ads___7, filename, 1);
    }
  }
#line 485
  return;
}
}
#line 487 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfigenvtext___0(adns_state ads___7 , char const   *envvar ) 
{ 
  char const   *textdata ;

  {
#line 490
  if ((unsigned int )ads___7->iflags & 1U) {
    {
#line 491
    adns__debug(ads___7, -1, (adns_query )0, "not checking environment variable `%s\'",
                envvar);
    }
#line 492
    return;
  }
  {
#line 494
  textdata = instrum_getenv___0(ads___7, envvar);
  }
#line 495
  if (textdata) {
    {
#line 495
    readconfigtext___0(ads___7, textdata, envvar);
    }
  }
#line 496
  return;
}
}
#line 508 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int init_begin___0(adns_state *ads_r , adns_initflags flags , adns_logcallbackfn *logfn ,
                          void *logfndata ) 
{ 
  adns_state ads___7 ;
  pid_t pid ;
  void *tmp ;
  int *tmp___0 ;
  adns_query tmp___1 ;
  adns_query tmp___2 ;
  adns_query tmp___3 ;
  adns_query tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __suseconds_t tmp___9 ;

  {
  {
#line 513
  tmp = Hmalloc(sizeof(*ads___7));
#line 513
  ads___7 = (adns_state )tmp;
  }
#line 513
  if (! ads___7) {
    {
#line 513
    tmp___0 = __errno_location();
    }
#line 513
    return (*tmp___0);
  }
  {
#line 515
  ads___7->iflags = flags;
#line 516
  ads___7->logfn = logfn;
#line 517
  ads___7->logfndata = logfndata;
#line 518
  ads___7->configerrno = 0;
#line 519
  tmp___1 = (adns_query )0;
#line 519
  ads___7->udpw.tail = tmp___1;
#line 519
  ads___7->udpw.head = tmp___1;
#line 520
  tmp___2 = (adns_query )0;
#line 520
  ads___7->tcpw.tail = tmp___2;
#line 520
  ads___7->tcpw.head = tmp___2;
#line 521
  tmp___3 = (adns_query )0;
#line 521
  ads___7->childw.tail = tmp___3;
#line 521
  ads___7->childw.head = tmp___3;
#line 522
  tmp___4 = (adns_query )0;
#line 522
  ads___7->output.tail = tmp___4;
#line 522
  ads___7->output.head = tmp___4;
#line 523
  ads___7->forallnext = (adns_query )0;
#line 524
  ads___7->nextid = 12575;
#line 525
  tmp___5 = -1;
#line 525
  ads___7->tcpsocket = tmp___5;
#line 525
  ads___7->udpsocket = tmp___5;
#line 526
  adns__vbuf_init(& ads___7->tcpsend);
#line 527
  adns__vbuf_init(& ads___7->tcprecv);
#line 528
  ads___7->tcprecv_skip = 0;
#line 529
  tmp___8 = 0;
#line 529
  ads___7->tcpserver = tmp___8;
#line 529
  tmp___7 = tmp___8;
#line 529
  ads___7->nsearchlist = tmp___7;
#line 529
  tmp___6 = tmp___7;
#line 529
  ads___7->nsortlist = tmp___6;
#line 529
  ads___7->nservers = tmp___6;
#line 530
  ads___7->searchndots = 1;
#line 531
  ads___7->tcpstate = (enum adns__tcpstate )0;
#line 532
  tmp___9 = (__suseconds_t )0;
#line 532
  ads___7->tcptimeout.tv_usec = tmp___9;
#line 532
  ads___7->tcptimeout.tv_sec = tmp___9;
#line 533
  ads___7->searchlist = (char **)0;
#line 535
  pid = Hgetpid();
#line 536
  ads___7->rand48xsubi[0] = (unsigned short )pid;
#line 537
  ads___7->rand48xsubi[1] = (unsigned short )((unsigned long )pid >> 16);
#line 538
  ads___7->rand48xsubi[2] = (unsigned short )((unsigned long )pid ^ ((unsigned long )pid >> 16));
#line 540
  *ads_r = ads___7;
  }
#line 541
  return (0);
}
}
#line 544 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int init_finish___0(adns_state ads___7 ) 
{ 
  struct in_addr ia ;
  struct protoent *proto ;
  int r ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 549
  if (! ads___7->nservers) {
#line 550
    if (ads___7->logfn) {
#line 550
      if ((unsigned int )ads___7->iflags & 8U) {
        {
#line 551
        adns__lprintf(ads___7, "adns: no nameservers, using localhost\n");
        }
      }
    }
    {
#line 552
    ia.s_addr = htonl((in_addr_t )2130706433);
#line 553
    addserver___0(ads___7, ia);
    }
  }
  {
#line 556
  proto = getprotobyname("udp");
  }
#line 556
  if (! proto) {
#line 556
    r = 92;
#line 556
    goto x_free;
  }
  {
#line 557
  ads___7->udpsocket = Hsocket(2, 2, proto->p_proto);
  }
#line 558
  if (ads___7->udpsocket < 0) {
    {
#line 558
    tmp = __errno_location();
#line 558
    r = *tmp;
    }
#line 558
    goto x_free;
  }
  {
#line 560
  r = adns__setnonblock(ads___7, ads___7->udpsocket);
  }
#line 561
  if (r) {
    {
#line 561
    tmp___0 = __errno_location();
#line 561
    r = *tmp___0;
    }
#line 561
    goto x_closeudp;
  }
#line 563
  return (0);
  x_closeudp: 
  {
#line 566
  Hclose(ads___7->udpsocket);
  }
  x_free: 
  {
#line 568
  Hfree((void *)ads___7);
  }
#line 569
  return (r);
}
}
#line 572 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void init_abort___0(adns_state ads___7 ) 
{ 


  {
#line 573
  if (ads___7->nsearchlist) {
    {
#line 574
    Hfree((void *)*(ads___7->searchlist + 0));
#line 575
    Hfree((void *)ads___7->searchlist);
    }
  }
  {
#line 577
  Hfree((void *)ads___7);
  }
#line 578
  return;
}
}
#line 580 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void logfn_file___0(adns_state ads___7 , void *logfndata , char const   *fmt ,
                           va_list al ) 
{ 


  {
  {
#line 582
  vfprintf((FILE */* __restrict  */)logfndata, (char const   */* __restrict  */)fmt,
           al);
  }
#line 583
  return;
}
}
#line 585 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int init_files___0(adns_state *ads_r , adns_initflags flags , adns_logcallbackfn *logfn ,
                          void *logfndata ) 
{ 
  adns_state ads___7 ;
  char const   *res_options ;
  char const   *adns_res_options ;
  int r ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 591
  r = init_begin___0(& ads___7, flags, logfn, logfndata);
  }
#line 592
  if (r) {
#line 592
    return (r);
  }
  {
#line 594
  res_options = instrum_getenv___0(ads___7, "RES_OPTIONS");
#line 595
  adns_res_options = instrum_getenv___0(ads___7, "ADNS_RES_OPTIONS");
#line 596
  ccf_options___0(ads___7, "RES_OPTIONS", -1, res_options);
#line 597
  ccf_options___0(ads___7, "ADNS_RES_OPTIONS", -1, adns_res_options);
#line 599
  readconfig___0(ads___7, "/etc/resolv.conf", 1);
#line 600
  readconfig___0(ads___7, "/etc/resolv-adns.conf", 0);
#line 601
  readconfigenv___0(ads___7, "RES_CONF");
#line 602
  readconfigenv___0(ads___7, "ADNS_RES_CONF");
#line 604
  readconfigenvtext___0(ads___7, "RES_CONF_TEXT");
#line 605
  readconfigenvtext___0(ads___7, "ADNS_RES_CONF_TEXT");
#line 607
  ccf_options___0(ads___7, "RES_OPTIONS", -1, res_options);
#line 608
  ccf_options___0(ads___7, "ADNS_RES_OPTIONS", -1, adns_res_options);
#line 610
  tmp = instrum_getenv___0(ads___7, "LOCALDOMAIN");
#line 610
  ccf_search___0(ads___7, "LOCALDOMAIN", -1, tmp);
#line 611
  tmp___0 = instrum_getenv___0(ads___7, "ADNS_LOCALDOMAIN");
#line 611
  ccf_search___0(ads___7, "ADNS_LOCALDOMAIN", -1, tmp___0);
  }
#line 613
  if (ads___7->configerrno) {
#line 613
    if (ads___7->configerrno != 22) {
      {
#line 614
      r = ads___7->configerrno;
#line 615
      init_abort___0(ads___7);
      }
#line 616
      return (r);
    }
  }
  {
#line 619
  r = init_finish___0(ads___7);
  }
#line 620
  if (r) {
#line 620
    return (r);
  }
  {
#line 622
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
#line 623
  *ads_r = ads___7;
  }
#line 624
  return (0);
}
}
#line 631 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int init_strcfg___0(adns_state *ads_r , adns_initflags flags , adns_logcallbackfn *logfn ,
                           void *logfndata , char const   *configtext ) 
{ 
  adns_state ads___7 ;
  int r ;

  {
  {
#line 637
  r = init_begin___0(& ads___7, flags, logfn, logfndata);
  }
#line 638
  if (r) {
#line 638
    return (r);
  }
  {
#line 640
  readconfigtext___0(ads___7, configtext, "<supplied configuration text>");
  }
#line 641
  if (ads___7->configerrno) {
    {
#line 642
    r = ads___7->configerrno;
#line 643
    init_abort___0(ads___7);
    }
#line 644
    return (r);
  }
  {
#line 647
  r = init_finish___0(ads___7);
  }
#line 647
  if (r) {
#line 647
    return (r);
  }
  {
#line 648
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
#line 649
  *ads_r = ads___7;
  }
#line 650
  return (0);
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
static vbuf vbw___0  ;
#line 175 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
static void Tvbpollevents___0(int events ) 
{ 
  char const   *delim ;

  {
#line 176
  delim = "";
#line 177
  events &= 7;
#line 178
  if (! events) {
    {
#line 178
    Tvba("0");
    }
#line 178
    return;
  }
#line 179
  if (events & 1) {
    {
#line 179
    Tvba("POLLIN");
#line 179
    delim = "|";
    }
  }
#line 180
  if (events & 4) {
    {
#line 180
    Tvba(delim);
#line 180
    Tvba("POLLOUT");
#line 180
    delim = "|";
    }
  }
#line 181
  if (events & 2) {
    {
#line 181
    Tvba(delim);
#line 181
    Tvba("POLLPRI");
    }
  }
#line 182
  return;
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
static unsigned long malloccount___0  ;
#line 241 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
static unsigned long mallocfailat___0  ;
#line 242 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
static struct __anonstruct_mallocedlist_90___0 mallocedlist___0  ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 336
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setvbuf)(FILE * __restrict  __stream ,
                                                                              char * __restrict  __buf ,
                                                                              int __modes ,
                                                                              size_t __n ) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static FILE *Tinputfile  ;
#line 13 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static FILE *Treportfile  ;
#line 14 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static vbuf vb2  ;
#line 18 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static void Tensurereportfile(void) 
{ 
  char const   *fdstr ;
  int fd ;
  char *tmp ;

  {
#line 21
  if (Treportfile) {
#line 21
    return;
  }
  {
#line 22
  Treportfile = stderr;
#line 23
  tmp = getenv("ADNS_TEST_REPORT_FD");
#line 23
  fdstr = (char const   *)tmp;
  }
#line 23
  if (! fdstr) {
#line 23
    return;
  }
  {
#line 24
  fd = atoi(fdstr);
#line 25
  Treportfile = fdopen(fd, "a");
  }
#line 25
  if (! Treportfile) {
    {
#line 25
    Tfailed("fdopen ADNS_TEST_REPORT_FD");
    }
  }
#line 26
  return;
}
}
#line 27 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static void Psyntax(char const   *where ) 
{ 


  {
  {
#line 28
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adns test harness: syntax error in test log input file: %s\n",
          where);
#line 29
  exit(-1);
  }
}
}
#line 31 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static void Pcheckinput(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 32
  tmp = ferror(Tinputfile);
  }
#line 32
  if (tmp) {
    {
#line 32
    Tfailed("read test log input file");
    }
  }
  {
#line 33
  tmp___0 = feof(Tinputfile);
  }
#line 33
  if (tmp___0) {
    {
#line 33
    Psyntax("eof at syscall reply");
    }
  }
#line 34
  return;
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static void Parg(char const   *argname ) 
{ 
  int l ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 59
  tmp = vb2.used;
#line 59
  (vb2.used) ++;
#line 59
  if ((int )*(vb2.buf + tmp) != 32) {
    {
#line 59
    Psyntax("not a space before argument");
    }
  }
  {
#line 60
  tmp___0 = strlen(argname);
#line 60
  l = (int )tmp___0;
#line 61
  tmp___1 = memcmp((void const   *)(vb2.buf + vb2.used), (void const   *)argname,
                   (size_t )l);
  }
#line 61
  if (tmp___1) {
    {
#line 61
    Psyntax("argument name wrong");
    }
  }
#line 62
  vb2.used += l;
#line 63
  tmp___2 = vb2.used;
#line 63
  (vb2.used) ++;
#line 63
  if ((int )*(vb2.buf + tmp___2) != 61) {
    {
#line 63
    Psyntax("not = after argument name");
    }
  }
#line 64
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static int Pstring_maybe(char const   *string ) 
{ 
  int l ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 67
  tmp = strlen(string);
#line 67
  l = (int )tmp;
#line 68
  tmp___0 = memcmp((void const   *)(vb2.buf + vb2.used), (void const   *)string, (size_t )l);
  }
#line 68
  if (tmp___0) {
#line 68
    return (0);
  }
#line 69
  vb2.used += l;
#line 70
  return (1);
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static void Pstring(char const   *string , char const   *emsg ) 
{ 
  int tmp ;

  {
  {
#line 73
  tmp = Pstring_maybe(string);
  }
#line 73
  if (tmp) {
#line 73
    return;
  }
  {
#line 74
  Psyntax(emsg);
  }
#line 75
  return;
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static int Perrno(char const   *stuff ) 
{ 
  struct Terrno  const  *te ;
  int r ;
  char *ep ;
  int tmp ;
  unsigned long tmp___0 ;

  {
#line 80
  te = Terrnos;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    if (te->n) {
      {
#line 80
      tmp = strcmp((char const   *)te->n, stuff);
      }
#line 80
      if (! tmp) {
#line 80
        goto while_break;
      }
    } else {
#line 80
      goto while_break;
    }
#line 80
    te ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  if (te->n) {
#line 81
    return ((int )te->v);
  }
  {
#line 82
  tmp___0 = strtoul((char const   */* __restrict  */)(stuff + 2), (char **/* __restrict  */)(& ep),
                    10);
#line 82
  r = (int )tmp___0;
  }
#line 83
  if (*ep) {
    {
#line 83
    Psyntax("errno value not recognised, not numeric");
    }
  }
#line 84
  return (r);
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static void P_updatetime(void) 
{ 
  int chars ;
  unsigned long sec ;
  unsigned long usec ;
  int tmp ;

  {
  {
#line 89
  tmp = adns__vbuf_ensure(& vb2, 1000);
  }
#line 89
  if (! tmp) {
    {
#line 89
    Tnomem();
    }
  }
  {
#line 90
  fgets((char */* __restrict  */)vb2.buf, vb2.avail, (FILE */* __restrict  */)Tinputfile);
#line 90
  Pcheckinput();
#line 91
  chars = -1;
#line 92
  sscanf((char const   */* __restrict  */)vb2.buf, (char const   */* __restrict  */)" +%lu.%lu%n",
         & sec, & usec, & chars);
  }
#line 93
  if (chars == -1) {
    {
#line 93
    Psyntax("update time invalid");
    }
  }
#line 94
  currenttime.tv_sec = (__time_t )((unsigned long )currenttime.tv_sec + sec);
#line 95
  currenttime.tv_usec = (__suseconds_t )((unsigned long )currenttime.tv_usec + usec);
#line 96
  if (currenttime.tv_usec > 1000000L) {
#line 97
    (currenttime.tv_sec) ++;
#line 98
    currenttime.tv_usec -= 1000000L;
  }
#line 100
  if ((int )*(vb2.buf + chars) != 10) {
    {
#line 100
    Psyntax("not newline after update time");
    }
  }
#line 101
  return;
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static void Pfdset(fd_set *set , int max ) 
{ 
  int r ;
  int c ;
  char *ep ;
  int tmp ;
  int __d0 ;
  int __d1 ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
#line 105
  tmp = vb2.used;
#line 105
  (vb2.used) ++;
#line 105
  if ((int )*(vb2.buf + tmp) != 91) {
    {
#line 105
    Psyntax("fd set start not [");
    }
  }
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& set->__fds_bits[0]): "memory");
#line 106
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  if ((int )*(vb2.buf + vb2.used) == 93) {
#line 107
    (vb2.used) ++;
#line 107
    return;
  }
  {
#line 108
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 109
    tmp___0 = strtoul((char const   */* __restrict  */)(vb2.buf + vb2.used), (char **/* __restrict  */)(& ep),
                      10);
#line 109
    r = (int )tmp___0;
    }
#line 110
    if (r >= max) {
      {
#line 110
      Psyntax("fd set member > max");
      }
    }
#line 111
    if ((unsigned long )ep == (unsigned long )((char *)vb2.buf + vb2.used)) {
      {
#line 111
      Psyntax("empty entry in fd set");
      }
    }
#line 112
    set->__fds_bits[r / (8 * (int )sizeof(__fd_mask ))] |= 1L << r % (8 * (int )sizeof(__fd_mask ));
#line 113
    vb2.used = (int )(ep - (char *)vb2.buf);
#line 114
    tmp___1 = vb2.used;
#line 114
    (vb2.used) ++;
#line 114
    c = (int )*(vb2.buf + tmp___1);
#line 115
    if (c == 93) {
#line 115
      goto while_break___0;
    }
#line 116
    if (c != 44) {
      {
#line 116
      Psyntax("fd set separator not ,");
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 118
  return;
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static int Ppollfdevents(void) 
{ 
  int events ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 122
  tmp = Pstring_maybe("0");
  }
#line 122
  if (tmp) {
#line 122
    return (0);
  }
  {
#line 123
  events = 0;
#line 124
  tmp___1 = Pstring_maybe("POLLIN");
  }
#line 124
  if (tmp___1) {
    {
#line 125
    events |= 1;
#line 126
    tmp___0 = Pstring_maybe("|");
    }
#line 126
    if (! tmp___0) {
#line 126
      return (events);
    }
  }
  {
#line 128
  tmp___3 = Pstring_maybe("POLLOUT");
  }
#line 128
  if (tmp___3) {
    {
#line 129
    events |= 4;
#line 130
    tmp___2 = Pstring_maybe("|");
    }
#line 130
    if (! tmp___2) {
#line 130
      return (events);
    }
  }
  {
#line 132
  Pstring("POLLPRI", "pollfdevents PRI?");
  }
#line 133
  return (events);
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static void Ppollfds(struct pollfd *fds , int nfds ) 
{ 
  int i ;
  char *ep ;
  char const   *comma ;
  int tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 138
  comma = "";
#line 139
  tmp = vb2.used;
#line 139
  (vb2.used) ++;
#line 139
  if ((int )*(vb2.buf + tmp) != 91) {
    {
#line 139
    Psyntax("pollfds start not [");
    }
  }
#line 140
  i = 0;
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if (! (i < nfds)) {
#line 140
      goto while_break;
    }
    {
#line 141
    Pstring("{fd=", "{fd= in pollfds");
#line 142
    tmp___0 = strtoul((char const   */* __restrict  */)(vb2.buf + vb2.used), (char **/* __restrict  */)(& ep),
                      10);
#line 142
    fds->fd = (int )tmp___0;
#line 143
    vb2.used = (int )(ep - (char *)vb2.buf);
#line 144
    Pstring(", events=", ", events= in pollfds");
#line 145
    tmp___1 = Ppollfdevents();
#line 145
    fds->events = (short )tmp___1;
#line 146
    Pstring(", revents=", ", revents= in pollfds");
#line 147
    tmp___2 = Ppollfdevents();
#line 147
    fds->revents = (short )tmp___2;
#line 148
    Pstring("}", "} in pollfds");
#line 149
    Pstring(comma, "separator in pollfds");
#line 150
    comma = ", ";
#line 140
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 152
  tmp___3 = vb2.used;
#line 152
  (vb2.used) ++;
#line 152
  if ((int )*(vb2.buf + tmp___3) != 93) {
    {
#line 152
    Psyntax("pollfds end not ]");
    }
  }
#line 153
  return;
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static void Paddr(struct sockaddr *addr , int *lenr ) 
{ 
  struct sockaddr_in *sa___3 ;
  char *p ;
  char *ep ;
  long ul ;
  char *tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 156
  sa___3 = (struct sockaddr_in *)addr;
#line 159
  if (! ((unsigned long )*lenr >= sizeof(*sa___3))) {
    {
#line 159
    __assert_fail("*lenr >= sizeof(*sa)", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c",
                  159U, "Paddr");
    }
  }
  {
#line 160
  p = strchr((char const   *)(vb2.buf + vb2.used), ':');
  }
#line 161
  if (! p) {
    {
#line 161
    Psyntax("no port on address");
    }
  }
  {
#line 162
  tmp = p;
#line 162
  p ++;
#line 162
  *tmp = (char)0;
#line 163
  memset((void *)sa___3, 0, sizeof(*sa___3));
#line 164
  sa___3->sin_family = (sa_family_t )2;
#line 165
  tmp___0 = inet_aton((char const   *)(vb2.buf + vb2.used), & sa___3->sin_addr);
  }
#line 165
  if (! tmp___0) {
    {
#line 165
    Psyntax("invalid address");
    }
  }
  {
#line 166
  tmp___1 = strtoul((char const   */* __restrict  */)p, (char **/* __restrict  */)(& ep),
                    10);
#line 166
  ul = (long )tmp___1;
  }
#line 167
  if (*ep) {
#line 167
    if ((int )*ep != 32) {
      {
#line 167
      Psyntax("invalid port (bad syntax)");
      }
    }
  }
#line 168
  if (ul >= 65536L) {
    {
#line 168
    Psyntax("port too large");
    }
  }
  {
#line 169
  sa___3->sin_port = htons((uint16_t )ul);
#line 170
  *lenr = (int )sizeof(*sa___3);
#line 171
  vb2.used = (int )(ep - (char *)vb2.buf);
  }
#line 172
  return;
}
}
#line 174
static int Pbytes(byte *buf___17 , int maxlen ) ;
#line 174 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static char const   hexdigits[17]  = 
#line 174
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'\000'};
#line 173 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static int Pbytes(byte *buf___17 , int maxlen ) 
{ 
  int c ;
  int v ;
  int done ;
  char const   *pf ;
  char *tmp ;
  char *tmp___0 ;
  byte *tmp___1 ;

  {
#line 177
  done = 0;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 179
    c = _IO_getc(Tinputfile);
#line 179
    Pcheckinput();
    }
#line 180
    if (c == 10) {
#line 180
      goto __Cont;
    } else
#line 180
    if (c == 32) {
#line 180
      goto __Cont;
    } else
#line 180
    if (c == 9) {
#line 180
      goto __Cont;
    }
#line 181
    if (c == 46) {
#line 181
      goto while_break;
    }
    {
#line 182
    tmp = strchr(hexdigits, c);
#line 182
    pf = (char const   *)tmp;
    }
#line 182
    if (! pf) {
      {
#line 182
      Psyntax("invalid first hex digit");
      }
    }
    {
#line 183
    v = (int )((pf - hexdigits) << 4);
#line 184
    c = _IO_getc(Tinputfile);
#line 184
    Pcheckinput();
#line 185
    tmp___0 = strchr(hexdigits, c);
#line 185
    pf = (char const   *)tmp___0;
    }
#line 185
    if (! pf) {
      {
#line 185
      Psyntax("invalid second hex digit");
      }
    }
#line 186
    v = (int )((long )v | (pf - hexdigits));
#line 187
    if (maxlen <= 0) {
      {
#line 187
      Psyntax("buffer overflow in bytes");
      }
    }
#line 188
    tmp___1 = buf___17;
#line 188
    buf___17 ++;
#line 188
    *tmp___1 = (byte )v;
#line 189
    maxlen --;
#line 189
    done ++;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 191
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 192
    c = _IO_getc(Tinputfile);
#line 192
    Pcheckinput();
    }
#line 193
    if (c == 10) {
#line 193
      return (done);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 573 "/usr/include/stdio.h"
extern int fputc(int __c , FILE *__stream ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 68 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnslogres.c"
static char const   * const  progname  =    (char const   */* const  */)"adnslogres";
#line 69 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnslogres.c"
static char const   *config_text___0  ;
#line 76 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnslogres.c"
static void msg(char const   *fmt  , ...) 
{ 
  va_list al ;

  {
  {
#line 79
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
          progname);
#line 80
  __builtin_va_start(al, fmt);
#line 81
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           al);
#line 82
  __builtin_va_end(al);
#line 83
  fputc('\n', stderr);
  }
#line 84
  return;
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnslogres.c"
static void aargh(char const   *cause ) 
{ 
  char const   *why ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 87
  tmp = __errno_location();
#line 87
  tmp___0 = strerror(*tmp);
#line 87
  why = (char const   *)tmp___0;
  }
#line 88
  if (! why) {
#line 88
    why = "Unknown error";
  }
  {
#line 89
  tmp___1 = __errno_location();
#line 89
  msg("%s: %s (%d)", cause, why, *tmp___1);
#line 90
  Hexit(1);
  }
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnslogres.c"
static char buf___1[30]  ;
#line 96 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnslogres.c"
static char *ipaddr2domain(char *start , char **addr , char **rest ) 
{ 
  char *ptrs[5] ;
  int i ;
  char *tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
#line 101
  ptrs[0] = start;
  retry: 
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 103
    tmp___1 = __ctype_b_loc();
    }
#line 103
    if ((int const   )*(*tmp___1 + (int )((unsigned char )*(ptrs[0]))) & 2048) {
#line 103
      goto while_break;
    }
#line 104
    tmp___0 = ptrs[0];
#line 104
    (ptrs[0]) ++;
#line 104
    if (! *tmp___0) {
      {
#line 105
      strcpy((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"invalid.");
#line 106
      tmp = (char *)((void *)0);
#line 106
      *rest = tmp;
#line 106
      *addr = tmp;
      }
#line 107
      return (buf___1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 109
  i = 1;
  {
#line 109
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 109
    if (! (i < 5)) {
#line 109
      goto while_break___0;
    }
#line 110
    ptrs[i] = ptrs[i - 1];
    {
#line 111
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 111
      tmp___2 = __ctype_b_loc();
#line 111
      tmp___3 = ptrs[i];
#line 111
      (ptrs[i]) ++;
      }
#line 111
      if (! ((int const   )*(*tmp___2 + (int )((unsigned char )*tmp___3)) & 2048)) {
#line 111
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 112
    if (i == 4) {
      {
#line 112
      tmp___4 = __ctype_b_loc();
      }
#line 112
      if ((int const   )*(*tmp___4 + (int )((unsigned char )*(ptrs[i] + -1))) & 8192) {
#line 112
        goto _L___0;
      } else {
#line 115
        ptrs[0] = ptrs[i] - 1;
#line 116
        goto retry;
      }
    } else
    _L___0: /* CIL Label */ 
#line 112
    if (i != 4) {
#line 112
      if ((int )*(ptrs[i] + -1) != 46) {
#line 115
        ptrs[0] = ptrs[i] - 1;
#line 116
        goto retry;
      } else {
#line 112
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 112
    if (ptrs[i] - ptrs[i - 1] > 4L) {
#line 115
      ptrs[0] = ptrs[i] - 1;
#line 116
      goto retry;
    }
#line 109
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 119
  sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%.*s.%.*s.%.*s.%.*s.in-addr.arpa.",
          (int )((ptrs[4] - ptrs[3]) - 1L), ptrs[3], (int )((ptrs[3] - ptrs[2]) - 1L),
          ptrs[2], (int )((ptrs[2] - ptrs[1]) - 1L), ptrs[1], (int )((ptrs[1] - ptrs[0]) - 1L),
          ptrs[0]);
#line 124
  *addr = ptrs[0];
#line 125
  *rest = ptrs[4] - 1;
  }
#line 126
  return (buf___1);
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnslogres.c"
static void printline(FILE *outf , char *start , char *addr , char *rest , char *domain ) 
{ 
  int tmp ;

  {
#line 130
  if (domain) {
    {
#line 131
    fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)"%.*s%s%s",
            (int )(addr - start), start, domain, rest);
    }
  } else {
    {
#line 133
    fputs((char const   */* __restrict  */)start, (FILE */* __restrict  */)outf);
    }
  }
  {
#line 134
  tmp = ferror(outf);
  }
#line 134
  if (tmp) {
    {
#line 134
    aargh("write output");
    }
  }
#line 135
  return;
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnslogres.c"
static char buf___2[1024]  ;
#line 143 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnslogres.c"
static logline *readline(FILE *inf , adns_state adns , int opts ) 
{ 
  char *str ;
  logline *line ;
  size_t tmp ;
  void *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 148
  tmp___3 = fgets((char */* __restrict  */)(buf___2), 1024, (FILE */* __restrict  */)inf);
  }
#line 148
  if (tmp___3) {
    {
#line 149
    tmp = strlen((char const   *)(buf___2));
#line 149
    tmp___0 = Hmalloc((sizeof(*line) + tmp) + 1UL);
#line 149
    str = (char *)tmp___0;
    }
#line 150
    if (! str) {
      {
#line 150
      aargh("malloc");
      }
    }
    {
#line 151
    line = (logline *)str;
#line 152
    line->next = (struct logline *)((void *)0);
#line 153
    line->start = str + sizeof(logline );
#line 154
    strcpy((char */* __restrict  */)line->start, (char const   */* __restrict  */)(buf___2));
#line 155
    str = ipaddr2domain(line->start, & line->addr, & line->rest);
    }
#line 156
    if (opts & 1) {
#line 157
      if (line->addr) {
#line 157
        tmp___1 = (char const   *)line->addr;
      } else {
#line 157
        tmp___1 = "";
      }
      {
#line 157
      msg("submitting %.*s -> %s", (int )(line->rest - line->addr), tmp___1, str);
      }
    }
    {
#line 158
    tmp___2 = adns_submit(adns, (char const   *)str, (adns_rrtype )65548, (adns_queryflags )256,
                          (void *)0, & line->query);
    }
#line 158
    if (tmp___2) {
      {
#line 161
      aargh("adns_submit");
      }
    }
#line 162
    return (line);
  }
  {
#line 164
  tmp___4 = feof(inf);
  }
#line 164
  if (! tmp___4) {
    {
#line 165
    aargh("fgets");
    }
  }
#line 166
  return ((logline *)((void *)0));
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnslogres.c"
static void proclog(FILE *inf , FILE *outf , int maxpending , int opts ) 
{ 
  int eof ;
  int err ;
  int len ;
  adns_state adns ;
  adns_answer *answer ;
  logline *head ;
  logline *tail ;
  logline *line ;
  adns_initflags initflags___3 ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 176
  if (opts & 1) {
#line 176
    initflags___3 = (adns_initflags )8;
  } else {
#line 176
    initflags___3 = (adns_initflags )0;
  }
#line 177
  if (config_text___0) {
    {
#line 178
    tmp = __errno_location();
#line 178
    *tmp = adns_init_strcfg(& adns, initflags___3, stderr, config_text___0);
    }
  } else {
    {
#line 180
    tmp___0 = __errno_location();
#line 180
    *tmp___0 = adns_init(& adns, initflags___3, (FILE *)0);
    }
  }
  {
#line 182
  tmp___1 = __errno_location();
  }
#line 182
  if (*tmp___1) {
    {
#line 182
    aargh("adns_init");
    }
  }
  {
#line 183
  tail = readline(inf, adns, opts);
#line 183
  head = tail;
#line 184
  len = 1;
#line 184
  eof = 0;
  }
  {
#line 185
  while (1) {
    while_continue: /* CIL Label */ ;
#line 185
    if (! head) {
#line 185
      goto while_break;
    }
    {
#line 186
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 186
      if (! head) {
#line 186
        goto while_break___0;
      }
#line 187
      if (opts & 1) {
#line 188
        if (head->addr) {
#line 188
          tmp___2 = (char const   *)head->addr;
        } else {
#line 188
          tmp___2 = "";
        }
        {
#line 188
        msg("%d in queue; checking %.*s", len, (int )(head->rest - head->addr), tmp___2);
        }
      }
#line 190
      if (eof) {
#line 190
        goto _L;
      } else
#line 190
      if (len >= maxpending) {
        _L: /* CIL Label */ 
#line 191
        if (opts & 2) {
          {
#line 192
          err = adns_wait_poll(adns, & head->query, & answer, (void **)((void *)0));
          }
        } else {
          {
#line 194
          err = adns_wait(adns, & head->query, & answer, (void **)((void *)0));
          }
        }
      } else {
        {
#line 196
        err = adns_check(adns, & head->query, & answer, (void **)((void *)0));
        }
      }
#line 198
      if (err == 11) {
#line 198
        goto while_break___0;
      }
#line 199
      if (err) {
        {
#line 200
        tmp___3 = strerror(err);
#line 200
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: adns_wait/check: %s",
                progname, tmp___3);
#line 201
        Hexit(1);
        }
      }
#line 203
      if ((unsigned int )answer->status == 0U) {
#line 203
        tmp___4 = *(answer->rrs.str);
      } else {
#line 203
        tmp___4 = (char *)((void *)0);
      }
      {
#line 203
      printline(outf, head->start, head->addr, head->rest, tmp___4);
#line 205
      line = head;
#line 205
      head = head->next;
#line 206
      Hfree((void *)line);
#line 207
      Hfree((void *)answer);
#line 208
      len --;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 210
    if (! eof) {
      {
#line 211
      line = readline(inf, adns, opts);
      }
#line 212
      if (line) {
#line 213
        if (! head) {
#line 213
          head = line;
        } else {
#line 214
          tail->next = line;
        }
#line 215
        tail = line;
#line 215
        len ++;
      } else {
#line 217
        eof = 1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 221
  adns_finish(adns);
  }
#line 222
  return;
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnslogres.c"
static void printhelp(FILE *file ) 
{ 


  {
  {
#line 225
  fputs((char const   */* __restrict  */)"usage: adnslogres [<options>] [<logfile>]\n       adnslogres --version|--help\noptions: -c <concurrency>  set max number of outstanding queries\n         -p                use poll(2) instead of select(2)\n         -d                turn on debugging\n         -C <config>       use instead of contents of resolv.conf\n",
        (FILE */* __restrict  */)stdout);
  }
#line 232
  return;
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnslogres.c"
static void usage(void) 
{ 


  {
  {
#line 235
  printhelp(stderr);
#line 236
  Hexit(1);
  }
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_qstring___0(parseinfo const   *pai , int *cbyte_io , int max ,
                                   int *len_r , char **str_r ) 
{ 
  byte const   *dgram ;
  int l ;
  int cbyte___3 ;
  char *str ;
  int tmp ;
  void *tmp___0 ;

  {
#line 92
  dgram = (byte const   *)pai->dgram;
#line 96
  cbyte___3 = *cbyte_io;
#line 98
  if (cbyte___3 >= max) {
#line 98
    return ((adns_status )104);
  }
#line 99
  tmp = cbyte___3;
#line 99
  cbyte___3 ++;
#line 99
  l = (int )((int const   )*(dgram + tmp) & 255);
#line 100
  if (cbyte___3 + l > max) {
#line 100
    return ((adns_status )104);
  }
  {
#line 102
  tmp___0 = adns__alloc_interim((adns_query )pai->qu, (size_t )(l + 1));
#line 102
  str = (char *)tmp___0;
  }
#line 103
  if (! str) {
#line 103
    return ((adns_status )1);
  }
  {
#line 105
  *(str + l) = (char)0;
#line 106
  memcpy((void */* __restrict  */)str, (void const   */* __restrict  */)(dgram + cbyte___3),
         (size_t )l);
#line 108
  *len_r = l;
#line 109
  *str_r = str;
#line 110
  *cbyte_io = cbyte___3 + l;
  }
#line 112
  return ((adns_status )0);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_qstring___0(vbuf *vb___0 , char const   *dp , int len ) 
{ 
  unsigned char ch ;
  char buf___17[10] ;
  int cn ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 120
    tmp = adns__vbuf_appendstr(vb___0, "\"");
    }
#line 120
    if (! tmp) {
#line 120
      return ((adns_status )1);
    }
#line 120
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  cn = 0;
  {
#line 121
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 121
    if (! (cn < len)) {
#line 121
      goto while_break___0;
    }
#line 122
    tmp___0 = dp;
#line 122
    dp ++;
#line 122
    ch = (unsigned char )*tmp___0;
#line 123
    if ((int )ch == 92) {
      {
#line 124
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 124
        tmp___1 = adns__vbuf_appendstr(vb___0, "\\\\");
        }
#line 124
        if (! tmp___1) {
#line 124
          return ((adns_status )1);
        }
#line 124
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else
#line 125
    if ((int )ch == 34) {
      {
#line 126
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 126
        tmp___2 = adns__vbuf_appendstr(vb___0, "\\\"");
        }
#line 126
        if (! tmp___2) {
#line 126
          return ((adns_status )1);
        }
#line 126
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else
#line 127
    if ((int )ch >= 32) {
#line 127
      if ((int )ch <= 126) {
        {
#line 128
        tmp___3 = adns__vbuf_append(vb___0, (byte const   *)(& ch), 1);
        }
#line 128
        if (! tmp___3) {
#line 128
          return ((adns_status )1);
        }
      } else {
#line 127
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 130
      sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"\\x%02x",
              (int )ch);
      }
      {
#line 131
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 131
        tmp___4 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
        }
#line 131
        if (! tmp___4) {
#line 131
          return ((adns_status )1);
        }
#line 131
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 121
    cn ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 134
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 134
    tmp___5 = adns__vbuf_appendstr(vb___0, "\"");
    }
#line 134
    if (! tmp___5) {
#line 134
      return ((adns_status )1);
    }
#line 134
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 136
  return ((adns_status )0);
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_str___0(adns_query qu , void *datap ) 
{ 
  char **rrp ;

  {
  {
#line 144
  rrp = (char **)datap;
#line 146
  adns__makefinal_str(qu, rrp);
  }
#line 147
  return;
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_intstr___0(adns_query qu , void *datap ) 
{ 
  adns_rr_intstr *rrp ;

  {
  {
#line 154
  rrp = (adns_rr_intstr *)datap;
#line 156
  adns__makefinal_str(qu, & rrp->str);
  }
#line 157
  return;
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_manyistr___0(adns_query qu , void *datap ) 
{ 
  adns_rr_intstr **rrp ;
  adns_rr_intstr *te ;
  adns_rr_intstr *table ;
  void *tablev ;
  int tc ;

  {
#line 164
  rrp = (adns_rr_intstr **)datap;
#line 169
  tc = 0;
#line 169
  te = *rrp;
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    if (! (te->i >= 0)) {
#line 169
      goto while_break;
    }
#line 169
    te ++;
#line 169
    tc ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 170
  tablev = (void *)*rrp;
#line 171
  adns__makefinal_block(qu, & tablev, sizeof(*te) * (unsigned long )(tc + 1));
#line 172
  table = (adns_rr_intstr *)tablev;
#line 172
  *rrp = table;
#line 173
  te = *rrp;
  }
  {
#line 173
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 173
    if (! (te->i >= 0)) {
#line 173
      goto while_break___0;
    }
    {
#line 174
    adns__makefinal_str(qu, & te->str);
#line 173
    te ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 175
  return;
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_txt___0(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  adns_rr_intstr **rrp ;
  adns_rr_intstr *table ;
  adns_rr_intstr *te ;
  byte const   *dgram ;
  int ti ;
  int tc ;
  int l ;
  int startbyte ;
  adns_status st ;
  int tmp ;
  void *tmp___0 ;

  {
#line 183
  rrp = (adns_rr_intstr **)datap;
#line 184
  dgram = (byte const   *)pai->dgram;
#line 188
  startbyte = cbyte___3;
#line 189
  if (cbyte___3 >= max) {
#line 189
    return ((adns_status )104);
  }
#line 190
  tc = 0;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! (cbyte___3 < max)) {
#line 191
      goto while_break;
    }
#line 192
    tmp = cbyte___3;
#line 192
    cbyte___3 ++;
#line 192
    l = (int )((int const   )*(dgram + tmp) & 255);
#line 193
    cbyte___3 += l;
#line 194
    tc ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  if (cbyte___3 != max) {
#line 196
    return ((adns_status )104);
  } else
#line 196
  if (! tc) {
#line 196
    return ((adns_status )104);
  }
  {
#line 198
  tmp___0 = adns__alloc_interim((adns_query )pai->qu, sizeof(*table) * (unsigned long )(tc + 1));
#line 198
  table = (adns_rr_intstr *)tmp___0;
  }
#line 199
  if (! table) {
#line 199
    return ((adns_status )1);
  }
#line 201
  cbyte___3 = startbyte;
#line 201
  ti = 0;
#line 201
  te = table;
  {
#line 201
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 201
    if (! (ti < tc)) {
#line 201
      goto while_break___0;
    }
    {
#line 202
    st = pap_qstring___0(pai, & cbyte___3, max, & te->i, & te->str);
    }
#line 203
    if (st) {
#line 203
      return (st);
    }
#line 201
    ti ++;
#line 201
    te ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 205
  if (! (cbyte___3 == max)) {
    {
#line 205
    __assert_fail("cbyte == max", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  205U, "pa_txt");
    }
  }
#line 207
  te->i = -1;
#line 208
  te->str = (char *)0;
#line 210
  *rrp = table;
#line 211
  return ((adns_status )0);
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_txt___0(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_intstr const   * const  *rrp ;
  adns_rr_intstr const   *current ;
  adns_status st ;
  int spc ;
  int tmp ;

  {
#line 215
  rrp = (adns_rr_intstr const   * const  *)datap;
#line 220
  current = (adns_rr_intstr const   *)*rrp;
#line 220
  spc = 0;
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    if (! (current->i >= 0)) {
#line 220
      goto while_break;
    }
#line 221
    if (spc) {
      {
#line 221
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 221
        tmp = adns__vbuf_appendstr(vb___0, " ");
        }
#line 221
        if (! tmp) {
#line 221
          return ((adns_status )1);
        }
#line 221
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 222
    st = csp_qstring___0(vb___0, (char const   *)current->str, (int )current->i);
    }
#line 222
    if (st) {
#line 222
      return (st);
    }
#line 220
    current ++;
#line 220
    spc = 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  return ((adns_status )0);
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_hinfo___0(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_intstrpair const   *rrp ;
  adns_status st ;
  int tmp ;

  {
  {
#line 232
  rrp = (adns_rr_intstrpair const   *)datap;
#line 235
  st = csp_qstring___0(vb___0, (char const   *)rrp->array[0].str, (int )rrp->array[0].i);
  }
#line 235
  if (st) {
#line 235
    return (st);
  }
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 236
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 236
    if (! tmp) {
#line 236
      return ((adns_status )1);
    }
#line 236
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 237
  st = csp_qstring___0(vb___0, (char const   *)rrp->array[1].str, (int )rrp->array[1].i);
  }
#line 237
  if (st) {
#line 237
    return (st);
  }
#line 238
  return ((adns_status )0);
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_inaddr___0(parseinfo const   *pai , int cbyte___3 , int max ,
                                 void *datap ) 
{ 
  struct in_addr *storeto ;

  {
#line 247
  storeto = (struct in_addr *)datap;
#line 249
  if (max - cbyte___3 != 4) {
#line 249
    return ((adns_status )104);
  }
  {
#line 250
  memcpy((void */* __restrict  */)storeto, (void const   */* __restrict  */)(pai->dgram + cbyte___3),
         (size_t )4);
  }
#line 251
  return ((adns_status )0);
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int search_sortlist___0(adns_state ads___7 , struct in_addr ad ) 
{ 
  struct sortlist  const  *slp ;
  int i ;

  {
#line 258
  i = 0;
#line 258
  slp = (struct sortlist  const  *)(ads___7->sortlist);
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 258
    if (i < ads___7->nsortlist) {
#line 258
      if (! (! ((ad.s_addr & (unsigned int )slp->mask.s_addr) == (unsigned int )slp->base.s_addr))) {
#line 258
        goto while_break;
      }
    } else {
#line 258
      goto while_break;
    }
#line 258
    i ++;
#line 258
    slp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  return (i);
}
}
#line 265 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int dip_inaddr___0(adns_state ads___7 , struct in_addr a , struct in_addr b ) 
{ 
  int ai ;
  int bi ;

  {
#line 268
  if (! ads___7->nsortlist) {
#line 268
    return (0);
  }
  {
#line 270
  ai = search_sortlist___0(ads___7, a);
#line 271
  bi = search_sortlist___0(ads___7, b);
  }
#line 272
  return (bi < ai);
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_inaddr___0(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  struct in_addr  const  *ap ;
  struct in_addr  const  *bp ;
  int tmp ;

  {
  {
#line 277
  ap = (struct in_addr  const  *)datap_a;
#line 277
  bp = (struct in_addr  const  *)datap_b;
#line 279
  tmp = dip_inaddr___0(ads___7, (struct in_addr )*ap, (struct in_addr )*bp);
  }
#line 279
  return (tmp);
}
}
#line 282 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_inaddr___0(vbuf *vb___0 , void const   *datap ) 
{ 
  struct in_addr  const  *rrp ;
  struct in_addr rr ;
  char const   *ia ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 283
  rrp = (struct in_addr  const  *)datap;
#line 283
  rr = *rrp;
#line 286
  tmp = inet_ntoa(rr);
#line 286
  ia = (char const   *)tmp;
  }
#line 286
  if (! ia) {
    {
#line 286
    __assert_fail("ia", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  286U, "cs_inaddr");
    }
  }
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 287
    tmp___0 = adns__vbuf_appendstr(vb___0, ia);
    }
#line 287
    if (! tmp___0) {
#line 287
      return ((adns_status )1);
    }
#line 287
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  return ((adns_status )0);
}
}
#line 295 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_addr___0(parseinfo const   *pai , int cbyte___3 , int max ,
                               void *datap ) 
{ 
  adns_rr_addr *storeto ;
  byte const   *dgram ;

  {
#line 297
  storeto = (adns_rr_addr *)datap;
#line 298
  dgram = (byte const   *)pai->dgram;
#line 300
  if (max - cbyte___3 != 4) {
#line 300
    return ((adns_status )104);
  }
  {
#line 301
  storeto->len = (int )sizeof(storeto->addr.inet);
#line 302
  memset((void *)(& storeto->addr), 0, sizeof(storeto->addr.inet));
#line 303
  storeto->addr.inet.sin_family = (sa_family_t )2;
#line 304
  memcpy((void */* __restrict  */)(& storeto->addr.inet.sin_addr), (void const   */* __restrict  */)(dgram + cbyte___3),
         (size_t )4);
  }
#line 305
  return ((adns_status )0);
}
}
#line 308 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_addr___0(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_addr const   *ap ;
  adns_rr_addr const   *bp ;
  int tmp ;

  {
#line 309
  ap = (adns_rr_addr const   *)datap_a;
#line 309
  bp = (adns_rr_addr const   *)datap_b;
#line 311
  if (! ((int const   )ap->addr.sa.sa_family == 2)) {
    {
#line 311
    __assert_fail("ap->addr.sa.sa_family == 2", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  311U, "di_addr");
    }
  }
  {
#line 312
  tmp = dip_inaddr___0(ads___7, (struct in_addr )ap->addr.inet.sin_addr, (struct in_addr )bp->addr.inet.sin_addr);
  }
#line 312
  return (tmp);
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int div_addr___0(void *context , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_state ads___7 ;
  int tmp ;

  {
  {
#line 316
  ads___7 = (adns_state )context;
#line 318
  tmp = di_addr___0(ads___7, datap_a, datap_b);
  }
#line 318
  return (tmp);
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_addr___0(vbuf *vb___0 , adns_rr_addr const   *rrp ) 
{ 
  char const   *ia ;
  char buf___17[30] ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 326
  if ((int const   )rrp->addr.inet.sin_family == 2) {
#line 326
    goto case_2;
  }
#line 331
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 327
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 327
    tmp = adns__vbuf_appendstr(vb___0, "INET ");
    }
#line 327
    if (! tmp) {
#line 327
      return ((adns_status )1);
    }
#line 327
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 328
  tmp___0 = inet_ntoa((struct in_addr )rrp->addr.inet.sin_addr);
#line 328
  ia = (char const   *)tmp___0;
  }
#line 328
  if (! ia) {
    {
#line 328
    __assert_fail("ia", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  328U, "csp_addr");
    }
  }
  {
#line 329
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 329
    tmp___1 = adns__vbuf_appendstr(vb___0, ia);
    }
#line 329
    if (! tmp___1) {
#line 329
      return ((adns_status )1);
    }
#line 329
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 330
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 332
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"AF=%u",
          (int const   )rrp->addr.sa.sa_family);
  }
  {
#line 333
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 333
    tmp___2 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 333
    if (! tmp___2) {
#line 333
      return ((adns_status )1);
    }
#line 333
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 334
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 336
  return ((adns_status )0);
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_addr___0(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_addr const   *rrp ;
  adns_status tmp ;

  {
  {
#line 340
  rrp = (adns_rr_addr const   *)datap;
#line 342
  tmp = csp_addr___0(vb___0, rrp);
  }
#line 342
  return (tmp);
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_domain___0(parseinfo const   *pai , int *cbyte_io , int max ,
                                  char **domain_r , parsedomain_flags flags ) 
{ 
  adns_status st ;
  char *dm ;
  void *tmp ;

  {
  {
#line 355
  st = adns__parse_domain((pai->qu)->ads, (int )pai->serv, (adns_query )pai->qu, & (pai->qu)->vb,
                          flags, (byte const   *)pai->dgram, (int )pai->dglen, cbyte_io,
                          max);
  }
#line 357
  if (st) {
#line 357
    return (st);
  }
#line 358
  if (! (pai->qu)->vb.used) {
#line 358
    return ((adns_status )104);
  }
  {
#line 360
  tmp = adns__alloc_interim((adns_query )pai->qu, (size_t )((pai->qu)->vb.used + 1));
#line 360
  dm = (char *)tmp;
  }
#line 361
  if (! dm) {
#line 361
    return ((adns_status )1);
  }
  {
#line 363
  *(dm + (pai->qu)->vb.used) = (char)0;
#line 364
  memcpy((void */* __restrict  */)dm, (void const   */* __restrict  */)(pai->qu)->vb.buf,
         (size_t )(pai->qu)->vb.used);
#line 366
  *domain_r = dm;
  }
#line 367
  return ((adns_status )0);
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_domain___0(vbuf *vb___0 , char const   *domain ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 371
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 371
    tmp = adns__vbuf_appendstr(vb___0, domain);
    }
#line 371
    if (! tmp) {
#line 371
      return ((adns_status )1);
    }
#line 371
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 372
  if (! *domain) {
    {
#line 372
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 372
      tmp___0 = adns__vbuf_appendstr(vb___0, ".");
      }
#line 372
      if (! tmp___0) {
#line 372
        return ((adns_status )1);
      }
#line 372
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 373
  return ((adns_status )0);
}
}
#line 376 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_domain___0(vbuf *vb___0 , void const   *datap ) 
{ 
  char const   * const  *domainp ;
  adns_status tmp ;

  {
  {
#line 377
  domainp = (char const   * const  *)datap;
#line 378
  tmp = csp_domain___0(vb___0, (char const   *)*domainp);
  }
#line 378
  return (tmp);
}
}
#line 381 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_dom_raw___0(parseinfo const   *pai , int cbyte___3 , int max ,
                                  void *datap ) 
{ 
  char **rrp ;
  adns_status st ;

  {
  {
#line 383
  rrp = (char **)datap;
#line 386
  st = pap_domain___0(pai, & cbyte___3, max, rrp, (parsedomain_flags )1);
  }
#line 387
  if (st) {
#line 387
    return (st);
  }
#line 389
  if (cbyte___3 != max) {
#line 389
    return ((adns_status )104);
  }
#line 390
  return ((adns_status )0);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_host_raw___0(parseinfo const   *pai , int cbyte___3 , int max ,
                                   void *datap ) 
{ 
  char **rrp ;
  adns_status st ;
  int tmp ;

  {
#line 399
  rrp = (char **)datap;
#line 402
  if ((pai->qu)->flags & 64) {
#line 402
    tmp = 1;
  } else {
#line 402
    tmp = 0;
  }
  {
#line 402
  st = pap_domain___0(pai, & cbyte___3, max, rrp, (parsedomain_flags )tmp);
  }
#line 404
  if (st) {
#line 404
    return (st);
  }
#line 406
  if (cbyte___3 != max) {
#line 406
    return ((adns_status )104);
  }
#line 407
  return ((adns_status )0);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_findaddrs___0(parseinfo const   *pai , adns_rr_hostaddr *ha ,
                                     int *cbyte_io , int count , int dmstart ) 
{ 
  int rri ;
  int naddrs ;
  int type ;
  int class ;
  int rdlen ;
  int rdstart ;
  int ownermatched ;
  unsigned long ttl ;
  adns_status st ;
  int tmp ;
  void *tmp___0 ;

  {
#line 421
  rri = 0;
#line 421
  naddrs = -1;
  {
#line 421
  while (1) {
    while_continue: /* CIL Label */ ;
#line 421
    if (! (rri < count)) {
#line 421
      goto while_break;
    }
    {
#line 422
    st = adns__findrr_anychk((adns_query )pai->qu, (int )pai->serv, (byte const   *)pai->dgram,
                             (int )pai->dglen, cbyte_io, & type, & class, & ttl, & rdlen,
                             & rdstart, (byte const   *)pai->dgram, (int )pai->dglen,
                             dmstart, & ownermatched);
    }
#line 426
    if (st) {
#line 426
      return (st);
    }
#line 427
    if (! ownermatched) {
#line 427
      goto _L;
    } else
#line 427
    if (class != 1) {
#line 427
      goto _L;
    } else
#line 427
    if (type != 1) {
      _L: /* CIL Label */ 
#line 428
      if (naddrs > 0) {
#line 428
        goto while_break;
      } else {
#line 428
        goto __Cont;
      }
    }
#line 430
    if (naddrs == -1) {
#line 431
      naddrs = 0;
    }
    {
#line 433
    tmp = adns__vbuf_ensure(& (pai->qu)->vb, (int )((unsigned long )(naddrs + 1) * sizeof(adns_rr_addr )));
    }
#line 433
    if (! tmp) {
#line 434
      return ((adns_status )1);
    }
    {
#line 435
    adns__update_expires((adns_query )pai->qu, ttl, (struct timeval )pai->now);
#line 436
    st = pa_addr___0(pai, rdstart, rdstart + rdlen, (void *)((pai->qu)->vb.buf + (unsigned long )naddrs * sizeof(adns_rr_addr )));
    }
#line 438
    if (st) {
#line 438
      return (st);
    }
#line 439
    naddrs ++;
    __Cont: /* CIL Label */ 
#line 421
    rri ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 441
  if (naddrs >= 0) {
    {
#line 442
    tmp___0 = adns__alloc_interim((adns_query )pai->qu, (unsigned long )naddrs * sizeof(adns_rr_addr ));
#line 442
    ha->addrs = (adns_rr_addr *)tmp___0;
    }
#line 443
    if (! ha->addrs) {
#line 443
      return ((adns_status )1);
    }
    {
#line 444
    memcpy((void */* __restrict  */)ha->addrs, (void const   */* __restrict  */)(pai->qu)->vb.buf,
           (unsigned long )naddrs * sizeof(adns_rr_addr ));
#line 445
    ha->naddrs = naddrs;
#line 446
    ha->astatus = (adns_status )0;
#line 448
    adns__isort((void *)ha->addrs, naddrs, (int )sizeof(adns_rr_addr ), (void *)(pai->qu)->vb.buf,
                & div_addr___0, (void *)pai->ads);
    }
  }
#line 451
  return ((adns_status )0);
}
}
#line 454 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void icb_hostaddr___0(adns_query parent , adns_query child ) 
{ 
  adns_answer *cans ;
  adns_rr_hostaddr *rrp ;
  adns_state ads___7 ;
  adns_status st ;

  {
#line 455
  cans = child->answer;
#line 456
  rrp = child->ctx.info.hostaddr;
#line 457
  ads___7 = parent->ads;
#line 460
  st = cans->status;
#line 461
  rrp->astatus = st;
#line 462
  if ((unsigned int )st > 0U) {
#line 462
    if ((unsigned int )st <= 99U) {
#line 462
      rrp->naddrs = -1;
    } else {
#line 462
      rrp->naddrs = cans->nrrs;
    }
  } else {
#line 462
    rrp->naddrs = cans->nrrs;
  }
  {
#line 463
  rrp->addrs = cans->rrs.addr;
#line 464
  adns__transfer_interim(child, parent, (void *)rrp->addrs, (unsigned long )rrp->naddrs * sizeof(adns_rr_addr ));
  }
#line 467
  if (parent->children.head) {
    {
#line 468
    while (1) {
      while_continue: /* CIL Label */ ;
#line 468
      parent->next = (adns_query )0;
#line 468
      parent->back = ads___7->childw.tail;
#line 468
      if (ads___7->childw.tail) {
#line 468
        (ads___7->childw.tail)->next = parent;
      } else {
#line 468
        ads___7->childw.head = parent;
      }
#line 468
      ads___7->childw.tail = parent;
#line 468
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 470
    adns__query_done(parent);
    }
  }
#line 472
  return;
}
}
#line 474 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_hostaddr___0(parseinfo const   *pai , int *cbyte_io , int max ,
                                    adns_rr_hostaddr *rrp ) 
{ 
  adns_status st ;
  int dmstart ;
  int cbyte___3 ;
  qcontext ctx ;
  int id ;
  adns_query nqu ;
  adns_queryflags nflags ;
  int tmp ;
  typeinfo const   *tmp___0 ;

  {
#line 483
  cbyte___3 = *cbyte_io;
#line 483
  dmstart = cbyte___3;
#line 484
  if ((pai->qu)->flags & 64) {
#line 484
    tmp = 1;
  } else {
#line 484
    tmp = 0;
  }
  {
#line 484
  st = pap_domain___0(pai, & cbyte___3, max, & rrp->host, (parsedomain_flags )tmp);
  }
#line 486
  if (st) {
#line 486
    return (st);
  }
  {
#line 487
  *cbyte_io = cbyte___3;
#line 489
  rrp->astatus = (adns_status )0;
#line 490
  rrp->naddrs = -1;
#line 491
  rrp->addrs = (adns_rr_addr *)0;
#line 493
  cbyte___3 = (int )pai->nsstart;
#line 495
  st = pap_findaddrs___0(pai, rrp, & cbyte___3, (int )pai->nscount, dmstart);
  }
#line 496
  if (st) {
#line 496
    return (st);
  }
#line 497
  if (rrp->naddrs != -1) {
#line 497
    return ((adns_status )0);
  }
  {
#line 499
  st = pap_findaddrs___0(pai, rrp, & cbyte___3, (int )pai->arcount, dmstart);
  }
#line 500
  if (st) {
#line 500
    return (st);
  }
#line 501
  if (rrp->naddrs != -1) {
#line 501
    return ((adns_status )0);
  }
  {
#line 503
  st = adns__mkquery_frdgram((adns_state )pai->ads, & (pai->qu)->vb, & id, (byte const   *)pai->dgram,
                             (int )pai->dglen, dmstart, (adns_rrtype )65537, (adns_queryflags )16);
  }
#line 506
  if (st) {
#line 506
    return (st);
  }
#line 508
  ctx.ext = (void *)0;
#line 509
  ctx.callback = & icb_hostaddr___0;
#line 510
  ctx.info.hostaddr = rrp;
#line 512
  nflags = (adns_queryflags )16;
#line 513
  if (! ((pai->qu)->flags & 256)) {
#line 513
    nflags = (adns_queryflags )((unsigned int )nflags | 512U);
  }
  {
#line 515
  tmp___0 = adns__findtype((adns_rrtype )65537);
#line 515
  st = adns__internal_submit((adns_state )pai->ads, & nqu, tmp___0, & (pai->qu)->vb,
                             id, nflags, (struct timeval )pai->now, (qcontext const   *)(& ctx));
  }
#line 517
  if (st) {
#line 517
    return (st);
  }
#line 519
  nqu->parent = (adns_query )pai->qu;
  {
#line 520
  while (1) {
    while_continue: /* CIL Label */ ;
#line 520
    nqu->siblings.next = (adns_query )0;
#line 520
    nqu->siblings.back = (pai->qu)->children.tail;
#line 520
    if ((pai->qu)->children.tail) {
#line 520
      ((pai->qu)->children.tail)->siblings.next = nqu;
    } else {
#line 520
      (pai->qu)->children.head = nqu;
    }
#line 520
    (pai->qu)->children.tail = nqu;
#line 520
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 522
  return ((adns_status )0);
}
}
#line 525 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_hostaddr___0(parseinfo const   *pai , int cbyte___3 , int max ,
                                   void *datap ) 
{ 
  adns_rr_hostaddr *rrp ;
  adns_status st ;

  {
  {
#line 527
  rrp = (adns_rr_hostaddr *)datap;
#line 530
  st = pap_hostaddr___0(pai, & cbyte___3, max, rrp);
  }
#line 531
  if (st) {
#line 531
    return (st);
  }
#line 532
  if (cbyte___3 != max) {
#line 532
    return ((adns_status )104);
  }
#line 534
  return ((adns_status )0);
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int dip_hostaddr___0(adns_state ads___7 , adns_rr_hostaddr const   *ap , adns_rr_hostaddr const   *bp ) 
{ 
  int tmp ;

  {
#line 539
  if ((unsigned int const   )ap->astatus != (unsigned int const   )bp->astatus) {
#line 539
    return ((int )ap->astatus);
  }
#line 540
  if (ap->astatus) {
#line 540
    return (0);
  }
#line 542
  if (! ((int )(ap->addrs + 0)->addr.sa.sa_family == 2)) {
    {
#line 542
    __assert_fail("ap->addrs[0].addr.sa.sa_family == 2", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  542U, "dip_hostaddr");
    }
  }
#line 543
  if (! ((int )(bp->addrs + 0)->addr.sa.sa_family == 2)) {
    {
#line 543
    __assert_fail("bp->addrs[0].addr.sa.sa_family == 2", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  543U, "dip_hostaddr");
    }
  }
  {
#line 544
  tmp = dip_inaddr___0(ads___7, (ap->addrs + 0)->addr.inet.sin_addr, (bp->addrs + 0)->addr.inet.sin_addr);
  }
#line 544
  return (tmp);
}
}
#line 549 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_hostaddr___0(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_hostaddr const   *ap ;
  adns_rr_hostaddr const   *bp ;
  int tmp ;

  {
  {
#line 551
  ap = (adns_rr_hostaddr const   *)datap_a;
#line 551
  bp = (adns_rr_hostaddr const   *)datap_b;
#line 553
  tmp = dip_hostaddr___0(ads___7, ap, bp);
  }
#line 553
  return (tmp);
}
}
#line 556 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mfp_hostaddr___0(adns_query qu , adns_rr_hostaddr *rrp ) 
{ 
  void *tablev ;

  {
  {
#line 559
  adns__makefinal_str(qu, & rrp->host);
#line 560
  tablev = (void *)rrp->addrs;
#line 561
  adns__makefinal_block(qu, & tablev, (unsigned long )rrp->naddrs * sizeof(*(rrp->addrs)));
#line 562
  rrp->addrs = (adns_rr_addr *)tablev;
  }
#line 563
  return;
}
}
#line 565 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_hostaddr___0(adns_query qu , void *datap ) 
{ 
  adns_rr_hostaddr *rrp ;

  {
  {
#line 566
  rrp = (adns_rr_hostaddr *)datap;
#line 568
  mfp_hostaddr___0(qu, rrp);
  }
#line 569
  return;
}
}
#line 571 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_hostaddr___0(vbuf *vb___0 , adns_rr_hostaddr const   *rrp ) 
{ 
  char const   *errstr ;
  adns_status st ;
  char buf___17[20] ;
  int i ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 577
  st = csp_domain___0(vb___0, (char const   *)rrp->host);
  }
#line 577
  if (st) {
#line 577
    return (st);
  }
  {
#line 579
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 579
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 579
    if (! tmp) {
#line 579
      return ((adns_status )1);
    }
#line 579
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 580
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 580
    tmp___0 = adns_errtypeabbrev((adns_status )rrp->astatus);
#line 580
    tmp___1 = adns__vbuf_appendstr(vb___0, tmp___0);
    }
#line 580
    if (! tmp___1) {
#line 580
      return ((adns_status )1);
    }
#line 580
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 582
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %d ",
          (unsigned int const   )rrp->astatus);
  }
  {
#line 583
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 583
    tmp___2 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 583
    if (! tmp___2) {
#line 583
      return ((adns_status )1);
    }
#line 583
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 585
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 585
    tmp___3 = adns_errabbrev((adns_status )rrp->astatus);
#line 585
    tmp___4 = adns__vbuf_appendstr(vb___0, tmp___3);
    }
#line 585
    if (! tmp___4) {
#line 585
      return ((adns_status )1);
    }
#line 585
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 586
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 586
    tmp___5 = adns__vbuf_appendstr(vb___0, " ");
    }
#line 586
    if (! tmp___5) {
#line 586
      return ((adns_status )1);
    }
#line 586
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 588
  errstr = adns_strerror((adns_status )rrp->astatus);
#line 589
  tmp___6 = strlen(errstr);
#line 589
  st = csp_qstring___0(vb___0, errstr, (int )tmp___6);
  }
#line 589
  if (st) {
#line 589
    return (st);
  }
#line 591
  if (rrp->naddrs >= 0) {
    {
#line 592
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 592
      tmp___7 = adns__vbuf_appendstr(vb___0, " (");
      }
#line 592
      if (! tmp___7) {
#line 592
        return ((adns_status )1);
      }
#line 592
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 593
    i = 0;
    {
#line 593
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 593
      if (! (i < (int )rrp->naddrs)) {
#line 593
        goto while_break___5;
      }
      {
#line 594
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 594
        tmp___8 = adns__vbuf_appendstr(vb___0, " ");
        }
#line 594
        if (! tmp___8) {
#line 594
          return ((adns_status )1);
        }
#line 594
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 595
      st = csp_addr___0(vb___0, (adns_rr_addr const   *)(rrp->addrs + i));
#line 593
      i ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 597
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 597
      tmp___9 = adns__vbuf_appendstr(vb___0, " )");
      }
#line 597
      if (! tmp___9) {
#line 597
        return ((adns_status )1);
      }
#line 597
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
  } else {
    {
#line 599
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 599
      tmp___10 = adns__vbuf_appendstr(vb___0, " ?");
      }
#line 599
      if (! tmp___10) {
#line 599
        return ((adns_status )1);
      }
#line 599
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
#line 601
  return ((adns_status )0);
}
}
#line 604 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_hostaddr___0(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_hostaddr const   *rrp ;
  adns_status tmp ;

  {
  {
#line 605
  rrp = (adns_rr_hostaddr const   *)datap;
#line 607
  tmp = csp_hostaddr___0(vb___0, rrp);
  }
#line 607
  return (tmp);
}
}
#line 614 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_mx_raw___0(parseinfo const   *pai , int cbyte___3 , int max ,
                                 void *datap ) 
{ 
  byte const   *dgram ;
  adns_rr_intstr *rrp ;
  adns_status st ;
  int pref ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 616
  dgram = (byte const   *)pai->dgram;
#line 617
  rrp = (adns_rr_intstr *)datap;
#line 621
  if (cbyte___3 + 2 > max) {
#line 621
    return ((adns_status )104);
  }
#line 622
  pref = 0;
#line 622
  tmp = cbyte___3;
#line 622
  cbyte___3 ++;
#line 622
  pref |= (int )(((int const   )*(dgram + tmp) & 255) << 8);
#line 622
  tmp___0 = cbyte___3;
#line 622
  cbyte___3 ++;
#line 622
  pref |= (int )((int const   )*(dgram + tmp___0) & 255);
#line 623
  rrp->i = pref;
#line 624
  if ((pai->qu)->flags & 64) {
#line 624
    tmp___1 = 1;
  } else {
#line 624
    tmp___1 = 0;
  }
  {
#line 624
  st = pap_domain___0(pai, & cbyte___3, max, & rrp->str, (parsedomain_flags )tmp___1);
  }
#line 626
  if (st) {
#line 626
    return (st);
  }
#line 628
  if (cbyte___3 != max) {
#line 628
    return ((adns_status )104);
  }
#line 629
  return ((adns_status )0);
}
}
#line 632 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_mx_raw___0(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_intstr const   *ap ;
  adns_rr_intstr const   *bp ;

  {
#line 633
  ap = (adns_rr_intstr const   *)datap_a;
#line 633
  bp = (adns_rr_intstr const   *)datap_b;
#line 635
  if (ap->i < bp->i) {
#line 635
    return (0);
  }
#line 636
  if (ap->i > bp->i) {
#line 636
    return (1);
  }
#line 637
  return (0);
}
}
#line 644 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_mx___0(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  byte const   *dgram ;
  adns_rr_inthostaddr *rrp ;
  adns_status st ;
  int pref ;
  int tmp ;
  int tmp___0 ;

  {
#line 646
  dgram = (byte const   *)pai->dgram;
#line 647
  rrp = (adns_rr_inthostaddr *)datap;
#line 651
  if (cbyte___3 + 2 > max) {
#line 651
    return ((adns_status )104);
  }
  {
#line 652
  pref = 0;
#line 652
  tmp = cbyte___3;
#line 652
  cbyte___3 ++;
#line 652
  pref |= (int )(((int const   )*(dgram + tmp) & 255) << 8);
#line 652
  tmp___0 = cbyte___3;
#line 652
  cbyte___3 ++;
#line 652
  pref |= (int )((int const   )*(dgram + tmp___0) & 255);
#line 653
  rrp->i = pref;
#line 654
  st = pap_hostaddr___0(pai, & cbyte___3, max, & rrp->ha);
  }
#line 655
  if (st) {
#line 655
    return (st);
  }
#line 657
  if (cbyte___3 != max) {
#line 657
    return ((adns_status )104);
  }
#line 658
  return ((adns_status )0);
}
}
#line 661 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_mx___0(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_inthostaddr const   *ap ;
  adns_rr_inthostaddr const   *bp ;
  int tmp ;

  {
#line 662
  ap = (adns_rr_inthostaddr const   *)datap_a;
#line 662
  bp = (adns_rr_inthostaddr const   *)datap_b;
#line 664
  if (ap->i < bp->i) {
#line 664
    return (0);
  }
#line 665
  if (ap->i > bp->i) {
#line 665
    return (1);
  }
  {
#line 666
  tmp = dip_hostaddr___0(ads___7, & ap->ha, & bp->ha);
  }
#line 666
  return (tmp);
}
}
#line 673 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_inthostaddr___0(adns_query qu , void *datap ) 
{ 
  adns_rr_inthostaddr *rrp ;

  {
  {
#line 674
  rrp = (adns_rr_inthostaddr *)datap;
#line 676
  mfp_hostaddr___0(qu, & rrp->ha);
  }
#line 677
  return;
}
}
#line 679 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_inthostaddr___0(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_inthostaddr const   *rrp ;
  char buf___17[10] ;
  int tmp ;
  adns_status tmp___0 ;

  {
  {
#line 680
  rrp = (adns_rr_inthostaddr const   *)datap;
#line 683
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"%u ",
          rrp->i);
  }
  {
#line 684
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 684
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 684
    if (! tmp) {
#line 684
      return ((adns_status )1);
    }
#line 684
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 686
  tmp___0 = csp_hostaddr___0(vb___0, & rrp->ha);
  }
#line 686
  return (tmp___0);
}
}
#line 693 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_inthost___0(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_intstr const   *rrp ;
  char buf___17[10] ;
  int tmp ;
  adns_status tmp___0 ;

  {
  {
#line 694
  rrp = (adns_rr_intstr const   *)datap;
#line 697
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"%u ",
          rrp->i);
  }
  {
#line 698
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 698
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 698
    if (! tmp) {
#line 698
      return ((adns_status )1);
    }
#line 698
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 699
  tmp___0 = csp_domain___0(vb___0, (char const   *)rrp->str);
  }
#line 699
  return (tmp___0);
}
}
#line 706 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void icb_ptr___0(adns_query parent , adns_query child ) 
{ 
  adns_answer *cans ;
  adns_rr_addr const   *queried ;
  adns_rr_addr const   *found ;
  adns_state ads___7 ;
  int i ;
  int tmp ;

  {
#line 707
  cans = child->answer;
#line 709
  ads___7 = parent->ads;
#line 712
  if ((unsigned int )cans->status == 300U) {
    {
#line 713
    adns__query_fail(parent, (adns_status )100);
    }
#line 714
    return;
  } else
#line 712
  if ((unsigned int )cans->status == 301U) {
    {
#line 713
    adns__query_fail(parent, (adns_status )100);
    }
#line 714
    return;
  } else
#line 715
  if (cans->status) {
    {
#line 716
    adns__query_fail(parent, cans->status);
    }
#line 717
    return;
  }
#line 720
  queried = (adns_rr_addr const   *)(& parent->ctx.info.ptr_parent_addr);
#line 721
  i = 0;
#line 721
  found = (adns_rr_addr const   *)cans->rrs.addr;
  {
#line 721
  while (1) {
    while_continue: /* CIL Label */ ;
#line 721
    if (! (i < cans->nrrs)) {
#line 721
      goto while_break;
    }
#line 722
    if (queried->len == found->len) {
      {
#line 722
      tmp = memcmp((void const   *)(& queried->addr), (void const   *)(& found->addr),
                   (size_t )queried->len);
      }
#line 722
      if (! tmp) {
#line 724
        if (! parent->children.head) {
          {
#line 725
          adns__query_done(parent);
          }
#line 726
          return;
        } else {
          {
#line 728
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 728
            parent->next = (adns_query )0;
#line 728
            parent->back = ads___7->childw.tail;
#line 728
            if (ads___7->childw.tail) {
#line 728
              (ads___7->childw.tail)->next = parent;
            } else {
#line 728
              ads___7->childw.head = parent;
            }
#line 728
            ads___7->childw.tail = parent;
#line 728
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 729
          return;
        }
      }
    }
#line 721
    i ++;
#line 721
    found ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 734
  adns__query_fail(parent, (adns_status )100);
  }
#line 735
  return;
}
}
#line 739
static adns_status pa_ptr___0(parseinfo const   *pai , int dmstart , int max , void *datap ) ;
#line 739 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static char const   * const  expectdomain___0[2]  = {      (char const   */* const  */)"in-addr",      (char const   */* const  */)"arpa"};
#line 737 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_ptr___0(parseinfo const   *pai , int dmstart , int max , void *datap ) 
{ 
  char **rrp ;
  adns_status st ;
  adns_rr_addr *ap ;
  findlabel_state fls ;
  char *ep ;
  byte ipv[4] ;
  char labbuf[4] ;
  int cbyte___3 ;
  int i ;
  int lablen ;
  int labstart ;
  int l ;
  int id ;
  adns_query nqu ;
  qcontext ctx ;
  int tmp ;
  unsigned long tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  typeinfo const   *tmp___3 ;

  {
#line 741
  rrp = (char **)datap;
#line 752
  cbyte___3 = dmstart;
#line 753
  if ((pai->qu)->flags & 64) {
#line 753
    tmp = 1;
  } else {
#line 753
    tmp = 0;
  }
  {
#line 753
  st = pap_domain___0(pai, & cbyte___3, max, rrp, (parsedomain_flags )tmp);
  }
#line 755
  if (st) {
#line 755
    return (st);
  }
#line 756
  if (cbyte___3 != max) {
#line 756
    return ((adns_status )104);
  }
#line 758
  ap = & (pai->qu)->ctx.info.ptr_parent_addr;
#line 759
  if (! ap->len) {
    {
#line 760
    adns__findlabel_start(& fls, (adns_state )pai->ads, -1, (adns_query )pai->qu,
                          (byte const   *)(pai->qu)->query_dgram, (pai->qu)->query_dglen,
                          (pai->qu)->query_dglen, 12, (int *)0);
#line 763
    i = 0;
    }
    {
#line 763
    while (1) {
      while_continue: /* CIL Label */ ;
#line 763
      if (! (i < 4)) {
#line 763
        goto while_break;
      }
      {
#line 764
      st = adns__findlabel_next(& fls, & lablen, & labstart);
      }
#line 764
      if (! (! st)) {
        {
#line 764
        __assert_fail("!st", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                      764U, "pa_ptr");
        }
      }
#line 765
      if (lablen <= 0) {
#line 765
        return ((adns_status )200);
      } else
#line 765
      if (lablen > 3) {
#line 765
        return ((adns_status )200);
      }
      {
#line 766
      memcpy((void */* __restrict  */)(labbuf), (void const   */* __restrict  */)((pai->qu)->query_dgram + labstart),
             (size_t )lablen);
#line 767
      labbuf[lablen] = (char)0;
#line 768
      tmp___0 = strtoul((char const   */* __restrict  */)(labbuf), (char **/* __restrict  */)(& ep),
                        10);
#line 768
      ipv[3 - i] = (byte )tmp___0;
      }
#line 769
      if (*ep) {
#line 769
        return ((adns_status )200);
      }
#line 770
      if (lablen > 1) {
#line 770
        if ((int )*((pai->qu)->query_dgram + labstart) == 48) {
#line 771
          return ((adns_status )200);
        }
      }
#line 763
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 773
    i = 0;
    {
#line 773
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 773
      if (! ((unsigned long )i < sizeof(expectdomain___0) / sizeof(expectdomain___0[0]))) {
#line 773
        goto while_break___0;
      }
      {
#line 774
      st = adns__findlabel_next(& fls, & lablen, & labstart);
      }
#line 774
      if (! (! st)) {
        {
#line 774
        __assert_fail("!st", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                      774U, "pa_ptr");
        }
      }
      {
#line 775
      tmp___1 = strlen((char const   *)expectdomain___0[i]);
#line 775
      l = (int )tmp___1;
      }
#line 776
      if (lablen != l) {
#line 778
        return ((adns_status )200);
      } else {
        {
#line 776
        tmp___2 = memcmp((void const   *)((pai->qu)->query_dgram + labstart), (void const   *)expectdomain___0[i],
                         (size_t )l);
        }
#line 776
        if (tmp___2) {
#line 778
          return ((adns_status )200);
        }
      }
#line 773
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 780
    st = adns__findlabel_next(& fls, & lablen, (int *)0);
    }
#line 780
    if (! (! st)) {
      {
#line 780
      __assert_fail("!st", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                    780U, "pa_ptr");
      }
    }
#line 781
    if (lablen) {
#line 781
      return ((adns_status )200);
    }
    {
#line 783
    ap->len = (int )sizeof(struct sockaddr_in );
#line 784
    memset((void *)(& ap->addr), 0, sizeof(ap->addr.inet));
#line 785
    ap->addr.inet.sin_family = (sa_family_t )2;
#line 786
    ap->addr.inet.sin_addr.s_addr = htonl((uint32_t )(((((int )ipv[0] << 24) | ((int )ipv[1] << 16)) | ((int )ipv[2] << 8)) | (int )ipv[3]));
    }
  }
  {
#line 790
  st = adns__mkquery_frdgram((adns_state )pai->ads, & (pai->qu)->vb, & id, (byte const   *)pai->dgram,
                             (int )pai->dglen, dmstart, (adns_rrtype )65537, (adns_queryflags )16);
  }
#line 793
  if (st) {
#line 793
    return (st);
  }
  {
#line 795
  ctx.ext = (void *)0;
#line 796
  ctx.callback = & icb_ptr___0;
#line 797
  memset((void *)(& ctx.info), 0, sizeof(ctx.info));
#line 798
  tmp___3 = adns__findtype((adns_rrtype )65537);
#line 798
  st = adns__internal_submit((adns_state )pai->ads, & nqu, tmp___3, & (pai->qu)->vb,
                             id, (adns_queryflags )16, (struct timeval )pai->now,
                             (qcontext const   *)(& ctx));
  }
#line 801
  if (st) {
#line 801
    return (st);
  }
#line 803
  nqu->parent = (adns_query )pai->qu;
  {
#line 804
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 804
    nqu->siblings.next = (adns_query )0;
#line 804
    nqu->siblings.back = (pai->qu)->children.tail;
#line 804
    if ((pai->qu)->children.tail) {
#line 804
      ((pai->qu)->children.tail)->siblings.next = nqu;
    } else {
#line 804
      (pai->qu)->children.head = nqu;
    }
#line 804
    (pai->qu)->children.tail = nqu;
#line 804
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 805
  return ((adns_status )0);
}
}
#line 812 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_strpair___0(adns_query qu , void *datap ) 
{ 
  adns_rr_strpair *rrp ;

  {
  {
#line 813
  rrp = (adns_rr_strpair *)datap;
#line 815
  adns__makefinal_str(qu, & rrp->array[0]);
#line 816
  adns__makefinal_str(qu, & rrp->array[1]);
  }
#line 817
  return;
}
}
#line 823 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_intstrpair___0(adns_query qu , void *datap ) 
{ 
  adns_rr_intstrpair *rrp ;

  {
  {
#line 824
  rrp = (adns_rr_intstrpair *)datap;
#line 826
  adns__makefinal_str(qu, & rrp->array[0].str);
#line 827
  adns__makefinal_str(qu, & rrp->array[1].str);
  }
#line 828
  return;
}
}
#line 834 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_hinfo___0(parseinfo const   *pai , int cbyte___3 , int max ,
                                void *datap ) 
{ 
  adns_rr_intstrpair *rrp ;
  adns_status st ;
  int i ;

  {
#line 836
  rrp = (adns_rr_intstrpair *)datap;
#line 840
  i = 0;
  {
#line 840
  while (1) {
    while_continue: /* CIL Label */ ;
#line 840
    if (! (i < 2)) {
#line 840
      goto while_break;
    }
    {
#line 841
    st = pap_qstring___0(pai, & cbyte___3, max, & rrp->array[i].i, & rrp->array[i].str);
    }
#line 842
    if (st) {
#line 842
      return (st);
    }
#line 840
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 845
  if (cbyte___3 != max) {
#line 845
    return ((adns_status )104);
  }
#line 847
  return ((adns_status )0);
}
}
#line 854 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_mailbox822___0(parseinfo const   *pai , int *cbyte_io , int max ,
                                      char **mb_r ) 
{ 
  int lablen ;
  int labstart ;
  int i ;
  int needquote ;
  int c ;
  int r ;
  int neednorm ;
  unsigned char const   *p ;
  char *str ;
  findlabel_state fls ;
  adns_status st ;
  vbuf *vb___0 ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 863
  vb___0 = & (pai->qu)->vb;
#line 864
  vb___0->used = 0;
#line 865
  adns__findlabel_start(& fls, (adns_state )pai->ads, -1, (adns_query )pai->qu, (byte const   *)pai->dgram,
                        (int )pai->dglen, max, *cbyte_io, cbyte_io);
#line 869
  st = adns__findlabel_next(& fls, & lablen, & labstart);
  }
#line 870
  if (! lablen) {
    {
#line 871
    adns__vbuf_appendstr(vb___0, ".");
    }
#line 872
    goto x_ok;
  }
#line 875
  neednorm = 1;
#line 876
  i = 0;
#line 876
  needquote = 0;
#line 876
  p = (unsigned char const   *)(pai->dgram + labstart);
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (! (i < lablen)) {
#line 876
      goto while_break;
    }
#line 877
    tmp = p;
#line 877
    p ++;
#line 877
    c = (int )*tmp;
#line 878
    if ((c & -129) < 32) {
#line 878
      return ((adns_status )104);
    } else
#line 878
    if ((c & -129) == 127) {
#line 878
      return ((adns_status )104);
    }
#line 879
    if (c == 46) {
#line 879
      if (! neednorm) {
#line 879
        neednorm = 1;
      } else {
#line 879
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 880
    if (c == 32) {
#line 880
      needquote ++;
    } else
#line 880
    if (c >= 127) {
#line 880
      needquote ++;
    } else {
      {
#line 880
      tmp___0 = ctype_822special(c);
      }
#line 880
      if (tmp___0) {
#line 880
        needquote ++;
      } else {
#line 881
        neednorm = 0;
      }
    }
#line 876
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 884
  if (needquote) {
#line 884
    goto _L___0;
  } else
#line 884
  if (neednorm) {
    _L___0: /* CIL Label */ 
    {
#line 885
    r = adns__vbuf_ensure(vb___0, (lablen + needquote) + 4);
    }
#line 885
    if (! r) {
#line 885
      return ((adns_status )1);
    }
    {
#line 886
    adns__vbuf_appendq(vb___0, (byte const   *)"\"", 1);
#line 887
    i = 0;
#line 887
    needquote = 0;
#line 887
    p = (unsigned char const   *)(pai->dgram + labstart);
    }
    {
#line 887
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 887
      if (! (i < lablen)) {
#line 887
        goto while_break___0;
      }
#line 888
      c = (int )*p;
#line 889
      if (c == 34) {
        {
#line 889
        adns__vbuf_appendq(vb___0, (byte const   *)"\\", 1);
        }
      } else
#line 889
      if (c == 92) {
        {
#line 889
        adns__vbuf_appendq(vb___0, (byte const   *)"\\", 1);
        }
      }
      {
#line 890
      adns__vbuf_appendq(vb___0, p, 1);
#line 887
      i ++;
#line 887
      p ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 892
    adns__vbuf_appendq(vb___0, (byte const   *)"\"", 1);
    }
  } else {
    {
#line 894
    r = adns__vbuf_append(vb___0, (byte const   *)(pai->dgram + labstart), lablen);
    }
#line 894
    if (! r) {
#line 894
      return ((adns_status )1);
    }
  }
  {
#line 897
  r = adns__vbuf_appendstr(vb___0, "@");
  }
#line 897
  if (! r) {
#line 897
    return ((adns_status )1);
  }
  {
#line 899
  st = adns__parse_domain_more(& fls, (adns_state )pai->ads, (adns_query )pai->qu,
                               vb___0, (parsedomain_flags )0, (byte const   *)pai->dgram);
  }
#line 900
  if (st) {
#line 900
    return (st);
  }
  x_ok: 
  {
#line 903
  tmp___1 = adns__alloc_interim((adns_query )pai->qu, (size_t )(vb___0->used + 1));
#line 903
  str = (char *)tmp___1;
  }
#line 903
  if (! str) {
#line 903
    return ((adns_status )1);
  }
  {
#line 904
  memcpy((void */* __restrict  */)str, (void const   */* __restrict  */)vb___0->buf,
         (size_t )vb___0->used);
#line 905
  *(str + vb___0->used) = (char)0;
#line 906
  *mb_r = str;
  }
#line 907
  return ((adns_status )0);
}
}
#line 910 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_mailbox___0(parseinfo const   *pai , int *cbyte_io , int max ,
                                   char **mb_r ) 
{ 
  adns_status tmp ;
  adns_status tmp___0 ;

  {
#line 912
  if ((unsigned int const   )((pai->qu)->typei)->typekey & 131072U) {
    {
#line 913
    tmp = pap_mailbox822___0(pai, cbyte_io, max, mb_r);
    }
#line 913
    return (tmp);
  } else {
    {
#line 915
    tmp___0 = pap_domain___0(pai, cbyte_io, max, mb_r, (parsedomain_flags )1);
    }
#line 915
    return (tmp___0);
  }
}
}
#line 919 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_mailbox___0(vbuf *vb___0 , char const   *mailbox ) 
{ 
  adns_status tmp ;

  {
  {
#line 920
  tmp = csp_domain___0(vb___0, mailbox);
  }
#line 920
  return (tmp);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_rp___0(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  adns_rr_strpair *rrp ;
  adns_status st ;

  {
  {
#line 929
  rrp = (adns_rr_strpair *)datap;
#line 932
  st = pap_mailbox___0(pai, & cbyte___3, max, & rrp->array[0]);
  }
#line 933
  if (st) {
#line 933
    return (st);
  }
  {
#line 935
  st = pap_domain___0(pai, & cbyte___3, max, & rrp->array[1], (parsedomain_flags )1);
  }
#line 936
  if (st) {
#line 936
    return (st);
  }
#line 938
  if (cbyte___3 != max) {
#line 938
    return ((adns_status )104);
  }
#line 939
  return ((adns_status )0);
}
}
#line 942 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_rp___0(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_strpair const   *rrp ;
  adns_status st ;
  int tmp ;

  {
  {
#line 943
  rrp = (adns_rr_strpair const   *)datap;
#line 946
  st = csp_mailbox___0(vb___0, (char const   *)rrp->array[0]);
  }
#line 946
  if (st) {
#line 946
    return (st);
  }
  {
#line 947
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 947
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 947
    if (! tmp) {
#line 947
      return ((adns_status )1);
    }
#line 947
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 948
  st = csp_domain___0(vb___0, (char const   *)rrp->array[1]);
  }
#line 948
  if (st) {
#line 948
    return (st);
  }
#line 950
  return ((adns_status )0);
}
}
#line 957 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_soa___0(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  adns_rr_soa *rrp ;
  byte const   *dgram ;
  adns_status st ;
  int msw ;
  int lsw ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 959
  rrp = (adns_rr_soa *)datap;
#line 960
  dgram = (byte const   *)pai->dgram;
#line 964
  if ((pai->qu)->flags & 64) {
#line 964
    tmp = 1;
  } else {
#line 964
    tmp = 0;
  }
  {
#line 964
  st = pap_domain___0(pai, & cbyte___3, max, & rrp->mname, (parsedomain_flags )tmp);
  }
#line 966
  if (st) {
#line 966
    return (st);
  }
  {
#line 968
  st = pap_mailbox___0(pai, & cbyte___3, max, & rrp->rname);
  }
#line 969
  if (st) {
#line 969
    return (st);
  }
#line 971
  if (cbyte___3 + 20 != max) {
#line 971
    return ((adns_status )104);
  }
#line 973
  i = 0;
  {
#line 973
  while (1) {
    while_continue: /* CIL Label */ ;
#line 973
    if (! (i < 5)) {
#line 973
      goto while_break;
    }
#line 974
    msw = 0;
#line 974
    tmp___0 = cbyte___3;
#line 974
    cbyte___3 ++;
#line 974
    msw |= (int )(((int const   )*(dgram + tmp___0) & 255) << 8);
#line 974
    tmp___1 = cbyte___3;
#line 974
    cbyte___3 ++;
#line 974
    msw |= (int )((int const   )*(dgram + tmp___1) & 255);
#line 975
    lsw = 0;
#line 975
    tmp___2 = cbyte___3;
#line 975
    cbyte___3 ++;
#line 975
    lsw |= (int )(((int const   )*(dgram + tmp___2) & 255) << 8);
#line 975
    tmp___3 = cbyte___3;
#line 975
    cbyte___3 ++;
#line 975
    lsw |= (int )((int const   )*(dgram + tmp___3) & 255);
#line 976
    *(& rrp->serial + i) = (unsigned long )((msw << 16) | lsw);
#line 973
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 979
  return ((adns_status )0);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_soa___0(adns_query qu , void *datap ) 
{ 
  adns_rr_soa *rrp ;

  {
  {
#line 983
  rrp = (adns_rr_soa *)datap;
#line 985
  adns__makefinal_str(qu, & rrp->mname);
#line 986
  adns__makefinal_str(qu, & rrp->rname);
  }
#line 987
  return;
}
}
#line 989 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_soa___0(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_soa const   *rrp ;
  char buf___17[20] ;
  int i ;
  adns_status st ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 990
  rrp = (adns_rr_soa const   *)datap;
#line 995
  st = csp_domain___0(vb___0, (char const   *)rrp->mname);
  }
#line 995
  if (st) {
#line 995
    return (st);
  }
  {
#line 996
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 996
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 996
    if (! tmp) {
#line 996
      return ((adns_status )1);
    }
#line 996
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 997
  st = csp_mailbox___0(vb___0, (char const   *)rrp->rname);
  }
#line 997
  if (st) {
#line 997
    return (st);
  }
#line 999
  i = 0;
  {
#line 999
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 999
    if (! (i < 5)) {
#line 999
      goto while_break___0;
    }
    {
#line 1000
    sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %lu",
            *(& rrp->serial + i));
    }
    {
#line 1001
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1001
      tmp___0 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
      }
#line 1001
      if (! tmp___0) {
#line 1001
        return ((adns_status )1);
      }
#line 1001
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 999
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1004
  return ((adns_status )0);
}
}
#line 1011 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status qdpl_srv___0(adns_state ads___7 , char const   **p_io , char const   *pe ,
                                int labelnum , char *label_r , int *ll_io , adns_queryflags flags ,
                                typeinfo const   *typei ) 
{ 
  int useflags ;
  char const   *p_orig ;
  adns_status st ;
  int ll ;
  void *tmp ;

  {
#line 1020
  if (labelnum < 2) {
#line 1020
    if (! ((unsigned int )flags & 16U)) {
#line 1021
      useflags = 16;
#line 1022
      p_orig = *p_io;
    } else {
#line 1024
      useflags = (int )flags;
#line 1025
      p_orig = (char const   *)0;
    }
  } else {
#line 1024
    useflags = (int )flags;
#line 1025
    p_orig = (char const   *)0;
  }
  {
#line 1027
  st = adns__qdpl_normal(ads___7, p_io, pe, labelnum, (char *)label_r, ll_io, (adns_queryflags )useflags,
                         typei);
  }
#line 1028
  if (st) {
#line 1028
    return (st);
  }
#line 1030
  if (p_orig) {
#line 1031
    ll = *ll_io;
#line 1032
    if (! ll) {
#line 1033
      return ((adns_status )201);
    } else
#line 1032
    if ((int )*(label_r + 0) != 95) {
#line 1033
      return ((adns_status )201);
    }
    {
#line 1034
    tmp = memchr((void const   *)(p_orig + 1), '\\', (size_t )(pe - (p_orig + 1)));
    }
#line 1034
    if (tmp) {
#line 1035
      return ((adns_status )201);
    }
  }
#line 1037
  return ((adns_status )0);
}
}
#line 1040 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_srv_begin___0(parseinfo const   *pai , int *cbyte_io , int max ,
                                     adns_rr_srvha *rrp ) 
{ 
  byte const   *dgram ;
  int ti ;
  int cbyte___3 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1043
  dgram = (byte const   *)pai->dgram;
#line 1046
  cbyte___3 = *cbyte_io;
#line 1047
  tmp = *cbyte_io + 6;
#line 1047
  *cbyte_io = tmp;
#line 1047
  if (tmp > max) {
#line 1047
    return ((adns_status )104);
  }
#line 1049
  ti = 0;
#line 1049
  tmp___0 = cbyte___3;
#line 1049
  cbyte___3 ++;
#line 1049
  ti |= (int )(((int const   )*(dgram + tmp___0) & 255) << 8);
#line 1049
  tmp___1 = cbyte___3;
#line 1049
  cbyte___3 ++;
#line 1049
  ti |= (int )((int const   )*(dgram + tmp___1) & 255);
#line 1049
  rrp->priority = ti;
#line 1050
  ti = 0;
#line 1050
  tmp___2 = cbyte___3;
#line 1050
  cbyte___3 ++;
#line 1050
  ti |= (int )(((int const   )*(dgram + tmp___2) & 255) << 8);
#line 1050
  tmp___3 = cbyte___3;
#line 1050
  cbyte___3 ++;
#line 1050
  ti |= (int )((int const   )*(dgram + tmp___3) & 255);
#line 1050
  rrp->weight = ti;
#line 1051
  ti = 0;
#line 1051
  tmp___4 = cbyte___3;
#line 1051
  cbyte___3 ++;
#line 1051
  ti |= (int )(((int const   )*(dgram + tmp___4) & 255) << 8);
#line 1051
  tmp___5 = cbyte___3;
#line 1051
  cbyte___3 ++;
#line 1051
  ti |= (int )((int const   )*(dgram + tmp___5) & 255);
#line 1051
  rrp->port = ti;
#line 1052
  return ((adns_status )0);
}
}
#line 1055 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_srvraw___0(parseinfo const   *pai , int cbyte___3 , int max ,
                                 void *datap ) 
{ 
  adns_rr_srvraw *rrp ;
  adns_status st ;
  int tmp ;

  {
  {
#line 1057
  rrp = (adns_rr_srvraw *)datap;
#line 1060
  st = pap_srv_begin___0(pai, & cbyte___3, max, (adns_rr_srvha *)datap);
  }
#line 1061
  if (st) {
#line 1061
    return (st);
  }
#line 1063
  if ((pai->qu)->flags & 64) {
#line 1063
    tmp = 1;
  } else {
#line 1063
    tmp = 0;
  }
  {
#line 1063
  st = pap_domain___0(pai, & cbyte___3, max, & rrp->host, (parsedomain_flags )tmp);
  }
#line 1065
  if (st) {
#line 1065
    return (st);
  }
#line 1067
  if (cbyte___3 != max) {
#line 1067
    return ((adns_status )104);
  }
#line 1068
  return ((adns_status )0);
}
}
#line 1071 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_srvha___0(parseinfo const   *pai , int cbyte___3 , int max ,
                                void *datap ) 
{ 
  adns_rr_srvha *rrp ;
  adns_status st ;

  {
  {
#line 1073
  rrp = (adns_rr_srvha *)datap;
#line 1076
  st = pap_srv_begin___0(pai, & cbyte___3, max, (adns_rr_srvha *)datap);
  }
#line 1076
  if (st) {
#line 1076
    return (st);
  }
  {
#line 1077
  st = pap_hostaddr___0(pai, & cbyte___3, max, & rrp->ha);
  }
#line 1077
  if (st) {
#line 1077
    return (st);
  }
#line 1078
  if (cbyte___3 != max) {
#line 1078
    return ((adns_status )104);
  }
#line 1079
  return ((adns_status )0);
}
}
#line 1082 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_srvraw___0(adns_query qu , void *datap ) 
{ 
  adns_rr_srvraw *rrp ;

  {
  {
#line 1083
  rrp = (adns_rr_srvraw *)datap;
#line 1084
  adns__makefinal_str(qu, & rrp->host);
  }
#line 1085
  return;
}
}
#line 1087 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_srvha___0(adns_query qu , void *datap ) 
{ 
  adns_rr_srvha *rrp ;

  {
  {
#line 1088
  rrp = (adns_rr_srvha *)datap;
#line 1089
  mfp_hostaddr___0(qu, & rrp->ha);
  }
#line 1090
  return;
}
}
#line 1092 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_srv___0(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_srvraw const   *ap ;
  adns_rr_srvraw const   *bp ;

  {
#line 1093
  ap = (adns_rr_srvraw const   *)datap_a;
#line 1093
  bp = (adns_rr_srvraw const   *)datap_b;
#line 1096
  if (ap->priority < bp->priority) {
#line 1096
    return (0);
  }
#line 1097
  if (ap->priority > bp->priority) {
#line 1097
    return (1);
  }
#line 1098
  return (0);
}
}
#line 1101 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_srv_begin___0(vbuf *vb___0 , adns_rr_srvha const   *rrp ) 
{ 
  char buf___17[30] ;
  int tmp ;

  {
  {
#line 1104
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"%u %u %u ",
          rrp->priority, rrp->weight, rrp->port);
  }
  {
#line 1105
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1105
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 1105
    if (! tmp) {
#line 1105
      return ((adns_status )1);
    }
#line 1105
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1106
  return ((adns_status )0);
}
}
#line 1109 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_srvraw___0(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_srvraw const   *rrp ;
  adns_status st ;
  adns_status tmp ;

  {
  {
#line 1110
  rrp = (adns_rr_srvraw const   *)datap;
#line 1113
  st = csp_srv_begin___0(vb___0, (adns_rr_srvha const   *)((void const   *)rrp));
  }
#line 1113
  if (st) {
#line 1113
    return (st);
  }
  {
#line 1114
  tmp = csp_domain___0(vb___0, (char const   *)rrp->host);
  }
#line 1114
  return (tmp);
}
}
#line 1117 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_srvha___0(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_srvha const   *rrp ;
  adns_status st ;
  adns_status tmp ;

  {
  {
#line 1118
  rrp = (adns_rr_srvha const   *)datap;
#line 1121
  st = csp_srv_begin___0(vb___0, (adns_rr_srvha const   *)datap);
  }
#line 1121
  if (st) {
#line 1121
    return (st);
  }
  {
#line 1122
  tmp = csp_hostaddr___0(vb___0, & rrp->ha);
  }
#line 1122
  return (tmp);
}
}
#line 1125 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void postsort_srv___0(adns_state ads___7 , void *array , int nrrs , struct typeinfo  const  *typei ) 
{ 
  char *workbegin ;
  char *workend ;
  char *search ;
  char *arrayend ;
  adns_rr_srvha const   *rr ;
  union __anonunion_rrtmp_89___0 rrtmp ;
  int cpriority ;
  int totalweight ;
  int runtotal ;
  long randval ;

  {
#line 1138
  workbegin = (char *)array;
#line 1138
  arrayend = workbegin + typei->rrsz * (int const   )nrrs;
  {
#line 1138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1138
    if (! ((unsigned long )workbegin < (unsigned long )arrayend)) {
#line 1138
      goto while_break;
    }
#line 1141
    rr = (adns_rr_srvha const   *)((void *)workbegin);
#line 1141
    cpriority = (int )rr->priority;
#line 1143
    workend = workbegin;
#line 1143
    totalweight = 0;
    {
#line 1143
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1143
      if ((unsigned long )workend < (unsigned long )arrayend) {
#line 1143
        rr = (adns_rr_srvha const   *)((void *)workend);
#line 1143
        if (! (rr->priority == (int const   )cpriority)) {
#line 1143
          goto while_break___0;
        }
      } else {
#line 1143
        goto while_break___0;
      }
#line 1146
      totalweight += (int )rr->weight;
#line 1143
      workend += typei->rrsz;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1155
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1155
      if (! ((unsigned long )(workbegin + typei->rrsz) < (unsigned long )workend)) {
#line 1155
        goto while_break___1;
      }
      {
#line 1159
      randval = nrand48((unsigned short *)(ads___7->rand48xsubi));
#line 1160
      randval %= (long )(totalweight + 1);
#line 1167
      search = workbegin;
#line 1167
      runtotal = 0;
      }
      {
#line 1167
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1167
        rr = (adns_rr_srvha const   *)((void *)search);
#line 1167
        runtotal += (int )rr->weight;
#line 1167
        if (! ((long )runtotal < randval)) {
#line 1167
          goto while_break___2;
        }
#line 1167
        search += typei->rrsz;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1170
      if (! ((unsigned long )search < (unsigned long )arrayend)) {
        {
#line 1170
        __assert_fail("search < arrayend", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                      1170U, "postsort_srv");
        }
      }
#line 1171
      totalweight -= (int )rr->weight;
#line 1172
      if ((unsigned long )search != (unsigned long )workbegin) {
        {
#line 1173
        memcpy((void */* __restrict  */)(& rrtmp), (void const   */* __restrict  */)workbegin,
               (size_t )typei->rrsz);
#line 1174
        memcpy((void */* __restrict  */)workbegin, (void const   */* __restrict  */)search,
               (size_t )typei->rrsz);
#line 1175
        memcpy((void */* __restrict  */)search, (void const   */* __restrict  */)(& rrtmp),
               (size_t )typei->rrsz);
        }
      }
#line 1155
      workbegin += typei->rrsz;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1138
    workbegin = workend;
  }
  while_break: /* CIL Label */ ;
  }
#line 1184
  return;
}
}
#line 1190 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_byteblock___0(adns_query qu , void *datap ) 
{ 
  adns_rr_byteblock *rrp ;
  void *bytes___3 ;

  {
  {
#line 1191
  rrp = (adns_rr_byteblock *)datap;
#line 1192
  bytes___3 = (void *)rrp->data;
#line 1193
  adns__makefinal_block(qu, & bytes___3, (size_t )rrp->len);
#line 1194
  rrp->data = (unsigned char *)bytes___3;
  }
#line 1195
  return;
}
}
#line 1201 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_opaque___0(parseinfo const   *pai , int cbyte___3 , int max ,
                                 void *datap ) 
{ 
  adns_rr_byteblock *rrp ;
  void *tmp ;

  {
  {
#line 1203
  rrp = (adns_rr_byteblock *)datap;
#line 1205
  rrp->len = max - cbyte___3;
#line 1206
  tmp = adns__alloc_interim((adns_query )pai->qu, (size_t )rrp->len);
#line 1206
  rrp->data = (unsigned char *)tmp;
  }
#line 1207
  if (! rrp->data) {
#line 1207
    return ((adns_status )1);
  }
  {
#line 1208
  memcpy((void */* __restrict  */)rrp->data, (void const   */* __restrict  */)(pai->dgram + cbyte___3),
         (size_t )rrp->len);
  }
#line 1209
  return ((adns_status )0);
}
}
#line 1212 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_opaque___0(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_byteblock const   *rrp ;
  char buf___17[10] ;
  int l ;
  unsigned char *p ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1213
  rrp = (adns_rr_byteblock const   *)datap;
#line 1218
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"\\# %d",
          rrp->len);
  }
  {
#line 1219
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1219
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 1219
    if (! tmp) {
#line 1219
      return ((adns_status )1);
    }
#line 1219
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1221
  l = (int )rrp->len;
#line 1221
  p = (unsigned char *)rrp->data;
  {
#line 1221
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1221
    if (! (l >= 4)) {
#line 1221
      goto while_break___0;
    }
    {
#line 1224
    sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %02x%02x%02x%02x",
            (int )*(p + 0), (int )*(p + 1), (int )*(p + 2), (int )*(p + 3));
    }
    {
#line 1225
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1225
      tmp___0 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
      }
#line 1225
      if (! tmp___0) {
#line 1225
        return ((adns_status )1);
      }
#line 1225
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1221
    l -= 4;
#line 1221
    p += 4;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1227
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1227
    if (! (l > 0)) {
#line 1227
      goto while_break___2;
    }
    {
#line 1230
    sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %02x",
            (int )*p);
    }
    {
#line 1231
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 1231
      tmp___1 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
      }
#line 1231
      if (! tmp___1) {
#line 1231
        return ((adns_status )1);
      }
#line 1231
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1227
    l --;
#line 1227
    p ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1233
  return ((adns_status )0);
}
}
#line 1240 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_flat___0(adns_query qu , void *data___0 ) 
{ 


  {
#line 1240
  return;
}
}
#line 1261 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static typeinfo const   typeinfos___0[17]  = 
#line 1261
  {      {(adns_rrtype )1, "A", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.inaddr)),
      & mf_flat___0, & cs_inaddr___0, & pa_inaddr___0, & di_inaddr___0, (adns_status (*)(adns_state ads ,
                                                                                         char const   **p_io ,
                                                                                         char const   *pe ,
                                                                                         int labelnum ,
                                                                                         char *label_r ,
                                                                                         int *ll_io ,
                                                                                         adns_queryflags flags ,
                                                                                         struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )2,
      "NS", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___0, & cs_domain___0,
      & pa_host_raw___0, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )5,
      "CNAME", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___0,
      & cs_domain___0, & pa_dom_raw___0, (int (*)(adns_state ads , void const   *datap_a ,
                                                  void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                              char const   **p_io ,
                                                                                              char const   *pe ,
                                                                                              int labelnum ,
                                                                                              char *label_r ,
                                                                                              int *ll_io ,
                                                                                              adns_queryflags flags ,
                                                                                              struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )6,
      "SOA", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.soa)), & mf_soa___0, & cs_soa___0,
      & pa_soa___0, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )12,
      "PTR", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___0, & cs_domain___0,
      & pa_host_raw___0, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )13,
      "HINFO", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.intstrpair)),
      & mf_intstrpair___0, & cs_hinfo___0, & pa_hinfo___0, (int (*)(adns_state ads ,
                                                                    void const   *datap_a ,
                                                                    void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )15,
      "MX", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.intstr)), & mf_intstr___0,
      & cs_inthost___0, & pa_mx_raw___0, & di_mx_raw___0, (adns_status (*)(adns_state ads ,
                                                                           char const   **p_io ,
                                                                           char const   *pe ,
                                                                           int labelnum ,
                                                                           char *label_r ,
                                                                           int *ll_io ,
                                                                           adns_queryflags flags ,
                                                                           struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )16,
      "TXT", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.manyistr)),
      & mf_manyistr___0, & cs_txt___0, & pa_txt___0, (int (*)(adns_state ads , void const   *datap_a ,
                                                              void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )17,
      "RP", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.strpair)), & mf_strpair___0,
      & cs_rp___0, & pa_rp___0, (int (*)(adns_state ads , void const   *datap_a ,
                                         void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                     char const   **p_io ,
                                                                                     char const   *pe ,
                                                                                     int labelnum ,
                                                                                     char *label_r ,
                                                                                     int *ll_io ,
                                                                                     adns_queryflags flags ,
                                                                                     struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )33,
      "SRV", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.srvraw)), & mf_srvraw___0,
      & cs_srvraw___0, & pa_srvraw___0, & di_srv___0, & qdpl_srv___0, & postsort_srv___0}, 
        {(adns_rrtype )65537,
      "A", "addr", (int )sizeof(*(((adns_answer *)0)->rrs.addr)), & mf_flat___0, & cs_addr___0,
      & pa_addr___0, & di_addr___0, (adns_status (*)(adns_state ads , char const   **p_io ,
                                                     char const   *pe , int labelnum ,
                                                     char *label_r , int *ll_io ,
                                                     adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65538,
      "NS", "+addr", (int )sizeof(*(((adns_answer *)0)->rrs.hostaddr)), & mf_hostaddr___0,
      & cs_hostaddr___0, & pa_hostaddr___0, & di_hostaddr___0, (adns_status (*)(adns_state ads ,
                                                                                char const   **p_io ,
                                                                                char const   *pe ,
                                                                                int labelnum ,
                                                                                char *label_r ,
                                                                                int *ll_io ,
                                                                                adns_queryflags flags ,
                                                                                struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65548,
      "PTR", "checked", (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___0,
      & cs_domain___0, & pa_ptr___0, (int (*)(adns_state ads , void const   *datap_a ,
                                              void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                          char const   **p_io ,
                                                                                          char const   *pe ,
                                                                                          int labelnum ,
                                                                                          char *label_r ,
                                                                                          int *ll_io ,
                                                                                          adns_queryflags flags ,
                                                                                          struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65551,
      "MX", "+addr", (int )sizeof(*(((adns_answer *)0)->rrs.inthostaddr)), & mf_inthostaddr___0,
      & cs_inthostaddr___0, & pa_mx___0, & di_mx___0, (adns_status (*)(adns_state ads ,
                                                                       char const   **p_io ,
                                                                       char const   *pe ,
                                                                       int labelnum ,
                                                                       char *label_r ,
                                                                       int *ll_io ,
                                                                       adns_queryflags flags ,
                                                                       struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65569,
      "SRV", "+addr", (int )sizeof(*(((adns_answer *)0)->rrs.srvha)), & mf_srvha___0,
      & cs_srvha___0, & pa_srvha___0, & di_srv___0, & qdpl_srv___0, & postsort_srv___0}, 
        {(adns_rrtype )131078,
      "SOA", "822", (int )sizeof(*(((adns_answer *)0)->rrs.soa)), & mf_soa___0, & cs_soa___0,
      & pa_soa___0, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )131089,
      "RP", "822", (int )sizeof(*(((adns_answer *)0)->rrs.strpair)), & mf_strpair___0,
      & cs_rp___0, & pa_rp___0, (int (*)(adns_state ads , void const   *datap_a ,
                                         void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                     char const   **p_io ,
                                                                                     char const   *pe ,
                                                                                     int labelnum ,
                                                                                     char *label_r ,
                                                                                     int *ll_io ,
                                                                                     adns_queryflags flags ,
                                                                                     struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}};
#line 1288 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static struct typeinfo  const  typeinfo_unknown___0  = 
#line 1288
     {(adns_rrtype )262144, (char const   *)0, "unknown", (int )sizeof(*(((adns_answer *)0)->rrs.byteblock)),
    & mf_byteblock___0, & cs_opaque___0, & pa_opaque___0, (int (*)(adns_state ads ,
                                                                   void const   *datap_a ,
                                                                   void const   *datap_b ))0,
    (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                     char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
    (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0};
#line 55 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_query_alloc___0(adns_state ads___7 , adns_query qu ) 
{ 
  allocnode *an ;
  int tmp ;

  {
#line 58
  if (qu->allocations.head) {
#line 58
    if (! (! (qu->allocations.head)->back)) {
      {
#line 58
      __assert_fail("! (qu->allocations).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    59U, "checkc_query_alloc");
      }
    }
#line 58
    an = qu->allocations.head;
    {
#line 58
    while (1) {
      while_continue: /* CIL Label */ ;
#line 58
      if (! an) {
#line 58
        goto while_break;
      }
#line 58
      if (an->next) {
#line 58
        tmp = (unsigned long )an == (unsigned long )(an->next)->back;
      } else {
#line 58
        tmp = (unsigned long )an == (unsigned long )qu->allocations.tail;
      }
#line 58
      if (! tmp) {
        {
#line 58
        __assert_fail("(an)-> next ? (an) == (an)-> next-> back : (an) == (qu->allocations).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      59U, "checkc_query_alloc");
        }
      }
#line 58
      an = an->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 60
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_query___0(adns_state ads___7 , adns_query qu ) 
{ 
  adns_query child ;

  {
#line 65
  if (! (qu->udpnextserver < ads___7->nservers)) {
    {
#line 65
    __assert_fail("qu->udpnextserver < ads->nservers", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  65U, "checkc_query");
    }
  }
#line 66
  if (! (! (qu->udpsent & (0xffffffffffffffffUL << ads___7->nservers)))) {
    {
#line 66
    __assert_fail("!(qu->udpsent & (~0UL << ads->nservers))", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  66U, "checkc_query");
    }
  }
#line 67
  if (! (qu->search_pos <= ads___7->nsearchlist)) {
    {
#line 67
    __assert_fail("qu->search_pos <= ads->nsearchlist", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  67U, "checkc_query");
    }
  }
#line 68
  if (qu->parent) {
    {
#line 68
    while (1) {
      while_continue: /* CIL Label */ ;
#line 68
      child = (qu->parent)->children.head;
      {
#line 68
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 68
        if (! ((unsigned long )child != (unsigned long )qu)) {
#line 68
          goto while_break___0;
        }
#line 68
        if (! child) {
          {
#line 68
          __assert_fail("(child)", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        68U, "checkc_query");
          }
        }
#line 68
        child = child->siblings.next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 68
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 69
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_notcpbuf___0(adns_state ads___7 ) 
{ 


  {
#line 72
  if (! (! ads___7->tcpsend.used)) {
    {
#line 72
    __assert_fail("!ads->tcpsend.used", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  72U, "checkc_notcpbuf");
    }
  }
#line 73
  if (! (! ads___7->tcprecv.used)) {
    {
#line 73
    __assert_fail("!ads->tcprecv.used", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  73U, "checkc_notcpbuf");
    }
  }
#line 74
  if (! (! ads___7->tcprecv_skip)) {
    {
#line 74
    __assert_fail("!ads->tcprecv_skip", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  74U, "checkc_notcpbuf");
    }
  }
#line 75
  return;
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_global___0(adns_state ads___7 ) 
{ 
  int i ;

  {
#line 80
  if (! (ads___7->udpsocket >= 0)) {
    {
#line 80
    __assert_fail("ads->udpsocket >= 0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  80U, "checkc_global");
    }
  }
#line 82
  i = 0;
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! (i < ads___7->nsortlist)) {
#line 82
      goto while_break;
    }
#line 83
    if (! (! (ads___7->sortlist[i].base.s_addr & ~ ads___7->sortlist[i].mask.s_addr))) {
      {
#line 83
      __assert_fail("!(ads->sortlist[i].base.s_addr & ~ads->sortlist[i].mask.s_addr)",
                    "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    83U, "checkc_global");
      }
    }
#line 82
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  if (ads___7->tcpserver >= 0) {
#line 85
    if (! (ads___7->tcpserver < ads___7->nservers)) {
      {
#line 85
      __assert_fail("ads->tcpserver >= 0 && ads->tcpserver < ads->nservers", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    85U, "checkc_global");
      }
    }
  } else {
    {
#line 85
    __assert_fail("ads->tcpserver >= 0 && ads->tcpserver < ads->nservers", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  85U, "checkc_global");
    }
  }
  {
#line 88
  if ((unsigned int )ads___7->tcpstate == 1U) {
#line 88
    goto case_1;
  }
#line 93
  if ((unsigned int )ads___7->tcpstate == 3U) {
#line 93
    goto case_3;
  }
#line 93
  if ((unsigned int )ads___7->tcpstate == 0U) {
#line 93
    goto case_3;
  }
#line 97
  if ((unsigned int )ads___7->tcpstate == 2U) {
#line 97
    goto case_2;
  }
#line 101
  goto switch_default;
  case_1: /* CIL Label */ 
#line 89
  if (! (ads___7->tcpsocket >= 0)) {
    {
#line 89
    __assert_fail("ads->tcpsocket >= 0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  89U, "checkc_global");
    }
  }
  {
#line 90
  checkc_notcpbuf___0(ads___7);
  }
#line 91
  goto switch_break;
  case_3: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 94
  if (! (ads___7->tcpsocket == -1)) {
    {
#line 94
    __assert_fail("ads->tcpsocket == -1", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  94U, "checkc_global");
    }
  }
  {
#line 95
  checkc_notcpbuf___0(ads___7);
  }
#line 96
  goto switch_break;
  case_2: /* CIL Label */ 
#line 98
  if (! (ads___7->tcpsocket >= 0)) {
    {
#line 98
    __assert_fail("ads->tcpsocket >= 0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  98U, "checkc_global");
    }
  }
#line 99
  if (! (ads___7->tcprecv_skip <= ads___7->tcprecv.used)) {
    {
#line 99
    __assert_fail("ads->tcprecv_skip <= ads->tcprecv.used", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  99U, "checkc_global");
    }
  }
#line 100
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 102
  __assert_fail("!\"ads->tcpstate value\"", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                102U, "checkc_global");
  }
  switch_break: /* CIL Label */ ;
  }
#line 105
  if (! ads___7->searchlist) {
#line 105
    if (! (! ads___7->nsearchlist)) {
      {
#line 105
      __assert_fail("ads->searchlist || !ads->nsearchlist", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    105U, "checkc_global");
      }
    }
  }
#line 106
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_queue_udpw___0(adns_state ads___7 ) 
{ 
  adns_query qu ;
  int tmp ;

  {
#line 111
  if (ads___7->udpw.head) {
#line 111
    if (! (! (ads___7->udpw.head)->back)) {
      {
#line 111
      __assert_fail("! (ads->udpw).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    118U, "checkc_queue_udpw");
      }
    }
#line 111
    qu = ads___7->udpw.head;
    {
#line 111
    while (1) {
      while_continue: /* CIL Label */ ;
#line 111
      if (! qu) {
#line 111
        goto while_break;
      }
#line 111
      if (qu->next) {
#line 111
        tmp = (unsigned long )qu == (unsigned long )(qu->next)->back;
      } else {
#line 111
        tmp = (unsigned long )qu == (unsigned long )ads___7->udpw.tail;
      }
#line 111
      if (! tmp) {
        {
#line 111
        __assert_fail("(qu)-> next ? (qu) == (qu)-> next-> back : (qu) == (ads->udpw).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! ((unsigned int )qu->state == 0U)) {
        {
#line 111
        __assert_fail("qu->state==query_tosend", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! (qu->retries <= 15)) {
        {
#line 111
        __assert_fail("qu->retries <= 15", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! qu->udpsent) {
        {
#line 111
        __assert_fail("qu->udpsent", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! qu->children.head) {
#line 111
        if (! (! qu->children.tail)) {
          {
#line 111
          __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        118U, "checkc_queue_udpw");
          }
        }
      } else {
        {
#line 111
        __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
      {
#line 111
      checkc_query___0(ads___7, qu);
#line 111
      checkc_query_alloc___0(ads___7, qu);
#line 111
      qu = qu->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 119
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_queue_tcpw___0(adns_state ads___7 ) 
{ 
  adns_query qu ;
  int tmp ;

  {
#line 124
  if (ads___7->tcpw.head) {
#line 124
    if (! (! (ads___7->tcpw.head)->back)) {
      {
#line 124
      __assert_fail("! (ads->tcpw).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    130U, "checkc_queue_tcpw");
      }
    }
#line 124
    qu = ads___7->tcpw.head;
    {
#line 124
    while (1) {
      while_continue: /* CIL Label */ ;
#line 124
      if (! qu) {
#line 124
        goto while_break;
      }
#line 124
      if (qu->next) {
#line 124
        tmp = (unsigned long )qu == (unsigned long )(qu->next)->back;
      } else {
#line 124
        tmp = (unsigned long )qu == (unsigned long )ads___7->tcpw.tail;
      }
#line 124
      if (! tmp) {
        {
#line 124
        __assert_fail("(qu)-> next ? (qu) == (qu)-> next-> back : (qu) == (ads->tcpw).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
#line 124
      if (! ((unsigned int )qu->state == 1U)) {
        {
#line 124
        __assert_fail("qu->state==query_tcpw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
#line 124
      if (! qu->children.head) {
#line 124
        if (! (! qu->children.tail)) {
          {
#line 124
          __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        130U, "checkc_queue_tcpw");
          }
        }
      } else {
        {
#line 124
        __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
#line 124
      if (! (qu->retries <= ads___7->nservers + 1)) {
        {
#line 124
        __assert_fail("qu->retries <= ads->nservers+1", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
      {
#line 124
      checkc_query___0(ads___7, qu);
#line 124
      checkc_query_alloc___0(ads___7, qu);
#line 124
      qu = qu->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 131
  return;
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_queue_childw___0(adns_state ads___7 ) 
{ 
  adns_query parent ;
  adns_query child ;
  int tmp ;
  int tmp___0 ;

  {
#line 136
  if (ads___7->childw.head) {
#line 136
    if (! (! (ads___7->childw.head)->back)) {
      {
#line 136
      __assert_fail("! (ads->childw).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    145U, "checkc_queue_childw");
      }
    }
#line 136
    parent = ads___7->childw.head;
    {
#line 136
    while (1) {
      while_continue: /* CIL Label */ ;
#line 136
      if (! parent) {
#line 136
        goto while_break;
      }
#line 136
      if (parent->next) {
#line 136
        tmp = (unsigned long )parent == (unsigned long )(parent->next)->back;
      } else {
#line 136
        tmp = (unsigned long )parent == (unsigned long )ads___7->childw.tail;
      }
#line 136
      if (! tmp) {
        {
#line 136
        __assert_fail("(parent)-> next ? (parent) == (parent)-> next-> back : (parent) == (ads->childw).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      145U, "checkc_queue_childw");
        }
      }
#line 136
      if (! ((unsigned int )parent->state == 2U)) {
        {
#line 136
        __assert_fail("parent->state == query_childw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      145U, "checkc_queue_childw");
        }
      }
#line 136
      if (! parent->children.head) {
        {
#line 136
        __assert_fail("parent->children.head", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      145U, "checkc_queue_childw");
        }
      }
#line 136
      if (parent->children.head) {
#line 136
        if (! (! (parent->children.head)->siblings.back)) {
          {
#line 136
          __assert_fail("! (parent->children).head->siblings. back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        145U, "checkc_queue_childw");
          }
        }
#line 136
        child = parent->children.head;
        {
#line 136
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 136
          if (! child) {
#line 136
            goto while_break___0;
          }
#line 136
          if (child->siblings.next) {
#line 136
            tmp___0 = (unsigned long )child == (unsigned long )(child->siblings.next)->siblings.back;
          } else {
#line 136
            tmp___0 = (unsigned long )child == (unsigned long )parent->children.tail;
          }
#line 136
          if (! tmp___0) {
            {
#line 136
            __assert_fail("(child)->siblings. next ? (child) == (child)->siblings. next->siblings. back : (child) == (parent->children).tail",
                          "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                          145U, "checkc_queue_childw");
            }
          }
#line 136
          if (! ((unsigned long )child->parent == (unsigned long )parent)) {
            {
#line 136
            __assert_fail("child->parent == parent", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                          145U, "checkc_queue_childw");
            }
          }
#line 136
          if (! ((unsigned int )child->state != 3U)) {
            {
#line 136
            __assert_fail("child->state != query_done", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                          145U, "checkc_queue_childw");
            }
          }
#line 136
          child = child->siblings.next;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 136
      checkc_query___0(ads___7, parent);
#line 136
      checkc_query_alloc___0(ads___7, parent);
#line 136
      parent = parent->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 146
  return;
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_queue_output___0(adns_state ads___7 ) 
{ 
  adns_query qu ;
  int tmp ;

  {
#line 151
  if (ads___7->output.head) {
#line 151
    if (! (! (ads___7->output.head)->back)) {
      {
#line 151
      __assert_fail("! (ads->output).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    157U, "checkc_queue_output");
      }
    }
#line 151
    qu = ads___7->output.head;
    {
#line 151
    while (1) {
      while_continue: /* CIL Label */ ;
#line 151
      if (! qu) {
#line 151
        goto while_break;
      }
#line 151
      if (qu->next) {
#line 151
        tmp = (unsigned long )qu == (unsigned long )(qu->next)->back;
      } else {
#line 151
        tmp = (unsigned long )qu == (unsigned long )ads___7->output.tail;
      }
#line 151
      if (! tmp) {
        {
#line 151
        __assert_fail("(qu)-> next ? (qu) == (qu)-> next-> back : (qu) == (ads->output).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! ((unsigned int )qu->state == 3U)) {
        {
#line 151
        __assert_fail("qu->state == query_done", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! qu->children.head) {
#line 151
        if (! (! qu->children.tail)) {
          {
#line 151
          __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        157U, "checkc_queue_output");
          }
        }
      } else {
        {
#line 151
        __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! (! qu->parent)) {
        {
#line 151
        __assert_fail("!qu->parent", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! qu->allocations.head) {
#line 151
        if (! (! qu->allocations.tail)) {
          {
#line 151
          __assert_fail("!qu->allocations.head && !qu->allocations.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        157U, "checkc_queue_output");
          }
        }
      } else {
        {
#line 151
        __assert_fail("!qu->allocations.head && !qu->allocations.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
      {
#line 151
      checkc_query___0(ads___7, qu);
#line 151
      qu = qu->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 158
  return;
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
static struct sinfo  const  sinfos___0[24]  = 
#line 233 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
  {      {(adns_status )0, "ok", "OK"}, 
        {(adns_status )1, "nomemory", "Out of memory"}, 
        {(adns_status )2, "unknownrrtype", "Query not implemented in DNS library"}, 
        {(adns_status )3, "systemfail", "General resolver or system failure"}, 
        {(adns_status )30, "timeout", "DNS query timed out"}, 
        {(adns_status )31, "allservfail", "All nameservers failed"}, 
        {(adns_status )32, "norecurse", "Recursion denied by nameserver"}, 
        {(adns_status )33, "invalidresponse", "Nameserver sent bad response"}, 
        {(adns_status )34, "unknownformat", "Nameserver used unknown format"}, 
        {(adns_status )60, "rcodeservfail", "Nameserver reports failure"}, 
        {(adns_status )61, "rcodeformaterror", "Query not understood by nameserver"}, 
        {(adns_status )62,
      "rcodenotimplemented", "Query not implemented by nameserver"}, 
        {(adns_status )63, "rcoderefused", "Query refused by nameserver"}, 
        {(adns_status )64, "rcodeunknown", "Nameserver sent unknown response code"}, 
        {(adns_status )100, "inconsistent", "Inconsistent resource records in DNS"}, 
        {(adns_status )101, "prohibitedcname", "DNS alias found where canonical name wanted"}, 
        {(adns_status )102,
      "answerdomaininvalid", "Found syntactically invalid domain name"}, 
        {(adns_status )103, "answerdomaintoolong", "Found overly-long domain name"}, 
        {(adns_status )104, "invaliddata", "Found invalid DNS data"}, 
        {(adns_status )200, "querydomainwrong", "Domain invalid for particular DNS query type"}, 
        {(adns_status )201,
      "querydomaininvalid", "Domain name is syntactically invalid"}, 
        {(adns_status )202, "querydomaintoolong", "Domain name or component is too long"}, 
        {(adns_status )300,
      "nxdomain", "No such domain"}, 
        {(adns_status )301, "nodata", "No such data"}};
#line 270 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
static int si_compar___0(void const   *key , void const   *elem ) 
{ 
  adns_status const   *st ;
  struct sinfo  const  *si ;
  int tmp ;
  int tmp___0 ;

  {
#line 271
  st = (adns_status const   *)key;
#line 272
  si = (struct sinfo  const  *)elem;
#line 274
  if ((unsigned int const   )*st < (unsigned int const   )si->st) {
#line 274
    tmp___0 = -1;
  } else {
#line 274
    if ((unsigned int const   )*st > (unsigned int const   )si->st) {
#line 274
      tmp = 1;
    } else {
#line 274
      tmp = 0;
    }
#line 274
    tmp___0 = tmp;
  }
#line 274
  return (tmp___0);
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
static struct sinfo  const  *findsinfo___0(adns_status st ) 
{ 
  void *tmp ;

  {
  {
#line 278
  tmp = bsearch((void const   *)(& st), (void const   *)(sinfos___0), sizeof(sinfos___0) / sizeof(sinfos___0[0]),
                sizeof(sinfos___0[0]), & si_compar___0);
  }
#line 278
  return ((struct sinfo  const  *)tmp);
}
}
#line 299 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
static struct stinfo  const  stinfos___0[7]  = {      {(adns_status )0, "ok"}, 
        {(adns_status )29, "localfail"}, 
        {(adns_status )59, "remotefail"}, 
        {(adns_status )99, "tempfail"}, 
        {(adns_status )199, "misconfig"}, 
        {(adns_status )299, "misquery"}, 
        {(adns_status )499, "permfail"}};
#line 312 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
static int sti_compar___0(void const   *key , void const   *elem ) 
{ 
  adns_status const   *st ;
  struct stinfo  const  *sti ;
  adns_status here ;
  adns_status min ;
  adns_status max ;
  int tmp ;
  int tmp___0 ;

  {
#line 313
  st = (adns_status const   *)key;
#line 314
  sti = (struct stinfo  const  *)elem;
#line 318
  here = (adns_status )*st;
#line 319
  if ((unsigned long )sti == (unsigned long )(stinfos___0)) {
#line 319
    min = (adns_status )0;
  } else {
#line 319
    min = (adns_status )((unsigned int const   )(sti + -1)->stmax + 1U);
  }
#line 320
  max = (adns_status )sti->stmax;
#line 322
  if ((unsigned int )here < (unsigned int )min) {
#line 322
    tmp___0 = -1;
  } else {
#line 322
    if ((unsigned int )here > (unsigned int )max) {
#line 322
      tmp = 1;
    } else {
#line 322
      tmp = 0;
    }
#line 322
    tmp___0 = tmp;
  }
#line 322
  return (tmp___0);
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/transmit.c"
static adns_status mkquery_header___0(adns_state ads___7 , vbuf *vb___0 , int *id_r ,
                                      int qdlen ) 
{ 
  int id ;
  byte *rqp ;
  int tmp ;
  int tmp___0 ;
  byte *tmp___1 ;
  byte *tmp___2 ;
  byte *tmp___3 ;
  byte *tmp___4 ;
  byte *tmp___5 ;
  byte *tmp___6 ;
  byte *tmp___7 ;
  byte *tmp___8 ;
  byte *tmp___9 ;
  byte *tmp___10 ;
  byte *tmp___11 ;
  byte *tmp___12 ;

  {
  {
#line 46
  tmp = adns__vbuf_ensure(vb___0, (12 + qdlen) + 4);
  }
#line 46
  if (! tmp) {
#line 46
    return ((adns_status )1);
  }
#line 48
  vb___0->used = 0;
#line 49
  rqp = vb___0->buf + vb___0->used;
#line 51
  tmp___0 = ads___7->nextid;
#line 51
  (ads___7->nextid) ++;
#line 51
  id = tmp___0 & 65535;
#line 51
  *id_r = id;
#line 52
  tmp___1 = rqp;
#line 52
  rqp ++;
#line 52
  *tmp___1 = (byte )((id >> 8) & 255);
#line 52
  tmp___2 = rqp;
#line 52
  rqp ++;
#line 52
  *tmp___2 = (byte )(id & 255);
#line 53
  tmp___3 = rqp;
#line 53
  rqp ++;
#line 53
  *tmp___3 = (byte )1;
#line 54
  tmp___4 = rqp;
#line 54
  rqp ++;
#line 54
  *tmp___4 = (byte )0;
#line 55
  tmp___5 = rqp;
#line 55
  rqp ++;
#line 55
  *tmp___5 = (byte )((1 >> 8) & 255);
#line 55
  tmp___6 = rqp;
#line 55
  rqp ++;
#line 55
  *tmp___6 = (byte )1;
#line 56
  tmp___7 = rqp;
#line 56
  rqp ++;
#line 56
  *tmp___7 = (byte )0;
#line 56
  tmp___8 = rqp;
#line 56
  rqp ++;
#line 56
  *tmp___8 = (byte )0;
#line 57
  tmp___9 = rqp;
#line 57
  rqp ++;
#line 57
  *tmp___9 = (byte )0;
#line 57
  tmp___10 = rqp;
#line 57
  rqp ++;
#line 57
  *tmp___10 = (byte )0;
#line 58
  tmp___11 = rqp;
#line 58
  rqp ++;
#line 58
  *tmp___11 = (byte )0;
#line 58
  tmp___12 = rqp;
#line 58
  rqp ++;
#line 58
  *tmp___12 = (byte )0;
#line 60
  vb___0->used = (int )(rqp - vb___0->buf);
#line 62
  return ((adns_status )0);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/transmit.c"
static adns_status mkquery_footer___0(vbuf *vb___0 , adns_rrtype type ) 
{ 
  byte *rqp ;
  byte *tmp ;
  byte *tmp___0 ;
  byte *tmp___1 ;
  byte *tmp___2 ;

  {
#line 68
  rqp = vb___0->buf + vb___0->used;
#line 69
  tmp = rqp;
#line 69
  rqp ++;
#line 69
  *tmp = (byte )((((unsigned int )type & 65535U) >> 8) & 255U);
#line 69
  tmp___0 = rqp;
#line 69
  rqp ++;
#line 69
  *tmp___0 = (byte )(((unsigned int )type & 65535U) & 255U);
#line 70
  tmp___1 = rqp;
#line 70
  rqp ++;
#line 70
  *tmp___1 = (byte )((1 >> 8) & 255);
#line 70
  tmp___2 = rqp;
#line 70
  rqp ++;
#line 70
  *tmp___2 = (byte )1;
#line 71
  vb___0->used = (int )(rqp - vb___0->buf);
#line 72
  if (! (vb___0->used <= vb___0->avail)) {
    {
#line 72
    __assert_fail("vb->used <= vb->avail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/transmit.c",
                  72U, "mkquery_footer");
    }
  }
#line 74
  return ((adns_status )0);
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/transmit.c"
static void query_usetcp___0(adns_query qu , struct timeval now ) 
{ 


  {
  {
#line 244
  qu->state = (enum __anonenum_state_83 )1;
#line 245
  qu->timeout = now;
#line 246
  timevaladd(& qu->timeout, 30000L);
  }
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    qu->next = (adns_query )0;
#line 247
    qu->back = (qu->ads)->tcpw.tail;
#line 247
    if ((qu->ads)->tcpw.tail) {
#line 247
      ((qu->ads)->tcpw.tail)->next = qu;
    } else {
#line 247
      (qu->ads)->tcpw.head = qu;
    }
#line 247
    (qu->ads)->tcpw.tail = qu;
#line 247
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 248
  adns__querysend_tcp(qu, now);
#line 249
  adns__tcp_tryconnect(qu->ads, now);
  }
#line 250
  return;
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static adns_query query_alloc___0(adns_state ads___7 , typeinfo const   *typei , adns_rrtype type ,
                                  adns_queryflags flags , struct timeval now ) 
{ 
  adns_query qu ;
  void *tmp ;
  void *tmp___0 ;
  adns_query tmp___1 ;
  adns_query tmp___2 ;
  adns_query tmp___3 ;
  adns_query tmp___4 ;
  allocnode *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __suseconds_t tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 45
  tmp = Hmalloc(sizeof(*qu));
#line 45
  qu = (adns_query )tmp;
  }
#line 45
  if (! qu) {
#line 45
    return ((adns_query )0);
  }
  {
#line 46
  tmp___0 = Hmalloc(sizeof(*(qu->answer)));
#line 46
  qu->answer = (adns_answer *)tmp___0;
  }
#line 47
  if (! qu->answer) {
    {
#line 47
    Hfree((void *)qu);
    }
#line 47
    return ((adns_query )0);
  }
  {
#line 49
  qu->ads = ads___7;
#line 50
  qu->state = (enum __anonenum_state_83 )0;
#line 51
  tmp___2 = (adns_query )0;
#line 51
  qu->parent = tmp___2;
#line 51
  tmp___1 = tmp___2;
#line 51
  qu->next = tmp___1;
#line 51
  qu->back = tmp___1;
#line 52
  tmp___3 = (adns_query )0;
#line 52
  qu->children.tail = tmp___3;
#line 52
  qu->children.head = tmp___3;
#line 53
  tmp___4 = (adns_query )0;
#line 53
  qu->siblings.back = tmp___4;
#line 53
  qu->siblings.next = tmp___4;
#line 54
  tmp___5 = (allocnode *)0;
#line 54
  qu->allocations.tail = tmp___5;
#line 54
  qu->allocations.head = tmp___5;
#line 55
  qu->interim_allocd = 0;
#line 56
  qu->preserved_allocd = 0;
#line 57
  qu->final_allocspace = (void *)0;
#line 59
  qu->typei = typei;
#line 60
  qu->query_dgram = (byte *)0;
#line 61
  qu->query_dglen = 0;
#line 62
  adns__vbuf_init(& qu->vb);
#line 64
  qu->cname_dgram = (byte *)0;
#line 65
  tmp___6 = 0;
#line 65
  qu->cname_begin = tmp___6;
#line 65
  qu->cname_dglen = tmp___6;
#line 67
  adns__vbuf_init(& qu->search_vb);
#line 68
  tmp___8 = 0;
#line 68
  qu->search_doneabs = tmp___8;
#line 68
  tmp___7 = tmp___8;
#line 68
  qu->search_pos = tmp___7;
#line 68
  qu->search_origlen = tmp___7;
#line 70
  qu->id = -2;
#line 71
  qu->flags = (int )flags;
#line 72
  qu->retries = 0;
#line 73
  qu->udpnextserver = 0;
#line 74
  qu->udpsent = 0UL;
#line 75
  tmp___9 = (__suseconds_t )0;
#line 75
  qu->timeout.tv_usec = tmp___9;
#line 75
  qu->timeout.tv_sec = tmp___9;
#line 76
  qu->expires = now.tv_sec + 604800L;
#line 78
  memset((void *)(& qu->ctx), 0, sizeof(qu->ctx));
#line 80
  (qu->answer)->status = (adns_status )0;
#line 81
  tmp___10 = (char *)0;
#line 81
  (qu->answer)->owner = tmp___10;
#line 81
  (qu->answer)->cname = tmp___10;
#line 82
  (qu->answer)->type = type;
#line 83
  (qu->answer)->expires = (time_t )-1;
#line 84
  (qu->answer)->nrrs = 0;
#line 85
  (qu->answer)->rrs.untyped = (void *)0;
#line 86
  (qu->answer)->rrsz = (int )typei->rrsz;
  }
#line 88
  return (qu);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void query_submit___0(adns_state ads___7 , adns_query qu , typeinfo const   *typei ,
                             vbuf *qumsg_vb , int id , adns_queryflags flags , struct timeval now ) 
{ 
  void *tmp ;

  {
  {
#line 98
  qu->vb = *qumsg_vb;
#line 99
  adns__vbuf_init(qumsg_vb);
#line 101
  tmp = Hmalloc((size_t )qu->vb.used);
#line 101
  qu->query_dgram = (byte *)tmp;
  }
#line 102
  if (! qu->query_dgram) {
    {
#line 102
    adns__query_fail(qu, (adns_status )1);
    }
#line 102
    return;
  }
  {
#line 104
  qu->id = id;
#line 105
  qu->query_dglen = qu->vb.used;
#line 106
  memcpy((void */* __restrict  */)qu->query_dgram, (void const   */* __restrict  */)qu->vb.buf,
         (size_t )qu->vb.used);
#line 108
  adns__query_send(qu, now);
  }
#line 109
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void query_simple___0(adns_state ads___7 , adns_query qu , char const   *owner ,
                             int ol , typeinfo const   *typei , adns_queryflags flags ,
                             struct timeval now ) 
{ 
  vbuf vb_new ;
  int id ;
  adns_status stat ;

  {
  {
#line 136
  stat = adns__mkquery(ads___7, & qu->vb, & id, owner, ol, typei, (qu->answer)->type,
                       flags);
  }
#line 138
  if (stat) {
#line 139
    if ((unsigned int )stat == 202U) {
#line 139
      if ((unsigned int )flags & 1U) {
        {
#line 140
        adns__search_next(ads___7, qu, now);
        }
#line 141
        return;
      } else {
        {
#line 143
        adns__query_fail(qu, stat);
        }
#line 144
        return;
      }
    } else {
      {
#line 143
      adns__query_fail(qu, stat);
      }
#line 144
      return;
    }
  }
  {
#line 148
  vb_new = qu->vb;
#line 149
  adns__vbuf_init(& qu->vb);
#line 150
  query_submit___0(ads___7, qu, typei, & vb_new, id, flags, now);
  }
#line 151
  return;
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static int save_owner___0(adns_query qu , char const   *owner , int ol ) 
{ 
  adns_answer *ans ;
  void *tmp ;

  {
#line 198
  if (! (qu->flags & 4)) {
#line 198
    return (1);
  }
#line 200
  ans = qu->answer;
#line 201
  if (! (! ans->owner)) {
    {
#line 201
    __assert_fail("!ans->owner", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c",
                  201U, "save_owner");
    }
  }
  {
#line 203
  tmp = adns__alloc_preserved(qu, (size_t )(ol + 1));
#line 203
  ans->owner = (char *)tmp;
  }
#line 203
  if (! ans->owner) {
#line 203
    return (0);
  }
  {
#line 205
  memcpy((void */* __restrict  */)ans->owner, (void const   */* __restrict  */)owner,
         (size_t )ol);
#line 206
  *(ans->owner + ol) = (char)0;
  }
#line 207
  return (1);
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void *alloc_common___0(adns_query qu , size_t sz ) 
{ 
  allocnode *an ;
  void *tmp ;

  {
#line 342
  if (! sz) {
#line 342
    return ((void *)qu);
  }
#line 343
  if (! (! qu->final_allocspace)) {
    {
#line 343
    __assert_fail("!qu->final_allocspace", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c",
                  343U, "alloc_common");
    }
  }
  {
#line 344
  tmp = Hmalloc((((((((sizeof(*an) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ) + sz) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ));
#line 344
  an = (allocnode *)tmp;
  }
#line 345
  if (! an) {
#line 345
    return ((void *)0);
  }
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 346
    an->next = (struct allocnode *)0;
#line 346
    an->back = qu->allocations.tail;
#line 346
    if (qu->allocations.tail) {
#line 346
      (qu->allocations.tail)->next = an;
    } else {
#line 346
      qu->allocations.head = an;
    }
#line 346
    qu->allocations.tail = an;
#line 346
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 347
  return ((void *)((byte *)an + (((sizeof(*an) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign )));
}
}
#line 410 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void cancel_children___0(adns_query qu ) 
{ 
  adns_query cqu ;
  adns_query ncqu ;

  {
#line 413
  cqu = qu->children.head;
  {
#line 413
  while (1) {
    while_continue: /* CIL Label */ ;
#line 413
    if (! cqu) {
#line 413
      goto while_break;
    }
    {
#line 414
    ncqu = cqu->siblings.next;
#line 415
    adns_cancel(cqu);
#line 413
    cqu = ncqu;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 417
  return;
}
}
#line 427 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void free_query_allocs___0(adns_query qu ) 
{ 
  allocnode *an ;
  allocnode *ann ;
  allocnode *tmp ;

  {
  {
#line 430
  cancel_children___0(qu);
#line 431
  an = qu->allocations.head;
  }
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    if (! an) {
#line 431
      goto while_break;
    }
    {
#line 431
    ann = an->next;
#line 431
    Hfree((void *)an);
#line 431
    an = ann;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 432
  tmp = (allocnode *)0;
#line 432
  qu->allocations.tail = tmp;
#line 432
  qu->allocations.head = tmp;
#line 433
  adns__vbuf_free(& qu->vb);
#line 434
  adns__vbuf_free(& qu->search_vb);
#line 435
  Hfree((void *)qu->query_dgram);
#line 436
  qu->query_dgram = (byte *)0;
  }
#line 437
  return;
}
}
#line 477 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void makefinal_query___0(adns_query qu ) 
{ 
  adns_answer *ans ;
  int rrn ;
  void *tmp ;

  {
#line 481
  ans = qu->answer;
#line 483
  if (qu->interim_allocd) {
    {
#line 484
    tmp = Hrealloc((void *)qu->answer, (((((((sizeof(*ans) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ) + (unsigned long )qu->interim_allocd) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ));
#line 484
    ans = (adns_answer *)tmp;
    }
#line 486
    if (! ans) {
#line 486
      goto x_nomem;
    }
#line 487
    qu->answer = ans;
  }
  {
#line 490
  qu->final_allocspace = (void *)((byte *)ans + (((sizeof(*ans) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ));
#line 491
  adns__makefinal_str(qu, & ans->cname);
#line 492
  adns__makefinal_str(qu, & ans->owner);
  }
#line 494
  if (ans->nrrs) {
    {
#line 495
    adns__makefinal_block(qu, & ans->rrs.untyped, (size_t )(ans->nrrs * ans->rrsz));
#line 497
    rrn = 0;
    }
    {
#line 497
    while (1) {
      while_continue: /* CIL Label */ ;
#line 497
      if (! (rrn < ans->nrrs)) {
#line 497
        goto while_break;
      }
      {
#line 498
      (*((qu->typei)->makefinal))(qu, (void *)(ans->rrs.bytes + rrn * ans->rrsz));
#line 497
      rrn ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 501
  free_query_allocs___0(qu);
  }
#line 502
  return;
  x_nomem: 
  {
#line 505
  qu->preserved_allocd = 0;
#line 506
  (qu->answer)->cname = (char *)0;
#line 507
  (qu->answer)->owner = (char *)0;
#line 508
  adns__reset_preserved(qu);
#line 510
  (qu->answer)->status = (adns_status )1;
#line 511
  free_query_allocs___0(qu);
  }
#line 512
  return;
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void tcp_close___0(adns_state ads___7 ) 
{ 
  int serv ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 48
  serv = ads___7->tcpserver;
#line 49
  Hclose(ads___7->tcpsocket);
#line 50
  ads___7->tcpsocket = -1;
#line 51
  tmp___0 = 0;
#line 51
  ads___7->tcpsend.used = tmp___0;
#line 51
  tmp = tmp___0;
#line 51
  ads___7->tcprecv_skip = tmp;
#line 51
  ads___7->tcprecv.used = tmp;
  }
#line 52
  return;
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void tcp_connected___0(adns_state ads___7 , struct timeval now ) 
{ 
  adns_query qu ;
  adns_query nqu ;

  {
  {
#line 76
  adns__debug(ads___7, ads___7->tcpserver, (adns_query )0, "TCP connected");
#line 77
  ads___7->tcpstate = (enum adns__tcpstate )2;
#line 78
  qu = ads___7->tcpw.head;
  }
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (qu) {
#line 78
      if (! ((unsigned int )ads___7->tcpstate == 2U)) {
#line 78
        goto while_break;
      }
    } else {
#line 78
      goto while_break;
    }
#line 79
    nqu = qu->next;
#line 80
    if (! ((unsigned int )qu->state == 1U)) {
      {
#line 80
      __assert_fail("qu->state == query_tcpw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c",
                    80U, "tcp_connected");
      }
    }
    {
#line 81
    adns__querysend_tcp(qu, now);
#line 78
    qu = nqu;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void tcp_broken_events___0(adns_state ads___7 ) 
{ 
  adns_query qu ;
  adns_query nqu ;

  {
#line 88
  if (! ((unsigned int )ads___7->tcpstate == 3U)) {
    {
#line 88
    __assert_fail("ads->tcpstate == server_broken", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c",
                  88U, "tcp_broken_events");
    }
  }
#line 89
  qu = ads___7->tcpw.head;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! qu) {
#line 89
      goto while_break;
    }
#line 90
    nqu = qu->next;
#line 91
    if (! ((unsigned int )qu->state == 1U)) {
      {
#line 91
      __assert_fail("qu->state == query_tcpw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c",
                    91U, "tcp_broken_events");
      }
    }
#line 92
    if (qu->retries > ads___7->nservers) {
      {
#line 93
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 93
        if (qu->back) {
#line 93
          (qu->back)->next = qu->next;
        } else {
#line 93
          ads___7->tcpw.head = qu->next;
        }
#line 93
        if (qu->next) {
#line 93
          (qu->next)->back = qu->back;
        } else {
#line 93
          ads___7->tcpw.tail = qu->back;
        }
#line 93
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 94
      adns__query_fail(qu, (adns_status )31);
      }
    }
#line 89
    qu = nqu;
  }
  while_break: /* CIL Label */ ;
  }
#line 97
  ads___7->tcpstate = (enum adns__tcpstate )0;
#line 98
  return;
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void inter_immed___0(struct timeval **tv_io , struct timeval *tvbuf ) 
{ 
  struct timeval *rbuf ;
  __suseconds_t tmp ;

  {
#line 174
  if (! tv_io) {
#line 174
    return;
  }
#line 176
  rbuf = *tv_io;
#line 177
  if (! rbuf) {
#line 177
    rbuf = tvbuf;
#line 177
    *tv_io = rbuf;
  }
#line 179
  tmp = (__suseconds_t )0;
#line 179
  rbuf->tv_usec = tmp;
#line 179
  rbuf->tv_sec = tmp;
#line 180
  return;
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void inter_maxto___0(struct timeval **tv_io , struct timeval *tvbuf , struct timeval maxto ) 
{ 
  struct timeval *rbuf ;
  int tmp ;

  {
#line 186
  if (! tv_io) {
#line 186
    return;
  }
#line 187
  rbuf = *tv_io;
#line 188
  if (! rbuf) {
#line 189
    *tvbuf = maxto;
#line 189
    *tv_io = tvbuf;
  } else {
#line 191
    if (rbuf->tv_sec == maxto.tv_sec) {
#line 191
      tmp = rbuf->tv_usec > maxto.tv_usec;
    } else {
#line 191
      tmp = rbuf->tv_sec > maxto.tv_sec;
    }
#line 191
    if (tmp) {
#line 191
      *rbuf = maxto;
    }
  }
#line 195
  return;
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void inter_maxtoabs___0(struct timeval **tv_io , struct timeval *tvbuf , struct timeval now ,
                               struct timeval maxtime ) 
{ 
  ldiv_t dr ;

  {
#line 204
  if (! tv_io) {
#line 204
    return;
  }
  {
#line 205
  maxtime.tv_sec -= now.tv_sec + 2L;
#line 206
  maxtime.tv_usec -= now.tv_usec - 2000000L;
#line 207
  dr = ldiv(maxtime.tv_usec, 1000000L);
#line 208
  maxtime.tv_sec += dr.quot;
#line 209
  maxtime.tv_usec -= dr.quot * 1000000L;
  }
#line 210
  if (maxtime.tv_sec < 0L) {
#line 210
    maxtime.tv_usec = (__suseconds_t )0;
#line 210
    maxtime.tv_sec = maxtime.tv_usec;
  }
  {
#line 211
  inter_maxto___0(tv_io, tvbuf, maxtime);
  }
#line 212
  return;
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void timeouts_queue___0(adns_state ads___7 , int act , struct timeval **tv_io ,
                               struct timeval *tvbuf , struct timeval now , struct query_queue *queue ) 
{ 
  adns_query qu ;
  adns_query nqu ;
  int tmp ;

  {
#line 219
  qu = queue->head;
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if (! qu) {
#line 219
      goto while_break;
    }
#line 220
    nqu = qu->next;
#line 221
    if (now.tv_sec == qu->timeout.tv_sec) {
#line 221
      tmp = now.tv_usec > qu->timeout.tv_usec;
    } else {
#line 221
      tmp = now.tv_sec > qu->timeout.tv_sec;
    }
#line 221
    if (tmp) {
#line 224
      if (! act) {
        {
#line 224
        inter_immed___0(tv_io, tvbuf);
        }
#line 224
        return;
      }
      {
#line 225
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 225
        if (qu->back) {
#line 225
          (qu->back)->next = qu->next;
        } else {
#line 225
          queue->head = qu->next;
        }
#line 225
        if (qu->next) {
#line 225
          (qu->next)->back = qu->back;
        } else {
#line 225
          queue->tail = qu->back;
        }
#line 225
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 226
      if ((unsigned int )qu->state != 0U) {
        {
#line 227
        adns__query_fail(qu, (adns_status )30);
        }
      } else {
        {
#line 229
        adns__query_send(qu, now);
        }
      }
#line 231
      nqu = queue->head;
    } else {
      {
#line 222
      inter_maxtoabs___0(tv_io, tvbuf, now, qu->timeout);
      }
    }
#line 219
    qu = nqu;
  }
  while_break: /* CIL Label */ ;
  }
#line 234
  return;
}
}
#line 236 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void tcp_events___0(adns_state ads___7 , int act , struct timeval **tv_io ,
                           struct timeval *tvbuf , struct timeval now ) 
{ 
  int tmp ;

  {
  {
#line 239
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 241
    if ((unsigned int )ads___7->tcpstate == 3U) {
#line 241
      goto case_3;
    }
#line 244
    if ((unsigned int )ads___7->tcpstate == 0U) {
#line 244
      goto case_0;
    }
#line 249
    if ((unsigned int )ads___7->tcpstate == 2U) {
#line 249
      goto case_2;
    }
#line 256
    if ((unsigned int )ads___7->tcpstate == 1U) {
#line 256
      goto case_1;
    }
#line 275
    goto switch_default___0;
    case_3: /* CIL Label */ 
#line 242
    if (! act) {
      {
#line 242
      inter_immed___0(tv_io, tvbuf);
      }
#line 242
      return;
    }
    {
#line 243
    tcp_broken_events___0(ads___7);
    }
    case_0: /* CIL Label */ 
#line 245
    if (! ads___7->tcpw.head) {
#line 245
      return;
    }
#line 246
    if (! act) {
      {
#line 246
      inter_immed___0(tv_io, tvbuf);
      }
#line 246
      return;
    }
    {
#line 247
    adns__tcp_tryconnect(ads___7, now);
    }
#line 248
    goto switch_break;
    case_2: /* CIL Label */ 
#line 250
    if (ads___7->tcpw.head) {
#line 250
      return;
    }
#line 251
    if (! ads___7->tcptimeout.tv_sec) {
#line 252
      if (! (! ads___7->tcptimeout.tv_usec)) {
        {
#line 252
        __assert_fail("!ads->tcptimeout.tv_usec", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c",
                      252U, "tcp_events");
        }
      }
      {
#line 253
      ads___7->tcptimeout = now;
#line 254
      timevaladd(& ads___7->tcptimeout, 30000L);
      }
    }
    case_1: /* CIL Label */ 
#line 257
    if (! act) {
      {
#line 258
      inter_maxtoabs___0(tv_io, tvbuf, now, ads___7->tcptimeout);
      }
#line 259
      return;
    } else {
#line 257
      if (now.tv_sec == ads___7->tcptimeout.tv_sec) {
#line 257
        tmp = now.tv_usec > ads___7->tcptimeout.tv_usec;
      } else {
#line 257
        tmp = now.tv_sec > ads___7->tcptimeout.tv_sec;
      }
#line 257
      if (! tmp) {
        {
#line 258
        inter_maxtoabs___0(tv_io, tvbuf, now, ads___7->tcptimeout);
        }
#line 259
        return;
      }
    }
    {
#line 263
    if ((unsigned int )ads___7->tcpstate == 1U) {
#line 263
      goto case_1___0;
    }
#line 266
    if ((unsigned int )ads___7->tcpstate == 2U) {
#line 266
      goto case_2___0;
    }
#line 270
    goto switch_default;
    case_1___0: /* CIL Label */ 
    {
#line 264
    adns__tcp_broken(ads___7, "unable to make connection", "timed out");
    }
#line 265
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 267
    tcp_close___0(ads___7);
#line 268
    ads___7->tcpstate = (enum adns__tcpstate )0;
    }
#line 269
    return;
    switch_default: /* CIL Label */ 
    {
#line 271
    abort();
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 274
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
#line 276
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 279
  return;
}
}
#line 516 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void fd_event___0(adns_state ads___7 , int fd , int revent , int pollflag ,
                         int maxfd , fd_set const   *fds , int (*func)(adns_state  ,
                                                                       int fd , struct timeval  const  *now ) ,
                         struct timeval now , int *r_r ) 
{ 
  int r ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 524
  if (! (revent & pollflag)) {
#line 524
    return;
  }
#line 525
  if (fds) {
#line 525
    if (fd < maxfd) {
#line 525
      if (! ((fds->__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
#line 525
        return;
      }
    } else {
#line 525
      return;
    }
  }
  {
#line 526
  r = (*func)(ads___7, fd, (struct timeval  const  *)(& now));
  }
#line 527
  if (r) {
#line 528
    if (r_r) {
#line 529
      *r_r = r;
    } else {
      {
#line 531
      tmp = __errno_location();
#line 531
      tmp___0 = strerror(*tmp);
#line 531
      adns__diag(ads___7, -1, (adns_query )0, "process fd failed after select: %s",
                 tmp___0);
#line 533
      adns_globalsystemfailure(ads___7);
      }
    }
  }
#line 536
  return;
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfig___1(adns_state ads___7 , char const   *filename , int warnmissing ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void addserver___1(adns_state ads___7 , struct in_addr addr ) 
{ 
  int i ;
  struct server *ss ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 48
  i = 0;
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (i < ads___7->nservers)) {
#line 48
      goto while_break;
    }
#line 49
    if (ads___7->servers[i].addr.s_addr == addr.s_addr) {
      {
#line 50
      tmp = inet_ntoa(addr);
#line 50
      adns__debug(ads___7, -1, (adns_query )0, "duplicate nameserver %s ignored",
                  tmp);
      }
#line 51
      return;
    }
#line 48
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  if (ads___7->nservers >= 5) {
    {
#line 56
    tmp___0 = inet_ntoa(addr);
#line 56
    adns__diag(ads___7, -1, (adns_query )0, "too many nameservers, ignoring %s", tmp___0);
    }
#line 57
    return;
  }
#line 60
  ss = ads___7->servers + ads___7->nservers;
#line 61
  ss->addr = addr;
#line 62
  (ads___7->nservers) ++;
#line 63
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void freesearchlist___1(adns_state ads___7 ) 
{ 


  {
#line 66
  if (ads___7->nsearchlist) {
    {
#line 66
    Hfree((void *)*(ads___7->searchlist));
    }
  }
  {
#line 67
  Hfree((void *)ads___7->searchlist);
  }
#line 68
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void saveerr___1(adns_state ads___7 , int en ) 
{ 


  {
#line 71
  if (! ads___7->configerrno) {
#line 71
    ads___7->configerrno = en;
  }
#line 72
  return;
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void configparseerr___1(adns_state ads___7 , char const   *fn , int lno , char const   *fmt 
                               , ...) 
{ 
  va_list al ;

  {
  {
#line 78
  saveerr___1(ads___7, 22);
  }
#line 79
  if (! ads___7->logfn) {
#line 79
    return;
  } else
#line 79
  if ((unsigned int )ads___7->iflags & 2U) {
#line 79
    return;
  }
#line 81
  if (lno == -1) {
    {
#line 81
    adns__lprintf(ads___7, "adns: %s: ", fn);
    }
  } else {
    {
#line 82
    adns__lprintf(ads___7, "adns: %s:%d: ", fn, lno);
    }
  }
  {
#line 83
  __builtin_va_start(al, fmt);
#line 84
  adns__vlprintf(ads___7, fmt, al);
#line 85
  __builtin_va_end(al);
#line 86
  adns__lprintf(ads___7, "\n");
  }
#line 87
  return;
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int nextword___1(char const   **bufp_io , char const   **word_r , int *l_r ) 
{ 
  char const   *p ;
  char const   *q ;
  int tmp ;
  int tmp___0 ;

  {
#line 92
  p = *bufp_io;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 93
    tmp = ctype_whitespace((int )*p);
    }
#line 93
    if (! tmp) {
#line 93
      goto while_break;
    }
#line 93
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  if (! *p) {
#line 94
    return (0);
  }
#line 96
  q = p;
  {
#line 97
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 97
    if (*q) {
      {
#line 97
      tmp___0 = ctype_whitespace((int )*q);
      }
#line 97
      if (tmp___0) {
#line 97
        goto while_break___0;
      }
    } else {
#line 97
      goto while_break___0;
    }
#line 97
    q ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 99
  *l_r = (int )(q - p);
#line 100
  *word_r = p;
#line 101
  *bufp_io = q;
#line 103
  return (1);
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_nameserver___1(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  struct in_addr ia ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 110
  tmp = inet_aton(buf___17, & ia);
  }
#line 110
  if (! tmp) {
    {
#line 111
    configparseerr___1(ads___7, fn, lno, "invalid nameserver address `%s\'", buf___17);
    }
#line 112
    return;
  }
  {
#line 114
  tmp___0 = inet_ntoa(ia);
#line 114
  adns__debug(ads___7, -1, (adns_query )0, "using nameserver %s", tmp___0);
#line 115
  addserver___1(ads___7, ia);
  }
#line 116
  return;
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_search___1(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  char const   *bufp ;
  char const   *word ;
  char *newchars ;
  char **newptrs ;
  char **pp ;
  int count ;
  int tl ;
  int l ;
  int tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char **tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
#line 124
  if (! buf___17) {
#line 124
    return;
  }
#line 126
  bufp = buf___17;
#line 127
  count = 0;
#line 128
  tl = 0;
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 129
    tmp = nextword___1(& bufp, & word, & l);
    }
#line 129
    if (! tmp) {
#line 129
      goto while_break;
    }
#line 129
    count ++;
#line 129
    tl += l + 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 131
  tmp___0 = Hmalloc(sizeof(char *) * (unsigned long )count);
#line 131
  newptrs = (char **)tmp___0;
  }
#line 132
  if (! newptrs) {
    {
#line 132
    tmp___1 = __errno_location();
#line 132
    saveerr___1(ads___7, *tmp___1);
    }
#line 132
    return;
  }
  {
#line 134
  tmp___2 = Hmalloc((size_t )tl);
#line 134
  newchars = (char *)tmp___2;
  }
#line 135
  if (! newchars) {
    {
#line 135
    tmp___3 = __errno_location();
#line 135
    saveerr___1(ads___7, *tmp___3);
#line 135
    Hfree((void *)newptrs);
    }
#line 135
    return;
  }
#line 137
  bufp = buf___17;
#line 138
  pp = newptrs;
  {
#line 139
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 139
    tmp___6 = nextword___1(& bufp, & word, & l);
    }
#line 139
    if (! tmp___6) {
#line 139
      goto while_break___0;
    }
    {
#line 140
    tmp___4 = pp;
#line 140
    pp ++;
#line 140
    *tmp___4 = newchars;
#line 141
    memcpy((void */* __restrict  */)newchars, (void const   */* __restrict  */)word,
           (size_t )l);
#line 142
    newchars += l;
#line 143
    tmp___5 = newchars;
#line 143
    newchars ++;
#line 143
    *tmp___5 = (char)0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 146
  freesearchlist___1(ads___7);
#line 147
  ads___7->nsearchlist = count;
#line 148
  ads___7->searchlist = newptrs;
  }
#line 149
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_sortlist___1(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  char const   *word ;
  char tbuf[200] ;
  char *slash ;
  char *ep ;
  struct in_addr base ;
  struct in_addr mask ;
  int l ;
  unsigned long initial ;
  unsigned long baselocal ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  uint32_t tmp___3 ;
  int tmp___4 ;

  {
#line 159
  if (! buf___17) {
#line 159
    return;
  }
#line 161
  ads___7->nsortlist = 0;
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 162
    tmp___4 = nextword___1(& buf___17, & word, & l);
    }
#line 162
    if (! tmp___4) {
#line 162
      goto while_break;
    }
#line 163
    if (ads___7->nsortlist >= 15) {
      {
#line 164
      adns__diag(ads___7, -1, (adns_query )0, "too many sortlist entries, ignoring %.*s onwards",
                 l, word);
      }
#line 166
      return;
    }
#line 169
    if ((unsigned long )l >= sizeof(tbuf)) {
      {
#line 170
      configparseerr___1(ads___7, fn, lno, "sortlist entry `%.*s\' too long", l, word);
      }
#line 171
      goto while_continue;
    }
    {
#line 174
    memcpy((void */* __restrict  */)(tbuf), (void const   */* __restrict  */)word,
           (size_t )l);
#line 174
    tbuf[l] = (char)0;
#line 175
    slash = strchr((char const   *)(tbuf), '/');
    }
#line 176
    if (slash) {
#line 176
      tmp = slash;
#line 176
      slash ++;
#line 176
      *tmp = (char)0;
    }
    {
#line 178
    tmp___0 = inet_aton((char const   *)(tbuf), & base);
    }
#line 178
    if (! tmp___0) {
      {
#line 179
      configparseerr___1(ads___7, fn, lno, "invalid address `%s\' in sortlist", tbuf);
      }
#line 180
      goto while_continue;
    }
#line 183
    if (slash) {
      {
#line 184
      tmp___2 = strchr((char const   *)slash, '.');
      }
#line 184
      if (tmp___2) {
        {
#line 185
        tmp___1 = inet_aton((char const   *)slash, & mask);
        }
#line 185
        if (! tmp___1) {
          {
#line 186
          configparseerr___1(ads___7, fn, lno, "invalid mask `%s\' in sortlist", slash);
          }
#line 187
          goto while_continue;
        }
#line 189
        if (base.s_addr & ~ mask.s_addr) {
          {
#line 190
          configparseerr___1(ads___7, fn, lno, "mask `%s\' in sortlist overlaps address `%s\'",
                             slash, tbuf);
          }
#line 192
          goto while_continue;
        }
      } else {
        {
#line 195
        initial = strtoul((char const   */* __restrict  */)slash, (char **/* __restrict  */)(& ep),
                          10);
        }
#line 196
        if (*ep) {
          {
#line 197
          configparseerr___1(ads___7, fn, lno, "mask length `%s\' invalid", slash);
          }
#line 198
          goto while_continue;
        } else
#line 196
        if (initial > 32UL) {
          {
#line 197
          configparseerr___1(ads___7, fn, lno, "mask length `%s\' invalid", slash);
          }
#line 198
          goto while_continue;
        }
        {
#line 200
        mask.s_addr = htonl((uint32_t )(4294967295UL << (32UL - initial)));
        }
      }
    } else {
      {
#line 203
      tmp___3 = ntohl(base.s_addr);
#line 203
      baselocal = (unsigned long )tmp___3;
      }
#line 204
      if ((unsigned long )(! baselocal) & 2147483648UL) {
        {
#line 205
        mask.s_addr = htonl((uint32_t )4278190080UL);
        }
      } else
#line 206
      if ((baselocal & 3221225472UL) == 2147483648UL) {
        {
#line 207
        mask.s_addr = htonl((uint32_t )4294901760UL);
        }
      } else
#line 208
      if ((baselocal & 4026531840UL) == 3758096384UL) {
        {
#line 209
        mask.s_addr = htonl((uint32_t )4278190080UL);
        }
      } else {
        {
#line 211
        configparseerr___1(ads___7, fn, lno, "network address `%s\' in sortlist is not in classed ranges, must specify mask explicitly",
                           tbuf);
        }
#line 214
        goto while_continue;
      }
    }
#line 218
    ads___7->sortlist[ads___7->nsortlist].base = base;
#line 219
    ads___7->sortlist[ads___7->nsortlist].mask = mask;
#line 220
    (ads___7->nsortlist) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  return;
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_options___1(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  char const   *word ;
  char *ep ;
  unsigned long v ;
  int l ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 231
  if (! buf___17) {
#line 231
    return;
  }
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 233
    tmp___5 = nextword___1(& buf___17, & word, & l);
    }
#line 233
    if (! tmp___5) {
#line 233
      goto while_break;
    }
#line 234
    if (l == 5) {
      {
#line 234
      tmp = memcmp((void const   *)word, (void const   *)"debug", (size_t )5);
      }
#line 234
      if (! tmp) {
#line 235
        ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 8U);
#line 236
        goto while_continue;
      }
    }
#line 238
    if (l >= 6) {
      {
#line 238
      tmp___0 = memcmp((void const   *)word, (void const   *)"ndots:", (size_t )6);
      }
#line 238
      if (! tmp___0) {
        {
#line 239
        v = strtoul((char const   */* __restrict  */)(word + 6), (char **/* __restrict  */)(& ep),
                    10);
        }
#line 240
        if (l == 6) {
          {
#line 241
          configparseerr___1(ads___7, fn, lno, "option `%.*s\' malformed or has bad value",
                             l, word);
          }
#line 243
          goto while_continue;
        } else
#line 240
        if ((unsigned long )ep != (unsigned long )(word + l)) {
          {
#line 241
          configparseerr___1(ads___7, fn, lno, "option `%.*s\' malformed or has bad value",
                             l, word);
          }
#line 243
          goto while_continue;
        } else
#line 240
        if (v > 2147483647UL) {
          {
#line 241
          configparseerr___1(ads___7, fn, lno, "option `%.*s\' malformed or has bad value",
                             l, word);
          }
#line 243
          goto while_continue;
        }
#line 245
        ads___7->searchndots = (int )v;
#line 246
        goto while_continue;
      }
    }
#line 248
    if (l >= 12) {
      {
#line 248
      tmp___4 = memcmp((void const   *)word, (void const   *)"adns_checkc:", (size_t )12);
      }
#line 248
      if (! tmp___4) {
        {
#line 249
        tmp___3 = strcmp(word + 12, "none");
        }
#line 249
        if (tmp___3) {
          {
#line 252
          tmp___2 = strcmp(word + 12, "entex");
          }
#line 252
          if (tmp___2) {
            {
#line 255
            tmp___1 = strcmp(word + 12, "freq");
            }
#line 255
            if (tmp___1) {
              {
#line 258
              configparseerr___1(ads___7, fn, lno, "option adns_checkc has bad value `%s\' (must be none, entex or freq",
                                 word + 12);
              }
            } else {
#line 256
              ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 768U);
            }
          } else {
#line 253
            ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags & 4294966527U);
#line 254
            ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 256U);
          }
        } else {
#line 250
          ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags & 4294966527U);
#line 251
          ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 256U);
        }
#line 261
        goto while_continue;
      }
    }
    {
#line 263
    adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown option `%.*s\'", fn, lno,
               l, word);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 265
  return;
}
}
#line 267 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_clearnss___1(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 


  {
#line 269
  ads___7->nservers = 0;
#line 270
  return;
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_include___1(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 


  {
#line 274
  if (! *buf___17) {
    {
#line 275
    configparseerr___1(ads___7, fn, lno, "`include\' directive with no filename");
    }
#line 276
    return;
  }
  {
#line 278
  readconfig___1(ads___7, buf___17, 1);
  }
#line 279
  return;
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_lookup___1(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  int found_bind ;
  char const   *word ;
  int l ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 283
  found_bind = 0;
#line 287
  if (! *buf___17) {
    {
#line 288
    configparseerr___1(ads___7, fn, lno, "`lookup\' directive with no databases");
    }
#line 289
    return;
  }
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 292
    tmp___2 = nextword___1(& buf___17, & word, & l);
    }
#line 292
    if (! tmp___2) {
#line 292
      goto while_break;
    }
#line 293
    if (l == 4) {
      {
#line 293
      tmp___1 = memcmp((void const   *)word, (void const   *)"bind", (size_t )4);
      }
#line 293
      if (tmp___1) {
#line 293
        goto _L___0;
      } else {
#line 294
        found_bind = 1;
      }
    } else
    _L___0: /* CIL Label */ 
#line 295
    if (l == 4) {
      {
#line 295
      tmp___0 = memcmp((void const   *)word, (void const   *)"file", (size_t )4);
      }
#line 295
      if (tmp___0) {
#line 295
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 297
    if (l == 2) {
      {
#line 297
      tmp = memcmp((void const   *)word, (void const   *)"yp", (size_t )2);
      }
#line 297
      if (tmp) {
        {
#line 301
        adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown `lookup\' database `%.*s\'",
                   fn, lno, l, word);
#line 303
        found_bind = -1;
        }
      } else {
        {
#line 298
        adns__diag(ads___7, -1, (adns_query )0, "%s:%d: yp lookups not supported by adns",
                   fn, lno);
#line 299
        found_bind = -1;
        }
      }
    } else {
      {
#line 301
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown `lookup\' database `%.*s\'",
                 fn, lno, l, word);
#line 303
      found_bind = -1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 306
  if (! found_bind) {
    {
#line 307
    adns__diag(ads___7, -1, (adns_query )0, "%s:%d: `lookup\' specified, but not `bind\'",
               fn, lno);
    }
  }
#line 308
  return;
}
}
#line 310 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static struct configcommandinfo  const  configcommandinfos___1[9]  = 
#line 310
  {      {"nameserver", & ccf_nameserver___1}, 
        {"domain", & ccf_search___1}, 
        {"search", & ccf_search___1}, 
        {"sortlist", & ccf_sortlist___1}, 
        {"options", & ccf_options___1}, 
        {"clearnameservers", & ccf_clearnss___1}, 
        {"include", & ccf_include___1}, 
        {"lookup", & ccf_lookup___1}, 
        {(char const   *)0, (void (*)(adns_state ads , char const   *fn , int lno , char const   *buf ))0}};
#line 330 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int gl_file___1(adns_state ads___7 , getline_ctx *src_io , char const   *filename ,
                       int lno , char *buf___17 , int buflen ) 
{ 
  FILE *file ;
  int c ;
  int i ;
  char *p ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 332
  file = src_io->file;
#line 336
  p = buf___17;
#line 337
  buflen --;
#line 338
  i = 0;
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (i == buflen) {
      {
#line 342
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: line too long, ignored", filename,
                 lno);
      }
#line 343
      goto x_badline;
    }
    {
#line 345
    c = _IO_getc(file);
    }
#line 346
    if (! c) {
      {
#line 347
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: line contains nul, ignored",
                 filename, lno);
      }
#line 348
      goto x_badline;
    } else
#line 349
    if (c == 10) {
#line 350
      goto while_break;
    } else
#line 351
    if (c == -1) {
      {
#line 352
      tmp___2 = ferror(file);
      }
#line 352
      if (tmp___2) {
        {
#line 353
        tmp = __errno_location();
#line 353
        saveerr___1(ads___7, *tmp);
#line 354
        tmp___0 = __errno_location();
#line 354
        tmp___1 = strerror(*tmp___0);
#line 354
        adns__diag(ads___7, -1, (adns_query )0, "%s:%d: read error: %s", filename,
                   lno, tmp___1);
        }
#line 356
        return (-1);
      }
#line 358
      if (! i) {
#line 358
        return (-1);
      }
#line 359
      goto while_break;
    } else {
#line 361
      tmp___3 = p;
#line 361
      p ++;
#line 361
      *tmp___3 = (char )c;
#line 362
      i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 366
  tmp___4 = p;
#line 366
  p ++;
#line 366
  *tmp___4 = (char)0;
#line 367
  return (i);
  x_badline: 
  {
#line 370
  saveerr___1(ads___7, 22);
  }
  {
#line 371
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 371
    c = _IO_getc(file);
    }
#line 371
    if (c != -1) {
#line 371
      if (! (c != 10)) {
#line 371
        goto while_break___0;
      }
    } else {
#line 371
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 372
  return (-2);
}
}
#line 375 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int gl_text___1(adns_state ads___7 , getline_ctx *src_io , char const   *filename ,
                       int lno , char *buf___17 , int buflen ) 
{ 
  char const   *cp ;
  int l ;
  size_t tmp ;

  {
#line 377
  cp = src_io->text;
#line 380
  if (! cp) {
#line 380
    return (-1);
  } else
#line 380
  if (! *cp) {
#line 380
    return (-1);
  }
#line 382
  if ((int const   )*cp == 59) {
#line 382
    cp ++;
  } else
#line 382
  if ((int const   )*cp == 10) {
#line 382
    cp ++;
  }
  {
#line 383
  tmp = strcspn(cp, ";\n");
#line 383
  l = (int )tmp;
#line 384
  src_io->text = cp + l;
  }
#line 386
  if (l >= buflen) {
    {
#line 387
    adns__diag(ads___7, -1, (adns_query )0, "%s:%d: line too long, ignored", filename,
               lno);
#line 388
    saveerr___1(ads___7, 22);
    }
#line 389
    return (-2);
  }
  {
#line 392
  memcpy((void */* __restrict  */)buf___17, (void const   */* __restrict  */)cp, (size_t )l);
#line 393
  *(buf___17 + l) = (char)0;
  }
#line 394
  return (l);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfiggeneric___1(adns_state ads___7 , char const   *filename , int (*getline___0)(adns_state ads ,
                                                                                                   getline_ctx * ,
                                                                                                   char const   *filename ,
                                                                                                   int lno ,
                                                                                                   char *buf ,
                                                                                                   int buflen ) ,
                                  getline_ctx gl_ctx ) 
{ 
  char linebuf[2000] ;
  char *p ;
  char *q ;
  int lno ;
  int l ;
  int dirl ;
  struct configcommandinfo  const  *ccip ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 410
  lno = 1;
  {
#line 410
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 410
    l = (*getline___0)(ads___7, & gl_ctx, filename, lno, linebuf, (int )sizeof(linebuf));
    }
#line 410
    if (! (l != -1)) {
#line 410
      goto while_break;
    }
#line 413
    if (l == -2) {
#line 413
      goto __Cont;
    }
    {
#line 414
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 414
      if (l > 0) {
        {
#line 414
        tmp = ctype_whitespace((int )linebuf[l - 1]);
        }
#line 414
        if (! tmp) {
#line 414
          goto while_break___0;
        }
      } else {
#line 414
        goto while_break___0;
      }
#line 414
      l --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 415
    linebuf[l] = (char)0;
#line 416
    p = linebuf;
    {
#line 417
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 417
      tmp___0 = ctype_whitespace((int )*p);
      }
#line 417
      if (! tmp___0) {
#line 417
        goto while_break___1;
      }
#line 417
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 418
    if ((int )*p == 35) {
#line 418
      goto __Cont;
    } else
#line 418
    if ((int )*p == 59) {
#line 418
      goto __Cont;
    } else
#line 418
    if (! *p) {
#line 418
      goto __Cont;
    }
#line 419
    q = p;
    {
#line 420
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 420
      if (*q) {
        {
#line 420
        tmp___1 = ctype_whitespace((int )*q);
        }
#line 420
        if (tmp___1) {
#line 420
          goto while_break___2;
        }
      } else {
#line 420
        goto while_break___2;
      }
#line 420
      q ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 421
    dirl = (int )(q - p);
#line 422
    ccip = configcommandinfos___1;
    {
#line 422
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 422
      if (ccip->name) {
        {
#line 422
        tmp___2 = strlen((char const   *)ccip->name);
        }
#line 422
        if (tmp___2 == (size_t )dirl) {
          {
#line 422
          tmp___3 = memcmp((void const   *)ccip->name, (void const   *)p, (size_t )(q - p));
          }
#line 422
          if (! tmp___3) {
#line 422
            goto while_break___3;
          }
        }
      } else {
#line 422
        goto while_break___3;
      }
#line 422
      ccip ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 426
    if (! ccip->name) {
      {
#line 427
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown configuration directive `%.*s\'",
                 filename, lno, (int )(q - p), p);
      }
#line 429
      goto __Cont;
    }
    {
#line 431
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 431
      tmp___4 = ctype_whitespace((int )*q);
      }
#line 431
      if (! tmp___4) {
#line 431
        goto while_break___4;
      }
#line 431
      q ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 432
    (*(ccip->fn))(ads___7, filename, lno, (char const   *)q);
    }
    __Cont: /* CIL Label */ 
#line 410
    lno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 434
  return;
}
}
#line 436 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static char const   *instrum_getenv___1(adns_state ads___7 , char const   *envvar ) 
{ 
  char const   *value ;
  char *tmp ;

  {
  {
#line 439
  tmp = getenv(envvar);
#line 439
  value = (char const   *)tmp;
  }
#line 440
  if (! value) {
    {
#line 440
    adns__debug(ads___7, -1, (adns_query )0, "environment variable %s not set", envvar);
    }
  } else {
    {
#line 441
    adns__debug(ads___7, -1, (adns_query )0, "environment variable %s set to `%s\'",
                envvar, value);
    }
  }
#line 443
  return (value);
}
}
#line 446 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfig___1(adns_state ads___7 , char const   *filename , int warnmissing ) 
{ 
  getline_ctx gl_ctx ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 449
  gl_ctx.file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 450
  if (! gl_ctx.file) {
    {
#line 451
    tmp = __errno_location();
    }
#line 451
    if (*tmp == 2) {
#line 452
      if (warnmissing) {
        {
#line 453
        adns__debug(ads___7, -1, (adns_query )0, "configuration file `%s\' does not exist",
                    filename);
        }
      }
#line 455
      return;
    }
    {
#line 457
    tmp___0 = __errno_location();
#line 457
    saveerr___1(ads___7, *tmp___0);
#line 458
    tmp___1 = __errno_location();
#line 458
    tmp___2 = strerror(*tmp___1);
#line 458
    adns__diag(ads___7, -1, (adns_query )0, "cannot open configuration file `%s\': %s",
               filename, tmp___2);
    }
#line 460
    return;
  }
  {
#line 463
  readconfiggeneric___1(ads___7, filename, & gl_file___1, gl_ctx);
#line 465
  fclose(gl_ctx.file);
  }
#line 466
  return;
}
}
#line 468 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfigtext___1(adns_state ads___7 , char const   *text , char const   *showname ) 
{ 
  getline_ctx gl_ctx ;

  {
  {
#line 472
  gl_ctx.text = text;
#line 473
  readconfiggeneric___1(ads___7, showname, & gl_text___1, gl_ctx);
  }
#line 474
  return;
}
}
#line 476 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfigenv___1(adns_state ads___7 , char const   *envvar ) 
{ 
  char const   *filename ;

  {
#line 479
  if ((unsigned int )ads___7->iflags & 1U) {
    {
#line 480
    adns__debug(ads___7, -1, (adns_query )0, "not checking environment variable `%s\'",
                envvar);
    }
#line 481
    return;
  }
  {
#line 483
  filename = instrum_getenv___1(ads___7, envvar);
  }
#line 484
  if (filename) {
    {
#line 484
    readconfig___1(ads___7, filename, 1);
    }
  }
#line 485
  return;
}
}
#line 487 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfigenvtext___1(adns_state ads___7 , char const   *envvar ) 
{ 
  char const   *textdata ;

  {
#line 490
  if ((unsigned int )ads___7->iflags & 1U) {
    {
#line 491
    adns__debug(ads___7, -1, (adns_query )0, "not checking environment variable `%s\'",
                envvar);
    }
#line 492
    return;
  }
  {
#line 494
  textdata = instrum_getenv___1(ads___7, envvar);
  }
#line 495
  if (textdata) {
    {
#line 495
    readconfigtext___1(ads___7, textdata, envvar);
    }
  }
#line 496
  return;
}
}
#line 508 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int init_begin___1(adns_state *ads_r , adns_initflags flags , adns_logcallbackfn *logfn ,
                          void *logfndata ) 
{ 
  adns_state ads___7 ;
  pid_t pid ;
  void *tmp ;
  int *tmp___0 ;
  adns_query tmp___1 ;
  adns_query tmp___2 ;
  adns_query tmp___3 ;
  adns_query tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __suseconds_t tmp___9 ;

  {
  {
#line 513
  tmp = Hmalloc(sizeof(*ads___7));
#line 513
  ads___7 = (adns_state )tmp;
  }
#line 513
  if (! ads___7) {
    {
#line 513
    tmp___0 = __errno_location();
    }
#line 513
    return (*tmp___0);
  }
  {
#line 515
  ads___7->iflags = flags;
#line 516
  ads___7->logfn = logfn;
#line 517
  ads___7->logfndata = logfndata;
#line 518
  ads___7->configerrno = 0;
#line 519
  tmp___1 = (adns_query )0;
#line 519
  ads___7->udpw.tail = tmp___1;
#line 519
  ads___7->udpw.head = tmp___1;
#line 520
  tmp___2 = (adns_query )0;
#line 520
  ads___7->tcpw.tail = tmp___2;
#line 520
  ads___7->tcpw.head = tmp___2;
#line 521
  tmp___3 = (adns_query )0;
#line 521
  ads___7->childw.tail = tmp___3;
#line 521
  ads___7->childw.head = tmp___3;
#line 522
  tmp___4 = (adns_query )0;
#line 522
  ads___7->output.tail = tmp___4;
#line 522
  ads___7->output.head = tmp___4;
#line 523
  ads___7->forallnext = (adns_query )0;
#line 524
  ads___7->nextid = 12575;
#line 525
  tmp___5 = -1;
#line 525
  ads___7->tcpsocket = tmp___5;
#line 525
  ads___7->udpsocket = tmp___5;
#line 526
  adns__vbuf_init(& ads___7->tcpsend);
#line 527
  adns__vbuf_init(& ads___7->tcprecv);
#line 528
  ads___7->tcprecv_skip = 0;
#line 529
  tmp___8 = 0;
#line 529
  ads___7->tcpserver = tmp___8;
#line 529
  tmp___7 = tmp___8;
#line 529
  ads___7->nsearchlist = tmp___7;
#line 529
  tmp___6 = tmp___7;
#line 529
  ads___7->nsortlist = tmp___6;
#line 529
  ads___7->nservers = tmp___6;
#line 530
  ads___7->searchndots = 1;
#line 531
  ads___7->tcpstate = (enum adns__tcpstate )0;
#line 532
  tmp___9 = (__suseconds_t )0;
#line 532
  ads___7->tcptimeout.tv_usec = tmp___9;
#line 532
  ads___7->tcptimeout.tv_sec = tmp___9;
#line 533
  ads___7->searchlist = (char **)0;
#line 535
  pid = Hgetpid();
#line 536
  ads___7->rand48xsubi[0] = (unsigned short )pid;
#line 537
  ads___7->rand48xsubi[1] = (unsigned short )((unsigned long )pid >> 16);
#line 538
  ads___7->rand48xsubi[2] = (unsigned short )((unsigned long )pid ^ ((unsigned long )pid >> 16));
#line 540
  *ads_r = ads___7;
  }
#line 541
  return (0);
}
}
#line 544 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int init_finish___1(adns_state ads___7 ) 
{ 
  struct in_addr ia ;
  struct protoent *proto ;
  int r ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 549
  if (! ads___7->nservers) {
#line 550
    if (ads___7->logfn) {
#line 550
      if ((unsigned int )ads___7->iflags & 8U) {
        {
#line 551
        adns__lprintf(ads___7, "adns: no nameservers, using localhost\n");
        }
      }
    }
    {
#line 552
    ia.s_addr = htonl((in_addr_t )2130706433);
#line 553
    addserver___1(ads___7, ia);
    }
  }
  {
#line 556
  proto = getprotobyname("udp");
  }
#line 556
  if (! proto) {
#line 556
    r = 92;
#line 556
    goto x_free;
  }
  {
#line 557
  ads___7->udpsocket = Hsocket(2, 2, proto->p_proto);
  }
#line 558
  if (ads___7->udpsocket < 0) {
    {
#line 558
    tmp = __errno_location();
#line 558
    r = *tmp;
    }
#line 558
    goto x_free;
  }
  {
#line 560
  r = adns__setnonblock(ads___7, ads___7->udpsocket);
  }
#line 561
  if (r) {
    {
#line 561
    tmp___0 = __errno_location();
#line 561
    r = *tmp___0;
    }
#line 561
    goto x_closeudp;
  }
#line 563
  return (0);
  x_closeudp: 
  {
#line 566
  Hclose(ads___7->udpsocket);
  }
  x_free: 
  {
#line 568
  Hfree((void *)ads___7);
  }
#line 569
  return (r);
}
}
#line 572 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void init_abort___1(adns_state ads___7 ) 
{ 


  {
#line 573
  if (ads___7->nsearchlist) {
    {
#line 574
    Hfree((void *)*(ads___7->searchlist + 0));
#line 575
    Hfree((void *)ads___7->searchlist);
    }
  }
  {
#line 577
  Hfree((void *)ads___7);
  }
#line 578
  return;
}
}
#line 580 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void logfn_file___1(adns_state ads___7 , void *logfndata , char const   *fmt ,
                           va_list al ) 
{ 


  {
  {
#line 582
  vfprintf((FILE */* __restrict  */)logfndata, (char const   */* __restrict  */)fmt,
           al);
  }
#line 583
  return;
}
}
#line 585 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int init_files___1(adns_state *ads_r , adns_initflags flags , adns_logcallbackfn *logfn ,
                          void *logfndata ) 
{ 
  adns_state ads___7 ;
  char const   *res_options ;
  char const   *adns_res_options ;
  int r ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 591
  r = init_begin___1(& ads___7, flags, logfn, logfndata);
  }
#line 592
  if (r) {
#line 592
    return (r);
  }
  {
#line 594
  res_options = instrum_getenv___1(ads___7, "RES_OPTIONS");
#line 595
  adns_res_options = instrum_getenv___1(ads___7, "ADNS_RES_OPTIONS");
#line 596
  ccf_options___1(ads___7, "RES_OPTIONS", -1, res_options);
#line 597
  ccf_options___1(ads___7, "ADNS_RES_OPTIONS", -1, adns_res_options);
#line 599
  readconfig___1(ads___7, "/etc/resolv.conf", 1);
#line 600
  readconfig___1(ads___7, "/etc/resolv-adns.conf", 0);
#line 601
  readconfigenv___1(ads___7, "RES_CONF");
#line 602
  readconfigenv___1(ads___7, "ADNS_RES_CONF");
#line 604
  readconfigenvtext___1(ads___7, "RES_CONF_TEXT");
#line 605
  readconfigenvtext___1(ads___7, "ADNS_RES_CONF_TEXT");
#line 607
  ccf_options___1(ads___7, "RES_OPTIONS", -1, res_options);
#line 608
  ccf_options___1(ads___7, "ADNS_RES_OPTIONS", -1, adns_res_options);
#line 610
  tmp = instrum_getenv___1(ads___7, "LOCALDOMAIN");
#line 610
  ccf_search___1(ads___7, "LOCALDOMAIN", -1, tmp);
#line 611
  tmp___0 = instrum_getenv___1(ads___7, "ADNS_LOCALDOMAIN");
#line 611
  ccf_search___1(ads___7, "ADNS_LOCALDOMAIN", -1, tmp___0);
  }
#line 613
  if (ads___7->configerrno) {
#line 613
    if (ads___7->configerrno != 22) {
      {
#line 614
      r = ads___7->configerrno;
#line 615
      init_abort___1(ads___7);
      }
#line 616
      return (r);
    }
  }
  {
#line 619
  r = init_finish___1(ads___7);
  }
#line 620
  if (r) {
#line 620
    return (r);
  }
  {
#line 622
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
#line 623
  *ads_r = ads___7;
  }
#line 624
  return (0);
}
}
#line 631 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int init_strcfg___1(adns_state *ads_r , adns_initflags flags , adns_logcallbackfn *logfn ,
                           void *logfndata , char const   *configtext ) 
{ 
  adns_state ads___7 ;
  int r ;

  {
  {
#line 637
  r = init_begin___1(& ads___7, flags, logfn, logfndata);
  }
#line 638
  if (r) {
#line 638
    return (r);
  }
  {
#line 640
  readconfigtext___1(ads___7, configtext, "<supplied configuration text>");
  }
#line 641
  if (ads___7->configerrno) {
    {
#line 642
    r = ads___7->configerrno;
#line 643
    init_abort___1(ads___7);
    }
#line 644
    return (r);
  }
  {
#line 647
  r = init_finish___1(ads___7);
  }
#line 647
  if (r) {
#line 647
    return (r);
  }
  {
#line 648
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
#line 649
  *ads_r = ads___7;
  }
#line 650
  return (0);
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
static vbuf vbw___1  ;
#line 175 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
static void Tvbpollevents___1(int events ) 
{ 
  char const   *delim ;

  {
#line 176
  delim = "";
#line 177
  events &= 7;
#line 178
  if (! events) {
    {
#line 178
    Tvba("0");
    }
#line 178
    return;
  }
#line 179
  if (events & 1) {
    {
#line 179
    Tvba("POLLIN");
#line 179
    delim = "|";
    }
  }
#line 180
  if (events & 4) {
    {
#line 180
    Tvba(delim);
#line 180
    Tvba("POLLOUT");
#line 180
    delim = "|";
    }
  }
#line 181
  if (events & 2) {
    {
#line 181
    Tvba(delim);
#line 181
    Tvba("POLLPRI");
    }
  }
#line 182
  return;
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
static unsigned long malloccount___1  ;
#line 241 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
static unsigned long mallocfailat___1  ;
#line 242 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
static struct __anonstruct_mallocedlist_90___1 mallocedlist___1  ;
#line 13 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static FILE *Tinputfile___0  ;
#line 13 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static FILE *Treportfile___0  ;
#line 14 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static vbuf vb2___0  ;
#line 18 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static void Tensurereportfile___0(void) 
{ 
  char const   *fdstr ;
  int fd ;
  char *tmp ;

  {
#line 21
  if (Treportfile___0) {
#line 21
    return;
  }
  {
#line 22
  Treportfile___0 = stderr;
#line 23
  tmp = getenv("ADNS_TEST_REPORT_FD");
#line 23
  fdstr = (char const   *)tmp;
  }
#line 23
  if (! fdstr) {
#line 23
    return;
  }
  {
#line 24
  fd = atoi(fdstr);
#line 25
  Treportfile___0 = fdopen(fd, "a");
  }
#line 25
  if (! Treportfile___0) {
    {
#line 25
    Tfailed("fdopen ADNS_TEST_REPORT_FD");
    }
  }
#line 26
  return;
}
}
#line 27 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static void Psyntax___0(char const   *where ) 
{ 


  {
  {
#line 28
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adns test harness: syntax error in test log input file: %s\n",
          where);
#line 29
  exit(-1);
  }
}
}
#line 31 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static void Pcheckinput___0(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 32
  tmp = ferror(Tinputfile___0);
  }
#line 32
  if (tmp) {
    {
#line 32
    Tfailed("read test log input file");
    }
  }
  {
#line 33
  tmp___0 = feof(Tinputfile___0);
  }
#line 33
  if (tmp___0) {
    {
#line 33
    Psyntax___0("eof at syscall reply");
    }
  }
#line 34
  return;
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static void Parg___0(char const   *argname ) 
{ 
  int l ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 59
  tmp = vb2___0.used;
#line 59
  (vb2___0.used) ++;
#line 59
  if ((int )*(vb2___0.buf + tmp) != 32) {
    {
#line 59
    Psyntax___0("not a space before argument");
    }
  }
  {
#line 60
  tmp___0 = strlen(argname);
#line 60
  l = (int )tmp___0;
#line 61
  tmp___1 = memcmp((void const   *)(vb2___0.buf + vb2___0.used), (void const   *)argname,
                   (size_t )l);
  }
#line 61
  if (tmp___1) {
    {
#line 61
    Psyntax___0("argument name wrong");
    }
  }
#line 62
  vb2___0.used += l;
#line 63
  tmp___2 = vb2___0.used;
#line 63
  (vb2___0.used) ++;
#line 63
  if ((int )*(vb2___0.buf + tmp___2) != 61) {
    {
#line 63
    Psyntax___0("not = after argument name");
    }
  }
#line 64
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static int Pstring_maybe___0(char const   *string ) 
{ 
  int l ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 67
  tmp = strlen(string);
#line 67
  l = (int )tmp;
#line 68
  tmp___0 = memcmp((void const   *)(vb2___0.buf + vb2___0.used), (void const   *)string,
                   (size_t )l);
  }
#line 68
  if (tmp___0) {
#line 68
    return (0);
  }
#line 69
  vb2___0.used += l;
#line 70
  return (1);
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static void Pstring___0(char const   *string , char const   *emsg ) 
{ 
  int tmp ;

  {
  {
#line 73
  tmp = Pstring_maybe___0(string);
  }
#line 73
  if (tmp) {
#line 73
    return;
  }
  {
#line 74
  Psyntax___0(emsg);
  }
#line 75
  return;
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static int Perrno___0(char const   *stuff ) 
{ 
  struct Terrno  const  *te ;
  int r ;
  char *ep ;
  int tmp ;
  unsigned long tmp___0 ;

  {
#line 80
  te = Terrnos;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    if (te->n) {
      {
#line 80
      tmp = strcmp((char const   *)te->n, stuff);
      }
#line 80
      if (! tmp) {
#line 80
        goto while_break;
      }
    } else {
#line 80
      goto while_break;
    }
#line 80
    te ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  if (te->n) {
#line 81
    return ((int )te->v);
  }
  {
#line 82
  tmp___0 = strtoul((char const   */* __restrict  */)(stuff + 2), (char **/* __restrict  */)(& ep),
                    10);
#line 82
  r = (int )tmp___0;
  }
#line 83
  if (*ep) {
    {
#line 83
    Psyntax___0("errno value not recognised, not numeric");
    }
  }
#line 84
  return (r);
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static void P_updatetime___0(void) 
{ 
  int chars ;
  unsigned long sec ;
  unsigned long usec ;
  int tmp ;

  {
  {
#line 89
  tmp = adns__vbuf_ensure(& vb2___0, 1000);
  }
#line 89
  if (! tmp) {
    {
#line 89
    Tnomem();
    }
  }
  {
#line 90
  fgets((char */* __restrict  */)vb2___0.buf, vb2___0.avail, (FILE */* __restrict  */)Tinputfile___0);
#line 90
  Pcheckinput___0();
#line 91
  chars = -1;
#line 92
  sscanf((char const   */* __restrict  */)vb2___0.buf, (char const   */* __restrict  */)" +%lu.%lu%n",
         & sec, & usec, & chars);
  }
#line 93
  if (chars == -1) {
    {
#line 93
    Psyntax___0("update time invalid");
    }
  }
#line 94
  currenttime.tv_sec = (__time_t )((unsigned long )currenttime.tv_sec + sec);
#line 95
  currenttime.tv_usec = (__suseconds_t )((unsigned long )currenttime.tv_usec + usec);
#line 96
  if (currenttime.tv_usec > 1000000L) {
#line 97
    (currenttime.tv_sec) ++;
#line 98
    currenttime.tv_usec -= 1000000L;
  }
#line 100
  if ((int )*(vb2___0.buf + chars) != 10) {
    {
#line 100
    Psyntax___0("not newline after update time");
    }
  }
#line 101
  return;
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static void Pfdset___0(fd_set *set , int max ) 
{ 
  int r ;
  int c ;
  char *ep ;
  int tmp ;
  int __d0 ;
  int __d1 ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
#line 105
  tmp = vb2___0.used;
#line 105
  (vb2___0.used) ++;
#line 105
  if ((int )*(vb2___0.buf + tmp) != 91) {
    {
#line 105
    Psyntax___0("fd set start not [");
    }
  }
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& set->__fds_bits[0]): "memory");
#line 106
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  if ((int )*(vb2___0.buf + vb2___0.used) == 93) {
#line 107
    (vb2___0.used) ++;
#line 107
    return;
  }
  {
#line 108
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 109
    tmp___0 = strtoul((char const   */* __restrict  */)(vb2___0.buf + vb2___0.used),
                      (char **/* __restrict  */)(& ep), 10);
#line 109
    r = (int )tmp___0;
    }
#line 110
    if (r >= max) {
      {
#line 110
      Psyntax___0("fd set member > max");
      }
    }
#line 111
    if ((unsigned long )ep == (unsigned long )((char *)vb2___0.buf + vb2___0.used)) {
      {
#line 111
      Psyntax___0("empty entry in fd set");
      }
    }
#line 112
    set->__fds_bits[r / (8 * (int )sizeof(__fd_mask ))] |= 1L << r % (8 * (int )sizeof(__fd_mask ));
#line 113
    vb2___0.used = (int )(ep - (char *)vb2___0.buf);
#line 114
    tmp___1 = vb2___0.used;
#line 114
    (vb2___0.used) ++;
#line 114
    c = (int )*(vb2___0.buf + tmp___1);
#line 115
    if (c == 93) {
#line 115
      goto while_break___0;
    }
#line 116
    if (c != 44) {
      {
#line 116
      Psyntax___0("fd set separator not ,");
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 118
  return;
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static int Ppollfdevents___0(void) 
{ 
  int events ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 122
  tmp = Pstring_maybe___0("0");
  }
#line 122
  if (tmp) {
#line 122
    return (0);
  }
  {
#line 123
  events = 0;
#line 124
  tmp___1 = Pstring_maybe___0("POLLIN");
  }
#line 124
  if (tmp___1) {
    {
#line 125
    events |= 1;
#line 126
    tmp___0 = Pstring_maybe___0("|");
    }
#line 126
    if (! tmp___0) {
#line 126
      return (events);
    }
  }
  {
#line 128
  tmp___3 = Pstring_maybe___0("POLLOUT");
  }
#line 128
  if (tmp___3) {
    {
#line 129
    events |= 4;
#line 130
    tmp___2 = Pstring_maybe___0("|");
    }
#line 130
    if (! tmp___2) {
#line 130
      return (events);
    }
  }
  {
#line 132
  Pstring___0("POLLPRI", "pollfdevents PRI?");
  }
#line 133
  return (events);
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static void Ppollfds___0(struct pollfd *fds , int nfds ) 
{ 
  int i ;
  char *ep ;
  char const   *comma ;
  int tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 138
  comma = "";
#line 139
  tmp = vb2___0.used;
#line 139
  (vb2___0.used) ++;
#line 139
  if ((int )*(vb2___0.buf + tmp) != 91) {
    {
#line 139
    Psyntax___0("pollfds start not [");
    }
  }
#line 140
  i = 0;
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if (! (i < nfds)) {
#line 140
      goto while_break;
    }
    {
#line 141
    Pstring___0("{fd=", "{fd= in pollfds");
#line 142
    tmp___0 = strtoul((char const   */* __restrict  */)(vb2___0.buf + vb2___0.used),
                      (char **/* __restrict  */)(& ep), 10);
#line 142
    fds->fd = (int )tmp___0;
#line 143
    vb2___0.used = (int )(ep - (char *)vb2___0.buf);
#line 144
    Pstring___0(", events=", ", events= in pollfds");
#line 145
    tmp___1 = Ppollfdevents___0();
#line 145
    fds->events = (short )tmp___1;
#line 146
    Pstring___0(", revents=", ", revents= in pollfds");
#line 147
    tmp___2 = Ppollfdevents___0();
#line 147
    fds->revents = (short )tmp___2;
#line 148
    Pstring___0("}", "} in pollfds");
#line 149
    Pstring___0(comma, "separator in pollfds");
#line 150
    comma = ", ";
#line 140
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 152
  tmp___3 = vb2___0.used;
#line 152
  (vb2___0.used) ++;
#line 152
  if ((int )*(vb2___0.buf + tmp___3) != 93) {
    {
#line 152
    Psyntax___0("pollfds end not ]");
    }
  }
#line 153
  return;
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static void Paddr___0(struct sockaddr *addr , int *lenr ) 
{ 
  struct sockaddr_in *sa___3 ;
  char *p ;
  char *ep ;
  long ul ;
  char *tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 156
  sa___3 = (struct sockaddr_in *)addr;
#line 159
  if (! ((unsigned long )*lenr >= sizeof(*sa___3))) {
    {
#line 159
    __assert_fail("*lenr >= sizeof(*sa)", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c",
                  159U, "Paddr");
    }
  }
  {
#line 160
  p = strchr((char const   *)(vb2___0.buf + vb2___0.used), ':');
  }
#line 161
  if (! p) {
    {
#line 161
    Psyntax___0("no port on address");
    }
  }
  {
#line 162
  tmp = p;
#line 162
  p ++;
#line 162
  *tmp = (char)0;
#line 163
  memset((void *)sa___3, 0, sizeof(*sa___3));
#line 164
  sa___3->sin_family = (sa_family_t )2;
#line 165
  tmp___0 = inet_aton((char const   *)(vb2___0.buf + vb2___0.used), & sa___3->sin_addr);
  }
#line 165
  if (! tmp___0) {
    {
#line 165
    Psyntax___0("invalid address");
    }
  }
  {
#line 166
  tmp___1 = strtoul((char const   */* __restrict  */)p, (char **/* __restrict  */)(& ep),
                    10);
#line 166
  ul = (long )tmp___1;
  }
#line 167
  if (*ep) {
#line 167
    if ((int )*ep != 32) {
      {
#line 167
      Psyntax___0("invalid port (bad syntax)");
      }
    }
  }
#line 168
  if (ul >= 65536L) {
    {
#line 168
    Psyntax___0("port too large");
    }
  }
  {
#line 169
  sa___3->sin_port = htons((uint16_t )ul);
#line 170
  *lenr = (int )sizeof(*sa___3);
#line 171
  vb2___0.used = (int )(ep - (char *)vb2___0.buf);
  }
#line 172
  return;
}
}
#line 174
static int Pbytes___0(byte *buf___17 , int maxlen ) ;
#line 174 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static char const   hexdigits___0[17]  = 
#line 174
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'\000'};
#line 173 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static int Pbytes___0(byte *buf___17 , int maxlen ) 
{ 
  int c ;
  int v ;
  int done ;
  char const   *pf ;
  char *tmp ;
  char *tmp___0 ;
  byte *tmp___1 ;

  {
#line 177
  done = 0;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 179
    c = _IO_getc(Tinputfile___0);
#line 179
    Pcheckinput___0();
    }
#line 180
    if (c == 10) {
#line 180
      goto __Cont;
    } else
#line 180
    if (c == 32) {
#line 180
      goto __Cont;
    } else
#line 180
    if (c == 9) {
#line 180
      goto __Cont;
    }
#line 181
    if (c == 46) {
#line 181
      goto while_break;
    }
    {
#line 182
    tmp = strchr(hexdigits___0, c);
#line 182
    pf = (char const   *)tmp;
    }
#line 182
    if (! pf) {
      {
#line 182
      Psyntax___0("invalid first hex digit");
      }
    }
    {
#line 183
    v = (int )((pf - hexdigits___0) << 4);
#line 184
    c = _IO_getc(Tinputfile___0);
#line 184
    Pcheckinput___0();
#line 185
    tmp___0 = strchr(hexdigits___0, c);
#line 185
    pf = (char const   *)tmp___0;
    }
#line 185
    if (! pf) {
      {
#line 185
      Psyntax___0("invalid second hex digit");
      }
    }
#line 186
    v = (int )((long )v | (pf - hexdigits___0));
#line 187
    if (maxlen <= 0) {
      {
#line 187
      Psyntax___0("buffer overflow in bytes");
      }
    }
#line 188
    tmp___1 = buf___17;
#line 188
    buf___17 ++;
#line 188
    *tmp___1 = (byte )v;
#line 189
    maxlen --;
#line 189
    done ++;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 191
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 192
    c = _IO_getc(Tinputfile___0);
#line 192
    Pcheckinput___0();
    }
#line 193
    if (c == 10) {
#line 193
      return (done);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_qstring___1(parseinfo const   *pai , int *cbyte_io , int max ,
                                   int *len_r , char **str_r ) 
{ 
  byte const   *dgram ;
  int l ;
  int cbyte___3 ;
  char *str ;
  int tmp ;
  void *tmp___0 ;

  {
#line 92
  dgram = (byte const   *)pai->dgram;
#line 96
  cbyte___3 = *cbyte_io;
#line 98
  if (cbyte___3 >= max) {
#line 98
    return ((adns_status )104);
  }
#line 99
  tmp = cbyte___3;
#line 99
  cbyte___3 ++;
#line 99
  l = (int )((int const   )*(dgram + tmp) & 255);
#line 100
  if (cbyte___3 + l > max) {
#line 100
    return ((adns_status )104);
  }
  {
#line 102
  tmp___0 = adns__alloc_interim((adns_query )pai->qu, (size_t )(l + 1));
#line 102
  str = (char *)tmp___0;
  }
#line 103
  if (! str) {
#line 103
    return ((adns_status )1);
  }
  {
#line 105
  *(str + l) = (char)0;
#line 106
  memcpy((void */* __restrict  */)str, (void const   */* __restrict  */)(dgram + cbyte___3),
         (size_t )l);
#line 108
  *len_r = l;
#line 109
  *str_r = str;
#line 110
  *cbyte_io = cbyte___3 + l;
  }
#line 112
  return ((adns_status )0);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_qstring___1(vbuf *vb___0 , char const   *dp , int len ) 
{ 
  unsigned char ch ;
  char buf___17[10] ;
  int cn ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 120
    tmp = adns__vbuf_appendstr(vb___0, "\"");
    }
#line 120
    if (! tmp) {
#line 120
      return ((adns_status )1);
    }
#line 120
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  cn = 0;
  {
#line 121
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 121
    if (! (cn < len)) {
#line 121
      goto while_break___0;
    }
#line 122
    tmp___0 = dp;
#line 122
    dp ++;
#line 122
    ch = (unsigned char )*tmp___0;
#line 123
    if ((int )ch == 92) {
      {
#line 124
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 124
        tmp___1 = adns__vbuf_appendstr(vb___0, "\\\\");
        }
#line 124
        if (! tmp___1) {
#line 124
          return ((adns_status )1);
        }
#line 124
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else
#line 125
    if ((int )ch == 34) {
      {
#line 126
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 126
        tmp___2 = adns__vbuf_appendstr(vb___0, "\\\"");
        }
#line 126
        if (! tmp___2) {
#line 126
          return ((adns_status )1);
        }
#line 126
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else
#line 127
    if ((int )ch >= 32) {
#line 127
      if ((int )ch <= 126) {
        {
#line 128
        tmp___3 = adns__vbuf_append(vb___0, (byte const   *)(& ch), 1);
        }
#line 128
        if (! tmp___3) {
#line 128
          return ((adns_status )1);
        }
      } else {
#line 127
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 130
      sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"\\x%02x",
              (int )ch);
      }
      {
#line 131
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 131
        tmp___4 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
        }
#line 131
        if (! tmp___4) {
#line 131
          return ((adns_status )1);
        }
#line 131
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 121
    cn ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 134
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 134
    tmp___5 = adns__vbuf_appendstr(vb___0, "\"");
    }
#line 134
    if (! tmp___5) {
#line 134
      return ((adns_status )1);
    }
#line 134
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 136
  return ((adns_status )0);
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_str___1(adns_query qu , void *datap ) 
{ 
  char **rrp ;

  {
  {
#line 144
  rrp = (char **)datap;
#line 146
  adns__makefinal_str(qu, rrp);
  }
#line 147
  return;
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_intstr___1(adns_query qu , void *datap ) 
{ 
  adns_rr_intstr *rrp ;

  {
  {
#line 154
  rrp = (adns_rr_intstr *)datap;
#line 156
  adns__makefinal_str(qu, & rrp->str);
  }
#line 157
  return;
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_manyistr___1(adns_query qu , void *datap ) 
{ 
  adns_rr_intstr **rrp ;
  adns_rr_intstr *te ;
  adns_rr_intstr *table ;
  void *tablev ;
  int tc ;

  {
#line 164
  rrp = (adns_rr_intstr **)datap;
#line 169
  tc = 0;
#line 169
  te = *rrp;
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    if (! (te->i >= 0)) {
#line 169
      goto while_break;
    }
#line 169
    te ++;
#line 169
    tc ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 170
  tablev = (void *)*rrp;
#line 171
  adns__makefinal_block(qu, & tablev, sizeof(*te) * (unsigned long )(tc + 1));
#line 172
  table = (adns_rr_intstr *)tablev;
#line 172
  *rrp = table;
#line 173
  te = *rrp;
  }
  {
#line 173
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 173
    if (! (te->i >= 0)) {
#line 173
      goto while_break___0;
    }
    {
#line 174
    adns__makefinal_str(qu, & te->str);
#line 173
    te ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 175
  return;
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_txt___1(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  adns_rr_intstr **rrp ;
  adns_rr_intstr *table ;
  adns_rr_intstr *te ;
  byte const   *dgram ;
  int ti ;
  int tc ;
  int l ;
  int startbyte ;
  adns_status st ;
  int tmp ;
  void *tmp___0 ;

  {
#line 183
  rrp = (adns_rr_intstr **)datap;
#line 184
  dgram = (byte const   *)pai->dgram;
#line 188
  startbyte = cbyte___3;
#line 189
  if (cbyte___3 >= max) {
#line 189
    return ((adns_status )104);
  }
#line 190
  tc = 0;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! (cbyte___3 < max)) {
#line 191
      goto while_break;
    }
#line 192
    tmp = cbyte___3;
#line 192
    cbyte___3 ++;
#line 192
    l = (int )((int const   )*(dgram + tmp) & 255);
#line 193
    cbyte___3 += l;
#line 194
    tc ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  if (cbyte___3 != max) {
#line 196
    return ((adns_status )104);
  } else
#line 196
  if (! tc) {
#line 196
    return ((adns_status )104);
  }
  {
#line 198
  tmp___0 = adns__alloc_interim((adns_query )pai->qu, sizeof(*table) * (unsigned long )(tc + 1));
#line 198
  table = (adns_rr_intstr *)tmp___0;
  }
#line 199
  if (! table) {
#line 199
    return ((adns_status )1);
  }
#line 201
  cbyte___3 = startbyte;
#line 201
  ti = 0;
#line 201
  te = table;
  {
#line 201
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 201
    if (! (ti < tc)) {
#line 201
      goto while_break___0;
    }
    {
#line 202
    st = pap_qstring___1(pai, & cbyte___3, max, & te->i, & te->str);
    }
#line 203
    if (st) {
#line 203
      return (st);
    }
#line 201
    ti ++;
#line 201
    te ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 205
  if (! (cbyte___3 == max)) {
    {
#line 205
    __assert_fail("cbyte == max", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  205U, "pa_txt");
    }
  }
#line 207
  te->i = -1;
#line 208
  te->str = (char *)0;
#line 210
  *rrp = table;
#line 211
  return ((adns_status )0);
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_txt___1(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_intstr const   * const  *rrp ;
  adns_rr_intstr const   *current ;
  adns_status st ;
  int spc ;
  int tmp ;

  {
#line 215
  rrp = (adns_rr_intstr const   * const  *)datap;
#line 220
  current = (adns_rr_intstr const   *)*rrp;
#line 220
  spc = 0;
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    if (! (current->i >= 0)) {
#line 220
      goto while_break;
    }
#line 221
    if (spc) {
      {
#line 221
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 221
        tmp = adns__vbuf_appendstr(vb___0, " ");
        }
#line 221
        if (! tmp) {
#line 221
          return ((adns_status )1);
        }
#line 221
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 222
    st = csp_qstring___1(vb___0, (char const   *)current->str, (int )current->i);
    }
#line 222
    if (st) {
#line 222
      return (st);
    }
#line 220
    current ++;
#line 220
    spc = 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  return ((adns_status )0);
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_hinfo___1(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_intstrpair const   *rrp ;
  adns_status st ;
  int tmp ;

  {
  {
#line 232
  rrp = (adns_rr_intstrpair const   *)datap;
#line 235
  st = csp_qstring___1(vb___0, (char const   *)rrp->array[0].str, (int )rrp->array[0].i);
  }
#line 235
  if (st) {
#line 235
    return (st);
  }
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 236
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 236
    if (! tmp) {
#line 236
      return ((adns_status )1);
    }
#line 236
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 237
  st = csp_qstring___1(vb___0, (char const   *)rrp->array[1].str, (int )rrp->array[1].i);
  }
#line 237
  if (st) {
#line 237
    return (st);
  }
#line 238
  return ((adns_status )0);
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_inaddr___1(parseinfo const   *pai , int cbyte___3 , int max ,
                                 void *datap ) 
{ 
  struct in_addr *storeto ;

  {
#line 247
  storeto = (struct in_addr *)datap;
#line 249
  if (max - cbyte___3 != 4) {
#line 249
    return ((adns_status )104);
  }
  {
#line 250
  memcpy((void */* __restrict  */)storeto, (void const   */* __restrict  */)(pai->dgram + cbyte___3),
         (size_t )4);
  }
#line 251
  return ((adns_status )0);
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int search_sortlist___1(adns_state ads___7 , struct in_addr ad ) 
{ 
  struct sortlist  const  *slp ;
  int i ;

  {
#line 258
  i = 0;
#line 258
  slp = (struct sortlist  const  *)(ads___7->sortlist);
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 258
    if (i < ads___7->nsortlist) {
#line 258
      if (! (! ((ad.s_addr & (unsigned int )slp->mask.s_addr) == (unsigned int )slp->base.s_addr))) {
#line 258
        goto while_break;
      }
    } else {
#line 258
      goto while_break;
    }
#line 258
    i ++;
#line 258
    slp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  return (i);
}
}
#line 265 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int dip_inaddr___1(adns_state ads___7 , struct in_addr a , struct in_addr b ) 
{ 
  int ai ;
  int bi ;

  {
#line 268
  if (! ads___7->nsortlist) {
#line 268
    return (0);
  }
  {
#line 270
  ai = search_sortlist___1(ads___7, a);
#line 271
  bi = search_sortlist___1(ads___7, b);
  }
#line 272
  return (bi < ai);
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_inaddr___1(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  struct in_addr  const  *ap ;
  struct in_addr  const  *bp ;
  int tmp ;

  {
  {
#line 277
  ap = (struct in_addr  const  *)datap_a;
#line 277
  bp = (struct in_addr  const  *)datap_b;
#line 279
  tmp = dip_inaddr___1(ads___7, (struct in_addr )*ap, (struct in_addr )*bp);
  }
#line 279
  return (tmp);
}
}
#line 282 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_inaddr___1(vbuf *vb___0 , void const   *datap ) 
{ 
  struct in_addr  const  *rrp ;
  struct in_addr rr ;
  char const   *ia ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 283
  rrp = (struct in_addr  const  *)datap;
#line 283
  rr = *rrp;
#line 286
  tmp = inet_ntoa(rr);
#line 286
  ia = (char const   *)tmp;
  }
#line 286
  if (! ia) {
    {
#line 286
    __assert_fail("ia", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  286U, "cs_inaddr");
    }
  }
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 287
    tmp___0 = adns__vbuf_appendstr(vb___0, ia);
    }
#line 287
    if (! tmp___0) {
#line 287
      return ((adns_status )1);
    }
#line 287
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  return ((adns_status )0);
}
}
#line 295 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_addr___1(parseinfo const   *pai , int cbyte___3 , int max ,
                               void *datap ) 
{ 
  adns_rr_addr *storeto ;
  byte const   *dgram ;

  {
#line 297
  storeto = (adns_rr_addr *)datap;
#line 298
  dgram = (byte const   *)pai->dgram;
#line 300
  if (max - cbyte___3 != 4) {
#line 300
    return ((adns_status )104);
  }
  {
#line 301
  storeto->len = (int )sizeof(storeto->addr.inet);
#line 302
  memset((void *)(& storeto->addr), 0, sizeof(storeto->addr.inet));
#line 303
  storeto->addr.inet.sin_family = (sa_family_t )2;
#line 304
  memcpy((void */* __restrict  */)(& storeto->addr.inet.sin_addr), (void const   */* __restrict  */)(dgram + cbyte___3),
         (size_t )4);
  }
#line 305
  return ((adns_status )0);
}
}
#line 308 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_addr___1(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_addr const   *ap ;
  adns_rr_addr const   *bp ;
  int tmp ;

  {
#line 309
  ap = (adns_rr_addr const   *)datap_a;
#line 309
  bp = (adns_rr_addr const   *)datap_b;
#line 311
  if (! ((int const   )ap->addr.sa.sa_family == 2)) {
    {
#line 311
    __assert_fail("ap->addr.sa.sa_family == 2", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  311U, "di_addr");
    }
  }
  {
#line 312
  tmp = dip_inaddr___1(ads___7, (struct in_addr )ap->addr.inet.sin_addr, (struct in_addr )bp->addr.inet.sin_addr);
  }
#line 312
  return (tmp);
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int div_addr___1(void *context , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_state ads___7 ;
  int tmp ;

  {
  {
#line 316
  ads___7 = (adns_state )context;
#line 318
  tmp = di_addr___1(ads___7, datap_a, datap_b);
  }
#line 318
  return (tmp);
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_addr___1(vbuf *vb___0 , adns_rr_addr const   *rrp ) 
{ 
  char const   *ia ;
  char buf___17[30] ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 326
  if ((int const   )rrp->addr.inet.sin_family == 2) {
#line 326
    goto case_2;
  }
#line 331
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 327
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 327
    tmp = adns__vbuf_appendstr(vb___0, "INET ");
    }
#line 327
    if (! tmp) {
#line 327
      return ((adns_status )1);
    }
#line 327
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 328
  tmp___0 = inet_ntoa((struct in_addr )rrp->addr.inet.sin_addr);
#line 328
  ia = (char const   *)tmp___0;
  }
#line 328
  if (! ia) {
    {
#line 328
    __assert_fail("ia", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  328U, "csp_addr");
    }
  }
  {
#line 329
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 329
    tmp___1 = adns__vbuf_appendstr(vb___0, ia);
    }
#line 329
    if (! tmp___1) {
#line 329
      return ((adns_status )1);
    }
#line 329
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 330
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 332
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"AF=%u",
          (int const   )rrp->addr.sa.sa_family);
  }
  {
#line 333
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 333
    tmp___2 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 333
    if (! tmp___2) {
#line 333
      return ((adns_status )1);
    }
#line 333
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 334
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 336
  return ((adns_status )0);
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_addr___1(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_addr const   *rrp ;
  adns_status tmp ;

  {
  {
#line 340
  rrp = (adns_rr_addr const   *)datap;
#line 342
  tmp = csp_addr___1(vb___0, rrp);
  }
#line 342
  return (tmp);
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_domain___1(parseinfo const   *pai , int *cbyte_io , int max ,
                                  char **domain_r , parsedomain_flags flags ) 
{ 
  adns_status st ;
  char *dm ;
  void *tmp ;

  {
  {
#line 355
  st = adns__parse_domain((pai->qu)->ads, (int )pai->serv, (adns_query )pai->qu, & (pai->qu)->vb,
                          flags, (byte const   *)pai->dgram, (int )pai->dglen, cbyte_io,
                          max);
  }
#line 357
  if (st) {
#line 357
    return (st);
  }
#line 358
  if (! (pai->qu)->vb.used) {
#line 358
    return ((adns_status )104);
  }
  {
#line 360
  tmp = adns__alloc_interim((adns_query )pai->qu, (size_t )((pai->qu)->vb.used + 1));
#line 360
  dm = (char *)tmp;
  }
#line 361
  if (! dm) {
#line 361
    return ((adns_status )1);
  }
  {
#line 363
  *(dm + (pai->qu)->vb.used) = (char)0;
#line 364
  memcpy((void */* __restrict  */)dm, (void const   */* __restrict  */)(pai->qu)->vb.buf,
         (size_t )(pai->qu)->vb.used);
#line 366
  *domain_r = dm;
  }
#line 367
  return ((adns_status )0);
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_domain___1(vbuf *vb___0 , char const   *domain ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 371
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 371
    tmp = adns__vbuf_appendstr(vb___0, domain);
    }
#line 371
    if (! tmp) {
#line 371
      return ((adns_status )1);
    }
#line 371
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 372
  if (! *domain) {
    {
#line 372
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 372
      tmp___0 = adns__vbuf_appendstr(vb___0, ".");
      }
#line 372
      if (! tmp___0) {
#line 372
        return ((adns_status )1);
      }
#line 372
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 373
  return ((adns_status )0);
}
}
#line 376 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_domain___1(vbuf *vb___0 , void const   *datap ) 
{ 
  char const   * const  *domainp ;
  adns_status tmp ;

  {
  {
#line 377
  domainp = (char const   * const  *)datap;
#line 378
  tmp = csp_domain___1(vb___0, (char const   *)*domainp);
  }
#line 378
  return (tmp);
}
}
#line 381 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_dom_raw___1(parseinfo const   *pai , int cbyte___3 , int max ,
                                  void *datap ) 
{ 
  char **rrp ;
  adns_status st ;

  {
  {
#line 383
  rrp = (char **)datap;
#line 386
  st = pap_domain___1(pai, & cbyte___3, max, rrp, (parsedomain_flags )1);
  }
#line 387
  if (st) {
#line 387
    return (st);
  }
#line 389
  if (cbyte___3 != max) {
#line 389
    return ((adns_status )104);
  }
#line 390
  return ((adns_status )0);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_host_raw___1(parseinfo const   *pai , int cbyte___3 , int max ,
                                   void *datap ) 
{ 
  char **rrp ;
  adns_status st ;
  int tmp ;

  {
#line 399
  rrp = (char **)datap;
#line 402
  if ((pai->qu)->flags & 64) {
#line 402
    tmp = 1;
  } else {
#line 402
    tmp = 0;
  }
  {
#line 402
  st = pap_domain___1(pai, & cbyte___3, max, rrp, (parsedomain_flags )tmp);
  }
#line 404
  if (st) {
#line 404
    return (st);
  }
#line 406
  if (cbyte___3 != max) {
#line 406
    return ((adns_status )104);
  }
#line 407
  return ((adns_status )0);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_findaddrs___1(parseinfo const   *pai , adns_rr_hostaddr *ha ,
                                     int *cbyte_io , int count , int dmstart ) 
{ 
  int rri ;
  int naddrs ;
  int type ;
  int class ;
  int rdlen ;
  int rdstart ;
  int ownermatched ;
  unsigned long ttl ;
  adns_status st ;
  int tmp ;
  void *tmp___0 ;

  {
#line 421
  rri = 0;
#line 421
  naddrs = -1;
  {
#line 421
  while (1) {
    while_continue: /* CIL Label */ ;
#line 421
    if (! (rri < count)) {
#line 421
      goto while_break;
    }
    {
#line 422
    st = adns__findrr_anychk((adns_query )pai->qu, (int )pai->serv, (byte const   *)pai->dgram,
                             (int )pai->dglen, cbyte_io, & type, & class, & ttl, & rdlen,
                             & rdstart, (byte const   *)pai->dgram, (int )pai->dglen,
                             dmstart, & ownermatched);
    }
#line 426
    if (st) {
#line 426
      return (st);
    }
#line 427
    if (! ownermatched) {
#line 427
      goto _L;
    } else
#line 427
    if (class != 1) {
#line 427
      goto _L;
    } else
#line 427
    if (type != 1) {
      _L: /* CIL Label */ 
#line 428
      if (naddrs > 0) {
#line 428
        goto while_break;
      } else {
#line 428
        goto __Cont;
      }
    }
#line 430
    if (naddrs == -1) {
#line 431
      naddrs = 0;
    }
    {
#line 433
    tmp = adns__vbuf_ensure(& (pai->qu)->vb, (int )((unsigned long )(naddrs + 1) * sizeof(adns_rr_addr )));
    }
#line 433
    if (! tmp) {
#line 434
      return ((adns_status )1);
    }
    {
#line 435
    adns__update_expires((adns_query )pai->qu, ttl, (struct timeval )pai->now);
#line 436
    st = pa_addr___1(pai, rdstart, rdstart + rdlen, (void *)((pai->qu)->vb.buf + (unsigned long )naddrs * sizeof(adns_rr_addr )));
    }
#line 438
    if (st) {
#line 438
      return (st);
    }
#line 439
    naddrs ++;
    __Cont: /* CIL Label */ 
#line 421
    rri ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 441
  if (naddrs >= 0) {
    {
#line 442
    tmp___0 = adns__alloc_interim((adns_query )pai->qu, (unsigned long )naddrs * sizeof(adns_rr_addr ));
#line 442
    ha->addrs = (adns_rr_addr *)tmp___0;
    }
#line 443
    if (! ha->addrs) {
#line 443
      return ((adns_status )1);
    }
    {
#line 444
    memcpy((void */* __restrict  */)ha->addrs, (void const   */* __restrict  */)(pai->qu)->vb.buf,
           (unsigned long )naddrs * sizeof(adns_rr_addr ));
#line 445
    ha->naddrs = naddrs;
#line 446
    ha->astatus = (adns_status )0;
#line 448
    adns__isort((void *)ha->addrs, naddrs, (int )sizeof(adns_rr_addr ), (void *)(pai->qu)->vb.buf,
                & div_addr___1, (void *)pai->ads);
    }
  }
#line 451
  return ((adns_status )0);
}
}
#line 454 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void icb_hostaddr___1(adns_query parent , adns_query child ) 
{ 
  adns_answer *cans ;
  adns_rr_hostaddr *rrp ;
  adns_state ads___7 ;
  adns_status st ;

  {
#line 455
  cans = child->answer;
#line 456
  rrp = child->ctx.info.hostaddr;
#line 457
  ads___7 = parent->ads;
#line 460
  st = cans->status;
#line 461
  rrp->astatus = st;
#line 462
  if ((unsigned int )st > 0U) {
#line 462
    if ((unsigned int )st <= 99U) {
#line 462
      rrp->naddrs = -1;
    } else {
#line 462
      rrp->naddrs = cans->nrrs;
    }
  } else {
#line 462
    rrp->naddrs = cans->nrrs;
  }
  {
#line 463
  rrp->addrs = cans->rrs.addr;
#line 464
  adns__transfer_interim(child, parent, (void *)rrp->addrs, (unsigned long )rrp->naddrs * sizeof(adns_rr_addr ));
  }
#line 467
  if (parent->children.head) {
    {
#line 468
    while (1) {
      while_continue: /* CIL Label */ ;
#line 468
      parent->next = (adns_query )0;
#line 468
      parent->back = ads___7->childw.tail;
#line 468
      if (ads___7->childw.tail) {
#line 468
        (ads___7->childw.tail)->next = parent;
      } else {
#line 468
        ads___7->childw.head = parent;
      }
#line 468
      ads___7->childw.tail = parent;
#line 468
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 470
    adns__query_done(parent);
    }
  }
#line 472
  return;
}
}
#line 474 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_hostaddr___1(parseinfo const   *pai , int *cbyte_io , int max ,
                                    adns_rr_hostaddr *rrp ) 
{ 
  adns_status st ;
  int dmstart ;
  int cbyte___3 ;
  qcontext ctx ;
  int id ;
  adns_query nqu ;
  adns_queryflags nflags ;
  int tmp ;
  typeinfo const   *tmp___0 ;

  {
#line 483
  cbyte___3 = *cbyte_io;
#line 483
  dmstart = cbyte___3;
#line 484
  if ((pai->qu)->flags & 64) {
#line 484
    tmp = 1;
  } else {
#line 484
    tmp = 0;
  }
  {
#line 484
  st = pap_domain___1(pai, & cbyte___3, max, & rrp->host, (parsedomain_flags )tmp);
  }
#line 486
  if (st) {
#line 486
    return (st);
  }
  {
#line 487
  *cbyte_io = cbyte___3;
#line 489
  rrp->astatus = (adns_status )0;
#line 490
  rrp->naddrs = -1;
#line 491
  rrp->addrs = (adns_rr_addr *)0;
#line 493
  cbyte___3 = (int )pai->nsstart;
#line 495
  st = pap_findaddrs___1(pai, rrp, & cbyte___3, (int )pai->nscount, dmstart);
  }
#line 496
  if (st) {
#line 496
    return (st);
  }
#line 497
  if (rrp->naddrs != -1) {
#line 497
    return ((adns_status )0);
  }
  {
#line 499
  st = pap_findaddrs___1(pai, rrp, & cbyte___3, (int )pai->arcount, dmstart);
  }
#line 500
  if (st) {
#line 500
    return (st);
  }
#line 501
  if (rrp->naddrs != -1) {
#line 501
    return ((adns_status )0);
  }
  {
#line 503
  st = adns__mkquery_frdgram((adns_state )pai->ads, & (pai->qu)->vb, & id, (byte const   *)pai->dgram,
                             (int )pai->dglen, dmstart, (adns_rrtype )65537, (adns_queryflags )16);
  }
#line 506
  if (st) {
#line 506
    return (st);
  }
#line 508
  ctx.ext = (void *)0;
#line 509
  ctx.callback = & icb_hostaddr___1;
#line 510
  ctx.info.hostaddr = rrp;
#line 512
  nflags = (adns_queryflags )16;
#line 513
  if (! ((pai->qu)->flags & 256)) {
#line 513
    nflags = (adns_queryflags )((unsigned int )nflags | 512U);
  }
  {
#line 515
  tmp___0 = adns__findtype((adns_rrtype )65537);
#line 515
  st = adns__internal_submit((adns_state )pai->ads, & nqu, tmp___0, & (pai->qu)->vb,
                             id, nflags, (struct timeval )pai->now, (qcontext const   *)(& ctx));
  }
#line 517
  if (st) {
#line 517
    return (st);
  }
#line 519
  nqu->parent = (adns_query )pai->qu;
  {
#line 520
  while (1) {
    while_continue: /* CIL Label */ ;
#line 520
    nqu->siblings.next = (adns_query )0;
#line 520
    nqu->siblings.back = (pai->qu)->children.tail;
#line 520
    if ((pai->qu)->children.tail) {
#line 520
      ((pai->qu)->children.tail)->siblings.next = nqu;
    } else {
#line 520
      (pai->qu)->children.head = nqu;
    }
#line 520
    (pai->qu)->children.tail = nqu;
#line 520
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 522
  return ((adns_status )0);
}
}
#line 525 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_hostaddr___1(parseinfo const   *pai , int cbyte___3 , int max ,
                                   void *datap ) 
{ 
  adns_rr_hostaddr *rrp ;
  adns_status st ;

  {
  {
#line 527
  rrp = (adns_rr_hostaddr *)datap;
#line 530
  st = pap_hostaddr___1(pai, & cbyte___3, max, rrp);
  }
#line 531
  if (st) {
#line 531
    return (st);
  }
#line 532
  if (cbyte___3 != max) {
#line 532
    return ((adns_status )104);
  }
#line 534
  return ((adns_status )0);
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int dip_hostaddr___1(adns_state ads___7 , adns_rr_hostaddr const   *ap , adns_rr_hostaddr const   *bp ) 
{ 
  int tmp ;

  {
#line 539
  if ((unsigned int const   )ap->astatus != (unsigned int const   )bp->astatus) {
#line 539
    return ((int )ap->astatus);
  }
#line 540
  if (ap->astatus) {
#line 540
    return (0);
  }
#line 542
  if (! ((int )(ap->addrs + 0)->addr.sa.sa_family == 2)) {
    {
#line 542
    __assert_fail("ap->addrs[0].addr.sa.sa_family == 2", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  542U, "dip_hostaddr");
    }
  }
#line 543
  if (! ((int )(bp->addrs + 0)->addr.sa.sa_family == 2)) {
    {
#line 543
    __assert_fail("bp->addrs[0].addr.sa.sa_family == 2", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  543U, "dip_hostaddr");
    }
  }
  {
#line 544
  tmp = dip_inaddr___1(ads___7, (ap->addrs + 0)->addr.inet.sin_addr, (bp->addrs + 0)->addr.inet.sin_addr);
  }
#line 544
  return (tmp);
}
}
#line 549 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_hostaddr___1(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_hostaddr const   *ap ;
  adns_rr_hostaddr const   *bp ;
  int tmp ;

  {
  {
#line 551
  ap = (adns_rr_hostaddr const   *)datap_a;
#line 551
  bp = (adns_rr_hostaddr const   *)datap_b;
#line 553
  tmp = dip_hostaddr___1(ads___7, ap, bp);
  }
#line 553
  return (tmp);
}
}
#line 556 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mfp_hostaddr___1(adns_query qu , adns_rr_hostaddr *rrp ) 
{ 
  void *tablev ;

  {
  {
#line 559
  adns__makefinal_str(qu, & rrp->host);
#line 560
  tablev = (void *)rrp->addrs;
#line 561
  adns__makefinal_block(qu, & tablev, (unsigned long )rrp->naddrs * sizeof(*(rrp->addrs)));
#line 562
  rrp->addrs = (adns_rr_addr *)tablev;
  }
#line 563
  return;
}
}
#line 565 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_hostaddr___1(adns_query qu , void *datap ) 
{ 
  adns_rr_hostaddr *rrp ;

  {
  {
#line 566
  rrp = (adns_rr_hostaddr *)datap;
#line 568
  mfp_hostaddr___1(qu, rrp);
  }
#line 569
  return;
}
}
#line 571 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_hostaddr___1(vbuf *vb___0 , adns_rr_hostaddr const   *rrp ) 
{ 
  char const   *errstr ;
  adns_status st ;
  char buf___17[20] ;
  int i ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 577
  st = csp_domain___1(vb___0, (char const   *)rrp->host);
  }
#line 577
  if (st) {
#line 577
    return (st);
  }
  {
#line 579
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 579
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 579
    if (! tmp) {
#line 579
      return ((adns_status )1);
    }
#line 579
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 580
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 580
    tmp___0 = adns_errtypeabbrev((adns_status )rrp->astatus);
#line 580
    tmp___1 = adns__vbuf_appendstr(vb___0, tmp___0);
    }
#line 580
    if (! tmp___1) {
#line 580
      return ((adns_status )1);
    }
#line 580
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 582
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %d ",
          (unsigned int const   )rrp->astatus);
  }
  {
#line 583
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 583
    tmp___2 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 583
    if (! tmp___2) {
#line 583
      return ((adns_status )1);
    }
#line 583
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 585
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 585
    tmp___3 = adns_errabbrev((adns_status )rrp->astatus);
#line 585
    tmp___4 = adns__vbuf_appendstr(vb___0, tmp___3);
    }
#line 585
    if (! tmp___4) {
#line 585
      return ((adns_status )1);
    }
#line 585
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 586
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 586
    tmp___5 = adns__vbuf_appendstr(vb___0, " ");
    }
#line 586
    if (! tmp___5) {
#line 586
      return ((adns_status )1);
    }
#line 586
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 588
  errstr = adns_strerror((adns_status )rrp->astatus);
#line 589
  tmp___6 = strlen(errstr);
#line 589
  st = csp_qstring___1(vb___0, errstr, (int )tmp___6);
  }
#line 589
  if (st) {
#line 589
    return (st);
  }
#line 591
  if (rrp->naddrs >= 0) {
    {
#line 592
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 592
      tmp___7 = adns__vbuf_appendstr(vb___0, " (");
      }
#line 592
      if (! tmp___7) {
#line 592
        return ((adns_status )1);
      }
#line 592
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 593
    i = 0;
    {
#line 593
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 593
      if (! (i < (int )rrp->naddrs)) {
#line 593
        goto while_break___5;
      }
      {
#line 594
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 594
        tmp___8 = adns__vbuf_appendstr(vb___0, " ");
        }
#line 594
        if (! tmp___8) {
#line 594
          return ((adns_status )1);
        }
#line 594
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 595
      st = csp_addr___1(vb___0, (adns_rr_addr const   *)(rrp->addrs + i));
#line 593
      i ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 597
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 597
      tmp___9 = adns__vbuf_appendstr(vb___0, " )");
      }
#line 597
      if (! tmp___9) {
#line 597
        return ((adns_status )1);
      }
#line 597
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
  } else {
    {
#line 599
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 599
      tmp___10 = adns__vbuf_appendstr(vb___0, " ?");
      }
#line 599
      if (! tmp___10) {
#line 599
        return ((adns_status )1);
      }
#line 599
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
#line 601
  return ((adns_status )0);
}
}
#line 604 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_hostaddr___1(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_hostaddr const   *rrp ;
  adns_status tmp ;

  {
  {
#line 605
  rrp = (adns_rr_hostaddr const   *)datap;
#line 607
  tmp = csp_hostaddr___1(vb___0, rrp);
  }
#line 607
  return (tmp);
}
}
#line 614 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_mx_raw___1(parseinfo const   *pai , int cbyte___3 , int max ,
                                 void *datap ) 
{ 
  byte const   *dgram ;
  adns_rr_intstr *rrp ;
  adns_status st ;
  int pref ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 616
  dgram = (byte const   *)pai->dgram;
#line 617
  rrp = (adns_rr_intstr *)datap;
#line 621
  if (cbyte___3 + 2 > max) {
#line 621
    return ((adns_status )104);
  }
#line 622
  pref = 0;
#line 622
  tmp = cbyte___3;
#line 622
  cbyte___3 ++;
#line 622
  pref |= (int )(((int const   )*(dgram + tmp) & 255) << 8);
#line 622
  tmp___0 = cbyte___3;
#line 622
  cbyte___3 ++;
#line 622
  pref |= (int )((int const   )*(dgram + tmp___0) & 255);
#line 623
  rrp->i = pref;
#line 624
  if ((pai->qu)->flags & 64) {
#line 624
    tmp___1 = 1;
  } else {
#line 624
    tmp___1 = 0;
  }
  {
#line 624
  st = pap_domain___1(pai, & cbyte___3, max, & rrp->str, (parsedomain_flags )tmp___1);
  }
#line 626
  if (st) {
#line 626
    return (st);
  }
#line 628
  if (cbyte___3 != max) {
#line 628
    return ((adns_status )104);
  }
#line 629
  return ((adns_status )0);
}
}
#line 632 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_mx_raw___1(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_intstr const   *ap ;
  adns_rr_intstr const   *bp ;

  {
#line 633
  ap = (adns_rr_intstr const   *)datap_a;
#line 633
  bp = (adns_rr_intstr const   *)datap_b;
#line 635
  if (ap->i < bp->i) {
#line 635
    return (0);
  }
#line 636
  if (ap->i > bp->i) {
#line 636
    return (1);
  }
#line 637
  return (0);
}
}
#line 644 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_mx___1(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  byte const   *dgram ;
  adns_rr_inthostaddr *rrp ;
  adns_status st ;
  int pref ;
  int tmp ;
  int tmp___0 ;

  {
#line 646
  dgram = (byte const   *)pai->dgram;
#line 647
  rrp = (adns_rr_inthostaddr *)datap;
#line 651
  if (cbyte___3 + 2 > max) {
#line 651
    return ((adns_status )104);
  }
  {
#line 652
  pref = 0;
#line 652
  tmp = cbyte___3;
#line 652
  cbyte___3 ++;
#line 652
  pref |= (int )(((int const   )*(dgram + tmp) & 255) << 8);
#line 652
  tmp___0 = cbyte___3;
#line 652
  cbyte___3 ++;
#line 652
  pref |= (int )((int const   )*(dgram + tmp___0) & 255);
#line 653
  rrp->i = pref;
#line 654
  st = pap_hostaddr___1(pai, & cbyte___3, max, & rrp->ha);
  }
#line 655
  if (st) {
#line 655
    return (st);
  }
#line 657
  if (cbyte___3 != max) {
#line 657
    return ((adns_status )104);
  }
#line 658
  return ((adns_status )0);
}
}
#line 661 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_mx___1(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_inthostaddr const   *ap ;
  adns_rr_inthostaddr const   *bp ;
  int tmp ;

  {
#line 662
  ap = (adns_rr_inthostaddr const   *)datap_a;
#line 662
  bp = (adns_rr_inthostaddr const   *)datap_b;
#line 664
  if (ap->i < bp->i) {
#line 664
    return (0);
  }
#line 665
  if (ap->i > bp->i) {
#line 665
    return (1);
  }
  {
#line 666
  tmp = dip_hostaddr___1(ads___7, & ap->ha, & bp->ha);
  }
#line 666
  return (tmp);
}
}
#line 673 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_inthostaddr___1(adns_query qu , void *datap ) 
{ 
  adns_rr_inthostaddr *rrp ;

  {
  {
#line 674
  rrp = (adns_rr_inthostaddr *)datap;
#line 676
  mfp_hostaddr___1(qu, & rrp->ha);
  }
#line 677
  return;
}
}
#line 679 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_inthostaddr___1(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_inthostaddr const   *rrp ;
  char buf___17[10] ;
  int tmp ;
  adns_status tmp___0 ;

  {
  {
#line 680
  rrp = (adns_rr_inthostaddr const   *)datap;
#line 683
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"%u ",
          rrp->i);
  }
  {
#line 684
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 684
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 684
    if (! tmp) {
#line 684
      return ((adns_status )1);
    }
#line 684
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 686
  tmp___0 = csp_hostaddr___1(vb___0, & rrp->ha);
  }
#line 686
  return (tmp___0);
}
}
#line 693 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_inthost___1(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_intstr const   *rrp ;
  char buf___17[10] ;
  int tmp ;
  adns_status tmp___0 ;

  {
  {
#line 694
  rrp = (adns_rr_intstr const   *)datap;
#line 697
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"%u ",
          rrp->i);
  }
  {
#line 698
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 698
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 698
    if (! tmp) {
#line 698
      return ((adns_status )1);
    }
#line 698
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 699
  tmp___0 = csp_domain___1(vb___0, (char const   *)rrp->str);
  }
#line 699
  return (tmp___0);
}
}
#line 706 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void icb_ptr___1(adns_query parent , adns_query child ) 
{ 
  adns_answer *cans ;
  adns_rr_addr const   *queried ;
  adns_rr_addr const   *found ;
  adns_state ads___7 ;
  int i ;
  int tmp ;

  {
#line 707
  cans = child->answer;
#line 709
  ads___7 = parent->ads;
#line 712
  if ((unsigned int )cans->status == 300U) {
    {
#line 713
    adns__query_fail(parent, (adns_status )100);
    }
#line 714
    return;
  } else
#line 712
  if ((unsigned int )cans->status == 301U) {
    {
#line 713
    adns__query_fail(parent, (adns_status )100);
    }
#line 714
    return;
  } else
#line 715
  if (cans->status) {
    {
#line 716
    adns__query_fail(parent, cans->status);
    }
#line 717
    return;
  }
#line 720
  queried = (adns_rr_addr const   *)(& parent->ctx.info.ptr_parent_addr);
#line 721
  i = 0;
#line 721
  found = (adns_rr_addr const   *)cans->rrs.addr;
  {
#line 721
  while (1) {
    while_continue: /* CIL Label */ ;
#line 721
    if (! (i < cans->nrrs)) {
#line 721
      goto while_break;
    }
#line 722
    if (queried->len == found->len) {
      {
#line 722
      tmp = memcmp((void const   *)(& queried->addr), (void const   *)(& found->addr),
                   (size_t )queried->len);
      }
#line 722
      if (! tmp) {
#line 724
        if (! parent->children.head) {
          {
#line 725
          adns__query_done(parent);
          }
#line 726
          return;
        } else {
          {
#line 728
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 728
            parent->next = (adns_query )0;
#line 728
            parent->back = ads___7->childw.tail;
#line 728
            if (ads___7->childw.tail) {
#line 728
              (ads___7->childw.tail)->next = parent;
            } else {
#line 728
              ads___7->childw.head = parent;
            }
#line 728
            ads___7->childw.tail = parent;
#line 728
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 729
          return;
        }
      }
    }
#line 721
    i ++;
#line 721
    found ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 734
  adns__query_fail(parent, (adns_status )100);
  }
#line 735
  return;
}
}
#line 739
static adns_status pa_ptr___1(parseinfo const   *pai , int dmstart , int max , void *datap ) ;
#line 739 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static char const   * const  expectdomain___1[2]  = {      (char const   */* const  */)"in-addr",      (char const   */* const  */)"arpa"};
#line 737 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_ptr___1(parseinfo const   *pai , int dmstart , int max , void *datap ) 
{ 
  char **rrp ;
  adns_status st ;
  adns_rr_addr *ap ;
  findlabel_state fls ;
  char *ep ;
  byte ipv[4] ;
  char labbuf[4] ;
  int cbyte___3 ;
  int i ;
  int lablen ;
  int labstart ;
  int l ;
  int id ;
  adns_query nqu ;
  qcontext ctx ;
  int tmp ;
  unsigned long tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  typeinfo const   *tmp___3 ;

  {
#line 741
  rrp = (char **)datap;
#line 752
  cbyte___3 = dmstart;
#line 753
  if ((pai->qu)->flags & 64) {
#line 753
    tmp = 1;
  } else {
#line 753
    tmp = 0;
  }
  {
#line 753
  st = pap_domain___1(pai, & cbyte___3, max, rrp, (parsedomain_flags )tmp);
  }
#line 755
  if (st) {
#line 755
    return (st);
  }
#line 756
  if (cbyte___3 != max) {
#line 756
    return ((adns_status )104);
  }
#line 758
  ap = & (pai->qu)->ctx.info.ptr_parent_addr;
#line 759
  if (! ap->len) {
    {
#line 760
    adns__findlabel_start(& fls, (adns_state )pai->ads, -1, (adns_query )pai->qu,
                          (byte const   *)(pai->qu)->query_dgram, (pai->qu)->query_dglen,
                          (pai->qu)->query_dglen, 12, (int *)0);
#line 763
    i = 0;
    }
    {
#line 763
    while (1) {
      while_continue: /* CIL Label */ ;
#line 763
      if (! (i < 4)) {
#line 763
        goto while_break;
      }
      {
#line 764
      st = adns__findlabel_next(& fls, & lablen, & labstart);
      }
#line 764
      if (! (! st)) {
        {
#line 764
        __assert_fail("!st", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                      764U, "pa_ptr");
        }
      }
#line 765
      if (lablen <= 0) {
#line 765
        return ((adns_status )200);
      } else
#line 765
      if (lablen > 3) {
#line 765
        return ((adns_status )200);
      }
      {
#line 766
      memcpy((void */* __restrict  */)(labbuf), (void const   */* __restrict  */)((pai->qu)->query_dgram + labstart),
             (size_t )lablen);
#line 767
      labbuf[lablen] = (char)0;
#line 768
      tmp___0 = strtoul((char const   */* __restrict  */)(labbuf), (char **/* __restrict  */)(& ep),
                        10);
#line 768
      ipv[3 - i] = (byte )tmp___0;
      }
#line 769
      if (*ep) {
#line 769
        return ((adns_status )200);
      }
#line 770
      if (lablen > 1) {
#line 770
        if ((int )*((pai->qu)->query_dgram + labstart) == 48) {
#line 771
          return ((adns_status )200);
        }
      }
#line 763
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 773
    i = 0;
    {
#line 773
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 773
      if (! ((unsigned long )i < sizeof(expectdomain___1) / sizeof(expectdomain___1[0]))) {
#line 773
        goto while_break___0;
      }
      {
#line 774
      st = adns__findlabel_next(& fls, & lablen, & labstart);
      }
#line 774
      if (! (! st)) {
        {
#line 774
        __assert_fail("!st", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                      774U, "pa_ptr");
        }
      }
      {
#line 775
      tmp___1 = strlen((char const   *)expectdomain___1[i]);
#line 775
      l = (int )tmp___1;
      }
#line 776
      if (lablen != l) {
#line 778
        return ((adns_status )200);
      } else {
        {
#line 776
        tmp___2 = memcmp((void const   *)((pai->qu)->query_dgram + labstart), (void const   *)expectdomain___1[i],
                         (size_t )l);
        }
#line 776
        if (tmp___2) {
#line 778
          return ((adns_status )200);
        }
      }
#line 773
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 780
    st = adns__findlabel_next(& fls, & lablen, (int *)0);
    }
#line 780
    if (! (! st)) {
      {
#line 780
      __assert_fail("!st", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                    780U, "pa_ptr");
      }
    }
#line 781
    if (lablen) {
#line 781
      return ((adns_status )200);
    }
    {
#line 783
    ap->len = (int )sizeof(struct sockaddr_in );
#line 784
    memset((void *)(& ap->addr), 0, sizeof(ap->addr.inet));
#line 785
    ap->addr.inet.sin_family = (sa_family_t )2;
#line 786
    ap->addr.inet.sin_addr.s_addr = htonl((uint32_t )(((((int )ipv[0] << 24) | ((int )ipv[1] << 16)) | ((int )ipv[2] << 8)) | (int )ipv[3]));
    }
  }
  {
#line 790
  st = adns__mkquery_frdgram((adns_state )pai->ads, & (pai->qu)->vb, & id, (byte const   *)pai->dgram,
                             (int )pai->dglen, dmstart, (adns_rrtype )65537, (adns_queryflags )16);
  }
#line 793
  if (st) {
#line 793
    return (st);
  }
  {
#line 795
  ctx.ext = (void *)0;
#line 796
  ctx.callback = & icb_ptr___1;
#line 797
  memset((void *)(& ctx.info), 0, sizeof(ctx.info));
#line 798
  tmp___3 = adns__findtype((adns_rrtype )65537);
#line 798
  st = adns__internal_submit((adns_state )pai->ads, & nqu, tmp___3, & (pai->qu)->vb,
                             id, (adns_queryflags )16, (struct timeval )pai->now,
                             (qcontext const   *)(& ctx));
  }
#line 801
  if (st) {
#line 801
    return (st);
  }
#line 803
  nqu->parent = (adns_query )pai->qu;
  {
#line 804
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 804
    nqu->siblings.next = (adns_query )0;
#line 804
    nqu->siblings.back = (pai->qu)->children.tail;
#line 804
    if ((pai->qu)->children.tail) {
#line 804
      ((pai->qu)->children.tail)->siblings.next = nqu;
    } else {
#line 804
      (pai->qu)->children.head = nqu;
    }
#line 804
    (pai->qu)->children.tail = nqu;
#line 804
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 805
  return ((adns_status )0);
}
}
#line 812 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_strpair___1(adns_query qu , void *datap ) 
{ 
  adns_rr_strpair *rrp ;

  {
  {
#line 813
  rrp = (adns_rr_strpair *)datap;
#line 815
  adns__makefinal_str(qu, & rrp->array[0]);
#line 816
  adns__makefinal_str(qu, & rrp->array[1]);
  }
#line 817
  return;
}
}
#line 823 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_intstrpair___1(adns_query qu , void *datap ) 
{ 
  adns_rr_intstrpair *rrp ;

  {
  {
#line 824
  rrp = (adns_rr_intstrpair *)datap;
#line 826
  adns__makefinal_str(qu, & rrp->array[0].str);
#line 827
  adns__makefinal_str(qu, & rrp->array[1].str);
  }
#line 828
  return;
}
}
#line 834 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_hinfo___1(parseinfo const   *pai , int cbyte___3 , int max ,
                                void *datap ) 
{ 
  adns_rr_intstrpair *rrp ;
  adns_status st ;
  int i ;

  {
#line 836
  rrp = (adns_rr_intstrpair *)datap;
#line 840
  i = 0;
  {
#line 840
  while (1) {
    while_continue: /* CIL Label */ ;
#line 840
    if (! (i < 2)) {
#line 840
      goto while_break;
    }
    {
#line 841
    st = pap_qstring___1(pai, & cbyte___3, max, & rrp->array[i].i, & rrp->array[i].str);
    }
#line 842
    if (st) {
#line 842
      return (st);
    }
#line 840
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 845
  if (cbyte___3 != max) {
#line 845
    return ((adns_status )104);
  }
#line 847
  return ((adns_status )0);
}
}
#line 854 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_mailbox822___1(parseinfo const   *pai , int *cbyte_io , int max ,
                                      char **mb_r ) 
{ 
  int lablen ;
  int labstart ;
  int i ;
  int needquote ;
  int c ;
  int r ;
  int neednorm ;
  unsigned char const   *p ;
  char *str ;
  findlabel_state fls ;
  adns_status st ;
  vbuf *vb___0 ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 863
  vb___0 = & (pai->qu)->vb;
#line 864
  vb___0->used = 0;
#line 865
  adns__findlabel_start(& fls, (adns_state )pai->ads, -1, (adns_query )pai->qu, (byte const   *)pai->dgram,
                        (int )pai->dglen, max, *cbyte_io, cbyte_io);
#line 869
  st = adns__findlabel_next(& fls, & lablen, & labstart);
  }
#line 870
  if (! lablen) {
    {
#line 871
    adns__vbuf_appendstr(vb___0, ".");
    }
#line 872
    goto x_ok;
  }
#line 875
  neednorm = 1;
#line 876
  i = 0;
#line 876
  needquote = 0;
#line 876
  p = (unsigned char const   *)(pai->dgram + labstart);
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (! (i < lablen)) {
#line 876
      goto while_break;
    }
#line 877
    tmp = p;
#line 877
    p ++;
#line 877
    c = (int )*tmp;
#line 878
    if ((c & -129) < 32) {
#line 878
      return ((adns_status )104);
    } else
#line 878
    if ((c & -129) == 127) {
#line 878
      return ((adns_status )104);
    }
#line 879
    if (c == 46) {
#line 879
      if (! neednorm) {
#line 879
        neednorm = 1;
      } else {
#line 879
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 880
    if (c == 32) {
#line 880
      needquote ++;
    } else
#line 880
    if (c >= 127) {
#line 880
      needquote ++;
    } else {
      {
#line 880
      tmp___0 = ctype_822special(c);
      }
#line 880
      if (tmp___0) {
#line 880
        needquote ++;
      } else {
#line 881
        neednorm = 0;
      }
    }
#line 876
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 884
  if (needquote) {
#line 884
    goto _L___0;
  } else
#line 884
  if (neednorm) {
    _L___0: /* CIL Label */ 
    {
#line 885
    r = adns__vbuf_ensure(vb___0, (lablen + needquote) + 4);
    }
#line 885
    if (! r) {
#line 885
      return ((adns_status )1);
    }
    {
#line 886
    adns__vbuf_appendq(vb___0, (byte const   *)"\"", 1);
#line 887
    i = 0;
#line 887
    needquote = 0;
#line 887
    p = (unsigned char const   *)(pai->dgram + labstart);
    }
    {
#line 887
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 887
      if (! (i < lablen)) {
#line 887
        goto while_break___0;
      }
#line 888
      c = (int )*p;
#line 889
      if (c == 34) {
        {
#line 889
        adns__vbuf_appendq(vb___0, (byte const   *)"\\", 1);
        }
      } else
#line 889
      if (c == 92) {
        {
#line 889
        adns__vbuf_appendq(vb___0, (byte const   *)"\\", 1);
        }
      }
      {
#line 890
      adns__vbuf_appendq(vb___0, p, 1);
#line 887
      i ++;
#line 887
      p ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 892
    adns__vbuf_appendq(vb___0, (byte const   *)"\"", 1);
    }
  } else {
    {
#line 894
    r = adns__vbuf_append(vb___0, (byte const   *)(pai->dgram + labstart), lablen);
    }
#line 894
    if (! r) {
#line 894
      return ((adns_status )1);
    }
  }
  {
#line 897
  r = adns__vbuf_appendstr(vb___0, "@");
  }
#line 897
  if (! r) {
#line 897
    return ((adns_status )1);
  }
  {
#line 899
  st = adns__parse_domain_more(& fls, (adns_state )pai->ads, (adns_query )pai->qu,
                               vb___0, (parsedomain_flags )0, (byte const   *)pai->dgram);
  }
#line 900
  if (st) {
#line 900
    return (st);
  }
  x_ok: 
  {
#line 903
  tmp___1 = adns__alloc_interim((adns_query )pai->qu, (size_t )(vb___0->used + 1));
#line 903
  str = (char *)tmp___1;
  }
#line 903
  if (! str) {
#line 903
    return ((adns_status )1);
  }
  {
#line 904
  memcpy((void */* __restrict  */)str, (void const   */* __restrict  */)vb___0->buf,
         (size_t )vb___0->used);
#line 905
  *(str + vb___0->used) = (char)0;
#line 906
  *mb_r = str;
  }
#line 907
  return ((adns_status )0);
}
}
#line 910 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_mailbox___1(parseinfo const   *pai , int *cbyte_io , int max ,
                                   char **mb_r ) 
{ 
  adns_status tmp ;
  adns_status tmp___0 ;

  {
#line 912
  if ((unsigned int const   )((pai->qu)->typei)->typekey & 131072U) {
    {
#line 913
    tmp = pap_mailbox822___1(pai, cbyte_io, max, mb_r);
    }
#line 913
    return (tmp);
  } else {
    {
#line 915
    tmp___0 = pap_domain___1(pai, cbyte_io, max, mb_r, (parsedomain_flags )1);
    }
#line 915
    return (tmp___0);
  }
}
}
#line 919 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_mailbox___1(vbuf *vb___0 , char const   *mailbox ) 
{ 
  adns_status tmp ;

  {
  {
#line 920
  tmp = csp_domain___1(vb___0, mailbox);
  }
#line 920
  return (tmp);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_rp___1(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  adns_rr_strpair *rrp ;
  adns_status st ;

  {
  {
#line 929
  rrp = (adns_rr_strpair *)datap;
#line 932
  st = pap_mailbox___1(pai, & cbyte___3, max, & rrp->array[0]);
  }
#line 933
  if (st) {
#line 933
    return (st);
  }
  {
#line 935
  st = pap_domain___1(pai, & cbyte___3, max, & rrp->array[1], (parsedomain_flags )1);
  }
#line 936
  if (st) {
#line 936
    return (st);
  }
#line 938
  if (cbyte___3 != max) {
#line 938
    return ((adns_status )104);
  }
#line 939
  return ((adns_status )0);
}
}
#line 942 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_rp___1(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_strpair const   *rrp ;
  adns_status st ;
  int tmp ;

  {
  {
#line 943
  rrp = (adns_rr_strpair const   *)datap;
#line 946
  st = csp_mailbox___1(vb___0, (char const   *)rrp->array[0]);
  }
#line 946
  if (st) {
#line 946
    return (st);
  }
  {
#line 947
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 947
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 947
    if (! tmp) {
#line 947
      return ((adns_status )1);
    }
#line 947
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 948
  st = csp_domain___1(vb___0, (char const   *)rrp->array[1]);
  }
#line 948
  if (st) {
#line 948
    return (st);
  }
#line 950
  return ((adns_status )0);
}
}
#line 957 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_soa___1(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  adns_rr_soa *rrp ;
  byte const   *dgram ;
  adns_status st ;
  int msw ;
  int lsw ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 959
  rrp = (adns_rr_soa *)datap;
#line 960
  dgram = (byte const   *)pai->dgram;
#line 964
  if ((pai->qu)->flags & 64) {
#line 964
    tmp = 1;
  } else {
#line 964
    tmp = 0;
  }
  {
#line 964
  st = pap_domain___1(pai, & cbyte___3, max, & rrp->mname, (parsedomain_flags )tmp);
  }
#line 966
  if (st) {
#line 966
    return (st);
  }
  {
#line 968
  st = pap_mailbox___1(pai, & cbyte___3, max, & rrp->rname);
  }
#line 969
  if (st) {
#line 969
    return (st);
  }
#line 971
  if (cbyte___3 + 20 != max) {
#line 971
    return ((adns_status )104);
  }
#line 973
  i = 0;
  {
#line 973
  while (1) {
    while_continue: /* CIL Label */ ;
#line 973
    if (! (i < 5)) {
#line 973
      goto while_break;
    }
#line 974
    msw = 0;
#line 974
    tmp___0 = cbyte___3;
#line 974
    cbyte___3 ++;
#line 974
    msw |= (int )(((int const   )*(dgram + tmp___0) & 255) << 8);
#line 974
    tmp___1 = cbyte___3;
#line 974
    cbyte___3 ++;
#line 974
    msw |= (int )((int const   )*(dgram + tmp___1) & 255);
#line 975
    lsw = 0;
#line 975
    tmp___2 = cbyte___3;
#line 975
    cbyte___3 ++;
#line 975
    lsw |= (int )(((int const   )*(dgram + tmp___2) & 255) << 8);
#line 975
    tmp___3 = cbyte___3;
#line 975
    cbyte___3 ++;
#line 975
    lsw |= (int )((int const   )*(dgram + tmp___3) & 255);
#line 976
    *(& rrp->serial + i) = (unsigned long )((msw << 16) | lsw);
#line 973
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 979
  return ((adns_status )0);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_soa___1(adns_query qu , void *datap ) 
{ 
  adns_rr_soa *rrp ;

  {
  {
#line 983
  rrp = (adns_rr_soa *)datap;
#line 985
  adns__makefinal_str(qu, & rrp->mname);
#line 986
  adns__makefinal_str(qu, & rrp->rname);
  }
#line 987
  return;
}
}
#line 989 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_soa___1(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_soa const   *rrp ;
  char buf___17[20] ;
  int i ;
  adns_status st ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 990
  rrp = (adns_rr_soa const   *)datap;
#line 995
  st = csp_domain___1(vb___0, (char const   *)rrp->mname);
  }
#line 995
  if (st) {
#line 995
    return (st);
  }
  {
#line 996
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 996
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 996
    if (! tmp) {
#line 996
      return ((adns_status )1);
    }
#line 996
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 997
  st = csp_mailbox___1(vb___0, (char const   *)rrp->rname);
  }
#line 997
  if (st) {
#line 997
    return (st);
  }
#line 999
  i = 0;
  {
#line 999
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 999
    if (! (i < 5)) {
#line 999
      goto while_break___0;
    }
    {
#line 1000
    sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %lu",
            *(& rrp->serial + i));
    }
    {
#line 1001
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1001
      tmp___0 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
      }
#line 1001
      if (! tmp___0) {
#line 1001
        return ((adns_status )1);
      }
#line 1001
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 999
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1004
  return ((adns_status )0);
}
}
#line 1011 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status qdpl_srv___1(adns_state ads___7 , char const   **p_io , char const   *pe ,
                                int labelnum , char *label_r , int *ll_io , adns_queryflags flags ,
                                typeinfo const   *typei ) 
{ 
  int useflags ;
  char const   *p_orig ;
  adns_status st ;
  int ll ;
  void *tmp ;

  {
#line 1020
  if (labelnum < 2) {
#line 1020
    if (! ((unsigned int )flags & 16U)) {
#line 1021
      useflags = 16;
#line 1022
      p_orig = *p_io;
    } else {
#line 1024
      useflags = (int )flags;
#line 1025
      p_orig = (char const   *)0;
    }
  } else {
#line 1024
    useflags = (int )flags;
#line 1025
    p_orig = (char const   *)0;
  }
  {
#line 1027
  st = adns__qdpl_normal(ads___7, p_io, pe, labelnum, (char *)label_r, ll_io, (adns_queryflags )useflags,
                         typei);
  }
#line 1028
  if (st) {
#line 1028
    return (st);
  }
#line 1030
  if (p_orig) {
#line 1031
    ll = *ll_io;
#line 1032
    if (! ll) {
#line 1033
      return ((adns_status )201);
    } else
#line 1032
    if ((int )*(label_r + 0) != 95) {
#line 1033
      return ((adns_status )201);
    }
    {
#line 1034
    tmp = memchr((void const   *)(p_orig + 1), '\\', (size_t )(pe - (p_orig + 1)));
    }
#line 1034
    if (tmp) {
#line 1035
      return ((adns_status )201);
    }
  }
#line 1037
  return ((adns_status )0);
}
}
#line 1040 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_srv_begin___1(parseinfo const   *pai , int *cbyte_io , int max ,
                                     adns_rr_srvha *rrp ) 
{ 
  byte const   *dgram ;
  int ti ;
  int cbyte___3 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1043
  dgram = (byte const   *)pai->dgram;
#line 1046
  cbyte___3 = *cbyte_io;
#line 1047
  tmp = *cbyte_io + 6;
#line 1047
  *cbyte_io = tmp;
#line 1047
  if (tmp > max) {
#line 1047
    return ((adns_status )104);
  }
#line 1049
  ti = 0;
#line 1049
  tmp___0 = cbyte___3;
#line 1049
  cbyte___3 ++;
#line 1049
  ti |= (int )(((int const   )*(dgram + tmp___0) & 255) << 8);
#line 1049
  tmp___1 = cbyte___3;
#line 1049
  cbyte___3 ++;
#line 1049
  ti |= (int )((int const   )*(dgram + tmp___1) & 255);
#line 1049
  rrp->priority = ti;
#line 1050
  ti = 0;
#line 1050
  tmp___2 = cbyte___3;
#line 1050
  cbyte___3 ++;
#line 1050
  ti |= (int )(((int const   )*(dgram + tmp___2) & 255) << 8);
#line 1050
  tmp___3 = cbyte___3;
#line 1050
  cbyte___3 ++;
#line 1050
  ti |= (int )((int const   )*(dgram + tmp___3) & 255);
#line 1050
  rrp->weight = ti;
#line 1051
  ti = 0;
#line 1051
  tmp___4 = cbyte___3;
#line 1051
  cbyte___3 ++;
#line 1051
  ti |= (int )(((int const   )*(dgram + tmp___4) & 255) << 8);
#line 1051
  tmp___5 = cbyte___3;
#line 1051
  cbyte___3 ++;
#line 1051
  ti |= (int )((int const   )*(dgram + tmp___5) & 255);
#line 1051
  rrp->port = ti;
#line 1052
  return ((adns_status )0);
}
}
#line 1055 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_srvraw___1(parseinfo const   *pai , int cbyte___3 , int max ,
                                 void *datap ) 
{ 
  adns_rr_srvraw *rrp ;
  adns_status st ;
  int tmp ;

  {
  {
#line 1057
  rrp = (adns_rr_srvraw *)datap;
#line 1060
  st = pap_srv_begin___1(pai, & cbyte___3, max, (adns_rr_srvha *)datap);
  }
#line 1061
  if (st) {
#line 1061
    return (st);
  }
#line 1063
  if ((pai->qu)->flags & 64) {
#line 1063
    tmp = 1;
  } else {
#line 1063
    tmp = 0;
  }
  {
#line 1063
  st = pap_domain___1(pai, & cbyte___3, max, & rrp->host, (parsedomain_flags )tmp);
  }
#line 1065
  if (st) {
#line 1065
    return (st);
  }
#line 1067
  if (cbyte___3 != max) {
#line 1067
    return ((adns_status )104);
  }
#line 1068
  return ((adns_status )0);
}
}
#line 1071 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_srvha___1(parseinfo const   *pai , int cbyte___3 , int max ,
                                void *datap ) 
{ 
  adns_rr_srvha *rrp ;
  adns_status st ;

  {
  {
#line 1073
  rrp = (adns_rr_srvha *)datap;
#line 1076
  st = pap_srv_begin___1(pai, & cbyte___3, max, (adns_rr_srvha *)datap);
  }
#line 1076
  if (st) {
#line 1076
    return (st);
  }
  {
#line 1077
  st = pap_hostaddr___1(pai, & cbyte___3, max, & rrp->ha);
  }
#line 1077
  if (st) {
#line 1077
    return (st);
  }
#line 1078
  if (cbyte___3 != max) {
#line 1078
    return ((adns_status )104);
  }
#line 1079
  return ((adns_status )0);
}
}
#line 1082 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_srvraw___1(adns_query qu , void *datap ) 
{ 
  adns_rr_srvraw *rrp ;

  {
  {
#line 1083
  rrp = (adns_rr_srvraw *)datap;
#line 1084
  adns__makefinal_str(qu, & rrp->host);
  }
#line 1085
  return;
}
}
#line 1087 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_srvha___1(adns_query qu , void *datap ) 
{ 
  adns_rr_srvha *rrp ;

  {
  {
#line 1088
  rrp = (adns_rr_srvha *)datap;
#line 1089
  mfp_hostaddr___1(qu, & rrp->ha);
  }
#line 1090
  return;
}
}
#line 1092 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_srv___1(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_srvraw const   *ap ;
  adns_rr_srvraw const   *bp ;

  {
#line 1093
  ap = (adns_rr_srvraw const   *)datap_a;
#line 1093
  bp = (adns_rr_srvraw const   *)datap_b;
#line 1096
  if (ap->priority < bp->priority) {
#line 1096
    return (0);
  }
#line 1097
  if (ap->priority > bp->priority) {
#line 1097
    return (1);
  }
#line 1098
  return (0);
}
}
#line 1101 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_srv_begin___1(vbuf *vb___0 , adns_rr_srvha const   *rrp ) 
{ 
  char buf___17[30] ;
  int tmp ;

  {
  {
#line 1104
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"%u %u %u ",
          rrp->priority, rrp->weight, rrp->port);
  }
  {
#line 1105
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1105
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 1105
    if (! tmp) {
#line 1105
      return ((adns_status )1);
    }
#line 1105
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1106
  return ((adns_status )0);
}
}
#line 1109 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_srvraw___1(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_srvraw const   *rrp ;
  adns_status st ;
  adns_status tmp ;

  {
  {
#line 1110
  rrp = (adns_rr_srvraw const   *)datap;
#line 1113
  st = csp_srv_begin___1(vb___0, (adns_rr_srvha const   *)((void const   *)rrp));
  }
#line 1113
  if (st) {
#line 1113
    return (st);
  }
  {
#line 1114
  tmp = csp_domain___1(vb___0, (char const   *)rrp->host);
  }
#line 1114
  return (tmp);
}
}
#line 1117 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_srvha___1(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_srvha const   *rrp ;
  adns_status st ;
  adns_status tmp ;

  {
  {
#line 1118
  rrp = (adns_rr_srvha const   *)datap;
#line 1121
  st = csp_srv_begin___1(vb___0, (adns_rr_srvha const   *)datap);
  }
#line 1121
  if (st) {
#line 1121
    return (st);
  }
  {
#line 1122
  tmp = csp_hostaddr___1(vb___0, & rrp->ha);
  }
#line 1122
  return (tmp);
}
}
#line 1125 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void postsort_srv___1(adns_state ads___7 , void *array , int nrrs , struct typeinfo  const  *typei ) 
{ 
  char *workbegin ;
  char *workend ;
  char *search ;
  char *arrayend ;
  adns_rr_srvha const   *rr ;
  union __anonunion_rrtmp_89___1 rrtmp ;
  int cpriority ;
  int totalweight ;
  int runtotal ;
  long randval ;

  {
#line 1138
  workbegin = (char *)array;
#line 1138
  arrayend = workbegin + typei->rrsz * (int const   )nrrs;
  {
#line 1138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1138
    if (! ((unsigned long )workbegin < (unsigned long )arrayend)) {
#line 1138
      goto while_break;
    }
#line 1141
    rr = (adns_rr_srvha const   *)((void *)workbegin);
#line 1141
    cpriority = (int )rr->priority;
#line 1143
    workend = workbegin;
#line 1143
    totalweight = 0;
    {
#line 1143
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1143
      if ((unsigned long )workend < (unsigned long )arrayend) {
#line 1143
        rr = (adns_rr_srvha const   *)((void *)workend);
#line 1143
        if (! (rr->priority == (int const   )cpriority)) {
#line 1143
          goto while_break___0;
        }
      } else {
#line 1143
        goto while_break___0;
      }
#line 1146
      totalweight += (int )rr->weight;
#line 1143
      workend += typei->rrsz;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1155
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1155
      if (! ((unsigned long )(workbegin + typei->rrsz) < (unsigned long )workend)) {
#line 1155
        goto while_break___1;
      }
      {
#line 1159
      randval = nrand48((unsigned short *)(ads___7->rand48xsubi));
#line 1160
      randval %= (long )(totalweight + 1);
#line 1167
      search = workbegin;
#line 1167
      runtotal = 0;
      }
      {
#line 1167
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1167
        rr = (adns_rr_srvha const   *)((void *)search);
#line 1167
        runtotal += (int )rr->weight;
#line 1167
        if (! ((long )runtotal < randval)) {
#line 1167
          goto while_break___2;
        }
#line 1167
        search += typei->rrsz;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1170
      if (! ((unsigned long )search < (unsigned long )arrayend)) {
        {
#line 1170
        __assert_fail("search < arrayend", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                      1170U, "postsort_srv");
        }
      }
#line 1171
      totalweight -= (int )rr->weight;
#line 1172
      if ((unsigned long )search != (unsigned long )workbegin) {
        {
#line 1173
        memcpy((void */* __restrict  */)(& rrtmp), (void const   */* __restrict  */)workbegin,
               (size_t )typei->rrsz);
#line 1174
        memcpy((void */* __restrict  */)workbegin, (void const   */* __restrict  */)search,
               (size_t )typei->rrsz);
#line 1175
        memcpy((void */* __restrict  */)search, (void const   */* __restrict  */)(& rrtmp),
               (size_t )typei->rrsz);
        }
      }
#line 1155
      workbegin += typei->rrsz;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1138
    workbegin = workend;
  }
  while_break: /* CIL Label */ ;
  }
#line 1184
  return;
}
}
#line 1190 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_byteblock___1(adns_query qu , void *datap ) 
{ 
  adns_rr_byteblock *rrp ;
  void *bytes___3 ;

  {
  {
#line 1191
  rrp = (adns_rr_byteblock *)datap;
#line 1192
  bytes___3 = (void *)rrp->data;
#line 1193
  adns__makefinal_block(qu, & bytes___3, (size_t )rrp->len);
#line 1194
  rrp->data = (unsigned char *)bytes___3;
  }
#line 1195
  return;
}
}
#line 1201 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_opaque___1(parseinfo const   *pai , int cbyte___3 , int max ,
                                 void *datap ) 
{ 
  adns_rr_byteblock *rrp ;
  void *tmp ;

  {
  {
#line 1203
  rrp = (adns_rr_byteblock *)datap;
#line 1205
  rrp->len = max - cbyte___3;
#line 1206
  tmp = adns__alloc_interim((adns_query )pai->qu, (size_t )rrp->len);
#line 1206
  rrp->data = (unsigned char *)tmp;
  }
#line 1207
  if (! rrp->data) {
#line 1207
    return ((adns_status )1);
  }
  {
#line 1208
  memcpy((void */* __restrict  */)rrp->data, (void const   */* __restrict  */)(pai->dgram + cbyte___3),
         (size_t )rrp->len);
  }
#line 1209
  return ((adns_status )0);
}
}
#line 1212 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_opaque___1(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_byteblock const   *rrp ;
  char buf___17[10] ;
  int l ;
  unsigned char *p ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1213
  rrp = (adns_rr_byteblock const   *)datap;
#line 1218
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"\\# %d",
          rrp->len);
  }
  {
#line 1219
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1219
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 1219
    if (! tmp) {
#line 1219
      return ((adns_status )1);
    }
#line 1219
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1221
  l = (int )rrp->len;
#line 1221
  p = (unsigned char *)rrp->data;
  {
#line 1221
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1221
    if (! (l >= 4)) {
#line 1221
      goto while_break___0;
    }
    {
#line 1224
    sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %02x%02x%02x%02x",
            (int )*(p + 0), (int )*(p + 1), (int )*(p + 2), (int )*(p + 3));
    }
    {
#line 1225
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1225
      tmp___0 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
      }
#line 1225
      if (! tmp___0) {
#line 1225
        return ((adns_status )1);
      }
#line 1225
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1221
    l -= 4;
#line 1221
    p += 4;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1227
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1227
    if (! (l > 0)) {
#line 1227
      goto while_break___2;
    }
    {
#line 1230
    sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %02x",
            (int )*p);
    }
    {
#line 1231
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 1231
      tmp___1 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
      }
#line 1231
      if (! tmp___1) {
#line 1231
        return ((adns_status )1);
      }
#line 1231
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1227
    l --;
#line 1227
    p ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1233
  return ((adns_status )0);
}
}
#line 1240 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_flat___1(adns_query qu , void *data___0 ) 
{ 


  {
#line 1240
  return;
}
}
#line 1261 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static typeinfo const   typeinfos___1[17]  = 
#line 1261
  {      {(adns_rrtype )1, "A", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.inaddr)),
      & mf_flat___1, & cs_inaddr___1, & pa_inaddr___1, & di_inaddr___1, (adns_status (*)(adns_state ads ,
                                                                                         char const   **p_io ,
                                                                                         char const   *pe ,
                                                                                         int labelnum ,
                                                                                         char *label_r ,
                                                                                         int *ll_io ,
                                                                                         adns_queryflags flags ,
                                                                                         struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )2,
      "NS", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___1, & cs_domain___1,
      & pa_host_raw___1, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )5,
      "CNAME", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___1,
      & cs_domain___1, & pa_dom_raw___1, (int (*)(adns_state ads , void const   *datap_a ,
                                                  void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                              char const   **p_io ,
                                                                                              char const   *pe ,
                                                                                              int labelnum ,
                                                                                              char *label_r ,
                                                                                              int *ll_io ,
                                                                                              adns_queryflags flags ,
                                                                                              struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )6,
      "SOA", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.soa)), & mf_soa___1, & cs_soa___1,
      & pa_soa___1, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )12,
      "PTR", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___1, & cs_domain___1,
      & pa_host_raw___1, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )13,
      "HINFO", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.intstrpair)),
      & mf_intstrpair___1, & cs_hinfo___1, & pa_hinfo___1, (int (*)(adns_state ads ,
                                                                    void const   *datap_a ,
                                                                    void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )15,
      "MX", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.intstr)), & mf_intstr___1,
      & cs_inthost___1, & pa_mx_raw___1, & di_mx_raw___1, (adns_status (*)(adns_state ads ,
                                                                           char const   **p_io ,
                                                                           char const   *pe ,
                                                                           int labelnum ,
                                                                           char *label_r ,
                                                                           int *ll_io ,
                                                                           adns_queryflags flags ,
                                                                           struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )16,
      "TXT", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.manyistr)),
      & mf_manyistr___1, & cs_txt___1, & pa_txt___1, (int (*)(adns_state ads , void const   *datap_a ,
                                                              void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )17,
      "RP", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.strpair)), & mf_strpair___1,
      & cs_rp___1, & pa_rp___1, (int (*)(adns_state ads , void const   *datap_a ,
                                         void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                     char const   **p_io ,
                                                                                     char const   *pe ,
                                                                                     int labelnum ,
                                                                                     char *label_r ,
                                                                                     int *ll_io ,
                                                                                     adns_queryflags flags ,
                                                                                     struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )33,
      "SRV", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.srvraw)), & mf_srvraw___1,
      & cs_srvraw___1, & pa_srvraw___1, & di_srv___1, & qdpl_srv___1, & postsort_srv___1}, 
        {(adns_rrtype )65537,
      "A", "addr", (int )sizeof(*(((adns_answer *)0)->rrs.addr)), & mf_flat___1, & cs_addr___1,
      & pa_addr___1, & di_addr___1, (adns_status (*)(adns_state ads , char const   **p_io ,
                                                     char const   *pe , int labelnum ,
                                                     char *label_r , int *ll_io ,
                                                     adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65538,
      "NS", "+addr", (int )sizeof(*(((adns_answer *)0)->rrs.hostaddr)), & mf_hostaddr___1,
      & cs_hostaddr___1, & pa_hostaddr___1, & di_hostaddr___1, (adns_status (*)(adns_state ads ,
                                                                                char const   **p_io ,
                                                                                char const   *pe ,
                                                                                int labelnum ,
                                                                                char *label_r ,
                                                                                int *ll_io ,
                                                                                adns_queryflags flags ,
                                                                                struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65548,
      "PTR", "checked", (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___1,
      & cs_domain___1, & pa_ptr___1, (int (*)(adns_state ads , void const   *datap_a ,
                                              void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                          char const   **p_io ,
                                                                                          char const   *pe ,
                                                                                          int labelnum ,
                                                                                          char *label_r ,
                                                                                          int *ll_io ,
                                                                                          adns_queryflags flags ,
                                                                                          struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65551,
      "MX", "+addr", (int )sizeof(*(((adns_answer *)0)->rrs.inthostaddr)), & mf_inthostaddr___1,
      & cs_inthostaddr___1, & pa_mx___1, & di_mx___1, (adns_status (*)(adns_state ads ,
                                                                       char const   **p_io ,
                                                                       char const   *pe ,
                                                                       int labelnum ,
                                                                       char *label_r ,
                                                                       int *ll_io ,
                                                                       adns_queryflags flags ,
                                                                       struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65569,
      "SRV", "+addr", (int )sizeof(*(((adns_answer *)0)->rrs.srvha)), & mf_srvha___1,
      & cs_srvha___1, & pa_srvha___1, & di_srv___1, & qdpl_srv___1, & postsort_srv___1}, 
        {(adns_rrtype )131078,
      "SOA", "822", (int )sizeof(*(((adns_answer *)0)->rrs.soa)), & mf_soa___1, & cs_soa___1,
      & pa_soa___1, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )131089,
      "RP", "822", (int )sizeof(*(((adns_answer *)0)->rrs.strpair)), & mf_strpair___1,
      & cs_rp___1, & pa_rp___1, (int (*)(adns_state ads , void const   *datap_a ,
                                         void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                     char const   **p_io ,
                                                                                     char const   *pe ,
                                                                                     int labelnum ,
                                                                                     char *label_r ,
                                                                                     int *ll_io ,
                                                                                     adns_queryflags flags ,
                                                                                     struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}};
#line 1288 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static struct typeinfo  const  typeinfo_unknown___1  = 
#line 1288
     {(adns_rrtype )262144, (char const   *)0, "unknown", (int )sizeof(*(((adns_answer *)0)->rrs.byteblock)),
    & mf_byteblock___1, & cs_opaque___1, & pa_opaque___1, (int (*)(adns_state ads ,
                                                                   void const   *datap_a ,
                                                                   void const   *datap_b ))0,
    (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                     char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
    (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0};
#line 55 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_query_alloc___1(adns_state ads___7 , adns_query qu ) 
{ 
  allocnode *an ;
  int tmp ;

  {
#line 58
  if (qu->allocations.head) {
#line 58
    if (! (! (qu->allocations.head)->back)) {
      {
#line 58
      __assert_fail("! (qu->allocations).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    59U, "checkc_query_alloc");
      }
    }
#line 58
    an = qu->allocations.head;
    {
#line 58
    while (1) {
      while_continue: /* CIL Label */ ;
#line 58
      if (! an) {
#line 58
        goto while_break;
      }
#line 58
      if (an->next) {
#line 58
        tmp = (unsigned long )an == (unsigned long )(an->next)->back;
      } else {
#line 58
        tmp = (unsigned long )an == (unsigned long )qu->allocations.tail;
      }
#line 58
      if (! tmp) {
        {
#line 58
        __assert_fail("(an)-> next ? (an) == (an)-> next-> back : (an) == (qu->allocations).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      59U, "checkc_query_alloc");
        }
      }
#line 58
      an = an->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 60
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_query___1(adns_state ads___7 , adns_query qu ) 
{ 
  adns_query child ;

  {
#line 65
  if (! (qu->udpnextserver < ads___7->nservers)) {
    {
#line 65
    __assert_fail("qu->udpnextserver < ads->nservers", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  65U, "checkc_query");
    }
  }
#line 66
  if (! (! (qu->udpsent & (0xffffffffffffffffUL << ads___7->nservers)))) {
    {
#line 66
    __assert_fail("!(qu->udpsent & (~0UL << ads->nservers))", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  66U, "checkc_query");
    }
  }
#line 67
  if (! (qu->search_pos <= ads___7->nsearchlist)) {
    {
#line 67
    __assert_fail("qu->search_pos <= ads->nsearchlist", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  67U, "checkc_query");
    }
  }
#line 68
  if (qu->parent) {
    {
#line 68
    while (1) {
      while_continue: /* CIL Label */ ;
#line 68
      child = (qu->parent)->children.head;
      {
#line 68
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 68
        if (! ((unsigned long )child != (unsigned long )qu)) {
#line 68
          goto while_break___0;
        }
#line 68
        if (! child) {
          {
#line 68
          __assert_fail("(child)", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        68U, "checkc_query");
          }
        }
#line 68
        child = child->siblings.next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 68
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 69
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_notcpbuf___1(adns_state ads___7 ) 
{ 


  {
#line 72
  if (! (! ads___7->tcpsend.used)) {
    {
#line 72
    __assert_fail("!ads->tcpsend.used", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  72U, "checkc_notcpbuf");
    }
  }
#line 73
  if (! (! ads___7->tcprecv.used)) {
    {
#line 73
    __assert_fail("!ads->tcprecv.used", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  73U, "checkc_notcpbuf");
    }
  }
#line 74
  if (! (! ads___7->tcprecv_skip)) {
    {
#line 74
    __assert_fail("!ads->tcprecv_skip", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  74U, "checkc_notcpbuf");
    }
  }
#line 75
  return;
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_global___1(adns_state ads___7 ) 
{ 
  int i ;

  {
#line 80
  if (! (ads___7->udpsocket >= 0)) {
    {
#line 80
    __assert_fail("ads->udpsocket >= 0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  80U, "checkc_global");
    }
  }
#line 82
  i = 0;
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! (i < ads___7->nsortlist)) {
#line 82
      goto while_break;
    }
#line 83
    if (! (! (ads___7->sortlist[i].base.s_addr & ~ ads___7->sortlist[i].mask.s_addr))) {
      {
#line 83
      __assert_fail("!(ads->sortlist[i].base.s_addr & ~ads->sortlist[i].mask.s_addr)",
                    "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    83U, "checkc_global");
      }
    }
#line 82
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  if (ads___7->tcpserver >= 0) {
#line 85
    if (! (ads___7->tcpserver < ads___7->nservers)) {
      {
#line 85
      __assert_fail("ads->tcpserver >= 0 && ads->tcpserver < ads->nservers", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    85U, "checkc_global");
      }
    }
  } else {
    {
#line 85
    __assert_fail("ads->tcpserver >= 0 && ads->tcpserver < ads->nservers", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  85U, "checkc_global");
    }
  }
  {
#line 88
  if ((unsigned int )ads___7->tcpstate == 1U) {
#line 88
    goto case_1;
  }
#line 93
  if ((unsigned int )ads___7->tcpstate == 3U) {
#line 93
    goto case_3;
  }
#line 93
  if ((unsigned int )ads___7->tcpstate == 0U) {
#line 93
    goto case_3;
  }
#line 97
  if ((unsigned int )ads___7->tcpstate == 2U) {
#line 97
    goto case_2;
  }
#line 101
  goto switch_default;
  case_1: /* CIL Label */ 
#line 89
  if (! (ads___7->tcpsocket >= 0)) {
    {
#line 89
    __assert_fail("ads->tcpsocket >= 0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  89U, "checkc_global");
    }
  }
  {
#line 90
  checkc_notcpbuf___1(ads___7);
  }
#line 91
  goto switch_break;
  case_3: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 94
  if (! (ads___7->tcpsocket == -1)) {
    {
#line 94
    __assert_fail("ads->tcpsocket == -1", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  94U, "checkc_global");
    }
  }
  {
#line 95
  checkc_notcpbuf___1(ads___7);
  }
#line 96
  goto switch_break;
  case_2: /* CIL Label */ 
#line 98
  if (! (ads___7->tcpsocket >= 0)) {
    {
#line 98
    __assert_fail("ads->tcpsocket >= 0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  98U, "checkc_global");
    }
  }
#line 99
  if (! (ads___7->tcprecv_skip <= ads___7->tcprecv.used)) {
    {
#line 99
    __assert_fail("ads->tcprecv_skip <= ads->tcprecv.used", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  99U, "checkc_global");
    }
  }
#line 100
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 102
  __assert_fail("!\"ads->tcpstate value\"", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                102U, "checkc_global");
  }
  switch_break: /* CIL Label */ ;
  }
#line 105
  if (! ads___7->searchlist) {
#line 105
    if (! (! ads___7->nsearchlist)) {
      {
#line 105
      __assert_fail("ads->searchlist || !ads->nsearchlist", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    105U, "checkc_global");
      }
    }
  }
#line 106
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_queue_udpw___1(adns_state ads___7 ) 
{ 
  adns_query qu ;
  int tmp ;

  {
#line 111
  if (ads___7->udpw.head) {
#line 111
    if (! (! (ads___7->udpw.head)->back)) {
      {
#line 111
      __assert_fail("! (ads->udpw).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    118U, "checkc_queue_udpw");
      }
    }
#line 111
    qu = ads___7->udpw.head;
    {
#line 111
    while (1) {
      while_continue: /* CIL Label */ ;
#line 111
      if (! qu) {
#line 111
        goto while_break;
      }
#line 111
      if (qu->next) {
#line 111
        tmp = (unsigned long )qu == (unsigned long )(qu->next)->back;
      } else {
#line 111
        tmp = (unsigned long )qu == (unsigned long )ads___7->udpw.tail;
      }
#line 111
      if (! tmp) {
        {
#line 111
        __assert_fail("(qu)-> next ? (qu) == (qu)-> next-> back : (qu) == (ads->udpw).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! ((unsigned int )qu->state == 0U)) {
        {
#line 111
        __assert_fail("qu->state==query_tosend", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! (qu->retries <= 15)) {
        {
#line 111
        __assert_fail("qu->retries <= 15", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! qu->udpsent) {
        {
#line 111
        __assert_fail("qu->udpsent", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! qu->children.head) {
#line 111
        if (! (! qu->children.tail)) {
          {
#line 111
          __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        118U, "checkc_queue_udpw");
          }
        }
      } else {
        {
#line 111
        __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
      {
#line 111
      checkc_query___1(ads___7, qu);
#line 111
      checkc_query_alloc___1(ads___7, qu);
#line 111
      qu = qu->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 119
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_queue_tcpw___1(adns_state ads___7 ) 
{ 
  adns_query qu ;
  int tmp ;

  {
#line 124
  if (ads___7->tcpw.head) {
#line 124
    if (! (! (ads___7->tcpw.head)->back)) {
      {
#line 124
      __assert_fail("! (ads->tcpw).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    130U, "checkc_queue_tcpw");
      }
    }
#line 124
    qu = ads___7->tcpw.head;
    {
#line 124
    while (1) {
      while_continue: /* CIL Label */ ;
#line 124
      if (! qu) {
#line 124
        goto while_break;
      }
#line 124
      if (qu->next) {
#line 124
        tmp = (unsigned long )qu == (unsigned long )(qu->next)->back;
      } else {
#line 124
        tmp = (unsigned long )qu == (unsigned long )ads___7->tcpw.tail;
      }
#line 124
      if (! tmp) {
        {
#line 124
        __assert_fail("(qu)-> next ? (qu) == (qu)-> next-> back : (qu) == (ads->tcpw).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
#line 124
      if (! ((unsigned int )qu->state == 1U)) {
        {
#line 124
        __assert_fail("qu->state==query_tcpw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
#line 124
      if (! qu->children.head) {
#line 124
        if (! (! qu->children.tail)) {
          {
#line 124
          __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        130U, "checkc_queue_tcpw");
          }
        }
      } else {
        {
#line 124
        __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
#line 124
      if (! (qu->retries <= ads___7->nservers + 1)) {
        {
#line 124
        __assert_fail("qu->retries <= ads->nservers+1", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
      {
#line 124
      checkc_query___1(ads___7, qu);
#line 124
      checkc_query_alloc___1(ads___7, qu);
#line 124
      qu = qu->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 131
  return;
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_queue_childw___1(adns_state ads___7 ) 
{ 
  adns_query parent ;
  adns_query child ;
  int tmp ;
  int tmp___0 ;

  {
#line 136
  if (ads___7->childw.head) {
#line 136
    if (! (! (ads___7->childw.head)->back)) {
      {
#line 136
      __assert_fail("! (ads->childw).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    145U, "checkc_queue_childw");
      }
    }
#line 136
    parent = ads___7->childw.head;
    {
#line 136
    while (1) {
      while_continue: /* CIL Label */ ;
#line 136
      if (! parent) {
#line 136
        goto while_break;
      }
#line 136
      if (parent->next) {
#line 136
        tmp = (unsigned long )parent == (unsigned long )(parent->next)->back;
      } else {
#line 136
        tmp = (unsigned long )parent == (unsigned long )ads___7->childw.tail;
      }
#line 136
      if (! tmp) {
        {
#line 136
        __assert_fail("(parent)-> next ? (parent) == (parent)-> next-> back : (parent) == (ads->childw).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      145U, "checkc_queue_childw");
        }
      }
#line 136
      if (! ((unsigned int )parent->state == 2U)) {
        {
#line 136
        __assert_fail("parent->state == query_childw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      145U, "checkc_queue_childw");
        }
      }
#line 136
      if (! parent->children.head) {
        {
#line 136
        __assert_fail("parent->children.head", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      145U, "checkc_queue_childw");
        }
      }
#line 136
      if (parent->children.head) {
#line 136
        if (! (! (parent->children.head)->siblings.back)) {
          {
#line 136
          __assert_fail("! (parent->children).head->siblings. back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        145U, "checkc_queue_childw");
          }
        }
#line 136
        child = parent->children.head;
        {
#line 136
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 136
          if (! child) {
#line 136
            goto while_break___0;
          }
#line 136
          if (child->siblings.next) {
#line 136
            tmp___0 = (unsigned long )child == (unsigned long )(child->siblings.next)->siblings.back;
          } else {
#line 136
            tmp___0 = (unsigned long )child == (unsigned long )parent->children.tail;
          }
#line 136
          if (! tmp___0) {
            {
#line 136
            __assert_fail("(child)->siblings. next ? (child) == (child)->siblings. next->siblings. back : (child) == (parent->children).tail",
                          "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                          145U, "checkc_queue_childw");
            }
          }
#line 136
          if (! ((unsigned long )child->parent == (unsigned long )parent)) {
            {
#line 136
            __assert_fail("child->parent == parent", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                          145U, "checkc_queue_childw");
            }
          }
#line 136
          if (! ((unsigned int )child->state != 3U)) {
            {
#line 136
            __assert_fail("child->state != query_done", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                          145U, "checkc_queue_childw");
            }
          }
#line 136
          child = child->siblings.next;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 136
      checkc_query___1(ads___7, parent);
#line 136
      checkc_query_alloc___1(ads___7, parent);
#line 136
      parent = parent->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 146
  return;
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_queue_output___1(adns_state ads___7 ) 
{ 
  adns_query qu ;
  int tmp ;

  {
#line 151
  if (ads___7->output.head) {
#line 151
    if (! (! (ads___7->output.head)->back)) {
      {
#line 151
      __assert_fail("! (ads->output).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    157U, "checkc_queue_output");
      }
    }
#line 151
    qu = ads___7->output.head;
    {
#line 151
    while (1) {
      while_continue: /* CIL Label */ ;
#line 151
      if (! qu) {
#line 151
        goto while_break;
      }
#line 151
      if (qu->next) {
#line 151
        tmp = (unsigned long )qu == (unsigned long )(qu->next)->back;
      } else {
#line 151
        tmp = (unsigned long )qu == (unsigned long )ads___7->output.tail;
      }
#line 151
      if (! tmp) {
        {
#line 151
        __assert_fail("(qu)-> next ? (qu) == (qu)-> next-> back : (qu) == (ads->output).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! ((unsigned int )qu->state == 3U)) {
        {
#line 151
        __assert_fail("qu->state == query_done", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! qu->children.head) {
#line 151
        if (! (! qu->children.tail)) {
          {
#line 151
          __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        157U, "checkc_queue_output");
          }
        }
      } else {
        {
#line 151
        __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! (! qu->parent)) {
        {
#line 151
        __assert_fail("!qu->parent", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! qu->allocations.head) {
#line 151
        if (! (! qu->allocations.tail)) {
          {
#line 151
          __assert_fail("!qu->allocations.head && !qu->allocations.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        157U, "checkc_queue_output");
          }
        }
      } else {
        {
#line 151
        __assert_fail("!qu->allocations.head && !qu->allocations.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
      {
#line 151
      checkc_query___1(ads___7, qu);
#line 151
      qu = qu->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 158
  return;
}
}
#line 289 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnstest.c"
static struct myctx *mcs  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnstest.c"
static adns_state ads___0  ;
#line 50 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnstest.c"
static adns_rrtype *types_a  ;
#line 52
static  __attribute__((__noreturn__)) void quitnow___0(int rc ) ;
#line 53
static  __attribute__((__noreturn__)) void quitnow___0(int rc ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnstest.c"
static void quitnow___0(int rc ) 
{ 


  {
  {
#line 54
  Hfree((void *)mcs);
#line 55
  Hfree((void *)types_a);
  }
#line 56
  if (ads___0) {
    {
#line 56
    adns_finish(ads___0);
    }
  }
  {
#line 58
  Hexit(rc);
  }
}
}
#line 71
static  __attribute__((__noreturn__)) void failure_status(char const   *what , adns_status st ) ;
#line 72
static  __attribute__((__noreturn__)) void failure_status(char const   *what , adns_status st ) ;
#line 72 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnstest.c"
static void failure_status(char const   *what , adns_status st ) 
{ 
  char const   *tmp ;

  {
  {
#line 73
  tmp = adns_strerror(st);
#line 73
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adns failure: %s: %s\n",
          what, tmp);
#line 74
  quitnow___0(2);
  }
}
}
#line 77
static  __attribute__((__noreturn__)) void failure_errno(char const   *what , int errnoval ) ;
#line 78
static  __attribute__((__noreturn__)) void failure_errno(char const   *what , int errnoval ) ;
#line 78 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnstest.c"
static void failure_errno(char const   *what , int errnoval ) 
{ 


  {
  {
#line 82
  if (errnoval == 22) {
#line 82
    goto case_22;
  }
#line 83
  if (errnoval == 4) {
#line 83
    goto case_4;
  }
#line 84
  if (errnoval == 3) {
#line 84
    goto case_3;
  }
#line 85
  if (errnoval == 11) {
#line 85
    goto case_11;
  }
#line 86
  if (errnoval == 38) {
#line 86
    goto case_38;
  }
#line 87
  if (errnoval == 34) {
#line 87
    goto case_34;
  }
#line 89
  goto switch_default;
  case_22: /* CIL Label */ 
  {
#line 82
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adns failure: %s: errno=EINVAL\n",
          what);
  }
#line 82
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 83
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adns failure: %s: errno=EINTR\n",
          what);
  }
#line 83
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 84
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adns failure: %s: errno=ESRCH\n",
          what);
  }
#line 84
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 85
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adns failure: %s: errno=EAGAIN\n",
          what);
  }
#line 85
  goto switch_break;
  case_38: /* CIL Label */ 
  {
#line 86
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adns failure: %s: errno=ENOSYS\n",
          what);
  }
#line 86
  goto switch_break;
  case_34: /* CIL Label */ 
  {
#line 87
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adns failure: %s: errno=ERANGE\n",
          what);
  }
#line 87
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 89
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adns failure: %s: errno=%d\n",
          what, errnoval);
  }
#line 89
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 91
  quitnow___0(2);
  }
}
}
#line 94
static  __attribute__((__noreturn__)) void usageerr___0(char const   *why ) ;
#line 95
static  __attribute__((__noreturn__)) void usageerr___0(char const   *why ) ;
#line 95 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnstest.c"
static void usageerr___0(char const   *why ) 
{ 


  {
  {
#line 96
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad usage: %s\nusage: adnstest [-<initflagsnum>[,<owninitflags>]] [/<initstring>]\n              [ :<typenum>,... ]\n              [ [<queryflagsnum>[,<ownqueryflags>]/]<domain> ... ]\ninitflags:   p  use poll(2) instead of select(2)\n             s  use adns_wait with specified query, instead of 0\nqueryflags:  a  print status abbrevs instead of strings\nexit status:  0 ok (though some queries may have failed)\n              1 used by test harness to indicate test failed\n              2 unable to submit or init or some such\n              3 unexpected failure\n              4 usage error\n              5 operation not supported on this system\n",
          why);
#line 111
  quitnow___0(4);
  }
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnstest.c"
static adns_rrtype const   defaulttypes[16]  = 
#line 114
  {      (adns_rrtype const   )1,      (adns_rrtype const   )2,      (adns_rrtype const   )5,      (adns_rrtype const   )6, 
        (adns_rrtype const   )12,      (adns_rrtype const   )13,      (adns_rrtype const   )15,      (adns_rrtype const   )16, 
        (adns_rrtype const   )17,      (adns_rrtype const   )65537,      (adns_rrtype const   )65538,      (adns_rrtype const   )65548, 
        (adns_rrtype const   )65551,      (adns_rrtype const   )131078,      (adns_rrtype const   )131089,      (adns_rrtype const   )0};
#line 136 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnstest.c"
static void dumptype(adns_status ri , char const   *rrtn , char const   *fmtn ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
#line 137
  if (ri) {
    {
#line 137
    tmp = adns_strerror(ri);
#line 137
    tmp___0 = tmp;
    }
  } else {
#line 137
    tmp___0 = "";
  }
#line 137
  if (ri) {
#line 137
    tmp___1 = " ";
  } else {
#line 137
    tmp___1 = "";
  }
#line 137
  if (ri) {
#line 137
    tmp___3 = "?";
  } else {
#line 137
    if (fmtn) {
#line 137
      tmp___2 = fmtn;
    } else {
#line 137
      tmp___2 = "-";
    }
#line 137
    tmp___3 = tmp___2;
  }
#line 137
  if (! ri) {
#line 137
    if (rrtn) {
#line 137
      tmp___4 = rrtn;
    } else {
#line 137
      tmp___4 = "?";
    }
  } else {
#line 137
    tmp___4 = "?";
  }
  {
#line 137
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s(%s)%s%s",
          tmp___4, tmp___3, tmp___1, tmp___0);
  }
#line 140
  return;
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnstest.c"
static void fdom_split(char const   *fdom , char const   **dom_r , int *qf_r , char *ownflags ,
                       int ownflags_l ) 
{ 
  int qf ;
  char *ep ;
  unsigned long tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 147
  tmp = strtoul((char const   */* __restrict  */)fdom, (char **/* __restrict  */)(& ep),
                0);
#line 147
  qf = (int )tmp;
  }
#line 148
  if ((int )*ep == 44) {
    {
#line 148
    tmp___2 = strchr((char const   *)ep, '/');
    }
#line 148
    if (tmp___2) {
#line 149
      ep ++;
      {
#line 150
      while (1) {
        while_continue: /* CIL Label */ ;
#line 150
        if (! ((int )*ep != 47)) {
#line 150
          goto while_break;
        }
#line 151
        ownflags_l --;
#line 151
        if (ownflags_l <= 0) {
          {
#line 151
          fputs((char const   */* __restrict  */)"too many flags\n", (FILE */* __restrict  */)stderr);
#line 151
          quitnow___0(3);
          }
        }
#line 152
        tmp___0 = ownflags;
#line 152
        ownflags ++;
#line 152
        tmp___1 = ep;
#line 152
        ep ++;
#line 152
        *tmp___0 = *tmp___1;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 155
  if ((int )*ep != 47) {
#line 155
    *dom_r = fdom;
#line 155
    *qf_r = 0;
  } else {
#line 156
    *dom_r = (char const   *)(ep + 1);
#line 156
    *qf_r = qf;
  }
#line 157
  *ownflags = (char)0;
#line 158
  return;
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnstest.c"
static int consistsof(char const   *string , char const   *accept___0 ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 161
  tmp = strspn(string, accept___0);
#line 161
  tmp___0 = strlen(string);
  }
#line 161
  return (tmp == tmp___0);
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
static struct sinfo  const  sinfos___1[24]  = 
#line 233 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
  {      {(adns_status )0, "ok", "OK"}, 
        {(adns_status )1, "nomemory", "Out of memory"}, 
        {(adns_status )2, "unknownrrtype", "Query not implemented in DNS library"}, 
        {(adns_status )3, "systemfail", "General resolver or system failure"}, 
        {(adns_status )30, "timeout", "DNS query timed out"}, 
        {(adns_status )31, "allservfail", "All nameservers failed"}, 
        {(adns_status )32, "norecurse", "Recursion denied by nameserver"}, 
        {(adns_status )33, "invalidresponse", "Nameserver sent bad response"}, 
        {(adns_status )34, "unknownformat", "Nameserver used unknown format"}, 
        {(adns_status )60, "rcodeservfail", "Nameserver reports failure"}, 
        {(adns_status )61, "rcodeformaterror", "Query not understood by nameserver"}, 
        {(adns_status )62,
      "rcodenotimplemented", "Query not implemented by nameserver"}, 
        {(adns_status )63, "rcoderefused", "Query refused by nameserver"}, 
        {(adns_status )64, "rcodeunknown", "Nameserver sent unknown response code"}, 
        {(adns_status )100, "inconsistent", "Inconsistent resource records in DNS"}, 
        {(adns_status )101, "prohibitedcname", "DNS alias found where canonical name wanted"}, 
        {(adns_status )102,
      "answerdomaininvalid", "Found syntactically invalid domain name"}, 
        {(adns_status )103, "answerdomaintoolong", "Found overly-long domain name"}, 
        {(adns_status )104, "invaliddata", "Found invalid DNS data"}, 
        {(adns_status )200, "querydomainwrong", "Domain invalid for particular DNS query type"}, 
        {(adns_status )201,
      "querydomaininvalid", "Domain name is syntactically invalid"}, 
        {(adns_status )202, "querydomaintoolong", "Domain name or component is too long"}, 
        {(adns_status )300,
      "nxdomain", "No such domain"}, 
        {(adns_status )301, "nodata", "No such data"}};
#line 270 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
static int si_compar___1(void const   *key , void const   *elem ) 
{ 
  adns_status const   *st ;
  struct sinfo  const  *si ;
  int tmp ;
  int tmp___0 ;

  {
#line 271
  st = (adns_status const   *)key;
#line 272
  si = (struct sinfo  const  *)elem;
#line 274
  if ((unsigned int const   )*st < (unsigned int const   )si->st) {
#line 274
    tmp___0 = -1;
  } else {
#line 274
    if ((unsigned int const   )*st > (unsigned int const   )si->st) {
#line 274
      tmp = 1;
    } else {
#line 274
      tmp = 0;
    }
#line 274
    tmp___0 = tmp;
  }
#line 274
  return (tmp___0);
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
static struct sinfo  const  *findsinfo___1(adns_status st ) 
{ 
  void *tmp ;

  {
  {
#line 278
  tmp = bsearch((void const   *)(& st), (void const   *)(sinfos___1), sizeof(sinfos___1) / sizeof(sinfos___1[0]),
                sizeof(sinfos___1[0]), & si_compar___1);
  }
#line 278
  return ((struct sinfo  const  *)tmp);
}
}
#line 299 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
static struct stinfo  const  stinfos___1[7]  = {      {(adns_status )0, "ok"}, 
        {(adns_status )29, "localfail"}, 
        {(adns_status )59, "remotefail"}, 
        {(adns_status )99, "tempfail"}, 
        {(adns_status )199, "misconfig"}, 
        {(adns_status )299, "misquery"}, 
        {(adns_status )499, "permfail"}};
#line 312 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
static int sti_compar___1(void const   *key , void const   *elem ) 
{ 
  adns_status const   *st ;
  struct stinfo  const  *sti ;
  adns_status here ;
  adns_status min ;
  adns_status max ;
  int tmp ;
  int tmp___0 ;

  {
#line 313
  st = (adns_status const   *)key;
#line 314
  sti = (struct stinfo  const  *)elem;
#line 318
  here = (adns_status )*st;
#line 319
  if ((unsigned long )sti == (unsigned long )(stinfos___1)) {
#line 319
    min = (adns_status )0;
  } else {
#line 319
    min = (adns_status )((unsigned int const   )(sti + -1)->stmax + 1U);
  }
#line 320
  max = (adns_status )sti->stmax;
#line 322
  if ((unsigned int )here < (unsigned int )min) {
#line 322
    tmp___0 = -1;
  } else {
#line 322
    if ((unsigned int )here > (unsigned int )max) {
#line 322
      tmp = 1;
    } else {
#line 322
      tmp = 0;
    }
#line 322
    tmp___0 = tmp;
  }
#line 322
  return (tmp___0);
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/transmit.c"
static adns_status mkquery_header___1(adns_state ads___7 , vbuf *vb___0 , int *id_r ,
                                      int qdlen ) 
{ 
  int id ;
  byte *rqp ;
  int tmp ;
  int tmp___0 ;
  byte *tmp___1 ;
  byte *tmp___2 ;
  byte *tmp___3 ;
  byte *tmp___4 ;
  byte *tmp___5 ;
  byte *tmp___6 ;
  byte *tmp___7 ;
  byte *tmp___8 ;
  byte *tmp___9 ;
  byte *tmp___10 ;
  byte *tmp___11 ;
  byte *tmp___12 ;

  {
  {
#line 46
  tmp = adns__vbuf_ensure(vb___0, (12 + qdlen) + 4);
  }
#line 46
  if (! tmp) {
#line 46
    return ((adns_status )1);
  }
#line 48
  vb___0->used = 0;
#line 49
  rqp = vb___0->buf + vb___0->used;
#line 51
  tmp___0 = ads___7->nextid;
#line 51
  (ads___7->nextid) ++;
#line 51
  id = tmp___0 & 65535;
#line 51
  *id_r = id;
#line 52
  tmp___1 = rqp;
#line 52
  rqp ++;
#line 52
  *tmp___1 = (byte )((id >> 8) & 255);
#line 52
  tmp___2 = rqp;
#line 52
  rqp ++;
#line 52
  *tmp___2 = (byte )(id & 255);
#line 53
  tmp___3 = rqp;
#line 53
  rqp ++;
#line 53
  *tmp___3 = (byte )1;
#line 54
  tmp___4 = rqp;
#line 54
  rqp ++;
#line 54
  *tmp___4 = (byte )0;
#line 55
  tmp___5 = rqp;
#line 55
  rqp ++;
#line 55
  *tmp___5 = (byte )((1 >> 8) & 255);
#line 55
  tmp___6 = rqp;
#line 55
  rqp ++;
#line 55
  *tmp___6 = (byte )1;
#line 56
  tmp___7 = rqp;
#line 56
  rqp ++;
#line 56
  *tmp___7 = (byte )0;
#line 56
  tmp___8 = rqp;
#line 56
  rqp ++;
#line 56
  *tmp___8 = (byte )0;
#line 57
  tmp___9 = rqp;
#line 57
  rqp ++;
#line 57
  *tmp___9 = (byte )0;
#line 57
  tmp___10 = rqp;
#line 57
  rqp ++;
#line 57
  *tmp___10 = (byte )0;
#line 58
  tmp___11 = rqp;
#line 58
  rqp ++;
#line 58
  *tmp___11 = (byte )0;
#line 58
  tmp___12 = rqp;
#line 58
  rqp ++;
#line 58
  *tmp___12 = (byte )0;
#line 60
  vb___0->used = (int )(rqp - vb___0->buf);
#line 62
  return ((adns_status )0);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/transmit.c"
static adns_status mkquery_footer___1(vbuf *vb___0 , adns_rrtype type ) 
{ 
  byte *rqp ;
  byte *tmp ;
  byte *tmp___0 ;
  byte *tmp___1 ;
  byte *tmp___2 ;

  {
#line 68
  rqp = vb___0->buf + vb___0->used;
#line 69
  tmp = rqp;
#line 69
  rqp ++;
#line 69
  *tmp = (byte )((((unsigned int )type & 65535U) >> 8) & 255U);
#line 69
  tmp___0 = rqp;
#line 69
  rqp ++;
#line 69
  *tmp___0 = (byte )(((unsigned int )type & 65535U) & 255U);
#line 70
  tmp___1 = rqp;
#line 70
  rqp ++;
#line 70
  *tmp___1 = (byte )((1 >> 8) & 255);
#line 70
  tmp___2 = rqp;
#line 70
  rqp ++;
#line 70
  *tmp___2 = (byte )1;
#line 71
  vb___0->used = (int )(rqp - vb___0->buf);
#line 72
  if (! (vb___0->used <= vb___0->avail)) {
    {
#line 72
    __assert_fail("vb->used <= vb->avail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/transmit.c",
                  72U, "mkquery_footer");
    }
  }
#line 74
  return ((adns_status )0);
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/transmit.c"
static void query_usetcp___1(adns_query qu , struct timeval now ) 
{ 


  {
  {
#line 244
  qu->state = (enum __anonenum_state_83 )1;
#line 245
  qu->timeout = now;
#line 246
  timevaladd(& qu->timeout, 30000L);
  }
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    qu->next = (adns_query )0;
#line 247
    qu->back = (qu->ads)->tcpw.tail;
#line 247
    if ((qu->ads)->tcpw.tail) {
#line 247
      ((qu->ads)->tcpw.tail)->next = qu;
    } else {
#line 247
      (qu->ads)->tcpw.head = qu;
    }
#line 247
    (qu->ads)->tcpw.tail = qu;
#line 247
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 248
  adns__querysend_tcp(qu, now);
#line 249
  adns__tcp_tryconnect(qu->ads, now);
  }
#line 250
  return;
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static adns_query query_alloc___1(adns_state ads___7 , typeinfo const   *typei , adns_rrtype type ,
                                  adns_queryflags flags , struct timeval now ) 
{ 
  adns_query qu ;
  void *tmp ;
  void *tmp___0 ;
  adns_query tmp___1 ;
  adns_query tmp___2 ;
  adns_query tmp___3 ;
  adns_query tmp___4 ;
  allocnode *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __suseconds_t tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 45
  tmp = Hmalloc(sizeof(*qu));
#line 45
  qu = (adns_query )tmp;
  }
#line 45
  if (! qu) {
#line 45
    return ((adns_query )0);
  }
  {
#line 46
  tmp___0 = Hmalloc(sizeof(*(qu->answer)));
#line 46
  qu->answer = (adns_answer *)tmp___0;
  }
#line 47
  if (! qu->answer) {
    {
#line 47
    Hfree((void *)qu);
    }
#line 47
    return ((adns_query )0);
  }
  {
#line 49
  qu->ads = ads___7;
#line 50
  qu->state = (enum __anonenum_state_83 )0;
#line 51
  tmp___2 = (adns_query )0;
#line 51
  qu->parent = tmp___2;
#line 51
  tmp___1 = tmp___2;
#line 51
  qu->next = tmp___1;
#line 51
  qu->back = tmp___1;
#line 52
  tmp___3 = (adns_query )0;
#line 52
  qu->children.tail = tmp___3;
#line 52
  qu->children.head = tmp___3;
#line 53
  tmp___4 = (adns_query )0;
#line 53
  qu->siblings.back = tmp___4;
#line 53
  qu->siblings.next = tmp___4;
#line 54
  tmp___5 = (allocnode *)0;
#line 54
  qu->allocations.tail = tmp___5;
#line 54
  qu->allocations.head = tmp___5;
#line 55
  qu->interim_allocd = 0;
#line 56
  qu->preserved_allocd = 0;
#line 57
  qu->final_allocspace = (void *)0;
#line 59
  qu->typei = typei;
#line 60
  qu->query_dgram = (byte *)0;
#line 61
  qu->query_dglen = 0;
#line 62
  adns__vbuf_init(& qu->vb);
#line 64
  qu->cname_dgram = (byte *)0;
#line 65
  tmp___6 = 0;
#line 65
  qu->cname_begin = tmp___6;
#line 65
  qu->cname_dglen = tmp___6;
#line 67
  adns__vbuf_init(& qu->search_vb);
#line 68
  tmp___8 = 0;
#line 68
  qu->search_doneabs = tmp___8;
#line 68
  tmp___7 = tmp___8;
#line 68
  qu->search_pos = tmp___7;
#line 68
  qu->search_origlen = tmp___7;
#line 70
  qu->id = -2;
#line 71
  qu->flags = (int )flags;
#line 72
  qu->retries = 0;
#line 73
  qu->udpnextserver = 0;
#line 74
  qu->udpsent = 0UL;
#line 75
  tmp___9 = (__suseconds_t )0;
#line 75
  qu->timeout.tv_usec = tmp___9;
#line 75
  qu->timeout.tv_sec = tmp___9;
#line 76
  qu->expires = now.tv_sec + 604800L;
#line 78
  memset((void *)(& qu->ctx), 0, sizeof(qu->ctx));
#line 80
  (qu->answer)->status = (adns_status )0;
#line 81
  tmp___10 = (char *)0;
#line 81
  (qu->answer)->owner = tmp___10;
#line 81
  (qu->answer)->cname = tmp___10;
#line 82
  (qu->answer)->type = type;
#line 83
  (qu->answer)->expires = (time_t )-1;
#line 84
  (qu->answer)->nrrs = 0;
#line 85
  (qu->answer)->rrs.untyped = (void *)0;
#line 86
  (qu->answer)->rrsz = (int )typei->rrsz;
  }
#line 88
  return (qu);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void query_submit___1(adns_state ads___7 , adns_query qu , typeinfo const   *typei ,
                             vbuf *qumsg_vb , int id , adns_queryflags flags , struct timeval now ) 
{ 
  void *tmp ;

  {
  {
#line 98
  qu->vb = *qumsg_vb;
#line 99
  adns__vbuf_init(qumsg_vb);
#line 101
  tmp = Hmalloc((size_t )qu->vb.used);
#line 101
  qu->query_dgram = (byte *)tmp;
  }
#line 102
  if (! qu->query_dgram) {
    {
#line 102
    adns__query_fail(qu, (adns_status )1);
    }
#line 102
    return;
  }
  {
#line 104
  qu->id = id;
#line 105
  qu->query_dglen = qu->vb.used;
#line 106
  memcpy((void */* __restrict  */)qu->query_dgram, (void const   */* __restrict  */)qu->vb.buf,
         (size_t )qu->vb.used);
#line 108
  adns__query_send(qu, now);
  }
#line 109
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void query_simple___1(adns_state ads___7 , adns_query qu , char const   *owner ,
                             int ol , typeinfo const   *typei , adns_queryflags flags ,
                             struct timeval now ) 
{ 
  vbuf vb_new ;
  int id ;
  adns_status stat ;

  {
  {
#line 136
  stat = adns__mkquery(ads___7, & qu->vb, & id, owner, ol, typei, (qu->answer)->type,
                       flags);
  }
#line 138
  if (stat) {
#line 139
    if ((unsigned int )stat == 202U) {
#line 139
      if ((unsigned int )flags & 1U) {
        {
#line 140
        adns__search_next(ads___7, qu, now);
        }
#line 141
        return;
      } else {
        {
#line 143
        adns__query_fail(qu, stat);
        }
#line 144
        return;
      }
    } else {
      {
#line 143
      adns__query_fail(qu, stat);
      }
#line 144
      return;
    }
  }
  {
#line 148
  vb_new = qu->vb;
#line 149
  adns__vbuf_init(& qu->vb);
#line 150
  query_submit___1(ads___7, qu, typei, & vb_new, id, flags, now);
  }
#line 151
  return;
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static int save_owner___1(adns_query qu , char const   *owner , int ol ) 
{ 
  adns_answer *ans ;
  void *tmp ;

  {
#line 198
  if (! (qu->flags & 4)) {
#line 198
    return (1);
  }
#line 200
  ans = qu->answer;
#line 201
  if (! (! ans->owner)) {
    {
#line 201
    __assert_fail("!ans->owner", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c",
                  201U, "save_owner");
    }
  }
  {
#line 203
  tmp = adns__alloc_preserved(qu, (size_t )(ol + 1));
#line 203
  ans->owner = (char *)tmp;
  }
#line 203
  if (! ans->owner) {
#line 203
    return (0);
  }
  {
#line 205
  memcpy((void */* __restrict  */)ans->owner, (void const   */* __restrict  */)owner,
         (size_t )ol);
#line 206
  *(ans->owner + ol) = (char)0;
  }
#line 207
  return (1);
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void *alloc_common___1(adns_query qu , size_t sz ) 
{ 
  allocnode *an ;
  void *tmp ;

  {
#line 342
  if (! sz) {
#line 342
    return ((void *)qu);
  }
#line 343
  if (! (! qu->final_allocspace)) {
    {
#line 343
    __assert_fail("!qu->final_allocspace", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c",
                  343U, "alloc_common");
    }
  }
  {
#line 344
  tmp = Hmalloc((((((((sizeof(*an) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ) + sz) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ));
#line 344
  an = (allocnode *)tmp;
  }
#line 345
  if (! an) {
#line 345
    return ((void *)0);
  }
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 346
    an->next = (struct allocnode *)0;
#line 346
    an->back = qu->allocations.tail;
#line 346
    if (qu->allocations.tail) {
#line 346
      (qu->allocations.tail)->next = an;
    } else {
#line 346
      qu->allocations.head = an;
    }
#line 346
    qu->allocations.tail = an;
#line 346
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 347
  return ((void *)((byte *)an + (((sizeof(*an) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign )));
}
}
#line 410 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void cancel_children___1(adns_query qu ) 
{ 
  adns_query cqu ;
  adns_query ncqu ;

  {
#line 413
  cqu = qu->children.head;
  {
#line 413
  while (1) {
    while_continue: /* CIL Label */ ;
#line 413
    if (! cqu) {
#line 413
      goto while_break;
    }
    {
#line 414
    ncqu = cqu->siblings.next;
#line 415
    adns_cancel(cqu);
#line 413
    cqu = ncqu;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 417
  return;
}
}
#line 427 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void free_query_allocs___1(adns_query qu ) 
{ 
  allocnode *an ;
  allocnode *ann ;
  allocnode *tmp ;

  {
  {
#line 430
  cancel_children___1(qu);
#line 431
  an = qu->allocations.head;
  }
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    if (! an) {
#line 431
      goto while_break;
    }
    {
#line 431
    ann = an->next;
#line 431
    Hfree((void *)an);
#line 431
    an = ann;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 432
  tmp = (allocnode *)0;
#line 432
  qu->allocations.tail = tmp;
#line 432
  qu->allocations.head = tmp;
#line 433
  adns__vbuf_free(& qu->vb);
#line 434
  adns__vbuf_free(& qu->search_vb);
#line 435
  Hfree((void *)qu->query_dgram);
#line 436
  qu->query_dgram = (byte *)0;
  }
#line 437
  return;
}
}
#line 477 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void makefinal_query___1(adns_query qu ) 
{ 
  adns_answer *ans ;
  int rrn ;
  void *tmp ;

  {
#line 481
  ans = qu->answer;
#line 483
  if (qu->interim_allocd) {
    {
#line 484
    tmp = Hrealloc((void *)qu->answer, (((((((sizeof(*ans) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ) + (unsigned long )qu->interim_allocd) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ));
#line 484
    ans = (adns_answer *)tmp;
    }
#line 486
    if (! ans) {
#line 486
      goto x_nomem;
    }
#line 487
    qu->answer = ans;
  }
  {
#line 490
  qu->final_allocspace = (void *)((byte *)ans + (((sizeof(*ans) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ));
#line 491
  adns__makefinal_str(qu, & ans->cname);
#line 492
  adns__makefinal_str(qu, & ans->owner);
  }
#line 494
  if (ans->nrrs) {
    {
#line 495
    adns__makefinal_block(qu, & ans->rrs.untyped, (size_t )(ans->nrrs * ans->rrsz));
#line 497
    rrn = 0;
    }
    {
#line 497
    while (1) {
      while_continue: /* CIL Label */ ;
#line 497
      if (! (rrn < ans->nrrs)) {
#line 497
        goto while_break;
      }
      {
#line 498
      (*((qu->typei)->makefinal))(qu, (void *)(ans->rrs.bytes + rrn * ans->rrsz));
#line 497
      rrn ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 501
  free_query_allocs___1(qu);
  }
#line 502
  return;
  x_nomem: 
  {
#line 505
  qu->preserved_allocd = 0;
#line 506
  (qu->answer)->cname = (char *)0;
#line 507
  (qu->answer)->owner = (char *)0;
#line 508
  adns__reset_preserved(qu);
#line 510
  (qu->answer)->status = (adns_status )1;
#line 511
  free_query_allocs___1(qu);
  }
#line 512
  return;
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void tcp_close___1(adns_state ads___7 ) 
{ 
  int serv ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 48
  serv = ads___7->tcpserver;
#line 49
  Hclose(ads___7->tcpsocket);
#line 50
  ads___7->tcpsocket = -1;
#line 51
  tmp___0 = 0;
#line 51
  ads___7->tcpsend.used = tmp___0;
#line 51
  tmp = tmp___0;
#line 51
  ads___7->tcprecv_skip = tmp;
#line 51
  ads___7->tcprecv.used = tmp;
  }
#line 52
  return;
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void tcp_connected___1(adns_state ads___7 , struct timeval now ) 
{ 
  adns_query qu ;
  adns_query nqu ;

  {
  {
#line 76
  adns__debug(ads___7, ads___7->tcpserver, (adns_query )0, "TCP connected");
#line 77
  ads___7->tcpstate = (enum adns__tcpstate )2;
#line 78
  qu = ads___7->tcpw.head;
  }
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (qu) {
#line 78
      if (! ((unsigned int )ads___7->tcpstate == 2U)) {
#line 78
        goto while_break;
      }
    } else {
#line 78
      goto while_break;
    }
#line 79
    nqu = qu->next;
#line 80
    if (! ((unsigned int )qu->state == 1U)) {
      {
#line 80
      __assert_fail("qu->state == query_tcpw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c",
                    80U, "tcp_connected");
      }
    }
    {
#line 81
    adns__querysend_tcp(qu, now);
#line 78
    qu = nqu;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void tcp_broken_events___1(adns_state ads___7 ) 
{ 
  adns_query qu ;
  adns_query nqu ;

  {
#line 88
  if (! ((unsigned int )ads___7->tcpstate == 3U)) {
    {
#line 88
    __assert_fail("ads->tcpstate == server_broken", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c",
                  88U, "tcp_broken_events");
    }
  }
#line 89
  qu = ads___7->tcpw.head;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! qu) {
#line 89
      goto while_break;
    }
#line 90
    nqu = qu->next;
#line 91
    if (! ((unsigned int )qu->state == 1U)) {
      {
#line 91
      __assert_fail("qu->state == query_tcpw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c",
                    91U, "tcp_broken_events");
      }
    }
#line 92
    if (qu->retries > ads___7->nservers) {
      {
#line 93
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 93
        if (qu->back) {
#line 93
          (qu->back)->next = qu->next;
        } else {
#line 93
          ads___7->tcpw.head = qu->next;
        }
#line 93
        if (qu->next) {
#line 93
          (qu->next)->back = qu->back;
        } else {
#line 93
          ads___7->tcpw.tail = qu->back;
        }
#line 93
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 94
      adns__query_fail(qu, (adns_status )31);
      }
    }
#line 89
    qu = nqu;
  }
  while_break: /* CIL Label */ ;
  }
#line 97
  ads___7->tcpstate = (enum adns__tcpstate )0;
#line 98
  return;
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void inter_immed___1(struct timeval **tv_io , struct timeval *tvbuf ) 
{ 
  struct timeval *rbuf ;
  __suseconds_t tmp ;

  {
#line 174
  if (! tv_io) {
#line 174
    return;
  }
#line 176
  rbuf = *tv_io;
#line 177
  if (! rbuf) {
#line 177
    rbuf = tvbuf;
#line 177
    *tv_io = rbuf;
  }
#line 179
  tmp = (__suseconds_t )0;
#line 179
  rbuf->tv_usec = tmp;
#line 179
  rbuf->tv_sec = tmp;
#line 180
  return;
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void inter_maxto___1(struct timeval **tv_io , struct timeval *tvbuf , struct timeval maxto ) 
{ 
  struct timeval *rbuf ;
  int tmp ;

  {
#line 186
  if (! tv_io) {
#line 186
    return;
  }
#line 187
  rbuf = *tv_io;
#line 188
  if (! rbuf) {
#line 189
    *tvbuf = maxto;
#line 189
    *tv_io = tvbuf;
  } else {
#line 191
    if (rbuf->tv_sec == maxto.tv_sec) {
#line 191
      tmp = rbuf->tv_usec > maxto.tv_usec;
    } else {
#line 191
      tmp = rbuf->tv_sec > maxto.tv_sec;
    }
#line 191
    if (tmp) {
#line 191
      *rbuf = maxto;
    }
  }
#line 195
  return;
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void inter_maxtoabs___1(struct timeval **tv_io , struct timeval *tvbuf , struct timeval now ,
                               struct timeval maxtime ) 
{ 
  ldiv_t dr ;

  {
#line 204
  if (! tv_io) {
#line 204
    return;
  }
  {
#line 205
  maxtime.tv_sec -= now.tv_sec + 2L;
#line 206
  maxtime.tv_usec -= now.tv_usec - 2000000L;
#line 207
  dr = ldiv(maxtime.tv_usec, 1000000L);
#line 208
  maxtime.tv_sec += dr.quot;
#line 209
  maxtime.tv_usec -= dr.quot * 1000000L;
  }
#line 210
  if (maxtime.tv_sec < 0L) {
#line 210
    maxtime.tv_usec = (__suseconds_t )0;
#line 210
    maxtime.tv_sec = maxtime.tv_usec;
  }
  {
#line 211
  inter_maxto___1(tv_io, tvbuf, maxtime);
  }
#line 212
  return;
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void timeouts_queue___1(adns_state ads___7 , int act , struct timeval **tv_io ,
                               struct timeval *tvbuf , struct timeval now , struct query_queue *queue ) 
{ 
  adns_query qu ;
  adns_query nqu ;
  int tmp ;

  {
#line 219
  qu = queue->head;
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if (! qu) {
#line 219
      goto while_break;
    }
#line 220
    nqu = qu->next;
#line 221
    if (now.tv_sec == qu->timeout.tv_sec) {
#line 221
      tmp = now.tv_usec > qu->timeout.tv_usec;
    } else {
#line 221
      tmp = now.tv_sec > qu->timeout.tv_sec;
    }
#line 221
    if (tmp) {
#line 224
      if (! act) {
        {
#line 224
        inter_immed___1(tv_io, tvbuf);
        }
#line 224
        return;
      }
      {
#line 225
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 225
        if (qu->back) {
#line 225
          (qu->back)->next = qu->next;
        } else {
#line 225
          queue->head = qu->next;
        }
#line 225
        if (qu->next) {
#line 225
          (qu->next)->back = qu->back;
        } else {
#line 225
          queue->tail = qu->back;
        }
#line 225
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 226
      if ((unsigned int )qu->state != 0U) {
        {
#line 227
        adns__query_fail(qu, (adns_status )30);
        }
      } else {
        {
#line 229
        adns__query_send(qu, now);
        }
      }
#line 231
      nqu = queue->head;
    } else {
      {
#line 222
      inter_maxtoabs___1(tv_io, tvbuf, now, qu->timeout);
      }
    }
#line 219
    qu = nqu;
  }
  while_break: /* CIL Label */ ;
  }
#line 234
  return;
}
}
#line 236 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void tcp_events___1(adns_state ads___7 , int act , struct timeval **tv_io ,
                           struct timeval *tvbuf , struct timeval now ) 
{ 
  int tmp ;

  {
  {
#line 239
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 241
    if ((unsigned int )ads___7->tcpstate == 3U) {
#line 241
      goto case_3;
    }
#line 244
    if ((unsigned int )ads___7->tcpstate == 0U) {
#line 244
      goto case_0;
    }
#line 249
    if ((unsigned int )ads___7->tcpstate == 2U) {
#line 249
      goto case_2;
    }
#line 256
    if ((unsigned int )ads___7->tcpstate == 1U) {
#line 256
      goto case_1;
    }
#line 275
    goto switch_default___0;
    case_3: /* CIL Label */ 
#line 242
    if (! act) {
      {
#line 242
      inter_immed___1(tv_io, tvbuf);
      }
#line 242
      return;
    }
    {
#line 243
    tcp_broken_events___1(ads___7);
    }
    case_0: /* CIL Label */ 
#line 245
    if (! ads___7->tcpw.head) {
#line 245
      return;
    }
#line 246
    if (! act) {
      {
#line 246
      inter_immed___1(tv_io, tvbuf);
      }
#line 246
      return;
    }
    {
#line 247
    adns__tcp_tryconnect(ads___7, now);
    }
#line 248
    goto switch_break;
    case_2: /* CIL Label */ 
#line 250
    if (ads___7->tcpw.head) {
#line 250
      return;
    }
#line 251
    if (! ads___7->tcptimeout.tv_sec) {
#line 252
      if (! (! ads___7->tcptimeout.tv_usec)) {
        {
#line 252
        __assert_fail("!ads->tcptimeout.tv_usec", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c",
                      252U, "tcp_events");
        }
      }
      {
#line 253
      ads___7->tcptimeout = now;
#line 254
      timevaladd(& ads___7->tcptimeout, 30000L);
      }
    }
    case_1: /* CIL Label */ 
#line 257
    if (! act) {
      {
#line 258
      inter_maxtoabs___1(tv_io, tvbuf, now, ads___7->tcptimeout);
      }
#line 259
      return;
    } else {
#line 257
      if (now.tv_sec == ads___7->tcptimeout.tv_sec) {
#line 257
        tmp = now.tv_usec > ads___7->tcptimeout.tv_usec;
      } else {
#line 257
        tmp = now.tv_sec > ads___7->tcptimeout.tv_sec;
      }
#line 257
      if (! tmp) {
        {
#line 258
        inter_maxtoabs___1(tv_io, tvbuf, now, ads___7->tcptimeout);
        }
#line 259
        return;
      }
    }
    {
#line 263
    if ((unsigned int )ads___7->tcpstate == 1U) {
#line 263
      goto case_1___0;
    }
#line 266
    if ((unsigned int )ads___7->tcpstate == 2U) {
#line 266
      goto case_2___0;
    }
#line 270
    goto switch_default;
    case_1___0: /* CIL Label */ 
    {
#line 264
    adns__tcp_broken(ads___7, "unable to make connection", "timed out");
    }
#line 265
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 267
    tcp_close___1(ads___7);
#line 268
    ads___7->tcpstate = (enum adns__tcpstate )0;
    }
#line 269
    return;
    switch_default: /* CIL Label */ 
    {
#line 271
    abort();
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 274
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
#line 276
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 279
  return;
}
}
#line 516 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void fd_event___1(adns_state ads___7 , int fd , int revent , int pollflag ,
                         int maxfd , fd_set const   *fds , int (*func)(adns_state  ,
                                                                       int fd , struct timeval  const  *now ) ,
                         struct timeval now , int *r_r ) 
{ 
  int r ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 524
  if (! (revent & pollflag)) {
#line 524
    return;
  }
#line 525
  if (fds) {
#line 525
    if (fd < maxfd) {
#line 525
      if (! ((fds->__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
#line 525
        return;
      }
    } else {
#line 525
      return;
    }
  }
  {
#line 526
  r = (*func)(ads___7, fd, (struct timeval  const  *)(& now));
  }
#line 527
  if (r) {
#line 528
    if (r_r) {
#line 529
      *r_r = r;
    } else {
      {
#line 531
      tmp = __errno_location();
#line 531
      tmp___0 = strerror(*tmp);
#line 531
      adns__diag(ads___7, -1, (adns_query )0, "process fd failed after select: %s",
                 tmp___0);
#line 533
      adns_globalsystemfailure(ads___7);
      }
    }
  }
#line 536
  return;
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfig___2(adns_state ads___7 , char const   *filename , int warnmissing ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void addserver___2(adns_state ads___7 , struct in_addr addr ) 
{ 
  int i ;
  struct server *ss ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 48
  i = 0;
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (i < ads___7->nservers)) {
#line 48
      goto while_break;
    }
#line 49
    if (ads___7->servers[i].addr.s_addr == addr.s_addr) {
      {
#line 50
      tmp = inet_ntoa(addr);
#line 50
      adns__debug(ads___7, -1, (adns_query )0, "duplicate nameserver %s ignored",
                  tmp);
      }
#line 51
      return;
    }
#line 48
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  if (ads___7->nservers >= 5) {
    {
#line 56
    tmp___0 = inet_ntoa(addr);
#line 56
    adns__diag(ads___7, -1, (adns_query )0, "too many nameservers, ignoring %s", tmp___0);
    }
#line 57
    return;
  }
#line 60
  ss = ads___7->servers + ads___7->nservers;
#line 61
  ss->addr = addr;
#line 62
  (ads___7->nservers) ++;
#line 63
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void freesearchlist___2(adns_state ads___7 ) 
{ 


  {
#line 66
  if (ads___7->nsearchlist) {
    {
#line 66
    Hfree((void *)*(ads___7->searchlist));
    }
  }
  {
#line 67
  Hfree((void *)ads___7->searchlist);
  }
#line 68
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void saveerr___2(adns_state ads___7 , int en ) 
{ 


  {
#line 71
  if (! ads___7->configerrno) {
#line 71
    ads___7->configerrno = en;
  }
#line 72
  return;
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void configparseerr___2(adns_state ads___7 , char const   *fn , int lno , char const   *fmt 
                               , ...) 
{ 
  va_list al ;

  {
  {
#line 78
  saveerr___2(ads___7, 22);
  }
#line 79
  if (! ads___7->logfn) {
#line 79
    return;
  } else
#line 79
  if ((unsigned int )ads___7->iflags & 2U) {
#line 79
    return;
  }
#line 81
  if (lno == -1) {
    {
#line 81
    adns__lprintf(ads___7, "adns: %s: ", fn);
    }
  } else {
    {
#line 82
    adns__lprintf(ads___7, "adns: %s:%d: ", fn, lno);
    }
  }
  {
#line 83
  __builtin_va_start(al, fmt);
#line 84
  adns__vlprintf(ads___7, fmt, al);
#line 85
  __builtin_va_end(al);
#line 86
  adns__lprintf(ads___7, "\n");
  }
#line 87
  return;
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int nextword___2(char const   **bufp_io , char const   **word_r , int *l_r ) 
{ 
  char const   *p ;
  char const   *q ;
  int tmp ;
  int tmp___0 ;

  {
#line 92
  p = *bufp_io;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 93
    tmp = ctype_whitespace((int )*p);
    }
#line 93
    if (! tmp) {
#line 93
      goto while_break;
    }
#line 93
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  if (! *p) {
#line 94
    return (0);
  }
#line 96
  q = p;
  {
#line 97
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 97
    if (*q) {
      {
#line 97
      tmp___0 = ctype_whitespace((int )*q);
      }
#line 97
      if (tmp___0) {
#line 97
        goto while_break___0;
      }
    } else {
#line 97
      goto while_break___0;
    }
#line 97
    q ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 99
  *l_r = (int )(q - p);
#line 100
  *word_r = p;
#line 101
  *bufp_io = q;
#line 103
  return (1);
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_nameserver___2(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  struct in_addr ia ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 110
  tmp = inet_aton(buf___17, & ia);
  }
#line 110
  if (! tmp) {
    {
#line 111
    configparseerr___2(ads___7, fn, lno, "invalid nameserver address `%s\'", buf___17);
    }
#line 112
    return;
  }
  {
#line 114
  tmp___0 = inet_ntoa(ia);
#line 114
  adns__debug(ads___7, -1, (adns_query )0, "using nameserver %s", tmp___0);
#line 115
  addserver___2(ads___7, ia);
  }
#line 116
  return;
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_search___2(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  char const   *bufp ;
  char const   *word ;
  char *newchars ;
  char **newptrs ;
  char **pp ;
  int count ;
  int tl ;
  int l ;
  int tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char **tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
#line 124
  if (! buf___17) {
#line 124
    return;
  }
#line 126
  bufp = buf___17;
#line 127
  count = 0;
#line 128
  tl = 0;
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 129
    tmp = nextword___2(& bufp, & word, & l);
    }
#line 129
    if (! tmp) {
#line 129
      goto while_break;
    }
#line 129
    count ++;
#line 129
    tl += l + 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 131
  tmp___0 = Hmalloc(sizeof(char *) * (unsigned long )count);
#line 131
  newptrs = (char **)tmp___0;
  }
#line 132
  if (! newptrs) {
    {
#line 132
    tmp___1 = __errno_location();
#line 132
    saveerr___2(ads___7, *tmp___1);
    }
#line 132
    return;
  }
  {
#line 134
  tmp___2 = Hmalloc((size_t )tl);
#line 134
  newchars = (char *)tmp___2;
  }
#line 135
  if (! newchars) {
    {
#line 135
    tmp___3 = __errno_location();
#line 135
    saveerr___2(ads___7, *tmp___3);
#line 135
    Hfree((void *)newptrs);
    }
#line 135
    return;
  }
#line 137
  bufp = buf___17;
#line 138
  pp = newptrs;
  {
#line 139
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 139
    tmp___6 = nextword___2(& bufp, & word, & l);
    }
#line 139
    if (! tmp___6) {
#line 139
      goto while_break___0;
    }
    {
#line 140
    tmp___4 = pp;
#line 140
    pp ++;
#line 140
    *tmp___4 = newchars;
#line 141
    memcpy((void */* __restrict  */)newchars, (void const   */* __restrict  */)word,
           (size_t )l);
#line 142
    newchars += l;
#line 143
    tmp___5 = newchars;
#line 143
    newchars ++;
#line 143
    *tmp___5 = (char)0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 146
  freesearchlist___2(ads___7);
#line 147
  ads___7->nsearchlist = count;
#line 148
  ads___7->searchlist = newptrs;
  }
#line 149
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_sortlist___2(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  char const   *word ;
  char tbuf[200] ;
  char *slash ;
  char *ep ;
  struct in_addr base ;
  struct in_addr mask ;
  int l ;
  unsigned long initial ;
  unsigned long baselocal ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  uint32_t tmp___3 ;
  int tmp___4 ;

  {
#line 159
  if (! buf___17) {
#line 159
    return;
  }
#line 161
  ads___7->nsortlist = 0;
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 162
    tmp___4 = nextword___2(& buf___17, & word, & l);
    }
#line 162
    if (! tmp___4) {
#line 162
      goto while_break;
    }
#line 163
    if (ads___7->nsortlist >= 15) {
      {
#line 164
      adns__diag(ads___7, -1, (adns_query )0, "too many sortlist entries, ignoring %.*s onwards",
                 l, word);
      }
#line 166
      return;
    }
#line 169
    if ((unsigned long )l >= sizeof(tbuf)) {
      {
#line 170
      configparseerr___2(ads___7, fn, lno, "sortlist entry `%.*s\' too long", l, word);
      }
#line 171
      goto while_continue;
    }
    {
#line 174
    memcpy((void */* __restrict  */)(tbuf), (void const   */* __restrict  */)word,
           (size_t )l);
#line 174
    tbuf[l] = (char)0;
#line 175
    slash = strchr((char const   *)(tbuf), '/');
    }
#line 176
    if (slash) {
#line 176
      tmp = slash;
#line 176
      slash ++;
#line 176
      *tmp = (char)0;
    }
    {
#line 178
    tmp___0 = inet_aton((char const   *)(tbuf), & base);
    }
#line 178
    if (! tmp___0) {
      {
#line 179
      configparseerr___2(ads___7, fn, lno, "invalid address `%s\' in sortlist", tbuf);
      }
#line 180
      goto while_continue;
    }
#line 183
    if (slash) {
      {
#line 184
      tmp___2 = strchr((char const   *)slash, '.');
      }
#line 184
      if (tmp___2) {
        {
#line 185
        tmp___1 = inet_aton((char const   *)slash, & mask);
        }
#line 185
        if (! tmp___1) {
          {
#line 186
          configparseerr___2(ads___7, fn, lno, "invalid mask `%s\' in sortlist", slash);
          }
#line 187
          goto while_continue;
        }
#line 189
        if (base.s_addr & ~ mask.s_addr) {
          {
#line 190
          configparseerr___2(ads___7, fn, lno, "mask `%s\' in sortlist overlaps address `%s\'",
                             slash, tbuf);
          }
#line 192
          goto while_continue;
        }
      } else {
        {
#line 195
        initial = strtoul((char const   */* __restrict  */)slash, (char **/* __restrict  */)(& ep),
                          10);
        }
#line 196
        if (*ep) {
          {
#line 197
          configparseerr___2(ads___7, fn, lno, "mask length `%s\' invalid", slash);
          }
#line 198
          goto while_continue;
        } else
#line 196
        if (initial > 32UL) {
          {
#line 197
          configparseerr___2(ads___7, fn, lno, "mask length `%s\' invalid", slash);
          }
#line 198
          goto while_continue;
        }
        {
#line 200
        mask.s_addr = htonl((uint32_t )(4294967295UL << (32UL - initial)));
        }
      }
    } else {
      {
#line 203
      tmp___3 = ntohl(base.s_addr);
#line 203
      baselocal = (unsigned long )tmp___3;
      }
#line 204
      if ((unsigned long )(! baselocal) & 2147483648UL) {
        {
#line 205
        mask.s_addr = htonl((uint32_t )4278190080UL);
        }
      } else
#line 206
      if ((baselocal & 3221225472UL) == 2147483648UL) {
        {
#line 207
        mask.s_addr = htonl((uint32_t )4294901760UL);
        }
      } else
#line 208
      if ((baselocal & 4026531840UL) == 3758096384UL) {
        {
#line 209
        mask.s_addr = htonl((uint32_t )4278190080UL);
        }
      } else {
        {
#line 211
        configparseerr___2(ads___7, fn, lno, "network address `%s\' in sortlist is not in classed ranges, must specify mask explicitly",
                           tbuf);
        }
#line 214
        goto while_continue;
      }
    }
#line 218
    ads___7->sortlist[ads___7->nsortlist].base = base;
#line 219
    ads___7->sortlist[ads___7->nsortlist].mask = mask;
#line 220
    (ads___7->nsortlist) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  return;
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_options___2(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  char const   *word ;
  char *ep ;
  unsigned long v ;
  int l ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 231
  if (! buf___17) {
#line 231
    return;
  }
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 233
    tmp___5 = nextword___2(& buf___17, & word, & l);
    }
#line 233
    if (! tmp___5) {
#line 233
      goto while_break;
    }
#line 234
    if (l == 5) {
      {
#line 234
      tmp = memcmp((void const   *)word, (void const   *)"debug", (size_t )5);
      }
#line 234
      if (! tmp) {
#line 235
        ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 8U);
#line 236
        goto while_continue;
      }
    }
#line 238
    if (l >= 6) {
      {
#line 238
      tmp___0 = memcmp((void const   *)word, (void const   *)"ndots:", (size_t )6);
      }
#line 238
      if (! tmp___0) {
        {
#line 239
        v = strtoul((char const   */* __restrict  */)(word + 6), (char **/* __restrict  */)(& ep),
                    10);
        }
#line 240
        if (l == 6) {
          {
#line 241
          configparseerr___2(ads___7, fn, lno, "option `%.*s\' malformed or has bad value",
                             l, word);
          }
#line 243
          goto while_continue;
        } else
#line 240
        if ((unsigned long )ep != (unsigned long )(word + l)) {
          {
#line 241
          configparseerr___2(ads___7, fn, lno, "option `%.*s\' malformed or has bad value",
                             l, word);
          }
#line 243
          goto while_continue;
        } else
#line 240
        if (v > 2147483647UL) {
          {
#line 241
          configparseerr___2(ads___7, fn, lno, "option `%.*s\' malformed or has bad value",
                             l, word);
          }
#line 243
          goto while_continue;
        }
#line 245
        ads___7->searchndots = (int )v;
#line 246
        goto while_continue;
      }
    }
#line 248
    if (l >= 12) {
      {
#line 248
      tmp___4 = memcmp((void const   *)word, (void const   *)"adns_checkc:", (size_t )12);
      }
#line 248
      if (! tmp___4) {
        {
#line 249
        tmp___3 = strcmp(word + 12, "none");
        }
#line 249
        if (tmp___3) {
          {
#line 252
          tmp___2 = strcmp(word + 12, "entex");
          }
#line 252
          if (tmp___2) {
            {
#line 255
            tmp___1 = strcmp(word + 12, "freq");
            }
#line 255
            if (tmp___1) {
              {
#line 258
              configparseerr___2(ads___7, fn, lno, "option adns_checkc has bad value `%s\' (must be none, entex or freq",
                                 word + 12);
              }
            } else {
#line 256
              ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 768U);
            }
          } else {
#line 253
            ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags & 4294966527U);
#line 254
            ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 256U);
          }
        } else {
#line 250
          ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags & 4294966527U);
#line 251
          ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 256U);
        }
#line 261
        goto while_continue;
      }
    }
    {
#line 263
    adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown option `%.*s\'", fn, lno,
               l, word);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 265
  return;
}
}
#line 267 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_clearnss___2(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 


  {
#line 269
  ads___7->nservers = 0;
#line 270
  return;
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_include___2(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 


  {
#line 274
  if (! *buf___17) {
    {
#line 275
    configparseerr___2(ads___7, fn, lno, "`include\' directive with no filename");
    }
#line 276
    return;
  }
  {
#line 278
  readconfig___2(ads___7, buf___17, 1);
  }
#line 279
  return;
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_lookup___2(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  int found_bind ;
  char const   *word ;
  int l ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 283
  found_bind = 0;
#line 287
  if (! *buf___17) {
    {
#line 288
    configparseerr___2(ads___7, fn, lno, "`lookup\' directive with no databases");
    }
#line 289
    return;
  }
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 292
    tmp___2 = nextword___2(& buf___17, & word, & l);
    }
#line 292
    if (! tmp___2) {
#line 292
      goto while_break;
    }
#line 293
    if (l == 4) {
      {
#line 293
      tmp___1 = memcmp((void const   *)word, (void const   *)"bind", (size_t )4);
      }
#line 293
      if (tmp___1) {
#line 293
        goto _L___0;
      } else {
#line 294
        found_bind = 1;
      }
    } else
    _L___0: /* CIL Label */ 
#line 295
    if (l == 4) {
      {
#line 295
      tmp___0 = memcmp((void const   *)word, (void const   *)"file", (size_t )4);
      }
#line 295
      if (tmp___0) {
#line 295
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 297
    if (l == 2) {
      {
#line 297
      tmp = memcmp((void const   *)word, (void const   *)"yp", (size_t )2);
      }
#line 297
      if (tmp) {
        {
#line 301
        adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown `lookup\' database `%.*s\'",
                   fn, lno, l, word);
#line 303
        found_bind = -1;
        }
      } else {
        {
#line 298
        adns__diag(ads___7, -1, (adns_query )0, "%s:%d: yp lookups not supported by adns",
                   fn, lno);
#line 299
        found_bind = -1;
        }
      }
    } else {
      {
#line 301
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown `lookup\' database `%.*s\'",
                 fn, lno, l, word);
#line 303
      found_bind = -1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 306
  if (! found_bind) {
    {
#line 307
    adns__diag(ads___7, -1, (adns_query )0, "%s:%d: `lookup\' specified, but not `bind\'",
               fn, lno);
    }
  }
#line 308
  return;
}
}
#line 310 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static struct configcommandinfo  const  configcommandinfos___2[9]  = 
#line 310
  {      {"nameserver", & ccf_nameserver___2}, 
        {"domain", & ccf_search___2}, 
        {"search", & ccf_search___2}, 
        {"sortlist", & ccf_sortlist___2}, 
        {"options", & ccf_options___2}, 
        {"clearnameservers", & ccf_clearnss___2}, 
        {"include", & ccf_include___2}, 
        {"lookup", & ccf_lookup___2}, 
        {(char const   *)0, (void (*)(adns_state ads , char const   *fn , int lno , char const   *buf ))0}};
#line 330 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int gl_file___2(adns_state ads___7 , getline_ctx *src_io , char const   *filename ,
                       int lno , char *buf___17 , int buflen ) 
{ 
  FILE *file ;
  int c ;
  int i ;
  char *p ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 332
  file = src_io->file;
#line 336
  p = buf___17;
#line 337
  buflen --;
#line 338
  i = 0;
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (i == buflen) {
      {
#line 342
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: line too long, ignored", filename,
                 lno);
      }
#line 343
      goto x_badline;
    }
    {
#line 345
    c = _IO_getc(file);
    }
#line 346
    if (! c) {
      {
#line 347
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: line contains nul, ignored",
                 filename, lno);
      }
#line 348
      goto x_badline;
    } else
#line 349
    if (c == 10) {
#line 350
      goto while_break;
    } else
#line 351
    if (c == -1) {
      {
#line 352
      tmp___2 = ferror(file);
      }
#line 352
      if (tmp___2) {
        {
#line 353
        tmp = __errno_location();
#line 353
        saveerr___2(ads___7, *tmp);
#line 354
        tmp___0 = __errno_location();
#line 354
        tmp___1 = strerror(*tmp___0);
#line 354
        adns__diag(ads___7, -1, (adns_query )0, "%s:%d: read error: %s", filename,
                   lno, tmp___1);
        }
#line 356
        return (-1);
      }
#line 358
      if (! i) {
#line 358
        return (-1);
      }
#line 359
      goto while_break;
    } else {
#line 361
      tmp___3 = p;
#line 361
      p ++;
#line 361
      *tmp___3 = (char )c;
#line 362
      i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 366
  tmp___4 = p;
#line 366
  p ++;
#line 366
  *tmp___4 = (char)0;
#line 367
  return (i);
  x_badline: 
  {
#line 370
  saveerr___2(ads___7, 22);
  }
  {
#line 371
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 371
    c = _IO_getc(file);
    }
#line 371
    if (c != -1) {
#line 371
      if (! (c != 10)) {
#line 371
        goto while_break___0;
      }
    } else {
#line 371
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 372
  return (-2);
}
}
#line 375 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int gl_text___2(adns_state ads___7 , getline_ctx *src_io , char const   *filename ,
                       int lno , char *buf___17 , int buflen ) 
{ 
  char const   *cp ;
  int l ;
  size_t tmp ;

  {
#line 377
  cp = src_io->text;
#line 380
  if (! cp) {
#line 380
    return (-1);
  } else
#line 380
  if (! *cp) {
#line 380
    return (-1);
  }
#line 382
  if ((int const   )*cp == 59) {
#line 382
    cp ++;
  } else
#line 382
  if ((int const   )*cp == 10) {
#line 382
    cp ++;
  }
  {
#line 383
  tmp = strcspn(cp, ";\n");
#line 383
  l = (int )tmp;
#line 384
  src_io->text = cp + l;
  }
#line 386
  if (l >= buflen) {
    {
#line 387
    adns__diag(ads___7, -1, (adns_query )0, "%s:%d: line too long, ignored", filename,
               lno);
#line 388
    saveerr___2(ads___7, 22);
    }
#line 389
    return (-2);
  }
  {
#line 392
  memcpy((void */* __restrict  */)buf___17, (void const   */* __restrict  */)cp, (size_t )l);
#line 393
  *(buf___17 + l) = (char)0;
  }
#line 394
  return (l);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfiggeneric___2(adns_state ads___7 , char const   *filename , int (*getline___0)(adns_state ads ,
                                                                                                   getline_ctx * ,
                                                                                                   char const   *filename ,
                                                                                                   int lno ,
                                                                                                   char *buf ,
                                                                                                   int buflen ) ,
                                  getline_ctx gl_ctx ) 
{ 
  char linebuf[2000] ;
  char *p ;
  char *q ;
  int lno ;
  int l ;
  int dirl ;
  struct configcommandinfo  const  *ccip ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 410
  lno = 1;
  {
#line 410
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 410
    l = (*getline___0)(ads___7, & gl_ctx, filename, lno, linebuf, (int )sizeof(linebuf));
    }
#line 410
    if (! (l != -1)) {
#line 410
      goto while_break;
    }
#line 413
    if (l == -2) {
#line 413
      goto __Cont;
    }
    {
#line 414
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 414
      if (l > 0) {
        {
#line 414
        tmp = ctype_whitespace((int )linebuf[l - 1]);
        }
#line 414
        if (! tmp) {
#line 414
          goto while_break___0;
        }
      } else {
#line 414
        goto while_break___0;
      }
#line 414
      l --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 415
    linebuf[l] = (char)0;
#line 416
    p = linebuf;
    {
#line 417
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 417
      tmp___0 = ctype_whitespace((int )*p);
      }
#line 417
      if (! tmp___0) {
#line 417
        goto while_break___1;
      }
#line 417
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 418
    if ((int )*p == 35) {
#line 418
      goto __Cont;
    } else
#line 418
    if ((int )*p == 59) {
#line 418
      goto __Cont;
    } else
#line 418
    if (! *p) {
#line 418
      goto __Cont;
    }
#line 419
    q = p;
    {
#line 420
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 420
      if (*q) {
        {
#line 420
        tmp___1 = ctype_whitespace((int )*q);
        }
#line 420
        if (tmp___1) {
#line 420
          goto while_break___2;
        }
      } else {
#line 420
        goto while_break___2;
      }
#line 420
      q ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 421
    dirl = (int )(q - p);
#line 422
    ccip = configcommandinfos___2;
    {
#line 422
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 422
      if (ccip->name) {
        {
#line 422
        tmp___2 = strlen((char const   *)ccip->name);
        }
#line 422
        if (tmp___2 == (size_t )dirl) {
          {
#line 422
          tmp___3 = memcmp((void const   *)ccip->name, (void const   *)p, (size_t )(q - p));
          }
#line 422
          if (! tmp___3) {
#line 422
            goto while_break___3;
          }
        }
      } else {
#line 422
        goto while_break___3;
      }
#line 422
      ccip ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 426
    if (! ccip->name) {
      {
#line 427
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown configuration directive `%.*s\'",
                 filename, lno, (int )(q - p), p);
      }
#line 429
      goto __Cont;
    }
    {
#line 431
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 431
      tmp___4 = ctype_whitespace((int )*q);
      }
#line 431
      if (! tmp___4) {
#line 431
        goto while_break___4;
      }
#line 431
      q ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 432
    (*(ccip->fn))(ads___7, filename, lno, (char const   *)q);
    }
    __Cont: /* CIL Label */ 
#line 410
    lno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 434
  return;
}
}
#line 436 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static char const   *instrum_getenv___2(adns_state ads___7 , char const   *envvar ) 
{ 
  char const   *value ;
  char *tmp ;

  {
  {
#line 439
  tmp = getenv(envvar);
#line 439
  value = (char const   *)tmp;
  }
#line 440
  if (! value) {
    {
#line 440
    adns__debug(ads___7, -1, (adns_query )0, "environment variable %s not set", envvar);
    }
  } else {
    {
#line 441
    adns__debug(ads___7, -1, (adns_query )0, "environment variable %s set to `%s\'",
                envvar, value);
    }
  }
#line 443
  return (value);
}
}
#line 446 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfig___2(adns_state ads___7 , char const   *filename , int warnmissing ) 
{ 
  getline_ctx gl_ctx ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 449
  gl_ctx.file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 450
  if (! gl_ctx.file) {
    {
#line 451
    tmp = __errno_location();
    }
#line 451
    if (*tmp == 2) {
#line 452
      if (warnmissing) {
        {
#line 453
        adns__debug(ads___7, -1, (adns_query )0, "configuration file `%s\' does not exist",
                    filename);
        }
      }
#line 455
      return;
    }
    {
#line 457
    tmp___0 = __errno_location();
#line 457
    saveerr___2(ads___7, *tmp___0);
#line 458
    tmp___1 = __errno_location();
#line 458
    tmp___2 = strerror(*tmp___1);
#line 458
    adns__diag(ads___7, -1, (adns_query )0, "cannot open configuration file `%s\': %s",
               filename, tmp___2);
    }
#line 460
    return;
  }
  {
#line 463
  readconfiggeneric___2(ads___7, filename, & gl_file___2, gl_ctx);
#line 465
  fclose(gl_ctx.file);
  }
#line 466
  return;
}
}
#line 468 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfigtext___2(adns_state ads___7 , char const   *text , char const   *showname ) 
{ 
  getline_ctx gl_ctx ;

  {
  {
#line 472
  gl_ctx.text = text;
#line 473
  readconfiggeneric___2(ads___7, showname, & gl_text___2, gl_ctx);
  }
#line 474
  return;
}
}
#line 476 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfigenv___2(adns_state ads___7 , char const   *envvar ) 
{ 
  char const   *filename ;

  {
#line 479
  if ((unsigned int )ads___7->iflags & 1U) {
    {
#line 480
    adns__debug(ads___7, -1, (adns_query )0, "not checking environment variable `%s\'",
                envvar);
    }
#line 481
    return;
  }
  {
#line 483
  filename = instrum_getenv___2(ads___7, envvar);
  }
#line 484
  if (filename) {
    {
#line 484
    readconfig___2(ads___7, filename, 1);
    }
  }
#line 485
  return;
}
}
#line 487 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfigenvtext___2(adns_state ads___7 , char const   *envvar ) 
{ 
  char const   *textdata ;

  {
#line 490
  if ((unsigned int )ads___7->iflags & 1U) {
    {
#line 491
    adns__debug(ads___7, -1, (adns_query )0, "not checking environment variable `%s\'",
                envvar);
    }
#line 492
    return;
  }
  {
#line 494
  textdata = instrum_getenv___2(ads___7, envvar);
  }
#line 495
  if (textdata) {
    {
#line 495
    readconfigtext___2(ads___7, textdata, envvar);
    }
  }
#line 496
  return;
}
}
#line 508 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int init_begin___2(adns_state *ads_r , adns_initflags flags , adns_logcallbackfn *logfn ,
                          void *logfndata ) 
{ 
  adns_state ads___7 ;
  pid_t pid ;
  void *tmp ;
  int *tmp___0 ;
  adns_query tmp___1 ;
  adns_query tmp___2 ;
  adns_query tmp___3 ;
  adns_query tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __suseconds_t tmp___9 ;

  {
  {
#line 513
  tmp = Hmalloc(sizeof(*ads___7));
#line 513
  ads___7 = (adns_state )tmp;
  }
#line 513
  if (! ads___7) {
    {
#line 513
    tmp___0 = __errno_location();
    }
#line 513
    return (*tmp___0);
  }
  {
#line 515
  ads___7->iflags = flags;
#line 516
  ads___7->logfn = logfn;
#line 517
  ads___7->logfndata = logfndata;
#line 518
  ads___7->configerrno = 0;
#line 519
  tmp___1 = (adns_query )0;
#line 519
  ads___7->udpw.tail = tmp___1;
#line 519
  ads___7->udpw.head = tmp___1;
#line 520
  tmp___2 = (adns_query )0;
#line 520
  ads___7->tcpw.tail = tmp___2;
#line 520
  ads___7->tcpw.head = tmp___2;
#line 521
  tmp___3 = (adns_query )0;
#line 521
  ads___7->childw.tail = tmp___3;
#line 521
  ads___7->childw.head = tmp___3;
#line 522
  tmp___4 = (adns_query )0;
#line 522
  ads___7->output.tail = tmp___4;
#line 522
  ads___7->output.head = tmp___4;
#line 523
  ads___7->forallnext = (adns_query )0;
#line 524
  ads___7->nextid = 12575;
#line 525
  tmp___5 = -1;
#line 525
  ads___7->tcpsocket = tmp___5;
#line 525
  ads___7->udpsocket = tmp___5;
#line 526
  adns__vbuf_init(& ads___7->tcpsend);
#line 527
  adns__vbuf_init(& ads___7->tcprecv);
#line 528
  ads___7->tcprecv_skip = 0;
#line 529
  tmp___8 = 0;
#line 529
  ads___7->tcpserver = tmp___8;
#line 529
  tmp___7 = tmp___8;
#line 529
  ads___7->nsearchlist = tmp___7;
#line 529
  tmp___6 = tmp___7;
#line 529
  ads___7->nsortlist = tmp___6;
#line 529
  ads___7->nservers = tmp___6;
#line 530
  ads___7->searchndots = 1;
#line 531
  ads___7->tcpstate = (enum adns__tcpstate )0;
#line 532
  tmp___9 = (__suseconds_t )0;
#line 532
  ads___7->tcptimeout.tv_usec = tmp___9;
#line 532
  ads___7->tcptimeout.tv_sec = tmp___9;
#line 533
  ads___7->searchlist = (char **)0;
#line 535
  pid = Hgetpid();
#line 536
  ads___7->rand48xsubi[0] = (unsigned short )pid;
#line 537
  ads___7->rand48xsubi[1] = (unsigned short )((unsigned long )pid >> 16);
#line 538
  ads___7->rand48xsubi[2] = (unsigned short )((unsigned long )pid ^ ((unsigned long )pid >> 16));
#line 540
  *ads_r = ads___7;
  }
#line 541
  return (0);
}
}
#line 544 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int init_finish___2(adns_state ads___7 ) 
{ 
  struct in_addr ia ;
  struct protoent *proto ;
  int r ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 549
  if (! ads___7->nservers) {
#line 550
    if (ads___7->logfn) {
#line 550
      if ((unsigned int )ads___7->iflags & 8U) {
        {
#line 551
        adns__lprintf(ads___7, "adns: no nameservers, using localhost\n");
        }
      }
    }
    {
#line 552
    ia.s_addr = htonl((in_addr_t )2130706433);
#line 553
    addserver___2(ads___7, ia);
    }
  }
  {
#line 556
  proto = getprotobyname("udp");
  }
#line 556
  if (! proto) {
#line 556
    r = 92;
#line 556
    goto x_free;
  }
  {
#line 557
  ads___7->udpsocket = Hsocket(2, 2, proto->p_proto);
  }
#line 558
  if (ads___7->udpsocket < 0) {
    {
#line 558
    tmp = __errno_location();
#line 558
    r = *tmp;
    }
#line 558
    goto x_free;
  }
  {
#line 560
  r = adns__setnonblock(ads___7, ads___7->udpsocket);
  }
#line 561
  if (r) {
    {
#line 561
    tmp___0 = __errno_location();
#line 561
    r = *tmp___0;
    }
#line 561
    goto x_closeudp;
  }
#line 563
  return (0);
  x_closeudp: 
  {
#line 566
  Hclose(ads___7->udpsocket);
  }
  x_free: 
  {
#line 568
  Hfree((void *)ads___7);
  }
#line 569
  return (r);
}
}
#line 572 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void init_abort___2(adns_state ads___7 ) 
{ 


  {
#line 573
  if (ads___7->nsearchlist) {
    {
#line 574
    Hfree((void *)*(ads___7->searchlist + 0));
#line 575
    Hfree((void *)ads___7->searchlist);
    }
  }
  {
#line 577
  Hfree((void *)ads___7);
  }
#line 578
  return;
}
}
#line 580 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void logfn_file___2(adns_state ads___7 , void *logfndata , char const   *fmt ,
                           va_list al ) 
{ 


  {
  {
#line 582
  vfprintf((FILE */* __restrict  */)logfndata, (char const   */* __restrict  */)fmt,
           al);
  }
#line 583
  return;
}
}
#line 585 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int init_files___2(adns_state *ads_r , adns_initflags flags , adns_logcallbackfn *logfn ,
                          void *logfndata ) 
{ 
  adns_state ads___7 ;
  char const   *res_options ;
  char const   *adns_res_options ;
  int r ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 591
  r = init_begin___2(& ads___7, flags, logfn, logfndata);
  }
#line 592
  if (r) {
#line 592
    return (r);
  }
  {
#line 594
  res_options = instrum_getenv___2(ads___7, "RES_OPTIONS");
#line 595
  adns_res_options = instrum_getenv___2(ads___7, "ADNS_RES_OPTIONS");
#line 596
  ccf_options___2(ads___7, "RES_OPTIONS", -1, res_options);
#line 597
  ccf_options___2(ads___7, "ADNS_RES_OPTIONS", -1, adns_res_options);
#line 599
  readconfig___2(ads___7, "/etc/resolv.conf", 1);
#line 600
  readconfig___2(ads___7, "/etc/resolv-adns.conf", 0);
#line 601
  readconfigenv___2(ads___7, "RES_CONF");
#line 602
  readconfigenv___2(ads___7, "ADNS_RES_CONF");
#line 604
  readconfigenvtext___2(ads___7, "RES_CONF_TEXT");
#line 605
  readconfigenvtext___2(ads___7, "ADNS_RES_CONF_TEXT");
#line 607
  ccf_options___2(ads___7, "RES_OPTIONS", -1, res_options);
#line 608
  ccf_options___2(ads___7, "ADNS_RES_OPTIONS", -1, adns_res_options);
#line 610
  tmp = instrum_getenv___2(ads___7, "LOCALDOMAIN");
#line 610
  ccf_search___2(ads___7, "LOCALDOMAIN", -1, tmp);
#line 611
  tmp___0 = instrum_getenv___2(ads___7, "ADNS_LOCALDOMAIN");
#line 611
  ccf_search___2(ads___7, "ADNS_LOCALDOMAIN", -1, tmp___0);
  }
#line 613
  if (ads___7->configerrno) {
#line 613
    if (ads___7->configerrno != 22) {
      {
#line 614
      r = ads___7->configerrno;
#line 615
      init_abort___2(ads___7);
      }
#line 616
      return (r);
    }
  }
  {
#line 619
  r = init_finish___2(ads___7);
  }
#line 620
  if (r) {
#line 620
    return (r);
  }
  {
#line 622
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
#line 623
  *ads_r = ads___7;
  }
#line 624
  return (0);
}
}
#line 631 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int init_strcfg___2(adns_state *ads_r , adns_initflags flags , adns_logcallbackfn *logfn ,
                           void *logfndata , char const   *configtext ) 
{ 
  adns_state ads___7 ;
  int r ;

  {
  {
#line 637
  r = init_begin___2(& ads___7, flags, logfn, logfndata);
  }
#line 638
  if (r) {
#line 638
    return (r);
  }
  {
#line 640
  readconfigtext___2(ads___7, configtext, "<supplied configuration text>");
  }
#line 641
  if (ads___7->configerrno) {
    {
#line 642
    r = ads___7->configerrno;
#line 643
    init_abort___2(ads___7);
    }
#line 644
    return (r);
  }
  {
#line 647
  r = init_finish___2(ads___7);
  }
#line 647
  if (r) {
#line 647
    return (r);
  }
  {
#line 648
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
#line 649
  *ads_r = ads___7;
  }
#line 650
  return (0);
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
static vbuf vbw___2  ;
#line 175 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
static void Tvbpollevents___2(int events ) 
{ 
  char const   *delim ;

  {
#line 176
  delim = "";
#line 177
  events &= 7;
#line 178
  if (! events) {
    {
#line 178
    Tvba("0");
    }
#line 178
    return;
  }
#line 179
  if (events & 1) {
    {
#line 179
    Tvba("POLLIN");
#line 179
    delim = "|";
    }
  }
#line 180
  if (events & 4) {
    {
#line 180
    Tvba(delim);
#line 180
    Tvba("POLLOUT");
#line 180
    delim = "|";
    }
  }
#line 181
  if (events & 2) {
    {
#line 181
    Tvba(delim);
#line 181
    Tvba("POLLPRI");
    }
  }
#line 182
  return;
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
static unsigned long malloccount___2  ;
#line 241 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
static unsigned long mallocfailat___2  ;
#line 242 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
static struct __anonstruct_mallocedlist_90___2 mallocedlist___2  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnslogres.c"
static char const   * const  progname___0  =    (char const   */* const  */)"adnslogres";
#line 69 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnslogres.c"
static char const   *config_text___1  ;
#line 76 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnslogres.c"
static void msg___0(char const   *fmt  , ...) 
{ 
  va_list al ;

  {
  {
#line 79
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
          progname___0);
#line 80
  __builtin_va_start(al, fmt);
#line 81
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           al);
#line 82
  __builtin_va_end(al);
#line 83
  fputc('\n', stderr);
  }
#line 84
  return;
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnslogres.c"
static void aargh___0(char const   *cause ) 
{ 
  char const   *why ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 87
  tmp = __errno_location();
#line 87
  tmp___0 = strerror(*tmp);
#line 87
  why = (char const   *)tmp___0;
  }
#line 88
  if (! why) {
#line 88
    why = "Unknown error";
  }
  {
#line 89
  tmp___1 = __errno_location();
#line 89
  msg___0("%s: %s (%d)", cause, why, *tmp___1);
#line 90
  Hexit(1);
  }
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnslogres.c"
static char buf___3[30]  ;
#line 96 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnslogres.c"
static char *ipaddr2domain___0(char *start , char **addr , char **rest ) 
{ 
  char *ptrs[5] ;
  int i ;
  char *tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
#line 101
  ptrs[0] = start;
  retry: 
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 103
    tmp___1 = __ctype_b_loc();
    }
#line 103
    if ((int const   )*(*tmp___1 + (int )((unsigned char )*(ptrs[0]))) & 2048) {
#line 103
      goto while_break;
    }
#line 104
    tmp___0 = ptrs[0];
#line 104
    (ptrs[0]) ++;
#line 104
    if (! *tmp___0) {
      {
#line 105
      strcpy((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)"invalid.");
#line 106
      tmp = (char *)((void *)0);
#line 106
      *rest = tmp;
#line 106
      *addr = tmp;
      }
#line 107
      return (buf___3);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 109
  i = 1;
  {
#line 109
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 109
    if (! (i < 5)) {
#line 109
      goto while_break___0;
    }
#line 110
    ptrs[i] = ptrs[i - 1];
    {
#line 111
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 111
      tmp___2 = __ctype_b_loc();
#line 111
      tmp___3 = ptrs[i];
#line 111
      (ptrs[i]) ++;
      }
#line 111
      if (! ((int const   )*(*tmp___2 + (int )((unsigned char )*tmp___3)) & 2048)) {
#line 111
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 112
    if (i == 4) {
      {
#line 112
      tmp___4 = __ctype_b_loc();
      }
#line 112
      if ((int const   )*(*tmp___4 + (int )((unsigned char )*(ptrs[i] + -1))) & 8192) {
#line 112
        goto _L___0;
      } else {
#line 115
        ptrs[0] = ptrs[i] - 1;
#line 116
        goto retry;
      }
    } else
    _L___0: /* CIL Label */ 
#line 112
    if (i != 4) {
#line 112
      if ((int )*(ptrs[i] + -1) != 46) {
#line 115
        ptrs[0] = ptrs[i] - 1;
#line 116
        goto retry;
      } else {
#line 112
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 112
    if (ptrs[i] - ptrs[i - 1] > 4L) {
#line 115
      ptrs[0] = ptrs[i] - 1;
#line 116
      goto retry;
    }
#line 109
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 119
  sprintf((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)"%.*s.%.*s.%.*s.%.*s.in-addr.arpa.",
          (int )((ptrs[4] - ptrs[3]) - 1L), ptrs[3], (int )((ptrs[3] - ptrs[2]) - 1L),
          ptrs[2], (int )((ptrs[2] - ptrs[1]) - 1L), ptrs[1], (int )((ptrs[1] - ptrs[0]) - 1L),
          ptrs[0]);
#line 124
  *addr = ptrs[0];
#line 125
  *rest = ptrs[4] - 1;
  }
#line 126
  return (buf___3);
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnslogres.c"
static void printline___0(FILE *outf , char *start , char *addr , char *rest , char *domain ) 
{ 
  int tmp ;

  {
#line 130
  if (domain) {
    {
#line 131
    fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)"%.*s%s%s",
            (int )(addr - start), start, domain, rest);
    }
  } else {
    {
#line 133
    fputs((char const   */* __restrict  */)start, (FILE */* __restrict  */)outf);
    }
  }
  {
#line 134
  tmp = ferror(outf);
  }
#line 134
  if (tmp) {
    {
#line 134
    aargh___0("write output");
    }
  }
#line 135
  return;
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnslogres.c"
static char buf___4[1024]  ;
#line 143 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnslogres.c"
static logline *readline___0(FILE *inf , adns_state adns , int opts ) 
{ 
  char *str ;
  logline *line ;
  size_t tmp ;
  void *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 148
  tmp___3 = fgets((char */* __restrict  */)(buf___4), 1024, (FILE */* __restrict  */)inf);
  }
#line 148
  if (tmp___3) {
    {
#line 149
    tmp = strlen((char const   *)(buf___4));
#line 149
    tmp___0 = Hmalloc((sizeof(*line) + tmp) + 1UL);
#line 149
    str = (char *)tmp___0;
    }
#line 150
    if (! str) {
      {
#line 150
      aargh___0("malloc");
      }
    }
    {
#line 151
    line = (logline *)str;
#line 152
    line->next = (struct logline *)((void *)0);
#line 153
    line->start = str + sizeof(logline );
#line 154
    strcpy((char */* __restrict  */)line->start, (char const   */* __restrict  */)(buf___4));
#line 155
    str = ipaddr2domain___0(line->start, & line->addr, & line->rest);
    }
#line 156
    if (opts & 1) {
#line 157
      if (line->addr) {
#line 157
        tmp___1 = (char const   *)line->addr;
      } else {
#line 157
        tmp___1 = "";
      }
      {
#line 157
      msg___0("submitting %.*s -> %s", (int )(line->rest - line->addr), tmp___1, str);
      }
    }
    {
#line 158
    tmp___2 = adns_submit(adns, (char const   *)str, (adns_rrtype )65548, (adns_queryflags )256,
                          (void *)0, & line->query);
    }
#line 158
    if (tmp___2) {
      {
#line 161
      aargh___0("adns_submit");
      }
    }
#line 162
    return (line);
  }
  {
#line 164
  tmp___4 = feof(inf);
  }
#line 164
  if (! tmp___4) {
    {
#line 165
    aargh___0("fgets");
    }
  }
#line 166
  return ((logline *)((void *)0));
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnslogres.c"
static void proclog___0(FILE *inf , FILE *outf , int maxpending , int opts ) 
{ 
  int eof ;
  int err ;
  int len ;
  adns_state adns ;
  adns_answer *answer ;
  logline *head ;
  logline *tail ;
  logline *line ;
  adns_initflags initflags___3 ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 176
  if (opts & 1) {
#line 176
    initflags___3 = (adns_initflags )8;
  } else {
#line 176
    initflags___3 = (adns_initflags )0;
  }
#line 177
  if (config_text___1) {
    {
#line 178
    tmp = __errno_location();
#line 178
    *tmp = adns_init_strcfg(& adns, initflags___3, stderr, config_text___1);
    }
  } else {
    {
#line 180
    tmp___0 = __errno_location();
#line 180
    *tmp___0 = adns_init(& adns, initflags___3, (FILE *)0);
    }
  }
  {
#line 182
  tmp___1 = __errno_location();
  }
#line 182
  if (*tmp___1) {
    {
#line 182
    aargh___0("adns_init");
    }
  }
  {
#line 183
  tail = readline___0(inf, adns, opts);
#line 183
  head = tail;
#line 184
  len = 1;
#line 184
  eof = 0;
  }
  {
#line 185
  while (1) {
    while_continue: /* CIL Label */ ;
#line 185
    if (! head) {
#line 185
      goto while_break;
    }
    {
#line 186
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 186
      if (! head) {
#line 186
        goto while_break___0;
      }
#line 187
      if (opts & 1) {
#line 188
        if (head->addr) {
#line 188
          tmp___2 = (char const   *)head->addr;
        } else {
#line 188
          tmp___2 = "";
        }
        {
#line 188
        msg___0("%d in queue; checking %.*s", len, (int )(head->rest - head->addr),
                tmp___2);
        }
      }
#line 190
      if (eof) {
#line 190
        goto _L;
      } else
#line 190
      if (len >= maxpending) {
        _L: /* CIL Label */ 
#line 191
        if (opts & 2) {
          {
#line 192
          err = adns_wait_poll(adns, & head->query, & answer, (void **)((void *)0));
          }
        } else {
          {
#line 194
          err = adns_wait(adns, & head->query, & answer, (void **)((void *)0));
          }
        }
      } else {
        {
#line 196
        err = adns_check(adns, & head->query, & answer, (void **)((void *)0));
        }
      }
#line 198
      if (err == 11) {
#line 198
        goto while_break___0;
      }
#line 199
      if (err) {
        {
#line 200
        tmp___3 = strerror(err);
#line 200
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: adns_wait/check: %s",
                progname___0, tmp___3);
#line 201
        Hexit(1);
        }
      }
#line 203
      if ((unsigned int )answer->status == 0U) {
#line 203
        tmp___4 = *(answer->rrs.str);
      } else {
#line 203
        tmp___4 = (char *)((void *)0);
      }
      {
#line 203
      printline___0(outf, head->start, head->addr, head->rest, tmp___4);
#line 205
      line = head;
#line 205
      head = head->next;
#line 206
      Hfree((void *)line);
#line 207
      Hfree((void *)answer);
#line 208
      len --;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 210
    if (! eof) {
      {
#line 211
      line = readline___0(inf, adns, opts);
      }
#line 212
      if (line) {
#line 213
        if (! head) {
#line 213
          head = line;
        } else {
#line 214
          tail->next = line;
        }
#line 215
        tail = line;
#line 215
        len ++;
      } else {
#line 217
        eof = 1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 221
  adns_finish(adns);
  }
#line 222
  return;
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnslogres.c"
static void printhelp___0(FILE *file ) 
{ 


  {
  {
#line 225
  fputs((char const   */* __restrict  */)"usage: adnslogres [<options>] [<logfile>]\n       adnslogres --version|--help\noptions: -c <concurrency>  set max number of outstanding queries\n         -p                use poll(2) instead of select(2)\n         -d                turn on debugging\n         -C <config>       use instead of contents of resolv.conf\n",
        (FILE */* __restrict  */)stdout);
  }
#line 232
  return;
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnslogres.c"
static void usage___0(void) 
{ 


  {
  {
#line 235
  printhelp___0(stderr);
#line 236
  Hexit(1);
  }
}
}
#line 9 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hrecord.c"
static FILE *Toutputfile___1  ;
#line 12 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hrecord.c"
static void R_recordtime___0(void) 
{ 
  int r ;
  struct timeval tv ;
  struct timeval tvrel ;

  {
  {
#line 15
  Tensurerecordfile();
#line 16
  r = gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )0);
  }
#line 16
  if (r) {
    {
#line 16
    Tfailed("gettimeofday syscallbegin");
    }
  }
#line 17
  tvrel.tv_sec = tv.tv_sec - currenttime.tv_sec;
#line 18
  tvrel.tv_usec = tv.tv_usec - currenttime.tv_usec;
#line 19
  if (tv.tv_usec < 0L) {
#line 19
    tvrel.tv_usec += 1000000L;
#line 19
    (tvrel.tv_sec) --;
  }
  {
#line 20
  Tvbf("\n +%ld.%06ld", tvrel.tv_sec, tvrel.tv_usec);
#line 21
  currenttime = tv;
  }
#line 22
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hrecord.c"
static void R_vb___0(void) 
{ 


  {
  {
#line 44
  Q_vb();
  }
#line 45
  return;
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_qstring___2(parseinfo const   *pai , int *cbyte_io , int max ,
                                   int *len_r , char **str_r ) 
{ 
  byte const   *dgram ;
  int l ;
  int cbyte___3 ;
  char *str ;
  int tmp ;
  void *tmp___0 ;

  {
#line 92
  dgram = (byte const   *)pai->dgram;
#line 96
  cbyte___3 = *cbyte_io;
#line 98
  if (cbyte___3 >= max) {
#line 98
    return ((adns_status )104);
  }
#line 99
  tmp = cbyte___3;
#line 99
  cbyte___3 ++;
#line 99
  l = (int )((int const   )*(dgram + tmp) & 255);
#line 100
  if (cbyte___3 + l > max) {
#line 100
    return ((adns_status )104);
  }
  {
#line 102
  tmp___0 = adns__alloc_interim((adns_query )pai->qu, (size_t )(l + 1));
#line 102
  str = (char *)tmp___0;
  }
#line 103
  if (! str) {
#line 103
    return ((adns_status )1);
  }
  {
#line 105
  *(str + l) = (char)0;
#line 106
  memcpy((void */* __restrict  */)str, (void const   */* __restrict  */)(dgram + cbyte___3),
         (size_t )l);
#line 108
  *len_r = l;
#line 109
  *str_r = str;
#line 110
  *cbyte_io = cbyte___3 + l;
  }
#line 112
  return ((adns_status )0);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_qstring___2(vbuf *vb___0 , char const   *dp , int len ) 
{ 
  unsigned char ch ;
  char buf___17[10] ;
  int cn ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 120
    tmp = adns__vbuf_appendstr(vb___0, "\"");
    }
#line 120
    if (! tmp) {
#line 120
      return ((adns_status )1);
    }
#line 120
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  cn = 0;
  {
#line 121
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 121
    if (! (cn < len)) {
#line 121
      goto while_break___0;
    }
#line 122
    tmp___0 = dp;
#line 122
    dp ++;
#line 122
    ch = (unsigned char )*tmp___0;
#line 123
    if ((int )ch == 92) {
      {
#line 124
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 124
        tmp___1 = adns__vbuf_appendstr(vb___0, "\\\\");
        }
#line 124
        if (! tmp___1) {
#line 124
          return ((adns_status )1);
        }
#line 124
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else
#line 125
    if ((int )ch == 34) {
      {
#line 126
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 126
        tmp___2 = adns__vbuf_appendstr(vb___0, "\\\"");
        }
#line 126
        if (! tmp___2) {
#line 126
          return ((adns_status )1);
        }
#line 126
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else
#line 127
    if ((int )ch >= 32) {
#line 127
      if ((int )ch <= 126) {
        {
#line 128
        tmp___3 = adns__vbuf_append(vb___0, (byte const   *)(& ch), 1);
        }
#line 128
        if (! tmp___3) {
#line 128
          return ((adns_status )1);
        }
      } else {
#line 127
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 130
      sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"\\x%02x",
              (int )ch);
      }
      {
#line 131
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 131
        tmp___4 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
        }
#line 131
        if (! tmp___4) {
#line 131
          return ((adns_status )1);
        }
#line 131
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 121
    cn ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 134
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 134
    tmp___5 = adns__vbuf_appendstr(vb___0, "\"");
    }
#line 134
    if (! tmp___5) {
#line 134
      return ((adns_status )1);
    }
#line 134
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 136
  return ((adns_status )0);
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_str___2(adns_query qu , void *datap ) 
{ 
  char **rrp ;

  {
  {
#line 144
  rrp = (char **)datap;
#line 146
  adns__makefinal_str(qu, rrp);
  }
#line 147
  return;
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_intstr___2(adns_query qu , void *datap ) 
{ 
  adns_rr_intstr *rrp ;

  {
  {
#line 154
  rrp = (adns_rr_intstr *)datap;
#line 156
  adns__makefinal_str(qu, & rrp->str);
  }
#line 157
  return;
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_manyistr___2(adns_query qu , void *datap ) 
{ 
  adns_rr_intstr **rrp ;
  adns_rr_intstr *te ;
  adns_rr_intstr *table ;
  void *tablev ;
  int tc ;

  {
#line 164
  rrp = (adns_rr_intstr **)datap;
#line 169
  tc = 0;
#line 169
  te = *rrp;
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    if (! (te->i >= 0)) {
#line 169
      goto while_break;
    }
#line 169
    te ++;
#line 169
    tc ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 170
  tablev = (void *)*rrp;
#line 171
  adns__makefinal_block(qu, & tablev, sizeof(*te) * (unsigned long )(tc + 1));
#line 172
  table = (adns_rr_intstr *)tablev;
#line 172
  *rrp = table;
#line 173
  te = *rrp;
  }
  {
#line 173
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 173
    if (! (te->i >= 0)) {
#line 173
      goto while_break___0;
    }
    {
#line 174
    adns__makefinal_str(qu, & te->str);
#line 173
    te ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 175
  return;
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_txt___2(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  adns_rr_intstr **rrp ;
  adns_rr_intstr *table ;
  adns_rr_intstr *te ;
  byte const   *dgram ;
  int ti ;
  int tc ;
  int l ;
  int startbyte ;
  adns_status st ;
  int tmp ;
  void *tmp___0 ;

  {
#line 183
  rrp = (adns_rr_intstr **)datap;
#line 184
  dgram = (byte const   *)pai->dgram;
#line 188
  startbyte = cbyte___3;
#line 189
  if (cbyte___3 >= max) {
#line 189
    return ((adns_status )104);
  }
#line 190
  tc = 0;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! (cbyte___3 < max)) {
#line 191
      goto while_break;
    }
#line 192
    tmp = cbyte___3;
#line 192
    cbyte___3 ++;
#line 192
    l = (int )((int const   )*(dgram + tmp) & 255);
#line 193
    cbyte___3 += l;
#line 194
    tc ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  if (cbyte___3 != max) {
#line 196
    return ((adns_status )104);
  } else
#line 196
  if (! tc) {
#line 196
    return ((adns_status )104);
  }
  {
#line 198
  tmp___0 = adns__alloc_interim((adns_query )pai->qu, sizeof(*table) * (unsigned long )(tc + 1));
#line 198
  table = (adns_rr_intstr *)tmp___0;
  }
#line 199
  if (! table) {
#line 199
    return ((adns_status )1);
  }
#line 201
  cbyte___3 = startbyte;
#line 201
  ti = 0;
#line 201
  te = table;
  {
#line 201
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 201
    if (! (ti < tc)) {
#line 201
      goto while_break___0;
    }
    {
#line 202
    st = pap_qstring___2(pai, & cbyte___3, max, & te->i, & te->str);
    }
#line 203
    if (st) {
#line 203
      return (st);
    }
#line 201
    ti ++;
#line 201
    te ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 205
  if (! (cbyte___3 == max)) {
    {
#line 205
    __assert_fail("cbyte == max", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  205U, "pa_txt");
    }
  }
#line 207
  te->i = -1;
#line 208
  te->str = (char *)0;
#line 210
  *rrp = table;
#line 211
  return ((adns_status )0);
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_txt___2(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_intstr const   * const  *rrp ;
  adns_rr_intstr const   *current ;
  adns_status st ;
  int spc ;
  int tmp ;

  {
#line 215
  rrp = (adns_rr_intstr const   * const  *)datap;
#line 220
  current = (adns_rr_intstr const   *)*rrp;
#line 220
  spc = 0;
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    if (! (current->i >= 0)) {
#line 220
      goto while_break;
    }
#line 221
    if (spc) {
      {
#line 221
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 221
        tmp = adns__vbuf_appendstr(vb___0, " ");
        }
#line 221
        if (! tmp) {
#line 221
          return ((adns_status )1);
        }
#line 221
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 222
    st = csp_qstring___2(vb___0, (char const   *)current->str, (int )current->i);
    }
#line 222
    if (st) {
#line 222
      return (st);
    }
#line 220
    current ++;
#line 220
    spc = 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  return ((adns_status )0);
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_hinfo___2(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_intstrpair const   *rrp ;
  adns_status st ;
  int tmp ;

  {
  {
#line 232
  rrp = (adns_rr_intstrpair const   *)datap;
#line 235
  st = csp_qstring___2(vb___0, (char const   *)rrp->array[0].str, (int )rrp->array[0].i);
  }
#line 235
  if (st) {
#line 235
    return (st);
  }
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 236
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 236
    if (! tmp) {
#line 236
      return ((adns_status )1);
    }
#line 236
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 237
  st = csp_qstring___2(vb___0, (char const   *)rrp->array[1].str, (int )rrp->array[1].i);
  }
#line 237
  if (st) {
#line 237
    return (st);
  }
#line 238
  return ((adns_status )0);
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_inaddr___2(parseinfo const   *pai , int cbyte___3 , int max ,
                                 void *datap ) 
{ 
  struct in_addr *storeto ;

  {
#line 247
  storeto = (struct in_addr *)datap;
#line 249
  if (max - cbyte___3 != 4) {
#line 249
    return ((adns_status )104);
  }
  {
#line 250
  memcpy((void */* __restrict  */)storeto, (void const   */* __restrict  */)(pai->dgram + cbyte___3),
         (size_t )4);
  }
#line 251
  return ((adns_status )0);
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int search_sortlist___2(adns_state ads___7 , struct in_addr ad ) 
{ 
  struct sortlist  const  *slp ;
  int i ;

  {
#line 258
  i = 0;
#line 258
  slp = (struct sortlist  const  *)(ads___7->sortlist);
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 258
    if (i < ads___7->nsortlist) {
#line 258
      if (! (! ((ad.s_addr & (unsigned int )slp->mask.s_addr) == (unsigned int )slp->base.s_addr))) {
#line 258
        goto while_break;
      }
    } else {
#line 258
      goto while_break;
    }
#line 258
    i ++;
#line 258
    slp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  return (i);
}
}
#line 265 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int dip_inaddr___2(adns_state ads___7 , struct in_addr a , struct in_addr b ) 
{ 
  int ai ;
  int bi ;

  {
#line 268
  if (! ads___7->nsortlist) {
#line 268
    return (0);
  }
  {
#line 270
  ai = search_sortlist___2(ads___7, a);
#line 271
  bi = search_sortlist___2(ads___7, b);
  }
#line 272
  return (bi < ai);
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_inaddr___2(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  struct in_addr  const  *ap ;
  struct in_addr  const  *bp ;
  int tmp ;

  {
  {
#line 277
  ap = (struct in_addr  const  *)datap_a;
#line 277
  bp = (struct in_addr  const  *)datap_b;
#line 279
  tmp = dip_inaddr___2(ads___7, (struct in_addr )*ap, (struct in_addr )*bp);
  }
#line 279
  return (tmp);
}
}
#line 282 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_inaddr___2(vbuf *vb___0 , void const   *datap ) 
{ 
  struct in_addr  const  *rrp ;
  struct in_addr rr ;
  char const   *ia ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 283
  rrp = (struct in_addr  const  *)datap;
#line 283
  rr = *rrp;
#line 286
  tmp = inet_ntoa(rr);
#line 286
  ia = (char const   *)tmp;
  }
#line 286
  if (! ia) {
    {
#line 286
    __assert_fail("ia", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  286U, "cs_inaddr");
    }
  }
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 287
    tmp___0 = adns__vbuf_appendstr(vb___0, ia);
    }
#line 287
    if (! tmp___0) {
#line 287
      return ((adns_status )1);
    }
#line 287
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  return ((adns_status )0);
}
}
#line 295 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_addr___2(parseinfo const   *pai , int cbyte___3 , int max ,
                               void *datap ) 
{ 
  adns_rr_addr *storeto ;
  byte const   *dgram ;

  {
#line 297
  storeto = (adns_rr_addr *)datap;
#line 298
  dgram = (byte const   *)pai->dgram;
#line 300
  if (max - cbyte___3 != 4) {
#line 300
    return ((adns_status )104);
  }
  {
#line 301
  storeto->len = (int )sizeof(storeto->addr.inet);
#line 302
  memset((void *)(& storeto->addr), 0, sizeof(storeto->addr.inet));
#line 303
  storeto->addr.inet.sin_family = (sa_family_t )2;
#line 304
  memcpy((void */* __restrict  */)(& storeto->addr.inet.sin_addr), (void const   */* __restrict  */)(dgram + cbyte___3),
         (size_t )4);
  }
#line 305
  return ((adns_status )0);
}
}
#line 308 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_addr___2(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_addr const   *ap ;
  adns_rr_addr const   *bp ;
  int tmp ;

  {
#line 309
  ap = (adns_rr_addr const   *)datap_a;
#line 309
  bp = (adns_rr_addr const   *)datap_b;
#line 311
  if (! ((int const   )ap->addr.sa.sa_family == 2)) {
    {
#line 311
    __assert_fail("ap->addr.sa.sa_family == 2", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  311U, "di_addr");
    }
  }
  {
#line 312
  tmp = dip_inaddr___2(ads___7, (struct in_addr )ap->addr.inet.sin_addr, (struct in_addr )bp->addr.inet.sin_addr);
  }
#line 312
  return (tmp);
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int div_addr___2(void *context , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_state ads___7 ;
  int tmp ;

  {
  {
#line 316
  ads___7 = (adns_state )context;
#line 318
  tmp = di_addr___2(ads___7, datap_a, datap_b);
  }
#line 318
  return (tmp);
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_addr___2(vbuf *vb___0 , adns_rr_addr const   *rrp ) 
{ 
  char const   *ia ;
  char buf___17[30] ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 326
  if ((int const   )rrp->addr.inet.sin_family == 2) {
#line 326
    goto case_2;
  }
#line 331
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 327
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 327
    tmp = adns__vbuf_appendstr(vb___0, "INET ");
    }
#line 327
    if (! tmp) {
#line 327
      return ((adns_status )1);
    }
#line 327
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 328
  tmp___0 = inet_ntoa((struct in_addr )rrp->addr.inet.sin_addr);
#line 328
  ia = (char const   *)tmp___0;
  }
#line 328
  if (! ia) {
    {
#line 328
    __assert_fail("ia", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  328U, "csp_addr");
    }
  }
  {
#line 329
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 329
    tmp___1 = adns__vbuf_appendstr(vb___0, ia);
    }
#line 329
    if (! tmp___1) {
#line 329
      return ((adns_status )1);
    }
#line 329
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 330
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 332
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"AF=%u",
          (int const   )rrp->addr.sa.sa_family);
  }
  {
#line 333
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 333
    tmp___2 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 333
    if (! tmp___2) {
#line 333
      return ((adns_status )1);
    }
#line 333
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 334
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 336
  return ((adns_status )0);
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_addr___2(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_addr const   *rrp ;
  adns_status tmp ;

  {
  {
#line 340
  rrp = (adns_rr_addr const   *)datap;
#line 342
  tmp = csp_addr___2(vb___0, rrp);
  }
#line 342
  return (tmp);
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_domain___2(parseinfo const   *pai , int *cbyte_io , int max ,
                                  char **domain_r , parsedomain_flags flags ) 
{ 
  adns_status st ;
  char *dm ;
  void *tmp ;

  {
  {
#line 355
  st = adns__parse_domain((pai->qu)->ads, (int )pai->serv, (adns_query )pai->qu, & (pai->qu)->vb,
                          flags, (byte const   *)pai->dgram, (int )pai->dglen, cbyte_io,
                          max);
  }
#line 357
  if (st) {
#line 357
    return (st);
  }
#line 358
  if (! (pai->qu)->vb.used) {
#line 358
    return ((adns_status )104);
  }
  {
#line 360
  tmp = adns__alloc_interim((adns_query )pai->qu, (size_t )((pai->qu)->vb.used + 1));
#line 360
  dm = (char *)tmp;
  }
#line 361
  if (! dm) {
#line 361
    return ((adns_status )1);
  }
  {
#line 363
  *(dm + (pai->qu)->vb.used) = (char)0;
#line 364
  memcpy((void */* __restrict  */)dm, (void const   */* __restrict  */)(pai->qu)->vb.buf,
         (size_t )(pai->qu)->vb.used);
#line 366
  *domain_r = dm;
  }
#line 367
  return ((adns_status )0);
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_domain___2(vbuf *vb___0 , char const   *domain ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 371
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 371
    tmp = adns__vbuf_appendstr(vb___0, domain);
    }
#line 371
    if (! tmp) {
#line 371
      return ((adns_status )1);
    }
#line 371
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 372
  if (! *domain) {
    {
#line 372
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 372
      tmp___0 = adns__vbuf_appendstr(vb___0, ".");
      }
#line 372
      if (! tmp___0) {
#line 372
        return ((adns_status )1);
      }
#line 372
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 373
  return ((adns_status )0);
}
}
#line 376 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_domain___2(vbuf *vb___0 , void const   *datap ) 
{ 
  char const   * const  *domainp ;
  adns_status tmp ;

  {
  {
#line 377
  domainp = (char const   * const  *)datap;
#line 378
  tmp = csp_domain___2(vb___0, (char const   *)*domainp);
  }
#line 378
  return (tmp);
}
}
#line 381 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_dom_raw___2(parseinfo const   *pai , int cbyte___3 , int max ,
                                  void *datap ) 
{ 
  char **rrp ;
  adns_status st ;

  {
  {
#line 383
  rrp = (char **)datap;
#line 386
  st = pap_domain___2(pai, & cbyte___3, max, rrp, (parsedomain_flags )1);
  }
#line 387
  if (st) {
#line 387
    return (st);
  }
#line 389
  if (cbyte___3 != max) {
#line 389
    return ((adns_status )104);
  }
#line 390
  return ((adns_status )0);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_host_raw___2(parseinfo const   *pai , int cbyte___3 , int max ,
                                   void *datap ) 
{ 
  char **rrp ;
  adns_status st ;
  int tmp ;

  {
#line 399
  rrp = (char **)datap;
#line 402
  if ((pai->qu)->flags & 64) {
#line 402
    tmp = 1;
  } else {
#line 402
    tmp = 0;
  }
  {
#line 402
  st = pap_domain___2(pai, & cbyte___3, max, rrp, (parsedomain_flags )tmp);
  }
#line 404
  if (st) {
#line 404
    return (st);
  }
#line 406
  if (cbyte___3 != max) {
#line 406
    return ((adns_status )104);
  }
#line 407
  return ((adns_status )0);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_findaddrs___2(parseinfo const   *pai , adns_rr_hostaddr *ha ,
                                     int *cbyte_io , int count , int dmstart ) 
{ 
  int rri ;
  int naddrs ;
  int type ;
  int class ;
  int rdlen ;
  int rdstart ;
  int ownermatched ;
  unsigned long ttl ;
  adns_status st ;
  int tmp ;
  void *tmp___0 ;

  {
#line 421
  rri = 0;
#line 421
  naddrs = -1;
  {
#line 421
  while (1) {
    while_continue: /* CIL Label */ ;
#line 421
    if (! (rri < count)) {
#line 421
      goto while_break;
    }
    {
#line 422
    st = adns__findrr_anychk((adns_query )pai->qu, (int )pai->serv, (byte const   *)pai->dgram,
                             (int )pai->dglen, cbyte_io, & type, & class, & ttl, & rdlen,
                             & rdstart, (byte const   *)pai->dgram, (int )pai->dglen,
                             dmstart, & ownermatched);
    }
#line 426
    if (st) {
#line 426
      return (st);
    }
#line 427
    if (! ownermatched) {
#line 427
      goto _L;
    } else
#line 427
    if (class != 1) {
#line 427
      goto _L;
    } else
#line 427
    if (type != 1) {
      _L: /* CIL Label */ 
#line 428
      if (naddrs > 0) {
#line 428
        goto while_break;
      } else {
#line 428
        goto __Cont;
      }
    }
#line 430
    if (naddrs == -1) {
#line 431
      naddrs = 0;
    }
    {
#line 433
    tmp = adns__vbuf_ensure(& (pai->qu)->vb, (int )((unsigned long )(naddrs + 1) * sizeof(adns_rr_addr )));
    }
#line 433
    if (! tmp) {
#line 434
      return ((adns_status )1);
    }
    {
#line 435
    adns__update_expires((adns_query )pai->qu, ttl, (struct timeval )pai->now);
#line 436
    st = pa_addr___2(pai, rdstart, rdstart + rdlen, (void *)((pai->qu)->vb.buf + (unsigned long )naddrs * sizeof(adns_rr_addr )));
    }
#line 438
    if (st) {
#line 438
      return (st);
    }
#line 439
    naddrs ++;
    __Cont: /* CIL Label */ 
#line 421
    rri ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 441
  if (naddrs >= 0) {
    {
#line 442
    tmp___0 = adns__alloc_interim((adns_query )pai->qu, (unsigned long )naddrs * sizeof(adns_rr_addr ));
#line 442
    ha->addrs = (adns_rr_addr *)tmp___0;
    }
#line 443
    if (! ha->addrs) {
#line 443
      return ((adns_status )1);
    }
    {
#line 444
    memcpy((void */* __restrict  */)ha->addrs, (void const   */* __restrict  */)(pai->qu)->vb.buf,
           (unsigned long )naddrs * sizeof(adns_rr_addr ));
#line 445
    ha->naddrs = naddrs;
#line 446
    ha->astatus = (adns_status )0;
#line 448
    adns__isort((void *)ha->addrs, naddrs, (int )sizeof(adns_rr_addr ), (void *)(pai->qu)->vb.buf,
                & div_addr___2, (void *)pai->ads);
    }
  }
#line 451
  return ((adns_status )0);
}
}
#line 454 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void icb_hostaddr___2(adns_query parent , adns_query child ) 
{ 
  adns_answer *cans ;
  adns_rr_hostaddr *rrp ;
  adns_state ads___7 ;
  adns_status st ;

  {
#line 455
  cans = child->answer;
#line 456
  rrp = child->ctx.info.hostaddr;
#line 457
  ads___7 = parent->ads;
#line 460
  st = cans->status;
#line 461
  rrp->astatus = st;
#line 462
  if ((unsigned int )st > 0U) {
#line 462
    if ((unsigned int )st <= 99U) {
#line 462
      rrp->naddrs = -1;
    } else {
#line 462
      rrp->naddrs = cans->nrrs;
    }
  } else {
#line 462
    rrp->naddrs = cans->nrrs;
  }
  {
#line 463
  rrp->addrs = cans->rrs.addr;
#line 464
  adns__transfer_interim(child, parent, (void *)rrp->addrs, (unsigned long )rrp->naddrs * sizeof(adns_rr_addr ));
  }
#line 467
  if (parent->children.head) {
    {
#line 468
    while (1) {
      while_continue: /* CIL Label */ ;
#line 468
      parent->next = (adns_query )0;
#line 468
      parent->back = ads___7->childw.tail;
#line 468
      if (ads___7->childw.tail) {
#line 468
        (ads___7->childw.tail)->next = parent;
      } else {
#line 468
        ads___7->childw.head = parent;
      }
#line 468
      ads___7->childw.tail = parent;
#line 468
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 470
    adns__query_done(parent);
    }
  }
#line 472
  return;
}
}
#line 474 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_hostaddr___2(parseinfo const   *pai , int *cbyte_io , int max ,
                                    adns_rr_hostaddr *rrp ) 
{ 
  adns_status st ;
  int dmstart ;
  int cbyte___3 ;
  qcontext ctx ;
  int id ;
  adns_query nqu ;
  adns_queryflags nflags ;
  int tmp ;
  typeinfo const   *tmp___0 ;

  {
#line 483
  cbyte___3 = *cbyte_io;
#line 483
  dmstart = cbyte___3;
#line 484
  if ((pai->qu)->flags & 64) {
#line 484
    tmp = 1;
  } else {
#line 484
    tmp = 0;
  }
  {
#line 484
  st = pap_domain___2(pai, & cbyte___3, max, & rrp->host, (parsedomain_flags )tmp);
  }
#line 486
  if (st) {
#line 486
    return (st);
  }
  {
#line 487
  *cbyte_io = cbyte___3;
#line 489
  rrp->astatus = (adns_status )0;
#line 490
  rrp->naddrs = -1;
#line 491
  rrp->addrs = (adns_rr_addr *)0;
#line 493
  cbyte___3 = (int )pai->nsstart;
#line 495
  st = pap_findaddrs___2(pai, rrp, & cbyte___3, (int )pai->nscount, dmstart);
  }
#line 496
  if (st) {
#line 496
    return (st);
  }
#line 497
  if (rrp->naddrs != -1) {
#line 497
    return ((adns_status )0);
  }
  {
#line 499
  st = pap_findaddrs___2(pai, rrp, & cbyte___3, (int )pai->arcount, dmstart);
  }
#line 500
  if (st) {
#line 500
    return (st);
  }
#line 501
  if (rrp->naddrs != -1) {
#line 501
    return ((adns_status )0);
  }
  {
#line 503
  st = adns__mkquery_frdgram((adns_state )pai->ads, & (pai->qu)->vb, & id, (byte const   *)pai->dgram,
                             (int )pai->dglen, dmstart, (adns_rrtype )65537, (adns_queryflags )16);
  }
#line 506
  if (st) {
#line 506
    return (st);
  }
#line 508
  ctx.ext = (void *)0;
#line 509
  ctx.callback = & icb_hostaddr___2;
#line 510
  ctx.info.hostaddr = rrp;
#line 512
  nflags = (adns_queryflags )16;
#line 513
  if (! ((pai->qu)->flags & 256)) {
#line 513
    nflags = (adns_queryflags )((unsigned int )nflags | 512U);
  }
  {
#line 515
  tmp___0 = adns__findtype((adns_rrtype )65537);
#line 515
  st = adns__internal_submit((adns_state )pai->ads, & nqu, tmp___0, & (pai->qu)->vb,
                             id, nflags, (struct timeval )pai->now, (qcontext const   *)(& ctx));
  }
#line 517
  if (st) {
#line 517
    return (st);
  }
#line 519
  nqu->parent = (adns_query )pai->qu;
  {
#line 520
  while (1) {
    while_continue: /* CIL Label */ ;
#line 520
    nqu->siblings.next = (adns_query )0;
#line 520
    nqu->siblings.back = (pai->qu)->children.tail;
#line 520
    if ((pai->qu)->children.tail) {
#line 520
      ((pai->qu)->children.tail)->siblings.next = nqu;
    } else {
#line 520
      (pai->qu)->children.head = nqu;
    }
#line 520
    (pai->qu)->children.tail = nqu;
#line 520
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 522
  return ((adns_status )0);
}
}
#line 525 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_hostaddr___2(parseinfo const   *pai , int cbyte___3 , int max ,
                                   void *datap ) 
{ 
  adns_rr_hostaddr *rrp ;
  adns_status st ;

  {
  {
#line 527
  rrp = (adns_rr_hostaddr *)datap;
#line 530
  st = pap_hostaddr___2(pai, & cbyte___3, max, rrp);
  }
#line 531
  if (st) {
#line 531
    return (st);
  }
#line 532
  if (cbyte___3 != max) {
#line 532
    return ((adns_status )104);
  }
#line 534
  return ((adns_status )0);
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int dip_hostaddr___2(adns_state ads___7 , adns_rr_hostaddr const   *ap , adns_rr_hostaddr const   *bp ) 
{ 
  int tmp ;

  {
#line 539
  if ((unsigned int const   )ap->astatus != (unsigned int const   )bp->astatus) {
#line 539
    return ((int )ap->astatus);
  }
#line 540
  if (ap->astatus) {
#line 540
    return (0);
  }
#line 542
  if (! ((int )(ap->addrs + 0)->addr.sa.sa_family == 2)) {
    {
#line 542
    __assert_fail("ap->addrs[0].addr.sa.sa_family == 2", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  542U, "dip_hostaddr");
    }
  }
#line 543
  if (! ((int )(bp->addrs + 0)->addr.sa.sa_family == 2)) {
    {
#line 543
    __assert_fail("bp->addrs[0].addr.sa.sa_family == 2", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  543U, "dip_hostaddr");
    }
  }
  {
#line 544
  tmp = dip_inaddr___2(ads___7, (ap->addrs + 0)->addr.inet.sin_addr, (bp->addrs + 0)->addr.inet.sin_addr);
  }
#line 544
  return (tmp);
}
}
#line 549 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_hostaddr___2(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_hostaddr const   *ap ;
  adns_rr_hostaddr const   *bp ;
  int tmp ;

  {
  {
#line 551
  ap = (adns_rr_hostaddr const   *)datap_a;
#line 551
  bp = (adns_rr_hostaddr const   *)datap_b;
#line 553
  tmp = dip_hostaddr___2(ads___7, ap, bp);
  }
#line 553
  return (tmp);
}
}
#line 556 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mfp_hostaddr___2(adns_query qu , adns_rr_hostaddr *rrp ) 
{ 
  void *tablev ;

  {
  {
#line 559
  adns__makefinal_str(qu, & rrp->host);
#line 560
  tablev = (void *)rrp->addrs;
#line 561
  adns__makefinal_block(qu, & tablev, (unsigned long )rrp->naddrs * sizeof(*(rrp->addrs)));
#line 562
  rrp->addrs = (adns_rr_addr *)tablev;
  }
#line 563
  return;
}
}
#line 565 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_hostaddr___2(adns_query qu , void *datap ) 
{ 
  adns_rr_hostaddr *rrp ;

  {
  {
#line 566
  rrp = (adns_rr_hostaddr *)datap;
#line 568
  mfp_hostaddr___2(qu, rrp);
  }
#line 569
  return;
}
}
#line 571 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_hostaddr___2(vbuf *vb___0 , adns_rr_hostaddr const   *rrp ) 
{ 
  char const   *errstr ;
  adns_status st ;
  char buf___17[20] ;
  int i ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 577
  st = csp_domain___2(vb___0, (char const   *)rrp->host);
  }
#line 577
  if (st) {
#line 577
    return (st);
  }
  {
#line 579
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 579
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 579
    if (! tmp) {
#line 579
      return ((adns_status )1);
    }
#line 579
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 580
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 580
    tmp___0 = adns_errtypeabbrev((adns_status )rrp->astatus);
#line 580
    tmp___1 = adns__vbuf_appendstr(vb___0, tmp___0);
    }
#line 580
    if (! tmp___1) {
#line 580
      return ((adns_status )1);
    }
#line 580
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 582
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %d ",
          (unsigned int const   )rrp->astatus);
  }
  {
#line 583
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 583
    tmp___2 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 583
    if (! tmp___2) {
#line 583
      return ((adns_status )1);
    }
#line 583
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 585
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 585
    tmp___3 = adns_errabbrev((adns_status )rrp->astatus);
#line 585
    tmp___4 = adns__vbuf_appendstr(vb___0, tmp___3);
    }
#line 585
    if (! tmp___4) {
#line 585
      return ((adns_status )1);
    }
#line 585
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 586
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 586
    tmp___5 = adns__vbuf_appendstr(vb___0, " ");
    }
#line 586
    if (! tmp___5) {
#line 586
      return ((adns_status )1);
    }
#line 586
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 588
  errstr = adns_strerror((adns_status )rrp->astatus);
#line 589
  tmp___6 = strlen(errstr);
#line 589
  st = csp_qstring___2(vb___0, errstr, (int )tmp___6);
  }
#line 589
  if (st) {
#line 589
    return (st);
  }
#line 591
  if (rrp->naddrs >= 0) {
    {
#line 592
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 592
      tmp___7 = adns__vbuf_appendstr(vb___0, " (");
      }
#line 592
      if (! tmp___7) {
#line 592
        return ((adns_status )1);
      }
#line 592
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 593
    i = 0;
    {
#line 593
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 593
      if (! (i < (int )rrp->naddrs)) {
#line 593
        goto while_break___5;
      }
      {
#line 594
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 594
        tmp___8 = adns__vbuf_appendstr(vb___0, " ");
        }
#line 594
        if (! tmp___8) {
#line 594
          return ((adns_status )1);
        }
#line 594
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 595
      st = csp_addr___2(vb___0, (adns_rr_addr const   *)(rrp->addrs + i));
#line 593
      i ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 597
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 597
      tmp___9 = adns__vbuf_appendstr(vb___0, " )");
      }
#line 597
      if (! tmp___9) {
#line 597
        return ((adns_status )1);
      }
#line 597
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
  } else {
    {
#line 599
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 599
      tmp___10 = adns__vbuf_appendstr(vb___0, " ?");
      }
#line 599
      if (! tmp___10) {
#line 599
        return ((adns_status )1);
      }
#line 599
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
#line 601
  return ((adns_status )0);
}
}
#line 604 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_hostaddr___2(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_hostaddr const   *rrp ;
  adns_status tmp ;

  {
  {
#line 605
  rrp = (adns_rr_hostaddr const   *)datap;
#line 607
  tmp = csp_hostaddr___2(vb___0, rrp);
  }
#line 607
  return (tmp);
}
}
#line 614 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_mx_raw___2(parseinfo const   *pai , int cbyte___3 , int max ,
                                 void *datap ) 
{ 
  byte const   *dgram ;
  adns_rr_intstr *rrp ;
  adns_status st ;
  int pref ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 616
  dgram = (byte const   *)pai->dgram;
#line 617
  rrp = (adns_rr_intstr *)datap;
#line 621
  if (cbyte___3 + 2 > max) {
#line 621
    return ((adns_status )104);
  }
#line 622
  pref = 0;
#line 622
  tmp = cbyte___3;
#line 622
  cbyte___3 ++;
#line 622
  pref |= (int )(((int const   )*(dgram + tmp) & 255) << 8);
#line 622
  tmp___0 = cbyte___3;
#line 622
  cbyte___3 ++;
#line 622
  pref |= (int )((int const   )*(dgram + tmp___0) & 255);
#line 623
  rrp->i = pref;
#line 624
  if ((pai->qu)->flags & 64) {
#line 624
    tmp___1 = 1;
  } else {
#line 624
    tmp___1 = 0;
  }
  {
#line 624
  st = pap_domain___2(pai, & cbyte___3, max, & rrp->str, (parsedomain_flags )tmp___1);
  }
#line 626
  if (st) {
#line 626
    return (st);
  }
#line 628
  if (cbyte___3 != max) {
#line 628
    return ((adns_status )104);
  }
#line 629
  return ((adns_status )0);
}
}
#line 632 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_mx_raw___2(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_intstr const   *ap ;
  adns_rr_intstr const   *bp ;

  {
#line 633
  ap = (adns_rr_intstr const   *)datap_a;
#line 633
  bp = (adns_rr_intstr const   *)datap_b;
#line 635
  if (ap->i < bp->i) {
#line 635
    return (0);
  }
#line 636
  if (ap->i > bp->i) {
#line 636
    return (1);
  }
#line 637
  return (0);
}
}
#line 644 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_mx___2(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  byte const   *dgram ;
  adns_rr_inthostaddr *rrp ;
  adns_status st ;
  int pref ;
  int tmp ;
  int tmp___0 ;

  {
#line 646
  dgram = (byte const   *)pai->dgram;
#line 647
  rrp = (adns_rr_inthostaddr *)datap;
#line 651
  if (cbyte___3 + 2 > max) {
#line 651
    return ((adns_status )104);
  }
  {
#line 652
  pref = 0;
#line 652
  tmp = cbyte___3;
#line 652
  cbyte___3 ++;
#line 652
  pref |= (int )(((int const   )*(dgram + tmp) & 255) << 8);
#line 652
  tmp___0 = cbyte___3;
#line 652
  cbyte___3 ++;
#line 652
  pref |= (int )((int const   )*(dgram + tmp___0) & 255);
#line 653
  rrp->i = pref;
#line 654
  st = pap_hostaddr___2(pai, & cbyte___3, max, & rrp->ha);
  }
#line 655
  if (st) {
#line 655
    return (st);
  }
#line 657
  if (cbyte___3 != max) {
#line 657
    return ((adns_status )104);
  }
#line 658
  return ((adns_status )0);
}
}
#line 661 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_mx___2(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_inthostaddr const   *ap ;
  adns_rr_inthostaddr const   *bp ;
  int tmp ;

  {
#line 662
  ap = (adns_rr_inthostaddr const   *)datap_a;
#line 662
  bp = (adns_rr_inthostaddr const   *)datap_b;
#line 664
  if (ap->i < bp->i) {
#line 664
    return (0);
  }
#line 665
  if (ap->i > bp->i) {
#line 665
    return (1);
  }
  {
#line 666
  tmp = dip_hostaddr___2(ads___7, & ap->ha, & bp->ha);
  }
#line 666
  return (tmp);
}
}
#line 673 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_inthostaddr___2(adns_query qu , void *datap ) 
{ 
  adns_rr_inthostaddr *rrp ;

  {
  {
#line 674
  rrp = (adns_rr_inthostaddr *)datap;
#line 676
  mfp_hostaddr___2(qu, & rrp->ha);
  }
#line 677
  return;
}
}
#line 679 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_inthostaddr___2(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_inthostaddr const   *rrp ;
  char buf___17[10] ;
  int tmp ;
  adns_status tmp___0 ;

  {
  {
#line 680
  rrp = (adns_rr_inthostaddr const   *)datap;
#line 683
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"%u ",
          rrp->i);
  }
  {
#line 684
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 684
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 684
    if (! tmp) {
#line 684
      return ((adns_status )1);
    }
#line 684
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 686
  tmp___0 = csp_hostaddr___2(vb___0, & rrp->ha);
  }
#line 686
  return (tmp___0);
}
}
#line 693 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_inthost___2(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_intstr const   *rrp ;
  char buf___17[10] ;
  int tmp ;
  adns_status tmp___0 ;

  {
  {
#line 694
  rrp = (adns_rr_intstr const   *)datap;
#line 697
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"%u ",
          rrp->i);
  }
  {
#line 698
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 698
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 698
    if (! tmp) {
#line 698
      return ((adns_status )1);
    }
#line 698
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 699
  tmp___0 = csp_domain___2(vb___0, (char const   *)rrp->str);
  }
#line 699
  return (tmp___0);
}
}
#line 706 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void icb_ptr___2(adns_query parent , adns_query child ) 
{ 
  adns_answer *cans ;
  adns_rr_addr const   *queried ;
  adns_rr_addr const   *found ;
  adns_state ads___7 ;
  int i ;
  int tmp ;

  {
#line 707
  cans = child->answer;
#line 709
  ads___7 = parent->ads;
#line 712
  if ((unsigned int )cans->status == 300U) {
    {
#line 713
    adns__query_fail(parent, (adns_status )100);
    }
#line 714
    return;
  } else
#line 712
  if ((unsigned int )cans->status == 301U) {
    {
#line 713
    adns__query_fail(parent, (adns_status )100);
    }
#line 714
    return;
  } else
#line 715
  if (cans->status) {
    {
#line 716
    adns__query_fail(parent, cans->status);
    }
#line 717
    return;
  }
#line 720
  queried = (adns_rr_addr const   *)(& parent->ctx.info.ptr_parent_addr);
#line 721
  i = 0;
#line 721
  found = (adns_rr_addr const   *)cans->rrs.addr;
  {
#line 721
  while (1) {
    while_continue: /* CIL Label */ ;
#line 721
    if (! (i < cans->nrrs)) {
#line 721
      goto while_break;
    }
#line 722
    if (queried->len == found->len) {
      {
#line 722
      tmp = memcmp((void const   *)(& queried->addr), (void const   *)(& found->addr),
                   (size_t )queried->len);
      }
#line 722
      if (! tmp) {
#line 724
        if (! parent->children.head) {
          {
#line 725
          adns__query_done(parent);
          }
#line 726
          return;
        } else {
          {
#line 728
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 728
            parent->next = (adns_query )0;
#line 728
            parent->back = ads___7->childw.tail;
#line 728
            if (ads___7->childw.tail) {
#line 728
              (ads___7->childw.tail)->next = parent;
            } else {
#line 728
              ads___7->childw.head = parent;
            }
#line 728
            ads___7->childw.tail = parent;
#line 728
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 729
          return;
        }
      }
    }
#line 721
    i ++;
#line 721
    found ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 734
  adns__query_fail(parent, (adns_status )100);
  }
#line 735
  return;
}
}
#line 739
static adns_status pa_ptr___2(parseinfo const   *pai , int dmstart , int max , void *datap ) ;
#line 739 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static char const   * const  expectdomain___2[2]  = {      (char const   */* const  */)"in-addr",      (char const   */* const  */)"arpa"};
#line 737 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_ptr___2(parseinfo const   *pai , int dmstart , int max , void *datap ) 
{ 
  char **rrp ;
  adns_status st ;
  adns_rr_addr *ap ;
  findlabel_state fls ;
  char *ep ;
  byte ipv[4] ;
  char labbuf[4] ;
  int cbyte___3 ;
  int i ;
  int lablen ;
  int labstart ;
  int l ;
  int id ;
  adns_query nqu ;
  qcontext ctx ;
  int tmp ;
  unsigned long tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  typeinfo const   *tmp___3 ;

  {
#line 741
  rrp = (char **)datap;
#line 752
  cbyte___3 = dmstart;
#line 753
  if ((pai->qu)->flags & 64) {
#line 753
    tmp = 1;
  } else {
#line 753
    tmp = 0;
  }
  {
#line 753
  st = pap_domain___2(pai, & cbyte___3, max, rrp, (parsedomain_flags )tmp);
  }
#line 755
  if (st) {
#line 755
    return (st);
  }
#line 756
  if (cbyte___3 != max) {
#line 756
    return ((adns_status )104);
  }
#line 758
  ap = & (pai->qu)->ctx.info.ptr_parent_addr;
#line 759
  if (! ap->len) {
    {
#line 760
    adns__findlabel_start(& fls, (adns_state )pai->ads, -1, (adns_query )pai->qu,
                          (byte const   *)(pai->qu)->query_dgram, (pai->qu)->query_dglen,
                          (pai->qu)->query_dglen, 12, (int *)0);
#line 763
    i = 0;
    }
    {
#line 763
    while (1) {
      while_continue: /* CIL Label */ ;
#line 763
      if (! (i < 4)) {
#line 763
        goto while_break;
      }
      {
#line 764
      st = adns__findlabel_next(& fls, & lablen, & labstart);
      }
#line 764
      if (! (! st)) {
        {
#line 764
        __assert_fail("!st", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                      764U, "pa_ptr");
        }
      }
#line 765
      if (lablen <= 0) {
#line 765
        return ((adns_status )200);
      } else
#line 765
      if (lablen > 3) {
#line 765
        return ((adns_status )200);
      }
      {
#line 766
      memcpy((void */* __restrict  */)(labbuf), (void const   */* __restrict  */)((pai->qu)->query_dgram + labstart),
             (size_t )lablen);
#line 767
      labbuf[lablen] = (char)0;
#line 768
      tmp___0 = strtoul((char const   */* __restrict  */)(labbuf), (char **/* __restrict  */)(& ep),
                        10);
#line 768
      ipv[3 - i] = (byte )tmp___0;
      }
#line 769
      if (*ep) {
#line 769
        return ((adns_status )200);
      }
#line 770
      if (lablen > 1) {
#line 770
        if ((int )*((pai->qu)->query_dgram + labstart) == 48) {
#line 771
          return ((adns_status )200);
        }
      }
#line 763
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 773
    i = 0;
    {
#line 773
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 773
      if (! ((unsigned long )i < sizeof(expectdomain___2) / sizeof(expectdomain___2[0]))) {
#line 773
        goto while_break___0;
      }
      {
#line 774
      st = adns__findlabel_next(& fls, & lablen, & labstart);
      }
#line 774
      if (! (! st)) {
        {
#line 774
        __assert_fail("!st", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                      774U, "pa_ptr");
        }
      }
      {
#line 775
      tmp___1 = strlen((char const   *)expectdomain___2[i]);
#line 775
      l = (int )tmp___1;
      }
#line 776
      if (lablen != l) {
#line 778
        return ((adns_status )200);
      } else {
        {
#line 776
        tmp___2 = memcmp((void const   *)((pai->qu)->query_dgram + labstart), (void const   *)expectdomain___2[i],
                         (size_t )l);
        }
#line 776
        if (tmp___2) {
#line 778
          return ((adns_status )200);
        }
      }
#line 773
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 780
    st = adns__findlabel_next(& fls, & lablen, (int *)0);
    }
#line 780
    if (! (! st)) {
      {
#line 780
      __assert_fail("!st", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                    780U, "pa_ptr");
      }
    }
#line 781
    if (lablen) {
#line 781
      return ((adns_status )200);
    }
    {
#line 783
    ap->len = (int )sizeof(struct sockaddr_in );
#line 784
    memset((void *)(& ap->addr), 0, sizeof(ap->addr.inet));
#line 785
    ap->addr.inet.sin_family = (sa_family_t )2;
#line 786
    ap->addr.inet.sin_addr.s_addr = htonl((uint32_t )(((((int )ipv[0] << 24) | ((int )ipv[1] << 16)) | ((int )ipv[2] << 8)) | (int )ipv[3]));
    }
  }
  {
#line 790
  st = adns__mkquery_frdgram((adns_state )pai->ads, & (pai->qu)->vb, & id, (byte const   *)pai->dgram,
                             (int )pai->dglen, dmstart, (adns_rrtype )65537, (adns_queryflags )16);
  }
#line 793
  if (st) {
#line 793
    return (st);
  }
  {
#line 795
  ctx.ext = (void *)0;
#line 796
  ctx.callback = & icb_ptr___2;
#line 797
  memset((void *)(& ctx.info), 0, sizeof(ctx.info));
#line 798
  tmp___3 = adns__findtype((adns_rrtype )65537);
#line 798
  st = adns__internal_submit((adns_state )pai->ads, & nqu, tmp___3, & (pai->qu)->vb,
                             id, (adns_queryflags )16, (struct timeval )pai->now,
                             (qcontext const   *)(& ctx));
  }
#line 801
  if (st) {
#line 801
    return (st);
  }
#line 803
  nqu->parent = (adns_query )pai->qu;
  {
#line 804
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 804
    nqu->siblings.next = (adns_query )0;
#line 804
    nqu->siblings.back = (pai->qu)->children.tail;
#line 804
    if ((pai->qu)->children.tail) {
#line 804
      ((pai->qu)->children.tail)->siblings.next = nqu;
    } else {
#line 804
      (pai->qu)->children.head = nqu;
    }
#line 804
    (pai->qu)->children.tail = nqu;
#line 804
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 805
  return ((adns_status )0);
}
}
#line 812 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_strpair___2(adns_query qu , void *datap ) 
{ 
  adns_rr_strpair *rrp ;

  {
  {
#line 813
  rrp = (adns_rr_strpair *)datap;
#line 815
  adns__makefinal_str(qu, & rrp->array[0]);
#line 816
  adns__makefinal_str(qu, & rrp->array[1]);
  }
#line 817
  return;
}
}
#line 823 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_intstrpair___2(adns_query qu , void *datap ) 
{ 
  adns_rr_intstrpair *rrp ;

  {
  {
#line 824
  rrp = (adns_rr_intstrpair *)datap;
#line 826
  adns__makefinal_str(qu, & rrp->array[0].str);
#line 827
  adns__makefinal_str(qu, & rrp->array[1].str);
  }
#line 828
  return;
}
}
#line 834 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_hinfo___2(parseinfo const   *pai , int cbyte___3 , int max ,
                                void *datap ) 
{ 
  adns_rr_intstrpair *rrp ;
  adns_status st ;
  int i ;

  {
#line 836
  rrp = (adns_rr_intstrpair *)datap;
#line 840
  i = 0;
  {
#line 840
  while (1) {
    while_continue: /* CIL Label */ ;
#line 840
    if (! (i < 2)) {
#line 840
      goto while_break;
    }
    {
#line 841
    st = pap_qstring___2(pai, & cbyte___3, max, & rrp->array[i].i, & rrp->array[i].str);
    }
#line 842
    if (st) {
#line 842
      return (st);
    }
#line 840
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 845
  if (cbyte___3 != max) {
#line 845
    return ((adns_status )104);
  }
#line 847
  return ((adns_status )0);
}
}
#line 854 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_mailbox822___2(parseinfo const   *pai , int *cbyte_io , int max ,
                                      char **mb_r ) 
{ 
  int lablen ;
  int labstart ;
  int i ;
  int needquote ;
  int c ;
  int r ;
  int neednorm ;
  unsigned char const   *p ;
  char *str ;
  findlabel_state fls ;
  adns_status st ;
  vbuf *vb___0 ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 863
  vb___0 = & (pai->qu)->vb;
#line 864
  vb___0->used = 0;
#line 865
  adns__findlabel_start(& fls, (adns_state )pai->ads, -1, (adns_query )pai->qu, (byte const   *)pai->dgram,
                        (int )pai->dglen, max, *cbyte_io, cbyte_io);
#line 869
  st = adns__findlabel_next(& fls, & lablen, & labstart);
  }
#line 870
  if (! lablen) {
    {
#line 871
    adns__vbuf_appendstr(vb___0, ".");
    }
#line 872
    goto x_ok;
  }
#line 875
  neednorm = 1;
#line 876
  i = 0;
#line 876
  needquote = 0;
#line 876
  p = (unsigned char const   *)(pai->dgram + labstart);
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (! (i < lablen)) {
#line 876
      goto while_break;
    }
#line 877
    tmp = p;
#line 877
    p ++;
#line 877
    c = (int )*tmp;
#line 878
    if ((c & -129) < 32) {
#line 878
      return ((adns_status )104);
    } else
#line 878
    if ((c & -129) == 127) {
#line 878
      return ((adns_status )104);
    }
#line 879
    if (c == 46) {
#line 879
      if (! neednorm) {
#line 879
        neednorm = 1;
      } else {
#line 879
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 880
    if (c == 32) {
#line 880
      needquote ++;
    } else
#line 880
    if (c >= 127) {
#line 880
      needquote ++;
    } else {
      {
#line 880
      tmp___0 = ctype_822special(c);
      }
#line 880
      if (tmp___0) {
#line 880
        needquote ++;
      } else {
#line 881
        neednorm = 0;
      }
    }
#line 876
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 884
  if (needquote) {
#line 884
    goto _L___0;
  } else
#line 884
  if (neednorm) {
    _L___0: /* CIL Label */ 
    {
#line 885
    r = adns__vbuf_ensure(vb___0, (lablen + needquote) + 4);
    }
#line 885
    if (! r) {
#line 885
      return ((adns_status )1);
    }
    {
#line 886
    adns__vbuf_appendq(vb___0, (byte const   *)"\"", 1);
#line 887
    i = 0;
#line 887
    needquote = 0;
#line 887
    p = (unsigned char const   *)(pai->dgram + labstart);
    }
    {
#line 887
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 887
      if (! (i < lablen)) {
#line 887
        goto while_break___0;
      }
#line 888
      c = (int )*p;
#line 889
      if (c == 34) {
        {
#line 889
        adns__vbuf_appendq(vb___0, (byte const   *)"\\", 1);
        }
      } else
#line 889
      if (c == 92) {
        {
#line 889
        adns__vbuf_appendq(vb___0, (byte const   *)"\\", 1);
        }
      }
      {
#line 890
      adns__vbuf_appendq(vb___0, p, 1);
#line 887
      i ++;
#line 887
      p ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 892
    adns__vbuf_appendq(vb___0, (byte const   *)"\"", 1);
    }
  } else {
    {
#line 894
    r = adns__vbuf_append(vb___0, (byte const   *)(pai->dgram + labstart), lablen);
    }
#line 894
    if (! r) {
#line 894
      return ((adns_status )1);
    }
  }
  {
#line 897
  r = adns__vbuf_appendstr(vb___0, "@");
  }
#line 897
  if (! r) {
#line 897
    return ((adns_status )1);
  }
  {
#line 899
  st = adns__parse_domain_more(& fls, (adns_state )pai->ads, (adns_query )pai->qu,
                               vb___0, (parsedomain_flags )0, (byte const   *)pai->dgram);
  }
#line 900
  if (st) {
#line 900
    return (st);
  }
  x_ok: 
  {
#line 903
  tmp___1 = adns__alloc_interim((adns_query )pai->qu, (size_t )(vb___0->used + 1));
#line 903
  str = (char *)tmp___1;
  }
#line 903
  if (! str) {
#line 903
    return ((adns_status )1);
  }
  {
#line 904
  memcpy((void */* __restrict  */)str, (void const   */* __restrict  */)vb___0->buf,
         (size_t )vb___0->used);
#line 905
  *(str + vb___0->used) = (char)0;
#line 906
  *mb_r = str;
  }
#line 907
  return ((adns_status )0);
}
}
#line 910 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_mailbox___2(parseinfo const   *pai , int *cbyte_io , int max ,
                                   char **mb_r ) 
{ 
  adns_status tmp ;
  adns_status tmp___0 ;

  {
#line 912
  if ((unsigned int const   )((pai->qu)->typei)->typekey & 131072U) {
    {
#line 913
    tmp = pap_mailbox822___2(pai, cbyte_io, max, mb_r);
    }
#line 913
    return (tmp);
  } else {
    {
#line 915
    tmp___0 = pap_domain___2(pai, cbyte_io, max, mb_r, (parsedomain_flags )1);
    }
#line 915
    return (tmp___0);
  }
}
}
#line 919 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_mailbox___2(vbuf *vb___0 , char const   *mailbox ) 
{ 
  adns_status tmp ;

  {
  {
#line 920
  tmp = csp_domain___2(vb___0, mailbox);
  }
#line 920
  return (tmp);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_rp___2(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  adns_rr_strpair *rrp ;
  adns_status st ;

  {
  {
#line 929
  rrp = (adns_rr_strpair *)datap;
#line 932
  st = pap_mailbox___2(pai, & cbyte___3, max, & rrp->array[0]);
  }
#line 933
  if (st) {
#line 933
    return (st);
  }
  {
#line 935
  st = pap_domain___2(pai, & cbyte___3, max, & rrp->array[1], (parsedomain_flags )1);
  }
#line 936
  if (st) {
#line 936
    return (st);
  }
#line 938
  if (cbyte___3 != max) {
#line 938
    return ((adns_status )104);
  }
#line 939
  return ((adns_status )0);
}
}
#line 942 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_rp___2(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_strpair const   *rrp ;
  adns_status st ;
  int tmp ;

  {
  {
#line 943
  rrp = (adns_rr_strpair const   *)datap;
#line 946
  st = csp_mailbox___2(vb___0, (char const   *)rrp->array[0]);
  }
#line 946
  if (st) {
#line 946
    return (st);
  }
  {
#line 947
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 947
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 947
    if (! tmp) {
#line 947
      return ((adns_status )1);
    }
#line 947
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 948
  st = csp_domain___2(vb___0, (char const   *)rrp->array[1]);
  }
#line 948
  if (st) {
#line 948
    return (st);
  }
#line 950
  return ((adns_status )0);
}
}
#line 957 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_soa___2(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  adns_rr_soa *rrp ;
  byte const   *dgram ;
  adns_status st ;
  int msw ;
  int lsw ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 959
  rrp = (adns_rr_soa *)datap;
#line 960
  dgram = (byte const   *)pai->dgram;
#line 964
  if ((pai->qu)->flags & 64) {
#line 964
    tmp = 1;
  } else {
#line 964
    tmp = 0;
  }
  {
#line 964
  st = pap_domain___2(pai, & cbyte___3, max, & rrp->mname, (parsedomain_flags )tmp);
  }
#line 966
  if (st) {
#line 966
    return (st);
  }
  {
#line 968
  st = pap_mailbox___2(pai, & cbyte___3, max, & rrp->rname);
  }
#line 969
  if (st) {
#line 969
    return (st);
  }
#line 971
  if (cbyte___3 + 20 != max) {
#line 971
    return ((adns_status )104);
  }
#line 973
  i = 0;
  {
#line 973
  while (1) {
    while_continue: /* CIL Label */ ;
#line 973
    if (! (i < 5)) {
#line 973
      goto while_break;
    }
#line 974
    msw = 0;
#line 974
    tmp___0 = cbyte___3;
#line 974
    cbyte___3 ++;
#line 974
    msw |= (int )(((int const   )*(dgram + tmp___0) & 255) << 8);
#line 974
    tmp___1 = cbyte___3;
#line 974
    cbyte___3 ++;
#line 974
    msw |= (int )((int const   )*(dgram + tmp___1) & 255);
#line 975
    lsw = 0;
#line 975
    tmp___2 = cbyte___3;
#line 975
    cbyte___3 ++;
#line 975
    lsw |= (int )(((int const   )*(dgram + tmp___2) & 255) << 8);
#line 975
    tmp___3 = cbyte___3;
#line 975
    cbyte___3 ++;
#line 975
    lsw |= (int )((int const   )*(dgram + tmp___3) & 255);
#line 976
    *(& rrp->serial + i) = (unsigned long )((msw << 16) | lsw);
#line 973
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 979
  return ((adns_status )0);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_soa___2(adns_query qu , void *datap ) 
{ 
  adns_rr_soa *rrp ;

  {
  {
#line 983
  rrp = (adns_rr_soa *)datap;
#line 985
  adns__makefinal_str(qu, & rrp->mname);
#line 986
  adns__makefinal_str(qu, & rrp->rname);
  }
#line 987
  return;
}
}
#line 989 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_soa___2(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_soa const   *rrp ;
  char buf___17[20] ;
  int i ;
  adns_status st ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 990
  rrp = (adns_rr_soa const   *)datap;
#line 995
  st = csp_domain___2(vb___0, (char const   *)rrp->mname);
  }
#line 995
  if (st) {
#line 995
    return (st);
  }
  {
#line 996
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 996
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 996
    if (! tmp) {
#line 996
      return ((adns_status )1);
    }
#line 996
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 997
  st = csp_mailbox___2(vb___0, (char const   *)rrp->rname);
  }
#line 997
  if (st) {
#line 997
    return (st);
  }
#line 999
  i = 0;
  {
#line 999
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 999
    if (! (i < 5)) {
#line 999
      goto while_break___0;
    }
    {
#line 1000
    sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %lu",
            *(& rrp->serial + i));
    }
    {
#line 1001
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1001
      tmp___0 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
      }
#line 1001
      if (! tmp___0) {
#line 1001
        return ((adns_status )1);
      }
#line 1001
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 999
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1004
  return ((adns_status )0);
}
}
#line 1011 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status qdpl_srv___2(adns_state ads___7 , char const   **p_io , char const   *pe ,
                                int labelnum , char *label_r , int *ll_io , adns_queryflags flags ,
                                typeinfo const   *typei ) 
{ 
  int useflags ;
  char const   *p_orig ;
  adns_status st ;
  int ll ;
  void *tmp ;

  {
#line 1020
  if (labelnum < 2) {
#line 1020
    if (! ((unsigned int )flags & 16U)) {
#line 1021
      useflags = 16;
#line 1022
      p_orig = *p_io;
    } else {
#line 1024
      useflags = (int )flags;
#line 1025
      p_orig = (char const   *)0;
    }
  } else {
#line 1024
    useflags = (int )flags;
#line 1025
    p_orig = (char const   *)0;
  }
  {
#line 1027
  st = adns__qdpl_normal(ads___7, p_io, pe, labelnum, (char *)label_r, ll_io, (adns_queryflags )useflags,
                         typei);
  }
#line 1028
  if (st) {
#line 1028
    return (st);
  }
#line 1030
  if (p_orig) {
#line 1031
    ll = *ll_io;
#line 1032
    if (! ll) {
#line 1033
      return ((adns_status )201);
    } else
#line 1032
    if ((int )*(label_r + 0) != 95) {
#line 1033
      return ((adns_status )201);
    }
    {
#line 1034
    tmp = memchr((void const   *)(p_orig + 1), '\\', (size_t )(pe - (p_orig + 1)));
    }
#line 1034
    if (tmp) {
#line 1035
      return ((adns_status )201);
    }
  }
#line 1037
  return ((adns_status )0);
}
}
#line 1040 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_srv_begin___2(parseinfo const   *pai , int *cbyte_io , int max ,
                                     adns_rr_srvha *rrp ) 
{ 
  byte const   *dgram ;
  int ti ;
  int cbyte___3 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1043
  dgram = (byte const   *)pai->dgram;
#line 1046
  cbyte___3 = *cbyte_io;
#line 1047
  tmp = *cbyte_io + 6;
#line 1047
  *cbyte_io = tmp;
#line 1047
  if (tmp > max) {
#line 1047
    return ((adns_status )104);
  }
#line 1049
  ti = 0;
#line 1049
  tmp___0 = cbyte___3;
#line 1049
  cbyte___3 ++;
#line 1049
  ti |= (int )(((int const   )*(dgram + tmp___0) & 255) << 8);
#line 1049
  tmp___1 = cbyte___3;
#line 1049
  cbyte___3 ++;
#line 1049
  ti |= (int )((int const   )*(dgram + tmp___1) & 255);
#line 1049
  rrp->priority = ti;
#line 1050
  ti = 0;
#line 1050
  tmp___2 = cbyte___3;
#line 1050
  cbyte___3 ++;
#line 1050
  ti |= (int )(((int const   )*(dgram + tmp___2) & 255) << 8);
#line 1050
  tmp___3 = cbyte___3;
#line 1050
  cbyte___3 ++;
#line 1050
  ti |= (int )((int const   )*(dgram + tmp___3) & 255);
#line 1050
  rrp->weight = ti;
#line 1051
  ti = 0;
#line 1051
  tmp___4 = cbyte___3;
#line 1051
  cbyte___3 ++;
#line 1051
  ti |= (int )(((int const   )*(dgram + tmp___4) & 255) << 8);
#line 1051
  tmp___5 = cbyte___3;
#line 1051
  cbyte___3 ++;
#line 1051
  ti |= (int )((int const   )*(dgram + tmp___5) & 255);
#line 1051
  rrp->port = ti;
#line 1052
  return ((adns_status )0);
}
}
#line 1055 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_srvraw___2(parseinfo const   *pai , int cbyte___3 , int max ,
                                 void *datap ) 
{ 
  adns_rr_srvraw *rrp ;
  adns_status st ;
  int tmp ;

  {
  {
#line 1057
  rrp = (adns_rr_srvraw *)datap;
#line 1060
  st = pap_srv_begin___2(pai, & cbyte___3, max, (adns_rr_srvha *)datap);
  }
#line 1061
  if (st) {
#line 1061
    return (st);
  }
#line 1063
  if ((pai->qu)->flags & 64) {
#line 1063
    tmp = 1;
  } else {
#line 1063
    tmp = 0;
  }
  {
#line 1063
  st = pap_domain___2(pai, & cbyte___3, max, & rrp->host, (parsedomain_flags )tmp);
  }
#line 1065
  if (st) {
#line 1065
    return (st);
  }
#line 1067
  if (cbyte___3 != max) {
#line 1067
    return ((adns_status )104);
  }
#line 1068
  return ((adns_status )0);
}
}
#line 1071 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_srvha___2(parseinfo const   *pai , int cbyte___3 , int max ,
                                void *datap ) 
{ 
  adns_rr_srvha *rrp ;
  adns_status st ;

  {
  {
#line 1073
  rrp = (adns_rr_srvha *)datap;
#line 1076
  st = pap_srv_begin___2(pai, & cbyte___3, max, (adns_rr_srvha *)datap);
  }
#line 1076
  if (st) {
#line 1076
    return (st);
  }
  {
#line 1077
  st = pap_hostaddr___2(pai, & cbyte___3, max, & rrp->ha);
  }
#line 1077
  if (st) {
#line 1077
    return (st);
  }
#line 1078
  if (cbyte___3 != max) {
#line 1078
    return ((adns_status )104);
  }
#line 1079
  return ((adns_status )0);
}
}
#line 1082 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_srvraw___2(adns_query qu , void *datap ) 
{ 
  adns_rr_srvraw *rrp ;

  {
  {
#line 1083
  rrp = (adns_rr_srvraw *)datap;
#line 1084
  adns__makefinal_str(qu, & rrp->host);
  }
#line 1085
  return;
}
}
#line 1087 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_srvha___2(adns_query qu , void *datap ) 
{ 
  adns_rr_srvha *rrp ;

  {
  {
#line 1088
  rrp = (adns_rr_srvha *)datap;
#line 1089
  mfp_hostaddr___2(qu, & rrp->ha);
  }
#line 1090
  return;
}
}
#line 1092 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_srv___2(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_srvraw const   *ap ;
  adns_rr_srvraw const   *bp ;

  {
#line 1093
  ap = (adns_rr_srvraw const   *)datap_a;
#line 1093
  bp = (adns_rr_srvraw const   *)datap_b;
#line 1096
  if (ap->priority < bp->priority) {
#line 1096
    return (0);
  }
#line 1097
  if (ap->priority > bp->priority) {
#line 1097
    return (1);
  }
#line 1098
  return (0);
}
}
#line 1101 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_srv_begin___2(vbuf *vb___0 , adns_rr_srvha const   *rrp ) 
{ 
  char buf___17[30] ;
  int tmp ;

  {
  {
#line 1104
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"%u %u %u ",
          rrp->priority, rrp->weight, rrp->port);
  }
  {
#line 1105
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1105
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 1105
    if (! tmp) {
#line 1105
      return ((adns_status )1);
    }
#line 1105
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1106
  return ((adns_status )0);
}
}
#line 1109 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_srvraw___2(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_srvraw const   *rrp ;
  adns_status st ;
  adns_status tmp ;

  {
  {
#line 1110
  rrp = (adns_rr_srvraw const   *)datap;
#line 1113
  st = csp_srv_begin___2(vb___0, (adns_rr_srvha const   *)((void const   *)rrp));
  }
#line 1113
  if (st) {
#line 1113
    return (st);
  }
  {
#line 1114
  tmp = csp_domain___2(vb___0, (char const   *)rrp->host);
  }
#line 1114
  return (tmp);
}
}
#line 1117 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_srvha___2(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_srvha const   *rrp ;
  adns_status st ;
  adns_status tmp ;

  {
  {
#line 1118
  rrp = (adns_rr_srvha const   *)datap;
#line 1121
  st = csp_srv_begin___2(vb___0, (adns_rr_srvha const   *)datap);
  }
#line 1121
  if (st) {
#line 1121
    return (st);
  }
  {
#line 1122
  tmp = csp_hostaddr___2(vb___0, & rrp->ha);
  }
#line 1122
  return (tmp);
}
}
#line 1125 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void postsort_srv___2(adns_state ads___7 , void *array , int nrrs , struct typeinfo  const  *typei ) 
{ 
  char *workbegin ;
  char *workend ;
  char *search ;
  char *arrayend ;
  adns_rr_srvha const   *rr ;
  union __anonunion_rrtmp_89___2 rrtmp ;
  int cpriority ;
  int totalweight ;
  int runtotal ;
  long randval ;

  {
#line 1138
  workbegin = (char *)array;
#line 1138
  arrayend = workbegin + typei->rrsz * (int const   )nrrs;
  {
#line 1138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1138
    if (! ((unsigned long )workbegin < (unsigned long )arrayend)) {
#line 1138
      goto while_break;
    }
#line 1141
    rr = (adns_rr_srvha const   *)((void *)workbegin);
#line 1141
    cpriority = (int )rr->priority;
#line 1143
    workend = workbegin;
#line 1143
    totalweight = 0;
    {
#line 1143
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1143
      if ((unsigned long )workend < (unsigned long )arrayend) {
#line 1143
        rr = (adns_rr_srvha const   *)((void *)workend);
#line 1143
        if (! (rr->priority == (int const   )cpriority)) {
#line 1143
          goto while_break___0;
        }
      } else {
#line 1143
        goto while_break___0;
      }
#line 1146
      totalweight += (int )rr->weight;
#line 1143
      workend += typei->rrsz;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1155
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1155
      if (! ((unsigned long )(workbegin + typei->rrsz) < (unsigned long )workend)) {
#line 1155
        goto while_break___1;
      }
      {
#line 1159
      randval = nrand48((unsigned short *)(ads___7->rand48xsubi));
#line 1160
      randval %= (long )(totalweight + 1);
#line 1167
      search = workbegin;
#line 1167
      runtotal = 0;
      }
      {
#line 1167
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1167
        rr = (adns_rr_srvha const   *)((void *)search);
#line 1167
        runtotal += (int )rr->weight;
#line 1167
        if (! ((long )runtotal < randval)) {
#line 1167
          goto while_break___2;
        }
#line 1167
        search += typei->rrsz;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1170
      if (! ((unsigned long )search < (unsigned long )arrayend)) {
        {
#line 1170
        __assert_fail("search < arrayend", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                      1170U, "postsort_srv");
        }
      }
#line 1171
      totalweight -= (int )rr->weight;
#line 1172
      if ((unsigned long )search != (unsigned long )workbegin) {
        {
#line 1173
        memcpy((void */* __restrict  */)(& rrtmp), (void const   */* __restrict  */)workbegin,
               (size_t )typei->rrsz);
#line 1174
        memcpy((void */* __restrict  */)workbegin, (void const   */* __restrict  */)search,
               (size_t )typei->rrsz);
#line 1175
        memcpy((void */* __restrict  */)search, (void const   */* __restrict  */)(& rrtmp),
               (size_t )typei->rrsz);
        }
      }
#line 1155
      workbegin += typei->rrsz;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1138
    workbegin = workend;
  }
  while_break: /* CIL Label */ ;
  }
#line 1184
  return;
}
}
#line 1190 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_byteblock___2(adns_query qu , void *datap ) 
{ 
  adns_rr_byteblock *rrp ;
  void *bytes___3 ;

  {
  {
#line 1191
  rrp = (adns_rr_byteblock *)datap;
#line 1192
  bytes___3 = (void *)rrp->data;
#line 1193
  adns__makefinal_block(qu, & bytes___3, (size_t )rrp->len);
#line 1194
  rrp->data = (unsigned char *)bytes___3;
  }
#line 1195
  return;
}
}
#line 1201 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_opaque___2(parseinfo const   *pai , int cbyte___3 , int max ,
                                 void *datap ) 
{ 
  adns_rr_byteblock *rrp ;
  void *tmp ;

  {
  {
#line 1203
  rrp = (adns_rr_byteblock *)datap;
#line 1205
  rrp->len = max - cbyte___3;
#line 1206
  tmp = adns__alloc_interim((adns_query )pai->qu, (size_t )rrp->len);
#line 1206
  rrp->data = (unsigned char *)tmp;
  }
#line 1207
  if (! rrp->data) {
#line 1207
    return ((adns_status )1);
  }
  {
#line 1208
  memcpy((void */* __restrict  */)rrp->data, (void const   */* __restrict  */)(pai->dgram + cbyte___3),
         (size_t )rrp->len);
  }
#line 1209
  return ((adns_status )0);
}
}
#line 1212 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_opaque___2(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_byteblock const   *rrp ;
  char buf___17[10] ;
  int l ;
  unsigned char *p ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1213
  rrp = (adns_rr_byteblock const   *)datap;
#line 1218
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"\\# %d",
          rrp->len);
  }
  {
#line 1219
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1219
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 1219
    if (! tmp) {
#line 1219
      return ((adns_status )1);
    }
#line 1219
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1221
  l = (int )rrp->len;
#line 1221
  p = (unsigned char *)rrp->data;
  {
#line 1221
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1221
    if (! (l >= 4)) {
#line 1221
      goto while_break___0;
    }
    {
#line 1224
    sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %02x%02x%02x%02x",
            (int )*(p + 0), (int )*(p + 1), (int )*(p + 2), (int )*(p + 3));
    }
    {
#line 1225
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1225
      tmp___0 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
      }
#line 1225
      if (! tmp___0) {
#line 1225
        return ((adns_status )1);
      }
#line 1225
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1221
    l -= 4;
#line 1221
    p += 4;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1227
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1227
    if (! (l > 0)) {
#line 1227
      goto while_break___2;
    }
    {
#line 1230
    sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %02x",
            (int )*p);
    }
    {
#line 1231
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 1231
      tmp___1 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
      }
#line 1231
      if (! tmp___1) {
#line 1231
        return ((adns_status )1);
      }
#line 1231
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1227
    l --;
#line 1227
    p ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1233
  return ((adns_status )0);
}
}
#line 1240 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_flat___2(adns_query qu , void *data___0 ) 
{ 


  {
#line 1240
  return;
}
}
#line 1261 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static typeinfo const   typeinfos___2[17]  = 
#line 1261
  {      {(adns_rrtype )1, "A", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.inaddr)),
      & mf_flat___2, & cs_inaddr___2, & pa_inaddr___2, & di_inaddr___2, (adns_status (*)(adns_state ads ,
                                                                                         char const   **p_io ,
                                                                                         char const   *pe ,
                                                                                         int labelnum ,
                                                                                         char *label_r ,
                                                                                         int *ll_io ,
                                                                                         adns_queryflags flags ,
                                                                                         struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )2,
      "NS", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___2, & cs_domain___2,
      & pa_host_raw___2, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )5,
      "CNAME", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___2,
      & cs_domain___2, & pa_dom_raw___2, (int (*)(adns_state ads , void const   *datap_a ,
                                                  void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                              char const   **p_io ,
                                                                                              char const   *pe ,
                                                                                              int labelnum ,
                                                                                              char *label_r ,
                                                                                              int *ll_io ,
                                                                                              adns_queryflags flags ,
                                                                                              struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )6,
      "SOA", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.soa)), & mf_soa___2, & cs_soa___2,
      & pa_soa___2, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )12,
      "PTR", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___2, & cs_domain___2,
      & pa_host_raw___2, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )13,
      "HINFO", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.intstrpair)),
      & mf_intstrpair___2, & cs_hinfo___2, & pa_hinfo___2, (int (*)(adns_state ads ,
                                                                    void const   *datap_a ,
                                                                    void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )15,
      "MX", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.intstr)), & mf_intstr___2,
      & cs_inthost___2, & pa_mx_raw___2, & di_mx_raw___2, (adns_status (*)(adns_state ads ,
                                                                           char const   **p_io ,
                                                                           char const   *pe ,
                                                                           int labelnum ,
                                                                           char *label_r ,
                                                                           int *ll_io ,
                                                                           adns_queryflags flags ,
                                                                           struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )16,
      "TXT", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.manyistr)),
      & mf_manyistr___2, & cs_txt___2, & pa_txt___2, (int (*)(adns_state ads , void const   *datap_a ,
                                                              void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )17,
      "RP", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.strpair)), & mf_strpair___2,
      & cs_rp___2, & pa_rp___2, (int (*)(adns_state ads , void const   *datap_a ,
                                         void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                     char const   **p_io ,
                                                                                     char const   *pe ,
                                                                                     int labelnum ,
                                                                                     char *label_r ,
                                                                                     int *ll_io ,
                                                                                     adns_queryflags flags ,
                                                                                     struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )33,
      "SRV", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.srvraw)), & mf_srvraw___2,
      & cs_srvraw___2, & pa_srvraw___2, & di_srv___2, & qdpl_srv___2, & postsort_srv___2}, 
        {(adns_rrtype )65537,
      "A", "addr", (int )sizeof(*(((adns_answer *)0)->rrs.addr)), & mf_flat___2, & cs_addr___2,
      & pa_addr___2, & di_addr___2, (adns_status (*)(adns_state ads , char const   **p_io ,
                                                     char const   *pe , int labelnum ,
                                                     char *label_r , int *ll_io ,
                                                     adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65538,
      "NS", "+addr", (int )sizeof(*(((adns_answer *)0)->rrs.hostaddr)), & mf_hostaddr___2,
      & cs_hostaddr___2, & pa_hostaddr___2, & di_hostaddr___2, (adns_status (*)(adns_state ads ,
                                                                                char const   **p_io ,
                                                                                char const   *pe ,
                                                                                int labelnum ,
                                                                                char *label_r ,
                                                                                int *ll_io ,
                                                                                adns_queryflags flags ,
                                                                                struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65548,
      "PTR", "checked", (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___2,
      & cs_domain___2, & pa_ptr___2, (int (*)(adns_state ads , void const   *datap_a ,
                                              void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                          char const   **p_io ,
                                                                                          char const   *pe ,
                                                                                          int labelnum ,
                                                                                          char *label_r ,
                                                                                          int *ll_io ,
                                                                                          adns_queryflags flags ,
                                                                                          struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65551,
      "MX", "+addr", (int )sizeof(*(((adns_answer *)0)->rrs.inthostaddr)), & mf_inthostaddr___2,
      & cs_inthostaddr___2, & pa_mx___2, & di_mx___2, (adns_status (*)(adns_state ads ,
                                                                       char const   **p_io ,
                                                                       char const   *pe ,
                                                                       int labelnum ,
                                                                       char *label_r ,
                                                                       int *ll_io ,
                                                                       adns_queryflags flags ,
                                                                       struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65569,
      "SRV", "+addr", (int )sizeof(*(((adns_answer *)0)->rrs.srvha)), & mf_srvha___2,
      & cs_srvha___2, & pa_srvha___2, & di_srv___2, & qdpl_srv___2, & postsort_srv___2}, 
        {(adns_rrtype )131078,
      "SOA", "822", (int )sizeof(*(((adns_answer *)0)->rrs.soa)), & mf_soa___2, & cs_soa___2,
      & pa_soa___2, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )131089,
      "RP", "822", (int )sizeof(*(((adns_answer *)0)->rrs.strpair)), & mf_strpair___2,
      & cs_rp___2, & pa_rp___2, (int (*)(adns_state ads , void const   *datap_a ,
                                         void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                     char const   **p_io ,
                                                                                     char const   *pe ,
                                                                                     int labelnum ,
                                                                                     char *label_r ,
                                                                                     int *ll_io ,
                                                                                     adns_queryflags flags ,
                                                                                     struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}};
#line 1288 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static struct typeinfo  const  typeinfo_unknown___2  = 
#line 1288
     {(adns_rrtype )262144, (char const   *)0, "unknown", (int )sizeof(*(((adns_answer *)0)->rrs.byteblock)),
    & mf_byteblock___2, & cs_opaque___2, & pa_opaque___2, (int (*)(adns_state ads ,
                                                                   void const   *datap_a ,
                                                                   void const   *datap_b ))0,
    (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                     char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
    (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0};
#line 55 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_query_alloc___2(adns_state ads___7 , adns_query qu ) 
{ 
  allocnode *an ;
  int tmp ;

  {
#line 58
  if (qu->allocations.head) {
#line 58
    if (! (! (qu->allocations.head)->back)) {
      {
#line 58
      __assert_fail("! (qu->allocations).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    59U, "checkc_query_alloc");
      }
    }
#line 58
    an = qu->allocations.head;
    {
#line 58
    while (1) {
      while_continue: /* CIL Label */ ;
#line 58
      if (! an) {
#line 58
        goto while_break;
      }
#line 58
      if (an->next) {
#line 58
        tmp = (unsigned long )an == (unsigned long )(an->next)->back;
      } else {
#line 58
        tmp = (unsigned long )an == (unsigned long )qu->allocations.tail;
      }
#line 58
      if (! tmp) {
        {
#line 58
        __assert_fail("(an)-> next ? (an) == (an)-> next-> back : (an) == (qu->allocations).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      59U, "checkc_query_alloc");
        }
      }
#line 58
      an = an->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 60
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_query___2(adns_state ads___7 , adns_query qu ) 
{ 
  adns_query child ;

  {
#line 65
  if (! (qu->udpnextserver < ads___7->nservers)) {
    {
#line 65
    __assert_fail("qu->udpnextserver < ads->nservers", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  65U, "checkc_query");
    }
  }
#line 66
  if (! (! (qu->udpsent & (0xffffffffffffffffUL << ads___7->nservers)))) {
    {
#line 66
    __assert_fail("!(qu->udpsent & (~0UL << ads->nservers))", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  66U, "checkc_query");
    }
  }
#line 67
  if (! (qu->search_pos <= ads___7->nsearchlist)) {
    {
#line 67
    __assert_fail("qu->search_pos <= ads->nsearchlist", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  67U, "checkc_query");
    }
  }
#line 68
  if (qu->parent) {
    {
#line 68
    while (1) {
      while_continue: /* CIL Label */ ;
#line 68
      child = (qu->parent)->children.head;
      {
#line 68
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 68
        if (! ((unsigned long )child != (unsigned long )qu)) {
#line 68
          goto while_break___0;
        }
#line 68
        if (! child) {
          {
#line 68
          __assert_fail("(child)", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        68U, "checkc_query");
          }
        }
#line 68
        child = child->siblings.next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 68
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 69
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_notcpbuf___2(adns_state ads___7 ) 
{ 


  {
#line 72
  if (! (! ads___7->tcpsend.used)) {
    {
#line 72
    __assert_fail("!ads->tcpsend.used", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  72U, "checkc_notcpbuf");
    }
  }
#line 73
  if (! (! ads___7->tcprecv.used)) {
    {
#line 73
    __assert_fail("!ads->tcprecv.used", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  73U, "checkc_notcpbuf");
    }
  }
#line 74
  if (! (! ads___7->tcprecv_skip)) {
    {
#line 74
    __assert_fail("!ads->tcprecv_skip", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  74U, "checkc_notcpbuf");
    }
  }
#line 75
  return;
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_global___2(adns_state ads___7 ) 
{ 
  int i ;

  {
#line 80
  if (! (ads___7->udpsocket >= 0)) {
    {
#line 80
    __assert_fail("ads->udpsocket >= 0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  80U, "checkc_global");
    }
  }
#line 82
  i = 0;
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! (i < ads___7->nsortlist)) {
#line 82
      goto while_break;
    }
#line 83
    if (! (! (ads___7->sortlist[i].base.s_addr & ~ ads___7->sortlist[i].mask.s_addr))) {
      {
#line 83
      __assert_fail("!(ads->sortlist[i].base.s_addr & ~ads->sortlist[i].mask.s_addr)",
                    "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    83U, "checkc_global");
      }
    }
#line 82
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  if (ads___7->tcpserver >= 0) {
#line 85
    if (! (ads___7->tcpserver < ads___7->nservers)) {
      {
#line 85
      __assert_fail("ads->tcpserver >= 0 && ads->tcpserver < ads->nservers", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    85U, "checkc_global");
      }
    }
  } else {
    {
#line 85
    __assert_fail("ads->tcpserver >= 0 && ads->tcpserver < ads->nservers", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  85U, "checkc_global");
    }
  }
  {
#line 88
  if ((unsigned int )ads___7->tcpstate == 1U) {
#line 88
    goto case_1;
  }
#line 93
  if ((unsigned int )ads___7->tcpstate == 3U) {
#line 93
    goto case_3;
  }
#line 93
  if ((unsigned int )ads___7->tcpstate == 0U) {
#line 93
    goto case_3;
  }
#line 97
  if ((unsigned int )ads___7->tcpstate == 2U) {
#line 97
    goto case_2;
  }
#line 101
  goto switch_default;
  case_1: /* CIL Label */ 
#line 89
  if (! (ads___7->tcpsocket >= 0)) {
    {
#line 89
    __assert_fail("ads->tcpsocket >= 0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  89U, "checkc_global");
    }
  }
  {
#line 90
  checkc_notcpbuf___2(ads___7);
  }
#line 91
  goto switch_break;
  case_3: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 94
  if (! (ads___7->tcpsocket == -1)) {
    {
#line 94
    __assert_fail("ads->tcpsocket == -1", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  94U, "checkc_global");
    }
  }
  {
#line 95
  checkc_notcpbuf___2(ads___7);
  }
#line 96
  goto switch_break;
  case_2: /* CIL Label */ 
#line 98
  if (! (ads___7->tcpsocket >= 0)) {
    {
#line 98
    __assert_fail("ads->tcpsocket >= 0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  98U, "checkc_global");
    }
  }
#line 99
  if (! (ads___7->tcprecv_skip <= ads___7->tcprecv.used)) {
    {
#line 99
    __assert_fail("ads->tcprecv_skip <= ads->tcprecv.used", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  99U, "checkc_global");
    }
  }
#line 100
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 102
  __assert_fail("!\"ads->tcpstate value\"", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                102U, "checkc_global");
  }
  switch_break: /* CIL Label */ ;
  }
#line 105
  if (! ads___7->searchlist) {
#line 105
    if (! (! ads___7->nsearchlist)) {
      {
#line 105
      __assert_fail("ads->searchlist || !ads->nsearchlist", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    105U, "checkc_global");
      }
    }
  }
#line 106
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_queue_udpw___2(adns_state ads___7 ) 
{ 
  adns_query qu ;
  int tmp ;

  {
#line 111
  if (ads___7->udpw.head) {
#line 111
    if (! (! (ads___7->udpw.head)->back)) {
      {
#line 111
      __assert_fail("! (ads->udpw).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    118U, "checkc_queue_udpw");
      }
    }
#line 111
    qu = ads___7->udpw.head;
    {
#line 111
    while (1) {
      while_continue: /* CIL Label */ ;
#line 111
      if (! qu) {
#line 111
        goto while_break;
      }
#line 111
      if (qu->next) {
#line 111
        tmp = (unsigned long )qu == (unsigned long )(qu->next)->back;
      } else {
#line 111
        tmp = (unsigned long )qu == (unsigned long )ads___7->udpw.tail;
      }
#line 111
      if (! tmp) {
        {
#line 111
        __assert_fail("(qu)-> next ? (qu) == (qu)-> next-> back : (qu) == (ads->udpw).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! ((unsigned int )qu->state == 0U)) {
        {
#line 111
        __assert_fail("qu->state==query_tosend", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! (qu->retries <= 15)) {
        {
#line 111
        __assert_fail("qu->retries <= 15", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! qu->udpsent) {
        {
#line 111
        __assert_fail("qu->udpsent", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! qu->children.head) {
#line 111
        if (! (! qu->children.tail)) {
          {
#line 111
          __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        118U, "checkc_queue_udpw");
          }
        }
      } else {
        {
#line 111
        __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
      {
#line 111
      checkc_query___2(ads___7, qu);
#line 111
      checkc_query_alloc___2(ads___7, qu);
#line 111
      qu = qu->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 119
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_queue_tcpw___2(adns_state ads___7 ) 
{ 
  adns_query qu ;
  int tmp ;

  {
#line 124
  if (ads___7->tcpw.head) {
#line 124
    if (! (! (ads___7->tcpw.head)->back)) {
      {
#line 124
      __assert_fail("! (ads->tcpw).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    130U, "checkc_queue_tcpw");
      }
    }
#line 124
    qu = ads___7->tcpw.head;
    {
#line 124
    while (1) {
      while_continue: /* CIL Label */ ;
#line 124
      if (! qu) {
#line 124
        goto while_break;
      }
#line 124
      if (qu->next) {
#line 124
        tmp = (unsigned long )qu == (unsigned long )(qu->next)->back;
      } else {
#line 124
        tmp = (unsigned long )qu == (unsigned long )ads___7->tcpw.tail;
      }
#line 124
      if (! tmp) {
        {
#line 124
        __assert_fail("(qu)-> next ? (qu) == (qu)-> next-> back : (qu) == (ads->tcpw).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
#line 124
      if (! ((unsigned int )qu->state == 1U)) {
        {
#line 124
        __assert_fail("qu->state==query_tcpw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
#line 124
      if (! qu->children.head) {
#line 124
        if (! (! qu->children.tail)) {
          {
#line 124
          __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        130U, "checkc_queue_tcpw");
          }
        }
      } else {
        {
#line 124
        __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
#line 124
      if (! (qu->retries <= ads___7->nservers + 1)) {
        {
#line 124
        __assert_fail("qu->retries <= ads->nservers+1", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
      {
#line 124
      checkc_query___2(ads___7, qu);
#line 124
      checkc_query_alloc___2(ads___7, qu);
#line 124
      qu = qu->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 131
  return;
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_queue_childw___2(adns_state ads___7 ) 
{ 
  adns_query parent ;
  adns_query child ;
  int tmp ;
  int tmp___0 ;

  {
#line 136
  if (ads___7->childw.head) {
#line 136
    if (! (! (ads___7->childw.head)->back)) {
      {
#line 136
      __assert_fail("! (ads->childw).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    145U, "checkc_queue_childw");
      }
    }
#line 136
    parent = ads___7->childw.head;
    {
#line 136
    while (1) {
      while_continue: /* CIL Label */ ;
#line 136
      if (! parent) {
#line 136
        goto while_break;
      }
#line 136
      if (parent->next) {
#line 136
        tmp = (unsigned long )parent == (unsigned long )(parent->next)->back;
      } else {
#line 136
        tmp = (unsigned long )parent == (unsigned long )ads___7->childw.tail;
      }
#line 136
      if (! tmp) {
        {
#line 136
        __assert_fail("(parent)-> next ? (parent) == (parent)-> next-> back : (parent) == (ads->childw).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      145U, "checkc_queue_childw");
        }
      }
#line 136
      if (! ((unsigned int )parent->state == 2U)) {
        {
#line 136
        __assert_fail("parent->state == query_childw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      145U, "checkc_queue_childw");
        }
      }
#line 136
      if (! parent->children.head) {
        {
#line 136
        __assert_fail("parent->children.head", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      145U, "checkc_queue_childw");
        }
      }
#line 136
      if (parent->children.head) {
#line 136
        if (! (! (parent->children.head)->siblings.back)) {
          {
#line 136
          __assert_fail("! (parent->children).head->siblings. back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        145U, "checkc_queue_childw");
          }
        }
#line 136
        child = parent->children.head;
        {
#line 136
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 136
          if (! child) {
#line 136
            goto while_break___0;
          }
#line 136
          if (child->siblings.next) {
#line 136
            tmp___0 = (unsigned long )child == (unsigned long )(child->siblings.next)->siblings.back;
          } else {
#line 136
            tmp___0 = (unsigned long )child == (unsigned long )parent->children.tail;
          }
#line 136
          if (! tmp___0) {
            {
#line 136
            __assert_fail("(child)->siblings. next ? (child) == (child)->siblings. next->siblings. back : (child) == (parent->children).tail",
                          "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                          145U, "checkc_queue_childw");
            }
          }
#line 136
          if (! ((unsigned long )child->parent == (unsigned long )parent)) {
            {
#line 136
            __assert_fail("child->parent == parent", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                          145U, "checkc_queue_childw");
            }
          }
#line 136
          if (! ((unsigned int )child->state != 3U)) {
            {
#line 136
            __assert_fail("child->state != query_done", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                          145U, "checkc_queue_childw");
            }
          }
#line 136
          child = child->siblings.next;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 136
      checkc_query___2(ads___7, parent);
#line 136
      checkc_query_alloc___2(ads___7, parent);
#line 136
      parent = parent->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 146
  return;
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_queue_output___2(adns_state ads___7 ) 
{ 
  adns_query qu ;
  int tmp ;

  {
#line 151
  if (ads___7->output.head) {
#line 151
    if (! (! (ads___7->output.head)->back)) {
      {
#line 151
      __assert_fail("! (ads->output).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    157U, "checkc_queue_output");
      }
    }
#line 151
    qu = ads___7->output.head;
    {
#line 151
    while (1) {
      while_continue: /* CIL Label */ ;
#line 151
      if (! qu) {
#line 151
        goto while_break;
      }
#line 151
      if (qu->next) {
#line 151
        tmp = (unsigned long )qu == (unsigned long )(qu->next)->back;
      } else {
#line 151
        tmp = (unsigned long )qu == (unsigned long )ads___7->output.tail;
      }
#line 151
      if (! tmp) {
        {
#line 151
        __assert_fail("(qu)-> next ? (qu) == (qu)-> next-> back : (qu) == (ads->output).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! ((unsigned int )qu->state == 3U)) {
        {
#line 151
        __assert_fail("qu->state == query_done", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! qu->children.head) {
#line 151
        if (! (! qu->children.tail)) {
          {
#line 151
          __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        157U, "checkc_queue_output");
          }
        }
      } else {
        {
#line 151
        __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! (! qu->parent)) {
        {
#line 151
        __assert_fail("!qu->parent", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! qu->allocations.head) {
#line 151
        if (! (! qu->allocations.tail)) {
          {
#line 151
          __assert_fail("!qu->allocations.head && !qu->allocations.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        157U, "checkc_queue_output");
          }
        }
      } else {
        {
#line 151
        __assert_fail("!qu->allocations.head && !qu->allocations.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
      {
#line 151
      checkc_query___2(ads___7, qu);
#line 151
      qu = qu->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 158
  return;
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
static struct sinfo  const  sinfos___2[24]  = 
#line 233 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
  {      {(adns_status )0, "ok", "OK"}, 
        {(adns_status )1, "nomemory", "Out of memory"}, 
        {(adns_status )2, "unknownrrtype", "Query not implemented in DNS library"}, 
        {(adns_status )3, "systemfail", "General resolver or system failure"}, 
        {(adns_status )30, "timeout", "DNS query timed out"}, 
        {(adns_status )31, "allservfail", "All nameservers failed"}, 
        {(adns_status )32, "norecurse", "Recursion denied by nameserver"}, 
        {(adns_status )33, "invalidresponse", "Nameserver sent bad response"}, 
        {(adns_status )34, "unknownformat", "Nameserver used unknown format"}, 
        {(adns_status )60, "rcodeservfail", "Nameserver reports failure"}, 
        {(adns_status )61, "rcodeformaterror", "Query not understood by nameserver"}, 
        {(adns_status )62,
      "rcodenotimplemented", "Query not implemented by nameserver"}, 
        {(adns_status )63, "rcoderefused", "Query refused by nameserver"}, 
        {(adns_status )64, "rcodeunknown", "Nameserver sent unknown response code"}, 
        {(adns_status )100, "inconsistent", "Inconsistent resource records in DNS"}, 
        {(adns_status )101, "prohibitedcname", "DNS alias found where canonical name wanted"}, 
        {(adns_status )102,
      "answerdomaininvalid", "Found syntactically invalid domain name"}, 
        {(adns_status )103, "answerdomaintoolong", "Found overly-long domain name"}, 
        {(adns_status )104, "invaliddata", "Found invalid DNS data"}, 
        {(adns_status )200, "querydomainwrong", "Domain invalid for particular DNS query type"}, 
        {(adns_status )201,
      "querydomaininvalid", "Domain name is syntactically invalid"}, 
        {(adns_status )202, "querydomaintoolong", "Domain name or component is too long"}, 
        {(adns_status )300,
      "nxdomain", "No such domain"}, 
        {(adns_status )301, "nodata", "No such data"}};
#line 270 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
static int si_compar___2(void const   *key , void const   *elem ) 
{ 
  adns_status const   *st ;
  struct sinfo  const  *si ;
  int tmp ;
  int tmp___0 ;

  {
#line 271
  st = (adns_status const   *)key;
#line 272
  si = (struct sinfo  const  *)elem;
#line 274
  if ((unsigned int const   )*st < (unsigned int const   )si->st) {
#line 274
    tmp___0 = -1;
  } else {
#line 274
    if ((unsigned int const   )*st > (unsigned int const   )si->st) {
#line 274
      tmp = 1;
    } else {
#line 274
      tmp = 0;
    }
#line 274
    tmp___0 = tmp;
  }
#line 274
  return (tmp___0);
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
static struct sinfo  const  *findsinfo___2(adns_status st ) 
{ 
  void *tmp ;

  {
  {
#line 278
  tmp = bsearch((void const   *)(& st), (void const   *)(sinfos___2), sizeof(sinfos___2) / sizeof(sinfos___2[0]),
                sizeof(sinfos___2[0]), & si_compar___2);
  }
#line 278
  return ((struct sinfo  const  *)tmp);
}
}
#line 299 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
static struct stinfo  const  stinfos___2[7]  = {      {(adns_status )0, "ok"}, 
        {(adns_status )29, "localfail"}, 
        {(adns_status )59, "remotefail"}, 
        {(adns_status )99, "tempfail"}, 
        {(adns_status )199, "misconfig"}, 
        {(adns_status )299, "misquery"}, 
        {(adns_status )499, "permfail"}};
#line 312 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
static int sti_compar___2(void const   *key , void const   *elem ) 
{ 
  adns_status const   *st ;
  struct stinfo  const  *sti ;
  adns_status here ;
  adns_status min ;
  adns_status max ;
  int tmp ;
  int tmp___0 ;

  {
#line 313
  st = (adns_status const   *)key;
#line 314
  sti = (struct stinfo  const  *)elem;
#line 318
  here = (adns_status )*st;
#line 319
  if ((unsigned long )sti == (unsigned long )(stinfos___2)) {
#line 319
    min = (adns_status )0;
  } else {
#line 319
    min = (adns_status )((unsigned int const   )(sti + -1)->stmax + 1U);
  }
#line 320
  max = (adns_status )sti->stmax;
#line 322
  if ((unsigned int )here < (unsigned int )min) {
#line 322
    tmp___0 = -1;
  } else {
#line 322
    if ((unsigned int )here > (unsigned int )max) {
#line 322
      tmp = 1;
    } else {
#line 322
      tmp = 0;
    }
#line 322
    tmp___0 = tmp;
  }
#line 322
  return (tmp___0);
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/transmit.c"
static adns_status mkquery_header___2(adns_state ads___7 , vbuf *vb___0 , int *id_r ,
                                      int qdlen ) 
{ 
  int id ;
  byte *rqp ;
  int tmp ;
  int tmp___0 ;
  byte *tmp___1 ;
  byte *tmp___2 ;
  byte *tmp___3 ;
  byte *tmp___4 ;
  byte *tmp___5 ;
  byte *tmp___6 ;
  byte *tmp___7 ;
  byte *tmp___8 ;
  byte *tmp___9 ;
  byte *tmp___10 ;
  byte *tmp___11 ;
  byte *tmp___12 ;

  {
  {
#line 46
  tmp = adns__vbuf_ensure(vb___0, (12 + qdlen) + 4);
  }
#line 46
  if (! tmp) {
#line 46
    return ((adns_status )1);
  }
#line 48
  vb___0->used = 0;
#line 49
  rqp = vb___0->buf + vb___0->used;
#line 51
  tmp___0 = ads___7->nextid;
#line 51
  (ads___7->nextid) ++;
#line 51
  id = tmp___0 & 65535;
#line 51
  *id_r = id;
#line 52
  tmp___1 = rqp;
#line 52
  rqp ++;
#line 52
  *tmp___1 = (byte )((id >> 8) & 255);
#line 52
  tmp___2 = rqp;
#line 52
  rqp ++;
#line 52
  *tmp___2 = (byte )(id & 255);
#line 53
  tmp___3 = rqp;
#line 53
  rqp ++;
#line 53
  *tmp___3 = (byte )1;
#line 54
  tmp___4 = rqp;
#line 54
  rqp ++;
#line 54
  *tmp___4 = (byte )0;
#line 55
  tmp___5 = rqp;
#line 55
  rqp ++;
#line 55
  *tmp___5 = (byte )((1 >> 8) & 255);
#line 55
  tmp___6 = rqp;
#line 55
  rqp ++;
#line 55
  *tmp___6 = (byte )1;
#line 56
  tmp___7 = rqp;
#line 56
  rqp ++;
#line 56
  *tmp___7 = (byte )0;
#line 56
  tmp___8 = rqp;
#line 56
  rqp ++;
#line 56
  *tmp___8 = (byte )0;
#line 57
  tmp___9 = rqp;
#line 57
  rqp ++;
#line 57
  *tmp___9 = (byte )0;
#line 57
  tmp___10 = rqp;
#line 57
  rqp ++;
#line 57
  *tmp___10 = (byte )0;
#line 58
  tmp___11 = rqp;
#line 58
  rqp ++;
#line 58
  *tmp___11 = (byte )0;
#line 58
  tmp___12 = rqp;
#line 58
  rqp ++;
#line 58
  *tmp___12 = (byte )0;
#line 60
  vb___0->used = (int )(rqp - vb___0->buf);
#line 62
  return ((adns_status )0);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/transmit.c"
static adns_status mkquery_footer___2(vbuf *vb___0 , adns_rrtype type ) 
{ 
  byte *rqp ;
  byte *tmp ;
  byte *tmp___0 ;
  byte *tmp___1 ;
  byte *tmp___2 ;

  {
#line 68
  rqp = vb___0->buf + vb___0->used;
#line 69
  tmp = rqp;
#line 69
  rqp ++;
#line 69
  *tmp = (byte )((((unsigned int )type & 65535U) >> 8) & 255U);
#line 69
  tmp___0 = rqp;
#line 69
  rqp ++;
#line 69
  *tmp___0 = (byte )(((unsigned int )type & 65535U) & 255U);
#line 70
  tmp___1 = rqp;
#line 70
  rqp ++;
#line 70
  *tmp___1 = (byte )((1 >> 8) & 255);
#line 70
  tmp___2 = rqp;
#line 70
  rqp ++;
#line 70
  *tmp___2 = (byte )1;
#line 71
  vb___0->used = (int )(rqp - vb___0->buf);
#line 72
  if (! (vb___0->used <= vb___0->avail)) {
    {
#line 72
    __assert_fail("vb->used <= vb->avail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/transmit.c",
                  72U, "mkquery_footer");
    }
  }
#line 74
  return ((adns_status )0);
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/transmit.c"
static void query_usetcp___2(adns_query qu , struct timeval now ) 
{ 


  {
  {
#line 244
  qu->state = (enum __anonenum_state_83 )1;
#line 245
  qu->timeout = now;
#line 246
  timevaladd(& qu->timeout, 30000L);
  }
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    qu->next = (adns_query )0;
#line 247
    qu->back = (qu->ads)->tcpw.tail;
#line 247
    if ((qu->ads)->tcpw.tail) {
#line 247
      ((qu->ads)->tcpw.tail)->next = qu;
    } else {
#line 247
      (qu->ads)->tcpw.head = qu;
    }
#line 247
    (qu->ads)->tcpw.tail = qu;
#line 247
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 248
  adns__querysend_tcp(qu, now);
#line 249
  adns__tcp_tryconnect(qu->ads, now);
  }
#line 250
  return;
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static adns_query query_alloc___2(adns_state ads___7 , typeinfo const   *typei , adns_rrtype type ,
                                  adns_queryflags flags , struct timeval now ) 
{ 
  adns_query qu ;
  void *tmp ;
  void *tmp___0 ;
  adns_query tmp___1 ;
  adns_query tmp___2 ;
  adns_query tmp___3 ;
  adns_query tmp___4 ;
  allocnode *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __suseconds_t tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 45
  tmp = Hmalloc(sizeof(*qu));
#line 45
  qu = (adns_query )tmp;
  }
#line 45
  if (! qu) {
#line 45
    return ((adns_query )0);
  }
  {
#line 46
  tmp___0 = Hmalloc(sizeof(*(qu->answer)));
#line 46
  qu->answer = (adns_answer *)tmp___0;
  }
#line 47
  if (! qu->answer) {
    {
#line 47
    Hfree((void *)qu);
    }
#line 47
    return ((adns_query )0);
  }
  {
#line 49
  qu->ads = ads___7;
#line 50
  qu->state = (enum __anonenum_state_83 )0;
#line 51
  tmp___2 = (adns_query )0;
#line 51
  qu->parent = tmp___2;
#line 51
  tmp___1 = tmp___2;
#line 51
  qu->next = tmp___1;
#line 51
  qu->back = tmp___1;
#line 52
  tmp___3 = (adns_query )0;
#line 52
  qu->children.tail = tmp___3;
#line 52
  qu->children.head = tmp___3;
#line 53
  tmp___4 = (adns_query )0;
#line 53
  qu->siblings.back = tmp___4;
#line 53
  qu->siblings.next = tmp___4;
#line 54
  tmp___5 = (allocnode *)0;
#line 54
  qu->allocations.tail = tmp___5;
#line 54
  qu->allocations.head = tmp___5;
#line 55
  qu->interim_allocd = 0;
#line 56
  qu->preserved_allocd = 0;
#line 57
  qu->final_allocspace = (void *)0;
#line 59
  qu->typei = typei;
#line 60
  qu->query_dgram = (byte *)0;
#line 61
  qu->query_dglen = 0;
#line 62
  adns__vbuf_init(& qu->vb);
#line 64
  qu->cname_dgram = (byte *)0;
#line 65
  tmp___6 = 0;
#line 65
  qu->cname_begin = tmp___6;
#line 65
  qu->cname_dglen = tmp___6;
#line 67
  adns__vbuf_init(& qu->search_vb);
#line 68
  tmp___8 = 0;
#line 68
  qu->search_doneabs = tmp___8;
#line 68
  tmp___7 = tmp___8;
#line 68
  qu->search_pos = tmp___7;
#line 68
  qu->search_origlen = tmp___7;
#line 70
  qu->id = -2;
#line 71
  qu->flags = (int )flags;
#line 72
  qu->retries = 0;
#line 73
  qu->udpnextserver = 0;
#line 74
  qu->udpsent = 0UL;
#line 75
  tmp___9 = (__suseconds_t )0;
#line 75
  qu->timeout.tv_usec = tmp___9;
#line 75
  qu->timeout.tv_sec = tmp___9;
#line 76
  qu->expires = now.tv_sec + 604800L;
#line 78
  memset((void *)(& qu->ctx), 0, sizeof(qu->ctx));
#line 80
  (qu->answer)->status = (adns_status )0;
#line 81
  tmp___10 = (char *)0;
#line 81
  (qu->answer)->owner = tmp___10;
#line 81
  (qu->answer)->cname = tmp___10;
#line 82
  (qu->answer)->type = type;
#line 83
  (qu->answer)->expires = (time_t )-1;
#line 84
  (qu->answer)->nrrs = 0;
#line 85
  (qu->answer)->rrs.untyped = (void *)0;
#line 86
  (qu->answer)->rrsz = (int )typei->rrsz;
  }
#line 88
  return (qu);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void query_submit___2(adns_state ads___7 , adns_query qu , typeinfo const   *typei ,
                             vbuf *qumsg_vb , int id , adns_queryflags flags , struct timeval now ) 
{ 
  void *tmp ;

  {
  {
#line 98
  qu->vb = *qumsg_vb;
#line 99
  adns__vbuf_init(qumsg_vb);
#line 101
  tmp = Hmalloc((size_t )qu->vb.used);
#line 101
  qu->query_dgram = (byte *)tmp;
  }
#line 102
  if (! qu->query_dgram) {
    {
#line 102
    adns__query_fail(qu, (adns_status )1);
    }
#line 102
    return;
  }
  {
#line 104
  qu->id = id;
#line 105
  qu->query_dglen = qu->vb.used;
#line 106
  memcpy((void */* __restrict  */)qu->query_dgram, (void const   */* __restrict  */)qu->vb.buf,
         (size_t )qu->vb.used);
#line 108
  adns__query_send(qu, now);
  }
#line 109
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void query_simple___2(adns_state ads___7 , adns_query qu , char const   *owner ,
                             int ol , typeinfo const   *typei , adns_queryflags flags ,
                             struct timeval now ) 
{ 
  vbuf vb_new ;
  int id ;
  adns_status stat ;

  {
  {
#line 136
  stat = adns__mkquery(ads___7, & qu->vb, & id, owner, ol, typei, (qu->answer)->type,
                       flags);
  }
#line 138
  if (stat) {
#line 139
    if ((unsigned int )stat == 202U) {
#line 139
      if ((unsigned int )flags & 1U) {
        {
#line 140
        adns__search_next(ads___7, qu, now);
        }
#line 141
        return;
      } else {
        {
#line 143
        adns__query_fail(qu, stat);
        }
#line 144
        return;
      }
    } else {
      {
#line 143
      adns__query_fail(qu, stat);
      }
#line 144
      return;
    }
  }
  {
#line 148
  vb_new = qu->vb;
#line 149
  adns__vbuf_init(& qu->vb);
#line 150
  query_submit___2(ads___7, qu, typei, & vb_new, id, flags, now);
  }
#line 151
  return;
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static int save_owner___2(adns_query qu , char const   *owner , int ol ) 
{ 
  adns_answer *ans ;
  void *tmp ;

  {
#line 198
  if (! (qu->flags & 4)) {
#line 198
    return (1);
  }
#line 200
  ans = qu->answer;
#line 201
  if (! (! ans->owner)) {
    {
#line 201
    __assert_fail("!ans->owner", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c",
                  201U, "save_owner");
    }
  }
  {
#line 203
  tmp = adns__alloc_preserved(qu, (size_t )(ol + 1));
#line 203
  ans->owner = (char *)tmp;
  }
#line 203
  if (! ans->owner) {
#line 203
    return (0);
  }
  {
#line 205
  memcpy((void */* __restrict  */)ans->owner, (void const   */* __restrict  */)owner,
         (size_t )ol);
#line 206
  *(ans->owner + ol) = (char)0;
  }
#line 207
  return (1);
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void *alloc_common___2(adns_query qu , size_t sz ) 
{ 
  allocnode *an ;
  void *tmp ;

  {
#line 342
  if (! sz) {
#line 342
    return ((void *)qu);
  }
#line 343
  if (! (! qu->final_allocspace)) {
    {
#line 343
    __assert_fail("!qu->final_allocspace", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c",
                  343U, "alloc_common");
    }
  }
  {
#line 344
  tmp = Hmalloc((((((((sizeof(*an) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ) + sz) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ));
#line 344
  an = (allocnode *)tmp;
  }
#line 345
  if (! an) {
#line 345
    return ((void *)0);
  }
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 346
    an->next = (struct allocnode *)0;
#line 346
    an->back = qu->allocations.tail;
#line 346
    if (qu->allocations.tail) {
#line 346
      (qu->allocations.tail)->next = an;
    } else {
#line 346
      qu->allocations.head = an;
    }
#line 346
    qu->allocations.tail = an;
#line 346
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 347
  return ((void *)((byte *)an + (((sizeof(*an) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign )));
}
}
#line 410 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void cancel_children___2(adns_query qu ) 
{ 
  adns_query cqu ;
  adns_query ncqu ;

  {
#line 413
  cqu = qu->children.head;
  {
#line 413
  while (1) {
    while_continue: /* CIL Label */ ;
#line 413
    if (! cqu) {
#line 413
      goto while_break;
    }
    {
#line 414
    ncqu = cqu->siblings.next;
#line 415
    adns_cancel(cqu);
#line 413
    cqu = ncqu;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 417
  return;
}
}
#line 427 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void free_query_allocs___2(adns_query qu ) 
{ 
  allocnode *an ;
  allocnode *ann ;
  allocnode *tmp ;

  {
  {
#line 430
  cancel_children___2(qu);
#line 431
  an = qu->allocations.head;
  }
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    if (! an) {
#line 431
      goto while_break;
    }
    {
#line 431
    ann = an->next;
#line 431
    Hfree((void *)an);
#line 431
    an = ann;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 432
  tmp = (allocnode *)0;
#line 432
  qu->allocations.tail = tmp;
#line 432
  qu->allocations.head = tmp;
#line 433
  adns__vbuf_free(& qu->vb);
#line 434
  adns__vbuf_free(& qu->search_vb);
#line 435
  Hfree((void *)qu->query_dgram);
#line 436
  qu->query_dgram = (byte *)0;
  }
#line 437
  return;
}
}
#line 477 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void makefinal_query___2(adns_query qu ) 
{ 
  adns_answer *ans ;
  int rrn ;
  void *tmp ;

  {
#line 481
  ans = qu->answer;
#line 483
  if (qu->interim_allocd) {
    {
#line 484
    tmp = Hrealloc((void *)qu->answer, (((((((sizeof(*ans) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ) + (unsigned long )qu->interim_allocd) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ));
#line 484
    ans = (adns_answer *)tmp;
    }
#line 486
    if (! ans) {
#line 486
      goto x_nomem;
    }
#line 487
    qu->answer = ans;
  }
  {
#line 490
  qu->final_allocspace = (void *)((byte *)ans + (((sizeof(*ans) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ));
#line 491
  adns__makefinal_str(qu, & ans->cname);
#line 492
  adns__makefinal_str(qu, & ans->owner);
  }
#line 494
  if (ans->nrrs) {
    {
#line 495
    adns__makefinal_block(qu, & ans->rrs.untyped, (size_t )(ans->nrrs * ans->rrsz));
#line 497
    rrn = 0;
    }
    {
#line 497
    while (1) {
      while_continue: /* CIL Label */ ;
#line 497
      if (! (rrn < ans->nrrs)) {
#line 497
        goto while_break;
      }
      {
#line 498
      (*((qu->typei)->makefinal))(qu, (void *)(ans->rrs.bytes + rrn * ans->rrsz));
#line 497
      rrn ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 501
  free_query_allocs___2(qu);
  }
#line 502
  return;
  x_nomem: 
  {
#line 505
  qu->preserved_allocd = 0;
#line 506
  (qu->answer)->cname = (char *)0;
#line 507
  (qu->answer)->owner = (char *)0;
#line 508
  adns__reset_preserved(qu);
#line 510
  (qu->answer)->status = (adns_status )1;
#line 511
  free_query_allocs___2(qu);
  }
#line 512
  return;
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void tcp_close___2(adns_state ads___7 ) 
{ 
  int serv ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 48
  serv = ads___7->tcpserver;
#line 49
  Hclose(ads___7->tcpsocket);
#line 50
  ads___7->tcpsocket = -1;
#line 51
  tmp___0 = 0;
#line 51
  ads___7->tcpsend.used = tmp___0;
#line 51
  tmp = tmp___0;
#line 51
  ads___7->tcprecv_skip = tmp;
#line 51
  ads___7->tcprecv.used = tmp;
  }
#line 52
  return;
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void tcp_connected___2(adns_state ads___7 , struct timeval now ) 
{ 
  adns_query qu ;
  adns_query nqu ;

  {
  {
#line 76
  adns__debug(ads___7, ads___7->tcpserver, (adns_query )0, "TCP connected");
#line 77
  ads___7->tcpstate = (enum adns__tcpstate )2;
#line 78
  qu = ads___7->tcpw.head;
  }
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (qu) {
#line 78
      if (! ((unsigned int )ads___7->tcpstate == 2U)) {
#line 78
        goto while_break;
      }
    } else {
#line 78
      goto while_break;
    }
#line 79
    nqu = qu->next;
#line 80
    if (! ((unsigned int )qu->state == 1U)) {
      {
#line 80
      __assert_fail("qu->state == query_tcpw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c",
                    80U, "tcp_connected");
      }
    }
    {
#line 81
    adns__querysend_tcp(qu, now);
#line 78
    qu = nqu;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void tcp_broken_events___2(adns_state ads___7 ) 
{ 
  adns_query qu ;
  adns_query nqu ;

  {
#line 88
  if (! ((unsigned int )ads___7->tcpstate == 3U)) {
    {
#line 88
    __assert_fail("ads->tcpstate == server_broken", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c",
                  88U, "tcp_broken_events");
    }
  }
#line 89
  qu = ads___7->tcpw.head;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! qu) {
#line 89
      goto while_break;
    }
#line 90
    nqu = qu->next;
#line 91
    if (! ((unsigned int )qu->state == 1U)) {
      {
#line 91
      __assert_fail("qu->state == query_tcpw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c",
                    91U, "tcp_broken_events");
      }
    }
#line 92
    if (qu->retries > ads___7->nservers) {
      {
#line 93
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 93
        if (qu->back) {
#line 93
          (qu->back)->next = qu->next;
        } else {
#line 93
          ads___7->tcpw.head = qu->next;
        }
#line 93
        if (qu->next) {
#line 93
          (qu->next)->back = qu->back;
        } else {
#line 93
          ads___7->tcpw.tail = qu->back;
        }
#line 93
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 94
      adns__query_fail(qu, (adns_status )31);
      }
    }
#line 89
    qu = nqu;
  }
  while_break: /* CIL Label */ ;
  }
#line 97
  ads___7->tcpstate = (enum adns__tcpstate )0;
#line 98
  return;
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void inter_immed___2(struct timeval **tv_io , struct timeval *tvbuf ) 
{ 
  struct timeval *rbuf ;
  __suseconds_t tmp ;

  {
#line 174
  if (! tv_io) {
#line 174
    return;
  }
#line 176
  rbuf = *tv_io;
#line 177
  if (! rbuf) {
#line 177
    rbuf = tvbuf;
#line 177
    *tv_io = rbuf;
  }
#line 179
  tmp = (__suseconds_t )0;
#line 179
  rbuf->tv_usec = tmp;
#line 179
  rbuf->tv_sec = tmp;
#line 180
  return;
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void inter_maxto___2(struct timeval **tv_io , struct timeval *tvbuf , struct timeval maxto ) 
{ 
  struct timeval *rbuf ;
  int tmp ;

  {
#line 186
  if (! tv_io) {
#line 186
    return;
  }
#line 187
  rbuf = *tv_io;
#line 188
  if (! rbuf) {
#line 189
    *tvbuf = maxto;
#line 189
    *tv_io = tvbuf;
  } else {
#line 191
    if (rbuf->tv_sec == maxto.tv_sec) {
#line 191
      tmp = rbuf->tv_usec > maxto.tv_usec;
    } else {
#line 191
      tmp = rbuf->tv_sec > maxto.tv_sec;
    }
#line 191
    if (tmp) {
#line 191
      *rbuf = maxto;
    }
  }
#line 195
  return;
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void inter_maxtoabs___2(struct timeval **tv_io , struct timeval *tvbuf , struct timeval now ,
                               struct timeval maxtime ) 
{ 
  ldiv_t dr ;

  {
#line 204
  if (! tv_io) {
#line 204
    return;
  }
  {
#line 205
  maxtime.tv_sec -= now.tv_sec + 2L;
#line 206
  maxtime.tv_usec -= now.tv_usec - 2000000L;
#line 207
  dr = ldiv(maxtime.tv_usec, 1000000L);
#line 208
  maxtime.tv_sec += dr.quot;
#line 209
  maxtime.tv_usec -= dr.quot * 1000000L;
  }
#line 210
  if (maxtime.tv_sec < 0L) {
#line 210
    maxtime.tv_usec = (__suseconds_t )0;
#line 210
    maxtime.tv_sec = maxtime.tv_usec;
  }
  {
#line 211
  inter_maxto___2(tv_io, tvbuf, maxtime);
  }
#line 212
  return;
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void timeouts_queue___2(adns_state ads___7 , int act , struct timeval **tv_io ,
                               struct timeval *tvbuf , struct timeval now , struct query_queue *queue ) 
{ 
  adns_query qu ;
  adns_query nqu ;
  int tmp ;

  {
#line 219
  qu = queue->head;
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if (! qu) {
#line 219
      goto while_break;
    }
#line 220
    nqu = qu->next;
#line 221
    if (now.tv_sec == qu->timeout.tv_sec) {
#line 221
      tmp = now.tv_usec > qu->timeout.tv_usec;
    } else {
#line 221
      tmp = now.tv_sec > qu->timeout.tv_sec;
    }
#line 221
    if (tmp) {
#line 224
      if (! act) {
        {
#line 224
        inter_immed___2(tv_io, tvbuf);
        }
#line 224
        return;
      }
      {
#line 225
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 225
        if (qu->back) {
#line 225
          (qu->back)->next = qu->next;
        } else {
#line 225
          queue->head = qu->next;
        }
#line 225
        if (qu->next) {
#line 225
          (qu->next)->back = qu->back;
        } else {
#line 225
          queue->tail = qu->back;
        }
#line 225
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 226
      if ((unsigned int )qu->state != 0U) {
        {
#line 227
        adns__query_fail(qu, (adns_status )30);
        }
      } else {
        {
#line 229
        adns__query_send(qu, now);
        }
      }
#line 231
      nqu = queue->head;
    } else {
      {
#line 222
      inter_maxtoabs___2(tv_io, tvbuf, now, qu->timeout);
      }
    }
#line 219
    qu = nqu;
  }
  while_break: /* CIL Label */ ;
  }
#line 234
  return;
}
}
#line 236 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void tcp_events___2(adns_state ads___7 , int act , struct timeval **tv_io ,
                           struct timeval *tvbuf , struct timeval now ) 
{ 
  int tmp ;

  {
  {
#line 239
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 241
    if ((unsigned int )ads___7->tcpstate == 3U) {
#line 241
      goto case_3;
    }
#line 244
    if ((unsigned int )ads___7->tcpstate == 0U) {
#line 244
      goto case_0;
    }
#line 249
    if ((unsigned int )ads___7->tcpstate == 2U) {
#line 249
      goto case_2;
    }
#line 256
    if ((unsigned int )ads___7->tcpstate == 1U) {
#line 256
      goto case_1;
    }
#line 275
    goto switch_default___0;
    case_3: /* CIL Label */ 
#line 242
    if (! act) {
      {
#line 242
      inter_immed___2(tv_io, tvbuf);
      }
#line 242
      return;
    }
    {
#line 243
    tcp_broken_events___2(ads___7);
    }
    case_0: /* CIL Label */ 
#line 245
    if (! ads___7->tcpw.head) {
#line 245
      return;
    }
#line 246
    if (! act) {
      {
#line 246
      inter_immed___2(tv_io, tvbuf);
      }
#line 246
      return;
    }
    {
#line 247
    adns__tcp_tryconnect(ads___7, now);
    }
#line 248
    goto switch_break;
    case_2: /* CIL Label */ 
#line 250
    if (ads___7->tcpw.head) {
#line 250
      return;
    }
#line 251
    if (! ads___7->tcptimeout.tv_sec) {
#line 252
      if (! (! ads___7->tcptimeout.tv_usec)) {
        {
#line 252
        __assert_fail("!ads->tcptimeout.tv_usec", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c",
                      252U, "tcp_events");
        }
      }
      {
#line 253
      ads___7->tcptimeout = now;
#line 254
      timevaladd(& ads___7->tcptimeout, 30000L);
      }
    }
    case_1: /* CIL Label */ 
#line 257
    if (! act) {
      {
#line 258
      inter_maxtoabs___2(tv_io, tvbuf, now, ads___7->tcptimeout);
      }
#line 259
      return;
    } else {
#line 257
      if (now.tv_sec == ads___7->tcptimeout.tv_sec) {
#line 257
        tmp = now.tv_usec > ads___7->tcptimeout.tv_usec;
      } else {
#line 257
        tmp = now.tv_sec > ads___7->tcptimeout.tv_sec;
      }
#line 257
      if (! tmp) {
        {
#line 258
        inter_maxtoabs___2(tv_io, tvbuf, now, ads___7->tcptimeout);
        }
#line 259
        return;
      }
    }
    {
#line 263
    if ((unsigned int )ads___7->tcpstate == 1U) {
#line 263
      goto case_1___0;
    }
#line 266
    if ((unsigned int )ads___7->tcpstate == 2U) {
#line 266
      goto case_2___0;
    }
#line 270
    goto switch_default;
    case_1___0: /* CIL Label */ 
    {
#line 264
    adns__tcp_broken(ads___7, "unable to make connection", "timed out");
    }
#line 265
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 267
    tcp_close___2(ads___7);
#line 268
    ads___7->tcpstate = (enum adns__tcpstate )0;
    }
#line 269
    return;
    switch_default: /* CIL Label */ 
    {
#line 271
    abort();
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 274
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
#line 276
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 279
  return;
}
}
#line 516 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void fd_event___2(adns_state ads___7 , int fd , int revent , int pollflag ,
                         int maxfd , fd_set const   *fds , int (*func)(adns_state  ,
                                                                       int fd , struct timeval  const  *now ) ,
                         struct timeval now , int *r_r ) 
{ 
  int r ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 524
  if (! (revent & pollflag)) {
#line 524
    return;
  }
#line 525
  if (fds) {
#line 525
    if (fd < maxfd) {
#line 525
      if (! ((fds->__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
#line 525
        return;
      }
    } else {
#line 525
      return;
    }
  }
  {
#line 526
  r = (*func)(ads___7, fd, (struct timeval  const  *)(& now));
  }
#line 527
  if (r) {
#line 528
    if (r_r) {
#line 529
      *r_r = r;
    } else {
      {
#line 531
      tmp = __errno_location();
#line 531
      tmp___0 = strerror(*tmp);
#line 531
      adns__diag(ads___7, -1, (adns_query )0, "process fd failed after select: %s",
                 tmp___0);
#line 533
      adns_globalsystemfailure(ads___7);
      }
    }
  }
#line 536
  return;
}
}
#line 129 "/usr/include/search.h"
extern void *tsearch(void const   *__key , void **__rootp , int (*__compar)(void const   * ,
                                                                            void const   * ) ) ;
#line 30 "./../src/tvarith.h"
__inline static void timevaladd___7(struct timeval *tv_io , long ms ) 
{ 
  struct timeval tmp ;

  {
#line 32
  if (! (ms >= 0L)) {
    {
#line 32
    __assert_fail("ms>=0", "./../src/tvarith.h", 32U, "timevaladd");
    }
  }
#line 33
  tmp = *tv_io;
#line 34
  tmp.tv_usec += (ms % 1000L) * 1000L;
#line 35
  tmp.tv_sec += ms / 1000L;
#line 36
  if (tmp.tv_usec >= 1000000L) {
#line 36
    (tmp.tv_sec) ++;
#line 36
    tmp.tv_usec -= 1000000L;
  }
#line 37
  *tv_io = tmp;
#line 38
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static int bracket  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static int forever  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static int address  ;
#line 59 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static unsigned long timeout  =    1000UL;
#line 60 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static adns_rrtype rrt  =    (adns_rrtype )65548;
#line 61 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static adns_initflags initflags  =    (adns_initflags )0;
#line 62 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static char const   *config_text___2  ;
#line 64 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static int outblocked  ;
#line 64 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static int inputeof  ;
#line 65 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static struct __anonstruct_outqueue_55 outqueue  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static int peroutqueuenode  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static int outqueuelen  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static struct sockaddr_in sa  ;
#line 69 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static adns_state ads___1  ;
#line 71 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static char addrtextbuf[14]  ;
#line 72 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static int cbyte  ;
#line 72 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static int inbyte  ;
#line 72 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static int inbuf  ;
#line 73 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static unsigned char bytes[4]  ;
#line 74 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static struct timeval printbefore  ;
#line 82 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static struct treething *newthing  ;
#line 83 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static void *treeroot  ;
#line 85 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static int nonblock(int fd , int isnonblock ) 
{ 
  int r ;
  int tmp ;

  {
  {
#line 88
  r = Hfcntl(fd, 3);
  }
#line 89
  if (r == -1) {
#line 89
    return (-1);
  }
#line 90
  if (isnonblock) {
#line 90
    tmp = r | 2048;
  } else {
#line 90
    tmp = r & -2049;
  }
  {
#line 90
  r = Hfcntl(fd, 4, tmp);
  }
#line 91
  if (r == -1) {
#line 91
    return (-1);
  }
#line 92
  return (0);
}
}
#line 101
static  __attribute__((__noreturn__)) void sysfail___0(char const   *what ) ;
#line 102
static  __attribute__((__noreturn__)) void sysfail___0(char const   *what ) ;
#line 102 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static void sysfail___0(char const   *what ) 
{ 
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 103
  tmp = __errno_location();
#line 103
  tmp___0 = strerror(*tmp);
#line 103
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adnsresfilter: system call failed: %s: %s\n",
          what, tmp___0);
#line 104
  quitnow(2);
  }
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static void *xmalloc___0(size_t sz ) 
{ 
  void *r ;

  {
  {
#line 109
  r = Hmalloc(sz);
  }
#line 109
  if (r) {
#line 109
    return (r);
  }
  {
#line 110
  sysfail___0("malloc");
  }
}
}
#line 113
static  __attribute__((__noreturn__)) void outputerr(void) ;
#line 114
static  __attribute__((__noreturn__)) void outputerr(void) ;
#line 114 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static void outputerr(void) 
{ 


  {
  {
#line 114
  sysfail___0("write to stdout");
  }
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static void usage___1(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 117
  tmp = printf((char const   */* __restrict  */)"usage: adnsresfilter [<options ...>]\n       adnsresfilter  -h|--help | --version\noptions: -t<milliseconds>|--timeout <milliseconds>\n         -w|--wait        (always wait for queries to time out or fail)\n         -b|--brackets    (require [...] around IP addresses)\n         -a|--address     (always include [address] in output)\n         -u|--unchecked   (do not forward map for checking)\n         --config <text>  (use this instead of resolv.conf)\n         --debug          (turn on adns resolver debugging)\nTimeout is the maximum amount to delay any particular bit of output for.\nLookups will go on in the background.  Default timeout = 1000 (ms).\n");
  }
#line 117
  if (tmp == -1) {
    {
#line 128
    outputerr();
    }
  }
  {
#line 129
  tmp___0 = fflush(stdout);
  }
#line 129
  if (tmp___0) {
    {
#line 129
    sysfail___0("flush stdout");
    }
  }
#line 130
  return;
}
}
#line 132
static  __attribute__((__noreturn__)) void usageerr___1(char const   *why ) ;
#line 133
static  __attribute__((__noreturn__)) void usageerr___1(char const   *why ) ;
#line 133 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static void usageerr___1(char const   *why ) 
{ 


  {
  {
#line 134
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adnsresfilter: bad usage: %s\n",
          why);
#line 135
  usage___1();
#line 136
  quitnow(1);
  }
}
}
#line 139
static  __attribute__((__noreturn__)) void adnsfail(char const   *what , int e ) ;
#line 140
static  __attribute__((__noreturn__)) void adnsfail(char const   *what , int e ) ;
#line 140 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static void adnsfail(char const   *what , int e ) 
{ 
  char *tmp ;

  {
  {
#line 141
  tmp = strerror(e);
#line 141
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adnsresfilter: adns call failed: %s: %s\n",
          what, tmp);
#line 142
  quitnow(2);
  }
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static void settimeout(char const   *arg ) 
{ 
  char *ep ;

  {
  {
#line 147
  timeout = strtoul((char const   */* __restrict  */)arg, (char **/* __restrict  */)(& ep),
                    0);
  }
#line 148
  if (*ep) {
    {
#line 148
    usageerr___1("invalid timeout");
    }
  }
#line 149
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static void parseargs(char const   * const  *argv ) 
{ 
  char const   *arg ;
  int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    argv ++;
#line 155
    arg = (char const   *)*argv;
#line 155
    if (! arg) {
#line 155
      goto while_break;
    }
#line 156
    if ((int const   )*(arg + 0) != 45) {
      {
#line 156
      usageerr___1("no non-option arguments are allowed");
      }
    }
#line 157
    if ((int const   )*(arg + 1) == 45) {
      {
#line 158
      tmp___9 = strcmp(arg, "--timeout");
      }
#line 158
      if (tmp___9) {
        {
#line 162
        tmp___8 = strcmp(arg, "--wait");
        }
#line 162
        if (tmp___8) {
          {
#line 164
          tmp___7 = strcmp(arg, "--brackets");
          }
#line 164
          if (tmp___7) {
            {
#line 166
            tmp___6 = strcmp(arg, "--address");
            }
#line 166
            if (tmp___6) {
              {
#line 168
              tmp___5 = strcmp(arg, "--unchecked");
              }
#line 168
              if (tmp___5) {
                {
#line 170
                tmp___4 = strcmp(arg, "--config");
                }
#line 170
                if (tmp___4) {
                  {
#line 173
                  tmp___3 = strcmp(arg, "--debug");
                  }
#line 173
                  if (tmp___3) {
                    {
#line 175
                    tmp___2 = strcmp(arg, "--help");
                    }
#line 175
                    if (tmp___2) {
                      {
#line 177
                      tmp___1 = strcmp(arg, "--version");
                      }
#line 177
                      if (tmp___1) {
                        {
#line 180
                        usageerr___1("unknown long option");
                        }
                      } else {
                        {
#line 178
                        tmp = fputs((char const   */* __restrict  */)"adnsresfilter (GNU adns) 1.2\n\nCopyright (C) 1997-2000,2003,2006  Ian Jackson\nCopyright (C) 1999-2000,2003,2006  Tony Finch\nCopyright (C) 1991 Massachusetts Institute of Technology\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n",
                                    (FILE */* __restrict  */)stdout);
                        }
#line 178
                        if (tmp == -1) {
                          {
#line 178
                          perror("adnsresfilter: write version message");
#line 178
                          quitnow(-1);
                          }
                        } else {
                          {
#line 178
                          tmp___0 = fclose(stdout);
                          }
#line 178
                          if (tmp___0) {
                            {
#line 178
                            perror("adnsresfilter: write version message");
#line 178
                            quitnow(-1);
                            }
                          }
                        }
                        {
#line 178
                        quitnow(0);
#line 178
                        quitnow(0);
                        }
                      }
                    } else {
                      {
#line 176
                      usage___1();
#line 176
                      quitnow(0);
                      }
                    }
                  } else {
#line 174
                    initflags = (adns_initflags )((unsigned int )initflags | 8U);
                  }
                } else {
#line 171
                  argv ++;
#line 171
                  arg = (char const   *)*argv;
#line 171
                  if (! arg) {
                    {
#line 171
                    usageerr___1("--config needs a value");
                    }
                  }
#line 172
                  config_text___2 = arg;
                }
              } else {
#line 169
                rrt = (adns_rrtype )12;
              }
            } else {
#line 167
              address = 1;
            }
          } else {
#line 165
            bracket = 1;
          }
        } else {
#line 163
          forever = 1;
        }
      } else {
#line 159
        argv ++;
#line 159
        arg = (char const   *)*argv;
#line 159
        if (! arg) {
          {
#line 159
          usageerr___1("--timeout needs a value");
          }
        }
        {
#line 160
        settimeout(arg);
#line 161
        forever = 0;
        }
      }
    } else {
      {
#line 183
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 183
        arg ++;
#line 183
        c = (int )*arg;
#line 183
        if (! c) {
#line 183
          goto while_break___0;
        }
        {
#line 185
        if (c == 116) {
#line 185
          goto case_116;
        }
#line 192
        if (c == 119) {
#line 192
          goto case_119;
        }
#line 195
        if (c == 98) {
#line 195
          goto case_98;
        }
#line 198
        if (c == 97) {
#line 198
          goto case_97;
        }
#line 201
        if (c == 117) {
#line 201
          goto case_117;
        }
#line 204
        if (c == 104) {
#line 204
          goto case_104;
        }
#line 207
        goto switch_default;
        case_116: /* CIL Label */ 
#line 186
        arg ++;
#line 186
        if (*arg) {
          {
#line 186
          settimeout(arg);
          }
        } else {
#line 187
          argv ++;
#line 187
          arg = (char const   *)*argv;
#line 187
          if (arg) {
            {
#line 187
            settimeout(arg);
            }
          } else {
            {
#line 188
            usageerr___1("-t needs a value");
            }
          }
        }
#line 189
        forever = 0;
#line 190
        arg = "\000";
#line 191
        goto switch_break;
        case_119: /* CIL Label */ 
#line 193
        forever = 1;
#line 194
        goto switch_break;
        case_98: /* CIL Label */ 
#line 196
        bracket = 1;
#line 197
        goto switch_break;
        case_97: /* CIL Label */ 
#line 199
        address = 1;
#line 200
        goto switch_break;
        case_117: /* CIL Label */ 
#line 202
        rrt = (adns_rrtype )12;
#line 203
        goto switch_break;
        case_104: /* CIL Label */ 
        {
#line 205
        usage___1();
#line 206
        quitnow(0);
        }
        switch_default: /* CIL Label */ 
        {
#line 208
        usageerr___1("unknown short option");
        }
        switch_break: /* CIL Label */ ;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  return;
}
}
#line 215 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static void queueoutchar(int c ) 
{ 
  struct outqueuenode *entry ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 218
  entry = outqueue.tail;
#line 219
  if (! entry) {
#line 219
    goto _L;
  } else
#line 219
  if (entry->addr) {
#line 219
    goto _L;
  } else
#line 219
  if (entry->textlen >= peroutqueuenode) {
    _L: /* CIL Label */ 
#line 220
    if (! peroutqueuenode) {
#line 220
      peroutqueuenode = 128;
    } else
#line 220
    if (! entry) {
#line 220
      peroutqueuenode = 128;
    } else
#line 220
    if (entry->addr) {
#line 220
      peroutqueuenode = 128;
    } else {
#line 220
      if (peroutqueuenode >= 1024) {
#line 220
        tmp = 4096;
      } else {
#line 220
        tmp = peroutqueuenode << 2;
      }
#line 220
      peroutqueuenode = tmp;
    }
    {
#line 222
    tmp___0 = xmalloc___0(sizeof(*entry));
#line 222
    entry = (struct outqueuenode *)tmp___0;
#line 223
    entry->buffer = xmalloc___0((size_t )peroutqueuenode);
#line 224
    entry->textp = (char *)entry->buffer;
#line 225
    entry->textlen = 0;
#line 226
    entry->addr = (struct treething *)0;
    }
    {
#line 227
    while (1) {
      while_continue: /* CIL Label */ ;
#line 227
      entry->next = (struct outqueuenode *)0;
#line 227
      entry->back = outqueue.tail;
#line 227
      if (outqueue.tail) {
#line 227
        (outqueue.tail)->next = entry;
      } else {
#line 227
        outqueue.head = entry;
      }
#line 227
      outqueue.tail = entry;
#line 227
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 228
    outqueuelen ++;
  }
#line 230
  tmp___1 = entry->textlen;
#line 230
  (entry->textlen) ++;
#line 230
  *(entry->textp + tmp___1) = (char )c;
#line 231
  return;
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static void queueoutstr(char const   *str , int len ) 
{ 
  char const   *tmp ;
  int tmp___0 ;

  {
  {
#line 234
  while (1) {
    while_continue: /* CIL Label */ ;
#line 234
    tmp___0 = len;
#line 234
    len --;
#line 234
    if (! (tmp___0 > 0)) {
#line 234
      goto while_break;
    }
    {
#line 234
    tmp = str;
#line 234
    str ++;
#line 234
    queueoutchar((int )*tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 235
  return;
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static void writestdout(struct outqueuenode *entry ) 
{ 
  int r ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 240
  while (1) {
    while_continue: /* CIL Label */ ;
#line 240
    if (! entry->textlen) {
#line 240
      goto while_break;
    }
    {
#line 241
    r = Hwrite(1, (void const   *)entry->textp, (size_t )entry->textlen);
    }
#line 242
    if (r < 0) {
      {
#line 243
      tmp = __errno_location();
      }
#line 243
      if (*tmp == 4) {
#line 243
        goto while_continue;
      }
      {
#line 244
      tmp___0 = __errno_location();
      }
#line 244
      if (*tmp___0 == 11) {
#line 244
        outblocked = 1;
#line 244
        goto while_break;
      }
      {
#line 245
      sysfail___0("write stdout");
      }
    }
#line 247
    if (! (r <= entry->textlen)) {
      {
#line 247
      __assert_fail("r <= entry->textlen", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c",
                    247U, "writestdout");
      }
    }
#line 248
    entry->textp += r;
#line 249
    entry->textlen -= r;
  }
  while_break: /* CIL Label */ ;
  }
#line 251
  if (! entry->textlen) {
    {
#line 252
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 252
      if (entry->back) {
#line 252
        (entry->back)->next = entry->next;
      } else {
#line 252
        outqueue.head = entry->next;
      }
#line 252
      if (entry->next) {
#line 252
        (entry->next)->back = entry->back;
      } else {
#line 252
        outqueue.tail = entry->back;
      }
#line 252
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 253
    Hfree(entry->buffer);
#line 254
    Hfree((void *)entry);
#line 255
    outqueuelen --;
    }
  }
#line 257
  return;
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static void replacetextwithname(struct outqueuenode *entry ) 
{ 
  char *name ;
  char *newbuf ;
  int namelen ;
  int newlen ;
  size_t tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 263
  name = *(((entry->addr)->ans)->rrs.str + 0);
#line 264
  tmp = strlen((char const   *)name);
#line 264
  namelen = (int )tmp;
  }
#line 265
  if (! address) {
    {
#line 266
    Hfree(entry->buffer);
#line 267
    entry->buffer = (void *)0;
#line 268
    entry->textp = name;
#line 269
    entry->textlen = namelen;
    }
  } else {
#line 271
    if (bracket) {
#line 271
      tmp___0 = 0;
    } else {
#line 271
      tmp___0 = 2;
    }
    {
#line 271
    newlen = (entry->textlen + namelen) + tmp___0;
#line 272
    tmp___1 = xmalloc___0((size_t )(newlen + 1));
#line 272
    newbuf = (char *)tmp___1;
    }
#line 273
    if (bracket) {
#line 273
      tmp___2 = "%s%.*s";
    } else {
#line 273
      tmp___2 = "%s[%.*s]";
    }
    {
#line 273
    sprintf((char */* __restrict  */)newbuf, (char const   */* __restrict  */)tmp___2,
            name, entry->textlen, entry->textp);
#line 274
    Hfree(entry->buffer);
#line 275
    tmp___3 = newbuf;
#line 275
    entry->textp = tmp___3;
#line 275
    entry->buffer = (void *)tmp___3;
#line 276
    entry->textlen = newlen;
    }
  }
#line 278
  return;
}
}
#line 280 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static void checkadnsqueries(void) 
{ 
  adns_query qu ;
  adns_answer *ans ;
  void *context ;
  struct treething *foundthing ;
  int r ;

  {
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 288
    qu = (adns_query )0;
#line 288
    context = (void *)0;
#line 288
    ans = (adns_answer *)0;
#line 289
    r = adns_check(ads___1, & qu, & ans, & context);
    }
#line 290
    if (r == 3) {
#line 290
      goto while_break;
    } else
#line 290
    if (r == 11) {
#line 290
      goto while_break;
    }
#line 291
    if (! (! r)) {
      {
#line 291
      __assert_fail("!r", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c",
                    291U, "checkadnsqueries");
      }
    }
#line 292
    foundthing = (struct treething *)context;
#line 293
    foundthing->ans = ans;
#line 294
    foundthing->qu = (adns_query )0;
  }
  while_break: /* CIL Label */ ;
  }
#line 296
  return;
}
}
#line 298 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static void restartbuf(void) 
{ 


  {
#line 299
  if (inbuf > 0) {
    {
#line 299
    queueoutstr((char const   *)(addrtextbuf), inbuf);
    }
  }
#line 300
  inbuf = 0;
#line 301
  return;
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static int comparer(void const   *a , void const   *b ) 
{ 
  int tmp ;

  {
  {
#line 304
  tmp = memcmp(a, b, (size_t )4);
  }
#line 304
  return (tmp);
}
}
#line 307 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static void procaddr(void) 
{ 
  struct treething *foundthing ;
  void **searchfound ;
  struct outqueuenode *entry ;
  int r ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 313
  if (! newthing) {
    {
#line 314
    tmp = xmalloc___0(sizeof(struct treething ));
#line 314
    newthing = (struct treething *)tmp;
#line 315
    newthing->qu = (adns_query )0;
#line 316
    newthing->ans = (adns_answer *)0;
    }
  }
  {
#line 319
  memcpy((void */* __restrict  */)(newthing->bytes), (void const   */* __restrict  */)(bytes),
         (size_t )4);
#line 320
  tmp___0 = tsearch((void const   *)newthing, & treeroot, & comparer);
#line 320
  searchfound = (void **)tmp___0;
  }
#line 321
  if (! searchfound) {
    {
#line 321
    sysfail___0("tsearch");
    }
  }
#line 322
  foundthing = (struct treething *)*searchfound;
#line 324
  if ((unsigned long )foundthing == (unsigned long )newthing) {
    {
#line 325
    newthing = (struct treething *)0;
#line 326
    memcpy((void */* __restrict  */)(& sa.sin_addr), (void const   */* __restrict  */)(bytes),
           (size_t )4);
#line 327
    r = adns_submit_reverse(ads___1, (struct sockaddr  const  *)(& sa), rrt, (adns_queryflags )0,
                            (void *)foundthing, & foundthing->qu);
    }
#line 329
    if (r) {
      {
#line 329
      adnsfail("submit", r);
      }
    }
  }
  {
#line 331
  tmp___1 = xmalloc___0(sizeof(*entry));
#line 331
  entry = (struct outqueuenode *)tmp___1;
#line 332
  entry->buffer = xmalloc___0((size_t )inbuf);
#line 333
  entry->textp = (char *)entry->buffer;
#line 334
  memcpy((void */* __restrict  */)entry->textp, (void const   */* __restrict  */)(addrtextbuf),
         (size_t )inbuf);
#line 335
  entry->textlen = inbuf;
#line 336
  entry->addr = foundthing;
#line 337
  entry->printbefore = printbefore;
  }
  {
#line 338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 338
    entry->next = (struct outqueuenode *)0;
#line 338
    entry->back = outqueue.tail;
#line 338
    if (outqueue.tail) {
#line 338
      (outqueue.tail)->next = entry;
    } else {
#line 338
      outqueue.head = entry;
    }
#line 338
    outqueue.tail = entry;
#line 338
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 339
  outqueuelen ++;
#line 340
  inbuf = 0;
#line 341
  cbyte = -1;
#line 342
  return;
}
}
#line 344 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static void startaddr(void) 
{ 


  {
#line 345
  cbyte = 0;
#line 345
  bytes[cbyte] = (unsigned char)0;
#line 346
  inbyte = 0;
#line 347
  return;
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static void readstdin(void) 
{ 
  char readbuf[512] ;
  char *p ;
  int r ;
  int c ;
  int nbyte ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
  {
#line 353
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 353
    r = Hread(0, (void *)(readbuf), sizeof(readbuf));
    }
#line 353
    if (! (r <= 0)) {
#line 353
      goto while_break;
    }
#line 354
    if (r == 0) {
#line 354
      inputeof = 1;
#line 354
      return;
    }
#line 355
    if (r == 11) {
#line 355
      return;
    }
#line 356
    if (r != 4) {
      {
#line 356
      sysfail___0("read stdin");
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 358
  p = readbuf;
  {
#line 358
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 358
    if (! (r > 0)) {
#line 358
      goto while_break___0;
    }
#line 359
    c = (int )*p;
#line 360
    if (cbyte == -1) {
#line 360
      if (bracket) {
#line 360
        if (c == 91) {
          {
#line 361
          tmp = inbuf;
#line 361
          inbuf ++;
#line 361
          addrtextbuf[tmp] = (char )c;
#line 362
          startaddr();
          }
        } else {
#line 360
          goto _L___15;
        }
      } else {
#line 360
        goto _L___15;
      }
    } else
    _L___15: /* CIL Label */ 
#line 363
    if (cbyte == -1) {
#line 363
      if (! bracket) {
        {
#line 363
        tmp___5 = __ctype_b_loc();
        }
#line 363
        if ((int const   )*(*tmp___5 + c) & 8) {
#line 363
          goto _L___13;
        } else {
          {
#line 364
          queueoutchar(c);
#line 365
          startaddr();
          }
        }
      } else {
#line 363
        goto _L___13;
      }
    } else
    _L___13: /* CIL Label */ 
#line 366
    if (cbyte >= 0) {
#line 366
      if (inbyte < 3) {
#line 366
        if (c >= 48) {
#line 366
          if (c <= 57) {
#line 366
            nbyte = (int )bytes[cbyte] * 10 + (c - 48);
#line 366
            if (nbyte <= 255) {
#line 368
              bytes[cbyte] = (unsigned char )nbyte;
#line 369
              tmp___0 = inbuf;
#line 369
              inbuf ++;
#line 369
              addrtextbuf[tmp___0] = (char )c;
#line 370
              inbyte ++;
            } else {
#line 366
              goto _L___11;
            }
          } else {
#line 366
            goto _L___11;
          }
        } else {
#line 366
          goto _L___11;
        }
      } else {
#line 366
        goto _L___11;
      }
    } else
    _L___11: /* CIL Label */ 
#line 371
    if (cbyte >= 0) {
#line 371
      if (cbyte < 3) {
#line 371
        if (inbyte > 0) {
#line 371
          if (c == 46) {
#line 372
            cbyte ++;
#line 372
            bytes[cbyte] = (unsigned char)0;
#line 373
            tmp___1 = inbuf;
#line 373
            inbuf ++;
#line 373
            addrtextbuf[tmp___1] = (char )c;
#line 374
            inbyte = 0;
          } else {
#line 371
            goto _L___7;
          }
        } else {
#line 371
          goto _L___7;
        }
      } else {
#line 371
        goto _L___7;
      }
    } else
    _L___7: /* CIL Label */ 
#line 375
    if (cbyte == 3) {
#line 375
      if (inbyte > 0) {
#line 375
        if (bracket) {
#line 375
          if (c == 93) {
            {
#line 376
            tmp___2 = inbuf;
#line 376
            inbuf ++;
#line 376
            addrtextbuf[tmp___2] = (char )c;
#line 377
            procaddr();
            }
          } else {
#line 375
            goto _L___4;
          }
        } else {
#line 375
          goto _L___4;
        }
      } else {
#line 375
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 378
    if (cbyte == 3) {
#line 378
      if (inbyte > 0) {
#line 378
        if (! bracket) {
          {
#line 378
          tmp___4 = __ctype_b_loc();
          }
#line 378
          if ((int const   )*(*tmp___4 + c) & 8) {
#line 378
            goto _L___1;
          } else {
            {
#line 379
            procaddr();
#line 380
            queueoutchar(c);
#line 381
            startaddr();
            }
          }
        } else {
#line 378
          goto _L___1;
        }
      } else {
#line 378
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 383
      restartbuf();
#line 384
      queueoutchar(c);
#line 385
      cbyte = -1;
      }
#line 386
      if (! bracket) {
        {
#line 386
        tmp___3 = __ctype_b_loc();
        }
#line 386
        if (! ((int const   )*(*tmp___3 + c) & 8)) {
          {
#line 386
          startaddr();
          }
        }
      }
    }
#line 358
    r --;
#line 358
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 389
  return;
}
}
#line 391 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static void startup(void) 
{ 
  int r ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 394
  tmp = nonblock(0, 1);
  }
#line 394
  if (tmp) {
    {
#line 394
    sysfail___0("set stdin to nonblocking mode");
    }
  }
  {
#line 395
  tmp___0 = nonblock(1, 1);
  }
#line 395
  if (tmp___0) {
    {
#line 395
    sysfail___0("set stdout to nonblocking mode");
    }
  }
  {
#line 396
  memset((void *)(& sa), 0, sizeof(sa));
#line 397
  sa.sin_family = (sa_family_t )2;
  }
#line 398
  if (config_text___2) {
    {
#line 399
    r = adns_init_strcfg(& ads___1, initflags, stderr, config_text___2);
    }
  } else {
    {
#line 401
    r = adns_init(& ads___1, initflags, (FILE *)0);
    }
  }
#line 403
  if (r) {
    {
#line 403
    adnsfail("init", r);
    }
  }
#line 404
  cbyte = -1;
#line 405
  inbyte = -1;
#line 406
  inbuf = 0;
#line 407
  if (! bracket) {
    {
#line 407
    startaddr();
    }
  }
#line 408
  return;
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfig___3(adns_state ads___7 , char const   *filename , int warnmissing ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void addserver___3(adns_state ads___7 , struct in_addr addr ) 
{ 
  int i ;
  struct server *ss ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 48
  i = 0;
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (i < ads___7->nservers)) {
#line 48
      goto while_break;
    }
#line 49
    if (ads___7->servers[i].addr.s_addr == addr.s_addr) {
      {
#line 50
      tmp = inet_ntoa(addr);
#line 50
      adns__debug(ads___7, -1, (adns_query )0, "duplicate nameserver %s ignored",
                  tmp);
      }
#line 51
      return;
    }
#line 48
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  if (ads___7->nservers >= 5) {
    {
#line 56
    tmp___0 = inet_ntoa(addr);
#line 56
    adns__diag(ads___7, -1, (adns_query )0, "too many nameservers, ignoring %s", tmp___0);
    }
#line 57
    return;
  }
#line 60
  ss = ads___7->servers + ads___7->nservers;
#line 61
  ss->addr = addr;
#line 62
  (ads___7->nservers) ++;
#line 63
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void freesearchlist___3(adns_state ads___7 ) 
{ 


  {
#line 66
  if (ads___7->nsearchlist) {
    {
#line 66
    Hfree((void *)*(ads___7->searchlist));
    }
  }
  {
#line 67
  Hfree((void *)ads___7->searchlist);
  }
#line 68
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void saveerr___3(adns_state ads___7 , int en ) 
{ 


  {
#line 71
  if (! ads___7->configerrno) {
#line 71
    ads___7->configerrno = en;
  }
#line 72
  return;
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void configparseerr___3(adns_state ads___7 , char const   *fn , int lno , char const   *fmt 
                               , ...) 
{ 
  va_list al ;

  {
  {
#line 78
  saveerr___3(ads___7, 22);
  }
#line 79
  if (! ads___7->logfn) {
#line 79
    return;
  } else
#line 79
  if ((unsigned int )ads___7->iflags & 2U) {
#line 79
    return;
  }
#line 81
  if (lno == -1) {
    {
#line 81
    adns__lprintf(ads___7, "adns: %s: ", fn);
    }
  } else {
    {
#line 82
    adns__lprintf(ads___7, "adns: %s:%d: ", fn, lno);
    }
  }
  {
#line 83
  __builtin_va_start(al, fmt);
#line 84
  adns__vlprintf(ads___7, fmt, al);
#line 85
  __builtin_va_end(al);
#line 86
  adns__lprintf(ads___7, "\n");
  }
#line 87
  return;
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int nextword___3(char const   **bufp_io , char const   **word_r , int *l_r ) 
{ 
  char const   *p ;
  char const   *q ;
  int tmp ;
  int tmp___0 ;

  {
#line 92
  p = *bufp_io;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 93
    tmp = ctype_whitespace((int )*p);
    }
#line 93
    if (! tmp) {
#line 93
      goto while_break;
    }
#line 93
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  if (! *p) {
#line 94
    return (0);
  }
#line 96
  q = p;
  {
#line 97
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 97
    if (*q) {
      {
#line 97
      tmp___0 = ctype_whitespace((int )*q);
      }
#line 97
      if (tmp___0) {
#line 97
        goto while_break___0;
      }
    } else {
#line 97
      goto while_break___0;
    }
#line 97
    q ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 99
  *l_r = (int )(q - p);
#line 100
  *word_r = p;
#line 101
  *bufp_io = q;
#line 103
  return (1);
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_nameserver___3(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  struct in_addr ia ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 110
  tmp = inet_aton(buf___17, & ia);
  }
#line 110
  if (! tmp) {
    {
#line 111
    configparseerr___3(ads___7, fn, lno, "invalid nameserver address `%s\'", buf___17);
    }
#line 112
    return;
  }
  {
#line 114
  tmp___0 = inet_ntoa(ia);
#line 114
  adns__debug(ads___7, -1, (adns_query )0, "using nameserver %s", tmp___0);
#line 115
  addserver___3(ads___7, ia);
  }
#line 116
  return;
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_search___3(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  char const   *bufp ;
  char const   *word ;
  char *newchars ;
  char **newptrs ;
  char **pp ;
  int count ;
  int tl ;
  int l ;
  int tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char **tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
#line 124
  if (! buf___17) {
#line 124
    return;
  }
#line 126
  bufp = buf___17;
#line 127
  count = 0;
#line 128
  tl = 0;
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 129
    tmp = nextword___3(& bufp, & word, & l);
    }
#line 129
    if (! tmp) {
#line 129
      goto while_break;
    }
#line 129
    count ++;
#line 129
    tl += l + 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 131
  tmp___0 = Hmalloc(sizeof(char *) * (unsigned long )count);
#line 131
  newptrs = (char **)tmp___0;
  }
#line 132
  if (! newptrs) {
    {
#line 132
    tmp___1 = __errno_location();
#line 132
    saveerr___3(ads___7, *tmp___1);
    }
#line 132
    return;
  }
  {
#line 134
  tmp___2 = Hmalloc((size_t )tl);
#line 134
  newchars = (char *)tmp___2;
  }
#line 135
  if (! newchars) {
    {
#line 135
    tmp___3 = __errno_location();
#line 135
    saveerr___3(ads___7, *tmp___3);
#line 135
    Hfree((void *)newptrs);
    }
#line 135
    return;
  }
#line 137
  bufp = buf___17;
#line 138
  pp = newptrs;
  {
#line 139
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 139
    tmp___6 = nextword___3(& bufp, & word, & l);
    }
#line 139
    if (! tmp___6) {
#line 139
      goto while_break___0;
    }
    {
#line 140
    tmp___4 = pp;
#line 140
    pp ++;
#line 140
    *tmp___4 = newchars;
#line 141
    memcpy((void */* __restrict  */)newchars, (void const   */* __restrict  */)word,
           (size_t )l);
#line 142
    newchars += l;
#line 143
    tmp___5 = newchars;
#line 143
    newchars ++;
#line 143
    *tmp___5 = (char)0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 146
  freesearchlist___3(ads___7);
#line 147
  ads___7->nsearchlist = count;
#line 148
  ads___7->searchlist = newptrs;
  }
#line 149
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_sortlist___3(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  char const   *word ;
  char tbuf[200] ;
  char *slash ;
  char *ep ;
  struct in_addr base ;
  struct in_addr mask ;
  int l ;
  unsigned long initial ;
  unsigned long baselocal ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  uint32_t tmp___3 ;
  int tmp___4 ;

  {
#line 159
  if (! buf___17) {
#line 159
    return;
  }
#line 161
  ads___7->nsortlist = 0;
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 162
    tmp___4 = nextword___3(& buf___17, & word, & l);
    }
#line 162
    if (! tmp___4) {
#line 162
      goto while_break;
    }
#line 163
    if (ads___7->nsortlist >= 15) {
      {
#line 164
      adns__diag(ads___7, -1, (adns_query )0, "too many sortlist entries, ignoring %.*s onwards",
                 l, word);
      }
#line 166
      return;
    }
#line 169
    if ((unsigned long )l >= sizeof(tbuf)) {
      {
#line 170
      configparseerr___3(ads___7, fn, lno, "sortlist entry `%.*s\' too long", l, word);
      }
#line 171
      goto while_continue;
    }
    {
#line 174
    memcpy((void */* __restrict  */)(tbuf), (void const   */* __restrict  */)word,
           (size_t )l);
#line 174
    tbuf[l] = (char)0;
#line 175
    slash = strchr((char const   *)(tbuf), '/');
    }
#line 176
    if (slash) {
#line 176
      tmp = slash;
#line 176
      slash ++;
#line 176
      *tmp = (char)0;
    }
    {
#line 178
    tmp___0 = inet_aton((char const   *)(tbuf), & base);
    }
#line 178
    if (! tmp___0) {
      {
#line 179
      configparseerr___3(ads___7, fn, lno, "invalid address `%s\' in sortlist", tbuf);
      }
#line 180
      goto while_continue;
    }
#line 183
    if (slash) {
      {
#line 184
      tmp___2 = strchr((char const   *)slash, '.');
      }
#line 184
      if (tmp___2) {
        {
#line 185
        tmp___1 = inet_aton((char const   *)slash, & mask);
        }
#line 185
        if (! tmp___1) {
          {
#line 186
          configparseerr___3(ads___7, fn, lno, "invalid mask `%s\' in sortlist", slash);
          }
#line 187
          goto while_continue;
        }
#line 189
        if (base.s_addr & ~ mask.s_addr) {
          {
#line 190
          configparseerr___3(ads___7, fn, lno, "mask `%s\' in sortlist overlaps address `%s\'",
                             slash, tbuf);
          }
#line 192
          goto while_continue;
        }
      } else {
        {
#line 195
        initial = strtoul((char const   */* __restrict  */)slash, (char **/* __restrict  */)(& ep),
                          10);
        }
#line 196
        if (*ep) {
          {
#line 197
          configparseerr___3(ads___7, fn, lno, "mask length `%s\' invalid", slash);
          }
#line 198
          goto while_continue;
        } else
#line 196
        if (initial > 32UL) {
          {
#line 197
          configparseerr___3(ads___7, fn, lno, "mask length `%s\' invalid", slash);
          }
#line 198
          goto while_continue;
        }
        {
#line 200
        mask.s_addr = htonl((uint32_t )(4294967295UL << (32UL - initial)));
        }
      }
    } else {
      {
#line 203
      tmp___3 = ntohl(base.s_addr);
#line 203
      baselocal = (unsigned long )tmp___3;
      }
#line 204
      if ((unsigned long )(! baselocal) & 2147483648UL) {
        {
#line 205
        mask.s_addr = htonl((uint32_t )4278190080UL);
        }
      } else
#line 206
      if ((baselocal & 3221225472UL) == 2147483648UL) {
        {
#line 207
        mask.s_addr = htonl((uint32_t )4294901760UL);
        }
      } else
#line 208
      if ((baselocal & 4026531840UL) == 3758096384UL) {
        {
#line 209
        mask.s_addr = htonl((uint32_t )4278190080UL);
        }
      } else {
        {
#line 211
        configparseerr___3(ads___7, fn, lno, "network address `%s\' in sortlist is not in classed ranges, must specify mask explicitly",
                           tbuf);
        }
#line 214
        goto while_continue;
      }
    }
#line 218
    ads___7->sortlist[ads___7->nsortlist].base = base;
#line 219
    ads___7->sortlist[ads___7->nsortlist].mask = mask;
#line 220
    (ads___7->nsortlist) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  return;
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_options___3(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  char const   *word ;
  char *ep ;
  unsigned long v ;
  int l ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 231
  if (! buf___17) {
#line 231
    return;
  }
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 233
    tmp___5 = nextword___3(& buf___17, & word, & l);
    }
#line 233
    if (! tmp___5) {
#line 233
      goto while_break;
    }
#line 234
    if (l == 5) {
      {
#line 234
      tmp = memcmp((void const   *)word, (void const   *)"debug", (size_t )5);
      }
#line 234
      if (! tmp) {
#line 235
        ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 8U);
#line 236
        goto while_continue;
      }
    }
#line 238
    if (l >= 6) {
      {
#line 238
      tmp___0 = memcmp((void const   *)word, (void const   *)"ndots:", (size_t )6);
      }
#line 238
      if (! tmp___0) {
        {
#line 239
        v = strtoul((char const   */* __restrict  */)(word + 6), (char **/* __restrict  */)(& ep),
                    10);
        }
#line 240
        if (l == 6) {
          {
#line 241
          configparseerr___3(ads___7, fn, lno, "option `%.*s\' malformed or has bad value",
                             l, word);
          }
#line 243
          goto while_continue;
        } else
#line 240
        if ((unsigned long )ep != (unsigned long )(word + l)) {
          {
#line 241
          configparseerr___3(ads___7, fn, lno, "option `%.*s\' malformed or has bad value",
                             l, word);
          }
#line 243
          goto while_continue;
        } else
#line 240
        if (v > 2147483647UL) {
          {
#line 241
          configparseerr___3(ads___7, fn, lno, "option `%.*s\' malformed or has bad value",
                             l, word);
          }
#line 243
          goto while_continue;
        }
#line 245
        ads___7->searchndots = (int )v;
#line 246
        goto while_continue;
      }
    }
#line 248
    if (l >= 12) {
      {
#line 248
      tmp___4 = memcmp((void const   *)word, (void const   *)"adns_checkc:", (size_t )12);
      }
#line 248
      if (! tmp___4) {
        {
#line 249
        tmp___3 = strcmp(word + 12, "none");
        }
#line 249
        if (tmp___3) {
          {
#line 252
          tmp___2 = strcmp(word + 12, "entex");
          }
#line 252
          if (tmp___2) {
            {
#line 255
            tmp___1 = strcmp(word + 12, "freq");
            }
#line 255
            if (tmp___1) {
              {
#line 258
              configparseerr___3(ads___7, fn, lno, "option adns_checkc has bad value `%s\' (must be none, entex or freq",
                                 word + 12);
              }
            } else {
#line 256
              ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 768U);
            }
          } else {
#line 253
            ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags & 4294966527U);
#line 254
            ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 256U);
          }
        } else {
#line 250
          ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags & 4294966527U);
#line 251
          ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 256U);
        }
#line 261
        goto while_continue;
      }
    }
    {
#line 263
    adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown option `%.*s\'", fn, lno,
               l, word);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 265
  return;
}
}
#line 267 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_clearnss___3(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 


  {
#line 269
  ads___7->nservers = 0;
#line 270
  return;
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_include___3(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 


  {
#line 274
  if (! *buf___17) {
    {
#line 275
    configparseerr___3(ads___7, fn, lno, "`include\' directive with no filename");
    }
#line 276
    return;
  }
  {
#line 278
  readconfig___3(ads___7, buf___17, 1);
  }
#line 279
  return;
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_lookup___3(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  int found_bind ;
  char const   *word ;
  int l ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 283
  found_bind = 0;
#line 287
  if (! *buf___17) {
    {
#line 288
    configparseerr___3(ads___7, fn, lno, "`lookup\' directive with no databases");
    }
#line 289
    return;
  }
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 292
    tmp___2 = nextword___3(& buf___17, & word, & l);
    }
#line 292
    if (! tmp___2) {
#line 292
      goto while_break;
    }
#line 293
    if (l == 4) {
      {
#line 293
      tmp___1 = memcmp((void const   *)word, (void const   *)"bind", (size_t )4);
      }
#line 293
      if (tmp___1) {
#line 293
        goto _L___0;
      } else {
#line 294
        found_bind = 1;
      }
    } else
    _L___0: /* CIL Label */ 
#line 295
    if (l == 4) {
      {
#line 295
      tmp___0 = memcmp((void const   *)word, (void const   *)"file", (size_t )4);
      }
#line 295
      if (tmp___0) {
#line 295
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 297
    if (l == 2) {
      {
#line 297
      tmp = memcmp((void const   *)word, (void const   *)"yp", (size_t )2);
      }
#line 297
      if (tmp) {
        {
#line 301
        adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown `lookup\' database `%.*s\'",
                   fn, lno, l, word);
#line 303
        found_bind = -1;
        }
      } else {
        {
#line 298
        adns__diag(ads___7, -1, (adns_query )0, "%s:%d: yp lookups not supported by adns",
                   fn, lno);
#line 299
        found_bind = -1;
        }
      }
    } else {
      {
#line 301
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown `lookup\' database `%.*s\'",
                 fn, lno, l, word);
#line 303
      found_bind = -1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 306
  if (! found_bind) {
    {
#line 307
    adns__diag(ads___7, -1, (adns_query )0, "%s:%d: `lookup\' specified, but not `bind\'",
               fn, lno);
    }
  }
#line 308
  return;
}
}
#line 310 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static struct configcommandinfo  const  configcommandinfos___3[9]  = 
#line 310
  {      {"nameserver", & ccf_nameserver___3}, 
        {"domain", & ccf_search___3}, 
        {"search", & ccf_search___3}, 
        {"sortlist", & ccf_sortlist___3}, 
        {"options", & ccf_options___3}, 
        {"clearnameservers", & ccf_clearnss___3}, 
        {"include", & ccf_include___3}, 
        {"lookup", & ccf_lookup___3}, 
        {(char const   *)0, (void (*)(adns_state ads , char const   *fn , int lno , char const   *buf ))0}};
#line 330 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int gl_file___3(adns_state ads___7 , getline_ctx *src_io , char const   *filename ,
                       int lno , char *buf___17 , int buflen ) 
{ 
  FILE *file ;
  int c ;
  int i ;
  char *p ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 332
  file = src_io->file;
#line 336
  p = buf___17;
#line 337
  buflen --;
#line 338
  i = 0;
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (i == buflen) {
      {
#line 342
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: line too long, ignored", filename,
                 lno);
      }
#line 343
      goto x_badline;
    }
    {
#line 345
    c = _IO_getc(file);
    }
#line 346
    if (! c) {
      {
#line 347
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: line contains nul, ignored",
                 filename, lno);
      }
#line 348
      goto x_badline;
    } else
#line 349
    if (c == 10) {
#line 350
      goto while_break;
    } else
#line 351
    if (c == -1) {
      {
#line 352
      tmp___2 = ferror(file);
      }
#line 352
      if (tmp___2) {
        {
#line 353
        tmp = __errno_location();
#line 353
        saveerr___3(ads___7, *tmp);
#line 354
        tmp___0 = __errno_location();
#line 354
        tmp___1 = strerror(*tmp___0);
#line 354
        adns__diag(ads___7, -1, (adns_query )0, "%s:%d: read error: %s", filename,
                   lno, tmp___1);
        }
#line 356
        return (-1);
      }
#line 358
      if (! i) {
#line 358
        return (-1);
      }
#line 359
      goto while_break;
    } else {
#line 361
      tmp___3 = p;
#line 361
      p ++;
#line 361
      *tmp___3 = (char )c;
#line 362
      i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 366
  tmp___4 = p;
#line 366
  p ++;
#line 366
  *tmp___4 = (char)0;
#line 367
  return (i);
  x_badline: 
  {
#line 370
  saveerr___3(ads___7, 22);
  }
  {
#line 371
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 371
    c = _IO_getc(file);
    }
#line 371
    if (c != -1) {
#line 371
      if (! (c != 10)) {
#line 371
        goto while_break___0;
      }
    } else {
#line 371
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 372
  return (-2);
}
}
#line 375 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int gl_text___3(adns_state ads___7 , getline_ctx *src_io , char const   *filename ,
                       int lno , char *buf___17 , int buflen ) 
{ 
  char const   *cp ;
  int l ;
  size_t tmp ;

  {
#line 377
  cp = src_io->text;
#line 380
  if (! cp) {
#line 380
    return (-1);
  } else
#line 380
  if (! *cp) {
#line 380
    return (-1);
  }
#line 382
  if ((int const   )*cp == 59) {
#line 382
    cp ++;
  } else
#line 382
  if ((int const   )*cp == 10) {
#line 382
    cp ++;
  }
  {
#line 383
  tmp = strcspn(cp, ";\n");
#line 383
  l = (int )tmp;
#line 384
  src_io->text = cp + l;
  }
#line 386
  if (l >= buflen) {
    {
#line 387
    adns__diag(ads___7, -1, (adns_query )0, "%s:%d: line too long, ignored", filename,
               lno);
#line 388
    saveerr___3(ads___7, 22);
    }
#line 389
    return (-2);
  }
  {
#line 392
  memcpy((void */* __restrict  */)buf___17, (void const   */* __restrict  */)cp, (size_t )l);
#line 393
  *(buf___17 + l) = (char)0;
  }
#line 394
  return (l);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfiggeneric___3(adns_state ads___7 , char const   *filename , int (*getline___0)(adns_state ads ,
                                                                                                   getline_ctx * ,
                                                                                                   char const   *filename ,
                                                                                                   int lno ,
                                                                                                   char *buf ,
                                                                                                   int buflen ) ,
                                  getline_ctx gl_ctx ) 
{ 
  char linebuf[2000] ;
  char *p ;
  char *q ;
  int lno ;
  int l ;
  int dirl ;
  struct configcommandinfo  const  *ccip ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 410
  lno = 1;
  {
#line 410
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 410
    l = (*getline___0)(ads___7, & gl_ctx, filename, lno, linebuf, (int )sizeof(linebuf));
    }
#line 410
    if (! (l != -1)) {
#line 410
      goto while_break;
    }
#line 413
    if (l == -2) {
#line 413
      goto __Cont;
    }
    {
#line 414
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 414
      if (l > 0) {
        {
#line 414
        tmp = ctype_whitespace((int )linebuf[l - 1]);
        }
#line 414
        if (! tmp) {
#line 414
          goto while_break___0;
        }
      } else {
#line 414
        goto while_break___0;
      }
#line 414
      l --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 415
    linebuf[l] = (char)0;
#line 416
    p = linebuf;
    {
#line 417
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 417
      tmp___0 = ctype_whitespace((int )*p);
      }
#line 417
      if (! tmp___0) {
#line 417
        goto while_break___1;
      }
#line 417
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 418
    if ((int )*p == 35) {
#line 418
      goto __Cont;
    } else
#line 418
    if ((int )*p == 59) {
#line 418
      goto __Cont;
    } else
#line 418
    if (! *p) {
#line 418
      goto __Cont;
    }
#line 419
    q = p;
    {
#line 420
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 420
      if (*q) {
        {
#line 420
        tmp___1 = ctype_whitespace((int )*q);
        }
#line 420
        if (tmp___1) {
#line 420
          goto while_break___2;
        }
      } else {
#line 420
        goto while_break___2;
      }
#line 420
      q ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 421
    dirl = (int )(q - p);
#line 422
    ccip = configcommandinfos___3;
    {
#line 422
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 422
      if (ccip->name) {
        {
#line 422
        tmp___2 = strlen((char const   *)ccip->name);
        }
#line 422
        if (tmp___2 == (size_t )dirl) {
          {
#line 422
          tmp___3 = memcmp((void const   *)ccip->name, (void const   *)p, (size_t )(q - p));
          }
#line 422
          if (! tmp___3) {
#line 422
            goto while_break___3;
          }
        }
      } else {
#line 422
        goto while_break___3;
      }
#line 422
      ccip ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 426
    if (! ccip->name) {
      {
#line 427
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown configuration directive `%.*s\'",
                 filename, lno, (int )(q - p), p);
      }
#line 429
      goto __Cont;
    }
    {
#line 431
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 431
      tmp___4 = ctype_whitespace((int )*q);
      }
#line 431
      if (! tmp___4) {
#line 431
        goto while_break___4;
      }
#line 431
      q ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 432
    (*(ccip->fn))(ads___7, filename, lno, (char const   *)q);
    }
    __Cont: /* CIL Label */ 
#line 410
    lno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 434
  return;
}
}
#line 436 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static char const   *instrum_getenv___3(adns_state ads___7 , char const   *envvar ) 
{ 
  char const   *value ;
  char *tmp ;

  {
  {
#line 439
  tmp = getenv(envvar);
#line 439
  value = (char const   *)tmp;
  }
#line 440
  if (! value) {
    {
#line 440
    adns__debug(ads___7, -1, (adns_query )0, "environment variable %s not set", envvar);
    }
  } else {
    {
#line 441
    adns__debug(ads___7, -1, (adns_query )0, "environment variable %s set to `%s\'",
                envvar, value);
    }
  }
#line 443
  return (value);
}
}
#line 446 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfig___3(adns_state ads___7 , char const   *filename , int warnmissing ) 
{ 
  getline_ctx gl_ctx ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 449
  gl_ctx.file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 450
  if (! gl_ctx.file) {
    {
#line 451
    tmp = __errno_location();
    }
#line 451
    if (*tmp == 2) {
#line 452
      if (warnmissing) {
        {
#line 453
        adns__debug(ads___7, -1, (adns_query )0, "configuration file `%s\' does not exist",
                    filename);
        }
      }
#line 455
      return;
    }
    {
#line 457
    tmp___0 = __errno_location();
#line 457
    saveerr___3(ads___7, *tmp___0);
#line 458
    tmp___1 = __errno_location();
#line 458
    tmp___2 = strerror(*tmp___1);
#line 458
    adns__diag(ads___7, -1, (adns_query )0, "cannot open configuration file `%s\': %s",
               filename, tmp___2);
    }
#line 460
    return;
  }
  {
#line 463
  readconfiggeneric___3(ads___7, filename, & gl_file___3, gl_ctx);
#line 465
  fclose(gl_ctx.file);
  }
#line 466
  return;
}
}
#line 468 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfigtext___3(adns_state ads___7 , char const   *text , char const   *showname ) 
{ 
  getline_ctx gl_ctx ;

  {
  {
#line 472
  gl_ctx.text = text;
#line 473
  readconfiggeneric___3(ads___7, showname, & gl_text___3, gl_ctx);
  }
#line 474
  return;
}
}
#line 476 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfigenv___3(adns_state ads___7 , char const   *envvar ) 
{ 
  char const   *filename ;

  {
#line 479
  if ((unsigned int )ads___7->iflags & 1U) {
    {
#line 480
    adns__debug(ads___7, -1, (adns_query )0, "not checking environment variable `%s\'",
                envvar);
    }
#line 481
    return;
  }
  {
#line 483
  filename = instrum_getenv___3(ads___7, envvar);
  }
#line 484
  if (filename) {
    {
#line 484
    readconfig___3(ads___7, filename, 1);
    }
  }
#line 485
  return;
}
}
#line 487 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfigenvtext___3(adns_state ads___7 , char const   *envvar ) 
{ 
  char const   *textdata ;

  {
#line 490
  if ((unsigned int )ads___7->iflags & 1U) {
    {
#line 491
    adns__debug(ads___7, -1, (adns_query )0, "not checking environment variable `%s\'",
                envvar);
    }
#line 492
    return;
  }
  {
#line 494
  textdata = instrum_getenv___3(ads___7, envvar);
  }
#line 495
  if (textdata) {
    {
#line 495
    readconfigtext___3(ads___7, textdata, envvar);
    }
  }
#line 496
  return;
}
}
#line 508 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int init_begin___3(adns_state *ads_r , adns_initflags flags , adns_logcallbackfn *logfn ,
                          void *logfndata ) 
{ 
  adns_state ads___7 ;
  pid_t pid ;
  void *tmp ;
  int *tmp___0 ;
  adns_query tmp___1 ;
  adns_query tmp___2 ;
  adns_query tmp___3 ;
  adns_query tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __suseconds_t tmp___9 ;

  {
  {
#line 513
  tmp = Hmalloc(sizeof(*ads___7));
#line 513
  ads___7 = (adns_state )tmp;
  }
#line 513
  if (! ads___7) {
    {
#line 513
    tmp___0 = __errno_location();
    }
#line 513
    return (*tmp___0);
  }
  {
#line 515
  ads___7->iflags = flags;
#line 516
  ads___7->logfn = logfn;
#line 517
  ads___7->logfndata = logfndata;
#line 518
  ads___7->configerrno = 0;
#line 519
  tmp___1 = (adns_query )0;
#line 519
  ads___7->udpw.tail = tmp___1;
#line 519
  ads___7->udpw.head = tmp___1;
#line 520
  tmp___2 = (adns_query )0;
#line 520
  ads___7->tcpw.tail = tmp___2;
#line 520
  ads___7->tcpw.head = tmp___2;
#line 521
  tmp___3 = (adns_query )0;
#line 521
  ads___7->childw.tail = tmp___3;
#line 521
  ads___7->childw.head = tmp___3;
#line 522
  tmp___4 = (adns_query )0;
#line 522
  ads___7->output.tail = tmp___4;
#line 522
  ads___7->output.head = tmp___4;
#line 523
  ads___7->forallnext = (adns_query )0;
#line 524
  ads___7->nextid = 12575;
#line 525
  tmp___5 = -1;
#line 525
  ads___7->tcpsocket = tmp___5;
#line 525
  ads___7->udpsocket = tmp___5;
#line 526
  adns__vbuf_init(& ads___7->tcpsend);
#line 527
  adns__vbuf_init(& ads___7->tcprecv);
#line 528
  ads___7->tcprecv_skip = 0;
#line 529
  tmp___8 = 0;
#line 529
  ads___7->tcpserver = tmp___8;
#line 529
  tmp___7 = tmp___8;
#line 529
  ads___7->nsearchlist = tmp___7;
#line 529
  tmp___6 = tmp___7;
#line 529
  ads___7->nsortlist = tmp___6;
#line 529
  ads___7->nservers = tmp___6;
#line 530
  ads___7->searchndots = 1;
#line 531
  ads___7->tcpstate = (enum adns__tcpstate )0;
#line 532
  tmp___9 = (__suseconds_t )0;
#line 532
  ads___7->tcptimeout.tv_usec = tmp___9;
#line 532
  ads___7->tcptimeout.tv_sec = tmp___9;
#line 533
  ads___7->searchlist = (char **)0;
#line 535
  pid = Hgetpid();
#line 536
  ads___7->rand48xsubi[0] = (unsigned short )pid;
#line 537
  ads___7->rand48xsubi[1] = (unsigned short )((unsigned long )pid >> 16);
#line 538
  ads___7->rand48xsubi[2] = (unsigned short )((unsigned long )pid ^ ((unsigned long )pid >> 16));
#line 540
  *ads_r = ads___7;
  }
#line 541
  return (0);
}
}
#line 544 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int init_finish___3(adns_state ads___7 ) 
{ 
  struct in_addr ia ;
  struct protoent *proto ;
  int r ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 549
  if (! ads___7->nservers) {
#line 550
    if (ads___7->logfn) {
#line 550
      if ((unsigned int )ads___7->iflags & 8U) {
        {
#line 551
        adns__lprintf(ads___7, "adns: no nameservers, using localhost\n");
        }
      }
    }
    {
#line 552
    ia.s_addr = htonl((in_addr_t )2130706433);
#line 553
    addserver___3(ads___7, ia);
    }
  }
  {
#line 556
  proto = getprotobyname("udp");
  }
#line 556
  if (! proto) {
#line 556
    r = 92;
#line 556
    goto x_free;
  }
  {
#line 557
  ads___7->udpsocket = Hsocket(2, 2, proto->p_proto);
  }
#line 558
  if (ads___7->udpsocket < 0) {
    {
#line 558
    tmp = __errno_location();
#line 558
    r = *tmp;
    }
#line 558
    goto x_free;
  }
  {
#line 560
  r = adns__setnonblock(ads___7, ads___7->udpsocket);
  }
#line 561
  if (r) {
    {
#line 561
    tmp___0 = __errno_location();
#line 561
    r = *tmp___0;
    }
#line 561
    goto x_closeudp;
  }
#line 563
  return (0);
  x_closeudp: 
  {
#line 566
  Hclose(ads___7->udpsocket);
  }
  x_free: 
  {
#line 568
  Hfree((void *)ads___7);
  }
#line 569
  return (r);
}
}
#line 572 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void init_abort___3(adns_state ads___7 ) 
{ 


  {
#line 573
  if (ads___7->nsearchlist) {
    {
#line 574
    Hfree((void *)*(ads___7->searchlist + 0));
#line 575
    Hfree((void *)ads___7->searchlist);
    }
  }
  {
#line 577
  Hfree((void *)ads___7);
  }
#line 578
  return;
}
}
#line 580 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void logfn_file___3(adns_state ads___7 , void *logfndata , char const   *fmt ,
                           va_list al ) 
{ 


  {
  {
#line 582
  vfprintf((FILE */* __restrict  */)logfndata, (char const   */* __restrict  */)fmt,
           al);
  }
#line 583
  return;
}
}
#line 585 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int init_files___3(adns_state *ads_r , adns_initflags flags , adns_logcallbackfn *logfn ,
                          void *logfndata ) 
{ 
  adns_state ads___7 ;
  char const   *res_options ;
  char const   *adns_res_options ;
  int r ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 591
  r = init_begin___3(& ads___7, flags, logfn, logfndata);
  }
#line 592
  if (r) {
#line 592
    return (r);
  }
  {
#line 594
  res_options = instrum_getenv___3(ads___7, "RES_OPTIONS");
#line 595
  adns_res_options = instrum_getenv___3(ads___7, "ADNS_RES_OPTIONS");
#line 596
  ccf_options___3(ads___7, "RES_OPTIONS", -1, res_options);
#line 597
  ccf_options___3(ads___7, "ADNS_RES_OPTIONS", -1, adns_res_options);
#line 599
  readconfig___3(ads___7, "/etc/resolv.conf", 1);
#line 600
  readconfig___3(ads___7, "/etc/resolv-adns.conf", 0);
#line 601
  readconfigenv___3(ads___7, "RES_CONF");
#line 602
  readconfigenv___3(ads___7, "ADNS_RES_CONF");
#line 604
  readconfigenvtext___3(ads___7, "RES_CONF_TEXT");
#line 605
  readconfigenvtext___3(ads___7, "ADNS_RES_CONF_TEXT");
#line 607
  ccf_options___3(ads___7, "RES_OPTIONS", -1, res_options);
#line 608
  ccf_options___3(ads___7, "ADNS_RES_OPTIONS", -1, adns_res_options);
#line 610
  tmp = instrum_getenv___3(ads___7, "LOCALDOMAIN");
#line 610
  ccf_search___3(ads___7, "LOCALDOMAIN", -1, tmp);
#line 611
  tmp___0 = instrum_getenv___3(ads___7, "ADNS_LOCALDOMAIN");
#line 611
  ccf_search___3(ads___7, "ADNS_LOCALDOMAIN", -1, tmp___0);
  }
#line 613
  if (ads___7->configerrno) {
#line 613
    if (ads___7->configerrno != 22) {
      {
#line 614
      r = ads___7->configerrno;
#line 615
      init_abort___3(ads___7);
      }
#line 616
      return (r);
    }
  }
  {
#line 619
  r = init_finish___3(ads___7);
  }
#line 620
  if (r) {
#line 620
    return (r);
  }
  {
#line 622
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
#line 623
  *ads_r = ads___7;
  }
#line 624
  return (0);
}
}
#line 631 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int init_strcfg___3(adns_state *ads_r , adns_initflags flags , adns_logcallbackfn *logfn ,
                           void *logfndata , char const   *configtext ) 
{ 
  adns_state ads___7 ;
  int r ;

  {
  {
#line 637
  r = init_begin___3(& ads___7, flags, logfn, logfndata);
  }
#line 638
  if (r) {
#line 638
    return (r);
  }
  {
#line 640
  readconfigtext___3(ads___7, configtext, "<supplied configuration text>");
  }
#line 641
  if (ads___7->configerrno) {
    {
#line 642
    r = ads___7->configerrno;
#line 643
    init_abort___3(ads___7);
    }
#line 644
    return (r);
  }
  {
#line 647
  r = init_finish___3(ads___7);
  }
#line 647
  if (r) {
#line 647
    return (r);
  }
  {
#line 648
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
#line 649
  *ads_r = ads___7;
  }
#line 650
  return (0);
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
static vbuf vbw___3  ;
#line 175 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
static void Tvbpollevents___3(int events ) 
{ 
  char const   *delim ;

  {
#line 176
  delim = "";
#line 177
  events &= 7;
#line 178
  if (! events) {
    {
#line 178
    Tvba("0");
    }
#line 178
    return;
  }
#line 179
  if (events & 1) {
    {
#line 179
    Tvba("POLLIN");
#line 179
    delim = "|";
    }
  }
#line 180
  if (events & 4) {
    {
#line 180
    Tvba(delim);
#line 180
    Tvba("POLLOUT");
#line 180
    delim = "|";
    }
  }
#line 181
  if (events & 2) {
    {
#line 181
    Tvba(delim);
#line 181
    Tvba("POLLPRI");
    }
  }
#line 182
  return;
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
static unsigned long malloccount___3  ;
#line 241 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
static unsigned long mallocfailat___3  ;
#line 242 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
static struct __anonstruct_mallocedlist_90___3 mallocedlist___3  ;
#line 9 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hrecord.c"
static FILE *Toutputfile___2  ;
#line 12 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hrecord.c"
static void R_recordtime___1(void) 
{ 
  int r ;
  struct timeval tv ;
  struct timeval tvrel ;

  {
  {
#line 15
  Tensurerecordfile();
#line 16
  r = gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )0);
  }
#line 16
  if (r) {
    {
#line 16
    Tfailed("gettimeofday syscallbegin");
    }
  }
#line 17
  tvrel.tv_sec = tv.tv_sec - currenttime.tv_sec;
#line 18
  tvrel.tv_usec = tv.tv_usec - currenttime.tv_usec;
#line 19
  if (tv.tv_usec < 0L) {
#line 19
    tvrel.tv_usec += 1000000L;
#line 19
    (tvrel.tv_sec) --;
  }
  {
#line 20
  Tvbf("\n +%ld.%06ld", tvrel.tv_sec, tvrel.tv_usec);
#line 21
  currenttime = tv;
  }
#line 22
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hrecord.c"
static void R_vb___1(void) 
{ 


  {
  {
#line 44
  Q_vb();
  }
#line 45
  return;
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_qstring___3(parseinfo const   *pai , int *cbyte_io , int max ,
                                   int *len_r , char **str_r ) 
{ 
  byte const   *dgram ;
  int l ;
  int cbyte___3 ;
  char *str ;
  int tmp ;
  void *tmp___0 ;

  {
#line 92
  dgram = (byte const   *)pai->dgram;
#line 96
  cbyte___3 = *cbyte_io;
#line 98
  if (cbyte___3 >= max) {
#line 98
    return ((adns_status )104);
  }
#line 99
  tmp = cbyte___3;
#line 99
  cbyte___3 ++;
#line 99
  l = (int )((int const   )*(dgram + tmp) & 255);
#line 100
  if (cbyte___3 + l > max) {
#line 100
    return ((adns_status )104);
  }
  {
#line 102
  tmp___0 = adns__alloc_interim((adns_query )pai->qu, (size_t )(l + 1));
#line 102
  str = (char *)tmp___0;
  }
#line 103
  if (! str) {
#line 103
    return ((adns_status )1);
  }
  {
#line 105
  *(str + l) = (char)0;
#line 106
  memcpy((void */* __restrict  */)str, (void const   */* __restrict  */)(dgram + cbyte___3),
         (size_t )l);
#line 108
  *len_r = l;
#line 109
  *str_r = str;
#line 110
  *cbyte_io = cbyte___3 + l;
  }
#line 112
  return ((adns_status )0);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_qstring___3(vbuf *vb___0 , char const   *dp , int len ) 
{ 
  unsigned char ch ;
  char buf___17[10] ;
  int cn ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 120
    tmp = adns__vbuf_appendstr(vb___0, "\"");
    }
#line 120
    if (! tmp) {
#line 120
      return ((adns_status )1);
    }
#line 120
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  cn = 0;
  {
#line 121
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 121
    if (! (cn < len)) {
#line 121
      goto while_break___0;
    }
#line 122
    tmp___0 = dp;
#line 122
    dp ++;
#line 122
    ch = (unsigned char )*tmp___0;
#line 123
    if ((int )ch == 92) {
      {
#line 124
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 124
        tmp___1 = adns__vbuf_appendstr(vb___0, "\\\\");
        }
#line 124
        if (! tmp___1) {
#line 124
          return ((adns_status )1);
        }
#line 124
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else
#line 125
    if ((int )ch == 34) {
      {
#line 126
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 126
        tmp___2 = adns__vbuf_appendstr(vb___0, "\\\"");
        }
#line 126
        if (! tmp___2) {
#line 126
          return ((adns_status )1);
        }
#line 126
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else
#line 127
    if ((int )ch >= 32) {
#line 127
      if ((int )ch <= 126) {
        {
#line 128
        tmp___3 = adns__vbuf_append(vb___0, (byte const   *)(& ch), 1);
        }
#line 128
        if (! tmp___3) {
#line 128
          return ((adns_status )1);
        }
      } else {
#line 127
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 130
      sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"\\x%02x",
              (int )ch);
      }
      {
#line 131
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 131
        tmp___4 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
        }
#line 131
        if (! tmp___4) {
#line 131
          return ((adns_status )1);
        }
#line 131
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 121
    cn ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 134
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 134
    tmp___5 = adns__vbuf_appendstr(vb___0, "\"");
    }
#line 134
    if (! tmp___5) {
#line 134
      return ((adns_status )1);
    }
#line 134
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 136
  return ((adns_status )0);
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_str___3(adns_query qu , void *datap ) 
{ 
  char **rrp ;

  {
  {
#line 144
  rrp = (char **)datap;
#line 146
  adns__makefinal_str(qu, rrp);
  }
#line 147
  return;
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_intstr___3(adns_query qu , void *datap ) 
{ 
  adns_rr_intstr *rrp ;

  {
  {
#line 154
  rrp = (adns_rr_intstr *)datap;
#line 156
  adns__makefinal_str(qu, & rrp->str);
  }
#line 157
  return;
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_manyistr___3(adns_query qu , void *datap ) 
{ 
  adns_rr_intstr **rrp ;
  adns_rr_intstr *te ;
  adns_rr_intstr *table ;
  void *tablev ;
  int tc ;

  {
#line 164
  rrp = (adns_rr_intstr **)datap;
#line 169
  tc = 0;
#line 169
  te = *rrp;
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    if (! (te->i >= 0)) {
#line 169
      goto while_break;
    }
#line 169
    te ++;
#line 169
    tc ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 170
  tablev = (void *)*rrp;
#line 171
  adns__makefinal_block(qu, & tablev, sizeof(*te) * (unsigned long )(tc + 1));
#line 172
  table = (adns_rr_intstr *)tablev;
#line 172
  *rrp = table;
#line 173
  te = *rrp;
  }
  {
#line 173
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 173
    if (! (te->i >= 0)) {
#line 173
      goto while_break___0;
    }
    {
#line 174
    adns__makefinal_str(qu, & te->str);
#line 173
    te ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 175
  return;
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_txt___3(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  adns_rr_intstr **rrp ;
  adns_rr_intstr *table ;
  adns_rr_intstr *te ;
  byte const   *dgram ;
  int ti ;
  int tc ;
  int l ;
  int startbyte ;
  adns_status st ;
  int tmp ;
  void *tmp___0 ;

  {
#line 183
  rrp = (adns_rr_intstr **)datap;
#line 184
  dgram = (byte const   *)pai->dgram;
#line 188
  startbyte = cbyte___3;
#line 189
  if (cbyte___3 >= max) {
#line 189
    return ((adns_status )104);
  }
#line 190
  tc = 0;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! (cbyte___3 < max)) {
#line 191
      goto while_break;
    }
#line 192
    tmp = cbyte___3;
#line 192
    cbyte___3 ++;
#line 192
    l = (int )((int const   )*(dgram + tmp) & 255);
#line 193
    cbyte___3 += l;
#line 194
    tc ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  if (cbyte___3 != max) {
#line 196
    return ((adns_status )104);
  } else
#line 196
  if (! tc) {
#line 196
    return ((adns_status )104);
  }
  {
#line 198
  tmp___0 = adns__alloc_interim((adns_query )pai->qu, sizeof(*table) * (unsigned long )(tc + 1));
#line 198
  table = (adns_rr_intstr *)tmp___0;
  }
#line 199
  if (! table) {
#line 199
    return ((adns_status )1);
  }
#line 201
  cbyte___3 = startbyte;
#line 201
  ti = 0;
#line 201
  te = table;
  {
#line 201
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 201
    if (! (ti < tc)) {
#line 201
      goto while_break___0;
    }
    {
#line 202
    st = pap_qstring___3(pai, & cbyte___3, max, & te->i, & te->str);
    }
#line 203
    if (st) {
#line 203
      return (st);
    }
#line 201
    ti ++;
#line 201
    te ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 205
  if (! (cbyte___3 == max)) {
    {
#line 205
    __assert_fail("cbyte == max", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  205U, "pa_txt");
    }
  }
#line 207
  te->i = -1;
#line 208
  te->str = (char *)0;
#line 210
  *rrp = table;
#line 211
  return ((adns_status )0);
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_txt___3(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_intstr const   * const  *rrp ;
  adns_rr_intstr const   *current ;
  adns_status st ;
  int spc ;
  int tmp ;

  {
#line 215
  rrp = (adns_rr_intstr const   * const  *)datap;
#line 220
  current = (adns_rr_intstr const   *)*rrp;
#line 220
  spc = 0;
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    if (! (current->i >= 0)) {
#line 220
      goto while_break;
    }
#line 221
    if (spc) {
      {
#line 221
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 221
        tmp = adns__vbuf_appendstr(vb___0, " ");
        }
#line 221
        if (! tmp) {
#line 221
          return ((adns_status )1);
        }
#line 221
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 222
    st = csp_qstring___3(vb___0, (char const   *)current->str, (int )current->i);
    }
#line 222
    if (st) {
#line 222
      return (st);
    }
#line 220
    current ++;
#line 220
    spc = 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  return ((adns_status )0);
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_hinfo___3(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_intstrpair const   *rrp ;
  adns_status st ;
  int tmp ;

  {
  {
#line 232
  rrp = (adns_rr_intstrpair const   *)datap;
#line 235
  st = csp_qstring___3(vb___0, (char const   *)rrp->array[0].str, (int )rrp->array[0].i);
  }
#line 235
  if (st) {
#line 235
    return (st);
  }
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 236
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 236
    if (! tmp) {
#line 236
      return ((adns_status )1);
    }
#line 236
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 237
  st = csp_qstring___3(vb___0, (char const   *)rrp->array[1].str, (int )rrp->array[1].i);
  }
#line 237
  if (st) {
#line 237
    return (st);
  }
#line 238
  return ((adns_status )0);
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_inaddr___3(parseinfo const   *pai , int cbyte___3 , int max ,
                                 void *datap ) 
{ 
  struct in_addr *storeto ;

  {
#line 247
  storeto = (struct in_addr *)datap;
#line 249
  if (max - cbyte___3 != 4) {
#line 249
    return ((adns_status )104);
  }
  {
#line 250
  memcpy((void */* __restrict  */)storeto, (void const   */* __restrict  */)(pai->dgram + cbyte___3),
         (size_t )4);
  }
#line 251
  return ((adns_status )0);
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int search_sortlist___3(adns_state ads___7 , struct in_addr ad ) 
{ 
  struct sortlist  const  *slp ;
  int i ;

  {
#line 258
  i = 0;
#line 258
  slp = (struct sortlist  const  *)(ads___7->sortlist);
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 258
    if (i < ads___7->nsortlist) {
#line 258
      if (! (! ((ad.s_addr & (unsigned int )slp->mask.s_addr) == (unsigned int )slp->base.s_addr))) {
#line 258
        goto while_break;
      }
    } else {
#line 258
      goto while_break;
    }
#line 258
    i ++;
#line 258
    slp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  return (i);
}
}
#line 265 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int dip_inaddr___3(adns_state ads___7 , struct in_addr a , struct in_addr b ) 
{ 
  int ai ;
  int bi ;

  {
#line 268
  if (! ads___7->nsortlist) {
#line 268
    return (0);
  }
  {
#line 270
  ai = search_sortlist___3(ads___7, a);
#line 271
  bi = search_sortlist___3(ads___7, b);
  }
#line 272
  return (bi < ai);
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_inaddr___3(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  struct in_addr  const  *ap ;
  struct in_addr  const  *bp ;
  int tmp ;

  {
  {
#line 277
  ap = (struct in_addr  const  *)datap_a;
#line 277
  bp = (struct in_addr  const  *)datap_b;
#line 279
  tmp = dip_inaddr___3(ads___7, (struct in_addr )*ap, (struct in_addr )*bp);
  }
#line 279
  return (tmp);
}
}
#line 282 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_inaddr___3(vbuf *vb___0 , void const   *datap ) 
{ 
  struct in_addr  const  *rrp ;
  struct in_addr rr ;
  char const   *ia ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 283
  rrp = (struct in_addr  const  *)datap;
#line 283
  rr = *rrp;
#line 286
  tmp = inet_ntoa(rr);
#line 286
  ia = (char const   *)tmp;
  }
#line 286
  if (! ia) {
    {
#line 286
    __assert_fail("ia", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  286U, "cs_inaddr");
    }
  }
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 287
    tmp___0 = adns__vbuf_appendstr(vb___0, ia);
    }
#line 287
    if (! tmp___0) {
#line 287
      return ((adns_status )1);
    }
#line 287
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  return ((adns_status )0);
}
}
#line 295 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_addr___3(parseinfo const   *pai , int cbyte___3 , int max ,
                               void *datap ) 
{ 
  adns_rr_addr *storeto ;
  byte const   *dgram ;

  {
#line 297
  storeto = (adns_rr_addr *)datap;
#line 298
  dgram = (byte const   *)pai->dgram;
#line 300
  if (max - cbyte___3 != 4) {
#line 300
    return ((adns_status )104);
  }
  {
#line 301
  storeto->len = (int )sizeof(storeto->addr.inet);
#line 302
  memset((void *)(& storeto->addr), 0, sizeof(storeto->addr.inet));
#line 303
  storeto->addr.inet.sin_family = (sa_family_t )2;
#line 304
  memcpy((void */* __restrict  */)(& storeto->addr.inet.sin_addr), (void const   */* __restrict  */)(dgram + cbyte___3),
         (size_t )4);
  }
#line 305
  return ((adns_status )0);
}
}
#line 308 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_addr___3(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_addr const   *ap ;
  adns_rr_addr const   *bp ;
  int tmp ;

  {
#line 309
  ap = (adns_rr_addr const   *)datap_a;
#line 309
  bp = (adns_rr_addr const   *)datap_b;
#line 311
  if (! ((int const   )ap->addr.sa.sa_family == 2)) {
    {
#line 311
    __assert_fail("ap->addr.sa.sa_family == 2", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  311U, "di_addr");
    }
  }
  {
#line 312
  tmp = dip_inaddr___3(ads___7, (struct in_addr )ap->addr.inet.sin_addr, (struct in_addr )bp->addr.inet.sin_addr);
  }
#line 312
  return (tmp);
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int div_addr___3(void *context , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_state ads___7 ;
  int tmp ;

  {
  {
#line 316
  ads___7 = (adns_state )context;
#line 318
  tmp = di_addr___3(ads___7, datap_a, datap_b);
  }
#line 318
  return (tmp);
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_addr___3(vbuf *vb___0 , adns_rr_addr const   *rrp ) 
{ 
  char const   *ia ;
  char buf___17[30] ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 326
  if ((int const   )rrp->addr.inet.sin_family == 2) {
#line 326
    goto case_2;
  }
#line 331
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 327
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 327
    tmp = adns__vbuf_appendstr(vb___0, "INET ");
    }
#line 327
    if (! tmp) {
#line 327
      return ((adns_status )1);
    }
#line 327
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 328
  tmp___0 = inet_ntoa((struct in_addr )rrp->addr.inet.sin_addr);
#line 328
  ia = (char const   *)tmp___0;
  }
#line 328
  if (! ia) {
    {
#line 328
    __assert_fail("ia", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  328U, "csp_addr");
    }
  }
  {
#line 329
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 329
    tmp___1 = adns__vbuf_appendstr(vb___0, ia);
    }
#line 329
    if (! tmp___1) {
#line 329
      return ((adns_status )1);
    }
#line 329
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 330
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 332
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"AF=%u",
          (int const   )rrp->addr.sa.sa_family);
  }
  {
#line 333
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 333
    tmp___2 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 333
    if (! tmp___2) {
#line 333
      return ((adns_status )1);
    }
#line 333
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 334
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 336
  return ((adns_status )0);
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_addr___3(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_addr const   *rrp ;
  adns_status tmp ;

  {
  {
#line 340
  rrp = (adns_rr_addr const   *)datap;
#line 342
  tmp = csp_addr___3(vb___0, rrp);
  }
#line 342
  return (tmp);
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_domain___3(parseinfo const   *pai , int *cbyte_io , int max ,
                                  char **domain_r , parsedomain_flags flags ) 
{ 
  adns_status st ;
  char *dm ;
  void *tmp ;

  {
  {
#line 355
  st = adns__parse_domain((pai->qu)->ads, (int )pai->serv, (adns_query )pai->qu, & (pai->qu)->vb,
                          flags, (byte const   *)pai->dgram, (int )pai->dglen, cbyte_io,
                          max);
  }
#line 357
  if (st) {
#line 357
    return (st);
  }
#line 358
  if (! (pai->qu)->vb.used) {
#line 358
    return ((adns_status )104);
  }
  {
#line 360
  tmp = adns__alloc_interim((adns_query )pai->qu, (size_t )((pai->qu)->vb.used + 1));
#line 360
  dm = (char *)tmp;
  }
#line 361
  if (! dm) {
#line 361
    return ((adns_status )1);
  }
  {
#line 363
  *(dm + (pai->qu)->vb.used) = (char)0;
#line 364
  memcpy((void */* __restrict  */)dm, (void const   */* __restrict  */)(pai->qu)->vb.buf,
         (size_t )(pai->qu)->vb.used);
#line 366
  *domain_r = dm;
  }
#line 367
  return ((adns_status )0);
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_domain___3(vbuf *vb___0 , char const   *domain ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 371
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 371
    tmp = adns__vbuf_appendstr(vb___0, domain);
    }
#line 371
    if (! tmp) {
#line 371
      return ((adns_status )1);
    }
#line 371
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 372
  if (! *domain) {
    {
#line 372
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 372
      tmp___0 = adns__vbuf_appendstr(vb___0, ".");
      }
#line 372
      if (! tmp___0) {
#line 372
        return ((adns_status )1);
      }
#line 372
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 373
  return ((adns_status )0);
}
}
#line 376 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_domain___3(vbuf *vb___0 , void const   *datap ) 
{ 
  char const   * const  *domainp ;
  adns_status tmp ;

  {
  {
#line 377
  domainp = (char const   * const  *)datap;
#line 378
  tmp = csp_domain___3(vb___0, (char const   *)*domainp);
  }
#line 378
  return (tmp);
}
}
#line 381 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_dom_raw___3(parseinfo const   *pai , int cbyte___3 , int max ,
                                  void *datap ) 
{ 
  char **rrp ;
  adns_status st ;

  {
  {
#line 383
  rrp = (char **)datap;
#line 386
  st = pap_domain___3(pai, & cbyte___3, max, rrp, (parsedomain_flags )1);
  }
#line 387
  if (st) {
#line 387
    return (st);
  }
#line 389
  if (cbyte___3 != max) {
#line 389
    return ((adns_status )104);
  }
#line 390
  return ((adns_status )0);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_host_raw___3(parseinfo const   *pai , int cbyte___3 , int max ,
                                   void *datap ) 
{ 
  char **rrp ;
  adns_status st ;
  int tmp ;

  {
#line 399
  rrp = (char **)datap;
#line 402
  if ((pai->qu)->flags & 64) {
#line 402
    tmp = 1;
  } else {
#line 402
    tmp = 0;
  }
  {
#line 402
  st = pap_domain___3(pai, & cbyte___3, max, rrp, (parsedomain_flags )tmp);
  }
#line 404
  if (st) {
#line 404
    return (st);
  }
#line 406
  if (cbyte___3 != max) {
#line 406
    return ((adns_status )104);
  }
#line 407
  return ((adns_status )0);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_findaddrs___3(parseinfo const   *pai , adns_rr_hostaddr *ha ,
                                     int *cbyte_io , int count , int dmstart ) 
{ 
  int rri ;
  int naddrs ;
  int type ;
  int class ;
  int rdlen ;
  int rdstart ;
  int ownermatched ;
  unsigned long ttl ;
  adns_status st ;
  int tmp ;
  void *tmp___0 ;

  {
#line 421
  rri = 0;
#line 421
  naddrs = -1;
  {
#line 421
  while (1) {
    while_continue: /* CIL Label */ ;
#line 421
    if (! (rri < count)) {
#line 421
      goto while_break;
    }
    {
#line 422
    st = adns__findrr_anychk((adns_query )pai->qu, (int )pai->serv, (byte const   *)pai->dgram,
                             (int )pai->dglen, cbyte_io, & type, & class, & ttl, & rdlen,
                             & rdstart, (byte const   *)pai->dgram, (int )pai->dglen,
                             dmstart, & ownermatched);
    }
#line 426
    if (st) {
#line 426
      return (st);
    }
#line 427
    if (! ownermatched) {
#line 427
      goto _L;
    } else
#line 427
    if (class != 1) {
#line 427
      goto _L;
    } else
#line 427
    if (type != 1) {
      _L: /* CIL Label */ 
#line 428
      if (naddrs > 0) {
#line 428
        goto while_break;
      } else {
#line 428
        goto __Cont;
      }
    }
#line 430
    if (naddrs == -1) {
#line 431
      naddrs = 0;
    }
    {
#line 433
    tmp = adns__vbuf_ensure(& (pai->qu)->vb, (int )((unsigned long )(naddrs + 1) * sizeof(adns_rr_addr )));
    }
#line 433
    if (! tmp) {
#line 434
      return ((adns_status )1);
    }
    {
#line 435
    adns__update_expires((adns_query )pai->qu, ttl, (struct timeval )pai->now);
#line 436
    st = pa_addr___3(pai, rdstart, rdstart + rdlen, (void *)((pai->qu)->vb.buf + (unsigned long )naddrs * sizeof(adns_rr_addr )));
    }
#line 438
    if (st) {
#line 438
      return (st);
    }
#line 439
    naddrs ++;
    __Cont: /* CIL Label */ 
#line 421
    rri ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 441
  if (naddrs >= 0) {
    {
#line 442
    tmp___0 = adns__alloc_interim((adns_query )pai->qu, (unsigned long )naddrs * sizeof(adns_rr_addr ));
#line 442
    ha->addrs = (adns_rr_addr *)tmp___0;
    }
#line 443
    if (! ha->addrs) {
#line 443
      return ((adns_status )1);
    }
    {
#line 444
    memcpy((void */* __restrict  */)ha->addrs, (void const   */* __restrict  */)(pai->qu)->vb.buf,
           (unsigned long )naddrs * sizeof(adns_rr_addr ));
#line 445
    ha->naddrs = naddrs;
#line 446
    ha->astatus = (adns_status )0;
#line 448
    adns__isort((void *)ha->addrs, naddrs, (int )sizeof(adns_rr_addr ), (void *)(pai->qu)->vb.buf,
                & div_addr___3, (void *)pai->ads);
    }
  }
#line 451
  return ((adns_status )0);
}
}
#line 454 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void icb_hostaddr___3(adns_query parent , adns_query child ) 
{ 
  adns_answer *cans ;
  adns_rr_hostaddr *rrp ;
  adns_state ads___7 ;
  adns_status st ;

  {
#line 455
  cans = child->answer;
#line 456
  rrp = child->ctx.info.hostaddr;
#line 457
  ads___7 = parent->ads;
#line 460
  st = cans->status;
#line 461
  rrp->astatus = st;
#line 462
  if ((unsigned int )st > 0U) {
#line 462
    if ((unsigned int )st <= 99U) {
#line 462
      rrp->naddrs = -1;
    } else {
#line 462
      rrp->naddrs = cans->nrrs;
    }
  } else {
#line 462
    rrp->naddrs = cans->nrrs;
  }
  {
#line 463
  rrp->addrs = cans->rrs.addr;
#line 464
  adns__transfer_interim(child, parent, (void *)rrp->addrs, (unsigned long )rrp->naddrs * sizeof(adns_rr_addr ));
  }
#line 467
  if (parent->children.head) {
    {
#line 468
    while (1) {
      while_continue: /* CIL Label */ ;
#line 468
      parent->next = (adns_query )0;
#line 468
      parent->back = ads___7->childw.tail;
#line 468
      if (ads___7->childw.tail) {
#line 468
        (ads___7->childw.tail)->next = parent;
      } else {
#line 468
        ads___7->childw.head = parent;
      }
#line 468
      ads___7->childw.tail = parent;
#line 468
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 470
    adns__query_done(parent);
    }
  }
#line 472
  return;
}
}
#line 474 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_hostaddr___3(parseinfo const   *pai , int *cbyte_io , int max ,
                                    adns_rr_hostaddr *rrp ) 
{ 
  adns_status st ;
  int dmstart ;
  int cbyte___3 ;
  qcontext ctx ;
  int id ;
  adns_query nqu ;
  adns_queryflags nflags ;
  int tmp ;
  typeinfo const   *tmp___0 ;

  {
#line 483
  cbyte___3 = *cbyte_io;
#line 483
  dmstart = cbyte___3;
#line 484
  if ((pai->qu)->flags & 64) {
#line 484
    tmp = 1;
  } else {
#line 484
    tmp = 0;
  }
  {
#line 484
  st = pap_domain___3(pai, & cbyte___3, max, & rrp->host, (parsedomain_flags )tmp);
  }
#line 486
  if (st) {
#line 486
    return (st);
  }
  {
#line 487
  *cbyte_io = cbyte___3;
#line 489
  rrp->astatus = (adns_status )0;
#line 490
  rrp->naddrs = -1;
#line 491
  rrp->addrs = (adns_rr_addr *)0;
#line 493
  cbyte___3 = (int )pai->nsstart;
#line 495
  st = pap_findaddrs___3(pai, rrp, & cbyte___3, (int )pai->nscount, dmstart);
  }
#line 496
  if (st) {
#line 496
    return (st);
  }
#line 497
  if (rrp->naddrs != -1) {
#line 497
    return ((adns_status )0);
  }
  {
#line 499
  st = pap_findaddrs___3(pai, rrp, & cbyte___3, (int )pai->arcount, dmstart);
  }
#line 500
  if (st) {
#line 500
    return (st);
  }
#line 501
  if (rrp->naddrs != -1) {
#line 501
    return ((adns_status )0);
  }
  {
#line 503
  st = adns__mkquery_frdgram((adns_state )pai->ads, & (pai->qu)->vb, & id, (byte const   *)pai->dgram,
                             (int )pai->dglen, dmstart, (adns_rrtype )65537, (adns_queryflags )16);
  }
#line 506
  if (st) {
#line 506
    return (st);
  }
#line 508
  ctx.ext = (void *)0;
#line 509
  ctx.callback = & icb_hostaddr___3;
#line 510
  ctx.info.hostaddr = rrp;
#line 512
  nflags = (adns_queryflags )16;
#line 513
  if (! ((pai->qu)->flags & 256)) {
#line 513
    nflags = (adns_queryflags )((unsigned int )nflags | 512U);
  }
  {
#line 515
  tmp___0 = adns__findtype((adns_rrtype )65537);
#line 515
  st = adns__internal_submit((adns_state )pai->ads, & nqu, tmp___0, & (pai->qu)->vb,
                             id, nflags, (struct timeval )pai->now, (qcontext const   *)(& ctx));
  }
#line 517
  if (st) {
#line 517
    return (st);
  }
#line 519
  nqu->parent = (adns_query )pai->qu;
  {
#line 520
  while (1) {
    while_continue: /* CIL Label */ ;
#line 520
    nqu->siblings.next = (adns_query )0;
#line 520
    nqu->siblings.back = (pai->qu)->children.tail;
#line 520
    if ((pai->qu)->children.tail) {
#line 520
      ((pai->qu)->children.tail)->siblings.next = nqu;
    } else {
#line 520
      (pai->qu)->children.head = nqu;
    }
#line 520
    (pai->qu)->children.tail = nqu;
#line 520
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 522
  return ((adns_status )0);
}
}
#line 525 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_hostaddr___3(parseinfo const   *pai , int cbyte___3 , int max ,
                                   void *datap ) 
{ 
  adns_rr_hostaddr *rrp ;
  adns_status st ;

  {
  {
#line 527
  rrp = (adns_rr_hostaddr *)datap;
#line 530
  st = pap_hostaddr___3(pai, & cbyte___3, max, rrp);
  }
#line 531
  if (st) {
#line 531
    return (st);
  }
#line 532
  if (cbyte___3 != max) {
#line 532
    return ((adns_status )104);
  }
#line 534
  return ((adns_status )0);
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int dip_hostaddr___3(adns_state ads___7 , adns_rr_hostaddr const   *ap , adns_rr_hostaddr const   *bp ) 
{ 
  int tmp ;

  {
#line 539
  if ((unsigned int const   )ap->astatus != (unsigned int const   )bp->astatus) {
#line 539
    return ((int )ap->astatus);
  }
#line 540
  if (ap->astatus) {
#line 540
    return (0);
  }
#line 542
  if (! ((int )(ap->addrs + 0)->addr.sa.sa_family == 2)) {
    {
#line 542
    __assert_fail("ap->addrs[0].addr.sa.sa_family == 2", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  542U, "dip_hostaddr");
    }
  }
#line 543
  if (! ((int )(bp->addrs + 0)->addr.sa.sa_family == 2)) {
    {
#line 543
    __assert_fail("bp->addrs[0].addr.sa.sa_family == 2", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  543U, "dip_hostaddr");
    }
  }
  {
#line 544
  tmp = dip_inaddr___3(ads___7, (ap->addrs + 0)->addr.inet.sin_addr, (bp->addrs + 0)->addr.inet.sin_addr);
  }
#line 544
  return (tmp);
}
}
#line 549 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_hostaddr___3(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_hostaddr const   *ap ;
  adns_rr_hostaddr const   *bp ;
  int tmp ;

  {
  {
#line 551
  ap = (adns_rr_hostaddr const   *)datap_a;
#line 551
  bp = (adns_rr_hostaddr const   *)datap_b;
#line 553
  tmp = dip_hostaddr___3(ads___7, ap, bp);
  }
#line 553
  return (tmp);
}
}
#line 556 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mfp_hostaddr___3(adns_query qu , adns_rr_hostaddr *rrp ) 
{ 
  void *tablev ;

  {
  {
#line 559
  adns__makefinal_str(qu, & rrp->host);
#line 560
  tablev = (void *)rrp->addrs;
#line 561
  adns__makefinal_block(qu, & tablev, (unsigned long )rrp->naddrs * sizeof(*(rrp->addrs)));
#line 562
  rrp->addrs = (adns_rr_addr *)tablev;
  }
#line 563
  return;
}
}
#line 565 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_hostaddr___3(adns_query qu , void *datap ) 
{ 
  adns_rr_hostaddr *rrp ;

  {
  {
#line 566
  rrp = (adns_rr_hostaddr *)datap;
#line 568
  mfp_hostaddr___3(qu, rrp);
  }
#line 569
  return;
}
}
#line 571 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_hostaddr___3(vbuf *vb___0 , adns_rr_hostaddr const   *rrp ) 
{ 
  char const   *errstr ;
  adns_status st ;
  char buf___17[20] ;
  int i ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 577
  st = csp_domain___3(vb___0, (char const   *)rrp->host);
  }
#line 577
  if (st) {
#line 577
    return (st);
  }
  {
#line 579
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 579
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 579
    if (! tmp) {
#line 579
      return ((adns_status )1);
    }
#line 579
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 580
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 580
    tmp___0 = adns_errtypeabbrev((adns_status )rrp->astatus);
#line 580
    tmp___1 = adns__vbuf_appendstr(vb___0, tmp___0);
    }
#line 580
    if (! tmp___1) {
#line 580
      return ((adns_status )1);
    }
#line 580
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 582
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %d ",
          (unsigned int const   )rrp->astatus);
  }
  {
#line 583
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 583
    tmp___2 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 583
    if (! tmp___2) {
#line 583
      return ((adns_status )1);
    }
#line 583
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 585
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 585
    tmp___3 = adns_errabbrev((adns_status )rrp->astatus);
#line 585
    tmp___4 = adns__vbuf_appendstr(vb___0, tmp___3);
    }
#line 585
    if (! tmp___4) {
#line 585
      return ((adns_status )1);
    }
#line 585
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 586
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 586
    tmp___5 = adns__vbuf_appendstr(vb___0, " ");
    }
#line 586
    if (! tmp___5) {
#line 586
      return ((adns_status )1);
    }
#line 586
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 588
  errstr = adns_strerror((adns_status )rrp->astatus);
#line 589
  tmp___6 = strlen(errstr);
#line 589
  st = csp_qstring___3(vb___0, errstr, (int )tmp___6);
  }
#line 589
  if (st) {
#line 589
    return (st);
  }
#line 591
  if (rrp->naddrs >= 0) {
    {
#line 592
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 592
      tmp___7 = adns__vbuf_appendstr(vb___0, " (");
      }
#line 592
      if (! tmp___7) {
#line 592
        return ((adns_status )1);
      }
#line 592
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 593
    i = 0;
    {
#line 593
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 593
      if (! (i < (int )rrp->naddrs)) {
#line 593
        goto while_break___5;
      }
      {
#line 594
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 594
        tmp___8 = adns__vbuf_appendstr(vb___0, " ");
        }
#line 594
        if (! tmp___8) {
#line 594
          return ((adns_status )1);
        }
#line 594
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 595
      st = csp_addr___3(vb___0, (adns_rr_addr const   *)(rrp->addrs + i));
#line 593
      i ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 597
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 597
      tmp___9 = adns__vbuf_appendstr(vb___0, " )");
      }
#line 597
      if (! tmp___9) {
#line 597
        return ((adns_status )1);
      }
#line 597
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
  } else {
    {
#line 599
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 599
      tmp___10 = adns__vbuf_appendstr(vb___0, " ?");
      }
#line 599
      if (! tmp___10) {
#line 599
        return ((adns_status )1);
      }
#line 599
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
#line 601
  return ((adns_status )0);
}
}
#line 604 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_hostaddr___3(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_hostaddr const   *rrp ;
  adns_status tmp ;

  {
  {
#line 605
  rrp = (adns_rr_hostaddr const   *)datap;
#line 607
  tmp = csp_hostaddr___3(vb___0, rrp);
  }
#line 607
  return (tmp);
}
}
#line 614 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_mx_raw___3(parseinfo const   *pai , int cbyte___3 , int max ,
                                 void *datap ) 
{ 
  byte const   *dgram ;
  adns_rr_intstr *rrp ;
  adns_status st ;
  int pref ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 616
  dgram = (byte const   *)pai->dgram;
#line 617
  rrp = (adns_rr_intstr *)datap;
#line 621
  if (cbyte___3 + 2 > max) {
#line 621
    return ((adns_status )104);
  }
#line 622
  pref = 0;
#line 622
  tmp = cbyte___3;
#line 622
  cbyte___3 ++;
#line 622
  pref |= (int )(((int const   )*(dgram + tmp) & 255) << 8);
#line 622
  tmp___0 = cbyte___3;
#line 622
  cbyte___3 ++;
#line 622
  pref |= (int )((int const   )*(dgram + tmp___0) & 255);
#line 623
  rrp->i = pref;
#line 624
  if ((pai->qu)->flags & 64) {
#line 624
    tmp___1 = 1;
  } else {
#line 624
    tmp___1 = 0;
  }
  {
#line 624
  st = pap_domain___3(pai, & cbyte___3, max, & rrp->str, (parsedomain_flags )tmp___1);
  }
#line 626
  if (st) {
#line 626
    return (st);
  }
#line 628
  if (cbyte___3 != max) {
#line 628
    return ((adns_status )104);
  }
#line 629
  return ((adns_status )0);
}
}
#line 632 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_mx_raw___3(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_intstr const   *ap ;
  adns_rr_intstr const   *bp ;

  {
#line 633
  ap = (adns_rr_intstr const   *)datap_a;
#line 633
  bp = (adns_rr_intstr const   *)datap_b;
#line 635
  if (ap->i < bp->i) {
#line 635
    return (0);
  }
#line 636
  if (ap->i > bp->i) {
#line 636
    return (1);
  }
#line 637
  return (0);
}
}
#line 644 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_mx___3(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  byte const   *dgram ;
  adns_rr_inthostaddr *rrp ;
  adns_status st ;
  int pref ;
  int tmp ;
  int tmp___0 ;

  {
#line 646
  dgram = (byte const   *)pai->dgram;
#line 647
  rrp = (adns_rr_inthostaddr *)datap;
#line 651
  if (cbyte___3 + 2 > max) {
#line 651
    return ((adns_status )104);
  }
  {
#line 652
  pref = 0;
#line 652
  tmp = cbyte___3;
#line 652
  cbyte___3 ++;
#line 652
  pref |= (int )(((int const   )*(dgram + tmp) & 255) << 8);
#line 652
  tmp___0 = cbyte___3;
#line 652
  cbyte___3 ++;
#line 652
  pref |= (int )((int const   )*(dgram + tmp___0) & 255);
#line 653
  rrp->i = pref;
#line 654
  st = pap_hostaddr___3(pai, & cbyte___3, max, & rrp->ha);
  }
#line 655
  if (st) {
#line 655
    return (st);
  }
#line 657
  if (cbyte___3 != max) {
#line 657
    return ((adns_status )104);
  }
#line 658
  return ((adns_status )0);
}
}
#line 661 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_mx___3(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_inthostaddr const   *ap ;
  adns_rr_inthostaddr const   *bp ;
  int tmp ;

  {
#line 662
  ap = (adns_rr_inthostaddr const   *)datap_a;
#line 662
  bp = (adns_rr_inthostaddr const   *)datap_b;
#line 664
  if (ap->i < bp->i) {
#line 664
    return (0);
  }
#line 665
  if (ap->i > bp->i) {
#line 665
    return (1);
  }
  {
#line 666
  tmp = dip_hostaddr___3(ads___7, & ap->ha, & bp->ha);
  }
#line 666
  return (tmp);
}
}
#line 673 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_inthostaddr___3(adns_query qu , void *datap ) 
{ 
  adns_rr_inthostaddr *rrp ;

  {
  {
#line 674
  rrp = (adns_rr_inthostaddr *)datap;
#line 676
  mfp_hostaddr___3(qu, & rrp->ha);
  }
#line 677
  return;
}
}
#line 679 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_inthostaddr___3(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_inthostaddr const   *rrp ;
  char buf___17[10] ;
  int tmp ;
  adns_status tmp___0 ;

  {
  {
#line 680
  rrp = (adns_rr_inthostaddr const   *)datap;
#line 683
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"%u ",
          rrp->i);
  }
  {
#line 684
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 684
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 684
    if (! tmp) {
#line 684
      return ((adns_status )1);
    }
#line 684
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 686
  tmp___0 = csp_hostaddr___3(vb___0, & rrp->ha);
  }
#line 686
  return (tmp___0);
}
}
#line 693 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_inthost___3(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_intstr const   *rrp ;
  char buf___17[10] ;
  int tmp ;
  adns_status tmp___0 ;

  {
  {
#line 694
  rrp = (adns_rr_intstr const   *)datap;
#line 697
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"%u ",
          rrp->i);
  }
  {
#line 698
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 698
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 698
    if (! tmp) {
#line 698
      return ((adns_status )1);
    }
#line 698
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 699
  tmp___0 = csp_domain___3(vb___0, (char const   *)rrp->str);
  }
#line 699
  return (tmp___0);
}
}
#line 706 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void icb_ptr___3(adns_query parent , adns_query child ) 
{ 
  adns_answer *cans ;
  adns_rr_addr const   *queried ;
  adns_rr_addr const   *found ;
  adns_state ads___7 ;
  int i ;
  int tmp ;

  {
#line 707
  cans = child->answer;
#line 709
  ads___7 = parent->ads;
#line 712
  if ((unsigned int )cans->status == 300U) {
    {
#line 713
    adns__query_fail(parent, (adns_status )100);
    }
#line 714
    return;
  } else
#line 712
  if ((unsigned int )cans->status == 301U) {
    {
#line 713
    adns__query_fail(parent, (adns_status )100);
    }
#line 714
    return;
  } else
#line 715
  if (cans->status) {
    {
#line 716
    adns__query_fail(parent, cans->status);
    }
#line 717
    return;
  }
#line 720
  queried = (adns_rr_addr const   *)(& parent->ctx.info.ptr_parent_addr);
#line 721
  i = 0;
#line 721
  found = (adns_rr_addr const   *)cans->rrs.addr;
  {
#line 721
  while (1) {
    while_continue: /* CIL Label */ ;
#line 721
    if (! (i < cans->nrrs)) {
#line 721
      goto while_break;
    }
#line 722
    if (queried->len == found->len) {
      {
#line 722
      tmp = memcmp((void const   *)(& queried->addr), (void const   *)(& found->addr),
                   (size_t )queried->len);
      }
#line 722
      if (! tmp) {
#line 724
        if (! parent->children.head) {
          {
#line 725
          adns__query_done(parent);
          }
#line 726
          return;
        } else {
          {
#line 728
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 728
            parent->next = (adns_query )0;
#line 728
            parent->back = ads___7->childw.tail;
#line 728
            if (ads___7->childw.tail) {
#line 728
              (ads___7->childw.tail)->next = parent;
            } else {
#line 728
              ads___7->childw.head = parent;
            }
#line 728
            ads___7->childw.tail = parent;
#line 728
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 729
          return;
        }
      }
    }
#line 721
    i ++;
#line 721
    found ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 734
  adns__query_fail(parent, (adns_status )100);
  }
#line 735
  return;
}
}
#line 739
static adns_status pa_ptr___3(parseinfo const   *pai , int dmstart , int max , void *datap ) ;
#line 739 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static char const   * const  expectdomain___3[2]  = {      (char const   */* const  */)"in-addr",      (char const   */* const  */)"arpa"};
#line 737 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_ptr___3(parseinfo const   *pai , int dmstart , int max , void *datap ) 
{ 
  char **rrp ;
  adns_status st ;
  adns_rr_addr *ap ;
  findlabel_state fls ;
  char *ep ;
  byte ipv[4] ;
  char labbuf[4] ;
  int cbyte___3 ;
  int i ;
  int lablen ;
  int labstart ;
  int l ;
  int id ;
  adns_query nqu ;
  qcontext ctx ;
  int tmp ;
  unsigned long tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  typeinfo const   *tmp___3 ;

  {
#line 741
  rrp = (char **)datap;
#line 752
  cbyte___3 = dmstart;
#line 753
  if ((pai->qu)->flags & 64) {
#line 753
    tmp = 1;
  } else {
#line 753
    tmp = 0;
  }
  {
#line 753
  st = pap_domain___3(pai, & cbyte___3, max, rrp, (parsedomain_flags )tmp);
  }
#line 755
  if (st) {
#line 755
    return (st);
  }
#line 756
  if (cbyte___3 != max) {
#line 756
    return ((adns_status )104);
  }
#line 758
  ap = & (pai->qu)->ctx.info.ptr_parent_addr;
#line 759
  if (! ap->len) {
    {
#line 760
    adns__findlabel_start(& fls, (adns_state )pai->ads, -1, (adns_query )pai->qu,
                          (byte const   *)(pai->qu)->query_dgram, (pai->qu)->query_dglen,
                          (pai->qu)->query_dglen, 12, (int *)0);
#line 763
    i = 0;
    }
    {
#line 763
    while (1) {
      while_continue: /* CIL Label */ ;
#line 763
      if (! (i < 4)) {
#line 763
        goto while_break;
      }
      {
#line 764
      st = adns__findlabel_next(& fls, & lablen, & labstart);
      }
#line 764
      if (! (! st)) {
        {
#line 764
        __assert_fail("!st", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                      764U, "pa_ptr");
        }
      }
#line 765
      if (lablen <= 0) {
#line 765
        return ((adns_status )200);
      } else
#line 765
      if (lablen > 3) {
#line 765
        return ((adns_status )200);
      }
      {
#line 766
      memcpy((void */* __restrict  */)(labbuf), (void const   */* __restrict  */)((pai->qu)->query_dgram + labstart),
             (size_t )lablen);
#line 767
      labbuf[lablen] = (char)0;
#line 768
      tmp___0 = strtoul((char const   */* __restrict  */)(labbuf), (char **/* __restrict  */)(& ep),
                        10);
#line 768
      ipv[3 - i] = (byte )tmp___0;
      }
#line 769
      if (*ep) {
#line 769
        return ((adns_status )200);
      }
#line 770
      if (lablen > 1) {
#line 770
        if ((int )*((pai->qu)->query_dgram + labstart) == 48) {
#line 771
          return ((adns_status )200);
        }
      }
#line 763
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 773
    i = 0;
    {
#line 773
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 773
      if (! ((unsigned long )i < sizeof(expectdomain___3) / sizeof(expectdomain___3[0]))) {
#line 773
        goto while_break___0;
      }
      {
#line 774
      st = adns__findlabel_next(& fls, & lablen, & labstart);
      }
#line 774
      if (! (! st)) {
        {
#line 774
        __assert_fail("!st", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                      774U, "pa_ptr");
        }
      }
      {
#line 775
      tmp___1 = strlen((char const   *)expectdomain___3[i]);
#line 775
      l = (int )tmp___1;
      }
#line 776
      if (lablen != l) {
#line 778
        return ((adns_status )200);
      } else {
        {
#line 776
        tmp___2 = memcmp((void const   *)((pai->qu)->query_dgram + labstart), (void const   *)expectdomain___3[i],
                         (size_t )l);
        }
#line 776
        if (tmp___2) {
#line 778
          return ((adns_status )200);
        }
      }
#line 773
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 780
    st = adns__findlabel_next(& fls, & lablen, (int *)0);
    }
#line 780
    if (! (! st)) {
      {
#line 780
      __assert_fail("!st", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                    780U, "pa_ptr");
      }
    }
#line 781
    if (lablen) {
#line 781
      return ((adns_status )200);
    }
    {
#line 783
    ap->len = (int )sizeof(struct sockaddr_in );
#line 784
    memset((void *)(& ap->addr), 0, sizeof(ap->addr.inet));
#line 785
    ap->addr.inet.sin_family = (sa_family_t )2;
#line 786
    ap->addr.inet.sin_addr.s_addr = htonl((uint32_t )(((((int )ipv[0] << 24) | ((int )ipv[1] << 16)) | ((int )ipv[2] << 8)) | (int )ipv[3]));
    }
  }
  {
#line 790
  st = adns__mkquery_frdgram((adns_state )pai->ads, & (pai->qu)->vb, & id, (byte const   *)pai->dgram,
                             (int )pai->dglen, dmstart, (adns_rrtype )65537, (adns_queryflags )16);
  }
#line 793
  if (st) {
#line 793
    return (st);
  }
  {
#line 795
  ctx.ext = (void *)0;
#line 796
  ctx.callback = & icb_ptr___3;
#line 797
  memset((void *)(& ctx.info), 0, sizeof(ctx.info));
#line 798
  tmp___3 = adns__findtype((adns_rrtype )65537);
#line 798
  st = adns__internal_submit((adns_state )pai->ads, & nqu, tmp___3, & (pai->qu)->vb,
                             id, (adns_queryflags )16, (struct timeval )pai->now,
                             (qcontext const   *)(& ctx));
  }
#line 801
  if (st) {
#line 801
    return (st);
  }
#line 803
  nqu->parent = (adns_query )pai->qu;
  {
#line 804
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 804
    nqu->siblings.next = (adns_query )0;
#line 804
    nqu->siblings.back = (pai->qu)->children.tail;
#line 804
    if ((pai->qu)->children.tail) {
#line 804
      ((pai->qu)->children.tail)->siblings.next = nqu;
    } else {
#line 804
      (pai->qu)->children.head = nqu;
    }
#line 804
    (pai->qu)->children.tail = nqu;
#line 804
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 805
  return ((adns_status )0);
}
}
#line 812 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_strpair___3(adns_query qu , void *datap ) 
{ 
  adns_rr_strpair *rrp ;

  {
  {
#line 813
  rrp = (adns_rr_strpair *)datap;
#line 815
  adns__makefinal_str(qu, & rrp->array[0]);
#line 816
  adns__makefinal_str(qu, & rrp->array[1]);
  }
#line 817
  return;
}
}
#line 823 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_intstrpair___3(adns_query qu , void *datap ) 
{ 
  adns_rr_intstrpair *rrp ;

  {
  {
#line 824
  rrp = (adns_rr_intstrpair *)datap;
#line 826
  adns__makefinal_str(qu, & rrp->array[0].str);
#line 827
  adns__makefinal_str(qu, & rrp->array[1].str);
  }
#line 828
  return;
}
}
#line 834 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_hinfo___3(parseinfo const   *pai , int cbyte___3 , int max ,
                                void *datap ) 
{ 
  adns_rr_intstrpair *rrp ;
  adns_status st ;
  int i ;

  {
#line 836
  rrp = (adns_rr_intstrpair *)datap;
#line 840
  i = 0;
  {
#line 840
  while (1) {
    while_continue: /* CIL Label */ ;
#line 840
    if (! (i < 2)) {
#line 840
      goto while_break;
    }
    {
#line 841
    st = pap_qstring___3(pai, & cbyte___3, max, & rrp->array[i].i, & rrp->array[i].str);
    }
#line 842
    if (st) {
#line 842
      return (st);
    }
#line 840
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 845
  if (cbyte___3 != max) {
#line 845
    return ((adns_status )104);
  }
#line 847
  return ((adns_status )0);
}
}
#line 854 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_mailbox822___3(parseinfo const   *pai , int *cbyte_io , int max ,
                                      char **mb_r ) 
{ 
  int lablen ;
  int labstart ;
  int i ;
  int needquote ;
  int c ;
  int r ;
  int neednorm ;
  unsigned char const   *p ;
  char *str ;
  findlabel_state fls ;
  adns_status st ;
  vbuf *vb___0 ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 863
  vb___0 = & (pai->qu)->vb;
#line 864
  vb___0->used = 0;
#line 865
  adns__findlabel_start(& fls, (adns_state )pai->ads, -1, (adns_query )pai->qu, (byte const   *)pai->dgram,
                        (int )pai->dglen, max, *cbyte_io, cbyte_io);
#line 869
  st = adns__findlabel_next(& fls, & lablen, & labstart);
  }
#line 870
  if (! lablen) {
    {
#line 871
    adns__vbuf_appendstr(vb___0, ".");
    }
#line 872
    goto x_ok;
  }
#line 875
  neednorm = 1;
#line 876
  i = 0;
#line 876
  needquote = 0;
#line 876
  p = (unsigned char const   *)(pai->dgram + labstart);
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (! (i < lablen)) {
#line 876
      goto while_break;
    }
#line 877
    tmp = p;
#line 877
    p ++;
#line 877
    c = (int )*tmp;
#line 878
    if ((c & -129) < 32) {
#line 878
      return ((adns_status )104);
    } else
#line 878
    if ((c & -129) == 127) {
#line 878
      return ((adns_status )104);
    }
#line 879
    if (c == 46) {
#line 879
      if (! neednorm) {
#line 879
        neednorm = 1;
      } else {
#line 879
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 880
    if (c == 32) {
#line 880
      needquote ++;
    } else
#line 880
    if (c >= 127) {
#line 880
      needquote ++;
    } else {
      {
#line 880
      tmp___0 = ctype_822special(c);
      }
#line 880
      if (tmp___0) {
#line 880
        needquote ++;
      } else {
#line 881
        neednorm = 0;
      }
    }
#line 876
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 884
  if (needquote) {
#line 884
    goto _L___0;
  } else
#line 884
  if (neednorm) {
    _L___0: /* CIL Label */ 
    {
#line 885
    r = adns__vbuf_ensure(vb___0, (lablen + needquote) + 4);
    }
#line 885
    if (! r) {
#line 885
      return ((adns_status )1);
    }
    {
#line 886
    adns__vbuf_appendq(vb___0, (byte const   *)"\"", 1);
#line 887
    i = 0;
#line 887
    needquote = 0;
#line 887
    p = (unsigned char const   *)(pai->dgram + labstart);
    }
    {
#line 887
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 887
      if (! (i < lablen)) {
#line 887
        goto while_break___0;
      }
#line 888
      c = (int )*p;
#line 889
      if (c == 34) {
        {
#line 889
        adns__vbuf_appendq(vb___0, (byte const   *)"\\", 1);
        }
      } else
#line 889
      if (c == 92) {
        {
#line 889
        adns__vbuf_appendq(vb___0, (byte const   *)"\\", 1);
        }
      }
      {
#line 890
      adns__vbuf_appendq(vb___0, p, 1);
#line 887
      i ++;
#line 887
      p ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 892
    adns__vbuf_appendq(vb___0, (byte const   *)"\"", 1);
    }
  } else {
    {
#line 894
    r = adns__vbuf_append(vb___0, (byte const   *)(pai->dgram + labstart), lablen);
    }
#line 894
    if (! r) {
#line 894
      return ((adns_status )1);
    }
  }
  {
#line 897
  r = adns__vbuf_appendstr(vb___0, "@");
  }
#line 897
  if (! r) {
#line 897
    return ((adns_status )1);
  }
  {
#line 899
  st = adns__parse_domain_more(& fls, (adns_state )pai->ads, (adns_query )pai->qu,
                               vb___0, (parsedomain_flags )0, (byte const   *)pai->dgram);
  }
#line 900
  if (st) {
#line 900
    return (st);
  }
  x_ok: 
  {
#line 903
  tmp___1 = adns__alloc_interim((adns_query )pai->qu, (size_t )(vb___0->used + 1));
#line 903
  str = (char *)tmp___1;
  }
#line 903
  if (! str) {
#line 903
    return ((adns_status )1);
  }
  {
#line 904
  memcpy((void */* __restrict  */)str, (void const   */* __restrict  */)vb___0->buf,
         (size_t )vb___0->used);
#line 905
  *(str + vb___0->used) = (char)0;
#line 906
  *mb_r = str;
  }
#line 907
  return ((adns_status )0);
}
}
#line 910 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_mailbox___3(parseinfo const   *pai , int *cbyte_io , int max ,
                                   char **mb_r ) 
{ 
  adns_status tmp ;
  adns_status tmp___0 ;

  {
#line 912
  if ((unsigned int const   )((pai->qu)->typei)->typekey & 131072U) {
    {
#line 913
    tmp = pap_mailbox822___3(pai, cbyte_io, max, mb_r);
    }
#line 913
    return (tmp);
  } else {
    {
#line 915
    tmp___0 = pap_domain___3(pai, cbyte_io, max, mb_r, (parsedomain_flags )1);
    }
#line 915
    return (tmp___0);
  }
}
}
#line 919 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_mailbox___3(vbuf *vb___0 , char const   *mailbox ) 
{ 
  adns_status tmp ;

  {
  {
#line 920
  tmp = csp_domain___3(vb___0, mailbox);
  }
#line 920
  return (tmp);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_rp___3(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  adns_rr_strpair *rrp ;
  adns_status st ;

  {
  {
#line 929
  rrp = (adns_rr_strpair *)datap;
#line 932
  st = pap_mailbox___3(pai, & cbyte___3, max, & rrp->array[0]);
  }
#line 933
  if (st) {
#line 933
    return (st);
  }
  {
#line 935
  st = pap_domain___3(pai, & cbyte___3, max, & rrp->array[1], (parsedomain_flags )1);
  }
#line 936
  if (st) {
#line 936
    return (st);
  }
#line 938
  if (cbyte___3 != max) {
#line 938
    return ((adns_status )104);
  }
#line 939
  return ((adns_status )0);
}
}
#line 942 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_rp___3(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_strpair const   *rrp ;
  adns_status st ;
  int tmp ;

  {
  {
#line 943
  rrp = (adns_rr_strpair const   *)datap;
#line 946
  st = csp_mailbox___3(vb___0, (char const   *)rrp->array[0]);
  }
#line 946
  if (st) {
#line 946
    return (st);
  }
  {
#line 947
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 947
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 947
    if (! tmp) {
#line 947
      return ((adns_status )1);
    }
#line 947
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 948
  st = csp_domain___3(vb___0, (char const   *)rrp->array[1]);
  }
#line 948
  if (st) {
#line 948
    return (st);
  }
#line 950
  return ((adns_status )0);
}
}
#line 957 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_soa___3(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  adns_rr_soa *rrp ;
  byte const   *dgram ;
  adns_status st ;
  int msw ;
  int lsw ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 959
  rrp = (adns_rr_soa *)datap;
#line 960
  dgram = (byte const   *)pai->dgram;
#line 964
  if ((pai->qu)->flags & 64) {
#line 964
    tmp = 1;
  } else {
#line 964
    tmp = 0;
  }
  {
#line 964
  st = pap_domain___3(pai, & cbyte___3, max, & rrp->mname, (parsedomain_flags )tmp);
  }
#line 966
  if (st) {
#line 966
    return (st);
  }
  {
#line 968
  st = pap_mailbox___3(pai, & cbyte___3, max, & rrp->rname);
  }
#line 969
  if (st) {
#line 969
    return (st);
  }
#line 971
  if (cbyte___3 + 20 != max) {
#line 971
    return ((adns_status )104);
  }
#line 973
  i = 0;
  {
#line 973
  while (1) {
    while_continue: /* CIL Label */ ;
#line 973
    if (! (i < 5)) {
#line 973
      goto while_break;
    }
#line 974
    msw = 0;
#line 974
    tmp___0 = cbyte___3;
#line 974
    cbyte___3 ++;
#line 974
    msw |= (int )(((int const   )*(dgram + tmp___0) & 255) << 8);
#line 974
    tmp___1 = cbyte___3;
#line 974
    cbyte___3 ++;
#line 974
    msw |= (int )((int const   )*(dgram + tmp___1) & 255);
#line 975
    lsw = 0;
#line 975
    tmp___2 = cbyte___3;
#line 975
    cbyte___3 ++;
#line 975
    lsw |= (int )(((int const   )*(dgram + tmp___2) & 255) << 8);
#line 975
    tmp___3 = cbyte___3;
#line 975
    cbyte___3 ++;
#line 975
    lsw |= (int )((int const   )*(dgram + tmp___3) & 255);
#line 976
    *(& rrp->serial + i) = (unsigned long )((msw << 16) | lsw);
#line 973
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 979
  return ((adns_status )0);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_soa___3(adns_query qu , void *datap ) 
{ 
  adns_rr_soa *rrp ;

  {
  {
#line 983
  rrp = (adns_rr_soa *)datap;
#line 985
  adns__makefinal_str(qu, & rrp->mname);
#line 986
  adns__makefinal_str(qu, & rrp->rname);
  }
#line 987
  return;
}
}
#line 989 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_soa___3(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_soa const   *rrp ;
  char buf___17[20] ;
  int i ;
  adns_status st ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 990
  rrp = (adns_rr_soa const   *)datap;
#line 995
  st = csp_domain___3(vb___0, (char const   *)rrp->mname);
  }
#line 995
  if (st) {
#line 995
    return (st);
  }
  {
#line 996
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 996
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 996
    if (! tmp) {
#line 996
      return ((adns_status )1);
    }
#line 996
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 997
  st = csp_mailbox___3(vb___0, (char const   *)rrp->rname);
  }
#line 997
  if (st) {
#line 997
    return (st);
  }
#line 999
  i = 0;
  {
#line 999
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 999
    if (! (i < 5)) {
#line 999
      goto while_break___0;
    }
    {
#line 1000
    sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %lu",
            *(& rrp->serial + i));
    }
    {
#line 1001
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1001
      tmp___0 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
      }
#line 1001
      if (! tmp___0) {
#line 1001
        return ((adns_status )1);
      }
#line 1001
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 999
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1004
  return ((adns_status )0);
}
}
#line 1011 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status qdpl_srv___3(adns_state ads___7 , char const   **p_io , char const   *pe ,
                                int labelnum , char *label_r , int *ll_io , adns_queryflags flags ,
                                typeinfo const   *typei ) 
{ 
  int useflags ;
  char const   *p_orig ;
  adns_status st ;
  int ll ;
  void *tmp ;

  {
#line 1020
  if (labelnum < 2) {
#line 1020
    if (! ((unsigned int )flags & 16U)) {
#line 1021
      useflags = 16;
#line 1022
      p_orig = *p_io;
    } else {
#line 1024
      useflags = (int )flags;
#line 1025
      p_orig = (char const   *)0;
    }
  } else {
#line 1024
    useflags = (int )flags;
#line 1025
    p_orig = (char const   *)0;
  }
  {
#line 1027
  st = adns__qdpl_normal(ads___7, p_io, pe, labelnum, (char *)label_r, ll_io, (adns_queryflags )useflags,
                         typei);
  }
#line 1028
  if (st) {
#line 1028
    return (st);
  }
#line 1030
  if (p_orig) {
#line 1031
    ll = *ll_io;
#line 1032
    if (! ll) {
#line 1033
      return ((adns_status )201);
    } else
#line 1032
    if ((int )*(label_r + 0) != 95) {
#line 1033
      return ((adns_status )201);
    }
    {
#line 1034
    tmp = memchr((void const   *)(p_orig + 1), '\\', (size_t )(pe - (p_orig + 1)));
    }
#line 1034
    if (tmp) {
#line 1035
      return ((adns_status )201);
    }
  }
#line 1037
  return ((adns_status )0);
}
}
#line 1040 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_srv_begin___3(parseinfo const   *pai , int *cbyte_io , int max ,
                                     adns_rr_srvha *rrp ) 
{ 
  byte const   *dgram ;
  int ti ;
  int cbyte___3 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1043
  dgram = (byte const   *)pai->dgram;
#line 1046
  cbyte___3 = *cbyte_io;
#line 1047
  tmp = *cbyte_io + 6;
#line 1047
  *cbyte_io = tmp;
#line 1047
  if (tmp > max) {
#line 1047
    return ((adns_status )104);
  }
#line 1049
  ti = 0;
#line 1049
  tmp___0 = cbyte___3;
#line 1049
  cbyte___3 ++;
#line 1049
  ti |= (int )(((int const   )*(dgram + tmp___0) & 255) << 8);
#line 1049
  tmp___1 = cbyte___3;
#line 1049
  cbyte___3 ++;
#line 1049
  ti |= (int )((int const   )*(dgram + tmp___1) & 255);
#line 1049
  rrp->priority = ti;
#line 1050
  ti = 0;
#line 1050
  tmp___2 = cbyte___3;
#line 1050
  cbyte___3 ++;
#line 1050
  ti |= (int )(((int const   )*(dgram + tmp___2) & 255) << 8);
#line 1050
  tmp___3 = cbyte___3;
#line 1050
  cbyte___3 ++;
#line 1050
  ti |= (int )((int const   )*(dgram + tmp___3) & 255);
#line 1050
  rrp->weight = ti;
#line 1051
  ti = 0;
#line 1051
  tmp___4 = cbyte___3;
#line 1051
  cbyte___3 ++;
#line 1051
  ti |= (int )(((int const   )*(dgram + tmp___4) & 255) << 8);
#line 1051
  tmp___5 = cbyte___3;
#line 1051
  cbyte___3 ++;
#line 1051
  ti |= (int )((int const   )*(dgram + tmp___5) & 255);
#line 1051
  rrp->port = ti;
#line 1052
  return ((adns_status )0);
}
}
#line 1055 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_srvraw___3(parseinfo const   *pai , int cbyte___3 , int max ,
                                 void *datap ) 
{ 
  adns_rr_srvraw *rrp ;
  adns_status st ;
  int tmp ;

  {
  {
#line 1057
  rrp = (adns_rr_srvraw *)datap;
#line 1060
  st = pap_srv_begin___3(pai, & cbyte___3, max, (adns_rr_srvha *)datap);
  }
#line 1061
  if (st) {
#line 1061
    return (st);
  }
#line 1063
  if ((pai->qu)->flags & 64) {
#line 1063
    tmp = 1;
  } else {
#line 1063
    tmp = 0;
  }
  {
#line 1063
  st = pap_domain___3(pai, & cbyte___3, max, & rrp->host, (parsedomain_flags )tmp);
  }
#line 1065
  if (st) {
#line 1065
    return (st);
  }
#line 1067
  if (cbyte___3 != max) {
#line 1067
    return ((adns_status )104);
  }
#line 1068
  return ((adns_status )0);
}
}
#line 1071 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_srvha___3(parseinfo const   *pai , int cbyte___3 , int max ,
                                void *datap ) 
{ 
  adns_rr_srvha *rrp ;
  adns_status st ;

  {
  {
#line 1073
  rrp = (adns_rr_srvha *)datap;
#line 1076
  st = pap_srv_begin___3(pai, & cbyte___3, max, (adns_rr_srvha *)datap);
  }
#line 1076
  if (st) {
#line 1076
    return (st);
  }
  {
#line 1077
  st = pap_hostaddr___3(pai, & cbyte___3, max, & rrp->ha);
  }
#line 1077
  if (st) {
#line 1077
    return (st);
  }
#line 1078
  if (cbyte___3 != max) {
#line 1078
    return ((adns_status )104);
  }
#line 1079
  return ((adns_status )0);
}
}
#line 1082 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_srvraw___3(adns_query qu , void *datap ) 
{ 
  adns_rr_srvraw *rrp ;

  {
  {
#line 1083
  rrp = (adns_rr_srvraw *)datap;
#line 1084
  adns__makefinal_str(qu, & rrp->host);
  }
#line 1085
  return;
}
}
#line 1087 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_srvha___3(adns_query qu , void *datap ) 
{ 
  adns_rr_srvha *rrp ;

  {
  {
#line 1088
  rrp = (adns_rr_srvha *)datap;
#line 1089
  mfp_hostaddr___3(qu, & rrp->ha);
  }
#line 1090
  return;
}
}
#line 1092 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_srv___3(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_srvraw const   *ap ;
  adns_rr_srvraw const   *bp ;

  {
#line 1093
  ap = (adns_rr_srvraw const   *)datap_a;
#line 1093
  bp = (adns_rr_srvraw const   *)datap_b;
#line 1096
  if (ap->priority < bp->priority) {
#line 1096
    return (0);
  }
#line 1097
  if (ap->priority > bp->priority) {
#line 1097
    return (1);
  }
#line 1098
  return (0);
}
}
#line 1101 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_srv_begin___3(vbuf *vb___0 , adns_rr_srvha const   *rrp ) 
{ 
  char buf___17[30] ;
  int tmp ;

  {
  {
#line 1104
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"%u %u %u ",
          rrp->priority, rrp->weight, rrp->port);
  }
  {
#line 1105
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1105
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 1105
    if (! tmp) {
#line 1105
      return ((adns_status )1);
    }
#line 1105
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1106
  return ((adns_status )0);
}
}
#line 1109 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_srvraw___3(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_srvraw const   *rrp ;
  adns_status st ;
  adns_status tmp ;

  {
  {
#line 1110
  rrp = (adns_rr_srvraw const   *)datap;
#line 1113
  st = csp_srv_begin___3(vb___0, (adns_rr_srvha const   *)((void const   *)rrp));
  }
#line 1113
  if (st) {
#line 1113
    return (st);
  }
  {
#line 1114
  tmp = csp_domain___3(vb___0, (char const   *)rrp->host);
  }
#line 1114
  return (tmp);
}
}
#line 1117 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_srvha___3(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_srvha const   *rrp ;
  adns_status st ;
  adns_status tmp ;

  {
  {
#line 1118
  rrp = (adns_rr_srvha const   *)datap;
#line 1121
  st = csp_srv_begin___3(vb___0, (adns_rr_srvha const   *)datap);
  }
#line 1121
  if (st) {
#line 1121
    return (st);
  }
  {
#line 1122
  tmp = csp_hostaddr___3(vb___0, & rrp->ha);
  }
#line 1122
  return (tmp);
}
}
#line 1125 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void postsort_srv___3(adns_state ads___7 , void *array , int nrrs , struct typeinfo  const  *typei ) 
{ 
  char *workbegin ;
  char *workend ;
  char *search ;
  char *arrayend ;
  adns_rr_srvha const   *rr ;
  union __anonunion_rrtmp_89___3 rrtmp ;
  int cpriority ;
  int totalweight ;
  int runtotal ;
  long randval ;

  {
#line 1138
  workbegin = (char *)array;
#line 1138
  arrayend = workbegin + typei->rrsz * (int const   )nrrs;
  {
#line 1138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1138
    if (! ((unsigned long )workbegin < (unsigned long )arrayend)) {
#line 1138
      goto while_break;
    }
#line 1141
    rr = (adns_rr_srvha const   *)((void *)workbegin);
#line 1141
    cpriority = (int )rr->priority;
#line 1143
    workend = workbegin;
#line 1143
    totalweight = 0;
    {
#line 1143
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1143
      if ((unsigned long )workend < (unsigned long )arrayend) {
#line 1143
        rr = (adns_rr_srvha const   *)((void *)workend);
#line 1143
        if (! (rr->priority == (int const   )cpriority)) {
#line 1143
          goto while_break___0;
        }
      } else {
#line 1143
        goto while_break___0;
      }
#line 1146
      totalweight += (int )rr->weight;
#line 1143
      workend += typei->rrsz;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1155
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1155
      if (! ((unsigned long )(workbegin + typei->rrsz) < (unsigned long )workend)) {
#line 1155
        goto while_break___1;
      }
      {
#line 1159
      randval = nrand48((unsigned short *)(ads___7->rand48xsubi));
#line 1160
      randval %= (long )(totalweight + 1);
#line 1167
      search = workbegin;
#line 1167
      runtotal = 0;
      }
      {
#line 1167
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1167
        rr = (adns_rr_srvha const   *)((void *)search);
#line 1167
        runtotal += (int )rr->weight;
#line 1167
        if (! ((long )runtotal < randval)) {
#line 1167
          goto while_break___2;
        }
#line 1167
        search += typei->rrsz;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1170
      if (! ((unsigned long )search < (unsigned long )arrayend)) {
        {
#line 1170
        __assert_fail("search < arrayend", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                      1170U, "postsort_srv");
        }
      }
#line 1171
      totalweight -= (int )rr->weight;
#line 1172
      if ((unsigned long )search != (unsigned long )workbegin) {
        {
#line 1173
        memcpy((void */* __restrict  */)(& rrtmp), (void const   */* __restrict  */)workbegin,
               (size_t )typei->rrsz);
#line 1174
        memcpy((void */* __restrict  */)workbegin, (void const   */* __restrict  */)search,
               (size_t )typei->rrsz);
#line 1175
        memcpy((void */* __restrict  */)search, (void const   */* __restrict  */)(& rrtmp),
               (size_t )typei->rrsz);
        }
      }
#line 1155
      workbegin += typei->rrsz;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1138
    workbegin = workend;
  }
  while_break: /* CIL Label */ ;
  }
#line 1184
  return;
}
}
#line 1190 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_byteblock___3(adns_query qu , void *datap ) 
{ 
  adns_rr_byteblock *rrp ;
  void *bytes___3 ;

  {
  {
#line 1191
  rrp = (adns_rr_byteblock *)datap;
#line 1192
  bytes___3 = (void *)rrp->data;
#line 1193
  adns__makefinal_block(qu, & bytes___3, (size_t )rrp->len);
#line 1194
  rrp->data = (unsigned char *)bytes___3;
  }
#line 1195
  return;
}
}
#line 1201 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_opaque___3(parseinfo const   *pai , int cbyte___3 , int max ,
                                 void *datap ) 
{ 
  adns_rr_byteblock *rrp ;
  void *tmp ;

  {
  {
#line 1203
  rrp = (adns_rr_byteblock *)datap;
#line 1205
  rrp->len = max - cbyte___3;
#line 1206
  tmp = adns__alloc_interim((adns_query )pai->qu, (size_t )rrp->len);
#line 1206
  rrp->data = (unsigned char *)tmp;
  }
#line 1207
  if (! rrp->data) {
#line 1207
    return ((adns_status )1);
  }
  {
#line 1208
  memcpy((void */* __restrict  */)rrp->data, (void const   */* __restrict  */)(pai->dgram + cbyte___3),
         (size_t )rrp->len);
  }
#line 1209
  return ((adns_status )0);
}
}
#line 1212 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_opaque___3(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_byteblock const   *rrp ;
  char buf___17[10] ;
  int l ;
  unsigned char *p ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1213
  rrp = (adns_rr_byteblock const   *)datap;
#line 1218
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"\\# %d",
          rrp->len);
  }
  {
#line 1219
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1219
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 1219
    if (! tmp) {
#line 1219
      return ((adns_status )1);
    }
#line 1219
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1221
  l = (int )rrp->len;
#line 1221
  p = (unsigned char *)rrp->data;
  {
#line 1221
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1221
    if (! (l >= 4)) {
#line 1221
      goto while_break___0;
    }
    {
#line 1224
    sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %02x%02x%02x%02x",
            (int )*(p + 0), (int )*(p + 1), (int )*(p + 2), (int )*(p + 3));
    }
    {
#line 1225
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1225
      tmp___0 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
      }
#line 1225
      if (! tmp___0) {
#line 1225
        return ((adns_status )1);
      }
#line 1225
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1221
    l -= 4;
#line 1221
    p += 4;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1227
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1227
    if (! (l > 0)) {
#line 1227
      goto while_break___2;
    }
    {
#line 1230
    sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %02x",
            (int )*p);
    }
    {
#line 1231
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 1231
      tmp___1 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
      }
#line 1231
      if (! tmp___1) {
#line 1231
        return ((adns_status )1);
      }
#line 1231
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1227
    l --;
#line 1227
    p ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1233
  return ((adns_status )0);
}
}
#line 1240 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_flat___3(adns_query qu , void *data___0 ) 
{ 


  {
#line 1240
  return;
}
}
#line 1261 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static typeinfo const   typeinfos___3[17]  = 
#line 1261
  {      {(adns_rrtype )1, "A", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.inaddr)),
      & mf_flat___3, & cs_inaddr___3, & pa_inaddr___3, & di_inaddr___3, (adns_status (*)(adns_state ads ,
                                                                                         char const   **p_io ,
                                                                                         char const   *pe ,
                                                                                         int labelnum ,
                                                                                         char *label_r ,
                                                                                         int *ll_io ,
                                                                                         adns_queryflags flags ,
                                                                                         struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )2,
      "NS", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___3, & cs_domain___3,
      & pa_host_raw___3, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )5,
      "CNAME", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___3,
      & cs_domain___3, & pa_dom_raw___3, (int (*)(adns_state ads , void const   *datap_a ,
                                                  void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                              char const   **p_io ,
                                                                                              char const   *pe ,
                                                                                              int labelnum ,
                                                                                              char *label_r ,
                                                                                              int *ll_io ,
                                                                                              adns_queryflags flags ,
                                                                                              struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )6,
      "SOA", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.soa)), & mf_soa___3, & cs_soa___3,
      & pa_soa___3, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )12,
      "PTR", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___3, & cs_domain___3,
      & pa_host_raw___3, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )13,
      "HINFO", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.intstrpair)),
      & mf_intstrpair___3, & cs_hinfo___3, & pa_hinfo___3, (int (*)(adns_state ads ,
                                                                    void const   *datap_a ,
                                                                    void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )15,
      "MX", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.intstr)), & mf_intstr___3,
      & cs_inthost___3, & pa_mx_raw___3, & di_mx_raw___3, (adns_status (*)(adns_state ads ,
                                                                           char const   **p_io ,
                                                                           char const   *pe ,
                                                                           int labelnum ,
                                                                           char *label_r ,
                                                                           int *ll_io ,
                                                                           adns_queryflags flags ,
                                                                           struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )16,
      "TXT", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.manyistr)),
      & mf_manyistr___3, & cs_txt___3, & pa_txt___3, (int (*)(adns_state ads , void const   *datap_a ,
                                                              void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )17,
      "RP", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.strpair)), & mf_strpair___3,
      & cs_rp___3, & pa_rp___3, (int (*)(adns_state ads , void const   *datap_a ,
                                         void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                     char const   **p_io ,
                                                                                     char const   *pe ,
                                                                                     int labelnum ,
                                                                                     char *label_r ,
                                                                                     int *ll_io ,
                                                                                     adns_queryflags flags ,
                                                                                     struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )33,
      "SRV", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.srvraw)), & mf_srvraw___3,
      & cs_srvraw___3, & pa_srvraw___3, & di_srv___3, & qdpl_srv___3, & postsort_srv___3}, 
        {(adns_rrtype )65537,
      "A", "addr", (int )sizeof(*(((adns_answer *)0)->rrs.addr)), & mf_flat___3, & cs_addr___3,
      & pa_addr___3, & di_addr___3, (adns_status (*)(adns_state ads , char const   **p_io ,
                                                     char const   *pe , int labelnum ,
                                                     char *label_r , int *ll_io ,
                                                     adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65538,
      "NS", "+addr", (int )sizeof(*(((adns_answer *)0)->rrs.hostaddr)), & mf_hostaddr___3,
      & cs_hostaddr___3, & pa_hostaddr___3, & di_hostaddr___3, (adns_status (*)(adns_state ads ,
                                                                                char const   **p_io ,
                                                                                char const   *pe ,
                                                                                int labelnum ,
                                                                                char *label_r ,
                                                                                int *ll_io ,
                                                                                adns_queryflags flags ,
                                                                                struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65548,
      "PTR", "checked", (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___3,
      & cs_domain___3, & pa_ptr___3, (int (*)(adns_state ads , void const   *datap_a ,
                                              void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                          char const   **p_io ,
                                                                                          char const   *pe ,
                                                                                          int labelnum ,
                                                                                          char *label_r ,
                                                                                          int *ll_io ,
                                                                                          adns_queryflags flags ,
                                                                                          struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65551,
      "MX", "+addr", (int )sizeof(*(((adns_answer *)0)->rrs.inthostaddr)), & mf_inthostaddr___3,
      & cs_inthostaddr___3, & pa_mx___3, & di_mx___3, (adns_status (*)(adns_state ads ,
                                                                       char const   **p_io ,
                                                                       char const   *pe ,
                                                                       int labelnum ,
                                                                       char *label_r ,
                                                                       int *ll_io ,
                                                                       adns_queryflags flags ,
                                                                       struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65569,
      "SRV", "+addr", (int )sizeof(*(((adns_answer *)0)->rrs.srvha)), & mf_srvha___3,
      & cs_srvha___3, & pa_srvha___3, & di_srv___3, & qdpl_srv___3, & postsort_srv___3}, 
        {(adns_rrtype )131078,
      "SOA", "822", (int )sizeof(*(((adns_answer *)0)->rrs.soa)), & mf_soa___3, & cs_soa___3,
      & pa_soa___3, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )131089,
      "RP", "822", (int )sizeof(*(((adns_answer *)0)->rrs.strpair)), & mf_strpair___3,
      & cs_rp___3, & pa_rp___3, (int (*)(adns_state ads , void const   *datap_a ,
                                         void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                     char const   **p_io ,
                                                                                     char const   *pe ,
                                                                                     int labelnum ,
                                                                                     char *label_r ,
                                                                                     int *ll_io ,
                                                                                     adns_queryflags flags ,
                                                                                     struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}};
#line 1288 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static struct typeinfo  const  typeinfo_unknown___3  = 
#line 1288
     {(adns_rrtype )262144, (char const   *)0, "unknown", (int )sizeof(*(((adns_answer *)0)->rrs.byteblock)),
    & mf_byteblock___3, & cs_opaque___3, & pa_opaque___3, (int (*)(adns_state ads ,
                                                                   void const   *datap_a ,
                                                                   void const   *datap_b ))0,
    (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                     char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
    (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0};
#line 55 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_query_alloc___3(adns_state ads___7 , adns_query qu ) 
{ 
  allocnode *an ;
  int tmp ;

  {
#line 58
  if (qu->allocations.head) {
#line 58
    if (! (! (qu->allocations.head)->back)) {
      {
#line 58
      __assert_fail("! (qu->allocations).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    59U, "checkc_query_alloc");
      }
    }
#line 58
    an = qu->allocations.head;
    {
#line 58
    while (1) {
      while_continue: /* CIL Label */ ;
#line 58
      if (! an) {
#line 58
        goto while_break;
      }
#line 58
      if (an->next) {
#line 58
        tmp = (unsigned long )an == (unsigned long )(an->next)->back;
      } else {
#line 58
        tmp = (unsigned long )an == (unsigned long )qu->allocations.tail;
      }
#line 58
      if (! tmp) {
        {
#line 58
        __assert_fail("(an)-> next ? (an) == (an)-> next-> back : (an) == (qu->allocations).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      59U, "checkc_query_alloc");
        }
      }
#line 58
      an = an->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 60
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_query___3(adns_state ads___7 , adns_query qu ) 
{ 
  adns_query child ;

  {
#line 65
  if (! (qu->udpnextserver < ads___7->nservers)) {
    {
#line 65
    __assert_fail("qu->udpnextserver < ads->nservers", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  65U, "checkc_query");
    }
  }
#line 66
  if (! (! (qu->udpsent & (0xffffffffffffffffUL << ads___7->nservers)))) {
    {
#line 66
    __assert_fail("!(qu->udpsent & (~0UL << ads->nservers))", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  66U, "checkc_query");
    }
  }
#line 67
  if (! (qu->search_pos <= ads___7->nsearchlist)) {
    {
#line 67
    __assert_fail("qu->search_pos <= ads->nsearchlist", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  67U, "checkc_query");
    }
  }
#line 68
  if (qu->parent) {
    {
#line 68
    while (1) {
      while_continue: /* CIL Label */ ;
#line 68
      child = (qu->parent)->children.head;
      {
#line 68
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 68
        if (! ((unsigned long )child != (unsigned long )qu)) {
#line 68
          goto while_break___0;
        }
#line 68
        if (! child) {
          {
#line 68
          __assert_fail("(child)", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        68U, "checkc_query");
          }
        }
#line 68
        child = child->siblings.next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 68
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 69
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_notcpbuf___3(adns_state ads___7 ) 
{ 


  {
#line 72
  if (! (! ads___7->tcpsend.used)) {
    {
#line 72
    __assert_fail("!ads->tcpsend.used", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  72U, "checkc_notcpbuf");
    }
  }
#line 73
  if (! (! ads___7->tcprecv.used)) {
    {
#line 73
    __assert_fail("!ads->tcprecv.used", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  73U, "checkc_notcpbuf");
    }
  }
#line 74
  if (! (! ads___7->tcprecv_skip)) {
    {
#line 74
    __assert_fail("!ads->tcprecv_skip", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  74U, "checkc_notcpbuf");
    }
  }
#line 75
  return;
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_global___3(adns_state ads___7 ) 
{ 
  int i ;

  {
#line 80
  if (! (ads___7->udpsocket >= 0)) {
    {
#line 80
    __assert_fail("ads->udpsocket >= 0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  80U, "checkc_global");
    }
  }
#line 82
  i = 0;
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! (i < ads___7->nsortlist)) {
#line 82
      goto while_break;
    }
#line 83
    if (! (! (ads___7->sortlist[i].base.s_addr & ~ ads___7->sortlist[i].mask.s_addr))) {
      {
#line 83
      __assert_fail("!(ads->sortlist[i].base.s_addr & ~ads->sortlist[i].mask.s_addr)",
                    "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    83U, "checkc_global");
      }
    }
#line 82
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  if (ads___7->tcpserver >= 0) {
#line 85
    if (! (ads___7->tcpserver < ads___7->nservers)) {
      {
#line 85
      __assert_fail("ads->tcpserver >= 0 && ads->tcpserver < ads->nservers", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    85U, "checkc_global");
      }
    }
  } else {
    {
#line 85
    __assert_fail("ads->tcpserver >= 0 && ads->tcpserver < ads->nservers", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  85U, "checkc_global");
    }
  }
  {
#line 88
  if ((unsigned int )ads___7->tcpstate == 1U) {
#line 88
    goto case_1;
  }
#line 93
  if ((unsigned int )ads___7->tcpstate == 3U) {
#line 93
    goto case_3;
  }
#line 93
  if ((unsigned int )ads___7->tcpstate == 0U) {
#line 93
    goto case_3;
  }
#line 97
  if ((unsigned int )ads___7->tcpstate == 2U) {
#line 97
    goto case_2;
  }
#line 101
  goto switch_default;
  case_1: /* CIL Label */ 
#line 89
  if (! (ads___7->tcpsocket >= 0)) {
    {
#line 89
    __assert_fail("ads->tcpsocket >= 0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  89U, "checkc_global");
    }
  }
  {
#line 90
  checkc_notcpbuf___3(ads___7);
  }
#line 91
  goto switch_break;
  case_3: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 94
  if (! (ads___7->tcpsocket == -1)) {
    {
#line 94
    __assert_fail("ads->tcpsocket == -1", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  94U, "checkc_global");
    }
  }
  {
#line 95
  checkc_notcpbuf___3(ads___7);
  }
#line 96
  goto switch_break;
  case_2: /* CIL Label */ 
#line 98
  if (! (ads___7->tcpsocket >= 0)) {
    {
#line 98
    __assert_fail("ads->tcpsocket >= 0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  98U, "checkc_global");
    }
  }
#line 99
  if (! (ads___7->tcprecv_skip <= ads___7->tcprecv.used)) {
    {
#line 99
    __assert_fail("ads->tcprecv_skip <= ads->tcprecv.used", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  99U, "checkc_global");
    }
  }
#line 100
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 102
  __assert_fail("!\"ads->tcpstate value\"", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                102U, "checkc_global");
  }
  switch_break: /* CIL Label */ ;
  }
#line 105
  if (! ads___7->searchlist) {
#line 105
    if (! (! ads___7->nsearchlist)) {
      {
#line 105
      __assert_fail("ads->searchlist || !ads->nsearchlist", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    105U, "checkc_global");
      }
    }
  }
#line 106
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_queue_udpw___3(adns_state ads___7 ) 
{ 
  adns_query qu ;
  int tmp ;

  {
#line 111
  if (ads___7->udpw.head) {
#line 111
    if (! (! (ads___7->udpw.head)->back)) {
      {
#line 111
      __assert_fail("! (ads->udpw).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    118U, "checkc_queue_udpw");
      }
    }
#line 111
    qu = ads___7->udpw.head;
    {
#line 111
    while (1) {
      while_continue: /* CIL Label */ ;
#line 111
      if (! qu) {
#line 111
        goto while_break;
      }
#line 111
      if (qu->next) {
#line 111
        tmp = (unsigned long )qu == (unsigned long )(qu->next)->back;
      } else {
#line 111
        tmp = (unsigned long )qu == (unsigned long )ads___7->udpw.tail;
      }
#line 111
      if (! tmp) {
        {
#line 111
        __assert_fail("(qu)-> next ? (qu) == (qu)-> next-> back : (qu) == (ads->udpw).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! ((unsigned int )qu->state == 0U)) {
        {
#line 111
        __assert_fail("qu->state==query_tosend", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! (qu->retries <= 15)) {
        {
#line 111
        __assert_fail("qu->retries <= 15", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! qu->udpsent) {
        {
#line 111
        __assert_fail("qu->udpsent", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! qu->children.head) {
#line 111
        if (! (! qu->children.tail)) {
          {
#line 111
          __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        118U, "checkc_queue_udpw");
          }
        }
      } else {
        {
#line 111
        __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
      {
#line 111
      checkc_query___3(ads___7, qu);
#line 111
      checkc_query_alloc___3(ads___7, qu);
#line 111
      qu = qu->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 119
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_queue_tcpw___3(adns_state ads___7 ) 
{ 
  adns_query qu ;
  int tmp ;

  {
#line 124
  if (ads___7->tcpw.head) {
#line 124
    if (! (! (ads___7->tcpw.head)->back)) {
      {
#line 124
      __assert_fail("! (ads->tcpw).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    130U, "checkc_queue_tcpw");
      }
    }
#line 124
    qu = ads___7->tcpw.head;
    {
#line 124
    while (1) {
      while_continue: /* CIL Label */ ;
#line 124
      if (! qu) {
#line 124
        goto while_break;
      }
#line 124
      if (qu->next) {
#line 124
        tmp = (unsigned long )qu == (unsigned long )(qu->next)->back;
      } else {
#line 124
        tmp = (unsigned long )qu == (unsigned long )ads___7->tcpw.tail;
      }
#line 124
      if (! tmp) {
        {
#line 124
        __assert_fail("(qu)-> next ? (qu) == (qu)-> next-> back : (qu) == (ads->tcpw).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
#line 124
      if (! ((unsigned int )qu->state == 1U)) {
        {
#line 124
        __assert_fail("qu->state==query_tcpw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
#line 124
      if (! qu->children.head) {
#line 124
        if (! (! qu->children.tail)) {
          {
#line 124
          __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        130U, "checkc_queue_tcpw");
          }
        }
      } else {
        {
#line 124
        __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
#line 124
      if (! (qu->retries <= ads___7->nservers + 1)) {
        {
#line 124
        __assert_fail("qu->retries <= ads->nservers+1", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
      {
#line 124
      checkc_query___3(ads___7, qu);
#line 124
      checkc_query_alloc___3(ads___7, qu);
#line 124
      qu = qu->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 131
  return;
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_queue_childw___3(adns_state ads___7 ) 
{ 
  adns_query parent ;
  adns_query child ;
  int tmp ;
  int tmp___0 ;

  {
#line 136
  if (ads___7->childw.head) {
#line 136
    if (! (! (ads___7->childw.head)->back)) {
      {
#line 136
      __assert_fail("! (ads->childw).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    145U, "checkc_queue_childw");
      }
    }
#line 136
    parent = ads___7->childw.head;
    {
#line 136
    while (1) {
      while_continue: /* CIL Label */ ;
#line 136
      if (! parent) {
#line 136
        goto while_break;
      }
#line 136
      if (parent->next) {
#line 136
        tmp = (unsigned long )parent == (unsigned long )(parent->next)->back;
      } else {
#line 136
        tmp = (unsigned long )parent == (unsigned long )ads___7->childw.tail;
      }
#line 136
      if (! tmp) {
        {
#line 136
        __assert_fail("(parent)-> next ? (parent) == (parent)-> next-> back : (parent) == (ads->childw).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      145U, "checkc_queue_childw");
        }
      }
#line 136
      if (! ((unsigned int )parent->state == 2U)) {
        {
#line 136
        __assert_fail("parent->state == query_childw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      145U, "checkc_queue_childw");
        }
      }
#line 136
      if (! parent->children.head) {
        {
#line 136
        __assert_fail("parent->children.head", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      145U, "checkc_queue_childw");
        }
      }
#line 136
      if (parent->children.head) {
#line 136
        if (! (! (parent->children.head)->siblings.back)) {
          {
#line 136
          __assert_fail("! (parent->children).head->siblings. back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        145U, "checkc_queue_childw");
          }
        }
#line 136
        child = parent->children.head;
        {
#line 136
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 136
          if (! child) {
#line 136
            goto while_break___0;
          }
#line 136
          if (child->siblings.next) {
#line 136
            tmp___0 = (unsigned long )child == (unsigned long )(child->siblings.next)->siblings.back;
          } else {
#line 136
            tmp___0 = (unsigned long )child == (unsigned long )parent->children.tail;
          }
#line 136
          if (! tmp___0) {
            {
#line 136
            __assert_fail("(child)->siblings. next ? (child) == (child)->siblings. next->siblings. back : (child) == (parent->children).tail",
                          "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                          145U, "checkc_queue_childw");
            }
          }
#line 136
          if (! ((unsigned long )child->parent == (unsigned long )parent)) {
            {
#line 136
            __assert_fail("child->parent == parent", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                          145U, "checkc_queue_childw");
            }
          }
#line 136
          if (! ((unsigned int )child->state != 3U)) {
            {
#line 136
            __assert_fail("child->state != query_done", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                          145U, "checkc_queue_childw");
            }
          }
#line 136
          child = child->siblings.next;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 136
      checkc_query___3(ads___7, parent);
#line 136
      checkc_query_alloc___3(ads___7, parent);
#line 136
      parent = parent->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 146
  return;
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_queue_output___3(adns_state ads___7 ) 
{ 
  adns_query qu ;
  int tmp ;

  {
#line 151
  if (ads___7->output.head) {
#line 151
    if (! (! (ads___7->output.head)->back)) {
      {
#line 151
      __assert_fail("! (ads->output).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    157U, "checkc_queue_output");
      }
    }
#line 151
    qu = ads___7->output.head;
    {
#line 151
    while (1) {
      while_continue: /* CIL Label */ ;
#line 151
      if (! qu) {
#line 151
        goto while_break;
      }
#line 151
      if (qu->next) {
#line 151
        tmp = (unsigned long )qu == (unsigned long )(qu->next)->back;
      } else {
#line 151
        tmp = (unsigned long )qu == (unsigned long )ads___7->output.tail;
      }
#line 151
      if (! tmp) {
        {
#line 151
        __assert_fail("(qu)-> next ? (qu) == (qu)-> next-> back : (qu) == (ads->output).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! ((unsigned int )qu->state == 3U)) {
        {
#line 151
        __assert_fail("qu->state == query_done", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! qu->children.head) {
#line 151
        if (! (! qu->children.tail)) {
          {
#line 151
          __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        157U, "checkc_queue_output");
          }
        }
      } else {
        {
#line 151
        __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! (! qu->parent)) {
        {
#line 151
        __assert_fail("!qu->parent", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! qu->allocations.head) {
#line 151
        if (! (! qu->allocations.tail)) {
          {
#line 151
          __assert_fail("!qu->allocations.head && !qu->allocations.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        157U, "checkc_queue_output");
          }
        }
      } else {
        {
#line 151
        __assert_fail("!qu->allocations.head && !qu->allocations.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
      {
#line 151
      checkc_query___3(ads___7, qu);
#line 151
      qu = qu->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 158
  return;
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
static struct sinfo  const  sinfos___3[24]  = 
#line 233 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
  {      {(adns_status )0, "ok", "OK"}, 
        {(adns_status )1, "nomemory", "Out of memory"}, 
        {(adns_status )2, "unknownrrtype", "Query not implemented in DNS library"}, 
        {(adns_status )3, "systemfail", "General resolver or system failure"}, 
        {(adns_status )30, "timeout", "DNS query timed out"}, 
        {(adns_status )31, "allservfail", "All nameservers failed"}, 
        {(adns_status )32, "norecurse", "Recursion denied by nameserver"}, 
        {(adns_status )33, "invalidresponse", "Nameserver sent bad response"}, 
        {(adns_status )34, "unknownformat", "Nameserver used unknown format"}, 
        {(adns_status )60, "rcodeservfail", "Nameserver reports failure"}, 
        {(adns_status )61, "rcodeformaterror", "Query not understood by nameserver"}, 
        {(adns_status )62,
      "rcodenotimplemented", "Query not implemented by nameserver"}, 
        {(adns_status )63, "rcoderefused", "Query refused by nameserver"}, 
        {(adns_status )64, "rcodeunknown", "Nameserver sent unknown response code"}, 
        {(adns_status )100, "inconsistent", "Inconsistent resource records in DNS"}, 
        {(adns_status )101, "prohibitedcname", "DNS alias found where canonical name wanted"}, 
        {(adns_status )102,
      "answerdomaininvalid", "Found syntactically invalid domain name"}, 
        {(adns_status )103, "answerdomaintoolong", "Found overly-long domain name"}, 
        {(adns_status )104, "invaliddata", "Found invalid DNS data"}, 
        {(adns_status )200, "querydomainwrong", "Domain invalid for particular DNS query type"}, 
        {(adns_status )201,
      "querydomaininvalid", "Domain name is syntactically invalid"}, 
        {(adns_status )202, "querydomaintoolong", "Domain name or component is too long"}, 
        {(adns_status )300,
      "nxdomain", "No such domain"}, 
        {(adns_status )301, "nodata", "No such data"}};
#line 270 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
static int si_compar___3(void const   *key , void const   *elem ) 
{ 
  adns_status const   *st ;
  struct sinfo  const  *si ;
  int tmp ;
  int tmp___0 ;

  {
#line 271
  st = (adns_status const   *)key;
#line 272
  si = (struct sinfo  const  *)elem;
#line 274
  if ((unsigned int const   )*st < (unsigned int const   )si->st) {
#line 274
    tmp___0 = -1;
  } else {
#line 274
    if ((unsigned int const   )*st > (unsigned int const   )si->st) {
#line 274
      tmp = 1;
    } else {
#line 274
      tmp = 0;
    }
#line 274
    tmp___0 = tmp;
  }
#line 274
  return (tmp___0);
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
static struct sinfo  const  *findsinfo___3(adns_status st ) 
{ 
  void *tmp ;

  {
  {
#line 278
  tmp = bsearch((void const   *)(& st), (void const   *)(sinfos___3), sizeof(sinfos___3) / sizeof(sinfos___3[0]),
                sizeof(sinfos___3[0]), & si_compar___3);
  }
#line 278
  return ((struct sinfo  const  *)tmp);
}
}
#line 299 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
static struct stinfo  const  stinfos___3[7]  = {      {(adns_status )0, "ok"}, 
        {(adns_status )29, "localfail"}, 
        {(adns_status )59, "remotefail"}, 
        {(adns_status )99, "tempfail"}, 
        {(adns_status )199, "misconfig"}, 
        {(adns_status )299, "misquery"}, 
        {(adns_status )499, "permfail"}};
#line 312 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
static int sti_compar___3(void const   *key , void const   *elem ) 
{ 
  adns_status const   *st ;
  struct stinfo  const  *sti ;
  adns_status here ;
  adns_status min ;
  adns_status max ;
  int tmp ;
  int tmp___0 ;

  {
#line 313
  st = (adns_status const   *)key;
#line 314
  sti = (struct stinfo  const  *)elem;
#line 318
  here = (adns_status )*st;
#line 319
  if ((unsigned long )sti == (unsigned long )(stinfos___3)) {
#line 319
    min = (adns_status )0;
  } else {
#line 319
    min = (adns_status )((unsigned int const   )(sti + -1)->stmax + 1U);
  }
#line 320
  max = (adns_status )sti->stmax;
#line 322
  if ((unsigned int )here < (unsigned int )min) {
#line 322
    tmp___0 = -1;
  } else {
#line 322
    if ((unsigned int )here > (unsigned int )max) {
#line 322
      tmp = 1;
    } else {
#line 322
      tmp = 0;
    }
#line 322
    tmp___0 = tmp;
  }
#line 322
  return (tmp___0);
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/transmit.c"
static adns_status mkquery_header___3(adns_state ads___7 , vbuf *vb___0 , int *id_r ,
                                      int qdlen ) 
{ 
  int id ;
  byte *rqp ;
  int tmp ;
  int tmp___0 ;
  byte *tmp___1 ;
  byte *tmp___2 ;
  byte *tmp___3 ;
  byte *tmp___4 ;
  byte *tmp___5 ;
  byte *tmp___6 ;
  byte *tmp___7 ;
  byte *tmp___8 ;
  byte *tmp___9 ;
  byte *tmp___10 ;
  byte *tmp___11 ;
  byte *tmp___12 ;

  {
  {
#line 46
  tmp = adns__vbuf_ensure(vb___0, (12 + qdlen) + 4);
  }
#line 46
  if (! tmp) {
#line 46
    return ((adns_status )1);
  }
#line 48
  vb___0->used = 0;
#line 49
  rqp = vb___0->buf + vb___0->used;
#line 51
  tmp___0 = ads___7->nextid;
#line 51
  (ads___7->nextid) ++;
#line 51
  id = tmp___0 & 65535;
#line 51
  *id_r = id;
#line 52
  tmp___1 = rqp;
#line 52
  rqp ++;
#line 52
  *tmp___1 = (byte )((id >> 8) & 255);
#line 52
  tmp___2 = rqp;
#line 52
  rqp ++;
#line 52
  *tmp___2 = (byte )(id & 255);
#line 53
  tmp___3 = rqp;
#line 53
  rqp ++;
#line 53
  *tmp___3 = (byte )1;
#line 54
  tmp___4 = rqp;
#line 54
  rqp ++;
#line 54
  *tmp___4 = (byte )0;
#line 55
  tmp___5 = rqp;
#line 55
  rqp ++;
#line 55
  *tmp___5 = (byte )((1 >> 8) & 255);
#line 55
  tmp___6 = rqp;
#line 55
  rqp ++;
#line 55
  *tmp___6 = (byte )1;
#line 56
  tmp___7 = rqp;
#line 56
  rqp ++;
#line 56
  *tmp___7 = (byte )0;
#line 56
  tmp___8 = rqp;
#line 56
  rqp ++;
#line 56
  *tmp___8 = (byte )0;
#line 57
  tmp___9 = rqp;
#line 57
  rqp ++;
#line 57
  *tmp___9 = (byte )0;
#line 57
  tmp___10 = rqp;
#line 57
  rqp ++;
#line 57
  *tmp___10 = (byte )0;
#line 58
  tmp___11 = rqp;
#line 58
  rqp ++;
#line 58
  *tmp___11 = (byte )0;
#line 58
  tmp___12 = rqp;
#line 58
  rqp ++;
#line 58
  *tmp___12 = (byte )0;
#line 60
  vb___0->used = (int )(rqp - vb___0->buf);
#line 62
  return ((adns_status )0);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/transmit.c"
static adns_status mkquery_footer___3(vbuf *vb___0 , adns_rrtype type ) 
{ 
  byte *rqp ;
  byte *tmp ;
  byte *tmp___0 ;
  byte *tmp___1 ;
  byte *tmp___2 ;

  {
#line 68
  rqp = vb___0->buf + vb___0->used;
#line 69
  tmp = rqp;
#line 69
  rqp ++;
#line 69
  *tmp = (byte )((((unsigned int )type & 65535U) >> 8) & 255U);
#line 69
  tmp___0 = rqp;
#line 69
  rqp ++;
#line 69
  *tmp___0 = (byte )(((unsigned int )type & 65535U) & 255U);
#line 70
  tmp___1 = rqp;
#line 70
  rqp ++;
#line 70
  *tmp___1 = (byte )((1 >> 8) & 255);
#line 70
  tmp___2 = rqp;
#line 70
  rqp ++;
#line 70
  *tmp___2 = (byte )1;
#line 71
  vb___0->used = (int )(rqp - vb___0->buf);
#line 72
  if (! (vb___0->used <= vb___0->avail)) {
    {
#line 72
    __assert_fail("vb->used <= vb->avail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/transmit.c",
                  72U, "mkquery_footer");
    }
  }
#line 74
  return ((adns_status )0);
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/transmit.c"
static void query_usetcp___3(adns_query qu , struct timeval now ) 
{ 


  {
  {
#line 244
  qu->state = (enum __anonenum_state_83 )1;
#line 245
  qu->timeout = now;
#line 246
  timevaladd(& qu->timeout, 30000L);
  }
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    qu->next = (adns_query )0;
#line 247
    qu->back = (qu->ads)->tcpw.tail;
#line 247
    if ((qu->ads)->tcpw.tail) {
#line 247
      ((qu->ads)->tcpw.tail)->next = qu;
    } else {
#line 247
      (qu->ads)->tcpw.head = qu;
    }
#line 247
    (qu->ads)->tcpw.tail = qu;
#line 247
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 248
  adns__querysend_tcp(qu, now);
#line 249
  adns__tcp_tryconnect(qu->ads, now);
  }
#line 250
  return;
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static adns_query query_alloc___3(adns_state ads___7 , typeinfo const   *typei , adns_rrtype type ,
                                  adns_queryflags flags , struct timeval now ) 
{ 
  adns_query qu ;
  void *tmp ;
  void *tmp___0 ;
  adns_query tmp___1 ;
  adns_query tmp___2 ;
  adns_query tmp___3 ;
  adns_query tmp___4 ;
  allocnode *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __suseconds_t tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 45
  tmp = Hmalloc(sizeof(*qu));
#line 45
  qu = (adns_query )tmp;
  }
#line 45
  if (! qu) {
#line 45
    return ((adns_query )0);
  }
  {
#line 46
  tmp___0 = Hmalloc(sizeof(*(qu->answer)));
#line 46
  qu->answer = (adns_answer *)tmp___0;
  }
#line 47
  if (! qu->answer) {
    {
#line 47
    Hfree((void *)qu);
    }
#line 47
    return ((adns_query )0);
  }
  {
#line 49
  qu->ads = ads___7;
#line 50
  qu->state = (enum __anonenum_state_83 )0;
#line 51
  tmp___2 = (adns_query )0;
#line 51
  qu->parent = tmp___2;
#line 51
  tmp___1 = tmp___2;
#line 51
  qu->next = tmp___1;
#line 51
  qu->back = tmp___1;
#line 52
  tmp___3 = (adns_query )0;
#line 52
  qu->children.tail = tmp___3;
#line 52
  qu->children.head = tmp___3;
#line 53
  tmp___4 = (adns_query )0;
#line 53
  qu->siblings.back = tmp___4;
#line 53
  qu->siblings.next = tmp___4;
#line 54
  tmp___5 = (allocnode *)0;
#line 54
  qu->allocations.tail = tmp___5;
#line 54
  qu->allocations.head = tmp___5;
#line 55
  qu->interim_allocd = 0;
#line 56
  qu->preserved_allocd = 0;
#line 57
  qu->final_allocspace = (void *)0;
#line 59
  qu->typei = typei;
#line 60
  qu->query_dgram = (byte *)0;
#line 61
  qu->query_dglen = 0;
#line 62
  adns__vbuf_init(& qu->vb);
#line 64
  qu->cname_dgram = (byte *)0;
#line 65
  tmp___6 = 0;
#line 65
  qu->cname_begin = tmp___6;
#line 65
  qu->cname_dglen = tmp___6;
#line 67
  adns__vbuf_init(& qu->search_vb);
#line 68
  tmp___8 = 0;
#line 68
  qu->search_doneabs = tmp___8;
#line 68
  tmp___7 = tmp___8;
#line 68
  qu->search_pos = tmp___7;
#line 68
  qu->search_origlen = tmp___7;
#line 70
  qu->id = -2;
#line 71
  qu->flags = (int )flags;
#line 72
  qu->retries = 0;
#line 73
  qu->udpnextserver = 0;
#line 74
  qu->udpsent = 0UL;
#line 75
  tmp___9 = (__suseconds_t )0;
#line 75
  qu->timeout.tv_usec = tmp___9;
#line 75
  qu->timeout.tv_sec = tmp___9;
#line 76
  qu->expires = now.tv_sec + 604800L;
#line 78
  memset((void *)(& qu->ctx), 0, sizeof(qu->ctx));
#line 80
  (qu->answer)->status = (adns_status )0;
#line 81
  tmp___10 = (char *)0;
#line 81
  (qu->answer)->owner = tmp___10;
#line 81
  (qu->answer)->cname = tmp___10;
#line 82
  (qu->answer)->type = type;
#line 83
  (qu->answer)->expires = (time_t )-1;
#line 84
  (qu->answer)->nrrs = 0;
#line 85
  (qu->answer)->rrs.untyped = (void *)0;
#line 86
  (qu->answer)->rrsz = (int )typei->rrsz;
  }
#line 88
  return (qu);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void query_submit___3(adns_state ads___7 , adns_query qu , typeinfo const   *typei ,
                             vbuf *qumsg_vb , int id , adns_queryflags flags , struct timeval now ) 
{ 
  void *tmp ;

  {
  {
#line 98
  qu->vb = *qumsg_vb;
#line 99
  adns__vbuf_init(qumsg_vb);
#line 101
  tmp = Hmalloc((size_t )qu->vb.used);
#line 101
  qu->query_dgram = (byte *)tmp;
  }
#line 102
  if (! qu->query_dgram) {
    {
#line 102
    adns__query_fail(qu, (adns_status )1);
    }
#line 102
    return;
  }
  {
#line 104
  qu->id = id;
#line 105
  qu->query_dglen = qu->vb.used;
#line 106
  memcpy((void */* __restrict  */)qu->query_dgram, (void const   */* __restrict  */)qu->vb.buf,
         (size_t )qu->vb.used);
#line 108
  adns__query_send(qu, now);
  }
#line 109
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void query_simple___3(adns_state ads___7 , adns_query qu , char const   *owner ,
                             int ol , typeinfo const   *typei , adns_queryflags flags ,
                             struct timeval now ) 
{ 
  vbuf vb_new ;
  int id ;
  adns_status stat ;

  {
  {
#line 136
  stat = adns__mkquery(ads___7, & qu->vb, & id, owner, ol, typei, (qu->answer)->type,
                       flags);
  }
#line 138
  if (stat) {
#line 139
    if ((unsigned int )stat == 202U) {
#line 139
      if ((unsigned int )flags & 1U) {
        {
#line 140
        adns__search_next(ads___7, qu, now);
        }
#line 141
        return;
      } else {
        {
#line 143
        adns__query_fail(qu, stat);
        }
#line 144
        return;
      }
    } else {
      {
#line 143
      adns__query_fail(qu, stat);
      }
#line 144
      return;
    }
  }
  {
#line 148
  vb_new = qu->vb;
#line 149
  adns__vbuf_init(& qu->vb);
#line 150
  query_submit___3(ads___7, qu, typei, & vb_new, id, flags, now);
  }
#line 151
  return;
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static int save_owner___3(adns_query qu , char const   *owner , int ol ) 
{ 
  adns_answer *ans ;
  void *tmp ;

  {
#line 198
  if (! (qu->flags & 4)) {
#line 198
    return (1);
  }
#line 200
  ans = qu->answer;
#line 201
  if (! (! ans->owner)) {
    {
#line 201
    __assert_fail("!ans->owner", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c",
                  201U, "save_owner");
    }
  }
  {
#line 203
  tmp = adns__alloc_preserved(qu, (size_t )(ol + 1));
#line 203
  ans->owner = (char *)tmp;
  }
#line 203
  if (! ans->owner) {
#line 203
    return (0);
  }
  {
#line 205
  memcpy((void */* __restrict  */)ans->owner, (void const   */* __restrict  */)owner,
         (size_t )ol);
#line 206
  *(ans->owner + ol) = (char)0;
  }
#line 207
  return (1);
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void *alloc_common___3(adns_query qu , size_t sz ) 
{ 
  allocnode *an ;
  void *tmp ;

  {
#line 342
  if (! sz) {
#line 342
    return ((void *)qu);
  }
#line 343
  if (! (! qu->final_allocspace)) {
    {
#line 343
    __assert_fail("!qu->final_allocspace", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c",
                  343U, "alloc_common");
    }
  }
  {
#line 344
  tmp = Hmalloc((((((((sizeof(*an) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ) + sz) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ));
#line 344
  an = (allocnode *)tmp;
  }
#line 345
  if (! an) {
#line 345
    return ((void *)0);
  }
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 346
    an->next = (struct allocnode *)0;
#line 346
    an->back = qu->allocations.tail;
#line 346
    if (qu->allocations.tail) {
#line 346
      (qu->allocations.tail)->next = an;
    } else {
#line 346
      qu->allocations.head = an;
    }
#line 346
    qu->allocations.tail = an;
#line 346
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 347
  return ((void *)((byte *)an + (((sizeof(*an) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign )));
}
}
#line 410 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void cancel_children___3(adns_query qu ) 
{ 
  adns_query cqu ;
  adns_query ncqu ;

  {
#line 413
  cqu = qu->children.head;
  {
#line 413
  while (1) {
    while_continue: /* CIL Label */ ;
#line 413
    if (! cqu) {
#line 413
      goto while_break;
    }
    {
#line 414
    ncqu = cqu->siblings.next;
#line 415
    adns_cancel(cqu);
#line 413
    cqu = ncqu;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 417
  return;
}
}
#line 427 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void free_query_allocs___3(adns_query qu ) 
{ 
  allocnode *an ;
  allocnode *ann ;
  allocnode *tmp ;

  {
  {
#line 430
  cancel_children___3(qu);
#line 431
  an = qu->allocations.head;
  }
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    if (! an) {
#line 431
      goto while_break;
    }
    {
#line 431
    ann = an->next;
#line 431
    Hfree((void *)an);
#line 431
    an = ann;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 432
  tmp = (allocnode *)0;
#line 432
  qu->allocations.tail = tmp;
#line 432
  qu->allocations.head = tmp;
#line 433
  adns__vbuf_free(& qu->vb);
#line 434
  adns__vbuf_free(& qu->search_vb);
#line 435
  Hfree((void *)qu->query_dgram);
#line 436
  qu->query_dgram = (byte *)0;
  }
#line 437
  return;
}
}
#line 477 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void makefinal_query___3(adns_query qu ) 
{ 
  adns_answer *ans ;
  int rrn ;
  void *tmp ;

  {
#line 481
  ans = qu->answer;
#line 483
  if (qu->interim_allocd) {
    {
#line 484
    tmp = Hrealloc((void *)qu->answer, (((((((sizeof(*ans) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ) + (unsigned long )qu->interim_allocd) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ));
#line 484
    ans = (adns_answer *)tmp;
    }
#line 486
    if (! ans) {
#line 486
      goto x_nomem;
    }
#line 487
    qu->answer = ans;
  }
  {
#line 490
  qu->final_allocspace = (void *)((byte *)ans + (((sizeof(*ans) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ));
#line 491
  adns__makefinal_str(qu, & ans->cname);
#line 492
  adns__makefinal_str(qu, & ans->owner);
  }
#line 494
  if (ans->nrrs) {
    {
#line 495
    adns__makefinal_block(qu, & ans->rrs.untyped, (size_t )(ans->nrrs * ans->rrsz));
#line 497
    rrn = 0;
    }
    {
#line 497
    while (1) {
      while_continue: /* CIL Label */ ;
#line 497
      if (! (rrn < ans->nrrs)) {
#line 497
        goto while_break;
      }
      {
#line 498
      (*((qu->typei)->makefinal))(qu, (void *)(ans->rrs.bytes + rrn * ans->rrsz));
#line 497
      rrn ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 501
  free_query_allocs___3(qu);
  }
#line 502
  return;
  x_nomem: 
  {
#line 505
  qu->preserved_allocd = 0;
#line 506
  (qu->answer)->cname = (char *)0;
#line 507
  (qu->answer)->owner = (char *)0;
#line 508
  adns__reset_preserved(qu);
#line 510
  (qu->answer)->status = (adns_status )1;
#line 511
  free_query_allocs___3(qu);
  }
#line 512
  return;
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void tcp_close___3(adns_state ads___7 ) 
{ 
  int serv ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 48
  serv = ads___7->tcpserver;
#line 49
  Hclose(ads___7->tcpsocket);
#line 50
  ads___7->tcpsocket = -1;
#line 51
  tmp___0 = 0;
#line 51
  ads___7->tcpsend.used = tmp___0;
#line 51
  tmp = tmp___0;
#line 51
  ads___7->tcprecv_skip = tmp;
#line 51
  ads___7->tcprecv.used = tmp;
  }
#line 52
  return;
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void tcp_connected___3(adns_state ads___7 , struct timeval now ) 
{ 
  adns_query qu ;
  adns_query nqu ;

  {
  {
#line 76
  adns__debug(ads___7, ads___7->tcpserver, (adns_query )0, "TCP connected");
#line 77
  ads___7->tcpstate = (enum adns__tcpstate )2;
#line 78
  qu = ads___7->tcpw.head;
  }
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (qu) {
#line 78
      if (! ((unsigned int )ads___7->tcpstate == 2U)) {
#line 78
        goto while_break;
      }
    } else {
#line 78
      goto while_break;
    }
#line 79
    nqu = qu->next;
#line 80
    if (! ((unsigned int )qu->state == 1U)) {
      {
#line 80
      __assert_fail("qu->state == query_tcpw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c",
                    80U, "tcp_connected");
      }
    }
    {
#line 81
    adns__querysend_tcp(qu, now);
#line 78
    qu = nqu;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void tcp_broken_events___3(adns_state ads___7 ) 
{ 
  adns_query qu ;
  adns_query nqu ;

  {
#line 88
  if (! ((unsigned int )ads___7->tcpstate == 3U)) {
    {
#line 88
    __assert_fail("ads->tcpstate == server_broken", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c",
                  88U, "tcp_broken_events");
    }
  }
#line 89
  qu = ads___7->tcpw.head;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! qu) {
#line 89
      goto while_break;
    }
#line 90
    nqu = qu->next;
#line 91
    if (! ((unsigned int )qu->state == 1U)) {
      {
#line 91
      __assert_fail("qu->state == query_tcpw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c",
                    91U, "tcp_broken_events");
      }
    }
#line 92
    if (qu->retries > ads___7->nservers) {
      {
#line 93
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 93
        if (qu->back) {
#line 93
          (qu->back)->next = qu->next;
        } else {
#line 93
          ads___7->tcpw.head = qu->next;
        }
#line 93
        if (qu->next) {
#line 93
          (qu->next)->back = qu->back;
        } else {
#line 93
          ads___7->tcpw.tail = qu->back;
        }
#line 93
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 94
      adns__query_fail(qu, (adns_status )31);
      }
    }
#line 89
    qu = nqu;
  }
  while_break: /* CIL Label */ ;
  }
#line 97
  ads___7->tcpstate = (enum adns__tcpstate )0;
#line 98
  return;
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void inter_immed___3(struct timeval **tv_io , struct timeval *tvbuf ) 
{ 
  struct timeval *rbuf ;
  __suseconds_t tmp ;

  {
#line 174
  if (! tv_io) {
#line 174
    return;
  }
#line 176
  rbuf = *tv_io;
#line 177
  if (! rbuf) {
#line 177
    rbuf = tvbuf;
#line 177
    *tv_io = rbuf;
  }
#line 179
  tmp = (__suseconds_t )0;
#line 179
  rbuf->tv_usec = tmp;
#line 179
  rbuf->tv_sec = tmp;
#line 180
  return;
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void inter_maxto___3(struct timeval **tv_io , struct timeval *tvbuf , struct timeval maxto ) 
{ 
  struct timeval *rbuf ;
  int tmp ;

  {
#line 186
  if (! tv_io) {
#line 186
    return;
  }
#line 187
  rbuf = *tv_io;
#line 188
  if (! rbuf) {
#line 189
    *tvbuf = maxto;
#line 189
    *tv_io = tvbuf;
  } else {
#line 191
    if (rbuf->tv_sec == maxto.tv_sec) {
#line 191
      tmp = rbuf->tv_usec > maxto.tv_usec;
    } else {
#line 191
      tmp = rbuf->tv_sec > maxto.tv_sec;
    }
#line 191
    if (tmp) {
#line 191
      *rbuf = maxto;
    }
  }
#line 195
  return;
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void inter_maxtoabs___3(struct timeval **tv_io , struct timeval *tvbuf , struct timeval now ,
                               struct timeval maxtime ) 
{ 
  ldiv_t dr ;

  {
#line 204
  if (! tv_io) {
#line 204
    return;
  }
  {
#line 205
  maxtime.tv_sec -= now.tv_sec + 2L;
#line 206
  maxtime.tv_usec -= now.tv_usec - 2000000L;
#line 207
  dr = ldiv(maxtime.tv_usec, 1000000L);
#line 208
  maxtime.tv_sec += dr.quot;
#line 209
  maxtime.tv_usec -= dr.quot * 1000000L;
  }
#line 210
  if (maxtime.tv_sec < 0L) {
#line 210
    maxtime.tv_usec = (__suseconds_t )0;
#line 210
    maxtime.tv_sec = maxtime.tv_usec;
  }
  {
#line 211
  inter_maxto___3(tv_io, tvbuf, maxtime);
  }
#line 212
  return;
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void timeouts_queue___3(adns_state ads___7 , int act , struct timeval **tv_io ,
                               struct timeval *tvbuf , struct timeval now , struct query_queue *queue ) 
{ 
  adns_query qu ;
  adns_query nqu ;
  int tmp ;

  {
#line 219
  qu = queue->head;
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if (! qu) {
#line 219
      goto while_break;
    }
#line 220
    nqu = qu->next;
#line 221
    if (now.tv_sec == qu->timeout.tv_sec) {
#line 221
      tmp = now.tv_usec > qu->timeout.tv_usec;
    } else {
#line 221
      tmp = now.tv_sec > qu->timeout.tv_sec;
    }
#line 221
    if (tmp) {
#line 224
      if (! act) {
        {
#line 224
        inter_immed___3(tv_io, tvbuf);
        }
#line 224
        return;
      }
      {
#line 225
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 225
        if (qu->back) {
#line 225
          (qu->back)->next = qu->next;
        } else {
#line 225
          queue->head = qu->next;
        }
#line 225
        if (qu->next) {
#line 225
          (qu->next)->back = qu->back;
        } else {
#line 225
          queue->tail = qu->back;
        }
#line 225
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 226
      if ((unsigned int )qu->state != 0U) {
        {
#line 227
        adns__query_fail(qu, (adns_status )30);
        }
      } else {
        {
#line 229
        adns__query_send(qu, now);
        }
      }
#line 231
      nqu = queue->head;
    } else {
      {
#line 222
      inter_maxtoabs___3(tv_io, tvbuf, now, qu->timeout);
      }
    }
#line 219
    qu = nqu;
  }
  while_break: /* CIL Label */ ;
  }
#line 234
  return;
}
}
#line 236 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void tcp_events___3(adns_state ads___7 , int act , struct timeval **tv_io ,
                           struct timeval *tvbuf , struct timeval now ) 
{ 
  int tmp ;

  {
  {
#line 239
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 241
    if ((unsigned int )ads___7->tcpstate == 3U) {
#line 241
      goto case_3;
    }
#line 244
    if ((unsigned int )ads___7->tcpstate == 0U) {
#line 244
      goto case_0;
    }
#line 249
    if ((unsigned int )ads___7->tcpstate == 2U) {
#line 249
      goto case_2;
    }
#line 256
    if ((unsigned int )ads___7->tcpstate == 1U) {
#line 256
      goto case_1;
    }
#line 275
    goto switch_default___0;
    case_3: /* CIL Label */ 
#line 242
    if (! act) {
      {
#line 242
      inter_immed___3(tv_io, tvbuf);
      }
#line 242
      return;
    }
    {
#line 243
    tcp_broken_events___3(ads___7);
    }
    case_0: /* CIL Label */ 
#line 245
    if (! ads___7->tcpw.head) {
#line 245
      return;
    }
#line 246
    if (! act) {
      {
#line 246
      inter_immed___3(tv_io, tvbuf);
      }
#line 246
      return;
    }
    {
#line 247
    adns__tcp_tryconnect(ads___7, now);
    }
#line 248
    goto switch_break;
    case_2: /* CIL Label */ 
#line 250
    if (ads___7->tcpw.head) {
#line 250
      return;
    }
#line 251
    if (! ads___7->tcptimeout.tv_sec) {
#line 252
      if (! (! ads___7->tcptimeout.tv_usec)) {
        {
#line 252
        __assert_fail("!ads->tcptimeout.tv_usec", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c",
                      252U, "tcp_events");
        }
      }
      {
#line 253
      ads___7->tcptimeout = now;
#line 254
      timevaladd(& ads___7->tcptimeout, 30000L);
      }
    }
    case_1: /* CIL Label */ 
#line 257
    if (! act) {
      {
#line 258
      inter_maxtoabs___3(tv_io, tvbuf, now, ads___7->tcptimeout);
      }
#line 259
      return;
    } else {
#line 257
      if (now.tv_sec == ads___7->tcptimeout.tv_sec) {
#line 257
        tmp = now.tv_usec > ads___7->tcptimeout.tv_usec;
      } else {
#line 257
        tmp = now.tv_sec > ads___7->tcptimeout.tv_sec;
      }
#line 257
      if (! tmp) {
        {
#line 258
        inter_maxtoabs___3(tv_io, tvbuf, now, ads___7->tcptimeout);
        }
#line 259
        return;
      }
    }
    {
#line 263
    if ((unsigned int )ads___7->tcpstate == 1U) {
#line 263
      goto case_1___0;
    }
#line 266
    if ((unsigned int )ads___7->tcpstate == 2U) {
#line 266
      goto case_2___0;
    }
#line 270
    goto switch_default;
    case_1___0: /* CIL Label */ 
    {
#line 264
    adns__tcp_broken(ads___7, "unable to make connection", "timed out");
    }
#line 265
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 267
    tcp_close___3(ads___7);
#line 268
    ads___7->tcpstate = (enum adns__tcpstate )0;
    }
#line 269
    return;
    switch_default: /* CIL Label */ 
    {
#line 271
    abort();
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 274
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
#line 276
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 279
  return;
}
}
#line 516 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void fd_event___3(adns_state ads___7 , int fd , int revent , int pollflag ,
                         int maxfd , fd_set const   *fds , int (*func)(adns_state  ,
                                                                       int fd , struct timeval  const  *now ) ,
                         struct timeval now , int *r_r ) 
{ 
  int r ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 524
  if (! (revent & pollflag)) {
#line 524
    return;
  }
#line 525
  if (fds) {
#line 525
    if (fd < maxfd) {
#line 525
      if (! ((fds->__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
#line 525
        return;
      }
    } else {
#line 525
      return;
    }
  }
  {
#line 526
  r = (*func)(ads___7, fd, (struct timeval  const  *)(& now));
  }
#line 527
  if (r) {
#line 528
    if (r_r) {
#line 529
      *r_r = r;
    } else {
      {
#line 531
      tmp = __errno_location();
#line 531
      tmp___0 = strerror(*tmp);
#line 531
      adns__diag(ads___7, -1, (adns_query )0, "process fd failed after select: %s",
                 tmp___0);
#line 533
      adns_globalsystemfailure(ads___7);
      }
    }
  }
#line 536
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static int bracket___0  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static int forever___0  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static int address___0  ;
#line 59 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static unsigned long timeout___0  =    1000UL;
#line 60 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static adns_rrtype rrt___0  =    (adns_rrtype )65548;
#line 61 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static adns_initflags initflags___0  =    (adns_initflags )0;
#line 62 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static char const   *config_text___3  ;
#line 64 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static int outblocked___0  ;
#line 64 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static int inputeof___0  ;
#line 65 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static struct __anonstruct_outqueue_55___0 outqueue___0  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static int peroutqueuenode___0  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static int outqueuelen___0  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static struct sockaddr_in sa___0  ;
#line 69 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static adns_state ads___2  ;
#line 71 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static char addrtextbuf___0[14]  ;
#line 72 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static int cbyte___0  ;
#line 72 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static int inbyte___0  ;
#line 72 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static int inbuf___0  ;
#line 73 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static unsigned char bytes___0[4]  ;
#line 74 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static struct timeval printbefore___0  ;
#line 82 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static struct treething *newthing___0  ;
#line 83 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static void *treeroot___0  ;
#line 85 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static int nonblock___0(int fd , int isnonblock ) 
{ 
  int r ;
  int tmp ;

  {
  {
#line 88
  r = Hfcntl(fd, 3);
  }
#line 89
  if (r == -1) {
#line 89
    return (-1);
  }
#line 90
  if (isnonblock) {
#line 90
    tmp = r | 2048;
  } else {
#line 90
    tmp = r & -2049;
  }
  {
#line 90
  r = Hfcntl(fd, 4, tmp);
  }
#line 91
  if (r == -1) {
#line 91
    return (-1);
  }
#line 92
  return (0);
}
}
#line 101
static  __attribute__((__noreturn__)) void sysfail___1(char const   *what ) ;
#line 102
static  __attribute__((__noreturn__)) void sysfail___1(char const   *what ) ;
#line 102 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static void sysfail___1(char const   *what ) 
{ 
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 103
  tmp = __errno_location();
#line 103
  tmp___0 = strerror(*tmp);
#line 103
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adnsresfilter: system call failed: %s: %s\n",
          what, tmp___0);
#line 104
  quitnow(2);
  }
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static void *xmalloc___1(size_t sz ) 
{ 
  void *r ;

  {
  {
#line 109
  r = Hmalloc(sz);
  }
#line 109
  if (r) {
#line 109
    return (r);
  }
  {
#line 110
  sysfail___1("malloc");
  }
}
}
#line 113
static  __attribute__((__noreturn__)) void outputerr___0(void) ;
#line 114
static  __attribute__((__noreturn__)) void outputerr___0(void) ;
#line 114 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static void outputerr___0(void) 
{ 


  {
  {
#line 114
  sysfail___1("write to stdout");
  }
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static void usage___2(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 117
  tmp = printf((char const   */* __restrict  */)"usage: adnsresfilter [<options ...>]\n       adnsresfilter  -h|--help | --version\noptions: -t<milliseconds>|--timeout <milliseconds>\n         -w|--wait        (always wait for queries to time out or fail)\n         -b|--brackets    (require [...] around IP addresses)\n         -a|--address     (always include [address] in output)\n         -u|--unchecked   (do not forward map for checking)\n         --config <text>  (use this instead of resolv.conf)\n         --debug          (turn on adns resolver debugging)\nTimeout is the maximum amount to delay any particular bit of output for.\nLookups will go on in the background.  Default timeout = 1000 (ms).\n");
  }
#line 117
  if (tmp == -1) {
    {
#line 128
    outputerr___0();
    }
  }
  {
#line 129
  tmp___0 = fflush(stdout);
  }
#line 129
  if (tmp___0) {
    {
#line 129
    sysfail___1("flush stdout");
    }
  }
#line 130
  return;
}
}
#line 132
static  __attribute__((__noreturn__)) void usageerr___2(char const   *why ) ;
#line 133
static  __attribute__((__noreturn__)) void usageerr___2(char const   *why ) ;
#line 133 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static void usageerr___2(char const   *why ) 
{ 


  {
  {
#line 134
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adnsresfilter: bad usage: %s\n",
          why);
#line 135
  usage___2();
#line 136
  quitnow(1);
  }
}
}
#line 139
static  __attribute__((__noreturn__)) void adnsfail___0(char const   *what , int e ) ;
#line 140
static  __attribute__((__noreturn__)) void adnsfail___0(char const   *what , int e ) ;
#line 140 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static void adnsfail___0(char const   *what , int e ) 
{ 
  char *tmp ;

  {
  {
#line 141
  tmp = strerror(e);
#line 141
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adnsresfilter: adns call failed: %s: %s\n",
          what, tmp);
#line 142
  quitnow(2);
  }
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static void settimeout___0(char const   *arg ) 
{ 
  char *ep ;

  {
  {
#line 147
  timeout___0 = strtoul((char const   */* __restrict  */)arg, (char **/* __restrict  */)(& ep),
                        0);
  }
#line 148
  if (*ep) {
    {
#line 148
    usageerr___2("invalid timeout");
    }
  }
#line 149
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static void parseargs___0(char const   * const  *argv ) 
{ 
  char const   *arg ;
  int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    argv ++;
#line 155
    arg = (char const   *)*argv;
#line 155
    if (! arg) {
#line 155
      goto while_break;
    }
#line 156
    if ((int const   )*(arg + 0) != 45) {
      {
#line 156
      usageerr___2("no non-option arguments are allowed");
      }
    }
#line 157
    if ((int const   )*(arg + 1) == 45) {
      {
#line 158
      tmp___9 = strcmp(arg, "--timeout");
      }
#line 158
      if (tmp___9) {
        {
#line 162
        tmp___8 = strcmp(arg, "--wait");
        }
#line 162
        if (tmp___8) {
          {
#line 164
          tmp___7 = strcmp(arg, "--brackets");
          }
#line 164
          if (tmp___7) {
            {
#line 166
            tmp___6 = strcmp(arg, "--address");
            }
#line 166
            if (tmp___6) {
              {
#line 168
              tmp___5 = strcmp(arg, "--unchecked");
              }
#line 168
              if (tmp___5) {
                {
#line 170
                tmp___4 = strcmp(arg, "--config");
                }
#line 170
                if (tmp___4) {
                  {
#line 173
                  tmp___3 = strcmp(arg, "--debug");
                  }
#line 173
                  if (tmp___3) {
                    {
#line 175
                    tmp___2 = strcmp(arg, "--help");
                    }
#line 175
                    if (tmp___2) {
                      {
#line 177
                      tmp___1 = strcmp(arg, "--version");
                      }
#line 177
                      if (tmp___1) {
                        {
#line 180
                        usageerr___2("unknown long option");
                        }
                      } else {
                        {
#line 178
                        tmp = fputs((char const   */* __restrict  */)"adnsresfilter (GNU adns) 1.2\n\nCopyright (C) 1997-2000,2003,2006  Ian Jackson\nCopyright (C) 1999-2000,2003,2006  Tony Finch\nCopyright (C) 1991 Massachusetts Institute of Technology\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n",
                                    (FILE */* __restrict  */)stdout);
                        }
#line 178
                        if (tmp == -1) {
                          {
#line 178
                          perror("adnsresfilter: write version message");
#line 178
                          quitnow(-1);
                          }
                        } else {
                          {
#line 178
                          tmp___0 = fclose(stdout);
                          }
#line 178
                          if (tmp___0) {
                            {
#line 178
                            perror("adnsresfilter: write version message");
#line 178
                            quitnow(-1);
                            }
                          }
                        }
                        {
#line 178
                        quitnow(0);
#line 178
                        quitnow(0);
                        }
                      }
                    } else {
                      {
#line 176
                      usage___2();
#line 176
                      quitnow(0);
                      }
                    }
                  } else {
#line 174
                    initflags___0 = (adns_initflags )((unsigned int )initflags___0 | 8U);
                  }
                } else {
#line 171
                  argv ++;
#line 171
                  arg = (char const   *)*argv;
#line 171
                  if (! arg) {
                    {
#line 171
                    usageerr___2("--config needs a value");
                    }
                  }
#line 172
                  config_text___3 = arg;
                }
              } else {
#line 169
                rrt___0 = (adns_rrtype )12;
              }
            } else {
#line 167
              address___0 = 1;
            }
          } else {
#line 165
            bracket___0 = 1;
          }
        } else {
#line 163
          forever___0 = 1;
        }
      } else {
#line 159
        argv ++;
#line 159
        arg = (char const   *)*argv;
#line 159
        if (! arg) {
          {
#line 159
          usageerr___2("--timeout needs a value");
          }
        }
        {
#line 160
        settimeout___0(arg);
#line 161
        forever___0 = 0;
        }
      }
    } else {
      {
#line 183
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 183
        arg ++;
#line 183
        c = (int )*arg;
#line 183
        if (! c) {
#line 183
          goto while_break___0;
        }
        {
#line 185
        if (c == 116) {
#line 185
          goto case_116;
        }
#line 192
        if (c == 119) {
#line 192
          goto case_119;
        }
#line 195
        if (c == 98) {
#line 195
          goto case_98;
        }
#line 198
        if (c == 97) {
#line 198
          goto case_97;
        }
#line 201
        if (c == 117) {
#line 201
          goto case_117;
        }
#line 204
        if (c == 104) {
#line 204
          goto case_104;
        }
#line 207
        goto switch_default;
        case_116: /* CIL Label */ 
#line 186
        arg ++;
#line 186
        if (*arg) {
          {
#line 186
          settimeout___0(arg);
          }
        } else {
#line 187
          argv ++;
#line 187
          arg = (char const   *)*argv;
#line 187
          if (arg) {
            {
#line 187
            settimeout___0(arg);
            }
          } else {
            {
#line 188
            usageerr___2("-t needs a value");
            }
          }
        }
#line 189
        forever___0 = 0;
#line 190
        arg = "\000";
#line 191
        goto switch_break;
        case_119: /* CIL Label */ 
#line 193
        forever___0 = 1;
#line 194
        goto switch_break;
        case_98: /* CIL Label */ 
#line 196
        bracket___0 = 1;
#line 197
        goto switch_break;
        case_97: /* CIL Label */ 
#line 199
        address___0 = 1;
#line 200
        goto switch_break;
        case_117: /* CIL Label */ 
#line 202
        rrt___0 = (adns_rrtype )12;
#line 203
        goto switch_break;
        case_104: /* CIL Label */ 
        {
#line 205
        usage___2();
#line 206
        quitnow(0);
        }
        switch_default: /* CIL Label */ 
        {
#line 208
        usageerr___2("unknown short option");
        }
        switch_break: /* CIL Label */ ;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  return;
}
}
#line 215 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static void queueoutchar___0(int c ) 
{ 
  struct outqueuenode *entry ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 218
  entry = outqueue___0.tail;
#line 219
  if (! entry) {
#line 219
    goto _L;
  } else
#line 219
  if (entry->addr) {
#line 219
    goto _L;
  } else
#line 219
  if (entry->textlen >= peroutqueuenode___0) {
    _L: /* CIL Label */ 
#line 220
    if (! peroutqueuenode___0) {
#line 220
      peroutqueuenode___0 = 128;
    } else
#line 220
    if (! entry) {
#line 220
      peroutqueuenode___0 = 128;
    } else
#line 220
    if (entry->addr) {
#line 220
      peroutqueuenode___0 = 128;
    } else {
#line 220
      if (peroutqueuenode___0 >= 1024) {
#line 220
        tmp = 4096;
      } else {
#line 220
        tmp = peroutqueuenode___0 << 2;
      }
#line 220
      peroutqueuenode___0 = tmp;
    }
    {
#line 222
    tmp___0 = xmalloc___1(sizeof(*entry));
#line 222
    entry = (struct outqueuenode *)tmp___0;
#line 223
    entry->buffer = xmalloc___1((size_t )peroutqueuenode___0);
#line 224
    entry->textp = (char *)entry->buffer;
#line 225
    entry->textlen = 0;
#line 226
    entry->addr = (struct treething *)0;
    }
    {
#line 227
    while (1) {
      while_continue: /* CIL Label */ ;
#line 227
      entry->next = (struct outqueuenode *)0;
#line 227
      entry->back = outqueue___0.tail;
#line 227
      if (outqueue___0.tail) {
#line 227
        (outqueue___0.tail)->next = entry;
      } else {
#line 227
        outqueue___0.head = entry;
      }
#line 227
      outqueue___0.tail = entry;
#line 227
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 228
    outqueuelen___0 ++;
  }
#line 230
  tmp___1 = entry->textlen;
#line 230
  (entry->textlen) ++;
#line 230
  *(entry->textp + tmp___1) = (char )c;
#line 231
  return;
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static void queueoutstr___0(char const   *str , int len ) 
{ 
  char const   *tmp ;
  int tmp___0 ;

  {
  {
#line 234
  while (1) {
    while_continue: /* CIL Label */ ;
#line 234
    tmp___0 = len;
#line 234
    len --;
#line 234
    if (! (tmp___0 > 0)) {
#line 234
      goto while_break;
    }
    {
#line 234
    tmp = str;
#line 234
    str ++;
#line 234
    queueoutchar___0((int )*tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 235
  return;
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static void writestdout___0(struct outqueuenode *entry ) 
{ 
  int r ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 240
  while (1) {
    while_continue: /* CIL Label */ ;
#line 240
    if (! entry->textlen) {
#line 240
      goto while_break;
    }
    {
#line 241
    r = Hwrite(1, (void const   *)entry->textp, (size_t )entry->textlen);
    }
#line 242
    if (r < 0) {
      {
#line 243
      tmp = __errno_location();
      }
#line 243
      if (*tmp == 4) {
#line 243
        goto while_continue;
      }
      {
#line 244
      tmp___0 = __errno_location();
      }
#line 244
      if (*tmp___0 == 11) {
#line 244
        outblocked___0 = 1;
#line 244
        goto while_break;
      }
      {
#line 245
      sysfail___1("write stdout");
      }
    }
#line 247
    if (! (r <= entry->textlen)) {
      {
#line 247
      __assert_fail("r <= entry->textlen", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c",
                    247U, "writestdout");
      }
    }
#line 248
    entry->textp += r;
#line 249
    entry->textlen -= r;
  }
  while_break: /* CIL Label */ ;
  }
#line 251
  if (! entry->textlen) {
    {
#line 252
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 252
      if (entry->back) {
#line 252
        (entry->back)->next = entry->next;
      } else {
#line 252
        outqueue___0.head = entry->next;
      }
#line 252
      if (entry->next) {
#line 252
        (entry->next)->back = entry->back;
      } else {
#line 252
        outqueue___0.tail = entry->back;
      }
#line 252
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 253
    Hfree(entry->buffer);
#line 254
    Hfree((void *)entry);
#line 255
    outqueuelen___0 --;
    }
  }
#line 257
  return;
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static void replacetextwithname___0(struct outqueuenode *entry ) 
{ 
  char *name ;
  char *newbuf ;
  int namelen ;
  int newlen ;
  size_t tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 263
  name = *(((entry->addr)->ans)->rrs.str + 0);
#line 264
  tmp = strlen((char const   *)name);
#line 264
  namelen = (int )tmp;
  }
#line 265
  if (! address___0) {
    {
#line 266
    Hfree(entry->buffer);
#line 267
    entry->buffer = (void *)0;
#line 268
    entry->textp = name;
#line 269
    entry->textlen = namelen;
    }
  } else {
#line 271
    if (bracket___0) {
#line 271
      tmp___0 = 0;
    } else {
#line 271
      tmp___0 = 2;
    }
    {
#line 271
    newlen = (entry->textlen + namelen) + tmp___0;
#line 272
    tmp___1 = xmalloc___1((size_t )(newlen + 1));
#line 272
    newbuf = (char *)tmp___1;
    }
#line 273
    if (bracket___0) {
#line 273
      tmp___2 = "%s%.*s";
    } else {
#line 273
      tmp___2 = "%s[%.*s]";
    }
    {
#line 273
    sprintf((char */* __restrict  */)newbuf, (char const   */* __restrict  */)tmp___2,
            name, entry->textlen, entry->textp);
#line 274
    Hfree(entry->buffer);
#line 275
    tmp___3 = newbuf;
#line 275
    entry->textp = tmp___3;
#line 275
    entry->buffer = (void *)tmp___3;
#line 276
    entry->textlen = newlen;
    }
  }
#line 278
  return;
}
}
#line 280 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static void checkadnsqueries___0(void) 
{ 
  adns_query qu ;
  adns_answer *ans ;
  void *context ;
  struct treething *foundthing ;
  int r ;

  {
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 288
    qu = (adns_query )0;
#line 288
    context = (void *)0;
#line 288
    ans = (adns_answer *)0;
#line 289
    r = adns_check(ads___2, & qu, & ans, & context);
    }
#line 290
    if (r == 3) {
#line 290
      goto while_break;
    } else
#line 290
    if (r == 11) {
#line 290
      goto while_break;
    }
#line 291
    if (! (! r)) {
      {
#line 291
      __assert_fail("!r", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c",
                    291U, "checkadnsqueries");
      }
    }
#line 292
    foundthing = (struct treething *)context;
#line 293
    foundthing->ans = ans;
#line 294
    foundthing->qu = (adns_query )0;
  }
  while_break: /* CIL Label */ ;
  }
#line 296
  return;
}
}
#line 298 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static void restartbuf___0(void) 
{ 


  {
#line 299
  if (inbuf___0 > 0) {
    {
#line 299
    queueoutstr___0((char const   *)(addrtextbuf___0), inbuf___0);
    }
  }
#line 300
  inbuf___0 = 0;
#line 301
  return;
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static int comparer___0(void const   *a , void const   *b ) 
{ 
  int tmp ;

  {
  {
#line 304
  tmp = memcmp(a, b, (size_t )4);
  }
#line 304
  return (tmp);
}
}
#line 307 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static void procaddr___0(void) 
{ 
  struct treething *foundthing ;
  void **searchfound ;
  struct outqueuenode *entry ;
  int r ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 313
  if (! newthing___0) {
    {
#line 314
    tmp = xmalloc___1(sizeof(struct treething ));
#line 314
    newthing___0 = (struct treething *)tmp;
#line 315
    newthing___0->qu = (adns_query )0;
#line 316
    newthing___0->ans = (adns_answer *)0;
    }
  }
  {
#line 319
  memcpy((void */* __restrict  */)(newthing___0->bytes), (void const   */* __restrict  */)(bytes___0),
         (size_t )4);
#line 320
  tmp___0 = tsearch((void const   *)newthing___0, & treeroot___0, & comparer___0);
#line 320
  searchfound = (void **)tmp___0;
  }
#line 321
  if (! searchfound) {
    {
#line 321
    sysfail___1("tsearch");
    }
  }
#line 322
  foundthing = (struct treething *)*searchfound;
#line 324
  if ((unsigned long )foundthing == (unsigned long )newthing___0) {
    {
#line 325
    newthing___0 = (struct treething *)0;
#line 326
    memcpy((void */* __restrict  */)(& sa___0.sin_addr), (void const   */* __restrict  */)(bytes___0),
           (size_t )4);
#line 327
    r = adns_submit_reverse(ads___2, (struct sockaddr  const  *)(& sa___0), rrt___0,
                            (adns_queryflags )0, (void *)foundthing, & foundthing->qu);
    }
#line 329
    if (r) {
      {
#line 329
      adnsfail___0("submit", r);
      }
    }
  }
  {
#line 331
  tmp___1 = xmalloc___1(sizeof(*entry));
#line 331
  entry = (struct outqueuenode *)tmp___1;
#line 332
  entry->buffer = xmalloc___1((size_t )inbuf___0);
#line 333
  entry->textp = (char *)entry->buffer;
#line 334
  memcpy((void */* __restrict  */)entry->textp, (void const   */* __restrict  */)(addrtextbuf___0),
         (size_t )inbuf___0);
#line 335
  entry->textlen = inbuf___0;
#line 336
  entry->addr = foundthing;
#line 337
  entry->printbefore = printbefore___0;
  }
  {
#line 338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 338
    entry->next = (struct outqueuenode *)0;
#line 338
    entry->back = outqueue___0.tail;
#line 338
    if (outqueue___0.tail) {
#line 338
      (outqueue___0.tail)->next = entry;
    } else {
#line 338
      outqueue___0.head = entry;
    }
#line 338
    outqueue___0.tail = entry;
#line 338
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 339
  outqueuelen___0 ++;
#line 340
  inbuf___0 = 0;
#line 341
  cbyte___0 = -1;
#line 342
  return;
}
}
#line 344 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static void startaddr___0(void) 
{ 


  {
#line 345
  cbyte___0 = 0;
#line 345
  bytes___0[cbyte___0] = (unsigned char)0;
#line 346
  inbyte___0 = 0;
#line 347
  return;
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static void readstdin___0(void) 
{ 
  char readbuf[512] ;
  char *p ;
  int r ;
  int c ;
  int nbyte ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
  {
#line 353
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 353
    r = Hread(0, (void *)(readbuf), sizeof(readbuf));
    }
#line 353
    if (! (r <= 0)) {
#line 353
      goto while_break;
    }
#line 354
    if (r == 0) {
#line 354
      inputeof___0 = 1;
#line 354
      return;
    }
#line 355
    if (r == 11) {
#line 355
      return;
    }
#line 356
    if (r != 4) {
      {
#line 356
      sysfail___1("read stdin");
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 358
  p = readbuf;
  {
#line 358
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 358
    if (! (r > 0)) {
#line 358
      goto while_break___0;
    }
#line 359
    c = (int )*p;
#line 360
    if (cbyte___0 == -1) {
#line 360
      if (bracket___0) {
#line 360
        if (c == 91) {
          {
#line 361
          tmp = inbuf___0;
#line 361
          inbuf___0 ++;
#line 361
          addrtextbuf___0[tmp] = (char )c;
#line 362
          startaddr___0();
          }
        } else {
#line 360
          goto _L___15;
        }
      } else {
#line 360
        goto _L___15;
      }
    } else
    _L___15: /* CIL Label */ 
#line 363
    if (cbyte___0 == -1) {
#line 363
      if (! bracket___0) {
        {
#line 363
        tmp___5 = __ctype_b_loc();
        }
#line 363
        if ((int const   )*(*tmp___5 + c) & 8) {
#line 363
          goto _L___13;
        } else {
          {
#line 364
          queueoutchar___0(c);
#line 365
          startaddr___0();
          }
        }
      } else {
#line 363
        goto _L___13;
      }
    } else
    _L___13: /* CIL Label */ 
#line 366
    if (cbyte___0 >= 0) {
#line 366
      if (inbyte___0 < 3) {
#line 366
        if (c >= 48) {
#line 366
          if (c <= 57) {
#line 366
            nbyte = (int )bytes___0[cbyte___0] * 10 + (c - 48);
#line 366
            if (nbyte <= 255) {
#line 368
              bytes___0[cbyte___0] = (unsigned char )nbyte;
#line 369
              tmp___0 = inbuf___0;
#line 369
              inbuf___0 ++;
#line 369
              addrtextbuf___0[tmp___0] = (char )c;
#line 370
              inbyte___0 ++;
            } else {
#line 366
              goto _L___11;
            }
          } else {
#line 366
            goto _L___11;
          }
        } else {
#line 366
          goto _L___11;
        }
      } else {
#line 366
        goto _L___11;
      }
    } else
    _L___11: /* CIL Label */ 
#line 371
    if (cbyte___0 >= 0) {
#line 371
      if (cbyte___0 < 3) {
#line 371
        if (inbyte___0 > 0) {
#line 371
          if (c == 46) {
#line 372
            cbyte___0 ++;
#line 372
            bytes___0[cbyte___0] = (unsigned char)0;
#line 373
            tmp___1 = inbuf___0;
#line 373
            inbuf___0 ++;
#line 373
            addrtextbuf___0[tmp___1] = (char )c;
#line 374
            inbyte___0 = 0;
          } else {
#line 371
            goto _L___7;
          }
        } else {
#line 371
          goto _L___7;
        }
      } else {
#line 371
        goto _L___7;
      }
    } else
    _L___7: /* CIL Label */ 
#line 375
    if (cbyte___0 == 3) {
#line 375
      if (inbyte___0 > 0) {
#line 375
        if (bracket___0) {
#line 375
          if (c == 93) {
            {
#line 376
            tmp___2 = inbuf___0;
#line 376
            inbuf___0 ++;
#line 376
            addrtextbuf___0[tmp___2] = (char )c;
#line 377
            procaddr___0();
            }
          } else {
#line 375
            goto _L___4;
          }
        } else {
#line 375
          goto _L___4;
        }
      } else {
#line 375
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 378
    if (cbyte___0 == 3) {
#line 378
      if (inbyte___0 > 0) {
#line 378
        if (! bracket___0) {
          {
#line 378
          tmp___4 = __ctype_b_loc();
          }
#line 378
          if ((int const   )*(*tmp___4 + c) & 8) {
#line 378
            goto _L___1;
          } else {
            {
#line 379
            procaddr___0();
#line 380
            queueoutchar___0(c);
#line 381
            startaddr___0();
            }
          }
        } else {
#line 378
          goto _L___1;
        }
      } else {
#line 378
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 383
      restartbuf___0();
#line 384
      queueoutchar___0(c);
#line 385
      cbyte___0 = -1;
      }
#line 386
      if (! bracket___0) {
        {
#line 386
        tmp___3 = __ctype_b_loc();
        }
#line 386
        if (! ((int const   )*(*tmp___3 + c) & 8)) {
          {
#line 386
          startaddr___0();
          }
        }
      }
    }
#line 358
    r --;
#line 358
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 389
  return;
}
}
#line 391 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnsresfilter.c"
static void startup___0(void) 
{ 
  int r ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 394
  tmp = nonblock___0(0, 1);
  }
#line 394
  if (tmp) {
    {
#line 394
    sysfail___1("set stdin to nonblocking mode");
    }
  }
  {
#line 395
  tmp___0 = nonblock___0(1, 1);
  }
#line 395
  if (tmp___0) {
    {
#line 395
    sysfail___1("set stdout to nonblocking mode");
    }
  }
  {
#line 396
  memset((void *)(& sa___0), 0, sizeof(sa___0));
#line 397
  sa___0.sin_family = (sa_family_t )2;
  }
#line 398
  if (config_text___3) {
    {
#line 399
    r = adns_init_strcfg(& ads___2, initflags___0, stderr, config_text___3);
    }
  } else {
    {
#line 401
    r = adns_init(& ads___2, initflags___0, (FILE *)0);
    }
  }
#line 403
  if (r) {
    {
#line 403
    adnsfail___0("init", r);
    }
  }
#line 404
  cbyte___0 = -1;
#line 405
  inbyte___0 = -1;
#line 406
  inbuf___0 = 0;
#line 407
  if (! bracket___0) {
    {
#line 407
    startaddr___0();
    }
  }
#line 408
  return;
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfig___4(adns_state ads___7 , char const   *filename , int warnmissing ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void addserver___4(adns_state ads___7 , struct in_addr addr ) 
{ 
  int i ;
  struct server *ss ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 48
  i = 0;
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (i < ads___7->nservers)) {
#line 48
      goto while_break;
    }
#line 49
    if (ads___7->servers[i].addr.s_addr == addr.s_addr) {
      {
#line 50
      tmp = inet_ntoa(addr);
#line 50
      adns__debug(ads___7, -1, (adns_query )0, "duplicate nameserver %s ignored",
                  tmp);
      }
#line 51
      return;
    }
#line 48
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  if (ads___7->nservers >= 5) {
    {
#line 56
    tmp___0 = inet_ntoa(addr);
#line 56
    adns__diag(ads___7, -1, (adns_query )0, "too many nameservers, ignoring %s", tmp___0);
    }
#line 57
    return;
  }
#line 60
  ss = ads___7->servers + ads___7->nservers;
#line 61
  ss->addr = addr;
#line 62
  (ads___7->nservers) ++;
#line 63
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void freesearchlist___4(adns_state ads___7 ) 
{ 


  {
#line 66
  if (ads___7->nsearchlist) {
    {
#line 66
    Hfree((void *)*(ads___7->searchlist));
    }
  }
  {
#line 67
  Hfree((void *)ads___7->searchlist);
  }
#line 68
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void saveerr___4(adns_state ads___7 , int en ) 
{ 


  {
#line 71
  if (! ads___7->configerrno) {
#line 71
    ads___7->configerrno = en;
  }
#line 72
  return;
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void configparseerr___4(adns_state ads___7 , char const   *fn , int lno , char const   *fmt 
                               , ...) 
{ 
  va_list al ;

  {
  {
#line 78
  saveerr___4(ads___7, 22);
  }
#line 79
  if (! ads___7->logfn) {
#line 79
    return;
  } else
#line 79
  if ((unsigned int )ads___7->iflags & 2U) {
#line 79
    return;
  }
#line 81
  if (lno == -1) {
    {
#line 81
    adns__lprintf(ads___7, "adns: %s: ", fn);
    }
  } else {
    {
#line 82
    adns__lprintf(ads___7, "adns: %s:%d: ", fn, lno);
    }
  }
  {
#line 83
  __builtin_va_start(al, fmt);
#line 84
  adns__vlprintf(ads___7, fmt, al);
#line 85
  __builtin_va_end(al);
#line 86
  adns__lprintf(ads___7, "\n");
  }
#line 87
  return;
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int nextword___4(char const   **bufp_io , char const   **word_r , int *l_r ) 
{ 
  char const   *p ;
  char const   *q ;
  int tmp ;
  int tmp___0 ;

  {
#line 92
  p = *bufp_io;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 93
    tmp = ctype_whitespace((int )*p);
    }
#line 93
    if (! tmp) {
#line 93
      goto while_break;
    }
#line 93
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  if (! *p) {
#line 94
    return (0);
  }
#line 96
  q = p;
  {
#line 97
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 97
    if (*q) {
      {
#line 97
      tmp___0 = ctype_whitespace((int )*q);
      }
#line 97
      if (tmp___0) {
#line 97
        goto while_break___0;
      }
    } else {
#line 97
      goto while_break___0;
    }
#line 97
    q ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 99
  *l_r = (int )(q - p);
#line 100
  *word_r = p;
#line 101
  *bufp_io = q;
#line 103
  return (1);
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_nameserver___4(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  struct in_addr ia ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 110
  tmp = inet_aton(buf___17, & ia);
  }
#line 110
  if (! tmp) {
    {
#line 111
    configparseerr___4(ads___7, fn, lno, "invalid nameserver address `%s\'", buf___17);
    }
#line 112
    return;
  }
  {
#line 114
  tmp___0 = inet_ntoa(ia);
#line 114
  adns__debug(ads___7, -1, (adns_query )0, "using nameserver %s", tmp___0);
#line 115
  addserver___4(ads___7, ia);
  }
#line 116
  return;
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_search___4(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  char const   *bufp ;
  char const   *word ;
  char *newchars ;
  char **newptrs ;
  char **pp ;
  int count ;
  int tl ;
  int l ;
  int tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char **tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
#line 124
  if (! buf___17) {
#line 124
    return;
  }
#line 126
  bufp = buf___17;
#line 127
  count = 0;
#line 128
  tl = 0;
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 129
    tmp = nextword___4(& bufp, & word, & l);
    }
#line 129
    if (! tmp) {
#line 129
      goto while_break;
    }
#line 129
    count ++;
#line 129
    tl += l + 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 131
  tmp___0 = Hmalloc(sizeof(char *) * (unsigned long )count);
#line 131
  newptrs = (char **)tmp___0;
  }
#line 132
  if (! newptrs) {
    {
#line 132
    tmp___1 = __errno_location();
#line 132
    saveerr___4(ads___7, *tmp___1);
    }
#line 132
    return;
  }
  {
#line 134
  tmp___2 = Hmalloc((size_t )tl);
#line 134
  newchars = (char *)tmp___2;
  }
#line 135
  if (! newchars) {
    {
#line 135
    tmp___3 = __errno_location();
#line 135
    saveerr___4(ads___7, *tmp___3);
#line 135
    Hfree((void *)newptrs);
    }
#line 135
    return;
  }
#line 137
  bufp = buf___17;
#line 138
  pp = newptrs;
  {
#line 139
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 139
    tmp___6 = nextword___4(& bufp, & word, & l);
    }
#line 139
    if (! tmp___6) {
#line 139
      goto while_break___0;
    }
    {
#line 140
    tmp___4 = pp;
#line 140
    pp ++;
#line 140
    *tmp___4 = newchars;
#line 141
    memcpy((void */* __restrict  */)newchars, (void const   */* __restrict  */)word,
           (size_t )l);
#line 142
    newchars += l;
#line 143
    tmp___5 = newchars;
#line 143
    newchars ++;
#line 143
    *tmp___5 = (char)0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 146
  freesearchlist___4(ads___7);
#line 147
  ads___7->nsearchlist = count;
#line 148
  ads___7->searchlist = newptrs;
  }
#line 149
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_sortlist___4(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  char const   *word ;
  char tbuf[200] ;
  char *slash ;
  char *ep ;
  struct in_addr base ;
  struct in_addr mask ;
  int l ;
  unsigned long initial ;
  unsigned long baselocal ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  uint32_t tmp___3 ;
  int tmp___4 ;

  {
#line 159
  if (! buf___17) {
#line 159
    return;
  }
#line 161
  ads___7->nsortlist = 0;
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 162
    tmp___4 = nextword___4(& buf___17, & word, & l);
    }
#line 162
    if (! tmp___4) {
#line 162
      goto while_break;
    }
#line 163
    if (ads___7->nsortlist >= 15) {
      {
#line 164
      adns__diag(ads___7, -1, (adns_query )0, "too many sortlist entries, ignoring %.*s onwards",
                 l, word);
      }
#line 166
      return;
    }
#line 169
    if ((unsigned long )l >= sizeof(tbuf)) {
      {
#line 170
      configparseerr___4(ads___7, fn, lno, "sortlist entry `%.*s\' too long", l, word);
      }
#line 171
      goto while_continue;
    }
    {
#line 174
    memcpy((void */* __restrict  */)(tbuf), (void const   */* __restrict  */)word,
           (size_t )l);
#line 174
    tbuf[l] = (char)0;
#line 175
    slash = strchr((char const   *)(tbuf), '/');
    }
#line 176
    if (slash) {
#line 176
      tmp = slash;
#line 176
      slash ++;
#line 176
      *tmp = (char)0;
    }
    {
#line 178
    tmp___0 = inet_aton((char const   *)(tbuf), & base);
    }
#line 178
    if (! tmp___0) {
      {
#line 179
      configparseerr___4(ads___7, fn, lno, "invalid address `%s\' in sortlist", tbuf);
      }
#line 180
      goto while_continue;
    }
#line 183
    if (slash) {
      {
#line 184
      tmp___2 = strchr((char const   *)slash, '.');
      }
#line 184
      if (tmp___2) {
        {
#line 185
        tmp___1 = inet_aton((char const   *)slash, & mask);
        }
#line 185
        if (! tmp___1) {
          {
#line 186
          configparseerr___4(ads___7, fn, lno, "invalid mask `%s\' in sortlist", slash);
          }
#line 187
          goto while_continue;
        }
#line 189
        if (base.s_addr & ~ mask.s_addr) {
          {
#line 190
          configparseerr___4(ads___7, fn, lno, "mask `%s\' in sortlist overlaps address `%s\'",
                             slash, tbuf);
          }
#line 192
          goto while_continue;
        }
      } else {
        {
#line 195
        initial = strtoul((char const   */* __restrict  */)slash, (char **/* __restrict  */)(& ep),
                          10);
        }
#line 196
        if (*ep) {
          {
#line 197
          configparseerr___4(ads___7, fn, lno, "mask length `%s\' invalid", slash);
          }
#line 198
          goto while_continue;
        } else
#line 196
        if (initial > 32UL) {
          {
#line 197
          configparseerr___4(ads___7, fn, lno, "mask length `%s\' invalid", slash);
          }
#line 198
          goto while_continue;
        }
        {
#line 200
        mask.s_addr = htonl((uint32_t )(4294967295UL << (32UL - initial)));
        }
      }
    } else {
      {
#line 203
      tmp___3 = ntohl(base.s_addr);
#line 203
      baselocal = (unsigned long )tmp___3;
      }
#line 204
      if ((unsigned long )(! baselocal) & 2147483648UL) {
        {
#line 205
        mask.s_addr = htonl((uint32_t )4278190080UL);
        }
      } else
#line 206
      if ((baselocal & 3221225472UL) == 2147483648UL) {
        {
#line 207
        mask.s_addr = htonl((uint32_t )4294901760UL);
        }
      } else
#line 208
      if ((baselocal & 4026531840UL) == 3758096384UL) {
        {
#line 209
        mask.s_addr = htonl((uint32_t )4278190080UL);
        }
      } else {
        {
#line 211
        configparseerr___4(ads___7, fn, lno, "network address `%s\' in sortlist is not in classed ranges, must specify mask explicitly",
                           tbuf);
        }
#line 214
        goto while_continue;
      }
    }
#line 218
    ads___7->sortlist[ads___7->nsortlist].base = base;
#line 219
    ads___7->sortlist[ads___7->nsortlist].mask = mask;
#line 220
    (ads___7->nsortlist) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  return;
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_options___4(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  char const   *word ;
  char *ep ;
  unsigned long v ;
  int l ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 231
  if (! buf___17) {
#line 231
    return;
  }
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 233
    tmp___5 = nextword___4(& buf___17, & word, & l);
    }
#line 233
    if (! tmp___5) {
#line 233
      goto while_break;
    }
#line 234
    if (l == 5) {
      {
#line 234
      tmp = memcmp((void const   *)word, (void const   *)"debug", (size_t )5);
      }
#line 234
      if (! tmp) {
#line 235
        ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 8U);
#line 236
        goto while_continue;
      }
    }
#line 238
    if (l >= 6) {
      {
#line 238
      tmp___0 = memcmp((void const   *)word, (void const   *)"ndots:", (size_t )6);
      }
#line 238
      if (! tmp___0) {
        {
#line 239
        v = strtoul((char const   */* __restrict  */)(word + 6), (char **/* __restrict  */)(& ep),
                    10);
        }
#line 240
        if (l == 6) {
          {
#line 241
          configparseerr___4(ads___7, fn, lno, "option `%.*s\' malformed or has bad value",
                             l, word);
          }
#line 243
          goto while_continue;
        } else
#line 240
        if ((unsigned long )ep != (unsigned long )(word + l)) {
          {
#line 241
          configparseerr___4(ads___7, fn, lno, "option `%.*s\' malformed or has bad value",
                             l, word);
          }
#line 243
          goto while_continue;
        } else
#line 240
        if (v > 2147483647UL) {
          {
#line 241
          configparseerr___4(ads___7, fn, lno, "option `%.*s\' malformed or has bad value",
                             l, word);
          }
#line 243
          goto while_continue;
        }
#line 245
        ads___7->searchndots = (int )v;
#line 246
        goto while_continue;
      }
    }
#line 248
    if (l >= 12) {
      {
#line 248
      tmp___4 = memcmp((void const   *)word, (void const   *)"adns_checkc:", (size_t )12);
      }
#line 248
      if (! tmp___4) {
        {
#line 249
        tmp___3 = strcmp(word + 12, "none");
        }
#line 249
        if (tmp___3) {
          {
#line 252
          tmp___2 = strcmp(word + 12, "entex");
          }
#line 252
          if (tmp___2) {
            {
#line 255
            tmp___1 = strcmp(word + 12, "freq");
            }
#line 255
            if (tmp___1) {
              {
#line 258
              configparseerr___4(ads___7, fn, lno, "option adns_checkc has bad value `%s\' (must be none, entex or freq",
                                 word + 12);
              }
            } else {
#line 256
              ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 768U);
            }
          } else {
#line 253
            ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags & 4294966527U);
#line 254
            ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 256U);
          }
        } else {
#line 250
          ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags & 4294966527U);
#line 251
          ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 256U);
        }
#line 261
        goto while_continue;
      }
    }
    {
#line 263
    adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown option `%.*s\'", fn, lno,
               l, word);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 265
  return;
}
}
#line 267 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_clearnss___4(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 


  {
#line 269
  ads___7->nservers = 0;
#line 270
  return;
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_include___4(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 


  {
#line 274
  if (! *buf___17) {
    {
#line 275
    configparseerr___4(ads___7, fn, lno, "`include\' directive with no filename");
    }
#line 276
    return;
  }
  {
#line 278
  readconfig___4(ads___7, buf___17, 1);
  }
#line 279
  return;
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_lookup___4(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  int found_bind ;
  char const   *word ;
  int l ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 283
  found_bind = 0;
#line 287
  if (! *buf___17) {
    {
#line 288
    configparseerr___4(ads___7, fn, lno, "`lookup\' directive with no databases");
    }
#line 289
    return;
  }
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 292
    tmp___2 = nextword___4(& buf___17, & word, & l);
    }
#line 292
    if (! tmp___2) {
#line 292
      goto while_break;
    }
#line 293
    if (l == 4) {
      {
#line 293
      tmp___1 = memcmp((void const   *)word, (void const   *)"bind", (size_t )4);
      }
#line 293
      if (tmp___1) {
#line 293
        goto _L___0;
      } else {
#line 294
        found_bind = 1;
      }
    } else
    _L___0: /* CIL Label */ 
#line 295
    if (l == 4) {
      {
#line 295
      tmp___0 = memcmp((void const   *)word, (void const   *)"file", (size_t )4);
      }
#line 295
      if (tmp___0) {
#line 295
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 297
    if (l == 2) {
      {
#line 297
      tmp = memcmp((void const   *)word, (void const   *)"yp", (size_t )2);
      }
#line 297
      if (tmp) {
        {
#line 301
        adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown `lookup\' database `%.*s\'",
                   fn, lno, l, word);
#line 303
        found_bind = -1;
        }
      } else {
        {
#line 298
        adns__diag(ads___7, -1, (adns_query )0, "%s:%d: yp lookups not supported by adns",
                   fn, lno);
#line 299
        found_bind = -1;
        }
      }
    } else {
      {
#line 301
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown `lookup\' database `%.*s\'",
                 fn, lno, l, word);
#line 303
      found_bind = -1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 306
  if (! found_bind) {
    {
#line 307
    adns__diag(ads___7, -1, (adns_query )0, "%s:%d: `lookup\' specified, but not `bind\'",
               fn, lno);
    }
  }
#line 308
  return;
}
}
#line 310 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static struct configcommandinfo  const  configcommandinfos___4[9]  = 
#line 310
  {      {"nameserver", & ccf_nameserver___4}, 
        {"domain", & ccf_search___4}, 
        {"search", & ccf_search___4}, 
        {"sortlist", & ccf_sortlist___4}, 
        {"options", & ccf_options___4}, 
        {"clearnameservers", & ccf_clearnss___4}, 
        {"include", & ccf_include___4}, 
        {"lookup", & ccf_lookup___4}, 
        {(char const   *)0, (void (*)(adns_state ads , char const   *fn , int lno , char const   *buf ))0}};
#line 330 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int gl_file___4(adns_state ads___7 , getline_ctx *src_io , char const   *filename ,
                       int lno , char *buf___17 , int buflen ) 
{ 
  FILE *file ;
  int c ;
  int i ;
  char *p ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 332
  file = src_io->file;
#line 336
  p = buf___17;
#line 337
  buflen --;
#line 338
  i = 0;
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (i == buflen) {
      {
#line 342
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: line too long, ignored", filename,
                 lno);
      }
#line 343
      goto x_badline;
    }
    {
#line 345
    c = _IO_getc(file);
    }
#line 346
    if (! c) {
      {
#line 347
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: line contains nul, ignored",
                 filename, lno);
      }
#line 348
      goto x_badline;
    } else
#line 349
    if (c == 10) {
#line 350
      goto while_break;
    } else
#line 351
    if (c == -1) {
      {
#line 352
      tmp___2 = ferror(file);
      }
#line 352
      if (tmp___2) {
        {
#line 353
        tmp = __errno_location();
#line 353
        saveerr___4(ads___7, *tmp);
#line 354
        tmp___0 = __errno_location();
#line 354
        tmp___1 = strerror(*tmp___0);
#line 354
        adns__diag(ads___7, -1, (adns_query )0, "%s:%d: read error: %s", filename,
                   lno, tmp___1);
        }
#line 356
        return (-1);
      }
#line 358
      if (! i) {
#line 358
        return (-1);
      }
#line 359
      goto while_break;
    } else {
#line 361
      tmp___3 = p;
#line 361
      p ++;
#line 361
      *tmp___3 = (char )c;
#line 362
      i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 366
  tmp___4 = p;
#line 366
  p ++;
#line 366
  *tmp___4 = (char)0;
#line 367
  return (i);
  x_badline: 
  {
#line 370
  saveerr___4(ads___7, 22);
  }
  {
#line 371
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 371
    c = _IO_getc(file);
    }
#line 371
    if (c != -1) {
#line 371
      if (! (c != 10)) {
#line 371
        goto while_break___0;
      }
    } else {
#line 371
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 372
  return (-2);
}
}
#line 375 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int gl_text___4(adns_state ads___7 , getline_ctx *src_io , char const   *filename ,
                       int lno , char *buf___17 , int buflen ) 
{ 
  char const   *cp ;
  int l ;
  size_t tmp ;

  {
#line 377
  cp = src_io->text;
#line 380
  if (! cp) {
#line 380
    return (-1);
  } else
#line 380
  if (! *cp) {
#line 380
    return (-1);
  }
#line 382
  if ((int const   )*cp == 59) {
#line 382
    cp ++;
  } else
#line 382
  if ((int const   )*cp == 10) {
#line 382
    cp ++;
  }
  {
#line 383
  tmp = strcspn(cp, ";\n");
#line 383
  l = (int )tmp;
#line 384
  src_io->text = cp + l;
  }
#line 386
  if (l >= buflen) {
    {
#line 387
    adns__diag(ads___7, -1, (adns_query )0, "%s:%d: line too long, ignored", filename,
               lno);
#line 388
    saveerr___4(ads___7, 22);
    }
#line 389
    return (-2);
  }
  {
#line 392
  memcpy((void */* __restrict  */)buf___17, (void const   */* __restrict  */)cp, (size_t )l);
#line 393
  *(buf___17 + l) = (char)0;
  }
#line 394
  return (l);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfiggeneric___4(adns_state ads___7 , char const   *filename , int (*getline___0)(adns_state ads ,
                                                                                                   getline_ctx * ,
                                                                                                   char const   *filename ,
                                                                                                   int lno ,
                                                                                                   char *buf ,
                                                                                                   int buflen ) ,
                                  getline_ctx gl_ctx ) 
{ 
  char linebuf[2000] ;
  char *p ;
  char *q ;
  int lno ;
  int l ;
  int dirl ;
  struct configcommandinfo  const  *ccip ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 410
  lno = 1;
  {
#line 410
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 410
    l = (*getline___0)(ads___7, & gl_ctx, filename, lno, linebuf, (int )sizeof(linebuf));
    }
#line 410
    if (! (l != -1)) {
#line 410
      goto while_break;
    }
#line 413
    if (l == -2) {
#line 413
      goto __Cont;
    }
    {
#line 414
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 414
      if (l > 0) {
        {
#line 414
        tmp = ctype_whitespace((int )linebuf[l - 1]);
        }
#line 414
        if (! tmp) {
#line 414
          goto while_break___0;
        }
      } else {
#line 414
        goto while_break___0;
      }
#line 414
      l --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 415
    linebuf[l] = (char)0;
#line 416
    p = linebuf;
    {
#line 417
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 417
      tmp___0 = ctype_whitespace((int )*p);
      }
#line 417
      if (! tmp___0) {
#line 417
        goto while_break___1;
      }
#line 417
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 418
    if ((int )*p == 35) {
#line 418
      goto __Cont;
    } else
#line 418
    if ((int )*p == 59) {
#line 418
      goto __Cont;
    } else
#line 418
    if (! *p) {
#line 418
      goto __Cont;
    }
#line 419
    q = p;
    {
#line 420
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 420
      if (*q) {
        {
#line 420
        tmp___1 = ctype_whitespace((int )*q);
        }
#line 420
        if (tmp___1) {
#line 420
          goto while_break___2;
        }
      } else {
#line 420
        goto while_break___2;
      }
#line 420
      q ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 421
    dirl = (int )(q - p);
#line 422
    ccip = configcommandinfos___4;
    {
#line 422
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 422
      if (ccip->name) {
        {
#line 422
        tmp___2 = strlen((char const   *)ccip->name);
        }
#line 422
        if (tmp___2 == (size_t )dirl) {
          {
#line 422
          tmp___3 = memcmp((void const   *)ccip->name, (void const   *)p, (size_t )(q - p));
          }
#line 422
          if (! tmp___3) {
#line 422
            goto while_break___3;
          }
        }
      } else {
#line 422
        goto while_break___3;
      }
#line 422
      ccip ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 426
    if (! ccip->name) {
      {
#line 427
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown configuration directive `%.*s\'",
                 filename, lno, (int )(q - p), p);
      }
#line 429
      goto __Cont;
    }
    {
#line 431
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 431
      tmp___4 = ctype_whitespace((int )*q);
      }
#line 431
      if (! tmp___4) {
#line 431
        goto while_break___4;
      }
#line 431
      q ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 432
    (*(ccip->fn))(ads___7, filename, lno, (char const   *)q);
    }
    __Cont: /* CIL Label */ 
#line 410
    lno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 434
  return;
}
}
#line 436 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static char const   *instrum_getenv___4(adns_state ads___7 , char const   *envvar ) 
{ 
  char const   *value ;
  char *tmp ;

  {
  {
#line 439
  tmp = getenv(envvar);
#line 439
  value = (char const   *)tmp;
  }
#line 440
  if (! value) {
    {
#line 440
    adns__debug(ads___7, -1, (adns_query )0, "environment variable %s not set", envvar);
    }
  } else {
    {
#line 441
    adns__debug(ads___7, -1, (adns_query )0, "environment variable %s set to `%s\'",
                envvar, value);
    }
  }
#line 443
  return (value);
}
}
#line 446 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfig___4(adns_state ads___7 , char const   *filename , int warnmissing ) 
{ 
  getline_ctx gl_ctx ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 449
  gl_ctx.file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 450
  if (! gl_ctx.file) {
    {
#line 451
    tmp = __errno_location();
    }
#line 451
    if (*tmp == 2) {
#line 452
      if (warnmissing) {
        {
#line 453
        adns__debug(ads___7, -1, (adns_query )0, "configuration file `%s\' does not exist",
                    filename);
        }
      }
#line 455
      return;
    }
    {
#line 457
    tmp___0 = __errno_location();
#line 457
    saveerr___4(ads___7, *tmp___0);
#line 458
    tmp___1 = __errno_location();
#line 458
    tmp___2 = strerror(*tmp___1);
#line 458
    adns__diag(ads___7, -1, (adns_query )0, "cannot open configuration file `%s\': %s",
               filename, tmp___2);
    }
#line 460
    return;
  }
  {
#line 463
  readconfiggeneric___4(ads___7, filename, & gl_file___4, gl_ctx);
#line 465
  fclose(gl_ctx.file);
  }
#line 466
  return;
}
}
#line 468 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfigtext___4(adns_state ads___7 , char const   *text , char const   *showname ) 
{ 
  getline_ctx gl_ctx ;

  {
  {
#line 472
  gl_ctx.text = text;
#line 473
  readconfiggeneric___4(ads___7, showname, & gl_text___4, gl_ctx);
  }
#line 474
  return;
}
}
#line 476 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfigenv___4(adns_state ads___7 , char const   *envvar ) 
{ 
  char const   *filename ;

  {
#line 479
  if ((unsigned int )ads___7->iflags & 1U) {
    {
#line 480
    adns__debug(ads___7, -1, (adns_query )0, "not checking environment variable `%s\'",
                envvar);
    }
#line 481
    return;
  }
  {
#line 483
  filename = instrum_getenv___4(ads___7, envvar);
  }
#line 484
  if (filename) {
    {
#line 484
    readconfig___4(ads___7, filename, 1);
    }
  }
#line 485
  return;
}
}
#line 487 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfigenvtext___4(adns_state ads___7 , char const   *envvar ) 
{ 
  char const   *textdata ;

  {
#line 490
  if ((unsigned int )ads___7->iflags & 1U) {
    {
#line 491
    adns__debug(ads___7, -1, (adns_query )0, "not checking environment variable `%s\'",
                envvar);
    }
#line 492
    return;
  }
  {
#line 494
  textdata = instrum_getenv___4(ads___7, envvar);
  }
#line 495
  if (textdata) {
    {
#line 495
    readconfigtext___4(ads___7, textdata, envvar);
    }
  }
#line 496
  return;
}
}
#line 508 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int init_begin___4(adns_state *ads_r , adns_initflags flags , adns_logcallbackfn *logfn ,
                          void *logfndata ) 
{ 
  adns_state ads___7 ;
  pid_t pid ;
  void *tmp ;
  int *tmp___0 ;
  adns_query tmp___1 ;
  adns_query tmp___2 ;
  adns_query tmp___3 ;
  adns_query tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __suseconds_t tmp___9 ;

  {
  {
#line 513
  tmp = Hmalloc(sizeof(*ads___7));
#line 513
  ads___7 = (adns_state )tmp;
  }
#line 513
  if (! ads___7) {
    {
#line 513
    tmp___0 = __errno_location();
    }
#line 513
    return (*tmp___0);
  }
  {
#line 515
  ads___7->iflags = flags;
#line 516
  ads___7->logfn = logfn;
#line 517
  ads___7->logfndata = logfndata;
#line 518
  ads___7->configerrno = 0;
#line 519
  tmp___1 = (adns_query )0;
#line 519
  ads___7->udpw.tail = tmp___1;
#line 519
  ads___7->udpw.head = tmp___1;
#line 520
  tmp___2 = (adns_query )0;
#line 520
  ads___7->tcpw.tail = tmp___2;
#line 520
  ads___7->tcpw.head = tmp___2;
#line 521
  tmp___3 = (adns_query )0;
#line 521
  ads___7->childw.tail = tmp___3;
#line 521
  ads___7->childw.head = tmp___3;
#line 522
  tmp___4 = (adns_query )0;
#line 522
  ads___7->output.tail = tmp___4;
#line 522
  ads___7->output.head = tmp___4;
#line 523
  ads___7->forallnext = (adns_query )0;
#line 524
  ads___7->nextid = 12575;
#line 525
  tmp___5 = -1;
#line 525
  ads___7->tcpsocket = tmp___5;
#line 525
  ads___7->udpsocket = tmp___5;
#line 526
  adns__vbuf_init(& ads___7->tcpsend);
#line 527
  adns__vbuf_init(& ads___7->tcprecv);
#line 528
  ads___7->tcprecv_skip = 0;
#line 529
  tmp___8 = 0;
#line 529
  ads___7->tcpserver = tmp___8;
#line 529
  tmp___7 = tmp___8;
#line 529
  ads___7->nsearchlist = tmp___7;
#line 529
  tmp___6 = tmp___7;
#line 529
  ads___7->nsortlist = tmp___6;
#line 529
  ads___7->nservers = tmp___6;
#line 530
  ads___7->searchndots = 1;
#line 531
  ads___7->tcpstate = (enum adns__tcpstate )0;
#line 532
  tmp___9 = (__suseconds_t )0;
#line 532
  ads___7->tcptimeout.tv_usec = tmp___9;
#line 532
  ads___7->tcptimeout.tv_sec = tmp___9;
#line 533
  ads___7->searchlist = (char **)0;
#line 535
  pid = Hgetpid();
#line 536
  ads___7->rand48xsubi[0] = (unsigned short )pid;
#line 537
  ads___7->rand48xsubi[1] = (unsigned short )((unsigned long )pid >> 16);
#line 538
  ads___7->rand48xsubi[2] = (unsigned short )((unsigned long )pid ^ ((unsigned long )pid >> 16));
#line 540
  *ads_r = ads___7;
  }
#line 541
  return (0);
}
}
#line 544 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int init_finish___4(adns_state ads___7 ) 
{ 
  struct in_addr ia ;
  struct protoent *proto ;
  int r ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 549
  if (! ads___7->nservers) {
#line 550
    if (ads___7->logfn) {
#line 550
      if ((unsigned int )ads___7->iflags & 8U) {
        {
#line 551
        adns__lprintf(ads___7, "adns: no nameservers, using localhost\n");
        }
      }
    }
    {
#line 552
    ia.s_addr = htonl((in_addr_t )2130706433);
#line 553
    addserver___4(ads___7, ia);
    }
  }
  {
#line 556
  proto = getprotobyname("udp");
  }
#line 556
  if (! proto) {
#line 556
    r = 92;
#line 556
    goto x_free;
  }
  {
#line 557
  ads___7->udpsocket = Hsocket(2, 2, proto->p_proto);
  }
#line 558
  if (ads___7->udpsocket < 0) {
    {
#line 558
    tmp = __errno_location();
#line 558
    r = *tmp;
    }
#line 558
    goto x_free;
  }
  {
#line 560
  r = adns__setnonblock(ads___7, ads___7->udpsocket);
  }
#line 561
  if (r) {
    {
#line 561
    tmp___0 = __errno_location();
#line 561
    r = *tmp___0;
    }
#line 561
    goto x_closeudp;
  }
#line 563
  return (0);
  x_closeudp: 
  {
#line 566
  Hclose(ads___7->udpsocket);
  }
  x_free: 
  {
#line 568
  Hfree((void *)ads___7);
  }
#line 569
  return (r);
}
}
#line 572 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void init_abort___4(adns_state ads___7 ) 
{ 


  {
#line 573
  if (ads___7->nsearchlist) {
    {
#line 574
    Hfree((void *)*(ads___7->searchlist + 0));
#line 575
    Hfree((void *)ads___7->searchlist);
    }
  }
  {
#line 577
  Hfree((void *)ads___7);
  }
#line 578
  return;
}
}
#line 580 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void logfn_file___4(adns_state ads___7 , void *logfndata , char const   *fmt ,
                           va_list al ) 
{ 


  {
  {
#line 582
  vfprintf((FILE */* __restrict  */)logfndata, (char const   */* __restrict  */)fmt,
           al);
  }
#line 583
  return;
}
}
#line 585 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int init_files___4(adns_state *ads_r , adns_initflags flags , adns_logcallbackfn *logfn ,
                          void *logfndata ) 
{ 
  adns_state ads___7 ;
  char const   *res_options ;
  char const   *adns_res_options ;
  int r ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 591
  r = init_begin___4(& ads___7, flags, logfn, logfndata);
  }
#line 592
  if (r) {
#line 592
    return (r);
  }
  {
#line 594
  res_options = instrum_getenv___4(ads___7, "RES_OPTIONS");
#line 595
  adns_res_options = instrum_getenv___4(ads___7, "ADNS_RES_OPTIONS");
#line 596
  ccf_options___4(ads___7, "RES_OPTIONS", -1, res_options);
#line 597
  ccf_options___4(ads___7, "ADNS_RES_OPTIONS", -1, adns_res_options);
#line 599
  readconfig___4(ads___7, "/etc/resolv.conf", 1);
#line 600
  readconfig___4(ads___7, "/etc/resolv-adns.conf", 0);
#line 601
  readconfigenv___4(ads___7, "RES_CONF");
#line 602
  readconfigenv___4(ads___7, "ADNS_RES_CONF");
#line 604
  readconfigenvtext___4(ads___7, "RES_CONF_TEXT");
#line 605
  readconfigenvtext___4(ads___7, "ADNS_RES_CONF_TEXT");
#line 607
  ccf_options___4(ads___7, "RES_OPTIONS", -1, res_options);
#line 608
  ccf_options___4(ads___7, "ADNS_RES_OPTIONS", -1, adns_res_options);
#line 610
  tmp = instrum_getenv___4(ads___7, "LOCALDOMAIN");
#line 610
  ccf_search___4(ads___7, "LOCALDOMAIN", -1, tmp);
#line 611
  tmp___0 = instrum_getenv___4(ads___7, "ADNS_LOCALDOMAIN");
#line 611
  ccf_search___4(ads___7, "ADNS_LOCALDOMAIN", -1, tmp___0);
  }
#line 613
  if (ads___7->configerrno) {
#line 613
    if (ads___7->configerrno != 22) {
      {
#line 614
      r = ads___7->configerrno;
#line 615
      init_abort___4(ads___7);
      }
#line 616
      return (r);
    }
  }
  {
#line 619
  r = init_finish___4(ads___7);
  }
#line 620
  if (r) {
#line 620
    return (r);
  }
  {
#line 622
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
#line 623
  *ads_r = ads___7;
  }
#line 624
  return (0);
}
}
#line 631 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int init_strcfg___4(adns_state *ads_r , adns_initflags flags , adns_logcallbackfn *logfn ,
                           void *logfndata , char const   *configtext ) 
{ 
  adns_state ads___7 ;
  int r ;

  {
  {
#line 637
  r = init_begin___4(& ads___7, flags, logfn, logfndata);
  }
#line 638
  if (r) {
#line 638
    return (r);
  }
  {
#line 640
  readconfigtext___4(ads___7, configtext, "<supplied configuration text>");
  }
#line 641
  if (ads___7->configerrno) {
    {
#line 642
    r = ads___7->configerrno;
#line 643
    init_abort___4(ads___7);
    }
#line 644
    return (r);
  }
  {
#line 647
  r = init_finish___4(ads___7);
  }
#line 647
  if (r) {
#line 647
    return (r);
  }
  {
#line 648
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
#line 649
  *ads_r = ads___7;
  }
#line 650
  return (0);
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
static vbuf vbw___4  ;
#line 175 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
static void Tvbpollevents___4(int events ) 
{ 
  char const   *delim ;

  {
#line 176
  delim = "";
#line 177
  events &= 7;
#line 178
  if (! events) {
    {
#line 178
    Tvba("0");
    }
#line 178
    return;
  }
#line 179
  if (events & 1) {
    {
#line 179
    Tvba("POLLIN");
#line 179
    delim = "|";
    }
  }
#line 180
  if (events & 4) {
    {
#line 180
    Tvba(delim);
#line 180
    Tvba("POLLOUT");
#line 180
    delim = "|";
    }
  }
#line 181
  if (events & 2) {
    {
#line 181
    Tvba(delim);
#line 181
    Tvba("POLLPRI");
    }
  }
#line 182
  return;
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
static unsigned long malloccount___4  ;
#line 241 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
static unsigned long mallocfailat___4  ;
#line 242 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
static struct __anonstruct_mallocedlist_90___4 mallocedlist___4  ;
#line 13 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static FILE *Tinputfile___1  ;
#line 13 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static FILE *Treportfile___1  ;
#line 14 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static vbuf vb2___1  ;
#line 18 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static void Tensurereportfile___1(void) 
{ 
  char const   *fdstr ;
  int fd ;
  char *tmp ;

  {
#line 21
  if (Treportfile___1) {
#line 21
    return;
  }
  {
#line 22
  Treportfile___1 = stderr;
#line 23
  tmp = getenv("ADNS_TEST_REPORT_FD");
#line 23
  fdstr = (char const   *)tmp;
  }
#line 23
  if (! fdstr) {
#line 23
    return;
  }
  {
#line 24
  fd = atoi(fdstr);
#line 25
  Treportfile___1 = fdopen(fd, "a");
  }
#line 25
  if (! Treportfile___1) {
    {
#line 25
    Tfailed("fdopen ADNS_TEST_REPORT_FD");
    }
  }
#line 26
  return;
}
}
#line 27 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static void Psyntax___1(char const   *where ) 
{ 


  {
  {
#line 28
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adns test harness: syntax error in test log input file: %s\n",
          where);
#line 29
  exit(-1);
  }
}
}
#line 31 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static void Pcheckinput___1(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 32
  tmp = ferror(Tinputfile___1);
  }
#line 32
  if (tmp) {
    {
#line 32
    Tfailed("read test log input file");
    }
  }
  {
#line 33
  tmp___0 = feof(Tinputfile___1);
  }
#line 33
  if (tmp___0) {
    {
#line 33
    Psyntax___1("eof at syscall reply");
    }
  }
#line 34
  return;
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static void Parg___1(char const   *argname ) 
{ 
  int l ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 59
  tmp = vb2___1.used;
#line 59
  (vb2___1.used) ++;
#line 59
  if ((int )*(vb2___1.buf + tmp) != 32) {
    {
#line 59
    Psyntax___1("not a space before argument");
    }
  }
  {
#line 60
  tmp___0 = strlen(argname);
#line 60
  l = (int )tmp___0;
#line 61
  tmp___1 = memcmp((void const   *)(vb2___1.buf + vb2___1.used), (void const   *)argname,
                   (size_t )l);
  }
#line 61
  if (tmp___1) {
    {
#line 61
    Psyntax___1("argument name wrong");
    }
  }
#line 62
  vb2___1.used += l;
#line 63
  tmp___2 = vb2___1.used;
#line 63
  (vb2___1.used) ++;
#line 63
  if ((int )*(vb2___1.buf + tmp___2) != 61) {
    {
#line 63
    Psyntax___1("not = after argument name");
    }
  }
#line 64
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static int Pstring_maybe___1(char const   *string ) 
{ 
  int l ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 67
  tmp = strlen(string);
#line 67
  l = (int )tmp;
#line 68
  tmp___0 = memcmp((void const   *)(vb2___1.buf + vb2___1.used), (void const   *)string,
                   (size_t )l);
  }
#line 68
  if (tmp___0) {
#line 68
    return (0);
  }
#line 69
  vb2___1.used += l;
#line 70
  return (1);
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static void Pstring___1(char const   *string , char const   *emsg ) 
{ 
  int tmp ;

  {
  {
#line 73
  tmp = Pstring_maybe___1(string);
  }
#line 73
  if (tmp) {
#line 73
    return;
  }
  {
#line 74
  Psyntax___1(emsg);
  }
#line 75
  return;
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static int Perrno___1(char const   *stuff ) 
{ 
  struct Terrno  const  *te ;
  int r ;
  char *ep ;
  int tmp ;
  unsigned long tmp___0 ;

  {
#line 80
  te = Terrnos;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    if (te->n) {
      {
#line 80
      tmp = strcmp((char const   *)te->n, stuff);
      }
#line 80
      if (! tmp) {
#line 80
        goto while_break;
      }
    } else {
#line 80
      goto while_break;
    }
#line 80
    te ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  if (te->n) {
#line 81
    return ((int )te->v);
  }
  {
#line 82
  tmp___0 = strtoul((char const   */* __restrict  */)(stuff + 2), (char **/* __restrict  */)(& ep),
                    10);
#line 82
  r = (int )tmp___0;
  }
#line 83
  if (*ep) {
    {
#line 83
    Psyntax___1("errno value not recognised, not numeric");
    }
  }
#line 84
  return (r);
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static void P_updatetime___1(void) 
{ 
  int chars ;
  unsigned long sec ;
  unsigned long usec ;
  int tmp ;

  {
  {
#line 89
  tmp = adns__vbuf_ensure(& vb2___1, 1000);
  }
#line 89
  if (! tmp) {
    {
#line 89
    Tnomem();
    }
  }
  {
#line 90
  fgets((char */* __restrict  */)vb2___1.buf, vb2___1.avail, (FILE */* __restrict  */)Tinputfile___1);
#line 90
  Pcheckinput___1();
#line 91
  chars = -1;
#line 92
  sscanf((char const   */* __restrict  */)vb2___1.buf, (char const   */* __restrict  */)" +%lu.%lu%n",
         & sec, & usec, & chars);
  }
#line 93
  if (chars == -1) {
    {
#line 93
    Psyntax___1("update time invalid");
    }
  }
#line 94
  currenttime.tv_sec = (__time_t )((unsigned long )currenttime.tv_sec + sec);
#line 95
  currenttime.tv_usec = (__suseconds_t )((unsigned long )currenttime.tv_usec + usec);
#line 96
  if (currenttime.tv_usec > 1000000L) {
#line 97
    (currenttime.tv_sec) ++;
#line 98
    currenttime.tv_usec -= 1000000L;
  }
#line 100
  if ((int )*(vb2___1.buf + chars) != 10) {
    {
#line 100
    Psyntax___1("not newline after update time");
    }
  }
#line 101
  return;
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static void Pfdset___1(fd_set *set , int max ) 
{ 
  int r ;
  int c ;
  char *ep ;
  int tmp ;
  int __d0 ;
  int __d1 ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
#line 105
  tmp = vb2___1.used;
#line 105
  (vb2___1.used) ++;
#line 105
  if ((int )*(vb2___1.buf + tmp) != 91) {
    {
#line 105
    Psyntax___1("fd set start not [");
    }
  }
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& set->__fds_bits[0]): "memory");
#line 106
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  if ((int )*(vb2___1.buf + vb2___1.used) == 93) {
#line 107
    (vb2___1.used) ++;
#line 107
    return;
  }
  {
#line 108
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 109
    tmp___0 = strtoul((char const   */* __restrict  */)(vb2___1.buf + vb2___1.used),
                      (char **/* __restrict  */)(& ep), 10);
#line 109
    r = (int )tmp___0;
    }
#line 110
    if (r >= max) {
      {
#line 110
      Psyntax___1("fd set member > max");
      }
    }
#line 111
    if ((unsigned long )ep == (unsigned long )((char *)vb2___1.buf + vb2___1.used)) {
      {
#line 111
      Psyntax___1("empty entry in fd set");
      }
    }
#line 112
    set->__fds_bits[r / (8 * (int )sizeof(__fd_mask ))] |= 1L << r % (8 * (int )sizeof(__fd_mask ));
#line 113
    vb2___1.used = (int )(ep - (char *)vb2___1.buf);
#line 114
    tmp___1 = vb2___1.used;
#line 114
    (vb2___1.used) ++;
#line 114
    c = (int )*(vb2___1.buf + tmp___1);
#line 115
    if (c == 93) {
#line 115
      goto while_break___0;
    }
#line 116
    if (c != 44) {
      {
#line 116
      Psyntax___1("fd set separator not ,");
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 118
  return;
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static int Ppollfdevents___1(void) 
{ 
  int events ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 122
  tmp = Pstring_maybe___1("0");
  }
#line 122
  if (tmp) {
#line 122
    return (0);
  }
  {
#line 123
  events = 0;
#line 124
  tmp___1 = Pstring_maybe___1("POLLIN");
  }
#line 124
  if (tmp___1) {
    {
#line 125
    events |= 1;
#line 126
    tmp___0 = Pstring_maybe___1("|");
    }
#line 126
    if (! tmp___0) {
#line 126
      return (events);
    }
  }
  {
#line 128
  tmp___3 = Pstring_maybe___1("POLLOUT");
  }
#line 128
  if (tmp___3) {
    {
#line 129
    events |= 4;
#line 130
    tmp___2 = Pstring_maybe___1("|");
    }
#line 130
    if (! tmp___2) {
#line 130
      return (events);
    }
  }
  {
#line 132
  Pstring___1("POLLPRI", "pollfdevents PRI?");
  }
#line 133
  return (events);
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static void Ppollfds___1(struct pollfd *fds , int nfds ) 
{ 
  int i ;
  char *ep ;
  char const   *comma ;
  int tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 138
  comma = "";
#line 139
  tmp = vb2___1.used;
#line 139
  (vb2___1.used) ++;
#line 139
  if ((int )*(vb2___1.buf + tmp) != 91) {
    {
#line 139
    Psyntax___1("pollfds start not [");
    }
  }
#line 140
  i = 0;
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if (! (i < nfds)) {
#line 140
      goto while_break;
    }
    {
#line 141
    Pstring___1("{fd=", "{fd= in pollfds");
#line 142
    tmp___0 = strtoul((char const   */* __restrict  */)(vb2___1.buf + vb2___1.used),
                      (char **/* __restrict  */)(& ep), 10);
#line 142
    fds->fd = (int )tmp___0;
#line 143
    vb2___1.used = (int )(ep - (char *)vb2___1.buf);
#line 144
    Pstring___1(", events=", ", events= in pollfds");
#line 145
    tmp___1 = Ppollfdevents___1();
#line 145
    fds->events = (short )tmp___1;
#line 146
    Pstring___1(", revents=", ", revents= in pollfds");
#line 147
    tmp___2 = Ppollfdevents___1();
#line 147
    fds->revents = (short )tmp___2;
#line 148
    Pstring___1("}", "} in pollfds");
#line 149
    Pstring___1(comma, "separator in pollfds");
#line 150
    comma = ", ";
#line 140
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 152
  tmp___3 = vb2___1.used;
#line 152
  (vb2___1.used) ++;
#line 152
  if ((int )*(vb2___1.buf + tmp___3) != 93) {
    {
#line 152
    Psyntax___1("pollfds end not ]");
    }
  }
#line 153
  return;
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static void Paddr___1(struct sockaddr *addr , int *lenr ) 
{ 
  struct sockaddr_in *sa___3 ;
  char *p ;
  char *ep ;
  long ul ;
  char *tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 156
  sa___3 = (struct sockaddr_in *)addr;
#line 159
  if (! ((unsigned long )*lenr >= sizeof(*sa___3))) {
    {
#line 159
    __assert_fail("*lenr >= sizeof(*sa)", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c",
                  159U, "Paddr");
    }
  }
  {
#line 160
  p = strchr((char const   *)(vb2___1.buf + vb2___1.used), ':');
  }
#line 161
  if (! p) {
    {
#line 161
    Psyntax___1("no port on address");
    }
  }
  {
#line 162
  tmp = p;
#line 162
  p ++;
#line 162
  *tmp = (char)0;
#line 163
  memset((void *)sa___3, 0, sizeof(*sa___3));
#line 164
  sa___3->sin_family = (sa_family_t )2;
#line 165
  tmp___0 = inet_aton((char const   *)(vb2___1.buf + vb2___1.used), & sa___3->sin_addr);
  }
#line 165
  if (! tmp___0) {
    {
#line 165
    Psyntax___1("invalid address");
    }
  }
  {
#line 166
  tmp___1 = strtoul((char const   */* __restrict  */)p, (char **/* __restrict  */)(& ep),
                    10);
#line 166
  ul = (long )tmp___1;
  }
#line 167
  if (*ep) {
#line 167
    if ((int )*ep != 32) {
      {
#line 167
      Psyntax___1("invalid port (bad syntax)");
      }
    }
  }
#line 168
  if (ul >= 65536L) {
    {
#line 168
    Psyntax___1("port too large");
    }
  }
  {
#line 169
  sa___3->sin_port = htons((uint16_t )ul);
#line 170
  *lenr = (int )sizeof(*sa___3);
#line 171
  vb2___1.used = (int )(ep - (char *)vb2___1.buf);
  }
#line 172
  return;
}
}
#line 174
static int Pbytes___1(byte *buf___17 , int maxlen ) ;
#line 174 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static char const   hexdigits___1[17]  = 
#line 174
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'\000'};
#line 173 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static int Pbytes___1(byte *buf___17 , int maxlen ) 
{ 
  int c ;
  int v ;
  int done ;
  char const   *pf ;
  char *tmp ;
  char *tmp___0 ;
  byte *tmp___1 ;

  {
#line 177
  done = 0;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 179
    c = _IO_getc(Tinputfile___1);
#line 179
    Pcheckinput___1();
    }
#line 180
    if (c == 10) {
#line 180
      goto __Cont;
    } else
#line 180
    if (c == 32) {
#line 180
      goto __Cont;
    } else
#line 180
    if (c == 9) {
#line 180
      goto __Cont;
    }
#line 181
    if (c == 46) {
#line 181
      goto while_break;
    }
    {
#line 182
    tmp = strchr(hexdigits___1, c);
#line 182
    pf = (char const   *)tmp;
    }
#line 182
    if (! pf) {
      {
#line 182
      Psyntax___1("invalid first hex digit");
      }
    }
    {
#line 183
    v = (int )((pf - hexdigits___1) << 4);
#line 184
    c = _IO_getc(Tinputfile___1);
#line 184
    Pcheckinput___1();
#line 185
    tmp___0 = strchr(hexdigits___1, c);
#line 185
    pf = (char const   *)tmp___0;
    }
#line 185
    if (! pf) {
      {
#line 185
      Psyntax___1("invalid second hex digit");
      }
    }
#line 186
    v = (int )((long )v | (pf - hexdigits___1));
#line 187
    if (maxlen <= 0) {
      {
#line 187
      Psyntax___1("buffer overflow in bytes");
      }
    }
#line 188
    tmp___1 = buf___17;
#line 188
    buf___17 ++;
#line 188
    *tmp___1 = (byte )v;
#line 189
    maxlen --;
#line 189
    done ++;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 191
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 192
    c = _IO_getc(Tinputfile___1);
#line 192
    Pcheckinput___1();
    }
#line 193
    if (c == 10) {
#line 193
      return (done);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_qstring___4(parseinfo const   *pai , int *cbyte_io , int max ,
                                   int *len_r , char **str_r ) 
{ 
  byte const   *dgram ;
  int l ;
  int cbyte___3 ;
  char *str ;
  int tmp ;
  void *tmp___0 ;

  {
#line 92
  dgram = (byte const   *)pai->dgram;
#line 96
  cbyte___3 = *cbyte_io;
#line 98
  if (cbyte___3 >= max) {
#line 98
    return ((adns_status )104);
  }
#line 99
  tmp = cbyte___3;
#line 99
  cbyte___3 ++;
#line 99
  l = (int )((int const   )*(dgram + tmp) & 255);
#line 100
  if (cbyte___3 + l > max) {
#line 100
    return ((adns_status )104);
  }
  {
#line 102
  tmp___0 = adns__alloc_interim((adns_query )pai->qu, (size_t )(l + 1));
#line 102
  str = (char *)tmp___0;
  }
#line 103
  if (! str) {
#line 103
    return ((adns_status )1);
  }
  {
#line 105
  *(str + l) = (char)0;
#line 106
  memcpy((void */* __restrict  */)str, (void const   */* __restrict  */)(dgram + cbyte___3),
         (size_t )l);
#line 108
  *len_r = l;
#line 109
  *str_r = str;
#line 110
  *cbyte_io = cbyte___3 + l;
  }
#line 112
  return ((adns_status )0);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_qstring___4(vbuf *vb___0 , char const   *dp , int len ) 
{ 
  unsigned char ch ;
  char buf___17[10] ;
  int cn ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 120
    tmp = adns__vbuf_appendstr(vb___0, "\"");
    }
#line 120
    if (! tmp) {
#line 120
      return ((adns_status )1);
    }
#line 120
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  cn = 0;
  {
#line 121
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 121
    if (! (cn < len)) {
#line 121
      goto while_break___0;
    }
#line 122
    tmp___0 = dp;
#line 122
    dp ++;
#line 122
    ch = (unsigned char )*tmp___0;
#line 123
    if ((int )ch == 92) {
      {
#line 124
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 124
        tmp___1 = adns__vbuf_appendstr(vb___0, "\\\\");
        }
#line 124
        if (! tmp___1) {
#line 124
          return ((adns_status )1);
        }
#line 124
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else
#line 125
    if ((int )ch == 34) {
      {
#line 126
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 126
        tmp___2 = adns__vbuf_appendstr(vb___0, "\\\"");
        }
#line 126
        if (! tmp___2) {
#line 126
          return ((adns_status )1);
        }
#line 126
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else
#line 127
    if ((int )ch >= 32) {
#line 127
      if ((int )ch <= 126) {
        {
#line 128
        tmp___3 = adns__vbuf_append(vb___0, (byte const   *)(& ch), 1);
        }
#line 128
        if (! tmp___3) {
#line 128
          return ((adns_status )1);
        }
      } else {
#line 127
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 130
      sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"\\x%02x",
              (int )ch);
      }
      {
#line 131
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 131
        tmp___4 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
        }
#line 131
        if (! tmp___4) {
#line 131
          return ((adns_status )1);
        }
#line 131
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 121
    cn ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 134
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 134
    tmp___5 = adns__vbuf_appendstr(vb___0, "\"");
    }
#line 134
    if (! tmp___5) {
#line 134
      return ((adns_status )1);
    }
#line 134
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 136
  return ((adns_status )0);
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_str___4(adns_query qu , void *datap ) 
{ 
  char **rrp ;

  {
  {
#line 144
  rrp = (char **)datap;
#line 146
  adns__makefinal_str(qu, rrp);
  }
#line 147
  return;
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_intstr___4(adns_query qu , void *datap ) 
{ 
  adns_rr_intstr *rrp ;

  {
  {
#line 154
  rrp = (adns_rr_intstr *)datap;
#line 156
  adns__makefinal_str(qu, & rrp->str);
  }
#line 157
  return;
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_manyistr___4(adns_query qu , void *datap ) 
{ 
  adns_rr_intstr **rrp ;
  adns_rr_intstr *te ;
  adns_rr_intstr *table ;
  void *tablev ;
  int tc ;

  {
#line 164
  rrp = (adns_rr_intstr **)datap;
#line 169
  tc = 0;
#line 169
  te = *rrp;
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    if (! (te->i >= 0)) {
#line 169
      goto while_break;
    }
#line 169
    te ++;
#line 169
    tc ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 170
  tablev = (void *)*rrp;
#line 171
  adns__makefinal_block(qu, & tablev, sizeof(*te) * (unsigned long )(tc + 1));
#line 172
  table = (adns_rr_intstr *)tablev;
#line 172
  *rrp = table;
#line 173
  te = *rrp;
  }
  {
#line 173
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 173
    if (! (te->i >= 0)) {
#line 173
      goto while_break___0;
    }
    {
#line 174
    adns__makefinal_str(qu, & te->str);
#line 173
    te ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 175
  return;
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_txt___4(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  adns_rr_intstr **rrp ;
  adns_rr_intstr *table ;
  adns_rr_intstr *te ;
  byte const   *dgram ;
  int ti ;
  int tc ;
  int l ;
  int startbyte ;
  adns_status st ;
  int tmp ;
  void *tmp___0 ;

  {
#line 183
  rrp = (adns_rr_intstr **)datap;
#line 184
  dgram = (byte const   *)pai->dgram;
#line 188
  startbyte = cbyte___3;
#line 189
  if (cbyte___3 >= max) {
#line 189
    return ((adns_status )104);
  }
#line 190
  tc = 0;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! (cbyte___3 < max)) {
#line 191
      goto while_break;
    }
#line 192
    tmp = cbyte___3;
#line 192
    cbyte___3 ++;
#line 192
    l = (int )((int const   )*(dgram + tmp) & 255);
#line 193
    cbyte___3 += l;
#line 194
    tc ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  if (cbyte___3 != max) {
#line 196
    return ((adns_status )104);
  } else
#line 196
  if (! tc) {
#line 196
    return ((adns_status )104);
  }
  {
#line 198
  tmp___0 = adns__alloc_interim((adns_query )pai->qu, sizeof(*table) * (unsigned long )(tc + 1));
#line 198
  table = (adns_rr_intstr *)tmp___0;
  }
#line 199
  if (! table) {
#line 199
    return ((adns_status )1);
  }
#line 201
  cbyte___3 = startbyte;
#line 201
  ti = 0;
#line 201
  te = table;
  {
#line 201
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 201
    if (! (ti < tc)) {
#line 201
      goto while_break___0;
    }
    {
#line 202
    st = pap_qstring___4(pai, & cbyte___3, max, & te->i, & te->str);
    }
#line 203
    if (st) {
#line 203
      return (st);
    }
#line 201
    ti ++;
#line 201
    te ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 205
  if (! (cbyte___3 == max)) {
    {
#line 205
    __assert_fail("cbyte == max", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  205U, "pa_txt");
    }
  }
#line 207
  te->i = -1;
#line 208
  te->str = (char *)0;
#line 210
  *rrp = table;
#line 211
  return ((adns_status )0);
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_txt___4(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_intstr const   * const  *rrp ;
  adns_rr_intstr const   *current ;
  adns_status st ;
  int spc ;
  int tmp ;

  {
#line 215
  rrp = (adns_rr_intstr const   * const  *)datap;
#line 220
  current = (adns_rr_intstr const   *)*rrp;
#line 220
  spc = 0;
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    if (! (current->i >= 0)) {
#line 220
      goto while_break;
    }
#line 221
    if (spc) {
      {
#line 221
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 221
        tmp = adns__vbuf_appendstr(vb___0, " ");
        }
#line 221
        if (! tmp) {
#line 221
          return ((adns_status )1);
        }
#line 221
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 222
    st = csp_qstring___4(vb___0, (char const   *)current->str, (int )current->i);
    }
#line 222
    if (st) {
#line 222
      return (st);
    }
#line 220
    current ++;
#line 220
    spc = 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  return ((adns_status )0);
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_hinfo___4(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_intstrpair const   *rrp ;
  adns_status st ;
  int tmp ;

  {
  {
#line 232
  rrp = (adns_rr_intstrpair const   *)datap;
#line 235
  st = csp_qstring___4(vb___0, (char const   *)rrp->array[0].str, (int )rrp->array[0].i);
  }
#line 235
  if (st) {
#line 235
    return (st);
  }
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 236
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 236
    if (! tmp) {
#line 236
      return ((adns_status )1);
    }
#line 236
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 237
  st = csp_qstring___4(vb___0, (char const   *)rrp->array[1].str, (int )rrp->array[1].i);
  }
#line 237
  if (st) {
#line 237
    return (st);
  }
#line 238
  return ((adns_status )0);
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_inaddr___4(parseinfo const   *pai , int cbyte___3 , int max ,
                                 void *datap ) 
{ 
  struct in_addr *storeto ;

  {
#line 247
  storeto = (struct in_addr *)datap;
#line 249
  if (max - cbyte___3 != 4) {
#line 249
    return ((adns_status )104);
  }
  {
#line 250
  memcpy((void */* __restrict  */)storeto, (void const   */* __restrict  */)(pai->dgram + cbyte___3),
         (size_t )4);
  }
#line 251
  return ((adns_status )0);
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int search_sortlist___4(adns_state ads___7 , struct in_addr ad ) 
{ 
  struct sortlist  const  *slp ;
  int i ;

  {
#line 258
  i = 0;
#line 258
  slp = (struct sortlist  const  *)(ads___7->sortlist);
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 258
    if (i < ads___7->nsortlist) {
#line 258
      if (! (! ((ad.s_addr & (unsigned int )slp->mask.s_addr) == (unsigned int )slp->base.s_addr))) {
#line 258
        goto while_break;
      }
    } else {
#line 258
      goto while_break;
    }
#line 258
    i ++;
#line 258
    slp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  return (i);
}
}
#line 265 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int dip_inaddr___4(adns_state ads___7 , struct in_addr a , struct in_addr b ) 
{ 
  int ai ;
  int bi ;

  {
#line 268
  if (! ads___7->nsortlist) {
#line 268
    return (0);
  }
  {
#line 270
  ai = search_sortlist___4(ads___7, a);
#line 271
  bi = search_sortlist___4(ads___7, b);
  }
#line 272
  return (bi < ai);
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_inaddr___4(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  struct in_addr  const  *ap ;
  struct in_addr  const  *bp ;
  int tmp ;

  {
  {
#line 277
  ap = (struct in_addr  const  *)datap_a;
#line 277
  bp = (struct in_addr  const  *)datap_b;
#line 279
  tmp = dip_inaddr___4(ads___7, (struct in_addr )*ap, (struct in_addr )*bp);
  }
#line 279
  return (tmp);
}
}
#line 282 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_inaddr___4(vbuf *vb___0 , void const   *datap ) 
{ 
  struct in_addr  const  *rrp ;
  struct in_addr rr ;
  char const   *ia ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 283
  rrp = (struct in_addr  const  *)datap;
#line 283
  rr = *rrp;
#line 286
  tmp = inet_ntoa(rr);
#line 286
  ia = (char const   *)tmp;
  }
#line 286
  if (! ia) {
    {
#line 286
    __assert_fail("ia", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  286U, "cs_inaddr");
    }
  }
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 287
    tmp___0 = adns__vbuf_appendstr(vb___0, ia);
    }
#line 287
    if (! tmp___0) {
#line 287
      return ((adns_status )1);
    }
#line 287
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  return ((adns_status )0);
}
}
#line 295 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_addr___4(parseinfo const   *pai , int cbyte___3 , int max ,
                               void *datap ) 
{ 
  adns_rr_addr *storeto ;
  byte const   *dgram ;

  {
#line 297
  storeto = (adns_rr_addr *)datap;
#line 298
  dgram = (byte const   *)pai->dgram;
#line 300
  if (max - cbyte___3 != 4) {
#line 300
    return ((adns_status )104);
  }
  {
#line 301
  storeto->len = (int )sizeof(storeto->addr.inet);
#line 302
  memset((void *)(& storeto->addr), 0, sizeof(storeto->addr.inet));
#line 303
  storeto->addr.inet.sin_family = (sa_family_t )2;
#line 304
  memcpy((void */* __restrict  */)(& storeto->addr.inet.sin_addr), (void const   */* __restrict  */)(dgram + cbyte___3),
         (size_t )4);
  }
#line 305
  return ((adns_status )0);
}
}
#line 308 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_addr___4(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_addr const   *ap ;
  adns_rr_addr const   *bp ;
  int tmp ;

  {
#line 309
  ap = (adns_rr_addr const   *)datap_a;
#line 309
  bp = (adns_rr_addr const   *)datap_b;
#line 311
  if (! ((int const   )ap->addr.sa.sa_family == 2)) {
    {
#line 311
    __assert_fail("ap->addr.sa.sa_family == 2", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  311U, "di_addr");
    }
  }
  {
#line 312
  tmp = dip_inaddr___4(ads___7, (struct in_addr )ap->addr.inet.sin_addr, (struct in_addr )bp->addr.inet.sin_addr);
  }
#line 312
  return (tmp);
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int div_addr___4(void *context , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_state ads___7 ;
  int tmp ;

  {
  {
#line 316
  ads___7 = (adns_state )context;
#line 318
  tmp = di_addr___4(ads___7, datap_a, datap_b);
  }
#line 318
  return (tmp);
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_addr___4(vbuf *vb___0 , adns_rr_addr const   *rrp ) 
{ 
  char const   *ia ;
  char buf___17[30] ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 326
  if ((int const   )rrp->addr.inet.sin_family == 2) {
#line 326
    goto case_2;
  }
#line 331
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 327
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 327
    tmp = adns__vbuf_appendstr(vb___0, "INET ");
    }
#line 327
    if (! tmp) {
#line 327
      return ((adns_status )1);
    }
#line 327
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 328
  tmp___0 = inet_ntoa((struct in_addr )rrp->addr.inet.sin_addr);
#line 328
  ia = (char const   *)tmp___0;
  }
#line 328
  if (! ia) {
    {
#line 328
    __assert_fail("ia", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  328U, "csp_addr");
    }
  }
  {
#line 329
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 329
    tmp___1 = adns__vbuf_appendstr(vb___0, ia);
    }
#line 329
    if (! tmp___1) {
#line 329
      return ((adns_status )1);
    }
#line 329
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 330
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 332
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"AF=%u",
          (int const   )rrp->addr.sa.sa_family);
  }
  {
#line 333
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 333
    tmp___2 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 333
    if (! tmp___2) {
#line 333
      return ((adns_status )1);
    }
#line 333
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 334
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 336
  return ((adns_status )0);
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_addr___4(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_addr const   *rrp ;
  adns_status tmp ;

  {
  {
#line 340
  rrp = (adns_rr_addr const   *)datap;
#line 342
  tmp = csp_addr___4(vb___0, rrp);
  }
#line 342
  return (tmp);
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_domain___4(parseinfo const   *pai , int *cbyte_io , int max ,
                                  char **domain_r , parsedomain_flags flags ) 
{ 
  adns_status st ;
  char *dm ;
  void *tmp ;

  {
  {
#line 355
  st = adns__parse_domain((pai->qu)->ads, (int )pai->serv, (adns_query )pai->qu, & (pai->qu)->vb,
                          flags, (byte const   *)pai->dgram, (int )pai->dglen, cbyte_io,
                          max);
  }
#line 357
  if (st) {
#line 357
    return (st);
  }
#line 358
  if (! (pai->qu)->vb.used) {
#line 358
    return ((adns_status )104);
  }
  {
#line 360
  tmp = adns__alloc_interim((adns_query )pai->qu, (size_t )((pai->qu)->vb.used + 1));
#line 360
  dm = (char *)tmp;
  }
#line 361
  if (! dm) {
#line 361
    return ((adns_status )1);
  }
  {
#line 363
  *(dm + (pai->qu)->vb.used) = (char)0;
#line 364
  memcpy((void */* __restrict  */)dm, (void const   */* __restrict  */)(pai->qu)->vb.buf,
         (size_t )(pai->qu)->vb.used);
#line 366
  *domain_r = dm;
  }
#line 367
  return ((adns_status )0);
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_domain___4(vbuf *vb___0 , char const   *domain ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 371
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 371
    tmp = adns__vbuf_appendstr(vb___0, domain);
    }
#line 371
    if (! tmp) {
#line 371
      return ((adns_status )1);
    }
#line 371
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 372
  if (! *domain) {
    {
#line 372
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 372
      tmp___0 = adns__vbuf_appendstr(vb___0, ".");
      }
#line 372
      if (! tmp___0) {
#line 372
        return ((adns_status )1);
      }
#line 372
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 373
  return ((adns_status )0);
}
}
#line 376 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_domain___4(vbuf *vb___0 , void const   *datap ) 
{ 
  char const   * const  *domainp ;
  adns_status tmp ;

  {
  {
#line 377
  domainp = (char const   * const  *)datap;
#line 378
  tmp = csp_domain___4(vb___0, (char const   *)*domainp);
  }
#line 378
  return (tmp);
}
}
#line 381 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_dom_raw___4(parseinfo const   *pai , int cbyte___3 , int max ,
                                  void *datap ) 
{ 
  char **rrp ;
  adns_status st ;

  {
  {
#line 383
  rrp = (char **)datap;
#line 386
  st = pap_domain___4(pai, & cbyte___3, max, rrp, (parsedomain_flags )1);
  }
#line 387
  if (st) {
#line 387
    return (st);
  }
#line 389
  if (cbyte___3 != max) {
#line 389
    return ((adns_status )104);
  }
#line 390
  return ((adns_status )0);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_host_raw___4(parseinfo const   *pai , int cbyte___3 , int max ,
                                   void *datap ) 
{ 
  char **rrp ;
  adns_status st ;
  int tmp ;

  {
#line 399
  rrp = (char **)datap;
#line 402
  if ((pai->qu)->flags & 64) {
#line 402
    tmp = 1;
  } else {
#line 402
    tmp = 0;
  }
  {
#line 402
  st = pap_domain___4(pai, & cbyte___3, max, rrp, (parsedomain_flags )tmp);
  }
#line 404
  if (st) {
#line 404
    return (st);
  }
#line 406
  if (cbyte___3 != max) {
#line 406
    return ((adns_status )104);
  }
#line 407
  return ((adns_status )0);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_findaddrs___4(parseinfo const   *pai , adns_rr_hostaddr *ha ,
                                     int *cbyte_io , int count , int dmstart ) 
{ 
  int rri ;
  int naddrs ;
  int type ;
  int class ;
  int rdlen ;
  int rdstart ;
  int ownermatched ;
  unsigned long ttl ;
  adns_status st ;
  int tmp ;
  void *tmp___0 ;

  {
#line 421
  rri = 0;
#line 421
  naddrs = -1;
  {
#line 421
  while (1) {
    while_continue: /* CIL Label */ ;
#line 421
    if (! (rri < count)) {
#line 421
      goto while_break;
    }
    {
#line 422
    st = adns__findrr_anychk((adns_query )pai->qu, (int )pai->serv, (byte const   *)pai->dgram,
                             (int )pai->dglen, cbyte_io, & type, & class, & ttl, & rdlen,
                             & rdstart, (byte const   *)pai->dgram, (int )pai->dglen,
                             dmstart, & ownermatched);
    }
#line 426
    if (st) {
#line 426
      return (st);
    }
#line 427
    if (! ownermatched) {
#line 427
      goto _L;
    } else
#line 427
    if (class != 1) {
#line 427
      goto _L;
    } else
#line 427
    if (type != 1) {
      _L: /* CIL Label */ 
#line 428
      if (naddrs > 0) {
#line 428
        goto while_break;
      } else {
#line 428
        goto __Cont;
      }
    }
#line 430
    if (naddrs == -1) {
#line 431
      naddrs = 0;
    }
    {
#line 433
    tmp = adns__vbuf_ensure(& (pai->qu)->vb, (int )((unsigned long )(naddrs + 1) * sizeof(adns_rr_addr )));
    }
#line 433
    if (! tmp) {
#line 434
      return ((adns_status )1);
    }
    {
#line 435
    adns__update_expires((adns_query )pai->qu, ttl, (struct timeval )pai->now);
#line 436
    st = pa_addr___4(pai, rdstart, rdstart + rdlen, (void *)((pai->qu)->vb.buf + (unsigned long )naddrs * sizeof(adns_rr_addr )));
    }
#line 438
    if (st) {
#line 438
      return (st);
    }
#line 439
    naddrs ++;
    __Cont: /* CIL Label */ 
#line 421
    rri ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 441
  if (naddrs >= 0) {
    {
#line 442
    tmp___0 = adns__alloc_interim((adns_query )pai->qu, (unsigned long )naddrs * sizeof(adns_rr_addr ));
#line 442
    ha->addrs = (adns_rr_addr *)tmp___0;
    }
#line 443
    if (! ha->addrs) {
#line 443
      return ((adns_status )1);
    }
    {
#line 444
    memcpy((void */* __restrict  */)ha->addrs, (void const   */* __restrict  */)(pai->qu)->vb.buf,
           (unsigned long )naddrs * sizeof(adns_rr_addr ));
#line 445
    ha->naddrs = naddrs;
#line 446
    ha->astatus = (adns_status )0;
#line 448
    adns__isort((void *)ha->addrs, naddrs, (int )sizeof(adns_rr_addr ), (void *)(pai->qu)->vb.buf,
                & div_addr___4, (void *)pai->ads);
    }
  }
#line 451
  return ((adns_status )0);
}
}
#line 454 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void icb_hostaddr___4(adns_query parent , adns_query child ) 
{ 
  adns_answer *cans ;
  adns_rr_hostaddr *rrp ;
  adns_state ads___7 ;
  adns_status st ;

  {
#line 455
  cans = child->answer;
#line 456
  rrp = child->ctx.info.hostaddr;
#line 457
  ads___7 = parent->ads;
#line 460
  st = cans->status;
#line 461
  rrp->astatus = st;
#line 462
  if ((unsigned int )st > 0U) {
#line 462
    if ((unsigned int )st <= 99U) {
#line 462
      rrp->naddrs = -1;
    } else {
#line 462
      rrp->naddrs = cans->nrrs;
    }
  } else {
#line 462
    rrp->naddrs = cans->nrrs;
  }
  {
#line 463
  rrp->addrs = cans->rrs.addr;
#line 464
  adns__transfer_interim(child, parent, (void *)rrp->addrs, (unsigned long )rrp->naddrs * sizeof(adns_rr_addr ));
  }
#line 467
  if (parent->children.head) {
    {
#line 468
    while (1) {
      while_continue: /* CIL Label */ ;
#line 468
      parent->next = (adns_query )0;
#line 468
      parent->back = ads___7->childw.tail;
#line 468
      if (ads___7->childw.tail) {
#line 468
        (ads___7->childw.tail)->next = parent;
      } else {
#line 468
        ads___7->childw.head = parent;
      }
#line 468
      ads___7->childw.tail = parent;
#line 468
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 470
    adns__query_done(parent);
    }
  }
#line 472
  return;
}
}
#line 474 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_hostaddr___4(parseinfo const   *pai , int *cbyte_io , int max ,
                                    adns_rr_hostaddr *rrp ) 
{ 
  adns_status st ;
  int dmstart ;
  int cbyte___3 ;
  qcontext ctx ;
  int id ;
  adns_query nqu ;
  adns_queryflags nflags ;
  int tmp ;
  typeinfo const   *tmp___0 ;

  {
#line 483
  cbyte___3 = *cbyte_io;
#line 483
  dmstart = cbyte___3;
#line 484
  if ((pai->qu)->flags & 64) {
#line 484
    tmp = 1;
  } else {
#line 484
    tmp = 0;
  }
  {
#line 484
  st = pap_domain___4(pai, & cbyte___3, max, & rrp->host, (parsedomain_flags )tmp);
  }
#line 486
  if (st) {
#line 486
    return (st);
  }
  {
#line 487
  *cbyte_io = cbyte___3;
#line 489
  rrp->astatus = (adns_status )0;
#line 490
  rrp->naddrs = -1;
#line 491
  rrp->addrs = (adns_rr_addr *)0;
#line 493
  cbyte___3 = (int )pai->nsstart;
#line 495
  st = pap_findaddrs___4(pai, rrp, & cbyte___3, (int )pai->nscount, dmstart);
  }
#line 496
  if (st) {
#line 496
    return (st);
  }
#line 497
  if (rrp->naddrs != -1) {
#line 497
    return ((adns_status )0);
  }
  {
#line 499
  st = pap_findaddrs___4(pai, rrp, & cbyte___3, (int )pai->arcount, dmstart);
  }
#line 500
  if (st) {
#line 500
    return (st);
  }
#line 501
  if (rrp->naddrs != -1) {
#line 501
    return ((adns_status )0);
  }
  {
#line 503
  st = adns__mkquery_frdgram((adns_state )pai->ads, & (pai->qu)->vb, & id, (byte const   *)pai->dgram,
                             (int )pai->dglen, dmstart, (adns_rrtype )65537, (adns_queryflags )16);
  }
#line 506
  if (st) {
#line 506
    return (st);
  }
#line 508
  ctx.ext = (void *)0;
#line 509
  ctx.callback = & icb_hostaddr___4;
#line 510
  ctx.info.hostaddr = rrp;
#line 512
  nflags = (adns_queryflags )16;
#line 513
  if (! ((pai->qu)->flags & 256)) {
#line 513
    nflags = (adns_queryflags )((unsigned int )nflags | 512U);
  }
  {
#line 515
  tmp___0 = adns__findtype((adns_rrtype )65537);
#line 515
  st = adns__internal_submit((adns_state )pai->ads, & nqu, tmp___0, & (pai->qu)->vb,
                             id, nflags, (struct timeval )pai->now, (qcontext const   *)(& ctx));
  }
#line 517
  if (st) {
#line 517
    return (st);
  }
#line 519
  nqu->parent = (adns_query )pai->qu;
  {
#line 520
  while (1) {
    while_continue: /* CIL Label */ ;
#line 520
    nqu->siblings.next = (adns_query )0;
#line 520
    nqu->siblings.back = (pai->qu)->children.tail;
#line 520
    if ((pai->qu)->children.tail) {
#line 520
      ((pai->qu)->children.tail)->siblings.next = nqu;
    } else {
#line 520
      (pai->qu)->children.head = nqu;
    }
#line 520
    (pai->qu)->children.tail = nqu;
#line 520
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 522
  return ((adns_status )0);
}
}
#line 525 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_hostaddr___4(parseinfo const   *pai , int cbyte___3 , int max ,
                                   void *datap ) 
{ 
  adns_rr_hostaddr *rrp ;
  adns_status st ;

  {
  {
#line 527
  rrp = (adns_rr_hostaddr *)datap;
#line 530
  st = pap_hostaddr___4(pai, & cbyte___3, max, rrp);
  }
#line 531
  if (st) {
#line 531
    return (st);
  }
#line 532
  if (cbyte___3 != max) {
#line 532
    return ((adns_status )104);
  }
#line 534
  return ((adns_status )0);
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int dip_hostaddr___4(adns_state ads___7 , adns_rr_hostaddr const   *ap , adns_rr_hostaddr const   *bp ) 
{ 
  int tmp ;

  {
#line 539
  if ((unsigned int const   )ap->astatus != (unsigned int const   )bp->astatus) {
#line 539
    return ((int )ap->astatus);
  }
#line 540
  if (ap->astatus) {
#line 540
    return (0);
  }
#line 542
  if (! ((int )(ap->addrs + 0)->addr.sa.sa_family == 2)) {
    {
#line 542
    __assert_fail("ap->addrs[0].addr.sa.sa_family == 2", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  542U, "dip_hostaddr");
    }
  }
#line 543
  if (! ((int )(bp->addrs + 0)->addr.sa.sa_family == 2)) {
    {
#line 543
    __assert_fail("bp->addrs[0].addr.sa.sa_family == 2", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  543U, "dip_hostaddr");
    }
  }
  {
#line 544
  tmp = dip_inaddr___4(ads___7, (ap->addrs + 0)->addr.inet.sin_addr, (bp->addrs + 0)->addr.inet.sin_addr);
  }
#line 544
  return (tmp);
}
}
#line 549 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_hostaddr___4(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_hostaddr const   *ap ;
  adns_rr_hostaddr const   *bp ;
  int tmp ;

  {
  {
#line 551
  ap = (adns_rr_hostaddr const   *)datap_a;
#line 551
  bp = (adns_rr_hostaddr const   *)datap_b;
#line 553
  tmp = dip_hostaddr___4(ads___7, ap, bp);
  }
#line 553
  return (tmp);
}
}
#line 556 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mfp_hostaddr___4(adns_query qu , adns_rr_hostaddr *rrp ) 
{ 
  void *tablev ;

  {
  {
#line 559
  adns__makefinal_str(qu, & rrp->host);
#line 560
  tablev = (void *)rrp->addrs;
#line 561
  adns__makefinal_block(qu, & tablev, (unsigned long )rrp->naddrs * sizeof(*(rrp->addrs)));
#line 562
  rrp->addrs = (adns_rr_addr *)tablev;
  }
#line 563
  return;
}
}
#line 565 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_hostaddr___4(adns_query qu , void *datap ) 
{ 
  adns_rr_hostaddr *rrp ;

  {
  {
#line 566
  rrp = (adns_rr_hostaddr *)datap;
#line 568
  mfp_hostaddr___4(qu, rrp);
  }
#line 569
  return;
}
}
#line 571 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_hostaddr___4(vbuf *vb___0 , adns_rr_hostaddr const   *rrp ) 
{ 
  char const   *errstr ;
  adns_status st ;
  char buf___17[20] ;
  int i ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 577
  st = csp_domain___4(vb___0, (char const   *)rrp->host);
  }
#line 577
  if (st) {
#line 577
    return (st);
  }
  {
#line 579
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 579
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 579
    if (! tmp) {
#line 579
      return ((adns_status )1);
    }
#line 579
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 580
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 580
    tmp___0 = adns_errtypeabbrev((adns_status )rrp->astatus);
#line 580
    tmp___1 = adns__vbuf_appendstr(vb___0, tmp___0);
    }
#line 580
    if (! tmp___1) {
#line 580
      return ((adns_status )1);
    }
#line 580
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 582
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %d ",
          (unsigned int const   )rrp->astatus);
  }
  {
#line 583
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 583
    tmp___2 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 583
    if (! tmp___2) {
#line 583
      return ((adns_status )1);
    }
#line 583
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 585
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 585
    tmp___3 = adns_errabbrev((adns_status )rrp->astatus);
#line 585
    tmp___4 = adns__vbuf_appendstr(vb___0, tmp___3);
    }
#line 585
    if (! tmp___4) {
#line 585
      return ((adns_status )1);
    }
#line 585
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 586
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 586
    tmp___5 = adns__vbuf_appendstr(vb___0, " ");
    }
#line 586
    if (! tmp___5) {
#line 586
      return ((adns_status )1);
    }
#line 586
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 588
  errstr = adns_strerror((adns_status )rrp->astatus);
#line 589
  tmp___6 = strlen(errstr);
#line 589
  st = csp_qstring___4(vb___0, errstr, (int )tmp___6);
  }
#line 589
  if (st) {
#line 589
    return (st);
  }
#line 591
  if (rrp->naddrs >= 0) {
    {
#line 592
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 592
      tmp___7 = adns__vbuf_appendstr(vb___0, " (");
      }
#line 592
      if (! tmp___7) {
#line 592
        return ((adns_status )1);
      }
#line 592
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 593
    i = 0;
    {
#line 593
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 593
      if (! (i < (int )rrp->naddrs)) {
#line 593
        goto while_break___5;
      }
      {
#line 594
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 594
        tmp___8 = adns__vbuf_appendstr(vb___0, " ");
        }
#line 594
        if (! tmp___8) {
#line 594
          return ((adns_status )1);
        }
#line 594
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 595
      st = csp_addr___4(vb___0, (adns_rr_addr const   *)(rrp->addrs + i));
#line 593
      i ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 597
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 597
      tmp___9 = adns__vbuf_appendstr(vb___0, " )");
      }
#line 597
      if (! tmp___9) {
#line 597
        return ((adns_status )1);
      }
#line 597
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
  } else {
    {
#line 599
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 599
      tmp___10 = adns__vbuf_appendstr(vb___0, " ?");
      }
#line 599
      if (! tmp___10) {
#line 599
        return ((adns_status )1);
      }
#line 599
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
#line 601
  return ((adns_status )0);
}
}
#line 604 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_hostaddr___4(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_hostaddr const   *rrp ;
  adns_status tmp ;

  {
  {
#line 605
  rrp = (adns_rr_hostaddr const   *)datap;
#line 607
  tmp = csp_hostaddr___4(vb___0, rrp);
  }
#line 607
  return (tmp);
}
}
#line 614 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_mx_raw___4(parseinfo const   *pai , int cbyte___3 , int max ,
                                 void *datap ) 
{ 
  byte const   *dgram ;
  adns_rr_intstr *rrp ;
  adns_status st ;
  int pref ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 616
  dgram = (byte const   *)pai->dgram;
#line 617
  rrp = (adns_rr_intstr *)datap;
#line 621
  if (cbyte___3 + 2 > max) {
#line 621
    return ((adns_status )104);
  }
#line 622
  pref = 0;
#line 622
  tmp = cbyte___3;
#line 622
  cbyte___3 ++;
#line 622
  pref |= (int )(((int const   )*(dgram + tmp) & 255) << 8);
#line 622
  tmp___0 = cbyte___3;
#line 622
  cbyte___3 ++;
#line 622
  pref |= (int )((int const   )*(dgram + tmp___0) & 255);
#line 623
  rrp->i = pref;
#line 624
  if ((pai->qu)->flags & 64) {
#line 624
    tmp___1 = 1;
  } else {
#line 624
    tmp___1 = 0;
  }
  {
#line 624
  st = pap_domain___4(pai, & cbyte___3, max, & rrp->str, (parsedomain_flags )tmp___1);
  }
#line 626
  if (st) {
#line 626
    return (st);
  }
#line 628
  if (cbyte___3 != max) {
#line 628
    return ((adns_status )104);
  }
#line 629
  return ((adns_status )0);
}
}
#line 632 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_mx_raw___4(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_intstr const   *ap ;
  adns_rr_intstr const   *bp ;

  {
#line 633
  ap = (adns_rr_intstr const   *)datap_a;
#line 633
  bp = (adns_rr_intstr const   *)datap_b;
#line 635
  if (ap->i < bp->i) {
#line 635
    return (0);
  }
#line 636
  if (ap->i > bp->i) {
#line 636
    return (1);
  }
#line 637
  return (0);
}
}
#line 644 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_mx___4(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  byte const   *dgram ;
  adns_rr_inthostaddr *rrp ;
  adns_status st ;
  int pref ;
  int tmp ;
  int tmp___0 ;

  {
#line 646
  dgram = (byte const   *)pai->dgram;
#line 647
  rrp = (adns_rr_inthostaddr *)datap;
#line 651
  if (cbyte___3 + 2 > max) {
#line 651
    return ((adns_status )104);
  }
  {
#line 652
  pref = 0;
#line 652
  tmp = cbyte___3;
#line 652
  cbyte___3 ++;
#line 652
  pref |= (int )(((int const   )*(dgram + tmp) & 255) << 8);
#line 652
  tmp___0 = cbyte___3;
#line 652
  cbyte___3 ++;
#line 652
  pref |= (int )((int const   )*(dgram + tmp___0) & 255);
#line 653
  rrp->i = pref;
#line 654
  st = pap_hostaddr___4(pai, & cbyte___3, max, & rrp->ha);
  }
#line 655
  if (st) {
#line 655
    return (st);
  }
#line 657
  if (cbyte___3 != max) {
#line 657
    return ((adns_status )104);
  }
#line 658
  return ((adns_status )0);
}
}
#line 661 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_mx___4(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_inthostaddr const   *ap ;
  adns_rr_inthostaddr const   *bp ;
  int tmp ;

  {
#line 662
  ap = (adns_rr_inthostaddr const   *)datap_a;
#line 662
  bp = (adns_rr_inthostaddr const   *)datap_b;
#line 664
  if (ap->i < bp->i) {
#line 664
    return (0);
  }
#line 665
  if (ap->i > bp->i) {
#line 665
    return (1);
  }
  {
#line 666
  tmp = dip_hostaddr___4(ads___7, & ap->ha, & bp->ha);
  }
#line 666
  return (tmp);
}
}
#line 673 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_inthostaddr___4(adns_query qu , void *datap ) 
{ 
  adns_rr_inthostaddr *rrp ;

  {
  {
#line 674
  rrp = (adns_rr_inthostaddr *)datap;
#line 676
  mfp_hostaddr___4(qu, & rrp->ha);
  }
#line 677
  return;
}
}
#line 679 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_inthostaddr___4(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_inthostaddr const   *rrp ;
  char buf___17[10] ;
  int tmp ;
  adns_status tmp___0 ;

  {
  {
#line 680
  rrp = (adns_rr_inthostaddr const   *)datap;
#line 683
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"%u ",
          rrp->i);
  }
  {
#line 684
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 684
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 684
    if (! tmp) {
#line 684
      return ((adns_status )1);
    }
#line 684
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 686
  tmp___0 = csp_hostaddr___4(vb___0, & rrp->ha);
  }
#line 686
  return (tmp___0);
}
}
#line 693 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_inthost___4(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_intstr const   *rrp ;
  char buf___17[10] ;
  int tmp ;
  adns_status tmp___0 ;

  {
  {
#line 694
  rrp = (adns_rr_intstr const   *)datap;
#line 697
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"%u ",
          rrp->i);
  }
  {
#line 698
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 698
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 698
    if (! tmp) {
#line 698
      return ((adns_status )1);
    }
#line 698
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 699
  tmp___0 = csp_domain___4(vb___0, (char const   *)rrp->str);
  }
#line 699
  return (tmp___0);
}
}
#line 706 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void icb_ptr___4(adns_query parent , adns_query child ) 
{ 
  adns_answer *cans ;
  adns_rr_addr const   *queried ;
  adns_rr_addr const   *found ;
  adns_state ads___7 ;
  int i ;
  int tmp ;

  {
#line 707
  cans = child->answer;
#line 709
  ads___7 = parent->ads;
#line 712
  if ((unsigned int )cans->status == 300U) {
    {
#line 713
    adns__query_fail(parent, (adns_status )100);
    }
#line 714
    return;
  } else
#line 712
  if ((unsigned int )cans->status == 301U) {
    {
#line 713
    adns__query_fail(parent, (adns_status )100);
    }
#line 714
    return;
  } else
#line 715
  if (cans->status) {
    {
#line 716
    adns__query_fail(parent, cans->status);
    }
#line 717
    return;
  }
#line 720
  queried = (adns_rr_addr const   *)(& parent->ctx.info.ptr_parent_addr);
#line 721
  i = 0;
#line 721
  found = (adns_rr_addr const   *)cans->rrs.addr;
  {
#line 721
  while (1) {
    while_continue: /* CIL Label */ ;
#line 721
    if (! (i < cans->nrrs)) {
#line 721
      goto while_break;
    }
#line 722
    if (queried->len == found->len) {
      {
#line 722
      tmp = memcmp((void const   *)(& queried->addr), (void const   *)(& found->addr),
                   (size_t )queried->len);
      }
#line 722
      if (! tmp) {
#line 724
        if (! parent->children.head) {
          {
#line 725
          adns__query_done(parent);
          }
#line 726
          return;
        } else {
          {
#line 728
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 728
            parent->next = (adns_query )0;
#line 728
            parent->back = ads___7->childw.tail;
#line 728
            if (ads___7->childw.tail) {
#line 728
              (ads___7->childw.tail)->next = parent;
            } else {
#line 728
              ads___7->childw.head = parent;
            }
#line 728
            ads___7->childw.tail = parent;
#line 728
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 729
          return;
        }
      }
    }
#line 721
    i ++;
#line 721
    found ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 734
  adns__query_fail(parent, (adns_status )100);
  }
#line 735
  return;
}
}
#line 739
static adns_status pa_ptr___4(parseinfo const   *pai , int dmstart , int max , void *datap ) ;
#line 739 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static char const   * const  expectdomain___4[2]  = {      (char const   */* const  */)"in-addr",      (char const   */* const  */)"arpa"};
#line 737 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_ptr___4(parseinfo const   *pai , int dmstart , int max , void *datap ) 
{ 
  char **rrp ;
  adns_status st ;
  adns_rr_addr *ap ;
  findlabel_state fls ;
  char *ep ;
  byte ipv[4] ;
  char labbuf[4] ;
  int cbyte___3 ;
  int i ;
  int lablen ;
  int labstart ;
  int l ;
  int id ;
  adns_query nqu ;
  qcontext ctx ;
  int tmp ;
  unsigned long tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  typeinfo const   *tmp___3 ;

  {
#line 741
  rrp = (char **)datap;
#line 752
  cbyte___3 = dmstart;
#line 753
  if ((pai->qu)->flags & 64) {
#line 753
    tmp = 1;
  } else {
#line 753
    tmp = 0;
  }
  {
#line 753
  st = pap_domain___4(pai, & cbyte___3, max, rrp, (parsedomain_flags )tmp);
  }
#line 755
  if (st) {
#line 755
    return (st);
  }
#line 756
  if (cbyte___3 != max) {
#line 756
    return ((adns_status )104);
  }
#line 758
  ap = & (pai->qu)->ctx.info.ptr_parent_addr;
#line 759
  if (! ap->len) {
    {
#line 760
    adns__findlabel_start(& fls, (adns_state )pai->ads, -1, (adns_query )pai->qu,
                          (byte const   *)(pai->qu)->query_dgram, (pai->qu)->query_dglen,
                          (pai->qu)->query_dglen, 12, (int *)0);
#line 763
    i = 0;
    }
    {
#line 763
    while (1) {
      while_continue: /* CIL Label */ ;
#line 763
      if (! (i < 4)) {
#line 763
        goto while_break;
      }
      {
#line 764
      st = adns__findlabel_next(& fls, & lablen, & labstart);
      }
#line 764
      if (! (! st)) {
        {
#line 764
        __assert_fail("!st", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                      764U, "pa_ptr");
        }
      }
#line 765
      if (lablen <= 0) {
#line 765
        return ((adns_status )200);
      } else
#line 765
      if (lablen > 3) {
#line 765
        return ((adns_status )200);
      }
      {
#line 766
      memcpy((void */* __restrict  */)(labbuf), (void const   */* __restrict  */)((pai->qu)->query_dgram + labstart),
             (size_t )lablen);
#line 767
      labbuf[lablen] = (char)0;
#line 768
      tmp___0 = strtoul((char const   */* __restrict  */)(labbuf), (char **/* __restrict  */)(& ep),
                        10);
#line 768
      ipv[3 - i] = (byte )tmp___0;
      }
#line 769
      if (*ep) {
#line 769
        return ((adns_status )200);
      }
#line 770
      if (lablen > 1) {
#line 770
        if ((int )*((pai->qu)->query_dgram + labstart) == 48) {
#line 771
          return ((adns_status )200);
        }
      }
#line 763
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 773
    i = 0;
    {
#line 773
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 773
      if (! ((unsigned long )i < sizeof(expectdomain___4) / sizeof(expectdomain___4[0]))) {
#line 773
        goto while_break___0;
      }
      {
#line 774
      st = adns__findlabel_next(& fls, & lablen, & labstart);
      }
#line 774
      if (! (! st)) {
        {
#line 774
        __assert_fail("!st", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                      774U, "pa_ptr");
        }
      }
      {
#line 775
      tmp___1 = strlen((char const   *)expectdomain___4[i]);
#line 775
      l = (int )tmp___1;
      }
#line 776
      if (lablen != l) {
#line 778
        return ((adns_status )200);
      } else {
        {
#line 776
        tmp___2 = memcmp((void const   *)((pai->qu)->query_dgram + labstart), (void const   *)expectdomain___4[i],
                         (size_t )l);
        }
#line 776
        if (tmp___2) {
#line 778
          return ((adns_status )200);
        }
      }
#line 773
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 780
    st = adns__findlabel_next(& fls, & lablen, (int *)0);
    }
#line 780
    if (! (! st)) {
      {
#line 780
      __assert_fail("!st", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                    780U, "pa_ptr");
      }
    }
#line 781
    if (lablen) {
#line 781
      return ((adns_status )200);
    }
    {
#line 783
    ap->len = (int )sizeof(struct sockaddr_in );
#line 784
    memset((void *)(& ap->addr), 0, sizeof(ap->addr.inet));
#line 785
    ap->addr.inet.sin_family = (sa_family_t )2;
#line 786
    ap->addr.inet.sin_addr.s_addr = htonl((uint32_t )(((((int )ipv[0] << 24) | ((int )ipv[1] << 16)) | ((int )ipv[2] << 8)) | (int )ipv[3]));
    }
  }
  {
#line 790
  st = adns__mkquery_frdgram((adns_state )pai->ads, & (pai->qu)->vb, & id, (byte const   *)pai->dgram,
                             (int )pai->dglen, dmstart, (adns_rrtype )65537, (adns_queryflags )16);
  }
#line 793
  if (st) {
#line 793
    return (st);
  }
  {
#line 795
  ctx.ext = (void *)0;
#line 796
  ctx.callback = & icb_ptr___4;
#line 797
  memset((void *)(& ctx.info), 0, sizeof(ctx.info));
#line 798
  tmp___3 = adns__findtype((adns_rrtype )65537);
#line 798
  st = adns__internal_submit((adns_state )pai->ads, & nqu, tmp___3, & (pai->qu)->vb,
                             id, (adns_queryflags )16, (struct timeval )pai->now,
                             (qcontext const   *)(& ctx));
  }
#line 801
  if (st) {
#line 801
    return (st);
  }
#line 803
  nqu->parent = (adns_query )pai->qu;
  {
#line 804
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 804
    nqu->siblings.next = (adns_query )0;
#line 804
    nqu->siblings.back = (pai->qu)->children.tail;
#line 804
    if ((pai->qu)->children.tail) {
#line 804
      ((pai->qu)->children.tail)->siblings.next = nqu;
    } else {
#line 804
      (pai->qu)->children.head = nqu;
    }
#line 804
    (pai->qu)->children.tail = nqu;
#line 804
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 805
  return ((adns_status )0);
}
}
#line 812 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_strpair___4(adns_query qu , void *datap ) 
{ 
  adns_rr_strpair *rrp ;

  {
  {
#line 813
  rrp = (adns_rr_strpair *)datap;
#line 815
  adns__makefinal_str(qu, & rrp->array[0]);
#line 816
  adns__makefinal_str(qu, & rrp->array[1]);
  }
#line 817
  return;
}
}
#line 823 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_intstrpair___4(adns_query qu , void *datap ) 
{ 
  adns_rr_intstrpair *rrp ;

  {
  {
#line 824
  rrp = (adns_rr_intstrpair *)datap;
#line 826
  adns__makefinal_str(qu, & rrp->array[0].str);
#line 827
  adns__makefinal_str(qu, & rrp->array[1].str);
  }
#line 828
  return;
}
}
#line 834 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_hinfo___4(parseinfo const   *pai , int cbyte___3 , int max ,
                                void *datap ) 
{ 
  adns_rr_intstrpair *rrp ;
  adns_status st ;
  int i ;

  {
#line 836
  rrp = (adns_rr_intstrpair *)datap;
#line 840
  i = 0;
  {
#line 840
  while (1) {
    while_continue: /* CIL Label */ ;
#line 840
    if (! (i < 2)) {
#line 840
      goto while_break;
    }
    {
#line 841
    st = pap_qstring___4(pai, & cbyte___3, max, & rrp->array[i].i, & rrp->array[i].str);
    }
#line 842
    if (st) {
#line 842
      return (st);
    }
#line 840
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 845
  if (cbyte___3 != max) {
#line 845
    return ((adns_status )104);
  }
#line 847
  return ((adns_status )0);
}
}
#line 854 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_mailbox822___4(parseinfo const   *pai , int *cbyte_io , int max ,
                                      char **mb_r ) 
{ 
  int lablen ;
  int labstart ;
  int i ;
  int needquote ;
  int c ;
  int r ;
  int neednorm ;
  unsigned char const   *p ;
  char *str ;
  findlabel_state fls ;
  adns_status st ;
  vbuf *vb___0 ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 863
  vb___0 = & (pai->qu)->vb;
#line 864
  vb___0->used = 0;
#line 865
  adns__findlabel_start(& fls, (adns_state )pai->ads, -1, (adns_query )pai->qu, (byte const   *)pai->dgram,
                        (int )pai->dglen, max, *cbyte_io, cbyte_io);
#line 869
  st = adns__findlabel_next(& fls, & lablen, & labstart);
  }
#line 870
  if (! lablen) {
    {
#line 871
    adns__vbuf_appendstr(vb___0, ".");
    }
#line 872
    goto x_ok;
  }
#line 875
  neednorm = 1;
#line 876
  i = 0;
#line 876
  needquote = 0;
#line 876
  p = (unsigned char const   *)(pai->dgram + labstart);
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (! (i < lablen)) {
#line 876
      goto while_break;
    }
#line 877
    tmp = p;
#line 877
    p ++;
#line 877
    c = (int )*tmp;
#line 878
    if ((c & -129) < 32) {
#line 878
      return ((adns_status )104);
    } else
#line 878
    if ((c & -129) == 127) {
#line 878
      return ((adns_status )104);
    }
#line 879
    if (c == 46) {
#line 879
      if (! neednorm) {
#line 879
        neednorm = 1;
      } else {
#line 879
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 880
    if (c == 32) {
#line 880
      needquote ++;
    } else
#line 880
    if (c >= 127) {
#line 880
      needquote ++;
    } else {
      {
#line 880
      tmp___0 = ctype_822special(c);
      }
#line 880
      if (tmp___0) {
#line 880
        needquote ++;
      } else {
#line 881
        neednorm = 0;
      }
    }
#line 876
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 884
  if (needquote) {
#line 884
    goto _L___0;
  } else
#line 884
  if (neednorm) {
    _L___0: /* CIL Label */ 
    {
#line 885
    r = adns__vbuf_ensure(vb___0, (lablen + needquote) + 4);
    }
#line 885
    if (! r) {
#line 885
      return ((adns_status )1);
    }
    {
#line 886
    adns__vbuf_appendq(vb___0, (byte const   *)"\"", 1);
#line 887
    i = 0;
#line 887
    needquote = 0;
#line 887
    p = (unsigned char const   *)(pai->dgram + labstart);
    }
    {
#line 887
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 887
      if (! (i < lablen)) {
#line 887
        goto while_break___0;
      }
#line 888
      c = (int )*p;
#line 889
      if (c == 34) {
        {
#line 889
        adns__vbuf_appendq(vb___0, (byte const   *)"\\", 1);
        }
      } else
#line 889
      if (c == 92) {
        {
#line 889
        adns__vbuf_appendq(vb___0, (byte const   *)"\\", 1);
        }
      }
      {
#line 890
      adns__vbuf_appendq(vb___0, p, 1);
#line 887
      i ++;
#line 887
      p ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 892
    adns__vbuf_appendq(vb___0, (byte const   *)"\"", 1);
    }
  } else {
    {
#line 894
    r = adns__vbuf_append(vb___0, (byte const   *)(pai->dgram + labstart), lablen);
    }
#line 894
    if (! r) {
#line 894
      return ((adns_status )1);
    }
  }
  {
#line 897
  r = adns__vbuf_appendstr(vb___0, "@");
  }
#line 897
  if (! r) {
#line 897
    return ((adns_status )1);
  }
  {
#line 899
  st = adns__parse_domain_more(& fls, (adns_state )pai->ads, (adns_query )pai->qu,
                               vb___0, (parsedomain_flags )0, (byte const   *)pai->dgram);
  }
#line 900
  if (st) {
#line 900
    return (st);
  }
  x_ok: 
  {
#line 903
  tmp___1 = adns__alloc_interim((adns_query )pai->qu, (size_t )(vb___0->used + 1));
#line 903
  str = (char *)tmp___1;
  }
#line 903
  if (! str) {
#line 903
    return ((adns_status )1);
  }
  {
#line 904
  memcpy((void */* __restrict  */)str, (void const   */* __restrict  */)vb___0->buf,
         (size_t )vb___0->used);
#line 905
  *(str + vb___0->used) = (char)0;
#line 906
  *mb_r = str;
  }
#line 907
  return ((adns_status )0);
}
}
#line 910 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_mailbox___4(parseinfo const   *pai , int *cbyte_io , int max ,
                                   char **mb_r ) 
{ 
  adns_status tmp ;
  adns_status tmp___0 ;

  {
#line 912
  if ((unsigned int const   )((pai->qu)->typei)->typekey & 131072U) {
    {
#line 913
    tmp = pap_mailbox822___4(pai, cbyte_io, max, mb_r);
    }
#line 913
    return (tmp);
  } else {
    {
#line 915
    tmp___0 = pap_domain___4(pai, cbyte_io, max, mb_r, (parsedomain_flags )1);
    }
#line 915
    return (tmp___0);
  }
}
}
#line 919 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_mailbox___4(vbuf *vb___0 , char const   *mailbox ) 
{ 
  adns_status tmp ;

  {
  {
#line 920
  tmp = csp_domain___4(vb___0, mailbox);
  }
#line 920
  return (tmp);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_rp___4(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  adns_rr_strpair *rrp ;
  adns_status st ;

  {
  {
#line 929
  rrp = (adns_rr_strpair *)datap;
#line 932
  st = pap_mailbox___4(pai, & cbyte___3, max, & rrp->array[0]);
  }
#line 933
  if (st) {
#line 933
    return (st);
  }
  {
#line 935
  st = pap_domain___4(pai, & cbyte___3, max, & rrp->array[1], (parsedomain_flags )1);
  }
#line 936
  if (st) {
#line 936
    return (st);
  }
#line 938
  if (cbyte___3 != max) {
#line 938
    return ((adns_status )104);
  }
#line 939
  return ((adns_status )0);
}
}
#line 942 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_rp___4(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_strpair const   *rrp ;
  adns_status st ;
  int tmp ;

  {
  {
#line 943
  rrp = (adns_rr_strpair const   *)datap;
#line 946
  st = csp_mailbox___4(vb___0, (char const   *)rrp->array[0]);
  }
#line 946
  if (st) {
#line 946
    return (st);
  }
  {
#line 947
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 947
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 947
    if (! tmp) {
#line 947
      return ((adns_status )1);
    }
#line 947
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 948
  st = csp_domain___4(vb___0, (char const   *)rrp->array[1]);
  }
#line 948
  if (st) {
#line 948
    return (st);
  }
#line 950
  return ((adns_status )0);
}
}
#line 957 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_soa___4(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  adns_rr_soa *rrp ;
  byte const   *dgram ;
  adns_status st ;
  int msw ;
  int lsw ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 959
  rrp = (adns_rr_soa *)datap;
#line 960
  dgram = (byte const   *)pai->dgram;
#line 964
  if ((pai->qu)->flags & 64) {
#line 964
    tmp = 1;
  } else {
#line 964
    tmp = 0;
  }
  {
#line 964
  st = pap_domain___4(pai, & cbyte___3, max, & rrp->mname, (parsedomain_flags )tmp);
  }
#line 966
  if (st) {
#line 966
    return (st);
  }
  {
#line 968
  st = pap_mailbox___4(pai, & cbyte___3, max, & rrp->rname);
  }
#line 969
  if (st) {
#line 969
    return (st);
  }
#line 971
  if (cbyte___3 + 20 != max) {
#line 971
    return ((adns_status )104);
  }
#line 973
  i = 0;
  {
#line 973
  while (1) {
    while_continue: /* CIL Label */ ;
#line 973
    if (! (i < 5)) {
#line 973
      goto while_break;
    }
#line 974
    msw = 0;
#line 974
    tmp___0 = cbyte___3;
#line 974
    cbyte___3 ++;
#line 974
    msw |= (int )(((int const   )*(dgram + tmp___0) & 255) << 8);
#line 974
    tmp___1 = cbyte___3;
#line 974
    cbyte___3 ++;
#line 974
    msw |= (int )((int const   )*(dgram + tmp___1) & 255);
#line 975
    lsw = 0;
#line 975
    tmp___2 = cbyte___3;
#line 975
    cbyte___3 ++;
#line 975
    lsw |= (int )(((int const   )*(dgram + tmp___2) & 255) << 8);
#line 975
    tmp___3 = cbyte___3;
#line 975
    cbyte___3 ++;
#line 975
    lsw |= (int )((int const   )*(dgram + tmp___3) & 255);
#line 976
    *(& rrp->serial + i) = (unsigned long )((msw << 16) | lsw);
#line 973
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 979
  return ((adns_status )0);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_soa___4(adns_query qu , void *datap ) 
{ 
  adns_rr_soa *rrp ;

  {
  {
#line 983
  rrp = (adns_rr_soa *)datap;
#line 985
  adns__makefinal_str(qu, & rrp->mname);
#line 986
  adns__makefinal_str(qu, & rrp->rname);
  }
#line 987
  return;
}
}
#line 989 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_soa___4(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_soa const   *rrp ;
  char buf___17[20] ;
  int i ;
  adns_status st ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 990
  rrp = (adns_rr_soa const   *)datap;
#line 995
  st = csp_domain___4(vb___0, (char const   *)rrp->mname);
  }
#line 995
  if (st) {
#line 995
    return (st);
  }
  {
#line 996
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 996
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 996
    if (! tmp) {
#line 996
      return ((adns_status )1);
    }
#line 996
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 997
  st = csp_mailbox___4(vb___0, (char const   *)rrp->rname);
  }
#line 997
  if (st) {
#line 997
    return (st);
  }
#line 999
  i = 0;
  {
#line 999
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 999
    if (! (i < 5)) {
#line 999
      goto while_break___0;
    }
    {
#line 1000
    sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %lu",
            *(& rrp->serial + i));
    }
    {
#line 1001
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1001
      tmp___0 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
      }
#line 1001
      if (! tmp___0) {
#line 1001
        return ((adns_status )1);
      }
#line 1001
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 999
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1004
  return ((adns_status )0);
}
}
#line 1011 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status qdpl_srv___4(adns_state ads___7 , char const   **p_io , char const   *pe ,
                                int labelnum , char *label_r , int *ll_io , adns_queryflags flags ,
                                typeinfo const   *typei ) 
{ 
  int useflags ;
  char const   *p_orig ;
  adns_status st ;
  int ll ;
  void *tmp ;

  {
#line 1020
  if (labelnum < 2) {
#line 1020
    if (! ((unsigned int )flags & 16U)) {
#line 1021
      useflags = 16;
#line 1022
      p_orig = *p_io;
    } else {
#line 1024
      useflags = (int )flags;
#line 1025
      p_orig = (char const   *)0;
    }
  } else {
#line 1024
    useflags = (int )flags;
#line 1025
    p_orig = (char const   *)0;
  }
  {
#line 1027
  st = adns__qdpl_normal(ads___7, p_io, pe, labelnum, (char *)label_r, ll_io, (adns_queryflags )useflags,
                         typei);
  }
#line 1028
  if (st) {
#line 1028
    return (st);
  }
#line 1030
  if (p_orig) {
#line 1031
    ll = *ll_io;
#line 1032
    if (! ll) {
#line 1033
      return ((adns_status )201);
    } else
#line 1032
    if ((int )*(label_r + 0) != 95) {
#line 1033
      return ((adns_status )201);
    }
    {
#line 1034
    tmp = memchr((void const   *)(p_orig + 1), '\\', (size_t )(pe - (p_orig + 1)));
    }
#line 1034
    if (tmp) {
#line 1035
      return ((adns_status )201);
    }
  }
#line 1037
  return ((adns_status )0);
}
}
#line 1040 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_srv_begin___4(parseinfo const   *pai , int *cbyte_io , int max ,
                                     adns_rr_srvha *rrp ) 
{ 
  byte const   *dgram ;
  int ti ;
  int cbyte___3 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1043
  dgram = (byte const   *)pai->dgram;
#line 1046
  cbyte___3 = *cbyte_io;
#line 1047
  tmp = *cbyte_io + 6;
#line 1047
  *cbyte_io = tmp;
#line 1047
  if (tmp > max) {
#line 1047
    return ((adns_status )104);
  }
#line 1049
  ti = 0;
#line 1049
  tmp___0 = cbyte___3;
#line 1049
  cbyte___3 ++;
#line 1049
  ti |= (int )(((int const   )*(dgram + tmp___0) & 255) << 8);
#line 1049
  tmp___1 = cbyte___3;
#line 1049
  cbyte___3 ++;
#line 1049
  ti |= (int )((int const   )*(dgram + tmp___1) & 255);
#line 1049
  rrp->priority = ti;
#line 1050
  ti = 0;
#line 1050
  tmp___2 = cbyte___3;
#line 1050
  cbyte___3 ++;
#line 1050
  ti |= (int )(((int const   )*(dgram + tmp___2) & 255) << 8);
#line 1050
  tmp___3 = cbyte___3;
#line 1050
  cbyte___3 ++;
#line 1050
  ti |= (int )((int const   )*(dgram + tmp___3) & 255);
#line 1050
  rrp->weight = ti;
#line 1051
  ti = 0;
#line 1051
  tmp___4 = cbyte___3;
#line 1051
  cbyte___3 ++;
#line 1051
  ti |= (int )(((int const   )*(dgram + tmp___4) & 255) << 8);
#line 1051
  tmp___5 = cbyte___3;
#line 1051
  cbyte___3 ++;
#line 1051
  ti |= (int )((int const   )*(dgram + tmp___5) & 255);
#line 1051
  rrp->port = ti;
#line 1052
  return ((adns_status )0);
}
}
#line 1055 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_srvraw___4(parseinfo const   *pai , int cbyte___3 , int max ,
                                 void *datap ) 
{ 
  adns_rr_srvraw *rrp ;
  adns_status st ;
  int tmp ;

  {
  {
#line 1057
  rrp = (adns_rr_srvraw *)datap;
#line 1060
  st = pap_srv_begin___4(pai, & cbyte___3, max, (adns_rr_srvha *)datap);
  }
#line 1061
  if (st) {
#line 1061
    return (st);
  }
#line 1063
  if ((pai->qu)->flags & 64) {
#line 1063
    tmp = 1;
  } else {
#line 1063
    tmp = 0;
  }
  {
#line 1063
  st = pap_domain___4(pai, & cbyte___3, max, & rrp->host, (parsedomain_flags )tmp);
  }
#line 1065
  if (st) {
#line 1065
    return (st);
  }
#line 1067
  if (cbyte___3 != max) {
#line 1067
    return ((adns_status )104);
  }
#line 1068
  return ((adns_status )0);
}
}
#line 1071 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_srvha___4(parseinfo const   *pai , int cbyte___3 , int max ,
                                void *datap ) 
{ 
  adns_rr_srvha *rrp ;
  adns_status st ;

  {
  {
#line 1073
  rrp = (adns_rr_srvha *)datap;
#line 1076
  st = pap_srv_begin___4(pai, & cbyte___3, max, (adns_rr_srvha *)datap);
  }
#line 1076
  if (st) {
#line 1076
    return (st);
  }
  {
#line 1077
  st = pap_hostaddr___4(pai, & cbyte___3, max, & rrp->ha);
  }
#line 1077
  if (st) {
#line 1077
    return (st);
  }
#line 1078
  if (cbyte___3 != max) {
#line 1078
    return ((adns_status )104);
  }
#line 1079
  return ((adns_status )0);
}
}
#line 1082 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_srvraw___4(adns_query qu , void *datap ) 
{ 
  adns_rr_srvraw *rrp ;

  {
  {
#line 1083
  rrp = (adns_rr_srvraw *)datap;
#line 1084
  adns__makefinal_str(qu, & rrp->host);
  }
#line 1085
  return;
}
}
#line 1087 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_srvha___4(adns_query qu , void *datap ) 
{ 
  adns_rr_srvha *rrp ;

  {
  {
#line 1088
  rrp = (adns_rr_srvha *)datap;
#line 1089
  mfp_hostaddr___4(qu, & rrp->ha);
  }
#line 1090
  return;
}
}
#line 1092 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_srv___4(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_srvraw const   *ap ;
  adns_rr_srvraw const   *bp ;

  {
#line 1093
  ap = (adns_rr_srvraw const   *)datap_a;
#line 1093
  bp = (adns_rr_srvraw const   *)datap_b;
#line 1096
  if (ap->priority < bp->priority) {
#line 1096
    return (0);
  }
#line 1097
  if (ap->priority > bp->priority) {
#line 1097
    return (1);
  }
#line 1098
  return (0);
}
}
#line 1101 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_srv_begin___4(vbuf *vb___0 , adns_rr_srvha const   *rrp ) 
{ 
  char buf___17[30] ;
  int tmp ;

  {
  {
#line 1104
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"%u %u %u ",
          rrp->priority, rrp->weight, rrp->port);
  }
  {
#line 1105
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1105
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 1105
    if (! tmp) {
#line 1105
      return ((adns_status )1);
    }
#line 1105
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1106
  return ((adns_status )0);
}
}
#line 1109 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_srvraw___4(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_srvraw const   *rrp ;
  adns_status st ;
  adns_status tmp ;

  {
  {
#line 1110
  rrp = (adns_rr_srvraw const   *)datap;
#line 1113
  st = csp_srv_begin___4(vb___0, (adns_rr_srvha const   *)((void const   *)rrp));
  }
#line 1113
  if (st) {
#line 1113
    return (st);
  }
  {
#line 1114
  tmp = csp_domain___4(vb___0, (char const   *)rrp->host);
  }
#line 1114
  return (tmp);
}
}
#line 1117 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_srvha___4(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_srvha const   *rrp ;
  adns_status st ;
  adns_status tmp ;

  {
  {
#line 1118
  rrp = (adns_rr_srvha const   *)datap;
#line 1121
  st = csp_srv_begin___4(vb___0, (adns_rr_srvha const   *)datap);
  }
#line 1121
  if (st) {
#line 1121
    return (st);
  }
  {
#line 1122
  tmp = csp_hostaddr___4(vb___0, & rrp->ha);
  }
#line 1122
  return (tmp);
}
}
#line 1125 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void postsort_srv___4(adns_state ads___7 , void *array , int nrrs , struct typeinfo  const  *typei ) 
{ 
  char *workbegin ;
  char *workend ;
  char *search ;
  char *arrayend ;
  adns_rr_srvha const   *rr ;
  union __anonunion_rrtmp_89___4 rrtmp ;
  int cpriority ;
  int totalweight ;
  int runtotal ;
  long randval ;

  {
#line 1138
  workbegin = (char *)array;
#line 1138
  arrayend = workbegin + typei->rrsz * (int const   )nrrs;
  {
#line 1138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1138
    if (! ((unsigned long )workbegin < (unsigned long )arrayend)) {
#line 1138
      goto while_break;
    }
#line 1141
    rr = (adns_rr_srvha const   *)((void *)workbegin);
#line 1141
    cpriority = (int )rr->priority;
#line 1143
    workend = workbegin;
#line 1143
    totalweight = 0;
    {
#line 1143
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1143
      if ((unsigned long )workend < (unsigned long )arrayend) {
#line 1143
        rr = (adns_rr_srvha const   *)((void *)workend);
#line 1143
        if (! (rr->priority == (int const   )cpriority)) {
#line 1143
          goto while_break___0;
        }
      } else {
#line 1143
        goto while_break___0;
      }
#line 1146
      totalweight += (int )rr->weight;
#line 1143
      workend += typei->rrsz;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1155
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1155
      if (! ((unsigned long )(workbegin + typei->rrsz) < (unsigned long )workend)) {
#line 1155
        goto while_break___1;
      }
      {
#line 1159
      randval = nrand48((unsigned short *)(ads___7->rand48xsubi));
#line 1160
      randval %= (long )(totalweight + 1);
#line 1167
      search = workbegin;
#line 1167
      runtotal = 0;
      }
      {
#line 1167
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1167
        rr = (adns_rr_srvha const   *)((void *)search);
#line 1167
        runtotal += (int )rr->weight;
#line 1167
        if (! ((long )runtotal < randval)) {
#line 1167
          goto while_break___2;
        }
#line 1167
        search += typei->rrsz;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1170
      if (! ((unsigned long )search < (unsigned long )arrayend)) {
        {
#line 1170
        __assert_fail("search < arrayend", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                      1170U, "postsort_srv");
        }
      }
#line 1171
      totalweight -= (int )rr->weight;
#line 1172
      if ((unsigned long )search != (unsigned long )workbegin) {
        {
#line 1173
        memcpy((void */* __restrict  */)(& rrtmp), (void const   */* __restrict  */)workbegin,
               (size_t )typei->rrsz);
#line 1174
        memcpy((void */* __restrict  */)workbegin, (void const   */* __restrict  */)search,
               (size_t )typei->rrsz);
#line 1175
        memcpy((void */* __restrict  */)search, (void const   */* __restrict  */)(& rrtmp),
               (size_t )typei->rrsz);
        }
      }
#line 1155
      workbegin += typei->rrsz;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1138
    workbegin = workend;
  }
  while_break: /* CIL Label */ ;
  }
#line 1184
  return;
}
}
#line 1190 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_byteblock___4(adns_query qu , void *datap ) 
{ 
  adns_rr_byteblock *rrp ;
  void *bytes___3 ;

  {
  {
#line 1191
  rrp = (adns_rr_byteblock *)datap;
#line 1192
  bytes___3 = (void *)rrp->data;
#line 1193
  adns__makefinal_block(qu, & bytes___3, (size_t )rrp->len);
#line 1194
  rrp->data = (unsigned char *)bytes___3;
  }
#line 1195
  return;
}
}
#line 1201 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_opaque___4(parseinfo const   *pai , int cbyte___3 , int max ,
                                 void *datap ) 
{ 
  adns_rr_byteblock *rrp ;
  void *tmp ;

  {
  {
#line 1203
  rrp = (adns_rr_byteblock *)datap;
#line 1205
  rrp->len = max - cbyte___3;
#line 1206
  tmp = adns__alloc_interim((adns_query )pai->qu, (size_t )rrp->len);
#line 1206
  rrp->data = (unsigned char *)tmp;
  }
#line 1207
  if (! rrp->data) {
#line 1207
    return ((adns_status )1);
  }
  {
#line 1208
  memcpy((void */* __restrict  */)rrp->data, (void const   */* __restrict  */)(pai->dgram + cbyte___3),
         (size_t )rrp->len);
  }
#line 1209
  return ((adns_status )0);
}
}
#line 1212 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_opaque___4(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_byteblock const   *rrp ;
  char buf___17[10] ;
  int l ;
  unsigned char *p ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1213
  rrp = (adns_rr_byteblock const   *)datap;
#line 1218
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"\\# %d",
          rrp->len);
  }
  {
#line 1219
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1219
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 1219
    if (! tmp) {
#line 1219
      return ((adns_status )1);
    }
#line 1219
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1221
  l = (int )rrp->len;
#line 1221
  p = (unsigned char *)rrp->data;
  {
#line 1221
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1221
    if (! (l >= 4)) {
#line 1221
      goto while_break___0;
    }
    {
#line 1224
    sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %02x%02x%02x%02x",
            (int )*(p + 0), (int )*(p + 1), (int )*(p + 2), (int )*(p + 3));
    }
    {
#line 1225
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1225
      tmp___0 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
      }
#line 1225
      if (! tmp___0) {
#line 1225
        return ((adns_status )1);
      }
#line 1225
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1221
    l -= 4;
#line 1221
    p += 4;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1227
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1227
    if (! (l > 0)) {
#line 1227
      goto while_break___2;
    }
    {
#line 1230
    sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %02x",
            (int )*p);
    }
    {
#line 1231
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 1231
      tmp___1 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
      }
#line 1231
      if (! tmp___1) {
#line 1231
        return ((adns_status )1);
      }
#line 1231
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1227
    l --;
#line 1227
    p ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1233
  return ((adns_status )0);
}
}
#line 1240 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_flat___4(adns_query qu , void *data___0 ) 
{ 


  {
#line 1240
  return;
}
}
#line 1261 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static typeinfo const   typeinfos___4[17]  = 
#line 1261
  {      {(adns_rrtype )1, "A", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.inaddr)),
      & mf_flat___4, & cs_inaddr___4, & pa_inaddr___4, & di_inaddr___4, (adns_status (*)(adns_state ads ,
                                                                                         char const   **p_io ,
                                                                                         char const   *pe ,
                                                                                         int labelnum ,
                                                                                         char *label_r ,
                                                                                         int *ll_io ,
                                                                                         adns_queryflags flags ,
                                                                                         struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )2,
      "NS", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___4, & cs_domain___4,
      & pa_host_raw___4, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )5,
      "CNAME", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___4,
      & cs_domain___4, & pa_dom_raw___4, (int (*)(adns_state ads , void const   *datap_a ,
                                                  void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                              char const   **p_io ,
                                                                                              char const   *pe ,
                                                                                              int labelnum ,
                                                                                              char *label_r ,
                                                                                              int *ll_io ,
                                                                                              adns_queryflags flags ,
                                                                                              struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )6,
      "SOA", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.soa)), & mf_soa___4, & cs_soa___4,
      & pa_soa___4, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )12,
      "PTR", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___4, & cs_domain___4,
      & pa_host_raw___4, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )13,
      "HINFO", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.intstrpair)),
      & mf_intstrpair___4, & cs_hinfo___4, & pa_hinfo___4, (int (*)(adns_state ads ,
                                                                    void const   *datap_a ,
                                                                    void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )15,
      "MX", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.intstr)), & mf_intstr___4,
      & cs_inthost___4, & pa_mx_raw___4, & di_mx_raw___4, (adns_status (*)(adns_state ads ,
                                                                           char const   **p_io ,
                                                                           char const   *pe ,
                                                                           int labelnum ,
                                                                           char *label_r ,
                                                                           int *ll_io ,
                                                                           adns_queryflags flags ,
                                                                           struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )16,
      "TXT", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.manyistr)),
      & mf_manyistr___4, & cs_txt___4, & pa_txt___4, (int (*)(adns_state ads , void const   *datap_a ,
                                                              void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )17,
      "RP", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.strpair)), & mf_strpair___4,
      & cs_rp___4, & pa_rp___4, (int (*)(adns_state ads , void const   *datap_a ,
                                         void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                     char const   **p_io ,
                                                                                     char const   *pe ,
                                                                                     int labelnum ,
                                                                                     char *label_r ,
                                                                                     int *ll_io ,
                                                                                     adns_queryflags flags ,
                                                                                     struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )33,
      "SRV", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.srvraw)), & mf_srvraw___4,
      & cs_srvraw___4, & pa_srvraw___4, & di_srv___4, & qdpl_srv___4, & postsort_srv___4}, 
        {(adns_rrtype )65537,
      "A", "addr", (int )sizeof(*(((adns_answer *)0)->rrs.addr)), & mf_flat___4, & cs_addr___4,
      & pa_addr___4, & di_addr___4, (adns_status (*)(adns_state ads , char const   **p_io ,
                                                     char const   *pe , int labelnum ,
                                                     char *label_r , int *ll_io ,
                                                     adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65538,
      "NS", "+addr", (int )sizeof(*(((adns_answer *)0)->rrs.hostaddr)), & mf_hostaddr___4,
      & cs_hostaddr___4, & pa_hostaddr___4, & di_hostaddr___4, (adns_status (*)(adns_state ads ,
                                                                                char const   **p_io ,
                                                                                char const   *pe ,
                                                                                int labelnum ,
                                                                                char *label_r ,
                                                                                int *ll_io ,
                                                                                adns_queryflags flags ,
                                                                                struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65548,
      "PTR", "checked", (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___4,
      & cs_domain___4, & pa_ptr___4, (int (*)(adns_state ads , void const   *datap_a ,
                                              void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                          char const   **p_io ,
                                                                                          char const   *pe ,
                                                                                          int labelnum ,
                                                                                          char *label_r ,
                                                                                          int *ll_io ,
                                                                                          adns_queryflags flags ,
                                                                                          struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65551,
      "MX", "+addr", (int )sizeof(*(((adns_answer *)0)->rrs.inthostaddr)), & mf_inthostaddr___4,
      & cs_inthostaddr___4, & pa_mx___4, & di_mx___4, (adns_status (*)(adns_state ads ,
                                                                       char const   **p_io ,
                                                                       char const   *pe ,
                                                                       int labelnum ,
                                                                       char *label_r ,
                                                                       int *ll_io ,
                                                                       adns_queryflags flags ,
                                                                       struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65569,
      "SRV", "+addr", (int )sizeof(*(((adns_answer *)0)->rrs.srvha)), & mf_srvha___4,
      & cs_srvha___4, & pa_srvha___4, & di_srv___4, & qdpl_srv___4, & postsort_srv___4}, 
        {(adns_rrtype )131078,
      "SOA", "822", (int )sizeof(*(((adns_answer *)0)->rrs.soa)), & mf_soa___4, & cs_soa___4,
      & pa_soa___4, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )131089,
      "RP", "822", (int )sizeof(*(((adns_answer *)0)->rrs.strpair)), & mf_strpair___4,
      & cs_rp___4, & pa_rp___4, (int (*)(adns_state ads , void const   *datap_a ,
                                         void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                     char const   **p_io ,
                                                                                     char const   *pe ,
                                                                                     int labelnum ,
                                                                                     char *label_r ,
                                                                                     int *ll_io ,
                                                                                     adns_queryflags flags ,
                                                                                     struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}};
#line 1288 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static struct typeinfo  const  typeinfo_unknown___4  = 
#line 1288
     {(adns_rrtype )262144, (char const   *)0, "unknown", (int )sizeof(*(((adns_answer *)0)->rrs.byteblock)),
    & mf_byteblock___4, & cs_opaque___4, & pa_opaque___4, (int (*)(adns_state ads ,
                                                                   void const   *datap_a ,
                                                                   void const   *datap_b ))0,
    (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                     char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
    (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0};
#line 55 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_query_alloc___4(adns_state ads___7 , adns_query qu ) 
{ 
  allocnode *an ;
  int tmp ;

  {
#line 58
  if (qu->allocations.head) {
#line 58
    if (! (! (qu->allocations.head)->back)) {
      {
#line 58
      __assert_fail("! (qu->allocations).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    59U, "checkc_query_alloc");
      }
    }
#line 58
    an = qu->allocations.head;
    {
#line 58
    while (1) {
      while_continue: /* CIL Label */ ;
#line 58
      if (! an) {
#line 58
        goto while_break;
      }
#line 58
      if (an->next) {
#line 58
        tmp = (unsigned long )an == (unsigned long )(an->next)->back;
      } else {
#line 58
        tmp = (unsigned long )an == (unsigned long )qu->allocations.tail;
      }
#line 58
      if (! tmp) {
        {
#line 58
        __assert_fail("(an)-> next ? (an) == (an)-> next-> back : (an) == (qu->allocations).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      59U, "checkc_query_alloc");
        }
      }
#line 58
      an = an->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 60
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_query___4(adns_state ads___7 , adns_query qu ) 
{ 
  adns_query child ;

  {
#line 65
  if (! (qu->udpnextserver < ads___7->nservers)) {
    {
#line 65
    __assert_fail("qu->udpnextserver < ads->nservers", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  65U, "checkc_query");
    }
  }
#line 66
  if (! (! (qu->udpsent & (0xffffffffffffffffUL << ads___7->nservers)))) {
    {
#line 66
    __assert_fail("!(qu->udpsent & (~0UL << ads->nservers))", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  66U, "checkc_query");
    }
  }
#line 67
  if (! (qu->search_pos <= ads___7->nsearchlist)) {
    {
#line 67
    __assert_fail("qu->search_pos <= ads->nsearchlist", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  67U, "checkc_query");
    }
  }
#line 68
  if (qu->parent) {
    {
#line 68
    while (1) {
      while_continue: /* CIL Label */ ;
#line 68
      child = (qu->parent)->children.head;
      {
#line 68
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 68
        if (! ((unsigned long )child != (unsigned long )qu)) {
#line 68
          goto while_break___0;
        }
#line 68
        if (! child) {
          {
#line 68
          __assert_fail("(child)", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        68U, "checkc_query");
          }
        }
#line 68
        child = child->siblings.next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 68
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 69
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_notcpbuf___4(adns_state ads___7 ) 
{ 


  {
#line 72
  if (! (! ads___7->tcpsend.used)) {
    {
#line 72
    __assert_fail("!ads->tcpsend.used", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  72U, "checkc_notcpbuf");
    }
  }
#line 73
  if (! (! ads___7->tcprecv.used)) {
    {
#line 73
    __assert_fail("!ads->tcprecv.used", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  73U, "checkc_notcpbuf");
    }
  }
#line 74
  if (! (! ads___7->tcprecv_skip)) {
    {
#line 74
    __assert_fail("!ads->tcprecv_skip", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  74U, "checkc_notcpbuf");
    }
  }
#line 75
  return;
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_global___4(adns_state ads___7 ) 
{ 
  int i ;

  {
#line 80
  if (! (ads___7->udpsocket >= 0)) {
    {
#line 80
    __assert_fail("ads->udpsocket >= 0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  80U, "checkc_global");
    }
  }
#line 82
  i = 0;
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! (i < ads___7->nsortlist)) {
#line 82
      goto while_break;
    }
#line 83
    if (! (! (ads___7->sortlist[i].base.s_addr & ~ ads___7->sortlist[i].mask.s_addr))) {
      {
#line 83
      __assert_fail("!(ads->sortlist[i].base.s_addr & ~ads->sortlist[i].mask.s_addr)",
                    "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    83U, "checkc_global");
      }
    }
#line 82
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  if (ads___7->tcpserver >= 0) {
#line 85
    if (! (ads___7->tcpserver < ads___7->nservers)) {
      {
#line 85
      __assert_fail("ads->tcpserver >= 0 && ads->tcpserver < ads->nservers", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    85U, "checkc_global");
      }
    }
  } else {
    {
#line 85
    __assert_fail("ads->tcpserver >= 0 && ads->tcpserver < ads->nservers", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  85U, "checkc_global");
    }
  }
  {
#line 88
  if ((unsigned int )ads___7->tcpstate == 1U) {
#line 88
    goto case_1;
  }
#line 93
  if ((unsigned int )ads___7->tcpstate == 3U) {
#line 93
    goto case_3;
  }
#line 93
  if ((unsigned int )ads___7->tcpstate == 0U) {
#line 93
    goto case_3;
  }
#line 97
  if ((unsigned int )ads___7->tcpstate == 2U) {
#line 97
    goto case_2;
  }
#line 101
  goto switch_default;
  case_1: /* CIL Label */ 
#line 89
  if (! (ads___7->tcpsocket >= 0)) {
    {
#line 89
    __assert_fail("ads->tcpsocket >= 0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  89U, "checkc_global");
    }
  }
  {
#line 90
  checkc_notcpbuf___4(ads___7);
  }
#line 91
  goto switch_break;
  case_3: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 94
  if (! (ads___7->tcpsocket == -1)) {
    {
#line 94
    __assert_fail("ads->tcpsocket == -1", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  94U, "checkc_global");
    }
  }
  {
#line 95
  checkc_notcpbuf___4(ads___7);
  }
#line 96
  goto switch_break;
  case_2: /* CIL Label */ 
#line 98
  if (! (ads___7->tcpsocket >= 0)) {
    {
#line 98
    __assert_fail("ads->tcpsocket >= 0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  98U, "checkc_global");
    }
  }
#line 99
  if (! (ads___7->tcprecv_skip <= ads___7->tcprecv.used)) {
    {
#line 99
    __assert_fail("ads->tcprecv_skip <= ads->tcprecv.used", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  99U, "checkc_global");
    }
  }
#line 100
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 102
  __assert_fail("!\"ads->tcpstate value\"", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                102U, "checkc_global");
  }
  switch_break: /* CIL Label */ ;
  }
#line 105
  if (! ads___7->searchlist) {
#line 105
    if (! (! ads___7->nsearchlist)) {
      {
#line 105
      __assert_fail("ads->searchlist || !ads->nsearchlist", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    105U, "checkc_global");
      }
    }
  }
#line 106
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_queue_udpw___4(adns_state ads___7 ) 
{ 
  adns_query qu ;
  int tmp ;

  {
#line 111
  if (ads___7->udpw.head) {
#line 111
    if (! (! (ads___7->udpw.head)->back)) {
      {
#line 111
      __assert_fail("! (ads->udpw).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    118U, "checkc_queue_udpw");
      }
    }
#line 111
    qu = ads___7->udpw.head;
    {
#line 111
    while (1) {
      while_continue: /* CIL Label */ ;
#line 111
      if (! qu) {
#line 111
        goto while_break;
      }
#line 111
      if (qu->next) {
#line 111
        tmp = (unsigned long )qu == (unsigned long )(qu->next)->back;
      } else {
#line 111
        tmp = (unsigned long )qu == (unsigned long )ads___7->udpw.tail;
      }
#line 111
      if (! tmp) {
        {
#line 111
        __assert_fail("(qu)-> next ? (qu) == (qu)-> next-> back : (qu) == (ads->udpw).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! ((unsigned int )qu->state == 0U)) {
        {
#line 111
        __assert_fail("qu->state==query_tosend", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! (qu->retries <= 15)) {
        {
#line 111
        __assert_fail("qu->retries <= 15", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! qu->udpsent) {
        {
#line 111
        __assert_fail("qu->udpsent", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! qu->children.head) {
#line 111
        if (! (! qu->children.tail)) {
          {
#line 111
          __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        118U, "checkc_queue_udpw");
          }
        }
      } else {
        {
#line 111
        __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
      {
#line 111
      checkc_query___4(ads___7, qu);
#line 111
      checkc_query_alloc___4(ads___7, qu);
#line 111
      qu = qu->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 119
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_queue_tcpw___4(adns_state ads___7 ) 
{ 
  adns_query qu ;
  int tmp ;

  {
#line 124
  if (ads___7->tcpw.head) {
#line 124
    if (! (! (ads___7->tcpw.head)->back)) {
      {
#line 124
      __assert_fail("! (ads->tcpw).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    130U, "checkc_queue_tcpw");
      }
    }
#line 124
    qu = ads___7->tcpw.head;
    {
#line 124
    while (1) {
      while_continue: /* CIL Label */ ;
#line 124
      if (! qu) {
#line 124
        goto while_break;
      }
#line 124
      if (qu->next) {
#line 124
        tmp = (unsigned long )qu == (unsigned long )(qu->next)->back;
      } else {
#line 124
        tmp = (unsigned long )qu == (unsigned long )ads___7->tcpw.tail;
      }
#line 124
      if (! tmp) {
        {
#line 124
        __assert_fail("(qu)-> next ? (qu) == (qu)-> next-> back : (qu) == (ads->tcpw).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
#line 124
      if (! ((unsigned int )qu->state == 1U)) {
        {
#line 124
        __assert_fail("qu->state==query_tcpw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
#line 124
      if (! qu->children.head) {
#line 124
        if (! (! qu->children.tail)) {
          {
#line 124
          __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        130U, "checkc_queue_tcpw");
          }
        }
      } else {
        {
#line 124
        __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
#line 124
      if (! (qu->retries <= ads___7->nservers + 1)) {
        {
#line 124
        __assert_fail("qu->retries <= ads->nservers+1", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
      {
#line 124
      checkc_query___4(ads___7, qu);
#line 124
      checkc_query_alloc___4(ads___7, qu);
#line 124
      qu = qu->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 131
  return;
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_queue_childw___4(adns_state ads___7 ) 
{ 
  adns_query parent ;
  adns_query child ;
  int tmp ;
  int tmp___0 ;

  {
#line 136
  if (ads___7->childw.head) {
#line 136
    if (! (! (ads___7->childw.head)->back)) {
      {
#line 136
      __assert_fail("! (ads->childw).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    145U, "checkc_queue_childw");
      }
    }
#line 136
    parent = ads___7->childw.head;
    {
#line 136
    while (1) {
      while_continue: /* CIL Label */ ;
#line 136
      if (! parent) {
#line 136
        goto while_break;
      }
#line 136
      if (parent->next) {
#line 136
        tmp = (unsigned long )parent == (unsigned long )(parent->next)->back;
      } else {
#line 136
        tmp = (unsigned long )parent == (unsigned long )ads___7->childw.tail;
      }
#line 136
      if (! tmp) {
        {
#line 136
        __assert_fail("(parent)-> next ? (parent) == (parent)-> next-> back : (parent) == (ads->childw).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      145U, "checkc_queue_childw");
        }
      }
#line 136
      if (! ((unsigned int )parent->state == 2U)) {
        {
#line 136
        __assert_fail("parent->state == query_childw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      145U, "checkc_queue_childw");
        }
      }
#line 136
      if (! parent->children.head) {
        {
#line 136
        __assert_fail("parent->children.head", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      145U, "checkc_queue_childw");
        }
      }
#line 136
      if (parent->children.head) {
#line 136
        if (! (! (parent->children.head)->siblings.back)) {
          {
#line 136
          __assert_fail("! (parent->children).head->siblings. back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        145U, "checkc_queue_childw");
          }
        }
#line 136
        child = parent->children.head;
        {
#line 136
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 136
          if (! child) {
#line 136
            goto while_break___0;
          }
#line 136
          if (child->siblings.next) {
#line 136
            tmp___0 = (unsigned long )child == (unsigned long )(child->siblings.next)->siblings.back;
          } else {
#line 136
            tmp___0 = (unsigned long )child == (unsigned long )parent->children.tail;
          }
#line 136
          if (! tmp___0) {
            {
#line 136
            __assert_fail("(child)->siblings. next ? (child) == (child)->siblings. next->siblings. back : (child) == (parent->children).tail",
                          "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                          145U, "checkc_queue_childw");
            }
          }
#line 136
          if (! ((unsigned long )child->parent == (unsigned long )parent)) {
            {
#line 136
            __assert_fail("child->parent == parent", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                          145U, "checkc_queue_childw");
            }
          }
#line 136
          if (! ((unsigned int )child->state != 3U)) {
            {
#line 136
            __assert_fail("child->state != query_done", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                          145U, "checkc_queue_childw");
            }
          }
#line 136
          child = child->siblings.next;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 136
      checkc_query___4(ads___7, parent);
#line 136
      checkc_query_alloc___4(ads___7, parent);
#line 136
      parent = parent->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 146
  return;
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_queue_output___4(adns_state ads___7 ) 
{ 
  adns_query qu ;
  int tmp ;

  {
#line 151
  if (ads___7->output.head) {
#line 151
    if (! (! (ads___7->output.head)->back)) {
      {
#line 151
      __assert_fail("! (ads->output).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    157U, "checkc_queue_output");
      }
    }
#line 151
    qu = ads___7->output.head;
    {
#line 151
    while (1) {
      while_continue: /* CIL Label */ ;
#line 151
      if (! qu) {
#line 151
        goto while_break;
      }
#line 151
      if (qu->next) {
#line 151
        tmp = (unsigned long )qu == (unsigned long )(qu->next)->back;
      } else {
#line 151
        tmp = (unsigned long )qu == (unsigned long )ads___7->output.tail;
      }
#line 151
      if (! tmp) {
        {
#line 151
        __assert_fail("(qu)-> next ? (qu) == (qu)-> next-> back : (qu) == (ads->output).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! ((unsigned int )qu->state == 3U)) {
        {
#line 151
        __assert_fail("qu->state == query_done", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! qu->children.head) {
#line 151
        if (! (! qu->children.tail)) {
          {
#line 151
          __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        157U, "checkc_queue_output");
          }
        }
      } else {
        {
#line 151
        __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! (! qu->parent)) {
        {
#line 151
        __assert_fail("!qu->parent", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! qu->allocations.head) {
#line 151
        if (! (! qu->allocations.tail)) {
          {
#line 151
          __assert_fail("!qu->allocations.head && !qu->allocations.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        157U, "checkc_queue_output");
          }
        }
      } else {
        {
#line 151
        __assert_fail("!qu->allocations.head && !qu->allocations.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
      {
#line 151
      checkc_query___4(ads___7, qu);
#line 151
      qu = qu->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 158
  return;
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
static struct sinfo  const  sinfos___4[24]  = 
#line 233 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
  {      {(adns_status )0, "ok", "OK"}, 
        {(adns_status )1, "nomemory", "Out of memory"}, 
        {(adns_status )2, "unknownrrtype", "Query not implemented in DNS library"}, 
        {(adns_status )3, "systemfail", "General resolver or system failure"}, 
        {(adns_status )30, "timeout", "DNS query timed out"}, 
        {(adns_status )31, "allservfail", "All nameservers failed"}, 
        {(adns_status )32, "norecurse", "Recursion denied by nameserver"}, 
        {(adns_status )33, "invalidresponse", "Nameserver sent bad response"}, 
        {(adns_status )34, "unknownformat", "Nameserver used unknown format"}, 
        {(adns_status )60, "rcodeservfail", "Nameserver reports failure"}, 
        {(adns_status )61, "rcodeformaterror", "Query not understood by nameserver"}, 
        {(adns_status )62,
      "rcodenotimplemented", "Query not implemented by nameserver"}, 
        {(adns_status )63, "rcoderefused", "Query refused by nameserver"}, 
        {(adns_status )64, "rcodeunknown", "Nameserver sent unknown response code"}, 
        {(adns_status )100, "inconsistent", "Inconsistent resource records in DNS"}, 
        {(adns_status )101, "prohibitedcname", "DNS alias found where canonical name wanted"}, 
        {(adns_status )102,
      "answerdomaininvalid", "Found syntactically invalid domain name"}, 
        {(adns_status )103, "answerdomaintoolong", "Found overly-long domain name"}, 
        {(adns_status )104, "invaliddata", "Found invalid DNS data"}, 
        {(adns_status )200, "querydomainwrong", "Domain invalid for particular DNS query type"}, 
        {(adns_status )201,
      "querydomaininvalid", "Domain name is syntactically invalid"}, 
        {(adns_status )202, "querydomaintoolong", "Domain name or component is too long"}, 
        {(adns_status )300,
      "nxdomain", "No such domain"}, 
        {(adns_status )301, "nodata", "No such data"}};
#line 270 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
static int si_compar___4(void const   *key , void const   *elem ) 
{ 
  adns_status const   *st ;
  struct sinfo  const  *si ;
  int tmp ;
  int tmp___0 ;

  {
#line 271
  st = (adns_status const   *)key;
#line 272
  si = (struct sinfo  const  *)elem;
#line 274
  if ((unsigned int const   )*st < (unsigned int const   )si->st) {
#line 274
    tmp___0 = -1;
  } else {
#line 274
    if ((unsigned int const   )*st > (unsigned int const   )si->st) {
#line 274
      tmp = 1;
    } else {
#line 274
      tmp = 0;
    }
#line 274
    tmp___0 = tmp;
  }
#line 274
  return (tmp___0);
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
static struct sinfo  const  *findsinfo___4(adns_status st ) 
{ 
  void *tmp ;

  {
  {
#line 278
  tmp = bsearch((void const   *)(& st), (void const   *)(sinfos___4), sizeof(sinfos___4) / sizeof(sinfos___4[0]),
                sizeof(sinfos___4[0]), & si_compar___4);
  }
#line 278
  return ((struct sinfo  const  *)tmp);
}
}
#line 299 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
static struct stinfo  const  stinfos___4[7]  = {      {(adns_status )0, "ok"}, 
        {(adns_status )29, "localfail"}, 
        {(adns_status )59, "remotefail"}, 
        {(adns_status )99, "tempfail"}, 
        {(adns_status )199, "misconfig"}, 
        {(adns_status )299, "misquery"}, 
        {(adns_status )499, "permfail"}};
#line 312 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
static int sti_compar___4(void const   *key , void const   *elem ) 
{ 
  adns_status const   *st ;
  struct stinfo  const  *sti ;
  adns_status here ;
  adns_status min ;
  adns_status max ;
  int tmp ;
  int tmp___0 ;

  {
#line 313
  st = (adns_status const   *)key;
#line 314
  sti = (struct stinfo  const  *)elem;
#line 318
  here = (adns_status )*st;
#line 319
  if ((unsigned long )sti == (unsigned long )(stinfos___4)) {
#line 319
    min = (adns_status )0;
  } else {
#line 319
    min = (adns_status )((unsigned int const   )(sti + -1)->stmax + 1U);
  }
#line 320
  max = (adns_status )sti->stmax;
#line 322
  if ((unsigned int )here < (unsigned int )min) {
#line 322
    tmp___0 = -1;
  } else {
#line 322
    if ((unsigned int )here > (unsigned int )max) {
#line 322
      tmp = 1;
    } else {
#line 322
      tmp = 0;
    }
#line 322
    tmp___0 = tmp;
  }
#line 322
  return (tmp___0);
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/transmit.c"
static adns_status mkquery_header___4(adns_state ads___7 , vbuf *vb___0 , int *id_r ,
                                      int qdlen ) 
{ 
  int id ;
  byte *rqp ;
  int tmp ;
  int tmp___0 ;
  byte *tmp___1 ;
  byte *tmp___2 ;
  byte *tmp___3 ;
  byte *tmp___4 ;
  byte *tmp___5 ;
  byte *tmp___6 ;
  byte *tmp___7 ;
  byte *tmp___8 ;
  byte *tmp___9 ;
  byte *tmp___10 ;
  byte *tmp___11 ;
  byte *tmp___12 ;

  {
  {
#line 46
  tmp = adns__vbuf_ensure(vb___0, (12 + qdlen) + 4);
  }
#line 46
  if (! tmp) {
#line 46
    return ((adns_status )1);
  }
#line 48
  vb___0->used = 0;
#line 49
  rqp = vb___0->buf + vb___0->used;
#line 51
  tmp___0 = ads___7->nextid;
#line 51
  (ads___7->nextid) ++;
#line 51
  id = tmp___0 & 65535;
#line 51
  *id_r = id;
#line 52
  tmp___1 = rqp;
#line 52
  rqp ++;
#line 52
  *tmp___1 = (byte )((id >> 8) & 255);
#line 52
  tmp___2 = rqp;
#line 52
  rqp ++;
#line 52
  *tmp___2 = (byte )(id & 255);
#line 53
  tmp___3 = rqp;
#line 53
  rqp ++;
#line 53
  *tmp___3 = (byte )1;
#line 54
  tmp___4 = rqp;
#line 54
  rqp ++;
#line 54
  *tmp___4 = (byte )0;
#line 55
  tmp___5 = rqp;
#line 55
  rqp ++;
#line 55
  *tmp___5 = (byte )((1 >> 8) & 255);
#line 55
  tmp___6 = rqp;
#line 55
  rqp ++;
#line 55
  *tmp___6 = (byte )1;
#line 56
  tmp___7 = rqp;
#line 56
  rqp ++;
#line 56
  *tmp___7 = (byte )0;
#line 56
  tmp___8 = rqp;
#line 56
  rqp ++;
#line 56
  *tmp___8 = (byte )0;
#line 57
  tmp___9 = rqp;
#line 57
  rqp ++;
#line 57
  *tmp___9 = (byte )0;
#line 57
  tmp___10 = rqp;
#line 57
  rqp ++;
#line 57
  *tmp___10 = (byte )0;
#line 58
  tmp___11 = rqp;
#line 58
  rqp ++;
#line 58
  *tmp___11 = (byte )0;
#line 58
  tmp___12 = rqp;
#line 58
  rqp ++;
#line 58
  *tmp___12 = (byte )0;
#line 60
  vb___0->used = (int )(rqp - vb___0->buf);
#line 62
  return ((adns_status )0);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/transmit.c"
static adns_status mkquery_footer___4(vbuf *vb___0 , adns_rrtype type ) 
{ 
  byte *rqp ;
  byte *tmp ;
  byte *tmp___0 ;
  byte *tmp___1 ;
  byte *tmp___2 ;

  {
#line 68
  rqp = vb___0->buf + vb___0->used;
#line 69
  tmp = rqp;
#line 69
  rqp ++;
#line 69
  *tmp = (byte )((((unsigned int )type & 65535U) >> 8) & 255U);
#line 69
  tmp___0 = rqp;
#line 69
  rqp ++;
#line 69
  *tmp___0 = (byte )(((unsigned int )type & 65535U) & 255U);
#line 70
  tmp___1 = rqp;
#line 70
  rqp ++;
#line 70
  *tmp___1 = (byte )((1 >> 8) & 255);
#line 70
  tmp___2 = rqp;
#line 70
  rqp ++;
#line 70
  *tmp___2 = (byte )1;
#line 71
  vb___0->used = (int )(rqp - vb___0->buf);
#line 72
  if (! (vb___0->used <= vb___0->avail)) {
    {
#line 72
    __assert_fail("vb->used <= vb->avail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/transmit.c",
                  72U, "mkquery_footer");
    }
  }
#line 74
  return ((adns_status )0);
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/transmit.c"
static void query_usetcp___4(adns_query qu , struct timeval now ) 
{ 


  {
  {
#line 244
  qu->state = (enum __anonenum_state_83 )1;
#line 245
  qu->timeout = now;
#line 246
  timevaladd(& qu->timeout, 30000L);
  }
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    qu->next = (adns_query )0;
#line 247
    qu->back = (qu->ads)->tcpw.tail;
#line 247
    if ((qu->ads)->tcpw.tail) {
#line 247
      ((qu->ads)->tcpw.tail)->next = qu;
    } else {
#line 247
      (qu->ads)->tcpw.head = qu;
    }
#line 247
    (qu->ads)->tcpw.tail = qu;
#line 247
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 248
  adns__querysend_tcp(qu, now);
#line 249
  adns__tcp_tryconnect(qu->ads, now);
  }
#line 250
  return;
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static adns_query query_alloc___4(adns_state ads___7 , typeinfo const   *typei , adns_rrtype type ,
                                  adns_queryflags flags , struct timeval now ) 
{ 
  adns_query qu ;
  void *tmp ;
  void *tmp___0 ;
  adns_query tmp___1 ;
  adns_query tmp___2 ;
  adns_query tmp___3 ;
  adns_query tmp___4 ;
  allocnode *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __suseconds_t tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 45
  tmp = Hmalloc(sizeof(*qu));
#line 45
  qu = (adns_query )tmp;
  }
#line 45
  if (! qu) {
#line 45
    return ((adns_query )0);
  }
  {
#line 46
  tmp___0 = Hmalloc(sizeof(*(qu->answer)));
#line 46
  qu->answer = (adns_answer *)tmp___0;
  }
#line 47
  if (! qu->answer) {
    {
#line 47
    Hfree((void *)qu);
    }
#line 47
    return ((adns_query )0);
  }
  {
#line 49
  qu->ads = ads___7;
#line 50
  qu->state = (enum __anonenum_state_83 )0;
#line 51
  tmp___2 = (adns_query )0;
#line 51
  qu->parent = tmp___2;
#line 51
  tmp___1 = tmp___2;
#line 51
  qu->next = tmp___1;
#line 51
  qu->back = tmp___1;
#line 52
  tmp___3 = (adns_query )0;
#line 52
  qu->children.tail = tmp___3;
#line 52
  qu->children.head = tmp___3;
#line 53
  tmp___4 = (adns_query )0;
#line 53
  qu->siblings.back = tmp___4;
#line 53
  qu->siblings.next = tmp___4;
#line 54
  tmp___5 = (allocnode *)0;
#line 54
  qu->allocations.tail = tmp___5;
#line 54
  qu->allocations.head = tmp___5;
#line 55
  qu->interim_allocd = 0;
#line 56
  qu->preserved_allocd = 0;
#line 57
  qu->final_allocspace = (void *)0;
#line 59
  qu->typei = typei;
#line 60
  qu->query_dgram = (byte *)0;
#line 61
  qu->query_dglen = 0;
#line 62
  adns__vbuf_init(& qu->vb);
#line 64
  qu->cname_dgram = (byte *)0;
#line 65
  tmp___6 = 0;
#line 65
  qu->cname_begin = tmp___6;
#line 65
  qu->cname_dglen = tmp___6;
#line 67
  adns__vbuf_init(& qu->search_vb);
#line 68
  tmp___8 = 0;
#line 68
  qu->search_doneabs = tmp___8;
#line 68
  tmp___7 = tmp___8;
#line 68
  qu->search_pos = tmp___7;
#line 68
  qu->search_origlen = tmp___7;
#line 70
  qu->id = -2;
#line 71
  qu->flags = (int )flags;
#line 72
  qu->retries = 0;
#line 73
  qu->udpnextserver = 0;
#line 74
  qu->udpsent = 0UL;
#line 75
  tmp___9 = (__suseconds_t )0;
#line 75
  qu->timeout.tv_usec = tmp___9;
#line 75
  qu->timeout.tv_sec = tmp___9;
#line 76
  qu->expires = now.tv_sec + 604800L;
#line 78
  memset((void *)(& qu->ctx), 0, sizeof(qu->ctx));
#line 80
  (qu->answer)->status = (adns_status )0;
#line 81
  tmp___10 = (char *)0;
#line 81
  (qu->answer)->owner = tmp___10;
#line 81
  (qu->answer)->cname = tmp___10;
#line 82
  (qu->answer)->type = type;
#line 83
  (qu->answer)->expires = (time_t )-1;
#line 84
  (qu->answer)->nrrs = 0;
#line 85
  (qu->answer)->rrs.untyped = (void *)0;
#line 86
  (qu->answer)->rrsz = (int )typei->rrsz;
  }
#line 88
  return (qu);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void query_submit___4(adns_state ads___7 , adns_query qu , typeinfo const   *typei ,
                             vbuf *qumsg_vb , int id , adns_queryflags flags , struct timeval now ) 
{ 
  void *tmp ;

  {
  {
#line 98
  qu->vb = *qumsg_vb;
#line 99
  adns__vbuf_init(qumsg_vb);
#line 101
  tmp = Hmalloc((size_t )qu->vb.used);
#line 101
  qu->query_dgram = (byte *)tmp;
  }
#line 102
  if (! qu->query_dgram) {
    {
#line 102
    adns__query_fail(qu, (adns_status )1);
    }
#line 102
    return;
  }
  {
#line 104
  qu->id = id;
#line 105
  qu->query_dglen = qu->vb.used;
#line 106
  memcpy((void */* __restrict  */)qu->query_dgram, (void const   */* __restrict  */)qu->vb.buf,
         (size_t )qu->vb.used);
#line 108
  adns__query_send(qu, now);
  }
#line 109
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void query_simple___4(adns_state ads___7 , adns_query qu , char const   *owner ,
                             int ol , typeinfo const   *typei , adns_queryflags flags ,
                             struct timeval now ) 
{ 
  vbuf vb_new ;
  int id ;
  adns_status stat ;

  {
  {
#line 136
  stat = adns__mkquery(ads___7, & qu->vb, & id, owner, ol, typei, (qu->answer)->type,
                       flags);
  }
#line 138
  if (stat) {
#line 139
    if ((unsigned int )stat == 202U) {
#line 139
      if ((unsigned int )flags & 1U) {
        {
#line 140
        adns__search_next(ads___7, qu, now);
        }
#line 141
        return;
      } else {
        {
#line 143
        adns__query_fail(qu, stat);
        }
#line 144
        return;
      }
    } else {
      {
#line 143
      adns__query_fail(qu, stat);
      }
#line 144
      return;
    }
  }
  {
#line 148
  vb_new = qu->vb;
#line 149
  adns__vbuf_init(& qu->vb);
#line 150
  query_submit___4(ads___7, qu, typei, & vb_new, id, flags, now);
  }
#line 151
  return;
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static int save_owner___4(adns_query qu , char const   *owner , int ol ) 
{ 
  adns_answer *ans ;
  void *tmp ;

  {
#line 198
  if (! (qu->flags & 4)) {
#line 198
    return (1);
  }
#line 200
  ans = qu->answer;
#line 201
  if (! (! ans->owner)) {
    {
#line 201
    __assert_fail("!ans->owner", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c",
                  201U, "save_owner");
    }
  }
  {
#line 203
  tmp = adns__alloc_preserved(qu, (size_t )(ol + 1));
#line 203
  ans->owner = (char *)tmp;
  }
#line 203
  if (! ans->owner) {
#line 203
    return (0);
  }
  {
#line 205
  memcpy((void */* __restrict  */)ans->owner, (void const   */* __restrict  */)owner,
         (size_t )ol);
#line 206
  *(ans->owner + ol) = (char)0;
  }
#line 207
  return (1);
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void *alloc_common___4(adns_query qu , size_t sz ) 
{ 
  allocnode *an ;
  void *tmp ;

  {
#line 342
  if (! sz) {
#line 342
    return ((void *)qu);
  }
#line 343
  if (! (! qu->final_allocspace)) {
    {
#line 343
    __assert_fail("!qu->final_allocspace", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c",
                  343U, "alloc_common");
    }
  }
  {
#line 344
  tmp = Hmalloc((((((((sizeof(*an) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ) + sz) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ));
#line 344
  an = (allocnode *)tmp;
  }
#line 345
  if (! an) {
#line 345
    return ((void *)0);
  }
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 346
    an->next = (struct allocnode *)0;
#line 346
    an->back = qu->allocations.tail;
#line 346
    if (qu->allocations.tail) {
#line 346
      (qu->allocations.tail)->next = an;
    } else {
#line 346
      qu->allocations.head = an;
    }
#line 346
    qu->allocations.tail = an;
#line 346
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 347
  return ((void *)((byte *)an + (((sizeof(*an) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign )));
}
}
#line 410 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void cancel_children___4(adns_query qu ) 
{ 
  adns_query cqu ;
  adns_query ncqu ;

  {
#line 413
  cqu = qu->children.head;
  {
#line 413
  while (1) {
    while_continue: /* CIL Label */ ;
#line 413
    if (! cqu) {
#line 413
      goto while_break;
    }
    {
#line 414
    ncqu = cqu->siblings.next;
#line 415
    adns_cancel(cqu);
#line 413
    cqu = ncqu;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 417
  return;
}
}
#line 427 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void free_query_allocs___4(adns_query qu ) 
{ 
  allocnode *an ;
  allocnode *ann ;
  allocnode *tmp ;

  {
  {
#line 430
  cancel_children___4(qu);
#line 431
  an = qu->allocations.head;
  }
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    if (! an) {
#line 431
      goto while_break;
    }
    {
#line 431
    ann = an->next;
#line 431
    Hfree((void *)an);
#line 431
    an = ann;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 432
  tmp = (allocnode *)0;
#line 432
  qu->allocations.tail = tmp;
#line 432
  qu->allocations.head = tmp;
#line 433
  adns__vbuf_free(& qu->vb);
#line 434
  adns__vbuf_free(& qu->search_vb);
#line 435
  Hfree((void *)qu->query_dgram);
#line 436
  qu->query_dgram = (byte *)0;
  }
#line 437
  return;
}
}
#line 477 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void makefinal_query___4(adns_query qu ) 
{ 
  adns_answer *ans ;
  int rrn ;
  void *tmp ;

  {
#line 481
  ans = qu->answer;
#line 483
  if (qu->interim_allocd) {
    {
#line 484
    tmp = Hrealloc((void *)qu->answer, (((((((sizeof(*ans) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ) + (unsigned long )qu->interim_allocd) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ));
#line 484
    ans = (adns_answer *)tmp;
    }
#line 486
    if (! ans) {
#line 486
      goto x_nomem;
    }
#line 487
    qu->answer = ans;
  }
  {
#line 490
  qu->final_allocspace = (void *)((byte *)ans + (((sizeof(*ans) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ));
#line 491
  adns__makefinal_str(qu, & ans->cname);
#line 492
  adns__makefinal_str(qu, & ans->owner);
  }
#line 494
  if (ans->nrrs) {
    {
#line 495
    adns__makefinal_block(qu, & ans->rrs.untyped, (size_t )(ans->nrrs * ans->rrsz));
#line 497
    rrn = 0;
    }
    {
#line 497
    while (1) {
      while_continue: /* CIL Label */ ;
#line 497
      if (! (rrn < ans->nrrs)) {
#line 497
        goto while_break;
      }
      {
#line 498
      (*((qu->typei)->makefinal))(qu, (void *)(ans->rrs.bytes + rrn * ans->rrsz));
#line 497
      rrn ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 501
  free_query_allocs___4(qu);
  }
#line 502
  return;
  x_nomem: 
  {
#line 505
  qu->preserved_allocd = 0;
#line 506
  (qu->answer)->cname = (char *)0;
#line 507
  (qu->answer)->owner = (char *)0;
#line 508
  adns__reset_preserved(qu);
#line 510
  (qu->answer)->status = (adns_status )1;
#line 511
  free_query_allocs___4(qu);
  }
#line 512
  return;
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void tcp_close___4(adns_state ads___7 ) 
{ 
  int serv ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 48
  serv = ads___7->tcpserver;
#line 49
  Hclose(ads___7->tcpsocket);
#line 50
  ads___7->tcpsocket = -1;
#line 51
  tmp___0 = 0;
#line 51
  ads___7->tcpsend.used = tmp___0;
#line 51
  tmp = tmp___0;
#line 51
  ads___7->tcprecv_skip = tmp;
#line 51
  ads___7->tcprecv.used = tmp;
  }
#line 52
  return;
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void tcp_connected___4(adns_state ads___7 , struct timeval now ) 
{ 
  adns_query qu ;
  adns_query nqu ;

  {
  {
#line 76
  adns__debug(ads___7, ads___7->tcpserver, (adns_query )0, "TCP connected");
#line 77
  ads___7->tcpstate = (enum adns__tcpstate )2;
#line 78
  qu = ads___7->tcpw.head;
  }
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (qu) {
#line 78
      if (! ((unsigned int )ads___7->tcpstate == 2U)) {
#line 78
        goto while_break;
      }
    } else {
#line 78
      goto while_break;
    }
#line 79
    nqu = qu->next;
#line 80
    if (! ((unsigned int )qu->state == 1U)) {
      {
#line 80
      __assert_fail("qu->state == query_tcpw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c",
                    80U, "tcp_connected");
      }
    }
    {
#line 81
    adns__querysend_tcp(qu, now);
#line 78
    qu = nqu;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void tcp_broken_events___4(adns_state ads___7 ) 
{ 
  adns_query qu ;
  adns_query nqu ;

  {
#line 88
  if (! ((unsigned int )ads___7->tcpstate == 3U)) {
    {
#line 88
    __assert_fail("ads->tcpstate == server_broken", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c",
                  88U, "tcp_broken_events");
    }
  }
#line 89
  qu = ads___7->tcpw.head;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! qu) {
#line 89
      goto while_break;
    }
#line 90
    nqu = qu->next;
#line 91
    if (! ((unsigned int )qu->state == 1U)) {
      {
#line 91
      __assert_fail("qu->state == query_tcpw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c",
                    91U, "tcp_broken_events");
      }
    }
#line 92
    if (qu->retries > ads___7->nservers) {
      {
#line 93
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 93
        if (qu->back) {
#line 93
          (qu->back)->next = qu->next;
        } else {
#line 93
          ads___7->tcpw.head = qu->next;
        }
#line 93
        if (qu->next) {
#line 93
          (qu->next)->back = qu->back;
        } else {
#line 93
          ads___7->tcpw.tail = qu->back;
        }
#line 93
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 94
      adns__query_fail(qu, (adns_status )31);
      }
    }
#line 89
    qu = nqu;
  }
  while_break: /* CIL Label */ ;
  }
#line 97
  ads___7->tcpstate = (enum adns__tcpstate )0;
#line 98
  return;
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void inter_immed___4(struct timeval **tv_io , struct timeval *tvbuf ) 
{ 
  struct timeval *rbuf ;
  __suseconds_t tmp ;

  {
#line 174
  if (! tv_io) {
#line 174
    return;
  }
#line 176
  rbuf = *tv_io;
#line 177
  if (! rbuf) {
#line 177
    rbuf = tvbuf;
#line 177
    *tv_io = rbuf;
  }
#line 179
  tmp = (__suseconds_t )0;
#line 179
  rbuf->tv_usec = tmp;
#line 179
  rbuf->tv_sec = tmp;
#line 180
  return;
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void inter_maxto___4(struct timeval **tv_io , struct timeval *tvbuf , struct timeval maxto ) 
{ 
  struct timeval *rbuf ;
  int tmp ;

  {
#line 186
  if (! tv_io) {
#line 186
    return;
  }
#line 187
  rbuf = *tv_io;
#line 188
  if (! rbuf) {
#line 189
    *tvbuf = maxto;
#line 189
    *tv_io = tvbuf;
  } else {
#line 191
    if (rbuf->tv_sec == maxto.tv_sec) {
#line 191
      tmp = rbuf->tv_usec > maxto.tv_usec;
    } else {
#line 191
      tmp = rbuf->tv_sec > maxto.tv_sec;
    }
#line 191
    if (tmp) {
#line 191
      *rbuf = maxto;
    }
  }
#line 195
  return;
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void inter_maxtoabs___4(struct timeval **tv_io , struct timeval *tvbuf , struct timeval now ,
                               struct timeval maxtime ) 
{ 
  ldiv_t dr ;

  {
#line 204
  if (! tv_io) {
#line 204
    return;
  }
  {
#line 205
  maxtime.tv_sec -= now.tv_sec + 2L;
#line 206
  maxtime.tv_usec -= now.tv_usec - 2000000L;
#line 207
  dr = ldiv(maxtime.tv_usec, 1000000L);
#line 208
  maxtime.tv_sec += dr.quot;
#line 209
  maxtime.tv_usec -= dr.quot * 1000000L;
  }
#line 210
  if (maxtime.tv_sec < 0L) {
#line 210
    maxtime.tv_usec = (__suseconds_t )0;
#line 210
    maxtime.tv_sec = maxtime.tv_usec;
  }
  {
#line 211
  inter_maxto___4(tv_io, tvbuf, maxtime);
  }
#line 212
  return;
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void timeouts_queue___4(adns_state ads___7 , int act , struct timeval **tv_io ,
                               struct timeval *tvbuf , struct timeval now , struct query_queue *queue ) 
{ 
  adns_query qu ;
  adns_query nqu ;
  int tmp ;

  {
#line 219
  qu = queue->head;
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if (! qu) {
#line 219
      goto while_break;
    }
#line 220
    nqu = qu->next;
#line 221
    if (now.tv_sec == qu->timeout.tv_sec) {
#line 221
      tmp = now.tv_usec > qu->timeout.tv_usec;
    } else {
#line 221
      tmp = now.tv_sec > qu->timeout.tv_sec;
    }
#line 221
    if (tmp) {
#line 224
      if (! act) {
        {
#line 224
        inter_immed___4(tv_io, tvbuf);
        }
#line 224
        return;
      }
      {
#line 225
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 225
        if (qu->back) {
#line 225
          (qu->back)->next = qu->next;
        } else {
#line 225
          queue->head = qu->next;
        }
#line 225
        if (qu->next) {
#line 225
          (qu->next)->back = qu->back;
        } else {
#line 225
          queue->tail = qu->back;
        }
#line 225
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 226
      if ((unsigned int )qu->state != 0U) {
        {
#line 227
        adns__query_fail(qu, (adns_status )30);
        }
      } else {
        {
#line 229
        adns__query_send(qu, now);
        }
      }
#line 231
      nqu = queue->head;
    } else {
      {
#line 222
      inter_maxtoabs___4(tv_io, tvbuf, now, qu->timeout);
      }
    }
#line 219
    qu = nqu;
  }
  while_break: /* CIL Label */ ;
  }
#line 234
  return;
}
}
#line 236 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void tcp_events___4(adns_state ads___7 , int act , struct timeval **tv_io ,
                           struct timeval *tvbuf , struct timeval now ) 
{ 
  int tmp ;

  {
  {
#line 239
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 241
    if ((unsigned int )ads___7->tcpstate == 3U) {
#line 241
      goto case_3;
    }
#line 244
    if ((unsigned int )ads___7->tcpstate == 0U) {
#line 244
      goto case_0;
    }
#line 249
    if ((unsigned int )ads___7->tcpstate == 2U) {
#line 249
      goto case_2;
    }
#line 256
    if ((unsigned int )ads___7->tcpstate == 1U) {
#line 256
      goto case_1;
    }
#line 275
    goto switch_default___0;
    case_3: /* CIL Label */ 
#line 242
    if (! act) {
      {
#line 242
      inter_immed___4(tv_io, tvbuf);
      }
#line 242
      return;
    }
    {
#line 243
    tcp_broken_events___4(ads___7);
    }
    case_0: /* CIL Label */ 
#line 245
    if (! ads___7->tcpw.head) {
#line 245
      return;
    }
#line 246
    if (! act) {
      {
#line 246
      inter_immed___4(tv_io, tvbuf);
      }
#line 246
      return;
    }
    {
#line 247
    adns__tcp_tryconnect(ads___7, now);
    }
#line 248
    goto switch_break;
    case_2: /* CIL Label */ 
#line 250
    if (ads___7->tcpw.head) {
#line 250
      return;
    }
#line 251
    if (! ads___7->tcptimeout.tv_sec) {
#line 252
      if (! (! ads___7->tcptimeout.tv_usec)) {
        {
#line 252
        __assert_fail("!ads->tcptimeout.tv_usec", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c",
                      252U, "tcp_events");
        }
      }
      {
#line 253
      ads___7->tcptimeout = now;
#line 254
      timevaladd(& ads___7->tcptimeout, 30000L);
      }
    }
    case_1: /* CIL Label */ 
#line 257
    if (! act) {
      {
#line 258
      inter_maxtoabs___4(tv_io, tvbuf, now, ads___7->tcptimeout);
      }
#line 259
      return;
    } else {
#line 257
      if (now.tv_sec == ads___7->tcptimeout.tv_sec) {
#line 257
        tmp = now.tv_usec > ads___7->tcptimeout.tv_usec;
      } else {
#line 257
        tmp = now.tv_sec > ads___7->tcptimeout.tv_sec;
      }
#line 257
      if (! tmp) {
        {
#line 258
        inter_maxtoabs___4(tv_io, tvbuf, now, ads___7->tcptimeout);
        }
#line 259
        return;
      }
    }
    {
#line 263
    if ((unsigned int )ads___7->tcpstate == 1U) {
#line 263
      goto case_1___0;
    }
#line 266
    if ((unsigned int )ads___7->tcpstate == 2U) {
#line 266
      goto case_2___0;
    }
#line 270
    goto switch_default;
    case_1___0: /* CIL Label */ 
    {
#line 264
    adns__tcp_broken(ads___7, "unable to make connection", "timed out");
    }
#line 265
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 267
    tcp_close___4(ads___7);
#line 268
    ads___7->tcpstate = (enum adns__tcpstate )0;
    }
#line 269
    return;
    switch_default: /* CIL Label */ 
    {
#line 271
    abort();
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 274
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
#line 276
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 279
  return;
}
}
#line 516 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void fd_event___4(adns_state ads___7 , int fd , int revent , int pollflag ,
                         int maxfd , fd_set const   *fds , int (*func)(adns_state  ,
                                                                       int fd , struct timeval  const  *now ) ,
                         struct timeval now , int *r_r ) 
{ 
  int r ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 524
  if (! (revent & pollflag)) {
#line 524
    return;
  }
#line 525
  if (fds) {
#line 525
    if (fd < maxfd) {
#line 525
      if (! ((fds->__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
#line 525
        return;
      }
    } else {
#line 525
      return;
    }
  }
  {
#line 526
  r = (*func)(ads___7, fd, (struct timeval  const  *)(& now));
  }
#line 527
  if (r) {
#line 528
    if (r_r) {
#line 529
      *r_r = r;
    } else {
      {
#line 531
      tmp = __errno_location();
#line 531
      tmp___0 = strerror(*tmp);
#line 531
      adns__diag(ads___7, -1, (adns_query )0, "process fd failed after select: %s",
                 tmp___0);
#line 533
      adns_globalsystemfailure(ads___7);
      }
    }
  }
#line 536
  return;
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfig___5(adns_state ads___7 , char const   *filename , int warnmissing ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void addserver___5(adns_state ads___7 , struct in_addr addr ) 
{ 
  int i ;
  struct server *ss ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 48
  i = 0;
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (i < ads___7->nservers)) {
#line 48
      goto while_break;
    }
#line 49
    if (ads___7->servers[i].addr.s_addr == addr.s_addr) {
      {
#line 50
      tmp = inet_ntoa(addr);
#line 50
      adns__debug(ads___7, -1, (adns_query )0, "duplicate nameserver %s ignored",
                  tmp);
      }
#line 51
      return;
    }
#line 48
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  if (ads___7->nservers >= 5) {
    {
#line 56
    tmp___0 = inet_ntoa(addr);
#line 56
    adns__diag(ads___7, -1, (adns_query )0, "too many nameservers, ignoring %s", tmp___0);
    }
#line 57
    return;
  }
#line 60
  ss = ads___7->servers + ads___7->nservers;
#line 61
  ss->addr = addr;
#line 62
  (ads___7->nservers) ++;
#line 63
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void freesearchlist___5(adns_state ads___7 ) 
{ 


  {
#line 66
  if (ads___7->nsearchlist) {
    {
#line 66
    Hfree((void *)*(ads___7->searchlist));
    }
  }
  {
#line 67
  Hfree((void *)ads___7->searchlist);
  }
#line 68
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void saveerr___5(adns_state ads___7 , int en ) 
{ 


  {
#line 71
  if (! ads___7->configerrno) {
#line 71
    ads___7->configerrno = en;
  }
#line 72
  return;
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void configparseerr___5(adns_state ads___7 , char const   *fn , int lno , char const   *fmt 
                               , ...) 
{ 
  va_list al ;

  {
  {
#line 78
  saveerr___5(ads___7, 22);
  }
#line 79
  if (! ads___7->logfn) {
#line 79
    return;
  } else
#line 79
  if ((unsigned int )ads___7->iflags & 2U) {
#line 79
    return;
  }
#line 81
  if (lno == -1) {
    {
#line 81
    adns__lprintf(ads___7, "adns: %s: ", fn);
    }
  } else {
    {
#line 82
    adns__lprintf(ads___7, "adns: %s:%d: ", fn, lno);
    }
  }
  {
#line 83
  __builtin_va_start(al, fmt);
#line 84
  adns__vlprintf(ads___7, fmt, al);
#line 85
  __builtin_va_end(al);
#line 86
  adns__lprintf(ads___7, "\n");
  }
#line 87
  return;
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int nextword___5(char const   **bufp_io , char const   **word_r , int *l_r ) 
{ 
  char const   *p ;
  char const   *q ;
  int tmp ;
  int tmp___0 ;

  {
#line 92
  p = *bufp_io;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 93
    tmp = ctype_whitespace((int )*p);
    }
#line 93
    if (! tmp) {
#line 93
      goto while_break;
    }
#line 93
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  if (! *p) {
#line 94
    return (0);
  }
#line 96
  q = p;
  {
#line 97
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 97
    if (*q) {
      {
#line 97
      tmp___0 = ctype_whitespace((int )*q);
      }
#line 97
      if (tmp___0) {
#line 97
        goto while_break___0;
      }
    } else {
#line 97
      goto while_break___0;
    }
#line 97
    q ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 99
  *l_r = (int )(q - p);
#line 100
  *word_r = p;
#line 101
  *bufp_io = q;
#line 103
  return (1);
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_nameserver___5(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  struct in_addr ia ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 110
  tmp = inet_aton(buf___17, & ia);
  }
#line 110
  if (! tmp) {
    {
#line 111
    configparseerr___5(ads___7, fn, lno, "invalid nameserver address `%s\'", buf___17);
    }
#line 112
    return;
  }
  {
#line 114
  tmp___0 = inet_ntoa(ia);
#line 114
  adns__debug(ads___7, -1, (adns_query )0, "using nameserver %s", tmp___0);
#line 115
  addserver___5(ads___7, ia);
  }
#line 116
  return;
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_search___5(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  char const   *bufp ;
  char const   *word ;
  char *newchars ;
  char **newptrs ;
  char **pp ;
  int count ;
  int tl ;
  int l ;
  int tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char **tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
#line 124
  if (! buf___17) {
#line 124
    return;
  }
#line 126
  bufp = buf___17;
#line 127
  count = 0;
#line 128
  tl = 0;
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 129
    tmp = nextword___5(& bufp, & word, & l);
    }
#line 129
    if (! tmp) {
#line 129
      goto while_break;
    }
#line 129
    count ++;
#line 129
    tl += l + 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 131
  tmp___0 = Hmalloc(sizeof(char *) * (unsigned long )count);
#line 131
  newptrs = (char **)tmp___0;
  }
#line 132
  if (! newptrs) {
    {
#line 132
    tmp___1 = __errno_location();
#line 132
    saveerr___5(ads___7, *tmp___1);
    }
#line 132
    return;
  }
  {
#line 134
  tmp___2 = Hmalloc((size_t )tl);
#line 134
  newchars = (char *)tmp___2;
  }
#line 135
  if (! newchars) {
    {
#line 135
    tmp___3 = __errno_location();
#line 135
    saveerr___5(ads___7, *tmp___3);
#line 135
    Hfree((void *)newptrs);
    }
#line 135
    return;
  }
#line 137
  bufp = buf___17;
#line 138
  pp = newptrs;
  {
#line 139
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 139
    tmp___6 = nextword___5(& bufp, & word, & l);
    }
#line 139
    if (! tmp___6) {
#line 139
      goto while_break___0;
    }
    {
#line 140
    tmp___4 = pp;
#line 140
    pp ++;
#line 140
    *tmp___4 = newchars;
#line 141
    memcpy((void */* __restrict  */)newchars, (void const   */* __restrict  */)word,
           (size_t )l);
#line 142
    newchars += l;
#line 143
    tmp___5 = newchars;
#line 143
    newchars ++;
#line 143
    *tmp___5 = (char)0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 146
  freesearchlist___5(ads___7);
#line 147
  ads___7->nsearchlist = count;
#line 148
  ads___7->searchlist = newptrs;
  }
#line 149
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_sortlist___5(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  char const   *word ;
  char tbuf[200] ;
  char *slash ;
  char *ep ;
  struct in_addr base ;
  struct in_addr mask ;
  int l ;
  unsigned long initial ;
  unsigned long baselocal ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  uint32_t tmp___3 ;
  int tmp___4 ;

  {
#line 159
  if (! buf___17) {
#line 159
    return;
  }
#line 161
  ads___7->nsortlist = 0;
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 162
    tmp___4 = nextword___5(& buf___17, & word, & l);
    }
#line 162
    if (! tmp___4) {
#line 162
      goto while_break;
    }
#line 163
    if (ads___7->nsortlist >= 15) {
      {
#line 164
      adns__diag(ads___7, -1, (adns_query )0, "too many sortlist entries, ignoring %.*s onwards",
                 l, word);
      }
#line 166
      return;
    }
#line 169
    if ((unsigned long )l >= sizeof(tbuf)) {
      {
#line 170
      configparseerr___5(ads___7, fn, lno, "sortlist entry `%.*s\' too long", l, word);
      }
#line 171
      goto while_continue;
    }
    {
#line 174
    memcpy((void */* __restrict  */)(tbuf), (void const   */* __restrict  */)word,
           (size_t )l);
#line 174
    tbuf[l] = (char)0;
#line 175
    slash = strchr((char const   *)(tbuf), '/');
    }
#line 176
    if (slash) {
#line 176
      tmp = slash;
#line 176
      slash ++;
#line 176
      *tmp = (char)0;
    }
    {
#line 178
    tmp___0 = inet_aton((char const   *)(tbuf), & base);
    }
#line 178
    if (! tmp___0) {
      {
#line 179
      configparseerr___5(ads___7, fn, lno, "invalid address `%s\' in sortlist", tbuf);
      }
#line 180
      goto while_continue;
    }
#line 183
    if (slash) {
      {
#line 184
      tmp___2 = strchr((char const   *)slash, '.');
      }
#line 184
      if (tmp___2) {
        {
#line 185
        tmp___1 = inet_aton((char const   *)slash, & mask);
        }
#line 185
        if (! tmp___1) {
          {
#line 186
          configparseerr___5(ads___7, fn, lno, "invalid mask `%s\' in sortlist", slash);
          }
#line 187
          goto while_continue;
        }
#line 189
        if (base.s_addr & ~ mask.s_addr) {
          {
#line 190
          configparseerr___5(ads___7, fn, lno, "mask `%s\' in sortlist overlaps address `%s\'",
                             slash, tbuf);
          }
#line 192
          goto while_continue;
        }
      } else {
        {
#line 195
        initial = strtoul((char const   */* __restrict  */)slash, (char **/* __restrict  */)(& ep),
                          10);
        }
#line 196
        if (*ep) {
          {
#line 197
          configparseerr___5(ads___7, fn, lno, "mask length `%s\' invalid", slash);
          }
#line 198
          goto while_continue;
        } else
#line 196
        if (initial > 32UL) {
          {
#line 197
          configparseerr___5(ads___7, fn, lno, "mask length `%s\' invalid", slash);
          }
#line 198
          goto while_continue;
        }
        {
#line 200
        mask.s_addr = htonl((uint32_t )(4294967295UL << (32UL - initial)));
        }
      }
    } else {
      {
#line 203
      tmp___3 = ntohl(base.s_addr);
#line 203
      baselocal = (unsigned long )tmp___3;
      }
#line 204
      if ((unsigned long )(! baselocal) & 2147483648UL) {
        {
#line 205
        mask.s_addr = htonl((uint32_t )4278190080UL);
        }
      } else
#line 206
      if ((baselocal & 3221225472UL) == 2147483648UL) {
        {
#line 207
        mask.s_addr = htonl((uint32_t )4294901760UL);
        }
      } else
#line 208
      if ((baselocal & 4026531840UL) == 3758096384UL) {
        {
#line 209
        mask.s_addr = htonl((uint32_t )4278190080UL);
        }
      } else {
        {
#line 211
        configparseerr___5(ads___7, fn, lno, "network address `%s\' in sortlist is not in classed ranges, must specify mask explicitly",
                           tbuf);
        }
#line 214
        goto while_continue;
      }
    }
#line 218
    ads___7->sortlist[ads___7->nsortlist].base = base;
#line 219
    ads___7->sortlist[ads___7->nsortlist].mask = mask;
#line 220
    (ads___7->nsortlist) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  return;
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_options___5(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  char const   *word ;
  char *ep ;
  unsigned long v ;
  int l ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 231
  if (! buf___17) {
#line 231
    return;
  }
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 233
    tmp___5 = nextword___5(& buf___17, & word, & l);
    }
#line 233
    if (! tmp___5) {
#line 233
      goto while_break;
    }
#line 234
    if (l == 5) {
      {
#line 234
      tmp = memcmp((void const   *)word, (void const   *)"debug", (size_t )5);
      }
#line 234
      if (! tmp) {
#line 235
        ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 8U);
#line 236
        goto while_continue;
      }
    }
#line 238
    if (l >= 6) {
      {
#line 238
      tmp___0 = memcmp((void const   *)word, (void const   *)"ndots:", (size_t )6);
      }
#line 238
      if (! tmp___0) {
        {
#line 239
        v = strtoul((char const   */* __restrict  */)(word + 6), (char **/* __restrict  */)(& ep),
                    10);
        }
#line 240
        if (l == 6) {
          {
#line 241
          configparseerr___5(ads___7, fn, lno, "option `%.*s\' malformed or has bad value",
                             l, word);
          }
#line 243
          goto while_continue;
        } else
#line 240
        if ((unsigned long )ep != (unsigned long )(word + l)) {
          {
#line 241
          configparseerr___5(ads___7, fn, lno, "option `%.*s\' malformed or has bad value",
                             l, word);
          }
#line 243
          goto while_continue;
        } else
#line 240
        if (v > 2147483647UL) {
          {
#line 241
          configparseerr___5(ads___7, fn, lno, "option `%.*s\' malformed or has bad value",
                             l, word);
          }
#line 243
          goto while_continue;
        }
#line 245
        ads___7->searchndots = (int )v;
#line 246
        goto while_continue;
      }
    }
#line 248
    if (l >= 12) {
      {
#line 248
      tmp___4 = memcmp((void const   *)word, (void const   *)"adns_checkc:", (size_t )12);
      }
#line 248
      if (! tmp___4) {
        {
#line 249
        tmp___3 = strcmp(word + 12, "none");
        }
#line 249
        if (tmp___3) {
          {
#line 252
          tmp___2 = strcmp(word + 12, "entex");
          }
#line 252
          if (tmp___2) {
            {
#line 255
            tmp___1 = strcmp(word + 12, "freq");
            }
#line 255
            if (tmp___1) {
              {
#line 258
              configparseerr___5(ads___7, fn, lno, "option adns_checkc has bad value `%s\' (must be none, entex or freq",
                                 word + 12);
              }
            } else {
#line 256
              ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 768U);
            }
          } else {
#line 253
            ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags & 4294966527U);
#line 254
            ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 256U);
          }
        } else {
#line 250
          ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags & 4294966527U);
#line 251
          ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 256U);
        }
#line 261
        goto while_continue;
      }
    }
    {
#line 263
    adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown option `%.*s\'", fn, lno,
               l, word);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 265
  return;
}
}
#line 267 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_clearnss___5(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 


  {
#line 269
  ads___7->nservers = 0;
#line 270
  return;
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_include___5(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 


  {
#line 274
  if (! *buf___17) {
    {
#line 275
    configparseerr___5(ads___7, fn, lno, "`include\' directive with no filename");
    }
#line 276
    return;
  }
  {
#line 278
  readconfig___5(ads___7, buf___17, 1);
  }
#line 279
  return;
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_lookup___5(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  int found_bind ;
  char const   *word ;
  int l ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 283
  found_bind = 0;
#line 287
  if (! *buf___17) {
    {
#line 288
    configparseerr___5(ads___7, fn, lno, "`lookup\' directive with no databases");
    }
#line 289
    return;
  }
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 292
    tmp___2 = nextword___5(& buf___17, & word, & l);
    }
#line 292
    if (! tmp___2) {
#line 292
      goto while_break;
    }
#line 293
    if (l == 4) {
      {
#line 293
      tmp___1 = memcmp((void const   *)word, (void const   *)"bind", (size_t )4);
      }
#line 293
      if (tmp___1) {
#line 293
        goto _L___0;
      } else {
#line 294
        found_bind = 1;
      }
    } else
    _L___0: /* CIL Label */ 
#line 295
    if (l == 4) {
      {
#line 295
      tmp___0 = memcmp((void const   *)word, (void const   *)"file", (size_t )4);
      }
#line 295
      if (tmp___0) {
#line 295
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 297
    if (l == 2) {
      {
#line 297
      tmp = memcmp((void const   *)word, (void const   *)"yp", (size_t )2);
      }
#line 297
      if (tmp) {
        {
#line 301
        adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown `lookup\' database `%.*s\'",
                   fn, lno, l, word);
#line 303
        found_bind = -1;
        }
      } else {
        {
#line 298
        adns__diag(ads___7, -1, (adns_query )0, "%s:%d: yp lookups not supported by adns",
                   fn, lno);
#line 299
        found_bind = -1;
        }
      }
    } else {
      {
#line 301
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown `lookup\' database `%.*s\'",
                 fn, lno, l, word);
#line 303
      found_bind = -1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 306
  if (! found_bind) {
    {
#line 307
    adns__diag(ads___7, -1, (adns_query )0, "%s:%d: `lookup\' specified, but not `bind\'",
               fn, lno);
    }
  }
#line 308
  return;
}
}
#line 310 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static struct configcommandinfo  const  configcommandinfos___5[9]  = 
#line 310
  {      {"nameserver", & ccf_nameserver___5}, 
        {"domain", & ccf_search___5}, 
        {"search", & ccf_search___5}, 
        {"sortlist", & ccf_sortlist___5}, 
        {"options", & ccf_options___5}, 
        {"clearnameservers", & ccf_clearnss___5}, 
        {"include", & ccf_include___5}, 
        {"lookup", & ccf_lookup___5}, 
        {(char const   *)0, (void (*)(adns_state ads , char const   *fn , int lno , char const   *buf ))0}};
#line 330 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int gl_file___5(adns_state ads___7 , getline_ctx *src_io , char const   *filename ,
                       int lno , char *buf___17 , int buflen ) 
{ 
  FILE *file ;
  int c ;
  int i ;
  char *p ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 332
  file = src_io->file;
#line 336
  p = buf___17;
#line 337
  buflen --;
#line 338
  i = 0;
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (i == buflen) {
      {
#line 342
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: line too long, ignored", filename,
                 lno);
      }
#line 343
      goto x_badline;
    }
    {
#line 345
    c = _IO_getc(file);
    }
#line 346
    if (! c) {
      {
#line 347
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: line contains nul, ignored",
                 filename, lno);
      }
#line 348
      goto x_badline;
    } else
#line 349
    if (c == 10) {
#line 350
      goto while_break;
    } else
#line 351
    if (c == -1) {
      {
#line 352
      tmp___2 = ferror(file);
      }
#line 352
      if (tmp___2) {
        {
#line 353
        tmp = __errno_location();
#line 353
        saveerr___5(ads___7, *tmp);
#line 354
        tmp___0 = __errno_location();
#line 354
        tmp___1 = strerror(*tmp___0);
#line 354
        adns__diag(ads___7, -1, (adns_query )0, "%s:%d: read error: %s", filename,
                   lno, tmp___1);
        }
#line 356
        return (-1);
      }
#line 358
      if (! i) {
#line 358
        return (-1);
      }
#line 359
      goto while_break;
    } else {
#line 361
      tmp___3 = p;
#line 361
      p ++;
#line 361
      *tmp___3 = (char )c;
#line 362
      i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 366
  tmp___4 = p;
#line 366
  p ++;
#line 366
  *tmp___4 = (char)0;
#line 367
  return (i);
  x_badline: 
  {
#line 370
  saveerr___5(ads___7, 22);
  }
  {
#line 371
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 371
    c = _IO_getc(file);
    }
#line 371
    if (c != -1) {
#line 371
      if (! (c != 10)) {
#line 371
        goto while_break___0;
      }
    } else {
#line 371
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 372
  return (-2);
}
}
#line 375 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int gl_text___5(adns_state ads___7 , getline_ctx *src_io , char const   *filename ,
                       int lno , char *buf___17 , int buflen ) 
{ 
  char const   *cp ;
  int l ;
  size_t tmp ;

  {
#line 377
  cp = src_io->text;
#line 380
  if (! cp) {
#line 380
    return (-1);
  } else
#line 380
  if (! *cp) {
#line 380
    return (-1);
  }
#line 382
  if ((int const   )*cp == 59) {
#line 382
    cp ++;
  } else
#line 382
  if ((int const   )*cp == 10) {
#line 382
    cp ++;
  }
  {
#line 383
  tmp = strcspn(cp, ";\n");
#line 383
  l = (int )tmp;
#line 384
  src_io->text = cp + l;
  }
#line 386
  if (l >= buflen) {
    {
#line 387
    adns__diag(ads___7, -1, (adns_query )0, "%s:%d: line too long, ignored", filename,
               lno);
#line 388
    saveerr___5(ads___7, 22);
    }
#line 389
    return (-2);
  }
  {
#line 392
  memcpy((void */* __restrict  */)buf___17, (void const   */* __restrict  */)cp, (size_t )l);
#line 393
  *(buf___17 + l) = (char)0;
  }
#line 394
  return (l);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfiggeneric___5(adns_state ads___7 , char const   *filename , int (*getline___0)(adns_state ads ,
                                                                                                   getline_ctx * ,
                                                                                                   char const   *filename ,
                                                                                                   int lno ,
                                                                                                   char *buf ,
                                                                                                   int buflen ) ,
                                  getline_ctx gl_ctx ) 
{ 
  char linebuf[2000] ;
  char *p ;
  char *q ;
  int lno ;
  int l ;
  int dirl ;
  struct configcommandinfo  const  *ccip ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 410
  lno = 1;
  {
#line 410
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 410
    l = (*getline___0)(ads___7, & gl_ctx, filename, lno, linebuf, (int )sizeof(linebuf));
    }
#line 410
    if (! (l != -1)) {
#line 410
      goto while_break;
    }
#line 413
    if (l == -2) {
#line 413
      goto __Cont;
    }
    {
#line 414
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 414
      if (l > 0) {
        {
#line 414
        tmp = ctype_whitespace((int )linebuf[l - 1]);
        }
#line 414
        if (! tmp) {
#line 414
          goto while_break___0;
        }
      } else {
#line 414
        goto while_break___0;
      }
#line 414
      l --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 415
    linebuf[l] = (char)0;
#line 416
    p = linebuf;
    {
#line 417
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 417
      tmp___0 = ctype_whitespace((int )*p);
      }
#line 417
      if (! tmp___0) {
#line 417
        goto while_break___1;
      }
#line 417
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 418
    if ((int )*p == 35) {
#line 418
      goto __Cont;
    } else
#line 418
    if ((int )*p == 59) {
#line 418
      goto __Cont;
    } else
#line 418
    if (! *p) {
#line 418
      goto __Cont;
    }
#line 419
    q = p;
    {
#line 420
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 420
      if (*q) {
        {
#line 420
        tmp___1 = ctype_whitespace((int )*q);
        }
#line 420
        if (tmp___1) {
#line 420
          goto while_break___2;
        }
      } else {
#line 420
        goto while_break___2;
      }
#line 420
      q ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 421
    dirl = (int )(q - p);
#line 422
    ccip = configcommandinfos___5;
    {
#line 422
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 422
      if (ccip->name) {
        {
#line 422
        tmp___2 = strlen((char const   *)ccip->name);
        }
#line 422
        if (tmp___2 == (size_t )dirl) {
          {
#line 422
          tmp___3 = memcmp((void const   *)ccip->name, (void const   *)p, (size_t )(q - p));
          }
#line 422
          if (! tmp___3) {
#line 422
            goto while_break___3;
          }
        }
      } else {
#line 422
        goto while_break___3;
      }
#line 422
      ccip ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 426
    if (! ccip->name) {
      {
#line 427
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown configuration directive `%.*s\'",
                 filename, lno, (int )(q - p), p);
      }
#line 429
      goto __Cont;
    }
    {
#line 431
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 431
      tmp___4 = ctype_whitespace((int )*q);
      }
#line 431
      if (! tmp___4) {
#line 431
        goto while_break___4;
      }
#line 431
      q ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 432
    (*(ccip->fn))(ads___7, filename, lno, (char const   *)q);
    }
    __Cont: /* CIL Label */ 
#line 410
    lno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 434
  return;
}
}
#line 436 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static char const   *instrum_getenv___5(adns_state ads___7 , char const   *envvar ) 
{ 
  char const   *value ;
  char *tmp ;

  {
  {
#line 439
  tmp = getenv(envvar);
#line 439
  value = (char const   *)tmp;
  }
#line 440
  if (! value) {
    {
#line 440
    adns__debug(ads___7, -1, (adns_query )0, "environment variable %s not set", envvar);
    }
  } else {
    {
#line 441
    adns__debug(ads___7, -1, (adns_query )0, "environment variable %s set to `%s\'",
                envvar, value);
    }
  }
#line 443
  return (value);
}
}
#line 446 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfig___5(adns_state ads___7 , char const   *filename , int warnmissing ) 
{ 
  getline_ctx gl_ctx ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 449
  gl_ctx.file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 450
  if (! gl_ctx.file) {
    {
#line 451
    tmp = __errno_location();
    }
#line 451
    if (*tmp == 2) {
#line 452
      if (warnmissing) {
        {
#line 453
        adns__debug(ads___7, -1, (adns_query )0, "configuration file `%s\' does not exist",
                    filename);
        }
      }
#line 455
      return;
    }
    {
#line 457
    tmp___0 = __errno_location();
#line 457
    saveerr___5(ads___7, *tmp___0);
#line 458
    tmp___1 = __errno_location();
#line 458
    tmp___2 = strerror(*tmp___1);
#line 458
    adns__diag(ads___7, -1, (adns_query )0, "cannot open configuration file `%s\': %s",
               filename, tmp___2);
    }
#line 460
    return;
  }
  {
#line 463
  readconfiggeneric___5(ads___7, filename, & gl_file___5, gl_ctx);
#line 465
  fclose(gl_ctx.file);
  }
#line 466
  return;
}
}
#line 468 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfigtext___5(adns_state ads___7 , char const   *text , char const   *showname ) 
{ 
  getline_ctx gl_ctx ;

  {
  {
#line 472
  gl_ctx.text = text;
#line 473
  readconfiggeneric___5(ads___7, showname, & gl_text___5, gl_ctx);
  }
#line 474
  return;
}
}
#line 476 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfigenv___5(adns_state ads___7 , char const   *envvar ) 
{ 
  char const   *filename ;

  {
#line 479
  if ((unsigned int )ads___7->iflags & 1U) {
    {
#line 480
    adns__debug(ads___7, -1, (adns_query )0, "not checking environment variable `%s\'",
                envvar);
    }
#line 481
    return;
  }
  {
#line 483
  filename = instrum_getenv___5(ads___7, envvar);
  }
#line 484
  if (filename) {
    {
#line 484
    readconfig___5(ads___7, filename, 1);
    }
  }
#line 485
  return;
}
}
#line 487 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfigenvtext___5(adns_state ads___7 , char const   *envvar ) 
{ 
  char const   *textdata ;

  {
#line 490
  if ((unsigned int )ads___7->iflags & 1U) {
    {
#line 491
    adns__debug(ads___7, -1, (adns_query )0, "not checking environment variable `%s\'",
                envvar);
    }
#line 492
    return;
  }
  {
#line 494
  textdata = instrum_getenv___5(ads___7, envvar);
  }
#line 495
  if (textdata) {
    {
#line 495
    readconfigtext___5(ads___7, textdata, envvar);
    }
  }
#line 496
  return;
}
}
#line 508 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int init_begin___5(adns_state *ads_r , adns_initflags flags , adns_logcallbackfn *logfn ,
                          void *logfndata ) 
{ 
  adns_state ads___7 ;
  pid_t pid ;
  void *tmp ;
  int *tmp___0 ;
  adns_query tmp___1 ;
  adns_query tmp___2 ;
  adns_query tmp___3 ;
  adns_query tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __suseconds_t tmp___9 ;

  {
  {
#line 513
  tmp = Hmalloc(sizeof(*ads___7));
#line 513
  ads___7 = (adns_state )tmp;
  }
#line 513
  if (! ads___7) {
    {
#line 513
    tmp___0 = __errno_location();
    }
#line 513
    return (*tmp___0);
  }
  {
#line 515
  ads___7->iflags = flags;
#line 516
  ads___7->logfn = logfn;
#line 517
  ads___7->logfndata = logfndata;
#line 518
  ads___7->configerrno = 0;
#line 519
  tmp___1 = (adns_query )0;
#line 519
  ads___7->udpw.tail = tmp___1;
#line 519
  ads___7->udpw.head = tmp___1;
#line 520
  tmp___2 = (adns_query )0;
#line 520
  ads___7->tcpw.tail = tmp___2;
#line 520
  ads___7->tcpw.head = tmp___2;
#line 521
  tmp___3 = (adns_query )0;
#line 521
  ads___7->childw.tail = tmp___3;
#line 521
  ads___7->childw.head = tmp___3;
#line 522
  tmp___4 = (adns_query )0;
#line 522
  ads___7->output.tail = tmp___4;
#line 522
  ads___7->output.head = tmp___4;
#line 523
  ads___7->forallnext = (adns_query )0;
#line 524
  ads___7->nextid = 12575;
#line 525
  tmp___5 = -1;
#line 525
  ads___7->tcpsocket = tmp___5;
#line 525
  ads___7->udpsocket = tmp___5;
#line 526
  adns__vbuf_init(& ads___7->tcpsend);
#line 527
  adns__vbuf_init(& ads___7->tcprecv);
#line 528
  ads___7->tcprecv_skip = 0;
#line 529
  tmp___8 = 0;
#line 529
  ads___7->tcpserver = tmp___8;
#line 529
  tmp___7 = tmp___8;
#line 529
  ads___7->nsearchlist = tmp___7;
#line 529
  tmp___6 = tmp___7;
#line 529
  ads___7->nsortlist = tmp___6;
#line 529
  ads___7->nservers = tmp___6;
#line 530
  ads___7->searchndots = 1;
#line 531
  ads___7->tcpstate = (enum adns__tcpstate )0;
#line 532
  tmp___9 = (__suseconds_t )0;
#line 532
  ads___7->tcptimeout.tv_usec = tmp___9;
#line 532
  ads___7->tcptimeout.tv_sec = tmp___9;
#line 533
  ads___7->searchlist = (char **)0;
#line 535
  pid = Hgetpid();
#line 536
  ads___7->rand48xsubi[0] = (unsigned short )pid;
#line 537
  ads___7->rand48xsubi[1] = (unsigned short )((unsigned long )pid >> 16);
#line 538
  ads___7->rand48xsubi[2] = (unsigned short )((unsigned long )pid ^ ((unsigned long )pid >> 16));
#line 540
  *ads_r = ads___7;
  }
#line 541
  return (0);
}
}
#line 544 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int init_finish___5(adns_state ads___7 ) 
{ 
  struct in_addr ia ;
  struct protoent *proto ;
  int r ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 549
  if (! ads___7->nservers) {
#line 550
    if (ads___7->logfn) {
#line 550
      if ((unsigned int )ads___7->iflags & 8U) {
        {
#line 551
        adns__lprintf(ads___7, "adns: no nameservers, using localhost\n");
        }
      }
    }
    {
#line 552
    ia.s_addr = htonl((in_addr_t )2130706433);
#line 553
    addserver___5(ads___7, ia);
    }
  }
  {
#line 556
  proto = getprotobyname("udp");
  }
#line 556
  if (! proto) {
#line 556
    r = 92;
#line 556
    goto x_free;
  }
  {
#line 557
  ads___7->udpsocket = Hsocket(2, 2, proto->p_proto);
  }
#line 558
  if (ads___7->udpsocket < 0) {
    {
#line 558
    tmp = __errno_location();
#line 558
    r = *tmp;
    }
#line 558
    goto x_free;
  }
  {
#line 560
  r = adns__setnonblock(ads___7, ads___7->udpsocket);
  }
#line 561
  if (r) {
    {
#line 561
    tmp___0 = __errno_location();
#line 561
    r = *tmp___0;
    }
#line 561
    goto x_closeudp;
  }
#line 563
  return (0);
  x_closeudp: 
  {
#line 566
  Hclose(ads___7->udpsocket);
  }
  x_free: 
  {
#line 568
  Hfree((void *)ads___7);
  }
#line 569
  return (r);
}
}
#line 572 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void init_abort___5(adns_state ads___7 ) 
{ 


  {
#line 573
  if (ads___7->nsearchlist) {
    {
#line 574
    Hfree((void *)*(ads___7->searchlist + 0));
#line 575
    Hfree((void *)ads___7->searchlist);
    }
  }
  {
#line 577
  Hfree((void *)ads___7);
  }
#line 578
  return;
}
}
#line 580 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void logfn_file___5(adns_state ads___7 , void *logfndata , char const   *fmt ,
                           va_list al ) 
{ 


  {
  {
#line 582
  vfprintf((FILE */* __restrict  */)logfndata, (char const   */* __restrict  */)fmt,
           al);
  }
#line 583
  return;
}
}
#line 585 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int init_files___5(adns_state *ads_r , adns_initflags flags , adns_logcallbackfn *logfn ,
                          void *logfndata ) 
{ 
  adns_state ads___7 ;
  char const   *res_options ;
  char const   *adns_res_options ;
  int r ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 591
  r = init_begin___5(& ads___7, flags, logfn, logfndata);
  }
#line 592
  if (r) {
#line 592
    return (r);
  }
  {
#line 594
  res_options = instrum_getenv___5(ads___7, "RES_OPTIONS");
#line 595
  adns_res_options = instrum_getenv___5(ads___7, "ADNS_RES_OPTIONS");
#line 596
  ccf_options___5(ads___7, "RES_OPTIONS", -1, res_options);
#line 597
  ccf_options___5(ads___7, "ADNS_RES_OPTIONS", -1, adns_res_options);
#line 599
  readconfig___5(ads___7, "/etc/resolv.conf", 1);
#line 600
  readconfig___5(ads___7, "/etc/resolv-adns.conf", 0);
#line 601
  readconfigenv___5(ads___7, "RES_CONF");
#line 602
  readconfigenv___5(ads___7, "ADNS_RES_CONF");
#line 604
  readconfigenvtext___5(ads___7, "RES_CONF_TEXT");
#line 605
  readconfigenvtext___5(ads___7, "ADNS_RES_CONF_TEXT");
#line 607
  ccf_options___5(ads___7, "RES_OPTIONS", -1, res_options);
#line 608
  ccf_options___5(ads___7, "ADNS_RES_OPTIONS", -1, adns_res_options);
#line 610
  tmp = instrum_getenv___5(ads___7, "LOCALDOMAIN");
#line 610
  ccf_search___5(ads___7, "LOCALDOMAIN", -1, tmp);
#line 611
  tmp___0 = instrum_getenv___5(ads___7, "ADNS_LOCALDOMAIN");
#line 611
  ccf_search___5(ads___7, "ADNS_LOCALDOMAIN", -1, tmp___0);
  }
#line 613
  if (ads___7->configerrno) {
#line 613
    if (ads___7->configerrno != 22) {
      {
#line 614
      r = ads___7->configerrno;
#line 615
      init_abort___5(ads___7);
      }
#line 616
      return (r);
    }
  }
  {
#line 619
  r = init_finish___5(ads___7);
  }
#line 620
  if (r) {
#line 620
    return (r);
  }
  {
#line 622
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
#line 623
  *ads_r = ads___7;
  }
#line 624
  return (0);
}
}
#line 631 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int init_strcfg___5(adns_state *ads_r , adns_initflags flags , adns_logcallbackfn *logfn ,
                           void *logfndata , char const   *configtext ) 
{ 
  adns_state ads___7 ;
  int r ;

  {
  {
#line 637
  r = init_begin___5(& ads___7, flags, logfn, logfndata);
  }
#line 638
  if (r) {
#line 638
    return (r);
  }
  {
#line 640
  readconfigtext___5(ads___7, configtext, "<supplied configuration text>");
  }
#line 641
  if (ads___7->configerrno) {
    {
#line 642
    r = ads___7->configerrno;
#line 643
    init_abort___5(ads___7);
    }
#line 644
    return (r);
  }
  {
#line 647
  r = init_finish___5(ads___7);
  }
#line 647
  if (r) {
#line 647
    return (r);
  }
  {
#line 648
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
#line 649
  *ads_r = ads___7;
  }
#line 650
  return (0);
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
static vbuf vbw___5  ;
#line 175 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
static void Tvbpollevents___5(int events ) 
{ 
  char const   *delim ;

  {
#line 176
  delim = "";
#line 177
  events &= 7;
#line 178
  if (! events) {
    {
#line 178
    Tvba("0");
    }
#line 178
    return;
  }
#line 179
  if (events & 1) {
    {
#line 179
    Tvba("POLLIN");
#line 179
    delim = "|";
    }
  }
#line 180
  if (events & 4) {
    {
#line 180
    Tvba(delim);
#line 180
    Tvba("POLLOUT");
#line 180
    delim = "|";
    }
  }
#line 181
  if (events & 2) {
    {
#line 181
    Tvba(delim);
#line 181
    Tvba("POLLPRI");
    }
  }
#line 182
  return;
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
static unsigned long malloccount___5  ;
#line 241 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
static unsigned long mallocfailat___5  ;
#line 242 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
static struct __anonstruct_mallocedlist_90___5 mallocedlist___5  ;
#line 9 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hrecord.c"
static FILE *Toutputfile___3  ;
#line 12 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hrecord.c"
static void R_recordtime___2(void) 
{ 
  int r ;
  struct timeval tv ;
  struct timeval tvrel ;

  {
  {
#line 15
  Tensurerecordfile();
#line 16
  r = gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )0);
  }
#line 16
  if (r) {
    {
#line 16
    Tfailed("gettimeofday syscallbegin");
    }
  }
#line 17
  tvrel.tv_sec = tv.tv_sec - currenttime.tv_sec;
#line 18
  tvrel.tv_usec = tv.tv_usec - currenttime.tv_usec;
#line 19
  if (tv.tv_usec < 0L) {
#line 19
    tvrel.tv_usec += 1000000L;
#line 19
    (tvrel.tv_sec) --;
  }
  {
#line 20
  Tvbf("\n +%ld.%06ld", tvrel.tv_sec, tvrel.tv_usec);
#line 21
  currenttime = tv;
  }
#line 22
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hrecord.c"
static void R_vb___2(void) 
{ 


  {
  {
#line 44
  Q_vb();
  }
#line 45
  return;
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_qstring___5(parseinfo const   *pai , int *cbyte_io , int max ,
                                   int *len_r , char **str_r ) 
{ 
  byte const   *dgram ;
  int l ;
  int cbyte___3 ;
  char *str ;
  int tmp ;
  void *tmp___0 ;

  {
#line 92
  dgram = (byte const   *)pai->dgram;
#line 96
  cbyte___3 = *cbyte_io;
#line 98
  if (cbyte___3 >= max) {
#line 98
    return ((adns_status )104);
  }
#line 99
  tmp = cbyte___3;
#line 99
  cbyte___3 ++;
#line 99
  l = (int )((int const   )*(dgram + tmp) & 255);
#line 100
  if (cbyte___3 + l > max) {
#line 100
    return ((adns_status )104);
  }
  {
#line 102
  tmp___0 = adns__alloc_interim((adns_query )pai->qu, (size_t )(l + 1));
#line 102
  str = (char *)tmp___0;
  }
#line 103
  if (! str) {
#line 103
    return ((adns_status )1);
  }
  {
#line 105
  *(str + l) = (char)0;
#line 106
  memcpy((void */* __restrict  */)str, (void const   */* __restrict  */)(dgram + cbyte___3),
         (size_t )l);
#line 108
  *len_r = l;
#line 109
  *str_r = str;
#line 110
  *cbyte_io = cbyte___3 + l;
  }
#line 112
  return ((adns_status )0);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_qstring___5(vbuf *vb___0 , char const   *dp , int len ) 
{ 
  unsigned char ch ;
  char buf___17[10] ;
  int cn ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 120
    tmp = adns__vbuf_appendstr(vb___0, "\"");
    }
#line 120
    if (! tmp) {
#line 120
      return ((adns_status )1);
    }
#line 120
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  cn = 0;
  {
#line 121
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 121
    if (! (cn < len)) {
#line 121
      goto while_break___0;
    }
#line 122
    tmp___0 = dp;
#line 122
    dp ++;
#line 122
    ch = (unsigned char )*tmp___0;
#line 123
    if ((int )ch == 92) {
      {
#line 124
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 124
        tmp___1 = adns__vbuf_appendstr(vb___0, "\\\\");
        }
#line 124
        if (! tmp___1) {
#line 124
          return ((adns_status )1);
        }
#line 124
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else
#line 125
    if ((int )ch == 34) {
      {
#line 126
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 126
        tmp___2 = adns__vbuf_appendstr(vb___0, "\\\"");
        }
#line 126
        if (! tmp___2) {
#line 126
          return ((adns_status )1);
        }
#line 126
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else
#line 127
    if ((int )ch >= 32) {
#line 127
      if ((int )ch <= 126) {
        {
#line 128
        tmp___3 = adns__vbuf_append(vb___0, (byte const   *)(& ch), 1);
        }
#line 128
        if (! tmp___3) {
#line 128
          return ((adns_status )1);
        }
      } else {
#line 127
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 130
      sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"\\x%02x",
              (int )ch);
      }
      {
#line 131
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 131
        tmp___4 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
        }
#line 131
        if (! tmp___4) {
#line 131
          return ((adns_status )1);
        }
#line 131
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 121
    cn ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 134
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 134
    tmp___5 = adns__vbuf_appendstr(vb___0, "\"");
    }
#line 134
    if (! tmp___5) {
#line 134
      return ((adns_status )1);
    }
#line 134
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 136
  return ((adns_status )0);
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_str___5(adns_query qu , void *datap ) 
{ 
  char **rrp ;

  {
  {
#line 144
  rrp = (char **)datap;
#line 146
  adns__makefinal_str(qu, rrp);
  }
#line 147
  return;
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_intstr___5(adns_query qu , void *datap ) 
{ 
  adns_rr_intstr *rrp ;

  {
  {
#line 154
  rrp = (adns_rr_intstr *)datap;
#line 156
  adns__makefinal_str(qu, & rrp->str);
  }
#line 157
  return;
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_manyistr___5(adns_query qu , void *datap ) 
{ 
  adns_rr_intstr **rrp ;
  adns_rr_intstr *te ;
  adns_rr_intstr *table ;
  void *tablev ;
  int tc ;

  {
#line 164
  rrp = (adns_rr_intstr **)datap;
#line 169
  tc = 0;
#line 169
  te = *rrp;
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    if (! (te->i >= 0)) {
#line 169
      goto while_break;
    }
#line 169
    te ++;
#line 169
    tc ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 170
  tablev = (void *)*rrp;
#line 171
  adns__makefinal_block(qu, & tablev, sizeof(*te) * (unsigned long )(tc + 1));
#line 172
  table = (adns_rr_intstr *)tablev;
#line 172
  *rrp = table;
#line 173
  te = *rrp;
  }
  {
#line 173
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 173
    if (! (te->i >= 0)) {
#line 173
      goto while_break___0;
    }
    {
#line 174
    adns__makefinal_str(qu, & te->str);
#line 173
    te ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 175
  return;
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_txt___5(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  adns_rr_intstr **rrp ;
  adns_rr_intstr *table ;
  adns_rr_intstr *te ;
  byte const   *dgram ;
  int ti ;
  int tc ;
  int l ;
  int startbyte ;
  adns_status st ;
  int tmp ;
  void *tmp___0 ;

  {
#line 183
  rrp = (adns_rr_intstr **)datap;
#line 184
  dgram = (byte const   *)pai->dgram;
#line 188
  startbyte = cbyte___3;
#line 189
  if (cbyte___3 >= max) {
#line 189
    return ((adns_status )104);
  }
#line 190
  tc = 0;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! (cbyte___3 < max)) {
#line 191
      goto while_break;
    }
#line 192
    tmp = cbyte___3;
#line 192
    cbyte___3 ++;
#line 192
    l = (int )((int const   )*(dgram + tmp) & 255);
#line 193
    cbyte___3 += l;
#line 194
    tc ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  if (cbyte___3 != max) {
#line 196
    return ((adns_status )104);
  } else
#line 196
  if (! tc) {
#line 196
    return ((adns_status )104);
  }
  {
#line 198
  tmp___0 = adns__alloc_interim((adns_query )pai->qu, sizeof(*table) * (unsigned long )(tc + 1));
#line 198
  table = (adns_rr_intstr *)tmp___0;
  }
#line 199
  if (! table) {
#line 199
    return ((adns_status )1);
  }
#line 201
  cbyte___3 = startbyte;
#line 201
  ti = 0;
#line 201
  te = table;
  {
#line 201
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 201
    if (! (ti < tc)) {
#line 201
      goto while_break___0;
    }
    {
#line 202
    st = pap_qstring___5(pai, & cbyte___3, max, & te->i, & te->str);
    }
#line 203
    if (st) {
#line 203
      return (st);
    }
#line 201
    ti ++;
#line 201
    te ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 205
  if (! (cbyte___3 == max)) {
    {
#line 205
    __assert_fail("cbyte == max", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  205U, "pa_txt");
    }
  }
#line 207
  te->i = -1;
#line 208
  te->str = (char *)0;
#line 210
  *rrp = table;
#line 211
  return ((adns_status )0);
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_txt___5(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_intstr const   * const  *rrp ;
  adns_rr_intstr const   *current ;
  adns_status st ;
  int spc ;
  int tmp ;

  {
#line 215
  rrp = (adns_rr_intstr const   * const  *)datap;
#line 220
  current = (adns_rr_intstr const   *)*rrp;
#line 220
  spc = 0;
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    if (! (current->i >= 0)) {
#line 220
      goto while_break;
    }
#line 221
    if (spc) {
      {
#line 221
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 221
        tmp = adns__vbuf_appendstr(vb___0, " ");
        }
#line 221
        if (! tmp) {
#line 221
          return ((adns_status )1);
        }
#line 221
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 222
    st = csp_qstring___5(vb___0, (char const   *)current->str, (int )current->i);
    }
#line 222
    if (st) {
#line 222
      return (st);
    }
#line 220
    current ++;
#line 220
    spc = 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  return ((adns_status )0);
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_hinfo___5(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_intstrpair const   *rrp ;
  adns_status st ;
  int tmp ;

  {
  {
#line 232
  rrp = (adns_rr_intstrpair const   *)datap;
#line 235
  st = csp_qstring___5(vb___0, (char const   *)rrp->array[0].str, (int )rrp->array[0].i);
  }
#line 235
  if (st) {
#line 235
    return (st);
  }
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 236
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 236
    if (! tmp) {
#line 236
      return ((adns_status )1);
    }
#line 236
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 237
  st = csp_qstring___5(vb___0, (char const   *)rrp->array[1].str, (int )rrp->array[1].i);
  }
#line 237
  if (st) {
#line 237
    return (st);
  }
#line 238
  return ((adns_status )0);
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_inaddr___5(parseinfo const   *pai , int cbyte___3 , int max ,
                                 void *datap ) 
{ 
  struct in_addr *storeto ;

  {
#line 247
  storeto = (struct in_addr *)datap;
#line 249
  if (max - cbyte___3 != 4) {
#line 249
    return ((adns_status )104);
  }
  {
#line 250
  memcpy((void */* __restrict  */)storeto, (void const   */* __restrict  */)(pai->dgram + cbyte___3),
         (size_t )4);
  }
#line 251
  return ((adns_status )0);
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int search_sortlist___5(adns_state ads___7 , struct in_addr ad ) 
{ 
  struct sortlist  const  *slp ;
  int i ;

  {
#line 258
  i = 0;
#line 258
  slp = (struct sortlist  const  *)(ads___7->sortlist);
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 258
    if (i < ads___7->nsortlist) {
#line 258
      if (! (! ((ad.s_addr & (unsigned int )slp->mask.s_addr) == (unsigned int )slp->base.s_addr))) {
#line 258
        goto while_break;
      }
    } else {
#line 258
      goto while_break;
    }
#line 258
    i ++;
#line 258
    slp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  return (i);
}
}
#line 265 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int dip_inaddr___5(adns_state ads___7 , struct in_addr a , struct in_addr b ) 
{ 
  int ai ;
  int bi ;

  {
#line 268
  if (! ads___7->nsortlist) {
#line 268
    return (0);
  }
  {
#line 270
  ai = search_sortlist___5(ads___7, a);
#line 271
  bi = search_sortlist___5(ads___7, b);
  }
#line 272
  return (bi < ai);
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_inaddr___5(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  struct in_addr  const  *ap ;
  struct in_addr  const  *bp ;
  int tmp ;

  {
  {
#line 277
  ap = (struct in_addr  const  *)datap_a;
#line 277
  bp = (struct in_addr  const  *)datap_b;
#line 279
  tmp = dip_inaddr___5(ads___7, (struct in_addr )*ap, (struct in_addr )*bp);
  }
#line 279
  return (tmp);
}
}
#line 282 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_inaddr___5(vbuf *vb___0 , void const   *datap ) 
{ 
  struct in_addr  const  *rrp ;
  struct in_addr rr ;
  char const   *ia ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 283
  rrp = (struct in_addr  const  *)datap;
#line 283
  rr = *rrp;
#line 286
  tmp = inet_ntoa(rr);
#line 286
  ia = (char const   *)tmp;
  }
#line 286
  if (! ia) {
    {
#line 286
    __assert_fail("ia", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  286U, "cs_inaddr");
    }
  }
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 287
    tmp___0 = adns__vbuf_appendstr(vb___0, ia);
    }
#line 287
    if (! tmp___0) {
#line 287
      return ((adns_status )1);
    }
#line 287
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  return ((adns_status )0);
}
}
#line 295 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_addr___5(parseinfo const   *pai , int cbyte___3 , int max ,
                               void *datap ) 
{ 
  adns_rr_addr *storeto ;
  byte const   *dgram ;

  {
#line 297
  storeto = (adns_rr_addr *)datap;
#line 298
  dgram = (byte const   *)pai->dgram;
#line 300
  if (max - cbyte___3 != 4) {
#line 300
    return ((adns_status )104);
  }
  {
#line 301
  storeto->len = (int )sizeof(storeto->addr.inet);
#line 302
  memset((void *)(& storeto->addr), 0, sizeof(storeto->addr.inet));
#line 303
  storeto->addr.inet.sin_family = (sa_family_t )2;
#line 304
  memcpy((void */* __restrict  */)(& storeto->addr.inet.sin_addr), (void const   */* __restrict  */)(dgram + cbyte___3),
         (size_t )4);
  }
#line 305
  return ((adns_status )0);
}
}
#line 308 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_addr___5(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_addr const   *ap ;
  adns_rr_addr const   *bp ;
  int tmp ;

  {
#line 309
  ap = (adns_rr_addr const   *)datap_a;
#line 309
  bp = (adns_rr_addr const   *)datap_b;
#line 311
  if (! ((int const   )ap->addr.sa.sa_family == 2)) {
    {
#line 311
    __assert_fail("ap->addr.sa.sa_family == 2", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  311U, "di_addr");
    }
  }
  {
#line 312
  tmp = dip_inaddr___5(ads___7, (struct in_addr )ap->addr.inet.sin_addr, (struct in_addr )bp->addr.inet.sin_addr);
  }
#line 312
  return (tmp);
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int div_addr___5(void *context , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_state ads___7 ;
  int tmp ;

  {
  {
#line 316
  ads___7 = (adns_state )context;
#line 318
  tmp = di_addr___5(ads___7, datap_a, datap_b);
  }
#line 318
  return (tmp);
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_addr___5(vbuf *vb___0 , adns_rr_addr const   *rrp ) 
{ 
  char const   *ia ;
  char buf___17[30] ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 326
  if ((int const   )rrp->addr.inet.sin_family == 2) {
#line 326
    goto case_2;
  }
#line 331
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 327
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 327
    tmp = adns__vbuf_appendstr(vb___0, "INET ");
    }
#line 327
    if (! tmp) {
#line 327
      return ((adns_status )1);
    }
#line 327
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 328
  tmp___0 = inet_ntoa((struct in_addr )rrp->addr.inet.sin_addr);
#line 328
  ia = (char const   *)tmp___0;
  }
#line 328
  if (! ia) {
    {
#line 328
    __assert_fail("ia", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  328U, "csp_addr");
    }
  }
  {
#line 329
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 329
    tmp___1 = adns__vbuf_appendstr(vb___0, ia);
    }
#line 329
    if (! tmp___1) {
#line 329
      return ((adns_status )1);
    }
#line 329
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 330
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 332
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"AF=%u",
          (int const   )rrp->addr.sa.sa_family);
  }
  {
#line 333
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 333
    tmp___2 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 333
    if (! tmp___2) {
#line 333
      return ((adns_status )1);
    }
#line 333
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 334
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 336
  return ((adns_status )0);
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_addr___5(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_addr const   *rrp ;
  adns_status tmp ;

  {
  {
#line 340
  rrp = (adns_rr_addr const   *)datap;
#line 342
  tmp = csp_addr___5(vb___0, rrp);
  }
#line 342
  return (tmp);
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_domain___5(parseinfo const   *pai , int *cbyte_io , int max ,
                                  char **domain_r , parsedomain_flags flags ) 
{ 
  adns_status st ;
  char *dm ;
  void *tmp ;

  {
  {
#line 355
  st = adns__parse_domain((pai->qu)->ads, (int )pai->serv, (adns_query )pai->qu, & (pai->qu)->vb,
                          flags, (byte const   *)pai->dgram, (int )pai->dglen, cbyte_io,
                          max);
  }
#line 357
  if (st) {
#line 357
    return (st);
  }
#line 358
  if (! (pai->qu)->vb.used) {
#line 358
    return ((adns_status )104);
  }
  {
#line 360
  tmp = adns__alloc_interim((adns_query )pai->qu, (size_t )((pai->qu)->vb.used + 1));
#line 360
  dm = (char *)tmp;
  }
#line 361
  if (! dm) {
#line 361
    return ((adns_status )1);
  }
  {
#line 363
  *(dm + (pai->qu)->vb.used) = (char)0;
#line 364
  memcpy((void */* __restrict  */)dm, (void const   */* __restrict  */)(pai->qu)->vb.buf,
         (size_t )(pai->qu)->vb.used);
#line 366
  *domain_r = dm;
  }
#line 367
  return ((adns_status )0);
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_domain___5(vbuf *vb___0 , char const   *domain ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 371
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 371
    tmp = adns__vbuf_appendstr(vb___0, domain);
    }
#line 371
    if (! tmp) {
#line 371
      return ((adns_status )1);
    }
#line 371
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 372
  if (! *domain) {
    {
#line 372
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 372
      tmp___0 = adns__vbuf_appendstr(vb___0, ".");
      }
#line 372
      if (! tmp___0) {
#line 372
        return ((adns_status )1);
      }
#line 372
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 373
  return ((adns_status )0);
}
}
#line 376 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_domain___5(vbuf *vb___0 , void const   *datap ) 
{ 
  char const   * const  *domainp ;
  adns_status tmp ;

  {
  {
#line 377
  domainp = (char const   * const  *)datap;
#line 378
  tmp = csp_domain___5(vb___0, (char const   *)*domainp);
  }
#line 378
  return (tmp);
}
}
#line 381 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_dom_raw___5(parseinfo const   *pai , int cbyte___3 , int max ,
                                  void *datap ) 
{ 
  char **rrp ;
  adns_status st ;

  {
  {
#line 383
  rrp = (char **)datap;
#line 386
  st = pap_domain___5(pai, & cbyte___3, max, rrp, (parsedomain_flags )1);
  }
#line 387
  if (st) {
#line 387
    return (st);
  }
#line 389
  if (cbyte___3 != max) {
#line 389
    return ((adns_status )104);
  }
#line 390
  return ((adns_status )0);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_host_raw___5(parseinfo const   *pai , int cbyte___3 , int max ,
                                   void *datap ) 
{ 
  char **rrp ;
  adns_status st ;
  int tmp ;

  {
#line 399
  rrp = (char **)datap;
#line 402
  if ((pai->qu)->flags & 64) {
#line 402
    tmp = 1;
  } else {
#line 402
    tmp = 0;
  }
  {
#line 402
  st = pap_domain___5(pai, & cbyte___3, max, rrp, (parsedomain_flags )tmp);
  }
#line 404
  if (st) {
#line 404
    return (st);
  }
#line 406
  if (cbyte___3 != max) {
#line 406
    return ((adns_status )104);
  }
#line 407
  return ((adns_status )0);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_findaddrs___5(parseinfo const   *pai , adns_rr_hostaddr *ha ,
                                     int *cbyte_io , int count , int dmstart ) 
{ 
  int rri ;
  int naddrs ;
  int type ;
  int class ;
  int rdlen ;
  int rdstart ;
  int ownermatched ;
  unsigned long ttl ;
  adns_status st ;
  int tmp ;
  void *tmp___0 ;

  {
#line 421
  rri = 0;
#line 421
  naddrs = -1;
  {
#line 421
  while (1) {
    while_continue: /* CIL Label */ ;
#line 421
    if (! (rri < count)) {
#line 421
      goto while_break;
    }
    {
#line 422
    st = adns__findrr_anychk((adns_query )pai->qu, (int )pai->serv, (byte const   *)pai->dgram,
                             (int )pai->dglen, cbyte_io, & type, & class, & ttl, & rdlen,
                             & rdstart, (byte const   *)pai->dgram, (int )pai->dglen,
                             dmstart, & ownermatched);
    }
#line 426
    if (st) {
#line 426
      return (st);
    }
#line 427
    if (! ownermatched) {
#line 427
      goto _L;
    } else
#line 427
    if (class != 1) {
#line 427
      goto _L;
    } else
#line 427
    if (type != 1) {
      _L: /* CIL Label */ 
#line 428
      if (naddrs > 0) {
#line 428
        goto while_break;
      } else {
#line 428
        goto __Cont;
      }
    }
#line 430
    if (naddrs == -1) {
#line 431
      naddrs = 0;
    }
    {
#line 433
    tmp = adns__vbuf_ensure(& (pai->qu)->vb, (int )((unsigned long )(naddrs + 1) * sizeof(adns_rr_addr )));
    }
#line 433
    if (! tmp) {
#line 434
      return ((adns_status )1);
    }
    {
#line 435
    adns__update_expires((adns_query )pai->qu, ttl, (struct timeval )pai->now);
#line 436
    st = pa_addr___5(pai, rdstart, rdstart + rdlen, (void *)((pai->qu)->vb.buf + (unsigned long )naddrs * sizeof(adns_rr_addr )));
    }
#line 438
    if (st) {
#line 438
      return (st);
    }
#line 439
    naddrs ++;
    __Cont: /* CIL Label */ 
#line 421
    rri ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 441
  if (naddrs >= 0) {
    {
#line 442
    tmp___0 = adns__alloc_interim((adns_query )pai->qu, (unsigned long )naddrs * sizeof(adns_rr_addr ));
#line 442
    ha->addrs = (adns_rr_addr *)tmp___0;
    }
#line 443
    if (! ha->addrs) {
#line 443
      return ((adns_status )1);
    }
    {
#line 444
    memcpy((void */* __restrict  */)ha->addrs, (void const   */* __restrict  */)(pai->qu)->vb.buf,
           (unsigned long )naddrs * sizeof(adns_rr_addr ));
#line 445
    ha->naddrs = naddrs;
#line 446
    ha->astatus = (adns_status )0;
#line 448
    adns__isort((void *)ha->addrs, naddrs, (int )sizeof(adns_rr_addr ), (void *)(pai->qu)->vb.buf,
                & div_addr___5, (void *)pai->ads);
    }
  }
#line 451
  return ((adns_status )0);
}
}
#line 454 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void icb_hostaddr___5(adns_query parent , adns_query child ) 
{ 
  adns_answer *cans ;
  adns_rr_hostaddr *rrp ;
  adns_state ads___7 ;
  adns_status st ;

  {
#line 455
  cans = child->answer;
#line 456
  rrp = child->ctx.info.hostaddr;
#line 457
  ads___7 = parent->ads;
#line 460
  st = cans->status;
#line 461
  rrp->astatus = st;
#line 462
  if ((unsigned int )st > 0U) {
#line 462
    if ((unsigned int )st <= 99U) {
#line 462
      rrp->naddrs = -1;
    } else {
#line 462
      rrp->naddrs = cans->nrrs;
    }
  } else {
#line 462
    rrp->naddrs = cans->nrrs;
  }
  {
#line 463
  rrp->addrs = cans->rrs.addr;
#line 464
  adns__transfer_interim(child, parent, (void *)rrp->addrs, (unsigned long )rrp->naddrs * sizeof(adns_rr_addr ));
  }
#line 467
  if (parent->children.head) {
    {
#line 468
    while (1) {
      while_continue: /* CIL Label */ ;
#line 468
      parent->next = (adns_query )0;
#line 468
      parent->back = ads___7->childw.tail;
#line 468
      if (ads___7->childw.tail) {
#line 468
        (ads___7->childw.tail)->next = parent;
      } else {
#line 468
        ads___7->childw.head = parent;
      }
#line 468
      ads___7->childw.tail = parent;
#line 468
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 470
    adns__query_done(parent);
    }
  }
#line 472
  return;
}
}
#line 474 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_hostaddr___5(parseinfo const   *pai , int *cbyte_io , int max ,
                                    adns_rr_hostaddr *rrp ) 
{ 
  adns_status st ;
  int dmstart ;
  int cbyte___3 ;
  qcontext ctx ;
  int id ;
  adns_query nqu ;
  adns_queryflags nflags ;
  int tmp ;
  typeinfo const   *tmp___0 ;

  {
#line 483
  cbyte___3 = *cbyte_io;
#line 483
  dmstart = cbyte___3;
#line 484
  if ((pai->qu)->flags & 64) {
#line 484
    tmp = 1;
  } else {
#line 484
    tmp = 0;
  }
  {
#line 484
  st = pap_domain___5(pai, & cbyte___3, max, & rrp->host, (parsedomain_flags )tmp);
  }
#line 486
  if (st) {
#line 486
    return (st);
  }
  {
#line 487
  *cbyte_io = cbyte___3;
#line 489
  rrp->astatus = (adns_status )0;
#line 490
  rrp->naddrs = -1;
#line 491
  rrp->addrs = (adns_rr_addr *)0;
#line 493
  cbyte___3 = (int )pai->nsstart;
#line 495
  st = pap_findaddrs___5(pai, rrp, & cbyte___3, (int )pai->nscount, dmstart);
  }
#line 496
  if (st) {
#line 496
    return (st);
  }
#line 497
  if (rrp->naddrs != -1) {
#line 497
    return ((adns_status )0);
  }
  {
#line 499
  st = pap_findaddrs___5(pai, rrp, & cbyte___3, (int )pai->arcount, dmstart);
  }
#line 500
  if (st) {
#line 500
    return (st);
  }
#line 501
  if (rrp->naddrs != -1) {
#line 501
    return ((adns_status )0);
  }
  {
#line 503
  st = adns__mkquery_frdgram((adns_state )pai->ads, & (pai->qu)->vb, & id, (byte const   *)pai->dgram,
                             (int )pai->dglen, dmstart, (adns_rrtype )65537, (adns_queryflags )16);
  }
#line 506
  if (st) {
#line 506
    return (st);
  }
#line 508
  ctx.ext = (void *)0;
#line 509
  ctx.callback = & icb_hostaddr___5;
#line 510
  ctx.info.hostaddr = rrp;
#line 512
  nflags = (adns_queryflags )16;
#line 513
  if (! ((pai->qu)->flags & 256)) {
#line 513
    nflags = (adns_queryflags )((unsigned int )nflags | 512U);
  }
  {
#line 515
  tmp___0 = adns__findtype((adns_rrtype )65537);
#line 515
  st = adns__internal_submit((adns_state )pai->ads, & nqu, tmp___0, & (pai->qu)->vb,
                             id, nflags, (struct timeval )pai->now, (qcontext const   *)(& ctx));
  }
#line 517
  if (st) {
#line 517
    return (st);
  }
#line 519
  nqu->parent = (adns_query )pai->qu;
  {
#line 520
  while (1) {
    while_continue: /* CIL Label */ ;
#line 520
    nqu->siblings.next = (adns_query )0;
#line 520
    nqu->siblings.back = (pai->qu)->children.tail;
#line 520
    if ((pai->qu)->children.tail) {
#line 520
      ((pai->qu)->children.tail)->siblings.next = nqu;
    } else {
#line 520
      (pai->qu)->children.head = nqu;
    }
#line 520
    (pai->qu)->children.tail = nqu;
#line 520
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 522
  return ((adns_status )0);
}
}
#line 525 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_hostaddr___5(parseinfo const   *pai , int cbyte___3 , int max ,
                                   void *datap ) 
{ 
  adns_rr_hostaddr *rrp ;
  adns_status st ;

  {
  {
#line 527
  rrp = (adns_rr_hostaddr *)datap;
#line 530
  st = pap_hostaddr___5(pai, & cbyte___3, max, rrp);
  }
#line 531
  if (st) {
#line 531
    return (st);
  }
#line 532
  if (cbyte___3 != max) {
#line 532
    return ((adns_status )104);
  }
#line 534
  return ((adns_status )0);
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int dip_hostaddr___5(adns_state ads___7 , adns_rr_hostaddr const   *ap , adns_rr_hostaddr const   *bp ) 
{ 
  int tmp ;

  {
#line 539
  if ((unsigned int const   )ap->astatus != (unsigned int const   )bp->astatus) {
#line 539
    return ((int )ap->astatus);
  }
#line 540
  if (ap->astatus) {
#line 540
    return (0);
  }
#line 542
  if (! ((int )(ap->addrs + 0)->addr.sa.sa_family == 2)) {
    {
#line 542
    __assert_fail("ap->addrs[0].addr.sa.sa_family == 2", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  542U, "dip_hostaddr");
    }
  }
#line 543
  if (! ((int )(bp->addrs + 0)->addr.sa.sa_family == 2)) {
    {
#line 543
    __assert_fail("bp->addrs[0].addr.sa.sa_family == 2", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  543U, "dip_hostaddr");
    }
  }
  {
#line 544
  tmp = dip_inaddr___5(ads___7, (ap->addrs + 0)->addr.inet.sin_addr, (bp->addrs + 0)->addr.inet.sin_addr);
  }
#line 544
  return (tmp);
}
}
#line 549 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_hostaddr___5(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_hostaddr const   *ap ;
  adns_rr_hostaddr const   *bp ;
  int tmp ;

  {
  {
#line 551
  ap = (adns_rr_hostaddr const   *)datap_a;
#line 551
  bp = (adns_rr_hostaddr const   *)datap_b;
#line 553
  tmp = dip_hostaddr___5(ads___7, ap, bp);
  }
#line 553
  return (tmp);
}
}
#line 556 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mfp_hostaddr___5(adns_query qu , adns_rr_hostaddr *rrp ) 
{ 
  void *tablev ;

  {
  {
#line 559
  adns__makefinal_str(qu, & rrp->host);
#line 560
  tablev = (void *)rrp->addrs;
#line 561
  adns__makefinal_block(qu, & tablev, (unsigned long )rrp->naddrs * sizeof(*(rrp->addrs)));
#line 562
  rrp->addrs = (adns_rr_addr *)tablev;
  }
#line 563
  return;
}
}
#line 565 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_hostaddr___5(adns_query qu , void *datap ) 
{ 
  adns_rr_hostaddr *rrp ;

  {
  {
#line 566
  rrp = (adns_rr_hostaddr *)datap;
#line 568
  mfp_hostaddr___5(qu, rrp);
  }
#line 569
  return;
}
}
#line 571 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_hostaddr___5(vbuf *vb___0 , adns_rr_hostaddr const   *rrp ) 
{ 
  char const   *errstr ;
  adns_status st ;
  char buf___17[20] ;
  int i ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 577
  st = csp_domain___5(vb___0, (char const   *)rrp->host);
  }
#line 577
  if (st) {
#line 577
    return (st);
  }
  {
#line 579
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 579
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 579
    if (! tmp) {
#line 579
      return ((adns_status )1);
    }
#line 579
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 580
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 580
    tmp___0 = adns_errtypeabbrev((adns_status )rrp->astatus);
#line 580
    tmp___1 = adns__vbuf_appendstr(vb___0, tmp___0);
    }
#line 580
    if (! tmp___1) {
#line 580
      return ((adns_status )1);
    }
#line 580
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 582
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %d ",
          (unsigned int const   )rrp->astatus);
  }
  {
#line 583
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 583
    tmp___2 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 583
    if (! tmp___2) {
#line 583
      return ((adns_status )1);
    }
#line 583
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 585
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 585
    tmp___3 = adns_errabbrev((adns_status )rrp->astatus);
#line 585
    tmp___4 = adns__vbuf_appendstr(vb___0, tmp___3);
    }
#line 585
    if (! tmp___4) {
#line 585
      return ((adns_status )1);
    }
#line 585
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 586
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 586
    tmp___5 = adns__vbuf_appendstr(vb___0, " ");
    }
#line 586
    if (! tmp___5) {
#line 586
      return ((adns_status )1);
    }
#line 586
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 588
  errstr = adns_strerror((adns_status )rrp->astatus);
#line 589
  tmp___6 = strlen(errstr);
#line 589
  st = csp_qstring___5(vb___0, errstr, (int )tmp___6);
  }
#line 589
  if (st) {
#line 589
    return (st);
  }
#line 591
  if (rrp->naddrs >= 0) {
    {
#line 592
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 592
      tmp___7 = adns__vbuf_appendstr(vb___0, " (");
      }
#line 592
      if (! tmp___7) {
#line 592
        return ((adns_status )1);
      }
#line 592
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 593
    i = 0;
    {
#line 593
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 593
      if (! (i < (int )rrp->naddrs)) {
#line 593
        goto while_break___5;
      }
      {
#line 594
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 594
        tmp___8 = adns__vbuf_appendstr(vb___0, " ");
        }
#line 594
        if (! tmp___8) {
#line 594
          return ((adns_status )1);
        }
#line 594
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 595
      st = csp_addr___5(vb___0, (adns_rr_addr const   *)(rrp->addrs + i));
#line 593
      i ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 597
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 597
      tmp___9 = adns__vbuf_appendstr(vb___0, " )");
      }
#line 597
      if (! tmp___9) {
#line 597
        return ((adns_status )1);
      }
#line 597
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
  } else {
    {
#line 599
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 599
      tmp___10 = adns__vbuf_appendstr(vb___0, " ?");
      }
#line 599
      if (! tmp___10) {
#line 599
        return ((adns_status )1);
      }
#line 599
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
#line 601
  return ((adns_status )0);
}
}
#line 604 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_hostaddr___5(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_hostaddr const   *rrp ;
  adns_status tmp ;

  {
  {
#line 605
  rrp = (adns_rr_hostaddr const   *)datap;
#line 607
  tmp = csp_hostaddr___5(vb___0, rrp);
  }
#line 607
  return (tmp);
}
}
#line 614 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_mx_raw___5(parseinfo const   *pai , int cbyte___3 , int max ,
                                 void *datap ) 
{ 
  byte const   *dgram ;
  adns_rr_intstr *rrp ;
  adns_status st ;
  int pref ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 616
  dgram = (byte const   *)pai->dgram;
#line 617
  rrp = (adns_rr_intstr *)datap;
#line 621
  if (cbyte___3 + 2 > max) {
#line 621
    return ((adns_status )104);
  }
#line 622
  pref = 0;
#line 622
  tmp = cbyte___3;
#line 622
  cbyte___3 ++;
#line 622
  pref |= (int )(((int const   )*(dgram + tmp) & 255) << 8);
#line 622
  tmp___0 = cbyte___3;
#line 622
  cbyte___3 ++;
#line 622
  pref |= (int )((int const   )*(dgram + tmp___0) & 255);
#line 623
  rrp->i = pref;
#line 624
  if ((pai->qu)->flags & 64) {
#line 624
    tmp___1 = 1;
  } else {
#line 624
    tmp___1 = 0;
  }
  {
#line 624
  st = pap_domain___5(pai, & cbyte___3, max, & rrp->str, (parsedomain_flags )tmp___1);
  }
#line 626
  if (st) {
#line 626
    return (st);
  }
#line 628
  if (cbyte___3 != max) {
#line 628
    return ((adns_status )104);
  }
#line 629
  return ((adns_status )0);
}
}
#line 632 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_mx_raw___5(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_intstr const   *ap ;
  adns_rr_intstr const   *bp ;

  {
#line 633
  ap = (adns_rr_intstr const   *)datap_a;
#line 633
  bp = (adns_rr_intstr const   *)datap_b;
#line 635
  if (ap->i < bp->i) {
#line 635
    return (0);
  }
#line 636
  if (ap->i > bp->i) {
#line 636
    return (1);
  }
#line 637
  return (0);
}
}
#line 644 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_mx___5(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  byte const   *dgram ;
  adns_rr_inthostaddr *rrp ;
  adns_status st ;
  int pref ;
  int tmp ;
  int tmp___0 ;

  {
#line 646
  dgram = (byte const   *)pai->dgram;
#line 647
  rrp = (adns_rr_inthostaddr *)datap;
#line 651
  if (cbyte___3 + 2 > max) {
#line 651
    return ((adns_status )104);
  }
  {
#line 652
  pref = 0;
#line 652
  tmp = cbyte___3;
#line 652
  cbyte___3 ++;
#line 652
  pref |= (int )(((int const   )*(dgram + tmp) & 255) << 8);
#line 652
  tmp___0 = cbyte___3;
#line 652
  cbyte___3 ++;
#line 652
  pref |= (int )((int const   )*(dgram + tmp___0) & 255);
#line 653
  rrp->i = pref;
#line 654
  st = pap_hostaddr___5(pai, & cbyte___3, max, & rrp->ha);
  }
#line 655
  if (st) {
#line 655
    return (st);
  }
#line 657
  if (cbyte___3 != max) {
#line 657
    return ((adns_status )104);
  }
#line 658
  return ((adns_status )0);
}
}
#line 661 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_mx___5(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_inthostaddr const   *ap ;
  adns_rr_inthostaddr const   *bp ;
  int tmp ;

  {
#line 662
  ap = (adns_rr_inthostaddr const   *)datap_a;
#line 662
  bp = (adns_rr_inthostaddr const   *)datap_b;
#line 664
  if (ap->i < bp->i) {
#line 664
    return (0);
  }
#line 665
  if (ap->i > bp->i) {
#line 665
    return (1);
  }
  {
#line 666
  tmp = dip_hostaddr___5(ads___7, & ap->ha, & bp->ha);
  }
#line 666
  return (tmp);
}
}
#line 673 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_inthostaddr___5(adns_query qu , void *datap ) 
{ 
  adns_rr_inthostaddr *rrp ;

  {
  {
#line 674
  rrp = (adns_rr_inthostaddr *)datap;
#line 676
  mfp_hostaddr___5(qu, & rrp->ha);
  }
#line 677
  return;
}
}
#line 679 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_inthostaddr___5(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_inthostaddr const   *rrp ;
  char buf___17[10] ;
  int tmp ;
  adns_status tmp___0 ;

  {
  {
#line 680
  rrp = (adns_rr_inthostaddr const   *)datap;
#line 683
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"%u ",
          rrp->i);
  }
  {
#line 684
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 684
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 684
    if (! tmp) {
#line 684
      return ((adns_status )1);
    }
#line 684
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 686
  tmp___0 = csp_hostaddr___5(vb___0, & rrp->ha);
  }
#line 686
  return (tmp___0);
}
}
#line 693 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_inthost___5(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_intstr const   *rrp ;
  char buf___17[10] ;
  int tmp ;
  adns_status tmp___0 ;

  {
  {
#line 694
  rrp = (adns_rr_intstr const   *)datap;
#line 697
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"%u ",
          rrp->i);
  }
  {
#line 698
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 698
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 698
    if (! tmp) {
#line 698
      return ((adns_status )1);
    }
#line 698
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 699
  tmp___0 = csp_domain___5(vb___0, (char const   *)rrp->str);
  }
#line 699
  return (tmp___0);
}
}
#line 706 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void icb_ptr___5(adns_query parent , adns_query child ) 
{ 
  adns_answer *cans ;
  adns_rr_addr const   *queried ;
  adns_rr_addr const   *found ;
  adns_state ads___7 ;
  int i ;
  int tmp ;

  {
#line 707
  cans = child->answer;
#line 709
  ads___7 = parent->ads;
#line 712
  if ((unsigned int )cans->status == 300U) {
    {
#line 713
    adns__query_fail(parent, (adns_status )100);
    }
#line 714
    return;
  } else
#line 712
  if ((unsigned int )cans->status == 301U) {
    {
#line 713
    adns__query_fail(parent, (adns_status )100);
    }
#line 714
    return;
  } else
#line 715
  if (cans->status) {
    {
#line 716
    adns__query_fail(parent, cans->status);
    }
#line 717
    return;
  }
#line 720
  queried = (adns_rr_addr const   *)(& parent->ctx.info.ptr_parent_addr);
#line 721
  i = 0;
#line 721
  found = (adns_rr_addr const   *)cans->rrs.addr;
  {
#line 721
  while (1) {
    while_continue: /* CIL Label */ ;
#line 721
    if (! (i < cans->nrrs)) {
#line 721
      goto while_break;
    }
#line 722
    if (queried->len == found->len) {
      {
#line 722
      tmp = memcmp((void const   *)(& queried->addr), (void const   *)(& found->addr),
                   (size_t )queried->len);
      }
#line 722
      if (! tmp) {
#line 724
        if (! parent->children.head) {
          {
#line 725
          adns__query_done(parent);
          }
#line 726
          return;
        } else {
          {
#line 728
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 728
            parent->next = (adns_query )0;
#line 728
            parent->back = ads___7->childw.tail;
#line 728
            if (ads___7->childw.tail) {
#line 728
              (ads___7->childw.tail)->next = parent;
            } else {
#line 728
              ads___7->childw.head = parent;
            }
#line 728
            ads___7->childw.tail = parent;
#line 728
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 729
          return;
        }
      }
    }
#line 721
    i ++;
#line 721
    found ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 734
  adns__query_fail(parent, (adns_status )100);
  }
#line 735
  return;
}
}
#line 739
static adns_status pa_ptr___5(parseinfo const   *pai , int dmstart , int max , void *datap ) ;
#line 739 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static char const   * const  expectdomain___5[2]  = {      (char const   */* const  */)"in-addr",      (char const   */* const  */)"arpa"};
#line 737 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_ptr___5(parseinfo const   *pai , int dmstart , int max , void *datap ) 
{ 
  char **rrp ;
  adns_status st ;
  adns_rr_addr *ap ;
  findlabel_state fls ;
  char *ep ;
  byte ipv[4] ;
  char labbuf[4] ;
  int cbyte___3 ;
  int i ;
  int lablen ;
  int labstart ;
  int l ;
  int id ;
  adns_query nqu ;
  qcontext ctx ;
  int tmp ;
  unsigned long tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  typeinfo const   *tmp___3 ;

  {
#line 741
  rrp = (char **)datap;
#line 752
  cbyte___3 = dmstart;
#line 753
  if ((pai->qu)->flags & 64) {
#line 753
    tmp = 1;
  } else {
#line 753
    tmp = 0;
  }
  {
#line 753
  st = pap_domain___5(pai, & cbyte___3, max, rrp, (parsedomain_flags )tmp);
  }
#line 755
  if (st) {
#line 755
    return (st);
  }
#line 756
  if (cbyte___3 != max) {
#line 756
    return ((adns_status )104);
  }
#line 758
  ap = & (pai->qu)->ctx.info.ptr_parent_addr;
#line 759
  if (! ap->len) {
    {
#line 760
    adns__findlabel_start(& fls, (adns_state )pai->ads, -1, (adns_query )pai->qu,
                          (byte const   *)(pai->qu)->query_dgram, (pai->qu)->query_dglen,
                          (pai->qu)->query_dglen, 12, (int *)0);
#line 763
    i = 0;
    }
    {
#line 763
    while (1) {
      while_continue: /* CIL Label */ ;
#line 763
      if (! (i < 4)) {
#line 763
        goto while_break;
      }
      {
#line 764
      st = adns__findlabel_next(& fls, & lablen, & labstart);
      }
#line 764
      if (! (! st)) {
        {
#line 764
        __assert_fail("!st", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                      764U, "pa_ptr");
        }
      }
#line 765
      if (lablen <= 0) {
#line 765
        return ((adns_status )200);
      } else
#line 765
      if (lablen > 3) {
#line 765
        return ((adns_status )200);
      }
      {
#line 766
      memcpy((void */* __restrict  */)(labbuf), (void const   */* __restrict  */)((pai->qu)->query_dgram + labstart),
             (size_t )lablen);
#line 767
      labbuf[lablen] = (char)0;
#line 768
      tmp___0 = strtoul((char const   */* __restrict  */)(labbuf), (char **/* __restrict  */)(& ep),
                        10);
#line 768
      ipv[3 - i] = (byte )tmp___0;
      }
#line 769
      if (*ep) {
#line 769
        return ((adns_status )200);
      }
#line 770
      if (lablen > 1) {
#line 770
        if ((int )*((pai->qu)->query_dgram + labstart) == 48) {
#line 771
          return ((adns_status )200);
        }
      }
#line 763
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 773
    i = 0;
    {
#line 773
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 773
      if (! ((unsigned long )i < sizeof(expectdomain___5) / sizeof(expectdomain___5[0]))) {
#line 773
        goto while_break___0;
      }
      {
#line 774
      st = adns__findlabel_next(& fls, & lablen, & labstart);
      }
#line 774
      if (! (! st)) {
        {
#line 774
        __assert_fail("!st", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                      774U, "pa_ptr");
        }
      }
      {
#line 775
      tmp___1 = strlen((char const   *)expectdomain___5[i]);
#line 775
      l = (int )tmp___1;
      }
#line 776
      if (lablen != l) {
#line 778
        return ((adns_status )200);
      } else {
        {
#line 776
        tmp___2 = memcmp((void const   *)((pai->qu)->query_dgram + labstart), (void const   *)expectdomain___5[i],
                         (size_t )l);
        }
#line 776
        if (tmp___2) {
#line 778
          return ((adns_status )200);
        }
      }
#line 773
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 780
    st = adns__findlabel_next(& fls, & lablen, (int *)0);
    }
#line 780
    if (! (! st)) {
      {
#line 780
      __assert_fail("!st", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                    780U, "pa_ptr");
      }
    }
#line 781
    if (lablen) {
#line 781
      return ((adns_status )200);
    }
    {
#line 783
    ap->len = (int )sizeof(struct sockaddr_in );
#line 784
    memset((void *)(& ap->addr), 0, sizeof(ap->addr.inet));
#line 785
    ap->addr.inet.sin_family = (sa_family_t )2;
#line 786
    ap->addr.inet.sin_addr.s_addr = htonl((uint32_t )(((((int )ipv[0] << 24) | ((int )ipv[1] << 16)) | ((int )ipv[2] << 8)) | (int )ipv[3]));
    }
  }
  {
#line 790
  st = adns__mkquery_frdgram((adns_state )pai->ads, & (pai->qu)->vb, & id, (byte const   *)pai->dgram,
                             (int )pai->dglen, dmstart, (adns_rrtype )65537, (adns_queryflags )16);
  }
#line 793
  if (st) {
#line 793
    return (st);
  }
  {
#line 795
  ctx.ext = (void *)0;
#line 796
  ctx.callback = & icb_ptr___5;
#line 797
  memset((void *)(& ctx.info), 0, sizeof(ctx.info));
#line 798
  tmp___3 = adns__findtype((adns_rrtype )65537);
#line 798
  st = adns__internal_submit((adns_state )pai->ads, & nqu, tmp___3, & (pai->qu)->vb,
                             id, (adns_queryflags )16, (struct timeval )pai->now,
                             (qcontext const   *)(& ctx));
  }
#line 801
  if (st) {
#line 801
    return (st);
  }
#line 803
  nqu->parent = (adns_query )pai->qu;
  {
#line 804
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 804
    nqu->siblings.next = (adns_query )0;
#line 804
    nqu->siblings.back = (pai->qu)->children.tail;
#line 804
    if ((pai->qu)->children.tail) {
#line 804
      ((pai->qu)->children.tail)->siblings.next = nqu;
    } else {
#line 804
      (pai->qu)->children.head = nqu;
    }
#line 804
    (pai->qu)->children.tail = nqu;
#line 804
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 805
  return ((adns_status )0);
}
}
#line 812 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_strpair___5(adns_query qu , void *datap ) 
{ 
  adns_rr_strpair *rrp ;

  {
  {
#line 813
  rrp = (adns_rr_strpair *)datap;
#line 815
  adns__makefinal_str(qu, & rrp->array[0]);
#line 816
  adns__makefinal_str(qu, & rrp->array[1]);
  }
#line 817
  return;
}
}
#line 823 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_intstrpair___5(adns_query qu , void *datap ) 
{ 
  adns_rr_intstrpair *rrp ;

  {
  {
#line 824
  rrp = (adns_rr_intstrpair *)datap;
#line 826
  adns__makefinal_str(qu, & rrp->array[0].str);
#line 827
  adns__makefinal_str(qu, & rrp->array[1].str);
  }
#line 828
  return;
}
}
#line 834 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_hinfo___5(parseinfo const   *pai , int cbyte___3 , int max ,
                                void *datap ) 
{ 
  adns_rr_intstrpair *rrp ;
  adns_status st ;
  int i ;

  {
#line 836
  rrp = (adns_rr_intstrpair *)datap;
#line 840
  i = 0;
  {
#line 840
  while (1) {
    while_continue: /* CIL Label */ ;
#line 840
    if (! (i < 2)) {
#line 840
      goto while_break;
    }
    {
#line 841
    st = pap_qstring___5(pai, & cbyte___3, max, & rrp->array[i].i, & rrp->array[i].str);
    }
#line 842
    if (st) {
#line 842
      return (st);
    }
#line 840
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 845
  if (cbyte___3 != max) {
#line 845
    return ((adns_status )104);
  }
#line 847
  return ((adns_status )0);
}
}
#line 854 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_mailbox822___5(parseinfo const   *pai , int *cbyte_io , int max ,
                                      char **mb_r ) 
{ 
  int lablen ;
  int labstart ;
  int i ;
  int needquote ;
  int c ;
  int r ;
  int neednorm ;
  unsigned char const   *p ;
  char *str ;
  findlabel_state fls ;
  adns_status st ;
  vbuf *vb___0 ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 863
  vb___0 = & (pai->qu)->vb;
#line 864
  vb___0->used = 0;
#line 865
  adns__findlabel_start(& fls, (adns_state )pai->ads, -1, (adns_query )pai->qu, (byte const   *)pai->dgram,
                        (int )pai->dglen, max, *cbyte_io, cbyte_io);
#line 869
  st = adns__findlabel_next(& fls, & lablen, & labstart);
  }
#line 870
  if (! lablen) {
    {
#line 871
    adns__vbuf_appendstr(vb___0, ".");
    }
#line 872
    goto x_ok;
  }
#line 875
  neednorm = 1;
#line 876
  i = 0;
#line 876
  needquote = 0;
#line 876
  p = (unsigned char const   *)(pai->dgram + labstart);
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (! (i < lablen)) {
#line 876
      goto while_break;
    }
#line 877
    tmp = p;
#line 877
    p ++;
#line 877
    c = (int )*tmp;
#line 878
    if ((c & -129) < 32) {
#line 878
      return ((adns_status )104);
    } else
#line 878
    if ((c & -129) == 127) {
#line 878
      return ((adns_status )104);
    }
#line 879
    if (c == 46) {
#line 879
      if (! neednorm) {
#line 879
        neednorm = 1;
      } else {
#line 879
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 880
    if (c == 32) {
#line 880
      needquote ++;
    } else
#line 880
    if (c >= 127) {
#line 880
      needquote ++;
    } else {
      {
#line 880
      tmp___0 = ctype_822special(c);
      }
#line 880
      if (tmp___0) {
#line 880
        needquote ++;
      } else {
#line 881
        neednorm = 0;
      }
    }
#line 876
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 884
  if (needquote) {
#line 884
    goto _L___0;
  } else
#line 884
  if (neednorm) {
    _L___0: /* CIL Label */ 
    {
#line 885
    r = adns__vbuf_ensure(vb___0, (lablen + needquote) + 4);
    }
#line 885
    if (! r) {
#line 885
      return ((adns_status )1);
    }
    {
#line 886
    adns__vbuf_appendq(vb___0, (byte const   *)"\"", 1);
#line 887
    i = 0;
#line 887
    needquote = 0;
#line 887
    p = (unsigned char const   *)(pai->dgram + labstart);
    }
    {
#line 887
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 887
      if (! (i < lablen)) {
#line 887
        goto while_break___0;
      }
#line 888
      c = (int )*p;
#line 889
      if (c == 34) {
        {
#line 889
        adns__vbuf_appendq(vb___0, (byte const   *)"\\", 1);
        }
      } else
#line 889
      if (c == 92) {
        {
#line 889
        adns__vbuf_appendq(vb___0, (byte const   *)"\\", 1);
        }
      }
      {
#line 890
      adns__vbuf_appendq(vb___0, p, 1);
#line 887
      i ++;
#line 887
      p ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 892
    adns__vbuf_appendq(vb___0, (byte const   *)"\"", 1);
    }
  } else {
    {
#line 894
    r = adns__vbuf_append(vb___0, (byte const   *)(pai->dgram + labstart), lablen);
    }
#line 894
    if (! r) {
#line 894
      return ((adns_status )1);
    }
  }
  {
#line 897
  r = adns__vbuf_appendstr(vb___0, "@");
  }
#line 897
  if (! r) {
#line 897
    return ((adns_status )1);
  }
  {
#line 899
  st = adns__parse_domain_more(& fls, (adns_state )pai->ads, (adns_query )pai->qu,
                               vb___0, (parsedomain_flags )0, (byte const   *)pai->dgram);
  }
#line 900
  if (st) {
#line 900
    return (st);
  }
  x_ok: 
  {
#line 903
  tmp___1 = adns__alloc_interim((adns_query )pai->qu, (size_t )(vb___0->used + 1));
#line 903
  str = (char *)tmp___1;
  }
#line 903
  if (! str) {
#line 903
    return ((adns_status )1);
  }
  {
#line 904
  memcpy((void */* __restrict  */)str, (void const   */* __restrict  */)vb___0->buf,
         (size_t )vb___0->used);
#line 905
  *(str + vb___0->used) = (char)0;
#line 906
  *mb_r = str;
  }
#line 907
  return ((adns_status )0);
}
}
#line 910 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_mailbox___5(parseinfo const   *pai , int *cbyte_io , int max ,
                                   char **mb_r ) 
{ 
  adns_status tmp ;
  adns_status tmp___0 ;

  {
#line 912
  if ((unsigned int const   )((pai->qu)->typei)->typekey & 131072U) {
    {
#line 913
    tmp = pap_mailbox822___5(pai, cbyte_io, max, mb_r);
    }
#line 913
    return (tmp);
  } else {
    {
#line 915
    tmp___0 = pap_domain___5(pai, cbyte_io, max, mb_r, (parsedomain_flags )1);
    }
#line 915
    return (tmp___0);
  }
}
}
#line 919 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_mailbox___5(vbuf *vb___0 , char const   *mailbox ) 
{ 
  adns_status tmp ;

  {
  {
#line 920
  tmp = csp_domain___5(vb___0, mailbox);
  }
#line 920
  return (tmp);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_rp___5(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  adns_rr_strpair *rrp ;
  adns_status st ;

  {
  {
#line 929
  rrp = (adns_rr_strpair *)datap;
#line 932
  st = pap_mailbox___5(pai, & cbyte___3, max, & rrp->array[0]);
  }
#line 933
  if (st) {
#line 933
    return (st);
  }
  {
#line 935
  st = pap_domain___5(pai, & cbyte___3, max, & rrp->array[1], (parsedomain_flags )1);
  }
#line 936
  if (st) {
#line 936
    return (st);
  }
#line 938
  if (cbyte___3 != max) {
#line 938
    return ((adns_status )104);
  }
#line 939
  return ((adns_status )0);
}
}
#line 942 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_rp___5(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_strpair const   *rrp ;
  adns_status st ;
  int tmp ;

  {
  {
#line 943
  rrp = (adns_rr_strpair const   *)datap;
#line 946
  st = csp_mailbox___5(vb___0, (char const   *)rrp->array[0]);
  }
#line 946
  if (st) {
#line 946
    return (st);
  }
  {
#line 947
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 947
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 947
    if (! tmp) {
#line 947
      return ((adns_status )1);
    }
#line 947
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 948
  st = csp_domain___5(vb___0, (char const   *)rrp->array[1]);
  }
#line 948
  if (st) {
#line 948
    return (st);
  }
#line 950
  return ((adns_status )0);
}
}
#line 957 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_soa___5(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  adns_rr_soa *rrp ;
  byte const   *dgram ;
  adns_status st ;
  int msw ;
  int lsw ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 959
  rrp = (adns_rr_soa *)datap;
#line 960
  dgram = (byte const   *)pai->dgram;
#line 964
  if ((pai->qu)->flags & 64) {
#line 964
    tmp = 1;
  } else {
#line 964
    tmp = 0;
  }
  {
#line 964
  st = pap_domain___5(pai, & cbyte___3, max, & rrp->mname, (parsedomain_flags )tmp);
  }
#line 966
  if (st) {
#line 966
    return (st);
  }
  {
#line 968
  st = pap_mailbox___5(pai, & cbyte___3, max, & rrp->rname);
  }
#line 969
  if (st) {
#line 969
    return (st);
  }
#line 971
  if (cbyte___3 + 20 != max) {
#line 971
    return ((adns_status )104);
  }
#line 973
  i = 0;
  {
#line 973
  while (1) {
    while_continue: /* CIL Label */ ;
#line 973
    if (! (i < 5)) {
#line 973
      goto while_break;
    }
#line 974
    msw = 0;
#line 974
    tmp___0 = cbyte___3;
#line 974
    cbyte___3 ++;
#line 974
    msw |= (int )(((int const   )*(dgram + tmp___0) & 255) << 8);
#line 974
    tmp___1 = cbyte___3;
#line 974
    cbyte___3 ++;
#line 974
    msw |= (int )((int const   )*(dgram + tmp___1) & 255);
#line 975
    lsw = 0;
#line 975
    tmp___2 = cbyte___3;
#line 975
    cbyte___3 ++;
#line 975
    lsw |= (int )(((int const   )*(dgram + tmp___2) & 255) << 8);
#line 975
    tmp___3 = cbyte___3;
#line 975
    cbyte___3 ++;
#line 975
    lsw |= (int )((int const   )*(dgram + tmp___3) & 255);
#line 976
    *(& rrp->serial + i) = (unsigned long )((msw << 16) | lsw);
#line 973
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 979
  return ((adns_status )0);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_soa___5(adns_query qu , void *datap ) 
{ 
  adns_rr_soa *rrp ;

  {
  {
#line 983
  rrp = (adns_rr_soa *)datap;
#line 985
  adns__makefinal_str(qu, & rrp->mname);
#line 986
  adns__makefinal_str(qu, & rrp->rname);
  }
#line 987
  return;
}
}
#line 989 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_soa___5(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_soa const   *rrp ;
  char buf___17[20] ;
  int i ;
  adns_status st ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 990
  rrp = (adns_rr_soa const   *)datap;
#line 995
  st = csp_domain___5(vb___0, (char const   *)rrp->mname);
  }
#line 995
  if (st) {
#line 995
    return (st);
  }
  {
#line 996
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 996
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 996
    if (! tmp) {
#line 996
      return ((adns_status )1);
    }
#line 996
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 997
  st = csp_mailbox___5(vb___0, (char const   *)rrp->rname);
  }
#line 997
  if (st) {
#line 997
    return (st);
  }
#line 999
  i = 0;
  {
#line 999
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 999
    if (! (i < 5)) {
#line 999
      goto while_break___0;
    }
    {
#line 1000
    sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %lu",
            *(& rrp->serial + i));
    }
    {
#line 1001
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1001
      tmp___0 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
      }
#line 1001
      if (! tmp___0) {
#line 1001
        return ((adns_status )1);
      }
#line 1001
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 999
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1004
  return ((adns_status )0);
}
}
#line 1011 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status qdpl_srv___5(adns_state ads___7 , char const   **p_io , char const   *pe ,
                                int labelnum , char *label_r , int *ll_io , adns_queryflags flags ,
                                typeinfo const   *typei ) 
{ 
  int useflags ;
  char const   *p_orig ;
  adns_status st ;
  int ll ;
  void *tmp ;

  {
#line 1020
  if (labelnum < 2) {
#line 1020
    if (! ((unsigned int )flags & 16U)) {
#line 1021
      useflags = 16;
#line 1022
      p_orig = *p_io;
    } else {
#line 1024
      useflags = (int )flags;
#line 1025
      p_orig = (char const   *)0;
    }
  } else {
#line 1024
    useflags = (int )flags;
#line 1025
    p_orig = (char const   *)0;
  }
  {
#line 1027
  st = adns__qdpl_normal(ads___7, p_io, pe, labelnum, (char *)label_r, ll_io, (adns_queryflags )useflags,
                         typei);
  }
#line 1028
  if (st) {
#line 1028
    return (st);
  }
#line 1030
  if (p_orig) {
#line 1031
    ll = *ll_io;
#line 1032
    if (! ll) {
#line 1033
      return ((adns_status )201);
    } else
#line 1032
    if ((int )*(label_r + 0) != 95) {
#line 1033
      return ((adns_status )201);
    }
    {
#line 1034
    tmp = memchr((void const   *)(p_orig + 1), '\\', (size_t )(pe - (p_orig + 1)));
    }
#line 1034
    if (tmp) {
#line 1035
      return ((adns_status )201);
    }
  }
#line 1037
  return ((adns_status )0);
}
}
#line 1040 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_srv_begin___5(parseinfo const   *pai , int *cbyte_io , int max ,
                                     adns_rr_srvha *rrp ) 
{ 
  byte const   *dgram ;
  int ti ;
  int cbyte___3 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1043
  dgram = (byte const   *)pai->dgram;
#line 1046
  cbyte___3 = *cbyte_io;
#line 1047
  tmp = *cbyte_io + 6;
#line 1047
  *cbyte_io = tmp;
#line 1047
  if (tmp > max) {
#line 1047
    return ((adns_status )104);
  }
#line 1049
  ti = 0;
#line 1049
  tmp___0 = cbyte___3;
#line 1049
  cbyte___3 ++;
#line 1049
  ti |= (int )(((int const   )*(dgram + tmp___0) & 255) << 8);
#line 1049
  tmp___1 = cbyte___3;
#line 1049
  cbyte___3 ++;
#line 1049
  ti |= (int )((int const   )*(dgram + tmp___1) & 255);
#line 1049
  rrp->priority = ti;
#line 1050
  ti = 0;
#line 1050
  tmp___2 = cbyte___3;
#line 1050
  cbyte___3 ++;
#line 1050
  ti |= (int )(((int const   )*(dgram + tmp___2) & 255) << 8);
#line 1050
  tmp___3 = cbyte___3;
#line 1050
  cbyte___3 ++;
#line 1050
  ti |= (int )((int const   )*(dgram + tmp___3) & 255);
#line 1050
  rrp->weight = ti;
#line 1051
  ti = 0;
#line 1051
  tmp___4 = cbyte___3;
#line 1051
  cbyte___3 ++;
#line 1051
  ti |= (int )(((int const   )*(dgram + tmp___4) & 255) << 8);
#line 1051
  tmp___5 = cbyte___3;
#line 1051
  cbyte___3 ++;
#line 1051
  ti |= (int )((int const   )*(dgram + tmp___5) & 255);
#line 1051
  rrp->port = ti;
#line 1052
  return ((adns_status )0);
}
}
#line 1055 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_srvraw___5(parseinfo const   *pai , int cbyte___3 , int max ,
                                 void *datap ) 
{ 
  adns_rr_srvraw *rrp ;
  adns_status st ;
  int tmp ;

  {
  {
#line 1057
  rrp = (adns_rr_srvraw *)datap;
#line 1060
  st = pap_srv_begin___5(pai, & cbyte___3, max, (adns_rr_srvha *)datap);
  }
#line 1061
  if (st) {
#line 1061
    return (st);
  }
#line 1063
  if ((pai->qu)->flags & 64) {
#line 1063
    tmp = 1;
  } else {
#line 1063
    tmp = 0;
  }
  {
#line 1063
  st = pap_domain___5(pai, & cbyte___3, max, & rrp->host, (parsedomain_flags )tmp);
  }
#line 1065
  if (st) {
#line 1065
    return (st);
  }
#line 1067
  if (cbyte___3 != max) {
#line 1067
    return ((adns_status )104);
  }
#line 1068
  return ((adns_status )0);
}
}
#line 1071 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_srvha___5(parseinfo const   *pai , int cbyte___3 , int max ,
                                void *datap ) 
{ 
  adns_rr_srvha *rrp ;
  adns_status st ;

  {
  {
#line 1073
  rrp = (adns_rr_srvha *)datap;
#line 1076
  st = pap_srv_begin___5(pai, & cbyte___3, max, (adns_rr_srvha *)datap);
  }
#line 1076
  if (st) {
#line 1076
    return (st);
  }
  {
#line 1077
  st = pap_hostaddr___5(pai, & cbyte___3, max, & rrp->ha);
  }
#line 1077
  if (st) {
#line 1077
    return (st);
  }
#line 1078
  if (cbyte___3 != max) {
#line 1078
    return ((adns_status )104);
  }
#line 1079
  return ((adns_status )0);
}
}
#line 1082 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_srvraw___5(adns_query qu , void *datap ) 
{ 
  adns_rr_srvraw *rrp ;

  {
  {
#line 1083
  rrp = (adns_rr_srvraw *)datap;
#line 1084
  adns__makefinal_str(qu, & rrp->host);
  }
#line 1085
  return;
}
}
#line 1087 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_srvha___5(adns_query qu , void *datap ) 
{ 
  adns_rr_srvha *rrp ;

  {
  {
#line 1088
  rrp = (adns_rr_srvha *)datap;
#line 1089
  mfp_hostaddr___5(qu, & rrp->ha);
  }
#line 1090
  return;
}
}
#line 1092 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_srv___5(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_srvraw const   *ap ;
  adns_rr_srvraw const   *bp ;

  {
#line 1093
  ap = (adns_rr_srvraw const   *)datap_a;
#line 1093
  bp = (adns_rr_srvraw const   *)datap_b;
#line 1096
  if (ap->priority < bp->priority) {
#line 1096
    return (0);
  }
#line 1097
  if (ap->priority > bp->priority) {
#line 1097
    return (1);
  }
#line 1098
  return (0);
}
}
#line 1101 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_srv_begin___5(vbuf *vb___0 , adns_rr_srvha const   *rrp ) 
{ 
  char buf___17[30] ;
  int tmp ;

  {
  {
#line 1104
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"%u %u %u ",
          rrp->priority, rrp->weight, rrp->port);
  }
  {
#line 1105
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1105
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 1105
    if (! tmp) {
#line 1105
      return ((adns_status )1);
    }
#line 1105
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1106
  return ((adns_status )0);
}
}
#line 1109 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_srvraw___5(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_srvraw const   *rrp ;
  adns_status st ;
  adns_status tmp ;

  {
  {
#line 1110
  rrp = (adns_rr_srvraw const   *)datap;
#line 1113
  st = csp_srv_begin___5(vb___0, (adns_rr_srvha const   *)((void const   *)rrp));
  }
#line 1113
  if (st) {
#line 1113
    return (st);
  }
  {
#line 1114
  tmp = csp_domain___5(vb___0, (char const   *)rrp->host);
  }
#line 1114
  return (tmp);
}
}
#line 1117 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_srvha___5(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_srvha const   *rrp ;
  adns_status st ;
  adns_status tmp ;

  {
  {
#line 1118
  rrp = (adns_rr_srvha const   *)datap;
#line 1121
  st = csp_srv_begin___5(vb___0, (adns_rr_srvha const   *)datap);
  }
#line 1121
  if (st) {
#line 1121
    return (st);
  }
  {
#line 1122
  tmp = csp_hostaddr___5(vb___0, & rrp->ha);
  }
#line 1122
  return (tmp);
}
}
#line 1125 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void postsort_srv___5(adns_state ads___7 , void *array , int nrrs , struct typeinfo  const  *typei ) 
{ 
  char *workbegin ;
  char *workend ;
  char *search ;
  char *arrayend ;
  adns_rr_srvha const   *rr ;
  union __anonunion_rrtmp_89___5 rrtmp ;
  int cpriority ;
  int totalweight ;
  int runtotal ;
  long randval ;

  {
#line 1138
  workbegin = (char *)array;
#line 1138
  arrayend = workbegin + typei->rrsz * (int const   )nrrs;
  {
#line 1138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1138
    if (! ((unsigned long )workbegin < (unsigned long )arrayend)) {
#line 1138
      goto while_break;
    }
#line 1141
    rr = (adns_rr_srvha const   *)((void *)workbegin);
#line 1141
    cpriority = (int )rr->priority;
#line 1143
    workend = workbegin;
#line 1143
    totalweight = 0;
    {
#line 1143
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1143
      if ((unsigned long )workend < (unsigned long )arrayend) {
#line 1143
        rr = (adns_rr_srvha const   *)((void *)workend);
#line 1143
        if (! (rr->priority == (int const   )cpriority)) {
#line 1143
          goto while_break___0;
        }
      } else {
#line 1143
        goto while_break___0;
      }
#line 1146
      totalweight += (int )rr->weight;
#line 1143
      workend += typei->rrsz;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1155
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1155
      if (! ((unsigned long )(workbegin + typei->rrsz) < (unsigned long )workend)) {
#line 1155
        goto while_break___1;
      }
      {
#line 1159
      randval = nrand48((unsigned short *)(ads___7->rand48xsubi));
#line 1160
      randval %= (long )(totalweight + 1);
#line 1167
      search = workbegin;
#line 1167
      runtotal = 0;
      }
      {
#line 1167
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1167
        rr = (adns_rr_srvha const   *)((void *)search);
#line 1167
        runtotal += (int )rr->weight;
#line 1167
        if (! ((long )runtotal < randval)) {
#line 1167
          goto while_break___2;
        }
#line 1167
        search += typei->rrsz;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1170
      if (! ((unsigned long )search < (unsigned long )arrayend)) {
        {
#line 1170
        __assert_fail("search < arrayend", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                      1170U, "postsort_srv");
        }
      }
#line 1171
      totalweight -= (int )rr->weight;
#line 1172
      if ((unsigned long )search != (unsigned long )workbegin) {
        {
#line 1173
        memcpy((void */* __restrict  */)(& rrtmp), (void const   */* __restrict  */)workbegin,
               (size_t )typei->rrsz);
#line 1174
        memcpy((void */* __restrict  */)workbegin, (void const   */* __restrict  */)search,
               (size_t )typei->rrsz);
#line 1175
        memcpy((void */* __restrict  */)search, (void const   */* __restrict  */)(& rrtmp),
               (size_t )typei->rrsz);
        }
      }
#line 1155
      workbegin += typei->rrsz;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1138
    workbegin = workend;
  }
  while_break: /* CIL Label */ ;
  }
#line 1184
  return;
}
}
#line 1190 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_byteblock___5(adns_query qu , void *datap ) 
{ 
  adns_rr_byteblock *rrp ;
  void *bytes___3 ;

  {
  {
#line 1191
  rrp = (adns_rr_byteblock *)datap;
#line 1192
  bytes___3 = (void *)rrp->data;
#line 1193
  adns__makefinal_block(qu, & bytes___3, (size_t )rrp->len);
#line 1194
  rrp->data = (unsigned char *)bytes___3;
  }
#line 1195
  return;
}
}
#line 1201 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_opaque___5(parseinfo const   *pai , int cbyte___3 , int max ,
                                 void *datap ) 
{ 
  adns_rr_byteblock *rrp ;
  void *tmp ;

  {
  {
#line 1203
  rrp = (adns_rr_byteblock *)datap;
#line 1205
  rrp->len = max - cbyte___3;
#line 1206
  tmp = adns__alloc_interim((adns_query )pai->qu, (size_t )rrp->len);
#line 1206
  rrp->data = (unsigned char *)tmp;
  }
#line 1207
  if (! rrp->data) {
#line 1207
    return ((adns_status )1);
  }
  {
#line 1208
  memcpy((void */* __restrict  */)rrp->data, (void const   */* __restrict  */)(pai->dgram + cbyte___3),
         (size_t )rrp->len);
  }
#line 1209
  return ((adns_status )0);
}
}
#line 1212 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_opaque___5(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_byteblock const   *rrp ;
  char buf___17[10] ;
  int l ;
  unsigned char *p ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1213
  rrp = (adns_rr_byteblock const   *)datap;
#line 1218
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"\\# %d",
          rrp->len);
  }
  {
#line 1219
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1219
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 1219
    if (! tmp) {
#line 1219
      return ((adns_status )1);
    }
#line 1219
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1221
  l = (int )rrp->len;
#line 1221
  p = (unsigned char *)rrp->data;
  {
#line 1221
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1221
    if (! (l >= 4)) {
#line 1221
      goto while_break___0;
    }
    {
#line 1224
    sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %02x%02x%02x%02x",
            (int )*(p + 0), (int )*(p + 1), (int )*(p + 2), (int )*(p + 3));
    }
    {
#line 1225
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1225
      tmp___0 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
      }
#line 1225
      if (! tmp___0) {
#line 1225
        return ((adns_status )1);
      }
#line 1225
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1221
    l -= 4;
#line 1221
    p += 4;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1227
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1227
    if (! (l > 0)) {
#line 1227
      goto while_break___2;
    }
    {
#line 1230
    sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %02x",
            (int )*p);
    }
    {
#line 1231
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 1231
      tmp___1 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
      }
#line 1231
      if (! tmp___1) {
#line 1231
        return ((adns_status )1);
      }
#line 1231
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1227
    l --;
#line 1227
    p ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1233
  return ((adns_status )0);
}
}
#line 1240 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_flat___5(adns_query qu , void *data___0 ) 
{ 


  {
#line 1240
  return;
}
}
#line 1261 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static typeinfo const   typeinfos___5[17]  = 
#line 1261
  {      {(adns_rrtype )1, "A", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.inaddr)),
      & mf_flat___5, & cs_inaddr___5, & pa_inaddr___5, & di_inaddr___5, (adns_status (*)(adns_state ads ,
                                                                                         char const   **p_io ,
                                                                                         char const   *pe ,
                                                                                         int labelnum ,
                                                                                         char *label_r ,
                                                                                         int *ll_io ,
                                                                                         adns_queryflags flags ,
                                                                                         struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )2,
      "NS", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___5, & cs_domain___5,
      & pa_host_raw___5, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )5,
      "CNAME", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___5,
      & cs_domain___5, & pa_dom_raw___5, (int (*)(adns_state ads , void const   *datap_a ,
                                                  void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                              char const   **p_io ,
                                                                                              char const   *pe ,
                                                                                              int labelnum ,
                                                                                              char *label_r ,
                                                                                              int *ll_io ,
                                                                                              adns_queryflags flags ,
                                                                                              struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )6,
      "SOA", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.soa)), & mf_soa___5, & cs_soa___5,
      & pa_soa___5, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )12,
      "PTR", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___5, & cs_domain___5,
      & pa_host_raw___5, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )13,
      "HINFO", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.intstrpair)),
      & mf_intstrpair___5, & cs_hinfo___5, & pa_hinfo___5, (int (*)(adns_state ads ,
                                                                    void const   *datap_a ,
                                                                    void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )15,
      "MX", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.intstr)), & mf_intstr___5,
      & cs_inthost___5, & pa_mx_raw___5, & di_mx_raw___5, (adns_status (*)(adns_state ads ,
                                                                           char const   **p_io ,
                                                                           char const   *pe ,
                                                                           int labelnum ,
                                                                           char *label_r ,
                                                                           int *ll_io ,
                                                                           adns_queryflags flags ,
                                                                           struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )16,
      "TXT", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.manyistr)),
      & mf_manyistr___5, & cs_txt___5, & pa_txt___5, (int (*)(adns_state ads , void const   *datap_a ,
                                                              void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )17,
      "RP", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.strpair)), & mf_strpair___5,
      & cs_rp___5, & pa_rp___5, (int (*)(adns_state ads , void const   *datap_a ,
                                         void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                     char const   **p_io ,
                                                                                     char const   *pe ,
                                                                                     int labelnum ,
                                                                                     char *label_r ,
                                                                                     int *ll_io ,
                                                                                     adns_queryflags flags ,
                                                                                     struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )33,
      "SRV", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.srvraw)), & mf_srvraw___5,
      & cs_srvraw___5, & pa_srvraw___5, & di_srv___5, & qdpl_srv___5, & postsort_srv___5}, 
        {(adns_rrtype )65537,
      "A", "addr", (int )sizeof(*(((adns_answer *)0)->rrs.addr)), & mf_flat___5, & cs_addr___5,
      & pa_addr___5, & di_addr___5, (adns_status (*)(adns_state ads , char const   **p_io ,
                                                     char const   *pe , int labelnum ,
                                                     char *label_r , int *ll_io ,
                                                     adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65538,
      "NS", "+addr", (int )sizeof(*(((adns_answer *)0)->rrs.hostaddr)), & mf_hostaddr___5,
      & cs_hostaddr___5, & pa_hostaddr___5, & di_hostaddr___5, (adns_status (*)(adns_state ads ,
                                                                                char const   **p_io ,
                                                                                char const   *pe ,
                                                                                int labelnum ,
                                                                                char *label_r ,
                                                                                int *ll_io ,
                                                                                adns_queryflags flags ,
                                                                                struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65548,
      "PTR", "checked", (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___5,
      & cs_domain___5, & pa_ptr___5, (int (*)(adns_state ads , void const   *datap_a ,
                                              void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                          char const   **p_io ,
                                                                                          char const   *pe ,
                                                                                          int labelnum ,
                                                                                          char *label_r ,
                                                                                          int *ll_io ,
                                                                                          adns_queryflags flags ,
                                                                                          struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65551,
      "MX", "+addr", (int )sizeof(*(((adns_answer *)0)->rrs.inthostaddr)), & mf_inthostaddr___5,
      & cs_inthostaddr___5, & pa_mx___5, & di_mx___5, (adns_status (*)(adns_state ads ,
                                                                       char const   **p_io ,
                                                                       char const   *pe ,
                                                                       int labelnum ,
                                                                       char *label_r ,
                                                                       int *ll_io ,
                                                                       adns_queryflags flags ,
                                                                       struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65569,
      "SRV", "+addr", (int )sizeof(*(((adns_answer *)0)->rrs.srvha)), & mf_srvha___5,
      & cs_srvha___5, & pa_srvha___5, & di_srv___5, & qdpl_srv___5, & postsort_srv___5}, 
        {(adns_rrtype )131078,
      "SOA", "822", (int )sizeof(*(((adns_answer *)0)->rrs.soa)), & mf_soa___5, & cs_soa___5,
      & pa_soa___5, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )131089,
      "RP", "822", (int )sizeof(*(((adns_answer *)0)->rrs.strpair)), & mf_strpair___5,
      & cs_rp___5, & pa_rp___5, (int (*)(adns_state ads , void const   *datap_a ,
                                         void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                     char const   **p_io ,
                                                                                     char const   *pe ,
                                                                                     int labelnum ,
                                                                                     char *label_r ,
                                                                                     int *ll_io ,
                                                                                     adns_queryflags flags ,
                                                                                     struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}};
#line 1288 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static struct typeinfo  const  typeinfo_unknown___5  = 
#line 1288
     {(adns_rrtype )262144, (char const   *)0, "unknown", (int )sizeof(*(((adns_answer *)0)->rrs.byteblock)),
    & mf_byteblock___5, & cs_opaque___5, & pa_opaque___5, (int (*)(adns_state ads ,
                                                                   void const   *datap_a ,
                                                                   void const   *datap_b ))0,
    (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                     char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
    (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0};
#line 55 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_query_alloc___5(adns_state ads___7 , adns_query qu ) 
{ 
  allocnode *an ;
  int tmp ;

  {
#line 58
  if (qu->allocations.head) {
#line 58
    if (! (! (qu->allocations.head)->back)) {
      {
#line 58
      __assert_fail("! (qu->allocations).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    59U, "checkc_query_alloc");
      }
    }
#line 58
    an = qu->allocations.head;
    {
#line 58
    while (1) {
      while_continue: /* CIL Label */ ;
#line 58
      if (! an) {
#line 58
        goto while_break;
      }
#line 58
      if (an->next) {
#line 58
        tmp = (unsigned long )an == (unsigned long )(an->next)->back;
      } else {
#line 58
        tmp = (unsigned long )an == (unsigned long )qu->allocations.tail;
      }
#line 58
      if (! tmp) {
        {
#line 58
        __assert_fail("(an)-> next ? (an) == (an)-> next-> back : (an) == (qu->allocations).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      59U, "checkc_query_alloc");
        }
      }
#line 58
      an = an->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 60
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_query___5(adns_state ads___7 , adns_query qu ) 
{ 
  adns_query child ;

  {
#line 65
  if (! (qu->udpnextserver < ads___7->nservers)) {
    {
#line 65
    __assert_fail("qu->udpnextserver < ads->nservers", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  65U, "checkc_query");
    }
  }
#line 66
  if (! (! (qu->udpsent & (0xffffffffffffffffUL << ads___7->nservers)))) {
    {
#line 66
    __assert_fail("!(qu->udpsent & (~0UL << ads->nservers))", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  66U, "checkc_query");
    }
  }
#line 67
  if (! (qu->search_pos <= ads___7->nsearchlist)) {
    {
#line 67
    __assert_fail("qu->search_pos <= ads->nsearchlist", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  67U, "checkc_query");
    }
  }
#line 68
  if (qu->parent) {
    {
#line 68
    while (1) {
      while_continue: /* CIL Label */ ;
#line 68
      child = (qu->parent)->children.head;
      {
#line 68
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 68
        if (! ((unsigned long )child != (unsigned long )qu)) {
#line 68
          goto while_break___0;
        }
#line 68
        if (! child) {
          {
#line 68
          __assert_fail("(child)", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        68U, "checkc_query");
          }
        }
#line 68
        child = child->siblings.next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 68
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 69
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_notcpbuf___5(adns_state ads___7 ) 
{ 


  {
#line 72
  if (! (! ads___7->tcpsend.used)) {
    {
#line 72
    __assert_fail("!ads->tcpsend.used", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  72U, "checkc_notcpbuf");
    }
  }
#line 73
  if (! (! ads___7->tcprecv.used)) {
    {
#line 73
    __assert_fail("!ads->tcprecv.used", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  73U, "checkc_notcpbuf");
    }
  }
#line 74
  if (! (! ads___7->tcprecv_skip)) {
    {
#line 74
    __assert_fail("!ads->tcprecv_skip", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  74U, "checkc_notcpbuf");
    }
  }
#line 75
  return;
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_global___5(adns_state ads___7 ) 
{ 
  int i ;

  {
#line 80
  if (! (ads___7->udpsocket >= 0)) {
    {
#line 80
    __assert_fail("ads->udpsocket >= 0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  80U, "checkc_global");
    }
  }
#line 82
  i = 0;
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! (i < ads___7->nsortlist)) {
#line 82
      goto while_break;
    }
#line 83
    if (! (! (ads___7->sortlist[i].base.s_addr & ~ ads___7->sortlist[i].mask.s_addr))) {
      {
#line 83
      __assert_fail("!(ads->sortlist[i].base.s_addr & ~ads->sortlist[i].mask.s_addr)",
                    "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    83U, "checkc_global");
      }
    }
#line 82
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  if (ads___7->tcpserver >= 0) {
#line 85
    if (! (ads___7->tcpserver < ads___7->nservers)) {
      {
#line 85
      __assert_fail("ads->tcpserver >= 0 && ads->tcpserver < ads->nservers", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    85U, "checkc_global");
      }
    }
  } else {
    {
#line 85
    __assert_fail("ads->tcpserver >= 0 && ads->tcpserver < ads->nservers", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  85U, "checkc_global");
    }
  }
  {
#line 88
  if ((unsigned int )ads___7->tcpstate == 1U) {
#line 88
    goto case_1;
  }
#line 93
  if ((unsigned int )ads___7->tcpstate == 3U) {
#line 93
    goto case_3;
  }
#line 93
  if ((unsigned int )ads___7->tcpstate == 0U) {
#line 93
    goto case_3;
  }
#line 97
  if ((unsigned int )ads___7->tcpstate == 2U) {
#line 97
    goto case_2;
  }
#line 101
  goto switch_default;
  case_1: /* CIL Label */ 
#line 89
  if (! (ads___7->tcpsocket >= 0)) {
    {
#line 89
    __assert_fail("ads->tcpsocket >= 0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  89U, "checkc_global");
    }
  }
  {
#line 90
  checkc_notcpbuf___5(ads___7);
  }
#line 91
  goto switch_break;
  case_3: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 94
  if (! (ads___7->tcpsocket == -1)) {
    {
#line 94
    __assert_fail("ads->tcpsocket == -1", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  94U, "checkc_global");
    }
  }
  {
#line 95
  checkc_notcpbuf___5(ads___7);
  }
#line 96
  goto switch_break;
  case_2: /* CIL Label */ 
#line 98
  if (! (ads___7->tcpsocket >= 0)) {
    {
#line 98
    __assert_fail("ads->tcpsocket >= 0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  98U, "checkc_global");
    }
  }
#line 99
  if (! (ads___7->tcprecv_skip <= ads___7->tcprecv.used)) {
    {
#line 99
    __assert_fail("ads->tcprecv_skip <= ads->tcprecv.used", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  99U, "checkc_global");
    }
  }
#line 100
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 102
  __assert_fail("!\"ads->tcpstate value\"", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                102U, "checkc_global");
  }
  switch_break: /* CIL Label */ ;
  }
#line 105
  if (! ads___7->searchlist) {
#line 105
    if (! (! ads___7->nsearchlist)) {
      {
#line 105
      __assert_fail("ads->searchlist || !ads->nsearchlist", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    105U, "checkc_global");
      }
    }
  }
#line 106
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_queue_udpw___5(adns_state ads___7 ) 
{ 
  adns_query qu ;
  int tmp ;

  {
#line 111
  if (ads___7->udpw.head) {
#line 111
    if (! (! (ads___7->udpw.head)->back)) {
      {
#line 111
      __assert_fail("! (ads->udpw).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    118U, "checkc_queue_udpw");
      }
    }
#line 111
    qu = ads___7->udpw.head;
    {
#line 111
    while (1) {
      while_continue: /* CIL Label */ ;
#line 111
      if (! qu) {
#line 111
        goto while_break;
      }
#line 111
      if (qu->next) {
#line 111
        tmp = (unsigned long )qu == (unsigned long )(qu->next)->back;
      } else {
#line 111
        tmp = (unsigned long )qu == (unsigned long )ads___7->udpw.tail;
      }
#line 111
      if (! tmp) {
        {
#line 111
        __assert_fail("(qu)-> next ? (qu) == (qu)-> next-> back : (qu) == (ads->udpw).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! ((unsigned int )qu->state == 0U)) {
        {
#line 111
        __assert_fail("qu->state==query_tosend", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! (qu->retries <= 15)) {
        {
#line 111
        __assert_fail("qu->retries <= 15", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! qu->udpsent) {
        {
#line 111
        __assert_fail("qu->udpsent", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! qu->children.head) {
#line 111
        if (! (! qu->children.tail)) {
          {
#line 111
          __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        118U, "checkc_queue_udpw");
          }
        }
      } else {
        {
#line 111
        __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
      {
#line 111
      checkc_query___5(ads___7, qu);
#line 111
      checkc_query_alloc___5(ads___7, qu);
#line 111
      qu = qu->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 119
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_queue_tcpw___5(adns_state ads___7 ) 
{ 
  adns_query qu ;
  int tmp ;

  {
#line 124
  if (ads___7->tcpw.head) {
#line 124
    if (! (! (ads___7->tcpw.head)->back)) {
      {
#line 124
      __assert_fail("! (ads->tcpw).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    130U, "checkc_queue_tcpw");
      }
    }
#line 124
    qu = ads___7->tcpw.head;
    {
#line 124
    while (1) {
      while_continue: /* CIL Label */ ;
#line 124
      if (! qu) {
#line 124
        goto while_break;
      }
#line 124
      if (qu->next) {
#line 124
        tmp = (unsigned long )qu == (unsigned long )(qu->next)->back;
      } else {
#line 124
        tmp = (unsigned long )qu == (unsigned long )ads___7->tcpw.tail;
      }
#line 124
      if (! tmp) {
        {
#line 124
        __assert_fail("(qu)-> next ? (qu) == (qu)-> next-> back : (qu) == (ads->tcpw).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
#line 124
      if (! ((unsigned int )qu->state == 1U)) {
        {
#line 124
        __assert_fail("qu->state==query_tcpw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
#line 124
      if (! qu->children.head) {
#line 124
        if (! (! qu->children.tail)) {
          {
#line 124
          __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        130U, "checkc_queue_tcpw");
          }
        }
      } else {
        {
#line 124
        __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
#line 124
      if (! (qu->retries <= ads___7->nservers + 1)) {
        {
#line 124
        __assert_fail("qu->retries <= ads->nservers+1", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
      {
#line 124
      checkc_query___5(ads___7, qu);
#line 124
      checkc_query_alloc___5(ads___7, qu);
#line 124
      qu = qu->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 131
  return;
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_queue_childw___5(adns_state ads___7 ) 
{ 
  adns_query parent ;
  adns_query child ;
  int tmp ;
  int tmp___0 ;

  {
#line 136
  if (ads___7->childw.head) {
#line 136
    if (! (! (ads___7->childw.head)->back)) {
      {
#line 136
      __assert_fail("! (ads->childw).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    145U, "checkc_queue_childw");
      }
    }
#line 136
    parent = ads___7->childw.head;
    {
#line 136
    while (1) {
      while_continue: /* CIL Label */ ;
#line 136
      if (! parent) {
#line 136
        goto while_break;
      }
#line 136
      if (parent->next) {
#line 136
        tmp = (unsigned long )parent == (unsigned long )(parent->next)->back;
      } else {
#line 136
        tmp = (unsigned long )parent == (unsigned long )ads___7->childw.tail;
      }
#line 136
      if (! tmp) {
        {
#line 136
        __assert_fail("(parent)-> next ? (parent) == (parent)-> next-> back : (parent) == (ads->childw).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      145U, "checkc_queue_childw");
        }
      }
#line 136
      if (! ((unsigned int )parent->state == 2U)) {
        {
#line 136
        __assert_fail("parent->state == query_childw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      145U, "checkc_queue_childw");
        }
      }
#line 136
      if (! parent->children.head) {
        {
#line 136
        __assert_fail("parent->children.head", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      145U, "checkc_queue_childw");
        }
      }
#line 136
      if (parent->children.head) {
#line 136
        if (! (! (parent->children.head)->siblings.back)) {
          {
#line 136
          __assert_fail("! (parent->children).head->siblings. back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        145U, "checkc_queue_childw");
          }
        }
#line 136
        child = parent->children.head;
        {
#line 136
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 136
          if (! child) {
#line 136
            goto while_break___0;
          }
#line 136
          if (child->siblings.next) {
#line 136
            tmp___0 = (unsigned long )child == (unsigned long )(child->siblings.next)->siblings.back;
          } else {
#line 136
            tmp___0 = (unsigned long )child == (unsigned long )parent->children.tail;
          }
#line 136
          if (! tmp___0) {
            {
#line 136
            __assert_fail("(child)->siblings. next ? (child) == (child)->siblings. next->siblings. back : (child) == (parent->children).tail",
                          "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                          145U, "checkc_queue_childw");
            }
          }
#line 136
          if (! ((unsigned long )child->parent == (unsigned long )parent)) {
            {
#line 136
            __assert_fail("child->parent == parent", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                          145U, "checkc_queue_childw");
            }
          }
#line 136
          if (! ((unsigned int )child->state != 3U)) {
            {
#line 136
            __assert_fail("child->state != query_done", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                          145U, "checkc_queue_childw");
            }
          }
#line 136
          child = child->siblings.next;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 136
      checkc_query___5(ads___7, parent);
#line 136
      checkc_query_alloc___5(ads___7, parent);
#line 136
      parent = parent->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 146
  return;
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_queue_output___5(adns_state ads___7 ) 
{ 
  adns_query qu ;
  int tmp ;

  {
#line 151
  if (ads___7->output.head) {
#line 151
    if (! (! (ads___7->output.head)->back)) {
      {
#line 151
      __assert_fail("! (ads->output).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    157U, "checkc_queue_output");
      }
    }
#line 151
    qu = ads___7->output.head;
    {
#line 151
    while (1) {
      while_continue: /* CIL Label */ ;
#line 151
      if (! qu) {
#line 151
        goto while_break;
      }
#line 151
      if (qu->next) {
#line 151
        tmp = (unsigned long )qu == (unsigned long )(qu->next)->back;
      } else {
#line 151
        tmp = (unsigned long )qu == (unsigned long )ads___7->output.tail;
      }
#line 151
      if (! tmp) {
        {
#line 151
        __assert_fail("(qu)-> next ? (qu) == (qu)-> next-> back : (qu) == (ads->output).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! ((unsigned int )qu->state == 3U)) {
        {
#line 151
        __assert_fail("qu->state == query_done", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! qu->children.head) {
#line 151
        if (! (! qu->children.tail)) {
          {
#line 151
          __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        157U, "checkc_queue_output");
          }
        }
      } else {
        {
#line 151
        __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! (! qu->parent)) {
        {
#line 151
        __assert_fail("!qu->parent", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! qu->allocations.head) {
#line 151
        if (! (! qu->allocations.tail)) {
          {
#line 151
          __assert_fail("!qu->allocations.head && !qu->allocations.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        157U, "checkc_queue_output");
          }
        }
      } else {
        {
#line 151
        __assert_fail("!qu->allocations.head && !qu->allocations.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
      {
#line 151
      checkc_query___5(ads___7, qu);
#line 151
      qu = qu->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 158
  return;
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnstest.c"
static struct myctx *mcs___0  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnstest.c"
static adns_state ads___3  ;
#line 50 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnstest.c"
static adns_rrtype *types_a___0  ;
#line 52
static  __attribute__((__noreturn__)) void quitnow___1(int rc ) ;
#line 53
static  __attribute__((__noreturn__)) void quitnow___1(int rc ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnstest.c"
static void quitnow___1(int rc ) 
{ 


  {
  {
#line 54
  Hfree((void *)mcs___0);
#line 55
  Hfree((void *)types_a___0);
  }
#line 56
  if (ads___3) {
    {
#line 56
    adns_finish(ads___3);
    }
  }
  {
#line 58
  Hexit(rc);
  }
}
}
#line 71
static  __attribute__((__noreturn__)) void failure_status___0(char const   *what ,
                                                              adns_status st ) ;
#line 72
static  __attribute__((__noreturn__)) void failure_status___0(char const   *what ,
                                                              adns_status st ) ;
#line 72 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnstest.c"
static void failure_status___0(char const   *what , adns_status st ) 
{ 
  char const   *tmp ;

  {
  {
#line 73
  tmp = adns_strerror(st);
#line 73
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adns failure: %s: %s\n",
          what, tmp);
#line 74
  quitnow___1(2);
  }
}
}
#line 77
static  __attribute__((__noreturn__)) void failure_errno___0(char const   *what ,
                                                             int errnoval ) ;
#line 78
static  __attribute__((__noreturn__)) void failure_errno___0(char const   *what ,
                                                             int errnoval ) ;
#line 78 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnstest.c"
static void failure_errno___0(char const   *what , int errnoval ) 
{ 


  {
  {
#line 82
  if (errnoval == 22) {
#line 82
    goto case_22;
  }
#line 83
  if (errnoval == 4) {
#line 83
    goto case_4;
  }
#line 84
  if (errnoval == 3) {
#line 84
    goto case_3;
  }
#line 85
  if (errnoval == 11) {
#line 85
    goto case_11;
  }
#line 86
  if (errnoval == 38) {
#line 86
    goto case_38;
  }
#line 87
  if (errnoval == 34) {
#line 87
    goto case_34;
  }
#line 89
  goto switch_default;
  case_22: /* CIL Label */ 
  {
#line 82
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adns failure: %s: errno=EINVAL\n",
          what);
  }
#line 82
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 83
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adns failure: %s: errno=EINTR\n",
          what);
  }
#line 83
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 84
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adns failure: %s: errno=ESRCH\n",
          what);
  }
#line 84
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 85
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adns failure: %s: errno=EAGAIN\n",
          what);
  }
#line 85
  goto switch_break;
  case_38: /* CIL Label */ 
  {
#line 86
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adns failure: %s: errno=ENOSYS\n",
          what);
  }
#line 86
  goto switch_break;
  case_34: /* CIL Label */ 
  {
#line 87
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adns failure: %s: errno=ERANGE\n",
          what);
  }
#line 87
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 89
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adns failure: %s: errno=%d\n",
          what, errnoval);
  }
#line 89
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 91
  quitnow___1(2);
  }
}
}
#line 94
static  __attribute__((__noreturn__)) void usageerr___3(char const   *why ) ;
#line 95
static  __attribute__((__noreturn__)) void usageerr___3(char const   *why ) ;
#line 95 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnstest.c"
static void usageerr___3(char const   *why ) 
{ 


  {
  {
#line 96
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad usage: %s\nusage: adnstest [-<initflagsnum>[,<owninitflags>]] [/<initstring>]\n              [ :<typenum>,... ]\n              [ [<queryflagsnum>[,<ownqueryflags>]/]<domain> ... ]\ninitflags:   p  use poll(2) instead of select(2)\n             s  use adns_wait with specified query, instead of 0\nqueryflags:  a  print status abbrevs instead of strings\nexit status:  0 ok (though some queries may have failed)\n              1 used by test harness to indicate test failed\n              2 unable to submit or init or some such\n              3 unexpected failure\n              4 usage error\n              5 operation not supported on this system\n",
          why);
#line 111
  quitnow___1(4);
  }
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnstest.c"
static adns_rrtype const   defaulttypes___0[16]  = 
#line 114
  {      (adns_rrtype const   )1,      (adns_rrtype const   )2,      (adns_rrtype const   )5,      (adns_rrtype const   )6, 
        (adns_rrtype const   )12,      (adns_rrtype const   )13,      (adns_rrtype const   )15,      (adns_rrtype const   )16, 
        (adns_rrtype const   )17,      (adns_rrtype const   )65537,      (adns_rrtype const   )65538,      (adns_rrtype const   )65548, 
        (adns_rrtype const   )65551,      (adns_rrtype const   )131078,      (adns_rrtype const   )131089,      (adns_rrtype const   )0};
#line 136 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnstest.c"
static void dumptype___0(adns_status ri , char const   *rrtn , char const   *fmtn ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
#line 137
  if (ri) {
    {
#line 137
    tmp = adns_strerror(ri);
#line 137
    tmp___0 = tmp;
    }
  } else {
#line 137
    tmp___0 = "";
  }
#line 137
  if (ri) {
#line 137
    tmp___1 = " ";
  } else {
#line 137
    tmp___1 = "";
  }
#line 137
  if (ri) {
#line 137
    tmp___3 = "?";
  } else {
#line 137
    if (fmtn) {
#line 137
      tmp___2 = fmtn;
    } else {
#line 137
      tmp___2 = "-";
    }
#line 137
    tmp___3 = tmp___2;
  }
#line 137
  if (! ri) {
#line 137
    if (rrtn) {
#line 137
      tmp___4 = rrtn;
    } else {
#line 137
      tmp___4 = "?";
    }
  } else {
#line 137
    tmp___4 = "?";
  }
  {
#line 137
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s(%s)%s%s",
          tmp___4, tmp___3, tmp___1, tmp___0);
  }
#line 140
  return;
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnstest.c"
static void fdom_split___0(char const   *fdom , char const   **dom_r , int *qf_r ,
                           char *ownflags , int ownflags_l ) 
{ 
  int qf ;
  char *ep ;
  unsigned long tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 147
  tmp = strtoul((char const   */* __restrict  */)fdom, (char **/* __restrict  */)(& ep),
                0);
#line 147
  qf = (int )tmp;
  }
#line 148
  if ((int )*ep == 44) {
    {
#line 148
    tmp___2 = strchr((char const   *)ep, '/');
    }
#line 148
    if (tmp___2) {
#line 149
      ep ++;
      {
#line 150
      while (1) {
        while_continue: /* CIL Label */ ;
#line 150
        if (! ((int )*ep != 47)) {
#line 150
          goto while_break;
        }
#line 151
        ownflags_l --;
#line 151
        if (ownflags_l <= 0) {
          {
#line 151
          fputs((char const   */* __restrict  */)"too many flags\n", (FILE */* __restrict  */)stderr);
#line 151
          quitnow___1(3);
          }
        }
#line 152
        tmp___0 = ownflags;
#line 152
        ownflags ++;
#line 152
        tmp___1 = ep;
#line 152
        ep ++;
#line 152
        *tmp___0 = *tmp___1;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 155
  if ((int )*ep != 47) {
#line 155
    *dom_r = fdom;
#line 155
    *qf_r = 0;
  } else {
#line 156
    *dom_r = (char const   *)(ep + 1);
#line 156
    *qf_r = qf;
  }
#line 157
  *ownflags = (char)0;
#line 158
  return;
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adnstest.c"
static int consistsof___0(char const   *string , char const   *accept___0 ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 161
  tmp = strspn(string, accept___0);
#line 161
  tmp___0 = strlen(string);
  }
#line 161
  return (tmp == tmp___0);
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
static struct sinfo  const  sinfos___5[24]  = 
#line 233 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
  {      {(adns_status )0, "ok", "OK"}, 
        {(adns_status )1, "nomemory", "Out of memory"}, 
        {(adns_status )2, "unknownrrtype", "Query not implemented in DNS library"}, 
        {(adns_status )3, "systemfail", "General resolver or system failure"}, 
        {(adns_status )30, "timeout", "DNS query timed out"}, 
        {(adns_status )31, "allservfail", "All nameservers failed"}, 
        {(adns_status )32, "norecurse", "Recursion denied by nameserver"}, 
        {(adns_status )33, "invalidresponse", "Nameserver sent bad response"}, 
        {(adns_status )34, "unknownformat", "Nameserver used unknown format"}, 
        {(adns_status )60, "rcodeservfail", "Nameserver reports failure"}, 
        {(adns_status )61, "rcodeformaterror", "Query not understood by nameserver"}, 
        {(adns_status )62,
      "rcodenotimplemented", "Query not implemented by nameserver"}, 
        {(adns_status )63, "rcoderefused", "Query refused by nameserver"}, 
        {(adns_status )64, "rcodeunknown", "Nameserver sent unknown response code"}, 
        {(adns_status )100, "inconsistent", "Inconsistent resource records in DNS"}, 
        {(adns_status )101, "prohibitedcname", "DNS alias found where canonical name wanted"}, 
        {(adns_status )102,
      "answerdomaininvalid", "Found syntactically invalid domain name"}, 
        {(adns_status )103, "answerdomaintoolong", "Found overly-long domain name"}, 
        {(adns_status )104, "invaliddata", "Found invalid DNS data"}, 
        {(adns_status )200, "querydomainwrong", "Domain invalid for particular DNS query type"}, 
        {(adns_status )201,
      "querydomaininvalid", "Domain name is syntactically invalid"}, 
        {(adns_status )202, "querydomaintoolong", "Domain name or component is too long"}, 
        {(adns_status )300,
      "nxdomain", "No such domain"}, 
        {(adns_status )301, "nodata", "No such data"}};
#line 270 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
static int si_compar___5(void const   *key , void const   *elem ) 
{ 
  adns_status const   *st ;
  struct sinfo  const  *si ;
  int tmp ;
  int tmp___0 ;

  {
#line 271
  st = (adns_status const   *)key;
#line 272
  si = (struct sinfo  const  *)elem;
#line 274
  if ((unsigned int const   )*st < (unsigned int const   )si->st) {
#line 274
    tmp___0 = -1;
  } else {
#line 274
    if ((unsigned int const   )*st > (unsigned int const   )si->st) {
#line 274
      tmp = 1;
    } else {
#line 274
      tmp = 0;
    }
#line 274
    tmp___0 = tmp;
  }
#line 274
  return (tmp___0);
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
static struct sinfo  const  *findsinfo___5(adns_status st ) 
{ 
  void *tmp ;

  {
  {
#line 278
  tmp = bsearch((void const   *)(& st), (void const   *)(sinfos___5), sizeof(sinfos___5) / sizeof(sinfos___5[0]),
                sizeof(sinfos___5[0]), & si_compar___5);
  }
#line 278
  return ((struct sinfo  const  *)tmp);
}
}
#line 299 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
static struct stinfo  const  stinfos___5[7]  = {      {(adns_status )0, "ok"}, 
        {(adns_status )29, "localfail"}, 
        {(adns_status )59, "remotefail"}, 
        {(adns_status )99, "tempfail"}, 
        {(adns_status )199, "misconfig"}, 
        {(adns_status )299, "misquery"}, 
        {(adns_status )499, "permfail"}};
#line 312 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
static int sti_compar___5(void const   *key , void const   *elem ) 
{ 
  adns_status const   *st ;
  struct stinfo  const  *sti ;
  adns_status here ;
  adns_status min ;
  adns_status max ;
  int tmp ;
  int tmp___0 ;

  {
#line 313
  st = (adns_status const   *)key;
#line 314
  sti = (struct stinfo  const  *)elem;
#line 318
  here = (adns_status )*st;
#line 319
  if ((unsigned long )sti == (unsigned long )(stinfos___5)) {
#line 319
    min = (adns_status )0;
  } else {
#line 319
    min = (adns_status )((unsigned int const   )(sti + -1)->stmax + 1U);
  }
#line 320
  max = (adns_status )sti->stmax;
#line 322
  if ((unsigned int )here < (unsigned int )min) {
#line 322
    tmp___0 = -1;
  } else {
#line 322
    if ((unsigned int )here > (unsigned int )max) {
#line 322
      tmp = 1;
    } else {
#line 322
      tmp = 0;
    }
#line 322
    tmp___0 = tmp;
  }
#line 322
  return (tmp___0);
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/transmit.c"
static adns_status mkquery_header___5(adns_state ads___7 , vbuf *vb___0 , int *id_r ,
                                      int qdlen ) 
{ 
  int id ;
  byte *rqp ;
  int tmp ;
  int tmp___0 ;
  byte *tmp___1 ;
  byte *tmp___2 ;
  byte *tmp___3 ;
  byte *tmp___4 ;
  byte *tmp___5 ;
  byte *tmp___6 ;
  byte *tmp___7 ;
  byte *tmp___8 ;
  byte *tmp___9 ;
  byte *tmp___10 ;
  byte *tmp___11 ;
  byte *tmp___12 ;

  {
  {
#line 46
  tmp = adns__vbuf_ensure(vb___0, (12 + qdlen) + 4);
  }
#line 46
  if (! tmp) {
#line 46
    return ((adns_status )1);
  }
#line 48
  vb___0->used = 0;
#line 49
  rqp = vb___0->buf + vb___0->used;
#line 51
  tmp___0 = ads___7->nextid;
#line 51
  (ads___7->nextid) ++;
#line 51
  id = tmp___0 & 65535;
#line 51
  *id_r = id;
#line 52
  tmp___1 = rqp;
#line 52
  rqp ++;
#line 52
  *tmp___1 = (byte )((id >> 8) & 255);
#line 52
  tmp___2 = rqp;
#line 52
  rqp ++;
#line 52
  *tmp___2 = (byte )(id & 255);
#line 53
  tmp___3 = rqp;
#line 53
  rqp ++;
#line 53
  *tmp___3 = (byte )1;
#line 54
  tmp___4 = rqp;
#line 54
  rqp ++;
#line 54
  *tmp___4 = (byte )0;
#line 55
  tmp___5 = rqp;
#line 55
  rqp ++;
#line 55
  *tmp___5 = (byte )((1 >> 8) & 255);
#line 55
  tmp___6 = rqp;
#line 55
  rqp ++;
#line 55
  *tmp___6 = (byte )1;
#line 56
  tmp___7 = rqp;
#line 56
  rqp ++;
#line 56
  *tmp___7 = (byte )0;
#line 56
  tmp___8 = rqp;
#line 56
  rqp ++;
#line 56
  *tmp___8 = (byte )0;
#line 57
  tmp___9 = rqp;
#line 57
  rqp ++;
#line 57
  *tmp___9 = (byte )0;
#line 57
  tmp___10 = rqp;
#line 57
  rqp ++;
#line 57
  *tmp___10 = (byte )0;
#line 58
  tmp___11 = rqp;
#line 58
  rqp ++;
#line 58
  *tmp___11 = (byte )0;
#line 58
  tmp___12 = rqp;
#line 58
  rqp ++;
#line 58
  *tmp___12 = (byte )0;
#line 60
  vb___0->used = (int )(rqp - vb___0->buf);
#line 62
  return ((adns_status )0);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/transmit.c"
static adns_status mkquery_footer___5(vbuf *vb___0 , adns_rrtype type ) 
{ 
  byte *rqp ;
  byte *tmp ;
  byte *tmp___0 ;
  byte *tmp___1 ;
  byte *tmp___2 ;

  {
#line 68
  rqp = vb___0->buf + vb___0->used;
#line 69
  tmp = rqp;
#line 69
  rqp ++;
#line 69
  *tmp = (byte )((((unsigned int )type & 65535U) >> 8) & 255U);
#line 69
  tmp___0 = rqp;
#line 69
  rqp ++;
#line 69
  *tmp___0 = (byte )(((unsigned int )type & 65535U) & 255U);
#line 70
  tmp___1 = rqp;
#line 70
  rqp ++;
#line 70
  *tmp___1 = (byte )((1 >> 8) & 255);
#line 70
  tmp___2 = rqp;
#line 70
  rqp ++;
#line 70
  *tmp___2 = (byte )1;
#line 71
  vb___0->used = (int )(rqp - vb___0->buf);
#line 72
  if (! (vb___0->used <= vb___0->avail)) {
    {
#line 72
    __assert_fail("vb->used <= vb->avail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/transmit.c",
                  72U, "mkquery_footer");
    }
  }
#line 74
  return ((adns_status )0);
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/transmit.c"
static void query_usetcp___5(adns_query qu , struct timeval now ) 
{ 


  {
  {
#line 244
  qu->state = (enum __anonenum_state_83 )1;
#line 245
  qu->timeout = now;
#line 246
  timevaladd(& qu->timeout, 30000L);
  }
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    qu->next = (adns_query )0;
#line 247
    qu->back = (qu->ads)->tcpw.tail;
#line 247
    if ((qu->ads)->tcpw.tail) {
#line 247
      ((qu->ads)->tcpw.tail)->next = qu;
    } else {
#line 247
      (qu->ads)->tcpw.head = qu;
    }
#line 247
    (qu->ads)->tcpw.tail = qu;
#line 247
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 248
  adns__querysend_tcp(qu, now);
#line 249
  adns__tcp_tryconnect(qu->ads, now);
  }
#line 250
  return;
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static adns_query query_alloc___5(adns_state ads___7 , typeinfo const   *typei , adns_rrtype type ,
                                  adns_queryflags flags , struct timeval now ) 
{ 
  adns_query qu ;
  void *tmp ;
  void *tmp___0 ;
  adns_query tmp___1 ;
  adns_query tmp___2 ;
  adns_query tmp___3 ;
  adns_query tmp___4 ;
  allocnode *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __suseconds_t tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 45
  tmp = Hmalloc(sizeof(*qu));
#line 45
  qu = (adns_query )tmp;
  }
#line 45
  if (! qu) {
#line 45
    return ((adns_query )0);
  }
  {
#line 46
  tmp___0 = Hmalloc(sizeof(*(qu->answer)));
#line 46
  qu->answer = (adns_answer *)tmp___0;
  }
#line 47
  if (! qu->answer) {
    {
#line 47
    Hfree((void *)qu);
    }
#line 47
    return ((adns_query )0);
  }
  {
#line 49
  qu->ads = ads___7;
#line 50
  qu->state = (enum __anonenum_state_83 )0;
#line 51
  tmp___2 = (adns_query )0;
#line 51
  qu->parent = tmp___2;
#line 51
  tmp___1 = tmp___2;
#line 51
  qu->next = tmp___1;
#line 51
  qu->back = tmp___1;
#line 52
  tmp___3 = (adns_query )0;
#line 52
  qu->children.tail = tmp___3;
#line 52
  qu->children.head = tmp___3;
#line 53
  tmp___4 = (adns_query )0;
#line 53
  qu->siblings.back = tmp___4;
#line 53
  qu->siblings.next = tmp___4;
#line 54
  tmp___5 = (allocnode *)0;
#line 54
  qu->allocations.tail = tmp___5;
#line 54
  qu->allocations.head = tmp___5;
#line 55
  qu->interim_allocd = 0;
#line 56
  qu->preserved_allocd = 0;
#line 57
  qu->final_allocspace = (void *)0;
#line 59
  qu->typei = typei;
#line 60
  qu->query_dgram = (byte *)0;
#line 61
  qu->query_dglen = 0;
#line 62
  adns__vbuf_init(& qu->vb);
#line 64
  qu->cname_dgram = (byte *)0;
#line 65
  tmp___6 = 0;
#line 65
  qu->cname_begin = tmp___6;
#line 65
  qu->cname_dglen = tmp___6;
#line 67
  adns__vbuf_init(& qu->search_vb);
#line 68
  tmp___8 = 0;
#line 68
  qu->search_doneabs = tmp___8;
#line 68
  tmp___7 = tmp___8;
#line 68
  qu->search_pos = tmp___7;
#line 68
  qu->search_origlen = tmp___7;
#line 70
  qu->id = -2;
#line 71
  qu->flags = (int )flags;
#line 72
  qu->retries = 0;
#line 73
  qu->udpnextserver = 0;
#line 74
  qu->udpsent = 0UL;
#line 75
  tmp___9 = (__suseconds_t )0;
#line 75
  qu->timeout.tv_usec = tmp___9;
#line 75
  qu->timeout.tv_sec = tmp___9;
#line 76
  qu->expires = now.tv_sec + 604800L;
#line 78
  memset((void *)(& qu->ctx), 0, sizeof(qu->ctx));
#line 80
  (qu->answer)->status = (adns_status )0;
#line 81
  tmp___10 = (char *)0;
#line 81
  (qu->answer)->owner = tmp___10;
#line 81
  (qu->answer)->cname = tmp___10;
#line 82
  (qu->answer)->type = type;
#line 83
  (qu->answer)->expires = (time_t )-1;
#line 84
  (qu->answer)->nrrs = 0;
#line 85
  (qu->answer)->rrs.untyped = (void *)0;
#line 86
  (qu->answer)->rrsz = (int )typei->rrsz;
  }
#line 88
  return (qu);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void query_submit___5(adns_state ads___7 , adns_query qu , typeinfo const   *typei ,
                             vbuf *qumsg_vb , int id , adns_queryflags flags , struct timeval now ) 
{ 
  void *tmp ;

  {
  {
#line 98
  qu->vb = *qumsg_vb;
#line 99
  adns__vbuf_init(qumsg_vb);
#line 101
  tmp = Hmalloc((size_t )qu->vb.used);
#line 101
  qu->query_dgram = (byte *)tmp;
  }
#line 102
  if (! qu->query_dgram) {
    {
#line 102
    adns__query_fail(qu, (adns_status )1);
    }
#line 102
    return;
  }
  {
#line 104
  qu->id = id;
#line 105
  qu->query_dglen = qu->vb.used;
#line 106
  memcpy((void */* __restrict  */)qu->query_dgram, (void const   */* __restrict  */)qu->vb.buf,
         (size_t )qu->vb.used);
#line 108
  adns__query_send(qu, now);
  }
#line 109
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void query_simple___5(adns_state ads___7 , adns_query qu , char const   *owner ,
                             int ol , typeinfo const   *typei , adns_queryflags flags ,
                             struct timeval now ) 
{ 
  vbuf vb_new ;
  int id ;
  adns_status stat ;

  {
  {
#line 136
  stat = adns__mkquery(ads___7, & qu->vb, & id, owner, ol, typei, (qu->answer)->type,
                       flags);
  }
#line 138
  if (stat) {
#line 139
    if ((unsigned int )stat == 202U) {
#line 139
      if ((unsigned int )flags & 1U) {
        {
#line 140
        adns__search_next(ads___7, qu, now);
        }
#line 141
        return;
      } else {
        {
#line 143
        adns__query_fail(qu, stat);
        }
#line 144
        return;
      }
    } else {
      {
#line 143
      adns__query_fail(qu, stat);
      }
#line 144
      return;
    }
  }
  {
#line 148
  vb_new = qu->vb;
#line 149
  adns__vbuf_init(& qu->vb);
#line 150
  query_submit___5(ads___7, qu, typei, & vb_new, id, flags, now);
  }
#line 151
  return;
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static int save_owner___5(adns_query qu , char const   *owner , int ol ) 
{ 
  adns_answer *ans ;
  void *tmp ;

  {
#line 198
  if (! (qu->flags & 4)) {
#line 198
    return (1);
  }
#line 200
  ans = qu->answer;
#line 201
  if (! (! ans->owner)) {
    {
#line 201
    __assert_fail("!ans->owner", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c",
                  201U, "save_owner");
    }
  }
  {
#line 203
  tmp = adns__alloc_preserved(qu, (size_t )(ol + 1));
#line 203
  ans->owner = (char *)tmp;
  }
#line 203
  if (! ans->owner) {
#line 203
    return (0);
  }
  {
#line 205
  memcpy((void */* __restrict  */)ans->owner, (void const   */* __restrict  */)owner,
         (size_t )ol);
#line 206
  *(ans->owner + ol) = (char)0;
  }
#line 207
  return (1);
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void *alloc_common___5(adns_query qu , size_t sz ) 
{ 
  allocnode *an ;
  void *tmp ;

  {
#line 342
  if (! sz) {
#line 342
    return ((void *)qu);
  }
#line 343
  if (! (! qu->final_allocspace)) {
    {
#line 343
    __assert_fail("!qu->final_allocspace", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c",
                  343U, "alloc_common");
    }
  }
  {
#line 344
  tmp = Hmalloc((((((((sizeof(*an) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ) + sz) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ));
#line 344
  an = (allocnode *)tmp;
  }
#line 345
  if (! an) {
#line 345
    return ((void *)0);
  }
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 346
    an->next = (struct allocnode *)0;
#line 346
    an->back = qu->allocations.tail;
#line 346
    if (qu->allocations.tail) {
#line 346
      (qu->allocations.tail)->next = an;
    } else {
#line 346
      qu->allocations.head = an;
    }
#line 346
    qu->allocations.tail = an;
#line 346
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 347
  return ((void *)((byte *)an + (((sizeof(*an) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign )));
}
}
#line 410 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void cancel_children___5(adns_query qu ) 
{ 
  adns_query cqu ;
  adns_query ncqu ;

  {
#line 413
  cqu = qu->children.head;
  {
#line 413
  while (1) {
    while_continue: /* CIL Label */ ;
#line 413
    if (! cqu) {
#line 413
      goto while_break;
    }
    {
#line 414
    ncqu = cqu->siblings.next;
#line 415
    adns_cancel(cqu);
#line 413
    cqu = ncqu;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 417
  return;
}
}
#line 427 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void free_query_allocs___5(adns_query qu ) 
{ 
  allocnode *an ;
  allocnode *ann ;
  allocnode *tmp ;

  {
  {
#line 430
  cancel_children___5(qu);
#line 431
  an = qu->allocations.head;
  }
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    if (! an) {
#line 431
      goto while_break;
    }
    {
#line 431
    ann = an->next;
#line 431
    Hfree((void *)an);
#line 431
    an = ann;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 432
  tmp = (allocnode *)0;
#line 432
  qu->allocations.tail = tmp;
#line 432
  qu->allocations.head = tmp;
#line 433
  adns__vbuf_free(& qu->vb);
#line 434
  adns__vbuf_free(& qu->search_vb);
#line 435
  Hfree((void *)qu->query_dgram);
#line 436
  qu->query_dgram = (byte *)0;
  }
#line 437
  return;
}
}
#line 477 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void makefinal_query___5(adns_query qu ) 
{ 
  adns_answer *ans ;
  int rrn ;
  void *tmp ;

  {
#line 481
  ans = qu->answer;
#line 483
  if (qu->interim_allocd) {
    {
#line 484
    tmp = Hrealloc((void *)qu->answer, (((((((sizeof(*ans) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ) + (unsigned long )qu->interim_allocd) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ));
#line 484
    ans = (adns_answer *)tmp;
    }
#line 486
    if (! ans) {
#line 486
      goto x_nomem;
    }
#line 487
    qu->answer = ans;
  }
  {
#line 490
  qu->final_allocspace = (void *)((byte *)ans + (((sizeof(*ans) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ));
#line 491
  adns__makefinal_str(qu, & ans->cname);
#line 492
  adns__makefinal_str(qu, & ans->owner);
  }
#line 494
  if (ans->nrrs) {
    {
#line 495
    adns__makefinal_block(qu, & ans->rrs.untyped, (size_t )(ans->nrrs * ans->rrsz));
#line 497
    rrn = 0;
    }
    {
#line 497
    while (1) {
      while_continue: /* CIL Label */ ;
#line 497
      if (! (rrn < ans->nrrs)) {
#line 497
        goto while_break;
      }
      {
#line 498
      (*((qu->typei)->makefinal))(qu, (void *)(ans->rrs.bytes + rrn * ans->rrsz));
#line 497
      rrn ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 501
  free_query_allocs___5(qu);
  }
#line 502
  return;
  x_nomem: 
  {
#line 505
  qu->preserved_allocd = 0;
#line 506
  (qu->answer)->cname = (char *)0;
#line 507
  (qu->answer)->owner = (char *)0;
#line 508
  adns__reset_preserved(qu);
#line 510
  (qu->answer)->status = (adns_status )1;
#line 511
  free_query_allocs___5(qu);
  }
#line 512
  return;
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void tcp_close___5(adns_state ads___7 ) 
{ 
  int serv ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 48
  serv = ads___7->tcpserver;
#line 49
  Hclose(ads___7->tcpsocket);
#line 50
  ads___7->tcpsocket = -1;
#line 51
  tmp___0 = 0;
#line 51
  ads___7->tcpsend.used = tmp___0;
#line 51
  tmp = tmp___0;
#line 51
  ads___7->tcprecv_skip = tmp;
#line 51
  ads___7->tcprecv.used = tmp;
  }
#line 52
  return;
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void tcp_connected___5(adns_state ads___7 , struct timeval now ) 
{ 
  adns_query qu ;
  adns_query nqu ;

  {
  {
#line 76
  adns__debug(ads___7, ads___7->tcpserver, (adns_query )0, "TCP connected");
#line 77
  ads___7->tcpstate = (enum adns__tcpstate )2;
#line 78
  qu = ads___7->tcpw.head;
  }
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (qu) {
#line 78
      if (! ((unsigned int )ads___7->tcpstate == 2U)) {
#line 78
        goto while_break;
      }
    } else {
#line 78
      goto while_break;
    }
#line 79
    nqu = qu->next;
#line 80
    if (! ((unsigned int )qu->state == 1U)) {
      {
#line 80
      __assert_fail("qu->state == query_tcpw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c",
                    80U, "tcp_connected");
      }
    }
    {
#line 81
    adns__querysend_tcp(qu, now);
#line 78
    qu = nqu;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void tcp_broken_events___5(adns_state ads___7 ) 
{ 
  adns_query qu ;
  adns_query nqu ;

  {
#line 88
  if (! ((unsigned int )ads___7->tcpstate == 3U)) {
    {
#line 88
    __assert_fail("ads->tcpstate == server_broken", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c",
                  88U, "tcp_broken_events");
    }
  }
#line 89
  qu = ads___7->tcpw.head;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! qu) {
#line 89
      goto while_break;
    }
#line 90
    nqu = qu->next;
#line 91
    if (! ((unsigned int )qu->state == 1U)) {
      {
#line 91
      __assert_fail("qu->state == query_tcpw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c",
                    91U, "tcp_broken_events");
      }
    }
#line 92
    if (qu->retries > ads___7->nservers) {
      {
#line 93
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 93
        if (qu->back) {
#line 93
          (qu->back)->next = qu->next;
        } else {
#line 93
          ads___7->tcpw.head = qu->next;
        }
#line 93
        if (qu->next) {
#line 93
          (qu->next)->back = qu->back;
        } else {
#line 93
          ads___7->tcpw.tail = qu->back;
        }
#line 93
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 94
      adns__query_fail(qu, (adns_status )31);
      }
    }
#line 89
    qu = nqu;
  }
  while_break: /* CIL Label */ ;
  }
#line 97
  ads___7->tcpstate = (enum adns__tcpstate )0;
#line 98
  return;
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void inter_immed___5(struct timeval **tv_io , struct timeval *tvbuf ) 
{ 
  struct timeval *rbuf ;
  __suseconds_t tmp ;

  {
#line 174
  if (! tv_io) {
#line 174
    return;
  }
#line 176
  rbuf = *tv_io;
#line 177
  if (! rbuf) {
#line 177
    rbuf = tvbuf;
#line 177
    *tv_io = rbuf;
  }
#line 179
  tmp = (__suseconds_t )0;
#line 179
  rbuf->tv_usec = tmp;
#line 179
  rbuf->tv_sec = tmp;
#line 180
  return;
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void inter_maxto___5(struct timeval **tv_io , struct timeval *tvbuf , struct timeval maxto ) 
{ 
  struct timeval *rbuf ;
  int tmp ;

  {
#line 186
  if (! tv_io) {
#line 186
    return;
  }
#line 187
  rbuf = *tv_io;
#line 188
  if (! rbuf) {
#line 189
    *tvbuf = maxto;
#line 189
    *tv_io = tvbuf;
  } else {
#line 191
    if (rbuf->tv_sec == maxto.tv_sec) {
#line 191
      tmp = rbuf->tv_usec > maxto.tv_usec;
    } else {
#line 191
      tmp = rbuf->tv_sec > maxto.tv_sec;
    }
#line 191
    if (tmp) {
#line 191
      *rbuf = maxto;
    }
  }
#line 195
  return;
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void inter_maxtoabs___5(struct timeval **tv_io , struct timeval *tvbuf , struct timeval now ,
                               struct timeval maxtime ) 
{ 
  ldiv_t dr ;

  {
#line 204
  if (! tv_io) {
#line 204
    return;
  }
  {
#line 205
  maxtime.tv_sec -= now.tv_sec + 2L;
#line 206
  maxtime.tv_usec -= now.tv_usec - 2000000L;
#line 207
  dr = ldiv(maxtime.tv_usec, 1000000L);
#line 208
  maxtime.tv_sec += dr.quot;
#line 209
  maxtime.tv_usec -= dr.quot * 1000000L;
  }
#line 210
  if (maxtime.tv_sec < 0L) {
#line 210
    maxtime.tv_usec = (__suseconds_t )0;
#line 210
    maxtime.tv_sec = maxtime.tv_usec;
  }
  {
#line 211
  inter_maxto___5(tv_io, tvbuf, maxtime);
  }
#line 212
  return;
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void timeouts_queue___5(adns_state ads___7 , int act , struct timeval **tv_io ,
                               struct timeval *tvbuf , struct timeval now , struct query_queue *queue ) 
{ 
  adns_query qu ;
  adns_query nqu ;
  int tmp ;

  {
#line 219
  qu = queue->head;
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if (! qu) {
#line 219
      goto while_break;
    }
#line 220
    nqu = qu->next;
#line 221
    if (now.tv_sec == qu->timeout.tv_sec) {
#line 221
      tmp = now.tv_usec > qu->timeout.tv_usec;
    } else {
#line 221
      tmp = now.tv_sec > qu->timeout.tv_sec;
    }
#line 221
    if (tmp) {
#line 224
      if (! act) {
        {
#line 224
        inter_immed___5(tv_io, tvbuf);
        }
#line 224
        return;
      }
      {
#line 225
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 225
        if (qu->back) {
#line 225
          (qu->back)->next = qu->next;
        } else {
#line 225
          queue->head = qu->next;
        }
#line 225
        if (qu->next) {
#line 225
          (qu->next)->back = qu->back;
        } else {
#line 225
          queue->tail = qu->back;
        }
#line 225
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 226
      if ((unsigned int )qu->state != 0U) {
        {
#line 227
        adns__query_fail(qu, (adns_status )30);
        }
      } else {
        {
#line 229
        adns__query_send(qu, now);
        }
      }
#line 231
      nqu = queue->head;
    } else {
      {
#line 222
      inter_maxtoabs___5(tv_io, tvbuf, now, qu->timeout);
      }
    }
#line 219
    qu = nqu;
  }
  while_break: /* CIL Label */ ;
  }
#line 234
  return;
}
}
#line 236 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void tcp_events___5(adns_state ads___7 , int act , struct timeval **tv_io ,
                           struct timeval *tvbuf , struct timeval now ) 
{ 
  int tmp ;

  {
  {
#line 239
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 241
    if ((unsigned int )ads___7->tcpstate == 3U) {
#line 241
      goto case_3;
    }
#line 244
    if ((unsigned int )ads___7->tcpstate == 0U) {
#line 244
      goto case_0;
    }
#line 249
    if ((unsigned int )ads___7->tcpstate == 2U) {
#line 249
      goto case_2;
    }
#line 256
    if ((unsigned int )ads___7->tcpstate == 1U) {
#line 256
      goto case_1;
    }
#line 275
    goto switch_default___0;
    case_3: /* CIL Label */ 
#line 242
    if (! act) {
      {
#line 242
      inter_immed___5(tv_io, tvbuf);
      }
#line 242
      return;
    }
    {
#line 243
    tcp_broken_events___5(ads___7);
    }
    case_0: /* CIL Label */ 
#line 245
    if (! ads___7->tcpw.head) {
#line 245
      return;
    }
#line 246
    if (! act) {
      {
#line 246
      inter_immed___5(tv_io, tvbuf);
      }
#line 246
      return;
    }
    {
#line 247
    adns__tcp_tryconnect(ads___7, now);
    }
#line 248
    goto switch_break;
    case_2: /* CIL Label */ 
#line 250
    if (ads___7->tcpw.head) {
#line 250
      return;
    }
#line 251
    if (! ads___7->tcptimeout.tv_sec) {
#line 252
      if (! (! ads___7->tcptimeout.tv_usec)) {
        {
#line 252
        __assert_fail("!ads->tcptimeout.tv_usec", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c",
                      252U, "tcp_events");
        }
      }
      {
#line 253
      ads___7->tcptimeout = now;
#line 254
      timevaladd(& ads___7->tcptimeout, 30000L);
      }
    }
    case_1: /* CIL Label */ 
#line 257
    if (! act) {
      {
#line 258
      inter_maxtoabs___5(tv_io, tvbuf, now, ads___7->tcptimeout);
      }
#line 259
      return;
    } else {
#line 257
      if (now.tv_sec == ads___7->tcptimeout.tv_sec) {
#line 257
        tmp = now.tv_usec > ads___7->tcptimeout.tv_usec;
      } else {
#line 257
        tmp = now.tv_sec > ads___7->tcptimeout.tv_sec;
      }
#line 257
      if (! tmp) {
        {
#line 258
        inter_maxtoabs___5(tv_io, tvbuf, now, ads___7->tcptimeout);
        }
#line 259
        return;
      }
    }
    {
#line 263
    if ((unsigned int )ads___7->tcpstate == 1U) {
#line 263
      goto case_1___0;
    }
#line 266
    if ((unsigned int )ads___7->tcpstate == 2U) {
#line 266
      goto case_2___0;
    }
#line 270
    goto switch_default;
    case_1___0: /* CIL Label */ 
    {
#line 264
    adns__tcp_broken(ads___7, "unable to make connection", "timed out");
    }
#line 265
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 267
    tcp_close___5(ads___7);
#line 268
    ads___7->tcpstate = (enum adns__tcpstate )0;
    }
#line 269
    return;
    switch_default: /* CIL Label */ 
    {
#line 271
    abort();
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 274
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
#line 276
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 279
  return;
}
}
#line 516 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void fd_event___5(adns_state ads___7 , int fd , int revent , int pollflag ,
                         int maxfd , fd_set const   *fds , int (*func)(adns_state  ,
                                                                       int fd , struct timeval  const  *now ) ,
                         struct timeval now , int *r_r ) 
{ 
  int r ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 524
  if (! (revent & pollflag)) {
#line 524
    return;
  }
#line 525
  if (fds) {
#line 525
    if (fd < maxfd) {
#line 525
      if (! ((fds->__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
#line 525
        return;
      }
    } else {
#line 525
      return;
    }
  }
  {
#line 526
  r = (*func)(ads___7, fd, (struct timeval  const  *)(& now));
  }
#line 527
  if (r) {
#line 528
    if (r_r) {
#line 529
      *r_r = r;
    } else {
      {
#line 531
      tmp = __errno_location();
#line 531
      tmp___0 = strerror(*tmp);
#line 531
      adns__diag(ads___7, -1, (adns_query )0, "process fd failed after select: %s",
                 tmp___0);
#line 533
      adns_globalsystemfailure(ads___7);
      }
    }
  }
#line 536
  return;
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
static struct sinfo  const  sinfos___6[24]  = 
#line 233 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
  {      {(adns_status )0, "ok", "OK"}, 
        {(adns_status )1, "nomemory", "Out of memory"}, 
        {(adns_status )2, "unknownrrtype", "Query not implemented in DNS library"}, 
        {(adns_status )3, "systemfail", "General resolver or system failure"}, 
        {(adns_status )30, "timeout", "DNS query timed out"}, 
        {(adns_status )31, "allservfail", "All nameservers failed"}, 
        {(adns_status )32, "norecurse", "Recursion denied by nameserver"}, 
        {(adns_status )33, "invalidresponse", "Nameserver sent bad response"}, 
        {(adns_status )34, "unknownformat", "Nameserver used unknown format"}, 
        {(adns_status )60, "rcodeservfail", "Nameserver reports failure"}, 
        {(adns_status )61, "rcodeformaterror", "Query not understood by nameserver"}, 
        {(adns_status )62,
      "rcodenotimplemented", "Query not implemented by nameserver"}, 
        {(adns_status )63, "rcoderefused", "Query refused by nameserver"}, 
        {(adns_status )64, "rcodeunknown", "Nameserver sent unknown response code"}, 
        {(adns_status )100, "inconsistent", "Inconsistent resource records in DNS"}, 
        {(adns_status )101, "prohibitedcname", "DNS alias found where canonical name wanted"}, 
        {(adns_status )102,
      "answerdomaininvalid", "Found syntactically invalid domain name"}, 
        {(adns_status )103, "answerdomaintoolong", "Found overly-long domain name"}, 
        {(adns_status )104, "invaliddata", "Found invalid DNS data"}, 
        {(adns_status )200, "querydomainwrong", "Domain invalid for particular DNS query type"}, 
        {(adns_status )201,
      "querydomaininvalid", "Domain name is syntactically invalid"}, 
        {(adns_status )202, "querydomaintoolong", "Domain name or component is too long"}, 
        {(adns_status )300,
      "nxdomain", "No such domain"}, 
        {(adns_status )301, "nodata", "No such data"}};
#line 270 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
static int si_compar___6(void const   *key , void const   *elem ) 
{ 
  adns_status const   *st ;
  struct sinfo  const  *si ;
  int tmp ;
  int tmp___0 ;

  {
#line 271
  st = (adns_status const   *)key;
#line 272
  si = (struct sinfo  const  *)elem;
#line 274
  if ((unsigned int const   )*st < (unsigned int const   )si->st) {
#line 274
    tmp___0 = -1;
  } else {
#line 274
    if ((unsigned int const   )*st > (unsigned int const   )si->st) {
#line 274
      tmp = 1;
    } else {
#line 274
      tmp = 0;
    }
#line 274
    tmp___0 = tmp;
  }
#line 274
  return (tmp___0);
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
static struct sinfo  const  *findsinfo___6(adns_status st ) 
{ 
  void *tmp ;

  {
  {
#line 278
  tmp = bsearch((void const   *)(& st), (void const   *)(sinfos___6), sizeof(sinfos___6) / sizeof(sinfos___6[0]),
                sizeof(sinfos___6[0]), & si_compar___6);
  }
#line 278
  return ((struct sinfo  const  *)tmp);
}
}
#line 299 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
static struct stinfo  const  stinfos___6[7]  = {      {(adns_status )0, "ok"}, 
        {(adns_status )29, "localfail"}, 
        {(adns_status )59, "remotefail"}, 
        {(adns_status )99, "tempfail"}, 
        {(adns_status )199, "misconfig"}, 
        {(adns_status )299, "misquery"}, 
        {(adns_status )499, "permfail"}};
#line 312 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/general.c"
static int sti_compar___6(void const   *key , void const   *elem ) 
{ 
  adns_status const   *st ;
  struct stinfo  const  *sti ;
  adns_status here ;
  adns_status min ;
  adns_status max ;
  int tmp ;
  int tmp___0 ;

  {
#line 313
  st = (adns_status const   *)key;
#line 314
  sti = (struct stinfo  const  *)elem;
#line 318
  here = (adns_status )*st;
#line 319
  if ((unsigned long )sti == (unsigned long )(stinfos___6)) {
#line 319
    min = (adns_status )0;
  } else {
#line 319
    min = (adns_status )((unsigned int const   )(sti + -1)->stmax + 1U);
  }
#line 320
  max = (adns_status )sti->stmax;
#line 322
  if ((unsigned int )here < (unsigned int )min) {
#line 322
    tmp___0 = -1;
  } else {
#line 322
    if ((unsigned int )here > (unsigned int )max) {
#line 322
      tmp = 1;
    } else {
#line 322
      tmp = 0;
    }
#line 322
    tmp___0 = tmp;
  }
#line 322
  return (tmp___0);
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
static vbuf vbw___6  ;
#line 175 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
static void Tvbpollevents___6(int events ) 
{ 
  char const   *delim ;

  {
#line 176
  delim = "";
#line 177
  events &= 7;
#line 178
  if (! events) {
    {
#line 178
    Tvba("0");
    }
#line 178
    return;
  }
#line 179
  if (events & 1) {
    {
#line 179
    Tvba("POLLIN");
#line 179
    delim = "|";
    }
  }
#line 180
  if (events & 4) {
    {
#line 180
    Tvba(delim);
#line 180
    Tvba("POLLOUT");
#line 180
    delim = "|";
    }
  }
#line 181
  if (events & 2) {
    {
#line 181
    Tvba(delim);
#line 181
    Tvba("POLLPRI");
    }
  }
#line 182
  return;
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
static unsigned long malloccount___6  ;
#line 241 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
static unsigned long mallocfailat___6  ;
#line 242 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hcommon.c"
static struct __anonstruct_mallocedlist_90___6 mallocedlist___6  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void tcp_close___6(adns_state ads___7 ) 
{ 
  int serv ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 48
  serv = ads___7->tcpserver;
#line 49
  Hclose(ads___7->tcpsocket);
#line 50
  ads___7->tcpsocket = -1;
#line 51
  tmp___0 = 0;
#line 51
  ads___7->tcpsend.used = tmp___0;
#line 51
  tmp = tmp___0;
#line 51
  ads___7->tcprecv_skip = tmp;
#line 51
  ads___7->tcprecv.used = tmp;
  }
#line 52
  return;
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void tcp_connected___6(adns_state ads___7 , struct timeval now ) 
{ 
  adns_query qu ;
  adns_query nqu ;

  {
  {
#line 76
  adns__debug(ads___7, ads___7->tcpserver, (adns_query )0, "TCP connected");
#line 77
  ads___7->tcpstate = (enum adns__tcpstate )2;
#line 78
  qu = ads___7->tcpw.head;
  }
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (qu) {
#line 78
      if (! ((unsigned int )ads___7->tcpstate == 2U)) {
#line 78
        goto while_break;
      }
    } else {
#line 78
      goto while_break;
    }
#line 79
    nqu = qu->next;
#line 80
    if (! ((unsigned int )qu->state == 1U)) {
      {
#line 80
      __assert_fail("qu->state == query_tcpw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c",
                    80U, "tcp_connected");
      }
    }
    {
#line 81
    adns__querysend_tcp(qu, now);
#line 78
    qu = nqu;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void tcp_broken_events___6(adns_state ads___7 ) 
{ 
  adns_query qu ;
  adns_query nqu ;

  {
#line 88
  if (! ((unsigned int )ads___7->tcpstate == 3U)) {
    {
#line 88
    __assert_fail("ads->tcpstate == server_broken", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c",
                  88U, "tcp_broken_events");
    }
  }
#line 89
  qu = ads___7->tcpw.head;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! qu) {
#line 89
      goto while_break;
    }
#line 90
    nqu = qu->next;
#line 91
    if (! ((unsigned int )qu->state == 1U)) {
      {
#line 91
      __assert_fail("qu->state == query_tcpw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c",
                    91U, "tcp_broken_events");
      }
    }
#line 92
    if (qu->retries > ads___7->nservers) {
      {
#line 93
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 93
        if (qu->back) {
#line 93
          (qu->back)->next = qu->next;
        } else {
#line 93
          ads___7->tcpw.head = qu->next;
        }
#line 93
        if (qu->next) {
#line 93
          (qu->next)->back = qu->back;
        } else {
#line 93
          ads___7->tcpw.tail = qu->back;
        }
#line 93
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 94
      adns__query_fail(qu, (adns_status )31);
      }
    }
#line 89
    qu = nqu;
  }
  while_break: /* CIL Label */ ;
  }
#line 97
  ads___7->tcpstate = (enum adns__tcpstate )0;
#line 98
  return;
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void inter_immed___6(struct timeval **tv_io , struct timeval *tvbuf ) 
{ 
  struct timeval *rbuf ;
  __suseconds_t tmp ;

  {
#line 174
  if (! tv_io) {
#line 174
    return;
  }
#line 176
  rbuf = *tv_io;
#line 177
  if (! rbuf) {
#line 177
    rbuf = tvbuf;
#line 177
    *tv_io = rbuf;
  }
#line 179
  tmp = (__suseconds_t )0;
#line 179
  rbuf->tv_usec = tmp;
#line 179
  rbuf->tv_sec = tmp;
#line 180
  return;
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void inter_maxto___6(struct timeval **tv_io , struct timeval *tvbuf , struct timeval maxto ) 
{ 
  struct timeval *rbuf ;
  int tmp ;

  {
#line 186
  if (! tv_io) {
#line 186
    return;
  }
#line 187
  rbuf = *tv_io;
#line 188
  if (! rbuf) {
#line 189
    *tvbuf = maxto;
#line 189
    *tv_io = tvbuf;
  } else {
#line 191
    if (rbuf->tv_sec == maxto.tv_sec) {
#line 191
      tmp = rbuf->tv_usec > maxto.tv_usec;
    } else {
#line 191
      tmp = rbuf->tv_sec > maxto.tv_sec;
    }
#line 191
    if (tmp) {
#line 191
      *rbuf = maxto;
    }
  }
#line 195
  return;
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void inter_maxtoabs___6(struct timeval **tv_io , struct timeval *tvbuf , struct timeval now ,
                               struct timeval maxtime ) 
{ 
  ldiv_t dr ;

  {
#line 204
  if (! tv_io) {
#line 204
    return;
  }
  {
#line 205
  maxtime.tv_sec -= now.tv_sec + 2L;
#line 206
  maxtime.tv_usec -= now.tv_usec - 2000000L;
#line 207
  dr = ldiv(maxtime.tv_usec, 1000000L);
#line 208
  maxtime.tv_sec += dr.quot;
#line 209
  maxtime.tv_usec -= dr.quot * 1000000L;
  }
#line 210
  if (maxtime.tv_sec < 0L) {
#line 210
    maxtime.tv_usec = (__suseconds_t )0;
#line 210
    maxtime.tv_sec = maxtime.tv_usec;
  }
  {
#line 211
  inter_maxto___6(tv_io, tvbuf, maxtime);
  }
#line 212
  return;
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void timeouts_queue___6(adns_state ads___7 , int act , struct timeval **tv_io ,
                               struct timeval *tvbuf , struct timeval now , struct query_queue *queue ) 
{ 
  adns_query qu ;
  adns_query nqu ;
  int tmp ;

  {
#line 219
  qu = queue->head;
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if (! qu) {
#line 219
      goto while_break;
    }
#line 220
    nqu = qu->next;
#line 221
    if (now.tv_sec == qu->timeout.tv_sec) {
#line 221
      tmp = now.tv_usec > qu->timeout.tv_usec;
    } else {
#line 221
      tmp = now.tv_sec > qu->timeout.tv_sec;
    }
#line 221
    if (tmp) {
#line 224
      if (! act) {
        {
#line 224
        inter_immed___6(tv_io, tvbuf);
        }
#line 224
        return;
      }
      {
#line 225
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 225
        if (qu->back) {
#line 225
          (qu->back)->next = qu->next;
        } else {
#line 225
          queue->head = qu->next;
        }
#line 225
        if (qu->next) {
#line 225
          (qu->next)->back = qu->back;
        } else {
#line 225
          queue->tail = qu->back;
        }
#line 225
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 226
      if ((unsigned int )qu->state != 0U) {
        {
#line 227
        adns__query_fail(qu, (adns_status )30);
        }
      } else {
        {
#line 229
        adns__query_send(qu, now);
        }
      }
#line 231
      nqu = queue->head;
    } else {
      {
#line 222
      inter_maxtoabs___6(tv_io, tvbuf, now, qu->timeout);
      }
    }
#line 219
    qu = nqu;
  }
  while_break: /* CIL Label */ ;
  }
#line 234
  return;
}
}
#line 236 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void tcp_events___6(adns_state ads___7 , int act , struct timeval **tv_io ,
                           struct timeval *tvbuf , struct timeval now ) 
{ 
  int tmp ;

  {
  {
#line 239
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 241
    if ((unsigned int )ads___7->tcpstate == 3U) {
#line 241
      goto case_3;
    }
#line 244
    if ((unsigned int )ads___7->tcpstate == 0U) {
#line 244
      goto case_0;
    }
#line 249
    if ((unsigned int )ads___7->tcpstate == 2U) {
#line 249
      goto case_2;
    }
#line 256
    if ((unsigned int )ads___7->tcpstate == 1U) {
#line 256
      goto case_1;
    }
#line 275
    goto switch_default___0;
    case_3: /* CIL Label */ 
#line 242
    if (! act) {
      {
#line 242
      inter_immed___6(tv_io, tvbuf);
      }
#line 242
      return;
    }
    {
#line 243
    tcp_broken_events___6(ads___7);
    }
    case_0: /* CIL Label */ 
#line 245
    if (! ads___7->tcpw.head) {
#line 245
      return;
    }
#line 246
    if (! act) {
      {
#line 246
      inter_immed___6(tv_io, tvbuf);
      }
#line 246
      return;
    }
    {
#line 247
    adns__tcp_tryconnect(ads___7, now);
    }
#line 248
    goto switch_break;
    case_2: /* CIL Label */ 
#line 250
    if (ads___7->tcpw.head) {
#line 250
      return;
    }
#line 251
    if (! ads___7->tcptimeout.tv_sec) {
#line 252
      if (! (! ads___7->tcptimeout.tv_usec)) {
        {
#line 252
        __assert_fail("!ads->tcptimeout.tv_usec", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c",
                      252U, "tcp_events");
        }
      }
      {
#line 253
      ads___7->tcptimeout = now;
#line 254
      timevaladd(& ads___7->tcptimeout, 30000L);
      }
    }
    case_1: /* CIL Label */ 
#line 257
    if (! act) {
      {
#line 258
      inter_maxtoabs___6(tv_io, tvbuf, now, ads___7->tcptimeout);
      }
#line 259
      return;
    } else {
#line 257
      if (now.tv_sec == ads___7->tcptimeout.tv_sec) {
#line 257
        tmp = now.tv_usec > ads___7->tcptimeout.tv_usec;
      } else {
#line 257
        tmp = now.tv_sec > ads___7->tcptimeout.tv_sec;
      }
#line 257
      if (! tmp) {
        {
#line 258
        inter_maxtoabs___6(tv_io, tvbuf, now, ads___7->tcptimeout);
        }
#line 259
        return;
      }
    }
    {
#line 263
    if ((unsigned int )ads___7->tcpstate == 1U) {
#line 263
      goto case_1___0;
    }
#line 266
    if ((unsigned int )ads___7->tcpstate == 2U) {
#line 266
      goto case_2___0;
    }
#line 270
    goto switch_default;
    case_1___0: /* CIL Label */ 
    {
#line 264
    adns__tcp_broken(ads___7, "unable to make connection", "timed out");
    }
#line 265
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 267
    tcp_close___6(ads___7);
#line 268
    ads___7->tcpstate = (enum adns__tcpstate )0;
    }
#line 269
    return;
    switch_default: /* CIL Label */ 
    {
#line 271
    abort();
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 274
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
#line 276
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 279
  return;
}
}
#line 516 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/event.c"
static void fd_event___6(adns_state ads___7 , int fd , int revent , int pollflag ,
                         int maxfd , fd_set const   *fds , int (*func)(adns_state  ,
                                                                       int fd , struct timeval  const  *now ) ,
                         struct timeval now , int *r_r ) 
{ 
  int r ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 524
  if (! (revent & pollflag)) {
#line 524
    return;
  }
#line 525
  if (fds) {
#line 525
    if (fd < maxfd) {
#line 525
      if (! ((fds->__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
#line 525
        return;
      }
    } else {
#line 525
      return;
    }
  }
  {
#line 526
  r = (*func)(ads___7, fd, (struct timeval  const  *)(& now));
  }
#line 527
  if (r) {
#line 528
    if (r_r) {
#line 529
      *r_r = r;
    } else {
      {
#line 531
      tmp = __errno_location();
#line 531
      tmp___0 = strerror(*tmp);
#line 531
      adns__diag(ads___7, -1, (adns_query )0, "process fd failed after select: %s",
                 tmp___0);
#line 533
      adns_globalsystemfailure(ads___7);
      }
    }
  }
#line 536
  return;
}
}
#line 13 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static FILE *Tinputfile___2  ;
#line 13 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static FILE *Treportfile___2  ;
#line 14 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static vbuf vb2___2  ;
#line 18 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static void Tensurereportfile___2(void) 
{ 
  char const   *fdstr ;
  int fd ;
  char *tmp ;

  {
#line 21
  if (Treportfile___2) {
#line 21
    return;
  }
  {
#line 22
  Treportfile___2 = stderr;
#line 23
  tmp = getenv("ADNS_TEST_REPORT_FD");
#line 23
  fdstr = (char const   *)tmp;
  }
#line 23
  if (! fdstr) {
#line 23
    return;
  }
  {
#line 24
  fd = atoi(fdstr);
#line 25
  Treportfile___2 = fdopen(fd, "a");
  }
#line 25
  if (! Treportfile___2) {
    {
#line 25
    Tfailed("fdopen ADNS_TEST_REPORT_FD");
    }
  }
#line 26
  return;
}
}
#line 27 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static void Psyntax___2(char const   *where ) 
{ 


  {
  {
#line 28
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adns test harness: syntax error in test log input file: %s\n",
          where);
#line 29
  exit(-1);
  }
}
}
#line 31 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static void Pcheckinput___2(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 32
  tmp = ferror(Tinputfile___2);
  }
#line 32
  if (tmp) {
    {
#line 32
    Tfailed("read test log input file");
    }
  }
  {
#line 33
  tmp___0 = feof(Tinputfile___2);
  }
#line 33
  if (tmp___0) {
    {
#line 33
    Psyntax___2("eof at syscall reply");
    }
  }
#line 34
  return;
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static void Parg___2(char const   *argname ) 
{ 
  int l ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 59
  tmp = vb2___2.used;
#line 59
  (vb2___2.used) ++;
#line 59
  if ((int )*(vb2___2.buf + tmp) != 32) {
    {
#line 59
    Psyntax___2("not a space before argument");
    }
  }
  {
#line 60
  tmp___0 = strlen(argname);
#line 60
  l = (int )tmp___0;
#line 61
  tmp___1 = memcmp((void const   *)(vb2___2.buf + vb2___2.used), (void const   *)argname,
                   (size_t )l);
  }
#line 61
  if (tmp___1) {
    {
#line 61
    Psyntax___2("argument name wrong");
    }
  }
#line 62
  vb2___2.used += l;
#line 63
  tmp___2 = vb2___2.used;
#line 63
  (vb2___2.used) ++;
#line 63
  if ((int )*(vb2___2.buf + tmp___2) != 61) {
    {
#line 63
    Psyntax___2("not = after argument name");
    }
  }
#line 64
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static int Pstring_maybe___2(char const   *string ) 
{ 
  int l ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 67
  tmp = strlen(string);
#line 67
  l = (int )tmp;
#line 68
  tmp___0 = memcmp((void const   *)(vb2___2.buf + vb2___2.used), (void const   *)string,
                   (size_t )l);
  }
#line 68
  if (tmp___0) {
#line 68
    return (0);
  }
#line 69
  vb2___2.used += l;
#line 70
  return (1);
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static void Pstring___2(char const   *string , char const   *emsg ) 
{ 
  int tmp ;

  {
  {
#line 73
  tmp = Pstring_maybe___2(string);
  }
#line 73
  if (tmp) {
#line 73
    return;
  }
  {
#line 74
  Psyntax___2(emsg);
  }
#line 75
  return;
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static int Perrno___2(char const   *stuff ) 
{ 
  struct Terrno  const  *te ;
  int r ;
  char *ep ;
  int tmp ;
  unsigned long tmp___0 ;

  {
#line 80
  te = Terrnos;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    if (te->n) {
      {
#line 80
      tmp = strcmp((char const   *)te->n, stuff);
      }
#line 80
      if (! tmp) {
#line 80
        goto while_break;
      }
    } else {
#line 80
      goto while_break;
    }
#line 80
    te ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  if (te->n) {
#line 81
    return ((int )te->v);
  }
  {
#line 82
  tmp___0 = strtoul((char const   */* __restrict  */)(stuff + 2), (char **/* __restrict  */)(& ep),
                    10);
#line 82
  r = (int )tmp___0;
  }
#line 83
  if (*ep) {
    {
#line 83
    Psyntax___2("errno value not recognised, not numeric");
    }
  }
#line 84
  return (r);
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static void P_updatetime___2(void) 
{ 
  int chars ;
  unsigned long sec ;
  unsigned long usec ;
  int tmp ;

  {
  {
#line 89
  tmp = adns__vbuf_ensure(& vb2___2, 1000);
  }
#line 89
  if (! tmp) {
    {
#line 89
    Tnomem();
    }
  }
  {
#line 90
  fgets((char */* __restrict  */)vb2___2.buf, vb2___2.avail, (FILE */* __restrict  */)Tinputfile___2);
#line 90
  Pcheckinput___2();
#line 91
  chars = -1;
#line 92
  sscanf((char const   */* __restrict  */)vb2___2.buf, (char const   */* __restrict  */)" +%lu.%lu%n",
         & sec, & usec, & chars);
  }
#line 93
  if (chars == -1) {
    {
#line 93
    Psyntax___2("update time invalid");
    }
  }
#line 94
  currenttime.tv_sec = (__time_t )((unsigned long )currenttime.tv_sec + sec);
#line 95
  currenttime.tv_usec = (__suseconds_t )((unsigned long )currenttime.tv_usec + usec);
#line 96
  if (currenttime.tv_usec > 1000000L) {
#line 97
    (currenttime.tv_sec) ++;
#line 98
    currenttime.tv_usec -= 1000000L;
  }
#line 100
  if ((int )*(vb2___2.buf + chars) != 10) {
    {
#line 100
    Psyntax___2("not newline after update time");
    }
  }
#line 101
  return;
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static void Pfdset___2(fd_set *set , int max ) 
{ 
  int r ;
  int c ;
  char *ep ;
  int tmp ;
  int __d0 ;
  int __d1 ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
#line 105
  tmp = vb2___2.used;
#line 105
  (vb2___2.used) ++;
#line 105
  if ((int )*(vb2___2.buf + tmp) != 91) {
    {
#line 105
    Psyntax___2("fd set start not [");
    }
  }
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& set->__fds_bits[0]): "memory");
#line 106
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  if ((int )*(vb2___2.buf + vb2___2.used) == 93) {
#line 107
    (vb2___2.used) ++;
#line 107
    return;
  }
  {
#line 108
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 109
    tmp___0 = strtoul((char const   */* __restrict  */)(vb2___2.buf + vb2___2.used),
                      (char **/* __restrict  */)(& ep), 10);
#line 109
    r = (int )tmp___0;
    }
#line 110
    if (r >= max) {
      {
#line 110
      Psyntax___2("fd set member > max");
      }
    }
#line 111
    if ((unsigned long )ep == (unsigned long )((char *)vb2___2.buf + vb2___2.used)) {
      {
#line 111
      Psyntax___2("empty entry in fd set");
      }
    }
#line 112
    set->__fds_bits[r / (8 * (int )sizeof(__fd_mask ))] |= 1L << r % (8 * (int )sizeof(__fd_mask ));
#line 113
    vb2___2.used = (int )(ep - (char *)vb2___2.buf);
#line 114
    tmp___1 = vb2___2.used;
#line 114
    (vb2___2.used) ++;
#line 114
    c = (int )*(vb2___2.buf + tmp___1);
#line 115
    if (c == 93) {
#line 115
      goto while_break___0;
    }
#line 116
    if (c != 44) {
      {
#line 116
      Psyntax___2("fd set separator not ,");
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 118
  return;
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static int Ppollfdevents___2(void) 
{ 
  int events ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 122
  tmp = Pstring_maybe___2("0");
  }
#line 122
  if (tmp) {
#line 122
    return (0);
  }
  {
#line 123
  events = 0;
#line 124
  tmp___1 = Pstring_maybe___2("POLLIN");
  }
#line 124
  if (tmp___1) {
    {
#line 125
    events |= 1;
#line 126
    tmp___0 = Pstring_maybe___2("|");
    }
#line 126
    if (! tmp___0) {
#line 126
      return (events);
    }
  }
  {
#line 128
  tmp___3 = Pstring_maybe___2("POLLOUT");
  }
#line 128
  if (tmp___3) {
    {
#line 129
    events |= 4;
#line 130
    tmp___2 = Pstring_maybe___2("|");
    }
#line 130
    if (! tmp___2) {
#line 130
      return (events);
    }
  }
  {
#line 132
  Pstring___2("POLLPRI", "pollfdevents PRI?");
  }
#line 133
  return (events);
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static void Ppollfds___2(struct pollfd *fds , int nfds ) 
{ 
  int i ;
  char *ep ;
  char const   *comma ;
  int tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 138
  comma = "";
#line 139
  tmp = vb2___2.used;
#line 139
  (vb2___2.used) ++;
#line 139
  if ((int )*(vb2___2.buf + tmp) != 91) {
    {
#line 139
    Psyntax___2("pollfds start not [");
    }
  }
#line 140
  i = 0;
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if (! (i < nfds)) {
#line 140
      goto while_break;
    }
    {
#line 141
    Pstring___2("{fd=", "{fd= in pollfds");
#line 142
    tmp___0 = strtoul((char const   */* __restrict  */)(vb2___2.buf + vb2___2.used),
                      (char **/* __restrict  */)(& ep), 10);
#line 142
    fds->fd = (int )tmp___0;
#line 143
    vb2___2.used = (int )(ep - (char *)vb2___2.buf);
#line 144
    Pstring___2(", events=", ", events= in pollfds");
#line 145
    tmp___1 = Ppollfdevents___2();
#line 145
    fds->events = (short )tmp___1;
#line 146
    Pstring___2(", revents=", ", revents= in pollfds");
#line 147
    tmp___2 = Ppollfdevents___2();
#line 147
    fds->revents = (short )tmp___2;
#line 148
    Pstring___2("}", "} in pollfds");
#line 149
    Pstring___2(comma, "separator in pollfds");
#line 150
    comma = ", ";
#line 140
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 152
  tmp___3 = vb2___2.used;
#line 152
  (vb2___2.used) ++;
#line 152
  if ((int )*(vb2___2.buf + tmp___3) != 93) {
    {
#line 152
    Psyntax___2("pollfds end not ]");
    }
  }
#line 153
  return;
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static void Paddr___2(struct sockaddr *addr , int *lenr ) 
{ 
  struct sockaddr_in *sa___3 ;
  char *p ;
  char *ep ;
  long ul ;
  char *tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 156
  sa___3 = (struct sockaddr_in *)addr;
#line 159
  if (! ((unsigned long )*lenr >= sizeof(*sa___3))) {
    {
#line 159
    __assert_fail("*lenr >= sizeof(*sa)", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c",
                  159U, "Paddr");
    }
  }
  {
#line 160
  p = strchr((char const   *)(vb2___2.buf + vb2___2.used), ':');
  }
#line 161
  if (! p) {
    {
#line 161
    Psyntax___2("no port on address");
    }
  }
  {
#line 162
  tmp = p;
#line 162
  p ++;
#line 162
  *tmp = (char)0;
#line 163
  memset((void *)sa___3, 0, sizeof(*sa___3));
#line 164
  sa___3->sin_family = (sa_family_t )2;
#line 165
  tmp___0 = inet_aton((char const   *)(vb2___2.buf + vb2___2.used), & sa___3->sin_addr);
  }
#line 165
  if (! tmp___0) {
    {
#line 165
    Psyntax___2("invalid address");
    }
  }
  {
#line 166
  tmp___1 = strtoul((char const   */* __restrict  */)p, (char **/* __restrict  */)(& ep),
                    10);
#line 166
  ul = (long )tmp___1;
  }
#line 167
  if (*ep) {
#line 167
    if ((int )*ep != 32) {
      {
#line 167
      Psyntax___2("invalid port (bad syntax)");
      }
    }
  }
#line 168
  if (ul >= 65536L) {
    {
#line 168
    Psyntax___2("port too large");
    }
  }
  {
#line 169
  sa___3->sin_port = htons((uint16_t )ul);
#line 170
  *lenr = (int )sizeof(*sa___3);
#line 171
  vb2___2.used = (int )(ep - (char *)vb2___2.buf);
  }
#line 172
  return;
}
}
#line 174
static int Pbytes___2(byte *buf___17 , int maxlen ) ;
#line 174 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static char const   hexdigits___2[17]  = 
#line 174
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'\000'};
#line 173 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/hplayback.c"
static int Pbytes___2(byte *buf___17 , int maxlen ) 
{ 
  int c ;
  int v ;
  int done ;
  char const   *pf ;
  char *tmp ;
  char *tmp___0 ;
  byte *tmp___1 ;

  {
#line 177
  done = 0;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 179
    c = _IO_getc(Tinputfile___2);
#line 179
    Pcheckinput___2();
    }
#line 180
    if (c == 10) {
#line 180
      goto __Cont;
    } else
#line 180
    if (c == 32) {
#line 180
      goto __Cont;
    } else
#line 180
    if (c == 9) {
#line 180
      goto __Cont;
    }
#line 181
    if (c == 46) {
#line 181
      goto while_break;
    }
    {
#line 182
    tmp = strchr(hexdigits___2, c);
#line 182
    pf = (char const   *)tmp;
    }
#line 182
    if (! pf) {
      {
#line 182
      Psyntax___2("invalid first hex digit");
      }
    }
    {
#line 183
    v = (int )((pf - hexdigits___2) << 4);
#line 184
    c = _IO_getc(Tinputfile___2);
#line 184
    Pcheckinput___2();
#line 185
    tmp___0 = strchr(hexdigits___2, c);
#line 185
    pf = (char const   *)tmp___0;
    }
#line 185
    if (! pf) {
      {
#line 185
      Psyntax___2("invalid second hex digit");
      }
    }
#line 186
    v = (int )((long )v | (pf - hexdigits___2));
#line 187
    if (maxlen <= 0) {
      {
#line 187
      Psyntax___2("buffer overflow in bytes");
      }
    }
#line 188
    tmp___1 = buf___17;
#line 188
    buf___17 ++;
#line 188
    *tmp___1 = (byte )v;
#line 189
    maxlen --;
#line 189
    done ++;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 191
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 192
    c = _IO_getc(Tinputfile___2);
#line 192
    Pcheckinput___2();
    }
#line 193
    if (c == 10) {
#line 193
      return (done);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-query.c"
static unsigned long idcounter___0  ;
#line 59 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-query.c"
static char buf___5[12]  ;
#line 71 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-query.c"
static void prep_query___0(struct query_node **qun_r , int *quflags_r ) 
{ 
  struct query_node *qun ;
  char idbuf[20] ;
  void *tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 75
  if (ov_pipe) {
#line 75
    if (! ads) {
      {
#line 75
      usageerr("-f/--pipe not consistent with domains on command line");
      }
    }
  }
  {
#line 76
  ensure_adns_init();
#line 78
  tmp = Hmalloc(sizeof(*qun));
#line 78
  qun = (struct query_node *)tmp;
#line 79
  qun->pqfr = ov_pqfr;
  }
#line 80
  if (ov_id) {
    {
#line 81
    qun->id = xstrsave((char const   *)ov_id);
    }
  } else {
    {
#line 83
    tmp___0 = idcounter___0;
#line 83
    idcounter___0 ++;
#line 83
    sprintf((char */* __restrict  */)(idbuf), (char const   */* __restrict  */)"%lu",
            tmp___0);
#line 84
    idcounter___0 &= 4294967295UL;
#line 85
    qun->id = xstrsave((char const   *)(idbuf));
    }
  }
#line 88
  if (ov_search) {
#line 88
    tmp___1 = 1;
  } else {
#line 88
    tmp___1 = 0;
  }
#line 88
  if (ov_tcp) {
#line 88
    tmp___2 = 2;
  } else {
#line 88
    tmp___2 = 0;
  }
#line 88
  if (ov_pqfr.show_owner) {
#line 88
    tmp___3 = 4;
  } else
#line 88
  if (ov_format == 1) {
#line 88
    tmp___3 = 4;
  } else {
#line 88
    tmp___3 = 0;
  }
#line 88
  if (ov_qc_query) {
#line 88
    tmp___4 = 16;
  } else {
#line 88
    tmp___4 = 0;
  }
#line 88
  if (ov_qc_anshost) {
#line 88
    tmp___5 = 64;
  } else {
#line 88
    tmp___5 = 0;
  }
#line 88
  if (ov_qc_cname) {
#line 88
    tmp___6 = 0;
  } else {
#line 88
    tmp___6 = 0;
  }
#line 88
  *quflags_r = (((((tmp___1 | tmp___2) | tmp___3) | tmp___4) | tmp___5) | tmp___6) | ov_cname;
#line 88
  *qun_r = qun;
#line 98
  return;
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-query.c"
static void dequeue_query___0(struct query_node *qun ) 
{ 


  {
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 162
    if (qun->back) {
#line 162
      (qun->back)->next = qun->next;
    } else {
#line 162
      outstanding.head = qun->next;
    }
#line 162
    if (qun->next) {
#line 162
      (qun->next)->back = qun->back;
    } else {
#line 162
      outstanding.tail = qun->back;
    }
#line 162
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 163
  Hfree((void *)qun->id);
#line 164
  Hfree((void *)qun->owner);
#line 165
  Hfree((void *)qun);
  }
#line 166
  return;
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-query.c"
static void print_withspace___0(char const   *str ) 
{ 
  int tmp ;

  {
  {
#line 169
  tmp = printf((char const   */* __restrict  */)"%s ", str);
  }
#line 169
  if (tmp == -1) {
    {
#line 169
    outerr();
    }
  }
#line 170
  return;
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-query.c"
static void print_ttl___0(struct query_node *qun , adns_answer *answer ) 
{ 
  unsigned long ttl ;
  time_t now ;
  int *tmp ;
  time_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 177
  if (qun->pqfr.ttl == 0) {
#line 177
    goto case_0;
  }
#line 179
  if (qun->pqfr.ttl == 1) {
#line 179
    goto case_1;
  }
#line 183
  if (qun->pqfr.ttl == 2) {
#line 183
    goto case_2;
  }
#line 186
  goto switch_default;
  case_0: /* CIL Label */ 
#line 178
  return;
  case_1: /* CIL Label */ 
  {
#line 180
  tmp___0 = time(& now);
  }
#line 180
  if (tmp___0 == -1L) {
    {
#line 180
    tmp = __errno_location();
#line 180
    sysfail("get current time", *tmp);
    }
  }
#line 181
  if (answer->expires < now) {
#line 181
    ttl = 0UL;
  } else {
#line 181
    ttl = (unsigned long )(answer->expires - now);
  }
#line 182
  goto switch_break;
  case_2: /* CIL Label */ 
#line 184
  ttl = (unsigned long )answer->expires;
#line 185
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 187
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 189
  tmp___1 = printf((char const   */* __restrict  */)"%lu ", ttl);
  }
#line 189
  if (tmp___1 == -1) {
    {
#line 189
    outerr();
    }
  }
#line 190
  return;
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-query.c"
static char const   *owner_show___0(struct query_node *qun , adns_answer *answer ) 
{ 
  char *tmp ;

  {
#line 193
  if (answer->owner) {
#line 193
    tmp = answer->owner;
  } else {
#line 193
    tmp = qun->owner;
  }
#line 193
  return ((char const   *)tmp);
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-query.c"
static void print_owner_ttl___0(struct query_node *qun , adns_answer *answer ) 
{ 
  char const   *tmp ;

  {
#line 197
  if (qun->pqfr.show_owner) {
    {
#line 197
    tmp = owner_show___0(qun, answer);
#line 197
    print_withspace___0(tmp);
    }
  }
  {
#line 198
  print_ttl___0(qun, answer);
  }
#line 199
  return;
}
}
#line 202
static void check_status___0(adns_status st ) ;
#line 202 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-query.c"
static adns_status const   statuspoints___0[6]  = {      (adns_status const   )0,      (adns_status const   )29,      (adns_status const   )59,      (adns_status const   )99, 
        (adns_status const   )199,      (adns_status const   )299};
#line 201 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-query.c"
static void check_status___0(adns_status st ) 
{ 
  adns_status const   *spp ;
  int minrcode ;

  {
#line 211
  minrcode = 0;
#line 211
  spp = statuspoints___0;
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 211
    if (! ((unsigned long )spp < (unsigned long )(statuspoints___0 + sizeof(statuspoints___0) / sizeof(statuspoints___0[0])))) {
#line 211
      goto while_break;
    }
#line 214
    if ((unsigned int )st > (unsigned int )*spp) {
#line 214
      minrcode ++;
    }
#line 211
    spp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 215
  if (rcode < minrcode) {
#line 215
    rcode = minrcode;
  }
#line 216
  return;
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-query.c"
static void print_status___0(adns_status st , struct query_node *qun , adns_answer *answer ) 
{ 
  char const   *statustypeabbrev ;
  char const   *statusabbrev ;
  char const   *statusstring ;
  char *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 221
  statustypeabbrev = adns_errtypeabbrev(st);
#line 222
  statusabbrev = adns_errabbrev(st);
#line 223
  statusstring = adns_strerror(st);
#line 224
  tmp = strchr(statusstring, '\"');
  }
#line 224
  if (tmp) {
    {
#line 224
    __assert_fail("!strchr(statusstring,\'\"\')", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-query.c",
                  224U, "print_status");
    }
  }
  {
#line 226
  tmp___0 = printf((char const   */* __restrict  */)"%s %d %s ", statustypeabbrev,
                   (unsigned int )st, statusabbrev);
  }
#line 226
  if (tmp___0 == -1) {
    {
#line 227
    outerr();
    }
  }
  {
#line 228
  print_owner_ttl___0(qun, answer);
  }
#line 229
  if (qun->pqfr.show_cname) {
#line 230
    if (answer->cname) {
#line 230
      tmp___1 = (char const   *)answer->cname;
    } else {
#line 230
      tmp___1 = "$";
    }
    {
#line 230
    print_withspace___0(tmp___1);
    }
  }
  {
#line 231
  tmp___2 = printf((char const   */* __restrict  */)"\"%s\"\n", statusstring);
  }
#line 231
  if (tmp___2 == -1) {
    {
#line 231
    outerr();
    }
  }
#line 232
  return;
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-query.c"
static void print_dnsfail___0(adns_status st , struct query_node *qun , adns_answer *answer ) 
{ 
  int r ;
  char const   *typename ;
  char const   *statusstring ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int *tmp___3 ;

  {
#line 238
  if (ov_format == 2) {
    {
#line 239
    tmp = fputs((char const   */* __restrict  */)"; failed ", (FILE */* __restrict  */)stdout);
    }
#line 239
    if (tmp == -1) {
      {
#line 239
      outerr();
      }
    }
    {
#line 240
    print_status___0(st, qun, answer);
    }
#line 241
    return;
  }
#line 243
  if (! (ov_format == 1)) {
    {
#line 243
    __assert_fail("ov_format == fmt_simple", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-query.c",
                  243U, "print_dnsfail");
    }
  }
#line 244
  if ((unsigned int )st == 300U) {
    {
#line 245
    tmp___0 = owner_show___0(qun, answer);
#line 245
    r = fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s does not exist\n",
                tmp___0);
    }
  } else {
    {
#line 247
    type_info(answer->type, & typename, (void const   *)0, (char **)0);
    }
#line 248
    if ((unsigned int )st == 301U) {
      {
#line 249
      tmp___1 = owner_show___0(qun, answer);
#line 249
      r = fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s has no %s record\n",
                  tmp___1, typename);
      }
    } else {
      {
#line 251
      statusstring = adns_strerror(st);
#line 252
      tmp___2 = owner_show___0(qun, answer);
#line 252
      r = fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error during DNS %s lookup for %s: %s\n",
                  typename, tmp___2, statusstring);
      }
    }
  }
#line 256
  if (r == -1) {
    {
#line 256
    tmp___3 = __errno_location();
#line 256
    sysfail("write error message to stderr", *tmp___3);
    }
  }
#line 257
  return;
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfig___6(adns_state ads___7 , char const   *filename , int warnmissing ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void addserver___6(adns_state ads___7 , struct in_addr addr ) 
{ 
  int i ;
  struct server *ss ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 48
  i = 0;
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (i < ads___7->nservers)) {
#line 48
      goto while_break;
    }
#line 49
    if (ads___7->servers[i].addr.s_addr == addr.s_addr) {
      {
#line 50
      tmp = inet_ntoa(addr);
#line 50
      adns__debug(ads___7, -1, (adns_query )0, "duplicate nameserver %s ignored",
                  tmp);
      }
#line 51
      return;
    }
#line 48
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  if (ads___7->nservers >= 5) {
    {
#line 56
    tmp___0 = inet_ntoa(addr);
#line 56
    adns__diag(ads___7, -1, (adns_query )0, "too many nameservers, ignoring %s", tmp___0);
    }
#line 57
    return;
  }
#line 60
  ss = ads___7->servers + ads___7->nservers;
#line 61
  ss->addr = addr;
#line 62
  (ads___7->nservers) ++;
#line 63
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void freesearchlist___6(adns_state ads___7 ) 
{ 


  {
#line 66
  if (ads___7->nsearchlist) {
    {
#line 66
    Hfree((void *)*(ads___7->searchlist));
    }
  }
  {
#line 67
  Hfree((void *)ads___7->searchlist);
  }
#line 68
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void saveerr___6(adns_state ads___7 , int en ) 
{ 


  {
#line 71
  if (! ads___7->configerrno) {
#line 71
    ads___7->configerrno = en;
  }
#line 72
  return;
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void configparseerr___6(adns_state ads___7 , char const   *fn , int lno , char const   *fmt 
                               , ...) 
{ 
  va_list al ;

  {
  {
#line 78
  saveerr___6(ads___7, 22);
  }
#line 79
  if (! ads___7->logfn) {
#line 79
    return;
  } else
#line 79
  if ((unsigned int )ads___7->iflags & 2U) {
#line 79
    return;
  }
#line 81
  if (lno == -1) {
    {
#line 81
    adns__lprintf(ads___7, "adns: %s: ", fn);
    }
  } else {
    {
#line 82
    adns__lprintf(ads___7, "adns: %s:%d: ", fn, lno);
    }
  }
  {
#line 83
  __builtin_va_start(al, fmt);
#line 84
  adns__vlprintf(ads___7, fmt, al);
#line 85
  __builtin_va_end(al);
#line 86
  adns__lprintf(ads___7, "\n");
  }
#line 87
  return;
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int nextword___6(char const   **bufp_io , char const   **word_r , int *l_r ) 
{ 
  char const   *p ;
  char const   *q ;
  int tmp ;
  int tmp___0 ;

  {
#line 92
  p = *bufp_io;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 93
    tmp = ctype_whitespace((int )*p);
    }
#line 93
    if (! tmp) {
#line 93
      goto while_break;
    }
#line 93
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  if (! *p) {
#line 94
    return (0);
  }
#line 96
  q = p;
  {
#line 97
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 97
    if (*q) {
      {
#line 97
      tmp___0 = ctype_whitespace((int )*q);
      }
#line 97
      if (tmp___0) {
#line 97
        goto while_break___0;
      }
    } else {
#line 97
      goto while_break___0;
    }
#line 97
    q ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 99
  *l_r = (int )(q - p);
#line 100
  *word_r = p;
#line 101
  *bufp_io = q;
#line 103
  return (1);
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_nameserver___6(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  struct in_addr ia ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 110
  tmp = inet_aton(buf___17, & ia);
  }
#line 110
  if (! tmp) {
    {
#line 111
    configparseerr___6(ads___7, fn, lno, "invalid nameserver address `%s\'", buf___17);
    }
#line 112
    return;
  }
  {
#line 114
  tmp___0 = inet_ntoa(ia);
#line 114
  adns__debug(ads___7, -1, (adns_query )0, "using nameserver %s", tmp___0);
#line 115
  addserver___6(ads___7, ia);
  }
#line 116
  return;
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_search___6(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  char const   *bufp ;
  char const   *word ;
  char *newchars ;
  char **newptrs ;
  char **pp ;
  int count ;
  int tl ;
  int l ;
  int tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char **tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
#line 124
  if (! buf___17) {
#line 124
    return;
  }
#line 126
  bufp = buf___17;
#line 127
  count = 0;
#line 128
  tl = 0;
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 129
    tmp = nextword___6(& bufp, & word, & l);
    }
#line 129
    if (! tmp) {
#line 129
      goto while_break;
    }
#line 129
    count ++;
#line 129
    tl += l + 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 131
  tmp___0 = Hmalloc(sizeof(char *) * (unsigned long )count);
#line 131
  newptrs = (char **)tmp___0;
  }
#line 132
  if (! newptrs) {
    {
#line 132
    tmp___1 = __errno_location();
#line 132
    saveerr___6(ads___7, *tmp___1);
    }
#line 132
    return;
  }
  {
#line 134
  tmp___2 = Hmalloc((size_t )tl);
#line 134
  newchars = (char *)tmp___2;
  }
#line 135
  if (! newchars) {
    {
#line 135
    tmp___3 = __errno_location();
#line 135
    saveerr___6(ads___7, *tmp___3);
#line 135
    Hfree((void *)newptrs);
    }
#line 135
    return;
  }
#line 137
  bufp = buf___17;
#line 138
  pp = newptrs;
  {
#line 139
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 139
    tmp___6 = nextword___6(& bufp, & word, & l);
    }
#line 139
    if (! tmp___6) {
#line 139
      goto while_break___0;
    }
    {
#line 140
    tmp___4 = pp;
#line 140
    pp ++;
#line 140
    *tmp___4 = newchars;
#line 141
    memcpy((void */* __restrict  */)newchars, (void const   */* __restrict  */)word,
           (size_t )l);
#line 142
    newchars += l;
#line 143
    tmp___5 = newchars;
#line 143
    newchars ++;
#line 143
    *tmp___5 = (char)0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 146
  freesearchlist___6(ads___7);
#line 147
  ads___7->nsearchlist = count;
#line 148
  ads___7->searchlist = newptrs;
  }
#line 149
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_sortlist___6(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  char const   *word ;
  char tbuf[200] ;
  char *slash ;
  char *ep ;
  struct in_addr base ;
  struct in_addr mask ;
  int l ;
  unsigned long initial ;
  unsigned long baselocal ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  uint32_t tmp___3 ;
  int tmp___4 ;

  {
#line 159
  if (! buf___17) {
#line 159
    return;
  }
#line 161
  ads___7->nsortlist = 0;
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 162
    tmp___4 = nextword___6(& buf___17, & word, & l);
    }
#line 162
    if (! tmp___4) {
#line 162
      goto while_break;
    }
#line 163
    if (ads___7->nsortlist >= 15) {
      {
#line 164
      adns__diag(ads___7, -1, (adns_query )0, "too many sortlist entries, ignoring %.*s onwards",
                 l, word);
      }
#line 166
      return;
    }
#line 169
    if ((unsigned long )l >= sizeof(tbuf)) {
      {
#line 170
      configparseerr___6(ads___7, fn, lno, "sortlist entry `%.*s\' too long", l, word);
      }
#line 171
      goto while_continue;
    }
    {
#line 174
    memcpy((void */* __restrict  */)(tbuf), (void const   */* __restrict  */)word,
           (size_t )l);
#line 174
    tbuf[l] = (char)0;
#line 175
    slash = strchr((char const   *)(tbuf), '/');
    }
#line 176
    if (slash) {
#line 176
      tmp = slash;
#line 176
      slash ++;
#line 176
      *tmp = (char)0;
    }
    {
#line 178
    tmp___0 = inet_aton((char const   *)(tbuf), & base);
    }
#line 178
    if (! tmp___0) {
      {
#line 179
      configparseerr___6(ads___7, fn, lno, "invalid address `%s\' in sortlist", tbuf);
      }
#line 180
      goto while_continue;
    }
#line 183
    if (slash) {
      {
#line 184
      tmp___2 = strchr((char const   *)slash, '.');
      }
#line 184
      if (tmp___2) {
        {
#line 185
        tmp___1 = inet_aton((char const   *)slash, & mask);
        }
#line 185
        if (! tmp___1) {
          {
#line 186
          configparseerr___6(ads___7, fn, lno, "invalid mask `%s\' in sortlist", slash);
          }
#line 187
          goto while_continue;
        }
#line 189
        if (base.s_addr & ~ mask.s_addr) {
          {
#line 190
          configparseerr___6(ads___7, fn, lno, "mask `%s\' in sortlist overlaps address `%s\'",
                             slash, tbuf);
          }
#line 192
          goto while_continue;
        }
      } else {
        {
#line 195
        initial = strtoul((char const   */* __restrict  */)slash, (char **/* __restrict  */)(& ep),
                          10);
        }
#line 196
        if (*ep) {
          {
#line 197
          configparseerr___6(ads___7, fn, lno, "mask length `%s\' invalid", slash);
          }
#line 198
          goto while_continue;
        } else
#line 196
        if (initial > 32UL) {
          {
#line 197
          configparseerr___6(ads___7, fn, lno, "mask length `%s\' invalid", slash);
          }
#line 198
          goto while_continue;
        }
        {
#line 200
        mask.s_addr = htonl((uint32_t )(4294967295UL << (32UL - initial)));
        }
      }
    } else {
      {
#line 203
      tmp___3 = ntohl(base.s_addr);
#line 203
      baselocal = (unsigned long )tmp___3;
      }
#line 204
      if ((unsigned long )(! baselocal) & 2147483648UL) {
        {
#line 205
        mask.s_addr = htonl((uint32_t )4278190080UL);
        }
      } else
#line 206
      if ((baselocal & 3221225472UL) == 2147483648UL) {
        {
#line 207
        mask.s_addr = htonl((uint32_t )4294901760UL);
        }
      } else
#line 208
      if ((baselocal & 4026531840UL) == 3758096384UL) {
        {
#line 209
        mask.s_addr = htonl((uint32_t )4278190080UL);
        }
      } else {
        {
#line 211
        configparseerr___6(ads___7, fn, lno, "network address `%s\' in sortlist is not in classed ranges, must specify mask explicitly",
                           tbuf);
        }
#line 214
        goto while_continue;
      }
    }
#line 218
    ads___7->sortlist[ads___7->nsortlist].base = base;
#line 219
    ads___7->sortlist[ads___7->nsortlist].mask = mask;
#line 220
    (ads___7->nsortlist) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  return;
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_options___6(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  char const   *word ;
  char *ep ;
  unsigned long v ;
  int l ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 231
  if (! buf___17) {
#line 231
    return;
  }
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 233
    tmp___5 = nextword___6(& buf___17, & word, & l);
    }
#line 233
    if (! tmp___5) {
#line 233
      goto while_break;
    }
#line 234
    if (l == 5) {
      {
#line 234
      tmp = memcmp((void const   *)word, (void const   *)"debug", (size_t )5);
      }
#line 234
      if (! tmp) {
#line 235
        ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 8U);
#line 236
        goto while_continue;
      }
    }
#line 238
    if (l >= 6) {
      {
#line 238
      tmp___0 = memcmp((void const   *)word, (void const   *)"ndots:", (size_t )6);
      }
#line 238
      if (! tmp___0) {
        {
#line 239
        v = strtoul((char const   */* __restrict  */)(word + 6), (char **/* __restrict  */)(& ep),
                    10);
        }
#line 240
        if (l == 6) {
          {
#line 241
          configparseerr___6(ads___7, fn, lno, "option `%.*s\' malformed or has bad value",
                             l, word);
          }
#line 243
          goto while_continue;
        } else
#line 240
        if ((unsigned long )ep != (unsigned long )(word + l)) {
          {
#line 241
          configparseerr___6(ads___7, fn, lno, "option `%.*s\' malformed or has bad value",
                             l, word);
          }
#line 243
          goto while_continue;
        } else
#line 240
        if (v > 2147483647UL) {
          {
#line 241
          configparseerr___6(ads___7, fn, lno, "option `%.*s\' malformed or has bad value",
                             l, word);
          }
#line 243
          goto while_continue;
        }
#line 245
        ads___7->searchndots = (int )v;
#line 246
        goto while_continue;
      }
    }
#line 248
    if (l >= 12) {
      {
#line 248
      tmp___4 = memcmp((void const   *)word, (void const   *)"adns_checkc:", (size_t )12);
      }
#line 248
      if (! tmp___4) {
        {
#line 249
        tmp___3 = strcmp(word + 12, "none");
        }
#line 249
        if (tmp___3) {
          {
#line 252
          tmp___2 = strcmp(word + 12, "entex");
          }
#line 252
          if (tmp___2) {
            {
#line 255
            tmp___1 = strcmp(word + 12, "freq");
            }
#line 255
            if (tmp___1) {
              {
#line 258
              configparseerr___6(ads___7, fn, lno, "option adns_checkc has bad value `%s\' (must be none, entex or freq",
                                 word + 12);
              }
            } else {
#line 256
              ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 768U);
            }
          } else {
#line 253
            ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags & 4294966527U);
#line 254
            ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 256U);
          }
        } else {
#line 250
          ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags & 4294966527U);
#line 251
          ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 256U);
        }
#line 261
        goto while_continue;
      }
    }
    {
#line 263
    adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown option `%.*s\'", fn, lno,
               l, word);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 265
  return;
}
}
#line 267 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_clearnss___6(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 


  {
#line 269
  ads___7->nservers = 0;
#line 270
  return;
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_include___6(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 


  {
#line 274
  if (! *buf___17) {
    {
#line 275
    configparseerr___6(ads___7, fn, lno, "`include\' directive with no filename");
    }
#line 276
    return;
  }
  {
#line 278
  readconfig___6(ads___7, buf___17, 1);
  }
#line 279
  return;
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void ccf_lookup___6(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  int found_bind ;
  char const   *word ;
  int l ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 283
  found_bind = 0;
#line 287
  if (! *buf___17) {
    {
#line 288
    configparseerr___6(ads___7, fn, lno, "`lookup\' directive with no databases");
    }
#line 289
    return;
  }
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 292
    tmp___2 = nextword___6(& buf___17, & word, & l);
    }
#line 292
    if (! tmp___2) {
#line 292
      goto while_break;
    }
#line 293
    if (l == 4) {
      {
#line 293
      tmp___1 = memcmp((void const   *)word, (void const   *)"bind", (size_t )4);
      }
#line 293
      if (tmp___1) {
#line 293
        goto _L___0;
      } else {
#line 294
        found_bind = 1;
      }
    } else
    _L___0: /* CIL Label */ 
#line 295
    if (l == 4) {
      {
#line 295
      tmp___0 = memcmp((void const   *)word, (void const   *)"file", (size_t )4);
      }
#line 295
      if (tmp___0) {
#line 295
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 297
    if (l == 2) {
      {
#line 297
      tmp = memcmp((void const   *)word, (void const   *)"yp", (size_t )2);
      }
#line 297
      if (tmp) {
        {
#line 301
        adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown `lookup\' database `%.*s\'",
                   fn, lno, l, word);
#line 303
        found_bind = -1;
        }
      } else {
        {
#line 298
        adns__diag(ads___7, -1, (adns_query )0, "%s:%d: yp lookups not supported by adns",
                   fn, lno);
#line 299
        found_bind = -1;
        }
      }
    } else {
      {
#line 301
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown `lookup\' database `%.*s\'",
                 fn, lno, l, word);
#line 303
      found_bind = -1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 306
  if (! found_bind) {
    {
#line 307
    adns__diag(ads___7, -1, (adns_query )0, "%s:%d: `lookup\' specified, but not `bind\'",
               fn, lno);
    }
  }
#line 308
  return;
}
}
#line 310 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static struct configcommandinfo  const  configcommandinfos___6[9]  = 
#line 310
  {      {"nameserver", & ccf_nameserver___6}, 
        {"domain", & ccf_search___6}, 
        {"search", & ccf_search___6}, 
        {"sortlist", & ccf_sortlist___6}, 
        {"options", & ccf_options___6}, 
        {"clearnameservers", & ccf_clearnss___6}, 
        {"include", & ccf_include___6}, 
        {"lookup", & ccf_lookup___6}, 
        {(char const   *)0, (void (*)(adns_state ads , char const   *fn , int lno , char const   *buf ))0}};
#line 330 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int gl_file___6(adns_state ads___7 , getline_ctx *src_io , char const   *filename ,
                       int lno , char *buf___17 , int buflen ) 
{ 
  FILE *file ;
  int c ;
  int i ;
  char *p ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 332
  file = src_io->file;
#line 336
  p = buf___17;
#line 337
  buflen --;
#line 338
  i = 0;
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (i == buflen) {
      {
#line 342
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: line too long, ignored", filename,
                 lno);
      }
#line 343
      goto x_badline;
    }
    {
#line 345
    c = _IO_getc(file);
    }
#line 346
    if (! c) {
      {
#line 347
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: line contains nul, ignored",
                 filename, lno);
      }
#line 348
      goto x_badline;
    } else
#line 349
    if (c == 10) {
#line 350
      goto while_break;
    } else
#line 351
    if (c == -1) {
      {
#line 352
      tmp___2 = ferror(file);
      }
#line 352
      if (tmp___2) {
        {
#line 353
        tmp = __errno_location();
#line 353
        saveerr___6(ads___7, *tmp);
#line 354
        tmp___0 = __errno_location();
#line 354
        tmp___1 = strerror(*tmp___0);
#line 354
        adns__diag(ads___7, -1, (adns_query )0, "%s:%d: read error: %s", filename,
                   lno, tmp___1);
        }
#line 356
        return (-1);
      }
#line 358
      if (! i) {
#line 358
        return (-1);
      }
#line 359
      goto while_break;
    } else {
#line 361
      tmp___3 = p;
#line 361
      p ++;
#line 361
      *tmp___3 = (char )c;
#line 362
      i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 366
  tmp___4 = p;
#line 366
  p ++;
#line 366
  *tmp___4 = (char)0;
#line 367
  return (i);
  x_badline: 
  {
#line 370
  saveerr___6(ads___7, 22);
  }
  {
#line 371
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 371
    c = _IO_getc(file);
    }
#line 371
    if (c != -1) {
#line 371
      if (! (c != 10)) {
#line 371
        goto while_break___0;
      }
    } else {
#line 371
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 372
  return (-2);
}
}
#line 375 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int gl_text___6(adns_state ads___7 , getline_ctx *src_io , char const   *filename ,
                       int lno , char *buf___17 , int buflen ) 
{ 
  char const   *cp ;
  int l ;
  size_t tmp ;

  {
#line 377
  cp = src_io->text;
#line 380
  if (! cp) {
#line 380
    return (-1);
  } else
#line 380
  if (! *cp) {
#line 380
    return (-1);
  }
#line 382
  if ((int const   )*cp == 59) {
#line 382
    cp ++;
  } else
#line 382
  if ((int const   )*cp == 10) {
#line 382
    cp ++;
  }
  {
#line 383
  tmp = strcspn(cp, ";\n");
#line 383
  l = (int )tmp;
#line 384
  src_io->text = cp + l;
  }
#line 386
  if (l >= buflen) {
    {
#line 387
    adns__diag(ads___7, -1, (adns_query )0, "%s:%d: line too long, ignored", filename,
               lno);
#line 388
    saveerr___6(ads___7, 22);
    }
#line 389
    return (-2);
  }
  {
#line 392
  memcpy((void */* __restrict  */)buf___17, (void const   */* __restrict  */)cp, (size_t )l);
#line 393
  *(buf___17 + l) = (char)0;
  }
#line 394
  return (l);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfiggeneric___6(adns_state ads___7 , char const   *filename , int (*getline___0)(adns_state ads ,
                                                                                                   getline_ctx * ,
                                                                                                   char const   *filename ,
                                                                                                   int lno ,
                                                                                                   char *buf ,
                                                                                                   int buflen ) ,
                                  getline_ctx gl_ctx ) 
{ 
  char linebuf[2000] ;
  char *p ;
  char *q ;
  int lno ;
  int l ;
  int dirl ;
  struct configcommandinfo  const  *ccip ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 410
  lno = 1;
  {
#line 410
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 410
    l = (*getline___0)(ads___7, & gl_ctx, filename, lno, linebuf, (int )sizeof(linebuf));
    }
#line 410
    if (! (l != -1)) {
#line 410
      goto while_break;
    }
#line 413
    if (l == -2) {
#line 413
      goto __Cont;
    }
    {
#line 414
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 414
      if (l > 0) {
        {
#line 414
        tmp = ctype_whitespace((int )linebuf[l - 1]);
        }
#line 414
        if (! tmp) {
#line 414
          goto while_break___0;
        }
      } else {
#line 414
        goto while_break___0;
      }
#line 414
      l --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 415
    linebuf[l] = (char)0;
#line 416
    p = linebuf;
    {
#line 417
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 417
      tmp___0 = ctype_whitespace((int )*p);
      }
#line 417
      if (! tmp___0) {
#line 417
        goto while_break___1;
      }
#line 417
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 418
    if ((int )*p == 35) {
#line 418
      goto __Cont;
    } else
#line 418
    if ((int )*p == 59) {
#line 418
      goto __Cont;
    } else
#line 418
    if (! *p) {
#line 418
      goto __Cont;
    }
#line 419
    q = p;
    {
#line 420
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 420
      if (*q) {
        {
#line 420
        tmp___1 = ctype_whitespace((int )*q);
        }
#line 420
        if (tmp___1) {
#line 420
          goto while_break___2;
        }
      } else {
#line 420
        goto while_break___2;
      }
#line 420
      q ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 421
    dirl = (int )(q - p);
#line 422
    ccip = configcommandinfos___6;
    {
#line 422
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 422
      if (ccip->name) {
        {
#line 422
        tmp___2 = strlen((char const   *)ccip->name);
        }
#line 422
        if (tmp___2 == (size_t )dirl) {
          {
#line 422
          tmp___3 = memcmp((void const   *)ccip->name, (void const   *)p, (size_t )(q - p));
          }
#line 422
          if (! tmp___3) {
#line 422
            goto while_break___3;
          }
        }
      } else {
#line 422
        goto while_break___3;
      }
#line 422
      ccip ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 426
    if (! ccip->name) {
      {
#line 427
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown configuration directive `%.*s\'",
                 filename, lno, (int )(q - p), p);
      }
#line 429
      goto __Cont;
    }
    {
#line 431
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 431
      tmp___4 = ctype_whitespace((int )*q);
      }
#line 431
      if (! tmp___4) {
#line 431
        goto while_break___4;
      }
#line 431
      q ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 432
    (*(ccip->fn))(ads___7, filename, lno, (char const   *)q);
    }
    __Cont: /* CIL Label */ 
#line 410
    lno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 434
  return;
}
}
#line 436 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static char const   *instrum_getenv___6(adns_state ads___7 , char const   *envvar ) 
{ 
  char const   *value ;
  char *tmp ;

  {
  {
#line 439
  tmp = getenv(envvar);
#line 439
  value = (char const   *)tmp;
  }
#line 440
  if (! value) {
    {
#line 440
    adns__debug(ads___7, -1, (adns_query )0, "environment variable %s not set", envvar);
    }
  } else {
    {
#line 441
    adns__debug(ads___7, -1, (adns_query )0, "environment variable %s set to `%s\'",
                envvar, value);
    }
  }
#line 443
  return (value);
}
}
#line 446 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfig___6(adns_state ads___7 , char const   *filename , int warnmissing ) 
{ 
  getline_ctx gl_ctx ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 449
  gl_ctx.file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 450
  if (! gl_ctx.file) {
    {
#line 451
    tmp = __errno_location();
    }
#line 451
    if (*tmp == 2) {
#line 452
      if (warnmissing) {
        {
#line 453
        adns__debug(ads___7, -1, (adns_query )0, "configuration file `%s\' does not exist",
                    filename);
        }
      }
#line 455
      return;
    }
    {
#line 457
    tmp___0 = __errno_location();
#line 457
    saveerr___6(ads___7, *tmp___0);
#line 458
    tmp___1 = __errno_location();
#line 458
    tmp___2 = strerror(*tmp___1);
#line 458
    adns__diag(ads___7, -1, (adns_query )0, "cannot open configuration file `%s\': %s",
               filename, tmp___2);
    }
#line 460
    return;
  }
  {
#line 463
  readconfiggeneric___6(ads___7, filename, & gl_file___6, gl_ctx);
#line 465
  fclose(gl_ctx.file);
  }
#line 466
  return;
}
}
#line 468 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfigtext___6(adns_state ads___7 , char const   *text , char const   *showname ) 
{ 
  getline_ctx gl_ctx ;

  {
  {
#line 472
  gl_ctx.text = text;
#line 473
  readconfiggeneric___6(ads___7, showname, & gl_text___6, gl_ctx);
  }
#line 474
  return;
}
}
#line 476 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfigenv___6(adns_state ads___7 , char const   *envvar ) 
{ 
  char const   *filename ;

  {
#line 479
  if ((unsigned int )ads___7->iflags & 1U) {
    {
#line 480
    adns__debug(ads___7, -1, (adns_query )0, "not checking environment variable `%s\'",
                envvar);
    }
#line 481
    return;
  }
  {
#line 483
  filename = instrum_getenv___6(ads___7, envvar);
  }
#line 484
  if (filename) {
    {
#line 484
    readconfig___6(ads___7, filename, 1);
    }
  }
#line 485
  return;
}
}
#line 487 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void readconfigenvtext___6(adns_state ads___7 , char const   *envvar ) 
{ 
  char const   *textdata ;

  {
#line 490
  if ((unsigned int )ads___7->iflags & 1U) {
    {
#line 491
    adns__debug(ads___7, -1, (adns_query )0, "not checking environment variable `%s\'",
                envvar);
    }
#line 492
    return;
  }
  {
#line 494
  textdata = instrum_getenv___6(ads___7, envvar);
  }
#line 495
  if (textdata) {
    {
#line 495
    readconfigtext___6(ads___7, textdata, envvar);
    }
  }
#line 496
  return;
}
}
#line 508 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int init_begin___6(adns_state *ads_r , adns_initflags flags , adns_logcallbackfn *logfn ,
                          void *logfndata ) 
{ 
  adns_state ads___7 ;
  pid_t pid ;
  void *tmp ;
  int *tmp___0 ;
  adns_query tmp___1 ;
  adns_query tmp___2 ;
  adns_query tmp___3 ;
  adns_query tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __suseconds_t tmp___9 ;

  {
  {
#line 513
  tmp = Hmalloc(sizeof(*ads___7));
#line 513
  ads___7 = (adns_state )tmp;
  }
#line 513
  if (! ads___7) {
    {
#line 513
    tmp___0 = __errno_location();
    }
#line 513
    return (*tmp___0);
  }
  {
#line 515
  ads___7->iflags = flags;
#line 516
  ads___7->logfn = logfn;
#line 517
  ads___7->logfndata = logfndata;
#line 518
  ads___7->configerrno = 0;
#line 519
  tmp___1 = (adns_query )0;
#line 519
  ads___7->udpw.tail = tmp___1;
#line 519
  ads___7->udpw.head = tmp___1;
#line 520
  tmp___2 = (adns_query )0;
#line 520
  ads___7->tcpw.tail = tmp___2;
#line 520
  ads___7->tcpw.head = tmp___2;
#line 521
  tmp___3 = (adns_query )0;
#line 521
  ads___7->childw.tail = tmp___3;
#line 521
  ads___7->childw.head = tmp___3;
#line 522
  tmp___4 = (adns_query )0;
#line 522
  ads___7->output.tail = tmp___4;
#line 522
  ads___7->output.head = tmp___4;
#line 523
  ads___7->forallnext = (adns_query )0;
#line 524
  ads___7->nextid = 12575;
#line 525
  tmp___5 = -1;
#line 525
  ads___7->tcpsocket = tmp___5;
#line 525
  ads___7->udpsocket = tmp___5;
#line 526
  adns__vbuf_init(& ads___7->tcpsend);
#line 527
  adns__vbuf_init(& ads___7->tcprecv);
#line 528
  ads___7->tcprecv_skip = 0;
#line 529
  tmp___8 = 0;
#line 529
  ads___7->tcpserver = tmp___8;
#line 529
  tmp___7 = tmp___8;
#line 529
  ads___7->nsearchlist = tmp___7;
#line 529
  tmp___6 = tmp___7;
#line 529
  ads___7->nsortlist = tmp___6;
#line 529
  ads___7->nservers = tmp___6;
#line 530
  ads___7->searchndots = 1;
#line 531
  ads___7->tcpstate = (enum adns__tcpstate )0;
#line 532
  tmp___9 = (__suseconds_t )0;
#line 532
  ads___7->tcptimeout.tv_usec = tmp___9;
#line 532
  ads___7->tcptimeout.tv_sec = tmp___9;
#line 533
  ads___7->searchlist = (char **)0;
#line 535
  pid = Hgetpid();
#line 536
  ads___7->rand48xsubi[0] = (unsigned short )pid;
#line 537
  ads___7->rand48xsubi[1] = (unsigned short )((unsigned long )pid >> 16);
#line 538
  ads___7->rand48xsubi[2] = (unsigned short )((unsigned long )pid ^ ((unsigned long )pid >> 16));
#line 540
  *ads_r = ads___7;
  }
#line 541
  return (0);
}
}
#line 544 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int init_finish___6(adns_state ads___7 ) 
{ 
  struct in_addr ia ;
  struct protoent *proto ;
  int r ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 549
  if (! ads___7->nservers) {
#line 550
    if (ads___7->logfn) {
#line 550
      if ((unsigned int )ads___7->iflags & 8U) {
        {
#line 551
        adns__lprintf(ads___7, "adns: no nameservers, using localhost\n");
        }
      }
    }
    {
#line 552
    ia.s_addr = htonl((in_addr_t )2130706433);
#line 553
    addserver___6(ads___7, ia);
    }
  }
  {
#line 556
  proto = getprotobyname("udp");
  }
#line 556
  if (! proto) {
#line 556
    r = 92;
#line 556
    goto x_free;
  }
  {
#line 557
  ads___7->udpsocket = Hsocket(2, 2, proto->p_proto);
  }
#line 558
  if (ads___7->udpsocket < 0) {
    {
#line 558
    tmp = __errno_location();
#line 558
    r = *tmp;
    }
#line 558
    goto x_free;
  }
  {
#line 560
  r = adns__setnonblock(ads___7, ads___7->udpsocket);
  }
#line 561
  if (r) {
    {
#line 561
    tmp___0 = __errno_location();
#line 561
    r = *tmp___0;
    }
#line 561
    goto x_closeudp;
  }
#line 563
  return (0);
  x_closeudp: 
  {
#line 566
  Hclose(ads___7->udpsocket);
  }
  x_free: 
  {
#line 568
  Hfree((void *)ads___7);
  }
#line 569
  return (r);
}
}
#line 572 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void init_abort___6(adns_state ads___7 ) 
{ 


  {
#line 573
  if (ads___7->nsearchlist) {
    {
#line 574
    Hfree((void *)*(ads___7->searchlist + 0));
#line 575
    Hfree((void *)ads___7->searchlist);
    }
  }
  {
#line 577
  Hfree((void *)ads___7);
  }
#line 578
  return;
}
}
#line 580 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static void logfn_file___6(adns_state ads___7 , void *logfndata , char const   *fmt ,
                           va_list al ) 
{ 


  {
  {
#line 582
  vfprintf((FILE */* __restrict  */)logfndata, (char const   */* __restrict  */)fmt,
           al);
  }
#line 583
  return;
}
}
#line 585 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int init_files___6(adns_state *ads_r , adns_initflags flags , adns_logcallbackfn *logfn ,
                          void *logfndata ) 
{ 
  adns_state ads___7 ;
  char const   *res_options ;
  char const   *adns_res_options ;
  int r ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 591
  r = init_begin___6(& ads___7, flags, logfn, logfndata);
  }
#line 592
  if (r) {
#line 592
    return (r);
  }
  {
#line 594
  res_options = instrum_getenv___6(ads___7, "RES_OPTIONS");
#line 595
  adns_res_options = instrum_getenv___6(ads___7, "ADNS_RES_OPTIONS");
#line 596
  ccf_options___6(ads___7, "RES_OPTIONS", -1, res_options);
#line 597
  ccf_options___6(ads___7, "ADNS_RES_OPTIONS", -1, adns_res_options);
#line 599
  readconfig___6(ads___7, "/etc/resolv.conf", 1);
#line 600
  readconfig___6(ads___7, "/etc/resolv-adns.conf", 0);
#line 601
  readconfigenv___6(ads___7, "RES_CONF");
#line 602
  readconfigenv___6(ads___7, "ADNS_RES_CONF");
#line 604
  readconfigenvtext___6(ads___7, "RES_CONF_TEXT");
#line 605
  readconfigenvtext___6(ads___7, "ADNS_RES_CONF_TEXT");
#line 607
  ccf_options___6(ads___7, "RES_OPTIONS", -1, res_options);
#line 608
  ccf_options___6(ads___7, "ADNS_RES_OPTIONS", -1, adns_res_options);
#line 610
  tmp = instrum_getenv___6(ads___7, "LOCALDOMAIN");
#line 610
  ccf_search___6(ads___7, "LOCALDOMAIN", -1, tmp);
#line 611
  tmp___0 = instrum_getenv___6(ads___7, "ADNS_LOCALDOMAIN");
#line 611
  ccf_search___6(ads___7, "ADNS_LOCALDOMAIN", -1, tmp___0);
  }
#line 613
  if (ads___7->configerrno) {
#line 613
    if (ads___7->configerrno != 22) {
      {
#line 614
      r = ads___7->configerrno;
#line 615
      init_abort___6(ads___7);
      }
#line 616
      return (r);
    }
  }
  {
#line 619
  r = init_finish___6(ads___7);
  }
#line 620
  if (r) {
#line 620
    return (r);
  }
  {
#line 622
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
#line 623
  *ads_r = ads___7;
  }
#line 624
  return (0);
}
}
#line 631 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/setup.c"
static int init_strcfg___6(adns_state *ads_r , adns_initflags flags , adns_logcallbackfn *logfn ,
                           void *logfndata , char const   *configtext ) 
{ 
  adns_state ads___7 ;
  int r ;

  {
  {
#line 637
  r = init_begin___6(& ads___7, flags, logfn, logfndata);
  }
#line 638
  if (r) {
#line 638
    return (r);
  }
  {
#line 640
  readconfigtext___6(ads___7, configtext, "<supplied configuration text>");
  }
#line 641
  if (ads___7->configerrno) {
    {
#line 642
    r = ads___7->configerrno;
#line 643
    init_abort___6(ads___7);
    }
#line 644
    return (r);
  }
  {
#line 647
  r = init_finish___6(ads___7);
  }
#line 647
  if (r) {
#line 647
    return (r);
  }
  {
#line 648
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
#line 649
  *ads_r = ads___7;
  }
#line 650
  return (0);
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static adns_query query_alloc___6(adns_state ads___7 , typeinfo const   *typei , adns_rrtype type ,
                                  adns_queryflags flags , struct timeval now ) 
{ 
  adns_query qu ;
  void *tmp ;
  void *tmp___0 ;
  adns_query tmp___1 ;
  adns_query tmp___2 ;
  adns_query tmp___3 ;
  adns_query tmp___4 ;
  allocnode *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __suseconds_t tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 45
  tmp = Hmalloc(sizeof(*qu));
#line 45
  qu = (adns_query )tmp;
  }
#line 45
  if (! qu) {
#line 45
    return ((adns_query )0);
  }
  {
#line 46
  tmp___0 = Hmalloc(sizeof(*(qu->answer)));
#line 46
  qu->answer = (adns_answer *)tmp___0;
  }
#line 47
  if (! qu->answer) {
    {
#line 47
    Hfree((void *)qu);
    }
#line 47
    return ((adns_query )0);
  }
  {
#line 49
  qu->ads = ads___7;
#line 50
  qu->state = (enum __anonenum_state_83 )0;
#line 51
  tmp___2 = (adns_query )0;
#line 51
  qu->parent = tmp___2;
#line 51
  tmp___1 = tmp___2;
#line 51
  qu->next = tmp___1;
#line 51
  qu->back = tmp___1;
#line 52
  tmp___3 = (adns_query )0;
#line 52
  qu->children.tail = tmp___3;
#line 52
  qu->children.head = tmp___3;
#line 53
  tmp___4 = (adns_query )0;
#line 53
  qu->siblings.back = tmp___4;
#line 53
  qu->siblings.next = tmp___4;
#line 54
  tmp___5 = (allocnode *)0;
#line 54
  qu->allocations.tail = tmp___5;
#line 54
  qu->allocations.head = tmp___5;
#line 55
  qu->interim_allocd = 0;
#line 56
  qu->preserved_allocd = 0;
#line 57
  qu->final_allocspace = (void *)0;
#line 59
  qu->typei = typei;
#line 60
  qu->query_dgram = (byte *)0;
#line 61
  qu->query_dglen = 0;
#line 62
  adns__vbuf_init(& qu->vb);
#line 64
  qu->cname_dgram = (byte *)0;
#line 65
  tmp___6 = 0;
#line 65
  qu->cname_begin = tmp___6;
#line 65
  qu->cname_dglen = tmp___6;
#line 67
  adns__vbuf_init(& qu->search_vb);
#line 68
  tmp___8 = 0;
#line 68
  qu->search_doneabs = tmp___8;
#line 68
  tmp___7 = tmp___8;
#line 68
  qu->search_pos = tmp___7;
#line 68
  qu->search_origlen = tmp___7;
#line 70
  qu->id = -2;
#line 71
  qu->flags = (int )flags;
#line 72
  qu->retries = 0;
#line 73
  qu->udpnextserver = 0;
#line 74
  qu->udpsent = 0UL;
#line 75
  tmp___9 = (__suseconds_t )0;
#line 75
  qu->timeout.tv_usec = tmp___9;
#line 75
  qu->timeout.tv_sec = tmp___9;
#line 76
  qu->expires = now.tv_sec + 604800L;
#line 78
  memset((void *)(& qu->ctx), 0, sizeof(qu->ctx));
#line 80
  (qu->answer)->status = (adns_status )0;
#line 81
  tmp___10 = (char *)0;
#line 81
  (qu->answer)->owner = tmp___10;
#line 81
  (qu->answer)->cname = tmp___10;
#line 82
  (qu->answer)->type = type;
#line 83
  (qu->answer)->expires = (time_t )-1;
#line 84
  (qu->answer)->nrrs = 0;
#line 85
  (qu->answer)->rrs.untyped = (void *)0;
#line 86
  (qu->answer)->rrsz = (int )typei->rrsz;
  }
#line 88
  return (qu);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void query_submit___6(adns_state ads___7 , adns_query qu , typeinfo const   *typei ,
                             vbuf *qumsg_vb , int id , adns_queryflags flags , struct timeval now ) 
{ 
  void *tmp ;

  {
  {
#line 98
  qu->vb = *qumsg_vb;
#line 99
  adns__vbuf_init(qumsg_vb);
#line 101
  tmp = Hmalloc((size_t )qu->vb.used);
#line 101
  qu->query_dgram = (byte *)tmp;
  }
#line 102
  if (! qu->query_dgram) {
    {
#line 102
    adns__query_fail(qu, (adns_status )1);
    }
#line 102
    return;
  }
  {
#line 104
  qu->id = id;
#line 105
  qu->query_dglen = qu->vb.used;
#line 106
  memcpy((void */* __restrict  */)qu->query_dgram, (void const   */* __restrict  */)qu->vb.buf,
         (size_t )qu->vb.used);
#line 108
  adns__query_send(qu, now);
  }
#line 109
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void query_simple___6(adns_state ads___7 , adns_query qu , char const   *owner ,
                             int ol , typeinfo const   *typei , adns_queryflags flags ,
                             struct timeval now ) 
{ 
  vbuf vb_new ;
  int id ;
  adns_status stat ;

  {
  {
#line 136
  stat = adns__mkquery(ads___7, & qu->vb, & id, owner, ol, typei, (qu->answer)->type,
                       flags);
  }
#line 138
  if (stat) {
#line 139
    if ((unsigned int )stat == 202U) {
#line 139
      if ((unsigned int )flags & 1U) {
        {
#line 140
        adns__search_next(ads___7, qu, now);
        }
#line 141
        return;
      } else {
        {
#line 143
        adns__query_fail(qu, stat);
        }
#line 144
        return;
      }
    } else {
      {
#line 143
      adns__query_fail(qu, stat);
      }
#line 144
      return;
    }
  }
  {
#line 148
  vb_new = qu->vb;
#line 149
  adns__vbuf_init(& qu->vb);
#line 150
  query_submit___6(ads___7, qu, typei, & vb_new, id, flags, now);
  }
#line 151
  return;
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static int save_owner___6(adns_query qu , char const   *owner , int ol ) 
{ 
  adns_answer *ans ;
  void *tmp ;

  {
#line 198
  if (! (qu->flags & 4)) {
#line 198
    return (1);
  }
#line 200
  ans = qu->answer;
#line 201
  if (! (! ans->owner)) {
    {
#line 201
    __assert_fail("!ans->owner", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c",
                  201U, "save_owner");
    }
  }
  {
#line 203
  tmp = adns__alloc_preserved(qu, (size_t )(ol + 1));
#line 203
  ans->owner = (char *)tmp;
  }
#line 203
  if (! ans->owner) {
#line 203
    return (0);
  }
  {
#line 205
  memcpy((void */* __restrict  */)ans->owner, (void const   */* __restrict  */)owner,
         (size_t )ol);
#line 206
  *(ans->owner + ol) = (char)0;
  }
#line 207
  return (1);
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void *alloc_common___6(adns_query qu , size_t sz ) 
{ 
  allocnode *an ;
  void *tmp ;

  {
#line 342
  if (! sz) {
#line 342
    return ((void *)qu);
  }
#line 343
  if (! (! qu->final_allocspace)) {
    {
#line 343
    __assert_fail("!qu->final_allocspace", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c",
                  343U, "alloc_common");
    }
  }
  {
#line 344
  tmp = Hmalloc((((((((sizeof(*an) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ) + sz) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ));
#line 344
  an = (allocnode *)tmp;
  }
#line 345
  if (! an) {
#line 345
    return ((void *)0);
  }
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 346
    an->next = (struct allocnode *)0;
#line 346
    an->back = qu->allocations.tail;
#line 346
    if (qu->allocations.tail) {
#line 346
      (qu->allocations.tail)->next = an;
    } else {
#line 346
      qu->allocations.head = an;
    }
#line 346
    qu->allocations.tail = an;
#line 346
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 347
  return ((void *)((byte *)an + (((sizeof(*an) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign )));
}
}
#line 410 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void cancel_children___6(adns_query qu ) 
{ 
  adns_query cqu ;
  adns_query ncqu ;

  {
#line 413
  cqu = qu->children.head;
  {
#line 413
  while (1) {
    while_continue: /* CIL Label */ ;
#line 413
    if (! cqu) {
#line 413
      goto while_break;
    }
    {
#line 414
    ncqu = cqu->siblings.next;
#line 415
    adns_cancel(cqu);
#line 413
    cqu = ncqu;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 417
  return;
}
}
#line 427 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void free_query_allocs___6(adns_query qu ) 
{ 
  allocnode *an ;
  allocnode *ann ;
  allocnode *tmp ;

  {
  {
#line 430
  cancel_children___6(qu);
#line 431
  an = qu->allocations.head;
  }
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    if (! an) {
#line 431
      goto while_break;
    }
    {
#line 431
    ann = an->next;
#line 431
    Hfree((void *)an);
#line 431
    an = ann;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 432
  tmp = (allocnode *)0;
#line 432
  qu->allocations.tail = tmp;
#line 432
  qu->allocations.head = tmp;
#line 433
  adns__vbuf_free(& qu->vb);
#line 434
  adns__vbuf_free(& qu->search_vb);
#line 435
  Hfree((void *)qu->query_dgram);
#line 436
  qu->query_dgram = (byte *)0;
  }
#line 437
  return;
}
}
#line 477 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/query.c"
static void makefinal_query___6(adns_query qu ) 
{ 
  adns_answer *ans ;
  int rrn ;
  void *tmp ;

  {
#line 481
  ans = qu->answer;
#line 483
  if (qu->interim_allocd) {
    {
#line 484
    tmp = Hrealloc((void *)qu->answer, (((((((sizeof(*ans) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ) + (unsigned long )qu->interim_allocd) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ));
#line 484
    ans = (adns_answer *)tmp;
    }
#line 486
    if (! ans) {
#line 486
      goto x_nomem;
    }
#line 487
    qu->answer = ans;
  }
  {
#line 490
  qu->final_allocspace = (void *)((byte *)ans + (((sizeof(*ans) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ));
#line 491
  adns__makefinal_str(qu, & ans->cname);
#line 492
  adns__makefinal_str(qu, & ans->owner);
  }
#line 494
  if (ans->nrrs) {
    {
#line 495
    adns__makefinal_block(qu, & ans->rrs.untyped, (size_t )(ans->nrrs * ans->rrsz));
#line 497
    rrn = 0;
    }
    {
#line 497
    while (1) {
      while_continue: /* CIL Label */ ;
#line 497
      if (! (rrn < ans->nrrs)) {
#line 497
        goto while_break;
      }
      {
#line 498
      (*((qu->typei)->makefinal))(qu, (void *)(ans->rrs.bytes + rrn * ans->rrsz));
#line 497
      rrn ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 501
  free_query_allocs___6(qu);
  }
#line 502
  return;
  x_nomem: 
  {
#line 505
  qu->preserved_allocd = 0;
#line 506
  (qu->answer)->cname = (char *)0;
#line 507
  (qu->answer)->owner = (char *)0;
#line 508
  adns__reset_preserved(qu);
#line 510
  (qu->answer)->status = (adns_status )1;
#line 511
  free_query_allocs___6(qu);
  }
#line 512
  return;
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_qstring___6(parseinfo const   *pai , int *cbyte_io , int max ,
                                   int *len_r , char **str_r ) 
{ 
  byte const   *dgram ;
  int l ;
  int cbyte___3 ;
  char *str ;
  int tmp ;
  void *tmp___0 ;

  {
#line 92
  dgram = (byte const   *)pai->dgram;
#line 96
  cbyte___3 = *cbyte_io;
#line 98
  if (cbyte___3 >= max) {
#line 98
    return ((adns_status )104);
  }
#line 99
  tmp = cbyte___3;
#line 99
  cbyte___3 ++;
#line 99
  l = (int )((int const   )*(dgram + tmp) & 255);
#line 100
  if (cbyte___3 + l > max) {
#line 100
    return ((adns_status )104);
  }
  {
#line 102
  tmp___0 = adns__alloc_interim((adns_query )pai->qu, (size_t )(l + 1));
#line 102
  str = (char *)tmp___0;
  }
#line 103
  if (! str) {
#line 103
    return ((adns_status )1);
  }
  {
#line 105
  *(str + l) = (char)0;
#line 106
  memcpy((void */* __restrict  */)str, (void const   */* __restrict  */)(dgram + cbyte___3),
         (size_t )l);
#line 108
  *len_r = l;
#line 109
  *str_r = str;
#line 110
  *cbyte_io = cbyte___3 + l;
  }
#line 112
  return ((adns_status )0);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_qstring___6(vbuf *vb___0 , char const   *dp , int len ) 
{ 
  unsigned char ch ;
  char buf___17[10] ;
  int cn ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 120
    tmp = adns__vbuf_appendstr(vb___0, "\"");
    }
#line 120
    if (! tmp) {
#line 120
      return ((adns_status )1);
    }
#line 120
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  cn = 0;
  {
#line 121
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 121
    if (! (cn < len)) {
#line 121
      goto while_break___0;
    }
#line 122
    tmp___0 = dp;
#line 122
    dp ++;
#line 122
    ch = (unsigned char )*tmp___0;
#line 123
    if ((int )ch == 92) {
      {
#line 124
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 124
        tmp___1 = adns__vbuf_appendstr(vb___0, "\\\\");
        }
#line 124
        if (! tmp___1) {
#line 124
          return ((adns_status )1);
        }
#line 124
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else
#line 125
    if ((int )ch == 34) {
      {
#line 126
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 126
        tmp___2 = adns__vbuf_appendstr(vb___0, "\\\"");
        }
#line 126
        if (! tmp___2) {
#line 126
          return ((adns_status )1);
        }
#line 126
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else
#line 127
    if ((int )ch >= 32) {
#line 127
      if ((int )ch <= 126) {
        {
#line 128
        tmp___3 = adns__vbuf_append(vb___0, (byte const   *)(& ch), 1);
        }
#line 128
        if (! tmp___3) {
#line 128
          return ((adns_status )1);
        }
      } else {
#line 127
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 130
      sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"\\x%02x",
              (int )ch);
      }
      {
#line 131
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 131
        tmp___4 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
        }
#line 131
        if (! tmp___4) {
#line 131
          return ((adns_status )1);
        }
#line 131
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 121
    cn ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 134
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 134
    tmp___5 = adns__vbuf_appendstr(vb___0, "\"");
    }
#line 134
    if (! tmp___5) {
#line 134
      return ((adns_status )1);
    }
#line 134
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 136
  return ((adns_status )0);
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_str___6(adns_query qu , void *datap ) 
{ 
  char **rrp ;

  {
  {
#line 144
  rrp = (char **)datap;
#line 146
  adns__makefinal_str(qu, rrp);
  }
#line 147
  return;
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_intstr___6(adns_query qu , void *datap ) 
{ 
  adns_rr_intstr *rrp ;

  {
  {
#line 154
  rrp = (adns_rr_intstr *)datap;
#line 156
  adns__makefinal_str(qu, & rrp->str);
  }
#line 157
  return;
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_manyistr___6(adns_query qu , void *datap ) 
{ 
  adns_rr_intstr **rrp ;
  adns_rr_intstr *te ;
  adns_rr_intstr *table ;
  void *tablev ;
  int tc ;

  {
#line 164
  rrp = (adns_rr_intstr **)datap;
#line 169
  tc = 0;
#line 169
  te = *rrp;
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    if (! (te->i >= 0)) {
#line 169
      goto while_break;
    }
#line 169
    te ++;
#line 169
    tc ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 170
  tablev = (void *)*rrp;
#line 171
  adns__makefinal_block(qu, & tablev, sizeof(*te) * (unsigned long )(tc + 1));
#line 172
  table = (adns_rr_intstr *)tablev;
#line 172
  *rrp = table;
#line 173
  te = *rrp;
  }
  {
#line 173
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 173
    if (! (te->i >= 0)) {
#line 173
      goto while_break___0;
    }
    {
#line 174
    adns__makefinal_str(qu, & te->str);
#line 173
    te ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 175
  return;
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_txt___6(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  adns_rr_intstr **rrp ;
  adns_rr_intstr *table ;
  adns_rr_intstr *te ;
  byte const   *dgram ;
  int ti ;
  int tc ;
  int l ;
  int startbyte ;
  adns_status st ;
  int tmp ;
  void *tmp___0 ;

  {
#line 183
  rrp = (adns_rr_intstr **)datap;
#line 184
  dgram = (byte const   *)pai->dgram;
#line 188
  startbyte = cbyte___3;
#line 189
  if (cbyte___3 >= max) {
#line 189
    return ((adns_status )104);
  }
#line 190
  tc = 0;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! (cbyte___3 < max)) {
#line 191
      goto while_break;
    }
#line 192
    tmp = cbyte___3;
#line 192
    cbyte___3 ++;
#line 192
    l = (int )((int const   )*(dgram + tmp) & 255);
#line 193
    cbyte___3 += l;
#line 194
    tc ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  if (cbyte___3 != max) {
#line 196
    return ((adns_status )104);
  } else
#line 196
  if (! tc) {
#line 196
    return ((adns_status )104);
  }
  {
#line 198
  tmp___0 = adns__alloc_interim((adns_query )pai->qu, sizeof(*table) * (unsigned long )(tc + 1));
#line 198
  table = (adns_rr_intstr *)tmp___0;
  }
#line 199
  if (! table) {
#line 199
    return ((adns_status )1);
  }
#line 201
  cbyte___3 = startbyte;
#line 201
  ti = 0;
#line 201
  te = table;
  {
#line 201
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 201
    if (! (ti < tc)) {
#line 201
      goto while_break___0;
    }
    {
#line 202
    st = pap_qstring___6(pai, & cbyte___3, max, & te->i, & te->str);
    }
#line 203
    if (st) {
#line 203
      return (st);
    }
#line 201
    ti ++;
#line 201
    te ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 205
  if (! (cbyte___3 == max)) {
    {
#line 205
    __assert_fail("cbyte == max", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  205U, "pa_txt");
    }
  }
#line 207
  te->i = -1;
#line 208
  te->str = (char *)0;
#line 210
  *rrp = table;
#line 211
  return ((adns_status )0);
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_txt___6(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_intstr const   * const  *rrp ;
  adns_rr_intstr const   *current ;
  adns_status st ;
  int spc ;
  int tmp ;

  {
#line 215
  rrp = (adns_rr_intstr const   * const  *)datap;
#line 220
  current = (adns_rr_intstr const   *)*rrp;
#line 220
  spc = 0;
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    if (! (current->i >= 0)) {
#line 220
      goto while_break;
    }
#line 221
    if (spc) {
      {
#line 221
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 221
        tmp = adns__vbuf_appendstr(vb___0, " ");
        }
#line 221
        if (! tmp) {
#line 221
          return ((adns_status )1);
        }
#line 221
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 222
    st = csp_qstring___6(vb___0, (char const   *)current->str, (int )current->i);
    }
#line 222
    if (st) {
#line 222
      return (st);
    }
#line 220
    current ++;
#line 220
    spc = 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  return ((adns_status )0);
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_hinfo___6(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_intstrpair const   *rrp ;
  adns_status st ;
  int tmp ;

  {
  {
#line 232
  rrp = (adns_rr_intstrpair const   *)datap;
#line 235
  st = csp_qstring___6(vb___0, (char const   *)rrp->array[0].str, (int )rrp->array[0].i);
  }
#line 235
  if (st) {
#line 235
    return (st);
  }
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 236
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 236
    if (! tmp) {
#line 236
      return ((adns_status )1);
    }
#line 236
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 237
  st = csp_qstring___6(vb___0, (char const   *)rrp->array[1].str, (int )rrp->array[1].i);
  }
#line 237
  if (st) {
#line 237
    return (st);
  }
#line 238
  return ((adns_status )0);
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_inaddr___6(parseinfo const   *pai , int cbyte___3 , int max ,
                                 void *datap ) 
{ 
  struct in_addr *storeto ;

  {
#line 247
  storeto = (struct in_addr *)datap;
#line 249
  if (max - cbyte___3 != 4) {
#line 249
    return ((adns_status )104);
  }
  {
#line 250
  memcpy((void */* __restrict  */)storeto, (void const   */* __restrict  */)(pai->dgram + cbyte___3),
         (size_t )4);
  }
#line 251
  return ((adns_status )0);
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int search_sortlist___6(adns_state ads___7 , struct in_addr ad ) 
{ 
  struct sortlist  const  *slp ;
  int i ;

  {
#line 258
  i = 0;
#line 258
  slp = (struct sortlist  const  *)(ads___7->sortlist);
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 258
    if (i < ads___7->nsortlist) {
#line 258
      if (! (! ((ad.s_addr & (unsigned int )slp->mask.s_addr) == (unsigned int )slp->base.s_addr))) {
#line 258
        goto while_break;
      }
    } else {
#line 258
      goto while_break;
    }
#line 258
    i ++;
#line 258
    slp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  return (i);
}
}
#line 265 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int dip_inaddr___6(adns_state ads___7 , struct in_addr a , struct in_addr b ) 
{ 
  int ai ;
  int bi ;

  {
#line 268
  if (! ads___7->nsortlist) {
#line 268
    return (0);
  }
  {
#line 270
  ai = search_sortlist___6(ads___7, a);
#line 271
  bi = search_sortlist___6(ads___7, b);
  }
#line 272
  return (bi < ai);
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_inaddr___6(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  struct in_addr  const  *ap ;
  struct in_addr  const  *bp ;
  int tmp ;

  {
  {
#line 277
  ap = (struct in_addr  const  *)datap_a;
#line 277
  bp = (struct in_addr  const  *)datap_b;
#line 279
  tmp = dip_inaddr___6(ads___7, (struct in_addr )*ap, (struct in_addr )*bp);
  }
#line 279
  return (tmp);
}
}
#line 282 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_inaddr___6(vbuf *vb___0 , void const   *datap ) 
{ 
  struct in_addr  const  *rrp ;
  struct in_addr rr ;
  char const   *ia ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 283
  rrp = (struct in_addr  const  *)datap;
#line 283
  rr = *rrp;
#line 286
  tmp = inet_ntoa(rr);
#line 286
  ia = (char const   *)tmp;
  }
#line 286
  if (! ia) {
    {
#line 286
    __assert_fail("ia", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  286U, "cs_inaddr");
    }
  }
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 287
    tmp___0 = adns__vbuf_appendstr(vb___0, ia);
    }
#line 287
    if (! tmp___0) {
#line 287
      return ((adns_status )1);
    }
#line 287
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  return ((adns_status )0);
}
}
#line 295 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_addr___6(parseinfo const   *pai , int cbyte___3 , int max ,
                               void *datap ) 
{ 
  adns_rr_addr *storeto ;
  byte const   *dgram ;

  {
#line 297
  storeto = (adns_rr_addr *)datap;
#line 298
  dgram = (byte const   *)pai->dgram;
#line 300
  if (max - cbyte___3 != 4) {
#line 300
    return ((adns_status )104);
  }
  {
#line 301
  storeto->len = (int )sizeof(storeto->addr.inet);
#line 302
  memset((void *)(& storeto->addr), 0, sizeof(storeto->addr.inet));
#line 303
  storeto->addr.inet.sin_family = (sa_family_t )2;
#line 304
  memcpy((void */* __restrict  */)(& storeto->addr.inet.sin_addr), (void const   */* __restrict  */)(dgram + cbyte___3),
         (size_t )4);
  }
#line 305
  return ((adns_status )0);
}
}
#line 308 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_addr___6(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_addr const   *ap ;
  adns_rr_addr const   *bp ;
  int tmp ;

  {
#line 309
  ap = (adns_rr_addr const   *)datap_a;
#line 309
  bp = (adns_rr_addr const   *)datap_b;
#line 311
  if (! ((int const   )ap->addr.sa.sa_family == 2)) {
    {
#line 311
    __assert_fail("ap->addr.sa.sa_family == 2", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  311U, "di_addr");
    }
  }
  {
#line 312
  tmp = dip_inaddr___6(ads___7, (struct in_addr )ap->addr.inet.sin_addr, (struct in_addr )bp->addr.inet.sin_addr);
  }
#line 312
  return (tmp);
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int div_addr___6(void *context , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_state ads___7 ;
  int tmp ;

  {
  {
#line 316
  ads___7 = (adns_state )context;
#line 318
  tmp = di_addr___6(ads___7, datap_a, datap_b);
  }
#line 318
  return (tmp);
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_addr___6(vbuf *vb___0 , adns_rr_addr const   *rrp ) 
{ 
  char const   *ia ;
  char buf___17[30] ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 326
  if ((int const   )rrp->addr.inet.sin_family == 2) {
#line 326
    goto case_2;
  }
#line 331
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 327
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 327
    tmp = adns__vbuf_appendstr(vb___0, "INET ");
    }
#line 327
    if (! tmp) {
#line 327
      return ((adns_status )1);
    }
#line 327
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 328
  tmp___0 = inet_ntoa((struct in_addr )rrp->addr.inet.sin_addr);
#line 328
  ia = (char const   *)tmp___0;
  }
#line 328
  if (! ia) {
    {
#line 328
    __assert_fail("ia", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  328U, "csp_addr");
    }
  }
  {
#line 329
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 329
    tmp___1 = adns__vbuf_appendstr(vb___0, ia);
    }
#line 329
    if (! tmp___1) {
#line 329
      return ((adns_status )1);
    }
#line 329
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 330
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 332
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"AF=%u",
          (int const   )rrp->addr.sa.sa_family);
  }
  {
#line 333
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 333
    tmp___2 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 333
    if (! tmp___2) {
#line 333
      return ((adns_status )1);
    }
#line 333
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 334
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 336
  return ((adns_status )0);
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_addr___6(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_addr const   *rrp ;
  adns_status tmp ;

  {
  {
#line 340
  rrp = (adns_rr_addr const   *)datap;
#line 342
  tmp = csp_addr___6(vb___0, rrp);
  }
#line 342
  return (tmp);
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_domain___6(parseinfo const   *pai , int *cbyte_io , int max ,
                                  char **domain_r , parsedomain_flags flags ) 
{ 
  adns_status st ;
  char *dm ;
  void *tmp ;

  {
  {
#line 355
  st = adns__parse_domain((pai->qu)->ads, (int )pai->serv, (adns_query )pai->qu, & (pai->qu)->vb,
                          flags, (byte const   *)pai->dgram, (int )pai->dglen, cbyte_io,
                          max);
  }
#line 357
  if (st) {
#line 357
    return (st);
  }
#line 358
  if (! (pai->qu)->vb.used) {
#line 358
    return ((adns_status )104);
  }
  {
#line 360
  tmp = adns__alloc_interim((adns_query )pai->qu, (size_t )((pai->qu)->vb.used + 1));
#line 360
  dm = (char *)tmp;
  }
#line 361
  if (! dm) {
#line 361
    return ((adns_status )1);
  }
  {
#line 363
  *(dm + (pai->qu)->vb.used) = (char)0;
#line 364
  memcpy((void */* __restrict  */)dm, (void const   */* __restrict  */)(pai->qu)->vb.buf,
         (size_t )(pai->qu)->vb.used);
#line 366
  *domain_r = dm;
  }
#line 367
  return ((adns_status )0);
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_domain___6(vbuf *vb___0 , char const   *domain ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 371
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 371
    tmp = adns__vbuf_appendstr(vb___0, domain);
    }
#line 371
    if (! tmp) {
#line 371
      return ((adns_status )1);
    }
#line 371
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 372
  if (! *domain) {
    {
#line 372
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 372
      tmp___0 = adns__vbuf_appendstr(vb___0, ".");
      }
#line 372
      if (! tmp___0) {
#line 372
        return ((adns_status )1);
      }
#line 372
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 373
  return ((adns_status )0);
}
}
#line 376 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_domain___6(vbuf *vb___0 , void const   *datap ) 
{ 
  char const   * const  *domainp ;
  adns_status tmp ;

  {
  {
#line 377
  domainp = (char const   * const  *)datap;
#line 378
  tmp = csp_domain___6(vb___0, (char const   *)*domainp);
  }
#line 378
  return (tmp);
}
}
#line 381 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_dom_raw___6(parseinfo const   *pai , int cbyte___3 , int max ,
                                  void *datap ) 
{ 
  char **rrp ;
  adns_status st ;

  {
  {
#line 383
  rrp = (char **)datap;
#line 386
  st = pap_domain___6(pai, & cbyte___3, max, rrp, (parsedomain_flags )1);
  }
#line 387
  if (st) {
#line 387
    return (st);
  }
#line 389
  if (cbyte___3 != max) {
#line 389
    return ((adns_status )104);
  }
#line 390
  return ((adns_status )0);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_host_raw___6(parseinfo const   *pai , int cbyte___3 , int max ,
                                   void *datap ) 
{ 
  char **rrp ;
  adns_status st ;
  int tmp ;

  {
#line 399
  rrp = (char **)datap;
#line 402
  if ((pai->qu)->flags & 64) {
#line 402
    tmp = 1;
  } else {
#line 402
    tmp = 0;
  }
  {
#line 402
  st = pap_domain___6(pai, & cbyte___3, max, rrp, (parsedomain_flags )tmp);
  }
#line 404
  if (st) {
#line 404
    return (st);
  }
#line 406
  if (cbyte___3 != max) {
#line 406
    return ((adns_status )104);
  }
#line 407
  return ((adns_status )0);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_findaddrs___6(parseinfo const   *pai , adns_rr_hostaddr *ha ,
                                     int *cbyte_io , int count , int dmstart ) 
{ 
  int rri ;
  int naddrs ;
  int type ;
  int class ;
  int rdlen ;
  int rdstart ;
  int ownermatched ;
  unsigned long ttl ;
  adns_status st ;
  int tmp ;
  void *tmp___0 ;

  {
#line 421
  rri = 0;
#line 421
  naddrs = -1;
  {
#line 421
  while (1) {
    while_continue: /* CIL Label */ ;
#line 421
    if (! (rri < count)) {
#line 421
      goto while_break;
    }
    {
#line 422
    st = adns__findrr_anychk((adns_query )pai->qu, (int )pai->serv, (byte const   *)pai->dgram,
                             (int )pai->dglen, cbyte_io, & type, & class, & ttl, & rdlen,
                             & rdstart, (byte const   *)pai->dgram, (int )pai->dglen,
                             dmstart, & ownermatched);
    }
#line 426
    if (st) {
#line 426
      return (st);
    }
#line 427
    if (! ownermatched) {
#line 427
      goto _L;
    } else
#line 427
    if (class != 1) {
#line 427
      goto _L;
    } else
#line 427
    if (type != 1) {
      _L: /* CIL Label */ 
#line 428
      if (naddrs > 0) {
#line 428
        goto while_break;
      } else {
#line 428
        goto __Cont;
      }
    }
#line 430
    if (naddrs == -1) {
#line 431
      naddrs = 0;
    }
    {
#line 433
    tmp = adns__vbuf_ensure(& (pai->qu)->vb, (int )((unsigned long )(naddrs + 1) * sizeof(adns_rr_addr )));
    }
#line 433
    if (! tmp) {
#line 434
      return ((adns_status )1);
    }
    {
#line 435
    adns__update_expires((adns_query )pai->qu, ttl, (struct timeval )pai->now);
#line 436
    st = pa_addr___6(pai, rdstart, rdstart + rdlen, (void *)((pai->qu)->vb.buf + (unsigned long )naddrs * sizeof(adns_rr_addr )));
    }
#line 438
    if (st) {
#line 438
      return (st);
    }
#line 439
    naddrs ++;
    __Cont: /* CIL Label */ 
#line 421
    rri ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 441
  if (naddrs >= 0) {
    {
#line 442
    tmp___0 = adns__alloc_interim((adns_query )pai->qu, (unsigned long )naddrs * sizeof(adns_rr_addr ));
#line 442
    ha->addrs = (adns_rr_addr *)tmp___0;
    }
#line 443
    if (! ha->addrs) {
#line 443
      return ((adns_status )1);
    }
    {
#line 444
    memcpy((void */* __restrict  */)ha->addrs, (void const   */* __restrict  */)(pai->qu)->vb.buf,
           (unsigned long )naddrs * sizeof(adns_rr_addr ));
#line 445
    ha->naddrs = naddrs;
#line 446
    ha->astatus = (adns_status )0;
#line 448
    adns__isort((void *)ha->addrs, naddrs, (int )sizeof(adns_rr_addr ), (void *)(pai->qu)->vb.buf,
                & div_addr___6, (void *)pai->ads);
    }
  }
#line 451
  return ((adns_status )0);
}
}
#line 454 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void icb_hostaddr___6(adns_query parent , adns_query child ) 
{ 
  adns_answer *cans ;
  adns_rr_hostaddr *rrp ;
  adns_state ads___7 ;
  adns_status st ;

  {
#line 455
  cans = child->answer;
#line 456
  rrp = child->ctx.info.hostaddr;
#line 457
  ads___7 = parent->ads;
#line 460
  st = cans->status;
#line 461
  rrp->astatus = st;
#line 462
  if ((unsigned int )st > 0U) {
#line 462
    if ((unsigned int )st <= 99U) {
#line 462
      rrp->naddrs = -1;
    } else {
#line 462
      rrp->naddrs = cans->nrrs;
    }
  } else {
#line 462
    rrp->naddrs = cans->nrrs;
  }
  {
#line 463
  rrp->addrs = cans->rrs.addr;
#line 464
  adns__transfer_interim(child, parent, (void *)rrp->addrs, (unsigned long )rrp->naddrs * sizeof(adns_rr_addr ));
  }
#line 467
  if (parent->children.head) {
    {
#line 468
    while (1) {
      while_continue: /* CIL Label */ ;
#line 468
      parent->next = (adns_query )0;
#line 468
      parent->back = ads___7->childw.tail;
#line 468
      if (ads___7->childw.tail) {
#line 468
        (ads___7->childw.tail)->next = parent;
      } else {
#line 468
        ads___7->childw.head = parent;
      }
#line 468
      ads___7->childw.tail = parent;
#line 468
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 470
    adns__query_done(parent);
    }
  }
#line 472
  return;
}
}
#line 474 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_hostaddr___6(parseinfo const   *pai , int *cbyte_io , int max ,
                                    adns_rr_hostaddr *rrp ) 
{ 
  adns_status st ;
  int dmstart ;
  int cbyte___3 ;
  qcontext ctx ;
  int id ;
  adns_query nqu ;
  adns_queryflags nflags ;
  int tmp ;
  typeinfo const   *tmp___0 ;

  {
#line 483
  cbyte___3 = *cbyte_io;
#line 483
  dmstart = cbyte___3;
#line 484
  if ((pai->qu)->flags & 64) {
#line 484
    tmp = 1;
  } else {
#line 484
    tmp = 0;
  }
  {
#line 484
  st = pap_domain___6(pai, & cbyte___3, max, & rrp->host, (parsedomain_flags )tmp);
  }
#line 486
  if (st) {
#line 486
    return (st);
  }
  {
#line 487
  *cbyte_io = cbyte___3;
#line 489
  rrp->astatus = (adns_status )0;
#line 490
  rrp->naddrs = -1;
#line 491
  rrp->addrs = (adns_rr_addr *)0;
#line 493
  cbyte___3 = (int )pai->nsstart;
#line 495
  st = pap_findaddrs___6(pai, rrp, & cbyte___3, (int )pai->nscount, dmstart);
  }
#line 496
  if (st) {
#line 496
    return (st);
  }
#line 497
  if (rrp->naddrs != -1) {
#line 497
    return ((adns_status )0);
  }
  {
#line 499
  st = pap_findaddrs___6(pai, rrp, & cbyte___3, (int )pai->arcount, dmstart);
  }
#line 500
  if (st) {
#line 500
    return (st);
  }
#line 501
  if (rrp->naddrs != -1) {
#line 501
    return ((adns_status )0);
  }
  {
#line 503
  st = adns__mkquery_frdgram((adns_state )pai->ads, & (pai->qu)->vb, & id, (byte const   *)pai->dgram,
                             (int )pai->dglen, dmstart, (adns_rrtype )65537, (adns_queryflags )16);
  }
#line 506
  if (st) {
#line 506
    return (st);
  }
#line 508
  ctx.ext = (void *)0;
#line 509
  ctx.callback = & icb_hostaddr___6;
#line 510
  ctx.info.hostaddr = rrp;
#line 512
  nflags = (adns_queryflags )16;
#line 513
  if (! ((pai->qu)->flags & 256)) {
#line 513
    nflags = (adns_queryflags )((unsigned int )nflags | 512U);
  }
  {
#line 515
  tmp___0 = adns__findtype((adns_rrtype )65537);
#line 515
  st = adns__internal_submit((adns_state )pai->ads, & nqu, tmp___0, & (pai->qu)->vb,
                             id, nflags, (struct timeval )pai->now, (qcontext const   *)(& ctx));
  }
#line 517
  if (st) {
#line 517
    return (st);
  }
#line 519
  nqu->parent = (adns_query )pai->qu;
  {
#line 520
  while (1) {
    while_continue: /* CIL Label */ ;
#line 520
    nqu->siblings.next = (adns_query )0;
#line 520
    nqu->siblings.back = (pai->qu)->children.tail;
#line 520
    if ((pai->qu)->children.tail) {
#line 520
      ((pai->qu)->children.tail)->siblings.next = nqu;
    } else {
#line 520
      (pai->qu)->children.head = nqu;
    }
#line 520
    (pai->qu)->children.tail = nqu;
#line 520
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 522
  return ((adns_status )0);
}
}
#line 525 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_hostaddr___6(parseinfo const   *pai , int cbyte___3 , int max ,
                                   void *datap ) 
{ 
  adns_rr_hostaddr *rrp ;
  adns_status st ;

  {
  {
#line 527
  rrp = (adns_rr_hostaddr *)datap;
#line 530
  st = pap_hostaddr___6(pai, & cbyte___3, max, rrp);
  }
#line 531
  if (st) {
#line 531
    return (st);
  }
#line 532
  if (cbyte___3 != max) {
#line 532
    return ((adns_status )104);
  }
#line 534
  return ((adns_status )0);
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int dip_hostaddr___6(adns_state ads___7 , adns_rr_hostaddr const   *ap , adns_rr_hostaddr const   *bp ) 
{ 
  int tmp ;

  {
#line 539
  if ((unsigned int const   )ap->astatus != (unsigned int const   )bp->astatus) {
#line 539
    return ((int )ap->astatus);
  }
#line 540
  if (ap->astatus) {
#line 540
    return (0);
  }
#line 542
  if (! ((int )(ap->addrs + 0)->addr.sa.sa_family == 2)) {
    {
#line 542
    __assert_fail("ap->addrs[0].addr.sa.sa_family == 2", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  542U, "dip_hostaddr");
    }
  }
#line 543
  if (! ((int )(bp->addrs + 0)->addr.sa.sa_family == 2)) {
    {
#line 543
    __assert_fail("bp->addrs[0].addr.sa.sa_family == 2", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                  543U, "dip_hostaddr");
    }
  }
  {
#line 544
  tmp = dip_inaddr___6(ads___7, (ap->addrs + 0)->addr.inet.sin_addr, (bp->addrs + 0)->addr.inet.sin_addr);
  }
#line 544
  return (tmp);
}
}
#line 549 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_hostaddr___6(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_hostaddr const   *ap ;
  adns_rr_hostaddr const   *bp ;
  int tmp ;

  {
  {
#line 551
  ap = (adns_rr_hostaddr const   *)datap_a;
#line 551
  bp = (adns_rr_hostaddr const   *)datap_b;
#line 553
  tmp = dip_hostaddr___6(ads___7, ap, bp);
  }
#line 553
  return (tmp);
}
}
#line 556 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mfp_hostaddr___6(adns_query qu , adns_rr_hostaddr *rrp ) 
{ 
  void *tablev ;

  {
  {
#line 559
  adns__makefinal_str(qu, & rrp->host);
#line 560
  tablev = (void *)rrp->addrs;
#line 561
  adns__makefinal_block(qu, & tablev, (unsigned long )rrp->naddrs * sizeof(*(rrp->addrs)));
#line 562
  rrp->addrs = (adns_rr_addr *)tablev;
  }
#line 563
  return;
}
}
#line 565 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_hostaddr___6(adns_query qu , void *datap ) 
{ 
  adns_rr_hostaddr *rrp ;

  {
  {
#line 566
  rrp = (adns_rr_hostaddr *)datap;
#line 568
  mfp_hostaddr___6(qu, rrp);
  }
#line 569
  return;
}
}
#line 571 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_hostaddr___6(vbuf *vb___0 , adns_rr_hostaddr const   *rrp ) 
{ 
  char const   *errstr ;
  adns_status st ;
  char buf___17[20] ;
  int i ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 577
  st = csp_domain___6(vb___0, (char const   *)rrp->host);
  }
#line 577
  if (st) {
#line 577
    return (st);
  }
  {
#line 579
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 579
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 579
    if (! tmp) {
#line 579
      return ((adns_status )1);
    }
#line 579
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 580
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 580
    tmp___0 = adns_errtypeabbrev((adns_status )rrp->astatus);
#line 580
    tmp___1 = adns__vbuf_appendstr(vb___0, tmp___0);
    }
#line 580
    if (! tmp___1) {
#line 580
      return ((adns_status )1);
    }
#line 580
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 582
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %d ",
          (unsigned int const   )rrp->astatus);
  }
  {
#line 583
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 583
    tmp___2 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 583
    if (! tmp___2) {
#line 583
      return ((adns_status )1);
    }
#line 583
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 585
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 585
    tmp___3 = adns_errabbrev((adns_status )rrp->astatus);
#line 585
    tmp___4 = adns__vbuf_appendstr(vb___0, tmp___3);
    }
#line 585
    if (! tmp___4) {
#line 585
      return ((adns_status )1);
    }
#line 585
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 586
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 586
    tmp___5 = adns__vbuf_appendstr(vb___0, " ");
    }
#line 586
    if (! tmp___5) {
#line 586
      return ((adns_status )1);
    }
#line 586
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 588
  errstr = adns_strerror((adns_status )rrp->astatus);
#line 589
  tmp___6 = strlen(errstr);
#line 589
  st = csp_qstring___6(vb___0, errstr, (int )tmp___6);
  }
#line 589
  if (st) {
#line 589
    return (st);
  }
#line 591
  if (rrp->naddrs >= 0) {
    {
#line 592
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 592
      tmp___7 = adns__vbuf_appendstr(vb___0, " (");
      }
#line 592
      if (! tmp___7) {
#line 592
        return ((adns_status )1);
      }
#line 592
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 593
    i = 0;
    {
#line 593
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 593
      if (! (i < (int )rrp->naddrs)) {
#line 593
        goto while_break___5;
      }
      {
#line 594
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 594
        tmp___8 = adns__vbuf_appendstr(vb___0, " ");
        }
#line 594
        if (! tmp___8) {
#line 594
          return ((adns_status )1);
        }
#line 594
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 595
      st = csp_addr___6(vb___0, (adns_rr_addr const   *)(rrp->addrs + i));
#line 593
      i ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 597
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 597
      tmp___9 = adns__vbuf_appendstr(vb___0, " )");
      }
#line 597
      if (! tmp___9) {
#line 597
        return ((adns_status )1);
      }
#line 597
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
  } else {
    {
#line 599
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 599
      tmp___10 = adns__vbuf_appendstr(vb___0, " ?");
      }
#line 599
      if (! tmp___10) {
#line 599
        return ((adns_status )1);
      }
#line 599
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
#line 601
  return ((adns_status )0);
}
}
#line 604 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_hostaddr___6(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_hostaddr const   *rrp ;
  adns_status tmp ;

  {
  {
#line 605
  rrp = (adns_rr_hostaddr const   *)datap;
#line 607
  tmp = csp_hostaddr___6(vb___0, rrp);
  }
#line 607
  return (tmp);
}
}
#line 614 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_mx_raw___6(parseinfo const   *pai , int cbyte___3 , int max ,
                                 void *datap ) 
{ 
  byte const   *dgram ;
  adns_rr_intstr *rrp ;
  adns_status st ;
  int pref ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 616
  dgram = (byte const   *)pai->dgram;
#line 617
  rrp = (adns_rr_intstr *)datap;
#line 621
  if (cbyte___3 + 2 > max) {
#line 621
    return ((adns_status )104);
  }
#line 622
  pref = 0;
#line 622
  tmp = cbyte___3;
#line 622
  cbyte___3 ++;
#line 622
  pref |= (int )(((int const   )*(dgram + tmp) & 255) << 8);
#line 622
  tmp___0 = cbyte___3;
#line 622
  cbyte___3 ++;
#line 622
  pref |= (int )((int const   )*(dgram + tmp___0) & 255);
#line 623
  rrp->i = pref;
#line 624
  if ((pai->qu)->flags & 64) {
#line 624
    tmp___1 = 1;
  } else {
#line 624
    tmp___1 = 0;
  }
  {
#line 624
  st = pap_domain___6(pai, & cbyte___3, max, & rrp->str, (parsedomain_flags )tmp___1);
  }
#line 626
  if (st) {
#line 626
    return (st);
  }
#line 628
  if (cbyte___3 != max) {
#line 628
    return ((adns_status )104);
  }
#line 629
  return ((adns_status )0);
}
}
#line 632 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_mx_raw___6(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_intstr const   *ap ;
  adns_rr_intstr const   *bp ;

  {
#line 633
  ap = (adns_rr_intstr const   *)datap_a;
#line 633
  bp = (adns_rr_intstr const   *)datap_b;
#line 635
  if (ap->i < bp->i) {
#line 635
    return (0);
  }
#line 636
  if (ap->i > bp->i) {
#line 636
    return (1);
  }
#line 637
  return (0);
}
}
#line 644 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_mx___6(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  byte const   *dgram ;
  adns_rr_inthostaddr *rrp ;
  adns_status st ;
  int pref ;
  int tmp ;
  int tmp___0 ;

  {
#line 646
  dgram = (byte const   *)pai->dgram;
#line 647
  rrp = (adns_rr_inthostaddr *)datap;
#line 651
  if (cbyte___3 + 2 > max) {
#line 651
    return ((adns_status )104);
  }
  {
#line 652
  pref = 0;
#line 652
  tmp = cbyte___3;
#line 652
  cbyte___3 ++;
#line 652
  pref |= (int )(((int const   )*(dgram + tmp) & 255) << 8);
#line 652
  tmp___0 = cbyte___3;
#line 652
  cbyte___3 ++;
#line 652
  pref |= (int )((int const   )*(dgram + tmp___0) & 255);
#line 653
  rrp->i = pref;
#line 654
  st = pap_hostaddr___6(pai, & cbyte___3, max, & rrp->ha);
  }
#line 655
  if (st) {
#line 655
    return (st);
  }
#line 657
  if (cbyte___3 != max) {
#line 657
    return ((adns_status )104);
  }
#line 658
  return ((adns_status )0);
}
}
#line 661 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_mx___6(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_inthostaddr const   *ap ;
  adns_rr_inthostaddr const   *bp ;
  int tmp ;

  {
#line 662
  ap = (adns_rr_inthostaddr const   *)datap_a;
#line 662
  bp = (adns_rr_inthostaddr const   *)datap_b;
#line 664
  if (ap->i < bp->i) {
#line 664
    return (0);
  }
#line 665
  if (ap->i > bp->i) {
#line 665
    return (1);
  }
  {
#line 666
  tmp = dip_hostaddr___6(ads___7, & ap->ha, & bp->ha);
  }
#line 666
  return (tmp);
}
}
#line 673 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_inthostaddr___6(adns_query qu , void *datap ) 
{ 
  adns_rr_inthostaddr *rrp ;

  {
  {
#line 674
  rrp = (adns_rr_inthostaddr *)datap;
#line 676
  mfp_hostaddr___6(qu, & rrp->ha);
  }
#line 677
  return;
}
}
#line 679 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_inthostaddr___6(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_inthostaddr const   *rrp ;
  char buf___17[10] ;
  int tmp ;
  adns_status tmp___0 ;

  {
  {
#line 680
  rrp = (adns_rr_inthostaddr const   *)datap;
#line 683
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"%u ",
          rrp->i);
  }
  {
#line 684
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 684
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 684
    if (! tmp) {
#line 684
      return ((adns_status )1);
    }
#line 684
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 686
  tmp___0 = csp_hostaddr___6(vb___0, & rrp->ha);
  }
#line 686
  return (tmp___0);
}
}
#line 693 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_inthost___6(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_intstr const   *rrp ;
  char buf___17[10] ;
  int tmp ;
  adns_status tmp___0 ;

  {
  {
#line 694
  rrp = (adns_rr_intstr const   *)datap;
#line 697
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"%u ",
          rrp->i);
  }
  {
#line 698
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 698
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 698
    if (! tmp) {
#line 698
      return ((adns_status )1);
    }
#line 698
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 699
  tmp___0 = csp_domain___6(vb___0, (char const   *)rrp->str);
  }
#line 699
  return (tmp___0);
}
}
#line 706 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void icb_ptr___6(adns_query parent , adns_query child ) 
{ 
  adns_answer *cans ;
  adns_rr_addr const   *queried ;
  adns_rr_addr const   *found ;
  adns_state ads___7 ;
  int i ;
  int tmp ;

  {
#line 707
  cans = child->answer;
#line 709
  ads___7 = parent->ads;
#line 712
  if ((unsigned int )cans->status == 300U) {
    {
#line 713
    adns__query_fail(parent, (adns_status )100);
    }
#line 714
    return;
  } else
#line 712
  if ((unsigned int )cans->status == 301U) {
    {
#line 713
    adns__query_fail(parent, (adns_status )100);
    }
#line 714
    return;
  } else
#line 715
  if (cans->status) {
    {
#line 716
    adns__query_fail(parent, cans->status);
    }
#line 717
    return;
  }
#line 720
  queried = (adns_rr_addr const   *)(& parent->ctx.info.ptr_parent_addr);
#line 721
  i = 0;
#line 721
  found = (adns_rr_addr const   *)cans->rrs.addr;
  {
#line 721
  while (1) {
    while_continue: /* CIL Label */ ;
#line 721
    if (! (i < cans->nrrs)) {
#line 721
      goto while_break;
    }
#line 722
    if (queried->len == found->len) {
      {
#line 722
      tmp = memcmp((void const   *)(& queried->addr), (void const   *)(& found->addr),
                   (size_t )queried->len);
      }
#line 722
      if (! tmp) {
#line 724
        if (! parent->children.head) {
          {
#line 725
          adns__query_done(parent);
          }
#line 726
          return;
        } else {
          {
#line 728
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 728
            parent->next = (adns_query )0;
#line 728
            parent->back = ads___7->childw.tail;
#line 728
            if (ads___7->childw.tail) {
#line 728
              (ads___7->childw.tail)->next = parent;
            } else {
#line 728
              ads___7->childw.head = parent;
            }
#line 728
            ads___7->childw.tail = parent;
#line 728
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 729
          return;
        }
      }
    }
#line 721
    i ++;
#line 721
    found ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 734
  adns__query_fail(parent, (adns_status )100);
  }
#line 735
  return;
}
}
#line 739
static adns_status pa_ptr___6(parseinfo const   *pai , int dmstart , int max , void *datap ) ;
#line 739 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static char const   * const  expectdomain___6[2]  = {      (char const   */* const  */)"in-addr",      (char const   */* const  */)"arpa"};
#line 737 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_ptr___6(parseinfo const   *pai , int dmstart , int max , void *datap ) 
{ 
  char **rrp ;
  adns_status st ;
  adns_rr_addr *ap ;
  findlabel_state fls ;
  char *ep ;
  byte ipv[4] ;
  char labbuf[4] ;
  int cbyte___3 ;
  int i ;
  int lablen ;
  int labstart ;
  int l ;
  int id ;
  adns_query nqu ;
  qcontext ctx ;
  int tmp ;
  unsigned long tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  typeinfo const   *tmp___3 ;

  {
#line 741
  rrp = (char **)datap;
#line 752
  cbyte___3 = dmstart;
#line 753
  if ((pai->qu)->flags & 64) {
#line 753
    tmp = 1;
  } else {
#line 753
    tmp = 0;
  }
  {
#line 753
  st = pap_domain___6(pai, & cbyte___3, max, rrp, (parsedomain_flags )tmp);
  }
#line 755
  if (st) {
#line 755
    return (st);
  }
#line 756
  if (cbyte___3 != max) {
#line 756
    return ((adns_status )104);
  }
#line 758
  ap = & (pai->qu)->ctx.info.ptr_parent_addr;
#line 759
  if (! ap->len) {
    {
#line 760
    adns__findlabel_start(& fls, (adns_state )pai->ads, -1, (adns_query )pai->qu,
                          (byte const   *)(pai->qu)->query_dgram, (pai->qu)->query_dglen,
                          (pai->qu)->query_dglen, 12, (int *)0);
#line 763
    i = 0;
    }
    {
#line 763
    while (1) {
      while_continue: /* CIL Label */ ;
#line 763
      if (! (i < 4)) {
#line 763
        goto while_break;
      }
      {
#line 764
      st = adns__findlabel_next(& fls, & lablen, & labstart);
      }
#line 764
      if (! (! st)) {
        {
#line 764
        __assert_fail("!st", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                      764U, "pa_ptr");
        }
      }
#line 765
      if (lablen <= 0) {
#line 765
        return ((adns_status )200);
      } else
#line 765
      if (lablen > 3) {
#line 765
        return ((adns_status )200);
      }
      {
#line 766
      memcpy((void */* __restrict  */)(labbuf), (void const   */* __restrict  */)((pai->qu)->query_dgram + labstart),
             (size_t )lablen);
#line 767
      labbuf[lablen] = (char)0;
#line 768
      tmp___0 = strtoul((char const   */* __restrict  */)(labbuf), (char **/* __restrict  */)(& ep),
                        10);
#line 768
      ipv[3 - i] = (byte )tmp___0;
      }
#line 769
      if (*ep) {
#line 769
        return ((adns_status )200);
      }
#line 770
      if (lablen > 1) {
#line 770
        if ((int )*((pai->qu)->query_dgram + labstart) == 48) {
#line 771
          return ((adns_status )200);
        }
      }
#line 763
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 773
    i = 0;
    {
#line 773
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 773
      if (! ((unsigned long )i < sizeof(expectdomain___6) / sizeof(expectdomain___6[0]))) {
#line 773
        goto while_break___0;
      }
      {
#line 774
      st = adns__findlabel_next(& fls, & lablen, & labstart);
      }
#line 774
      if (! (! st)) {
        {
#line 774
        __assert_fail("!st", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                      774U, "pa_ptr");
        }
      }
      {
#line 775
      tmp___1 = strlen((char const   *)expectdomain___6[i]);
#line 775
      l = (int )tmp___1;
      }
#line 776
      if (lablen != l) {
#line 778
        return ((adns_status )200);
      } else {
        {
#line 776
        tmp___2 = memcmp((void const   *)((pai->qu)->query_dgram + labstart), (void const   *)expectdomain___6[i],
                         (size_t )l);
        }
#line 776
        if (tmp___2) {
#line 778
          return ((adns_status )200);
        }
      }
#line 773
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 780
    st = adns__findlabel_next(& fls, & lablen, (int *)0);
    }
#line 780
    if (! (! st)) {
      {
#line 780
      __assert_fail("!st", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                    780U, "pa_ptr");
      }
    }
#line 781
    if (lablen) {
#line 781
      return ((adns_status )200);
    }
    {
#line 783
    ap->len = (int )sizeof(struct sockaddr_in );
#line 784
    memset((void *)(& ap->addr), 0, sizeof(ap->addr.inet));
#line 785
    ap->addr.inet.sin_family = (sa_family_t )2;
#line 786
    ap->addr.inet.sin_addr.s_addr = htonl((uint32_t )(((((int )ipv[0] << 24) | ((int )ipv[1] << 16)) | ((int )ipv[2] << 8)) | (int )ipv[3]));
    }
  }
  {
#line 790
  st = adns__mkquery_frdgram((adns_state )pai->ads, & (pai->qu)->vb, & id, (byte const   *)pai->dgram,
                             (int )pai->dglen, dmstart, (adns_rrtype )65537, (adns_queryflags )16);
  }
#line 793
  if (st) {
#line 793
    return (st);
  }
  {
#line 795
  ctx.ext = (void *)0;
#line 796
  ctx.callback = & icb_ptr___6;
#line 797
  memset((void *)(& ctx.info), 0, sizeof(ctx.info));
#line 798
  tmp___3 = adns__findtype((adns_rrtype )65537);
#line 798
  st = adns__internal_submit((adns_state )pai->ads, & nqu, tmp___3, & (pai->qu)->vb,
                             id, (adns_queryflags )16, (struct timeval )pai->now,
                             (qcontext const   *)(& ctx));
  }
#line 801
  if (st) {
#line 801
    return (st);
  }
#line 803
  nqu->parent = (adns_query )pai->qu;
  {
#line 804
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 804
    nqu->siblings.next = (adns_query )0;
#line 804
    nqu->siblings.back = (pai->qu)->children.tail;
#line 804
    if ((pai->qu)->children.tail) {
#line 804
      ((pai->qu)->children.tail)->siblings.next = nqu;
    } else {
#line 804
      (pai->qu)->children.head = nqu;
    }
#line 804
    (pai->qu)->children.tail = nqu;
#line 804
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 805
  return ((adns_status )0);
}
}
#line 812 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_strpair___6(adns_query qu , void *datap ) 
{ 
  adns_rr_strpair *rrp ;

  {
  {
#line 813
  rrp = (adns_rr_strpair *)datap;
#line 815
  adns__makefinal_str(qu, & rrp->array[0]);
#line 816
  adns__makefinal_str(qu, & rrp->array[1]);
  }
#line 817
  return;
}
}
#line 823 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_intstrpair___6(adns_query qu , void *datap ) 
{ 
  adns_rr_intstrpair *rrp ;

  {
  {
#line 824
  rrp = (adns_rr_intstrpair *)datap;
#line 826
  adns__makefinal_str(qu, & rrp->array[0].str);
#line 827
  adns__makefinal_str(qu, & rrp->array[1].str);
  }
#line 828
  return;
}
}
#line 834 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_hinfo___6(parseinfo const   *pai , int cbyte___3 , int max ,
                                void *datap ) 
{ 
  adns_rr_intstrpair *rrp ;
  adns_status st ;
  int i ;

  {
#line 836
  rrp = (adns_rr_intstrpair *)datap;
#line 840
  i = 0;
  {
#line 840
  while (1) {
    while_continue: /* CIL Label */ ;
#line 840
    if (! (i < 2)) {
#line 840
      goto while_break;
    }
    {
#line 841
    st = pap_qstring___6(pai, & cbyte___3, max, & rrp->array[i].i, & rrp->array[i].str);
    }
#line 842
    if (st) {
#line 842
      return (st);
    }
#line 840
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 845
  if (cbyte___3 != max) {
#line 845
    return ((adns_status )104);
  }
#line 847
  return ((adns_status )0);
}
}
#line 854 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_mailbox822___6(parseinfo const   *pai , int *cbyte_io , int max ,
                                      char **mb_r ) 
{ 
  int lablen ;
  int labstart ;
  int i ;
  int needquote ;
  int c ;
  int r ;
  int neednorm ;
  unsigned char const   *p ;
  char *str ;
  findlabel_state fls ;
  adns_status st ;
  vbuf *vb___0 ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 863
  vb___0 = & (pai->qu)->vb;
#line 864
  vb___0->used = 0;
#line 865
  adns__findlabel_start(& fls, (adns_state )pai->ads, -1, (adns_query )pai->qu, (byte const   *)pai->dgram,
                        (int )pai->dglen, max, *cbyte_io, cbyte_io);
#line 869
  st = adns__findlabel_next(& fls, & lablen, & labstart);
  }
#line 870
  if (! lablen) {
    {
#line 871
    adns__vbuf_appendstr(vb___0, ".");
    }
#line 872
    goto x_ok;
  }
#line 875
  neednorm = 1;
#line 876
  i = 0;
#line 876
  needquote = 0;
#line 876
  p = (unsigned char const   *)(pai->dgram + labstart);
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (! (i < lablen)) {
#line 876
      goto while_break;
    }
#line 877
    tmp = p;
#line 877
    p ++;
#line 877
    c = (int )*tmp;
#line 878
    if ((c & -129) < 32) {
#line 878
      return ((adns_status )104);
    } else
#line 878
    if ((c & -129) == 127) {
#line 878
      return ((adns_status )104);
    }
#line 879
    if (c == 46) {
#line 879
      if (! neednorm) {
#line 879
        neednorm = 1;
      } else {
#line 879
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 880
    if (c == 32) {
#line 880
      needquote ++;
    } else
#line 880
    if (c >= 127) {
#line 880
      needquote ++;
    } else {
      {
#line 880
      tmp___0 = ctype_822special(c);
      }
#line 880
      if (tmp___0) {
#line 880
        needquote ++;
      } else {
#line 881
        neednorm = 0;
      }
    }
#line 876
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 884
  if (needquote) {
#line 884
    goto _L___0;
  } else
#line 884
  if (neednorm) {
    _L___0: /* CIL Label */ 
    {
#line 885
    r = adns__vbuf_ensure(vb___0, (lablen + needquote) + 4);
    }
#line 885
    if (! r) {
#line 885
      return ((adns_status )1);
    }
    {
#line 886
    adns__vbuf_appendq(vb___0, (byte const   *)"\"", 1);
#line 887
    i = 0;
#line 887
    needquote = 0;
#line 887
    p = (unsigned char const   *)(pai->dgram + labstart);
    }
    {
#line 887
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 887
      if (! (i < lablen)) {
#line 887
        goto while_break___0;
      }
#line 888
      c = (int )*p;
#line 889
      if (c == 34) {
        {
#line 889
        adns__vbuf_appendq(vb___0, (byte const   *)"\\", 1);
        }
      } else
#line 889
      if (c == 92) {
        {
#line 889
        adns__vbuf_appendq(vb___0, (byte const   *)"\\", 1);
        }
      }
      {
#line 890
      adns__vbuf_appendq(vb___0, p, 1);
#line 887
      i ++;
#line 887
      p ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 892
    adns__vbuf_appendq(vb___0, (byte const   *)"\"", 1);
    }
  } else {
    {
#line 894
    r = adns__vbuf_append(vb___0, (byte const   *)(pai->dgram + labstart), lablen);
    }
#line 894
    if (! r) {
#line 894
      return ((adns_status )1);
    }
  }
  {
#line 897
  r = adns__vbuf_appendstr(vb___0, "@");
  }
#line 897
  if (! r) {
#line 897
    return ((adns_status )1);
  }
  {
#line 899
  st = adns__parse_domain_more(& fls, (adns_state )pai->ads, (adns_query )pai->qu,
                               vb___0, (parsedomain_flags )0, (byte const   *)pai->dgram);
  }
#line 900
  if (st) {
#line 900
    return (st);
  }
  x_ok: 
  {
#line 903
  tmp___1 = adns__alloc_interim((adns_query )pai->qu, (size_t )(vb___0->used + 1));
#line 903
  str = (char *)tmp___1;
  }
#line 903
  if (! str) {
#line 903
    return ((adns_status )1);
  }
  {
#line 904
  memcpy((void */* __restrict  */)str, (void const   */* __restrict  */)vb___0->buf,
         (size_t )vb___0->used);
#line 905
  *(str + vb___0->used) = (char)0;
#line 906
  *mb_r = str;
  }
#line 907
  return ((adns_status )0);
}
}
#line 910 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_mailbox___6(parseinfo const   *pai , int *cbyte_io , int max ,
                                   char **mb_r ) 
{ 
  adns_status tmp ;
  adns_status tmp___0 ;

  {
#line 912
  if ((unsigned int const   )((pai->qu)->typei)->typekey & 131072U) {
    {
#line 913
    tmp = pap_mailbox822___6(pai, cbyte_io, max, mb_r);
    }
#line 913
    return (tmp);
  } else {
    {
#line 915
    tmp___0 = pap_domain___6(pai, cbyte_io, max, mb_r, (parsedomain_flags )1);
    }
#line 915
    return (tmp___0);
  }
}
}
#line 919 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_mailbox___6(vbuf *vb___0 , char const   *mailbox ) 
{ 
  adns_status tmp ;

  {
  {
#line 920
  tmp = csp_domain___6(vb___0, mailbox);
  }
#line 920
  return (tmp);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_rp___6(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  adns_rr_strpair *rrp ;
  adns_status st ;

  {
  {
#line 929
  rrp = (adns_rr_strpair *)datap;
#line 932
  st = pap_mailbox___6(pai, & cbyte___3, max, & rrp->array[0]);
  }
#line 933
  if (st) {
#line 933
    return (st);
  }
  {
#line 935
  st = pap_domain___6(pai, & cbyte___3, max, & rrp->array[1], (parsedomain_flags )1);
  }
#line 936
  if (st) {
#line 936
    return (st);
  }
#line 938
  if (cbyte___3 != max) {
#line 938
    return ((adns_status )104);
  }
#line 939
  return ((adns_status )0);
}
}
#line 942 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_rp___6(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_strpair const   *rrp ;
  adns_status st ;
  int tmp ;

  {
  {
#line 943
  rrp = (adns_rr_strpair const   *)datap;
#line 946
  st = csp_mailbox___6(vb___0, (char const   *)rrp->array[0]);
  }
#line 946
  if (st) {
#line 946
    return (st);
  }
  {
#line 947
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 947
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 947
    if (! tmp) {
#line 947
      return ((adns_status )1);
    }
#line 947
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 948
  st = csp_domain___6(vb___0, (char const   *)rrp->array[1]);
  }
#line 948
  if (st) {
#line 948
    return (st);
  }
#line 950
  return ((adns_status )0);
}
}
#line 957 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_soa___6(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  adns_rr_soa *rrp ;
  byte const   *dgram ;
  adns_status st ;
  int msw ;
  int lsw ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 959
  rrp = (adns_rr_soa *)datap;
#line 960
  dgram = (byte const   *)pai->dgram;
#line 964
  if ((pai->qu)->flags & 64) {
#line 964
    tmp = 1;
  } else {
#line 964
    tmp = 0;
  }
  {
#line 964
  st = pap_domain___6(pai, & cbyte___3, max, & rrp->mname, (parsedomain_flags )tmp);
  }
#line 966
  if (st) {
#line 966
    return (st);
  }
  {
#line 968
  st = pap_mailbox___6(pai, & cbyte___3, max, & rrp->rname);
  }
#line 969
  if (st) {
#line 969
    return (st);
  }
#line 971
  if (cbyte___3 + 20 != max) {
#line 971
    return ((adns_status )104);
  }
#line 973
  i = 0;
  {
#line 973
  while (1) {
    while_continue: /* CIL Label */ ;
#line 973
    if (! (i < 5)) {
#line 973
      goto while_break;
    }
#line 974
    msw = 0;
#line 974
    tmp___0 = cbyte___3;
#line 974
    cbyte___3 ++;
#line 974
    msw |= (int )(((int const   )*(dgram + tmp___0) & 255) << 8);
#line 974
    tmp___1 = cbyte___3;
#line 974
    cbyte___3 ++;
#line 974
    msw |= (int )((int const   )*(dgram + tmp___1) & 255);
#line 975
    lsw = 0;
#line 975
    tmp___2 = cbyte___3;
#line 975
    cbyte___3 ++;
#line 975
    lsw |= (int )(((int const   )*(dgram + tmp___2) & 255) << 8);
#line 975
    tmp___3 = cbyte___3;
#line 975
    cbyte___3 ++;
#line 975
    lsw |= (int )((int const   )*(dgram + tmp___3) & 255);
#line 976
    *(& rrp->serial + i) = (unsigned long )((msw << 16) | lsw);
#line 973
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 979
  return ((adns_status )0);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_soa___6(adns_query qu , void *datap ) 
{ 
  adns_rr_soa *rrp ;

  {
  {
#line 983
  rrp = (adns_rr_soa *)datap;
#line 985
  adns__makefinal_str(qu, & rrp->mname);
#line 986
  adns__makefinal_str(qu, & rrp->rname);
  }
#line 987
  return;
}
}
#line 989 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_soa___6(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_soa const   *rrp ;
  char buf___17[20] ;
  int i ;
  adns_status st ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 990
  rrp = (adns_rr_soa const   *)datap;
#line 995
  st = csp_domain___6(vb___0, (char const   *)rrp->mname);
  }
#line 995
  if (st) {
#line 995
    return (st);
  }
  {
#line 996
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 996
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 996
    if (! tmp) {
#line 996
      return ((adns_status )1);
    }
#line 996
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 997
  st = csp_mailbox___6(vb___0, (char const   *)rrp->rname);
  }
#line 997
  if (st) {
#line 997
    return (st);
  }
#line 999
  i = 0;
  {
#line 999
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 999
    if (! (i < 5)) {
#line 999
      goto while_break___0;
    }
    {
#line 1000
    sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %lu",
            *(& rrp->serial + i));
    }
    {
#line 1001
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1001
      tmp___0 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
      }
#line 1001
      if (! tmp___0) {
#line 1001
        return ((adns_status )1);
      }
#line 1001
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 999
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1004
  return ((adns_status )0);
}
}
#line 1011 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status qdpl_srv___6(adns_state ads___7 , char const   **p_io , char const   *pe ,
                                int labelnum , char *label_r , int *ll_io , adns_queryflags flags ,
                                typeinfo const   *typei ) 
{ 
  int useflags ;
  char const   *p_orig ;
  adns_status st ;
  int ll ;
  void *tmp ;

  {
#line 1020
  if (labelnum < 2) {
#line 1020
    if (! ((unsigned int )flags & 16U)) {
#line 1021
      useflags = 16;
#line 1022
      p_orig = *p_io;
    } else {
#line 1024
      useflags = (int )flags;
#line 1025
      p_orig = (char const   *)0;
    }
  } else {
#line 1024
    useflags = (int )flags;
#line 1025
    p_orig = (char const   *)0;
  }
  {
#line 1027
  st = adns__qdpl_normal(ads___7, p_io, pe, labelnum, (char *)label_r, ll_io, (adns_queryflags )useflags,
                         typei);
  }
#line 1028
  if (st) {
#line 1028
    return (st);
  }
#line 1030
  if (p_orig) {
#line 1031
    ll = *ll_io;
#line 1032
    if (! ll) {
#line 1033
      return ((adns_status )201);
    } else
#line 1032
    if ((int )*(label_r + 0) != 95) {
#line 1033
      return ((adns_status )201);
    }
    {
#line 1034
    tmp = memchr((void const   *)(p_orig + 1), '\\', (size_t )(pe - (p_orig + 1)));
    }
#line 1034
    if (tmp) {
#line 1035
      return ((adns_status )201);
    }
  }
#line 1037
  return ((adns_status )0);
}
}
#line 1040 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pap_srv_begin___6(parseinfo const   *pai , int *cbyte_io , int max ,
                                     adns_rr_srvha *rrp ) 
{ 
  byte const   *dgram ;
  int ti ;
  int cbyte___3 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1043
  dgram = (byte const   *)pai->dgram;
#line 1046
  cbyte___3 = *cbyte_io;
#line 1047
  tmp = *cbyte_io + 6;
#line 1047
  *cbyte_io = tmp;
#line 1047
  if (tmp > max) {
#line 1047
    return ((adns_status )104);
  }
#line 1049
  ti = 0;
#line 1049
  tmp___0 = cbyte___3;
#line 1049
  cbyte___3 ++;
#line 1049
  ti |= (int )(((int const   )*(dgram + tmp___0) & 255) << 8);
#line 1049
  tmp___1 = cbyte___3;
#line 1049
  cbyte___3 ++;
#line 1049
  ti |= (int )((int const   )*(dgram + tmp___1) & 255);
#line 1049
  rrp->priority = ti;
#line 1050
  ti = 0;
#line 1050
  tmp___2 = cbyte___3;
#line 1050
  cbyte___3 ++;
#line 1050
  ti |= (int )(((int const   )*(dgram + tmp___2) & 255) << 8);
#line 1050
  tmp___3 = cbyte___3;
#line 1050
  cbyte___3 ++;
#line 1050
  ti |= (int )((int const   )*(dgram + tmp___3) & 255);
#line 1050
  rrp->weight = ti;
#line 1051
  ti = 0;
#line 1051
  tmp___4 = cbyte___3;
#line 1051
  cbyte___3 ++;
#line 1051
  ti |= (int )(((int const   )*(dgram + tmp___4) & 255) << 8);
#line 1051
  tmp___5 = cbyte___3;
#line 1051
  cbyte___3 ++;
#line 1051
  ti |= (int )((int const   )*(dgram + tmp___5) & 255);
#line 1051
  rrp->port = ti;
#line 1052
  return ((adns_status )0);
}
}
#line 1055 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_srvraw___6(parseinfo const   *pai , int cbyte___3 , int max ,
                                 void *datap ) 
{ 
  adns_rr_srvraw *rrp ;
  adns_status st ;
  int tmp ;

  {
  {
#line 1057
  rrp = (adns_rr_srvraw *)datap;
#line 1060
  st = pap_srv_begin___6(pai, & cbyte___3, max, (adns_rr_srvha *)datap);
  }
#line 1061
  if (st) {
#line 1061
    return (st);
  }
#line 1063
  if ((pai->qu)->flags & 64) {
#line 1063
    tmp = 1;
  } else {
#line 1063
    tmp = 0;
  }
  {
#line 1063
  st = pap_domain___6(pai, & cbyte___3, max, & rrp->host, (parsedomain_flags )tmp);
  }
#line 1065
  if (st) {
#line 1065
    return (st);
  }
#line 1067
  if (cbyte___3 != max) {
#line 1067
    return ((adns_status )104);
  }
#line 1068
  return ((adns_status )0);
}
}
#line 1071 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_srvha___6(parseinfo const   *pai , int cbyte___3 , int max ,
                                void *datap ) 
{ 
  adns_rr_srvha *rrp ;
  adns_status st ;

  {
  {
#line 1073
  rrp = (adns_rr_srvha *)datap;
#line 1076
  st = pap_srv_begin___6(pai, & cbyte___3, max, (adns_rr_srvha *)datap);
  }
#line 1076
  if (st) {
#line 1076
    return (st);
  }
  {
#line 1077
  st = pap_hostaddr___6(pai, & cbyte___3, max, & rrp->ha);
  }
#line 1077
  if (st) {
#line 1077
    return (st);
  }
#line 1078
  if (cbyte___3 != max) {
#line 1078
    return ((adns_status )104);
  }
#line 1079
  return ((adns_status )0);
}
}
#line 1082 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_srvraw___6(adns_query qu , void *datap ) 
{ 
  adns_rr_srvraw *rrp ;

  {
  {
#line 1083
  rrp = (adns_rr_srvraw *)datap;
#line 1084
  adns__makefinal_str(qu, & rrp->host);
  }
#line 1085
  return;
}
}
#line 1087 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_srvha___6(adns_query qu , void *datap ) 
{ 
  adns_rr_srvha *rrp ;

  {
  {
#line 1088
  rrp = (adns_rr_srvha *)datap;
#line 1089
  mfp_hostaddr___6(qu, & rrp->ha);
  }
#line 1090
  return;
}
}
#line 1092 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static int di_srv___6(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_srvraw const   *ap ;
  adns_rr_srvraw const   *bp ;

  {
#line 1093
  ap = (adns_rr_srvraw const   *)datap_a;
#line 1093
  bp = (adns_rr_srvraw const   *)datap_b;
#line 1096
  if (ap->priority < bp->priority) {
#line 1096
    return (0);
  }
#line 1097
  if (ap->priority > bp->priority) {
#line 1097
    return (1);
  }
#line 1098
  return (0);
}
}
#line 1101 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status csp_srv_begin___6(vbuf *vb___0 , adns_rr_srvha const   *rrp ) 
{ 
  char buf___17[30] ;
  int tmp ;

  {
  {
#line 1104
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"%u %u %u ",
          rrp->priority, rrp->weight, rrp->port);
  }
  {
#line 1105
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1105
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 1105
    if (! tmp) {
#line 1105
      return ((adns_status )1);
    }
#line 1105
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1106
  return ((adns_status )0);
}
}
#line 1109 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_srvraw___6(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_srvraw const   *rrp ;
  adns_status st ;
  adns_status tmp ;

  {
  {
#line 1110
  rrp = (adns_rr_srvraw const   *)datap;
#line 1113
  st = csp_srv_begin___6(vb___0, (adns_rr_srvha const   *)((void const   *)rrp));
  }
#line 1113
  if (st) {
#line 1113
    return (st);
  }
  {
#line 1114
  tmp = csp_domain___6(vb___0, (char const   *)rrp->host);
  }
#line 1114
  return (tmp);
}
}
#line 1117 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_srvha___6(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_srvha const   *rrp ;
  adns_status st ;
  adns_status tmp ;

  {
  {
#line 1118
  rrp = (adns_rr_srvha const   *)datap;
#line 1121
  st = csp_srv_begin___6(vb___0, (adns_rr_srvha const   *)datap);
  }
#line 1121
  if (st) {
#line 1121
    return (st);
  }
  {
#line 1122
  tmp = csp_hostaddr___6(vb___0, & rrp->ha);
  }
#line 1122
  return (tmp);
}
}
#line 1125 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void postsort_srv___6(adns_state ads___7 , void *array , int nrrs , struct typeinfo  const  *typei ) 
{ 
  char *workbegin ;
  char *workend ;
  char *search ;
  char *arrayend ;
  adns_rr_srvha const   *rr ;
  union __anonunion_rrtmp_89___6 rrtmp ;
  int cpriority ;
  int totalweight ;
  int runtotal ;
  long randval ;

  {
#line 1138
  workbegin = (char *)array;
#line 1138
  arrayend = workbegin + typei->rrsz * (int const   )nrrs;
  {
#line 1138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1138
    if (! ((unsigned long )workbegin < (unsigned long )arrayend)) {
#line 1138
      goto while_break;
    }
#line 1141
    rr = (adns_rr_srvha const   *)((void *)workbegin);
#line 1141
    cpriority = (int )rr->priority;
#line 1143
    workend = workbegin;
#line 1143
    totalweight = 0;
    {
#line 1143
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1143
      if ((unsigned long )workend < (unsigned long )arrayend) {
#line 1143
        rr = (adns_rr_srvha const   *)((void *)workend);
#line 1143
        if (! (rr->priority == (int const   )cpriority)) {
#line 1143
          goto while_break___0;
        }
      } else {
#line 1143
        goto while_break___0;
      }
#line 1146
      totalweight += (int )rr->weight;
#line 1143
      workend += typei->rrsz;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1155
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1155
      if (! ((unsigned long )(workbegin + typei->rrsz) < (unsigned long )workend)) {
#line 1155
        goto while_break___1;
      }
      {
#line 1159
      randval = nrand48((unsigned short *)(ads___7->rand48xsubi));
#line 1160
      randval %= (long )(totalweight + 1);
#line 1167
      search = workbegin;
#line 1167
      runtotal = 0;
      }
      {
#line 1167
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1167
        rr = (adns_rr_srvha const   *)((void *)search);
#line 1167
        runtotal += (int )rr->weight;
#line 1167
        if (! ((long )runtotal < randval)) {
#line 1167
          goto while_break___2;
        }
#line 1167
        search += typei->rrsz;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1170
      if (! ((unsigned long )search < (unsigned long )arrayend)) {
        {
#line 1170
        __assert_fail("search < arrayend", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c",
                      1170U, "postsort_srv");
        }
      }
#line 1171
      totalweight -= (int )rr->weight;
#line 1172
      if ((unsigned long )search != (unsigned long )workbegin) {
        {
#line 1173
        memcpy((void */* __restrict  */)(& rrtmp), (void const   */* __restrict  */)workbegin,
               (size_t )typei->rrsz);
#line 1174
        memcpy((void */* __restrict  */)workbegin, (void const   */* __restrict  */)search,
               (size_t )typei->rrsz);
#line 1175
        memcpy((void */* __restrict  */)search, (void const   */* __restrict  */)(& rrtmp),
               (size_t )typei->rrsz);
        }
      }
#line 1155
      workbegin += typei->rrsz;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1138
    workbegin = workend;
  }
  while_break: /* CIL Label */ ;
  }
#line 1184
  return;
}
}
#line 1190 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_byteblock___6(adns_query qu , void *datap ) 
{ 
  adns_rr_byteblock *rrp ;
  void *bytes___3 ;

  {
  {
#line 1191
  rrp = (adns_rr_byteblock *)datap;
#line 1192
  bytes___3 = (void *)rrp->data;
#line 1193
  adns__makefinal_block(qu, & bytes___3, (size_t )rrp->len);
#line 1194
  rrp->data = (unsigned char *)bytes___3;
  }
#line 1195
  return;
}
}
#line 1201 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status pa_opaque___6(parseinfo const   *pai , int cbyte___3 , int max ,
                                 void *datap ) 
{ 
  adns_rr_byteblock *rrp ;
  void *tmp ;

  {
  {
#line 1203
  rrp = (adns_rr_byteblock *)datap;
#line 1205
  rrp->len = max - cbyte___3;
#line 1206
  tmp = adns__alloc_interim((adns_query )pai->qu, (size_t )rrp->len);
#line 1206
  rrp->data = (unsigned char *)tmp;
  }
#line 1207
  if (! rrp->data) {
#line 1207
    return ((adns_status )1);
  }
  {
#line 1208
  memcpy((void */* __restrict  */)rrp->data, (void const   */* __restrict  */)(pai->dgram + cbyte___3),
         (size_t )rrp->len);
  }
#line 1209
  return ((adns_status )0);
}
}
#line 1212 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static adns_status cs_opaque___6(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_byteblock const   *rrp ;
  char buf___17[10] ;
  int l ;
  unsigned char *p ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1213
  rrp = (adns_rr_byteblock const   *)datap;
#line 1218
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"\\# %d",
          rrp->len);
  }
  {
#line 1219
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1219
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 1219
    if (! tmp) {
#line 1219
      return ((adns_status )1);
    }
#line 1219
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1221
  l = (int )rrp->len;
#line 1221
  p = (unsigned char *)rrp->data;
  {
#line 1221
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1221
    if (! (l >= 4)) {
#line 1221
      goto while_break___0;
    }
    {
#line 1224
    sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %02x%02x%02x%02x",
            (int )*(p + 0), (int )*(p + 1), (int )*(p + 2), (int )*(p + 3));
    }
    {
#line 1225
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1225
      tmp___0 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
      }
#line 1225
      if (! tmp___0) {
#line 1225
        return ((adns_status )1);
      }
#line 1225
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1221
    l -= 4;
#line 1221
    p += 4;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1227
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1227
    if (! (l > 0)) {
#line 1227
      goto while_break___2;
    }
    {
#line 1230
    sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %02x",
            (int )*p);
    }
    {
#line 1231
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 1231
      tmp___1 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
      }
#line 1231
      if (! tmp___1) {
#line 1231
        return ((adns_status )1);
      }
#line 1231
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1227
    l --;
#line 1227
    p ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1233
  return ((adns_status )0);
}
}
#line 1240 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static void mf_flat___6(adns_query qu , void *data___0 ) 
{ 


  {
#line 1240
  return;
}
}
#line 1261 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static typeinfo const   typeinfos___6[17]  = 
#line 1261
  {      {(adns_rrtype )1, "A", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.inaddr)),
      & mf_flat___6, & cs_inaddr___6, & pa_inaddr___6, & di_inaddr___6, (adns_status (*)(adns_state ads ,
                                                                                         char const   **p_io ,
                                                                                         char const   *pe ,
                                                                                         int labelnum ,
                                                                                         char *label_r ,
                                                                                         int *ll_io ,
                                                                                         adns_queryflags flags ,
                                                                                         struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )2,
      "NS", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___6, & cs_domain___6,
      & pa_host_raw___6, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )5,
      "CNAME", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___6,
      & cs_domain___6, & pa_dom_raw___6, (int (*)(adns_state ads , void const   *datap_a ,
                                                  void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                              char const   **p_io ,
                                                                                              char const   *pe ,
                                                                                              int labelnum ,
                                                                                              char *label_r ,
                                                                                              int *ll_io ,
                                                                                              adns_queryflags flags ,
                                                                                              struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )6,
      "SOA", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.soa)), & mf_soa___6, & cs_soa___6,
      & pa_soa___6, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )12,
      "PTR", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___6, & cs_domain___6,
      & pa_host_raw___6, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )13,
      "HINFO", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.intstrpair)),
      & mf_intstrpair___6, & cs_hinfo___6, & pa_hinfo___6, (int (*)(adns_state ads ,
                                                                    void const   *datap_a ,
                                                                    void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )15,
      "MX", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.intstr)), & mf_intstr___6,
      & cs_inthost___6, & pa_mx_raw___6, & di_mx_raw___6, (adns_status (*)(adns_state ads ,
                                                                           char const   **p_io ,
                                                                           char const   *pe ,
                                                                           int labelnum ,
                                                                           char *label_r ,
                                                                           int *ll_io ,
                                                                           adns_queryflags flags ,
                                                                           struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )16,
      "TXT", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.manyistr)),
      & mf_manyistr___6, & cs_txt___6, & pa_txt___6, (int (*)(adns_state ads , void const   *datap_a ,
                                                              void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )17,
      "RP", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.strpair)), & mf_strpair___6,
      & cs_rp___6, & pa_rp___6, (int (*)(adns_state ads , void const   *datap_a ,
                                         void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                     char const   **p_io ,
                                                                                     char const   *pe ,
                                                                                     int labelnum ,
                                                                                     char *label_r ,
                                                                                     int *ll_io ,
                                                                                     adns_queryflags flags ,
                                                                                     struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )33,
      "SRV", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.srvraw)), & mf_srvraw___6,
      & cs_srvraw___6, & pa_srvraw___6, & di_srv___6, & qdpl_srv___6, & postsort_srv___6}, 
        {(adns_rrtype )65537,
      "A", "addr", (int )sizeof(*(((adns_answer *)0)->rrs.addr)), & mf_flat___6, & cs_addr___6,
      & pa_addr___6, & di_addr___6, (adns_status (*)(adns_state ads , char const   **p_io ,
                                                     char const   *pe , int labelnum ,
                                                     char *label_r , int *ll_io ,
                                                     adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65538,
      "NS", "+addr", (int )sizeof(*(((adns_answer *)0)->rrs.hostaddr)), & mf_hostaddr___6,
      & cs_hostaddr___6, & pa_hostaddr___6, & di_hostaddr___6, (adns_status (*)(adns_state ads ,
                                                                                char const   **p_io ,
                                                                                char const   *pe ,
                                                                                int labelnum ,
                                                                                char *label_r ,
                                                                                int *ll_io ,
                                                                                adns_queryflags flags ,
                                                                                struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65548,
      "PTR", "checked", (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___6,
      & cs_domain___6, & pa_ptr___6, (int (*)(adns_state ads , void const   *datap_a ,
                                              void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                          char const   **p_io ,
                                                                                          char const   *pe ,
                                                                                          int labelnum ,
                                                                                          char *label_r ,
                                                                                          int *ll_io ,
                                                                                          adns_queryflags flags ,
                                                                                          struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65551,
      "MX", "+addr", (int )sizeof(*(((adns_answer *)0)->rrs.inthostaddr)), & mf_inthostaddr___6,
      & cs_inthostaddr___6, & pa_mx___6, & di_mx___6, (adns_status (*)(adns_state ads ,
                                                                       char const   **p_io ,
                                                                       char const   *pe ,
                                                                       int labelnum ,
                                                                       char *label_r ,
                                                                       int *ll_io ,
                                                                       adns_queryflags flags ,
                                                                       struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65569,
      "SRV", "+addr", (int )sizeof(*(((adns_answer *)0)->rrs.srvha)), & mf_srvha___6,
      & cs_srvha___6, & pa_srvha___6, & di_srv___6, & qdpl_srv___6, & postsort_srv___6}, 
        {(adns_rrtype )131078,
      "SOA", "822", (int )sizeof(*(((adns_answer *)0)->rrs.soa)), & mf_soa___6, & cs_soa___6,
      & pa_soa___6, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )131089,
      "RP", "822", (int )sizeof(*(((adns_answer *)0)->rrs.strpair)), & mf_strpair___6,
      & cs_rp___6, & pa_rp___6, (int (*)(adns_state ads , void const   *datap_a ,
                                         void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                     char const   **p_io ,
                                                                                     char const   *pe ,
                                                                                     int labelnum ,
                                                                                     char *label_r ,
                                                                                     int *ll_io ,
                                                                                     adns_queryflags flags ,
                                                                                     struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}};
#line 1288 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/types.c"
static struct typeinfo  const  typeinfo_unknown___6  = 
#line 1288
     {(adns_rrtype )262144, (char const   *)0, "unknown", (int )sizeof(*(((adns_answer *)0)->rrs.byteblock)),
    & mf_byteblock___6, & cs_opaque___6, & pa_opaque___6, (int (*)(adns_state ads ,
                                                                   void const   *datap_a ,
                                                                   void const   *datap_b ))0,
    (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                     char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
    (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0};
#line 55 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_query_alloc___6(adns_state ads___7 , adns_query qu ) 
{ 
  allocnode *an ;
  int tmp ;

  {
#line 58
  if (qu->allocations.head) {
#line 58
    if (! (! (qu->allocations.head)->back)) {
      {
#line 58
      __assert_fail("! (qu->allocations).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    59U, "checkc_query_alloc");
      }
    }
#line 58
    an = qu->allocations.head;
    {
#line 58
    while (1) {
      while_continue: /* CIL Label */ ;
#line 58
      if (! an) {
#line 58
        goto while_break;
      }
#line 58
      if (an->next) {
#line 58
        tmp = (unsigned long )an == (unsigned long )(an->next)->back;
      } else {
#line 58
        tmp = (unsigned long )an == (unsigned long )qu->allocations.tail;
      }
#line 58
      if (! tmp) {
        {
#line 58
        __assert_fail("(an)-> next ? (an) == (an)-> next-> back : (an) == (qu->allocations).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      59U, "checkc_query_alloc");
        }
      }
#line 58
      an = an->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 60
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_query___6(adns_state ads___7 , adns_query qu ) 
{ 
  adns_query child ;

  {
#line 65
  if (! (qu->udpnextserver < ads___7->nservers)) {
    {
#line 65
    __assert_fail("qu->udpnextserver < ads->nservers", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  65U, "checkc_query");
    }
  }
#line 66
  if (! (! (qu->udpsent & (0xffffffffffffffffUL << ads___7->nservers)))) {
    {
#line 66
    __assert_fail("!(qu->udpsent & (~0UL << ads->nservers))", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  66U, "checkc_query");
    }
  }
#line 67
  if (! (qu->search_pos <= ads___7->nsearchlist)) {
    {
#line 67
    __assert_fail("qu->search_pos <= ads->nsearchlist", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  67U, "checkc_query");
    }
  }
#line 68
  if (qu->parent) {
    {
#line 68
    while (1) {
      while_continue: /* CIL Label */ ;
#line 68
      child = (qu->parent)->children.head;
      {
#line 68
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 68
        if (! ((unsigned long )child != (unsigned long )qu)) {
#line 68
          goto while_break___0;
        }
#line 68
        if (! child) {
          {
#line 68
          __assert_fail("(child)", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        68U, "checkc_query");
          }
        }
#line 68
        child = child->siblings.next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 68
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 69
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_notcpbuf___6(adns_state ads___7 ) 
{ 


  {
#line 72
  if (! (! ads___7->tcpsend.used)) {
    {
#line 72
    __assert_fail("!ads->tcpsend.used", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  72U, "checkc_notcpbuf");
    }
  }
#line 73
  if (! (! ads___7->tcprecv.used)) {
    {
#line 73
    __assert_fail("!ads->tcprecv.used", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  73U, "checkc_notcpbuf");
    }
  }
#line 74
  if (! (! ads___7->tcprecv_skip)) {
    {
#line 74
    __assert_fail("!ads->tcprecv_skip", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  74U, "checkc_notcpbuf");
    }
  }
#line 75
  return;
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_global___6(adns_state ads___7 ) 
{ 
  int i ;

  {
#line 80
  if (! (ads___7->udpsocket >= 0)) {
    {
#line 80
    __assert_fail("ads->udpsocket >= 0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  80U, "checkc_global");
    }
  }
#line 82
  i = 0;
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! (i < ads___7->nsortlist)) {
#line 82
      goto while_break;
    }
#line 83
    if (! (! (ads___7->sortlist[i].base.s_addr & ~ ads___7->sortlist[i].mask.s_addr))) {
      {
#line 83
      __assert_fail("!(ads->sortlist[i].base.s_addr & ~ads->sortlist[i].mask.s_addr)",
                    "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    83U, "checkc_global");
      }
    }
#line 82
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  if (ads___7->tcpserver >= 0) {
#line 85
    if (! (ads___7->tcpserver < ads___7->nservers)) {
      {
#line 85
      __assert_fail("ads->tcpserver >= 0 && ads->tcpserver < ads->nservers", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    85U, "checkc_global");
      }
    }
  } else {
    {
#line 85
    __assert_fail("ads->tcpserver >= 0 && ads->tcpserver < ads->nservers", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  85U, "checkc_global");
    }
  }
  {
#line 88
  if ((unsigned int )ads___7->tcpstate == 1U) {
#line 88
    goto case_1;
  }
#line 93
  if ((unsigned int )ads___7->tcpstate == 3U) {
#line 93
    goto case_3;
  }
#line 93
  if ((unsigned int )ads___7->tcpstate == 0U) {
#line 93
    goto case_3;
  }
#line 97
  if ((unsigned int )ads___7->tcpstate == 2U) {
#line 97
    goto case_2;
  }
#line 101
  goto switch_default;
  case_1: /* CIL Label */ 
#line 89
  if (! (ads___7->tcpsocket >= 0)) {
    {
#line 89
    __assert_fail("ads->tcpsocket >= 0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  89U, "checkc_global");
    }
  }
  {
#line 90
  checkc_notcpbuf___6(ads___7);
  }
#line 91
  goto switch_break;
  case_3: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 94
  if (! (ads___7->tcpsocket == -1)) {
    {
#line 94
    __assert_fail("ads->tcpsocket == -1", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  94U, "checkc_global");
    }
  }
  {
#line 95
  checkc_notcpbuf___6(ads___7);
  }
#line 96
  goto switch_break;
  case_2: /* CIL Label */ 
#line 98
  if (! (ads___7->tcpsocket >= 0)) {
    {
#line 98
    __assert_fail("ads->tcpsocket >= 0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  98U, "checkc_global");
    }
  }
#line 99
  if (! (ads___7->tcprecv_skip <= ads___7->tcprecv.used)) {
    {
#line 99
    __assert_fail("ads->tcprecv_skip <= ads->tcprecv.used", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                  99U, "checkc_global");
    }
  }
#line 100
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 102
  __assert_fail("!\"ads->tcpstate value\"", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                102U, "checkc_global");
  }
  switch_break: /* CIL Label */ ;
  }
#line 105
  if (! ads___7->searchlist) {
#line 105
    if (! (! ads___7->nsearchlist)) {
      {
#line 105
      __assert_fail("ads->searchlist || !ads->nsearchlist", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    105U, "checkc_global");
      }
    }
  }
#line 106
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_queue_udpw___6(adns_state ads___7 ) 
{ 
  adns_query qu ;
  int tmp ;

  {
#line 111
  if (ads___7->udpw.head) {
#line 111
    if (! (! (ads___7->udpw.head)->back)) {
      {
#line 111
      __assert_fail("! (ads->udpw).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    118U, "checkc_queue_udpw");
      }
    }
#line 111
    qu = ads___7->udpw.head;
    {
#line 111
    while (1) {
      while_continue: /* CIL Label */ ;
#line 111
      if (! qu) {
#line 111
        goto while_break;
      }
#line 111
      if (qu->next) {
#line 111
        tmp = (unsigned long )qu == (unsigned long )(qu->next)->back;
      } else {
#line 111
        tmp = (unsigned long )qu == (unsigned long )ads___7->udpw.tail;
      }
#line 111
      if (! tmp) {
        {
#line 111
        __assert_fail("(qu)-> next ? (qu) == (qu)-> next-> back : (qu) == (ads->udpw).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! ((unsigned int )qu->state == 0U)) {
        {
#line 111
        __assert_fail("qu->state==query_tosend", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! (qu->retries <= 15)) {
        {
#line 111
        __assert_fail("qu->retries <= 15", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! qu->udpsent) {
        {
#line 111
        __assert_fail("qu->udpsent", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! qu->children.head) {
#line 111
        if (! (! qu->children.tail)) {
          {
#line 111
          __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        118U, "checkc_queue_udpw");
          }
        }
      } else {
        {
#line 111
        __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
      {
#line 111
      checkc_query___6(ads___7, qu);
#line 111
      checkc_query_alloc___6(ads___7, qu);
#line 111
      qu = qu->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 119
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_queue_tcpw___6(adns_state ads___7 ) 
{ 
  adns_query qu ;
  int tmp ;

  {
#line 124
  if (ads___7->tcpw.head) {
#line 124
    if (! (! (ads___7->tcpw.head)->back)) {
      {
#line 124
      __assert_fail("! (ads->tcpw).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    130U, "checkc_queue_tcpw");
      }
    }
#line 124
    qu = ads___7->tcpw.head;
    {
#line 124
    while (1) {
      while_continue: /* CIL Label */ ;
#line 124
      if (! qu) {
#line 124
        goto while_break;
      }
#line 124
      if (qu->next) {
#line 124
        tmp = (unsigned long )qu == (unsigned long )(qu->next)->back;
      } else {
#line 124
        tmp = (unsigned long )qu == (unsigned long )ads___7->tcpw.tail;
      }
#line 124
      if (! tmp) {
        {
#line 124
        __assert_fail("(qu)-> next ? (qu) == (qu)-> next-> back : (qu) == (ads->tcpw).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
#line 124
      if (! ((unsigned int )qu->state == 1U)) {
        {
#line 124
        __assert_fail("qu->state==query_tcpw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
#line 124
      if (! qu->children.head) {
#line 124
        if (! (! qu->children.tail)) {
          {
#line 124
          __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        130U, "checkc_queue_tcpw");
          }
        }
      } else {
        {
#line 124
        __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
#line 124
      if (! (qu->retries <= ads___7->nservers + 1)) {
        {
#line 124
        __assert_fail("qu->retries <= ads->nservers+1", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
      {
#line 124
      checkc_query___6(ads___7, qu);
#line 124
      checkc_query_alloc___6(ads___7, qu);
#line 124
      qu = qu->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 131
  return;
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_queue_childw___6(adns_state ads___7 ) 
{ 
  adns_query parent ;
  adns_query child ;
  int tmp ;
  int tmp___0 ;

  {
#line 136
  if (ads___7->childw.head) {
#line 136
    if (! (! (ads___7->childw.head)->back)) {
      {
#line 136
      __assert_fail("! (ads->childw).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    145U, "checkc_queue_childw");
      }
    }
#line 136
    parent = ads___7->childw.head;
    {
#line 136
    while (1) {
      while_continue: /* CIL Label */ ;
#line 136
      if (! parent) {
#line 136
        goto while_break;
      }
#line 136
      if (parent->next) {
#line 136
        tmp = (unsigned long )parent == (unsigned long )(parent->next)->back;
      } else {
#line 136
        tmp = (unsigned long )parent == (unsigned long )ads___7->childw.tail;
      }
#line 136
      if (! tmp) {
        {
#line 136
        __assert_fail("(parent)-> next ? (parent) == (parent)-> next-> back : (parent) == (ads->childw).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      145U, "checkc_queue_childw");
        }
      }
#line 136
      if (! ((unsigned int )parent->state == 2U)) {
        {
#line 136
        __assert_fail("parent->state == query_childw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      145U, "checkc_queue_childw");
        }
      }
#line 136
      if (! parent->children.head) {
        {
#line 136
        __assert_fail("parent->children.head", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      145U, "checkc_queue_childw");
        }
      }
#line 136
      if (parent->children.head) {
#line 136
        if (! (! (parent->children.head)->siblings.back)) {
          {
#line 136
          __assert_fail("! (parent->children).head->siblings. back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        145U, "checkc_queue_childw");
          }
        }
#line 136
        child = parent->children.head;
        {
#line 136
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 136
          if (! child) {
#line 136
            goto while_break___0;
          }
#line 136
          if (child->siblings.next) {
#line 136
            tmp___0 = (unsigned long )child == (unsigned long )(child->siblings.next)->siblings.back;
          } else {
#line 136
            tmp___0 = (unsigned long )child == (unsigned long )parent->children.tail;
          }
#line 136
          if (! tmp___0) {
            {
#line 136
            __assert_fail("(child)->siblings. next ? (child) == (child)->siblings. next->siblings. back : (child) == (parent->children).tail",
                          "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                          145U, "checkc_queue_childw");
            }
          }
#line 136
          if (! ((unsigned long )child->parent == (unsigned long )parent)) {
            {
#line 136
            __assert_fail("child->parent == parent", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                          145U, "checkc_queue_childw");
            }
          }
#line 136
          if (! ((unsigned int )child->state != 3U)) {
            {
#line 136
            __assert_fail("child->state != query_done", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                          145U, "checkc_queue_childw");
            }
          }
#line 136
          child = child->siblings.next;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 136
      checkc_query___6(ads___7, parent);
#line 136
      checkc_query_alloc___6(ads___7, parent);
#line 136
      parent = parent->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 146
  return;
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c"
static void checkc_queue_output___6(adns_state ads___7 ) 
{ 
  adns_query qu ;
  int tmp ;

  {
#line 151
  if (ads___7->output.head) {
#line 151
    if (! (! (ads___7->output.head)->back)) {
      {
#line 151
      __assert_fail("! (ads->output).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                    157U, "checkc_queue_output");
      }
    }
#line 151
    qu = ads___7->output.head;
    {
#line 151
    while (1) {
      while_continue: /* CIL Label */ ;
#line 151
      if (! qu) {
#line 151
        goto while_break;
      }
#line 151
      if (qu->next) {
#line 151
        tmp = (unsigned long )qu == (unsigned long )(qu->next)->back;
      } else {
#line 151
        tmp = (unsigned long )qu == (unsigned long )ads___7->output.tail;
      }
#line 151
      if (! tmp) {
        {
#line 151
        __assert_fail("(qu)-> next ? (qu) == (qu)-> next-> back : (qu) == (ads->output).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! ((unsigned int )qu->state == 3U)) {
        {
#line 151
        __assert_fail("qu->state == query_done", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! qu->children.head) {
#line 151
        if (! (! qu->children.tail)) {
          {
#line 151
          __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        157U, "checkc_queue_output");
          }
        }
      } else {
        {
#line 151
        __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! (! qu->parent)) {
        {
#line 151
        __assert_fail("!qu->parent", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! qu->allocations.head) {
#line 151
        if (! (! qu->allocations.tail)) {
          {
#line 151
          __assert_fail("!qu->allocations.head && !qu->allocations.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                        157U, "checkc_queue_output");
          }
        }
      } else {
        {
#line 151
        __assert_fail("!qu->allocations.head && !qu->allocations.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
      {
#line 151
      checkc_query___6(ads___7, qu);
#line 151
      qu = qu->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 158
  return;
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-main.c"
static int used___0  ;
#line 33 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-main.c"
static int avail___0  ;
#line 34 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-main.c"
static char *buf___6  ;
#line 82 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-main.c"
static struct typename  const  typenames___0[18]  = 
#line 82
  {      {(adns_rrtype )65538, "ns"}, 
        {(adns_rrtype )131078, "soa"}, 
        {(adns_rrtype )65548, "ptr"}, 
        {(adns_rrtype )65551, "mx"}, 
        {(adns_rrtype )131089, "rp"}, 
        {(adns_rrtype )65569, "srv"}, 
        {(adns_rrtype )65537, "addr"}, 
        {(adns_rrtype )5, "cname"}, 
        {(adns_rrtype )13, "hinfo"}, 
        {(adns_rrtype )16, "txt"}, 
        {(adns_rrtype )1, "a"}, 
        {(adns_rrtype )2, "ns-"}, 
        {(adns_rrtype )6, "soa-"}, 
        {(adns_rrtype )12, "ptr-"}, 
        {(adns_rrtype )15, "mx-"}, 
        {(adns_rrtype )17, "rp-"}, 
        {(adns_rrtype )33, "srv-"}, 
        {(adns_rrtype )0, (char const   *)0}};
#line 129 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-main.c"
static void process_optarg___0(char const   *arg , char const   * const  **argv_p ,
                               char const   *value ) 
{ 
  struct optioninfo  const  *oip ;
  char const   *arg2 ;
  int invert ;
  int tmp ;

  {
#line 136
  if ((int const   )*(arg + 0) == 45) {
#line 136
    goto _L___1;
  } else
#line 136
  if ((int const   )*(arg + 0) == 43) {
    _L___1: /* CIL Label */ 
#line 137
    if ((int const   )*(arg + 0) == 45) {
#line 137
      if ((int const   )*(arg + 1) == 45) {
        {
#line 138
        tmp = strncmp(arg, "--no-", (size_t )5);
        }
#line 138
        if (tmp) {
          {
#line 142
          invert = 0;
#line 143
          oip = opt_findl(arg + 2);
          }
        } else {
          {
#line 139
          invert = 1;
#line 140
          oip = opt_findl(arg + 5);
          }
        }
#line 145
        if ((unsigned int const   )oip->type == 5U) {
#line 146
          if (argv_p) {
#line 146
            (*argv_p) ++;
#line 146
            arg = (char const   *)*(*argv_p);
          } else {
#line 146
            arg = value;
          }
#line 147
          if (! arg) {
            {
#line 147
            usageerr("option --%s requires a value argument", oip->lopt);
            }
          }
#line 148
          arg2 = (char const   *)0;
        } else
#line 149
        if ((unsigned int const   )oip->type == 6U) {
#line 150
          if (! argv_p) {
            {
#line 150
            __assert_fail("argv_p", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-main.c",
                          150U, "process_optarg");
            }
          }
#line 151
          (*argv_p) ++;
#line 151
          arg = (char const   *)*(*argv_p);
#line 152
          if (arg) {
#line 152
            (*argv_p) ++;
#line 152
            arg2 = (char const   *)*(*argv_p);
          } else {
#line 152
            arg2 = (char const   *)0;
          }
#line 153
          if (! arg) {
            {
#line 154
            usageerr("option --%s requires two more arguments", oip->lopt);
            }
          } else
#line 153
          if (! arg2) {
            {
#line 154
            usageerr("option --%s requires two more arguments", oip->lopt);
            }
          }
        } else {
#line 156
          if (value) {
            {
#line 156
            usageerr("option --%s does not take a value", oip->lopt);
            }
          }
#line 157
          arg = (char const   *)0;
#line 158
          arg2 = (char const   *)0;
        }
        {
#line 160
        opt_do(oip, invert, arg, arg2);
        }
      } else {
#line 137
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 161
    if ((int const   )*(arg + 0) == 45) {
#line 161
      if ((int const   )*(arg + 1) == 0) {
#line 162
        if (argv_p) {
#line 162
          (*argv_p) ++;
#line 162
          arg = (char const   *)*(*argv_p);
        } else {
#line 162
          arg = value;
        }
#line 163
        if (! arg) {
          {
#line 163
          usageerr("option `-\' must be followed by a domain");
          }
        }
        {
#line 164
        query_do(arg);
        }
      } else {
#line 161
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 166
      invert = (int const   )*(arg + 0) == 43;
#line 167
      arg ++;
      {
#line 168
      while (1) {
        while_continue: /* CIL Label */ ;
#line 168
        if (! *arg) {
#line 168
          goto while_break;
        }
        {
#line 169
        oip = opt_finds(& arg);
        }
#line 170
        if ((unsigned int const   )oip->type == 5U) {
#line 171
          if (! *arg) {
#line 172
            if (argv_p) {
#line 172
              (*argv_p) ++;
#line 172
              arg = (char const   *)*(*argv_p);
            } else {
#line 172
              arg = value;
            }
#line 173
            if (! arg) {
              {
#line 173
              usageerr("option -%s requires a value argument", oip->sopt);
              }
            }
          } else
#line 175
          if (value) {
            {
#line 175
            usageerr("two values for option -%s given !", oip->sopt);
            }
          }
          {
#line 177
          opt_do(oip, invert, arg, (char const   *)0);
#line 178
          arg = "";
          }
        } else {
#line 180
          if (value) {
            {
#line 180
            usageerr("option -%s does not take a value", oip->sopt);
            }
          }
          {
#line 181
          opt_do(oip, invert, (char const   *)0, (char const   *)0);
          }
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 186
    query_do(arg);
    }
  }
#line 188
  return;
}
}
#line 190 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-main.c"
static void read_stdin___0(void) 
{ 
  int anydone ;
  int r ;
  char *newline ;
  char *space ;
  void *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
#line 194
  anydone = 0;
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 195
    if (! (! anydone)) {
#line 195
      if (! used___0) {
#line 195
        goto while_break;
      }
    }
    {
#line 196
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 196
      tmp___4 = memchr((void const   *)buf___6, '\n', (size_t )used___0);
#line 196
      newline = (char *)tmp___4;
      }
#line 196
      if (newline) {
#line 196
        goto while_break___0;
      }
#line 197
      if (used___0 == avail___0) {
        {
#line 198
        avail___0 += 20;
#line 198
        avail___0 <<= 1;
#line 199
        tmp = Hrealloc((void *)buf___6, (size_t )avail___0);
#line 199
        buf___6 = (char *)tmp;
        }
#line 200
        if (! buf___6) {
          {
#line 200
          tmp___0 = __errno_location();
#line 200
          sysfail("realloc stdin buffer", *tmp___0);
          }
        }
      }
      {
#line 202
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 203
        r = Hread(0, (void *)(buf___6 + used___0), (size_t )(avail___0 - used___0));
        }
#line 202
        if (r < 0) {
          {
#line 202
          tmp___1 = __errno_location();
          }
#line 202
          if (! (*tmp___1 == 4)) {
#line 202
            goto while_break___1;
          }
        } else {
#line 202
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 205
      if (r == 0) {
#line 206
        if (used___0) {
#line 208
          tmp___2 = used___0;
#line 208
          used___0 ++;
#line 208
          *(buf___6 + tmp___2) = (char )'\n';
#line 209
          r = 1;
        } else {
#line 211
          ov_pipe = 0;
#line 212
          return;
        }
      }
#line 215
      if (r < 0) {
        {
#line 215
        tmp___3 = __errno_location();
#line 215
        sysfail("read stdin", *tmp___3);
        }
      }
#line 216
      used___0 += r;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 218
    tmp___5 = newline;
#line 218
    newline ++;
#line 218
    *tmp___5 = (char)0;
#line 219
    space = strchr((char const   *)buf___6, ' ');
    }
#line 220
    if (space) {
#line 220
      tmp___6 = space;
#line 220
      space ++;
#line 220
      *tmp___6 = (char)0;
    }
    {
#line 221
    process_optarg___0((char const   *)buf___6, (char const   * const  **)0, (char const   *)space);
#line 222
    used___0 = (int )((long )used___0 - (newline - buf___6));
#line 223
    memmove((void *)buf___6, (void const   *)newline, (size_t )used___0);
#line 224
    anydone = 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 226
  return;
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/transmit.c"
static adns_status mkquery_header___6(adns_state ads___7 , vbuf *vb___0 , int *id_r ,
                                      int qdlen ) 
{ 
  int id ;
  byte *rqp ;
  int tmp ;
  int tmp___0 ;
  byte *tmp___1 ;
  byte *tmp___2 ;
  byte *tmp___3 ;
  byte *tmp___4 ;
  byte *tmp___5 ;
  byte *tmp___6 ;
  byte *tmp___7 ;
  byte *tmp___8 ;
  byte *tmp___9 ;
  byte *tmp___10 ;
  byte *tmp___11 ;
  byte *tmp___12 ;

  {
  {
#line 46
  tmp = adns__vbuf_ensure(vb___0, (12 + qdlen) + 4);
  }
#line 46
  if (! tmp) {
#line 46
    return ((adns_status )1);
  }
#line 48
  vb___0->used = 0;
#line 49
  rqp = vb___0->buf + vb___0->used;
#line 51
  tmp___0 = ads___7->nextid;
#line 51
  (ads___7->nextid) ++;
#line 51
  id = tmp___0 & 65535;
#line 51
  *id_r = id;
#line 52
  tmp___1 = rqp;
#line 52
  rqp ++;
#line 52
  *tmp___1 = (byte )((id >> 8) & 255);
#line 52
  tmp___2 = rqp;
#line 52
  rqp ++;
#line 52
  *tmp___2 = (byte )(id & 255);
#line 53
  tmp___3 = rqp;
#line 53
  rqp ++;
#line 53
  *tmp___3 = (byte )1;
#line 54
  tmp___4 = rqp;
#line 54
  rqp ++;
#line 54
  *tmp___4 = (byte )0;
#line 55
  tmp___5 = rqp;
#line 55
  rqp ++;
#line 55
  *tmp___5 = (byte )((1 >> 8) & 255);
#line 55
  tmp___6 = rqp;
#line 55
  rqp ++;
#line 55
  *tmp___6 = (byte )1;
#line 56
  tmp___7 = rqp;
#line 56
  rqp ++;
#line 56
  *tmp___7 = (byte )0;
#line 56
  tmp___8 = rqp;
#line 56
  rqp ++;
#line 56
  *tmp___8 = (byte )0;
#line 57
  tmp___9 = rqp;
#line 57
  rqp ++;
#line 57
  *tmp___9 = (byte )0;
#line 57
  tmp___10 = rqp;
#line 57
  rqp ++;
#line 57
  *tmp___10 = (byte )0;
#line 58
  tmp___11 = rqp;
#line 58
  rqp ++;
#line 58
  *tmp___11 = (byte )0;
#line 58
  tmp___12 = rqp;
#line 58
  rqp ++;
#line 58
  *tmp___12 = (byte )0;
#line 60
  vb___0->used = (int )(rqp - vb___0->buf);
#line 62
  return ((adns_status )0);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/transmit.c"
static adns_status mkquery_footer___6(vbuf *vb___0 , adns_rrtype type ) 
{ 
  byte *rqp ;
  byte *tmp ;
  byte *tmp___0 ;
  byte *tmp___1 ;
  byte *tmp___2 ;

  {
#line 68
  rqp = vb___0->buf + vb___0->used;
#line 69
  tmp = rqp;
#line 69
  rqp ++;
#line 69
  *tmp = (byte )((((unsigned int )type & 65535U) >> 8) & 255U);
#line 69
  tmp___0 = rqp;
#line 69
  rqp ++;
#line 69
  *tmp___0 = (byte )(((unsigned int )type & 65535U) & 255U);
#line 70
  tmp___1 = rqp;
#line 70
  rqp ++;
#line 70
  *tmp___1 = (byte )((1 >> 8) & 255);
#line 70
  tmp___2 = rqp;
#line 70
  rqp ++;
#line 70
  *tmp___2 = (byte )1;
#line 71
  vb___0->used = (int )(rqp - vb___0->buf);
#line 72
  if (! (vb___0->used <= vb___0->avail)) {
    {
#line 72
    __assert_fail("vb->used <= vb->avail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/transmit.c",
                  72U, "mkquery_footer");
    }
  }
#line 74
  return ((adns_status )0);
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../src/transmit.c"
static void query_usetcp___6(adns_query qu , struct timeval now ) 
{ 


  {
  {
#line 244
  qu->state = (enum __anonenum_state_83 )1;
#line 245
  qu->timeout = now;
#line 246
  timevaladd(& qu->timeout, 30000L);
  }
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    qu->next = (adns_query )0;
#line 247
    qu->back = (qu->ads)->tcpw.tail;
#line 247
    if ((qu->ads)->tcpw.tail) {
#line 247
      ((qu->ads)->tcpw.tail)->next = qu;
    } else {
#line 247
      (qu->ads)->tcpw.head = qu;
    }
#line 247
    (qu->ads)->tcpw.tail = qu;
#line 247
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 248
  adns__querysend_tcp(qu, now);
#line 249
  adns__tcp_tryconnect(qu->ads, now);
  }
#line 250
  return;
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-opts.c"
static struct optioninfo  const  global_options___0[17]  = 
#line 38 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-opts.c"
  {      {(enum oi_type )1, "global binary options:", (char const   *)0, (char const   *)0,
      (int *)0, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )2, "Do not look at environment variables at all", "e", "env",
      & ov_env, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )2, "Read queries on stdin instead of using args", "f", "pipe",
      & ov_pipe, 1, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )2, "Allow answers to be reordered", "a", "asynch", & ov_asynch,
      1, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )1, "answer/error output format and destination (see below):",
      (char const   *)0, (char const   *)0, (int *)0, 0, (optfunc *)0, (char const   *)0,
      (char const   *)0}, 
        {(enum oi_type )3, "Answers to stdout, errors as messages to stderr (default)",
      "Fs", "fmt-simple", & ov_format, 1, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )3,
      "Answers and errors both to stdout in parseable format", "Fi", "fmt-inline",
      & ov_format, 2, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )3, "Fully-parseable output format (default for --asynch)", "Fa",
      "fmt-asynch", & ov_format, 3, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )1,
      "global verbosity level:", (char const   *)0, (char const   *)0, (int *)0, 0,
      (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )3, "Do not print anything to stderr", "Vq", "quiet", & ov_verbose,
      2, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )3, "Report unexpected kinds of problem only  (default)", "Vn",
      "no-quiet", & ov_verbose, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )3,
      "Debugging mode", "Vd", "debug", & ov_verbose, 8, (optfunc *)0, (char const   *)0,
      (char const   *)0}, 
        {(enum oi_type )1, "other global options:", (char const   *)0, (char const   *)0,
      (int *)0, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )5, "Configuration to use instead of /etc/resolv.conf", (char const   *)0,
      "config", (int *)0, 0, & of_config, "<config-text>", (char const   *)0}, 
        {(enum oi_type )4, "Print version number", (char const   *)0, "version", (int *)0,
      0, & of_version, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )4, "Print usage information", (char const   *)0, "help", (int *)0,
      0, & of_help, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )0, (char const   *)0, (char const   *)0, (char const   *)0, (int *)0,
      0, (optfunc *)0, (char const   *)0, (char const   *)0}};
#line 74 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-opts.c"
static struct optioninfo  const  perquery_options___0[25]  = 
#line 74
  {      {(enum oi_type )1, "per-query options:", (char const   *)0, (char const   *)0,
      (int *)0, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )5, "Query type (see below)", "t", "type", (int *)0, 0, & of_type,
      "type", (char const   *)0}, 
        {(enum oi_type )5, "Do reverse query (address -> name lookup)", "i", "ptr", (int *)0,
      0, & of_ptr, "addr", (char const   *)0}, 
        {(enum oi_type )6, "Lookup in in-addr-like `zone\' (eg MAPS RBL)", (char const   *)0,
      "reverse", (int *)0, 0, & of_reverse, "addr", "zone"}, 
        {(enum oi_type )1, "per-query binary options:", (char const   *)0, (char const   *)0,
      (int *)0, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )2, "Use the search list", "s", "search", & ov_search, 1, (optfunc *)0,
      (char const   *)0, (char const   *)0}, 
        {(enum oi_type )2, "Let query domains contain quote-requiring chars", "Qq", "qc-query",
      & ov_qc_query, 1, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )2, "Let hostnames in answers contain ...", "Qa", "qc-anshost",
      & ov_qc_anshost, 1, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )2, "Prevent CNAME target domains from containing ...", "Qc",
      "qc-cname", & ov_qc_cname, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )2,
      "Force use of a virtual circuit", "u", "tcp", & ov_tcp, 1, (optfunc *)0, (char const   *)0,
      (char const   *)0}, 
        {(enum oi_type )2, "Do not display owner name in output", "Do", "show-owner",
      & ov_pqfr.show_owner, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )2,
      "Do not display RR type in output", "Dt", "show-type", & ov_pqfr.show_type,
      0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )2, "Do not display CNAME target in output", "Dc", "show-cname",
      & ov_pqfr.show_cname, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )1,
      "per-query TTL mode (NB TTL is minimum across all info in reply):", (char const   *)0,
      (char const   *)0, (int *)0, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )3,
      "Show the TTL as a TTL", "Tt", "ttl-ttl", & ov_pqfr.ttl, 1, (optfunc *)0, (char const   *)0,
      (char const   *)0}, 
        {(enum oi_type )3, "Show the TTL as a time_t when the data might expire", "Ta",
      "ttl-abs", & ov_pqfr.ttl, 2, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )3,
      "Do not show the TTL (default)", "Tn", "no-ttl", & ov_pqfr.ttl, 0, (optfunc *)0,
      (char const   *)0, (char const   *)0}, 
        {(enum oi_type )1, "per-query CNAME handling mode:", (char const   *)0, (char const   *)0,
      (int *)0, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )3, "Call it an error if a CNAME is found", "Cf", "cname-reject",
      & ov_cname, 512, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )3, "Allow references to CNAMEs in other RRs", "Cl", "cname-loose",
      & ov_cname, 256, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )3, "CNAME ok for query domain, but not in RRs (default)", "Cs",
      "cname-ok", & ov_cname, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )1,
      "asynchronous/pipe mode options:", (char const   *)0, (char const   *)0, (int *)0,
      0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )5, "Set <id>, default is decimal sequence starting 0", (char const   *)0,
      "asynch-id", (int *)0, 0, & of_asynch_id, "id", (char const   *)0}, 
        {(enum oi_type )5, "Cancel the query with id <id> (no error if not found)", (char const   *)0,
      "cancel-id", (int *)0, 0, & of_cancel_id, "id", (char const   *)0}, 
        {(enum oi_type )0, (char const   *)0, (char const   *)0, (char const   *)0, (int *)0,
      0, (optfunc *)0, (char const   *)0, (char const   *)0}};
#line 127
static void printusage___0(void) ;
#line 127 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-opts.c"
static struct optioninfo  const  * const  all_optiontables___0[3]  = {      (struct optioninfo  const  */* const  */)(global_options___0),      (struct optioninfo  const  */* const  */)(perquery_options___0),      (struct optioninfo  const  */* const  */)0};
#line 126 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-opts.c"
static void printusage___0(void) 
{ 
  struct optioninfo  const  * const  *oiap ;
  struct optioninfo  const  *oip ;
  int maxsopt ;
  int maxlopt ;
  int l ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  int tmp___13 ;

  {
#line 131
  oip = (struct optioninfo  const  *)0;
#line 134
  maxlopt = 0;
#line 134
  maxsopt = maxlopt;
#line 136
  oiap = all_optiontables___0;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (! *oiap) {
#line 136
      goto while_break;
    }
#line 137
    oip = (struct optioninfo  const  *)*oiap;
    {
#line 137
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 137
      if (! ((unsigned int const   )oip->type != 0U)) {
#line 137
        goto while_break___0;
      }
#line 138
      if ((unsigned int const   )oip->type == 5U) {
#line 138
        goto __Cont;
      }
#line 139
      if (oip->sopt) {
        {
#line 139
        tmp = strlen((char const   *)oip->sopt);
#line 139
        l = (int )tmp;
        }
#line 139
        if (l > maxsopt) {
#line 139
          maxsopt = l;
        }
      }
#line 140
      if (oip->lopt) {
        {
#line 141
        tmp___0 = strlen((char const   *)oip->lopt);
#line 141
        l = (int )tmp___0;
        }
#line 142
        if ((unsigned int const   )oip->type == 2U) {
#line 142
          if (! oip->value) {
#line 142
            l += 3;
          }
        }
#line 143
        if (l > maxlopt) {
#line 143
          maxlopt = l;
        }
      }
      __Cont: /* CIL Label */ 
#line 137
      oip ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 136
    oiap ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 148
  fputs((char const   */* __restrict  */)"usage: adnshost [global-opts] [query-opts] query-domain\n                             [[query-opts] query-domain ...]\n       adnshost [global-opts] [query-opts] -f|--pipe\n",
        (FILE */* __restrict  */)stdout);
#line 153
  oiap = all_optiontables___0;
  }
  {
#line 153
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 153
    if (! *oiap) {
#line 153
      goto while_break___1;
    }
    {
#line 154
    putchar('\n');
#line 155
    oip = (struct optioninfo  const  *)*oiap;
    }
    {
#line 155
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 155
      if (! ((unsigned int const   )oip->type != 0U)) {
#line 155
        goto while_break___2;
      }
      {
#line 157
      if ((unsigned int const   )oip->type == 2U) {
#line 157
        goto case_2;
      }
#line 171
      if ((unsigned int const   )oip->type == 4U) {
#line 171
        goto case_4;
      }
#line 171
      if ((unsigned int const   )oip->type == 3U) {
#line 171
        goto case_4;
      }
#line 183
      if ((unsigned int const   )oip->type == 5U) {
#line 183
        goto case_5;
      }
#line 200
      if ((unsigned int const   )oip->type == 6U) {
#line 200
        goto case_6;
      }
#line 209
      if ((unsigned int const   )oip->type == 1U) {
#line 209
        goto case_1;
      }
#line 212
      goto switch_default;
      case_2: /* CIL Label */ 
#line 158
      if (! oip->value) {
#line 159
        if (oip->sopt) {
          {
#line 160
          printf((char const   */* __restrict  */)" +%-*s --no-%-*s %s\n", maxsopt,
                 oip->sopt, maxlopt - 2, oip->lopt, oip->desc);
          }
        } else {
          {
#line 165
          printf((char const   */* __restrict  */)" --no-%-*s %s\n", (maxlopt + maxsopt) + 1,
                 oip->lopt, oip->desc);
          }
        }
#line 169
        goto switch_break;
      }
      case_4: /* CIL Label */ 
      case_3: /* CIL Label */ 
#line 172
      if (oip->sopt) {
        {
#line 173
        printf((char const   */* __restrict  */)" -%-*s --%-*s %s\n", maxsopt, oip->sopt,
               maxlopt + 1, oip->lopt, oip->desc);
        }
      } else {
        {
#line 178
        printf((char const   */* __restrict  */)" --%-*s %s\n", (maxlopt + maxsopt) + 3,
               oip->lopt, oip->desc);
        }
      }
#line 182
      goto switch_break;
      case_5: /* CIL Label */ 
#line 184
      if (oip->sopt) {
        {
#line 185
        tmp___1 = strlen((char const   *)oip->sopt);
#line 185
        tmp___2 = strlen((char const   *)oip->lopt);
#line 185
        tmp___3 = strlen((char const   *)oip->argdesc);
#line 185
        l = (int )((size_t )((maxlopt + maxsopt) - 9) - ((tmp___1 + tmp___2) + 2UL * tmp___3));
        }
#line 187
        if (l > 2) {
#line 187
          tmp___4 = l;
        } else {
#line 187
          tmp___4 = 2;
        }
        {
#line 187
        printf((char const   */* __restrict  */)" -%s<%s> / --%s <%s>%*s%s\n", oip->sopt,
               oip->argdesc, oip->lopt, oip->argdesc, tmp___4, "", oip->desc);
        }
      } else {
        {
#line 192
        tmp___5 = strlen((char const   *)oip->lopt);
#line 192
        tmp___6 = strlen((char const   *)oip->argdesc);
#line 192
        l = (int )((size_t )((maxlopt + maxsopt) + 1) - (tmp___5 + tmp___6));
        }
#line 194
        if (l > 2) {
#line 194
          tmp___7 = l;
        } else {
#line 194
          tmp___7 = 2;
        }
        {
#line 194
        printf((char const   */* __restrict  */)" --%s <%s>%*s%s\n", oip->lopt, oip->argdesc,
               tmp___7, "", oip->desc);
        }
      }
#line 199
      goto switch_break;
      case_6: /* CIL Label */ 
#line 201
      if (! (! oip->sopt)) {
        {
#line 201
        __assert_fail("!oip->sopt", "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-opts.c",
                      201U, "printusage");
        }
      }
      {
#line 202
      tmp___8 = strlen((char const   *)oip->lopt);
#line 202
      tmp___9 = strlen((char const   *)oip->argdesc);
#line 202
      tmp___10 = strlen((char const   *)oip->argdesc2);
#line 202
      l = (int )((size_t )((maxlopt + maxsopt) - 2) - ((tmp___8 + tmp___9) + tmp___10));
      }
#line 204
      if (l > 2) {
#line 204
        tmp___11 = l;
      } else {
#line 204
        tmp___11 = 2;
      }
      {
#line 204
      printf((char const   */* __restrict  */)" --%s <%s> <%s>%*s%s\n", oip->lopt,
             oip->argdesc, oip->argdesc2, tmp___11, "", oip->desc);
      }
#line 208
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 210
      printf((char const   */* __restrict  */)"%s\n", oip->desc);
      }
#line 211
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 213
      abort();
      }
      switch_break: /* CIL Label */ ;
      }
#line 155
      oip ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 153
    oiap ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 218
  printf((char const   */* __restrict  */)"\nEscaping domains which might start with `-\':\n - %-*s Next argument is a domain, but more options may follow\n",
         (maxlopt + maxsopt) + 3, "<domain>");
#line 222
  fputs((char const   */* __restrict  */)"\nQuery domains should always be quoted according to master file format.\n\nFor binary options, --FOO and --no-FOO are opposites, as are\n-X and +X.  In each case the default is the one not listed.\nPer query options stay set a particular way until they are reset,\nwhether they appear on the command line or on stdin.\nAll global options must preceed the first query domain.\n\nWith -f, the input should be lines with either an option, possibly\nwith a value argument (separated from the option by a space if it\'s a long\noption), or a domain (possibly preceded by a hyphen and a space to\ndistinguish it from an option).\n\nOutput format is master file format without class or TTL by default:\n   [<owner>] [<ttl>] [<type>] <data>\nor if the <owner> domain refers to a CNAME and --show-cname is on\n   [<owner>] [<ttl>] CNAME <cname>\n   [<cname>] [<ttl>] <type> <data>\nWhen a query fails you get an error message to stderr (with --fmt-simple).\nSpecify --fmt-inline for lines like this (broken here for readability):\n   ; failed <statustype> <statusnum> <statusabbrev> \\\n       [<owner>] [<ttl>] [<cname>] \"<status string>\"\nIf you use --fmt-asynch, which is the default for --asynch,\neach answer (success or failure) is preceded by a line\n   <id> <nrrs> <statustype> <statusnum> <statusabbrev> \\\n       [<owner>] [<ttl>] [<cname>] \"<status string>\"\nwhere <nrrs> is the number of RRs that follow and <cname> will be `$\' or\nthe CNAME target; the CNAME indirection and error formats above are not used.\n\nExit status:\n 0    all went well\n 1-6  at least one query failed with statustype:\n   1    localfail   )\n   2    remotefail  ) temporary errors\n   3    tempfail  __)_________________\n   4    misconfig   )\n   5    misquery    ) permanent errors\n   6    permfail    )\n 10   system trouble\n 11   usage problems\n\nQuery types (see adns.h; default is addr):\n  ns  soa  ptr  mx  rp  srv  addr       - enhanced versions\n  cname  hinfo  txt                     - types with only one version\n  a  ns-  soa-  ptr-  mx-  rp-  srv-    - _raw versions\n  type<number>                          - `unknown\' type, RFC3597\nDefault is addr, or ptr for -i/--ptr queries\n",
        (FILE */* __restrict  */)stdout);
#line 271
  tmp___13 = ferror(stdout);
  }
#line 271
  if (tmp___13) {
    {
#line 271
    tmp___12 = __errno_location();
#line 271
    sysfail("write usage message", *tmp___12);
    }
  }
#line 272
  return;
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-opts.c"
static int oc_long___0(char const   **optp , struct optioninfo  const  *entry ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 287
  if (entry->lopt) {
    {
#line 287
    tmp = strcmp(*optp, (char const   *)entry->lopt);
    }
#line 287
    if (tmp) {
#line 287
      tmp___0 = 0;
    } else {
#line 287
      tmp___0 = 1;
    }
  } else {
#line 287
    tmp___0 = 0;
  }
#line 287
  return (tmp___0);
}
}
#line 290 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-opts.c"
static int oc_short___0(char const   **optp , struct optioninfo  const  *entry ) 
{ 
  char const   *sopt ;
  int l ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 294
  sopt = (char const   *)entry->sopt;
#line 295
  if (! sopt) {
#line 295
    return (0);
  }
  {
#line 296
  tmp = strlen(sopt);
#line 296
  l = (int )tmp;
#line 297
  tmp___0 = memcmp((void const   *)*optp, (void const   *)sopt, (size_t )l);
  }
#line 297
  if (tmp___0) {
#line 297
    return (0);
  }
#line 298
  *optp += l;
#line 299
  return (1);
}
}
#line 302 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-opts.c"
static struct optioninfo  const  *find1___0(char const   **optp , struct optioninfo  const  *table ,
                                            comparer_type *comparer___3 ) 
{ 
  int tmp ;

  {
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;
#line 306
    if ((unsigned int const   )table->type == 0U) {
#line 306
      return ((struct optioninfo  const  *)0);
    }
    {
#line 307
    tmp = (*comparer___3)(optp, table);
    }
#line 307
    if (tmp) {
#line 307
      return (table);
    }
#line 308
    table ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-opts.c"
static struct optioninfo  const  *find___0(char const   **optp , char const   *prefix ,
                                           comparer_type *comparer___3 ) 
{ 
  struct optioninfo  const  *oip ;
  char const   *opt ;

  {
  {
#line 318
  opt = *optp;
#line 319
  oip = find1___0(optp, perquery_options___0, comparer___3);
  }
#line 320
  if (oip) {
#line 320
    return (oip);
  }
  {
#line 321
  oip = find1___0(optp, global_options___0, comparer___3);
  }
#line 322
  if (! oip) {
    {
#line 322
    usageerr("unknown option %s%s", prefix, opt);
    }
  }
#line 323
  if (ads) {
    {
#line 323
    usageerr("global option %s%s specified after query domain(s)", prefix, opt);
    }
  }
#line 324
  return (oip);
}
}
#line 330
static  __attribute__((__noreturn__)) void noninvert___0(struct optioninfo  const  *oip ) ;
#line 331
static  __attribute__((__noreturn__)) void noninvert___0(struct optioninfo  const  *oip ) ;
#line 331 "/home/june/repo/benchmarks/collector/temp/adns-1.4/regress/../client/adh-opts.c"
static void noninvert___0(struct optioninfo  const  *oip ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 332
  if (oip->lopt) {
#line 332
    tmp = oip->lopt;
  } else {
#line 332
    tmp = (char const   */* const  */)"";
  }
#line 332
  if (oip->lopt) {
#line 332
    tmp___0 = "--";
  } else {
#line 332
    tmp___0 = "";
  }
#line 332
  if (oip->lopt) {
#line 332
    if (oip->sopt) {
#line 332
      tmp___1 = " / ";
    } else {
#line 332
      tmp___1 = "";
    }
  } else {
#line 332
    tmp___1 = "";
  }
#line 332
  if (oip->sopt) {
#line 332
    tmp___2 = oip->sopt;
  } else {
#line 332
    tmp___2 = (char const   */* const  */)"";
  }
#line 332
  if (oip->sopt) {
#line 332
    tmp___3 = "-";
  } else {
#line 332
    tmp___3 = "";
  }
  {
#line 332
  usageerr("option %s%s%s%s%s may not be inverted", tmp___3, tmp___2, tmp___1, tmp___0,
           tmp);
  }
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static int bracket___1  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static int forever___1  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static int address___1  ;
#line 59 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static unsigned long timeout___1  =    1000UL;
#line 60 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static adns_rrtype rrt___1  =    (adns_rrtype )65548;
#line 61 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static adns_initflags initflags___1  =    (adns_initflags )0;
#line 62 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static char const   *config_text___4  ;
#line 64 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static int outblocked___1  ;
#line 64 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static int inputeof___1  ;
#line 65 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static struct __anonstruct_outqueue_55___1 outqueue___1  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static int peroutqueuenode___1  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static int outqueuelen___1  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static struct sockaddr_in sa___1  ;
#line 69 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static adns_state ads___4  ;
#line 71 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static char addrtextbuf___1[14]  ;
#line 72 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static int cbyte___1  ;
#line 72 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static int inbyte___1  ;
#line 72 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static int inbuf___1  ;
#line 73 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static unsigned char bytes___1[4]  ;
#line 74 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static struct timeval printbefore___1  ;
#line 82 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static struct treething *newthing___1  ;
#line 83 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static void *treeroot___1  ;
#line 85 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static int nonblock___1(int fd , int isnonblock ) 
{ 
  int r ;
  int tmp ;

  {
  {
#line 88
  r = fcntl(fd, 3);
  }
#line 89
  if (r == -1) {
#line 89
    return (-1);
  }
#line 90
  if (isnonblock) {
#line 90
    tmp = r | 2048;
  } else {
#line 90
    tmp = r & -2049;
  }
  {
#line 90
  r = fcntl(fd, 4, tmp);
  }
#line 91
  if (r == -1) {
#line 91
    return (-1);
  }
#line 92
  return (0);
}
}
#line 101
static  __attribute__((__noreturn__)) void sysfail___2(char const   *what ) ;
#line 102
static  __attribute__((__noreturn__)) void sysfail___2(char const   *what ) ;
#line 102 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static void sysfail___2(char const   *what ) 
{ 
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 103
  tmp = __errno_location();
#line 103
  tmp___0 = strerror(*tmp);
#line 103
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adnsresfilter: system call failed: %s: %s\n",
          what, tmp___0);
#line 104
  quitnow(2);
  }
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static void *xmalloc___2(size_t sz ) 
{ 
  void *r ;

  {
  {
#line 109
  r = malloc(sz);
  }
#line 109
  if (r) {
#line 109
    return (r);
  }
  {
#line 110
  sysfail___2("malloc");
  }
}
}
#line 113
static  __attribute__((__noreturn__)) void outputerr___1(void) ;
#line 114
static  __attribute__((__noreturn__)) void outputerr___1(void) ;
#line 114 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static void outputerr___1(void) 
{ 


  {
  {
#line 114
  sysfail___2("write to stdout");
  }
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static void usage___3(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 117
  tmp = printf((char const   */* __restrict  */)"usage: adnsresfilter [<options ...>]\n       adnsresfilter  -h|--help | --version\noptions: -t<milliseconds>|--timeout <milliseconds>\n         -w|--wait        (always wait for queries to time out or fail)\n         -b|--brackets    (require [...] around IP addresses)\n         -a|--address     (always include [address] in output)\n         -u|--unchecked   (do not forward map for checking)\n         --config <text>  (use this instead of resolv.conf)\n         --debug          (turn on adns resolver debugging)\nTimeout is the maximum amount to delay any particular bit of output for.\nLookups will go on in the background.  Default timeout = 1000 (ms).\n");
  }
#line 117
  if (tmp == -1) {
    {
#line 128
    outputerr___1();
    }
  }
  {
#line 129
  tmp___0 = fflush(stdout);
  }
#line 129
  if (tmp___0) {
    {
#line 129
    sysfail___2("flush stdout");
    }
  }
#line 130
  return;
}
}
#line 132
static  __attribute__((__noreturn__)) void usageerr___4(char const   *why ) ;
#line 133
static  __attribute__((__noreturn__)) void usageerr___4(char const   *why ) ;
#line 133 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static void usageerr___4(char const   *why ) 
{ 


  {
  {
#line 134
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adnsresfilter: bad usage: %s\n",
          why);
#line 135
  usage___3();
#line 136
  quitnow(1);
  }
}
}
#line 139
static  __attribute__((__noreturn__)) void adnsfail___1(char const   *what , int e ) ;
#line 140
static  __attribute__((__noreturn__)) void adnsfail___1(char const   *what , int e ) ;
#line 140 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static void adnsfail___1(char const   *what , int e ) 
{ 
  char *tmp ;

  {
  {
#line 141
  tmp = strerror(e);
#line 141
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adnsresfilter: adns call failed: %s: %s\n",
          what, tmp);
#line 142
  quitnow(2);
  }
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static void settimeout___1(char const   *arg ) 
{ 
  char *ep ;

  {
  {
#line 147
  timeout___1 = strtoul((char const   */* __restrict  */)arg, (char **/* __restrict  */)(& ep),
                        0);
  }
#line 148
  if (*ep) {
    {
#line 148
    usageerr___4("invalid timeout");
    }
  }
#line 149
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static void parseargs___1(char const   * const  *argv ) 
{ 
  char const   *arg ;
  int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    argv ++;
#line 155
    arg = (char const   *)*argv;
#line 155
    if (! arg) {
#line 155
      goto while_break;
    }
#line 156
    if ((int const   )*(arg + 0) != 45) {
      {
#line 156
      usageerr___4("no non-option arguments are allowed");
      }
    }
#line 157
    if ((int const   )*(arg + 1) == 45) {
      {
#line 158
      tmp___9 = strcmp(arg, "--timeout");
      }
#line 158
      if (tmp___9) {
        {
#line 162
        tmp___8 = strcmp(arg, "--wait");
        }
#line 162
        if (tmp___8) {
          {
#line 164
          tmp___7 = strcmp(arg, "--brackets");
          }
#line 164
          if (tmp___7) {
            {
#line 166
            tmp___6 = strcmp(arg, "--address");
            }
#line 166
            if (tmp___6) {
              {
#line 168
              tmp___5 = strcmp(arg, "--unchecked");
              }
#line 168
              if (tmp___5) {
                {
#line 170
                tmp___4 = strcmp(arg, "--config");
                }
#line 170
                if (tmp___4) {
                  {
#line 173
                  tmp___3 = strcmp(arg, "--debug");
                  }
#line 173
                  if (tmp___3) {
                    {
#line 175
                    tmp___2 = strcmp(arg, "--help");
                    }
#line 175
                    if (tmp___2) {
                      {
#line 177
                      tmp___1 = strcmp(arg, "--version");
                      }
#line 177
                      if (tmp___1) {
                        {
#line 180
                        usageerr___4("unknown long option");
                        }
                      } else {
                        {
#line 178
                        tmp = fputs((char const   */* __restrict  */)"adnsresfilter (GNU adns) 1.2\n\nCopyright (C) 1997-2000,2003,2006  Ian Jackson\nCopyright (C) 1999-2000,2003,2006  Tony Finch\nCopyright (C) 1991 Massachusetts Institute of Technology\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n",
                                    (FILE */* __restrict  */)stdout);
                        }
#line 178
                        if (tmp == -1) {
                          {
#line 178
                          perror("adnsresfilter: write version message");
#line 178
                          quitnow(-1);
                          }
                        } else {
                          {
#line 178
                          tmp___0 = fclose(stdout);
                          }
#line 178
                          if (tmp___0) {
                            {
#line 178
                            perror("adnsresfilter: write version message");
#line 178
                            quitnow(-1);
                            }
                          }
                        }
                        {
#line 178
                        quitnow(0);
#line 178
                        quitnow(0);
                        }
                      }
                    } else {
                      {
#line 176
                      usage___3();
#line 176
                      quitnow(0);
                      }
                    }
                  } else {
#line 174
                    initflags___1 = (adns_initflags )((unsigned int )initflags___1 | 8U);
                  }
                } else {
#line 171
                  argv ++;
#line 171
                  arg = (char const   *)*argv;
#line 171
                  if (! arg) {
                    {
#line 171
                    usageerr___4("--config needs a value");
                    }
                  }
#line 172
                  config_text___4 = arg;
                }
              } else {
#line 169
                rrt___1 = (adns_rrtype )12;
              }
            } else {
#line 167
              address___1 = 1;
            }
          } else {
#line 165
            bracket___1 = 1;
          }
        } else {
#line 163
          forever___1 = 1;
        }
      } else {
#line 159
        argv ++;
#line 159
        arg = (char const   *)*argv;
#line 159
        if (! arg) {
          {
#line 159
          usageerr___4("--timeout needs a value");
          }
        }
        {
#line 160
        settimeout___1(arg);
#line 161
        forever___1 = 0;
        }
      }
    } else {
      {
#line 183
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 183
        arg ++;
#line 183
        c = (int )*arg;
#line 183
        if (! c) {
#line 183
          goto while_break___0;
        }
        {
#line 185
        if (c == 116) {
#line 185
          goto case_116;
        }
#line 192
        if (c == 119) {
#line 192
          goto case_119;
        }
#line 195
        if (c == 98) {
#line 195
          goto case_98;
        }
#line 198
        if (c == 97) {
#line 198
          goto case_97;
        }
#line 201
        if (c == 117) {
#line 201
          goto case_117;
        }
#line 204
        if (c == 104) {
#line 204
          goto case_104;
        }
#line 207
        goto switch_default;
        case_116: /* CIL Label */ 
#line 186
        arg ++;
#line 186
        if (*arg) {
          {
#line 186
          settimeout___1(arg);
          }
        } else {
#line 187
          argv ++;
#line 187
          arg = (char const   *)*argv;
#line 187
          if (arg) {
            {
#line 187
            settimeout___1(arg);
            }
          } else {
            {
#line 188
            usageerr___4("-t needs a value");
            }
          }
        }
#line 189
        forever___1 = 0;
#line 190
        arg = "\000";
#line 191
        goto switch_break;
        case_119: /* CIL Label */ 
#line 193
        forever___1 = 1;
#line 194
        goto switch_break;
        case_98: /* CIL Label */ 
#line 196
        bracket___1 = 1;
#line 197
        goto switch_break;
        case_97: /* CIL Label */ 
#line 199
        address___1 = 1;
#line 200
        goto switch_break;
        case_117: /* CIL Label */ 
#line 202
        rrt___1 = (adns_rrtype )12;
#line 203
        goto switch_break;
        case_104: /* CIL Label */ 
        {
#line 205
        usage___3();
#line 206
        quitnow(0);
        }
        switch_default: /* CIL Label */ 
        {
#line 208
        usageerr___4("unknown short option");
        }
        switch_break: /* CIL Label */ ;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  return;
}
}
#line 215 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static void queueoutchar___1(int c ) 
{ 
  struct outqueuenode *entry ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 218
  entry = outqueue___1.tail;
#line 219
  if (! entry) {
#line 219
    goto _L;
  } else
#line 219
  if (entry->addr) {
#line 219
    goto _L;
  } else
#line 219
  if (entry->textlen >= peroutqueuenode___1) {
    _L: /* CIL Label */ 
#line 220
    if (! peroutqueuenode___1) {
#line 220
      peroutqueuenode___1 = 128;
    } else
#line 220
    if (! entry) {
#line 220
      peroutqueuenode___1 = 128;
    } else
#line 220
    if (entry->addr) {
#line 220
      peroutqueuenode___1 = 128;
    } else {
#line 220
      if (peroutqueuenode___1 >= 1024) {
#line 220
        tmp = 4096;
      } else {
#line 220
        tmp = peroutqueuenode___1 << 2;
      }
#line 220
      peroutqueuenode___1 = tmp;
    }
    {
#line 222
    tmp___0 = xmalloc___2(sizeof(*entry));
#line 222
    entry = (struct outqueuenode *)tmp___0;
#line 223
    entry->buffer = xmalloc___2((size_t )peroutqueuenode___1);
#line 224
    entry->textp = (char *)entry->buffer;
#line 225
    entry->textlen = 0;
#line 226
    entry->addr = (struct treething *)0;
    }
    {
#line 227
    while (1) {
      while_continue: /* CIL Label */ ;
#line 227
      entry->next = (struct outqueuenode *)0;
#line 227
      entry->back = outqueue___1.tail;
#line 227
      if (outqueue___1.tail) {
#line 227
        (outqueue___1.tail)->next = entry;
      } else {
#line 227
        outqueue___1.head = entry;
      }
#line 227
      outqueue___1.tail = entry;
#line 227
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 228
    outqueuelen___1 ++;
  }
#line 230
  tmp___1 = entry->textlen;
#line 230
  (entry->textlen) ++;
#line 230
  *(entry->textp + tmp___1) = (char )c;
#line 231
  return;
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static void queueoutstr___1(char const   *str , int len ) 
{ 
  char const   *tmp ;
  int tmp___0 ;

  {
  {
#line 234
  while (1) {
    while_continue: /* CIL Label */ ;
#line 234
    tmp___0 = len;
#line 234
    len --;
#line 234
    if (! (tmp___0 > 0)) {
#line 234
      goto while_break;
    }
    {
#line 234
    tmp = str;
#line 234
    str ++;
#line 234
    queueoutchar___1((int )*tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 235
  return;
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static void writestdout___1(struct outqueuenode *entry ) 
{ 
  int r ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 240
  while (1) {
    while_continue: /* CIL Label */ ;
#line 240
    if (! entry->textlen) {
#line 240
      goto while_break;
    }
    {
#line 241
    tmp = write(1, (void const   *)entry->textp, (size_t )entry->textlen);
#line 241
    r = (int )tmp;
    }
#line 242
    if (r < 0) {
      {
#line 243
      tmp___0 = __errno_location();
      }
#line 243
      if (*tmp___0 == 4) {
#line 243
        goto while_continue;
      }
      {
#line 244
      tmp___1 = __errno_location();
      }
#line 244
      if (*tmp___1 == 11) {
#line 244
        outblocked___1 = 1;
#line 244
        goto while_break;
      }
      {
#line 245
      sysfail___2("write stdout");
      }
    }
#line 247
    if (! (r <= entry->textlen)) {
      {
#line 247
      __assert_fail("r <= entry->textlen", "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c",
                    247U, "writestdout");
      }
    }
#line 248
    entry->textp += r;
#line 249
    entry->textlen -= r;
  }
  while_break: /* CIL Label */ ;
  }
#line 251
  if (! entry->textlen) {
    {
#line 252
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 252
      if (entry->back) {
#line 252
        (entry->back)->next = entry->next;
      } else {
#line 252
        outqueue___1.head = entry->next;
      }
#line 252
      if (entry->next) {
#line 252
        (entry->next)->back = entry->back;
      } else {
#line 252
        outqueue___1.tail = entry->back;
      }
#line 252
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 253
    free(entry->buffer);
#line 254
    free((void *)entry);
#line 255
    outqueuelen___1 --;
    }
  }
#line 257
  return;
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static void replacetextwithname___1(struct outqueuenode *entry ) 
{ 
  char *name ;
  char *newbuf ;
  int namelen ;
  int newlen ;
  size_t tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 263
  name = *(((entry->addr)->ans)->rrs.str + 0);
#line 264
  tmp = strlen((char const   *)name);
#line 264
  namelen = (int )tmp;
  }
#line 265
  if (! address___1) {
    {
#line 266
    free(entry->buffer);
#line 267
    entry->buffer = (void *)0;
#line 268
    entry->textp = name;
#line 269
    entry->textlen = namelen;
    }
  } else {
#line 271
    if (bracket___1) {
#line 271
      tmp___0 = 0;
    } else {
#line 271
      tmp___0 = 2;
    }
    {
#line 271
    newlen = (entry->textlen + namelen) + tmp___0;
#line 272
    tmp___1 = xmalloc___2((size_t )(newlen + 1));
#line 272
    newbuf = (char *)tmp___1;
    }
#line 273
    if (bracket___1) {
#line 273
      tmp___2 = "%s%.*s";
    } else {
#line 273
      tmp___2 = "%s[%.*s]";
    }
    {
#line 273
    sprintf((char */* __restrict  */)newbuf, (char const   */* __restrict  */)tmp___2,
            name, entry->textlen, entry->textp);
#line 274
    free(entry->buffer);
#line 275
    tmp___3 = newbuf;
#line 275
    entry->textp = tmp___3;
#line 275
    entry->buffer = (void *)tmp___3;
#line 276
    entry->textlen = newlen;
    }
  }
#line 278
  return;
}
}
#line 280 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static void checkadnsqueries___1(void) 
{ 
  adns_query qu ;
  adns_answer *ans ;
  void *context ;
  struct treething *foundthing ;
  int r ;

  {
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 288
    qu = (adns_query )0;
#line 288
    context = (void *)0;
#line 288
    ans = (adns_answer *)0;
#line 289
    r = adns_check(ads___4, & qu, & ans, & context);
    }
#line 290
    if (r == 3) {
#line 290
      goto while_break;
    } else
#line 290
    if (r == 11) {
#line 290
      goto while_break;
    }
#line 291
    if (! (! r)) {
      {
#line 291
      __assert_fail("!r", "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c",
                    291U, "checkadnsqueries");
      }
    }
#line 292
    foundthing = (struct treething *)context;
#line 293
    foundthing->ans = ans;
#line 294
    foundthing->qu = (adns_query )0;
  }
  while_break: /* CIL Label */ ;
  }
#line 296
  return;
}
}
#line 298 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static void restartbuf___1(void) 
{ 


  {
#line 299
  if (inbuf___1 > 0) {
    {
#line 299
    queueoutstr___1((char const   *)(addrtextbuf___1), inbuf___1);
    }
  }
#line 300
  inbuf___1 = 0;
#line 301
  return;
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static int comparer___1(void const   *a , void const   *b ) 
{ 
  int tmp ;

  {
  {
#line 304
  tmp = memcmp(a, b, (size_t )4);
  }
#line 304
  return (tmp);
}
}
#line 307 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static void procaddr___1(void) 
{ 
  struct treething *foundthing ;
  void **searchfound ;
  struct outqueuenode *entry ;
  int r ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 313
  if (! newthing___1) {
    {
#line 314
    tmp = xmalloc___2(sizeof(struct treething ));
#line 314
    newthing___1 = (struct treething *)tmp;
#line 315
    newthing___1->qu = (adns_query )0;
#line 316
    newthing___1->ans = (adns_answer *)0;
    }
  }
  {
#line 319
  memcpy((void */* __restrict  */)(newthing___1->bytes), (void const   */* __restrict  */)(bytes___1),
         (size_t )4);
#line 320
  tmp___0 = tsearch((void const   *)newthing___1, & treeroot___1, & comparer___1);
#line 320
  searchfound = (void **)tmp___0;
  }
#line 321
  if (! searchfound) {
    {
#line 321
    sysfail___2("tsearch");
    }
  }
#line 322
  foundthing = (struct treething *)*searchfound;
#line 324
  if ((unsigned long )foundthing == (unsigned long )newthing___1) {
    {
#line 325
    newthing___1 = (struct treething *)0;
#line 326
    memcpy((void */* __restrict  */)(& sa___1.sin_addr), (void const   */* __restrict  */)(bytes___1),
           (size_t )4);
#line 327
    r = adns_submit_reverse(ads___4, (struct sockaddr  const  *)(& sa___1), rrt___1,
                            (adns_queryflags )0, (void *)foundthing, & foundthing->qu);
    }
#line 329
    if (r) {
      {
#line 329
      adnsfail___1("submit", r);
      }
    }
  }
  {
#line 331
  tmp___1 = xmalloc___2(sizeof(*entry));
#line 331
  entry = (struct outqueuenode *)tmp___1;
#line 332
  entry->buffer = xmalloc___2((size_t )inbuf___1);
#line 333
  entry->textp = (char *)entry->buffer;
#line 334
  memcpy((void */* __restrict  */)entry->textp, (void const   */* __restrict  */)(addrtextbuf___1),
         (size_t )inbuf___1);
#line 335
  entry->textlen = inbuf___1;
#line 336
  entry->addr = foundthing;
#line 337
  entry->printbefore = printbefore___1;
  }
  {
#line 338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 338
    entry->next = (struct outqueuenode *)0;
#line 338
    entry->back = outqueue___1.tail;
#line 338
    if (outqueue___1.tail) {
#line 338
      (outqueue___1.tail)->next = entry;
    } else {
#line 338
      outqueue___1.head = entry;
    }
#line 338
    outqueue___1.tail = entry;
#line 338
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 339
  outqueuelen___1 ++;
#line 340
  inbuf___1 = 0;
#line 341
  cbyte___1 = -1;
#line 342
  return;
}
}
#line 344 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static void startaddr___1(void) 
{ 


  {
#line 345
  cbyte___1 = 0;
#line 345
  bytes___1[cbyte___1] = (unsigned char)0;
#line 346
  inbyte___1 = 0;
#line 347
  return;
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static void readstdin___1(void) 
{ 
  char readbuf[512] ;
  char *p ;
  int r ;
  int c ;
  int nbyte ;
  ssize_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;

  {
  {
#line 353
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 353
    tmp = read(0, (void *)(readbuf), sizeof(readbuf));
#line 353
    r = (int )tmp;
    }
#line 353
    if (! (r <= 0)) {
#line 353
      goto while_break;
    }
#line 354
    if (r == 0) {
#line 354
      inputeof___1 = 1;
#line 354
      return;
    }
#line 355
    if (r == 11) {
#line 355
      return;
    }
#line 356
    if (r != 4) {
      {
#line 356
      sysfail___2("read stdin");
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 358
  p = readbuf;
  {
#line 358
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 358
    if (! (r > 0)) {
#line 358
      goto while_break___0;
    }
#line 359
    c = (int )*p;
#line 360
    if (cbyte___1 == -1) {
#line 360
      if (bracket___1) {
#line 360
        if (c == 91) {
          {
#line 361
          tmp___0 = inbuf___1;
#line 361
          inbuf___1 ++;
#line 361
          addrtextbuf___1[tmp___0] = (char )c;
#line 362
          startaddr___1();
          }
        } else {
#line 360
          goto _L___15;
        }
      } else {
#line 360
        goto _L___15;
      }
    } else
    _L___15: /* CIL Label */ 
#line 363
    if (cbyte___1 == -1) {
#line 363
      if (! bracket___1) {
        {
#line 363
        tmp___6 = __ctype_b_loc();
        }
#line 363
        if ((int const   )*(*tmp___6 + c) & 8) {
#line 363
          goto _L___13;
        } else {
          {
#line 364
          queueoutchar___1(c);
#line 365
          startaddr___1();
          }
        }
      } else {
#line 363
        goto _L___13;
      }
    } else
    _L___13: /* CIL Label */ 
#line 366
    if (cbyte___1 >= 0) {
#line 366
      if (inbyte___1 < 3) {
#line 366
        if (c >= 48) {
#line 366
          if (c <= 57) {
#line 366
            nbyte = (int )bytes___1[cbyte___1] * 10 + (c - 48);
#line 366
            if (nbyte <= 255) {
#line 368
              bytes___1[cbyte___1] = (unsigned char )nbyte;
#line 369
              tmp___1 = inbuf___1;
#line 369
              inbuf___1 ++;
#line 369
              addrtextbuf___1[tmp___1] = (char )c;
#line 370
              inbyte___1 ++;
            } else {
#line 366
              goto _L___11;
            }
          } else {
#line 366
            goto _L___11;
          }
        } else {
#line 366
          goto _L___11;
        }
      } else {
#line 366
        goto _L___11;
      }
    } else
    _L___11: /* CIL Label */ 
#line 371
    if (cbyte___1 >= 0) {
#line 371
      if (cbyte___1 < 3) {
#line 371
        if (inbyte___1 > 0) {
#line 371
          if (c == 46) {
#line 372
            cbyte___1 ++;
#line 372
            bytes___1[cbyte___1] = (unsigned char)0;
#line 373
            tmp___2 = inbuf___1;
#line 373
            inbuf___1 ++;
#line 373
            addrtextbuf___1[tmp___2] = (char )c;
#line 374
            inbyte___1 = 0;
          } else {
#line 371
            goto _L___7;
          }
        } else {
#line 371
          goto _L___7;
        }
      } else {
#line 371
        goto _L___7;
      }
    } else
    _L___7: /* CIL Label */ 
#line 375
    if (cbyte___1 == 3) {
#line 375
      if (inbyte___1 > 0) {
#line 375
        if (bracket___1) {
#line 375
          if (c == 93) {
            {
#line 376
            tmp___3 = inbuf___1;
#line 376
            inbuf___1 ++;
#line 376
            addrtextbuf___1[tmp___3] = (char )c;
#line 377
            procaddr___1();
            }
          } else {
#line 375
            goto _L___4;
          }
        } else {
#line 375
          goto _L___4;
        }
      } else {
#line 375
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 378
    if (cbyte___1 == 3) {
#line 378
      if (inbyte___1 > 0) {
#line 378
        if (! bracket___1) {
          {
#line 378
          tmp___5 = __ctype_b_loc();
          }
#line 378
          if ((int const   )*(*tmp___5 + c) & 8) {
#line 378
            goto _L___1;
          } else {
            {
#line 379
            procaddr___1();
#line 380
            queueoutchar___1(c);
#line 381
            startaddr___1();
            }
          }
        } else {
#line 378
          goto _L___1;
        }
      } else {
#line 378
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 383
      restartbuf___1();
#line 384
      queueoutchar___1(c);
#line 385
      cbyte___1 = -1;
      }
#line 386
      if (! bracket___1) {
        {
#line 386
        tmp___4 = __ctype_b_loc();
        }
#line 386
        if (! ((int const   )*(*tmp___4 + c) & 8)) {
          {
#line 386
          startaddr___1();
          }
        }
      }
    }
#line 358
    r --;
#line 358
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 389
  return;
}
}
#line 391 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static void startup___1(void) 
{ 
  int r ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 394
  tmp = nonblock___1(0, 1);
  }
#line 394
  if (tmp) {
    {
#line 394
    sysfail___2("set stdin to nonblocking mode");
    }
  }
  {
#line 395
  tmp___0 = nonblock___1(1, 1);
  }
#line 395
  if (tmp___0) {
    {
#line 395
    sysfail___2("set stdout to nonblocking mode");
    }
  }
  {
#line 396
  memset((void *)(& sa___1), 0, sizeof(sa___1));
#line 397
  sa___1.sin_family = (sa_family_t )2;
  }
#line 398
  if (config_text___4) {
    {
#line 399
    r = adns_init_strcfg(& ads___4, initflags___1, stderr, config_text___4);
    }
  } else {
    {
#line 401
    r = adns_init(& ads___4, initflags___1, (FILE *)0);
    }
  }
#line 403
  if (r) {
    {
#line 403
    adnsfail___1("init", r);
    }
  }
#line 404
  cbyte___1 = -1;
#line 405
  inbyte___1 = -1;
#line 406
  inbuf___1 = 0;
#line 407
  if (! bracket___1) {
    {
#line 407
    startaddr___1();
    }
  }
#line 408
  return;
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pap_qstring___7(parseinfo const   *pai , int *cbyte_io , int max ,
                                   int *len_r , char **str_r ) 
{ 
  byte const   *dgram ;
  int l ;
  int cbyte___3 ;
  char *str ;
  int tmp ;
  void *tmp___0 ;

  {
#line 92
  dgram = (byte const   *)pai->dgram;
#line 96
  cbyte___3 = *cbyte_io;
#line 98
  if (cbyte___3 >= max) {
#line 98
    return ((adns_status )104);
  }
#line 99
  tmp = cbyte___3;
#line 99
  cbyte___3 ++;
#line 99
  l = (int )((int const   )*(dgram + tmp) & 255);
#line 100
  if (cbyte___3 + l > max) {
#line 100
    return ((adns_status )104);
  }
  {
#line 102
  tmp___0 = adns__alloc_interim((adns_query )pai->qu, (size_t )(l + 1));
#line 102
  str = (char *)tmp___0;
  }
#line 103
  if (! str) {
#line 103
    return ((adns_status )1);
  }
  {
#line 105
  *(str + l) = (char)0;
#line 106
  memcpy((void */* __restrict  */)str, (void const   */* __restrict  */)(dgram + cbyte___3),
         (size_t )l);
#line 108
  *len_r = l;
#line 109
  *str_r = str;
#line 110
  *cbyte_io = cbyte___3 + l;
  }
#line 112
  return ((adns_status )0);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status csp_qstring___7(vbuf *vb___0 , char const   *dp , int len ) 
{ 
  unsigned char ch ;
  char buf___17[10] ;
  int cn ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 120
    tmp = adns__vbuf_appendstr(vb___0, "\"");
    }
#line 120
    if (! tmp) {
#line 120
      return ((adns_status )1);
    }
#line 120
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  cn = 0;
  {
#line 121
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 121
    if (! (cn < len)) {
#line 121
      goto while_break___0;
    }
#line 122
    tmp___0 = dp;
#line 122
    dp ++;
#line 122
    ch = (unsigned char )*tmp___0;
#line 123
    if ((int )ch == 92) {
      {
#line 124
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 124
        tmp___1 = adns__vbuf_appendstr(vb___0, "\\\\");
        }
#line 124
        if (! tmp___1) {
#line 124
          return ((adns_status )1);
        }
#line 124
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else
#line 125
    if ((int )ch == 34) {
      {
#line 126
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 126
        tmp___2 = adns__vbuf_appendstr(vb___0, "\\\"");
        }
#line 126
        if (! tmp___2) {
#line 126
          return ((adns_status )1);
        }
#line 126
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else
#line 127
    if ((int )ch >= 32) {
#line 127
      if ((int )ch <= 126) {
        {
#line 128
        tmp___3 = adns__vbuf_append(vb___0, (byte const   *)(& ch), 1);
        }
#line 128
        if (! tmp___3) {
#line 128
          return ((adns_status )1);
        }
      } else {
#line 127
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 130
      sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"\\x%02x",
              (int )ch);
      }
      {
#line 131
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 131
        tmp___4 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
        }
#line 131
        if (! tmp___4) {
#line 131
          return ((adns_status )1);
        }
#line 131
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 121
    cn ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 134
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 134
    tmp___5 = adns__vbuf_appendstr(vb___0, "\"");
    }
#line 134
    if (! tmp___5) {
#line 134
      return ((adns_status )1);
    }
#line 134
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 136
  return ((adns_status )0);
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_str___7(adns_query qu , void *datap ) 
{ 
  char **rrp ;

  {
  {
#line 144
  rrp = (char **)datap;
#line 146
  adns__makefinal_str(qu, rrp);
  }
#line 147
  return;
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_intstr___7(adns_query qu , void *datap ) 
{ 
  adns_rr_intstr *rrp ;

  {
  {
#line 154
  rrp = (adns_rr_intstr *)datap;
#line 156
  adns__makefinal_str(qu, & rrp->str);
  }
#line 157
  return;
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_manyistr___7(adns_query qu , void *datap ) 
{ 
  adns_rr_intstr **rrp ;
  adns_rr_intstr *te ;
  adns_rr_intstr *table ;
  void *tablev ;
  int tc ;

  {
#line 164
  rrp = (adns_rr_intstr **)datap;
#line 169
  tc = 0;
#line 169
  te = *rrp;
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    if (! (te->i >= 0)) {
#line 169
      goto while_break;
    }
#line 169
    te ++;
#line 169
    tc ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 170
  tablev = (void *)*rrp;
#line 171
  adns__makefinal_block(qu, & tablev, sizeof(*te) * (unsigned long )(tc + 1));
#line 172
  table = (adns_rr_intstr *)tablev;
#line 172
  *rrp = table;
#line 173
  te = *rrp;
  }
  {
#line 173
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 173
    if (! (te->i >= 0)) {
#line 173
      goto while_break___0;
    }
    {
#line 174
    adns__makefinal_str(qu, & te->str);
#line 173
    te ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 175
  return;
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_txt___7(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  adns_rr_intstr **rrp ;
  adns_rr_intstr *table ;
  adns_rr_intstr *te ;
  byte const   *dgram ;
  int ti ;
  int tc ;
  int l ;
  int startbyte ;
  adns_status st ;
  int tmp ;
  void *tmp___0 ;

  {
#line 183
  rrp = (adns_rr_intstr **)datap;
#line 184
  dgram = (byte const   *)pai->dgram;
#line 188
  startbyte = cbyte___3;
#line 189
  if (cbyte___3 >= max) {
#line 189
    return ((adns_status )104);
  }
#line 190
  tc = 0;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! (cbyte___3 < max)) {
#line 191
      goto while_break;
    }
#line 192
    tmp = cbyte___3;
#line 192
    cbyte___3 ++;
#line 192
    l = (int )((int const   )*(dgram + tmp) & 255);
#line 193
    cbyte___3 += l;
#line 194
    tc ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  if (cbyte___3 != max) {
#line 196
    return ((adns_status )104);
  } else
#line 196
  if (! tc) {
#line 196
    return ((adns_status )104);
  }
  {
#line 198
  tmp___0 = adns__alloc_interim((adns_query )pai->qu, sizeof(*table) * (unsigned long )(tc + 1));
#line 198
  table = (adns_rr_intstr *)tmp___0;
  }
#line 199
  if (! table) {
#line 199
    return ((adns_status )1);
  }
#line 201
  cbyte___3 = startbyte;
#line 201
  ti = 0;
#line 201
  te = table;
  {
#line 201
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 201
    if (! (ti < tc)) {
#line 201
      goto while_break___0;
    }
    {
#line 202
    st = pap_qstring___7(pai, & cbyte___3, max, & te->i, & te->str);
    }
#line 203
    if (st) {
#line 203
      return (st);
    }
#line 201
    ti ++;
#line 201
    te ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 205
  if (! (cbyte___3 == max)) {
    {
#line 205
    __assert_fail("cbyte == max", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                  205U, "pa_txt");
    }
  }
#line 207
  te->i = -1;
#line 208
  te->str = (char *)0;
#line 210
  *rrp = table;
#line 211
  return ((adns_status )0);
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_txt___7(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_intstr const   * const  *rrp ;
  adns_rr_intstr const   *current ;
  adns_status st ;
  int spc ;
  int tmp ;

  {
#line 215
  rrp = (adns_rr_intstr const   * const  *)datap;
#line 220
  current = (adns_rr_intstr const   *)*rrp;
#line 220
  spc = 0;
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    if (! (current->i >= 0)) {
#line 220
      goto while_break;
    }
#line 221
    if (spc) {
      {
#line 221
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 221
        tmp = adns__vbuf_appendstr(vb___0, " ");
        }
#line 221
        if (! tmp) {
#line 221
          return ((adns_status )1);
        }
#line 221
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 222
    st = csp_qstring___7(vb___0, (char const   *)current->str, (int )current->i);
    }
#line 222
    if (st) {
#line 222
      return (st);
    }
#line 220
    current ++;
#line 220
    spc = 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  return ((adns_status )0);
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_hinfo___7(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_intstrpair const   *rrp ;
  adns_status st ;
  int tmp ;

  {
  {
#line 232
  rrp = (adns_rr_intstrpair const   *)datap;
#line 235
  st = csp_qstring___7(vb___0, (char const   *)rrp->array[0].str, (int )rrp->array[0].i);
  }
#line 235
  if (st) {
#line 235
    return (st);
  }
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 236
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 236
    if (! tmp) {
#line 236
      return ((adns_status )1);
    }
#line 236
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 237
  st = csp_qstring___7(vb___0, (char const   *)rrp->array[1].str, (int )rrp->array[1].i);
  }
#line 237
  if (st) {
#line 237
    return (st);
  }
#line 238
  return ((adns_status )0);
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_inaddr___7(parseinfo const   *pai , int cbyte___3 , int max ,
                                 void *datap ) 
{ 
  struct in_addr *storeto ;

  {
#line 247
  storeto = (struct in_addr *)datap;
#line 249
  if (max - cbyte___3 != 4) {
#line 249
    return ((adns_status )104);
  }
  {
#line 250
  memcpy((void */* __restrict  */)storeto, (void const   */* __restrict  */)(pai->dgram + cbyte___3),
         (size_t )4);
  }
#line 251
  return ((adns_status )0);
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int search_sortlist___7(adns_state ads___7 , struct in_addr ad ) 
{ 
  struct sortlist  const  *slp ;
  int i ;

  {
#line 258
  i = 0;
#line 258
  slp = (struct sortlist  const  *)(ads___7->sortlist);
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 258
    if (i < ads___7->nsortlist) {
#line 258
      if (! (! ((ad.s_addr & (unsigned int )slp->mask.s_addr) == (unsigned int )slp->base.s_addr))) {
#line 258
        goto while_break;
      }
    } else {
#line 258
      goto while_break;
    }
#line 258
    i ++;
#line 258
    slp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  return (i);
}
}
#line 265 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int dip_inaddr___7(adns_state ads___7 , struct in_addr a , struct in_addr b ) 
{ 
  int ai ;
  int bi ;

  {
#line 268
  if (! ads___7->nsortlist) {
#line 268
    return (0);
  }
  {
#line 270
  ai = search_sortlist___7(ads___7, a);
#line 271
  bi = search_sortlist___7(ads___7, b);
  }
#line 272
  return (bi < ai);
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int di_inaddr___7(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  struct in_addr  const  *ap ;
  struct in_addr  const  *bp ;
  int tmp ;

  {
  {
#line 277
  ap = (struct in_addr  const  *)datap_a;
#line 277
  bp = (struct in_addr  const  *)datap_b;
#line 279
  tmp = dip_inaddr___7(ads___7, (struct in_addr )*ap, (struct in_addr )*bp);
  }
#line 279
  return (tmp);
}
}
#line 282 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_inaddr___7(vbuf *vb___0 , void const   *datap ) 
{ 
  struct in_addr  const  *rrp ;
  struct in_addr rr ;
  char const   *ia ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 283
  rrp = (struct in_addr  const  *)datap;
#line 283
  rr = *rrp;
#line 286
  tmp = inet_ntoa(rr);
#line 286
  ia = (char const   *)tmp;
  }
#line 286
  if (! ia) {
    {
#line 286
    __assert_fail("ia", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                  286U, "cs_inaddr");
    }
  }
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 287
    tmp___0 = adns__vbuf_appendstr(vb___0, ia);
    }
#line 287
    if (! tmp___0) {
#line 287
      return ((adns_status )1);
    }
#line 287
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  return ((adns_status )0);
}
}
#line 295 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_addr___7(parseinfo const   *pai , int cbyte___3 , int max ,
                               void *datap ) 
{ 
  adns_rr_addr *storeto ;
  byte const   *dgram ;

  {
#line 297
  storeto = (adns_rr_addr *)datap;
#line 298
  dgram = (byte const   *)pai->dgram;
#line 300
  if (max - cbyte___3 != 4) {
#line 300
    return ((adns_status )104);
  }
  {
#line 301
  storeto->len = (int )sizeof(storeto->addr.inet);
#line 302
  memset((void *)(& storeto->addr), 0, sizeof(storeto->addr.inet));
#line 303
  storeto->addr.inet.sin_family = (sa_family_t )2;
#line 304
  memcpy((void */* __restrict  */)(& storeto->addr.inet.sin_addr), (void const   */* __restrict  */)(dgram + cbyte___3),
         (size_t )4);
  }
#line 305
  return ((adns_status )0);
}
}
#line 308 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int di_addr___7(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_addr const   *ap ;
  adns_rr_addr const   *bp ;
  int tmp ;

  {
#line 309
  ap = (adns_rr_addr const   *)datap_a;
#line 309
  bp = (adns_rr_addr const   *)datap_b;
#line 311
  if (! ((int const   )ap->addr.sa.sa_family == 2)) {
    {
#line 311
    __assert_fail("ap->addr.sa.sa_family == 2", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                  311U, "di_addr");
    }
  }
  {
#line 312
  tmp = dip_inaddr___7(ads___7, (struct in_addr )ap->addr.inet.sin_addr, (struct in_addr )bp->addr.inet.sin_addr);
  }
#line 312
  return (tmp);
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int div_addr___7(void *context , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_state ads___7 ;
  int tmp ;

  {
  {
#line 316
  ads___7 = (adns_state )context;
#line 318
  tmp = di_addr___7(ads___7, datap_a, datap_b);
  }
#line 318
  return (tmp);
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status csp_addr___7(vbuf *vb___0 , adns_rr_addr const   *rrp ) 
{ 
  char const   *ia ;
  char buf___17[30] ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 326
  if ((int const   )rrp->addr.inet.sin_family == 2) {
#line 326
    goto case_2;
  }
#line 331
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 327
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 327
    tmp = adns__vbuf_appendstr(vb___0, "INET ");
    }
#line 327
    if (! tmp) {
#line 327
      return ((adns_status )1);
    }
#line 327
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 328
  tmp___0 = inet_ntoa((struct in_addr )rrp->addr.inet.sin_addr);
#line 328
  ia = (char const   *)tmp___0;
  }
#line 328
  if (! ia) {
    {
#line 328
    __assert_fail("ia", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                  328U, "csp_addr");
    }
  }
  {
#line 329
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 329
    tmp___1 = adns__vbuf_appendstr(vb___0, ia);
    }
#line 329
    if (! tmp___1) {
#line 329
      return ((adns_status )1);
    }
#line 329
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 330
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 332
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"AF=%u",
          (int const   )rrp->addr.sa.sa_family);
  }
  {
#line 333
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 333
    tmp___2 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 333
    if (! tmp___2) {
#line 333
      return ((adns_status )1);
    }
#line 333
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 334
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 336
  return ((adns_status )0);
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_addr___7(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_addr const   *rrp ;
  adns_status tmp ;

  {
  {
#line 340
  rrp = (adns_rr_addr const   *)datap;
#line 342
  tmp = csp_addr___7(vb___0, rrp);
  }
#line 342
  return (tmp);
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pap_domain___7(parseinfo const   *pai , int *cbyte_io , int max ,
                                  char **domain_r , parsedomain_flags flags ) 
{ 
  adns_status st ;
  char *dm ;
  void *tmp ;

  {
  {
#line 355
  st = adns__parse_domain((pai->qu)->ads, (int )pai->serv, (adns_query )pai->qu, & (pai->qu)->vb,
                          flags, (byte const   *)pai->dgram, (int )pai->dglen, cbyte_io,
                          max);
  }
#line 357
  if (st) {
#line 357
    return (st);
  }
#line 358
  if (! (pai->qu)->vb.used) {
#line 358
    return ((adns_status )104);
  }
  {
#line 360
  tmp = adns__alloc_interim((adns_query )pai->qu, (size_t )((pai->qu)->vb.used + 1));
#line 360
  dm = (char *)tmp;
  }
#line 361
  if (! dm) {
#line 361
    return ((adns_status )1);
  }
  {
#line 363
  *(dm + (pai->qu)->vb.used) = (char)0;
#line 364
  memcpy((void */* __restrict  */)dm, (void const   */* __restrict  */)(pai->qu)->vb.buf,
         (size_t )(pai->qu)->vb.used);
#line 366
  *domain_r = dm;
  }
#line 367
  return ((adns_status )0);
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status csp_domain___7(vbuf *vb___0 , char const   *domain ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 371
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 371
    tmp = adns__vbuf_appendstr(vb___0, domain);
    }
#line 371
    if (! tmp) {
#line 371
      return ((adns_status )1);
    }
#line 371
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 372
  if (! *domain) {
    {
#line 372
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 372
      tmp___0 = adns__vbuf_appendstr(vb___0, ".");
      }
#line 372
      if (! tmp___0) {
#line 372
        return ((adns_status )1);
      }
#line 372
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 373
  return ((adns_status )0);
}
}
#line 376 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_domain___7(vbuf *vb___0 , void const   *datap ) 
{ 
  char const   * const  *domainp ;
  adns_status tmp ;

  {
  {
#line 377
  domainp = (char const   * const  *)datap;
#line 378
  tmp = csp_domain___7(vb___0, (char const   *)*domainp);
  }
#line 378
  return (tmp);
}
}
#line 381 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_dom_raw___7(parseinfo const   *pai , int cbyte___3 , int max ,
                                  void *datap ) 
{ 
  char **rrp ;
  adns_status st ;

  {
  {
#line 383
  rrp = (char **)datap;
#line 386
  st = pap_domain___7(pai, & cbyte___3, max, rrp, (parsedomain_flags )1);
  }
#line 387
  if (st) {
#line 387
    return (st);
  }
#line 389
  if (cbyte___3 != max) {
#line 389
    return ((adns_status )104);
  }
#line 390
  return ((adns_status )0);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_host_raw___7(parseinfo const   *pai , int cbyte___3 , int max ,
                                   void *datap ) 
{ 
  char **rrp ;
  adns_status st ;
  int tmp ;

  {
#line 399
  rrp = (char **)datap;
#line 402
  if ((pai->qu)->flags & 64) {
#line 402
    tmp = 1;
  } else {
#line 402
    tmp = 0;
  }
  {
#line 402
  st = pap_domain___7(pai, & cbyte___3, max, rrp, (parsedomain_flags )tmp);
  }
#line 404
  if (st) {
#line 404
    return (st);
  }
#line 406
  if (cbyte___3 != max) {
#line 406
    return ((adns_status )104);
  }
#line 407
  return ((adns_status )0);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pap_findaddrs___7(parseinfo const   *pai , adns_rr_hostaddr *ha ,
                                     int *cbyte_io , int count , int dmstart ) 
{ 
  int rri ;
  int naddrs ;
  int type ;
  int class ;
  int rdlen ;
  int rdstart ;
  int ownermatched ;
  unsigned long ttl ;
  adns_status st ;
  int tmp ;
  void *tmp___0 ;

  {
#line 421
  rri = 0;
#line 421
  naddrs = -1;
  {
#line 421
  while (1) {
    while_continue: /* CIL Label */ ;
#line 421
    if (! (rri < count)) {
#line 421
      goto while_break;
    }
    {
#line 422
    st = adns__findrr_anychk((adns_query )pai->qu, (int )pai->serv, (byte const   *)pai->dgram,
                             (int )pai->dglen, cbyte_io, & type, & class, & ttl, & rdlen,
                             & rdstart, (byte const   *)pai->dgram, (int )pai->dglen,
                             dmstart, & ownermatched);
    }
#line 426
    if (st) {
#line 426
      return (st);
    }
#line 427
    if (! ownermatched) {
#line 427
      goto _L;
    } else
#line 427
    if (class != 1) {
#line 427
      goto _L;
    } else
#line 427
    if (type != 1) {
      _L: /* CIL Label */ 
#line 428
      if (naddrs > 0) {
#line 428
        goto while_break;
      } else {
#line 428
        goto __Cont;
      }
    }
#line 430
    if (naddrs == -1) {
#line 431
      naddrs = 0;
    }
    {
#line 433
    tmp = adns__vbuf_ensure(& (pai->qu)->vb, (int )((unsigned long )(naddrs + 1) * sizeof(adns_rr_addr )));
    }
#line 433
    if (! tmp) {
#line 434
      return ((adns_status )1);
    }
    {
#line 435
    adns__update_expires((adns_query )pai->qu, ttl, (struct timeval )pai->now);
#line 436
    st = pa_addr___7(pai, rdstart, rdstart + rdlen, (void *)((pai->qu)->vb.buf + (unsigned long )naddrs * sizeof(adns_rr_addr )));
    }
#line 438
    if (st) {
#line 438
      return (st);
    }
#line 439
    naddrs ++;
    __Cont: /* CIL Label */ 
#line 421
    rri ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 441
  if (naddrs >= 0) {
    {
#line 442
    tmp___0 = adns__alloc_interim((adns_query )pai->qu, (unsigned long )naddrs * sizeof(adns_rr_addr ));
#line 442
    ha->addrs = (adns_rr_addr *)tmp___0;
    }
#line 443
    if (! ha->addrs) {
#line 443
      return ((adns_status )1);
    }
    {
#line 444
    memcpy((void */* __restrict  */)ha->addrs, (void const   */* __restrict  */)(pai->qu)->vb.buf,
           (unsigned long )naddrs * sizeof(adns_rr_addr ));
#line 445
    ha->naddrs = naddrs;
#line 446
    ha->astatus = (adns_status )0;
#line 448
    adns__isort((void *)ha->addrs, naddrs, (int )sizeof(adns_rr_addr ), (void *)(pai->qu)->vb.buf,
                & div_addr___7, (void *)pai->ads);
    }
  }
#line 451
  return ((adns_status )0);
}
}
#line 454 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void icb_hostaddr___7(adns_query parent , adns_query child ) 
{ 
  adns_answer *cans ;
  adns_rr_hostaddr *rrp ;
  adns_state ads___7 ;
  adns_status st ;

  {
#line 455
  cans = child->answer;
#line 456
  rrp = child->ctx.info.hostaddr;
#line 457
  ads___7 = parent->ads;
#line 460
  st = cans->status;
#line 461
  rrp->astatus = st;
#line 462
  if ((unsigned int )st > 0U) {
#line 462
    if ((unsigned int )st <= 99U) {
#line 462
      rrp->naddrs = -1;
    } else {
#line 462
      rrp->naddrs = cans->nrrs;
    }
  } else {
#line 462
    rrp->naddrs = cans->nrrs;
  }
  {
#line 463
  rrp->addrs = cans->rrs.addr;
#line 464
  adns__transfer_interim(child, parent, (void *)rrp->addrs, (unsigned long )rrp->naddrs * sizeof(adns_rr_addr ));
  }
#line 467
  if (parent->children.head) {
    {
#line 468
    while (1) {
      while_continue: /* CIL Label */ ;
#line 468
      parent->next = (adns_query )0;
#line 468
      parent->back = ads___7->childw.tail;
#line 468
      if (ads___7->childw.tail) {
#line 468
        (ads___7->childw.tail)->next = parent;
      } else {
#line 468
        ads___7->childw.head = parent;
      }
#line 468
      ads___7->childw.tail = parent;
#line 468
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 470
    adns__query_done(parent);
    }
  }
#line 472
  return;
}
}
#line 474 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pap_hostaddr___7(parseinfo const   *pai , int *cbyte_io , int max ,
                                    adns_rr_hostaddr *rrp ) 
{ 
  adns_status st ;
  int dmstart ;
  int cbyte___3 ;
  qcontext ctx ;
  int id ;
  adns_query nqu ;
  adns_queryflags nflags ;
  int tmp ;
  typeinfo const   *tmp___0 ;

  {
#line 483
  cbyte___3 = *cbyte_io;
#line 483
  dmstart = cbyte___3;
#line 484
  if ((pai->qu)->flags & 64) {
#line 484
    tmp = 1;
  } else {
#line 484
    tmp = 0;
  }
  {
#line 484
  st = pap_domain___7(pai, & cbyte___3, max, & rrp->host, (parsedomain_flags )tmp);
  }
#line 486
  if (st) {
#line 486
    return (st);
  }
  {
#line 487
  *cbyte_io = cbyte___3;
#line 489
  rrp->astatus = (adns_status )0;
#line 490
  rrp->naddrs = -1;
#line 491
  rrp->addrs = (adns_rr_addr *)0;
#line 493
  cbyte___3 = (int )pai->nsstart;
#line 495
  st = pap_findaddrs___7(pai, rrp, & cbyte___3, (int )pai->nscount, dmstart);
  }
#line 496
  if (st) {
#line 496
    return (st);
  }
#line 497
  if (rrp->naddrs != -1) {
#line 497
    return ((adns_status )0);
  }
  {
#line 499
  st = pap_findaddrs___7(pai, rrp, & cbyte___3, (int )pai->arcount, dmstart);
  }
#line 500
  if (st) {
#line 500
    return (st);
  }
#line 501
  if (rrp->naddrs != -1) {
#line 501
    return ((adns_status )0);
  }
  {
#line 503
  st = adns__mkquery_frdgram((adns_state )pai->ads, & (pai->qu)->vb, & id, (byte const   *)pai->dgram,
                             (int )pai->dglen, dmstart, (adns_rrtype )65537, (adns_queryflags )16);
  }
#line 506
  if (st) {
#line 506
    return (st);
  }
#line 508
  ctx.ext = (void *)0;
#line 509
  ctx.callback = & icb_hostaddr___7;
#line 510
  ctx.info.hostaddr = rrp;
#line 512
  nflags = (adns_queryflags )16;
#line 513
  if (! ((pai->qu)->flags & 256)) {
#line 513
    nflags = (adns_queryflags )((unsigned int )nflags | 512U);
  }
  {
#line 515
  tmp___0 = adns__findtype((adns_rrtype )65537);
#line 515
  st = adns__internal_submit((adns_state )pai->ads, & nqu, tmp___0, & (pai->qu)->vb,
                             id, nflags, (struct timeval )pai->now, (qcontext const   *)(& ctx));
  }
#line 517
  if (st) {
#line 517
    return (st);
  }
#line 519
  nqu->parent = (adns_query )pai->qu;
  {
#line 520
  while (1) {
    while_continue: /* CIL Label */ ;
#line 520
    nqu->siblings.next = (adns_query )0;
#line 520
    nqu->siblings.back = (pai->qu)->children.tail;
#line 520
    if ((pai->qu)->children.tail) {
#line 520
      ((pai->qu)->children.tail)->siblings.next = nqu;
    } else {
#line 520
      (pai->qu)->children.head = nqu;
    }
#line 520
    (pai->qu)->children.tail = nqu;
#line 520
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 522
  return ((adns_status )0);
}
}
#line 525 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_hostaddr___7(parseinfo const   *pai , int cbyte___3 , int max ,
                                   void *datap ) 
{ 
  adns_rr_hostaddr *rrp ;
  adns_status st ;

  {
  {
#line 527
  rrp = (adns_rr_hostaddr *)datap;
#line 530
  st = pap_hostaddr___7(pai, & cbyte___3, max, rrp);
  }
#line 531
  if (st) {
#line 531
    return (st);
  }
#line 532
  if (cbyte___3 != max) {
#line 532
    return ((adns_status )104);
  }
#line 534
  return ((adns_status )0);
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int dip_hostaddr___7(adns_state ads___7 , adns_rr_hostaddr const   *ap , adns_rr_hostaddr const   *bp ) 
{ 
  int tmp ;

  {
#line 539
  if ((unsigned int const   )ap->astatus != (unsigned int const   )bp->astatus) {
#line 539
    return ((int )ap->astatus);
  }
#line 540
  if (ap->astatus) {
#line 540
    return (0);
  }
#line 542
  if (! ((int )(ap->addrs + 0)->addr.sa.sa_family == 2)) {
    {
#line 542
    __assert_fail("ap->addrs[0].addr.sa.sa_family == 2", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                  542U, "dip_hostaddr");
    }
  }
#line 543
  if (! ((int )(bp->addrs + 0)->addr.sa.sa_family == 2)) {
    {
#line 543
    __assert_fail("bp->addrs[0].addr.sa.sa_family == 2", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                  543U, "dip_hostaddr");
    }
  }
  {
#line 544
  tmp = dip_inaddr___7(ads___7, (ap->addrs + 0)->addr.inet.sin_addr, (bp->addrs + 0)->addr.inet.sin_addr);
  }
#line 544
  return (tmp);
}
}
#line 549 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int di_hostaddr___7(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_hostaddr const   *ap ;
  adns_rr_hostaddr const   *bp ;
  int tmp ;

  {
  {
#line 551
  ap = (adns_rr_hostaddr const   *)datap_a;
#line 551
  bp = (adns_rr_hostaddr const   *)datap_b;
#line 553
  tmp = dip_hostaddr___7(ads___7, ap, bp);
  }
#line 553
  return (tmp);
}
}
#line 556 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mfp_hostaddr___7(adns_query qu , adns_rr_hostaddr *rrp ) 
{ 
  void *tablev ;

  {
  {
#line 559
  adns__makefinal_str(qu, & rrp->host);
#line 560
  tablev = (void *)rrp->addrs;
#line 561
  adns__makefinal_block(qu, & tablev, (unsigned long )rrp->naddrs * sizeof(*(rrp->addrs)));
#line 562
  rrp->addrs = (adns_rr_addr *)tablev;
  }
#line 563
  return;
}
}
#line 565 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_hostaddr___7(adns_query qu , void *datap ) 
{ 
  adns_rr_hostaddr *rrp ;

  {
  {
#line 566
  rrp = (adns_rr_hostaddr *)datap;
#line 568
  mfp_hostaddr___7(qu, rrp);
  }
#line 569
  return;
}
}
#line 571 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status csp_hostaddr___7(vbuf *vb___0 , adns_rr_hostaddr const   *rrp ) 
{ 
  char const   *errstr ;
  adns_status st ;
  char buf___17[20] ;
  int i ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 577
  st = csp_domain___7(vb___0, (char const   *)rrp->host);
  }
#line 577
  if (st) {
#line 577
    return (st);
  }
  {
#line 579
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 579
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 579
    if (! tmp) {
#line 579
      return ((adns_status )1);
    }
#line 579
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 580
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 580
    tmp___0 = adns_errtypeabbrev((adns_status )rrp->astatus);
#line 580
    tmp___1 = adns__vbuf_appendstr(vb___0, tmp___0);
    }
#line 580
    if (! tmp___1) {
#line 580
      return ((adns_status )1);
    }
#line 580
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 582
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %d ",
          (unsigned int const   )rrp->astatus);
  }
  {
#line 583
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 583
    tmp___2 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 583
    if (! tmp___2) {
#line 583
      return ((adns_status )1);
    }
#line 583
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 585
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 585
    tmp___3 = adns_errabbrev((adns_status )rrp->astatus);
#line 585
    tmp___4 = adns__vbuf_appendstr(vb___0, tmp___3);
    }
#line 585
    if (! tmp___4) {
#line 585
      return ((adns_status )1);
    }
#line 585
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 586
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 586
    tmp___5 = adns__vbuf_appendstr(vb___0, " ");
    }
#line 586
    if (! tmp___5) {
#line 586
      return ((adns_status )1);
    }
#line 586
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 588
  errstr = adns_strerror((adns_status )rrp->astatus);
#line 589
  tmp___6 = strlen(errstr);
#line 589
  st = csp_qstring___7(vb___0, errstr, (int )tmp___6);
  }
#line 589
  if (st) {
#line 589
    return (st);
  }
#line 591
  if (rrp->naddrs >= 0) {
    {
#line 592
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 592
      tmp___7 = adns__vbuf_appendstr(vb___0, " (");
      }
#line 592
      if (! tmp___7) {
#line 592
        return ((adns_status )1);
      }
#line 592
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 593
    i = 0;
    {
#line 593
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 593
      if (! (i < (int )rrp->naddrs)) {
#line 593
        goto while_break___5;
      }
      {
#line 594
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 594
        tmp___8 = adns__vbuf_appendstr(vb___0, " ");
        }
#line 594
        if (! tmp___8) {
#line 594
          return ((adns_status )1);
        }
#line 594
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 595
      st = csp_addr___7(vb___0, (adns_rr_addr const   *)(rrp->addrs + i));
#line 593
      i ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 597
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 597
      tmp___9 = adns__vbuf_appendstr(vb___0, " )");
      }
#line 597
      if (! tmp___9) {
#line 597
        return ((adns_status )1);
      }
#line 597
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
  } else {
    {
#line 599
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 599
      tmp___10 = adns__vbuf_appendstr(vb___0, " ?");
      }
#line 599
      if (! tmp___10) {
#line 599
        return ((adns_status )1);
      }
#line 599
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
#line 601
  return ((adns_status )0);
}
}
#line 604 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_hostaddr___7(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_hostaddr const   *rrp ;
  adns_status tmp ;

  {
  {
#line 605
  rrp = (adns_rr_hostaddr const   *)datap;
#line 607
  tmp = csp_hostaddr___7(vb___0, rrp);
  }
#line 607
  return (tmp);
}
}
#line 614 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_mx_raw___7(parseinfo const   *pai , int cbyte___3 , int max ,
                                 void *datap ) 
{ 
  byte const   *dgram ;
  adns_rr_intstr *rrp ;
  adns_status st ;
  int pref ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 616
  dgram = (byte const   *)pai->dgram;
#line 617
  rrp = (adns_rr_intstr *)datap;
#line 621
  if (cbyte___3 + 2 > max) {
#line 621
    return ((adns_status )104);
  }
#line 622
  pref = 0;
#line 622
  tmp = cbyte___3;
#line 622
  cbyte___3 ++;
#line 622
  pref |= (int )(((int const   )*(dgram + tmp) & 255) << 8);
#line 622
  tmp___0 = cbyte___3;
#line 622
  cbyte___3 ++;
#line 622
  pref |= (int )((int const   )*(dgram + tmp___0) & 255);
#line 623
  rrp->i = pref;
#line 624
  if ((pai->qu)->flags & 64) {
#line 624
    tmp___1 = 1;
  } else {
#line 624
    tmp___1 = 0;
  }
  {
#line 624
  st = pap_domain___7(pai, & cbyte___3, max, & rrp->str, (parsedomain_flags )tmp___1);
  }
#line 626
  if (st) {
#line 626
    return (st);
  }
#line 628
  if (cbyte___3 != max) {
#line 628
    return ((adns_status )104);
  }
#line 629
  return ((adns_status )0);
}
}
#line 632 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int di_mx_raw___7(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_intstr const   *ap ;
  adns_rr_intstr const   *bp ;

  {
#line 633
  ap = (adns_rr_intstr const   *)datap_a;
#line 633
  bp = (adns_rr_intstr const   *)datap_b;
#line 635
  if (ap->i < bp->i) {
#line 635
    return (0);
  }
#line 636
  if (ap->i > bp->i) {
#line 636
    return (1);
  }
#line 637
  return (0);
}
}
#line 644 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_mx___7(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  byte const   *dgram ;
  adns_rr_inthostaddr *rrp ;
  adns_status st ;
  int pref ;
  int tmp ;
  int tmp___0 ;

  {
#line 646
  dgram = (byte const   *)pai->dgram;
#line 647
  rrp = (adns_rr_inthostaddr *)datap;
#line 651
  if (cbyte___3 + 2 > max) {
#line 651
    return ((adns_status )104);
  }
  {
#line 652
  pref = 0;
#line 652
  tmp = cbyte___3;
#line 652
  cbyte___3 ++;
#line 652
  pref |= (int )(((int const   )*(dgram + tmp) & 255) << 8);
#line 652
  tmp___0 = cbyte___3;
#line 652
  cbyte___3 ++;
#line 652
  pref |= (int )((int const   )*(dgram + tmp___0) & 255);
#line 653
  rrp->i = pref;
#line 654
  st = pap_hostaddr___7(pai, & cbyte___3, max, & rrp->ha);
  }
#line 655
  if (st) {
#line 655
    return (st);
  }
#line 657
  if (cbyte___3 != max) {
#line 657
    return ((adns_status )104);
  }
#line 658
  return ((adns_status )0);
}
}
#line 661 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int di_mx___7(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_inthostaddr const   *ap ;
  adns_rr_inthostaddr const   *bp ;
  int tmp ;

  {
#line 662
  ap = (adns_rr_inthostaddr const   *)datap_a;
#line 662
  bp = (adns_rr_inthostaddr const   *)datap_b;
#line 664
  if (ap->i < bp->i) {
#line 664
    return (0);
  }
#line 665
  if (ap->i > bp->i) {
#line 665
    return (1);
  }
  {
#line 666
  tmp = dip_hostaddr___7(ads___7, & ap->ha, & bp->ha);
  }
#line 666
  return (tmp);
}
}
#line 673 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_inthostaddr___7(adns_query qu , void *datap ) 
{ 
  adns_rr_inthostaddr *rrp ;

  {
  {
#line 674
  rrp = (adns_rr_inthostaddr *)datap;
#line 676
  mfp_hostaddr___7(qu, & rrp->ha);
  }
#line 677
  return;
}
}
#line 679 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_inthostaddr___7(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_inthostaddr const   *rrp ;
  char buf___17[10] ;
  int tmp ;
  adns_status tmp___0 ;

  {
  {
#line 680
  rrp = (adns_rr_inthostaddr const   *)datap;
#line 683
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"%u ",
          rrp->i);
  }
  {
#line 684
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 684
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 684
    if (! tmp) {
#line 684
      return ((adns_status )1);
    }
#line 684
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 686
  tmp___0 = csp_hostaddr___7(vb___0, & rrp->ha);
  }
#line 686
  return (tmp___0);
}
}
#line 693 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_inthost___7(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_intstr const   *rrp ;
  char buf___17[10] ;
  int tmp ;
  adns_status tmp___0 ;

  {
  {
#line 694
  rrp = (adns_rr_intstr const   *)datap;
#line 697
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"%u ",
          rrp->i);
  }
  {
#line 698
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 698
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 698
    if (! tmp) {
#line 698
      return ((adns_status )1);
    }
#line 698
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 699
  tmp___0 = csp_domain___7(vb___0, (char const   *)rrp->str);
  }
#line 699
  return (tmp___0);
}
}
#line 706 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void icb_ptr___7(adns_query parent , adns_query child ) 
{ 
  adns_answer *cans ;
  adns_rr_addr const   *queried ;
  adns_rr_addr const   *found ;
  adns_state ads___7 ;
  int i ;
  int tmp ;

  {
#line 707
  cans = child->answer;
#line 709
  ads___7 = parent->ads;
#line 712
  if ((unsigned int )cans->status == 300U) {
    {
#line 713
    adns__query_fail(parent, (adns_status )100);
    }
#line 714
    return;
  } else
#line 712
  if ((unsigned int )cans->status == 301U) {
    {
#line 713
    adns__query_fail(parent, (adns_status )100);
    }
#line 714
    return;
  } else
#line 715
  if (cans->status) {
    {
#line 716
    adns__query_fail(parent, cans->status);
    }
#line 717
    return;
  }
#line 720
  queried = (adns_rr_addr const   *)(& parent->ctx.info.ptr_parent_addr);
#line 721
  i = 0;
#line 721
  found = (adns_rr_addr const   *)cans->rrs.addr;
  {
#line 721
  while (1) {
    while_continue: /* CIL Label */ ;
#line 721
    if (! (i < cans->nrrs)) {
#line 721
      goto while_break;
    }
#line 722
    if (queried->len == found->len) {
      {
#line 722
      tmp = memcmp((void const   *)(& queried->addr), (void const   *)(& found->addr),
                   (size_t )queried->len);
      }
#line 722
      if (! tmp) {
#line 724
        if (! parent->children.head) {
          {
#line 725
          adns__query_done(parent);
          }
#line 726
          return;
        } else {
          {
#line 728
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 728
            parent->next = (adns_query )0;
#line 728
            parent->back = ads___7->childw.tail;
#line 728
            if (ads___7->childw.tail) {
#line 728
              (ads___7->childw.tail)->next = parent;
            } else {
#line 728
              ads___7->childw.head = parent;
            }
#line 728
            ads___7->childw.tail = parent;
#line 728
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 729
          return;
        }
      }
    }
#line 721
    i ++;
#line 721
    found ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 734
  adns__query_fail(parent, (adns_status )100);
  }
#line 735
  return;
}
}
#line 739
static adns_status pa_ptr___7(parseinfo const   *pai , int dmstart , int max , void *datap ) ;
#line 739 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static char const   * const  expectdomain___7[2]  = {      (char const   */* const  */)"in-addr",      (char const   */* const  */)"arpa"};
#line 737 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_ptr___7(parseinfo const   *pai , int dmstart , int max , void *datap ) 
{ 
  char **rrp ;
  adns_status st ;
  adns_rr_addr *ap ;
  findlabel_state fls ;
  char *ep ;
  byte ipv[4] ;
  char labbuf[4] ;
  int cbyte___3 ;
  int i ;
  int lablen ;
  int labstart ;
  int l ;
  int id ;
  adns_query nqu ;
  qcontext ctx ;
  int tmp ;
  unsigned long tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  typeinfo const   *tmp___3 ;

  {
#line 741
  rrp = (char **)datap;
#line 752
  cbyte___3 = dmstart;
#line 753
  if ((pai->qu)->flags & 64) {
#line 753
    tmp = 1;
  } else {
#line 753
    tmp = 0;
  }
  {
#line 753
  st = pap_domain___7(pai, & cbyte___3, max, rrp, (parsedomain_flags )tmp);
  }
#line 755
  if (st) {
#line 755
    return (st);
  }
#line 756
  if (cbyte___3 != max) {
#line 756
    return ((adns_status )104);
  }
#line 758
  ap = & (pai->qu)->ctx.info.ptr_parent_addr;
#line 759
  if (! ap->len) {
    {
#line 760
    adns__findlabel_start(& fls, (adns_state )pai->ads, -1, (adns_query )pai->qu,
                          (byte const   *)(pai->qu)->query_dgram, (pai->qu)->query_dglen,
                          (pai->qu)->query_dglen, 12, (int *)0);
#line 763
    i = 0;
    }
    {
#line 763
    while (1) {
      while_continue: /* CIL Label */ ;
#line 763
      if (! (i < 4)) {
#line 763
        goto while_break;
      }
      {
#line 764
      st = adns__findlabel_next(& fls, & lablen, & labstart);
      }
#line 764
      if (! (! st)) {
        {
#line 764
        __assert_fail("!st", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                      764U, "pa_ptr");
        }
      }
#line 765
      if (lablen <= 0) {
#line 765
        return ((adns_status )200);
      } else
#line 765
      if (lablen > 3) {
#line 765
        return ((adns_status )200);
      }
      {
#line 766
      memcpy((void */* __restrict  */)(labbuf), (void const   */* __restrict  */)((pai->qu)->query_dgram + labstart),
             (size_t )lablen);
#line 767
      labbuf[lablen] = (char)0;
#line 768
      tmp___0 = strtoul((char const   */* __restrict  */)(labbuf), (char **/* __restrict  */)(& ep),
                        10);
#line 768
      ipv[3 - i] = (byte )tmp___0;
      }
#line 769
      if (*ep) {
#line 769
        return ((adns_status )200);
      }
#line 770
      if (lablen > 1) {
#line 770
        if ((int )*((pai->qu)->query_dgram + labstart) == 48) {
#line 771
          return ((adns_status )200);
        }
      }
#line 763
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 773
    i = 0;
    {
#line 773
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 773
      if (! ((unsigned long )i < sizeof(expectdomain___7) / sizeof(expectdomain___7[0]))) {
#line 773
        goto while_break___0;
      }
      {
#line 774
      st = adns__findlabel_next(& fls, & lablen, & labstart);
      }
#line 774
      if (! (! st)) {
        {
#line 774
        __assert_fail("!st", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                      774U, "pa_ptr");
        }
      }
      {
#line 775
      tmp___1 = strlen((char const   *)expectdomain___7[i]);
#line 775
      l = (int )tmp___1;
      }
#line 776
      if (lablen != l) {
#line 778
        return ((adns_status )200);
      } else {
        {
#line 776
        tmp___2 = memcmp((void const   *)((pai->qu)->query_dgram + labstart), (void const   *)expectdomain___7[i],
                         (size_t )l);
        }
#line 776
        if (tmp___2) {
#line 778
          return ((adns_status )200);
        }
      }
#line 773
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 780
    st = adns__findlabel_next(& fls, & lablen, (int *)0);
    }
#line 780
    if (! (! st)) {
      {
#line 780
      __assert_fail("!st", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                    780U, "pa_ptr");
      }
    }
#line 781
    if (lablen) {
#line 781
      return ((adns_status )200);
    }
    {
#line 783
    ap->len = (int )sizeof(struct sockaddr_in );
#line 784
    memset((void *)(& ap->addr), 0, sizeof(ap->addr.inet));
#line 785
    ap->addr.inet.sin_family = (sa_family_t )2;
#line 786
    ap->addr.inet.sin_addr.s_addr = htonl((uint32_t )(((((int )ipv[0] << 24) | ((int )ipv[1] << 16)) | ((int )ipv[2] << 8)) | (int )ipv[3]));
    }
  }
  {
#line 790
  st = adns__mkquery_frdgram((adns_state )pai->ads, & (pai->qu)->vb, & id, (byte const   *)pai->dgram,
                             (int )pai->dglen, dmstart, (adns_rrtype )65537, (adns_queryflags )16);
  }
#line 793
  if (st) {
#line 793
    return (st);
  }
  {
#line 795
  ctx.ext = (void *)0;
#line 796
  ctx.callback = & icb_ptr___7;
#line 797
  memset((void *)(& ctx.info), 0, sizeof(ctx.info));
#line 798
  tmp___3 = adns__findtype((adns_rrtype )65537);
#line 798
  st = adns__internal_submit((adns_state )pai->ads, & nqu, tmp___3, & (pai->qu)->vb,
                             id, (adns_queryflags )16, (struct timeval )pai->now,
                             (qcontext const   *)(& ctx));
  }
#line 801
  if (st) {
#line 801
    return (st);
  }
#line 803
  nqu->parent = (adns_query )pai->qu;
  {
#line 804
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 804
    nqu->siblings.next = (adns_query )0;
#line 804
    nqu->siblings.back = (pai->qu)->children.tail;
#line 804
    if ((pai->qu)->children.tail) {
#line 804
      ((pai->qu)->children.tail)->siblings.next = nqu;
    } else {
#line 804
      (pai->qu)->children.head = nqu;
    }
#line 804
    (pai->qu)->children.tail = nqu;
#line 804
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 805
  return ((adns_status )0);
}
}
#line 812 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_strpair___7(adns_query qu , void *datap ) 
{ 
  adns_rr_strpair *rrp ;

  {
  {
#line 813
  rrp = (adns_rr_strpair *)datap;
#line 815
  adns__makefinal_str(qu, & rrp->array[0]);
#line 816
  adns__makefinal_str(qu, & rrp->array[1]);
  }
#line 817
  return;
}
}
#line 823 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_intstrpair___7(adns_query qu , void *datap ) 
{ 
  adns_rr_intstrpair *rrp ;

  {
  {
#line 824
  rrp = (adns_rr_intstrpair *)datap;
#line 826
  adns__makefinal_str(qu, & rrp->array[0].str);
#line 827
  adns__makefinal_str(qu, & rrp->array[1].str);
  }
#line 828
  return;
}
}
#line 834 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_hinfo___7(parseinfo const   *pai , int cbyte___3 , int max ,
                                void *datap ) 
{ 
  adns_rr_intstrpair *rrp ;
  adns_status st ;
  int i ;

  {
#line 836
  rrp = (adns_rr_intstrpair *)datap;
#line 840
  i = 0;
  {
#line 840
  while (1) {
    while_continue: /* CIL Label */ ;
#line 840
    if (! (i < 2)) {
#line 840
      goto while_break;
    }
    {
#line 841
    st = pap_qstring___7(pai, & cbyte___3, max, & rrp->array[i].i, & rrp->array[i].str);
    }
#line 842
    if (st) {
#line 842
      return (st);
    }
#line 840
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 845
  if (cbyte___3 != max) {
#line 845
    return ((adns_status )104);
  }
#line 847
  return ((adns_status )0);
}
}
#line 854 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pap_mailbox822___7(parseinfo const   *pai , int *cbyte_io , int max ,
                                      char **mb_r ) 
{ 
  int lablen ;
  int labstart ;
  int i ;
  int needquote ;
  int c ;
  int r ;
  int neednorm ;
  unsigned char const   *p ;
  char *str ;
  findlabel_state fls ;
  adns_status st ;
  vbuf *vb___0 ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 863
  vb___0 = & (pai->qu)->vb;
#line 864
  vb___0->used = 0;
#line 865
  adns__findlabel_start(& fls, (adns_state )pai->ads, -1, (adns_query )pai->qu, (byte const   *)pai->dgram,
                        (int )pai->dglen, max, *cbyte_io, cbyte_io);
#line 869
  st = adns__findlabel_next(& fls, & lablen, & labstart);
  }
#line 870
  if (! lablen) {
    {
#line 871
    adns__vbuf_appendstr(vb___0, ".");
    }
#line 872
    goto x_ok;
  }
#line 875
  neednorm = 1;
#line 876
  i = 0;
#line 876
  needquote = 0;
#line 876
  p = (unsigned char const   *)(pai->dgram + labstart);
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (! (i < lablen)) {
#line 876
      goto while_break;
    }
#line 877
    tmp = p;
#line 877
    p ++;
#line 877
    c = (int )*tmp;
#line 878
    if ((c & -129) < 32) {
#line 878
      return ((adns_status )104);
    } else
#line 878
    if ((c & -129) == 127) {
#line 878
      return ((adns_status )104);
    }
#line 879
    if (c == 46) {
#line 879
      if (! neednorm) {
#line 879
        neednorm = 1;
      } else {
#line 879
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 880
    if (c == 32) {
#line 880
      needquote ++;
    } else
#line 880
    if (c >= 127) {
#line 880
      needquote ++;
    } else {
      {
#line 880
      tmp___0 = ctype_822special(c);
      }
#line 880
      if (tmp___0) {
#line 880
        needquote ++;
      } else {
#line 881
        neednorm = 0;
      }
    }
#line 876
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 884
  if (needquote) {
#line 884
    goto _L___0;
  } else
#line 884
  if (neednorm) {
    _L___0: /* CIL Label */ 
    {
#line 885
    r = adns__vbuf_ensure(vb___0, (lablen + needquote) + 4);
    }
#line 885
    if (! r) {
#line 885
      return ((adns_status )1);
    }
    {
#line 886
    adns__vbuf_appendq(vb___0, (byte const   *)"\"", 1);
#line 887
    i = 0;
#line 887
    needquote = 0;
#line 887
    p = (unsigned char const   *)(pai->dgram + labstart);
    }
    {
#line 887
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 887
      if (! (i < lablen)) {
#line 887
        goto while_break___0;
      }
#line 888
      c = (int )*p;
#line 889
      if (c == 34) {
        {
#line 889
        adns__vbuf_appendq(vb___0, (byte const   *)"\\", 1);
        }
      } else
#line 889
      if (c == 92) {
        {
#line 889
        adns__vbuf_appendq(vb___0, (byte const   *)"\\", 1);
        }
      }
      {
#line 890
      adns__vbuf_appendq(vb___0, p, 1);
#line 887
      i ++;
#line 887
      p ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 892
    adns__vbuf_appendq(vb___0, (byte const   *)"\"", 1);
    }
  } else {
    {
#line 894
    r = adns__vbuf_append(vb___0, (byte const   *)(pai->dgram + labstart), lablen);
    }
#line 894
    if (! r) {
#line 894
      return ((adns_status )1);
    }
  }
  {
#line 897
  r = adns__vbuf_appendstr(vb___0, "@");
  }
#line 897
  if (! r) {
#line 897
    return ((adns_status )1);
  }
  {
#line 899
  st = adns__parse_domain_more(& fls, (adns_state )pai->ads, (adns_query )pai->qu,
                               vb___0, (parsedomain_flags )0, (byte const   *)pai->dgram);
  }
#line 900
  if (st) {
#line 900
    return (st);
  }
  x_ok: 
  {
#line 903
  tmp___1 = adns__alloc_interim((adns_query )pai->qu, (size_t )(vb___0->used + 1));
#line 903
  str = (char *)tmp___1;
  }
#line 903
  if (! str) {
#line 903
    return ((adns_status )1);
  }
  {
#line 904
  memcpy((void */* __restrict  */)str, (void const   */* __restrict  */)vb___0->buf,
         (size_t )vb___0->used);
#line 905
  *(str + vb___0->used) = (char)0;
#line 906
  *mb_r = str;
  }
#line 907
  return ((adns_status )0);
}
}
#line 910 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pap_mailbox___7(parseinfo const   *pai , int *cbyte_io , int max ,
                                   char **mb_r ) 
{ 
  adns_status tmp ;
  adns_status tmp___0 ;

  {
#line 912
  if ((unsigned int const   )((pai->qu)->typei)->typekey & 131072U) {
    {
#line 913
    tmp = pap_mailbox822___7(pai, cbyte_io, max, mb_r);
    }
#line 913
    return (tmp);
  } else {
    {
#line 915
    tmp___0 = pap_domain___7(pai, cbyte_io, max, mb_r, (parsedomain_flags )1);
    }
#line 915
    return (tmp___0);
  }
}
}
#line 919 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status csp_mailbox___7(vbuf *vb___0 , char const   *mailbox ) 
{ 
  adns_status tmp ;

  {
  {
#line 920
  tmp = csp_domain___7(vb___0, mailbox);
  }
#line 920
  return (tmp);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_rp___7(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  adns_rr_strpair *rrp ;
  adns_status st ;

  {
  {
#line 929
  rrp = (adns_rr_strpair *)datap;
#line 932
  st = pap_mailbox___7(pai, & cbyte___3, max, & rrp->array[0]);
  }
#line 933
  if (st) {
#line 933
    return (st);
  }
  {
#line 935
  st = pap_domain___7(pai, & cbyte___3, max, & rrp->array[1], (parsedomain_flags )1);
  }
#line 936
  if (st) {
#line 936
    return (st);
  }
#line 938
  if (cbyte___3 != max) {
#line 938
    return ((adns_status )104);
  }
#line 939
  return ((adns_status )0);
}
}
#line 942 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_rp___7(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_strpair const   *rrp ;
  adns_status st ;
  int tmp ;

  {
  {
#line 943
  rrp = (adns_rr_strpair const   *)datap;
#line 946
  st = csp_mailbox___7(vb___0, (char const   *)rrp->array[0]);
  }
#line 946
  if (st) {
#line 946
    return (st);
  }
  {
#line 947
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 947
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 947
    if (! tmp) {
#line 947
      return ((adns_status )1);
    }
#line 947
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 948
  st = csp_domain___7(vb___0, (char const   *)rrp->array[1]);
  }
#line 948
  if (st) {
#line 948
    return (st);
  }
#line 950
  return ((adns_status )0);
}
}
#line 957 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_soa___7(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  adns_rr_soa *rrp ;
  byte const   *dgram ;
  adns_status st ;
  int msw ;
  int lsw ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 959
  rrp = (adns_rr_soa *)datap;
#line 960
  dgram = (byte const   *)pai->dgram;
#line 964
  if ((pai->qu)->flags & 64) {
#line 964
    tmp = 1;
  } else {
#line 964
    tmp = 0;
  }
  {
#line 964
  st = pap_domain___7(pai, & cbyte___3, max, & rrp->mname, (parsedomain_flags )tmp);
  }
#line 966
  if (st) {
#line 966
    return (st);
  }
  {
#line 968
  st = pap_mailbox___7(pai, & cbyte___3, max, & rrp->rname);
  }
#line 969
  if (st) {
#line 969
    return (st);
  }
#line 971
  if (cbyte___3 + 20 != max) {
#line 971
    return ((adns_status )104);
  }
#line 973
  i = 0;
  {
#line 973
  while (1) {
    while_continue: /* CIL Label */ ;
#line 973
    if (! (i < 5)) {
#line 973
      goto while_break;
    }
#line 974
    msw = 0;
#line 974
    tmp___0 = cbyte___3;
#line 974
    cbyte___3 ++;
#line 974
    msw |= (int )(((int const   )*(dgram + tmp___0) & 255) << 8);
#line 974
    tmp___1 = cbyte___3;
#line 974
    cbyte___3 ++;
#line 974
    msw |= (int )((int const   )*(dgram + tmp___1) & 255);
#line 975
    lsw = 0;
#line 975
    tmp___2 = cbyte___3;
#line 975
    cbyte___3 ++;
#line 975
    lsw |= (int )(((int const   )*(dgram + tmp___2) & 255) << 8);
#line 975
    tmp___3 = cbyte___3;
#line 975
    cbyte___3 ++;
#line 975
    lsw |= (int )((int const   )*(dgram + tmp___3) & 255);
#line 976
    *(& rrp->serial + i) = (unsigned long )((msw << 16) | lsw);
#line 973
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 979
  return ((adns_status )0);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_soa___7(adns_query qu , void *datap ) 
{ 
  adns_rr_soa *rrp ;

  {
  {
#line 983
  rrp = (adns_rr_soa *)datap;
#line 985
  adns__makefinal_str(qu, & rrp->mname);
#line 986
  adns__makefinal_str(qu, & rrp->rname);
  }
#line 987
  return;
}
}
#line 989 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_soa___7(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_soa const   *rrp ;
  char buf___17[20] ;
  int i ;
  adns_status st ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 990
  rrp = (adns_rr_soa const   *)datap;
#line 995
  st = csp_domain___7(vb___0, (char const   *)rrp->mname);
  }
#line 995
  if (st) {
#line 995
    return (st);
  }
  {
#line 996
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 996
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 996
    if (! tmp) {
#line 996
      return ((adns_status )1);
    }
#line 996
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 997
  st = csp_mailbox___7(vb___0, (char const   *)rrp->rname);
  }
#line 997
  if (st) {
#line 997
    return (st);
  }
#line 999
  i = 0;
  {
#line 999
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 999
    if (! (i < 5)) {
#line 999
      goto while_break___0;
    }
    {
#line 1000
    sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %lu",
            *(& rrp->serial + i));
    }
    {
#line 1001
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1001
      tmp___0 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
      }
#line 1001
      if (! tmp___0) {
#line 1001
        return ((adns_status )1);
      }
#line 1001
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 999
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1004
  return ((adns_status )0);
}
}
#line 1011 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status qdpl_srv___7(adns_state ads___7 , char const   **p_io , char const   *pe ,
                                int labelnum , char *label_r , int *ll_io , adns_queryflags flags ,
                                typeinfo const   *typei ) 
{ 
  int useflags ;
  char const   *p_orig ;
  adns_status st ;
  int ll ;
  void *tmp ;

  {
#line 1020
  if (labelnum < 2) {
#line 1020
    if (! ((unsigned int )flags & 16U)) {
#line 1021
      useflags = 16;
#line 1022
      p_orig = *p_io;
    } else {
#line 1024
      useflags = (int )flags;
#line 1025
      p_orig = (char const   *)0;
    }
  } else {
#line 1024
    useflags = (int )flags;
#line 1025
    p_orig = (char const   *)0;
  }
  {
#line 1027
  st = adns__qdpl_normal(ads___7, p_io, pe, labelnum, (char *)label_r, ll_io, (adns_queryflags )useflags,
                         typei);
  }
#line 1028
  if (st) {
#line 1028
    return (st);
  }
#line 1030
  if (p_orig) {
#line 1031
    ll = *ll_io;
#line 1032
    if (! ll) {
#line 1033
      return ((adns_status )201);
    } else
#line 1032
    if ((int )*(label_r + 0) != 95) {
#line 1033
      return ((adns_status )201);
    }
    {
#line 1034
    tmp = memchr((void const   *)(p_orig + 1), '\\', (size_t )(pe - (p_orig + 1)));
    }
#line 1034
    if (tmp) {
#line 1035
      return ((adns_status )201);
    }
  }
#line 1037
  return ((adns_status )0);
}
}
#line 1040 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pap_srv_begin___7(parseinfo const   *pai , int *cbyte_io , int max ,
                                     adns_rr_srvha *rrp ) 
{ 
  byte const   *dgram ;
  int ti ;
  int cbyte___3 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1043
  dgram = (byte const   *)pai->dgram;
#line 1046
  cbyte___3 = *cbyte_io;
#line 1047
  tmp = *cbyte_io + 6;
#line 1047
  *cbyte_io = tmp;
#line 1047
  if (tmp > max) {
#line 1047
    return ((adns_status )104);
  }
#line 1049
  ti = 0;
#line 1049
  tmp___0 = cbyte___3;
#line 1049
  cbyte___3 ++;
#line 1049
  ti |= (int )(((int const   )*(dgram + tmp___0) & 255) << 8);
#line 1049
  tmp___1 = cbyte___3;
#line 1049
  cbyte___3 ++;
#line 1049
  ti |= (int )((int const   )*(dgram + tmp___1) & 255);
#line 1049
  rrp->priority = ti;
#line 1050
  ti = 0;
#line 1050
  tmp___2 = cbyte___3;
#line 1050
  cbyte___3 ++;
#line 1050
  ti |= (int )(((int const   )*(dgram + tmp___2) & 255) << 8);
#line 1050
  tmp___3 = cbyte___3;
#line 1050
  cbyte___3 ++;
#line 1050
  ti |= (int )((int const   )*(dgram + tmp___3) & 255);
#line 1050
  rrp->weight = ti;
#line 1051
  ti = 0;
#line 1051
  tmp___4 = cbyte___3;
#line 1051
  cbyte___3 ++;
#line 1051
  ti |= (int )(((int const   )*(dgram + tmp___4) & 255) << 8);
#line 1051
  tmp___5 = cbyte___3;
#line 1051
  cbyte___3 ++;
#line 1051
  ti |= (int )((int const   )*(dgram + tmp___5) & 255);
#line 1051
  rrp->port = ti;
#line 1052
  return ((adns_status )0);
}
}
#line 1055 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_srvraw___7(parseinfo const   *pai , int cbyte___3 , int max ,
                                 void *datap ) 
{ 
  adns_rr_srvraw *rrp ;
  adns_status st ;
  int tmp ;

  {
  {
#line 1057
  rrp = (adns_rr_srvraw *)datap;
#line 1060
  st = pap_srv_begin___7(pai, & cbyte___3, max, (adns_rr_srvha *)datap);
  }
#line 1061
  if (st) {
#line 1061
    return (st);
  }
#line 1063
  if ((pai->qu)->flags & 64) {
#line 1063
    tmp = 1;
  } else {
#line 1063
    tmp = 0;
  }
  {
#line 1063
  st = pap_domain___7(pai, & cbyte___3, max, & rrp->host, (parsedomain_flags )tmp);
  }
#line 1065
  if (st) {
#line 1065
    return (st);
  }
#line 1067
  if (cbyte___3 != max) {
#line 1067
    return ((adns_status )104);
  }
#line 1068
  return ((adns_status )0);
}
}
#line 1071 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_srvha___7(parseinfo const   *pai , int cbyte___3 , int max ,
                                void *datap ) 
{ 
  adns_rr_srvha *rrp ;
  adns_status st ;

  {
  {
#line 1073
  rrp = (adns_rr_srvha *)datap;
#line 1076
  st = pap_srv_begin___7(pai, & cbyte___3, max, (adns_rr_srvha *)datap);
  }
#line 1076
  if (st) {
#line 1076
    return (st);
  }
  {
#line 1077
  st = pap_hostaddr___7(pai, & cbyte___3, max, & rrp->ha);
  }
#line 1077
  if (st) {
#line 1077
    return (st);
  }
#line 1078
  if (cbyte___3 != max) {
#line 1078
    return ((adns_status )104);
  }
#line 1079
  return ((adns_status )0);
}
}
#line 1082 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_srvraw___7(adns_query qu , void *datap ) 
{ 
  adns_rr_srvraw *rrp ;

  {
  {
#line 1083
  rrp = (adns_rr_srvraw *)datap;
#line 1084
  adns__makefinal_str(qu, & rrp->host);
  }
#line 1085
  return;
}
}
#line 1087 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_srvha___7(adns_query qu , void *datap ) 
{ 
  adns_rr_srvha *rrp ;

  {
  {
#line 1088
  rrp = (adns_rr_srvha *)datap;
#line 1089
  mfp_hostaddr___7(qu, & rrp->ha);
  }
#line 1090
  return;
}
}
#line 1092 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int di_srv___7(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_srvraw const   *ap ;
  adns_rr_srvraw const   *bp ;

  {
#line 1093
  ap = (adns_rr_srvraw const   *)datap_a;
#line 1093
  bp = (adns_rr_srvraw const   *)datap_b;
#line 1096
  if (ap->priority < bp->priority) {
#line 1096
    return (0);
  }
#line 1097
  if (ap->priority > bp->priority) {
#line 1097
    return (1);
  }
#line 1098
  return (0);
}
}
#line 1101 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status csp_srv_begin___7(vbuf *vb___0 , adns_rr_srvha const   *rrp ) 
{ 
  char buf___17[30] ;
  int tmp ;

  {
  {
#line 1104
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"%u %u %u ",
          rrp->priority, rrp->weight, rrp->port);
  }
  {
#line 1105
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1105
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 1105
    if (! tmp) {
#line 1105
      return ((adns_status )1);
    }
#line 1105
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1106
  return ((adns_status )0);
}
}
#line 1109 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_srvraw___7(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_srvraw const   *rrp ;
  adns_status st ;
  adns_status tmp ;

  {
  {
#line 1110
  rrp = (adns_rr_srvraw const   *)datap;
#line 1113
  st = csp_srv_begin___7(vb___0, (adns_rr_srvha const   *)((void const   *)rrp));
  }
#line 1113
  if (st) {
#line 1113
    return (st);
  }
  {
#line 1114
  tmp = csp_domain___7(vb___0, (char const   *)rrp->host);
  }
#line 1114
  return (tmp);
}
}
#line 1117 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_srvha___7(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_srvha const   *rrp ;
  adns_status st ;
  adns_status tmp ;

  {
  {
#line 1118
  rrp = (adns_rr_srvha const   *)datap;
#line 1121
  st = csp_srv_begin___7(vb___0, (adns_rr_srvha const   *)datap);
  }
#line 1121
  if (st) {
#line 1121
    return (st);
  }
  {
#line 1122
  tmp = csp_hostaddr___7(vb___0, & rrp->ha);
  }
#line 1122
  return (tmp);
}
}
#line 1125 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void postsort_srv___7(adns_state ads___7 , void *array , int nrrs , struct typeinfo  const  *typei ) 
{ 
  char *workbegin ;
  char *workend ;
  char *search ;
  char *arrayend ;
  adns_rr_srvha const   *rr ;
  union __anonunion_rrtmp_89___7 rrtmp ;
  int cpriority ;
  int totalweight ;
  int runtotal ;
  long randval ;

  {
#line 1138
  workbegin = (char *)array;
#line 1138
  arrayend = workbegin + typei->rrsz * (int const   )nrrs;
  {
#line 1138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1138
    if (! ((unsigned long )workbegin < (unsigned long )arrayend)) {
#line 1138
      goto while_break;
    }
#line 1141
    rr = (adns_rr_srvha const   *)((void *)workbegin);
#line 1141
    cpriority = (int )rr->priority;
#line 1143
    workend = workbegin;
#line 1143
    totalweight = 0;
    {
#line 1143
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1143
      if ((unsigned long )workend < (unsigned long )arrayend) {
#line 1143
        rr = (adns_rr_srvha const   *)((void *)workend);
#line 1143
        if (! (rr->priority == (int const   )cpriority)) {
#line 1143
          goto while_break___0;
        }
      } else {
#line 1143
        goto while_break___0;
      }
#line 1146
      totalweight += (int )rr->weight;
#line 1143
      workend += typei->rrsz;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1155
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1155
      if (! ((unsigned long )(workbegin + typei->rrsz) < (unsigned long )workend)) {
#line 1155
        goto while_break___1;
      }
      {
#line 1159
      randval = nrand48((unsigned short *)(ads___7->rand48xsubi));
#line 1160
      randval %= (long )(totalweight + 1);
#line 1167
      search = workbegin;
#line 1167
      runtotal = 0;
      }
      {
#line 1167
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1167
        rr = (adns_rr_srvha const   *)((void *)search);
#line 1167
        runtotal += (int )rr->weight;
#line 1167
        if (! ((long )runtotal < randval)) {
#line 1167
          goto while_break___2;
        }
#line 1167
        search += typei->rrsz;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1170
      if (! ((unsigned long )search < (unsigned long )arrayend)) {
        {
#line 1170
        __assert_fail("search < arrayend", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                      1170U, "postsort_srv");
        }
      }
#line 1171
      totalweight -= (int )rr->weight;
#line 1172
      if ((unsigned long )search != (unsigned long )workbegin) {
        {
#line 1173
        memcpy((void */* __restrict  */)(& rrtmp), (void const   */* __restrict  */)workbegin,
               (size_t )typei->rrsz);
#line 1174
        memcpy((void */* __restrict  */)workbegin, (void const   */* __restrict  */)search,
               (size_t )typei->rrsz);
#line 1175
        memcpy((void */* __restrict  */)search, (void const   */* __restrict  */)(& rrtmp),
               (size_t )typei->rrsz);
        }
      }
#line 1155
      workbegin += typei->rrsz;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1138
    workbegin = workend;
  }
  while_break: /* CIL Label */ ;
  }
#line 1184
  return;
}
}
#line 1190 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_byteblock___7(adns_query qu , void *datap ) 
{ 
  adns_rr_byteblock *rrp ;
  void *bytes___3 ;

  {
  {
#line 1191
  rrp = (adns_rr_byteblock *)datap;
#line 1192
  bytes___3 = (void *)rrp->data;
#line 1193
  adns__makefinal_block(qu, & bytes___3, (size_t )rrp->len);
#line 1194
  rrp->data = (unsigned char *)bytes___3;
  }
#line 1195
  return;
}
}
#line 1201 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_opaque___7(parseinfo const   *pai , int cbyte___3 , int max ,
                                 void *datap ) 
{ 
  adns_rr_byteblock *rrp ;
  void *tmp ;

  {
  {
#line 1203
  rrp = (adns_rr_byteblock *)datap;
#line 1205
  rrp->len = max - cbyte___3;
#line 1206
  tmp = adns__alloc_interim((adns_query )pai->qu, (size_t )rrp->len);
#line 1206
  rrp->data = (unsigned char *)tmp;
  }
#line 1207
  if (! rrp->data) {
#line 1207
    return ((adns_status )1);
  }
  {
#line 1208
  memcpy((void */* __restrict  */)rrp->data, (void const   */* __restrict  */)(pai->dgram + cbyte___3),
         (size_t )rrp->len);
  }
#line 1209
  return ((adns_status )0);
}
}
#line 1212 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_opaque___7(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_byteblock const   *rrp ;
  char buf___17[10] ;
  int l ;
  unsigned char *p ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1213
  rrp = (adns_rr_byteblock const   *)datap;
#line 1218
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"\\# %d",
          rrp->len);
  }
  {
#line 1219
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1219
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 1219
    if (! tmp) {
#line 1219
      return ((adns_status )1);
    }
#line 1219
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1221
  l = (int )rrp->len;
#line 1221
  p = (unsigned char *)rrp->data;
  {
#line 1221
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1221
    if (! (l >= 4)) {
#line 1221
      goto while_break___0;
    }
    {
#line 1224
    sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %02x%02x%02x%02x",
            (int )*(p + 0), (int )*(p + 1), (int )*(p + 2), (int )*(p + 3));
    }
    {
#line 1225
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1225
      tmp___0 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
      }
#line 1225
      if (! tmp___0) {
#line 1225
        return ((adns_status )1);
      }
#line 1225
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1221
    l -= 4;
#line 1221
    p += 4;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1227
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1227
    if (! (l > 0)) {
#line 1227
      goto while_break___2;
    }
    {
#line 1230
    sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %02x",
            (int )*p);
    }
    {
#line 1231
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 1231
      tmp___1 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
      }
#line 1231
      if (! tmp___1) {
#line 1231
        return ((adns_status )1);
      }
#line 1231
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1227
    l --;
#line 1227
    p ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1233
  return ((adns_status )0);
}
}
#line 1240 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_flat___7(adns_query qu , void *data___0 ) 
{ 


  {
#line 1240
  return;
}
}
#line 1261 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static typeinfo const   typeinfos___7[17]  = 
#line 1261
  {      {(adns_rrtype )1, "A", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.inaddr)),
      & mf_flat___7, & cs_inaddr___7, & pa_inaddr___7, & di_inaddr___7, (adns_status (*)(adns_state ads ,
                                                                                         char const   **p_io ,
                                                                                         char const   *pe ,
                                                                                         int labelnum ,
                                                                                         char *label_r ,
                                                                                         int *ll_io ,
                                                                                         adns_queryflags flags ,
                                                                                         struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )2,
      "NS", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___7, & cs_domain___7,
      & pa_host_raw___7, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )5,
      "CNAME", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___7,
      & cs_domain___7, & pa_dom_raw___7, (int (*)(adns_state ads , void const   *datap_a ,
                                                  void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                              char const   **p_io ,
                                                                                              char const   *pe ,
                                                                                              int labelnum ,
                                                                                              char *label_r ,
                                                                                              int *ll_io ,
                                                                                              adns_queryflags flags ,
                                                                                              struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )6,
      "SOA", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.soa)), & mf_soa___7, & cs_soa___7,
      & pa_soa___7, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )12,
      "PTR", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___7, & cs_domain___7,
      & pa_host_raw___7, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )13,
      "HINFO", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.intstrpair)),
      & mf_intstrpair___7, & cs_hinfo___7, & pa_hinfo___7, (int (*)(adns_state ads ,
                                                                    void const   *datap_a ,
                                                                    void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )15,
      "MX", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.intstr)), & mf_intstr___7,
      & cs_inthost___7, & pa_mx_raw___7, & di_mx_raw___7, (adns_status (*)(adns_state ads ,
                                                                           char const   **p_io ,
                                                                           char const   *pe ,
                                                                           int labelnum ,
                                                                           char *label_r ,
                                                                           int *ll_io ,
                                                                           adns_queryflags flags ,
                                                                           struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )16,
      "TXT", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.manyistr)),
      & mf_manyistr___7, & cs_txt___7, & pa_txt___7, (int (*)(adns_state ads , void const   *datap_a ,
                                                              void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )17,
      "RP", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.strpair)), & mf_strpair___7,
      & cs_rp___7, & pa_rp___7, (int (*)(adns_state ads , void const   *datap_a ,
                                         void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                     char const   **p_io ,
                                                                                     char const   *pe ,
                                                                                     int labelnum ,
                                                                                     char *label_r ,
                                                                                     int *ll_io ,
                                                                                     adns_queryflags flags ,
                                                                                     struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )33,
      "SRV", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.srvraw)), & mf_srvraw___7,
      & cs_srvraw___7, & pa_srvraw___7, & di_srv___7, & qdpl_srv___7, & postsort_srv___7}, 
        {(adns_rrtype )65537,
      "A", "addr", (int )sizeof(*(((adns_answer *)0)->rrs.addr)), & mf_flat___7, & cs_addr___7,
      & pa_addr___7, & di_addr___7, (adns_status (*)(adns_state ads , char const   **p_io ,
                                                     char const   *pe , int labelnum ,
                                                     char *label_r , int *ll_io ,
                                                     adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65538,
      "NS", "+addr", (int )sizeof(*(((adns_answer *)0)->rrs.hostaddr)), & mf_hostaddr___7,
      & cs_hostaddr___7, & pa_hostaddr___7, & di_hostaddr___7, (adns_status (*)(adns_state ads ,
                                                                                char const   **p_io ,
                                                                                char const   *pe ,
                                                                                int labelnum ,
                                                                                char *label_r ,
                                                                                int *ll_io ,
                                                                                adns_queryflags flags ,
                                                                                struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65548,
      "PTR", "checked", (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___7,
      & cs_domain___7, & pa_ptr___7, (int (*)(adns_state ads , void const   *datap_a ,
                                              void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                          char const   **p_io ,
                                                                                          char const   *pe ,
                                                                                          int labelnum ,
                                                                                          char *label_r ,
                                                                                          int *ll_io ,
                                                                                          adns_queryflags flags ,
                                                                                          struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65551,
      "MX", "+addr", (int )sizeof(*(((adns_answer *)0)->rrs.inthostaddr)), & mf_inthostaddr___7,
      & cs_inthostaddr___7, & pa_mx___7, & di_mx___7, (adns_status (*)(adns_state ads ,
                                                                       char const   **p_io ,
                                                                       char const   *pe ,
                                                                       int labelnum ,
                                                                       char *label_r ,
                                                                       int *ll_io ,
                                                                       adns_queryflags flags ,
                                                                       struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65569,
      "SRV", "+addr", (int )sizeof(*(((adns_answer *)0)->rrs.srvha)), & mf_srvha___7,
      & cs_srvha___7, & pa_srvha___7, & di_srv___7, & qdpl_srv___7, & postsort_srv___7}, 
        {(adns_rrtype )131078,
      "SOA", "822", (int )sizeof(*(((adns_answer *)0)->rrs.soa)), & mf_soa___7, & cs_soa___7,
      & pa_soa___7, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )131089,
      "RP", "822", (int )sizeof(*(((adns_answer *)0)->rrs.strpair)), & mf_strpair___7,
      & cs_rp___7, & pa_rp___7, (int (*)(adns_state ads , void const   *datap_a ,
                                         void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                     char const   **p_io ,
                                                                                     char const   *pe ,
                                                                                     int labelnum ,
                                                                                     char *label_r ,
                                                                                     int *ll_io ,
                                                                                     adns_queryflags flags ,
                                                                                     struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}};
#line 1288 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static struct typeinfo  const  typeinfo_unknown___7  = 
#line 1288
     {(adns_rrtype )262144, (char const   *)0, "unknown", (int )sizeof(*(((adns_answer *)0)->rrs.byteblock)),
    & mf_byteblock___7, & cs_opaque___7, & pa_opaque___7, (int (*)(adns_state ads ,
                                                                   void const   *datap_a ,
                                                                   void const   *datap_b ))0,
    (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                     char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
    (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0};
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 233 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/general.c"
static struct sinfo  const  sinfos___7[24]  = 
#line 233 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/general.c"
  {      {(adns_status )0, "ok", "OK"}, 
        {(adns_status )1, "nomemory", "Out of memory"}, 
        {(adns_status )2, "unknownrrtype", "Query not implemented in DNS library"}, 
        {(adns_status )3, "systemfail", "General resolver or system failure"}, 
        {(adns_status )30, "timeout", "DNS query timed out"}, 
        {(adns_status )31, "allservfail", "All nameservers failed"}, 
        {(adns_status )32, "norecurse", "Recursion denied by nameserver"}, 
        {(adns_status )33, "invalidresponse", "Nameserver sent bad response"}, 
        {(adns_status )34, "unknownformat", "Nameserver used unknown format"}, 
        {(adns_status )60, "rcodeservfail", "Nameserver reports failure"}, 
        {(adns_status )61, "rcodeformaterror", "Query not understood by nameserver"}, 
        {(adns_status )62,
      "rcodenotimplemented", "Query not implemented by nameserver"}, 
        {(adns_status )63, "rcoderefused", "Query refused by nameserver"}, 
        {(adns_status )64, "rcodeunknown", "Nameserver sent unknown response code"}, 
        {(adns_status )100, "inconsistent", "Inconsistent resource records in DNS"}, 
        {(adns_status )101, "prohibitedcname", "DNS alias found where canonical name wanted"}, 
        {(adns_status )102,
      "answerdomaininvalid", "Found syntactically invalid domain name"}, 
        {(adns_status )103, "answerdomaintoolong", "Found overly-long domain name"}, 
        {(adns_status )104, "invaliddata", "Found invalid DNS data"}, 
        {(adns_status )200, "querydomainwrong", "Domain invalid for particular DNS query type"}, 
        {(adns_status )201,
      "querydomaininvalid", "Domain name is syntactically invalid"}, 
        {(adns_status )202, "querydomaintoolong", "Domain name or component is too long"}, 
        {(adns_status )300,
      "nxdomain", "No such domain"}, 
        {(adns_status )301, "nodata", "No such data"}};
#line 270 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/general.c"
static int si_compar___7(void const   *key , void const   *elem ) 
{ 
  adns_status const   *st ;
  struct sinfo  const  *si ;
  int tmp ;
  int tmp___0 ;

  {
#line 271
  st = (adns_status const   *)key;
#line 272
  si = (struct sinfo  const  *)elem;
#line 274
  if ((unsigned int const   )*st < (unsigned int const   )si->st) {
#line 274
    tmp___0 = -1;
  } else {
#line 274
    if ((unsigned int const   )*st > (unsigned int const   )si->st) {
#line 274
      tmp = 1;
    } else {
#line 274
      tmp = 0;
    }
#line 274
    tmp___0 = tmp;
  }
#line 274
  return (tmp___0);
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/general.c"
static struct sinfo  const  *findsinfo___7(adns_status st ) 
{ 
  void *tmp ;

  {
  {
#line 278
  tmp = bsearch((void const   *)(& st), (void const   *)(sinfos___7), sizeof(sinfos___7) / sizeof(sinfos___7[0]),
                sizeof(sinfos___7[0]), & si_compar___7);
  }
#line 278
  return ((struct sinfo  const  *)tmp);
}
}
#line 299 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/general.c"
static struct stinfo  const  stinfos___7[7]  = {      {(adns_status )0, "ok"}, 
        {(adns_status )29, "localfail"}, 
        {(adns_status )59, "remotefail"}, 
        {(adns_status )99, "tempfail"}, 
        {(adns_status )199, "misconfig"}, 
        {(adns_status )299, "misquery"}, 
        {(adns_status )499, "permfail"}};
#line 312 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/general.c"
static int sti_compar___7(void const   *key , void const   *elem ) 
{ 
  adns_status const   *st ;
  struct stinfo  const  *sti ;
  adns_status here ;
  adns_status min ;
  adns_status max ;
  int tmp ;
  int tmp___0 ;

  {
#line 313
  st = (adns_status const   *)key;
#line 314
  sti = (struct stinfo  const  *)elem;
#line 318
  here = (adns_status )*st;
#line 319
  if ((unsigned long )sti == (unsigned long )(stinfos___7)) {
#line 319
    min = (adns_status )0;
  } else {
#line 319
    min = (adns_status )((unsigned int const   )(sti + -1)->stmax + 1U);
  }
#line 320
  max = (adns_status )sti->stmax;
#line 322
  if ((unsigned int )here < (unsigned int )min) {
#line 322
    tmp___0 = -1;
  } else {
#line 322
    if ((unsigned int )here > (unsigned int )max) {
#line 322
      tmp = 1;
    } else {
#line 322
      tmp = 0;
    }
#line 322
    tmp___0 = tmp;
  }
#line 322
  return (tmp___0);
}
}
#line 50 "/usr/include/x86_64-linux-gnu/sys/uio.h"
extern ssize_t writev(int __fd , struct iovec  const  *__iovec , int __count ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/tvarith.h"
__inline static void timevaladd___18(struct timeval *tv_io , long ms ) 
{ 
  struct timeval tmp ;

  {
#line 32
  if (! (ms >= 0L)) {
    {
#line 32
    __assert_fail("ms>=0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/tvarith.h",
                  32U, "timevaladd");
    }
  }
#line 33
  tmp = *tv_io;
#line 34
  tmp.tv_usec += (ms % 1000L) * 1000L;
#line 35
  tmp.tv_sec += ms / 1000L;
#line 36
  if (tmp.tv_usec >= 1000000L) {
#line 36
    (tmp.tv_sec) ++;
#line 36
    tmp.tv_usec -= 1000000L;
  }
#line 37
  *tv_io = tmp;
#line 38
  return;
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/transmit.c"
static adns_status mkquery_header___7(adns_state ads___7 , vbuf *vb___0 , int *id_r ,
                                      int qdlen ) 
{ 
  int id ;
  byte *rqp ;
  int tmp ;
  int tmp___0 ;
  byte *tmp___1 ;
  byte *tmp___2 ;
  byte *tmp___3 ;
  byte *tmp___4 ;
  byte *tmp___5 ;
  byte *tmp___6 ;
  byte *tmp___7 ;
  byte *tmp___8 ;
  byte *tmp___9 ;
  byte *tmp___10 ;
  byte *tmp___11 ;
  byte *tmp___12 ;

  {
  {
#line 46
  tmp = adns__vbuf_ensure(vb___0, (12 + qdlen) + 4);
  }
#line 46
  if (! tmp) {
#line 46
    return ((adns_status )1);
  }
#line 48
  vb___0->used = 0;
#line 49
  rqp = vb___0->buf + vb___0->used;
#line 51
  tmp___0 = ads___7->nextid;
#line 51
  (ads___7->nextid) ++;
#line 51
  id = tmp___0 & 65535;
#line 51
  *id_r = id;
#line 52
  tmp___1 = rqp;
#line 52
  rqp ++;
#line 52
  *tmp___1 = (byte )((id >> 8) & 255);
#line 52
  tmp___2 = rqp;
#line 52
  rqp ++;
#line 52
  *tmp___2 = (byte )(id & 255);
#line 53
  tmp___3 = rqp;
#line 53
  rqp ++;
#line 53
  *tmp___3 = (byte )1;
#line 54
  tmp___4 = rqp;
#line 54
  rqp ++;
#line 54
  *tmp___4 = (byte )0;
#line 55
  tmp___5 = rqp;
#line 55
  rqp ++;
#line 55
  *tmp___5 = (byte )((1 >> 8) & 255);
#line 55
  tmp___6 = rqp;
#line 55
  rqp ++;
#line 55
  *tmp___6 = (byte )1;
#line 56
  tmp___7 = rqp;
#line 56
  rqp ++;
#line 56
  *tmp___7 = (byte )0;
#line 56
  tmp___8 = rqp;
#line 56
  rqp ++;
#line 56
  *tmp___8 = (byte )0;
#line 57
  tmp___9 = rqp;
#line 57
  rqp ++;
#line 57
  *tmp___9 = (byte )0;
#line 57
  tmp___10 = rqp;
#line 57
  rqp ++;
#line 57
  *tmp___10 = (byte )0;
#line 58
  tmp___11 = rqp;
#line 58
  rqp ++;
#line 58
  *tmp___11 = (byte )0;
#line 58
  tmp___12 = rqp;
#line 58
  rqp ++;
#line 58
  *tmp___12 = (byte )0;
#line 60
  vb___0->used = (int )(rqp - vb___0->buf);
#line 62
  return ((adns_status )0);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/transmit.c"
static adns_status mkquery_footer___7(vbuf *vb___0 , adns_rrtype type ) 
{ 
  byte *rqp ;
  byte *tmp ;
  byte *tmp___0 ;
  byte *tmp___1 ;
  byte *tmp___2 ;

  {
#line 68
  rqp = vb___0->buf + vb___0->used;
#line 69
  tmp = rqp;
#line 69
  rqp ++;
#line 69
  *tmp = (byte )((((unsigned int )type & 65535U) >> 8) & 255U);
#line 69
  tmp___0 = rqp;
#line 69
  rqp ++;
#line 69
  *tmp___0 = (byte )(((unsigned int )type & 65535U) & 255U);
#line 70
  tmp___1 = rqp;
#line 70
  rqp ++;
#line 70
  *tmp___1 = (byte )((1 >> 8) & 255);
#line 70
  tmp___2 = rqp;
#line 70
  rqp ++;
#line 70
  *tmp___2 = (byte )1;
#line 71
  vb___0->used = (int )(rqp - vb___0->buf);
#line 72
  if (! (vb___0->used <= vb___0->avail)) {
    {
#line 72
    __assert_fail("vb->used <= vb->avail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/transmit.c",
                  72U, "mkquery_footer");
    }
  }
#line 74
  return ((adns_status )0);
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/transmit.c"
static void query_usetcp___7(adns_query qu , struct timeval now ) 
{ 


  {
  {
#line 244
  qu->state = (enum __anonenum_state_83 )1;
#line 245
  qu->timeout = now;
#line 246
  timevaladd___18(& qu->timeout, 30000L);
  }
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    qu->next = (adns_query )0;
#line 247
    qu->back = (qu->ads)->tcpw.tail;
#line 247
    if ((qu->ads)->tcpw.tail) {
#line 247
      ((qu->ads)->tcpw.tail)->next = qu;
    } else {
#line 247
      (qu->ads)->tcpw.head = qu;
    }
#line 247
    (qu->ads)->tcpw.tail = qu;
#line 247
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 248
  adns__querysend_tcp(qu, now);
#line 249
  adns__tcp_tryconnect(qu->ads, now);
  }
#line 250
  return;
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c"
static adns_query query_alloc___7(adns_state ads___7 , typeinfo const   *typei , adns_rrtype type ,
                                  adns_queryflags flags , struct timeval now ) 
{ 
  adns_query qu ;
  void *tmp ;
  void *tmp___0 ;
  adns_query tmp___1 ;
  adns_query tmp___2 ;
  adns_query tmp___3 ;
  adns_query tmp___4 ;
  allocnode *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __suseconds_t tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 45
  tmp = malloc(sizeof(*qu));
#line 45
  qu = (adns_query )tmp;
  }
#line 45
  if (! qu) {
#line 45
    return ((adns_query )0);
  }
  {
#line 46
  tmp___0 = malloc(sizeof(*(qu->answer)));
#line 46
  qu->answer = (adns_answer *)tmp___0;
  }
#line 47
  if (! qu->answer) {
    {
#line 47
    free((void *)qu);
    }
#line 47
    return ((adns_query )0);
  }
  {
#line 49
  qu->ads = ads___7;
#line 50
  qu->state = (enum __anonenum_state_83 )0;
#line 51
  tmp___2 = (adns_query )0;
#line 51
  qu->parent = tmp___2;
#line 51
  tmp___1 = tmp___2;
#line 51
  qu->next = tmp___1;
#line 51
  qu->back = tmp___1;
#line 52
  tmp___3 = (adns_query )0;
#line 52
  qu->children.tail = tmp___3;
#line 52
  qu->children.head = tmp___3;
#line 53
  tmp___4 = (adns_query )0;
#line 53
  qu->siblings.back = tmp___4;
#line 53
  qu->siblings.next = tmp___4;
#line 54
  tmp___5 = (allocnode *)0;
#line 54
  qu->allocations.tail = tmp___5;
#line 54
  qu->allocations.head = tmp___5;
#line 55
  qu->interim_allocd = 0;
#line 56
  qu->preserved_allocd = 0;
#line 57
  qu->final_allocspace = (void *)0;
#line 59
  qu->typei = typei;
#line 60
  qu->query_dgram = (byte *)0;
#line 61
  qu->query_dglen = 0;
#line 62
  adns__vbuf_init(& qu->vb);
#line 64
  qu->cname_dgram = (byte *)0;
#line 65
  tmp___6 = 0;
#line 65
  qu->cname_begin = tmp___6;
#line 65
  qu->cname_dglen = tmp___6;
#line 67
  adns__vbuf_init(& qu->search_vb);
#line 68
  tmp___8 = 0;
#line 68
  qu->search_doneabs = tmp___8;
#line 68
  tmp___7 = tmp___8;
#line 68
  qu->search_pos = tmp___7;
#line 68
  qu->search_origlen = tmp___7;
#line 70
  qu->id = -2;
#line 71
  qu->flags = (int )flags;
#line 72
  qu->retries = 0;
#line 73
  qu->udpnextserver = 0;
#line 74
  qu->udpsent = 0UL;
#line 75
  tmp___9 = (__suseconds_t )0;
#line 75
  qu->timeout.tv_usec = tmp___9;
#line 75
  qu->timeout.tv_sec = tmp___9;
#line 76
  qu->expires = now.tv_sec + 604800L;
#line 78
  memset((void *)(& qu->ctx), 0, sizeof(qu->ctx));
#line 80
  (qu->answer)->status = (adns_status )0;
#line 81
  tmp___10 = (char *)0;
#line 81
  (qu->answer)->owner = tmp___10;
#line 81
  (qu->answer)->cname = tmp___10;
#line 82
  (qu->answer)->type = type;
#line 83
  (qu->answer)->expires = (time_t )-1;
#line 84
  (qu->answer)->nrrs = 0;
#line 85
  (qu->answer)->rrs.untyped = (void *)0;
#line 86
  (qu->answer)->rrsz = (int )typei->rrsz;
  }
#line 88
  return (qu);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c"
static void query_submit___7(adns_state ads___7 , adns_query qu , typeinfo const   *typei ,
                             vbuf *qumsg_vb , int id , adns_queryflags flags , struct timeval now ) 
{ 
  void *tmp ;

  {
  {
#line 98
  qu->vb = *qumsg_vb;
#line 99
  adns__vbuf_init(qumsg_vb);
#line 101
  tmp = malloc((size_t )qu->vb.used);
#line 101
  qu->query_dgram = (byte *)tmp;
  }
#line 102
  if (! qu->query_dgram) {
    {
#line 102
    adns__query_fail(qu, (adns_status )1);
    }
#line 102
    return;
  }
  {
#line 104
  qu->id = id;
#line 105
  qu->query_dglen = qu->vb.used;
#line 106
  memcpy((void */* __restrict  */)qu->query_dgram, (void const   */* __restrict  */)qu->vb.buf,
         (size_t )qu->vb.used);
#line 108
  adns__query_send(qu, now);
  }
#line 109
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c"
static void query_simple___7(adns_state ads___7 , adns_query qu , char const   *owner ,
                             int ol , typeinfo const   *typei , adns_queryflags flags ,
                             struct timeval now ) 
{ 
  vbuf vb_new ;
  int id ;
  adns_status stat ;

  {
  {
#line 136
  stat = adns__mkquery(ads___7, & qu->vb, & id, owner, ol, typei, (qu->answer)->type,
                       flags);
  }
#line 138
  if (stat) {
#line 139
    if ((unsigned int )stat == 202U) {
#line 139
      if ((unsigned int )flags & 1U) {
        {
#line 140
        adns__search_next(ads___7, qu, now);
        }
#line 141
        return;
      } else {
        {
#line 143
        adns__query_fail(qu, stat);
        }
#line 144
        return;
      }
    } else {
      {
#line 143
      adns__query_fail(qu, stat);
      }
#line 144
      return;
    }
  }
  {
#line 148
  vb_new = qu->vb;
#line 149
  adns__vbuf_init(& qu->vb);
#line 150
  query_submit___7(ads___7, qu, typei, & vb_new, id, flags, now);
  }
#line 151
  return;
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c"
static int save_owner___7(adns_query qu , char const   *owner , int ol ) 
{ 
  adns_answer *ans ;
  void *tmp ;

  {
#line 198
  if (! (qu->flags & 4)) {
#line 198
    return (1);
  }
#line 200
  ans = qu->answer;
#line 201
  if (! (! ans->owner)) {
    {
#line 201
    __assert_fail("!ans->owner", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c",
                  201U, "save_owner");
    }
  }
  {
#line 203
  tmp = adns__alloc_preserved(qu, (size_t )(ol + 1));
#line 203
  ans->owner = (char *)tmp;
  }
#line 203
  if (! ans->owner) {
#line 203
    return (0);
  }
  {
#line 205
  memcpy((void */* __restrict  */)ans->owner, (void const   */* __restrict  */)owner,
         (size_t )ol);
#line 206
  *(ans->owner + ol) = (char)0;
  }
#line 207
  return (1);
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c"
static void *alloc_common___7(adns_query qu , size_t sz ) 
{ 
  allocnode *an ;
  void *tmp ;

  {
#line 342
  if (! sz) {
#line 342
    return ((void *)qu);
  }
#line 343
  if (! (! qu->final_allocspace)) {
    {
#line 343
    __assert_fail("!qu->final_allocspace", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c",
                  343U, "alloc_common");
    }
  }
  {
#line 344
  tmp = malloc((((((((sizeof(*an) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ) + sz) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ));
#line 344
  an = (allocnode *)tmp;
  }
#line 345
  if (! an) {
#line 345
    return ((void *)0);
  }
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 346
    an->next = (struct allocnode *)0;
#line 346
    an->back = qu->allocations.tail;
#line 346
    if (qu->allocations.tail) {
#line 346
      (qu->allocations.tail)->next = an;
    } else {
#line 346
      qu->allocations.head = an;
    }
#line 346
    qu->allocations.tail = an;
#line 346
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 347
  return ((void *)((byte *)an + (((sizeof(*an) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign )));
}
}
#line 410 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c"
static void cancel_children___7(adns_query qu ) 
{ 
  adns_query cqu ;
  adns_query ncqu ;

  {
#line 413
  cqu = qu->children.head;
  {
#line 413
  while (1) {
    while_continue: /* CIL Label */ ;
#line 413
    if (! cqu) {
#line 413
      goto while_break;
    }
    {
#line 414
    ncqu = cqu->siblings.next;
#line 415
    adns_cancel(cqu);
#line 413
    cqu = ncqu;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 417
  return;
}
}
#line 427 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c"
static void free_query_allocs___7(adns_query qu ) 
{ 
  allocnode *an ;
  allocnode *ann ;
  allocnode *tmp ;

  {
  {
#line 430
  cancel_children___7(qu);
#line 431
  an = qu->allocations.head;
  }
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    if (! an) {
#line 431
      goto while_break;
    }
    {
#line 431
    ann = an->next;
#line 431
    free((void *)an);
#line 431
    an = ann;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 432
  tmp = (allocnode *)0;
#line 432
  qu->allocations.tail = tmp;
#line 432
  qu->allocations.head = tmp;
#line 433
  adns__vbuf_free(& qu->vb);
#line 434
  adns__vbuf_free(& qu->search_vb);
#line 435
  free((void *)qu->query_dgram);
#line 436
  qu->query_dgram = (byte *)0;
  }
#line 437
  return;
}
}
#line 477 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c"
static void makefinal_query___7(adns_query qu ) 
{ 
  adns_answer *ans ;
  int rrn ;
  void *tmp ;

  {
#line 481
  ans = qu->answer;
#line 483
  if (qu->interim_allocd) {
    {
#line 484
    tmp = realloc((void *)qu->answer, (((((((sizeof(*ans) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ) + (unsigned long )qu->interim_allocd) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ));
#line 484
    ans = (adns_answer *)tmp;
    }
#line 486
    if (! ans) {
#line 486
      goto x_nomem;
    }
#line 487
    qu->answer = ans;
  }
  {
#line 490
  qu->final_allocspace = (void *)((byte *)ans + (((sizeof(*ans) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ));
#line 491
  adns__makefinal_str(qu, & ans->cname);
#line 492
  adns__makefinal_str(qu, & ans->owner);
  }
#line 494
  if (ans->nrrs) {
    {
#line 495
    adns__makefinal_block(qu, & ans->rrs.untyped, (size_t )(ans->nrrs * ans->rrsz));
#line 497
    rrn = 0;
    }
    {
#line 497
    while (1) {
      while_continue: /* CIL Label */ ;
#line 497
      if (! (rrn < ans->nrrs)) {
#line 497
        goto while_break;
      }
      {
#line 498
      (*((qu->typei)->makefinal))(qu, (void *)(ans->rrs.bytes + rrn * ans->rrsz));
#line 497
      rrn ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 501
  free_query_allocs___7(qu);
  }
#line 502
  return;
  x_nomem: 
  {
#line 505
  qu->preserved_allocd = 0;
#line 506
  (qu->answer)->cname = (char *)0;
#line 507
  (qu->answer)->owner = (char *)0;
#line 508
  adns__reset_preserved(qu);
#line 510
  (qu->answer)->status = (adns_status )1;
#line 511
  free_query_allocs___7(qu);
  }
#line 512
  return;
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void readconfig___7(adns_state ads___7 , char const   *filename , int warnmissing ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void addserver___7(adns_state ads___7 , struct in_addr addr ) 
{ 
  int i ;
  struct server *ss ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 48
  i = 0;
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (i < ads___7->nservers)) {
#line 48
      goto while_break;
    }
#line 49
    if (ads___7->servers[i].addr.s_addr == addr.s_addr) {
      {
#line 50
      tmp = inet_ntoa(addr);
#line 50
      adns__debug(ads___7, -1, (adns_query )0, "duplicate nameserver %s ignored",
                  tmp);
      }
#line 51
      return;
    }
#line 48
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  if (ads___7->nservers >= 5) {
    {
#line 56
    tmp___0 = inet_ntoa(addr);
#line 56
    adns__diag(ads___7, -1, (adns_query )0, "too many nameservers, ignoring %s", tmp___0);
    }
#line 57
    return;
  }
#line 60
  ss = ads___7->servers + ads___7->nservers;
#line 61
  ss->addr = addr;
#line 62
  (ads___7->nservers) ++;
#line 63
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void freesearchlist___7(adns_state ads___7 ) 
{ 


  {
#line 66
  if (ads___7->nsearchlist) {
    {
#line 66
    free((void *)*(ads___7->searchlist));
    }
  }
  {
#line 67
  free((void *)ads___7->searchlist);
  }
#line 68
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void saveerr___7(adns_state ads___7 , int en ) 
{ 


  {
#line 71
  if (! ads___7->configerrno) {
#line 71
    ads___7->configerrno = en;
  }
#line 72
  return;
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void configparseerr___7(adns_state ads___7 , char const   *fn , int lno , char const   *fmt 
                               , ...) 
{ 
  va_list al ;

  {
  {
#line 78
  saveerr___7(ads___7, 22);
  }
#line 79
  if (! ads___7->logfn) {
#line 79
    return;
  } else
#line 79
  if ((unsigned int )ads___7->iflags & 2U) {
#line 79
    return;
  }
#line 81
  if (lno == -1) {
    {
#line 81
    adns__lprintf(ads___7, "adns: %s: ", fn);
    }
  } else {
    {
#line 82
    adns__lprintf(ads___7, "adns: %s:%d: ", fn, lno);
    }
  }
  {
#line 83
  __builtin_va_start(al, fmt);
#line 84
  adns__vlprintf(ads___7, fmt, al);
#line 85
  __builtin_va_end(al);
#line 86
  adns__lprintf(ads___7, "\n");
  }
#line 87
  return;
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static int nextword___7(char const   **bufp_io , char const   **word_r , int *l_r ) 
{ 
  char const   *p ;
  char const   *q ;
  int tmp ;
  int tmp___0 ;

  {
#line 92
  p = *bufp_io;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 93
    tmp = ctype_whitespace((int )*p);
    }
#line 93
    if (! tmp) {
#line 93
      goto while_break;
    }
#line 93
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  if (! *p) {
#line 94
    return (0);
  }
#line 96
  q = p;
  {
#line 97
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 97
    if (*q) {
      {
#line 97
      tmp___0 = ctype_whitespace((int )*q);
      }
#line 97
      if (tmp___0) {
#line 97
        goto while_break___0;
      }
    } else {
#line 97
      goto while_break___0;
    }
#line 97
    q ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 99
  *l_r = (int )(q - p);
#line 100
  *word_r = p;
#line 101
  *bufp_io = q;
#line 103
  return (1);
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void ccf_nameserver___7(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  struct in_addr ia ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 110
  tmp = inet_aton(buf___17, & ia);
  }
#line 110
  if (! tmp) {
    {
#line 111
    configparseerr___7(ads___7, fn, lno, "invalid nameserver address `%s\'", buf___17);
    }
#line 112
    return;
  }
  {
#line 114
  tmp___0 = inet_ntoa(ia);
#line 114
  adns__debug(ads___7, -1, (adns_query )0, "using nameserver %s", tmp___0);
#line 115
  addserver___7(ads___7, ia);
  }
#line 116
  return;
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void ccf_search___7(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  char const   *bufp ;
  char const   *word ;
  char *newchars ;
  char **newptrs ;
  char **pp ;
  int count ;
  int tl ;
  int l ;
  int tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char **tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
#line 124
  if (! buf___17) {
#line 124
    return;
  }
#line 126
  bufp = buf___17;
#line 127
  count = 0;
#line 128
  tl = 0;
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 129
    tmp = nextword___7(& bufp, & word, & l);
    }
#line 129
    if (! tmp) {
#line 129
      goto while_break;
    }
#line 129
    count ++;
#line 129
    tl += l + 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 131
  tmp___0 = malloc(sizeof(char *) * (unsigned long )count);
#line 131
  newptrs = (char **)tmp___0;
  }
#line 132
  if (! newptrs) {
    {
#line 132
    tmp___1 = __errno_location();
#line 132
    saveerr___7(ads___7, *tmp___1);
    }
#line 132
    return;
  }
  {
#line 134
  tmp___2 = malloc((size_t )tl);
#line 134
  newchars = (char *)tmp___2;
  }
#line 135
  if (! newchars) {
    {
#line 135
    tmp___3 = __errno_location();
#line 135
    saveerr___7(ads___7, *tmp___3);
#line 135
    free((void *)newptrs);
    }
#line 135
    return;
  }
#line 137
  bufp = buf___17;
#line 138
  pp = newptrs;
  {
#line 139
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 139
    tmp___6 = nextword___7(& bufp, & word, & l);
    }
#line 139
    if (! tmp___6) {
#line 139
      goto while_break___0;
    }
    {
#line 140
    tmp___4 = pp;
#line 140
    pp ++;
#line 140
    *tmp___4 = newchars;
#line 141
    memcpy((void */* __restrict  */)newchars, (void const   */* __restrict  */)word,
           (size_t )l);
#line 142
    newchars += l;
#line 143
    tmp___5 = newchars;
#line 143
    newchars ++;
#line 143
    *tmp___5 = (char)0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 146
  freesearchlist___7(ads___7);
#line 147
  ads___7->nsearchlist = count;
#line 148
  ads___7->searchlist = newptrs;
  }
#line 149
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void ccf_sortlist___7(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  char const   *word ;
  char tbuf[200] ;
  char *slash ;
  char *ep ;
  struct in_addr base ;
  struct in_addr mask ;
  int l ;
  unsigned long initial ;
  unsigned long baselocal ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  uint32_t tmp___3 ;
  int tmp___4 ;

  {
#line 159
  if (! buf___17) {
#line 159
    return;
  }
#line 161
  ads___7->nsortlist = 0;
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 162
    tmp___4 = nextword___7(& buf___17, & word, & l);
    }
#line 162
    if (! tmp___4) {
#line 162
      goto while_break;
    }
#line 163
    if (ads___7->nsortlist >= 15) {
      {
#line 164
      adns__diag(ads___7, -1, (adns_query )0, "too many sortlist entries, ignoring %.*s onwards",
                 l, word);
      }
#line 166
      return;
    }
#line 169
    if ((unsigned long )l >= sizeof(tbuf)) {
      {
#line 170
      configparseerr___7(ads___7, fn, lno, "sortlist entry `%.*s\' too long", l, word);
      }
#line 171
      goto while_continue;
    }
    {
#line 174
    memcpy((void */* __restrict  */)(tbuf), (void const   */* __restrict  */)word,
           (size_t )l);
#line 174
    tbuf[l] = (char)0;
#line 175
    slash = strchr((char const   *)(tbuf), '/');
    }
#line 176
    if (slash) {
#line 176
      tmp = slash;
#line 176
      slash ++;
#line 176
      *tmp = (char)0;
    }
    {
#line 178
    tmp___0 = inet_aton((char const   *)(tbuf), & base);
    }
#line 178
    if (! tmp___0) {
      {
#line 179
      configparseerr___7(ads___7, fn, lno, "invalid address `%s\' in sortlist", tbuf);
      }
#line 180
      goto while_continue;
    }
#line 183
    if (slash) {
      {
#line 184
      tmp___2 = strchr((char const   *)slash, '.');
      }
#line 184
      if (tmp___2) {
        {
#line 185
        tmp___1 = inet_aton((char const   *)slash, & mask);
        }
#line 185
        if (! tmp___1) {
          {
#line 186
          configparseerr___7(ads___7, fn, lno, "invalid mask `%s\' in sortlist", slash);
          }
#line 187
          goto while_continue;
        }
#line 189
        if (base.s_addr & ~ mask.s_addr) {
          {
#line 190
          configparseerr___7(ads___7, fn, lno, "mask `%s\' in sortlist overlaps address `%s\'",
                             slash, tbuf);
          }
#line 192
          goto while_continue;
        }
      } else {
        {
#line 195
        initial = strtoul((char const   */* __restrict  */)slash, (char **/* __restrict  */)(& ep),
                          10);
        }
#line 196
        if (*ep) {
          {
#line 197
          configparseerr___7(ads___7, fn, lno, "mask length `%s\' invalid", slash);
          }
#line 198
          goto while_continue;
        } else
#line 196
        if (initial > 32UL) {
          {
#line 197
          configparseerr___7(ads___7, fn, lno, "mask length `%s\' invalid", slash);
          }
#line 198
          goto while_continue;
        }
        {
#line 200
        mask.s_addr = htonl((uint32_t )(4294967295UL << (32UL - initial)));
        }
      }
    } else {
      {
#line 203
      tmp___3 = ntohl(base.s_addr);
#line 203
      baselocal = (unsigned long )tmp___3;
      }
#line 204
      if ((unsigned long )(! baselocal) & 2147483648UL) {
        {
#line 205
        mask.s_addr = htonl((uint32_t )4278190080UL);
        }
      } else
#line 206
      if ((baselocal & 3221225472UL) == 2147483648UL) {
        {
#line 207
        mask.s_addr = htonl((uint32_t )4294901760UL);
        }
      } else
#line 208
      if ((baselocal & 4026531840UL) == 3758096384UL) {
        {
#line 209
        mask.s_addr = htonl((uint32_t )4278190080UL);
        }
      } else {
        {
#line 211
        configparseerr___7(ads___7, fn, lno, "network address `%s\' in sortlist is not in classed ranges, must specify mask explicitly",
                           tbuf);
        }
#line 214
        goto while_continue;
      }
    }
#line 218
    ads___7->sortlist[ads___7->nsortlist].base = base;
#line 219
    ads___7->sortlist[ads___7->nsortlist].mask = mask;
#line 220
    (ads___7->nsortlist) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  return;
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void ccf_options___7(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  char const   *word ;
  char *ep ;
  unsigned long v ;
  int l ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 231
  if (! buf___17) {
#line 231
    return;
  }
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 233
    tmp___5 = nextword___7(& buf___17, & word, & l);
    }
#line 233
    if (! tmp___5) {
#line 233
      goto while_break;
    }
#line 234
    if (l == 5) {
      {
#line 234
      tmp = memcmp((void const   *)word, (void const   *)"debug", (size_t )5);
      }
#line 234
      if (! tmp) {
#line 235
        ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 8U);
#line 236
        goto while_continue;
      }
    }
#line 238
    if (l >= 6) {
      {
#line 238
      tmp___0 = memcmp((void const   *)word, (void const   *)"ndots:", (size_t )6);
      }
#line 238
      if (! tmp___0) {
        {
#line 239
        v = strtoul((char const   */* __restrict  */)(word + 6), (char **/* __restrict  */)(& ep),
                    10);
        }
#line 240
        if (l == 6) {
          {
#line 241
          configparseerr___7(ads___7, fn, lno, "option `%.*s\' malformed or has bad value",
                             l, word);
          }
#line 243
          goto while_continue;
        } else
#line 240
        if ((unsigned long )ep != (unsigned long )(word + l)) {
          {
#line 241
          configparseerr___7(ads___7, fn, lno, "option `%.*s\' malformed or has bad value",
                             l, word);
          }
#line 243
          goto while_continue;
        } else
#line 240
        if (v > 2147483647UL) {
          {
#line 241
          configparseerr___7(ads___7, fn, lno, "option `%.*s\' malformed or has bad value",
                             l, word);
          }
#line 243
          goto while_continue;
        }
#line 245
        ads___7->searchndots = (int )v;
#line 246
        goto while_continue;
      }
    }
#line 248
    if (l >= 12) {
      {
#line 248
      tmp___4 = memcmp((void const   *)word, (void const   *)"adns_checkc:", (size_t )12);
      }
#line 248
      if (! tmp___4) {
        {
#line 249
        tmp___3 = strcmp(word + 12, "none");
        }
#line 249
        if (tmp___3) {
          {
#line 252
          tmp___2 = strcmp(word + 12, "entex");
          }
#line 252
          if (tmp___2) {
            {
#line 255
            tmp___1 = strcmp(word + 12, "freq");
            }
#line 255
            if (tmp___1) {
              {
#line 258
              configparseerr___7(ads___7, fn, lno, "option adns_checkc has bad value `%s\' (must be none, entex or freq",
                                 word + 12);
              }
            } else {
#line 256
              ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 768U);
            }
          } else {
#line 253
            ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags & 4294966527U);
#line 254
            ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 256U);
          }
        } else {
#line 250
          ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags & 4294966527U);
#line 251
          ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 256U);
        }
#line 261
        goto while_continue;
      }
    }
    {
#line 263
    adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown option `%.*s\'", fn, lno,
               l, word);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 265
  return;
}
}
#line 267 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void ccf_clearnss___7(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 


  {
#line 269
  ads___7->nservers = 0;
#line 270
  return;
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void ccf_include___7(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 


  {
#line 274
  if (! *buf___17) {
    {
#line 275
    configparseerr___7(ads___7, fn, lno, "`include\' directive with no filename");
    }
#line 276
    return;
  }
  {
#line 278
  readconfig___7(ads___7, buf___17, 1);
  }
#line 279
  return;
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void ccf_lookup___7(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  int found_bind ;
  char const   *word ;
  int l ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 283
  found_bind = 0;
#line 287
  if (! *buf___17) {
    {
#line 288
    configparseerr___7(ads___7, fn, lno, "`lookup\' directive with no databases");
    }
#line 289
    return;
  }
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 292
    tmp___2 = nextword___7(& buf___17, & word, & l);
    }
#line 292
    if (! tmp___2) {
#line 292
      goto while_break;
    }
#line 293
    if (l == 4) {
      {
#line 293
      tmp___1 = memcmp((void const   *)word, (void const   *)"bind", (size_t )4);
      }
#line 293
      if (tmp___1) {
#line 293
        goto _L___0;
      } else {
#line 294
        found_bind = 1;
      }
    } else
    _L___0: /* CIL Label */ 
#line 295
    if (l == 4) {
      {
#line 295
      tmp___0 = memcmp((void const   *)word, (void const   *)"file", (size_t )4);
      }
#line 295
      if (tmp___0) {
#line 295
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 297
    if (l == 2) {
      {
#line 297
      tmp = memcmp((void const   *)word, (void const   *)"yp", (size_t )2);
      }
#line 297
      if (tmp) {
        {
#line 301
        adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown `lookup\' database `%.*s\'",
                   fn, lno, l, word);
#line 303
        found_bind = -1;
        }
      } else {
        {
#line 298
        adns__diag(ads___7, -1, (adns_query )0, "%s:%d: yp lookups not supported by adns",
                   fn, lno);
#line 299
        found_bind = -1;
        }
      }
    } else {
      {
#line 301
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown `lookup\' database `%.*s\'",
                 fn, lno, l, word);
#line 303
      found_bind = -1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 306
  if (! found_bind) {
    {
#line 307
    adns__diag(ads___7, -1, (adns_query )0, "%s:%d: `lookup\' specified, but not `bind\'",
               fn, lno);
    }
  }
#line 308
  return;
}
}
#line 310 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static struct configcommandinfo  const  configcommandinfos___7[9]  = 
#line 310
  {      {"nameserver", & ccf_nameserver___7}, 
        {"domain", & ccf_search___7}, 
        {"search", & ccf_search___7}, 
        {"sortlist", & ccf_sortlist___7}, 
        {"options", & ccf_options___7}, 
        {"clearnameservers", & ccf_clearnss___7}, 
        {"include", & ccf_include___7}, 
        {"lookup", & ccf_lookup___7}, 
        {(char const   *)0, (void (*)(adns_state ads , char const   *fn , int lno , char const   *buf ))0}};
#line 330 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static int gl_file___7(adns_state ads___7 , getline_ctx *src_io , char const   *filename ,
                       int lno , char *buf___17 , int buflen ) 
{ 
  FILE *file ;
  int c ;
  int i ;
  char *p ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 332
  file = src_io->file;
#line 336
  p = buf___17;
#line 337
  buflen --;
#line 338
  i = 0;
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (i == buflen) {
      {
#line 342
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: line too long, ignored", filename,
                 lno);
      }
#line 343
      goto x_badline;
    }
    {
#line 345
    c = _IO_getc(file);
    }
#line 346
    if (! c) {
      {
#line 347
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: line contains nul, ignored",
                 filename, lno);
      }
#line 348
      goto x_badline;
    } else
#line 349
    if (c == 10) {
#line 350
      goto while_break;
    } else
#line 351
    if (c == -1) {
      {
#line 352
      tmp___2 = ferror(file);
      }
#line 352
      if (tmp___2) {
        {
#line 353
        tmp = __errno_location();
#line 353
        saveerr___7(ads___7, *tmp);
#line 354
        tmp___0 = __errno_location();
#line 354
        tmp___1 = strerror(*tmp___0);
#line 354
        adns__diag(ads___7, -1, (adns_query )0, "%s:%d: read error: %s", filename,
                   lno, tmp___1);
        }
#line 356
        return (-1);
      }
#line 358
      if (! i) {
#line 358
        return (-1);
      }
#line 359
      goto while_break;
    } else {
#line 361
      tmp___3 = p;
#line 361
      p ++;
#line 361
      *tmp___3 = (char )c;
#line 362
      i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 366
  tmp___4 = p;
#line 366
  p ++;
#line 366
  *tmp___4 = (char)0;
#line 367
  return (i);
  x_badline: 
  {
#line 370
  saveerr___7(ads___7, 22);
  }
  {
#line 371
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 371
    c = _IO_getc(file);
    }
#line 371
    if (c != -1) {
#line 371
      if (! (c != 10)) {
#line 371
        goto while_break___0;
      }
    } else {
#line 371
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 372
  return (-2);
}
}
#line 375 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static int gl_text___7(adns_state ads___7 , getline_ctx *src_io , char const   *filename ,
                       int lno , char *buf___17 , int buflen ) 
{ 
  char const   *cp ;
  int l ;
  size_t tmp ;

  {
#line 377
  cp = src_io->text;
#line 380
  if (! cp) {
#line 380
    return (-1);
  } else
#line 380
  if (! *cp) {
#line 380
    return (-1);
  }
#line 382
  if ((int const   )*cp == 59) {
#line 382
    cp ++;
  } else
#line 382
  if ((int const   )*cp == 10) {
#line 382
    cp ++;
  }
  {
#line 383
  tmp = strcspn(cp, ";\n");
#line 383
  l = (int )tmp;
#line 384
  src_io->text = cp + l;
  }
#line 386
  if (l >= buflen) {
    {
#line 387
    adns__diag(ads___7, -1, (adns_query )0, "%s:%d: line too long, ignored", filename,
               lno);
#line 388
    saveerr___7(ads___7, 22);
    }
#line 389
    return (-2);
  }
  {
#line 392
  memcpy((void */* __restrict  */)buf___17, (void const   */* __restrict  */)cp, (size_t )l);
#line 393
  *(buf___17 + l) = (char)0;
  }
#line 394
  return (l);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void readconfiggeneric___7(adns_state ads___7 , char const   *filename , int (*getline___0)(adns_state ads ,
                                                                                                   getline_ctx * ,
                                                                                                   char const   *filename ,
                                                                                                   int lno ,
                                                                                                   char *buf ,
                                                                                                   int buflen ) ,
                                  getline_ctx gl_ctx ) 
{ 
  char linebuf[2000] ;
  char *p ;
  char *q ;
  int lno ;
  int l ;
  int dirl ;
  struct configcommandinfo  const  *ccip ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 410
  lno = 1;
  {
#line 410
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 410
    l = (*getline___0)(ads___7, & gl_ctx, filename, lno, linebuf, (int )sizeof(linebuf));
    }
#line 410
    if (! (l != -1)) {
#line 410
      goto while_break;
    }
#line 413
    if (l == -2) {
#line 413
      goto __Cont;
    }
    {
#line 414
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 414
      if (l > 0) {
        {
#line 414
        tmp = ctype_whitespace((int )linebuf[l - 1]);
        }
#line 414
        if (! tmp) {
#line 414
          goto while_break___0;
        }
      } else {
#line 414
        goto while_break___0;
      }
#line 414
      l --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 415
    linebuf[l] = (char)0;
#line 416
    p = linebuf;
    {
#line 417
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 417
      tmp___0 = ctype_whitespace((int )*p);
      }
#line 417
      if (! tmp___0) {
#line 417
        goto while_break___1;
      }
#line 417
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 418
    if ((int )*p == 35) {
#line 418
      goto __Cont;
    } else
#line 418
    if ((int )*p == 59) {
#line 418
      goto __Cont;
    } else
#line 418
    if (! *p) {
#line 418
      goto __Cont;
    }
#line 419
    q = p;
    {
#line 420
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 420
      if (*q) {
        {
#line 420
        tmp___1 = ctype_whitespace((int )*q);
        }
#line 420
        if (tmp___1) {
#line 420
          goto while_break___2;
        }
      } else {
#line 420
        goto while_break___2;
      }
#line 420
      q ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 421
    dirl = (int )(q - p);
#line 422
    ccip = configcommandinfos___7;
    {
#line 422
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 422
      if (ccip->name) {
        {
#line 422
        tmp___2 = strlen((char const   *)ccip->name);
        }
#line 422
        if (tmp___2 == (size_t )dirl) {
          {
#line 422
          tmp___3 = memcmp((void const   *)ccip->name, (void const   *)p, (size_t )(q - p));
          }
#line 422
          if (! tmp___3) {
#line 422
            goto while_break___3;
          }
        }
      } else {
#line 422
        goto while_break___3;
      }
#line 422
      ccip ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 426
    if (! ccip->name) {
      {
#line 427
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown configuration directive `%.*s\'",
                 filename, lno, (int )(q - p), p);
      }
#line 429
      goto __Cont;
    }
    {
#line 431
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 431
      tmp___4 = ctype_whitespace((int )*q);
      }
#line 431
      if (! tmp___4) {
#line 431
        goto while_break___4;
      }
#line 431
      q ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 432
    (*(ccip->fn))(ads___7, filename, lno, (char const   *)q);
    }
    __Cont: /* CIL Label */ 
#line 410
    lno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 434
  return;
}
}
#line 436 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static char const   *instrum_getenv___7(adns_state ads___7 , char const   *envvar ) 
{ 
  char const   *value ;
  char *tmp ;

  {
  {
#line 439
  tmp = getenv(envvar);
#line 439
  value = (char const   *)tmp;
  }
#line 440
  if (! value) {
    {
#line 440
    adns__debug(ads___7, -1, (adns_query )0, "environment variable %s not set", envvar);
    }
  } else {
    {
#line 441
    adns__debug(ads___7, -1, (adns_query )0, "environment variable %s set to `%s\'",
                envvar, value);
    }
  }
#line 443
  return (value);
}
}
#line 446 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void readconfig___7(adns_state ads___7 , char const   *filename , int warnmissing ) 
{ 
  getline_ctx gl_ctx ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 449
  gl_ctx.file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 450
  if (! gl_ctx.file) {
    {
#line 451
    tmp = __errno_location();
    }
#line 451
    if (*tmp == 2) {
#line 452
      if (warnmissing) {
        {
#line 453
        adns__debug(ads___7, -1, (adns_query )0, "configuration file `%s\' does not exist",
                    filename);
        }
      }
#line 455
      return;
    }
    {
#line 457
    tmp___0 = __errno_location();
#line 457
    saveerr___7(ads___7, *tmp___0);
#line 458
    tmp___1 = __errno_location();
#line 458
    tmp___2 = strerror(*tmp___1);
#line 458
    adns__diag(ads___7, -1, (adns_query )0, "cannot open configuration file `%s\': %s",
               filename, tmp___2);
    }
#line 460
    return;
  }
  {
#line 463
  readconfiggeneric___7(ads___7, filename, & gl_file___7, gl_ctx);
#line 465
  fclose(gl_ctx.file);
  }
#line 466
  return;
}
}
#line 468 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void readconfigtext___7(adns_state ads___7 , char const   *text , char const   *showname ) 
{ 
  getline_ctx gl_ctx ;

  {
  {
#line 472
  gl_ctx.text = text;
#line 473
  readconfiggeneric___7(ads___7, showname, & gl_text___7, gl_ctx);
  }
#line 474
  return;
}
}
#line 476 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void readconfigenv___7(adns_state ads___7 , char const   *envvar ) 
{ 
  char const   *filename ;

  {
#line 479
  if ((unsigned int )ads___7->iflags & 1U) {
    {
#line 480
    adns__debug(ads___7, -1, (adns_query )0, "not checking environment variable `%s\'",
                envvar);
    }
#line 481
    return;
  }
  {
#line 483
  filename = instrum_getenv___7(ads___7, envvar);
  }
#line 484
  if (filename) {
    {
#line 484
    readconfig___7(ads___7, filename, 1);
    }
  }
#line 485
  return;
}
}
#line 487 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void readconfigenvtext___7(adns_state ads___7 , char const   *envvar ) 
{ 
  char const   *textdata ;

  {
#line 490
  if ((unsigned int )ads___7->iflags & 1U) {
    {
#line 491
    adns__debug(ads___7, -1, (adns_query )0, "not checking environment variable `%s\'",
                envvar);
    }
#line 492
    return;
  }
  {
#line 494
  textdata = instrum_getenv___7(ads___7, envvar);
  }
#line 495
  if (textdata) {
    {
#line 495
    readconfigtext___7(ads___7, textdata, envvar);
    }
  }
#line 496
  return;
}
}
#line 508 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static int init_begin___7(adns_state *ads_r , adns_initflags flags , adns_logcallbackfn *logfn ,
                          void *logfndata ) 
{ 
  adns_state ads___7 ;
  pid_t pid ;
  void *tmp ;
  int *tmp___0 ;
  adns_query tmp___1 ;
  adns_query tmp___2 ;
  adns_query tmp___3 ;
  adns_query tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __suseconds_t tmp___9 ;

  {
  {
#line 513
  tmp = malloc(sizeof(*ads___7));
#line 513
  ads___7 = (adns_state )tmp;
  }
#line 513
  if (! ads___7) {
    {
#line 513
    tmp___0 = __errno_location();
    }
#line 513
    return (*tmp___0);
  }
  {
#line 515
  ads___7->iflags = flags;
#line 516
  ads___7->logfn = logfn;
#line 517
  ads___7->logfndata = logfndata;
#line 518
  ads___7->configerrno = 0;
#line 519
  tmp___1 = (adns_query )0;
#line 519
  ads___7->udpw.tail = tmp___1;
#line 519
  ads___7->udpw.head = tmp___1;
#line 520
  tmp___2 = (adns_query )0;
#line 520
  ads___7->tcpw.tail = tmp___2;
#line 520
  ads___7->tcpw.head = tmp___2;
#line 521
  tmp___3 = (adns_query )0;
#line 521
  ads___7->childw.tail = tmp___3;
#line 521
  ads___7->childw.head = tmp___3;
#line 522
  tmp___4 = (adns_query )0;
#line 522
  ads___7->output.tail = tmp___4;
#line 522
  ads___7->output.head = tmp___4;
#line 523
  ads___7->forallnext = (adns_query )0;
#line 524
  ads___7->nextid = 12575;
#line 525
  tmp___5 = -1;
#line 525
  ads___7->tcpsocket = tmp___5;
#line 525
  ads___7->udpsocket = tmp___5;
#line 526
  adns__vbuf_init(& ads___7->tcpsend);
#line 527
  adns__vbuf_init(& ads___7->tcprecv);
#line 528
  ads___7->tcprecv_skip = 0;
#line 529
  tmp___8 = 0;
#line 529
  ads___7->tcpserver = tmp___8;
#line 529
  tmp___7 = tmp___8;
#line 529
  ads___7->nsearchlist = tmp___7;
#line 529
  tmp___6 = tmp___7;
#line 529
  ads___7->nsortlist = tmp___6;
#line 529
  ads___7->nservers = tmp___6;
#line 530
  ads___7->searchndots = 1;
#line 531
  ads___7->tcpstate = (enum adns__tcpstate )0;
#line 532
  tmp___9 = (__suseconds_t )0;
#line 532
  ads___7->tcptimeout.tv_usec = tmp___9;
#line 532
  ads___7->tcptimeout.tv_sec = tmp___9;
#line 533
  ads___7->searchlist = (char **)0;
#line 535
  pid = getpid();
#line 536
  ads___7->rand48xsubi[0] = (unsigned short )pid;
#line 537
  ads___7->rand48xsubi[1] = (unsigned short )((unsigned long )pid >> 16);
#line 538
  ads___7->rand48xsubi[2] = (unsigned short )((unsigned long )pid ^ ((unsigned long )pid >> 16));
#line 540
  *ads_r = ads___7;
  }
#line 541
  return (0);
}
}
#line 544 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static int init_finish___7(adns_state ads___7 ) 
{ 
  struct in_addr ia ;
  struct protoent *proto ;
  int r ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 549
  if (! ads___7->nservers) {
#line 550
    if (ads___7->logfn) {
#line 550
      if ((unsigned int )ads___7->iflags & 8U) {
        {
#line 551
        adns__lprintf(ads___7, "adns: no nameservers, using localhost\n");
        }
      }
    }
    {
#line 552
    ia.s_addr = htonl((in_addr_t )2130706433);
#line 553
    addserver___7(ads___7, ia);
    }
  }
  {
#line 556
  proto = getprotobyname("udp");
  }
#line 556
  if (! proto) {
#line 556
    r = 92;
#line 556
    goto x_free;
  }
  {
#line 557
  ads___7->udpsocket = socket(2, 2, proto->p_proto);
  }
#line 558
  if (ads___7->udpsocket < 0) {
    {
#line 558
    tmp = __errno_location();
#line 558
    r = *tmp;
    }
#line 558
    goto x_free;
  }
  {
#line 560
  r = adns__setnonblock(ads___7, ads___7->udpsocket);
  }
#line 561
  if (r) {
    {
#line 561
    tmp___0 = __errno_location();
#line 561
    r = *tmp___0;
    }
#line 561
    goto x_closeudp;
  }
#line 563
  return (0);
  x_closeudp: 
  {
#line 566
  close(ads___7->udpsocket);
  }
  x_free: 
  {
#line 568
  free((void *)ads___7);
  }
#line 569
  return (r);
}
}
#line 572 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void init_abort___7(adns_state ads___7 ) 
{ 


  {
#line 573
  if (ads___7->nsearchlist) {
    {
#line 574
    free((void *)*(ads___7->searchlist + 0));
#line 575
    free((void *)ads___7->searchlist);
    }
  }
  {
#line 577
  free((void *)ads___7);
  }
#line 578
  return;
}
}
#line 580 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void logfn_file___7(adns_state ads___7 , void *logfndata , char const   *fmt ,
                           va_list al ) 
{ 


  {
  {
#line 582
  vfprintf((FILE */* __restrict  */)logfndata, (char const   */* __restrict  */)fmt,
           al);
  }
#line 583
  return;
}
}
#line 585 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static int init_files___7(adns_state *ads_r , adns_initflags flags , adns_logcallbackfn *logfn ,
                          void *logfndata ) 
{ 
  adns_state ads___7 ;
  char const   *res_options ;
  char const   *adns_res_options ;
  int r ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 591
  r = init_begin___7(& ads___7, flags, logfn, logfndata);
  }
#line 592
  if (r) {
#line 592
    return (r);
  }
  {
#line 594
  res_options = instrum_getenv___7(ads___7, "RES_OPTIONS");
#line 595
  adns_res_options = instrum_getenv___7(ads___7, "ADNS_RES_OPTIONS");
#line 596
  ccf_options___7(ads___7, "RES_OPTIONS", -1, res_options);
#line 597
  ccf_options___7(ads___7, "ADNS_RES_OPTIONS", -1, adns_res_options);
#line 599
  readconfig___7(ads___7, "/etc/resolv.conf", 1);
#line 600
  readconfig___7(ads___7, "/etc/resolv-adns.conf", 0);
#line 601
  readconfigenv___7(ads___7, "RES_CONF");
#line 602
  readconfigenv___7(ads___7, "ADNS_RES_CONF");
#line 604
  readconfigenvtext___7(ads___7, "RES_CONF_TEXT");
#line 605
  readconfigenvtext___7(ads___7, "ADNS_RES_CONF_TEXT");
#line 607
  ccf_options___7(ads___7, "RES_OPTIONS", -1, res_options);
#line 608
  ccf_options___7(ads___7, "ADNS_RES_OPTIONS", -1, adns_res_options);
#line 610
  tmp = instrum_getenv___7(ads___7, "LOCALDOMAIN");
#line 610
  ccf_search___7(ads___7, "LOCALDOMAIN", -1, tmp);
#line 611
  tmp___0 = instrum_getenv___7(ads___7, "ADNS_LOCALDOMAIN");
#line 611
  ccf_search___7(ads___7, "ADNS_LOCALDOMAIN", -1, tmp___0);
  }
#line 613
  if (ads___7->configerrno) {
#line 613
    if (ads___7->configerrno != 22) {
      {
#line 614
      r = ads___7->configerrno;
#line 615
      init_abort___7(ads___7);
      }
#line 616
      return (r);
    }
  }
  {
#line 619
  r = init_finish___7(ads___7);
  }
#line 620
  if (r) {
#line 620
    return (r);
  }
  {
#line 622
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
#line 623
  *ads_r = ads___7;
  }
#line 624
  return (0);
}
}
#line 631 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static int init_strcfg___7(adns_state *ads_r , adns_initflags flags , adns_logcallbackfn *logfn ,
                           void *logfndata , char const   *configtext ) 
{ 
  adns_state ads___7 ;
  int r ;

  {
  {
#line 637
  r = init_begin___7(& ads___7, flags, logfn, logfndata);
  }
#line 638
  if (r) {
#line 638
    return (r);
  }
  {
#line 640
  readconfigtext___7(ads___7, configtext, "<supplied configuration text>");
  }
#line 641
  if (ads___7->configerrno) {
    {
#line 642
    r = ads___7->configerrno;
#line 643
    init_abort___7(ads___7);
    }
#line 644
    return (r);
  }
  {
#line 647
  r = init_finish___7(ads___7);
  }
#line 647
  if (r) {
#line 647
    return (r);
  }
  {
#line 648
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
#line 649
  *ads_r = ads___7;
  }
#line 650
  return (0);
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c"
static void tcp_close___7(adns_state ads___7 ) 
{ 
  int serv ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 48
  serv = ads___7->tcpserver;
#line 49
  close(ads___7->tcpsocket);
#line 50
  ads___7->tcpsocket = -1;
#line 51
  tmp___0 = 0;
#line 51
  ads___7->tcpsend.used = tmp___0;
#line 51
  tmp = tmp___0;
#line 51
  ads___7->tcprecv_skip = tmp;
#line 51
  ads___7->tcprecv.used = tmp;
  }
#line 52
  return;
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c"
static void tcp_connected___7(adns_state ads___7 , struct timeval now ) 
{ 
  adns_query qu ;
  adns_query nqu ;

  {
  {
#line 76
  adns__debug(ads___7, ads___7->tcpserver, (adns_query )0, "TCP connected");
#line 77
  ads___7->tcpstate = (enum adns__tcpstate )2;
#line 78
  qu = ads___7->tcpw.head;
  }
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (qu) {
#line 78
      if (! ((unsigned int )ads___7->tcpstate == 2U)) {
#line 78
        goto while_break;
      }
    } else {
#line 78
      goto while_break;
    }
#line 79
    nqu = qu->next;
#line 80
    if (! ((unsigned int )qu->state == 1U)) {
      {
#line 80
      __assert_fail("qu->state == query_tcpw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c",
                    80U, "tcp_connected");
      }
    }
    {
#line 81
    adns__querysend_tcp(qu, now);
#line 78
    qu = nqu;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c"
static void tcp_broken_events___7(adns_state ads___7 ) 
{ 
  adns_query qu ;
  adns_query nqu ;

  {
#line 88
  if (! ((unsigned int )ads___7->tcpstate == 3U)) {
    {
#line 88
    __assert_fail("ads->tcpstate == server_broken", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c",
                  88U, "tcp_broken_events");
    }
  }
#line 89
  qu = ads___7->tcpw.head;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! qu) {
#line 89
      goto while_break;
    }
#line 90
    nqu = qu->next;
#line 91
    if (! ((unsigned int )qu->state == 1U)) {
      {
#line 91
      __assert_fail("qu->state == query_tcpw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c",
                    91U, "tcp_broken_events");
      }
    }
#line 92
    if (qu->retries > ads___7->nservers) {
      {
#line 93
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 93
        if (qu->back) {
#line 93
          (qu->back)->next = qu->next;
        } else {
#line 93
          ads___7->tcpw.head = qu->next;
        }
#line 93
        if (qu->next) {
#line 93
          (qu->next)->back = qu->back;
        } else {
#line 93
          ads___7->tcpw.tail = qu->back;
        }
#line 93
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 94
      adns__query_fail(qu, (adns_status )31);
      }
    }
#line 89
    qu = nqu;
  }
  while_break: /* CIL Label */ ;
  }
#line 97
  ads___7->tcpstate = (enum adns__tcpstate )0;
#line 98
  return;
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c"
static void inter_immed___7(struct timeval **tv_io , struct timeval *tvbuf ) 
{ 
  struct timeval *rbuf ;
  __suseconds_t tmp ;

  {
#line 174
  if (! tv_io) {
#line 174
    return;
  }
#line 176
  rbuf = *tv_io;
#line 177
  if (! rbuf) {
#line 177
    rbuf = tvbuf;
#line 177
    *tv_io = rbuf;
  }
#line 179
  tmp = (__suseconds_t )0;
#line 179
  rbuf->tv_usec = tmp;
#line 179
  rbuf->tv_sec = tmp;
#line 180
  return;
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c"
static void inter_maxto___7(struct timeval **tv_io , struct timeval *tvbuf , struct timeval maxto ) 
{ 
  struct timeval *rbuf ;
  int tmp ;

  {
#line 186
  if (! tv_io) {
#line 186
    return;
  }
#line 187
  rbuf = *tv_io;
#line 188
  if (! rbuf) {
#line 189
    *tvbuf = maxto;
#line 189
    *tv_io = tvbuf;
  } else {
#line 191
    if (rbuf->tv_sec == maxto.tv_sec) {
#line 191
      tmp = rbuf->tv_usec > maxto.tv_usec;
    } else {
#line 191
      tmp = rbuf->tv_sec > maxto.tv_sec;
    }
#line 191
    if (tmp) {
#line 191
      *rbuf = maxto;
    }
  }
#line 195
  return;
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c"
static void inter_maxtoabs___7(struct timeval **tv_io , struct timeval *tvbuf , struct timeval now ,
                               struct timeval maxtime ) 
{ 
  ldiv_t dr ;

  {
#line 204
  if (! tv_io) {
#line 204
    return;
  }
  {
#line 205
  maxtime.tv_sec -= now.tv_sec + 2L;
#line 206
  maxtime.tv_usec -= now.tv_usec - 2000000L;
#line 207
  dr = ldiv(maxtime.tv_usec, 1000000L);
#line 208
  maxtime.tv_sec += dr.quot;
#line 209
  maxtime.tv_usec -= dr.quot * 1000000L;
  }
#line 210
  if (maxtime.tv_sec < 0L) {
#line 210
    maxtime.tv_usec = (__suseconds_t )0;
#line 210
    maxtime.tv_sec = maxtime.tv_usec;
  }
  {
#line 211
  inter_maxto___7(tv_io, tvbuf, maxtime);
  }
#line 212
  return;
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c"
static void timeouts_queue___7(adns_state ads___7 , int act , struct timeval **tv_io ,
                               struct timeval *tvbuf , struct timeval now , struct query_queue *queue ) 
{ 
  adns_query qu ;
  adns_query nqu ;
  int tmp ;

  {
#line 219
  qu = queue->head;
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if (! qu) {
#line 219
      goto while_break;
    }
#line 220
    nqu = qu->next;
#line 221
    if (now.tv_sec == qu->timeout.tv_sec) {
#line 221
      tmp = now.tv_usec > qu->timeout.tv_usec;
    } else {
#line 221
      tmp = now.tv_sec > qu->timeout.tv_sec;
    }
#line 221
    if (tmp) {
#line 224
      if (! act) {
        {
#line 224
        inter_immed___7(tv_io, tvbuf);
        }
#line 224
        return;
      }
      {
#line 225
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 225
        if (qu->back) {
#line 225
          (qu->back)->next = qu->next;
        } else {
#line 225
          queue->head = qu->next;
        }
#line 225
        if (qu->next) {
#line 225
          (qu->next)->back = qu->back;
        } else {
#line 225
          queue->tail = qu->back;
        }
#line 225
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 226
      if ((unsigned int )qu->state != 0U) {
        {
#line 227
        adns__query_fail(qu, (adns_status )30);
        }
      } else {
        {
#line 229
        adns__query_send(qu, now);
        }
      }
#line 231
      nqu = queue->head;
    } else {
      {
#line 222
      inter_maxtoabs___7(tv_io, tvbuf, now, qu->timeout);
      }
    }
#line 219
    qu = nqu;
  }
  while_break: /* CIL Label */ ;
  }
#line 234
  return;
}
}
#line 236 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c"
static void tcp_events___7(adns_state ads___7 , int act , struct timeval **tv_io ,
                           struct timeval *tvbuf , struct timeval now ) 
{ 
  int tmp ;

  {
  {
#line 239
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 241
    if ((unsigned int )ads___7->tcpstate == 3U) {
#line 241
      goto case_3;
    }
#line 244
    if ((unsigned int )ads___7->tcpstate == 0U) {
#line 244
      goto case_0;
    }
#line 249
    if ((unsigned int )ads___7->tcpstate == 2U) {
#line 249
      goto case_2;
    }
#line 256
    if ((unsigned int )ads___7->tcpstate == 1U) {
#line 256
      goto case_1;
    }
#line 275
    goto switch_default___0;
    case_3: /* CIL Label */ 
#line 242
    if (! act) {
      {
#line 242
      inter_immed___7(tv_io, tvbuf);
      }
#line 242
      return;
    }
    {
#line 243
    tcp_broken_events___7(ads___7);
    }
    case_0: /* CIL Label */ 
#line 245
    if (! ads___7->tcpw.head) {
#line 245
      return;
    }
#line 246
    if (! act) {
      {
#line 246
      inter_immed___7(tv_io, tvbuf);
      }
#line 246
      return;
    }
    {
#line 247
    adns__tcp_tryconnect(ads___7, now);
    }
#line 248
    goto switch_break;
    case_2: /* CIL Label */ 
#line 250
    if (ads___7->tcpw.head) {
#line 250
      return;
    }
#line 251
    if (! ads___7->tcptimeout.tv_sec) {
#line 252
      if (! (! ads___7->tcptimeout.tv_usec)) {
        {
#line 252
        __assert_fail("!ads->tcptimeout.tv_usec", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c",
                      252U, "tcp_events");
        }
      }
      {
#line 253
      ads___7->tcptimeout = now;
#line 254
      timevaladd___18(& ads___7->tcptimeout, 30000L);
      }
    }
    case_1: /* CIL Label */ 
#line 257
    if (! act) {
      {
#line 258
      inter_maxtoabs___7(tv_io, tvbuf, now, ads___7->tcptimeout);
      }
#line 259
      return;
    } else {
#line 257
      if (now.tv_sec == ads___7->tcptimeout.tv_sec) {
#line 257
        tmp = now.tv_usec > ads___7->tcptimeout.tv_usec;
      } else {
#line 257
        tmp = now.tv_sec > ads___7->tcptimeout.tv_sec;
      }
#line 257
      if (! tmp) {
        {
#line 258
        inter_maxtoabs___7(tv_io, tvbuf, now, ads___7->tcptimeout);
        }
#line 259
        return;
      }
    }
    {
#line 263
    if ((unsigned int )ads___7->tcpstate == 1U) {
#line 263
      goto case_1___0;
    }
#line 266
    if ((unsigned int )ads___7->tcpstate == 2U) {
#line 266
      goto case_2___0;
    }
#line 270
    goto switch_default;
    case_1___0: /* CIL Label */ 
    {
#line 264
    adns__tcp_broken(ads___7, "unable to make connection", "timed out");
    }
#line 265
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 267
    tcp_close___7(ads___7);
#line 268
    ads___7->tcpstate = (enum adns__tcpstate )0;
    }
#line 269
    return;
    switch_default: /* CIL Label */ 
    {
#line 271
    abort();
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 274
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
#line 276
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 279
  return;
}
}
#line 516 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c"
static void fd_event___7(adns_state ads___7 , int fd , int revent , int pollflag ,
                         int maxfd , fd_set const   *fds , int (*func)(adns_state  ,
                                                                       int fd , struct timeval  const  *now ) ,
                         struct timeval now , int *r_r ) 
{ 
  int r ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 524
  if (! (revent & pollflag)) {
#line 524
    return;
  }
#line 525
  if (fds) {
#line 525
    if (fd < maxfd) {
#line 525
      if (! ((fds->__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
#line 525
        return;
      }
    } else {
#line 525
      return;
    }
  }
  {
#line 526
  r = (*func)(ads___7, fd, (struct timeval  const  *)(& now));
  }
#line 527
  if (r) {
#line 528
    if (r_r) {
#line 529
      *r_r = r;
    } else {
      {
#line 531
      tmp = __errno_location();
#line 531
      tmp___0 = strerror(*tmp);
#line 531
      adns__diag(ads___7, -1, (adns_query )0, "process fd failed after select: %s",
                 tmp___0);
#line 533
      adns_globalsystemfailure(ads___7);
      }
    }
  }
#line 536
  return;
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c"
static void checkc_query_alloc___7(adns_state ads___7 , adns_query qu ) 
{ 
  allocnode *an ;
  int tmp ;

  {
#line 58
  if (qu->allocations.head) {
#line 58
    if (! (! (qu->allocations.head)->back)) {
      {
#line 58
      __assert_fail("! (qu->allocations).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                    59U, "checkc_query_alloc");
      }
    }
#line 58
    an = qu->allocations.head;
    {
#line 58
    while (1) {
      while_continue: /* CIL Label */ ;
#line 58
      if (! an) {
#line 58
        goto while_break;
      }
#line 58
      if (an->next) {
#line 58
        tmp = (unsigned long )an == (unsigned long )(an->next)->back;
      } else {
#line 58
        tmp = (unsigned long )an == (unsigned long )qu->allocations.tail;
      }
#line 58
      if (! tmp) {
        {
#line 58
        __assert_fail("(an)-> next ? (an) == (an)-> next-> back : (an) == (qu->allocations).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      59U, "checkc_query_alloc");
        }
      }
#line 58
      an = an->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 60
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c"
static void checkc_query___7(adns_state ads___7 , adns_query qu ) 
{ 
  adns_query child ;

  {
#line 65
  if (! (qu->udpnextserver < ads___7->nservers)) {
    {
#line 65
    __assert_fail("qu->udpnextserver < ads->nservers", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  65U, "checkc_query");
    }
  }
#line 66
  if (! (! (qu->udpsent & (0xffffffffffffffffUL << ads___7->nservers)))) {
    {
#line 66
    __assert_fail("!(qu->udpsent & (~0UL << ads->nservers))", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  66U, "checkc_query");
    }
  }
#line 67
  if (! (qu->search_pos <= ads___7->nsearchlist)) {
    {
#line 67
    __assert_fail("qu->search_pos <= ads->nsearchlist", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  67U, "checkc_query");
    }
  }
#line 68
  if (qu->parent) {
    {
#line 68
    while (1) {
      while_continue: /* CIL Label */ ;
#line 68
      child = (qu->parent)->children.head;
      {
#line 68
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 68
        if (! ((unsigned long )child != (unsigned long )qu)) {
#line 68
          goto while_break___0;
        }
#line 68
        if (! child) {
          {
#line 68
          __assert_fail("(child)", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                        68U, "checkc_query");
          }
        }
#line 68
        child = child->siblings.next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 68
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 69
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c"
static void checkc_notcpbuf___7(adns_state ads___7 ) 
{ 


  {
#line 72
  if (! (! ads___7->tcpsend.used)) {
    {
#line 72
    __assert_fail("!ads->tcpsend.used", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  72U, "checkc_notcpbuf");
    }
  }
#line 73
  if (! (! ads___7->tcprecv.used)) {
    {
#line 73
    __assert_fail("!ads->tcprecv.used", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  73U, "checkc_notcpbuf");
    }
  }
#line 74
  if (! (! ads___7->tcprecv_skip)) {
    {
#line 74
    __assert_fail("!ads->tcprecv_skip", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  74U, "checkc_notcpbuf");
    }
  }
#line 75
  return;
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c"
static void checkc_global___7(adns_state ads___7 ) 
{ 
  int i ;

  {
#line 80
  if (! (ads___7->udpsocket >= 0)) {
    {
#line 80
    __assert_fail("ads->udpsocket >= 0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  80U, "checkc_global");
    }
  }
#line 82
  i = 0;
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! (i < ads___7->nsortlist)) {
#line 82
      goto while_break;
    }
#line 83
    if (! (! (ads___7->sortlist[i].base.s_addr & ~ ads___7->sortlist[i].mask.s_addr))) {
      {
#line 83
      __assert_fail("!(ads->sortlist[i].base.s_addr & ~ads->sortlist[i].mask.s_addr)",
                    "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                    83U, "checkc_global");
      }
    }
#line 82
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  if (ads___7->tcpserver >= 0) {
#line 85
    if (! (ads___7->tcpserver < ads___7->nservers)) {
      {
#line 85
      __assert_fail("ads->tcpserver >= 0 && ads->tcpserver < ads->nservers", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                    85U, "checkc_global");
      }
    }
  } else {
    {
#line 85
    __assert_fail("ads->tcpserver >= 0 && ads->tcpserver < ads->nservers", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  85U, "checkc_global");
    }
  }
  {
#line 88
  if ((unsigned int )ads___7->tcpstate == 1U) {
#line 88
    goto case_1;
  }
#line 93
  if ((unsigned int )ads___7->tcpstate == 3U) {
#line 93
    goto case_3;
  }
#line 93
  if ((unsigned int )ads___7->tcpstate == 0U) {
#line 93
    goto case_3;
  }
#line 97
  if ((unsigned int )ads___7->tcpstate == 2U) {
#line 97
    goto case_2;
  }
#line 101
  goto switch_default;
  case_1: /* CIL Label */ 
#line 89
  if (! (ads___7->tcpsocket >= 0)) {
    {
#line 89
    __assert_fail("ads->tcpsocket >= 0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  89U, "checkc_global");
    }
  }
  {
#line 90
  checkc_notcpbuf___7(ads___7);
  }
#line 91
  goto switch_break;
  case_3: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 94
  if (! (ads___7->tcpsocket == -1)) {
    {
#line 94
    __assert_fail("ads->tcpsocket == -1", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  94U, "checkc_global");
    }
  }
  {
#line 95
  checkc_notcpbuf___7(ads___7);
  }
#line 96
  goto switch_break;
  case_2: /* CIL Label */ 
#line 98
  if (! (ads___7->tcpsocket >= 0)) {
    {
#line 98
    __assert_fail("ads->tcpsocket >= 0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  98U, "checkc_global");
    }
  }
#line 99
  if (! (ads___7->tcprecv_skip <= ads___7->tcprecv.used)) {
    {
#line 99
    __assert_fail("ads->tcprecv_skip <= ads->tcprecv.used", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  99U, "checkc_global");
    }
  }
#line 100
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 102
  __assert_fail("!\"ads->tcpstate value\"", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                102U, "checkc_global");
  }
  switch_break: /* CIL Label */ ;
  }
#line 105
  if (! ads___7->searchlist) {
#line 105
    if (! (! ads___7->nsearchlist)) {
      {
#line 105
      __assert_fail("ads->searchlist || !ads->nsearchlist", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                    105U, "checkc_global");
      }
    }
  }
#line 106
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c"
static void checkc_queue_udpw___7(adns_state ads___7 ) 
{ 
  adns_query qu ;
  int tmp ;

  {
#line 111
  if (ads___7->udpw.head) {
#line 111
    if (! (! (ads___7->udpw.head)->back)) {
      {
#line 111
      __assert_fail("! (ads->udpw).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                    118U, "checkc_queue_udpw");
      }
    }
#line 111
    qu = ads___7->udpw.head;
    {
#line 111
    while (1) {
      while_continue: /* CIL Label */ ;
#line 111
      if (! qu) {
#line 111
        goto while_break;
      }
#line 111
      if (qu->next) {
#line 111
        tmp = (unsigned long )qu == (unsigned long )(qu->next)->back;
      } else {
#line 111
        tmp = (unsigned long )qu == (unsigned long )ads___7->udpw.tail;
      }
#line 111
      if (! tmp) {
        {
#line 111
        __assert_fail("(qu)-> next ? (qu) == (qu)-> next-> back : (qu) == (ads->udpw).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! ((unsigned int )qu->state == 0U)) {
        {
#line 111
        __assert_fail("qu->state==query_tosend", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! (qu->retries <= 15)) {
        {
#line 111
        __assert_fail("qu->retries <= 15", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! qu->udpsent) {
        {
#line 111
        __assert_fail("qu->udpsent", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! qu->children.head) {
#line 111
        if (! (! qu->children.tail)) {
          {
#line 111
          __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                        118U, "checkc_queue_udpw");
          }
        }
      } else {
        {
#line 111
        __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
      {
#line 111
      checkc_query___7(ads___7, qu);
#line 111
      checkc_query_alloc___7(ads___7, qu);
#line 111
      qu = qu->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 119
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c"
static void checkc_queue_tcpw___7(adns_state ads___7 ) 
{ 
  adns_query qu ;
  int tmp ;

  {
#line 124
  if (ads___7->tcpw.head) {
#line 124
    if (! (! (ads___7->tcpw.head)->back)) {
      {
#line 124
      __assert_fail("! (ads->tcpw).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                    130U, "checkc_queue_tcpw");
      }
    }
#line 124
    qu = ads___7->tcpw.head;
    {
#line 124
    while (1) {
      while_continue: /* CIL Label */ ;
#line 124
      if (! qu) {
#line 124
        goto while_break;
      }
#line 124
      if (qu->next) {
#line 124
        tmp = (unsigned long )qu == (unsigned long )(qu->next)->back;
      } else {
#line 124
        tmp = (unsigned long )qu == (unsigned long )ads___7->tcpw.tail;
      }
#line 124
      if (! tmp) {
        {
#line 124
        __assert_fail("(qu)-> next ? (qu) == (qu)-> next-> back : (qu) == (ads->tcpw).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
#line 124
      if (! ((unsigned int )qu->state == 1U)) {
        {
#line 124
        __assert_fail("qu->state==query_tcpw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
#line 124
      if (! qu->children.head) {
#line 124
        if (! (! qu->children.tail)) {
          {
#line 124
          __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                        130U, "checkc_queue_tcpw");
          }
        }
      } else {
        {
#line 124
        __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
#line 124
      if (! (qu->retries <= ads___7->nservers + 1)) {
        {
#line 124
        __assert_fail("qu->retries <= ads->nservers+1", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
      {
#line 124
      checkc_query___7(ads___7, qu);
#line 124
      checkc_query_alloc___7(ads___7, qu);
#line 124
      qu = qu->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 131
  return;
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c"
static void checkc_queue_childw___7(adns_state ads___7 ) 
{ 
  adns_query parent ;
  adns_query child ;
  int tmp ;
  int tmp___0 ;

  {
#line 136
  if (ads___7->childw.head) {
#line 136
    if (! (! (ads___7->childw.head)->back)) {
      {
#line 136
      __assert_fail("! (ads->childw).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                    145U, "checkc_queue_childw");
      }
    }
#line 136
    parent = ads___7->childw.head;
    {
#line 136
    while (1) {
      while_continue: /* CIL Label */ ;
#line 136
      if (! parent) {
#line 136
        goto while_break;
      }
#line 136
      if (parent->next) {
#line 136
        tmp = (unsigned long )parent == (unsigned long )(parent->next)->back;
      } else {
#line 136
        tmp = (unsigned long )parent == (unsigned long )ads___7->childw.tail;
      }
#line 136
      if (! tmp) {
        {
#line 136
        __assert_fail("(parent)-> next ? (parent) == (parent)-> next-> back : (parent) == (ads->childw).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      145U, "checkc_queue_childw");
        }
      }
#line 136
      if (! ((unsigned int )parent->state == 2U)) {
        {
#line 136
        __assert_fail("parent->state == query_childw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      145U, "checkc_queue_childw");
        }
      }
#line 136
      if (! parent->children.head) {
        {
#line 136
        __assert_fail("parent->children.head", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      145U, "checkc_queue_childw");
        }
      }
#line 136
      if (parent->children.head) {
#line 136
        if (! (! (parent->children.head)->siblings.back)) {
          {
#line 136
          __assert_fail("! (parent->children).head->siblings. back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                        145U, "checkc_queue_childw");
          }
        }
#line 136
        child = parent->children.head;
        {
#line 136
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 136
          if (! child) {
#line 136
            goto while_break___0;
          }
#line 136
          if (child->siblings.next) {
#line 136
            tmp___0 = (unsigned long )child == (unsigned long )(child->siblings.next)->siblings.back;
          } else {
#line 136
            tmp___0 = (unsigned long )child == (unsigned long )parent->children.tail;
          }
#line 136
          if (! tmp___0) {
            {
#line 136
            __assert_fail("(child)->siblings. next ? (child) == (child)->siblings. next->siblings. back : (child) == (parent->children).tail",
                          "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                          145U, "checkc_queue_childw");
            }
          }
#line 136
          if (! ((unsigned long )child->parent == (unsigned long )parent)) {
            {
#line 136
            __assert_fail("child->parent == parent", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                          145U, "checkc_queue_childw");
            }
          }
#line 136
          if (! ((unsigned int )child->state != 3U)) {
            {
#line 136
            __assert_fail("child->state != query_done", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                          145U, "checkc_queue_childw");
            }
          }
#line 136
          child = child->siblings.next;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 136
      checkc_query___7(ads___7, parent);
#line 136
      checkc_query_alloc___7(ads___7, parent);
#line 136
      parent = parent->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 146
  return;
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c"
static void checkc_queue_output___7(adns_state ads___7 ) 
{ 
  adns_query qu ;
  int tmp ;

  {
#line 151
  if (ads___7->output.head) {
#line 151
    if (! (! (ads___7->output.head)->back)) {
      {
#line 151
      __assert_fail("! (ads->output).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                    157U, "checkc_queue_output");
      }
    }
#line 151
    qu = ads___7->output.head;
    {
#line 151
    while (1) {
      while_continue: /* CIL Label */ ;
#line 151
      if (! qu) {
#line 151
        goto while_break;
      }
#line 151
      if (qu->next) {
#line 151
        tmp = (unsigned long )qu == (unsigned long )(qu->next)->back;
      } else {
#line 151
        tmp = (unsigned long )qu == (unsigned long )ads___7->output.tail;
      }
#line 151
      if (! tmp) {
        {
#line 151
        __assert_fail("(qu)-> next ? (qu) == (qu)-> next-> back : (qu) == (ads->output).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! ((unsigned int )qu->state == 3U)) {
        {
#line 151
        __assert_fail("qu->state == query_done", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! qu->children.head) {
#line 151
        if (! (! qu->children.tail)) {
          {
#line 151
          __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                        157U, "checkc_queue_output");
          }
        }
      } else {
        {
#line 151
        __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! (! qu->parent)) {
        {
#line 151
        __assert_fail("!qu->parent", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! qu->allocations.head) {
#line 151
        if (! (! qu->allocations.tail)) {
          {
#line 151
          __assert_fail("!qu->allocations.head && !qu->allocations.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                        157U, "checkc_queue_output");
          }
        }
      } else {
        {
#line 151
        __assert_fail("!qu->allocations.head && !qu->allocations.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
      {
#line 151
      checkc_query___7(ads___7, qu);
#line 151
      qu = qu->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 158
  return;
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-main.c"
static int used___1  ;
#line 33 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-main.c"
static int avail___1  ;
#line 34 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-main.c"
static char *buf___7  ;
#line 82 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-main.c"
static struct typename  const  typenames___1[18]  = 
#line 82
  {      {(adns_rrtype )65538, "ns"}, 
        {(adns_rrtype )131078, "soa"}, 
        {(adns_rrtype )65548, "ptr"}, 
        {(adns_rrtype )65551, "mx"}, 
        {(adns_rrtype )131089, "rp"}, 
        {(adns_rrtype )65569, "srv"}, 
        {(adns_rrtype )65537, "addr"}, 
        {(adns_rrtype )5, "cname"}, 
        {(adns_rrtype )13, "hinfo"}, 
        {(adns_rrtype )16, "txt"}, 
        {(adns_rrtype )1, "a"}, 
        {(adns_rrtype )2, "ns-"}, 
        {(adns_rrtype )6, "soa-"}, 
        {(adns_rrtype )12, "ptr-"}, 
        {(adns_rrtype )15, "mx-"}, 
        {(adns_rrtype )17, "rp-"}, 
        {(adns_rrtype )33, "srv-"}, 
        {(adns_rrtype )0, (char const   *)0}};
#line 129 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-main.c"
static void process_optarg___1(char const   *arg , char const   * const  **argv_p ,
                               char const   *value ) 
{ 
  struct optioninfo  const  *oip ;
  char const   *arg2 ;
  int invert ;
  int tmp ;

  {
#line 136
  if ((int const   )*(arg + 0) == 45) {
#line 136
    goto _L___1;
  } else
#line 136
  if ((int const   )*(arg + 0) == 43) {
    _L___1: /* CIL Label */ 
#line 137
    if ((int const   )*(arg + 0) == 45) {
#line 137
      if ((int const   )*(arg + 1) == 45) {
        {
#line 138
        tmp = strncmp(arg, "--no-", (size_t )5);
        }
#line 138
        if (tmp) {
          {
#line 142
          invert = 0;
#line 143
          oip = opt_findl(arg + 2);
          }
        } else {
          {
#line 139
          invert = 1;
#line 140
          oip = opt_findl(arg + 5);
          }
        }
#line 145
        if ((unsigned int const   )oip->type == 5U) {
#line 146
          if (argv_p) {
#line 146
            (*argv_p) ++;
#line 146
            arg = (char const   *)*(*argv_p);
          } else {
#line 146
            arg = value;
          }
#line 147
          if (! arg) {
            {
#line 147
            usageerr("option --%s requires a value argument", oip->lopt);
            }
          }
#line 148
          arg2 = (char const   *)0;
        } else
#line 149
        if ((unsigned int const   )oip->type == 6U) {
#line 150
          if (! argv_p) {
            {
#line 150
            __assert_fail("argv_p", "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-main.c",
                          150U, "process_optarg");
            }
          }
#line 151
          (*argv_p) ++;
#line 151
          arg = (char const   *)*(*argv_p);
#line 152
          if (arg) {
#line 152
            (*argv_p) ++;
#line 152
            arg2 = (char const   *)*(*argv_p);
          } else {
#line 152
            arg2 = (char const   *)0;
          }
#line 153
          if (! arg) {
            {
#line 154
            usageerr("option --%s requires two more arguments", oip->lopt);
            }
          } else
#line 153
          if (! arg2) {
            {
#line 154
            usageerr("option --%s requires two more arguments", oip->lopt);
            }
          }
        } else {
#line 156
          if (value) {
            {
#line 156
            usageerr("option --%s does not take a value", oip->lopt);
            }
          }
#line 157
          arg = (char const   *)0;
#line 158
          arg2 = (char const   *)0;
        }
        {
#line 160
        opt_do(oip, invert, arg, arg2);
        }
      } else {
#line 137
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 161
    if ((int const   )*(arg + 0) == 45) {
#line 161
      if ((int const   )*(arg + 1) == 0) {
#line 162
        if (argv_p) {
#line 162
          (*argv_p) ++;
#line 162
          arg = (char const   *)*(*argv_p);
        } else {
#line 162
          arg = value;
        }
#line 163
        if (! arg) {
          {
#line 163
          usageerr("option `-\' must be followed by a domain");
          }
        }
        {
#line 164
        query_do(arg);
        }
      } else {
#line 161
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 166
      invert = (int const   )*(arg + 0) == 43;
#line 167
      arg ++;
      {
#line 168
      while (1) {
        while_continue: /* CIL Label */ ;
#line 168
        if (! *arg) {
#line 168
          goto while_break;
        }
        {
#line 169
        oip = opt_finds(& arg);
        }
#line 170
        if ((unsigned int const   )oip->type == 5U) {
#line 171
          if (! *arg) {
#line 172
            if (argv_p) {
#line 172
              (*argv_p) ++;
#line 172
              arg = (char const   *)*(*argv_p);
            } else {
#line 172
              arg = value;
            }
#line 173
            if (! arg) {
              {
#line 173
              usageerr("option -%s requires a value argument", oip->sopt);
              }
            }
          } else
#line 175
          if (value) {
            {
#line 175
            usageerr("two values for option -%s given !", oip->sopt);
            }
          }
          {
#line 177
          opt_do(oip, invert, arg, (char const   *)0);
#line 178
          arg = "";
          }
        } else {
#line 180
          if (value) {
            {
#line 180
            usageerr("option -%s does not take a value", oip->sopt);
            }
          }
          {
#line 181
          opt_do(oip, invert, (char const   *)0, (char const   *)0);
          }
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 186
    query_do(arg);
    }
  }
#line 188
  return;
}
}
#line 190 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-main.c"
static void read_stdin___1(void) 
{ 
  int anydone ;
  int r ;
  char *newline ;
  char *space ;
  void *tmp ;
  int *tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 194
  anydone = 0;
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 195
    if (! (! anydone)) {
#line 195
      if (! used___1) {
#line 195
        goto while_break;
      }
    }
    {
#line 196
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 196
      tmp___5 = memchr((void const   *)buf___7, '\n', (size_t )used___1);
#line 196
      newline = (char *)tmp___5;
      }
#line 196
      if (newline) {
#line 196
        goto while_break___0;
      }
#line 197
      if (used___1 == avail___1) {
        {
#line 198
        avail___1 += 20;
#line 198
        avail___1 <<= 1;
#line 199
        tmp = realloc((void *)buf___7, (size_t )avail___1);
#line 199
        buf___7 = (char *)tmp;
        }
#line 200
        if (! buf___7) {
          {
#line 200
          tmp___0 = __errno_location();
#line 200
          sysfail("realloc stdin buffer", *tmp___0);
          }
        }
      }
      {
#line 202
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 203
        tmp___1 = read(0, (void *)(buf___7 + used___1), (size_t )(avail___1 - used___1));
#line 203
        r = (int )tmp___1;
        }
#line 202
        if (r < 0) {
          {
#line 202
          tmp___2 = __errno_location();
          }
#line 202
          if (! (*tmp___2 == 4)) {
#line 202
            goto while_break___1;
          }
        } else {
#line 202
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 205
      if (r == 0) {
#line 206
        if (used___1) {
#line 208
          tmp___3 = used___1;
#line 208
          used___1 ++;
#line 208
          *(buf___7 + tmp___3) = (char )'\n';
#line 209
          r = 1;
        } else {
#line 211
          ov_pipe = 0;
#line 212
          return;
        }
      }
#line 215
      if (r < 0) {
        {
#line 215
        tmp___4 = __errno_location();
#line 215
        sysfail("read stdin", *tmp___4);
        }
      }
#line 216
      used___1 += r;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 218
    tmp___6 = newline;
#line 218
    newline ++;
#line 218
    *tmp___6 = (char)0;
#line 219
    space = strchr((char const   *)buf___7, ' ');
    }
#line 220
    if (space) {
#line 220
      tmp___7 = space;
#line 220
      space ++;
#line 220
      *tmp___7 = (char)0;
    }
    {
#line 221
    process_optarg___1((char const   *)buf___7, (char const   * const  **)0, (char const   *)space);
#line 222
    used___1 = (int )((long )used___1 - (newline - buf___7));
#line 223
    memmove((void *)buf___7, (void const   *)newline, (size_t )used___1);
#line 224
    anydone = 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 226
  return;
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-opts.c"
static struct optioninfo  const  global_options___1[17]  = 
#line 38 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-opts.c"
  {      {(enum oi_type )1, "global binary options:", (char const   *)0, (char const   *)0,
      (int *)0, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )2, "Do not look at environment variables at all", "e", "env",
      & ov_env, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )2, "Read queries on stdin instead of using args", "f", "pipe",
      & ov_pipe, 1, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )2, "Allow answers to be reordered", "a", "asynch", & ov_asynch,
      1, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )1, "answer/error output format and destination (see below):",
      (char const   *)0, (char const   *)0, (int *)0, 0, (optfunc *)0, (char const   *)0,
      (char const   *)0}, 
        {(enum oi_type )3, "Answers to stdout, errors as messages to stderr (default)",
      "Fs", "fmt-simple", & ov_format, 1, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )3,
      "Answers and errors both to stdout in parseable format", "Fi", "fmt-inline",
      & ov_format, 2, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )3, "Fully-parseable output format (default for --asynch)", "Fa",
      "fmt-asynch", & ov_format, 3, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )1,
      "global verbosity level:", (char const   *)0, (char const   *)0, (int *)0, 0,
      (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )3, "Do not print anything to stderr", "Vq", "quiet", & ov_verbose,
      2, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )3, "Report unexpected kinds of problem only  (default)", "Vn",
      "no-quiet", & ov_verbose, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )3,
      "Debugging mode", "Vd", "debug", & ov_verbose, 8, (optfunc *)0, (char const   *)0,
      (char const   *)0}, 
        {(enum oi_type )1, "other global options:", (char const   *)0, (char const   *)0,
      (int *)0, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )5, "Configuration to use instead of /etc/resolv.conf", (char const   *)0,
      "config", (int *)0, 0, & of_config, "<config-text>", (char const   *)0}, 
        {(enum oi_type )4, "Print version number", (char const   *)0, "version", (int *)0,
      0, & of_version, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )4, "Print usage information", (char const   *)0, "help", (int *)0,
      0, & of_help, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )0, (char const   *)0, (char const   *)0, (char const   *)0, (int *)0,
      0, (optfunc *)0, (char const   *)0, (char const   *)0}};
#line 74 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-opts.c"
static struct optioninfo  const  perquery_options___1[25]  = 
#line 74
  {      {(enum oi_type )1, "per-query options:", (char const   *)0, (char const   *)0,
      (int *)0, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )5, "Query type (see below)", "t", "type", (int *)0, 0, & of_type,
      "type", (char const   *)0}, 
        {(enum oi_type )5, "Do reverse query (address -> name lookup)", "i", "ptr", (int *)0,
      0, & of_ptr, "addr", (char const   *)0}, 
        {(enum oi_type )6, "Lookup in in-addr-like `zone\' (eg MAPS RBL)", (char const   *)0,
      "reverse", (int *)0, 0, & of_reverse, "addr", "zone"}, 
        {(enum oi_type )1, "per-query binary options:", (char const   *)0, (char const   *)0,
      (int *)0, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )2, "Use the search list", "s", "search", & ov_search, 1, (optfunc *)0,
      (char const   *)0, (char const   *)0}, 
        {(enum oi_type )2, "Let query domains contain quote-requiring chars", "Qq", "qc-query",
      & ov_qc_query, 1, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )2, "Let hostnames in answers contain ...", "Qa", "qc-anshost",
      & ov_qc_anshost, 1, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )2, "Prevent CNAME target domains from containing ...", "Qc",
      "qc-cname", & ov_qc_cname, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )2,
      "Force use of a virtual circuit", "u", "tcp", & ov_tcp, 1, (optfunc *)0, (char const   *)0,
      (char const   *)0}, 
        {(enum oi_type )2, "Do not display owner name in output", "Do", "show-owner",
      & ov_pqfr.show_owner, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )2,
      "Do not display RR type in output", "Dt", "show-type", & ov_pqfr.show_type,
      0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )2, "Do not display CNAME target in output", "Dc", "show-cname",
      & ov_pqfr.show_cname, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )1,
      "per-query TTL mode (NB TTL is minimum across all info in reply):", (char const   *)0,
      (char const   *)0, (int *)0, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )3,
      "Show the TTL as a TTL", "Tt", "ttl-ttl", & ov_pqfr.ttl, 1, (optfunc *)0, (char const   *)0,
      (char const   *)0}, 
        {(enum oi_type )3, "Show the TTL as a time_t when the data might expire", "Ta",
      "ttl-abs", & ov_pqfr.ttl, 2, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )3,
      "Do not show the TTL (default)", "Tn", "no-ttl", & ov_pqfr.ttl, 0, (optfunc *)0,
      (char const   *)0, (char const   *)0}, 
        {(enum oi_type )1, "per-query CNAME handling mode:", (char const   *)0, (char const   *)0,
      (int *)0, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )3, "Call it an error if a CNAME is found", "Cf", "cname-reject",
      & ov_cname, 512, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )3, "Allow references to CNAMEs in other RRs", "Cl", "cname-loose",
      & ov_cname, 256, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )3, "CNAME ok for query domain, but not in RRs (default)", "Cs",
      "cname-ok", & ov_cname, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )1,
      "asynchronous/pipe mode options:", (char const   *)0, (char const   *)0, (int *)0,
      0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )5, "Set <id>, default is decimal sequence starting 0", (char const   *)0,
      "asynch-id", (int *)0, 0, & of_asynch_id, "id", (char const   *)0}, 
        {(enum oi_type )5, "Cancel the query with id <id> (no error if not found)", (char const   *)0,
      "cancel-id", (int *)0, 0, & of_cancel_id, "id", (char const   *)0}, 
        {(enum oi_type )0, (char const   *)0, (char const   *)0, (char const   *)0, (int *)0,
      0, (optfunc *)0, (char const   *)0, (char const   *)0}};
#line 127
static void printusage___1(void) ;
#line 127 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-opts.c"
static struct optioninfo  const  * const  all_optiontables___1[3]  = {      (struct optioninfo  const  */* const  */)(global_options___1),      (struct optioninfo  const  */* const  */)(perquery_options___1),      (struct optioninfo  const  */* const  */)0};
#line 126 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-opts.c"
static void printusage___1(void) 
{ 
  struct optioninfo  const  * const  *oiap ;
  struct optioninfo  const  *oip ;
  int maxsopt ;
  int maxlopt ;
  int l ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  int tmp___13 ;

  {
#line 131
  oip = (struct optioninfo  const  *)0;
#line 134
  maxlopt = 0;
#line 134
  maxsopt = maxlopt;
#line 136
  oiap = all_optiontables___1;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (! *oiap) {
#line 136
      goto while_break;
    }
#line 137
    oip = (struct optioninfo  const  *)*oiap;
    {
#line 137
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 137
      if (! ((unsigned int const   )oip->type != 0U)) {
#line 137
        goto while_break___0;
      }
#line 138
      if ((unsigned int const   )oip->type == 5U) {
#line 138
        goto __Cont;
      }
#line 139
      if (oip->sopt) {
        {
#line 139
        tmp = strlen((char const   *)oip->sopt);
#line 139
        l = (int )tmp;
        }
#line 139
        if (l > maxsopt) {
#line 139
          maxsopt = l;
        }
      }
#line 140
      if (oip->lopt) {
        {
#line 141
        tmp___0 = strlen((char const   *)oip->lopt);
#line 141
        l = (int )tmp___0;
        }
#line 142
        if ((unsigned int const   )oip->type == 2U) {
#line 142
          if (! oip->value) {
#line 142
            l += 3;
          }
        }
#line 143
        if (l > maxlopt) {
#line 143
          maxlopt = l;
        }
      }
      __Cont: /* CIL Label */ 
#line 137
      oip ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 136
    oiap ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 148
  fputs((char const   */* __restrict  */)"usage: adnshost [global-opts] [query-opts] query-domain\n                             [[query-opts] query-domain ...]\n       adnshost [global-opts] [query-opts] -f|--pipe\n",
        (FILE */* __restrict  */)stdout);
#line 153
  oiap = all_optiontables___1;
  }
  {
#line 153
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 153
    if (! *oiap) {
#line 153
      goto while_break___1;
    }
    {
#line 154
    putchar('\n');
#line 155
    oip = (struct optioninfo  const  *)*oiap;
    }
    {
#line 155
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 155
      if (! ((unsigned int const   )oip->type != 0U)) {
#line 155
        goto while_break___2;
      }
      {
#line 157
      if ((unsigned int const   )oip->type == 2U) {
#line 157
        goto case_2;
      }
#line 171
      if ((unsigned int const   )oip->type == 4U) {
#line 171
        goto case_4;
      }
#line 171
      if ((unsigned int const   )oip->type == 3U) {
#line 171
        goto case_4;
      }
#line 183
      if ((unsigned int const   )oip->type == 5U) {
#line 183
        goto case_5;
      }
#line 200
      if ((unsigned int const   )oip->type == 6U) {
#line 200
        goto case_6;
      }
#line 209
      if ((unsigned int const   )oip->type == 1U) {
#line 209
        goto case_1;
      }
#line 212
      goto switch_default;
      case_2: /* CIL Label */ 
#line 158
      if (! oip->value) {
#line 159
        if (oip->sopt) {
          {
#line 160
          printf((char const   */* __restrict  */)" +%-*s --no-%-*s %s\n", maxsopt,
                 oip->sopt, maxlopt - 2, oip->lopt, oip->desc);
          }
        } else {
          {
#line 165
          printf((char const   */* __restrict  */)" --no-%-*s %s\n", (maxlopt + maxsopt) + 1,
                 oip->lopt, oip->desc);
          }
        }
#line 169
        goto switch_break;
      }
      case_4: /* CIL Label */ 
      case_3: /* CIL Label */ 
#line 172
      if (oip->sopt) {
        {
#line 173
        printf((char const   */* __restrict  */)" -%-*s --%-*s %s\n", maxsopt, oip->sopt,
               maxlopt + 1, oip->lopt, oip->desc);
        }
      } else {
        {
#line 178
        printf((char const   */* __restrict  */)" --%-*s %s\n", (maxlopt + maxsopt) + 3,
               oip->lopt, oip->desc);
        }
      }
#line 182
      goto switch_break;
      case_5: /* CIL Label */ 
#line 184
      if (oip->sopt) {
        {
#line 185
        tmp___1 = strlen((char const   *)oip->sopt);
#line 185
        tmp___2 = strlen((char const   *)oip->lopt);
#line 185
        tmp___3 = strlen((char const   *)oip->argdesc);
#line 185
        l = (int )((size_t )((maxlopt + maxsopt) - 9) - ((tmp___1 + tmp___2) + 2UL * tmp___3));
        }
#line 187
        if (l > 2) {
#line 187
          tmp___4 = l;
        } else {
#line 187
          tmp___4 = 2;
        }
        {
#line 187
        printf((char const   */* __restrict  */)" -%s<%s> / --%s <%s>%*s%s\n", oip->sopt,
               oip->argdesc, oip->lopt, oip->argdesc, tmp___4, "", oip->desc);
        }
      } else {
        {
#line 192
        tmp___5 = strlen((char const   *)oip->lopt);
#line 192
        tmp___6 = strlen((char const   *)oip->argdesc);
#line 192
        l = (int )((size_t )((maxlopt + maxsopt) + 1) - (tmp___5 + tmp___6));
        }
#line 194
        if (l > 2) {
#line 194
          tmp___7 = l;
        } else {
#line 194
          tmp___7 = 2;
        }
        {
#line 194
        printf((char const   */* __restrict  */)" --%s <%s>%*s%s\n", oip->lopt, oip->argdesc,
               tmp___7, "", oip->desc);
        }
      }
#line 199
      goto switch_break;
      case_6: /* CIL Label */ 
#line 201
      if (! (! oip->sopt)) {
        {
#line 201
        __assert_fail("!oip->sopt", "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-opts.c",
                      201U, "printusage");
        }
      }
      {
#line 202
      tmp___8 = strlen((char const   *)oip->lopt);
#line 202
      tmp___9 = strlen((char const   *)oip->argdesc);
#line 202
      tmp___10 = strlen((char const   *)oip->argdesc2);
#line 202
      l = (int )((size_t )((maxlopt + maxsopt) - 2) - ((tmp___8 + tmp___9) + tmp___10));
      }
#line 204
      if (l > 2) {
#line 204
        tmp___11 = l;
      } else {
#line 204
        tmp___11 = 2;
      }
      {
#line 204
      printf((char const   */* __restrict  */)" --%s <%s> <%s>%*s%s\n", oip->lopt,
             oip->argdesc, oip->argdesc2, tmp___11, "", oip->desc);
      }
#line 208
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 210
      printf((char const   */* __restrict  */)"%s\n", oip->desc);
      }
#line 211
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 213
      abort();
      }
      switch_break: /* CIL Label */ ;
      }
#line 155
      oip ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 153
    oiap ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 218
  printf((char const   */* __restrict  */)"\nEscaping domains which might start with `-\':\n - %-*s Next argument is a domain, but more options may follow\n",
         (maxlopt + maxsopt) + 3, "<domain>");
#line 222
  fputs((char const   */* __restrict  */)"\nQuery domains should always be quoted according to master file format.\n\nFor binary options, --FOO and --no-FOO are opposites, as are\n-X and +X.  In each case the default is the one not listed.\nPer query options stay set a particular way until they are reset,\nwhether they appear on the command line or on stdin.\nAll global options must preceed the first query domain.\n\nWith -f, the input should be lines with either an option, possibly\nwith a value argument (separated from the option by a space if it\'s a long\noption), or a domain (possibly preceded by a hyphen and a space to\ndistinguish it from an option).\n\nOutput format is master file format without class or TTL by default:\n   [<owner>] [<ttl>] [<type>] <data>\nor if the <owner> domain refers to a CNAME and --show-cname is on\n   [<owner>] [<ttl>] CNAME <cname>\n   [<cname>] [<ttl>] <type> <data>\nWhen a query fails you get an error message to stderr (with --fmt-simple).\nSpecify --fmt-inline for lines like this (broken here for readability):\n   ; failed <statustype> <statusnum> <statusabbrev> \\\n       [<owner>] [<ttl>] [<cname>] \"<status string>\"\nIf you use --fmt-asynch, which is the default for --asynch,\neach answer (success or failure) is preceded by a line\n   <id> <nrrs> <statustype> <statusnum> <statusabbrev> \\\n       [<owner>] [<ttl>] [<cname>] \"<status string>\"\nwhere <nrrs> is the number of RRs that follow and <cname> will be `$\' or\nthe CNAME target; the CNAME indirection and error formats above are not used.\n\nExit status:\n 0    all went well\n 1-6  at least one query failed with statustype:\n   1    localfail   )\n   2    remotefail  ) temporary errors\n   3    tempfail  __)_________________\n   4    misconfig   )\n   5    misquery    ) permanent errors\n   6    permfail    )\n 10   system trouble\n 11   usage problems\n\nQuery types (see adns.h; default is addr):\n  ns  soa  ptr  mx  rp  srv  addr       - enhanced versions\n  cname  hinfo  txt                     - types with only one version\n  a  ns-  soa-  ptr-  mx-  rp-  srv-    - _raw versions\n  type<number>                          - `unknown\' type, RFC3597\nDefault is addr, or ptr for -i/--ptr queries\n",
        (FILE */* __restrict  */)stdout);
#line 271
  tmp___13 = ferror(stdout);
  }
#line 271
  if (tmp___13) {
    {
#line 271
    tmp___12 = __errno_location();
#line 271
    sysfail("write usage message", *tmp___12);
    }
  }
#line 272
  return;
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-opts.c"
static int oc_long___1(char const   **optp , struct optioninfo  const  *entry ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 287
  if (entry->lopt) {
    {
#line 287
    tmp = strcmp(*optp, (char const   *)entry->lopt);
    }
#line 287
    if (tmp) {
#line 287
      tmp___0 = 0;
    } else {
#line 287
      tmp___0 = 1;
    }
  } else {
#line 287
    tmp___0 = 0;
  }
#line 287
  return (tmp___0);
}
}
#line 290 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-opts.c"
static int oc_short___1(char const   **optp , struct optioninfo  const  *entry ) 
{ 
  char const   *sopt ;
  int l ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 294
  sopt = (char const   *)entry->sopt;
#line 295
  if (! sopt) {
#line 295
    return (0);
  }
  {
#line 296
  tmp = strlen(sopt);
#line 296
  l = (int )tmp;
#line 297
  tmp___0 = memcmp((void const   *)*optp, (void const   *)sopt, (size_t )l);
  }
#line 297
  if (tmp___0) {
#line 297
    return (0);
  }
#line 298
  *optp += l;
#line 299
  return (1);
}
}
#line 302 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-opts.c"
static struct optioninfo  const  *find1___1(char const   **optp , struct optioninfo  const  *table ,
                                            comparer_type *comparer___3 ) 
{ 
  int tmp ;

  {
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;
#line 306
    if ((unsigned int const   )table->type == 0U) {
#line 306
      return ((struct optioninfo  const  *)0);
    }
    {
#line 307
    tmp = (*comparer___3)(optp, table);
    }
#line 307
    if (tmp) {
#line 307
      return (table);
    }
#line 308
    table ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-opts.c"
static struct optioninfo  const  *find___1(char const   **optp , char const   *prefix ,
                                           comparer_type *comparer___3 ) 
{ 
  struct optioninfo  const  *oip ;
  char const   *opt ;

  {
  {
#line 318
  opt = *optp;
#line 319
  oip = find1___1(optp, perquery_options___1, comparer___3);
  }
#line 320
  if (oip) {
#line 320
    return (oip);
  }
  {
#line 321
  oip = find1___1(optp, global_options___1, comparer___3);
  }
#line 322
  if (! oip) {
    {
#line 322
    usageerr("unknown option %s%s", prefix, opt);
    }
  }
#line 323
  if (ads) {
    {
#line 323
    usageerr("global option %s%s specified after query domain(s)", prefix, opt);
    }
  }
#line 324
  return (oip);
}
}
#line 330
static  __attribute__((__noreturn__)) void noninvert___1(struct optioninfo  const  *oip ) ;
#line 331
static  __attribute__((__noreturn__)) void noninvert___1(struct optioninfo  const  *oip ) ;
#line 331 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-opts.c"
static void noninvert___1(struct optioninfo  const  *oip ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 332
  if (oip->lopt) {
#line 332
    tmp = oip->lopt;
  } else {
#line 332
    tmp = (char const   */* const  */)"";
  }
#line 332
  if (oip->lopt) {
#line 332
    tmp___0 = "--";
  } else {
#line 332
    tmp___0 = "";
  }
#line 332
  if (oip->lopt) {
#line 332
    if (oip->sopt) {
#line 332
      tmp___1 = " / ";
    } else {
#line 332
      tmp___1 = "";
    }
  } else {
#line 332
    tmp___1 = "";
  }
#line 332
  if (oip->sopt) {
#line 332
    tmp___2 = oip->sopt;
  } else {
#line 332
    tmp___2 = (char const   */* const  */)"";
  }
#line 332
  if (oip->sopt) {
#line 332
    tmp___3 = "-";
  } else {
#line 332
    tmp___3 = "";
  }
  {
#line 332
  usageerr("option %s%s%s%s%s may not be inverted", tmp___3, tmp___2, tmp___1, tmp___0,
           tmp);
  }
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-query.c"
static unsigned long idcounter___1  ;
#line 59 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-query.c"
static char buf___8[12]  ;
#line 71 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-query.c"
static void prep_query___1(struct query_node **qun_r , int *quflags_r ) 
{ 
  struct query_node *qun ;
  char idbuf[20] ;
  void *tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 75
  if (ov_pipe) {
#line 75
    if (! ads) {
      {
#line 75
      usageerr("-f/--pipe not consistent with domains on command line");
      }
    }
  }
  {
#line 76
  ensure_adns_init();
#line 78
  tmp = malloc(sizeof(*qun));
#line 78
  qun = (struct query_node *)tmp;
#line 79
  qun->pqfr = ov_pqfr;
  }
#line 80
  if (ov_id) {
    {
#line 81
    qun->id = xstrsave((char const   *)ov_id);
    }
  } else {
    {
#line 83
    tmp___0 = idcounter___1;
#line 83
    idcounter___1 ++;
#line 83
    sprintf((char */* __restrict  */)(idbuf), (char const   */* __restrict  */)"%lu",
            tmp___0);
#line 84
    idcounter___1 &= 4294967295UL;
#line 85
    qun->id = xstrsave((char const   *)(idbuf));
    }
  }
#line 88
  if (ov_search) {
#line 88
    tmp___1 = 1;
  } else {
#line 88
    tmp___1 = 0;
  }
#line 88
  if (ov_tcp) {
#line 88
    tmp___2 = 2;
  } else {
#line 88
    tmp___2 = 0;
  }
#line 88
  if (ov_pqfr.show_owner) {
#line 88
    tmp___3 = 4;
  } else
#line 88
  if (ov_format == 1) {
#line 88
    tmp___3 = 4;
  } else {
#line 88
    tmp___3 = 0;
  }
#line 88
  if (ov_qc_query) {
#line 88
    tmp___4 = 16;
  } else {
#line 88
    tmp___4 = 0;
  }
#line 88
  if (ov_qc_anshost) {
#line 88
    tmp___5 = 64;
  } else {
#line 88
    tmp___5 = 0;
  }
#line 88
  if (ov_qc_cname) {
#line 88
    tmp___6 = 0;
  } else {
#line 88
    tmp___6 = 0;
  }
#line 88
  *quflags_r = (((((tmp___1 | tmp___2) | tmp___3) | tmp___4) | tmp___5) | tmp___6) | ov_cname;
#line 88
  *qun_r = qun;
#line 98
  return;
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-query.c"
static void dequeue_query___1(struct query_node *qun ) 
{ 


  {
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 162
    if (qun->back) {
#line 162
      (qun->back)->next = qun->next;
    } else {
#line 162
      outstanding.head = qun->next;
    }
#line 162
    if (qun->next) {
#line 162
      (qun->next)->back = qun->back;
    } else {
#line 162
      outstanding.tail = qun->back;
    }
#line 162
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 163
  free((void *)qun->id);
#line 164
  free((void *)qun->owner);
#line 165
  free((void *)qun);
  }
#line 166
  return;
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-query.c"
static void print_withspace___1(char const   *str ) 
{ 
  int tmp ;

  {
  {
#line 169
  tmp = printf((char const   */* __restrict  */)"%s ", str);
  }
#line 169
  if (tmp == -1) {
    {
#line 169
    outerr();
    }
  }
#line 170
  return;
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-query.c"
static void print_ttl___1(struct query_node *qun , adns_answer *answer ) 
{ 
  unsigned long ttl ;
  time_t now ;
  int *tmp ;
  time_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 177
  if (qun->pqfr.ttl == 0) {
#line 177
    goto case_0;
  }
#line 179
  if (qun->pqfr.ttl == 1) {
#line 179
    goto case_1;
  }
#line 183
  if (qun->pqfr.ttl == 2) {
#line 183
    goto case_2;
  }
#line 186
  goto switch_default;
  case_0: /* CIL Label */ 
#line 178
  return;
  case_1: /* CIL Label */ 
  {
#line 180
  tmp___0 = time(& now);
  }
#line 180
  if (tmp___0 == -1L) {
    {
#line 180
    tmp = __errno_location();
#line 180
    sysfail("get current time", *tmp);
    }
  }
#line 181
  if (answer->expires < now) {
#line 181
    ttl = 0UL;
  } else {
#line 181
    ttl = (unsigned long )(answer->expires - now);
  }
#line 182
  goto switch_break;
  case_2: /* CIL Label */ 
#line 184
  ttl = (unsigned long )answer->expires;
#line 185
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 187
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 189
  tmp___1 = printf((char const   */* __restrict  */)"%lu ", ttl);
  }
#line 189
  if (tmp___1 == -1) {
    {
#line 189
    outerr();
    }
  }
#line 190
  return;
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-query.c"
static char const   *owner_show___1(struct query_node *qun , adns_answer *answer ) 
{ 
  char *tmp ;

  {
#line 193
  if (answer->owner) {
#line 193
    tmp = answer->owner;
  } else {
#line 193
    tmp = qun->owner;
  }
#line 193
  return ((char const   *)tmp);
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-query.c"
static void print_owner_ttl___1(struct query_node *qun , adns_answer *answer ) 
{ 
  char const   *tmp ;

  {
#line 197
  if (qun->pqfr.show_owner) {
    {
#line 197
    tmp = owner_show___1(qun, answer);
#line 197
    print_withspace___1(tmp);
    }
  }
  {
#line 198
  print_ttl___1(qun, answer);
  }
#line 199
  return;
}
}
#line 202
static void check_status___1(adns_status st ) ;
#line 202 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-query.c"
static adns_status const   statuspoints___1[6]  = {      (adns_status const   )0,      (adns_status const   )29,      (adns_status const   )59,      (adns_status const   )99, 
        (adns_status const   )199,      (adns_status const   )299};
#line 201 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-query.c"
static void check_status___1(adns_status st ) 
{ 
  adns_status const   *spp ;
  int minrcode ;

  {
#line 211
  minrcode = 0;
#line 211
  spp = statuspoints___1;
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 211
    if (! ((unsigned long )spp < (unsigned long )(statuspoints___1 + sizeof(statuspoints___1) / sizeof(statuspoints___1[0])))) {
#line 211
      goto while_break;
    }
#line 214
    if ((unsigned int )st > (unsigned int )*spp) {
#line 214
      minrcode ++;
    }
#line 211
    spp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 215
  if (rcode < minrcode) {
#line 215
    rcode = minrcode;
  }
#line 216
  return;
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-query.c"
static void print_status___1(adns_status st , struct query_node *qun , adns_answer *answer ) 
{ 
  char const   *statustypeabbrev ;
  char const   *statusabbrev ;
  char const   *statusstring ;
  char *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 221
  statustypeabbrev = adns_errtypeabbrev(st);
#line 222
  statusabbrev = adns_errabbrev(st);
#line 223
  statusstring = adns_strerror(st);
#line 224
  tmp = strchr(statusstring, '\"');
  }
#line 224
  if (tmp) {
    {
#line 224
    __assert_fail("!strchr(statusstring,\'\"\')", "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-query.c",
                  224U, "print_status");
    }
  }
  {
#line 226
  tmp___0 = printf((char const   */* __restrict  */)"%s %d %s ", statustypeabbrev,
                   (unsigned int )st, statusabbrev);
  }
#line 226
  if (tmp___0 == -1) {
    {
#line 227
    outerr();
    }
  }
  {
#line 228
  print_owner_ttl___1(qun, answer);
  }
#line 229
  if (qun->pqfr.show_cname) {
#line 230
    if (answer->cname) {
#line 230
      tmp___1 = (char const   *)answer->cname;
    } else {
#line 230
      tmp___1 = "$";
    }
    {
#line 230
    print_withspace___1(tmp___1);
    }
  }
  {
#line 231
  tmp___2 = printf((char const   */* __restrict  */)"\"%s\"\n", statusstring);
  }
#line 231
  if (tmp___2 == -1) {
    {
#line 231
    outerr();
    }
  }
#line 232
  return;
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-query.c"
static void print_dnsfail___1(adns_status st , struct query_node *qun , adns_answer *answer ) 
{ 
  int r ;
  char const   *typename ;
  char const   *statusstring ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int *tmp___3 ;

  {
#line 238
  if (ov_format == 2) {
    {
#line 239
    tmp = fputs((char const   */* __restrict  */)"; failed ", (FILE */* __restrict  */)stdout);
    }
#line 239
    if (tmp == -1) {
      {
#line 239
      outerr();
      }
    }
    {
#line 240
    print_status___1(st, qun, answer);
    }
#line 241
    return;
  }
#line 243
  if (! (ov_format == 1)) {
    {
#line 243
    __assert_fail("ov_format == fmt_simple", "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-query.c",
                  243U, "print_dnsfail");
    }
  }
#line 244
  if ((unsigned int )st == 300U) {
    {
#line 245
    tmp___0 = owner_show___1(qun, answer);
#line 245
    r = fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s does not exist\n",
                tmp___0);
    }
  } else {
    {
#line 247
    type_info(answer->type, & typename, (void const   *)0, (char **)0);
    }
#line 248
    if ((unsigned int )st == 301U) {
      {
#line 249
      tmp___1 = owner_show___1(qun, answer);
#line 249
      r = fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s has no %s record\n",
                  tmp___1, typename);
      }
    } else {
      {
#line 251
      statusstring = adns_strerror(st);
#line 252
      tmp___2 = owner_show___1(qun, answer);
#line 252
      r = fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error during DNS %s lookup for %s: %s\n",
                  typename, tmp___2, statusstring);
      }
    }
  }
#line 256
  if (r == -1) {
    {
#line 256
    tmp___3 = __errno_location();
#line 256
    sysfail("write error message to stderr", *tmp___3);
    }
  }
#line 257
  return;
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsheloex.c"
static char const   * const  progname___1  =    (char const   */* const  */)"adnsheloex";
#line 70 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsheloex.c"
static char const   *config_text___5  ;
#line 77 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsheloex.c"
static void msg___1(char const   *fmt  , ...) 
{ 
  va_list al ;

  {
  {
#line 80
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
          progname___1);
#line 81
  __builtin_va_start(al, fmt);
#line 82
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           al);
#line 83
  __builtin_va_end(al);
#line 84
  fputc('\n', stderr);
  }
#line 85
  return;
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsheloex.c"
static void aargh___1(char const   *cause ) 
{ 
  char const   *why ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 88
  tmp = __errno_location();
#line 88
  tmp___0 = strerror(*tmp);
#line 88
  why = (char const   *)tmp___0;
  }
#line 89
  if (! why) {
#line 89
    why = "Unknown error";
  }
  {
#line 90
  tmp___1 = __errno_location();
#line 90
  msg___1("%s: %s (%d)", cause, why, *tmp___1);
#line 91
  exit(1);
  }
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsheloex.c"
static char buf___9[1024]  ;
#line 100 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsheloex.c"
static logline___0 *readline___1(FILE *inf , adns_state adns , int opts ) 
{ 
  char *str ;
  char *p ;
  char *q ;
  char *r ;
  logline___0 *line ;
  size_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 105
  tmp___5 = fgets((char */* __restrict  */)(buf___9), 1024, (FILE */* __restrict  */)inf);
  }
#line 105
  if (tmp___5) {
    {
#line 106
    tmp = strlen((char const   *)(buf___9));
#line 106
    tmp___0 = malloc((sizeof(*line) + tmp) + 1UL);
#line 106
    str = (char *)tmp___0;
    }
#line 107
    if (! str) {
      {
#line 107
      aargh___1("malloc");
      }
    }
    {
#line 108
    line = (logline___0 *)str;
#line 109
    line->next = (struct logline___0 *)((void *)0);
#line 110
    line->start = str + sizeof(logline___0 );
#line 111
    strcpy((char */* __restrict  */)line->start, (char const   */* __restrict  */)(buf___9));
#line 112
    tmp___2 = (char *)((void *)0);
#line 112
    line->addr = tmp___2;
#line 112
    tmp___1 = tmp___2;
#line 112
    line->rest = tmp___1;
#line 112
    line->name = tmp___1;
#line 115
    p = strchr((char const   *)line->start, ' ');
    }
    {
#line 115
    while (1) {
      while_continue: /* CIL Label */ ;
#line 115
      if (! p) {
#line 115
        goto while_break;
      }
      {
#line 116
      tmp___3 = strncmp((char const   *)p, " H=", (size_t )3);
      }
#line 116
      if (! tmp___3) {
        {
#line 117
        r = strchr((char const   *)p, '[');
        }
#line 118
        if (! r) {
#line 118
          goto while_break;
        }
        {
#line 119
        q = strchr((char const   *)p, ')');
        }
#line 120
        if (! q) {
#line 120
          goto while_break;
        } else
#line 120
        if ((unsigned long )q > (unsigned long )r) {
#line 120
          goto while_break;
        }
        {
#line 121
        p = strchr((char const   *)p, '(');
        }
#line 122
        if (! p) {
#line 122
          goto while_break;
        } else
#line 122
        if ((unsigned long )p > (unsigned long )q) {
#line 122
          goto while_break;
        }
#line 123
        line->name = p + 1;
#line 124
        line->rest = q;
#line 125
        line->addr = r + 1;
#line 126
        goto while_break;
      }
      {
#line 115
      p = strchr((char const   *)(p + 1), ' ');
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 129
    if (line->name) {
#line 130
      *(line->rest) = (char )'\000';
#line 131
      if (opts & 1) {
        {
#line 132
        msg___1("submitting %s", line->name);
        }
      }
      {
#line 133
      tmp___4 = adns_submit(adns, (char const   *)line->name, (adns_rrtype )1, (adns_queryflags )272,
                            (void *)0, & line->query);
      }
#line 133
      if (tmp___4) {
        {
#line 136
        aargh___1("adns_submit");
        }
      }
#line 137
      *(line->rest) = (char )')';
    } else {
#line 139
      if (opts & 1) {
        {
#line 140
        msg___1("no query");
        }
      }
#line 141
      line->query = (adns_query )((void *)0);
    }
#line 143
    return (line);
  }
  {
#line 145
  tmp___6 = feof(inf);
  }
#line 145
  if (! tmp___6) {
    {
#line 146
    aargh___1("fgets");
    }
  }
#line 147
  return ((logline___0 *)((void *)0));
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsheloex.c"
static void proclog___1(FILE *inf , FILE *outf , int maxpending , int opts ) 
{ 
  int eof ;
  int err ;
  int len ;
  adns_state adns ;
  adns_answer *answer ;
  logline___0 *head ;
  logline___0 *tail ;
  logline___0 *line ;
  adns_initflags initflags___3 ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char const   *addr ;
  int ok ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;

  {
#line 157
  if (opts & 1) {
#line 157
    initflags___3 = (adns_initflags )8;
  } else {
#line 157
    initflags___3 = (adns_initflags )0;
  }
#line 158
  if (config_text___5) {
    {
#line 159
    tmp = __errno_location();
#line 159
    *tmp = adns_init_strcfg(& adns, initflags___3, stderr, config_text___5);
    }
  } else {
    {
#line 161
    tmp___0 = __errno_location();
#line 161
    *tmp___0 = adns_init(& adns, initflags___3, (FILE *)0);
    }
  }
  {
#line 163
  tmp___1 = __errno_location();
  }
#line 163
  if (*tmp___1) {
    {
#line 163
    aargh___1("adns_init");
    }
  }
  {
#line 164
  tail = readline___1(inf, adns, opts);
#line 164
  head = tail;
#line 165
  len = 1;
#line 165
  eof = 0;
  }
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    if (! head) {
#line 166
      goto while_break;
    }
    {
#line 167
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 167
      if (! head) {
#line 167
        goto while_break___0;
      }
#line 168
      if (head->query) {
#line 169
        if (opts & 1) {
#line 170
          if (head->name) {
#line 170
            tmp___2 = (char const   *)head->name;
          } else {
#line 170
            tmp___2 = "";
          }
          {
#line 170
          msg___1("%d in queue; checking %.*s", len, (int )(head->rest - head->name),
                  tmp___2);
          }
        }
#line 172
        if (eof) {
#line 172
          goto _L;
        } else
#line 172
        if (len >= maxpending) {
          _L: /* CIL Label */ 
#line 173
          if (opts & 2) {
            {
#line 174
            err = adns_wait_poll(adns, & head->query, & answer, (void **)((void *)0));
            }
          } else {
            {
#line 176
            err = adns_wait(adns, & head->query, & answer, (void **)((void *)0));
            }
          }
        } else {
          {
#line 178
          err = adns_check(adns, & head->query, & answer, (void **)((void *)0));
          }
        }
#line 180
        if (err == 11) {
#line 180
          goto while_break___0;
        }
#line 181
        if (err) {
          {
#line 182
          tmp___3 = strerror(err);
#line 182
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: adns_wait/check: %s",
                  progname___1, tmp___3);
#line 183
          exit(1);
          }
        }
#line 185
        if ((unsigned int )answer->status == 0U) {
          {
#line 187
          ok = 0;
#line 188
          fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)"%.*s",
                  (int )(head->rest - head->start), head->start);
          }
          {
#line 189
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 189
            tmp___8 = answer->nrrs;
#line 189
            (answer->nrrs) --;
#line 189
            if (! tmp___8) {
#line 189
              goto while_break___1;
            }
            {
#line 190
            tmp___4 = inet_ntoa(*(answer->rrs.inaddr + answer->nrrs));
#line 190
            addr = (char const   *)tmp___4;
#line 191
            tmp___5 = strlen(addr);
#line 191
            tmp___6 = strncmp(addr, (char const   *)head->addr, tmp___5);
            }
#line 191
            if (tmp___6) {
#line 191
              tmp___7 = 0;
            } else {
#line 191
              tmp___7 = 1;
            }
            {
#line 191
            ok |= tmp___7;
#line 192
            fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)" [%s]",
                    addr);
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 194
          if (ok) {
#line 194
            tmp___9 = " OK";
          } else {
#line 194
            tmp___9 = "";
          }
          {
#line 194
          fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)"%s%s",
                  tmp___9, head->rest);
          }
        } else {
#line 196
          if (opts & 1) {
            {
#line 197
            msg___1("query failed");
            }
          }
          {
#line 198
          fputs((char const   */* __restrict  */)head->start, (FILE */* __restrict  */)outf);
          }
        }
        {
#line 200
        free((void *)answer);
#line 201
        len --;
        }
      } else {
#line 203
        if (opts & 1) {
          {
#line 204
          msg___1("%d in queue; no query on this line", len);
          }
        }
        {
#line 205
        fputs((char const   */* __restrict  */)head->start, (FILE */* __restrict  */)outf);
        }
      }
      {
#line 207
      line = head;
#line 207
      head = head->next;
#line 208
      free((void *)line);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 210
    if (! eof) {
      {
#line 211
      line = readline___1(inf, adns, opts);
      }
#line 212
      if (line) {
#line 213
        if (! head) {
#line 213
          head = line;
        } else {
#line 214
          tail->next = line;
        }
#line 215
        tail = line;
#line 216
        if (line->query) {
#line 216
          len ++;
        }
      } else {
#line 218
        eof = 1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 222
  adns_finish(adns);
  }
#line 223
  return;
}
}
#line 225 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsheloex.c"
static void printhelp___1(FILE *file ) 
{ 


  {
  {
#line 226
  fputs((char const   */* __restrict  */)"usage: adnsheloex [<options>] [<logfile>]\n       adnsheloex --version|--help\noptions: -c <concurrency>  set max number of outstanding queries\n         -p                use poll(2) instead of select(2)\n         -d                turn on debugging\n         -C <config>       use instead of contents of resolv.conf\n",
        (FILE */* __restrict  */)stdout);
  }
#line 233
  return;
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsheloex.c"
static void usage___4(void) 
{ 


  {
  {
#line 236
  printhelp___1(stderr);
#line 237
  exit(1);
  }
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pap_qstring___8(parseinfo const   *pai , int *cbyte_io , int max ,
                                   int *len_r , char **str_r ) 
{ 
  byte const   *dgram ;
  int l ;
  int cbyte___3 ;
  char *str ;
  int tmp ;
  void *tmp___0 ;

  {
#line 92
  dgram = (byte const   *)pai->dgram;
#line 96
  cbyte___3 = *cbyte_io;
#line 98
  if (cbyte___3 >= max) {
#line 98
    return ((adns_status )104);
  }
#line 99
  tmp = cbyte___3;
#line 99
  cbyte___3 ++;
#line 99
  l = (int )((int const   )*(dgram + tmp) & 255);
#line 100
  if (cbyte___3 + l > max) {
#line 100
    return ((adns_status )104);
  }
  {
#line 102
  tmp___0 = adns__alloc_interim((adns_query )pai->qu, (size_t )(l + 1));
#line 102
  str = (char *)tmp___0;
  }
#line 103
  if (! str) {
#line 103
    return ((adns_status )1);
  }
  {
#line 105
  *(str + l) = (char)0;
#line 106
  memcpy((void */* __restrict  */)str, (void const   */* __restrict  */)(dgram + cbyte___3),
         (size_t )l);
#line 108
  *len_r = l;
#line 109
  *str_r = str;
#line 110
  *cbyte_io = cbyte___3 + l;
  }
#line 112
  return ((adns_status )0);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status csp_qstring___8(vbuf *vb___0 , char const   *dp , int len ) 
{ 
  unsigned char ch ;
  char buf___17[10] ;
  int cn ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 120
    tmp = adns__vbuf_appendstr(vb___0, "\"");
    }
#line 120
    if (! tmp) {
#line 120
      return ((adns_status )1);
    }
#line 120
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  cn = 0;
  {
#line 121
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 121
    if (! (cn < len)) {
#line 121
      goto while_break___0;
    }
#line 122
    tmp___0 = dp;
#line 122
    dp ++;
#line 122
    ch = (unsigned char )*tmp___0;
#line 123
    if ((int )ch == 92) {
      {
#line 124
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 124
        tmp___1 = adns__vbuf_appendstr(vb___0, "\\\\");
        }
#line 124
        if (! tmp___1) {
#line 124
          return ((adns_status )1);
        }
#line 124
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else
#line 125
    if ((int )ch == 34) {
      {
#line 126
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 126
        tmp___2 = adns__vbuf_appendstr(vb___0, "\\\"");
        }
#line 126
        if (! tmp___2) {
#line 126
          return ((adns_status )1);
        }
#line 126
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else
#line 127
    if ((int )ch >= 32) {
#line 127
      if ((int )ch <= 126) {
        {
#line 128
        tmp___3 = adns__vbuf_append(vb___0, (byte const   *)(& ch), 1);
        }
#line 128
        if (! tmp___3) {
#line 128
          return ((adns_status )1);
        }
      } else {
#line 127
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 130
      sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"\\x%02x",
              (int )ch);
      }
      {
#line 131
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 131
        tmp___4 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
        }
#line 131
        if (! tmp___4) {
#line 131
          return ((adns_status )1);
        }
#line 131
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 121
    cn ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 134
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 134
    tmp___5 = adns__vbuf_appendstr(vb___0, "\"");
    }
#line 134
    if (! tmp___5) {
#line 134
      return ((adns_status )1);
    }
#line 134
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 136
  return ((adns_status )0);
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_str___8(adns_query qu , void *datap ) 
{ 
  char **rrp ;

  {
  {
#line 144
  rrp = (char **)datap;
#line 146
  adns__makefinal_str(qu, rrp);
  }
#line 147
  return;
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_intstr___8(adns_query qu , void *datap ) 
{ 
  adns_rr_intstr *rrp ;

  {
  {
#line 154
  rrp = (adns_rr_intstr *)datap;
#line 156
  adns__makefinal_str(qu, & rrp->str);
  }
#line 157
  return;
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_manyistr___8(adns_query qu , void *datap ) 
{ 
  adns_rr_intstr **rrp ;
  adns_rr_intstr *te ;
  adns_rr_intstr *table ;
  void *tablev ;
  int tc ;

  {
#line 164
  rrp = (adns_rr_intstr **)datap;
#line 169
  tc = 0;
#line 169
  te = *rrp;
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    if (! (te->i >= 0)) {
#line 169
      goto while_break;
    }
#line 169
    te ++;
#line 169
    tc ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 170
  tablev = (void *)*rrp;
#line 171
  adns__makefinal_block(qu, & tablev, sizeof(*te) * (unsigned long )(tc + 1));
#line 172
  table = (adns_rr_intstr *)tablev;
#line 172
  *rrp = table;
#line 173
  te = *rrp;
  }
  {
#line 173
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 173
    if (! (te->i >= 0)) {
#line 173
      goto while_break___0;
    }
    {
#line 174
    adns__makefinal_str(qu, & te->str);
#line 173
    te ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 175
  return;
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_txt___8(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  adns_rr_intstr **rrp ;
  adns_rr_intstr *table ;
  adns_rr_intstr *te ;
  byte const   *dgram ;
  int ti ;
  int tc ;
  int l ;
  int startbyte ;
  adns_status st ;
  int tmp ;
  void *tmp___0 ;

  {
#line 183
  rrp = (adns_rr_intstr **)datap;
#line 184
  dgram = (byte const   *)pai->dgram;
#line 188
  startbyte = cbyte___3;
#line 189
  if (cbyte___3 >= max) {
#line 189
    return ((adns_status )104);
  }
#line 190
  tc = 0;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! (cbyte___3 < max)) {
#line 191
      goto while_break;
    }
#line 192
    tmp = cbyte___3;
#line 192
    cbyte___3 ++;
#line 192
    l = (int )((int const   )*(dgram + tmp) & 255);
#line 193
    cbyte___3 += l;
#line 194
    tc ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  if (cbyte___3 != max) {
#line 196
    return ((adns_status )104);
  } else
#line 196
  if (! tc) {
#line 196
    return ((adns_status )104);
  }
  {
#line 198
  tmp___0 = adns__alloc_interim((adns_query )pai->qu, sizeof(*table) * (unsigned long )(tc + 1));
#line 198
  table = (adns_rr_intstr *)tmp___0;
  }
#line 199
  if (! table) {
#line 199
    return ((adns_status )1);
  }
#line 201
  cbyte___3 = startbyte;
#line 201
  ti = 0;
#line 201
  te = table;
  {
#line 201
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 201
    if (! (ti < tc)) {
#line 201
      goto while_break___0;
    }
    {
#line 202
    st = pap_qstring___8(pai, & cbyte___3, max, & te->i, & te->str);
    }
#line 203
    if (st) {
#line 203
      return (st);
    }
#line 201
    ti ++;
#line 201
    te ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 205
  if (! (cbyte___3 == max)) {
    {
#line 205
    __assert_fail("cbyte == max", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                  205U, "pa_txt");
    }
  }
#line 207
  te->i = -1;
#line 208
  te->str = (char *)0;
#line 210
  *rrp = table;
#line 211
  return ((adns_status )0);
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_txt___8(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_intstr const   * const  *rrp ;
  adns_rr_intstr const   *current ;
  adns_status st ;
  int spc ;
  int tmp ;

  {
#line 215
  rrp = (adns_rr_intstr const   * const  *)datap;
#line 220
  current = (adns_rr_intstr const   *)*rrp;
#line 220
  spc = 0;
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    if (! (current->i >= 0)) {
#line 220
      goto while_break;
    }
#line 221
    if (spc) {
      {
#line 221
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 221
        tmp = adns__vbuf_appendstr(vb___0, " ");
        }
#line 221
        if (! tmp) {
#line 221
          return ((adns_status )1);
        }
#line 221
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 222
    st = csp_qstring___8(vb___0, (char const   *)current->str, (int )current->i);
    }
#line 222
    if (st) {
#line 222
      return (st);
    }
#line 220
    current ++;
#line 220
    spc = 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  return ((adns_status )0);
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_hinfo___8(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_intstrpair const   *rrp ;
  adns_status st ;
  int tmp ;

  {
  {
#line 232
  rrp = (adns_rr_intstrpair const   *)datap;
#line 235
  st = csp_qstring___8(vb___0, (char const   *)rrp->array[0].str, (int )rrp->array[0].i);
  }
#line 235
  if (st) {
#line 235
    return (st);
  }
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 236
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 236
    if (! tmp) {
#line 236
      return ((adns_status )1);
    }
#line 236
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 237
  st = csp_qstring___8(vb___0, (char const   *)rrp->array[1].str, (int )rrp->array[1].i);
  }
#line 237
  if (st) {
#line 237
    return (st);
  }
#line 238
  return ((adns_status )0);
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_inaddr___8(parseinfo const   *pai , int cbyte___3 , int max ,
                                 void *datap ) 
{ 
  struct in_addr *storeto ;

  {
#line 247
  storeto = (struct in_addr *)datap;
#line 249
  if (max - cbyte___3 != 4) {
#line 249
    return ((adns_status )104);
  }
  {
#line 250
  memcpy((void */* __restrict  */)storeto, (void const   */* __restrict  */)(pai->dgram + cbyte___3),
         (size_t )4);
  }
#line 251
  return ((adns_status )0);
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int search_sortlist___8(adns_state ads___7 , struct in_addr ad ) 
{ 
  struct sortlist  const  *slp ;
  int i ;

  {
#line 258
  i = 0;
#line 258
  slp = (struct sortlist  const  *)(ads___7->sortlist);
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 258
    if (i < ads___7->nsortlist) {
#line 258
      if (! (! ((ad.s_addr & (unsigned int )slp->mask.s_addr) == (unsigned int )slp->base.s_addr))) {
#line 258
        goto while_break;
      }
    } else {
#line 258
      goto while_break;
    }
#line 258
    i ++;
#line 258
    slp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  return (i);
}
}
#line 265 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int dip_inaddr___8(adns_state ads___7 , struct in_addr a , struct in_addr b ) 
{ 
  int ai ;
  int bi ;

  {
#line 268
  if (! ads___7->nsortlist) {
#line 268
    return (0);
  }
  {
#line 270
  ai = search_sortlist___8(ads___7, a);
#line 271
  bi = search_sortlist___8(ads___7, b);
  }
#line 272
  return (bi < ai);
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int di_inaddr___8(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  struct in_addr  const  *ap ;
  struct in_addr  const  *bp ;
  int tmp ;

  {
  {
#line 277
  ap = (struct in_addr  const  *)datap_a;
#line 277
  bp = (struct in_addr  const  *)datap_b;
#line 279
  tmp = dip_inaddr___8(ads___7, (struct in_addr )*ap, (struct in_addr )*bp);
  }
#line 279
  return (tmp);
}
}
#line 282 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_inaddr___8(vbuf *vb___0 , void const   *datap ) 
{ 
  struct in_addr  const  *rrp ;
  struct in_addr rr ;
  char const   *ia ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 283
  rrp = (struct in_addr  const  *)datap;
#line 283
  rr = *rrp;
#line 286
  tmp = inet_ntoa(rr);
#line 286
  ia = (char const   *)tmp;
  }
#line 286
  if (! ia) {
    {
#line 286
    __assert_fail("ia", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                  286U, "cs_inaddr");
    }
  }
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 287
    tmp___0 = adns__vbuf_appendstr(vb___0, ia);
    }
#line 287
    if (! tmp___0) {
#line 287
      return ((adns_status )1);
    }
#line 287
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  return ((adns_status )0);
}
}
#line 295 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_addr___8(parseinfo const   *pai , int cbyte___3 , int max ,
                               void *datap ) 
{ 
  adns_rr_addr *storeto ;
  byte const   *dgram ;

  {
#line 297
  storeto = (adns_rr_addr *)datap;
#line 298
  dgram = (byte const   *)pai->dgram;
#line 300
  if (max - cbyte___3 != 4) {
#line 300
    return ((adns_status )104);
  }
  {
#line 301
  storeto->len = (int )sizeof(storeto->addr.inet);
#line 302
  memset((void *)(& storeto->addr), 0, sizeof(storeto->addr.inet));
#line 303
  storeto->addr.inet.sin_family = (sa_family_t )2;
#line 304
  memcpy((void */* __restrict  */)(& storeto->addr.inet.sin_addr), (void const   */* __restrict  */)(dgram + cbyte___3),
         (size_t )4);
  }
#line 305
  return ((adns_status )0);
}
}
#line 308 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int di_addr___8(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_addr const   *ap ;
  adns_rr_addr const   *bp ;
  int tmp ;

  {
#line 309
  ap = (adns_rr_addr const   *)datap_a;
#line 309
  bp = (adns_rr_addr const   *)datap_b;
#line 311
  if (! ((int const   )ap->addr.sa.sa_family == 2)) {
    {
#line 311
    __assert_fail("ap->addr.sa.sa_family == 2", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                  311U, "di_addr");
    }
  }
  {
#line 312
  tmp = dip_inaddr___8(ads___7, (struct in_addr )ap->addr.inet.sin_addr, (struct in_addr )bp->addr.inet.sin_addr);
  }
#line 312
  return (tmp);
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int div_addr___8(void *context , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_state ads___7 ;
  int tmp ;

  {
  {
#line 316
  ads___7 = (adns_state )context;
#line 318
  tmp = di_addr___8(ads___7, datap_a, datap_b);
  }
#line 318
  return (tmp);
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status csp_addr___8(vbuf *vb___0 , adns_rr_addr const   *rrp ) 
{ 
  char const   *ia ;
  char buf___17[30] ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 326
  if ((int const   )rrp->addr.inet.sin_family == 2) {
#line 326
    goto case_2;
  }
#line 331
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 327
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 327
    tmp = adns__vbuf_appendstr(vb___0, "INET ");
    }
#line 327
    if (! tmp) {
#line 327
      return ((adns_status )1);
    }
#line 327
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 328
  tmp___0 = inet_ntoa((struct in_addr )rrp->addr.inet.sin_addr);
#line 328
  ia = (char const   *)tmp___0;
  }
#line 328
  if (! ia) {
    {
#line 328
    __assert_fail("ia", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                  328U, "csp_addr");
    }
  }
  {
#line 329
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 329
    tmp___1 = adns__vbuf_appendstr(vb___0, ia);
    }
#line 329
    if (! tmp___1) {
#line 329
      return ((adns_status )1);
    }
#line 329
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 330
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 332
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"AF=%u",
          (int const   )rrp->addr.sa.sa_family);
  }
  {
#line 333
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 333
    tmp___2 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 333
    if (! tmp___2) {
#line 333
      return ((adns_status )1);
    }
#line 333
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 334
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 336
  return ((adns_status )0);
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_addr___8(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_addr const   *rrp ;
  adns_status tmp ;

  {
  {
#line 340
  rrp = (adns_rr_addr const   *)datap;
#line 342
  tmp = csp_addr___8(vb___0, rrp);
  }
#line 342
  return (tmp);
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pap_domain___8(parseinfo const   *pai , int *cbyte_io , int max ,
                                  char **domain_r , parsedomain_flags flags ) 
{ 
  adns_status st ;
  char *dm ;
  void *tmp ;

  {
  {
#line 355
  st = adns__parse_domain((pai->qu)->ads, (int )pai->serv, (adns_query )pai->qu, & (pai->qu)->vb,
                          flags, (byte const   *)pai->dgram, (int )pai->dglen, cbyte_io,
                          max);
  }
#line 357
  if (st) {
#line 357
    return (st);
  }
#line 358
  if (! (pai->qu)->vb.used) {
#line 358
    return ((adns_status )104);
  }
  {
#line 360
  tmp = adns__alloc_interim((adns_query )pai->qu, (size_t )((pai->qu)->vb.used + 1));
#line 360
  dm = (char *)tmp;
  }
#line 361
  if (! dm) {
#line 361
    return ((adns_status )1);
  }
  {
#line 363
  *(dm + (pai->qu)->vb.used) = (char)0;
#line 364
  memcpy((void */* __restrict  */)dm, (void const   */* __restrict  */)(pai->qu)->vb.buf,
         (size_t )(pai->qu)->vb.used);
#line 366
  *domain_r = dm;
  }
#line 367
  return ((adns_status )0);
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status csp_domain___8(vbuf *vb___0 , char const   *domain ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 371
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 371
    tmp = adns__vbuf_appendstr(vb___0, domain);
    }
#line 371
    if (! tmp) {
#line 371
      return ((adns_status )1);
    }
#line 371
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 372
  if (! *domain) {
    {
#line 372
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 372
      tmp___0 = adns__vbuf_appendstr(vb___0, ".");
      }
#line 372
      if (! tmp___0) {
#line 372
        return ((adns_status )1);
      }
#line 372
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 373
  return ((adns_status )0);
}
}
#line 376 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_domain___8(vbuf *vb___0 , void const   *datap ) 
{ 
  char const   * const  *domainp ;
  adns_status tmp ;

  {
  {
#line 377
  domainp = (char const   * const  *)datap;
#line 378
  tmp = csp_domain___8(vb___0, (char const   *)*domainp);
  }
#line 378
  return (tmp);
}
}
#line 381 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_dom_raw___8(parseinfo const   *pai , int cbyte___3 , int max ,
                                  void *datap ) 
{ 
  char **rrp ;
  adns_status st ;

  {
  {
#line 383
  rrp = (char **)datap;
#line 386
  st = pap_domain___8(pai, & cbyte___3, max, rrp, (parsedomain_flags )1);
  }
#line 387
  if (st) {
#line 387
    return (st);
  }
#line 389
  if (cbyte___3 != max) {
#line 389
    return ((adns_status )104);
  }
#line 390
  return ((adns_status )0);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_host_raw___8(parseinfo const   *pai , int cbyte___3 , int max ,
                                   void *datap ) 
{ 
  char **rrp ;
  adns_status st ;
  int tmp ;

  {
#line 399
  rrp = (char **)datap;
#line 402
  if ((pai->qu)->flags & 64) {
#line 402
    tmp = 1;
  } else {
#line 402
    tmp = 0;
  }
  {
#line 402
  st = pap_domain___8(pai, & cbyte___3, max, rrp, (parsedomain_flags )tmp);
  }
#line 404
  if (st) {
#line 404
    return (st);
  }
#line 406
  if (cbyte___3 != max) {
#line 406
    return ((adns_status )104);
  }
#line 407
  return ((adns_status )0);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pap_findaddrs___8(parseinfo const   *pai , adns_rr_hostaddr *ha ,
                                     int *cbyte_io , int count , int dmstart ) 
{ 
  int rri ;
  int naddrs ;
  int type ;
  int class ;
  int rdlen ;
  int rdstart ;
  int ownermatched ;
  unsigned long ttl ;
  adns_status st ;
  int tmp ;
  void *tmp___0 ;

  {
#line 421
  rri = 0;
#line 421
  naddrs = -1;
  {
#line 421
  while (1) {
    while_continue: /* CIL Label */ ;
#line 421
    if (! (rri < count)) {
#line 421
      goto while_break;
    }
    {
#line 422
    st = adns__findrr_anychk((adns_query )pai->qu, (int )pai->serv, (byte const   *)pai->dgram,
                             (int )pai->dglen, cbyte_io, & type, & class, & ttl, & rdlen,
                             & rdstart, (byte const   *)pai->dgram, (int )pai->dglen,
                             dmstart, & ownermatched);
    }
#line 426
    if (st) {
#line 426
      return (st);
    }
#line 427
    if (! ownermatched) {
#line 427
      goto _L;
    } else
#line 427
    if (class != 1) {
#line 427
      goto _L;
    } else
#line 427
    if (type != 1) {
      _L: /* CIL Label */ 
#line 428
      if (naddrs > 0) {
#line 428
        goto while_break;
      } else {
#line 428
        goto __Cont;
      }
    }
#line 430
    if (naddrs == -1) {
#line 431
      naddrs = 0;
    }
    {
#line 433
    tmp = adns__vbuf_ensure(& (pai->qu)->vb, (int )((unsigned long )(naddrs + 1) * sizeof(adns_rr_addr )));
    }
#line 433
    if (! tmp) {
#line 434
      return ((adns_status )1);
    }
    {
#line 435
    adns__update_expires((adns_query )pai->qu, ttl, (struct timeval )pai->now);
#line 436
    st = pa_addr___8(pai, rdstart, rdstart + rdlen, (void *)((pai->qu)->vb.buf + (unsigned long )naddrs * sizeof(adns_rr_addr )));
    }
#line 438
    if (st) {
#line 438
      return (st);
    }
#line 439
    naddrs ++;
    __Cont: /* CIL Label */ 
#line 421
    rri ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 441
  if (naddrs >= 0) {
    {
#line 442
    tmp___0 = adns__alloc_interim((adns_query )pai->qu, (unsigned long )naddrs * sizeof(adns_rr_addr ));
#line 442
    ha->addrs = (adns_rr_addr *)tmp___0;
    }
#line 443
    if (! ha->addrs) {
#line 443
      return ((adns_status )1);
    }
    {
#line 444
    memcpy((void */* __restrict  */)ha->addrs, (void const   */* __restrict  */)(pai->qu)->vb.buf,
           (unsigned long )naddrs * sizeof(adns_rr_addr ));
#line 445
    ha->naddrs = naddrs;
#line 446
    ha->astatus = (adns_status )0;
#line 448
    adns__isort((void *)ha->addrs, naddrs, (int )sizeof(adns_rr_addr ), (void *)(pai->qu)->vb.buf,
                & div_addr___8, (void *)pai->ads);
    }
  }
#line 451
  return ((adns_status )0);
}
}
#line 454 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void icb_hostaddr___8(adns_query parent , adns_query child ) 
{ 
  adns_answer *cans ;
  adns_rr_hostaddr *rrp ;
  adns_state ads___7 ;
  adns_status st ;

  {
#line 455
  cans = child->answer;
#line 456
  rrp = child->ctx.info.hostaddr;
#line 457
  ads___7 = parent->ads;
#line 460
  st = cans->status;
#line 461
  rrp->astatus = st;
#line 462
  if ((unsigned int )st > 0U) {
#line 462
    if ((unsigned int )st <= 99U) {
#line 462
      rrp->naddrs = -1;
    } else {
#line 462
      rrp->naddrs = cans->nrrs;
    }
  } else {
#line 462
    rrp->naddrs = cans->nrrs;
  }
  {
#line 463
  rrp->addrs = cans->rrs.addr;
#line 464
  adns__transfer_interim(child, parent, (void *)rrp->addrs, (unsigned long )rrp->naddrs * sizeof(adns_rr_addr ));
  }
#line 467
  if (parent->children.head) {
    {
#line 468
    while (1) {
      while_continue: /* CIL Label */ ;
#line 468
      parent->next = (adns_query )0;
#line 468
      parent->back = ads___7->childw.tail;
#line 468
      if (ads___7->childw.tail) {
#line 468
        (ads___7->childw.tail)->next = parent;
      } else {
#line 468
        ads___7->childw.head = parent;
      }
#line 468
      ads___7->childw.tail = parent;
#line 468
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 470
    adns__query_done(parent);
    }
  }
#line 472
  return;
}
}
#line 474 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pap_hostaddr___8(parseinfo const   *pai , int *cbyte_io , int max ,
                                    adns_rr_hostaddr *rrp ) 
{ 
  adns_status st ;
  int dmstart ;
  int cbyte___3 ;
  qcontext ctx ;
  int id ;
  adns_query nqu ;
  adns_queryflags nflags ;
  int tmp ;
  typeinfo const   *tmp___0 ;

  {
#line 483
  cbyte___3 = *cbyte_io;
#line 483
  dmstart = cbyte___3;
#line 484
  if ((pai->qu)->flags & 64) {
#line 484
    tmp = 1;
  } else {
#line 484
    tmp = 0;
  }
  {
#line 484
  st = pap_domain___8(pai, & cbyte___3, max, & rrp->host, (parsedomain_flags )tmp);
  }
#line 486
  if (st) {
#line 486
    return (st);
  }
  {
#line 487
  *cbyte_io = cbyte___3;
#line 489
  rrp->astatus = (adns_status )0;
#line 490
  rrp->naddrs = -1;
#line 491
  rrp->addrs = (adns_rr_addr *)0;
#line 493
  cbyte___3 = (int )pai->nsstart;
#line 495
  st = pap_findaddrs___8(pai, rrp, & cbyte___3, (int )pai->nscount, dmstart);
  }
#line 496
  if (st) {
#line 496
    return (st);
  }
#line 497
  if (rrp->naddrs != -1) {
#line 497
    return ((adns_status )0);
  }
  {
#line 499
  st = pap_findaddrs___8(pai, rrp, & cbyte___3, (int )pai->arcount, dmstart);
  }
#line 500
  if (st) {
#line 500
    return (st);
  }
#line 501
  if (rrp->naddrs != -1) {
#line 501
    return ((adns_status )0);
  }
  {
#line 503
  st = adns__mkquery_frdgram((adns_state )pai->ads, & (pai->qu)->vb, & id, (byte const   *)pai->dgram,
                             (int )pai->dglen, dmstart, (adns_rrtype )65537, (adns_queryflags )16);
  }
#line 506
  if (st) {
#line 506
    return (st);
  }
#line 508
  ctx.ext = (void *)0;
#line 509
  ctx.callback = & icb_hostaddr___8;
#line 510
  ctx.info.hostaddr = rrp;
#line 512
  nflags = (adns_queryflags )16;
#line 513
  if (! ((pai->qu)->flags & 256)) {
#line 513
    nflags = (adns_queryflags )((unsigned int )nflags | 512U);
  }
  {
#line 515
  tmp___0 = adns__findtype((adns_rrtype )65537);
#line 515
  st = adns__internal_submit((adns_state )pai->ads, & nqu, tmp___0, & (pai->qu)->vb,
                             id, nflags, (struct timeval )pai->now, (qcontext const   *)(& ctx));
  }
#line 517
  if (st) {
#line 517
    return (st);
  }
#line 519
  nqu->parent = (adns_query )pai->qu;
  {
#line 520
  while (1) {
    while_continue: /* CIL Label */ ;
#line 520
    nqu->siblings.next = (adns_query )0;
#line 520
    nqu->siblings.back = (pai->qu)->children.tail;
#line 520
    if ((pai->qu)->children.tail) {
#line 520
      ((pai->qu)->children.tail)->siblings.next = nqu;
    } else {
#line 520
      (pai->qu)->children.head = nqu;
    }
#line 520
    (pai->qu)->children.tail = nqu;
#line 520
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 522
  return ((adns_status )0);
}
}
#line 525 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_hostaddr___8(parseinfo const   *pai , int cbyte___3 , int max ,
                                   void *datap ) 
{ 
  adns_rr_hostaddr *rrp ;
  adns_status st ;

  {
  {
#line 527
  rrp = (adns_rr_hostaddr *)datap;
#line 530
  st = pap_hostaddr___8(pai, & cbyte___3, max, rrp);
  }
#line 531
  if (st) {
#line 531
    return (st);
  }
#line 532
  if (cbyte___3 != max) {
#line 532
    return ((adns_status )104);
  }
#line 534
  return ((adns_status )0);
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int dip_hostaddr___8(adns_state ads___7 , adns_rr_hostaddr const   *ap , adns_rr_hostaddr const   *bp ) 
{ 
  int tmp ;

  {
#line 539
  if ((unsigned int const   )ap->astatus != (unsigned int const   )bp->astatus) {
#line 539
    return ((int )ap->astatus);
  }
#line 540
  if (ap->astatus) {
#line 540
    return (0);
  }
#line 542
  if (! ((int )(ap->addrs + 0)->addr.sa.sa_family == 2)) {
    {
#line 542
    __assert_fail("ap->addrs[0].addr.sa.sa_family == 2", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                  542U, "dip_hostaddr");
    }
  }
#line 543
  if (! ((int )(bp->addrs + 0)->addr.sa.sa_family == 2)) {
    {
#line 543
    __assert_fail("bp->addrs[0].addr.sa.sa_family == 2", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                  543U, "dip_hostaddr");
    }
  }
  {
#line 544
  tmp = dip_inaddr___8(ads___7, (ap->addrs + 0)->addr.inet.sin_addr, (bp->addrs + 0)->addr.inet.sin_addr);
  }
#line 544
  return (tmp);
}
}
#line 549 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int di_hostaddr___8(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_hostaddr const   *ap ;
  adns_rr_hostaddr const   *bp ;
  int tmp ;

  {
  {
#line 551
  ap = (adns_rr_hostaddr const   *)datap_a;
#line 551
  bp = (adns_rr_hostaddr const   *)datap_b;
#line 553
  tmp = dip_hostaddr___8(ads___7, ap, bp);
  }
#line 553
  return (tmp);
}
}
#line 556 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mfp_hostaddr___8(adns_query qu , adns_rr_hostaddr *rrp ) 
{ 
  void *tablev ;

  {
  {
#line 559
  adns__makefinal_str(qu, & rrp->host);
#line 560
  tablev = (void *)rrp->addrs;
#line 561
  adns__makefinal_block(qu, & tablev, (unsigned long )rrp->naddrs * sizeof(*(rrp->addrs)));
#line 562
  rrp->addrs = (adns_rr_addr *)tablev;
  }
#line 563
  return;
}
}
#line 565 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_hostaddr___8(adns_query qu , void *datap ) 
{ 
  adns_rr_hostaddr *rrp ;

  {
  {
#line 566
  rrp = (adns_rr_hostaddr *)datap;
#line 568
  mfp_hostaddr___8(qu, rrp);
  }
#line 569
  return;
}
}
#line 571 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status csp_hostaddr___8(vbuf *vb___0 , adns_rr_hostaddr const   *rrp ) 
{ 
  char const   *errstr ;
  adns_status st ;
  char buf___17[20] ;
  int i ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 577
  st = csp_domain___8(vb___0, (char const   *)rrp->host);
  }
#line 577
  if (st) {
#line 577
    return (st);
  }
  {
#line 579
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 579
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 579
    if (! tmp) {
#line 579
      return ((adns_status )1);
    }
#line 579
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 580
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 580
    tmp___0 = adns_errtypeabbrev((adns_status )rrp->astatus);
#line 580
    tmp___1 = adns__vbuf_appendstr(vb___0, tmp___0);
    }
#line 580
    if (! tmp___1) {
#line 580
      return ((adns_status )1);
    }
#line 580
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 582
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %d ",
          (unsigned int const   )rrp->astatus);
  }
  {
#line 583
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 583
    tmp___2 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 583
    if (! tmp___2) {
#line 583
      return ((adns_status )1);
    }
#line 583
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 585
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 585
    tmp___3 = adns_errabbrev((adns_status )rrp->astatus);
#line 585
    tmp___4 = adns__vbuf_appendstr(vb___0, tmp___3);
    }
#line 585
    if (! tmp___4) {
#line 585
      return ((adns_status )1);
    }
#line 585
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 586
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 586
    tmp___5 = adns__vbuf_appendstr(vb___0, " ");
    }
#line 586
    if (! tmp___5) {
#line 586
      return ((adns_status )1);
    }
#line 586
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 588
  errstr = adns_strerror((adns_status )rrp->astatus);
#line 589
  tmp___6 = strlen(errstr);
#line 589
  st = csp_qstring___8(vb___0, errstr, (int )tmp___6);
  }
#line 589
  if (st) {
#line 589
    return (st);
  }
#line 591
  if (rrp->naddrs >= 0) {
    {
#line 592
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 592
      tmp___7 = adns__vbuf_appendstr(vb___0, " (");
      }
#line 592
      if (! tmp___7) {
#line 592
        return ((adns_status )1);
      }
#line 592
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 593
    i = 0;
    {
#line 593
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 593
      if (! (i < (int )rrp->naddrs)) {
#line 593
        goto while_break___5;
      }
      {
#line 594
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 594
        tmp___8 = adns__vbuf_appendstr(vb___0, " ");
        }
#line 594
        if (! tmp___8) {
#line 594
          return ((adns_status )1);
        }
#line 594
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 595
      st = csp_addr___8(vb___0, (adns_rr_addr const   *)(rrp->addrs + i));
#line 593
      i ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 597
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 597
      tmp___9 = adns__vbuf_appendstr(vb___0, " )");
      }
#line 597
      if (! tmp___9) {
#line 597
        return ((adns_status )1);
      }
#line 597
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
  } else {
    {
#line 599
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 599
      tmp___10 = adns__vbuf_appendstr(vb___0, " ?");
      }
#line 599
      if (! tmp___10) {
#line 599
        return ((adns_status )1);
      }
#line 599
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
#line 601
  return ((adns_status )0);
}
}
#line 604 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_hostaddr___8(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_hostaddr const   *rrp ;
  adns_status tmp ;

  {
  {
#line 605
  rrp = (adns_rr_hostaddr const   *)datap;
#line 607
  tmp = csp_hostaddr___8(vb___0, rrp);
  }
#line 607
  return (tmp);
}
}
#line 614 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_mx_raw___8(parseinfo const   *pai , int cbyte___3 , int max ,
                                 void *datap ) 
{ 
  byte const   *dgram ;
  adns_rr_intstr *rrp ;
  adns_status st ;
  int pref ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 616
  dgram = (byte const   *)pai->dgram;
#line 617
  rrp = (adns_rr_intstr *)datap;
#line 621
  if (cbyte___3 + 2 > max) {
#line 621
    return ((adns_status )104);
  }
#line 622
  pref = 0;
#line 622
  tmp = cbyte___3;
#line 622
  cbyte___3 ++;
#line 622
  pref |= (int )(((int const   )*(dgram + tmp) & 255) << 8);
#line 622
  tmp___0 = cbyte___3;
#line 622
  cbyte___3 ++;
#line 622
  pref |= (int )((int const   )*(dgram + tmp___0) & 255);
#line 623
  rrp->i = pref;
#line 624
  if ((pai->qu)->flags & 64) {
#line 624
    tmp___1 = 1;
  } else {
#line 624
    tmp___1 = 0;
  }
  {
#line 624
  st = pap_domain___8(pai, & cbyte___3, max, & rrp->str, (parsedomain_flags )tmp___1);
  }
#line 626
  if (st) {
#line 626
    return (st);
  }
#line 628
  if (cbyte___3 != max) {
#line 628
    return ((adns_status )104);
  }
#line 629
  return ((adns_status )0);
}
}
#line 632 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int di_mx_raw___8(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_intstr const   *ap ;
  adns_rr_intstr const   *bp ;

  {
#line 633
  ap = (adns_rr_intstr const   *)datap_a;
#line 633
  bp = (adns_rr_intstr const   *)datap_b;
#line 635
  if (ap->i < bp->i) {
#line 635
    return (0);
  }
#line 636
  if (ap->i > bp->i) {
#line 636
    return (1);
  }
#line 637
  return (0);
}
}
#line 644 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_mx___8(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  byte const   *dgram ;
  adns_rr_inthostaddr *rrp ;
  adns_status st ;
  int pref ;
  int tmp ;
  int tmp___0 ;

  {
#line 646
  dgram = (byte const   *)pai->dgram;
#line 647
  rrp = (adns_rr_inthostaddr *)datap;
#line 651
  if (cbyte___3 + 2 > max) {
#line 651
    return ((adns_status )104);
  }
  {
#line 652
  pref = 0;
#line 652
  tmp = cbyte___3;
#line 652
  cbyte___3 ++;
#line 652
  pref |= (int )(((int const   )*(dgram + tmp) & 255) << 8);
#line 652
  tmp___0 = cbyte___3;
#line 652
  cbyte___3 ++;
#line 652
  pref |= (int )((int const   )*(dgram + tmp___0) & 255);
#line 653
  rrp->i = pref;
#line 654
  st = pap_hostaddr___8(pai, & cbyte___3, max, & rrp->ha);
  }
#line 655
  if (st) {
#line 655
    return (st);
  }
#line 657
  if (cbyte___3 != max) {
#line 657
    return ((adns_status )104);
  }
#line 658
  return ((adns_status )0);
}
}
#line 661 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int di_mx___8(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_inthostaddr const   *ap ;
  adns_rr_inthostaddr const   *bp ;
  int tmp ;

  {
#line 662
  ap = (adns_rr_inthostaddr const   *)datap_a;
#line 662
  bp = (adns_rr_inthostaddr const   *)datap_b;
#line 664
  if (ap->i < bp->i) {
#line 664
    return (0);
  }
#line 665
  if (ap->i > bp->i) {
#line 665
    return (1);
  }
  {
#line 666
  tmp = dip_hostaddr___8(ads___7, & ap->ha, & bp->ha);
  }
#line 666
  return (tmp);
}
}
#line 673 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_inthostaddr___8(adns_query qu , void *datap ) 
{ 
  adns_rr_inthostaddr *rrp ;

  {
  {
#line 674
  rrp = (adns_rr_inthostaddr *)datap;
#line 676
  mfp_hostaddr___8(qu, & rrp->ha);
  }
#line 677
  return;
}
}
#line 679 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_inthostaddr___8(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_inthostaddr const   *rrp ;
  char buf___17[10] ;
  int tmp ;
  adns_status tmp___0 ;

  {
  {
#line 680
  rrp = (adns_rr_inthostaddr const   *)datap;
#line 683
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"%u ",
          rrp->i);
  }
  {
#line 684
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 684
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 684
    if (! tmp) {
#line 684
      return ((adns_status )1);
    }
#line 684
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 686
  tmp___0 = csp_hostaddr___8(vb___0, & rrp->ha);
  }
#line 686
  return (tmp___0);
}
}
#line 693 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_inthost___8(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_intstr const   *rrp ;
  char buf___17[10] ;
  int tmp ;
  adns_status tmp___0 ;

  {
  {
#line 694
  rrp = (adns_rr_intstr const   *)datap;
#line 697
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"%u ",
          rrp->i);
  }
  {
#line 698
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 698
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 698
    if (! tmp) {
#line 698
      return ((adns_status )1);
    }
#line 698
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 699
  tmp___0 = csp_domain___8(vb___0, (char const   *)rrp->str);
  }
#line 699
  return (tmp___0);
}
}
#line 706 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void icb_ptr___8(adns_query parent , adns_query child ) 
{ 
  adns_answer *cans ;
  adns_rr_addr const   *queried ;
  adns_rr_addr const   *found ;
  adns_state ads___7 ;
  int i ;
  int tmp ;

  {
#line 707
  cans = child->answer;
#line 709
  ads___7 = parent->ads;
#line 712
  if ((unsigned int )cans->status == 300U) {
    {
#line 713
    adns__query_fail(parent, (adns_status )100);
    }
#line 714
    return;
  } else
#line 712
  if ((unsigned int )cans->status == 301U) {
    {
#line 713
    adns__query_fail(parent, (adns_status )100);
    }
#line 714
    return;
  } else
#line 715
  if (cans->status) {
    {
#line 716
    adns__query_fail(parent, cans->status);
    }
#line 717
    return;
  }
#line 720
  queried = (adns_rr_addr const   *)(& parent->ctx.info.ptr_parent_addr);
#line 721
  i = 0;
#line 721
  found = (adns_rr_addr const   *)cans->rrs.addr;
  {
#line 721
  while (1) {
    while_continue: /* CIL Label */ ;
#line 721
    if (! (i < cans->nrrs)) {
#line 721
      goto while_break;
    }
#line 722
    if (queried->len == found->len) {
      {
#line 722
      tmp = memcmp((void const   *)(& queried->addr), (void const   *)(& found->addr),
                   (size_t )queried->len);
      }
#line 722
      if (! tmp) {
#line 724
        if (! parent->children.head) {
          {
#line 725
          adns__query_done(parent);
          }
#line 726
          return;
        } else {
          {
#line 728
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 728
            parent->next = (adns_query )0;
#line 728
            parent->back = ads___7->childw.tail;
#line 728
            if (ads___7->childw.tail) {
#line 728
              (ads___7->childw.tail)->next = parent;
            } else {
#line 728
              ads___7->childw.head = parent;
            }
#line 728
            ads___7->childw.tail = parent;
#line 728
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 729
          return;
        }
      }
    }
#line 721
    i ++;
#line 721
    found ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 734
  adns__query_fail(parent, (adns_status )100);
  }
#line 735
  return;
}
}
#line 739
static adns_status pa_ptr___8(parseinfo const   *pai , int dmstart , int max , void *datap ) ;
#line 739 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static char const   * const  expectdomain___8[2]  = {      (char const   */* const  */)"in-addr",      (char const   */* const  */)"arpa"};
#line 737 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_ptr___8(parseinfo const   *pai , int dmstart , int max , void *datap ) 
{ 
  char **rrp ;
  adns_status st ;
  adns_rr_addr *ap ;
  findlabel_state fls ;
  char *ep ;
  byte ipv[4] ;
  char labbuf[4] ;
  int cbyte___3 ;
  int i ;
  int lablen ;
  int labstart ;
  int l ;
  int id ;
  adns_query nqu ;
  qcontext ctx ;
  int tmp ;
  unsigned long tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  typeinfo const   *tmp___3 ;

  {
#line 741
  rrp = (char **)datap;
#line 752
  cbyte___3 = dmstart;
#line 753
  if ((pai->qu)->flags & 64) {
#line 753
    tmp = 1;
  } else {
#line 753
    tmp = 0;
  }
  {
#line 753
  st = pap_domain___8(pai, & cbyte___3, max, rrp, (parsedomain_flags )tmp);
  }
#line 755
  if (st) {
#line 755
    return (st);
  }
#line 756
  if (cbyte___3 != max) {
#line 756
    return ((adns_status )104);
  }
#line 758
  ap = & (pai->qu)->ctx.info.ptr_parent_addr;
#line 759
  if (! ap->len) {
    {
#line 760
    adns__findlabel_start(& fls, (adns_state )pai->ads, -1, (adns_query )pai->qu,
                          (byte const   *)(pai->qu)->query_dgram, (pai->qu)->query_dglen,
                          (pai->qu)->query_dglen, 12, (int *)0);
#line 763
    i = 0;
    }
    {
#line 763
    while (1) {
      while_continue: /* CIL Label */ ;
#line 763
      if (! (i < 4)) {
#line 763
        goto while_break;
      }
      {
#line 764
      st = adns__findlabel_next(& fls, & lablen, & labstart);
      }
#line 764
      if (! (! st)) {
        {
#line 764
        __assert_fail("!st", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                      764U, "pa_ptr");
        }
      }
#line 765
      if (lablen <= 0) {
#line 765
        return ((adns_status )200);
      } else
#line 765
      if (lablen > 3) {
#line 765
        return ((adns_status )200);
      }
      {
#line 766
      memcpy((void */* __restrict  */)(labbuf), (void const   */* __restrict  */)((pai->qu)->query_dgram + labstart),
             (size_t )lablen);
#line 767
      labbuf[lablen] = (char)0;
#line 768
      tmp___0 = strtoul((char const   */* __restrict  */)(labbuf), (char **/* __restrict  */)(& ep),
                        10);
#line 768
      ipv[3 - i] = (byte )tmp___0;
      }
#line 769
      if (*ep) {
#line 769
        return ((adns_status )200);
      }
#line 770
      if (lablen > 1) {
#line 770
        if ((int )*((pai->qu)->query_dgram + labstart) == 48) {
#line 771
          return ((adns_status )200);
        }
      }
#line 763
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 773
    i = 0;
    {
#line 773
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 773
      if (! ((unsigned long )i < sizeof(expectdomain___8) / sizeof(expectdomain___8[0]))) {
#line 773
        goto while_break___0;
      }
      {
#line 774
      st = adns__findlabel_next(& fls, & lablen, & labstart);
      }
#line 774
      if (! (! st)) {
        {
#line 774
        __assert_fail("!st", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                      774U, "pa_ptr");
        }
      }
      {
#line 775
      tmp___1 = strlen((char const   *)expectdomain___8[i]);
#line 775
      l = (int )tmp___1;
      }
#line 776
      if (lablen != l) {
#line 778
        return ((adns_status )200);
      } else {
        {
#line 776
        tmp___2 = memcmp((void const   *)((pai->qu)->query_dgram + labstart), (void const   *)expectdomain___8[i],
                         (size_t )l);
        }
#line 776
        if (tmp___2) {
#line 778
          return ((adns_status )200);
        }
      }
#line 773
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 780
    st = adns__findlabel_next(& fls, & lablen, (int *)0);
    }
#line 780
    if (! (! st)) {
      {
#line 780
      __assert_fail("!st", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                    780U, "pa_ptr");
      }
    }
#line 781
    if (lablen) {
#line 781
      return ((adns_status )200);
    }
    {
#line 783
    ap->len = (int )sizeof(struct sockaddr_in );
#line 784
    memset((void *)(& ap->addr), 0, sizeof(ap->addr.inet));
#line 785
    ap->addr.inet.sin_family = (sa_family_t )2;
#line 786
    ap->addr.inet.sin_addr.s_addr = htonl((uint32_t )(((((int )ipv[0] << 24) | ((int )ipv[1] << 16)) | ((int )ipv[2] << 8)) | (int )ipv[3]));
    }
  }
  {
#line 790
  st = adns__mkquery_frdgram((adns_state )pai->ads, & (pai->qu)->vb, & id, (byte const   *)pai->dgram,
                             (int )pai->dglen, dmstart, (adns_rrtype )65537, (adns_queryflags )16);
  }
#line 793
  if (st) {
#line 793
    return (st);
  }
  {
#line 795
  ctx.ext = (void *)0;
#line 796
  ctx.callback = & icb_ptr___8;
#line 797
  memset((void *)(& ctx.info), 0, sizeof(ctx.info));
#line 798
  tmp___3 = adns__findtype((adns_rrtype )65537);
#line 798
  st = adns__internal_submit((adns_state )pai->ads, & nqu, tmp___3, & (pai->qu)->vb,
                             id, (adns_queryflags )16, (struct timeval )pai->now,
                             (qcontext const   *)(& ctx));
  }
#line 801
  if (st) {
#line 801
    return (st);
  }
#line 803
  nqu->parent = (adns_query )pai->qu;
  {
#line 804
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 804
    nqu->siblings.next = (adns_query )0;
#line 804
    nqu->siblings.back = (pai->qu)->children.tail;
#line 804
    if ((pai->qu)->children.tail) {
#line 804
      ((pai->qu)->children.tail)->siblings.next = nqu;
    } else {
#line 804
      (pai->qu)->children.head = nqu;
    }
#line 804
    (pai->qu)->children.tail = nqu;
#line 804
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 805
  return ((adns_status )0);
}
}
#line 812 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_strpair___8(adns_query qu , void *datap ) 
{ 
  adns_rr_strpair *rrp ;

  {
  {
#line 813
  rrp = (adns_rr_strpair *)datap;
#line 815
  adns__makefinal_str(qu, & rrp->array[0]);
#line 816
  adns__makefinal_str(qu, & rrp->array[1]);
  }
#line 817
  return;
}
}
#line 823 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_intstrpair___8(adns_query qu , void *datap ) 
{ 
  adns_rr_intstrpair *rrp ;

  {
  {
#line 824
  rrp = (adns_rr_intstrpair *)datap;
#line 826
  adns__makefinal_str(qu, & rrp->array[0].str);
#line 827
  adns__makefinal_str(qu, & rrp->array[1].str);
  }
#line 828
  return;
}
}
#line 834 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_hinfo___8(parseinfo const   *pai , int cbyte___3 , int max ,
                                void *datap ) 
{ 
  adns_rr_intstrpair *rrp ;
  adns_status st ;
  int i ;

  {
#line 836
  rrp = (adns_rr_intstrpair *)datap;
#line 840
  i = 0;
  {
#line 840
  while (1) {
    while_continue: /* CIL Label */ ;
#line 840
    if (! (i < 2)) {
#line 840
      goto while_break;
    }
    {
#line 841
    st = pap_qstring___8(pai, & cbyte___3, max, & rrp->array[i].i, & rrp->array[i].str);
    }
#line 842
    if (st) {
#line 842
      return (st);
    }
#line 840
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 845
  if (cbyte___3 != max) {
#line 845
    return ((adns_status )104);
  }
#line 847
  return ((adns_status )0);
}
}
#line 854 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pap_mailbox822___8(parseinfo const   *pai , int *cbyte_io , int max ,
                                      char **mb_r ) 
{ 
  int lablen ;
  int labstart ;
  int i ;
  int needquote ;
  int c ;
  int r ;
  int neednorm ;
  unsigned char const   *p ;
  char *str ;
  findlabel_state fls ;
  adns_status st ;
  vbuf *vb___0 ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 863
  vb___0 = & (pai->qu)->vb;
#line 864
  vb___0->used = 0;
#line 865
  adns__findlabel_start(& fls, (adns_state )pai->ads, -1, (adns_query )pai->qu, (byte const   *)pai->dgram,
                        (int )pai->dglen, max, *cbyte_io, cbyte_io);
#line 869
  st = adns__findlabel_next(& fls, & lablen, & labstart);
  }
#line 870
  if (! lablen) {
    {
#line 871
    adns__vbuf_appendstr(vb___0, ".");
    }
#line 872
    goto x_ok;
  }
#line 875
  neednorm = 1;
#line 876
  i = 0;
#line 876
  needquote = 0;
#line 876
  p = (unsigned char const   *)(pai->dgram + labstart);
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (! (i < lablen)) {
#line 876
      goto while_break;
    }
#line 877
    tmp = p;
#line 877
    p ++;
#line 877
    c = (int )*tmp;
#line 878
    if ((c & -129) < 32) {
#line 878
      return ((adns_status )104);
    } else
#line 878
    if ((c & -129) == 127) {
#line 878
      return ((adns_status )104);
    }
#line 879
    if (c == 46) {
#line 879
      if (! neednorm) {
#line 879
        neednorm = 1;
      } else {
#line 879
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 880
    if (c == 32) {
#line 880
      needquote ++;
    } else
#line 880
    if (c >= 127) {
#line 880
      needquote ++;
    } else {
      {
#line 880
      tmp___0 = ctype_822special(c);
      }
#line 880
      if (tmp___0) {
#line 880
        needquote ++;
      } else {
#line 881
        neednorm = 0;
      }
    }
#line 876
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 884
  if (needquote) {
#line 884
    goto _L___0;
  } else
#line 884
  if (neednorm) {
    _L___0: /* CIL Label */ 
    {
#line 885
    r = adns__vbuf_ensure(vb___0, (lablen + needquote) + 4);
    }
#line 885
    if (! r) {
#line 885
      return ((adns_status )1);
    }
    {
#line 886
    adns__vbuf_appendq(vb___0, (byte const   *)"\"", 1);
#line 887
    i = 0;
#line 887
    needquote = 0;
#line 887
    p = (unsigned char const   *)(pai->dgram + labstart);
    }
    {
#line 887
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 887
      if (! (i < lablen)) {
#line 887
        goto while_break___0;
      }
#line 888
      c = (int )*p;
#line 889
      if (c == 34) {
        {
#line 889
        adns__vbuf_appendq(vb___0, (byte const   *)"\\", 1);
        }
      } else
#line 889
      if (c == 92) {
        {
#line 889
        adns__vbuf_appendq(vb___0, (byte const   *)"\\", 1);
        }
      }
      {
#line 890
      adns__vbuf_appendq(vb___0, p, 1);
#line 887
      i ++;
#line 887
      p ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 892
    adns__vbuf_appendq(vb___0, (byte const   *)"\"", 1);
    }
  } else {
    {
#line 894
    r = adns__vbuf_append(vb___0, (byte const   *)(pai->dgram + labstart), lablen);
    }
#line 894
    if (! r) {
#line 894
      return ((adns_status )1);
    }
  }
  {
#line 897
  r = adns__vbuf_appendstr(vb___0, "@");
  }
#line 897
  if (! r) {
#line 897
    return ((adns_status )1);
  }
  {
#line 899
  st = adns__parse_domain_more(& fls, (adns_state )pai->ads, (adns_query )pai->qu,
                               vb___0, (parsedomain_flags )0, (byte const   *)pai->dgram);
  }
#line 900
  if (st) {
#line 900
    return (st);
  }
  x_ok: 
  {
#line 903
  tmp___1 = adns__alloc_interim((adns_query )pai->qu, (size_t )(vb___0->used + 1));
#line 903
  str = (char *)tmp___1;
  }
#line 903
  if (! str) {
#line 903
    return ((adns_status )1);
  }
  {
#line 904
  memcpy((void */* __restrict  */)str, (void const   */* __restrict  */)vb___0->buf,
         (size_t )vb___0->used);
#line 905
  *(str + vb___0->used) = (char)0;
#line 906
  *mb_r = str;
  }
#line 907
  return ((adns_status )0);
}
}
#line 910 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pap_mailbox___8(parseinfo const   *pai , int *cbyte_io , int max ,
                                   char **mb_r ) 
{ 
  adns_status tmp ;
  adns_status tmp___0 ;

  {
#line 912
  if ((unsigned int const   )((pai->qu)->typei)->typekey & 131072U) {
    {
#line 913
    tmp = pap_mailbox822___8(pai, cbyte_io, max, mb_r);
    }
#line 913
    return (tmp);
  } else {
    {
#line 915
    tmp___0 = pap_domain___8(pai, cbyte_io, max, mb_r, (parsedomain_flags )1);
    }
#line 915
    return (tmp___0);
  }
}
}
#line 919 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status csp_mailbox___8(vbuf *vb___0 , char const   *mailbox ) 
{ 
  adns_status tmp ;

  {
  {
#line 920
  tmp = csp_domain___8(vb___0, mailbox);
  }
#line 920
  return (tmp);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_rp___8(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  adns_rr_strpair *rrp ;
  adns_status st ;

  {
  {
#line 929
  rrp = (adns_rr_strpair *)datap;
#line 932
  st = pap_mailbox___8(pai, & cbyte___3, max, & rrp->array[0]);
  }
#line 933
  if (st) {
#line 933
    return (st);
  }
  {
#line 935
  st = pap_domain___8(pai, & cbyte___3, max, & rrp->array[1], (parsedomain_flags )1);
  }
#line 936
  if (st) {
#line 936
    return (st);
  }
#line 938
  if (cbyte___3 != max) {
#line 938
    return ((adns_status )104);
  }
#line 939
  return ((adns_status )0);
}
}
#line 942 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_rp___8(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_strpair const   *rrp ;
  adns_status st ;
  int tmp ;

  {
  {
#line 943
  rrp = (adns_rr_strpair const   *)datap;
#line 946
  st = csp_mailbox___8(vb___0, (char const   *)rrp->array[0]);
  }
#line 946
  if (st) {
#line 946
    return (st);
  }
  {
#line 947
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 947
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 947
    if (! tmp) {
#line 947
      return ((adns_status )1);
    }
#line 947
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 948
  st = csp_domain___8(vb___0, (char const   *)rrp->array[1]);
  }
#line 948
  if (st) {
#line 948
    return (st);
  }
#line 950
  return ((adns_status )0);
}
}
#line 957 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_soa___8(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  adns_rr_soa *rrp ;
  byte const   *dgram ;
  adns_status st ;
  int msw ;
  int lsw ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 959
  rrp = (adns_rr_soa *)datap;
#line 960
  dgram = (byte const   *)pai->dgram;
#line 964
  if ((pai->qu)->flags & 64) {
#line 964
    tmp = 1;
  } else {
#line 964
    tmp = 0;
  }
  {
#line 964
  st = pap_domain___8(pai, & cbyte___3, max, & rrp->mname, (parsedomain_flags )tmp);
  }
#line 966
  if (st) {
#line 966
    return (st);
  }
  {
#line 968
  st = pap_mailbox___8(pai, & cbyte___3, max, & rrp->rname);
  }
#line 969
  if (st) {
#line 969
    return (st);
  }
#line 971
  if (cbyte___3 + 20 != max) {
#line 971
    return ((adns_status )104);
  }
#line 973
  i = 0;
  {
#line 973
  while (1) {
    while_continue: /* CIL Label */ ;
#line 973
    if (! (i < 5)) {
#line 973
      goto while_break;
    }
#line 974
    msw = 0;
#line 974
    tmp___0 = cbyte___3;
#line 974
    cbyte___3 ++;
#line 974
    msw |= (int )(((int const   )*(dgram + tmp___0) & 255) << 8);
#line 974
    tmp___1 = cbyte___3;
#line 974
    cbyte___3 ++;
#line 974
    msw |= (int )((int const   )*(dgram + tmp___1) & 255);
#line 975
    lsw = 0;
#line 975
    tmp___2 = cbyte___3;
#line 975
    cbyte___3 ++;
#line 975
    lsw |= (int )(((int const   )*(dgram + tmp___2) & 255) << 8);
#line 975
    tmp___3 = cbyte___3;
#line 975
    cbyte___3 ++;
#line 975
    lsw |= (int )((int const   )*(dgram + tmp___3) & 255);
#line 976
    *(& rrp->serial + i) = (unsigned long )((msw << 16) | lsw);
#line 973
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 979
  return ((adns_status )0);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_soa___8(adns_query qu , void *datap ) 
{ 
  adns_rr_soa *rrp ;

  {
  {
#line 983
  rrp = (adns_rr_soa *)datap;
#line 985
  adns__makefinal_str(qu, & rrp->mname);
#line 986
  adns__makefinal_str(qu, & rrp->rname);
  }
#line 987
  return;
}
}
#line 989 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_soa___8(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_soa const   *rrp ;
  char buf___17[20] ;
  int i ;
  adns_status st ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 990
  rrp = (adns_rr_soa const   *)datap;
#line 995
  st = csp_domain___8(vb___0, (char const   *)rrp->mname);
  }
#line 995
  if (st) {
#line 995
    return (st);
  }
  {
#line 996
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 996
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 996
    if (! tmp) {
#line 996
      return ((adns_status )1);
    }
#line 996
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 997
  st = csp_mailbox___8(vb___0, (char const   *)rrp->rname);
  }
#line 997
  if (st) {
#line 997
    return (st);
  }
#line 999
  i = 0;
  {
#line 999
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 999
    if (! (i < 5)) {
#line 999
      goto while_break___0;
    }
    {
#line 1000
    sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %lu",
            *(& rrp->serial + i));
    }
    {
#line 1001
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1001
      tmp___0 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
      }
#line 1001
      if (! tmp___0) {
#line 1001
        return ((adns_status )1);
      }
#line 1001
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 999
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1004
  return ((adns_status )0);
}
}
#line 1011 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status qdpl_srv___8(adns_state ads___7 , char const   **p_io , char const   *pe ,
                                int labelnum , char *label_r , int *ll_io , adns_queryflags flags ,
                                typeinfo const   *typei ) 
{ 
  int useflags ;
  char const   *p_orig ;
  adns_status st ;
  int ll ;
  void *tmp ;

  {
#line 1020
  if (labelnum < 2) {
#line 1020
    if (! ((unsigned int )flags & 16U)) {
#line 1021
      useflags = 16;
#line 1022
      p_orig = *p_io;
    } else {
#line 1024
      useflags = (int )flags;
#line 1025
      p_orig = (char const   *)0;
    }
  } else {
#line 1024
    useflags = (int )flags;
#line 1025
    p_orig = (char const   *)0;
  }
  {
#line 1027
  st = adns__qdpl_normal(ads___7, p_io, pe, labelnum, (char *)label_r, ll_io, (adns_queryflags )useflags,
                         typei);
  }
#line 1028
  if (st) {
#line 1028
    return (st);
  }
#line 1030
  if (p_orig) {
#line 1031
    ll = *ll_io;
#line 1032
    if (! ll) {
#line 1033
      return ((adns_status )201);
    } else
#line 1032
    if ((int )*(label_r + 0) != 95) {
#line 1033
      return ((adns_status )201);
    }
    {
#line 1034
    tmp = memchr((void const   *)(p_orig + 1), '\\', (size_t )(pe - (p_orig + 1)));
    }
#line 1034
    if (tmp) {
#line 1035
      return ((adns_status )201);
    }
  }
#line 1037
  return ((adns_status )0);
}
}
#line 1040 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pap_srv_begin___8(parseinfo const   *pai , int *cbyte_io , int max ,
                                     adns_rr_srvha *rrp ) 
{ 
  byte const   *dgram ;
  int ti ;
  int cbyte___3 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1043
  dgram = (byte const   *)pai->dgram;
#line 1046
  cbyte___3 = *cbyte_io;
#line 1047
  tmp = *cbyte_io + 6;
#line 1047
  *cbyte_io = tmp;
#line 1047
  if (tmp > max) {
#line 1047
    return ((adns_status )104);
  }
#line 1049
  ti = 0;
#line 1049
  tmp___0 = cbyte___3;
#line 1049
  cbyte___3 ++;
#line 1049
  ti |= (int )(((int const   )*(dgram + tmp___0) & 255) << 8);
#line 1049
  tmp___1 = cbyte___3;
#line 1049
  cbyte___3 ++;
#line 1049
  ti |= (int )((int const   )*(dgram + tmp___1) & 255);
#line 1049
  rrp->priority = ti;
#line 1050
  ti = 0;
#line 1050
  tmp___2 = cbyte___3;
#line 1050
  cbyte___3 ++;
#line 1050
  ti |= (int )(((int const   )*(dgram + tmp___2) & 255) << 8);
#line 1050
  tmp___3 = cbyte___3;
#line 1050
  cbyte___3 ++;
#line 1050
  ti |= (int )((int const   )*(dgram + tmp___3) & 255);
#line 1050
  rrp->weight = ti;
#line 1051
  ti = 0;
#line 1051
  tmp___4 = cbyte___3;
#line 1051
  cbyte___3 ++;
#line 1051
  ti |= (int )(((int const   )*(dgram + tmp___4) & 255) << 8);
#line 1051
  tmp___5 = cbyte___3;
#line 1051
  cbyte___3 ++;
#line 1051
  ti |= (int )((int const   )*(dgram + tmp___5) & 255);
#line 1051
  rrp->port = ti;
#line 1052
  return ((adns_status )0);
}
}
#line 1055 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_srvraw___8(parseinfo const   *pai , int cbyte___3 , int max ,
                                 void *datap ) 
{ 
  adns_rr_srvraw *rrp ;
  adns_status st ;
  int tmp ;

  {
  {
#line 1057
  rrp = (adns_rr_srvraw *)datap;
#line 1060
  st = pap_srv_begin___8(pai, & cbyte___3, max, (adns_rr_srvha *)datap);
  }
#line 1061
  if (st) {
#line 1061
    return (st);
  }
#line 1063
  if ((pai->qu)->flags & 64) {
#line 1063
    tmp = 1;
  } else {
#line 1063
    tmp = 0;
  }
  {
#line 1063
  st = pap_domain___8(pai, & cbyte___3, max, & rrp->host, (parsedomain_flags )tmp);
  }
#line 1065
  if (st) {
#line 1065
    return (st);
  }
#line 1067
  if (cbyte___3 != max) {
#line 1067
    return ((adns_status )104);
  }
#line 1068
  return ((adns_status )0);
}
}
#line 1071 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_srvha___8(parseinfo const   *pai , int cbyte___3 , int max ,
                                void *datap ) 
{ 
  adns_rr_srvha *rrp ;
  adns_status st ;

  {
  {
#line 1073
  rrp = (adns_rr_srvha *)datap;
#line 1076
  st = pap_srv_begin___8(pai, & cbyte___3, max, (adns_rr_srvha *)datap);
  }
#line 1076
  if (st) {
#line 1076
    return (st);
  }
  {
#line 1077
  st = pap_hostaddr___8(pai, & cbyte___3, max, & rrp->ha);
  }
#line 1077
  if (st) {
#line 1077
    return (st);
  }
#line 1078
  if (cbyte___3 != max) {
#line 1078
    return ((adns_status )104);
  }
#line 1079
  return ((adns_status )0);
}
}
#line 1082 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_srvraw___8(adns_query qu , void *datap ) 
{ 
  adns_rr_srvraw *rrp ;

  {
  {
#line 1083
  rrp = (adns_rr_srvraw *)datap;
#line 1084
  adns__makefinal_str(qu, & rrp->host);
  }
#line 1085
  return;
}
}
#line 1087 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_srvha___8(adns_query qu , void *datap ) 
{ 
  adns_rr_srvha *rrp ;

  {
  {
#line 1088
  rrp = (adns_rr_srvha *)datap;
#line 1089
  mfp_hostaddr___8(qu, & rrp->ha);
  }
#line 1090
  return;
}
}
#line 1092 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int di_srv___8(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_srvraw const   *ap ;
  adns_rr_srvraw const   *bp ;

  {
#line 1093
  ap = (adns_rr_srvraw const   *)datap_a;
#line 1093
  bp = (adns_rr_srvraw const   *)datap_b;
#line 1096
  if (ap->priority < bp->priority) {
#line 1096
    return (0);
  }
#line 1097
  if (ap->priority > bp->priority) {
#line 1097
    return (1);
  }
#line 1098
  return (0);
}
}
#line 1101 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status csp_srv_begin___8(vbuf *vb___0 , adns_rr_srvha const   *rrp ) 
{ 
  char buf___17[30] ;
  int tmp ;

  {
  {
#line 1104
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"%u %u %u ",
          rrp->priority, rrp->weight, rrp->port);
  }
  {
#line 1105
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1105
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 1105
    if (! tmp) {
#line 1105
      return ((adns_status )1);
    }
#line 1105
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1106
  return ((adns_status )0);
}
}
#line 1109 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_srvraw___8(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_srvraw const   *rrp ;
  adns_status st ;
  adns_status tmp ;

  {
  {
#line 1110
  rrp = (adns_rr_srvraw const   *)datap;
#line 1113
  st = csp_srv_begin___8(vb___0, (adns_rr_srvha const   *)((void const   *)rrp));
  }
#line 1113
  if (st) {
#line 1113
    return (st);
  }
  {
#line 1114
  tmp = csp_domain___8(vb___0, (char const   *)rrp->host);
  }
#line 1114
  return (tmp);
}
}
#line 1117 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_srvha___8(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_srvha const   *rrp ;
  adns_status st ;
  adns_status tmp ;

  {
  {
#line 1118
  rrp = (adns_rr_srvha const   *)datap;
#line 1121
  st = csp_srv_begin___8(vb___0, (adns_rr_srvha const   *)datap);
  }
#line 1121
  if (st) {
#line 1121
    return (st);
  }
  {
#line 1122
  tmp = csp_hostaddr___8(vb___0, & rrp->ha);
  }
#line 1122
  return (tmp);
}
}
#line 1125 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void postsort_srv___8(adns_state ads___7 , void *array , int nrrs , struct typeinfo  const  *typei ) 
{ 
  char *workbegin ;
  char *workend ;
  char *search ;
  char *arrayend ;
  adns_rr_srvha const   *rr ;
  union __anonunion_rrtmp_89___8 rrtmp ;
  int cpriority ;
  int totalweight ;
  int runtotal ;
  long randval ;

  {
#line 1138
  workbegin = (char *)array;
#line 1138
  arrayend = workbegin + typei->rrsz * (int const   )nrrs;
  {
#line 1138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1138
    if (! ((unsigned long )workbegin < (unsigned long )arrayend)) {
#line 1138
      goto while_break;
    }
#line 1141
    rr = (adns_rr_srvha const   *)((void *)workbegin);
#line 1141
    cpriority = (int )rr->priority;
#line 1143
    workend = workbegin;
#line 1143
    totalweight = 0;
    {
#line 1143
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1143
      if ((unsigned long )workend < (unsigned long )arrayend) {
#line 1143
        rr = (adns_rr_srvha const   *)((void *)workend);
#line 1143
        if (! (rr->priority == (int const   )cpriority)) {
#line 1143
          goto while_break___0;
        }
      } else {
#line 1143
        goto while_break___0;
      }
#line 1146
      totalweight += (int )rr->weight;
#line 1143
      workend += typei->rrsz;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1155
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1155
      if (! ((unsigned long )(workbegin + typei->rrsz) < (unsigned long )workend)) {
#line 1155
        goto while_break___1;
      }
      {
#line 1159
      randval = nrand48((unsigned short *)(ads___7->rand48xsubi));
#line 1160
      randval %= (long )(totalweight + 1);
#line 1167
      search = workbegin;
#line 1167
      runtotal = 0;
      }
      {
#line 1167
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1167
        rr = (adns_rr_srvha const   *)((void *)search);
#line 1167
        runtotal += (int )rr->weight;
#line 1167
        if (! ((long )runtotal < randval)) {
#line 1167
          goto while_break___2;
        }
#line 1167
        search += typei->rrsz;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1170
      if (! ((unsigned long )search < (unsigned long )arrayend)) {
        {
#line 1170
        __assert_fail("search < arrayend", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                      1170U, "postsort_srv");
        }
      }
#line 1171
      totalweight -= (int )rr->weight;
#line 1172
      if ((unsigned long )search != (unsigned long )workbegin) {
        {
#line 1173
        memcpy((void */* __restrict  */)(& rrtmp), (void const   */* __restrict  */)workbegin,
               (size_t )typei->rrsz);
#line 1174
        memcpy((void */* __restrict  */)workbegin, (void const   */* __restrict  */)search,
               (size_t )typei->rrsz);
#line 1175
        memcpy((void */* __restrict  */)search, (void const   */* __restrict  */)(& rrtmp),
               (size_t )typei->rrsz);
        }
      }
#line 1155
      workbegin += typei->rrsz;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1138
    workbegin = workend;
  }
  while_break: /* CIL Label */ ;
  }
#line 1184
  return;
}
}
#line 1190 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_byteblock___8(adns_query qu , void *datap ) 
{ 
  adns_rr_byteblock *rrp ;
  void *bytes___3 ;

  {
  {
#line 1191
  rrp = (adns_rr_byteblock *)datap;
#line 1192
  bytes___3 = (void *)rrp->data;
#line 1193
  adns__makefinal_block(qu, & bytes___3, (size_t )rrp->len);
#line 1194
  rrp->data = (unsigned char *)bytes___3;
  }
#line 1195
  return;
}
}
#line 1201 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_opaque___8(parseinfo const   *pai , int cbyte___3 , int max ,
                                 void *datap ) 
{ 
  adns_rr_byteblock *rrp ;
  void *tmp ;

  {
  {
#line 1203
  rrp = (adns_rr_byteblock *)datap;
#line 1205
  rrp->len = max - cbyte___3;
#line 1206
  tmp = adns__alloc_interim((adns_query )pai->qu, (size_t )rrp->len);
#line 1206
  rrp->data = (unsigned char *)tmp;
  }
#line 1207
  if (! rrp->data) {
#line 1207
    return ((adns_status )1);
  }
  {
#line 1208
  memcpy((void */* __restrict  */)rrp->data, (void const   */* __restrict  */)(pai->dgram + cbyte___3),
         (size_t )rrp->len);
  }
#line 1209
  return ((adns_status )0);
}
}
#line 1212 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_opaque___8(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_byteblock const   *rrp ;
  char buf___17[10] ;
  int l ;
  unsigned char *p ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1213
  rrp = (adns_rr_byteblock const   *)datap;
#line 1218
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"\\# %d",
          rrp->len);
  }
  {
#line 1219
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1219
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 1219
    if (! tmp) {
#line 1219
      return ((adns_status )1);
    }
#line 1219
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1221
  l = (int )rrp->len;
#line 1221
  p = (unsigned char *)rrp->data;
  {
#line 1221
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1221
    if (! (l >= 4)) {
#line 1221
      goto while_break___0;
    }
    {
#line 1224
    sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %02x%02x%02x%02x",
            (int )*(p + 0), (int )*(p + 1), (int )*(p + 2), (int )*(p + 3));
    }
    {
#line 1225
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1225
      tmp___0 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
      }
#line 1225
      if (! tmp___0) {
#line 1225
        return ((adns_status )1);
      }
#line 1225
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1221
    l -= 4;
#line 1221
    p += 4;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1227
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1227
    if (! (l > 0)) {
#line 1227
      goto while_break___2;
    }
    {
#line 1230
    sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %02x",
            (int )*p);
    }
    {
#line 1231
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 1231
      tmp___1 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
      }
#line 1231
      if (! tmp___1) {
#line 1231
        return ((adns_status )1);
      }
#line 1231
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1227
    l --;
#line 1227
    p ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1233
  return ((adns_status )0);
}
}
#line 1240 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_flat___8(adns_query qu , void *data___0 ) 
{ 


  {
#line 1240
  return;
}
}
#line 1261 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static typeinfo const   typeinfos___8[17]  = 
#line 1261
  {      {(adns_rrtype )1, "A", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.inaddr)),
      & mf_flat___8, & cs_inaddr___8, & pa_inaddr___8, & di_inaddr___8, (adns_status (*)(adns_state ads ,
                                                                                         char const   **p_io ,
                                                                                         char const   *pe ,
                                                                                         int labelnum ,
                                                                                         char *label_r ,
                                                                                         int *ll_io ,
                                                                                         adns_queryflags flags ,
                                                                                         struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )2,
      "NS", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___8, & cs_domain___8,
      & pa_host_raw___8, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )5,
      "CNAME", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___8,
      & cs_domain___8, & pa_dom_raw___8, (int (*)(adns_state ads , void const   *datap_a ,
                                                  void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                              char const   **p_io ,
                                                                                              char const   *pe ,
                                                                                              int labelnum ,
                                                                                              char *label_r ,
                                                                                              int *ll_io ,
                                                                                              adns_queryflags flags ,
                                                                                              struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )6,
      "SOA", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.soa)), & mf_soa___8, & cs_soa___8,
      & pa_soa___8, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )12,
      "PTR", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___8, & cs_domain___8,
      & pa_host_raw___8, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )13,
      "HINFO", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.intstrpair)),
      & mf_intstrpair___8, & cs_hinfo___8, & pa_hinfo___8, (int (*)(adns_state ads ,
                                                                    void const   *datap_a ,
                                                                    void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )15,
      "MX", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.intstr)), & mf_intstr___8,
      & cs_inthost___8, & pa_mx_raw___8, & di_mx_raw___8, (adns_status (*)(adns_state ads ,
                                                                           char const   **p_io ,
                                                                           char const   *pe ,
                                                                           int labelnum ,
                                                                           char *label_r ,
                                                                           int *ll_io ,
                                                                           adns_queryflags flags ,
                                                                           struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )16,
      "TXT", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.manyistr)),
      & mf_manyistr___8, & cs_txt___8, & pa_txt___8, (int (*)(adns_state ads , void const   *datap_a ,
                                                              void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )17,
      "RP", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.strpair)), & mf_strpair___8,
      & cs_rp___8, & pa_rp___8, (int (*)(adns_state ads , void const   *datap_a ,
                                         void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                     char const   **p_io ,
                                                                                     char const   *pe ,
                                                                                     int labelnum ,
                                                                                     char *label_r ,
                                                                                     int *ll_io ,
                                                                                     adns_queryflags flags ,
                                                                                     struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )33,
      "SRV", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.srvraw)), & mf_srvraw___8,
      & cs_srvraw___8, & pa_srvraw___8, & di_srv___8, & qdpl_srv___8, & postsort_srv___8}, 
        {(adns_rrtype )65537,
      "A", "addr", (int )sizeof(*(((adns_answer *)0)->rrs.addr)), & mf_flat___8, & cs_addr___8,
      & pa_addr___8, & di_addr___8, (adns_status (*)(adns_state ads , char const   **p_io ,
                                                     char const   *pe , int labelnum ,
                                                     char *label_r , int *ll_io ,
                                                     adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65538,
      "NS", "+addr", (int )sizeof(*(((adns_answer *)0)->rrs.hostaddr)), & mf_hostaddr___8,
      & cs_hostaddr___8, & pa_hostaddr___8, & di_hostaddr___8, (adns_status (*)(adns_state ads ,
                                                                                char const   **p_io ,
                                                                                char const   *pe ,
                                                                                int labelnum ,
                                                                                char *label_r ,
                                                                                int *ll_io ,
                                                                                adns_queryflags flags ,
                                                                                struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65548,
      "PTR", "checked", (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___8,
      & cs_domain___8, & pa_ptr___8, (int (*)(adns_state ads , void const   *datap_a ,
                                              void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                          char const   **p_io ,
                                                                                          char const   *pe ,
                                                                                          int labelnum ,
                                                                                          char *label_r ,
                                                                                          int *ll_io ,
                                                                                          adns_queryflags flags ,
                                                                                          struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65551,
      "MX", "+addr", (int )sizeof(*(((adns_answer *)0)->rrs.inthostaddr)), & mf_inthostaddr___8,
      & cs_inthostaddr___8, & pa_mx___8, & di_mx___8, (adns_status (*)(adns_state ads ,
                                                                       char const   **p_io ,
                                                                       char const   *pe ,
                                                                       int labelnum ,
                                                                       char *label_r ,
                                                                       int *ll_io ,
                                                                       adns_queryflags flags ,
                                                                       struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65569,
      "SRV", "+addr", (int )sizeof(*(((adns_answer *)0)->rrs.srvha)), & mf_srvha___8,
      & cs_srvha___8, & pa_srvha___8, & di_srv___8, & qdpl_srv___8, & postsort_srv___8}, 
        {(adns_rrtype )131078,
      "SOA", "822", (int )sizeof(*(((adns_answer *)0)->rrs.soa)), & mf_soa___8, & cs_soa___8,
      & pa_soa___8, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )131089,
      "RP", "822", (int )sizeof(*(((adns_answer *)0)->rrs.strpair)), & mf_strpair___8,
      & cs_rp___8, & pa_rp___8, (int (*)(adns_state ads , void const   *datap_a ,
                                         void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                     char const   **p_io ,
                                                                                     char const   *pe ,
                                                                                     int labelnum ,
                                                                                     char *label_r ,
                                                                                     int *ll_io ,
                                                                                     adns_queryflags flags ,
                                                                                     struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}};
#line 1288 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static struct typeinfo  const  typeinfo_unknown___8  = 
#line 1288
     {(adns_rrtype )262144, (char const   *)0, "unknown", (int )sizeof(*(((adns_answer *)0)->rrs.byteblock)),
    & mf_byteblock___8, & cs_opaque___8, & pa_opaque___8, (int (*)(adns_state ads ,
                                                                   void const   *datap_a ,
                                                                   void const   *datap_b ))0,
    (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                     char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
    (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0};
#line 233 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/general.c"
static struct sinfo  const  sinfos___8[24]  = 
#line 233 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/general.c"
  {      {(adns_status )0, "ok", "OK"}, 
        {(adns_status )1, "nomemory", "Out of memory"}, 
        {(adns_status )2, "unknownrrtype", "Query not implemented in DNS library"}, 
        {(adns_status )3, "systemfail", "General resolver or system failure"}, 
        {(adns_status )30, "timeout", "DNS query timed out"}, 
        {(adns_status )31, "allservfail", "All nameservers failed"}, 
        {(adns_status )32, "norecurse", "Recursion denied by nameserver"}, 
        {(adns_status )33, "invalidresponse", "Nameserver sent bad response"}, 
        {(adns_status )34, "unknownformat", "Nameserver used unknown format"}, 
        {(adns_status )60, "rcodeservfail", "Nameserver reports failure"}, 
        {(adns_status )61, "rcodeformaterror", "Query not understood by nameserver"}, 
        {(adns_status )62,
      "rcodenotimplemented", "Query not implemented by nameserver"}, 
        {(adns_status )63, "rcoderefused", "Query refused by nameserver"}, 
        {(adns_status )64, "rcodeunknown", "Nameserver sent unknown response code"}, 
        {(adns_status )100, "inconsistent", "Inconsistent resource records in DNS"}, 
        {(adns_status )101, "prohibitedcname", "DNS alias found where canonical name wanted"}, 
        {(adns_status )102,
      "answerdomaininvalid", "Found syntactically invalid domain name"}, 
        {(adns_status )103, "answerdomaintoolong", "Found overly-long domain name"}, 
        {(adns_status )104, "invaliddata", "Found invalid DNS data"}, 
        {(adns_status )200, "querydomainwrong", "Domain invalid for particular DNS query type"}, 
        {(adns_status )201,
      "querydomaininvalid", "Domain name is syntactically invalid"}, 
        {(adns_status )202, "querydomaintoolong", "Domain name or component is too long"}, 
        {(adns_status )300,
      "nxdomain", "No such domain"}, 
        {(adns_status )301, "nodata", "No such data"}};
#line 270 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/general.c"
static int si_compar___8(void const   *key , void const   *elem ) 
{ 
  adns_status const   *st ;
  struct sinfo  const  *si ;
  int tmp ;
  int tmp___0 ;

  {
#line 271
  st = (adns_status const   *)key;
#line 272
  si = (struct sinfo  const  *)elem;
#line 274
  if ((unsigned int const   )*st < (unsigned int const   )si->st) {
#line 274
    tmp___0 = -1;
  } else {
#line 274
    if ((unsigned int const   )*st > (unsigned int const   )si->st) {
#line 274
      tmp = 1;
    } else {
#line 274
      tmp = 0;
    }
#line 274
    tmp___0 = tmp;
  }
#line 274
  return (tmp___0);
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/general.c"
static struct sinfo  const  *findsinfo___8(adns_status st ) 
{ 
  void *tmp ;

  {
  {
#line 278
  tmp = bsearch((void const   *)(& st), (void const   *)(sinfos___8), sizeof(sinfos___8) / sizeof(sinfos___8[0]),
                sizeof(sinfos___8[0]), & si_compar___8);
  }
#line 278
  return ((struct sinfo  const  *)tmp);
}
}
#line 299 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/general.c"
static struct stinfo  const  stinfos___8[7]  = {      {(adns_status )0, "ok"}, 
        {(adns_status )29, "localfail"}, 
        {(adns_status )59, "remotefail"}, 
        {(adns_status )99, "tempfail"}, 
        {(adns_status )199, "misconfig"}, 
        {(adns_status )299, "misquery"}, 
        {(adns_status )499, "permfail"}};
#line 312 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/general.c"
static int sti_compar___8(void const   *key , void const   *elem ) 
{ 
  adns_status const   *st ;
  struct stinfo  const  *sti ;
  adns_status here ;
  adns_status min ;
  adns_status max ;
  int tmp ;
  int tmp___0 ;

  {
#line 313
  st = (adns_status const   *)key;
#line 314
  sti = (struct stinfo  const  *)elem;
#line 318
  here = (adns_status )*st;
#line 319
  if ((unsigned long )sti == (unsigned long )(stinfos___8)) {
#line 319
    min = (adns_status )0;
  } else {
#line 319
    min = (adns_status )((unsigned int const   )(sti + -1)->stmax + 1U);
  }
#line 320
  max = (adns_status )sti->stmax;
#line 322
  if ((unsigned int )here < (unsigned int )min) {
#line 322
    tmp___0 = -1;
  } else {
#line 322
    if ((unsigned int )here > (unsigned int )max) {
#line 322
      tmp = 1;
    } else {
#line 322
      tmp = 0;
    }
#line 322
    tmp___0 = tmp;
  }
#line 322
  return (tmp___0);
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/transmit.c"
static adns_status mkquery_header___8(adns_state ads___7 , vbuf *vb___0 , int *id_r ,
                                      int qdlen ) 
{ 
  int id ;
  byte *rqp ;
  int tmp ;
  int tmp___0 ;
  byte *tmp___1 ;
  byte *tmp___2 ;
  byte *tmp___3 ;
  byte *tmp___4 ;
  byte *tmp___5 ;
  byte *tmp___6 ;
  byte *tmp___7 ;
  byte *tmp___8 ;
  byte *tmp___9 ;
  byte *tmp___10 ;
  byte *tmp___11 ;
  byte *tmp___12 ;

  {
  {
#line 46
  tmp = adns__vbuf_ensure(vb___0, (12 + qdlen) + 4);
  }
#line 46
  if (! tmp) {
#line 46
    return ((adns_status )1);
  }
#line 48
  vb___0->used = 0;
#line 49
  rqp = vb___0->buf + vb___0->used;
#line 51
  tmp___0 = ads___7->nextid;
#line 51
  (ads___7->nextid) ++;
#line 51
  id = tmp___0 & 65535;
#line 51
  *id_r = id;
#line 52
  tmp___1 = rqp;
#line 52
  rqp ++;
#line 52
  *tmp___1 = (byte )((id >> 8) & 255);
#line 52
  tmp___2 = rqp;
#line 52
  rqp ++;
#line 52
  *tmp___2 = (byte )(id & 255);
#line 53
  tmp___3 = rqp;
#line 53
  rqp ++;
#line 53
  *tmp___3 = (byte )1;
#line 54
  tmp___4 = rqp;
#line 54
  rqp ++;
#line 54
  *tmp___4 = (byte )0;
#line 55
  tmp___5 = rqp;
#line 55
  rqp ++;
#line 55
  *tmp___5 = (byte )((1 >> 8) & 255);
#line 55
  tmp___6 = rqp;
#line 55
  rqp ++;
#line 55
  *tmp___6 = (byte )1;
#line 56
  tmp___7 = rqp;
#line 56
  rqp ++;
#line 56
  *tmp___7 = (byte )0;
#line 56
  tmp___8 = rqp;
#line 56
  rqp ++;
#line 56
  *tmp___8 = (byte )0;
#line 57
  tmp___9 = rqp;
#line 57
  rqp ++;
#line 57
  *tmp___9 = (byte )0;
#line 57
  tmp___10 = rqp;
#line 57
  rqp ++;
#line 57
  *tmp___10 = (byte )0;
#line 58
  tmp___11 = rqp;
#line 58
  rqp ++;
#line 58
  *tmp___11 = (byte )0;
#line 58
  tmp___12 = rqp;
#line 58
  rqp ++;
#line 58
  *tmp___12 = (byte )0;
#line 60
  vb___0->used = (int )(rqp - vb___0->buf);
#line 62
  return ((adns_status )0);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/transmit.c"
static adns_status mkquery_footer___8(vbuf *vb___0 , adns_rrtype type ) 
{ 
  byte *rqp ;
  byte *tmp ;
  byte *tmp___0 ;
  byte *tmp___1 ;
  byte *tmp___2 ;

  {
#line 68
  rqp = vb___0->buf + vb___0->used;
#line 69
  tmp = rqp;
#line 69
  rqp ++;
#line 69
  *tmp = (byte )((((unsigned int )type & 65535U) >> 8) & 255U);
#line 69
  tmp___0 = rqp;
#line 69
  rqp ++;
#line 69
  *tmp___0 = (byte )(((unsigned int )type & 65535U) & 255U);
#line 70
  tmp___1 = rqp;
#line 70
  rqp ++;
#line 70
  *tmp___1 = (byte )((1 >> 8) & 255);
#line 70
  tmp___2 = rqp;
#line 70
  rqp ++;
#line 70
  *tmp___2 = (byte )1;
#line 71
  vb___0->used = (int )(rqp - vb___0->buf);
#line 72
  if (! (vb___0->used <= vb___0->avail)) {
    {
#line 72
    __assert_fail("vb->used <= vb->avail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/transmit.c",
                  72U, "mkquery_footer");
    }
  }
#line 74
  return ((adns_status )0);
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/transmit.c"
static void query_usetcp___8(adns_query qu , struct timeval now ) 
{ 


  {
  {
#line 244
  qu->state = (enum __anonenum_state_83 )1;
#line 245
  qu->timeout = now;
#line 246
  timevaladd___18(& qu->timeout, 30000L);
  }
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    qu->next = (adns_query )0;
#line 247
    qu->back = (qu->ads)->tcpw.tail;
#line 247
    if ((qu->ads)->tcpw.tail) {
#line 247
      ((qu->ads)->tcpw.tail)->next = qu;
    } else {
#line 247
      (qu->ads)->tcpw.head = qu;
    }
#line 247
    (qu->ads)->tcpw.tail = qu;
#line 247
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 248
  adns__querysend_tcp(qu, now);
#line 249
  adns__tcp_tryconnect(qu->ads, now);
  }
#line 250
  return;
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c"
static adns_query query_alloc___8(adns_state ads___7 , typeinfo const   *typei , adns_rrtype type ,
                                  adns_queryflags flags , struct timeval now ) 
{ 
  adns_query qu ;
  void *tmp ;
  void *tmp___0 ;
  adns_query tmp___1 ;
  adns_query tmp___2 ;
  adns_query tmp___3 ;
  adns_query tmp___4 ;
  allocnode *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __suseconds_t tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 45
  tmp = malloc(sizeof(*qu));
#line 45
  qu = (adns_query )tmp;
  }
#line 45
  if (! qu) {
#line 45
    return ((adns_query )0);
  }
  {
#line 46
  tmp___0 = malloc(sizeof(*(qu->answer)));
#line 46
  qu->answer = (adns_answer *)tmp___0;
  }
#line 47
  if (! qu->answer) {
    {
#line 47
    free((void *)qu);
    }
#line 47
    return ((adns_query )0);
  }
  {
#line 49
  qu->ads = ads___7;
#line 50
  qu->state = (enum __anonenum_state_83 )0;
#line 51
  tmp___2 = (adns_query )0;
#line 51
  qu->parent = tmp___2;
#line 51
  tmp___1 = tmp___2;
#line 51
  qu->next = tmp___1;
#line 51
  qu->back = tmp___1;
#line 52
  tmp___3 = (adns_query )0;
#line 52
  qu->children.tail = tmp___3;
#line 52
  qu->children.head = tmp___3;
#line 53
  tmp___4 = (adns_query )0;
#line 53
  qu->siblings.back = tmp___4;
#line 53
  qu->siblings.next = tmp___4;
#line 54
  tmp___5 = (allocnode *)0;
#line 54
  qu->allocations.tail = tmp___5;
#line 54
  qu->allocations.head = tmp___5;
#line 55
  qu->interim_allocd = 0;
#line 56
  qu->preserved_allocd = 0;
#line 57
  qu->final_allocspace = (void *)0;
#line 59
  qu->typei = typei;
#line 60
  qu->query_dgram = (byte *)0;
#line 61
  qu->query_dglen = 0;
#line 62
  adns__vbuf_init(& qu->vb);
#line 64
  qu->cname_dgram = (byte *)0;
#line 65
  tmp___6 = 0;
#line 65
  qu->cname_begin = tmp___6;
#line 65
  qu->cname_dglen = tmp___6;
#line 67
  adns__vbuf_init(& qu->search_vb);
#line 68
  tmp___8 = 0;
#line 68
  qu->search_doneabs = tmp___8;
#line 68
  tmp___7 = tmp___8;
#line 68
  qu->search_pos = tmp___7;
#line 68
  qu->search_origlen = tmp___7;
#line 70
  qu->id = -2;
#line 71
  qu->flags = (int )flags;
#line 72
  qu->retries = 0;
#line 73
  qu->udpnextserver = 0;
#line 74
  qu->udpsent = 0UL;
#line 75
  tmp___9 = (__suseconds_t )0;
#line 75
  qu->timeout.tv_usec = tmp___9;
#line 75
  qu->timeout.tv_sec = tmp___9;
#line 76
  qu->expires = now.tv_sec + 604800L;
#line 78
  memset((void *)(& qu->ctx), 0, sizeof(qu->ctx));
#line 80
  (qu->answer)->status = (adns_status )0;
#line 81
  tmp___10 = (char *)0;
#line 81
  (qu->answer)->owner = tmp___10;
#line 81
  (qu->answer)->cname = tmp___10;
#line 82
  (qu->answer)->type = type;
#line 83
  (qu->answer)->expires = (time_t )-1;
#line 84
  (qu->answer)->nrrs = 0;
#line 85
  (qu->answer)->rrs.untyped = (void *)0;
#line 86
  (qu->answer)->rrsz = (int )typei->rrsz;
  }
#line 88
  return (qu);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c"
static void query_submit___8(adns_state ads___7 , adns_query qu , typeinfo const   *typei ,
                             vbuf *qumsg_vb , int id , adns_queryflags flags , struct timeval now ) 
{ 
  void *tmp ;

  {
  {
#line 98
  qu->vb = *qumsg_vb;
#line 99
  adns__vbuf_init(qumsg_vb);
#line 101
  tmp = malloc((size_t )qu->vb.used);
#line 101
  qu->query_dgram = (byte *)tmp;
  }
#line 102
  if (! qu->query_dgram) {
    {
#line 102
    adns__query_fail(qu, (adns_status )1);
    }
#line 102
    return;
  }
  {
#line 104
  qu->id = id;
#line 105
  qu->query_dglen = qu->vb.used;
#line 106
  memcpy((void */* __restrict  */)qu->query_dgram, (void const   */* __restrict  */)qu->vb.buf,
         (size_t )qu->vb.used);
#line 108
  adns__query_send(qu, now);
  }
#line 109
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c"
static void query_simple___8(adns_state ads___7 , adns_query qu , char const   *owner ,
                             int ol , typeinfo const   *typei , adns_queryflags flags ,
                             struct timeval now ) 
{ 
  vbuf vb_new ;
  int id ;
  adns_status stat ;

  {
  {
#line 136
  stat = adns__mkquery(ads___7, & qu->vb, & id, owner, ol, typei, (qu->answer)->type,
                       flags);
  }
#line 138
  if (stat) {
#line 139
    if ((unsigned int )stat == 202U) {
#line 139
      if ((unsigned int )flags & 1U) {
        {
#line 140
        adns__search_next(ads___7, qu, now);
        }
#line 141
        return;
      } else {
        {
#line 143
        adns__query_fail(qu, stat);
        }
#line 144
        return;
      }
    } else {
      {
#line 143
      adns__query_fail(qu, stat);
      }
#line 144
      return;
    }
  }
  {
#line 148
  vb_new = qu->vb;
#line 149
  adns__vbuf_init(& qu->vb);
#line 150
  query_submit___8(ads___7, qu, typei, & vb_new, id, flags, now);
  }
#line 151
  return;
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c"
static int save_owner___8(adns_query qu , char const   *owner , int ol ) 
{ 
  adns_answer *ans ;
  void *tmp ;

  {
#line 198
  if (! (qu->flags & 4)) {
#line 198
    return (1);
  }
#line 200
  ans = qu->answer;
#line 201
  if (! (! ans->owner)) {
    {
#line 201
    __assert_fail("!ans->owner", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c",
                  201U, "save_owner");
    }
  }
  {
#line 203
  tmp = adns__alloc_preserved(qu, (size_t )(ol + 1));
#line 203
  ans->owner = (char *)tmp;
  }
#line 203
  if (! ans->owner) {
#line 203
    return (0);
  }
  {
#line 205
  memcpy((void */* __restrict  */)ans->owner, (void const   */* __restrict  */)owner,
         (size_t )ol);
#line 206
  *(ans->owner + ol) = (char)0;
  }
#line 207
  return (1);
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c"
static void *alloc_common___8(adns_query qu , size_t sz ) 
{ 
  allocnode *an ;
  void *tmp ;

  {
#line 342
  if (! sz) {
#line 342
    return ((void *)qu);
  }
#line 343
  if (! (! qu->final_allocspace)) {
    {
#line 343
    __assert_fail("!qu->final_allocspace", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c",
                  343U, "alloc_common");
    }
  }
  {
#line 344
  tmp = malloc((((((((sizeof(*an) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ) + sz) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ));
#line 344
  an = (allocnode *)tmp;
  }
#line 345
  if (! an) {
#line 345
    return ((void *)0);
  }
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 346
    an->next = (struct allocnode *)0;
#line 346
    an->back = qu->allocations.tail;
#line 346
    if (qu->allocations.tail) {
#line 346
      (qu->allocations.tail)->next = an;
    } else {
#line 346
      qu->allocations.head = an;
    }
#line 346
    qu->allocations.tail = an;
#line 346
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 347
  return ((void *)((byte *)an + (((sizeof(*an) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign )));
}
}
#line 410 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c"
static void cancel_children___8(adns_query qu ) 
{ 
  adns_query cqu ;
  adns_query ncqu ;

  {
#line 413
  cqu = qu->children.head;
  {
#line 413
  while (1) {
    while_continue: /* CIL Label */ ;
#line 413
    if (! cqu) {
#line 413
      goto while_break;
    }
    {
#line 414
    ncqu = cqu->siblings.next;
#line 415
    adns_cancel(cqu);
#line 413
    cqu = ncqu;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 417
  return;
}
}
#line 427 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c"
static void free_query_allocs___8(adns_query qu ) 
{ 
  allocnode *an ;
  allocnode *ann ;
  allocnode *tmp ;

  {
  {
#line 430
  cancel_children___8(qu);
#line 431
  an = qu->allocations.head;
  }
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    if (! an) {
#line 431
      goto while_break;
    }
    {
#line 431
    ann = an->next;
#line 431
    free((void *)an);
#line 431
    an = ann;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 432
  tmp = (allocnode *)0;
#line 432
  qu->allocations.tail = tmp;
#line 432
  qu->allocations.head = tmp;
#line 433
  adns__vbuf_free(& qu->vb);
#line 434
  adns__vbuf_free(& qu->search_vb);
#line 435
  free((void *)qu->query_dgram);
#line 436
  qu->query_dgram = (byte *)0;
  }
#line 437
  return;
}
}
#line 477 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c"
static void makefinal_query___8(adns_query qu ) 
{ 
  adns_answer *ans ;
  int rrn ;
  void *tmp ;

  {
#line 481
  ans = qu->answer;
#line 483
  if (qu->interim_allocd) {
    {
#line 484
    tmp = realloc((void *)qu->answer, (((((((sizeof(*ans) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ) + (unsigned long )qu->interim_allocd) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ));
#line 484
    ans = (adns_answer *)tmp;
    }
#line 486
    if (! ans) {
#line 486
      goto x_nomem;
    }
#line 487
    qu->answer = ans;
  }
  {
#line 490
  qu->final_allocspace = (void *)((byte *)ans + (((sizeof(*ans) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ));
#line 491
  adns__makefinal_str(qu, & ans->cname);
#line 492
  adns__makefinal_str(qu, & ans->owner);
  }
#line 494
  if (ans->nrrs) {
    {
#line 495
    adns__makefinal_block(qu, & ans->rrs.untyped, (size_t )(ans->nrrs * ans->rrsz));
#line 497
    rrn = 0;
    }
    {
#line 497
    while (1) {
      while_continue: /* CIL Label */ ;
#line 497
      if (! (rrn < ans->nrrs)) {
#line 497
        goto while_break;
      }
      {
#line 498
      (*((qu->typei)->makefinal))(qu, (void *)(ans->rrs.bytes + rrn * ans->rrsz));
#line 497
      rrn ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 501
  free_query_allocs___8(qu);
  }
#line 502
  return;
  x_nomem: 
  {
#line 505
  qu->preserved_allocd = 0;
#line 506
  (qu->answer)->cname = (char *)0;
#line 507
  (qu->answer)->owner = (char *)0;
#line 508
  adns__reset_preserved(qu);
#line 510
  (qu->answer)->status = (adns_status )1;
#line 511
  free_query_allocs___8(qu);
  }
#line 512
  return;
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void readconfig___8(adns_state ads___7 , char const   *filename , int warnmissing ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void addserver___8(adns_state ads___7 , struct in_addr addr ) 
{ 
  int i ;
  struct server *ss ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 48
  i = 0;
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (i < ads___7->nservers)) {
#line 48
      goto while_break;
    }
#line 49
    if (ads___7->servers[i].addr.s_addr == addr.s_addr) {
      {
#line 50
      tmp = inet_ntoa(addr);
#line 50
      adns__debug(ads___7, -1, (adns_query )0, "duplicate nameserver %s ignored",
                  tmp);
      }
#line 51
      return;
    }
#line 48
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  if (ads___7->nservers >= 5) {
    {
#line 56
    tmp___0 = inet_ntoa(addr);
#line 56
    adns__diag(ads___7, -1, (adns_query )0, "too many nameservers, ignoring %s", tmp___0);
    }
#line 57
    return;
  }
#line 60
  ss = ads___7->servers + ads___7->nservers;
#line 61
  ss->addr = addr;
#line 62
  (ads___7->nservers) ++;
#line 63
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void freesearchlist___8(adns_state ads___7 ) 
{ 


  {
#line 66
  if (ads___7->nsearchlist) {
    {
#line 66
    free((void *)*(ads___7->searchlist));
    }
  }
  {
#line 67
  free((void *)ads___7->searchlist);
  }
#line 68
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void saveerr___8(adns_state ads___7 , int en ) 
{ 


  {
#line 71
  if (! ads___7->configerrno) {
#line 71
    ads___7->configerrno = en;
  }
#line 72
  return;
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void configparseerr___8(adns_state ads___7 , char const   *fn , int lno , char const   *fmt 
                               , ...) 
{ 
  va_list al ;

  {
  {
#line 78
  saveerr___8(ads___7, 22);
  }
#line 79
  if (! ads___7->logfn) {
#line 79
    return;
  } else
#line 79
  if ((unsigned int )ads___7->iflags & 2U) {
#line 79
    return;
  }
#line 81
  if (lno == -1) {
    {
#line 81
    adns__lprintf(ads___7, "adns: %s: ", fn);
    }
  } else {
    {
#line 82
    adns__lprintf(ads___7, "adns: %s:%d: ", fn, lno);
    }
  }
  {
#line 83
  __builtin_va_start(al, fmt);
#line 84
  adns__vlprintf(ads___7, fmt, al);
#line 85
  __builtin_va_end(al);
#line 86
  adns__lprintf(ads___7, "\n");
  }
#line 87
  return;
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static int nextword___8(char const   **bufp_io , char const   **word_r , int *l_r ) 
{ 
  char const   *p ;
  char const   *q ;
  int tmp ;
  int tmp___0 ;

  {
#line 92
  p = *bufp_io;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 93
    tmp = ctype_whitespace((int )*p);
    }
#line 93
    if (! tmp) {
#line 93
      goto while_break;
    }
#line 93
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  if (! *p) {
#line 94
    return (0);
  }
#line 96
  q = p;
  {
#line 97
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 97
    if (*q) {
      {
#line 97
      tmp___0 = ctype_whitespace((int )*q);
      }
#line 97
      if (tmp___0) {
#line 97
        goto while_break___0;
      }
    } else {
#line 97
      goto while_break___0;
    }
#line 97
    q ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 99
  *l_r = (int )(q - p);
#line 100
  *word_r = p;
#line 101
  *bufp_io = q;
#line 103
  return (1);
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void ccf_nameserver___8(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  struct in_addr ia ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 110
  tmp = inet_aton(buf___17, & ia);
  }
#line 110
  if (! tmp) {
    {
#line 111
    configparseerr___8(ads___7, fn, lno, "invalid nameserver address `%s\'", buf___17);
    }
#line 112
    return;
  }
  {
#line 114
  tmp___0 = inet_ntoa(ia);
#line 114
  adns__debug(ads___7, -1, (adns_query )0, "using nameserver %s", tmp___0);
#line 115
  addserver___8(ads___7, ia);
  }
#line 116
  return;
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void ccf_search___8(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  char const   *bufp ;
  char const   *word ;
  char *newchars ;
  char **newptrs ;
  char **pp ;
  int count ;
  int tl ;
  int l ;
  int tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char **tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
#line 124
  if (! buf___17) {
#line 124
    return;
  }
#line 126
  bufp = buf___17;
#line 127
  count = 0;
#line 128
  tl = 0;
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 129
    tmp = nextword___8(& bufp, & word, & l);
    }
#line 129
    if (! tmp) {
#line 129
      goto while_break;
    }
#line 129
    count ++;
#line 129
    tl += l + 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 131
  tmp___0 = malloc(sizeof(char *) * (unsigned long )count);
#line 131
  newptrs = (char **)tmp___0;
  }
#line 132
  if (! newptrs) {
    {
#line 132
    tmp___1 = __errno_location();
#line 132
    saveerr___8(ads___7, *tmp___1);
    }
#line 132
    return;
  }
  {
#line 134
  tmp___2 = malloc((size_t )tl);
#line 134
  newchars = (char *)tmp___2;
  }
#line 135
  if (! newchars) {
    {
#line 135
    tmp___3 = __errno_location();
#line 135
    saveerr___8(ads___7, *tmp___3);
#line 135
    free((void *)newptrs);
    }
#line 135
    return;
  }
#line 137
  bufp = buf___17;
#line 138
  pp = newptrs;
  {
#line 139
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 139
    tmp___6 = nextword___8(& bufp, & word, & l);
    }
#line 139
    if (! tmp___6) {
#line 139
      goto while_break___0;
    }
    {
#line 140
    tmp___4 = pp;
#line 140
    pp ++;
#line 140
    *tmp___4 = newchars;
#line 141
    memcpy((void */* __restrict  */)newchars, (void const   */* __restrict  */)word,
           (size_t )l);
#line 142
    newchars += l;
#line 143
    tmp___5 = newchars;
#line 143
    newchars ++;
#line 143
    *tmp___5 = (char)0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 146
  freesearchlist___8(ads___7);
#line 147
  ads___7->nsearchlist = count;
#line 148
  ads___7->searchlist = newptrs;
  }
#line 149
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void ccf_sortlist___8(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  char const   *word ;
  char tbuf[200] ;
  char *slash ;
  char *ep ;
  struct in_addr base ;
  struct in_addr mask ;
  int l ;
  unsigned long initial ;
  unsigned long baselocal ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  uint32_t tmp___3 ;
  int tmp___4 ;

  {
#line 159
  if (! buf___17) {
#line 159
    return;
  }
#line 161
  ads___7->nsortlist = 0;
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 162
    tmp___4 = nextword___8(& buf___17, & word, & l);
    }
#line 162
    if (! tmp___4) {
#line 162
      goto while_break;
    }
#line 163
    if (ads___7->nsortlist >= 15) {
      {
#line 164
      adns__diag(ads___7, -1, (adns_query )0, "too many sortlist entries, ignoring %.*s onwards",
                 l, word);
      }
#line 166
      return;
    }
#line 169
    if ((unsigned long )l >= sizeof(tbuf)) {
      {
#line 170
      configparseerr___8(ads___7, fn, lno, "sortlist entry `%.*s\' too long", l, word);
      }
#line 171
      goto while_continue;
    }
    {
#line 174
    memcpy((void */* __restrict  */)(tbuf), (void const   */* __restrict  */)word,
           (size_t )l);
#line 174
    tbuf[l] = (char)0;
#line 175
    slash = strchr((char const   *)(tbuf), '/');
    }
#line 176
    if (slash) {
#line 176
      tmp = slash;
#line 176
      slash ++;
#line 176
      *tmp = (char)0;
    }
    {
#line 178
    tmp___0 = inet_aton((char const   *)(tbuf), & base);
    }
#line 178
    if (! tmp___0) {
      {
#line 179
      configparseerr___8(ads___7, fn, lno, "invalid address `%s\' in sortlist", tbuf);
      }
#line 180
      goto while_continue;
    }
#line 183
    if (slash) {
      {
#line 184
      tmp___2 = strchr((char const   *)slash, '.');
      }
#line 184
      if (tmp___2) {
        {
#line 185
        tmp___1 = inet_aton((char const   *)slash, & mask);
        }
#line 185
        if (! tmp___1) {
          {
#line 186
          configparseerr___8(ads___7, fn, lno, "invalid mask `%s\' in sortlist", slash);
          }
#line 187
          goto while_continue;
        }
#line 189
        if (base.s_addr & ~ mask.s_addr) {
          {
#line 190
          configparseerr___8(ads___7, fn, lno, "mask `%s\' in sortlist overlaps address `%s\'",
                             slash, tbuf);
          }
#line 192
          goto while_continue;
        }
      } else {
        {
#line 195
        initial = strtoul((char const   */* __restrict  */)slash, (char **/* __restrict  */)(& ep),
                          10);
        }
#line 196
        if (*ep) {
          {
#line 197
          configparseerr___8(ads___7, fn, lno, "mask length `%s\' invalid", slash);
          }
#line 198
          goto while_continue;
        } else
#line 196
        if (initial > 32UL) {
          {
#line 197
          configparseerr___8(ads___7, fn, lno, "mask length `%s\' invalid", slash);
          }
#line 198
          goto while_continue;
        }
        {
#line 200
        mask.s_addr = htonl((uint32_t )(4294967295UL << (32UL - initial)));
        }
      }
    } else {
      {
#line 203
      tmp___3 = ntohl(base.s_addr);
#line 203
      baselocal = (unsigned long )tmp___3;
      }
#line 204
      if ((unsigned long )(! baselocal) & 2147483648UL) {
        {
#line 205
        mask.s_addr = htonl((uint32_t )4278190080UL);
        }
      } else
#line 206
      if ((baselocal & 3221225472UL) == 2147483648UL) {
        {
#line 207
        mask.s_addr = htonl((uint32_t )4294901760UL);
        }
      } else
#line 208
      if ((baselocal & 4026531840UL) == 3758096384UL) {
        {
#line 209
        mask.s_addr = htonl((uint32_t )4278190080UL);
        }
      } else {
        {
#line 211
        configparseerr___8(ads___7, fn, lno, "network address `%s\' in sortlist is not in classed ranges, must specify mask explicitly",
                           tbuf);
        }
#line 214
        goto while_continue;
      }
    }
#line 218
    ads___7->sortlist[ads___7->nsortlist].base = base;
#line 219
    ads___7->sortlist[ads___7->nsortlist].mask = mask;
#line 220
    (ads___7->nsortlist) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  return;
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void ccf_options___8(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  char const   *word ;
  char *ep ;
  unsigned long v ;
  int l ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 231
  if (! buf___17) {
#line 231
    return;
  }
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 233
    tmp___5 = nextword___8(& buf___17, & word, & l);
    }
#line 233
    if (! tmp___5) {
#line 233
      goto while_break;
    }
#line 234
    if (l == 5) {
      {
#line 234
      tmp = memcmp((void const   *)word, (void const   *)"debug", (size_t )5);
      }
#line 234
      if (! tmp) {
#line 235
        ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 8U);
#line 236
        goto while_continue;
      }
    }
#line 238
    if (l >= 6) {
      {
#line 238
      tmp___0 = memcmp((void const   *)word, (void const   *)"ndots:", (size_t )6);
      }
#line 238
      if (! tmp___0) {
        {
#line 239
        v = strtoul((char const   */* __restrict  */)(word + 6), (char **/* __restrict  */)(& ep),
                    10);
        }
#line 240
        if (l == 6) {
          {
#line 241
          configparseerr___8(ads___7, fn, lno, "option `%.*s\' malformed or has bad value",
                             l, word);
          }
#line 243
          goto while_continue;
        } else
#line 240
        if ((unsigned long )ep != (unsigned long )(word + l)) {
          {
#line 241
          configparseerr___8(ads___7, fn, lno, "option `%.*s\' malformed or has bad value",
                             l, word);
          }
#line 243
          goto while_continue;
        } else
#line 240
        if (v > 2147483647UL) {
          {
#line 241
          configparseerr___8(ads___7, fn, lno, "option `%.*s\' malformed or has bad value",
                             l, word);
          }
#line 243
          goto while_continue;
        }
#line 245
        ads___7->searchndots = (int )v;
#line 246
        goto while_continue;
      }
    }
#line 248
    if (l >= 12) {
      {
#line 248
      tmp___4 = memcmp((void const   *)word, (void const   *)"adns_checkc:", (size_t )12);
      }
#line 248
      if (! tmp___4) {
        {
#line 249
        tmp___3 = strcmp(word + 12, "none");
        }
#line 249
        if (tmp___3) {
          {
#line 252
          tmp___2 = strcmp(word + 12, "entex");
          }
#line 252
          if (tmp___2) {
            {
#line 255
            tmp___1 = strcmp(word + 12, "freq");
            }
#line 255
            if (tmp___1) {
              {
#line 258
              configparseerr___8(ads___7, fn, lno, "option adns_checkc has bad value `%s\' (must be none, entex or freq",
                                 word + 12);
              }
            } else {
#line 256
              ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 768U);
            }
          } else {
#line 253
            ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags & 4294966527U);
#line 254
            ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 256U);
          }
        } else {
#line 250
          ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags & 4294966527U);
#line 251
          ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 256U);
        }
#line 261
        goto while_continue;
      }
    }
    {
#line 263
    adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown option `%.*s\'", fn, lno,
               l, word);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 265
  return;
}
}
#line 267 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void ccf_clearnss___8(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 


  {
#line 269
  ads___7->nservers = 0;
#line 270
  return;
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void ccf_include___8(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 


  {
#line 274
  if (! *buf___17) {
    {
#line 275
    configparseerr___8(ads___7, fn, lno, "`include\' directive with no filename");
    }
#line 276
    return;
  }
  {
#line 278
  readconfig___8(ads___7, buf___17, 1);
  }
#line 279
  return;
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void ccf_lookup___8(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  int found_bind ;
  char const   *word ;
  int l ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 283
  found_bind = 0;
#line 287
  if (! *buf___17) {
    {
#line 288
    configparseerr___8(ads___7, fn, lno, "`lookup\' directive with no databases");
    }
#line 289
    return;
  }
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 292
    tmp___2 = nextword___8(& buf___17, & word, & l);
    }
#line 292
    if (! tmp___2) {
#line 292
      goto while_break;
    }
#line 293
    if (l == 4) {
      {
#line 293
      tmp___1 = memcmp((void const   *)word, (void const   *)"bind", (size_t )4);
      }
#line 293
      if (tmp___1) {
#line 293
        goto _L___0;
      } else {
#line 294
        found_bind = 1;
      }
    } else
    _L___0: /* CIL Label */ 
#line 295
    if (l == 4) {
      {
#line 295
      tmp___0 = memcmp((void const   *)word, (void const   *)"file", (size_t )4);
      }
#line 295
      if (tmp___0) {
#line 295
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 297
    if (l == 2) {
      {
#line 297
      tmp = memcmp((void const   *)word, (void const   *)"yp", (size_t )2);
      }
#line 297
      if (tmp) {
        {
#line 301
        adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown `lookup\' database `%.*s\'",
                   fn, lno, l, word);
#line 303
        found_bind = -1;
        }
      } else {
        {
#line 298
        adns__diag(ads___7, -1, (adns_query )0, "%s:%d: yp lookups not supported by adns",
                   fn, lno);
#line 299
        found_bind = -1;
        }
      }
    } else {
      {
#line 301
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown `lookup\' database `%.*s\'",
                 fn, lno, l, word);
#line 303
      found_bind = -1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 306
  if (! found_bind) {
    {
#line 307
    adns__diag(ads___7, -1, (adns_query )0, "%s:%d: `lookup\' specified, but not `bind\'",
               fn, lno);
    }
  }
#line 308
  return;
}
}
#line 310 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static struct configcommandinfo  const  configcommandinfos___8[9]  = 
#line 310
  {      {"nameserver", & ccf_nameserver___8}, 
        {"domain", & ccf_search___8}, 
        {"search", & ccf_search___8}, 
        {"sortlist", & ccf_sortlist___8}, 
        {"options", & ccf_options___8}, 
        {"clearnameservers", & ccf_clearnss___8}, 
        {"include", & ccf_include___8}, 
        {"lookup", & ccf_lookup___8}, 
        {(char const   *)0, (void (*)(adns_state ads , char const   *fn , int lno , char const   *buf ))0}};
#line 330 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static int gl_file___8(adns_state ads___7 , getline_ctx *src_io , char const   *filename ,
                       int lno , char *buf___17 , int buflen ) 
{ 
  FILE *file ;
  int c ;
  int i ;
  char *p ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 332
  file = src_io->file;
#line 336
  p = buf___17;
#line 337
  buflen --;
#line 338
  i = 0;
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (i == buflen) {
      {
#line 342
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: line too long, ignored", filename,
                 lno);
      }
#line 343
      goto x_badline;
    }
    {
#line 345
    c = _IO_getc(file);
    }
#line 346
    if (! c) {
      {
#line 347
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: line contains nul, ignored",
                 filename, lno);
      }
#line 348
      goto x_badline;
    } else
#line 349
    if (c == 10) {
#line 350
      goto while_break;
    } else
#line 351
    if (c == -1) {
      {
#line 352
      tmp___2 = ferror(file);
      }
#line 352
      if (tmp___2) {
        {
#line 353
        tmp = __errno_location();
#line 353
        saveerr___8(ads___7, *tmp);
#line 354
        tmp___0 = __errno_location();
#line 354
        tmp___1 = strerror(*tmp___0);
#line 354
        adns__diag(ads___7, -1, (adns_query )0, "%s:%d: read error: %s", filename,
                   lno, tmp___1);
        }
#line 356
        return (-1);
      }
#line 358
      if (! i) {
#line 358
        return (-1);
      }
#line 359
      goto while_break;
    } else {
#line 361
      tmp___3 = p;
#line 361
      p ++;
#line 361
      *tmp___3 = (char )c;
#line 362
      i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 366
  tmp___4 = p;
#line 366
  p ++;
#line 366
  *tmp___4 = (char)0;
#line 367
  return (i);
  x_badline: 
  {
#line 370
  saveerr___8(ads___7, 22);
  }
  {
#line 371
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 371
    c = _IO_getc(file);
    }
#line 371
    if (c != -1) {
#line 371
      if (! (c != 10)) {
#line 371
        goto while_break___0;
      }
    } else {
#line 371
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 372
  return (-2);
}
}
#line 375 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static int gl_text___8(adns_state ads___7 , getline_ctx *src_io , char const   *filename ,
                       int lno , char *buf___17 , int buflen ) 
{ 
  char const   *cp ;
  int l ;
  size_t tmp ;

  {
#line 377
  cp = src_io->text;
#line 380
  if (! cp) {
#line 380
    return (-1);
  } else
#line 380
  if (! *cp) {
#line 380
    return (-1);
  }
#line 382
  if ((int const   )*cp == 59) {
#line 382
    cp ++;
  } else
#line 382
  if ((int const   )*cp == 10) {
#line 382
    cp ++;
  }
  {
#line 383
  tmp = strcspn(cp, ";\n");
#line 383
  l = (int )tmp;
#line 384
  src_io->text = cp + l;
  }
#line 386
  if (l >= buflen) {
    {
#line 387
    adns__diag(ads___7, -1, (adns_query )0, "%s:%d: line too long, ignored", filename,
               lno);
#line 388
    saveerr___8(ads___7, 22);
    }
#line 389
    return (-2);
  }
  {
#line 392
  memcpy((void */* __restrict  */)buf___17, (void const   */* __restrict  */)cp, (size_t )l);
#line 393
  *(buf___17 + l) = (char)0;
  }
#line 394
  return (l);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void readconfiggeneric___8(adns_state ads___7 , char const   *filename , int (*getline___0)(adns_state ads ,
                                                                                                   getline_ctx * ,
                                                                                                   char const   *filename ,
                                                                                                   int lno ,
                                                                                                   char *buf ,
                                                                                                   int buflen ) ,
                                  getline_ctx gl_ctx ) 
{ 
  char linebuf[2000] ;
  char *p ;
  char *q ;
  int lno ;
  int l ;
  int dirl ;
  struct configcommandinfo  const  *ccip ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 410
  lno = 1;
  {
#line 410
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 410
    l = (*getline___0)(ads___7, & gl_ctx, filename, lno, linebuf, (int )sizeof(linebuf));
    }
#line 410
    if (! (l != -1)) {
#line 410
      goto while_break;
    }
#line 413
    if (l == -2) {
#line 413
      goto __Cont;
    }
    {
#line 414
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 414
      if (l > 0) {
        {
#line 414
        tmp = ctype_whitespace((int )linebuf[l - 1]);
        }
#line 414
        if (! tmp) {
#line 414
          goto while_break___0;
        }
      } else {
#line 414
        goto while_break___0;
      }
#line 414
      l --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 415
    linebuf[l] = (char)0;
#line 416
    p = linebuf;
    {
#line 417
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 417
      tmp___0 = ctype_whitespace((int )*p);
      }
#line 417
      if (! tmp___0) {
#line 417
        goto while_break___1;
      }
#line 417
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 418
    if ((int )*p == 35) {
#line 418
      goto __Cont;
    } else
#line 418
    if ((int )*p == 59) {
#line 418
      goto __Cont;
    } else
#line 418
    if (! *p) {
#line 418
      goto __Cont;
    }
#line 419
    q = p;
    {
#line 420
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 420
      if (*q) {
        {
#line 420
        tmp___1 = ctype_whitespace((int )*q);
        }
#line 420
        if (tmp___1) {
#line 420
          goto while_break___2;
        }
      } else {
#line 420
        goto while_break___2;
      }
#line 420
      q ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 421
    dirl = (int )(q - p);
#line 422
    ccip = configcommandinfos___8;
    {
#line 422
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 422
      if (ccip->name) {
        {
#line 422
        tmp___2 = strlen((char const   *)ccip->name);
        }
#line 422
        if (tmp___2 == (size_t )dirl) {
          {
#line 422
          tmp___3 = memcmp((void const   *)ccip->name, (void const   *)p, (size_t )(q - p));
          }
#line 422
          if (! tmp___3) {
#line 422
            goto while_break___3;
          }
        }
      } else {
#line 422
        goto while_break___3;
      }
#line 422
      ccip ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 426
    if (! ccip->name) {
      {
#line 427
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown configuration directive `%.*s\'",
                 filename, lno, (int )(q - p), p);
      }
#line 429
      goto __Cont;
    }
    {
#line 431
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 431
      tmp___4 = ctype_whitespace((int )*q);
      }
#line 431
      if (! tmp___4) {
#line 431
        goto while_break___4;
      }
#line 431
      q ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 432
    (*(ccip->fn))(ads___7, filename, lno, (char const   *)q);
    }
    __Cont: /* CIL Label */ 
#line 410
    lno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 434
  return;
}
}
#line 436 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static char const   *instrum_getenv___8(adns_state ads___7 , char const   *envvar ) 
{ 
  char const   *value ;
  char *tmp ;

  {
  {
#line 439
  tmp = getenv(envvar);
#line 439
  value = (char const   *)tmp;
  }
#line 440
  if (! value) {
    {
#line 440
    adns__debug(ads___7, -1, (adns_query )0, "environment variable %s not set", envvar);
    }
  } else {
    {
#line 441
    adns__debug(ads___7, -1, (adns_query )0, "environment variable %s set to `%s\'",
                envvar, value);
    }
  }
#line 443
  return (value);
}
}
#line 446 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void readconfig___8(adns_state ads___7 , char const   *filename , int warnmissing ) 
{ 
  getline_ctx gl_ctx ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 449
  gl_ctx.file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 450
  if (! gl_ctx.file) {
    {
#line 451
    tmp = __errno_location();
    }
#line 451
    if (*tmp == 2) {
#line 452
      if (warnmissing) {
        {
#line 453
        adns__debug(ads___7, -1, (adns_query )0, "configuration file `%s\' does not exist",
                    filename);
        }
      }
#line 455
      return;
    }
    {
#line 457
    tmp___0 = __errno_location();
#line 457
    saveerr___8(ads___7, *tmp___0);
#line 458
    tmp___1 = __errno_location();
#line 458
    tmp___2 = strerror(*tmp___1);
#line 458
    adns__diag(ads___7, -1, (adns_query )0, "cannot open configuration file `%s\': %s",
               filename, tmp___2);
    }
#line 460
    return;
  }
  {
#line 463
  readconfiggeneric___8(ads___7, filename, & gl_file___8, gl_ctx);
#line 465
  fclose(gl_ctx.file);
  }
#line 466
  return;
}
}
#line 468 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void readconfigtext___8(adns_state ads___7 , char const   *text , char const   *showname ) 
{ 
  getline_ctx gl_ctx ;

  {
  {
#line 472
  gl_ctx.text = text;
#line 473
  readconfiggeneric___8(ads___7, showname, & gl_text___8, gl_ctx);
  }
#line 474
  return;
}
}
#line 476 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void readconfigenv___8(adns_state ads___7 , char const   *envvar ) 
{ 
  char const   *filename ;

  {
#line 479
  if ((unsigned int )ads___7->iflags & 1U) {
    {
#line 480
    adns__debug(ads___7, -1, (adns_query )0, "not checking environment variable `%s\'",
                envvar);
    }
#line 481
    return;
  }
  {
#line 483
  filename = instrum_getenv___8(ads___7, envvar);
  }
#line 484
  if (filename) {
    {
#line 484
    readconfig___8(ads___7, filename, 1);
    }
  }
#line 485
  return;
}
}
#line 487 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void readconfigenvtext___8(adns_state ads___7 , char const   *envvar ) 
{ 
  char const   *textdata ;

  {
#line 490
  if ((unsigned int )ads___7->iflags & 1U) {
    {
#line 491
    adns__debug(ads___7, -1, (adns_query )0, "not checking environment variable `%s\'",
                envvar);
    }
#line 492
    return;
  }
  {
#line 494
  textdata = instrum_getenv___8(ads___7, envvar);
  }
#line 495
  if (textdata) {
    {
#line 495
    readconfigtext___8(ads___7, textdata, envvar);
    }
  }
#line 496
  return;
}
}
#line 508 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static int init_begin___8(adns_state *ads_r , adns_initflags flags , adns_logcallbackfn *logfn ,
                          void *logfndata ) 
{ 
  adns_state ads___7 ;
  pid_t pid ;
  void *tmp ;
  int *tmp___0 ;
  adns_query tmp___1 ;
  adns_query tmp___2 ;
  adns_query tmp___3 ;
  adns_query tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __suseconds_t tmp___9 ;

  {
  {
#line 513
  tmp = malloc(sizeof(*ads___7));
#line 513
  ads___7 = (adns_state )tmp;
  }
#line 513
  if (! ads___7) {
    {
#line 513
    tmp___0 = __errno_location();
    }
#line 513
    return (*tmp___0);
  }
  {
#line 515
  ads___7->iflags = flags;
#line 516
  ads___7->logfn = logfn;
#line 517
  ads___7->logfndata = logfndata;
#line 518
  ads___7->configerrno = 0;
#line 519
  tmp___1 = (adns_query )0;
#line 519
  ads___7->udpw.tail = tmp___1;
#line 519
  ads___7->udpw.head = tmp___1;
#line 520
  tmp___2 = (adns_query )0;
#line 520
  ads___7->tcpw.tail = tmp___2;
#line 520
  ads___7->tcpw.head = tmp___2;
#line 521
  tmp___3 = (adns_query )0;
#line 521
  ads___7->childw.tail = tmp___3;
#line 521
  ads___7->childw.head = tmp___3;
#line 522
  tmp___4 = (adns_query )0;
#line 522
  ads___7->output.tail = tmp___4;
#line 522
  ads___7->output.head = tmp___4;
#line 523
  ads___7->forallnext = (adns_query )0;
#line 524
  ads___7->nextid = 12575;
#line 525
  tmp___5 = -1;
#line 525
  ads___7->tcpsocket = tmp___5;
#line 525
  ads___7->udpsocket = tmp___5;
#line 526
  adns__vbuf_init(& ads___7->tcpsend);
#line 527
  adns__vbuf_init(& ads___7->tcprecv);
#line 528
  ads___7->tcprecv_skip = 0;
#line 529
  tmp___8 = 0;
#line 529
  ads___7->tcpserver = tmp___8;
#line 529
  tmp___7 = tmp___8;
#line 529
  ads___7->nsearchlist = tmp___7;
#line 529
  tmp___6 = tmp___7;
#line 529
  ads___7->nsortlist = tmp___6;
#line 529
  ads___7->nservers = tmp___6;
#line 530
  ads___7->searchndots = 1;
#line 531
  ads___7->tcpstate = (enum adns__tcpstate )0;
#line 532
  tmp___9 = (__suseconds_t )0;
#line 532
  ads___7->tcptimeout.tv_usec = tmp___9;
#line 532
  ads___7->tcptimeout.tv_sec = tmp___9;
#line 533
  ads___7->searchlist = (char **)0;
#line 535
  pid = getpid();
#line 536
  ads___7->rand48xsubi[0] = (unsigned short )pid;
#line 537
  ads___7->rand48xsubi[1] = (unsigned short )((unsigned long )pid >> 16);
#line 538
  ads___7->rand48xsubi[2] = (unsigned short )((unsigned long )pid ^ ((unsigned long )pid >> 16));
#line 540
  *ads_r = ads___7;
  }
#line 541
  return (0);
}
}
#line 544 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static int init_finish___8(adns_state ads___7 ) 
{ 
  struct in_addr ia ;
  struct protoent *proto ;
  int r ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 549
  if (! ads___7->nservers) {
#line 550
    if (ads___7->logfn) {
#line 550
      if ((unsigned int )ads___7->iflags & 8U) {
        {
#line 551
        adns__lprintf(ads___7, "adns: no nameservers, using localhost\n");
        }
      }
    }
    {
#line 552
    ia.s_addr = htonl((in_addr_t )2130706433);
#line 553
    addserver___8(ads___7, ia);
    }
  }
  {
#line 556
  proto = getprotobyname("udp");
  }
#line 556
  if (! proto) {
#line 556
    r = 92;
#line 556
    goto x_free;
  }
  {
#line 557
  ads___7->udpsocket = socket(2, 2, proto->p_proto);
  }
#line 558
  if (ads___7->udpsocket < 0) {
    {
#line 558
    tmp = __errno_location();
#line 558
    r = *tmp;
    }
#line 558
    goto x_free;
  }
  {
#line 560
  r = adns__setnonblock(ads___7, ads___7->udpsocket);
  }
#line 561
  if (r) {
    {
#line 561
    tmp___0 = __errno_location();
#line 561
    r = *tmp___0;
    }
#line 561
    goto x_closeudp;
  }
#line 563
  return (0);
  x_closeudp: 
  {
#line 566
  close(ads___7->udpsocket);
  }
  x_free: 
  {
#line 568
  free((void *)ads___7);
  }
#line 569
  return (r);
}
}
#line 572 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void init_abort___8(adns_state ads___7 ) 
{ 


  {
#line 573
  if (ads___7->nsearchlist) {
    {
#line 574
    free((void *)*(ads___7->searchlist + 0));
#line 575
    free((void *)ads___7->searchlist);
    }
  }
  {
#line 577
  free((void *)ads___7);
  }
#line 578
  return;
}
}
#line 580 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void logfn_file___8(adns_state ads___7 , void *logfndata , char const   *fmt ,
                           va_list al ) 
{ 


  {
  {
#line 582
  vfprintf((FILE */* __restrict  */)logfndata, (char const   */* __restrict  */)fmt,
           al);
  }
#line 583
  return;
}
}
#line 585 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static int init_files___8(adns_state *ads_r , adns_initflags flags , adns_logcallbackfn *logfn ,
                          void *logfndata ) 
{ 
  adns_state ads___7 ;
  char const   *res_options ;
  char const   *adns_res_options ;
  int r ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 591
  r = init_begin___8(& ads___7, flags, logfn, logfndata);
  }
#line 592
  if (r) {
#line 592
    return (r);
  }
  {
#line 594
  res_options = instrum_getenv___8(ads___7, "RES_OPTIONS");
#line 595
  adns_res_options = instrum_getenv___8(ads___7, "ADNS_RES_OPTIONS");
#line 596
  ccf_options___8(ads___7, "RES_OPTIONS", -1, res_options);
#line 597
  ccf_options___8(ads___7, "ADNS_RES_OPTIONS", -1, adns_res_options);
#line 599
  readconfig___8(ads___7, "/etc/resolv.conf", 1);
#line 600
  readconfig___8(ads___7, "/etc/resolv-adns.conf", 0);
#line 601
  readconfigenv___8(ads___7, "RES_CONF");
#line 602
  readconfigenv___8(ads___7, "ADNS_RES_CONF");
#line 604
  readconfigenvtext___8(ads___7, "RES_CONF_TEXT");
#line 605
  readconfigenvtext___8(ads___7, "ADNS_RES_CONF_TEXT");
#line 607
  ccf_options___8(ads___7, "RES_OPTIONS", -1, res_options);
#line 608
  ccf_options___8(ads___7, "ADNS_RES_OPTIONS", -1, adns_res_options);
#line 610
  tmp = instrum_getenv___8(ads___7, "LOCALDOMAIN");
#line 610
  ccf_search___8(ads___7, "LOCALDOMAIN", -1, tmp);
#line 611
  tmp___0 = instrum_getenv___8(ads___7, "ADNS_LOCALDOMAIN");
#line 611
  ccf_search___8(ads___7, "ADNS_LOCALDOMAIN", -1, tmp___0);
  }
#line 613
  if (ads___7->configerrno) {
#line 613
    if (ads___7->configerrno != 22) {
      {
#line 614
      r = ads___7->configerrno;
#line 615
      init_abort___8(ads___7);
      }
#line 616
      return (r);
    }
  }
  {
#line 619
  r = init_finish___8(ads___7);
  }
#line 620
  if (r) {
#line 620
    return (r);
  }
  {
#line 622
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
#line 623
  *ads_r = ads___7;
  }
#line 624
  return (0);
}
}
#line 631 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static int init_strcfg___8(adns_state *ads_r , adns_initflags flags , adns_logcallbackfn *logfn ,
                           void *logfndata , char const   *configtext ) 
{ 
  adns_state ads___7 ;
  int r ;

  {
  {
#line 637
  r = init_begin___8(& ads___7, flags, logfn, logfndata);
  }
#line 638
  if (r) {
#line 638
    return (r);
  }
  {
#line 640
  readconfigtext___8(ads___7, configtext, "<supplied configuration text>");
  }
#line 641
  if (ads___7->configerrno) {
    {
#line 642
    r = ads___7->configerrno;
#line 643
    init_abort___8(ads___7);
    }
#line 644
    return (r);
  }
  {
#line 647
  r = init_finish___8(ads___7);
  }
#line 647
  if (r) {
#line 647
    return (r);
  }
  {
#line 648
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
#line 649
  *ads_r = ads___7;
  }
#line 650
  return (0);
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c"
static void tcp_close___8(adns_state ads___7 ) 
{ 
  int serv ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 48
  serv = ads___7->tcpserver;
#line 49
  close(ads___7->tcpsocket);
#line 50
  ads___7->tcpsocket = -1;
#line 51
  tmp___0 = 0;
#line 51
  ads___7->tcpsend.used = tmp___0;
#line 51
  tmp = tmp___0;
#line 51
  ads___7->tcprecv_skip = tmp;
#line 51
  ads___7->tcprecv.used = tmp;
  }
#line 52
  return;
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c"
static void tcp_connected___8(adns_state ads___7 , struct timeval now ) 
{ 
  adns_query qu ;
  adns_query nqu ;

  {
  {
#line 76
  adns__debug(ads___7, ads___7->tcpserver, (adns_query )0, "TCP connected");
#line 77
  ads___7->tcpstate = (enum adns__tcpstate )2;
#line 78
  qu = ads___7->tcpw.head;
  }
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (qu) {
#line 78
      if (! ((unsigned int )ads___7->tcpstate == 2U)) {
#line 78
        goto while_break;
      }
    } else {
#line 78
      goto while_break;
    }
#line 79
    nqu = qu->next;
#line 80
    if (! ((unsigned int )qu->state == 1U)) {
      {
#line 80
      __assert_fail("qu->state == query_tcpw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c",
                    80U, "tcp_connected");
      }
    }
    {
#line 81
    adns__querysend_tcp(qu, now);
#line 78
    qu = nqu;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c"
static void tcp_broken_events___8(adns_state ads___7 ) 
{ 
  adns_query qu ;
  adns_query nqu ;

  {
#line 88
  if (! ((unsigned int )ads___7->tcpstate == 3U)) {
    {
#line 88
    __assert_fail("ads->tcpstate == server_broken", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c",
                  88U, "tcp_broken_events");
    }
  }
#line 89
  qu = ads___7->tcpw.head;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! qu) {
#line 89
      goto while_break;
    }
#line 90
    nqu = qu->next;
#line 91
    if (! ((unsigned int )qu->state == 1U)) {
      {
#line 91
      __assert_fail("qu->state == query_tcpw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c",
                    91U, "tcp_broken_events");
      }
    }
#line 92
    if (qu->retries > ads___7->nservers) {
      {
#line 93
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 93
        if (qu->back) {
#line 93
          (qu->back)->next = qu->next;
        } else {
#line 93
          ads___7->tcpw.head = qu->next;
        }
#line 93
        if (qu->next) {
#line 93
          (qu->next)->back = qu->back;
        } else {
#line 93
          ads___7->tcpw.tail = qu->back;
        }
#line 93
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 94
      adns__query_fail(qu, (adns_status )31);
      }
    }
#line 89
    qu = nqu;
  }
  while_break: /* CIL Label */ ;
  }
#line 97
  ads___7->tcpstate = (enum adns__tcpstate )0;
#line 98
  return;
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c"
static void inter_immed___8(struct timeval **tv_io , struct timeval *tvbuf ) 
{ 
  struct timeval *rbuf ;
  __suseconds_t tmp ;

  {
#line 174
  if (! tv_io) {
#line 174
    return;
  }
#line 176
  rbuf = *tv_io;
#line 177
  if (! rbuf) {
#line 177
    rbuf = tvbuf;
#line 177
    *tv_io = rbuf;
  }
#line 179
  tmp = (__suseconds_t )0;
#line 179
  rbuf->tv_usec = tmp;
#line 179
  rbuf->tv_sec = tmp;
#line 180
  return;
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c"
static void inter_maxto___8(struct timeval **tv_io , struct timeval *tvbuf , struct timeval maxto ) 
{ 
  struct timeval *rbuf ;
  int tmp ;

  {
#line 186
  if (! tv_io) {
#line 186
    return;
  }
#line 187
  rbuf = *tv_io;
#line 188
  if (! rbuf) {
#line 189
    *tvbuf = maxto;
#line 189
    *tv_io = tvbuf;
  } else {
#line 191
    if (rbuf->tv_sec == maxto.tv_sec) {
#line 191
      tmp = rbuf->tv_usec > maxto.tv_usec;
    } else {
#line 191
      tmp = rbuf->tv_sec > maxto.tv_sec;
    }
#line 191
    if (tmp) {
#line 191
      *rbuf = maxto;
    }
  }
#line 195
  return;
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c"
static void inter_maxtoabs___8(struct timeval **tv_io , struct timeval *tvbuf , struct timeval now ,
                               struct timeval maxtime ) 
{ 
  ldiv_t dr ;

  {
#line 204
  if (! tv_io) {
#line 204
    return;
  }
  {
#line 205
  maxtime.tv_sec -= now.tv_sec + 2L;
#line 206
  maxtime.tv_usec -= now.tv_usec - 2000000L;
#line 207
  dr = ldiv(maxtime.tv_usec, 1000000L);
#line 208
  maxtime.tv_sec += dr.quot;
#line 209
  maxtime.tv_usec -= dr.quot * 1000000L;
  }
#line 210
  if (maxtime.tv_sec < 0L) {
#line 210
    maxtime.tv_usec = (__suseconds_t )0;
#line 210
    maxtime.tv_sec = maxtime.tv_usec;
  }
  {
#line 211
  inter_maxto___8(tv_io, tvbuf, maxtime);
  }
#line 212
  return;
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c"
static void timeouts_queue___8(adns_state ads___7 , int act , struct timeval **tv_io ,
                               struct timeval *tvbuf , struct timeval now , struct query_queue *queue ) 
{ 
  adns_query qu ;
  adns_query nqu ;
  int tmp ;

  {
#line 219
  qu = queue->head;
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if (! qu) {
#line 219
      goto while_break;
    }
#line 220
    nqu = qu->next;
#line 221
    if (now.tv_sec == qu->timeout.tv_sec) {
#line 221
      tmp = now.tv_usec > qu->timeout.tv_usec;
    } else {
#line 221
      tmp = now.tv_sec > qu->timeout.tv_sec;
    }
#line 221
    if (tmp) {
#line 224
      if (! act) {
        {
#line 224
        inter_immed___8(tv_io, tvbuf);
        }
#line 224
        return;
      }
      {
#line 225
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 225
        if (qu->back) {
#line 225
          (qu->back)->next = qu->next;
        } else {
#line 225
          queue->head = qu->next;
        }
#line 225
        if (qu->next) {
#line 225
          (qu->next)->back = qu->back;
        } else {
#line 225
          queue->tail = qu->back;
        }
#line 225
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 226
      if ((unsigned int )qu->state != 0U) {
        {
#line 227
        adns__query_fail(qu, (adns_status )30);
        }
      } else {
        {
#line 229
        adns__query_send(qu, now);
        }
      }
#line 231
      nqu = queue->head;
    } else {
      {
#line 222
      inter_maxtoabs___8(tv_io, tvbuf, now, qu->timeout);
      }
    }
#line 219
    qu = nqu;
  }
  while_break: /* CIL Label */ ;
  }
#line 234
  return;
}
}
#line 236 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c"
static void tcp_events___8(adns_state ads___7 , int act , struct timeval **tv_io ,
                           struct timeval *tvbuf , struct timeval now ) 
{ 
  int tmp ;

  {
  {
#line 239
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 241
    if ((unsigned int )ads___7->tcpstate == 3U) {
#line 241
      goto case_3;
    }
#line 244
    if ((unsigned int )ads___7->tcpstate == 0U) {
#line 244
      goto case_0;
    }
#line 249
    if ((unsigned int )ads___7->tcpstate == 2U) {
#line 249
      goto case_2;
    }
#line 256
    if ((unsigned int )ads___7->tcpstate == 1U) {
#line 256
      goto case_1;
    }
#line 275
    goto switch_default___0;
    case_3: /* CIL Label */ 
#line 242
    if (! act) {
      {
#line 242
      inter_immed___8(tv_io, tvbuf);
      }
#line 242
      return;
    }
    {
#line 243
    tcp_broken_events___8(ads___7);
    }
    case_0: /* CIL Label */ 
#line 245
    if (! ads___7->tcpw.head) {
#line 245
      return;
    }
#line 246
    if (! act) {
      {
#line 246
      inter_immed___8(tv_io, tvbuf);
      }
#line 246
      return;
    }
    {
#line 247
    adns__tcp_tryconnect(ads___7, now);
    }
#line 248
    goto switch_break;
    case_2: /* CIL Label */ 
#line 250
    if (ads___7->tcpw.head) {
#line 250
      return;
    }
#line 251
    if (! ads___7->tcptimeout.tv_sec) {
#line 252
      if (! (! ads___7->tcptimeout.tv_usec)) {
        {
#line 252
        __assert_fail("!ads->tcptimeout.tv_usec", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c",
                      252U, "tcp_events");
        }
      }
      {
#line 253
      ads___7->tcptimeout = now;
#line 254
      timevaladd___18(& ads___7->tcptimeout, 30000L);
      }
    }
    case_1: /* CIL Label */ 
#line 257
    if (! act) {
      {
#line 258
      inter_maxtoabs___8(tv_io, tvbuf, now, ads___7->tcptimeout);
      }
#line 259
      return;
    } else {
#line 257
      if (now.tv_sec == ads___7->tcptimeout.tv_sec) {
#line 257
        tmp = now.tv_usec > ads___7->tcptimeout.tv_usec;
      } else {
#line 257
        tmp = now.tv_sec > ads___7->tcptimeout.tv_sec;
      }
#line 257
      if (! tmp) {
        {
#line 258
        inter_maxtoabs___8(tv_io, tvbuf, now, ads___7->tcptimeout);
        }
#line 259
        return;
      }
    }
    {
#line 263
    if ((unsigned int )ads___7->tcpstate == 1U) {
#line 263
      goto case_1___0;
    }
#line 266
    if ((unsigned int )ads___7->tcpstate == 2U) {
#line 266
      goto case_2___0;
    }
#line 270
    goto switch_default;
    case_1___0: /* CIL Label */ 
    {
#line 264
    adns__tcp_broken(ads___7, "unable to make connection", "timed out");
    }
#line 265
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 267
    tcp_close___8(ads___7);
#line 268
    ads___7->tcpstate = (enum adns__tcpstate )0;
    }
#line 269
    return;
    switch_default: /* CIL Label */ 
    {
#line 271
    abort();
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 274
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
#line 276
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 279
  return;
}
}
#line 516 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c"
static void fd_event___8(adns_state ads___7 , int fd , int revent , int pollflag ,
                         int maxfd , fd_set const   *fds , int (*func)(adns_state  ,
                                                                       int fd , struct timeval  const  *now ) ,
                         struct timeval now , int *r_r ) 
{ 
  int r ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 524
  if (! (revent & pollflag)) {
#line 524
    return;
  }
#line 525
  if (fds) {
#line 525
    if (fd < maxfd) {
#line 525
      if (! ((fds->__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
#line 525
        return;
      }
    } else {
#line 525
      return;
    }
  }
  {
#line 526
  r = (*func)(ads___7, fd, (struct timeval  const  *)(& now));
  }
#line 527
  if (r) {
#line 528
    if (r_r) {
#line 529
      *r_r = r;
    } else {
      {
#line 531
      tmp = __errno_location();
#line 531
      tmp___0 = strerror(*tmp);
#line 531
      adns__diag(ads___7, -1, (adns_query )0, "process fd failed after select: %s",
                 tmp___0);
#line 533
      adns_globalsystemfailure(ads___7);
      }
    }
  }
#line 536
  return;
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c"
static void checkc_query_alloc___8(adns_state ads___7 , adns_query qu ) 
{ 
  allocnode *an ;
  int tmp ;

  {
#line 58
  if (qu->allocations.head) {
#line 58
    if (! (! (qu->allocations.head)->back)) {
      {
#line 58
      __assert_fail("! (qu->allocations).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                    59U, "checkc_query_alloc");
      }
    }
#line 58
    an = qu->allocations.head;
    {
#line 58
    while (1) {
      while_continue: /* CIL Label */ ;
#line 58
      if (! an) {
#line 58
        goto while_break;
      }
#line 58
      if (an->next) {
#line 58
        tmp = (unsigned long )an == (unsigned long )(an->next)->back;
      } else {
#line 58
        tmp = (unsigned long )an == (unsigned long )qu->allocations.tail;
      }
#line 58
      if (! tmp) {
        {
#line 58
        __assert_fail("(an)-> next ? (an) == (an)-> next-> back : (an) == (qu->allocations).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      59U, "checkc_query_alloc");
        }
      }
#line 58
      an = an->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 60
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c"
static void checkc_query___8(adns_state ads___7 , adns_query qu ) 
{ 
  adns_query child ;

  {
#line 65
  if (! (qu->udpnextserver < ads___7->nservers)) {
    {
#line 65
    __assert_fail("qu->udpnextserver < ads->nservers", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  65U, "checkc_query");
    }
  }
#line 66
  if (! (! (qu->udpsent & (0xffffffffffffffffUL << ads___7->nservers)))) {
    {
#line 66
    __assert_fail("!(qu->udpsent & (~0UL << ads->nservers))", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  66U, "checkc_query");
    }
  }
#line 67
  if (! (qu->search_pos <= ads___7->nsearchlist)) {
    {
#line 67
    __assert_fail("qu->search_pos <= ads->nsearchlist", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  67U, "checkc_query");
    }
  }
#line 68
  if (qu->parent) {
    {
#line 68
    while (1) {
      while_continue: /* CIL Label */ ;
#line 68
      child = (qu->parent)->children.head;
      {
#line 68
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 68
        if (! ((unsigned long )child != (unsigned long )qu)) {
#line 68
          goto while_break___0;
        }
#line 68
        if (! child) {
          {
#line 68
          __assert_fail("(child)", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                        68U, "checkc_query");
          }
        }
#line 68
        child = child->siblings.next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 68
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 69
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c"
static void checkc_notcpbuf___8(adns_state ads___7 ) 
{ 


  {
#line 72
  if (! (! ads___7->tcpsend.used)) {
    {
#line 72
    __assert_fail("!ads->tcpsend.used", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  72U, "checkc_notcpbuf");
    }
  }
#line 73
  if (! (! ads___7->tcprecv.used)) {
    {
#line 73
    __assert_fail("!ads->tcprecv.used", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  73U, "checkc_notcpbuf");
    }
  }
#line 74
  if (! (! ads___7->tcprecv_skip)) {
    {
#line 74
    __assert_fail("!ads->tcprecv_skip", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  74U, "checkc_notcpbuf");
    }
  }
#line 75
  return;
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c"
static void checkc_global___8(adns_state ads___7 ) 
{ 
  int i ;

  {
#line 80
  if (! (ads___7->udpsocket >= 0)) {
    {
#line 80
    __assert_fail("ads->udpsocket >= 0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  80U, "checkc_global");
    }
  }
#line 82
  i = 0;
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! (i < ads___7->nsortlist)) {
#line 82
      goto while_break;
    }
#line 83
    if (! (! (ads___7->sortlist[i].base.s_addr & ~ ads___7->sortlist[i].mask.s_addr))) {
      {
#line 83
      __assert_fail("!(ads->sortlist[i].base.s_addr & ~ads->sortlist[i].mask.s_addr)",
                    "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                    83U, "checkc_global");
      }
    }
#line 82
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  if (ads___7->tcpserver >= 0) {
#line 85
    if (! (ads___7->tcpserver < ads___7->nservers)) {
      {
#line 85
      __assert_fail("ads->tcpserver >= 0 && ads->tcpserver < ads->nservers", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                    85U, "checkc_global");
      }
    }
  } else {
    {
#line 85
    __assert_fail("ads->tcpserver >= 0 && ads->tcpserver < ads->nservers", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  85U, "checkc_global");
    }
  }
  {
#line 88
  if ((unsigned int )ads___7->tcpstate == 1U) {
#line 88
    goto case_1;
  }
#line 93
  if ((unsigned int )ads___7->tcpstate == 3U) {
#line 93
    goto case_3;
  }
#line 93
  if ((unsigned int )ads___7->tcpstate == 0U) {
#line 93
    goto case_3;
  }
#line 97
  if ((unsigned int )ads___7->tcpstate == 2U) {
#line 97
    goto case_2;
  }
#line 101
  goto switch_default;
  case_1: /* CIL Label */ 
#line 89
  if (! (ads___7->tcpsocket >= 0)) {
    {
#line 89
    __assert_fail("ads->tcpsocket >= 0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  89U, "checkc_global");
    }
  }
  {
#line 90
  checkc_notcpbuf___8(ads___7);
  }
#line 91
  goto switch_break;
  case_3: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 94
  if (! (ads___7->tcpsocket == -1)) {
    {
#line 94
    __assert_fail("ads->tcpsocket == -1", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  94U, "checkc_global");
    }
  }
  {
#line 95
  checkc_notcpbuf___8(ads___7);
  }
#line 96
  goto switch_break;
  case_2: /* CIL Label */ 
#line 98
  if (! (ads___7->tcpsocket >= 0)) {
    {
#line 98
    __assert_fail("ads->tcpsocket >= 0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  98U, "checkc_global");
    }
  }
#line 99
  if (! (ads___7->tcprecv_skip <= ads___7->tcprecv.used)) {
    {
#line 99
    __assert_fail("ads->tcprecv_skip <= ads->tcprecv.used", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  99U, "checkc_global");
    }
  }
#line 100
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 102
  __assert_fail("!\"ads->tcpstate value\"", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                102U, "checkc_global");
  }
  switch_break: /* CIL Label */ ;
  }
#line 105
  if (! ads___7->searchlist) {
#line 105
    if (! (! ads___7->nsearchlist)) {
      {
#line 105
      __assert_fail("ads->searchlist || !ads->nsearchlist", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                    105U, "checkc_global");
      }
    }
  }
#line 106
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c"
static void checkc_queue_udpw___8(adns_state ads___7 ) 
{ 
  adns_query qu ;
  int tmp ;

  {
#line 111
  if (ads___7->udpw.head) {
#line 111
    if (! (! (ads___7->udpw.head)->back)) {
      {
#line 111
      __assert_fail("! (ads->udpw).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                    118U, "checkc_queue_udpw");
      }
    }
#line 111
    qu = ads___7->udpw.head;
    {
#line 111
    while (1) {
      while_continue: /* CIL Label */ ;
#line 111
      if (! qu) {
#line 111
        goto while_break;
      }
#line 111
      if (qu->next) {
#line 111
        tmp = (unsigned long )qu == (unsigned long )(qu->next)->back;
      } else {
#line 111
        tmp = (unsigned long )qu == (unsigned long )ads___7->udpw.tail;
      }
#line 111
      if (! tmp) {
        {
#line 111
        __assert_fail("(qu)-> next ? (qu) == (qu)-> next-> back : (qu) == (ads->udpw).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! ((unsigned int )qu->state == 0U)) {
        {
#line 111
        __assert_fail("qu->state==query_tosend", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! (qu->retries <= 15)) {
        {
#line 111
        __assert_fail("qu->retries <= 15", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! qu->udpsent) {
        {
#line 111
        __assert_fail("qu->udpsent", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! qu->children.head) {
#line 111
        if (! (! qu->children.tail)) {
          {
#line 111
          __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                        118U, "checkc_queue_udpw");
          }
        }
      } else {
        {
#line 111
        __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
      {
#line 111
      checkc_query___8(ads___7, qu);
#line 111
      checkc_query_alloc___8(ads___7, qu);
#line 111
      qu = qu->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 119
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c"
static void checkc_queue_tcpw___8(adns_state ads___7 ) 
{ 
  adns_query qu ;
  int tmp ;

  {
#line 124
  if (ads___7->tcpw.head) {
#line 124
    if (! (! (ads___7->tcpw.head)->back)) {
      {
#line 124
      __assert_fail("! (ads->tcpw).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                    130U, "checkc_queue_tcpw");
      }
    }
#line 124
    qu = ads___7->tcpw.head;
    {
#line 124
    while (1) {
      while_continue: /* CIL Label */ ;
#line 124
      if (! qu) {
#line 124
        goto while_break;
      }
#line 124
      if (qu->next) {
#line 124
        tmp = (unsigned long )qu == (unsigned long )(qu->next)->back;
      } else {
#line 124
        tmp = (unsigned long )qu == (unsigned long )ads___7->tcpw.tail;
      }
#line 124
      if (! tmp) {
        {
#line 124
        __assert_fail("(qu)-> next ? (qu) == (qu)-> next-> back : (qu) == (ads->tcpw).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
#line 124
      if (! ((unsigned int )qu->state == 1U)) {
        {
#line 124
        __assert_fail("qu->state==query_tcpw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
#line 124
      if (! qu->children.head) {
#line 124
        if (! (! qu->children.tail)) {
          {
#line 124
          __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                        130U, "checkc_queue_tcpw");
          }
        }
      } else {
        {
#line 124
        __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
#line 124
      if (! (qu->retries <= ads___7->nservers + 1)) {
        {
#line 124
        __assert_fail("qu->retries <= ads->nservers+1", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
      {
#line 124
      checkc_query___8(ads___7, qu);
#line 124
      checkc_query_alloc___8(ads___7, qu);
#line 124
      qu = qu->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 131
  return;
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c"
static void checkc_queue_childw___8(adns_state ads___7 ) 
{ 
  adns_query parent ;
  adns_query child ;
  int tmp ;
  int tmp___0 ;

  {
#line 136
  if (ads___7->childw.head) {
#line 136
    if (! (! (ads___7->childw.head)->back)) {
      {
#line 136
      __assert_fail("! (ads->childw).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                    145U, "checkc_queue_childw");
      }
    }
#line 136
    parent = ads___7->childw.head;
    {
#line 136
    while (1) {
      while_continue: /* CIL Label */ ;
#line 136
      if (! parent) {
#line 136
        goto while_break;
      }
#line 136
      if (parent->next) {
#line 136
        tmp = (unsigned long )parent == (unsigned long )(parent->next)->back;
      } else {
#line 136
        tmp = (unsigned long )parent == (unsigned long )ads___7->childw.tail;
      }
#line 136
      if (! tmp) {
        {
#line 136
        __assert_fail("(parent)-> next ? (parent) == (parent)-> next-> back : (parent) == (ads->childw).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      145U, "checkc_queue_childw");
        }
      }
#line 136
      if (! ((unsigned int )parent->state == 2U)) {
        {
#line 136
        __assert_fail("parent->state == query_childw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      145U, "checkc_queue_childw");
        }
      }
#line 136
      if (! parent->children.head) {
        {
#line 136
        __assert_fail("parent->children.head", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      145U, "checkc_queue_childw");
        }
      }
#line 136
      if (parent->children.head) {
#line 136
        if (! (! (parent->children.head)->siblings.back)) {
          {
#line 136
          __assert_fail("! (parent->children).head->siblings. back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                        145U, "checkc_queue_childw");
          }
        }
#line 136
        child = parent->children.head;
        {
#line 136
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 136
          if (! child) {
#line 136
            goto while_break___0;
          }
#line 136
          if (child->siblings.next) {
#line 136
            tmp___0 = (unsigned long )child == (unsigned long )(child->siblings.next)->siblings.back;
          } else {
#line 136
            tmp___0 = (unsigned long )child == (unsigned long )parent->children.tail;
          }
#line 136
          if (! tmp___0) {
            {
#line 136
            __assert_fail("(child)->siblings. next ? (child) == (child)->siblings. next->siblings. back : (child) == (parent->children).tail",
                          "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                          145U, "checkc_queue_childw");
            }
          }
#line 136
          if (! ((unsigned long )child->parent == (unsigned long )parent)) {
            {
#line 136
            __assert_fail("child->parent == parent", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                          145U, "checkc_queue_childw");
            }
          }
#line 136
          if (! ((unsigned int )child->state != 3U)) {
            {
#line 136
            __assert_fail("child->state != query_done", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                          145U, "checkc_queue_childw");
            }
          }
#line 136
          child = child->siblings.next;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 136
      checkc_query___8(ads___7, parent);
#line 136
      checkc_query_alloc___8(ads___7, parent);
#line 136
      parent = parent->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 146
  return;
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c"
static void checkc_queue_output___8(adns_state ads___7 ) 
{ 
  adns_query qu ;
  int tmp ;

  {
#line 151
  if (ads___7->output.head) {
#line 151
    if (! (! (ads___7->output.head)->back)) {
      {
#line 151
      __assert_fail("! (ads->output).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                    157U, "checkc_queue_output");
      }
    }
#line 151
    qu = ads___7->output.head;
    {
#line 151
    while (1) {
      while_continue: /* CIL Label */ ;
#line 151
      if (! qu) {
#line 151
        goto while_break;
      }
#line 151
      if (qu->next) {
#line 151
        tmp = (unsigned long )qu == (unsigned long )(qu->next)->back;
      } else {
#line 151
        tmp = (unsigned long )qu == (unsigned long )ads___7->output.tail;
      }
#line 151
      if (! tmp) {
        {
#line 151
        __assert_fail("(qu)-> next ? (qu) == (qu)-> next-> back : (qu) == (ads->output).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! ((unsigned int )qu->state == 3U)) {
        {
#line 151
        __assert_fail("qu->state == query_done", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! qu->children.head) {
#line 151
        if (! (! qu->children.tail)) {
          {
#line 151
          __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                        157U, "checkc_queue_output");
          }
        }
      } else {
        {
#line 151
        __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! (! qu->parent)) {
        {
#line 151
        __assert_fail("!qu->parent", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! qu->allocations.head) {
#line 151
        if (! (! qu->allocations.tail)) {
          {
#line 151
          __assert_fail("!qu->allocations.head && !qu->allocations.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                        157U, "checkc_queue_output");
          }
        }
      } else {
        {
#line 151
        __assert_fail("!qu->allocations.head && !qu->allocations.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
      {
#line 151
      checkc_query___8(ads___7, qu);
#line 151
      qu = qu->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 158
  return;
}
}
#line 263 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/fanftest.c"
static char const   *progname___2  ;
#line 50 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/fanftest.c"
static void aargh___2(char const   *msg___5 ) 
{ 
  int *tmp ;
  int *tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 51
  tmp = __errno_location();
#line 51
  tmp___5 = __errno_location();
#line 51
  tmp___6 = strerror(*tmp___5);
  }
#line 51
  if (tmp___6) {
    {
#line 51
    tmp___2 = __errno_location();
#line 51
    tmp___3 = strerror(*tmp___2);
#line 51
    tmp___4 = (char const   *)tmp___3;
    }
  } else {
#line 51
    tmp___4 = "Unknown error";
  }
  {
#line 51
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s (%d)\n",
          progname___2, msg___5, tmp___4, *tmp);
#line 53
  exit(1);
  }
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsheloex.c"
static char const   * const  progname___3  =    (char const   */* const  */)"adnsheloex";
#line 70 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsheloex.c"
static char const   *config_text___6  ;
#line 77 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsheloex.c"
static void msg___2(char const   *fmt  , ...) 
{ 
  va_list al ;

  {
  {
#line 80
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
          progname___3);
#line 81
  __builtin_va_start(al, fmt);
#line 82
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           al);
#line 83
  __builtin_va_end(al);
#line 84
  fputc('\n', stderr);
  }
#line 85
  return;
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsheloex.c"
static void aargh___3(char const   *cause ) 
{ 
  char const   *why ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 88
  tmp = __errno_location();
#line 88
  tmp___0 = strerror(*tmp);
#line 88
  why = (char const   *)tmp___0;
  }
#line 89
  if (! why) {
#line 89
    why = "Unknown error";
  }
  {
#line 90
  tmp___1 = __errno_location();
#line 90
  msg___2("%s: %s (%d)", cause, why, *tmp___1);
#line 91
  exit(1);
  }
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsheloex.c"
static char buf___10[1024]  ;
#line 100 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsheloex.c"
static logline___0 *readline___2(FILE *inf , adns_state adns , int opts ) 
{ 
  char *str ;
  char *p ;
  char *q ;
  char *r ;
  logline___0 *line ;
  size_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 105
  tmp___5 = fgets((char */* __restrict  */)(buf___10), 1024, (FILE */* __restrict  */)inf);
  }
#line 105
  if (tmp___5) {
    {
#line 106
    tmp = strlen((char const   *)(buf___10));
#line 106
    tmp___0 = malloc((sizeof(*line) + tmp) + 1UL);
#line 106
    str = (char *)tmp___0;
    }
#line 107
    if (! str) {
      {
#line 107
      aargh___3("malloc");
      }
    }
    {
#line 108
    line = (logline___0 *)str;
#line 109
    line->next = (struct logline___0 *)((void *)0);
#line 110
    line->start = str + sizeof(logline___0 );
#line 111
    strcpy((char */* __restrict  */)line->start, (char const   */* __restrict  */)(buf___10));
#line 112
    tmp___2 = (char *)((void *)0);
#line 112
    line->addr = tmp___2;
#line 112
    tmp___1 = tmp___2;
#line 112
    line->rest = tmp___1;
#line 112
    line->name = tmp___1;
#line 115
    p = strchr((char const   *)line->start, ' ');
    }
    {
#line 115
    while (1) {
      while_continue: /* CIL Label */ ;
#line 115
      if (! p) {
#line 115
        goto while_break;
      }
      {
#line 116
      tmp___3 = strncmp((char const   *)p, " H=", (size_t )3);
      }
#line 116
      if (! tmp___3) {
        {
#line 117
        r = strchr((char const   *)p, '[');
        }
#line 118
        if (! r) {
#line 118
          goto while_break;
        }
        {
#line 119
        q = strchr((char const   *)p, ')');
        }
#line 120
        if (! q) {
#line 120
          goto while_break;
        } else
#line 120
        if ((unsigned long )q > (unsigned long )r) {
#line 120
          goto while_break;
        }
        {
#line 121
        p = strchr((char const   *)p, '(');
        }
#line 122
        if (! p) {
#line 122
          goto while_break;
        } else
#line 122
        if ((unsigned long )p > (unsigned long )q) {
#line 122
          goto while_break;
        }
#line 123
        line->name = p + 1;
#line 124
        line->rest = q;
#line 125
        line->addr = r + 1;
#line 126
        goto while_break;
      }
      {
#line 115
      p = strchr((char const   *)(p + 1), ' ');
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 129
    if (line->name) {
#line 130
      *(line->rest) = (char )'\000';
#line 131
      if (opts & 1) {
        {
#line 132
        msg___2("submitting %s", line->name);
        }
      }
      {
#line 133
      tmp___4 = adns_submit(adns, (char const   *)line->name, (adns_rrtype )1, (adns_queryflags )272,
                            (void *)0, & line->query);
      }
#line 133
      if (tmp___4) {
        {
#line 136
        aargh___3("adns_submit");
        }
      }
#line 137
      *(line->rest) = (char )')';
    } else {
#line 139
      if (opts & 1) {
        {
#line 140
        msg___2("no query");
        }
      }
#line 141
      line->query = (adns_query )((void *)0);
    }
#line 143
    return (line);
  }
  {
#line 145
  tmp___6 = feof(inf);
  }
#line 145
  if (! tmp___6) {
    {
#line 146
    aargh___3("fgets");
    }
  }
#line 147
  return ((logline___0 *)((void *)0));
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsheloex.c"
static void proclog___2(FILE *inf , FILE *outf , int maxpending , int opts ) 
{ 
  int eof ;
  int err ;
  int len ;
  adns_state adns ;
  adns_answer *answer ;
  logline___0 *head ;
  logline___0 *tail ;
  logline___0 *line ;
  adns_initflags initflags___3 ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char const   *addr ;
  int ok ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;

  {
#line 157
  if (opts & 1) {
#line 157
    initflags___3 = (adns_initflags )8;
  } else {
#line 157
    initflags___3 = (adns_initflags )0;
  }
#line 158
  if (config_text___6) {
    {
#line 159
    tmp = __errno_location();
#line 159
    *tmp = adns_init_strcfg(& adns, initflags___3, stderr, config_text___6);
    }
  } else {
    {
#line 161
    tmp___0 = __errno_location();
#line 161
    *tmp___0 = adns_init(& adns, initflags___3, (FILE *)0);
    }
  }
  {
#line 163
  tmp___1 = __errno_location();
  }
#line 163
  if (*tmp___1) {
    {
#line 163
    aargh___3("adns_init");
    }
  }
  {
#line 164
  tail = readline___2(inf, adns, opts);
#line 164
  head = tail;
#line 165
  len = 1;
#line 165
  eof = 0;
  }
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    if (! head) {
#line 166
      goto while_break;
    }
    {
#line 167
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 167
      if (! head) {
#line 167
        goto while_break___0;
      }
#line 168
      if (head->query) {
#line 169
        if (opts & 1) {
#line 170
          if (head->name) {
#line 170
            tmp___2 = (char const   *)head->name;
          } else {
#line 170
            tmp___2 = "";
          }
          {
#line 170
          msg___2("%d in queue; checking %.*s", len, (int )(head->rest - head->name),
                  tmp___2);
          }
        }
#line 172
        if (eof) {
#line 172
          goto _L;
        } else
#line 172
        if (len >= maxpending) {
          _L: /* CIL Label */ 
#line 173
          if (opts & 2) {
            {
#line 174
            err = adns_wait_poll(adns, & head->query, & answer, (void **)((void *)0));
            }
          } else {
            {
#line 176
            err = adns_wait(adns, & head->query, & answer, (void **)((void *)0));
            }
          }
        } else {
          {
#line 178
          err = adns_check(adns, & head->query, & answer, (void **)((void *)0));
          }
        }
#line 180
        if (err == 11) {
#line 180
          goto while_break___0;
        }
#line 181
        if (err) {
          {
#line 182
          tmp___3 = strerror(err);
#line 182
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: adns_wait/check: %s",
                  progname___3, tmp___3);
#line 183
          exit(1);
          }
        }
#line 185
        if ((unsigned int )answer->status == 0U) {
          {
#line 187
          ok = 0;
#line 188
          fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)"%.*s",
                  (int )(head->rest - head->start), head->start);
          }
          {
#line 189
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 189
            tmp___8 = answer->nrrs;
#line 189
            (answer->nrrs) --;
#line 189
            if (! tmp___8) {
#line 189
              goto while_break___1;
            }
            {
#line 190
            tmp___4 = inet_ntoa(*(answer->rrs.inaddr + answer->nrrs));
#line 190
            addr = (char const   *)tmp___4;
#line 191
            tmp___5 = strlen(addr);
#line 191
            tmp___6 = strncmp(addr, (char const   *)head->addr, tmp___5);
            }
#line 191
            if (tmp___6) {
#line 191
              tmp___7 = 0;
            } else {
#line 191
              tmp___7 = 1;
            }
            {
#line 191
            ok |= tmp___7;
#line 192
            fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)" [%s]",
                    addr);
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 194
          if (ok) {
#line 194
            tmp___9 = " OK";
          } else {
#line 194
            tmp___9 = "";
          }
          {
#line 194
          fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)"%s%s",
                  tmp___9, head->rest);
          }
        } else {
#line 196
          if (opts & 1) {
            {
#line 197
            msg___2("query failed");
            }
          }
          {
#line 198
          fputs((char const   */* __restrict  */)head->start, (FILE */* __restrict  */)outf);
          }
        }
        {
#line 200
        free((void *)answer);
#line 201
        len --;
        }
      } else {
#line 203
        if (opts & 1) {
          {
#line 204
          msg___2("%d in queue; no query on this line", len);
          }
        }
        {
#line 205
        fputs((char const   */* __restrict  */)head->start, (FILE */* __restrict  */)outf);
        }
      }
      {
#line 207
      line = head;
#line 207
      head = head->next;
#line 208
      free((void *)line);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 210
    if (! eof) {
      {
#line 211
      line = readline___2(inf, adns, opts);
      }
#line 212
      if (line) {
#line 213
        if (! head) {
#line 213
          head = line;
        } else {
#line 214
          tail->next = line;
        }
#line 215
        tail = line;
#line 216
        if (line->query) {
#line 216
          len ++;
        }
      } else {
#line 218
        eof = 1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 222
  adns_finish(adns);
  }
#line 223
  return;
}
}
#line 225 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsheloex.c"
static void printhelp___2(FILE *file ) 
{ 


  {
  {
#line 226
  fputs((char const   */* __restrict  */)"usage: adnsheloex [<options>] [<logfile>]\n       adnsheloex --version|--help\noptions: -c <concurrency>  set max number of outstanding queries\n         -p                use poll(2) instead of select(2)\n         -d                turn on debugging\n         -C <config>       use instead of contents of resolv.conf\n",
        (FILE */* __restrict  */)stdout);
  }
#line 233
  return;
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsheloex.c"
static void usage___5(void) 
{ 


  {
  {
#line 236
  printhelp___2(stderr);
#line 237
  exit(1);
  }
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnslogres.c"
static char const   * const  progname___4  =    (char const   */* const  */)"adnslogres";
#line 69 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnslogres.c"
static char const   *config_text___7  ;
#line 76 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnslogres.c"
static void msg___3(char const   *fmt  , ...) 
{ 
  va_list al ;

  {
  {
#line 79
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
          progname___4);
#line 80
  __builtin_va_start(al, fmt);
#line 81
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           al);
#line 82
  __builtin_va_end(al);
#line 83
  fputc('\n', stderr);
  }
#line 84
  return;
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnslogres.c"
static void aargh___4(char const   *cause ) 
{ 
  char const   *why ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 87
  tmp = __errno_location();
#line 87
  tmp___0 = strerror(*tmp);
#line 87
  why = (char const   *)tmp___0;
  }
#line 88
  if (! why) {
#line 88
    why = "Unknown error";
  }
  {
#line 89
  tmp___1 = __errno_location();
#line 89
  msg___3("%s: %s (%d)", cause, why, *tmp___1);
#line 90
  exit(1);
  }
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnslogres.c"
static char buf___11[30]  ;
#line 96 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnslogres.c"
static char *ipaddr2domain___1(char *start , char **addr , char **rest ) 
{ 
  char *ptrs[5] ;
  int i ;
  char *tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
#line 101
  ptrs[0] = start;
  retry: 
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 103
    tmp___1 = __ctype_b_loc();
    }
#line 103
    if ((int const   )*(*tmp___1 + (int )((unsigned char )*(ptrs[0]))) & 2048) {
#line 103
      goto while_break;
    }
#line 104
    tmp___0 = ptrs[0];
#line 104
    (ptrs[0]) ++;
#line 104
    if (! *tmp___0) {
      {
#line 105
      strcpy((char */* __restrict  */)(buf___11), (char const   */* __restrict  */)"invalid.");
#line 106
      tmp = (char *)((void *)0);
#line 106
      *rest = tmp;
#line 106
      *addr = tmp;
      }
#line 107
      return (buf___11);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 109
  i = 1;
  {
#line 109
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 109
    if (! (i < 5)) {
#line 109
      goto while_break___0;
    }
#line 110
    ptrs[i] = ptrs[i - 1];
    {
#line 111
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 111
      tmp___2 = __ctype_b_loc();
#line 111
      tmp___3 = ptrs[i];
#line 111
      (ptrs[i]) ++;
      }
#line 111
      if (! ((int const   )*(*tmp___2 + (int )((unsigned char )*tmp___3)) & 2048)) {
#line 111
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 112
    if (i == 4) {
      {
#line 112
      tmp___4 = __ctype_b_loc();
      }
#line 112
      if ((int const   )*(*tmp___4 + (int )((unsigned char )*(ptrs[i] + -1))) & 8192) {
#line 112
        goto _L___0;
      } else {
#line 115
        ptrs[0] = ptrs[i] - 1;
#line 116
        goto retry;
      }
    } else
    _L___0: /* CIL Label */ 
#line 112
    if (i != 4) {
#line 112
      if ((int )*(ptrs[i] + -1) != 46) {
#line 115
        ptrs[0] = ptrs[i] - 1;
#line 116
        goto retry;
      } else {
#line 112
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 112
    if (ptrs[i] - ptrs[i - 1] > 4L) {
#line 115
      ptrs[0] = ptrs[i] - 1;
#line 116
      goto retry;
    }
#line 109
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 119
  sprintf((char */* __restrict  */)(buf___11), (char const   */* __restrict  */)"%.*s.%.*s.%.*s.%.*s.in-addr.arpa.",
          (int )((ptrs[4] - ptrs[3]) - 1L), ptrs[3], (int )((ptrs[3] - ptrs[2]) - 1L),
          ptrs[2], (int )((ptrs[2] - ptrs[1]) - 1L), ptrs[1], (int )((ptrs[1] - ptrs[0]) - 1L),
          ptrs[0]);
#line 124
  *addr = ptrs[0];
#line 125
  *rest = ptrs[4] - 1;
  }
#line 126
  return (buf___11);
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnslogres.c"
static void printline___1(FILE *outf , char *start , char *addr , char *rest , char *domain ) 
{ 
  int tmp ;

  {
#line 130
  if (domain) {
    {
#line 131
    fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)"%.*s%s%s",
            (int )(addr - start), start, domain, rest);
    }
  } else {
    {
#line 133
    fputs((char const   */* __restrict  */)start, (FILE */* __restrict  */)outf);
    }
  }
  {
#line 134
  tmp = ferror(outf);
  }
#line 134
  if (tmp) {
    {
#line 134
    aargh___4("write output");
    }
  }
#line 135
  return;
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnslogres.c"
static char buf___12[1024]  ;
#line 143 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnslogres.c"
static logline *readline___3(FILE *inf , adns_state adns , int opts ) 
{ 
  char *str ;
  logline *line ;
  size_t tmp ;
  void *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 148
  tmp___3 = fgets((char */* __restrict  */)(buf___12), 1024, (FILE */* __restrict  */)inf);
  }
#line 148
  if (tmp___3) {
    {
#line 149
    tmp = strlen((char const   *)(buf___12));
#line 149
    tmp___0 = malloc((sizeof(*line) + tmp) + 1UL);
#line 149
    str = (char *)tmp___0;
    }
#line 150
    if (! str) {
      {
#line 150
      aargh___4("malloc");
      }
    }
    {
#line 151
    line = (logline *)str;
#line 152
    line->next = (struct logline *)((void *)0);
#line 153
    line->start = str + sizeof(logline );
#line 154
    strcpy((char */* __restrict  */)line->start, (char const   */* __restrict  */)(buf___12));
#line 155
    str = ipaddr2domain___1(line->start, & line->addr, & line->rest);
    }
#line 156
    if (opts & 1) {
#line 157
      if (line->addr) {
#line 157
        tmp___1 = (char const   *)line->addr;
      } else {
#line 157
        tmp___1 = "";
      }
      {
#line 157
      msg___3("submitting %.*s -> %s", (int )(line->rest - line->addr), tmp___1, str);
      }
    }
    {
#line 158
    tmp___2 = adns_submit(adns, (char const   *)str, (adns_rrtype )65548, (adns_queryflags )256,
                          (void *)0, & line->query);
    }
#line 158
    if (tmp___2) {
      {
#line 161
      aargh___4("adns_submit");
      }
    }
#line 162
    return (line);
  }
  {
#line 164
  tmp___4 = feof(inf);
  }
#line 164
  if (! tmp___4) {
    {
#line 165
    aargh___4("fgets");
    }
  }
#line 166
  return ((logline *)((void *)0));
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnslogres.c"
static void proclog___3(FILE *inf , FILE *outf , int maxpending , int opts ) 
{ 
  int eof ;
  int err ;
  int len ;
  adns_state adns ;
  adns_answer *answer ;
  logline *head ;
  logline *tail ;
  logline *line ;
  adns_initflags initflags___3 ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 176
  if (opts & 1) {
#line 176
    initflags___3 = (adns_initflags )8;
  } else {
#line 176
    initflags___3 = (adns_initflags )0;
  }
#line 177
  if (config_text___7) {
    {
#line 178
    tmp = __errno_location();
#line 178
    *tmp = adns_init_strcfg(& adns, initflags___3, stderr, config_text___7);
    }
  } else {
    {
#line 180
    tmp___0 = __errno_location();
#line 180
    *tmp___0 = adns_init(& adns, initflags___3, (FILE *)0);
    }
  }
  {
#line 182
  tmp___1 = __errno_location();
  }
#line 182
  if (*tmp___1) {
    {
#line 182
    aargh___4("adns_init");
    }
  }
  {
#line 183
  tail = readline___3(inf, adns, opts);
#line 183
  head = tail;
#line 184
  len = 1;
#line 184
  eof = 0;
  }
  {
#line 185
  while (1) {
    while_continue: /* CIL Label */ ;
#line 185
    if (! head) {
#line 185
      goto while_break;
    }
    {
#line 186
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 186
      if (! head) {
#line 186
        goto while_break___0;
      }
#line 187
      if (opts & 1) {
#line 188
        if (head->addr) {
#line 188
          tmp___2 = (char const   *)head->addr;
        } else {
#line 188
          tmp___2 = "";
        }
        {
#line 188
        msg___3("%d in queue; checking %.*s", len, (int )(head->rest - head->addr),
                tmp___2);
        }
      }
#line 190
      if (eof) {
#line 190
        goto _L;
      } else
#line 190
      if (len >= maxpending) {
        _L: /* CIL Label */ 
#line 191
        if (opts & 2) {
          {
#line 192
          err = adns_wait_poll(adns, & head->query, & answer, (void **)((void *)0));
          }
        } else {
          {
#line 194
          err = adns_wait(adns, & head->query, & answer, (void **)((void *)0));
          }
        }
      } else {
        {
#line 196
        err = adns_check(adns, & head->query, & answer, (void **)((void *)0));
        }
      }
#line 198
      if (err == 11) {
#line 198
        goto while_break___0;
      }
#line 199
      if (err) {
        {
#line 200
        tmp___3 = strerror(err);
#line 200
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: adns_wait/check: %s",
                progname___4, tmp___3);
#line 201
        exit(1);
        }
      }
#line 203
      if ((unsigned int )answer->status == 0U) {
#line 203
        tmp___4 = *(answer->rrs.str);
      } else {
#line 203
        tmp___4 = (char *)((void *)0);
      }
      {
#line 203
      printline___1(outf, head->start, head->addr, head->rest, tmp___4);
#line 205
      line = head;
#line 205
      head = head->next;
#line 206
      free((void *)line);
#line 207
      free((void *)answer);
#line 208
      len --;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 210
    if (! eof) {
      {
#line 211
      line = readline___3(inf, adns, opts);
      }
#line 212
      if (line) {
#line 213
        if (! head) {
#line 213
          head = line;
        } else {
#line 214
          tail->next = line;
        }
#line 215
        tail = line;
#line 215
        len ++;
      } else {
#line 217
        eof = 1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 221
  adns_finish(adns);
  }
#line 222
  return;
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnslogres.c"
static void printhelp___3(FILE *file ) 
{ 


  {
  {
#line 225
  fputs((char const   */* __restrict  */)"usage: adnslogres [<options>] [<logfile>]\n       adnslogres --version|--help\noptions: -c <concurrency>  set max number of outstanding queries\n         -p                use poll(2) instead of select(2)\n         -d                turn on debugging\n         -C <config>       use instead of contents of resolv.conf\n",
        (FILE */* __restrict  */)stdout);
  }
#line 232
  return;
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnslogres.c"
static void usage___6(void) 
{ 


  {
  {
#line 235
  printhelp___3(stderr);
#line 236
  exit(1);
  }
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pap_qstring___9(parseinfo const   *pai , int *cbyte_io , int max ,
                                   int *len_r , char **str_r ) 
{ 
  byte const   *dgram ;
  int l ;
  int cbyte___3 ;
  char *str ;
  int tmp ;
  void *tmp___0 ;

  {
#line 92
  dgram = (byte const   *)pai->dgram;
#line 96
  cbyte___3 = *cbyte_io;
#line 98
  if (cbyte___3 >= max) {
#line 98
    return ((adns_status )104);
  }
#line 99
  tmp = cbyte___3;
#line 99
  cbyte___3 ++;
#line 99
  l = (int )((int const   )*(dgram + tmp) & 255);
#line 100
  if (cbyte___3 + l > max) {
#line 100
    return ((adns_status )104);
  }
  {
#line 102
  tmp___0 = adns__alloc_interim((adns_query )pai->qu, (size_t )(l + 1));
#line 102
  str = (char *)tmp___0;
  }
#line 103
  if (! str) {
#line 103
    return ((adns_status )1);
  }
  {
#line 105
  *(str + l) = (char)0;
#line 106
  memcpy((void */* __restrict  */)str, (void const   */* __restrict  */)(dgram + cbyte___3),
         (size_t )l);
#line 108
  *len_r = l;
#line 109
  *str_r = str;
#line 110
  *cbyte_io = cbyte___3 + l;
  }
#line 112
  return ((adns_status )0);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status csp_qstring___9(vbuf *vb___0 , char const   *dp , int len ) 
{ 
  unsigned char ch ;
  char buf___17[10] ;
  int cn ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 120
    tmp = adns__vbuf_appendstr(vb___0, "\"");
    }
#line 120
    if (! tmp) {
#line 120
      return ((adns_status )1);
    }
#line 120
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  cn = 0;
  {
#line 121
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 121
    if (! (cn < len)) {
#line 121
      goto while_break___0;
    }
#line 122
    tmp___0 = dp;
#line 122
    dp ++;
#line 122
    ch = (unsigned char )*tmp___0;
#line 123
    if ((int )ch == 92) {
      {
#line 124
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 124
        tmp___1 = adns__vbuf_appendstr(vb___0, "\\\\");
        }
#line 124
        if (! tmp___1) {
#line 124
          return ((adns_status )1);
        }
#line 124
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else
#line 125
    if ((int )ch == 34) {
      {
#line 126
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 126
        tmp___2 = adns__vbuf_appendstr(vb___0, "\\\"");
        }
#line 126
        if (! tmp___2) {
#line 126
          return ((adns_status )1);
        }
#line 126
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else
#line 127
    if ((int )ch >= 32) {
#line 127
      if ((int )ch <= 126) {
        {
#line 128
        tmp___3 = adns__vbuf_append(vb___0, (byte const   *)(& ch), 1);
        }
#line 128
        if (! tmp___3) {
#line 128
          return ((adns_status )1);
        }
      } else {
#line 127
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 130
      sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"\\x%02x",
              (int )ch);
      }
      {
#line 131
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 131
        tmp___4 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
        }
#line 131
        if (! tmp___4) {
#line 131
          return ((adns_status )1);
        }
#line 131
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 121
    cn ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 134
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 134
    tmp___5 = adns__vbuf_appendstr(vb___0, "\"");
    }
#line 134
    if (! tmp___5) {
#line 134
      return ((adns_status )1);
    }
#line 134
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 136
  return ((adns_status )0);
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_str___9(adns_query qu , void *datap ) 
{ 
  char **rrp ;

  {
  {
#line 144
  rrp = (char **)datap;
#line 146
  adns__makefinal_str(qu, rrp);
  }
#line 147
  return;
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_intstr___9(adns_query qu , void *datap ) 
{ 
  adns_rr_intstr *rrp ;

  {
  {
#line 154
  rrp = (adns_rr_intstr *)datap;
#line 156
  adns__makefinal_str(qu, & rrp->str);
  }
#line 157
  return;
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_manyistr___9(adns_query qu , void *datap ) 
{ 
  adns_rr_intstr **rrp ;
  adns_rr_intstr *te ;
  adns_rr_intstr *table ;
  void *tablev ;
  int tc ;

  {
#line 164
  rrp = (adns_rr_intstr **)datap;
#line 169
  tc = 0;
#line 169
  te = *rrp;
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    if (! (te->i >= 0)) {
#line 169
      goto while_break;
    }
#line 169
    te ++;
#line 169
    tc ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 170
  tablev = (void *)*rrp;
#line 171
  adns__makefinal_block(qu, & tablev, sizeof(*te) * (unsigned long )(tc + 1));
#line 172
  table = (adns_rr_intstr *)tablev;
#line 172
  *rrp = table;
#line 173
  te = *rrp;
  }
  {
#line 173
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 173
    if (! (te->i >= 0)) {
#line 173
      goto while_break___0;
    }
    {
#line 174
    adns__makefinal_str(qu, & te->str);
#line 173
    te ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 175
  return;
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_txt___9(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  adns_rr_intstr **rrp ;
  adns_rr_intstr *table ;
  adns_rr_intstr *te ;
  byte const   *dgram ;
  int ti ;
  int tc ;
  int l ;
  int startbyte ;
  adns_status st ;
  int tmp ;
  void *tmp___0 ;

  {
#line 183
  rrp = (adns_rr_intstr **)datap;
#line 184
  dgram = (byte const   *)pai->dgram;
#line 188
  startbyte = cbyte___3;
#line 189
  if (cbyte___3 >= max) {
#line 189
    return ((adns_status )104);
  }
#line 190
  tc = 0;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! (cbyte___3 < max)) {
#line 191
      goto while_break;
    }
#line 192
    tmp = cbyte___3;
#line 192
    cbyte___3 ++;
#line 192
    l = (int )((int const   )*(dgram + tmp) & 255);
#line 193
    cbyte___3 += l;
#line 194
    tc ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  if (cbyte___3 != max) {
#line 196
    return ((adns_status )104);
  } else
#line 196
  if (! tc) {
#line 196
    return ((adns_status )104);
  }
  {
#line 198
  tmp___0 = adns__alloc_interim((adns_query )pai->qu, sizeof(*table) * (unsigned long )(tc + 1));
#line 198
  table = (adns_rr_intstr *)tmp___0;
  }
#line 199
  if (! table) {
#line 199
    return ((adns_status )1);
  }
#line 201
  cbyte___3 = startbyte;
#line 201
  ti = 0;
#line 201
  te = table;
  {
#line 201
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 201
    if (! (ti < tc)) {
#line 201
      goto while_break___0;
    }
    {
#line 202
    st = pap_qstring___9(pai, & cbyte___3, max, & te->i, & te->str);
    }
#line 203
    if (st) {
#line 203
      return (st);
    }
#line 201
    ti ++;
#line 201
    te ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 205
  if (! (cbyte___3 == max)) {
    {
#line 205
    __assert_fail("cbyte == max", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                  205U, "pa_txt");
    }
  }
#line 207
  te->i = -1;
#line 208
  te->str = (char *)0;
#line 210
  *rrp = table;
#line 211
  return ((adns_status )0);
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_txt___9(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_intstr const   * const  *rrp ;
  adns_rr_intstr const   *current ;
  adns_status st ;
  int spc ;
  int tmp ;

  {
#line 215
  rrp = (adns_rr_intstr const   * const  *)datap;
#line 220
  current = (adns_rr_intstr const   *)*rrp;
#line 220
  spc = 0;
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    if (! (current->i >= 0)) {
#line 220
      goto while_break;
    }
#line 221
    if (spc) {
      {
#line 221
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 221
        tmp = adns__vbuf_appendstr(vb___0, " ");
        }
#line 221
        if (! tmp) {
#line 221
          return ((adns_status )1);
        }
#line 221
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 222
    st = csp_qstring___9(vb___0, (char const   *)current->str, (int )current->i);
    }
#line 222
    if (st) {
#line 222
      return (st);
    }
#line 220
    current ++;
#line 220
    spc = 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  return ((adns_status )0);
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_hinfo___9(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_intstrpair const   *rrp ;
  adns_status st ;
  int tmp ;

  {
  {
#line 232
  rrp = (adns_rr_intstrpair const   *)datap;
#line 235
  st = csp_qstring___9(vb___0, (char const   *)rrp->array[0].str, (int )rrp->array[0].i);
  }
#line 235
  if (st) {
#line 235
    return (st);
  }
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 236
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 236
    if (! tmp) {
#line 236
      return ((adns_status )1);
    }
#line 236
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 237
  st = csp_qstring___9(vb___0, (char const   *)rrp->array[1].str, (int )rrp->array[1].i);
  }
#line 237
  if (st) {
#line 237
    return (st);
  }
#line 238
  return ((adns_status )0);
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_inaddr___9(parseinfo const   *pai , int cbyte___3 , int max ,
                                 void *datap ) 
{ 
  struct in_addr *storeto ;

  {
#line 247
  storeto = (struct in_addr *)datap;
#line 249
  if (max - cbyte___3 != 4) {
#line 249
    return ((adns_status )104);
  }
  {
#line 250
  memcpy((void */* __restrict  */)storeto, (void const   */* __restrict  */)(pai->dgram + cbyte___3),
         (size_t )4);
  }
#line 251
  return ((adns_status )0);
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int search_sortlist___9(adns_state ads___7 , struct in_addr ad ) 
{ 
  struct sortlist  const  *slp ;
  int i ;

  {
#line 258
  i = 0;
#line 258
  slp = (struct sortlist  const  *)(ads___7->sortlist);
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 258
    if (i < ads___7->nsortlist) {
#line 258
      if (! (! ((ad.s_addr & (unsigned int )slp->mask.s_addr) == (unsigned int )slp->base.s_addr))) {
#line 258
        goto while_break;
      }
    } else {
#line 258
      goto while_break;
    }
#line 258
    i ++;
#line 258
    slp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  return (i);
}
}
#line 265 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int dip_inaddr___9(adns_state ads___7 , struct in_addr a , struct in_addr b ) 
{ 
  int ai ;
  int bi ;

  {
#line 268
  if (! ads___7->nsortlist) {
#line 268
    return (0);
  }
  {
#line 270
  ai = search_sortlist___9(ads___7, a);
#line 271
  bi = search_sortlist___9(ads___7, b);
  }
#line 272
  return (bi < ai);
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int di_inaddr___9(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  struct in_addr  const  *ap ;
  struct in_addr  const  *bp ;
  int tmp ;

  {
  {
#line 277
  ap = (struct in_addr  const  *)datap_a;
#line 277
  bp = (struct in_addr  const  *)datap_b;
#line 279
  tmp = dip_inaddr___9(ads___7, (struct in_addr )*ap, (struct in_addr )*bp);
  }
#line 279
  return (tmp);
}
}
#line 282 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_inaddr___9(vbuf *vb___0 , void const   *datap ) 
{ 
  struct in_addr  const  *rrp ;
  struct in_addr rr ;
  char const   *ia ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 283
  rrp = (struct in_addr  const  *)datap;
#line 283
  rr = *rrp;
#line 286
  tmp = inet_ntoa(rr);
#line 286
  ia = (char const   *)tmp;
  }
#line 286
  if (! ia) {
    {
#line 286
    __assert_fail("ia", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                  286U, "cs_inaddr");
    }
  }
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 287
    tmp___0 = adns__vbuf_appendstr(vb___0, ia);
    }
#line 287
    if (! tmp___0) {
#line 287
      return ((adns_status )1);
    }
#line 287
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  return ((adns_status )0);
}
}
#line 295 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_addr___9(parseinfo const   *pai , int cbyte___3 , int max ,
                               void *datap ) 
{ 
  adns_rr_addr *storeto ;
  byte const   *dgram ;

  {
#line 297
  storeto = (adns_rr_addr *)datap;
#line 298
  dgram = (byte const   *)pai->dgram;
#line 300
  if (max - cbyte___3 != 4) {
#line 300
    return ((adns_status )104);
  }
  {
#line 301
  storeto->len = (int )sizeof(storeto->addr.inet);
#line 302
  memset((void *)(& storeto->addr), 0, sizeof(storeto->addr.inet));
#line 303
  storeto->addr.inet.sin_family = (sa_family_t )2;
#line 304
  memcpy((void */* __restrict  */)(& storeto->addr.inet.sin_addr), (void const   */* __restrict  */)(dgram + cbyte___3),
         (size_t )4);
  }
#line 305
  return ((adns_status )0);
}
}
#line 308 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int di_addr___9(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_addr const   *ap ;
  adns_rr_addr const   *bp ;
  int tmp ;

  {
#line 309
  ap = (adns_rr_addr const   *)datap_a;
#line 309
  bp = (adns_rr_addr const   *)datap_b;
#line 311
  if (! ((int const   )ap->addr.sa.sa_family == 2)) {
    {
#line 311
    __assert_fail("ap->addr.sa.sa_family == 2", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                  311U, "di_addr");
    }
  }
  {
#line 312
  tmp = dip_inaddr___9(ads___7, (struct in_addr )ap->addr.inet.sin_addr, (struct in_addr )bp->addr.inet.sin_addr);
  }
#line 312
  return (tmp);
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int div_addr___9(void *context , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_state ads___7 ;
  int tmp ;

  {
  {
#line 316
  ads___7 = (adns_state )context;
#line 318
  tmp = di_addr___9(ads___7, datap_a, datap_b);
  }
#line 318
  return (tmp);
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status csp_addr___9(vbuf *vb___0 , adns_rr_addr const   *rrp ) 
{ 
  char const   *ia ;
  char buf___17[30] ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 326
  if ((int const   )rrp->addr.inet.sin_family == 2) {
#line 326
    goto case_2;
  }
#line 331
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 327
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 327
    tmp = adns__vbuf_appendstr(vb___0, "INET ");
    }
#line 327
    if (! tmp) {
#line 327
      return ((adns_status )1);
    }
#line 327
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 328
  tmp___0 = inet_ntoa((struct in_addr )rrp->addr.inet.sin_addr);
#line 328
  ia = (char const   *)tmp___0;
  }
#line 328
  if (! ia) {
    {
#line 328
    __assert_fail("ia", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                  328U, "csp_addr");
    }
  }
  {
#line 329
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 329
    tmp___1 = adns__vbuf_appendstr(vb___0, ia);
    }
#line 329
    if (! tmp___1) {
#line 329
      return ((adns_status )1);
    }
#line 329
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 330
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 332
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"AF=%u",
          (int const   )rrp->addr.sa.sa_family);
  }
  {
#line 333
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 333
    tmp___2 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 333
    if (! tmp___2) {
#line 333
      return ((adns_status )1);
    }
#line 333
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 334
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 336
  return ((adns_status )0);
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_addr___9(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_addr const   *rrp ;
  adns_status tmp ;

  {
  {
#line 340
  rrp = (adns_rr_addr const   *)datap;
#line 342
  tmp = csp_addr___9(vb___0, rrp);
  }
#line 342
  return (tmp);
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pap_domain___9(parseinfo const   *pai , int *cbyte_io , int max ,
                                  char **domain_r , parsedomain_flags flags ) 
{ 
  adns_status st ;
  char *dm ;
  void *tmp ;

  {
  {
#line 355
  st = adns__parse_domain((pai->qu)->ads, (int )pai->serv, (adns_query )pai->qu, & (pai->qu)->vb,
                          flags, (byte const   *)pai->dgram, (int )pai->dglen, cbyte_io,
                          max);
  }
#line 357
  if (st) {
#line 357
    return (st);
  }
#line 358
  if (! (pai->qu)->vb.used) {
#line 358
    return ((adns_status )104);
  }
  {
#line 360
  tmp = adns__alloc_interim((adns_query )pai->qu, (size_t )((pai->qu)->vb.used + 1));
#line 360
  dm = (char *)tmp;
  }
#line 361
  if (! dm) {
#line 361
    return ((adns_status )1);
  }
  {
#line 363
  *(dm + (pai->qu)->vb.used) = (char)0;
#line 364
  memcpy((void */* __restrict  */)dm, (void const   */* __restrict  */)(pai->qu)->vb.buf,
         (size_t )(pai->qu)->vb.used);
#line 366
  *domain_r = dm;
  }
#line 367
  return ((adns_status )0);
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status csp_domain___9(vbuf *vb___0 , char const   *domain ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 371
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 371
    tmp = adns__vbuf_appendstr(vb___0, domain);
    }
#line 371
    if (! tmp) {
#line 371
      return ((adns_status )1);
    }
#line 371
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 372
  if (! *domain) {
    {
#line 372
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 372
      tmp___0 = adns__vbuf_appendstr(vb___0, ".");
      }
#line 372
      if (! tmp___0) {
#line 372
        return ((adns_status )1);
      }
#line 372
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 373
  return ((adns_status )0);
}
}
#line 376 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_domain___9(vbuf *vb___0 , void const   *datap ) 
{ 
  char const   * const  *domainp ;
  adns_status tmp ;

  {
  {
#line 377
  domainp = (char const   * const  *)datap;
#line 378
  tmp = csp_domain___9(vb___0, (char const   *)*domainp);
  }
#line 378
  return (tmp);
}
}
#line 381 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_dom_raw___9(parseinfo const   *pai , int cbyte___3 , int max ,
                                  void *datap ) 
{ 
  char **rrp ;
  adns_status st ;

  {
  {
#line 383
  rrp = (char **)datap;
#line 386
  st = pap_domain___9(pai, & cbyte___3, max, rrp, (parsedomain_flags )1);
  }
#line 387
  if (st) {
#line 387
    return (st);
  }
#line 389
  if (cbyte___3 != max) {
#line 389
    return ((adns_status )104);
  }
#line 390
  return ((adns_status )0);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_host_raw___9(parseinfo const   *pai , int cbyte___3 , int max ,
                                   void *datap ) 
{ 
  char **rrp ;
  adns_status st ;
  int tmp ;

  {
#line 399
  rrp = (char **)datap;
#line 402
  if ((pai->qu)->flags & 64) {
#line 402
    tmp = 1;
  } else {
#line 402
    tmp = 0;
  }
  {
#line 402
  st = pap_domain___9(pai, & cbyte___3, max, rrp, (parsedomain_flags )tmp);
  }
#line 404
  if (st) {
#line 404
    return (st);
  }
#line 406
  if (cbyte___3 != max) {
#line 406
    return ((adns_status )104);
  }
#line 407
  return ((adns_status )0);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pap_findaddrs___9(parseinfo const   *pai , adns_rr_hostaddr *ha ,
                                     int *cbyte_io , int count , int dmstart ) 
{ 
  int rri ;
  int naddrs ;
  int type ;
  int class ;
  int rdlen ;
  int rdstart ;
  int ownermatched ;
  unsigned long ttl ;
  adns_status st ;
  int tmp ;
  void *tmp___0 ;

  {
#line 421
  rri = 0;
#line 421
  naddrs = -1;
  {
#line 421
  while (1) {
    while_continue: /* CIL Label */ ;
#line 421
    if (! (rri < count)) {
#line 421
      goto while_break;
    }
    {
#line 422
    st = adns__findrr_anychk((adns_query )pai->qu, (int )pai->serv, (byte const   *)pai->dgram,
                             (int )pai->dglen, cbyte_io, & type, & class, & ttl, & rdlen,
                             & rdstart, (byte const   *)pai->dgram, (int )pai->dglen,
                             dmstart, & ownermatched);
    }
#line 426
    if (st) {
#line 426
      return (st);
    }
#line 427
    if (! ownermatched) {
#line 427
      goto _L;
    } else
#line 427
    if (class != 1) {
#line 427
      goto _L;
    } else
#line 427
    if (type != 1) {
      _L: /* CIL Label */ 
#line 428
      if (naddrs > 0) {
#line 428
        goto while_break;
      } else {
#line 428
        goto __Cont;
      }
    }
#line 430
    if (naddrs == -1) {
#line 431
      naddrs = 0;
    }
    {
#line 433
    tmp = adns__vbuf_ensure(& (pai->qu)->vb, (int )((unsigned long )(naddrs + 1) * sizeof(adns_rr_addr )));
    }
#line 433
    if (! tmp) {
#line 434
      return ((adns_status )1);
    }
    {
#line 435
    adns__update_expires((adns_query )pai->qu, ttl, (struct timeval )pai->now);
#line 436
    st = pa_addr___9(pai, rdstart, rdstart + rdlen, (void *)((pai->qu)->vb.buf + (unsigned long )naddrs * sizeof(adns_rr_addr )));
    }
#line 438
    if (st) {
#line 438
      return (st);
    }
#line 439
    naddrs ++;
    __Cont: /* CIL Label */ 
#line 421
    rri ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 441
  if (naddrs >= 0) {
    {
#line 442
    tmp___0 = adns__alloc_interim((adns_query )pai->qu, (unsigned long )naddrs * sizeof(adns_rr_addr ));
#line 442
    ha->addrs = (adns_rr_addr *)tmp___0;
    }
#line 443
    if (! ha->addrs) {
#line 443
      return ((adns_status )1);
    }
    {
#line 444
    memcpy((void */* __restrict  */)ha->addrs, (void const   */* __restrict  */)(pai->qu)->vb.buf,
           (unsigned long )naddrs * sizeof(adns_rr_addr ));
#line 445
    ha->naddrs = naddrs;
#line 446
    ha->astatus = (adns_status )0;
#line 448
    adns__isort((void *)ha->addrs, naddrs, (int )sizeof(adns_rr_addr ), (void *)(pai->qu)->vb.buf,
                & div_addr___9, (void *)pai->ads);
    }
  }
#line 451
  return ((adns_status )0);
}
}
#line 454 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void icb_hostaddr___9(adns_query parent , adns_query child ) 
{ 
  adns_answer *cans ;
  adns_rr_hostaddr *rrp ;
  adns_state ads___7 ;
  adns_status st ;

  {
#line 455
  cans = child->answer;
#line 456
  rrp = child->ctx.info.hostaddr;
#line 457
  ads___7 = parent->ads;
#line 460
  st = cans->status;
#line 461
  rrp->astatus = st;
#line 462
  if ((unsigned int )st > 0U) {
#line 462
    if ((unsigned int )st <= 99U) {
#line 462
      rrp->naddrs = -1;
    } else {
#line 462
      rrp->naddrs = cans->nrrs;
    }
  } else {
#line 462
    rrp->naddrs = cans->nrrs;
  }
  {
#line 463
  rrp->addrs = cans->rrs.addr;
#line 464
  adns__transfer_interim(child, parent, (void *)rrp->addrs, (unsigned long )rrp->naddrs * sizeof(adns_rr_addr ));
  }
#line 467
  if (parent->children.head) {
    {
#line 468
    while (1) {
      while_continue: /* CIL Label */ ;
#line 468
      parent->next = (adns_query )0;
#line 468
      parent->back = ads___7->childw.tail;
#line 468
      if (ads___7->childw.tail) {
#line 468
        (ads___7->childw.tail)->next = parent;
      } else {
#line 468
        ads___7->childw.head = parent;
      }
#line 468
      ads___7->childw.tail = parent;
#line 468
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 470
    adns__query_done(parent);
    }
  }
#line 472
  return;
}
}
#line 474 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pap_hostaddr___9(parseinfo const   *pai , int *cbyte_io , int max ,
                                    adns_rr_hostaddr *rrp ) 
{ 
  adns_status st ;
  int dmstart ;
  int cbyte___3 ;
  qcontext ctx ;
  int id ;
  adns_query nqu ;
  adns_queryflags nflags ;
  int tmp ;
  typeinfo const   *tmp___0 ;

  {
#line 483
  cbyte___3 = *cbyte_io;
#line 483
  dmstart = cbyte___3;
#line 484
  if ((pai->qu)->flags & 64) {
#line 484
    tmp = 1;
  } else {
#line 484
    tmp = 0;
  }
  {
#line 484
  st = pap_domain___9(pai, & cbyte___3, max, & rrp->host, (parsedomain_flags )tmp);
  }
#line 486
  if (st) {
#line 486
    return (st);
  }
  {
#line 487
  *cbyte_io = cbyte___3;
#line 489
  rrp->astatus = (adns_status )0;
#line 490
  rrp->naddrs = -1;
#line 491
  rrp->addrs = (adns_rr_addr *)0;
#line 493
  cbyte___3 = (int )pai->nsstart;
#line 495
  st = pap_findaddrs___9(pai, rrp, & cbyte___3, (int )pai->nscount, dmstart);
  }
#line 496
  if (st) {
#line 496
    return (st);
  }
#line 497
  if (rrp->naddrs != -1) {
#line 497
    return ((adns_status )0);
  }
  {
#line 499
  st = pap_findaddrs___9(pai, rrp, & cbyte___3, (int )pai->arcount, dmstart);
  }
#line 500
  if (st) {
#line 500
    return (st);
  }
#line 501
  if (rrp->naddrs != -1) {
#line 501
    return ((adns_status )0);
  }
  {
#line 503
  st = adns__mkquery_frdgram((adns_state )pai->ads, & (pai->qu)->vb, & id, (byte const   *)pai->dgram,
                             (int )pai->dglen, dmstart, (adns_rrtype )65537, (adns_queryflags )16);
  }
#line 506
  if (st) {
#line 506
    return (st);
  }
#line 508
  ctx.ext = (void *)0;
#line 509
  ctx.callback = & icb_hostaddr___9;
#line 510
  ctx.info.hostaddr = rrp;
#line 512
  nflags = (adns_queryflags )16;
#line 513
  if (! ((pai->qu)->flags & 256)) {
#line 513
    nflags = (adns_queryflags )((unsigned int )nflags | 512U);
  }
  {
#line 515
  tmp___0 = adns__findtype((adns_rrtype )65537);
#line 515
  st = adns__internal_submit((adns_state )pai->ads, & nqu, tmp___0, & (pai->qu)->vb,
                             id, nflags, (struct timeval )pai->now, (qcontext const   *)(& ctx));
  }
#line 517
  if (st) {
#line 517
    return (st);
  }
#line 519
  nqu->parent = (adns_query )pai->qu;
  {
#line 520
  while (1) {
    while_continue: /* CIL Label */ ;
#line 520
    nqu->siblings.next = (adns_query )0;
#line 520
    nqu->siblings.back = (pai->qu)->children.tail;
#line 520
    if ((pai->qu)->children.tail) {
#line 520
      ((pai->qu)->children.tail)->siblings.next = nqu;
    } else {
#line 520
      (pai->qu)->children.head = nqu;
    }
#line 520
    (pai->qu)->children.tail = nqu;
#line 520
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 522
  return ((adns_status )0);
}
}
#line 525 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_hostaddr___9(parseinfo const   *pai , int cbyte___3 , int max ,
                                   void *datap ) 
{ 
  adns_rr_hostaddr *rrp ;
  adns_status st ;

  {
  {
#line 527
  rrp = (adns_rr_hostaddr *)datap;
#line 530
  st = pap_hostaddr___9(pai, & cbyte___3, max, rrp);
  }
#line 531
  if (st) {
#line 531
    return (st);
  }
#line 532
  if (cbyte___3 != max) {
#line 532
    return ((adns_status )104);
  }
#line 534
  return ((adns_status )0);
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int dip_hostaddr___9(adns_state ads___7 , adns_rr_hostaddr const   *ap , adns_rr_hostaddr const   *bp ) 
{ 
  int tmp ;

  {
#line 539
  if ((unsigned int const   )ap->astatus != (unsigned int const   )bp->astatus) {
#line 539
    return ((int )ap->astatus);
  }
#line 540
  if (ap->astatus) {
#line 540
    return (0);
  }
#line 542
  if (! ((int )(ap->addrs + 0)->addr.sa.sa_family == 2)) {
    {
#line 542
    __assert_fail("ap->addrs[0].addr.sa.sa_family == 2", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                  542U, "dip_hostaddr");
    }
  }
#line 543
  if (! ((int )(bp->addrs + 0)->addr.sa.sa_family == 2)) {
    {
#line 543
    __assert_fail("bp->addrs[0].addr.sa.sa_family == 2", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                  543U, "dip_hostaddr");
    }
  }
  {
#line 544
  tmp = dip_inaddr___9(ads___7, (ap->addrs + 0)->addr.inet.sin_addr, (bp->addrs + 0)->addr.inet.sin_addr);
  }
#line 544
  return (tmp);
}
}
#line 549 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int di_hostaddr___9(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_hostaddr const   *ap ;
  adns_rr_hostaddr const   *bp ;
  int tmp ;

  {
  {
#line 551
  ap = (adns_rr_hostaddr const   *)datap_a;
#line 551
  bp = (adns_rr_hostaddr const   *)datap_b;
#line 553
  tmp = dip_hostaddr___9(ads___7, ap, bp);
  }
#line 553
  return (tmp);
}
}
#line 556 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mfp_hostaddr___9(adns_query qu , adns_rr_hostaddr *rrp ) 
{ 
  void *tablev ;

  {
  {
#line 559
  adns__makefinal_str(qu, & rrp->host);
#line 560
  tablev = (void *)rrp->addrs;
#line 561
  adns__makefinal_block(qu, & tablev, (unsigned long )rrp->naddrs * sizeof(*(rrp->addrs)));
#line 562
  rrp->addrs = (adns_rr_addr *)tablev;
  }
#line 563
  return;
}
}
#line 565 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_hostaddr___9(adns_query qu , void *datap ) 
{ 
  adns_rr_hostaddr *rrp ;

  {
  {
#line 566
  rrp = (adns_rr_hostaddr *)datap;
#line 568
  mfp_hostaddr___9(qu, rrp);
  }
#line 569
  return;
}
}
#line 571 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status csp_hostaddr___9(vbuf *vb___0 , adns_rr_hostaddr const   *rrp ) 
{ 
  char const   *errstr ;
  adns_status st ;
  char buf___17[20] ;
  int i ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 577
  st = csp_domain___9(vb___0, (char const   *)rrp->host);
  }
#line 577
  if (st) {
#line 577
    return (st);
  }
  {
#line 579
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 579
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 579
    if (! tmp) {
#line 579
      return ((adns_status )1);
    }
#line 579
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 580
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 580
    tmp___0 = adns_errtypeabbrev((adns_status )rrp->astatus);
#line 580
    tmp___1 = adns__vbuf_appendstr(vb___0, tmp___0);
    }
#line 580
    if (! tmp___1) {
#line 580
      return ((adns_status )1);
    }
#line 580
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 582
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %d ",
          (unsigned int const   )rrp->astatus);
  }
  {
#line 583
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 583
    tmp___2 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 583
    if (! tmp___2) {
#line 583
      return ((adns_status )1);
    }
#line 583
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 585
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 585
    tmp___3 = adns_errabbrev((adns_status )rrp->astatus);
#line 585
    tmp___4 = adns__vbuf_appendstr(vb___0, tmp___3);
    }
#line 585
    if (! tmp___4) {
#line 585
      return ((adns_status )1);
    }
#line 585
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 586
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 586
    tmp___5 = adns__vbuf_appendstr(vb___0, " ");
    }
#line 586
    if (! tmp___5) {
#line 586
      return ((adns_status )1);
    }
#line 586
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 588
  errstr = adns_strerror((adns_status )rrp->astatus);
#line 589
  tmp___6 = strlen(errstr);
#line 589
  st = csp_qstring___9(vb___0, errstr, (int )tmp___6);
  }
#line 589
  if (st) {
#line 589
    return (st);
  }
#line 591
  if (rrp->naddrs >= 0) {
    {
#line 592
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 592
      tmp___7 = adns__vbuf_appendstr(vb___0, " (");
      }
#line 592
      if (! tmp___7) {
#line 592
        return ((adns_status )1);
      }
#line 592
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 593
    i = 0;
    {
#line 593
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 593
      if (! (i < (int )rrp->naddrs)) {
#line 593
        goto while_break___5;
      }
      {
#line 594
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 594
        tmp___8 = adns__vbuf_appendstr(vb___0, " ");
        }
#line 594
        if (! tmp___8) {
#line 594
          return ((adns_status )1);
        }
#line 594
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 595
      st = csp_addr___9(vb___0, (adns_rr_addr const   *)(rrp->addrs + i));
#line 593
      i ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 597
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 597
      tmp___9 = adns__vbuf_appendstr(vb___0, " )");
      }
#line 597
      if (! tmp___9) {
#line 597
        return ((adns_status )1);
      }
#line 597
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
  } else {
    {
#line 599
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 599
      tmp___10 = adns__vbuf_appendstr(vb___0, " ?");
      }
#line 599
      if (! tmp___10) {
#line 599
        return ((adns_status )1);
      }
#line 599
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
#line 601
  return ((adns_status )0);
}
}
#line 604 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_hostaddr___9(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_hostaddr const   *rrp ;
  adns_status tmp ;

  {
  {
#line 605
  rrp = (adns_rr_hostaddr const   *)datap;
#line 607
  tmp = csp_hostaddr___9(vb___0, rrp);
  }
#line 607
  return (tmp);
}
}
#line 614 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_mx_raw___9(parseinfo const   *pai , int cbyte___3 , int max ,
                                 void *datap ) 
{ 
  byte const   *dgram ;
  adns_rr_intstr *rrp ;
  adns_status st ;
  int pref ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 616
  dgram = (byte const   *)pai->dgram;
#line 617
  rrp = (adns_rr_intstr *)datap;
#line 621
  if (cbyte___3 + 2 > max) {
#line 621
    return ((adns_status )104);
  }
#line 622
  pref = 0;
#line 622
  tmp = cbyte___3;
#line 622
  cbyte___3 ++;
#line 622
  pref |= (int )(((int const   )*(dgram + tmp) & 255) << 8);
#line 622
  tmp___0 = cbyte___3;
#line 622
  cbyte___3 ++;
#line 622
  pref |= (int )((int const   )*(dgram + tmp___0) & 255);
#line 623
  rrp->i = pref;
#line 624
  if ((pai->qu)->flags & 64) {
#line 624
    tmp___1 = 1;
  } else {
#line 624
    tmp___1 = 0;
  }
  {
#line 624
  st = pap_domain___9(pai, & cbyte___3, max, & rrp->str, (parsedomain_flags )tmp___1);
  }
#line 626
  if (st) {
#line 626
    return (st);
  }
#line 628
  if (cbyte___3 != max) {
#line 628
    return ((adns_status )104);
  }
#line 629
  return ((adns_status )0);
}
}
#line 632 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int di_mx_raw___9(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_intstr const   *ap ;
  adns_rr_intstr const   *bp ;

  {
#line 633
  ap = (adns_rr_intstr const   *)datap_a;
#line 633
  bp = (adns_rr_intstr const   *)datap_b;
#line 635
  if (ap->i < bp->i) {
#line 635
    return (0);
  }
#line 636
  if (ap->i > bp->i) {
#line 636
    return (1);
  }
#line 637
  return (0);
}
}
#line 644 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_mx___9(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  byte const   *dgram ;
  adns_rr_inthostaddr *rrp ;
  adns_status st ;
  int pref ;
  int tmp ;
  int tmp___0 ;

  {
#line 646
  dgram = (byte const   *)pai->dgram;
#line 647
  rrp = (adns_rr_inthostaddr *)datap;
#line 651
  if (cbyte___3 + 2 > max) {
#line 651
    return ((adns_status )104);
  }
  {
#line 652
  pref = 0;
#line 652
  tmp = cbyte___3;
#line 652
  cbyte___3 ++;
#line 652
  pref |= (int )(((int const   )*(dgram + tmp) & 255) << 8);
#line 652
  tmp___0 = cbyte___3;
#line 652
  cbyte___3 ++;
#line 652
  pref |= (int )((int const   )*(dgram + tmp___0) & 255);
#line 653
  rrp->i = pref;
#line 654
  st = pap_hostaddr___9(pai, & cbyte___3, max, & rrp->ha);
  }
#line 655
  if (st) {
#line 655
    return (st);
  }
#line 657
  if (cbyte___3 != max) {
#line 657
    return ((adns_status )104);
  }
#line 658
  return ((adns_status )0);
}
}
#line 661 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int di_mx___9(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_inthostaddr const   *ap ;
  adns_rr_inthostaddr const   *bp ;
  int tmp ;

  {
#line 662
  ap = (adns_rr_inthostaddr const   *)datap_a;
#line 662
  bp = (adns_rr_inthostaddr const   *)datap_b;
#line 664
  if (ap->i < bp->i) {
#line 664
    return (0);
  }
#line 665
  if (ap->i > bp->i) {
#line 665
    return (1);
  }
  {
#line 666
  tmp = dip_hostaddr___9(ads___7, & ap->ha, & bp->ha);
  }
#line 666
  return (tmp);
}
}
#line 673 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_inthostaddr___9(adns_query qu , void *datap ) 
{ 
  adns_rr_inthostaddr *rrp ;

  {
  {
#line 674
  rrp = (adns_rr_inthostaddr *)datap;
#line 676
  mfp_hostaddr___9(qu, & rrp->ha);
  }
#line 677
  return;
}
}
#line 679 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_inthostaddr___9(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_inthostaddr const   *rrp ;
  char buf___17[10] ;
  int tmp ;
  adns_status tmp___0 ;

  {
  {
#line 680
  rrp = (adns_rr_inthostaddr const   *)datap;
#line 683
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"%u ",
          rrp->i);
  }
  {
#line 684
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 684
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 684
    if (! tmp) {
#line 684
      return ((adns_status )1);
    }
#line 684
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 686
  tmp___0 = csp_hostaddr___9(vb___0, & rrp->ha);
  }
#line 686
  return (tmp___0);
}
}
#line 693 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_inthost___9(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_intstr const   *rrp ;
  char buf___17[10] ;
  int tmp ;
  adns_status tmp___0 ;

  {
  {
#line 694
  rrp = (adns_rr_intstr const   *)datap;
#line 697
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"%u ",
          rrp->i);
  }
  {
#line 698
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 698
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 698
    if (! tmp) {
#line 698
      return ((adns_status )1);
    }
#line 698
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 699
  tmp___0 = csp_domain___9(vb___0, (char const   *)rrp->str);
  }
#line 699
  return (tmp___0);
}
}
#line 706 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void icb_ptr___9(adns_query parent , adns_query child ) 
{ 
  adns_answer *cans ;
  adns_rr_addr const   *queried ;
  adns_rr_addr const   *found ;
  adns_state ads___7 ;
  int i ;
  int tmp ;

  {
#line 707
  cans = child->answer;
#line 709
  ads___7 = parent->ads;
#line 712
  if ((unsigned int )cans->status == 300U) {
    {
#line 713
    adns__query_fail(parent, (adns_status )100);
    }
#line 714
    return;
  } else
#line 712
  if ((unsigned int )cans->status == 301U) {
    {
#line 713
    adns__query_fail(parent, (adns_status )100);
    }
#line 714
    return;
  } else
#line 715
  if (cans->status) {
    {
#line 716
    adns__query_fail(parent, cans->status);
    }
#line 717
    return;
  }
#line 720
  queried = (adns_rr_addr const   *)(& parent->ctx.info.ptr_parent_addr);
#line 721
  i = 0;
#line 721
  found = (adns_rr_addr const   *)cans->rrs.addr;
  {
#line 721
  while (1) {
    while_continue: /* CIL Label */ ;
#line 721
    if (! (i < cans->nrrs)) {
#line 721
      goto while_break;
    }
#line 722
    if (queried->len == found->len) {
      {
#line 722
      tmp = memcmp((void const   *)(& queried->addr), (void const   *)(& found->addr),
                   (size_t )queried->len);
      }
#line 722
      if (! tmp) {
#line 724
        if (! parent->children.head) {
          {
#line 725
          adns__query_done(parent);
          }
#line 726
          return;
        } else {
          {
#line 728
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 728
            parent->next = (adns_query )0;
#line 728
            parent->back = ads___7->childw.tail;
#line 728
            if (ads___7->childw.tail) {
#line 728
              (ads___7->childw.tail)->next = parent;
            } else {
#line 728
              ads___7->childw.head = parent;
            }
#line 728
            ads___7->childw.tail = parent;
#line 728
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 729
          return;
        }
      }
    }
#line 721
    i ++;
#line 721
    found ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 734
  adns__query_fail(parent, (adns_status )100);
  }
#line 735
  return;
}
}
#line 739
static adns_status pa_ptr___9(parseinfo const   *pai , int dmstart , int max , void *datap ) ;
#line 739 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static char const   * const  expectdomain___9[2]  = {      (char const   */* const  */)"in-addr",      (char const   */* const  */)"arpa"};
#line 737 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_ptr___9(parseinfo const   *pai , int dmstart , int max , void *datap ) 
{ 
  char **rrp ;
  adns_status st ;
  adns_rr_addr *ap ;
  findlabel_state fls ;
  char *ep ;
  byte ipv[4] ;
  char labbuf[4] ;
  int cbyte___3 ;
  int i ;
  int lablen ;
  int labstart ;
  int l ;
  int id ;
  adns_query nqu ;
  qcontext ctx ;
  int tmp ;
  unsigned long tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  typeinfo const   *tmp___3 ;

  {
#line 741
  rrp = (char **)datap;
#line 752
  cbyte___3 = dmstart;
#line 753
  if ((pai->qu)->flags & 64) {
#line 753
    tmp = 1;
  } else {
#line 753
    tmp = 0;
  }
  {
#line 753
  st = pap_domain___9(pai, & cbyte___3, max, rrp, (parsedomain_flags )tmp);
  }
#line 755
  if (st) {
#line 755
    return (st);
  }
#line 756
  if (cbyte___3 != max) {
#line 756
    return ((adns_status )104);
  }
#line 758
  ap = & (pai->qu)->ctx.info.ptr_parent_addr;
#line 759
  if (! ap->len) {
    {
#line 760
    adns__findlabel_start(& fls, (adns_state )pai->ads, -1, (adns_query )pai->qu,
                          (byte const   *)(pai->qu)->query_dgram, (pai->qu)->query_dglen,
                          (pai->qu)->query_dglen, 12, (int *)0);
#line 763
    i = 0;
    }
    {
#line 763
    while (1) {
      while_continue: /* CIL Label */ ;
#line 763
      if (! (i < 4)) {
#line 763
        goto while_break;
      }
      {
#line 764
      st = adns__findlabel_next(& fls, & lablen, & labstart);
      }
#line 764
      if (! (! st)) {
        {
#line 764
        __assert_fail("!st", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                      764U, "pa_ptr");
        }
      }
#line 765
      if (lablen <= 0) {
#line 765
        return ((adns_status )200);
      } else
#line 765
      if (lablen > 3) {
#line 765
        return ((adns_status )200);
      }
      {
#line 766
      memcpy((void */* __restrict  */)(labbuf), (void const   */* __restrict  */)((pai->qu)->query_dgram + labstart),
             (size_t )lablen);
#line 767
      labbuf[lablen] = (char)0;
#line 768
      tmp___0 = strtoul((char const   */* __restrict  */)(labbuf), (char **/* __restrict  */)(& ep),
                        10);
#line 768
      ipv[3 - i] = (byte )tmp___0;
      }
#line 769
      if (*ep) {
#line 769
        return ((adns_status )200);
      }
#line 770
      if (lablen > 1) {
#line 770
        if ((int )*((pai->qu)->query_dgram + labstart) == 48) {
#line 771
          return ((adns_status )200);
        }
      }
#line 763
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 773
    i = 0;
    {
#line 773
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 773
      if (! ((unsigned long )i < sizeof(expectdomain___9) / sizeof(expectdomain___9[0]))) {
#line 773
        goto while_break___0;
      }
      {
#line 774
      st = adns__findlabel_next(& fls, & lablen, & labstart);
      }
#line 774
      if (! (! st)) {
        {
#line 774
        __assert_fail("!st", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                      774U, "pa_ptr");
        }
      }
      {
#line 775
      tmp___1 = strlen((char const   *)expectdomain___9[i]);
#line 775
      l = (int )tmp___1;
      }
#line 776
      if (lablen != l) {
#line 778
        return ((adns_status )200);
      } else {
        {
#line 776
        tmp___2 = memcmp((void const   *)((pai->qu)->query_dgram + labstart), (void const   *)expectdomain___9[i],
                         (size_t )l);
        }
#line 776
        if (tmp___2) {
#line 778
          return ((adns_status )200);
        }
      }
#line 773
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 780
    st = adns__findlabel_next(& fls, & lablen, (int *)0);
    }
#line 780
    if (! (! st)) {
      {
#line 780
      __assert_fail("!st", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                    780U, "pa_ptr");
      }
    }
#line 781
    if (lablen) {
#line 781
      return ((adns_status )200);
    }
    {
#line 783
    ap->len = (int )sizeof(struct sockaddr_in );
#line 784
    memset((void *)(& ap->addr), 0, sizeof(ap->addr.inet));
#line 785
    ap->addr.inet.sin_family = (sa_family_t )2;
#line 786
    ap->addr.inet.sin_addr.s_addr = htonl((uint32_t )(((((int )ipv[0] << 24) | ((int )ipv[1] << 16)) | ((int )ipv[2] << 8)) | (int )ipv[3]));
    }
  }
  {
#line 790
  st = adns__mkquery_frdgram((adns_state )pai->ads, & (pai->qu)->vb, & id, (byte const   *)pai->dgram,
                             (int )pai->dglen, dmstart, (adns_rrtype )65537, (adns_queryflags )16);
  }
#line 793
  if (st) {
#line 793
    return (st);
  }
  {
#line 795
  ctx.ext = (void *)0;
#line 796
  ctx.callback = & icb_ptr___9;
#line 797
  memset((void *)(& ctx.info), 0, sizeof(ctx.info));
#line 798
  tmp___3 = adns__findtype((adns_rrtype )65537);
#line 798
  st = adns__internal_submit((adns_state )pai->ads, & nqu, tmp___3, & (pai->qu)->vb,
                             id, (adns_queryflags )16, (struct timeval )pai->now,
                             (qcontext const   *)(& ctx));
  }
#line 801
  if (st) {
#line 801
    return (st);
  }
#line 803
  nqu->parent = (adns_query )pai->qu;
  {
#line 804
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 804
    nqu->siblings.next = (adns_query )0;
#line 804
    nqu->siblings.back = (pai->qu)->children.tail;
#line 804
    if ((pai->qu)->children.tail) {
#line 804
      ((pai->qu)->children.tail)->siblings.next = nqu;
    } else {
#line 804
      (pai->qu)->children.head = nqu;
    }
#line 804
    (pai->qu)->children.tail = nqu;
#line 804
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 805
  return ((adns_status )0);
}
}
#line 812 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_strpair___9(adns_query qu , void *datap ) 
{ 
  adns_rr_strpair *rrp ;

  {
  {
#line 813
  rrp = (adns_rr_strpair *)datap;
#line 815
  adns__makefinal_str(qu, & rrp->array[0]);
#line 816
  adns__makefinal_str(qu, & rrp->array[1]);
  }
#line 817
  return;
}
}
#line 823 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_intstrpair___9(adns_query qu , void *datap ) 
{ 
  adns_rr_intstrpair *rrp ;

  {
  {
#line 824
  rrp = (adns_rr_intstrpair *)datap;
#line 826
  adns__makefinal_str(qu, & rrp->array[0].str);
#line 827
  adns__makefinal_str(qu, & rrp->array[1].str);
  }
#line 828
  return;
}
}
#line 834 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_hinfo___9(parseinfo const   *pai , int cbyte___3 , int max ,
                                void *datap ) 
{ 
  adns_rr_intstrpair *rrp ;
  adns_status st ;
  int i ;

  {
#line 836
  rrp = (adns_rr_intstrpair *)datap;
#line 840
  i = 0;
  {
#line 840
  while (1) {
    while_continue: /* CIL Label */ ;
#line 840
    if (! (i < 2)) {
#line 840
      goto while_break;
    }
    {
#line 841
    st = pap_qstring___9(pai, & cbyte___3, max, & rrp->array[i].i, & rrp->array[i].str);
    }
#line 842
    if (st) {
#line 842
      return (st);
    }
#line 840
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 845
  if (cbyte___3 != max) {
#line 845
    return ((adns_status )104);
  }
#line 847
  return ((adns_status )0);
}
}
#line 854 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pap_mailbox822___9(parseinfo const   *pai , int *cbyte_io , int max ,
                                      char **mb_r ) 
{ 
  int lablen ;
  int labstart ;
  int i ;
  int needquote ;
  int c ;
  int r ;
  int neednorm ;
  unsigned char const   *p ;
  char *str ;
  findlabel_state fls ;
  adns_status st ;
  vbuf *vb___0 ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 863
  vb___0 = & (pai->qu)->vb;
#line 864
  vb___0->used = 0;
#line 865
  adns__findlabel_start(& fls, (adns_state )pai->ads, -1, (adns_query )pai->qu, (byte const   *)pai->dgram,
                        (int )pai->dglen, max, *cbyte_io, cbyte_io);
#line 869
  st = adns__findlabel_next(& fls, & lablen, & labstart);
  }
#line 870
  if (! lablen) {
    {
#line 871
    adns__vbuf_appendstr(vb___0, ".");
    }
#line 872
    goto x_ok;
  }
#line 875
  neednorm = 1;
#line 876
  i = 0;
#line 876
  needquote = 0;
#line 876
  p = (unsigned char const   *)(pai->dgram + labstart);
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (! (i < lablen)) {
#line 876
      goto while_break;
    }
#line 877
    tmp = p;
#line 877
    p ++;
#line 877
    c = (int )*tmp;
#line 878
    if ((c & -129) < 32) {
#line 878
      return ((adns_status )104);
    } else
#line 878
    if ((c & -129) == 127) {
#line 878
      return ((adns_status )104);
    }
#line 879
    if (c == 46) {
#line 879
      if (! neednorm) {
#line 879
        neednorm = 1;
      } else {
#line 879
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 880
    if (c == 32) {
#line 880
      needquote ++;
    } else
#line 880
    if (c >= 127) {
#line 880
      needquote ++;
    } else {
      {
#line 880
      tmp___0 = ctype_822special(c);
      }
#line 880
      if (tmp___0) {
#line 880
        needquote ++;
      } else {
#line 881
        neednorm = 0;
      }
    }
#line 876
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 884
  if (needquote) {
#line 884
    goto _L___0;
  } else
#line 884
  if (neednorm) {
    _L___0: /* CIL Label */ 
    {
#line 885
    r = adns__vbuf_ensure(vb___0, (lablen + needquote) + 4);
    }
#line 885
    if (! r) {
#line 885
      return ((adns_status )1);
    }
    {
#line 886
    adns__vbuf_appendq(vb___0, (byte const   *)"\"", 1);
#line 887
    i = 0;
#line 887
    needquote = 0;
#line 887
    p = (unsigned char const   *)(pai->dgram + labstart);
    }
    {
#line 887
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 887
      if (! (i < lablen)) {
#line 887
        goto while_break___0;
      }
#line 888
      c = (int )*p;
#line 889
      if (c == 34) {
        {
#line 889
        adns__vbuf_appendq(vb___0, (byte const   *)"\\", 1);
        }
      } else
#line 889
      if (c == 92) {
        {
#line 889
        adns__vbuf_appendq(vb___0, (byte const   *)"\\", 1);
        }
      }
      {
#line 890
      adns__vbuf_appendq(vb___0, p, 1);
#line 887
      i ++;
#line 887
      p ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 892
    adns__vbuf_appendq(vb___0, (byte const   *)"\"", 1);
    }
  } else {
    {
#line 894
    r = adns__vbuf_append(vb___0, (byte const   *)(pai->dgram + labstart), lablen);
    }
#line 894
    if (! r) {
#line 894
      return ((adns_status )1);
    }
  }
  {
#line 897
  r = adns__vbuf_appendstr(vb___0, "@");
  }
#line 897
  if (! r) {
#line 897
    return ((adns_status )1);
  }
  {
#line 899
  st = adns__parse_domain_more(& fls, (adns_state )pai->ads, (adns_query )pai->qu,
                               vb___0, (parsedomain_flags )0, (byte const   *)pai->dgram);
  }
#line 900
  if (st) {
#line 900
    return (st);
  }
  x_ok: 
  {
#line 903
  tmp___1 = adns__alloc_interim((adns_query )pai->qu, (size_t )(vb___0->used + 1));
#line 903
  str = (char *)tmp___1;
  }
#line 903
  if (! str) {
#line 903
    return ((adns_status )1);
  }
  {
#line 904
  memcpy((void */* __restrict  */)str, (void const   */* __restrict  */)vb___0->buf,
         (size_t )vb___0->used);
#line 905
  *(str + vb___0->used) = (char)0;
#line 906
  *mb_r = str;
  }
#line 907
  return ((adns_status )0);
}
}
#line 910 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pap_mailbox___9(parseinfo const   *pai , int *cbyte_io , int max ,
                                   char **mb_r ) 
{ 
  adns_status tmp ;
  adns_status tmp___0 ;

  {
#line 912
  if ((unsigned int const   )((pai->qu)->typei)->typekey & 131072U) {
    {
#line 913
    tmp = pap_mailbox822___9(pai, cbyte_io, max, mb_r);
    }
#line 913
    return (tmp);
  } else {
    {
#line 915
    tmp___0 = pap_domain___9(pai, cbyte_io, max, mb_r, (parsedomain_flags )1);
    }
#line 915
    return (tmp___0);
  }
}
}
#line 919 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status csp_mailbox___9(vbuf *vb___0 , char const   *mailbox ) 
{ 
  adns_status tmp ;

  {
  {
#line 920
  tmp = csp_domain___9(vb___0, mailbox);
  }
#line 920
  return (tmp);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_rp___9(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  adns_rr_strpair *rrp ;
  adns_status st ;

  {
  {
#line 929
  rrp = (adns_rr_strpair *)datap;
#line 932
  st = pap_mailbox___9(pai, & cbyte___3, max, & rrp->array[0]);
  }
#line 933
  if (st) {
#line 933
    return (st);
  }
  {
#line 935
  st = pap_domain___9(pai, & cbyte___3, max, & rrp->array[1], (parsedomain_flags )1);
  }
#line 936
  if (st) {
#line 936
    return (st);
  }
#line 938
  if (cbyte___3 != max) {
#line 938
    return ((adns_status )104);
  }
#line 939
  return ((adns_status )0);
}
}
#line 942 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_rp___9(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_strpair const   *rrp ;
  adns_status st ;
  int tmp ;

  {
  {
#line 943
  rrp = (adns_rr_strpair const   *)datap;
#line 946
  st = csp_mailbox___9(vb___0, (char const   *)rrp->array[0]);
  }
#line 946
  if (st) {
#line 946
    return (st);
  }
  {
#line 947
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 947
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 947
    if (! tmp) {
#line 947
      return ((adns_status )1);
    }
#line 947
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 948
  st = csp_domain___9(vb___0, (char const   *)rrp->array[1]);
  }
#line 948
  if (st) {
#line 948
    return (st);
  }
#line 950
  return ((adns_status )0);
}
}
#line 957 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_soa___9(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  adns_rr_soa *rrp ;
  byte const   *dgram ;
  adns_status st ;
  int msw ;
  int lsw ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 959
  rrp = (adns_rr_soa *)datap;
#line 960
  dgram = (byte const   *)pai->dgram;
#line 964
  if ((pai->qu)->flags & 64) {
#line 964
    tmp = 1;
  } else {
#line 964
    tmp = 0;
  }
  {
#line 964
  st = pap_domain___9(pai, & cbyte___3, max, & rrp->mname, (parsedomain_flags )tmp);
  }
#line 966
  if (st) {
#line 966
    return (st);
  }
  {
#line 968
  st = pap_mailbox___9(pai, & cbyte___3, max, & rrp->rname);
  }
#line 969
  if (st) {
#line 969
    return (st);
  }
#line 971
  if (cbyte___3 + 20 != max) {
#line 971
    return ((adns_status )104);
  }
#line 973
  i = 0;
  {
#line 973
  while (1) {
    while_continue: /* CIL Label */ ;
#line 973
    if (! (i < 5)) {
#line 973
      goto while_break;
    }
#line 974
    msw = 0;
#line 974
    tmp___0 = cbyte___3;
#line 974
    cbyte___3 ++;
#line 974
    msw |= (int )(((int const   )*(dgram + tmp___0) & 255) << 8);
#line 974
    tmp___1 = cbyte___3;
#line 974
    cbyte___3 ++;
#line 974
    msw |= (int )((int const   )*(dgram + tmp___1) & 255);
#line 975
    lsw = 0;
#line 975
    tmp___2 = cbyte___3;
#line 975
    cbyte___3 ++;
#line 975
    lsw |= (int )(((int const   )*(dgram + tmp___2) & 255) << 8);
#line 975
    tmp___3 = cbyte___3;
#line 975
    cbyte___3 ++;
#line 975
    lsw |= (int )((int const   )*(dgram + tmp___3) & 255);
#line 976
    *(& rrp->serial + i) = (unsigned long )((msw << 16) | lsw);
#line 973
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 979
  return ((adns_status )0);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_soa___9(adns_query qu , void *datap ) 
{ 
  adns_rr_soa *rrp ;

  {
  {
#line 983
  rrp = (adns_rr_soa *)datap;
#line 985
  adns__makefinal_str(qu, & rrp->mname);
#line 986
  adns__makefinal_str(qu, & rrp->rname);
  }
#line 987
  return;
}
}
#line 989 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_soa___9(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_soa const   *rrp ;
  char buf___17[20] ;
  int i ;
  adns_status st ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 990
  rrp = (adns_rr_soa const   *)datap;
#line 995
  st = csp_domain___9(vb___0, (char const   *)rrp->mname);
  }
#line 995
  if (st) {
#line 995
    return (st);
  }
  {
#line 996
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 996
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 996
    if (! tmp) {
#line 996
      return ((adns_status )1);
    }
#line 996
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 997
  st = csp_mailbox___9(vb___0, (char const   *)rrp->rname);
  }
#line 997
  if (st) {
#line 997
    return (st);
  }
#line 999
  i = 0;
  {
#line 999
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 999
    if (! (i < 5)) {
#line 999
      goto while_break___0;
    }
    {
#line 1000
    sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %lu",
            *(& rrp->serial + i));
    }
    {
#line 1001
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1001
      tmp___0 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
      }
#line 1001
      if (! tmp___0) {
#line 1001
        return ((adns_status )1);
      }
#line 1001
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 999
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1004
  return ((adns_status )0);
}
}
#line 1011 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status qdpl_srv___9(adns_state ads___7 , char const   **p_io , char const   *pe ,
                                int labelnum , char *label_r , int *ll_io , adns_queryflags flags ,
                                typeinfo const   *typei ) 
{ 
  int useflags ;
  char const   *p_orig ;
  adns_status st ;
  int ll ;
  void *tmp ;

  {
#line 1020
  if (labelnum < 2) {
#line 1020
    if (! ((unsigned int )flags & 16U)) {
#line 1021
      useflags = 16;
#line 1022
      p_orig = *p_io;
    } else {
#line 1024
      useflags = (int )flags;
#line 1025
      p_orig = (char const   *)0;
    }
  } else {
#line 1024
    useflags = (int )flags;
#line 1025
    p_orig = (char const   *)0;
  }
  {
#line 1027
  st = adns__qdpl_normal(ads___7, p_io, pe, labelnum, (char *)label_r, ll_io, (adns_queryflags )useflags,
                         typei);
  }
#line 1028
  if (st) {
#line 1028
    return (st);
  }
#line 1030
  if (p_orig) {
#line 1031
    ll = *ll_io;
#line 1032
    if (! ll) {
#line 1033
      return ((adns_status )201);
    } else
#line 1032
    if ((int )*(label_r + 0) != 95) {
#line 1033
      return ((adns_status )201);
    }
    {
#line 1034
    tmp = memchr((void const   *)(p_orig + 1), '\\', (size_t )(pe - (p_orig + 1)));
    }
#line 1034
    if (tmp) {
#line 1035
      return ((adns_status )201);
    }
  }
#line 1037
  return ((adns_status )0);
}
}
#line 1040 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pap_srv_begin___9(parseinfo const   *pai , int *cbyte_io , int max ,
                                     adns_rr_srvha *rrp ) 
{ 
  byte const   *dgram ;
  int ti ;
  int cbyte___3 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1043
  dgram = (byte const   *)pai->dgram;
#line 1046
  cbyte___3 = *cbyte_io;
#line 1047
  tmp = *cbyte_io + 6;
#line 1047
  *cbyte_io = tmp;
#line 1047
  if (tmp > max) {
#line 1047
    return ((adns_status )104);
  }
#line 1049
  ti = 0;
#line 1049
  tmp___0 = cbyte___3;
#line 1049
  cbyte___3 ++;
#line 1049
  ti |= (int )(((int const   )*(dgram + tmp___0) & 255) << 8);
#line 1049
  tmp___1 = cbyte___3;
#line 1049
  cbyte___3 ++;
#line 1049
  ti |= (int )((int const   )*(dgram + tmp___1) & 255);
#line 1049
  rrp->priority = ti;
#line 1050
  ti = 0;
#line 1050
  tmp___2 = cbyte___3;
#line 1050
  cbyte___3 ++;
#line 1050
  ti |= (int )(((int const   )*(dgram + tmp___2) & 255) << 8);
#line 1050
  tmp___3 = cbyte___3;
#line 1050
  cbyte___3 ++;
#line 1050
  ti |= (int )((int const   )*(dgram + tmp___3) & 255);
#line 1050
  rrp->weight = ti;
#line 1051
  ti = 0;
#line 1051
  tmp___4 = cbyte___3;
#line 1051
  cbyte___3 ++;
#line 1051
  ti |= (int )(((int const   )*(dgram + tmp___4) & 255) << 8);
#line 1051
  tmp___5 = cbyte___3;
#line 1051
  cbyte___3 ++;
#line 1051
  ti |= (int )((int const   )*(dgram + tmp___5) & 255);
#line 1051
  rrp->port = ti;
#line 1052
  return ((adns_status )0);
}
}
#line 1055 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_srvraw___9(parseinfo const   *pai , int cbyte___3 , int max ,
                                 void *datap ) 
{ 
  adns_rr_srvraw *rrp ;
  adns_status st ;
  int tmp ;

  {
  {
#line 1057
  rrp = (adns_rr_srvraw *)datap;
#line 1060
  st = pap_srv_begin___9(pai, & cbyte___3, max, (adns_rr_srvha *)datap);
  }
#line 1061
  if (st) {
#line 1061
    return (st);
  }
#line 1063
  if ((pai->qu)->flags & 64) {
#line 1063
    tmp = 1;
  } else {
#line 1063
    tmp = 0;
  }
  {
#line 1063
  st = pap_domain___9(pai, & cbyte___3, max, & rrp->host, (parsedomain_flags )tmp);
  }
#line 1065
  if (st) {
#line 1065
    return (st);
  }
#line 1067
  if (cbyte___3 != max) {
#line 1067
    return ((adns_status )104);
  }
#line 1068
  return ((adns_status )0);
}
}
#line 1071 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_srvha___9(parseinfo const   *pai , int cbyte___3 , int max ,
                                void *datap ) 
{ 
  adns_rr_srvha *rrp ;
  adns_status st ;

  {
  {
#line 1073
  rrp = (adns_rr_srvha *)datap;
#line 1076
  st = pap_srv_begin___9(pai, & cbyte___3, max, (adns_rr_srvha *)datap);
  }
#line 1076
  if (st) {
#line 1076
    return (st);
  }
  {
#line 1077
  st = pap_hostaddr___9(pai, & cbyte___3, max, & rrp->ha);
  }
#line 1077
  if (st) {
#line 1077
    return (st);
  }
#line 1078
  if (cbyte___3 != max) {
#line 1078
    return ((adns_status )104);
  }
#line 1079
  return ((adns_status )0);
}
}
#line 1082 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_srvraw___9(adns_query qu , void *datap ) 
{ 
  adns_rr_srvraw *rrp ;

  {
  {
#line 1083
  rrp = (adns_rr_srvraw *)datap;
#line 1084
  adns__makefinal_str(qu, & rrp->host);
  }
#line 1085
  return;
}
}
#line 1087 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_srvha___9(adns_query qu , void *datap ) 
{ 
  adns_rr_srvha *rrp ;

  {
  {
#line 1088
  rrp = (adns_rr_srvha *)datap;
#line 1089
  mfp_hostaddr___9(qu, & rrp->ha);
  }
#line 1090
  return;
}
}
#line 1092 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int di_srv___9(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_srvraw const   *ap ;
  adns_rr_srvraw const   *bp ;

  {
#line 1093
  ap = (adns_rr_srvraw const   *)datap_a;
#line 1093
  bp = (adns_rr_srvraw const   *)datap_b;
#line 1096
  if (ap->priority < bp->priority) {
#line 1096
    return (0);
  }
#line 1097
  if (ap->priority > bp->priority) {
#line 1097
    return (1);
  }
#line 1098
  return (0);
}
}
#line 1101 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status csp_srv_begin___9(vbuf *vb___0 , adns_rr_srvha const   *rrp ) 
{ 
  char buf___17[30] ;
  int tmp ;

  {
  {
#line 1104
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"%u %u %u ",
          rrp->priority, rrp->weight, rrp->port);
  }
  {
#line 1105
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1105
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 1105
    if (! tmp) {
#line 1105
      return ((adns_status )1);
    }
#line 1105
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1106
  return ((adns_status )0);
}
}
#line 1109 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_srvraw___9(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_srvraw const   *rrp ;
  adns_status st ;
  adns_status tmp ;

  {
  {
#line 1110
  rrp = (adns_rr_srvraw const   *)datap;
#line 1113
  st = csp_srv_begin___9(vb___0, (adns_rr_srvha const   *)((void const   *)rrp));
  }
#line 1113
  if (st) {
#line 1113
    return (st);
  }
  {
#line 1114
  tmp = csp_domain___9(vb___0, (char const   *)rrp->host);
  }
#line 1114
  return (tmp);
}
}
#line 1117 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_srvha___9(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_srvha const   *rrp ;
  adns_status st ;
  adns_status tmp ;

  {
  {
#line 1118
  rrp = (adns_rr_srvha const   *)datap;
#line 1121
  st = csp_srv_begin___9(vb___0, (adns_rr_srvha const   *)datap);
  }
#line 1121
  if (st) {
#line 1121
    return (st);
  }
  {
#line 1122
  tmp = csp_hostaddr___9(vb___0, & rrp->ha);
  }
#line 1122
  return (tmp);
}
}
#line 1125 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void postsort_srv___9(adns_state ads___7 , void *array , int nrrs , struct typeinfo  const  *typei ) 
{ 
  char *workbegin ;
  char *workend ;
  char *search ;
  char *arrayend ;
  adns_rr_srvha const   *rr ;
  union __anonunion_rrtmp_89___9 rrtmp ;
  int cpriority ;
  int totalweight ;
  int runtotal ;
  long randval ;

  {
#line 1138
  workbegin = (char *)array;
#line 1138
  arrayend = workbegin + typei->rrsz * (int const   )nrrs;
  {
#line 1138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1138
    if (! ((unsigned long )workbegin < (unsigned long )arrayend)) {
#line 1138
      goto while_break;
    }
#line 1141
    rr = (adns_rr_srvha const   *)((void *)workbegin);
#line 1141
    cpriority = (int )rr->priority;
#line 1143
    workend = workbegin;
#line 1143
    totalweight = 0;
    {
#line 1143
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1143
      if ((unsigned long )workend < (unsigned long )arrayend) {
#line 1143
        rr = (adns_rr_srvha const   *)((void *)workend);
#line 1143
        if (! (rr->priority == (int const   )cpriority)) {
#line 1143
          goto while_break___0;
        }
      } else {
#line 1143
        goto while_break___0;
      }
#line 1146
      totalweight += (int )rr->weight;
#line 1143
      workend += typei->rrsz;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1155
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1155
      if (! ((unsigned long )(workbegin + typei->rrsz) < (unsigned long )workend)) {
#line 1155
        goto while_break___1;
      }
      {
#line 1159
      randval = nrand48((unsigned short *)(ads___7->rand48xsubi));
#line 1160
      randval %= (long )(totalweight + 1);
#line 1167
      search = workbegin;
#line 1167
      runtotal = 0;
      }
      {
#line 1167
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1167
        rr = (adns_rr_srvha const   *)((void *)search);
#line 1167
        runtotal += (int )rr->weight;
#line 1167
        if (! ((long )runtotal < randval)) {
#line 1167
          goto while_break___2;
        }
#line 1167
        search += typei->rrsz;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1170
      if (! ((unsigned long )search < (unsigned long )arrayend)) {
        {
#line 1170
        __assert_fail("search < arrayend", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                      1170U, "postsort_srv");
        }
      }
#line 1171
      totalweight -= (int )rr->weight;
#line 1172
      if ((unsigned long )search != (unsigned long )workbegin) {
        {
#line 1173
        memcpy((void */* __restrict  */)(& rrtmp), (void const   */* __restrict  */)workbegin,
               (size_t )typei->rrsz);
#line 1174
        memcpy((void */* __restrict  */)workbegin, (void const   */* __restrict  */)search,
               (size_t )typei->rrsz);
#line 1175
        memcpy((void */* __restrict  */)search, (void const   */* __restrict  */)(& rrtmp),
               (size_t )typei->rrsz);
        }
      }
#line 1155
      workbegin += typei->rrsz;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1138
    workbegin = workend;
  }
  while_break: /* CIL Label */ ;
  }
#line 1184
  return;
}
}
#line 1190 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_byteblock___9(adns_query qu , void *datap ) 
{ 
  adns_rr_byteblock *rrp ;
  void *bytes___3 ;

  {
  {
#line 1191
  rrp = (adns_rr_byteblock *)datap;
#line 1192
  bytes___3 = (void *)rrp->data;
#line 1193
  adns__makefinal_block(qu, & bytes___3, (size_t )rrp->len);
#line 1194
  rrp->data = (unsigned char *)bytes___3;
  }
#line 1195
  return;
}
}
#line 1201 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_opaque___9(parseinfo const   *pai , int cbyte___3 , int max ,
                                 void *datap ) 
{ 
  adns_rr_byteblock *rrp ;
  void *tmp ;

  {
  {
#line 1203
  rrp = (adns_rr_byteblock *)datap;
#line 1205
  rrp->len = max - cbyte___3;
#line 1206
  tmp = adns__alloc_interim((adns_query )pai->qu, (size_t )rrp->len);
#line 1206
  rrp->data = (unsigned char *)tmp;
  }
#line 1207
  if (! rrp->data) {
#line 1207
    return ((adns_status )1);
  }
  {
#line 1208
  memcpy((void */* __restrict  */)rrp->data, (void const   */* __restrict  */)(pai->dgram + cbyte___3),
         (size_t )rrp->len);
  }
#line 1209
  return ((adns_status )0);
}
}
#line 1212 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_opaque___9(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_byteblock const   *rrp ;
  char buf___17[10] ;
  int l ;
  unsigned char *p ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1213
  rrp = (adns_rr_byteblock const   *)datap;
#line 1218
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"\\# %d",
          rrp->len);
  }
  {
#line 1219
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1219
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 1219
    if (! tmp) {
#line 1219
      return ((adns_status )1);
    }
#line 1219
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1221
  l = (int )rrp->len;
#line 1221
  p = (unsigned char *)rrp->data;
  {
#line 1221
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1221
    if (! (l >= 4)) {
#line 1221
      goto while_break___0;
    }
    {
#line 1224
    sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %02x%02x%02x%02x",
            (int )*(p + 0), (int )*(p + 1), (int )*(p + 2), (int )*(p + 3));
    }
    {
#line 1225
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1225
      tmp___0 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
      }
#line 1225
      if (! tmp___0) {
#line 1225
        return ((adns_status )1);
      }
#line 1225
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1221
    l -= 4;
#line 1221
    p += 4;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1227
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1227
    if (! (l > 0)) {
#line 1227
      goto while_break___2;
    }
    {
#line 1230
    sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %02x",
            (int )*p);
    }
    {
#line 1231
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 1231
      tmp___1 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
      }
#line 1231
      if (! tmp___1) {
#line 1231
        return ((adns_status )1);
      }
#line 1231
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1227
    l --;
#line 1227
    p ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1233
  return ((adns_status )0);
}
}
#line 1240 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_flat___9(adns_query qu , void *data___0 ) 
{ 


  {
#line 1240
  return;
}
}
#line 1261 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static typeinfo const   typeinfos___9[17]  = 
#line 1261
  {      {(adns_rrtype )1, "A", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.inaddr)),
      & mf_flat___9, & cs_inaddr___9, & pa_inaddr___9, & di_inaddr___9, (adns_status (*)(adns_state ads ,
                                                                                         char const   **p_io ,
                                                                                         char const   *pe ,
                                                                                         int labelnum ,
                                                                                         char *label_r ,
                                                                                         int *ll_io ,
                                                                                         adns_queryflags flags ,
                                                                                         struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )2,
      "NS", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___9, & cs_domain___9,
      & pa_host_raw___9, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )5,
      "CNAME", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___9,
      & cs_domain___9, & pa_dom_raw___9, (int (*)(adns_state ads , void const   *datap_a ,
                                                  void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                              char const   **p_io ,
                                                                                              char const   *pe ,
                                                                                              int labelnum ,
                                                                                              char *label_r ,
                                                                                              int *ll_io ,
                                                                                              adns_queryflags flags ,
                                                                                              struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )6,
      "SOA", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.soa)), & mf_soa___9, & cs_soa___9,
      & pa_soa___9, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )12,
      "PTR", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___9, & cs_domain___9,
      & pa_host_raw___9, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )13,
      "HINFO", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.intstrpair)),
      & mf_intstrpair___9, & cs_hinfo___9, & pa_hinfo___9, (int (*)(adns_state ads ,
                                                                    void const   *datap_a ,
                                                                    void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )15,
      "MX", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.intstr)), & mf_intstr___9,
      & cs_inthost___9, & pa_mx_raw___9, & di_mx_raw___9, (adns_status (*)(adns_state ads ,
                                                                           char const   **p_io ,
                                                                           char const   *pe ,
                                                                           int labelnum ,
                                                                           char *label_r ,
                                                                           int *ll_io ,
                                                                           adns_queryflags flags ,
                                                                           struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )16,
      "TXT", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.manyistr)),
      & mf_manyistr___9, & cs_txt___9, & pa_txt___9, (int (*)(adns_state ads , void const   *datap_a ,
                                                              void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )17,
      "RP", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.strpair)), & mf_strpair___9,
      & cs_rp___9, & pa_rp___9, (int (*)(adns_state ads , void const   *datap_a ,
                                         void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                     char const   **p_io ,
                                                                                     char const   *pe ,
                                                                                     int labelnum ,
                                                                                     char *label_r ,
                                                                                     int *ll_io ,
                                                                                     adns_queryflags flags ,
                                                                                     struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )33,
      "SRV", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.srvraw)), & mf_srvraw___9,
      & cs_srvraw___9, & pa_srvraw___9, & di_srv___9, & qdpl_srv___9, & postsort_srv___9}, 
        {(adns_rrtype )65537,
      "A", "addr", (int )sizeof(*(((adns_answer *)0)->rrs.addr)), & mf_flat___9, & cs_addr___9,
      & pa_addr___9, & di_addr___9, (adns_status (*)(adns_state ads , char const   **p_io ,
                                                     char const   *pe , int labelnum ,
                                                     char *label_r , int *ll_io ,
                                                     adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65538,
      "NS", "+addr", (int )sizeof(*(((adns_answer *)0)->rrs.hostaddr)), & mf_hostaddr___9,
      & cs_hostaddr___9, & pa_hostaddr___9, & di_hostaddr___9, (adns_status (*)(adns_state ads ,
                                                                                char const   **p_io ,
                                                                                char const   *pe ,
                                                                                int labelnum ,
                                                                                char *label_r ,
                                                                                int *ll_io ,
                                                                                adns_queryflags flags ,
                                                                                struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65548,
      "PTR", "checked", (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___9,
      & cs_domain___9, & pa_ptr___9, (int (*)(adns_state ads , void const   *datap_a ,
                                              void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                          char const   **p_io ,
                                                                                          char const   *pe ,
                                                                                          int labelnum ,
                                                                                          char *label_r ,
                                                                                          int *ll_io ,
                                                                                          adns_queryflags flags ,
                                                                                          struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65551,
      "MX", "+addr", (int )sizeof(*(((adns_answer *)0)->rrs.inthostaddr)), & mf_inthostaddr___9,
      & cs_inthostaddr___9, & pa_mx___9, & di_mx___9, (adns_status (*)(adns_state ads ,
                                                                       char const   **p_io ,
                                                                       char const   *pe ,
                                                                       int labelnum ,
                                                                       char *label_r ,
                                                                       int *ll_io ,
                                                                       adns_queryflags flags ,
                                                                       struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65569,
      "SRV", "+addr", (int )sizeof(*(((adns_answer *)0)->rrs.srvha)), & mf_srvha___9,
      & cs_srvha___9, & pa_srvha___9, & di_srv___9, & qdpl_srv___9, & postsort_srv___9}, 
        {(adns_rrtype )131078,
      "SOA", "822", (int )sizeof(*(((adns_answer *)0)->rrs.soa)), & mf_soa___9, & cs_soa___9,
      & pa_soa___9, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )131089,
      "RP", "822", (int )sizeof(*(((adns_answer *)0)->rrs.strpair)), & mf_strpair___9,
      & cs_rp___9, & pa_rp___9, (int (*)(adns_state ads , void const   *datap_a ,
                                         void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                     char const   **p_io ,
                                                                                     char const   *pe ,
                                                                                     int labelnum ,
                                                                                     char *label_r ,
                                                                                     int *ll_io ,
                                                                                     adns_queryflags flags ,
                                                                                     struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}};
#line 1288 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static struct typeinfo  const  typeinfo_unknown___9  = 
#line 1288
     {(adns_rrtype )262144, (char const   *)0, "unknown", (int )sizeof(*(((adns_answer *)0)->rrs.byteblock)),
    & mf_byteblock___9, & cs_opaque___9, & pa_opaque___9, (int (*)(adns_state ads ,
                                                                   void const   *datap_a ,
                                                                   void const   *datap_b ))0,
    (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                     char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
    (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0};
#line 233 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/general.c"
static struct sinfo  const  sinfos___9[24]  = 
#line 233 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/general.c"
  {      {(adns_status )0, "ok", "OK"}, 
        {(adns_status )1, "nomemory", "Out of memory"}, 
        {(adns_status )2, "unknownrrtype", "Query not implemented in DNS library"}, 
        {(adns_status )3, "systemfail", "General resolver or system failure"}, 
        {(adns_status )30, "timeout", "DNS query timed out"}, 
        {(adns_status )31, "allservfail", "All nameservers failed"}, 
        {(adns_status )32, "norecurse", "Recursion denied by nameserver"}, 
        {(adns_status )33, "invalidresponse", "Nameserver sent bad response"}, 
        {(adns_status )34, "unknownformat", "Nameserver used unknown format"}, 
        {(adns_status )60, "rcodeservfail", "Nameserver reports failure"}, 
        {(adns_status )61, "rcodeformaterror", "Query not understood by nameserver"}, 
        {(adns_status )62,
      "rcodenotimplemented", "Query not implemented by nameserver"}, 
        {(adns_status )63, "rcoderefused", "Query refused by nameserver"}, 
        {(adns_status )64, "rcodeunknown", "Nameserver sent unknown response code"}, 
        {(adns_status )100, "inconsistent", "Inconsistent resource records in DNS"}, 
        {(adns_status )101, "prohibitedcname", "DNS alias found where canonical name wanted"}, 
        {(adns_status )102,
      "answerdomaininvalid", "Found syntactically invalid domain name"}, 
        {(adns_status )103, "answerdomaintoolong", "Found overly-long domain name"}, 
        {(adns_status )104, "invaliddata", "Found invalid DNS data"}, 
        {(adns_status )200, "querydomainwrong", "Domain invalid for particular DNS query type"}, 
        {(adns_status )201,
      "querydomaininvalid", "Domain name is syntactically invalid"}, 
        {(adns_status )202, "querydomaintoolong", "Domain name or component is too long"}, 
        {(adns_status )300,
      "nxdomain", "No such domain"}, 
        {(adns_status )301, "nodata", "No such data"}};
#line 270 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/general.c"
static int si_compar___9(void const   *key , void const   *elem ) 
{ 
  adns_status const   *st ;
  struct sinfo  const  *si ;
  int tmp ;
  int tmp___0 ;

  {
#line 271
  st = (adns_status const   *)key;
#line 272
  si = (struct sinfo  const  *)elem;
#line 274
  if ((unsigned int const   )*st < (unsigned int const   )si->st) {
#line 274
    tmp___0 = -1;
  } else {
#line 274
    if ((unsigned int const   )*st > (unsigned int const   )si->st) {
#line 274
      tmp = 1;
    } else {
#line 274
      tmp = 0;
    }
#line 274
    tmp___0 = tmp;
  }
#line 274
  return (tmp___0);
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/general.c"
static struct sinfo  const  *findsinfo___9(adns_status st ) 
{ 
  void *tmp ;

  {
  {
#line 278
  tmp = bsearch((void const   *)(& st), (void const   *)(sinfos___9), sizeof(sinfos___9) / sizeof(sinfos___9[0]),
                sizeof(sinfos___9[0]), & si_compar___9);
  }
#line 278
  return ((struct sinfo  const  *)tmp);
}
}
#line 299 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/general.c"
static struct stinfo  const  stinfos___9[7]  = {      {(adns_status )0, "ok"}, 
        {(adns_status )29, "localfail"}, 
        {(adns_status )59, "remotefail"}, 
        {(adns_status )99, "tempfail"}, 
        {(adns_status )199, "misconfig"}, 
        {(adns_status )299, "misquery"}, 
        {(adns_status )499, "permfail"}};
#line 312 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/general.c"
static int sti_compar___9(void const   *key , void const   *elem ) 
{ 
  adns_status const   *st ;
  struct stinfo  const  *sti ;
  adns_status here ;
  adns_status min ;
  adns_status max ;
  int tmp ;
  int tmp___0 ;

  {
#line 313
  st = (adns_status const   *)key;
#line 314
  sti = (struct stinfo  const  *)elem;
#line 318
  here = (adns_status )*st;
#line 319
  if ((unsigned long )sti == (unsigned long )(stinfos___9)) {
#line 319
    min = (adns_status )0;
  } else {
#line 319
    min = (adns_status )((unsigned int const   )(sti + -1)->stmax + 1U);
  }
#line 320
  max = (adns_status )sti->stmax;
#line 322
  if ((unsigned int )here < (unsigned int )min) {
#line 322
    tmp___0 = -1;
  } else {
#line 322
    if ((unsigned int )here > (unsigned int )max) {
#line 322
      tmp = 1;
    } else {
#line 322
      tmp = 0;
    }
#line 322
    tmp___0 = tmp;
  }
#line 322
  return (tmp___0);
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/transmit.c"
static adns_status mkquery_header___9(adns_state ads___7 , vbuf *vb___0 , int *id_r ,
                                      int qdlen ) 
{ 
  int id ;
  byte *rqp ;
  int tmp ;
  int tmp___0 ;
  byte *tmp___1 ;
  byte *tmp___2 ;
  byte *tmp___3 ;
  byte *tmp___4 ;
  byte *tmp___5 ;
  byte *tmp___6 ;
  byte *tmp___7 ;
  byte *tmp___8 ;
  byte *tmp___9 ;
  byte *tmp___10 ;
  byte *tmp___11 ;
  byte *tmp___12 ;

  {
  {
#line 46
  tmp = adns__vbuf_ensure(vb___0, (12 + qdlen) + 4);
  }
#line 46
  if (! tmp) {
#line 46
    return ((adns_status )1);
  }
#line 48
  vb___0->used = 0;
#line 49
  rqp = vb___0->buf + vb___0->used;
#line 51
  tmp___0 = ads___7->nextid;
#line 51
  (ads___7->nextid) ++;
#line 51
  id = tmp___0 & 65535;
#line 51
  *id_r = id;
#line 52
  tmp___1 = rqp;
#line 52
  rqp ++;
#line 52
  *tmp___1 = (byte )((id >> 8) & 255);
#line 52
  tmp___2 = rqp;
#line 52
  rqp ++;
#line 52
  *tmp___2 = (byte )(id & 255);
#line 53
  tmp___3 = rqp;
#line 53
  rqp ++;
#line 53
  *tmp___3 = (byte )1;
#line 54
  tmp___4 = rqp;
#line 54
  rqp ++;
#line 54
  *tmp___4 = (byte )0;
#line 55
  tmp___5 = rqp;
#line 55
  rqp ++;
#line 55
  *tmp___5 = (byte )((1 >> 8) & 255);
#line 55
  tmp___6 = rqp;
#line 55
  rqp ++;
#line 55
  *tmp___6 = (byte )1;
#line 56
  tmp___7 = rqp;
#line 56
  rqp ++;
#line 56
  *tmp___7 = (byte )0;
#line 56
  tmp___8 = rqp;
#line 56
  rqp ++;
#line 56
  *tmp___8 = (byte )0;
#line 57
  tmp___9 = rqp;
#line 57
  rqp ++;
#line 57
  *tmp___9 = (byte )0;
#line 57
  tmp___10 = rqp;
#line 57
  rqp ++;
#line 57
  *tmp___10 = (byte )0;
#line 58
  tmp___11 = rqp;
#line 58
  rqp ++;
#line 58
  *tmp___11 = (byte )0;
#line 58
  tmp___12 = rqp;
#line 58
  rqp ++;
#line 58
  *tmp___12 = (byte )0;
#line 60
  vb___0->used = (int )(rqp - vb___0->buf);
#line 62
  return ((adns_status )0);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/transmit.c"
static adns_status mkquery_footer___9(vbuf *vb___0 , adns_rrtype type ) 
{ 
  byte *rqp ;
  byte *tmp ;
  byte *tmp___0 ;
  byte *tmp___1 ;
  byte *tmp___2 ;

  {
#line 68
  rqp = vb___0->buf + vb___0->used;
#line 69
  tmp = rqp;
#line 69
  rqp ++;
#line 69
  *tmp = (byte )((((unsigned int )type & 65535U) >> 8) & 255U);
#line 69
  tmp___0 = rqp;
#line 69
  rqp ++;
#line 69
  *tmp___0 = (byte )(((unsigned int )type & 65535U) & 255U);
#line 70
  tmp___1 = rqp;
#line 70
  rqp ++;
#line 70
  *tmp___1 = (byte )((1 >> 8) & 255);
#line 70
  tmp___2 = rqp;
#line 70
  rqp ++;
#line 70
  *tmp___2 = (byte )1;
#line 71
  vb___0->used = (int )(rqp - vb___0->buf);
#line 72
  if (! (vb___0->used <= vb___0->avail)) {
    {
#line 72
    __assert_fail("vb->used <= vb->avail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/transmit.c",
                  72U, "mkquery_footer");
    }
  }
#line 74
  return ((adns_status )0);
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/transmit.c"
static void query_usetcp___9(adns_query qu , struct timeval now ) 
{ 


  {
  {
#line 244
  qu->state = (enum __anonenum_state_83 )1;
#line 245
  qu->timeout = now;
#line 246
  timevaladd___18(& qu->timeout, 30000L);
  }
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    qu->next = (adns_query )0;
#line 247
    qu->back = (qu->ads)->tcpw.tail;
#line 247
    if ((qu->ads)->tcpw.tail) {
#line 247
      ((qu->ads)->tcpw.tail)->next = qu;
    } else {
#line 247
      (qu->ads)->tcpw.head = qu;
    }
#line 247
    (qu->ads)->tcpw.tail = qu;
#line 247
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 248
  adns__querysend_tcp(qu, now);
#line 249
  adns__tcp_tryconnect(qu->ads, now);
  }
#line 250
  return;
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c"
static adns_query query_alloc___9(adns_state ads___7 , typeinfo const   *typei , adns_rrtype type ,
                                  adns_queryflags flags , struct timeval now ) 
{ 
  adns_query qu ;
  void *tmp ;
  void *tmp___0 ;
  adns_query tmp___1 ;
  adns_query tmp___2 ;
  adns_query tmp___3 ;
  adns_query tmp___4 ;
  allocnode *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __suseconds_t tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 45
  tmp = malloc(sizeof(*qu));
#line 45
  qu = (adns_query )tmp;
  }
#line 45
  if (! qu) {
#line 45
    return ((adns_query )0);
  }
  {
#line 46
  tmp___0 = malloc(sizeof(*(qu->answer)));
#line 46
  qu->answer = (adns_answer *)tmp___0;
  }
#line 47
  if (! qu->answer) {
    {
#line 47
    free((void *)qu);
    }
#line 47
    return ((adns_query )0);
  }
  {
#line 49
  qu->ads = ads___7;
#line 50
  qu->state = (enum __anonenum_state_83 )0;
#line 51
  tmp___2 = (adns_query )0;
#line 51
  qu->parent = tmp___2;
#line 51
  tmp___1 = tmp___2;
#line 51
  qu->next = tmp___1;
#line 51
  qu->back = tmp___1;
#line 52
  tmp___3 = (adns_query )0;
#line 52
  qu->children.tail = tmp___3;
#line 52
  qu->children.head = tmp___3;
#line 53
  tmp___4 = (adns_query )0;
#line 53
  qu->siblings.back = tmp___4;
#line 53
  qu->siblings.next = tmp___4;
#line 54
  tmp___5 = (allocnode *)0;
#line 54
  qu->allocations.tail = tmp___5;
#line 54
  qu->allocations.head = tmp___5;
#line 55
  qu->interim_allocd = 0;
#line 56
  qu->preserved_allocd = 0;
#line 57
  qu->final_allocspace = (void *)0;
#line 59
  qu->typei = typei;
#line 60
  qu->query_dgram = (byte *)0;
#line 61
  qu->query_dglen = 0;
#line 62
  adns__vbuf_init(& qu->vb);
#line 64
  qu->cname_dgram = (byte *)0;
#line 65
  tmp___6 = 0;
#line 65
  qu->cname_begin = tmp___6;
#line 65
  qu->cname_dglen = tmp___6;
#line 67
  adns__vbuf_init(& qu->search_vb);
#line 68
  tmp___8 = 0;
#line 68
  qu->search_doneabs = tmp___8;
#line 68
  tmp___7 = tmp___8;
#line 68
  qu->search_pos = tmp___7;
#line 68
  qu->search_origlen = tmp___7;
#line 70
  qu->id = -2;
#line 71
  qu->flags = (int )flags;
#line 72
  qu->retries = 0;
#line 73
  qu->udpnextserver = 0;
#line 74
  qu->udpsent = 0UL;
#line 75
  tmp___9 = (__suseconds_t )0;
#line 75
  qu->timeout.tv_usec = tmp___9;
#line 75
  qu->timeout.tv_sec = tmp___9;
#line 76
  qu->expires = now.tv_sec + 604800L;
#line 78
  memset((void *)(& qu->ctx), 0, sizeof(qu->ctx));
#line 80
  (qu->answer)->status = (adns_status )0;
#line 81
  tmp___10 = (char *)0;
#line 81
  (qu->answer)->owner = tmp___10;
#line 81
  (qu->answer)->cname = tmp___10;
#line 82
  (qu->answer)->type = type;
#line 83
  (qu->answer)->expires = (time_t )-1;
#line 84
  (qu->answer)->nrrs = 0;
#line 85
  (qu->answer)->rrs.untyped = (void *)0;
#line 86
  (qu->answer)->rrsz = (int )typei->rrsz;
  }
#line 88
  return (qu);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c"
static void query_submit___9(adns_state ads___7 , adns_query qu , typeinfo const   *typei ,
                             vbuf *qumsg_vb , int id , adns_queryflags flags , struct timeval now ) 
{ 
  void *tmp ;

  {
  {
#line 98
  qu->vb = *qumsg_vb;
#line 99
  adns__vbuf_init(qumsg_vb);
#line 101
  tmp = malloc((size_t )qu->vb.used);
#line 101
  qu->query_dgram = (byte *)tmp;
  }
#line 102
  if (! qu->query_dgram) {
    {
#line 102
    adns__query_fail(qu, (adns_status )1);
    }
#line 102
    return;
  }
  {
#line 104
  qu->id = id;
#line 105
  qu->query_dglen = qu->vb.used;
#line 106
  memcpy((void */* __restrict  */)qu->query_dgram, (void const   */* __restrict  */)qu->vb.buf,
         (size_t )qu->vb.used);
#line 108
  adns__query_send(qu, now);
  }
#line 109
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c"
static void query_simple___9(adns_state ads___7 , adns_query qu , char const   *owner ,
                             int ol , typeinfo const   *typei , adns_queryflags flags ,
                             struct timeval now ) 
{ 
  vbuf vb_new ;
  int id ;
  adns_status stat ;

  {
  {
#line 136
  stat = adns__mkquery(ads___7, & qu->vb, & id, owner, ol, typei, (qu->answer)->type,
                       flags);
  }
#line 138
  if (stat) {
#line 139
    if ((unsigned int )stat == 202U) {
#line 139
      if ((unsigned int )flags & 1U) {
        {
#line 140
        adns__search_next(ads___7, qu, now);
        }
#line 141
        return;
      } else {
        {
#line 143
        adns__query_fail(qu, stat);
        }
#line 144
        return;
      }
    } else {
      {
#line 143
      adns__query_fail(qu, stat);
      }
#line 144
      return;
    }
  }
  {
#line 148
  vb_new = qu->vb;
#line 149
  adns__vbuf_init(& qu->vb);
#line 150
  query_submit___9(ads___7, qu, typei, & vb_new, id, flags, now);
  }
#line 151
  return;
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c"
static int save_owner___9(adns_query qu , char const   *owner , int ol ) 
{ 
  adns_answer *ans ;
  void *tmp ;

  {
#line 198
  if (! (qu->flags & 4)) {
#line 198
    return (1);
  }
#line 200
  ans = qu->answer;
#line 201
  if (! (! ans->owner)) {
    {
#line 201
    __assert_fail("!ans->owner", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c",
                  201U, "save_owner");
    }
  }
  {
#line 203
  tmp = adns__alloc_preserved(qu, (size_t )(ol + 1));
#line 203
  ans->owner = (char *)tmp;
  }
#line 203
  if (! ans->owner) {
#line 203
    return (0);
  }
  {
#line 205
  memcpy((void */* __restrict  */)ans->owner, (void const   */* __restrict  */)owner,
         (size_t )ol);
#line 206
  *(ans->owner + ol) = (char)0;
  }
#line 207
  return (1);
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c"
static void *alloc_common___9(adns_query qu , size_t sz ) 
{ 
  allocnode *an ;
  void *tmp ;

  {
#line 342
  if (! sz) {
#line 342
    return ((void *)qu);
  }
#line 343
  if (! (! qu->final_allocspace)) {
    {
#line 343
    __assert_fail("!qu->final_allocspace", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c",
                  343U, "alloc_common");
    }
  }
  {
#line 344
  tmp = malloc((((((((sizeof(*an) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ) + sz) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ));
#line 344
  an = (allocnode *)tmp;
  }
#line 345
  if (! an) {
#line 345
    return ((void *)0);
  }
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 346
    an->next = (struct allocnode *)0;
#line 346
    an->back = qu->allocations.tail;
#line 346
    if (qu->allocations.tail) {
#line 346
      (qu->allocations.tail)->next = an;
    } else {
#line 346
      qu->allocations.head = an;
    }
#line 346
    qu->allocations.tail = an;
#line 346
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 347
  return ((void *)((byte *)an + (((sizeof(*an) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign )));
}
}
#line 410 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c"
static void cancel_children___9(adns_query qu ) 
{ 
  adns_query cqu ;
  adns_query ncqu ;

  {
#line 413
  cqu = qu->children.head;
  {
#line 413
  while (1) {
    while_continue: /* CIL Label */ ;
#line 413
    if (! cqu) {
#line 413
      goto while_break;
    }
    {
#line 414
    ncqu = cqu->siblings.next;
#line 415
    adns_cancel(cqu);
#line 413
    cqu = ncqu;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 417
  return;
}
}
#line 427 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c"
static void free_query_allocs___9(adns_query qu ) 
{ 
  allocnode *an ;
  allocnode *ann ;
  allocnode *tmp ;

  {
  {
#line 430
  cancel_children___9(qu);
#line 431
  an = qu->allocations.head;
  }
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    if (! an) {
#line 431
      goto while_break;
    }
    {
#line 431
    ann = an->next;
#line 431
    free((void *)an);
#line 431
    an = ann;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 432
  tmp = (allocnode *)0;
#line 432
  qu->allocations.tail = tmp;
#line 432
  qu->allocations.head = tmp;
#line 433
  adns__vbuf_free(& qu->vb);
#line 434
  adns__vbuf_free(& qu->search_vb);
#line 435
  free((void *)qu->query_dgram);
#line 436
  qu->query_dgram = (byte *)0;
  }
#line 437
  return;
}
}
#line 477 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c"
static void makefinal_query___9(adns_query qu ) 
{ 
  adns_answer *ans ;
  int rrn ;
  void *tmp ;

  {
#line 481
  ans = qu->answer;
#line 483
  if (qu->interim_allocd) {
    {
#line 484
    tmp = realloc((void *)qu->answer, (((((((sizeof(*ans) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ) + (unsigned long )qu->interim_allocd) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ));
#line 484
    ans = (adns_answer *)tmp;
    }
#line 486
    if (! ans) {
#line 486
      goto x_nomem;
    }
#line 487
    qu->answer = ans;
  }
  {
#line 490
  qu->final_allocspace = (void *)((byte *)ans + (((sizeof(*ans) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ));
#line 491
  adns__makefinal_str(qu, & ans->cname);
#line 492
  adns__makefinal_str(qu, & ans->owner);
  }
#line 494
  if (ans->nrrs) {
    {
#line 495
    adns__makefinal_block(qu, & ans->rrs.untyped, (size_t )(ans->nrrs * ans->rrsz));
#line 497
    rrn = 0;
    }
    {
#line 497
    while (1) {
      while_continue: /* CIL Label */ ;
#line 497
      if (! (rrn < ans->nrrs)) {
#line 497
        goto while_break;
      }
      {
#line 498
      (*((qu->typei)->makefinal))(qu, (void *)(ans->rrs.bytes + rrn * ans->rrsz));
#line 497
      rrn ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 501
  free_query_allocs___9(qu);
  }
#line 502
  return;
  x_nomem: 
  {
#line 505
  qu->preserved_allocd = 0;
#line 506
  (qu->answer)->cname = (char *)0;
#line 507
  (qu->answer)->owner = (char *)0;
#line 508
  adns__reset_preserved(qu);
#line 510
  (qu->answer)->status = (adns_status )1;
#line 511
  free_query_allocs___9(qu);
  }
#line 512
  return;
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void readconfig___9(adns_state ads___7 , char const   *filename , int warnmissing ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void addserver___9(adns_state ads___7 , struct in_addr addr ) 
{ 
  int i ;
  struct server *ss ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 48
  i = 0;
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (i < ads___7->nservers)) {
#line 48
      goto while_break;
    }
#line 49
    if (ads___7->servers[i].addr.s_addr == addr.s_addr) {
      {
#line 50
      tmp = inet_ntoa(addr);
#line 50
      adns__debug(ads___7, -1, (adns_query )0, "duplicate nameserver %s ignored",
                  tmp);
      }
#line 51
      return;
    }
#line 48
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  if (ads___7->nservers >= 5) {
    {
#line 56
    tmp___0 = inet_ntoa(addr);
#line 56
    adns__diag(ads___7, -1, (adns_query )0, "too many nameservers, ignoring %s", tmp___0);
    }
#line 57
    return;
  }
#line 60
  ss = ads___7->servers + ads___7->nservers;
#line 61
  ss->addr = addr;
#line 62
  (ads___7->nservers) ++;
#line 63
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void freesearchlist___9(adns_state ads___7 ) 
{ 


  {
#line 66
  if (ads___7->nsearchlist) {
    {
#line 66
    free((void *)*(ads___7->searchlist));
    }
  }
  {
#line 67
  free((void *)ads___7->searchlist);
  }
#line 68
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void saveerr___9(adns_state ads___7 , int en ) 
{ 


  {
#line 71
  if (! ads___7->configerrno) {
#line 71
    ads___7->configerrno = en;
  }
#line 72
  return;
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void configparseerr___9(adns_state ads___7 , char const   *fn , int lno , char const   *fmt 
                               , ...) 
{ 
  va_list al ;

  {
  {
#line 78
  saveerr___9(ads___7, 22);
  }
#line 79
  if (! ads___7->logfn) {
#line 79
    return;
  } else
#line 79
  if ((unsigned int )ads___7->iflags & 2U) {
#line 79
    return;
  }
#line 81
  if (lno == -1) {
    {
#line 81
    adns__lprintf(ads___7, "adns: %s: ", fn);
    }
  } else {
    {
#line 82
    adns__lprintf(ads___7, "adns: %s:%d: ", fn, lno);
    }
  }
  {
#line 83
  __builtin_va_start(al, fmt);
#line 84
  adns__vlprintf(ads___7, fmt, al);
#line 85
  __builtin_va_end(al);
#line 86
  adns__lprintf(ads___7, "\n");
  }
#line 87
  return;
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static int nextword___9(char const   **bufp_io , char const   **word_r , int *l_r ) 
{ 
  char const   *p ;
  char const   *q ;
  int tmp ;
  int tmp___0 ;

  {
#line 92
  p = *bufp_io;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 93
    tmp = ctype_whitespace((int )*p);
    }
#line 93
    if (! tmp) {
#line 93
      goto while_break;
    }
#line 93
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  if (! *p) {
#line 94
    return (0);
  }
#line 96
  q = p;
  {
#line 97
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 97
    if (*q) {
      {
#line 97
      tmp___0 = ctype_whitespace((int )*q);
      }
#line 97
      if (tmp___0) {
#line 97
        goto while_break___0;
      }
    } else {
#line 97
      goto while_break___0;
    }
#line 97
    q ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 99
  *l_r = (int )(q - p);
#line 100
  *word_r = p;
#line 101
  *bufp_io = q;
#line 103
  return (1);
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void ccf_nameserver___9(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  struct in_addr ia ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 110
  tmp = inet_aton(buf___17, & ia);
  }
#line 110
  if (! tmp) {
    {
#line 111
    configparseerr___9(ads___7, fn, lno, "invalid nameserver address `%s\'", buf___17);
    }
#line 112
    return;
  }
  {
#line 114
  tmp___0 = inet_ntoa(ia);
#line 114
  adns__debug(ads___7, -1, (adns_query )0, "using nameserver %s", tmp___0);
#line 115
  addserver___9(ads___7, ia);
  }
#line 116
  return;
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void ccf_search___9(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  char const   *bufp ;
  char const   *word ;
  char *newchars ;
  char **newptrs ;
  char **pp ;
  int count ;
  int tl ;
  int l ;
  int tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char **tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
#line 124
  if (! buf___17) {
#line 124
    return;
  }
#line 126
  bufp = buf___17;
#line 127
  count = 0;
#line 128
  tl = 0;
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 129
    tmp = nextword___9(& bufp, & word, & l);
    }
#line 129
    if (! tmp) {
#line 129
      goto while_break;
    }
#line 129
    count ++;
#line 129
    tl += l + 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 131
  tmp___0 = malloc(sizeof(char *) * (unsigned long )count);
#line 131
  newptrs = (char **)tmp___0;
  }
#line 132
  if (! newptrs) {
    {
#line 132
    tmp___1 = __errno_location();
#line 132
    saveerr___9(ads___7, *tmp___1);
    }
#line 132
    return;
  }
  {
#line 134
  tmp___2 = malloc((size_t )tl);
#line 134
  newchars = (char *)tmp___2;
  }
#line 135
  if (! newchars) {
    {
#line 135
    tmp___3 = __errno_location();
#line 135
    saveerr___9(ads___7, *tmp___3);
#line 135
    free((void *)newptrs);
    }
#line 135
    return;
  }
#line 137
  bufp = buf___17;
#line 138
  pp = newptrs;
  {
#line 139
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 139
    tmp___6 = nextword___9(& bufp, & word, & l);
    }
#line 139
    if (! tmp___6) {
#line 139
      goto while_break___0;
    }
    {
#line 140
    tmp___4 = pp;
#line 140
    pp ++;
#line 140
    *tmp___4 = newchars;
#line 141
    memcpy((void */* __restrict  */)newchars, (void const   */* __restrict  */)word,
           (size_t )l);
#line 142
    newchars += l;
#line 143
    tmp___5 = newchars;
#line 143
    newchars ++;
#line 143
    *tmp___5 = (char)0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 146
  freesearchlist___9(ads___7);
#line 147
  ads___7->nsearchlist = count;
#line 148
  ads___7->searchlist = newptrs;
  }
#line 149
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void ccf_sortlist___9(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  char const   *word ;
  char tbuf[200] ;
  char *slash ;
  char *ep ;
  struct in_addr base ;
  struct in_addr mask ;
  int l ;
  unsigned long initial ;
  unsigned long baselocal ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  uint32_t tmp___3 ;
  int tmp___4 ;

  {
#line 159
  if (! buf___17) {
#line 159
    return;
  }
#line 161
  ads___7->nsortlist = 0;
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 162
    tmp___4 = nextword___9(& buf___17, & word, & l);
    }
#line 162
    if (! tmp___4) {
#line 162
      goto while_break;
    }
#line 163
    if (ads___7->nsortlist >= 15) {
      {
#line 164
      adns__diag(ads___7, -1, (adns_query )0, "too many sortlist entries, ignoring %.*s onwards",
                 l, word);
      }
#line 166
      return;
    }
#line 169
    if ((unsigned long )l >= sizeof(tbuf)) {
      {
#line 170
      configparseerr___9(ads___7, fn, lno, "sortlist entry `%.*s\' too long", l, word);
      }
#line 171
      goto while_continue;
    }
    {
#line 174
    memcpy((void */* __restrict  */)(tbuf), (void const   */* __restrict  */)word,
           (size_t )l);
#line 174
    tbuf[l] = (char)0;
#line 175
    slash = strchr((char const   *)(tbuf), '/');
    }
#line 176
    if (slash) {
#line 176
      tmp = slash;
#line 176
      slash ++;
#line 176
      *tmp = (char)0;
    }
    {
#line 178
    tmp___0 = inet_aton((char const   *)(tbuf), & base);
    }
#line 178
    if (! tmp___0) {
      {
#line 179
      configparseerr___9(ads___7, fn, lno, "invalid address `%s\' in sortlist", tbuf);
      }
#line 180
      goto while_continue;
    }
#line 183
    if (slash) {
      {
#line 184
      tmp___2 = strchr((char const   *)slash, '.');
      }
#line 184
      if (tmp___2) {
        {
#line 185
        tmp___1 = inet_aton((char const   *)slash, & mask);
        }
#line 185
        if (! tmp___1) {
          {
#line 186
          configparseerr___9(ads___7, fn, lno, "invalid mask `%s\' in sortlist", slash);
          }
#line 187
          goto while_continue;
        }
#line 189
        if (base.s_addr & ~ mask.s_addr) {
          {
#line 190
          configparseerr___9(ads___7, fn, lno, "mask `%s\' in sortlist overlaps address `%s\'",
                             slash, tbuf);
          }
#line 192
          goto while_continue;
        }
      } else {
        {
#line 195
        initial = strtoul((char const   */* __restrict  */)slash, (char **/* __restrict  */)(& ep),
                          10);
        }
#line 196
        if (*ep) {
          {
#line 197
          configparseerr___9(ads___7, fn, lno, "mask length `%s\' invalid", slash);
          }
#line 198
          goto while_continue;
        } else
#line 196
        if (initial > 32UL) {
          {
#line 197
          configparseerr___9(ads___7, fn, lno, "mask length `%s\' invalid", slash);
          }
#line 198
          goto while_continue;
        }
        {
#line 200
        mask.s_addr = htonl((uint32_t )(4294967295UL << (32UL - initial)));
        }
      }
    } else {
      {
#line 203
      tmp___3 = ntohl(base.s_addr);
#line 203
      baselocal = (unsigned long )tmp___3;
      }
#line 204
      if ((unsigned long )(! baselocal) & 2147483648UL) {
        {
#line 205
        mask.s_addr = htonl((uint32_t )4278190080UL);
        }
      } else
#line 206
      if ((baselocal & 3221225472UL) == 2147483648UL) {
        {
#line 207
        mask.s_addr = htonl((uint32_t )4294901760UL);
        }
      } else
#line 208
      if ((baselocal & 4026531840UL) == 3758096384UL) {
        {
#line 209
        mask.s_addr = htonl((uint32_t )4278190080UL);
        }
      } else {
        {
#line 211
        configparseerr___9(ads___7, fn, lno, "network address `%s\' in sortlist is not in classed ranges, must specify mask explicitly",
                           tbuf);
        }
#line 214
        goto while_continue;
      }
    }
#line 218
    ads___7->sortlist[ads___7->nsortlist].base = base;
#line 219
    ads___7->sortlist[ads___7->nsortlist].mask = mask;
#line 220
    (ads___7->nsortlist) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  return;
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void ccf_options___9(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  char const   *word ;
  char *ep ;
  unsigned long v ;
  int l ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 231
  if (! buf___17) {
#line 231
    return;
  }
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 233
    tmp___5 = nextword___9(& buf___17, & word, & l);
    }
#line 233
    if (! tmp___5) {
#line 233
      goto while_break;
    }
#line 234
    if (l == 5) {
      {
#line 234
      tmp = memcmp((void const   *)word, (void const   *)"debug", (size_t )5);
      }
#line 234
      if (! tmp) {
#line 235
        ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 8U);
#line 236
        goto while_continue;
      }
    }
#line 238
    if (l >= 6) {
      {
#line 238
      tmp___0 = memcmp((void const   *)word, (void const   *)"ndots:", (size_t )6);
      }
#line 238
      if (! tmp___0) {
        {
#line 239
        v = strtoul((char const   */* __restrict  */)(word + 6), (char **/* __restrict  */)(& ep),
                    10);
        }
#line 240
        if (l == 6) {
          {
#line 241
          configparseerr___9(ads___7, fn, lno, "option `%.*s\' malformed or has bad value",
                             l, word);
          }
#line 243
          goto while_continue;
        } else
#line 240
        if ((unsigned long )ep != (unsigned long )(word + l)) {
          {
#line 241
          configparseerr___9(ads___7, fn, lno, "option `%.*s\' malformed or has bad value",
                             l, word);
          }
#line 243
          goto while_continue;
        } else
#line 240
        if (v > 2147483647UL) {
          {
#line 241
          configparseerr___9(ads___7, fn, lno, "option `%.*s\' malformed or has bad value",
                             l, word);
          }
#line 243
          goto while_continue;
        }
#line 245
        ads___7->searchndots = (int )v;
#line 246
        goto while_continue;
      }
    }
#line 248
    if (l >= 12) {
      {
#line 248
      tmp___4 = memcmp((void const   *)word, (void const   *)"adns_checkc:", (size_t )12);
      }
#line 248
      if (! tmp___4) {
        {
#line 249
        tmp___3 = strcmp(word + 12, "none");
        }
#line 249
        if (tmp___3) {
          {
#line 252
          tmp___2 = strcmp(word + 12, "entex");
          }
#line 252
          if (tmp___2) {
            {
#line 255
            tmp___1 = strcmp(word + 12, "freq");
            }
#line 255
            if (tmp___1) {
              {
#line 258
              configparseerr___9(ads___7, fn, lno, "option adns_checkc has bad value `%s\' (must be none, entex or freq",
                                 word + 12);
              }
            } else {
#line 256
              ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 768U);
            }
          } else {
#line 253
            ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags & 4294966527U);
#line 254
            ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 256U);
          }
        } else {
#line 250
          ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags & 4294966527U);
#line 251
          ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 256U);
        }
#line 261
        goto while_continue;
      }
    }
    {
#line 263
    adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown option `%.*s\'", fn, lno,
               l, word);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 265
  return;
}
}
#line 267 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void ccf_clearnss___9(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 


  {
#line 269
  ads___7->nservers = 0;
#line 270
  return;
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void ccf_include___9(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 


  {
#line 274
  if (! *buf___17) {
    {
#line 275
    configparseerr___9(ads___7, fn, lno, "`include\' directive with no filename");
    }
#line 276
    return;
  }
  {
#line 278
  readconfig___9(ads___7, buf___17, 1);
  }
#line 279
  return;
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void ccf_lookup___9(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  int found_bind ;
  char const   *word ;
  int l ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 283
  found_bind = 0;
#line 287
  if (! *buf___17) {
    {
#line 288
    configparseerr___9(ads___7, fn, lno, "`lookup\' directive with no databases");
    }
#line 289
    return;
  }
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 292
    tmp___2 = nextword___9(& buf___17, & word, & l);
    }
#line 292
    if (! tmp___2) {
#line 292
      goto while_break;
    }
#line 293
    if (l == 4) {
      {
#line 293
      tmp___1 = memcmp((void const   *)word, (void const   *)"bind", (size_t )4);
      }
#line 293
      if (tmp___1) {
#line 293
        goto _L___0;
      } else {
#line 294
        found_bind = 1;
      }
    } else
    _L___0: /* CIL Label */ 
#line 295
    if (l == 4) {
      {
#line 295
      tmp___0 = memcmp((void const   *)word, (void const   *)"file", (size_t )4);
      }
#line 295
      if (tmp___0) {
#line 295
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 297
    if (l == 2) {
      {
#line 297
      tmp = memcmp((void const   *)word, (void const   *)"yp", (size_t )2);
      }
#line 297
      if (tmp) {
        {
#line 301
        adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown `lookup\' database `%.*s\'",
                   fn, lno, l, word);
#line 303
        found_bind = -1;
        }
      } else {
        {
#line 298
        adns__diag(ads___7, -1, (adns_query )0, "%s:%d: yp lookups not supported by adns",
                   fn, lno);
#line 299
        found_bind = -1;
        }
      }
    } else {
      {
#line 301
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown `lookup\' database `%.*s\'",
                 fn, lno, l, word);
#line 303
      found_bind = -1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 306
  if (! found_bind) {
    {
#line 307
    adns__diag(ads___7, -1, (adns_query )0, "%s:%d: `lookup\' specified, but not `bind\'",
               fn, lno);
    }
  }
#line 308
  return;
}
}
#line 310 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static struct configcommandinfo  const  configcommandinfos___9[9]  = 
#line 310
  {      {"nameserver", & ccf_nameserver___9}, 
        {"domain", & ccf_search___9}, 
        {"search", & ccf_search___9}, 
        {"sortlist", & ccf_sortlist___9}, 
        {"options", & ccf_options___9}, 
        {"clearnameservers", & ccf_clearnss___9}, 
        {"include", & ccf_include___9}, 
        {"lookup", & ccf_lookup___9}, 
        {(char const   *)0, (void (*)(adns_state ads , char const   *fn , int lno , char const   *buf ))0}};
#line 330 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static int gl_file___9(adns_state ads___7 , getline_ctx *src_io , char const   *filename ,
                       int lno , char *buf___17 , int buflen ) 
{ 
  FILE *file ;
  int c ;
  int i ;
  char *p ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 332
  file = src_io->file;
#line 336
  p = buf___17;
#line 337
  buflen --;
#line 338
  i = 0;
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (i == buflen) {
      {
#line 342
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: line too long, ignored", filename,
                 lno);
      }
#line 343
      goto x_badline;
    }
    {
#line 345
    c = _IO_getc(file);
    }
#line 346
    if (! c) {
      {
#line 347
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: line contains nul, ignored",
                 filename, lno);
      }
#line 348
      goto x_badline;
    } else
#line 349
    if (c == 10) {
#line 350
      goto while_break;
    } else
#line 351
    if (c == -1) {
      {
#line 352
      tmp___2 = ferror(file);
      }
#line 352
      if (tmp___2) {
        {
#line 353
        tmp = __errno_location();
#line 353
        saveerr___9(ads___7, *tmp);
#line 354
        tmp___0 = __errno_location();
#line 354
        tmp___1 = strerror(*tmp___0);
#line 354
        adns__diag(ads___7, -1, (adns_query )0, "%s:%d: read error: %s", filename,
                   lno, tmp___1);
        }
#line 356
        return (-1);
      }
#line 358
      if (! i) {
#line 358
        return (-1);
      }
#line 359
      goto while_break;
    } else {
#line 361
      tmp___3 = p;
#line 361
      p ++;
#line 361
      *tmp___3 = (char )c;
#line 362
      i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 366
  tmp___4 = p;
#line 366
  p ++;
#line 366
  *tmp___4 = (char)0;
#line 367
  return (i);
  x_badline: 
  {
#line 370
  saveerr___9(ads___7, 22);
  }
  {
#line 371
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 371
    c = _IO_getc(file);
    }
#line 371
    if (c != -1) {
#line 371
      if (! (c != 10)) {
#line 371
        goto while_break___0;
      }
    } else {
#line 371
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 372
  return (-2);
}
}
#line 375 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static int gl_text___9(adns_state ads___7 , getline_ctx *src_io , char const   *filename ,
                       int lno , char *buf___17 , int buflen ) 
{ 
  char const   *cp ;
  int l ;
  size_t tmp ;

  {
#line 377
  cp = src_io->text;
#line 380
  if (! cp) {
#line 380
    return (-1);
  } else
#line 380
  if (! *cp) {
#line 380
    return (-1);
  }
#line 382
  if ((int const   )*cp == 59) {
#line 382
    cp ++;
  } else
#line 382
  if ((int const   )*cp == 10) {
#line 382
    cp ++;
  }
  {
#line 383
  tmp = strcspn(cp, ";\n");
#line 383
  l = (int )tmp;
#line 384
  src_io->text = cp + l;
  }
#line 386
  if (l >= buflen) {
    {
#line 387
    adns__diag(ads___7, -1, (adns_query )0, "%s:%d: line too long, ignored", filename,
               lno);
#line 388
    saveerr___9(ads___7, 22);
    }
#line 389
    return (-2);
  }
  {
#line 392
  memcpy((void */* __restrict  */)buf___17, (void const   */* __restrict  */)cp, (size_t )l);
#line 393
  *(buf___17 + l) = (char)0;
  }
#line 394
  return (l);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void readconfiggeneric___9(adns_state ads___7 , char const   *filename , int (*getline___0)(adns_state ads ,
                                                                                                   getline_ctx * ,
                                                                                                   char const   *filename ,
                                                                                                   int lno ,
                                                                                                   char *buf ,
                                                                                                   int buflen ) ,
                                  getline_ctx gl_ctx ) 
{ 
  char linebuf[2000] ;
  char *p ;
  char *q ;
  int lno ;
  int l ;
  int dirl ;
  struct configcommandinfo  const  *ccip ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 410
  lno = 1;
  {
#line 410
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 410
    l = (*getline___0)(ads___7, & gl_ctx, filename, lno, linebuf, (int )sizeof(linebuf));
    }
#line 410
    if (! (l != -1)) {
#line 410
      goto while_break;
    }
#line 413
    if (l == -2) {
#line 413
      goto __Cont;
    }
    {
#line 414
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 414
      if (l > 0) {
        {
#line 414
        tmp = ctype_whitespace((int )linebuf[l - 1]);
        }
#line 414
        if (! tmp) {
#line 414
          goto while_break___0;
        }
      } else {
#line 414
        goto while_break___0;
      }
#line 414
      l --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 415
    linebuf[l] = (char)0;
#line 416
    p = linebuf;
    {
#line 417
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 417
      tmp___0 = ctype_whitespace((int )*p);
      }
#line 417
      if (! tmp___0) {
#line 417
        goto while_break___1;
      }
#line 417
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 418
    if ((int )*p == 35) {
#line 418
      goto __Cont;
    } else
#line 418
    if ((int )*p == 59) {
#line 418
      goto __Cont;
    } else
#line 418
    if (! *p) {
#line 418
      goto __Cont;
    }
#line 419
    q = p;
    {
#line 420
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 420
      if (*q) {
        {
#line 420
        tmp___1 = ctype_whitespace((int )*q);
        }
#line 420
        if (tmp___1) {
#line 420
          goto while_break___2;
        }
      } else {
#line 420
        goto while_break___2;
      }
#line 420
      q ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 421
    dirl = (int )(q - p);
#line 422
    ccip = configcommandinfos___9;
    {
#line 422
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 422
      if (ccip->name) {
        {
#line 422
        tmp___2 = strlen((char const   *)ccip->name);
        }
#line 422
        if (tmp___2 == (size_t )dirl) {
          {
#line 422
          tmp___3 = memcmp((void const   *)ccip->name, (void const   *)p, (size_t )(q - p));
          }
#line 422
          if (! tmp___3) {
#line 422
            goto while_break___3;
          }
        }
      } else {
#line 422
        goto while_break___3;
      }
#line 422
      ccip ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 426
    if (! ccip->name) {
      {
#line 427
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown configuration directive `%.*s\'",
                 filename, lno, (int )(q - p), p);
      }
#line 429
      goto __Cont;
    }
    {
#line 431
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 431
      tmp___4 = ctype_whitespace((int )*q);
      }
#line 431
      if (! tmp___4) {
#line 431
        goto while_break___4;
      }
#line 431
      q ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 432
    (*(ccip->fn))(ads___7, filename, lno, (char const   *)q);
    }
    __Cont: /* CIL Label */ 
#line 410
    lno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 434
  return;
}
}
#line 436 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static char const   *instrum_getenv___9(adns_state ads___7 , char const   *envvar ) 
{ 
  char const   *value ;
  char *tmp ;

  {
  {
#line 439
  tmp = getenv(envvar);
#line 439
  value = (char const   *)tmp;
  }
#line 440
  if (! value) {
    {
#line 440
    adns__debug(ads___7, -1, (adns_query )0, "environment variable %s not set", envvar);
    }
  } else {
    {
#line 441
    adns__debug(ads___7, -1, (adns_query )0, "environment variable %s set to `%s\'",
                envvar, value);
    }
  }
#line 443
  return (value);
}
}
#line 446 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void readconfig___9(adns_state ads___7 , char const   *filename , int warnmissing ) 
{ 
  getline_ctx gl_ctx ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 449
  gl_ctx.file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 450
  if (! gl_ctx.file) {
    {
#line 451
    tmp = __errno_location();
    }
#line 451
    if (*tmp == 2) {
#line 452
      if (warnmissing) {
        {
#line 453
        adns__debug(ads___7, -1, (adns_query )0, "configuration file `%s\' does not exist",
                    filename);
        }
      }
#line 455
      return;
    }
    {
#line 457
    tmp___0 = __errno_location();
#line 457
    saveerr___9(ads___7, *tmp___0);
#line 458
    tmp___1 = __errno_location();
#line 458
    tmp___2 = strerror(*tmp___1);
#line 458
    adns__diag(ads___7, -1, (adns_query )0, "cannot open configuration file `%s\': %s",
               filename, tmp___2);
    }
#line 460
    return;
  }
  {
#line 463
  readconfiggeneric___9(ads___7, filename, & gl_file___9, gl_ctx);
#line 465
  fclose(gl_ctx.file);
  }
#line 466
  return;
}
}
#line 468 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void readconfigtext___9(adns_state ads___7 , char const   *text , char const   *showname ) 
{ 
  getline_ctx gl_ctx ;

  {
  {
#line 472
  gl_ctx.text = text;
#line 473
  readconfiggeneric___9(ads___7, showname, & gl_text___9, gl_ctx);
  }
#line 474
  return;
}
}
#line 476 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void readconfigenv___9(adns_state ads___7 , char const   *envvar ) 
{ 
  char const   *filename ;

  {
#line 479
  if ((unsigned int )ads___7->iflags & 1U) {
    {
#line 480
    adns__debug(ads___7, -1, (adns_query )0, "not checking environment variable `%s\'",
                envvar);
    }
#line 481
    return;
  }
  {
#line 483
  filename = instrum_getenv___9(ads___7, envvar);
  }
#line 484
  if (filename) {
    {
#line 484
    readconfig___9(ads___7, filename, 1);
    }
  }
#line 485
  return;
}
}
#line 487 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void readconfigenvtext___9(adns_state ads___7 , char const   *envvar ) 
{ 
  char const   *textdata ;

  {
#line 490
  if ((unsigned int )ads___7->iflags & 1U) {
    {
#line 491
    adns__debug(ads___7, -1, (adns_query )0, "not checking environment variable `%s\'",
                envvar);
    }
#line 492
    return;
  }
  {
#line 494
  textdata = instrum_getenv___9(ads___7, envvar);
  }
#line 495
  if (textdata) {
    {
#line 495
    readconfigtext___9(ads___7, textdata, envvar);
    }
  }
#line 496
  return;
}
}
#line 508 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static int init_begin___9(adns_state *ads_r , adns_initflags flags , adns_logcallbackfn *logfn ,
                          void *logfndata ) 
{ 
  adns_state ads___7 ;
  pid_t pid ;
  void *tmp ;
  int *tmp___0 ;
  adns_query tmp___1 ;
  adns_query tmp___2 ;
  adns_query tmp___3 ;
  adns_query tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __suseconds_t tmp___9 ;

  {
  {
#line 513
  tmp = malloc(sizeof(*ads___7));
#line 513
  ads___7 = (adns_state )tmp;
  }
#line 513
  if (! ads___7) {
    {
#line 513
    tmp___0 = __errno_location();
    }
#line 513
    return (*tmp___0);
  }
  {
#line 515
  ads___7->iflags = flags;
#line 516
  ads___7->logfn = logfn;
#line 517
  ads___7->logfndata = logfndata;
#line 518
  ads___7->configerrno = 0;
#line 519
  tmp___1 = (adns_query )0;
#line 519
  ads___7->udpw.tail = tmp___1;
#line 519
  ads___7->udpw.head = tmp___1;
#line 520
  tmp___2 = (adns_query )0;
#line 520
  ads___7->tcpw.tail = tmp___2;
#line 520
  ads___7->tcpw.head = tmp___2;
#line 521
  tmp___3 = (adns_query )0;
#line 521
  ads___7->childw.tail = tmp___3;
#line 521
  ads___7->childw.head = tmp___3;
#line 522
  tmp___4 = (adns_query )0;
#line 522
  ads___7->output.tail = tmp___4;
#line 522
  ads___7->output.head = tmp___4;
#line 523
  ads___7->forallnext = (adns_query )0;
#line 524
  ads___7->nextid = 12575;
#line 525
  tmp___5 = -1;
#line 525
  ads___7->tcpsocket = tmp___5;
#line 525
  ads___7->udpsocket = tmp___5;
#line 526
  adns__vbuf_init(& ads___7->tcpsend);
#line 527
  adns__vbuf_init(& ads___7->tcprecv);
#line 528
  ads___7->tcprecv_skip = 0;
#line 529
  tmp___8 = 0;
#line 529
  ads___7->tcpserver = tmp___8;
#line 529
  tmp___7 = tmp___8;
#line 529
  ads___7->nsearchlist = tmp___7;
#line 529
  tmp___6 = tmp___7;
#line 529
  ads___7->nsortlist = tmp___6;
#line 529
  ads___7->nservers = tmp___6;
#line 530
  ads___7->searchndots = 1;
#line 531
  ads___7->tcpstate = (enum adns__tcpstate )0;
#line 532
  tmp___9 = (__suseconds_t )0;
#line 532
  ads___7->tcptimeout.tv_usec = tmp___9;
#line 532
  ads___7->tcptimeout.tv_sec = tmp___9;
#line 533
  ads___7->searchlist = (char **)0;
#line 535
  pid = getpid();
#line 536
  ads___7->rand48xsubi[0] = (unsigned short )pid;
#line 537
  ads___7->rand48xsubi[1] = (unsigned short )((unsigned long )pid >> 16);
#line 538
  ads___7->rand48xsubi[2] = (unsigned short )((unsigned long )pid ^ ((unsigned long )pid >> 16));
#line 540
  *ads_r = ads___7;
  }
#line 541
  return (0);
}
}
#line 544 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static int init_finish___9(adns_state ads___7 ) 
{ 
  struct in_addr ia ;
  struct protoent *proto ;
  int r ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 549
  if (! ads___7->nservers) {
#line 550
    if (ads___7->logfn) {
#line 550
      if ((unsigned int )ads___7->iflags & 8U) {
        {
#line 551
        adns__lprintf(ads___7, "adns: no nameservers, using localhost\n");
        }
      }
    }
    {
#line 552
    ia.s_addr = htonl((in_addr_t )2130706433);
#line 553
    addserver___9(ads___7, ia);
    }
  }
  {
#line 556
  proto = getprotobyname("udp");
  }
#line 556
  if (! proto) {
#line 556
    r = 92;
#line 556
    goto x_free;
  }
  {
#line 557
  ads___7->udpsocket = socket(2, 2, proto->p_proto);
  }
#line 558
  if (ads___7->udpsocket < 0) {
    {
#line 558
    tmp = __errno_location();
#line 558
    r = *tmp;
    }
#line 558
    goto x_free;
  }
  {
#line 560
  r = adns__setnonblock(ads___7, ads___7->udpsocket);
  }
#line 561
  if (r) {
    {
#line 561
    tmp___0 = __errno_location();
#line 561
    r = *tmp___0;
    }
#line 561
    goto x_closeudp;
  }
#line 563
  return (0);
  x_closeudp: 
  {
#line 566
  close(ads___7->udpsocket);
  }
  x_free: 
  {
#line 568
  free((void *)ads___7);
  }
#line 569
  return (r);
}
}
#line 572 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void init_abort___9(adns_state ads___7 ) 
{ 


  {
#line 573
  if (ads___7->nsearchlist) {
    {
#line 574
    free((void *)*(ads___7->searchlist + 0));
#line 575
    free((void *)ads___7->searchlist);
    }
  }
  {
#line 577
  free((void *)ads___7);
  }
#line 578
  return;
}
}
#line 580 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void logfn_file___9(adns_state ads___7 , void *logfndata , char const   *fmt ,
                           va_list al ) 
{ 


  {
  {
#line 582
  vfprintf((FILE */* __restrict  */)logfndata, (char const   */* __restrict  */)fmt,
           al);
  }
#line 583
  return;
}
}
#line 585 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static int init_files___9(adns_state *ads_r , adns_initflags flags , adns_logcallbackfn *logfn ,
                          void *logfndata ) 
{ 
  adns_state ads___7 ;
  char const   *res_options ;
  char const   *adns_res_options ;
  int r ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 591
  r = init_begin___9(& ads___7, flags, logfn, logfndata);
  }
#line 592
  if (r) {
#line 592
    return (r);
  }
  {
#line 594
  res_options = instrum_getenv___9(ads___7, "RES_OPTIONS");
#line 595
  adns_res_options = instrum_getenv___9(ads___7, "ADNS_RES_OPTIONS");
#line 596
  ccf_options___9(ads___7, "RES_OPTIONS", -1, res_options);
#line 597
  ccf_options___9(ads___7, "ADNS_RES_OPTIONS", -1, adns_res_options);
#line 599
  readconfig___9(ads___7, "/etc/resolv.conf", 1);
#line 600
  readconfig___9(ads___7, "/etc/resolv-adns.conf", 0);
#line 601
  readconfigenv___9(ads___7, "RES_CONF");
#line 602
  readconfigenv___9(ads___7, "ADNS_RES_CONF");
#line 604
  readconfigenvtext___9(ads___7, "RES_CONF_TEXT");
#line 605
  readconfigenvtext___9(ads___7, "ADNS_RES_CONF_TEXT");
#line 607
  ccf_options___9(ads___7, "RES_OPTIONS", -1, res_options);
#line 608
  ccf_options___9(ads___7, "ADNS_RES_OPTIONS", -1, adns_res_options);
#line 610
  tmp = instrum_getenv___9(ads___7, "LOCALDOMAIN");
#line 610
  ccf_search___9(ads___7, "LOCALDOMAIN", -1, tmp);
#line 611
  tmp___0 = instrum_getenv___9(ads___7, "ADNS_LOCALDOMAIN");
#line 611
  ccf_search___9(ads___7, "ADNS_LOCALDOMAIN", -1, tmp___0);
  }
#line 613
  if (ads___7->configerrno) {
#line 613
    if (ads___7->configerrno != 22) {
      {
#line 614
      r = ads___7->configerrno;
#line 615
      init_abort___9(ads___7);
      }
#line 616
      return (r);
    }
  }
  {
#line 619
  r = init_finish___9(ads___7);
  }
#line 620
  if (r) {
#line 620
    return (r);
  }
  {
#line 622
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
#line 623
  *ads_r = ads___7;
  }
#line 624
  return (0);
}
}
#line 631 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static int init_strcfg___9(adns_state *ads_r , adns_initflags flags , adns_logcallbackfn *logfn ,
                           void *logfndata , char const   *configtext ) 
{ 
  adns_state ads___7 ;
  int r ;

  {
  {
#line 637
  r = init_begin___9(& ads___7, flags, logfn, logfndata);
  }
#line 638
  if (r) {
#line 638
    return (r);
  }
  {
#line 640
  readconfigtext___9(ads___7, configtext, "<supplied configuration text>");
  }
#line 641
  if (ads___7->configerrno) {
    {
#line 642
    r = ads___7->configerrno;
#line 643
    init_abort___9(ads___7);
    }
#line 644
    return (r);
  }
  {
#line 647
  r = init_finish___9(ads___7);
  }
#line 647
  if (r) {
#line 647
    return (r);
  }
  {
#line 648
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
#line 649
  *ads_r = ads___7;
  }
#line 650
  return (0);
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnslogres.c"
static char const   * const  progname___5  =    (char const   */* const  */)"adnslogres";
#line 69 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnslogres.c"
static char const   *config_text___8  ;
#line 76 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnslogres.c"
static void msg___4(char const   *fmt  , ...) 
{ 
  va_list al ;

  {
  {
#line 79
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
          progname___5);
#line 80
  __builtin_va_start(al, fmt);
#line 81
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           al);
#line 82
  __builtin_va_end(al);
#line 83
  fputc('\n', stderr);
  }
#line 84
  return;
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnslogres.c"
static void aargh___5(char const   *cause ) 
{ 
  char const   *why ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 87
  tmp = __errno_location();
#line 87
  tmp___0 = strerror(*tmp);
#line 87
  why = (char const   *)tmp___0;
  }
#line 88
  if (! why) {
#line 88
    why = "Unknown error";
  }
  {
#line 89
  tmp___1 = __errno_location();
#line 89
  msg___4("%s: %s (%d)", cause, why, *tmp___1);
#line 90
  exit(1);
  }
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnslogres.c"
static char buf___13[30]  ;
#line 96 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnslogres.c"
static char *ipaddr2domain___2(char *start , char **addr , char **rest ) 
{ 
  char *ptrs[5] ;
  int i ;
  char *tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
#line 101
  ptrs[0] = start;
  retry: 
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 103
    tmp___1 = __ctype_b_loc();
    }
#line 103
    if ((int const   )*(*tmp___1 + (int )((unsigned char )*(ptrs[0]))) & 2048) {
#line 103
      goto while_break;
    }
#line 104
    tmp___0 = ptrs[0];
#line 104
    (ptrs[0]) ++;
#line 104
    if (! *tmp___0) {
      {
#line 105
      strcpy((char */* __restrict  */)(buf___13), (char const   */* __restrict  */)"invalid.");
#line 106
      tmp = (char *)((void *)0);
#line 106
      *rest = tmp;
#line 106
      *addr = tmp;
      }
#line 107
      return (buf___13);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 109
  i = 1;
  {
#line 109
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 109
    if (! (i < 5)) {
#line 109
      goto while_break___0;
    }
#line 110
    ptrs[i] = ptrs[i - 1];
    {
#line 111
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 111
      tmp___2 = __ctype_b_loc();
#line 111
      tmp___3 = ptrs[i];
#line 111
      (ptrs[i]) ++;
      }
#line 111
      if (! ((int const   )*(*tmp___2 + (int )((unsigned char )*tmp___3)) & 2048)) {
#line 111
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 112
    if (i == 4) {
      {
#line 112
      tmp___4 = __ctype_b_loc();
      }
#line 112
      if ((int const   )*(*tmp___4 + (int )((unsigned char )*(ptrs[i] + -1))) & 8192) {
#line 112
        goto _L___0;
      } else {
#line 115
        ptrs[0] = ptrs[i] - 1;
#line 116
        goto retry;
      }
    } else
    _L___0: /* CIL Label */ 
#line 112
    if (i != 4) {
#line 112
      if ((int )*(ptrs[i] + -1) != 46) {
#line 115
        ptrs[0] = ptrs[i] - 1;
#line 116
        goto retry;
      } else {
#line 112
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 112
    if (ptrs[i] - ptrs[i - 1] > 4L) {
#line 115
      ptrs[0] = ptrs[i] - 1;
#line 116
      goto retry;
    }
#line 109
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 119
  sprintf((char */* __restrict  */)(buf___13), (char const   */* __restrict  */)"%.*s.%.*s.%.*s.%.*s.in-addr.arpa.",
          (int )((ptrs[4] - ptrs[3]) - 1L), ptrs[3], (int )((ptrs[3] - ptrs[2]) - 1L),
          ptrs[2], (int )((ptrs[2] - ptrs[1]) - 1L), ptrs[1], (int )((ptrs[1] - ptrs[0]) - 1L),
          ptrs[0]);
#line 124
  *addr = ptrs[0];
#line 125
  *rest = ptrs[4] - 1;
  }
#line 126
  return (buf___13);
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnslogres.c"
static void printline___2(FILE *outf , char *start , char *addr , char *rest , char *domain ) 
{ 
  int tmp ;

  {
#line 130
  if (domain) {
    {
#line 131
    fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)"%.*s%s%s",
            (int )(addr - start), start, domain, rest);
    }
  } else {
    {
#line 133
    fputs((char const   */* __restrict  */)start, (FILE */* __restrict  */)outf);
    }
  }
  {
#line 134
  tmp = ferror(outf);
  }
#line 134
  if (tmp) {
    {
#line 134
    aargh___5("write output");
    }
  }
#line 135
  return;
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnslogres.c"
static char buf___14[1024]  ;
#line 143 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnslogres.c"
static logline *readline___4(FILE *inf , adns_state adns , int opts ) 
{ 
  char *str ;
  logline *line ;
  size_t tmp ;
  void *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 148
  tmp___3 = fgets((char */* __restrict  */)(buf___14), 1024, (FILE */* __restrict  */)inf);
  }
#line 148
  if (tmp___3) {
    {
#line 149
    tmp = strlen((char const   *)(buf___14));
#line 149
    tmp___0 = malloc((sizeof(*line) + tmp) + 1UL);
#line 149
    str = (char *)tmp___0;
    }
#line 150
    if (! str) {
      {
#line 150
      aargh___5("malloc");
      }
    }
    {
#line 151
    line = (logline *)str;
#line 152
    line->next = (struct logline *)((void *)0);
#line 153
    line->start = str + sizeof(logline );
#line 154
    strcpy((char */* __restrict  */)line->start, (char const   */* __restrict  */)(buf___14));
#line 155
    str = ipaddr2domain___2(line->start, & line->addr, & line->rest);
    }
#line 156
    if (opts & 1) {
#line 157
      if (line->addr) {
#line 157
        tmp___1 = (char const   *)line->addr;
      } else {
#line 157
        tmp___1 = "";
      }
      {
#line 157
      msg___4("submitting %.*s -> %s", (int )(line->rest - line->addr), tmp___1, str);
      }
    }
    {
#line 158
    tmp___2 = adns_submit(adns, (char const   *)str, (adns_rrtype )65548, (adns_queryflags )256,
                          (void *)0, & line->query);
    }
#line 158
    if (tmp___2) {
      {
#line 161
      aargh___5("adns_submit");
      }
    }
#line 162
    return (line);
  }
  {
#line 164
  tmp___4 = feof(inf);
  }
#line 164
  if (! tmp___4) {
    {
#line 165
    aargh___5("fgets");
    }
  }
#line 166
  return ((logline *)((void *)0));
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnslogres.c"
static void proclog___4(FILE *inf , FILE *outf , int maxpending , int opts ) 
{ 
  int eof ;
  int err ;
  int len ;
  adns_state adns ;
  adns_answer *answer ;
  logline *head ;
  logline *tail ;
  logline *line ;
  adns_initflags initflags___3 ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 176
  if (opts & 1) {
#line 176
    initflags___3 = (adns_initflags )8;
  } else {
#line 176
    initflags___3 = (adns_initflags )0;
  }
#line 177
  if (config_text___8) {
    {
#line 178
    tmp = __errno_location();
#line 178
    *tmp = adns_init_strcfg(& adns, initflags___3, stderr, config_text___8);
    }
  } else {
    {
#line 180
    tmp___0 = __errno_location();
#line 180
    *tmp___0 = adns_init(& adns, initflags___3, (FILE *)0);
    }
  }
  {
#line 182
  tmp___1 = __errno_location();
  }
#line 182
  if (*tmp___1) {
    {
#line 182
    aargh___5("adns_init");
    }
  }
  {
#line 183
  tail = readline___4(inf, adns, opts);
#line 183
  head = tail;
#line 184
  len = 1;
#line 184
  eof = 0;
  }
  {
#line 185
  while (1) {
    while_continue: /* CIL Label */ ;
#line 185
    if (! head) {
#line 185
      goto while_break;
    }
    {
#line 186
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 186
      if (! head) {
#line 186
        goto while_break___0;
      }
#line 187
      if (opts & 1) {
#line 188
        if (head->addr) {
#line 188
          tmp___2 = (char const   *)head->addr;
        } else {
#line 188
          tmp___2 = "";
        }
        {
#line 188
        msg___4("%d in queue; checking %.*s", len, (int )(head->rest - head->addr),
                tmp___2);
        }
      }
#line 190
      if (eof) {
#line 190
        goto _L;
      } else
#line 190
      if (len >= maxpending) {
        _L: /* CIL Label */ 
#line 191
        if (opts & 2) {
          {
#line 192
          err = adns_wait_poll(adns, & head->query, & answer, (void **)((void *)0));
          }
        } else {
          {
#line 194
          err = adns_wait(adns, & head->query, & answer, (void **)((void *)0));
          }
        }
      } else {
        {
#line 196
        err = adns_check(adns, & head->query, & answer, (void **)((void *)0));
        }
      }
#line 198
      if (err == 11) {
#line 198
        goto while_break___0;
      }
#line 199
      if (err) {
        {
#line 200
        tmp___3 = strerror(err);
#line 200
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: adns_wait/check: %s",
                progname___5, tmp___3);
#line 201
        exit(1);
        }
      }
#line 203
      if ((unsigned int )answer->status == 0U) {
#line 203
        tmp___4 = *(answer->rrs.str);
      } else {
#line 203
        tmp___4 = (char *)((void *)0);
      }
      {
#line 203
      printline___2(outf, head->start, head->addr, head->rest, tmp___4);
#line 205
      line = head;
#line 205
      head = head->next;
#line 206
      free((void *)line);
#line 207
      free((void *)answer);
#line 208
      len --;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 210
    if (! eof) {
      {
#line 211
      line = readline___4(inf, adns, opts);
      }
#line 212
      if (line) {
#line 213
        if (! head) {
#line 213
          head = line;
        } else {
#line 214
          tail->next = line;
        }
#line 215
        tail = line;
#line 215
        len ++;
      } else {
#line 217
        eof = 1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 221
  adns_finish(adns);
  }
#line 222
  return;
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnslogres.c"
static void printhelp___4(FILE *file ) 
{ 


  {
  {
#line 225
  fputs((char const   */* __restrict  */)"usage: adnslogres [<options>] [<logfile>]\n       adnslogres --version|--help\noptions: -c <concurrency>  set max number of outstanding queries\n         -p                use poll(2) instead of select(2)\n         -d                turn on debugging\n         -C <config>       use instead of contents of resolv.conf\n",
        (FILE */* __restrict  */)stdout);
  }
#line 232
  return;
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnslogres.c"
static void usage___7(void) 
{ 


  {
  {
#line 235
  printhelp___4(stderr);
#line 236
  exit(1);
  }
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c"
static void tcp_close___9(adns_state ads___7 ) 
{ 
  int serv ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 48
  serv = ads___7->tcpserver;
#line 49
  close(ads___7->tcpsocket);
#line 50
  ads___7->tcpsocket = -1;
#line 51
  tmp___0 = 0;
#line 51
  ads___7->tcpsend.used = tmp___0;
#line 51
  tmp = tmp___0;
#line 51
  ads___7->tcprecv_skip = tmp;
#line 51
  ads___7->tcprecv.used = tmp;
  }
#line 52
  return;
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c"
static void tcp_connected___9(adns_state ads___7 , struct timeval now ) 
{ 
  adns_query qu ;
  adns_query nqu ;

  {
  {
#line 76
  adns__debug(ads___7, ads___7->tcpserver, (adns_query )0, "TCP connected");
#line 77
  ads___7->tcpstate = (enum adns__tcpstate )2;
#line 78
  qu = ads___7->tcpw.head;
  }
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (qu) {
#line 78
      if (! ((unsigned int )ads___7->tcpstate == 2U)) {
#line 78
        goto while_break;
      }
    } else {
#line 78
      goto while_break;
    }
#line 79
    nqu = qu->next;
#line 80
    if (! ((unsigned int )qu->state == 1U)) {
      {
#line 80
      __assert_fail("qu->state == query_tcpw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c",
                    80U, "tcp_connected");
      }
    }
    {
#line 81
    adns__querysend_tcp(qu, now);
#line 78
    qu = nqu;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c"
static void tcp_broken_events___9(adns_state ads___7 ) 
{ 
  adns_query qu ;
  adns_query nqu ;

  {
#line 88
  if (! ((unsigned int )ads___7->tcpstate == 3U)) {
    {
#line 88
    __assert_fail("ads->tcpstate == server_broken", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c",
                  88U, "tcp_broken_events");
    }
  }
#line 89
  qu = ads___7->tcpw.head;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! qu) {
#line 89
      goto while_break;
    }
#line 90
    nqu = qu->next;
#line 91
    if (! ((unsigned int )qu->state == 1U)) {
      {
#line 91
      __assert_fail("qu->state == query_tcpw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c",
                    91U, "tcp_broken_events");
      }
    }
#line 92
    if (qu->retries > ads___7->nservers) {
      {
#line 93
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 93
        if (qu->back) {
#line 93
          (qu->back)->next = qu->next;
        } else {
#line 93
          ads___7->tcpw.head = qu->next;
        }
#line 93
        if (qu->next) {
#line 93
          (qu->next)->back = qu->back;
        } else {
#line 93
          ads___7->tcpw.tail = qu->back;
        }
#line 93
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 94
      adns__query_fail(qu, (adns_status )31);
      }
    }
#line 89
    qu = nqu;
  }
  while_break: /* CIL Label */ ;
  }
#line 97
  ads___7->tcpstate = (enum adns__tcpstate )0;
#line 98
  return;
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c"
static void inter_immed___9(struct timeval **tv_io , struct timeval *tvbuf ) 
{ 
  struct timeval *rbuf ;
  __suseconds_t tmp ;

  {
#line 174
  if (! tv_io) {
#line 174
    return;
  }
#line 176
  rbuf = *tv_io;
#line 177
  if (! rbuf) {
#line 177
    rbuf = tvbuf;
#line 177
    *tv_io = rbuf;
  }
#line 179
  tmp = (__suseconds_t )0;
#line 179
  rbuf->tv_usec = tmp;
#line 179
  rbuf->tv_sec = tmp;
#line 180
  return;
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c"
static void inter_maxto___9(struct timeval **tv_io , struct timeval *tvbuf , struct timeval maxto ) 
{ 
  struct timeval *rbuf ;
  int tmp ;

  {
#line 186
  if (! tv_io) {
#line 186
    return;
  }
#line 187
  rbuf = *tv_io;
#line 188
  if (! rbuf) {
#line 189
    *tvbuf = maxto;
#line 189
    *tv_io = tvbuf;
  } else {
#line 191
    if (rbuf->tv_sec == maxto.tv_sec) {
#line 191
      tmp = rbuf->tv_usec > maxto.tv_usec;
    } else {
#line 191
      tmp = rbuf->tv_sec > maxto.tv_sec;
    }
#line 191
    if (tmp) {
#line 191
      *rbuf = maxto;
    }
  }
#line 195
  return;
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c"
static void inter_maxtoabs___9(struct timeval **tv_io , struct timeval *tvbuf , struct timeval now ,
                               struct timeval maxtime ) 
{ 
  ldiv_t dr ;

  {
#line 204
  if (! tv_io) {
#line 204
    return;
  }
  {
#line 205
  maxtime.tv_sec -= now.tv_sec + 2L;
#line 206
  maxtime.tv_usec -= now.tv_usec - 2000000L;
#line 207
  dr = ldiv(maxtime.tv_usec, 1000000L);
#line 208
  maxtime.tv_sec += dr.quot;
#line 209
  maxtime.tv_usec -= dr.quot * 1000000L;
  }
#line 210
  if (maxtime.tv_sec < 0L) {
#line 210
    maxtime.tv_usec = (__suseconds_t )0;
#line 210
    maxtime.tv_sec = maxtime.tv_usec;
  }
  {
#line 211
  inter_maxto___9(tv_io, tvbuf, maxtime);
  }
#line 212
  return;
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c"
static void timeouts_queue___9(adns_state ads___7 , int act , struct timeval **tv_io ,
                               struct timeval *tvbuf , struct timeval now , struct query_queue *queue ) 
{ 
  adns_query qu ;
  adns_query nqu ;
  int tmp ;

  {
#line 219
  qu = queue->head;
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if (! qu) {
#line 219
      goto while_break;
    }
#line 220
    nqu = qu->next;
#line 221
    if (now.tv_sec == qu->timeout.tv_sec) {
#line 221
      tmp = now.tv_usec > qu->timeout.tv_usec;
    } else {
#line 221
      tmp = now.tv_sec > qu->timeout.tv_sec;
    }
#line 221
    if (tmp) {
#line 224
      if (! act) {
        {
#line 224
        inter_immed___9(tv_io, tvbuf);
        }
#line 224
        return;
      }
      {
#line 225
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 225
        if (qu->back) {
#line 225
          (qu->back)->next = qu->next;
        } else {
#line 225
          queue->head = qu->next;
        }
#line 225
        if (qu->next) {
#line 225
          (qu->next)->back = qu->back;
        } else {
#line 225
          queue->tail = qu->back;
        }
#line 225
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 226
      if ((unsigned int )qu->state != 0U) {
        {
#line 227
        adns__query_fail(qu, (adns_status )30);
        }
      } else {
        {
#line 229
        adns__query_send(qu, now);
        }
      }
#line 231
      nqu = queue->head;
    } else {
      {
#line 222
      inter_maxtoabs___9(tv_io, tvbuf, now, qu->timeout);
      }
    }
#line 219
    qu = nqu;
  }
  while_break: /* CIL Label */ ;
  }
#line 234
  return;
}
}
#line 236 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c"
static void tcp_events___9(adns_state ads___7 , int act , struct timeval **tv_io ,
                           struct timeval *tvbuf , struct timeval now ) 
{ 
  int tmp ;

  {
  {
#line 239
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 241
    if ((unsigned int )ads___7->tcpstate == 3U) {
#line 241
      goto case_3;
    }
#line 244
    if ((unsigned int )ads___7->tcpstate == 0U) {
#line 244
      goto case_0;
    }
#line 249
    if ((unsigned int )ads___7->tcpstate == 2U) {
#line 249
      goto case_2;
    }
#line 256
    if ((unsigned int )ads___7->tcpstate == 1U) {
#line 256
      goto case_1;
    }
#line 275
    goto switch_default___0;
    case_3: /* CIL Label */ 
#line 242
    if (! act) {
      {
#line 242
      inter_immed___9(tv_io, tvbuf);
      }
#line 242
      return;
    }
    {
#line 243
    tcp_broken_events___9(ads___7);
    }
    case_0: /* CIL Label */ 
#line 245
    if (! ads___7->tcpw.head) {
#line 245
      return;
    }
#line 246
    if (! act) {
      {
#line 246
      inter_immed___9(tv_io, tvbuf);
      }
#line 246
      return;
    }
    {
#line 247
    adns__tcp_tryconnect(ads___7, now);
    }
#line 248
    goto switch_break;
    case_2: /* CIL Label */ 
#line 250
    if (ads___7->tcpw.head) {
#line 250
      return;
    }
#line 251
    if (! ads___7->tcptimeout.tv_sec) {
#line 252
      if (! (! ads___7->tcptimeout.tv_usec)) {
        {
#line 252
        __assert_fail("!ads->tcptimeout.tv_usec", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c",
                      252U, "tcp_events");
        }
      }
      {
#line 253
      ads___7->tcptimeout = now;
#line 254
      timevaladd___18(& ads___7->tcptimeout, 30000L);
      }
    }
    case_1: /* CIL Label */ 
#line 257
    if (! act) {
      {
#line 258
      inter_maxtoabs___9(tv_io, tvbuf, now, ads___7->tcptimeout);
      }
#line 259
      return;
    } else {
#line 257
      if (now.tv_sec == ads___7->tcptimeout.tv_sec) {
#line 257
        tmp = now.tv_usec > ads___7->tcptimeout.tv_usec;
      } else {
#line 257
        tmp = now.tv_sec > ads___7->tcptimeout.tv_sec;
      }
#line 257
      if (! tmp) {
        {
#line 258
        inter_maxtoabs___9(tv_io, tvbuf, now, ads___7->tcptimeout);
        }
#line 259
        return;
      }
    }
    {
#line 263
    if ((unsigned int )ads___7->tcpstate == 1U) {
#line 263
      goto case_1___0;
    }
#line 266
    if ((unsigned int )ads___7->tcpstate == 2U) {
#line 266
      goto case_2___0;
    }
#line 270
    goto switch_default;
    case_1___0: /* CIL Label */ 
    {
#line 264
    adns__tcp_broken(ads___7, "unable to make connection", "timed out");
    }
#line 265
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 267
    tcp_close___9(ads___7);
#line 268
    ads___7->tcpstate = (enum adns__tcpstate )0;
    }
#line 269
    return;
    switch_default: /* CIL Label */ 
    {
#line 271
    abort();
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 274
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
#line 276
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 279
  return;
}
}
#line 516 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c"
static void fd_event___9(adns_state ads___7 , int fd , int revent , int pollflag ,
                         int maxfd , fd_set const   *fds , int (*func)(adns_state  ,
                                                                       int fd , struct timeval  const  *now ) ,
                         struct timeval now , int *r_r ) 
{ 
  int r ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 524
  if (! (revent & pollflag)) {
#line 524
    return;
  }
#line 525
  if (fds) {
#line 525
    if (fd < maxfd) {
#line 525
      if (! ((fds->__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
#line 525
        return;
      }
    } else {
#line 525
      return;
    }
  }
  {
#line 526
  r = (*func)(ads___7, fd, (struct timeval  const  *)(& now));
  }
#line 527
  if (r) {
#line 528
    if (r_r) {
#line 529
      *r_r = r;
    } else {
      {
#line 531
      tmp = __errno_location();
#line 531
      tmp___0 = strerror(*tmp);
#line 531
      adns__diag(ads___7, -1, (adns_query )0, "process fd failed after select: %s",
                 tmp___0);
#line 533
      adns_globalsystemfailure(ads___7);
      }
    }
  }
#line 536
  return;
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c"
static void checkc_query_alloc___9(adns_state ads___7 , adns_query qu ) 
{ 
  allocnode *an ;
  int tmp ;

  {
#line 58
  if (qu->allocations.head) {
#line 58
    if (! (! (qu->allocations.head)->back)) {
      {
#line 58
      __assert_fail("! (qu->allocations).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                    59U, "checkc_query_alloc");
      }
    }
#line 58
    an = qu->allocations.head;
    {
#line 58
    while (1) {
      while_continue: /* CIL Label */ ;
#line 58
      if (! an) {
#line 58
        goto while_break;
      }
#line 58
      if (an->next) {
#line 58
        tmp = (unsigned long )an == (unsigned long )(an->next)->back;
      } else {
#line 58
        tmp = (unsigned long )an == (unsigned long )qu->allocations.tail;
      }
#line 58
      if (! tmp) {
        {
#line 58
        __assert_fail("(an)-> next ? (an) == (an)-> next-> back : (an) == (qu->allocations).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      59U, "checkc_query_alloc");
        }
      }
#line 58
      an = an->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 60
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c"
static void checkc_query___9(adns_state ads___7 , adns_query qu ) 
{ 
  adns_query child ;

  {
#line 65
  if (! (qu->udpnextserver < ads___7->nservers)) {
    {
#line 65
    __assert_fail("qu->udpnextserver < ads->nservers", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  65U, "checkc_query");
    }
  }
#line 66
  if (! (! (qu->udpsent & (0xffffffffffffffffUL << ads___7->nservers)))) {
    {
#line 66
    __assert_fail("!(qu->udpsent & (~0UL << ads->nservers))", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  66U, "checkc_query");
    }
  }
#line 67
  if (! (qu->search_pos <= ads___7->nsearchlist)) {
    {
#line 67
    __assert_fail("qu->search_pos <= ads->nsearchlist", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  67U, "checkc_query");
    }
  }
#line 68
  if (qu->parent) {
    {
#line 68
    while (1) {
      while_continue: /* CIL Label */ ;
#line 68
      child = (qu->parent)->children.head;
      {
#line 68
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 68
        if (! ((unsigned long )child != (unsigned long )qu)) {
#line 68
          goto while_break___0;
        }
#line 68
        if (! child) {
          {
#line 68
          __assert_fail("(child)", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                        68U, "checkc_query");
          }
        }
#line 68
        child = child->siblings.next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 68
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 69
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c"
static void checkc_notcpbuf___9(adns_state ads___7 ) 
{ 


  {
#line 72
  if (! (! ads___7->tcpsend.used)) {
    {
#line 72
    __assert_fail("!ads->tcpsend.used", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  72U, "checkc_notcpbuf");
    }
  }
#line 73
  if (! (! ads___7->tcprecv.used)) {
    {
#line 73
    __assert_fail("!ads->tcprecv.used", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  73U, "checkc_notcpbuf");
    }
  }
#line 74
  if (! (! ads___7->tcprecv_skip)) {
    {
#line 74
    __assert_fail("!ads->tcprecv_skip", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  74U, "checkc_notcpbuf");
    }
  }
#line 75
  return;
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c"
static void checkc_global___9(adns_state ads___7 ) 
{ 
  int i ;

  {
#line 80
  if (! (ads___7->udpsocket >= 0)) {
    {
#line 80
    __assert_fail("ads->udpsocket >= 0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  80U, "checkc_global");
    }
  }
#line 82
  i = 0;
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! (i < ads___7->nsortlist)) {
#line 82
      goto while_break;
    }
#line 83
    if (! (! (ads___7->sortlist[i].base.s_addr & ~ ads___7->sortlist[i].mask.s_addr))) {
      {
#line 83
      __assert_fail("!(ads->sortlist[i].base.s_addr & ~ads->sortlist[i].mask.s_addr)",
                    "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                    83U, "checkc_global");
      }
    }
#line 82
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  if (ads___7->tcpserver >= 0) {
#line 85
    if (! (ads___7->tcpserver < ads___7->nservers)) {
      {
#line 85
      __assert_fail("ads->tcpserver >= 0 && ads->tcpserver < ads->nservers", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                    85U, "checkc_global");
      }
    }
  } else {
    {
#line 85
    __assert_fail("ads->tcpserver >= 0 && ads->tcpserver < ads->nservers", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  85U, "checkc_global");
    }
  }
  {
#line 88
  if ((unsigned int )ads___7->tcpstate == 1U) {
#line 88
    goto case_1;
  }
#line 93
  if ((unsigned int )ads___7->tcpstate == 3U) {
#line 93
    goto case_3;
  }
#line 93
  if ((unsigned int )ads___7->tcpstate == 0U) {
#line 93
    goto case_3;
  }
#line 97
  if ((unsigned int )ads___7->tcpstate == 2U) {
#line 97
    goto case_2;
  }
#line 101
  goto switch_default;
  case_1: /* CIL Label */ 
#line 89
  if (! (ads___7->tcpsocket >= 0)) {
    {
#line 89
    __assert_fail("ads->tcpsocket >= 0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  89U, "checkc_global");
    }
  }
  {
#line 90
  checkc_notcpbuf___9(ads___7);
  }
#line 91
  goto switch_break;
  case_3: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 94
  if (! (ads___7->tcpsocket == -1)) {
    {
#line 94
    __assert_fail("ads->tcpsocket == -1", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  94U, "checkc_global");
    }
  }
  {
#line 95
  checkc_notcpbuf___9(ads___7);
  }
#line 96
  goto switch_break;
  case_2: /* CIL Label */ 
#line 98
  if (! (ads___7->tcpsocket >= 0)) {
    {
#line 98
    __assert_fail("ads->tcpsocket >= 0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  98U, "checkc_global");
    }
  }
#line 99
  if (! (ads___7->tcprecv_skip <= ads___7->tcprecv.used)) {
    {
#line 99
    __assert_fail("ads->tcprecv_skip <= ads->tcprecv.used", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  99U, "checkc_global");
    }
  }
#line 100
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 102
  __assert_fail("!\"ads->tcpstate value\"", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                102U, "checkc_global");
  }
  switch_break: /* CIL Label */ ;
  }
#line 105
  if (! ads___7->searchlist) {
#line 105
    if (! (! ads___7->nsearchlist)) {
      {
#line 105
      __assert_fail("ads->searchlist || !ads->nsearchlist", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                    105U, "checkc_global");
      }
    }
  }
#line 106
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c"
static void checkc_queue_udpw___9(adns_state ads___7 ) 
{ 
  adns_query qu ;
  int tmp ;

  {
#line 111
  if (ads___7->udpw.head) {
#line 111
    if (! (! (ads___7->udpw.head)->back)) {
      {
#line 111
      __assert_fail("! (ads->udpw).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                    118U, "checkc_queue_udpw");
      }
    }
#line 111
    qu = ads___7->udpw.head;
    {
#line 111
    while (1) {
      while_continue: /* CIL Label */ ;
#line 111
      if (! qu) {
#line 111
        goto while_break;
      }
#line 111
      if (qu->next) {
#line 111
        tmp = (unsigned long )qu == (unsigned long )(qu->next)->back;
      } else {
#line 111
        tmp = (unsigned long )qu == (unsigned long )ads___7->udpw.tail;
      }
#line 111
      if (! tmp) {
        {
#line 111
        __assert_fail("(qu)-> next ? (qu) == (qu)-> next-> back : (qu) == (ads->udpw).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! ((unsigned int )qu->state == 0U)) {
        {
#line 111
        __assert_fail("qu->state==query_tosend", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! (qu->retries <= 15)) {
        {
#line 111
        __assert_fail("qu->retries <= 15", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! qu->udpsent) {
        {
#line 111
        __assert_fail("qu->udpsent", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! qu->children.head) {
#line 111
        if (! (! qu->children.tail)) {
          {
#line 111
          __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                        118U, "checkc_queue_udpw");
          }
        }
      } else {
        {
#line 111
        __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
      {
#line 111
      checkc_query___9(ads___7, qu);
#line 111
      checkc_query_alloc___9(ads___7, qu);
#line 111
      qu = qu->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 119
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c"
static void checkc_queue_tcpw___9(adns_state ads___7 ) 
{ 
  adns_query qu ;
  int tmp ;

  {
#line 124
  if (ads___7->tcpw.head) {
#line 124
    if (! (! (ads___7->tcpw.head)->back)) {
      {
#line 124
      __assert_fail("! (ads->tcpw).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                    130U, "checkc_queue_tcpw");
      }
    }
#line 124
    qu = ads___7->tcpw.head;
    {
#line 124
    while (1) {
      while_continue: /* CIL Label */ ;
#line 124
      if (! qu) {
#line 124
        goto while_break;
      }
#line 124
      if (qu->next) {
#line 124
        tmp = (unsigned long )qu == (unsigned long )(qu->next)->back;
      } else {
#line 124
        tmp = (unsigned long )qu == (unsigned long )ads___7->tcpw.tail;
      }
#line 124
      if (! tmp) {
        {
#line 124
        __assert_fail("(qu)-> next ? (qu) == (qu)-> next-> back : (qu) == (ads->tcpw).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
#line 124
      if (! ((unsigned int )qu->state == 1U)) {
        {
#line 124
        __assert_fail("qu->state==query_tcpw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
#line 124
      if (! qu->children.head) {
#line 124
        if (! (! qu->children.tail)) {
          {
#line 124
          __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                        130U, "checkc_queue_tcpw");
          }
        }
      } else {
        {
#line 124
        __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
#line 124
      if (! (qu->retries <= ads___7->nservers + 1)) {
        {
#line 124
        __assert_fail("qu->retries <= ads->nservers+1", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
      {
#line 124
      checkc_query___9(ads___7, qu);
#line 124
      checkc_query_alloc___9(ads___7, qu);
#line 124
      qu = qu->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 131
  return;
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c"
static void checkc_queue_childw___9(adns_state ads___7 ) 
{ 
  adns_query parent ;
  adns_query child ;
  int tmp ;
  int tmp___0 ;

  {
#line 136
  if (ads___7->childw.head) {
#line 136
    if (! (! (ads___7->childw.head)->back)) {
      {
#line 136
      __assert_fail("! (ads->childw).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                    145U, "checkc_queue_childw");
      }
    }
#line 136
    parent = ads___7->childw.head;
    {
#line 136
    while (1) {
      while_continue: /* CIL Label */ ;
#line 136
      if (! parent) {
#line 136
        goto while_break;
      }
#line 136
      if (parent->next) {
#line 136
        tmp = (unsigned long )parent == (unsigned long )(parent->next)->back;
      } else {
#line 136
        tmp = (unsigned long )parent == (unsigned long )ads___7->childw.tail;
      }
#line 136
      if (! tmp) {
        {
#line 136
        __assert_fail("(parent)-> next ? (parent) == (parent)-> next-> back : (parent) == (ads->childw).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      145U, "checkc_queue_childw");
        }
      }
#line 136
      if (! ((unsigned int )parent->state == 2U)) {
        {
#line 136
        __assert_fail("parent->state == query_childw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      145U, "checkc_queue_childw");
        }
      }
#line 136
      if (! parent->children.head) {
        {
#line 136
        __assert_fail("parent->children.head", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      145U, "checkc_queue_childw");
        }
      }
#line 136
      if (parent->children.head) {
#line 136
        if (! (! (parent->children.head)->siblings.back)) {
          {
#line 136
          __assert_fail("! (parent->children).head->siblings. back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                        145U, "checkc_queue_childw");
          }
        }
#line 136
        child = parent->children.head;
        {
#line 136
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 136
          if (! child) {
#line 136
            goto while_break___0;
          }
#line 136
          if (child->siblings.next) {
#line 136
            tmp___0 = (unsigned long )child == (unsigned long )(child->siblings.next)->siblings.back;
          } else {
#line 136
            tmp___0 = (unsigned long )child == (unsigned long )parent->children.tail;
          }
#line 136
          if (! tmp___0) {
            {
#line 136
            __assert_fail("(child)->siblings. next ? (child) == (child)->siblings. next->siblings. back : (child) == (parent->children).tail",
                          "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                          145U, "checkc_queue_childw");
            }
          }
#line 136
          if (! ((unsigned long )child->parent == (unsigned long )parent)) {
            {
#line 136
            __assert_fail("child->parent == parent", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                          145U, "checkc_queue_childw");
            }
          }
#line 136
          if (! ((unsigned int )child->state != 3U)) {
            {
#line 136
            __assert_fail("child->state != query_done", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                          145U, "checkc_queue_childw");
            }
          }
#line 136
          child = child->siblings.next;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 136
      checkc_query___9(ads___7, parent);
#line 136
      checkc_query_alloc___9(ads___7, parent);
#line 136
      parent = parent->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 146
  return;
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c"
static void checkc_queue_output___9(adns_state ads___7 ) 
{ 
  adns_query qu ;
  int tmp ;

  {
#line 151
  if (ads___7->output.head) {
#line 151
    if (! (! (ads___7->output.head)->back)) {
      {
#line 151
      __assert_fail("! (ads->output).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                    157U, "checkc_queue_output");
      }
    }
#line 151
    qu = ads___7->output.head;
    {
#line 151
    while (1) {
      while_continue: /* CIL Label */ ;
#line 151
      if (! qu) {
#line 151
        goto while_break;
      }
#line 151
      if (qu->next) {
#line 151
        tmp = (unsigned long )qu == (unsigned long )(qu->next)->back;
      } else {
#line 151
        tmp = (unsigned long )qu == (unsigned long )ads___7->output.tail;
      }
#line 151
      if (! tmp) {
        {
#line 151
        __assert_fail("(qu)-> next ? (qu) == (qu)-> next-> back : (qu) == (ads->output).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! ((unsigned int )qu->state == 3U)) {
        {
#line 151
        __assert_fail("qu->state == query_done", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! qu->children.head) {
#line 151
        if (! (! qu->children.tail)) {
          {
#line 151
          __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                        157U, "checkc_queue_output");
          }
        }
      } else {
        {
#line 151
        __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! (! qu->parent)) {
        {
#line 151
        __assert_fail("!qu->parent", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! qu->allocations.head) {
#line 151
        if (! (! qu->allocations.tail)) {
          {
#line 151
          __assert_fail("!qu->allocations.head && !qu->allocations.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                        157U, "checkc_queue_output");
          }
        }
      } else {
        {
#line 151
        __assert_fail("!qu->allocations.head && !qu->allocations.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
      {
#line 151
      checkc_query___9(ads___7, qu);
#line 151
      qu = qu->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 158
  return;
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnstest.c"
static struct myctx *mcs___1  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnstest.c"
static adns_state ads___5  ;
#line 50 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnstest.c"
static adns_rrtype *types_a___1  ;
#line 52
static  __attribute__((__noreturn__)) void quitnow___2(int rc ) ;
#line 53
static  __attribute__((__noreturn__)) void quitnow___2(int rc ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnstest.c"
static void quitnow___2(int rc ) 
{ 


  {
  {
#line 54
  free((void *)mcs___1);
#line 55
  free((void *)types_a___1);
  }
#line 56
  if (ads___5) {
    {
#line 56
    adns_finish(ads___5);
    }
  }
  {
#line 58
  exit(rc);
  }
}
}
#line 71
static  __attribute__((__noreturn__)) void failure_status___1(char const   *what ,
                                                              adns_status st ) ;
#line 72
static  __attribute__((__noreturn__)) void failure_status___1(char const   *what ,
                                                              adns_status st ) ;
#line 72 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnstest.c"
static void failure_status___1(char const   *what , adns_status st ) 
{ 
  char const   *tmp ;

  {
  {
#line 73
  tmp = adns_strerror(st);
#line 73
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adns failure: %s: %s\n",
          what, tmp);
#line 74
  quitnow___2(2);
  }
}
}
#line 77
static  __attribute__((__noreturn__)) void failure_errno___1(char const   *what ,
                                                             int errnoval ) ;
#line 78
static  __attribute__((__noreturn__)) void failure_errno___1(char const   *what ,
                                                             int errnoval ) ;
#line 78 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnstest.c"
static void failure_errno___1(char const   *what , int errnoval ) 
{ 


  {
  {
#line 82
  if (errnoval == 22) {
#line 82
    goto case_22;
  }
#line 83
  if (errnoval == 4) {
#line 83
    goto case_4;
  }
#line 84
  if (errnoval == 3) {
#line 84
    goto case_3;
  }
#line 85
  if (errnoval == 11) {
#line 85
    goto case_11;
  }
#line 86
  if (errnoval == 38) {
#line 86
    goto case_38;
  }
#line 87
  if (errnoval == 34) {
#line 87
    goto case_34;
  }
#line 89
  goto switch_default;
  case_22: /* CIL Label */ 
  {
#line 82
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adns failure: %s: errno=EINVAL\n",
          what);
  }
#line 82
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 83
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adns failure: %s: errno=EINTR\n",
          what);
  }
#line 83
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 84
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adns failure: %s: errno=ESRCH\n",
          what);
  }
#line 84
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 85
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adns failure: %s: errno=EAGAIN\n",
          what);
  }
#line 85
  goto switch_break;
  case_38: /* CIL Label */ 
  {
#line 86
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adns failure: %s: errno=ENOSYS\n",
          what);
  }
#line 86
  goto switch_break;
  case_34: /* CIL Label */ 
  {
#line 87
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adns failure: %s: errno=ERANGE\n",
          what);
  }
#line 87
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 89
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adns failure: %s: errno=%d\n",
          what, errnoval);
  }
#line 89
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 91
  quitnow___2(2);
  }
}
}
#line 94
static  __attribute__((__noreturn__)) void usageerr___5(char const   *why ) ;
#line 95
static  __attribute__((__noreturn__)) void usageerr___5(char const   *why ) ;
#line 95 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnstest.c"
static void usageerr___5(char const   *why ) 
{ 


  {
  {
#line 96
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad usage: %s\nusage: adnstest [-<initflagsnum>[,<owninitflags>]] [/<initstring>]\n              [ :<typenum>,... ]\n              [ [<queryflagsnum>[,<ownqueryflags>]/]<domain> ... ]\ninitflags:   p  use poll(2) instead of select(2)\n             s  use adns_wait with specified query, instead of 0\nqueryflags:  a  print status abbrevs instead of strings\nexit status:  0 ok (though some queries may have failed)\n              1 used by test harness to indicate test failed\n              2 unable to submit or init or some such\n              3 unexpected failure\n              4 usage error\n              5 operation not supported on this system\n",
          why);
#line 111
  quitnow___2(4);
  }
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnstest.c"
static adns_rrtype const   defaulttypes___1[16]  = 
#line 114
  {      (adns_rrtype const   )1,      (adns_rrtype const   )2,      (adns_rrtype const   )5,      (adns_rrtype const   )6, 
        (adns_rrtype const   )12,      (adns_rrtype const   )13,      (adns_rrtype const   )15,      (adns_rrtype const   )16, 
        (adns_rrtype const   )17,      (adns_rrtype const   )65537,      (adns_rrtype const   )65538,      (adns_rrtype const   )65548, 
        (adns_rrtype const   )65551,      (adns_rrtype const   )131078,      (adns_rrtype const   )131089,      (adns_rrtype const   )0};
#line 136 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnstest.c"
static void dumptype___1(adns_status ri , char const   *rrtn , char const   *fmtn ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
#line 137
  if (ri) {
    {
#line 137
    tmp = adns_strerror(ri);
#line 137
    tmp___0 = tmp;
    }
  } else {
#line 137
    tmp___0 = "";
  }
#line 137
  if (ri) {
#line 137
    tmp___1 = " ";
  } else {
#line 137
    tmp___1 = "";
  }
#line 137
  if (ri) {
#line 137
    tmp___3 = "?";
  } else {
#line 137
    if (fmtn) {
#line 137
      tmp___2 = fmtn;
    } else {
#line 137
      tmp___2 = "-";
    }
#line 137
    tmp___3 = tmp___2;
  }
#line 137
  if (! ri) {
#line 137
    if (rrtn) {
#line 137
      tmp___4 = rrtn;
    } else {
#line 137
      tmp___4 = "?";
    }
  } else {
#line 137
    tmp___4 = "?";
  }
  {
#line 137
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s(%s)%s%s",
          tmp___4, tmp___3, tmp___1, tmp___0);
  }
#line 140
  return;
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnstest.c"
static void fdom_split___1(char const   *fdom , char const   **dom_r , int *qf_r ,
                           char *ownflags , int ownflags_l ) 
{ 
  int qf ;
  char *ep ;
  unsigned long tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 147
  tmp = strtoul((char const   */* __restrict  */)fdom, (char **/* __restrict  */)(& ep),
                0);
#line 147
  qf = (int )tmp;
  }
#line 148
  if ((int )*ep == 44) {
    {
#line 148
    tmp___2 = strchr((char const   *)ep, '/');
    }
#line 148
    if (tmp___2) {
#line 149
      ep ++;
      {
#line 150
      while (1) {
        while_continue: /* CIL Label */ ;
#line 150
        if (! ((int )*ep != 47)) {
#line 150
          goto while_break;
        }
#line 151
        ownflags_l --;
#line 151
        if (ownflags_l <= 0) {
          {
#line 151
          fputs((char const   */* __restrict  */)"too many flags\n", (FILE */* __restrict  */)stderr);
#line 151
          quitnow___2(3);
          }
        }
#line 152
        tmp___0 = ownflags;
#line 152
        ownflags ++;
#line 152
        tmp___1 = ep;
#line 152
        ep ++;
#line 152
        *tmp___0 = *tmp___1;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 155
  if ((int )*ep != 47) {
#line 155
    *dom_r = fdom;
#line 155
    *qf_r = 0;
  } else {
#line 156
    *dom_r = (char const   *)(ep + 1);
#line 156
    *qf_r = qf;
  }
#line 157
  *ownflags = (char)0;
#line 158
  return;
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnstest.c"
static int consistsof___1(char const   *string , char const   *accept___0 ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 161
  tmp = strspn(string, accept___0);
#line 161
  tmp___0 = strlen(string);
  }
#line 161
  return (tmp == tmp___0);
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static int bracket___2  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static int forever___2  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static int address___2  ;
#line 59 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static unsigned long timeout___2  =    1000UL;
#line 60 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static adns_rrtype rrt___2  =    (adns_rrtype )65548;
#line 61 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static adns_initflags initflags___2  =    (adns_initflags )0;
#line 62 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static char const   *config_text___9  ;
#line 64 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static int outblocked___2  ;
#line 64 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static int inputeof___2  ;
#line 65 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static struct __anonstruct_outqueue_55___2 outqueue___2  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static int peroutqueuenode___2  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static int outqueuelen___2  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static struct sockaddr_in sa___2  ;
#line 69 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static adns_state ads___6  ;
#line 71 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static char addrtextbuf___2[14]  ;
#line 72 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static int cbyte___2  ;
#line 72 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static int inbyte___2  ;
#line 72 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static int inbuf___2  ;
#line 73 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static unsigned char bytes___2[4]  ;
#line 74 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static struct timeval printbefore___2  ;
#line 82 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static struct treething *newthing___2  ;
#line 83 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static void *treeroot___2  ;
#line 85 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static int nonblock___2(int fd , int isnonblock ) 
{ 
  int r ;
  int tmp ;

  {
  {
#line 88
  r = fcntl(fd, 3);
  }
#line 89
  if (r == -1) {
#line 89
    return (-1);
  }
#line 90
  if (isnonblock) {
#line 90
    tmp = r | 2048;
  } else {
#line 90
    tmp = r & -2049;
  }
  {
#line 90
  r = fcntl(fd, 4, tmp);
  }
#line 91
  if (r == -1) {
#line 91
    return (-1);
  }
#line 92
  return (0);
}
}
#line 101
static  __attribute__((__noreturn__)) void sysfail___3(char const   *what ) ;
#line 102
static  __attribute__((__noreturn__)) void sysfail___3(char const   *what ) ;
#line 102 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static void sysfail___3(char const   *what ) 
{ 
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 103
  tmp = __errno_location();
#line 103
  tmp___0 = strerror(*tmp);
#line 103
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adnsresfilter: system call failed: %s: %s\n",
          what, tmp___0);
#line 104
  quitnow(2);
  }
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static void *xmalloc___3(size_t sz ) 
{ 
  void *r ;

  {
  {
#line 109
  r = malloc(sz);
  }
#line 109
  if (r) {
#line 109
    return (r);
  }
  {
#line 110
  sysfail___3("malloc");
  }
}
}
#line 113
static  __attribute__((__noreturn__)) void outputerr___2(void) ;
#line 114
static  __attribute__((__noreturn__)) void outputerr___2(void) ;
#line 114 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static void outputerr___2(void) 
{ 


  {
  {
#line 114
  sysfail___3("write to stdout");
  }
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static void usage___8(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 117
  tmp = printf((char const   */* __restrict  */)"usage: adnsresfilter [<options ...>]\n       adnsresfilter  -h|--help | --version\noptions: -t<milliseconds>|--timeout <milliseconds>\n         -w|--wait        (always wait for queries to time out or fail)\n         -b|--brackets    (require [...] around IP addresses)\n         -a|--address     (always include [address] in output)\n         -u|--unchecked   (do not forward map for checking)\n         --config <text>  (use this instead of resolv.conf)\n         --debug          (turn on adns resolver debugging)\nTimeout is the maximum amount to delay any particular bit of output for.\nLookups will go on in the background.  Default timeout = 1000 (ms).\n");
  }
#line 117
  if (tmp == -1) {
    {
#line 128
    outputerr___2();
    }
  }
  {
#line 129
  tmp___0 = fflush(stdout);
  }
#line 129
  if (tmp___0) {
    {
#line 129
    sysfail___3("flush stdout");
    }
  }
#line 130
  return;
}
}
#line 132
static  __attribute__((__noreturn__)) void usageerr___6(char const   *why ) ;
#line 133
static  __attribute__((__noreturn__)) void usageerr___6(char const   *why ) ;
#line 133 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static void usageerr___6(char const   *why ) 
{ 


  {
  {
#line 134
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adnsresfilter: bad usage: %s\n",
          why);
#line 135
  usage___8();
#line 136
  quitnow(1);
  }
}
}
#line 139
static  __attribute__((__noreturn__)) void adnsfail___2(char const   *what , int e ) ;
#line 140
static  __attribute__((__noreturn__)) void adnsfail___2(char const   *what , int e ) ;
#line 140 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static void adnsfail___2(char const   *what , int e ) 
{ 
  char *tmp ;

  {
  {
#line 141
  tmp = strerror(e);
#line 141
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adnsresfilter: adns call failed: %s: %s\n",
          what, tmp);
#line 142
  quitnow(2);
  }
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static void settimeout___2(char const   *arg ) 
{ 
  char *ep ;

  {
  {
#line 147
  timeout___2 = strtoul((char const   */* __restrict  */)arg, (char **/* __restrict  */)(& ep),
                        0);
  }
#line 148
  if (*ep) {
    {
#line 148
    usageerr___6("invalid timeout");
    }
  }
#line 149
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static void parseargs___2(char const   * const  *argv ) 
{ 
  char const   *arg ;
  int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    argv ++;
#line 155
    arg = (char const   *)*argv;
#line 155
    if (! arg) {
#line 155
      goto while_break;
    }
#line 156
    if ((int const   )*(arg + 0) != 45) {
      {
#line 156
      usageerr___6("no non-option arguments are allowed");
      }
    }
#line 157
    if ((int const   )*(arg + 1) == 45) {
      {
#line 158
      tmp___9 = strcmp(arg, "--timeout");
      }
#line 158
      if (tmp___9) {
        {
#line 162
        tmp___8 = strcmp(arg, "--wait");
        }
#line 162
        if (tmp___8) {
          {
#line 164
          tmp___7 = strcmp(arg, "--brackets");
          }
#line 164
          if (tmp___7) {
            {
#line 166
            tmp___6 = strcmp(arg, "--address");
            }
#line 166
            if (tmp___6) {
              {
#line 168
              tmp___5 = strcmp(arg, "--unchecked");
              }
#line 168
              if (tmp___5) {
                {
#line 170
                tmp___4 = strcmp(arg, "--config");
                }
#line 170
                if (tmp___4) {
                  {
#line 173
                  tmp___3 = strcmp(arg, "--debug");
                  }
#line 173
                  if (tmp___3) {
                    {
#line 175
                    tmp___2 = strcmp(arg, "--help");
                    }
#line 175
                    if (tmp___2) {
                      {
#line 177
                      tmp___1 = strcmp(arg, "--version");
                      }
#line 177
                      if (tmp___1) {
                        {
#line 180
                        usageerr___6("unknown long option");
                        }
                      } else {
                        {
#line 178
                        tmp = fputs((char const   */* __restrict  */)"adnsresfilter (GNU adns) 1.2\n\nCopyright (C) 1997-2000,2003,2006  Ian Jackson\nCopyright (C) 1999-2000,2003,2006  Tony Finch\nCopyright (C) 1991 Massachusetts Institute of Technology\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n",
                                    (FILE */* __restrict  */)stdout);
                        }
#line 178
                        if (tmp == -1) {
                          {
#line 178
                          perror("adnsresfilter: write version message");
#line 178
                          quitnow(-1);
                          }
                        } else {
                          {
#line 178
                          tmp___0 = fclose(stdout);
                          }
#line 178
                          if (tmp___0) {
                            {
#line 178
                            perror("adnsresfilter: write version message");
#line 178
                            quitnow(-1);
                            }
                          }
                        }
                        {
#line 178
                        quitnow(0);
#line 178
                        quitnow(0);
                        }
                      }
                    } else {
                      {
#line 176
                      usage___8();
#line 176
                      quitnow(0);
                      }
                    }
                  } else {
#line 174
                    initflags___2 = (adns_initflags )((unsigned int )initflags___2 | 8U);
                  }
                } else {
#line 171
                  argv ++;
#line 171
                  arg = (char const   *)*argv;
#line 171
                  if (! arg) {
                    {
#line 171
                    usageerr___6("--config needs a value");
                    }
                  }
#line 172
                  config_text___9 = arg;
                }
              } else {
#line 169
                rrt___2 = (adns_rrtype )12;
              }
            } else {
#line 167
              address___2 = 1;
            }
          } else {
#line 165
            bracket___2 = 1;
          }
        } else {
#line 163
          forever___2 = 1;
        }
      } else {
#line 159
        argv ++;
#line 159
        arg = (char const   *)*argv;
#line 159
        if (! arg) {
          {
#line 159
          usageerr___6("--timeout needs a value");
          }
        }
        {
#line 160
        settimeout___2(arg);
#line 161
        forever___2 = 0;
        }
      }
    } else {
      {
#line 183
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 183
        arg ++;
#line 183
        c = (int )*arg;
#line 183
        if (! c) {
#line 183
          goto while_break___0;
        }
        {
#line 185
        if (c == 116) {
#line 185
          goto case_116;
        }
#line 192
        if (c == 119) {
#line 192
          goto case_119;
        }
#line 195
        if (c == 98) {
#line 195
          goto case_98;
        }
#line 198
        if (c == 97) {
#line 198
          goto case_97;
        }
#line 201
        if (c == 117) {
#line 201
          goto case_117;
        }
#line 204
        if (c == 104) {
#line 204
          goto case_104;
        }
#line 207
        goto switch_default;
        case_116: /* CIL Label */ 
#line 186
        arg ++;
#line 186
        if (*arg) {
          {
#line 186
          settimeout___2(arg);
          }
        } else {
#line 187
          argv ++;
#line 187
          arg = (char const   *)*argv;
#line 187
          if (arg) {
            {
#line 187
            settimeout___2(arg);
            }
          } else {
            {
#line 188
            usageerr___6("-t needs a value");
            }
          }
        }
#line 189
        forever___2 = 0;
#line 190
        arg = "\000";
#line 191
        goto switch_break;
        case_119: /* CIL Label */ 
#line 193
        forever___2 = 1;
#line 194
        goto switch_break;
        case_98: /* CIL Label */ 
#line 196
        bracket___2 = 1;
#line 197
        goto switch_break;
        case_97: /* CIL Label */ 
#line 199
        address___2 = 1;
#line 200
        goto switch_break;
        case_117: /* CIL Label */ 
#line 202
        rrt___2 = (adns_rrtype )12;
#line 203
        goto switch_break;
        case_104: /* CIL Label */ 
        {
#line 205
        usage___8();
#line 206
        quitnow(0);
        }
        switch_default: /* CIL Label */ 
        {
#line 208
        usageerr___6("unknown short option");
        }
        switch_break: /* CIL Label */ ;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  return;
}
}
#line 215 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static void queueoutchar___2(int c ) 
{ 
  struct outqueuenode *entry ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 218
  entry = outqueue___2.tail;
#line 219
  if (! entry) {
#line 219
    goto _L;
  } else
#line 219
  if (entry->addr) {
#line 219
    goto _L;
  } else
#line 219
  if (entry->textlen >= peroutqueuenode___2) {
    _L: /* CIL Label */ 
#line 220
    if (! peroutqueuenode___2) {
#line 220
      peroutqueuenode___2 = 128;
    } else
#line 220
    if (! entry) {
#line 220
      peroutqueuenode___2 = 128;
    } else
#line 220
    if (entry->addr) {
#line 220
      peroutqueuenode___2 = 128;
    } else {
#line 220
      if (peroutqueuenode___2 >= 1024) {
#line 220
        tmp = 4096;
      } else {
#line 220
        tmp = peroutqueuenode___2 << 2;
      }
#line 220
      peroutqueuenode___2 = tmp;
    }
    {
#line 222
    tmp___0 = xmalloc___3(sizeof(*entry));
#line 222
    entry = (struct outqueuenode *)tmp___0;
#line 223
    entry->buffer = xmalloc___3((size_t )peroutqueuenode___2);
#line 224
    entry->textp = (char *)entry->buffer;
#line 225
    entry->textlen = 0;
#line 226
    entry->addr = (struct treething *)0;
    }
    {
#line 227
    while (1) {
      while_continue: /* CIL Label */ ;
#line 227
      entry->next = (struct outqueuenode *)0;
#line 227
      entry->back = outqueue___2.tail;
#line 227
      if (outqueue___2.tail) {
#line 227
        (outqueue___2.tail)->next = entry;
      } else {
#line 227
        outqueue___2.head = entry;
      }
#line 227
      outqueue___2.tail = entry;
#line 227
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 228
    outqueuelen___2 ++;
  }
#line 230
  tmp___1 = entry->textlen;
#line 230
  (entry->textlen) ++;
#line 230
  *(entry->textp + tmp___1) = (char )c;
#line 231
  return;
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static void queueoutstr___2(char const   *str , int len ) 
{ 
  char const   *tmp ;
  int tmp___0 ;

  {
  {
#line 234
  while (1) {
    while_continue: /* CIL Label */ ;
#line 234
    tmp___0 = len;
#line 234
    len --;
#line 234
    if (! (tmp___0 > 0)) {
#line 234
      goto while_break;
    }
    {
#line 234
    tmp = str;
#line 234
    str ++;
#line 234
    queueoutchar___2((int )*tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 235
  return;
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static void writestdout___2(struct outqueuenode *entry ) 
{ 
  int r ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 240
  while (1) {
    while_continue: /* CIL Label */ ;
#line 240
    if (! entry->textlen) {
#line 240
      goto while_break;
    }
    {
#line 241
    tmp = write(1, (void const   *)entry->textp, (size_t )entry->textlen);
#line 241
    r = (int )tmp;
    }
#line 242
    if (r < 0) {
      {
#line 243
      tmp___0 = __errno_location();
      }
#line 243
      if (*tmp___0 == 4) {
#line 243
        goto while_continue;
      }
      {
#line 244
      tmp___1 = __errno_location();
      }
#line 244
      if (*tmp___1 == 11) {
#line 244
        outblocked___2 = 1;
#line 244
        goto while_break;
      }
      {
#line 245
      sysfail___3("write stdout");
      }
    }
#line 247
    if (! (r <= entry->textlen)) {
      {
#line 247
      __assert_fail("r <= entry->textlen", "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c",
                    247U, "writestdout");
      }
    }
#line 248
    entry->textp += r;
#line 249
    entry->textlen -= r;
  }
  while_break: /* CIL Label */ ;
  }
#line 251
  if (! entry->textlen) {
    {
#line 252
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 252
      if (entry->back) {
#line 252
        (entry->back)->next = entry->next;
      } else {
#line 252
        outqueue___2.head = entry->next;
      }
#line 252
      if (entry->next) {
#line 252
        (entry->next)->back = entry->back;
      } else {
#line 252
        outqueue___2.tail = entry->back;
      }
#line 252
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 253
    free(entry->buffer);
#line 254
    free((void *)entry);
#line 255
    outqueuelen___2 --;
    }
  }
#line 257
  return;
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static void replacetextwithname___2(struct outqueuenode *entry ) 
{ 
  char *name ;
  char *newbuf ;
  int namelen ;
  int newlen ;
  size_t tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 263
  name = *(((entry->addr)->ans)->rrs.str + 0);
#line 264
  tmp = strlen((char const   *)name);
#line 264
  namelen = (int )tmp;
  }
#line 265
  if (! address___2) {
    {
#line 266
    free(entry->buffer);
#line 267
    entry->buffer = (void *)0;
#line 268
    entry->textp = name;
#line 269
    entry->textlen = namelen;
    }
  } else {
#line 271
    if (bracket___2) {
#line 271
      tmp___0 = 0;
    } else {
#line 271
      tmp___0 = 2;
    }
    {
#line 271
    newlen = (entry->textlen + namelen) + tmp___0;
#line 272
    tmp___1 = xmalloc___3((size_t )(newlen + 1));
#line 272
    newbuf = (char *)tmp___1;
    }
#line 273
    if (bracket___2) {
#line 273
      tmp___2 = "%s%.*s";
    } else {
#line 273
      tmp___2 = "%s[%.*s]";
    }
    {
#line 273
    sprintf((char */* __restrict  */)newbuf, (char const   */* __restrict  */)tmp___2,
            name, entry->textlen, entry->textp);
#line 274
    free(entry->buffer);
#line 275
    tmp___3 = newbuf;
#line 275
    entry->textp = tmp___3;
#line 275
    entry->buffer = (void *)tmp___3;
#line 276
    entry->textlen = newlen;
    }
  }
#line 278
  return;
}
}
#line 280 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static void checkadnsqueries___2(void) 
{ 
  adns_query qu ;
  adns_answer *ans ;
  void *context ;
  struct treething *foundthing ;
  int r ;

  {
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 288
    qu = (adns_query )0;
#line 288
    context = (void *)0;
#line 288
    ans = (adns_answer *)0;
#line 289
    r = adns_check(ads___6, & qu, & ans, & context);
    }
#line 290
    if (r == 3) {
#line 290
      goto while_break;
    } else
#line 290
    if (r == 11) {
#line 290
      goto while_break;
    }
#line 291
    if (! (! r)) {
      {
#line 291
      __assert_fail("!r", "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c",
                    291U, "checkadnsqueries");
      }
    }
#line 292
    foundthing = (struct treething *)context;
#line 293
    foundthing->ans = ans;
#line 294
    foundthing->qu = (adns_query )0;
  }
  while_break: /* CIL Label */ ;
  }
#line 296
  return;
}
}
#line 298 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static void restartbuf___2(void) 
{ 


  {
#line 299
  if (inbuf___2 > 0) {
    {
#line 299
    queueoutstr___2((char const   *)(addrtextbuf___2), inbuf___2);
    }
  }
#line 300
  inbuf___2 = 0;
#line 301
  return;
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static int comparer___2(void const   *a , void const   *b ) 
{ 
  int tmp ;

  {
  {
#line 304
  tmp = memcmp(a, b, (size_t )4);
  }
#line 304
  return (tmp);
}
}
#line 307 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static void procaddr___2(void) 
{ 
  struct treething *foundthing ;
  void **searchfound ;
  struct outqueuenode *entry ;
  int r ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 313
  if (! newthing___2) {
    {
#line 314
    tmp = xmalloc___3(sizeof(struct treething ));
#line 314
    newthing___2 = (struct treething *)tmp;
#line 315
    newthing___2->qu = (adns_query )0;
#line 316
    newthing___2->ans = (adns_answer *)0;
    }
  }
  {
#line 319
  memcpy((void */* __restrict  */)(newthing___2->bytes), (void const   */* __restrict  */)(bytes___2),
         (size_t )4);
#line 320
  tmp___0 = tsearch((void const   *)newthing___2, & treeroot___2, & comparer___2);
#line 320
  searchfound = (void **)tmp___0;
  }
#line 321
  if (! searchfound) {
    {
#line 321
    sysfail___3("tsearch");
    }
  }
#line 322
  foundthing = (struct treething *)*searchfound;
#line 324
  if ((unsigned long )foundthing == (unsigned long )newthing___2) {
    {
#line 325
    newthing___2 = (struct treething *)0;
#line 326
    memcpy((void */* __restrict  */)(& sa___2.sin_addr), (void const   */* __restrict  */)(bytes___2),
           (size_t )4);
#line 327
    r = adns_submit_reverse(ads___6, (struct sockaddr  const  *)(& sa___2), rrt___2,
                            (adns_queryflags )0, (void *)foundthing, & foundthing->qu);
    }
#line 329
    if (r) {
      {
#line 329
      adnsfail___2("submit", r);
      }
    }
  }
  {
#line 331
  tmp___1 = xmalloc___3(sizeof(*entry));
#line 331
  entry = (struct outqueuenode *)tmp___1;
#line 332
  entry->buffer = xmalloc___3((size_t )inbuf___2);
#line 333
  entry->textp = (char *)entry->buffer;
#line 334
  memcpy((void */* __restrict  */)entry->textp, (void const   */* __restrict  */)(addrtextbuf___2),
         (size_t )inbuf___2);
#line 335
  entry->textlen = inbuf___2;
#line 336
  entry->addr = foundthing;
#line 337
  entry->printbefore = printbefore___2;
  }
  {
#line 338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 338
    entry->next = (struct outqueuenode *)0;
#line 338
    entry->back = outqueue___2.tail;
#line 338
    if (outqueue___2.tail) {
#line 338
      (outqueue___2.tail)->next = entry;
    } else {
#line 338
      outqueue___2.head = entry;
    }
#line 338
    outqueue___2.tail = entry;
#line 338
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 339
  outqueuelen___2 ++;
#line 340
  inbuf___2 = 0;
#line 341
  cbyte___2 = -1;
#line 342
  return;
}
}
#line 344 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static void startaddr___2(void) 
{ 


  {
#line 345
  cbyte___2 = 0;
#line 345
  bytes___2[cbyte___2] = (unsigned char)0;
#line 346
  inbyte___2 = 0;
#line 347
  return;
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static void readstdin___2(void) 
{ 
  char readbuf[512] ;
  char *p ;
  int r ;
  int c ;
  int nbyte ;
  ssize_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;

  {
  {
#line 353
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 353
    tmp = read(0, (void *)(readbuf), sizeof(readbuf));
#line 353
    r = (int )tmp;
    }
#line 353
    if (! (r <= 0)) {
#line 353
      goto while_break;
    }
#line 354
    if (r == 0) {
#line 354
      inputeof___2 = 1;
#line 354
      return;
    }
#line 355
    if (r == 11) {
#line 355
      return;
    }
#line 356
    if (r != 4) {
      {
#line 356
      sysfail___3("read stdin");
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 358
  p = readbuf;
  {
#line 358
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 358
    if (! (r > 0)) {
#line 358
      goto while_break___0;
    }
#line 359
    c = (int )*p;
#line 360
    if (cbyte___2 == -1) {
#line 360
      if (bracket___2) {
#line 360
        if (c == 91) {
          {
#line 361
          tmp___0 = inbuf___2;
#line 361
          inbuf___2 ++;
#line 361
          addrtextbuf___2[tmp___0] = (char )c;
#line 362
          startaddr___2();
          }
        } else {
#line 360
          goto _L___15;
        }
      } else {
#line 360
        goto _L___15;
      }
    } else
    _L___15: /* CIL Label */ 
#line 363
    if (cbyte___2 == -1) {
#line 363
      if (! bracket___2) {
        {
#line 363
        tmp___6 = __ctype_b_loc();
        }
#line 363
        if ((int const   )*(*tmp___6 + c) & 8) {
#line 363
          goto _L___13;
        } else {
          {
#line 364
          queueoutchar___2(c);
#line 365
          startaddr___2();
          }
        }
      } else {
#line 363
        goto _L___13;
      }
    } else
    _L___13: /* CIL Label */ 
#line 366
    if (cbyte___2 >= 0) {
#line 366
      if (inbyte___2 < 3) {
#line 366
        if (c >= 48) {
#line 366
          if (c <= 57) {
#line 366
            nbyte = (int )bytes___2[cbyte___2] * 10 + (c - 48);
#line 366
            if (nbyte <= 255) {
#line 368
              bytes___2[cbyte___2] = (unsigned char )nbyte;
#line 369
              tmp___1 = inbuf___2;
#line 369
              inbuf___2 ++;
#line 369
              addrtextbuf___2[tmp___1] = (char )c;
#line 370
              inbyte___2 ++;
            } else {
#line 366
              goto _L___11;
            }
          } else {
#line 366
            goto _L___11;
          }
        } else {
#line 366
          goto _L___11;
        }
      } else {
#line 366
        goto _L___11;
      }
    } else
    _L___11: /* CIL Label */ 
#line 371
    if (cbyte___2 >= 0) {
#line 371
      if (cbyte___2 < 3) {
#line 371
        if (inbyte___2 > 0) {
#line 371
          if (c == 46) {
#line 372
            cbyte___2 ++;
#line 372
            bytes___2[cbyte___2] = (unsigned char)0;
#line 373
            tmp___2 = inbuf___2;
#line 373
            inbuf___2 ++;
#line 373
            addrtextbuf___2[tmp___2] = (char )c;
#line 374
            inbyte___2 = 0;
          } else {
#line 371
            goto _L___7;
          }
        } else {
#line 371
          goto _L___7;
        }
      } else {
#line 371
        goto _L___7;
      }
    } else
    _L___7: /* CIL Label */ 
#line 375
    if (cbyte___2 == 3) {
#line 375
      if (inbyte___2 > 0) {
#line 375
        if (bracket___2) {
#line 375
          if (c == 93) {
            {
#line 376
            tmp___3 = inbuf___2;
#line 376
            inbuf___2 ++;
#line 376
            addrtextbuf___2[tmp___3] = (char )c;
#line 377
            procaddr___2();
            }
          } else {
#line 375
            goto _L___4;
          }
        } else {
#line 375
          goto _L___4;
        }
      } else {
#line 375
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 378
    if (cbyte___2 == 3) {
#line 378
      if (inbyte___2 > 0) {
#line 378
        if (! bracket___2) {
          {
#line 378
          tmp___5 = __ctype_b_loc();
          }
#line 378
          if ((int const   )*(*tmp___5 + c) & 8) {
#line 378
            goto _L___1;
          } else {
            {
#line 379
            procaddr___2();
#line 380
            queueoutchar___2(c);
#line 381
            startaddr___2();
            }
          }
        } else {
#line 378
          goto _L___1;
        }
      } else {
#line 378
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 383
      restartbuf___2();
#line 384
      queueoutchar___2(c);
#line 385
      cbyte___2 = -1;
      }
#line 386
      if (! bracket___2) {
        {
#line 386
        tmp___4 = __ctype_b_loc();
        }
#line 386
        if (! ((int const   )*(*tmp___4 + c) & 8)) {
          {
#line 386
          startaddr___2();
          }
        }
      }
    }
#line 358
    r --;
#line 358
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 389
  return;
}
}
#line 391 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adnsresfilter.c"
static void startup___2(void) 
{ 
  int r ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 394
  tmp = nonblock___2(0, 1);
  }
#line 394
  if (tmp) {
    {
#line 394
    sysfail___3("set stdin to nonblocking mode");
    }
  }
  {
#line 395
  tmp___0 = nonblock___2(1, 1);
  }
#line 395
  if (tmp___0) {
    {
#line 395
    sysfail___3("set stdout to nonblocking mode");
    }
  }
  {
#line 396
  memset((void *)(& sa___2), 0, sizeof(sa___2));
#line 397
  sa___2.sin_family = (sa_family_t )2;
  }
#line 398
  if (config_text___9) {
    {
#line 399
    r = adns_init_strcfg(& ads___6, initflags___2, stderr, config_text___9);
    }
  } else {
    {
#line 401
    r = adns_init(& ads___6, initflags___2, (FILE *)0);
    }
  }
#line 403
  if (r) {
    {
#line 403
    adnsfail___2("init", r);
    }
  }
#line 404
  cbyte___2 = -1;
#line 405
  inbyte___2 = -1;
#line 406
  inbuf___2 = 0;
#line 407
  if (! bracket___2) {
    {
#line 407
    startaddr___2();
    }
  }
#line 408
  return;
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-main.c"
static int used___2  ;
#line 33 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-main.c"
static int avail___2  ;
#line 34 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-main.c"
static char *buf___15  ;
#line 82 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-main.c"
static struct typename  const  typenames___2[18]  = 
#line 82
  {      {(adns_rrtype )65538, "ns"}, 
        {(adns_rrtype )131078, "soa"}, 
        {(adns_rrtype )65548, "ptr"}, 
        {(adns_rrtype )65551, "mx"}, 
        {(adns_rrtype )131089, "rp"}, 
        {(adns_rrtype )65569, "srv"}, 
        {(adns_rrtype )65537, "addr"}, 
        {(adns_rrtype )5, "cname"}, 
        {(adns_rrtype )13, "hinfo"}, 
        {(adns_rrtype )16, "txt"}, 
        {(adns_rrtype )1, "a"}, 
        {(adns_rrtype )2, "ns-"}, 
        {(adns_rrtype )6, "soa-"}, 
        {(adns_rrtype )12, "ptr-"}, 
        {(adns_rrtype )15, "mx-"}, 
        {(adns_rrtype )17, "rp-"}, 
        {(adns_rrtype )33, "srv-"}, 
        {(adns_rrtype )0, (char const   *)0}};
#line 129 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-main.c"
static void process_optarg___2(char const   *arg , char const   * const  **argv_p ,
                               char const   *value ) 
{ 
  struct optioninfo  const  *oip ;
  char const   *arg2 ;
  int invert ;
  int tmp ;

  {
#line 136
  if ((int const   )*(arg + 0) == 45) {
#line 136
    goto _L___1;
  } else
#line 136
  if ((int const   )*(arg + 0) == 43) {
    _L___1: /* CIL Label */ 
#line 137
    if ((int const   )*(arg + 0) == 45) {
#line 137
      if ((int const   )*(arg + 1) == 45) {
        {
#line 138
        tmp = strncmp(arg, "--no-", (size_t )5);
        }
#line 138
        if (tmp) {
          {
#line 142
          invert = 0;
#line 143
          oip = opt_findl(arg + 2);
          }
        } else {
          {
#line 139
          invert = 1;
#line 140
          oip = opt_findl(arg + 5);
          }
        }
#line 145
        if ((unsigned int const   )oip->type == 5U) {
#line 146
          if (argv_p) {
#line 146
            (*argv_p) ++;
#line 146
            arg = (char const   *)*(*argv_p);
          } else {
#line 146
            arg = value;
          }
#line 147
          if (! arg) {
            {
#line 147
            usageerr("option --%s requires a value argument", oip->lopt);
            }
          }
#line 148
          arg2 = (char const   *)0;
        } else
#line 149
        if ((unsigned int const   )oip->type == 6U) {
#line 150
          if (! argv_p) {
            {
#line 150
            __assert_fail("argv_p", "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-main.c",
                          150U, "process_optarg");
            }
          }
#line 151
          (*argv_p) ++;
#line 151
          arg = (char const   *)*(*argv_p);
#line 152
          if (arg) {
#line 152
            (*argv_p) ++;
#line 152
            arg2 = (char const   *)*(*argv_p);
          } else {
#line 152
            arg2 = (char const   *)0;
          }
#line 153
          if (! arg) {
            {
#line 154
            usageerr("option --%s requires two more arguments", oip->lopt);
            }
          } else
#line 153
          if (! arg2) {
            {
#line 154
            usageerr("option --%s requires two more arguments", oip->lopt);
            }
          }
        } else {
#line 156
          if (value) {
            {
#line 156
            usageerr("option --%s does not take a value", oip->lopt);
            }
          }
#line 157
          arg = (char const   *)0;
#line 158
          arg2 = (char const   *)0;
        }
        {
#line 160
        opt_do(oip, invert, arg, arg2);
        }
      } else {
#line 137
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 161
    if ((int const   )*(arg + 0) == 45) {
#line 161
      if ((int const   )*(arg + 1) == 0) {
#line 162
        if (argv_p) {
#line 162
          (*argv_p) ++;
#line 162
          arg = (char const   *)*(*argv_p);
        } else {
#line 162
          arg = value;
        }
#line 163
        if (! arg) {
          {
#line 163
          usageerr("option `-\' must be followed by a domain");
          }
        }
        {
#line 164
        query_do(arg);
        }
      } else {
#line 161
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 166
      invert = (int const   )*(arg + 0) == 43;
#line 167
      arg ++;
      {
#line 168
      while (1) {
        while_continue: /* CIL Label */ ;
#line 168
        if (! *arg) {
#line 168
          goto while_break;
        }
        {
#line 169
        oip = opt_finds(& arg);
        }
#line 170
        if ((unsigned int const   )oip->type == 5U) {
#line 171
          if (! *arg) {
#line 172
            if (argv_p) {
#line 172
              (*argv_p) ++;
#line 172
              arg = (char const   *)*(*argv_p);
            } else {
#line 172
              arg = value;
            }
#line 173
            if (! arg) {
              {
#line 173
              usageerr("option -%s requires a value argument", oip->sopt);
              }
            }
          } else
#line 175
          if (value) {
            {
#line 175
            usageerr("two values for option -%s given !", oip->sopt);
            }
          }
          {
#line 177
          opt_do(oip, invert, arg, (char const   *)0);
#line 178
          arg = "";
          }
        } else {
#line 180
          if (value) {
            {
#line 180
            usageerr("option -%s does not take a value", oip->sopt);
            }
          }
          {
#line 181
          opt_do(oip, invert, (char const   *)0, (char const   *)0);
          }
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 186
    query_do(arg);
    }
  }
#line 188
  return;
}
}
#line 190 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-main.c"
static void read_stdin___2(void) 
{ 
  int anydone ;
  int r ;
  char *newline ;
  char *space ;
  void *tmp ;
  int *tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 194
  anydone = 0;
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 195
    if (! (! anydone)) {
#line 195
      if (! used___2) {
#line 195
        goto while_break;
      }
    }
    {
#line 196
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 196
      tmp___5 = memchr((void const   *)buf___15, '\n', (size_t )used___2);
#line 196
      newline = (char *)tmp___5;
      }
#line 196
      if (newline) {
#line 196
        goto while_break___0;
      }
#line 197
      if (used___2 == avail___2) {
        {
#line 198
        avail___2 += 20;
#line 198
        avail___2 <<= 1;
#line 199
        tmp = realloc((void *)buf___15, (size_t )avail___2);
#line 199
        buf___15 = (char *)tmp;
        }
#line 200
        if (! buf___15) {
          {
#line 200
          tmp___0 = __errno_location();
#line 200
          sysfail("realloc stdin buffer", *tmp___0);
          }
        }
      }
      {
#line 202
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 203
        tmp___1 = read(0, (void *)(buf___15 + used___2), (size_t )(avail___2 - used___2));
#line 203
        r = (int )tmp___1;
        }
#line 202
        if (r < 0) {
          {
#line 202
          tmp___2 = __errno_location();
          }
#line 202
          if (! (*tmp___2 == 4)) {
#line 202
            goto while_break___1;
          }
        } else {
#line 202
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 205
      if (r == 0) {
#line 206
        if (used___2) {
#line 208
          tmp___3 = used___2;
#line 208
          used___2 ++;
#line 208
          *(buf___15 + tmp___3) = (char )'\n';
#line 209
          r = 1;
        } else {
#line 211
          ov_pipe = 0;
#line 212
          return;
        }
      }
#line 215
      if (r < 0) {
        {
#line 215
        tmp___4 = __errno_location();
#line 215
        sysfail("read stdin", *tmp___4);
        }
      }
#line 216
      used___2 += r;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 218
    tmp___6 = newline;
#line 218
    newline ++;
#line 218
    *tmp___6 = (char)0;
#line 219
    space = strchr((char const   *)buf___15, ' ');
    }
#line 220
    if (space) {
#line 220
      tmp___7 = space;
#line 220
      space ++;
#line 220
      *tmp___7 = (char)0;
    }
    {
#line 221
    process_optarg___2((char const   *)buf___15, (char const   * const  **)0, (char const   *)space);
#line 222
    used___2 = (int )((long )used___2 - (newline - buf___15));
#line 223
    memmove((void *)buf___15, (void const   *)newline, (size_t )used___2);
#line 224
    anydone = 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 226
  return;
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c"
static void checkc_query_alloc___10(adns_state ads___7 , adns_query qu ) 
{ 
  allocnode *an ;
  int tmp ;

  {
#line 58
  if (qu->allocations.head) {
#line 58
    if (! (! (qu->allocations.head)->back)) {
      {
#line 58
      __assert_fail("! (qu->allocations).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                    59U, "checkc_query_alloc");
      }
    }
#line 58
    an = qu->allocations.head;
    {
#line 58
    while (1) {
      while_continue: /* CIL Label */ ;
#line 58
      if (! an) {
#line 58
        goto while_break;
      }
#line 58
      if (an->next) {
#line 58
        tmp = (unsigned long )an == (unsigned long )(an->next)->back;
      } else {
#line 58
        tmp = (unsigned long )an == (unsigned long )qu->allocations.tail;
      }
#line 58
      if (! tmp) {
        {
#line 58
        __assert_fail("(an)-> next ? (an) == (an)-> next-> back : (an) == (qu->allocations).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      59U, "checkc_query_alloc");
        }
      }
#line 58
      an = an->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 60
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c"
static void checkc_query___10(adns_state ads___7 , adns_query qu ) 
{ 
  adns_query child ;

  {
#line 65
  if (! (qu->udpnextserver < ads___7->nservers)) {
    {
#line 65
    __assert_fail("qu->udpnextserver < ads->nservers", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  65U, "checkc_query");
    }
  }
#line 66
  if (! (! (qu->udpsent & (0xffffffffffffffffUL << ads___7->nservers)))) {
    {
#line 66
    __assert_fail("!(qu->udpsent & (~0UL << ads->nservers))", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  66U, "checkc_query");
    }
  }
#line 67
  if (! (qu->search_pos <= ads___7->nsearchlist)) {
    {
#line 67
    __assert_fail("qu->search_pos <= ads->nsearchlist", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  67U, "checkc_query");
    }
  }
#line 68
  if (qu->parent) {
    {
#line 68
    while (1) {
      while_continue: /* CIL Label */ ;
#line 68
      child = (qu->parent)->children.head;
      {
#line 68
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 68
        if (! ((unsigned long )child != (unsigned long )qu)) {
#line 68
          goto while_break___0;
        }
#line 68
        if (! child) {
          {
#line 68
          __assert_fail("(child)", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                        68U, "checkc_query");
          }
        }
#line 68
        child = child->siblings.next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 68
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 69
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c"
static void checkc_notcpbuf___10(adns_state ads___7 ) 
{ 


  {
#line 72
  if (! (! ads___7->tcpsend.used)) {
    {
#line 72
    __assert_fail("!ads->tcpsend.used", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  72U, "checkc_notcpbuf");
    }
  }
#line 73
  if (! (! ads___7->tcprecv.used)) {
    {
#line 73
    __assert_fail("!ads->tcprecv.used", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  73U, "checkc_notcpbuf");
    }
  }
#line 74
  if (! (! ads___7->tcprecv_skip)) {
    {
#line 74
    __assert_fail("!ads->tcprecv_skip", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  74U, "checkc_notcpbuf");
    }
  }
#line 75
  return;
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c"
static void checkc_global___10(adns_state ads___7 ) 
{ 
  int i ;

  {
#line 80
  if (! (ads___7->udpsocket >= 0)) {
    {
#line 80
    __assert_fail("ads->udpsocket >= 0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  80U, "checkc_global");
    }
  }
#line 82
  i = 0;
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! (i < ads___7->nsortlist)) {
#line 82
      goto while_break;
    }
#line 83
    if (! (! (ads___7->sortlist[i].base.s_addr & ~ ads___7->sortlist[i].mask.s_addr))) {
      {
#line 83
      __assert_fail("!(ads->sortlist[i].base.s_addr & ~ads->sortlist[i].mask.s_addr)",
                    "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                    83U, "checkc_global");
      }
    }
#line 82
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  if (ads___7->tcpserver >= 0) {
#line 85
    if (! (ads___7->tcpserver < ads___7->nservers)) {
      {
#line 85
      __assert_fail("ads->tcpserver >= 0 && ads->tcpserver < ads->nservers", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                    85U, "checkc_global");
      }
    }
  } else {
    {
#line 85
    __assert_fail("ads->tcpserver >= 0 && ads->tcpserver < ads->nservers", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  85U, "checkc_global");
    }
  }
  {
#line 88
  if ((unsigned int )ads___7->tcpstate == 1U) {
#line 88
    goto case_1;
  }
#line 93
  if ((unsigned int )ads___7->tcpstate == 3U) {
#line 93
    goto case_3;
  }
#line 93
  if ((unsigned int )ads___7->tcpstate == 0U) {
#line 93
    goto case_3;
  }
#line 97
  if ((unsigned int )ads___7->tcpstate == 2U) {
#line 97
    goto case_2;
  }
#line 101
  goto switch_default;
  case_1: /* CIL Label */ 
#line 89
  if (! (ads___7->tcpsocket >= 0)) {
    {
#line 89
    __assert_fail("ads->tcpsocket >= 0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  89U, "checkc_global");
    }
  }
  {
#line 90
  checkc_notcpbuf___10(ads___7);
  }
#line 91
  goto switch_break;
  case_3: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 94
  if (! (ads___7->tcpsocket == -1)) {
    {
#line 94
    __assert_fail("ads->tcpsocket == -1", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  94U, "checkc_global");
    }
  }
  {
#line 95
  checkc_notcpbuf___10(ads___7);
  }
#line 96
  goto switch_break;
  case_2: /* CIL Label */ 
#line 98
  if (! (ads___7->tcpsocket >= 0)) {
    {
#line 98
    __assert_fail("ads->tcpsocket >= 0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  98U, "checkc_global");
    }
  }
#line 99
  if (! (ads___7->tcprecv_skip <= ads___7->tcprecv.used)) {
    {
#line 99
    __assert_fail("ads->tcprecv_skip <= ads->tcprecv.used", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  99U, "checkc_global");
    }
  }
#line 100
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 102
  __assert_fail("!\"ads->tcpstate value\"", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                102U, "checkc_global");
  }
  switch_break: /* CIL Label */ ;
  }
#line 105
  if (! ads___7->searchlist) {
#line 105
    if (! (! ads___7->nsearchlist)) {
      {
#line 105
      __assert_fail("ads->searchlist || !ads->nsearchlist", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                    105U, "checkc_global");
      }
    }
  }
#line 106
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c"
static void checkc_queue_udpw___10(adns_state ads___7 ) 
{ 
  adns_query qu ;
  int tmp ;

  {
#line 111
  if (ads___7->udpw.head) {
#line 111
    if (! (! (ads___7->udpw.head)->back)) {
      {
#line 111
      __assert_fail("! (ads->udpw).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                    118U, "checkc_queue_udpw");
      }
    }
#line 111
    qu = ads___7->udpw.head;
    {
#line 111
    while (1) {
      while_continue: /* CIL Label */ ;
#line 111
      if (! qu) {
#line 111
        goto while_break;
      }
#line 111
      if (qu->next) {
#line 111
        tmp = (unsigned long )qu == (unsigned long )(qu->next)->back;
      } else {
#line 111
        tmp = (unsigned long )qu == (unsigned long )ads___7->udpw.tail;
      }
#line 111
      if (! tmp) {
        {
#line 111
        __assert_fail("(qu)-> next ? (qu) == (qu)-> next-> back : (qu) == (ads->udpw).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! ((unsigned int )qu->state == 0U)) {
        {
#line 111
        __assert_fail("qu->state==query_tosend", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! (qu->retries <= 15)) {
        {
#line 111
        __assert_fail("qu->retries <= 15", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! qu->udpsent) {
        {
#line 111
        __assert_fail("qu->udpsent", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! qu->children.head) {
#line 111
        if (! (! qu->children.tail)) {
          {
#line 111
          __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                        118U, "checkc_queue_udpw");
          }
        }
      } else {
        {
#line 111
        __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
      {
#line 111
      checkc_query___10(ads___7, qu);
#line 111
      checkc_query_alloc___10(ads___7, qu);
#line 111
      qu = qu->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 119
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c"
static void checkc_queue_tcpw___10(adns_state ads___7 ) 
{ 
  adns_query qu ;
  int tmp ;

  {
#line 124
  if (ads___7->tcpw.head) {
#line 124
    if (! (! (ads___7->tcpw.head)->back)) {
      {
#line 124
      __assert_fail("! (ads->tcpw).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                    130U, "checkc_queue_tcpw");
      }
    }
#line 124
    qu = ads___7->tcpw.head;
    {
#line 124
    while (1) {
      while_continue: /* CIL Label */ ;
#line 124
      if (! qu) {
#line 124
        goto while_break;
      }
#line 124
      if (qu->next) {
#line 124
        tmp = (unsigned long )qu == (unsigned long )(qu->next)->back;
      } else {
#line 124
        tmp = (unsigned long )qu == (unsigned long )ads___7->tcpw.tail;
      }
#line 124
      if (! tmp) {
        {
#line 124
        __assert_fail("(qu)-> next ? (qu) == (qu)-> next-> back : (qu) == (ads->tcpw).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
#line 124
      if (! ((unsigned int )qu->state == 1U)) {
        {
#line 124
        __assert_fail("qu->state==query_tcpw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
#line 124
      if (! qu->children.head) {
#line 124
        if (! (! qu->children.tail)) {
          {
#line 124
          __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                        130U, "checkc_queue_tcpw");
          }
        }
      } else {
        {
#line 124
        __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
#line 124
      if (! (qu->retries <= ads___7->nservers + 1)) {
        {
#line 124
        __assert_fail("qu->retries <= ads->nservers+1", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
      {
#line 124
      checkc_query___10(ads___7, qu);
#line 124
      checkc_query_alloc___10(ads___7, qu);
#line 124
      qu = qu->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 131
  return;
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c"
static void checkc_queue_childw___10(adns_state ads___7 ) 
{ 
  adns_query parent ;
  adns_query child ;
  int tmp ;
  int tmp___0 ;

  {
#line 136
  if (ads___7->childw.head) {
#line 136
    if (! (! (ads___7->childw.head)->back)) {
      {
#line 136
      __assert_fail("! (ads->childw).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                    145U, "checkc_queue_childw");
      }
    }
#line 136
    parent = ads___7->childw.head;
    {
#line 136
    while (1) {
      while_continue: /* CIL Label */ ;
#line 136
      if (! parent) {
#line 136
        goto while_break;
      }
#line 136
      if (parent->next) {
#line 136
        tmp = (unsigned long )parent == (unsigned long )(parent->next)->back;
      } else {
#line 136
        tmp = (unsigned long )parent == (unsigned long )ads___7->childw.tail;
      }
#line 136
      if (! tmp) {
        {
#line 136
        __assert_fail("(parent)-> next ? (parent) == (parent)-> next-> back : (parent) == (ads->childw).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      145U, "checkc_queue_childw");
        }
      }
#line 136
      if (! ((unsigned int )parent->state == 2U)) {
        {
#line 136
        __assert_fail("parent->state == query_childw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      145U, "checkc_queue_childw");
        }
      }
#line 136
      if (! parent->children.head) {
        {
#line 136
        __assert_fail("parent->children.head", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      145U, "checkc_queue_childw");
        }
      }
#line 136
      if (parent->children.head) {
#line 136
        if (! (! (parent->children.head)->siblings.back)) {
          {
#line 136
          __assert_fail("! (parent->children).head->siblings. back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                        145U, "checkc_queue_childw");
          }
        }
#line 136
        child = parent->children.head;
        {
#line 136
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 136
          if (! child) {
#line 136
            goto while_break___0;
          }
#line 136
          if (child->siblings.next) {
#line 136
            tmp___0 = (unsigned long )child == (unsigned long )(child->siblings.next)->siblings.back;
          } else {
#line 136
            tmp___0 = (unsigned long )child == (unsigned long )parent->children.tail;
          }
#line 136
          if (! tmp___0) {
            {
#line 136
            __assert_fail("(child)->siblings. next ? (child) == (child)->siblings. next->siblings. back : (child) == (parent->children).tail",
                          "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                          145U, "checkc_queue_childw");
            }
          }
#line 136
          if (! ((unsigned long )child->parent == (unsigned long )parent)) {
            {
#line 136
            __assert_fail("child->parent == parent", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                          145U, "checkc_queue_childw");
            }
          }
#line 136
          if (! ((unsigned int )child->state != 3U)) {
            {
#line 136
            __assert_fail("child->state != query_done", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                          145U, "checkc_queue_childw");
            }
          }
#line 136
          child = child->siblings.next;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 136
      checkc_query___10(ads___7, parent);
#line 136
      checkc_query_alloc___10(ads___7, parent);
#line 136
      parent = parent->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 146
  return;
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c"
static void checkc_queue_output___10(adns_state ads___7 ) 
{ 
  adns_query qu ;
  int tmp ;

  {
#line 151
  if (ads___7->output.head) {
#line 151
    if (! (! (ads___7->output.head)->back)) {
      {
#line 151
      __assert_fail("! (ads->output).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                    157U, "checkc_queue_output");
      }
    }
#line 151
    qu = ads___7->output.head;
    {
#line 151
    while (1) {
      while_continue: /* CIL Label */ ;
#line 151
      if (! qu) {
#line 151
        goto while_break;
      }
#line 151
      if (qu->next) {
#line 151
        tmp = (unsigned long )qu == (unsigned long )(qu->next)->back;
      } else {
#line 151
        tmp = (unsigned long )qu == (unsigned long )ads___7->output.tail;
      }
#line 151
      if (! tmp) {
        {
#line 151
        __assert_fail("(qu)-> next ? (qu) == (qu)-> next-> back : (qu) == (ads->output).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! ((unsigned int )qu->state == 3U)) {
        {
#line 151
        __assert_fail("qu->state == query_done", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! qu->children.head) {
#line 151
        if (! (! qu->children.tail)) {
          {
#line 151
          __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                        157U, "checkc_queue_output");
          }
        }
      } else {
        {
#line 151
        __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! (! qu->parent)) {
        {
#line 151
        __assert_fail("!qu->parent", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! qu->allocations.head) {
#line 151
        if (! (! qu->allocations.tail)) {
          {
#line 151
          __assert_fail("!qu->allocations.head && !qu->allocations.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                        157U, "checkc_queue_output");
          }
        }
      } else {
        {
#line 151
        __assert_fail("!qu->allocations.head && !qu->allocations.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
      {
#line 151
      checkc_query___10(ads___7, qu);
#line 151
      qu = qu->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 158
  return;
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c"
static adns_query query_alloc___10(adns_state ads___7 , typeinfo const   *typei ,
                                   adns_rrtype type , adns_queryflags flags , struct timeval now ) 
{ 
  adns_query qu ;
  void *tmp ;
  void *tmp___0 ;
  adns_query tmp___1 ;
  adns_query tmp___2 ;
  adns_query tmp___3 ;
  adns_query tmp___4 ;
  allocnode *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __suseconds_t tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 45
  tmp = malloc(sizeof(*qu));
#line 45
  qu = (adns_query )tmp;
  }
#line 45
  if (! qu) {
#line 45
    return ((adns_query )0);
  }
  {
#line 46
  tmp___0 = malloc(sizeof(*(qu->answer)));
#line 46
  qu->answer = (adns_answer *)tmp___0;
  }
#line 47
  if (! qu->answer) {
    {
#line 47
    free((void *)qu);
    }
#line 47
    return ((adns_query )0);
  }
  {
#line 49
  qu->ads = ads___7;
#line 50
  qu->state = (enum __anonenum_state_83 )0;
#line 51
  tmp___2 = (adns_query )0;
#line 51
  qu->parent = tmp___2;
#line 51
  tmp___1 = tmp___2;
#line 51
  qu->next = tmp___1;
#line 51
  qu->back = tmp___1;
#line 52
  tmp___3 = (adns_query )0;
#line 52
  qu->children.tail = tmp___3;
#line 52
  qu->children.head = tmp___3;
#line 53
  tmp___4 = (adns_query )0;
#line 53
  qu->siblings.back = tmp___4;
#line 53
  qu->siblings.next = tmp___4;
#line 54
  tmp___5 = (allocnode *)0;
#line 54
  qu->allocations.tail = tmp___5;
#line 54
  qu->allocations.head = tmp___5;
#line 55
  qu->interim_allocd = 0;
#line 56
  qu->preserved_allocd = 0;
#line 57
  qu->final_allocspace = (void *)0;
#line 59
  qu->typei = typei;
#line 60
  qu->query_dgram = (byte *)0;
#line 61
  qu->query_dglen = 0;
#line 62
  adns__vbuf_init(& qu->vb);
#line 64
  qu->cname_dgram = (byte *)0;
#line 65
  tmp___6 = 0;
#line 65
  qu->cname_begin = tmp___6;
#line 65
  qu->cname_dglen = tmp___6;
#line 67
  adns__vbuf_init(& qu->search_vb);
#line 68
  tmp___8 = 0;
#line 68
  qu->search_doneabs = tmp___8;
#line 68
  tmp___7 = tmp___8;
#line 68
  qu->search_pos = tmp___7;
#line 68
  qu->search_origlen = tmp___7;
#line 70
  qu->id = -2;
#line 71
  qu->flags = (int )flags;
#line 72
  qu->retries = 0;
#line 73
  qu->udpnextserver = 0;
#line 74
  qu->udpsent = 0UL;
#line 75
  tmp___9 = (__suseconds_t )0;
#line 75
  qu->timeout.tv_usec = tmp___9;
#line 75
  qu->timeout.tv_sec = tmp___9;
#line 76
  qu->expires = now.tv_sec + 604800L;
#line 78
  memset((void *)(& qu->ctx), 0, sizeof(qu->ctx));
#line 80
  (qu->answer)->status = (adns_status )0;
#line 81
  tmp___10 = (char *)0;
#line 81
  (qu->answer)->owner = tmp___10;
#line 81
  (qu->answer)->cname = tmp___10;
#line 82
  (qu->answer)->type = type;
#line 83
  (qu->answer)->expires = (time_t )-1;
#line 84
  (qu->answer)->nrrs = 0;
#line 85
  (qu->answer)->rrs.untyped = (void *)0;
#line 86
  (qu->answer)->rrsz = (int )typei->rrsz;
  }
#line 88
  return (qu);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c"
static void query_submit___10(adns_state ads___7 , adns_query qu , typeinfo const   *typei ,
                              vbuf *qumsg_vb , int id , adns_queryflags flags , struct timeval now ) 
{ 
  void *tmp ;

  {
  {
#line 98
  qu->vb = *qumsg_vb;
#line 99
  adns__vbuf_init(qumsg_vb);
#line 101
  tmp = malloc((size_t )qu->vb.used);
#line 101
  qu->query_dgram = (byte *)tmp;
  }
#line 102
  if (! qu->query_dgram) {
    {
#line 102
    adns__query_fail(qu, (adns_status )1);
    }
#line 102
    return;
  }
  {
#line 104
  qu->id = id;
#line 105
  qu->query_dglen = qu->vb.used;
#line 106
  memcpy((void */* __restrict  */)qu->query_dgram, (void const   */* __restrict  */)qu->vb.buf,
         (size_t )qu->vb.used);
#line 108
  adns__query_send(qu, now);
  }
#line 109
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c"
static void query_simple___10(adns_state ads___7 , adns_query qu , char const   *owner ,
                              int ol , typeinfo const   *typei , adns_queryflags flags ,
                              struct timeval now ) 
{ 
  vbuf vb_new ;
  int id ;
  adns_status stat ;

  {
  {
#line 136
  stat = adns__mkquery(ads___7, & qu->vb, & id, owner, ol, typei, (qu->answer)->type,
                       flags);
  }
#line 138
  if (stat) {
#line 139
    if ((unsigned int )stat == 202U) {
#line 139
      if ((unsigned int )flags & 1U) {
        {
#line 140
        adns__search_next(ads___7, qu, now);
        }
#line 141
        return;
      } else {
        {
#line 143
        adns__query_fail(qu, stat);
        }
#line 144
        return;
      }
    } else {
      {
#line 143
      adns__query_fail(qu, stat);
      }
#line 144
      return;
    }
  }
  {
#line 148
  vb_new = qu->vb;
#line 149
  adns__vbuf_init(& qu->vb);
#line 150
  query_submit___10(ads___7, qu, typei, & vb_new, id, flags, now);
  }
#line 151
  return;
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c"
static int save_owner___10(adns_query qu , char const   *owner , int ol ) 
{ 
  adns_answer *ans ;
  void *tmp ;

  {
#line 198
  if (! (qu->flags & 4)) {
#line 198
    return (1);
  }
#line 200
  ans = qu->answer;
#line 201
  if (! (! ans->owner)) {
    {
#line 201
    __assert_fail("!ans->owner", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c",
                  201U, "save_owner");
    }
  }
  {
#line 203
  tmp = adns__alloc_preserved(qu, (size_t )(ol + 1));
#line 203
  ans->owner = (char *)tmp;
  }
#line 203
  if (! ans->owner) {
#line 203
    return (0);
  }
  {
#line 205
  memcpy((void */* __restrict  */)ans->owner, (void const   */* __restrict  */)owner,
         (size_t )ol);
#line 206
  *(ans->owner + ol) = (char)0;
  }
#line 207
  return (1);
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c"
static void *alloc_common___10(adns_query qu , size_t sz ) 
{ 
  allocnode *an ;
  void *tmp ;

  {
#line 342
  if (! sz) {
#line 342
    return ((void *)qu);
  }
#line 343
  if (! (! qu->final_allocspace)) {
    {
#line 343
    __assert_fail("!qu->final_allocspace", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c",
                  343U, "alloc_common");
    }
  }
  {
#line 344
  tmp = malloc((((((((sizeof(*an) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ) + sz) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ));
#line 344
  an = (allocnode *)tmp;
  }
#line 345
  if (! an) {
#line 345
    return ((void *)0);
  }
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 346
    an->next = (struct allocnode *)0;
#line 346
    an->back = qu->allocations.tail;
#line 346
    if (qu->allocations.tail) {
#line 346
      (qu->allocations.tail)->next = an;
    } else {
#line 346
      qu->allocations.head = an;
    }
#line 346
    qu->allocations.tail = an;
#line 346
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 347
  return ((void *)((byte *)an + (((sizeof(*an) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign )));
}
}
#line 410 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c"
static void cancel_children___10(adns_query qu ) 
{ 
  adns_query cqu ;
  adns_query ncqu ;

  {
#line 413
  cqu = qu->children.head;
  {
#line 413
  while (1) {
    while_continue: /* CIL Label */ ;
#line 413
    if (! cqu) {
#line 413
      goto while_break;
    }
    {
#line 414
    ncqu = cqu->siblings.next;
#line 415
    adns_cancel(cqu);
#line 413
    cqu = ncqu;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 417
  return;
}
}
#line 427 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c"
static void free_query_allocs___10(adns_query qu ) 
{ 
  allocnode *an ;
  allocnode *ann ;
  allocnode *tmp ;

  {
  {
#line 430
  cancel_children___10(qu);
#line 431
  an = qu->allocations.head;
  }
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    if (! an) {
#line 431
      goto while_break;
    }
    {
#line 431
    ann = an->next;
#line 431
    free((void *)an);
#line 431
    an = ann;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 432
  tmp = (allocnode *)0;
#line 432
  qu->allocations.tail = tmp;
#line 432
  qu->allocations.head = tmp;
#line 433
  adns__vbuf_free(& qu->vb);
#line 434
  adns__vbuf_free(& qu->search_vb);
#line 435
  free((void *)qu->query_dgram);
#line 436
  qu->query_dgram = (byte *)0;
  }
#line 437
  return;
}
}
#line 477 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c"
static void makefinal_query___10(adns_query qu ) 
{ 
  adns_answer *ans ;
  int rrn ;
  void *tmp ;

  {
#line 481
  ans = qu->answer;
#line 483
  if (qu->interim_allocd) {
    {
#line 484
    tmp = realloc((void *)qu->answer, (((((((sizeof(*ans) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ) + (unsigned long )qu->interim_allocd) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ));
#line 484
    ans = (adns_answer *)tmp;
    }
#line 486
    if (! ans) {
#line 486
      goto x_nomem;
    }
#line 487
    qu->answer = ans;
  }
  {
#line 490
  qu->final_allocspace = (void *)((byte *)ans + (((sizeof(*ans) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ));
#line 491
  adns__makefinal_str(qu, & ans->cname);
#line 492
  adns__makefinal_str(qu, & ans->owner);
  }
#line 494
  if (ans->nrrs) {
    {
#line 495
    adns__makefinal_block(qu, & ans->rrs.untyped, (size_t )(ans->nrrs * ans->rrsz));
#line 497
    rrn = 0;
    }
    {
#line 497
    while (1) {
      while_continue: /* CIL Label */ ;
#line 497
      if (! (rrn < ans->nrrs)) {
#line 497
        goto while_break;
      }
      {
#line 498
      (*((qu->typei)->makefinal))(qu, (void *)(ans->rrs.bytes + rrn * ans->rrsz));
#line 497
      rrn ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 501
  free_query_allocs___10(qu);
  }
#line 502
  return;
  x_nomem: 
  {
#line 505
  qu->preserved_allocd = 0;
#line 506
  (qu->answer)->cname = (char *)0;
#line 507
  (qu->answer)->owner = (char *)0;
#line 508
  adns__reset_preserved(qu);
#line 510
  (qu->answer)->status = (adns_status )1;
#line 511
  free_query_allocs___10(qu);
  }
#line 512
  return;
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/transmit.c"
static adns_status mkquery_header___10(adns_state ads___7 , vbuf *vb___0 , int *id_r ,
                                       int qdlen ) 
{ 
  int id ;
  byte *rqp ;
  int tmp ;
  int tmp___0 ;
  byte *tmp___1 ;
  byte *tmp___2 ;
  byte *tmp___3 ;
  byte *tmp___4 ;
  byte *tmp___5 ;
  byte *tmp___6 ;
  byte *tmp___7 ;
  byte *tmp___8 ;
  byte *tmp___9 ;
  byte *tmp___10 ;
  byte *tmp___11 ;
  byte *tmp___12 ;

  {
  {
#line 46
  tmp = adns__vbuf_ensure(vb___0, (12 + qdlen) + 4);
  }
#line 46
  if (! tmp) {
#line 46
    return ((adns_status )1);
  }
#line 48
  vb___0->used = 0;
#line 49
  rqp = vb___0->buf + vb___0->used;
#line 51
  tmp___0 = ads___7->nextid;
#line 51
  (ads___7->nextid) ++;
#line 51
  id = tmp___0 & 65535;
#line 51
  *id_r = id;
#line 52
  tmp___1 = rqp;
#line 52
  rqp ++;
#line 52
  *tmp___1 = (byte )((id >> 8) & 255);
#line 52
  tmp___2 = rqp;
#line 52
  rqp ++;
#line 52
  *tmp___2 = (byte )(id & 255);
#line 53
  tmp___3 = rqp;
#line 53
  rqp ++;
#line 53
  *tmp___3 = (byte )1;
#line 54
  tmp___4 = rqp;
#line 54
  rqp ++;
#line 54
  *tmp___4 = (byte )0;
#line 55
  tmp___5 = rqp;
#line 55
  rqp ++;
#line 55
  *tmp___5 = (byte )((1 >> 8) & 255);
#line 55
  tmp___6 = rqp;
#line 55
  rqp ++;
#line 55
  *tmp___6 = (byte )1;
#line 56
  tmp___7 = rqp;
#line 56
  rqp ++;
#line 56
  *tmp___7 = (byte )0;
#line 56
  tmp___8 = rqp;
#line 56
  rqp ++;
#line 56
  *tmp___8 = (byte )0;
#line 57
  tmp___9 = rqp;
#line 57
  rqp ++;
#line 57
  *tmp___9 = (byte )0;
#line 57
  tmp___10 = rqp;
#line 57
  rqp ++;
#line 57
  *tmp___10 = (byte )0;
#line 58
  tmp___11 = rqp;
#line 58
  rqp ++;
#line 58
  *tmp___11 = (byte )0;
#line 58
  tmp___12 = rqp;
#line 58
  rqp ++;
#line 58
  *tmp___12 = (byte )0;
#line 60
  vb___0->used = (int )(rqp - vb___0->buf);
#line 62
  return ((adns_status )0);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/transmit.c"
static adns_status mkquery_footer___10(vbuf *vb___0 , adns_rrtype type ) 
{ 
  byte *rqp ;
  byte *tmp ;
  byte *tmp___0 ;
  byte *tmp___1 ;
  byte *tmp___2 ;

  {
#line 68
  rqp = vb___0->buf + vb___0->used;
#line 69
  tmp = rqp;
#line 69
  rqp ++;
#line 69
  *tmp = (byte )((((unsigned int )type & 65535U) >> 8) & 255U);
#line 69
  tmp___0 = rqp;
#line 69
  rqp ++;
#line 69
  *tmp___0 = (byte )(((unsigned int )type & 65535U) & 255U);
#line 70
  tmp___1 = rqp;
#line 70
  rqp ++;
#line 70
  *tmp___1 = (byte )((1 >> 8) & 255);
#line 70
  tmp___2 = rqp;
#line 70
  rqp ++;
#line 70
  *tmp___2 = (byte )1;
#line 71
  vb___0->used = (int )(rqp - vb___0->buf);
#line 72
  if (! (vb___0->used <= vb___0->avail)) {
    {
#line 72
    __assert_fail("vb->used <= vb->avail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/transmit.c",
                  72U, "mkquery_footer");
    }
  }
#line 74
  return ((adns_status )0);
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/transmit.c"
static void query_usetcp___10(adns_query qu , struct timeval now ) 
{ 


  {
  {
#line 244
  qu->state = (enum __anonenum_state_83 )1;
#line 245
  qu->timeout = now;
#line 246
  timevaladd___18(& qu->timeout, 30000L);
  }
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    qu->next = (adns_query )0;
#line 247
    qu->back = (qu->ads)->tcpw.tail;
#line 247
    if ((qu->ads)->tcpw.tail) {
#line 247
      ((qu->ads)->tcpw.tail)->next = qu;
    } else {
#line 247
      (qu->ads)->tcpw.head = qu;
    }
#line 247
    (qu->ads)->tcpw.tail = qu;
#line 247
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 248
  adns__querysend_tcp(qu, now);
#line 249
  adns__tcp_tryconnect(qu->ads, now);
  }
#line 250
  return;
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-opts.c"
static struct optioninfo  const  global_options___2[17]  = 
#line 38 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-opts.c"
  {      {(enum oi_type )1, "global binary options:", (char const   *)0, (char const   *)0,
      (int *)0, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )2, "Do not look at environment variables at all", "e", "env",
      & ov_env, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )2, "Read queries on stdin instead of using args", "f", "pipe",
      & ov_pipe, 1, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )2, "Allow answers to be reordered", "a", "asynch", & ov_asynch,
      1, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )1, "answer/error output format and destination (see below):",
      (char const   *)0, (char const   *)0, (int *)0, 0, (optfunc *)0, (char const   *)0,
      (char const   *)0}, 
        {(enum oi_type )3, "Answers to stdout, errors as messages to stderr (default)",
      "Fs", "fmt-simple", & ov_format, 1, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )3,
      "Answers and errors both to stdout in parseable format", "Fi", "fmt-inline",
      & ov_format, 2, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )3, "Fully-parseable output format (default for --asynch)", "Fa",
      "fmt-asynch", & ov_format, 3, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )1,
      "global verbosity level:", (char const   *)0, (char const   *)0, (int *)0, 0,
      (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )3, "Do not print anything to stderr", "Vq", "quiet", & ov_verbose,
      2, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )3, "Report unexpected kinds of problem only  (default)", "Vn",
      "no-quiet", & ov_verbose, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )3,
      "Debugging mode", "Vd", "debug", & ov_verbose, 8, (optfunc *)0, (char const   *)0,
      (char const   *)0}, 
        {(enum oi_type )1, "other global options:", (char const   *)0, (char const   *)0,
      (int *)0, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )5, "Configuration to use instead of /etc/resolv.conf", (char const   *)0,
      "config", (int *)0, 0, & of_config, "<config-text>", (char const   *)0}, 
        {(enum oi_type )4, "Print version number", (char const   *)0, "version", (int *)0,
      0, & of_version, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )4, "Print usage information", (char const   *)0, "help", (int *)0,
      0, & of_help, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )0, (char const   *)0, (char const   *)0, (char const   *)0, (int *)0,
      0, (optfunc *)0, (char const   *)0, (char const   *)0}};
#line 74 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-opts.c"
static struct optioninfo  const  perquery_options___2[25]  = 
#line 74
  {      {(enum oi_type )1, "per-query options:", (char const   *)0, (char const   *)0,
      (int *)0, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )5, "Query type (see below)", "t", "type", (int *)0, 0, & of_type,
      "type", (char const   *)0}, 
        {(enum oi_type )5, "Do reverse query (address -> name lookup)", "i", "ptr", (int *)0,
      0, & of_ptr, "addr", (char const   *)0}, 
        {(enum oi_type )6, "Lookup in in-addr-like `zone\' (eg MAPS RBL)", (char const   *)0,
      "reverse", (int *)0, 0, & of_reverse, "addr", "zone"}, 
        {(enum oi_type )1, "per-query binary options:", (char const   *)0, (char const   *)0,
      (int *)0, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )2, "Use the search list", "s", "search", & ov_search, 1, (optfunc *)0,
      (char const   *)0, (char const   *)0}, 
        {(enum oi_type )2, "Let query domains contain quote-requiring chars", "Qq", "qc-query",
      & ov_qc_query, 1, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )2, "Let hostnames in answers contain ...", "Qa", "qc-anshost",
      & ov_qc_anshost, 1, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )2, "Prevent CNAME target domains from containing ...", "Qc",
      "qc-cname", & ov_qc_cname, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )2,
      "Force use of a virtual circuit", "u", "tcp", & ov_tcp, 1, (optfunc *)0, (char const   *)0,
      (char const   *)0}, 
        {(enum oi_type )2, "Do not display owner name in output", "Do", "show-owner",
      & ov_pqfr.show_owner, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )2,
      "Do not display RR type in output", "Dt", "show-type", & ov_pqfr.show_type,
      0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )2, "Do not display CNAME target in output", "Dc", "show-cname",
      & ov_pqfr.show_cname, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )1,
      "per-query TTL mode (NB TTL is minimum across all info in reply):", (char const   *)0,
      (char const   *)0, (int *)0, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )3,
      "Show the TTL as a TTL", "Tt", "ttl-ttl", & ov_pqfr.ttl, 1, (optfunc *)0, (char const   *)0,
      (char const   *)0}, 
        {(enum oi_type )3, "Show the TTL as a time_t when the data might expire", "Ta",
      "ttl-abs", & ov_pqfr.ttl, 2, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )3,
      "Do not show the TTL (default)", "Tn", "no-ttl", & ov_pqfr.ttl, 0, (optfunc *)0,
      (char const   *)0, (char const   *)0}, 
        {(enum oi_type )1, "per-query CNAME handling mode:", (char const   *)0, (char const   *)0,
      (int *)0, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )3, "Call it an error if a CNAME is found", "Cf", "cname-reject",
      & ov_cname, 512, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )3, "Allow references to CNAMEs in other RRs", "Cl", "cname-loose",
      & ov_cname, 256, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )3, "CNAME ok for query domain, but not in RRs (default)", "Cs",
      "cname-ok", & ov_cname, 0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )1,
      "asynchronous/pipe mode options:", (char const   *)0, (char const   *)0, (int *)0,
      0, (optfunc *)0, (char const   *)0, (char const   *)0}, 
        {(enum oi_type )5, "Set <id>, default is decimal sequence starting 0", (char const   *)0,
      "asynch-id", (int *)0, 0, & of_asynch_id, "id", (char const   *)0}, 
        {(enum oi_type )5, "Cancel the query with id <id> (no error if not found)", (char const   *)0,
      "cancel-id", (int *)0, 0, & of_cancel_id, "id", (char const   *)0}, 
        {(enum oi_type )0, (char const   *)0, (char const   *)0, (char const   *)0, (int *)0,
      0, (optfunc *)0, (char const   *)0, (char const   *)0}};
#line 127
static void printusage___2(void) ;
#line 127 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-opts.c"
static struct optioninfo  const  * const  all_optiontables___2[3]  = {      (struct optioninfo  const  */* const  */)(global_options___2),      (struct optioninfo  const  */* const  */)(perquery_options___2),      (struct optioninfo  const  */* const  */)0};
#line 126 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-opts.c"
static void printusage___2(void) 
{ 
  struct optioninfo  const  * const  *oiap ;
  struct optioninfo  const  *oip ;
  int maxsopt ;
  int maxlopt ;
  int l ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  int tmp___13 ;

  {
#line 131
  oip = (struct optioninfo  const  *)0;
#line 134
  maxlopt = 0;
#line 134
  maxsopt = maxlopt;
#line 136
  oiap = all_optiontables___2;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (! *oiap) {
#line 136
      goto while_break;
    }
#line 137
    oip = (struct optioninfo  const  *)*oiap;
    {
#line 137
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 137
      if (! ((unsigned int const   )oip->type != 0U)) {
#line 137
        goto while_break___0;
      }
#line 138
      if ((unsigned int const   )oip->type == 5U) {
#line 138
        goto __Cont;
      }
#line 139
      if (oip->sopt) {
        {
#line 139
        tmp = strlen((char const   *)oip->sopt);
#line 139
        l = (int )tmp;
        }
#line 139
        if (l > maxsopt) {
#line 139
          maxsopt = l;
        }
      }
#line 140
      if (oip->lopt) {
        {
#line 141
        tmp___0 = strlen((char const   *)oip->lopt);
#line 141
        l = (int )tmp___0;
        }
#line 142
        if ((unsigned int const   )oip->type == 2U) {
#line 142
          if (! oip->value) {
#line 142
            l += 3;
          }
        }
#line 143
        if (l > maxlopt) {
#line 143
          maxlopt = l;
        }
      }
      __Cont: /* CIL Label */ 
#line 137
      oip ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 136
    oiap ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 148
  fputs((char const   */* __restrict  */)"usage: adnshost [global-opts] [query-opts] query-domain\n                             [[query-opts] query-domain ...]\n       adnshost [global-opts] [query-opts] -f|--pipe\n",
        (FILE */* __restrict  */)stdout);
#line 153
  oiap = all_optiontables___2;
  }
  {
#line 153
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 153
    if (! *oiap) {
#line 153
      goto while_break___1;
    }
    {
#line 154
    putchar('\n');
#line 155
    oip = (struct optioninfo  const  *)*oiap;
    }
    {
#line 155
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 155
      if (! ((unsigned int const   )oip->type != 0U)) {
#line 155
        goto while_break___2;
      }
      {
#line 157
      if ((unsigned int const   )oip->type == 2U) {
#line 157
        goto case_2;
      }
#line 171
      if ((unsigned int const   )oip->type == 4U) {
#line 171
        goto case_4;
      }
#line 171
      if ((unsigned int const   )oip->type == 3U) {
#line 171
        goto case_4;
      }
#line 183
      if ((unsigned int const   )oip->type == 5U) {
#line 183
        goto case_5;
      }
#line 200
      if ((unsigned int const   )oip->type == 6U) {
#line 200
        goto case_6;
      }
#line 209
      if ((unsigned int const   )oip->type == 1U) {
#line 209
        goto case_1;
      }
#line 212
      goto switch_default;
      case_2: /* CIL Label */ 
#line 158
      if (! oip->value) {
#line 159
        if (oip->sopt) {
          {
#line 160
          printf((char const   */* __restrict  */)" +%-*s --no-%-*s %s\n", maxsopt,
                 oip->sopt, maxlopt - 2, oip->lopt, oip->desc);
          }
        } else {
          {
#line 165
          printf((char const   */* __restrict  */)" --no-%-*s %s\n", (maxlopt + maxsopt) + 1,
                 oip->lopt, oip->desc);
          }
        }
#line 169
        goto switch_break;
      }
      case_4: /* CIL Label */ 
      case_3: /* CIL Label */ 
#line 172
      if (oip->sopt) {
        {
#line 173
        printf((char const   */* __restrict  */)" -%-*s --%-*s %s\n", maxsopt, oip->sopt,
               maxlopt + 1, oip->lopt, oip->desc);
        }
      } else {
        {
#line 178
        printf((char const   */* __restrict  */)" --%-*s %s\n", (maxlopt + maxsopt) + 3,
               oip->lopt, oip->desc);
        }
      }
#line 182
      goto switch_break;
      case_5: /* CIL Label */ 
#line 184
      if (oip->sopt) {
        {
#line 185
        tmp___1 = strlen((char const   *)oip->sopt);
#line 185
        tmp___2 = strlen((char const   *)oip->lopt);
#line 185
        tmp___3 = strlen((char const   *)oip->argdesc);
#line 185
        l = (int )((size_t )((maxlopt + maxsopt) - 9) - ((tmp___1 + tmp___2) + 2UL * tmp___3));
        }
#line 187
        if (l > 2) {
#line 187
          tmp___4 = l;
        } else {
#line 187
          tmp___4 = 2;
        }
        {
#line 187
        printf((char const   */* __restrict  */)" -%s<%s> / --%s <%s>%*s%s\n", oip->sopt,
               oip->argdesc, oip->lopt, oip->argdesc, tmp___4, "", oip->desc);
        }
      } else {
        {
#line 192
        tmp___5 = strlen((char const   *)oip->lopt);
#line 192
        tmp___6 = strlen((char const   *)oip->argdesc);
#line 192
        l = (int )((size_t )((maxlopt + maxsopt) + 1) - (tmp___5 + tmp___6));
        }
#line 194
        if (l > 2) {
#line 194
          tmp___7 = l;
        } else {
#line 194
          tmp___7 = 2;
        }
        {
#line 194
        printf((char const   */* __restrict  */)" --%s <%s>%*s%s\n", oip->lopt, oip->argdesc,
               tmp___7, "", oip->desc);
        }
      }
#line 199
      goto switch_break;
      case_6: /* CIL Label */ 
#line 201
      if (! (! oip->sopt)) {
        {
#line 201
        __assert_fail("!oip->sopt", "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-opts.c",
                      201U, "printusage");
        }
      }
      {
#line 202
      tmp___8 = strlen((char const   *)oip->lopt);
#line 202
      tmp___9 = strlen((char const   *)oip->argdesc);
#line 202
      tmp___10 = strlen((char const   *)oip->argdesc2);
#line 202
      l = (int )((size_t )((maxlopt + maxsopt) - 2) - ((tmp___8 + tmp___9) + tmp___10));
      }
#line 204
      if (l > 2) {
#line 204
        tmp___11 = l;
      } else {
#line 204
        tmp___11 = 2;
      }
      {
#line 204
      printf((char const   */* __restrict  */)" --%s <%s> <%s>%*s%s\n", oip->lopt,
             oip->argdesc, oip->argdesc2, tmp___11, "", oip->desc);
      }
#line 208
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 210
      printf((char const   */* __restrict  */)"%s\n", oip->desc);
      }
#line 211
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 213
      abort();
      }
      switch_break: /* CIL Label */ ;
      }
#line 155
      oip ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 153
    oiap ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 218
  printf((char const   */* __restrict  */)"\nEscaping domains which might start with `-\':\n - %-*s Next argument is a domain, but more options may follow\n",
         (maxlopt + maxsopt) + 3, "<domain>");
#line 222
  fputs((char const   */* __restrict  */)"\nQuery domains should always be quoted according to master file format.\n\nFor binary options, --FOO and --no-FOO are opposites, as are\n-X and +X.  In each case the default is the one not listed.\nPer query options stay set a particular way until they are reset,\nwhether they appear on the command line or on stdin.\nAll global options must preceed the first query domain.\n\nWith -f, the input should be lines with either an option, possibly\nwith a value argument (separated from the option by a space if it\'s a long\noption), or a domain (possibly preceded by a hyphen and a space to\ndistinguish it from an option).\n\nOutput format is master file format without class or TTL by default:\n   [<owner>] [<ttl>] [<type>] <data>\nor if the <owner> domain refers to a CNAME and --show-cname is on\n   [<owner>] [<ttl>] CNAME <cname>\n   [<cname>] [<ttl>] <type> <data>\nWhen a query fails you get an error message to stderr (with --fmt-simple).\nSpecify --fmt-inline for lines like this (broken here for readability):\n   ; failed <statustype> <statusnum> <statusabbrev> \\\n       [<owner>] [<ttl>] [<cname>] \"<status string>\"\nIf you use --fmt-asynch, which is the default for --asynch,\neach answer (success or failure) is preceded by a line\n   <id> <nrrs> <statustype> <statusnum> <statusabbrev> \\\n       [<owner>] [<ttl>] [<cname>] \"<status string>\"\nwhere <nrrs> is the number of RRs that follow and <cname> will be `$\' or\nthe CNAME target; the CNAME indirection and error formats above are not used.\n\nExit status:\n 0    all went well\n 1-6  at least one query failed with statustype:\n   1    localfail   )\n   2    remotefail  ) temporary errors\n   3    tempfail  __)_________________\n   4    misconfig   )\n   5    misquery    ) permanent errors\n   6    permfail    )\n 10   system trouble\n 11   usage problems\n\nQuery types (see adns.h; default is addr):\n  ns  soa  ptr  mx  rp  srv  addr       - enhanced versions\n  cname  hinfo  txt                     - types with only one version\n  a  ns-  soa-  ptr-  mx-  rp-  srv-    - _raw versions\n  type<number>                          - `unknown\' type, RFC3597\nDefault is addr, or ptr for -i/--ptr queries\n",
        (FILE */* __restrict  */)stdout);
#line 271
  tmp___13 = ferror(stdout);
  }
#line 271
  if (tmp___13) {
    {
#line 271
    tmp___12 = __errno_location();
#line 271
    sysfail("write usage message", *tmp___12);
    }
  }
#line 272
  return;
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-opts.c"
static int oc_long___2(char const   **optp , struct optioninfo  const  *entry ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 287
  if (entry->lopt) {
    {
#line 287
    tmp = strcmp(*optp, (char const   *)entry->lopt);
    }
#line 287
    if (tmp) {
#line 287
      tmp___0 = 0;
    } else {
#line 287
      tmp___0 = 1;
    }
  } else {
#line 287
    tmp___0 = 0;
  }
#line 287
  return (tmp___0);
}
}
#line 290 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-opts.c"
static int oc_short___2(char const   **optp , struct optioninfo  const  *entry ) 
{ 
  char const   *sopt ;
  int l ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 294
  sopt = (char const   *)entry->sopt;
#line 295
  if (! sopt) {
#line 295
    return (0);
  }
  {
#line 296
  tmp = strlen(sopt);
#line 296
  l = (int )tmp;
#line 297
  tmp___0 = memcmp((void const   *)*optp, (void const   *)sopt, (size_t )l);
  }
#line 297
  if (tmp___0) {
#line 297
    return (0);
  }
#line 298
  *optp += l;
#line 299
  return (1);
}
}
#line 302 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-opts.c"
static struct optioninfo  const  *find1___2(char const   **optp , struct optioninfo  const  *table ,
                                            comparer_type *comparer___3 ) 
{ 
  int tmp ;

  {
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;
#line 306
    if ((unsigned int const   )table->type == 0U) {
#line 306
      return ((struct optioninfo  const  *)0);
    }
    {
#line 307
    tmp = (*comparer___3)(optp, table);
    }
#line 307
    if (tmp) {
#line 307
      return (table);
    }
#line 308
    table ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-opts.c"
static struct optioninfo  const  *find___2(char const   **optp , char const   *prefix ,
                                           comparer_type *comparer___3 ) 
{ 
  struct optioninfo  const  *oip ;
  char const   *opt ;

  {
  {
#line 318
  opt = *optp;
#line 319
  oip = find1___2(optp, perquery_options___2, comparer___3);
  }
#line 320
  if (oip) {
#line 320
    return (oip);
  }
  {
#line 321
  oip = find1___2(optp, global_options___2, comparer___3);
  }
#line 322
  if (! oip) {
    {
#line 322
    usageerr("unknown option %s%s", prefix, opt);
    }
  }
#line 323
  if (ads) {
    {
#line 323
    usageerr("global option %s%s specified after query domain(s)", prefix, opt);
    }
  }
#line 324
  return (oip);
}
}
#line 330
static  __attribute__((__noreturn__)) void noninvert___2(struct optioninfo  const  *oip ) ;
#line 331
static  __attribute__((__noreturn__)) void noninvert___2(struct optioninfo  const  *oip ) ;
#line 331 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-opts.c"
static void noninvert___2(struct optioninfo  const  *oip ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 332
  if (oip->lopt) {
#line 332
    tmp = oip->lopt;
  } else {
#line 332
    tmp = (char const   */* const  */)"";
  }
#line 332
  if (oip->lopt) {
#line 332
    tmp___0 = "--";
  } else {
#line 332
    tmp___0 = "";
  }
#line 332
  if (oip->lopt) {
#line 332
    if (oip->sopt) {
#line 332
      tmp___1 = " / ";
    } else {
#line 332
      tmp___1 = "";
    }
  } else {
#line 332
    tmp___1 = "";
  }
#line 332
  if (oip->sopt) {
#line 332
    tmp___2 = oip->sopt;
  } else {
#line 332
    tmp___2 = (char const   */* const  */)"";
  }
#line 332
  if (oip->sopt) {
#line 332
    tmp___3 = "-";
  } else {
#line 332
    tmp___3 = "";
  }
  {
#line 332
  usageerr("option %s%s%s%s%s may not be inverted", tmp___3, tmp___2, tmp___1, tmp___0,
           tmp);
  }
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c"
static void tcp_close___10(adns_state ads___7 ) 
{ 
  int serv ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 48
  serv = ads___7->tcpserver;
#line 49
  close(ads___7->tcpsocket);
#line 50
  ads___7->tcpsocket = -1;
#line 51
  tmp___0 = 0;
#line 51
  ads___7->tcpsend.used = tmp___0;
#line 51
  tmp = tmp___0;
#line 51
  ads___7->tcprecv_skip = tmp;
#line 51
  ads___7->tcprecv.used = tmp;
  }
#line 52
  return;
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c"
static void tcp_connected___10(adns_state ads___7 , struct timeval now ) 
{ 
  adns_query qu ;
  adns_query nqu ;

  {
  {
#line 76
  adns__debug(ads___7, ads___7->tcpserver, (adns_query )0, "TCP connected");
#line 77
  ads___7->tcpstate = (enum adns__tcpstate )2;
#line 78
  qu = ads___7->tcpw.head;
  }
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (qu) {
#line 78
      if (! ((unsigned int )ads___7->tcpstate == 2U)) {
#line 78
        goto while_break;
      }
    } else {
#line 78
      goto while_break;
    }
#line 79
    nqu = qu->next;
#line 80
    if (! ((unsigned int )qu->state == 1U)) {
      {
#line 80
      __assert_fail("qu->state == query_tcpw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c",
                    80U, "tcp_connected");
      }
    }
    {
#line 81
    adns__querysend_tcp(qu, now);
#line 78
    qu = nqu;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c"
static void tcp_broken_events___10(adns_state ads___7 ) 
{ 
  adns_query qu ;
  adns_query nqu ;

  {
#line 88
  if (! ((unsigned int )ads___7->tcpstate == 3U)) {
    {
#line 88
    __assert_fail("ads->tcpstate == server_broken", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c",
                  88U, "tcp_broken_events");
    }
  }
#line 89
  qu = ads___7->tcpw.head;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! qu) {
#line 89
      goto while_break;
    }
#line 90
    nqu = qu->next;
#line 91
    if (! ((unsigned int )qu->state == 1U)) {
      {
#line 91
      __assert_fail("qu->state == query_tcpw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c",
                    91U, "tcp_broken_events");
      }
    }
#line 92
    if (qu->retries > ads___7->nservers) {
      {
#line 93
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 93
        if (qu->back) {
#line 93
          (qu->back)->next = qu->next;
        } else {
#line 93
          ads___7->tcpw.head = qu->next;
        }
#line 93
        if (qu->next) {
#line 93
          (qu->next)->back = qu->back;
        } else {
#line 93
          ads___7->tcpw.tail = qu->back;
        }
#line 93
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 94
      adns__query_fail(qu, (adns_status )31);
      }
    }
#line 89
    qu = nqu;
  }
  while_break: /* CIL Label */ ;
  }
#line 97
  ads___7->tcpstate = (enum adns__tcpstate )0;
#line 98
  return;
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c"
static void inter_immed___10(struct timeval **tv_io , struct timeval *tvbuf ) 
{ 
  struct timeval *rbuf ;
  __suseconds_t tmp ;

  {
#line 174
  if (! tv_io) {
#line 174
    return;
  }
#line 176
  rbuf = *tv_io;
#line 177
  if (! rbuf) {
#line 177
    rbuf = tvbuf;
#line 177
    *tv_io = rbuf;
  }
#line 179
  tmp = (__suseconds_t )0;
#line 179
  rbuf->tv_usec = tmp;
#line 179
  rbuf->tv_sec = tmp;
#line 180
  return;
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c"
static void inter_maxto___10(struct timeval **tv_io , struct timeval *tvbuf , struct timeval maxto ) 
{ 
  struct timeval *rbuf ;
  int tmp ;

  {
#line 186
  if (! tv_io) {
#line 186
    return;
  }
#line 187
  rbuf = *tv_io;
#line 188
  if (! rbuf) {
#line 189
    *tvbuf = maxto;
#line 189
    *tv_io = tvbuf;
  } else {
#line 191
    if (rbuf->tv_sec == maxto.tv_sec) {
#line 191
      tmp = rbuf->tv_usec > maxto.tv_usec;
    } else {
#line 191
      tmp = rbuf->tv_sec > maxto.tv_sec;
    }
#line 191
    if (tmp) {
#line 191
      *rbuf = maxto;
    }
  }
#line 195
  return;
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c"
static void inter_maxtoabs___10(struct timeval **tv_io , struct timeval *tvbuf , struct timeval now ,
                                struct timeval maxtime ) 
{ 
  ldiv_t dr ;

  {
#line 204
  if (! tv_io) {
#line 204
    return;
  }
  {
#line 205
  maxtime.tv_sec -= now.tv_sec + 2L;
#line 206
  maxtime.tv_usec -= now.tv_usec - 2000000L;
#line 207
  dr = ldiv(maxtime.tv_usec, 1000000L);
#line 208
  maxtime.tv_sec += dr.quot;
#line 209
  maxtime.tv_usec -= dr.quot * 1000000L;
  }
#line 210
  if (maxtime.tv_sec < 0L) {
#line 210
    maxtime.tv_usec = (__suseconds_t )0;
#line 210
    maxtime.tv_sec = maxtime.tv_usec;
  }
  {
#line 211
  inter_maxto___10(tv_io, tvbuf, maxtime);
  }
#line 212
  return;
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c"
static void timeouts_queue___10(adns_state ads___7 , int act , struct timeval **tv_io ,
                                struct timeval *tvbuf , struct timeval now , struct query_queue *queue ) 
{ 
  adns_query qu ;
  adns_query nqu ;
  int tmp ;

  {
#line 219
  qu = queue->head;
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if (! qu) {
#line 219
      goto while_break;
    }
#line 220
    nqu = qu->next;
#line 221
    if (now.tv_sec == qu->timeout.tv_sec) {
#line 221
      tmp = now.tv_usec > qu->timeout.tv_usec;
    } else {
#line 221
      tmp = now.tv_sec > qu->timeout.tv_sec;
    }
#line 221
    if (tmp) {
#line 224
      if (! act) {
        {
#line 224
        inter_immed___10(tv_io, tvbuf);
        }
#line 224
        return;
      }
      {
#line 225
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 225
        if (qu->back) {
#line 225
          (qu->back)->next = qu->next;
        } else {
#line 225
          queue->head = qu->next;
        }
#line 225
        if (qu->next) {
#line 225
          (qu->next)->back = qu->back;
        } else {
#line 225
          queue->tail = qu->back;
        }
#line 225
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 226
      if ((unsigned int )qu->state != 0U) {
        {
#line 227
        adns__query_fail(qu, (adns_status )30);
        }
      } else {
        {
#line 229
        adns__query_send(qu, now);
        }
      }
#line 231
      nqu = queue->head;
    } else {
      {
#line 222
      inter_maxtoabs___10(tv_io, tvbuf, now, qu->timeout);
      }
    }
#line 219
    qu = nqu;
  }
  while_break: /* CIL Label */ ;
  }
#line 234
  return;
}
}
#line 236 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c"
static void tcp_events___10(adns_state ads___7 , int act , struct timeval **tv_io ,
                            struct timeval *tvbuf , struct timeval now ) 
{ 
  int tmp ;

  {
  {
#line 239
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 241
    if ((unsigned int )ads___7->tcpstate == 3U) {
#line 241
      goto case_3;
    }
#line 244
    if ((unsigned int )ads___7->tcpstate == 0U) {
#line 244
      goto case_0;
    }
#line 249
    if ((unsigned int )ads___7->tcpstate == 2U) {
#line 249
      goto case_2;
    }
#line 256
    if ((unsigned int )ads___7->tcpstate == 1U) {
#line 256
      goto case_1;
    }
#line 275
    goto switch_default___0;
    case_3: /* CIL Label */ 
#line 242
    if (! act) {
      {
#line 242
      inter_immed___10(tv_io, tvbuf);
      }
#line 242
      return;
    }
    {
#line 243
    tcp_broken_events___10(ads___7);
    }
    case_0: /* CIL Label */ 
#line 245
    if (! ads___7->tcpw.head) {
#line 245
      return;
    }
#line 246
    if (! act) {
      {
#line 246
      inter_immed___10(tv_io, tvbuf);
      }
#line 246
      return;
    }
    {
#line 247
    adns__tcp_tryconnect(ads___7, now);
    }
#line 248
    goto switch_break;
    case_2: /* CIL Label */ 
#line 250
    if (ads___7->tcpw.head) {
#line 250
      return;
    }
#line 251
    if (! ads___7->tcptimeout.tv_sec) {
#line 252
      if (! (! ads___7->tcptimeout.tv_usec)) {
        {
#line 252
        __assert_fail("!ads->tcptimeout.tv_usec", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c",
                      252U, "tcp_events");
        }
      }
      {
#line 253
      ads___7->tcptimeout = now;
#line 254
      timevaladd___18(& ads___7->tcptimeout, 30000L);
      }
    }
    case_1: /* CIL Label */ 
#line 257
    if (! act) {
      {
#line 258
      inter_maxtoabs___10(tv_io, tvbuf, now, ads___7->tcptimeout);
      }
#line 259
      return;
    } else {
#line 257
      if (now.tv_sec == ads___7->tcptimeout.tv_sec) {
#line 257
        tmp = now.tv_usec > ads___7->tcptimeout.tv_usec;
      } else {
#line 257
        tmp = now.tv_sec > ads___7->tcptimeout.tv_sec;
      }
#line 257
      if (! tmp) {
        {
#line 258
        inter_maxtoabs___10(tv_io, tvbuf, now, ads___7->tcptimeout);
        }
#line 259
        return;
      }
    }
    {
#line 263
    if ((unsigned int )ads___7->tcpstate == 1U) {
#line 263
      goto case_1___0;
    }
#line 266
    if ((unsigned int )ads___7->tcpstate == 2U) {
#line 266
      goto case_2___0;
    }
#line 270
    goto switch_default;
    case_1___0: /* CIL Label */ 
    {
#line 264
    adns__tcp_broken(ads___7, "unable to make connection", "timed out");
    }
#line 265
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 267
    tcp_close___10(ads___7);
#line 268
    ads___7->tcpstate = (enum adns__tcpstate )0;
    }
#line 269
    return;
    switch_default: /* CIL Label */ 
    {
#line 271
    abort();
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 274
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
#line 276
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 279
  return;
}
}
#line 516 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c"
static void fd_event___10(adns_state ads___7 , int fd , int revent , int pollflag ,
                          int maxfd , fd_set const   *fds , int (*func)(adns_state  ,
                                                                        int fd , struct timeval  const  *now ) ,
                          struct timeval now , int *r_r ) 
{ 
  int r ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 524
  if (! (revent & pollflag)) {
#line 524
    return;
  }
#line 525
  if (fds) {
#line 525
    if (fd < maxfd) {
#line 525
      if (! ((fds->__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
#line 525
        return;
      }
    } else {
#line 525
      return;
    }
  }
  {
#line 526
  r = (*func)(ads___7, fd, (struct timeval  const  *)(& now));
  }
#line 527
  if (r) {
#line 528
    if (r_r) {
#line 529
      *r_r = r;
    } else {
      {
#line 531
      tmp = __errno_location();
#line 531
      tmp___0 = strerror(*tmp);
#line 531
      adns__diag(ads___7, -1, (adns_query )0, "process fd failed after select: %s",
                 tmp___0);
#line 533
      adns_globalsystemfailure(ads___7);
      }
    }
  }
#line 536
  return;
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-query.c"
static unsigned long idcounter___2  ;
#line 59 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-query.c"
static char buf___16[12]  ;
#line 71 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-query.c"
static void prep_query___2(struct query_node **qun_r , int *quflags_r ) 
{ 
  struct query_node *qun ;
  char idbuf[20] ;
  void *tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 75
  if (ov_pipe) {
#line 75
    if (! ads) {
      {
#line 75
      usageerr("-f/--pipe not consistent with domains on command line");
      }
    }
  }
  {
#line 76
  ensure_adns_init();
#line 78
  tmp = malloc(sizeof(*qun));
#line 78
  qun = (struct query_node *)tmp;
#line 79
  qun->pqfr = ov_pqfr;
  }
#line 80
  if (ov_id) {
    {
#line 81
    qun->id = xstrsave((char const   *)ov_id);
    }
  } else {
    {
#line 83
    tmp___0 = idcounter___2;
#line 83
    idcounter___2 ++;
#line 83
    sprintf((char */* __restrict  */)(idbuf), (char const   */* __restrict  */)"%lu",
            tmp___0);
#line 84
    idcounter___2 &= 4294967295UL;
#line 85
    qun->id = xstrsave((char const   *)(idbuf));
    }
  }
#line 88
  if (ov_search) {
#line 88
    tmp___1 = 1;
  } else {
#line 88
    tmp___1 = 0;
  }
#line 88
  if (ov_tcp) {
#line 88
    tmp___2 = 2;
  } else {
#line 88
    tmp___2 = 0;
  }
#line 88
  if (ov_pqfr.show_owner) {
#line 88
    tmp___3 = 4;
  } else
#line 88
  if (ov_format == 1) {
#line 88
    tmp___3 = 4;
  } else {
#line 88
    tmp___3 = 0;
  }
#line 88
  if (ov_qc_query) {
#line 88
    tmp___4 = 16;
  } else {
#line 88
    tmp___4 = 0;
  }
#line 88
  if (ov_qc_anshost) {
#line 88
    tmp___5 = 64;
  } else {
#line 88
    tmp___5 = 0;
  }
#line 88
  if (ov_qc_cname) {
#line 88
    tmp___6 = 0;
  } else {
#line 88
    tmp___6 = 0;
  }
#line 88
  *quflags_r = (((((tmp___1 | tmp___2) | tmp___3) | tmp___4) | tmp___5) | tmp___6) | ov_cname;
#line 88
  *qun_r = qun;
#line 98
  return;
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-query.c"
static void dequeue_query___2(struct query_node *qun ) 
{ 


  {
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 162
    if (qun->back) {
#line 162
      (qun->back)->next = qun->next;
    } else {
#line 162
      outstanding.head = qun->next;
    }
#line 162
    if (qun->next) {
#line 162
      (qun->next)->back = qun->back;
    } else {
#line 162
      outstanding.tail = qun->back;
    }
#line 162
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 163
  free((void *)qun->id);
#line 164
  free((void *)qun->owner);
#line 165
  free((void *)qun);
  }
#line 166
  return;
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-query.c"
static void print_withspace___2(char const   *str ) 
{ 
  int tmp ;

  {
  {
#line 169
  tmp = printf((char const   */* __restrict  */)"%s ", str);
  }
#line 169
  if (tmp == -1) {
    {
#line 169
    outerr();
    }
  }
#line 170
  return;
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-query.c"
static void print_ttl___2(struct query_node *qun , adns_answer *answer ) 
{ 
  unsigned long ttl ;
  time_t now ;
  int *tmp ;
  time_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 177
  if (qun->pqfr.ttl == 0) {
#line 177
    goto case_0;
  }
#line 179
  if (qun->pqfr.ttl == 1) {
#line 179
    goto case_1;
  }
#line 183
  if (qun->pqfr.ttl == 2) {
#line 183
    goto case_2;
  }
#line 186
  goto switch_default;
  case_0: /* CIL Label */ 
#line 178
  return;
  case_1: /* CIL Label */ 
  {
#line 180
  tmp___0 = time(& now);
  }
#line 180
  if (tmp___0 == -1L) {
    {
#line 180
    tmp = __errno_location();
#line 180
    sysfail("get current time", *tmp);
    }
  }
#line 181
  if (answer->expires < now) {
#line 181
    ttl = 0UL;
  } else {
#line 181
    ttl = (unsigned long )(answer->expires - now);
  }
#line 182
  goto switch_break;
  case_2: /* CIL Label */ 
#line 184
  ttl = (unsigned long )answer->expires;
#line 185
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 187
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 189
  tmp___1 = printf((char const   */* __restrict  */)"%lu ", ttl);
  }
#line 189
  if (tmp___1 == -1) {
    {
#line 189
    outerr();
    }
  }
#line 190
  return;
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-query.c"
static char const   *owner_show___2(struct query_node *qun , adns_answer *answer ) 
{ 
  char *tmp ;

  {
#line 193
  if (answer->owner) {
#line 193
    tmp = answer->owner;
  } else {
#line 193
    tmp = qun->owner;
  }
#line 193
  return ((char const   *)tmp);
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-query.c"
static void print_owner_ttl___2(struct query_node *qun , adns_answer *answer ) 
{ 
  char const   *tmp ;

  {
#line 197
  if (qun->pqfr.show_owner) {
    {
#line 197
    tmp = owner_show___2(qun, answer);
#line 197
    print_withspace___2(tmp);
    }
  }
  {
#line 198
  print_ttl___2(qun, answer);
  }
#line 199
  return;
}
}
#line 202
static void check_status___2(adns_status st ) ;
#line 202 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-query.c"
static adns_status const   statuspoints___2[6]  = {      (adns_status const   )0,      (adns_status const   )29,      (adns_status const   )59,      (adns_status const   )99, 
        (adns_status const   )199,      (adns_status const   )299};
#line 201 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-query.c"
static void check_status___2(adns_status st ) 
{ 
  adns_status const   *spp ;
  int minrcode ;

  {
#line 211
  minrcode = 0;
#line 211
  spp = statuspoints___2;
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 211
    if (! ((unsigned long )spp < (unsigned long )(statuspoints___2 + sizeof(statuspoints___2) / sizeof(statuspoints___2[0])))) {
#line 211
      goto while_break;
    }
#line 214
    if ((unsigned int )st > (unsigned int )*spp) {
#line 214
      minrcode ++;
    }
#line 211
    spp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 215
  if (rcode < minrcode) {
#line 215
    rcode = minrcode;
  }
#line 216
  return;
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-query.c"
static void print_status___2(adns_status st , struct query_node *qun , adns_answer *answer ) 
{ 
  char const   *statustypeabbrev ;
  char const   *statusabbrev ;
  char const   *statusstring ;
  char *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 221
  statustypeabbrev = adns_errtypeabbrev(st);
#line 222
  statusabbrev = adns_errabbrev(st);
#line 223
  statusstring = adns_strerror(st);
#line 224
  tmp = strchr(statusstring, '\"');
  }
#line 224
  if (tmp) {
    {
#line 224
    __assert_fail("!strchr(statusstring,\'\"\')", "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-query.c",
                  224U, "print_status");
    }
  }
  {
#line 226
  tmp___0 = printf((char const   */* __restrict  */)"%s %d %s ", statustypeabbrev,
                   (unsigned int )st, statusabbrev);
  }
#line 226
  if (tmp___0 == -1) {
    {
#line 227
    outerr();
    }
  }
  {
#line 228
  print_owner_ttl___2(qun, answer);
  }
#line 229
  if (qun->pqfr.show_cname) {
#line 230
    if (answer->cname) {
#line 230
      tmp___1 = (char const   *)answer->cname;
    } else {
#line 230
      tmp___1 = "$";
    }
    {
#line 230
    print_withspace___2(tmp___1);
    }
  }
  {
#line 231
  tmp___2 = printf((char const   */* __restrict  */)"\"%s\"\n", statusstring);
  }
#line 231
  if (tmp___2 == -1) {
    {
#line 231
    outerr();
    }
  }
#line 232
  return;
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-query.c"
static void print_dnsfail___2(adns_status st , struct query_node *qun , adns_answer *answer ) 
{ 
  int r ;
  char const   *typename ;
  char const   *statusstring ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int *tmp___3 ;

  {
#line 238
  if (ov_format == 2) {
    {
#line 239
    tmp = fputs((char const   */* __restrict  */)"; failed ", (FILE */* __restrict  */)stdout);
    }
#line 239
    if (tmp == -1) {
      {
#line 239
      outerr();
      }
    }
    {
#line 240
    print_status___2(st, qun, answer);
    }
#line 241
    return;
  }
#line 243
  if (! (ov_format == 1)) {
    {
#line 243
    __assert_fail("ov_format == fmt_simple", "/home/june/repo/benchmarks/collector/temp/adns-1.4/client/adh-query.c",
                  243U, "print_dnsfail");
    }
  }
#line 244
  if ((unsigned int )st == 300U) {
    {
#line 245
    tmp___0 = owner_show___2(qun, answer);
#line 245
    r = fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s does not exist\n",
                tmp___0);
    }
  } else {
    {
#line 247
    type_info(answer->type, & typename, (void const   *)0, (char **)0);
    }
#line 248
    if ((unsigned int )st == 301U) {
      {
#line 249
      tmp___1 = owner_show___2(qun, answer);
#line 249
      r = fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s has no %s record\n",
                  tmp___1, typename);
      }
    } else {
      {
#line 251
      statusstring = adns_strerror(st);
#line 252
      tmp___2 = owner_show___2(qun, answer);
#line 252
      r = fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error during DNS %s lookup for %s: %s\n",
                  typename, tmp___2, statusstring);
      }
    }
  }
#line 256
  if (r == -1) {
    {
#line 256
    tmp___3 = __errno_location();
#line 256
    sysfail("write error message to stderr", *tmp___3);
    }
  }
#line 257
  return;
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void readconfig___10(adns_state ads___7 , char const   *filename , int warnmissing ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void addserver___10(adns_state ads___7 , struct in_addr addr ) 
{ 
  int i ;
  struct server *ss ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 48
  i = 0;
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (i < ads___7->nservers)) {
#line 48
      goto while_break;
    }
#line 49
    if (ads___7->servers[i].addr.s_addr == addr.s_addr) {
      {
#line 50
      tmp = inet_ntoa(addr);
#line 50
      adns__debug(ads___7, -1, (adns_query )0, "duplicate nameserver %s ignored",
                  tmp);
      }
#line 51
      return;
    }
#line 48
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  if (ads___7->nservers >= 5) {
    {
#line 56
    tmp___0 = inet_ntoa(addr);
#line 56
    adns__diag(ads___7, -1, (adns_query )0, "too many nameservers, ignoring %s", tmp___0);
    }
#line 57
    return;
  }
#line 60
  ss = ads___7->servers + ads___7->nservers;
#line 61
  ss->addr = addr;
#line 62
  (ads___7->nservers) ++;
#line 63
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void freesearchlist___10(adns_state ads___7 ) 
{ 


  {
#line 66
  if (ads___7->nsearchlist) {
    {
#line 66
    free((void *)*(ads___7->searchlist));
    }
  }
  {
#line 67
  free((void *)ads___7->searchlist);
  }
#line 68
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void saveerr___10(adns_state ads___7 , int en ) 
{ 


  {
#line 71
  if (! ads___7->configerrno) {
#line 71
    ads___7->configerrno = en;
  }
#line 72
  return;
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void configparseerr___10(adns_state ads___7 , char const   *fn , int lno ,
                                char const   *fmt  , ...) 
{ 
  va_list al ;

  {
  {
#line 78
  saveerr___10(ads___7, 22);
  }
#line 79
  if (! ads___7->logfn) {
#line 79
    return;
  } else
#line 79
  if ((unsigned int )ads___7->iflags & 2U) {
#line 79
    return;
  }
#line 81
  if (lno == -1) {
    {
#line 81
    adns__lprintf(ads___7, "adns: %s: ", fn);
    }
  } else {
    {
#line 82
    adns__lprintf(ads___7, "adns: %s:%d: ", fn, lno);
    }
  }
  {
#line 83
  __builtin_va_start(al, fmt);
#line 84
  adns__vlprintf(ads___7, fmt, al);
#line 85
  __builtin_va_end(al);
#line 86
  adns__lprintf(ads___7, "\n");
  }
#line 87
  return;
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static int nextword___10(char const   **bufp_io , char const   **word_r , int *l_r ) 
{ 
  char const   *p ;
  char const   *q ;
  int tmp ;
  int tmp___0 ;

  {
#line 92
  p = *bufp_io;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 93
    tmp = ctype_whitespace((int )*p);
    }
#line 93
    if (! tmp) {
#line 93
      goto while_break;
    }
#line 93
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  if (! *p) {
#line 94
    return (0);
  }
#line 96
  q = p;
  {
#line 97
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 97
    if (*q) {
      {
#line 97
      tmp___0 = ctype_whitespace((int )*q);
      }
#line 97
      if (tmp___0) {
#line 97
        goto while_break___0;
      }
    } else {
#line 97
      goto while_break___0;
    }
#line 97
    q ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 99
  *l_r = (int )(q - p);
#line 100
  *word_r = p;
#line 101
  *bufp_io = q;
#line 103
  return (1);
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void ccf_nameserver___10(adns_state ads___7 , char const   *fn , int lno ,
                                char const   *buf___17 ) 
{ 
  struct in_addr ia ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 110
  tmp = inet_aton(buf___17, & ia);
  }
#line 110
  if (! tmp) {
    {
#line 111
    configparseerr___10(ads___7, fn, lno, "invalid nameserver address `%s\'", buf___17);
    }
#line 112
    return;
  }
  {
#line 114
  tmp___0 = inet_ntoa(ia);
#line 114
  adns__debug(ads___7, -1, (adns_query )0, "using nameserver %s", tmp___0);
#line 115
  addserver___10(ads___7, ia);
  }
#line 116
  return;
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void ccf_search___10(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  char const   *bufp ;
  char const   *word ;
  char *newchars ;
  char **newptrs ;
  char **pp ;
  int count ;
  int tl ;
  int l ;
  int tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char **tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
#line 124
  if (! buf___17) {
#line 124
    return;
  }
#line 126
  bufp = buf___17;
#line 127
  count = 0;
#line 128
  tl = 0;
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 129
    tmp = nextword___10(& bufp, & word, & l);
    }
#line 129
    if (! tmp) {
#line 129
      goto while_break;
    }
#line 129
    count ++;
#line 129
    tl += l + 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 131
  tmp___0 = malloc(sizeof(char *) * (unsigned long )count);
#line 131
  newptrs = (char **)tmp___0;
  }
#line 132
  if (! newptrs) {
    {
#line 132
    tmp___1 = __errno_location();
#line 132
    saveerr___10(ads___7, *tmp___1);
    }
#line 132
    return;
  }
  {
#line 134
  tmp___2 = malloc((size_t )tl);
#line 134
  newchars = (char *)tmp___2;
  }
#line 135
  if (! newchars) {
    {
#line 135
    tmp___3 = __errno_location();
#line 135
    saveerr___10(ads___7, *tmp___3);
#line 135
    free((void *)newptrs);
    }
#line 135
    return;
  }
#line 137
  bufp = buf___17;
#line 138
  pp = newptrs;
  {
#line 139
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 139
    tmp___6 = nextword___10(& bufp, & word, & l);
    }
#line 139
    if (! tmp___6) {
#line 139
      goto while_break___0;
    }
    {
#line 140
    tmp___4 = pp;
#line 140
    pp ++;
#line 140
    *tmp___4 = newchars;
#line 141
    memcpy((void */* __restrict  */)newchars, (void const   */* __restrict  */)word,
           (size_t )l);
#line 142
    newchars += l;
#line 143
    tmp___5 = newchars;
#line 143
    newchars ++;
#line 143
    *tmp___5 = (char)0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 146
  freesearchlist___10(ads___7);
#line 147
  ads___7->nsearchlist = count;
#line 148
  ads___7->searchlist = newptrs;
  }
#line 149
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void ccf_sortlist___10(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  char const   *word ;
  char tbuf[200] ;
  char *slash ;
  char *ep ;
  struct in_addr base ;
  struct in_addr mask ;
  int l ;
  unsigned long initial ;
  unsigned long baselocal ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  uint32_t tmp___3 ;
  int tmp___4 ;

  {
#line 159
  if (! buf___17) {
#line 159
    return;
  }
#line 161
  ads___7->nsortlist = 0;
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 162
    tmp___4 = nextword___10(& buf___17, & word, & l);
    }
#line 162
    if (! tmp___4) {
#line 162
      goto while_break;
    }
#line 163
    if (ads___7->nsortlist >= 15) {
      {
#line 164
      adns__diag(ads___7, -1, (adns_query )0, "too many sortlist entries, ignoring %.*s onwards",
                 l, word);
      }
#line 166
      return;
    }
#line 169
    if ((unsigned long )l >= sizeof(tbuf)) {
      {
#line 170
      configparseerr___10(ads___7, fn, lno, "sortlist entry `%.*s\' too long", l,
                          word);
      }
#line 171
      goto while_continue;
    }
    {
#line 174
    memcpy((void */* __restrict  */)(tbuf), (void const   */* __restrict  */)word,
           (size_t )l);
#line 174
    tbuf[l] = (char)0;
#line 175
    slash = strchr((char const   *)(tbuf), '/');
    }
#line 176
    if (slash) {
#line 176
      tmp = slash;
#line 176
      slash ++;
#line 176
      *tmp = (char)0;
    }
    {
#line 178
    tmp___0 = inet_aton((char const   *)(tbuf), & base);
    }
#line 178
    if (! tmp___0) {
      {
#line 179
      configparseerr___10(ads___7, fn, lno, "invalid address `%s\' in sortlist", tbuf);
      }
#line 180
      goto while_continue;
    }
#line 183
    if (slash) {
      {
#line 184
      tmp___2 = strchr((char const   *)slash, '.');
      }
#line 184
      if (tmp___2) {
        {
#line 185
        tmp___1 = inet_aton((char const   *)slash, & mask);
        }
#line 185
        if (! tmp___1) {
          {
#line 186
          configparseerr___10(ads___7, fn, lno, "invalid mask `%s\' in sortlist",
                              slash);
          }
#line 187
          goto while_continue;
        }
#line 189
        if (base.s_addr & ~ mask.s_addr) {
          {
#line 190
          configparseerr___10(ads___7, fn, lno, "mask `%s\' in sortlist overlaps address `%s\'",
                              slash, tbuf);
          }
#line 192
          goto while_continue;
        }
      } else {
        {
#line 195
        initial = strtoul((char const   */* __restrict  */)slash, (char **/* __restrict  */)(& ep),
                          10);
        }
#line 196
        if (*ep) {
          {
#line 197
          configparseerr___10(ads___7, fn, lno, "mask length `%s\' invalid", slash);
          }
#line 198
          goto while_continue;
        } else
#line 196
        if (initial > 32UL) {
          {
#line 197
          configparseerr___10(ads___7, fn, lno, "mask length `%s\' invalid", slash);
          }
#line 198
          goto while_continue;
        }
        {
#line 200
        mask.s_addr = htonl((uint32_t )(4294967295UL << (32UL - initial)));
        }
      }
    } else {
      {
#line 203
      tmp___3 = ntohl(base.s_addr);
#line 203
      baselocal = (unsigned long )tmp___3;
      }
#line 204
      if ((unsigned long )(! baselocal) & 2147483648UL) {
        {
#line 205
        mask.s_addr = htonl((uint32_t )4278190080UL);
        }
      } else
#line 206
      if ((baselocal & 3221225472UL) == 2147483648UL) {
        {
#line 207
        mask.s_addr = htonl((uint32_t )4294901760UL);
        }
      } else
#line 208
      if ((baselocal & 4026531840UL) == 3758096384UL) {
        {
#line 209
        mask.s_addr = htonl((uint32_t )4278190080UL);
        }
      } else {
        {
#line 211
        configparseerr___10(ads___7, fn, lno, "network address `%s\' in sortlist is not in classed ranges, must specify mask explicitly",
                            tbuf);
        }
#line 214
        goto while_continue;
      }
    }
#line 218
    ads___7->sortlist[ads___7->nsortlist].base = base;
#line 219
    ads___7->sortlist[ads___7->nsortlist].mask = mask;
#line 220
    (ads___7->nsortlist) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  return;
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void ccf_options___10(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  char const   *word ;
  char *ep ;
  unsigned long v ;
  int l ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 231
  if (! buf___17) {
#line 231
    return;
  }
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 233
    tmp___5 = nextword___10(& buf___17, & word, & l);
    }
#line 233
    if (! tmp___5) {
#line 233
      goto while_break;
    }
#line 234
    if (l == 5) {
      {
#line 234
      tmp = memcmp((void const   *)word, (void const   *)"debug", (size_t )5);
      }
#line 234
      if (! tmp) {
#line 235
        ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 8U);
#line 236
        goto while_continue;
      }
    }
#line 238
    if (l >= 6) {
      {
#line 238
      tmp___0 = memcmp((void const   *)word, (void const   *)"ndots:", (size_t )6);
      }
#line 238
      if (! tmp___0) {
        {
#line 239
        v = strtoul((char const   */* __restrict  */)(word + 6), (char **/* __restrict  */)(& ep),
                    10);
        }
#line 240
        if (l == 6) {
          {
#line 241
          configparseerr___10(ads___7, fn, lno, "option `%.*s\' malformed or has bad value",
                              l, word);
          }
#line 243
          goto while_continue;
        } else
#line 240
        if ((unsigned long )ep != (unsigned long )(word + l)) {
          {
#line 241
          configparseerr___10(ads___7, fn, lno, "option `%.*s\' malformed or has bad value",
                              l, word);
          }
#line 243
          goto while_continue;
        } else
#line 240
        if (v > 2147483647UL) {
          {
#line 241
          configparseerr___10(ads___7, fn, lno, "option `%.*s\' malformed or has bad value",
                              l, word);
          }
#line 243
          goto while_continue;
        }
#line 245
        ads___7->searchndots = (int )v;
#line 246
        goto while_continue;
      }
    }
#line 248
    if (l >= 12) {
      {
#line 248
      tmp___4 = memcmp((void const   *)word, (void const   *)"adns_checkc:", (size_t )12);
      }
#line 248
      if (! tmp___4) {
        {
#line 249
        tmp___3 = strcmp(word + 12, "none");
        }
#line 249
        if (tmp___3) {
          {
#line 252
          tmp___2 = strcmp(word + 12, "entex");
          }
#line 252
          if (tmp___2) {
            {
#line 255
            tmp___1 = strcmp(word + 12, "freq");
            }
#line 255
            if (tmp___1) {
              {
#line 258
              configparseerr___10(ads___7, fn, lno, "option adns_checkc has bad value `%s\' (must be none, entex or freq",
                                  word + 12);
              }
            } else {
#line 256
              ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 768U);
            }
          } else {
#line 253
            ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags & 4294966527U);
#line 254
            ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 256U);
          }
        } else {
#line 250
          ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags & 4294966527U);
#line 251
          ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 256U);
        }
#line 261
        goto while_continue;
      }
    }
    {
#line 263
    adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown option `%.*s\'", fn, lno,
               l, word);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 265
  return;
}
}
#line 267 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void ccf_clearnss___10(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 


  {
#line 269
  ads___7->nservers = 0;
#line 270
  return;
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void ccf_include___10(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 


  {
#line 274
  if (! *buf___17) {
    {
#line 275
    configparseerr___10(ads___7, fn, lno, "`include\' directive with no filename");
    }
#line 276
    return;
  }
  {
#line 278
  readconfig___10(ads___7, buf___17, 1);
  }
#line 279
  return;
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void ccf_lookup___10(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  int found_bind ;
  char const   *word ;
  int l ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 283
  found_bind = 0;
#line 287
  if (! *buf___17) {
    {
#line 288
    configparseerr___10(ads___7, fn, lno, "`lookup\' directive with no databases");
    }
#line 289
    return;
  }
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 292
    tmp___2 = nextword___10(& buf___17, & word, & l);
    }
#line 292
    if (! tmp___2) {
#line 292
      goto while_break;
    }
#line 293
    if (l == 4) {
      {
#line 293
      tmp___1 = memcmp((void const   *)word, (void const   *)"bind", (size_t )4);
      }
#line 293
      if (tmp___1) {
#line 293
        goto _L___0;
      } else {
#line 294
        found_bind = 1;
      }
    } else
    _L___0: /* CIL Label */ 
#line 295
    if (l == 4) {
      {
#line 295
      tmp___0 = memcmp((void const   *)word, (void const   *)"file", (size_t )4);
      }
#line 295
      if (tmp___0) {
#line 295
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 297
    if (l == 2) {
      {
#line 297
      tmp = memcmp((void const   *)word, (void const   *)"yp", (size_t )2);
      }
#line 297
      if (tmp) {
        {
#line 301
        adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown `lookup\' database `%.*s\'",
                   fn, lno, l, word);
#line 303
        found_bind = -1;
        }
      } else {
        {
#line 298
        adns__diag(ads___7, -1, (adns_query )0, "%s:%d: yp lookups not supported by adns",
                   fn, lno);
#line 299
        found_bind = -1;
        }
      }
    } else {
      {
#line 301
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown `lookup\' database `%.*s\'",
                 fn, lno, l, word);
#line 303
      found_bind = -1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 306
  if (! found_bind) {
    {
#line 307
    adns__diag(ads___7, -1, (adns_query )0, "%s:%d: `lookup\' specified, but not `bind\'",
               fn, lno);
    }
  }
#line 308
  return;
}
}
#line 310 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static struct configcommandinfo  const  configcommandinfos___10[9]  = 
#line 310
  {      {"nameserver", & ccf_nameserver___10}, 
        {"domain", & ccf_search___10}, 
        {"search", & ccf_search___10}, 
        {"sortlist", & ccf_sortlist___10}, 
        {"options", & ccf_options___10}, 
        {"clearnameservers", & ccf_clearnss___10}, 
        {"include", & ccf_include___10}, 
        {"lookup", & ccf_lookup___10}, 
        {(char const   *)0, (void (*)(adns_state ads , char const   *fn , int lno , char const   *buf ))0}};
#line 330 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static int gl_file___10(adns_state ads___7 , getline_ctx *src_io , char const   *filename ,
                        int lno , char *buf___17 , int buflen ) 
{ 
  FILE *file ;
  int c ;
  int i ;
  char *p ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 332
  file = src_io->file;
#line 336
  p = buf___17;
#line 337
  buflen --;
#line 338
  i = 0;
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (i == buflen) {
      {
#line 342
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: line too long, ignored", filename,
                 lno);
      }
#line 343
      goto x_badline;
    }
    {
#line 345
    c = _IO_getc(file);
    }
#line 346
    if (! c) {
      {
#line 347
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: line contains nul, ignored",
                 filename, lno);
      }
#line 348
      goto x_badline;
    } else
#line 349
    if (c == 10) {
#line 350
      goto while_break;
    } else
#line 351
    if (c == -1) {
      {
#line 352
      tmp___2 = ferror(file);
      }
#line 352
      if (tmp___2) {
        {
#line 353
        tmp = __errno_location();
#line 353
        saveerr___10(ads___7, *tmp);
#line 354
        tmp___0 = __errno_location();
#line 354
        tmp___1 = strerror(*tmp___0);
#line 354
        adns__diag(ads___7, -1, (adns_query )0, "%s:%d: read error: %s", filename,
                   lno, tmp___1);
        }
#line 356
        return (-1);
      }
#line 358
      if (! i) {
#line 358
        return (-1);
      }
#line 359
      goto while_break;
    } else {
#line 361
      tmp___3 = p;
#line 361
      p ++;
#line 361
      *tmp___3 = (char )c;
#line 362
      i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 366
  tmp___4 = p;
#line 366
  p ++;
#line 366
  *tmp___4 = (char)0;
#line 367
  return (i);
  x_badline: 
  {
#line 370
  saveerr___10(ads___7, 22);
  }
  {
#line 371
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 371
    c = _IO_getc(file);
    }
#line 371
    if (c != -1) {
#line 371
      if (! (c != 10)) {
#line 371
        goto while_break___0;
      }
    } else {
#line 371
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 372
  return (-2);
}
}
#line 375 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static int gl_text___10(adns_state ads___7 , getline_ctx *src_io , char const   *filename ,
                        int lno , char *buf___17 , int buflen ) 
{ 
  char const   *cp ;
  int l ;
  size_t tmp ;

  {
#line 377
  cp = src_io->text;
#line 380
  if (! cp) {
#line 380
    return (-1);
  } else
#line 380
  if (! *cp) {
#line 380
    return (-1);
  }
#line 382
  if ((int const   )*cp == 59) {
#line 382
    cp ++;
  } else
#line 382
  if ((int const   )*cp == 10) {
#line 382
    cp ++;
  }
  {
#line 383
  tmp = strcspn(cp, ";\n");
#line 383
  l = (int )tmp;
#line 384
  src_io->text = cp + l;
  }
#line 386
  if (l >= buflen) {
    {
#line 387
    adns__diag(ads___7, -1, (adns_query )0, "%s:%d: line too long, ignored", filename,
               lno);
#line 388
    saveerr___10(ads___7, 22);
    }
#line 389
    return (-2);
  }
  {
#line 392
  memcpy((void */* __restrict  */)buf___17, (void const   */* __restrict  */)cp, (size_t )l);
#line 393
  *(buf___17 + l) = (char)0;
  }
#line 394
  return (l);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void readconfiggeneric___10(adns_state ads___7 , char const   *filename , int (*getline___0)(adns_state ads ,
                                                                                                    getline_ctx * ,
                                                                                                    char const   *filename ,
                                                                                                    int lno ,
                                                                                                    char *buf ,
                                                                                                    int buflen ) ,
                                   getline_ctx gl_ctx ) 
{ 
  char linebuf[2000] ;
  char *p ;
  char *q ;
  int lno ;
  int l ;
  int dirl ;
  struct configcommandinfo  const  *ccip ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 410
  lno = 1;
  {
#line 410
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 410
    l = (*getline___0)(ads___7, & gl_ctx, filename, lno, linebuf, (int )sizeof(linebuf));
    }
#line 410
    if (! (l != -1)) {
#line 410
      goto while_break;
    }
#line 413
    if (l == -2) {
#line 413
      goto __Cont;
    }
    {
#line 414
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 414
      if (l > 0) {
        {
#line 414
        tmp = ctype_whitespace((int )linebuf[l - 1]);
        }
#line 414
        if (! tmp) {
#line 414
          goto while_break___0;
        }
      } else {
#line 414
        goto while_break___0;
      }
#line 414
      l --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 415
    linebuf[l] = (char)0;
#line 416
    p = linebuf;
    {
#line 417
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 417
      tmp___0 = ctype_whitespace((int )*p);
      }
#line 417
      if (! tmp___0) {
#line 417
        goto while_break___1;
      }
#line 417
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 418
    if ((int )*p == 35) {
#line 418
      goto __Cont;
    } else
#line 418
    if ((int )*p == 59) {
#line 418
      goto __Cont;
    } else
#line 418
    if (! *p) {
#line 418
      goto __Cont;
    }
#line 419
    q = p;
    {
#line 420
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 420
      if (*q) {
        {
#line 420
        tmp___1 = ctype_whitespace((int )*q);
        }
#line 420
        if (tmp___1) {
#line 420
          goto while_break___2;
        }
      } else {
#line 420
        goto while_break___2;
      }
#line 420
      q ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 421
    dirl = (int )(q - p);
#line 422
    ccip = configcommandinfos___10;
    {
#line 422
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 422
      if (ccip->name) {
        {
#line 422
        tmp___2 = strlen((char const   *)ccip->name);
        }
#line 422
        if (tmp___2 == (size_t )dirl) {
          {
#line 422
          tmp___3 = memcmp((void const   *)ccip->name, (void const   *)p, (size_t )(q - p));
          }
#line 422
          if (! tmp___3) {
#line 422
            goto while_break___3;
          }
        }
      } else {
#line 422
        goto while_break___3;
      }
#line 422
      ccip ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 426
    if (! ccip->name) {
      {
#line 427
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown configuration directive `%.*s\'",
                 filename, lno, (int )(q - p), p);
      }
#line 429
      goto __Cont;
    }
    {
#line 431
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 431
      tmp___4 = ctype_whitespace((int )*q);
      }
#line 431
      if (! tmp___4) {
#line 431
        goto while_break___4;
      }
#line 431
      q ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 432
    (*(ccip->fn))(ads___7, filename, lno, (char const   *)q);
    }
    __Cont: /* CIL Label */ 
#line 410
    lno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 434
  return;
}
}
#line 436 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static char const   *instrum_getenv___10(adns_state ads___7 , char const   *envvar ) 
{ 
  char const   *value ;
  char *tmp ;

  {
  {
#line 439
  tmp = getenv(envvar);
#line 439
  value = (char const   *)tmp;
  }
#line 440
  if (! value) {
    {
#line 440
    adns__debug(ads___7, -1, (adns_query )0, "environment variable %s not set", envvar);
    }
  } else {
    {
#line 441
    adns__debug(ads___7, -1, (adns_query )0, "environment variable %s set to `%s\'",
                envvar, value);
    }
  }
#line 443
  return (value);
}
}
#line 446 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void readconfig___10(adns_state ads___7 , char const   *filename , int warnmissing ) 
{ 
  getline_ctx gl_ctx ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 449
  gl_ctx.file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 450
  if (! gl_ctx.file) {
    {
#line 451
    tmp = __errno_location();
    }
#line 451
    if (*tmp == 2) {
#line 452
      if (warnmissing) {
        {
#line 453
        adns__debug(ads___7, -1, (adns_query )0, "configuration file `%s\' does not exist",
                    filename);
        }
      }
#line 455
      return;
    }
    {
#line 457
    tmp___0 = __errno_location();
#line 457
    saveerr___10(ads___7, *tmp___0);
#line 458
    tmp___1 = __errno_location();
#line 458
    tmp___2 = strerror(*tmp___1);
#line 458
    adns__diag(ads___7, -1, (adns_query )0, "cannot open configuration file `%s\': %s",
               filename, tmp___2);
    }
#line 460
    return;
  }
  {
#line 463
  readconfiggeneric___10(ads___7, filename, & gl_file___10, gl_ctx);
#line 465
  fclose(gl_ctx.file);
  }
#line 466
  return;
}
}
#line 468 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void readconfigtext___10(adns_state ads___7 , char const   *text , char const   *showname ) 
{ 
  getline_ctx gl_ctx ;

  {
  {
#line 472
  gl_ctx.text = text;
#line 473
  readconfiggeneric___10(ads___7, showname, & gl_text___10, gl_ctx);
  }
#line 474
  return;
}
}
#line 476 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void readconfigenv___10(adns_state ads___7 , char const   *envvar ) 
{ 
  char const   *filename ;

  {
#line 479
  if ((unsigned int )ads___7->iflags & 1U) {
    {
#line 480
    adns__debug(ads___7, -1, (adns_query )0, "not checking environment variable `%s\'",
                envvar);
    }
#line 481
    return;
  }
  {
#line 483
  filename = instrum_getenv___10(ads___7, envvar);
  }
#line 484
  if (filename) {
    {
#line 484
    readconfig___10(ads___7, filename, 1);
    }
  }
#line 485
  return;
}
}
#line 487 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void readconfigenvtext___10(adns_state ads___7 , char const   *envvar ) 
{ 
  char const   *textdata ;

  {
#line 490
  if ((unsigned int )ads___7->iflags & 1U) {
    {
#line 491
    adns__debug(ads___7, -1, (adns_query )0, "not checking environment variable `%s\'",
                envvar);
    }
#line 492
    return;
  }
  {
#line 494
  textdata = instrum_getenv___10(ads___7, envvar);
  }
#line 495
  if (textdata) {
    {
#line 495
    readconfigtext___10(ads___7, textdata, envvar);
    }
  }
#line 496
  return;
}
}
#line 508 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static int init_begin___10(adns_state *ads_r , adns_initflags flags , adns_logcallbackfn *logfn ,
                           void *logfndata ) 
{ 
  adns_state ads___7 ;
  pid_t pid ;
  void *tmp ;
  int *tmp___0 ;
  adns_query tmp___1 ;
  adns_query tmp___2 ;
  adns_query tmp___3 ;
  adns_query tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __suseconds_t tmp___9 ;

  {
  {
#line 513
  tmp = malloc(sizeof(*ads___7));
#line 513
  ads___7 = (adns_state )tmp;
  }
#line 513
  if (! ads___7) {
    {
#line 513
    tmp___0 = __errno_location();
    }
#line 513
    return (*tmp___0);
  }
  {
#line 515
  ads___7->iflags = flags;
#line 516
  ads___7->logfn = logfn;
#line 517
  ads___7->logfndata = logfndata;
#line 518
  ads___7->configerrno = 0;
#line 519
  tmp___1 = (adns_query )0;
#line 519
  ads___7->udpw.tail = tmp___1;
#line 519
  ads___7->udpw.head = tmp___1;
#line 520
  tmp___2 = (adns_query )0;
#line 520
  ads___7->tcpw.tail = tmp___2;
#line 520
  ads___7->tcpw.head = tmp___2;
#line 521
  tmp___3 = (adns_query )0;
#line 521
  ads___7->childw.tail = tmp___3;
#line 521
  ads___7->childw.head = tmp___3;
#line 522
  tmp___4 = (adns_query )0;
#line 522
  ads___7->output.tail = tmp___4;
#line 522
  ads___7->output.head = tmp___4;
#line 523
  ads___7->forallnext = (adns_query )0;
#line 524
  ads___7->nextid = 12575;
#line 525
  tmp___5 = -1;
#line 525
  ads___7->tcpsocket = tmp___5;
#line 525
  ads___7->udpsocket = tmp___5;
#line 526
  adns__vbuf_init(& ads___7->tcpsend);
#line 527
  adns__vbuf_init(& ads___7->tcprecv);
#line 528
  ads___7->tcprecv_skip = 0;
#line 529
  tmp___8 = 0;
#line 529
  ads___7->tcpserver = tmp___8;
#line 529
  tmp___7 = tmp___8;
#line 529
  ads___7->nsearchlist = tmp___7;
#line 529
  tmp___6 = tmp___7;
#line 529
  ads___7->nsortlist = tmp___6;
#line 529
  ads___7->nservers = tmp___6;
#line 530
  ads___7->searchndots = 1;
#line 531
  ads___7->tcpstate = (enum adns__tcpstate )0;
#line 532
  tmp___9 = (__suseconds_t )0;
#line 532
  ads___7->tcptimeout.tv_usec = tmp___9;
#line 532
  ads___7->tcptimeout.tv_sec = tmp___9;
#line 533
  ads___7->searchlist = (char **)0;
#line 535
  pid = getpid();
#line 536
  ads___7->rand48xsubi[0] = (unsigned short )pid;
#line 537
  ads___7->rand48xsubi[1] = (unsigned short )((unsigned long )pid >> 16);
#line 538
  ads___7->rand48xsubi[2] = (unsigned short )((unsigned long )pid ^ ((unsigned long )pid >> 16));
#line 540
  *ads_r = ads___7;
  }
#line 541
  return (0);
}
}
#line 544 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static int init_finish___10(adns_state ads___7 ) 
{ 
  struct in_addr ia ;
  struct protoent *proto ;
  int r ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 549
  if (! ads___7->nservers) {
#line 550
    if (ads___7->logfn) {
#line 550
      if ((unsigned int )ads___7->iflags & 8U) {
        {
#line 551
        adns__lprintf(ads___7, "adns: no nameservers, using localhost\n");
        }
      }
    }
    {
#line 552
    ia.s_addr = htonl((in_addr_t )2130706433);
#line 553
    addserver___10(ads___7, ia);
    }
  }
  {
#line 556
  proto = getprotobyname("udp");
  }
#line 556
  if (! proto) {
#line 556
    r = 92;
#line 556
    goto x_free;
  }
  {
#line 557
  ads___7->udpsocket = socket(2, 2, proto->p_proto);
  }
#line 558
  if (ads___7->udpsocket < 0) {
    {
#line 558
    tmp = __errno_location();
#line 558
    r = *tmp;
    }
#line 558
    goto x_free;
  }
  {
#line 560
  r = adns__setnonblock(ads___7, ads___7->udpsocket);
  }
#line 561
  if (r) {
    {
#line 561
    tmp___0 = __errno_location();
#line 561
    r = *tmp___0;
    }
#line 561
    goto x_closeudp;
  }
#line 563
  return (0);
  x_closeudp: 
  {
#line 566
  close(ads___7->udpsocket);
  }
  x_free: 
  {
#line 568
  free((void *)ads___7);
  }
#line 569
  return (r);
}
}
#line 572 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void init_abort___10(adns_state ads___7 ) 
{ 


  {
#line 573
  if (ads___7->nsearchlist) {
    {
#line 574
    free((void *)*(ads___7->searchlist + 0));
#line 575
    free((void *)ads___7->searchlist);
    }
  }
  {
#line 577
  free((void *)ads___7);
  }
#line 578
  return;
}
}
#line 580 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void logfn_file___10(adns_state ads___7 , void *logfndata , char const   *fmt ,
                            va_list al ) 
{ 


  {
  {
#line 582
  vfprintf((FILE */* __restrict  */)logfndata, (char const   */* __restrict  */)fmt,
           al);
  }
#line 583
  return;
}
}
#line 585 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static int init_files___10(adns_state *ads_r , adns_initflags flags , adns_logcallbackfn *logfn ,
                           void *logfndata ) 
{ 
  adns_state ads___7 ;
  char const   *res_options ;
  char const   *adns_res_options ;
  int r ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 591
  r = init_begin___10(& ads___7, flags, logfn, logfndata);
  }
#line 592
  if (r) {
#line 592
    return (r);
  }
  {
#line 594
  res_options = instrum_getenv___10(ads___7, "RES_OPTIONS");
#line 595
  adns_res_options = instrum_getenv___10(ads___7, "ADNS_RES_OPTIONS");
#line 596
  ccf_options___10(ads___7, "RES_OPTIONS", -1, res_options);
#line 597
  ccf_options___10(ads___7, "ADNS_RES_OPTIONS", -1, adns_res_options);
#line 599
  readconfig___10(ads___7, "/etc/resolv.conf", 1);
#line 600
  readconfig___10(ads___7, "/etc/resolv-adns.conf", 0);
#line 601
  readconfigenv___10(ads___7, "RES_CONF");
#line 602
  readconfigenv___10(ads___7, "ADNS_RES_CONF");
#line 604
  readconfigenvtext___10(ads___7, "RES_CONF_TEXT");
#line 605
  readconfigenvtext___10(ads___7, "ADNS_RES_CONF_TEXT");
#line 607
  ccf_options___10(ads___7, "RES_OPTIONS", -1, res_options);
#line 608
  ccf_options___10(ads___7, "ADNS_RES_OPTIONS", -1, adns_res_options);
#line 610
  tmp = instrum_getenv___10(ads___7, "LOCALDOMAIN");
#line 610
  ccf_search___10(ads___7, "LOCALDOMAIN", -1, tmp);
#line 611
  tmp___0 = instrum_getenv___10(ads___7, "ADNS_LOCALDOMAIN");
#line 611
  ccf_search___10(ads___7, "ADNS_LOCALDOMAIN", -1, tmp___0);
  }
#line 613
  if (ads___7->configerrno) {
#line 613
    if (ads___7->configerrno != 22) {
      {
#line 614
      r = ads___7->configerrno;
#line 615
      init_abort___10(ads___7);
      }
#line 616
      return (r);
    }
  }
  {
#line 619
  r = init_finish___10(ads___7);
  }
#line 620
  if (r) {
#line 620
    return (r);
  }
  {
#line 622
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
#line 623
  *ads_r = ads___7;
  }
#line 624
  return (0);
}
}
#line 631 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static int init_strcfg___10(adns_state *ads_r , adns_initflags flags , adns_logcallbackfn *logfn ,
                            void *logfndata , char const   *configtext ) 
{ 
  adns_state ads___7 ;
  int r ;

  {
  {
#line 637
  r = init_begin___10(& ads___7, flags, logfn, logfndata);
  }
#line 638
  if (r) {
#line 638
    return (r);
  }
  {
#line 640
  readconfigtext___10(ads___7, configtext, "<supplied configuration text>");
  }
#line 641
  if (ads___7->configerrno) {
    {
#line 642
    r = ads___7->configerrno;
#line 643
    init_abort___10(ads___7);
    }
#line 644
    return (r);
  }
  {
#line 647
  r = init_finish___10(ads___7);
  }
#line 647
  if (r) {
#line 647
    return (r);
  }
  {
#line 648
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
#line 649
  *ads_r = ads___7;
  }
#line 650
  return (0);
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pap_qstring___10(parseinfo const   *pai , int *cbyte_io , int max ,
                                    int *len_r , char **str_r ) 
{ 
  byte const   *dgram ;
  int l ;
  int cbyte___3 ;
  char *str ;
  int tmp ;
  void *tmp___0 ;

  {
#line 92
  dgram = (byte const   *)pai->dgram;
#line 96
  cbyte___3 = *cbyte_io;
#line 98
  if (cbyte___3 >= max) {
#line 98
    return ((adns_status )104);
  }
#line 99
  tmp = cbyte___3;
#line 99
  cbyte___3 ++;
#line 99
  l = (int )((int const   )*(dgram + tmp) & 255);
#line 100
  if (cbyte___3 + l > max) {
#line 100
    return ((adns_status )104);
  }
  {
#line 102
  tmp___0 = adns__alloc_interim((adns_query )pai->qu, (size_t )(l + 1));
#line 102
  str = (char *)tmp___0;
  }
#line 103
  if (! str) {
#line 103
    return ((adns_status )1);
  }
  {
#line 105
  *(str + l) = (char)0;
#line 106
  memcpy((void */* __restrict  */)str, (void const   */* __restrict  */)(dgram + cbyte___3),
         (size_t )l);
#line 108
  *len_r = l;
#line 109
  *str_r = str;
#line 110
  *cbyte_io = cbyte___3 + l;
  }
#line 112
  return ((adns_status )0);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status csp_qstring___10(vbuf *vb___0 , char const   *dp , int len ) 
{ 
  unsigned char ch ;
  char buf___17[10] ;
  int cn ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 120
    tmp = adns__vbuf_appendstr(vb___0, "\"");
    }
#line 120
    if (! tmp) {
#line 120
      return ((adns_status )1);
    }
#line 120
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  cn = 0;
  {
#line 121
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 121
    if (! (cn < len)) {
#line 121
      goto while_break___0;
    }
#line 122
    tmp___0 = dp;
#line 122
    dp ++;
#line 122
    ch = (unsigned char )*tmp___0;
#line 123
    if ((int )ch == 92) {
      {
#line 124
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 124
        tmp___1 = adns__vbuf_appendstr(vb___0, "\\\\");
        }
#line 124
        if (! tmp___1) {
#line 124
          return ((adns_status )1);
        }
#line 124
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else
#line 125
    if ((int )ch == 34) {
      {
#line 126
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 126
        tmp___2 = adns__vbuf_appendstr(vb___0, "\\\"");
        }
#line 126
        if (! tmp___2) {
#line 126
          return ((adns_status )1);
        }
#line 126
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else
#line 127
    if ((int )ch >= 32) {
#line 127
      if ((int )ch <= 126) {
        {
#line 128
        tmp___3 = adns__vbuf_append(vb___0, (byte const   *)(& ch), 1);
        }
#line 128
        if (! tmp___3) {
#line 128
          return ((adns_status )1);
        }
      } else {
#line 127
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 130
      sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"\\x%02x",
              (int )ch);
      }
      {
#line 131
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 131
        tmp___4 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
        }
#line 131
        if (! tmp___4) {
#line 131
          return ((adns_status )1);
        }
#line 131
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 121
    cn ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 134
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 134
    tmp___5 = adns__vbuf_appendstr(vb___0, "\"");
    }
#line 134
    if (! tmp___5) {
#line 134
      return ((adns_status )1);
    }
#line 134
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 136
  return ((adns_status )0);
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_str___10(adns_query qu , void *datap ) 
{ 
  char **rrp ;

  {
  {
#line 144
  rrp = (char **)datap;
#line 146
  adns__makefinal_str(qu, rrp);
  }
#line 147
  return;
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_intstr___10(adns_query qu , void *datap ) 
{ 
  adns_rr_intstr *rrp ;

  {
  {
#line 154
  rrp = (adns_rr_intstr *)datap;
#line 156
  adns__makefinal_str(qu, & rrp->str);
  }
#line 157
  return;
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_manyistr___10(adns_query qu , void *datap ) 
{ 
  adns_rr_intstr **rrp ;
  adns_rr_intstr *te ;
  adns_rr_intstr *table ;
  void *tablev ;
  int tc ;

  {
#line 164
  rrp = (adns_rr_intstr **)datap;
#line 169
  tc = 0;
#line 169
  te = *rrp;
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    if (! (te->i >= 0)) {
#line 169
      goto while_break;
    }
#line 169
    te ++;
#line 169
    tc ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 170
  tablev = (void *)*rrp;
#line 171
  adns__makefinal_block(qu, & tablev, sizeof(*te) * (unsigned long )(tc + 1));
#line 172
  table = (adns_rr_intstr *)tablev;
#line 172
  *rrp = table;
#line 173
  te = *rrp;
  }
  {
#line 173
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 173
    if (! (te->i >= 0)) {
#line 173
      goto while_break___0;
    }
    {
#line 174
    adns__makefinal_str(qu, & te->str);
#line 173
    te ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 175
  return;
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_txt___10(parseinfo const   *pai , int cbyte___3 , int max ,
                               void *datap ) 
{ 
  adns_rr_intstr **rrp ;
  adns_rr_intstr *table ;
  adns_rr_intstr *te ;
  byte const   *dgram ;
  int ti ;
  int tc ;
  int l ;
  int startbyte ;
  adns_status st ;
  int tmp ;
  void *tmp___0 ;

  {
#line 183
  rrp = (adns_rr_intstr **)datap;
#line 184
  dgram = (byte const   *)pai->dgram;
#line 188
  startbyte = cbyte___3;
#line 189
  if (cbyte___3 >= max) {
#line 189
    return ((adns_status )104);
  }
#line 190
  tc = 0;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! (cbyte___3 < max)) {
#line 191
      goto while_break;
    }
#line 192
    tmp = cbyte___3;
#line 192
    cbyte___3 ++;
#line 192
    l = (int )((int const   )*(dgram + tmp) & 255);
#line 193
    cbyte___3 += l;
#line 194
    tc ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  if (cbyte___3 != max) {
#line 196
    return ((adns_status )104);
  } else
#line 196
  if (! tc) {
#line 196
    return ((adns_status )104);
  }
  {
#line 198
  tmp___0 = adns__alloc_interim((adns_query )pai->qu, sizeof(*table) * (unsigned long )(tc + 1));
#line 198
  table = (adns_rr_intstr *)tmp___0;
  }
#line 199
  if (! table) {
#line 199
    return ((adns_status )1);
  }
#line 201
  cbyte___3 = startbyte;
#line 201
  ti = 0;
#line 201
  te = table;
  {
#line 201
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 201
    if (! (ti < tc)) {
#line 201
      goto while_break___0;
    }
    {
#line 202
    st = pap_qstring___10(pai, & cbyte___3, max, & te->i, & te->str);
    }
#line 203
    if (st) {
#line 203
      return (st);
    }
#line 201
    ti ++;
#line 201
    te ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 205
  if (! (cbyte___3 == max)) {
    {
#line 205
    __assert_fail("cbyte == max", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                  205U, "pa_txt");
    }
  }
#line 207
  te->i = -1;
#line 208
  te->str = (char *)0;
#line 210
  *rrp = table;
#line 211
  return ((adns_status )0);
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_txt___10(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_intstr const   * const  *rrp ;
  adns_rr_intstr const   *current ;
  adns_status st ;
  int spc ;
  int tmp ;

  {
#line 215
  rrp = (adns_rr_intstr const   * const  *)datap;
#line 220
  current = (adns_rr_intstr const   *)*rrp;
#line 220
  spc = 0;
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    if (! (current->i >= 0)) {
#line 220
      goto while_break;
    }
#line 221
    if (spc) {
      {
#line 221
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 221
        tmp = adns__vbuf_appendstr(vb___0, " ");
        }
#line 221
        if (! tmp) {
#line 221
          return ((adns_status )1);
        }
#line 221
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 222
    st = csp_qstring___10(vb___0, (char const   *)current->str, (int )current->i);
    }
#line 222
    if (st) {
#line 222
      return (st);
    }
#line 220
    current ++;
#line 220
    spc = 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  return ((adns_status )0);
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_hinfo___10(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_intstrpair const   *rrp ;
  adns_status st ;
  int tmp ;

  {
  {
#line 232
  rrp = (adns_rr_intstrpair const   *)datap;
#line 235
  st = csp_qstring___10(vb___0, (char const   *)rrp->array[0].str, (int )rrp->array[0].i);
  }
#line 235
  if (st) {
#line 235
    return (st);
  }
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 236
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 236
    if (! tmp) {
#line 236
      return ((adns_status )1);
    }
#line 236
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 237
  st = csp_qstring___10(vb___0, (char const   *)rrp->array[1].str, (int )rrp->array[1].i);
  }
#line 237
  if (st) {
#line 237
    return (st);
  }
#line 238
  return ((adns_status )0);
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_inaddr___10(parseinfo const   *pai , int cbyte___3 , int max ,
                                  void *datap ) 
{ 
  struct in_addr *storeto ;

  {
#line 247
  storeto = (struct in_addr *)datap;
#line 249
  if (max - cbyte___3 != 4) {
#line 249
    return ((adns_status )104);
  }
  {
#line 250
  memcpy((void */* __restrict  */)storeto, (void const   */* __restrict  */)(pai->dgram + cbyte___3),
         (size_t )4);
  }
#line 251
  return ((adns_status )0);
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int search_sortlist___10(adns_state ads___7 , struct in_addr ad ) 
{ 
  struct sortlist  const  *slp ;
  int i ;

  {
#line 258
  i = 0;
#line 258
  slp = (struct sortlist  const  *)(ads___7->sortlist);
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 258
    if (i < ads___7->nsortlist) {
#line 258
      if (! (! ((ad.s_addr & (unsigned int )slp->mask.s_addr) == (unsigned int )slp->base.s_addr))) {
#line 258
        goto while_break;
      }
    } else {
#line 258
      goto while_break;
    }
#line 258
    i ++;
#line 258
    slp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  return (i);
}
}
#line 265 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int dip_inaddr___10(adns_state ads___7 , struct in_addr a , struct in_addr b ) 
{ 
  int ai ;
  int bi ;

  {
#line 268
  if (! ads___7->nsortlist) {
#line 268
    return (0);
  }
  {
#line 270
  ai = search_sortlist___10(ads___7, a);
#line 271
  bi = search_sortlist___10(ads___7, b);
  }
#line 272
  return (bi < ai);
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int di_inaddr___10(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  struct in_addr  const  *ap ;
  struct in_addr  const  *bp ;
  int tmp ;

  {
  {
#line 277
  ap = (struct in_addr  const  *)datap_a;
#line 277
  bp = (struct in_addr  const  *)datap_b;
#line 279
  tmp = dip_inaddr___10(ads___7, (struct in_addr )*ap, (struct in_addr )*bp);
  }
#line 279
  return (tmp);
}
}
#line 282 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_inaddr___10(vbuf *vb___0 , void const   *datap ) 
{ 
  struct in_addr  const  *rrp ;
  struct in_addr rr ;
  char const   *ia ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 283
  rrp = (struct in_addr  const  *)datap;
#line 283
  rr = *rrp;
#line 286
  tmp = inet_ntoa(rr);
#line 286
  ia = (char const   *)tmp;
  }
#line 286
  if (! ia) {
    {
#line 286
    __assert_fail("ia", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                  286U, "cs_inaddr");
    }
  }
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 287
    tmp___0 = adns__vbuf_appendstr(vb___0, ia);
    }
#line 287
    if (! tmp___0) {
#line 287
      return ((adns_status )1);
    }
#line 287
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  return ((adns_status )0);
}
}
#line 295 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_addr___10(parseinfo const   *pai , int cbyte___3 , int max ,
                                void *datap ) 
{ 
  adns_rr_addr *storeto ;
  byte const   *dgram ;

  {
#line 297
  storeto = (adns_rr_addr *)datap;
#line 298
  dgram = (byte const   *)pai->dgram;
#line 300
  if (max - cbyte___3 != 4) {
#line 300
    return ((adns_status )104);
  }
  {
#line 301
  storeto->len = (int )sizeof(storeto->addr.inet);
#line 302
  memset((void *)(& storeto->addr), 0, sizeof(storeto->addr.inet));
#line 303
  storeto->addr.inet.sin_family = (sa_family_t )2;
#line 304
  memcpy((void */* __restrict  */)(& storeto->addr.inet.sin_addr), (void const   */* __restrict  */)(dgram + cbyte___3),
         (size_t )4);
  }
#line 305
  return ((adns_status )0);
}
}
#line 308 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int di_addr___10(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_addr const   *ap ;
  adns_rr_addr const   *bp ;
  int tmp ;

  {
#line 309
  ap = (adns_rr_addr const   *)datap_a;
#line 309
  bp = (adns_rr_addr const   *)datap_b;
#line 311
  if (! ((int const   )ap->addr.sa.sa_family == 2)) {
    {
#line 311
    __assert_fail("ap->addr.sa.sa_family == 2", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                  311U, "di_addr");
    }
  }
  {
#line 312
  tmp = dip_inaddr___10(ads___7, (struct in_addr )ap->addr.inet.sin_addr, (struct in_addr )bp->addr.inet.sin_addr);
  }
#line 312
  return (tmp);
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int div_addr___10(void *context , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_state ads___7 ;
  int tmp ;

  {
  {
#line 316
  ads___7 = (adns_state )context;
#line 318
  tmp = di_addr___10(ads___7, datap_a, datap_b);
  }
#line 318
  return (tmp);
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status csp_addr___10(vbuf *vb___0 , adns_rr_addr const   *rrp ) 
{ 
  char const   *ia ;
  char buf___17[30] ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 326
  if ((int const   )rrp->addr.inet.sin_family == 2) {
#line 326
    goto case_2;
  }
#line 331
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 327
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 327
    tmp = adns__vbuf_appendstr(vb___0, "INET ");
    }
#line 327
    if (! tmp) {
#line 327
      return ((adns_status )1);
    }
#line 327
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 328
  tmp___0 = inet_ntoa((struct in_addr )rrp->addr.inet.sin_addr);
#line 328
  ia = (char const   *)tmp___0;
  }
#line 328
  if (! ia) {
    {
#line 328
    __assert_fail("ia", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                  328U, "csp_addr");
    }
  }
  {
#line 329
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 329
    tmp___1 = adns__vbuf_appendstr(vb___0, ia);
    }
#line 329
    if (! tmp___1) {
#line 329
      return ((adns_status )1);
    }
#line 329
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 330
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 332
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"AF=%u",
          (int const   )rrp->addr.sa.sa_family);
  }
  {
#line 333
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 333
    tmp___2 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 333
    if (! tmp___2) {
#line 333
      return ((adns_status )1);
    }
#line 333
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 334
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 336
  return ((adns_status )0);
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_addr___10(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_addr const   *rrp ;
  adns_status tmp ;

  {
  {
#line 340
  rrp = (adns_rr_addr const   *)datap;
#line 342
  tmp = csp_addr___10(vb___0, rrp);
  }
#line 342
  return (tmp);
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pap_domain___10(parseinfo const   *pai , int *cbyte_io , int max ,
                                   char **domain_r , parsedomain_flags flags ) 
{ 
  adns_status st ;
  char *dm ;
  void *tmp ;

  {
  {
#line 355
  st = adns__parse_domain((pai->qu)->ads, (int )pai->serv, (adns_query )pai->qu, & (pai->qu)->vb,
                          flags, (byte const   *)pai->dgram, (int )pai->dglen, cbyte_io,
                          max);
  }
#line 357
  if (st) {
#line 357
    return (st);
  }
#line 358
  if (! (pai->qu)->vb.used) {
#line 358
    return ((adns_status )104);
  }
  {
#line 360
  tmp = adns__alloc_interim((adns_query )pai->qu, (size_t )((pai->qu)->vb.used + 1));
#line 360
  dm = (char *)tmp;
  }
#line 361
  if (! dm) {
#line 361
    return ((adns_status )1);
  }
  {
#line 363
  *(dm + (pai->qu)->vb.used) = (char)0;
#line 364
  memcpy((void */* __restrict  */)dm, (void const   */* __restrict  */)(pai->qu)->vb.buf,
         (size_t )(pai->qu)->vb.used);
#line 366
  *domain_r = dm;
  }
#line 367
  return ((adns_status )0);
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status csp_domain___10(vbuf *vb___0 , char const   *domain ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 371
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 371
    tmp = adns__vbuf_appendstr(vb___0, domain);
    }
#line 371
    if (! tmp) {
#line 371
      return ((adns_status )1);
    }
#line 371
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 372
  if (! *domain) {
    {
#line 372
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 372
      tmp___0 = adns__vbuf_appendstr(vb___0, ".");
      }
#line 372
      if (! tmp___0) {
#line 372
        return ((adns_status )1);
      }
#line 372
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 373
  return ((adns_status )0);
}
}
#line 376 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_domain___10(vbuf *vb___0 , void const   *datap ) 
{ 
  char const   * const  *domainp ;
  adns_status tmp ;

  {
  {
#line 377
  domainp = (char const   * const  *)datap;
#line 378
  tmp = csp_domain___10(vb___0, (char const   *)*domainp);
  }
#line 378
  return (tmp);
}
}
#line 381 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_dom_raw___10(parseinfo const   *pai , int cbyte___3 , int max ,
                                   void *datap ) 
{ 
  char **rrp ;
  adns_status st ;

  {
  {
#line 383
  rrp = (char **)datap;
#line 386
  st = pap_domain___10(pai, & cbyte___3, max, rrp, (parsedomain_flags )1);
  }
#line 387
  if (st) {
#line 387
    return (st);
  }
#line 389
  if (cbyte___3 != max) {
#line 389
    return ((adns_status )104);
  }
#line 390
  return ((adns_status )0);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_host_raw___10(parseinfo const   *pai , int cbyte___3 , int max ,
                                    void *datap ) 
{ 
  char **rrp ;
  adns_status st ;
  int tmp ;

  {
#line 399
  rrp = (char **)datap;
#line 402
  if ((pai->qu)->flags & 64) {
#line 402
    tmp = 1;
  } else {
#line 402
    tmp = 0;
  }
  {
#line 402
  st = pap_domain___10(pai, & cbyte___3, max, rrp, (parsedomain_flags )tmp);
  }
#line 404
  if (st) {
#line 404
    return (st);
  }
#line 406
  if (cbyte___3 != max) {
#line 406
    return ((adns_status )104);
  }
#line 407
  return ((adns_status )0);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pap_findaddrs___10(parseinfo const   *pai , adns_rr_hostaddr *ha ,
                                      int *cbyte_io , int count , int dmstart ) 
{ 
  int rri ;
  int naddrs ;
  int type ;
  int class ;
  int rdlen ;
  int rdstart ;
  int ownermatched ;
  unsigned long ttl ;
  adns_status st ;
  int tmp ;
  void *tmp___0 ;

  {
#line 421
  rri = 0;
#line 421
  naddrs = -1;
  {
#line 421
  while (1) {
    while_continue: /* CIL Label */ ;
#line 421
    if (! (rri < count)) {
#line 421
      goto while_break;
    }
    {
#line 422
    st = adns__findrr_anychk((adns_query )pai->qu, (int )pai->serv, (byte const   *)pai->dgram,
                             (int )pai->dglen, cbyte_io, & type, & class, & ttl, & rdlen,
                             & rdstart, (byte const   *)pai->dgram, (int )pai->dglen,
                             dmstart, & ownermatched);
    }
#line 426
    if (st) {
#line 426
      return (st);
    }
#line 427
    if (! ownermatched) {
#line 427
      goto _L;
    } else
#line 427
    if (class != 1) {
#line 427
      goto _L;
    } else
#line 427
    if (type != 1) {
      _L: /* CIL Label */ 
#line 428
      if (naddrs > 0) {
#line 428
        goto while_break;
      } else {
#line 428
        goto __Cont;
      }
    }
#line 430
    if (naddrs == -1) {
#line 431
      naddrs = 0;
    }
    {
#line 433
    tmp = adns__vbuf_ensure(& (pai->qu)->vb, (int )((unsigned long )(naddrs + 1) * sizeof(adns_rr_addr )));
    }
#line 433
    if (! tmp) {
#line 434
      return ((adns_status )1);
    }
    {
#line 435
    adns__update_expires((adns_query )pai->qu, ttl, (struct timeval )pai->now);
#line 436
    st = pa_addr___10(pai, rdstart, rdstart + rdlen, (void *)((pai->qu)->vb.buf + (unsigned long )naddrs * sizeof(adns_rr_addr )));
    }
#line 438
    if (st) {
#line 438
      return (st);
    }
#line 439
    naddrs ++;
    __Cont: /* CIL Label */ 
#line 421
    rri ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 441
  if (naddrs >= 0) {
    {
#line 442
    tmp___0 = adns__alloc_interim((adns_query )pai->qu, (unsigned long )naddrs * sizeof(adns_rr_addr ));
#line 442
    ha->addrs = (adns_rr_addr *)tmp___0;
    }
#line 443
    if (! ha->addrs) {
#line 443
      return ((adns_status )1);
    }
    {
#line 444
    memcpy((void */* __restrict  */)ha->addrs, (void const   */* __restrict  */)(pai->qu)->vb.buf,
           (unsigned long )naddrs * sizeof(adns_rr_addr ));
#line 445
    ha->naddrs = naddrs;
#line 446
    ha->astatus = (adns_status )0;
#line 448
    adns__isort((void *)ha->addrs, naddrs, (int )sizeof(adns_rr_addr ), (void *)(pai->qu)->vb.buf,
                & div_addr___10, (void *)pai->ads);
    }
  }
#line 451
  return ((adns_status )0);
}
}
#line 454 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void icb_hostaddr___10(adns_query parent , adns_query child ) 
{ 
  adns_answer *cans ;
  adns_rr_hostaddr *rrp ;
  adns_state ads___7 ;
  adns_status st ;

  {
#line 455
  cans = child->answer;
#line 456
  rrp = child->ctx.info.hostaddr;
#line 457
  ads___7 = parent->ads;
#line 460
  st = cans->status;
#line 461
  rrp->astatus = st;
#line 462
  if ((unsigned int )st > 0U) {
#line 462
    if ((unsigned int )st <= 99U) {
#line 462
      rrp->naddrs = -1;
    } else {
#line 462
      rrp->naddrs = cans->nrrs;
    }
  } else {
#line 462
    rrp->naddrs = cans->nrrs;
  }
  {
#line 463
  rrp->addrs = cans->rrs.addr;
#line 464
  adns__transfer_interim(child, parent, (void *)rrp->addrs, (unsigned long )rrp->naddrs * sizeof(adns_rr_addr ));
  }
#line 467
  if (parent->children.head) {
    {
#line 468
    while (1) {
      while_continue: /* CIL Label */ ;
#line 468
      parent->next = (adns_query )0;
#line 468
      parent->back = ads___7->childw.tail;
#line 468
      if (ads___7->childw.tail) {
#line 468
        (ads___7->childw.tail)->next = parent;
      } else {
#line 468
        ads___7->childw.head = parent;
      }
#line 468
      ads___7->childw.tail = parent;
#line 468
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 470
    adns__query_done(parent);
    }
  }
#line 472
  return;
}
}
#line 474 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pap_hostaddr___10(parseinfo const   *pai , int *cbyte_io , int max ,
                                     adns_rr_hostaddr *rrp ) 
{ 
  adns_status st ;
  int dmstart ;
  int cbyte___3 ;
  qcontext ctx ;
  int id ;
  adns_query nqu ;
  adns_queryflags nflags ;
  int tmp ;
  typeinfo const   *tmp___0 ;

  {
#line 483
  cbyte___3 = *cbyte_io;
#line 483
  dmstart = cbyte___3;
#line 484
  if ((pai->qu)->flags & 64) {
#line 484
    tmp = 1;
  } else {
#line 484
    tmp = 0;
  }
  {
#line 484
  st = pap_domain___10(pai, & cbyte___3, max, & rrp->host, (parsedomain_flags )tmp);
  }
#line 486
  if (st) {
#line 486
    return (st);
  }
  {
#line 487
  *cbyte_io = cbyte___3;
#line 489
  rrp->astatus = (adns_status )0;
#line 490
  rrp->naddrs = -1;
#line 491
  rrp->addrs = (adns_rr_addr *)0;
#line 493
  cbyte___3 = (int )pai->nsstart;
#line 495
  st = pap_findaddrs___10(pai, rrp, & cbyte___3, (int )pai->nscount, dmstart);
  }
#line 496
  if (st) {
#line 496
    return (st);
  }
#line 497
  if (rrp->naddrs != -1) {
#line 497
    return ((adns_status )0);
  }
  {
#line 499
  st = pap_findaddrs___10(pai, rrp, & cbyte___3, (int )pai->arcount, dmstart);
  }
#line 500
  if (st) {
#line 500
    return (st);
  }
#line 501
  if (rrp->naddrs != -1) {
#line 501
    return ((adns_status )0);
  }
  {
#line 503
  st = adns__mkquery_frdgram((adns_state )pai->ads, & (pai->qu)->vb, & id, (byte const   *)pai->dgram,
                             (int )pai->dglen, dmstart, (adns_rrtype )65537, (adns_queryflags )16);
  }
#line 506
  if (st) {
#line 506
    return (st);
  }
#line 508
  ctx.ext = (void *)0;
#line 509
  ctx.callback = & icb_hostaddr___10;
#line 510
  ctx.info.hostaddr = rrp;
#line 512
  nflags = (adns_queryflags )16;
#line 513
  if (! ((pai->qu)->flags & 256)) {
#line 513
    nflags = (adns_queryflags )((unsigned int )nflags | 512U);
  }
  {
#line 515
  tmp___0 = adns__findtype((adns_rrtype )65537);
#line 515
  st = adns__internal_submit((adns_state )pai->ads, & nqu, tmp___0, & (pai->qu)->vb,
                             id, nflags, (struct timeval )pai->now, (qcontext const   *)(& ctx));
  }
#line 517
  if (st) {
#line 517
    return (st);
  }
#line 519
  nqu->parent = (adns_query )pai->qu;
  {
#line 520
  while (1) {
    while_continue: /* CIL Label */ ;
#line 520
    nqu->siblings.next = (adns_query )0;
#line 520
    nqu->siblings.back = (pai->qu)->children.tail;
#line 520
    if ((pai->qu)->children.tail) {
#line 520
      ((pai->qu)->children.tail)->siblings.next = nqu;
    } else {
#line 520
      (pai->qu)->children.head = nqu;
    }
#line 520
    (pai->qu)->children.tail = nqu;
#line 520
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 522
  return ((adns_status )0);
}
}
#line 525 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_hostaddr___10(parseinfo const   *pai , int cbyte___3 , int max ,
                                    void *datap ) 
{ 
  adns_rr_hostaddr *rrp ;
  adns_status st ;

  {
  {
#line 527
  rrp = (adns_rr_hostaddr *)datap;
#line 530
  st = pap_hostaddr___10(pai, & cbyte___3, max, rrp);
  }
#line 531
  if (st) {
#line 531
    return (st);
  }
#line 532
  if (cbyte___3 != max) {
#line 532
    return ((adns_status )104);
  }
#line 534
  return ((adns_status )0);
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int dip_hostaddr___10(adns_state ads___7 , adns_rr_hostaddr const   *ap , adns_rr_hostaddr const   *bp ) 
{ 
  int tmp ;

  {
#line 539
  if ((unsigned int const   )ap->astatus != (unsigned int const   )bp->astatus) {
#line 539
    return ((int )ap->astatus);
  }
#line 540
  if (ap->astatus) {
#line 540
    return (0);
  }
#line 542
  if (! ((int )(ap->addrs + 0)->addr.sa.sa_family == 2)) {
    {
#line 542
    __assert_fail("ap->addrs[0].addr.sa.sa_family == 2", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                  542U, "dip_hostaddr");
    }
  }
#line 543
  if (! ((int )(bp->addrs + 0)->addr.sa.sa_family == 2)) {
    {
#line 543
    __assert_fail("bp->addrs[0].addr.sa.sa_family == 2", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                  543U, "dip_hostaddr");
    }
  }
  {
#line 544
  tmp = dip_inaddr___10(ads___7, (ap->addrs + 0)->addr.inet.sin_addr, (bp->addrs + 0)->addr.inet.sin_addr);
  }
#line 544
  return (tmp);
}
}
#line 549 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int di_hostaddr___10(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_hostaddr const   *ap ;
  adns_rr_hostaddr const   *bp ;
  int tmp ;

  {
  {
#line 551
  ap = (adns_rr_hostaddr const   *)datap_a;
#line 551
  bp = (adns_rr_hostaddr const   *)datap_b;
#line 553
  tmp = dip_hostaddr___10(ads___7, ap, bp);
  }
#line 553
  return (tmp);
}
}
#line 556 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mfp_hostaddr___10(adns_query qu , adns_rr_hostaddr *rrp ) 
{ 
  void *tablev ;

  {
  {
#line 559
  adns__makefinal_str(qu, & rrp->host);
#line 560
  tablev = (void *)rrp->addrs;
#line 561
  adns__makefinal_block(qu, & tablev, (unsigned long )rrp->naddrs * sizeof(*(rrp->addrs)));
#line 562
  rrp->addrs = (adns_rr_addr *)tablev;
  }
#line 563
  return;
}
}
#line 565 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_hostaddr___10(adns_query qu , void *datap ) 
{ 
  adns_rr_hostaddr *rrp ;

  {
  {
#line 566
  rrp = (adns_rr_hostaddr *)datap;
#line 568
  mfp_hostaddr___10(qu, rrp);
  }
#line 569
  return;
}
}
#line 571 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status csp_hostaddr___10(vbuf *vb___0 , adns_rr_hostaddr const   *rrp ) 
{ 
  char const   *errstr ;
  adns_status st ;
  char buf___17[20] ;
  int i ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 577
  st = csp_domain___10(vb___0, (char const   *)rrp->host);
  }
#line 577
  if (st) {
#line 577
    return (st);
  }
  {
#line 579
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 579
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 579
    if (! tmp) {
#line 579
      return ((adns_status )1);
    }
#line 579
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 580
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 580
    tmp___0 = adns_errtypeabbrev((adns_status )rrp->astatus);
#line 580
    tmp___1 = adns__vbuf_appendstr(vb___0, tmp___0);
    }
#line 580
    if (! tmp___1) {
#line 580
      return ((adns_status )1);
    }
#line 580
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 582
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %d ",
          (unsigned int const   )rrp->astatus);
  }
  {
#line 583
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 583
    tmp___2 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 583
    if (! tmp___2) {
#line 583
      return ((adns_status )1);
    }
#line 583
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 585
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 585
    tmp___3 = adns_errabbrev((adns_status )rrp->astatus);
#line 585
    tmp___4 = adns__vbuf_appendstr(vb___0, tmp___3);
    }
#line 585
    if (! tmp___4) {
#line 585
      return ((adns_status )1);
    }
#line 585
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 586
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 586
    tmp___5 = adns__vbuf_appendstr(vb___0, " ");
    }
#line 586
    if (! tmp___5) {
#line 586
      return ((adns_status )1);
    }
#line 586
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 588
  errstr = adns_strerror((adns_status )rrp->astatus);
#line 589
  tmp___6 = strlen(errstr);
#line 589
  st = csp_qstring___10(vb___0, errstr, (int )tmp___6);
  }
#line 589
  if (st) {
#line 589
    return (st);
  }
#line 591
  if (rrp->naddrs >= 0) {
    {
#line 592
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 592
      tmp___7 = adns__vbuf_appendstr(vb___0, " (");
      }
#line 592
      if (! tmp___7) {
#line 592
        return ((adns_status )1);
      }
#line 592
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 593
    i = 0;
    {
#line 593
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 593
      if (! (i < (int )rrp->naddrs)) {
#line 593
        goto while_break___5;
      }
      {
#line 594
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 594
        tmp___8 = adns__vbuf_appendstr(vb___0, " ");
        }
#line 594
        if (! tmp___8) {
#line 594
          return ((adns_status )1);
        }
#line 594
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 595
      st = csp_addr___10(vb___0, (adns_rr_addr const   *)(rrp->addrs + i));
#line 593
      i ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 597
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 597
      tmp___9 = adns__vbuf_appendstr(vb___0, " )");
      }
#line 597
      if (! tmp___9) {
#line 597
        return ((adns_status )1);
      }
#line 597
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
  } else {
    {
#line 599
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 599
      tmp___10 = adns__vbuf_appendstr(vb___0, " ?");
      }
#line 599
      if (! tmp___10) {
#line 599
        return ((adns_status )1);
      }
#line 599
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
#line 601
  return ((adns_status )0);
}
}
#line 604 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_hostaddr___10(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_hostaddr const   *rrp ;
  adns_status tmp ;

  {
  {
#line 605
  rrp = (adns_rr_hostaddr const   *)datap;
#line 607
  tmp = csp_hostaddr___10(vb___0, rrp);
  }
#line 607
  return (tmp);
}
}
#line 614 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_mx_raw___10(parseinfo const   *pai , int cbyte___3 , int max ,
                                  void *datap ) 
{ 
  byte const   *dgram ;
  adns_rr_intstr *rrp ;
  adns_status st ;
  int pref ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 616
  dgram = (byte const   *)pai->dgram;
#line 617
  rrp = (adns_rr_intstr *)datap;
#line 621
  if (cbyte___3 + 2 > max) {
#line 621
    return ((adns_status )104);
  }
#line 622
  pref = 0;
#line 622
  tmp = cbyte___3;
#line 622
  cbyte___3 ++;
#line 622
  pref |= (int )(((int const   )*(dgram + tmp) & 255) << 8);
#line 622
  tmp___0 = cbyte___3;
#line 622
  cbyte___3 ++;
#line 622
  pref |= (int )((int const   )*(dgram + tmp___0) & 255);
#line 623
  rrp->i = pref;
#line 624
  if ((pai->qu)->flags & 64) {
#line 624
    tmp___1 = 1;
  } else {
#line 624
    tmp___1 = 0;
  }
  {
#line 624
  st = pap_domain___10(pai, & cbyte___3, max, & rrp->str, (parsedomain_flags )tmp___1);
  }
#line 626
  if (st) {
#line 626
    return (st);
  }
#line 628
  if (cbyte___3 != max) {
#line 628
    return ((adns_status )104);
  }
#line 629
  return ((adns_status )0);
}
}
#line 632 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int di_mx_raw___10(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_intstr const   *ap ;
  adns_rr_intstr const   *bp ;

  {
#line 633
  ap = (adns_rr_intstr const   *)datap_a;
#line 633
  bp = (adns_rr_intstr const   *)datap_b;
#line 635
  if (ap->i < bp->i) {
#line 635
    return (0);
  }
#line 636
  if (ap->i > bp->i) {
#line 636
    return (1);
  }
#line 637
  return (0);
}
}
#line 644 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_mx___10(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  byte const   *dgram ;
  adns_rr_inthostaddr *rrp ;
  adns_status st ;
  int pref ;
  int tmp ;
  int tmp___0 ;

  {
#line 646
  dgram = (byte const   *)pai->dgram;
#line 647
  rrp = (adns_rr_inthostaddr *)datap;
#line 651
  if (cbyte___3 + 2 > max) {
#line 651
    return ((adns_status )104);
  }
  {
#line 652
  pref = 0;
#line 652
  tmp = cbyte___3;
#line 652
  cbyte___3 ++;
#line 652
  pref |= (int )(((int const   )*(dgram + tmp) & 255) << 8);
#line 652
  tmp___0 = cbyte___3;
#line 652
  cbyte___3 ++;
#line 652
  pref |= (int )((int const   )*(dgram + tmp___0) & 255);
#line 653
  rrp->i = pref;
#line 654
  st = pap_hostaddr___10(pai, & cbyte___3, max, & rrp->ha);
  }
#line 655
  if (st) {
#line 655
    return (st);
  }
#line 657
  if (cbyte___3 != max) {
#line 657
    return ((adns_status )104);
  }
#line 658
  return ((adns_status )0);
}
}
#line 661 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int di_mx___10(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_inthostaddr const   *ap ;
  adns_rr_inthostaddr const   *bp ;
  int tmp ;

  {
#line 662
  ap = (adns_rr_inthostaddr const   *)datap_a;
#line 662
  bp = (adns_rr_inthostaddr const   *)datap_b;
#line 664
  if (ap->i < bp->i) {
#line 664
    return (0);
  }
#line 665
  if (ap->i > bp->i) {
#line 665
    return (1);
  }
  {
#line 666
  tmp = dip_hostaddr___10(ads___7, & ap->ha, & bp->ha);
  }
#line 666
  return (tmp);
}
}
#line 673 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_inthostaddr___10(adns_query qu , void *datap ) 
{ 
  adns_rr_inthostaddr *rrp ;

  {
  {
#line 674
  rrp = (adns_rr_inthostaddr *)datap;
#line 676
  mfp_hostaddr___10(qu, & rrp->ha);
  }
#line 677
  return;
}
}
#line 679 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_inthostaddr___10(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_inthostaddr const   *rrp ;
  char buf___17[10] ;
  int tmp ;
  adns_status tmp___0 ;

  {
  {
#line 680
  rrp = (adns_rr_inthostaddr const   *)datap;
#line 683
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"%u ",
          rrp->i);
  }
  {
#line 684
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 684
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 684
    if (! tmp) {
#line 684
      return ((adns_status )1);
    }
#line 684
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 686
  tmp___0 = csp_hostaddr___10(vb___0, & rrp->ha);
  }
#line 686
  return (tmp___0);
}
}
#line 693 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_inthost___10(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_intstr const   *rrp ;
  char buf___17[10] ;
  int tmp ;
  adns_status tmp___0 ;

  {
  {
#line 694
  rrp = (adns_rr_intstr const   *)datap;
#line 697
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"%u ",
          rrp->i);
  }
  {
#line 698
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 698
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 698
    if (! tmp) {
#line 698
      return ((adns_status )1);
    }
#line 698
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 699
  tmp___0 = csp_domain___10(vb___0, (char const   *)rrp->str);
  }
#line 699
  return (tmp___0);
}
}
#line 706 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void icb_ptr___10(adns_query parent , adns_query child ) 
{ 
  adns_answer *cans ;
  adns_rr_addr const   *queried ;
  adns_rr_addr const   *found ;
  adns_state ads___7 ;
  int i ;
  int tmp ;

  {
#line 707
  cans = child->answer;
#line 709
  ads___7 = parent->ads;
#line 712
  if ((unsigned int )cans->status == 300U) {
    {
#line 713
    adns__query_fail(parent, (adns_status )100);
    }
#line 714
    return;
  } else
#line 712
  if ((unsigned int )cans->status == 301U) {
    {
#line 713
    adns__query_fail(parent, (adns_status )100);
    }
#line 714
    return;
  } else
#line 715
  if (cans->status) {
    {
#line 716
    adns__query_fail(parent, cans->status);
    }
#line 717
    return;
  }
#line 720
  queried = (adns_rr_addr const   *)(& parent->ctx.info.ptr_parent_addr);
#line 721
  i = 0;
#line 721
  found = (adns_rr_addr const   *)cans->rrs.addr;
  {
#line 721
  while (1) {
    while_continue: /* CIL Label */ ;
#line 721
    if (! (i < cans->nrrs)) {
#line 721
      goto while_break;
    }
#line 722
    if (queried->len == found->len) {
      {
#line 722
      tmp = memcmp((void const   *)(& queried->addr), (void const   *)(& found->addr),
                   (size_t )queried->len);
      }
#line 722
      if (! tmp) {
#line 724
        if (! parent->children.head) {
          {
#line 725
          adns__query_done(parent);
          }
#line 726
          return;
        } else {
          {
#line 728
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 728
            parent->next = (adns_query )0;
#line 728
            parent->back = ads___7->childw.tail;
#line 728
            if (ads___7->childw.tail) {
#line 728
              (ads___7->childw.tail)->next = parent;
            } else {
#line 728
              ads___7->childw.head = parent;
            }
#line 728
            ads___7->childw.tail = parent;
#line 728
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 729
          return;
        }
      }
    }
#line 721
    i ++;
#line 721
    found ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 734
  adns__query_fail(parent, (adns_status )100);
  }
#line 735
  return;
}
}
#line 739
static adns_status pa_ptr___10(parseinfo const   *pai , int dmstart , int max , void *datap ) ;
#line 739 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static char const   * const  expectdomain___10[2]  = {      (char const   */* const  */)"in-addr",      (char const   */* const  */)"arpa"};
#line 737 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_ptr___10(parseinfo const   *pai , int dmstart , int max , void *datap ) 
{ 
  char **rrp ;
  adns_status st ;
  adns_rr_addr *ap ;
  findlabel_state fls ;
  char *ep ;
  byte ipv[4] ;
  char labbuf[4] ;
  int cbyte___3 ;
  int i ;
  int lablen ;
  int labstart ;
  int l ;
  int id ;
  adns_query nqu ;
  qcontext ctx ;
  int tmp ;
  unsigned long tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  typeinfo const   *tmp___3 ;

  {
#line 741
  rrp = (char **)datap;
#line 752
  cbyte___3 = dmstart;
#line 753
  if ((pai->qu)->flags & 64) {
#line 753
    tmp = 1;
  } else {
#line 753
    tmp = 0;
  }
  {
#line 753
  st = pap_domain___10(pai, & cbyte___3, max, rrp, (parsedomain_flags )tmp);
  }
#line 755
  if (st) {
#line 755
    return (st);
  }
#line 756
  if (cbyte___3 != max) {
#line 756
    return ((adns_status )104);
  }
#line 758
  ap = & (pai->qu)->ctx.info.ptr_parent_addr;
#line 759
  if (! ap->len) {
    {
#line 760
    adns__findlabel_start(& fls, (adns_state )pai->ads, -1, (adns_query )pai->qu,
                          (byte const   *)(pai->qu)->query_dgram, (pai->qu)->query_dglen,
                          (pai->qu)->query_dglen, 12, (int *)0);
#line 763
    i = 0;
    }
    {
#line 763
    while (1) {
      while_continue: /* CIL Label */ ;
#line 763
      if (! (i < 4)) {
#line 763
        goto while_break;
      }
      {
#line 764
      st = adns__findlabel_next(& fls, & lablen, & labstart);
      }
#line 764
      if (! (! st)) {
        {
#line 764
        __assert_fail("!st", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                      764U, "pa_ptr");
        }
      }
#line 765
      if (lablen <= 0) {
#line 765
        return ((adns_status )200);
      } else
#line 765
      if (lablen > 3) {
#line 765
        return ((adns_status )200);
      }
      {
#line 766
      memcpy((void */* __restrict  */)(labbuf), (void const   */* __restrict  */)((pai->qu)->query_dgram + labstart),
             (size_t )lablen);
#line 767
      labbuf[lablen] = (char)0;
#line 768
      tmp___0 = strtoul((char const   */* __restrict  */)(labbuf), (char **/* __restrict  */)(& ep),
                        10);
#line 768
      ipv[3 - i] = (byte )tmp___0;
      }
#line 769
      if (*ep) {
#line 769
        return ((adns_status )200);
      }
#line 770
      if (lablen > 1) {
#line 770
        if ((int )*((pai->qu)->query_dgram + labstart) == 48) {
#line 771
          return ((adns_status )200);
        }
      }
#line 763
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 773
    i = 0;
    {
#line 773
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 773
      if (! ((unsigned long )i < sizeof(expectdomain___10) / sizeof(expectdomain___10[0]))) {
#line 773
        goto while_break___0;
      }
      {
#line 774
      st = adns__findlabel_next(& fls, & lablen, & labstart);
      }
#line 774
      if (! (! st)) {
        {
#line 774
        __assert_fail("!st", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                      774U, "pa_ptr");
        }
      }
      {
#line 775
      tmp___1 = strlen((char const   *)expectdomain___10[i]);
#line 775
      l = (int )tmp___1;
      }
#line 776
      if (lablen != l) {
#line 778
        return ((adns_status )200);
      } else {
        {
#line 776
        tmp___2 = memcmp((void const   *)((pai->qu)->query_dgram + labstart), (void const   *)expectdomain___10[i],
                         (size_t )l);
        }
#line 776
        if (tmp___2) {
#line 778
          return ((adns_status )200);
        }
      }
#line 773
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 780
    st = adns__findlabel_next(& fls, & lablen, (int *)0);
    }
#line 780
    if (! (! st)) {
      {
#line 780
      __assert_fail("!st", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                    780U, "pa_ptr");
      }
    }
#line 781
    if (lablen) {
#line 781
      return ((adns_status )200);
    }
    {
#line 783
    ap->len = (int )sizeof(struct sockaddr_in );
#line 784
    memset((void *)(& ap->addr), 0, sizeof(ap->addr.inet));
#line 785
    ap->addr.inet.sin_family = (sa_family_t )2;
#line 786
    ap->addr.inet.sin_addr.s_addr = htonl((uint32_t )(((((int )ipv[0] << 24) | ((int )ipv[1] << 16)) | ((int )ipv[2] << 8)) | (int )ipv[3]));
    }
  }
  {
#line 790
  st = adns__mkquery_frdgram((adns_state )pai->ads, & (pai->qu)->vb, & id, (byte const   *)pai->dgram,
                             (int )pai->dglen, dmstart, (adns_rrtype )65537, (adns_queryflags )16);
  }
#line 793
  if (st) {
#line 793
    return (st);
  }
  {
#line 795
  ctx.ext = (void *)0;
#line 796
  ctx.callback = & icb_ptr___10;
#line 797
  memset((void *)(& ctx.info), 0, sizeof(ctx.info));
#line 798
  tmp___3 = adns__findtype((adns_rrtype )65537);
#line 798
  st = adns__internal_submit((adns_state )pai->ads, & nqu, tmp___3, & (pai->qu)->vb,
                             id, (adns_queryflags )16, (struct timeval )pai->now,
                             (qcontext const   *)(& ctx));
  }
#line 801
  if (st) {
#line 801
    return (st);
  }
#line 803
  nqu->parent = (adns_query )pai->qu;
  {
#line 804
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 804
    nqu->siblings.next = (adns_query )0;
#line 804
    nqu->siblings.back = (pai->qu)->children.tail;
#line 804
    if ((pai->qu)->children.tail) {
#line 804
      ((pai->qu)->children.tail)->siblings.next = nqu;
    } else {
#line 804
      (pai->qu)->children.head = nqu;
    }
#line 804
    (pai->qu)->children.tail = nqu;
#line 804
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 805
  return ((adns_status )0);
}
}
#line 812 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_strpair___10(adns_query qu , void *datap ) 
{ 
  adns_rr_strpair *rrp ;

  {
  {
#line 813
  rrp = (adns_rr_strpair *)datap;
#line 815
  adns__makefinal_str(qu, & rrp->array[0]);
#line 816
  adns__makefinal_str(qu, & rrp->array[1]);
  }
#line 817
  return;
}
}
#line 823 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_intstrpair___10(adns_query qu , void *datap ) 
{ 
  adns_rr_intstrpair *rrp ;

  {
  {
#line 824
  rrp = (adns_rr_intstrpair *)datap;
#line 826
  adns__makefinal_str(qu, & rrp->array[0].str);
#line 827
  adns__makefinal_str(qu, & rrp->array[1].str);
  }
#line 828
  return;
}
}
#line 834 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_hinfo___10(parseinfo const   *pai , int cbyte___3 , int max ,
                                 void *datap ) 
{ 
  adns_rr_intstrpair *rrp ;
  adns_status st ;
  int i ;

  {
#line 836
  rrp = (adns_rr_intstrpair *)datap;
#line 840
  i = 0;
  {
#line 840
  while (1) {
    while_continue: /* CIL Label */ ;
#line 840
    if (! (i < 2)) {
#line 840
      goto while_break;
    }
    {
#line 841
    st = pap_qstring___10(pai, & cbyte___3, max, & rrp->array[i].i, & rrp->array[i].str);
    }
#line 842
    if (st) {
#line 842
      return (st);
    }
#line 840
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 845
  if (cbyte___3 != max) {
#line 845
    return ((adns_status )104);
  }
#line 847
  return ((adns_status )0);
}
}
#line 854 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pap_mailbox822___10(parseinfo const   *pai , int *cbyte_io , int max ,
                                       char **mb_r ) 
{ 
  int lablen ;
  int labstart ;
  int i ;
  int needquote ;
  int c ;
  int r ;
  int neednorm ;
  unsigned char const   *p ;
  char *str ;
  findlabel_state fls ;
  adns_status st ;
  vbuf *vb___0 ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 863
  vb___0 = & (pai->qu)->vb;
#line 864
  vb___0->used = 0;
#line 865
  adns__findlabel_start(& fls, (adns_state )pai->ads, -1, (adns_query )pai->qu, (byte const   *)pai->dgram,
                        (int )pai->dglen, max, *cbyte_io, cbyte_io);
#line 869
  st = adns__findlabel_next(& fls, & lablen, & labstart);
  }
#line 870
  if (! lablen) {
    {
#line 871
    adns__vbuf_appendstr(vb___0, ".");
    }
#line 872
    goto x_ok;
  }
#line 875
  neednorm = 1;
#line 876
  i = 0;
#line 876
  needquote = 0;
#line 876
  p = (unsigned char const   *)(pai->dgram + labstart);
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (! (i < lablen)) {
#line 876
      goto while_break;
    }
#line 877
    tmp = p;
#line 877
    p ++;
#line 877
    c = (int )*tmp;
#line 878
    if ((c & -129) < 32) {
#line 878
      return ((adns_status )104);
    } else
#line 878
    if ((c & -129) == 127) {
#line 878
      return ((adns_status )104);
    }
#line 879
    if (c == 46) {
#line 879
      if (! neednorm) {
#line 879
        neednorm = 1;
      } else {
#line 879
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 880
    if (c == 32) {
#line 880
      needquote ++;
    } else
#line 880
    if (c >= 127) {
#line 880
      needquote ++;
    } else {
      {
#line 880
      tmp___0 = ctype_822special(c);
      }
#line 880
      if (tmp___0) {
#line 880
        needquote ++;
      } else {
#line 881
        neednorm = 0;
      }
    }
#line 876
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 884
  if (needquote) {
#line 884
    goto _L___0;
  } else
#line 884
  if (neednorm) {
    _L___0: /* CIL Label */ 
    {
#line 885
    r = adns__vbuf_ensure(vb___0, (lablen + needquote) + 4);
    }
#line 885
    if (! r) {
#line 885
      return ((adns_status )1);
    }
    {
#line 886
    adns__vbuf_appendq(vb___0, (byte const   *)"\"", 1);
#line 887
    i = 0;
#line 887
    needquote = 0;
#line 887
    p = (unsigned char const   *)(pai->dgram + labstart);
    }
    {
#line 887
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 887
      if (! (i < lablen)) {
#line 887
        goto while_break___0;
      }
#line 888
      c = (int )*p;
#line 889
      if (c == 34) {
        {
#line 889
        adns__vbuf_appendq(vb___0, (byte const   *)"\\", 1);
        }
      } else
#line 889
      if (c == 92) {
        {
#line 889
        adns__vbuf_appendq(vb___0, (byte const   *)"\\", 1);
        }
      }
      {
#line 890
      adns__vbuf_appendq(vb___0, p, 1);
#line 887
      i ++;
#line 887
      p ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 892
    adns__vbuf_appendq(vb___0, (byte const   *)"\"", 1);
    }
  } else {
    {
#line 894
    r = adns__vbuf_append(vb___0, (byte const   *)(pai->dgram + labstart), lablen);
    }
#line 894
    if (! r) {
#line 894
      return ((adns_status )1);
    }
  }
  {
#line 897
  r = adns__vbuf_appendstr(vb___0, "@");
  }
#line 897
  if (! r) {
#line 897
    return ((adns_status )1);
  }
  {
#line 899
  st = adns__parse_domain_more(& fls, (adns_state )pai->ads, (adns_query )pai->qu,
                               vb___0, (parsedomain_flags )0, (byte const   *)pai->dgram);
  }
#line 900
  if (st) {
#line 900
    return (st);
  }
  x_ok: 
  {
#line 903
  tmp___1 = adns__alloc_interim((adns_query )pai->qu, (size_t )(vb___0->used + 1));
#line 903
  str = (char *)tmp___1;
  }
#line 903
  if (! str) {
#line 903
    return ((adns_status )1);
  }
  {
#line 904
  memcpy((void */* __restrict  */)str, (void const   */* __restrict  */)vb___0->buf,
         (size_t )vb___0->used);
#line 905
  *(str + vb___0->used) = (char)0;
#line 906
  *mb_r = str;
  }
#line 907
  return ((adns_status )0);
}
}
#line 910 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pap_mailbox___10(parseinfo const   *pai , int *cbyte_io , int max ,
                                    char **mb_r ) 
{ 
  adns_status tmp ;
  adns_status tmp___0 ;

  {
#line 912
  if ((unsigned int const   )((pai->qu)->typei)->typekey & 131072U) {
    {
#line 913
    tmp = pap_mailbox822___10(pai, cbyte_io, max, mb_r);
    }
#line 913
    return (tmp);
  } else {
    {
#line 915
    tmp___0 = pap_domain___10(pai, cbyte_io, max, mb_r, (parsedomain_flags )1);
    }
#line 915
    return (tmp___0);
  }
}
}
#line 919 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status csp_mailbox___10(vbuf *vb___0 , char const   *mailbox ) 
{ 
  adns_status tmp ;

  {
  {
#line 920
  tmp = csp_domain___10(vb___0, mailbox);
  }
#line 920
  return (tmp);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_rp___10(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  adns_rr_strpair *rrp ;
  adns_status st ;

  {
  {
#line 929
  rrp = (adns_rr_strpair *)datap;
#line 932
  st = pap_mailbox___10(pai, & cbyte___3, max, & rrp->array[0]);
  }
#line 933
  if (st) {
#line 933
    return (st);
  }
  {
#line 935
  st = pap_domain___10(pai, & cbyte___3, max, & rrp->array[1], (parsedomain_flags )1);
  }
#line 936
  if (st) {
#line 936
    return (st);
  }
#line 938
  if (cbyte___3 != max) {
#line 938
    return ((adns_status )104);
  }
#line 939
  return ((adns_status )0);
}
}
#line 942 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_rp___10(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_strpair const   *rrp ;
  adns_status st ;
  int tmp ;

  {
  {
#line 943
  rrp = (adns_rr_strpair const   *)datap;
#line 946
  st = csp_mailbox___10(vb___0, (char const   *)rrp->array[0]);
  }
#line 946
  if (st) {
#line 946
    return (st);
  }
  {
#line 947
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 947
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 947
    if (! tmp) {
#line 947
      return ((adns_status )1);
    }
#line 947
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 948
  st = csp_domain___10(vb___0, (char const   *)rrp->array[1]);
  }
#line 948
  if (st) {
#line 948
    return (st);
  }
#line 950
  return ((adns_status )0);
}
}
#line 957 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_soa___10(parseinfo const   *pai , int cbyte___3 , int max ,
                               void *datap ) 
{ 
  adns_rr_soa *rrp ;
  byte const   *dgram ;
  adns_status st ;
  int msw ;
  int lsw ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 959
  rrp = (adns_rr_soa *)datap;
#line 960
  dgram = (byte const   *)pai->dgram;
#line 964
  if ((pai->qu)->flags & 64) {
#line 964
    tmp = 1;
  } else {
#line 964
    tmp = 0;
  }
  {
#line 964
  st = pap_domain___10(pai, & cbyte___3, max, & rrp->mname, (parsedomain_flags )tmp);
  }
#line 966
  if (st) {
#line 966
    return (st);
  }
  {
#line 968
  st = pap_mailbox___10(pai, & cbyte___3, max, & rrp->rname);
  }
#line 969
  if (st) {
#line 969
    return (st);
  }
#line 971
  if (cbyte___3 + 20 != max) {
#line 971
    return ((adns_status )104);
  }
#line 973
  i = 0;
  {
#line 973
  while (1) {
    while_continue: /* CIL Label */ ;
#line 973
    if (! (i < 5)) {
#line 973
      goto while_break;
    }
#line 974
    msw = 0;
#line 974
    tmp___0 = cbyte___3;
#line 974
    cbyte___3 ++;
#line 974
    msw |= (int )(((int const   )*(dgram + tmp___0) & 255) << 8);
#line 974
    tmp___1 = cbyte___3;
#line 974
    cbyte___3 ++;
#line 974
    msw |= (int )((int const   )*(dgram + tmp___1) & 255);
#line 975
    lsw = 0;
#line 975
    tmp___2 = cbyte___3;
#line 975
    cbyte___3 ++;
#line 975
    lsw |= (int )(((int const   )*(dgram + tmp___2) & 255) << 8);
#line 975
    tmp___3 = cbyte___3;
#line 975
    cbyte___3 ++;
#line 975
    lsw |= (int )((int const   )*(dgram + tmp___3) & 255);
#line 976
    *(& rrp->serial + i) = (unsigned long )((msw << 16) | lsw);
#line 973
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 979
  return ((adns_status )0);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_soa___10(adns_query qu , void *datap ) 
{ 
  adns_rr_soa *rrp ;

  {
  {
#line 983
  rrp = (adns_rr_soa *)datap;
#line 985
  adns__makefinal_str(qu, & rrp->mname);
#line 986
  adns__makefinal_str(qu, & rrp->rname);
  }
#line 987
  return;
}
}
#line 989 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_soa___10(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_soa const   *rrp ;
  char buf___17[20] ;
  int i ;
  adns_status st ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 990
  rrp = (adns_rr_soa const   *)datap;
#line 995
  st = csp_domain___10(vb___0, (char const   *)rrp->mname);
  }
#line 995
  if (st) {
#line 995
    return (st);
  }
  {
#line 996
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 996
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 996
    if (! tmp) {
#line 996
      return ((adns_status )1);
    }
#line 996
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 997
  st = csp_mailbox___10(vb___0, (char const   *)rrp->rname);
  }
#line 997
  if (st) {
#line 997
    return (st);
  }
#line 999
  i = 0;
  {
#line 999
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 999
    if (! (i < 5)) {
#line 999
      goto while_break___0;
    }
    {
#line 1000
    sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %lu",
            *(& rrp->serial + i));
    }
    {
#line 1001
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1001
      tmp___0 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
      }
#line 1001
      if (! tmp___0) {
#line 1001
        return ((adns_status )1);
      }
#line 1001
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 999
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1004
  return ((adns_status )0);
}
}
#line 1011 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status qdpl_srv___10(adns_state ads___7 , char const   **p_io , char const   *pe ,
                                 int labelnum , char *label_r , int *ll_io , adns_queryflags flags ,
                                 typeinfo const   *typei ) 
{ 
  int useflags ;
  char const   *p_orig ;
  adns_status st ;
  int ll ;
  void *tmp ;

  {
#line 1020
  if (labelnum < 2) {
#line 1020
    if (! ((unsigned int )flags & 16U)) {
#line 1021
      useflags = 16;
#line 1022
      p_orig = *p_io;
    } else {
#line 1024
      useflags = (int )flags;
#line 1025
      p_orig = (char const   *)0;
    }
  } else {
#line 1024
    useflags = (int )flags;
#line 1025
    p_orig = (char const   *)0;
  }
  {
#line 1027
  st = adns__qdpl_normal(ads___7, p_io, pe, labelnum, (char *)label_r, ll_io, (adns_queryflags )useflags,
                         typei);
  }
#line 1028
  if (st) {
#line 1028
    return (st);
  }
#line 1030
  if (p_orig) {
#line 1031
    ll = *ll_io;
#line 1032
    if (! ll) {
#line 1033
      return ((adns_status )201);
    } else
#line 1032
    if ((int )*(label_r + 0) != 95) {
#line 1033
      return ((adns_status )201);
    }
    {
#line 1034
    tmp = memchr((void const   *)(p_orig + 1), '\\', (size_t )(pe - (p_orig + 1)));
    }
#line 1034
    if (tmp) {
#line 1035
      return ((adns_status )201);
    }
  }
#line 1037
  return ((adns_status )0);
}
}
#line 1040 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pap_srv_begin___10(parseinfo const   *pai , int *cbyte_io , int max ,
                                      adns_rr_srvha *rrp ) 
{ 
  byte const   *dgram ;
  int ti ;
  int cbyte___3 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1043
  dgram = (byte const   *)pai->dgram;
#line 1046
  cbyte___3 = *cbyte_io;
#line 1047
  tmp = *cbyte_io + 6;
#line 1047
  *cbyte_io = tmp;
#line 1047
  if (tmp > max) {
#line 1047
    return ((adns_status )104);
  }
#line 1049
  ti = 0;
#line 1049
  tmp___0 = cbyte___3;
#line 1049
  cbyte___3 ++;
#line 1049
  ti |= (int )(((int const   )*(dgram + tmp___0) & 255) << 8);
#line 1049
  tmp___1 = cbyte___3;
#line 1049
  cbyte___3 ++;
#line 1049
  ti |= (int )((int const   )*(dgram + tmp___1) & 255);
#line 1049
  rrp->priority = ti;
#line 1050
  ti = 0;
#line 1050
  tmp___2 = cbyte___3;
#line 1050
  cbyte___3 ++;
#line 1050
  ti |= (int )(((int const   )*(dgram + tmp___2) & 255) << 8);
#line 1050
  tmp___3 = cbyte___3;
#line 1050
  cbyte___3 ++;
#line 1050
  ti |= (int )((int const   )*(dgram + tmp___3) & 255);
#line 1050
  rrp->weight = ti;
#line 1051
  ti = 0;
#line 1051
  tmp___4 = cbyte___3;
#line 1051
  cbyte___3 ++;
#line 1051
  ti |= (int )(((int const   )*(dgram + tmp___4) & 255) << 8);
#line 1051
  tmp___5 = cbyte___3;
#line 1051
  cbyte___3 ++;
#line 1051
  ti |= (int )((int const   )*(dgram + tmp___5) & 255);
#line 1051
  rrp->port = ti;
#line 1052
  return ((adns_status )0);
}
}
#line 1055 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_srvraw___10(parseinfo const   *pai , int cbyte___3 , int max ,
                                  void *datap ) 
{ 
  adns_rr_srvraw *rrp ;
  adns_status st ;
  int tmp ;

  {
  {
#line 1057
  rrp = (adns_rr_srvraw *)datap;
#line 1060
  st = pap_srv_begin___10(pai, & cbyte___3, max, (adns_rr_srvha *)datap);
  }
#line 1061
  if (st) {
#line 1061
    return (st);
  }
#line 1063
  if ((pai->qu)->flags & 64) {
#line 1063
    tmp = 1;
  } else {
#line 1063
    tmp = 0;
  }
  {
#line 1063
  st = pap_domain___10(pai, & cbyte___3, max, & rrp->host, (parsedomain_flags )tmp);
  }
#line 1065
  if (st) {
#line 1065
    return (st);
  }
#line 1067
  if (cbyte___3 != max) {
#line 1067
    return ((adns_status )104);
  }
#line 1068
  return ((adns_status )0);
}
}
#line 1071 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_srvha___10(parseinfo const   *pai , int cbyte___3 , int max ,
                                 void *datap ) 
{ 
  adns_rr_srvha *rrp ;
  adns_status st ;

  {
  {
#line 1073
  rrp = (adns_rr_srvha *)datap;
#line 1076
  st = pap_srv_begin___10(pai, & cbyte___3, max, (adns_rr_srvha *)datap);
  }
#line 1076
  if (st) {
#line 1076
    return (st);
  }
  {
#line 1077
  st = pap_hostaddr___10(pai, & cbyte___3, max, & rrp->ha);
  }
#line 1077
  if (st) {
#line 1077
    return (st);
  }
#line 1078
  if (cbyte___3 != max) {
#line 1078
    return ((adns_status )104);
  }
#line 1079
  return ((adns_status )0);
}
}
#line 1082 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_srvraw___10(adns_query qu , void *datap ) 
{ 
  adns_rr_srvraw *rrp ;

  {
  {
#line 1083
  rrp = (adns_rr_srvraw *)datap;
#line 1084
  adns__makefinal_str(qu, & rrp->host);
  }
#line 1085
  return;
}
}
#line 1087 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_srvha___10(adns_query qu , void *datap ) 
{ 
  adns_rr_srvha *rrp ;

  {
  {
#line 1088
  rrp = (adns_rr_srvha *)datap;
#line 1089
  mfp_hostaddr___10(qu, & rrp->ha);
  }
#line 1090
  return;
}
}
#line 1092 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int di_srv___10(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_srvraw const   *ap ;
  adns_rr_srvraw const   *bp ;

  {
#line 1093
  ap = (adns_rr_srvraw const   *)datap_a;
#line 1093
  bp = (adns_rr_srvraw const   *)datap_b;
#line 1096
  if (ap->priority < bp->priority) {
#line 1096
    return (0);
  }
#line 1097
  if (ap->priority > bp->priority) {
#line 1097
    return (1);
  }
#line 1098
  return (0);
}
}
#line 1101 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status csp_srv_begin___10(vbuf *vb___0 , adns_rr_srvha const   *rrp ) 
{ 
  char buf___17[30] ;
  int tmp ;

  {
  {
#line 1104
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"%u %u %u ",
          rrp->priority, rrp->weight, rrp->port);
  }
  {
#line 1105
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1105
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 1105
    if (! tmp) {
#line 1105
      return ((adns_status )1);
    }
#line 1105
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1106
  return ((adns_status )0);
}
}
#line 1109 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_srvraw___10(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_srvraw const   *rrp ;
  adns_status st ;
  adns_status tmp ;

  {
  {
#line 1110
  rrp = (adns_rr_srvraw const   *)datap;
#line 1113
  st = csp_srv_begin___10(vb___0, (adns_rr_srvha const   *)((void const   *)rrp));
  }
#line 1113
  if (st) {
#line 1113
    return (st);
  }
  {
#line 1114
  tmp = csp_domain___10(vb___0, (char const   *)rrp->host);
  }
#line 1114
  return (tmp);
}
}
#line 1117 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_srvha___10(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_srvha const   *rrp ;
  adns_status st ;
  adns_status tmp ;

  {
  {
#line 1118
  rrp = (adns_rr_srvha const   *)datap;
#line 1121
  st = csp_srv_begin___10(vb___0, (adns_rr_srvha const   *)datap);
  }
#line 1121
  if (st) {
#line 1121
    return (st);
  }
  {
#line 1122
  tmp = csp_hostaddr___10(vb___0, & rrp->ha);
  }
#line 1122
  return (tmp);
}
}
#line 1125 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void postsort_srv___10(adns_state ads___7 , void *array , int nrrs , struct typeinfo  const  *typei ) 
{ 
  char *workbegin ;
  char *workend ;
  char *search ;
  char *arrayend ;
  adns_rr_srvha const   *rr ;
  union __anonunion_rrtmp_89___10 rrtmp ;
  int cpriority ;
  int totalweight ;
  int runtotal ;
  long randval ;

  {
#line 1138
  workbegin = (char *)array;
#line 1138
  arrayend = workbegin + typei->rrsz * (int const   )nrrs;
  {
#line 1138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1138
    if (! ((unsigned long )workbegin < (unsigned long )arrayend)) {
#line 1138
      goto while_break;
    }
#line 1141
    rr = (adns_rr_srvha const   *)((void *)workbegin);
#line 1141
    cpriority = (int )rr->priority;
#line 1143
    workend = workbegin;
#line 1143
    totalweight = 0;
    {
#line 1143
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1143
      if ((unsigned long )workend < (unsigned long )arrayend) {
#line 1143
        rr = (adns_rr_srvha const   *)((void *)workend);
#line 1143
        if (! (rr->priority == (int const   )cpriority)) {
#line 1143
          goto while_break___0;
        }
      } else {
#line 1143
        goto while_break___0;
      }
#line 1146
      totalweight += (int )rr->weight;
#line 1143
      workend += typei->rrsz;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1155
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1155
      if (! ((unsigned long )(workbegin + typei->rrsz) < (unsigned long )workend)) {
#line 1155
        goto while_break___1;
      }
      {
#line 1159
      randval = nrand48((unsigned short *)(ads___7->rand48xsubi));
#line 1160
      randval %= (long )(totalweight + 1);
#line 1167
      search = workbegin;
#line 1167
      runtotal = 0;
      }
      {
#line 1167
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1167
        rr = (adns_rr_srvha const   *)((void *)search);
#line 1167
        runtotal += (int )rr->weight;
#line 1167
        if (! ((long )runtotal < randval)) {
#line 1167
          goto while_break___2;
        }
#line 1167
        search += typei->rrsz;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1170
      if (! ((unsigned long )search < (unsigned long )arrayend)) {
        {
#line 1170
        __assert_fail("search < arrayend", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                      1170U, "postsort_srv");
        }
      }
#line 1171
      totalweight -= (int )rr->weight;
#line 1172
      if ((unsigned long )search != (unsigned long )workbegin) {
        {
#line 1173
        memcpy((void */* __restrict  */)(& rrtmp), (void const   */* __restrict  */)workbegin,
               (size_t )typei->rrsz);
#line 1174
        memcpy((void */* __restrict  */)workbegin, (void const   */* __restrict  */)search,
               (size_t )typei->rrsz);
#line 1175
        memcpy((void */* __restrict  */)search, (void const   */* __restrict  */)(& rrtmp),
               (size_t )typei->rrsz);
        }
      }
#line 1155
      workbegin += typei->rrsz;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1138
    workbegin = workend;
  }
  while_break: /* CIL Label */ ;
  }
#line 1184
  return;
}
}
#line 1190 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_byteblock___10(adns_query qu , void *datap ) 
{ 
  adns_rr_byteblock *rrp ;
  void *bytes___3 ;

  {
  {
#line 1191
  rrp = (adns_rr_byteblock *)datap;
#line 1192
  bytes___3 = (void *)rrp->data;
#line 1193
  adns__makefinal_block(qu, & bytes___3, (size_t )rrp->len);
#line 1194
  rrp->data = (unsigned char *)bytes___3;
  }
#line 1195
  return;
}
}
#line 1201 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_opaque___10(parseinfo const   *pai , int cbyte___3 , int max ,
                                  void *datap ) 
{ 
  adns_rr_byteblock *rrp ;
  void *tmp ;

  {
  {
#line 1203
  rrp = (adns_rr_byteblock *)datap;
#line 1205
  rrp->len = max - cbyte___3;
#line 1206
  tmp = adns__alloc_interim((adns_query )pai->qu, (size_t )rrp->len);
#line 1206
  rrp->data = (unsigned char *)tmp;
  }
#line 1207
  if (! rrp->data) {
#line 1207
    return ((adns_status )1);
  }
  {
#line 1208
  memcpy((void */* __restrict  */)rrp->data, (void const   */* __restrict  */)(pai->dgram + cbyte___3),
         (size_t )rrp->len);
  }
#line 1209
  return ((adns_status )0);
}
}
#line 1212 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_opaque___10(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_byteblock const   *rrp ;
  char buf___17[10] ;
  int l ;
  unsigned char *p ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1213
  rrp = (adns_rr_byteblock const   *)datap;
#line 1218
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"\\# %d",
          rrp->len);
  }
  {
#line 1219
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1219
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 1219
    if (! tmp) {
#line 1219
      return ((adns_status )1);
    }
#line 1219
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1221
  l = (int )rrp->len;
#line 1221
  p = (unsigned char *)rrp->data;
  {
#line 1221
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1221
    if (! (l >= 4)) {
#line 1221
      goto while_break___0;
    }
    {
#line 1224
    sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %02x%02x%02x%02x",
            (int )*(p + 0), (int )*(p + 1), (int )*(p + 2), (int )*(p + 3));
    }
    {
#line 1225
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1225
      tmp___0 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
      }
#line 1225
      if (! tmp___0) {
#line 1225
        return ((adns_status )1);
      }
#line 1225
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1221
    l -= 4;
#line 1221
    p += 4;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1227
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1227
    if (! (l > 0)) {
#line 1227
      goto while_break___2;
    }
    {
#line 1230
    sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %02x",
            (int )*p);
    }
    {
#line 1231
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 1231
      tmp___1 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
      }
#line 1231
      if (! tmp___1) {
#line 1231
        return ((adns_status )1);
      }
#line 1231
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1227
    l --;
#line 1227
    p ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1233
  return ((adns_status )0);
}
}
#line 1240 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_flat___10(adns_query qu , void *data___0 ) 
{ 


  {
#line 1240
  return;
}
}
#line 1261 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static typeinfo const   typeinfos___10[17]  = 
#line 1261
  {      {(adns_rrtype )1, "A", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.inaddr)),
      & mf_flat___10, & cs_inaddr___10, & pa_inaddr___10, & di_inaddr___10, (adns_status (*)(adns_state ads ,
                                                                                             char const   **p_io ,
                                                                                             char const   *pe ,
                                                                                             int labelnum ,
                                                                                             char *label_r ,
                                                                                             int *ll_io ,
                                                                                             adns_queryflags flags ,
                                                                                             struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )2,
      "NS", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___10, & cs_domain___10,
      & pa_host_raw___10, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )5,
      "CNAME", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___10,
      & cs_domain___10, & pa_dom_raw___10, (int (*)(adns_state ads , void const   *datap_a ,
                                                    void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                                char const   **p_io ,
                                                                                                char const   *pe ,
                                                                                                int labelnum ,
                                                                                                char *label_r ,
                                                                                                int *ll_io ,
                                                                                                adns_queryflags flags ,
                                                                                                struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )6,
      "SOA", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.soa)), & mf_soa___10, & cs_soa___10,
      & pa_soa___10, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )12,
      "PTR", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___10, & cs_domain___10,
      & pa_host_raw___10, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )13,
      "HINFO", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.intstrpair)),
      & mf_intstrpair___10, & cs_hinfo___10, & pa_hinfo___10, (int (*)(adns_state ads ,
                                                                       void const   *datap_a ,
                                                                       void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )15,
      "MX", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.intstr)), & mf_intstr___10,
      & cs_inthost___10, & pa_mx_raw___10, & di_mx_raw___10, (adns_status (*)(adns_state ads ,
                                                                              char const   **p_io ,
                                                                              char const   *pe ,
                                                                              int labelnum ,
                                                                              char *label_r ,
                                                                              int *ll_io ,
                                                                              adns_queryflags flags ,
                                                                              struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )16,
      "TXT", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.manyistr)),
      & mf_manyistr___10, & cs_txt___10, & pa_txt___10, (int (*)(adns_state ads ,
                                                                 void const   *datap_a ,
                                                                 void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )17,
      "RP", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.strpair)), & mf_strpair___10,
      & cs_rp___10, & pa_rp___10, (int (*)(adns_state ads , void const   *datap_a ,
                                           void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                       char const   **p_io ,
                                                                                       char const   *pe ,
                                                                                       int labelnum ,
                                                                                       char *label_r ,
                                                                                       int *ll_io ,
                                                                                       adns_queryflags flags ,
                                                                                       struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )33,
      "SRV", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.srvraw)), & mf_srvraw___10,
      & cs_srvraw___10, & pa_srvraw___10, & di_srv___10, & qdpl_srv___10, & postsort_srv___10}, 
        {(adns_rrtype )65537,
      "A", "addr", (int )sizeof(*(((adns_answer *)0)->rrs.addr)), & mf_flat___10,
      & cs_addr___10, & pa_addr___10, & di_addr___10, (adns_status (*)(adns_state ads ,
                                                                       char const   **p_io ,
                                                                       char const   *pe ,
                                                                       int labelnum ,
                                                                       char *label_r ,
                                                                       int *ll_io ,
                                                                       adns_queryflags flags ,
                                                                       struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65538,
      "NS", "+addr", (int )sizeof(*(((adns_answer *)0)->rrs.hostaddr)), & mf_hostaddr___10,
      & cs_hostaddr___10, & pa_hostaddr___10, & di_hostaddr___10, (adns_status (*)(adns_state ads ,
                                                                                   char const   **p_io ,
                                                                                   char const   *pe ,
                                                                                   int labelnum ,
                                                                                   char *label_r ,
                                                                                   int *ll_io ,
                                                                                   adns_queryflags flags ,
                                                                                   struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65548,
      "PTR", "checked", (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___10,
      & cs_domain___10, & pa_ptr___10, (int (*)(adns_state ads , void const   *datap_a ,
                                                void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                            char const   **p_io ,
                                                                                            char const   *pe ,
                                                                                            int labelnum ,
                                                                                            char *label_r ,
                                                                                            int *ll_io ,
                                                                                            adns_queryflags flags ,
                                                                                            struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65551,
      "MX", "+addr", (int )sizeof(*(((adns_answer *)0)->rrs.inthostaddr)), & mf_inthostaddr___10,
      & cs_inthostaddr___10, & pa_mx___10, & di_mx___10, (adns_status (*)(adns_state ads ,
                                                                          char const   **p_io ,
                                                                          char const   *pe ,
                                                                          int labelnum ,
                                                                          char *label_r ,
                                                                          int *ll_io ,
                                                                          adns_queryflags flags ,
                                                                          struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65569,
      "SRV", "+addr", (int )sizeof(*(((adns_answer *)0)->rrs.srvha)), & mf_srvha___10,
      & cs_srvha___10, & pa_srvha___10, & di_srv___10, & qdpl_srv___10, & postsort_srv___10}, 
        {(adns_rrtype )131078,
      "SOA", "822", (int )sizeof(*(((adns_answer *)0)->rrs.soa)), & mf_soa___10, & cs_soa___10,
      & pa_soa___10, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )131089,
      "RP", "822", (int )sizeof(*(((adns_answer *)0)->rrs.strpair)), & mf_strpair___10,
      & cs_rp___10, & pa_rp___10, (int (*)(adns_state ads , void const   *datap_a ,
                                           void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                       char const   **p_io ,
                                                                                       char const   *pe ,
                                                                                       int labelnum ,
                                                                                       char *label_r ,
                                                                                       int *ll_io ,
                                                                                       adns_queryflags flags ,
                                                                                       struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}};
#line 1288 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static struct typeinfo  const  typeinfo_unknown___10  = 
#line 1288
     {(adns_rrtype )262144, (char const   *)0, "unknown", (int )sizeof(*(((adns_answer *)0)->rrs.byteblock)),
    & mf_byteblock___10, & cs_opaque___10, & pa_opaque___10, (int (*)(adns_state ads ,
                                                                      void const   *datap_a ,
                                                                      void const   *datap_b ))0,
    (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                     char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
    (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0};
#line 233 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/general.c"
static struct sinfo  const  sinfos___10[24]  = 
#line 233 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/general.c"
  {      {(adns_status )0, "ok", "OK"}, 
        {(adns_status )1, "nomemory", "Out of memory"}, 
        {(adns_status )2, "unknownrrtype", "Query not implemented in DNS library"}, 
        {(adns_status )3, "systemfail", "General resolver or system failure"}, 
        {(adns_status )30, "timeout", "DNS query timed out"}, 
        {(adns_status )31, "allservfail", "All nameservers failed"}, 
        {(adns_status )32, "norecurse", "Recursion denied by nameserver"}, 
        {(adns_status )33, "invalidresponse", "Nameserver sent bad response"}, 
        {(adns_status )34, "unknownformat", "Nameserver used unknown format"}, 
        {(adns_status )60, "rcodeservfail", "Nameserver reports failure"}, 
        {(adns_status )61, "rcodeformaterror", "Query not understood by nameserver"}, 
        {(adns_status )62,
      "rcodenotimplemented", "Query not implemented by nameserver"}, 
        {(adns_status )63, "rcoderefused", "Query refused by nameserver"}, 
        {(adns_status )64, "rcodeunknown", "Nameserver sent unknown response code"}, 
        {(adns_status )100, "inconsistent", "Inconsistent resource records in DNS"}, 
        {(adns_status )101, "prohibitedcname", "DNS alias found where canonical name wanted"}, 
        {(adns_status )102,
      "answerdomaininvalid", "Found syntactically invalid domain name"}, 
        {(adns_status )103, "answerdomaintoolong", "Found overly-long domain name"}, 
        {(adns_status )104, "invaliddata", "Found invalid DNS data"}, 
        {(adns_status )200, "querydomainwrong", "Domain invalid for particular DNS query type"}, 
        {(adns_status )201,
      "querydomaininvalid", "Domain name is syntactically invalid"}, 
        {(adns_status )202, "querydomaintoolong", "Domain name or component is too long"}, 
        {(adns_status )300,
      "nxdomain", "No such domain"}, 
        {(adns_status )301, "nodata", "No such data"}};
#line 270 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/general.c"
static int si_compar___10(void const   *key , void const   *elem ) 
{ 
  adns_status const   *st ;
  struct sinfo  const  *si ;
  int tmp ;
  int tmp___0 ;

  {
#line 271
  st = (adns_status const   *)key;
#line 272
  si = (struct sinfo  const  *)elem;
#line 274
  if ((unsigned int const   )*st < (unsigned int const   )si->st) {
#line 274
    tmp___0 = -1;
  } else {
#line 274
    if ((unsigned int const   )*st > (unsigned int const   )si->st) {
#line 274
      tmp = 1;
    } else {
#line 274
      tmp = 0;
    }
#line 274
    tmp___0 = tmp;
  }
#line 274
  return (tmp___0);
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/general.c"
static struct sinfo  const  *findsinfo___10(adns_status st ) 
{ 
  void *tmp ;

  {
  {
#line 278
  tmp = bsearch((void const   *)(& st), (void const   *)(sinfos___10), sizeof(sinfos___10) / sizeof(sinfos___10[0]),
                sizeof(sinfos___10[0]), & si_compar___10);
  }
#line 278
  return ((struct sinfo  const  *)tmp);
}
}
#line 299 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/general.c"
static struct stinfo  const  stinfos___10[7]  = {      {(adns_status )0, "ok"}, 
        {(adns_status )29, "localfail"}, 
        {(adns_status )59, "remotefail"}, 
        {(adns_status )99, "tempfail"}, 
        {(adns_status )199, "misconfig"}, 
        {(adns_status )299, "misquery"}, 
        {(adns_status )499, "permfail"}};
#line 312 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/general.c"
static int sti_compar___10(void const   *key , void const   *elem ) 
{ 
  adns_status const   *st ;
  struct stinfo  const  *sti ;
  adns_status here ;
  adns_status min ;
  adns_status max ;
  int tmp ;
  int tmp___0 ;

  {
#line 313
  st = (adns_status const   *)key;
#line 314
  sti = (struct stinfo  const  *)elem;
#line 318
  here = (adns_status )*st;
#line 319
  if ((unsigned long )sti == (unsigned long )(stinfos___10)) {
#line 319
    min = (adns_status )0;
  } else {
#line 319
    min = (adns_status )((unsigned int const   )(sti + -1)->stmax + 1U);
  }
#line 320
  max = (adns_status )sti->stmax;
#line 322
  if ((unsigned int )here < (unsigned int )min) {
#line 322
    tmp___0 = -1;
  } else {
#line 322
    if ((unsigned int )here > (unsigned int )max) {
#line 322
      tmp = 1;
    } else {
#line 322
      tmp = 0;
    }
#line 322
    tmp___0 = tmp;
  }
#line 322
  return (tmp___0);
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pap_qstring___11(parseinfo const   *pai , int *cbyte_io , int max ,
                                    int *len_r , char **str_r ) 
{ 
  byte const   *dgram ;
  int l ;
  int cbyte___3 ;
  char *str ;
  int tmp ;
  void *tmp___0 ;

  {
#line 92
  dgram = (byte const   *)pai->dgram;
#line 96
  cbyte___3 = *cbyte_io;
#line 98
  if (cbyte___3 >= max) {
#line 98
    return ((adns_status )104);
  }
#line 99
  tmp = cbyte___3;
#line 99
  cbyte___3 ++;
#line 99
  l = (int )((int const   )*(dgram + tmp) & 255);
#line 100
  if (cbyte___3 + l > max) {
#line 100
    return ((adns_status )104);
  }
  {
#line 102
  tmp___0 = adns__alloc_interim((adns_query )pai->qu, (size_t )(l + 1));
#line 102
  str = (char *)tmp___0;
  }
#line 103
  if (! str) {
#line 103
    return ((adns_status )1);
  }
  {
#line 105
  *(str + l) = (char)0;
#line 106
  memcpy((void */* __restrict  */)str, (void const   */* __restrict  */)(dgram + cbyte___3),
         (size_t )l);
#line 108
  *len_r = l;
#line 109
  *str_r = str;
#line 110
  *cbyte_io = cbyte___3 + l;
  }
#line 112
  return ((adns_status )0);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status csp_qstring___11(vbuf *vb___0 , char const   *dp , int len ) 
{ 
  unsigned char ch ;
  char buf___17[10] ;
  int cn ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 120
    tmp = adns__vbuf_appendstr(vb___0, "\"");
    }
#line 120
    if (! tmp) {
#line 120
      return ((adns_status )1);
    }
#line 120
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  cn = 0;
  {
#line 121
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 121
    if (! (cn < len)) {
#line 121
      goto while_break___0;
    }
#line 122
    tmp___0 = dp;
#line 122
    dp ++;
#line 122
    ch = (unsigned char )*tmp___0;
#line 123
    if ((int )ch == 92) {
      {
#line 124
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 124
        tmp___1 = adns__vbuf_appendstr(vb___0, "\\\\");
        }
#line 124
        if (! tmp___1) {
#line 124
          return ((adns_status )1);
        }
#line 124
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else
#line 125
    if ((int )ch == 34) {
      {
#line 126
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 126
        tmp___2 = adns__vbuf_appendstr(vb___0, "\\\"");
        }
#line 126
        if (! tmp___2) {
#line 126
          return ((adns_status )1);
        }
#line 126
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else
#line 127
    if ((int )ch >= 32) {
#line 127
      if ((int )ch <= 126) {
        {
#line 128
        tmp___3 = adns__vbuf_append(vb___0, (byte const   *)(& ch), 1);
        }
#line 128
        if (! tmp___3) {
#line 128
          return ((adns_status )1);
        }
      } else {
#line 127
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 130
      sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"\\x%02x",
              (int )ch);
      }
      {
#line 131
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 131
        tmp___4 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
        }
#line 131
        if (! tmp___4) {
#line 131
          return ((adns_status )1);
        }
#line 131
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 121
    cn ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 134
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 134
    tmp___5 = adns__vbuf_appendstr(vb___0, "\"");
    }
#line 134
    if (! tmp___5) {
#line 134
      return ((adns_status )1);
    }
#line 134
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 136
  return ((adns_status )0);
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_str___11(adns_query qu , void *datap ) 
{ 
  char **rrp ;

  {
  {
#line 144
  rrp = (char **)datap;
#line 146
  adns__makefinal_str(qu, rrp);
  }
#line 147
  return;
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_intstr___11(adns_query qu , void *datap ) 
{ 
  adns_rr_intstr *rrp ;

  {
  {
#line 154
  rrp = (adns_rr_intstr *)datap;
#line 156
  adns__makefinal_str(qu, & rrp->str);
  }
#line 157
  return;
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_manyistr___11(adns_query qu , void *datap ) 
{ 
  adns_rr_intstr **rrp ;
  adns_rr_intstr *te ;
  adns_rr_intstr *table ;
  void *tablev ;
  int tc ;

  {
#line 164
  rrp = (adns_rr_intstr **)datap;
#line 169
  tc = 0;
#line 169
  te = *rrp;
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    if (! (te->i >= 0)) {
#line 169
      goto while_break;
    }
#line 169
    te ++;
#line 169
    tc ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 170
  tablev = (void *)*rrp;
#line 171
  adns__makefinal_block(qu, & tablev, sizeof(*te) * (unsigned long )(tc + 1));
#line 172
  table = (adns_rr_intstr *)tablev;
#line 172
  *rrp = table;
#line 173
  te = *rrp;
  }
  {
#line 173
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 173
    if (! (te->i >= 0)) {
#line 173
      goto while_break___0;
    }
    {
#line 174
    adns__makefinal_str(qu, & te->str);
#line 173
    te ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 175
  return;
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_txt___11(parseinfo const   *pai , int cbyte___3 , int max ,
                               void *datap ) 
{ 
  adns_rr_intstr **rrp ;
  adns_rr_intstr *table ;
  adns_rr_intstr *te ;
  byte const   *dgram ;
  int ti ;
  int tc ;
  int l ;
  int startbyte ;
  adns_status st ;
  int tmp ;
  void *tmp___0 ;

  {
#line 183
  rrp = (adns_rr_intstr **)datap;
#line 184
  dgram = (byte const   *)pai->dgram;
#line 188
  startbyte = cbyte___3;
#line 189
  if (cbyte___3 >= max) {
#line 189
    return ((adns_status )104);
  }
#line 190
  tc = 0;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! (cbyte___3 < max)) {
#line 191
      goto while_break;
    }
#line 192
    tmp = cbyte___3;
#line 192
    cbyte___3 ++;
#line 192
    l = (int )((int const   )*(dgram + tmp) & 255);
#line 193
    cbyte___3 += l;
#line 194
    tc ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  if (cbyte___3 != max) {
#line 196
    return ((adns_status )104);
  } else
#line 196
  if (! tc) {
#line 196
    return ((adns_status )104);
  }
  {
#line 198
  tmp___0 = adns__alloc_interim((adns_query )pai->qu, sizeof(*table) * (unsigned long )(tc + 1));
#line 198
  table = (adns_rr_intstr *)tmp___0;
  }
#line 199
  if (! table) {
#line 199
    return ((adns_status )1);
  }
#line 201
  cbyte___3 = startbyte;
#line 201
  ti = 0;
#line 201
  te = table;
  {
#line 201
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 201
    if (! (ti < tc)) {
#line 201
      goto while_break___0;
    }
    {
#line 202
    st = pap_qstring___11(pai, & cbyte___3, max, & te->i, & te->str);
    }
#line 203
    if (st) {
#line 203
      return (st);
    }
#line 201
    ti ++;
#line 201
    te ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 205
  if (! (cbyte___3 == max)) {
    {
#line 205
    __assert_fail("cbyte == max", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                  205U, "pa_txt");
    }
  }
#line 207
  te->i = -1;
#line 208
  te->str = (char *)0;
#line 210
  *rrp = table;
#line 211
  return ((adns_status )0);
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_txt___11(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_intstr const   * const  *rrp ;
  adns_rr_intstr const   *current ;
  adns_status st ;
  int spc ;
  int tmp ;

  {
#line 215
  rrp = (adns_rr_intstr const   * const  *)datap;
#line 220
  current = (adns_rr_intstr const   *)*rrp;
#line 220
  spc = 0;
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    if (! (current->i >= 0)) {
#line 220
      goto while_break;
    }
#line 221
    if (spc) {
      {
#line 221
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 221
        tmp = adns__vbuf_appendstr(vb___0, " ");
        }
#line 221
        if (! tmp) {
#line 221
          return ((adns_status )1);
        }
#line 221
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 222
    st = csp_qstring___11(vb___0, (char const   *)current->str, (int )current->i);
    }
#line 222
    if (st) {
#line 222
      return (st);
    }
#line 220
    current ++;
#line 220
    spc = 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  return ((adns_status )0);
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_hinfo___11(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_intstrpair const   *rrp ;
  adns_status st ;
  int tmp ;

  {
  {
#line 232
  rrp = (adns_rr_intstrpair const   *)datap;
#line 235
  st = csp_qstring___11(vb___0, (char const   *)rrp->array[0].str, (int )rrp->array[0].i);
  }
#line 235
  if (st) {
#line 235
    return (st);
  }
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 236
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 236
    if (! tmp) {
#line 236
      return ((adns_status )1);
    }
#line 236
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 237
  st = csp_qstring___11(vb___0, (char const   *)rrp->array[1].str, (int )rrp->array[1].i);
  }
#line 237
  if (st) {
#line 237
    return (st);
  }
#line 238
  return ((adns_status )0);
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_inaddr___11(parseinfo const   *pai , int cbyte___3 , int max ,
                                  void *datap ) 
{ 
  struct in_addr *storeto ;

  {
#line 247
  storeto = (struct in_addr *)datap;
#line 249
  if (max - cbyte___3 != 4) {
#line 249
    return ((adns_status )104);
  }
  {
#line 250
  memcpy((void */* __restrict  */)storeto, (void const   */* __restrict  */)(pai->dgram + cbyte___3),
         (size_t )4);
  }
#line 251
  return ((adns_status )0);
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int search_sortlist___11(adns_state ads___7 , struct in_addr ad ) 
{ 
  struct sortlist  const  *slp ;
  int i ;

  {
#line 258
  i = 0;
#line 258
  slp = (struct sortlist  const  *)(ads___7->sortlist);
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 258
    if (i < ads___7->nsortlist) {
#line 258
      if (! (! ((ad.s_addr & (unsigned int )slp->mask.s_addr) == (unsigned int )slp->base.s_addr))) {
#line 258
        goto while_break;
      }
    } else {
#line 258
      goto while_break;
    }
#line 258
    i ++;
#line 258
    slp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  return (i);
}
}
#line 265 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int dip_inaddr___11(adns_state ads___7 , struct in_addr a , struct in_addr b ) 
{ 
  int ai ;
  int bi ;

  {
#line 268
  if (! ads___7->nsortlist) {
#line 268
    return (0);
  }
  {
#line 270
  ai = search_sortlist___11(ads___7, a);
#line 271
  bi = search_sortlist___11(ads___7, b);
  }
#line 272
  return (bi < ai);
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int di_inaddr___11(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  struct in_addr  const  *ap ;
  struct in_addr  const  *bp ;
  int tmp ;

  {
  {
#line 277
  ap = (struct in_addr  const  *)datap_a;
#line 277
  bp = (struct in_addr  const  *)datap_b;
#line 279
  tmp = dip_inaddr___11(ads___7, (struct in_addr )*ap, (struct in_addr )*bp);
  }
#line 279
  return (tmp);
}
}
#line 282 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_inaddr___11(vbuf *vb___0 , void const   *datap ) 
{ 
  struct in_addr  const  *rrp ;
  struct in_addr rr ;
  char const   *ia ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 283
  rrp = (struct in_addr  const  *)datap;
#line 283
  rr = *rrp;
#line 286
  tmp = inet_ntoa(rr);
#line 286
  ia = (char const   *)tmp;
  }
#line 286
  if (! ia) {
    {
#line 286
    __assert_fail("ia", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                  286U, "cs_inaddr");
    }
  }
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 287
    tmp___0 = adns__vbuf_appendstr(vb___0, ia);
    }
#line 287
    if (! tmp___0) {
#line 287
      return ((adns_status )1);
    }
#line 287
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  return ((adns_status )0);
}
}
#line 295 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_addr___11(parseinfo const   *pai , int cbyte___3 , int max ,
                                void *datap ) 
{ 
  adns_rr_addr *storeto ;
  byte const   *dgram ;

  {
#line 297
  storeto = (adns_rr_addr *)datap;
#line 298
  dgram = (byte const   *)pai->dgram;
#line 300
  if (max - cbyte___3 != 4) {
#line 300
    return ((adns_status )104);
  }
  {
#line 301
  storeto->len = (int )sizeof(storeto->addr.inet);
#line 302
  memset((void *)(& storeto->addr), 0, sizeof(storeto->addr.inet));
#line 303
  storeto->addr.inet.sin_family = (sa_family_t )2;
#line 304
  memcpy((void */* __restrict  */)(& storeto->addr.inet.sin_addr), (void const   */* __restrict  */)(dgram + cbyte___3),
         (size_t )4);
  }
#line 305
  return ((adns_status )0);
}
}
#line 308 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int di_addr___11(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_addr const   *ap ;
  adns_rr_addr const   *bp ;
  int tmp ;

  {
#line 309
  ap = (adns_rr_addr const   *)datap_a;
#line 309
  bp = (adns_rr_addr const   *)datap_b;
#line 311
  if (! ((int const   )ap->addr.sa.sa_family == 2)) {
    {
#line 311
    __assert_fail("ap->addr.sa.sa_family == 2", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                  311U, "di_addr");
    }
  }
  {
#line 312
  tmp = dip_inaddr___11(ads___7, (struct in_addr )ap->addr.inet.sin_addr, (struct in_addr )bp->addr.inet.sin_addr);
  }
#line 312
  return (tmp);
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int div_addr___11(void *context , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_state ads___7 ;
  int tmp ;

  {
  {
#line 316
  ads___7 = (adns_state )context;
#line 318
  tmp = di_addr___11(ads___7, datap_a, datap_b);
  }
#line 318
  return (tmp);
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status csp_addr___11(vbuf *vb___0 , adns_rr_addr const   *rrp ) 
{ 
  char const   *ia ;
  char buf___17[30] ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 326
  if ((int const   )rrp->addr.inet.sin_family == 2) {
#line 326
    goto case_2;
  }
#line 331
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 327
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 327
    tmp = adns__vbuf_appendstr(vb___0, "INET ");
    }
#line 327
    if (! tmp) {
#line 327
      return ((adns_status )1);
    }
#line 327
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 328
  tmp___0 = inet_ntoa((struct in_addr )rrp->addr.inet.sin_addr);
#line 328
  ia = (char const   *)tmp___0;
  }
#line 328
  if (! ia) {
    {
#line 328
    __assert_fail("ia", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                  328U, "csp_addr");
    }
  }
  {
#line 329
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 329
    tmp___1 = adns__vbuf_appendstr(vb___0, ia);
    }
#line 329
    if (! tmp___1) {
#line 329
      return ((adns_status )1);
    }
#line 329
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 330
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 332
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"AF=%u",
          (int const   )rrp->addr.sa.sa_family);
  }
  {
#line 333
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 333
    tmp___2 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 333
    if (! tmp___2) {
#line 333
      return ((adns_status )1);
    }
#line 333
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 334
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 336
  return ((adns_status )0);
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_addr___11(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_addr const   *rrp ;
  adns_status tmp ;

  {
  {
#line 340
  rrp = (adns_rr_addr const   *)datap;
#line 342
  tmp = csp_addr___11(vb___0, rrp);
  }
#line 342
  return (tmp);
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pap_domain___11(parseinfo const   *pai , int *cbyte_io , int max ,
                                   char **domain_r , parsedomain_flags flags ) 
{ 
  adns_status st ;
  char *dm ;
  void *tmp ;

  {
  {
#line 355
  st = adns__parse_domain((pai->qu)->ads, (int )pai->serv, (adns_query )pai->qu, & (pai->qu)->vb,
                          flags, (byte const   *)pai->dgram, (int )pai->dglen, cbyte_io,
                          max);
  }
#line 357
  if (st) {
#line 357
    return (st);
  }
#line 358
  if (! (pai->qu)->vb.used) {
#line 358
    return ((adns_status )104);
  }
  {
#line 360
  tmp = adns__alloc_interim((adns_query )pai->qu, (size_t )((pai->qu)->vb.used + 1));
#line 360
  dm = (char *)tmp;
  }
#line 361
  if (! dm) {
#line 361
    return ((adns_status )1);
  }
  {
#line 363
  *(dm + (pai->qu)->vb.used) = (char)0;
#line 364
  memcpy((void */* __restrict  */)dm, (void const   */* __restrict  */)(pai->qu)->vb.buf,
         (size_t )(pai->qu)->vb.used);
#line 366
  *domain_r = dm;
  }
#line 367
  return ((adns_status )0);
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status csp_domain___11(vbuf *vb___0 , char const   *domain ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 371
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 371
    tmp = adns__vbuf_appendstr(vb___0, domain);
    }
#line 371
    if (! tmp) {
#line 371
      return ((adns_status )1);
    }
#line 371
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 372
  if (! *domain) {
    {
#line 372
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 372
      tmp___0 = adns__vbuf_appendstr(vb___0, ".");
      }
#line 372
      if (! tmp___0) {
#line 372
        return ((adns_status )1);
      }
#line 372
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 373
  return ((adns_status )0);
}
}
#line 376 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_domain___11(vbuf *vb___0 , void const   *datap ) 
{ 
  char const   * const  *domainp ;
  adns_status tmp ;

  {
  {
#line 377
  domainp = (char const   * const  *)datap;
#line 378
  tmp = csp_domain___11(vb___0, (char const   *)*domainp);
  }
#line 378
  return (tmp);
}
}
#line 381 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_dom_raw___11(parseinfo const   *pai , int cbyte___3 , int max ,
                                   void *datap ) 
{ 
  char **rrp ;
  adns_status st ;

  {
  {
#line 383
  rrp = (char **)datap;
#line 386
  st = pap_domain___11(pai, & cbyte___3, max, rrp, (parsedomain_flags )1);
  }
#line 387
  if (st) {
#line 387
    return (st);
  }
#line 389
  if (cbyte___3 != max) {
#line 389
    return ((adns_status )104);
  }
#line 390
  return ((adns_status )0);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_host_raw___11(parseinfo const   *pai , int cbyte___3 , int max ,
                                    void *datap ) 
{ 
  char **rrp ;
  adns_status st ;
  int tmp ;

  {
#line 399
  rrp = (char **)datap;
#line 402
  if ((pai->qu)->flags & 64) {
#line 402
    tmp = 1;
  } else {
#line 402
    tmp = 0;
  }
  {
#line 402
  st = pap_domain___11(pai, & cbyte___3, max, rrp, (parsedomain_flags )tmp);
  }
#line 404
  if (st) {
#line 404
    return (st);
  }
#line 406
  if (cbyte___3 != max) {
#line 406
    return ((adns_status )104);
  }
#line 407
  return ((adns_status )0);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pap_findaddrs___11(parseinfo const   *pai , adns_rr_hostaddr *ha ,
                                      int *cbyte_io , int count , int dmstart ) 
{ 
  int rri ;
  int naddrs ;
  int type ;
  int class ;
  int rdlen ;
  int rdstart ;
  int ownermatched ;
  unsigned long ttl ;
  adns_status st ;
  int tmp ;
  void *tmp___0 ;

  {
#line 421
  rri = 0;
#line 421
  naddrs = -1;
  {
#line 421
  while (1) {
    while_continue: /* CIL Label */ ;
#line 421
    if (! (rri < count)) {
#line 421
      goto while_break;
    }
    {
#line 422
    st = adns__findrr_anychk((adns_query )pai->qu, (int )pai->serv, (byte const   *)pai->dgram,
                             (int )pai->dglen, cbyte_io, & type, & class, & ttl, & rdlen,
                             & rdstart, (byte const   *)pai->dgram, (int )pai->dglen,
                             dmstart, & ownermatched);
    }
#line 426
    if (st) {
#line 426
      return (st);
    }
#line 427
    if (! ownermatched) {
#line 427
      goto _L;
    } else
#line 427
    if (class != 1) {
#line 427
      goto _L;
    } else
#line 427
    if (type != 1) {
      _L: /* CIL Label */ 
#line 428
      if (naddrs > 0) {
#line 428
        goto while_break;
      } else {
#line 428
        goto __Cont;
      }
    }
#line 430
    if (naddrs == -1) {
#line 431
      naddrs = 0;
    }
    {
#line 433
    tmp = adns__vbuf_ensure(& (pai->qu)->vb, (int )((unsigned long )(naddrs + 1) * sizeof(adns_rr_addr )));
    }
#line 433
    if (! tmp) {
#line 434
      return ((adns_status )1);
    }
    {
#line 435
    adns__update_expires((adns_query )pai->qu, ttl, (struct timeval )pai->now);
#line 436
    st = pa_addr___11(pai, rdstart, rdstart + rdlen, (void *)((pai->qu)->vb.buf + (unsigned long )naddrs * sizeof(adns_rr_addr )));
    }
#line 438
    if (st) {
#line 438
      return (st);
    }
#line 439
    naddrs ++;
    __Cont: /* CIL Label */ 
#line 421
    rri ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 441
  if (naddrs >= 0) {
    {
#line 442
    tmp___0 = adns__alloc_interim((adns_query )pai->qu, (unsigned long )naddrs * sizeof(adns_rr_addr ));
#line 442
    ha->addrs = (adns_rr_addr *)tmp___0;
    }
#line 443
    if (! ha->addrs) {
#line 443
      return ((adns_status )1);
    }
    {
#line 444
    memcpy((void */* __restrict  */)ha->addrs, (void const   */* __restrict  */)(pai->qu)->vb.buf,
           (unsigned long )naddrs * sizeof(adns_rr_addr ));
#line 445
    ha->naddrs = naddrs;
#line 446
    ha->astatus = (adns_status )0;
#line 448
    adns__isort((void *)ha->addrs, naddrs, (int )sizeof(adns_rr_addr ), (void *)(pai->qu)->vb.buf,
                & div_addr___11, (void *)pai->ads);
    }
  }
#line 451
  return ((adns_status )0);
}
}
#line 454 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void icb_hostaddr___11(adns_query parent , adns_query child ) 
{ 
  adns_answer *cans ;
  adns_rr_hostaddr *rrp ;
  adns_state ads___7 ;
  adns_status st ;

  {
#line 455
  cans = child->answer;
#line 456
  rrp = child->ctx.info.hostaddr;
#line 457
  ads___7 = parent->ads;
#line 460
  st = cans->status;
#line 461
  rrp->astatus = st;
#line 462
  if ((unsigned int )st > 0U) {
#line 462
    if ((unsigned int )st <= 99U) {
#line 462
      rrp->naddrs = -1;
    } else {
#line 462
      rrp->naddrs = cans->nrrs;
    }
  } else {
#line 462
    rrp->naddrs = cans->nrrs;
  }
  {
#line 463
  rrp->addrs = cans->rrs.addr;
#line 464
  adns__transfer_interim(child, parent, (void *)rrp->addrs, (unsigned long )rrp->naddrs * sizeof(adns_rr_addr ));
  }
#line 467
  if (parent->children.head) {
    {
#line 468
    while (1) {
      while_continue: /* CIL Label */ ;
#line 468
      parent->next = (adns_query )0;
#line 468
      parent->back = ads___7->childw.tail;
#line 468
      if (ads___7->childw.tail) {
#line 468
        (ads___7->childw.tail)->next = parent;
      } else {
#line 468
        ads___7->childw.head = parent;
      }
#line 468
      ads___7->childw.tail = parent;
#line 468
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 470
    adns__query_done(parent);
    }
  }
#line 472
  return;
}
}
#line 474 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pap_hostaddr___11(parseinfo const   *pai , int *cbyte_io , int max ,
                                     adns_rr_hostaddr *rrp ) 
{ 
  adns_status st ;
  int dmstart ;
  int cbyte___3 ;
  qcontext ctx ;
  int id ;
  adns_query nqu ;
  adns_queryflags nflags ;
  int tmp ;
  typeinfo const   *tmp___0 ;

  {
#line 483
  cbyte___3 = *cbyte_io;
#line 483
  dmstart = cbyte___3;
#line 484
  if ((pai->qu)->flags & 64) {
#line 484
    tmp = 1;
  } else {
#line 484
    tmp = 0;
  }
  {
#line 484
  st = pap_domain___11(pai, & cbyte___3, max, & rrp->host, (parsedomain_flags )tmp);
  }
#line 486
  if (st) {
#line 486
    return (st);
  }
  {
#line 487
  *cbyte_io = cbyte___3;
#line 489
  rrp->astatus = (adns_status )0;
#line 490
  rrp->naddrs = -1;
#line 491
  rrp->addrs = (adns_rr_addr *)0;
#line 493
  cbyte___3 = (int )pai->nsstart;
#line 495
  st = pap_findaddrs___11(pai, rrp, & cbyte___3, (int )pai->nscount, dmstart);
  }
#line 496
  if (st) {
#line 496
    return (st);
  }
#line 497
  if (rrp->naddrs != -1) {
#line 497
    return ((adns_status )0);
  }
  {
#line 499
  st = pap_findaddrs___11(pai, rrp, & cbyte___3, (int )pai->arcount, dmstart);
  }
#line 500
  if (st) {
#line 500
    return (st);
  }
#line 501
  if (rrp->naddrs != -1) {
#line 501
    return ((adns_status )0);
  }
  {
#line 503
  st = adns__mkquery_frdgram((adns_state )pai->ads, & (pai->qu)->vb, & id, (byte const   *)pai->dgram,
                             (int )pai->dglen, dmstart, (adns_rrtype )65537, (adns_queryflags )16);
  }
#line 506
  if (st) {
#line 506
    return (st);
  }
#line 508
  ctx.ext = (void *)0;
#line 509
  ctx.callback = & icb_hostaddr___11;
#line 510
  ctx.info.hostaddr = rrp;
#line 512
  nflags = (adns_queryflags )16;
#line 513
  if (! ((pai->qu)->flags & 256)) {
#line 513
    nflags = (adns_queryflags )((unsigned int )nflags | 512U);
  }
  {
#line 515
  tmp___0 = adns__findtype((adns_rrtype )65537);
#line 515
  st = adns__internal_submit((adns_state )pai->ads, & nqu, tmp___0, & (pai->qu)->vb,
                             id, nflags, (struct timeval )pai->now, (qcontext const   *)(& ctx));
  }
#line 517
  if (st) {
#line 517
    return (st);
  }
#line 519
  nqu->parent = (adns_query )pai->qu;
  {
#line 520
  while (1) {
    while_continue: /* CIL Label */ ;
#line 520
    nqu->siblings.next = (adns_query )0;
#line 520
    nqu->siblings.back = (pai->qu)->children.tail;
#line 520
    if ((pai->qu)->children.tail) {
#line 520
      ((pai->qu)->children.tail)->siblings.next = nqu;
    } else {
#line 520
      (pai->qu)->children.head = nqu;
    }
#line 520
    (pai->qu)->children.tail = nqu;
#line 520
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 522
  return ((adns_status )0);
}
}
#line 525 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_hostaddr___11(parseinfo const   *pai , int cbyte___3 , int max ,
                                    void *datap ) 
{ 
  adns_rr_hostaddr *rrp ;
  adns_status st ;

  {
  {
#line 527
  rrp = (adns_rr_hostaddr *)datap;
#line 530
  st = pap_hostaddr___11(pai, & cbyte___3, max, rrp);
  }
#line 531
  if (st) {
#line 531
    return (st);
  }
#line 532
  if (cbyte___3 != max) {
#line 532
    return ((adns_status )104);
  }
#line 534
  return ((adns_status )0);
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int dip_hostaddr___11(adns_state ads___7 , adns_rr_hostaddr const   *ap , adns_rr_hostaddr const   *bp ) 
{ 
  int tmp ;

  {
#line 539
  if ((unsigned int const   )ap->astatus != (unsigned int const   )bp->astatus) {
#line 539
    return ((int )ap->astatus);
  }
#line 540
  if (ap->astatus) {
#line 540
    return (0);
  }
#line 542
  if (! ((int )(ap->addrs + 0)->addr.sa.sa_family == 2)) {
    {
#line 542
    __assert_fail("ap->addrs[0].addr.sa.sa_family == 2", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                  542U, "dip_hostaddr");
    }
  }
#line 543
  if (! ((int )(bp->addrs + 0)->addr.sa.sa_family == 2)) {
    {
#line 543
    __assert_fail("bp->addrs[0].addr.sa.sa_family == 2", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                  543U, "dip_hostaddr");
    }
  }
  {
#line 544
  tmp = dip_inaddr___11(ads___7, (ap->addrs + 0)->addr.inet.sin_addr, (bp->addrs + 0)->addr.inet.sin_addr);
  }
#line 544
  return (tmp);
}
}
#line 549 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int di_hostaddr___11(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_hostaddr const   *ap ;
  adns_rr_hostaddr const   *bp ;
  int tmp ;

  {
  {
#line 551
  ap = (adns_rr_hostaddr const   *)datap_a;
#line 551
  bp = (adns_rr_hostaddr const   *)datap_b;
#line 553
  tmp = dip_hostaddr___11(ads___7, ap, bp);
  }
#line 553
  return (tmp);
}
}
#line 556 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mfp_hostaddr___11(adns_query qu , adns_rr_hostaddr *rrp ) 
{ 
  void *tablev ;

  {
  {
#line 559
  adns__makefinal_str(qu, & rrp->host);
#line 560
  tablev = (void *)rrp->addrs;
#line 561
  adns__makefinal_block(qu, & tablev, (unsigned long )rrp->naddrs * sizeof(*(rrp->addrs)));
#line 562
  rrp->addrs = (adns_rr_addr *)tablev;
  }
#line 563
  return;
}
}
#line 565 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_hostaddr___11(adns_query qu , void *datap ) 
{ 
  adns_rr_hostaddr *rrp ;

  {
  {
#line 566
  rrp = (adns_rr_hostaddr *)datap;
#line 568
  mfp_hostaddr___11(qu, rrp);
  }
#line 569
  return;
}
}
#line 571 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status csp_hostaddr___11(vbuf *vb___0 , adns_rr_hostaddr const   *rrp ) 
{ 
  char const   *errstr ;
  adns_status st ;
  char buf___17[20] ;
  int i ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 577
  st = csp_domain___11(vb___0, (char const   *)rrp->host);
  }
#line 577
  if (st) {
#line 577
    return (st);
  }
  {
#line 579
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 579
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 579
    if (! tmp) {
#line 579
      return ((adns_status )1);
    }
#line 579
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 580
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 580
    tmp___0 = adns_errtypeabbrev((adns_status )rrp->astatus);
#line 580
    tmp___1 = adns__vbuf_appendstr(vb___0, tmp___0);
    }
#line 580
    if (! tmp___1) {
#line 580
      return ((adns_status )1);
    }
#line 580
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 582
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %d ",
          (unsigned int const   )rrp->astatus);
  }
  {
#line 583
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 583
    tmp___2 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 583
    if (! tmp___2) {
#line 583
      return ((adns_status )1);
    }
#line 583
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 585
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 585
    tmp___3 = adns_errabbrev((adns_status )rrp->astatus);
#line 585
    tmp___4 = adns__vbuf_appendstr(vb___0, tmp___3);
    }
#line 585
    if (! tmp___4) {
#line 585
      return ((adns_status )1);
    }
#line 585
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 586
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 586
    tmp___5 = adns__vbuf_appendstr(vb___0, " ");
    }
#line 586
    if (! tmp___5) {
#line 586
      return ((adns_status )1);
    }
#line 586
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 588
  errstr = adns_strerror((adns_status )rrp->astatus);
#line 589
  tmp___6 = strlen(errstr);
#line 589
  st = csp_qstring___11(vb___0, errstr, (int )tmp___6);
  }
#line 589
  if (st) {
#line 589
    return (st);
  }
#line 591
  if (rrp->naddrs >= 0) {
    {
#line 592
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 592
      tmp___7 = adns__vbuf_appendstr(vb___0, " (");
      }
#line 592
      if (! tmp___7) {
#line 592
        return ((adns_status )1);
      }
#line 592
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 593
    i = 0;
    {
#line 593
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 593
      if (! (i < (int )rrp->naddrs)) {
#line 593
        goto while_break___5;
      }
      {
#line 594
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 594
        tmp___8 = adns__vbuf_appendstr(vb___0, " ");
        }
#line 594
        if (! tmp___8) {
#line 594
          return ((adns_status )1);
        }
#line 594
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 595
      st = csp_addr___11(vb___0, (adns_rr_addr const   *)(rrp->addrs + i));
#line 593
      i ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 597
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 597
      tmp___9 = adns__vbuf_appendstr(vb___0, " )");
      }
#line 597
      if (! tmp___9) {
#line 597
        return ((adns_status )1);
      }
#line 597
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
  } else {
    {
#line 599
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 599
      tmp___10 = adns__vbuf_appendstr(vb___0, " ?");
      }
#line 599
      if (! tmp___10) {
#line 599
        return ((adns_status )1);
      }
#line 599
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
#line 601
  return ((adns_status )0);
}
}
#line 604 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_hostaddr___11(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_hostaddr const   *rrp ;
  adns_status tmp ;

  {
  {
#line 605
  rrp = (adns_rr_hostaddr const   *)datap;
#line 607
  tmp = csp_hostaddr___11(vb___0, rrp);
  }
#line 607
  return (tmp);
}
}
#line 614 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_mx_raw___11(parseinfo const   *pai , int cbyte___3 , int max ,
                                  void *datap ) 
{ 
  byte const   *dgram ;
  adns_rr_intstr *rrp ;
  adns_status st ;
  int pref ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 616
  dgram = (byte const   *)pai->dgram;
#line 617
  rrp = (adns_rr_intstr *)datap;
#line 621
  if (cbyte___3 + 2 > max) {
#line 621
    return ((adns_status )104);
  }
#line 622
  pref = 0;
#line 622
  tmp = cbyte___3;
#line 622
  cbyte___3 ++;
#line 622
  pref |= (int )(((int const   )*(dgram + tmp) & 255) << 8);
#line 622
  tmp___0 = cbyte___3;
#line 622
  cbyte___3 ++;
#line 622
  pref |= (int )((int const   )*(dgram + tmp___0) & 255);
#line 623
  rrp->i = pref;
#line 624
  if ((pai->qu)->flags & 64) {
#line 624
    tmp___1 = 1;
  } else {
#line 624
    tmp___1 = 0;
  }
  {
#line 624
  st = pap_domain___11(pai, & cbyte___3, max, & rrp->str, (parsedomain_flags )tmp___1);
  }
#line 626
  if (st) {
#line 626
    return (st);
  }
#line 628
  if (cbyte___3 != max) {
#line 628
    return ((adns_status )104);
  }
#line 629
  return ((adns_status )0);
}
}
#line 632 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int di_mx_raw___11(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_intstr const   *ap ;
  adns_rr_intstr const   *bp ;

  {
#line 633
  ap = (adns_rr_intstr const   *)datap_a;
#line 633
  bp = (adns_rr_intstr const   *)datap_b;
#line 635
  if (ap->i < bp->i) {
#line 635
    return (0);
  }
#line 636
  if (ap->i > bp->i) {
#line 636
    return (1);
  }
#line 637
  return (0);
}
}
#line 644 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_mx___11(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  byte const   *dgram ;
  adns_rr_inthostaddr *rrp ;
  adns_status st ;
  int pref ;
  int tmp ;
  int tmp___0 ;

  {
#line 646
  dgram = (byte const   *)pai->dgram;
#line 647
  rrp = (adns_rr_inthostaddr *)datap;
#line 651
  if (cbyte___3 + 2 > max) {
#line 651
    return ((adns_status )104);
  }
  {
#line 652
  pref = 0;
#line 652
  tmp = cbyte___3;
#line 652
  cbyte___3 ++;
#line 652
  pref |= (int )(((int const   )*(dgram + tmp) & 255) << 8);
#line 652
  tmp___0 = cbyte___3;
#line 652
  cbyte___3 ++;
#line 652
  pref |= (int )((int const   )*(dgram + tmp___0) & 255);
#line 653
  rrp->i = pref;
#line 654
  st = pap_hostaddr___11(pai, & cbyte___3, max, & rrp->ha);
  }
#line 655
  if (st) {
#line 655
    return (st);
  }
#line 657
  if (cbyte___3 != max) {
#line 657
    return ((adns_status )104);
  }
#line 658
  return ((adns_status )0);
}
}
#line 661 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int di_mx___11(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_inthostaddr const   *ap ;
  adns_rr_inthostaddr const   *bp ;
  int tmp ;

  {
#line 662
  ap = (adns_rr_inthostaddr const   *)datap_a;
#line 662
  bp = (adns_rr_inthostaddr const   *)datap_b;
#line 664
  if (ap->i < bp->i) {
#line 664
    return (0);
  }
#line 665
  if (ap->i > bp->i) {
#line 665
    return (1);
  }
  {
#line 666
  tmp = dip_hostaddr___11(ads___7, & ap->ha, & bp->ha);
  }
#line 666
  return (tmp);
}
}
#line 673 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_inthostaddr___11(adns_query qu , void *datap ) 
{ 
  adns_rr_inthostaddr *rrp ;

  {
  {
#line 674
  rrp = (adns_rr_inthostaddr *)datap;
#line 676
  mfp_hostaddr___11(qu, & rrp->ha);
  }
#line 677
  return;
}
}
#line 679 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_inthostaddr___11(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_inthostaddr const   *rrp ;
  char buf___17[10] ;
  int tmp ;
  adns_status tmp___0 ;

  {
  {
#line 680
  rrp = (adns_rr_inthostaddr const   *)datap;
#line 683
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"%u ",
          rrp->i);
  }
  {
#line 684
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 684
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 684
    if (! tmp) {
#line 684
      return ((adns_status )1);
    }
#line 684
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 686
  tmp___0 = csp_hostaddr___11(vb___0, & rrp->ha);
  }
#line 686
  return (tmp___0);
}
}
#line 693 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_inthost___11(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_intstr const   *rrp ;
  char buf___17[10] ;
  int tmp ;
  adns_status tmp___0 ;

  {
  {
#line 694
  rrp = (adns_rr_intstr const   *)datap;
#line 697
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"%u ",
          rrp->i);
  }
  {
#line 698
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 698
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 698
    if (! tmp) {
#line 698
      return ((adns_status )1);
    }
#line 698
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 699
  tmp___0 = csp_domain___11(vb___0, (char const   *)rrp->str);
  }
#line 699
  return (tmp___0);
}
}
#line 706 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void icb_ptr___11(adns_query parent , adns_query child ) 
{ 
  adns_answer *cans ;
  adns_rr_addr const   *queried ;
  adns_rr_addr const   *found ;
  adns_state ads___7 ;
  int i ;
  int tmp ;

  {
#line 707
  cans = child->answer;
#line 709
  ads___7 = parent->ads;
#line 712
  if ((unsigned int )cans->status == 300U) {
    {
#line 713
    adns__query_fail(parent, (adns_status )100);
    }
#line 714
    return;
  } else
#line 712
  if ((unsigned int )cans->status == 301U) {
    {
#line 713
    adns__query_fail(parent, (adns_status )100);
    }
#line 714
    return;
  } else
#line 715
  if (cans->status) {
    {
#line 716
    adns__query_fail(parent, cans->status);
    }
#line 717
    return;
  }
#line 720
  queried = (adns_rr_addr const   *)(& parent->ctx.info.ptr_parent_addr);
#line 721
  i = 0;
#line 721
  found = (adns_rr_addr const   *)cans->rrs.addr;
  {
#line 721
  while (1) {
    while_continue: /* CIL Label */ ;
#line 721
    if (! (i < cans->nrrs)) {
#line 721
      goto while_break;
    }
#line 722
    if (queried->len == found->len) {
      {
#line 722
      tmp = memcmp((void const   *)(& queried->addr), (void const   *)(& found->addr),
                   (size_t )queried->len);
      }
#line 722
      if (! tmp) {
#line 724
        if (! parent->children.head) {
          {
#line 725
          adns__query_done(parent);
          }
#line 726
          return;
        } else {
          {
#line 728
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 728
            parent->next = (adns_query )0;
#line 728
            parent->back = ads___7->childw.tail;
#line 728
            if (ads___7->childw.tail) {
#line 728
              (ads___7->childw.tail)->next = parent;
            } else {
#line 728
              ads___7->childw.head = parent;
            }
#line 728
            ads___7->childw.tail = parent;
#line 728
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 729
          return;
        }
      }
    }
#line 721
    i ++;
#line 721
    found ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 734
  adns__query_fail(parent, (adns_status )100);
  }
#line 735
  return;
}
}
#line 739
static adns_status pa_ptr___11(parseinfo const   *pai , int dmstart , int max , void *datap ) ;
#line 739 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static char const   * const  expectdomain___11[2]  = {      (char const   */* const  */)"in-addr",      (char const   */* const  */)"arpa"};
#line 737 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_ptr___11(parseinfo const   *pai , int dmstart , int max , void *datap ) 
{ 
  char **rrp ;
  adns_status st ;
  adns_rr_addr *ap ;
  findlabel_state fls ;
  char *ep ;
  byte ipv[4] ;
  char labbuf[4] ;
  int cbyte___3 ;
  int i ;
  int lablen ;
  int labstart ;
  int l ;
  int id ;
  adns_query nqu ;
  qcontext ctx ;
  int tmp ;
  unsigned long tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  typeinfo const   *tmp___3 ;

  {
#line 741
  rrp = (char **)datap;
#line 752
  cbyte___3 = dmstart;
#line 753
  if ((pai->qu)->flags & 64) {
#line 753
    tmp = 1;
  } else {
#line 753
    tmp = 0;
  }
  {
#line 753
  st = pap_domain___11(pai, & cbyte___3, max, rrp, (parsedomain_flags )tmp);
  }
#line 755
  if (st) {
#line 755
    return (st);
  }
#line 756
  if (cbyte___3 != max) {
#line 756
    return ((adns_status )104);
  }
#line 758
  ap = & (pai->qu)->ctx.info.ptr_parent_addr;
#line 759
  if (! ap->len) {
    {
#line 760
    adns__findlabel_start(& fls, (adns_state )pai->ads, -1, (adns_query )pai->qu,
                          (byte const   *)(pai->qu)->query_dgram, (pai->qu)->query_dglen,
                          (pai->qu)->query_dglen, 12, (int *)0);
#line 763
    i = 0;
    }
    {
#line 763
    while (1) {
      while_continue: /* CIL Label */ ;
#line 763
      if (! (i < 4)) {
#line 763
        goto while_break;
      }
      {
#line 764
      st = adns__findlabel_next(& fls, & lablen, & labstart);
      }
#line 764
      if (! (! st)) {
        {
#line 764
        __assert_fail("!st", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                      764U, "pa_ptr");
        }
      }
#line 765
      if (lablen <= 0) {
#line 765
        return ((adns_status )200);
      } else
#line 765
      if (lablen > 3) {
#line 765
        return ((adns_status )200);
      }
      {
#line 766
      memcpy((void */* __restrict  */)(labbuf), (void const   */* __restrict  */)((pai->qu)->query_dgram + labstart),
             (size_t )lablen);
#line 767
      labbuf[lablen] = (char)0;
#line 768
      tmp___0 = strtoul((char const   */* __restrict  */)(labbuf), (char **/* __restrict  */)(& ep),
                        10);
#line 768
      ipv[3 - i] = (byte )tmp___0;
      }
#line 769
      if (*ep) {
#line 769
        return ((adns_status )200);
      }
#line 770
      if (lablen > 1) {
#line 770
        if ((int )*((pai->qu)->query_dgram + labstart) == 48) {
#line 771
          return ((adns_status )200);
        }
      }
#line 763
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 773
    i = 0;
    {
#line 773
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 773
      if (! ((unsigned long )i < sizeof(expectdomain___11) / sizeof(expectdomain___11[0]))) {
#line 773
        goto while_break___0;
      }
      {
#line 774
      st = adns__findlabel_next(& fls, & lablen, & labstart);
      }
#line 774
      if (! (! st)) {
        {
#line 774
        __assert_fail("!st", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                      774U, "pa_ptr");
        }
      }
      {
#line 775
      tmp___1 = strlen((char const   *)expectdomain___11[i]);
#line 775
      l = (int )tmp___1;
      }
#line 776
      if (lablen != l) {
#line 778
        return ((adns_status )200);
      } else {
        {
#line 776
        tmp___2 = memcmp((void const   *)((pai->qu)->query_dgram + labstart), (void const   *)expectdomain___11[i],
                         (size_t )l);
        }
#line 776
        if (tmp___2) {
#line 778
          return ((adns_status )200);
        }
      }
#line 773
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 780
    st = adns__findlabel_next(& fls, & lablen, (int *)0);
    }
#line 780
    if (! (! st)) {
      {
#line 780
      __assert_fail("!st", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                    780U, "pa_ptr");
      }
    }
#line 781
    if (lablen) {
#line 781
      return ((adns_status )200);
    }
    {
#line 783
    ap->len = (int )sizeof(struct sockaddr_in );
#line 784
    memset((void *)(& ap->addr), 0, sizeof(ap->addr.inet));
#line 785
    ap->addr.inet.sin_family = (sa_family_t )2;
#line 786
    ap->addr.inet.sin_addr.s_addr = htonl((uint32_t )(((((int )ipv[0] << 24) | ((int )ipv[1] << 16)) | ((int )ipv[2] << 8)) | (int )ipv[3]));
    }
  }
  {
#line 790
  st = adns__mkquery_frdgram((adns_state )pai->ads, & (pai->qu)->vb, & id, (byte const   *)pai->dgram,
                             (int )pai->dglen, dmstart, (adns_rrtype )65537, (adns_queryflags )16);
  }
#line 793
  if (st) {
#line 793
    return (st);
  }
  {
#line 795
  ctx.ext = (void *)0;
#line 796
  ctx.callback = & icb_ptr___11;
#line 797
  memset((void *)(& ctx.info), 0, sizeof(ctx.info));
#line 798
  tmp___3 = adns__findtype((adns_rrtype )65537);
#line 798
  st = adns__internal_submit((adns_state )pai->ads, & nqu, tmp___3, & (pai->qu)->vb,
                             id, (adns_queryflags )16, (struct timeval )pai->now,
                             (qcontext const   *)(& ctx));
  }
#line 801
  if (st) {
#line 801
    return (st);
  }
#line 803
  nqu->parent = (adns_query )pai->qu;
  {
#line 804
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 804
    nqu->siblings.next = (adns_query )0;
#line 804
    nqu->siblings.back = (pai->qu)->children.tail;
#line 804
    if ((pai->qu)->children.tail) {
#line 804
      ((pai->qu)->children.tail)->siblings.next = nqu;
    } else {
#line 804
      (pai->qu)->children.head = nqu;
    }
#line 804
    (pai->qu)->children.tail = nqu;
#line 804
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 805
  return ((adns_status )0);
}
}
#line 812 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_strpair___11(adns_query qu , void *datap ) 
{ 
  adns_rr_strpair *rrp ;

  {
  {
#line 813
  rrp = (adns_rr_strpair *)datap;
#line 815
  adns__makefinal_str(qu, & rrp->array[0]);
#line 816
  adns__makefinal_str(qu, & rrp->array[1]);
  }
#line 817
  return;
}
}
#line 823 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_intstrpair___11(adns_query qu , void *datap ) 
{ 
  adns_rr_intstrpair *rrp ;

  {
  {
#line 824
  rrp = (adns_rr_intstrpair *)datap;
#line 826
  adns__makefinal_str(qu, & rrp->array[0].str);
#line 827
  adns__makefinal_str(qu, & rrp->array[1].str);
  }
#line 828
  return;
}
}
#line 834 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_hinfo___11(parseinfo const   *pai , int cbyte___3 , int max ,
                                 void *datap ) 
{ 
  adns_rr_intstrpair *rrp ;
  adns_status st ;
  int i ;

  {
#line 836
  rrp = (adns_rr_intstrpair *)datap;
#line 840
  i = 0;
  {
#line 840
  while (1) {
    while_continue: /* CIL Label */ ;
#line 840
    if (! (i < 2)) {
#line 840
      goto while_break;
    }
    {
#line 841
    st = pap_qstring___11(pai, & cbyte___3, max, & rrp->array[i].i, & rrp->array[i].str);
    }
#line 842
    if (st) {
#line 842
      return (st);
    }
#line 840
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 845
  if (cbyte___3 != max) {
#line 845
    return ((adns_status )104);
  }
#line 847
  return ((adns_status )0);
}
}
#line 854 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pap_mailbox822___11(parseinfo const   *pai , int *cbyte_io , int max ,
                                       char **mb_r ) 
{ 
  int lablen ;
  int labstart ;
  int i ;
  int needquote ;
  int c ;
  int r ;
  int neednorm ;
  unsigned char const   *p ;
  char *str ;
  findlabel_state fls ;
  adns_status st ;
  vbuf *vb___0 ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 863
  vb___0 = & (pai->qu)->vb;
#line 864
  vb___0->used = 0;
#line 865
  adns__findlabel_start(& fls, (adns_state )pai->ads, -1, (adns_query )pai->qu, (byte const   *)pai->dgram,
                        (int )pai->dglen, max, *cbyte_io, cbyte_io);
#line 869
  st = adns__findlabel_next(& fls, & lablen, & labstart);
  }
#line 870
  if (! lablen) {
    {
#line 871
    adns__vbuf_appendstr(vb___0, ".");
    }
#line 872
    goto x_ok;
  }
#line 875
  neednorm = 1;
#line 876
  i = 0;
#line 876
  needquote = 0;
#line 876
  p = (unsigned char const   *)(pai->dgram + labstart);
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (! (i < lablen)) {
#line 876
      goto while_break;
    }
#line 877
    tmp = p;
#line 877
    p ++;
#line 877
    c = (int )*tmp;
#line 878
    if ((c & -129) < 32) {
#line 878
      return ((adns_status )104);
    } else
#line 878
    if ((c & -129) == 127) {
#line 878
      return ((adns_status )104);
    }
#line 879
    if (c == 46) {
#line 879
      if (! neednorm) {
#line 879
        neednorm = 1;
      } else {
#line 879
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 880
    if (c == 32) {
#line 880
      needquote ++;
    } else
#line 880
    if (c >= 127) {
#line 880
      needquote ++;
    } else {
      {
#line 880
      tmp___0 = ctype_822special(c);
      }
#line 880
      if (tmp___0) {
#line 880
        needquote ++;
      } else {
#line 881
        neednorm = 0;
      }
    }
#line 876
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 884
  if (needquote) {
#line 884
    goto _L___0;
  } else
#line 884
  if (neednorm) {
    _L___0: /* CIL Label */ 
    {
#line 885
    r = adns__vbuf_ensure(vb___0, (lablen + needquote) + 4);
    }
#line 885
    if (! r) {
#line 885
      return ((adns_status )1);
    }
    {
#line 886
    adns__vbuf_appendq(vb___0, (byte const   *)"\"", 1);
#line 887
    i = 0;
#line 887
    needquote = 0;
#line 887
    p = (unsigned char const   *)(pai->dgram + labstart);
    }
    {
#line 887
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 887
      if (! (i < lablen)) {
#line 887
        goto while_break___0;
      }
#line 888
      c = (int )*p;
#line 889
      if (c == 34) {
        {
#line 889
        adns__vbuf_appendq(vb___0, (byte const   *)"\\", 1);
        }
      } else
#line 889
      if (c == 92) {
        {
#line 889
        adns__vbuf_appendq(vb___0, (byte const   *)"\\", 1);
        }
      }
      {
#line 890
      adns__vbuf_appendq(vb___0, p, 1);
#line 887
      i ++;
#line 887
      p ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 892
    adns__vbuf_appendq(vb___0, (byte const   *)"\"", 1);
    }
  } else {
    {
#line 894
    r = adns__vbuf_append(vb___0, (byte const   *)(pai->dgram + labstart), lablen);
    }
#line 894
    if (! r) {
#line 894
      return ((adns_status )1);
    }
  }
  {
#line 897
  r = adns__vbuf_appendstr(vb___0, "@");
  }
#line 897
  if (! r) {
#line 897
    return ((adns_status )1);
  }
  {
#line 899
  st = adns__parse_domain_more(& fls, (adns_state )pai->ads, (adns_query )pai->qu,
                               vb___0, (parsedomain_flags )0, (byte const   *)pai->dgram);
  }
#line 900
  if (st) {
#line 900
    return (st);
  }
  x_ok: 
  {
#line 903
  tmp___1 = adns__alloc_interim((adns_query )pai->qu, (size_t )(vb___0->used + 1));
#line 903
  str = (char *)tmp___1;
  }
#line 903
  if (! str) {
#line 903
    return ((adns_status )1);
  }
  {
#line 904
  memcpy((void */* __restrict  */)str, (void const   */* __restrict  */)vb___0->buf,
         (size_t )vb___0->used);
#line 905
  *(str + vb___0->used) = (char)0;
#line 906
  *mb_r = str;
  }
#line 907
  return ((adns_status )0);
}
}
#line 910 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pap_mailbox___11(parseinfo const   *pai , int *cbyte_io , int max ,
                                    char **mb_r ) 
{ 
  adns_status tmp ;
  adns_status tmp___0 ;

  {
#line 912
  if ((unsigned int const   )((pai->qu)->typei)->typekey & 131072U) {
    {
#line 913
    tmp = pap_mailbox822___11(pai, cbyte_io, max, mb_r);
    }
#line 913
    return (tmp);
  } else {
    {
#line 915
    tmp___0 = pap_domain___11(pai, cbyte_io, max, mb_r, (parsedomain_flags )1);
    }
#line 915
    return (tmp___0);
  }
}
}
#line 919 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status csp_mailbox___11(vbuf *vb___0 , char const   *mailbox ) 
{ 
  adns_status tmp ;

  {
  {
#line 920
  tmp = csp_domain___11(vb___0, mailbox);
  }
#line 920
  return (tmp);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_rp___11(parseinfo const   *pai , int cbyte___3 , int max , void *datap ) 
{ 
  adns_rr_strpair *rrp ;
  adns_status st ;

  {
  {
#line 929
  rrp = (adns_rr_strpair *)datap;
#line 932
  st = pap_mailbox___11(pai, & cbyte___3, max, & rrp->array[0]);
  }
#line 933
  if (st) {
#line 933
    return (st);
  }
  {
#line 935
  st = pap_domain___11(pai, & cbyte___3, max, & rrp->array[1], (parsedomain_flags )1);
  }
#line 936
  if (st) {
#line 936
    return (st);
  }
#line 938
  if (cbyte___3 != max) {
#line 938
    return ((adns_status )104);
  }
#line 939
  return ((adns_status )0);
}
}
#line 942 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_rp___11(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_strpair const   *rrp ;
  adns_status st ;
  int tmp ;

  {
  {
#line 943
  rrp = (adns_rr_strpair const   *)datap;
#line 946
  st = csp_mailbox___11(vb___0, (char const   *)rrp->array[0]);
  }
#line 946
  if (st) {
#line 946
    return (st);
  }
  {
#line 947
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 947
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 947
    if (! tmp) {
#line 947
      return ((adns_status )1);
    }
#line 947
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 948
  st = csp_domain___11(vb___0, (char const   *)rrp->array[1]);
  }
#line 948
  if (st) {
#line 948
    return (st);
  }
#line 950
  return ((adns_status )0);
}
}
#line 957 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_soa___11(parseinfo const   *pai , int cbyte___3 , int max ,
                               void *datap ) 
{ 
  adns_rr_soa *rrp ;
  byte const   *dgram ;
  adns_status st ;
  int msw ;
  int lsw ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 959
  rrp = (adns_rr_soa *)datap;
#line 960
  dgram = (byte const   *)pai->dgram;
#line 964
  if ((pai->qu)->flags & 64) {
#line 964
    tmp = 1;
  } else {
#line 964
    tmp = 0;
  }
  {
#line 964
  st = pap_domain___11(pai, & cbyte___3, max, & rrp->mname, (parsedomain_flags )tmp);
  }
#line 966
  if (st) {
#line 966
    return (st);
  }
  {
#line 968
  st = pap_mailbox___11(pai, & cbyte___3, max, & rrp->rname);
  }
#line 969
  if (st) {
#line 969
    return (st);
  }
#line 971
  if (cbyte___3 + 20 != max) {
#line 971
    return ((adns_status )104);
  }
#line 973
  i = 0;
  {
#line 973
  while (1) {
    while_continue: /* CIL Label */ ;
#line 973
    if (! (i < 5)) {
#line 973
      goto while_break;
    }
#line 974
    msw = 0;
#line 974
    tmp___0 = cbyte___3;
#line 974
    cbyte___3 ++;
#line 974
    msw |= (int )(((int const   )*(dgram + tmp___0) & 255) << 8);
#line 974
    tmp___1 = cbyte___3;
#line 974
    cbyte___3 ++;
#line 974
    msw |= (int )((int const   )*(dgram + tmp___1) & 255);
#line 975
    lsw = 0;
#line 975
    tmp___2 = cbyte___3;
#line 975
    cbyte___3 ++;
#line 975
    lsw |= (int )(((int const   )*(dgram + tmp___2) & 255) << 8);
#line 975
    tmp___3 = cbyte___3;
#line 975
    cbyte___3 ++;
#line 975
    lsw |= (int )((int const   )*(dgram + tmp___3) & 255);
#line 976
    *(& rrp->serial + i) = (unsigned long )((msw << 16) | lsw);
#line 973
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 979
  return ((adns_status )0);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_soa___11(adns_query qu , void *datap ) 
{ 
  adns_rr_soa *rrp ;

  {
  {
#line 983
  rrp = (adns_rr_soa *)datap;
#line 985
  adns__makefinal_str(qu, & rrp->mname);
#line 986
  adns__makefinal_str(qu, & rrp->rname);
  }
#line 987
  return;
}
}
#line 989 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_soa___11(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_soa const   *rrp ;
  char buf___17[20] ;
  int i ;
  adns_status st ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 990
  rrp = (adns_rr_soa const   *)datap;
#line 995
  st = csp_domain___11(vb___0, (char const   *)rrp->mname);
  }
#line 995
  if (st) {
#line 995
    return (st);
  }
  {
#line 996
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 996
    tmp = adns__vbuf_appendstr(vb___0, " ");
    }
#line 996
    if (! tmp) {
#line 996
      return ((adns_status )1);
    }
#line 996
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 997
  st = csp_mailbox___11(vb___0, (char const   *)rrp->rname);
  }
#line 997
  if (st) {
#line 997
    return (st);
  }
#line 999
  i = 0;
  {
#line 999
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 999
    if (! (i < 5)) {
#line 999
      goto while_break___0;
    }
    {
#line 1000
    sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %lu",
            *(& rrp->serial + i));
    }
    {
#line 1001
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1001
      tmp___0 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
      }
#line 1001
      if (! tmp___0) {
#line 1001
        return ((adns_status )1);
      }
#line 1001
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 999
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1004
  return ((adns_status )0);
}
}
#line 1011 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status qdpl_srv___11(adns_state ads___7 , char const   **p_io , char const   *pe ,
                                 int labelnum , char *label_r , int *ll_io , adns_queryflags flags ,
                                 typeinfo const   *typei ) 
{ 
  int useflags ;
  char const   *p_orig ;
  adns_status st ;
  int ll ;
  void *tmp ;

  {
#line 1020
  if (labelnum < 2) {
#line 1020
    if (! ((unsigned int )flags & 16U)) {
#line 1021
      useflags = 16;
#line 1022
      p_orig = *p_io;
    } else {
#line 1024
      useflags = (int )flags;
#line 1025
      p_orig = (char const   *)0;
    }
  } else {
#line 1024
    useflags = (int )flags;
#line 1025
    p_orig = (char const   *)0;
  }
  {
#line 1027
  st = adns__qdpl_normal(ads___7, p_io, pe, labelnum, (char *)label_r, ll_io, (adns_queryflags )useflags,
                         typei);
  }
#line 1028
  if (st) {
#line 1028
    return (st);
  }
#line 1030
  if (p_orig) {
#line 1031
    ll = *ll_io;
#line 1032
    if (! ll) {
#line 1033
      return ((adns_status )201);
    } else
#line 1032
    if ((int )*(label_r + 0) != 95) {
#line 1033
      return ((adns_status )201);
    }
    {
#line 1034
    tmp = memchr((void const   *)(p_orig + 1), '\\', (size_t )(pe - (p_orig + 1)));
    }
#line 1034
    if (tmp) {
#line 1035
      return ((adns_status )201);
    }
  }
#line 1037
  return ((adns_status )0);
}
}
#line 1040 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pap_srv_begin___11(parseinfo const   *pai , int *cbyte_io , int max ,
                                      adns_rr_srvha *rrp ) 
{ 
  byte const   *dgram ;
  int ti ;
  int cbyte___3 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1043
  dgram = (byte const   *)pai->dgram;
#line 1046
  cbyte___3 = *cbyte_io;
#line 1047
  tmp = *cbyte_io + 6;
#line 1047
  *cbyte_io = tmp;
#line 1047
  if (tmp > max) {
#line 1047
    return ((adns_status )104);
  }
#line 1049
  ti = 0;
#line 1049
  tmp___0 = cbyte___3;
#line 1049
  cbyte___3 ++;
#line 1049
  ti |= (int )(((int const   )*(dgram + tmp___0) & 255) << 8);
#line 1049
  tmp___1 = cbyte___3;
#line 1049
  cbyte___3 ++;
#line 1049
  ti |= (int )((int const   )*(dgram + tmp___1) & 255);
#line 1049
  rrp->priority = ti;
#line 1050
  ti = 0;
#line 1050
  tmp___2 = cbyte___3;
#line 1050
  cbyte___3 ++;
#line 1050
  ti |= (int )(((int const   )*(dgram + tmp___2) & 255) << 8);
#line 1050
  tmp___3 = cbyte___3;
#line 1050
  cbyte___3 ++;
#line 1050
  ti |= (int )((int const   )*(dgram + tmp___3) & 255);
#line 1050
  rrp->weight = ti;
#line 1051
  ti = 0;
#line 1051
  tmp___4 = cbyte___3;
#line 1051
  cbyte___3 ++;
#line 1051
  ti |= (int )(((int const   )*(dgram + tmp___4) & 255) << 8);
#line 1051
  tmp___5 = cbyte___3;
#line 1051
  cbyte___3 ++;
#line 1051
  ti |= (int )((int const   )*(dgram + tmp___5) & 255);
#line 1051
  rrp->port = ti;
#line 1052
  return ((adns_status )0);
}
}
#line 1055 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_srvraw___11(parseinfo const   *pai , int cbyte___3 , int max ,
                                  void *datap ) 
{ 
  adns_rr_srvraw *rrp ;
  adns_status st ;
  int tmp ;

  {
  {
#line 1057
  rrp = (adns_rr_srvraw *)datap;
#line 1060
  st = pap_srv_begin___11(pai, & cbyte___3, max, (adns_rr_srvha *)datap);
  }
#line 1061
  if (st) {
#line 1061
    return (st);
  }
#line 1063
  if ((pai->qu)->flags & 64) {
#line 1063
    tmp = 1;
  } else {
#line 1063
    tmp = 0;
  }
  {
#line 1063
  st = pap_domain___11(pai, & cbyte___3, max, & rrp->host, (parsedomain_flags )tmp);
  }
#line 1065
  if (st) {
#line 1065
    return (st);
  }
#line 1067
  if (cbyte___3 != max) {
#line 1067
    return ((adns_status )104);
  }
#line 1068
  return ((adns_status )0);
}
}
#line 1071 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_srvha___11(parseinfo const   *pai , int cbyte___3 , int max ,
                                 void *datap ) 
{ 
  adns_rr_srvha *rrp ;
  adns_status st ;

  {
  {
#line 1073
  rrp = (adns_rr_srvha *)datap;
#line 1076
  st = pap_srv_begin___11(pai, & cbyte___3, max, (adns_rr_srvha *)datap);
  }
#line 1076
  if (st) {
#line 1076
    return (st);
  }
  {
#line 1077
  st = pap_hostaddr___11(pai, & cbyte___3, max, & rrp->ha);
  }
#line 1077
  if (st) {
#line 1077
    return (st);
  }
#line 1078
  if (cbyte___3 != max) {
#line 1078
    return ((adns_status )104);
  }
#line 1079
  return ((adns_status )0);
}
}
#line 1082 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_srvraw___11(adns_query qu , void *datap ) 
{ 
  adns_rr_srvraw *rrp ;

  {
  {
#line 1083
  rrp = (adns_rr_srvraw *)datap;
#line 1084
  adns__makefinal_str(qu, & rrp->host);
  }
#line 1085
  return;
}
}
#line 1087 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_srvha___11(adns_query qu , void *datap ) 
{ 
  adns_rr_srvha *rrp ;

  {
  {
#line 1088
  rrp = (adns_rr_srvha *)datap;
#line 1089
  mfp_hostaddr___11(qu, & rrp->ha);
  }
#line 1090
  return;
}
}
#line 1092 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static int di_srv___11(adns_state ads___7 , void const   *datap_a , void const   *datap_b ) 
{ 
  adns_rr_srvraw const   *ap ;
  adns_rr_srvraw const   *bp ;

  {
#line 1093
  ap = (adns_rr_srvraw const   *)datap_a;
#line 1093
  bp = (adns_rr_srvraw const   *)datap_b;
#line 1096
  if (ap->priority < bp->priority) {
#line 1096
    return (0);
  }
#line 1097
  if (ap->priority > bp->priority) {
#line 1097
    return (1);
  }
#line 1098
  return (0);
}
}
#line 1101 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status csp_srv_begin___11(vbuf *vb___0 , adns_rr_srvha const   *rrp ) 
{ 
  char buf___17[30] ;
  int tmp ;

  {
  {
#line 1104
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"%u %u %u ",
          rrp->priority, rrp->weight, rrp->port);
  }
  {
#line 1105
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1105
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 1105
    if (! tmp) {
#line 1105
      return ((adns_status )1);
    }
#line 1105
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1106
  return ((adns_status )0);
}
}
#line 1109 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_srvraw___11(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_srvraw const   *rrp ;
  adns_status st ;
  adns_status tmp ;

  {
  {
#line 1110
  rrp = (adns_rr_srvraw const   *)datap;
#line 1113
  st = csp_srv_begin___11(vb___0, (adns_rr_srvha const   *)((void const   *)rrp));
  }
#line 1113
  if (st) {
#line 1113
    return (st);
  }
  {
#line 1114
  tmp = csp_domain___11(vb___0, (char const   *)rrp->host);
  }
#line 1114
  return (tmp);
}
}
#line 1117 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_srvha___11(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_srvha const   *rrp ;
  adns_status st ;
  adns_status tmp ;

  {
  {
#line 1118
  rrp = (adns_rr_srvha const   *)datap;
#line 1121
  st = csp_srv_begin___11(vb___0, (adns_rr_srvha const   *)datap);
  }
#line 1121
  if (st) {
#line 1121
    return (st);
  }
  {
#line 1122
  tmp = csp_hostaddr___11(vb___0, & rrp->ha);
  }
#line 1122
  return (tmp);
}
}
#line 1125 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void postsort_srv___11(adns_state ads___7 , void *array , int nrrs , struct typeinfo  const  *typei ) 
{ 
  char *workbegin ;
  char *workend ;
  char *search ;
  char *arrayend ;
  adns_rr_srvha const   *rr ;
  union __anonunion_rrtmp_89___11 rrtmp ;
  int cpriority ;
  int totalweight ;
  int runtotal ;
  long randval ;

  {
#line 1138
  workbegin = (char *)array;
#line 1138
  arrayend = workbegin + typei->rrsz * (int const   )nrrs;
  {
#line 1138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1138
    if (! ((unsigned long )workbegin < (unsigned long )arrayend)) {
#line 1138
      goto while_break;
    }
#line 1141
    rr = (adns_rr_srvha const   *)((void *)workbegin);
#line 1141
    cpriority = (int )rr->priority;
#line 1143
    workend = workbegin;
#line 1143
    totalweight = 0;
    {
#line 1143
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1143
      if ((unsigned long )workend < (unsigned long )arrayend) {
#line 1143
        rr = (adns_rr_srvha const   *)((void *)workend);
#line 1143
        if (! (rr->priority == (int const   )cpriority)) {
#line 1143
          goto while_break___0;
        }
      } else {
#line 1143
        goto while_break___0;
      }
#line 1146
      totalweight += (int )rr->weight;
#line 1143
      workend += typei->rrsz;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1155
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1155
      if (! ((unsigned long )(workbegin + typei->rrsz) < (unsigned long )workend)) {
#line 1155
        goto while_break___1;
      }
      {
#line 1159
      randval = nrand48((unsigned short *)(ads___7->rand48xsubi));
#line 1160
      randval %= (long )(totalweight + 1);
#line 1167
      search = workbegin;
#line 1167
      runtotal = 0;
      }
      {
#line 1167
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1167
        rr = (adns_rr_srvha const   *)((void *)search);
#line 1167
        runtotal += (int )rr->weight;
#line 1167
        if (! ((long )runtotal < randval)) {
#line 1167
          goto while_break___2;
        }
#line 1167
        search += typei->rrsz;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1170
      if (! ((unsigned long )search < (unsigned long )arrayend)) {
        {
#line 1170
        __assert_fail("search < arrayend", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c",
                      1170U, "postsort_srv");
        }
      }
#line 1171
      totalweight -= (int )rr->weight;
#line 1172
      if ((unsigned long )search != (unsigned long )workbegin) {
        {
#line 1173
        memcpy((void */* __restrict  */)(& rrtmp), (void const   */* __restrict  */)workbegin,
               (size_t )typei->rrsz);
#line 1174
        memcpy((void */* __restrict  */)workbegin, (void const   */* __restrict  */)search,
               (size_t )typei->rrsz);
#line 1175
        memcpy((void */* __restrict  */)search, (void const   */* __restrict  */)(& rrtmp),
               (size_t )typei->rrsz);
        }
      }
#line 1155
      workbegin += typei->rrsz;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1138
    workbegin = workend;
  }
  while_break: /* CIL Label */ ;
  }
#line 1184
  return;
}
}
#line 1190 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_byteblock___11(adns_query qu , void *datap ) 
{ 
  adns_rr_byteblock *rrp ;
  void *bytes___3 ;

  {
  {
#line 1191
  rrp = (adns_rr_byteblock *)datap;
#line 1192
  bytes___3 = (void *)rrp->data;
#line 1193
  adns__makefinal_block(qu, & bytes___3, (size_t )rrp->len);
#line 1194
  rrp->data = (unsigned char *)bytes___3;
  }
#line 1195
  return;
}
}
#line 1201 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status pa_opaque___11(parseinfo const   *pai , int cbyte___3 , int max ,
                                  void *datap ) 
{ 
  adns_rr_byteblock *rrp ;
  void *tmp ;

  {
  {
#line 1203
  rrp = (adns_rr_byteblock *)datap;
#line 1205
  rrp->len = max - cbyte___3;
#line 1206
  tmp = adns__alloc_interim((adns_query )pai->qu, (size_t )rrp->len);
#line 1206
  rrp->data = (unsigned char *)tmp;
  }
#line 1207
  if (! rrp->data) {
#line 1207
    return ((adns_status )1);
  }
  {
#line 1208
  memcpy((void */* __restrict  */)rrp->data, (void const   */* __restrict  */)(pai->dgram + cbyte___3),
         (size_t )rrp->len);
  }
#line 1209
  return ((adns_status )0);
}
}
#line 1212 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static adns_status cs_opaque___11(vbuf *vb___0 , void const   *datap ) 
{ 
  adns_rr_byteblock const   *rrp ;
  char buf___17[10] ;
  int l ;
  unsigned char *p ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1213
  rrp = (adns_rr_byteblock const   *)datap;
#line 1218
  sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)"\\# %d",
          rrp->len);
  }
  {
#line 1219
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1219
    tmp = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
    }
#line 1219
    if (! tmp) {
#line 1219
      return ((adns_status )1);
    }
#line 1219
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1221
  l = (int )rrp->len;
#line 1221
  p = (unsigned char *)rrp->data;
  {
#line 1221
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1221
    if (! (l >= 4)) {
#line 1221
      goto while_break___0;
    }
    {
#line 1224
    sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %02x%02x%02x%02x",
            (int )*(p + 0), (int )*(p + 1), (int )*(p + 2), (int )*(p + 3));
    }
    {
#line 1225
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1225
      tmp___0 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
      }
#line 1225
      if (! tmp___0) {
#line 1225
        return ((adns_status )1);
      }
#line 1225
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1221
    l -= 4;
#line 1221
    p += 4;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1227
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1227
    if (! (l > 0)) {
#line 1227
      goto while_break___2;
    }
    {
#line 1230
    sprintf((char */* __restrict  */)(buf___17), (char const   */* __restrict  */)" %02x",
            (int )*p);
    }
    {
#line 1231
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 1231
      tmp___1 = adns__vbuf_appendstr(vb___0, (char const   *)(buf___17));
      }
#line 1231
      if (! tmp___1) {
#line 1231
        return ((adns_status )1);
      }
#line 1231
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1227
    l --;
#line 1227
    p ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1233
  return ((adns_status )0);
}
}
#line 1240 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static void mf_flat___11(adns_query qu , void *data___0 ) 
{ 


  {
#line 1240
  return;
}
}
#line 1261 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static typeinfo const   typeinfos___11[17]  = 
#line 1261
  {      {(adns_rrtype )1, "A", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.inaddr)),
      & mf_flat___11, & cs_inaddr___11, & pa_inaddr___11, & di_inaddr___11, (adns_status (*)(adns_state ads ,
                                                                                             char const   **p_io ,
                                                                                             char const   *pe ,
                                                                                             int labelnum ,
                                                                                             char *label_r ,
                                                                                             int *ll_io ,
                                                                                             adns_queryflags flags ,
                                                                                             struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )2,
      "NS", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___11, & cs_domain___11,
      & pa_host_raw___11, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )5,
      "CNAME", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___11,
      & cs_domain___11, & pa_dom_raw___11, (int (*)(adns_state ads , void const   *datap_a ,
                                                    void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                                char const   **p_io ,
                                                                                                char const   *pe ,
                                                                                                int labelnum ,
                                                                                                char *label_r ,
                                                                                                int *ll_io ,
                                                                                                adns_queryflags flags ,
                                                                                                struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )6,
      "SOA", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.soa)), & mf_soa___11, & cs_soa___11,
      & pa_soa___11, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )12,
      "PTR", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___11, & cs_domain___11,
      & pa_host_raw___11, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )13,
      "HINFO", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.intstrpair)),
      & mf_intstrpair___11, & cs_hinfo___11, & pa_hinfo___11, (int (*)(adns_state ads ,
                                                                       void const   *datap_a ,
                                                                       void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )15,
      "MX", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.intstr)), & mf_intstr___11,
      & cs_inthost___11, & pa_mx_raw___11, & di_mx_raw___11, (adns_status (*)(adns_state ads ,
                                                                              char const   **p_io ,
                                                                              char const   *pe ,
                                                                              int labelnum ,
                                                                              char *label_r ,
                                                                              int *ll_io ,
                                                                              adns_queryflags flags ,
                                                                              struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )16,
      "TXT", (char const   *)0, (int )sizeof(*(((adns_answer *)0)->rrs.manyistr)),
      & mf_manyistr___11, & cs_txt___11, & pa_txt___11, (int (*)(adns_state ads ,
                                                                 void const   *datap_a ,
                                                                 void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )17,
      "RP", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.strpair)), & mf_strpair___11,
      & cs_rp___11, & pa_rp___11, (int (*)(adns_state ads , void const   *datap_a ,
                                           void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                       char const   **p_io ,
                                                                                       char const   *pe ,
                                                                                       int labelnum ,
                                                                                       char *label_r ,
                                                                                       int *ll_io ,
                                                                                       adns_queryflags flags ,
                                                                                       struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )33,
      "SRV", "raw", (int )sizeof(*(((adns_answer *)0)->rrs.srvraw)), & mf_srvraw___11,
      & cs_srvraw___11, & pa_srvraw___11, & di_srv___11, & qdpl_srv___11, & postsort_srv___11}, 
        {(adns_rrtype )65537,
      "A", "addr", (int )sizeof(*(((adns_answer *)0)->rrs.addr)), & mf_flat___11,
      & cs_addr___11, & pa_addr___11, & di_addr___11, (adns_status (*)(adns_state ads ,
                                                                       char const   **p_io ,
                                                                       char const   *pe ,
                                                                       int labelnum ,
                                                                       char *label_r ,
                                                                       int *ll_io ,
                                                                       adns_queryflags flags ,
                                                                       struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65538,
      "NS", "+addr", (int )sizeof(*(((adns_answer *)0)->rrs.hostaddr)), & mf_hostaddr___11,
      & cs_hostaddr___11, & pa_hostaddr___11, & di_hostaddr___11, (adns_status (*)(adns_state ads ,
                                                                                   char const   **p_io ,
                                                                                   char const   *pe ,
                                                                                   int labelnum ,
                                                                                   char *label_r ,
                                                                                   int *ll_io ,
                                                                                   adns_queryflags flags ,
                                                                                   struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65548,
      "PTR", "checked", (int )sizeof(*(((adns_answer *)0)->rrs.str)), & mf_str___11,
      & cs_domain___11, & pa_ptr___11, (int (*)(adns_state ads , void const   *datap_a ,
                                                void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                            char const   **p_io ,
                                                                                            char const   *pe ,
                                                                                            int labelnum ,
                                                                                            char *label_r ,
                                                                                            int *ll_io ,
                                                                                            adns_queryflags flags ,
                                                                                            struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65551,
      "MX", "+addr", (int )sizeof(*(((adns_answer *)0)->rrs.inthostaddr)), & mf_inthostaddr___11,
      & cs_inthostaddr___11, & pa_mx___11, & di_mx___11, (adns_status (*)(adns_state ads ,
                                                                          char const   **p_io ,
                                                                          char const   *pe ,
                                                                          int labelnum ,
                                                                          char *label_r ,
                                                                          int *ll_io ,
                                                                          adns_queryflags flags ,
                                                                          struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )65569,
      "SRV", "+addr", (int )sizeof(*(((adns_answer *)0)->rrs.srvha)), & mf_srvha___11,
      & cs_srvha___11, & pa_srvha___11, & di_srv___11, & qdpl_srv___11, & postsort_srv___11}, 
        {(adns_rrtype )131078,
      "SOA", "822", (int )sizeof(*(((adns_answer *)0)->rrs.soa)), & mf_soa___11, & cs_soa___11,
      & pa_soa___11, (int (*)(adns_state ads , void const   *datap_a , void const   *datap_b ))0,
      (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                       char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}, 
        {(adns_rrtype )131089,
      "RP", "822", (int )sizeof(*(((adns_answer *)0)->rrs.strpair)), & mf_strpair___11,
      & cs_rp___11, & pa_rp___11, (int (*)(adns_state ads , void const   *datap_a ,
                                           void const   *datap_b ))0, (adns_status (*)(adns_state ads ,
                                                                                       char const   **p_io ,
                                                                                       char const   *pe ,
                                                                                       int labelnum ,
                                                                                       char *label_r ,
                                                                                       int *ll_io ,
                                                                                       adns_queryflags flags ,
                                                                                       struct typeinfo  const  *typei ))(& adns__qdpl_normal),
      (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0}};
#line 1288 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/types.c"
static struct typeinfo  const  typeinfo_unknown___11  = 
#line 1288
     {(adns_rrtype )262144, (char const   *)0, "unknown", (int )sizeof(*(((adns_answer *)0)->rrs.byteblock)),
    & mf_byteblock___11, & cs_opaque___11, & pa_opaque___11, (int (*)(adns_state ads ,
                                                                      void const   *datap_a ,
                                                                      void const   *datap_b ))0,
    (adns_status (*)(adns_state ads , char const   **p_io , char const   *pe , int labelnum ,
                     char *label_r , int *ll_io , adns_queryflags flags , struct typeinfo  const  *typei ))(& adns__qdpl_normal),
    (void (*)(adns_state ads , void *array , int nrrs , struct typeinfo  const  *typei ))0};
#line 39 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c"
static adns_query query_alloc___11(adns_state ads___7 , typeinfo const   *typei ,
                                   adns_rrtype type , adns_queryflags flags , struct timeval now ) 
{ 
  adns_query qu ;
  void *tmp ;
  void *tmp___0 ;
  adns_query tmp___1 ;
  adns_query tmp___2 ;
  adns_query tmp___3 ;
  adns_query tmp___4 ;
  allocnode *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __suseconds_t tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 45
  tmp = malloc(sizeof(*qu));
#line 45
  qu = (adns_query )tmp;
  }
#line 45
  if (! qu) {
#line 45
    return ((adns_query )0);
  }
  {
#line 46
  tmp___0 = malloc(sizeof(*(qu->answer)));
#line 46
  qu->answer = (adns_answer *)tmp___0;
  }
#line 47
  if (! qu->answer) {
    {
#line 47
    free((void *)qu);
    }
#line 47
    return ((adns_query )0);
  }
  {
#line 49
  qu->ads = ads___7;
#line 50
  qu->state = (enum __anonenum_state_83 )0;
#line 51
  tmp___2 = (adns_query )0;
#line 51
  qu->parent = tmp___2;
#line 51
  tmp___1 = tmp___2;
#line 51
  qu->next = tmp___1;
#line 51
  qu->back = tmp___1;
#line 52
  tmp___3 = (adns_query )0;
#line 52
  qu->children.tail = tmp___3;
#line 52
  qu->children.head = tmp___3;
#line 53
  tmp___4 = (adns_query )0;
#line 53
  qu->siblings.back = tmp___4;
#line 53
  qu->siblings.next = tmp___4;
#line 54
  tmp___5 = (allocnode *)0;
#line 54
  qu->allocations.tail = tmp___5;
#line 54
  qu->allocations.head = tmp___5;
#line 55
  qu->interim_allocd = 0;
#line 56
  qu->preserved_allocd = 0;
#line 57
  qu->final_allocspace = (void *)0;
#line 59
  qu->typei = typei;
#line 60
  qu->query_dgram = (byte *)0;
#line 61
  qu->query_dglen = 0;
#line 62
  adns__vbuf_init(& qu->vb);
#line 64
  qu->cname_dgram = (byte *)0;
#line 65
  tmp___6 = 0;
#line 65
  qu->cname_begin = tmp___6;
#line 65
  qu->cname_dglen = tmp___6;
#line 67
  adns__vbuf_init(& qu->search_vb);
#line 68
  tmp___8 = 0;
#line 68
  qu->search_doneabs = tmp___8;
#line 68
  tmp___7 = tmp___8;
#line 68
  qu->search_pos = tmp___7;
#line 68
  qu->search_origlen = tmp___7;
#line 70
  qu->id = -2;
#line 71
  qu->flags = (int )flags;
#line 72
  qu->retries = 0;
#line 73
  qu->udpnextserver = 0;
#line 74
  qu->udpsent = 0UL;
#line 75
  tmp___9 = (__suseconds_t )0;
#line 75
  qu->timeout.tv_usec = tmp___9;
#line 75
  qu->timeout.tv_sec = tmp___9;
#line 76
  qu->expires = now.tv_sec + 604800L;
#line 78
  memset((void *)(& qu->ctx), 0, sizeof(qu->ctx));
#line 80
  (qu->answer)->status = (adns_status )0;
#line 81
  tmp___10 = (char *)0;
#line 81
  (qu->answer)->owner = tmp___10;
#line 81
  (qu->answer)->cname = tmp___10;
#line 82
  (qu->answer)->type = type;
#line 83
  (qu->answer)->expires = (time_t )-1;
#line 84
  (qu->answer)->nrrs = 0;
#line 85
  (qu->answer)->rrs.untyped = (void *)0;
#line 86
  (qu->answer)->rrsz = (int )typei->rrsz;
  }
#line 88
  return (qu);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c"
static void query_submit___11(adns_state ads___7 , adns_query qu , typeinfo const   *typei ,
                              vbuf *qumsg_vb , int id , adns_queryflags flags , struct timeval now ) 
{ 
  void *tmp ;

  {
  {
#line 98
  qu->vb = *qumsg_vb;
#line 99
  adns__vbuf_init(qumsg_vb);
#line 101
  tmp = malloc((size_t )qu->vb.used);
#line 101
  qu->query_dgram = (byte *)tmp;
  }
#line 102
  if (! qu->query_dgram) {
    {
#line 102
    adns__query_fail(qu, (adns_status )1);
    }
#line 102
    return;
  }
  {
#line 104
  qu->id = id;
#line 105
  qu->query_dglen = qu->vb.used;
#line 106
  memcpy((void */* __restrict  */)qu->query_dgram, (void const   */* __restrict  */)qu->vb.buf,
         (size_t )qu->vb.used);
#line 108
  adns__query_send(qu, now);
  }
#line 109
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c"
static void query_simple___11(adns_state ads___7 , adns_query qu , char const   *owner ,
                              int ol , typeinfo const   *typei , adns_queryflags flags ,
                              struct timeval now ) 
{ 
  vbuf vb_new ;
  int id ;
  adns_status stat ;

  {
  {
#line 136
  stat = adns__mkquery(ads___7, & qu->vb, & id, owner, ol, typei, (qu->answer)->type,
                       flags);
  }
#line 138
  if (stat) {
#line 139
    if ((unsigned int )stat == 202U) {
#line 139
      if ((unsigned int )flags & 1U) {
        {
#line 140
        adns__search_next(ads___7, qu, now);
        }
#line 141
        return;
      } else {
        {
#line 143
        adns__query_fail(qu, stat);
        }
#line 144
        return;
      }
    } else {
      {
#line 143
      adns__query_fail(qu, stat);
      }
#line 144
      return;
    }
  }
  {
#line 148
  vb_new = qu->vb;
#line 149
  adns__vbuf_init(& qu->vb);
#line 150
  query_submit___11(ads___7, qu, typei, & vb_new, id, flags, now);
  }
#line 151
  return;
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c"
static int save_owner___11(adns_query qu , char const   *owner , int ol ) 
{ 
  adns_answer *ans ;
  void *tmp ;

  {
#line 198
  if (! (qu->flags & 4)) {
#line 198
    return (1);
  }
#line 200
  ans = qu->answer;
#line 201
  if (! (! ans->owner)) {
    {
#line 201
    __assert_fail("!ans->owner", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c",
                  201U, "save_owner");
    }
  }
  {
#line 203
  tmp = adns__alloc_preserved(qu, (size_t )(ol + 1));
#line 203
  ans->owner = (char *)tmp;
  }
#line 203
  if (! ans->owner) {
#line 203
    return (0);
  }
  {
#line 205
  memcpy((void */* __restrict  */)ans->owner, (void const   */* __restrict  */)owner,
         (size_t )ol);
#line 206
  *(ans->owner + ol) = (char)0;
  }
#line 207
  return (1);
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c"
static void *alloc_common___11(adns_query qu , size_t sz ) 
{ 
  allocnode *an ;
  void *tmp ;

  {
#line 342
  if (! sz) {
#line 342
    return ((void *)qu);
  }
#line 343
  if (! (! qu->final_allocspace)) {
    {
#line 343
    __assert_fail("!qu->final_allocspace", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c",
                  343U, "alloc_common");
    }
  }
  {
#line 344
  tmp = malloc((((((((sizeof(*an) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ) + sz) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ));
#line 344
  an = (allocnode *)tmp;
  }
#line 345
  if (! an) {
#line 345
    return ((void *)0);
  }
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 346
    an->next = (struct allocnode *)0;
#line 346
    an->back = qu->allocations.tail;
#line 346
    if (qu->allocations.tail) {
#line 346
      (qu->allocations.tail)->next = an;
    } else {
#line 346
      qu->allocations.head = an;
    }
#line 346
    qu->allocations.tail = an;
#line 346
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 347
  return ((void *)((byte *)an + (((sizeof(*an) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign )));
}
}
#line 410 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c"
static void cancel_children___11(adns_query qu ) 
{ 
  adns_query cqu ;
  adns_query ncqu ;

  {
#line 413
  cqu = qu->children.head;
  {
#line 413
  while (1) {
    while_continue: /* CIL Label */ ;
#line 413
    if (! cqu) {
#line 413
      goto while_break;
    }
    {
#line 414
    ncqu = cqu->siblings.next;
#line 415
    adns_cancel(cqu);
#line 413
    cqu = ncqu;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 417
  return;
}
}
#line 427 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c"
static void free_query_allocs___11(adns_query qu ) 
{ 
  allocnode *an ;
  allocnode *ann ;
  allocnode *tmp ;

  {
  {
#line 430
  cancel_children___11(qu);
#line 431
  an = qu->allocations.head;
  }
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    if (! an) {
#line 431
      goto while_break;
    }
    {
#line 431
    ann = an->next;
#line 431
    free((void *)an);
#line 431
    an = ann;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 432
  tmp = (allocnode *)0;
#line 432
  qu->allocations.tail = tmp;
#line 432
  qu->allocations.head = tmp;
#line 433
  adns__vbuf_free(& qu->vb);
#line 434
  adns__vbuf_free(& qu->search_vb);
#line 435
  free((void *)qu->query_dgram);
#line 436
  qu->query_dgram = (byte *)0;
  }
#line 437
  return;
}
}
#line 477 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/query.c"
static void makefinal_query___11(adns_query qu ) 
{ 
  adns_answer *ans ;
  int rrn ;
  void *tmp ;

  {
#line 481
  ans = qu->answer;
#line 483
  if (qu->interim_allocd) {
    {
#line 484
    tmp = realloc((void *)qu->answer, (((((((sizeof(*ans) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ) + (unsigned long )qu->interim_allocd) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ));
#line 484
    ans = (adns_answer *)tmp;
    }
#line 486
    if (! ans) {
#line 486
      goto x_nomem;
    }
#line 487
    qu->answer = ans;
  }
  {
#line 490
  qu->final_allocspace = (void *)((byte *)ans + (((sizeof(*ans) + sizeof(union maxalign )) - 1UL) / sizeof(union maxalign )) * sizeof(union maxalign ));
#line 491
  adns__makefinal_str(qu, & ans->cname);
#line 492
  adns__makefinal_str(qu, & ans->owner);
  }
#line 494
  if (ans->nrrs) {
    {
#line 495
    adns__makefinal_block(qu, & ans->rrs.untyped, (size_t )(ans->nrrs * ans->rrsz));
#line 497
    rrn = 0;
    }
    {
#line 497
    while (1) {
      while_continue: /* CIL Label */ ;
#line 497
      if (! (rrn < ans->nrrs)) {
#line 497
        goto while_break;
      }
      {
#line 498
      (*((qu->typei)->makefinal))(qu, (void *)(ans->rrs.bytes + rrn * ans->rrsz));
#line 497
      rrn ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 501
  free_query_allocs___11(qu);
  }
#line 502
  return;
  x_nomem: 
  {
#line 505
  qu->preserved_allocd = 0;
#line 506
  (qu->answer)->cname = (char *)0;
#line 507
  (qu->answer)->owner = (char *)0;
#line 508
  adns__reset_preserved(qu);
#line 510
  (qu->answer)->status = (adns_status )1;
#line 511
  free_query_allocs___11(qu);
  }
#line 512
  return;
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/transmit.c"
static adns_status mkquery_header___11(adns_state ads___7 , vbuf *vb___0 , int *id_r ,
                                       int qdlen ) 
{ 
  int id ;
  byte *rqp ;
  int tmp ;
  int tmp___0 ;
  byte *tmp___1 ;
  byte *tmp___2 ;
  byte *tmp___3 ;
  byte *tmp___4 ;
  byte *tmp___5 ;
  byte *tmp___6 ;
  byte *tmp___7 ;
  byte *tmp___8 ;
  byte *tmp___9 ;
  byte *tmp___10 ;
  byte *tmp___11 ;
  byte *tmp___12 ;

  {
  {
#line 46
  tmp = adns__vbuf_ensure(vb___0, (12 + qdlen) + 4);
  }
#line 46
  if (! tmp) {
#line 46
    return ((adns_status )1);
  }
#line 48
  vb___0->used = 0;
#line 49
  rqp = vb___0->buf + vb___0->used;
#line 51
  tmp___0 = ads___7->nextid;
#line 51
  (ads___7->nextid) ++;
#line 51
  id = tmp___0 & 65535;
#line 51
  *id_r = id;
#line 52
  tmp___1 = rqp;
#line 52
  rqp ++;
#line 52
  *tmp___1 = (byte )((id >> 8) & 255);
#line 52
  tmp___2 = rqp;
#line 52
  rqp ++;
#line 52
  *tmp___2 = (byte )(id & 255);
#line 53
  tmp___3 = rqp;
#line 53
  rqp ++;
#line 53
  *tmp___3 = (byte )1;
#line 54
  tmp___4 = rqp;
#line 54
  rqp ++;
#line 54
  *tmp___4 = (byte )0;
#line 55
  tmp___5 = rqp;
#line 55
  rqp ++;
#line 55
  *tmp___5 = (byte )((1 >> 8) & 255);
#line 55
  tmp___6 = rqp;
#line 55
  rqp ++;
#line 55
  *tmp___6 = (byte )1;
#line 56
  tmp___7 = rqp;
#line 56
  rqp ++;
#line 56
  *tmp___7 = (byte )0;
#line 56
  tmp___8 = rqp;
#line 56
  rqp ++;
#line 56
  *tmp___8 = (byte )0;
#line 57
  tmp___9 = rqp;
#line 57
  rqp ++;
#line 57
  *tmp___9 = (byte )0;
#line 57
  tmp___10 = rqp;
#line 57
  rqp ++;
#line 57
  *tmp___10 = (byte )0;
#line 58
  tmp___11 = rqp;
#line 58
  rqp ++;
#line 58
  *tmp___11 = (byte )0;
#line 58
  tmp___12 = rqp;
#line 58
  rqp ++;
#line 58
  *tmp___12 = (byte )0;
#line 60
  vb___0->used = (int )(rqp - vb___0->buf);
#line 62
  return ((adns_status )0);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/transmit.c"
static adns_status mkquery_footer___11(vbuf *vb___0 , adns_rrtype type ) 
{ 
  byte *rqp ;
  byte *tmp ;
  byte *tmp___0 ;
  byte *tmp___1 ;
  byte *tmp___2 ;

  {
#line 68
  rqp = vb___0->buf + vb___0->used;
#line 69
  tmp = rqp;
#line 69
  rqp ++;
#line 69
  *tmp = (byte )((((unsigned int )type & 65535U) >> 8) & 255U);
#line 69
  tmp___0 = rqp;
#line 69
  rqp ++;
#line 69
  *tmp___0 = (byte )(((unsigned int )type & 65535U) & 255U);
#line 70
  tmp___1 = rqp;
#line 70
  rqp ++;
#line 70
  *tmp___1 = (byte )((1 >> 8) & 255);
#line 70
  tmp___2 = rqp;
#line 70
  rqp ++;
#line 70
  *tmp___2 = (byte )1;
#line 71
  vb___0->used = (int )(rqp - vb___0->buf);
#line 72
  if (! (vb___0->used <= vb___0->avail)) {
    {
#line 72
    __assert_fail("vb->used <= vb->avail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/transmit.c",
                  72U, "mkquery_footer");
    }
  }
#line 74
  return ((adns_status )0);
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/transmit.c"
static void query_usetcp___11(adns_query qu , struct timeval now ) 
{ 


  {
  {
#line 244
  qu->state = (enum __anonenum_state_83 )1;
#line 245
  qu->timeout = now;
#line 246
  timevaladd___18(& qu->timeout, 30000L);
  }
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    qu->next = (adns_query )0;
#line 247
    qu->back = (qu->ads)->tcpw.tail;
#line 247
    if ((qu->ads)->tcpw.tail) {
#line 247
      ((qu->ads)->tcpw.tail)->next = qu;
    } else {
#line 247
      (qu->ads)->tcpw.head = qu;
    }
#line 247
    (qu->ads)->tcpw.tail = qu;
#line 247
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 248
  adns__querysend_tcp(qu, now);
#line 249
  adns__tcp_tryconnect(qu->ads, now);
  }
#line 250
  return;
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void readconfig___11(adns_state ads___7 , char const   *filename , int warnmissing ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void addserver___11(adns_state ads___7 , struct in_addr addr ) 
{ 
  int i ;
  struct server *ss ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 48
  i = 0;
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (i < ads___7->nservers)) {
#line 48
      goto while_break;
    }
#line 49
    if (ads___7->servers[i].addr.s_addr == addr.s_addr) {
      {
#line 50
      tmp = inet_ntoa(addr);
#line 50
      adns__debug(ads___7, -1, (adns_query )0, "duplicate nameserver %s ignored",
                  tmp);
      }
#line 51
      return;
    }
#line 48
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  if (ads___7->nservers >= 5) {
    {
#line 56
    tmp___0 = inet_ntoa(addr);
#line 56
    adns__diag(ads___7, -1, (adns_query )0, "too many nameservers, ignoring %s", tmp___0);
    }
#line 57
    return;
  }
#line 60
  ss = ads___7->servers + ads___7->nservers;
#line 61
  ss->addr = addr;
#line 62
  (ads___7->nservers) ++;
#line 63
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void freesearchlist___11(adns_state ads___7 ) 
{ 


  {
#line 66
  if (ads___7->nsearchlist) {
    {
#line 66
    free((void *)*(ads___7->searchlist));
    }
  }
  {
#line 67
  free((void *)ads___7->searchlist);
  }
#line 68
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void saveerr___11(adns_state ads___7 , int en ) 
{ 


  {
#line 71
  if (! ads___7->configerrno) {
#line 71
    ads___7->configerrno = en;
  }
#line 72
  return;
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void configparseerr___11(adns_state ads___7 , char const   *fn , int lno ,
                                char const   *fmt  , ...) 
{ 
  va_list al ;

  {
  {
#line 78
  saveerr___11(ads___7, 22);
  }
#line 79
  if (! ads___7->logfn) {
#line 79
    return;
  } else
#line 79
  if ((unsigned int )ads___7->iflags & 2U) {
#line 79
    return;
  }
#line 81
  if (lno == -1) {
    {
#line 81
    adns__lprintf(ads___7, "adns: %s: ", fn);
    }
  } else {
    {
#line 82
    adns__lprintf(ads___7, "adns: %s:%d: ", fn, lno);
    }
  }
  {
#line 83
  __builtin_va_start(al, fmt);
#line 84
  adns__vlprintf(ads___7, fmt, al);
#line 85
  __builtin_va_end(al);
#line 86
  adns__lprintf(ads___7, "\n");
  }
#line 87
  return;
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static int nextword___11(char const   **bufp_io , char const   **word_r , int *l_r ) 
{ 
  char const   *p ;
  char const   *q ;
  int tmp ;
  int tmp___0 ;

  {
#line 92
  p = *bufp_io;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 93
    tmp = ctype_whitespace((int )*p);
    }
#line 93
    if (! tmp) {
#line 93
      goto while_break;
    }
#line 93
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  if (! *p) {
#line 94
    return (0);
  }
#line 96
  q = p;
  {
#line 97
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 97
    if (*q) {
      {
#line 97
      tmp___0 = ctype_whitespace((int )*q);
      }
#line 97
      if (tmp___0) {
#line 97
        goto while_break___0;
      }
    } else {
#line 97
      goto while_break___0;
    }
#line 97
    q ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 99
  *l_r = (int )(q - p);
#line 100
  *word_r = p;
#line 101
  *bufp_io = q;
#line 103
  return (1);
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void ccf_nameserver___11(adns_state ads___7 , char const   *fn , int lno ,
                                char const   *buf___17 ) 
{ 
  struct in_addr ia ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 110
  tmp = inet_aton(buf___17, & ia);
  }
#line 110
  if (! tmp) {
    {
#line 111
    configparseerr___11(ads___7, fn, lno, "invalid nameserver address `%s\'", buf___17);
    }
#line 112
    return;
  }
  {
#line 114
  tmp___0 = inet_ntoa(ia);
#line 114
  adns__debug(ads___7, -1, (adns_query )0, "using nameserver %s", tmp___0);
#line 115
  addserver___11(ads___7, ia);
  }
#line 116
  return;
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void ccf_search___11(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  char const   *bufp ;
  char const   *word ;
  char *newchars ;
  char **newptrs ;
  char **pp ;
  int count ;
  int tl ;
  int l ;
  int tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char **tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
#line 124
  if (! buf___17) {
#line 124
    return;
  }
#line 126
  bufp = buf___17;
#line 127
  count = 0;
#line 128
  tl = 0;
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 129
    tmp = nextword___11(& bufp, & word, & l);
    }
#line 129
    if (! tmp) {
#line 129
      goto while_break;
    }
#line 129
    count ++;
#line 129
    tl += l + 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 131
  tmp___0 = malloc(sizeof(char *) * (unsigned long )count);
#line 131
  newptrs = (char **)tmp___0;
  }
#line 132
  if (! newptrs) {
    {
#line 132
    tmp___1 = __errno_location();
#line 132
    saveerr___11(ads___7, *tmp___1);
    }
#line 132
    return;
  }
  {
#line 134
  tmp___2 = malloc((size_t )tl);
#line 134
  newchars = (char *)tmp___2;
  }
#line 135
  if (! newchars) {
    {
#line 135
    tmp___3 = __errno_location();
#line 135
    saveerr___11(ads___7, *tmp___3);
#line 135
    free((void *)newptrs);
    }
#line 135
    return;
  }
#line 137
  bufp = buf___17;
#line 138
  pp = newptrs;
  {
#line 139
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 139
    tmp___6 = nextword___11(& bufp, & word, & l);
    }
#line 139
    if (! tmp___6) {
#line 139
      goto while_break___0;
    }
    {
#line 140
    tmp___4 = pp;
#line 140
    pp ++;
#line 140
    *tmp___4 = newchars;
#line 141
    memcpy((void */* __restrict  */)newchars, (void const   */* __restrict  */)word,
           (size_t )l);
#line 142
    newchars += l;
#line 143
    tmp___5 = newchars;
#line 143
    newchars ++;
#line 143
    *tmp___5 = (char)0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 146
  freesearchlist___11(ads___7);
#line 147
  ads___7->nsearchlist = count;
#line 148
  ads___7->searchlist = newptrs;
  }
#line 149
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void ccf_sortlist___11(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  char const   *word ;
  char tbuf[200] ;
  char *slash ;
  char *ep ;
  struct in_addr base ;
  struct in_addr mask ;
  int l ;
  unsigned long initial ;
  unsigned long baselocal ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  uint32_t tmp___3 ;
  int tmp___4 ;

  {
#line 159
  if (! buf___17) {
#line 159
    return;
  }
#line 161
  ads___7->nsortlist = 0;
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 162
    tmp___4 = nextword___11(& buf___17, & word, & l);
    }
#line 162
    if (! tmp___4) {
#line 162
      goto while_break;
    }
#line 163
    if (ads___7->nsortlist >= 15) {
      {
#line 164
      adns__diag(ads___7, -1, (adns_query )0, "too many sortlist entries, ignoring %.*s onwards",
                 l, word);
      }
#line 166
      return;
    }
#line 169
    if ((unsigned long )l >= sizeof(tbuf)) {
      {
#line 170
      configparseerr___11(ads___7, fn, lno, "sortlist entry `%.*s\' too long", l,
                          word);
      }
#line 171
      goto while_continue;
    }
    {
#line 174
    memcpy((void */* __restrict  */)(tbuf), (void const   */* __restrict  */)word,
           (size_t )l);
#line 174
    tbuf[l] = (char)0;
#line 175
    slash = strchr((char const   *)(tbuf), '/');
    }
#line 176
    if (slash) {
#line 176
      tmp = slash;
#line 176
      slash ++;
#line 176
      *tmp = (char)0;
    }
    {
#line 178
    tmp___0 = inet_aton((char const   *)(tbuf), & base);
    }
#line 178
    if (! tmp___0) {
      {
#line 179
      configparseerr___11(ads___7, fn, lno, "invalid address `%s\' in sortlist", tbuf);
      }
#line 180
      goto while_continue;
    }
#line 183
    if (slash) {
      {
#line 184
      tmp___2 = strchr((char const   *)slash, '.');
      }
#line 184
      if (tmp___2) {
        {
#line 185
        tmp___1 = inet_aton((char const   *)slash, & mask);
        }
#line 185
        if (! tmp___1) {
          {
#line 186
          configparseerr___11(ads___7, fn, lno, "invalid mask `%s\' in sortlist",
                              slash);
          }
#line 187
          goto while_continue;
        }
#line 189
        if (base.s_addr & ~ mask.s_addr) {
          {
#line 190
          configparseerr___11(ads___7, fn, lno, "mask `%s\' in sortlist overlaps address `%s\'",
                              slash, tbuf);
          }
#line 192
          goto while_continue;
        }
      } else {
        {
#line 195
        initial = strtoul((char const   */* __restrict  */)slash, (char **/* __restrict  */)(& ep),
                          10);
        }
#line 196
        if (*ep) {
          {
#line 197
          configparseerr___11(ads___7, fn, lno, "mask length `%s\' invalid", slash);
          }
#line 198
          goto while_continue;
        } else
#line 196
        if (initial > 32UL) {
          {
#line 197
          configparseerr___11(ads___7, fn, lno, "mask length `%s\' invalid", slash);
          }
#line 198
          goto while_continue;
        }
        {
#line 200
        mask.s_addr = htonl((uint32_t )(4294967295UL << (32UL - initial)));
        }
      }
    } else {
      {
#line 203
      tmp___3 = ntohl(base.s_addr);
#line 203
      baselocal = (unsigned long )tmp___3;
      }
#line 204
      if ((unsigned long )(! baselocal) & 2147483648UL) {
        {
#line 205
        mask.s_addr = htonl((uint32_t )4278190080UL);
        }
      } else
#line 206
      if ((baselocal & 3221225472UL) == 2147483648UL) {
        {
#line 207
        mask.s_addr = htonl((uint32_t )4294901760UL);
        }
      } else
#line 208
      if ((baselocal & 4026531840UL) == 3758096384UL) {
        {
#line 209
        mask.s_addr = htonl((uint32_t )4278190080UL);
        }
      } else {
        {
#line 211
        configparseerr___11(ads___7, fn, lno, "network address `%s\' in sortlist is not in classed ranges, must specify mask explicitly",
                            tbuf);
        }
#line 214
        goto while_continue;
      }
    }
#line 218
    ads___7->sortlist[ads___7->nsortlist].base = base;
#line 219
    ads___7->sortlist[ads___7->nsortlist].mask = mask;
#line 220
    (ads___7->nsortlist) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  return;
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void ccf_options___11(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  char const   *word ;
  char *ep ;
  unsigned long v ;
  int l ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 231
  if (! buf___17) {
#line 231
    return;
  }
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 233
    tmp___5 = nextword___11(& buf___17, & word, & l);
    }
#line 233
    if (! tmp___5) {
#line 233
      goto while_break;
    }
#line 234
    if (l == 5) {
      {
#line 234
      tmp = memcmp((void const   *)word, (void const   *)"debug", (size_t )5);
      }
#line 234
      if (! tmp) {
#line 235
        ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 8U);
#line 236
        goto while_continue;
      }
    }
#line 238
    if (l >= 6) {
      {
#line 238
      tmp___0 = memcmp((void const   *)word, (void const   *)"ndots:", (size_t )6);
      }
#line 238
      if (! tmp___0) {
        {
#line 239
        v = strtoul((char const   */* __restrict  */)(word + 6), (char **/* __restrict  */)(& ep),
                    10);
        }
#line 240
        if (l == 6) {
          {
#line 241
          configparseerr___11(ads___7, fn, lno, "option `%.*s\' malformed or has bad value",
                              l, word);
          }
#line 243
          goto while_continue;
        } else
#line 240
        if ((unsigned long )ep != (unsigned long )(word + l)) {
          {
#line 241
          configparseerr___11(ads___7, fn, lno, "option `%.*s\' malformed or has bad value",
                              l, word);
          }
#line 243
          goto while_continue;
        } else
#line 240
        if (v > 2147483647UL) {
          {
#line 241
          configparseerr___11(ads___7, fn, lno, "option `%.*s\' malformed or has bad value",
                              l, word);
          }
#line 243
          goto while_continue;
        }
#line 245
        ads___7->searchndots = (int )v;
#line 246
        goto while_continue;
      }
    }
#line 248
    if (l >= 12) {
      {
#line 248
      tmp___4 = memcmp((void const   *)word, (void const   *)"adns_checkc:", (size_t )12);
      }
#line 248
      if (! tmp___4) {
        {
#line 249
        tmp___3 = strcmp(word + 12, "none");
        }
#line 249
        if (tmp___3) {
          {
#line 252
          tmp___2 = strcmp(word + 12, "entex");
          }
#line 252
          if (tmp___2) {
            {
#line 255
            tmp___1 = strcmp(word + 12, "freq");
            }
#line 255
            if (tmp___1) {
              {
#line 258
              configparseerr___11(ads___7, fn, lno, "option adns_checkc has bad value `%s\' (must be none, entex or freq",
                                  word + 12);
              }
            } else {
#line 256
              ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 768U);
            }
          } else {
#line 253
            ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags & 4294966527U);
#line 254
            ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 256U);
          }
        } else {
#line 250
          ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags & 4294966527U);
#line 251
          ads___7->iflags = (adns_initflags )((unsigned int )ads___7->iflags | 256U);
        }
#line 261
        goto while_continue;
      }
    }
    {
#line 263
    adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown option `%.*s\'", fn, lno,
               l, word);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 265
  return;
}
}
#line 267 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void ccf_clearnss___11(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 


  {
#line 269
  ads___7->nservers = 0;
#line 270
  return;
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void ccf_include___11(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 


  {
#line 274
  if (! *buf___17) {
    {
#line 275
    configparseerr___11(ads___7, fn, lno, "`include\' directive with no filename");
    }
#line 276
    return;
  }
  {
#line 278
  readconfig___11(ads___7, buf___17, 1);
  }
#line 279
  return;
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void ccf_lookup___11(adns_state ads___7 , char const   *fn , int lno , char const   *buf___17 ) 
{ 
  int found_bind ;
  char const   *word ;
  int l ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 283
  found_bind = 0;
#line 287
  if (! *buf___17) {
    {
#line 288
    configparseerr___11(ads___7, fn, lno, "`lookup\' directive with no databases");
    }
#line 289
    return;
  }
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 292
    tmp___2 = nextword___11(& buf___17, & word, & l);
    }
#line 292
    if (! tmp___2) {
#line 292
      goto while_break;
    }
#line 293
    if (l == 4) {
      {
#line 293
      tmp___1 = memcmp((void const   *)word, (void const   *)"bind", (size_t )4);
      }
#line 293
      if (tmp___1) {
#line 293
        goto _L___0;
      } else {
#line 294
        found_bind = 1;
      }
    } else
    _L___0: /* CIL Label */ 
#line 295
    if (l == 4) {
      {
#line 295
      tmp___0 = memcmp((void const   *)word, (void const   *)"file", (size_t )4);
      }
#line 295
      if (tmp___0) {
#line 295
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 297
    if (l == 2) {
      {
#line 297
      tmp = memcmp((void const   *)word, (void const   *)"yp", (size_t )2);
      }
#line 297
      if (tmp) {
        {
#line 301
        adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown `lookup\' database `%.*s\'",
                   fn, lno, l, word);
#line 303
        found_bind = -1;
        }
      } else {
        {
#line 298
        adns__diag(ads___7, -1, (adns_query )0, "%s:%d: yp lookups not supported by adns",
                   fn, lno);
#line 299
        found_bind = -1;
        }
      }
    } else {
      {
#line 301
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown `lookup\' database `%.*s\'",
                 fn, lno, l, word);
#line 303
      found_bind = -1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 306
  if (! found_bind) {
    {
#line 307
    adns__diag(ads___7, -1, (adns_query )0, "%s:%d: `lookup\' specified, but not `bind\'",
               fn, lno);
    }
  }
#line 308
  return;
}
}
#line 310 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static struct configcommandinfo  const  configcommandinfos___11[9]  = 
#line 310
  {      {"nameserver", & ccf_nameserver___11}, 
        {"domain", & ccf_search___11}, 
        {"search", & ccf_search___11}, 
        {"sortlist", & ccf_sortlist___11}, 
        {"options", & ccf_options___11}, 
        {"clearnameservers", & ccf_clearnss___11}, 
        {"include", & ccf_include___11}, 
        {"lookup", & ccf_lookup___11}, 
        {(char const   *)0, (void (*)(adns_state ads , char const   *fn , int lno , char const   *buf ))0}};
#line 330 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static int gl_file___11(adns_state ads___7 , getline_ctx *src_io , char const   *filename ,
                        int lno , char *buf___17 , int buflen ) 
{ 
  FILE *file ;
  int c ;
  int i ;
  char *p ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 332
  file = src_io->file;
#line 336
  p = buf___17;
#line 337
  buflen --;
#line 338
  i = 0;
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (i == buflen) {
      {
#line 342
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: line too long, ignored", filename,
                 lno);
      }
#line 343
      goto x_badline;
    }
    {
#line 345
    c = _IO_getc(file);
    }
#line 346
    if (! c) {
      {
#line 347
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: line contains nul, ignored",
                 filename, lno);
      }
#line 348
      goto x_badline;
    } else
#line 349
    if (c == 10) {
#line 350
      goto while_break;
    } else
#line 351
    if (c == -1) {
      {
#line 352
      tmp___2 = ferror(file);
      }
#line 352
      if (tmp___2) {
        {
#line 353
        tmp = __errno_location();
#line 353
        saveerr___11(ads___7, *tmp);
#line 354
        tmp___0 = __errno_location();
#line 354
        tmp___1 = strerror(*tmp___0);
#line 354
        adns__diag(ads___7, -1, (adns_query )0, "%s:%d: read error: %s", filename,
                   lno, tmp___1);
        }
#line 356
        return (-1);
      }
#line 358
      if (! i) {
#line 358
        return (-1);
      }
#line 359
      goto while_break;
    } else {
#line 361
      tmp___3 = p;
#line 361
      p ++;
#line 361
      *tmp___3 = (char )c;
#line 362
      i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 366
  tmp___4 = p;
#line 366
  p ++;
#line 366
  *tmp___4 = (char)0;
#line 367
  return (i);
  x_badline: 
  {
#line 370
  saveerr___11(ads___7, 22);
  }
  {
#line 371
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 371
    c = _IO_getc(file);
    }
#line 371
    if (c != -1) {
#line 371
      if (! (c != 10)) {
#line 371
        goto while_break___0;
      }
    } else {
#line 371
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 372
  return (-2);
}
}
#line 375 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static int gl_text___11(adns_state ads___7 , getline_ctx *src_io , char const   *filename ,
                        int lno , char *buf___17 , int buflen ) 
{ 
  char const   *cp ;
  int l ;
  size_t tmp ;

  {
#line 377
  cp = src_io->text;
#line 380
  if (! cp) {
#line 380
    return (-1);
  } else
#line 380
  if (! *cp) {
#line 380
    return (-1);
  }
#line 382
  if ((int const   )*cp == 59) {
#line 382
    cp ++;
  } else
#line 382
  if ((int const   )*cp == 10) {
#line 382
    cp ++;
  }
  {
#line 383
  tmp = strcspn(cp, ";\n");
#line 383
  l = (int )tmp;
#line 384
  src_io->text = cp + l;
  }
#line 386
  if (l >= buflen) {
    {
#line 387
    adns__diag(ads___7, -1, (adns_query )0, "%s:%d: line too long, ignored", filename,
               lno);
#line 388
    saveerr___11(ads___7, 22);
    }
#line 389
    return (-2);
  }
  {
#line 392
  memcpy((void */* __restrict  */)buf___17, (void const   */* __restrict  */)cp, (size_t )l);
#line 393
  *(buf___17 + l) = (char)0;
  }
#line 394
  return (l);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void readconfiggeneric___11(adns_state ads___7 , char const   *filename , int (*getline___0)(adns_state ads ,
                                                                                                    getline_ctx * ,
                                                                                                    char const   *filename ,
                                                                                                    int lno ,
                                                                                                    char *buf ,
                                                                                                    int buflen ) ,
                                   getline_ctx gl_ctx ) 
{ 
  char linebuf[2000] ;
  char *p ;
  char *q ;
  int lno ;
  int l ;
  int dirl ;
  struct configcommandinfo  const  *ccip ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 410
  lno = 1;
  {
#line 410
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 410
    l = (*getline___0)(ads___7, & gl_ctx, filename, lno, linebuf, (int )sizeof(linebuf));
    }
#line 410
    if (! (l != -1)) {
#line 410
      goto while_break;
    }
#line 413
    if (l == -2) {
#line 413
      goto __Cont;
    }
    {
#line 414
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 414
      if (l > 0) {
        {
#line 414
        tmp = ctype_whitespace((int )linebuf[l - 1]);
        }
#line 414
        if (! tmp) {
#line 414
          goto while_break___0;
        }
      } else {
#line 414
        goto while_break___0;
      }
#line 414
      l --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 415
    linebuf[l] = (char)0;
#line 416
    p = linebuf;
    {
#line 417
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 417
      tmp___0 = ctype_whitespace((int )*p);
      }
#line 417
      if (! tmp___0) {
#line 417
        goto while_break___1;
      }
#line 417
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 418
    if ((int )*p == 35) {
#line 418
      goto __Cont;
    } else
#line 418
    if ((int )*p == 59) {
#line 418
      goto __Cont;
    } else
#line 418
    if (! *p) {
#line 418
      goto __Cont;
    }
#line 419
    q = p;
    {
#line 420
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 420
      if (*q) {
        {
#line 420
        tmp___1 = ctype_whitespace((int )*q);
        }
#line 420
        if (tmp___1) {
#line 420
          goto while_break___2;
        }
      } else {
#line 420
        goto while_break___2;
      }
#line 420
      q ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 421
    dirl = (int )(q - p);
#line 422
    ccip = configcommandinfos___11;
    {
#line 422
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 422
      if (ccip->name) {
        {
#line 422
        tmp___2 = strlen((char const   *)ccip->name);
        }
#line 422
        if (tmp___2 == (size_t )dirl) {
          {
#line 422
          tmp___3 = memcmp((void const   *)ccip->name, (void const   *)p, (size_t )(q - p));
          }
#line 422
          if (! tmp___3) {
#line 422
            goto while_break___3;
          }
        }
      } else {
#line 422
        goto while_break___3;
      }
#line 422
      ccip ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 426
    if (! ccip->name) {
      {
#line 427
      adns__diag(ads___7, -1, (adns_query )0, "%s:%d: unknown configuration directive `%.*s\'",
                 filename, lno, (int )(q - p), p);
      }
#line 429
      goto __Cont;
    }
    {
#line 431
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 431
      tmp___4 = ctype_whitespace((int )*q);
      }
#line 431
      if (! tmp___4) {
#line 431
        goto while_break___4;
      }
#line 431
      q ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 432
    (*(ccip->fn))(ads___7, filename, lno, (char const   *)q);
    }
    __Cont: /* CIL Label */ 
#line 410
    lno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 434
  return;
}
}
#line 436 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static char const   *instrum_getenv___11(adns_state ads___7 , char const   *envvar ) 
{ 
  char const   *value ;
  char *tmp ;

  {
  {
#line 439
  tmp = getenv(envvar);
#line 439
  value = (char const   *)tmp;
  }
#line 440
  if (! value) {
    {
#line 440
    adns__debug(ads___7, -1, (adns_query )0, "environment variable %s not set", envvar);
    }
  } else {
    {
#line 441
    adns__debug(ads___7, -1, (adns_query )0, "environment variable %s set to `%s\'",
                envvar, value);
    }
  }
#line 443
  return (value);
}
}
#line 446 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void readconfig___11(adns_state ads___7 , char const   *filename , int warnmissing ) 
{ 
  getline_ctx gl_ctx ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 449
  gl_ctx.file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 450
  if (! gl_ctx.file) {
    {
#line 451
    tmp = __errno_location();
    }
#line 451
    if (*tmp == 2) {
#line 452
      if (warnmissing) {
        {
#line 453
        adns__debug(ads___7, -1, (adns_query )0, "configuration file `%s\' does not exist",
                    filename);
        }
      }
#line 455
      return;
    }
    {
#line 457
    tmp___0 = __errno_location();
#line 457
    saveerr___11(ads___7, *tmp___0);
#line 458
    tmp___1 = __errno_location();
#line 458
    tmp___2 = strerror(*tmp___1);
#line 458
    adns__diag(ads___7, -1, (adns_query )0, "cannot open configuration file `%s\': %s",
               filename, tmp___2);
    }
#line 460
    return;
  }
  {
#line 463
  readconfiggeneric___11(ads___7, filename, & gl_file___11, gl_ctx);
#line 465
  fclose(gl_ctx.file);
  }
#line 466
  return;
}
}
#line 468 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void readconfigtext___11(adns_state ads___7 , char const   *text , char const   *showname ) 
{ 
  getline_ctx gl_ctx ;

  {
  {
#line 472
  gl_ctx.text = text;
#line 473
  readconfiggeneric___11(ads___7, showname, & gl_text___11, gl_ctx);
  }
#line 474
  return;
}
}
#line 476 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void readconfigenv___11(adns_state ads___7 , char const   *envvar ) 
{ 
  char const   *filename ;

  {
#line 479
  if ((unsigned int )ads___7->iflags & 1U) {
    {
#line 480
    adns__debug(ads___7, -1, (adns_query )0, "not checking environment variable `%s\'",
                envvar);
    }
#line 481
    return;
  }
  {
#line 483
  filename = instrum_getenv___11(ads___7, envvar);
  }
#line 484
  if (filename) {
    {
#line 484
    readconfig___11(ads___7, filename, 1);
    }
  }
#line 485
  return;
}
}
#line 487 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void readconfigenvtext___11(adns_state ads___7 , char const   *envvar ) 
{ 
  char const   *textdata ;

  {
#line 490
  if ((unsigned int )ads___7->iflags & 1U) {
    {
#line 491
    adns__debug(ads___7, -1, (adns_query )0, "not checking environment variable `%s\'",
                envvar);
    }
#line 492
    return;
  }
  {
#line 494
  textdata = instrum_getenv___11(ads___7, envvar);
  }
#line 495
  if (textdata) {
    {
#line 495
    readconfigtext___11(ads___7, textdata, envvar);
    }
  }
#line 496
  return;
}
}
#line 508 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static int init_begin___11(adns_state *ads_r , adns_initflags flags , adns_logcallbackfn *logfn ,
                           void *logfndata ) 
{ 
  adns_state ads___7 ;
  pid_t pid ;
  void *tmp ;
  int *tmp___0 ;
  adns_query tmp___1 ;
  adns_query tmp___2 ;
  adns_query tmp___3 ;
  adns_query tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __suseconds_t tmp___9 ;

  {
  {
#line 513
  tmp = malloc(sizeof(*ads___7));
#line 513
  ads___7 = (adns_state )tmp;
  }
#line 513
  if (! ads___7) {
    {
#line 513
    tmp___0 = __errno_location();
    }
#line 513
    return (*tmp___0);
  }
  {
#line 515
  ads___7->iflags = flags;
#line 516
  ads___7->logfn = logfn;
#line 517
  ads___7->logfndata = logfndata;
#line 518
  ads___7->configerrno = 0;
#line 519
  tmp___1 = (adns_query )0;
#line 519
  ads___7->udpw.tail = tmp___1;
#line 519
  ads___7->udpw.head = tmp___1;
#line 520
  tmp___2 = (adns_query )0;
#line 520
  ads___7->tcpw.tail = tmp___2;
#line 520
  ads___7->tcpw.head = tmp___2;
#line 521
  tmp___3 = (adns_query )0;
#line 521
  ads___7->childw.tail = tmp___3;
#line 521
  ads___7->childw.head = tmp___3;
#line 522
  tmp___4 = (adns_query )0;
#line 522
  ads___7->output.tail = tmp___4;
#line 522
  ads___7->output.head = tmp___4;
#line 523
  ads___7->forallnext = (adns_query )0;
#line 524
  ads___7->nextid = 12575;
#line 525
  tmp___5 = -1;
#line 525
  ads___7->tcpsocket = tmp___5;
#line 525
  ads___7->udpsocket = tmp___5;
#line 526
  adns__vbuf_init(& ads___7->tcpsend);
#line 527
  adns__vbuf_init(& ads___7->tcprecv);
#line 528
  ads___7->tcprecv_skip = 0;
#line 529
  tmp___8 = 0;
#line 529
  ads___7->tcpserver = tmp___8;
#line 529
  tmp___7 = tmp___8;
#line 529
  ads___7->nsearchlist = tmp___7;
#line 529
  tmp___6 = tmp___7;
#line 529
  ads___7->nsortlist = tmp___6;
#line 529
  ads___7->nservers = tmp___6;
#line 530
  ads___7->searchndots = 1;
#line 531
  ads___7->tcpstate = (enum adns__tcpstate )0;
#line 532
  tmp___9 = (__suseconds_t )0;
#line 532
  ads___7->tcptimeout.tv_usec = tmp___9;
#line 532
  ads___7->tcptimeout.tv_sec = tmp___9;
#line 533
  ads___7->searchlist = (char **)0;
#line 535
  pid = getpid();
#line 536
  ads___7->rand48xsubi[0] = (unsigned short )pid;
#line 537
  ads___7->rand48xsubi[1] = (unsigned short )((unsigned long )pid >> 16);
#line 538
  ads___7->rand48xsubi[2] = (unsigned short )((unsigned long )pid ^ ((unsigned long )pid >> 16));
#line 540
  *ads_r = ads___7;
  }
#line 541
  return (0);
}
}
#line 544 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static int init_finish___11(adns_state ads___7 ) 
{ 
  struct in_addr ia ;
  struct protoent *proto ;
  int r ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 549
  if (! ads___7->nservers) {
#line 550
    if (ads___7->logfn) {
#line 550
      if ((unsigned int )ads___7->iflags & 8U) {
        {
#line 551
        adns__lprintf(ads___7, "adns: no nameservers, using localhost\n");
        }
      }
    }
    {
#line 552
    ia.s_addr = htonl((in_addr_t )2130706433);
#line 553
    addserver___11(ads___7, ia);
    }
  }
  {
#line 556
  proto = getprotobyname("udp");
  }
#line 556
  if (! proto) {
#line 556
    r = 92;
#line 556
    goto x_free;
  }
  {
#line 557
  ads___7->udpsocket = socket(2, 2, proto->p_proto);
  }
#line 558
  if (ads___7->udpsocket < 0) {
    {
#line 558
    tmp = __errno_location();
#line 558
    r = *tmp;
    }
#line 558
    goto x_free;
  }
  {
#line 560
  r = adns__setnonblock(ads___7, ads___7->udpsocket);
  }
#line 561
  if (r) {
    {
#line 561
    tmp___0 = __errno_location();
#line 561
    r = *tmp___0;
    }
#line 561
    goto x_closeudp;
  }
#line 563
  return (0);
  x_closeudp: 
  {
#line 566
  close(ads___7->udpsocket);
  }
  x_free: 
  {
#line 568
  free((void *)ads___7);
  }
#line 569
  return (r);
}
}
#line 572 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void init_abort___11(adns_state ads___7 ) 
{ 


  {
#line 573
  if (ads___7->nsearchlist) {
    {
#line 574
    free((void *)*(ads___7->searchlist + 0));
#line 575
    free((void *)ads___7->searchlist);
    }
  }
  {
#line 577
  free((void *)ads___7);
  }
#line 578
  return;
}
}
#line 580 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static void logfn_file___11(adns_state ads___7 , void *logfndata , char const   *fmt ,
                            va_list al ) 
{ 


  {
  {
#line 582
  vfprintf((FILE */* __restrict  */)logfndata, (char const   */* __restrict  */)fmt,
           al);
  }
#line 583
  return;
}
}
#line 585 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static int init_files___11(adns_state *ads_r , adns_initflags flags , adns_logcallbackfn *logfn ,
                           void *logfndata ) 
{ 
  adns_state ads___7 ;
  char const   *res_options ;
  char const   *adns_res_options ;
  int r ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 591
  r = init_begin___11(& ads___7, flags, logfn, logfndata);
  }
#line 592
  if (r) {
#line 592
    return (r);
  }
  {
#line 594
  res_options = instrum_getenv___11(ads___7, "RES_OPTIONS");
#line 595
  adns_res_options = instrum_getenv___11(ads___7, "ADNS_RES_OPTIONS");
#line 596
  ccf_options___11(ads___7, "RES_OPTIONS", -1, res_options);
#line 597
  ccf_options___11(ads___7, "ADNS_RES_OPTIONS", -1, adns_res_options);
#line 599
  readconfig___11(ads___7, "/etc/resolv.conf", 1);
#line 600
  readconfig___11(ads___7, "/etc/resolv-adns.conf", 0);
#line 601
  readconfigenv___11(ads___7, "RES_CONF");
#line 602
  readconfigenv___11(ads___7, "ADNS_RES_CONF");
#line 604
  readconfigenvtext___11(ads___7, "RES_CONF_TEXT");
#line 605
  readconfigenvtext___11(ads___7, "ADNS_RES_CONF_TEXT");
#line 607
  ccf_options___11(ads___7, "RES_OPTIONS", -1, res_options);
#line 608
  ccf_options___11(ads___7, "ADNS_RES_OPTIONS", -1, adns_res_options);
#line 610
  tmp = instrum_getenv___11(ads___7, "LOCALDOMAIN");
#line 610
  ccf_search___11(ads___7, "LOCALDOMAIN", -1, tmp);
#line 611
  tmp___0 = instrum_getenv___11(ads___7, "ADNS_LOCALDOMAIN");
#line 611
  ccf_search___11(ads___7, "ADNS_LOCALDOMAIN", -1, tmp___0);
  }
#line 613
  if (ads___7->configerrno) {
#line 613
    if (ads___7->configerrno != 22) {
      {
#line 614
      r = ads___7->configerrno;
#line 615
      init_abort___11(ads___7);
      }
#line 616
      return (r);
    }
  }
  {
#line 619
  r = init_finish___11(ads___7);
  }
#line 620
  if (r) {
#line 620
    return (r);
  }
  {
#line 622
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
#line 623
  *ads_r = ads___7;
  }
#line 624
  return (0);
}
}
#line 631 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/setup.c"
static int init_strcfg___11(adns_state *ads_r , adns_initflags flags , adns_logcallbackfn *logfn ,
                            void *logfndata , char const   *configtext ) 
{ 
  adns_state ads___7 ;
  int r ;

  {
  {
#line 637
  r = init_begin___11(& ads___7, flags, logfn, logfndata);
  }
#line 638
  if (r) {
#line 638
    return (r);
  }
  {
#line 640
  readconfigtext___11(ads___7, configtext, "<supplied configuration text>");
  }
#line 641
  if (ads___7->configerrno) {
    {
#line 642
    r = ads___7->configerrno;
#line 643
    init_abort___11(ads___7);
    }
#line 644
    return (r);
  }
  {
#line 647
  r = init_finish___11(ads___7);
  }
#line 647
  if (r) {
#line 647
    return (r);
  }
  {
#line 648
  adns__consistency(ads___7, (adns_query )0, (consistency_checks )1);
#line 649
  *ads_r = ads___7;
  }
#line 650
  return (0);
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c"
static void checkc_query_alloc___11(adns_state ads___7 , adns_query qu ) 
{ 
  allocnode *an ;
  int tmp ;

  {
#line 58
  if (qu->allocations.head) {
#line 58
    if (! (! (qu->allocations.head)->back)) {
      {
#line 58
      __assert_fail("! (qu->allocations).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                    59U, "checkc_query_alloc");
      }
    }
#line 58
    an = qu->allocations.head;
    {
#line 58
    while (1) {
      while_continue: /* CIL Label */ ;
#line 58
      if (! an) {
#line 58
        goto while_break;
      }
#line 58
      if (an->next) {
#line 58
        tmp = (unsigned long )an == (unsigned long )(an->next)->back;
      } else {
#line 58
        tmp = (unsigned long )an == (unsigned long )qu->allocations.tail;
      }
#line 58
      if (! tmp) {
        {
#line 58
        __assert_fail("(an)-> next ? (an) == (an)-> next-> back : (an) == (qu->allocations).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      59U, "checkc_query_alloc");
        }
      }
#line 58
      an = an->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 60
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c"
static void checkc_query___11(adns_state ads___7 , adns_query qu ) 
{ 
  adns_query child ;

  {
#line 65
  if (! (qu->udpnextserver < ads___7->nservers)) {
    {
#line 65
    __assert_fail("qu->udpnextserver < ads->nservers", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  65U, "checkc_query");
    }
  }
#line 66
  if (! (! (qu->udpsent & (0xffffffffffffffffUL << ads___7->nservers)))) {
    {
#line 66
    __assert_fail("!(qu->udpsent & (~0UL << ads->nservers))", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  66U, "checkc_query");
    }
  }
#line 67
  if (! (qu->search_pos <= ads___7->nsearchlist)) {
    {
#line 67
    __assert_fail("qu->search_pos <= ads->nsearchlist", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  67U, "checkc_query");
    }
  }
#line 68
  if (qu->parent) {
    {
#line 68
    while (1) {
      while_continue: /* CIL Label */ ;
#line 68
      child = (qu->parent)->children.head;
      {
#line 68
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 68
        if (! ((unsigned long )child != (unsigned long )qu)) {
#line 68
          goto while_break___0;
        }
#line 68
        if (! child) {
          {
#line 68
          __assert_fail("(child)", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                        68U, "checkc_query");
          }
        }
#line 68
        child = child->siblings.next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 68
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 69
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c"
static void checkc_notcpbuf___11(adns_state ads___7 ) 
{ 


  {
#line 72
  if (! (! ads___7->tcpsend.used)) {
    {
#line 72
    __assert_fail("!ads->tcpsend.used", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  72U, "checkc_notcpbuf");
    }
  }
#line 73
  if (! (! ads___7->tcprecv.used)) {
    {
#line 73
    __assert_fail("!ads->tcprecv.used", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  73U, "checkc_notcpbuf");
    }
  }
#line 74
  if (! (! ads___7->tcprecv_skip)) {
    {
#line 74
    __assert_fail("!ads->tcprecv_skip", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  74U, "checkc_notcpbuf");
    }
  }
#line 75
  return;
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c"
static void checkc_global___11(adns_state ads___7 ) 
{ 
  int i ;

  {
#line 80
  if (! (ads___7->udpsocket >= 0)) {
    {
#line 80
    __assert_fail("ads->udpsocket >= 0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  80U, "checkc_global");
    }
  }
#line 82
  i = 0;
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! (i < ads___7->nsortlist)) {
#line 82
      goto while_break;
    }
#line 83
    if (! (! (ads___7->sortlist[i].base.s_addr & ~ ads___7->sortlist[i].mask.s_addr))) {
      {
#line 83
      __assert_fail("!(ads->sortlist[i].base.s_addr & ~ads->sortlist[i].mask.s_addr)",
                    "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                    83U, "checkc_global");
      }
    }
#line 82
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  if (ads___7->tcpserver >= 0) {
#line 85
    if (! (ads___7->tcpserver < ads___7->nservers)) {
      {
#line 85
      __assert_fail("ads->tcpserver >= 0 && ads->tcpserver < ads->nservers", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                    85U, "checkc_global");
      }
    }
  } else {
    {
#line 85
    __assert_fail("ads->tcpserver >= 0 && ads->tcpserver < ads->nservers", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  85U, "checkc_global");
    }
  }
  {
#line 88
  if ((unsigned int )ads___7->tcpstate == 1U) {
#line 88
    goto case_1;
  }
#line 93
  if ((unsigned int )ads___7->tcpstate == 3U) {
#line 93
    goto case_3;
  }
#line 93
  if ((unsigned int )ads___7->tcpstate == 0U) {
#line 93
    goto case_3;
  }
#line 97
  if ((unsigned int )ads___7->tcpstate == 2U) {
#line 97
    goto case_2;
  }
#line 101
  goto switch_default;
  case_1: /* CIL Label */ 
#line 89
  if (! (ads___7->tcpsocket >= 0)) {
    {
#line 89
    __assert_fail("ads->tcpsocket >= 0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  89U, "checkc_global");
    }
  }
  {
#line 90
  checkc_notcpbuf___11(ads___7);
  }
#line 91
  goto switch_break;
  case_3: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 94
  if (! (ads___7->tcpsocket == -1)) {
    {
#line 94
    __assert_fail("ads->tcpsocket == -1", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  94U, "checkc_global");
    }
  }
  {
#line 95
  checkc_notcpbuf___11(ads___7);
  }
#line 96
  goto switch_break;
  case_2: /* CIL Label */ 
#line 98
  if (! (ads___7->tcpsocket >= 0)) {
    {
#line 98
    __assert_fail("ads->tcpsocket >= 0", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  98U, "checkc_global");
    }
  }
#line 99
  if (! (ads___7->tcprecv_skip <= ads___7->tcprecv.used)) {
    {
#line 99
    __assert_fail("ads->tcprecv_skip <= ads->tcprecv.used", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                  99U, "checkc_global");
    }
  }
#line 100
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 102
  __assert_fail("!\"ads->tcpstate value\"", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                102U, "checkc_global");
  }
  switch_break: /* CIL Label */ ;
  }
#line 105
  if (! ads___7->searchlist) {
#line 105
    if (! (! ads___7->nsearchlist)) {
      {
#line 105
      __assert_fail("ads->searchlist || !ads->nsearchlist", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                    105U, "checkc_global");
      }
    }
  }
#line 106
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c"
static void checkc_queue_udpw___11(adns_state ads___7 ) 
{ 
  adns_query qu ;
  int tmp ;

  {
#line 111
  if (ads___7->udpw.head) {
#line 111
    if (! (! (ads___7->udpw.head)->back)) {
      {
#line 111
      __assert_fail("! (ads->udpw).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                    118U, "checkc_queue_udpw");
      }
    }
#line 111
    qu = ads___7->udpw.head;
    {
#line 111
    while (1) {
      while_continue: /* CIL Label */ ;
#line 111
      if (! qu) {
#line 111
        goto while_break;
      }
#line 111
      if (qu->next) {
#line 111
        tmp = (unsigned long )qu == (unsigned long )(qu->next)->back;
      } else {
#line 111
        tmp = (unsigned long )qu == (unsigned long )ads___7->udpw.tail;
      }
#line 111
      if (! tmp) {
        {
#line 111
        __assert_fail("(qu)-> next ? (qu) == (qu)-> next-> back : (qu) == (ads->udpw).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! ((unsigned int )qu->state == 0U)) {
        {
#line 111
        __assert_fail("qu->state==query_tosend", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! (qu->retries <= 15)) {
        {
#line 111
        __assert_fail("qu->retries <= 15", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! qu->udpsent) {
        {
#line 111
        __assert_fail("qu->udpsent", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
#line 111
      if (! qu->children.head) {
#line 111
        if (! (! qu->children.tail)) {
          {
#line 111
          __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                        118U, "checkc_queue_udpw");
          }
        }
      } else {
        {
#line 111
        __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      118U, "checkc_queue_udpw");
        }
      }
      {
#line 111
      checkc_query___11(ads___7, qu);
#line 111
      checkc_query_alloc___11(ads___7, qu);
#line 111
      qu = qu->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 119
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c"
static void checkc_queue_tcpw___11(adns_state ads___7 ) 
{ 
  adns_query qu ;
  int tmp ;

  {
#line 124
  if (ads___7->tcpw.head) {
#line 124
    if (! (! (ads___7->tcpw.head)->back)) {
      {
#line 124
      __assert_fail("! (ads->tcpw).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                    130U, "checkc_queue_tcpw");
      }
    }
#line 124
    qu = ads___7->tcpw.head;
    {
#line 124
    while (1) {
      while_continue: /* CIL Label */ ;
#line 124
      if (! qu) {
#line 124
        goto while_break;
      }
#line 124
      if (qu->next) {
#line 124
        tmp = (unsigned long )qu == (unsigned long )(qu->next)->back;
      } else {
#line 124
        tmp = (unsigned long )qu == (unsigned long )ads___7->tcpw.tail;
      }
#line 124
      if (! tmp) {
        {
#line 124
        __assert_fail("(qu)-> next ? (qu) == (qu)-> next-> back : (qu) == (ads->tcpw).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
#line 124
      if (! ((unsigned int )qu->state == 1U)) {
        {
#line 124
        __assert_fail("qu->state==query_tcpw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
#line 124
      if (! qu->children.head) {
#line 124
        if (! (! qu->children.tail)) {
          {
#line 124
          __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                        130U, "checkc_queue_tcpw");
          }
        }
      } else {
        {
#line 124
        __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
#line 124
      if (! (qu->retries <= ads___7->nservers + 1)) {
        {
#line 124
        __assert_fail("qu->retries <= ads->nservers+1", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      130U, "checkc_queue_tcpw");
        }
      }
      {
#line 124
      checkc_query___11(ads___7, qu);
#line 124
      checkc_query_alloc___11(ads___7, qu);
#line 124
      qu = qu->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 131
  return;
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c"
static void checkc_queue_childw___11(adns_state ads___7 ) 
{ 
  adns_query parent ;
  adns_query child ;
  int tmp ;
  int tmp___0 ;

  {
#line 136
  if (ads___7->childw.head) {
#line 136
    if (! (! (ads___7->childw.head)->back)) {
      {
#line 136
      __assert_fail("! (ads->childw).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                    145U, "checkc_queue_childw");
      }
    }
#line 136
    parent = ads___7->childw.head;
    {
#line 136
    while (1) {
      while_continue: /* CIL Label */ ;
#line 136
      if (! parent) {
#line 136
        goto while_break;
      }
#line 136
      if (parent->next) {
#line 136
        tmp = (unsigned long )parent == (unsigned long )(parent->next)->back;
      } else {
#line 136
        tmp = (unsigned long )parent == (unsigned long )ads___7->childw.tail;
      }
#line 136
      if (! tmp) {
        {
#line 136
        __assert_fail("(parent)-> next ? (parent) == (parent)-> next-> back : (parent) == (ads->childw).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      145U, "checkc_queue_childw");
        }
      }
#line 136
      if (! ((unsigned int )parent->state == 2U)) {
        {
#line 136
        __assert_fail("parent->state == query_childw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      145U, "checkc_queue_childw");
        }
      }
#line 136
      if (! parent->children.head) {
        {
#line 136
        __assert_fail("parent->children.head", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      145U, "checkc_queue_childw");
        }
      }
#line 136
      if (parent->children.head) {
#line 136
        if (! (! (parent->children.head)->siblings.back)) {
          {
#line 136
          __assert_fail("! (parent->children).head->siblings. back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                        145U, "checkc_queue_childw");
          }
        }
#line 136
        child = parent->children.head;
        {
#line 136
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 136
          if (! child) {
#line 136
            goto while_break___0;
          }
#line 136
          if (child->siblings.next) {
#line 136
            tmp___0 = (unsigned long )child == (unsigned long )(child->siblings.next)->siblings.back;
          } else {
#line 136
            tmp___0 = (unsigned long )child == (unsigned long )parent->children.tail;
          }
#line 136
          if (! tmp___0) {
            {
#line 136
            __assert_fail("(child)->siblings. next ? (child) == (child)->siblings. next->siblings. back : (child) == (parent->children).tail",
                          "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                          145U, "checkc_queue_childw");
            }
          }
#line 136
          if (! ((unsigned long )child->parent == (unsigned long )parent)) {
            {
#line 136
            __assert_fail("child->parent == parent", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                          145U, "checkc_queue_childw");
            }
          }
#line 136
          if (! ((unsigned int )child->state != 3U)) {
            {
#line 136
            __assert_fail("child->state != query_done", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                          145U, "checkc_queue_childw");
            }
          }
#line 136
          child = child->siblings.next;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 136
      checkc_query___11(ads___7, parent);
#line 136
      checkc_query_alloc___11(ads___7, parent);
#line 136
      parent = parent->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 146
  return;
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c"
static void checkc_queue_output___11(adns_state ads___7 ) 
{ 
  adns_query qu ;
  int tmp ;

  {
#line 151
  if (ads___7->output.head) {
#line 151
    if (! (! (ads___7->output.head)->back)) {
      {
#line 151
      __assert_fail("! (ads->output).head-> back", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                    157U, "checkc_queue_output");
      }
    }
#line 151
    qu = ads___7->output.head;
    {
#line 151
    while (1) {
      while_continue: /* CIL Label */ ;
#line 151
      if (! qu) {
#line 151
        goto while_break;
      }
#line 151
      if (qu->next) {
#line 151
        tmp = (unsigned long )qu == (unsigned long )(qu->next)->back;
      } else {
#line 151
        tmp = (unsigned long )qu == (unsigned long )ads___7->output.tail;
      }
#line 151
      if (! tmp) {
        {
#line 151
        __assert_fail("(qu)-> next ? (qu) == (qu)-> next-> back : (qu) == (ads->output).tail",
                      "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! ((unsigned int )qu->state == 3U)) {
        {
#line 151
        __assert_fail("qu->state == query_done", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! qu->children.head) {
#line 151
        if (! (! qu->children.tail)) {
          {
#line 151
          __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                        157U, "checkc_queue_output");
          }
        }
      } else {
        {
#line 151
        __assert_fail("!qu->children.head && !qu->children.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! (! qu->parent)) {
        {
#line 151
        __assert_fail("!qu->parent", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
#line 151
      if (! qu->allocations.head) {
#line 151
        if (! (! qu->allocations.tail)) {
          {
#line 151
          __assert_fail("!qu->allocations.head && !qu->allocations.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                        157U, "checkc_queue_output");
          }
        }
      } else {
        {
#line 151
        __assert_fail("!qu->allocations.head && !qu->allocations.tail", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/check.c",
                      157U, "checkc_queue_output");
        }
      }
      {
#line 151
      checkc_query___11(ads___7, qu);
#line 151
      qu = qu->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 158
  return;
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/general.c"
static struct sinfo  const  sinfos___11[24]  = 
#line 233 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/general.c"
  {      {(adns_status )0, "ok", "OK"}, 
        {(adns_status )1, "nomemory", "Out of memory"}, 
        {(adns_status )2, "unknownrrtype", "Query not implemented in DNS library"}, 
        {(adns_status )3, "systemfail", "General resolver or system failure"}, 
        {(adns_status )30, "timeout", "DNS query timed out"}, 
        {(adns_status )31, "allservfail", "All nameservers failed"}, 
        {(adns_status )32, "norecurse", "Recursion denied by nameserver"}, 
        {(adns_status )33, "invalidresponse", "Nameserver sent bad response"}, 
        {(adns_status )34, "unknownformat", "Nameserver used unknown format"}, 
        {(adns_status )60, "rcodeservfail", "Nameserver reports failure"}, 
        {(adns_status )61, "rcodeformaterror", "Query not understood by nameserver"}, 
        {(adns_status )62,
      "rcodenotimplemented", "Query not implemented by nameserver"}, 
        {(adns_status )63, "rcoderefused", "Query refused by nameserver"}, 
        {(adns_status )64, "rcodeunknown", "Nameserver sent unknown response code"}, 
        {(adns_status )100, "inconsistent", "Inconsistent resource records in DNS"}, 
        {(adns_status )101, "prohibitedcname", "DNS alias found where canonical name wanted"}, 
        {(adns_status )102,
      "answerdomaininvalid", "Found syntactically invalid domain name"}, 
        {(adns_status )103, "answerdomaintoolong", "Found overly-long domain name"}, 
        {(adns_status )104, "invaliddata", "Found invalid DNS data"}, 
        {(adns_status )200, "querydomainwrong", "Domain invalid for particular DNS query type"}, 
        {(adns_status )201,
      "querydomaininvalid", "Domain name is syntactically invalid"}, 
        {(adns_status )202, "querydomaintoolong", "Domain name or component is too long"}, 
        {(adns_status )300,
      "nxdomain", "No such domain"}, 
        {(adns_status )301, "nodata", "No such data"}};
#line 270 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/general.c"
static int si_compar___11(void const   *key , void const   *elem ) 
{ 
  adns_status const   *st ;
  struct sinfo  const  *si ;
  int tmp ;
  int tmp___0 ;

  {
#line 271
  st = (adns_status const   *)key;
#line 272
  si = (struct sinfo  const  *)elem;
#line 274
  if ((unsigned int const   )*st < (unsigned int const   )si->st) {
#line 274
    tmp___0 = -1;
  } else {
#line 274
    if ((unsigned int const   )*st > (unsigned int const   )si->st) {
#line 274
      tmp = 1;
    } else {
#line 274
      tmp = 0;
    }
#line 274
    tmp___0 = tmp;
  }
#line 274
  return (tmp___0);
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/general.c"
static struct sinfo  const  *findsinfo___11(adns_status st ) 
{ 
  void *tmp ;

  {
  {
#line 278
  tmp = bsearch((void const   *)(& st), (void const   *)(sinfos___11), sizeof(sinfos___11) / sizeof(sinfos___11[0]),
                sizeof(sinfos___11[0]), & si_compar___11);
  }
#line 278
  return ((struct sinfo  const  *)tmp);
}
}
#line 299 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/general.c"
static struct stinfo  const  stinfos___11[7]  = {      {(adns_status )0, "ok"}, 
        {(adns_status )29, "localfail"}, 
        {(adns_status )59, "remotefail"}, 
        {(adns_status )99, "tempfail"}, 
        {(adns_status )199, "misconfig"}, 
        {(adns_status )299, "misquery"}, 
        {(adns_status )499, "permfail"}};
#line 312 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/general.c"
static int sti_compar___11(void const   *key , void const   *elem ) 
{ 
  adns_status const   *st ;
  struct stinfo  const  *sti ;
  adns_status here ;
  adns_status min ;
  adns_status max ;
  int tmp ;
  int tmp___0 ;

  {
#line 313
  st = (adns_status const   *)key;
#line 314
  sti = (struct stinfo  const  *)elem;
#line 318
  here = (adns_status )*st;
#line 319
  if ((unsigned long )sti == (unsigned long )(stinfos___11)) {
#line 319
    min = (adns_status )0;
  } else {
#line 319
    min = (adns_status )((unsigned int const   )(sti + -1)->stmax + 1U);
  }
#line 320
  max = (adns_status )sti->stmax;
#line 322
  if ((unsigned int )here < (unsigned int )min) {
#line 322
    tmp___0 = -1;
  } else {
#line 322
    if ((unsigned int )here > (unsigned int )max) {
#line 322
      tmp = 1;
    } else {
#line 322
      tmp = 0;
    }
#line 322
    tmp___0 = tmp;
  }
#line 322
  return (tmp___0);
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c"
static void tcp_close___11(adns_state ads___7 ) 
{ 
  int serv ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 48
  serv = ads___7->tcpserver;
#line 49
  close(ads___7->tcpsocket);
#line 50
  ads___7->tcpsocket = -1;
#line 51
  tmp___0 = 0;
#line 51
  ads___7->tcpsend.used = tmp___0;
#line 51
  tmp = tmp___0;
#line 51
  ads___7->tcprecv_skip = tmp;
#line 51
  ads___7->tcprecv.used = tmp;
  }
#line 52
  return;
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c"
static void tcp_connected___11(adns_state ads___7 , struct timeval now ) 
{ 
  adns_query qu ;
  adns_query nqu ;

  {
  {
#line 76
  adns__debug(ads___7, ads___7->tcpserver, (adns_query )0, "TCP connected");
#line 77
  ads___7->tcpstate = (enum adns__tcpstate )2;
#line 78
  qu = ads___7->tcpw.head;
  }
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (qu) {
#line 78
      if (! ((unsigned int )ads___7->tcpstate == 2U)) {
#line 78
        goto while_break;
      }
    } else {
#line 78
      goto while_break;
    }
#line 79
    nqu = qu->next;
#line 80
    if (! ((unsigned int )qu->state == 1U)) {
      {
#line 80
      __assert_fail("qu->state == query_tcpw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c",
                    80U, "tcp_connected");
      }
    }
    {
#line 81
    adns__querysend_tcp(qu, now);
#line 78
    qu = nqu;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c"
static void tcp_broken_events___11(adns_state ads___7 ) 
{ 
  adns_query qu ;
  adns_query nqu ;

  {
#line 88
  if (! ((unsigned int )ads___7->tcpstate == 3U)) {
    {
#line 88
    __assert_fail("ads->tcpstate == server_broken", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c",
                  88U, "tcp_broken_events");
    }
  }
#line 89
  qu = ads___7->tcpw.head;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! qu) {
#line 89
      goto while_break;
    }
#line 90
    nqu = qu->next;
#line 91
    if (! ((unsigned int )qu->state == 1U)) {
      {
#line 91
      __assert_fail("qu->state == query_tcpw", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c",
                    91U, "tcp_broken_events");
      }
    }
#line 92
    if (qu->retries > ads___7->nservers) {
      {
#line 93
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 93
        if (qu->back) {
#line 93
          (qu->back)->next = qu->next;
        } else {
#line 93
          ads___7->tcpw.head = qu->next;
        }
#line 93
        if (qu->next) {
#line 93
          (qu->next)->back = qu->back;
        } else {
#line 93
          ads___7->tcpw.tail = qu->back;
        }
#line 93
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 94
      adns__query_fail(qu, (adns_status )31);
      }
    }
#line 89
    qu = nqu;
  }
  while_break: /* CIL Label */ ;
  }
#line 97
  ads___7->tcpstate = (enum adns__tcpstate )0;
#line 98
  return;
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c"
static void inter_immed___11(struct timeval **tv_io , struct timeval *tvbuf ) 
{ 
  struct timeval *rbuf ;
  __suseconds_t tmp ;

  {
#line 174
  if (! tv_io) {
#line 174
    return;
  }
#line 176
  rbuf = *tv_io;
#line 177
  if (! rbuf) {
#line 177
    rbuf = tvbuf;
#line 177
    *tv_io = rbuf;
  }
#line 179
  tmp = (__suseconds_t )0;
#line 179
  rbuf->tv_usec = tmp;
#line 179
  rbuf->tv_sec = tmp;
#line 180
  return;
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c"
static void inter_maxto___11(struct timeval **tv_io , struct timeval *tvbuf , struct timeval maxto ) 
{ 
  struct timeval *rbuf ;
  int tmp ;

  {
#line 186
  if (! tv_io) {
#line 186
    return;
  }
#line 187
  rbuf = *tv_io;
#line 188
  if (! rbuf) {
#line 189
    *tvbuf = maxto;
#line 189
    *tv_io = tvbuf;
  } else {
#line 191
    if (rbuf->tv_sec == maxto.tv_sec) {
#line 191
      tmp = rbuf->tv_usec > maxto.tv_usec;
    } else {
#line 191
      tmp = rbuf->tv_sec > maxto.tv_sec;
    }
#line 191
    if (tmp) {
#line 191
      *rbuf = maxto;
    }
  }
#line 195
  return;
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c"
static void inter_maxtoabs___11(struct timeval **tv_io , struct timeval *tvbuf , struct timeval now ,
                                struct timeval maxtime ) 
{ 
  ldiv_t dr ;

  {
#line 204
  if (! tv_io) {
#line 204
    return;
  }
  {
#line 205
  maxtime.tv_sec -= now.tv_sec + 2L;
#line 206
  maxtime.tv_usec -= now.tv_usec - 2000000L;
#line 207
  dr = ldiv(maxtime.tv_usec, 1000000L);
#line 208
  maxtime.tv_sec += dr.quot;
#line 209
  maxtime.tv_usec -= dr.quot * 1000000L;
  }
#line 210
  if (maxtime.tv_sec < 0L) {
#line 210
    maxtime.tv_usec = (__suseconds_t )0;
#line 210
    maxtime.tv_sec = maxtime.tv_usec;
  }
  {
#line 211
  inter_maxto___11(tv_io, tvbuf, maxtime);
  }
#line 212
  return;
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c"
static void timeouts_queue___11(adns_state ads___7 , int act , struct timeval **tv_io ,
                                struct timeval *tvbuf , struct timeval now , struct query_queue *queue ) 
{ 
  adns_query qu ;
  adns_query nqu ;
  int tmp ;

  {
#line 219
  qu = queue->head;
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if (! qu) {
#line 219
      goto while_break;
    }
#line 220
    nqu = qu->next;
#line 221
    if (now.tv_sec == qu->timeout.tv_sec) {
#line 221
      tmp = now.tv_usec > qu->timeout.tv_usec;
    } else {
#line 221
      tmp = now.tv_sec > qu->timeout.tv_sec;
    }
#line 221
    if (tmp) {
#line 224
      if (! act) {
        {
#line 224
        inter_immed___11(tv_io, tvbuf);
        }
#line 224
        return;
      }
      {
#line 225
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 225
        if (qu->back) {
#line 225
          (qu->back)->next = qu->next;
        } else {
#line 225
          queue->head = qu->next;
        }
#line 225
        if (qu->next) {
#line 225
          (qu->next)->back = qu->back;
        } else {
#line 225
          queue->tail = qu->back;
        }
#line 225
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 226
      if ((unsigned int )qu->state != 0U) {
        {
#line 227
        adns__query_fail(qu, (adns_status )30);
        }
      } else {
        {
#line 229
        adns__query_send(qu, now);
        }
      }
#line 231
      nqu = queue->head;
    } else {
      {
#line 222
      inter_maxtoabs___11(tv_io, tvbuf, now, qu->timeout);
      }
    }
#line 219
    qu = nqu;
  }
  while_break: /* CIL Label */ ;
  }
#line 234
  return;
}
}
#line 236 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c"
static void tcp_events___11(adns_state ads___7 , int act , struct timeval **tv_io ,
                            struct timeval *tvbuf , struct timeval now ) 
{ 
  int tmp ;

  {
  {
#line 239
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 241
    if ((unsigned int )ads___7->tcpstate == 3U) {
#line 241
      goto case_3;
    }
#line 244
    if ((unsigned int )ads___7->tcpstate == 0U) {
#line 244
      goto case_0;
    }
#line 249
    if ((unsigned int )ads___7->tcpstate == 2U) {
#line 249
      goto case_2;
    }
#line 256
    if ((unsigned int )ads___7->tcpstate == 1U) {
#line 256
      goto case_1;
    }
#line 275
    goto switch_default___0;
    case_3: /* CIL Label */ 
#line 242
    if (! act) {
      {
#line 242
      inter_immed___11(tv_io, tvbuf);
      }
#line 242
      return;
    }
    {
#line 243
    tcp_broken_events___11(ads___7);
    }
    case_0: /* CIL Label */ 
#line 245
    if (! ads___7->tcpw.head) {
#line 245
      return;
    }
#line 246
    if (! act) {
      {
#line 246
      inter_immed___11(tv_io, tvbuf);
      }
#line 246
      return;
    }
    {
#line 247
    adns__tcp_tryconnect(ads___7, now);
    }
#line 248
    goto switch_break;
    case_2: /* CIL Label */ 
#line 250
    if (ads___7->tcpw.head) {
#line 250
      return;
    }
#line 251
    if (! ads___7->tcptimeout.tv_sec) {
#line 252
      if (! (! ads___7->tcptimeout.tv_usec)) {
        {
#line 252
        __assert_fail("!ads->tcptimeout.tv_usec", "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c",
                      252U, "tcp_events");
        }
      }
      {
#line 253
      ads___7->tcptimeout = now;
#line 254
      timevaladd___18(& ads___7->tcptimeout, 30000L);
      }
    }
    case_1: /* CIL Label */ 
#line 257
    if (! act) {
      {
#line 258
      inter_maxtoabs___11(tv_io, tvbuf, now, ads___7->tcptimeout);
      }
#line 259
      return;
    } else {
#line 257
      if (now.tv_sec == ads___7->tcptimeout.tv_sec) {
#line 257
        tmp = now.tv_usec > ads___7->tcptimeout.tv_usec;
      } else {
#line 257
        tmp = now.tv_sec > ads___7->tcptimeout.tv_sec;
      }
#line 257
      if (! tmp) {
        {
#line 258
        inter_maxtoabs___11(tv_io, tvbuf, now, ads___7->tcptimeout);
        }
#line 259
        return;
      }
    }
    {
#line 263
    if ((unsigned int )ads___7->tcpstate == 1U) {
#line 263
      goto case_1___0;
    }
#line 266
    if ((unsigned int )ads___7->tcpstate == 2U) {
#line 266
      goto case_2___0;
    }
#line 270
    goto switch_default;
    case_1___0: /* CIL Label */ 
    {
#line 264
    adns__tcp_broken(ads___7, "unable to make connection", "timed out");
    }
#line 265
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 267
    tcp_close___11(ads___7);
#line 268
    ads___7->tcpstate = (enum adns__tcpstate )0;
    }
#line 269
    return;
    switch_default: /* CIL Label */ 
    {
#line 271
    abort();
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 274
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
#line 276
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 279
  return;
}
}
#line 516 "/home/june/repo/benchmarks/collector/temp/adns-1.4/dynamic/../src/event.c"
static void fd_event___11(adns_state ads___7 , int fd , int revent , int pollflag ,
                          int maxfd , fd_set const   *fds , int (*func)(adns_state  ,
                                                                        int fd , struct timeval  const  *now ) ,
                          struct timeval now , int *r_r ) 
{ 
  int r ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 524
  if (! (revent & pollflag)) {
#line 524
    return;
  }
#line 525
  if (fds) {
#line 525
    if (fd < maxfd) {
#line 525
      if (! ((fds->__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
#line 525
        return;
      }
    } else {
#line 525
      return;
    }
  }
  {
#line 526
  r = (*func)(ads___7, fd, (struct timeval  const  *)(& now));
  }
#line 527
  if (r) {
#line 528
    if (r_r) {
#line 529
      *r_r = r;
    } else {
      {
#line 531
      tmp = __errno_location();
#line 531
      tmp___0 = strerror(*tmp);
#line 531
      adns__diag(ads___7, -1, (adns_query )0, "process fd failed after select: %s",
                 tmp___0);
#line 533
      adns_globalsystemfailure(ads___7);
      }
    }
  }
#line 536
  return;
}
}
