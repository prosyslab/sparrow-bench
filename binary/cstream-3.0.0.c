/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 163 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt64_t;
#line 167 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt64_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_terminated_7 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_stopped_8 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_7 __wait_terminated ;
   struct __anonstruct___wait_stopped_8 __wait_stopped ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef int __sig_atomic_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_13 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_13 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 40 "/usr/include/signal.h"
typedef __sig_atomic_t sig_atomic_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_33 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_34 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_35 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_36 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_37 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_38 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_39 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_32 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_33 _kill ;
   struct __anonstruct__timer_34 _timer ;
   struct __anonstruct__rt_35 _rt ;
   struct __anonstruct__sigchld_36 _sigchld ;
   struct __anonstruct__sigfault_37 _sigfault ;
   struct __anonstruct__sigpoll_38 _sigpoll ;
   struct __anonstruct__sigsys_39 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_31 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_32 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_31 siginfo_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_51 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_51 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 107 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct itimerval {
   struct timeval it_interval ;
   struct timeval it_value ;
};
#line 120 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef int __itimer_which_t;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 36 "/usr/include/x86_64-linux-gnu/sys/poll.h"
typedef unsigned long nfds_t;
#line 39 "/usr/include/x86_64-linux-gnu/sys/poll.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 29 "/usr/include/x86_64-linux-gnu/bits/statvfs.h"
struct statvfs {
   unsigned long f_bsize ;
   unsigned long f_frsize ;
   __fsblkcnt64_t f_blocks ;
   __fsblkcnt64_t f_bfree ;
   __fsblkcnt64_t f_bavail ;
   __fsfilcnt64_t f_files ;
   __fsfilcnt64_t f_ffree ;
   __fsfilcnt64_t f_favail ;
   unsigned long f_fsid ;
   unsigned long f_flag ;
   unsigned long f_namemax ;
   int __f_spare[6] ;
};
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 90 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct sockaddr_in;
#line 90
struct sockaddr_in6;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 209 "/usr/include/netinet/in.h"
union __anonunion___in6_u_65 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 209 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_65 __in6_u ;
};
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 252 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 167 "/home/june/repo/benchmarks/collector/temp/cstream-3.0.0/cstream.c"
struct pmalloc {
   void *data ;
   void *allocated ;
   size_t n_bytes ;
};
#line 172 "/home/june/repo/benchmarks/collector/temp/cstream-3.0.0/cstream.c"
struct options {
   int v ;
   long long n ;
   int t ;
   char *i ;
   char *o ;
   char *I ;
   char *O ;
   char *p ;
   int l ;
   int B ;
   int c ;
   int w ;
   int S ;
   int T ;
   int user_specified_blocksize ;
   int six ;
};
#line 193 "/home/june/repo/benchmarks/collector/temp/cstream-3.0.0/cstream.c"
struct progstate {
   int b ;
   int ifd ;
   int ofd ;
   long long bytes_transferred ;
   int bytes_firsttransfer ;
   long long bytes_lastreport ;
   double starttime ;
   double lasttime ;
   double time_firsttransfer ;
   double time_lastreport ;
   long long n_lines ;
   int pidfile_has_been_created ;
   int pid ;
   int teefd ;
   int using_o_direct ;
   int using_o_direct_i ;
   struct pmalloc pmalloc ;
};
#line 341 "/home/june/repo/benchmarks/collector/temp/cstream-3.0.0/cstream.c"
struct soundoptions {
   int so_format ;
   int so_rate ;
   int so_stereo ;
};
#line 624 "/home/june/repo/benchmarks/collector/temp/cstream-3.0.0/cstream.c"
struct __anonstruct_it_66 {
   int (*func)(int  , struct sockaddr * , socklen_t * ) ;
   char *name ;
   char *text ;
};
#line 633 "/home/june/repo/benchmarks/collector/temp/cstream-3.0.0/cstream.c"
union __anonunion_un_67 {
   struct sockaddr sa ;
   char data[8192] ;
};
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 283
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 150
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 374
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 455
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1,2), __leaf__)) bcopy)(void const   *__src ,
                                                                                               void *__dest ,
                                                                                               size_t __n ) ;
#line 459
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1), __leaf__)) bzero)(void *__s ,
                                                                                             size_t __n ) ;
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 65 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sin)(double __x ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 417
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 460
extern int usleep(__useconds_t __useconds ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 978 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getpagesize)(void)  __attribute__((__const__)) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 215
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 131
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setitimer)(__itimer_which_t __which ,
                                                                                struct itimerval  const  * __restrict  __new ,
                                                                                struct itimerval * __restrict  __old ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 149 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...)  __asm__("open64")  ;
#line 217 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf )  __asm__("stat64")  ;
#line 350
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkfifo)(char const   *__path ,
                                                                                             __mode_t __mode ) ;
#line 102 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/poll.h"
extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout ) ;
#line 77 "/usr/include/x86_64-linux-gnu/sys/statvfs.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstatvfs)(int __fildes ,
                                                                                               struct statvfs *__buf )  __asm__("fstatvfs64")  ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  * __restrict  __addr ,
                                                                           socklen_t __len ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockname)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
#line 141
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getpeername)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 227 "/usr/include/netinet/in.h"
extern struct in6_addr  const  in6addr_any ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 34 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t ( __attribute__((__leaf__)) inet_addr)(char const   *__cp ) ;
#line 64
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) inet_ntop)(int __af ,
                                                                                          void const   * __restrict  __cp ,
                                                                                          char * __restrict  __buf ,
                                                                                          socklen_t __len ) ;
#line 92 "/usr/include/netdb.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) herror)(char const   *__str ) ;
#line 144
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 662
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 671
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) gai_strerror)(int __ecode ) ;
#line 677
extern int getnameinfo(struct sockaddr  const  * __restrict  __sa , socklen_t __salen ,
                       char * __restrict  __host , socklen_t __hostlen , char * __restrict  __serv ,
                       socklen_t __servlen , int __flags ) ;
#line 160 "/home/june/repo/benchmarks/collector/temp/cstream-3.0.0/cstream.c"
sig_atomic_t volatile   stopit  ;
#line 161 "/home/june/repo/benchmarks/collector/temp/cstream-3.0.0/cstream.c"
sig_atomic_t volatile   signal_report  ;
#line 162 "/home/june/repo/benchmarks/collector/temp/cstream-3.0.0/cstream.c"
sig_atomic_t volatile   n_sighups  ;
#line 163 "/home/june/repo/benchmarks/collector/temp/cstream-3.0.0/cstream.c"
int volatile   childpid  =    (sig_atomic_t volatile   )0;
#line 165 "/home/june/repo/benchmarks/collector/temp/cstream-3.0.0/cstream.c"
int pagesize  =    -1;
#line 191
void malloc_page_aligned(struct options  const  * const  o , struct pmalloc * const  pmalloc ) ;
#line 217 "/home/june/repo/benchmarks/collector/temp/cstream-3.0.0/cstream.c"
static void sigtimer(int const   signal___0 ) 
{ 


  {
#line 220
  signal_report = (sig_atomic_t volatile   )1;
#line 221
  return;
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/cstream-3.0.0/cstream.c"
static void sigshutdown(int const   signal___0 ) 
{ 


  {
#line 227
  stopit = (sig_atomic_t volatile   )1;
#line 228
  return;
}
}
#line 271 "/home/june/repo/benchmarks/collector/temp/cstream-3.0.0/cstream.c"
static void sigreport(int signal___0 ) 
{ 


  {
#line 274
  signal_report = (sig_atomic_t volatile   )1;
#line 275
  return;
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/cstream-3.0.0/cstream.c"
static void sighup(int signal___0 ) 
{ 
  int meh ;
  ssize_t tmp ;

  {
  {
#line 280
  tmp = write(2, (void const   *)"SIGHUP\n", sizeof("SIGHUP\n") - 1UL);
#line 280
  meh = (int )tmp;
#line 281
  n_sighups += (sig_atomic_t volatile   )1;
  }
#line 282
  return;
}
}
#line 285 "/home/june/repo/benchmarks/collector/temp/cstream-3.0.0/cstream.c"
static void handle_sighup(void) 
{ 
  __pid_t tmp ;

  {
  {
#line 288
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Received SIGHUP. If this is an error, send another one within 5 seconds\n");
#line 291
  n_sighups = (sig_atomic_t volatile   )1;
#line 292
  sleep(5U);
  }
#line 293
  if (n_sighups > (sig_atomic_t volatile   )1) {
    {
#line 294
    n_sighups = (sig_atomic_t volatile   )0;
#line 295
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Continuing\n");
    }
#line 296
    return;
  }
  {
#line 298
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Exiting...\n");
#line 299
  signal(1, (void (*)(int  ))0);
#line 300
  tmp = getpid();
#line 300
  kill(tmp, 1);
  }
#line 301
  return;
}
}
#line 304 "/home/june/repo/benchmarks/collector/temp/cstream-3.0.0/cstream.c"
static struct options *default_options(struct options * const  o ) 
{ 


  {
  {
#line 307
  bzero((void *)o, sizeof(struct options ));
  }
#line 308
  return ((struct options *)o);
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/cstream-3.0.0/cstream.c"
static void tsignal(int const   sig , void (* const  handler)(int  ) ) 
{ 
  struct sigaction sa ;
  int tmp ;

  {
  {
#line 317
  sa.__sigaction_handler.sa_handler = (void (*)(int  ))handler;
#line 318
  sigemptyset(& sa.sa_mask);
#line 319
  sa.sa_flags = 0;
#line 320
  tmp = sigaction((int )sig, (struct sigaction  const  */* __restrict  */)(& sa),
                  (struct sigaction */* __restrict  */)((void *)0));
  }
#line 320
  if (tmp == -1) {
    {
#line 321
    perror("sigaction");
#line 322
    exit(2);
    }
  }
#line 324
  return;
}
}
#line 364
extern int ( /* missing proto */  ioctl)() ;
#line 338 "/home/june/repo/benchmarks/collector/temp/cstream-3.0.0/cstream.c"
static void setaudio(int fd , char const   *spec ) 
{ 
  struct soundoptions so ;
  char *s ;
  long tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;

  {
  {
#line 341
  so.so_format = 16;
#line 341
  so.so_rate = 44100;
#line 341
  so.so_stereo = 1;
#line 353
  s = getenv("CSTREAM_AUDIO_BITRATE");
  }
#line 353
  if (s) {
    {
#line 354
    tmp = atol((char const   *)s);
#line 354
    so.so_rate = (int )tmp;
    }
  }
#line 357
  if ((unsigned long )spec == (unsigned long )((void *)0)) {
#line 358
    spec = "-";
  }
  {
#line 360
  tmp___0 = strchr(spec, ':');
  }
#line 360
  if (tmp___0) {
    {
#line 361
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: audio options will just be CD-quality settings.\nFilespec parsing not implemented\n");
    }
  }
  {
#line 364
  tmp___3 = ioctl(fd, (unsigned long )(((3U << 30) | (unsigned int )(80 << 8)) | 5U) | (sizeof(int ) << 16),
                  & so.so_format);
  }
#line 364
  if (tmp___3 == -1) {
    {
#line 365
    tmp___1 = __errno_location();
#line 365
    tmp___2 = strerror(*tmp___1);
#line 365
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"icotl SNDCTL_DSP_SETFMT for \'%s\' failed: \'%s\'\n",
            spec, tmp___2);
    }
  }
  {
#line 367
  tmp___6 = ioctl(fd, (unsigned long )(((3U << 30) | (unsigned int )(80 << 8)) | 3U) | (sizeof(int ) << 16),
                  & so.so_stereo);
  }
#line 367
  if (tmp___6 == -1) {
    {
#line 368
    tmp___4 = __errno_location();
#line 368
    tmp___5 = strerror(*tmp___4);
#line 368
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"icotl SNDCTL_DSP_STEREO for \'%s\' failed: \'%s\'\n",
            spec, tmp___5);
    }
  }
  {
#line 370
  tmp___9 = ioctl(fd, (unsigned long )(((3U << 30) | (unsigned int )(80 << 8)) | 2U) | (sizeof(int ) << 16),
                  & so.so_rate);
  }
#line 370
  if (tmp___9 == -1) {
    {
#line 371
    tmp___7 = __errno_location();
#line 371
    tmp___8 = strerror(*tmp___7);
#line 371
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"icotl SNDCTL_DSP_SPEED for \'%s\' failed: \'%s\'\n",
            spec, tmp___8);
    }
  }
#line 373
  return;
}
}
#line 393 "/home/june/repo/benchmarks/collector/temp/cstream-3.0.0/cstream.c"
static void print_inet(FILE * const  f , void const   * const  raw ) 
{ 
  unsigned char const   *c ;

  {
  {
#line 396
  c = (unsigned char const   *)raw;
#line 398
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d.%d.%d.%d",
          (int )*c, (int )*(c + 1), (int )*(c + 2), (int )*(c + 3));
  }
#line 400
  return;
}
}
#line 404 "/home/june/repo/benchmarks/collector/temp/cstream-3.0.0/cstream.c"
static int use_getaddrlen  =    1;
#line 409 "/home/june/repo/benchmarks/collector/temp/cstream-3.0.0/cstream.c"
int gimme_a_socket(int domain , int type , int protocol ) 
{ 
  int fd ;
  int i ;
  int tmp ;

  {
  {
#line 413
  fd = socket(domain, type, protocol);
  }
#line 413
  if (fd == -1) {
    {
#line 414
    perror("socket");
#line 415
    exit(2);
    }
  }
  {
#line 419
  i = 1;
#line 420
  tmp = setsockopt(fd, 1, 2, (void const   *)(& i), (socklen_t )sizeof(i));
  }
#line 420
  if (tmp == -1) {
    {
#line 421
    perror("setsockopt(REUSEADDR), [continuing]");
    }
  }
#line 424
  return (fd);
}
}
#line 427 "/home/june/repo/benchmarks/collector/temp/cstream-3.0.0/cstream.c"
static int open_tcp(struct options  const  * const  o , int mode ) 
{ 
  char *hostname ;
  char const   *port ;
  char const   *port_iterator ;
  char const   *spec ;
  int fd ;
  int newfd ;
  struct sockaddr *use_this_serv_addr ;
  socklen_t use_this_serv_addr_len ;
  char *tmp ;
  char *tmp___0 ;
  struct sockaddr_in serv_addr ;
  int tmp___1 ;
  struct sockaddr_in6 sin6 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  struct sockaddr addr_here ;
  socklen_t addr_here_size ;
  int *tmp___6 ;
  struct sockaddr_in serv_addr___0 ;
  int tmp___7 ;
  struct in_addr **a ;
  struct hostent *hostent ;
  char const   *tmp___8 ;
  struct addrinfo *result_begin ;
  struct addrinfo *result ;
  struct addrinfo hints ;
  int error ;
  char const   *tmp___9 ;
  char *msg ;
  char name[8192] ;
  char addr_string[46] ;
  char const   *tmp___10 ;
  int tmp___11 ;
  struct __anonstruct_it_66 *it ;
  struct __anonstruct_it_66 funcs[3] ;
  union __anonunion_un_67 un ;
  socklen_t len ;
  char hostname___0[8192] ;
  char service[8192] ;
  int tmp___12 ;

  {
#line 434
  fd = -1;
#line 435
  newfd = -1;
#line 436
  use_this_serv_addr = (struct sockaddr *)((void *)0);
#line 437
  use_this_serv_addr_len = (socklen_t )-1;
#line 439
  if (mode == 1) {
#line 440
    spec = (char const   *)o->o;
  } else {
#line 442
    spec = (char const   *)o->i;
  }
  {
#line 445
  port = (char const   *)((void *)0);
#line 446
  tmp = strchr(spec, ':');
#line 446
  port_iterator = (char const   *)tmp;
  }
  {
#line 446
  while (1) {
    while_continue: /* CIL Label */ ;
#line 446
    if (port_iterator) {
#line 446
      if (! *port_iterator) {
#line 446
        goto while_break;
      }
    } else {
#line 446
      goto while_break;
    }
    {
#line 449
    port = port_iterator;
#line 450
    port_iterator ++;
#line 446
    tmp___0 = strchr(port_iterator, ':');
#line 446
    port_iterator = (char const   *)tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 452
  port ++;
#line 453
  if ((unsigned long )port == (unsigned long )((void *)0)) {
    {
#line 454
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t find port in IP Spec \'%s\'\n",
            spec);
#line 455
    exit(1);
    }
  }
#line 459
  if ((int const   )*(spec + 1) != 0) {
#line 459
    if ((int const   )*(spec + 0) == 58) {
#line 459
      if ((int const   )*(spec + 1) != 58) {
#line 461
        if (o->six == -1) {
          {
#line 464
          use_this_serv_addr = (struct sockaddr *)(& serv_addr);
#line 465
          use_this_serv_addr_len = (socklen_t )sizeof(serv_addr);
#line 466
          bzero((void *)(& serv_addr), sizeof(serv_addr));
#line 467
          serv_addr.sin_family = (sa_family_t )2;
#line 468
          serv_addr.sin_addr.s_addr = (in_addr_t )0;
#line 469
          tmp___1 = atoi(port);
#line 469
          serv_addr.sin_port = htons((uint16_t )tmp___1);
#line 471
          fd = gimme_a_socket(2, 1, 0);
          }
        } else {
          {
#line 474
          bzero((void *)(& sin6), sizeof(sin6));
#line 475
          use_this_serv_addr = (struct sockaddr *)(& sin6);
#line 476
          use_this_serv_addr_len = (socklen_t )sizeof(sin6);
#line 478
          sin6.sin6_family = (sa_family_t )10;
#line 479
          sin6.sin6_flowinfo = (uint32_t )0;
#line 480
          tmp___2 = atoi(port);
#line 480
          sin6.sin6_port = htons((uint16_t )tmp___2);
#line 481
          sin6.sin6_addr = (struct in6_addr )in6addr_any;
#line 483
          fd = gimme_a_socket(10, 1, 0);
          }
        }
#line 485
        if (o->v > 1) {
#line 485
          if (o->six != -1) {
            {
#line 486
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bind in IPV6 mode\n");
            }
          }
        }
        {
#line 487
        tmp___3 = bind(fd, (struct sockaddr  const  */* __restrict  */)use_this_serv_addr,
                       use_this_serv_addr_len);
        }
#line 487
        if (tmp___3 == -1) {
          {
#line 489
          perror("bind");
#line 490
          exit(2);
          }
        }
        {
#line 493
        tmp___4 = listen(fd, 2);
        }
#line 493
        if (tmp___4 == -1) {
          {
#line 494
          perror("listen");
#line 495
          exit(2);
          }
        }
#line 498
        if (o->v >= 1) {
          {
#line 499
          tmp___5 = atoi(port);
#line 499
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Accepting on port %d\n",
                  tmp___5);
          }
        }
        {
#line 504
        newfd = accept(fd, (struct sockaddr */* __restrict  */)(& addr_here), (socklen_t */* __restrict  */)(& addr_here_size));
        }
#line 504
        if (newfd == -1) {
          {
#line 505
          tmp___6 = __errno_location();
#line 505
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"errno: %d\n",
                  *tmp___6);
#line 506
          perror("accept");
#line 507
          exit(2);
          }
        }
        {
#line 509
        close(fd);
#line 510
        fd = newfd;
        }
      } else {
#line 459
        goto _L___0;
      }
    } else {
#line 459
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 513
    hostname = strdup(spec);
#line 514
    *(hostname + ((port - spec) - 1L)) = (char )'\000';
    }
#line 516
    if (o->v >= 2) {
      {
#line 517
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Connecting to %s %s\n",
              hostname, port);
      }
    }
    {
#line 520
    use_this_serv_addr = (struct sockaddr *)(& serv_addr___0);
#line 521
    use_this_serv_addr_len = (socklen_t )sizeof(serv_addr___0);
#line 522
    bzero((void *)(& serv_addr___0), sizeof(serv_addr___0));
#line 523
    serv_addr___0.sin_family = (sa_family_t )2;
#line 524
    tmp___7 = atoi(port);
#line 524
    serv_addr___0.sin_port = htons((uint16_t )tmp___7);
#line 525
    serv_addr___0.sin_addr.s_addr = inet_addr((char const   *)hostname);
    }
#line 526
    if (serv_addr___0.sin_addr.s_addr != 4294967295U) {
      {
#line 528
      fd = gimme_a_socket(2, 1, 0);
      }
    } else {
#line 535
      if (o->v >= 2) {
        {
#line 536
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hostname lookup for \'%s\' use getaddrlen? %d\n",
                hostname, use_getaddrlen);
        }
      }
#line 538
      if (use_getaddrlen == 0) {
        {
#line 541
        hostent = gethostbyname((char const   *)hostname);
        }
#line 542
        if ((unsigned long )hostent == (unsigned long )((void *)0)) {
          {
#line 543
          herror((char const   *)hostname);
#line 544
          exit(2);
          }
        }
        {
#line 546
        a = (struct in_addr **)hostent->h_addr_list;
#line 547
        bcopy((void const   *)*a, (void *)(& serv_addr___0.sin_addr.s_addr), sizeof(struct in_addr ));
        }
#line 548
        if (o->v >= 2) {
#line 549
          if (hostent->h_addrtype == 2) {
#line 549
            tmp___8 = "ipv4";
          } else {
#line 549
            tmp___8 = "!ipv4";
          }
          {
#line 549
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannonical name %s, type %s, prim addr: ",
                  hostent->h_name, tmp___8);
#line 552
          print_inet((FILE */* const  */)stderr, (void const   */* const  */)(& serv_addr___0.sin_addr.s_addr));
#line 553
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
          }
        }
        {
#line 555
        fd = gimme_a_socket(2, 1, 0);
        }
      }
      {
#line 561
      bzero((void *)(& hints), sizeof(hints));
      }
      {
#line 563
      if (o->six == -1) {
#line 563
        goto case_neg_1;
      }
#line 564
      if (o->six == 2) {
#line 564
        goto case_2;
      }
#line 565
      goto switch_default;
      case_neg_1: /* CIL Label */ 
#line 563
      hints.ai_family = 2;
#line 563
      goto switch_break;
      case_2: /* CIL Label */ 
#line 564
      hints.ai_family = 10;
#line 564
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 566
      hints.ai_family = 0;
#line 566
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 568
      hints.ai_socktype = 1;
#line 570
      error = getaddrinfo((char const   */* __restrict  */)hostname, (char const   */* __restrict  */)port,
                          (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& result_begin));
      }
#line 571
      if (error) {
        {
#line 572
        tmp___9 = gai_strerror(error);
#line 572
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getaddrinfo: \'%s\'\n",
                tmp___9);
#line 573
        exit(3);
        }
      }
#line 575
      result = result_begin;
      {
#line 575
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 575
        if (! result) {
#line 575
          goto while_break___0;
        }
#line 576
        if (result->ai_addr) {
#line 577
          goto while_break___0;
        }
#line 575
        result = result->ai_next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 579
      if ((unsigned long )result == (unsigned long )((void *)0)) {
        {
#line 580
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"empty getaddrinfo() result for \'%s\'\n",
                hostname);
#line 581
        exit(3);
        }
      }
#line 583
      use_this_serv_addr = result->ai_addr;
#line 584
      use_this_serv_addr_len = result->ai_addrlen;
#line 586
      if (o->v > 1) {
        {
#line 589
        if (result->ai_family == 2) {
#line 589
          goto case_2___0;
        }
#line 590
        if (result->ai_family == 10) {
#line 590
          goto case_10;
        }
#line 591
        goto switch_default___0;
        case_2___0: /* CIL Label */ 
#line 589
        msg = (char *)"ipv4";
#line 589
        goto switch_break___0;
        case_10: /* CIL Label */ 
#line 590
        msg = (char *)"ipv6";
#line 590
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
#line 591
        msg = (char *)"not-IPv4/6";
#line 591
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
        {
#line 596
        getnameinfo((struct sockaddr  const  */* __restrict  */)use_this_serv_addr,
                    use_this_serv_addr_len, (char */* __restrict  */)(name), (socklen_t )sizeof(name),
                    (char */* __restrict  */)((void *)0), (socklen_t )0, 0);
#line 598
        tmp___10 = inet_ntop(result->ai_family, (void const   */* __restrict  */)(& use_this_serv_addr),
                             (char */* __restrict  */)(addr_string), use_this_serv_addr_len);
        }
#line 598
        if ((unsigned long )tmp___10 == (unsigned long )((void *)0)) {
          {
#line 600
          strcpy((char */* __restrict  */)(addr_string), (char const   */* __restrict  */)"unknown");
          }
        }
        {
#line 602
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannonical name \'%s\', type %s, prim addr: \'%s\'\n",
                name, msg, addr_string);
        }
      }
      {
#line 608
      fd = gimme_a_socket(result->ai_family, result->ai_socktype, result->ai_protocol);
      }
    }
    {
#line 613
    tmp___11 = connect(fd, (struct sockaddr  const  */* __restrict  */)use_this_serv_addr,
                       use_this_serv_addr_len);
    }
#line 613
    if (tmp___11 == -1) {
      {
#line 614
      perror("connect");
#line 615
      exit(2);
      }
    }
    {
#line 617
    free((void *)hostname);
    }
  }
#line 623
  if (o->v >= 2) {
#line 624
    funcs[0].func = (int (*)(int  , struct sockaddr * , socklen_t * ))(& getsockname);
#line 624
    funcs[0].name = (char *)"getsockname";
#line 624
    funcs[0].text = (char *)"Local binding";
#line 624
    funcs[1].func = (int (*)(int  , struct sockaddr * , socklen_t * ))(& getpeername);
#line 624
    funcs[1].name = (char *)"getpeername";
#line 624
    funcs[1].text = (char *)"Remote binding";
#line 624
    funcs[2].func = (int (*)(int  , struct sockaddr * , socklen_t * ))((void *)0);
#line 624
    funcs[2].name = (char *)0;
#line 624
    funcs[2].text = (char *)0;
#line 639
    len = (socklen_t )sizeof(un);
#line 640
    it = funcs;
    {
#line 640
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 640
      if (! it->func) {
#line 640
        goto while_break___1;
      }
      {
#line 643
      tmp___12 = (*(it->func))(fd, & un.sa, & len);
      }
#line 643
      if (tmp___12 == -1) {
        {
#line 644
        perror((char const   *)it->name);
#line 645
        exit(2);
        }
      }
      {
#line 647
      getnameinfo((struct sockaddr  const  */* __restrict  */)(& un.sa), len, (char */* __restrict  */)(hostname___0),
                  (socklen_t )sizeof(hostname___0), (char */* __restrict  */)(service),
                  (socklen_t )sizeof(service), 3);
#line 649
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s %s:%s\n",
              it->text, hostname___0, service);
#line 640
      it ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 653
  return (fd);
}
}
#line 657 "/home/june/repo/benchmarks/collector/temp/cstream-3.0.0/cstream.c"
int get_fs_blocksize(char const   * const  filename , int flags , int mode ) 
{ 
  struct statvfs statfs ;
  int fd ;
  int tmp ;

  {
  {
#line 663
  fd = open((char const   *)filename, flags, mode);
  }
#line 664
  if (fd == -1) {
    {
#line 665
    perror("Cannot open input file (to get block size)");
#line 666
    exit(2);
    }
  }
  {
#line 668
  tmp = fstatvfs(fd, & statfs);
  }
#line 668
  if (tmp == -1) {
    {
#line 669
    perror("Cannot get FS blocksize, you need to use -b<blocksize>\n");
#line 670
    exit(2);
    }
  }
  {
#line 672
  close(fd);
  }
#line 673
  return ((int )statfs.f_bsize);
}
}
#line 677 "/home/june/repo/benchmarks/collector/temp/cstream-3.0.0/cstream.c"
void open_output_file(struct options  const  * const  o , struct progstate * const  state ,
                      int flags ) 
{ 
  int mode ;
  char *tmp ;
  struct statvfs statfs ;
  int tmp___0 ;

  {
  {
#line 680
  mode = 438;
#line 682
  tmp = strchr((char const   *)o->O, 'S');
  }
#line 682
  if (tmp) {
#line 684
    flags |= 1052672;
#line 685
    if (o->v > 1) {
      {
#line 686
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Using O_SYNC on output file\n");
      }
    }
  }
#line 695
  if (state->using_o_direct) {
#line 696
    flags |= 16384;
#line 697
    if (o->v > 1) {
      {
#line 698
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Using O_DIRECT on output file with blocksize %d\n",
              state->b);
      }
    }
#line 702
    if (! o->user_specified_blocksize) {
      {
#line 719
      state->ofd = open((char const   *)o->o, flags, mode);
      }
#line 720
      if (state->ofd == -1) {
        {
#line 721
        perror("Cannot open output file (to get block size)");
#line 722
        exit(2);
        }
      }
      {
#line 724
      tmp___0 = fstatvfs(state->ofd, & statfs);
      }
#line 724
      if (tmp___0 == -1) {
        {
#line 725
        perror("Cannot get FS blocksize, you need to use -b<blocksize>\n");
#line 726
        exit(2);
        }
      }
      {
#line 728
      state->b = (int )statfs.f_bsize;
#line 729
      close(state->ofd);
      }
    }
  }
  {
#line 741
  state->ofd = open((char const   *)o->o, flags, mode);
  }
#line 742
  if (state->ofd == -1) {
    {
#line 743
    perror("Cannot open output file");
#line 744
    exit(2);
    }
  }
#line 746
  return;
}
}
#line 748 "/home/june/repo/benchmarks/collector/temp/cstream-3.0.0/cstream.c"
static void init(struct options * const  o , struct progstate * const  state , int const   blocksize ) 
{ 
  struct timeval t ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  ssize_t tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  FILE *f ;
  struct stat sb ;
  int tmp___15 ;
  int *tmp___16 ;
  __pid_t tmp___17 ;
  int tmp___18 ;

  {
  {
#line 754
  bzero((void *)state, sizeof(*state));
#line 756
  pagesize = getpagesize();
  }
#line 758
  if ((unsigned long )o->I == (unsigned long )((void *)0)) {
#line 759
    o->I = (char *)"";
  }
#line 760
  if ((unsigned long )o->O == (unsigned long )((void *)0)) {
#line 761
    o->O = (char *)"";
  }
  {
#line 763
  tmp = strchr((char const   *)o->O, 'D');
  }
#line 763
  if (tmp) {
#line 765
    state->using_o_direct = 1;
  }
#line 772
  if (blocksize == 0) {
#line 773
    state->b = 8192;
  } else {
#line 775
    state->b = (int )blocksize;
#line 776
    o->user_specified_blocksize = 1;
  }
#line 779
  if (state->b == 0) {
#line 780
    state->b = state->b;
  }
  {
#line 782
  tmp___0 = strchr((char const   *)o->I, 'D');
  }
#line 782
  if (tmp___0) {
#line 783
    state->using_o_direct_i = 1;
  }
#line 788
  if (o->w == 0) {
#line 789
    o->w = state->b;
  }
#line 791
  if (state->b < state->b) {
    {
#line 792
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-B must not be lower than -b or -n (%d/%d)\n",
            state->b, state->b);
#line 794
    exit(1);
    }
  }
#line 797
  if (o->c < 0) {
    {
#line 798
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-c must must be 0, 1, 2, 3 or 4\n");
#line 799
    exit(1);
    }
  } else
#line 797
  if (o->c > 4) {
    {
#line 798
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-c must must be 0, 1, 2, 3 or 4\n");
#line 799
    exit(1);
    }
  }
#line 802
  if ((unsigned long )o->i == (unsigned long )((void *)0)) {
#line 803
    state->ifd = 0;
  } else
#line 802
  if ((int )*(o->i + 0) == 0) {
#line 803
    state->ifd = 0;
  } else {
    {
#line 804
    tmp___5 = strcmp((char const   *)o->i, "-");
    }
#line 804
    if (tmp___5) {
      {
#line 807
      tmp___4 = strchr((char const   *)o->I, 'f');
      }
#line 807
      if (tmp___4) {
        {
#line 808
        unlink((char const   *)o->i);
#line 809
        tmp___1 = mkfifo((char const   *)o->i, (__mode_t )438);
        }
#line 809
        if (tmp___1 == -1) {
          {
#line 810
          perror("mkfifo() in");
#line 811
          exit(2);
          }
        }
        {
#line 813
        state->ifd = open((char const   *)o->i, 2);
        }
      } else {
        {
#line 816
        tmp___2 = strchr((char const   *)o->i, ':');
        }
#line 816
        if (tmp___2) {
          {
#line 816
          tmp___3 = strchr((char const   *)o->I, 'N');
          }
#line 816
          if (tmp___3) {
            {
#line 819
            state->ifd = open((char const   *)o->i, 0);
            }
          } else {
            {
#line 817
            state->ifd = open_tcp((struct options  const  */* const  */)o, 0);
            }
          }
        } else {
          {
#line 819
          state->ifd = open((char const   *)o->i, 0);
          }
        }
      }
#line 821
      if (state->ifd == -1) {
        {
#line 822
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open input file/tcpspec \'%s\': ",
                o->i);
#line 823
        perror((char const   *)((void *)0));
#line 824
        exit(2);
        }
      }
    } else {
#line 805
      state->ifd = -1;
    }
  }
  {
#line 828
  tmp___7 = strchr((char const   *)o->O, 't');
  }
#line 828
  if (tmp___7) {
    {
#line 829
    state->teefd = 3;
#line 830
    tmp___6 = write(state->teefd, (void const   *)"", (size_t )0);
    }
#line 830
    if (tmp___6 == -1L) {
      {
#line 831
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"stream copy to fd 3 requested, but fd3 is not open\n");
#line 832
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Use from shell like this:\n  cstream -O t 3> /tmp/file\n");
#line 834
      exit(1);
      }
    }
  } else {
#line 838
    state->teefd = -1;
  }
#line 840
  if ((unsigned long )o->o == (unsigned long )((void *)0)) {
#line 841
    state->ofd = 1;
  } else
#line 840
  if ((int )*(o->o + 0) == 0) {
#line 841
    state->ofd = 1;
  } else {
    {
#line 842
    tmp___12 = strcmp((char const   *)o->o, "-");
    }
#line 842
    if (tmp___12) {
      {
#line 845
      tmp___9 = strchr((char const   *)o->O, 'f');
      }
#line 845
      if (tmp___9) {
        {
#line 846
        unlink((char const   *)o->o);
#line 847
        tmp___8 = mkfifo((char const   *)o->o, (__mode_t )438);
        }
#line 847
        if (tmp___8 == -1) {
          {
#line 848
          perror("mkfifo() out");
#line 849
          exit(2);
          }
        }
      }
      {
#line 852
      tmp___10 = strchr((char const   *)o->o, ':');
      }
#line 852
      if (tmp___10) {
        {
#line 852
        tmp___11 = strchr((char const   *)o->O, 'N');
        }
#line 852
        if (tmp___11) {
          {
#line 855
          open_output_file((struct options  const  */* const  */)o, state, 578);
          }
        } else {
          {
#line 853
          state->ofd = open_tcp((struct options  const  */* const  */)o, 1);
          }
        }
      } else {
        {
#line 855
        open_output_file((struct options  const  */* const  */)o, state, 578);
        }
      }
    } else {
#line 843
      state->ofd = -1;
    }
  }
#line 859
  if (o->v >= 4) {
    {
#line 860
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Files are open at fd %d/%d\n",
            state->ifd, state->ofd);
    }
  }
  {
#line 862
  tmp___13 = strchr((char const   *)o->I, 'a');
  }
#line 862
  if (tmp___13) {
    {
#line 863
    setaudio(state->ifd, (char const   *)o->i);
    }
  }
  {
#line 864
  tmp___14 = strchr((char const   *)o->O, 'a');
  }
#line 864
  if (tmp___14) {
    {
#line 865
    setaudio(state->ofd, (char const   *)o->o);
    }
  }
#line 867
  if (o->c > 0) {
#line 867
    if (state->ofd == -1) {
      {
#line 868
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Do not use -c > 0 if you generate or sink data.\n");
#line 869
      exit(1);
      }
    } else
#line 867
    if (state->ifd == -1) {
      {
#line 868
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Do not use -c > 0 if you generate or sink data.\n");
#line 869
      exit(1);
      }
    }
  }
#line 872
  if (o->c == 4) {
#line 872
    if (o->t != 0) {
      {
#line 873
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-t not implemented for -c 4\n");
#line 874
      exit(1);
      }
    }
  }
#line 877
  state->pidfile_has_been_created = 0;
#line 878
  if (o->p) {
    {
#line 882
    tmp___15 = stat((char const   */* __restrict  */)o->p, (struct stat */* __restrict  */)(& sb));
    }
#line 882
    if (tmp___15 == -1) {
      {
#line 882
      tmp___16 = __errno_location();
      }
#line 882
      if (*tmp___16 == 2) {
#line 883
        state->pidfile_has_been_created = 1;
      }
    }
    {
#line 886
    f = fopen((char const   */* __restrict  */)o->p, (char const   */* __restrict  */)"w");
    }
#line 887
    if ((unsigned long )f == (unsigned long )((void *)0)) {
      {
#line 888
      perror("fopen()/write/pidfile failed");
#line 889
      exit(2);
      }
    }
    {
#line 891
    tmp___17 = getpid();
#line 891
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%d\n", tmp___17);
#line 892
    fclose(f);
    }
  }
#line 895
  state->bytes_transferred = 0LL;
#line 896
  if (o->l) {
#line 897
    state->n_lines = 0LL;
  }
  {
#line 899
  stopit = (sig_atomic_t volatile   )0;
#line 900
  signal_report = (sig_atomic_t volatile   )0;
#line 901
  n_sighups = (sig_atomic_t volatile   )0;
#line 903
  tsignal((int const   )12, (void (*/* const  */)(int  ))(& sigshutdown));
#line 907
  tsignal((int const   )10, (void (*/* const  */)(int  ))(& sigreport));
#line 914
  tsignal((int const   )1, (void (*/* const  */)(int  ))(& sighup));
#line 917
  state->bytes_firsttransfer = -1;
#line 918
  state->time_firsttransfer = - 1.0;
#line 920
  state->bytes_lastreport = -1LL;
#line 921
  state->time_lastreport = - 1.0;
#line 923
  tmp___18 = gettimeofday((struct timeval */* __restrict  */)(& t), (__timezone_ptr_t )((void *)0));
  }
#line 923
  if (tmp___18 == -1) {
    {
#line 924
    perror("gettimeofday() failed");
#line 925
    exit(2);
    }
  }
  {
#line 927
  state->starttime = (double )t.tv_sec + (double )t.tv_usec / 1000000.0;
#line 928
  state->lasttime = - 1.0;
#line 931
  state->pmalloc.n_bytes = (size_t )state->b;
#line 932
  malloc_page_aligned((struct options  const  *)o, & state->pmalloc);
  }
#line 933
  return;
}
}
#line 935 "/home/june/repo/benchmarks/collector/temp/cstream-3.0.0/cstream.c"
static void closefiles(struct progstate * const  state ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 938
  if (state->ofd != 1) {
#line 938
    if (state->ofd != 2) {
#line 938
      if (state->ofd != -1) {
        {
#line 939
        tmp = close(state->ofd);
        }
#line 939
        if (tmp == -1) {
          {
#line 940
          perror("Cannot close outfile");
          }
        }
      }
    }
  }
#line 942
  if (state->ifd != 0) {
#line 942
    if (state->ifd != -1) {
      {
#line 943
      tmp___0 = close(state->ifd);
      }
#line 943
      if (tmp___0 == -1) {
        {
#line 944
        perror("Cannot close infile");
        }
      }
    }
  }
#line 946
  return;
}
}
#line 949 "/home/june/repo/benchmarks/collector/temp/cstream-3.0.0/cstream.c"
static void print_kmg(char const   * const  pre , char const   * const  format , double const   num ,
                      char const   * const  post , FILE * const  f ) 
{ 


  {
#line 954
  if ((unsigned long )pre != (unsigned long )((void *)0)) {
    {
#line 955
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s", pre);
    }
  }
#line 956
  if (num >= (double const   )1000000000.0) {
    {
#line 957
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)format, ((num / (double const   )1024.0) / (double const   )1024.0) / (double const   )1024.0);
#line 958
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" G");
    }
  } else
#line 959
  if (num >= (double const   )1000000.0) {
    {
#line 960
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)format, (num / (double const   )1024.0) / (double const   )1024.0);
#line 961
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" M");
    }
  } else
#line 962
  if (num >= (double const   )1000.0) {
    {
#line 963
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)format, num / (double const   )1024.0);
#line 964
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" K");
    }
  } else {
    {
#line 966
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)format, num);
#line 967
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" ");
    }
  }
#line 969
  if ((unsigned long )post != (unsigned long )((void *)0)) {
    {
#line 970
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s", post);
    }
  }
#line 971
  return;
}
}
#line 973 "/home/june/repo/benchmarks/collector/temp/cstream-3.0.0/cstream.c"
static void report(struct options  const  * const  o , struct progstate * const  state ,
                   int curbytes ) 
{ 
  struct timeval t2 ;
  double sofar ;
  double rate ;
  struct itimerval itv ;
  int tmp ;

  {
  {
#line 985
  tmp = gettimeofday((struct timeval */* __restrict  */)(& t2), (__timezone_ptr_t )((void *)0));
  }
#line 985
  if (tmp == -1) {
    {
#line 986
    perror("gettimeofday() failed");
#line 987
    exit(2);
    }
  }
#line 989
  sofar = ((double )t2.tv_sec + (double )t2.tv_usec / 1000000.0) - state->starttime;
#line 991
  if (sofar > (double )0) {
#line 992
    rate = (double )state->bytes_transferred / sofar;
  } else {
#line 994
    rate = 0.0;
  }
  {
#line 995
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%.0f B",
          (double )state->bytes_transferred);
#line 996
  print_kmg((char const   */* const  */)" ", (char const   */* const  */)"%.1f", (double const   )((double )state->bytes_transferred),
            (char const   */* const  */)"B", (FILE */* const  */)stderr);
  }
#line 997
  if (sofar < 200.0) {
    {
#line 998
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %.2f s",
            sofar);
    }
  } else {
    {
#line 1000
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %.1f s",
            sofar);
    }
#line 1001
    if (sofar >= 3600.0) {
      {
#line 1002
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" (%d:%02d h)",
              (int )sofar / 3600, ((int )sofar % 3600) / 60);
      }
    } else {
      {
#line 1004
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" (%d:%02d min)",
              (int )sofar / 60, (int )sofar % 60);
      }
    }
  }
  {
#line 1006
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %.0f B/s",
          rate);
#line 1007
  print_kmg((char const   */* const  */)" ", (char const   */* const  */)"%.2f", (double const   )rate,
            (char const   */* const  */)"B/s", (FILE */* const  */)stderr);
  }
#line 1008
  if (o->l) {
    {
#line 1009
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %g lines",
            (double )state->n_lines);
    }
  }
#line 1010
  if (curbytes != -1) {
#line 1010
    if (state->b != state->b) {
      {
#line 1011
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %.1f %%buf",
              ((double )curbytes / (double )state->b) * 100.0);
      }
    }
  }
  {
#line 1012
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 1014
  if (o->v >= 2) {
#line 1014
    if (sofar - state->time_firsttransfer > 0.0) {
      {
#line 1015
      rate = ((double )state->bytes_transferred - (double )state->bytes_firsttransfer) / (sofar - state->time_firsttransfer);
#line 1019
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Since end of first transfer: %.0f B/s",
              rate);
#line 1020
      print_kmg((char const   */* const  */)" ", (char const   */* const  */)"%.2f",
                (double const   )rate, (char const   */* const  */)"B/s", (FILE */* const  */)stderr);
#line 1021
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
#line 1023
      if (state->bytes_lastreport != -1LL) {
        {
#line 1024
        rate = ((double )state->bytes_transferred - (double )state->bytes_lastreport) / (sofar - state->time_lastreport);
#line 1028
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Since last report          : %.0f B/s",
                rate);
#line 1029
        print_kmg((char const   */* const  */)" ", (char const   */* const  */)"%.2f",
                  (double const   )rate, (char const   */* const  */)"B/s", (FILE */* const  */)stderr);
#line 1030
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
        }
      }
    }
  }
#line 1034
  state->bytes_lastreport = state->bytes_transferred;
#line 1035
  state->time_lastreport = sofar;
#line 1037
  if (o->T) {
    {
#line 1039
    itv.it_interval.tv_sec = (__time_t )o->T;
#line 1040
    itv.it_interval.tv_usec = (__suseconds_t )0;
#line 1041
    itv.it_value.tv_sec = (__time_t )o->T;
#line 1042
    itv.it_value.tv_usec = (__suseconds_t )0;
#line 1043
    setitimer(0, (struct itimerval  const  */* __restrict  */)(& itv), (struct itimerval */* __restrict  */)((void *)0));
    }
  }
#line 1048
  return;
}
}
#line 1054
int my_write(struct options  const  * const  o , struct progstate * const  state ,
             void const   *buf , size_t const   n_bytes ) ;
#line 1054 "/home/june/repo/benchmarks/collector/temp/cstream-3.0.0/cstream.c"
static int warning_printed  =    0;
#line 1050 "/home/june/repo/benchmarks/collector/temp/cstream-3.0.0/cstream.c"
int my_write(struct options  const  * const  o , struct progstate * const  state ,
             void const   *buf , size_t const   n_bytes ) 
{ 
  int ret ;
  ssize_t tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;
  int *tmp___3 ;

  {
#line 1056
  if (state->using_o_direct) {
#line 1056
    if ((long )buf % (long )pagesize != 0L) {
#line 1057
      if (warning_printed == 0) {
        {
#line 1058
        warning_printed = 1;
#line 1059
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Write from buffer not page aligned, copying data\n");
        }
      }
#line 1061
      if (state->pmalloc.n_bytes < (size_t )n_bytes) {
        {
#line 1062
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Target buffer too small, reallocating\n");
#line 1063
        free(state->pmalloc.allocated);
#line 1064
        state->pmalloc.n_bytes = (size_t )n_bytes;
#line 1065
        malloc_page_aligned((struct options  const  *)o, & state->pmalloc);
        }
      }
      {
#line 1067
      memcpy((void */* __restrict  */)state->pmalloc.data, (void const   */* __restrict  */)buf,
             (size_t )n_bytes);
#line 1068
      buf = (void const   *)state->pmalloc.data;
      }
    }
  }
  {
#line 1071
  tmp = write(state->ofd, buf, (size_t )n_bytes);
#line 1071
  ret = (int )tmp;
  }
#line 1072
  if (ret != -1) {
#line 1073
    return (ret);
  }
  {
#line 1078
  tmp___0 = __errno_location();
  }
#line 1078
  if (*tmp___0 == 4) {
#line 1079
    return (0);
  }
#line 1082
  if (state->using_o_direct) {
#line 1083
    if (o->v > 0) {
      {
#line 1084
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Write of %llu bytes failed at %p (%lld) (normal), reopening without O_DIRECT\n",
              (unsigned long long )n_bytes, buf, (long long )((long )buf) % (long long )pagesize);
      }
    }
    {
#line 1088
    tmp___1 = close(state->ofd);
    }
#line 1088
    if (tmp___1 == -1) {
      {
#line 1089
      perror("Cannot close output file\n");
#line 1090
      exit(2);
      }
    }
    {
#line 1092
    state->using_o_direct = 0;
#line 1093
    open_output_file(o, state, 1026);
    }
  }
  {
#line 1096
  tmp___2 = write(state->ofd, buf, (size_t )n_bytes);
#line 1096
  ret = (int )tmp___2;
  }
#line 1097
  if (ret != -1) {
#line 1098
    return (ret);
  }
  {
#line 1100
  tmp___3 = __errno_location();
  }
#line 1100
  if (*tmp___3 == 4) {
#line 1101
    return (0);
  }
  {
#line 1103
  report(o, state, -1);
#line 1104
  perror("write");
#line 1105
  exit(2);
  }
}
}
#line 1108 "/home/june/repo/benchmarks/collector/temp/cstream-3.0.0/cstream.c"
void malloc_page_aligned(struct options  const  * const  o , struct pmalloc * const  pmalloc ) 
{ 


  {
  {
#line 1112
  pmalloc->allocated = malloc(pmalloc->n_bytes + (size_t )pagesize);
  }
#line 1114
  if ((unsigned long )pmalloc->allocated == (unsigned long )((void *)0)) {
    {
#line 1115
    perror("malloc");
#line 1116
    exit(2);
    }
  }
#line 1119
  pmalloc->data = (pmalloc->allocated + pagesize) - (long )pmalloc->allocated % (long )pagesize;
#line 1122
  if (o->v >= 4) {
    {
#line 1123
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Page-aligned malloc at %p -> %p\n",
            pmalloc->allocated, pmalloc->data);
    }
  }
#line 1127
  return;
}
}
#line 1130 "/home/june/repo/benchmarks/collector/temp/cstream-3.0.0/cstream.c"
static void pollloop(struct options  const  * const  o , struct progstate * const  state ) 
{ 
  char *buf ;
  char *curread ;
  char *curwrite ;
  int ret ;
  struct pollfd pollfd[2] ;
  struct pollfd *pfd ;
  int want_to_read ;
  int want_to_write ;
  struct pmalloc palloc ;
  int *tmp ;
  int nbytes ;
  ssize_t tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1143
  palloc.n_bytes = (size_t )state->b;
#line 1144
  malloc_page_aligned(o, (struct pmalloc */* const  */)(& palloc));
#line 1145
  buf = (char *)palloc.data;
#line 1147
  pollfd[0].fd = state->ifd;
#line 1148
  pollfd[0].events = (short)65;
#line 1149
  pollfd[1].fd = state->ofd;
#line 1150
  pollfd[1].events = (short)260;
#line 1151
  curwrite = buf;
#line 1151
  curread = curwrite;
#line 1153
  ret = -1;
  }
  {
#line 1154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1154
    if (! (stopit == (sig_atomic_t volatile   )0)) {
#line 1154
      goto while_break;
    }
#line 1155
    want_to_write = 0;
#line 1155
    want_to_read = want_to_write;
#line 1158
    if ((unsigned long )curwrite < (unsigned long )curread) {
#line 1159
      want_to_write = 1;
    }
#line 1162
    if (curread - buf <= (long )(state->b - state->b)) {
#line 1166
      want_to_read = 1;
    } else
#line 1174
    if ((unsigned long )curwrite == (unsigned long )curread) {
#line 1175
      curwrite = buf;
#line 1175
      curread = curwrite;
#line 1176
      want_to_read = 1;
    }
#line 1180
    if (want_to_read) {
#line 1181
      pfd = pollfd;
    } else {
#line 1183
      pfd = pollfd + 1;
    }
#line 1185
    if (o->v >= 4) {
      {
#line 1186
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Polling, want_to_read %d want_to_write %d\n",
              want_to_read, want_to_write);
      }
    }
    {
#line 1188
    ret = poll(pfd, (nfds_t )(want_to_read + want_to_write), -1);
    }
#line 1189
    if (ret == -1) {
      {
#line 1190
      tmp = __errno_location();
      }
#line 1190
      if (*tmp == 4) {
#line 1191
        goto while_continue;
      }
      {
#line 1192
      perror("poll");
#line 1193
      exit(2);
      }
    }
#line 1195
    if (o->v >= 4) {
      {
#line 1196
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Poll returned %d\n",
              ret);
      }
    }
#line 1198
    if (want_to_write) {
#line 1198
      if ((int )pollfd[1].revents & 260) {
#line 1201
        if ((long )o->w <= curread - curwrite) {
#line 1202
          nbytes = (int )o->w;
        } else {
#line 1204
          nbytes = (int )(curread - curwrite);
        }
#line 1206
        if (o->v >= 4) {
          {
#line 1207
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Trying to write %d bytes (1)\n",
                  nbytes);
          }
        }
        {
#line 1208
        ret = my_write(o, state, (void const   *)curwrite, (size_t const   )nbytes);
        }
#line 1209
        if (o->v >= 4) {
          {
#line 1210
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrote %d bytes\n",
                  ret);
          }
        }
#line 1211
        curwrite += ret;
      }
    }
#line 1214
    if (want_to_read) {
#line 1214
      if ((int )pollfd[0].revents & 65) {
#line 1215
        if (o->v >= 4) {
          {
#line 1216
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Trying to read\n");
          }
        }
#line 1218
        if (o->n) {
#line 1218
          if (state->bytes_transferred + (long long )state->b > (long long )o->n) {
            {
#line 1219
            tmp___0 = read(state->ifd, (void *)curread, (size_t )(o->n - (long long const   )state->bytes_transferred));
#line 1219
            ret = (int )tmp___0;
            }
          } else {
            {
#line 1221
            tmp___1 = read(state->ifd, (void *)curread, (size_t )state->b);
#line 1221
            ret = (int )tmp___1;
            }
          }
        } else {
          {
#line 1221
          tmp___1 = read(state->ifd, (void *)curread, (size_t )state->b);
#line 1221
          ret = (int )tmp___1;
          }
        }
#line 1223
        if (ret == -1) {
          {
#line 1224
          tmp___2 = __errno_location();
          }
#line 1224
          if (*tmp___2 == 4) {
#line 1225
            goto while_continue;
          }
          {
#line 1226
          perror("read");
#line 1227
          exit(2);
          }
        }
#line 1229
        if (o->v >= 4) {
          {
#line 1230
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Read %d bytes\n",
                  ret);
          }
        }
#line 1231
        curread += ret;
#line 1232
        state->bytes_transferred += (long long )ret;
      }
    }
#line 1234
    if (signal_report) {
      {
#line 1235
      report(o, state, (int )(curread - buf));
#line 1236
      signal_report = (sig_atomic_t volatile   )0;
      }
    }
#line 1238
    if (n_sighups > (sig_atomic_t volatile   )0) {
      {
#line 1239
      handle_sighup();
      }
    }
#line 1241
    if (want_to_read) {
#line 1241
      if (ret == 0) {
#line 1241
        goto _L;
      } else {
#line 1241
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1241
    if (o->n == (long long const   )state->bytes_transferred) {
      _L: /* CIL Label */ 
#line 1241
      if ((unsigned long )curwrite == (unsigned long )curread) {
#line 1244
        if (o->v > 1) {
#line 1245
          if (childpid) {
#line 1245
            tmp___3 = 1;
          } else {
#line 1245
            tmp___3 = 0;
          }
          {
#line 1245
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"#%dfinishing on condition 1\n",
                  tmp___3);
          }
        }
#line 1247
        stopit = (sig_atomic_t volatile   )1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1250
  if (o->v >= 1) {
    {
#line 1251
    report(o, state, -1);
    }
  }
  {
#line 1253
  closefiles(state);
#line 1255
  free(palloc.allocated);
  }
#line 1256
  return;
}
}
#line 1259 "/home/june/repo/benchmarks/collector/temp/cstream-3.0.0/cstream.c"
static void loop(struct options * const  o , struct progstate * const  state ) 
{ 
  char *buf ;
  char *curbuf ;
  char *curbuf2 ;
  int nbytes ;
  long long bytes_read ;
  int pipefd[2] ;
  struct pmalloc palloc ;
  int tmp ;
  __pid_t tmp___0 ;
  int i ;
  int tmp___1 ;
  int i___0 ;
  double rate ;
  double freq ;
  double pi ;
  int frames ;
  unsigned short val ;
  int tmp___2 ;
  double tmp___3 ;
  char tmp___4 ;
  char tmp___5 ;
  char *tmp___6 ;
  struct timeval t2 ;
  double sofar ;
  double theory ;
  double time_to_sleep ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  ssize_t tmp___10 ;
  int tmp___11 ;
  ssize_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  char *s ;
  int n ;
  int tmp___16 ;
  ssize_t tmp___17 ;
  ssize_t tmp___18 ;
  int *tmp___19 ;
  int tmp___20 ;
  struct timeval t ;
  int tmp___21 ;
  int tmp___22 ;

  {
  {
#line 1266
  nbytes = 0;
#line 1267
  bytes_read = 0LL;
#line 1271
  state->pid = getpid();
  }
#line 1272
  if (o->c > 0) {
    {
#line 1273
    tmp = pipe((int *)(pipefd));
    }
#line 1273
    if (tmp == -1) {
      {
#line 1274
      perror("pipe");
#line 1275
      exit(3);
      }
    }
    {
#line 1277
    tmp___0 = fork();
#line 1277
    childpid = (int volatile   )tmp___0;
    }
#line 1278
    if (childpid == (int volatile   )-1) {
      {
#line 1279
      perror("fork");
#line 1280
      exit(3);
      }
    }
#line 1282
    if (childpid == (int volatile   )0) {
      {
#line 1284
      state->pid = getpid();
#line 1287
      close(pipefd[1]);
#line 1288
      state->ifd = pipefd[0];
      }
    } else {
#line 1295
      if (o->v >= 4) {
        {
#line 1296
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Child has pid (%d)\n",
                state->pid);
        }
      }
      {
#line 1299
      close(pipefd[0]);
#line 1300
      state->ofd = pipefd[1];
      }
    }
  }
#line 1304
  if (o->c == 1) {
#line 1305
    if (childpid == (int volatile   )0) {
#line 1306
      state->b = state->b;
    }
  } else
#line 1308
  if (o->c == 2) {
#line 1309
    if (childpid != (int volatile   )0) {
#line 1310
      state->b = state->b;
    }
  }
  {
#line 1314
  palloc.n_bytes = (size_t )state->b;
#line 1315
  malloc_page_aligned((struct options  const  */* const  */)o, (struct pmalloc */* const  */)(& palloc));
#line 1316
  buf = (char *)palloc.data;
  }
#line 1318
  if (o->c == 0) {
#line 1318
    goto _L;
  } else
#line 1318
  if (childpid != (int volatile   )0) {
    _L: /* CIL Label */ 
#line 1319
    if (state->ifd == -1) {
      {
#line 1325
      tmp___6 = strchr((char const   *)o->O, 'a');
      }
#line 1325
      if (tmp___6) {
#line 1343
        rate = 44100.0;
#line 1344
        freq = 440.0;
#line 1345
        pi = 3.141592653589793;
#line 1346
        frames = (int )(rate / freq);
#line 1349
        if ((frames * 2) * 2 > state->b) {
          {
#line 1350
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Blocksize too small for wave\n");
#line 1351
          exit(1);
          }
        }
#line 1354
        tmp___2 = (frames * 2) * 2;
#line 1354
        state->b = tmp___2;
#line 1354
        state->b = tmp___2;
#line 1355
        i___0 = 0;
        {
#line 1355
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1355
          if (! (i___0 < frames)) {
#line 1355
            goto while_break;
          }
          {
#line 1356
          tmp___3 = sin((((double )i___0 * 2.0) * pi) / (double )frames);
#line 1356
          val = (unsigned short )(tmp___3 * 32767.0);
#line 1357
          tmp___4 = (char )((int )val % 256);
#line 1357
          *(buf + (i___0 * 4 + 2)) = tmp___4;
#line 1357
          *(buf + i___0 * 4) = tmp___4;
#line 1358
          tmp___5 = (char )((int )val / 256);
#line 1358
          *(buf + (i___0 * 4 + 3)) = tmp___5;
#line 1358
          *(buf + (i___0 * 4 + 1)) = tmp___5;
#line 1355
          i___0 ++;
          }
        }
        while_break: /* CIL Label */ ;
        }
      } else {
#line 1329
        i = 0;
        {
#line 1329
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1329
          if (! (i < state->b)) {
#line 1329
            goto while_break___0;
          }
#line 1331
          if ((i + 1) % 76 == 0) {
#line 1332
            *(buf + i) = (char )'\n';
          } else
#line 1331
          if ((long long )i == o->n - 1LL) {
#line 1332
            *(buf + i) = (char )'\n';
          } else {
            {
#line 1334
            tmp___1 = rand();
#line 1334
            *(buf + i) = (char )(65 + tmp___1 % 26);
            }
          }
#line 1329
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
  } else {
    {
#line 1365
    signal(10, (void (*)(int  ))0);
#line 1371
    signal(1, (void (*)(int  ))0);
    }
  }
  {
#line 1376
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1376
    if (! (stopit == (sig_atomic_t volatile   )0)) {
#line 1376
      goto while_break___1;
    }
#line 1379
    curbuf = buf;
    {
#line 1379
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1379
      if (stopit == (sig_atomic_t volatile   )0) {
#line 1379
        if (! ((unsigned long )(curbuf + state->b) <= (unsigned long )(buf + state->b))) {
#line 1379
          goto while_break___2;
        }
      } else {
#line 1379
        goto while_break___2;
      }
#line 1388
      if (o->t != 0) {
#line 1388
        if (o->c > 0) {
#line 1388
          if (! (childpid == (int volatile   )0)) {
#line 1388
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 1388
        if (bytes_read > 0LL) {
          {
#line 1394
          tmp___7 = gettimeofday((struct timeval */* __restrict  */)(& t2), (__timezone_ptr_t )((void *)0));
          }
#line 1394
          if (tmp___7 == -1) {
            {
#line 1395
            perror("gettimeofday() failed");
#line 1396
            exit(2);
            }
          }
#line 1399
          if (o->t > 0) {
#line 1402
            sofar = ((double )t2.tv_sec + (double )t2.tv_usec / 1000000.0) - state->starttime;
#line 1406
            theory = (double )bytes_read / (double )o->t;
#line 1407
            if (o->v >= 4) {
              {
#line 1408
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"We needed %g seconds, should be %g\n",
                      sofar, theory);
              }
            }
#line 1410
            if (sofar < theory) {
              {
#line 1411
              usleep((__useconds_t )((theory - sofar) * 1000000.0));
              }
            }
          } else {
#line 1414
            sofar = ((double )t2.tv_sec + (double )t2.tv_usec / 1000000.0) - state->lasttime;
#line 1419
            theory = (double )state->b / (double )(- o->t);
#line 1421
            time_to_sleep = (theory - sofar) * 1000000.0;
#line 1422
            if (o->v >= 4) {
              {
#line 1423
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"We needed %g seconds for %d bytes, should be %g, sleeping %g\n",
                      sofar, state->b, theory, time_to_sleep);
              }
            }
#line 1427
            state->lasttime = (double )t2.tv_sec + (double )t2.tv_usec / 1000000.0;
#line 1430
            if (sofar < theory) {
              {
#line 1431
              usleep((__useconds_t )time_to_sleep);
#line 1432
              state->lasttime += time_to_sleep / 1000000.0;
              }
            }
          }
        }
      }
#line 1439
      if (state->ifd == -1) {
#line 1441
        if (o->n) {
#line 1441
          if (bytes_read + (long long )state->b > o->n) {
#line 1442
            nbytes = (int )(o->n - bytes_read);
#line 1443
            if (o->v > 1) {
#line 1444
              if (childpid) {
#line 1444
                tmp___8 = 1;
              } else {
#line 1444
                tmp___8 = 0;
              }
              {
#line 1444
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"#%d finishing on condition 3\n",
                      tmp___8);
              }
            }
#line 1446
            stopit = (sig_atomic_t volatile   )1;
          } else {
#line 1449
            nbytes = state->b;
          }
        } else {
#line 1449
          nbytes = state->b;
        }
      } else {
#line 1451
        if (o->v >= 4) {
#line 1452
          if (childpid) {
#line 1452
            tmp___9 = 1;
          } else {
#line 1452
            tmp___9 = 0;
          }
          {
#line 1452
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"#%d trying to read %d bytes\n",
                  tmp___9, state->b);
          }
        }
#line 1455
        if (o->n) {
#line 1455
          if (bytes_read + (long long )state->b > o->n) {
            {
#line 1456
            tmp___10 = read(state->ifd, (void *)curbuf, (size_t )(o->n - bytes_read));
#line 1456
            nbytes = (int )tmp___10;
            }
#line 1457
            if (o->v > 1) {
#line 1458
              if (childpid) {
#line 1458
                tmp___11 = 1;
              } else {
#line 1458
                tmp___11 = 0;
              }
              {
#line 1458
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"#%d finishing on condition 4\n",
                      tmp___11);
              }
            }
#line 1460
            stopit = (sig_atomic_t volatile   )1;
          } else {
            {
#line 1463
            tmp___12 = read(state->ifd, (void *)curbuf, (size_t )state->b);
#line 1463
            nbytes = (int )tmp___12;
            }
          }
        } else {
          {
#line 1463
          tmp___12 = read(state->ifd, (void *)curbuf, (size_t )state->b);
#line 1463
          nbytes = (int )tmp___12;
          }
        }
#line 1465
        if (o->v >= 4) {
#line 1466
          if (childpid) {
#line 1466
            tmp___13 = 1;
          } else {
#line 1466
            tmp___13 = 0;
          }
          {
#line 1466
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"#%d read %d bytes\n",
                  tmp___13, nbytes);
          }
        }
#line 1467
        if (nbytes == 0) {
#line 1468
          if (o->v > 1) {
#line 1469
            if (childpid) {
#line 1469
              tmp___14 = 1;
            } else {
#line 1469
              tmp___14 = 0;
            }
            {
#line 1469
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"#%d finishing on condition 1\n",
                    tmp___14);
            }
          }
#line 1471
          stopit = (sig_atomic_t volatile   )1;
        }
#line 1474
        if (nbytes == -1) {
          {
#line 1475
          tmp___15 = __errno_location();
          }
#line 1475
          if (*tmp___15 == 4) {
#line 1476
            nbytes = 0;
          } else {
            {
#line 1478
            perror("read() failed");
#line 1479
            report((struct options  const  */* const  */)o, state, -1);
#line 1480
            exit(2);
            }
          }
        }
      }
#line 1484
      if (signal_report) {
        {
#line 1485
        report((struct options  const  */* const  */)o, state, (int )(curbuf - buf));
#line 1486
        signal_report = (sig_atomic_t volatile   )0;
        }
      }
#line 1488
      if (n_sighups > (sig_atomic_t volatile   )0) {
        {
#line 1489
        handle_sighup();
        }
      }
#line 1379
      curbuf += nbytes;
#line 1379
      bytes_read += (long long )nbytes;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1494
    if (o->l) {
#line 1497
      s = buf;
      {
#line 1497
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1497
        if (! ((unsigned long )s < (unsigned long )curbuf)) {
#line 1497
          goto while_break___3;
        }
#line 1498
        if ((int )*s == 10) {
#line 1499
          (state->n_lines) ++;
        }
#line 1497
        s ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 1505
    curbuf2 = buf;
    {
#line 1505
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1505
      if (! ((unsigned long )curbuf2 < (unsigned long )curbuf)) {
#line 1505
        goto while_break___4;
      }
#line 1506
      if (state->ofd == -1) {
#line 1507
        if (curbuf - curbuf2 < (long )state->b) {
#line 1508
          nbytes = (int )(curbuf - curbuf2);
        } else {
#line 1510
          nbytes = state->b;
        }
      } else {
#line 1514
        if (curbuf - curbuf2 < (long )state->b) {
#line 1515
          n = (int )(curbuf - curbuf2);
        } else {
#line 1517
          n = state->b;
        }
#line 1519
        if (o->v >= 4) {
          {
#line 1520
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Trying to write %d bytes (2) from %p\n",
                  n, curbuf2);
          }
        }
        {
#line 1522
        nbytes = my_write((struct options  const  */* const  */)o, state, (void const   *)curbuf2,
                          (size_t const   )n);
        }
#line 1524
        if (o->v >= 4) {
#line 1525
          if (childpid) {
#line 1525
            tmp___16 = 1;
          } else {
#line 1525
            tmp___16 = 0;
          }
          {
#line 1525
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"#%d wrote %d bytes\n",
                  tmp___16, nbytes);
          }
        }
#line 1528
        if (o->c == 0) {
#line 1528
          goto _L___1;
        } else
#line 1528
        if (childpid != (int volatile   )0) {
          _L___1: /* CIL Label */ 
#line 1528
          if (state->teefd != -1) {
#line 1530
            if (curbuf - curbuf2 < (long )state->b) {
              {
#line 1531
              tmp___17 = write(state->teefd, (void const   *)curbuf2, (size_t )(curbuf - curbuf2));
#line 1531
              nbytes = (int )tmp___17;
              }
            } else {
              {
#line 1533
              tmp___18 = write(state->teefd, (void const   *)curbuf2, (size_t )state->b);
#line 1533
              nbytes = (int )tmp___18;
              }
            }
#line 1534
            if (nbytes == -1) {
              {
#line 1535
              tmp___19 = __errno_location();
              }
#line 1535
              if (*tmp___19 == 4) {
#line 1536
                nbytes = 0;
              } else {
                {
#line 1538
                perror("write() failed");
#line 1539
                report((struct options  const  */* const  */)o, state, -1);
#line 1540
                exit(2);
                }
              }
            }
#line 1543
            if (o->v >= 4) {
#line 1544
              if (childpid) {
#line 1544
                tmp___20 = 1;
              } else {
#line 1544
                tmp___20 = 0;
              }
              {
#line 1544
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"#%d wrote %d bytes to fd %d\n",
                      tmp___20, nbytes, state->teefd);
              }
            }
          }
        }
      }
#line 1548
      state->bytes_transferred += (long long )nbytes;
#line 1549
      if (o->v >= 2) {
#line 1549
        if (state->bytes_firsttransfer == -1) {
          {
#line 1551
          state->bytes_firsttransfer = nbytes;
#line 1552
          tmp___21 = gettimeofday((struct timeval */* __restrict  */)(& t), (__timezone_ptr_t )((void *)0));
          }
#line 1552
          if (tmp___21 == -1) {
            {
#line 1553
            perror("gettimeofday() failed");
#line 1554
            exit(2);
            }
          }
#line 1556
          state->time_firsttransfer = ((double )t.tv_sec + (double )t.tv_usec / 1000000.0) - state->starttime;
        }
      }
#line 1561
      if (o->n) {
#line 1561
        if (state->bytes_transferred >= o->n) {
#line 1562
          if (o->v > 1) {
#line 1563
            if (childpid) {
#line 1563
              tmp___22 = 1;
            } else {
#line 1563
              tmp___22 = 0;
            }
            {
#line 1563
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"#%d finishing on condition 5\n",
                    tmp___22);
            }
          }
#line 1565
          stopit = (sig_atomic_t volatile   )1;
        }
      }
#line 1567
      if (signal_report) {
        {
#line 1568
        report((struct options  const  */* const  */)o, state, (int )(curbuf - buf));
#line 1569
        signal_report = (sig_atomic_t volatile   )0;
        }
      }
#line 1571
      if (n_sighups > (sig_atomic_t volatile   )0) {
        {
#line 1572
        handle_sighup();
        }
      }
#line 1505
      curbuf2 += nbytes;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1577
  if (o->v >= 1) {
#line 1577
    if (o->c > 0) {
#line 1577
      if (! (childpid == (int volatile   )0)) {
        {
#line 1578
        report((struct options  const  */* const  */)o, state, -1);
        }
      }
    } else {
      {
#line 1578
      report((struct options  const  */* const  */)o, state, -1);
      }
    }
  }
  {
#line 1580
  closefiles(state);
  }
#line 1581
  if (o->c > 0) {
#line 1582
    if (childpid == (int volatile   )0) {
      {
#line 1583
      exit(0);
      }
    } else {
      {
#line 1585
      wait((union wait *)((void *)0));
      }
    }
  }
  {
#line 1589
  free(palloc.allocated);
  }
#line 1590
  return;
}
}
#line 1592 "/home/june/repo/benchmarks/collector/temp/cstream-3.0.0/cstream.c"
void cleanup(struct options  const  * const  o , struct progstate * const  state ) 
{ 
  int tmp ;

  {
#line 1595
  if (o->p) {
#line 1595
    if (state->pidfile_has_been_created) {
      {
#line 1596
      tmp = unlink((char const   *)o->p);
      }
#line 1596
      if (tmp == -1) {
        {
#line 1597
        perror("Unlink pidfile failed - continuing");
        }
      }
    }
  }
#line 1598
  return;
}
}
#line 1600 "/home/june/repo/benchmarks/collector/temp/cstream-3.0.0/cstream.c"
static void print_version(void) 
{ 


  {
  {
#line 1603
  printf((char const   */* __restrict  */)"%s\n", "3.0.0");
  }
#line 1604
  return;
}
}
#line 1606 "/home/june/repo/benchmarks/collector/temp/cstream-3.0.0/cstream.c"
static void usage(void) 
{ 


  {
  {
#line 1609
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cstream by Martin Cracauer - version 3.0.0\n");
#line 1610
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-V     = print version number to stdout and exit with 0\n-v <n> = verbose [default: off]\n         0 = nothing\n         1 = report bytes transferred and throughput\n         2 = also throughput after first read/write\n         3 = also seperate throughput for read and write (unimplemented)\n         3 = verbose stats on every read/write\n-b <n> = blocksize [default: 8192]\n-B <n> = buffer (at most) <n> bytes [default: one block]\n-c <n> = Concurrency, writing done by a seperate process\n         0 = no concurrency, one one process\n         1 = read side buffers\n         2 = write side buffers\n         3 = both sides buffer, -B amount of data will be transferred at once\n-n <n> = overall size of data [default: unlimited]\n-t <n> = throughput in bytes/sec [default: unlimited]\n         if positive, bandwith is average over whole session.\n         if negative, every write is delayed to not excceed.\n-i <s> = name of input file, - = generate stream yourself\n         to use stdin, use -i \'\'\n-o <s> = name of output file, - = just sink data\n         to use stdout, -o \'\'\n-I <s> = Type of input file\n-O <s> = Type of ouput file\n         \'f\' = fifo (create it)\n         \'a\' = set audio modes on file (i.e. CD quality)\n         \'N\' = don\'t use TCP even if filename has \':\'\n         \'t\' = tee - in addition to outfile, copy stream to fd 3\n         \'D\' = O_DIRECT\n         \'S\' = O_SYNC\n         [Multiple chars allowed]\n-p <s> = Write pid as ascii integer to file <s>\n-l       include line count in statistics\n-w <n> = Set write block size (-c 5 only)\n-S       Don\'t output statistic on SIGINFO\n-T <n> = Report throughput every <n> seconds\nSIGINFO causes statistics to be written to stderr\nSIGUSR1 causes statistics to be written to stderr\nSIGUSR2 causes loop end after next buffer transfer\n<file>  if -i has not been used, specifies input file\n-6 <n>  Use IPV6: -1 = don\'t, 1 = allow both, 2 = force v6\n        On some platforms server mode 1 forces ipv6, as\n        they don\'t open both v4 and v6 ports from one bind call.\n");
#line 1658
  exit(1);
  }
}
}
#line 1661 "/home/june/repo/benchmarks/collector/temp/cstream-3.0.0/cstream.c"
long long atoi_kmg(char const   * const  s ) 
{ 
  long long res ;
  char c ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1667
  tmp = atoi((char const   *)s);
#line 1667
  res = (long long )tmp;
  }
#line 1668
  if ((int const   )*(s + 0) != 0) {
    {
#line 1669
    tmp___0 = strlen((char const   *)s);
#line 1669
    tmp___1 = tolower((int )*(s + (tmp___0 - 1UL)));
#line 1669
    c = (char )tmp___1;
    }
    {
#line 1671
    if ((int )c == 107) {
#line 1671
      goto case_107;
    }
#line 1672
    if ((int )c == 109) {
#line 1672
      goto case_109;
    }
#line 1673
    if ((int )c == 103) {
#line 1673
      goto case_103;
    }
#line 1670
    goto switch_break;
    case_107: /* CIL Label */ 
#line 1671
    res *= 1024LL;
#line 1671
    goto switch_break;
    case_109: /* CIL Label */ 
#line 1672
    res *= 1048576LL;
#line 1672
    goto switch_break;
    case_103: /* CIL Label */ 
#line 1673
    res *= 1073741824LL;
#line 1673
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 1676
  return (res);
}
}
#line 1679 "/home/june/repo/benchmarks/collector/temp/cstream-3.0.0/cstream.c"
int main(int argc , char * const  *argv ) 
{ 
  struct options o ;
  struct progstate state ;
  int ch ;
  size_t blocksize ;
  long long tmp ;
  long long tmp___0 ;
  long long tmp___1 ;
  long long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  struct itimerval itv ;

  {
  {
#line 1685
  blocksize = (size_t )0;
#line 1687
  default_options((struct options */* const  */)(& o));
  }
  {
#line 1689
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1689
    ch = getopt(argc, argv, "b:B:c:i:I:n:o:O:p:St:T:v:Vl6:");
    }
#line 1689
    if (! (ch != -1)) {
#line 1689
      goto while_break;
    }
    {
#line 1691
    if (ch == 118) {
#line 1691
      goto case_118;
    }
#line 1692
    if (ch == 98) {
#line 1692
      goto case_98;
    }
#line 1693
    if (ch == 66) {
#line 1693
      goto case_66;
    }
#line 1694
    if (ch == 99) {
#line 1694
      goto case_99;
    }
#line 1695
    if (ch == 108) {
#line 1695
      goto case_108;
    }
#line 1696
    if (ch == 110) {
#line 1696
      goto case_110;
    }
#line 1697
    if (ch == 116) {
#line 1697
      goto case_116;
    }
#line 1698
    if (ch == 83) {
#line 1698
      goto case_83;
    }
#line 1699
    if (ch == 105) {
#line 1699
      goto case_105;
    }
#line 1700
    if (ch == 111) {
#line 1700
      goto case_111;
    }
#line 1701
    if (ch == 73) {
#line 1701
      goto case_73;
    }
#line 1702
    if (ch == 79) {
#line 1702
      goto case_79;
    }
#line 1703
    if (ch == 112) {
#line 1703
      goto case_112;
    }
#line 1704
    if (ch == 86) {
#line 1704
      goto case_86;
    }
#line 1705
    if (ch == 119) {
#line 1705
      goto case_119;
    }
#line 1706
    if (ch == 84) {
#line 1706
      goto case_84;
    }
#line 1712
    if (ch == 54) {
#line 1712
      goto case_54;
    }
#line 1719
    goto switch_default;
    case_118: /* CIL Label */ 
    {
#line 1691
    o.v = atoi((char const   *)optarg);
    }
#line 1691
    goto switch_break;
    case_98: /* CIL Label */ 
    {
#line 1692
    tmp = atoi_kmg((char const   */* const  */)optarg);
#line 1692
    blocksize = (size_t )tmp;
    }
#line 1692
    goto switch_break;
    case_66: /* CIL Label */ 
    {
#line 1693
    tmp___0 = atoi_kmg((char const   */* const  */)optarg);
#line 1693
    o.B = (int )tmp___0;
    }
#line 1693
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 1694
    o.c = atoi((char const   *)optarg);
    }
#line 1694
    goto switch_break;
    case_108: /* CIL Label */ 
#line 1695
    o.l = 1;
#line 1695
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 1696
    o.n = atoi_kmg((char const   */* const  */)optarg);
    }
#line 1696
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 1697
    tmp___1 = atoi_kmg((char const   */* const  */)optarg);
#line 1697
    o.t = (int )tmp___1;
    }
#line 1697
    goto switch_break;
    case_83: /* CIL Label */ 
#line 1698
    o.S = 1;
#line 1698
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 1699
    o.i = strdup((char const   *)optarg);
    }
#line 1699
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 1700
    o.o = strdup((char const   *)optarg);
    }
#line 1700
    goto switch_break;
    case_73: /* CIL Label */ 
    {
#line 1701
    o.I = strdup((char const   *)optarg);
    }
#line 1701
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 1702
    o.O = strdup((char const   *)optarg);
    }
#line 1702
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 1703
    o.p = strdup((char const   *)optarg);
    }
#line 1703
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 1704
    print_version();
#line 1704
    exit(0);
    }
    case_119: /* CIL Label */ 
    {
#line 1705
    tmp___2 = atoi_kmg((char const   */* const  */)optarg);
#line 1705
    o.w = (int )tmp___2;
    }
#line 1705
    goto switch_break;
    case_84: /* CIL Label */ 
    {
#line 1710
    o.T = atoi((char const   *)optarg);
    }
#line 1711
    goto switch_break;
    case_54: /* CIL Label */ 
    {
#line 1713
    tmp___3 = atoi((char const   *)optarg);
    }
#line 1713
    if (tmp___3) {
#line 1713
      tmp___4 = 0;
    } else {
#line 1713
      tmp___4 = 1;
    }
#line 1713
    if (tmp___4 != 0) {
      {
#line 1714
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-6 arg must be a number, -1, 1 or 2: \'%s\'\n",
              optarg);
#line 1715
      exit(1);
      }
    }
    {
#line 1717
    o.six = atoi((char const   *)optarg);
    }
#line 1718
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1719
    usage();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1723
  argc -= optind;
#line 1724
  argv += optind;
  {
#line 1727
  if (argc == 0) {
#line 1727
    goto case_0;
  }
#line 1728
  if (argc == 1) {
#line 1728
    goto case_1;
  }
#line 1734
  goto switch_default___0;
  case_0: /* CIL Label */ 
#line 1727
  goto switch_break___0;
  case_1: /* CIL Label */ 
#line 1729
  if ((unsigned long )o.i == (unsigned long )((void *)0)) {
    {
#line 1730
    o.i = strdup((char const   *)*(argv + 0));
    }
  } else {
    {
#line 1732
    usage();
    }
  }
#line 1733
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 1734
  usage();
  }
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 1737
  init((struct options */* const  */)(& o), (struct progstate */* const  */)(& state),
       (int const   )blocksize);
  }
#line 1739
  if (o.T) {
    {
#line 1743
    signal(14, (void (*)(int  ))(& sigtimer));
#line 1744
    itv.it_interval.tv_sec = (__time_t )o.T;
#line 1745
    itv.it_interval.tv_usec = (__suseconds_t )0;
#line 1746
    itv.it_value.tv_sec = (__time_t )o.T;
#line 1747
    itv.it_value.tv_usec = (__suseconds_t )0;
#line 1748
    setitimer(0, (struct itimerval  const  */* __restrict  */)(& itv), (struct itimerval */* __restrict  */)((void *)0));
    }
  }
#line 1752
  if (o.c == 4) {
    {
#line 1754
    pollloop((struct options  const  */* const  */)(& o), (struct progstate */* const  */)(& state));
    }
  } else {
    {
#line 1761
    loop((struct options */* const  */)(& o), (struct progstate */* const  */)(& state));
    }
  }
  {
#line 1763
  cleanup((struct options  const  */* const  */)(& o), (struct progstate */* const  */)(& state));
#line 1765
  free(state.pmalloc.allocated);
  }
#line 1768
  return (0);
}
}
