/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 485 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/jam.h"
struct globs {
   int noexec ;
   int jobs ;
   int quitquick ;
   int newestfirst ;
   char debug[15] ;
   FILE *cmdout ;
};
#line 16 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/option.h"
struct option {
   char flag ;
   char const   *val ;
};
#line 16 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/option.h"
typedef struct option option;
#line 47 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/lists.h"
struct _list;
#line 47 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/lists.h"
typedef struct _list LIST;
#line 49 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/lists.h"
struct _list {
   LIST *next ;
   LIST *tail ;
   char const   *string ;
};
#line 48 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
struct utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char __domainname[65] ;
};
#line 59 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/lists.h"
struct _lol;
#line 59 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/lists.h"
typedef struct _lol LOL;
#line 63 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/lists.h"
struct _lol {
   int count ;
   LIST *list[9] ;
};
#line 25 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/pathsys.h"
struct _pathname;
#line 25 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/pathsys.h"
typedef struct _pathname PATHNAME;
#line 26
struct _pathpart;
#line 26 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/pathsys.h"
typedef struct _pathpart PATHPART;
#line 28 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/pathsys.h"
struct _pathpart {
   char const   *ptr ;
   int len ;
};
#line 33 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/pathsys.h"
struct _pathname {
   PATHPART part[6] ;
};
#line 39 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/expand.c"
struct __anonstruct_VAR_EDITS_50 {
   PATHNAME f ;
   char parent ;
   char filemods ;
   char downshift ;
   char upshift ;
   char quote ;
   PATHPART empty ;
   PATHPART join ;
};
#line 39 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/expand.c"
typedef struct __anonstruct_VAR_EDITS_50 VAR_EDITS;
#line 18 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/parse.h"
struct _PARSE;
#line 18 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/parse.h"
typedef struct _PARSE PARSE;
#line 20 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/parse.h"
struct _PARSE {
   LIST *(*func)(PARSE *p , LOL *args , int *jmp ) ;
   PARSE *left ;
   PARSE *right ;
   PARSE *third ;
   char const   *string ;
   char const   *string1 ;
   int num ;
   int refs ;
};
#line 34 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/scan.h"
struct _YYSTYPE {
   int type ;
   char const   *string ;
   PARSE *parse ;
   LIST *list ;
   int number ;
};
#line 34 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/scan.h"
typedef struct _YYSTYPE YYSYMBOL;
#line 325 "y.tab.c"
union yyalloc {
   short yyss ;
   YYSYMBOL yyvs ;
};
#line 377 "y.tab.c"
typedef signed char yysigned_char;
#line 39 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/rules.h"
struct _rule;
#line 39 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/rules.h"
typedef struct _rule RULE;
#line 40
struct _target;
#line 40 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/rules.h"
typedef struct _target TARGET;
#line 41
struct _targets;
#line 41 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/rules.h"
typedef struct _targets TARGETS;
#line 42
struct _action;
#line 42 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/rules.h"
typedef struct _action ACTION;
#line 43
struct _actions;
#line 43 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/rules.h"
typedef struct _actions ACTIONS;
#line 44
struct _settings;
#line 44 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/rules.h"
typedef struct _settings SETTINGS;
#line 48 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/rules.h"
struct _rule {
   char const   *name ;
   PARSE *procedure ;
   char const   *actions ;
   LIST *bindlist ;
   LIST *params ;
   int flags ;
};
#line 68 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/rules.h"
struct _actions {
   ACTIONS *next ;
   ACTIONS *tail ;
   ACTION *action ;
};
#line 76 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/rules.h"
struct _action {
   RULE *rule ;
   TARGETS *targets ;
   TARGETS *sources ;
   char running ;
   char status ;
};
#line 86 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/rules.h"
struct _settings {
   SETTINGS *next ;
   char const   *symbol ;
   LIST *value ;
};
#line 94 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/rules.h"
struct _targets {
   TARGETS *next ;
   TARGETS *tail ;
   TARGET *target ;
};
#line 102 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/rules.h"
struct _target {
   char const   *name ;
   char const   *boundname ;
   ACTIONS *actions ;
   SETTINGS *settings ;
   char flags ;
   char binding ;
   TARGETS *depends ;
   TARGET *includes ;
   time_t time ;
   time_t leaf ;
   char fate ;
   char progress ;
   char status ;
   int asynccnt ;
   TARGETS *parents ;
   char *cmds ;
};
#line 72 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/make.c"
struct __anonstruct_COUNTS_50 {
   int temp ;
   int updating ;
   int cantfind ;
   int cantmake ;
   int targets ;
   int made ;
};
#line 72 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/make.c"
typedef struct __anonstruct_COUNTS_50 COUNTS;
#line 38 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/command.h"
struct _cmd;
#line 38 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/command.h"
typedef struct _cmd CMD;
#line 40 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/command.h"
struct _cmd {
   CMD *next ;
   CMD *tail ;
   RULE *rule ;
   LIST *shell ;
   LOL args ;
   char buf[10240] ;
};
#line 77 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/make1.c"
struct __anonstruct_counts_50 {
   int failed ;
   int skipped ;
   int total ;
   int made ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 69 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/execunix.c"
struct __anonstruct_cmdtab_50 {
   int pid ;
   void (*func)(void *closure , int status ) ;
   void *closure ;
};
#line 11 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/regexp.h"
struct regexp {
   char const   *startp[10] ;
   char const   *endp[10] ;
   char regstart ;
   char reganch ;
   char *regmust ;
   int regmlen ;
   char program[1] ;
};
#line 11 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/regexp.h"
typedef struct regexp regexp;
#line 13 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/hash.h"
struct hashdata;
#line 13 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/hash.h"
typedef struct hashdata HASHDATA;
#line 15
struct hash;
#line 45 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/hdrmacro.c"
struct header_macro {
   char const   *symbol ;
   char const   *filename ;
};
#line 45 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/hdrmacro.c"
typedef struct header_macro HEADER_MACRO;
#line 33 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/newstr.c"
typedef char const   *STRING;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 35 "/usr/include/ar.h"
struct ar_hdr {
   char ar_name[16] ;
   char ar_date[12] ;
   char ar_uid[6] ;
   char ar_gid[6] ;
   char ar_mode[8] ;
   char ar_size[10] ;
   char ar_fmag[2] ;
};
#line 30 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/hash.c"
struct item;
#line 30 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/hash.c"
struct hashhdr {
   struct item *next ;
   unsigned int keyval ;
};
#line 38 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/hash.c"
struct hashdata {
   char *key ;
};
#line 43 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/hash.c"
struct item {
   struct hashhdr hdr ;
   struct hashdata data ;
};
#line 43 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/hash.c"
typedef struct item ITEM;
#line 50 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/hash.c"
struct __anonstruct_tab_50 {
   int nel ;
   ITEM **base ;
};
#line 50 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/hash.c"
struct __anonstruct_lists_52 {
   int nel ;
   char *base ;
};
#line 50 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/hash.c"
struct __anonstruct_items_51 {
   int more ;
   char *next ;
   int datalen ;
   int size ;
   int nel ;
   int list ;
   struct __anonstruct_lists_52 lists[32] ;
};
#line 50 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/hash.c"
struct hash {
   struct __anonstruct_tab_50 tab ;
   int bloat ;
   int inel ;
   struct __anonstruct_items_51 items ;
   char const   *name ;
};
#line 225 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/builtins.c"
struct globbing {
   LIST *patterns ;
   LIST *results ;
};
#line 30 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/scan.c"
struct keyword {
   char const   *word ;
   int type ;
};
#line 38 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/scan.c"
struct include {
   struct include *next ;
   char const   *string ;
   char **strings ;
   FILE *file ;
   char const   *fname ;
   int line ;
   char buf[512] ;
};
#line 47 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/variable.c"
struct _variable;
#line 47 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/variable.c"
typedef struct _variable VARIABLE;
#line 49 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/variable.c"
struct _variable {
   char const   *symbol ;
   LIST *value ;
};
#line 77 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/make1.c"
struct __anonstruct_counts_50___0 {
   int failed ;
   int skipped ;
   int total ;
   int made ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/timestamp.c"
struct _binding;
#line 26 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/timestamp.c"
typedef struct _binding BINDING;
#line 28 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/timestamp.c"
struct _binding {
   char const   *name ;
   short flags ;
   short progress ;
   time_t time ;
};
#line 69 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/execunix.c"
struct __anonstruct_cmdtab_50___0 {
   int pid ;
   void (*func)(void *closure , int status ) ;
   void *closure ;
};
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/mkjambase.c"
int main(int argc , char **argv , char **envp ) 
{ 
  char buf___0[1024] ;
  FILE *fin ;
  FILE *fout ;
  char *p ;
  int doDotC ;
  int tmp ;
  char *p___0 ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 33
  doDotC = 0;
#line 35
  if (argc < 3) {
    {
#line 37
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage: %s jambase.c Jambase ...\n",
            *(argv + 0));
    }
#line 38
    return (-1);
  }
  {
#line 41
  fout = fopen((char const   */* __restrict  */)*(argv + 1), (char const   */* __restrict  */)"w");
  }
#line 41
  if (! fout) {
    {
#line 43
    perror((char const   *)*(argv + 1));
    }
#line 44
    return (-1);
  }
  {
#line 49
  p = strrchr((char const   *)*(argv + 1), '.');
  }
#line 49
  if (p) {
    {
#line 49
    tmp = strcmp((char const   *)p, ".c");
    }
#line 49
    if (! tmp) {
#line 50
      doDotC ++;
    }
  }
#line 54
  argc -= 2;
#line 54
  argv += 2;
#line 56
  if (doDotC) {
    {
#line 58
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"/* Generated by mkjambase from Jambase */\n");
#line 59
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"const char *jambase[] = {\n");
    }
  }
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    tmp___1 = argc;
#line 62
    argc --;
#line 62
    if (! tmp___1) {
#line 62
      goto while_break;
    }
    {
#line 64
    fin = fopen((char const   */* __restrict  */)*argv, (char const   */* __restrict  */)"r");
    }
#line 64
    if (! fin) {
      {
#line 66
      perror((char const   *)*argv);
      }
#line 67
      return (-1);
    }
#line 70
    if (doDotC) {
      {
#line 72
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"/* %s */\n",
              *argv);
      }
    } else {
      {
#line 76
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"### %s ###\n",
              *argv);
      }
    }
    {
#line 79
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 79
      tmp___0 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)fin);
      }
#line 79
      if (! tmp___0) {
#line 79
        goto while_break___0;
      }
#line 81
      if (doDotC) {
#line 83
        p___0 = buf___0;
        {
#line 87
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 87
          if (! ((int )*p___0 == 32)) {
#line 87
            if (! ((int )*p___0 == 9)) {
#line 87
              if (! ((int )*p___0 == 10)) {
#line 87
                goto while_break___1;
              }
            }
          }
#line 88
          p___0 ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 92
        if ((int )*p___0 == 35) {
#line 93
          goto while_continue___0;
        } else
#line 92
        if (! *p___0) {
#line 93
          goto while_continue___0;
        }
        {
#line 97
        _IO_putc('\"', fout);
        }
        {
#line 99
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 99
          if (*p___0) {
#line 99
            if ((int )*p___0 != 10) {
#line 99
              if (! ((int )*p___0 != 13)) {
#line 99
                goto while_break___2;
              }
            } else {
#line 99
              goto while_break___2;
            }
          } else {
#line 99
            goto while_break___2;
          }
          {
#line 102
          if ((int )*p___0 == 92) {
#line 102
            goto case_92;
          }
#line 103
          if ((int )*p___0 == 34) {
#line 103
            goto case_34;
          }
#line 104
          goto switch_default;
          case_92: /* CIL Label */ 
          {
#line 102
          _IO_putc('\\', fout);
#line 102
          _IO_putc('\\', fout);
          }
#line 102
          goto switch_break;
          case_34: /* CIL Label */ 
          {
#line 103
          _IO_putc('\\', fout);
#line 103
          _IO_putc('\"', fout);
          }
#line 103
          goto switch_break;
          switch_default: /* CIL Label */ 
          {
#line 104
          _IO_putc((int )*p___0, fout);
          }
#line 104
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
#line 99
          p___0 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 107
        fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\\n\",\n");
        }
      } else {
        {
#line 111
        fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%s",
                buf___0);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 116
    fclose(fin);
#line 62
    argv ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  if (doDotC) {
    {
#line 120
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"0 };\n");
    }
  }
  {
#line 122
  fclose(fout);
  }
#line 124
  return (0);
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 264
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 494 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/jam.h"
struct globs globs ;
#line 25 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/option.h"
int getoptions(int argc , char **argv , char const   *opts , option *optv , char **targets ) ;
#line 26
char const   *getoptval(option *optv , char opt , int subopt ) ;
#line 71 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/lists.h"
LIST *list_new(LIST *head , char const   *string , int copy ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/parse.h"
void parse_file(char const   *f ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/variable.h"
void var_defines(char const   **e ) ;
#line 16
void var_set(char const   *symbol , LIST *value , int flag ) ;
#line 18
void var_done(void) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/builtins.h"
void load_builtins(void) ;
#line 170 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/rules.h"
void touchtarget(char const   *t ) ;
#line 180
void donerules(void) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/newstr.h"
void donestr(void) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/scan.h"
int yyanyerrors(void) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/timestamp.h"
void donestamps(void) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/make.h"
int make(int n_targets , char const   **targets , int anyhow ) ;
#line 81 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) uname)(struct utsname *__name ) ;
#line 133 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/jam.c"
struct globs globs  =    {0, 1, 0, 0, {(char)0, (char)1}, (FILE *)0};
#line 148 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/jam.c"
static char const   *othersyms[5]  = {      "UNIX=true",      "OS=LINUX",      "",      "JAMVERSION=2.5.2", 
        (char const   *)0};
#line 165
extern char **environ ;
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 69 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/lists.h"
LIST *list_copy(LIST *l , LIST *nl ) ;
#line 70
void list_free(LIST *head ) ;
#line 72
void list_print(LIST *l ) ;
#line 83
LIST *lol_get(LOL *lol , int i ) ;
#line 15 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/variable.h"
LIST *var_get(char const   *symbol ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/expand.h"
LIST *var_expand(LIST *l , char const   *in , char const   *end , LOL *lol , int cancopyin ) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/pathsys.h"
void path_build(PATHNAME *f , char *file , int binding ) ;
#line 49
void path_parse(char const   *file , PATHNAME *f ) ;
#line 50
void path_parent(PATHNAME *f ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/expand.c"
static void var_edit_parse(char const   *mods , VAR_EDITS *edits ) ;
#line 51
static void var_edit_file(char const   *in , char *out , VAR_EDITS *edits ) ;
#line 52
static void var_edit_shift(char *out , VAR_EDITS *edits ) ;
#line 53
static void var_edit_quote(char *out ) ;
#line 71 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/expand.c"
LIST *var_expand(LIST *l , char const   *in , char const   *end , LOL *lol , int cancopyin ) 
{ 
  char out_buf[1024] ;
  char *out ;
  char const   *inp ;
  char *ov ;
  int depth ;
  LIST *tmp ;
  LIST *tmp___0 ;
  LIST *tmp___1 ;
  LIST *tmp___2 ;
  char *tmp___3 ;
  char tmp___4 ;
  char const   *tmp___5 ;
  LIST *tmp___6 ;
  LIST *tmp___7 ;
  char *tmp___8 ;
  char tmp___9 ;
  char const   *tmp___10 ;
  LIST *variables ;
  LIST *remainder ;
  LIST *vars ;
  LIST *value ;
  LIST *evalue ;
  char *colon ;
  char *bracket ;
  char varname[1024] ;
  int sub1 ;
  int sub2 ;
  VAR_EDITS edits ;
  char *dash ;
  int tmp___11 ;
  int tmp___12 ;
  LIST *rem ;
  char *out1 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;

  {
#line 80
  out = out_buf;
#line 81
  inp = in;
#line 85
  if (globs.debug[8]) {
    {
#line 86
    printf((char const   */* __restrict  */)"expand \'%.*s\'\n", end - in, in);
    }
  }
#line 90
  if (end - in == 4L) {
#line 90
    if ((int const   )*(in + 0) == 36) {
#line 90
      if ((int const   )*(in + 1) == 40) {
#line 90
        if ((int const   )*(in + 3) == 41) {
          {
#line 95
          if ((int const   )*(in + 2) == 60) {
#line 95
            goto case_60;
          }
#line 95
          if ((int const   )*(in + 2) == 49) {
#line 95
            goto case_60;
          }
#line 99
          if ((int const   )*(in + 2) == 62) {
#line 99
            goto case_62;
          }
#line 99
          if ((int const   )*(in + 2) == 50) {
#line 99
            goto case_62;
          }
#line 92
          goto switch_break;
          case_60: /* CIL Label */ 
          case_49: /* CIL Label */ 
          {
#line 96
          tmp = lol_get(lol, 0);
#line 96
          tmp___0 = list_copy(l, tmp);
          }
#line 96
          return (tmp___0);
          case_62: /* CIL Label */ 
          case_50: /* CIL Label */ 
          {
#line 100
          tmp___1 = lol_get(lol, 1);
#line 100
          tmp___2 = list_copy(l, tmp___1);
          }
#line 100
          return (tmp___2);
          switch_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if (! ((unsigned long )in < (unsigned long )end)) {
#line 106
      goto while_break;
    }
#line 107
    tmp___3 = out;
#line 107
    out ++;
#line 107
    tmp___5 = in;
#line 107
    in ++;
#line 107
    tmp___4 = (char )*tmp___5;
#line 107
    *tmp___3 = tmp___4;
#line 107
    if ((int )tmp___4 == 36) {
#line 107
      if ((int const   )*in == 40) {
#line 108
        goto expand;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 116
  *out = (char )'\000';
#line 118
  if (cancopyin) {
    {
#line 119
    tmp___6 = list_new(l, inp, 1);
    }
#line 119
    return (tmp___6);
  } else {
    {
#line 121
    tmp___7 = list_new(l, (char const   *)(out_buf), 0);
    }
#line 121
    return (tmp___7);
  }
  expand: 
#line 145
  depth = 1;
#line 146
  out --;
#line 146
  in ++;
#line 147
  ov = out;
  {
#line 149
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 149
    if ((unsigned long )in < (unsigned long )end) {
#line 149
      if (! depth) {
#line 149
        goto while_break___0;
      }
    } else {
#line 149
      goto while_break___0;
    }
#line 151
    tmp___8 = ov;
#line 151
    ov ++;
#line 151
    tmp___10 = in;
#line 151
    in ++;
#line 151
    tmp___9 = (char )*tmp___10;
#line 151
    *tmp___8 = tmp___9;
    {
#line 153
    if ((int )tmp___9 == 40) {
#line 153
      goto case_40;
    }
#line 154
    if ((int )tmp___9 == 41) {
#line 154
      goto case_41;
    }
#line 155
    if ((int )tmp___9 == 58) {
#line 155
      goto case_58;
    }
#line 156
    if ((int )tmp___9 == 91) {
#line 156
      goto case_91;
    }
#line 157
    if ((int )tmp___9 == 93) {
#line 157
      goto case_93;
    }
#line 151
    goto switch_break___0;
    case_40: /* CIL Label */ 
#line 153
    depth ++;
#line 153
    goto switch_break___0;
    case_41: /* CIL Label */ 
#line 154
    depth --;
#line 154
    goto switch_break___0;
    case_58: /* CIL Label */ 
#line 155
    *(ov + -1) = (char )'\001';
#line 155
    goto switch_break___0;
    case_91: /* CIL Label */ 
#line 156
    *(ov + -1) = (char )'\002';
#line 156
    goto switch_break___0;
    case_93: /* CIL Label */ 
#line 157
    *(ov + -1) = (char )'\003';
#line 157
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 163
  ov --;
#line 184
  variables = (LIST *)0;
#line 185
  remainder = (LIST *)0;
#line 190
  if ((unsigned long )out < (unsigned long )ov) {
    {
#line 191
    variables = var_expand((LIST *)0, (char const   *)out, (char const   *)ov, lol,
                           0);
    }
  }
#line 192
  if ((unsigned long )in < (unsigned long )end) {
    {
#line 193
    remainder = var_expand((LIST *)0, in, end, lol, 0);
    }
  }
#line 199
  vars = variables;
  {
#line 199
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 199
    if (! vars) {
#line 199
      goto while_break___1;
    }
    {
#line 201
    evalue = (LIST *)0;
#line 205
    sub1 = 0;
#line 205
    sub2 = -1;
#line 211
    strcpy((char */* __restrict  */)(varname), (char const   */* __restrict  */)vars->string);
#line 213
    colon = strchr((char const   *)(varname), '\001');
    }
#line 213
    if (colon) {
      {
#line 215
      *colon = (char )'\000';
#line 216
      var_edit_parse((char const   *)(colon + 1), & edits);
      }
    }
    {
#line 223
    bracket = strchr((char const   *)(varname), '\002');
    }
#line 223
    if (bracket) {
      {
#line 227
      dash = strchr((char const   *)(bracket + 1), '-');
      }
#line 227
      if (dash) {
#line 228
        *dash = (char )'\000';
      }
      {
#line 230
      tmp___11 = atoi((char const   *)(bracket + 1));
#line 230
      sub1 = tmp___11 - 1;
      }
#line 232
      if (! dash) {
#line 233
        sub2 = 1;
      } else
#line 234
      if (! *(dash + 1)) {
#line 235
        sub2 = -1;
      } else
#line 234
      if ((int )*(dash + 1) == 3) {
#line 235
        sub2 = -1;
      } else {
        {
#line 237
        tmp___12 = atoi((char const   *)(dash + 1));
#line 237
        sub2 = tmp___12 - sub1;
        }
      }
#line 239
      *bracket = (char )'\000';
    }
#line 244
    if ((int )varname[0] == 60) {
#line 244
      if (! varname[1]) {
        {
#line 245
        value = lol_get(lol, 0);
        }
      } else {
#line 244
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 246
    if ((int )varname[0] == 62) {
#line 246
      if (! varname[1]) {
        {
#line 247
        value = lol_get(lol, 1);
        }
      } else {
#line 246
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 248
    if ((int )varname[0] >= 49) {
#line 248
      if ((int )varname[0] <= 57) {
#line 248
        if (! varname[1]) {
          {
#line 249
          value = lol_get(lol, (int )varname[0] - 49);
          }
        } else {
          {
#line 251
          value = var_get((char const   *)(varname));
          }
        }
      } else {
        {
#line 251
        value = var_get((char const   *)(varname));
        }
      }
    } else {
      {
#line 251
      value = var_get((char const   *)(varname));
      }
    }
#line 256
    if ((unsigned long )out == (unsigned long )(out_buf)) {
#line 256
      if (! bracket) {
#line 256
        if (! colon) {
#line 256
          if ((unsigned long )in == (unsigned long )end) {
            {
#line 258
            l = list_copy(l, value);
            }
#line 259
            goto __Cont;
          }
        }
      }
    }
    {
#line 264
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 264
      if (sub1 > 0) {
#line 264
        if (! value) {
#line 264
          goto while_break___2;
        }
      } else {
#line 264
        goto while_break___2;
      }
#line 265
      sub1 --;
#line 265
      value = value->next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 269
    if (! value) {
#line 269
      if (colon) {
#line 269
        if (edits.empty.ptr) {
          {
#line 270
          value = list_new((LIST *)0, edits.empty.ptr, 0);
#line 270
          evalue = value;
          }
        }
      }
    }
    {
#line 274
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 274
      if (! value) {
#line 274
        goto while_break___3;
      }
#line 281
      if (sub2 >= 0) {
#line 281
        sub2 --;
#line 281
        if (sub2 < 0) {
#line 282
          goto while_break___3;
        }
      }
#line 286
      if (colon) {
#line 286
        if (edits.filemods) {
          {
#line 287
          var_edit_file(value->string, out, & edits);
          }
        } else {
          {
#line 289
          strcpy((char */* __restrict  */)out, (char const   */* __restrict  */)value->string);
          }
        }
      } else {
        {
#line 289
        strcpy((char */* __restrict  */)out, (char const   */* __restrict  */)value->string);
        }
      }
#line 291
      if (colon) {
#line 291
        if (edits.upshift) {
          {
#line 292
          var_edit_shift(out, & edits);
          }
        } else
#line 291
        if (edits.downshift) {
          {
#line 292
          var_edit_shift(out, & edits);
          }
        }
      }
#line 294
      if (colon) {
#line 294
        if (edits.quote) {
          {
#line 295
          var_edit_quote(out);
          }
        }
      }
#line 302
      if (colon) {
#line 302
        if (edits.join.ptr) {
#line 302
          if (value->next) {
#line 302
            goto _L___1;
          } else
#line 302
          if (vars->next) {
            _L___1: /* CIL Label */ 
            {
#line 305
            tmp___13 = strlen((char const   *)out);
#line 305
            out += tmp___13;
#line 306
            strcpy((char */* __restrict  */)out, (char const   */* __restrict  */)edits.join.ptr);
#line 307
            tmp___14 = strlen((char const   *)out);
#line 307
            out += tmp___14;
            }
#line 308
            goto __Cont___0;
          }
        }
      }
#line 313
      if ((unsigned long )in == (unsigned long )end) {
        {
#line 315
        l = list_new(l, (char const   *)(out_buf), 0);
        }
#line 316
        goto __Cont___0;
      }
      {
#line 324
      tmp___15 = strlen((char const   *)out);
#line 324
      out1 = out + tmp___15;
#line 326
      rem = remainder;
      }
      {
#line 326
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 326
        if (! rem) {
#line 326
          goto while_break___4;
        }
        {
#line 328
        strcpy((char */* __restrict  */)out1, (char const   */* __restrict  */)rem->string);
#line 329
        l = list_new(l, (char const   *)(out_buf), 0);
#line 326
        rem = rem->next;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      __Cont___0: /* CIL Label */ 
#line 274
      value = value->next;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 335
    if (evalue) {
      {
#line 336
      list_free(evalue);
      }
    }
    __Cont: /* CIL Label */ 
#line 199
    vars = vars->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 342
  if (variables) {
    {
#line 343
    list_free(variables);
    }
  }
#line 344
  if (remainder) {
    {
#line 345
    list_free(remainder);
    }
  }
#line 347
  if (globs.debug[8]) {
    {
#line 349
    printf((char const   */* __restrict  */)"expanded to ");
#line 350
    list_print(l);
#line 351
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 354
  return (l);
}
}
#line 393 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/expand.c"
static void var_edit_parse(char const   *mods , VAR_EDITS *edits ) 
{ 
  int havezeroed ;
  char *p ;
  PATHPART *fp ;
  char const   *tmp ;
  char tmp___0 ;
  int i ;
  int tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 398
  havezeroed = 0;
#line 399
  memset((void *)((char *)edits), 0, sizeof(*edits));
  }
  {
#line 401
  while (1) {
    while_continue: /* CIL Label */ ;
#line 401
    if (! *mods) {
#line 401
      goto while_break;
    }
#line 406
    tmp = mods;
#line 406
    mods ++;
    {
#line 408
    if ((int const   )*tmp == 76) {
#line 408
      goto case_76;
    }
#line 409
    if ((int const   )*tmp == 85) {
#line 409
      goto case_85;
    }
#line 410
    if ((int const   )*tmp == 81) {
#line 410
      goto case_81;
    }
#line 411
    if ((int const   )*tmp == 80) {
#line 411
      goto case_80;
    }
#line 412
    if ((int const   )*tmp == 69) {
#line 412
      goto case_69;
    }
#line 413
    if ((int const   )*tmp == 74) {
#line 413
      goto case_74;
    }
#line 414
    if ((int const   )*tmp == 71) {
#line 414
      goto case_71;
    }
#line 415
    if ((int const   )*tmp == 82) {
#line 415
      goto case_82;
    }
#line 416
    if ((int const   )*tmp == 68) {
#line 416
      goto case_68;
    }
#line 417
    if ((int const   )*tmp == 66) {
#line 417
      goto case_66;
    }
#line 418
    if ((int const   )*tmp == 83) {
#line 418
      goto case_83;
    }
#line 419
    if ((int const   )*tmp == 77) {
#line 419
      goto case_77;
    }
#line 421
    goto switch_default;
    case_76: /* CIL Label */ 
#line 408
    edits->downshift = (char)1;
#line 408
    goto while_continue;
    case_85: /* CIL Label */ 
#line 409
    edits->upshift = (char)1;
#line 409
    goto while_continue;
    case_81: /* CIL Label */ 
#line 410
    edits->quote = (char)1;
#line 410
    goto while_continue;
    case_80: /* CIL Label */ 
#line 411
    tmp___0 = (char)1;
#line 411
    edits->filemods = tmp___0;
#line 411
    edits->parent = tmp___0;
#line 411
    goto while_continue;
    case_69: /* CIL Label */ 
#line 412
    fp = & edits->empty;
#line 412
    goto strval;
    case_74: /* CIL Label */ 
#line 413
    fp = & edits->join;
#line 413
    goto strval;
    case_71: /* CIL Label */ 
#line 414
    fp = & edits->f.part[0];
#line 414
    goto fileval;
    case_82: /* CIL Label */ 
#line 415
    fp = & edits->f.part[1];
#line 415
    goto fileval;
    case_68: /* CIL Label */ 
#line 416
    fp = & edits->f.part[2];
#line 416
    goto fileval;
    case_66: /* CIL Label */ 
#line 417
    fp = & edits->f.part[3];
#line 417
    goto fileval;
    case_83: /* CIL Label */ 
#line 418
    fp = & edits->f.part[4];
#line 418
    goto fileval;
    case_77: /* CIL Label */ 
#line 419
    fp = & edits->f.part[5];
#line 419
    goto fileval;
    switch_default: /* CIL Label */ 
#line 421
    return;
    switch_break: /* CIL Label */ ;
    }
    fileval: 
#line 431
    edits->filemods = (char)1;
#line 433
    if ((int const   )*mods != 61) {
#line 437
      tmp___1 = havezeroed;
#line 437
      havezeroed ++;
#line 437
      if (! tmp___1) {
#line 438
        i = 0;
        {
#line 438
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 438
          if (! (i < 6)) {
#line 438
            goto while_break___0;
          }
#line 440
          edits->f.part[i].len = 0;
#line 441
          edits->f.part[i].ptr = "";
#line 438
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 444
      fp->ptr = (char const   *)0;
#line 445
      goto while_continue;
    }
    strval: 
#line 452
    if ((int const   )*mods != 61) {
#line 454
      fp->ptr = "";
#line 455
      fp->len = 0;
    } else {
      {
#line 457
      p = strchr(mods, '\001');
      }
#line 457
      if (p) {
#line 459
        *p = (char)0;
#line 460
        mods ++;
#line 460
        fp->ptr = mods;
#line 461
        fp->len = (int )(p - (char *)mods);
#line 462
        mods = (char const   *)(p + 1);
      } else {
        {
#line 466
        mods ++;
#line 466
        fp->ptr = mods;
#line 467
        tmp___2 = strlen(mods);
#line 467
        fp->len = (int )tmp___2;
#line 468
        mods += fp->len;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 471
  return;
}
}
#line 477 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/expand.c"
static void var_edit_file(char const   *in , char *out , VAR_EDITS *edits ) 
{ 
  PATHNAME pathname ;

  {
  {
#line 487
  path_parse(in, & pathname);
  }
#line 491
  if (edits->f.part[0].ptr) {
#line 492
    pathname.part[0] = edits->f.part[0];
  }
#line 494
  if (edits->f.part[1].ptr) {
#line 495
    pathname.part[1] = edits->f.part[1];
  }
#line 497
  if (edits->f.part[2].ptr) {
#line 498
    pathname.part[2] = edits->f.part[2];
  }
#line 500
  if (edits->f.part[3].ptr) {
#line 501
    pathname.part[3] = edits->f.part[3];
  }
#line 503
  if (edits->f.part[4].ptr) {
#line 504
    pathname.part[4] = edits->f.part[4];
  }
#line 506
  if (edits->f.part[5].ptr) {
#line 507
    pathname.part[5] = edits->f.part[5];
  }
#line 511
  if (edits->parent) {
    {
#line 512
    path_parent(& pathname);
    }
  }
  {
#line 516
  path_build(& pathname, out, 0);
  }
#line 517
  return;
}
}
#line 523 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/expand.c"
static void var_edit_shift(char *out , VAR_EDITS *edits ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 530
  if (edits->upshift) {
    {
#line 532
    while (1) {
      while_continue: /* CIL Label */ ;
#line 532
      if (! *out) {
#line 532
        goto while_break;
      }
      {
#line 533
      tmp = toupper((int )*out);
#line 533
      *out = (char )tmp;
#line 532
      out ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 535
  if (edits->downshift) {
    {
#line 537
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 537
      if (! *out) {
#line 537
        goto while_break___0;
      }
      {
#line 538
      tmp___0 = tolower((int )*out);
#line 538
      *out = (char )tmp___0;
#line 537
      out ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 540
  return;
}
}
#line 543 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/expand.c"
static void var_edit_quote(char *out ) 
{ 
  int count ;
  char *p ;
  char *q ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 548
  p = out;
#line 551
  count = 0;
#line 552
  p = out;
  {
#line 552
  while (1) {
    while_continue: /* CIL Label */ ;
#line 552
    if (! *p) {
#line 552
      goto while_break;
    }
#line 553
    if ((int )*p == 92) {
#line 554
      count ++;
    }
#line 552
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 556
  q = p + count;
  {
#line 558
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 558
    if (! ((unsigned long )p >= (unsigned long )out)) {
#line 558
      goto while_break___0;
    }
#line 560
    if ((int )*p == 92) {
#line 562
      tmp = q;
#line 562
      q --;
#line 562
      tmp___0 = p;
#line 562
      p --;
#line 562
      *tmp = *tmp___0;
#line 563
      tmp___1 = q;
#line 563
      q --;
#line 563
      *tmp___1 = (char )'\\';
    } else {
#line 566
      tmp___2 = q;
#line 566
      q --;
#line 566
      tmp___3 = p;
#line 566
      p --;
#line 566
      *tmp___2 = *tmp___3;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 568
  return;
}
}
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(unsigned long __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/parse.h"
void parse_save(PARSE *p ) ;
#line 34
PARSE *parse_make(LIST *(*func)(PARSE *p , LOL *args , int *jmp ) , PARSE *left ,
                  PARSE *right , PARSE *third , char const   *string , char const   *string1 ,
                  int num ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/scan.h"
YYSYMBOL yylval  ;
#line 44
void yymode(int n ) ;
#line 45
void yyerror(char const   *s ) ;
#line 49
int yylex(void) ;
#line 50
int yyparse(void) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/compile.h"
LIST *compile_append(PARSE *parse , LOL *args , int *jmp ) ;
#line 21
LIST *compile_break(PARSE *parse , LOL *args , int *jmp ) ;
#line 22
LIST *compile_foreach(PARSE *p , LOL *args , int *jmp ) ;
#line 23
LIST *compile_if(PARSE *p , LOL *args , int *jmp ) ;
#line 24
LIST *compile_eval(PARSE *parse , LOL *args , int *jmp ) ;
#line 25
LIST *compile_include(PARSE *parse , LOL *args , int *jmp ) ;
#line 26
LIST *compile_list(PARSE *parse , LOL *args , int *jmp ) ;
#line 27
LIST *compile_local(PARSE *parse , LOL *args , int *jmp ) ;
#line 28
LIST *compile_null(PARSE *parse , LOL *args , int *jmp ) ;
#line 29
LIST *compile_on(PARSE *parse , LOL *args , int *jmp ) ;
#line 30
LIST *compile_rule(PARSE *parse , LOL *args , int *jmp ) ;
#line 31
LIST *compile_rules(PARSE *parse , LOL *args , int *jmp ) ;
#line 32
LIST *compile_set(PARSE *parse , LOL *args , int *jmp ) ;
#line 33
LIST *compile_setcomp(PARSE *parse , LOL *args , int *jmp ) ;
#line 34
LIST *compile_setexec(PARSE *parse , LOL *args , int *jmp ) ;
#line 35
LIST *compile_settings(PARSE *parse , LOL *args , int *jmp ) ;
#line 36
LIST *compile_switch(PARSE *parse , LOL *args , int *jmp ) ;
#line 37
LIST *compile_while(PARSE *p , LOL *args , int *jmp ) ;
#line 404 "y.tab.c"
static unsigned char const   yytranslate[305]  = 
#line 404 "y.tab.c"
  {      (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )3,      (unsigned char const   )4, 
        (unsigned char const   )5,      (unsigned char const   )6,      (unsigned char const   )7,      (unsigned char const   )8, 
        (unsigned char const   )9,      (unsigned char const   )10,      (unsigned char const   )11,      (unsigned char const   )12, 
        (unsigned char const   )13,      (unsigned char const   )14,      (unsigned char const   )15,      (unsigned char const   )16, 
        (unsigned char const   )17,      (unsigned char const   )18,      (unsigned char const   )19,      (unsigned char const   )20, 
        (unsigned char const   )21,      (unsigned char const   )22,      (unsigned char const   )23,      (unsigned char const   )24, 
        (unsigned char const   )25,      (unsigned char const   )26,      (unsigned char const   )27,      (unsigned char const   )28, 
        (unsigned char const   )29,      (unsigned char const   )30,      (unsigned char const   )31,      (unsigned char const   )32, 
        (unsigned char const   )33,      (unsigned char const   )34,      (unsigned char const   )35,      (unsigned char const   )36, 
        (unsigned char const   )37,      (unsigned char const   )38,      (unsigned char const   )39,      (unsigned char const   )40, 
        (unsigned char const   )41,      (unsigned char const   )42,      (unsigned char const   )43,      (unsigned char const   )44, 
        (unsigned char const   )45,      (unsigned char const   )46,      (unsigned char const   )47,      (unsigned char const   )48, 
        (unsigned char const   )49};
#line 533 "y.tab.c"
static unsigned char const   yyr1[74]  = 
#line 533
  {      (unsigned char const   )0,      (unsigned char const   )50,      (unsigned char const   )51,      (unsigned char const   )51, 
        (unsigned char const   )52,      (unsigned char const   )52,      (unsigned char const   )53,      (unsigned char const   )53, 
        (unsigned char const   )53,      (unsigned char const   )53,      (unsigned char const   )54,      (unsigned char const   )54, 
        (unsigned char const   )54,      (unsigned char const   )54,      (unsigned char const   )54,      (unsigned char const   )54, 
        (unsigned char const   )54,      (unsigned char const   )54,      (unsigned char const   )54,      (unsigned char const   )54, 
        (unsigned char const   )54,      (unsigned char const   )54,      (unsigned char const   )54,      (unsigned char const   )54, 
        (unsigned char const   )54,      (unsigned char const   )55,      (unsigned char const   )56,      (unsigned char const   )54, 
        (unsigned char const   )57,      (unsigned char const   )57,      (unsigned char const   )57,      (unsigned char const   )57, 
        (unsigned char const   )58,      (unsigned char const   )58,      (unsigned char const   )58,      (unsigned char const   )58, 
        (unsigned char const   )58,      (unsigned char const   )58,      (unsigned char const   )58,      (unsigned char const   )58, 
        (unsigned char const   )58,      (unsigned char const   )58,      (unsigned char const   )58,      (unsigned char const   )58, 
        (unsigned char const   )58,      (unsigned char const   )58,      (unsigned char const   )59,      (unsigned char const   )59, 
        (unsigned char const   )60,      (unsigned char const   )61,      (unsigned char const   )61,      (unsigned char const   )61, 
        (unsigned char const   )62,      (unsigned char const   )62,      (unsigned char const   )63,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )65,      (unsigned char const   )66,      (unsigned char const   )65, 
        (unsigned char const   )67,      (unsigned char const   )67,      (unsigned char const   )67,      (unsigned char const   )68, 
        (unsigned char const   )68,      (unsigned char const   )69,      (unsigned char const   )69,      (unsigned char const   )69, 
        (unsigned char const   )69,      (unsigned char const   )69,      (unsigned char const   )69,      (unsigned char const   )69, 
        (unsigned char const   )70,      (unsigned char const   )70};
#line 546 "y.tab.c"
static unsigned char const   yyr2[74]  = 
#line 546
  {      (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )1, 
        (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )2, 
        (unsigned char const   )4,      (unsigned char const   )6,      (unsigned char const   )3,      (unsigned char const   )3, 
        (unsigned char const   )3,      (unsigned char const   )4,      (unsigned char const   )6,      (unsigned char const   )3, 
        (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )7,      (unsigned char const   )5, 
        (unsigned char const   )5,      (unsigned char const   )7,      (unsigned char const   )5,      (unsigned char const   )6, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )9, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )2, 
        (unsigned char const   )1,      (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )3, 
        (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )3, 
        (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )3, 
        (unsigned char const   )2,      (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )2, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )3,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )3,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )4, 
        (unsigned char const   )2,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )2, 
        (unsigned char const   )0,      (unsigned char const   )2};
#line 561 "y.tab.c"
static unsigned char const   yydefact[154]  = 
#line 561
  {      (unsigned char const   )2,      (unsigned char const   )58,      (unsigned char const   )63,      (unsigned char const   )55, 
        (unsigned char const   )55,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )55, 
        (unsigned char const   )55,      (unsigned char const   )0,      (unsigned char const   )55,      (unsigned char const   )0, 
        (unsigned char const   )55,      (unsigned char const   )0,      (unsigned char const   )4,      (unsigned char const   )57, 
        (unsigned char const   )0,      (unsigned char const   )3,      (unsigned char const   )6,      (unsigned char const   )55, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )54, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )49,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )5,      (unsigned char const   )1, 
        (unsigned char const   )7,      (unsigned char const   )29,      (unsigned char const   )28,      (unsigned char const   )30, 
        (unsigned char const   )0,      (unsigned char const   )55,      (unsigned char const   )55,      (unsigned char const   )0, 
        (unsigned char const   )52,      (unsigned char const   )0,      (unsigned char const   )55,      (unsigned char const   )0, 
        (unsigned char const   )70,      (unsigned char const   )67,      (unsigned char const   )0,      (unsigned char const   )69, 
        (unsigned char const   )68,      (unsigned char const   )66,      (unsigned char const   )65,      (unsigned char const   )72, 
        (unsigned char const   )64,      (unsigned char const   )15,      (unsigned char const   )56,      (unsigned char const   )16, 
        (unsigned char const   )55,      (unsigned char const   )44,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )4, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )55,      (unsigned char const   )11, 
        (unsigned char const   )4,      (unsigned char const   )55,      (unsigned char const   )24,      (unsigned char const   )17, 
        (unsigned char const   )51,      (unsigned char const   )0,      (unsigned char const   )46,      (unsigned char const   )4, 
        (unsigned char const   )10,      (unsigned char const   )31,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )55,      (unsigned char const   )0,      (unsigned char const   )60, 
        (unsigned char const   )59,      (unsigned char const   )71,      (unsigned char const   )55,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )45,      (unsigned char const   )34,      (unsigned char const   )39, 
        (unsigned char const   )40,      (unsigned char const   )35,      (unsigned char const   )36,      (unsigned char const   )33, 
        (unsigned char const   )37,      (unsigned char const   )38,      (unsigned char const   )0,      (unsigned char const   )41, 
        (unsigned char const   )42,      (unsigned char const   )43,      (unsigned char const   )8,      (unsigned char const   )0, 
        (unsigned char const   )49,      (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )46,      (unsigned char const   )0,      (unsigned char const   )55,      (unsigned char const   )13, 
        (unsigned char const   )53,      (unsigned char const   )55,      (unsigned char const   )55,      (unsigned char const   )73, 
        (unsigned char const   )25,      (unsigned char const   )4,      (unsigned char const   )20,      (unsigned char const   )4, 
        (unsigned char const   )50,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )19, 
        (unsigned char const   )47,      (unsigned char const   )22,      (unsigned char const   )0,      (unsigned char const   )62, 
        (unsigned char const   )61,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )9,      (unsigned char const   )23,      (unsigned char const   )4,      (unsigned char const   )14, 
        (unsigned char const   )26,      (unsigned char const   )18,      (unsigned char const   )21,      (unsigned char const   )48, 
        (unsigned char const   )0,      (unsigned char const   )27};
#line 582 "y.tab.c"
static short const   yydefgoto[21]  = 
#line 582
  {      (short const   )-1,      (short const   )16,      (short const   )37,      (short const   )38, 
        (short const   )18,      (short const   )141,      (short const   )152,      (short const   )46, 
        (short const   )28,      (short const   )119,      (short const   )120,      (short const   )85, 
        (short const   )47,      (short const   )48,      (short const   )23,      (short const   )29, 
        (short const   )20,      (short const   )51,      (short const   )21,      (short const   )60, 
        (short const   )99};
#line 592 "y.tab.c"
static short const   yypact[154]  = 
#line 592
  {      (short const   )154,      (short const   )-59,      (short const   )-59,      (short const   )-59, 
        (short const   )-59,      (short const   )-32,      (short const   )8,      (short const   )-59, 
        (short const   )-59,      (short const   )-6,      (short const   )-59,      (short const   )-7, 
        (short const   )-59,      (short const   )8,      (short const   )154,      (short const   )-59, 
        (short const   )46,      (short const   )-59,      (short const   )154,      (short const   )49, 
        (short const   )-14,      (short const   )200,      (short const   )37,      (short const   )-6, 
        (short const   )40,      (short const   )21,      (short const   )8,      (short const   )8, 
        (short const   )120,      (short const   )22,      (short const   )43,      (short const   )19, 
        (short const   )185,      (short const   )58,      (short const   )9,      (short const   )26, 
        (short const   )135,      (short const   )25,      (short const   )-59,      (short const   )-59, 
        (short const   )-59,      (short const   )-59,      (short const   )-59,      (short const   )-59, 
        (short const   )63,      (short const   )-59,      (short const   )-59,      (short const   )67, 
        (short const   )71,      (short const   )-6,      (short const   )-59,      (short const   )66, 
        (short const   )-59,      (short const   )-59,      (short const   )38,      (short const   )-59, 
        (short const   )-59,      (short const   )-59,      (short const   )-59,      (short const   )61, 
        (short const   )-59,      (short const   )-59,      (short const   )-59,      (short const   )-59, 
        (short const   )-59,      (short const   )-59,      (short const   )155,      (short const   )8, 
        (short const   )8,      (short const   )8,      (short const   )8,      (short const   )8, 
        (short const   )8,      (short const   )8,      (short const   )8,      (short const   )154, 
        (short const   )8,      (short const   )8,      (short const   )-59,      (short const   )-59, 
        (short const   )154,      (short const   )-59,      (short const   )-59,      (short const   )-59, 
        (short const   )79,      (short const   )47,      (short const   )69,      (short const   )154, 
        (short const   )-59,      (short const   )-59,      (short const   )10,      (short const   )82, 
        (short const   )-59,      (short const   )-59,      (short const   )7,      (short const   )-59, 
        (short const   )-59,      (short const   )-59,      (short const   )-59,      (short const   )51, 
        (short const   )53,      (short const   )-59,      (short const   )52,      (short const   )24, 
        (short const   )24,      (short const   )-59,      (short const   )-59,      (short const   )52, 
        (short const   )-59,      (short const   )-59,      (short const   )62,      (short const   )239, 
        (short const   )239,      (short const   )-59,      (short const   )-59,      (short const   )87, 
        (short const   )9,      (short const   )154,      (short const   )42,      (short const   )65, 
        (short const   )69,      (short const   )68,      (short const   )-59,      (short const   )-59, 
        (short const   )-59,      (short const   )-59,      (short const   )-59,      (short const   )-59, 
        (short const   )-59,      (short const   )154,      (short const   )73,      (short const   )154, 
        (short const   )-59,      (short const   )72,      (short const   )90,      (short const   )-59, 
        (short const   )-59,      (short const   )-59,      (short const   )102,      (short const   )-59, 
        (short const   )-59,      (short const   )78,      (short const   )74,      (short const   )185, 
        (short const   )-59,      (short const   )-59,      (short const   )154,      (short const   )-59, 
        (short const   )-59,      (short const   )-59,      (short const   )-59,      (short const   )-59, 
        (short const   )75,      (short const   )-59};
#line 613 "y.tab.c"
static yysigned_char const   yypgoto[21]  = 
#line 613
  {      (yysigned_char const   )-59,      (yysigned_char const   )-59,      (yysigned_char const   )-58,      (yysigned_char const   )13, 
        (yysigned_char const   )-29,      (yysigned_char const   )-59,      (yysigned_char const   )-59,      (yysigned_char const   )28, 
        (yysigned_char const   )34,      (yysigned_char const   )-4,      (yysigned_char const   )-59,      (yysigned_char const   )12, 
        (yysigned_char const   )-43,      (yysigned_char const   )-2,      (yysigned_char const   )-59,      (yysigned_char const   )0, 
        (yysigned_char const   )-59,      (yysigned_char const   )-59,      (yysigned_char const   )-59,      (yysigned_char const   )-59, 
        (yysigned_char const   )-59};
#line 625 "y.tab.c"
static unsigned char const   yytable[256]  = 
#line 625
  {      (unsigned char const   )19,      (unsigned char const   )22,      (unsigned char const   )24,      (unsigned char const   )82, 
        (unsigned char const   )1,      (unsigned char const   )30,      (unsigned char const   )31,      (unsigned char const   )95, 
        (unsigned char const   )33,      (unsigned char const   )32,      (unsigned char const   )35,      (unsigned char const   )26, 
        (unsigned char const   )1,      (unsigned char const   )17,      (unsigned char const   )19,      (unsigned char const   )27, 
        (unsigned char const   )25,      (unsigned char const   )110,      (unsigned char const   )19,      (unsigned char const   )41, 
        (unsigned char const   )50,      (unsigned char const   )49,      (unsigned char const   )114,      (unsigned char const   )62, 
        (unsigned char const   )42,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )43, 
        (unsigned char const   )67,      (unsigned char const   )121,      (unsigned char const   )80,      (unsigned char const   )40, 
        (unsigned char const   )19,      (unsigned char const   )81,      (unsigned char const   )15,      (unsigned char const   )44, 
        (unsigned char const   )70,      (unsigned char const   )71,      (unsigned char const   )72,      (unsigned char const   )73, 
        (unsigned char const   )74,      (unsigned char const   )34,      (unsigned char const   )15,      (unsigned char const   )90, 
        (unsigned char const   )91,      (unsigned char const   )125,      (unsigned char const   )39,      (unsigned char const   )36, 
        (unsigned char const   )61,      (unsigned char const   )94,      (unsigned char const   )124,      (unsigned char const   )63, 
        (unsigned char const   )64,      (unsigned char const   )78,      (unsigned char const   )79,      (unsigned char const   )15, 
        (unsigned char const   )15,      (unsigned char const   )84,      (unsigned char const   )41,      (unsigned char const   )133, 
        (unsigned char const   )65,      (unsigned char const   )66,      (unsigned char const   )100,      (unsigned char const   )42, 
        (unsigned char const   )70,      (unsigned char const   )71,      (unsigned char const   )43,      (unsigned char const   )73, 
        (unsigned char const   )74,      (unsigned char const   )83,      (unsigned char const   )86,      (unsigned char const   )142, 
        (unsigned char const   )88,      (unsigned char const   )144,      (unsigned char const   )44,      (unsigned char const   )19, 
        (unsigned char const   )113,      (unsigned char const   )89,      (unsigned char const   )92,      (unsigned char const   )115, 
        (unsigned char const   )19,      (unsigned char const   )93,      (unsigned char const   )98,      (unsigned char const   )140, 
        (unsigned char const   )45,      (unsigned char const   )96,      (unsigned char const   )97,      (unsigned char const   )19, 
        (unsigned char const   )151,      (unsigned char const   )116,      (unsigned char const   )134,      (unsigned char const   )117, 
        (unsigned char const   )118,      (unsigned char const   )123,      (unsigned char const   )126,      (unsigned char const   )128, 
        (unsigned char const   )127,      (unsigned char const   )129,      (unsigned char const   )131,      (unsigned char const   )143, 
        (unsigned char const   )146,      (unsigned char const   )102,      (unsigned char const   )103,      (unsigned char const   )104, 
        (unsigned char const   )105,      (unsigned char const   )106,      (unsigned char const   )107,      (unsigned char const   )108, 
        (unsigned char const   )109,      (unsigned char const   )130,      (unsigned char const   )111,      (unsigned char const   )112, 
        (unsigned char const   )135,      (unsigned char const   )147,      (unsigned char const   )150,      (unsigned char const   )137, 
        (unsigned char const   )136,      (unsigned char const   )19,      (unsigned char const   )122,      (unsigned char const   )145, 
        (unsigned char const   )138,      (unsigned char const   )149,      (unsigned char const   )153,      (unsigned char const   )139, 
        (unsigned char const   )67,      (unsigned char const   )68,      (unsigned char const   )69,      (unsigned char const   )148, 
        (unsigned char const   )132,      (unsigned char const   )19,      (unsigned char const   )0,      (unsigned char const   )19, 
        (unsigned char const   )70,      (unsigned char const   )71,      (unsigned char const   )72,      (unsigned char const   )73, 
        (unsigned char const   )74,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )67, 
        (unsigned char const   )68,      (unsigned char const   )69,      (unsigned char const   )0,      (unsigned char const   )19, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )19,      (unsigned char const   )70, 
        (unsigned char const   )71,      (unsigned char const   )72,      (unsigned char const   )73,      (unsigned char const   )74, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )67, 
        (unsigned char const   )68,      (unsigned char const   )69,      (unsigned char const   )0,      (unsigned char const   )101, 
        (unsigned char const   )75,      (unsigned char const   )76,      (unsigned char const   )77,      (unsigned char const   )70, 
        (unsigned char const   )71,      (unsigned char const   )72,      (unsigned char const   )73,      (unsigned char const   )74, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )0, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )4,      (unsigned char const   )87, 
        (unsigned char const   )76,      (unsigned char const   )77,      (unsigned char const   )5,      (unsigned char const   )6, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )7,      (unsigned char const   )8, 
        (unsigned char const   )0,      (unsigned char const   )9,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )10,      (unsigned char const   )11,      (unsigned char const   )12,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )13,      (unsigned char const   )14,      (unsigned char const   )0, 
        (unsigned char const   )76,      (unsigned char const   )77,      (unsigned char const   )15,      (unsigned char const   )1, 
        (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )3, 
        (unsigned char const   )0,      (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )5,      (unsigned char const   )6,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )9,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )10, 
        (unsigned char const   )11,      (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )52, 
        (unsigned char const   )13,      (unsigned char const   )14,      (unsigned char const   )53,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )15,      (unsigned char const   )54,      (unsigned char const   )0, 
        (unsigned char const   )55,      (unsigned char const   )56,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )57,      (unsigned char const   )58,      (unsigned char const   )67, 
        (unsigned char const   )68,      (unsigned char const   )69,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )59,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )70, 
        (unsigned char const   )71,      (unsigned char const   )72,      (unsigned char const   )73,      (unsigned char const   )74};
#line 655 "y.tab.c"
static short const   yycheck[256]  = 
#line 655
  {      (short const   )0,      (short const   )3,      (short const   )4,      (short const   )32, 
        (short const   )18,      (short const   )7,      (short const   )8,      (short const   )50, 
        (short const   )10,      (short const   )9,      (short const   )12,      (short const   )3, 
        (short const   )18,      (short const   )0,      (short const   )14,      (short const   )7, 
        (short const   )48,      (short const   )75,      (short const   )18,      (short const   )9, 
        (short const   )20,      (short const   )35,      (short const   )80,      (short const   )23, 
        (short const   )14,      (short const   )18,      (short const   )18,      (short const   )17, 
        (short const   )4,      (short const   )87,      (short const   )11,      (short const   )18, 
        (short const   )32,      (short const   )14,      (short const   )48,      (short const   )25, 
        (short const   )12,      (short const   )13,      (short const   )14,      (short const   )15, 
        (short const   )16,      (short const   )48,      (short const   )48,      (short const   )45, 
        (short const   )46,      (short const   )38,      (short const   )0,      (short const   )13, 
        (short const   )11,      (short const   )49,      (short const   )93,      (short const   )11, 
        (short const   )31,      (short const   )31,      (short const   )11,      (short const   )48, 
        (short const   )48,      (short const   )48,      (short const   )9,      (short const   )117, 
        (short const   )26,      (short const   )27,      (short const   )64,      (short const   )14, 
        (short const   )12,      (short const   )13,      (short const   )17,      (short const   )15, 
        (short const   )16,      (short const   )11,      (short const   )44,      (short const   )129, 
        (short const   )47,      (short const   )131,      (short const   )25,      (short const   )75, 
        (short const   )78,      (short const   )14,      (short const   )11,      (short const   )81, 
        (short const   )80,      (short const   )10,      (short const   )21,      (short const   )126, 
        (short const   )35,      (short const   )19,      (short const   )48,      (short const   )87, 
        (short const   )146,      (short const   )10,      (short const   )48,      (short const   )44, 
        (short const   )23,      (short const   )11,      (short const   )94,      (short const   )44, 
        (short const   )98,      (short const   )44,      (short const   )11,      (short const   )26, 
        (short const   )10,      (short const   )67,      (short const   )68,      (short const   )69, 
        (short const   )70,      (short const   )71,      (short const   )72,      (short const   )73, 
        (short const   )74,      (short const   )47,      (short const   )76,      (short const   )77, 
        (short const   )47,      (short const   )11,      (short const   )143,      (short const   )47, 
        (short const   )120,      (short const   )117,      (short const   )90,      (short const   )47, 
        (short const   )122,      (short const   )47,      (short const   )47,      (short const   )125, 
        (short const   )4,      (short const   )5,      (short const   )6,      (short const   )49, 
        (short const   )116,      (short const   )129,      (short const   )-1,      (short const   )131, 
        (short const   )12,      (short const   )13,      (short const   )14,      (short const   )15, 
        (short const   )16,      (short const   )-1,      (short const   )-1,      (short const   )4, 
        (short const   )5,      (short const   )6,      (short const   )-1,      (short const   )143, 
        (short const   )-1,      (short const   )-1,      (short const   )146,      (short const   )12, 
        (short const   )13,      (short const   )14,      (short const   )15,      (short const   )16, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )4, 
        (short const   )5,      (short const   )6,      (short const   )-1,      (short const   )8, 
        (short const   )44,      (short const   )45,      (short const   )46,      (short const   )12, 
        (short const   )13,      (short const   )14,      (short const   )15,      (short const   )16, 
        (short const   )18,      (short const   )-1,      (short const   )20,      (short const   )-1, 
        (short const   )22,      (short const   )-1,      (short const   )24,      (short const   )44, 
        (short const   )45,      (short const   )46,      (short const   )28,      (short const   )29, 
        (short const   )-1,      (short const   )-1,      (short const   )32,      (short const   )33, 
        (short const   )-1,      (short const   )35,      (short const   )-1,      (short const   )-1, 
        (short const   )38,      (short const   )39,      (short const   )40,      (short const   )-1, 
        (short const   )-1,      (short const   )43,      (short const   )44,      (short const   )-1, 
        (short const   )45,      (short const   )46,      (short const   )48,      (short const   )18, 
        (short const   )-1,      (short const   )20,      (short const   )-1,      (short const   )22, 
        (short const   )-1,      (short const   )24,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )28,      (short const   )29,      (short const   )-1, 
        (short const   )-1,      (short const   )32,      (short const   )-1,      (short const   )-1, 
        (short const   )35,      (short const   )-1,      (short const   )-1,      (short const   )38, 
        (short const   )39,      (short const   )40,      (short const   )-1,      (short const   )27, 
        (short const   )43,      (short const   )44,      (short const   )30,      (short const   )-1, 
        (short const   )-1,      (short const   )48,      (short const   )34,      (short const   )-1, 
        (short const   )36,      (short const   )37,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )41,      (short const   )42,      (short const   )4, 
        (short const   )5,      (short const   )6,      (short const   )-1,      (short const   )-1, 
        (short const   )48,      (short const   )-1,      (short const   )-1,      (short const   )12, 
        (short const   )13,      (short const   )14,      (short const   )15,      (short const   )16};
#line 687 "y.tab.c"
static unsigned char const   yystos[154]  = 
#line 687
  {      (unsigned char const   )0,      (unsigned char const   )18,      (unsigned char const   )20,      (unsigned char const   )22, 
        (unsigned char const   )24,      (unsigned char const   )28,      (unsigned char const   )29,      (unsigned char const   )32, 
        (unsigned char const   )33,      (unsigned char const   )35,      (unsigned char const   )38,      (unsigned char const   )39, 
        (unsigned char const   )40,      (unsigned char const   )43,      (unsigned char const   )44,      (unsigned char const   )48, 
        (unsigned char const   )51,      (unsigned char const   )53,      (unsigned char const   )54,      (unsigned char const   )65, 
        (unsigned char const   )66,      (unsigned char const   )68,      (unsigned char const   )63,      (unsigned char const   )64, 
        (unsigned char const   )63,      (unsigned char const   )48,      (unsigned char const   )3,      (unsigned char const   )7, 
        (unsigned char const   )58,      (unsigned char const   )65,      (unsigned char const   )63,      (unsigned char const   )63, 
        (unsigned char const   )65,      (unsigned char const   )63,      (unsigned char const   )48,      (unsigned char const   )63, 
        (unsigned char const   )58,      (unsigned char const   )52,      (unsigned char const   )53,      (unsigned char const   )0, 
        (unsigned char const   )53,      (unsigned char const   )9,      (unsigned char const   )14,      (unsigned char const   )17, 
        (unsigned char const   )25,      (unsigned char const   )35,      (unsigned char const   )57,      (unsigned char const   )62, 
        (unsigned char const   )63,      (unsigned char const   )35,      (unsigned char const   )65,      (unsigned char const   )67, 
        (unsigned char const   )27,      (unsigned char const   )30,      (unsigned char const   )34,      (unsigned char const   )36, 
        (unsigned char const   )37,      (unsigned char const   )41,      (unsigned char const   )42,      (unsigned char const   )48, 
        (unsigned char const   )69,      (unsigned char const   )11,      (unsigned char const   )65,      (unsigned char const   )11, 
        (unsigned char const   )31,      (unsigned char const   )58,      (unsigned char const   )58,      (unsigned char const   )4, 
        (unsigned char const   )5,      (unsigned char const   )6,      (unsigned char const   )12,      (unsigned char const   )13, 
        (unsigned char const   )14,      (unsigned char const   )15,      (unsigned char const   )16,      (unsigned char const   )44, 
        (unsigned char const   )45,      (unsigned char const   )46,      (unsigned char const   )31,      (unsigned char const   )11, 
        (unsigned char const   )11,      (unsigned char const   )14,      (unsigned char const   )54,      (unsigned char const   )11, 
        (unsigned char const   )48,      (unsigned char const   )61,      (unsigned char const   )44,      (unsigned char const   )44, 
        (unsigned char const   )47,      (unsigned char const   )14,      (unsigned char const   )63,      (unsigned char const   )63, 
        (unsigned char const   )11,      (unsigned char const   )10,      (unsigned char const   )65,      (unsigned char const   )62, 
        (unsigned char const   )19,      (unsigned char const   )48,      (unsigned char const   )21,      (unsigned char const   )70, 
        (unsigned char const   )63,      (unsigned char const   )8,      (unsigned char const   )58,      (unsigned char const   )58, 
        (unsigned char const   )58,      (unsigned char const   )58,      (unsigned char const   )58,      (unsigned char const   )58, 
        (unsigned char const   )58,      (unsigned char const   )58,      (unsigned char const   )52,      (unsigned char const   )58, 
        (unsigned char const   )58,      (unsigned char const   )63,      (unsigned char const   )52,      (unsigned char const   )63, 
        (unsigned char const   )10,      (unsigned char const   )44,      (unsigned char const   )23,      (unsigned char const   )59, 
        (unsigned char const   )60,      (unsigned char const   )52,      (unsigned char const   )57,      (unsigned char const   )11, 
        (unsigned char const   )62,      (unsigned char const   )38,      (unsigned char const   )65,      (unsigned char const   )63, 
        (unsigned char const   )44,      (unsigned char const   )44,      (unsigned char const   )47,      (unsigned char const   )11, 
        (unsigned char const   )61,      (unsigned char const   )52,      (unsigned char const   )48,      (unsigned char const   )47, 
        (unsigned char const   )59,      (unsigned char const   )47,      (unsigned char const   )63,      (unsigned char const   )63, 
        (unsigned char const   )62,      (unsigned char const   )55,      (unsigned char const   )52,      (unsigned char const   )26, 
        (unsigned char const   )52,      (unsigned char const   )47,      (unsigned char const   )10,      (unsigned char const   )11, 
        (unsigned char const   )49,      (unsigned char const   )47,      (unsigned char const   )54,      (unsigned char const   )52, 
        (unsigned char const   )56,      (unsigned char const   )47};
#line 1054 "y.tab.c"
static void yydestruct(char const   *yymsg , int yytype , YYSYMBOL *yyvaluep ) 
{ 


  {
#line 1067
  if (! yymsg) {
#line 1068
    yymsg = "Deleting";
  }
  {
#line 1074
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1075
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1077
  return;
}
}
#line 1099 "y.tab.c"
int yychar  ;
#line 1105 "y.tab.c"
int yynerrs  ;
#line 1122 "y.tab.c"
int yyparse(void) 
{ 
  int yystate ;
  int yyn ;
  int yyresult ;
  int yyerrstatus ;
  int yytoken ;
  short yyssa[200] ;
  short *yyss ;
  short *yyssp ;
  YYSYMBOL yyvsa[200] ;
  YYSYMBOL *yyvs ;
  YYSYMBOL *yyvsp ;
  unsigned long yystacksize ;
  YYSYMBOL yyval ;
  int yylen ;
  unsigned long yysize ;
  short *yyss1 ;
  union yyalloc *yyptr ;
  void *tmp ;
  unsigned long yynewbytes ;
  unsigned long yynewbytes___0 ;
  PARSE *tmp___0 ;
  PARSE *tmp___1 ;
  PARSE *tmp___2 ;
  PARSE *tmp___3 ;
  PARSE *tmp___4 ;
  int tmp___5 ;

  {
#line 1138
  yytoken = 0;
#line 1150
  yyss = yyssa;
#line 1155
  yyvs = yyvsa;
#line 1162
  yystacksize = 200UL;
#line 1175
  yystate = 0;
#line 1176
  yyerrstatus = 0;
#line 1177
  yynerrs = 0;
#line 1178
  yychar = -2;
#line 1185
  yyssp = yyss;
#line 1186
  yyvsp = yyvs;
#line 1188
  goto yysetstate;
  yynewstate: 
#line 1197
  yyssp ++;
  yysetstate: 
#line 1200
  *yyssp = (short )yystate;
#line 1202
  if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1205
    yysize = (unsigned long )((yyssp - yyss) + 1L);
#line 1234
    if (10000UL <= yystacksize) {
#line 1235
      goto yyexhaustedlab;
    }
#line 1236
    yystacksize *= 2UL;
#line 1237
    if (10000UL < yystacksize) {
#line 1238
      yystacksize = 10000UL;
    }
    {
#line 1241
    yyss1 = yyss;
#line 1242
    tmp = malloc(yystacksize * (sizeof(short ) + sizeof(YYSYMBOL )) + (sizeof(union yyalloc ) - 1UL));
#line 1242
    yyptr = (union yyalloc *)tmp;
    }
#line 1244
    if (! yyptr) {
#line 1245
      goto yyexhaustedlab;
    }
    {
#line 1246
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1246
      __builtin_memcpy((void *)(& yyptr->yyss), (void const   *)yyss, yysize * sizeof(*yyss));
#line 1246
      yyss = & yyptr->yyss;
#line 1246
      yynewbytes = yystacksize * sizeof(*yyss) + (sizeof(union yyalloc ) - 1UL);
#line 1246
      yyptr += yynewbytes / sizeof(*yyptr);
      }
#line 1246
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1247
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1247
      __builtin_memcpy((void *)(& yyptr->yyvs), (void const   *)yyvs, yysize * sizeof(*yyvs));
#line 1247
      yyvs = & yyptr->yyvs;
#line 1247
      yynewbytes___0 = yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc ) - 1UL);
#line 1247
      yyptr += yynewbytes___0 / sizeof(*yyptr);
      }
#line 1247
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1250
    if ((unsigned long )yyss1 != (unsigned long )(yyssa)) {
      {
#line 1251
      free((void *)yyss1);
      }
    }
#line 1256
    yyssp = (yyss + yysize) - 1;
#line 1257
    yyvsp = (yyvs + yysize) - 1;
#line 1263
    if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1264
      goto yyabortlab;
    }
  }
#line 1269
  goto yybackup;
  yybackup: 
#line 1282
  yyn = (int )yypact[yystate];
#line 1283
  if (yyn == -59) {
#line 1284
    goto yydefault;
  }
#line 1289
  if (yychar == -2) {
    {
#line 1292
    yychar = yylex();
    }
  }
#line 1295
  if (yychar <= 0) {
#line 1297
    yytoken = 0;
#line 1297
    yychar = yytoken;
  } else
#line 1302
  if ((unsigned int )yychar <= 304U) {
#line 1302
    yytoken = (int )yytranslate[yychar];
  } else {
#line 1302
    yytoken = 2;
  }
#line 1308
  yyn += yytoken;
#line 1309
  if (yyn < 0) {
#line 1310
    goto yydefault;
  } else
#line 1309
  if (255 < yyn) {
#line 1310
    goto yydefault;
  } else
#line 1309
  if ((int const   )yycheck[yyn] != (int const   )yytoken) {
#line 1310
    goto yydefault;
  }
#line 1311
  yyn = (int )yytable[yyn];
#line 1312
  if (yyn <= 0) {
#line 1314
    if (yyn == 0) {
#line 1315
      goto yyerrlab;
    } else
#line 1314
    if (yyn == -1) {
#line 1315
      goto yyerrlab;
    }
#line 1316
    yyn = - yyn;
#line 1317
    goto yyreduce;
  }
#line 1320
  if (yyn == 39) {
#line 1321
    goto yyacceptlab;
  }
#line 1327
  if (yychar != 0) {
#line 1328
    yychar = -2;
  }
#line 1330
  yyvsp ++;
#line 1330
  *yyvsp = yylval;
#line 1335
  if (yyerrstatus) {
#line 1336
    yyerrstatus --;
  }
#line 1338
  yystate = yyn;
#line 1339
  goto yynewstate;
  yydefault: 
#line 1346
  yyn = (int )yydefact[yystate];
#line 1347
  if (yyn == 0) {
#line 1348
    goto yyerrlab;
  }
#line 1349
  goto yyreduce;
  yyreduce: 
#line 1357
  yylen = (int )yyr2[yyn];
#line 1367
  yyval = *(yyvsp + (1 - yylen));
  {
#line 1373
  if (yyn == 3) {
#line 1373
    goto case_3;
  }
#line 133
  if (yyn == 4) {
#line 133 "jamgram.y"
    goto case_4;
  }
#line 144
  if (yyn == 5) {
#line 144
    goto case_5;
  }
#line 146
  if (yyn == 6) {
#line 146
    goto case_6;
  }
#line 150
  if (yyn == 7) {
#line 150
    goto case_7;
  }
#line 152
  if (yyn == 8) {
#line 152
    goto case_8;
  }
#line 154
  if (yyn == 9) {
#line 154
    goto case_9;
  }
#line 156
  if (yyn == 10) {
#line 156
    goto case_10;
  }
#line 160
  if (yyn == 11) {
#line 160
    goto case_11;
  }
#line 162
  if (yyn == 12) {
#line 162
    goto case_12;
  }
#line 164
  if (yyn == 13) {
#line 164
    goto case_13;
  }
#line 166
  if (yyn == 14) {
#line 166
    goto case_14;
  }
#line 168
  if (yyn == 15) {
#line 168
    goto case_15;
  }
#line 170
  if (yyn == 16) {
#line 170
    goto case_16;
  }
#line 172
  if (yyn == 17) {
#line 172
    goto case_17;
  }
#line 174
  if (yyn == 18) {
#line 174
    goto case_18;
  }
#line 176
  if (yyn == 19) {
#line 176
    goto case_19;
  }
#line 178
  if (yyn == 20) {
#line 178
    goto case_20;
  }
#line 180
  if (yyn == 21) {
#line 180
    goto case_21;
  }
#line 182
  if (yyn == 22) {
#line 182
    goto case_22;
  }
#line 184
  if (yyn == 23) {
#line 184
    goto case_23;
  }
#line 186
  if (yyn == 24) {
#line 186
    goto case_24;
  }
#line 188
  if (yyn == 25) {
#line 188
    goto case_25;
  }
#line 190
  if (yyn == 26) {
#line 190
    goto case_26;
  }
#line 192
  if (yyn == 27) {
#line 192
    goto case_27;
  }
#line 194
  if (yyn == 28) {
#line 194
    goto case_28;
  }
#line 202
  if (yyn == 29) {
#line 202
    goto case_29;
  }
#line 204
  if (yyn == 30) {
#line 204
    goto case_30;
  }
#line 206
  if (yyn == 31) {
#line 206
    goto case_31;
  }
#line 208
  if (yyn == 32) {
#line 208
    goto case_32;
  }
#line 216
  if (yyn == 33) {
#line 216
    goto case_33;
  }
#line 218
  if (yyn == 34) {
#line 218
    goto case_34;
  }
#line 220
  if (yyn == 35) {
#line 220
    goto case_35;
  }
#line 222
  if (yyn == 36) {
#line 222
    goto case_36;
  }
#line 224
  if (yyn == 37) {
#line 224
    goto case_37;
  }
#line 226
  if (yyn == 38) {
#line 226
    goto case_38;
  }
#line 228
  if (yyn == 39) {
#line 228
    goto case_39;
  }
#line 230
  if (yyn == 40) {
#line 230
    goto case_40;
  }
#line 232
  if (yyn == 41) {
#line 232
    goto case_41;
  }
#line 234
  if (yyn == 42) {
#line 234
    goto case_42;
  }
#line 236
  if (yyn == 43) {
#line 236
    goto case_43;
  }
#line 238
  if (yyn == 44) {
#line 238
    goto case_44;
  }
#line 240
  if (yyn == 45) {
#line 240
    goto case_45;
  }
#line 242
  if (yyn == 46) {
#line 242
    goto case_46;
  }
#line 252
  if (yyn == 47) {
#line 252
    goto case_47;
  }
#line 254
  if (yyn == 48) {
#line 254
    goto case_48;
  }
#line 258
  if (yyn == 49) {
#line 258
    goto case_49;
  }
#line 267
  if (yyn == 50) {
#line 267
    goto case_50;
  }
#line 269
  if (yyn == 51) {
#line 269
    goto case_51;
  }
#line 271
  if (yyn == 52) {
#line 271
    goto case_52;
  }
#line 280
  if (yyn == 53) {
#line 280
    goto case_53;
  }
#line 282
  if (yyn == 54) {
#line 282
    goto case_54;
  }
#line 292
  if (yyn == 55) {
#line 292
    goto case_55;
  }
#line 296
  if (yyn == 56) {
#line 296
    goto case_56;
  }
#line 298
  if (yyn == 57) {
#line 298
    goto case_57;
  }
#line 302
  if (yyn == 58) {
#line 302
    goto case_58;
  }
#line 303
  if (yyn == 59) {
#line 303
    goto case_59;
  }
#line 304
  if (yyn == 60) {
#line 304
    goto case_60;
  }
#line 313
  if (yyn == 61) {
#line 313
    goto case_61;
  }
#line 315
  if (yyn == 62) {
#line 315
    goto case_62;
  }
#line 317
  if (yyn == 63) {
#line 317
    goto case_63;
  }
#line 326
  if (yyn == 64) {
#line 326
    goto case_64;
  }
#line 328
  if (yyn == 65) {
#line 328
    goto case_65;
  }
#line 332
  if (yyn == 66) {
#line 332
    goto case_66;
  }
#line 334
  if (yyn == 67) {
#line 334
    goto case_67;
  }
#line 336
  if (yyn == 68) {
#line 336
    goto case_68;
  }
#line 338
  if (yyn == 69) {
#line 338
    goto case_69;
  }
#line 340
  if (yyn == 70) {
#line 340
    goto case_70;
  }
#line 342
  if (yyn == 71) {
#line 342
    goto case_71;
  }
#line 344
  if (yyn == 72) {
#line 344
    goto case_72;
  }
#line 353
  if (yyn == 73) {
#line 353
    goto case_73;
  }
#line 356
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 130
  parse_save((yyvsp + 0)->parse);
  }
#line 131
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 141
  yyval.parse = parse_make(& compile_null, (PARSE *)0, (PARSE *)0, (PARSE *)0, (char const   *)((char *)0),
                           (char const   *)((char *)0), 0);
  }
#line 142
  goto switch_break;
  case_5: /* CIL Label */ 
#line 143
  yyval.parse = (yyvsp + 0)->parse;
#line 144
  goto switch_break;
  case_6: /* CIL Label */ 
#line 147
  yyval.parse = (yyvsp + 0)->parse;
#line 148
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 149
  yyval.parse = parse_make(& compile_rules, (yyvsp + -1)->parse, (yyvsp + 0)->parse,
                           (PARSE *)0, (char const   *)((char *)0), (char const   *)((char *)0),
                           0);
  }
#line 150
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 151
  tmp___0 = parse_make(& compile_null, (PARSE *)0, (PARSE *)0, (PARSE *)0, (char const   *)((char *)0),
                       (char const   *)((char *)0), 0);
#line 151
  yyval.parse = parse_make(& compile_local, (yyvsp + -2)->parse, tmp___0, (yyvsp + 0)->parse,
                           (char const   *)((char *)0), (char const   *)((char *)0),
                           0);
  }
#line 152
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 153
  yyval.parse = parse_make(& compile_local, (yyvsp + -4)->parse, (yyvsp + -2)->parse,
                           (yyvsp + 0)->parse, (char const   *)((char *)0), (char const   *)((char *)0),
                           0);
  }
#line 154
  goto switch_break;
  case_10: /* CIL Label */ 
#line 157
  yyval.parse = (yyvsp + -1)->parse;
#line 158
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 159
  yyval.parse = parse_make(& compile_include, (yyvsp + -1)->parse, (PARSE *)0, (PARSE *)0,
                           (char const   *)((char *)0), (char const   *)((char *)0),
                           0);
  }
#line 160
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 161
  yyval.parse = parse_make(& compile_rule, (yyvsp + -2)->parse, (yyvsp + -1)->parse,
                           (PARSE *)0, (char const   *)((char *)0), (char const   *)((char *)0),
                           0);
  }
#line 162
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 163
  yyval.parse = parse_make(& compile_set, (yyvsp + -3)->parse, (yyvsp + -1)->parse,
                           (PARSE *)0, (char const   *)((char *)0), (char const   *)((char *)0),
                           (yyvsp + -2)->number);
  }
#line 164
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 165
  yyval.parse = parse_make(& compile_settings, (yyvsp + -5)->parse, (yyvsp + -3)->parse,
                           (yyvsp + -1)->parse, (char const   *)((char *)0), (char const   *)((char *)0),
                           (yyvsp + -2)->number);
  }
#line 166
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 167
  yyval.parse = parse_make(& compile_break, (yyvsp + -1)->parse, (PARSE *)0, (PARSE *)0,
                           (char const   *)((char *)0), (char const   *)((char *)0),
                           1);
  }
#line 168
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 169
  yyval.parse = parse_make(& compile_break, (yyvsp + -1)->parse, (PARSE *)0, (PARSE *)0,
                           (char const   *)((char *)0), (char const   *)((char *)0),
                           2);
  }
#line 170
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 171
  yyval.parse = parse_make(& compile_break, (yyvsp + -1)->parse, (PARSE *)0, (PARSE *)0,
                           (char const   *)((char *)0), (char const   *)((char *)0),
                           3);
  }
#line 172
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 173
  yyval.parse = parse_make(& compile_foreach, (yyvsp + -3)->parse, (yyvsp + -1)->parse,
                           (PARSE *)0, (yyvsp + -5)->string, (char const   *)((char *)0),
                           0);
  }
#line 174
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 175
  yyval.parse = parse_make(& compile_switch, (yyvsp + -3)->parse, (yyvsp + -1)->parse,
                           (PARSE *)0, (char const   *)((char *)0), (char const   *)((char *)0),
                           0);
  }
#line 176
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 177
  tmp___1 = parse_make(& compile_null, (PARSE *)0, (PARSE *)0, (PARSE *)0, (char const   *)((char *)0),
                       (char const   *)((char *)0), 0);
#line 177
  yyval.parse = parse_make(& compile_if, (yyvsp + -3)->parse, (yyvsp + -1)->parse,
                           tmp___1, (char const   *)((char *)0), (char const   *)((char *)0),
                           0);
  }
#line 178
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 179
  yyval.parse = parse_make(& compile_if, (yyvsp + -5)->parse, (yyvsp + -3)->parse,
                           (yyvsp + 0)->parse, (char const   *)((char *)0), (char const   *)((char *)0),
                           0);
  }
#line 180
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 181
  yyval.parse = parse_make(& compile_while, (yyvsp + -3)->parse, (yyvsp + -1)->parse,
                           (PARSE *)0, (char const   *)((char *)0), (char const   *)((char *)0),
                           0);
  }
#line 182
  goto switch_break;
  case_23: /* CIL Label */ 
  {
#line 183
  yyval.parse = parse_make(& compile_setcomp, (yyvsp + -3)->parse, (yyvsp + -1)->parse,
                           (PARSE *)0, (yyvsp + -4)->string, (char const   *)((char *)0),
                           0);
  }
#line 184
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 185
  yyval.parse = parse_make(& compile_on, (yyvsp + -1)->parse, (yyvsp + 0)->parse,
                           (PARSE *)0, (char const   *)((char *)0), (char const   *)((char *)0),
                           0);
  }
#line 186
  goto switch_break;
  case_25: /* CIL Label */ 
  {
#line 187
  yymode(1);
  }
#line 188
  goto switch_break;
  case_26: /* CIL Label */ 
  {
#line 189
  yymode(0);
  }
#line 190
  goto switch_break;
  case_27: /* CIL Label */ 
  {
#line 191
  yyval.parse = parse_make(& compile_setexec, (yyvsp + -5)->parse, (PARSE *)0, (PARSE *)0,
                           (yyvsp + -6)->string, (yyvsp + -2)->string, (yyvsp + -7)->number);
  }
#line 192
  goto switch_break;
  case_28: /* CIL Label */ 
#line 199
  yyval.number = 0;
#line 200
  goto switch_break;
  case_29: /* CIL Label */ 
#line 201
  yyval.number = 1;
#line 202
  goto switch_break;
  case_30: /* CIL Label */ 
#line 203
  yyval.number = 2;
#line 204
  goto switch_break;
  case_31: /* CIL Label */ 
#line 205
  yyval.number = 2;
#line 206
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 213
  tmp___2 = parse_make(& compile_null, (PARSE *)0, (PARSE *)0, (PARSE *)0, (char const   *)((char *)0),
                       (char const   *)((char *)0), 0);
#line 213
  yyval.parse = parse_make(& compile_eval, (yyvsp + 0)->parse, tmp___2, (PARSE *)0,
                           (char const   *)((char *)0), (char const   *)((char *)0),
                           3);
  }
#line 214
  goto switch_break;
  case_33: /* CIL Label */ 
  {
#line 215
  yyval.parse = parse_make(& compile_eval, (yyvsp + -2)->parse, (yyvsp + 0)->parse,
                           (PARSE *)0, (char const   *)((char *)0), (char const   *)((char *)0),
                           4);
  }
#line 216
  goto switch_break;
  case_34: /* CIL Label */ 
  {
#line 217
  yyval.parse = parse_make(& compile_eval, (yyvsp + -2)->parse, (yyvsp + 0)->parse,
                           (PARSE *)0, (char const   *)((char *)0), (char const   *)((char *)0),
                           5);
  }
#line 218
  goto switch_break;
  case_35: /* CIL Label */ 
  {
#line 219
  yyval.parse = parse_make(& compile_eval, (yyvsp + -2)->parse, (yyvsp + 0)->parse,
                           (PARSE *)0, (char const   *)((char *)0), (char const   *)((char *)0),
                           6);
  }
#line 220
  goto switch_break;
  case_36: /* CIL Label */ 
  {
#line 221
  yyval.parse = parse_make(& compile_eval, (yyvsp + -2)->parse, (yyvsp + 0)->parse,
                           (PARSE *)0, (char const   *)((char *)0), (char const   *)((char *)0),
                           7);
  }
#line 222
  goto switch_break;
  case_37: /* CIL Label */ 
  {
#line 223
  yyval.parse = parse_make(& compile_eval, (yyvsp + -2)->parse, (yyvsp + 0)->parse,
                           (PARSE *)0, (char const   *)((char *)0), (char const   *)((char *)0),
                           8);
  }
#line 224
  goto switch_break;
  case_38: /* CIL Label */ 
  {
#line 225
  yyval.parse = parse_make(& compile_eval, (yyvsp + -2)->parse, (yyvsp + 0)->parse,
                           (PARSE *)0, (char const   *)((char *)0), (char const   *)((char *)0),
                           9);
  }
#line 226
  goto switch_break;
  case_39: /* CIL Label */ 
  {
#line 227
  yyval.parse = parse_make(& compile_eval, (yyvsp + -2)->parse, (yyvsp + 0)->parse,
                           (PARSE *)0, (char const   *)((char *)0), (char const   *)((char *)0),
                           1);
  }
#line 228
  goto switch_break;
  case_40: /* CIL Label */ 
  {
#line 229
  yyval.parse = parse_make(& compile_eval, (yyvsp + -2)->parse, (yyvsp + 0)->parse,
                           (PARSE *)0, (char const   *)((char *)0), (char const   *)((char *)0),
                           1);
  }
#line 230
  goto switch_break;
  case_41: /* CIL Label */ 
  {
#line 231
  yyval.parse = parse_make(& compile_eval, (yyvsp + -2)->parse, (yyvsp + 0)->parse,
                           (PARSE *)0, (char const   *)((char *)0), (char const   *)((char *)0),
                           2);
  }
#line 232
  goto switch_break;
  case_42: /* CIL Label */ 
  {
#line 233
  yyval.parse = parse_make(& compile_eval, (yyvsp + -2)->parse, (yyvsp + 0)->parse,
                           (PARSE *)0, (char const   *)((char *)0), (char const   *)((char *)0),
                           2);
  }
#line 234
  goto switch_break;
  case_43: /* CIL Label */ 
  {
#line 235
  yyval.parse = parse_make(& compile_eval, (yyvsp + -2)->parse, (yyvsp + 0)->parse,
                           (PARSE *)0, (char const   *)((char *)0), (char const   *)((char *)0),
                           10);
  }
#line 236
  goto switch_break;
  case_44: /* CIL Label */ 
  {
#line 237
  tmp___3 = parse_make(& compile_null, (PARSE *)0, (PARSE *)0, (PARSE *)0, (char const   *)((char *)0),
                       (char const   *)((char *)0), 0);
#line 237
  yyval.parse = parse_make(& compile_eval, (yyvsp + 0)->parse, tmp___3, (PARSE *)0,
                           (char const   *)((char *)0), (char const   *)((char *)0),
                           0);
  }
#line 238
  goto switch_break;
  case_45: /* CIL Label */ 
#line 239
  yyval.parse = (yyvsp + -1)->parse;
#line 240
  goto switch_break;
  case_46: /* CIL Label */ 
#line 249
  yyval.parse = (PARSE *)0;
#line 250
  goto switch_break;
  case_47: /* CIL Label */ 
  {
#line 251
  yyval.parse = parse_make((LIST *(*)(PARSE * , LOL * , int * ))0, (yyvsp + -1)->parse,
                           (yyvsp + 0)->parse, (PARSE *)0, (char const   *)((char *)0),
                           (char const   *)((char *)0), 0);
  }
#line 252
  goto switch_break;
  case_48: /* CIL Label */ 
  {
#line 255
  yyval.parse = parse_make((LIST *(*)(PARSE * , LOL * , int * ))0, (yyvsp + 0)->parse,
                           (PARSE *)0, (PARSE *)0, (yyvsp + -2)->string, (char const   *)((char *)0),
                           0);
  }
#line 256
  goto switch_break;
  case_49: /* CIL Label */ 
#line 264
  yyval.parse = (PARSE *)0;
#line 265
  goto switch_break;
  case_50: /* CIL Label */ 
  {
#line 266
  yyval.parse = parse_make((LIST *(*)(PARSE * , LOL * , int * ))0, (yyvsp + 0)->parse,
                           (PARSE *)0, (PARSE *)0, (yyvsp + -2)->string, (char const   *)((char *)0),
                           0);
  }
#line 267
  goto switch_break;
  case_51: /* CIL Label */ 
  {
#line 268
  yyval.parse = parse_make((LIST *(*)(PARSE * , LOL * , int * ))0, (PARSE *)0, (PARSE *)0,
                           (PARSE *)0, (yyvsp + 0)->string, (char const   *)((char *)0),
                           0);
  }
#line 269
  goto switch_break;
  case_52: /* CIL Label */ 
  {
#line 277
  yyval.parse = parse_make((LIST *(*)(PARSE * , LOL * , int * ))0, (PARSE *)0, (yyvsp + 0)->parse,
                           (PARSE *)0, (char const   *)((char *)0), (char const   *)((char *)0),
                           0);
  }
#line 278
  goto switch_break;
  case_53: /* CIL Label */ 
  {
#line 279
  yyval.parse = parse_make((LIST *(*)(PARSE * , LOL * , int * ))0, (yyvsp + 0)->parse,
                           (yyvsp + -2)->parse, (PARSE *)0, (char const   *)((char *)0),
                           (char const   *)((char *)0), 0);
  }
#line 280
  goto switch_break;
  case_54: /* CIL Label */ 
  {
#line 289
  yyval.parse = (yyvsp + 0)->parse;
#line 289
  yymode(0);
  }
#line 290
  goto switch_break;
  case_55: /* CIL Label */ 
  {
#line 293
  yyval.parse = parse_make(& compile_null, (PARSE *)0, (PARSE *)0, (PARSE *)0, (char const   *)((char *)0),
                           (char const   *)((char *)0), 0);
#line 293
  yymode(2);
  }
#line 294
  goto switch_break;
  case_56: /* CIL Label */ 
  {
#line 295
  yyval.parse = parse_make(& compile_append, (yyvsp + -1)->parse, (yyvsp + 0)->parse,
                           (PARSE *)0, (char const   *)((char *)0), (char const   *)((char *)0),
                           0);
  }
#line 296
  goto switch_break;
  case_57: /* CIL Label */ 
  {
#line 299
  yyval.parse = parse_make(& compile_list, (PARSE *)0, (PARSE *)0, (PARSE *)0, (yyvsp + 0)->string,
                           (char const   *)((char *)0), 0);
  }
#line 300
  goto switch_break;
  case_58: /* CIL Label */ 
  {
#line 300
  yymode(0);
  }
#line 301
  goto switch_break;
  case_59: /* CIL Label */ 
#line 301
  yyval.parse = (yyvsp + -1)->parse;
#line 302
  goto switch_break;
  case_60: /* CIL Label */ 
  {
#line 310
  yyval.parse = parse_make(& compile_rule, (yyvsp + -1)->parse, (yyvsp + 0)->parse,
                           (PARSE *)0, (char const   *)((char *)0), (char const   *)((char *)0),
                           0);
  }
#line 311
  goto switch_break;
  case_61: /* CIL Label */ 
  {
#line 312
  tmp___4 = parse_make(& compile_rule, (yyvsp + -1)->parse, (yyvsp + 0)->parse, (PARSE *)0,
                       (char const   *)((char *)0), (char const   *)((char *)0), 0);
#line 312
  yyval.parse = parse_make(& compile_on, (yyvsp + -2)->parse, tmp___4, (PARSE *)0,
                           (char const   *)((char *)0), (char const   *)((char *)0),
                           0);
  }
#line 313
  goto switch_break;
  case_62: /* CIL Label */ 
  {
#line 314
  yyval.parse = parse_make(& compile_on, (yyvsp + -2)->parse, (yyvsp + 0)->parse,
                           (PARSE *)0, (char const   *)((char *)0), (char const   *)((char *)0),
                           0);
  }
#line 315
  goto switch_break;
  case_63: /* CIL Label */ 
#line 323
  yyval.number = 0;
#line 324
  goto switch_break;
  case_64: /* CIL Label */ 
#line 325
  yyval.number = (yyvsp + -1)->number | (yyvsp + 0)->number;
#line 326
  goto switch_break;
  case_65: /* CIL Label */ 
#line 329
  yyval.number = 1;
#line 330
  goto switch_break;
  case_66: /* CIL Label */ 
#line 331
  yyval.number = 2;
#line 332
  goto switch_break;
  case_67: /* CIL Label */ 
#line 333
  yyval.number = 4;
#line 334
  goto switch_break;
  case_68: /* CIL Label */ 
#line 335
  yyval.number = 8;
#line 336
  goto switch_break;
  case_69: /* CIL Label */ 
#line 337
  yyval.number = 16;
#line 338
  goto switch_break;
  case_70: /* CIL Label */ 
#line 339
  yyval.number = 32;
#line 340
  goto switch_break;
  case_71: /* CIL Label */ 
  {
#line 341
  tmp___5 = atoi((yyvsp + 0)->string);
#line 341
  yyval.number = tmp___5 * 64;
  }
#line 342
  goto switch_break;
  case_72: /* CIL Label */ 
  {
#line 350
  yyval.parse = parse_make(& compile_null, (PARSE *)0, (PARSE *)0, (PARSE *)0, (char const   *)((char *)0),
                           (char const   *)((char *)0), 0);
  }
#line 351
  goto switch_break;
  case_73: /* CIL Label */ 
#line 352
  yyval.parse = (yyvsp + 0)->parse;
#line 353
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 356
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1735 "y.tab.c"
  yyvsp -= yylen;
#line 1736
  yyssp -= yylen;
#line 1741
  yyvsp ++;
#line 1741
  *yyvsp = yyval;
#line 1748
  yyn = (int )yyr1[yyn];
#line 1750
  yystate = (int )((int const   )yypgoto[yyn - 50] + (int const   )*yyssp);
#line 1751
  if (0 <= yystate) {
#line 1751
    if (yystate <= 255) {
#line 1751
      if ((int const   )yycheck[yystate] == (int const   )*yyssp) {
#line 1752
        yystate = (int )yytable[yystate];
      } else {
#line 1754
        yystate = (int )yydefgoto[yyn - 50];
      }
    } else {
#line 1754
      yystate = (int )yydefgoto[yyn - 50];
    }
  } else {
#line 1754
    yystate = (int )yydefgoto[yyn - 50];
  }
#line 1756
  goto yynewstate;
  yyerrlab: 
#line 1764
  if (! yyerrstatus) {
    {
#line 1766
    yynerrs ++;
#line 1870
    yyerror("syntax error");
    }
  }
#line 1875
  if (yyerrstatus == 3) {
#line 1880
    if (yychar <= 0) {
#line 1883
      if (yychar == 0) {
#line 1884
        goto yyabortlab;
      }
    } else {
      {
#line 1888
      yydestruct("Error: discarding", yytoken, & yylval);
#line 1889
      yychar = -2;
      }
    }
  }
#line 1895
  goto yyerrlab1;
#line 1909
  yyvsp -= yylen;
#line 1910
  yyssp -= yylen;
#line 1911
  yystate = (int )*yyssp;
#line 1912
  goto yyerrlab1;
  yyerrlab1: 
#line 1919
  yyerrstatus = 3;
  {
#line 1921
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1923
    yyn = (int )yypact[yystate];
#line 1924
    if (yyn != -59) {
#line 1926
      yyn ++;
#line 1927
      if (0 <= yyn) {
#line 1927
        if (yyn <= 255) {
#line 1927
          if ((int const   )yycheck[yyn] == 1) {
#line 1929
            yyn = (int )yytable[yyn];
#line 1930
            if (0 < yyn) {
#line 1931
              goto while_break___1;
            }
          }
        }
      }
    }
#line 1936
    if ((unsigned long )yyssp == (unsigned long )yyss) {
#line 1937
      goto yyabortlab;
    }
    {
#line 1940
    yydestruct("Error: popping", (int )yystos[yystate], yyvsp);
#line 1941
    yyvsp --;
#line 1941
    yyssp --;
#line 1942
    yystate = (int )*yyssp;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1946
  if (yyn == 39) {
#line 1947
    goto yyacceptlab;
  }
#line 1949
  yyvsp ++;
#line 1949
  *yyvsp = yylval;
#line 1955
  yystate = yyn;
#line 1956
  goto yynewstate;
  yyacceptlab: 
#line 1963
  yyresult = 0;
#line 1964
  goto yyreturn;
  yyabortlab: 
#line 1970
  yyresult = 1;
#line 1971
  goto yyreturn;
  yyexhaustedlab: 
  {
#line 1978
  yyerror("memory exhausted");
#line 1979
  yyresult = 2;
  }
  yyreturn: 
#line 1984
  if (yychar != 0) {
#line 1984
    if (yychar != -2) {
      {
#line 1985
      yydestruct("Cleanup: discarding lookahead", yytoken, & yylval);
      }
    }
  }
  {
#line 1987
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1987
    if (! ((unsigned long )yyssp != (unsigned long )yyss)) {
#line 1987
      goto while_break___2;
    }
    {
#line 1989
    yydestruct("Cleanup: popping", (int )yystos[*yyssp], yyvsp);
#line 1991
    yyvsp --;
#line 1991
    yyssp --;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1994
  if ((unsigned long )yyss != (unsigned long )(yyssa)) {
    {
#line 1995
    free((void *)yyss);
    }
  }
#line 1997
  return (yyresult);
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/rules.h"
TARGET *bindtarget(char const   *targetname ) ;
#line 172
TARGETS *targetentry(TARGETS *chain , TARGET *target ) ;
#line 173
TARGETS *targetchain(TARGETS *chain , TARGETS *targets ) ;
#line 176
SETTINGS *copysettings(SETTINGS *from ) ;
#line 177
void pushsettings(SETTINGS *v ) ;
#line 178
void popsettings(SETTINGS *v ) ;
#line 179
void freesettings(SETTINGS *v ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/search.h"
char const   *search(char const   *target , time_t *time___0 ) ;
#line 14 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/make.h"
int make1(TARGET *t ) ;
#line 11 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/headers.h"
void headers(TARGET *t ) ;
#line 81 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/make.c"
static void make0(TARGET *t , TARGET *p , int depth , COUNTS *counts___1 , int anyhow ) ;
#line 84
static TARGETS *make0sort(TARGETS *chain ) ;
#line 86 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/make.c"
static char const   *target_fate[12]  = 
#line 86
  {      "init",      "making",      "stable",      "newer", 
        "temp",      "touched",      "missing",      "needtmp", 
        "old",      "update",      "nofind",      "nomake"};
#line 102 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/make.c"
static char const   *target_bind[4]  = {      "unbound",      "missing",      "parents",      "exists"};
#line 116 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/make.c"
int make(int n_targets , char const   **targets , int anyhow ) 
{ 
  int i ;
  COUNTS counts___1[1] ;
  int status ;
  TARGET *t ;
  TARGET *tmp ;
  int tmp___0 ;
  TARGET *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 124
  status = 0;
#line 126
  memset((void *)((char *)(counts___1)), 0, sizeof(counts___1[0]));
#line 128
  i = 0;
  }
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    if (! (i < n_targets)) {
#line 128
      goto while_break;
    }
    {
#line 130
    tmp = bindtarget(*(targets + i));
#line 130
    t = tmp;
#line 132
    make0(t, (TARGET *)0, 0, counts___1, anyhow);
#line 128
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 135
  if (globs.debug[1]) {
#line 137
    if (counts___1[0].targets) {
      {
#line 138
      printf((char const   */* __restrict  */)"...found %d target(s)...\n", counts___1[0].targets);
      }
    }
#line 139
    if (counts___1[0].temp) {
      {
#line 140
      printf((char const   */* __restrict  */)"...using %d temp target(s)...\n", counts___1[0].temp);
      }
    }
#line 141
    if (counts___1[0].updating) {
      {
#line 142
      printf((char const   */* __restrict  */)"...updating %d target(s)...\n", counts___1[0].updating);
      }
    }
#line 143
    if (counts___1[0].cantfind) {
      {
#line 144
      printf((char const   */* __restrict  */)"...can\'t find %d target(s)...\n",
             counts___1[0].cantfind);
      }
    }
#line 145
    if (counts___1[0].cantmake) {
      {
#line 146
      printf((char const   */* __restrict  */)"...can\'t make %d target(s)...\n",
             counts___1[0].cantmake);
      }
    }
  }
#line 149
  if (counts___1[0].cantfind) {
#line 149
    tmp___0 = 1;
  } else
#line 149
  if (counts___1[0].cantmake) {
#line 149
    tmp___0 = 1;
  } else {
#line 149
    tmp___0 = 0;
  }
#line 149
  status = tmp___0;
#line 151
  i = 0;
  {
#line 151
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 151
    if (! (i < n_targets)) {
#line 151
      goto while_break___0;
    }
    {
#line 152
    tmp___1 = bindtarget(*(targets + i));
#line 152
    tmp___2 = make1(tmp___1);
#line 152
    status |= tmp___2;
#line 151
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 154
  return (status);
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/make.c"
static void make0(TARGET *t , TARGET *p , int depth , COUNTS *counts___1 , int anyhow ) 
{ 
  TARGETS *c ;
  TARGETS *incs ;
  TARGET *ptime ;
  time_t last ;
  time_t leaf ;
  time_t hlast ;
  int fate ;
  char const   *flag ;
  SETTINGS *s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int internal ;
  char const   *tmp___5 ;
  int tmp___6 ;

  {
#line 173
  ptime = t;
#line 176
  flag = "";
#line 183
  if (globs.debug[3]) {
#line 184
    if (depth > 16) {
#line 184
      tmp = 16;
    } else {
#line 184
      tmp = depth;
    }
    {
#line 184
    printf((char const   */* __restrict  */)"make\t--\t%s%s\n", ("                " + 16) - tmp,
           t->name);
    }
  }
  {
#line 186
  t->fate = (char)1;
#line 195
  s = copysettings(t->settings);
#line 196
  pushsettings(s);
  }
#line 200
  if ((int )t->binding == 0) {
#line 200
    if (! ((int )t->flags & 4)) {
      {
#line 202
      t->boundname = search(t->name, & t->time);
      }
#line 203
      if (t->time) {
#line 203
        t->binding = (char)3;
      } else {
#line 203
        t->binding = (char)1;
      }
    }
  }
#line 208
  if (p) {
#line 208
    if ((int )t->flags & 64) {
#line 209
      ptime = p;
    }
  }
#line 213
  if (p) {
#line 213
    if ((int )t->flags & 1) {
#line 213
      if ((int )t->binding == 1) {
#line 213
        if ((int )p->binding != 1) {
#line 217
          t->binding = (char)2;
#line 218
          ptime = p;
        }
      }
    }
  }
#line 223
  if ((int )t->binding == 3) {
    {
#line 224
    headers(t);
    }
  }
  {
#line 228
  popsettings(s);
#line 229
  freesettings(s);
  }
#line 235
  if (globs.debug[3]) {
    {
#line 237
    tmp___1 = strcmp(t->name, t->boundname);
    }
#line 237
    if (tmp___1) {
#line 239
      if (depth > 16) {
#line 239
        tmp___0 = 16;
      } else {
#line 239
        tmp___0 = depth;
      }
      {
#line 239
      printf((char const   */* __restrict  */)"bind\t--\t%s%s: %s\n", ("                " + 16) - tmp___0,
             t->name, t->boundname);
      }
    }
    {
#line 247
    if ((int )t->binding == 2) {
#line 247
      goto case_2;
    }
#line 247
    if ((int )t->binding == 1) {
#line 247
      goto case_2;
    }
#line 247
    if ((int )t->binding == 0) {
#line 247
      goto case_2;
    }
#line 252
    if ((int )t->binding == 3) {
#line 252
      goto case_3;
    }
#line 243
    goto switch_break;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 248
    if (depth > 16) {
#line 248
      tmp___2 = 16;
    } else {
#line 248
      tmp___2 = depth;
    }
    {
#line 248
    printf((char const   */* __restrict  */)"time\t--\t%s%s: %s\n", ("                " + 16) - tmp___2,
           t->name, target_bind[t->binding]);
    }
#line 250
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 253
    tmp___3 = ctime((time_t const   *)(& t->time));
    }
#line 253
    if (depth > 16) {
#line 253
      tmp___4 = 16;
    } else {
#line 253
      tmp___4 = depth;
    }
    {
#line 253
    printf((char const   */* __restrict  */)"time\t--\t%s%s: %s", ("                " + 16) - tmp___4,
           t->name, tmp___3);
    }
#line 255
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 265
  c = t->depends;
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 265
    if (! c) {
#line 265
      goto while_break;
    }
#line 267
    internal = (int )t->flags & 64;
#line 269
    if (globs.debug[13]) {
#line 270
      if (internal) {
#line 270
        tmp___5 = "Includes";
      } else {
#line 270
        tmp___5 = "Depends";
      }
      {
#line 270
      printf((char const   */* __restrict  */)"%s \"%s\" : \"%s\" ;\n", tmp___5, t->name,
             (c->target)->name);
      }
    }
#line 277
    if ((int )(c->target)->fate == 0) {
      {
#line 278
      make0(c->target, ptime, depth + 1, counts___1, anyhow);
      }
    } else
#line 279
    if ((int )(c->target)->fate == 1) {
#line 279
      if (! internal) {
        {
#line 280
        printf((char const   */* __restrict  */)"warning: %s depends on itself\n",
               (c->target)->name);
        }
      }
    }
#line 265
    c = c->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 285
  if (t->includes) {
    {
#line 286
    make0(t->includes, p, depth + 1, counts___1, anyhow);
    }
  }
#line 290
  incs = (TARGETS *)0;
#line 292
  c = t->depends;
  {
#line 292
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 292
    if (! c) {
#line 292
      goto while_break___0;
    }
#line 293
    if ((c->target)->includes) {
      {
#line 294
      incs = targetentry(incs, (c->target)->includes);
      }
#line 298
      if (((c->target)->includes)->time > t->time) {
#line 299
        if (3 > (int )(c->target)->fate) {
#line 299
          (c->target)->fate = (char)3;
        } else {
#line 299
          (c->target)->fate = (c->target)->fate;
        }
      }
    }
#line 292
    c = c->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 303
  t->depends = targetchain(t->depends, incs);
#line 311
  last = (time_t )0;
#line 312
  leaf = (time_t )0;
#line 313
  fate = 2;
#line 315
  c = t->depends;
  }
  {
#line 315
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 315
    if (! c) {
#line 315
      goto while_break___1;
    }
#line 320
    if (leaf > (c->target)->leaf) {
#line 320
      leaf = leaf;
    } else {
#line 320
      leaf = (c->target)->leaf;
    }
#line 322
    if ((int )t->flags & 16) {
#line 324
      last = leaf;
#line 325
      goto __Cont;
    }
#line 328
    if (last > (c->target)->time) {
#line 328
      last = last;
    } else {
#line 328
      last = (c->target)->time;
    }
#line 329
    if (fate > (int )(c->target)->fate) {
#line 329
      fate = fate;
    } else {
#line 329
      fate = (int )(c->target)->fate;
    }
    __Cont: /* CIL Label */ 
#line 315
    c = c->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 339
  if (t->includes) {
#line 339
    hlast = (t->includes)->time;
  } else {
#line 339
    hlast = (time_t )0;
  }
#line 349
  if ((int )t->flags & 32) {
#line 351
    last = (time_t )0;
#line 352
    t->time = (time_t )0;
#line 353
    fate = 2;
  }
#line 376
  if (fate >= 10) {
#line 378
    fate = 11;
  } else
#line 380
  if (fate >= 4) {
#line 382
    fate = 9;
  } else
#line 384
  if ((int )t->binding == 1) {
#line 386
    fate = 6;
  } else
#line 388
  if ((int )t->binding == 3) {
#line 388
    if (last > t->time) {
#line 390
      fate = 8;
    } else {
#line 388
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 392
  if ((int )t->binding == 2) {
#line 392
    if (last > p->time) {
#line 394
      fate = 7;
    } else {
#line 392
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 396
  if ((int )t->binding == 2) {
#line 396
    if (hlast > p->time) {
#line 398
      fate = 7;
    } else {
#line 396
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 400
  if ((int )t->flags & 8) {
#line 402
    fate = 5;
  } else
#line 404
  if (anyhow) {
#line 404
    if (! ((int )t->flags & 32)) {
#line 406
      fate = 5;
    } else {
#line 404
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 408
  if ((int )t->binding == 3) {
#line 408
    if ((int )t->flags & 1) {
#line 410
      fate = 4;
    } else {
#line 408
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 412
  if ((int )t->binding == 3) {
#line 412
    if (p) {
#line 412
      if ((int )p->binding != 0) {
#line 412
        if (t->time > p->time) {
#line 415
          fate = 3;
        } else {
#line 419
          fate = 2;
        }
      } else {
#line 419
        fate = 2;
      }
    } else {
#line 419
      fate = 2;
    }
  } else {
#line 419
    fate = 2;
  }
#line 428
  if (fate == 6) {
#line 428
    if (! t->actions) {
#line 428
      if (! t->depends) {
#line 430
        if ((int )t->flags & 2) {
#line 432
          fate = 2;
        } else {
          {
#line 436
          printf((char const   */* __restrict  */)"don\'t know how to make %s\n",
                 t->name);
#line 438
          fate = 10;
          }
        }
      }
    }
  }
#line 445
  if (t->time > last) {
#line 445
    t->time = t->time;
  } else {
#line 445
    t->time = last;
  }
#line 446
  if (leaf) {
#line 446
    t->leaf = leaf;
  } else {
#line 446
    t->leaf = t->time;
  }
#line 447
  t->fate = (char )fate;
#line 453
  if (globs.newestfirst) {
    {
#line 454
    t->depends = make0sort(t->depends);
    }
  }
#line 462
  if ((int )t->flags & 64) {
#line 463
    return;
  }
#line 465
  (counts___1->targets) ++;
#line 465
  if (! (counts___1->targets % 1000)) {
#line 465
    if (globs.debug[1]) {
      {
#line 466
      printf((char const   */* __restrict  */)"...patience...\n");
      }
    }
  }
#line 468
  if (fate == 4) {
#line 469
    (counts___1->temp) ++;
  } else
#line 470
  if (fate == 10) {
#line 471
    (counts___1->cantfind) ++;
  } else
#line 472
  if (fate == 11) {
#line 472
    if (t->actions) {
#line 473
      (counts___1->cantmake) ++;
    } else {
#line 472
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 474
  if (fate >= 5) {
#line 474
    if (fate < 10) {
#line 474
      if (t->actions) {
#line 475
        (counts___1->updating) ++;
      }
    }
  }
#line 477
  if (! ((int )t->flags & 4)) {
#line 477
    if (fate >= 4) {
#line 478
      flag = "+";
    } else {
#line 477
      goto _L___5;
    }
  } else
  _L___5: /* CIL Label */ 
#line 479
  if ((int )t->binding == 3) {
#line 479
    if (p) {
#line 479
      if (t->time > p->time) {
#line 480
        flag = "*";
      }
    }
  }
#line 482
  if (globs.debug[3]) {
#line 483
    if (depth > 16) {
#line 483
      tmp___6 = 16;
    } else {
#line 483
      tmp___6 = depth;
    }
    {
#line 483
    printf((char const   */* __restrict  */)"made%s\t%s\t%s%s\n", flag, target_fate[t->fate],
           ("                " + 16) - tmp___6, t->name);
    }
  }
#line 487
  if (globs.debug[14]) {
#line 487
    if ((int )t->fate >= 3) {
#line 487
      if ((int )t->fate <= 6) {
        {
#line 490
        printf((char const   */* __restrict  */)"%s %s\n", target_fate[t->fate], t->name);
        }
      }
    }
  }
#line 491
  return;
}
}
#line 497 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/make.c"
static TARGETS *make0sort(TARGETS *chain ) 
{ 
  TARGETS *result ;
  TARGETS *c ;
  TARGETS *s ;

  {
#line 500
  result = (TARGETS *)0;
  {
#line 511
  while (1) {
    while_continue: /* CIL Label */ ;
#line 511
    if (! chain) {
#line 511
      goto while_break;
    }
#line 513
    c = chain;
#line 514
    s = result;
#line 516
    chain = chain->next;
    {
#line 520
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 520
      if (s) {
#line 520
        if (! ((s->target)->time > (c->target)->time)) {
#line 520
          goto while_break___0;
        }
      } else {
#line 520
        goto while_break___0;
      }
#line 521
      s = s->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 526
    c->next = s;
#line 527
    if ((unsigned long )result == (unsigned long )s) {
#line 527
      result = c;
    }
#line 528
    if (! s) {
#line 528
      s = result;
    }
#line 529
    if ((unsigned long )result != (unsigned long )c) {
#line 529
      (s->tail)->next = c;
    }
#line 530
    c->tail = s->tail;
#line 531
    s->tail = c;
  }
  while_break: /* CIL Label */ ;
  }
#line 534
  return (result);
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 73 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/lists.h"
int list_length(LIST *l ) ;
#line 74
LIST *list_sublist(LIST *l , int start , int count ) ;
#line 175 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/rules.h"
SETTINGS *addsettings(SETTINGS *head , int setflag , char const   *symbol , LIST *value ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/command.h"
CMD *cmd_new(RULE *rule , LIST *targets , LIST *sources , LIST *shell , int maxline ) ;
#line 57
void cmd_free(CMD *cmd ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/execcmd.h"
void execcmd(char *string , void (*func)(void *closure , int status ) , void *closure ,
             LIST *shell ) ;
#line 19
int execwait(void) ;
#line 65 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/make1.c"
static void make1a(TARGET *t , TARGET *parent ) ;
#line 66
static void make1b(TARGET *t ) ;
#line 67
static void make1c(TARGET *t ) ;
#line 68
static void make1d(void *closure , int status ) ;
#line 70
static CMD *make1cmds(ACTIONS *a0 ) ;
#line 71
static LIST *make1list(LIST *l , TARGETS *targets , int flags ) ;
#line 72
static SETTINGS *make1settings(LIST *vars ) ;
#line 73
static void make1bind(TARGET *t , int warn ) ;
#line 77 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/make1.c"
static struct __anonstruct_counts_50 counts[1]  ;
#line 88 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/make1.c"
static int intr  =    0;
#line 90 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/make1.c"
int make1(TARGET *t ) 
{ 
  int tmp ;

  {
  {
#line 93
  memset((void *)((char *)(counts)), 0, sizeof(counts[0]));
#line 97
  make1a(t, (TARGET *)0);
  }
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 101
    tmp = execwait();
    }
#line 101
    if (! tmp) {
#line 101
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  if (globs.debug[1]) {
#line 106
    if (counts[0].failed) {
      {
#line 107
      printf((char const   */* __restrict  */)"...failed updating %d target(s)...\n",
             counts[0].failed);
      }
    }
  }
#line 109
  if (globs.debug[1]) {
#line 109
    if (counts[0].skipped) {
      {
#line 110
      printf((char const   */* __restrict  */)"...skipped %d target(s)...\n", counts[0].skipped);
      }
    }
  }
#line 112
  if (globs.debug[1]) {
#line 112
    if (counts[0].made) {
      {
#line 113
      printf((char const   */* __restrict  */)"...updated %d target(s)...\n", counts[0].made);
      }
    }
  }
#line 115
  return (counts[0].total != counts[0].made);
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/make1.c"
static void make1a(TARGET *t , TARGET *parent ) 
{ 
  TARGETS *c ;

  {
#line 133
  if (parent) {
    {
#line 138
    if ((int )t->progress == 3) {
#line 138
      goto case_3;
    }
#line 138
    if ((int )t->progress == 2) {
#line 138
      goto case_3;
    }
#line 138
    if ((int )t->progress == 0) {
#line 138
      goto case_3;
    }
#line 134
    goto switch_break;
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
    case_0: /* CIL Label */ 
    {
#line 139
    t->parents = targetentry(t->parents, parent);
#line 140
    (parent->asynccnt) ++;
    }
    switch_break: /* CIL Label */ ;
    }
  }
#line 143
  if ((int )t->progress != 0) {
#line 144
    return;
  }
#line 152
  t->asynccnt = 1;
#line 157
  t->progress = (char)1;
#line 159
  c = t->depends;
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 159
    if (c) {
#line 159
      if (! (! intr)) {
#line 159
        goto while_break;
      }
    } else {
#line 159
      goto while_break;
    }
    {
#line 160
    make1a(c->target, t);
#line 159
    c = c->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 162
  t->progress = (char)2;
#line 167
  make1b(t);
  }
#line 168
  return;
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/make1.c"
static void make1b(TARGET *t ) 
{ 
  TARGETS *c ;
  char const   *failed ;
  CMD *tmp ;

  {
#line 178
  failed = "dependents";
#line 183
  (t->asynccnt) --;
#line 183
  if (t->asynccnt) {
#line 184
    return;
  }
#line 190
  c = t->depends;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    if (! c) {
#line 190
      goto while_break;
    }
#line 191
    if ((int )(c->target)->status > (int )t->status) {
#line 193
      failed = (c->target)->name;
#line 194
      t->status = (c->target)->status;
    }
#line 190
    c = c->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 200
  if ((int )t->status == 1) {
#line 200
    if (t->actions) {
      {
#line 202
      (counts[0].skipped) ++;
#line 203
      printf((char const   */* __restrict  */)"...skipped %s for lack of %s...\n",
             t->name, failed);
      }
    }
  }
#line 206
  if ((int )t->status == 0) {
    {
#line 214
    if ((int )t->fate == 3) {
#line 214
      goto case_3;
    }
#line 214
    if ((int )t->fate == 2) {
#line 214
      goto case_3;
    }
#line 214
    if ((int )t->fate == 1) {
#line 214
      goto case_3;
    }
#line 214
    if ((int )t->fate == 0) {
#line 214
      goto case_3;
    }
#line 218
    if ((int )t->fate == 11) {
#line 218
      goto case_11;
    }
#line 218
    if ((int )t->fate == 10) {
#line 218
      goto case_11;
    }
#line 222
    if ((int )t->fate == 4) {
#line 222
      goto case_4;
    }
#line 231
    if ((int )t->fate == 9) {
#line 231
      goto case_9;
    }
#line 231
    if ((int )t->fate == 8) {
#line 231
      goto case_9;
    }
#line 231
    if ((int )t->fate == 7) {
#line 231
      goto case_9;
    }
#line 231
    if ((int )t->fate == 6) {
#line 231
      goto case_9;
    }
#line 231
    if ((int )t->fate == 5) {
#line 231
      goto case_9;
    }
#line 207
    goto switch_break;
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 215
    goto switch_break;
    case_11: /* CIL Label */ 
    case_10: /* CIL Label */ 
#line 219
    t->status = (char)1;
#line 220
    goto switch_break;
    case_4: /* CIL Label */ 
#line 223
    if (globs.debug[11]) {
      {
#line 224
      printf((char const   */* __restrict  */)"...using %s...\n", t->name);
      }
    }
#line 225
    goto switch_break;
    case_9: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
    case_5: /* CIL Label */ 
#line 236
    if (t->actions) {
#line 238
      (counts[0].total) ++;
#line 240
      if (globs.debug[1]) {
#line 240
        if (! (counts[0].total % 100)) {
          {
#line 241
          printf((char const   */* __restrict  */)"...on %dth target...\n", counts[0].total);
          }
        }
      }
      {
#line 243
      pushsettings(t->settings);
#line 244
      tmp = make1cmds(t->actions);
#line 244
      t->cmds = (char *)tmp;
#line 245
      popsettings(t->settings);
#line 247
      t->progress = (char)3;
      }
    }
#line 250
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 259
  make1c(t);
  }
#line 260
  return;
}
}
#line 266 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/make1.c"
static void make1c(TARGET *t ) 
{ 
  CMD *cmd ;
  LIST *tmp ;
  TARGETS *c ;
  ACTIONS *actions ;

  {
#line 269
  cmd = (CMD *)t->cmds;
#line 279
  if (cmd) {
#line 279
    if ((int )t->status == 0) {
#line 281
      if (globs.debug[1]) {
#line 282
        if (globs.debug[11]) {
          {
#line 284
          printf((char const   */* __restrict  */)"%s ", (cmd->rule)->name);
#line 285
          tmp = lol_get(& cmd->args, 0);
#line 285
          list_print(tmp);
#line 286
          printf((char const   */* __restrict  */)"\n");
          }
        } else
#line 282
        if (! ((cmd->rule)->flags & 8)) {
          {
#line 284
          printf((char const   */* __restrict  */)"%s ", (cmd->rule)->name);
#line 285
          tmp = lol_get(& cmd->args, 0);
#line 285
          list_print(tmp);
#line 286
          printf((char const   */* __restrict  */)"\n");
          }
        }
      }
#line 289
      if (globs.debug[12]) {
        {
#line 290
        printf((char const   */* __restrict  */)"%s\n", cmd->buf);
        }
      }
#line 292
      if (globs.cmdout) {
        {
#line 293
        fprintf((FILE */* __restrict  */)globs.cmdout, (char const   */* __restrict  */)"%s",
                cmd->buf);
        }
      }
#line 295
      if (globs.noexec) {
        {
#line 297
        make1d((void *)t, 0);
        }
      } else {
        {
#line 301
        fflush(stdout);
#line 302
        execcmd(cmd->buf, & make1d, (void *)t, cmd->shell);
        }
      }
    } else {
#line 279
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 312
    actions = t->actions;
    {
#line 312
    while (1) {
      while_continue: /* CIL Label */ ;
#line 312
      if (! actions) {
#line 312
        goto while_break;
      }
#line 313
      if ((int )(actions->action)->status > (int )t->status) {
#line 314
        t->status = (actions->action)->status;
      }
#line 312
      actions = actions->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 316
    actions = t->actions;
    {
#line 316
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 316
      if (! actions) {
#line 316
        goto while_break___0;
      }
#line 317
      if ((int )t->status > (int )(actions->action)->status) {
#line 318
        (actions->action)->status = t->status;
      }
#line 316
      actions = actions->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 322
    if ((int )t->progress == 3) {
      {
#line 325
      if ((int )t->status == 0) {
#line 325
        goto case_0;
      }
#line 328
      if ((int )t->status == 1) {
#line 328
        goto case_1;
      }
#line 323
      goto switch_break;
      case_0: /* CIL Label */ 
#line 326
      (counts[0].made) ++;
#line 327
      goto switch_break;
      case_1: /* CIL Label */ 
#line 329
      (counts[0].failed) ++;
#line 330
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 335
    t->progress = (char)4;
#line 337
    c = t->parents;
    {
#line 337
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 337
      if (! c) {
#line 337
        goto while_break___1;
      }
      {
#line 338
      make1b(c->target);
#line 337
      c = c->next;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 340
  return;
}
}
#line 389
extern int ( /* missing proto */  unlink)() ;
#line 346 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/make1.c"
static void make1d(void *closure , int status ) 
{ 
  TARGET *t ;
  CMD *cmd ;
  LIST *tmp ;
  LIST *targets ;
  LIST *tmp___0 ;
  int tmp___1 ;

  {
#line 351
  t = (TARGET *)closure;
#line 352
  cmd = (CMD *)t->cmds;
#line 358
  if (status == 1) {
#line 358
    if ((cmd->rule)->flags & 4) {
#line 359
      status = 0;
    }
  }
#line 363
  if (status == 2) {
#line 364
    intr ++;
  }
#line 366
  if (status == 1) {
#line 366
    if (globs.debug[1]) {
#line 370
      if (! globs.debug[12]) {
        {
#line 371
        printf((char const   */* __restrict  */)"%s\n", cmd->buf);
        }
      }
      {
#line 373
      printf((char const   */* __restrict  */)"...failed %s ", (cmd->rule)->name);
#line 374
      tmp = lol_get(& cmd->args, 0);
#line 374
      list_print(tmp);
#line 375
      printf((char const   */* __restrict  */)"...\n");
      }
#line 377
      if (globs.quitquick) {
#line 377
        intr ++;
      }
    }
  }
#line 384
  if (status != 0) {
#line 384
    if (! ((cmd->rule)->flags & 1)) {
      {
#line 386
      tmp___0 = lol_get(& cmd->args, 0);
#line 386
      targets = tmp___0;
      }
      {
#line 388
      while (1) {
        while_continue: /* CIL Label */ ;
#line 388
        if (! targets) {
#line 388
          goto while_break;
        }
        {
#line 389
        tmp___1 = unlink(targets->string);
        }
#line 389
        if (! tmp___1) {
          {
#line 390
          printf((char const   */* __restrict  */)"...removing %s\n", targets->string);
          }
        }
#line 388
        targets = targets->next;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 395
  t->status = (char )status;
#line 396
  t->cmds = (char *)cmd->next;
#line 398
  cmd_free(cmd);
#line 400
  make1c(t);
  }
#line 401
  return;
}
}
#line 413 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/make1.c"
static CMD *make1cmds(ACTIONS *a0 ) 
{ 
  CMD *cmds ;
  LIST *shell ;
  LIST *tmp ;
  RULE *rule ;
  SETTINGS *boundvars ;
  LIST *nt ;
  LIST *ns ;
  ACTIONS *a1 ;
  int start ;
  int chunk ;
  int length ;
  int maxline ;
  CMD *cmd___0 ;
  LIST *tmp___0 ;
  LIST *tmp___1 ;
  LIST *tmp___2 ;
  CMD *tmp___3 ;

  {
  {
#line 416
  cmds = (CMD *)0;
#line 417
  tmp = var_get("JAMSHELL");
#line 417
  shell = tmp;
  }
  {
#line 423
  while (1) {
    while_continue: /* CIL Label */ ;
#line 423
    if (! a0) {
#line 423
      goto while_break;
    }
#line 425
    rule = (a0->action)->rule;
#line 435
    if (! rule->actions) {
#line 436
      goto __Cont;
    } else
#line 435
    if ((a0->action)->running) {
#line 436
      goto __Cont;
    }
    {
#line 438
    (a0->action)->running = (char)1;
#line 444
    nt = make1list((LIST *)0, (a0->action)->targets, 0);
#line 445
    ns = make1list((LIST *)0, (a0->action)->sources, rule->flags);
    }
#line 447
    if (rule->flags & 2) {
#line 448
      a1 = a0->next;
      {
#line 448
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 448
        if (! a1) {
#line 448
          goto while_break___0;
        }
#line 449
        if ((unsigned long )(a1->action)->rule == (unsigned long )rule) {
#line 449
          if (! (a1->action)->running) {
            {
#line 451
            ns = make1list(ns, (a1->action)->sources, rule->flags);
#line 452
            (a1->action)->running = (char)1;
            }
          }
        }
#line 448
        a1 = a1->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 458
    if (! ns) {
#line 458
      if (rule->flags & 33) {
        {
#line 460
        list_free(nt);
        }
#line 461
        goto __Cont;
      }
    }
    {
#line 466
    boundvars = make1settings(rule->bindlist);
#line 467
    pushsettings(boundvars);
#line 489
    start = 0;
#line 490
    length = list_length(ns);
#line 490
    chunk = length;
#line 491
    maxline = rule->flags / 64;
    }
#line 492
    if (maxline) {
#line 492
      if (maxline < 10240) {
#line 492
        maxline = maxline;
      } else {
#line 492
        maxline = 10240;
      }
    } else {
#line 492
      maxline = 10240;
    }
    {
#line 494
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 498
      tmp___0 = list_copy((LIST *)0, shell);
#line 498
      tmp___1 = list_sublist(ns, start, chunk);
#line 498
      tmp___2 = list_copy((LIST *)0, nt);
#line 498
      tmp___3 = cmd_new(rule, tmp___2, tmp___1, tmp___0, maxline);
#line 498
      cmd___0 = tmp___3;
      }
#line 504
      if (cmd___0) {
#line 508
        if (! cmds) {
#line 508
          cmds = cmd___0;
        } else {
#line 509
          (cmds->tail)->next = cmd___0;
        }
#line 510
        cmds->tail = cmd___0;
#line 511
        start += chunk;
      } else
#line 513
      if (rule->flags & 16) {
#line 513
        if (chunk > 1) {
#line 517
          chunk = (chunk * 9) / 10;
        } else {
          {
#line 523
          printf((char const   */* __restrict  */)"%s actions too long (max %d)!\n",
                 rule->name, maxline);
#line 525
          exit(1);
          }
        }
      } else {
        {
#line 523
        printf((char const   */* __restrict  */)"%s actions too long (max %d)!\n",
               rule->name, maxline);
#line 525
        exit(1);
        }
      }
#line 494
      if (! (start < length)) {
#line 494
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 532
    list_free(nt);
#line 533
    list_free(ns);
#line 538
    popsettings(boundvars);
#line 539
    freesettings(boundvars);
    }
    __Cont: /* CIL Label */ 
#line 423
    a0 = a0->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 542
  return (cmds);
}
}
#line 549 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/make1.c"
static LIST *make1list(LIST *l , TARGETS *targets , int flags ) 
{ 
  TARGET *t ;
  LIST *m ;
  int tmp ;

  {
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    if (! targets) {
#line 555
      goto while_break;
    }
#line 557
    t = targets->target;
#line 564
    if ((int )t->binding == 0) {
      {
#line 565
      make1bind(t, ! (flags & 32));
      }
    }
#line 567
    if (flags & 32) {
#line 567
      if ((int )t->binding != 3) {
#line 568
        goto __Cont;
      }
    }
#line 570
    if (flags & 1) {
#line 570
      if ((int )t->fate <= 2) {
#line 571
        goto __Cont;
      }
    }
#line 575
    if (flags & 2) {
#line 579
      m = l;
      {
#line 579
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 579
        if (! m) {
#line 579
          goto while_break___0;
        }
        {
#line 580
        tmp = strcmp(m->string, t->boundname);
        }
#line 580
        if (! tmp) {
#line 581
          goto while_break___0;
        }
#line 579
        m = m->next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 583
      if (m) {
#line 584
        goto __Cont;
      }
    }
    {
#line 589
    l = list_new(l, t->boundname, 1);
    }
    __Cont: /* CIL Label */ 
#line 555
    targets = targets->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 592
  return (l);
}
}
#line 599 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/make1.c"
static SETTINGS *make1settings(LIST *vars ) 
{ 
  SETTINGS *settings ;
  LIST *l ;
  LIST *tmp ;
  LIST *nl ;
  TARGET *t ;
  TARGET *tmp___0 ;

  {
#line 602
  settings = (SETTINGS *)0;
  {
#line 604
  while (1) {
    while_continue: /* CIL Label */ ;
#line 604
    if (! vars) {
#line 604
      goto while_break;
    }
    {
#line 606
    tmp = var_get(vars->string);
#line 606
    l = tmp;
#line 607
    nl = (LIST *)0;
    }
    {
#line 609
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 609
      if (! l) {
#line 609
        goto while_break___0;
      }
      {
#line 611
      tmp___0 = bindtarget(l->string);
#line 611
      t = tmp___0;
      }
#line 616
      if ((int )t->binding == 0) {
        {
#line 617
        make1bind(t, 1);
        }
      }
      {
#line 621
      nl = list_new(nl, t->boundname, 1);
#line 609
      l = l->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 626
    settings = addsettings(settings, 0, vars->string, nl);
#line 604
    vars = vars->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 629
  return (settings);
}
}
#line 639 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/make1.c"
static void make1bind(TARGET *t , int warn ) 
{ 


  {
#line 644
  if ((int )t->flags & 4) {
#line 645
    return;
  }
#line 652
  if (warn) {
    {
#line 653
    printf((char const   */* __restrict  */)"warning: using independent target %s\n",
           t->name);
    }
  }
  {
#line 655
  pushsettings(t->settings);
#line 656
  t->boundname = search(t->name, & t->time);
  }
#line 657
  if (t->time) {
#line 657
    t->binding = (char)3;
  } else {
#line 657
    t->binding = (char)1;
  }
  {
#line 658
  popsettings(t->settings);
  }
#line 659
  return;
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 65 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/execunix.c"
static int intr___0  =    0;
#line 66 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/execunix.c"
static int cmdsrunning  =    0;
#line 67 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/execunix.c"
static void (*istat)(int  )  ;
#line 69 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/execunix.c"
static struct __anonstruct_cmdtab_50 cmdtab[64]  = {      {0, (void (*)(void *closure , int status ))0, (void *)0}};
#line 85 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/execunix.c"
void onintr(int disp ) 
{ 


  {
  {
#line 88
  intr___0 ++;
#line 89
  printf((char const   */* __restrict  */)"...interrupted\n");
  }
#line 90
  return;
}
}
#line 234
extern int ( /* missing proto */  execvp)() ;
#line 235
extern int ( /* missing proto */  _exit)() ;
#line 232
extern int ( /* missing proto */  vfork)() ;
#line 96 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/execunix.c"
void execcmd(char *string , void (*func)(void *closure , int status ) , void *closure ,
             LIST *shell ) 
{ 
  int pid ;
  int slot ;
  char const   *argv[33] ;
  int i ;
  char jobno[4] ;
  int gotpercent ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 113
  slot = 0;
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    if (! (slot < 64)) {
#line 113
      goto while_break;
    }
#line 114
    if (! cmdtab[slot].pid) {
#line 115
      goto while_break;
    }
#line 113
    slot ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 117
  if (slot == 64) {
    {
#line 119
    printf((char const   */* __restrict  */)"no slots for child!\n");
#line 120
    exit(1);
    }
  }
#line 173
  if (shell) {
    {
#line 177
    gotpercent = 0;
#line 179
    sprintf((char */* __restrict  */)(jobno), (char const   */* __restrict  */)"%d",
            slot + 1);
#line 181
    i = 0;
    }
    {
#line 181
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 181
      if (shell) {
#line 181
        if (! (i < 32)) {
#line 181
          goto while_break___0;
        }
      } else {
#line 181
        goto while_break___0;
      }
      {
#line 185
      if ((int const   )*(shell->string + 0) == 37) {
#line 185
        goto case_37;
      }
#line 186
      if ((int const   )*(shell->string + 0) == 33) {
#line 186
        goto case_33;
      }
#line 187
      goto switch_default;
      case_37: /* CIL Label */ 
#line 185
      argv[i] = (char const   *)string;
#line 185
      gotpercent ++;
#line 185
      goto switch_break;
      case_33: /* CIL Label */ 
#line 186
      argv[i] = (char const   *)(jobno);
#line 186
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 187
      argv[i] = shell->string;
      switch_break: /* CIL Label */ ;
      }
#line 189
      if (globs.debug[4]) {
        {
#line 190
        printf((char const   */* __restrict  */)"argv[%d] = \'%s\'\n", i, argv[i]);
        }
      }
#line 181
      i ++;
#line 181
      shell = shell->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 193
    if (! gotpercent) {
#line 194
      tmp = i;
#line 194
      i ++;
#line 194
      argv[tmp] = (char const   *)string;
    }
#line 196
    argv[i] = (char const   *)0;
  } else {
#line 204
    argv[0] = "/bin/sh";
#line 205
    argv[1] = "-c";
#line 207
    argv[2] = (char const   *)string;
#line 208
    argv[3] = (char const   *)0;
  }
#line 213
  tmp___0 = cmdsrunning;
#line 213
  cmdsrunning ++;
#line 213
  if (! tmp___0) {
    {
#line 214
    istat = signal(2, & onintr);
    }
  }
  {
#line 232
  pid = vfork();
  }
#line 232
  if (pid == 0) {
    {
#line 234
    execvp(argv[0], argv);
#line 235
    _exit(127);
    }
  }
#line 239
  if (pid == -1) {
    {
#line 241
    perror("vfork");
#line 242
    exit(1);
    }
  }
#line 247
  cmdtab[slot].pid = pid;
#line 248
  cmdtab[slot].func = func;
#line 249
  cmdtab[slot].closure = closure;
  {
#line 254
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 254
    if (! (cmdsrunning >= 64)) {
#line 254
      if (! (cmdsrunning >= globs.jobs)) {
#line 254
        goto while_break___1;
      }
    }
    {
#line 255
    tmp___1 = execwait();
    }
#line 255
    if (! tmp___1) {
#line 256
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 257
  return;
}
}
#line 277
extern int ( /* missing proto */  wait)() ;
#line 263 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/execunix.c"
int execwait(void) 
{ 
  int i ;
  int status ;
  int w ;
  int rstat ;
  int *tmp ;

  {
#line 272
  if (! cmdsrunning) {
#line 273
    return (0);
  }
  {
#line 277
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 277
    w = wait(& status);
    }
#line 277
    if (w == -1) {
      {
#line 277
      tmp = __errno_location();
      }
#line 277
      if (! (*tmp == 4)) {
#line 277
        goto while_break;
      }
    } else {
#line 277
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 280
  if (w == -1) {
    {
#line 282
    printf((char const   */* __restrict  */)"child process(es) lost!\n");
#line 283
    perror("wait");
#line 284
    exit(1);
    }
  }
#line 289
  i = 0;
  {
#line 289
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 289
    if (! (i < 64)) {
#line 289
      goto while_break___0;
    }
#line 290
    if (w == cmdtab[i].pid) {
#line 291
      goto while_break___0;
    }
#line 289
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 293
  if (i == 64) {
    {
#line 295
    printf((char const   */* __restrict  */)"waif child found!\n");
#line 296
    exit(1);
    }
  }
#line 307
  cmdsrunning --;
#line 307
  if (! cmdsrunning) {
    {
#line 308
    signal(2, istat);
    }
  }
#line 310
  if (intr___0) {
#line 311
    rstat = 2;
  } else
#line 312
  if (w == -1) {
#line 313
    rstat = 1;
  } else
#line 312
  if (status != 0) {
#line 313
    rstat = 1;
  } else {
#line 315
    rstat = 0;
  }
  {
#line 317
  cmdtab[i].pid = 0;
#line 319
  (*(cmdtab[i].func))(cmdtab[i].closure, rstat);
  }
#line 321
  return (1);
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/glob.c"
static void globchars(char const   *s , char const   *e , char *b ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/glob.c"
int glob(char const   *c , char const   *s ) 
{ 
  char bitlist[16] ;
  char const   *here ;
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int r ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;

  {
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    tmp = c;
#line 49
    c ++;
    {
#line 51
    if ((int const   )*tmp == 0) {
#line 51
      goto case_0;
    }
#line 54
    if ((int const   )*tmp == 63) {
#line 54
      goto case_63;
    }
#line 59
    if ((int const   )*tmp == 91) {
#line 59
      goto case_91;
    }
#line 77
    if ((int const   )*tmp == 42) {
#line 77
      goto case_42;
    }
#line 103
    if ((int const   )*tmp == 92) {
#line 103
      goto case_92;
    }
#line 110
    goto switch_default;
    case_0: /* CIL Label */ 
#line 52
    if (*s) {
#line 52
      tmp___0 = -1;
    } else {
#line 52
      tmp___0 = 0;
    }
#line 52
    return (tmp___0);
    case_63: /* CIL Label */ 
#line 55
    tmp___1 = s;
#line 55
    s ++;
#line 55
    if (! *tmp___1) {
#line 56
      return (1);
    }
#line 57
    goto switch_break;
    case_91: /* CIL Label */ 
#line 62
    here = c;
    {
#line 63
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 63
      tmp___2 = c;
#line 63
      c ++;
#line 63
      if (! *tmp___2) {
#line 64
        return (1);
      }
#line 63
      if (! ((unsigned long )here == (unsigned long )c)) {
#line 63
        if (! ((int const   )*c != 93)) {
#line 63
          goto while_break___0;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 66
    c ++;
#line 70
    globchars(here, c, bitlist);
    }
#line 72
    if (! ((int )bitlist[(int )*((unsigned char *)s) / 8] & (1 << (int )*((unsigned char *)s) % 8))) {
#line 73
      return (1);
    }
#line 74
    s ++;
#line 75
    goto switch_break;
    case_42: /* CIL Label */ 
#line 78
    here = s;
    {
#line 80
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 80
      if (! *s) {
#line 80
        goto while_break___1;
      }
#line 81
      s ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 86
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 86
      if (! ((unsigned long )s != (unsigned long )here)) {
#line 86
        goto while_break___2;
      }
#line 92
      if (*c) {
        {
#line 92
        tmp___3 = glob(c, s);
#line 92
        r = tmp___3;
        }
      } else {
#line 92
        if (*s) {
#line 92
          tmp___4 = -1;
        } else {
#line 92
          tmp___4 = 0;
        }
#line 92
        r = tmp___4;
      }
#line 94
      if (! r) {
#line 95
        return (0);
      } else
#line 96
      if (r < 0) {
#line 97
        return (1);
      }
#line 99
      s --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 101
    goto switch_break;
    case_92: /* CIL Label */ 
#line 106
    if (! *c) {
#line 107
      return (1);
    } else {
#line 106
      tmp___5 = s;
#line 106
      s ++;
#line 106
      tmp___6 = c;
#line 106
      c ++;
#line 106
      if ((int const   )*tmp___5 != (int const   )*tmp___6) {
#line 107
        return (1);
      }
    }
#line 108
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 111
    tmp___7 = s;
#line 111
    s ++;
#line 111
    if ((int const   )*tmp___7 != (int const   )*(c + -1)) {
#line 112
      return (1);
    }
#line 113
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/glob.c"
static void globchars(char const   *s , char const   *e , char *b ) 
{ 
  int neg ;
  int c ;
  char const   *tmp ;
  int i ;

  {
  {
#line 127
  neg = 0;
#line 129
  memset((void *)b, '\000', (size_t )16);
  }
#line 131
  if ((int const   )*s == 94) {
#line 132
    neg ++;
#line 132
    s ++;
  }
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if (! ((unsigned long )s < (unsigned long )e)) {
#line 134
      goto while_break;
    }
#line 138
    if ((unsigned long )(s + 2) < (unsigned long )e) {
#line 138
      if ((int const   )*(s + 1) == 45) {
#line 140
        c = (int )*(s + 0);
        {
#line 140
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 140
          if (! (c <= (int )*(s + 2))) {
#line 140
            goto while_break___0;
          }
#line 141
          *(b + c / 8) = (char )((int )*(b + c / 8) | (1 << c % 8));
#line 140
          c ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 142
        s += 3;
      } else {
#line 144
        tmp = s;
#line 144
        s ++;
#line 144
        c = (int )*tmp;
#line 145
        *(b + c / 8) = (char )((int )*(b + c / 8) | (1 << c % 8));
      }
    } else {
#line 144
      tmp = s;
#line 144
      s ++;
#line 144
      c = (int )*tmp;
#line 145
      *(b + c / 8) = (char )((int )*(b + c / 8) | (1 << c % 8));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  if (neg) {
#line 152
    i = 0;
    {
#line 152
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 152
      if (! (i < 16)) {
#line 152
        goto while_break___1;
      }
#line 153
      *(b + i) = (char )((int )*(b + i) ^ 255);
#line 152
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 158
  *(b + 0) = (char )((int )*(b + 0) & 254);
#line 159
  return;
}
}
#line 573 "/usr/include/stdio.h"
extern int fputc(int __c , FILE *__stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 96 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/newstr.h"
char const   *newstr(char const   *string ) ;
#line 14
char const   *copystr(char const   *s ) ;
#line 15
void freestr(char const   *s ) ;
#line 68 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/lists.h"
LIST *list_append(LIST *l , LIST *nl ) ;
#line 80
void lol_add(LOL *lol , LIST *l ) ;
#line 81
void lol_init(LOL *lol ) ;
#line 82
void lol_free(LOL *lol ) ;
#line 84
void lol_print(LOL *lol ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/lists.c"
static LIST *freelist  =    (LIST *)0;
#line 37 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/lists.c"
LIST *list_append(LIST *l , LIST *nl ) 
{ 


  {
#line 42
  if (! (! nl)) {
#line 46
    if (! l) {
#line 48
      l = nl;
    } else {
#line 53
      (l->tail)->next = nl;
#line 54
      l->tail = nl->tail;
    }
  }
#line 57
  return (l);
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/lists.c"
LIST *list_new(LIST *head , char const   *string , int copy ) 
{ 
  LIST *l ;
  char const   *tmp ;
  char const   *tmp___0 ;
  void *tmp___1 ;

  {
#line 72
  if (globs.debug[9]) {
    {
#line 73
    printf((char const   */* __restrict  */)"list > %s <\n", string);
    }
  }
#line 77
  if (copy) {
    {
#line 77
    tmp = copystr(string);
#line 77
    string = tmp;
    }
  } else {
    {
#line 77
    tmp___0 = newstr(string);
#line 77
    string = tmp___0;
    }
  }
#line 83
  if (freelist) {
    {
#line 85
    l = freelist;
#line 86
    freestr(l->string);
#line 87
    freelist = freelist->next;
    }
  } else {
    {
#line 91
    tmp___1 = malloc(sizeof(*l));
#line 91
    l = (LIST *)tmp___1;
    }
  }
#line 98
  if (! head) {
#line 98
    head = l;
  } else {
#line 99
    (head->tail)->next = l;
  }
#line 100
  head->tail = l;
#line 101
  l->next = (LIST *)0;
#line 103
  l->string = string;
#line 105
  return (head);
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/lists.c"
LIST *list_copy(LIST *l , LIST *nl ) 
{ 


  {
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! nl) {
#line 117
      goto while_break;
    }
    {
#line 118
    l = list_new(l, nl->string, 1);
#line 117
    nl = nl->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  return (l);
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/lists.c"
LIST *list_sublist(LIST *l , int start , int count ) 
{ 
  LIST *nl ;
  int tmp ;
  int tmp___0 ;

  {
#line 133
  nl = (LIST *)0;
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (l) {
#line 135
      tmp = start;
#line 135
      start --;
#line 135
      if (! tmp) {
#line 135
        goto while_break;
      }
    } else {
#line 135
      goto while_break;
    }
#line 135
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 138
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 138
    if (l) {
#line 138
      tmp___0 = count;
#line 138
      count --;
#line 138
      if (! tmp___0) {
#line 138
        goto while_break___0;
      }
    } else {
#line 138
      goto while_break___0;
    }
    {
#line 139
    nl = list_new(nl, l->string, 1);
#line 138
    l = l->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 141
  return (nl);
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/lists.c"
void list_free(LIST *head ) 
{ 


  {
#line 153
  if (head) {
#line 155
    (head->tail)->next = freelist;
#line 156
    freelist = head;
  }
#line 158
  return;
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/lists.c"
void list_print(LIST *l ) 
{ 


  {
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (! l) {
#line 167
      goto while_break;
    }
    {
#line 168
    printf((char const   */* __restrict  */)"%s ", l->string);
#line 167
    l = l->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 169
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/lists.c"
void list_printq(FILE *out , LIST *l ) 
{ 
  char const   *p ;
  char const   *ep ;
  size_t tmp ;
  char const   *op ;
  void *tmp___0 ;

  {
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (! l) {
#line 181
      goto while_break;
    }
    {
#line 183
    p = l->string;
#line 184
    tmp = strlen(p);
#line 184
    ep = p + tmp;
#line 185
    op = p;
#line 187
    fputc('\n', out);
#line 188
    fputc('\t', out);
#line 189
    fputc('\"', out);
    }
    {
#line 193
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 193
      tmp___0 = memchr((void const   *)op, '\"', (size_t )(ep - op));
#line 193
      p = (char const   *)((char *)tmp___0);
      }
#line 193
      if (! p) {
#line 193
        goto while_break___0;
      }
      {
#line 195
      fwrite((void const   */* __restrict  */)op, (size_t )(p - op), (size_t )1, (FILE */* __restrict  */)out);
#line 196
      fputc('\\', out);
#line 197
      fputc('\"', out);
#line 198
      op = p + 1;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 203
    fwrite((void const   */* __restrict  */)op, (size_t )(ep - op), (size_t )1, (FILE */* __restrict  */)out);
#line 204
    fputc('\"', out);
#line 205
    fputc(' ', out);
#line 181
    l = l->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 207
  return;
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/lists.c"
int list_length(LIST *l ) 
{ 
  int n ;

  {
#line 216
  n = 0;
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;
#line 218
    if (! l) {
#line 218
      goto while_break;
    }
#line 218
    l = l->next;
#line 218
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 221
  return (n);
}
}
#line 228 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/lists.c"
void lol_init(LOL *lol ) 
{ 


  {
#line 231
  lol->count = 0;
#line 232
  return;
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/lists.c"
void lol_add(LOL *lol , LIST *l ) 
{ 
  int tmp ;

  {
#line 243
  if (lol->count < 9) {
#line 244
    tmp = lol->count;
#line 244
    (lol->count) ++;
#line 244
    lol->list[tmp] = l;
  }
#line 245
  return;
}
}
#line 251 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/lists.c"
void lol_free(LOL *lol ) 
{ 
  int i ;

  {
#line 256
  i = 0;
  {
#line 256
  while (1) {
    while_continue: /* CIL Label */ ;
#line 256
    if (! (i < lol->count)) {
#line 256
      goto while_break;
    }
    {
#line 257
    list_free(lol->list[i]);
#line 256
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 259
  lol->count = 0;
#line 260
  return;
}
}
#line 266 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/lists.c"
LIST *lol_get(LOL *lol , int i ) 
{ 
  LIST *tmp ;

  {
#line 271
  if (i < lol->count) {
#line 271
    tmp = lol->list[i];
  } else {
#line 271
    tmp = (LIST *)0;
  }
#line 271
  return (tmp);
}
}
#line 278 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/lists.c"
void lol_print(LOL *lol ) 
{ 
  int i ;

  {
#line 283
  i = 0;
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 283
    if (! (i < lol->count)) {
#line 283
      goto while_break;
    }
#line 285
    if (i) {
      {
#line 286
      printf((char const   */* __restrict  */)" : ");
      }
    }
    {
#line 287
    list_print(lol->list[i]);
#line 283
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 289
  return;
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/regexp.h"
regexp *regcomp(char const   *exp ) ;
#line 22
int regexec(regexp *prog , char const   *string ) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/hdrmacro.h"
void macro_headers(TARGET *t ) ;
#line 14
char const   *macro_header_get(char const   *macro_name ) ;
#line 15 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/hash.h"
struct hash *hashinit(int datalen , char const   *name ) ;
#line 16
int hashitem(struct hash *hp , HASHDATA **data , int enter ) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/hdrmacro.c"
static struct hash *header_macros_hash  =    (struct hash *)0;
#line 60 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/hdrmacro.c"
void macro_headers(TARGET *t ) 
{ 
  regexp *re ;
  FILE *f ;
  char buf___0[1024] ;
  HEADER_MACRO var ;
  HEADER_MACRO *v ;
  char buf1[1024] ;
  char buf2[1024] ;
  int l1 ;
  int l2 ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 69
  if (globs.debug[6]) {
    {
#line 70
    printf((char const   */* __restrict  */)"macro header scan for %s\n", t->name);
    }
  }
  {
#line 75
  re = regcomp("^[ \t]*#[ \t]*define[ \t]*([A-Za-z][A-Za-z0-9_]*)[ \t]*[<\"]([^\">]*)[\">].*$");
#line 79
  f = fopen((char const   */* __restrict  */)t->boundname, (char const   */* __restrict  */)"r");
  }
#line 79
  if ((unsigned long )f == (unsigned long )((FILE *)0)) {
#line 80
    return;
  }
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 82
    tmp___1 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)f);
    }
#line 82
    if (! tmp___1) {
#line 82
      goto while_break;
    }
    {
#line 84
    v = & var;
#line 86
    tmp___0 = regexec(re, (char const   *)(buf___0));
    }
#line 86
    if (tmp___0) {
#line 86
      if (re->startp[1]) {
        {
#line 91
        l1 = (int )(re->endp[1] - re->startp[1]);
#line 92
        l2 = (int )(re->endp[2] - re->startp[2]);
#line 94
        memcpy((void */* __restrict  */)(buf1), (void const   */* __restrict  */)re->startp[1],
               (size_t )l1);
#line 95
        memcpy((void */* __restrict  */)(buf2), (void const   */* __restrict  */)re->startp[2],
               (size_t )l2);
#line 96
        buf1[l1] = (char )'\000';
#line 97
        buf2[l2] = (char )'\000';
        }
#line 100
        if (globs.debug[6]) {
          {
#line 101
          printf((char const   */* __restrict  */)"macro \'%s\' used to define filename \'%s\' in \'%s\'\n",
                 buf1, buf2, t->boundname);
          }
        }
#line 105
        if (! header_macros_hash) {
          {
#line 106
          header_macros_hash = hashinit((int )sizeof(HEADER_MACRO ), "hdrmacros");
          }
        }
        {
#line 108
        v->symbol = (char const   *)(buf1);
#line 109
        v->filename = (char const   *)0;
#line 110
        tmp = hashitem(header_macros_hash, (HASHDATA **)(& v), 1);
        }
#line 110
        if (! tmp) {
          {
#line 112
          v->symbol = newstr((char const   *)(buf1));
#line 113
          v->filename = newstr((char const   *)(buf2));
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 120
  fclose(f);
#line 122
  free((void *)re);
  }
#line 123
  return;
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/hdrmacro.c"
char const   *macro_header_get(char const   *macro_name ) 
{ 
  HEADER_MACRO var ;
  HEADER_MACRO *v ;
  int tmp ;

  {
#line 129
  v = & var;
#line 131
  v->symbol = (char const   *)((char *)macro_name);
#line 133
  if (header_macros_hash) {
    {
#line 133
    tmp = hashitem(header_macros_hash, (HASHDATA **)(& v), 0);
    }
#line 133
    if (tmp) {
#line 135
      if (globs.debug[6]) {
        {
#line 136
        printf((char const   */* __restrict  */)"### macro \'%s\' evaluated to \'%s\'\n",
               macro_name, v->filename);
        }
      }
#line 137
      return (v->filename);
    }
  }
#line 139
  return ((char const   *)0);
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/parse.h"
void parse_refer(PARSE *p ) ;
#line 44
void parse_free(PARSE *p ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/compile.h"
LIST *evaluate_rule(char const   *rulename , LOL *args , LIST *result ) ;
#line 167 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/rules.h"
RULE *bindrule(char const   *rulename ) ;
#line 171
TARGETS *targetlist(TARGETS *chain , LIST *targets ) ;
#line 174
ACTIONS *actionlist(ACTIONS *chain , ACTION *action ) ;
#line 82 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/compile.c"
static char const   *set_names[3]  = {      "=",      "+=",      "?="};
#line 83
static void debug_compile(int which , char const   *s ) ;
#line 95 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/compile.c"
LIST *compile_append(PARSE *parse , LOL *args , int *jmp ) 
{ 
  LIST *tmp ;
  LIST *tmp___0 ;
  LIST *tmp___1 ;

  {
  {
#line 103
  tmp = (*((parse->right)->func))(parse->right, args, jmp);
#line 103
  tmp___0 = (*((parse->left)->func))(parse->left, args, jmp);
#line 103
  tmp___1 = list_append(tmp___0, tmp);
  }
#line 103
  return (tmp___1);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/compile.c"
LIST *compile_break(PARSE *parse , LOL *args , int *jmp ) 
{ 
  LIST *lv ;
  LIST *tmp ;

  {
  {
#line 121
  tmp = (*((parse->left)->func))(parse->left, args, jmp);
#line 121
  lv = tmp;
#line 122
  *jmp = parse->num;
  }
#line 123
  return (lv);
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/compile.c"
static int lcmp(LIST *t , LIST *s ) 
{ 
  int status ;
  char const   *st ;
  char const   *tmp ;
  char const   *ss ;
  char const   *tmp___0 ;

  {
#line 137
  status = 0;
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    if (! status) {
#line 139
      if (! t) {
#line 139
        if (! s) {
#line 139
          goto while_break;
        }
      }
    } else {
#line 139
      goto while_break;
    }
#line 141
    if (t) {
#line 141
      tmp = t->string;
    } else {
#line 141
      tmp = "";
    }
#line 141
    st = tmp;
#line 142
    if (s) {
#line 142
      tmp___0 = s->string;
    } else {
#line 142
      tmp___0 = "";
    }
    {
#line 142
    ss = tmp___0;
#line 144
    status = strcmp(st, ss);
    }
#line 146
    if (t) {
#line 146
      t = t->next;
    } else {
#line 146
      t = t;
    }
#line 147
    if (s) {
#line 147
      s = s->next;
    } else {
#line 147
      s = s;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 150
  return (status);
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/compile.c"
LIST *compile_eval(PARSE *parse , LOL *args , int *jmp ) 
{ 
  LIST *ll ;
  LIST *lr ;
  LIST *s ;
  LIST *t ;
  int status ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 160
  status = 0;
#line 164
  ll = (*((parse->left)->func))(parse->left, args, jmp);
#line 165
  lr = (LIST *)0;
  }
  {
#line 170
  if (parse->num == 10) {
#line 170
    goto case_10;
  }
#line 170
  if (parse->num == 1) {
#line 170
    goto case_10;
  }
#line 171
  if (parse->num == 2) {
#line 171
    goto case_2;
  }
#line 172
  goto eval;
  case_10: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 170
  if (ll) {
#line 170
    goto eval;
  }
#line 170
  goto switch_break;
  case_2: /* CIL Label */ 
#line 171
  if (! ll) {
#line 171
    goto eval;
  }
#line 171
  goto switch_break;
  eval: 
  switch_default: /* CIL Label */ 
  {
#line 172
  lr = (*((parse->right)->func))(parse->right, args, jmp);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 179
  if (parse->num == 0) {
#line 179
    goto case_0;
  }
#line 183
  if (parse->num == 1) {
#line 183
    goto case_1___0;
  }
#line 187
  if (parse->num == 2) {
#line 187
    goto case_2___0;
  }
#line 191
  if (parse->num == 10) {
#line 191
    goto case_10___0;
  }
#line 209
  if (parse->num == 3) {
#line 209
    goto case_3;
  }
#line 210
  if (parse->num == 4) {
#line 210
    goto case_4;
  }
#line 211
  if (parse->num == 5) {
#line 211
    goto case_5;
  }
#line 212
  if (parse->num == 6) {
#line 212
    goto case_6;
  }
#line 213
  if (parse->num == 7) {
#line 213
    goto case_7;
  }
#line 214
  if (parse->num == 8) {
#line 214
    goto case_8;
  }
#line 215
  if (parse->num == 9) {
#line 215
    goto case_9;
  }
#line 177
  goto switch_break___0;
  case_0: /* CIL Label */ 
#line 180
  if (! ll) {
#line 180
    status = 1;
  }
#line 181
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 184
  if (ll) {
#line 184
    if (lr) {
#line 184
      status = 1;
    }
  }
#line 185
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 188
  if (ll) {
#line 188
    status = 1;
  } else
#line 188
  if (lr) {
#line 188
    status = 1;
  }
#line 189
  goto switch_break___0;
  case_10___0: /* CIL Label */ 
#line 195
  t = ll;
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 195
    if (! t) {
#line 195
      goto while_break;
    }
#line 197
    s = lr;
    {
#line 197
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 197
      if (! s) {
#line 197
        goto while_break___0;
      }
      {
#line 198
      tmp = strcmp(t->string, s->string);
      }
#line 198
      if (! tmp) {
#line 199
        goto while_break___0;
      }
#line 197
      s = s->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 200
    if (! s) {
#line 200
      goto while_break;
    }
#line 195
    t = t->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  if (! t) {
#line 205
    status = 1;
  }
#line 207
  goto switch_break___0;
  case_3: /* CIL Label */ 
  {
#line 209
  tmp___0 = lcmp(ll, (LIST *)0);
  }
#line 209
  if (tmp___0 != 0) {
#line 209
    status = 1;
  }
#line 209
  goto switch_break___0;
  case_4: /* CIL Label */ 
  {
#line 210
  tmp___1 = lcmp(ll, lr);
  }
#line 210
  if (tmp___1 == 0) {
#line 210
    status = 1;
  }
#line 210
  goto switch_break___0;
  case_5: /* CIL Label */ 
  {
#line 211
  tmp___2 = lcmp(ll, lr);
  }
#line 211
  if (tmp___2 != 0) {
#line 211
    status = 1;
  }
#line 211
  goto switch_break___0;
  case_6: /* CIL Label */ 
  {
#line 212
  tmp___3 = lcmp(ll, lr);
  }
#line 212
  if (tmp___3 < 0) {
#line 212
    status = 1;
  }
#line 212
  goto switch_break___0;
  case_7: /* CIL Label */ 
  {
#line 213
  tmp___4 = lcmp(ll, lr);
  }
#line 213
  if (tmp___4 <= 0) {
#line 213
    status = 1;
  }
#line 213
  goto switch_break___0;
  case_8: /* CIL Label */ 
  {
#line 214
  tmp___5 = lcmp(ll, lr);
  }
#line 214
  if (tmp___5 > 0) {
#line 214
    status = 1;
  }
#line 214
  goto switch_break___0;
  case_9: /* CIL Label */ 
  {
#line 215
  tmp___6 = lcmp(ll, lr);
  }
#line 215
  if (tmp___6 >= 0) {
#line 215
    status = 1;
  }
#line 215
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 219
  if (globs.debug[8]) {
    {
#line 221
    debug_compile(0, "if");
#line 222
    list_print(ll);
#line 223
    printf((char const   */* __restrict  */)"(%d) ", status);
#line 224
    list_print(lr);
#line 225
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 232
  if (! status) {
#line 232
    t = (LIST *)0;
  } else
#line 233
  if (ll) {
#line 233
    t = ll;
#line 233
    ll = (LIST *)0;
  } else
#line 234
  if (lr) {
#line 234
    t = lr;
#line 234
    lr = (LIST *)0;
  } else {
    {
#line 235
    t = list_new((LIST *)0, "1", 0);
    }
  }
#line 237
  if (ll) {
    {
#line 237
    list_free(ll);
    }
  }
#line 238
  if (lr) {
    {
#line 238
    list_free(lr);
    }
  }
#line 239
  return (t);
}
}
#line 253 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/compile.c"
LIST *compile_foreach(PARSE *p , LOL *args , int *jmp ) 
{ 
  LIST *nv ;
  LIST *tmp ;
  LIST *result ;
  LIST *l ;
  LIST *tmp___0 ;

  {
  {
#line 259
  tmp = (*((p->left)->func))(p->left, args, jmp);
#line 259
  nv = tmp;
#line 260
  result = (LIST *)0;
#line 265
  l = nv;
  }
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 265
    if (l) {
#line 265
      if (! (*jmp == 0)) {
#line 265
        goto while_break;
      }
    } else {
#line 265
      goto while_break;
    }
    {
#line 269
    tmp___0 = list_new((LIST *)0, l->string, 1);
#line 269
    var_set(p->string, tmp___0, 0);
#line 273
    list_free(result);
#line 274
    result = (*((p->right)->func))(p->right, args, jmp);
    }
#line 278
    if (*jmp == 2) {
#line 279
      *jmp = 0;
    }
#line 265
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 284
  if (*jmp == 1) {
#line 285
    *jmp = 0;
  } else
#line 284
  if (*jmp == 2) {
#line 285
    *jmp = 0;
  }
  {
#line 287
  list_free(nv);
  }
#line 291
  return (result);
}
}
#line 302 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/compile.c"
LIST *compile_if(PARSE *p , LOL *args , int *jmp ) 
{ 
  LIST *l ;
  LIST *tmp ;
  LIST *tmp___0 ;

  {
  {
#line 308
  tmp = (*((p->left)->func))(p->left, args, jmp);
#line 308
  l = tmp;
  }
#line 310
  if (l) {
#line 310
    p = p->right;
  } else {
#line 310
    p = p->third;
  }
  {
#line 312
  list_free(l);
#line 314
  tmp___0 = (*(p->func))(p, args, jmp);
  }
#line 314
  return (tmp___0);
}
}
#line 323 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/compile.c"
LIST *compile_include(PARSE *parse , LOL *args , int *jmp ) 
{ 
  LIST *nt ;
  LIST *tmp ;
  TARGET *t ;
  TARGET *tmp___0 ;

  {
  {
#line 329
  tmp = (*((parse->left)->func))(parse->left, args, jmp);
#line 329
  nt = tmp;
  }
#line 331
  if (globs.debug[5]) {
    {
#line 333
    debug_compile(0, "include");
#line 334
    list_print(nt);
#line 335
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 338
  if (nt) {
    {
#line 340
    tmp___0 = bindtarget(nt->string);
#line 340
    t = tmp___0;
#line 347
    pushsettings(t->settings);
#line 348
    t->boundname = search(t->name, & t->time);
#line 349
    popsettings(t->settings);
    }
#line 353
    if (t->time) {
      {
#line 354
      parse_file(t->boundname);
      }
    } else
#line 353
    if (! ((int )t->flags & 2)) {
      {
#line 354
      parse_file(t->boundname);
      }
    }
  }
  {
#line 357
  list_free(nt);
  }
#line 359
  return ((LIST *)0);
}
}
#line 368 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/compile.c"
LIST *compile_list(PARSE *parse , LOL *args , int *jmp ) 
{ 
  char const   *s ;
  size_t tmp ;
  LIST *tmp___0 ;

  {
  {
#line 375
  s = parse->string;
#line 376
  tmp = strlen(s);
#line 376
  tmp___0 = var_expand((LIST *)0, s, s + tmp, args, 1);
  }
#line 376
  return (tmp___0);
}
}
#line 387 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/compile.c"
LIST *compile_local(PARSE *parse , LOL *args , int *jmp ) 
{ 
  LIST *l ;
  SETTINGS *s ;
  LIST *nt ;
  LIST *tmp ;
  LIST *ns ;
  LIST *tmp___0 ;
  LIST *result ;
  LIST *tmp___1 ;

  {
  {
#line 394
  s = (SETTINGS *)0;
#line 395
  tmp = (*((parse->left)->func))(parse->left, args, jmp);
#line 395
  nt = tmp;
#line 396
  tmp___0 = (*((parse->right)->func))(parse->right, args, jmp);
#line 396
  ns = tmp___0;
  }
#line 399
  if (globs.debug[5]) {
    {
#line 401
    debug_compile(0, "local");
#line 402
    list_print(nt);
#line 403
    printf((char const   */* __restrict  */)" = ");
#line 404
    list_print(ns);
#line 405
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 410
  l = nt;
  {
#line 410
  while (1) {
    while_continue: /* CIL Label */ ;
#line 410
    if (! l) {
#line 410
      goto while_break;
    }
    {
#line 411
    tmp___1 = list_copy((LIST *)0, ns);
#line 411
    s = addsettings(s, 0, l->string, tmp___1);
#line 410
    l = l->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 413
  list_free(ns);
#line 414
  list_free(nt);
#line 419
  pushsettings(s);
#line 420
  result = (*((parse->third)->func))(parse->third, args, jmp);
#line 421
  popsettings(s);
#line 422
  freesettings(s);
  }
#line 424
  return (result);
}
}
#line 431 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/compile.c"
LIST *compile_null(PARSE *parse , LOL *args , int *jmp ) 
{ 


  {
#line 437
  return ((LIST *)0);
}
}
#line 447 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/compile.c"
LIST *compile_on(PARSE *parse , LOL *args , int *jmp ) 
{ 
  LIST *nt ;
  LIST *tmp ;
  LIST *result ;
  TARGET *t ;
  TARGET *tmp___0 ;
  SETTINGS *s ;
  SETTINGS *tmp___1 ;

  {
  {
#line 453
  tmp = (*((parse->left)->func))(parse->left, args, jmp);
#line 453
  nt = tmp;
#line 454
  result = (LIST *)0;
  }
#line 456
  if (globs.debug[5]) {
    {
#line 458
    debug_compile(0, "on");
#line 459
    list_print(nt);
#line 460
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 468
  if (nt) {
    {
#line 470
    tmp___0 = bindtarget(nt->string);
#line 470
    t = tmp___0;
#line 471
    tmp___1 = copysettings(t->settings);
#line 471
    s = tmp___1;
#line 473
    pushsettings(s);
#line 474
    result = (*((parse->right)->func))(parse->right, args, jmp);
#line 475
    popsettings(s);
#line 476
    freesettings(s);
    }
  }
  {
#line 479
  list_free(nt);
  }
#line 481
  return (result);
}
}
#line 493 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/compile.c"
LIST *compile_rule(PARSE *parse , LOL *args , int *jmp ) 
{ 
  LOL nargs[1] ;
  LIST *result ;
  LIST *ll ;
  LIST *l ;
  PARSE *p ;
  LIST *tmp ;

  {
  {
#line 500
  result = (LIST *)0;
#line 506
  ll = (*((parse->left)->func))(parse->left, args, jmp);
#line 510
  lol_init(nargs);
#line 512
  p = parse->right;
  }
  {
#line 512
  while (1) {
    while_continue: /* CIL Label */ ;
#line 512
    if (! p) {
#line 512
      goto while_break;
    }
    {
#line 513
    tmp = (*((p->right)->func))(p->right, args, jmp);
#line 513
    lol_add(nargs, tmp);
#line 512
    p = p->left;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 517
  l = ll;
  {
#line 517
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 517
    if (! l) {
#line 517
      goto while_break___0;
    }
    {
#line 518
    result = evaluate_rule(l->string, nargs, result);
#line 517
    l = l->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 520
  list_free(ll);
#line 521
  lol_free(nargs);
  }
#line 523
  return (result);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/compile.c"
LIST *evaluate_rule(char const   *rulename , LOL *args , LIST *result ) 
{ 
  RULE *rule ;
  RULE *tmp ;
  TARGETS *t ;
  ACTION *action ;
  void *tmp___0 ;
  LIST *tmp___1 ;
  LIST *tmp___2 ;
  PARSE *parse ;
  SETTINGS *s ;
  int jmp ;
  LIST *l ;
  int i ;
  LIST *tmp___3 ;
  LIST *tmp___4 ;
  LIST *tmp___5 ;

  {
  {
#line 536
  tmp = bindrule(rulename);
#line 536
  rule = tmp;
  }
#line 538
  if (globs.debug[5]) {
    {
#line 540
    debug_compile(1, rulename);
#line 541
    lol_print(args);
#line 542
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 547
  if (! rule->actions) {
#line 547
    if (! rule->procedure) {
      {
#line 548
      printf((char const   */* __restrict  */)"warning: unknown rule %s\n", rule->name);
      }
    }
  }
#line 553
  if (rule->actions) {
    {
#line 560
    tmp___0 = malloc(sizeof(ACTION ));
#line 560
    action = (ACTION *)tmp___0;
#line 561
    memset((void *)((char *)action), '\000', sizeof(*action));
#line 563
    action->rule = rule;
#line 564
    tmp___1 = lol_get(args, 0);
#line 564
    action->targets = targetlist((TARGETS *)0, tmp___1);
#line 565
    tmp___2 = lol_get(args, 1);
#line 565
    action->sources = targetlist((TARGETS *)0, tmp___2);
#line 569
    t = action->targets;
    }
    {
#line 569
    while (1) {
      while_continue: /* CIL Label */ ;
#line 569
      if (! t) {
#line 569
        goto while_break;
      }
      {
#line 570
      (t->target)->actions = actionlist((t->target)->actions, action);
#line 569
      t = t->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 575
  if (rule->procedure) {
#line 577
    parse = rule->procedure;
#line 578
    s = (SETTINGS *)0;
#line 579
    jmp = 0;
#line 585
    l = rule->params;
#line 585
    i = 0;
    {
#line 585
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 585
      if (! l) {
#line 585
        goto while_break___0;
      }
      {
#line 586
      tmp___3 = lol_get(args, i);
#line 586
      tmp___4 = list_copy((LIST *)0, tmp___3);
#line 586
      s = addsettings(s, 0, l->string, tmp___4);
#line 585
      l = l->next;
#line 585
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 593
    parse_refer(parse);
#line 595
    pushsettings(s);
#line 596
    tmp___5 = (*(parse->func))(parse, args, & jmp);
#line 596
    result = list_append(result, tmp___5);
#line 597
    popsettings(s);
#line 598
    freesettings(s);
#line 600
    parse_free(parse);
    }
  }
#line 603
  if (globs.debug[5]) {
    {
#line 604
    debug_compile(-1, (char const   *)0);
    }
  }
#line 606
  return (result);
}
}
#line 616 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/compile.c"
LIST *compile_rules(PARSE *parse , LOL *args , int *jmp ) 
{ 
  LIST *result ;

  {
#line 625
  result = (LIST *)0;
  {
#line 627
  while (1) {
    while_continue: /* CIL Label */ ;
#line 627
    if (*jmp == 0) {
#line 627
      if (! ((unsigned long )parse->func == (unsigned long )(& compile_rules))) {
#line 627
        goto while_break;
      }
    } else {
#line 627
      goto while_break;
    }
    {
#line 629
    list_free(result);
#line 630
    result = (*((parse->left)->func))(parse->left, args, jmp);
#line 631
    parse = parse->right;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 634
  if (*jmp == 0) {
    {
#line 636
    list_free(result);
#line 637
    result = (*(parse->func))(parse, args, jmp);
    }
  }
#line 640
  return (result);
}
}
#line 651 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/compile.c"
LIST *compile_set(PARSE *parse , LOL *args , int *jmp ) 
{ 
  LIST *nt ;
  LIST *tmp ;
  LIST *ns ;
  LIST *tmp___0 ;
  LIST *l ;
  LIST *tmp___1 ;

  {
  {
#line 657
  tmp = (*((parse->left)->func))(parse->left, args, jmp);
#line 657
  nt = tmp;
#line 658
  tmp___0 = (*((parse->right)->func))(parse->right, args, jmp);
#line 658
  ns = tmp___0;
  }
#line 661
  if (globs.debug[5]) {
    {
#line 663
    debug_compile(0, "set");
#line 664
    list_print(nt);
#line 665
    printf((char const   */* __restrict  */)" %s ", set_names[parse->num]);
#line 666
    list_print(ns);
#line 667
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 673
  l = nt;
  {
#line 673
  while (1) {
    while_continue: /* CIL Label */ ;
#line 673
    if (! l) {
#line 673
      goto while_break;
    }
    {
#line 674
    tmp___1 = list_copy((LIST *)0, ns);
#line 674
    var_set(l->string, tmp___1, parse->num);
#line 673
    l = l->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 676
  list_free(nt);
  }
#line 678
  return (ns);
}
}
#line 689 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/compile.c"
LIST *compile_setcomp(PARSE *parse , LOL *args , int *jmp ) 
{ 
  RULE *rule ;
  RULE *tmp ;
  LIST *params ;
  PARSE *p ;

  {
  {
#line 695
  tmp = bindrule(parse->string);
#line 695
  rule = tmp;
#line 696
  params = (LIST *)0;
#line 701
  p = parse->left;
  }
  {
#line 701
  while (1) {
    while_continue: /* CIL Label */ ;
#line 701
    if (! p) {
#line 701
      goto while_break;
    }
    {
#line 702
    params = list_new(params, p->string, 1);
#line 701
    p = p->left;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 704
  if (globs.debug[5]) {
    {
#line 706
    debug_compile(0, "rule");
#line 707
    printf((char const   */* __restrict  */)"%s ", parse->string);
#line 708
    list_print(params);
#line 709
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 714
  if (rule->procedure) {
    {
#line 715
    parse_free(rule->procedure);
    }
  }
#line 717
  if (rule->params) {
    {
#line 718
    list_free(rule->params);
    }
  }
  {
#line 720
  rule->procedure = parse->right;
#line 721
  rule->params = params;
#line 726
  parse_refer(parse->right);
  }
#line 728
  return ((LIST *)0);
}
}
#line 743 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/compile.c"
LIST *compile_setexec(PARSE *parse , LOL *args , int *jmp ) 
{ 
  RULE *rule ;
  RULE *tmp ;
  LIST *bindlist ;
  LIST *tmp___0 ;

  {
  {
#line 749
  tmp = bindrule(parse->string);
#line 749
  rule = tmp;
#line 750
  tmp___0 = (*((parse->left)->func))(parse->left, args, jmp);
#line 750
  bindlist = tmp___0;
  }
#line 754
  if (rule->actions) {
    {
#line 756
    freestr(rule->actions);
#line 757
    list_free(rule->bindlist);
    }
  }
  {
#line 760
  rule->actions = copystr(parse->string1);
#line 761
  rule->bindlist = bindlist;
#line 762
  rule->flags = parse->num;
  }
#line 764
  return ((LIST *)0);
}
}
#line 776 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/compile.c"
LIST *compile_settings(PARSE *parse , LOL *args , int *jmp ) 
{ 
  LIST *nt ;
  LIST *tmp ;
  LIST *ns ;
  LIST *tmp___0 ;
  LIST *targets ;
  LIST *tmp___1 ;
  LIST *ts ;
  TARGET *t ;
  TARGET *tmp___2 ;
  LIST *l ;
  LIST *tmp___3 ;

  {
  {
#line 782
  tmp = (*((parse->left)->func))(parse->left, args, jmp);
#line 782
  nt = tmp;
#line 783
  tmp___0 = (*((parse->third)->func))(parse->third, args, jmp);
#line 783
  ns = tmp___0;
#line 784
  tmp___1 = (*((parse->right)->func))(parse->right, args, jmp);
#line 784
  targets = tmp___1;
  }
#line 787
  if (globs.debug[5]) {
    {
#line 789
    debug_compile(0, "set");
#line 790
    list_print(nt);
#line 791
    printf((char const   */* __restrict  */)"on ");
#line 792
    list_print(targets);
#line 793
    printf((char const   */* __restrict  */)" %s ", set_names[parse->num]);
#line 794
    list_print(ns);
#line 795
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 802
  ts = targets;
  {
#line 802
  while (1) {
    while_continue: /* CIL Label */ ;
#line 802
    if (! ts) {
#line 802
      goto while_break;
    }
    {
#line 804
    tmp___2 = bindtarget(ts->string);
#line 804
    t = tmp___2;
#line 807
    l = nt;
    }
    {
#line 807
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 807
      if (! l) {
#line 807
        goto while_break___0;
      }
      {
#line 808
      tmp___3 = list_copy((LIST *)0, ns);
#line 808
      t->settings = addsettings(t->settings, parse->num, l->string, tmp___3);
#line 807
      l = l->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 802
    ts = ts->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 812
  list_free(nt);
#line 813
  list_free(targets);
  }
#line 815
  return (ns);
}
}
#line 831 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/compile.c"
LIST *compile_switch(PARSE *parse , LOL *args , int *jmp ) 
{ 
  LIST *nt ;
  LIST *tmp ;
  LIST *result ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 837
  tmp = (*((parse->left)->func))(parse->left, args, jmp);
#line 837
  nt = tmp;
#line 838
  result = (LIST *)0;
  }
#line 840
  if (globs.debug[5]) {
    {
#line 842
    debug_compile(0, "switch");
#line 843
    list_print(nt);
#line 844
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 849
  parse = parse->right;
  {
#line 849
  while (1) {
    while_continue: /* CIL Label */ ;
#line 849
    if (! parse) {
#line 849
      goto while_break;
    }
#line 851
    if (nt) {
#line 851
      tmp___0 = nt->string;
    } else {
#line 851
      tmp___0 = "";
    }
    {
#line 851
    tmp___1 = glob((parse->left)->string, tmp___0);
    }
#line 851
    if (! tmp___1) {
      {
#line 854
      parse = (parse->left)->left;
#line 855
      result = (*(parse->func))(parse, args, jmp);
      }
#line 856
      goto while_break;
    }
#line 849
    parse = parse->right;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 860
  list_free(nt);
  }
#line 862
  return (result);
}
}
#line 872 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/compile.c"
LIST *compile_while(PARSE *p , LOL *args , int *jmp ) 
{ 
  LIST *result ;
  LIST *l ;

  {
#line 878
  result = (LIST *)0;
  {
#line 883
  while (1) {
    while_continue: /* CIL Label */ ;
#line 883
    if (*jmp == 0) {
      {
#line 883
      l = (*((p->left)->func))(p->left, args, jmp);
      }
#line 883
      if (! l) {
#line 883
        goto while_break;
      }
    } else {
#line 883
      goto while_break;
    }
    {
#line 888
    list_free(l);
#line 892
    list_free(result);
#line 893
    result = (*((p->right)->func))(p->right, args, jmp);
    }
#line 897
    if (*jmp == 2) {
#line 898
      *jmp = 0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 903
  if (*jmp == 1) {
#line 904
    *jmp = 0;
  } else
#line 903
  if (*jmp == 2) {
#line 904
    *jmp = 0;
  }
#line 908
  return (result);
}
}
#line 918 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/compile.c"
static int level  =    0;
#line 919 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/compile.c"
static char indent[36]  = 
#line 919
  {      (char )'>',      (char )'>',      (char )'>',      (char )'>', 
        (char )'|',      (char )'>',      (char )'>',      (char )'>', 
        (char )'>',      (char )'|',      (char )'>',      (char )'>', 
        (char )'>',      (char )'>',      (char )'|',      (char )'>', 
        (char )'>',      (char )'>',      (char )'>',      (char )'|', 
        (char )'>',      (char )'>',      (char )'>',      (char )'>', 
        (char )'|',      (char )'>',      (char )'>',      (char )'>', 
        (char )'>',      (char )'|',      (char )'>',      (char )'>', 
        (char )'>',      (char )'>',      (char )'|',      (char )'\000'};
#line 915 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/compile.c"
static void debug_compile(int which , char const   *s ) 
{ 
  int i ;

  {
#line 920
  i = ((1 + level) * 2) % 35;
#line 922
  if (which >= 0) {
    {
#line 923
    printf((char const   */* __restrict  */)"%*.*s ", i, i, indent);
    }
  }
#line 925
  if (s) {
    {
#line 926
    printf((char const   */* __restrict  */)"%s ", s);
    }
  }
#line 928
  level += which;
#line 929
  return;
}
}
#line 17 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/hash.h"
void hashdone(struct hash *hp ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/newstr.c"
static struct hash *strhash  =    (struct hash *)0;
#line 36 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/newstr.c"
static int strtotal  =    0;
#line 42 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/newstr.c"
char const   *newstr(char const   *string ) 
{ 
  STRING str ;
  STRING *s ;
  int l ;
  size_t tmp ;
  char *m ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 45
  s = & str;
#line 47
  if (! strhash) {
    {
#line 48
    strhash = hashinit((int )sizeof(STRING ), "strings");
    }
  }
  {
#line 50
  *s = string;
#line 52
  tmp___1 = hashitem(strhash, (HASHDATA **)(& s), 1);
  }
#line 52
  if (! tmp___1) {
    {
#line 54
    tmp = strlen(string);
#line 54
    l = (int )tmp;
#line 55
    tmp___0 = malloc((size_t )(l + 1));
#line 55
    m = (char *)tmp___0;
    }
#line 57
    if (globs.debug[9]) {
      {
#line 58
      printf((char const   */* __restrict  */)"newstr: allocating %d bytes\n", l + 1);
      }
    }
    {
#line 60
    strtotal += l + 1;
#line 61
    memcpy((void */* __restrict  */)m, (void const   */* __restrict  */)string, (size_t )(l + 1));
#line 62
    *s = (STRING )m;
    }
  }
#line 65
  return (*s);
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/newstr.c"
char const   *copystr(char const   *s ) 
{ 


  {
#line 75
  return (s);
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/newstr.c"
void freestr(char const   *s ) 
{ 


  {
#line 85
  return;
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/newstr.c"
void donestr(void) 
{ 


  {
  {
#line 94
  hashdone(strhash);
  }
#line 96
  if (globs.debug[9]) {
    {
#line 97
    printf((char const   */* __restrict  */)"%dK in strings\n", strtotal / 1024);
    }
  }
#line 98
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/headers.c"
static LIST *headers1(char const   *file , LIST *hdrscan ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/headers.c"
void headers(TARGET *t ) 
{ 
  LIST *hdrscan ;
  LIST *hdrrule ;
  LOL lol ;
  LIST *tmp ;
  LIST *tmp___0 ;
  LIST *tmp___1 ;
  LIST *tmp___2 ;

  {
  {
#line 59
  hdrscan = var_get("HDRSCAN");
  }
#line 59
  if (hdrscan) {
    {
#line 59
    hdrrule = var_get("HDRRULE");
    }
#line 59
    if (! hdrrule) {
#line 61
      return;
    }
  } else {
#line 61
    return;
  }
#line 66
  if (globs.debug[6]) {
    {
#line 67
    printf((char const   */* __restrict  */)"header scan %s\n", t->name);
    }
  }
  {
#line 69
  lol_init(& lol);
#line 71
  tmp = list_new((LIST *)0, t->name, 1);
#line 71
  lol_add(& lol, tmp);
#line 72
  tmp___0 = headers1(t->boundname, hdrscan);
#line 72
  lol_add(& lol, tmp___0);
#line 74
  tmp___2 = lol_get(& lol, 1);
  }
#line 74
  if (tmp___2) {
    {
#line 75
    tmp___1 = evaluate_rule(hdrrule->string, & lol, (LIST *)0);
#line 75
    list_free(tmp___1);
    }
  }
  {
#line 79
  lol_free(& lol);
  }
#line 80
  return;
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/headers.c"
static LIST *headers1(char const   *file , LIST *hdrscan ) 
{ 
  FILE *f ;
  int i ;
  int rec ;
  LIST *result ;
  regexp *re[10] ;
  regexp *re_macros ;
  char buf___0[1024] ;
  int tmp ;
  char buf2[1024] ;
  int l ;
  int tmp___0 ;
  char const   *header_filename ;
  char buf2___0[1024] ;
  int l___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 93
  rec = 0;
#line 94
  result = (LIST *)0;
#line 99
  f = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"r");
  }
#line 99
  if (! f) {
#line 100
    return (result);
  }
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    if (rec < 10) {
#line 102
      if (! hdrscan) {
#line 102
        goto while_break;
      }
    } else {
#line 102
      goto while_break;
    }
    {
#line 104
    tmp = rec;
#line 104
    rec ++;
#line 104
    re[tmp] = regcomp(hdrscan->string);
#line 105
    hdrscan = hdrscan->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 110
  re_macros = regcomp("^[ \t]*#[ \t]*include[ \t]*([A-Za-z][A-Za-z0-9_]*).*$");
  }
  {
#line 113
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 113
    tmp___2 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)f);
    }
#line 113
    if (! tmp___2) {
#line 113
      goto while_break___0;
    }
#line 115
    i = 0;
    {
#line 115
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 115
      if (! (i < rec)) {
#line 115
        goto while_break___1;
      }
      {
#line 116
      tmp___0 = regexec(re[i], (char const   *)(buf___0));
      }
#line 116
      if (tmp___0) {
#line 116
        if ((re[i])->startp[1]) {
          {
#line 121
          l = (int )((re[i])->endp[1] - (re[i])->startp[1]);
#line 122
          memcpy((void */* __restrict  */)(buf2), (void const   */* __restrict  */)(re[i])->startp[1],
                 (size_t )l);
#line 123
          buf2[l] = (char)0;
#line 124
          result = list_new(result, (char const   *)(buf2), 0);
          }
#line 126
          if (globs.debug[6]) {
            {
#line 127
            printf((char const   */* __restrict  */)"header found: %s\n", buf2);
            }
          }
        }
      }
#line 115
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 131
    tmp___1 = regexec(re_macros, (char const   *)(buf___0));
    }
#line 131
    if (tmp___1) {
#line 131
      if (re_macros->startp[1]) {
        {
#line 135
        l___0 = (int )(re_macros->endp[1] - re_macros->startp[1]);
#line 137
        memcpy((void */* __restrict  */)(buf2___0), (void const   */* __restrict  */)re_macros->startp[1],
               (size_t )l___0);
#line 138
        buf2___0[l___0] = (char)0;
        }
#line 140
        if (globs.debug[6]) {
          {
#line 141
          printf((char const   */* __restrict  */)"macro header found: %s", buf2___0);
          }
        }
        {
#line 143
        header_filename = macro_header_get((char const   *)(buf2___0));
        }
#line 144
        if (header_filename) {
#line 145
          if (globs.debug[6]) {
            {
#line 146
            printf((char const   */* __restrict  */)" resolved to \'%s\'\n", header_filename);
            }
          }
          {
#line 147
          result = list_new(result, header_filename, 0);
          }
        } else
#line 149
        if (globs.debug[6]) {
          {
#line 150
          printf((char const   */* __restrict  */)" ignored !!\n");
          }
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 155
  free((void *)re_macros);
  }
  {
#line 157
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 157
    if (! rec) {
#line 157
      goto while_break___2;
    }
    {
#line 158
    rec --;
#line 158
    free((void *)((char *)re[rec]));
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 160
  fclose(f);
  }
#line 162
  return (result);
}
}
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 15 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/filesys.h"
void file_dirscan(char const   *dir , void (*func)(void *closure , char const   *file ,
                                                   int found , time_t t ) , void *closure ) ;
#line 16
void file_archscan(char const   *archive , void (*func)(void *closure , char const   *file ,
                                                        int found , time_t t ) , void *closure ) ;
#line 18
int file_time(char const   *filename , time_t *time___0 ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 111 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/fileunix.c"
void file_dirscan(char const   *dir , void (*func)(void *closure , char const   *file ,
                                                   int found , time_t t ) , void *closure ) 
{ 
  PATHNAME f ;
  DIR *d ;
  struct dirent *dirent ;
  char filename[1024] ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 124
  memset((void *)((char *)(& f)), '\000', sizeof(f));
#line 126
  f.part[2].ptr = dir;
#line 127
  tmp = strlen(dir);
#line 127
  f.part[2].len = (int )tmp;
  }
#line 129
  if (*dir) {
#line 129
    dir = dir;
  } else {
#line 129
    dir = ".";
  }
#line 133
  if (f.part[2].len == 1) {
#line 133
    if ((int const   )*(f.part[2].ptr + 0) == 47) {
      {
#line 134
      (*func)(closure, dir, 0, (time_t )0);
      }
    }
  }
  {
#line 138
  d = opendir(dir);
  }
#line 138
  if (! d) {
#line 139
    return;
  }
#line 141
  if (globs.debug[6]) {
    {
#line 142
    printf((char const   */* __restrict  */)"scan directory %s\n", dir);
    }
  }
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 144
    dirent = readdir(d);
    }
#line 144
    if (! dirent) {
#line 144
      goto while_break;
    }
    {
#line 150
    f.part[3].ptr = (char const   *)(dirent->d_name);
#line 152
    tmp___0 = strlen(f.part[3].ptr);
#line 152
    f.part[3].len = (int )tmp___0;
#line 154
    path_build(& f, filename, 0);
#line 156
    (*func)(closure, (char const   *)(filename), 0, (time_t )0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 159
  closedir(d);
  }
#line 160
  return;
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/fileunix.c"
int file_time(char const   *filename , time_t *time___0 ) 
{ 
  struct stat statbuf ;
  int tmp ;

  {
  {
#line 173
  tmp = stat((char const   */* __restrict  */)filename, (struct stat */* __restrict  */)(& statbuf));
  }
#line 173
  if (tmp < 0) {
#line 174
    return (-1);
  }
#line 176
  *time___0 = statbuf.st_mtim.tv_sec;
#line 177
  return (0);
}
}
#line 208
extern int ( /* missing proto */  close)() ;
#line 205
extern int ( /* missing proto */  read)() ;
#line 260
extern int ( /* missing proto */  lseek)() ;
#line 189 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/fileunix.c"
void file_archscan(char const   *archive , void (*func)(void *closure , char const   *file ,
                                                        int found , time_t t ) , void *closure ) 
{ 
  struct ar_hdr ar_hdr ;
  char buf___0[1024] ;
  long offset ;
  char *string_table ;
  int fd ;
  int tmp ;
  int tmp___0 ;
  long lar_date ;
  long lar_size ;
  char lar_name[256] ;
  char *dst ;
  char *src ;
  char const   *e ;
  char *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  char *src___0 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int len ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
  {
#line 199
  string_table = (char *)0;
#line 202
  fd = open(archive, 0, 0);
  }
#line 202
  if (fd < 0) {
#line 203
    return;
  }
  {
#line 205
  tmp = read(fd, buf___0, 8);
  }
#line 205
  if (tmp != 8) {
    {
#line 208
    close(fd);
    }
#line 209
    return;
  } else {
    {
#line 205
    tmp___0 = strncmp("!<arch>\n", (char const   *)(buf___0), (size_t )8);
    }
#line 205
    if (tmp___0) {
      {
#line 208
      close(fd);
      }
#line 209
      return;
    }
  }
#line 212
  offset = 8L;
#line 214
  if (globs.debug[6]) {
    {
#line 215
    printf((char const   */* __restrict  */)"scan archive %s\n", archive);
    }
  }
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 217
    tmp___11 = read(fd, & ar_hdr, sizeof(struct ar_hdr ));
    }
#line 217
    if ((unsigned long )tmp___11 == sizeof(struct ar_hdr )) {
      {
#line 217
      tmp___12 = memcmp((void const   *)(ar_hdr.ar_fmag), (void const   *)"`\n", (size_t )2);
      }
#line 217
      if (tmp___12) {
#line 217
        goto while_break;
      }
    } else {
#line 217
      goto while_break;
    }
    {
#line 223
    dst = lar_name;
#line 227
    ar_hdr.ar_fmag[0] = (char)0;
#line 231
    sscanf((char const   */* __restrict  */)(ar_hdr.ar_date), (char const   */* __restrict  */)"%ld",
           & lar_date);
#line 232
    sscanf((char const   */* __restrict  */)(ar_hdr.ar_size), (char const   */* __restrict  */)"%ld",
           & lar_size);
    }
#line 239
    if ((int )ar_hdr.ar_name[0] != 47) {
#line 245
      src = ar_hdr.ar_name;
#line 246
      e = (char const   *)(src + sizeof(ar_hdr.ar_name));
      {
#line 248
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 248
        if ((unsigned long )src < (unsigned long )e) {
#line 248
          if (*src) {
#line 248
            if ((int )*src != 32) {
#line 248
              if (! ((int )*src != 47)) {
#line 248
                goto while_break___0;
              }
            } else {
#line 248
              goto while_break___0;
            }
          } else {
#line 248
            goto while_break___0;
          }
        } else {
#line 248
          goto while_break___0;
        }
#line 249
        tmp___1 = dst;
#line 249
        dst ++;
#line 249
        tmp___2 = src;
#line 249
        src ++;
#line 249
        *tmp___1 = *tmp___2;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else
#line 251
    if ((int )ar_hdr.ar_name[1] == 47) {
      {
#line 258
      tmp___3 = malloc((size_t )lar_size);
#line 258
      string_table = (char *)tmp___3;
#line 260
      lseek(fd, (unsigned long )offset + sizeof(struct ar_hdr ), 0);
#line 261
      tmp___4 = read(fd, string_table, lar_size);
      }
#line 261
      if ((long )tmp___4 != lar_size) {
        {
#line 262
        printf((char const   */* __restrict  */)"error reading string table\n");
        }
      }
    } else
#line 264
    if (string_table) {
#line 264
      if ((int )ar_hdr.ar_name[1] != 32) {
        {
#line 271
        tmp___5 = atoi((char const   *)(ar_hdr.ar_name + 1));
#line 271
        src___0 = string_table + tmp___5;
        }
        {
#line 273
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 273
          if (! ((int )*src___0 != 47)) {
#line 273
            goto while_break___1;
          }
#line 274
          tmp___6 = dst;
#line 274
          dst ++;
#line 274
          tmp___7 = src___0;
#line 274
          src___0 ++;
#line 274
          *tmp___6 = *tmp___7;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
    {
#line 279
    *dst = (char)0;
#line 285
    tmp___10 = strcmp((char const   *)(lar_name), "#1");
    }
#line 285
    if (! tmp___10) {
      {
#line 287
      tmp___8 = atoi((char const   *)(ar_hdr.ar_name + 3));
#line 287
      len = tmp___8;
#line 288
      tmp___9 = read(fd, lar_name, len);
      }
#line 288
      if (tmp___9 != len) {
        {
#line 289
        printf((char const   */* __restrict  */)"error reading archive entry\n");
        }
      }
#line 290
      lar_name[len] = (char)0;
    }
#line 295
    if (lar_name[0]) {
#line 297
      if (globs.debug[6]) {
        {
#line 298
        printf((char const   */* __restrict  */)"archive name %s found\n", lar_name);
        }
      }
      {
#line 300
      sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%s(%s)",
              archive, lar_name);
#line 302
      (*func)(closure, (char const   *)(buf___0), 1, lar_date);
      }
    }
    {
#line 307
    offset = (long )((unsigned long )offset + (sizeof(struct ar_hdr ) + (unsigned long )((lar_size + 1L) & -2L)));
#line 308
    lseek(fd, offset, 0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 311
  if (string_table) {
    {
#line 312
    free((void *)string_table);
    }
  }
  {
#line 314
  close(fd);
  }
#line 318
  return;
}
}
#line 14 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/variable.h"
int var_string(char const   *in , char *out , int outsize , LOL *lol ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/command.c"
CMD *cmd_new(RULE *rule , LIST *targets , LIST *sources , LIST *shell , int maxline ) 
{ 
  CMD *cmd ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 35
  tmp = malloc(sizeof(CMD ));
#line 35
  cmd = (CMD *)tmp;
#line 37
  cmd->rule = rule;
#line 38
  cmd->shell = shell;
#line 39
  cmd->next = (CMD *)0;
#line 41
  lol_init(& cmd->args);
#line 42
  lol_add(& cmd->args, targets);
#line 43
  lol_add(& cmd->args, sources);
#line 48
  tmp___0 = var_string(rule->actions, cmd->buf, maxline, & cmd->args);
  }
#line 48
  if (tmp___0 < 0) {
    {
#line 50
    cmd_free(cmd);
    }
#line 51
    return ((CMD *)0);
  }
#line 54
  return (cmd);
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/command.c"
void cmd_free(CMD *cmd ) 
{ 


  {
  {
#line 64
  lol_free(& cmd->args);
#line 65
  list_free(cmd->shell);
#line 66
  free((void *)((char *)cmd));
  }
#line 67
  return;
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/hash.c"
static void hashrehash(struct hash *hp ) ;
#line 85
static void hashstat(struct hash *hp ) ;
#line 91 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/hash.c"
int hashitem(struct hash *hp , HASHDATA **data , int enter ) 
{ 
  ITEM **base ;
  register ITEM *i ;
  unsigned char *b ;
  unsigned int keyval ;
  unsigned char *tmp ;
  int tmp___0 ;

  {
#line 99
  b = (unsigned char *)(*data)->key;
#line 102
  if (enter) {
#line 102
    if (! hp->items.more) {
      {
#line 103
      hashrehash(hp);
      }
    }
  }
#line 105
  if (! enter) {
#line 105
    if (! hp->items.nel) {
#line 106
      return (0);
    }
  }
#line 108
  keyval = (unsigned int )*b;
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (! *b) {
#line 110
      goto while_break;
    }
#line 111
    tmp = b;
#line 111
    b ++;
#line 111
    keyval = keyval * 2147059363U + (unsigned int )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  base = hp->tab.base + keyval % (unsigned int )hp->tab.nel;
#line 115
  i = *base;
  {
#line 115
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 115
    if (! i) {
#line 115
      goto while_break___0;
    }
#line 116
    if (keyval == i->hdr.keyval) {
      {
#line 116
      tmp___0 = strcmp((char const   *)i->data.key, (char const   *)(*data)->key);
      }
#line 116
      if (! tmp___0) {
#line 119
        *data = & i->data;
#line 120
        return (1);
      }
    }
#line 115
    i = i->hdr.next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 123
  if (enter) {
    {
#line 125
    i = (ITEM *)hp->items.next;
#line 126
    hp->items.next += hp->items.size;
#line 127
    (hp->items.more) --;
#line 128
    memcpy((void */* __restrict  */)((char *)(& i->data)), (void const   */* __restrict  */)((char *)*data),
           (size_t )hp->items.datalen);
#line 129
    i->hdr.keyval = keyval;
#line 130
    i->hdr.next = *base;
#line 131
    *base = i;
#line 132
    *data = & i->data;
    }
  }
#line 135
  return (0);
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/hash.c"
static void hashrehash(struct hash *hp ) 
{ 
  int i ;
  void *tmp ;
  void *tmp___0 ;
  int nel ;
  char *next ;
  register ITEM *i___0 ;
  ITEM **ip ;
  int tmp___1 ;

  {
#line 144
  (hp->items.list) ++;
#line 144
  i = hp->items.list;
#line 146
  if (i) {
#line 146
    hp->items.more = 2 * hp->items.nel;
  } else {
#line 146
    hp->items.more = hp->inel;
  }
  {
#line 147
  tmp = malloc((size_t )(hp->items.more * hp->items.size));
#line 147
  hp->items.next = (char *)tmp;
#line 149
  hp->items.lists[i].nel = hp->items.more;
#line 150
  hp->items.lists[i].base = hp->items.next;
#line 151
  hp->items.nel += hp->items.more;
  }
#line 153
  if (hp->tab.base) {
    {
#line 154
    free((void *)((char *)hp->tab.base));
    }
  }
  {
#line 156
  hp->tab.nel = hp->items.nel * hp->bloat;
#line 157
  tmp___0 = malloc((unsigned long )hp->tab.nel * sizeof(ITEM **));
#line 157
  hp->tab.base = (ITEM **)tmp___0;
#line 159
  memset((void *)((char *)hp->tab.base), '\000', (unsigned long )hp->tab.nel * sizeof(ITEM *));
#line 161
  i = 0;
  }
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    if (! (i < hp->items.list)) {
#line 161
      goto while_break;
    }
#line 163
    nel = hp->items.lists[i].nel;
#line 164
    next = hp->items.lists[i].base;
    {
#line 166
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 166
      tmp___1 = nel;
#line 166
      nel --;
#line 166
      if (! tmp___1) {
#line 166
        goto while_break___0;
      }
#line 168
      i___0 = (ITEM *)next;
#line 169
      ip = hp->tab.base + i___0->hdr.keyval % (unsigned int )hp->tab.nel;
#line 171
      i___0->hdr.next = *ip;
#line 172
      *ip = i___0;
#line 166
      next += hp->items.size;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 161
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  return;
}
}
#line 185 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/hash.c"
struct hash *hashinit(int datalen , char const   *name ) 
{ 
  struct hash *hp ;
  void *tmp ;

  {
  {
#line 190
  tmp = malloc(sizeof(*hp));
#line 190
  hp = (struct hash *)tmp;
#line 192
  hp->bloat = 3;
#line 193
  hp->tab.nel = 0;
#line 194
  hp->tab.base = (ITEM **)0;
#line 195
  hp->items.more = 0;
#line 196
  hp->items.datalen = datalen;
#line 197
  hp->items.size = (int )(sizeof(struct hashhdr ) + ((((unsigned long )datalen + sizeof(ITEM )) - 1UL) & ~ (sizeof(ITEM ) - 1UL)));
#line 198
  hp->items.list = -1;
#line 199
  hp->items.nel = 0;
#line 200
  hp->inel = 11;
#line 201
  hp->name = name;
  }
#line 203
  return (hp);
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/hash.c"
void hashdone(struct hash *hp ) 
{ 
  int i ;

  {
#line 215
  if (! hp) {
#line 216
    return;
  }
#line 218
  if (globs.debug[9]) {
    {
#line 219
    hashstat(hp);
    }
  }
#line 221
  if (hp->tab.base) {
    {
#line 222
    free((void *)((char *)hp->tab.base));
    }
  }
#line 223
  i = 0;
  {
#line 223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 223
    if (! (i <= hp->items.list)) {
#line 223
      goto while_break;
    }
    {
#line 224
    free((void *)hp->items.lists[i].base);
#line 223
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 225
  free((void *)((char *)hp));
  }
#line 226
  return;
}
}
#line 230 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/hash.c"
static void hashstat(struct hash *hp ) 
{ 
  ITEM **tab ;
  int nel ;
  int count ;
  int sets ;
  int run ;
  int i ;
  int here ;
  ITEM **tmp ;

  {
#line 233
  tab = hp->tab.base;
#line 234
  nel = hp->tab.nel;
#line 235
  count = 0;
#line 236
  sets = 0;
#line 237
  run = (unsigned long )*(tab + (nel - 1)) != (unsigned long )((ITEM *)0);
#line 240
  i = nel;
  {
#line 240
  while (1) {
    while_continue: /* CIL Label */ ;
#line 240
    if (! (i > 0)) {
#line 240
      goto while_break;
    }
#line 242
    tmp = tab;
#line 242
    tab ++;
#line 242
    here = (unsigned long )*tmp != (unsigned long )((ITEM *)0);
#line 242
    if (here) {
#line 243
      count ++;
    }
#line 244
    if (here) {
#line 244
      if (! run) {
#line 245
        sets ++;
      }
    }
#line 246
    run = here;
#line 240
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 249
  printf((char const   */* __restrict  */)"%s table: %d+%d+%d (%dK+%dK) items+table+hash, %f density\n",
         hp->name, count, hp->items.nel, hp->tab.nel, (hp->items.nel * hp->items.size) / 1024,
         ((unsigned long )hp->tab.nel * sizeof(ITEM **)) / 1024UL, (double )((float )count / (float )sets));
  }
#line 257
  return;
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/rules.h"
TARGET *copytarget(TARGET const   *ot ) ;
#line 54 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/builtins.c"
LIST *builtin_depends(PARSE *parse , LOL *args , int *jmp ) ;
#line 55
LIST *builtin_echo(PARSE *parse , LOL *args , int *jmp ) ;
#line 56
LIST *builtin_exit(PARSE *parse , LOL *args , int *jmp ) ;
#line 57
LIST *builtin_flags(PARSE *parse , LOL *args , int *jmp ) ;
#line 58
LIST *builtin_glob(PARSE *parse , LOL *args , int *jmp ) ;
#line 59
LIST *builtin_match(PARSE *parse , LOL *args , int *jmp ) ;
#line 60
LIST *builtin_hdrmacro(PARSE *parse , LOL *args , int *jmp ) ;
#line 64 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/builtins.c"
void load_builtins(void) 
{ 
  RULE *tmp ;
  RULE *tmp___0 ;
  PARSE *tmp___1 ;
  RULE *tmp___2 ;
  RULE *tmp___3 ;
  PARSE *tmp___4 ;
  RULE *tmp___5 ;
  RULE *tmp___6 ;
  PARSE *tmp___7 ;
  RULE *tmp___8 ;
  PARSE *tmp___9 ;
  RULE *tmp___10 ;
  RULE *tmp___11 ;
  PARSE *tmp___12 ;
  RULE *tmp___13 ;
  PARSE *tmp___14 ;
  RULE *tmp___15 ;
  RULE *tmp___16 ;
  PARSE *tmp___17 ;
  RULE *tmp___18 ;
  RULE *tmp___19 ;
  PARSE *tmp___20 ;
  RULE *tmp___21 ;
  RULE *tmp___22 ;
  PARSE *tmp___23 ;
  RULE *tmp___24 ;
  RULE *tmp___25 ;
  PARSE *tmp___26 ;
  RULE *tmp___27 ;
  RULE *tmp___28 ;
  PARSE *tmp___29 ;
  RULE *tmp___30 ;
  RULE *tmp___31 ;
  PARSE *tmp___32 ;
  RULE *tmp___33 ;
  PARSE *tmp___34 ;
  RULE *tmp___35 ;
  RULE *tmp___36 ;
  PARSE *tmp___37 ;
  RULE *tmp___38 ;
  RULE *tmp___39 ;
  PARSE *tmp___40 ;
  RULE *tmp___41 ;
  RULE *tmp___42 ;
  PARSE *tmp___43 ;

  {
  {
#line 67
  tmp = bindrule("Always");
#line 67
  tmp___0 = bindrule("ALWAYS");
#line 67
  tmp___1 = parse_make(& builtin_flags, (PARSE *)0, (PARSE *)0, (PARSE *)0, (char const   *)((char *)0),
                       (char const   *)((char *)0), 8);
#line 67
  tmp___0->procedure = tmp___1;
#line 67
  tmp->procedure = tmp___1;
#line 71
  tmp___2 = bindrule("Depends");
#line 71
  tmp___3 = bindrule("DEPENDS");
#line 71
  tmp___4 = parse_make(& builtin_depends, (PARSE *)0, (PARSE *)0, (PARSE *)0, (char const   *)((char *)0),
                       (char const   *)((char *)0), 0);
#line 71
  tmp___3->procedure = tmp___4;
#line 71
  tmp___2->procedure = tmp___4;
#line 75
  tmp___5 = bindrule("echo");
#line 75
  tmp___6 = bindrule("Echo");
#line 75
  tmp___8 = bindrule("ECHO");
#line 75
  tmp___9 = parse_make(& builtin_echo, (PARSE *)0, (PARSE *)0, (PARSE *)0, (char const   *)((char *)0),
                       (char const   *)((char *)0), 0);
#line 75
  tmp___8->procedure = tmp___9;
#line 75
  tmp___7 = tmp___9;
#line 75
  tmp___6->procedure = tmp___7;
#line 75
  tmp___5->procedure = tmp___7;
#line 80
  tmp___10 = bindrule("exit");
#line 80
  tmp___11 = bindrule("Exit");
#line 80
  tmp___13 = bindrule("EXIT");
#line 80
  tmp___14 = parse_make(& builtin_exit, (PARSE *)0, (PARSE *)0, (PARSE *)0, (char const   *)((char *)0),
                        (char const   *)((char *)0), 0);
#line 80
  tmp___13->procedure = tmp___14;
#line 80
  tmp___12 = tmp___14;
#line 80
  tmp___11->procedure = tmp___12;
#line 80
  tmp___10->procedure = tmp___12;
#line 85
  tmp___15 = bindrule("Glob");
#line 85
  tmp___16 = bindrule("GLOB");
#line 85
  tmp___17 = parse_make(& builtin_glob, (PARSE *)0, (PARSE *)0, (PARSE *)0, (char const   *)((char *)0),
                        (char const   *)((char *)0), 0);
#line 85
  tmp___16->procedure = tmp___17;
#line 85
  tmp___15->procedure = tmp___17;
#line 89
  tmp___18 = bindrule("Includes");
#line 89
  tmp___19 = bindrule("INCLUDES");
#line 89
  tmp___20 = parse_make(& builtin_depends, (PARSE *)0, (PARSE *)0, (PARSE *)0, (char const   *)((char *)0),
                        (char const   *)((char *)0), 1);
#line 89
  tmp___19->procedure = tmp___20;
#line 89
  tmp___18->procedure = tmp___20;
#line 93
  tmp___21 = bindrule("Leaves");
#line 93
  tmp___22 = bindrule("LEAVES");
#line 93
  tmp___23 = parse_make(& builtin_flags, (PARSE *)0, (PARSE *)0, (PARSE *)0, (char const   *)((char *)0),
                        (char const   *)((char *)0), 16);
#line 93
  tmp___22->procedure = tmp___23;
#line 93
  tmp___21->procedure = tmp___23;
#line 97
  tmp___24 = bindrule("Match");
#line 97
  tmp___25 = bindrule("MATCH");
#line 97
  tmp___26 = parse_make(& builtin_match, (PARSE *)0, (PARSE *)0, (PARSE *)0, (char const   *)((char *)0),
                        (char const   *)((char *)0), 0);
#line 97
  tmp___25->procedure = tmp___26;
#line 97
  tmp___24->procedure = tmp___26;
#line 101
  tmp___27 = bindrule("NoCare");
#line 101
  tmp___28 = bindrule("NOCARE");
#line 101
  tmp___29 = parse_make(& builtin_flags, (PARSE *)0, (PARSE *)0, (PARSE *)0, (char const   *)((char *)0),
                        (char const   *)((char *)0), 2);
#line 101
  tmp___28->procedure = tmp___29;
#line 101
  tmp___27->procedure = tmp___29;
#line 105
  tmp___30 = bindrule("NOTIME");
#line 105
  tmp___31 = bindrule("NotFile");
#line 105
  tmp___33 = bindrule("NOTFILE");
#line 105
  tmp___34 = parse_make(& builtin_flags, (PARSE *)0, (PARSE *)0, (PARSE *)0, (char const   *)((char *)0),
                        (char const   *)((char *)0), 4);
#line 105
  tmp___33->procedure = tmp___34;
#line 105
  tmp___32 = tmp___34;
#line 105
  tmp___31->procedure = tmp___32;
#line 105
  tmp___30->procedure = tmp___32;
#line 110
  tmp___35 = bindrule("NoUpdate");
#line 110
  tmp___36 = bindrule("NOUPDATE");
#line 110
  tmp___37 = parse_make(& builtin_flags, (PARSE *)0, (PARSE *)0, (PARSE *)0, (char const   *)((char *)0),
                        (char const   *)((char *)0), 32);
#line 110
  tmp___36->procedure = tmp___37;
#line 110
  tmp___35->procedure = tmp___37;
#line 114
  tmp___38 = bindrule("Temporary");
#line 114
  tmp___39 = bindrule("TEMPORARY");
#line 114
  tmp___40 = parse_make(& builtin_flags, (PARSE *)0, (PARSE *)0, (PARSE *)0, (char const   *)((char *)0),
                        (char const   *)((char *)0), 1);
#line 114
  tmp___39->procedure = tmp___40;
#line 114
  tmp___38->procedure = tmp___40;
#line 118
  tmp___41 = bindrule("HdrMacro");
#line 118
  tmp___42 = bindrule("HDRMACRO");
#line 118
  tmp___43 = parse_make(& builtin_hdrmacro, (PARSE *)0, (PARSE *)0, (PARSE *)0, (char const   *)((char *)0),
                        (char const   *)((char *)0), 0);
#line 118
  tmp___42->procedure = tmp___43;
#line 118
  tmp___41->procedure = tmp___43;
  }
#line 121
  return;
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/builtins.c"
LIST *builtin_depends(PARSE *parse , LOL *args , int *jmp ) 
{ 
  LIST *targets ;
  LIST *tmp ;
  LIST *sources ;
  LIST *tmp___0 ;
  int which ;
  LIST *l ;
  TARGET *t ;
  TARGET *tmp___1 ;

  {
  {
#line 137
  tmp = lol_get(args, 0);
#line 137
  targets = tmp;
#line 138
  tmp___0 = lol_get(args, 1);
#line 138
  sources = tmp___0;
#line 139
  which = parse->num;
#line 142
  l = targets;
  }
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    if (! l) {
#line 142
      goto while_break;
    }
    {
#line 144
    tmp___1 = bindtarget(l->string);
#line 144
    t = tmp___1;
    }
#line 150
    if (parse->num) {
#line 152
      if (! t->includes) {
        {
#line 153
        t->includes = copytarget((TARGET const   *)t);
        }
      }
#line 154
      t = t->includes;
    }
    {
#line 157
    t->depends = targetlist(t->depends, sources);
#line 142
    l = l->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  return ((LIST *)0);
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/builtins.c"
LIST *builtin_echo(PARSE *parse , LOL *args , int *jmp ) 
{ 
  LIST *tmp ;

  {
  {
#line 176
  tmp = lol_get(args, 0);
#line 176
  list_print(tmp);
#line 177
  printf((char const   */* __restrict  */)"\n");
  }
#line 178
  return ((LIST *)0);
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/builtins.c"
LIST *builtin_exit(PARSE *parse , LOL *args , int *jmp ) 
{ 
  LIST *tmp ;

  {
  {
#line 194
  tmp = lol_get(args, 0);
#line 194
  list_print(tmp);
#line 195
  printf((char const   */* __restrict  */)"\n");
#line 196
  exit(1);
  }
#line 197
  return ((LIST *)0);
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/builtins.c"
LIST *builtin_flags(PARSE *parse , LOL *args , int *jmp ) 
{ 
  LIST *l ;
  LIST *tmp ;
  TARGET *tmp___0 ;

  {
  {
#line 213
  tmp = lol_get(args, 0);
#line 213
  l = tmp;
  }
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    if (! l) {
#line 215
      goto while_break;
    }
    {
#line 216
    tmp___0 = bindtarget(l->string);
#line 216
    tmp___0->flags = (char )((int )tmp___0->flags | parse->num);
#line 215
    l = l->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 218
  return ((LIST *)0);
}
}
#line 230 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/builtins.c"
static void builtin_glob_back(void *closure , char const   *file , int status , time_t time___0 ) 
{ 
  struct globbing *globbing ;
  LIST *l ;
  PATHNAME f ;
  char buf___0[1024] ;
  int tmp ;

  {
  {
#line 237
  globbing = (struct globbing *)closure;
#line 245
  path_parse(file, & f);
#line 246
  f.part[2].len = 0;
#line 247
  path_build(& f, buf___0, 0);
#line 249
  l = globbing->patterns;
  }
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    if (! l) {
#line 249
      goto while_break;
    }
    {
#line 250
    tmp = glob(l->string, (char const   *)(buf___0));
    }
#line 250
    if (! tmp) {
      {
#line 252
      globbing->results = list_new(globbing->results, file, 0);
      }
#line 253
      goto while_break;
    }
#line 249
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 255
  return;
}
}
#line 257 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/builtins.c"
LIST *builtin_glob(PARSE *parse , LOL *args , int *jmp ) 
{ 
  LIST *l ;
  LIST *tmp ;
  LIST *r ;
  LIST *tmp___0 ;
  struct globbing globbing ;

  {
  {
#line 263
  tmp = lol_get(args, 0);
#line 263
  l = tmp;
#line 264
  tmp___0 = lol_get(args, 1);
#line 264
  r = tmp___0;
#line 268
  globbing.results = (LIST *)0;
#line 269
  globbing.patterns = r;
  }
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
#line 271
    if (! l) {
#line 271
      goto while_break;
    }
    {
#line 272
    file_dirscan(l->string, & builtin_glob_back, (void *)(& globbing));
#line 271
    l = l->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 274
  return (globbing.results);
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/builtins.c"
LIST *builtin_match(PARSE *parse , LOL *args , int *jmp ) 
{ 
  LIST *l ;
  LIST *r ;
  LIST *result ;
  regexp *re ;
  regexp *tmp ;
  int i ;
  int top ;
  int tmp___0 ;
  char buf___0[1024] ;
  int l___0 ;
  int tmp___1 ;

  {
  {
#line 288
  result = (LIST *)0;
#line 292
  l = lol_get(args, 0);
  }
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
#line 292
    if (! l) {
#line 292
      goto while_break;
    }
    {
#line 294
    tmp = regcomp(l->string);
#line 294
    re = tmp;
#line 298
    r = lol_get(args, 1);
    }
    {
#line 298
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 298
      if (! r) {
#line 298
        goto while_break___0;
      }
      {
#line 299
      tmp___1 = regexec(re, r->string);
      }
#line 299
      if (tmp___1) {
#line 305
        top = 10;
        {
#line 305
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 305
          tmp___0 = top;
#line 305
          top --;
#line 305
          if (! (tmp___0 > 1)) {
#line 305
            goto while_break___1;
          }
#line 306
          if (re->startp[top]) {
#line 307
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 312
        i = 1;
        {
#line 312
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 312
          if (! (i <= top)) {
#line 312
            goto while_break___2;
          }
          {
#line 315
          l___0 = (int )(re->endp[i] - re->startp[i]);
#line 316
          memcpy((void */* __restrict  */)(buf___0), (void const   */* __restrict  */)re->startp[i],
                 (size_t )l___0);
#line 317
          buf___0[l___0] = (char)0;
#line 318
          result = list_new(result, (char const   *)(buf___0), 0);
#line 312
          i ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 298
      r = r->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 322
    free((void *)((char *)re));
#line 292
    l = l->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 325
  return (result);
}
}
#line 329 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/builtins.c"
LIST *builtin_hdrmacro(PARSE *parse , LOL *args , int *jmp ) 
{ 
  LIST *l ;
  LIST *tmp ;
  TARGET *t ;
  TARGET *tmp___0 ;

  {
  {
#line 335
  tmp = lol_get(args, 0);
#line 335
  l = tmp;
  }
  {
#line 337
  while (1) {
    while_continue: /* CIL Label */ ;
#line 337
    if (! l) {
#line 337
      goto while_break;
    }
    {
#line 339
    tmp___0 = bindtarget(l->string);
#line 339
    t = tmp___0;
    }
#line 342
    if (globs.debug[6]) {
      {
#line 343
      printf((char const   */* __restrict  */)"scanning \'%s\' for header file macro definitions\n",
             l->string);
      }
    }
    {
#line 346
    macro_headers(t);
#line 337
    l = l->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 349
  return ((LIST *)0);
}
}
#line 2 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/jambase.c"
char const   *jambase[2709]  = 
#line 2 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/jambase.c"
  {      "\n",      "\n",      "\n",      "\n", 
        "\n",      "\n",      "\n",      "JAMBASEDATE = 2004.10.07 ;\n", 
        "\n",      "\n",      "\n",      "if $(NT)\n", 
        "{\n",      "local SUPPORTED_TOOLSETS = BORLANDC\n",      "VISUALC\n",      "VISUALC16\n", 
        "INTELC\n",      "WATCOM\n",      "MINGW\n",      "LCC\n", 
        "DIGITALMARS\n",      "PELLESC\n",      ";\n",      "\n", 
        "if $(JAM_TOOLSET)\n",      "{\n",      "if ! $(JAM_TOOLSET) in $(SUPPORTED_TOOLSETS)\n",      "{\n", 
        "Echo  \"The JAM_TOOLSET environment variable is defined but its value\" ;\n",      "Echo  \"is invalid, please use one of the following:\" ;\n",      "Echo  ;\n",      "\n", 
        "for t in $(SUPPORTED_TOOLSETS) { Echo \"  \" $(t) ; }\n",      "Exit ;\n",      "}\n",      "}\n", 
        "\n",      "if ! $(JAM_TOOLSET)\n",      "{\n",      "if $(BCCROOT)\n", 
        "{\n",      "JAM_TOOLSET  = BORLANDC ;\n",      "BORLANDC     = $(BCCROOT) ;\n",      "}\n", 
        "else if $(MSVC)\n",      "{\n",      "JAM_TOOLSET = VISUALC16 ;\n",      "VISUALC16   = $(MSVC) ;\n", 
        "}\n",      "else if $(MSVCNT)\n",      "{\n",      "JAM_TOOLSET = VISUALC ;\n", 
        "VISUALC     = $(MSVCNT) ;\n",      "}\n",      "else if $(MINGW)\n",      "{\n", 
        "JAM_TOOLSET = MINGW ;\n",      "}\n",      "else\n",      "{\n", 
        "Echo  \"Jam cannot be run because you didn\'t indicate which compilation toolset\" ;\n",      "Echo  \"to use. To do so, define the JAM_TOOLSET environment variable with\" ;\n",      "Echo  \"one of the following values:\" ;\n",      "Echo  ;\n", 
        "Echo  \"   Value       Toolset Description\" ;\n",      "Echo  ;\n",      "Echo  \"   BORLANDC     Borland C++\" ;\n",      "Echo  \"   VISUALC      Microsoft Visual C++\" ;\n", 
        "Echo  \"   VISUALC16    Microsoft Visual C++ 16 bit\" ;\n",      "Echo  \"   INTELC       Intel C/C++\" ;\n",      "Echo  \"   WATCOM       Watcom C/C++\" ;\n",      "Echo  \"   MINGW        MinGW (gcc)\" ;\n", 
        "Echo  \"   LCC          Win32-LCC\" ;\n",      "Echo  \"   DIGITALMARS  Digital Mars C/C++\" ;\n",      "Echo  \"   PELLESC      Pelles C\" ;\n",      "Echo  ;\n", 
        "Echo  \"The corresponding compiler must be in your path\" ;\n",      "Echo  ;\n",      "Echo  \"  e.g.:  set JAM_TOOLSET=VISUALC\" ;\n",      "Exit  ;\n", 
        "}\n",      "}\n",      "\n",      "MV      ?= move /y ;\n", 
        "CP      ?= copy ;\n",      "RM      ?= del /f/q ;\n",      "RMDIR       ?= rmdir /s/q ;\n",      "SLASH   ?= \\\\ ;\n", 
        "SUFLIB  ?= .lib ;\n",      "SUFOBJ  ?= .obj ;\n",      "SUFEXE  ?= .exe ;\n",      "\n", 
        "SUFLIBSHR ?= .dll ;\n",      "\n",      "if $(JAM_TOOLSET) = BORLANDC\n",      "{\n", 
        "Echo \"Compiler is Borland C++\" ;\n",      "\n",      "AR          ?= tlib /C /P64 ;\n",      "CC          ?= bcc32 ;\n", 
        "CCFLAGS     ?= -w- -q -DWIN -tWR -tWM -tWC ;\n",      "C++         ?= $(CC) ;\n",      "C++FLAGS    ?= $(CCFLAGS) -P ;\n",      "LINK        ?= $(CC) ;\n", 
        "ILINK       ?= ilink32 -q ;\n",      "IMPLIB      ?= implib ;\n",      "LINKFLAGS   ?= $(CCFLAGS) ;\n",      "STDLIBPATH  ?= $(BORLANDC)\\\\lib ;\n", 
        "STDHDRS     ?= $(BORLANDC)\\\\include ;\n",      "NOARSCAN    ?= true ;\n",      "ILINKLIBS   ?= C0D32.OBJ CW32.LIB IMPORT32.LIB ;\n",      "PICFLAGS    ?= -tWD ;\n", 
        "}\n",      "else if $(JAM_TOOLSET) = VISUALC16\n",      "{\n",      "Echo \"Compiler is Microsoft Visual C++ 16 bit\" ;\n", 
        "\n",      "AR      ?= lib /nologo ;\n",      "CC      ?= cl /nologo ;\n",      "CCFLAGS     ?= /D \"\\\"WIN\\\"\" ;\n", 
        "C++     ?= $(CC) ;\n",      "C++FLAGS    ?= $(CCFLAGS) ;\n",      "LINK        ?= $(CC) ;\n",      "LINKFLAGS   ?= $(CCFLAGS) ;\n", 
        "LINKLIBS    ?=\n",      "$(MSVC)\\\\lib\\\\mlibce.lib\n",      "$(MSVC)\\\\lib\\\\oldnames.lib\n",      ";\n", 
        "LINKLIBS    ?= ;\n",      "NOARSCAN    ?= true ;\n",      "OPTIM       ?= \"\" ;\n",      "STDHDRS     ?= $(VISUALC16)\\\\include ;\n", 
        "UNDEFFLAG   ?= \"/u _\" ;\n",      "}\n",      "else if $(JAM_TOOLSET) = VISUALC\n",      "{\n", 
        "\n",      "MSVCNT      ?= $(MSVCDIR) ;\n",      "\n",      "\n", 
        "local I ; if $(OSPLAT) = IA64 { I = ia64\\\\ ; } else { I = \"\" ; }\n",      "\n",      "AR          ?= lib ;\n",      "AS          ?= masm386 ;\n", 
        "CC          ?= cl /nologo ;\n",      "CCFLAGS     ?= \"\" ;\n",      "C++         ?= $(CC) ;\n",      "C++FLAGS    ?= $(CCFLAGS) ;\n", 
        "LINK        ?= link /nologo ;\n",      "LINKFLAGS   ?= \"\" ;\n",      "LINKLIBS    ?=\n",      "$(MSVCNT)\\\\lib\\\\$(I)libc.lib\n", 
        "$(MSVCNT)\\\\lib\\\\$(I)oldnames.lib\n",      "$(MSVCNT)\\\\lib\\\\$(I)kernel32.lib ;\n",      "OPTIM       ?= \"\" ;\n",      "STDHDRS     ?= $(VISUALC)\\\\include ;\n", 
        "UNDEFFLAG   ?= \"/u _\" ;\n",      "}\n",      "else if $(JAM_TOOLSET) = INTELC\n",      "{\n", 
        "Echo \"Compiler is Intel C/C++\" ;\n",      "\n",      "if ! $(VISUALC)\n",      "{\n", 
        "Echo \"As a special exception, when using the Intel C++ compiler, you need\" ;\n",      "Echo \"to define the VISUALC environment variable to indicate the location\" ;\n",      "Echo \"of your Visual C++ installation. Aborting..\" ;\n",      "Exit ;\n", 
        "}\n",      "\n",      "AR          ?= lib ;\n",      "AS          ?= masm386 ;\n", 
        "CC          ?= icl /nologo ;\n",      "CCFLAGS     ?= \"\" ;\n",      "C++         ?= $(CC) ;\n",      "C++FLAGS    ?= $(CCFLAGS) ;\n", 
        "LINK        ?= link /nologo ;\n",      "LINKFLAGS   ?= \"\" ;\n",      "LINKLIBS    ?= $(VISUALC)\\\\lib\\\\advapi32.lib\n",      "$(VISUALC)\\\\lib\\\\libc.lib\n", 
        "$(VISUALC)\\\\lib\\\\oldnames.lib\n",      "$(VISUALC)\\\\lib\\\\kernel32.lib ;\n",      "OPTIM       ?= \"\" ;\n",      "STDHDRS     ?= $(INTELC)\\include $(VISUALC)\\\\include ;\n", 
        "UNDEFFLAG   ?= \"/u _\" ;\n",      "}\n",      "else if $(JAM_TOOLSET) = WATCOM\n",      "{\n", 
        "Echo \"Compiler is Watcom C/C++\" ;\n",      "\n",      "AR          ?= wlib ;\n",      "CC          ?= wcc386 ;\n", 
        "CCFLAGS     ?= /zq /DWIN32 /I$(WATCOM)\\\\h ; # zq=quiet\n",      "C++         ?= wpp386 ;\n",      "C++FLAGS    ?= $(CCFLAGS) ;\n",      "CP          ?= copy ;\n", 
        "DOT         ?= . ;\n",      "DOTDOT      ?= .. ;\n",      "LINK        ?= wcl386 ;\n",      "LINKFLAGS   ?= /zq ; # zq=quiet\n", 
        "LINKLIBS    ?= ;\n",      "MV          ?= move ;\n",      "NOARSCAN    ?= true ;\n",      "OPTIM       ?= ;\n", 
        "RM          ?= del /f ;\n",      "SLASH       ?= \\\\ ;\n",      "STDHDRS     ?= $(WATCOM)\\\\h $(WATCOM)\\\\h\\\\nt ;\n",      "SUFEXE      ?= .exe ;\n", 
        "SUFLIB      ?= .lib ;\n",      "SUFOBJ      ?= .obj ;\n",      "UNDEFFLAG   ?= \"/u _\" ;\n",      "PICFLAGS     = -s ;  # disable stack checks\n", 
        "}\n",      "else if $(JAM_TOOLSET) = MINGW\n",      "{\n",      "Echo \"Compiler is GCC with Mingw\" ;\n", 
        "\n",      "AR              ?= ar -ru ;\n",      "CC              ?= gcc ;\n",      "CCFLAGS         ?= \"\" ;\n", 
        "C++             ?= $(CC) ;\n",      "C++FLAGS        ?= $(CCFLAGS) ;\n",      "LINK            ?= $(CC) ;\n",      "LINKFLAGS       ?= \"\" ;\n", 
        "LINKLIBS        ?= \"\" ;\n",      "OPTIM           ?= ;\n",      "SUFOBJ           = .o ;\n",      "SUFLIB           = .a ;\n", 
        "SLASH            = / ;\n",      "}\n",      "else if $(JAM_TOOLSET) = LCC\n",      "{\n", 
        "Echo \"Compiler is Win32-LCC\" ;\n",      "\n",      "AR              ?= lcclib ;\n",      "CC              ?= lcc ;\n", 
        "CCFLAGS         ?= \"\" ;\n",      "C++             ?= $(CC) ;\n",      "C++FLAGS        ?= $(CCFLAGS) ;\n",      "LINK            ?= lcclnk ;\n", 
        "LINKFLAGS       ?= \"\" ;\n",      "LINKLIBS        ?= \"\" ;\n",      "OPTIM           ?= ;\n",      "NOARSCAN         = true ;\n", 
        "}\n",      "else if $(JAM_TOOLSET) = DIGITALMARS\n",      "{\n",      "Echo \"Compiler is Digital Mars C/C++\" ;\n", 
        "\n",      "AR              ?= lib -c ;\n",      "CC              ?= dmc ;\n",      "CCFLAGS         ?= \"\" ;\n", 
        "C++             ?= $(CC) ;\n",      "C++FLAGS        ?= $(CCFLAGS) ;\n",      "LINK            ?= link /nologo ;\n",      "LINKFLAGS       ?= \"/EXETYPE:NT /NOMAP\" ;\n", 
        "LINKLIBS        ?= USER32.LIB\n",      "KERNEL32.LIB\n",      "GDI32.LIB ;\n",      "OPTIM           ?= ;\n", 
        "NOARSCAN         = true ;\n",      "PICFLAGS         = -mn -WD ;\n",      "}\n",      "else if $(JAM_TOOLSET) = PELLESC\n", 
        "{\n",      "Echo \"Compiler is PellesC\" ;\n",      "\n",      "AR        ?= polib ;\n", 
        "CC        ?= pocc ;\n",      "CCFLAGS   ?= \"\" ;\n",      "LINK      ?= polink ;\n",      "LINKFLAGS ?= ;\n", 
        "LINKLIBS  ?= ;\n",      "OPTIM     ?= ;\n",      "NOARSCAN   = true ;\n",      "LINKLIBS  ?=\n", 
        "crt.lib oldnames.lib Win\\\\kernel32.lib ;\n",      "}\n",      "else\n",      "{\n", 
        "Exit \"On NT, set BCCROOT, MSVCNT, MINGW or MSVC to the root of the\"\n",      "\"Borland or Microsoft directories.\" ;\n",      "}\n",      "\n", 
        "STDHRS ?= \"\" ;\n",      "}\n",      "else if $(OS2)\n",      "{\n", 
        "local SUPPORTED_TOOLSETS = \"EMX\" \"WATCOM\" ;\n",      "\n",      "TOOLSET = \"\" ;\n",      "\n", 
        "if $(JAM_TOOLSET)\n",      "{\n",      "if ! $(JAM_TOOLSET) in $(SUPPORTED_TOOLSETS)\n",      "{\n", 
        "Echo  \"The JAM_TOOLSET environment variable is defined but its value\" ;\n",      "Echo  \"is invalid, please use one of the following:\" ;\n",      "Echo  ;\n",      "\n", 
        "for t in $(SUPPORTED_TOOLSETS) { Echo \"  \" $(t) ; }\n",      "Exit ;\n",      "}\n",      "}\n", 
        "\n",      "if ! $(JAM_TOOLSET)\n",      "{\n",      "if $(watcom)\n", 
        "{\n",      "WATCOM   = $(watcom) ;\n",      "TOOLSET  = WATCOM ;\n",      "}\n", 
        "else\n",      "{\n",      "Echo  \"Jam cannot be run because you didn\'t indicate which compilation toolset\" ;\n",      "Echo  \"to use. To do so, follow these simple instructions:\" ;\n", 
        "Echo  ;\n",      "Echo  \"  - define one of the following environment variable, with the\" ;\n",      "Echo  \"    appropriate value according to this list:\" ;\n",      "Echo  ;\n", 
        "Echo  \"   Variable    Toolset                      Description\" ;\n",      "Echo  ;\n",      "Echo  \"   WATCOM      Watcom C/C++                 Watcom install path\" ;\n",      "Echo  \"   EMX         EMX (gcc)                    EMX install path\" ;\n", 
        "Echo  ;\n",      "Echo  \"  - define the JAM_TOOLSET environment variable with the *name*\" ;\n",      "Echo  \"    of the toolset variable you want to use.\" ;\n",      "Echo  ;\n", 
        "Echo  \"  e.g.:  set WATCOM=C:\\WATCOM\" ;\n",      "Echo  \"         set JAM_TOOLSET=WATCOM\" ;\n",      "Echo  ;\n",      "Exit  ;\n", 
        "}\n",      "}\n",      "\n",      "RM       = del /f ;\n", 
        "CP       = copy ;\n",      "MV      ?= move ;\n",      "DOT     ?= . ;\n",      "DOTDOT  ?= .. ;\n", 
        "SUFLIB  ?= .lib ;\n",      "SUFOBJ  ?= .obj ;\n",      "SUFEXE  ?= .exe ;\n",      "\n", 
        "SUFLIBSHR ?= .dll ;\n",      "\n",      "if $(JAM_TOOLSET) = WATCOM\n",      "{\n", 
        "AR          ?= wlib ;\n",      "BINDIR      ?= \\\\os2\\\\apps ;\n",      "CC          ?= wcc386 ;\n",      "CCFLAGS     ?= /zq /DOS2 /I$(WATCOM)\\\\h ; # zq=quiet\n", 
        "C++         ?= wpp386 ;\n",      "C++FLAGS    ?= $(CCFLAGS) ;\n",      "CP          ?= copy ;\n",      "DOT         ?= . ;\n", 
        "DOTDOT      ?= .. ;\n",      "LINK        ?= wcl386 ;\n",      "LINKFLAGS   ?= /zq ; # zq=quiet\n",      "LINKLIBS    ?= ;\n", 
        "MV          ?= move ;\n",      "NOARSCAN    ?= true ;\n",      "OPTIM       ?= ;\n",      "RM          ?= del /f ;\n", 
        "SLASH       ?= \\\\ ;\n",      "STDHDRS     ?= $(WATCOM)\\\\h ;\n",      "SUFEXE      ?= .exe ;\n",      "SUFLIB      ?= .lib ;\n", 
        "SUFOBJ      ?= .obj ;\n",      "UNDEFFLAG   ?= \"/u _\" ;\n",      "}\n",      "else if $(JAM_TOOLSET) = EMX\n", 
        "{\n",      "Echo \"Compiler is GCC-EMX\" ;\n",      "AR            ?= ar -ru ;\n",      "CC            ?= gcc ;\n", 
        "CCFLAGS       ?= \"\" ;\n",      "C++           ?= $(CC) ;\n",      "C++FLAGS      ?= $(CCFLAGS) ;\n",      "LINK          ?= $(CC) ;\n", 
        "LINKFLAGS     ?= \"\" ;\n",      "LINKLIBS      ?= \"\" ;\n",      "OPTIM         ?= ;\n",      "SUFOBJ         = .o ;\n", 
        "SUFLIB         = .a ;\n",      "UNDEFFLAG     ?= \"-U\" ;\n",      "SLASH          = / ;\n",      "}\n", 
        "else\n",      "{\n",      "Exit  \"Sorry, but the $(JAM_TOOLSET) toolset isn\'t supported for now\" ;\n",      "}\n", 
        "}\n",      "else if $(VMS)\n",      "{\n",      "C++     ?= cxx ;\n", 
        "C++FLAGS    ?= ;\n",      "CC      ?= cc ;\n",      "CCFLAGS     ?= ;\n",      "CHMOD       ?= set file/prot= ;\n", 
        "CP      ?= copy/replace ;\n",      "CRELIB      ?= true ;\n",      "DOT     ?= [] ;\n",      "DOTDOT      ?= [-] ;\n", 
        "EXEMODE     ?= (w:e) ;\n",      "FILEMODE    ?= (w:r) ;\n",      "HDRS        ?= ;\n",      "LINK        ?= link ;\n", 
        "LINKFLAGS   ?= \"\" ;\n",      "LINKLIBS    ?= ;\n",      "MKDIR       ?= create/dir ;\n",      "MV      ?= rename ;\n", 
        "OPTIM       ?= \"\" ;\n",      "RM      ?= delete ;\n",      "RUNVMS      ?= mcr ;\n",      "SHELLMODE   ?= (w:er) ;\n", 
        "SLASH       ?= . ;\n",      "STDHDRS     ?= decc$library_include ;\n",      "SUFEXE      ?= .exe ;\n",      "SUFLIB      ?= .olb ;\n", 
        "SUFOBJ      ?= .obj ;\n",      "\n",      "switch $(OS)\n",      "{\n", 
        "case OPENVMS : CCFLAGS ?= /stand=vaxc ;\n",      "case VMS     : LINKLIBS ?= sys$library:vaxcrtl.olb/lib ;\n",      "}\n",      "}\n", 
        "else if $(MAC)\n",      "{\n",      "local OPT ;\n",      "\n", 
        "CW  ?= \"{CW}\" ;\n",      "\n",      "MACHDRS ?=\n",      "\"$(UMACHDRS):Universal:Interfaces:CIncludes\"\n", 
        "\"$(CW):MSL:MSL_C:MSL_Common:Include\"\n",      "\"$(CW):MSL:MSL_C:MSL_MacOS:Include\" ;\n",      "\n",      "MACLIBS ?=\n", 
        "\"$(CW):MacOS Support:Universal:Libraries:StubLibraries:Interfacelib\"\n",      "\"$(CW):MacOS Support:Universal:Libraries:StubLibraries:Mathlib\" ;\n",      "\n",      "MPWLIBS ?=\n", 
        "\"$(CW):MacOS Support:Libraries:Runtime:Libs:MSL_MPWCRuntime_PPC.lib\"\n",      "\"$(CW):MSL:MSL_C:MSL_MacOS:Lib:PPC:MSL_C_PPC_MPW.Lib\" ;\n",      "\n",      "MPWNLLIBS ?=\n", 
        "\"$(CW):MacOS Support:Libraries:Runtime:Libs:MSL_MPWCRuntime_PPC.lib\"\n",      "\"$(CW):MSL:MSL_C:MSL_MacOS:Lib:PPC:MSL_C_PPC_MPW(NL).Lib\" ;\n",      "\n",      "SIOUXHDRS ?= ;\n", 
        "\n",      "SIOUXLIBS ?=\n",      "\"$(CW):MacOS Support:Libraries:Runtime:Libs:MSL_Runtime_PPC.lib\"\n",      "\"$(CW):MSL:MSL_C:MSL_MacOS:Lib:PPC:MSL_SIOUX_PPC.Lib\"\n", 
        "\"$(CW):MSL:MSL_C:MSL_MacOS:Lib:PPC:MSL_C_PPC.Lib\" ;\n",      "\n",      "C++     ?= mwcppc ;\n",      "C++FLAGS    ?= -w off ;\n", 
        "CC      ?= mwcppc ;\n",      "CCFLAGS     ?= -w off ;\n",      "CP      ?= duplicate -y ;\n",      "DOT     ?= \":\" ;\n", 
        "DOTDOT      ?= \"::\" ;\n",      "HDRS        ?= $(MACHDRS) $(MPWHDRS) ;\n",      "LINK        ?= mwlinkppc ;\n",      "LINKFLAGS   ?= -mpwtool -warn ;\n", 
        "LINKLIBS    ?= $(MACLIBS) $(MPWLIBS) ;\n",      "MKDIR       ?= newfolder ;\n",      "MV      ?= rename -y ;\n",      "NOARSCAN    ?= true ;\n", 
        "OPTIM       ?= ;\n",      "RM      ?= delete -y ;\n",      "SLASH       ?= \":\" ;\n",      "STDHDRS     ?= ;\n", 
        "SUFLIB      ?= .lib ;\n",      "SUFOBJ      ?= .o ;\n",      "}\n",      "else if $(OS) = BEOS && $(OSPLAT) = PPC\n", 
        "{\n",      "AR      ?= mwld -xml -o ;\n",      "BINDIR      ?= /boot/home/config/bin ;\n",      "CC      ?= mwcc ;\n", 
        "CCFLAGS     ?= -nosyspath ;\n",      "C++     ?= $(CC) ;\n",      "C++FLAGS    ?= -nosyspath ;\n",      "CHMOD       ?= chmod ;\n", 
        "CHGRP       ?= chgrp ;\n",      "CHOWN       ?= chown ;\n",      "FORTRAN     ?= \"\" ;\n",      "LEX     ?= flex ;\n", 
        "LIBDIR      ?= /boot/home/config/lib ;\n",      "LINK        ?= mwld ;\n",      "LINKFLAGS   ?= \"\" ;\n",      "MANDIR      ?= /boot/home/config/man ;\n", 
        "NOARSCAN    ?= true ;\n",      "RANLIB      ?= ranlib ;\n",      "STDHDRS     ?= /boot/develop/headers/posix ;\n",      "YACC        ?= bison -y ;\n", 
        "YACCGEN     ?= .c ;\n",      "YACCFILES   ?= y.tab ;\n",      "YACCFLAGS   ?= -d ;\n",      "}\n", 
        "else if $(OS) = BEOS\n",      "{\n",      "BINDIR      ?= /boot/home/config/bin ;\n",      "CC      ?= gcc ;\n", 
        "C++     ?= $(CC) ;\n",      "CHMOD       ?= chmod ;\n",      "CHGRP       ?= chgrp ;\n",      "CHOWN       ?= chown ;\n", 
        "FORTRAN     ?= \"\" ;\n",      "LEX     ?= flex ;\n",      "LIBDIR      ?= /boot/home/config/lib ;\n",      "LINK        ?= gcc ;\n", 
        "MANDIR      ?= /boot/home/config/man ;\n",      "NOARSCAN    ?= true ;\n",      "RANLIB      ?= ranlib ;\n",      "STDHDRS     ?= /boot/develop/headers/posix ;\n", 
        "YACC        ?= bison -y ;\n",      "YACCGEN     ?= .c ;\n",      "YACCFILES   ?= y.tab ;\n",      "YACCFLAGS   ?= -d ;\n", 
        "}\n",      "else if $(UNIX)\n",      "{\n",      "switch $(OS)\n", 
        "{\n",      "case AIX :\n",      "LINKLIBS    ?= -lbsd ;\n",      "\n", 
        "case AMIGA :\n",      "CC      ?= gcc ;\n",      "YACC        ?= bison -y ;\n",      "\n", 
        "case CYGWIN :\n",      "CC      ?= gcc ;\n",      "CCFLAGS     += -D__cygwin__ ;\n",      "LEX     ?= flex ;\n", 
        "JAMSHELL    ?= sh -c ;\n",      "RANLIB      ?= \"\" ;\n",      "SUFEXE      ?= .exe ;\n",      "YACC        ?= bison -y ;\n", 
        "\n",      "case DGUX :\n",      "RANLIB      ?= \"\" ;\n",      "RELOCATE    ?= true ;\n", 
        "\n",      "case HPUX :\n",      "RANLIB      ?= \"\" ;\n",      "\n", 
        "case INTERIX :\n",      "CC      ?= gcc ;\n",      "JAMSHELL    ?= sh -c ;\n",      "RANLIB      ?= \"\" ;\n", 
        "\n",      "case IRIX :\n",      "RANLIB      ?= \"\" ;\n",      "\n", 
        "case MPEIX :\n",      "CC      ?= gcc ;\n",      "C++     ?= gcc ;\n",      "CCFLAGS     += -D_POSIX_SOURCE ;\n", 
        "HDRS        += /usr/include ;\n",      "RANLIB      ?= \"\" ;\n",      "NOARSCAN    ?= true ;\n",      "NOARUPDATE  ?= true ;\n", 
        "\n",      "case MVS :\n",      "RANLIB      ?= \"\" ;\n",      "\n", 
        "case NEXT :\n",      "AR      ?= libtool -o ;\n",      "RANLIB      ?= \"\" ;\n",      "\n", 
        "case MACOSX :\n",      "C++     ?= c++ ;\n",      "MANDIR      ?= /usr/local/share/man ;\n",      "\n", 
        "case NCR :\n",      "RANLIB      ?= \"\" ;\n",      "\n",      "case PTX :\n", 
        "RANLIB      ?= \"\" ;\n",      "\n",      "case QNX :\n",      "AR      ?= wlib ;\n", 
        "CC      ?= cc ;\n",      "CCFLAGS     ?= -Q ; # quiet\n",      "C++     ?= $(CC) ;\n",      "C++FLAGS    ?= -Q ; # quiet\n", 
        "LINK        ?= $(CC) ;\n",      "LINKFLAGS   ?= -Q ; # quiet\n",      "NOARSCAN    ?= true ;\n",      "RANLIB      ?= \"\" ;\n", 
        "\n",      "case SCO :\n",      "RANLIB      ?= \"\" ;\n",      "RELOCATE    ?= true ;\n", 
        "\n",      "case SINIX :\n",      "RANLIB      ?= \"\" ;\n",      "\n", 
        "case SOLARIS :\n",      "RANLIB      ?= \"\" ;\n",      "AR      ?= \"/usr/ccs/bin/ar ru\" ;\n",      "\n", 
        "case UNICOS :\n",      "NOARSCAN    ?= true ;\n",      "OPTIM       ?= -O0 ;\n",      "\n", 
        "case UNIXWARE :\n",      "RANLIB      ?= \"\" ;\n",      "RELOCATE    ?= true ;\n",      "}\n", 
        "\n",      "\n",      "CCFLAGS     ?= ;\n",      "C++FLAGS    ?= $(CCFLAGS) ;\n", 
        "CHMOD       ?= chmod ;\n",      "CHGRP       ?= chgrp ;\n",      "CHOWN       ?= chown ;\n",      "LEX         ?= lex ;\n", 
        "LINKFLAGS   ?= $(CCFLAGS) ;\n",      "LINKLIBS    ?= ;\n",      "OPTIM       ?= -O ;\n",      "RANLIB      ?= ranlib ;\n", 
        "YACC        ?= yacc ;\n",      "YACCGEN     ?= .c ;\n",      "YACCFILES   ?= y.tab ;\n",      "YACCFLAGS   ?= -d ;\n", 
        "\n",      "SUFOBJSHR   ?= .lo ;\n",      "SUFLIBSHR   ?= .la ;\n",      "PICFLAGS    ?= -fpic ;\n", 
        "STDHDRS     ?= /usr/include ;\n",      "}\n",      "\n",      "SUFOBJSHR ?= $(SUFOBJ) ;\n", 
        "SUFLIBSHR ?= $(SUFLIB) ;\n",      "\n",      "\n",      "DC ?= dmd ;\n", 
        "\n",      "\n",      "AR      ?= ar ru ;\n",      "AS      ?= as ;\n", 
        "ASFLAGS     ?= ;\n",      "AWK     ?= awk ;\n",      "BINDIR      ?= /usr/local/bin ;\n",      "C++     ?= cc ;\n", 
        "C++FLAGS    ?= ;\n",      "CC      ?= cc ;\n",      "CCFLAGS     ?= ;\n",      "CP      ?= cp -f ;\n", 
        "CRELIB      ?= ;\n",      "DOT     ?= . ;\n",      "DOTDOT      ?= .. ;\n",      "EXEMODE     ?= 755 ;\n", 
        "FILEMODE    ?= 644 ;\n",      "FORTRAN     ?= f77 ;\n",      "FORTRANFLAGS    ?= ;\n",      "HDRS        ?= ;\n", 
        "INSTALLGRIST    ?= installed ;\n",      "JAMFILE     ?= Jamfile ;\n",      "JAMRULES    ?= Jamrules ;\n",      "LEX     ?= ;\n", 
        "LIBDIR      ?= /usr/local/lib ;\n",      "LINK        ?= $(CC) ;\n",      "LINKFLAGS   ?= ;\n",      "LINKLIBS    ?= ;\n", 
        "LN      ?= ln ;\n",      "MANDIR      ?= /usr/local/man ;\n",      "MKDIR       ?= mkdir ;\n",      "MV      ?= mv -f ;\n", 
        "OPTIM       ?= ;\n",      "RCP     ?= rcp ;\n",      "RM      ?= rm -f ;\n",      "RMDIR       ?= $(RM) ;\n", 
        "RSH     ?= rsh ;\n",      "SED     ?= sed ;\n",      "SHELLHEADER ?= \"#!/bin/sh\" ;\n",      "SHELLMODE   ?= 755 ;\n", 
        "SLASH       ?= / ;\n",      "SUBDIRRULES     ?= ;\n",      "SUBDIRRESET     ?= ASFLAGS HDRS C++FLAGS CCFLAGS ;\n",      "SUFEXE      ?= \"\" ;\n", 
        "SUFLIB      ?= .a ;\n",      "SUFOBJ      ?= .o ;\n",      "UNDEFFLAG   ?= \"-u _\" ;\n",      "YACC        ?= ;\n", 
        "YACCGEN     ?= ;\n",      "YACCFILES   ?= ;\n",      "YACCFLAGS   ?= ;\n",      "\n", 
        "HDRPATTERN =\n",      "\"^[ \t]*#[ \t]*include[ \t]*[<\\\"]([^\\\">]*)[\\\">].*$\" ;\n",      "\n",      "OSFULL = $(OS)$(OSVER)$(OSPLAT) $(OS)$(OSPLAT) $(OS)$(OSVER) $(OS) ;\n", 
        "\n",      "\n",      "\n",      "Depends all : shell files lib exe obj ;\n", 
        "Depends all shell files lib exe obj : first ;\n",      "NotFile all first shell files lib exe obj dirs clean uninstall ;\n",      "Always  clean uninstall ;\n",      "\n", 
        "\n",      "rule As\n",      "{\n",      "Depends $(<) : $(>) ;\n", 
        "ASFLAGS on $(<) += $(ASFLAGS) $(SUBDIRASFLAGS) ;\n",      "ASHDRS on $(<) = [ FIncludes $(SEARCH_SOURCE) $(SUBDIRHDRS) $(HDRS) ] ;\n",      "}\n",      "\n", 
        "rule Bulk\n",      "{\n",      "local i ;\n",      "\n", 
        "for i in $(>)\n",      "{\n",      "File $(i:D=$(<)) : $(i) ;\n",      "}\n", 
        "}\n",      "\n",      "\n",      "rule Dc\n", 
        "{\n",      "Depends $(<) : $(>) ;\n",      "\n",      "\n", 
        "DCFLAGS on $(<) += $(DCFLAGS) $(SUBDIRDCFLAGS) ;\n",      "}\n",      "\n",      "\n", 
        "rule Cc\n",      "{\n",      "Depends $(<) : $(>) ;\n",      "\n", 
        "\n",      "if $(RELOCATE)\n",      "{\n",      "CcMv $(<) : $(>) ;\n", 
        "}\n",      "\n",      "\n",      "CCFLAGS on $(<) += $(CCFLAGS) $(SUBDIRCCFLAGS) ;\n", 
        "\n",      "CCHDRS on $(<) = [ on $(<) FIncludes $(HDRS) ] ;\n",      "CCDEFS on $(<) = [ on $(<) FDefines $(DEFINES) ] ;\n",      "}\n", 
        "\n",      "rule C++\n",      "{\n",      "Depends $(<) : $(>) ;\n", 
        "\n",      "if $(RELOCATE)\n",      "{\n",      "CcMv $(<) : $(>) ;\n", 
        "}\n",      "\n",      "C++FLAGS on $(<) += $(C++FLAGS) $(SUBDIRC++FLAGS) ;\n",      "\n", 
        "CCHDRS on $(<) = [ on $(<) FIncludes $(HDRS) ] ;\n",      "CCDEFS on $(<) = [ on $(<) FDefines $(DEFINES) ] ;\n",      "}\n",      "\n", 
        "rule Chmod\n",      "{\n",      "if $(CHMOD) { Chmod1 $(<) ; }\n",      "}\n", 
        "\n",      "\n",      "rule File\n",      "{\n", 
        "Depends files : $(<) ;\n",      "Depends $(<) : $(>) ;\n",      "SEARCH on $(>) = $(SEARCH_SOURCE) ;\n",      "MODE on $(<) = $(FILEMODE) ;\n", 
        "Chmod $(<) ;\n",      "}\n",      "\n",      "rule Fortran\n", 
        "{\n",      "Depends $(<) : $(>) ;\n",      "}\n",      "\n", 
        "rule GenFile\n",      "{\n",      "local _t = [ FGristSourceFiles $(<) ] ;\n",      "local _s = [ FAppendSuffix $(>[1]) : $(SUFEXE) ] ;\n", 
        "Depends $(_t) : $(_s) $(>[2-]) ;\n",      "GenFile1 $(_t) : $(_s) $(>[2-]) ;\n",      "Clean clean : $(_t) ;\n",      "}\n", 
        "\n",      "rule GenFile1\n",      "{\n",      "MakeLocate $(<) : $(LOCATE_SOURCE) ;\n", 
        "SEARCH on $(>) = $(SEARCH_SOURCE) ;\n",      "}\n",      "\n",      "rule HardLink\n", 
        "{\n",      "Depends files : $(<) ;\n",      "Depends $(<) : $(>) ;\n",      "SEARCH on $(>) = $(SEARCH_SOURCE) ;\n", 
        "}\n",      "\n",      "rule HdrMacroFile\n",      "{\n", 
        "HDRMACRO $(<) ;\n",      "}\n",      "\n",      "rule HdrRule\n", 
        "{\n",      "\n",      "\n",      "\n", 
        "local s = $(>:G=$(HDRGRIST:E)) ;\n",      "\n",      "Includes $(<) : $(s) ;\n",      "SEARCH on $(s) = $(HDRSEARCH) ;\n", 
        "NoCare $(s) ;\n",      "\n",      "\n",      "HDRSEARCH on $(s) = $(HDRSEARCH) ;\n", 
        "HDRSCAN on $(s) = $(HDRSCAN) ;\n",      "HDRRULE on $(s) = $(HDRRULE) ;\n",      "HDRGRIST on $(s) = $(HDRGRIST) ;\n",      "}\n", 
        "\n",      "\n",      "rule InstallInto\n",      "{\n", 
        "\n",      "local i t ;\n",      "\n",      "t = $(>:G=$(INSTALLGRIST)) ;\n", 
        "\n",      "\n",      "Depends install : $(t) ;\n",      "Clean uninstall : $(t) ;\n", 
        "SEARCH on $(>) = $(SEARCH_SOURCE) ;\n",      "MakeLocate $(t) : $(<) ;\n",      "\n",      "\n", 
        "for i in $(>)\n",      "{\n",      "local tt = $(i:G=$(INSTALLGRIST)) ;\n",      "\n", 
        "Depends $(tt) : $(i) ;\n",      "Install $(tt) : $(i) ;\n",      "Chmod $(tt) ;\n",      "\n", 
        "if $(OWNER) && $(CHOWN)\n",      "{\n",      "Chown $(tt) ;\n",      "OWNER on $(tt) = $(OWNER) ;\n", 
        "}\n",      "\n",      "if $(GROUP) && $(CHGRP)\n",      "{\n", 
        "Chgrp $(tt) ;\n",      "GROUP on $(tt) = $(GROUP) ;\n",      "}\n",      "}\n", 
        "}\n",      "\n",      "rule InstallBin\n",      "{\n", 
        "local _t = [ FAppendSuffix $(>) : $(SUFEXE) ] ;\n",      "\n",      "InstallInto $(<) : $(_t) ;\n",      "MODE on $(_t:G=$(INSTALLGRIST)) = $(EXEMODE) ;\n", 
        "}\n",      "\n",      "rule InstallFile\n",      "{\n", 
        "InstallInto $(<) : $(>) ;\n",      "MODE on $(>:G=$(INSTALLGRIST)) = $(FILEMODE) ;\n",      "}\n",      "\n", 
        "rule InstallLib\n",      "{\n",      "InstallInto $(<) : $(>) ;\n",      "MODE on $(>:G=$(INSTALLGRIST)) = $(FILEMODE) ;\n", 
        "}\n",      "\n",      "rule InstallMan\n",      "{\n", 
        "\n",      "local i s d ;\n",      "\n",      "for i in $(>)\n", 
        "{\n",      "switch $(i:S)\n",      "{\n",      "case .1 : s = 1 ; case .2 : s = 2 ; case .3 : s = 3 ;\n", 
        "case .4 : s = 4 ; case .5 : s = 5 ; case .6 : s = 6 ;\n",      "case .7 : s = 7 ; case .8 : s = 8 ; case .l : s = l ;\n",      "case .n : s = n ; case .man : s = 1 ;\n",      "}\n", 
        "\n",      "d = man$(s) ;\n",      "\n",      "InstallInto $(d:R=$(<)) : $(i) ;\n", 
        "}\n",      "\n",      "MODE on $(>:G=$(INSTALLGRIST)) = $(FILEMODE) ;\n",      "}\n", 
        "\n",      "rule InstallShell\n",      "{\n",      "InstallInto $(<) : $(>) ;\n", 
        "MODE on $(>:G=$(INSTALLGRIST)) = $(SHELLMODE) ;\n",      "}\n",      "\n",      "rule Lex\n", 
        "{\n",      "LexMv $(<) : $(>) ;\n",      "Depends $(<) : $(>) ;\n",      "MakeLocate $(<) : $(LOCATE_SOURCE) ;\n", 
        "Clean clean : $(<) ;\n",      "}\n",      "\n",      "rule Library\n", 
        "{\n",      "LibraryFromObjects $(<) : $(>:S=$(SUFOBJ)) ;\n",      "Objects $(>) ;\n",      "}\n", 
        "\n",      "rule SharedLibrary\n",      "{\n",      "SharedLibraryFromObjects $(<) : $(>:S=$(SUFOBJSHR)) : $(3) : $(4) ;\n", 
        "SharedObjects            $(>) ;\n",      "}\n",      "\n",      "if $(UNIX)\n", 
        "{\n",      "rule LibToolFind\n",      "{\n",      "if $(LIBTOOL) { return $(LIBTOOL) ; }\n", 
        "\n",      "local  matches = [ Glob $(PATH) : libtool ] ;\n",      "\n",      "if ! $(matches)\n", 
        "{\n",      "Exit \"could not find \'libtool\' program in current path. Aborting !\" ;\n",      "}\n",      "LIBTOOL = $(matches[1]) ;\n", 
        "\n",      "return $(LIBTOOL) ;\n",      "}\n",      "}\n", 
        "\n",      "rule LibraryFromObjects\n",      "{\n",      "local _i _l _s ;\n", 
        "\n",      "\n",      "_s = [ FGristFiles $(>) ] ;\n",      "_l = $(<:S=$(SUFLIB)) ;\n", 
        "\n",      "\n",      "if $(KEEPOBJS)\n",      "{\n", 
        "Depends obj : $(_s) ;\n",      "}\n",      "else\n",      "{\n", 
        "Depends lib : $(_l) ;\n",      "}\n",      "\n",      "\n", 
        "if ! $(_l:D)\n",      "{\n",      "MakeLocate $(_l) $(_l)($(_s:BS)) : $(LOCATE_TARGET) ;\n",      "}\n", 
        "\n",      "if $(NOARSCAN)\n",      "{\n",      "\n", 
        "Depends $(_l) : $(_s) ;\n",      "}\n",      "else\n",      "{\n", 
        "\n",      "Depends $(_l) : $(_l)($(_s:BS)) ;\n",      "\n",      "for _i in $(_s)\n", 
        "{\n",      "Depends $(_l)($(_i:BS)) : $(_i) ;\n",      "}\n",      "}\n", 
        "\n",      "Clean clean : $(_l) ;\n",      "\n",      "if $(CRELIB) { CreLib $(_l) : $(_s[1]) ; }\n", 
        "\n",      "Archive $(_l) : $(_s) ;\n",      "\n",      "if $(RANLIB) { Ranlib $(_l) ; }\n", 
        "\n",      "\n",      "if ! ( $(NOARSCAN) || $(NOARUPDATE) ) { RmTemps $(_l) : $(_s) ; }\n",      "}\n", 
        "\n",      "\n",      "rule SharedLibraryFromObjects\n",      "{\n", 
        "local _i _l _s ;\n",      "\n",      "\n",      "_s = [ FGristFiles $(>) ] ;\n", 
        "_l = $(<:S=$(SUFLIBSHR)) ;\n",      "\n",      "\n",      "if $(KEEPOBJS)\n", 
        "{\n",      "Depends obj : $(_s) ;\n",      "}\n",      "else\n", 
        "{\n",      "Depends lib : $(_l) ;\n",      "}\n",      "\n", 
        "\n",      "if ! $(_l:D)\n",      "{\n",      "MakeLocate $(_l) : $(LOCATE_TARGET) ;\n", 
        "}\n",      "\n",      "Depends $(_l) : $(_s) ;\n",      "\n", 
        "Clean clean : $(_l) ;\n",      "\n",      "\n",      "if $(UNIX)\n", 
        "{\n",      "local  libtool = [ LibToolFind ] ;  # find the right libtool\n",      "\n",      "AR on $(_l) = \"$(libtool) --mode=link $(AR)\" ;\n", 
        "}\n",      "else if $(NT)\n",      "{\n",      "local  _implib = $(4) ;\n", 
        "local  _def    = $(3) ;\n",      "\n",      "_implib ?= $(_l:S=$(SUFLIBSHR)$(SUFLIB)) ;\n",      "_def    ?= $(_l:S=.def) ;\n", 
        "\n",      "Clean    clean : $(_implib) ;\n",      "Depends  lib   : $(_implib) $(_def) ;\n",      "\n", 
        "Depends $(_implib) : $(_def) $(_l) ;\n",      "Depends $(_l)      : $(_def) ;\n",      "\n",      "DEFFILENAME on $(_l) = $(_def) ;\n", 
        "IMPLIBNAME  on $(_l) = $(_implib) ;\n",      "\n",      "MakeLocate $(_implib)        : $(LOCATE_TARGET) ;\n",      "MakeLocate $(_implib:S=.exp) : $(LOCATE_TARGET) ;\n", 
        "\n",      "if $(JAM_TOOLSET) in VISUALC BORLANDC LCC WATCOM DIGITALMARS\n",      "{\n",      "SharedLink-$(JAM_TOOLSET) $(_l) : $(_s) : $(_implib) : $(_def) ;\n", 
        "}\n",      "\n",      "DllLink $(_l) : $(_s) ;\n",      "}\n", 
        "else\n",      "{\n",      "Echo \"Sorry, I don\'t know how to make a shared library on your system\" ;\n",      "Exit \"Please contact the FTJam maintainer for help\" ;\n", 
        "}\n",      "}\n",      "\n",      "\n", 
        "\n",      "rule SharedLink-VISUALC\n",      "{\n",      "Clean  clean : $(3:S=.exp) ;\n", 
        "}\n",      "\n",      "\n",      "rule SharedLink-BORLANDC\n", 
        "{\n",      "local  _deffile = $(4) ;\n",      "local  _implib  = $(3) ;\n",      "\n", 
        "LINKFLAGS on $(<) += /x /Gn /Tpd ;\n",      "LINKLIBS on $(<) = $(LINKLIBS) $(ILINKLIBS) ;\n",      "\n",      "DllImplib $(_implib) : $(<) ;\n", 
        "Depends   $(_implib) : $(_deffile) $(<) ;\n",      "Depends   lib        : $(_implib) ;\n",      "\n",      "DEFFILENAME on $(_implib) = $(_deffile) ;\n", 
        "\n",      "MakeLocate $(<:S=.tds) : $(LOCATE_TARGET) ;\n",      "Clean  clean : $(<:S=.tds) ;\n",      "}\n", 
        "\n",      "\n",      "rule SharedLink-LCC\n",      "{\n", 
        "if \"\" {\n",      "}\n",      "\n",      "\n", 
        "Clean clean : $(4:S=.exp) ;\n",      "}\n",      "\n",      "\n", 
        "rule SharedLink-WATCOM\n",      "{\n",      "\n",      "local  _deffile = $(4) ;\n", 
        "local  _implib  = $(3) ;\n",      "\n",      "IMPLIB on $(<) = $(_implib) ;\n",      "DEFFILE on $(<) = $(_deffile) ;\n", 
        "\n",      "MakeLocate $(<:S=.tds) : $(LOCATE_TARGET) ;\n",      "Clean  clean : $(<:S=.tds) ;\n",      "}\n", 
        "\n",      "\n",      "rule SharedLink-DIGITALMARS\n",      "{\n", 
        "}\n",      "\n",      "\n",      "rule Link\n", 
        "{\n",      "MODE on $(<) = $(EXEMODE) ;\n",      "Chmod $(<) ;\n",      "}\n", 
        "\n",      "rule LinkLibraries\n",      "{\n",      "\n", 
        "local _t = [ FAppendSuffix $(<) : $(SUFEXE) ] ;\n",      "\n",      "Depends $(_t) : $(>:S=$(SUFLIB)) ;\n",      "NEEDLIBS on $(_t) += $(>:S=$(SUFLIB)) ;\n", 
        "}\n",      "\n",      "rule LinkSharedLibraries\n",      "{\n", 
        "\n",      "local _t   = [ FAppendSuffix $(<) : $(SUFEXE) ] ;\n",      "local _ext = $(SUFLIBSHR) ;\n",      "\n", 
        "if $(NT) || $(OS2)\n",      "{\n",      "_ext = $(SUFLIBSHR)$(SUFLIB) ;\n",      "}\n", 
        "Depends $(_t) : $(>:S=$(_ext))  ;\n",      "NEEDLIBS on $(_t) += $(>:S=$(_ext)) ;\n",      "}\n",      "\n", 
        "rule Main\n",      "{\n",      "MainFromObjects $(<) : $(>:S=$(SUFOBJ)) ;\n",      "Objects $(>) ;\n", 
        "}\n",      "\n",      "rule MainFromObjects\n",      "{\n", 
        "local _s _t ;\n",      "\n",      "\n",      "_s = [ FGristFiles $(>) ] ;\n", 
        "_t = [ FAppendSuffix $(<) : $(SUFEXE) ] ;\n",      "\n",      "\n",      "if $(_t) != $(<)\n", 
        "{\n",      "Depends $(<) : $(_t) ;\n",      "NotFile $(<) ;\n",      "}\n", 
        "\n",      "\n",      "Depends exe : $(_t) ;\n",      "Depends $(_t) : $(_s) ;\n", 
        "MakeLocate $(_t) : $(LOCATE_TARGET) ;\n",      "\n",      "Clean clean : $(_t) ;\n",      "\n", 
        "if $(JAM_TOOLSET) = BORLANDC {\n",      "MakeLocate $(_t:S=.tds) : $(LOCATE_TARGET) ;\n",      "Clean  clean : $(_t:S=.tds) ;\n",      "}\n", 
        "\n",      "Link $(_t) : $(_s) ;\n",      "}\n",      "\n", 
        "rule MakeLocate\n",      "{\n",      "\n",      "if $(>)\n", 
        "{\n",      "LOCATE on $(<) = $(>) ;\n",      "Depends $(<) : $(>[1]:G=dir) ;\n",      "MkDir $(>[1]:G=dir) ;\n", 
        "}\n",      "}\n",      "\n",      "rule MkDir\n", 
        "{\n",      "\n",      "NoUpdate $(<) ;\n",      "\n", 
        "\n",      "if $(<:G=) != $(DOT) && ! $($(<)-mkdir)\n",      "{\n",      "\n", 
        "$(<)-mkdir = true ;\n",      "Depends dirs : $(<) ;\n",      "MkDir1 $(<) ;\n",      "\n", 
        "\n",      "local s = $(<:P) ;\n",      "\n",      "\n", 
        "if $(NT)\n",      "{\n",      "switch $(s)\n",      "{\n", 
        "case *:   : s = ;\n",      "case *:\\\\ : s = ;\n",      "}\n",      "}\n", 
        "\n",      "if $(UNIX) && $(OS) = CYGWIN\n",      "{\n",      "switch $(s)\n", 
        "{\n",      "case ?:   : s = ;\n",      "case ?:/  : s = ;\n",      "case <dir>/cygdrive   : s = ;\n", 
        "case <dir>/cygdrive/  : s = ;\n",      "}\n",      "}\n",      "\n", 
        "if $(s) = $(<)\n",      "{\n",      "\n",      "NotFile $(s) ;\n", 
        "}\n",      "else if $(s:G=)\n",      "{\n",      "\n", 
        "Depends $(<) : $(s) ;\n",      "MkDir $(s) ;\n",      "}\n",      "}\n", 
        "}\n",      "\n",      "rule Object\n",      "{\n", 
        "\n",      "Clean clean : $(<) ;\n",      "\n",      "MakeLocate $(<) : $(LOCATE_TARGET) ;\n", 
        "SEARCH on $(>) = $(SEARCH_SOURCE) ;\n",      "\n",      "\n",      "HDRS on $(<) = $(SEARCH_SOURCE) $(SUBDIRHDRS) $(HDRS) ;\n", 
        "\n",      "\n",      "\n",      "HDRRULE on $(>) = HdrRule ;\n", 
        "HDRSCAN on $(>) = $(HDRPATTERN) ;\n",      "HDRSEARCH on $(>) =\n",      "$(SEARCH_SOURCE:E) $(SUBDIRHDRS) $(HDRS) $(STDHDRS) ;\n",      "\n", 
        "HDRGRIST on $(>) = $(HDRGRIST) ;\n",      "\n",      "\n",      "DEFINES on $(<) += $(DEFINES) ;\n", 
        "\n",      "\n",      "switch $(>:S)\n",      "{\n", 
        "case .asm : As $(<) : $(>) ;\n",      "case .c :   Cc $(<) : $(>) ;\n",      "case .C :   C++ $(<) : $(>) ;\n",      "case .cc :  C++ $(<) : $(>) ;\n", 
        "case .cpp : C++ $(<) : $(>) ;\n",      "case .cxx : C++ $(<) : $(>) ;\n",      "case .c++ : C++ $(<) : $(>) ;\n",      "case .C++ : C++ $(<) : $(>) ;\n", 
        "case .d :   Dc $(<) : $(>) ;\n",      "case .f :   Fortran $(<) : $(>) ;\n",      "case .l :   Cc $(<) : $(<:S=.c) ;\n",      "Lex $(<:S=.c) : $(>) ;\n", 
        "case .s :   As $(<) : $(>) ;\n",      "case .y :   Cc $(<) : $(<:S=$(YACCGEN)) ;\n",      "Yacc $(<:S=$(YACCGEN)) : $(>) ;\n",      "case * :    UserObject $(<) : $(>) ;\n", 
        "}\n",      "}\n",      "\n",      "rule ObjectCcFlags\n", 
        "{\n",      "CCFLAGS on [ FGristFiles $(<:S=$(SUFOBJ)) ] += $(>) ;\n",      "}\n",      "\n", 
        "rule ObjectC++Flags\n",      "{\n",      "C++FLAGS on [ FGristFiles $(<:S=$(SUFOBJ)) ] += $(>) ;\n",      "}\n", 
        "\n",      "rule ObjectDefines\n",      "{\n",      "\n", 
        "local s = [ FGristFiles $(<:S=$(SUFOBJ)) ] ;\n",      "\n",      "DEFINES on $(s) += $(>) ;\n",      "CCDEFS on $(s) = [ on $(s) FDefines $(DEFINES) ] ;\n", 
        "}\n",      "\n",      "rule ObjectHdrs\n",      "{\n", 
        "\n",      "local s = [ FGristFiles $(<:S=$(SUFOBJ)) ] ;\n",      "\n",      "HDRS on $(s) += $(>) ;\n", 
        "CCHDRS on $(s) = [ on $(s) FIncludes $(HDRS) ] ;\n",      "}\n",      "\n",      "rule Objects\n", 
        "{\n",      "local _i ;\n",      "\n",      "for _i in [ FGristFiles $(<) ]\n", 
        "{\n",      "Object $(_i:S=$(SUFOBJ)) : $(_i) ;\n",      "Depends obj : $(_i:S=$(SUFOBJ)) ;\n",      "}\n", 
        "}\n",      "\n",      "rule SharedObjects\n",      "{\n", 
        "local SUFOBJ = $(SUFOBJSHR) ;\n",      "\n",      "Objects $(<) ;\n",      "\n", 
        "ObjectCcFlags $(<) : $(PICFLAGS) ;\n",      "\n",      "if $(UNIX)\n",      "{\n", 
        "libtool on $(<:S=$(SUFOBJ)) = [ LibToolFind ] ;\n",      "CC on $(<:S=$(SUFOBJ))      = \"$(libtool) --mode=compile $(CC) -dynamic\" ;\n",      "}\n",      "}\n", 
        "\n",      "\n",      "rule RmTemps\n",      "{\n", 
        "Temporary $(>) ;\n",      "}\n",      "\n",      "rule Setuid\n", 
        "{\n",      "MODE on [ FAppendSuffix $(<) : $(SUFEXE) ] = 4755 ;\n",      "}\n",      "\n", 
        "rule Shell\n",      "{\n",      "Depends shell : $(<) ;\n",      "Depends $(<) : $(>) ;\n", 
        "SEARCH on $(>) = $(SEARCH_SOURCE) ;\n",      "MODE on $(<) = $(SHELLMODE) ;\n",      "Clean clean : $(<) ;\n",      "Chmod $(<) ;\n", 
        "}\n",      "\n",      "rule SoftLink\n",      "{\n", 
        "Depends files : $(<) ;\n",      "Depends $(<) : $(>) ;\n",      "SEARCH on $(>) = $(SEARCH_SOURCE) ;\n",      "Clean clean : $(<) ;\n", 
        "}\n",      "\n",      "rule SubDir\n",      "{\n", 
        "\n",      "local _top = $(<[1]) ;\n",      "local _tokens = $(<[2-]) ;\n",      "\n", 
        "\n",      "if ! $(_top)\n",      "{\n",      "Exit SubDir syntax error ;\n", 
        "}\n",      "\n",      "if ! $($(_top)-SET)\n",      "{\n", 
        "$(_top)-SET = true ;\n",      "\n",      "\n",      "if $($(_top))\n", 
        "{\n",      "\n",      "$(_top)-UP = ;\n",      "$(_top)-DOWN = ;\n", 
        "$(_top)-ROOT = $($(_top)) ;\n",      "}\n",      "else\n",      "{\n", 
        "\n",      "\n",      "\n",      "_tokens = [ FReverse $(_tokens) ] ;\n", 
        "SUBDIR_DOWN = [ FReverse $(SUBDIR_DOWN) ] ;\n",      "FStripCommon _tokens : SUBDIR_DOWN ;\n",      "SUBDIR_DOWN = [ FReverse $(SUBDIR_DOWN) ] ;\n",      "_tokens = [ FReverse $(_tokens) ] ;\n", 
        "\n",      "if $(SUBDIR_DOWN) && $(_tokens)\n",      "{\n",      "Echo Warning: SubDir $(<) misplaced! ;\n", 
        "}\n",      "\n",      "\n",      "$(_top)-UP = $(SUBDIR_UP) $(_tokens) ;\n", 
        "$(_top)-DOWN = $(SUBDIR_DOWN) ;\n",      "$(_top)-ROOT = $(SUBDIR_ROOT:E=\"\") ;\n",      "$(_top) = [ FSubDirPath $(_top) ] ;\n",      "}\n", 
        "\n",      "\n",      "SUBDIR_UP = $($(_top)-UP) ;\n",      "SUBDIR_DOWN = ;\n", 
        "SUBDIR_ROOT = $($(_top)-ROOT) ;\n",      "\n",      "\n",      "if $($(_top)RULES) {\n", 
        "include $($(_top)RULES) ;\n",      "} else {\n",      "NoCare $(JAMRULES:R=$($(_top)):G=$(_top)) ;\n",      "include $(JAMRULES:R=$($(_top)):G=$(_top)) ;\n", 
        "}\n",      "}\n",      "\n",      "\n", 
        "SUBDIR_UP = $($(_top)-UP) ;\n",      "SUBDIR_DOWN = $($(_top)-DOWN) $(_tokens) ;\n",      "SUBDIR_ROOT = $($(_top)-ROOT) ;\n",      "SUBDIR_TOKENS = $(SUBDIR_DOWN) ;\n", 
        "\n",      "SUBDIR = [ FSubDirPath $(<) ] ;\n",      "\n",      "\n", 
        "SEARCH_SOURCE = $(SUBDIR) ;\n",      "LOCATE_SOURCE = $(ALL_LOCATE_TARGET) $(SUBDIR) ;\n",      "LOCATE_TARGET = $(ALL_LOCATE_TARGET) $(SUBDIR) ;\n",      "SOURCE_GRIST = [ FGrist $(SUBDIR_TOKENS) ] ;\n", 
        "\n",      "\n",      "SUBDIR$(SUBDIRRESET) = ;\n",      "\n", 
        "\n",      "$(SUBDIRRULES) $(<) ;\n",      "}\n",      "\n", 
        "rule FSubDirPath\n",      "{\n",      "\n",      "\n", 
        "\n",      "local _r = [ FRelPath $($(<[1])-UP) : $($(<[1])-DOWN) $(<[2-]) ] ;\n",      "\n",      "return $(_r:R=$($(<[1])-ROOT)) ;\n", 
        "}\n",      "\n",      "rule SubDirDcFlags\n",      "{\n", 
        "SUBDIRDCFLAGS += $(<) ;\n",      "}\n",      "\n",      "rule SubDirCcFlags\n", 
        "{\n",      "SUBDIRCCFLAGS += $(<) ;\n",      "}\n",      "\n", 
        "rule SubDirC++Flags\n",      "{\n",      "SUBDIRC++FLAGS += $(<) ;\n",      "}\n", 
        "\n",      "rule SubDirHdrs\n",      "{\n",      "SUBDIRHDRS += [ FDirName $(<) ] ;\n", 
        "}\n",      "\n",      "rule SubInclude\n",      "{\n", 
        "\n",      "\n",      "if ! $($(<[1]))\n",      "{\n", 
        "Exit SubInclude $(<[1]) without prior SubDir $(<[1]) ;\n",      "}\n",      "\n",      "SubDir $(<) ;\n", 
        "\n",      "include $(JAMFILE:D=$(SUBDIR)) ;\n",      "}\n",      "\n", 
        "rule SubRules\n",      "{\n",      "\n",      "if ! $($(<[1]))\n", 
        "{\n",      "Exit SubRules $(<[1]) without prior SubDir $(<[1]) ;\n",      "}\n",      "\n", 
        "SubDir $(<) ;\n",      "SubDir $(>) ;\n",      "}\n",      "\n", 
        "rule Undefines\n",      "{\n",      "UNDEFS on [ FAppendSuffix $(<) : $(SUFEXE) ] += $(UNDEFFLAG)$(>) ;\n",      "}\n", 
        "\n",      "rule UserObject\n",      "{\n",      "Exit \"Unknown suffix on\" $(>) \"- see UserObject rule in /usr/share/doc/ftjam/Jamfile.html.\" ;\n", 
        "}\n",      "\n",      "rule Yacc\n",      "{\n", 
        "local _h ;\n",      "\n",      "_h = $(<:BS=.h) ;\n",      "\n", 
        "\n",      "MakeLocate $(<) $(_h) : $(LOCATE_SOURCE) ;\n",      "\n",      "if $(YACC)\n", 
        "{\n",      "Depends $(<) $(_h) : $(>) ;\n",      "Yacc1 $(<) $(_h) : $(>) ;\n",      "YaccMv $(<) $(_h) : $(>) ;\n", 
        "Clean clean : $(<) $(_h) ;\n",      "}\n",      "\n",      "\n", 
        "Includes $(<) : $(_h) ;\n",      "}\n",      "\n",      "\n", 
        "rule FGrist\n",      "{\n",      "return $(<:J=!) ;\n",      "\n", 
        "}\n",      "\n",      "\n",      "rule FGristFiles\n", 
        "{\n",      "return $(<:G=$(SOURCE_GRIST:E)) ;\n",      "}\n",      "\n", 
        "\n",      "rule FGristSourceFiles\n",      "{\n",      "\n", 
        "\n",      "if ! $(SOURCE_GRIST)\n",      "{\n",      "return $(<) ;\n", 
        "}\n",      "else\n",      "{\n",      "local _i _o ;\n", 
        "\n",      "for _i in $(<)\n",      "{\n",      "switch $(_i)\n", 
        "{\n",      "case *.h :  _o += $(_i) ;\n",      "case * :    _o += $(_i:G=$(SOURCE_GRIST)) ;\n",      "}\n", 
        "}\n",      "\n",      "return $(_o) ;\n",      "}\n", 
        "}\n",      "\n",      "\n",      "rule FReverse\n", 
        "{\n",      "if $(1) { return [ FReverse $(1[2-]) ] $(1[1]) ; }\n",      "}\n",      "\n", 
        "\n",      "rule FSubDir\n",      "{\n",      "\n", 
        "if ! $(<[1])\n",      "{\n",      "return $(DOT) ;\n",      "}\n", 
        "else\n",      "{\n",      "local _i _d ;\n",      "\n", 
        "_d = $(DOTDOT) ;\n",      "\n",      "for _i in $(<[2-])\n",      "{\n", 
        "_d = $(_d:R=$(DOTDOT)) ;\n",      "}\n",      "\n",      "return $(_d) ;\n", 
        "}\n",      "}\n",      "\n",      "\n", 
        "rule FStripCommon\n",      "{\n",      "\n",      "\n", 
        "if $($(<)[1]) && $($(<)[1]) = $($(>)[1])\n",      "{\n",      "$(<) = $($(<)[2-]) ;\n",      "$(>) = $($(>)[2-]) ;\n", 
        "FStripCommon $(<) : $(>) ;\n",      "}\n",      "}\n",      "\n", 
        "\n",      "rule FRelPath\n",      "{\n",      "local _l _r ;\n", 
        "\n",      "\n",      "_l = $(<) ;\n",      "_r = $(>) ;\n", 
        "\n",      "FStripCommon _l : _r ;\n",      "\n",      "\n", 
        "_l = [ FSubDir $(_l) ] ;\n",      "_r = [ FDirName $(_r) ] ;\n",      "\n",      "\n", 
        "\n",      "if $(_r) = $(DOT) {\n",      "return $(_l) ;\n",      "} else {\n", 
        "return $(_r:R=$(_l)) ;\n",      "}\n",      "}\n",      "\n", 
        "\n",      "rule FAppendSuffix\n",      "{\n",      "\n", 
        "if $(>)\n",      "{\n",      "local _i _o ;\n",      "\n", 
        "for _i in $(<)\n",      "{\n",      "if $(_i:S)\n",      "{\n", 
        "_o += $(_i) ;\n",      "}\n",      "else\n",      "{\n", 
        "_o += $(_i:S=$(>)) ;\n",      "}\n",      "}\n",      "return $(_o) ;\n", 
        "}\n",      "else\n",      "{\n",      "return $(<) ;\n", 
        "}\n",      "}\n",      "\n",      "\n", 
        "rule FQuote { return \"\\\\\\\"$(<)\\\\\\\"\" ; }\n",      "rule FDefines { return -D$(<) ; }\n",      "rule FIncludes { return -I$(<) ; }\n",      "\n", 
        "rule FDirName\n",      "{\n",      "\n",      "local _i ;\n", 
        "local _s = $(DOT) ;\n",      "\n",      "for _i in $(<)\n",      "{\n", 
        "_s = $(_i:R=$(_s)) ;\n",      "}\n",      "\n",      "return $(_s) ;\n", 
        "}\n",      "\n",      "if $(OS2)\n",      "{\n", 
        "rule FQuote { return \"\\\"$(<)\\\"\" ; }\n",      "rule FIncludes { return /I$(<) ; }\n",      "}\n",      "else if $(NT) && $(JAM_TOOLSET) != MINGW && $(JAM_TOOLSET) != LCC\n", 
        "{\n",      "rule FDefines { return /D$(<) ; }\n",      "rule FIncludes { return /I$(<) ; }\n",      "}\n", 
        "\n",      "else if $(MAC)\n",      "{\n",      "rule FQuote { return \"\\\"$(<)\\\"\" ; }\n", 
        "rule FDefines { return \"-define \'$(<)\'\" ; }\n",      "rule FIncludes { return \"\\\"$(<:J=,)\\\"\" ; }\n",      "}\n",      "\n", 
        "else if $(VMS)\n",      "{\n",      "rule FQuote { return \"\\\"\\\"\\\"$(<)\\\"\\\"\\\"\" ; }\n",      "rule FDefines { return \"/define=( $(<:J=,) )\" ; }\n", 
        "rule FIncludes { return \"/inc=( $(<:J=,) )\" ; }\n",      "\n",      "rule FDirName\n",      "{\n", 
        "local _s _i ;\n",      "\n",      "\n",      "if ! $(<)\n", 
        "{\n",      "_s = $(DOT) ;\n",      "}\n",      "else\n", 
        "{\n",      "\n",      "switch $(<[1])\n",      "{\n", 
        "case *:* :     _s = $(<[1]) ;\n",      "case \\\\[*\\\\] : _s = $(<[1]) ;\n",      "case * :       _s = [.$(<[1])] ;\n",      "}\n", 
        "\n",      "for _i in [.$(<[2-])]\n",      "{\n",      "_s = $(_i:R=$(_s)) ;\n", 
        "}\n",      "}\n",      "\n",      "return $(_s) ;\n", 
        "}\n",      "}\n",      "\n",      "\n", 
        "\n",      "actions updated together piecemeal Archive\n",      "{\n",      "$(AR) $(<) $(>)\n", 
        "}\n",      "\n",      "actions As\n",      "{\n", 
        "$(AS) $(ASFLAGS) $(ASHDRS) -o $(<) $(>)\n",      "}\n",      "\n",      "actions C++\n", 
        "{\n",      "$(C++) -c -o $(<) $(C++FLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) $(>)\n",      "}\n",      "\n", 
        "actions Cc\n",      "{\n",      "$(CC) -c -o $(<) $(CCFLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) $(>)\n",      "}\n", 
        "\n",      "actions Dc\n",      "{\n",      "$(DC) -c -of$(<) $(DCFLAGS) $(DOPTIM) $(>)\n", 
        "}\n",      "\n",      "actions Chgrp\n",      "{\n", 
        "$(CHGRP) $(GROUP) $(<)\n",      "}\n",      "\n",      "actions Chmod1\n", 
        "{\n",      "$(CHMOD) $(MODE) $(<)\n",      "}\n",      "\n", 
        "actions Chown\n",      "{\n",      "$(CHOWN) $(OWNER) $(<)\n",      "}\n", 
        "\n",      "actions piecemeal together existing Clean\n",      "{\n",      "$(RM) $(>)\n", 
        "}\n",      "\n",      "actions File\n",      "{\n", 
        "$(CP) $(>) $(<)\n",      "}\n",      "\n",      "actions GenFile1\n", 
        "{\n",      "$(>[1]) $(<) $(>[2-])\n",      "}\n",      "\n", 
        "actions Fortran\n",      "{\n",      "$(FORTRAN) $(FORTRANFLAGS) -o $(<) $(>)\n",      "}\n", 
        "\n",      "actions HardLink\n",      "{\n",      "$(RM) $(<) && $(LN) $(>) $(<)\n", 
        "}\n",      "\n",      "actions Install\n",      "{\n", 
        "$(CP) $(>) $(<)\n",      "}\n",      "\n",      "actions Lex\n", 
        "{\n",      "$(LEX) $(>)\n",      "}\n",      "\n", 
        "actions LexMv\n",      "{\n",      "$(MV) lex.yy.c $(<)\n",      "}\n", 
        "\n",      "actions Link bind NEEDLIBS\n",      "{\n",      "$(LINK) $(LINKFLAGS) -o $(<) $(UNDEFS) $(>) $(NEEDLIBS) $(LINKLIBS)\n", 
        "}\n",      "\n",      "actions MkDir1\n",      "{\n", 
        "$(MKDIR) $(<)\n",      "}\n",      "\n",      "actions together Ranlib\n", 
        "{\n",      "$(RANLIB) $(<)\n",      "}\n",      "\n", 
        "actions quietly updated piecemeal together RmTemps\n",      "{\n",      "$(RM) $(>)\n",      "}\n", 
        "\n",      "actions Shell\n",      "{\n",      "$(AWK) \'\n", 
        "NR == 1 { print \"$(SHELLHEADER)\" }\n",      "NR == 1 && /^[#:]/ { next }\n",      "/^##/ { next }\n",      "{ print }\n", 
        "\' < $(>) > $(<)\n",      "}\n",      "\n",      "actions SoftLink\n", 
        "{\n",      "$(RM) $(<) && $(LN) -s $(>) $(<)\n",      "}\n",      "\n", 
        "actions Yacc1\n",      "{\n",      "$(YACC) $(YACCFLAGS) $(>)\n",      "}\n", 
        "\n",      "actions YaccMv\n",      "{\n",      "$(MV) $(YACCFILES).c $(<[1])\n", 
        "$(MV) $(YACCFILES).h $(<[2])\n",      "}\n",      "\n",      "\n", 
        "if $(RELOCATE)\n",      "{\n",      "actions C++\n",      "{\n", 
        "$(C++) -c $(C++FLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) $(>)\n",      "}\n",      "\n",      "actions Cc\n", 
        "{\n",      "$(CC) -c $(CCFLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) $(>)\n",      "}\n",      "\n", 
        "actions ignore CcMv\n",      "{\n",      "[ $(<) != $(>:BS=$(SUFOBJ)) ] && $(MV) $(>:BS=$(SUFOBJ)) $(<)\n",      "}\n", 
        "}\n",      "\n",      "\n",      "if $(NOARUPDATE)\n", 
        "{\n",      "actions Archive\n",      "{\n",      "$(AR) $(<) $(>)\n", 
        "}\n",      "}\n",      "\n",      "\n", 
        "if $(UNIX)\n",      "{\n",      "actions GenFile1\n",      "{\n", 
        "PATH=\"$PATH:.\"\n",      "$(>[1]) $(<) $(>[2-])\n",      "}\n",      "}\n", 
        "\n",      "\n",      "if $(NT)\n",      "{\n", 
        "if $(JAM_TOOLSET) = VISUALC || $(JAM_TOOLSET) = INTELC\n",      "{\n",      "actions updated together piecemeal Archive\n",      "{\n", 
        "if exist $(<) set _$(<:B)_=$(<)\n",      "$(AR) /out:$(<) %_$(<:B)_% $(>)\n",      "}\n",      "\n", 
        "actions As\n",      "{\n",      "$(AS) /Ml /p /v /w2 $(>) $(<) ,nul,nul;\n",      "}\n", 
        "\n",      "actions Cc\n",      "{\n",      "$(CC) /c /Fo$(<) $(CCFLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) /I$(STDHDRS) $(>)\n", 
        "}\n",      "\n",      "actions C++\n",      "{\n", 
        "$(C++) /c /Fo$(<) $(C++FLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) /I$(STDHDRS) /Tp$(>)\n",      "}\n",      "\n",      "actions Link bind NEEDLIBS\n", 
        "{\n",      "$(LINK) $(LINKFLAGS) /out:$(<) $(UNDEFS) $(>) $(NEEDLIBS) $(LINKLIBS)\n",      "}\n",      "\n", 
        "actions DllLink bind NEEDLIBS DEFFILENAME IMPLIBNAME\n",      "{\n",      "$(LINK) $(LINKFLAGS) /DLL /DEF:$(DEFFILENAME) /IMPLIB:$(IMPLIBNAME) /out:$(<) $(UNDEFS) $(>) $(NEEDLIBS) $(LINKLIBS)\n",      "}\n", 
        "}\n",      "else if $(JAM_TOOLSET) = VISUALC16\n",      "{\n",      "actions updated together piecemeal Archive\n", 
        "{\n",      "$(AR) $(<) -+$(>)\n",      "}\n",      "\n", 
        "actions Cc\n",      "{\n",      "$(CC) /c /Fo$(<) $(CCFLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) $(>)\n",      "}\n", 
        "\n",      "actions C++\n",      "{\n",      "$(C++) /c /Fo$(<) $(C++FLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) /Tp$(>)\n", 
        "}\n",      "\n",      "actions Link bind NEEDLIBS\n",      "{\n", 
        "$(LINK) $(LINKFLAGS) /out:$(<) $(UNDEFS) $(>) $(NEEDLIBS) $(LINKLIBS)\n",      "}\n",      "\n",      "actions DllLink bind NEEDLIBS DEFFILENAME IMPLIBNAME\n", 
        "{\n",      "$(LINK) $(LINKFLAGS) /DLL /DEF:$(DEFFILENAME) /IMPLIB:$(IMPLIBNAME) /out:$(<) $(UNDEFS) $(>) $(NEEDLIBS) $(LINKLIBS)\n",      "}\n",      "}\n", 
        "else if $(JAM_TOOLSET) = BORLANDC\n",      "{\n",      "actions updated together piecemeal Archive\n",      "{\n", 
        "$(AR) $(<) -+$(>)\n",      "}\n",      "\n",      "actions Link bind NEEDLIBS\n", 
        "{\n",      "$(LINK) -e$(<) $(LINKFLAGS) $(UNDEFS) -L$(LINKLIBS) $(NEEDLIBS) $(>)\n",      "}\n",      "\n", 
        "actions DllLink bind NEEDLIBS DEFFILENAME\n",      "{\n",      "$(ILINK) $(LINKFLAGS) $(>) , $(<) ,, $(LINKLIBS:E) $(NEEDLIBS:E) , $(DEFFILENAME)\n",      "}\n", 
        "\n",      "actions DllImplib bind DEFFILENAME\n",      "{\n",      "$(IMPLIB) -a $(<) $(>) $(DEFFILENAME)\n", 
        "}\n",      "\n",      "actions C++\n",      "{\n", 
        "$(C++) -c -o$(<) $(C++FLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) $(>)\n",      "}\n",      "\n",      "actions Cc\n", 
        "{\n",      "$(CC) -c -o$(<) $(CCFLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) $(>)\n",      "}\n",      "}\n", 
        "else if $(JAM_TOOLSET) = MINGW\n",      "{\n",      "actions together piecemeal Archive\n",      "{\n", 
        "$(AR) $(<) $(>:T)\n",      "}\n",      "\n",      "actions Cc\n", 
        "{\n",      "$(CC) -c -o $(<) $(CCFLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) -I$(STDHDRS) $(>)\n",      "}\n",      "\n", 
        "actions C++\n",      "{\n",      "$(C++) -c -o $(<) $(C++FLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) -I$(STDHDRS) $(>)\n",      "}\n", 
        "\n",      "actions DllLink bind DEFFILENAME IMPLIBNAME\n",      "{\n",      "$(LINK) $(LINKFLAGS) -shared -o $(<) $(>) $(DEFFILENAME) -Wl,--out-implib,$(IMPLIBNAME)\n", 
        "}\n",      "}\n",      "else if $(JAM_TOOLSET) = WATCOM\n",      "{\n", 
        "actions together piecemeal Archive\n",      "{\n",      "$(AR) -q $(<) +-$(>)\n",      "}\n", 
        "\n",      "actions Cc\n",      "{\n",      "$(CC) $(CCFLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) /Fo=$(<) -I$(STDHDRS) $(>)\n", 
        "}\n",      "\n",      "actions C++\n",      "{\n", 
        "$(C++) $(C++FLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) /Fo=$(<) -I$(STDHDRS) $(>)\n",      "}\n",      "\n",      "actions Link bind NEEDLIBS\n", 
        "{\n",      "$(LINK) $(LINKFLAGS) /Fe=$(<) $(UNDEFS) $(>) $(NEEDLIBS) $(LINKLIBS)\n",      "}\n",      "\n", 
        "actions DllLink bind NEEDLIBS DEFFILENAME IMPLIBNAME\n",      "{\n",      "$(LINK) $(LINKFLAGS) -l=NT_DLL -\"export=$(DEFFILENAME) option implib=$(IMPLIBNAME)\" /Fe=$(<) $(UNDEFS) $(>) $(NEEDLIBS) $(LINKLIBS)\n",      "}\n", 
        "\n",      "actions Shell\n",      "{\n",      "$(CP) $(>) $(<)\n", 
        "}\n",      "}\n",      "else if $(JAM_TOOLSET) = LCC\n",      "{\n", 
        "actions together piecemeal Archive\n",      "{\n",      "$(AR) /out:$(<) $(>)\n",      "}\n", 
        "\n",      "actions Cc\n",      "{\n",      "$(CC) $(CCFLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) -Fo$(<) -I$(STDHDRS) $(>)\n", 
        "}\n",      "\n",      "actions Link bind NEEDLIBS\n",      "{\n", 
        "$(LINK) $(LINKFLAGS) -o $(<) $(UNDEFS) $(>) $(NEEDLIBS) $(LINKLIBS)\n",      "}\n",      "\n",      "actions DllLink bind NEEDLIBS DEFFILENAME\n", 
        "{\n",      "$(LINK) $(LINKFLAGS) -DLL -o $(<) $(UNDEFS) $(>) $(DEFFILENAME) $(NEEDLIBS) $(LINKLIBS)\n",      "}\n",      "\n", 
        "actions ignore DllLinkMv\n",      "{\n",      "$(MV) $(2) $(1)\n",      "}\n", 
        "\n",      "actions Shell\n",      "{\n",      "$(CP) $(>) $(<)\n", 
        "}\n",      "}\n",      "else if $(JAM_TOOLSET) = DIGITALMARS\n",      "{\n", 
        "actions together piecemeal Archive\n",      "{\n",      "$(AR) $(<) $(>)\n",      "}\n", 
        "\n",      "actions Cc\n",      "{\n",      "$(CC) -c $(CCFLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) -o$(<) -I$(STDHDRS) $(>)\n", 
        "}\n",      "\n",      "actions C++\n",      "{\n", 
        "$(C++) -c $(C++FLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) -o$(<) -I$(STDHDRS) $(>)\n",      "}\n",      "\n",      "actions Link bind NEEDLIBS\n", 
        "{\n",      "$(LINK) $(LINKFLAGS) $(>),$(<),NUL, $(NEEDLIBS) $(LINKLIBS)\n",      "}\n",      "\n", 
        "actions DllLink bind NEEDLIBS DEFFILENAME IMPLIBNAME\n",      "{\n",      "$(LINK) $(LINKFLAGS) /IMPLIB:$(IMPLIBNAME) $(>) , $(<) ,NUL, $(LINKLIBS:E) $(NEEDLIBS:E) , $(DEFFILENAME)\n",      "}\n", 
        "\n",      "actions Shell\n",      "{\n",      "$(CP) $(>) $(<)\n", 
        "}\n",      "}\n",      "else if $(JAM_TOOLSET) = PELLESC\n",      "{\n", 
        "actions together piecemeal Archive\n",      "{\n",      "$(AR) /OUT:$(<) $(>)\n",      "}\n", 
        "\n",      "actions Cc\n",      "{\n",      "$(CC) $(CCFLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS)   /Fo $(<) -I$(STDHDRS)  $(>)\n", 
        "}\n",      "\n",      "actions Link bind NEEDLIBS\n",      "{\n", 
        "$(LINK) $(LINKFLAGS) /OUT:$(<) $(>) $(NEEDLIBS) $(LINKLIBS)\n",      "}\n",      "\n",      "actions DllLink bind NEEDLIBS DEFFILENAME IMPLIBNAME\n", 
        "{\n",      "$(LINK) $(LINKFLAGS) /DLL /DEF:$(DEFFILENAME) /IMPLIB:$(IMPLIBNAME) /OUT:$(<) $(>) $(NEEDLIBS) $(LINKLIBS)\n",      "}\n",      "\n", 
        "actions Shell\n",      "{\n",      "$(CP) $(>) $(<)\n",      "}\n", 
        "}\n",      "}\n",      "\n",      "\n", 
        "else if $(OS2)\n",      "{\n",      "if $(JAM_TOOLSET) = WATCOM\n",      "{\n", 
        "actions together piecemeal Archive\n",      "{\n",      "$(AR) -q $(<) +-$(>)\n",      "}\n", 
        "\n",      "actions Cc\n",      "{\n",      "$(CC) /Fo=$(<) $(CCFLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) $(>)\n", 
        "}\n",      "\n",      "actions C++\n",      "{\n", 
        "$(C++) /Fo=$(<) $(C++FLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) $(>)\n",      "}\n",      "\n",      "actions Link bind NEEDLIBS\n", 
        "{\n",      "$(LINK) -q $(LINKFLAGS) /Fe=$(<) $(UNDEFS) $(>) $(NEEDLIBS) $(LINKLIBS)\n",      "}\n",      "\n", 
        "actions Shell\n",      "{\n",      "$(CP) $(>) $(<)\n",      "}\n", 
        "}\n",      "else if $(JAM_TOOLSET) = EMX\n",      "{\n",      "actions together piecemeal Archive\n", 
        "{\n",      "$(AR) $(<) $(>:T)\n",      "}\n",      "\n", 
        "actions Cc\n",      "{\n",      "$(CC) -c -o $(<) $(CCFLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) $(>)\n",      "}\n", 
        "\n",      "actions C++\n",      "{\n",      "$(C++) -c -o $(<) $(C++FLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) $(>)\n", 
        "}\n",      "}\n",      "}\n",      "\n", 
        "\n",      "else if $(VMS)\n",      "{\n",      "actions updated together piecemeal Archive\n", 
        "{\n",      "lib/replace $(<) $(>[1]) ,$(>[2-])\n",      "}\n",      "\n", 
        "actions Cc\n",      "{\n",      "$(CC)/obj=$(<) $(CCFLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) $(>)\n",      "}\n", 
        "\n",      "actions C++\n",      "{\n",      "$(C++)/obj=$(<) $(C++FLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) $(>)\n", 
        "}\n",      "\n",      "actions piecemeal together existing Clean\n",      "{\n", 
        "$(RM) $(>[1]);* ,$(>[2-]);*\n",      "}\n",      "\n",      "actions together quietly CreLib\n", 
        "{\n",      "if f$search(\"$(<)\") .eqs. \"\" then lib/create $(<)\n",      "}\n",      "\n", 
        "actions GenFile1\n",      "{\n",      "mcr $(>[1]) $(<) $(>[2-])\n",      "}\n", 
        "\n",      "actions Link bind NEEDLIBS\n",      "{\n",      "$(LINK)/exe=$(<) $(LINKFLAGS) $(>:J=,) ,$(NEEDLIBS)/lib ,$(LINKLIBS)\n", 
        "}\n",      "\n",      "actions quietly updated piecemeal together RmTemps\n",      "{\n", 
        "$(RM) $(>[1]);* ,$(>[2-]);*\n",      "}\n",      "\n",      "actions Shell\n", 
        "{\n",      "$(CP) $(>) $(<)\n",      "}\n",      "}\n", 
        "\n",      "\n",      "else if $(MAC)\n",      "{\n", 
        "actions together Archive\n",      "{\n",      "$(LINK) -library -o $(<) $(>)\n",      "}\n", 
        "\n",      "actions Cc\n",      "{\n",      "set -e MWCincludes $(CCHDRS)\n", 
        "$(CC) -o $(<) $(CCFLAGS) $(OPTIM) $(CCDEFS) $(>)\n",      "}\n",      "\n",      "actions C++\n", 
        "{\n",      "set -e MWCincludes $(CCHDRS)\n",      "$(CC) -o $(<) $(C++FLAGS) $(OPTIM) $(CCDEFS) $(>)\n",      "}\n", 
        "\n",      "actions Link bind NEEDLIBS\n",      "{\n",      "$(LINK) -o $(<) $(LINKFLAGS) $(>) $(NEEDLIBS) \"$(LINKLIBS)\"\n", 
        "}\n",      "}\n",      "\n",      "if $(WIN98)\n", 
        "{\n",      "actions existing Clean\n",      "{\n",      "del $(>)\n", 
        "}\n",      "}\n",      "\n",      "\n", 
        "rule BULK { Bulk $(<) : $(>) ; }\n",      "rule FILE { File $(<) : $(>) ; }\n",      "rule HDRRULE { HdrRule $(<) : $(>) ; }\n",      "rule INSTALL { Install $(<) : $(>) ; }\n", 
        "rule LIBRARY { Library $(<) : $(>) ; }\n",      "rule LIBS { LinkLibraries $(<) : $(>) ; }\n",      "rule LINK { Link $(<) : $(>) ; }\n",      "rule MAIN { Main $(<) : $(>) ; }\n", 
        "rule SETUID { Setuid $(<) ; }\n",      "rule SHELL { Shell $(<) : $(>) ; }\n",      "rule UNDEFINES { Undefines $(<) : $(>) ; }\n",      "\n", 
        "\n",      "rule INSTALLBIN { InstallBin $(BINDIR) : $(<) ; }\n",      "rule INSTALLLIB { InstallLib $(LIBDIR) : $(<) ; }\n",      "rule INSTALLMAN { InstallMan $(MANDIR) : $(<) ; }\n", 
        "\n",      "\n",      "rule addDirName { $(<) += [ FDirName $(>) ] ; }\n",      "rule makeCommon { FStripCommon $(<) : $(>) ; }\n", 
        "rule _makeCommon { FStripCommon $(<) : $(>) ; }\n",      "rule makeDirName { $(<) = [ FDirName $(>) ] ; }\n",      "rule makeGrist { $(<) = [ FGrist $(>) ] ; }\n",      "rule makeGristedName { $(<) = [ FGristSourceFiles $(>) ] ; }\n", 
        "rule makeRelPath { $(<[1]) = [ FRelPath $(<[2-]) : $(>) ] ; }\n",      "rule makeString { $(<) = $(>:J) ; }\n",      "rule makeSubDir { $(<) = [ FSubDir $(>) ] ; }\n",      "rule makeSuffixed { $(<[1]) = [ FAppendSuffix $(>) : $(<[2]) ] ; }\n", 
        "\n",      "\n",      "\n",      "rule _PkgAppend\n", 
        "{\n",      "local result = $($(1)) ;\n",      "local i ;\n",      "\n", 
        "for i in $(2)\n",      "{\n",      "if ! $(i) in $(result)\n",      "{\n", 
        "result += $(i) ;\n",      "}\n",      "}\n",      "$(1) = $(result) ;\n", 
        "}\n",      "\n",      "\n",      "rule _PkgPrepend\n", 
        "{\n",      "local result = $($(1)) ;\n",      "local i ;\n",      "\n", 
        "for i in $(2)\n",      "{\n",      "if ! $(i) in $(result)\n",      "{\n", 
        "result = $(i) $(result) ;\n",      "}\n",      "}\n",      "$(1) = $(result) ;\n", 
        "}\n",      "\n",      "\n",      "rule PkgBegin\n", 
        "{\n",      "if $(_PKG_NAME)\n",      "{\n",      "Echo \"nested package declarations are not allowed. please use\"\n", 
        "Exit \"PkgEnd to finish\" $(_PKG_NAME)\"\'s declaration\" ;\n",      "}\n",      "\n",      "if ! $(PACKAGE_ROOT)\n", 
        "{\n",      "PACKAGE_ROOT = [ FDirName  $(HOME) packages ] ;\n",      "Echo \"PACKAGE_ROOT  variable not set, using\" $(PACKAGE_ROOT) \"directory\" ;\n",      "}\n", 
        "\n",      "_PKG_NAME = $(1[1]) ;\n",      "_PKG_DESC = [ FDirName $(PACKAGE_ROOT) $(_PKG_NAME).pc ] ;\n",      "_PKG_TOP  = $(2) ;\n", 
        "if ! $(_PKG_TOP)\n",      "{\n",      "_PKG_TOP = [ FDirName $(PACKAGE_ROOT) $(_PKG_NAME) ] ;\n",      "}\n", 
        "\n",      "_PKG_ORG_HDRS       = $(HDRS) ;\n",      "_PKG_ORG_DEFINES    = $(DEFINES) ;\n",      "_PKG_ORG_LINKLIBS   = $(LINKLIBS) ;\n", 
        "_PKG_ORG_SUBDIRHDRS = $(SUBDIRHDRS) ;\n",      "\n",      "pkg-$(_PKG_NAME)-top = $(_PKG_TOP) ;\n",      "\n", 
        "_PKG_USES = ;\n",      "_PKG_DEFINES = ;\n",      "_PKG_INCLUDES = ;\n",      "_PKG_LIBS = ;\n", 
        "_PKG_DO_INSTALL = ;\n",      "\n",      "_PKG_ALL_USES = ;\n",      "\n", 
        "_PkgUpdate ;\n",      "}\n",      "\n",      "\n", 
        "rule PkgEnd\n",      "{\n",      "if $(_PKG_DO_INSTALL)\n",      "{\n", 
        "_PkgGeneratePc $(_PKG_DESC) ;\n",      "PKG on $(_PKG_DESC) = $(_PKG_NAME) ;\n",      "}\n",      "\n", 
        "HDRS     = $(_PKG_ORG_HDRS) ;\n",      "DEFINES  = $(_PKG_ORG_DEFINES) ;\n",      "LINKLIBS = $(_PKG_ORG_LINKLIBS) ;\n",      "\n", 
        "SUBDIRHDRS = $(_PKG_ORG_SUBDIRHDRS) ;\n",      "\n",      "_PKG_NAME = ;\n",      "_PKG_DO_INSTALL = ;\n", 
        "}\n",      "\n",      "rule _PkgReverse\n",      "{\n", 
        "local p ;\n",      "\n",      "result = $(1[1]) ;\n",      "\n", 
        "for p in $(1[2-])\n",      "{\n",      "result = $(p) $(result) ;\n",      "}\n", 
        "return $(result) ;\n",      "}\n",      "\n",      "rule _PkgGeneratePc\n", 
        "{\n",      "MkDir $(PACKAGE_ROOT) ;\n",      "Depends $(1) : $(PACKAGE_ROOT) ;\n",      "Depends install : $(1) ;\n", 
        "Clean uninstall : $(1) ;\n",      "Always $(1) ;   # always re-install, overwrite old version\n",      "}\n",      "\n", 
        "if $(UNIX)\n",      "{\n",      "actions _PkgGeneratePc\n",      "{\n", 
        "echo \"# this file was generated automatically - do not edit\" > $(1)\n",      "echo \"pkg-$(PKG)-uses     = $(pkg-$(PKG)-uses) ;\" >> $(1)\n",      "echo \"pkg-$(PKG)-libs     = $(pkg-$(PKG)-libs:Q) ;\" >> $(1)\n",      "echo \"pkg-$(PKG)-defines  = $(pkg-$(PKG)-defines) ;\" >> $(1)\n", 
        "echo \"pkg-$(PKG)-includes = $(pkg-$(PKG)-includes:Q) ;\" >> $(1)\n",      "echo \"pkg-$(PKG)-ok       = 1 ;\" >> $(1)\n",      "}\n",      "}\n", 
        "else\n",      "{\n",      "actions _PkgGeneratePc\n",      "{\n", 
        "echo # this file was generated automatically - do not edit > $(1)\n",      "echo pkg-$(PKG)-uses     = $(pkg-$(PKG)-uses) ; >> $(1)\n",      "echo pkg-$(PKG)-libs     = $(pkg-$(PKG)-libs:Q) ; >> $(1)\n",      "echo pkg-$(PKG)-defines  = $(pkg-$(PKG)-defines) ; >> $(1)\n", 
        "echo pkg-$(PKG)-includes = $(pkg-$(PKG)-includes:Q) ; >> $(1)\n",      "echo pkg-$(PKG)-ok       = 1 ; >> $(1)\n",      "}\n",      "}\n", 
        "\n",      "rule PkgInstallPc\n",      "{\n",      "}\n", 
        "\n",      "rule _PkgUpdate\n",      "{\n",      "local p z ;\n", 
        "\n",      "_PKG_ALL_DEFINES  = ;\n",      "_PKG_ALL_INCLUDES = ;\n",      "_PKG_ALL_LIBS     = ;\n", 
        "_PKG_USE_LIBS     = ;\n",      "\n",      "for p in $(_PKG_ALL_USES)\n",      "{\n", 
        "_PkgAppend  _PKG_ALL_DEFINES  : $(pkg-$(p)-defines) ;\n",      "_PkgAppend  _PKG_ALL_INCLUDES : $(pkg-$(p)-includes)    ;\n",      "}\n",      "\n", 
        "for p in [ _PkgReverse  $(_PKG_ALL_USES) ]\n",      "{\n",      "local  thelibs = $(pkg-$(p)-libs) ;\n",      "\n", 
        "_PKG_ALL_LIBS += $(thelibs) ;\n",      "_PKG_USE_LIBS += $(thelibs[1]) ;\n",      "}\n",      "\n", 
        "_PkgAppend _PKG_ALL_DEFINES  : $(_PKG_DEFINES) ;\n",      "_PkgAppend _PKG_ALL_INCLUDES : $(_PKG_INCLUDES) ;\n",      "\n",      "HDRS     = $(_PKG_ORG_HDRS)     $(_PKG_ALL_INCLUDES) ;\n", 
        "DEFINES  = $(_PKG_ORG_DEFINES)  $(_PKG_ALL_DEFINES) ;\n",      "LINKLIBS = $(_PKG_ORG_LINKLIBS) $(_PKG_ALL_LIBS) ;\n",      "\n",      "pkg-$(_PKG_NAME)-includes = $(_PKG_INCLUDES) ;\n", 
        "pkg-$(_PKG_NAME)-defines  = $(_PKG_DEFINES) ;\n",      "pkg-$(_PKG_NAME)-uses     = $(_PKG_USES) ;\n",      "pkg-$(_PKG_NAME)-libs     = $(_PKG_LIBS) ;\n",      "}\n", 
        "\n",      "\n",      "rule _PkgUses\n",      "{\n", 
        "local p ;\n",      "\n",      "for p in $(1)\n",      "{\n", 
        "if ! $(p) in $(_PKG_ALL_USES)\n",      "{\n",      "local  pcfile = [ FDirName $(PACKAGE_ROOT) $(p).pc ] ;\n",      "\n", 
        "NoCare $(pcfile) ;\n",      "include $(pcfile) ;\n",      "\n",      "if ! $(pkg-$(p)-ok)\n", 
        "{\n",      "$(2) += $(p) ;\n",      "}\n",      "else if $(pkg-$(p)-uses)\n", 
        "{\n",      "_PkgUses $(pkg-$(p)-uses) ;\n",      "}\n",      "_PKG_ALL_USES  +=  $(p) ;\n", 
        "}\n",      "}\n",      "}\n",      "\n", 
        "\n",      "rule PkgUses\n",      "{\n",      "local  pkg-missing = ;\n", 
        "\n",      "_PkgUses $(1) : pkg-missing ;\n",      "\n",      "if $(pkg-missing)\n", 
        "{\n",      "Exit \"Please install the following required packages:\" $(pkg-missing) ;\n",      "}\n",      "\n", 
        "_PkgPrepend _PKG_USES : $(1) ;\n",      "\n",      "_PkgUpdate ;\n",      "}\n", 
        "\n",      "\n",      "rule _PkgMakeLocate\n",      "{\n", 
        "local  top = $(3:E=$(DOT)) ;\n",      "local  dir file ss ;\n",      "local  dirs ;\n",      "\n", 
        "for ss in $(2)\n",      "{\n",      "file = [ FDirName $(top) $(ss:G=\"\") ] ;\n",      "dir  = $(1) ;\n", 
        "\n",      "if $(ss:D)\n",      "{\n",      "dir = [ FDirName $(dir) $(ss:D) ] ;\n", 
        "}\n",      "\n",      "LOCATE on $(ss) = $(1) ;\n",      "Depends $(ss) : $(dir) ;\n", 
        "\n",      "if ! $(dir) in $(dirs)\n",      "{\n",      "dirs += $(dir) ;\n", 
        "}\n",      "}\n",      "\n",      "MkDir $(dirs) ;\n", 
        "}\n",      "\n",      "rule _PkgInstallInto\n",      "{\n", 
        "local sources = $(2) ;\n",      "local targets = $(sources:G=$(INSTALLGRIST)) ;\n",      "\n",      "\n", 
        "Depends  install : $(targets) ;\n",      "Clean uninstall : $(targets) ;\n",      "\n",      "_PkgMakeLocate $(1) : $(targets) : $(3) ;\n", 
        "\n",      "\n",      "for s in $(sources)\n",      "{\n", 
        "local t = $(s:G=$(INSTALLGRIST)) ;\n",      "\n",      "Depends $(t) : $(s) ;\n",      "\n", 
        "SEARCH on $(s) = $(3) ;\n",      "\n",      "Install $(t) : $(s) ;\n",      "Chmod $(t) ;\n", 
        "\n",      "if $(OWNER) && $(CHOWN)\n",      "{\n",      "Chown $(t) ;\n", 
        "OWNER on $(t) = $(OWNER) ;\n",      "}\n",      "\n",      "if $(GROUP) && $(CHGRP)\n", 
        "{\n",      "Chgrp $(t) ;\n",      "GROUP on $(t) = $(GROUP) ;\n",      "}\n", 
        "}\n",      "}\n",      "\n",      "rule _PkgInstallBin\n", 
        "{\n",      "local _t = [ FAppendSuffix $(>) : $(SUFEXE) ] ;\n",      "\n",      "_PkgInstallInto $(<) : $(_t) : $(3) ;\n", 
        "MODE on $(_t:G=$(INSTALLGRIST)) = $(EXEMODE) ;\n",      "}\n",      "\n",      "\n", 
        "rule _PkgInstallShell\n",      "{\n",      "_PkgInstallInto $(1) : $(2) : $(3) ;\n",      "MODE on $(2:G=$(INSTALLGRIST)) = $(SHELLMODE) ;\n", 
        "}\n",      "\n",      "\n",      "rule _PkgInstallFile\n", 
        "{\n",      "_PkgInstallInto $(1) : $(2) : $(3) ;\n",      "MODE on $(2:G=$(INSTALLGRIST)) = $(FILEMODE) ;\n",      "}\n", 
        "\n",      "rule PkgIncludes\n",      "{\n",      "_PKG_INCLUDES += $(1) ;\n", 
        "_PkgUpdate ;\n",      "}\n",      "\n",      "rule PkgDefines\n", 
        "{\n",      "_PKG_DEFINES += $(1) ;\n",      "_PkgUpdate ;\n",      "}\n", 
        "\n",      "rule PkgInstallHeader\n",      "{\n",      "local  dir = [ FDirName $(_PKG_TOP) include ] ;\n", 
        "\n",      "_PKG_DO_INSTALL = 1 ;\n",      "\n",      "_PkgInstallFile  [ FDirName $(dir) $(3) ] : $(1) : $(2)   ;\n", 
        "_PkgAppend _PKG_INCLUDES : $(dir) ;\n",      "_PkgUpdate ;\n",      "}\n",      "\n", 
        "rule PkgInstallLib\n",      "{\n",      "local  lib = $(1:S=$(SUFLIB)) ;\n",      "local  dir = [ FDirName $(_PKG_TOP) lib ] ;\n", 
        "\n",      "_PKG_DO_INSTALL = 1 ;\n",      "\n",      "_PkgInstallFile  $(dir) : $(lib) : $(DOT) ;\n", 
        "_PkgPrepend _PKG_LIBS : [ FDirName $(dir) $(lib) ] ;\n",      "_PkgUpdate ;\n",      "}\n",      "\n", 
        "\n",      "rule PkgNeedLib\n",      "{\n",      "_PkgAppend _PKG_LIBS : $(1) ;\n", 
        "_PkgUpdate ;\n",      "}\n",      "\n",      "\n", 
        "rule PkgMain\n",      "{\n",      "MainFromObjects $(<) : $(>:S=$(SUFOBJ)) ;\n",      "Objects $(>) ;\n", 
        "LINKLIBS on $(<:S=$(SUFEXE)) += $(LINKLIBS) ;\n",      "Depends $(<:S=$(SUFEXE)) : $(_PKG_USE_LIBS) ;\n",      "}\n",      "\n", 
        "\n",      "rule PkgGlob\n",      "{\n",      "local files dir ;\n", 
        "files = [ GLOB [ FDirName $(2) $(1) ] : $(3) ] ;\n",      "dir   = [ FDirName $(1) ] ;\n",      "\n",      "return  $(files:D=$(dir)) ;\n", 
        "}\n",      "\n",      "\n",      "include $(JAMFILE) ;\n", 
        (char const   *)0};
#line 35 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/newstr.c"
static struct hash *strhash___0  =    (struct hash *)0;
#line 36 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/newstr.c"
static int strtotal___0  =    0;
#line 52 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/hdrmacro.c"
static struct hash *header_macros_hash___0  =    (struct hash *)0;
#line 17 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/variable.h"
LIST *var_swap(char const   *symbol , LIST *value ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/rules.c"
static struct hash *rulehash  =    (struct hash *)0;
#line 45 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/rules.c"
static struct hash *targethash  =    (struct hash *)0;
#line 52 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/rules.c"
RULE *bindrule(char const   *rulename ) 
{ 
  RULE rule ;
  RULE *r ;
  int tmp ;

  {
#line 55
  r = & rule;
#line 57
  if (! rulehash) {
    {
#line 58
    rulehash = hashinit((int )sizeof(RULE ), "rules");
    }
  }
  {
#line 60
  r->name = rulename;
#line 62
  tmp = hashitem(rulehash, (HASHDATA **)(& r), 1);
  }
#line 62
  if (! tmp) {
    {
#line 64
    r->name = newstr(rulename);
#line 65
    r->procedure = (PARSE *)0;
#line 66
    r->actions = (char const   *)((char *)0);
#line 67
    r->bindlist = (LIST *)0;
#line 68
    r->params = (LIST *)0;
#line 69
    r->flags = 0;
    }
  }
#line 72
  return (r);
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/rules.c"
TARGET *bindtarget(char const   *targetname ) 
{ 
  TARGET target ;
  TARGET *t ;
  int tmp ;

  {
#line 82
  t = & target;
#line 84
  if (! targethash) {
    {
#line 85
    targethash = hashinit((int )sizeof(TARGET ), "targets");
    }
  }
  {
#line 87
  t->name = targetname;
#line 89
  tmp = hashitem(targethash, (HASHDATA **)(& t), 1);
  }
#line 89
  if (! tmp) {
    {
#line 91
    memset((void *)((char *)t), '\000', sizeof(*t));
#line 92
    t->name = newstr(targetname);
#line 93
    t->boundname = t->name;
    }
  }
#line 96
  return (t);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/rules.c"
TARGET *copytarget(TARGET const   *ot ) 
{ 
  TARGET *t ;
  void *tmp ;

  {
  {
#line 110
  tmp = malloc(sizeof(*t));
#line 110
  t = (TARGET *)tmp;
#line 111
  memset((void *)((char *)t), '\000', sizeof(*t));
#line 112
  t->name = copystr((char const   *)ot->name);
#line 113
  t->boundname = t->name;
#line 115
  t->flags = (char )((int )t->flags | 68);
  }
#line 117
  return (t);
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/rules.c"
void touchtarget(char const   *t ) 
{ 
  TARGET *tmp ;

  {
  {
#line 127
  tmp = bindtarget(t);
#line 127
  tmp->flags = (char )((int )tmp->flags | 8);
  }
#line 128
  return;
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/rules.c"
TARGETS *targetlist(TARGETS *chain , LIST *targets ) 
{ 
  TARGET *tmp ;

  {
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! targets) {
#line 143
      goto while_break;
    }
    {
#line 144
    tmp = bindtarget(targets->string);
#line 144
    chain = targetentry(chain, tmp);
#line 143
    targets = targets->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 146
  return (chain);
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/rules.c"
TARGETS *targetentry(TARGETS *chain , TARGET *target ) 
{ 
  TARGETS *c ;
  void *tmp ;

  {
  {
#line 164
  tmp = malloc(sizeof(TARGETS ));
#line 164
  c = (TARGETS *)tmp;
#line 165
  c->target = target;
  }
#line 167
  if (! chain) {
#line 167
    chain = c;
  } else {
#line 168
    (chain->tail)->next = c;
  }
#line 169
  chain->tail = c;
#line 170
  c->next = (TARGETS *)0;
#line 172
  return (chain);
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/rules.c"
TARGETS *targetchain(TARGETS *chain , TARGETS *targets ) 
{ 


  {
#line 190
  if (! targets) {
#line 191
    return (chain);
  } else
#line 192
  if (! chain) {
#line 193
    return (targets);
  }
#line 195
  (chain->tail)->next = targets;
#line 196
  chain->tail = targets->tail;
#line 198
  return (chain);
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/rules.c"
ACTIONS *actionlist(ACTIONS *chain , ACTION *action ) 
{ 
  ACTIONS *actions ;
  void *tmp ;

  {
  {
#line 210
  tmp = malloc(sizeof(ACTIONS ));
#line 210
  actions = (ACTIONS *)tmp;
#line 212
  actions->action = action;
  }
#line 214
  if (! chain) {
#line 214
    chain = actions;
  } else {
#line 215
    (chain->tail)->next = actions;
  }
#line 216
  chain->tail = actions;
#line 217
  actions->next = (ACTIONS *)0;
#line 219
  return (chain);
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/rules.c"
SETTINGS *addsettings(SETTINGS *head , int setflag , char const   *symbol , LIST *value ) 
{ 
  SETTINGS *v ;
  int tmp ;
  void *tmp___0 ;

  {
#line 242
  v = head;
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 242
    if (! v) {
#line 242
      goto while_break;
    }
    {
#line 243
    tmp = strcmp(v->symbol, symbol);
    }
#line 243
    if (! tmp) {
#line 244
      goto while_break;
    }
#line 242
    v = v->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 250
  if (! v) {
    {
#line 252
    tmp___0 = malloc(sizeof(*v));
#line 252
    v = (SETTINGS *)tmp___0;
#line 253
    v->symbol = newstr(symbol);
#line 254
    v->value = value;
#line 255
    v->next = head;
#line 256
    head = v;
    }
  } else {
    {
#line 260
    if (setflag == 0) {
#line 260
      goto case_0;
    }
#line 266
    if (setflag == 1) {
#line 266
      goto case_1;
    }
#line 271
    if (setflag == 2) {
#line 271
      goto case_2;
    }
#line 258
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 262
    list_free(v->value);
#line 263
    v->value = value;
    }
#line 264
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 268
    v->value = list_append(v->value, value);
    }
#line 269
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 273
    list_free(value);
    }
#line 274
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 279
  return (head);
}
}
#line 297 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/rules.c"
SETTINGS *copysettings(SETTINGS *from ) 
{ 
  SETTINGS *head ;
  SETTINGS *v___0 ;
  void *tmp ;

  {
#line 300
  head = (SETTINGS *)0;
  {
#line 302
  while (1) {
    while_continue: /* CIL Label */ ;
#line 302
    if (! from) {
#line 302
      goto while_break;
    }
    {
#line 304
    tmp = malloc(sizeof(*v___0));
#line 304
    v___0 = (SETTINGS *)tmp;
#line 305
    v___0->symbol = copystr(from->symbol);
#line 306
    v___0->value = list_copy((LIST *)0, from->value);
#line 307
    v___0->next = head;
#line 308
    head = v___0;
#line 302
    from = from->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 311
  return (head);
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/rules.c"
void pushsettings(SETTINGS *v ) 
{ 


  {
  {
#line 321
  while (1) {
    while_continue: /* CIL Label */ ;
#line 321
    if (! v) {
#line 321
      goto while_break;
    }
    {
#line 322
    v->value = var_swap(v->symbol, v->value);
#line 321
    v = v->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 323
  return;
}
}
#line 329 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/rules.c"
void popsettings(SETTINGS *v ) 
{ 


  {
  {
#line 332
  pushsettings(v);
  }
#line 333
  return;
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/rules.c"
void freesettings(SETTINGS *v ) 
{ 
  SETTINGS *n ;

  {
  {
#line 342
  while (1) {
    while_continue: /* CIL Label */ ;
#line 342
    if (! v) {
#line 342
      goto while_break;
    }
    {
#line 344
    n = v->next;
#line 346
    freestr(v->symbol);
#line 347
    list_free(v->value);
#line 348
    free((void *)((char *)v));
#line 350
    v = n;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 352
  return;
}
}
#line 358 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/rules.c"
void donerules(void) 
{ 


  {
  {
#line 361
  hashdone(rulehash);
#line 362
  hashdone(targethash);
  }
#line 363
  return;
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/scan.h"
void yyfparse(char const   *s ) ;
#line 48
int yyline(void) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/scan.c"
struct keyword keywords[46]  = 
#line 30 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/scan.c"
  {      {"!", 258}, 
        {"!=", 259}, 
        {"&", 260}, 
        {"&&", 261}, 
        {"(", 262}, 
        {")", 263}, 
        {"+=", 264}, 
        {":", 265}, 
        {";", 266}, 
        {"<", 267}, 
        {"<=", 268}, 
        {"=", 269}, 
        {">", 270}, 
        {">=", 271}, 
        {"?=", 272}, 
        {"[", 273}, 
        {"]", 274}, 
        {"actions", 275}, 
        {"bind", 276}, 
        {"break", 277}, 
        {"case", 278}, 
        {"continue", 279}, 
        {"default", 280}, 
        {"else", 281}, 
        {"existing", 282}, 
        {"for", 283}, 
        {"if", 284}, 
        {"ignore", 285}, 
        {"in", 286}, 
        {"include", 287}, 
        {"local", 288}, 
        {"maxline", 289}, 
        {"on", 290}, 
        {"piecemeal", 291}, 
        {"quietly", 292}, 
        {"return", 293}, 
        {"rule", 294}, 
        {"switch", 295}, 
        {"together", 296}, 
        {"updated", 297}, 
        {"while", 298}, 
        {"{", 299}, 
        {"|", 300}, 
        {"||", 301}, 
        {"}", 302}, 
        {(char const   *)0, 0}};
#line 48 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/scan.c"
static struct include *incp  =    (struct include *)0;
#line 50 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/scan.c"
static int scanmode  =    0;
#line 51 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/scan.c"
static int anyerrors  =    0;
#line 52
static char *symdump(YYSYMBOL *s ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/scan.c"
void yymode(int n ) 
{ 


  {
#line 63
  scanmode = n;
#line 64
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/scan.c"
void yyerror(char const   *s ) 
{ 
  char *tmp ;

  {
#line 69
  if (incp) {
    {
#line 70
    printf((char const   */* __restrict  */)"%s: line %d: ", incp->fname, incp->line);
    }
  }
  {
#line 72
  tmp = symdump(& yylval);
#line 72
  printf((char const   */* __restrict  */)"%s at %s\n", s, tmp);
#line 74
  anyerrors ++;
  }
#line 75
  return;
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/scan.c"
int yyanyerrors(void) 
{ 


  {
#line 80
  return (anyerrors != 0);
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/scan.c"
void yyfparse(char const   *s ) 
{ 
  struct include *i ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 86
  tmp = malloc(sizeof(*i));
#line 86
  i = (struct include *)tmp;
#line 90
  i->string = "";
#line 91
  i->strings = (char **)0;
#line 92
  i->file = (FILE *)0;
#line 93
  i->fname = copystr(s);
#line 94
  i->line = 0;
#line 95
  i->next = incp;
#line 96
  incp = i;
#line 100
  tmp___0 = strcmp(s, "+");
  }
#line 100
  if (! tmp___0) {
#line 101
    i->strings = jambase;
  }
#line 102
  return;
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/scan.c"
int yyline(void) 
{ 
  struct include *i ;
  char const   *tmp ;
  char **tmp___0 ;
  char const   *tmp___1 ;
  FILE *f ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;

  {
#line 114
  i = incp;
#line 116
  if (! incp) {
#line 117
    return (-1);
  }
#line 125
  if (*(i->string)) {
#line 126
    tmp = i->string;
#line 126
    (i->string) ++;
#line 126
    return ((int )*tmp);
  }
#line 131
  if (i->strings) {
#line 133
    if (! *(i->strings)) {
#line 134
      goto next;
    }
#line 136
    (i->line) ++;
#line 137
    tmp___0 = i->strings;
#line 137
    (i->strings) ++;
#line 137
    i->string = (char const   *)*tmp___0;
#line 138
    tmp___1 = i->string;
#line 138
    (i->string) ++;
#line 138
    return ((int )*tmp___1);
  }
#line 143
  if (! i->file) {
    {
#line 145
    f = stdin;
#line 147
    tmp___2 = strcmp(i->fname, "-");
    }
#line 147
    if (tmp___2) {
      {
#line 147
      f = fopen((char const   */* __restrict  */)i->fname, (char const   */* __restrict  */)"r");
      }
#line 147
      if (! f) {
        {
#line 148
        perror(i->fname);
        }
      }
    }
#line 150
    i->file = f;
  }
#line 155
  if (i->file) {
    {
#line 155
    tmp___4 = fgets((char */* __restrict  */)(i->buf), (int )sizeof(i->buf), (FILE */* __restrict  */)i->file);
    }
#line 155
    if (tmp___4) {
#line 157
      (i->line) ++;
#line 158
      i->string = (char const   *)(i->buf);
#line 159
      tmp___3 = i->string;
#line 159
      (i->string) ++;
#line 159
      return ((int )*tmp___3);
    }
  }
  next: 
#line 166
  incp = i->next;
#line 170
  if (i->file) {
#line 170
    if ((unsigned long )i->file != (unsigned long )stdin) {
      {
#line 171
      fclose(i->file);
      }
    }
  }
  {
#line 172
  freestr(i->fname);
#line 173
  free((void *)((char *)i));
  }
#line 175
  return (-1);
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/scan.c"
int yylex(void) 
{ 
  int c ;
  char buf___0[10240] ;
  char *b ;
  char const   *tmp ;
  int tmp___0 ;
  int nest ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char *b___0 ;
  struct keyword *k ;
  int inquote ;
  int notkeyword ;
  char const   *tmp___4 ;
  int tmp___5 ;
  unsigned short const   **tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  char const   *tmp___13 ;
  int tmp___14 ;
  unsigned short const   **tmp___15 ;
  int tmp___16 ;
  unsigned short const   **tmp___17 ;
  char *tmp___18 ;

  {
#line 198
  b = buf___0;
#line 200
  if (! incp) {
#line 201
    goto eof;
  }
#line 205
  if (*(incp->string)) {
#line 205
    tmp = incp->string;
#line 205
    (incp->string) ++;
#line 205
    c = (int )*tmp;
  } else {
    {
#line 205
    tmp___0 = yyline();
#line 205
    c = tmp___0;
    }
  }
#line 207
  if (scanmode == 1) {
#line 212
    nest = 1;
    {
#line 214
    while (1) {
      while_continue: /* CIL Label */ ;
#line 214
      if (c != -1) {
#line 214
        if (! ((unsigned long )b < (unsigned long )(buf___0 + sizeof(buf___0)))) {
#line 214
          goto while_break;
        }
      } else {
#line 214
        goto while_break;
      }
#line 216
      if (c == 123) {
#line 217
        nest ++;
      }
#line 219
      if (c == 125) {
#line 219
        nest --;
#line 219
        if (! nest) {
#line 220
          goto while_break;
        }
      }
#line 222
      tmp___1 = b;
#line 222
      b ++;
#line 222
      *tmp___1 = (char )c;
#line 224
      if (*(incp->string)) {
#line 224
        tmp___2 = incp->string;
#line 224
        (incp->string) ++;
#line 224
        c = (int )*tmp___2;
      } else {
        {
#line 224
        tmp___3 = yyline();
#line 224
        c = tmp___3;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 229
    if (c != -1) {
#line 230
      (incp->string) --;
    }
#line 234
    if ((unsigned long )b == (unsigned long )(buf___0 + sizeof(buf___0))) {
      {
#line 236
      yyerror("action block too big");
      }
#line 237
      goto eof;
    }
#line 240
    if (nest) {
      {
#line 242
      yyerror("unmatched {} in action block");
      }
#line 243
      goto eof;
    }
    {
#line 246
    *b = (char)0;
#line 247
    yylval.type = 304;
#line 248
    yylval.string = newstr((char const   *)(buf___0));
    }
  } else {
#line 253
    b___0 = buf___0;
#line 255
    inquote = 0;
    {
#line 260
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 264
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 264
        if (c != -1) {
          {
#line 264
          tmp___6 = __ctype_b_loc();
          }
#line 264
          if (! ((int const   )*(*tmp___6 + c) & 8192)) {
#line 264
            goto while_break___1;
          }
        } else {
#line 264
          goto while_break___1;
        }
#line 265
        if (*(incp->string)) {
#line 265
          tmp___4 = incp->string;
#line 265
          (incp->string) ++;
#line 265
          c = (int )*tmp___4;
        } else {
          {
#line 265
          tmp___5 = yyline();
#line 265
          c = tmp___5;
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 269
      if (c != 35) {
#line 270
        goto while_break___0;
      }
      {
#line 271
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 271
        if (*(incp->string)) {
#line 271
          tmp___7 = incp->string;
#line 271
          (incp->string) ++;
#line 271
          c = (int )*tmp___7;
        } else {
          {
#line 271
          tmp___8 = yyline();
#line 271
          c = tmp___8;
          }
        }
#line 271
        if (c != -1) {
#line 271
          if (! (c != 10)) {
#line 271
            goto while_break___2;
          }
        } else {
#line 271
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 277
    if (c == -1) {
#line 278
      goto eof;
    }
#line 283
    notkeyword = c == 36;
    {
#line 289
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 289
      if (c != -1) {
#line 289
        if ((unsigned long )b___0 < (unsigned long )(buf___0 + sizeof(buf___0))) {
#line 289
          if (! inquote) {
            {
#line 289
            tmp___15 = __ctype_b_loc();
            }
#line 289
            if ((int const   )*(*tmp___15 + c) & 8192) {
#line 289
              goto while_break___3;
            }
          }
        } else {
#line 289
          goto while_break___3;
        }
      } else {
#line 289
        goto while_break___3;
      }
#line 294
      if (c == 34) {
#line 297
        inquote = ! inquote;
#line 298
        notkeyword = 1;
      } else
#line 300
      if (c != 92) {
#line 303
        tmp___9 = b___0;
#line 303
        b___0 ++;
#line 303
        *tmp___9 = (char )c;
      } else {
#line 305
        if (*(incp->string)) {
#line 305
          tmp___11 = incp->string;
#line 305
          (incp->string) ++;
#line 305
          c = (int )*tmp___11;
        } else {
          {
#line 305
          tmp___12 = yyline();
#line 305
          c = tmp___12;
          }
        }
#line 305
        if (c != -1) {
#line 308
          tmp___10 = b___0;
#line 308
          b___0 ++;
#line 308
          *tmp___10 = (char )c;
#line 309
          notkeyword = 1;
        } else {
#line 314
          goto while_break___3;
        }
      }
#line 317
      if (*(incp->string)) {
#line 317
        tmp___13 = incp->string;
#line 317
        (incp->string) ++;
#line 317
        c = (int )*tmp___13;
      } else {
        {
#line 317
        tmp___14 = yyline();
#line 317
        c = tmp___14;
        }
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 322
    if ((unsigned long )b___0 == (unsigned long )(buf___0 + sizeof(buf___0))) {
      {
#line 324
      yyerror("string too big");
      }
#line 325
      goto eof;
    }
#line 328
    if (inquote) {
      {
#line 330
      yyerror("unmatched \" in string");
      }
#line 331
      goto eof;
    }
#line 336
    if (c != -1) {
#line 337
      (incp->string) --;
    }
#line 343
    *b___0 = (char)0;
#line 344
    yylval.type = 303;
#line 346
    if (! notkeyword) {
      {
#line 346
      tmp___17 = __ctype_b_loc();
      }
#line 346
      if ((int const   )*(*tmp___17 + (int )buf___0[0]) & 1024) {
#line 346
        if (! (scanmode == 2)) {
#line 346
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 348
        k = keywords;
        {
#line 348
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 348
          if (! k->word) {
#line 348
            goto while_break___4;
          }
#line 349
          if ((int )buf___0[0] == (int )*(k->word)) {
            {
#line 349
            tmp___16 = strcmp(k->word, (char const   *)(buf___0));
            }
#line 349
            if (! tmp___16) {
#line 351
              yylval.type = k->type;
#line 352
              yylval.string = k->word;
#line 353
              goto while_break___4;
            }
          }
#line 348
          k ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
    }
#line 357
    if (yylval.type == 303) {
      {
#line 358
      yylval.string = newstr((char const   *)(buf___0));
      }
    }
  }
#line 361
  if (globs.debug[9]) {
    {
#line 362
    tmp___18 = symdump(& yylval);
#line 362
    printf((char const   */* __restrict  */)"scan %s\n", tmp___18);
    }
  }
#line 364
  return (yylval.type);
  eof: 
#line 367
  yylval.type = -1;
#line 368
  return (yylval.type);
}
}
#line 374 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/scan.c"
static char buf[10260]  ;
#line 371 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/scan.c"
static char *symdump(YYSYMBOL *s ) 
{ 


  {
  {
#line 378
  if (s->type == -1) {
#line 378
    goto case_neg_1;
  }
#line 381
  if (s->type == 0) {
#line 381
    goto case_0;
  }
#line 384
  if (s->type == 303) {
#line 384
    goto case_303;
  }
#line 387
  if (s->type == 304) {
#line 387
    goto case_304;
  }
#line 390
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 379
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"EOF");
  }
#line 380
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 382
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"unknown symbol %s",
          s->string);
  }
#line 383
  goto switch_break;
  case_303: /* CIL Label */ 
  {
#line 385
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"argument %s",
          s->string);
  }
#line 386
  goto switch_break;
  case_304: /* CIL Label */ 
  {
#line 388
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"string \"%s\"",
          s->string);
  }
#line 389
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 391
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"keyword %s",
          s->string);
  }
#line 392
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 394
  return (buf);
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/jam.c"
static char const   *othersyms___0[5]  = {      "UNIX=true",      "OS=LINUX",      "",      "JAMVERSION=2.5.2", 
        (char const   *)0};
#line 31 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/lists.c"
static LIST *freelist___0  =    (LIST *)0;
#line 34 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/glob.c"
static void globchars___0(char const   *s , char const   *e , char *b ) ;
#line 121 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/glob.c"
static void globchars___0(char const   *s , char const   *e , char *b ) 
{ 
  int neg ;
  int c ;
  char const   *tmp ;
  int i ;

  {
  {
#line 127
  neg = 0;
#line 129
  memset((void *)b, '\000', (size_t )16);
  }
#line 131
  if ((int const   )*s == 94) {
#line 132
    neg ++;
#line 132
    s ++;
  }
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if (! ((unsigned long )s < (unsigned long )e)) {
#line 134
      goto while_break;
    }
#line 138
    if ((unsigned long )(s + 2) < (unsigned long )e) {
#line 138
      if ((int const   )*(s + 1) == 45) {
#line 140
        c = (int )*(s + 0);
        {
#line 140
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 140
          if (! (c <= (int )*(s + 2))) {
#line 140
            goto while_break___0;
          }
#line 141
          *(b + c / 8) = (char )((int )*(b + c / 8) | (1 << c % 8));
#line 140
          c ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 142
        s += 3;
      } else {
#line 144
        tmp = s;
#line 144
        s ++;
#line 144
        c = (int )*tmp;
#line 145
        *(b + c / 8) = (char )((int )*(b + c / 8) | (1 << c % 8));
      }
    } else {
#line 144
      tmp = s;
#line 144
      s ++;
#line 144
      c = (int )*tmp;
#line 145
      *(b + c / 8) = (char )((int )*(b + c / 8) | (1 << c % 8));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  if (neg) {
#line 152
    i = 0;
    {
#line 152
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 152
      if (! (i < 16)) {
#line 152
        goto while_break___1;
      }
#line 153
      *(b + i) = (char )((int )*(b + i) ^ 255);
#line 152
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 158
  *(b + 0) = (char )((int )*(b + 0) & 254);
#line 159
  return;
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/option.c"
int getoptions(int argc , char **argv , char const   *opts , option *optv , char **targets ) 
{ 
  int i ;
  int n ;
  int optc ;
  char *arg ;
  int tmp ;
  char const   *f ;
  option *tmp___0 ;
  option *tmp___1 ;
  option *tmp___2 ;
  int tmp___3 ;
  option *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 31
  optc = 256;
#line 33
  memset((void *)((char *)optv), '\000', sizeof(*optv) * 256UL);
#line 35
  n = 0;
#line 36
  i = 0;
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! (i < argc)) {
#line 36
      goto while_break;
    }
#line 40
    if ((int )*(*(argv + i) + 0) == 45) {
#line 42
      tmp = optc;
#line 42
      optc --;
#line 42
      if (! tmp) {
        {
#line 44
        printf((char const   */* __restrict  */)"too many options (%d max)\n", 256);
        }
#line 45
        return (-1);
      }
#line 48
      arg = *(argv + i) + 1;
      {
#line 48
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 48
        if (! *arg) {
#line 48
          goto while_break___0;
        }
#line 52
        f = opts;
        {
#line 52
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 52
          if (! *f) {
#line 52
            goto while_break___1;
          }
#line 53
          if ((int const   )*f == (int const   )*arg) {
#line 54
            goto while_break___1;
          }
#line 52
          f ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 56
        if (! *f) {
          {
#line 58
          printf((char const   */* __restrict  */)"Invalid option: -%c\n", (int )*arg);
          }
#line 59
          return (-1);
        }
#line 62
        optv->flag = (char )*f;
#line 64
        if ((int const   )*(f + 1) != 58) {
#line 66
          tmp___0 = optv;
#line 66
          optv ++;
#line 66
          tmp___0->val = "true";
        } else
#line 68
        if (*(arg + 1)) {
#line 70
          tmp___1 = optv;
#line 70
          optv ++;
#line 70
          tmp___1->val = (char const   *)(arg + 1);
#line 71
          goto while_break___0;
        } else {
#line 73
          i ++;
#line 73
          if (i < argc) {
#line 75
            tmp___2 = optv;
#line 75
            optv ++;
#line 75
            tmp___2->val = (char const   *)*(argv + i);
#line 76
            goto while_break___0;
          } else {
            {
#line 80
            printf((char const   */* __restrict  */)"option: -%c needs argument\n",
                   (int const   )*f);
            }
#line 81
            return (-1);
          }
        }
#line 48
        arg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else
#line 88
    if ((int )*(*(argv + i) + 0) != 61) {
      {
#line 88
      tmp___6 = strchr((char const   *)*(argv + i), '=');
      }
#line 88
      if (tmp___6) {
#line 90
        tmp___3 = optc;
#line 90
        optc --;
#line 90
        if (! tmp___3) {
          {
#line 92
          printf((char const   */* __restrict  */)"too many options (%d max)\n", 256);
          }
#line 93
          return (-1);
        }
#line 96
        optv->flag = (char )'s';
#line 97
        tmp___4 = optv;
#line 97
        optv ++;
#line 97
        tmp___4->val = (char const   *)*(argv + i);
      } else {
#line 88
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 101
      if (n >= 256) {
        {
#line 103
        printf((char const   */* __restrict  */)"too many targets (%d max)\n", 256);
        }
#line 104
        return (-1);
      }
#line 106
      tmp___5 = n;
#line 106
      n ++;
#line 106
      *(targets + tmp___5) = *(argv + i);
    }
#line 36
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 111
  return (n);
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/option.c"
char const   *getoptval(option *optv , char opt , int subopt ) 
{ 
  int i ;
  int tmp ;

  {
#line 126
  i = 0;
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    if (! (i < 256)) {
#line 126
      goto while_break;
    }
#line 127
    if ((int )optv->flag == (int )opt) {
#line 127
      tmp = subopt;
#line 127
      subopt --;
#line 127
      if (! tmp) {
#line 128
        return (optv->val);
      }
    }
#line 126
    i ++;
#line 126
    optv ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  return ((char const   *)0);
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/compile.c"
static char const   *set_names___0[3]  = {      "=",      "+=",      "?="};
#line 83
static void debug_compile___0(int which , char const   *s ) ;
#line 134 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/compile.c"
static int lcmp___0(LIST *t , LIST *s ) 
{ 
  int status ;
  char const   *st ;
  char const   *tmp ;
  char const   *ss ;
  char const   *tmp___0 ;

  {
#line 137
  status = 0;
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    if (! status) {
#line 139
      if (! t) {
#line 139
        if (! s) {
#line 139
          goto while_break;
        }
      }
    } else {
#line 139
      goto while_break;
    }
#line 141
    if (t) {
#line 141
      tmp = t->string;
    } else {
#line 141
      tmp = "";
    }
#line 141
    st = tmp;
#line 142
    if (s) {
#line 142
      tmp___0 = s->string;
    } else {
#line 142
      tmp___0 = "";
    }
    {
#line 142
    ss = tmp___0;
#line 144
    status = strcmp(st, ss);
    }
#line 146
    if (t) {
#line 146
      t = t->next;
    } else {
#line 146
      t = t;
    }
#line 147
    if (s) {
#line 147
      s = s->next;
    } else {
#line 147
      s = s;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 150
  return (status);
}
}
#line 918 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/compile.c"
static int level___0  =    0;
#line 919 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/compile.c"
static char indent___0[36]  = 
#line 919
  {      (char )'>',      (char )'>',      (char )'>',      (char )'>', 
        (char )'|',      (char )'>',      (char )'>',      (char )'>', 
        (char )'>',      (char )'|',      (char )'>',      (char )'>', 
        (char )'>',      (char )'>',      (char )'|',      (char )'>', 
        (char )'>',      (char )'>',      (char )'>',      (char )'|', 
        (char )'>',      (char )'>',      (char )'>',      (char )'>', 
        (char )'|',      (char )'>',      (char )'>',      (char )'>', 
        (char )'>',      (char )'|',      (char )'>',      (char )'>', 
        (char )'>',      (char )'>',      (char )'|',      (char )'\000'};
#line 915 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/compile.c"
static void debug_compile___0(int which , char const   *s ) 
{ 
  int i ;

  {
#line 920
  i = ((1 + level___0) * 2) % 35;
#line 922
  if (which >= 0) {
    {
#line 923
    printf((char const   */* __restrict  */)"%*.*s ", i, i, indent___0);
    }
  }
#line 925
  if (s) {
    {
#line 926
    printf((char const   */* __restrict  */)"%s ", s);
    }
  }
#line 928
  level___0 += which;
#line 929
  return;
}
}
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/variable.c"
static struct hash *varhash  =    (struct hash *)0;
#line 54
static VARIABLE *var_enter(char const   *symbol ) ;
#line 55
static void var_dump(char const   *symbol , LIST *value , char const   *what ) ;
#line 66 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/variable.c"
void var_defines(char const   **e ) 
{ 
  char const   *val ;
  int tmp ;
  char *tmp___0 ;
  LIST *l ;
  char const   *pp ;
  char const   *p ;
  char split ;
  char buf___0[1024] ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int len ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (! *e) {
#line 69
      goto while_break;
    }
    {
#line 76
    tmp = strcmp(*e, "OS=Windows_NT");
    }
#line 76
    if (! tmp) {
#line 77
      goto __Cont;
    }
    {
#line 82
    tmp___0 = strchr(*e, '=');
#line 82
    val = (char const   *)tmp___0;
    }
#line 82
    if (val) {
#line 82
      if ((int const   )*(val + 1) == 40) {
#line 82
        if ((int const   )*(val + 2) == 41) {
#line 83
          goto __Cont;
        }
      }
    }
    {
#line 91
    tmp___5 = strchr(*e, '=');
#line 91
    val = (char const   *)tmp___5;
    }
#line 91
    if (val) {
#line 94
      l = (LIST *)0;
#line 99
      split = (char )' ';
#line 105
      if ((unsigned long )(val - 4) >= (unsigned long )*e) {
        {
#line 107
        tmp___1 = strncmp(val - 4, "PATH", (size_t )4);
        }
#line 107
        if (tmp___1) {
          {
#line 107
          tmp___2 = strncmp(val - 4, "Path", (size_t )4);
          }
#line 107
          if (tmp___2) {
            {
#line 107
            tmp___3 = strncmp(val - 4, "path", (size_t )4);
            }
#line 107
            if (! tmp___3) {
#line 110
              split = (char )':';
            }
          } else {
#line 110
            split = (char )':';
          }
        } else {
#line 110
          split = (char )':';
        }
      }
#line 115
      pp = val + 1;
      {
#line 115
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 115
        tmp___4 = strchr(pp, (int )split);
#line 115
        p = (char const   *)tmp___4;
        }
#line 115
        if (! p) {
#line 115
          goto while_break___0;
        }
#line 117
        len = (int )(p - pp);
#line 119
        if ((unsigned long )len >= sizeof(buf___0)) {
#line 120
          len = (int )(sizeof(buf___0) - 1UL);
        }
        {
#line 122
        strncpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)pp,
                (size_t )len);
#line 123
        buf___0[len] = (char )'\000';
#line 124
        l = list_new(l, (char const   *)(buf___0), 0);
#line 115
        pp = p + 1;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 127
      l = list_new(l, pp, 0);
#line 131
      strncpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)*e,
              (size_t )(val - *e));
#line 132
      buf___0[val - *e] = (char )'\000';
#line 134
      var_set((char const   *)(buf___0), l, 0);
      }
    }
    __Cont: /* CIL Label */ 
#line 69
    e ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 137
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/variable.c"
int var_string(char const   *in , char *out , int outsize , LOL *lol ) 
{ 
  char *out0 ;
  char *oute ;
  char *lastword ;
  int dollar ;
  char *tmp ;
  char const   *tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  unsigned short const   **tmp___4 ;
  LIST *l ;
  LIST *tmp___5 ;
  int so ;
  size_t tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
#line 152
  out0 = out;
#line 153
  oute = (out + outsize) - 1;
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    if (! *in) {
#line 155
      goto while_break;
    }
#line 158
    dollar = 0;
    {
#line 162
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 162
      tmp___1 = __ctype_b_loc();
      }
#line 162
      if (! ((int const   )*(*tmp___1 + (int )*in) & 8192)) {
#line 162
        goto while_break___0;
      }
#line 164
      if ((unsigned long )out >= (unsigned long )oute) {
#line 165
        return (-1);
      }
#line 167
      tmp = out;
#line 167
      out ++;
#line 167
      tmp___0 = in;
#line 167
      in ++;
#line 167
      *tmp = (char )*tmp___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 170
    lastword = out;
    {
#line 174
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 174
      if (*in) {
        {
#line 174
        tmp___4 = __ctype_b_loc();
        }
#line 174
        if ((int const   )*(*tmp___4 + (int )*in) & 8192) {
#line 174
          goto while_break___1;
        }
      } else {
#line 174
        goto while_break___1;
      }
#line 176
      if ((unsigned long )out >= (unsigned long )oute) {
#line 177
        return (-1);
      }
#line 179
      if ((int const   )*(in + 0) == 36) {
#line 179
        if ((int const   )*(in + 1) == 40) {
#line 180
          dollar ++;
        }
      }
#line 182
      tmp___2 = out;
#line 182
      out ++;
#line 182
      tmp___3 = in;
#line 182
      in ++;
#line 182
      *tmp___2 = (char )*tmp___3;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 188
    if (dollar) {
      {
#line 190
      tmp___5 = var_expand((LIST *)0, (char const   *)lastword, (char const   *)out,
                           lol, 0);
#line 190
      l = tmp___5;
#line 192
      out = lastword;
      }
      {
#line 194
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 194
        if (! l) {
#line 194
          goto while_break___2;
        }
        {
#line 196
        tmp___6 = strlen(l->string);
#line 196
        so = (int )tmp___6;
        }
#line 198
        if ((unsigned long )(out + so) >= (unsigned long )oute) {
#line 199
          return (-1);
        }
        {
#line 201
        strcpy((char */* __restrict  */)out, (char const   */* __restrict  */)l->string);
#line 202
        out += so;
#line 206
        l = l->next;
        }
#line 206
        if (l) {
#line 207
          tmp___7 = out;
#line 207
          out ++;
#line 207
          *tmp___7 = (char )' ';
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 210
      list_free(l);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  if ((unsigned long )out >= (unsigned long )oute) {
#line 215
    return (-1);
  }
#line 217
  tmp___8 = out;
#line 217
  out ++;
#line 217
  *tmp___8 = (char )'\000';
#line 219
  return ((int )(out - out0));
}
}
#line 228 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/variable.c"
LIST *var_get(char const   *symbol ) 
{ 
  VARIABLE var ;
  VARIABLE *v ;
  int tmp ;

  {
#line 231
  v = & var;
#line 233
  v->symbol = symbol;
#line 235
  if (varhash) {
    {
#line 235
    tmp = hashitem(varhash, (HASHDATA **)(& v), 0);
    }
#line 235
    if (tmp) {
#line 237
      if (globs.debug[8]) {
        {
#line 238
        var_dump(v->symbol, v->value, "get");
        }
      }
#line 239
      return (v->value);
    }
  }
#line 242
  return ((LIST *)0);
}
}
#line 256 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/variable.c"
void var_set(char const   *symbol , LIST *value , int flag ) 
{ 
  VARIABLE *v ;
  VARIABLE *tmp ;

  {
  {
#line 262
  tmp = var_enter(symbol);
#line 262
  v = tmp;
  }
#line 264
  if (globs.debug[7]) {
    {
#line 265
    var_dump(symbol, value, "set");
    }
  }
  {
#line 269
  if (flag == 0) {
#line 269
    goto case_0;
  }
#line 275
  if (flag == 1) {
#line 275
    goto case_1;
  }
#line 280
  if (flag == 2) {
#line 280
    goto case_2;
  }
#line 267
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 271
  list_free(v->value);
#line 272
  v->value = value;
  }
#line 273
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 277
  v->value = list_append(v->value, value);
  }
#line 278
  goto switch_break;
  case_2: /* CIL Label */ 
#line 282
  if (! v->value) {
#line 283
    v->value = value;
  } else {
    {
#line 285
    list_free(value);
    }
  }
#line 286
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 288
  return;
}
}
#line 294 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/variable.c"
LIST *var_swap(char const   *symbol , LIST *value ) 
{ 
  VARIABLE *v ;
  VARIABLE *tmp ;
  LIST *oldvalue ;

  {
  {
#line 299
  tmp = var_enter(symbol);
#line 299
  v = tmp;
#line 300
  oldvalue = v->value;
  }
#line 302
  if (globs.debug[7]) {
    {
#line 303
    var_dump(symbol, value, "set");
    }
  }
#line 305
  v->value = value;
#line 307
  return (oldvalue);
}
}
#line 316 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/variable.c"
static VARIABLE *var_enter(char const   *symbol ) 
{ 
  VARIABLE var ;
  VARIABLE *v ;
  int tmp ;

  {
#line 319
  v = & var;
#line 321
  if (! varhash) {
    {
#line 322
    varhash = hashinit((int )sizeof(VARIABLE ), "variables");
    }
  }
  {
#line 324
  v->symbol = symbol;
#line 325
  v->value = (LIST *)0;
#line 327
  tmp = hashitem(varhash, (HASHDATA **)(& v), 1);
  }
#line 327
  if (! tmp) {
    {
#line 328
    v->symbol = newstr(symbol);
    }
  }
#line 330
  return (v);
}
}
#line 337 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/variable.c"
static void var_dump(char const   *symbol , LIST *value , char const   *what ) 
{ 


  {
  {
#line 343
  printf((char const   */* __restrict  */)"%s %s = ", what, symbol);
#line 344
  list_print(value);
#line 345
  printf((char const   */* __restrict  */)"\n");
  }
#line 346
  return;
}
}
#line 352 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/variable.c"
void var_done(void) 
{ 


  {
  {
#line 355
  hashdone(varhash);
  }
#line 356
  return;
}
}
#line 230 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/builtins.c"
static void builtin_glob_back___0(void *closure , char const   *file , int status ,
                                  time_t time___0 ) 
{ 
  struct globbing *globbing ;
  LIST *l ;
  PATHNAME f ;
  char buf___0[1024] ;
  int tmp ;

  {
  {
#line 237
  globbing = (struct globbing *)closure;
#line 245
  path_parse(file, & f);
#line 246
  f.part[2].len = 0;
#line 247
  path_build(& f, buf___0, 0);
#line 249
  l = globbing->patterns;
  }
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    if (! l) {
#line 249
      goto while_break;
    }
    {
#line 250
    tmp = glob(l->string, (char const   *)(buf___0));
    }
#line 250
    if (! tmp) {
      {
#line 252
      globbing->results = list_new(globbing->results, file, 0);
      }
#line 253
      goto while_break;
    }
#line 249
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 255
  return;
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/pathunix.c"
void path_parse(char const   *file , PATHNAME *f ) 
{ 
  char const   *p ;
  char const   *q ;
  char const   *end ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 53
  memset((void *)((char *)f), 0, sizeof(*f));
  }
#line 57
  if ((int const   )*(file + 0) == 60) {
    {
#line 57
    tmp = strchr(file, '>');
#line 57
    p = (char const   *)tmp;
    }
#line 57
    if (p) {
#line 59
      f->part[0].ptr = file;
#line 60
      f->part[0].len = (int )(p - file);
#line 61
      file = p + 1;
    }
  }
  {
#line 66
  tmp___0 = strrchr(file, '/');
#line 66
  p = (char const   *)tmp___0;
  }
#line 76
  if (p) {
#line 78
    f->part[2].ptr = file;
#line 79
    f->part[2].len = (int )(p - file);
#line 83
    if (! f->part[2].len) {
#line 84
      f->part[2].len = 1;
    }
#line 93
    file = p + 1;
  }
  {
#line 96
  tmp___1 = strlen(file);
#line 96
  end = file + tmp___1;
#line 100
  tmp___2 = strchr(file, '(');
#line 100
  p = (char const   *)tmp___2;
  }
#line 100
  if (p) {
#line 100
    if ((int const   )*(end + -1) == 41) {
#line 102
      f->part[5].ptr = p + 1;
#line 103
      f->part[5].len = (int )((end - p) - 2L);
#line 104
      end = p;
    }
  }
#line 110
  p = (char const   *)0;
#line 111
  q = file;
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 113
    tmp___4 = memchr((void const   *)q, '.', (size_t )(end - q));
#line 113
    q = (char const   *)((char *)tmp___4);
    }
#line 113
    if (! q) {
#line 113
      goto while_break;
    }
#line 114
    tmp___3 = q;
#line 114
    q ++;
#line 114
    p = tmp___3;
  }
  while_break: /* CIL Label */ ;
  }
#line 116
  if (p) {
#line 118
    f->part[4].ptr = p;
#line 119
    f->part[4].len = (int )(end - p);
#line 120
    end = p;
  }
#line 125
  f->part[3].ptr = file;
#line 126
  f->part[3].len = (int )(end - file);
#line 127
  return;
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/pathunix.c"
void path_build(PATHNAME *f , char *file , int binding ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 142
  if (f->part[0].len) {
#line 144
    if ((int const   )*(f->part[0].ptr + 0) != 60) {
#line 144
      tmp = file;
#line 144
      file ++;
#line 144
      *tmp = (char )'<';
    }
    {
#line 145
    memcpy((void */* __restrict  */)file, (void const   */* __restrict  */)f->part[0].ptr,
           (size_t )f->part[0].len);
#line 146
    file += f->part[0].len;
    }
#line 147
    if ((int )*(file + -1) != 62) {
#line 147
      tmp___0 = file;
#line 147
      file ++;
#line 147
      *tmp___0 = (char )'>';
    }
  }
#line 154
  if (f->part[1].len) {
#line 154
    if (f->part[1].len == 1) {
#line 154
      if (! ((int const   )*(f->part[1].ptr + 0) == 46)) {
#line 154
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 154
    if (f->part[2].len) {
#line 154
      if (! ((int const   )*(f->part[2].ptr + 0) == 47)) {
        {
#line 169
        memcpy((void */* __restrict  */)file, (void const   */* __restrict  */)f->part[1].ptr,
               (size_t )f->part[1].len);
#line 170
        file += f->part[1].len;
#line 171
        tmp___1 = file;
#line 171
        file ++;
#line 171
        *tmp___1 = (char )'/';
        }
      }
    } else {
      {
#line 169
      memcpy((void */* __restrict  */)file, (void const   */* __restrict  */)f->part[1].ptr,
             (size_t )f->part[1].len);
#line 170
      file += f->part[1].len;
#line 171
      tmp___1 = file;
#line 171
      file ++;
#line 171
      *tmp___1 = (char )'/';
      }
    }
  }
#line 174
  if (f->part[2].len) {
    {
#line 176
    memcpy((void */* __restrict  */)file, (void const   */* __restrict  */)f->part[2].ptr,
           (size_t )f->part[2].len);
#line 177
    file += f->part[2].len;
    }
  }
#line 183
  if (f->part[2].len) {
#line 183
    if (f->part[3].len) {
#line 183
      goto _L___0;
    } else
#line 183
    if (f->part[4].len) {
      _L___0: /* CIL Label */ 
#line 191
      if (f->part[2].len == 1) {
#line 191
        if (! ((int const   )*(f->part[2].ptr + 0) == 47)) {
#line 192
          tmp___2 = file;
#line 192
          file ++;
#line 192
          *tmp___2 = (char )'/';
        }
      } else {
#line 192
        tmp___2 = file;
#line 192
        file ++;
#line 192
        *tmp___2 = (char )'/';
      }
    }
  }
#line 195
  if (f->part[3].len) {
    {
#line 197
    memcpy((void */* __restrict  */)file, (void const   */* __restrict  */)f->part[3].ptr,
           (size_t )f->part[3].len);
#line 198
    file += f->part[3].len;
    }
  }
#line 201
  if (f->part[4].len) {
    {
#line 203
    memcpy((void */* __restrict  */)file, (void const   */* __restrict  */)f->part[4].ptr,
           (size_t )f->part[4].len);
#line 204
    file += f->part[4].len;
    }
  }
#line 207
  if (f->part[5].len) {
    {
#line 209
    tmp___3 = file;
#line 209
    file ++;
#line 209
    *tmp___3 = (char )'(';
#line 210
    memcpy((void */* __restrict  */)file, (void const   */* __restrict  */)f->part[5].ptr,
           (size_t )f->part[5].len);
#line 211
    file += f->part[5].len;
#line 212
    tmp___4 = file;
#line 212
    file ++;
#line 212
    *tmp___4 = (char )')';
    }
  }
#line 214
  *file = (char)0;
#line 215
  return;
}
}
#line 221 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/pathunix.c"
void path_parent(PATHNAME *f ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 226
  tmp___0 = "";
#line 226
  f->part[5].ptr = tmp___0;
#line 226
  tmp = tmp___0;
#line 226
  f->part[4].ptr = tmp;
#line 226
  f->part[3].ptr = tmp;
#line 230
  tmp___2 = 0;
#line 230
  f->part[5].len = tmp___2;
#line 230
  tmp___1 = tmp___2;
#line 230
  f->part[4].len = tmp___1;
#line 230
  f->part[3].len = tmp___1;
#line 233
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/headers.c"
static LIST *headers1___0(char const   *file , LIST *hdrscan ) ;
#line 86 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/headers.c"
static LIST *headers1___0(char const   *file , LIST *hdrscan ) 
{ 
  FILE *f ;
  int i ;
  int rec ;
  LIST *result ;
  regexp *re[10] ;
  regexp *re_macros ;
  char buf___0[1024] ;
  int tmp ;
  char buf2[1024] ;
  int l ;
  int tmp___0 ;
  char const   *header_filename ;
  char buf2___0[1024] ;
  int l___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 93
  rec = 0;
#line 94
  result = (LIST *)0;
#line 99
  f = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"r");
  }
#line 99
  if (! f) {
#line 100
    return (result);
  }
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    if (rec < 10) {
#line 102
      if (! hdrscan) {
#line 102
        goto while_break;
      }
    } else {
#line 102
      goto while_break;
    }
    {
#line 104
    tmp = rec;
#line 104
    rec ++;
#line 104
    re[tmp] = regcomp(hdrscan->string);
#line 105
    hdrscan = hdrscan->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 110
  re_macros = regcomp("^[ \t]*#[ \t]*include[ \t]*([A-Za-z][A-Za-z0-9_]*).*$");
  }
  {
#line 113
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 113
    tmp___2 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)f);
    }
#line 113
    if (! tmp___2) {
#line 113
      goto while_break___0;
    }
#line 115
    i = 0;
    {
#line 115
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 115
      if (! (i < rec)) {
#line 115
        goto while_break___1;
      }
      {
#line 116
      tmp___0 = regexec(re[i], (char const   *)(buf___0));
      }
#line 116
      if (tmp___0) {
#line 116
        if ((re[i])->startp[1]) {
          {
#line 121
          l = (int )((re[i])->endp[1] - (re[i])->startp[1]);
#line 122
          memcpy((void */* __restrict  */)(buf2), (void const   */* __restrict  */)(re[i])->startp[1],
                 (size_t )l);
#line 123
          buf2[l] = (char)0;
#line 124
          result = list_new(result, (char const   *)(buf2), 0);
          }
#line 126
          if (globs.debug[6]) {
            {
#line 127
            printf((char const   */* __restrict  */)"header found: %s\n", buf2);
            }
          }
        }
      }
#line 115
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 131
    tmp___1 = regexec(re_macros, (char const   *)(buf___0));
    }
#line 131
    if (tmp___1) {
#line 131
      if (re_macros->startp[1]) {
        {
#line 135
        l___0 = (int )(re_macros->endp[1] - re_macros->startp[1]);
#line 137
        memcpy((void */* __restrict  */)(buf2___0), (void const   */* __restrict  */)re_macros->startp[1],
               (size_t )l___0);
#line 138
        buf2___0[l___0] = (char)0;
        }
#line 140
        if (globs.debug[6]) {
          {
#line 141
          printf((char const   */* __restrict  */)"macro header found: %s", buf2___0);
          }
        }
        {
#line 143
        header_filename = macro_header_get((char const   *)(buf2___0));
        }
#line 144
        if (header_filename) {
#line 145
          if (globs.debug[6]) {
            {
#line 146
            printf((char const   */* __restrict  */)" resolved to \'%s\'\n", header_filename);
            }
          }
          {
#line 147
          result = list_new(result, header_filename, 0);
          }
        } else
#line 149
        if (globs.debug[6]) {
          {
#line 150
          printf((char const   */* __restrict  */)" ignored !!\n");
          }
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 155
  free((void *)re_macros);
  }
  {
#line 157
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 157
    if (! rec) {
#line 157
      goto while_break___2;
    }
    {
#line 158
    rec --;
#line 158
    free((void *)((char *)re[rec]));
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 160
  fclose(f);
  }
#line 162
  return (result);
}
}
#line 404 "y.tab.c"
static unsigned char const   yytranslate___0[305]  = 
#line 404 "y.tab.c"
  {      (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )3,      (unsigned char const   )4, 
        (unsigned char const   )5,      (unsigned char const   )6,      (unsigned char const   )7,      (unsigned char const   )8, 
        (unsigned char const   )9,      (unsigned char const   )10,      (unsigned char const   )11,      (unsigned char const   )12, 
        (unsigned char const   )13,      (unsigned char const   )14,      (unsigned char const   )15,      (unsigned char const   )16, 
        (unsigned char const   )17,      (unsigned char const   )18,      (unsigned char const   )19,      (unsigned char const   )20, 
        (unsigned char const   )21,      (unsigned char const   )22,      (unsigned char const   )23,      (unsigned char const   )24, 
        (unsigned char const   )25,      (unsigned char const   )26,      (unsigned char const   )27,      (unsigned char const   )28, 
        (unsigned char const   )29,      (unsigned char const   )30,      (unsigned char const   )31,      (unsigned char const   )32, 
        (unsigned char const   )33,      (unsigned char const   )34,      (unsigned char const   )35,      (unsigned char const   )36, 
        (unsigned char const   )37,      (unsigned char const   )38,      (unsigned char const   )39,      (unsigned char const   )40, 
        (unsigned char const   )41,      (unsigned char const   )42,      (unsigned char const   )43,      (unsigned char const   )44, 
        (unsigned char const   )45,      (unsigned char const   )46,      (unsigned char const   )47,      (unsigned char const   )48, 
        (unsigned char const   )49};
#line 533 "y.tab.c"
static unsigned char const   yyr1___0[74]  = 
#line 533
  {      (unsigned char const   )0,      (unsigned char const   )50,      (unsigned char const   )51,      (unsigned char const   )51, 
        (unsigned char const   )52,      (unsigned char const   )52,      (unsigned char const   )53,      (unsigned char const   )53, 
        (unsigned char const   )53,      (unsigned char const   )53,      (unsigned char const   )54,      (unsigned char const   )54, 
        (unsigned char const   )54,      (unsigned char const   )54,      (unsigned char const   )54,      (unsigned char const   )54, 
        (unsigned char const   )54,      (unsigned char const   )54,      (unsigned char const   )54,      (unsigned char const   )54, 
        (unsigned char const   )54,      (unsigned char const   )54,      (unsigned char const   )54,      (unsigned char const   )54, 
        (unsigned char const   )54,      (unsigned char const   )55,      (unsigned char const   )56,      (unsigned char const   )54, 
        (unsigned char const   )57,      (unsigned char const   )57,      (unsigned char const   )57,      (unsigned char const   )57, 
        (unsigned char const   )58,      (unsigned char const   )58,      (unsigned char const   )58,      (unsigned char const   )58, 
        (unsigned char const   )58,      (unsigned char const   )58,      (unsigned char const   )58,      (unsigned char const   )58, 
        (unsigned char const   )58,      (unsigned char const   )58,      (unsigned char const   )58,      (unsigned char const   )58, 
        (unsigned char const   )58,      (unsigned char const   )58,      (unsigned char const   )59,      (unsigned char const   )59, 
        (unsigned char const   )60,      (unsigned char const   )61,      (unsigned char const   )61,      (unsigned char const   )61, 
        (unsigned char const   )62,      (unsigned char const   )62,      (unsigned char const   )63,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )65,      (unsigned char const   )66,      (unsigned char const   )65, 
        (unsigned char const   )67,      (unsigned char const   )67,      (unsigned char const   )67,      (unsigned char const   )68, 
        (unsigned char const   )68,      (unsigned char const   )69,      (unsigned char const   )69,      (unsigned char const   )69, 
        (unsigned char const   )69,      (unsigned char const   )69,      (unsigned char const   )69,      (unsigned char const   )69, 
        (unsigned char const   )70,      (unsigned char const   )70};
#line 546 "y.tab.c"
static unsigned char const   yyr2___0[74]  = 
#line 546
  {      (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )1, 
        (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )2, 
        (unsigned char const   )4,      (unsigned char const   )6,      (unsigned char const   )3,      (unsigned char const   )3, 
        (unsigned char const   )3,      (unsigned char const   )4,      (unsigned char const   )6,      (unsigned char const   )3, 
        (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )7,      (unsigned char const   )5, 
        (unsigned char const   )5,      (unsigned char const   )7,      (unsigned char const   )5,      (unsigned char const   )6, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )9, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )2, 
        (unsigned char const   )1,      (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )3, 
        (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )3, 
        (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )3, 
        (unsigned char const   )2,      (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )2, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )3,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )3,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )4, 
        (unsigned char const   )2,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )2, 
        (unsigned char const   )0,      (unsigned char const   )2};
#line 561 "y.tab.c"
static unsigned char const   yydefact___0[154]  = 
#line 561
  {      (unsigned char const   )2,      (unsigned char const   )58,      (unsigned char const   )63,      (unsigned char const   )55, 
        (unsigned char const   )55,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )55, 
        (unsigned char const   )55,      (unsigned char const   )0,      (unsigned char const   )55,      (unsigned char const   )0, 
        (unsigned char const   )55,      (unsigned char const   )0,      (unsigned char const   )4,      (unsigned char const   )57, 
        (unsigned char const   )0,      (unsigned char const   )3,      (unsigned char const   )6,      (unsigned char const   )55, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )54, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )49,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )5,      (unsigned char const   )1, 
        (unsigned char const   )7,      (unsigned char const   )29,      (unsigned char const   )28,      (unsigned char const   )30, 
        (unsigned char const   )0,      (unsigned char const   )55,      (unsigned char const   )55,      (unsigned char const   )0, 
        (unsigned char const   )52,      (unsigned char const   )0,      (unsigned char const   )55,      (unsigned char const   )0, 
        (unsigned char const   )70,      (unsigned char const   )67,      (unsigned char const   )0,      (unsigned char const   )69, 
        (unsigned char const   )68,      (unsigned char const   )66,      (unsigned char const   )65,      (unsigned char const   )72, 
        (unsigned char const   )64,      (unsigned char const   )15,      (unsigned char const   )56,      (unsigned char const   )16, 
        (unsigned char const   )55,      (unsigned char const   )44,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )4, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )55,      (unsigned char const   )11, 
        (unsigned char const   )4,      (unsigned char const   )55,      (unsigned char const   )24,      (unsigned char const   )17, 
        (unsigned char const   )51,      (unsigned char const   )0,      (unsigned char const   )46,      (unsigned char const   )4, 
        (unsigned char const   )10,      (unsigned char const   )31,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )55,      (unsigned char const   )0,      (unsigned char const   )60, 
        (unsigned char const   )59,      (unsigned char const   )71,      (unsigned char const   )55,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )45,      (unsigned char const   )34,      (unsigned char const   )39, 
        (unsigned char const   )40,      (unsigned char const   )35,      (unsigned char const   )36,      (unsigned char const   )33, 
        (unsigned char const   )37,      (unsigned char const   )38,      (unsigned char const   )0,      (unsigned char const   )41, 
        (unsigned char const   )42,      (unsigned char const   )43,      (unsigned char const   )8,      (unsigned char const   )0, 
        (unsigned char const   )49,      (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )46,      (unsigned char const   )0,      (unsigned char const   )55,      (unsigned char const   )13, 
        (unsigned char const   )53,      (unsigned char const   )55,      (unsigned char const   )55,      (unsigned char const   )73, 
        (unsigned char const   )25,      (unsigned char const   )4,      (unsigned char const   )20,      (unsigned char const   )4, 
        (unsigned char const   )50,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )19, 
        (unsigned char const   )47,      (unsigned char const   )22,      (unsigned char const   )0,      (unsigned char const   )62, 
        (unsigned char const   )61,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )9,      (unsigned char const   )23,      (unsigned char const   )4,      (unsigned char const   )14, 
        (unsigned char const   )26,      (unsigned char const   )18,      (unsigned char const   )21,      (unsigned char const   )48, 
        (unsigned char const   )0,      (unsigned char const   )27};
#line 582 "y.tab.c"
static short const   yydefgoto___0[21]  = 
#line 582
  {      (short const   )-1,      (short const   )16,      (short const   )37,      (short const   )38, 
        (short const   )18,      (short const   )141,      (short const   )152,      (short const   )46, 
        (short const   )28,      (short const   )119,      (short const   )120,      (short const   )85, 
        (short const   )47,      (short const   )48,      (short const   )23,      (short const   )29, 
        (short const   )20,      (short const   )51,      (short const   )21,      (short const   )60, 
        (short const   )99};
#line 592 "y.tab.c"
static short const   yypact___0[154]  = 
#line 592
  {      (short const   )154,      (short const   )-59,      (short const   )-59,      (short const   )-59, 
        (short const   )-59,      (short const   )-32,      (short const   )8,      (short const   )-59, 
        (short const   )-59,      (short const   )-6,      (short const   )-59,      (short const   )-7, 
        (short const   )-59,      (short const   )8,      (short const   )154,      (short const   )-59, 
        (short const   )46,      (short const   )-59,      (short const   )154,      (short const   )49, 
        (short const   )-14,      (short const   )200,      (short const   )37,      (short const   )-6, 
        (short const   )40,      (short const   )21,      (short const   )8,      (short const   )8, 
        (short const   )120,      (short const   )22,      (short const   )43,      (short const   )19, 
        (short const   )185,      (short const   )58,      (short const   )9,      (short const   )26, 
        (short const   )135,      (short const   )25,      (short const   )-59,      (short const   )-59, 
        (short const   )-59,      (short const   )-59,      (short const   )-59,      (short const   )-59, 
        (short const   )63,      (short const   )-59,      (short const   )-59,      (short const   )67, 
        (short const   )71,      (short const   )-6,      (short const   )-59,      (short const   )66, 
        (short const   )-59,      (short const   )-59,      (short const   )38,      (short const   )-59, 
        (short const   )-59,      (short const   )-59,      (short const   )-59,      (short const   )61, 
        (short const   )-59,      (short const   )-59,      (short const   )-59,      (short const   )-59, 
        (short const   )-59,      (short const   )-59,      (short const   )155,      (short const   )8, 
        (short const   )8,      (short const   )8,      (short const   )8,      (short const   )8, 
        (short const   )8,      (short const   )8,      (short const   )8,      (short const   )154, 
        (short const   )8,      (short const   )8,      (short const   )-59,      (short const   )-59, 
        (short const   )154,      (short const   )-59,      (short const   )-59,      (short const   )-59, 
        (short const   )79,      (short const   )47,      (short const   )69,      (short const   )154, 
        (short const   )-59,      (short const   )-59,      (short const   )10,      (short const   )82, 
        (short const   )-59,      (short const   )-59,      (short const   )7,      (short const   )-59, 
        (short const   )-59,      (short const   )-59,      (short const   )-59,      (short const   )51, 
        (short const   )53,      (short const   )-59,      (short const   )52,      (short const   )24, 
        (short const   )24,      (short const   )-59,      (short const   )-59,      (short const   )52, 
        (short const   )-59,      (short const   )-59,      (short const   )62,      (short const   )239, 
        (short const   )239,      (short const   )-59,      (short const   )-59,      (short const   )87, 
        (short const   )9,      (short const   )154,      (short const   )42,      (short const   )65, 
        (short const   )69,      (short const   )68,      (short const   )-59,      (short const   )-59, 
        (short const   )-59,      (short const   )-59,      (short const   )-59,      (short const   )-59, 
        (short const   )-59,      (short const   )154,      (short const   )73,      (short const   )154, 
        (short const   )-59,      (short const   )72,      (short const   )90,      (short const   )-59, 
        (short const   )-59,      (short const   )-59,      (short const   )102,      (short const   )-59, 
        (short const   )-59,      (short const   )78,      (short const   )74,      (short const   )185, 
        (short const   )-59,      (short const   )-59,      (short const   )154,      (short const   )-59, 
        (short const   )-59,      (short const   )-59,      (short const   )-59,      (short const   )-59, 
        (short const   )75,      (short const   )-59};
#line 613 "y.tab.c"
static yysigned_char const   yypgoto___0[21]  = 
#line 613
  {      (yysigned_char const   )-59,      (yysigned_char const   )-59,      (yysigned_char const   )-58,      (yysigned_char const   )13, 
        (yysigned_char const   )-29,      (yysigned_char const   )-59,      (yysigned_char const   )-59,      (yysigned_char const   )28, 
        (yysigned_char const   )34,      (yysigned_char const   )-4,      (yysigned_char const   )-59,      (yysigned_char const   )12, 
        (yysigned_char const   )-43,      (yysigned_char const   )-2,      (yysigned_char const   )-59,      (yysigned_char const   )0, 
        (yysigned_char const   )-59,      (yysigned_char const   )-59,      (yysigned_char const   )-59,      (yysigned_char const   )-59, 
        (yysigned_char const   )-59};
#line 625 "y.tab.c"
static unsigned char const   yytable___0[256]  = 
#line 625
  {      (unsigned char const   )19,      (unsigned char const   )22,      (unsigned char const   )24,      (unsigned char const   )82, 
        (unsigned char const   )1,      (unsigned char const   )30,      (unsigned char const   )31,      (unsigned char const   )95, 
        (unsigned char const   )33,      (unsigned char const   )32,      (unsigned char const   )35,      (unsigned char const   )26, 
        (unsigned char const   )1,      (unsigned char const   )17,      (unsigned char const   )19,      (unsigned char const   )27, 
        (unsigned char const   )25,      (unsigned char const   )110,      (unsigned char const   )19,      (unsigned char const   )41, 
        (unsigned char const   )50,      (unsigned char const   )49,      (unsigned char const   )114,      (unsigned char const   )62, 
        (unsigned char const   )42,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )43, 
        (unsigned char const   )67,      (unsigned char const   )121,      (unsigned char const   )80,      (unsigned char const   )40, 
        (unsigned char const   )19,      (unsigned char const   )81,      (unsigned char const   )15,      (unsigned char const   )44, 
        (unsigned char const   )70,      (unsigned char const   )71,      (unsigned char const   )72,      (unsigned char const   )73, 
        (unsigned char const   )74,      (unsigned char const   )34,      (unsigned char const   )15,      (unsigned char const   )90, 
        (unsigned char const   )91,      (unsigned char const   )125,      (unsigned char const   )39,      (unsigned char const   )36, 
        (unsigned char const   )61,      (unsigned char const   )94,      (unsigned char const   )124,      (unsigned char const   )63, 
        (unsigned char const   )64,      (unsigned char const   )78,      (unsigned char const   )79,      (unsigned char const   )15, 
        (unsigned char const   )15,      (unsigned char const   )84,      (unsigned char const   )41,      (unsigned char const   )133, 
        (unsigned char const   )65,      (unsigned char const   )66,      (unsigned char const   )100,      (unsigned char const   )42, 
        (unsigned char const   )70,      (unsigned char const   )71,      (unsigned char const   )43,      (unsigned char const   )73, 
        (unsigned char const   )74,      (unsigned char const   )83,      (unsigned char const   )86,      (unsigned char const   )142, 
        (unsigned char const   )88,      (unsigned char const   )144,      (unsigned char const   )44,      (unsigned char const   )19, 
        (unsigned char const   )113,      (unsigned char const   )89,      (unsigned char const   )92,      (unsigned char const   )115, 
        (unsigned char const   )19,      (unsigned char const   )93,      (unsigned char const   )98,      (unsigned char const   )140, 
        (unsigned char const   )45,      (unsigned char const   )96,      (unsigned char const   )97,      (unsigned char const   )19, 
        (unsigned char const   )151,      (unsigned char const   )116,      (unsigned char const   )134,      (unsigned char const   )117, 
        (unsigned char const   )118,      (unsigned char const   )123,      (unsigned char const   )126,      (unsigned char const   )128, 
        (unsigned char const   )127,      (unsigned char const   )129,      (unsigned char const   )131,      (unsigned char const   )143, 
        (unsigned char const   )146,      (unsigned char const   )102,      (unsigned char const   )103,      (unsigned char const   )104, 
        (unsigned char const   )105,      (unsigned char const   )106,      (unsigned char const   )107,      (unsigned char const   )108, 
        (unsigned char const   )109,      (unsigned char const   )130,      (unsigned char const   )111,      (unsigned char const   )112, 
        (unsigned char const   )135,      (unsigned char const   )147,      (unsigned char const   )150,      (unsigned char const   )137, 
        (unsigned char const   )136,      (unsigned char const   )19,      (unsigned char const   )122,      (unsigned char const   )145, 
        (unsigned char const   )138,      (unsigned char const   )149,      (unsigned char const   )153,      (unsigned char const   )139, 
        (unsigned char const   )67,      (unsigned char const   )68,      (unsigned char const   )69,      (unsigned char const   )148, 
        (unsigned char const   )132,      (unsigned char const   )19,      (unsigned char const   )0,      (unsigned char const   )19, 
        (unsigned char const   )70,      (unsigned char const   )71,      (unsigned char const   )72,      (unsigned char const   )73, 
        (unsigned char const   )74,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )67, 
        (unsigned char const   )68,      (unsigned char const   )69,      (unsigned char const   )0,      (unsigned char const   )19, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )19,      (unsigned char const   )70, 
        (unsigned char const   )71,      (unsigned char const   )72,      (unsigned char const   )73,      (unsigned char const   )74, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )67, 
        (unsigned char const   )68,      (unsigned char const   )69,      (unsigned char const   )0,      (unsigned char const   )101, 
        (unsigned char const   )75,      (unsigned char const   )76,      (unsigned char const   )77,      (unsigned char const   )70, 
        (unsigned char const   )71,      (unsigned char const   )72,      (unsigned char const   )73,      (unsigned char const   )74, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )0, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )4,      (unsigned char const   )87, 
        (unsigned char const   )76,      (unsigned char const   )77,      (unsigned char const   )5,      (unsigned char const   )6, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )7,      (unsigned char const   )8, 
        (unsigned char const   )0,      (unsigned char const   )9,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )10,      (unsigned char const   )11,      (unsigned char const   )12,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )13,      (unsigned char const   )14,      (unsigned char const   )0, 
        (unsigned char const   )76,      (unsigned char const   )77,      (unsigned char const   )15,      (unsigned char const   )1, 
        (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )3, 
        (unsigned char const   )0,      (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )5,      (unsigned char const   )6,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )9,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )10, 
        (unsigned char const   )11,      (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )52, 
        (unsigned char const   )13,      (unsigned char const   )14,      (unsigned char const   )53,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )15,      (unsigned char const   )54,      (unsigned char const   )0, 
        (unsigned char const   )55,      (unsigned char const   )56,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )57,      (unsigned char const   )58,      (unsigned char const   )67, 
        (unsigned char const   )68,      (unsigned char const   )69,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )59,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )70, 
        (unsigned char const   )71,      (unsigned char const   )72,      (unsigned char const   )73,      (unsigned char const   )74};
#line 655 "y.tab.c"
static short const   yycheck___0[256]  = 
#line 655
  {      (short const   )0,      (short const   )3,      (short const   )4,      (short const   )32, 
        (short const   )18,      (short const   )7,      (short const   )8,      (short const   )50, 
        (short const   )10,      (short const   )9,      (short const   )12,      (short const   )3, 
        (short const   )18,      (short const   )0,      (short const   )14,      (short const   )7, 
        (short const   )48,      (short const   )75,      (short const   )18,      (short const   )9, 
        (short const   )20,      (short const   )35,      (short const   )80,      (short const   )23, 
        (short const   )14,      (short const   )18,      (short const   )18,      (short const   )17, 
        (short const   )4,      (short const   )87,      (short const   )11,      (short const   )18, 
        (short const   )32,      (short const   )14,      (short const   )48,      (short const   )25, 
        (short const   )12,      (short const   )13,      (short const   )14,      (short const   )15, 
        (short const   )16,      (short const   )48,      (short const   )48,      (short const   )45, 
        (short const   )46,      (short const   )38,      (short const   )0,      (short const   )13, 
        (short const   )11,      (short const   )49,      (short const   )93,      (short const   )11, 
        (short const   )31,      (short const   )31,      (short const   )11,      (short const   )48, 
        (short const   )48,      (short const   )48,      (short const   )9,      (short const   )117, 
        (short const   )26,      (short const   )27,      (short const   )64,      (short const   )14, 
        (short const   )12,      (short const   )13,      (short const   )17,      (short const   )15, 
        (short const   )16,      (short const   )11,      (short const   )44,      (short const   )129, 
        (short const   )47,      (short const   )131,      (short const   )25,      (short const   )75, 
        (short const   )78,      (short const   )14,      (short const   )11,      (short const   )81, 
        (short const   )80,      (short const   )10,      (short const   )21,      (short const   )126, 
        (short const   )35,      (short const   )19,      (short const   )48,      (short const   )87, 
        (short const   )146,      (short const   )10,      (short const   )48,      (short const   )44, 
        (short const   )23,      (short const   )11,      (short const   )94,      (short const   )44, 
        (short const   )98,      (short const   )44,      (short const   )11,      (short const   )26, 
        (short const   )10,      (short const   )67,      (short const   )68,      (short const   )69, 
        (short const   )70,      (short const   )71,      (short const   )72,      (short const   )73, 
        (short const   )74,      (short const   )47,      (short const   )76,      (short const   )77, 
        (short const   )47,      (short const   )11,      (short const   )143,      (short const   )47, 
        (short const   )120,      (short const   )117,      (short const   )90,      (short const   )47, 
        (short const   )122,      (short const   )47,      (short const   )47,      (short const   )125, 
        (short const   )4,      (short const   )5,      (short const   )6,      (short const   )49, 
        (short const   )116,      (short const   )129,      (short const   )-1,      (short const   )131, 
        (short const   )12,      (short const   )13,      (short const   )14,      (short const   )15, 
        (short const   )16,      (short const   )-1,      (short const   )-1,      (short const   )4, 
        (short const   )5,      (short const   )6,      (short const   )-1,      (short const   )143, 
        (short const   )-1,      (short const   )-1,      (short const   )146,      (short const   )12, 
        (short const   )13,      (short const   )14,      (short const   )15,      (short const   )16, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )4, 
        (short const   )5,      (short const   )6,      (short const   )-1,      (short const   )8, 
        (short const   )44,      (short const   )45,      (short const   )46,      (short const   )12, 
        (short const   )13,      (short const   )14,      (short const   )15,      (short const   )16, 
        (short const   )18,      (short const   )-1,      (short const   )20,      (short const   )-1, 
        (short const   )22,      (short const   )-1,      (short const   )24,      (short const   )44, 
        (short const   )45,      (short const   )46,      (short const   )28,      (short const   )29, 
        (short const   )-1,      (short const   )-1,      (short const   )32,      (short const   )33, 
        (short const   )-1,      (short const   )35,      (short const   )-1,      (short const   )-1, 
        (short const   )38,      (short const   )39,      (short const   )40,      (short const   )-1, 
        (short const   )-1,      (short const   )43,      (short const   )44,      (short const   )-1, 
        (short const   )45,      (short const   )46,      (short const   )48,      (short const   )18, 
        (short const   )-1,      (short const   )20,      (short const   )-1,      (short const   )22, 
        (short const   )-1,      (short const   )24,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )28,      (short const   )29,      (short const   )-1, 
        (short const   )-1,      (short const   )32,      (short const   )-1,      (short const   )-1, 
        (short const   )35,      (short const   )-1,      (short const   )-1,      (short const   )38, 
        (short const   )39,      (short const   )40,      (short const   )-1,      (short const   )27, 
        (short const   )43,      (short const   )44,      (short const   )30,      (short const   )-1, 
        (short const   )-1,      (short const   )48,      (short const   )34,      (short const   )-1, 
        (short const   )36,      (short const   )37,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )41,      (short const   )42,      (short const   )4, 
        (short const   )5,      (short const   )6,      (short const   )-1,      (short const   )-1, 
        (short const   )48,      (short const   )-1,      (short const   )-1,      (short const   )12, 
        (short const   )13,      (short const   )14,      (short const   )15,      (short const   )16};
#line 687 "y.tab.c"
static unsigned char const   yystos___0[154]  = 
#line 687
  {      (unsigned char const   )0,      (unsigned char const   )18,      (unsigned char const   )20,      (unsigned char const   )22, 
        (unsigned char const   )24,      (unsigned char const   )28,      (unsigned char const   )29,      (unsigned char const   )32, 
        (unsigned char const   )33,      (unsigned char const   )35,      (unsigned char const   )38,      (unsigned char const   )39, 
        (unsigned char const   )40,      (unsigned char const   )43,      (unsigned char const   )44,      (unsigned char const   )48, 
        (unsigned char const   )51,      (unsigned char const   )53,      (unsigned char const   )54,      (unsigned char const   )65, 
        (unsigned char const   )66,      (unsigned char const   )68,      (unsigned char const   )63,      (unsigned char const   )64, 
        (unsigned char const   )63,      (unsigned char const   )48,      (unsigned char const   )3,      (unsigned char const   )7, 
        (unsigned char const   )58,      (unsigned char const   )65,      (unsigned char const   )63,      (unsigned char const   )63, 
        (unsigned char const   )65,      (unsigned char const   )63,      (unsigned char const   )48,      (unsigned char const   )63, 
        (unsigned char const   )58,      (unsigned char const   )52,      (unsigned char const   )53,      (unsigned char const   )0, 
        (unsigned char const   )53,      (unsigned char const   )9,      (unsigned char const   )14,      (unsigned char const   )17, 
        (unsigned char const   )25,      (unsigned char const   )35,      (unsigned char const   )57,      (unsigned char const   )62, 
        (unsigned char const   )63,      (unsigned char const   )35,      (unsigned char const   )65,      (unsigned char const   )67, 
        (unsigned char const   )27,      (unsigned char const   )30,      (unsigned char const   )34,      (unsigned char const   )36, 
        (unsigned char const   )37,      (unsigned char const   )41,      (unsigned char const   )42,      (unsigned char const   )48, 
        (unsigned char const   )69,      (unsigned char const   )11,      (unsigned char const   )65,      (unsigned char const   )11, 
        (unsigned char const   )31,      (unsigned char const   )58,      (unsigned char const   )58,      (unsigned char const   )4, 
        (unsigned char const   )5,      (unsigned char const   )6,      (unsigned char const   )12,      (unsigned char const   )13, 
        (unsigned char const   )14,      (unsigned char const   )15,      (unsigned char const   )16,      (unsigned char const   )44, 
        (unsigned char const   )45,      (unsigned char const   )46,      (unsigned char const   )31,      (unsigned char const   )11, 
        (unsigned char const   )11,      (unsigned char const   )14,      (unsigned char const   )54,      (unsigned char const   )11, 
        (unsigned char const   )48,      (unsigned char const   )61,      (unsigned char const   )44,      (unsigned char const   )44, 
        (unsigned char const   )47,      (unsigned char const   )14,      (unsigned char const   )63,      (unsigned char const   )63, 
        (unsigned char const   )11,      (unsigned char const   )10,      (unsigned char const   )65,      (unsigned char const   )62, 
        (unsigned char const   )19,      (unsigned char const   )48,      (unsigned char const   )21,      (unsigned char const   )70, 
        (unsigned char const   )63,      (unsigned char const   )8,      (unsigned char const   )58,      (unsigned char const   )58, 
        (unsigned char const   )58,      (unsigned char const   )58,      (unsigned char const   )58,      (unsigned char const   )58, 
        (unsigned char const   )58,      (unsigned char const   )58,      (unsigned char const   )52,      (unsigned char const   )58, 
        (unsigned char const   )58,      (unsigned char const   )63,      (unsigned char const   )52,      (unsigned char const   )63, 
        (unsigned char const   )10,      (unsigned char const   )44,      (unsigned char const   )23,      (unsigned char const   )59, 
        (unsigned char const   )60,      (unsigned char const   )52,      (unsigned char const   )57,      (unsigned char const   )11, 
        (unsigned char const   )62,      (unsigned char const   )38,      (unsigned char const   )65,      (unsigned char const   )63, 
        (unsigned char const   )44,      (unsigned char const   )44,      (unsigned char const   )47,      (unsigned char const   )11, 
        (unsigned char const   )61,      (unsigned char const   )52,      (unsigned char const   )48,      (unsigned char const   )47, 
        (unsigned char const   )59,      (unsigned char const   )47,      (unsigned char const   )63,      (unsigned char const   )63, 
        (unsigned char const   )62,      (unsigned char const   )55,      (unsigned char const   )52,      (unsigned char const   )26, 
        (unsigned char const   )52,      (unsigned char const   )47,      (unsigned char const   )10,      (unsigned char const   )11, 
        (unsigned char const   )49,      (unsigned char const   )47,      (unsigned char const   )54,      (unsigned char const   )52, 
        (unsigned char const   )56,      (unsigned char const   )47};
#line 1054 "y.tab.c"
static void yydestruct___0(char const   *yymsg , int yytype , YYSYMBOL *yyvaluep ) 
{ 


  {
#line 1067
  if (! yymsg) {
#line 1068
    yymsg = "Deleting";
  }
  {
#line 1074
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1075
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1077
  return;
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/parse.c"
static PARSE *yypsave  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/parse.c"
void parse_file(char const   *f ) 
{ 
  LOL l ;
  PARSE *p ;
  int jmp ;
  int tmp ;
  LIST *tmp___0 ;

  {
  {
#line 32
  yyfparse(f);
  }
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 42
    jmp = 0;
#line 46
    lol_init(& l);
#line 50
    yypsave = (PARSE *)0;
#line 54
    tmp = yyparse();
    }
#line 54
    if (tmp) {
#line 55
      goto while_break;
    } else {
#line 54
      p = yypsave;
#line 54
      if (! p) {
#line 55
        goto while_break;
      }
    }
    {
#line 59
    tmp___0 = (*(p->func))(p, & l, & jmp);
#line 59
    list_free(tmp___0);
#line 61
    parse_free(p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 63
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/parse.c"
void parse_save(PARSE *p ) 
{ 


  {
#line 68
  yypsave = p;
#line 69
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/parse.c"
PARSE *parse_make(LIST *(*func)(PARSE *p , LOL *args , int *jmp ) , PARSE *left ,
                  PARSE *right , PARSE *third , char const   *string , char const   *string1 ,
                  int num ) 
{ 
  PARSE *p ;
  void *tmp ;

  {
  {
#line 81
  tmp = malloc(sizeof(PARSE ));
#line 81
  p = (PARSE *)tmp;
#line 83
  p->func = func;
#line 84
  p->left = left;
#line 85
  p->right = right;
#line 86
  p->third = third;
#line 87
  p->string = string;
#line 88
  p->string1 = string1;
#line 89
  p->num = num;
#line 90
  p->refs = 1;
  }
#line 92
  return (p);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/parse.c"
void parse_refer(PARSE *p ) 
{ 


  {
#line 98
  (p->refs) ++;
#line 99
  return;
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/parse.c"
void parse_free(PARSE *p ) 
{ 


  {
#line 104
  (p->refs) --;
#line 104
  if (p->refs) {
#line 105
    return;
  }
#line 107
  if (p->string) {
    {
#line 108
    freestr(p->string);
    }
  }
#line 109
  if (p->string1) {
    {
#line 110
    freestr(p->string1);
    }
  }
#line 111
  if (p->left) {
    {
#line 112
    parse_free(p->left);
    }
  }
#line 113
  if (p->right) {
    {
#line 114
    parse_free(p->right);
    }
  }
#line 115
  if (p->third) {
    {
#line 116
    parse_free(p->third);
    }
  }
  {
#line 118
  free((void *)((char *)p));
  }
#line 119
  return;
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/expand.c"
static void var_edit_parse___0(char const   *mods , VAR_EDITS *edits ) ;
#line 51
static void var_edit_file___0(char const   *in , char *out , VAR_EDITS *edits ) ;
#line 52
static void var_edit_shift___0(char *out , VAR_EDITS *edits ) ;
#line 53
static void var_edit_quote___0(char *out ) ;
#line 393 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/expand.c"
static void var_edit_parse___0(char const   *mods , VAR_EDITS *edits ) 
{ 
  int havezeroed ;
  char *p ;
  PATHPART *fp ;
  char const   *tmp ;
  char tmp___0 ;
  int i ;
  int tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 398
  havezeroed = 0;
#line 399
  memset((void *)((char *)edits), 0, sizeof(*edits));
  }
  {
#line 401
  while (1) {
    while_continue: /* CIL Label */ ;
#line 401
    if (! *mods) {
#line 401
      goto while_break;
    }
#line 406
    tmp = mods;
#line 406
    mods ++;
    {
#line 408
    if ((int const   )*tmp == 76) {
#line 408
      goto case_76;
    }
#line 409
    if ((int const   )*tmp == 85) {
#line 409
      goto case_85;
    }
#line 410
    if ((int const   )*tmp == 81) {
#line 410
      goto case_81;
    }
#line 411
    if ((int const   )*tmp == 80) {
#line 411
      goto case_80;
    }
#line 412
    if ((int const   )*tmp == 69) {
#line 412
      goto case_69;
    }
#line 413
    if ((int const   )*tmp == 74) {
#line 413
      goto case_74;
    }
#line 414
    if ((int const   )*tmp == 71) {
#line 414
      goto case_71;
    }
#line 415
    if ((int const   )*tmp == 82) {
#line 415
      goto case_82;
    }
#line 416
    if ((int const   )*tmp == 68) {
#line 416
      goto case_68;
    }
#line 417
    if ((int const   )*tmp == 66) {
#line 417
      goto case_66;
    }
#line 418
    if ((int const   )*tmp == 83) {
#line 418
      goto case_83;
    }
#line 419
    if ((int const   )*tmp == 77) {
#line 419
      goto case_77;
    }
#line 421
    goto switch_default;
    case_76: /* CIL Label */ 
#line 408
    edits->downshift = (char)1;
#line 408
    goto while_continue;
    case_85: /* CIL Label */ 
#line 409
    edits->upshift = (char)1;
#line 409
    goto while_continue;
    case_81: /* CIL Label */ 
#line 410
    edits->quote = (char)1;
#line 410
    goto while_continue;
    case_80: /* CIL Label */ 
#line 411
    tmp___0 = (char)1;
#line 411
    edits->filemods = tmp___0;
#line 411
    edits->parent = tmp___0;
#line 411
    goto while_continue;
    case_69: /* CIL Label */ 
#line 412
    fp = & edits->empty;
#line 412
    goto strval;
    case_74: /* CIL Label */ 
#line 413
    fp = & edits->join;
#line 413
    goto strval;
    case_71: /* CIL Label */ 
#line 414
    fp = & edits->f.part[0];
#line 414
    goto fileval;
    case_82: /* CIL Label */ 
#line 415
    fp = & edits->f.part[1];
#line 415
    goto fileval;
    case_68: /* CIL Label */ 
#line 416
    fp = & edits->f.part[2];
#line 416
    goto fileval;
    case_66: /* CIL Label */ 
#line 417
    fp = & edits->f.part[3];
#line 417
    goto fileval;
    case_83: /* CIL Label */ 
#line 418
    fp = & edits->f.part[4];
#line 418
    goto fileval;
    case_77: /* CIL Label */ 
#line 419
    fp = & edits->f.part[5];
#line 419
    goto fileval;
    switch_default: /* CIL Label */ 
#line 421
    return;
    switch_break: /* CIL Label */ ;
    }
    fileval: 
#line 431
    edits->filemods = (char)1;
#line 433
    if ((int const   )*mods != 61) {
#line 437
      tmp___1 = havezeroed;
#line 437
      havezeroed ++;
#line 437
      if (! tmp___1) {
#line 438
        i = 0;
        {
#line 438
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 438
          if (! (i < 6)) {
#line 438
            goto while_break___0;
          }
#line 440
          edits->f.part[i].len = 0;
#line 441
          edits->f.part[i].ptr = "";
#line 438
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 444
      fp->ptr = (char const   *)0;
#line 445
      goto while_continue;
    }
    strval: 
#line 452
    if ((int const   )*mods != 61) {
#line 454
      fp->ptr = "";
#line 455
      fp->len = 0;
    } else {
      {
#line 457
      p = strchr(mods, '\001');
      }
#line 457
      if (p) {
#line 459
        *p = (char)0;
#line 460
        mods ++;
#line 460
        fp->ptr = mods;
#line 461
        fp->len = (int )(p - (char *)mods);
#line 462
        mods = (char const   *)(p + 1);
      } else {
        {
#line 466
        mods ++;
#line 466
        fp->ptr = mods;
#line 467
        tmp___2 = strlen(mods);
#line 467
        fp->len = (int )tmp___2;
#line 468
        mods += fp->len;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 471
  return;
}
}
#line 477 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/expand.c"
static void var_edit_file___0(char const   *in , char *out , VAR_EDITS *edits ) 
{ 
  PATHNAME pathname ;

  {
  {
#line 487
  path_parse(in, & pathname);
  }
#line 491
  if (edits->f.part[0].ptr) {
#line 492
    pathname.part[0] = edits->f.part[0];
  }
#line 494
  if (edits->f.part[1].ptr) {
#line 495
    pathname.part[1] = edits->f.part[1];
  }
#line 497
  if (edits->f.part[2].ptr) {
#line 498
    pathname.part[2] = edits->f.part[2];
  }
#line 500
  if (edits->f.part[3].ptr) {
#line 501
    pathname.part[3] = edits->f.part[3];
  }
#line 503
  if (edits->f.part[4].ptr) {
#line 504
    pathname.part[4] = edits->f.part[4];
  }
#line 506
  if (edits->f.part[5].ptr) {
#line 507
    pathname.part[5] = edits->f.part[5];
  }
#line 511
  if (edits->parent) {
    {
#line 512
    path_parent(& pathname);
    }
  }
  {
#line 516
  path_build(& pathname, out, 0);
  }
#line 517
  return;
}
}
#line 523 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/expand.c"
static void var_edit_shift___0(char *out , VAR_EDITS *edits ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 530
  if (edits->upshift) {
    {
#line 532
    while (1) {
      while_continue: /* CIL Label */ ;
#line 532
      if (! *out) {
#line 532
        goto while_break;
      }
      {
#line 533
      tmp = toupper((int )*out);
#line 533
      *out = (char )tmp;
#line 532
      out ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 535
  if (edits->downshift) {
    {
#line 537
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 537
      if (! *out) {
#line 537
        goto while_break___0;
      }
      {
#line 538
      tmp___0 = tolower((int )*out);
#line 538
      *out = (char )tmp___0;
#line 537
      out ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 540
  return;
}
}
#line 543 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/expand.c"
static void var_edit_quote___0(char *out ) 
{ 
  int count ;
  char *p ;
  char *q ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 548
  p = out;
#line 551
  count = 0;
#line 552
  p = out;
  {
#line 552
  while (1) {
    while_continue: /* CIL Label */ ;
#line 552
    if (! *p) {
#line 552
      goto while_break;
    }
#line 553
    if ((int )*p == 92) {
#line 554
      count ++;
    }
#line 552
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 556
  q = p + count;
  {
#line 558
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 558
    if (! ((unsigned long )p >= (unsigned long )out)) {
#line 558
      goto while_break___0;
    }
#line 560
    if ((int )*p == 92) {
#line 562
      tmp = q;
#line 562
      q --;
#line 562
      tmp___0 = p;
#line 562
      p --;
#line 562
      *tmp = *tmp___0;
#line 563
      tmp___1 = q;
#line 563
      q --;
#line 563
      *tmp___1 = (char )'\\';
    } else {
#line 566
      tmp___2 = q;
#line 566
      q --;
#line 566
      tmp___3 = p;
#line 566
      p --;
#line 566
      *tmp___2 = *tmp___3;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 568
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/make1.c"
static void make1a___0(TARGET *t , TARGET *parent ) ;
#line 66
static void make1b___0(TARGET *t ) ;
#line 67
static void make1c___0(TARGET *t ) ;
#line 68
static void make1d___0(void *closure , int status ) ;
#line 70
static CMD *make1cmds___0(ACTIONS *a0 ) ;
#line 71
static LIST *make1list___0(LIST *l , TARGETS *targets , int flags ) ;
#line 72
static SETTINGS *make1settings___0(LIST *vars ) ;
#line 73
static void make1bind___0(TARGET *t , int warn ) ;
#line 77 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/make1.c"
static struct __anonstruct_counts_50___0 counts___0[1]  ;
#line 88 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/make1.c"
static int intr___1  =    0;
#line 122 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/make1.c"
static void make1a___0(TARGET *t , TARGET *parent ) 
{ 
  TARGETS *c ;

  {
#line 133
  if (parent) {
    {
#line 138
    if ((int )t->progress == 3) {
#line 138
      goto case_3;
    }
#line 138
    if ((int )t->progress == 2) {
#line 138
      goto case_3;
    }
#line 138
    if ((int )t->progress == 0) {
#line 138
      goto case_3;
    }
#line 134
    goto switch_break;
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
    case_0: /* CIL Label */ 
    {
#line 139
    t->parents = targetentry(t->parents, parent);
#line 140
    (parent->asynccnt) ++;
    }
    switch_break: /* CIL Label */ ;
    }
  }
#line 143
  if ((int )t->progress != 0) {
#line 144
    return;
  }
#line 152
  t->asynccnt = 1;
#line 157
  t->progress = (char)1;
#line 159
  c = t->depends;
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 159
    if (c) {
#line 159
      if (! (! intr___1)) {
#line 159
        goto while_break;
      }
    } else {
#line 159
      goto while_break;
    }
    {
#line 160
    make1a___0(c->target, t);
#line 159
    c = c->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 162
  t->progress = (char)2;
#line 167
  make1b___0(t);
  }
#line 168
  return;
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/make1.c"
static void make1b___0(TARGET *t ) 
{ 
  TARGETS *c ;
  char const   *failed ;
  CMD *tmp ;

  {
#line 178
  failed = "dependents";
#line 183
  (t->asynccnt) --;
#line 183
  if (t->asynccnt) {
#line 184
    return;
  }
#line 190
  c = t->depends;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    if (! c) {
#line 190
      goto while_break;
    }
#line 191
    if ((int )(c->target)->status > (int )t->status) {
#line 193
      failed = (c->target)->name;
#line 194
      t->status = (c->target)->status;
    }
#line 190
    c = c->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 200
  if ((int )t->status == 1) {
#line 200
    if (t->actions) {
      {
#line 202
      (counts___0[0].skipped) ++;
#line 203
      printf((char const   */* __restrict  */)"...skipped %s for lack of %s...\n",
             t->name, failed);
      }
    }
  }
#line 206
  if ((int )t->status == 0) {
    {
#line 214
    if ((int )t->fate == 3) {
#line 214
      goto case_3;
    }
#line 214
    if ((int )t->fate == 2) {
#line 214
      goto case_3;
    }
#line 214
    if ((int )t->fate == 1) {
#line 214
      goto case_3;
    }
#line 214
    if ((int )t->fate == 0) {
#line 214
      goto case_3;
    }
#line 218
    if ((int )t->fate == 11) {
#line 218
      goto case_11;
    }
#line 218
    if ((int )t->fate == 10) {
#line 218
      goto case_11;
    }
#line 222
    if ((int )t->fate == 4) {
#line 222
      goto case_4;
    }
#line 231
    if ((int )t->fate == 9) {
#line 231
      goto case_9;
    }
#line 231
    if ((int )t->fate == 8) {
#line 231
      goto case_9;
    }
#line 231
    if ((int )t->fate == 7) {
#line 231
      goto case_9;
    }
#line 231
    if ((int )t->fate == 6) {
#line 231
      goto case_9;
    }
#line 231
    if ((int )t->fate == 5) {
#line 231
      goto case_9;
    }
#line 207
    goto switch_break;
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 215
    goto switch_break;
    case_11: /* CIL Label */ 
    case_10: /* CIL Label */ 
#line 219
    t->status = (char)1;
#line 220
    goto switch_break;
    case_4: /* CIL Label */ 
#line 223
    if (globs.debug[11]) {
      {
#line 224
      printf((char const   */* __restrict  */)"...using %s...\n", t->name);
      }
    }
#line 225
    goto switch_break;
    case_9: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
    case_5: /* CIL Label */ 
#line 236
    if (t->actions) {
#line 238
      (counts___0[0].total) ++;
#line 240
      if (globs.debug[1]) {
#line 240
        if (! (counts___0[0].total % 100)) {
          {
#line 241
          printf((char const   */* __restrict  */)"...on %dth target...\n", counts___0[0].total);
          }
        }
      }
      {
#line 243
      pushsettings(t->settings);
#line 244
      tmp = make1cmds___0(t->actions);
#line 244
      t->cmds = (char *)tmp;
#line 245
      popsettings(t->settings);
#line 247
      t->progress = (char)3;
      }
    }
#line 250
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 259
  make1c___0(t);
  }
#line 260
  return;
}
}
#line 266 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/make1.c"
static void make1c___0(TARGET *t ) 
{ 
  CMD *cmd ;
  LIST *tmp ;
  TARGETS *c ;
  ACTIONS *actions ;

  {
#line 269
  cmd = (CMD *)t->cmds;
#line 279
  if (cmd) {
#line 279
    if ((int )t->status == 0) {
#line 281
      if (globs.debug[1]) {
#line 282
        if (globs.debug[11]) {
          {
#line 284
          printf((char const   */* __restrict  */)"%s ", (cmd->rule)->name);
#line 285
          tmp = lol_get(& cmd->args, 0);
#line 285
          list_print(tmp);
#line 286
          printf((char const   */* __restrict  */)"\n");
          }
        } else
#line 282
        if (! ((cmd->rule)->flags & 8)) {
          {
#line 284
          printf((char const   */* __restrict  */)"%s ", (cmd->rule)->name);
#line 285
          tmp = lol_get(& cmd->args, 0);
#line 285
          list_print(tmp);
#line 286
          printf((char const   */* __restrict  */)"\n");
          }
        }
      }
#line 289
      if (globs.debug[12]) {
        {
#line 290
        printf((char const   */* __restrict  */)"%s\n", cmd->buf);
        }
      }
#line 292
      if (globs.cmdout) {
        {
#line 293
        fprintf((FILE */* __restrict  */)globs.cmdout, (char const   */* __restrict  */)"%s",
                cmd->buf);
        }
      }
#line 295
      if (globs.noexec) {
        {
#line 297
        make1d___0((void *)t, 0);
        }
      } else {
        {
#line 301
        fflush(stdout);
#line 302
        execcmd(cmd->buf, & make1d___0, (void *)t, cmd->shell);
        }
      }
    } else {
#line 279
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 312
    actions = t->actions;
    {
#line 312
    while (1) {
      while_continue: /* CIL Label */ ;
#line 312
      if (! actions) {
#line 312
        goto while_break;
      }
#line 313
      if ((int )(actions->action)->status > (int )t->status) {
#line 314
        t->status = (actions->action)->status;
      }
#line 312
      actions = actions->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 316
    actions = t->actions;
    {
#line 316
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 316
      if (! actions) {
#line 316
        goto while_break___0;
      }
#line 317
      if ((int )t->status > (int )(actions->action)->status) {
#line 318
        (actions->action)->status = t->status;
      }
#line 316
      actions = actions->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 322
    if ((int )t->progress == 3) {
      {
#line 325
      if ((int )t->status == 0) {
#line 325
        goto case_0;
      }
#line 328
      if ((int )t->status == 1) {
#line 328
        goto case_1;
      }
#line 323
      goto switch_break;
      case_0: /* CIL Label */ 
#line 326
      (counts___0[0].made) ++;
#line 327
      goto switch_break;
      case_1: /* CIL Label */ 
#line 329
      (counts___0[0].failed) ++;
#line 330
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 335
    t->progress = (char)4;
#line 337
    c = t->parents;
    {
#line 337
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 337
      if (! c) {
#line 337
        goto while_break___1;
      }
      {
#line 338
      make1b___0(c->target);
#line 337
      c = c->next;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 340
  return;
}
}
#line 346 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/make1.c"
static void make1d___0(void *closure , int status ) 
{ 
  TARGET *t ;
  CMD *cmd ;
  LIST *tmp ;
  LIST *targets ;
  LIST *tmp___0 ;
  int tmp___1 ;

  {
#line 351
  t = (TARGET *)closure;
#line 352
  cmd = (CMD *)t->cmds;
#line 358
  if (status == 1) {
#line 358
    if ((cmd->rule)->flags & 4) {
#line 359
      status = 0;
    }
  }
#line 363
  if (status == 2) {
#line 364
    intr___1 ++;
  }
#line 366
  if (status == 1) {
#line 366
    if (globs.debug[1]) {
#line 370
      if (! globs.debug[12]) {
        {
#line 371
        printf((char const   */* __restrict  */)"%s\n", cmd->buf);
        }
      }
      {
#line 373
      printf((char const   */* __restrict  */)"...failed %s ", (cmd->rule)->name);
#line 374
      tmp = lol_get(& cmd->args, 0);
#line 374
      list_print(tmp);
#line 375
      printf((char const   */* __restrict  */)"...\n");
      }
#line 377
      if (globs.quitquick) {
#line 377
        intr___1 ++;
      }
    }
  }
#line 384
  if (status != 0) {
#line 384
    if (! ((cmd->rule)->flags & 1)) {
      {
#line 386
      tmp___0 = lol_get(& cmd->args, 0);
#line 386
      targets = tmp___0;
      }
      {
#line 388
      while (1) {
        while_continue: /* CIL Label */ ;
#line 388
        if (! targets) {
#line 388
          goto while_break;
        }
        {
#line 389
        tmp___1 = unlink(targets->string);
        }
#line 389
        if (! tmp___1) {
          {
#line 390
          printf((char const   */* __restrict  */)"...removing %s\n", targets->string);
          }
        }
#line 388
        targets = targets->next;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 395
  t->status = (char )status;
#line 396
  t->cmds = (char *)cmd->next;
#line 398
  cmd_free(cmd);
#line 400
  make1c___0(t);
  }
#line 401
  return;
}
}
#line 413 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/make1.c"
static CMD *make1cmds___0(ACTIONS *a0 ) 
{ 
  CMD *cmds ;
  LIST *shell ;
  LIST *tmp ;
  RULE *rule ;
  SETTINGS *boundvars ;
  LIST *nt ;
  LIST *ns ;
  ACTIONS *a1 ;
  int start ;
  int chunk ;
  int length ;
  int maxline ;
  CMD *cmd___0 ;
  LIST *tmp___0 ;
  LIST *tmp___1 ;
  LIST *tmp___2 ;
  CMD *tmp___3 ;

  {
  {
#line 416
  cmds = (CMD *)0;
#line 417
  tmp = var_get("JAMSHELL");
#line 417
  shell = tmp;
  }
  {
#line 423
  while (1) {
    while_continue: /* CIL Label */ ;
#line 423
    if (! a0) {
#line 423
      goto while_break;
    }
#line 425
    rule = (a0->action)->rule;
#line 435
    if (! rule->actions) {
#line 436
      goto __Cont;
    } else
#line 435
    if ((a0->action)->running) {
#line 436
      goto __Cont;
    }
    {
#line 438
    (a0->action)->running = (char)1;
#line 444
    nt = make1list___0((LIST *)0, (a0->action)->targets, 0);
#line 445
    ns = make1list___0((LIST *)0, (a0->action)->sources, rule->flags);
    }
#line 447
    if (rule->flags & 2) {
#line 448
      a1 = a0->next;
      {
#line 448
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 448
        if (! a1) {
#line 448
          goto while_break___0;
        }
#line 449
        if ((unsigned long )(a1->action)->rule == (unsigned long )rule) {
#line 449
          if (! (a1->action)->running) {
            {
#line 451
            ns = make1list___0(ns, (a1->action)->sources, rule->flags);
#line 452
            (a1->action)->running = (char)1;
            }
          }
        }
#line 448
        a1 = a1->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 458
    if (! ns) {
#line 458
      if (rule->flags & 33) {
        {
#line 460
        list_free(nt);
        }
#line 461
        goto __Cont;
      }
    }
    {
#line 466
    boundvars = make1settings___0(rule->bindlist);
#line 467
    pushsettings(boundvars);
#line 489
    start = 0;
#line 490
    length = list_length(ns);
#line 490
    chunk = length;
#line 491
    maxline = rule->flags / 64;
    }
#line 492
    if (maxline) {
#line 492
      if (maxline < 10240) {
#line 492
        maxline = maxline;
      } else {
#line 492
        maxline = 10240;
      }
    } else {
#line 492
      maxline = 10240;
    }
    {
#line 494
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 498
      tmp___0 = list_copy((LIST *)0, shell);
#line 498
      tmp___1 = list_sublist(ns, start, chunk);
#line 498
      tmp___2 = list_copy((LIST *)0, nt);
#line 498
      tmp___3 = cmd_new(rule, tmp___2, tmp___1, tmp___0, maxline);
#line 498
      cmd___0 = tmp___3;
      }
#line 504
      if (cmd___0) {
#line 508
        if (! cmds) {
#line 508
          cmds = cmd___0;
        } else {
#line 509
          (cmds->tail)->next = cmd___0;
        }
#line 510
        cmds->tail = cmd___0;
#line 511
        start += chunk;
      } else
#line 513
      if (rule->flags & 16) {
#line 513
        if (chunk > 1) {
#line 517
          chunk = (chunk * 9) / 10;
        } else {
          {
#line 523
          printf((char const   */* __restrict  */)"%s actions too long (max %d)!\n",
                 rule->name, maxline);
#line 525
          exit(1);
          }
        }
      } else {
        {
#line 523
        printf((char const   */* __restrict  */)"%s actions too long (max %d)!\n",
               rule->name, maxline);
#line 525
        exit(1);
        }
      }
#line 494
      if (! (start < length)) {
#line 494
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 532
    list_free(nt);
#line 533
    list_free(ns);
#line 538
    popsettings(boundvars);
#line 539
    freesettings(boundvars);
    }
    __Cont: /* CIL Label */ 
#line 423
    a0 = a0->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 542
  return (cmds);
}
}
#line 549 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/make1.c"
static LIST *make1list___0(LIST *l , TARGETS *targets , int flags ) 
{ 
  TARGET *t ;
  LIST *m ;
  int tmp ;

  {
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    if (! targets) {
#line 555
      goto while_break;
    }
#line 557
    t = targets->target;
#line 564
    if ((int )t->binding == 0) {
      {
#line 565
      make1bind___0(t, ! (flags & 32));
      }
    }
#line 567
    if (flags & 32) {
#line 567
      if ((int )t->binding != 3) {
#line 568
        goto __Cont;
      }
    }
#line 570
    if (flags & 1) {
#line 570
      if ((int )t->fate <= 2) {
#line 571
        goto __Cont;
      }
    }
#line 575
    if (flags & 2) {
#line 579
      m = l;
      {
#line 579
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 579
        if (! m) {
#line 579
          goto while_break___0;
        }
        {
#line 580
        tmp = strcmp(m->string, t->boundname);
        }
#line 580
        if (! tmp) {
#line 581
          goto while_break___0;
        }
#line 579
        m = m->next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 583
      if (m) {
#line 584
        goto __Cont;
      }
    }
    {
#line 589
    l = list_new(l, t->boundname, 1);
    }
    __Cont: /* CIL Label */ 
#line 555
    targets = targets->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 592
  return (l);
}
}
#line 599 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/make1.c"
static SETTINGS *make1settings___0(LIST *vars ) 
{ 
  SETTINGS *settings ;
  LIST *l ;
  LIST *tmp ;
  LIST *nl ;
  TARGET *t ;
  TARGET *tmp___0 ;

  {
#line 602
  settings = (SETTINGS *)0;
  {
#line 604
  while (1) {
    while_continue: /* CIL Label */ ;
#line 604
    if (! vars) {
#line 604
      goto while_break;
    }
    {
#line 606
    tmp = var_get(vars->string);
#line 606
    l = tmp;
#line 607
    nl = (LIST *)0;
    }
    {
#line 609
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 609
      if (! l) {
#line 609
        goto while_break___0;
      }
      {
#line 611
      tmp___0 = bindtarget(l->string);
#line 611
      t = tmp___0;
      }
#line 616
      if ((int )t->binding == 0) {
        {
#line 617
        make1bind___0(t, 1);
        }
      }
      {
#line 621
      nl = list_new(nl, t->boundname, 1);
#line 609
      l = l->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 626
    settings = addsettings(settings, 0, vars->string, nl);
#line 604
    vars = vars->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 629
  return (settings);
}
}
#line 639 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/make1.c"
static void make1bind___0(TARGET *t , int warn ) 
{ 


  {
#line 644
  if ((int )t->flags & 4) {
#line 645
    return;
  }
#line 652
  if (warn) {
    {
#line 653
    printf((char const   */* __restrict  */)"warning: using independent target %s\n",
           t->name);
    }
  }
  {
#line 655
  pushsettings(t->settings);
#line 656
  t->boundname = search(t->name, & t->time);
  }
#line 657
  if (t->time) {
#line 657
    t->binding = (char)3;
  } else {
#line 657
    t->binding = (char)1;
  }
  {
#line 658
  popsettings(t->settings);
  }
#line 659
  return;
}
}
#line 11 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/timestamp.h"
void timestamp(char *target , time_t *time___0 ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/timestamp.c"
static struct hash *bindhash  =    (struct hash *)0;
#line 46
static void time_enter(void *closure , char const   *target , int found , time_t time___0 ) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/timestamp.c"
static char const   *time_progress[5]  = {      "INIT",      "NOENTRY",      "SPOTTED",      "MISSING", 
        "FOUND"};
#line 62 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/timestamp.c"
void timestamp(char *target , time_t *time___0 ) 
{ 
  PATHNAME f1 ;
  PATHNAME f2 ;
  BINDING binding ;
  BINDING *b ;
  char buf___0[1024] ;
  short tmp ;
  int tmp___0 ;
  BINDING binding___0 ;
  BINDING *b___0 ;
  short tmp___1 ;
  int tmp___2 ;
  BINDING binding___1 ;
  BINDING *b___1 ;
  short tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 68
  b = & binding;
#line 81
  if (! bindhash) {
    {
#line 82
    bindhash = hashinit((int )sizeof(BINDING ), "bindings");
    }
  }
  {
#line 86
  b->name = (char const   *)target;
#line 87
  tmp = (short)0;
#line 87
  b->flags = tmp;
#line 87
  b->time = (time_t )tmp;
#line 88
  b->progress = (short)0;
#line 90
  tmp___0 = hashitem(bindhash, (HASHDATA **)(& b), 1);
  }
#line 90
  if (! tmp___0) {
    {
#line 91
    b->name = newstr((char const   *)target);
    }
  }
#line 93
  if ((int )b->progress != 0) {
#line 94
    goto afterscanning;
  }
  {
#line 96
  b->progress = (short)1;
#line 100
  path_parse((char const   *)target, & f1);
#line 105
  b___0 = & binding___0;
#line 107
  f2 = f1;
#line 108
  f2.part[0].len = 0;
#line 109
  path_parent(& f2);
#line 110
  path_build(& f2, buf___0, 0);
#line 112
  b___0->name = (char const   *)(buf___0);
#line 113
  tmp___1 = (short)0;
#line 113
  b___0->flags = tmp___1;
#line 113
  b___0->time = (time_t )tmp___1;
#line 114
  b___0->progress = (short)0;
#line 116
  tmp___2 = hashitem(bindhash, (HASHDATA **)(& b___0), 1);
  }
#line 116
  if (! tmp___2) {
    {
#line 117
    b___0->name = newstr((char const   *)(buf___0));
    }
  }
#line 119
  if (! ((int )b___0->flags & 1)) {
    {
#line 121
    file_dirscan((char const   *)(buf___0), & time_enter, (void *)bindhash);
#line 122
    b___0->flags = (short )((int )b___0->flags | 1);
    }
  }
#line 128
  if (f1.part[5].len) {
    {
#line 130
    b___1 = & binding___1;
#line 132
    f2 = f1;
#line 133
    f2.part[0].len = 0;
#line 134
    f2.part[5].len = 0;
#line 135
    path_build(& f2, buf___0, 0);
#line 137
    b___1->name = (char const   *)(buf___0);
#line 138
    tmp___3 = (short)0;
#line 138
    b___1->flags = tmp___3;
#line 138
    b___1->time = (time_t )tmp___3;
#line 139
    b___1->progress = (short)0;
#line 141
    tmp___4 = hashitem(bindhash, (HASHDATA **)(& b___1), 1);
    }
#line 141
    if (! tmp___4) {
      {
#line 142
      b___1->name = newstr((char const   *)(buf___0));
      }
    }
#line 144
    if (! ((int )b___1->flags & 1)) {
      {
#line 146
      file_archscan((char const   *)(buf___0), & time_enter, (void *)bindhash);
#line 147
      b___1->flags = (short )((int )b___1->flags | 1);
      }
    }
  }
  afterscanning: 
#line 153
  if ((int )b->progress == 2) {
    {
#line 155
    tmp___5 = file_time(b->name, & b->time);
    }
#line 155
    if (tmp___5 < 0) {
#line 156
      b->progress = (short)3;
    } else {
#line 158
      b->progress = (short)4;
    }
  }
#line 161
  if ((int )b->progress == 4) {
#line 161
    *time___0 = b->time;
  } else {
#line 161
    *time___0 = (time_t )0;
  }
#line 162
  return;
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/timestamp.c"
static void time_enter(void *closure , char const   *target , int found , time_t time___0 ) 
{ 
  BINDING binding ;
  BINDING *b ;
  struct hash *bindhash___0 ;
  int tmp ;

  {
  {
#line 171
  b = & binding;
#line 172
  bindhash___0 = (struct hash *)closure;
#line 184
  b->name = target;
#line 185
  b->flags = (short)0;
#line 187
  tmp = hashitem(bindhash___0, (HASHDATA **)(& b), 1);
  }
#line 187
  if (! tmp) {
    {
#line 188
    b->name = newstr(target);
    }
  }
#line 190
  b->time = time___0;
#line 191
  if (found) {
#line 191
    b->progress = (short)4;
  } else {
#line 191
    b->progress = (short)2;
  }
#line 193
  if (globs.debug[6]) {
    {
#line 194
    printf((char const   */* __restrict  */)"time ( %s ) : %s\n", target, time_progress[b->progress]);
    }
  }
#line 195
  return;
}
}
#line 201 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/timestamp.c"
void donestamps(void) 
{ 


  {
  {
#line 204
  hashdone(bindhash);
  }
#line 205
  return;
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/hash.c"
static void hashrehash___0(struct hash *hp ) ;
#line 85
static void hashstat___0(struct hash *hp ) ;
#line 142 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/hash.c"
static void hashrehash___0(struct hash *hp ) 
{ 
  int i ;
  void *tmp ;
  void *tmp___0 ;
  int nel ;
  char *next ;
  register ITEM *i___0 ;
  ITEM **ip ;
  int tmp___1 ;

  {
#line 144
  (hp->items.list) ++;
#line 144
  i = hp->items.list;
#line 146
  if (i) {
#line 146
    hp->items.more = 2 * hp->items.nel;
  } else {
#line 146
    hp->items.more = hp->inel;
  }
  {
#line 147
  tmp = malloc((size_t )(hp->items.more * hp->items.size));
#line 147
  hp->items.next = (char *)tmp;
#line 149
  hp->items.lists[i].nel = hp->items.more;
#line 150
  hp->items.lists[i].base = hp->items.next;
#line 151
  hp->items.nel += hp->items.more;
  }
#line 153
  if (hp->tab.base) {
    {
#line 154
    free((void *)((char *)hp->tab.base));
    }
  }
  {
#line 156
  hp->tab.nel = hp->items.nel * hp->bloat;
#line 157
  tmp___0 = malloc((unsigned long )hp->tab.nel * sizeof(ITEM **));
#line 157
  hp->tab.base = (ITEM **)tmp___0;
#line 159
  memset((void *)((char *)hp->tab.base), '\000', (unsigned long )hp->tab.nel * sizeof(ITEM *));
#line 161
  i = 0;
  }
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    if (! (i < hp->items.list)) {
#line 161
      goto while_break;
    }
#line 163
    nel = hp->items.lists[i].nel;
#line 164
    next = hp->items.lists[i].base;
    {
#line 166
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 166
      tmp___1 = nel;
#line 166
      nel --;
#line 166
      if (! tmp___1) {
#line 166
        goto while_break___0;
      }
#line 168
      i___0 = (ITEM *)next;
#line 169
      ip = hp->tab.base + i___0->hdr.keyval % (unsigned int )hp->tab.nel;
#line 171
      i___0->hdr.next = *ip;
#line 172
      *ip = i___0;
#line 166
      next += hp->items.size;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 161
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  return;
}
}
#line 230 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/hash.c"
static void hashstat___0(struct hash *hp ) 
{ 
  ITEM **tab ;
  int nel ;
  int count ;
  int sets ;
  int run ;
  int i ;
  int here ;
  ITEM **tmp ;

  {
#line 233
  tab = hp->tab.base;
#line 234
  nel = hp->tab.nel;
#line 235
  count = 0;
#line 236
  sets = 0;
#line 237
  run = (unsigned long )*(tab + (nel - 1)) != (unsigned long )((ITEM *)0);
#line 240
  i = nel;
  {
#line 240
  while (1) {
    while_continue: /* CIL Label */ ;
#line 240
    if (! (i > 0)) {
#line 240
      goto while_break;
    }
#line 242
    tmp = tab;
#line 242
    tab ++;
#line 242
    here = (unsigned long )*tmp != (unsigned long )((ITEM *)0);
#line 242
    if (here) {
#line 243
      count ++;
    }
#line 244
    if (here) {
#line 244
      if (! run) {
#line 245
        sets ++;
      }
    }
#line 246
    run = here;
#line 240
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 249
  printf((char const   */* __restrict  */)"%s table: %d+%d+%d (%dK+%dK) items+table+hash, %f density\n",
         hp->name, count, hp->items.nel, hp->tab.nel, (hp->items.nel * hp->items.size) / 1024,
         ((unsigned long )hp->tab.nel * sizeof(ITEM **)) / 1024UL, (double )((float )count / (float )sets));
  }
#line 257
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/execunix.c"
static int intr___2  =    0;
#line 66 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/execunix.c"
static int cmdsrunning___0  =    0;
#line 67 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/execunix.c"
static void (*istat___0)(int  )  ;
#line 69 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/execunix.c"
static struct __anonstruct_cmdtab_50___0 cmdtab___0[64]  = {      {0, (void (*)(void *closure , int status ))0, (void *)0}};
#line 81 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/make.c"
static void make0___0(TARGET *t , TARGET *p , int depth , COUNTS *counts___1 , int anyhow ) ;
#line 84
static TARGETS *make0sort___0(TARGETS *chain ) ;
#line 86 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/make.c"
static char const   *target_fate___0[12]  = 
#line 86
  {      "init",      "making",      "stable",      "newer", 
        "temp",      "touched",      "missing",      "needtmp", 
        "old",      "update",      "nofind",      "nomake"};
#line 102 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/make.c"
static char const   *target_bind___0[4]  = {      "unbound",      "missing",      "parents",      "exists"};
#line 164 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/make.c"
static void make0___0(TARGET *t , TARGET *p , int depth , COUNTS *counts___1 , int anyhow ) 
{ 
  TARGETS *c ;
  TARGETS *incs ;
  TARGET *ptime ;
  time_t last ;
  time_t leaf ;
  time_t hlast ;
  int fate ;
  char const   *flag ;
  SETTINGS *s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int internal ;
  char const   *tmp___5 ;
  int tmp___6 ;

  {
#line 173
  ptime = t;
#line 176
  flag = "";
#line 183
  if (globs.debug[3]) {
#line 184
    if (depth > 16) {
#line 184
      tmp = 16;
    } else {
#line 184
      tmp = depth;
    }
    {
#line 184
    printf((char const   */* __restrict  */)"make\t--\t%s%s\n", ("                " + 16) - tmp,
           t->name);
    }
  }
  {
#line 186
  t->fate = (char)1;
#line 195
  s = copysettings(t->settings);
#line 196
  pushsettings(s);
  }
#line 200
  if ((int )t->binding == 0) {
#line 200
    if (! ((int )t->flags & 4)) {
      {
#line 202
      t->boundname = search(t->name, & t->time);
      }
#line 203
      if (t->time) {
#line 203
        t->binding = (char)3;
      } else {
#line 203
        t->binding = (char)1;
      }
    }
  }
#line 208
  if (p) {
#line 208
    if ((int )t->flags & 64) {
#line 209
      ptime = p;
    }
  }
#line 213
  if (p) {
#line 213
    if ((int )t->flags & 1) {
#line 213
      if ((int )t->binding == 1) {
#line 213
        if ((int )p->binding != 1) {
#line 217
          t->binding = (char)2;
#line 218
          ptime = p;
        }
      }
    }
  }
#line 223
  if ((int )t->binding == 3) {
    {
#line 224
    headers(t);
    }
  }
  {
#line 228
  popsettings(s);
#line 229
  freesettings(s);
  }
#line 235
  if (globs.debug[3]) {
    {
#line 237
    tmp___1 = strcmp(t->name, t->boundname);
    }
#line 237
    if (tmp___1) {
#line 239
      if (depth > 16) {
#line 239
        tmp___0 = 16;
      } else {
#line 239
        tmp___0 = depth;
      }
      {
#line 239
      printf((char const   */* __restrict  */)"bind\t--\t%s%s: %s\n", ("                " + 16) - tmp___0,
             t->name, t->boundname);
      }
    }
    {
#line 247
    if ((int )t->binding == 2) {
#line 247
      goto case_2;
    }
#line 247
    if ((int )t->binding == 1) {
#line 247
      goto case_2;
    }
#line 247
    if ((int )t->binding == 0) {
#line 247
      goto case_2;
    }
#line 252
    if ((int )t->binding == 3) {
#line 252
      goto case_3;
    }
#line 243
    goto switch_break;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 248
    if (depth > 16) {
#line 248
      tmp___2 = 16;
    } else {
#line 248
      tmp___2 = depth;
    }
    {
#line 248
    printf((char const   */* __restrict  */)"time\t--\t%s%s: %s\n", ("                " + 16) - tmp___2,
           t->name, target_bind___0[t->binding]);
    }
#line 250
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 253
    tmp___3 = ctime((time_t const   *)(& t->time));
    }
#line 253
    if (depth > 16) {
#line 253
      tmp___4 = 16;
    } else {
#line 253
      tmp___4 = depth;
    }
    {
#line 253
    printf((char const   */* __restrict  */)"time\t--\t%s%s: %s", ("                " + 16) - tmp___4,
           t->name, tmp___3);
    }
#line 255
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 265
  c = t->depends;
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 265
    if (! c) {
#line 265
      goto while_break;
    }
#line 267
    internal = (int )t->flags & 64;
#line 269
    if (globs.debug[13]) {
#line 270
      if (internal) {
#line 270
        tmp___5 = "Includes";
      } else {
#line 270
        tmp___5 = "Depends";
      }
      {
#line 270
      printf((char const   */* __restrict  */)"%s \"%s\" : \"%s\" ;\n", tmp___5, t->name,
             (c->target)->name);
      }
    }
#line 277
    if ((int )(c->target)->fate == 0) {
      {
#line 278
      make0___0(c->target, ptime, depth + 1, counts___1, anyhow);
      }
    } else
#line 279
    if ((int )(c->target)->fate == 1) {
#line 279
      if (! internal) {
        {
#line 280
        printf((char const   */* __restrict  */)"warning: %s depends on itself\n",
               (c->target)->name);
        }
      }
    }
#line 265
    c = c->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 285
  if (t->includes) {
    {
#line 286
    make0___0(t->includes, p, depth + 1, counts___1, anyhow);
    }
  }
#line 290
  incs = (TARGETS *)0;
#line 292
  c = t->depends;
  {
#line 292
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 292
    if (! c) {
#line 292
      goto while_break___0;
    }
#line 293
    if ((c->target)->includes) {
      {
#line 294
      incs = targetentry(incs, (c->target)->includes);
      }
#line 298
      if (((c->target)->includes)->time > t->time) {
#line 299
        if (3 > (int )(c->target)->fate) {
#line 299
          (c->target)->fate = (char)3;
        } else {
#line 299
          (c->target)->fate = (c->target)->fate;
        }
      }
    }
#line 292
    c = c->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 303
  t->depends = targetchain(t->depends, incs);
#line 311
  last = (time_t )0;
#line 312
  leaf = (time_t )0;
#line 313
  fate = 2;
#line 315
  c = t->depends;
  }
  {
#line 315
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 315
    if (! c) {
#line 315
      goto while_break___1;
    }
#line 320
    if (leaf > (c->target)->leaf) {
#line 320
      leaf = leaf;
    } else {
#line 320
      leaf = (c->target)->leaf;
    }
#line 322
    if ((int )t->flags & 16) {
#line 324
      last = leaf;
#line 325
      goto __Cont;
    }
#line 328
    if (last > (c->target)->time) {
#line 328
      last = last;
    } else {
#line 328
      last = (c->target)->time;
    }
#line 329
    if (fate > (int )(c->target)->fate) {
#line 329
      fate = fate;
    } else {
#line 329
      fate = (int )(c->target)->fate;
    }
    __Cont: /* CIL Label */ 
#line 315
    c = c->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 339
  if (t->includes) {
#line 339
    hlast = (t->includes)->time;
  } else {
#line 339
    hlast = (time_t )0;
  }
#line 349
  if ((int )t->flags & 32) {
#line 351
    last = (time_t )0;
#line 352
    t->time = (time_t )0;
#line 353
    fate = 2;
  }
#line 376
  if (fate >= 10) {
#line 378
    fate = 11;
  } else
#line 380
  if (fate >= 4) {
#line 382
    fate = 9;
  } else
#line 384
  if ((int )t->binding == 1) {
#line 386
    fate = 6;
  } else
#line 388
  if ((int )t->binding == 3) {
#line 388
    if (last > t->time) {
#line 390
      fate = 8;
    } else {
#line 388
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 392
  if ((int )t->binding == 2) {
#line 392
    if (last > p->time) {
#line 394
      fate = 7;
    } else {
#line 392
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 396
  if ((int )t->binding == 2) {
#line 396
    if (hlast > p->time) {
#line 398
      fate = 7;
    } else {
#line 396
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 400
  if ((int )t->flags & 8) {
#line 402
    fate = 5;
  } else
#line 404
  if (anyhow) {
#line 404
    if (! ((int )t->flags & 32)) {
#line 406
      fate = 5;
    } else {
#line 404
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 408
  if ((int )t->binding == 3) {
#line 408
    if ((int )t->flags & 1) {
#line 410
      fate = 4;
    } else {
#line 408
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 412
  if ((int )t->binding == 3) {
#line 412
    if (p) {
#line 412
      if ((int )p->binding != 0) {
#line 412
        if (t->time > p->time) {
#line 415
          fate = 3;
        } else {
#line 419
          fate = 2;
        }
      } else {
#line 419
        fate = 2;
      }
    } else {
#line 419
      fate = 2;
    }
  } else {
#line 419
    fate = 2;
  }
#line 428
  if (fate == 6) {
#line 428
    if (! t->actions) {
#line 428
      if (! t->depends) {
#line 430
        if ((int )t->flags & 2) {
#line 432
          fate = 2;
        } else {
          {
#line 436
          printf((char const   */* __restrict  */)"don\'t know how to make %s\n",
                 t->name);
#line 438
          fate = 10;
          }
        }
      }
    }
  }
#line 445
  if (t->time > last) {
#line 445
    t->time = t->time;
  } else {
#line 445
    t->time = last;
  }
#line 446
  if (leaf) {
#line 446
    t->leaf = leaf;
  } else {
#line 446
    t->leaf = t->time;
  }
#line 447
  t->fate = (char )fate;
#line 453
  if (globs.newestfirst) {
    {
#line 454
    t->depends = make0sort___0(t->depends);
    }
  }
#line 462
  if ((int )t->flags & 64) {
#line 463
    return;
  }
#line 465
  (counts___1->targets) ++;
#line 465
  if (! (counts___1->targets % 1000)) {
#line 465
    if (globs.debug[1]) {
      {
#line 466
      printf((char const   */* __restrict  */)"...patience...\n");
      }
    }
  }
#line 468
  if (fate == 4) {
#line 469
    (counts___1->temp) ++;
  } else
#line 470
  if (fate == 10) {
#line 471
    (counts___1->cantfind) ++;
  } else
#line 472
  if (fate == 11) {
#line 472
    if (t->actions) {
#line 473
      (counts___1->cantmake) ++;
    } else {
#line 472
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 474
  if (fate >= 5) {
#line 474
    if (fate < 10) {
#line 474
      if (t->actions) {
#line 475
        (counts___1->updating) ++;
      }
    }
  }
#line 477
  if (! ((int )t->flags & 4)) {
#line 477
    if (fate >= 4) {
#line 478
      flag = "+";
    } else {
#line 477
      goto _L___5;
    }
  } else
  _L___5: /* CIL Label */ 
#line 479
  if ((int )t->binding == 3) {
#line 479
    if (p) {
#line 479
      if (t->time > p->time) {
#line 480
        flag = "*";
      }
    }
  }
#line 482
  if (globs.debug[3]) {
#line 483
    if (depth > 16) {
#line 483
      tmp___6 = 16;
    } else {
#line 483
      tmp___6 = depth;
    }
    {
#line 483
    printf((char const   */* __restrict  */)"made%s\t%s\t%s%s\n", flag, target_fate___0[t->fate],
           ("                " + 16) - tmp___6, t->name);
    }
  }
#line 487
  if (globs.debug[14]) {
#line 487
    if ((int )t->fate >= 3) {
#line 487
      if ((int )t->fate <= 6) {
        {
#line 490
        printf((char const   */* __restrict  */)"%s %s\n", target_fate___0[t->fate],
               t->name);
        }
      }
    }
  }
#line 491
  return;
}
}
#line 497 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/make.c"
static TARGETS *make0sort___0(TARGETS *chain ) 
{ 
  TARGETS *result ;
  TARGETS *c ;
  TARGETS *s ;

  {
#line 500
  result = (TARGETS *)0;
  {
#line 511
  while (1) {
    while_continue: /* CIL Label */ ;
#line 511
    if (! chain) {
#line 511
      goto while_break;
    }
#line 513
    c = chain;
#line 514
    s = result;
#line 516
    chain = chain->next;
    {
#line 520
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 520
      if (s) {
#line 520
        if (! ((s->target)->time > (c->target)->time)) {
#line 520
          goto while_break___0;
        }
      } else {
#line 520
        goto while_break___0;
      }
#line 521
      s = s->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 526
    c->next = s;
#line 527
    if ((unsigned long )result == (unsigned long )s) {
#line 527
      result = c;
    }
#line 528
    if (! s) {
#line 528
      s = result;
    }
#line 529
    if ((unsigned long )result != (unsigned long )c) {
#line 529
      (s->tail)->next = c;
    }
#line 530
    c->tail = s->tail;
#line 531
    s->tail = c;
  }
  while_break: /* CIL Label */ ;
  }
#line 534
  return (result);
}
}
#line 21 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/search.c"
char const   *search(char const   *target , time_t *time___0 ) 
{ 
  PATHNAME f[1] ;
  LIST *varlist ;
  char buf___0[1024] ;
  size_t tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
  {
#line 32
  path_parse(target, f);
#line 34
  f[0].part[0].ptr = (char const   *)0;
#line 35
  f[0].part[0].len = 0;
#line 37
  varlist = var_get("LOCATE");
  }
#line 37
  if (varlist) {
    {
#line 39
    f[0].part[1].ptr = varlist->string;
#line 40
    tmp = strlen(varlist->string);
#line 40
    f[0].part[1].len = (int )tmp;
#line 42
    path_build(f, buf___0, 1);
    }
#line 44
    if (globs.debug[6]) {
      {
#line 45
      printf((char const   */* __restrict  */)"locate %s: %s\n", target, buf___0);
      }
    }
    {
#line 47
    timestamp(buf___0, time___0);
#line 49
    tmp___0 = newstr((char const   *)(buf___0));
    }
#line 49
    return (tmp___0);
  } else {
    {
#line 51
    varlist = var_get("SEARCH");
    }
#line 51
    if (varlist) {
      {
#line 53
      while (1) {
        while_continue: /* CIL Label */ ;
#line 53
        if (! varlist) {
#line 53
          goto while_break;
        }
        {
#line 55
        f[0].part[1].ptr = varlist->string;
#line 56
        tmp___1 = strlen(varlist->string);
#line 56
        f[0].part[1].len = (int )tmp___1;
#line 58
        path_build(f, buf___0, 1);
        }
#line 60
        if (globs.debug[6]) {
          {
#line 61
          printf((char const   */* __restrict  */)"search %s: %s\n", target, buf___0);
          }
        }
        {
#line 63
        timestamp(buf___0, time___0);
        }
#line 65
        if (*time___0) {
          {
#line 66
          tmp___2 = newstr((char const   *)(buf___0));
          }
#line 66
          return (tmp___2);
        }
#line 68
        varlist = varlist->next;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 76
  f[0].part[1].ptr = (char const   *)0;
#line 77
  f[0].part[1].len = 0;
#line 79
  path_build(f, buf___0, 1);
  }
#line 81
  if (globs.debug[6]) {
    {
#line 82
    printf((char const   */* __restrict  */)"search %s: %s\n", target, buf___0);
    }
  }
  {
#line 84
  timestamp(buf___0, time___0);
#line 86
  tmp___3 = newstr((char const   *)(buf___0));
  }
#line 86
  return (tmp___3);
}
}
#line 23 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/regexp.h"
void regerror(char const   *s ) ;
#line 173 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/regexp.c"
static char *regparse  ;
#line 174 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/regexp.c"
static int regnpar  ;
#line 175 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/regexp.c"
static char regdummy  ;
#line 176 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/regexp.c"
static char *regcode  ;
#line 177 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/regexp.c"
static long regsize  ;
#line 185
static char *reg(int paren , int *flagp ) ;
#line 186
static char *regbranch(int *flagp ) ;
#line 187
static char *regpiece(int *flagp ) ;
#line 188
static char *regatom(int *flagp ) ;
#line 189
static char *regnode(int op ) ;
#line 190
static char *regnext(char *p ) ;
#line 191
static void regc(int b ) ;
#line 192
static void reginsert(char op , char *opnd ) ;
#line 193
static void regtail(char *p , char *val ) ;
#line 194
static void regoptail(char *p , char *val ) ;
#line 214 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/regexp.c"
regexp *regcomp(char const   *exp ) 
{ 
  register regexp *r ;
  register char *scan ;
  register char *longest ;
  register unsigned int len ;
  int flags ;
  char *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;

  {
#line 223
  if ((unsigned long )exp == (unsigned long )((void *)0)) {
    {
#line 224
    regerror("NULL argument");
    }
#line 224
    return ((regexp *)((void *)0));
  }
  {
#line 230
  regparse = (char *)exp;
#line 231
  regnpar = 1;
#line 232
  regsize = 0L;
#line 233
  regcode = & regdummy;
#line 234
  regc(156);
#line 235
  tmp = reg(0, & flags);
  }
#line 235
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 236
    return ((regexp *)((void *)0));
  }
#line 239
  if (regsize >= 32767L) {
    {
#line 240
    regerror("regexp too big");
    }
#line 240
    return ((regexp *)((void *)0));
  }
  {
#line 243
  tmp___0 = malloc(sizeof(regexp ) + (unsigned long )((unsigned int )regsize));
#line 243
  r = (regexp *)tmp___0;
  }
#line 244
  if ((unsigned long )r == (unsigned long )((void *)0)) {
    {
#line 245
    regerror("out of space");
    }
#line 245
    return ((regexp *)((void *)0));
  }
  {
#line 248
  regparse = (char *)exp;
#line 249
  regnpar = 1;
#line 250
  regcode = r->program;
#line 251
  regc(156);
#line 252
  tmp___1 = reg(0, & flags);
  }
#line 252
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 253
    return ((regexp *)((void *)0));
  }
  {
#line 256
  r->regstart = (char )'\000';
#line 257
  r->reganch = (char)0;
#line 258
  r->regmust = (char *)((void *)0);
#line 259
  r->regmlen = 0;
#line 260
  scan = r->program + 1;
#line 261
  tmp___4 = regnext(scan);
  }
#line 261
  if ((int )*tmp___4 == 0) {
#line 262
    scan += 3;
#line 265
    if ((int )*scan == 8) {
#line 266
      r->regstart = *(scan + 3);
    } else
#line 267
    if ((int )*scan == 1) {
#line 268
      r->reganch = (char )((int )r->reganch + 1);
    }
#line 278
    if (flags & 4) {
#line 279
      longest = (char *)((void *)0);
#line 280
      len = 0U;
      {
#line 281
      while (1) {
        while_continue: /* CIL Label */ ;
#line 281
        if (! ((unsigned long )scan != (unsigned long )((void *)0))) {
#line 281
          goto while_break;
        }
#line 282
        if ((int )*scan == 8) {
          {
#line 282
          tmp___3 = strlen((char const   *)(scan + 3));
          }
#line 282
          if (tmp___3 >= (size_t )len) {
            {
#line 283
            longest = scan + 3;
#line 284
            tmp___2 = strlen((char const   *)(scan + 3));
#line 284
            len = (unsigned int )tmp___2;
            }
          }
        }
        {
#line 281
        scan = regnext(scan);
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 286
      r->regmust = longest;
#line 287
      r->regmlen = (int )len;
    }
  }
#line 291
  return (r);
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/regexp.c"
static char *reg(int paren , int *flagp ) 
{ 
  register char *ret ;
  register char *br ;
  register char *ender ;
  register int parno ;
  int flags ;
  int tmp ;
  char *tmp___0 ;

  {
#line 314
  *flagp = 1;
#line 317
  if (paren) {
#line 318
    if (regnpar >= 10) {
      {
#line 319
      regerror("too many ()");
      }
#line 319
      return ((char *)((void *)0));
    }
    {
#line 320
    parno = regnpar;
#line 321
    regnpar ++;
#line 322
    ret = regnode(20 + parno);
    }
  } else {
#line 324
    ret = (char *)((void *)0);
  }
  {
#line 327
  br = regbranch(& flags);
  }
#line 328
  if ((unsigned long )br == (unsigned long )((void *)0)) {
#line 329
    return ((char *)((void *)0));
  }
#line 330
  if ((unsigned long )ret != (unsigned long )((void *)0)) {
    {
#line 331
    regtail(ret, br);
    }
  } else {
#line 333
    ret = br;
  }
#line 334
  if (! (flags & 1)) {
#line 335
    *flagp &= -2;
  }
#line 336
  *flagp |= flags & 4;
  {
#line 337
  while (1) {
    while_continue: /* CIL Label */ ;
#line 337
    if (! ((int )*regparse == 124)) {
#line 337
      if (! ((int )*regparse == 10)) {
#line 337
        goto while_break;
      }
    }
    {
#line 338
    regparse ++;
#line 339
    br = regbranch(& flags);
    }
#line 340
    if ((unsigned long )br == (unsigned long )((void *)0)) {
#line 341
      return ((char *)((void *)0));
    }
    {
#line 342
    regtail(ret, br);
    }
#line 343
    if (! (flags & 1)) {
#line 344
      *flagp &= -2;
    }
#line 345
    *flagp |= flags & 4;
  }
  while_break: /* CIL Label */ ;
  }
#line 349
  if (paren) {
#line 349
    tmp = 30 + parno;
  } else {
#line 349
    tmp = 0;
  }
  {
#line 349
  ender = regnode(tmp);
#line 350
  regtail(ret, ender);
#line 353
  br = ret;
  }
  {
#line 353
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 353
    if (! ((unsigned long )br != (unsigned long )((void *)0))) {
#line 353
      goto while_break___0;
    }
    {
#line 354
    regoptail(br, ender);
#line 353
    br = regnext(br);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 357
  if (paren) {
#line 357
    tmp___0 = regparse;
#line 357
    regparse ++;
#line 357
    if ((int )*tmp___0 != 41) {
      {
#line 358
      regerror("unmatched ()");
      }
#line 358
      return ((char *)((void *)0));
    } else {
#line 357
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 359
  if (! paren) {
#line 359
    if ((int )*regparse != 0) {
#line 360
      if ((int )*regparse == 41) {
        {
#line 361
        regerror("unmatched ()");
        }
#line 361
        return ((char *)((void *)0));
      } else {
        {
#line 363
        regerror("junk on end");
        }
#line 363
        return ((char *)((void *)0));
      }
    }
  }
#line 367
  return (ret);
}
}
#line 375 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/regexp.c"
static char *regbranch(int *flagp ) 
{ 
  register char *ret ;
  register char *chain ;
  register char *latest ;
  int flags ;

  {
  {
#line 383
  *flagp = 0;
#line 385
  ret = regnode(6);
#line 386
  chain = (char *)((void *)0);
  }
  {
#line 387
  while (1) {
    while_continue: /* CIL Label */ ;
#line 387
    if ((int )*regparse != 0) {
#line 387
      if ((int )*regparse != 41) {
#line 387
        if ((int )*regparse != 10) {
#line 387
          if (! ((int )*regparse != 124)) {
#line 387
            goto while_break;
          }
        } else {
#line 387
          goto while_break;
        }
      } else {
#line 387
        goto while_break;
      }
    } else {
#line 387
      goto while_break;
    }
    {
#line 389
    latest = regpiece(& flags);
    }
#line 390
    if ((unsigned long )latest == (unsigned long )((void *)0)) {
#line 391
      return ((char *)((void *)0));
    }
#line 392
    *flagp |= flags & 1;
#line 393
    if ((unsigned long )chain == (unsigned long )((void *)0)) {
#line 394
      *flagp |= flags & 4;
    } else {
      {
#line 396
      regtail(chain, latest);
      }
    }
#line 397
    chain = latest;
  }
  while_break: /* CIL Label */ ;
  }
#line 399
  if ((unsigned long )chain == (unsigned long )((void *)0)) {
    {
#line 400
    regnode(9);
    }
  }
#line 402
  return (ret);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/regexp.c"
static char *regpiece(int *flagp ) 
{ 
  register char *ret ;
  register char op ;
  register char *next ;
  int flags ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 422
  ret = regatom(& flags);
  }
#line 423
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 424
    return ((char *)((void *)0));
  }
#line 426
  op = *regparse;
#line 427
  if (! ((int )op == 42)) {
#line 427
    if (! ((int )op == 43)) {
#line 427
      if (! ((int )op == 63)) {
#line 428
        *flagp = flags;
#line 429
        return (ret);
      }
    }
  }
#line 432
  if (! (flags & 1)) {
#line 432
    if ((int )op != 63) {
      {
#line 433
      regerror("*+ operand could be empty");
      }
#line 433
      return ((char *)((void *)0));
    }
  }
#line 434
  if ((int )op != 43) {
#line 434
    *flagp = 4;
  } else {
#line 434
    *flagp = 1;
  }
#line 436
  if ((int )op == 42) {
#line 436
    if (flags & 2) {
      {
#line 437
      reginsert((char)10, ret);
      }
    } else {
#line 436
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 438
  if ((int )op == 42) {
    {
#line 440
    reginsert((char)6, ret);
#line 441
    tmp = regnode(7);
#line 441
    regoptail(ret, tmp);
#line 442
    regoptail(ret, ret);
#line 443
    tmp___0 = regnode(6);
#line 443
    regtail(ret, tmp___0);
#line 444
    tmp___1 = regnode(9);
#line 444
    regtail(ret, tmp___1);
    }
  } else
#line 445
  if ((int )op == 43) {
#line 445
    if (flags & 2) {
      {
#line 446
      reginsert((char)11, ret);
      }
    } else {
#line 445
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 447
  if ((int )op == 43) {
    {
#line 449
    next = regnode(6);
#line 450
    regtail(ret, next);
#line 451
    tmp___2 = regnode(7);
#line 451
    regtail(tmp___2, ret);
#line 452
    tmp___3 = regnode(6);
#line 452
    regtail(next, tmp___3);
#line 453
    tmp___4 = regnode(9);
#line 453
    regtail(ret, tmp___4);
    }
  } else
#line 454
  if ((int )op == 63) {
    {
#line 456
    reginsert((char)6, ret);
#line 457
    tmp___5 = regnode(6);
#line 457
    regtail(ret, tmp___5);
#line 458
    next = regnode(9);
#line 459
    regtail(ret, next);
#line 460
    regoptail(ret, next);
    }
  }
#line 462
  regparse ++;
#line 463
  if ((int )*regparse == 42) {
    {
#line 464
    regerror("nested *?+");
    }
#line 464
    return ((char *)((void *)0));
  } else
#line 463
  if ((int )*regparse == 43) {
    {
#line 464
    regerror("nested *?+");
    }
#line 464
    return ((char *)((void *)0));
  } else
#line 463
  if ((int )*regparse == 63) {
    {
#line 464
    regerror("nested *?+");
    }
#line 464
    return ((char *)((void *)0));
  }
#line 466
  return (ret);
}
}
#line 477 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/regexp.c"
static char *regatom(int *flagp ) 
{ 
  register char *ret ;
  int flags ;
  char *tmp ;
  register int classr ;
  register int classend ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *regprev ;
  register char ch ;
  char *tmp___3 ;

  {
#line 483
  *flagp = 0;
#line 485
  tmp = regparse;
#line 485
  regparse ++;
  {
#line 487
  if ((int )*tmp == 94) {
#line 487
    goto case_94;
  }
#line 490
  if ((int )*tmp == 36) {
#line 490
    goto case_36;
  }
#line 493
  if ((int )*tmp == 46) {
#line 493
    goto case_46;
  }
#line 497
  if ((int )*tmp == 91) {
#line 497
    goto case_91;
  }
#line 532
  if ((int )*tmp == 40) {
#line 532
    goto case_40;
  }
#line 541
  if ((int )*tmp == 41) {
#line 541
    goto case_41;
  }
#line 541
  if ((int )*tmp == 10) {
#line 541
    goto case_41;
  }
#line 541
  if ((int )*tmp == 124) {
#line 541
    goto case_41;
  }
#line 541
  if ((int )*tmp == 0) {
#line 541
    goto case_41;
  }
#line 546
  if ((int )*tmp == 42) {
#line 546
    goto case_42;
  }
#line 546
  if ((int )*tmp == 43) {
#line 546
    goto case_42;
  }
#line 546
  if ((int )*tmp == 63) {
#line 546
    goto case_42;
  }
#line 549
  if ((int )*tmp == 92) {
#line 549
    goto case_92;
  }
#line 567
  goto de_fault;
  case_94: /* CIL Label */ 
  {
#line 488
  ret = regnode(1);
  }
#line 489
  goto switch_break;
  case_36: /* CIL Label */ 
  {
#line 491
  ret = regnode(2);
  }
#line 492
  goto switch_break;
  case_46: /* CIL Label */ 
  {
#line 494
  ret = regnode(3);
#line 495
  *flagp |= 3;
  }
#line 496
  goto switch_break;
  case_91: /* CIL Label */ 
#line 501
  if ((int )*regparse == 94) {
    {
#line 502
    ret = regnode(5);
#line 503
    regparse ++;
    }
  } else {
    {
#line 505
    ret = regnode(4);
    }
  }
#line 506
  if ((int )*regparse == 93) {
    {
#line 507
    tmp___0 = regparse;
#line 507
    regparse ++;
#line 507
    regc((int )*tmp___0);
    }
  } else
#line 506
  if ((int )*regparse == 45) {
    {
#line 507
    tmp___0 = regparse;
#line 507
    regparse ++;
#line 507
    regc((int )*tmp___0);
    }
  }
  {
#line 508
  while (1) {
    while_continue: /* CIL Label */ ;
#line 508
    if ((int )*regparse != 0) {
#line 508
      if (! ((int )*regparse != 93)) {
#line 508
        goto while_break;
      }
    } else {
#line 508
      goto while_break;
    }
#line 509
    if ((int )*regparse == 45) {
#line 510
      regparse ++;
#line 511
      if ((int )*regparse == 93) {
        {
#line 512
        regc('-');
        }
      } else
#line 511
      if ((int )*regparse == 0) {
        {
#line 512
        regc('-');
        }
      } else {
#line 514
        classr = (int )*((unsigned char *)(regparse - 2)) + 1;
#line 515
        classend = (int )*((unsigned char *)regparse);
#line 516
        if (classr > classend + 1) {
          {
#line 517
          regerror("invalid [] range");
          }
#line 517
          return ((char *)((void *)0));
        }
        {
#line 518
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 518
          if (! (classr <= classend)) {
#line 518
            goto while_break___0;
          }
          {
#line 519
          regc(classr);
#line 518
          classr ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 520
        regparse ++;
      }
    } else {
      {
#line 523
      tmp___1 = regparse;
#line 523
      regparse ++;
#line 523
      regc((int )*tmp___1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 525
  regc('\000');
  }
#line 526
  if ((int )*regparse != 93) {
    {
#line 527
    regerror("unmatched []");
    }
#line 527
    return ((char *)((void *)0));
  }
#line 528
  regparse ++;
#line 529
  *flagp |= 3;
#line 531
  goto switch_break;
  case_40: /* CIL Label */ 
  {
#line 533
  ret = reg(1, & flags);
  }
#line 534
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 535
    return ((char *)((void *)0));
  }
#line 536
  *flagp |= flags & 5;
#line 537
  goto switch_break;
  case_41: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_124: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 542
  regerror("internal urp");
  }
#line 542
  return ((char *)((void *)0));
#line 543
  goto switch_break;
  case_42: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_63: /* CIL Label */ 
  {
#line 547
  regerror("?+* follows nothing");
  }
#line 547
  return ((char *)((void *)0));
#line 548
  goto switch_break;
  case_92: /* CIL Label */ 
#line 550
  tmp___2 = regparse;
#line 550
  regparse ++;
  {
#line 551
  if ((int )*tmp___2 == 0) {
#line 551
    goto case_0___0;
  }
#line 554
  if ((int )*tmp___2 == 60) {
#line 554
    goto case_60;
  }
#line 557
  if ((int )*tmp___2 == 62) {
#line 557
    goto case_62;
  }
#line 561
  goto switch_default;
  case_0___0: /* CIL Label */ 
  {
#line 552
  regerror("trailing \\");
  }
#line 552
  return ((char *)((void *)0));
#line 553
  goto switch_break___0;
  case_60: /* CIL Label */ 
  {
#line 555
  ret = regnode(12);
  }
#line 556
  goto switch_break___0;
  case_62: /* CIL Label */ 
  {
#line 558
  ret = regnode(13);
  }
#line 559
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 563
  goto de_fault;
  switch_break___0: /* CIL Label */ ;
  }
#line 565
  goto switch_break;
  de_fault: 
  switch_default___0: /* CIL Label */ 
  {
#line 596
  regparse --;
#line 597
  ret = regnode(8);
#line 598
  regprev = (char *)0;
  }
  {
#line 598
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 599
    tmp___3 = regparse;
#line 599
    regparse ++;
#line 599
    ch = *tmp___3;
    {
#line 609
    if ((int )*regparse == 0) {
#line 609
      goto magic;
    }
#line 609
    if ((int )*regparse == 94) {
#line 609
      goto magic;
    }
#line 609
    if ((int )*regparse == 36) {
#line 609
      goto magic;
    }
#line 609
    if ((int )*regparse == 10) {
#line 609
      goto magic;
    }
#line 609
    if ((int )*regparse == 124) {
#line 609
      goto magic;
    }
#line 609
    if ((int )*regparse == 41) {
#line 609
      goto magic;
    }
#line 609
    if ((int )*regparse == 40) {
#line 609
      goto magic;
    }
#line 609
    if ((int )*regparse == 91) {
#line 609
      goto magic;
    }
#line 609
    if ((int )*regparse == 46) {
#line 609
      goto magic;
    }
#line 615
    if ((int )*regparse == 42) {
#line 615
      goto case_42___0;
    }
#line 615
    if ((int )*regparse == 43) {
#line 615
      goto case_42___0;
    }
#line 615
    if ((int )*regparse == 63) {
#line 615
      goto case_42___0;
    }
#line 622
    if ((int )*regparse == 92) {
#line 622
      goto case_92___0;
    }
#line 602
    goto switch_default___1;
    switch_default___1: /* CIL Label */ 
    {
#line 603
    regc((int )ch);
    }
#line 604
    goto switch_break___1;
    magic: 
    case_0___1: /* CIL Label */ 
    case_94___0: /* CIL Label */ 
    case_36___0: /* CIL Label */ 
    case_10___0: /* CIL Label */ 
    case_124___0: /* CIL Label */ 
    case_41___0: /* CIL Label */ 
    case_40___0: /* CIL Label */ 
    case_91___0: /* CIL Label */ 
    case_46___0: /* CIL Label */ 
    {
#line 612
    regc((int )ch);
    }
#line 613
    goto done;
    case_42___0: /* CIL Label */ 
    case_43___0: /* CIL Label */ 
    case_63___0: /* CIL Label */ 
#line 616
    if (! regprev) {
#line 617
      goto magic;
    }
#line 619
    regparse = regprev;
#line 620
    goto done;
    case_92___0: /* CIL Label */ 
    {
#line 623
    regc((int )ch);
    }
    {
#line 627
    if ((int )*(regparse + 1) == 62) {
#line 627
      goto case_62___0;
    }
#line 627
    if ((int )*(regparse + 1) == 60) {
#line 627
      goto case_62___0;
    }
#line 627
    if ((int )*(regparse + 1) == 0) {
#line 627
      goto case_62___0;
    }
#line 630
    goto switch_default___2;
    case_62___0: /* CIL Label */ 
    case_60___0: /* CIL Label */ 
    case_0___2: /* CIL Label */ 
#line 629
    goto done;
    switch_default___2: /* CIL Label */ 
#line 632
    regprev = regparse;
#line 633
    regparse ++;
#line 634
    goto __Cont;
    switch_break___2: /* CIL Label */ ;
    }
    switch_break___1: /* CIL Label */ ;
    }
#line 637
    regprev = regparse;
    __Cont: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  done: 
  {
#line 640
  regc('\000');
#line 641
  *flagp |= 1;
  }
#line 642
  if (! regprev) {
#line 643
    *flagp |= 2;
  }
#line 645
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 648
  return (ret);
}
}
#line 654 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/regexp.c"
static char *regnode(int op ) 
{ 
  register char *ret ;
  register char *ptr ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 660
  ret = regcode;
#line 661
  if ((unsigned long )ret == (unsigned long )(& regdummy)) {
#line 662
    regsize += 3L;
#line 663
    return (ret);
  }
#line 666
  ptr = ret;
#line 667
  tmp = ptr;
#line 667
  ptr ++;
#line 667
  *tmp = (char )op;
#line 668
  tmp___0 = ptr;
#line 668
  ptr ++;
#line 668
  *tmp___0 = (char )'\000';
#line 669
  tmp___1 = ptr;
#line 669
  ptr ++;
#line 669
  *tmp___1 = (char )'\000';
#line 670
  regcode = ptr;
#line 672
  return (ret);
}
}
#line 678 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/regexp.c"
static void regc(int b ) 
{ 
  char *tmp ;

  {
#line 681
  if ((unsigned long )regcode != (unsigned long )(& regdummy)) {
#line 682
    tmp = regcode;
#line 682
    regcode ++;
#line 682
    *tmp = (char )b;
  } else {
#line 684
    regsize ++;
  }
#line 685
  return;
}
}
#line 692 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/regexp.c"
static void reginsert(char op , char *opnd ) 
{ 
  register char *src ;
  register char *dst ;
  register char *place ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 701
  if ((unsigned long )regcode == (unsigned long )(& regdummy)) {
#line 702
    regsize += 3L;
#line 703
    return;
  }
#line 706
  src = regcode;
#line 707
  regcode += 3;
#line 708
  dst = regcode;
  {
#line 709
  while (1) {
    while_continue: /* CIL Label */ ;
#line 709
    if (! ((unsigned long )src > (unsigned long )opnd)) {
#line 709
      goto while_break;
    }
#line 710
    dst --;
#line 710
    src --;
#line 710
    *dst = *src;
  }
  while_break: /* CIL Label */ ;
  }
#line 712
  place = opnd;
#line 713
  tmp = place;
#line 713
  place ++;
#line 713
  *tmp = op;
#line 714
  tmp___0 = place;
#line 714
  place ++;
#line 714
  *tmp___0 = (char )'\000';
#line 715
  tmp___1 = place;
#line 715
  place ++;
#line 715
  *tmp___1 = (char )'\000';
#line 716
  return;
}
}
#line 721 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/regexp.c"
static void regtail(char *p , char *val ) 
{ 
  register char *scan ;
  register char *temp ;
  register int offset ;

  {
#line 730
  if ((unsigned long )p == (unsigned long )(& regdummy)) {
#line 731
    return;
  }
#line 734
  scan = p;
  {
#line 735
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 736
    temp = regnext(scan);
    }
#line 737
    if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 738
      goto while_break;
    }
#line 739
    scan = temp;
  }
  while_break: /* CIL Label */ ;
  }
#line 742
  if ((int )*scan == 7) {
#line 743
    offset = (int )(scan - val);
  } else {
#line 745
    offset = (int )(val - scan);
  }
#line 746
  *(scan + 1) = (char )((offset >> 8) & 255);
#line 747
  *(scan + 2) = (char )(offset & 255);
#line 748
  return;
}
}
#line 754 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/regexp.c"
static void regoptail(char *p , char *val ) 
{ 


  {
#line 760
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 761
    return;
  } else
#line 760
  if ((unsigned long )p == (unsigned long )(& regdummy)) {
#line 761
    return;
  } else
#line 760
  if ((int )*p != 6) {
#line 761
    return;
  }
  {
#line 762
  regtail(p + 3, val);
  }
#line 763
  return;
}
}
#line 772 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/regexp.c"
static char const   *reginput  ;
#line 773 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/regexp.c"
static char *regbol  ;
#line 774 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/regexp.c"
static char const   **regstartp  ;
#line 775 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/regexp.c"
static char const   **regendp  ;
#line 780
static int regtry(regexp *prog , char const   *string ) ;
#line 781
static int regmatch(char *prog ) ;
#line 782
static int regrepeat(char *p ) ;
#line 793 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/regexp.c"
int regexec(regexp *prog , char const   *string ) 
{ 
  register char *s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 801
  if ((unsigned long )prog == (unsigned long )((void *)0)) {
    {
#line 802
    regerror("NULL parameter");
    }
#line 803
    return (0);
  } else
#line 801
  if ((unsigned long )string == (unsigned long )((void *)0)) {
    {
#line 802
    regerror("NULL parameter");
    }
#line 803
    return (0);
  }
#line 807
  if ((int )*((unsigned char *)(prog->program)) != 156) {
    {
#line 808
    regerror("corrupted program");
    }
#line 809
    return (0);
  }
#line 813
  if ((unsigned long )prog->regmust != (unsigned long )((void *)0)) {
#line 814
    s = (char *)string;
    {
#line 815
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 815
      s = strchr((char const   *)s, (int )*(prog->regmust + 0));
      }
#line 815
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 815
        goto while_break;
      }
      {
#line 816
      tmp = strncmp((char const   *)s, (char const   *)prog->regmust, (size_t )prog->regmlen);
      }
#line 816
      if (tmp == 0) {
#line 817
        goto while_break;
      }
#line 818
      s ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 820
    if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 821
      return (0);
    }
  }
#line 825
  regbol = (char *)string;
#line 828
  if (prog->reganch) {
    {
#line 829
    tmp___0 = regtry(prog, string);
    }
#line 829
    return (tmp___0);
  }
#line 832
  s = (char *)string;
#line 833
  if ((int )prog->regstart != 0) {
    {
#line 835
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 835
      s = strchr((char const   *)s, (int )prog->regstart);
      }
#line 835
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 835
        goto while_break___0;
      }
      {
#line 836
      tmp___1 = regtry(prog, (char const   *)s);
      }
#line 836
      if (tmp___1) {
#line 837
        return (1);
      }
#line 838
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 842
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 843
      tmp___2 = regtry(prog, (char const   *)s);
      }
#line 843
      if (tmp___2) {
#line 844
        return (1);
      }
#line 842
      tmp___3 = s;
#line 842
      s ++;
#line 842
      if (! ((int )*tmp___3 != 0)) {
#line 842
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 848
  return (0);
}
}
#line 854 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/regexp.c"
static int regtry(regexp *prog , char const   *string ) 
{ 
  register int i ;
  register char const   **sp ;
  register char const   **ep ;
  char const   **tmp ;
  char const   **tmp___0 ;
  int tmp___1 ;

  {
#line 863
  reginput = string;
#line 864
  regstartp = prog->startp;
#line 865
  regendp = prog->endp;
#line 867
  sp = prog->startp;
#line 868
  ep = prog->endp;
#line 869
  i = 10;
  {
#line 869
  while (1) {
    while_continue: /* CIL Label */ ;
#line 869
    if (! (i > 0)) {
#line 869
      goto while_break;
    }
#line 870
    tmp = sp;
#line 870
    sp ++;
#line 870
    *tmp = (char const   *)((void *)0);
#line 871
    tmp___0 = ep;
#line 871
    ep ++;
#line 871
    *tmp___0 = (char const   *)((void *)0);
#line 869
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 873
  tmp___1 = regmatch(prog->program + 1);
  }
#line 873
  if (tmp___1) {
#line 874
    prog->startp[0] = string;
#line 875
    prog->endp[0] = reginput;
#line 876
    return (1);
  } else {
#line 878
    return (0);
  }
}
}
#line 891 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/regexp.c"
static int regmatch(char *prog ) 
{ 
  register char *scan ;
  char *next ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  register int len ;
  register char *opnd ;
  size_t tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  register int no ;
  register char const   *save ;
  int tmp___6 ;
  register int no___0 ;
  register char const   *save___0 ;
  int tmp___7 ;
  register char const   *save___1 ;
  int tmp___8 ;
  register char nextch ;
  register int no___1 ;
  register char const   *save___2 ;
  register int min ;
  int tmp___9 ;

  {
#line 897
  scan = prog;
  {
#line 902
  while (1) {
    while_continue: /* CIL Label */ ;
#line 902
    if (! ((unsigned long )scan != (unsigned long )((void *)0))) {
#line 902
      goto while_break;
    }
    {
#line 907
    next = regnext(scan);
    }
    {
#line 910
    if ((int )*scan == 1) {
#line 910
      goto case_1;
    }
#line 914
    if ((int )*scan == 2) {
#line 914
      goto case_2;
    }
#line 918
    if ((int )*scan == 12) {
#line 918
      goto case_12;
    }
#line 927
    if ((int )*scan == 13) {
#line 927
      goto case_13;
    }
#line 933
    if ((int )*scan == 3) {
#line 933
      goto case_3;
    }
#line 938
    if ((int )*scan == 8) {
#line 938
      goto case_8;
    }
#line 952
    if ((int )*scan == 4) {
#line 952
      goto case_4;
    }
#line 957
    if ((int )*scan == 5) {
#line 957
      goto case_5;
    }
#line 962
    if ((int )*scan == 9) {
#line 962
      goto case_9;
    }
#line 964
    if ((int )*scan == 7) {
#line 964
      goto case_7;
    }
#line 974
    if ((int )*scan == 29) {
#line 974
      goto case_29;
    }
#line 974
    if ((int )*scan == 28) {
#line 974
      goto case_29;
    }
#line 974
    if ((int )*scan == 27) {
#line 974
      goto case_29;
    }
#line 974
    if ((int )*scan == 26) {
#line 974
      goto case_29;
    }
#line 974
    if ((int )*scan == 25) {
#line 974
      goto case_29;
    }
#line 974
    if ((int )*scan == 24) {
#line 974
      goto case_29;
    }
#line 974
    if ((int )*scan == 23) {
#line 974
      goto case_29;
    }
#line 974
    if ((int )*scan == 22) {
#line 974
      goto case_29;
    }
#line 974
    if ((int )*scan == 21) {
#line 974
      goto case_29;
    }
#line 1002
    if ((int )*scan == 39) {
#line 1002
      goto case_39;
    }
#line 1002
    if ((int )*scan == 38) {
#line 1002
      goto case_39;
    }
#line 1002
    if ((int )*scan == 37) {
#line 1002
      goto case_39;
    }
#line 1002
    if ((int )*scan == 36) {
#line 1002
      goto case_39;
    }
#line 1002
    if ((int )*scan == 35) {
#line 1002
      goto case_39;
    }
#line 1002
    if ((int )*scan == 34) {
#line 1002
      goto case_39;
    }
#line 1002
    if ((int )*scan == 33) {
#line 1002
      goto case_39;
    }
#line 1002
    if ((int )*scan == 32) {
#line 1002
      goto case_39;
    }
#line 1002
    if ((int )*scan == 31) {
#line 1002
      goto case_39;
    }
#line 1022
    if ((int )*scan == 6) {
#line 1022
      goto case_6;
    }
#line 1041
    if ((int )*scan == 11) {
#line 1041
      goto case_11;
    }
#line 1041
    if ((int )*scan == 10) {
#line 1041
      goto case_11;
    }
#line 1069
    if ((int )*scan == 0) {
#line 1069
      goto case_0;
    }
#line 1072
    goto switch_default;
    case_1: /* CIL Label */ 
#line 911
    if ((unsigned long )reginput != (unsigned long )regbol) {
#line 912
      return (0);
    }
#line 913
    goto switch_break;
    case_2: /* CIL Label */ 
#line 915
    if ((int const   )*reginput != 0) {
#line 916
      return (0);
    }
#line 917
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 920
    tmp = __ctype_b_loc();
    }
#line 920
    if (! ((int const   )*(*tmp + (int )*reginput) & 8)) {
#line 920
      if ((int const   )*reginput != 95) {
#line 921
        return (0);
      }
    }
#line 923
    if ((unsigned long )reginput > (unsigned long )regbol) {
      {
#line 923
      tmp___0 = __ctype_b_loc();
      }
#line 923
      if ((int const   )*(*tmp___0 + (int )*(reginput + -1)) & 8) {
#line 925
        return (0);
      } else
#line 923
      if ((int const   )*(reginput + -1) == 95) {
#line 925
        return (0);
      }
    }
#line 926
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 929
    tmp___1 = __ctype_b_loc();
    }
#line 929
    if ((int const   )*(*tmp___1 + (int )*reginput) & 8) {
#line 930
      return (0);
    } else
#line 929
    if ((int const   )*reginput == 95) {
#line 930
      return (0);
    }
#line 932
    goto switch_break;
    case_3: /* CIL Label */ 
#line 934
    if ((int const   )*reginput == 0) {
#line 935
      return (0);
    }
#line 936
    reginput ++;
#line 937
    goto switch_break;
    case_8: /* CIL Label */ 
#line 942
    opnd = scan + 3;
#line 944
    if ((int )*opnd != (int )*reginput) {
#line 945
      return (0);
    }
    {
#line 946
    tmp___2 = strlen((char const   *)opnd);
#line 946
    len = (int )tmp___2;
    }
#line 947
    if (len > 1) {
      {
#line 947
      tmp___3 = strncmp((char const   *)opnd, reginput, (size_t )len);
      }
#line 947
      if (tmp___3 != 0) {
#line 948
        return (0);
      }
    }
#line 949
    reginput += len;
#line 951
    goto switch_break;
    case_4: /* CIL Label */ 
#line 953
    if ((int const   )*reginput == 0) {
#line 954
      return (0);
    } else {
      {
#line 953
      tmp___4 = strchr((char const   *)(scan + 3), (int )*reginput);
      }
#line 953
      if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
#line 954
        return (0);
      }
    }
#line 955
    reginput ++;
#line 956
    goto switch_break;
    case_5: /* CIL Label */ 
#line 958
    if ((int const   )*reginput == 0) {
#line 959
      return (0);
    } else {
      {
#line 958
      tmp___5 = strchr((char const   *)(scan + 3), (int )*reginput);
      }
#line 958
      if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
#line 959
        return (0);
      }
    }
#line 960
    reginput ++;
#line 961
    goto switch_break;
    case_9: /* CIL Label */ 
#line 963
    goto switch_break;
    case_7: /* CIL Label */ 
#line 965
    goto switch_break;
    case_29: /* CIL Label */ 
    case_28: /* CIL Label */ 
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24: /* CIL Label */ 
    case_23: /* CIL Label */ 
    case_22: /* CIL Label */ 
    case_21: /* CIL Label */ 
    {
#line 978
    no = (int )*scan - 20;
#line 979
    save = reginput;
#line 981
    tmp___6 = regmatch(next);
    }
#line 981
    if (tmp___6) {
#line 987
      if ((unsigned long )*(regstartp + no) == (unsigned long )((void *)0)) {
#line 988
        *(regstartp + no) = save;
      }
#line 989
      return (1);
    } else {
#line 991
      return (0);
    }
#line 993
    goto switch_break;
    case_39: /* CIL Label */ 
    case_38: /* CIL Label */ 
    case_37: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_35: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_33: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_31: /* CIL Label */ 
    {
#line 1006
    no___0 = (int )*scan - 30;
#line 1007
    save___0 = reginput;
#line 1009
    tmp___7 = regmatch(next);
    }
#line 1009
    if (tmp___7) {
#line 1015
      if ((unsigned long )*(regendp + no___0) == (unsigned long )((void *)0)) {
#line 1016
        *(regendp + no___0) = save___0;
      }
#line 1017
      return (1);
    } else {
#line 1019
      return (0);
    }
#line 1021
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1025
    if ((int )*next != 6) {
#line 1026
      next = scan + 3;
    } else {
      {
#line 1028
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1029
        save___1 = reginput;
#line 1030
        tmp___8 = regmatch(scan + 3);
        }
#line 1030
        if (tmp___8) {
#line 1031
          return (1);
        }
        {
#line 1032
        reginput = save___1;
#line 1033
        scan = regnext(scan);
        }
#line 1028
        if ((unsigned long )scan != (unsigned long )((void *)0)) {
#line 1028
          if (! ((int )*scan == 6)) {
#line 1028
            goto while_break___0;
          }
        } else {
#line 1028
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1035
      return (0);
    }
#line 1039
    goto switch_break;
    case_11: /* CIL Label */ 
    case_10: /* CIL Label */ 
#line 1051
    nextch = (char )'\000';
#line 1052
    if ((int )*next == 8) {
#line 1053
      nextch = *(next + 3);
    }
#line 1054
    if ((int )*scan == 10) {
#line 1054
      min = 0;
    } else {
#line 1054
      min = 1;
    }
    {
#line 1055
    save___2 = reginput;
#line 1056
    no___1 = regrepeat(scan + 3);
    }
    {
#line 1057
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1057
      if (! (no___1 >= min)) {
#line 1057
        goto while_break___1;
      }
#line 1059
      if ((int )nextch == 0) {
#line 1059
        goto _L;
      } else
#line 1059
      if ((int const   )*reginput == (int const   )nextch) {
        _L: /* CIL Label */ 
        {
#line 1060
        tmp___9 = regmatch(next);
        }
#line 1060
        if (tmp___9) {
#line 1061
          return (1);
        }
      }
#line 1063
      no___1 --;
#line 1064
      reginput = save___2 + no___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1066
    return (0);
#line 1068
    goto switch_break;
    case_0: /* CIL Label */ 
#line 1070
    return (1);
#line 1071
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1073
    regerror("memory corruption");
    }
#line 1074
    return (0);
#line 1075
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1078
    scan = next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1085
  regerror("corrupted pointers");
  }
#line 1086
  return (0);
}
}
#line 1092 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/regexp.c"
static int regrepeat(char *p ) 
{ 
  register int count ;
  register char const   *scan ;
  register char *opnd ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 1095
  count = 0;
#line 1099
  scan = reginput;
#line 1100
  opnd = p + 3;
  {
#line 1102
  if ((int )*p == 3) {
#line 1102
    goto case_3;
  }
#line 1106
  if ((int )*p == 8) {
#line 1106
    goto case_8;
  }
#line 1112
  if ((int )*p == 4) {
#line 1112
    goto case_4;
  }
#line 1118
  if ((int )*p == 5) {
#line 1118
    goto case_5;
  }
#line 1124
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 1103
  tmp = strlen(scan);
#line 1103
  count = (int )tmp;
#line 1104
  scan += count;
  }
#line 1105
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 1107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1107
    if (! ((int )*opnd == (int )*scan)) {
#line 1107
      goto while_break;
    }
#line 1108
    count ++;
#line 1109
    scan ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1111
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 1113
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1113
    if ((int const   )*scan != 0) {
      {
#line 1113
      tmp___0 = strchr((char const   *)opnd, (int )*scan);
      }
#line 1113
      if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 1113
        goto while_break___0;
      }
    } else {
#line 1113
      goto while_break___0;
    }
#line 1114
    count ++;
#line 1115
    scan ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1117
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 1119
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1119
    if ((int const   )*scan != 0) {
      {
#line 1119
      tmp___1 = strchr((char const   *)opnd, (int )*scan);
      }
#line 1119
      if (! ((unsigned long )tmp___1 == (unsigned long )((void *)0))) {
#line 1119
        goto while_break___1;
      }
    } else {
#line 1119
      goto while_break___1;
    }
#line 1120
    count ++;
#line 1121
    scan ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1123
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1125
  regerror("internal foulup");
#line 1126
  count = 0;
  }
#line 1127
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1129
  reginput = scan;
#line 1131
  return (count);
}
}
#line 1137 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/regexp.c"
static char *regnext(char *p ) 
{ 
  register int offset ;

  {
#line 1142
  if ((unsigned long )p == (unsigned long )(& regdummy)) {
#line 1143
    return ((char *)((void *)0));
  }
#line 1145
  offset = (((int )*(p + 1) & 255) << 8) + ((int )*(p + 2) & 255);
#line 1146
  if (offset == 0) {
#line 1147
    return ((char *)((void *)0));
  }
#line 1149
  if ((int )*p == 7) {
#line 1150
    return (p - offset);
  } else {
#line 1152
    return (p + offset);
  }
}
}
#line 1321 "/home/june/repo/benchmarks/collector/temp/ftjam-2.5.2/regexp.c"
void regerror(char const   *s ) 
{ 


  {
  {
#line 1324
  printf((char const   */* __restrict  */)"re error %s\n", s);
  }
#line 1325
  return;
}
}
