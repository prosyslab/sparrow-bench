/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 128 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 159 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt64_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 48 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino_t ino_t;
#line 60 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 65 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 119 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat64 {
   __dev_t st_dev ;
   __ino64_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 37 "/usr/include/utime.h"
struct utimbuf {
   __time_t actime ;
   __time_t modtime ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 37 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent64 {
   __ino64_t d_ino ;
   __off64_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 47 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/zlibc.h"
struct FilenameActions {
   int fa_type ;
   char *name ;
   int namelength ;
   int pipe_mode ;
   dev_t dev ;
   ino_t ino ;
   int is_initialized ;
};
#line 47 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/zlibc.h"
typedef struct FilenameActions FilenameActions;
#line 91 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/zlibc.h"
struct CommandActions {
   char *name ;
   int cm_type ;
   FilenameActions *actions ;
};
#line 91 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/zlibc.h"
typedef struct CommandActions CommandActions;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_terminated_23 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_stopped_24 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_23 __wait_terminated ;
   struct __anonstruct___wait_stopped_24 __wait_stopped ;
};
#line 335 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/open.c"
union __anonunion_60 {
   int __in ;
   int __i ;
};
#line 335 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/open.c"
union __anonunion_61 {
   int __in ;
   int __i ;
};
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 38 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/parseconfig.c"
struct token_table {
   char *name ;
   int value ;
};
#line 181 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/zlibc.h"
struct commands_line {
   char *name ;
   int mode ;
   int modemask ;
   struct commands_line *globalnext ;
   struct commands_line *localnext ;
   int generation ;
   char class[16] ;
   int defined ;
};
#line 181 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/zlibc.h"
typedef struct commands_line commands_line;
#line 803 "/usr/include/unistd.h"
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) symlink)(char const   *file_name1 ,
                                                                                         char const   *file_name2 ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/zlibc.h"
int _zlibc_init(void) ;
#line 161
void zlib_initialise(void) ;
#line 162
int zlib_getfiletype(char const   *name , int fd ) ;
#line 167
char *zlib_ext ;
#line 169
int zlib_mode ;
#line 31 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/direct_sys.h"
int (*zlib_real_xstat)(int vers , char const   * , struct stat * ) ;
#line 47
int (*zlib_real_symlink)(char const   * , char const   * ) ;
#line 15 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/stat.h"
__inline static int ___zlibc_nativestat(char const   *name , struct stat *buf ) 
{ 
  int tmp ;

  {
  {
#line 17
  tmp = (*zlib_real_xstat)(1, name, buf);
  }
#line 17
  return (tmp);
}
}
#line 12 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/symlink.c"
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) symlink)(char const   *file_name1 ,
                                                                                         char const   *file_name2 ) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/symlink.c"
int ( __attribute__((__nonnull__(1,2), __leaf__)) symlink)(char const   *file_name1 ,
                                                           char const   *file_name2 ) 
{ 
  int st ;
  struct stat buf ;
  char newname1[4102] ;
  char newname2[4102] ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 17
  _zlibc_init();
#line 20
  st = ___zlibc_nativestat(file_name1, & buf);
  }
#line 21
  if (st < 0) {
    {
#line 21
    tmp___3 = __errno_location();
    }
#line 21
    if (*tmp___3 == 2) {
      {
#line 25
      zlib_initialise();
      }
#line 26
      if (! (zlib_mode & 2)) {
        {
#line 26
        tmp___2 = zlib_getfiletype(file_name1, -1);
        }
#line 26
        if ((tmp___2 & 7) != 5) {
          {
#line 29
          strncpy((char */* __restrict  */)(newname1), (char const   */* __restrict  */)file_name1,
                  (size_t )1024);
#line 30
          strcat((char */* __restrict  */)(newname1), (char const   */* __restrict  */)zlib_ext);
#line 32
          st = ___zlibc_nativestat((char const   *)(newname1), & buf);
          }
#line 35
          if (st >= 0) {
#line 35
            goto _L;
          } else {
            {
#line 35
            tmp___1 = __errno_location();
            }
#line 35
            if (*tmp___1 != 2) {
              _L: /* CIL Label */ 
              {
#line 36
              tmp = __errno_location();
#line 36
              *tmp = 0;
#line 37
              strncpy((char */* __restrict  */)(newname2), (char const   */* __restrict  */)file_name2,
                      (size_t )1024);
#line 38
              strcat((char */* __restrict  */)(newname2), (char const   */* __restrict  */)zlib_ext);
#line 39
              tmp___0 = (*zlib_real_symlink)((char const   *)(newname1), (char const   *)(newname2));
              }
#line 39
              return (tmp___0);
            }
          }
        }
      }
    }
  }
  {
#line 45
  tmp___4 = __errno_location();
#line 45
  *tmp___4 = 0;
#line 46
  tmp___5 = (*zlib_real_symlink)(file_name1, file_name2);
  }
#line 46
  return (tmp___5);
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 501
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchdir)(int __fd ) ;
#line 545
extern char **environ ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 681
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getgid)(void) ;
#line 684
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getegid)(void) ;
#line 1058
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) syscall)(long __sysno 
                                                                               , ...) ;
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 64 "/usr/include/dlfcn.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(2), __leaf__)) dlsym)(void * __restrict  __handle ,
                                                                                              char const   * __restrict  __name ) ;
#line 98 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/zlibc.h"
CommandActions zlib_commandActions[39] ;
#line 163
void zlib_getuserconf(char *progname , FilenameActions **filenameActions___0 , int *mode ,
                      int *modemask ) ;
#line 167 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/zlibc.h"
char *zlib_ext  ;
#line 168 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/zlibc.h"
int zlib_extlen  ;
#line 169 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/zlibc.h"
int zlib_mode  ;
#line 170 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/zlibc.h"
char *zlib_tmp  ;
#line 171 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/zlibc.h"
char **zlib_uncompressor  ;
#line 6 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/direct_sys.h"
int (*zlib_real_access)(char const   * , int  )  ;
#line 7 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/direct_sys.h"
int (*zlib_real_chmod)(char const   * , mode_t  )  ;
#line 8 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/direct_sys.h"
int (*zlib_real_chown)(char const   * , uid_t  , gid_t  )  ;
#line 9 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/direct_sys.h"
int (*zlib_real_getdents)(unsigned int  , struct dirent * , unsigned int  )  ;
#line 12 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/direct_sys.h"
int (*zlib_real_getdents64)(unsigned int  , struct dirent64 * , unsigned int  )  ;
#line 15 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/direct_sys.h"
int (*zlib_real_link)(char const   * , char const   * )  ;
#line 17 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/direct_sys.h"
int (*zlib_real_open)(char const   * , int  , mode_t  )  ;
#line 19 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/direct_sys.h"
FILE *(*zlib_real_fopen)(char const   * , char const   *mode )  ;
#line 20 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/direct_sys.h"
FILE *(*zlib_real_fopen64)(char const   * , char const   *mode )  ;
#line 23 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/direct_sys.h"
struct dirent *(*zlib_real_readdir)(DIR * )  ;
#line 25 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/direct_sys.h"
struct dirent64 *(*zlib_real_readdir64)(DIR * )  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/direct_sys.h"
int (*zlib_real_readlink)(char const   * , char * , size_t  )  ;
#line 28 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/direct_sys.h"
int (*zlib_real_rename)(char const   * , char const   * )  ;
#line 31 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/direct_sys.h"
int (*zlib_real_xstat)(int vers , char const   * , struct stat * )  ;
#line 32 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/direct_sys.h"
int (*zlib_real_lxstat)(int vers , char const   * , struct stat * )  ;
#line 39 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/direct_sys.h"
int (*zlib_real_xstat64)(int vers , char const   * , struct stat64 * )  ;
#line 40 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/direct_sys.h"
int (*zlib_real_lxstat64)(int vers , char const   * , struct stat64 * )  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/direct_sys.h"
int (*zlib_real_symlink)(char const   * , char const   * )  ;
#line 48 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/direct_sys.h"
int (*zlib_real_unlink)(char const   * )  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/direct_sys.h"
int (*zlib_real_utime)(char const   * , struct utimbuf * )  ;
#line 50 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/direct_sys.h"
int (*zlib_real_utimes)(char const   * , struct timeval * )  ;
#line 53 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/direct_sys.h"
ssize_t (*zlib_real_getxattr)(char const   * , char const   * , void * , size_t  )  ;
#line 54 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/direct_sys.h"
ssize_t (*zlib_real_lgetxattr)(char const   * , char const   * , void * , size_t  )  ;
#line 55 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/direct_sys.h"
int (*zlib_real_setxattr)(char const   * , char const   * , void const   * , size_t  ,
                          int  )  ;
#line 57 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/direct_sys.h"
int (*zlib_real_lsetxattr)(char const   * , char const   * , void const   * , size_t  ,
                           int  )  ;
#line 59 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/direct_sys.h"
ssize_t (*zlib_real_listxattr)(char const   * , char * , size_t  )  ;
#line 60 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/direct_sys.h"
ssize_t (*zlib_real_llistxattr)(char const   * , char * , size_t  )  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/direct_sys.h"
int (*zlib_real_removexattr)(char const   * , char const   * )  ;
#line 62 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/direct_sys.h"
int (*zlib_real_lremovexattr)(char const   * , char const   * )  ;
#line 14 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/filetype.c"
static int is_initialised  =    0;
#line 15 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/filetype.c"
static FilenameActions *filenameActions  ;
#line 16 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/filetype.c"
static char *default_uncompressor[3]  = {      (char *)"/bin/gzip",      (char *)"-dc",      (char *)0};
#line 19 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/filetype.c"
static char *custom_uncompressor[2]  = {      (char *)0,      (char *)0};
#line 41 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/filetype.c"
static void remove_ld_preload(void) 
{ 
  char preload_name[12] ;
  char *uncompr ;
  int i ;
  char *rptr ;
  char *lastbegin ;
  char *wptr ;
  int comp ;
  int atbegin ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 42
  if (zlib_mode & 64) {
#line 43
    preload_name[0] = (char )'L';
#line 43
    preload_name[1] = (char )'D';
#line 43
    preload_name[2] = (char )'_';
#line 43
    preload_name[3] = (char )'P';
#line 43
    preload_name[4] = (char )'R';
#line 43
    preload_name[5] = (char )'E';
#line 43
    preload_name[6] = (char )'L';
#line 43
    preload_name[7] = (char )'O';
#line 43
    preload_name[8] = (char )'A';
#line 43
    preload_name[9] = (char )'D';
#line 43
    preload_name[10] = (char )'=';
#line 43
    preload_name[11] = (char )'\000';
#line 44
    uncompr = (char *)"/uncompress.o";
#line 46
    i = 0;
    {
#line 46
    while (1) {
      while_continue: /* CIL Label */ ;
#line 46
      if (! *(environ + i)) {
#line 46
        goto while_break;
      }
      {
#line 47
      tmp___1 = strncmp((char const   *)*(environ + i), (char const   *)(preload_name),
                        sizeof(preload_name) - 1UL);
      }
#line 47
      if (! tmp___1) {
#line 49
        rptr = (*(environ + i) + sizeof(preload_name)) - 1;
#line 50
        lastbegin = rptr;
#line 51
        wptr = rptr;
#line 52
        comp = 1;
#line 53
        atbegin = 1;
#line 54
        lastbegin = wptr;
        {
#line 55
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 56
          if ((int )*rptr == 58) {
#line 57
            if ((int )*(uncompr + comp) == 0) {
#line 58
              wptr = lastbegin;
#line 59
              if (atbegin) {
#line 60
                rptr ++;
#line 61
                comp = 1;
#line 62
                goto while_continue___0;
              }
            }
#line 65
            comp = 1;
#line 66
            lastbegin = wptr;
#line 67
            atbegin = 0;
          } else
#line 68
          if ((int )*rptr == 0) {
#line 69
            if ((int )*(uncompr + comp) == 0) {
#line 70
              wptr = lastbegin;
            }
#line 72
            *wptr = (char )'\000';
#line 73
            goto while_break___0;
          } else
#line 74
          if ((int )*rptr == (int )*(uncompr + comp)) {
#line 75
            comp ++;
          } else {
#line 77
            comp = 0;
          }
#line 79
          tmp = wptr;
#line 79
          wptr ++;
#line 79
          tmp___0 = rptr;
#line 79
          rptr ++;
#line 79
          *tmp = *tmp___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 46
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 84
  return;
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/filetype.c"
static char *mode_table[5]  = {      (char *)"DISABLE",      (char *)"READDIR_COMPR",      (char *)"VERBOSE",      (char *)"UNLINK", 
        (char *)"NOCONF"};
#line 94 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/filetype.c"
void zlib_initialise(void) 
{ 
  int modemask ;
  int olderrno ;
  unsigned int i ;
  char env_buffer[1024] ;
  char *value ;
  int *tmp ;
  CommandActions *cma ;
  char static_cmdline[1025] ;
  int fd ;
  int n ;
  char *cmdline ;
  char *progname ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  __uid_t tmp___7 ;
  __uid_t tmp___8 ;
  __gid_t tmp___9 ;
  __gid_t tmp___10 ;
  long tmp___11 ;
  ssize_t tmp___12 ;
  int zerosfound ;
  int tmp___13 ;
  int *tmp___14 ;

  {
  {
#line 105
  tmp = __errno_location();
#line 105
  olderrno = *tmp;
  }
#line 106
  if (! is_initialised) {
    {
#line 114
    progname = (char *)0;
#line 116
    modemask = 0;
#line 116
    zlib_mode = modemask;
#line 118
    zlib_ext = (char *)".gz";
#line 119
    tmp___0 = strlen((char const   *)zlib_ext);
#line 119
    zlib_extlen = (int )tmp___0;
#line 120
    zlib_uncompressor = default_uncompressor;
#line 121
    zlib_tmp = (char *)"/tmp";
#line 124
    tmp___7 = getuid();
#line 124
    tmp___8 = geteuid();
    }
#line 124
    if (tmp___7 == tmp___8) {
#line 124
      goto _L;
    } else {
      {
#line 124
      tmp___9 = getgid();
#line 124
      tmp___10 = getegid();
      }
#line 124
      if (tmp___9 == tmp___10) {
        _L: /* CIL Label */ 
        {
#line 125
        zlib_tmp = getenv("LD_ZLIB_TMP");
        }
#line 126
        if ((unsigned long )zlib_tmp == (unsigned long )((char *)0)) {
#line 127
          zlib_tmp = (char *)"/tmp";
        }
        {
#line 129
        zlib_ext = getenv("LD_ZLIB_EXT");
        }
#line 130
        if ((unsigned long )zlib_ext == (unsigned long )((char *)0)) {
#line 131
          zlib_ext = (char *)".gz";
        }
        {
#line 132
        tmp___1 = strlen((char const   *)zlib_ext);
#line 132
        zlib_extlen = (int )tmp___1;
        }
#line 133
        if (zlib_extlen > 5) {
          {
#line 134
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"extension too long, taking default\n");
#line 135
          zlib_ext = (char *)".gz";
          }
        }
        {
#line 137
        custom_uncompressor[0] = getenv("LD_ZLIB_UNCOMPRESSOR");
        }
#line 138
        if (custom_uncompressor[0]) {
#line 139
          zlib_uncompressor = custom_uncompressor;
        } else {
#line 141
          zlib_uncompressor = default_uncompressor;
        }
        {
#line 143
        strcpy((char */* __restrict  */)(env_buffer), (char const   */* __restrict  */)"LD_ZLIB_");
#line 144
        i = 0U;
        }
        {
#line 144
        while (1) {
          while_continue: /* CIL Label */ ;
#line 144
          if (! ((unsigned long )i < sizeof(mode_table) / sizeof(char *))) {
#line 144
            goto while_break;
          }
          {
#line 145
          strcpy((char */* __restrict  */)(env_buffer + (sizeof("LD_ZLIB_") - 1UL)),
                 (char const   */* __restrict  */)mode_table[i]);
#line 146
          value = getenv((char const   *)(env_buffer));
          }
#line 146
          if (value) {
            {
#line 147
            tmp___4 = strcmp((char const   *)value, "on");
            }
#line 147
            if (tmp___4 == 0) {
#line 148
              zlib_mode |= 1 << (i + 1U);
            } else {
              {
#line 147
              tmp___5 = strcmp((char const   *)value, "1");
              }
#line 147
              if (tmp___5 == 0) {
#line 148
                zlib_mode |= 1 << (i + 1U);
              } else {
                {
#line 150
                tmp___2 = strcmp((char const   *)value, "off");
                }
#line 150
                if (tmp___2) {
                  {
#line 150
                  tmp___3 = strcmp((char const   *)value, "0");
                  }
#line 150
                  if (tmp___3) {
#line 151
                    goto __Cont;
                  }
                }
              }
            }
#line 152
            modemask |= 1 << (i + 1U);
          }
          __Cont: /* CIL Label */ 
#line 144
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 155
        if (zlib_mode & 2) {
          {
#line 156
          is_initialised = 2;
#line 157
          tmp___6 = __errno_location();
#line 157
          *tmp___6 = olderrno;
          }
#line 158
          return;
        }
      }
    }
    {
#line 165
    cmdline = static_cmdline;
#line 166
    strcpy((char */* __restrict  */)cmdline, (char const   */* __restrict  */)"unknown");
#line 167
    tmp___11 = syscall(2L, "/proc/self/cmdline", 0);
#line 167
    fd = (int )tmp___11;
    }
#line 168
    if (fd > 0) {
      {
#line 169
      *(cmdline + 1024) = (char )'\000';
#line 170
      tmp___12 = read(fd, (void *)cmdline, (size_t )1024);
#line 170
      n = (int )tmp___12;
      }
#line 171
      if (n < 1) {
#line 172
        *(cmdline + 0) = (char )'\000';
      } else {
#line 174
        *(cmdline + n) = (char )'\000';
      }
      {
#line 175
      close(fd);
      }
    } else {
      {
#line 181
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 184
        if ((unsigned long )environ == (unsigned long )((char **)0)) {
#line 185
          cmdline = (char *)"";
#line 186
          goto while_break___0;
        }
#line 188
        cmdline = *environ;
#line 190
        if ((unsigned long )cmdline == (unsigned long )((char *)0)) {
#line 191
          cmdline = (char *)"";
#line 192
          goto while_break___0;
        }
#line 195
        zerosfound = 0;
        {
#line 196
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 196
          if (! (zerosfound < 2)) {
#line 196
            goto while_break___1;
          }
#line 197
          cmdline --;
#line 198
          if ((int )*cmdline == 0) {
#line 199
            zerosfound ++;
          } else {
#line 201
            zerosfound = 0;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 203
        cmdline += 2;
#line 181
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 207
    progname = strrchr((char const   *)cmdline, '/');
    }
#line 209
    if (! progname) {
#line 210
      progname = cmdline;
    } else {
#line 212
      progname ++;
    }
#line 214
    if (zlib_mode & 8) {
      {
#line 215
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"progname = %s\n",
              progname);
      }
    }
#line 217
    is_initialised = 1;
#line 221
    if (! (zlib_mode & 32)) {
      {
#line 222
      zlib_getuserconf(progname, & filenameActions, & zlib_mode, & modemask);
      }
    }
#line 224
    if (modemask != 95) {
#line 226
      cma = zlib_commandActions;
      {
#line 227
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 227
        if (cma->name) {
          {
#line 227
          tmp___13 = strcmp((char const   *)cma->name, (char const   *)progname);
          }
#line 227
          if (! tmp___13) {
#line 227
            goto while_break___2;
          }
        } else {
#line 227
          goto while_break___2;
        }
#line 228
        cma ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 230
      if ((modemask & 1) == 0) {
#line 231
        filenameActions = cma->actions;
      }
#line 233
      zlib_mode |= cma->cm_type & ~ modemask;
    }
    {
#line 237
    remove_ld_preload();
#line 238
    is_initialised = 2;
    }
  }
  {
#line 241
  tmp___14 = __errno_location();
#line 241
  *tmp___14 = olderrno;
  }
#line 242
  return;
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/filetype.c"
static int _is_rtld_initialized  =    0;
#line 306 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/filetype.c"
int _zlibc_init(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  void *tmp___24 ;
  void *tmp___25 ;
  void *tmp___26 ;
  void *tmp___27 ;
  void *tmp___28 ;

  {
#line 308
  if (_is_rtld_initialized) {
#line 309
    return (0);
  }
  {
#line 311
  _is_rtld_initialized = 1;
#line 313
  tmp = dlsym((void */* __restrict  */)((void *)-1L), (char const   */* __restrict  */)"access");
#line 313
  zlib_real_access = (int (*)(char const   * , int  ))tmp;
#line 314
  tmp___0 = dlsym((void */* __restrict  */)((void *)-1L), (char const   */* __restrict  */)"chmod");
#line 314
  zlib_real_chmod = (int (*)(char const   * , mode_t  ))tmp___0;
#line 315
  tmp___1 = dlsym((void */* __restrict  */)((void *)-1L), (char const   */* __restrict  */)"chown");
#line 315
  zlib_real_chown = (int (*)(char const   * , uid_t  , gid_t  ))tmp___1;
#line 316
  tmp___2 = dlsym((void */* __restrict  */)((void *)-1L), (char const   */* __restrict  */)"_getdents");
#line 316
  zlib_real_getdents = (int (*)(unsigned int  , struct dirent * , unsigned int  ))tmp___2;
#line 318
  tmp___3 = dlsym((void */* __restrict  */)((void *)-1L), (char const   */* __restrict  */)"_getdents64");
#line 318
  zlib_real_getdents64 = (int (*)(unsigned int  , struct dirent64 * , unsigned int  ))tmp___3;
#line 320
  tmp___4 = dlsym((void */* __restrict  */)((void *)-1L), (char const   */* __restrict  */)"link");
#line 320
  zlib_real_link = (int (*)(char const   * , char const   * ))tmp___4;
#line 324
  tmp___5 = dlsym((void */* __restrict  */)((void *)-1L), (char const   */* __restrict  */)"_open");
#line 324
  zlib_real_open = (int (*)(char const   * , int  , mode_t  ))tmp___5;
  }
#line 326
  if ((unsigned long )zlib_real_open == (unsigned long )((void *)0)) {
    {
#line 327
    tmp___6 = dlsym((void */* __restrict  */)((void *)-1L), (char const   */* __restrict  */)"open");
#line 327
    zlib_real_open = (int (*)(char const   * , int  , mode_t  ))tmp___6;
    }
  }
  {
#line 329
  tmp___7 = dlsym((void */* __restrict  */)((void *)-1L), (char const   */* __restrict  */)"fopen");
#line 329
  zlib_real_fopen = (FILE *(*)(char const   * , char const   *mode ))tmp___7;
#line 330
  tmp___8 = dlsym((void */* __restrict  */)((void *)-1L), (char const   */* __restrict  */)"fopen64");
#line 330
  zlib_real_fopen64 = (FILE *(*)(char const   * , char const   *mode ))tmp___8;
#line 332
  tmp___9 = dlsym((void */* __restrict  */)((void *)-1L), (char const   */* __restrict  */)"readdir");
#line 332
  zlib_real_readdir = (struct dirent *(*)(DIR * ))tmp___9;
#line 333
  tmp___10 = dlsym((void */* __restrict  */)((void *)-1L), (char const   */* __restrict  */)"readdir64");
#line 333
  zlib_real_readdir64 = (struct dirent64 *(*)(DIR * ))tmp___10;
#line 334
  tmp___11 = dlsym((void */* __restrict  */)((void *)-1L), (char const   */* __restrict  */)"readlink");
#line 334
  zlib_real_readlink = (int (*)(char const   * , char * , size_t  ))tmp___11;
#line 335
  tmp___12 = dlsym((void */* __restrict  */)((void *)-1L), (char const   */* __restrict  */)"rename");
#line 335
  zlib_real_rename = (int (*)(char const   * , char const   * ))tmp___12;
#line 336
  tmp___13 = dlsym((void */* __restrict  */)((void *)-1L), (char const   */* __restrict  */)"symlink");
#line 336
  zlib_real_symlink = (int (*)(char const   * , char const   * ))tmp___13;
#line 337
  tmp___14 = dlsym((void */* __restrict  */)((void *)-1L), (char const   */* __restrict  */)"unlink");
#line 337
  zlib_real_unlink = (int (*)(char const   * ))tmp___14;
#line 338
  tmp___15 = dlsym((void */* __restrict  */)((void *)-1L), (char const   */* __restrict  */)"utime");
#line 338
  zlib_real_utime = (int (*)(char const   * , struct utimbuf * ))tmp___15;
#line 339
  tmp___16 = dlsym((void */* __restrict  */)((void *)-1L), (char const   */* __restrict  */)"utimes");
#line 339
  zlib_real_utimes = (int (*)(char const   * , struct timeval * ))tmp___16;
#line 342
  tmp___17 = dlsym((void */* __restrict  */)((void *)-1L), (char const   */* __restrict  */)"__xstat");
#line 342
  zlib_real_xstat = (int (*)(int vers , char const   * , struct stat * ))tmp___17;
#line 343
  tmp___18 = dlsym((void */* __restrict  */)((void *)-1L), (char const   */* __restrict  */)"__lxstat");
#line 343
  zlib_real_lxstat = (int (*)(int vers , char const   * , struct stat * ))tmp___18;
#line 351
  tmp___19 = dlsym((void */* __restrict  */)((void *)-1L), (char const   */* __restrict  */)"__xstat64");
#line 351
  zlib_real_xstat64 = (int (*)(int vers , char const   * , struct stat64 * ))tmp___19;
#line 352
  tmp___20 = dlsym((void */* __restrict  */)((void *)-1L), (char const   */* __restrict  */)"__lxstat64");
#line 352
  zlib_real_lxstat64 = (int (*)(int vers , char const   * , struct stat64 * ))tmp___20;
#line 361
  tmp___21 = dlsym((void */* __restrict  */)((void *)-1L), (char const   */* __restrict  */)"getxattr");
#line 361
  zlib_real_getxattr = (ssize_t (*)(char const   * , char const   * , void * , size_t  ))tmp___21;
#line 362
  tmp___22 = dlsym((void */* __restrict  */)((void *)-1L), (char const   */* __restrict  */)"lgetxattr");
#line 362
  zlib_real_lgetxattr = (ssize_t (*)(char const   * , char const   * , void * , size_t  ))tmp___22;
#line 363
  tmp___23 = dlsym((void */* __restrict  */)((void *)-1L), (char const   */* __restrict  */)"setxattr");
#line 363
  zlib_real_setxattr = (int (*)(char const   * , char const   * , void const   * ,
                                size_t  , int  ))tmp___23;
#line 364
  tmp___24 = dlsym((void */* __restrict  */)((void *)-1L), (char const   */* __restrict  */)"lsetxattr");
#line 364
  zlib_real_lsetxattr = (int (*)(char const   * , char const   * , void const   * ,
                                 size_t  , int  ))tmp___24;
#line 365
  tmp___25 = dlsym((void */* __restrict  */)((void *)-1L), (char const   */* __restrict  */)"listxattr");
#line 365
  zlib_real_listxattr = (ssize_t (*)(char const   * , char * , size_t  ))tmp___25;
#line 366
  tmp___26 = dlsym((void */* __restrict  */)((void *)-1L), (char const   */* __restrict  */)"llistxattr");
#line 366
  zlib_real_llistxattr = (ssize_t (*)(char const   * , char * , size_t  ))tmp___26;
#line 367
  tmp___27 = dlsym((void */* __restrict  */)((void *)-1L), (char const   */* __restrict  */)"removexattr");
#line 367
  zlib_real_removexattr = (int (*)(char const   * , char const   * ))tmp___27;
#line 368
  tmp___28 = dlsym((void */* __restrict  */)((void *)-1L), (char const   */* __restrict  */)"lremovexattr");
#line 368
  zlib_real_lremovexattr = (int (*)(char const   * , char const   * ))tmp___28;
#line 371
  zlib_initialise();
  }
#line 372
  return (0);
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/filetype.c"
static int masks[5]  = {      7,      24,      96,      384, 
        1536};
#line 387 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/filetype.c"
static void quick_stat(char const   *name , dev_t *dev , ino_t *ino ) 
{ 
  int olderrno ;
  int st ;
  struct stat buf ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 393
  tmp = __errno_location();
#line 393
  olderrno = *tmp;
#line 394
  st = ___zlibc_nativestat(name, & buf);
#line 395
  tmp___0 = __errno_location();
#line 395
  *tmp___0 = olderrno;
  }
#line 396
  if (st < 0) {
#line 398
    *ino = (ino_t )0;
#line 399
    *dev = (dev_t )0;
  } else {
#line 401
    *dev = buf.st_dev;
#line 402
    *ino = buf.st_ino;
  }
#line 404
  return;
}
}
#line 406 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/filetype.c"
static void initialize_fa(FilenameActions *fa ) 
{ 


  {
#line 408
  if (fa->is_initialized) {
#line 409
    return;
  }
  {
#line 410
  fa->is_initialized = 1;
#line 411
  quick_stat((char const   *)fa->name, & fa->dev, & fa->ino);
  }
#line 412
  return;
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/filetype.c"
static int check_subdir(char const   *name , int dirlength , int fd , FilenameActions *fa ,
                        int subdir ) 
{ 
  char dirname[4097] ;
  struct stat buf ;
  dev_t last_dev ;
  ino_t last_ino ;
  int cwd ;
  int cfd ;
  int closefd ;
  int r ;

  {
  {
#line 419
  last_dev = (dev_t )0;
#line 420
  last_ino = (ino_t )0;
#line 423
  closefd = 0;
#line 426
  initialize_fa(fa);
  }
#line 427
  if (! fa->ino) {
#line 428
    return (0);
  }
#line 430
  if (fd == -1) {
#line 431
    if (dirlength - 1 > 4096) {
#line 432
      return (0);
    }
#line 433
    if (! dirlength) {
      {
#line 434
      strcpy((char */* __restrict  */)(dirname), (char const   */* __restrict  */)".");
      }
    } else {
      {
#line 436
      strncpy((char */* __restrict  */)(dirname), (char const   */* __restrict  */)name,
              (size_t )(dirlength - 1));
      }
    }
    {
#line 437
    fd = (*zlib_real_open)((char const   *)(dirname), 0, (mode_t )0);
#line 437
    closefd = fd;
    }
#line 438
    if (fd < 0) {
#line 439
      return (0);
    }
  }
#line 442
  cwd = -1;
#line 443
  cfd = fd;
  {
#line 444
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 445
    fstat(cfd, & buf);
    }
#line 446
    if (cwd >= 0) {
      {
#line 447
      close(cfd);
      }
    }
#line 448
    if (buf.st_dev == fa->dev) {
#line 448
      if (buf.st_ino == fa->ino) {
#line 450
        r = 1;
#line 451
        goto while_break;
      }
    }
#line 453
    if (! subdir) {
#line 454
      r = 0;
#line 455
      goto while_break;
    }
#line 457
    if (cwd >= 0) {
#line 457
      if (buf.st_dev == last_dev) {
#line 457
        if (buf.st_ino == last_ino) {
#line 461
          r = 0;
#line 462
          goto while_break;
        }
      }
    }
#line 464
    last_dev = buf.st_dev;
#line 465
    last_ino = buf.st_ino;
#line 467
    if (cwd < 0) {
      {
#line 469
      cwd = (*zlib_real_open)(".", 0, (mode_t )0);
      }
#line 470
      if (cwd < 0) {
#line 471
        r = 0;
#line 472
        goto while_break;
      }
      {
#line 474
      fchdir(fd);
      }
    }
    {
#line 476
    chdir("..");
#line 477
    cfd = (*zlib_real_open)(".", 0, (mode_t )0);
    }
#line 478
    if (cfd < 0) {
#line 479
      r = 0;
#line 480
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 502
  if (cwd != -1) {
    {
#line 504
    fchdir(cwd);
#line 505
    close(cwd);
    }
  }
#line 508
  if (closefd) {
    {
#line 509
    close(fd);
    }
  }
#line 510
  return (r);
}
}
#line 513 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/filetype.c"
int zlib_getfiletype(char const   *name , int fd ) 
{ 
  char const   *basename___0 ;
  FilenameActions *fa ;
  int length ;
  int dirlength ;
  int basenamelength ;
  int pipe_mode ;
  unsigned int i ;
  int match ;
  int dostop ;
  int dev ;
  struct stat buf ;
  int olderrno ;
  int st ;
  char *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  char namez[4102] ;
  int *tmp___12 ;
  __pid_t tmp___13 ;

  {
  {
#line 531
  dev = -1;
#line 532
  tmp = strrchr(name, '/');
#line 532
  basename___0 = (char const   *)tmp;
  }
#line 533
  if (! basename___0) {
#line 534
    basename___0 = name;
  } else {
#line 536
    basename___0 ++;
  }
  {
#line 538
  dirlength = (int )(basename___0 - name);
#line 539
  tmp___0 = strlen(basename___0);
#line 539
  basenamelength = (int )tmp___0;
#line 540
  length = dirlength + basenamelength;
#line 542
  zlib_initialise();
  }
#line 544
  if (is_initialised == 1) {
#line 546
    return (3);
  }
#line 548
  fa = filenameActions;
#line 549
  pipe_mode = 0;
  {
#line 550
  while (1) {
    while_continue: /* CIL Label */ ;
#line 551
    match = 0;
    {
#line 557
    if (fa->fa_type == 6) {
#line 557
      goto case_6;
    }
#line 557
    if (fa->fa_type == 0) {
#line 557
      goto case_6;
    }
#line 560
    if (fa->fa_type == 1) {
#line 560
      goto case_1;
    }
#line 567
    if (fa->fa_type == 2) {
#line 567
      goto case_2;
    }
#line 574
    if (fa->fa_type == 3) {
#line 574
      goto case_3;
    }
#line 577
    if (fa->fa_type == 5) {
#line 577
      goto case_5;
    }
#line 580
    if (fa->fa_type == 4) {
#line 580
      goto case_4;
    }
#line 584
    if (fa->fa_type == 7) {
#line 584
      goto case_7;
    }
#line 604
    goto switch_default;
    case_6: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 558
    match = 1;
#line 559
    goto switch_break;
    case_1: /* CIL Label */ 
#line 561
    if (fd == -1) {
#line 561
      if ((int const   )*(name + 0) == 47) {
#line 562
        if (fa->namelength == dirlength) {
          {
#line 562
          tmp___1 = strncmp((char const   *)fa->name, name, (size_t )dirlength);
          }
#line 562
          if (tmp___1) {
#line 562
            tmp___2 = 0;
          } else {
#line 562
            tmp___2 = 1;
          }
        } else {
#line 562
          tmp___2 = 0;
        }
#line 562
        match = tmp___2;
      } else {
        {
#line 565
        match = check_subdir(name, dirlength, fd, fa, 0);
        }
      }
    } else {
      {
#line 565
      match = check_subdir(name, dirlength, fd, fa, 0);
      }
    }
#line 566
    goto switch_break;
    case_2: /* CIL Label */ 
#line 568
    if (fd == -1) {
#line 568
      if ((int const   )*(name + 0) == 47) {
#line 569
        if (fa->namelength <= dirlength) {
          {
#line 569
          tmp___3 = strncmp((char const   *)fa->name, name, (size_t )fa->namelength);
          }
#line 569
          if (tmp___3) {
#line 569
            tmp___4 = 0;
          } else {
#line 569
            tmp___4 = 1;
          }
        } else {
#line 569
          tmp___4 = 0;
        }
#line 569
        match = tmp___4;
      } else {
        {
#line 572
        match = check_subdir(name, dirlength, fd, fa, 1);
        }
      }
    } else {
      {
#line 572
      match = check_subdir(name, dirlength, fd, fa, 1);
      }
    }
#line 573
    goto switch_break;
    case_3: /* CIL Label */ 
#line 575
    if (fa->namelength == basenamelength) {
      {
#line 575
      tmp___5 = strcmp((char const   *)fa->name, basename___0);
      }
#line 575
      if (tmp___5) {
#line 575
        tmp___6 = 0;
      } else {
#line 575
        tmp___6 = 1;
      }
    } else {
#line 575
      tmp___6 = 0;
    }
#line 575
    match = tmp___6;
#line 576
    goto switch_break;
    case_5: /* CIL Label */ 
#line 578
    if (fa->namelength == length) {
      {
#line 578
      tmp___7 = strcmp((char const   *)fa->name, name);
      }
#line 578
      if (tmp___7) {
#line 578
        tmp___8 = 0;
      } else {
#line 578
        tmp___8 = 1;
      }
    } else {
#line 578
      tmp___8 = 0;
    }
#line 578
    match = tmp___8;
#line 579
    goto switch_break;
    case_4: /* CIL Label */ 
#line 581
    if (fa->namelength <= basenamelength) {
      {
#line 581
      tmp___9 = strcmp((char const   *)fa->name, basename___0 + (basenamelength - fa->namelength));
      }
#line 581
      if (tmp___9) {
#line 581
        tmp___10 = 0;
      } else {
#line 581
        tmp___10 = 1;
      }
    } else {
#line 581
      tmp___10 = 0;
    }
#line 581
    match = tmp___10;
#line 583
    goto switch_break;
    case_7: /* CIL Label */ 
#line 585
    if (dev == -1) {
      {
#line 586
      tmp___11 = __errno_location();
#line 586
      olderrno = *tmp___11;
      }
#line 588
      if (fd != -1) {
        {
#line 589
        st = fstat(fd, & buf);
        }
      } else {
        {
#line 592
        strncpy((char */* __restrict  */)(namez), (char const   */* __restrict  */)name,
                (size_t )4096);
#line 593
        strncat((char */* __restrict  */)(namez), (char const   */* __restrict  */)zlib_ext,
                (size_t )4096);
#line 594
        st = ___zlibc_nativestat((char const   *)(namez), & buf);
        }
      }
      {
#line 596
      tmp___12 = __errno_location();
#line 596
      *tmp___12 = olderrno;
      }
#line 597
      if (st < 0) {
#line 598
        dev = 0;
      } else {
#line 600
        dev = (int )buf.st_dev;
      }
    }
#line 602
    match = buf.st_dev == (__dev_t )fa->namelength;
#line 603
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 605
    tmp___13 = getpid();
#line 605
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error in filenameActions %x in %d\n",
            fa->fa_type, tmp___13);
#line 607
    sleep(3U);
    }
#line 608
    return (0);
#line 609
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 611
    if (match) {
#line 612
      dostop = 1;
#line 613
      i = 0U;
      {
#line 613
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 613
        if (! ((unsigned long )i < sizeof(masks) / sizeof(masks[0]))) {
#line 613
          goto while_break___0;
        }
#line 614
        if (! (pipe_mode & masks[i])) {
#line 615
          pipe_mode |= fa->pipe_mode & masks[i];
        }
#line 616
        if (! (pipe_mode & masks[i])) {
#line 617
          dostop = 0;
        }
#line 613
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 619
      if (dostop) {
#line 623
        return (pipe_mode);
      } else
#line 619
      if (fa->fa_type == 0) {
#line 623
        return (pipe_mode);
      }
    }
#line 626
    fa ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 287 "/usr/include/unistd.h"
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *file_name ,
                                                                                      int mode ) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/access.c"
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *file_name ,
                                                                                      int mode ) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/access.c"
int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *file_name ,
                                                        int mode ) 
{ 
  int ret ;
  int ft ;
  int *tmp ;
  char newname[4102] ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 16
  _zlibc_init();
#line 17
  ret = (*zlib_real_access)(file_name, mode);
  }
#line 18
  if (ret >= 0) {
#line 19
    return (ret);
  } else {
    {
#line 18
    tmp = __errno_location();
    }
#line 18
    if (*tmp != 2) {
#line 19
      return (ret);
    }
  }
  {
#line 24
  zlib_initialise();
  }
#line 25
  if (zlib_mode & 2) {
#line 26
    return (ret);
  }
  {
#line 28
  ft = zlib_getfiletype(file_name, -1);
  }
#line 29
  if (zlib_mode & 8) {
    {
#line 30
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"accessing %s %x\n",
            file_name, mode);
    }
  }
#line 31
  if ((ft & 7) == 5) {
#line 32
    return (ret);
  }
#line 34
  if (! (ft & 168)) {
#line 34
    if (mode & 2) {
#line 36
      return (ret);
    }
  }
  {
#line 38
  strncpy((char */* __restrict  */)(newname), (char const   */* __restrict  */)file_name,
          (size_t )1024);
#line 39
  strcat((char */* __restrict  */)(newname), (char const   */* __restrict  */)zlib_ext);
#line 41
  ret = (*zlib_real_access)((char const   *)(newname), mode);
  }
#line 42
  if (ret < 0) {
    {
#line 42
    tmp___1 = __errno_location();
    }
#line 42
    if (*tmp___1 == 22) {
      {
#line 43
      tmp___0 = __errno_location();
#line 43
      *tmp___0 = 2;
      }
    }
  }
#line 44
  return (ret);
}
}
#line 12 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/lgetxattr.c"
int lgetxattr(char const   *file_name , char const   *name , void *value , size_t size ) 
{ 
  int st ;
  char newname[4102] ;
  ssize_t tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  ssize_t tmp___3 ;

  {
  {
#line 18
  _zlibc_init();
#line 19
  tmp = (*zlib_real_lgetxattr)(file_name, name, value, size);
#line 19
  st = (int )tmp;
  }
#line 20
  if (st >= 0) {
#line 21
    return (st);
  } else {
    {
#line 20
    tmp___0 = __errno_location();
    }
#line 20
    if (*tmp___0 != 2) {
#line 21
      return (st);
    }
  }
  {
#line 23
  zlib_initialise();
  }
#line 24
  if (zlib_mode & 2) {
#line 25
    return (st);
  }
  {
#line 26
  tmp___1 = zlib_getfiletype(file_name, -1);
  }
#line 26
  if ((tmp___1 & 7) == 5) {
#line 27
    return (st);
  }
#line 29
  if (zlib_mode & 8) {
    {
#line 30
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Getxattr %s\n",
            file_name);
    }
  }
  {
#line 32
  strncpy((char */* __restrict  */)(newname), (char const   */* __restrict  */)file_name,
          (size_t )1024);
#line 33
  strcat((char */* __restrict  */)(newname), (char const   */* __restrict  */)zlib_ext);
#line 35
  tmp___2 = __errno_location();
#line 35
  *tmp___2 = 0;
#line 36
  tmp___3 = (*zlib_real_lgetxattr)((char const   *)(newname), name, value, size);
  }
#line 36
  return ((int )tmp___3);
}
}
#line 12 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/getxattr.c"
ssize_t getxattr(char const   *file_name , char const   *name , void *value , size_t size ) 
{ 
  int st ;
  char newname[4102] ;
  ssize_t tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  ssize_t tmp___3 ;

  {
  {
#line 18
  _zlibc_init();
#line 19
  tmp = (*zlib_real_getxattr)(file_name, name, value, size);
#line 19
  st = (int )tmp;
  }
#line 21
  if (st >= 0) {
#line 22
    return ((ssize_t )st);
  } else {
    {
#line 21
    tmp___0 = __errno_location();
    }
#line 21
    if (*tmp___0 != 2) {
#line 22
      return ((ssize_t )st);
    }
  }
  {
#line 24
  zlib_initialise();
  }
#line 25
  if (zlib_mode & 2) {
#line 26
    return ((ssize_t )st);
  }
  {
#line 27
  tmp___1 = zlib_getfiletype(file_name, -1);
  }
#line 27
  if ((tmp___1 & 7) == 5) {
#line 28
    return ((ssize_t )st);
  }
#line 30
  if (zlib_mode & 8) {
    {
#line 31
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Getxattr %s\n",
            file_name);
    }
  }
  {
#line 33
  strncpy((char */* __restrict  */)(newname), (char const   */* __restrict  */)file_name,
          (size_t )1024);
#line 34
  strcat((char */* __restrict  */)(newname), (char const   */* __restrict  */)zlib_ext);
#line 36
  tmp___2 = __errno_location();
#line 36
  *tmp___2 = 0;
#line 37
  tmp___3 = (*zlib_real_getxattr)((char const   *)(newname), name, value, size);
  }
#line 37
  return (tmp___3);
}
}
#line 2 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/readdir_tmpl.c"
static void adjust_name(int fd , struct dirent *de ) 
{ 
  int l ;
  char *extension ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 7
  if (zlib_mode & 8) {
    {
#line 8
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Adjust name: %s\n",
            de->d_name);
    }
  }
  {
#line 10
  tmp = strlen((char const   *)(de->d_name));
#line 10
  l = (int )tmp;
  }
#line 13
  if (l > zlib_extlen) {
    {
#line 16
    extension = (de->d_name + l) - zlib_extlen;
#line 17
    tmp___1 = strncmp((char const   *)extension, (char const   *)zlib_ext, (size_t )zlib_extlen);
    }
#line 17
    if (tmp___1 == 0) {
      {
#line 18
      *extension = (char )'\000';
#line 19
      tmp___0 = zlib_getfiletype((char const   *)(de->d_name), fd);
      }
#line 19
      if ((tmp___0 & 7) >= 4) {
#line 21
        if (zlib_mode & 8) {
          {
#line 22
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Leave %s compressed\n",
                  de->d_name);
          }
        }
#line 24
        *extension = *zlib_ext;
      }
    }
  }
#line 32
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/readdir_tmpl.c"
int getdents(int fd , struct dirent *dirp , unsigned int count ) 
{ 
  int left ;
  int tmp ;

  {
  {
#line 65
  _zlibc_init();
#line 66
  tmp = (*zlib_real_getdents)((unsigned int )fd, dirp, count);
#line 66
  count = (unsigned int )tmp;
  }
#line 67
  if (count <= 0U) {
#line 68
    return ((int )count);
  }
  {
#line 70
  zlib_initialise();
  }
#line 72
  if (zlib_mode & 6) {
#line 73
    return ((int )count);
  }
#line 75
  if (zlib_mode & 8) {
    {
#line 76
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getdents\n");
    }
  }
#line 78
  left = (int )count;
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (! left) {
#line 78
      goto while_break;
    }
    {
#line 82
    adjust_name(fd, dirp);
#line 78
    left -= (int )dirp->d_reclen;
#line 78
    dirp = (struct dirent *)((char *)dirp + (int )dirp->d_reclen);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  return ((int )count);
}
}
#line 2 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/readdir_tmpl.c"
static void adjust_name64(int fd , struct dirent64 *de ) 
{ 
  int l ;
  char *extension ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 7
  if (zlib_mode & 8) {
    {
#line 8
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Adjust name: %s\n",
            de->d_name);
    }
  }
  {
#line 10
  tmp = strlen((char const   *)(de->d_name));
#line 10
  l = (int )tmp;
  }
#line 13
  if (l > zlib_extlen) {
    {
#line 16
    extension = (de->d_name + l) - zlib_extlen;
#line 17
    tmp___1 = strncmp((char const   *)extension, (char const   *)zlib_ext, (size_t )zlib_extlen);
    }
#line 17
    if (tmp___1 == 0) {
      {
#line 18
      *extension = (char )'\000';
#line 19
      tmp___0 = zlib_getfiletype((char const   *)(de->d_name), fd);
      }
#line 19
      if ((tmp___0 & 7) >= 4) {
#line 21
        if (zlib_mode & 8) {
          {
#line 22
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Leave %s compressed\n",
                  de->d_name);
          }
        }
#line 24
        *extension = *zlib_ext;
      }
    }
  }
#line 32
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/readdir_tmpl.c"
int getdents64(int fd , struct dirent64 *dirp , unsigned int count ) 
{ 
  int left ;
  int tmp ;

  {
  {
#line 65
  _zlibc_init();
#line 66
  tmp = (*zlib_real_getdents64)((unsigned int )fd, dirp, count);
#line 66
  count = (unsigned int )tmp;
  }
#line 67
  if (count <= 0U) {
#line 68
    return ((int )count);
  }
  {
#line 70
  zlib_initialise();
  }
#line 72
  if (zlib_mode & 6) {
#line 73
    return ((int )count);
  }
#line 75
  if (zlib_mode & 8) {
    {
#line 76
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getdents\n");
    }
  }
#line 78
  left = (int )count;
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (! left) {
#line 78
      goto while_break;
    }
    {
#line 82
    adjust_name64(fd, dirp);
#line 78
    left -= (int )dirp->d_reclen;
#line 78
    dirp = (struct dirent64 *)((char *)dirp + (int )dirp->d_reclen);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  return ((int )count);
}
}
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 228 "/usr/include/x86_64-linux-gnu/sys/stat.h"
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat64)(char const   * __restrict  name ,
                                                                                        struct stat64 * __restrict  buf ) ;
#line 276
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat64)(char const   * __restrict  name ,
                                                                                         struct stat64 * __restrict  buf ) ;
#line 399
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3), __leaf__)) __fxstat)(int __ver ,
                                                                                               int __fildes ,
                                                                                               struct stat *__stat_buf ) ;
#line 401
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) __xstat)(int vers ,
                                                                                         char const   *name ,
                                                                                         struct stat *buf ) ;
#line 403
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) __lxstat)(int vers ,
                                                                                          char const   *name ,
                                                                                          struct stat *buf ) ;
#line 432
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3), __leaf__)) __fxstat64)(int __ver ,
                                                                                                 int __fildes ,
                                                                                                 struct stat64 *__stat_buf ) ;
#line 434
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) __xstat64)(int vers ,
                                                                                           char const   *name ,
                                                                                           struct stat64 *buf ) ;
#line 436
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) __lxstat64)(int vers ,
                                                                                            char const   *name ,
                                                                                            struct stat64 *buf ) ;
#line 1 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/stat_tmpl.h"
__inline static int ___zlibc_lxstat(int ver , char const   *file_name , struct stat *buf ) 
{ 
  int tmp ;

  {
  {
#line 5
  tmp = (*zlib_real_lxstat)(ver, file_name, buf);
  }
#line 5
  return (tmp);
}
}
#line 12 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/stat_tmpl.h"
__inline static int ___zlibc_xstat(int ver , char const   *file_name , struct stat *buf ) 
{ 
  int tmp ;

  {
  {
#line 16
  tmp = (*zlib_real_xstat)(ver, file_name, buf);
  }
#line 16
  return (tmp);
}
}
#line 1 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/stat_tmpl.h"
__inline static int ___zlibc_lxstat64(int ver , char const   *file_name , struct stat64 *buf ) 
{ 
  int tmp ;

  {
  {
#line 5
  tmp = (*zlib_real_lxstat64)(ver, file_name, buf);
  }
#line 5
  return (tmp);
}
}
#line 12 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/stat_tmpl.h"
__inline static int ___zlibc_xstat64(int ver , char const   *file_name , struct stat64 *buf ) 
{ 
  int tmp ;

  {
  {
#line 16
  tmp = (*zlib_real_xstat64)(ver, file_name, buf);
  }
#line 16
  return (tmp);
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/stat_tmpl.c"
static int zstat(int ver , char const   *name , char *newname , struct stat *buf ) 
{ 
  int fd ;
  int st ;
  int ft ;
  unsigned char size_buffer[4] ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 12
  ft = zlib_getfiletype(name, -1);
  }
#line 14
  if ((ft & 7) == 5) {
    {
#line 15
    tmp = __errno_location();
#line 15
    *tmp = 2;
    }
#line 16
    return (-1);
  }
#line 19
  if ((ft & 1536) == 512) {
    {
#line 20
    ___zlibc_xstat(ver, (char const   *)newname, buf);
    }
  } else {
    {
#line 22
    fd = (*zlib_real_open)((char const   *)newname, 2048, (mode_t )0);
    }
#line 24
    if (fd < 0) {
      {
#line 25
      tmp___0 = __errno_location();
      }
#line 25
      if (*tmp___0 == 2) {
#line 26
        return (-1);
      }
#line 27
      return (2);
    } else {
      {
#line 29
      st = __fxstat(ver, fd, buf);
      }
#line 31
      if (ver == 1) {
#line 34
        if (st < 0) {
          {
#line 35
          close(fd);
          }
#line 36
          return (st);
        }
#line 38
        if (! ((buf->st_mode & 61440U) == 32768U)) {
#line 40
          return (st);
        }
        {
#line 43
        lseek(fd, (__off_t )-4, 2);
#line 44
        read(fd, (void *)(size_buffer), (size_t )4);
#line 46
        buf->st_size = (__off_t )((((int )size_buffer[0] + ((int )size_buffer[1] << 8)) + ((int )size_buffer[2] << 16)) + ((int )size_buffer[3] << 24));
        }
      }
      {
#line 49
      close(fd);
      }
    }
  }
#line 54
  if (ver == 1) {
#line 59
    if ((ft & 7) == 3) {
#line 60
      buf->st_mode ^= 36864U;
    }
#line 63
    if (! (ft & 168)) {
#line 64
      buf->st_mode &= 4294967149U;
    }
  }
#line 70
  return (0);
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/stat_tmpl.c"
static int zlibc_xstat(int ver , char const   *file_name , struct stat *buf ) 
{ 
  int st ;
  int olderrno ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char newname[4102] ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 79
  tmp = __errno_location();
#line 79
  olderrno = *tmp;
#line 80
  tmp___0 = __errno_location();
#line 80
  *tmp___0 = 0;
#line 82
  st = ___zlibc_xstat(ver, file_name, buf);
  }
#line 84
  if (st >= 0) {
#line 85
    return (st);
  } else {
    {
#line 84
    tmp___1 = __errno_location();
    }
#line 84
    if (*tmp___1 != 2) {
#line 85
      return (st);
    }
  }
  {
#line 89
  zlib_initialise();
  }
#line 91
  if (zlib_mode & 2) {
    {
#line 92
    tmp___2 = __errno_location();
#line 92
    *tmp___2 = 2;
    }
#line 93
    return (st);
  }
#line 96
  if (zlib_mode & 8) {
    {
#line 97
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"stating %s\n",
            file_name);
    }
  }
  {
#line 99
  strncpy((char */* __restrict  */)(newname), (char const   */* __restrict  */)file_name,
          (size_t )4096);
#line 100
  strcat((char */* __restrict  */)(newname), (char const   */* __restrict  */)zlib_ext);
#line 102
  st = zstat(ver, file_name, newname, buf);
  }
#line 104
  if (zlib_mode & 8) {
    {
#line 105
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"stated %s, rv=%d\n",
            file_name, st);
    }
  }
#line 107
  if (st == 2) {
    {
#line 108
    st = ___zlibc_xstat(ver, (char const   *)(newname), buf);
    }
#line 109
    if (ver == 1) {
#line 110
      buf->st_size = (__off_t )0;
    }
  }
#line 113
  if (st < 0) {
    {
#line 114
    tmp___3 = __errno_location();
#line 114
    *tmp___3 = 2;
    }
#line 115
    return (st);
  }
  {
#line 120
  tmp___4 = __errno_location();
#line 120
  *tmp___4 = olderrno;
  }
#line 121
  return (st);
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/stat_tmpl.c"
static int zlibc_lxstat(int ver , char const   *file_name , struct stat *buf ) 
{ 
  int st ;
  int olderrno ;
  int *tmp ;
  int *tmp___0 ;
  char newname[4102] ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 129
  tmp = __errno_location();
#line 129
  olderrno = *tmp;
#line 130
  st = ___zlibc_lxstat(ver, file_name, buf);
  }
#line 132
  if (st >= 0) {
#line 133
    return (st);
  } else {
    {
#line 132
    tmp___0 = __errno_location();
    }
#line 132
    if (*tmp___0 != 2) {
#line 133
      return (st);
    }
  }
  {
#line 138
  zlib_initialise();
  }
#line 139
  if (zlib_mode & 2) {
    {
#line 140
    tmp___1 = __errno_location();
#line 140
    *tmp___1 = 2;
    }
#line 141
    return (st);
  }
#line 143
  if (zlib_mode & 8) {
    {
#line 144
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lstating %s\n",
            file_name);
    }
  }
  {
#line 146
  strncpy((char */* __restrict  */)(newname), (char const   */* __restrict  */)file_name,
          (size_t )4096);
#line 147
  strcat((char */* __restrict  */)(newname), (char const   */* __restrict  */)zlib_ext);
#line 149
  st = ___zlibc_lxstat(ver, (char const   *)(newname), buf);
  }
#line 151
  if (st < 0) {
    {
#line 152
    tmp___2 = __errno_location();
#line 152
    *tmp___2 = 2;
    }
#line 153
    return (st);
  }
#line 156
  if (ver == 1) {
#line 156
    if ((buf->st_mode & 61440U) == 40960U) {
#line 157
      if ((int )buf->st_size > zlib_extlen) {
#line 158
        buf->st_size -= (__off_t )zlib_extlen;
      }
      {
#line 159
      tmp___3 = __errno_location();
#line 159
      *tmp___3 = olderrno;
      }
#line 160
      return (st);
    }
  }
  {
#line 163
  st = zstat(ver, file_name, newname, buf);
  }
#line 164
  if (st == 2) {
#line 166
    st = 0;
  }
  {
#line 169
  tmp___4 = __errno_location();
#line 169
  *tmp___4 = olderrno;
  }
#line 170
  return (st);
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/stat_tmpl.c"
static int zstat64(int ver , char const   *name , char *newname , struct stat64 *buf ) 
{ 
  int fd ;
  int st ;
  int ft ;
  unsigned char size_buffer[4] ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 12
  ft = zlib_getfiletype(name, -1);
  }
#line 14
  if ((ft & 7) == 5) {
    {
#line 15
    tmp = __errno_location();
#line 15
    *tmp = 2;
    }
#line 16
    return (-1);
  }
#line 19
  if ((ft & 1536) == 512) {
    {
#line 20
    ___zlibc_xstat64(ver, (char const   *)newname, buf);
    }
  } else {
    {
#line 22
    fd = (*zlib_real_open)((char const   *)newname, 2048, (mode_t )0);
    }
#line 24
    if (fd < 0) {
      {
#line 25
      tmp___0 = __errno_location();
      }
#line 25
      if (*tmp___0 == 2) {
#line 26
        return (-1);
      }
#line 27
      return (2);
    } else {
      {
#line 29
      st = __fxstat64(ver, fd, buf);
      }
#line 31
      if (ver == 1) {
#line 34
        if (st < 0) {
          {
#line 35
          close(fd);
          }
#line 36
          return (st);
        }
#line 38
        if (! ((buf->st_mode & 61440U) == 32768U)) {
#line 40
          return (st);
        }
        {
#line 43
        lseek(fd, (__off_t )-4, 2);
#line 44
        read(fd, (void *)(size_buffer), (size_t )4);
#line 46
        buf->st_size = (__off_t )((((int )size_buffer[0] + ((int )size_buffer[1] << 8)) + ((int )size_buffer[2] << 16)) + ((int )size_buffer[3] << 24));
        }
      }
      {
#line 49
      close(fd);
      }
    }
  }
#line 54
  if (ver == 1) {
#line 59
    if ((ft & 7) == 3) {
#line 60
      buf->st_mode ^= 36864U;
    }
#line 63
    if (! (ft & 168)) {
#line 64
      buf->st_mode &= 4294967149U;
    }
  }
#line 70
  return (0);
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/stat_tmpl.c"
static int zlibc_xstat64(int ver , char const   *file_name , struct stat64 *buf ) 
{ 
  int st ;
  int olderrno ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char newname[4102] ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 79
  tmp = __errno_location();
#line 79
  olderrno = *tmp;
#line 80
  tmp___0 = __errno_location();
#line 80
  *tmp___0 = 0;
#line 82
  st = ___zlibc_xstat64(ver, file_name, buf);
  }
#line 84
  if (st >= 0) {
#line 85
    return (st);
  } else {
    {
#line 84
    tmp___1 = __errno_location();
    }
#line 84
    if (*tmp___1 != 2) {
#line 85
      return (st);
    }
  }
  {
#line 89
  zlib_initialise();
  }
#line 91
  if (zlib_mode & 2) {
    {
#line 92
    tmp___2 = __errno_location();
#line 92
    *tmp___2 = 2;
    }
#line 93
    return (st);
  }
#line 96
  if (zlib_mode & 8) {
    {
#line 97
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"stating %s\n",
            file_name);
    }
  }
  {
#line 99
  strncpy((char */* __restrict  */)(newname), (char const   */* __restrict  */)file_name,
          (size_t )4096);
#line 100
  strcat((char */* __restrict  */)(newname), (char const   */* __restrict  */)zlib_ext);
#line 102
  st = zstat64(ver, file_name, newname, buf);
  }
#line 104
  if (zlib_mode & 8) {
    {
#line 105
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"stated %s, rv=%d\n",
            file_name, st);
    }
  }
#line 107
  if (st == 2) {
    {
#line 108
    st = ___zlibc_xstat64(ver, (char const   *)(newname), buf);
    }
#line 109
    if (ver == 1) {
#line 110
      buf->st_size = (__off_t )0;
    }
  }
#line 113
  if (st < 0) {
    {
#line 114
    tmp___3 = __errno_location();
#line 114
    *tmp___3 = 2;
    }
#line 115
    return (st);
  }
  {
#line 120
  tmp___4 = __errno_location();
#line 120
  *tmp___4 = olderrno;
  }
#line 121
  return (st);
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/stat_tmpl.c"
static int zlibc_lxstat64(int ver , char const   *file_name , struct stat64 *buf ) 
{ 
  int st ;
  int olderrno ;
  int *tmp ;
  int *tmp___0 ;
  char newname[4102] ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 129
  tmp = __errno_location();
#line 129
  olderrno = *tmp;
#line 130
  st = ___zlibc_lxstat64(ver, file_name, buf);
  }
#line 132
  if (st >= 0) {
#line 133
    return (st);
  } else {
    {
#line 132
    tmp___0 = __errno_location();
    }
#line 132
    if (*tmp___0 != 2) {
#line 133
      return (st);
    }
  }
  {
#line 138
  zlib_initialise();
  }
#line 139
  if (zlib_mode & 2) {
    {
#line 140
    tmp___1 = __errno_location();
#line 140
    *tmp___1 = 2;
    }
#line 141
    return (st);
  }
#line 143
  if (zlib_mode & 8) {
    {
#line 144
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lstating %s\n",
            file_name);
    }
  }
  {
#line 146
  strncpy((char */* __restrict  */)(newname), (char const   */* __restrict  */)file_name,
          (size_t )4096);
#line 147
  strcat((char */* __restrict  */)(newname), (char const   */* __restrict  */)zlib_ext);
#line 149
  st = ___zlibc_lxstat64(ver, (char const   *)(newname), buf);
  }
#line 151
  if (st < 0) {
    {
#line 152
    tmp___2 = __errno_location();
#line 152
    *tmp___2 = 2;
    }
#line 153
    return (st);
  }
#line 156
  if (ver == 1) {
#line 156
    if ((buf->st_mode & 61440U) == 40960U) {
#line 157
      if ((int )buf->st_size > zlib_extlen) {
#line 158
        buf->st_size -= (__off_t )zlib_extlen;
      }
      {
#line 159
      tmp___3 = __errno_location();
#line 159
      *tmp___3 = olderrno;
      }
#line 160
      return (st);
    }
  }
  {
#line 163
  st = zstat64(ver, file_name, newname, buf);
  }
#line 164
  if (st == 2) {
#line 166
    st = 0;
  }
  {
#line 169
  tmp___4 = __errno_location();
#line 169
  *tmp___4 = olderrno;
  }
#line 170
  return (st);
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/stat.c"
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) __xstat)(int vers ,
                                                                                         char const   *name ,
                                                                                         struct stat *buf ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/stat.c"
int ( __attribute__((__nonnull__(2,3), __leaf__)) __xstat)(int vers , char const   *name ,
                                                           struct stat *buf ) 
{ 
  int tmp ;

  {
  {
#line 58
  _zlibc_init();
#line 59
  tmp = zlibc_xstat(vers, name, buf);
  }
#line 59
  return (tmp);
}
}
#line 62
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) __lxstat)(int vers ,
                                                                                          char const   *name ,
                                                                                          struct stat *buf ) ;
#line 62 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/stat.c"
int ( __attribute__((__nonnull__(2,3), __leaf__)) __lxstat)(int vers , char const   *name ,
                                                            struct stat *buf ) 
{ 
  int tmp ;

  {
  {
#line 64
  _zlibc_init();
#line 65
  tmp = zlibc_lxstat(vers, name, buf);
  }
#line 65
  return (tmp);
}
}
#line 70
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) __xstat64)(int vers ,
                                                                                           char const   *name ,
                                                                                           struct stat64 *buf ) ;
#line 70 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/stat.c"
int ( __attribute__((__nonnull__(2,3), __leaf__)) __xstat64)(int vers , char const   *name ,
                                                             struct stat64 *buf ) 
{ 
  int tmp ;

  {
  {
#line 72
  _zlibc_init();
#line 73
  tmp = zlibc_xstat64(vers, name, buf);
  }
#line 73
  return (tmp);
}
}
#line 76
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) __lxstat64)(int vers ,
                                                                                            char const   *name ,
                                                                                            struct stat64 *buf ) ;
#line 76 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/stat.c"
int ( __attribute__((__nonnull__(2,3), __leaf__)) __lxstat64)(int vers , char const   *name ,
                                                              struct stat64 *buf ) 
{ 
  int tmp ;

  {
  {
#line 78
  _zlibc_init();
#line 79
  tmp = zlibc_lxstat64(vers, name, buf);
  }
#line 79
  return (tmp);
}
}
#line 104
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat64)(char const   * __restrict  name ,
                                                                                        struct stat64 * __restrict  buf ) ;
#line 104 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/stat.c"
int ( __attribute__((__nonnull__(1,2), __leaf__)) stat64)(char const   * __restrict  name ,
                                                          struct stat64 * __restrict  buf ) 
{ 
  int tmp ;

  {
  {
#line 106
  _zlibc_init();
#line 107
  tmp = zlibc_xstat64(1, (char const   *)name, (struct stat64 *)buf);
  }
#line 107
  return (tmp);
}
}
#line 109
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat64)(char const   * __restrict  name ,
                                                                                         struct stat64 * __restrict  buf ) ;
#line 109 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/stat.c"
int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat64)(char const   * __restrict  name ,
                                                           struct stat64 * __restrict  buf ) 
{ 
  int tmp ;

  {
  {
#line 111
  _zlibc_init();
#line 112
  tmp = zlibc_lxstat64(1, (char const   *)name, (struct stat64 *)buf);
  }
#line 112
  return (tmp);
}
}
#line 180 "/usr/include/stdio.h"
 __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *file_name1 ,
                                                                      char const   *file_name2 ) ;
#line 6 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/stat.h"
__inline static int ___zlibc_testexistence(char const   *name ) 
{ 
  struct stat buf ;
  int tmp ;

  {
  {
#line 9
  tmp = (*zlib_real_lxstat)(1, name, & buf);
  }
#line 9
  return (tmp);
}
}
#line 12 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/rename.c"
 __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *file_name1 ,
                                                                      char const   *file_name2 ) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/rename.c"
int ( __attribute__((__leaf__)) rename)(char const   *file_name1 , char const   *file_name2 ) 
{ 
  int st ;
  char newname1[4102] ;
  char newname2[4102] ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 18
  _zlibc_init();
#line 19
  st = (*zlib_real_rename)(file_name1, file_name2);
  }
#line 21
  if (st >= 0) {
#line 22
    return (st);
  } else {
    {
#line 21
    tmp = __errno_location();
    }
#line 21
    if (*tmp != 2) {
#line 22
      return (st);
    }
  }
  {
#line 24
  zlib_initialise();
  }
#line 25
  if (zlib_mode & 2) {
#line 26
    return (st);
  }
  {
#line 27
  tmp___0 = zlib_getfiletype(file_name1, -1);
  }
#line 27
  if ((tmp___0 & 7) == 5) {
#line 28
    return (st);
  }
  {
#line 30
  strncpy((char */* __restrict  */)(newname1), (char const   */* __restrict  */)file_name1,
          (size_t )1024);
#line 31
  strcat((char */* __restrict  */)(newname1), (char const   */* __restrict  */)zlib_ext);
#line 33
  strncpy((char */* __restrict  */)(newname2), (char const   */* __restrict  */)file_name2,
          (size_t )1024);
#line 34
  strcat((char */* __restrict  */)(newname2), (char const   */* __restrict  */)zlib_ext);
#line 36
  tmp___1 = __errno_location();
#line 36
  *tmp___1 = 0;
#line 37
  st = (*zlib_real_rename)((char const   *)(newname1), (char const   *)(newname2));
  }
#line 38
  if (st >= 0) {
#line 39
    return (st);
  } else {
    {
#line 38
    tmp___2 = __errno_location();
    }
#line 38
    if (*tmp___2 != 22) {
#line 39
      return (st);
    }
  }
  {
#line 42
  st = ___zlibc_testexistence((char const   *)(newname1));
  }
#line 43
  if (st >= 0) {
    {
#line 45
    tmp___3 = __errno_location();
#line 45
    *tmp___3 = 22;
    }
#line 46
    return (-1);
  } else {
#line 48
    return (-1);
  }
}
}
#line 12 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/llistxattr.c"
int llistxattr(char const   *file_name , char *list , size_t size ) 
{ 
  int st ;
  char newname[4102] ;
  ssize_t tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  ssize_t tmp___3 ;

  {
  {
#line 17
  _zlibc_init();
#line 18
  tmp = (*zlib_real_llistxattr)(file_name, list, size);
#line 18
  st = (int )tmp;
  }
#line 20
  if (st >= 0) {
#line 21
    return (st);
  } else {
    {
#line 20
    tmp___0 = __errno_location();
    }
#line 20
    if (*tmp___0 != 2) {
#line 21
      return (st);
    }
  }
  {
#line 23
  zlib_initialise();
  }
#line 24
  if (zlib_mode & 2) {
#line 25
    return (st);
  }
  {
#line 26
  tmp___1 = zlib_getfiletype(file_name, -1);
  }
#line 26
  if ((tmp___1 & 7) == 5) {
#line 27
    return (st);
  }
#line 29
  if (zlib_mode & 8) {
    {
#line 30
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Getxattr %s\n",
            file_name);
    }
  }
  {
#line 32
  strncpy((char */* __restrict  */)(newname), (char const   */* __restrict  */)file_name,
          (size_t )1024);
#line 33
  strcat((char */* __restrict  */)(newname), (char const   */* __restrict  */)zlib_ext);
#line 35
  tmp___2 = __errno_location();
#line 35
  *tmp___2 = 0;
#line 36
  tmp___3 = (*zlib_real_llistxattr)((char const   *)(newname), list, size);
  }
#line 36
  return ((int )tmp___3);
}
}
#line 13 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/readlink.c"
int readlink(char const   *file_name , char *buf , size_t len ) 
{ 
  int st ;
  int olderrno ;
  int *tmp ;
  char newname[4102] ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 18
  _zlibc_init();
#line 19
  st = (*zlib_real_readlink)(file_name, buf, len);
  }
#line 21
  if (st >= 0) {
#line 22
    return (st);
  } else {
    {
#line 21
    tmp = __errno_location();
    }
#line 21
    if (*tmp != 2) {
#line 22
      return (st);
    }
  }
  {
#line 25
  tmp___0 = __errno_location();
#line 25
  olderrno = *tmp___0;
#line 27
  zlib_initialise();
  }
#line 28
  if (zlib_mode & 2) {
#line 29
    return (st);
  }
  {
#line 30
  tmp___1 = zlib_getfiletype(file_name, -1);
  }
#line 30
  if ((tmp___1 & 7) == 5) {
#line 31
    return (st);
  }
#line 34
  if (zlib_mode & 8) {
    {
#line 35
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"readlinking %s\n",
            file_name);
    }
  }
  {
#line 38
  strncpy((char */* __restrict  */)(newname), (char const   */* __restrict  */)file_name,
          (size_t )1024);
#line 39
  strcat((char */* __restrict  */)(newname), (char const   */* __restrict  */)zlib_ext);
#line 41
  st = (*zlib_real_readlink)((char const   *)(newname), buf, len);
  }
#line 42
  if (st < 0) {
    {
#line 43
    tmp___2 = __errno_location();
#line 43
    *tmp___2 = olderrno;
    }
#line 44
    return (st);
  }
  {
#line 47
  tmp___3 = strncmp((char const   *)((buf + st) - zlib_extlen), (char const   *)zlib_ext,
                    (size_t )zlib_extlen);
  }
#line 47
  if (! tmp___3) {
#line 48
    *(buf + (st - zlib_extlen)) = (char)0;
  }
  {
#line 50
  tmp___4 = __errno_location();
#line 50
  *tmp___4 = 0;
  }
#line 51
  return (st);
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/altnames.c"
__asm__(".globl _access; _access = access");
#line 8
__asm__(".globl _chmod; _chmod = chmod");
#line 10
__asm__(".globl _stat; _stat = stat");
#line 11
__asm__(".globl _lstat; _lstat = lstat");
#line 22
__asm__(".globl _link; _link = link");
#line 23
__asm__(".globl _symlink; _symlink = symlink");
#line 24
__asm__(".globl _rename; _rename = rename");
#line 26
__asm__(".globl _chown; _chown = chown");
#line 27
__asm__(".globl _getdents; _getdents = getdents");
#line 28
__asm__(".globl __getdents; __getdents = getdents");
#line 32
__asm__(".globl _getdents64; _getdents64 = getdents64");
#line 33
__asm__(".globl __getdents64; __getdents64 = getdents64");
#line 36
__asm__(".globl _open; _open = open");
#line 37
__asm__(".globl _open64; _open64 = open64");
#line 38
__asm__(".globl __open; __open = open");
#line 39
__asm__(".globl __open64; __open64 = open64");
#line 40
__asm__(".globl unlink; unlink = _unlink");
#line 41
__asm__(".globl readdir; readdir = _readdir");
#line 42
__asm__(".globl _readlink; _readlink = readlink");
#line 43
__asm__(".globl __readlink; __readlink = readlink");
#line 826 "/usr/include/unistd.h"
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *file_name ) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/unlink.c"
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *file_name ) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/unlink.c"
int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *file_name ) 
{ 
  int st ;
  char newname[4102] ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 17
  _zlibc_init();
#line 18
  st = (*zlib_real_unlink)(file_name);
  }
#line 20
  if (st >= 0) {
#line 21
    return (st);
  } else {
    {
#line 20
    tmp = __errno_location();
    }
#line 20
    if (*tmp != 2) {
#line 21
      return (st);
    }
  }
  {
#line 23
  zlib_initialise();
  }
#line 24
  if (zlib_mode & 2) {
#line 25
    return (st);
  }
  {
#line 26
  tmp___0 = zlib_getfiletype(file_name, -1);
  }
#line 26
  if ((tmp___0 & 7) == 5) {
#line 27
    return (st);
  }
#line 29
  if (zlib_mode & 8) {
    {
#line 30
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unlinking %s\n",
            file_name);
    }
  }
  {
#line 32
  strncpy((char */* __restrict  */)(newname), (char const   */* __restrict  */)file_name,
          (size_t )1024);
#line 33
  strcat((char */* __restrict  */)(newname), (char const   */* __restrict  */)zlib_ext);
#line 35
  st = 0;
  }
#line 36
  if (zlib_mode & 16) {
    {
#line 37
    st = (*zlib_real_unlink)((char const   *)(newname));
    }
  } else {
    {
#line 39
    st = ___zlibc_testexistence((char const   *)(newname));
    }
  }
#line 40
  if (st < 0) {
    {
#line 41
    tmp___1 = __errno_location();
#line 41
    *tmp___1 = 2;
    }
#line 42
    return (st);
  }
#line 46
  return (0);
}
}
#line 473 "/usr/include/unistd.h"
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chown)(char const   *file_name ,
                                                                                     __uid_t owner ,
                                                                                     __gid_t group ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/chown.c"
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chown)(char const   *file_name ,
                                                                                     __uid_t owner ,
                                                                                     __gid_t group ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/chown.c"
int ( __attribute__((__nonnull__(1), __leaf__)) chown)(char const   *file_name , __uid_t owner ,
                                                       __gid_t group ) 
{ 
  int st ;
  char newname[4102] ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 18
  _zlibc_init();
#line 19
  st = (*zlib_real_chown)(file_name, owner, group);
  }
#line 21
  if (st >= 0) {
#line 22
    return (st);
  } else {
    {
#line 21
    tmp = __errno_location();
    }
#line 21
    if (*tmp != 2) {
#line 22
      return (st);
    }
  }
  {
#line 24
  zlib_initialise();
  }
#line 25
  if (zlib_mode & 2) {
#line 26
    return (st);
  }
  {
#line 27
  tmp___0 = zlib_getfiletype(file_name, -1);
  }
#line 27
  if ((tmp___0 & 7) == 5) {
#line 28
    return (st);
  }
#line 30
  if (zlib_mode & 8) {
    {
#line 31
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Chowning %s\n",
            file_name);
    }
  }
  {
#line 33
  strncpy((char */* __restrict  */)(newname), (char const   */* __restrict  */)file_name,
          (size_t )1024);
#line 34
  strcat((char */* __restrict  */)(newname), (char const   */* __restrict  */)zlib_ext);
#line 36
  tmp___1 = __errno_location();
#line 36
  *tmp___1 = 0;
#line 37
  tmp___2 = (*zlib_real_chown)((char const   *)(newname), owner, group);
  }
#line 37
  return (tmp___2);
}
}
#line 12 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/lremovexattr.c"
int lremovexattr(char const   *file_name , char const   *name ) 
{ 
  int st ;
  char newname[4102] ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 17
  _zlibc_init();
#line 18
  st = (*zlib_real_lremovexattr)(file_name, name);
  }
#line 20
  if (st >= 0) {
#line 21
    return (st);
  } else {
    {
#line 20
    tmp = __errno_location();
    }
#line 20
    if (*tmp != 2) {
#line 21
      return (st);
    }
  }
  {
#line 23
  zlib_initialise();
  }
#line 24
  if (zlib_mode & 2) {
#line 25
    return (st);
  }
  {
#line 26
  tmp___0 = zlib_getfiletype(file_name, -1);
  }
#line 26
  if ((tmp___0 & 7) == 5) {
#line 27
    return (st);
  }
#line 29
  if (zlib_mode & 8) {
    {
#line 30
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Getxattr %s\n",
            file_name);
    }
  }
  {
#line 32
  strncpy((char */* __restrict  */)(newname), (char const   */* __restrict  */)file_name,
          (size_t )1024);
#line 33
  strcat((char */* __restrict  */)(newname), (char const   */* __restrict  */)zlib_ext);
#line 35
  tmp___1 = __errno_location();
#line 35
  *tmp___1 = 0;
#line 36
  tmp___2 = (*zlib_real_lremovexattr)((char const   *)(newname), name);
  }
#line 36
  return (tmp___2);
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 272 "/usr/include/stdio.h"
FILE *fopen(char const   * __restrict  path , char const   * __restrict  mode ) ;
#line 297
FILE *fopen64(char const   * __restrict  path , char const   * __restrict  mode ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 417 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 531
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 156 "/usr/include/fcntl.h"
int ( __attribute__((__nonnull__(1))) open64)(char const   *name , int flags  , ...) ;
#line 192
int ( __attribute__((__nonnull__(1))) creat)(char const   *name , mode_t mode ) ;
#line 102 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/open.c"
static char *zlib_compressor[3]  = {      (char *)"/bin/gzip",      (char *)"-c",      (char *)0};
#line 24
int open(char const   *name , int flags , mode_t mode ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/open.c"
int ( __attribute__((__nonnull__(1))) open64)(char const   *name , int flags  , ...) 
{ 
  va_list ap ;
  mode_t mode ;
  mode_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 29
  __builtin_va_start(ap, flags);
  }
#line 30
  if (flags & 64) {
    {
#line 31
    tmp___0 = __builtin_va_arg(ap, mode_t );
#line 31
    mode = tmp___0;
#line 32
    tmp___1 = open(name, flags, mode);
    }
#line 32
    return (tmp___1);
  } else {
    {
#line 34
    tmp___2 = open(name, flags, (mode_t )0);
    }
#line 34
    return (tmp___2);
  }
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/open.c"
int open(char const   *name , int flags , mode_t mode ) 
{ 
  int fd ;
  int zfd ;
  int pid ;
  int filetype ;
  int zflags ;
  int do_append ;
  int do_uncompress ;
  int do_create ;
  int have_filetype ;
  int tmp ;
  int stat_result ;
  int status ;
  struct stat buf ;
  int pipeout[2] ;
  char newname[4102] ;
  char _pname[4102] ;
  char const   *pname ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  __pid_t tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  __pid_t tmp___8 ;
  int *tmp___9 ;
  __pid_t tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  union __anonunion_60 __constr_expr_0 ;
  union __anonunion_61 __constr_expr_1 ;

  {
  {
#line 65
  _zlibc_init();
#line 66
  do_create = 0;
#line 66
  do_uncompress = do_create;
#line 66
  do_append = do_uncompress;
#line 66
  have_filetype = do_append;
#line 66
  filetype = have_filetype;
#line 68
  zflags = flags;
  }
#line 69
  if (flags & 64) {
    {
#line 70
    zlib_initialise();
#line 71
    have_filetype = 1;
    }
#line 72
    if (! (zlib_mode & 2)) {
      {
#line 73
      filetype = zlib_getfiletype(name, -1);
      }
#line 75
      if ((flags & 3) == 1) {
#line 75
        if (flags & 640) {
#line 75
          if (filetype & 8) {
#line 78
            do_create = 1;
          } else {
#line 75
            goto _L___2;
          }
        } else {
#line 75
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 79
      if ((flags & 3) == 1) {
#line 79
        if (flags & 1024) {
#line 79
          if (filetype & 32) {
#line 82
            do_append = 1;
          } else {
#line 79
            goto _L___0;
          }
        } else {
#line 79
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 83
      if ((flags & 3) != 0) {
#line 83
        if (filetype & 128) {
#line 85
          do_uncompress = 1;
        }
      }
#line 86
      if ((do_create | do_append) | do_uncompress) {
#line 87
        zflags &= -65;
      }
    }
  }
  {
#line 91
  fd = (*zlib_real_open)(name, zflags, mode);
  }
#line 99
  if (fd >= 0) {
#line 100
    return (fd);
  } else {
    {
#line 99
    tmp___0 = __errno_location();
    }
#line 99
    if (*tmp___0 != 2) {
#line 100
      return (fd);
    }
  }
#line 102
  if (! have_filetype) {
    {
#line 103
    zlib_initialise();
    }
  }
#line 105
  if (zlib_mode & 2) {
#line 106
    return (fd);
  }
#line 108
  if (! have_filetype) {
    {
#line 109
    filetype = zlib_getfiletype(name, -1);
    }
  }
#line 111
  if (zlib_mode & 8) {
    {
#line 112
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"opening %s %o\n",
            name, flags);
    }
  }
  {
#line 114
  strncpy((char */* __restrict  */)(newname), (char const   */* __restrict  */)name,
          (size_t )4096);
#line 115
  strcat((char */* __restrict  */)(newname), (char const   */* __restrict  */)zlib_ext);
#line 119
  zflags = flags;
  }
#line 120
  if ((flags & 3) == 1) {
#line 120
    if (flags & 512) {
#line 120
      if (filetype & 8) {
#line 123
        do_create = 1;
      } else {
#line 120
        goto _L___7;
      }
    } else {
#line 120
      goto _L___7;
    }
  } else
  _L___7: /* CIL Label */ 
#line 124
  if ((flags & 3) == 1) {
#line 124
    if (flags & 1024) {
#line 124
      if (filetype & 32) {
#line 127
        do_append = 1;
      } else {
#line 124
        goto _L___5;
      }
    } else {
#line 124
      goto _L___5;
    }
  } else
  _L___5: /* CIL Label */ 
#line 128
  if ((flags & 3) != 0) {
#line 128
    if (filetype & 128) {
#line 130
      zflags = 0;
#line 131
      do_uncompress = 1;
    } else {
#line 128
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 132
  if ((flags & 3) != 0) {
#line 133
    return (fd);
  }
  {
#line 135
  zfd = (*zlib_real_open)((char const   *)(newname), zflags, mode);
  }
#line 137
  if (zfd < 0) {
#line 138
    if (flags & 64) {
      {
#line 139
      tmp___1 = (*zlib_real_open)(name, flags, mode);
      }
#line 139
      return (tmp___1);
    }
    {
#line 140
    tmp___3 = __errno_location();
    }
#line 140
    if (*tmp___3 == 22) {
      {
#line 141
      tmp___2 = __errno_location();
#line 141
      *tmp___2 = 2;
      }
    }
#line 142
    return (zfd);
  }
#line 145
  if (do_append) {
#line 145
    goto _L___8;
  } else
#line 145
  if (do_create) {
    _L___8: /* CIL Label */ 
    {
#line 147
    tmp___4 = pipe((int *)(pipeout));
    }
#line 147
    if (tmp___4 < 0) {
#line 148
      return (-1);
    }
    {
#line 151
    pid = fork();
    }
    {
#line 152
    if (pid == 0) {
#line 152
      goto case_0;
    }
#line 189
    if (pid == -1) {
#line 189
      goto case_neg_1___0;
    }
#line 151
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 153
    tmp___5 = fork();
    }
    {
#line 154
    if (tmp___5 == 0) {
#line 154
      goto case_0___0;
    }
#line 182
    if (tmp___5 == -1) {
#line 182
      goto case_neg_1;
    }
#line 186
    goto switch_default;
    case_0___0: /* CIL Label */ 
#line 155
    if (zfd == 0) {
      {
#line 157
      tmp = dup(zfd);
#line 158
      close(zfd);
#line 159
      zfd = tmp;
      }
    }
#line 161
    if (pipeout[0] != 0) {
      {
#line 162
      close(0);
#line 163
      dup(pipeout[0]);
      }
    }
#line 165
    if (zfd != 1) {
      {
#line 166
      close(1);
#line 167
      dup(zfd);
      }
    }
    {
#line 170
    close(pipeout[0]);
#line 171
    close(pipeout[1]);
    }
#line 173
    if (! (zlib_mode & 8)) {
      {
#line 174
      close(2);
      }
    }
    {
#line 176
    execvp((char const   *)zlib_compressor[0], (char * const  *)(zlib_compressor));
    }
#line 178
    if (zlib_mode & 8) {
      {
#line 179
      perror("exec compressor");
#line 180
      exit(1);
      }
    }
    case_neg_1: /* CIL Label */ 
#line 183
    if (zlib_mode & 8) {
      {
#line 184
      perror("fork error");
      }
    }
    {
#line 185
    exit(1);
    }
    switch_default: /* CIL Label */ 
    {
#line 187
    exit(0);
    }
    switch_break___0: /* CIL Label */ ;
    }
    case_neg_1___0: /* CIL Label */ 
    {
#line 190
    tmp___6 = __errno_location();
#line 190
    *tmp___6 = 2;
    }
#line 191
    return (-1);
    switch_break: /* CIL Label */ ;
    }
    {
#line 193
    close(pipeout[0]);
#line 195
    close(zfd);
#line 196
    fd = dup(pipeout[1]);
#line 197
    close(pipeout[1]);
#line 199
    wait((union wait *)(& status));
    }
#line 200
    return (fd);
  }
#line 203
  if (! do_uncompress) {
#line 203
    if ((filetype & 7) >= 2) {
      {
#line 205
      tmp___7 = pipe((int *)(pipeout));
      }
#line 205
      if (tmp___7 < 0) {
#line 206
        return (-1);
      }
      {
#line 209
      pid = fork();
      }
      {
#line 210
      if (pid == 0) {
#line 210
        goto case_0___1;
      }
#line 242
      if (pid == -1) {
#line 242
        goto case_neg_1___2;
      }
#line 209
      goto switch_break___1;
      case_0___1: /* CIL Label */ 
      {
#line 211
      tmp___8 = fork();
      }
      {
#line 212
      if (tmp___8 == 0) {
#line 212
        goto case_0___2;
      }
#line 235
      if (tmp___8 == -1) {
#line 235
        goto case_neg_1___1;
      }
#line 239
      goto switch_default___0;
      case_0___2: /* CIL Label */ 
#line 213
      if (zfd != 0) {
        {
#line 214
        close(0);
#line 215
        dup(zfd);
        }
      }
#line 218
      if (pipeout[1] != 1) {
        {
#line 219
        close(1);
#line 220
        dup(pipeout[1]);
        }
      }
      {
#line 223
      close(pipeout[0]);
#line 224
      close(pipeout[1]);
      }
#line 226
      if (! (zlib_mode & 8)) {
        {
#line 227
        close(2);
        }
      }
      {
#line 229
      execvp((char const   *)*(zlib_uncompressor + 0), (char * const  *)zlib_uncompressor);
      }
#line 231
      if (zlib_mode & 8) {
        {
#line 232
        perror("exec uncompressor");
#line 233
        exit(1);
        }
      }
      case_neg_1___1: /* CIL Label */ 
#line 236
      if (zlib_mode & 8) {
        {
#line 237
        perror("fork error");
        }
      }
      {
#line 238
      exit(1);
      }
      switch_default___0: /* CIL Label */ 
      {
#line 240
      exit(0);
      }
      switch_break___2: /* CIL Label */ ;
      }
      case_neg_1___2: /* CIL Label */ 
      {
#line 243
      tmp___9 = __errno_location();
#line 243
      *tmp___9 = 2;
      }
#line 244
      return (-1);
      switch_break___1: /* CIL Label */ ;
      }
      {
#line 246
      close(pipeout[1]);
#line 249
      close(zfd);
#line 250
      fd = dup(pipeout[0]);
#line 251
      close(pipeout[0]);
#line 252
      wait((union wait *)(& status));
      }
    } else {
#line 203
      goto _L___9;
    }
  } else {
    _L___9: /* CIL Label */ 
    {
#line 254
    stat_result = fstat(zfd, & buf);
#line 256
    mode = (mode_t )256;
    }
#line 257
    if (! do_uncompress) {
      {
#line 258
      tmp___10 = getpid();
#line 258
      sprintf((char */* __restrict  */)(_pname), (char const   */* __restrict  */)"%s/pipe.%d",
              zlib_tmp, tmp___10);
#line 259
      pname = (char const   *)(_pname);
      }
    } else {
#line 261
      mode = (mode_t )0;
#line 262
      pname = name;
    }
    {
#line 264
    (*zlib_real_unlink)(pname);
#line 265
    pipeout[0] = (*zlib_real_open)(pname, 194, mode);
    }
#line 267
    if (pipeout[0] < 0) {
#line 268
      if (zlib_mode & 8) {
        {
#line 269
        perror("could not create uncompressed file");
        }
      }
      {
#line 270
      tmp___11 = __errno_location();
#line 270
      *tmp___11 = 2;
      }
#line 271
      return (-1);
    }
    {
#line 274
    pid = fork();
    }
    {
#line 275
    if (pid == 0) {
#line 275
      goto case_0___3;
    }
#line 293
    if (pid == -1) {
#line 293
      goto case_neg_1___3;
    }
#line 274
    goto switch_break___3;
    case_0___3: /* CIL Label */ 
#line 276
    if (zfd != 0) {
      {
#line 277
      close(0);
#line 278
      dup(zfd);
      }
    }
#line 281
    if (pipeout[0] != 1) {
      {
#line 282
      close(1);
#line 283
      dup(pipeout[0]);
      }
    }
#line 286
    if (! (zlib_mode & 8)) {
      {
#line 287
      close(2);
      }
    }
    {
#line 289
    execvp((char const   *)*(zlib_uncompressor + 0), (char * const  *)zlib_uncompressor);
    }
#line 290
    if (zlib_mode & 8) {
      {
#line 291
      perror("exec uncompressor");
      }
    }
    {
#line 292
    exit(1);
    }
    case_neg_1___3: /* CIL Label */ 
    {
#line 294
    tmp___12 = __errno_location();
#line 294
    *tmp___12 = 2;
    }
#line 295
    return (-1);
    switch_break___3: /* CIL Label */ ;
    }
    {
#line 298
    wait((union wait *)(& status));
#line 301
    close(pipeout[0]);
    }
#line 303
    if (do_uncompress) {
#line 305
      if (stat_result >= 0) {
#line 306
        mode = buf.st_mode;
      } else {
#line 308
        mode = (mode_t )384;
      }
      {
#line 309
      (*zlib_real_chmod)(pname, mode);
      }
    }
    {
#line 327
    close(zfd);
#line 330
    fd = (*zlib_real_open)(pname, flags, mode);
    }
#line 332
    if (! do_uncompress) {
      {
#line 333
      (*zlib_real_unlink)(pname);
      }
    } else
#line 335
    if (fd >= 0) {
#line 335
      __constr_expr_0.__in = status;
#line 335
      if ((__constr_expr_0.__i & 127) == 0) {
#line 335
        __constr_expr_1.__in = status;
#line 335
        if ((__constr_expr_1.__i & 65280) >> 8 == 0) {
          {
#line 337
          (*zlib_real_unlink)((char const   *)(newname));
          }
        }
      }
    }
  }
#line 340
  return (fd);
}
}
#line 344 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/open.c"
int ( __attribute__((__nonnull__(1))) creat)(char const   *name , mode_t mode ) 
{ 
  int tmp ;

  {
  {
#line 346
  tmp = open(name, 577, mode);
  }
#line 346
  return (tmp);
}
}
#line 351 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/open.c"
FILE *fopen(char const   * __restrict  path , char const   * __restrict  mode ) 
{ 
  FILE *f ;
  int fd ;
  int tmp ;
  FILE *tmp___0 ;

  {
  {
#line 356
  _zlibc_init();
#line 358
  f = (*zlib_real_fopen)((char const   *)path, (char const   *)mode);
  }
#line 359
  if ((unsigned long )f != (unsigned long )((void *)0)) {
#line 360
    return (f);
  }
#line 361
  if (zlib_mode & 2) {
#line 363
    return ((FILE *)((void *)0));
  }
  {
#line 365
  tmp = strcmp((char const   *)mode, "r");
  }
#line 365
  if (tmp) {
#line 367
    return ((FILE *)((void *)0));
  }
  {
#line 369
  fd = open((char const   *)path, 0, (mode_t )0);
  }
#line 370
  if (fd < 0) {
#line 371
    return ((FILE *)((void *)0));
  }
  {
#line 373
  tmp___0 = fdopen(fd, (char const   *)mode);
  }
#line 373
  return (tmp___0);
}
}
#line 376 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/open.c"
FILE *fopen64(char const   * __restrict  path , char const   * __restrict  mode ) 
{ 
  FILE *f ;
  int fd ;
  int tmp ;
  FILE *tmp___0 ;

  {
  {
#line 381
  _zlibc_init();
#line 383
  f = (*zlib_real_fopen64)((char const   *)path, (char const   *)mode);
  }
#line 384
  if ((unsigned long )f != (unsigned long )((void *)0)) {
#line 385
    return (f);
  }
#line 386
  if (zlib_mode & 2) {
#line 388
    return ((FILE *)((void *)0));
  }
  {
#line 390
  tmp = strcmp((char const   *)mode, "r");
  }
#line 390
  if (tmp) {
#line 392
    return ((FILE *)((void *)0));
  }
  {
#line 394
  fd = open((char const   *)path, 0, (mode_t )0);
  }
#line 395
  if (fd < 0) {
#line 396
    return ((FILE *)((void *)0));
  }
  {
#line 398
  tmp___0 = fdopen(fd, (char const   *)mode);
  }
#line 398
  return (tmp___0);
}
}
#line 790 "/usr/include/unistd.h"
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) link)(char const   *file_name1 ,
                                                                                      char const   *file_name2 ) ;
#line 11 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/link.c"
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) link)(char const   *file_name1 ,
                                                                                      char const   *file_name2 ) ;
#line 11 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/link.c"
int ( __attribute__((__nonnull__(1,2), __leaf__)) link)(char const   *file_name1 ,
                                                        char const   *file_name2 ) 
{ 
  int st ;
  char newname1[4102] ;
  char newname2[4102] ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 17
  _zlibc_init();
#line 18
  st = (*zlib_real_link)(file_name1, file_name2);
  }
#line 20
  if (st >= 0) {
#line 21
    return (st);
  } else {
    {
#line 20
    tmp = __errno_location();
    }
#line 20
    if (*tmp != 2) {
#line 21
      return (st);
    }
  }
  {
#line 23
  zlib_initialise();
  }
#line 24
  if (zlib_mode & 2) {
#line 25
    return (st);
  }
  {
#line 26
  tmp___0 = zlib_getfiletype(file_name1, -1);
  }
#line 26
  if ((tmp___0 & 7) == 5) {
#line 27
    return (st);
  }
  {
#line 30
  strncpy((char */* __restrict  */)(newname1), (char const   */* __restrict  */)file_name1,
          (size_t )1024);
#line 31
  strcat((char */* __restrict  */)(newname1), (char const   */* __restrict  */)zlib_ext);
#line 33
  strncpy((char */* __restrict  */)(newname2), (char const   */* __restrict  */)file_name2,
          (size_t )1024);
#line 34
  strcat((char */* __restrict  */)(newname2), (char const   */* __restrict  */)zlib_ext);
#line 36
  tmp___1 = __errno_location();
#line 36
  *tmp___1 = 0;
#line 37
  tmp___2 = (*zlib_real_link)((char const   *)(newname1), (char const   *)(newname2));
  }
#line 37
  return (tmp___2);
}
}
#line 12 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/listxattr.c"
int listxattr(char const   *file_name , char *list , size_t size ) 
{ 
  int st ;
  char newname[4102] ;
  ssize_t tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  ssize_t tmp___3 ;

  {
  {
#line 17
  _zlibc_init();
#line 18
  tmp = (*zlib_real_listxattr)(file_name, list, size);
#line 18
  st = (int )tmp;
  }
#line 20
  if (st >= 0) {
#line 21
    return (st);
  } else {
    {
#line 20
    tmp___0 = __errno_location();
    }
#line 20
    if (*tmp___0 != 2) {
#line 21
      return (st);
    }
  }
  {
#line 23
  zlib_initialise();
  }
#line 24
  if (zlib_mode & 2) {
#line 25
    return (st);
  }
  {
#line 26
  tmp___1 = zlib_getfiletype(file_name, -1);
  }
#line 26
  if ((tmp___1 & 7) == 5) {
#line 27
    return (st);
  }
#line 29
  if (zlib_mode & 8) {
    {
#line 30
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Getxattr %s\n",
            file_name);
    }
  }
  {
#line 32
  strncpy((char */* __restrict  */)(newname), (char const   */* __restrict  */)file_name,
          (size_t )1024);
#line 33
  strcat((char */* __restrict  */)(newname), (char const   */* __restrict  */)zlib_ext);
#line 35
  tmp___2 = __errno_location();
#line 35
  *tmp___2 = 0;
#line 36
  tmp___3 = (*zlib_real_listxattr)((char const   *)(newname), list, size);
  }
#line 36
  return ((int )tmp___3);
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 849 "/usr/include/unistd.h"
extern char *getlogin(void) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 116
extern struct passwd *getpwnam(char const   *__name ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/parseconfig.c"
static struct token_table token_table[43]  = 
#line 38 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/parseconfig.c"
  {      {(char *)"commands", 2}, 
        {(char *)"command", 2}, 
        {(char *)"use", 3}, 
        {(char *)"uses", 3}, 
        {(char *)"class", 4}, 
        {(char *)"end", 5}, 
        {(char *)"default", 6}, 
        {(char *)"all", 4102}, 
        {(char *)"dir", 4097}, 
        {(char *)"directory", 4097}, 
        {(char *)"subdir", 4098}, 
        {(char *)"subdirectory", 4098}, 
        {(char *)"basename", 4099}, 
        {(char *)"suffix", 4100}, 
        {(char *)"filename", 4101}, 
        {(char *)"filesystem", 4103}, 
        {(char *)"use_tmp_file", 16385}, 
        {(char *)"hide_pipe", 16386}, 
        {(char *)"use_and_hide_pipe", 16386}, 
        {(char *)"show_pipe", 16387}, 
        {(char *)"use_and_show_pipe", 16387}, 
        {(char *)"dir_leave_compressed", 16388}, 
        {(char *)"leave_compressed", 16389}, 
        {(char *)"create_compressed", 16392}, 
        {(char *)"no_create_compressed", 16400}, 
        {(char *)"append_compressed", 16416}, 
        {(char *)"no_append_compressed", 16448}, 
        {(char *)"uncompress_before_write", 16640}, 
        {(char *)"no_uncompress_before_write", 16512}, 
        {(char *)"show_compressed_size", 16896}, 
        {(char *)"show_uncompressed_size", 17408}, 
        {(char *)"disable", 8194}, 
        {(char *)"disable_child", 8256}, 
        {(char *)"readdir_compr", 8196}, 
        {(char *)"readdir", 8196}, 
        {(char *)"verbose", 8200}, 
        {(char *)"unlink", 8208}, 
        {(char *)"enable", 12290}, 
        {(char *)"enable_child", 8256}, 
        {(char *)"readdir_uncompr", 12292}, 
        {(char *)"silent", 12296}, 
        {(char *)"no_unlink", 12304}, 
        {(char *)0, 7}};
#line 111 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/parseconfig.c"
static char *err_strings___0[13]  = 
#line 111
  {      (char *)"Record not found",      (char *)"String expected",      (char *)"File action expected",      (char *)"Pipe mode expected", 
        (char *)"End of line expected",      (char *)"End of line reached",      (char *)"Bad token",      (char *)"Out of memory", 
        (char *)"Too many filename actions",      (char *)"End of file reached",      (char *)"Commands clause following file-actions clause",      (char *)"Undefined command class", 
        (char *)"Same command listed twice"};
#line 129 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/parseconfig.c"
static char *mystrsep(char **stringp , char const   *delim ) 
{ 
  char *sp ;
  char const   *dp ;

  {
#line 134
  sp = *stringp;
#line 135
  if (! sp) {
#line 136
    return ((char *)0);
  } else
#line 135
  if (! *sp) {
#line 136
    return ((char *)0);
  }
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 137
    if (! *(*stringp)) {
#line 137
      goto while_break;
    }
#line 138
    dp = delim;
    {
#line 138
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 138
      if (! *dp) {
#line 138
        goto while_break___0;
      }
#line 139
      if ((int const   )*dp == (int const   )*(*stringp)) {
#line 140
        *(*stringp) = (char )'\000';
#line 141
        (*stringp) ++;
#line 142
        return (sp);
      }
#line 138
      dp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 144
    (*stringp) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 146
  return (sp);
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/parseconfig.c"
static char buffer[256]  ;
#line 154
static char *mymalloc(size_t size ) ;
#line 154 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/parseconfig.c"
static int offset  =    0;
#line 150 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/parseconfig.c"
static char *mymalloc(size_t size ) 
{ 
  char *ptr ;
  void *tmp ;

  {
#line 157
  if ((size_t )offset + size > 256UL) {
    {
#line 158
    tmp = malloc(size);
    }
#line 158
    return ((char *)tmp);
  }
#line 159
  ptr = buffer + offset;
#line 160
  offset = (int )((size_t )offset + size);
#line 161
  return (ptr);
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/parseconfig.c"
static int my_strcmp(char *pattern , char *tok ) 
{ 


  {
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (! *pattern) {
#line 167
      if (! *tok) {
#line 168
        return (0);
      }
    }
#line 169
    if ((int )*pattern == (int )*tok) {
#line 170
      tok ++;
#line 171
      pattern ++;
#line 172
      goto while_continue;
    }
#line 174
    if ((int )*pattern == 45) {
#line 174
      goto _L;
    } else
#line 174
    if ((int )*pattern == 95) {
      _L: /* CIL Label */ 
#line 175
      if ((int )*tok == 45) {
#line 176
        tok ++;
      } else
#line 175
      if ((int )*tok == 95) {
#line 176
        tok ++;
      }
#line 177
      pattern ++;
#line 178
      goto while_continue;
    }
#line 180
    return (1);
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/parseconfig.c"
static int get_next_token(char **stringp , char **val ) 
{ 
  int stringmode ;
  struct token_table *tok ;
  char *delim ;
  int tmp ;

  {
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! *stringp) {
#line 192
      return (8);
    }
    {
#line 194
    if ((int )*(*stringp) == 35) {
#line 194
      goto case_35;
    }
#line 196
    if ((int )*(*stringp) == 34) {
#line 196
      goto case_34;
    }
#line 201
    if ((int )*(*stringp) == 39) {
#line 201
      goto case_39;
    }
#line 206
    goto switch_default;
    case_35: /* CIL Label */ 
#line 195
    return (8);
    case_34: /* CIL Label */ 
#line 197
    stringmode = 1;
#line 198
    (*stringp) ++;
#line 199
    delim = (char *)"\"\n";
#line 200
    goto switch_break;
    case_39: /* CIL Label */ 
#line 202
    stringmode = 1;
#line 203
    (*stringp) ++;
#line 204
    delim = (char *)"\'\n";
#line 205
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 207
    stringmode = 0;
#line 208
    delim = (char *)"\n\t;, #";
    switch_break: /* CIL Label */ ;
    }
    {
#line 211
    *val = mystrsep(stringp, (char const   *)delim);
    }
#line 212
    if ((unsigned long )*val == (unsigned long )((char *)0)) {
#line 213
      return (8);
    }
#line 215
    if ((int )*(*val) == 0) {
#line 216
      goto while_continue;
    }
#line 218
    if (! stringmode) {
#line 219
      tok = token_table;
      {
#line 220
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 220
        if (tok->name) {
          {
#line 220
          tmp = my_strcmp(tok->name, *val);
          }
#line 220
          if (! tmp) {
#line 220
            goto while_break___0;
          }
        } else {
#line 220
          goto while_break___0;
        }
#line 221
        tok ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 222
      return (tok->value);
    }
#line 224
    return (1);
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 228 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/parseconfig.c"
static int parse_commands_line(char *prgname , char *stringp , char *class , int *mode ,
                               int *modemask ) 
{ 
  int have_found ;
  char *string ;
  int tok ;
  int stop_loop ;
  int tmp ;

  {
#line 247
  have_found = 0;
#line 248
  stop_loop = 0;
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    if (! (! stop_loop)) {
#line 250
      goto while_break;
    }
    {
#line 251
    tok = get_next_token(& stringp, & string);
    }
    {
#line 252
    if (tok == 1) {
#line 252
      goto case_1;
    }
#line 262
    if (tok == 6) {
#line 262
      goto case_6;
    }
#line 269
    if (tok == 3) {
#line 269
      goto case_3;
    }
#line 274
    if (tok == 8) {
#line 274
      goto case_8;
    }
#line 276
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 258
    tmp = strcmp((char const   *)string, (char const   *)prgname);
    }
#line 258
    if (tmp == 0) {
#line 259
      have_found = 1;
    }
#line 261
    goto switch_break;
    case_6: /* CIL Label */ 
#line 267
    have_found = 1;
#line 268
    goto switch_break;
    case_3: /* CIL Label */ 
#line 270
    if (! have_found) {
#line 271
      return (0);
    }
#line 272
    stop_loop = 1;
#line 273
    goto switch_break;
    case_8: /* CIL Label */ 
#line 275
    return (-4);
    switch_default: /* CIL Label */ 
#line 277
    return (-6);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 281
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 282
    tok = get_next_token(& stringp, & string);
    }
    {
#line 283
    if (tok == 1) {
#line 283
      goto case_1___0;
    }
#line 293
    if (tok == 8) {
#line 293
      goto case_8___0;
    }
#line 295
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
#line 285
    if ((int )*(class + 0) == 0) {
      {
#line 286
      strncpy((char */* __restrict  */)class, (char const   */* __restrict  */)string,
              (size_t )16);
      }
    }
#line 292
    goto switch_break___0;
    case_8___0: /* CIL Label */ 
#line 294
    return (0);
    switch_default___0: /* CIL Label */ 
#line 296
    if ((tok & -4096) == 8192) {
#line 301
      *mode |= (tok & 4095) & ~ *modemask;
    } else
#line 303
    if ((tok & -4096) == 12288) {
#line 308
      *modemask |= tok & 4095;
    } else {
#line 311
      return (-6);
    }
#line 312
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/parseconfig.c"
static int parse_fa_line(char *stringp , FilenameActions *fa ) 
{ 
  int have_found ;
  char *string ;
  int tok1 ;
  int tok2 ;
  int tok3 ;
  int stop_loop ;
  int len ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  struct stat buf ;
  int st ;
  int olderrno ;
  int *tmp___2 ;
  int *tmp___3 ;
  char tmp___4[4100] ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 330
  len = 0;
#line 332
  have_found = 0;
#line 333
  stop_loop = 0;
#line 335
  tok3 = 0;
#line 335
  tok2 = tok3;
#line 335
  tok1 = tok2;
#line 337
  tok1 = get_next_token(& stringp, & string);
  }
#line 338
  if (tok1 == 8) {
#line 339
    return (2);
  }
#line 341
  if ((tok1 & -4096) == 16384) {
#line 342
    tok3 = tok1;
#line 343
    tok2 = 1;
#line 344
    tok1 = 4096;
#line 345
    if (! fa) {
#line 346
      return (1);
    }
  }
#line 349
  if (tok1 == 6) {
#line 350
    tok2 = 1;
#line 351
    tok1 = 4096;
#line 352
    if (! fa) {
#line 353
      return (1);
    }
  }
#line 356
  if (tok1 == 4102) {
#line 357
    tok2 = 1;
  }
#line 359
  if (! fa) {
#line 360
    return (0);
  }
#line 362
  if (tok1 == 1) {
    {
#line 363
    tok2 = tok1;
#line 364
    tmp = strlen((char const   *)string);
#line 364
    len = (int )tmp;
    }
#line 366
    if ((int )*(string + 0) == 46) {
#line 367
      tok1 = 4100;
    } else
#line 368
    if ((int )*(string + 0) == 47) {
#line 369
      if ((int )*(string + (len - 1)) == 47) {
#line 370
        tok1 = 4098;
      } else {
#line 372
        tok1 = 4101;
      }
    } else {
#line 375
      tok1 = 4099;
    }
  }
#line 378
  if ((tok1 & -4096) != 4096) {
#line 379
    return (-2);
  }
#line 381
  if (tok2 == 0) {
    {
#line 382
    tok2 = get_next_token(& stringp, & string);
    }
#line 383
    if (tok2 != 1) {
#line 384
      return (-1);
    }
    {
#line 386
    tmp___0 = strlen((char const   *)string);
#line 386
    len = (int )tmp___0;
    }
  }
#line 389
  fa->fa_type = tok1 & 4095;
#line 390
  fa->is_initialized = 0;
#line 392
  if (tok1 != 4096) {
#line 392
    if (tok1 != 4102) {
#line 393
      if (tok1 == 4098) {
#line 393
        goto _L;
      } else
#line 393
      if (tok1 == 4097) {
        _L: /* CIL Label */ 
#line 395
        if ((int )*(string + (len - 1)) != 47) {
#line 396
          *(string + len) = (char )'/';
#line 397
          len ++;
        }
      }
#line 401
      if (tok1 != 4103) {
        {
#line 402
        tmp___1 = mymalloc((size_t )(len + 1));
#line 402
        fa->name = tmp___1;
        }
#line 403
        if ((unsigned long )fa->name == (unsigned long )((char *)0)) {
#line 404
          return (-7);
        }
        {
#line 406
        fa->namelength = len;
#line 407
        strncpy((char */* __restrict  */)fa->name, (char const   */* __restrict  */)string,
                (size_t )len);
#line 408
        *(fa->name + len) = (char )'\000';
        }
      } else {
        {
#line 414
        tmp___2 = __errno_location();
#line 414
        olderrno = *tmp___2;
#line 415
        st = ___zlibc_nativestat((char const   *)string, & buf);
#line 416
        tmp___3 = __errno_location();
#line 416
        *tmp___3 = olderrno;
        }
#line 418
        if (st == 0) {
          {
#line 419
          fa->dev = buf.st_dev;
#line 420
          tmp___5 = strcmp((char const   *)string, "/");
          }
#line 420
          if (tmp___5) {
            {
#line 422
            strcpy((char */* __restrict  */)(tmp___4), (char const   */* __restrict  */)string);
#line 423
            strcat((char */* __restrict  */)(tmp___4), (char const   */* __restrict  */)"/..");
#line 424
            st = ___zlibc_nativestat((char const   *)(tmp___4), & buf);
            }
#line 425
            if (st < 0) {
#line 426
              fa->namelength = 0;
            } else
#line 425
            if (buf.st_dev == fa->dev) {
#line 426
              fa->namelength = 0;
            }
          }
        } else {
#line 429
          fa->dev = (dev_t )0;
        }
      }
    }
  }
#line 433
  if (! tok3) {
    {
#line 434
    tok3 = get_next_token(& stringp, & string);
    }
#line 435
    if ((tok3 & -4096) != 16384) {
#line 436
      return (-3);
    }
  }
  {
#line 439
  fa->pipe_mode = tok3 & 4095;
#line 441
  tmp___6 = get_next_token(& stringp, & string);
  }
#line 441
  if (tmp___6 != 8) {
#line 442
    return (-4);
  }
#line 444
  if (fa->fa_type == 0) {
#line 445
    return (1);
  }
#line 446
  return (0);
}
}
#line 451 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/parseconfig.c"
static FilenameActions userFilenameActions[100]  ;
#line 457 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/parseconfig.c"
static int parse_class(FILE *f , int *line , FilenameActions *fa ) 
{ 
  char buffer___1[1024] ;
  char *stringp ;
  int count ;
  int ret ;
  char *tmp ;

  {
#line 464
  count = 0;
  {
#line 465
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 466
    tmp = fgets((char */* __restrict  */)(buffer___1), 1024, (FILE */* __restrict  */)f);
    }
#line 466
    if ((unsigned long )tmp == (unsigned long )((char *)0)) {
#line 467
      return (-9);
    }
    {
#line 468
    (*line) ++;
#line 469
    stringp = buffer___1;
#line 470
    ret = parse_fa_line(buffer___1, fa);
    }
#line 471
    if (ret == 2) {
#line 472
      goto while_continue;
    }
#line 473
    if (ret) {
#line 474
      return (ret);
    }
#line 475
    if (fa) {
#line 476
      fa ++;
#line 477
      count ++;
    }
#line 479
    if (count > 100) {
#line 480
      return (-8);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 485 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/parseconfig.c"
static int parse_file___0(char *progname , FILE *f , int *line , int *mode , int *modemask ,
                          char *classname ) 
{ 
  char buffer___1[1024] ;
  int state ;
  char *stringp ;
  char *string ;
  int ret ;
  int tok ;
  FilenameActions *fa ;
  char *tmp ;
  int tmp___0 ;

  {
#line 496
  state = 1;
#line 502
  *line = 0;
  {
#line 503
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 504
    tmp = fgets((char */* __restrict  */)(buffer___1), 1024, (FILE */* __restrict  */)f);
    }
#line 504
    if ((unsigned long )tmp == (unsigned long )((char *)0)) {
#line 505
      return (0);
    }
    {
#line 507
    (*line) ++;
#line 509
    stringp = buffer___1;
#line 510
    tok = get_next_token(& stringp, & string);
    }
#line 513
    if (tok == 8) {
#line 514
      goto while_continue;
    }
#line 517
    if (tok == 2) {
#line 518
      if (state == 2) {
#line 519
        return (-10);
      }
      {
#line 521
      ret = parse_commands_line(progname, stringp, classname, mode, modemask);
      }
#line 522
      if (ret < 0) {
#line 523
        return (ret);
      }
#line 524
      goto while_continue;
    }
#line 528
    if (tok == 4) {
#line 529
      state = 2;
#line 531
      if ((int )*(classname + 0) == 0) {
#line 532
        return (0);
      }
#line 534
      if ((int )*(classname + 0) == 0) {
#line 536
        return (0);
      } else
#line 534
      if (*modemask & 1) {
#line 536
        return (0);
      }
      {
#line 538
      tok = get_next_token(& stringp, & string);
      }
#line 539
      if (tok != 1) {
#line 540
        return (-1);
      }
      {
#line 543
      tmp___0 = strcmp((char const   *)string, (char const   *)classname);
      }
#line 543
      if (tmp___0) {
#line 545
        fa = (FilenameActions *)0;
      } else {
#line 548
        fa = userFilenameActions;
      }
      {
#line 549
      ret = parse_class(f, line, fa);
      }
#line 550
      if (ret < 0) {
#line 551
        return (ret);
      }
#line 553
      if (fa) {
#line 554
        *modemask |= 1;
#line 555
        return (0);
      }
#line 560
      goto while_continue;
    }
#line 562
    return (-6);
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 568 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/parseconfig.c"
void zlib_getuserconf(char *progname , FilenameActions **filenameActions___0 , int *mode ,
                      int *modemask ) 
{ 
  int line ;
  int ret ;
  int i ;
  FILE *f ;
  char classname[1024] ;
  char homeconffile[4097UL + sizeof(".zlibrc")] ;
  struct passwd *pw ;
  uid_t uid ;
  char *homedir ;
  char *username ;
  int iamnotsuid ;
  char *conffiles[3] ;
  int nconffiles ;
  __uid_t tmp ;
  __gid_t tmp___0 ;
  __gid_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 592
  nconffiles = 0;
#line 597
  conffiles[0] = getenv("LD_ZLIB_CONFFILE");
  }
#line 598
  if (conffiles[0]) {
#line 599
    nconffiles ++;
  }
  {
#line 603
  uid = geteuid();
#line 605
  tmp = getuid();
  }
#line 605
  if (tmp == uid) {
#line 605
    tmp___2 = 1;
  } else {
    {
#line 605
    tmp___0 = getgid();
#line 605
    tmp___1 = getegid();
    }
#line 605
    if (tmp___0 == tmp___1) {
#line 605
      tmp___2 = 1;
    } else {
#line 605
      tmp___2 = 0;
    }
  }
#line 605
  iamnotsuid = tmp___2;
#line 610
  if (iamnotsuid) {
    {
#line 611
    homedir = getenv("HOME");
    }
  } else {
#line 613
    homedir = (char *)0;
  }
#line 616
  if (! homedir) {
#line 617
    pw = (struct passwd *)0;
#line 619
    if (iamnotsuid) {
      {
#line 620
      username = getenv("LOGNAME");
      }
    } else {
#line 622
      username = (char *)0;
    }
#line 624
    if (! username) {
      {
#line 625
      username = getlogin();
      }
    }
#line 627
    if (username) {
      {
#line 628
      pw = getpwnam((char const   *)username);
      }
    }
#line 630
    if ((unsigned long )pw == (unsigned long )((struct passwd *)0)) {
      {
#line 632
      pw = getpwuid(uid);
      }
    } else
#line 630
    if (pw->pw_uid != uid) {
      {
#line 632
      pw = getpwuid(uid);
      }
    }
#line 635
    if (pw) {
#line 636
      homedir = pw->pw_dir;
    }
  }
#line 639
  if (homedir) {
    {
#line 640
    strncpy((char */* __restrict  */)(homeconffile), (char const   */* __restrict  */)homedir,
            (size_t )4096);
#line 641
    homeconffile[4096] = (char )'\000';
#line 643
    strcat((char */* __restrict  */)(homeconffile), (char const   */* __restrict  */)"/.zlibrc");
#line 648
    tmp___3 = nconffiles;
#line 648
    nconffiles ++;
#line 648
    conffiles[tmp___3] = homeconffile;
    }
  }
#line 652
  tmp___4 = nconffiles;
#line 652
  nconffiles ++;
#line 652
  conffiles[tmp___4] = (char *)"/usr/local/etc/zlibc.conf";
#line 654
  if (zlib_mode & 8) {
#line 655
    i = 0;
    {
#line 655
    while (1) {
      while_continue: /* CIL Label */ ;
#line 655
      if (! (i < nconffiles)) {
#line 655
        goto while_break;
      }
      {
#line 656
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              conffiles[i]);
#line 655
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 660
  ret = -1;
#line 662
  classname[0] = (char )'\000';
#line 664
  i = 0;
  {
#line 664
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 664
    if (! (i < nconffiles)) {
#line 664
      goto while_break___0;
    }
    {
#line 665
    f = fopen((char const   */* __restrict  */)conffiles[i], (char const   */* __restrict  */)"r");
    }
#line 666
    if ((unsigned long )f == (unsigned long )((FILE *)0)) {
#line 667
      goto __Cont;
    }
    {
#line 669
    ret = parse_file___0(progname, f, & line, mode, modemask, classname);
#line 670
    fclose(f);
    }
#line 671
    if (ret < 0) {
#line 672
      if (zlib_mode & 8) {
        {
#line 673
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"zlibc: %s in line %d, file %s\n",
                err_strings___0[- ret], line, conffiles[i]);
        }
      }
#line 677
      goto __Cont;
    }
#line 679
    if (*modemask == 95) {
#line 680
      goto while_break___0;
    }
    __Cont: /* CIL Label */ 
#line 664
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 685
  if (zlib_mode & 8) {
#line 686
    i = 0;
#line 687
    if (*modemask & 1) {
      {
#line 688
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Listing class\n");
      }
      {
#line 689
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 689
        if (! (userFilenameActions[i].fa_type != 0)) {
#line 689
          goto while_break___1;
        }
        {
#line 690
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%x %d %d",
                userFilenameActions[i].fa_type, userFilenameActions[i].pipe_mode,
                userFilenameActions[i].namelength);
        }
#line 694
        if (userFilenameActions[i].name) {
          {
#line 695
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %s",
                  userFilenameActions[i].name);
          }
        }
        {
#line 697
        printf((char const   */* __restrict  */)"\n");
#line 698
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    } else
#line 700
    if (classname[0]) {
      {
#line 701
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Trying to use undefined class \"%s\"\n",
              classname);
      }
    }
    {
#line 702
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%x %d default\n",
            userFilenameActions[i].fa_type, userFilenameActions[i].pipe_mode);
    }
  }
#line 707
  *filenameActions___0 = userFilenameActions;
#line 708
  return;
}
}
#line 284 "/usr/include/x86_64-linux-gnu/sys/stat.h"
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *file_name ,
                                                                                     __mode_t mode ) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/chmod.c"
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *file_name ,
                                                                                     __mode_t mode ) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/chmod.c"
int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *file_name , __mode_t mode ) 
{ 
  int st ;
  char newname[4102] ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 17
  _zlibc_init();
#line 18
  st = (*zlib_real_chmod)(file_name, mode);
  }
#line 20
  if (st >= 0) {
#line 21
    return (st);
  } else {
    {
#line 20
    tmp = __errno_location();
    }
#line 20
    if (*tmp != 2) {
#line 21
      return (st);
    }
  }
  {
#line 24
  zlib_initialise();
  }
#line 25
  if (zlib_mode & 2) {
#line 26
    return (st);
  }
  {
#line 27
  tmp___0 = zlib_getfiletype(file_name, -1);
  }
#line 27
  if ((tmp___0 & 7) == 5) {
#line 28
    return (st);
  }
#line 30
  if (zlib_mode & 8) {
    {
#line 31
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Chowning %s\n",
            file_name);
    }
  }
  {
#line 33
  strncpy((char */* __restrict  */)(newname), (char const   */* __restrict  */)file_name,
          (size_t )1024);
#line 34
  strcat((char */* __restrict  */)(newname), (char const   */* __restrict  */)zlib_ext);
#line 36
  tmp___1 = __errno_location();
#line 36
  *tmp___1 = 0;
#line 37
  tmp___2 = (*zlib_real_chmod)((char const   *)(newname), mode);
  }
#line 37
  return (tmp___2);
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/zlibc.conf.c"
static FilenameActions zlibc_class_X[4]  = {      {2, (char *)"/usr/X11R6/", (int )(sizeof("/usr/X11R6/") - 1UL), 1, 0UL, 0UL,
      0}, 
        {2, (char *)"/usr/X386/", (int )(sizeof("/usr/X386/") - 1UL), 1, 0UL, 0UL, 0}, 
        {2,
      (char *)"/usr/lib/X11/", (int )(sizeof("/usr/lib/X11/") - 1UL), 1, 0UL, 0UL,
      0}, 
        {0, (char *)"", (int )(sizeof("") - 1UL), 3, 0UL, 0UL, 0}};
#line 11 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/zlibc.conf.c"
static FilenameActions zlibc_class_nopipe[1]  = {      {0, (char *)"", (int )(sizeof("") - 1UL), 1, 0UL, 0UL, 0}};
#line 14 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/zlibc.conf.c"
static FilenameActions zlibc_class_showpipe[1]  = {      {0, (char *)"", (int )(sizeof("") - 1UL), 3, 0UL, 0UL, 0}};
#line 17 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/zlibc.conf.c"
static FilenameActions zlibc_class_find[2]  = {      {6, (char *)"", (int )(sizeof("") - 1UL), 512, 0UL, 0UL, 0}, 
        {0, (char *)"", (int )(sizeof("") - 1UL), 1, 0UL, 0UL, 0}};
#line 21 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/zlibc.conf.c"
static FilenameActions zlibc_class_emacs[3]  = {      {2, (char *)"/usr/lib/emacs/", (int )(sizeof("/usr/lib/emacs/") - 1UL), 3, 0UL,
      0UL, 0}, 
        {2, (char *)"/usr/info/", (int )(sizeof("/usr/info/") - 1UL), 2, 0UL, 0UL, 0}, 
        {0,
      (char *)"", (int )(sizeof("") - 1UL), 5, 0UL, 0UL, 0}};
#line 26 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/zlibc.conf.c"
static FilenameActions zlibc_class_generic_safe[2]  = {      {4, (char *)".tar", (int )(sizeof(".tar") - 1UL), 4, 0UL, 0UL, 0}, 
        {0, (char *)"", (int )(sizeof("") - 1UL), 1, 0UL, 0UL, 0}};
#line 31 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/zlibc.conf.c"
CommandActions zlib_commandActions[39]  = 
#line 31
  {      {(char *)"mv", 4, zlibc_class_generic_safe}, 
        {(char *)"cp", 4, zlibc_class_generic_safe}, 
        {(char *)"pax", 4, zlibc_class_generic_safe}, 
        {(char *)"cpio", 4, zlibc_class_generic_safe}, 
        {(char *)"tar", 4, zlibc_class_generic_safe}, 
        {(char *)"XF86_Accel", 0, zlibc_class_X}, 
        {(char *)"XF86_VGA16", 0, zlibc_class_X}, 
        {(char *)"XF86_S3", 0, zlibc_class_X}, 
        {(char *)"XF86_Mono", 0, zlibc_class_X}, 
        {(char *)"XF86_SVGA", 0, zlibc_class_X}, 
        {(char *)"emacs", 64, zlibc_class_emacs}, 
        {(char *)"lisp", 0, zlibc_class_nopipe}, 
        {(char *)"lisp.run", 0, zlibc_class_nopipe}, 
        {(char *)"clisp", 0, zlibc_class_nopipe}, 
        {(char *)"in.nnrpd", 0, zlibc_class_nopipe}, 
        {(char *)"xrn", 0, zlibc_class_nopipe}, 
        {(char *)"trn", 0, zlibc_class_nopipe}, 
        {(char *)"rn", 0, zlibc_class_nopipe}, 
        {(char *)"tin", 0, zlibc_class_nopipe}, 
        {(char *)"nn", 0, zlibc_class_nopipe}, 
        {(char *)"zls", 2, zlibc_class_generic_safe}, 
        {(char *)"zfind", 2, zlibc_class_generic_safe}, 
        {(char *)"zzsh", 2, zlibc_class_generic_safe}, 
        {(char *)"find", 0, zlibc_class_find}, 
        {(char *)"smalltalk", 0, zlibc_class_nopipe}, 
        {(char *)"xdvi", 0, zlibc_class_nopipe}, 
        {(char *)"file", 0, zlibc_class_nopipe}, 
        {(char *)"less", 0, zlibc_class_nopipe}, 
        {(char *)"patch", 0, zlibc_class_showpipe}, 
        {(char *)"ls", 0, zlibc_class_showpipe}, 
        {(char *)"mkisofs", 2, zlibc_class_generic_safe}, 
        {(char *)"rm", 20, zlibc_class_generic_safe}, 
        {(char *)"uncompress", 2, zlibc_class_generic_safe}, 
        {(char *)"compress", 2, zlibc_class_generic_safe}, 
        {(char *)"gunzip", 2, zlibc_class_generic_safe}, 
        {(char *)"gzip", 2, zlibc_class_generic_safe}, 
        {(char *)"xemacs", 66, zlibc_class_generic_safe}, 
        {(char *)"xman", 2, zlibc_class_nopipe}, 
        {(char *)0, 16, zlibc_class_generic_safe}};
#line 12 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/removexattr.c"
int removexattr(char const   *file_name , char const   *name ) 
{ 
  int st ;
  char newname[4102] ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 17
  _zlibc_init();
#line 18
  st = (*zlib_real_removexattr)(file_name, name);
  }
#line 20
  if (st >= 0) {
#line 21
    return (st);
  } else {
    {
#line 20
    tmp = __errno_location();
    }
#line 20
    if (*tmp != 2) {
#line 21
      return (st);
    }
  }
  {
#line 23
  zlib_initialise();
  }
#line 24
  if (zlib_mode & 2) {
#line 25
    return (st);
  }
  {
#line 26
  tmp___0 = zlib_getfiletype(file_name, -1);
  }
#line 26
  if ((tmp___0 & 7) == 5) {
#line 27
    return (st);
  }
#line 29
  if (zlib_mode & 8) {
    {
#line 30
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Getxattr %s\n",
            file_name);
    }
  }
  {
#line 32
  strncpy((char */* __restrict  */)(newname), (char const   */* __restrict  */)file_name,
          (size_t )1024);
#line 33
  strcat((char */* __restrict  */)(newname), (char const   */* __restrict  */)zlib_ext);
#line 35
  tmp___1 = __errno_location();
#line 35
  *tmp___1 = 0;
#line 36
  tmp___2 = (*zlib_real_removexattr)((char const   *)(newname), name);
  }
#line 36
  return (tmp___2);
}
}
#line 12 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/setxattr.c"
int setxattr(char const   *file_name , char const   *name , void const   *value ,
             size_t size , int flags ) 
{ 
  int st ;
  char newname[4102] ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 18
  _zlibc_init();
#line 19
  st = (*zlib_real_setxattr)(file_name, name, value, size, flags);
  }
#line 21
  if (st >= 0) {
#line 22
    return (st);
  } else {
    {
#line 21
    tmp = __errno_location();
    }
#line 21
    if (*tmp != 2) {
#line 22
      return (st);
    }
  }
  {
#line 24
  zlib_initialise();
  }
#line 25
  if (zlib_mode & 2) {
#line 26
    return (st);
  }
  {
#line 27
  tmp___0 = zlib_getfiletype(file_name, -1);
  }
#line 27
  if ((tmp___0 & 7) == 5) {
#line 28
    return (st);
  }
#line 30
  if (zlib_mode & 8) {
    {
#line 31
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Getxattr %s\n",
            file_name);
    }
  }
  {
#line 33
  strncpy((char */* __restrict  */)(newname), (char const   */* __restrict  */)file_name,
          (size_t )1024);
#line 34
  strcat((char */* __restrict  */)(newname), (char const   */* __restrict  */)zlib_ext);
#line 36
  tmp___1 = __errno_location();
#line 36
  *tmp___1 = 0;
#line 37
  tmp___2 = (*zlib_real_setxattr)((char const   *)(newname), name, value, size, flags);
  }
#line 37
  return (tmp___2);
}
}
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 177 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/zlibc.h"
char *err_strings[13] ;
#line 178
int generation ;
#line 190
int add_prog(commands_line **cmd , char *name ) ;
#line 191
int add_default(commands_line **cmd ) ;
#line 193
void print_class(FilenameActions *fa , char *name , int line ) ;
#line 194
int parse_file(char *progname , FILE *f , int *line , int *mode , int *modemask ,
               char *classname ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/parseconfig.c"
static struct token_table token_table___0[43]  = 
#line 38 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/parseconfig.c"
  {      {(char *)"commands", 2}, 
        {(char *)"command", 2}, 
        {(char *)"use", 3}, 
        {(char *)"uses", 3}, 
        {(char *)"class", 4}, 
        {(char *)"end", 5}, 
        {(char *)"default", 6}, 
        {(char *)"all", 4102}, 
        {(char *)"dir", 4097}, 
        {(char *)"directory", 4097}, 
        {(char *)"subdir", 4098}, 
        {(char *)"subdirectory", 4098}, 
        {(char *)"basename", 4099}, 
        {(char *)"suffix", 4100}, 
        {(char *)"filename", 4101}, 
        {(char *)"filesystem", 4103}, 
        {(char *)"use_tmp_file", 16385}, 
        {(char *)"hide_pipe", 16386}, 
        {(char *)"use_and_hide_pipe", 16386}, 
        {(char *)"show_pipe", 16387}, 
        {(char *)"use_and_show_pipe", 16387}, 
        {(char *)"dir_leave_compressed", 16388}, 
        {(char *)"leave_compressed", 16389}, 
        {(char *)"create_compressed", 16392}, 
        {(char *)"no_create_compressed", 16400}, 
        {(char *)"append_compressed", 16416}, 
        {(char *)"no_append_compressed", 16448}, 
        {(char *)"uncompress_before_write", 16640}, 
        {(char *)"no_uncompress_before_write", 16512}, 
        {(char *)"show_compressed_size", 16896}, 
        {(char *)"show_uncompressed_size", 17408}, 
        {(char *)"disable", 8194}, 
        {(char *)"disable_child", 8256}, 
        {(char *)"readdir_compr", 8196}, 
        {(char *)"readdir", 8196}, 
        {(char *)"verbose", 8200}, 
        {(char *)"unlink", 8208}, 
        {(char *)"enable", 12290}, 
        {(char *)"enable_child", 8256}, 
        {(char *)"readdir_uncompr", 12292}, 
        {(char *)"silent", 12296}, 
        {(char *)"no_unlink", 12304}, 
        {(char *)0, 7}};
#line 113 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/parseconfig.c"
char *err_strings[13]  = 
#line 113
  {      (char *)"Record not found",      (char *)"String expected",      (char *)"File action expected",      (char *)"Pipe mode expected", 
        (char *)"End of line expected",      (char *)"End of line reached",      (char *)"Bad token",      (char *)"Out of memory", 
        (char *)"Too many filename actions",      (char *)"End of file reached",      (char *)"Commands clause following file-actions clause",      (char *)"Undefined command class", 
        (char *)"Same command listed twice"};
#line 129 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/parseconfig.c"
static char *mystrsep___0(char **stringp , char const   *delim ) 
{ 
  char *sp ;
  char const   *dp ;

  {
#line 134
  sp = *stringp;
#line 135
  if (! sp) {
#line 136
    return ((char *)0);
  } else
#line 135
  if (! *sp) {
#line 136
    return ((char *)0);
  }
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 137
    if (! *(*stringp)) {
#line 137
      goto while_break;
    }
#line 138
    dp = delim;
    {
#line 138
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 138
      if (! *dp) {
#line 138
        goto while_break___0;
      }
#line 139
      if ((int const   )*dp == (int const   )*(*stringp)) {
#line 140
        *(*stringp) = (char )'\000';
#line 141
        (*stringp) ++;
#line 142
        return (sp);
      }
#line 138
      dp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 144
    (*stringp) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 146
  return (sp);
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/parseconfig.c"
static char buffer___0[256]  ;
#line 154
static char *mymalloc___0(size_t size ) ;
#line 154 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/parseconfig.c"
static int offset___0  =    0;
#line 150 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/parseconfig.c"
static char *mymalloc___0(size_t size ) 
{ 
  char *ptr ;
  void *tmp ;

  {
#line 157
  if ((size_t )offset___0 + size > 256UL) {
    {
#line 158
    tmp = malloc(size);
    }
#line 158
    return ((char *)tmp);
  }
#line 159
  ptr = buffer___0 + offset___0;
#line 160
  offset___0 = (int )((size_t )offset___0 + size);
#line 161
  return (ptr);
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/parseconfig.c"
static int my_strcmp___0(char *pattern , char *tok ) 
{ 


  {
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (! *pattern) {
#line 167
      if (! *tok) {
#line 168
        return (0);
      }
    }
#line 169
    if ((int )*pattern == (int )*tok) {
#line 170
      tok ++;
#line 171
      pattern ++;
#line 172
      goto while_continue;
    }
#line 174
    if ((int )*pattern == 45) {
#line 174
      goto _L;
    } else
#line 174
    if ((int )*pattern == 95) {
      _L: /* CIL Label */ 
#line 175
      if ((int )*tok == 45) {
#line 176
        tok ++;
      } else
#line 175
      if ((int )*tok == 95) {
#line 176
        tok ++;
      }
#line 177
      pattern ++;
#line 178
      goto while_continue;
    }
#line 180
    return (1);
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/parseconfig.c"
static int get_next_token___0(char **stringp , char **val ) 
{ 
  int stringmode ;
  struct token_table *tok ;
  char *delim ;
  int tmp ;

  {
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! *stringp) {
#line 192
      return (8);
    }
    {
#line 194
    if ((int )*(*stringp) == 35) {
#line 194
      goto case_35;
    }
#line 196
    if ((int )*(*stringp) == 34) {
#line 196
      goto case_34;
    }
#line 201
    if ((int )*(*stringp) == 39) {
#line 201
      goto case_39;
    }
#line 206
    goto switch_default;
    case_35: /* CIL Label */ 
#line 195
    return (8);
    case_34: /* CIL Label */ 
#line 197
    stringmode = 1;
#line 198
    (*stringp) ++;
#line 199
    delim = (char *)"\"\n";
#line 200
    goto switch_break;
    case_39: /* CIL Label */ 
#line 202
    stringmode = 1;
#line 203
    (*stringp) ++;
#line 204
    delim = (char *)"\'\n";
#line 205
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 207
    stringmode = 0;
#line 208
    delim = (char *)"\n\t;, #";
    switch_break: /* CIL Label */ ;
    }
    {
#line 211
    *val = mystrsep___0(stringp, (char const   *)delim);
    }
#line 212
    if ((unsigned long )*val == (unsigned long )((char *)0)) {
#line 213
      return (8);
    }
#line 215
    if ((int )*(*val) == 0) {
#line 216
      goto while_continue;
    }
#line 218
    if (! stringmode) {
#line 219
      tok = token_table___0;
      {
#line 220
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 220
        if (tok->name) {
          {
#line 220
          tmp = my_strcmp___0(tok->name, *val);
          }
#line 220
          if (! tmp) {
#line 220
            goto while_break___0;
          }
        } else {
#line 220
          goto while_break___0;
        }
#line 221
        tok ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 222
      return (tok->value);
    }
#line 224
    return (1);
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 228 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/parseconfig.c"
static int parse_commands_line___0(char *prgname , char *stringp , char *class , int *mode ,
                                   int *modemask ) 
{ 
  int have_found ;
  char *string ;
  int tok ;
  int stop_loop ;
  int ret ;
  commands_line *ptr ;
  commands_line *cmd ;

  {
#line 243
  cmd = (commands_line *)0;
#line 244
  generation ++;
#line 247
  have_found = 0;
#line 248
  stop_loop = 0;
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    if (! (! stop_loop)) {
#line 250
      goto while_break;
    }
    {
#line 251
    tok = get_next_token___0(& stringp, & string);
    }
    {
#line 252
    if (tok == 1) {
#line 252
      goto case_1;
    }
#line 262
    if (tok == 6) {
#line 262
      goto case_6;
    }
#line 269
    if (tok == 3) {
#line 269
      goto case_3;
    }
#line 274
    if (tok == 8) {
#line 274
      goto case_8;
    }
#line 276
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 254
    have_found = 1;
#line 255
    ret = add_prog(& cmd, string);
    }
#line 255
    if (ret) {
#line 256
      return (ret);
    }
#line 261
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 264
    ret = add_default(& cmd);
    }
#line 264
    if (ret) {
#line 265
      return (ret);
    }
#line 267
    have_found = 1;
#line 268
    goto switch_break;
    case_3: /* CIL Label */ 
#line 270
    if (! have_found) {
#line 271
      return (0);
    }
#line 272
    stop_loop = 1;
#line 273
    goto switch_break;
    case_8: /* CIL Label */ 
#line 275
    return (-4);
    switch_default: /* CIL Label */ 
#line 277
    return (-6);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 281
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 282
    tok = get_next_token___0(& stringp, & string);
    }
    {
#line 283
    if (tok == 1) {
#line 283
      goto case_1___0;
    }
#line 293
    if (tok == 8) {
#line 293
      goto case_8___0;
    }
#line 295
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
#line 288
    ptr = cmd;
    {
#line 288
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 288
      if (! ptr) {
#line 288
        goto while_break___1;
      }
#line 289
      if (! ptr->class[0]) {
        {
#line 290
        strncpy((char */* __restrict  */)(ptr->class), (char const   */* __restrict  */)string,
                (size_t )16);
        }
      }
#line 288
      ptr = ptr->localnext;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 292
    goto switch_break___0;
    case_8___0: /* CIL Label */ 
#line 294
    return (0);
    switch_default___0: /* CIL Label */ 
#line 296
    if ((tok & -4096) == 8192) {
#line 298
      ptr = cmd;
      {
#line 298
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 298
        if (! ptr) {
#line 298
          goto while_break___2;
        }
#line 299
        ptr->mode |= (tok & 4095) & ~ ptr->modemask;
#line 298
        ptr = ptr->localnext;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else
#line 303
    if ((tok & -4096) == 12288) {
#line 305
      ptr = cmd;
      {
#line 305
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 305
        if (! ptr) {
#line 305
          goto while_break___3;
        }
#line 306
        ptr->modemask |= tok & 4095;
#line 305
        ptr = ptr->localnext;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {
#line 311
      return (-6);
    }
#line 312
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/parseconfig.c"
static int parse_fa_line___0(char *stringp , FilenameActions *fa ) 
{ 
  int have_found ;
  char *string ;
  int tok1 ;
  int tok2 ;
  int tok3 ;
  int stop_loop ;
  int len ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  struct stat buf ;
  int st ;
  int olderrno ;
  int *tmp___2 ;
  int *tmp___3 ;
  char tmp___4[4100] ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 330
  len = 0;
#line 332
  have_found = 0;
#line 333
  stop_loop = 0;
#line 335
  tok3 = 0;
#line 335
  tok2 = tok3;
#line 335
  tok1 = tok2;
#line 337
  tok1 = get_next_token___0(& stringp, & string);
  }
#line 338
  if (tok1 == 8) {
#line 339
    return (2);
  }
#line 341
  if ((tok1 & -4096) == 16384) {
#line 342
    tok3 = tok1;
#line 343
    tok2 = 1;
#line 344
    tok1 = 4096;
#line 345
    if (! fa) {
#line 346
      return (1);
    }
  }
#line 349
  if (tok1 == 6) {
#line 350
    tok2 = 1;
#line 351
    tok1 = 4096;
#line 352
    if (! fa) {
#line 353
      return (1);
    }
  }
#line 356
  if (tok1 == 4102) {
#line 357
    tok2 = 1;
  }
#line 359
  if (! fa) {
#line 360
    return (0);
  }
#line 362
  if (tok1 == 1) {
    {
#line 363
    tok2 = tok1;
#line 364
    tmp = strlen((char const   *)string);
#line 364
    len = (int )tmp;
    }
#line 366
    if ((int )*(string + 0) == 46) {
#line 367
      tok1 = 4100;
    } else
#line 368
    if ((int )*(string + 0) == 47) {
#line 369
      if ((int )*(string + (len - 1)) == 47) {
#line 370
        tok1 = 4098;
      } else {
#line 372
        tok1 = 4101;
      }
    } else {
#line 375
      tok1 = 4099;
    }
  }
#line 378
  if ((tok1 & -4096) != 4096) {
#line 379
    return (-2);
  }
#line 381
  if (tok2 == 0) {
    {
#line 382
    tok2 = get_next_token___0(& stringp, & string);
    }
#line 383
    if (tok2 != 1) {
#line 384
      return (-1);
    }
    {
#line 386
    tmp___0 = strlen((char const   *)string);
#line 386
    len = (int )tmp___0;
    }
  }
#line 389
  fa->fa_type = tok1 & 4095;
#line 390
  fa->is_initialized = 0;
#line 392
  if (tok1 != 4096) {
#line 392
    if (tok1 != 4102) {
#line 393
      if (tok1 == 4098) {
#line 393
        goto _L;
      } else
#line 393
      if (tok1 == 4097) {
        _L: /* CIL Label */ 
#line 395
        if ((int )*(string + (len - 1)) != 47) {
#line 396
          *(string + len) = (char )'/';
#line 397
          len ++;
        }
      }
#line 401
      if (tok1 != 4103) {
        {
#line 402
        tmp___1 = mymalloc___0((size_t )(len + 1));
#line 402
        fa->name = tmp___1;
        }
#line 403
        if ((unsigned long )fa->name == (unsigned long )((char *)0)) {
#line 404
          return (-7);
        }
        {
#line 406
        fa->namelength = len;
#line 407
        strncpy((char */* __restrict  */)fa->name, (char const   */* __restrict  */)string,
                (size_t )len);
#line 408
        *(fa->name + len) = (char )'\000';
        }
      } else {
        {
#line 414
        tmp___2 = __errno_location();
#line 414
        olderrno = *tmp___2;
#line 415
        st = stat((char const   */* __restrict  */)string, (struct stat */* __restrict  */)(& buf));
#line 416
        tmp___3 = __errno_location();
#line 416
        *tmp___3 = olderrno;
        }
#line 418
        if (st == 0) {
          {
#line 419
          fa->dev = buf.st_dev;
#line 420
          tmp___5 = strcmp((char const   *)string, "/");
          }
#line 420
          if (tmp___5) {
            {
#line 422
            strcpy((char */* __restrict  */)(tmp___4), (char const   */* __restrict  */)string);
#line 423
            strcat((char */* __restrict  */)(tmp___4), (char const   */* __restrict  */)"/..");
#line 424
            st = stat((char const   */* __restrict  */)(tmp___4), (struct stat */* __restrict  */)(& buf));
            }
#line 425
            if (st < 0) {
#line 426
              fa->namelength = 0;
            } else
#line 425
            if (buf.st_dev == fa->dev) {
#line 426
              fa->namelength = 0;
            }
          }
        } else {
#line 429
          fa->dev = (dev_t )0;
        }
      }
    }
  }
#line 433
  if (! tok3) {
    {
#line 434
    tok3 = get_next_token___0(& stringp, & string);
    }
#line 435
    if ((tok3 & -4096) != 16384) {
#line 436
      return (-3);
    }
  }
  {
#line 439
  fa->pipe_mode = tok3 & 4095;
#line 441
  tmp___6 = get_next_token___0(& stringp, & string);
  }
#line 441
  if (tmp___6 != 8) {
#line 442
    return (-4);
  }
#line 444
  if (fa->fa_type == 0) {
#line 445
    return (1);
  }
#line 446
  return (0);
}
}
#line 451 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/parseconfig.c"
static FilenameActions userFilenameActions___0[100]  ;
#line 457 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/parseconfig.c"
static int parse_class___0(FILE *f , int *line , FilenameActions *fa ) 
{ 
  char buffer___1[1024] ;
  char *stringp ;
  int count ;
  int ret ;
  char *tmp ;

  {
#line 464
  count = 0;
  {
#line 465
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 466
    tmp = fgets((char */* __restrict  */)(buffer___1), 1024, (FILE */* __restrict  */)f);
    }
#line 466
    if ((unsigned long )tmp == (unsigned long )((char *)0)) {
#line 467
      return (-9);
    }
    {
#line 468
    (*line) ++;
#line 469
    stringp = buffer___1;
#line 470
    ret = parse_fa_line___0(buffer___1, fa);
    }
#line 471
    if (ret == 2) {
#line 472
      goto while_continue;
    }
#line 473
    if (ret) {
#line 474
      return (ret);
    }
#line 475
    if (fa) {
#line 476
      fa ++;
#line 477
      count ++;
    }
#line 479
    if (count > 100) {
#line 480
      return (-8);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 488 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/parseconfig.c"
int parse_file(char *progname , FILE *f , int *line , int *mode , int *modemask ,
               char *classname ) 
{ 
  char buffer___1[1024] ;
  int state ;
  char *stringp ;
  char *string ;
  int ret ;
  int tok ;
  FilenameActions *fa ;
  char *tmp ;

  {
#line 496
  state = 1;
#line 502
  *line = 0;
  {
#line 503
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 504
    tmp = fgets((char */* __restrict  */)(buffer___1), 1024, (FILE */* __restrict  */)f);
    }
#line 504
    if ((unsigned long )tmp == (unsigned long )((char *)0)) {
#line 505
      return (0);
    }
    {
#line 507
    (*line) ++;
#line 509
    stringp = buffer___1;
#line 510
    tok = get_next_token___0(& stringp, & string);
    }
#line 513
    if (tok == 8) {
#line 514
      goto while_continue;
    }
#line 517
    if (tok == 2) {
#line 518
      if (state == 2) {
#line 519
        return (-10);
      }
      {
#line 521
      ret = parse_commands_line___0(progname, stringp, classname, mode, modemask);
      }
#line 522
      if (ret < 0) {
#line 523
        return (ret);
      }
#line 524
      goto while_continue;
    }
#line 528
    if (tok == 4) {
      {
#line 529
      state = 2;
#line 538
      tok = get_next_token___0(& stringp, & string);
      }
#line 539
      if (tok != 1) {
#line 540
        return (-1);
      }
      {
#line 548
      fa = userFilenameActions___0;
#line 549
      ret = parse_class___0(f, line, fa);
      }
#line 550
      if (ret < 0) {
#line 551
        return (ret);
      }
      {
#line 558
      print_class(fa, string, *line);
      }
#line 560
      goto while_continue;
    }
#line 562
    return (-6);
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 580 "/usr/include/stdio.h"
extern int putchar(int __c ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/printconfig.c"
commands_line *commands_lines  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/printconfig.c"
int generation  =    0;
#line 28 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/printconfig.c"
int zlib_mode  =    0;
#line 29 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/printconfig.c"
commands_line *make_entry(char *name ) 
{ 
  commands_line *ptr ;
  commands_line *newptr ;
  int tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
#line 33
  ptr = commands_lines;
  {
#line 33
  while (1) {
    while_continue: /* CIL Label */ ;
#line 33
    if (! ptr) {
#line 33
      goto while_break;
    }
    {
#line 34
    tmp = strcmp((char const   *)ptr->name, (char const   *)name);
    }
#line 34
    if (! tmp) {
#line 35
      return (ptr);
    }
#line 33
    ptr = ptr->globalnext;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 37
  tmp___0 = malloc(sizeof(commands_line ));
#line 37
  newptr = (commands_line *)tmp___0;
  }
#line 38
  if (! newptr) {
    {
#line 39
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory\n");
#line 40
    exit(1);
    }
#line 41
    return ((commands_line *)0);
  }
  {
#line 43
  newptr->globalnext = commands_lines;
#line 44
  commands_lines = newptr;
#line 45
  tmp___1 = strlen((char const   *)name);
#line 45
  tmp___2 = malloc(tmp___1 + 1UL);
#line 45
  newptr->name = (char *)tmp___2;
  }
#line 46
  if (! newptr->name) {
    {
#line 47
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory\n");
#line 48
    exit(1);
    }
#line 49
    return ((commands_line *)0);
  }
  {
#line 51
  strcpy((char */* __restrict  */)newptr->name, (char const   */* __restrict  */)name);
#line 52
  newptr->mode = 0;
#line 53
  newptr->modemask = 0;
#line 54
  newptr->generation = 0;
#line 55
  newptr->localnext = (struct commands_line *)0;
#line 56
  newptr->class[0] = (char )'\000';
#line 57
  newptr->defined = 0;
  }
#line 58
  return (newptr);
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/printconfig.c"
commands_line *default_cl  =    (commands_line *)0;
#line 63 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/printconfig.c"
int add_prog(commands_line **cmd , char *name ) 
{ 
  commands_line *ptr ;

  {
  {
#line 67
  ptr = make_entry(name);
  }
#line 68
  if (! ptr) {
#line 69
    return (-7);
  }
#line 70
  default_cl = ptr;
#line 71
  if (ptr->generation == generation) {
#line 72
    return (-12);
  }
#line 73
  ptr->localnext = *cmd;
#line 74
  *cmd = ptr;
#line 75
  return (0);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/printconfig.c"
int add_default(commands_line **cmd ) 
{ 
  commands_line *ptr ;

  {
  {
#line 82
  ptr = make_entry((char *)"");
  }
#line 83
  if (! ptr) {
#line 84
    return (-7);
  }
#line 85
  if (ptr->generation == generation) {
#line 86
    return (-12);
  }
#line 87
  ptr->localnext = *cmd;
#line 88
  *cmd = ptr;
#line 89
  return (0);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/printconfig.c"
void print_class(FilenameActions *fa , char *name , int line ) 
{ 
  int i ;
  int notfirst ;
  commands_line *ptr ;
  int needed ;
  int tmp ;

  {
#line 103
  needed = 0;
#line 104
  ptr = commands_lines;
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    if (! ptr) {
#line 104
      goto while_break;
    }
    {
#line 105
    tmp = strcmp((char const   *)(ptr->class), (char const   *)name);
    }
#line 105
    if (! tmp) {
#line 106
      if (ptr->defined) {
        {
#line 107
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Class %s defined twice!\n",
                name);
#line 108
        exit(1);
        }
      }
#line 110
      needed = 1;
#line 111
      ptr->defined = 1;
    }
#line 104
    ptr = ptr->globalnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  if (! needed) {
#line 116
    return;
  }
  {
#line 118
  printf((char const   */* __restrict  */)"static FilenameActions zlibc_class_%s[]={\n",
         name);
  }
  {
#line 119
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 120
    if (fa->fa_type == 7) {
      {
#line 125
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Skipping filesystem criterion in class %s near line %d\n",
              name, line);
#line 128
      fa ++;
      }
#line 129
      goto while_continue___0;
    } else {
      {
#line 132
      printf((char const   */* __restrict  */)"FREC( ");
      }
#line 133
      if (fa->fa_type == 0) {
#line 134
        fa->namelength = 0;
      }
      {
#line 137
      if (fa->fa_type == 0) {
#line 137
        goto case_0;
      }
#line 138
      if (fa->fa_type == 1) {
#line 138
        goto case_1;
      }
#line 139
      if (fa->fa_type == 2) {
#line 139
        goto case_2;
      }
#line 140
      if (fa->fa_type == 3) {
#line 140
        goto case_3;
      }
#line 141
      if (fa->fa_type == 4) {
#line 141
        goto case_4;
      }
#line 142
      if (fa->fa_type == 6) {
#line 142
        goto case_6;
      }
#line 136
      goto switch_break;
      case_0: /* CIL Label */ 
      {
#line 137
      printf((char const   */* __restrict  */)"FA_ALL");
      }
#line 137
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 138
      printf((char const   */* __restrict  */)"FA_DIR");
      }
#line 138
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 139
      printf((char const   */* __restrict  */)"FA_SUBDIR");
      }
#line 139
      goto switch_break;
      case_3: /* CIL Label */ 
      {
#line 140
      printf((char const   */* __restrict  */)"FA_BASENAME");
      }
#line 140
      goto switch_break;
      case_4: /* CIL Label */ 
      {
#line 141
      printf((char const   */* __restrict  */)"FA_SUFFIX");
      }
#line 141
      goto switch_break;
      case_6: /* CIL Label */ 
      {
#line 142
      printf((char const   */* __restrict  */)"FA_ALL2");
      }
#line 142
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 144
      if (fa->fa_type != 7) {
        {
#line 145
        printf((char const   */* __restrict  */)",\t\"");
#line 146
        i = 0;
        }
        {
#line 146
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 146
          if (! (i < fa->namelength)) {
#line 146
            goto while_break___1;
          }
          {
#line 147
          putchar((int )*(fa->name + i));
#line 146
          i ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 148
        putchar('\"');
        }
      }
    }
    {
#line 151
    printf((char const   */* __restrict  */)",\t");
    }
#line 152
    if (fa->pipe_mode == 0) {
      {
#line 153
      printf((char const   */* __restrict  */)"PM_NONE");
      }
    } else {
#line 155
      notfirst = 0;
      {
#line 157
      if ((fa->pipe_mode & 7) == 1) {
#line 157
        goto case_1___0;
      }
#line 158
      if ((fa->pipe_mode & 7) == 2) {
#line 158
        goto case_2___0;
      }
#line 159
      if ((fa->pipe_mode & 7) == 3) {
#line 159
        goto case_3___0;
      }
#line 160
      if ((fa->pipe_mode & 7) == 4) {
#line 160
        goto case_4___0;
      }
#line 161
      if ((fa->pipe_mode & 7) == 5) {
#line 161
        goto case_5;
      }
#line 156
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
#line 157
      if (notfirst) {
        {
#line 157
        putchar('|');
        }
      }
      {
#line 157
      printf((char const   */* __restrict  */)"PM_USE_TMP_FILE");
#line 157
      notfirst = 1;
      }
#line 157
      goto switch_break___0;
      case_2___0: /* CIL Label */ 
#line 158
      if (notfirst) {
        {
#line 158
        putchar('|');
        }
      }
      {
#line 158
      printf((char const   */* __restrict  */)"PM_HIDE_PIPE");
#line 158
      notfirst = 1;
      }
#line 158
      goto switch_break___0;
      case_3___0: /* CIL Label */ 
#line 159
      if (notfirst) {
        {
#line 159
        putchar('|');
        }
      }
      {
#line 159
      printf((char const   */* __restrict  */)"PM_SHOW_PIPE");
#line 159
      notfirst = 1;
      }
#line 159
      goto switch_break___0;
      case_4___0: /* CIL Label */ 
#line 160
      if (notfirst) {
        {
#line 160
        putchar('|');
        }
      }
      {
#line 160
      printf((char const   */* __restrict  */)"PM_DIR_LEAVE_COMPR");
#line 160
      notfirst = 1;
      }
#line 160
      goto switch_break___0;
      case_5: /* CIL Label */ 
#line 161
      if (notfirst) {
        {
#line 161
        putchar('|');
        }
      }
      {
#line 161
      printf((char const   */* __restrict  */)"PM_LEAVE_COMPR");
#line 161
      notfirst = 1;
      }
#line 161
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
      {
#line 165
      if ((fa->pipe_mode & 24) == 8) {
#line 165
        goto case_8;
      }
#line 166
      if ((fa->pipe_mode & 24) == 16) {
#line 166
        goto case_16;
      }
#line 164
      goto switch_break___1;
      case_8: /* CIL Label */ 
#line 165
      if (notfirst) {
        {
#line 165
        putchar('|');
        }
      }
      {
#line 165
      printf((char const   */* __restrict  */)"PM_CREATE_COMPR");
#line 165
      notfirst = 1;
      }
#line 165
      goto switch_break___1;
      case_16: /* CIL Label */ 
#line 166
      if (notfirst) {
        {
#line 166
        putchar('|');
        }
      }
      {
#line 166
      printf((char const   */* __restrict  */)"PM_NOCREATE_COMPR");
#line 166
      notfirst = 1;
      }
#line 166
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
      {
#line 170
      if ((fa->pipe_mode & 96) == 32) {
#line 170
        goto case_32;
      }
#line 171
      if ((fa->pipe_mode & 96) == 64) {
#line 171
        goto case_64;
      }
#line 169
      goto switch_break___2;
      case_32: /* CIL Label */ 
#line 170
      if (notfirst) {
        {
#line 170
        putchar('|');
        }
      }
      {
#line 170
      printf((char const   */* __restrict  */)"PM_APPEND_COMPR");
#line 170
      notfirst = 1;
      }
#line 170
      goto switch_break___2;
      case_64: /* CIL Label */ 
#line 171
      if (notfirst) {
        {
#line 171
        putchar('|');
        }
      }
      {
#line 171
      printf((char const   */* __restrict  */)"PM_NOAPPEND_COMPR");
#line 171
      notfirst = 1;
      }
#line 171
      goto switch_break___2;
      switch_break___2: /* CIL Label */ ;
      }
      {
#line 175
      if ((fa->pipe_mode & 384) == 128) {
#line 175
        goto case_128;
      }
#line 176
      if ((fa->pipe_mode & 384) == 256) {
#line 176
        goto case_256;
      }
#line 174
      goto switch_break___3;
      case_128: /* CIL Label */ 
#line 175
      if (notfirst) {
        {
#line 175
        putchar('|');
        }
      }
      {
#line 175
      printf((char const   */* __restrict  */)"PM_UNCOMPR_BEFORE_WRITE");
#line 175
      notfirst = 1;
      }
#line 175
      goto switch_break___3;
      case_256: /* CIL Label */ 
#line 176
      if (notfirst) {
        {
#line 176
        putchar('|');
        }
      }
      {
#line 176
      printf((char const   */* __restrict  */)"PM_NO_UNCOMPR_BEFORE_WRITE");
#line 176
      notfirst = 1;
      }
#line 176
      goto switch_break___3;
      switch_break___3: /* CIL Label */ ;
      }
      {
#line 180
      if ((fa->pipe_mode & 512) == 512) {
#line 180
        goto case_512;
      }
#line 181
      if ((fa->pipe_mode & 512) == 1024) {
#line 181
        goto case_1024;
      }
#line 179
      goto switch_break___4;
      case_512: /* CIL Label */ 
#line 180
      if (notfirst) {
        {
#line 180
        putchar('|');
        }
      }
      {
#line 180
      printf((char const   */* __restrict  */)"PM_SIZE_COMPR");
#line 180
      notfirst = 1;
      }
#line 180
      goto switch_break___4;
      case_1024: /* CIL Label */ 
#line 181
      if (notfirst) {
        {
#line 181
        putchar('|');
        }
      }
      {
#line 181
      printf((char const   */* __restrict  */)"PM_SIZE_UNCOMPR");
#line 181
      notfirst = 1;
      }
#line 181
      goto switch_break___4;
      switch_break___4: /* CIL Label */ ;
      }
    }
    {
#line 185
    printf((char const   */* __restrict  */)")");
    }
#line 186
    if (fa->fa_type == 0) {
      {
#line 187
      printf((char const   */* __restrict  */)"};\n\n");
      }
#line 188
      goto while_break___0;
    } else {
      {
#line 190
      printf((char const   */* __restrict  */)",\n");
      }
    }
#line 191
    fa ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 193
  return;
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/printconfig.c"
void print_commands_line(commands_line *ptr , int end ) 
{ 
  int notfirst ;

  {
  {
#line 200
  notfirst = 0;
#line 202
  printf((char const   */* __restrict  */)"{ ");
  }
#line 203
  if (*(ptr->name + 0)) {
    {
#line 204
    printf((char const   */* __restrict  */)"\"%s\"", ptr->name);
    }
  } else {
    {
#line 206
    putchar('0');
    }
  }
  {
#line 207
  printf((char const   */* __restrict  */)",\t");
  }
#line 209
  if (! ptr->mode) {
    {
#line 210
    printf((char const   */* __restrict  */)"0");
    }
  } else {
#line 212
    if (ptr->mode & 2) {
#line 212
      if (notfirst) {
        {
#line 212
        putchar('|');
        }
      }
      {
#line 212
      printf((char const   */* __restrict  */)"CM_DISAB");
#line 212
      notfirst = 1;
      }
    }
#line 213
    if (ptr->mode & 64) {
#line 213
      if (notfirst) {
        {
#line 213
        putchar('|');
        }
      }
      {
#line 213
      printf((char const   */* __restrict  */)"CM_DISAB_CHILD");
#line 213
      notfirst = 1;
      }
    }
#line 214
    if (ptr->mode & 4) {
#line 214
      if (notfirst) {
        {
#line 214
        putchar('|');
        }
      }
      {
#line 214
      printf((char const   */* __restrict  */)"CM_READDIR_COMPR");
#line 214
      notfirst = 1;
      }
    }
#line 215
    if (ptr->mode & 8) {
#line 215
      if (notfirst) {
        {
#line 215
        putchar('|');
        }
      }
      {
#line 215
      printf((char const   */* __restrict  */)"CM_VERBOSE");
#line 215
      notfirst = 1;
      }
    }
#line 216
    if (ptr->mode & 16) {
#line 216
      if (notfirst) {
        {
#line 216
        putchar('|');
        }
      }
      {
#line 216
      printf((char const   */* __restrict  */)"CM_UNLINK");
#line 216
      notfirst = 1;
      }
    }
#line 217
    if (ptr->mode & 32) {
#line 217
      if (notfirst) {
        {
#line 217
        putchar('|');
        }
      }
      {
#line 217
      printf((char const   */* __restrict  */)"CM_NORTCONF");
#line 217
      notfirst = 1;
      }
    }
  }
  {
#line 220
  printf((char const   */* __restrict  */)",\t");
  }
#line 221
  if (ptr->class) {
#line 221
    if (ptr->class[0]) {
#line 222
      if (! ptr->defined) {
        {
#line 223
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Class %s undefined (needed by %s)\n",
                ptr->class, ptr->name);
#line 225
        exit(1);
        }
      }
      {
#line 227
      printf((char const   */* __restrict  */)"zlibc_class_%s", ptr->class);
      }
    } else {
#line 221
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 228
  if (default_cl) {
#line 228
    if (default_cl->class) {
#line 228
      if (default_cl->class[0]) {
        {
#line 229
        printf((char const   */* __restrict  */)"zlibc_class_%s", default_cl->class);
        }
      } else {
        {
#line 231
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing default class\n");
#line 232
        exit(1);
        }
      }
    } else {
      {
#line 231
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing default class\n");
#line 232
      exit(1);
      }
    }
  } else {
    {
#line 231
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing default class\n");
#line 232
    exit(1);
    }
  }
  {
#line 234
  putchar('}');
  }
#line 235
  if (! end) {
    {
#line 236
    putchar(',');
    }
  }
  {
#line 237
  putchar('\n');
  }
#line 238
  return;
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/printconfig.c"
void print_commands_lines(void) 
{ 
  commands_line *ptr ;
  commands_line *def ;

  {
  {
#line 245
  printf((char const   */* __restrict  */)"\nCommandActions zlib_commandActions[]={\n");
#line 247
  def = (commands_line *)0;
#line 248
  ptr = commands_lines;
  }
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;
#line 248
    if (! ptr) {
#line 248
      goto while_break;
    }
#line 249
    if ((int )*(ptr->name + 0) == 0) {
#line 250
      def = ptr;
    } else {
      {
#line 252
      print_commands_line(ptr, 0);
      }
    }
#line 248
    ptr = ptr->globalnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 254
  if (def) {
    {
#line 255
    print_commands_line(def, 1);
    }
  } else {
    {
#line 257
    printf((char const   */* __restrict  */)"0,0,0}\n");
    }
  }
  {
#line 258
  printf((char const   */* __restrict  */)"};\n");
  }
#line 259
  return;
}
}
#line 261 "/home/june/repo/benchmarks/collector/temp/zlibc-0.9k/printconfig.c"
int main(int argc , char **argv ) 
{ 
  int line ;
  int ret ;
  FILE *f ;

  {
#line 267
  if (argc == 1) {
    {
#line 268
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s file\n",
            *(argv + 0));
#line 269
    exit(1);
    }
  }
  {
#line 271
  f = fopen((char const   */* __restrict  */)*(argv + 1), (char const   */* __restrict  */)"r");
  }
#line 272
  if (! f) {
    {
#line 273
    perror("fopen");
#line 274
    exit(1);
    }
  }
  {
#line 276
  printf((char const   */* __restrict  */)"/* This file is generated automatically. DO NOT EDIT*/\n");
#line 277
  printf((char const   */* __restrict  */)"#define _LARGEFILE64_SOURCE\n");
#line 278
  printf((char const   */* __restrict  */)"#define _GNU_SOURCE\n");
#line 280
  printf((char const   */* __restrict  */)"#include \"sysincludes.h\" \n");
#line 281
  ret = parse_file((char *)0, f, & line, (int *)0, (int *)0, (char *)0);
  }
#line 282
  if (ret < 0) {
    {
#line 283
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"zlibc: %s in line %d\n",
            err_strings[- ret], line);
#line 286
    exit(1);
    }
  }
  {
#line 288
  print_commands_lines();
  }
#line 289
  return (0);
}
}
