/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 116 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __caddr_t caddr_t;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned char u_int8_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_13 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_13 __sigset_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 36 "/usr/include/x86_64-linux-gnu/sys/poll.h"
typedef unsigned long nfds_t;
#line 39 "/usr/include/x86_64-linux-gnu/sys/poll.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_38 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_39 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_40 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_41 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_42 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_43 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_44 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_37 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_38 _kill ;
   struct __anonstruct__timer_39 _timer ;
   struct __anonstruct__rt_40 _rt ;
   struct __anonstruct__sigchld_41 _sigchld ;
   struct __anonstruct__sigfault_42 _sigfault ;
   struct __anonstruct__sigpoll_43 _sigpoll ;
   struct __anonstruct__sigsys_44 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_36 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_37 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_36 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_56 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_56 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 111 "/usr/include/net/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifrn_62 {
   char ifrn_name[16] ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifru_63 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   __caddr_t ifru_data ;
};
#line 126 "/usr/include/net/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_62 ifr_ifrn ;
   union __anonunion_ifr_ifru_63 ifr_ifru ;
};
#line 176 "/usr/include/net/if.h"
union __anonunion_ifc_ifcu_64 {
   __caddr_t ifcu_buf ;
   struct ifreq *ifcu_req ;
};
#line 176 "/usr/include/net/if.h"
struct ifconf {
   int ifc_len ;
   union __anonunion_ifc_ifcu_64 ifc_ifcu ;
};
#line 54 "/usr/include/net/if_arp.h"
struct arphdr {
   unsigned short ar_hrd ;
   unsigned short ar_pro ;
   unsigned char ar_hln ;
   unsigned char ar_pln ;
   unsigned short ar_op ;
};
#line 138 "/usr/include/net/if_arp.h"
struct arpreq {
   struct sockaddr arp_pa ;
   struct sockaddr arp_ha ;
   int arp_flags ;
   struct sockaddr arp_netmask ;
   char arp_dev[16] ;
};
#line 20 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 23 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 26 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 28 "/usr/include/linux/types.h"
typedef __u16 __be16;
#line 32 "/usr/include/net/ethernet.h"
struct ether_addr {
   u_int8_t ether_addr_octet[6] ;
} __attribute__((__packed__)) ;
#line 12 "/usr/include/linux/if_packet.h"
struct sockaddr_ll {
   unsigned short sll_family ;
   __be16 sll_protocol ;
   int sll_ifindex ;
   unsigned short sll_hatype ;
   unsigned char sll_pkttype ;
   unsigned char sll_halen ;
   unsigned char sll_addr[8] ;
};
#line 23 "/usr/include/linux/filter.h"
struct sock_filter {
   __u16 code ;
   __u8 jt ;
   __u8 jf ;
   __u32 k ;
};
#line 30 "/usr/include/linux/filter.h"
struct sock_fprog {
   unsigned short len ;
   struct sock_filter *filter ;
};
#line 57 "/home/june/repo/benchmarks/collector/temp/rarpd-0.981107/rarpd.c"
struct rarpifaddr;
#line 57 "/home/june/repo/benchmarks/collector/temp/rarpd-0.981107/rarpd.c"
struct rarpiflink {
   struct rarpiflink *next ;
   int index ;
   int hatype ;
   u_int8_t lladdr[6] ;
   char name[16] ;
   struct rarpifaddr *ifa_list ;
};
#line 67 "/home/june/repo/benchmarks/collector/temp/rarpd-0.981107/rarpd.c"
struct rarpifaddr {
   struct rarpifaddr *next ;
   __u32 prefix ;
   __u32 mask ;
   __u32 local ;
};
#line 75 "/home/june/repo/benchmarks/collector/temp/rarpd-0.981107/rarpd.c"
struct rarp_map {
   struct rarp_map *next ;
   int ifindex ;
   int arp_type ;
   int lladdr_len ;
   u_int8_t lladdr[6] ;
   __u32 ipaddr ;
};
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 181 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 432
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 76
extern int opterr ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 163
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  *__addr , socklen_t __addr_len ) ;
#line 174
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 375
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 377
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 144 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 53 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/poll.h"
extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 259 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 40 "/usr/include/netinet/ether.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ether_ntohost)(char *__hostname ,
                                                                                    struct ether_addr  const  *__addr ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/rarpd-0.981107/rarpd.c"
int do_reload  =    1;
#line 42 "/home/june/repo/benchmarks/collector/temp/rarpd-0.981107/rarpd.c"
int debug  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/rarpd-0.981107/rarpd.c"
int verbose  ;
#line 44 "/home/june/repo/benchmarks/collector/temp/rarpd-0.981107/rarpd.c"
int ifidx  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/rarpd-0.981107/rarpd.c"
int allow_offlink  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/rarpd-0.981107/rarpd.c"
int only_ethers  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/rarpd-0.981107/rarpd.c"
int all_ifaces  ;
#line 48 "/home/june/repo/benchmarks/collector/temp/rarpd-0.981107/rarpd.c"
int listen_arp  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/rarpd-0.981107/rarpd.c"
char *ifname  ;
#line 50 "/home/june/repo/benchmarks/collector/temp/rarpd-0.981107/rarpd.c"
char const   *tftp_dir  =    "/tftpboot";
#line 55
 __attribute__((__noreturn__)) void usage(void) ;
#line 57 "/home/june/repo/benchmarks/collector/temp/rarpd-0.981107/rarpd.c"
struct rarpiflink *ifl_list  ;
#line 75 "/home/june/repo/benchmarks/collector/temp/rarpd-0.981107/rarpd.c"
struct rarp_map *rarp_db  ;
#line 86
 __attribute__((__noreturn__)) void usage(void) ;
#line 86 "/home/june/repo/benchmarks/collector/temp/rarpd-0.981107/rarpd.c"
void usage(void) 
{ 


  {
  {
#line 88
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: rarpd [ -dveaAo ] [ -b tftpdir ] [ interface]\n");
#line 89
  exit(1);
  }
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/rarpd-0.981107/rarpd.c"
void load_db(void) 
{ 


  {
#line 94
  return;
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/rarpd-0.981107/rarpd.c"
void load_if(void) 
{ 
  int fd ;
  struct ifreq *ifrp ;
  struct ifreq *ifend ;
  struct rarpiflink *ifl ;
  struct rarpifaddr *ifa ;
  struct ifconf ifc ;
  struct ifreq ibuf[256] ;
  int tmp ;
  __u32 addr ;
  __u32 mask ;
  __u32 prefix ;
  int tmp___0 ;
  char *p ;
  int index___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int i ;
  __u32 m ;
  uint32_t tmp___6 ;
  char *tmp___7 ;
  char tmpa[64] ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
  {
#line 105
  fd = socket(2, 2, 0);
  }
#line 105
  if (fd < 0) {
    {
#line 106
    syslog(3, "socket: %m");
    }
#line 107
    return;
  }
  {
#line 110
  ifc.ifc_len = (int )sizeof(ibuf);
#line 111
  ifc.ifc_ifcu.ifcu_buf = (caddr_t )(ibuf);
#line 112
  tmp = ioctl(fd, 35090UL, (char *)(& ifc));
  }
#line 112
  if (tmp < 0) {
    {
#line 114
    syslog(3, "SIOCGIFCONF: %m");
#line 115
    close(fd);
    }
#line 116
    return;
  } else
#line 112
  if (ifc.ifc_len < (int )sizeof(struct ifreq )) {
    {
#line 114
    syslog(3, "SIOCGIFCONF: %m");
#line 115
    close(fd);
    }
#line 116
    return;
  }
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 119
    ifl = ifl_list;
#line 119
    if (! ((unsigned long )ifl != (unsigned long )((void *)0))) {
#line 119
      goto while_break;
    }
    {
#line 120
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 120
      ifa = ifl->ifa_list;
#line 120
      if (! ((unsigned long )ifa != (unsigned long )((void *)0))) {
#line 120
        goto while_break___0;
      }
      {
#line 121
      ifl->ifa_list = ifa->next;
#line 122
      free((void *)ifa);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 124
    ifl_list = ifl->next;
#line 125
    free((void *)ifl);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 128
  ifend = (struct ifreq *)((char *)(ibuf) + ifc.ifc_len);
#line 129
  ifrp = ibuf;
  {
#line 129
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 129
    if (! ((unsigned long )ifrp < (unsigned long )ifend)) {
#line 129
      goto while_break___1;
    }
#line 134
    if ((int )ifrp->ifr_ifru.ifru_addr.sa_family != 2) {
#line 135
      goto __Cont;
    }
#line 136
    addr = ((struct sockaddr_in *)(& ifrp->ifr_ifru.ifru_addr))->sin_addr.s_addr;
#line 137
    if (addr == 0U) {
#line 138
      goto __Cont;
    }
    {
#line 139
    tmp___0 = ioctl(fd, 35123UL, ifrp);
    }
#line 139
    if (tmp___0) {
      {
#line 140
      syslog(3, "ioctl(SIOCGIFNAME): %m");
      }
#line 141
      goto __Cont;
    }
#line 143
    if (ifidx) {
#line 143
      if (ifrp->ifr_ifru.ifru_ivalue != ifidx) {
#line 144
        goto __Cont;
      }
    }
#line 145
    ifl = ifl_list;
    {
#line 145
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 145
      if (! ifl) {
#line 145
        goto while_break___2;
      }
#line 146
      if (ifl->index == ifrp->ifr_ifru.ifru_ivalue) {
#line 147
        goto while_break___2;
      }
#line 145
      ifl = ifl->next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 148
    if ((unsigned long )ifl == (unsigned long )((void *)0)) {
      {
#line 150
      index___0 = ifrp->ifr_ifru.ifru_ivalue;
#line 152
      tmp___1 = ioctl(fd, 35111UL, ifrp);
      }
#line 152
      if (tmp___1) {
        {
#line 153
        syslog(3, "ioctl(SIOCGIFHWADDR): %m");
        }
#line 154
        goto __Cont;
      }
      {
#line 157
      tmp___2 = malloc(sizeof(*ifl));
#line 157
      ifl = (struct rarpiflink *)tmp___2;
      }
#line 158
      if ((unsigned long )ifl == (unsigned long )((void *)0)) {
#line 159
        goto __Cont;
      }
      {
#line 160
      memset((void *)ifl, 0, sizeof(*ifl));
#line 161
      ifl->next = ifl_list;
#line 162
      ifl_list = ifl;
#line 163
      ifl->index = index___0;
#line 164
      ifl->hatype = (int )ifrp->ifr_ifru.ifru_hwaddr.sa_family;
#line 165
      memcpy((void */* __restrict  */)(ifl->lladdr), (void const   */* __restrict  */)(ifrp->ifr_ifru.ifru_hwaddr.sa_data),
             sizeof(u_int8_t ) * 6UL);
#line 166
      strncpy((char */* __restrict  */)(ifl->name), (char const   */* __restrict  */)(ifrp->ifr_ifrn.ifrn_name),
              (size_t )16);
#line 167
      ifl->name[15] = (char)0;
#line 168
      p = strchr((char const   *)(ifl->name), ':');
      }
#line 169
      if (p) {
#line 170
        *p = (char)0;
      }
#line 171
      if (verbose) {
        {
#line 172
        syslog(6, "link %s", ifl->name);
        }
      }
    }
    {
#line 174
    tmp___3 = ioctl(fd, 35099UL, ifrp);
    }
#line 174
    if (tmp___3) {
      {
#line 175
      syslog(3, "ioctl(SIOCGIFMASK): %m");
      }
#line 176
      goto __Cont;
    }
    {
#line 178
    mask = ((struct sockaddr_in *)(& ifrp->ifr_ifru.ifru_netmask))->sin_addr.s_addr;
#line 179
    tmp___4 = ioctl(fd, 35095UL, ifrp);
    }
#line 179
    if (tmp___4) {
      {
#line 180
      syslog(3, "ioctl(SIOCGIFDSTADDR): %m");
      }
#line 181
      goto __Cont;
    }
#line 183
    prefix = ((struct sockaddr_in *)(& ifrp->ifr_ifru.ifru_dstaddr))->sin_addr.s_addr;
#line 184
    ifa = ifl->ifa_list;
    {
#line 184
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 184
      if (! ifa) {
#line 184
        goto while_break___3;
      }
#line 185
      if (ifa->local == addr) {
#line 185
        if (ifa->prefix == prefix) {
#line 185
          if (ifa->mask == mask) {
#line 188
            goto while_break___3;
          }
        }
      }
#line 184
      ifa = ifa->next;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 190
    if ((unsigned long )ifa == (unsigned long )((void *)0)) {
#line 191
      if (mask == 0U) {
#line 192
        goto __Cont;
      } else
#line 191
      if (prefix == 0U) {
#line 192
        goto __Cont;
      }
      {
#line 193
      tmp___5 = malloc(sizeof(*ifa));
#line 193
      ifa = (struct rarpifaddr *)tmp___5;
#line 194
      memset((void *)ifa, 0, sizeof(*ifa));
#line 195
      ifa->local = addr;
#line 196
      ifa->prefix = prefix;
#line 197
      ifa->mask = mask;
#line 198
      ifa->next = ifl->ifa_list;
#line 199
      ifl->ifa_list = ifa;
      }
#line 201
      if (verbose) {
#line 203
        m = ~ 0U;
#line 204
        i = 32;
        {
#line 204
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 204
          if (! (i >= 0)) {
#line 204
            goto while_break___4;
          }
          {
#line 205
          tmp___6 = htonl(m);
          }
#line 205
          if (tmp___6 == mask) {
#line 206
            goto while_break___4;
          }
#line 207
          m <<= 1;
#line 204
          i --;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 209
        if (addr == prefix) {
          {
#line 210
          tmp___7 = inet_ntoa(*((struct in_addr *)(& addr)));
#line 210
          syslog(6, "  addr %s/%d on %s\n", tmp___7, i, ifl->name);
          }
        } else {
          {
#line 214
          tmp___8 = inet_ntoa(*((struct in_addr *)(& addr)));
#line 214
          sprintf((char */* __restrict  */)(tmpa), (char const   */* __restrict  */)"%s",
                  tmp___8);
#line 215
          tmp___9 = inet_ntoa(*((struct in_addr *)(& prefix)));
#line 215
          syslog(6, "  addr %s %s/%d on %s\n", tmpa, tmp___9, i, ifl->name);
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 129
    ifrp ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 221
  return;
}
}
#line 223 "/home/june/repo/benchmarks/collector/temp/rarpd-0.981107/rarpd.c"
void configure(void) 
{ 


  {
  {
#line 225
  syslog(6, "Building list of addresses per interface.");
#line 226
  load_if();
#line 227
  load_db();
  }
#line 228
  return;
}
}
#line 230 "/home/june/repo/benchmarks/collector/temp/rarpd-0.981107/rarpd.c"
int bootable(__u32 addr ) 
{ 
  struct dirent *dent ;
  DIR *d ;
  char name[9] ;
  uint32_t tmp ;
  int tmp___0 ;

  {
  {
#line 236
  tmp = ntohl(addr);
#line 236
  sprintf((char */* __restrict  */)(name), (char const   */* __restrict  */)"%08X",
          tmp);
#line 237
  d = opendir(tftp_dir);
  }
#line 238
  if ((unsigned long )d == (unsigned long )((void *)0)) {
    {
#line 239
    syslog(3, "opendir: %m");
    }
#line 240
    return (0);
  }
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 242
    dent = readdir(d);
    }
#line 242
    if (! ((unsigned long )dent != (unsigned long )((void *)0))) {
#line 242
      goto while_break;
    }
    {
#line 243
    tmp___0 = strncmp((char const   *)(dent->d_name), (char const   *)(name), (size_t )8);
    }
#line 243
    if (tmp___0 == 0) {
#line 244
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 246
  closedir(d);
  }
#line 247
  return ((unsigned long )dent != (unsigned long )((void *)0));
}
}
#line 250 "/home/june/repo/benchmarks/collector/temp/rarpd-0.981107/rarpd.c"
struct rarpifaddr *select_ipaddr(int ifindex , __u32 *sel_addr , __u32 **alist ) 
{ 
  struct rarpiflink *ifl ;
  struct rarpifaddr *ifa ;
  int retry ;
  int i ;
  __u32 addr ;

  {
#line 254
  retry = 0;
  retry: 
#line 258
  ifl = ifl_list;
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 258
    if (! ifl) {
#line 258
      goto while_break;
    }
#line 259
    if (ifl->index == ifindex) {
#line 260
      goto while_break;
    }
#line 258
    ifl = ifl->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 261
  if ((unsigned long )ifl == (unsigned long )((void *)0)) {
#line 261
    if (! retry) {
      {
#line 262
      retry ++;
#line 263
      load_if();
      }
#line 264
      goto retry;
    }
  }
#line 266
  if ((unsigned long )ifl == (unsigned long )((void *)0)) {
#line 267
    return ((struct rarpifaddr *)((void *)0));
  }
#line 269
  i = 0;
  {
#line 269
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 269
    if (! *(alist + i)) {
#line 269
      goto while_break___0;
    }
#line 270
    addr = *(*(alist + i));
#line 271
    ifa = ifl->ifa_list;
    {
#line 271
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 271
      if (! ifa) {
#line 271
        goto while_break___1;
      }
#line 272
      if (! ((ifa->prefix ^ addr) & ifa->mask)) {
#line 273
        *sel_addr = addr;
#line 274
        return (ifa);
      }
#line 271
      ifa = ifa->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 277
    if ((unsigned long )ifa == (unsigned long )((void *)0)) {
#line 277
      if (retry == 0) {
        {
#line 278
        retry ++;
#line 279
        load_if();
        }
#line 280
        goto retry;
      }
    }
#line 269
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 283
  if (i == 1) {
#line 283
    if (allow_offlink) {
#line 284
      *sel_addr = *(*(alist + 0));
#line 285
      return (ifl->ifa_list);
    }
  }
  {
#line 287
  syslog(3, "Off-link request on %s", ifl->name);
  }
#line 288
  return ((struct rarpifaddr *)((void *)0));
}
}
#line 312
struct rarp_map *rarp_lookup(int ifindex , int hatype , int halen , u_int8_t *lladdr ) ;
#line 312 "/home/june/repo/benchmarks/collector/temp/rarpd-0.981107/rarpd.c"
static struct rarp_map emap  =    {(struct rarp_map *)((void *)0), 0, 1, 6, {(unsigned char)0, (unsigned char)0,
                                              (unsigned char)0, (unsigned char)0,
                                              (unsigned char)0, (unsigned char)0},
    0U};
#line 291 "/home/june/repo/benchmarks/collector/temp/rarpd-0.981107/rarpd.c"
struct rarp_map *rarp_lookup(int ifindex , int hatype , int halen , u_int8_t *lladdr ) 
{ 
  struct rarp_map *r ;
  int tmp ;
  struct rarpifaddr *ifa ;
  struct hostent *hp ;
  char ename[256] ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 296
  r = rarp_db;
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    if (! r) {
#line 296
      goto while_break;
    }
#line 297
    if (r->arp_type != hatype) {
#line 297
      if (r->arp_type != -1) {
#line 298
        goto __Cont;
      }
    }
#line 299
    if (r->lladdr_len != halen) {
#line 300
      goto __Cont;
    }
#line 301
    if (r->ifindex != ifindex) {
#line 301
      if (r->ifindex != 0) {
#line 302
        goto __Cont;
      }
    }
    {
#line 303
    tmp = memcmp((void const   *)(r->lladdr), (void const   *)lladdr, (size_t )halen);
    }
#line 303
    if (tmp == 0) {
#line 304
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 296
    r = r->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 307
  if ((unsigned long )r == (unsigned long )((void *)0)) {
#line 308
    if (hatype == 1) {
#line 308
      if (halen == 6) {
        {
#line 319
        tmp___0 = ether_ntohost(ename, (struct ether_addr  const  *)((struct ether_addr *)lladdr));
        }
#line 319
        if (tmp___0 != 0) {
#line 319
          goto _L;
        } else {
          {
#line 319
          hp = gethostbyname((char const   *)(ename));
          }
#line 319
          if ((unsigned long )hp == (unsigned long )((void *)0)) {
            _L: /* CIL Label */ 
#line 321
            if (verbose) {
              {
#line 322
              syslog(6, "not found in /etc/ethers");
              }
            }
#line 323
            return ((struct rarp_map *)((void *)0));
          }
        }
#line 325
        if (hp->h_addrtype != 2) {
          {
#line 326
          syslog(3, "no IP address");
          }
#line 327
          return ((struct rarp_map *)((void *)0));
        }
        {
#line 329
        ifa = select_ipaddr(ifindex, & emap.ipaddr, (__u32 **)hp->h_addr_list);
        }
#line 330
        if (ifa) {
          {
#line 331
          memcpy((void */* __restrict  */)(emap.lladdr), (void const   */* __restrict  */)lladdr,
                 sizeof(u_int8_t ) * 6UL);
          }
#line 332
          if (only_ethers) {
#line 333
            return (& emap);
          } else {
            {
#line 332
            tmp___1 = bootable(emap.ipaddr);
            }
#line 332
            if (tmp___1) {
#line 333
              return (& emap);
            }
          }
#line 334
          if (verbose) {
            {
#line 335
            syslog(6, "not bootable");
            }
          }
        }
      }
    }
  }
#line 339
  return (r);
}
}
#line 344
static int load_arp_bpflet(int fd ) ;
#line 344 "/home/june/repo/benchmarks/collector/temp/rarpd-0.981107/rarpd.c"
static struct sock_filter insns[4]  = {      {(unsigned short)40, (__u8 )0, (__u8 )0, (__u32 )6}, 
        {(unsigned short)21, (__u8 )0, (__u8 )1, (__u32 )3}, 
        {(unsigned short)6, (__u8 )0, (__u8 )0, (__u32 )1024}, 
        {(unsigned short)6, (__u8 )0, (__u8 )0, (__u32 )0}};
#line 350
static int load_arp_bpflet(int fd ) ;
#line 350 "/home/june/repo/benchmarks/collector/temp/rarpd-0.981107/rarpd.c"
static struct sock_fprog filter  =    {(unsigned short )(sizeof(insns) / sizeof(insns[0])), insns};
#line 342 "/home/june/repo/benchmarks/collector/temp/rarpd-0.981107/rarpd.c"
static int load_arp_bpflet(int fd ) 
{ 
  int tmp ;

  {
  {
#line 355
  tmp = setsockopt(fd, 1, 26, (void const   *)(& filter), (socklen_t )sizeof(filter));
  }
#line 355
  return (tmp);
}
}
#line 358 "/home/june/repo/benchmarks/collector/temp/rarpd-0.981107/rarpd.c"
int put_mylladdr(unsigned char **ptr_p , int ifindex , int alen ) 
{ 
  struct rarpiflink *ifl ;

  {
#line 362
  ifl = ifl_list;
  {
#line 362
  while (1) {
    while_continue: /* CIL Label */ ;
#line 362
    if (! ifl) {
#line 362
      goto while_break;
    }
#line 363
    if (ifl->index == ifindex) {
#line 364
      goto while_break;
    }
#line 362
    ifl = ifl->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 366
  if ((unsigned long )ifl == (unsigned long )((void *)0)) {
#line 367
    return (-1);
  }
  {
#line 369
  memcpy((void */* __restrict  */)*ptr_p, (void const   */* __restrict  */)(ifl->lladdr),
         (size_t )alen);
#line 370
  *ptr_p += alen;
  }
#line 371
  return (0);
}
}
#line 374 "/home/june/repo/benchmarks/collector/temp/rarpd-0.981107/rarpd.c"
int put_myipaddr(unsigned char **ptr_p , int ifindex , __u32 hisipaddr ) 
{ 
  __u32 laddr ;
  struct rarpiflink *ifl ;
  struct rarpifaddr *ifa ;

  {
#line 376
  laddr = (__u32 )0;
#line 380
  ifl = ifl_list;
  {
#line 380
  while (1) {
    while_continue: /* CIL Label */ ;
#line 380
    if (! ifl) {
#line 380
      goto while_break;
    }
#line 381
    if (ifl->index == ifindex) {
#line 382
      goto while_break;
    }
#line 380
    ifl = ifl->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 384
  if ((unsigned long )ifl == (unsigned long )((void *)0)) {
#line 385
    return (-1);
  }
#line 387
  ifa = ifl->ifa_list;
  {
#line 387
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 387
    if (! ifa) {
#line 387
      goto while_break___0;
    }
#line 388
    if (! ((ifa->prefix ^ hisipaddr) & ifa->mask)) {
#line 389
      laddr = ifa->local;
#line 390
      goto while_break___0;
    }
#line 387
    ifa = ifa->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 393
  memcpy((void */* __restrict  */)*ptr_p, (void const   */* __restrict  */)(& laddr),
         (size_t )4);
#line 394
  *ptr_p += 4;
  }
#line 395
  return (0);
}
}
#line 398 "/home/june/repo/benchmarks/collector/temp/rarpd-0.981107/rarpd.c"
void arp_advise(int ifindex , u_int8_t *lladdr , int lllen , __u32 ipaddr ) 
{ 
  int fd ;
  struct arpreq req ;
  struct sockaddr_in *sin ;
  struct rarpiflink *ifl ;
  int tmp ;

  {
#line 405
  ifl = ifl_list;
  {
#line 405
  while (1) {
    while_continue: /* CIL Label */ ;
#line 405
    if (! ifl) {
#line 405
      goto while_break;
    }
#line 406
    if (ifl->index == ifindex) {
#line 407
      goto while_break;
    }
#line 405
    ifl = ifl->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 409
  if ((unsigned long )ifl == (unsigned long )((void *)0)) {
#line 410
    return;
  }
  {
#line 412
  fd = socket(2, 2, 0);
#line 413
  memset((void *)(& req), 0, sizeof(req));
#line 414
  req.arp_flags = 2;
#line 415
  sin = (struct sockaddr_in *)(& req.arp_pa);
#line 416
  sin->sin_family = (sa_family_t )2;
#line 417
  sin->sin_addr.s_addr = ipaddr;
#line 418
  req.arp_ha.sa_family = (sa_family_t )ifl->hatype;
#line 419
  memcpy((void */* __restrict  */)(req.arp_ha.sa_data), (void const   */* __restrict  */)lladdr,
         (size_t )lllen);
#line 420
  memcpy((void */* __restrict  */)(req.arp_dev), (void const   */* __restrict  */)(ifl->name),
         (size_t )16);
#line 422
  tmp = ioctl(fd, 35157UL, & req);
  }
#line 422
  if (tmp) {
    {
#line 423
    syslog(3, "SIOCSARP: %m");
    }
  }
  {
#line 424
  close(fd);
  }
#line 425
  return;
}
}
#line 430 "/home/june/repo/benchmarks/collector/temp/rarpd-0.981107/rarpd.c"
int serve_it(int fd ) 
{ 
  unsigned char buf[1024] ;
  struct sockaddr_ll sll ;
  socklen_t sll_len ;
  struct arphdr *a ;
  struct rarp_map *rmap ;
  unsigned char *ptr ;
  int n ;
  char tmpbuf[48] ;
  char tmpname[16] ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  uint16_t tmp___2 ;
  int i ;
  char *ptr___0 ;
  struct rarpiflink *ifl ;
  char const   *tmp___4 ;
  uint16_t tmp___5 ;
  uint16_t tmp___6 ;
  uint16_t tmp___7 ;
  uint16_t tmp___8 ;
  uint16_t tmp___9 ;
  uint16_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;

  {
#line 434
  sll_len = (socklen_t )sizeof(sll);
#line 435
  a = (struct arphdr *)(buf);
#line 441
  if (fd < 0) {
#line 442
    return (0);
  }
  {
#line 444
  tmp = recvfrom(fd, (void */* __restrict  */)(buf), sizeof(buf), 64, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& sll)),
                 (socklen_t */* __restrict  */)(& sll_len));
#line 444
  n = (int )tmp;
  }
#line 445
  if (n < 0) {
    {
#line 446
    tmp___0 = __errno_location();
    }
#line 446
    if (*tmp___0 != 4) {
      {
#line 447
      syslog(3, "recvfrom: %m");
      }
    }
    {
#line 449
    tmp___1 = __errno_location();
    }
#line 449
    if (*tmp___1 == 88) {
      {
#line 450
      syslog(3, "Warning: Removing a socket from list. Send HUP to renew list.");
      }
#line 451
      return (1);
    }
#line 454
    return (0);
  }
#line 458
  if ((int )sll.sll_pkttype != 1) {
#line 458
    if ((int )sll.sll_pkttype != 2) {
#line 458
      if ((int )sll.sll_pkttype != 0) {
#line 461
        return (0);
      }
    }
  }
#line 463
  if (ifidx) {
#line 463
    if (sll.sll_ifindex != ifidx) {
#line 464
      return (0);
    }
  }
#line 466
  if ((unsigned long )n < sizeof(*a)) {
    {
#line 467
    syslog(3, "truncated arp packet; len=%d", n);
    }
#line 468
    return (0);
  }
  {
#line 472
  tmp___2 = htons((uint16_t )3);
  }
#line 472
  if ((int )a->ar_op != (int )tmp___2) {
#line 473
    return (0);
  }
#line 477
  ptr___0 = tmpbuf;
#line 480
  i = 0;
  {
#line 480
  while (1) {
    while_continue: /* CIL Label */ ;
#line 480
    if (! (i < (int )sll.sll_halen)) {
#line 480
      goto while_break;
    }
#line 481
    if (i) {
      {
#line 482
      sprintf((char */* __restrict  */)ptr___0, (char const   */* __restrict  */)":%02x",
              (int )sll.sll_addr[i]);
#line 483
      ptr___0 ++;
      }
    } else {
      {
#line 485
      sprintf((char */* __restrict  */)ptr___0, (char const   */* __restrict  */)"%02x",
              (int )sll.sll_addr[i]);
      }
    }
#line 486
    ptr___0 += 2;
#line 480
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 488
  ifl = ifl_list;
  {
#line 488
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 488
    if (! ifl) {
#line 488
      goto while_break___0;
    }
#line 489
    if (ifl->index == sll.sll_ifindex) {
#line 490
      goto while_break___0;
    }
#line 488
    ifl = ifl->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 491
  if (ifl) {
    {
#line 492
    strncpy((char */* __restrict  */)(tmpname), (char const   */* __restrict  */)(ifl->name),
            (size_t )16);
#line 493
    tmpname[15] = (char)0;
    }
  } else {
    {
#line 495
    sprintf((char */* __restrict  */)(tmpname), (char const   */* __restrict  */)"if%d",
            sll.sll_ifindex);
    }
  }
#line 497
  if (verbose) {
    {
#line 498
    tmp___5 = htons((uint16_t )2054);
    }
#line 498
    if ((int )sll.sll_protocol == (int )tmp___5) {
#line 498
      tmp___4 = " (ARP-packet)";
    } else {
#line 498
      tmp___4 = "";
    }
    {
#line 498
    syslog(6, "RARP request%s from %s on %s", tmp___4, tmpbuf, tmpname);
    }
  }
#line 507
  if ((int )a->ar_pln != 4) {
    {
#line 508
    syslog(3, "interesting rarp_req plen=%d", (int )a->ar_pln);
    }
#line 509
    return (0);
  }
  {
#line 512
  tmp___7 = htons((uint16_t )2048);
  }
#line 512
  if ((int )a->ar_pro != (int )tmp___7) {
    {
#line 513
    tmp___6 = ntohs(a->ar_pro);
#line 513
    syslog(3, "rarp protocol is not IP %04x", (int )tmp___6);
    }
#line 514
    return (0);
  }
  {
#line 517
  tmp___10 = htons(sll.sll_hatype);
  }
#line 517
  if ((int )tmp___10 != (int )a->ar_hrd) {
    {
#line 519
    if ((int )sll.sll_hatype == 774) {
#line 519
      goto case_774;
    }
#line 523
    goto switch_default;
    case_774: /* CIL Label */ 
    {
#line 520
    tmp___8 = htons((uint16_t )1);
    }
#line 520
    if ((int )a->ar_hrd == (int )tmp___8) {
#line 522
      goto switch_break;
    } else {
      {
#line 520
      tmp___9 = htons((uint16_t )6);
      }
#line 520
      if ((int )a->ar_hrd == (int )tmp___9) {
#line 522
        goto switch_break;
      }
    }
    switch_default: /* CIL Label */ 
    {
#line 524
    syslog(3, "rarp htype mismatch");
    }
#line 525
    return (0);
    switch_break: /* CIL Label */ ;
    }
  }
#line 529
  if ((int )a->ar_hln != (int )sll.sll_halen) {
    {
#line 530
    syslog(3, "rarp hlen mismatch");
    }
#line 531
    return (0);
  }
#line 534
  if ((sizeof(*a) + 8UL) + (unsigned long )(2 * (int )a->ar_hln) > (unsigned long )n) {
    {
#line 535
    syslog(3, "truncated rarp request; len=%d", n);
    }
#line 536
    return (0);
  }
  {
#line 541
  tmp___11 = memcmp((void const   *)(sll.sll_addr), (void const   *)(a + 1), (size_t )sll.sll_halen);
  }
#line 541
  if (tmp___11) {
    {
#line 542
    syslog(3, "this guy set different his lladdrs in arp and header");
    }
#line 543
    return (0);
  }
  {
#line 548
  rmap = rarp_lookup(sll.sll_ifindex, (int )sll.sll_hatype, (int )sll.sll_halen, ((unsigned char *)(a + 1) + (int )sll.sll_halen) + 4);
  }
#line 550
  if ((unsigned long )rmap == (unsigned long )((void *)0)) {
#line 551
    return (0);
  }
  {
#line 558
  a->ar_op = htons((uint16_t )4);
#line 559
  ptr = (unsigned char *)(a + 1);
#line 560
  tmp___12 = put_mylladdr(& ptr, sll.sll_ifindex, rmap->lladdr_len);
  }
#line 560
  if (tmp___12) {
#line 561
    return (0);
  }
  {
#line 562
  tmp___13 = put_myipaddr(& ptr, sll.sll_ifindex, rmap->ipaddr);
  }
#line 562
  if (tmp___13) {
#line 563
    return (0);
  }
  {
#line 565
  ptr += rmap->lladdr_len;
#line 566
  memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)(& rmap->ipaddr),
         (size_t )4);
#line 567
  ptr += 4;
#line 568
  tmp___14 = inet_ntoa(*((struct in_addr *)(& rmap->ipaddr)));
#line 568
  syslog(6, "RARP response to %s %s on %s", tmpbuf, tmp___14, tmpname);
#line 574
  arp_advise(sll.sll_ifindex, rmap->lladdr, rmap->lladdr_len, rmap->ipaddr);
#line 577
  alarm(5U);
#line 578
  sendto(fd, (void const   *)(buf), (size_t )(ptr - buf), 0, (struct sockaddr  const  *)((struct sockaddr *)(& sll)),
         (socklen_t )sizeof(sll));
#line 579
  alarm(0U);
  }
#line 581
  return (0);
}
}
#line 584 "/home/june/repo/benchmarks/collector/temp/rarpd-0.981107/rarpd.c"
void catch_signal(int sig , void (*handler)(int  ) ) 
{ 
  struct sigaction sa ;

  {
  {
#line 588
  memset((void *)(& sa), 0, sizeof(sa));
#line 589
  sa.__sigaction_handler.sa_handler = handler;
#line 591
  sa.sa_flags = 536870912;
#line 593
  sigaction(sig, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 594
  return;
}
}
#line 596 "/home/june/repo/benchmarks/collector/temp/rarpd-0.981107/rarpd.c"
void sig_alarm(int signo ) 
{ 


  {
#line 598
  return;
}
}
#line 600 "/home/june/repo/benchmarks/collector/temp/rarpd-0.981107/rarpd.c"
void sig_hup(int signo ) 
{ 


  {
#line 602
  do_reload = 1;
#line 603
  return;
}
}
#line 605 "/home/june/repo/benchmarks/collector/temp/rarpd-0.981107/rarpd.c"
int main(int argc , char **argv ) 
{ 
  struct pollfd pset[2] ;
  int psize ;
  int opt ;
  struct ifreq ifr ;
  int tmp ;
  struct sockaddr_ll sll ;
  int tmp___0 ;
  struct sockaddr_ll sll___0 ;
  int tmp___1 ;
  int fd ;
  pid_t pid ;
  __pid_t tmp___2 ;
  int tmp___3 ;
  int i ;
  int *tmp___4 ;
  int tmp___5 ;

  {
#line 612
  opterr = 0;
  {
#line 613
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 613
    opt = getopt(argc, (char * const  *)argv, "aAb:dvoe");
    }
#line 613
    if (! (opt != -1)) {
#line 613
      goto while_break;
    }
    {
#line 615
    if (opt == 97) {
#line 615
      goto case_97;
    }
#line 619
    if (opt == 65) {
#line 619
      goto case_65;
    }
#line 623
    if (opt == 100) {
#line 623
      goto case_100;
    }
#line 628
    if (opt == 118) {
#line 628
      goto case_118;
    }
#line 632
    if (opt == 111) {
#line 632
      goto case_111;
    }
#line 636
    if (opt == 101) {
#line 636
      goto case_101;
    }
#line 640
    if (opt == 98) {
#line 640
      goto case_98;
    }
#line 644
    goto switch_default;
    case_97: /* CIL Label */ 
#line 616
    all_ifaces ++;
#line 617
    goto switch_break;
    case_65: /* CIL Label */ 
#line 620
    listen_arp ++;
#line 621
    goto switch_break;
    case_100: /* CIL Label */ 
#line 624
    debug ++;
#line 625
    verbose ++;
#line 626
    goto switch_break;
    case_118: /* CIL Label */ 
#line 629
    verbose ++;
#line 630
    goto switch_break;
    case_111: /* CIL Label */ 
#line 633
    allow_offlink ++;
#line 634
    goto switch_break;
    case_101: /* CIL Label */ 
#line 637
    only_ethers ++;
#line 638
    goto switch_break;
    case_98: /* CIL Label */ 
#line 641
    tftp_dir = (char const   *)optarg;
#line 642
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 645
    usage();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 648
  if (argc > optind) {
#line 649
    if (argc > optind + 1) {
      {
#line 650
      usage();
      }
    }
#line 651
    ifname = *(argv + optind);
  }
  {
#line 654
  psize = 1;
#line 655
  pset[0].fd = socket(17, 2, 0);
  }
#line 657
  if (ifname) {
    {
#line 659
    memset((void *)(& ifr), 0, sizeof(ifr));
#line 660
    strncpy((char */* __restrict  */)(ifr.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)ifname,
            (size_t )15);
#line 661
    tmp = ioctl(pset[0].fd, 35123UL, & ifr);
    }
#line 661
    if (tmp) {
      {
#line 662
      perror("ioctl(SIOCGIFINDEX)");
#line 663
      usage();
      }
    }
#line 665
    ifidx = ifr.ifr_ifru.ifru_ivalue;
  }
#line 668
  pset[1].fd = -1;
#line 669
  if (listen_arp) {
    {
#line 670
    pset[1].fd = socket(17, 2, 0);
    }
#line 671
    if (pset[1].fd >= 0) {
      {
#line 672
      load_arp_bpflet(pset[1].fd);
#line 673
      psize ++;
      }
    }
  }
#line 677
  if (pset[1].fd >= 0) {
    {
#line 679
    memset((void *)(& sll), 0, sizeof(sll));
#line 680
    sll.sll_family = (unsigned short)17;
#line 681
    sll.sll_protocol = htons((uint16_t )2054);
    }
#line 682
    if (all_ifaces) {
#line 682
      sll.sll_ifindex = 0;
    } else {
#line 682
      sll.sll_ifindex = ifidx;
    }
    {
#line 683
    tmp___0 = bind(pset[1].fd, (struct sockaddr  const  *)((struct sockaddr *)(& sll)),
                   (socklen_t )sizeof(sll));
    }
#line 683
    if (tmp___0 < 0) {
      {
#line 684
      close(pset[1].fd);
#line 685
      pset[1].fd = -1;
#line 686
      psize --;
      }
    }
  }
#line 689
  if (pset[0].fd >= 0) {
    {
#line 691
    memset((void *)(& sll___0), 0, sizeof(sll___0));
#line 692
    sll___0.sll_family = (unsigned short)17;
#line 693
    sll___0.sll_protocol = htons((uint16_t )32821);
    }
#line 694
    if (all_ifaces) {
#line 694
      sll___0.sll_ifindex = 0;
    } else {
#line 694
      sll___0.sll_ifindex = ifidx;
    }
    {
#line 695
    tmp___1 = bind(pset[0].fd, (struct sockaddr  const  *)((struct sockaddr *)(& sll___0)),
                   (socklen_t )sizeof(sll___0));
    }
#line 695
    if (tmp___1 < 0) {
      {
#line 696
      close(pset[0].fd);
#line 697
      pset[0].fd = -1;
      }
    }
  }
#line 700
  if (pset[0].fd < 0) {
#line 701
    pset[0] = pset[1];
#line 702
    psize --;
  }
#line 704
  if (psize == 0) {
    {
#line 705
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"failed to bind any socket. Aborting.\n");
#line 706
    exit(1);
    }
  }
#line 709
  if (! debug) {
    {
#line 711
    tmp___2 = fork();
#line 711
    pid = tmp___2;
    }
#line 713
    if (pid > 0) {
      {
#line 714
      exit(0);
      }
    } else
#line 715
    if (pid == -1) {
      {
#line 716
      perror("rarpd: fork");
#line 717
      exit(1);
      }
    }
    {
#line 720
    chdir("/");
#line 721
    fd = open("/dev/null", 2);
    }
#line 722
    if (fd >= 0) {
      {
#line 723
      dup2(fd, 0);
#line 724
      dup2(fd, 1);
#line 725
      dup2(fd, 2);
      }
#line 726
      if (fd > 2) {
        {
#line 727
        close(fd);
        }
      }
    }
    {
#line 729
    setsid();
    }
  }
#line 733
  if (debug) {
#line 733
    tmp___3 = 35;
  } else {
#line 733
    tmp___3 = 3;
  }
  {
#line 733
  openlog("rarpd", tmp___3, 3 << 3);
#line 741
  catch_signal(14, & sig_alarm);
#line 742
  catch_signal(1, & sig_hup);
  }
  {
#line 744
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 747
    if (do_reload) {
      {
#line 748
      configure();
#line 749
      do_reload = 0;
      }
    }
    {
#line 753
    pset[0].events = (short)27;
#line 754
    pset[0].revents = (short)0;
#line 755
    pset[1].events = (short)27;
#line 756
    pset[1].revents = (short)0;
#line 758
    i = poll(pset, (nfds_t )psize, -1);
    }
#line 759
    if (i <= 0) {
      {
#line 760
      tmp___4 = __errno_location();
      }
#line 760
      if (*tmp___4 != 4) {
#line 760
        if (i < 0) {
          {
#line 761
          syslog(3, "poll returned some crap: %m\n");
#line 762
          sleep(10U);
          }
        }
      }
#line 764
      goto __Cont;
    }
#line 766
    i = 0;
    {
#line 766
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 766
      if (! (i < psize)) {
#line 766
        goto while_break___1;
      }
#line 767
      if ((int )pset[i].revents & 27) {
#line 767
        if (pset[i].fd >= 0) {
          {
#line 768
          tmp___5 = serve_it(pset[i].fd);
          }
#line 768
          if (tmp___5 == 1) {
#line 769
            pset[i].fd = -1;
          }
        }
      }
#line 766
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
