/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 86 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off_t off_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 42 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/util.h"
enum __anonenum_round_t_30 {
    UP = 0,
    DOWN = 1
} ;
#line 42 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/util.h"
typedef enum __anonenum_round_t_30 round_t;
#line 25 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/hwrand.h"
typedef _Bool (*hwrand_t)(unsigned char * , int  );
#line 73 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/hwrand.c"
struct cpuid {
   unsigned int eax ;
   unsigned int ecx ;
   unsigned int edx ;
   unsigned int ebx ;
};
#line 100 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/hwrand.c"
typedef unsigned long long rdrand_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/resource.h"
enum __rlimit_resource {
    RLIMIT_CPU = 0,
    RLIMIT_FSIZE = 1,
    RLIMIT_DATA = 2,
    RLIMIT_STACK = 3,
    RLIMIT_CORE = 4,
    __RLIMIT_RSS = 5,
    RLIMIT_NOFILE = 7,
    __RLIMIT_OFILE = 7,
    RLIMIT_AS = 9,
    __RLIMIT_NPROC = 6,
    __RLIMIT_MEMLOCK = 8,
    __RLIMIT_LOCKS = 10,
    __RLIMIT_SIGPENDING = 11,
    __RLIMIT_MSGQUEUE = 12,
    __RLIMIT_NICE = 13,
    __RLIMIT_RTPRIO = 14,
    __RLIMIT_RTTIME = 15,
    __RLIMIT_NLIMITS = 16,
    __RLIM_NLIMITS = 16
} ;
#line 131 "/usr/include/x86_64-linux-gnu/bits/resource.h"
typedef __rlim_t rlim_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 38 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef enum __rlimit_resource __rlimit_resource_t;
#line 33 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/util.h"
enum __anonenum_filetype_t_69 {
    FILE_NOEXIST = 0,
    FILE_REGULAR = 1,
    FILE_CHAR = 2,
    FILE_BLOCK = 3,
    FILE_LINK = 4,
    FILE_OTHER = 5
} ;
#line 33 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/util.h"
typedef enum __anonenum_filetype_t_69 filetype_t;
#line 27 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/progress.h"
struct prog_struct;
#line 27 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/progress.h"
typedef struct prog_struct *prog_t;
#line 29 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/pattern.h"
enum __anonenum_ptype_t_71 {
    PAT_NORMAL = 0,
    PAT_RANDOM = 1,
    PAT_VERIFY = 2
} ;
#line 29 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/pattern.h"
typedef enum __anonenum_ptype_t_71 ptype_t;
#line 34 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/pattern.h"
struct __anonstruct_pattern_t_72 {
   ptype_t ptype ;
   int len ;
   int pat[16] ;
};
#line 34 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/pattern.h"
typedef struct __anonstruct_pattern_t_72 pattern_t;
#line 40 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/pattern.h"
struct __anonstruct_sequence_t_73 {
   char *key ;
   char *desc ;
   int len ;
   pattern_t pat[35] ;
};
#line 40 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/pattern.h"
typedef struct __anonstruct_sequence_t_73 sequence_t;
#line 31 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/aes.h"
struct __anonstruct_aes_context_1 {
   unsigned long erk[64] ;
   unsigned long drk[64] ;
   int nr ;
};
#line 31 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/aes.h"
typedef struct __anonstruct_aes_context_1 aes_context;
#line 42 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/progress.c"
struct prog_struct {
   int magic ;
   int bars ;
   int maxbars ;
   int batch ;
   char bar ;
};
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 48 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
struct utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char domainname[65] ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 63 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 69 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 48 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/fillfile.c"
struct memstruct {
   void (*refill)(unsigned char *mem , int memsize ) ;
   unsigned char *buf ;
   int size ;
   pthread_t thd ;
   int err ;
};
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 353
extern int close(int __fd ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/util.h"
int read_all(int fd___0 , unsigned char *buf , int count ) ;
#line 45
int write_all(int fd___0 , unsigned char const   *buf , int count ) ;
#line 47
off_t blkalign(off_t offset , int blocksize , round_t rtype ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/sig.h"
int writesig(char *path ) ;
#line 27
int checksig(char *path , _Bool *status ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/sig.c"
static int sigbufsize(char *path , off_t *blocksize ) 
{ 
  struct stat sb ;
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 55
  tmp = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& sb));
  }
#line 55
  if (tmp < 0) {
#line 56
    goto error;
  }
  {
#line 57
  tmp___0 = strlen("\001\002\003SCRUBBED!");
#line 57
  *blocksize = blkalign((off_t )tmp___0, (int )sb.st_blksize, (round_t )0);
  }
#line 58
  return (0);
  error: 
#line 60
  return (-1);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/sig.c"
int writesig(char *path ) 
{ 
  unsigned char *buf ;
  int fd___0 ;
  int n ;
  off_t blocksize ;
  int tmp ;
  void *tmp___0 ;
  __off_t tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 68
  buf = (unsigned char *)((void *)0);
#line 69
  fd___0 = -1;
#line 72
  tmp = sigbufsize(path, & blocksize);
  }
#line 72
  if (tmp < 0) {
#line 73
    goto error;
  }
  {
#line 74
  tmp___0 = malloc((size_t )blocksize);
#line 74
  buf = (unsigned char *)tmp___0;
  }
#line 74
  if (! buf) {
#line 75
    goto nomem;
  }
  {
#line 76
  fd___0 = open((char const   *)path, 2);
  }
#line 76
  if (fd___0 < 0) {
#line 77
    goto error;
  }
  {
#line 78
  n = read_all(fd___0, buf, (int )blocksize);
  }
#line 78
  if (n < 0) {
#line 79
    goto error;
  }
  {
#line 80
  memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)"\001\002\003SCRUBBED!",
         sizeof("\001\002\003SCRUBBED!"));
#line 81
  tmp___1 = lseek(fd___0, (__off_t )0, 0);
  }
#line 81
  if (tmp___1 < 0L) {
#line 82
    goto error;
  }
  {
#line 83
  n = write_all(fd___0, (unsigned char const   *)buf, (int )blocksize);
  }
#line 83
  if (n < 0) {
#line 84
    goto error;
  }
#line 85
  if (n == 0) {
    {
#line 86
    tmp___2 = __errno_location();
#line 86
    *tmp___2 = 22;
    }
#line 87
    goto error;
  }
  {
#line 89
  tmp___3 = close(fd___0);
  }
#line 89
  if (tmp___3 < 0) {
#line 90
    goto error;
  }
  {
#line 91
  free((void *)buf);
  }
#line 92
  return (0);
  nomem: 
  {
#line 94
  tmp___4 = __errno_location();
#line 94
  *tmp___4 = 12;
  }
  error: 
#line 96
  if (buf) {
    {
#line 97
    free((void *)buf);
    }
  }
#line 98
  if (fd___0 != -1) {
    {
#line 99
    close(fd___0);
    }
  }
#line 100
  return (-1);
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/sig.c"
int checksig(char *path , _Bool *status ) 
{ 
  unsigned char *buf ;
  int fd___0 ;
  int n ;
  _Bool result ;
  off_t blocksize ;
  int tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;

  {
  {
#line 106
  buf = (unsigned char *)((void *)0);
#line 107
  fd___0 = -1;
#line 108
  result = (_Bool)0;
#line 111
  tmp = sigbufsize(path, & blocksize);
  }
#line 111
  if (tmp < 0) {
#line 112
    goto error;
  }
  {
#line 113
  tmp___0 = malloc((size_t )blocksize);
#line 113
  buf = (unsigned char *)tmp___0;
  }
#line 113
  if (! buf) {
#line 114
    goto nomem;
  }
  {
#line 115
  fd___0 = open((char const   *)path, 0);
  }
#line 115
  if (fd___0 < 0) {
#line 116
    goto error;
  }
  {
#line 117
  n = read_all(fd___0, buf, (int )blocksize);
  }
#line 117
  if (n < 0) {
#line 118
    goto error;
  }
  {
#line 119
  tmp___3 = strlen("\001\002\003SCRUBBED!");
  }
#line 119
  if ((size_t )n >= tmp___3) {
    {
#line 120
    tmp___1 = strlen("\001\002\003SCRUBBED!");
#line 120
    tmp___2 = memcmp((void const   *)buf, (void const   *)"\001\002\003SCRUBBED!",
                     tmp___1);
    }
#line 120
    if (tmp___2 == 0) {
#line 121
      result = (_Bool)1;
    }
  }
  {
#line 123
  tmp___4 = close(fd___0);
  }
#line 123
  if (tmp___4 < 0) {
#line 124
    goto error;
  }
  {
#line 125
  free((void *)buf);
#line 126
  *status = result;
  }
#line 127
  return (0);
  nomem: 
  {
#line 129
  tmp___5 = __errno_location();
#line 129
  *tmp___5 = 12;
  }
  error: 
#line 131
  if (buf) {
    {
#line 132
    free((void *)buf);
    }
  }
#line 133
  if (fd___0 != -1) {
    {
#line 134
    close(fd___0);
    }
  }
#line 135
  return (-1);
}
}
#line 27 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/hwrand.h"
hwrand_t init_hwrand(void) ;
#line 66 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/hwrand.c"
static _Bool have_cpuid(void) 
{ 


  {
#line 68
  return ((_Bool)1);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/hwrand.c"
static void cpuid(unsigned int leaf , unsigned int subleaf , struct cpuid *out ) 
{ 


  {
#line 88
  __asm__  volatile   ("cpuid": "=b" (out->ebx), "=a" (out->eax), "=c" (out->ecx),
                       "=d" (out->edx): "a" (leaf), "c" (subleaf));
#line 95
  return;
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/hwrand.c"
__inline static _Bool rdrand(rdrand_t *ptr ) 
{ 
  unsigned int ctr___0 ;

  {
#line 108
  ctr___0 = 10U;
#line 110
  __asm__  volatile   ("1:\n"
                       " "
                       ".byte 0x48,0x0f,0xc7,0xf0"
                       "\n"
                       " jc 2f\n"
                       " dec %1\n"
                       " jnz 1b\n"
                       "2:": "=a" (*ptr), "+r" (ctr___0));
#line 118
  return ((_Bool )(ctr___0 > 0U));
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/hwrand.c"
static _Bool hwrand_rdrand(unsigned char *buf , int bufsize ) 
{ 
  rdrand_t tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;
#line 125
    if (! ((unsigned long )bufsize >= sizeof(rdrand_t ))) {
#line 125
      goto while_break;
    }
    {
#line 126
    tmp___0 = rdrand((rdrand_t *)buf);
    }
#line 126
    if (! tmp___0) {
#line 127
      return ((_Bool)0);
    }
#line 129
    buf += sizeof(rdrand_t );
#line 130
    bufsize = (int )((unsigned long )bufsize - sizeof(rdrand_t ));
  }
  while_break: /* CIL Label */ ;
  }
#line 133
  if (! bufsize) {
#line 134
    return ((_Bool)1);
  }
  {
#line 136
  tmp___1 = rdrand(& tmp);
  }
#line 136
  if (! tmp___1) {
#line 137
    return ((_Bool)0);
  }
#line 140
  if (bufsize & 4) {
#line 141
    *((unsigned int *)buf) = (unsigned int )tmp;
#line 142
    buf += 4;
#line 143
    tmp >>= 32;
  }
#line 147
  if (bufsize & 2) {
#line 148
    *((unsigned short *)buf) = (unsigned short )tmp;
#line 149
    buf += 2;
#line 150
    tmp >>= 16;
  }
#line 153
  if (bufsize & 1) {
#line 154
    *buf = (unsigned char )tmp;
  }
#line 156
  return ((_Bool)1);
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/hwrand.c"
hwrand_t init_hwrand(void) 
{ 
  struct cpuid cpu ;
  _Bool tmp ;

  {
  {
#line 163
  tmp = have_cpuid();
  }
#line 163
  if (! tmp) {
#line 164
    return ((hwrand_t )((void *)0));
  }
  {
#line 166
  cpuid(0U, 0U, & cpu);
  }
#line 167
  if (cpu.eax < 1U) {
#line 168
    return ((hwrand_t )((void *)0));
  }
  {
#line 170
  cpuid(1U, 0U, & cpu);
  }
#line 171
  if (! (cpu.ecx & (unsigned int )(1 << 30))) {
#line 172
    return ((hwrand_t )((void *)0));
  }
#line 174
  return (& hwrand_rdrand);
}
}
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 173
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 321 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 180
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 34 "/usr/include/libgen.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) __xpg_basename)(char *__path ) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 835
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) rmdir)(char const   *__path ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getrlimit)(__rlimit_resource_t __resource ,
                                                                                struct rlimit *__rlimits ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setrlimit)(__rlimit_resource_t __resource ,
                                                                                struct rlimit  const  *__rlimits ) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/util.h"
filetype_t filetype(char *path ) ;
#line 48
void *alloc_buffer(int bufsize ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/genrand.h"
void disable_hwrand(void) ;
#line 28
int initrand(void) ;
#line 29
int churnrand(void) ;
#line 30
void genrand(unsigned char *buf , int buflen ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/fillfile.h"
off_t fillfile(char *path , off_t filesize , unsigned char *mem , int memsize , void (*progress)(void *arg ,
                                                                                                 double completed ) ,
               void *arg , void (*refill)(unsigned char *mem , int memsize ) , _Bool sparse ,
               _Bool creat___0 ) ;
#line 33
off_t checkfile(char *path , off_t filesize , unsigned char *mem , int memsize , void (*progress)(void *arg ,
                                                                                                  double completed ) ,
                void *arg , _Bool sparse ) ;
#line 35
void disable_threads(void) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/filldentry.h"
int filldentry(char *path , int pat ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/getsize.h"
int getsize(char *path , off_t *sizep ) ;
#line 28
off_t str2size(char *str___0 ) ;
#line 29
int str2int(char *str___0 ) ;
#line 30
void size2str(char *str___0 , int len , off_t size ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/progress.h"
void progress_create(prog_t *ctx___0 , int width ) ;
#line 30
void progress_destroy(prog_t ctx___0 ) ;
#line 31
void progress_update(prog_t ctx___0 , double complete ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/pattern.h"
sequence_t const   *seq_lookup(char *key ) ;
#line 48
void seq_list(void) ;
#line 49
char *pat2str(pattern_t p ) ;
#line 50
void memset_pat(void *s , pattern_t p , size_t n ) ;
#line 56
sequence_t *seq_create(char *key , char *desc , char *s ) ;
#line 57
void seq_destroy(sequence_t *sp ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/scrub.c"
static _Bool scrub(char *path , off_t size , sequence_t const   *seq , int bufsize ,
                   _Bool Sopt , _Bool sparse , _Bool enospc ) ;
#line 62
static void scrub_free(char *dirpath , off_t size , sequence_t const   *seq , int bufsize ,
                       _Bool Sopt ) ;
#line 64
static void scrub_dirent(char *path , char *newpath ) ;
#line 65
static void scrub_file(char *path , off_t size , sequence_t const   *seq , int bufsize ,
                       _Bool Sopt , _Bool sparse ) ;
#line 71
static void scrub_disk(char *path , off_t size , sequence_t const   *seq , int bufsize ,
                       _Bool Sopt , _Bool sparse ) ;
#line 77 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/scrub.c"
static struct option longopts[15]  = 
#line 77
  {      {"pattern", 1, (int *)0, 'p'}, 
        {"dirent", 1, (int *)0, 'D'}, 
        {"freespace", 0, (int *)0, 'X'}, 
        {"blocksize", 1, (int *)0, 'b'}, 
        {"device-size", 1, (int *)0, 's'}, 
        {"force", 0, (int *)0, 'f'}, 
        {"no-signature", 0, (int *)0, 'S'}, 
        {"remove", 0, (int *)0, 'r'}, 
        {"version", 0, (int *)0, 'v'}, 
        {"test-sparse", 0, (int *)0, 'T'}, 
        {"no-link", 0, (int *)0, 'L'}, 
        {"no-hwrand", 0, (int *)0, 'R'}, 
        {"no-threads", 0, (int *)0, 't'}, 
        {"help", 0, (int *)0, 'h'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 98 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/scrub.c"
char *prog  ;
#line 100 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/scrub.c"
static void usage(void) 
{ 


  {
  {
#line 103
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [OPTIONS] file\n  -v, --version           display scrub version and exit\n  -p, --pattern pat       select scrub pattern sequence\n  -b, --blocksize size    set I/O buffer size (default 4m)\n  -s, --device-size size  set device size manually\n  -X, --freespace dir     create dir+files, fill until ENOSPC, then scrub\n  -D, --dirent newname    after scrubbing file, scrub dir entry, rename\n  -f, --force             scrub despite signature from previous scrub\n  -S, --no-signature      do not write scrub signature after scrub\n  -r, --remove            remove file after scrub\n  -L, --no-link           do not scrub link target\n  -R, --no-hwrand         do not use a hardware random number generator\n  -t, --no-threads        do not compute random data in a parallel thread\n  -h, --help              display this help message\n",
          prog);
#line 120
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Available patterns are:\n");
#line 121
  seq_list();
#line 122
  exit(1);
  }
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/scrub.c"
int main(int argc , char **argv ) 
{ 
  sequence_t const   *seq ;
  sequence_t *custom_seq___0 ;
  _Bool Xopt ;
  int bopt ;
  off_t sopt ;
  char *Dopt ;
  char *filename ;
  _Bool fopt ;
  _Bool Sopt ;
  _Bool ropt ;
  _Bool Topt ;
  _Bool Lopt ;
  _Bool Ropt ;
  _Bool topt ;
  int c ;
  _Bool havesig ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  filetype_t tmp___3 ;
  filetype_t tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;

  {
#line 128
  seq = (sequence_t const   *)((void *)0);
#line 129
  custom_seq___0 = (sequence_t *)((void *)0);
#line 130
  Xopt = (_Bool)0;
#line 131
  bopt = 4194304;
#line 132
  sopt = (off_t )0;
#line 133
  Dopt = (char *)((void *)0);
#line 134
  filename = (char *)((void *)0);
#line 135
  fopt = (_Bool)0;
#line 136
  Sopt = (_Bool)0;
#line 137
  ropt = (_Bool)0;
#line 138
  Topt = (_Bool)0;
#line 139
  Lopt = (_Bool)0;
#line 140
  Ropt = (_Bool)0;
#line 141
  topt = (_Bool)0;
#line 147
  if (! (sizeof(off_t ) == 8UL)) {
    {
#line 147
    __assert_fail("sizeof(off_t) == 8", "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/scrub.c",
                  147U, "main");
    }
  }
  {
#line 151
  prog = __xpg_basename(*(argv + 0));
  }
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 152
    c = getopt_long(argc, (char * const  *)argv, "p:D:Xb:s:fSrvTLRth", (struct option  const  *)(longopts),
                    (int *)((void *)0));
    }
#line 152
    if (! (c != -1)) {
#line 152
      goto while_break;
    }
    {
#line 154
    if (c == 118) {
#line 154
      goto case_118;
    }
#line 157
    if (c == 112) {
#line 157
      goto case_112;
    }
#line 178
    if (c == 88) {
#line 178
      goto case_88;
    }
#line 181
    if (c == 68) {
#line 181
      goto case_68;
    }
#line 184
    if (c == 114) {
#line 184
      goto case_114;
    }
#line 187
    if (c == 98) {
#line 187
      goto case_98;
    }
#line 194
    if (c == 115) {
#line 194
      goto case_115;
    }
#line 201
    if (c == 102) {
#line 201
      goto case_102;
    }
#line 204
    if (c == 83) {
#line 204
      goto case_83;
    }
#line 207
    if (c == 84) {
#line 207
      goto case_84;
    }
#line 210
    if (c == 76) {
#line 210
      goto case_76;
    }
#line 213
    if (c == 82) {
#line 213
      goto case_82;
    }
#line 216
    if (c == 116) {
#line 216
      goto case_116;
    }
#line 220
    goto switch_default;
    case_118: /* CIL Label */ 
    {
#line 155
    printf((char const   */* __restrict  */)"scrub version %s\n", "2.5.2");
#line 156
    exit(0);
    }
    case_112: /* CIL Label */ 
#line 158
    if ((unsigned long )seq != (unsigned long )((void *)0)) {
      {
#line 159
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: only one pattern can be selected\n",
              prog);
#line 160
      exit(1);
      }
    }
    {
#line 162
    tmp___1 = strncmp((char const   *)optarg, "custom=", (size_t )7);
    }
#line 162
    if (tmp___1) {
      _L: /* CIL Label */ 
      {
#line 171
      seq = seq_lookup(optarg);
      }
#line 172
      if (! seq) {
        {
#line 173
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: no such pattern sequence\n",
                prog);
#line 174
        exit(1);
        }
      }
    } else {
      {
#line 162
      tmp___2 = strlen((char const   *)optarg);
      }
#line 162
      if (tmp___2 > 7UL) {
        {
#line 163
        custom_seq___0 = seq_create((char *)"custom", (char *)"Custom single-pass",
                                    optarg + 7);
        }
#line 163
        if (! custom_seq___0) {
          {
#line 165
          tmp = __errno_location();
#line 165
          tmp___0 = strerror(*tmp);
#line 165
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: custom sequence: %s\n",
                  prog, tmp___0);
#line 167
          exit(1);
          }
        }
#line 169
        seq = (sequence_t const   *)custom_seq___0;
      } else {
#line 162
        goto _L;
      }
    }
#line 177
    goto switch_break;
    case_88: /* CIL Label */ 
#line 179
    Xopt = (_Bool)1;
#line 180
    goto switch_break;
    case_68: /* CIL Label */ 
#line 182
    Dopt = optarg;
#line 183
    goto switch_break;
    case_114: /* CIL Label */ 
#line 185
    ropt = (_Bool)1;
#line 186
    goto switch_break;
    case_98: /* CIL Label */ 
    {
#line 188
    bopt = str2int(optarg);
    }
#line 189
    if (bopt == 0) {
      {
#line 190
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error parsing blocksize string\n",
              prog);
#line 191
      exit(1);
      }
    }
#line 193
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 195
    sopt = str2size(optarg);
    }
#line 196
    if (sopt == 0L) {
      {
#line 197
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error parsing size string\n",
              prog);
#line 198
      exit(1);
      }
    }
#line 200
    goto switch_break;
    case_102: /* CIL Label */ 
#line 202
    fopt = (_Bool)1;
#line 203
    goto switch_break;
    case_83: /* CIL Label */ 
#line 205
    Sopt = (_Bool)1;
#line 206
    goto switch_break;
    case_84: /* CIL Label */ 
#line 208
    Topt = (_Bool)1;
#line 209
    goto switch_break;
    case_76: /* CIL Label */ 
#line 211
    Lopt = (_Bool)1;
#line 212
    goto switch_break;
    case_82: /* CIL Label */ 
#line 214
    Ropt = (_Bool)1;
#line 215
    goto switch_break;
    case_116: /* CIL Label */ 
#line 217
    topt = (_Bool)1;
#line 218
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 221
    usage();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  if (argc - optind != 1) {
    {
#line 225
    usage();
    }
  }
#line 226
  filename = *(argv + optind);
#line 228
  if (! seq) {
    {
#line 229
    seq = seq_lookup((char *)"nnsa");
    }
  }
#line 230
  if (! ((unsigned long )seq != (unsigned long )((void *)0))) {
    {
#line 230
    __assert_fail("seq != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/scrub.c",
                  230U, "main");
    }
  }
  {
#line 231
  printf((char const   */* __restrict  */)"%s: using %s patterns\n", prog, seq->desc);
  }
#line 233
  if (Ropt) {
    {
#line 234
    disable_hwrand();
    }
  }
#line 235
  if (topt) {
    {
#line 236
    disable_threads();
    }
  }
#line 240
  if (Xopt) {
    {
#line 241
    tmp___3 = filetype(filename);
    }
#line 241
    if ((unsigned int )tmp___3 != 0U) {
      {
#line 242
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: -X directory already exists\n",
              prog);
#line 243
      exit(1);
      }
    }
#line 245
    if (Dopt) {
      {
#line 246
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: -D and -X cannot be used together\n",
              prog);
#line 247
      exit(1);
      }
    }
    {
#line 249
    scrub_free(filename, sopt, seq, bopt, Sopt);
    }
#line 250
    goto done;
  }
  {
#line 253
  tmp___4 = filetype(filename);
  }
  {
#line 254
  if ((unsigned int )tmp___4 == 0U) {
#line 254
    goto case_0;
  }
#line 257
  if ((unsigned int )tmp___4 == 5U) {
#line 257
    goto case_5;
  }
#line 261
  if ((unsigned int )tmp___4 == 2U) {
#line 261
    goto case_2;
  }
#line 261
  if ((unsigned int )tmp___4 == 3U) {
#line 261
    goto case_2;
  }
#line 286
  if ((unsigned int )tmp___4 == 4U) {
#line 286
    goto case_4;
  }
#line 298
  if ((unsigned int )tmp___4 == 1U) {
#line 298
    goto case_1;
  }
#line 253
  goto switch_break___0;
  case_0: /* CIL Label */ 
  {
#line 255
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s does not exist\n",
          prog, filename);
#line 256
  exit(1);
  }
  case_5: /* CIL Label */ 
  {
#line 258
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s is wrong type of file\n",
          prog, filename);
#line 259
  exit(1);
  }
  case_2: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 262
  if (Dopt) {
    {
#line 263
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: cannot use -D with special file\n",
            prog);
#line 264
    exit(1);
    }
  }
#line 266
  if (ropt) {
    {
#line 267
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: cannot use -r with special file\n",
            prog);
#line 268
    exit(1);
    }
  }
  {
#line 270
  tmp___5 = access((char const   *)filename, 6);
  }
#line 270
  if (tmp___5 < 0) {
    {
#line 271
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: no rw access to %s\n",
            prog, filename);
#line 272
    exit(1);
    }
  }
  {
#line 274
  tmp___8 = checksig(filename, & havesig);
  }
#line 274
  if (tmp___8 < 0) {
    {
#line 275
    tmp___6 = __errno_location();
#line 275
    tmp___7 = strerror(*tmp___6);
#line 275
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s\n",
            prog, filename, tmp___7);
#line 277
    exit(1);
    }
  }
#line 279
  if (havesig) {
#line 279
    if (! fopt) {
      {
#line 280
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s already scrubbed? (-f to force)\n",
              prog, filename);
#line 282
      exit(1);
      }
    }
  }
  {
#line 284
  scrub_disk(filename, sopt, seq, bopt, Sopt, Topt);
  }
#line 285
  goto switch_break___0;
  case_4: /* CIL Label */ 
#line 287
  if (Lopt) {
#line 288
    if (ropt) {
      {
#line 289
      printf((char const   */* __restrict  */)"%s: unlinking %s\n", prog, filename);
#line 290
      tmp___11 = unlink((char const   *)filename);
      }
#line 290
      if (tmp___11 != 0) {
        {
#line 291
        tmp___9 = __errno_location();
#line 291
        tmp___10 = strerror(*tmp___9);
#line 291
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unlink %s: %s\n",
                prog, filename, tmp___10);
#line 293
        exit(1);
        }
      }
    }
#line 296
    goto switch_break___0;
  }
  case_1: /* CIL Label */ 
  {
#line 299
  tmp___12 = access((char const   *)filename, 6);
  }
#line 299
  if (tmp___12 < 0) {
    {
#line 300
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: no rw access to %s\n",
            prog, filename);
#line 301
    exit(1);
    }
  }
  {
#line 303
  tmp___15 = checksig(filename, & havesig);
  }
#line 303
  if (tmp___15 < 0) {
    {
#line 304
    tmp___13 = __errno_location();
#line 304
    tmp___14 = strerror(*tmp___13);
#line 304
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s\n",
            prog, filename, tmp___14);
#line 306
    exit(1);
    }
  }
#line 308
  if (havesig) {
#line 308
    if (! fopt) {
      {
#line 309
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s already scrubbed? (-f to force)\n",
              prog, filename);
#line 311
      exit(1);
      }
    }
  }
#line 313
  if (Dopt) {
#line 313
    if ((int )*Dopt != 47) {
#line 313
      if ((int )*filename == 47) {
        {
#line 314
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s should be a full path like %s\n",
                prog, Dopt, filename);
#line 316
        exit(1);
        }
      }
    }
  }
  {
#line 318
  scrub_file(filename, sopt, seq, bopt, Sopt, Topt);
  }
#line 322
  if (Dopt) {
    {
#line 323
    scrub_dirent(filename, Dopt);
#line 324
    filename = Dopt;
    }
  }
#line 326
  if (ropt) {
    {
#line 327
    printf((char const   */* __restrict  */)"%s: unlinking %s\n", prog, filename);
#line 328
    tmp___18 = unlink((char const   *)filename);
    }
#line 328
    if (tmp___18 != 0) {
      {
#line 329
      tmp___16 = __errno_location();
#line 329
      tmp___17 = strerror(*tmp___16);
#line 329
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unlink %s: %s\n",
              prog, filename, tmp___17);
#line 331
      exit(1);
      }
    }
  }
#line 334
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  done: 
#line 337
  if (custom_seq___0) {
    {
#line 338
    seq_destroy(custom_seq___0);
    }
  }
  {
#line 339
  exit(0);
  }
}
}
#line 347 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/scrub.c"
static _Bool scrub(char *path , off_t size , sequence_t const   *seq , int bufsize ,
                   _Bool Sopt , _Bool sparse , _Bool enospc ) 
{ 
  unsigned char *buf ;
  int i ;
  prog_t p ;
  char sizestr[80] ;
  _Bool isfull ;
  off_t written ;
  off_t checked ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;

  {
  {
#line 355
  isfull = (_Bool)0;
#line 358
  tmp = alloc_buffer(bufsize);
#line 358
  buf = (unsigned char *)tmp;
  }
#line 358
  if (! buf) {
    {
#line 359
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: out of memory\n",
            prog);
#line 360
    exit(1);
    }
  }
  {
#line 363
  size2str(sizestr, (int )sizeof(sizestr), size);
#line 364
  printf((char const   */* __restrict  */)"%s: scrubbing %s %s\n", prog, path, sizestr);
#line 366
  tmp___2 = initrand();
  }
#line 366
  if (tmp___2 < 0) {
    {
#line 367
    tmp___0 = __errno_location();
#line 367
    tmp___1 = strerror(*tmp___0);
#line 367
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: initrand: %s\n",
            prog, tmp___1);
#line 368
    exit(1);
    }
  }
#line 370
  i = 0;
  {
#line 370
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    if (! (i < (int )seq->len)) {
#line 370
      goto while_break;
    }
#line 371
    if (i > 0) {
#line 372
      enospc = (_Bool)0;
    }
    {
#line 374
    if ((unsigned int const   )seq->pat[i].ptype == 1U) {
#line 374
      goto case_1;
    }
#line 392
    if ((unsigned int const   )seq->pat[i].ptype == 0U) {
#line 392
      goto case_0;
    }
#line 406
    if ((unsigned int const   )seq->pat[i].ptype == 2U) {
#line 406
      goto case_2;
    }
#line 373
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 375
    printf((char const   */* __restrict  */)"%s: %-8s", prog, "random");
#line 376
    progress_create(& p, 50);
#line 377
    tmp___5 = churnrand();
    }
#line 377
    if (tmp___5 < 0) {
      {
#line 378
      tmp___3 = __errno_location();
#line 378
      tmp___4 = strerror(*tmp___3);
#line 378
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: churnrand: %s\n",
              prog, tmp___4);
#line 380
      exit(1);
      }
    }
    {
#line 382
    written = fillfile(path, size, buf, bufsize, (void (*)(void *arg , double completed ))(& progress_update),
                       (void *)p, & genrand, sparse, enospc);
    }
#line 385
    if (written == -1L) {
      {
#line 386
      tmp___6 = __errno_location();
#line 386
      tmp___7 = strerror(*tmp___6);
#line 386
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s\n",
              prog, path, tmp___7);
#line 388
      exit(1);
      }
    }
    {
#line 390
    progress_destroy(p);
    }
#line 391
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 393
    tmp___8 = pat2str(seq->pat[i]);
#line 393
    printf((char const   */* __restrict  */)"%s: %-8s", prog, tmp___8);
#line 394
    progress_create(& p, 50);
#line 395
    memset_pat((void *)buf, seq->pat[i], (size_t )bufsize);
#line 396
    written = fillfile(path, size, buf, bufsize, (void (*)(void *arg , double completed ))(& progress_update),
                       (void *)p, (void (*)(unsigned char *mem , int memsize ))((void *)0),
                       sparse, enospc);
    }
#line 399
    if (written == -1L) {
      {
#line 400
      tmp___9 = __errno_location();
#line 400
      tmp___10 = strerror(*tmp___9);
#line 400
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s\n",
              prog, path, tmp___10);
#line 402
      exit(1);
      }
    }
    {
#line 404
    progress_destroy(p);
    }
#line 405
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 407
    tmp___11 = pat2str(seq->pat[i]);
#line 407
    printf((char const   */* __restrict  */)"%s: %-8s", prog, tmp___11);
#line 408
    progress_create(& p, 50);
#line 409
    memset_pat((void *)buf, seq->pat[i], (size_t )bufsize);
#line 410
    written = fillfile(path, size, buf, bufsize, (void (*)(void *arg , double completed ))(& progress_update),
                       (void *)p, (void (*)(unsigned char *mem , int memsize ))((void *)0),
                       sparse, enospc);
    }
#line 413
    if (written == -1L) {
      {
#line 414
      tmp___12 = __errno_location();
#line 414
      tmp___13 = strerror(*tmp___12);
#line 414
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s\n",
              prog, path, tmp___13);
#line 416
      exit(1);
      }
    }
    {
#line 418
    progress_destroy(p);
#line 419
    printf((char const   */* __restrict  */)"%s: %-8s", prog, "verify");
#line 420
    progress_create(& p, 50);
#line 421
    checked = checkfile(path, written, buf, bufsize, (void (*)(void *arg , double completed ))(& progress_update),
                        (void *)p, sparse);
    }
#line 423
    if (checked == -1L) {
      {
#line 424
      tmp___14 = __errno_location();
#line 424
      tmp___15 = strerror(*tmp___14);
#line 424
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s\n",
              prog, path, tmp___15);
#line 426
      exit(1);
      }
    }
#line 428
    if (checked < written) {
      {
#line 429
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: verification error\n",
              prog, path);
#line 431
      exit(1);
      }
    }
    {
#line 433
    progress_destroy(p);
    }
#line 434
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 436
    if (written < size) {
#line 437
      if (! (i == 0)) {
        {
#line 437
        __assert_fail("i == 0", "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/scrub.c",
                      437U, "scrub");
        }
      }
#line 438
      if (! ((int )enospc == 1)) {
        {
#line 438
        __assert_fail("enospc == 1", "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/scrub.c",
                      438U, "scrub");
        }
      }
#line 439
      isfull = (_Bool)1;
#line 440
      size = written;
#line 441
      if (size == 0L) {
        {
#line 442
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: file system is full (0 bytes written)\n",
                prog);
        }
#line 444
        goto while_break;
      }
    }
#line 370
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 448
  if (! Sopt) {
    {
#line 449
    tmp___18 = writesig(path);
    }
#line 449
    if (tmp___18 < 0) {
      {
#line 450
      tmp___16 = __errno_location();
#line 450
      tmp___17 = strerror(*tmp___16);
#line 450
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: writing signature to %s: %s\n",
              prog, path, tmp___17);
#line 452
      exit(1);
      }
    }
  }
  {
#line 456
  free((void *)buf);
  }
#line 457
  return (isfull);
}
}
#line 460 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/scrub.c"
static off_t get_rlimit_fsize(void) 
{ 
  struct rlimit r ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 465
  tmp___1 = getrlimit((__rlimit_resource_t )1, & r);
  }
#line 465
  if (tmp___1 < 0) {
    {
#line 466
    tmp = __errno_location();
#line 466
    tmp___0 = strerror(*tmp);
#line 466
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: getrlimit: %s\n",
            prog, tmp___0);
#line 467
    exit(1);
    }
  }
#line 469
  if (r.rlim_cur == 0xffffffffffffffffUL) {
#line 470
    return ((off_t )0);
  }
#line 471
  return ((off_t )r.rlim_cur);
}
}
#line 474 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/scrub.c"
static void set_rlimit_fsize(off_t val ) 
{ 
  struct rlimit r ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 479
  r.rlim_max = (rlim_t )val;
#line 479
  r.rlim_cur = r.rlim_max;
#line 480
  tmp___1 = setrlimit((__rlimit_resource_t )1, (struct rlimit  const  *)(& r));
  }
#line 480
  if (tmp___1 < 0) {
    {
#line 481
    tmp = __errno_location();
#line 481
    tmp___0 = strerror(*tmp);
#line 481
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: setrlimit: %s\n",
            prog, tmp___0);
#line 482
    exit(1);
    }
  }
#line 484
  return;
}
}
#line 489 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/scrub.c"
static void scrub_free(char *dirpath , off_t size , sequence_t const   *seq , int bufsize ,
                       _Bool Sopt ) 
{ 
  char path[4096] ;
  int fileno___0 ;
  struct stat sb ;
  _Bool isfull ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  __uid_t tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;

  {
  {
#line 494
  fileno___0 = 0;
#line 498
  tmp___1 = mkdir((char const   *)dirpath, (__mode_t )493);
  }
#line 498
  if (tmp___1 < 0) {
    {
#line 499
    tmp = __errno_location();
#line 499
    tmp___0 = strerror(*tmp);
#line 499
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: mkdir %s: %s\n",
            prog, path, tmp___0);
#line 500
    exit(1);
    }
  }
  {
#line 502
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: created directory %s\n",
          prog, dirpath);
#line 503
  tmp___4 = stat((char const   */* __restrict  */)dirpath, (struct stat */* __restrict  */)(& sb));
  }
#line 503
  if (tmp___4 < 0) {
    {
#line 504
    tmp___2 = __errno_location();
#line 504
    tmp___3 = strerror(*tmp___2);
#line 504
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: stat %s: %s\n",
            prog, path, tmp___3);
#line 505
    exit(1);
    }
  }
  {
#line 507
  tmp___5 = getuid();
  }
#line 507
  if (tmp___5 == 0U) {
    {
#line 508
    set_rlimit_fsize((off_t )((__rlim_t )-1));
    }
  }
#line 509
  if (size == 0L) {
    {
#line 510
    size = get_rlimit_fsize();
    }
  }
#line 511
  if (size == 0L) {
#line 512
    size = (off_t )1073741824;
  }
  {
#line 513
  size = blkalign(size, (int )sb.st_blksize, (round_t )1);
  }
  {
#line 514
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 515
    tmp___6 = fileno___0;
#line 515
    fileno___0 ++;
#line 515
    snprintf((char */* __restrict  */)(path), sizeof(path), (char const   */* __restrict  */)"%s/scrub.%.3d",
             dirpath, tmp___6);
#line 516
    isfull = scrub(path, size, seq, bufsize, Sopt, (_Bool)0, (_Bool)1);
    }
#line 514
    if (! (! isfull)) {
#line 514
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 518
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 518
    fileno___0 --;
#line 518
    if (! (fileno___0 >= 0)) {
#line 518
      goto while_break___0;
    }
    {
#line 519
    snprintf((char */* __restrict  */)(path), sizeof(path), (char const   */* __restrict  */)"%s/scrub.%.3d",
             dirpath, fileno___0);
#line 520
    tmp___9 = unlink((char const   *)(path));
    }
#line 520
    if (tmp___9 < 0) {
      {
#line 521
      tmp___7 = __errno_location();
#line 521
      tmp___8 = strerror(*tmp___7);
#line 521
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unlink %s: %s\n",
              prog, path, tmp___8);
      }
    } else {
      {
#line 523
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unlinked %s\n",
              prog, path);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 525
  tmp___12 = rmdir((char const   *)dirpath);
  }
#line 525
  if (tmp___12 < 0) {
    {
#line 526
    tmp___10 = __errno_location();
#line 526
    tmp___11 = strerror(*tmp___10);
#line 526
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: rmdir %s: %s\n",
            prog, dirpath, tmp___11);
    }
  } else {
    {
#line 528
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: removed %s\n",
            prog, dirpath);
    }
  }
#line 529
  return;
}
}
#line 533 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/scrub.c"
static void scrub_dirent(char *path , char *newpath ) 
{ 
  sequence_t const   *seq ;
  sequence_t const   *tmp ;
  prog_t p ;
  int i ;
  filetype_t ftype ;
  filetype_t tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 536
  tmp = seq_lookup((char *)"dirent");
#line 536
  seq = tmp;
#line 539
  tmp___0 = filetype(path);
#line 539
  ftype = tmp___0;
  }
#line 541
  if (! ((unsigned long )seq != (unsigned long )((void *)0))) {
    {
#line 541
    __assert_fail("seq != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/scrub.c",
                  541U, "scrub_dirent");
    }
  }
#line 542
  if (! ((unsigned int )ftype == 1U)) {
    {
#line 542
    __assert_fail("ftype == FILE_REGULAR", "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/scrub.c",
                  542U, "scrub_dirent");
    }
  }
  {
#line 544
  printf((char const   */* __restrict  */)"%s: scrubbing directory entry\n", prog);
#line 546
  i = 0;
  }
  {
#line 546
  while (1) {
    while_continue: /* CIL Label */ ;
#line 546
    if (! (i < (int )seq->len)) {
#line 546
      goto while_break;
    }
#line 547
    if (! ((unsigned int const   )seq->pat[i].ptype == 0U)) {
      {
#line 547
      __assert_fail("seq->pat[i].ptype == PAT_NORMAL", "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/scrub.c",
                    547U, "scrub_dirent");
      }
    }
#line 548
    if (! (seq->pat[i].len == 1)) {
      {
#line 548
      __assert_fail("seq->pat[i].len == 1", "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/scrub.c",
                    548U, "scrub_dirent");
      }
    }
    {
#line 549
    tmp___1 = pat2str(seq->pat[i]);
#line 549
    printf((char const   */* __restrict  */)"%s: %-8s", prog, tmp___1);
#line 550
    progress_create(& p, 50);
#line 551
    tmp___4 = filldentry(path, seq->pat[i].pat[0]);
    }
#line 551
    if (tmp___4 < 0) {
      {
#line 552
      tmp___2 = __errno_location();
#line 552
      tmp___3 = strerror(*tmp___2);
#line 552
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: filldentry: %s\n",
              prog, tmp___3);
#line 553
      exit(1);
      }
    }
    {
#line 555
    progress_update(p, 1.0);
#line 556
    progress_destroy(p);
#line 546
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 558
  tmp___5 = rename((char const   *)path, (char const   *)newpath);
  }
#line 558
  if (tmp___5 < 0) {
    {
#line 559
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error renaming %s to %s\n",
            prog, path, newpath);
#line 560
    exit(1);
    }
  }
#line 562
  return;
}
}
#line 566 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/scrub.c"
static void scrub_file(char *path , off_t size , sequence_t const   *seq , int bufsize ,
                       _Bool Sopt , _Bool sparse ) 
{ 
  struct stat sb ;
  filetype_t ftype ;
  filetype_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  off_t tmp___3 ;

  {
  {
#line 571
  tmp = filetype(path);
#line 571
  ftype = tmp;
  }
#line 573
  if (! ((unsigned int )ftype == 1U)) {
#line 573
    if (! ((unsigned int )ftype == 4U)) {
      {
#line 573
      __assert_fail("ftype == FILE_REGULAR || ftype == FILE_LINK", "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/scrub.c",
                    573U, "scrub_file");
      }
    }
  }
  {
#line 575
  tmp___2 = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& sb));
  }
#line 575
  if (tmp___2 < 0) {
    {
#line 576
    tmp___0 = __errno_location();
#line 576
    tmp___1 = strerror(*tmp___0);
#line 576
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: stat %s: %s\n",
            prog, path, tmp___1);
#line 577
    exit(1);
    }
  }
#line 579
  if (size > 0L) {
    {
#line 580
    tmp___3 = blkalign(sb.st_size, (int )sb.st_blksize, (round_t )0);
    }
#line 580
    if (tmp___3 > size) {
      {
#line 581
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: warning: -s size < file size\n",
              prog);
      }
    }
  } else {
#line 583
    if (sb.st_size == 0L) {
      {
#line 584
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: warning: %s is zero length\n",
              prog, path);
      }
#line 585
      return;
    }
    {
#line 587
    size = blkalign(sb.st_size, (int )sb.st_blksize, (round_t )0);
    }
#line 588
    if (size != sb.st_size) {
      {
#line 589
      printf((char const   */* __restrict  */)"%s: padding %s with %d bytes to fill last fs block\n",
             prog, path, (int )(size - sb.st_size));
      }
    }
  }
  {
#line 593
  scrub(path, size, seq, bufsize, Sopt, sparse, (_Bool)0);
  }
#line 594
  return;
}
}
#line 627 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/scrub.c"
static void scrub_disk(char *path , off_t size , sequence_t const   *seq , int bufsize ,
                       _Bool Sopt , _Bool sparse ) 
{ 
  filetype_t ftype ;
  filetype_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 631
  tmp = filetype(path);
#line 631
  ftype = tmp;
  }
#line 633
  if (! ((unsigned int )ftype == 3U)) {
#line 633
    if (! ((unsigned int )ftype == 2U)) {
      {
#line 633
      __assert_fail("ftype == FILE_BLOCK || ftype == FILE_CHAR", "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/scrub.c",
                    633U, "scrub_disk");
      }
    }
  }
#line 634
  if (size == 0L) {
    {
#line 635
    tmp___2 = getsize(path, & size);
    }
#line 635
    if (tmp___2 < 0) {
      {
#line 636
      tmp___0 = __errno_location();
#line 636
      tmp___1 = strerror(*tmp___0);
#line 636
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s\n",
              prog, path, tmp___1);
#line 637
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: could not determine size, use -s\n",
              prog);
#line 638
      exit(1);
      }
    }
    {
#line 640
    printf((char const   */* __restrict  */)"%s: please verify that device size below is correct!\n",
           prog);
    }
  }
  {
#line 642
  scrub(path, size, seq, bufsize, Sopt, sparse, (_Bool)0);
  }
#line 643
  return;
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/aes.h"
int aes_set_key(aes_context *ctx___0 , unsigned char *key , int nbits ) ;
#line 40
void aes_encrypt(aes_context *ctx___0 , unsigned char *input , unsigned char *output ) ;
#line 41
void aes_decrypt(aes_context *ctx___0 , unsigned char *input , unsigned char *output ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/aes.c"
unsigned long FSb[256]  ;
#line 36 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/aes.c"
unsigned long FT0[256]  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/aes.c"
unsigned long FT1[256]  ;
#line 38 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/aes.c"
unsigned long FT2[256]  ;
#line 39 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/aes.c"
unsigned long FT3[256]  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/aes.c"
unsigned long RSb[256]  ;
#line 44 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/aes.c"
unsigned long RT0[256]  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/aes.c"
unsigned long RT1[256]  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/aes.c"
unsigned long RT2[256]  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/aes.c"
unsigned long RT3[256]  ;
#line 51 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/aes.c"
unsigned long RCON[10]  ;
#line 55 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/aes.c"
int do_init  =    1;
#line 65 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/aes.c"
void aes_gen_tables(void) 
{ 
  int i ;
  unsigned char x ;
  unsigned char y ;
  unsigned char pow[256] ;
  unsigned char log[256] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 74
  i = 0;
#line 74
  x = (unsigned char)1;
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (! (i < 256)) {
#line 74
      goto while_break;
    }
#line 76
    pow[i] = x;
#line 77
    log[x] = (unsigned char )i;
#line 74
    i ++;
#line 74
    if ((int )x & 128) {
#line 74
      tmp = 27;
    } else {
#line 74
      tmp = 0;
    }
#line 74
    x = (unsigned char )((int )x ^ (((int )x << 1) ^ tmp));
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  i = 0;
#line 82
  x = (unsigned char)1;
  {
#line 82
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 82
    if (! (i < 10)) {
#line 82
      goto while_break___0;
    }
#line 84
    RCON[i] = (unsigned long )x << 24;
#line 82
    i ++;
#line 82
    if ((int )x & 128) {
#line 82
      tmp___0 = 27;
    } else {
#line 82
      tmp___0 = 0;
    }
#line 82
    x = (unsigned char )(((int )x << 1) ^ tmp___0);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 89
  FSb[0] = 99UL;
#line 90
  RSb[99] = 0UL;
#line 92
  i = 1;
  {
#line 92
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 92
    if (! (i < 256)) {
#line 92
      goto while_break___1;
    }
#line 94
    x = pow[255 - (int )log[i]];
#line 96
    y = x;
#line 96
    y = (unsigned char )(((int )y << 1) | ((int )y >> 7));
#line 97
    x = (unsigned char )((int )x ^ (int )y);
#line 97
    y = (unsigned char )(((int )y << 1) | ((int )y >> 7));
#line 98
    x = (unsigned char )((int )x ^ (int )y);
#line 98
    y = (unsigned char )(((int )y << 1) | ((int )y >> 7));
#line 99
    x = (unsigned char )((int )x ^ (int )y);
#line 99
    y = (unsigned char )(((int )y << 1) | ((int )y >> 7));
#line 100
    x = (unsigned char )((int )x ^ ((int )y ^ 99));
#line 102
    FSb[i] = (unsigned long )x;
#line 103
    RSb[x] = (unsigned long )i;
#line 92
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 108
  i = 0;
  {
#line 108
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 108
    if (! (i < 256)) {
#line 108
      goto while_break___2;
    }
#line 110
    x = (unsigned char )FSb[i];
#line 110
    if ((int )x & 128) {
#line 110
      tmp___1 = 27;
    } else {
#line 110
      tmp___1 = 0;
    }
#line 110
    y = (unsigned char )(((int )x << 1) ^ tmp___1);
#line 112
    FT0[i] = (((unsigned long )((int )x ^ (int )y) ^ ((unsigned long )x << 8)) ^ ((unsigned long )x << 16)) ^ ((unsigned long )y << 24);
#line 117
    FT0[i] &= 4294967295UL;
#line 119
    FT1[i] = ((FT0[i] << 24) & 4294967295UL) | ((FT0[i] & 4294967295UL) >> 8);
#line 120
    FT2[i] = ((FT1[i] << 24) & 4294967295UL) | ((FT1[i] & 4294967295UL) >> 8);
#line 121
    FT3[i] = ((FT2[i] << 24) & 4294967295UL) | ((FT2[i] & 4294967295UL) >> 8);
#line 123
    y = (unsigned char )RSb[i];
#line 125
    if (y) {
#line 125
      tmp___2 = (int )pow[((int )log[11] + (int )log[y]) % 255];
    } else {
#line 125
      tmp___2 = 0;
    }
#line 125
    if (y) {
#line 125
      tmp___3 = (int )pow[((int )log[13] + (int )log[y]) % 255];
    } else {
#line 125
      tmp___3 = 0;
    }
#line 125
    if (y) {
#line 125
      tmp___4 = (int )pow[((int )log[9] + (int )log[y]) % 255];
    } else {
#line 125
      tmp___4 = 0;
    }
#line 125
    if (y) {
#line 125
      tmp___5 = (int )pow[((int )log[14] + (int )log[y]) % 255];
    } else {
#line 125
      tmp___5 = 0;
    }
#line 125
    RT0[i] = (((unsigned long )tmp___2 ^ ((unsigned long )tmp___3 << 8)) ^ ((unsigned long )tmp___4 << 16)) ^ ((unsigned long )tmp___5 << 24);
#line 130
    RT0[i] &= 4294967295UL;
#line 132
    RT1[i] = ((RT0[i] << 24) & 4294967295UL) | ((RT0[i] & 4294967295UL) >> 8);
#line 133
    RT2[i] = ((RT1[i] << 24) & 4294967295UL) | ((RT1[i] & 4294967295UL) >> 8);
#line 134
    RT3[i] = ((RT2[i] << 24) & 4294967295UL) | ((RT2[i] & 4294967295UL) >> 8);
#line 108
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 136
  return;
}
}
#line 427 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/aes.c"
int KT_init  =    1;
#line 429 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/aes.c"
unsigned long KT0[256]  ;
#line 430 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/aes.c"
unsigned long KT1[256]  ;
#line 431 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/aes.c"
unsigned long KT2[256]  ;
#line 432 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/aes.c"
unsigned long KT3[256]  ;
#line 436 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/aes.c"
int aes_set_key(aes_context *ctx___0 , unsigned char *key , int nbits ) 
{ 
  int i ;
  unsigned long *RK ;
  unsigned long *SK ;
  unsigned long *tmp ;
  unsigned long *tmp___0 ;
  unsigned long *tmp___1 ;
  unsigned long *tmp___2 ;
  unsigned long *tmp___3 ;
  unsigned long *tmp___4 ;
  unsigned long *tmp___5 ;
  unsigned long *tmp___6 ;
  unsigned long *tmp___7 ;
  unsigned long *tmp___8 ;
  unsigned long *tmp___9 ;
  unsigned long *tmp___10 ;
  unsigned long *tmp___11 ;
  unsigned long *tmp___12 ;
  unsigned long *tmp___13 ;
  unsigned long *tmp___14 ;
  unsigned long *tmp___15 ;
  unsigned long *tmp___16 ;
  unsigned long *tmp___17 ;
  unsigned long *tmp___18 ;

  {
#line 441
  if (do_init) {
    {
#line 443
    aes_gen_tables();
#line 445
    do_init = 0;
    }
  }
  {
#line 450
  if (nbits == 128) {
#line 450
    goto case_128;
  }
#line 451
  if (nbits == 192) {
#line 451
    goto case_192;
  }
#line 452
  if (nbits == 256) {
#line 452
    goto case_256;
  }
#line 453
  goto switch_default;
  case_128: /* CIL Label */ 
#line 450
  ctx___0->nr = 10;
#line 450
  goto switch_break;
  case_192: /* CIL Label */ 
#line 451
  ctx___0->nr = 12;
#line 451
  goto switch_break;
  case_256: /* CIL Label */ 
#line 452
  ctx___0->nr = 14;
#line 452
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 453
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 456
  RK = ctx___0->erk;
#line 458
  i = 0;
  {
#line 458
  while (1) {
    while_continue: /* CIL Label */ ;
#line 458
    if (! (i < nbits >> 5)) {
#line 458
      goto while_break;
    }
#line 460
    *(RK + i) = ((((unsigned long )*(key + i * 4) << 24) | ((unsigned long )*(key + (i * 4 + 1)) << 16)) | ((unsigned long )*(key + (i * 4 + 2)) << 8)) | (unsigned long )*(key + (i * 4 + 3));
#line 458
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 467
  if (nbits == 128) {
#line 467
    goto case_128___0;
  }
#line 483
  if (nbits == 192) {
#line 483
    goto case_192___0;
  }
#line 501
  if (nbits == 256) {
#line 501
    goto case_256___0;
  }
#line 465
  goto switch_break___0;
  case_128___0: /* CIL Label */ 
#line 469
  i = 0;
  {
#line 469
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 469
    if (! (i < 10)) {
#line 469
      goto while_break___0;
    }
#line 471
    *(RK + 4) = ((((*(RK + 0) ^ RCON[i]) ^ (FSb[(unsigned char )(*(RK + 3) >> 16)] << 24)) ^ (FSb[(unsigned char )(*(RK + 3) >> 8)] << 16)) ^ (FSb[(unsigned char )*(RK + 3)] << 8)) ^ FSb[(unsigned char )(*(RK + 3) >> 24)];
#line 477
    *(RK + 5) = *(RK + 1) ^ *(RK + 4);
#line 478
    *(RK + 6) = *(RK + 2) ^ *(RK + 5);
#line 479
    *(RK + 7) = *(RK + 3) ^ *(RK + 6);
#line 469
    i ++;
#line 469
    RK += 4;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 481
  goto switch_break___0;
  case_192___0: /* CIL Label */ 
#line 485
  i = 0;
  {
#line 485
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 485
    if (! (i < 8)) {
#line 485
      goto while_break___1;
    }
#line 487
    *(RK + 6) = ((((*(RK + 0) ^ RCON[i]) ^ (FSb[(unsigned char )(*(RK + 5) >> 16)] << 24)) ^ (FSb[(unsigned char )(*(RK + 5) >> 8)] << 16)) ^ (FSb[(unsigned char )*(RK + 5)] << 8)) ^ FSb[(unsigned char )(*(RK + 5) >> 24)];
#line 493
    *(RK + 7) = *(RK + 1) ^ *(RK + 6);
#line 494
    *(RK + 8) = *(RK + 2) ^ *(RK + 7);
#line 495
    *(RK + 9) = *(RK + 3) ^ *(RK + 8);
#line 496
    *(RK + 10) = *(RK + 4) ^ *(RK + 9);
#line 497
    *(RK + 11) = *(RK + 5) ^ *(RK + 10);
#line 485
    i ++;
#line 485
    RK += 6;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 499
  goto switch_break___0;
  case_256___0: /* CIL Label */ 
#line 503
  i = 0;
  {
#line 503
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 503
    if (! (i < 7)) {
#line 503
      goto while_break___2;
    }
#line 505
    *(RK + 8) = ((((*(RK + 0) ^ RCON[i]) ^ (FSb[(unsigned char )(*(RK + 7) >> 16)] << 24)) ^ (FSb[(unsigned char )(*(RK + 7) >> 8)] << 16)) ^ (FSb[(unsigned char )*(RK + 7)] << 8)) ^ FSb[(unsigned char )(*(RK + 7) >> 24)];
#line 511
    *(RK + 9) = *(RK + 1) ^ *(RK + 8);
#line 512
    *(RK + 10) = *(RK + 2) ^ *(RK + 9);
#line 513
    *(RK + 11) = *(RK + 3) ^ *(RK + 10);
#line 515
    *(RK + 12) = (((*(RK + 4) ^ (FSb[(unsigned char )(*(RK + 11) >> 24)] << 24)) ^ (FSb[(unsigned char )(*(RK + 11) >> 16)] << 16)) ^ (FSb[(unsigned char )(*(RK + 11) >> 8)] << 8)) ^ FSb[(unsigned char )*(RK + 11)];
#line 521
    *(RK + 13) = *(RK + 5) ^ *(RK + 12);
#line 522
    *(RK + 14) = *(RK + 6) ^ *(RK + 13);
#line 523
    *(RK + 15) = *(RK + 7) ^ *(RK + 14);
#line 503
    i ++;
#line 503
    RK += 8;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 525
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 530
  if (KT_init) {
#line 532
    i = 0;
    {
#line 532
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 532
      if (! (i < 256)) {
#line 532
        goto while_break___3;
      }
#line 534
      KT0[i] = RT0[FSb[i]];
#line 535
      KT1[i] = RT1[FSb[i]];
#line 536
      KT2[i] = RT2[FSb[i]];
#line 537
      KT3[i] = RT3[FSb[i]];
#line 532
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 540
    KT_init = 0;
  }
#line 543
  SK = ctx___0->drk;
#line 545
  tmp = SK;
#line 545
  SK ++;
#line 545
  tmp___0 = RK;
#line 545
  RK ++;
#line 545
  *tmp = *tmp___0;
#line 546
  tmp___1 = SK;
#line 546
  SK ++;
#line 546
  tmp___2 = RK;
#line 546
  RK ++;
#line 546
  *tmp___1 = *tmp___2;
#line 547
  tmp___3 = SK;
#line 547
  SK ++;
#line 547
  tmp___4 = RK;
#line 547
  RK ++;
#line 547
  *tmp___3 = *tmp___4;
#line 548
  tmp___5 = SK;
#line 548
  SK ++;
#line 548
  tmp___6 = RK;
#line 548
  RK ++;
#line 548
  *tmp___5 = *tmp___6;
#line 550
  i = 1;
  {
#line 550
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 550
    if (! (i < ctx___0->nr)) {
#line 550
      goto while_break___4;
    }
#line 552
    RK -= 8;
#line 554
    tmp___7 = SK;
#line 554
    SK ++;
#line 554
    *tmp___7 = ((KT0[(unsigned char )(*RK >> 24)] ^ KT1[(unsigned char )(*RK >> 16)]) ^ KT2[(unsigned char )(*RK >> 8)]) ^ KT3[(unsigned char )*RK];
#line 557
    RK ++;
#line 559
    tmp___8 = SK;
#line 559
    SK ++;
#line 559
    *tmp___8 = ((KT0[(unsigned char )(*RK >> 24)] ^ KT1[(unsigned char )(*RK >> 16)]) ^ KT2[(unsigned char )(*RK >> 8)]) ^ KT3[(unsigned char )*RK];
#line 562
    RK ++;
#line 564
    tmp___9 = SK;
#line 564
    SK ++;
#line 564
    *tmp___9 = ((KT0[(unsigned char )(*RK >> 24)] ^ KT1[(unsigned char )(*RK >> 16)]) ^ KT2[(unsigned char )(*RK >> 8)]) ^ KT3[(unsigned char )*RK];
#line 567
    RK ++;
#line 569
    tmp___10 = SK;
#line 569
    SK ++;
#line 569
    *tmp___10 = ((KT0[(unsigned char )(*RK >> 24)] ^ KT1[(unsigned char )(*RK >> 16)]) ^ KT2[(unsigned char )(*RK >> 8)]) ^ KT3[(unsigned char )*RK];
#line 572
    RK ++;
#line 550
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 575
  RK -= 8;
#line 577
  tmp___11 = SK;
#line 577
  SK ++;
#line 577
  tmp___12 = RK;
#line 577
  RK ++;
#line 577
  *tmp___11 = *tmp___12;
#line 578
  tmp___13 = SK;
#line 578
  SK ++;
#line 578
  tmp___14 = RK;
#line 578
  RK ++;
#line 578
  *tmp___13 = *tmp___14;
#line 579
  tmp___15 = SK;
#line 579
  SK ++;
#line 579
  tmp___16 = RK;
#line 579
  RK ++;
#line 579
  *tmp___15 = *tmp___16;
#line 580
  tmp___17 = SK;
#line 580
  SK ++;
#line 580
  tmp___18 = RK;
#line 580
  RK ++;
#line 580
  *tmp___17 = *tmp___18;
#line 582
  return (0);
}
}
#line 587 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/aes.c"
void aes_encrypt(aes_context *ctx___0 , unsigned char *input , unsigned char *output ) 
{ 
  unsigned long *RK ;
  unsigned long X0 ;
  unsigned long X1 ;
  unsigned long X2 ;
  unsigned long X3 ;
  unsigned long Y0 ;
  unsigned long Y1 ;
  unsigned long Y2 ;
  unsigned long Y3 ;

  {
#line 591
  RK = ctx___0->erk;
#line 593
  X0 = ((((unsigned long )*(input + 0) << 24) | ((unsigned long )*(input + 1) << 16)) | ((unsigned long )*(input + 2) << 8)) | (unsigned long )*(input + 3);
#line 593
  X0 ^= *(RK + 0);
#line 594
  X1 = ((((unsigned long )*(input + 4) << 24) | ((unsigned long )*(input + 5) << 16)) | ((unsigned long )*(input + 6) << 8)) | (unsigned long )*(input + 7);
#line 594
  X1 ^= *(RK + 1);
#line 595
  X2 = ((((unsigned long )*(input + 8) << 24) | ((unsigned long )*(input + 9) << 16)) | ((unsigned long )*(input + 10) << 8)) | (unsigned long )*(input + 11);
#line 595
  X2 ^= *(RK + 2);
#line 596
  X3 = ((((unsigned long )*(input + 12) << 24) | ((unsigned long )*(input + 13) << 16)) | ((unsigned long )*(input + 14) << 8)) | (unsigned long )*(input + 15);
#line 596
  X3 ^= *(RK + 3);
#line 623
  RK += 4;
#line 623
  Y0 = (((*(RK + 0) ^ FT0[(unsigned char )(X0 >> 24)]) ^ FT1[(unsigned char )(X1 >> 16)]) ^ FT2[(unsigned char )(X2 >> 8)]) ^ FT3[(unsigned char )X3];
#line 623
  Y1 = (((*(RK + 1) ^ FT0[(unsigned char )(X1 >> 24)]) ^ FT1[(unsigned char )(X2 >> 16)]) ^ FT2[(unsigned char )(X3 >> 8)]) ^ FT3[(unsigned char )X0];
#line 623
  Y2 = (((*(RK + 2) ^ FT0[(unsigned char )(X2 >> 24)]) ^ FT1[(unsigned char )(X3 >> 16)]) ^ FT2[(unsigned char )(X0 >> 8)]) ^ FT3[(unsigned char )X1];
#line 623
  Y3 = (((*(RK + 3) ^ FT0[(unsigned char )(X3 >> 24)]) ^ FT1[(unsigned char )(X0 >> 16)]) ^ FT2[(unsigned char )(X1 >> 8)]) ^ FT3[(unsigned char )X2];
#line 624
  RK += 4;
#line 624
  X0 = (((*(RK + 0) ^ FT0[(unsigned char )(Y0 >> 24)]) ^ FT1[(unsigned char )(Y1 >> 16)]) ^ FT2[(unsigned char )(Y2 >> 8)]) ^ FT3[(unsigned char )Y3];
#line 624
  X1 = (((*(RK + 1) ^ FT0[(unsigned char )(Y1 >> 24)]) ^ FT1[(unsigned char )(Y2 >> 16)]) ^ FT2[(unsigned char )(Y3 >> 8)]) ^ FT3[(unsigned char )Y0];
#line 624
  X2 = (((*(RK + 2) ^ FT0[(unsigned char )(Y2 >> 24)]) ^ FT1[(unsigned char )(Y3 >> 16)]) ^ FT2[(unsigned char )(Y0 >> 8)]) ^ FT3[(unsigned char )Y1];
#line 624
  X3 = (((*(RK + 3) ^ FT0[(unsigned char )(Y3 >> 24)]) ^ FT1[(unsigned char )(Y0 >> 16)]) ^ FT2[(unsigned char )(Y1 >> 8)]) ^ FT3[(unsigned char )Y2];
#line 625
  RK += 4;
#line 625
  Y0 = (((*(RK + 0) ^ FT0[(unsigned char )(X0 >> 24)]) ^ FT1[(unsigned char )(X1 >> 16)]) ^ FT2[(unsigned char )(X2 >> 8)]) ^ FT3[(unsigned char )X3];
#line 625
  Y1 = (((*(RK + 1) ^ FT0[(unsigned char )(X1 >> 24)]) ^ FT1[(unsigned char )(X2 >> 16)]) ^ FT2[(unsigned char )(X3 >> 8)]) ^ FT3[(unsigned char )X0];
#line 625
  Y2 = (((*(RK + 2) ^ FT0[(unsigned char )(X2 >> 24)]) ^ FT1[(unsigned char )(X3 >> 16)]) ^ FT2[(unsigned char )(X0 >> 8)]) ^ FT3[(unsigned char )X1];
#line 625
  Y3 = (((*(RK + 3) ^ FT0[(unsigned char )(X3 >> 24)]) ^ FT1[(unsigned char )(X0 >> 16)]) ^ FT2[(unsigned char )(X1 >> 8)]) ^ FT3[(unsigned char )X2];
#line 626
  RK += 4;
#line 626
  X0 = (((*(RK + 0) ^ FT0[(unsigned char )(Y0 >> 24)]) ^ FT1[(unsigned char )(Y1 >> 16)]) ^ FT2[(unsigned char )(Y2 >> 8)]) ^ FT3[(unsigned char )Y3];
#line 626
  X1 = (((*(RK + 1) ^ FT0[(unsigned char )(Y1 >> 24)]) ^ FT1[(unsigned char )(Y2 >> 16)]) ^ FT2[(unsigned char )(Y3 >> 8)]) ^ FT3[(unsigned char )Y0];
#line 626
  X2 = (((*(RK + 2) ^ FT0[(unsigned char )(Y2 >> 24)]) ^ FT1[(unsigned char )(Y3 >> 16)]) ^ FT2[(unsigned char )(Y0 >> 8)]) ^ FT3[(unsigned char )Y1];
#line 626
  X3 = (((*(RK + 3) ^ FT0[(unsigned char )(Y3 >> 24)]) ^ FT1[(unsigned char )(Y0 >> 16)]) ^ FT2[(unsigned char )(Y1 >> 8)]) ^ FT3[(unsigned char )Y2];
#line 627
  RK += 4;
#line 627
  Y0 = (((*(RK + 0) ^ FT0[(unsigned char )(X0 >> 24)]) ^ FT1[(unsigned char )(X1 >> 16)]) ^ FT2[(unsigned char )(X2 >> 8)]) ^ FT3[(unsigned char )X3];
#line 627
  Y1 = (((*(RK + 1) ^ FT0[(unsigned char )(X1 >> 24)]) ^ FT1[(unsigned char )(X2 >> 16)]) ^ FT2[(unsigned char )(X3 >> 8)]) ^ FT3[(unsigned char )X0];
#line 627
  Y2 = (((*(RK + 2) ^ FT0[(unsigned char )(X2 >> 24)]) ^ FT1[(unsigned char )(X3 >> 16)]) ^ FT2[(unsigned char )(X0 >> 8)]) ^ FT3[(unsigned char )X1];
#line 627
  Y3 = (((*(RK + 3) ^ FT0[(unsigned char )(X3 >> 24)]) ^ FT1[(unsigned char )(X0 >> 16)]) ^ FT2[(unsigned char )(X1 >> 8)]) ^ FT3[(unsigned char )X2];
#line 628
  RK += 4;
#line 628
  X0 = (((*(RK + 0) ^ FT0[(unsigned char )(Y0 >> 24)]) ^ FT1[(unsigned char )(Y1 >> 16)]) ^ FT2[(unsigned char )(Y2 >> 8)]) ^ FT3[(unsigned char )Y3];
#line 628
  X1 = (((*(RK + 1) ^ FT0[(unsigned char )(Y1 >> 24)]) ^ FT1[(unsigned char )(Y2 >> 16)]) ^ FT2[(unsigned char )(Y3 >> 8)]) ^ FT3[(unsigned char )Y0];
#line 628
  X2 = (((*(RK + 2) ^ FT0[(unsigned char )(Y2 >> 24)]) ^ FT1[(unsigned char )(Y3 >> 16)]) ^ FT2[(unsigned char )(Y0 >> 8)]) ^ FT3[(unsigned char )Y1];
#line 628
  X3 = (((*(RK + 3) ^ FT0[(unsigned char )(Y3 >> 24)]) ^ FT1[(unsigned char )(Y0 >> 16)]) ^ FT2[(unsigned char )(Y1 >> 8)]) ^ FT3[(unsigned char )Y2];
#line 629
  RK += 4;
#line 629
  Y0 = (((*(RK + 0) ^ FT0[(unsigned char )(X0 >> 24)]) ^ FT1[(unsigned char )(X1 >> 16)]) ^ FT2[(unsigned char )(X2 >> 8)]) ^ FT3[(unsigned char )X3];
#line 629
  Y1 = (((*(RK + 1) ^ FT0[(unsigned char )(X1 >> 24)]) ^ FT1[(unsigned char )(X2 >> 16)]) ^ FT2[(unsigned char )(X3 >> 8)]) ^ FT3[(unsigned char )X0];
#line 629
  Y2 = (((*(RK + 2) ^ FT0[(unsigned char )(X2 >> 24)]) ^ FT1[(unsigned char )(X3 >> 16)]) ^ FT2[(unsigned char )(X0 >> 8)]) ^ FT3[(unsigned char )X1];
#line 629
  Y3 = (((*(RK + 3) ^ FT0[(unsigned char )(X3 >> 24)]) ^ FT1[(unsigned char )(X0 >> 16)]) ^ FT2[(unsigned char )(X1 >> 8)]) ^ FT3[(unsigned char )X2];
#line 630
  RK += 4;
#line 630
  X0 = (((*(RK + 0) ^ FT0[(unsigned char )(Y0 >> 24)]) ^ FT1[(unsigned char )(Y1 >> 16)]) ^ FT2[(unsigned char )(Y2 >> 8)]) ^ FT3[(unsigned char )Y3];
#line 630
  X1 = (((*(RK + 1) ^ FT0[(unsigned char )(Y1 >> 24)]) ^ FT1[(unsigned char )(Y2 >> 16)]) ^ FT2[(unsigned char )(Y3 >> 8)]) ^ FT3[(unsigned char )Y0];
#line 630
  X2 = (((*(RK + 2) ^ FT0[(unsigned char )(Y2 >> 24)]) ^ FT1[(unsigned char )(Y3 >> 16)]) ^ FT2[(unsigned char )(Y0 >> 8)]) ^ FT3[(unsigned char )Y1];
#line 630
  X3 = (((*(RK + 3) ^ FT0[(unsigned char )(Y3 >> 24)]) ^ FT1[(unsigned char )(Y0 >> 16)]) ^ FT2[(unsigned char )(Y1 >> 8)]) ^ FT3[(unsigned char )Y2];
#line 631
  RK += 4;
#line 631
  Y0 = (((*(RK + 0) ^ FT0[(unsigned char )(X0 >> 24)]) ^ FT1[(unsigned char )(X1 >> 16)]) ^ FT2[(unsigned char )(X2 >> 8)]) ^ FT3[(unsigned char )X3];
#line 631
  Y1 = (((*(RK + 1) ^ FT0[(unsigned char )(X1 >> 24)]) ^ FT1[(unsigned char )(X2 >> 16)]) ^ FT2[(unsigned char )(X3 >> 8)]) ^ FT3[(unsigned char )X0];
#line 631
  Y2 = (((*(RK + 2) ^ FT0[(unsigned char )(X2 >> 24)]) ^ FT1[(unsigned char )(X3 >> 16)]) ^ FT2[(unsigned char )(X0 >> 8)]) ^ FT3[(unsigned char )X1];
#line 631
  Y3 = (((*(RK + 3) ^ FT0[(unsigned char )(X3 >> 24)]) ^ FT1[(unsigned char )(X0 >> 16)]) ^ FT2[(unsigned char )(X1 >> 8)]) ^ FT3[(unsigned char )X2];
#line 633
  if (ctx___0->nr > 10) {
#line 635
    RK += 4;
#line 635
    X0 = (((*(RK + 0) ^ FT0[(unsigned char )(Y0 >> 24)]) ^ FT1[(unsigned char )(Y1 >> 16)]) ^ FT2[(unsigned char )(Y2 >> 8)]) ^ FT3[(unsigned char )Y3];
#line 635
    X1 = (((*(RK + 1) ^ FT0[(unsigned char )(Y1 >> 24)]) ^ FT1[(unsigned char )(Y2 >> 16)]) ^ FT2[(unsigned char )(Y3 >> 8)]) ^ FT3[(unsigned char )Y0];
#line 635
    X2 = (((*(RK + 2) ^ FT0[(unsigned char )(Y2 >> 24)]) ^ FT1[(unsigned char )(Y3 >> 16)]) ^ FT2[(unsigned char )(Y0 >> 8)]) ^ FT3[(unsigned char )Y1];
#line 635
    X3 = (((*(RK + 3) ^ FT0[(unsigned char )(Y3 >> 24)]) ^ FT1[(unsigned char )(Y0 >> 16)]) ^ FT2[(unsigned char )(Y1 >> 8)]) ^ FT3[(unsigned char )Y2];
#line 636
    RK += 4;
#line 636
    Y0 = (((*(RK + 0) ^ FT0[(unsigned char )(X0 >> 24)]) ^ FT1[(unsigned char )(X1 >> 16)]) ^ FT2[(unsigned char )(X2 >> 8)]) ^ FT3[(unsigned char )X3];
#line 636
    Y1 = (((*(RK + 1) ^ FT0[(unsigned char )(X1 >> 24)]) ^ FT1[(unsigned char )(X2 >> 16)]) ^ FT2[(unsigned char )(X3 >> 8)]) ^ FT3[(unsigned char )X0];
#line 636
    Y2 = (((*(RK + 2) ^ FT0[(unsigned char )(X2 >> 24)]) ^ FT1[(unsigned char )(X3 >> 16)]) ^ FT2[(unsigned char )(X0 >> 8)]) ^ FT3[(unsigned char )X1];
#line 636
    Y3 = (((*(RK + 3) ^ FT0[(unsigned char )(X3 >> 24)]) ^ FT1[(unsigned char )(X0 >> 16)]) ^ FT2[(unsigned char )(X1 >> 8)]) ^ FT3[(unsigned char )X2];
  }
#line 639
  if (ctx___0->nr > 12) {
#line 641
    RK += 4;
#line 641
    X0 = (((*(RK + 0) ^ FT0[(unsigned char )(Y0 >> 24)]) ^ FT1[(unsigned char )(Y1 >> 16)]) ^ FT2[(unsigned char )(Y2 >> 8)]) ^ FT3[(unsigned char )Y3];
#line 641
    X1 = (((*(RK + 1) ^ FT0[(unsigned char )(Y1 >> 24)]) ^ FT1[(unsigned char )(Y2 >> 16)]) ^ FT2[(unsigned char )(Y3 >> 8)]) ^ FT3[(unsigned char )Y0];
#line 641
    X2 = (((*(RK + 2) ^ FT0[(unsigned char )(Y2 >> 24)]) ^ FT1[(unsigned char )(Y3 >> 16)]) ^ FT2[(unsigned char )(Y0 >> 8)]) ^ FT3[(unsigned char )Y1];
#line 641
    X3 = (((*(RK + 3) ^ FT0[(unsigned char )(Y3 >> 24)]) ^ FT1[(unsigned char )(Y0 >> 16)]) ^ FT2[(unsigned char )(Y1 >> 8)]) ^ FT3[(unsigned char )Y2];
#line 642
    RK += 4;
#line 642
    Y0 = (((*(RK + 0) ^ FT0[(unsigned char )(X0 >> 24)]) ^ FT1[(unsigned char )(X1 >> 16)]) ^ FT2[(unsigned char )(X2 >> 8)]) ^ FT3[(unsigned char )X3];
#line 642
    Y1 = (((*(RK + 1) ^ FT0[(unsigned char )(X1 >> 24)]) ^ FT1[(unsigned char )(X2 >> 16)]) ^ FT2[(unsigned char )(X3 >> 8)]) ^ FT3[(unsigned char )X0];
#line 642
    Y2 = (((*(RK + 2) ^ FT0[(unsigned char )(X2 >> 24)]) ^ FT1[(unsigned char )(X3 >> 16)]) ^ FT2[(unsigned char )(X0 >> 8)]) ^ FT3[(unsigned char )X1];
#line 642
    Y3 = (((*(RK + 3) ^ FT0[(unsigned char )(X3 >> 24)]) ^ FT1[(unsigned char )(X0 >> 16)]) ^ FT2[(unsigned char )(X1 >> 8)]) ^ FT3[(unsigned char )X2];
  }
#line 647
  RK += 4;
#line 649
  X0 = (((*(RK + 0) ^ (FSb[(unsigned char )(Y0 >> 24)] << 24)) ^ (FSb[(unsigned char )(Y1 >> 16)] << 16)) ^ (FSb[(unsigned char )(Y2 >> 8)] << 8)) ^ FSb[(unsigned char )Y3];
#line 654
  X1 = (((*(RK + 1) ^ (FSb[(unsigned char )(Y1 >> 24)] << 24)) ^ (FSb[(unsigned char )(Y2 >> 16)] << 16)) ^ (FSb[(unsigned char )(Y3 >> 8)] << 8)) ^ FSb[(unsigned char )Y0];
#line 659
  X2 = (((*(RK + 2) ^ (FSb[(unsigned char )(Y2 >> 24)] << 24)) ^ (FSb[(unsigned char )(Y3 >> 16)] << 16)) ^ (FSb[(unsigned char )(Y0 >> 8)] << 8)) ^ FSb[(unsigned char )Y1];
#line 664
  X3 = (((*(RK + 3) ^ (FSb[(unsigned char )(Y3 >> 24)] << 24)) ^ (FSb[(unsigned char )(Y0 >> 16)] << 16)) ^ (FSb[(unsigned char )(Y1 >> 8)] << 8)) ^ FSb[(unsigned char )Y2];
#line 669
  *(output + 0) = (unsigned char )(X0 >> 24);
#line 669
  *(output + 1) = (unsigned char )(X0 >> 16);
#line 669
  *(output + 2) = (unsigned char )(X0 >> 8);
#line 669
  *(output + 3) = (unsigned char )X0;
#line 670
  *(output + 4) = (unsigned char )(X1 >> 24);
#line 670
  *(output + 5) = (unsigned char )(X1 >> 16);
#line 670
  *(output + 6) = (unsigned char )(X1 >> 8);
#line 670
  *(output + 7) = (unsigned char )X1;
#line 671
  *(output + 8) = (unsigned char )(X2 >> 24);
#line 671
  *(output + 9) = (unsigned char )(X2 >> 16);
#line 671
  *(output + 10) = (unsigned char )(X2 >> 8);
#line 671
  *(output + 11) = (unsigned char )X2;
#line 672
  *(output + 12) = (unsigned char )(X3 >> 24);
#line 672
  *(output + 13) = (unsigned char )(X3 >> 16);
#line 672
  *(output + 14) = (unsigned char )(X3 >> 8);
#line 672
  *(output + 15) = (unsigned char )X3;
#line 673
  return;
}
}
#line 677 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/aes.c"
void aes_decrypt(aes_context *ctx___0 , unsigned char *input , unsigned char *output ) 
{ 
  unsigned long *RK ;
  unsigned long X0 ;
  unsigned long X1 ;
  unsigned long X2 ;
  unsigned long X3 ;
  unsigned long Y0 ;
  unsigned long Y1 ;
  unsigned long Y2 ;
  unsigned long Y3 ;

  {
#line 681
  RK = ctx___0->drk;
#line 683
  X0 = ((((unsigned long )*(input + 0) << 24) | ((unsigned long )*(input + 1) << 16)) | ((unsigned long )*(input + 2) << 8)) | (unsigned long )*(input + 3);
#line 683
  X0 ^= *(RK + 0);
#line 684
  X1 = ((((unsigned long )*(input + 4) << 24) | ((unsigned long )*(input + 5) << 16)) | ((unsigned long )*(input + 6) << 8)) | (unsigned long )*(input + 7);
#line 684
  X1 ^= *(RK + 1);
#line 685
  X2 = ((((unsigned long )*(input + 8) << 24) | ((unsigned long )*(input + 9) << 16)) | ((unsigned long )*(input + 10) << 8)) | (unsigned long )*(input + 11);
#line 685
  X2 ^= *(RK + 2);
#line 686
  X3 = ((((unsigned long )*(input + 12) << 24) | ((unsigned long )*(input + 13) << 16)) | ((unsigned long )*(input + 14) << 8)) | (unsigned long )*(input + 15);
#line 686
  X3 ^= *(RK + 3);
#line 713
  RK += 4;
#line 713
  Y0 = (((*(RK + 0) ^ RT0[(unsigned char )(X0 >> 24)]) ^ RT1[(unsigned char )(X3 >> 16)]) ^ RT2[(unsigned char )(X2 >> 8)]) ^ RT3[(unsigned char )X1];
#line 713
  Y1 = (((*(RK + 1) ^ RT0[(unsigned char )(X1 >> 24)]) ^ RT1[(unsigned char )(X0 >> 16)]) ^ RT2[(unsigned char )(X3 >> 8)]) ^ RT3[(unsigned char )X2];
#line 713
  Y2 = (((*(RK + 2) ^ RT0[(unsigned char )(X2 >> 24)]) ^ RT1[(unsigned char )(X1 >> 16)]) ^ RT2[(unsigned char )(X0 >> 8)]) ^ RT3[(unsigned char )X3];
#line 713
  Y3 = (((*(RK + 3) ^ RT0[(unsigned char )(X3 >> 24)]) ^ RT1[(unsigned char )(X2 >> 16)]) ^ RT2[(unsigned char )(X1 >> 8)]) ^ RT3[(unsigned char )X0];
#line 714
  RK += 4;
#line 714
  X0 = (((*(RK + 0) ^ RT0[(unsigned char )(Y0 >> 24)]) ^ RT1[(unsigned char )(Y3 >> 16)]) ^ RT2[(unsigned char )(Y2 >> 8)]) ^ RT3[(unsigned char )Y1];
#line 714
  X1 = (((*(RK + 1) ^ RT0[(unsigned char )(Y1 >> 24)]) ^ RT1[(unsigned char )(Y0 >> 16)]) ^ RT2[(unsigned char )(Y3 >> 8)]) ^ RT3[(unsigned char )Y2];
#line 714
  X2 = (((*(RK + 2) ^ RT0[(unsigned char )(Y2 >> 24)]) ^ RT1[(unsigned char )(Y1 >> 16)]) ^ RT2[(unsigned char )(Y0 >> 8)]) ^ RT3[(unsigned char )Y3];
#line 714
  X3 = (((*(RK + 3) ^ RT0[(unsigned char )(Y3 >> 24)]) ^ RT1[(unsigned char )(Y2 >> 16)]) ^ RT2[(unsigned char )(Y1 >> 8)]) ^ RT3[(unsigned char )Y0];
#line 715
  RK += 4;
#line 715
  Y0 = (((*(RK + 0) ^ RT0[(unsigned char )(X0 >> 24)]) ^ RT1[(unsigned char )(X3 >> 16)]) ^ RT2[(unsigned char )(X2 >> 8)]) ^ RT3[(unsigned char )X1];
#line 715
  Y1 = (((*(RK + 1) ^ RT0[(unsigned char )(X1 >> 24)]) ^ RT1[(unsigned char )(X0 >> 16)]) ^ RT2[(unsigned char )(X3 >> 8)]) ^ RT3[(unsigned char )X2];
#line 715
  Y2 = (((*(RK + 2) ^ RT0[(unsigned char )(X2 >> 24)]) ^ RT1[(unsigned char )(X1 >> 16)]) ^ RT2[(unsigned char )(X0 >> 8)]) ^ RT3[(unsigned char )X3];
#line 715
  Y3 = (((*(RK + 3) ^ RT0[(unsigned char )(X3 >> 24)]) ^ RT1[(unsigned char )(X2 >> 16)]) ^ RT2[(unsigned char )(X1 >> 8)]) ^ RT3[(unsigned char )X0];
#line 716
  RK += 4;
#line 716
  X0 = (((*(RK + 0) ^ RT0[(unsigned char )(Y0 >> 24)]) ^ RT1[(unsigned char )(Y3 >> 16)]) ^ RT2[(unsigned char )(Y2 >> 8)]) ^ RT3[(unsigned char )Y1];
#line 716
  X1 = (((*(RK + 1) ^ RT0[(unsigned char )(Y1 >> 24)]) ^ RT1[(unsigned char )(Y0 >> 16)]) ^ RT2[(unsigned char )(Y3 >> 8)]) ^ RT3[(unsigned char )Y2];
#line 716
  X2 = (((*(RK + 2) ^ RT0[(unsigned char )(Y2 >> 24)]) ^ RT1[(unsigned char )(Y1 >> 16)]) ^ RT2[(unsigned char )(Y0 >> 8)]) ^ RT3[(unsigned char )Y3];
#line 716
  X3 = (((*(RK + 3) ^ RT0[(unsigned char )(Y3 >> 24)]) ^ RT1[(unsigned char )(Y2 >> 16)]) ^ RT2[(unsigned char )(Y1 >> 8)]) ^ RT3[(unsigned char )Y0];
#line 717
  RK += 4;
#line 717
  Y0 = (((*(RK + 0) ^ RT0[(unsigned char )(X0 >> 24)]) ^ RT1[(unsigned char )(X3 >> 16)]) ^ RT2[(unsigned char )(X2 >> 8)]) ^ RT3[(unsigned char )X1];
#line 717
  Y1 = (((*(RK + 1) ^ RT0[(unsigned char )(X1 >> 24)]) ^ RT1[(unsigned char )(X0 >> 16)]) ^ RT2[(unsigned char )(X3 >> 8)]) ^ RT3[(unsigned char )X2];
#line 717
  Y2 = (((*(RK + 2) ^ RT0[(unsigned char )(X2 >> 24)]) ^ RT1[(unsigned char )(X1 >> 16)]) ^ RT2[(unsigned char )(X0 >> 8)]) ^ RT3[(unsigned char )X3];
#line 717
  Y3 = (((*(RK + 3) ^ RT0[(unsigned char )(X3 >> 24)]) ^ RT1[(unsigned char )(X2 >> 16)]) ^ RT2[(unsigned char )(X1 >> 8)]) ^ RT3[(unsigned char )X0];
#line 718
  RK += 4;
#line 718
  X0 = (((*(RK + 0) ^ RT0[(unsigned char )(Y0 >> 24)]) ^ RT1[(unsigned char )(Y3 >> 16)]) ^ RT2[(unsigned char )(Y2 >> 8)]) ^ RT3[(unsigned char )Y1];
#line 718
  X1 = (((*(RK + 1) ^ RT0[(unsigned char )(Y1 >> 24)]) ^ RT1[(unsigned char )(Y0 >> 16)]) ^ RT2[(unsigned char )(Y3 >> 8)]) ^ RT3[(unsigned char )Y2];
#line 718
  X2 = (((*(RK + 2) ^ RT0[(unsigned char )(Y2 >> 24)]) ^ RT1[(unsigned char )(Y1 >> 16)]) ^ RT2[(unsigned char )(Y0 >> 8)]) ^ RT3[(unsigned char )Y3];
#line 718
  X3 = (((*(RK + 3) ^ RT0[(unsigned char )(Y3 >> 24)]) ^ RT1[(unsigned char )(Y2 >> 16)]) ^ RT2[(unsigned char )(Y1 >> 8)]) ^ RT3[(unsigned char )Y0];
#line 719
  RK += 4;
#line 719
  Y0 = (((*(RK + 0) ^ RT0[(unsigned char )(X0 >> 24)]) ^ RT1[(unsigned char )(X3 >> 16)]) ^ RT2[(unsigned char )(X2 >> 8)]) ^ RT3[(unsigned char )X1];
#line 719
  Y1 = (((*(RK + 1) ^ RT0[(unsigned char )(X1 >> 24)]) ^ RT1[(unsigned char )(X0 >> 16)]) ^ RT2[(unsigned char )(X3 >> 8)]) ^ RT3[(unsigned char )X2];
#line 719
  Y2 = (((*(RK + 2) ^ RT0[(unsigned char )(X2 >> 24)]) ^ RT1[(unsigned char )(X1 >> 16)]) ^ RT2[(unsigned char )(X0 >> 8)]) ^ RT3[(unsigned char )X3];
#line 719
  Y3 = (((*(RK + 3) ^ RT0[(unsigned char )(X3 >> 24)]) ^ RT1[(unsigned char )(X2 >> 16)]) ^ RT2[(unsigned char )(X1 >> 8)]) ^ RT3[(unsigned char )X0];
#line 720
  RK += 4;
#line 720
  X0 = (((*(RK + 0) ^ RT0[(unsigned char )(Y0 >> 24)]) ^ RT1[(unsigned char )(Y3 >> 16)]) ^ RT2[(unsigned char )(Y2 >> 8)]) ^ RT3[(unsigned char )Y1];
#line 720
  X1 = (((*(RK + 1) ^ RT0[(unsigned char )(Y1 >> 24)]) ^ RT1[(unsigned char )(Y0 >> 16)]) ^ RT2[(unsigned char )(Y3 >> 8)]) ^ RT3[(unsigned char )Y2];
#line 720
  X2 = (((*(RK + 2) ^ RT0[(unsigned char )(Y2 >> 24)]) ^ RT1[(unsigned char )(Y1 >> 16)]) ^ RT2[(unsigned char )(Y0 >> 8)]) ^ RT3[(unsigned char )Y3];
#line 720
  X3 = (((*(RK + 3) ^ RT0[(unsigned char )(Y3 >> 24)]) ^ RT1[(unsigned char )(Y2 >> 16)]) ^ RT2[(unsigned char )(Y1 >> 8)]) ^ RT3[(unsigned char )Y0];
#line 721
  RK += 4;
#line 721
  Y0 = (((*(RK + 0) ^ RT0[(unsigned char )(X0 >> 24)]) ^ RT1[(unsigned char )(X3 >> 16)]) ^ RT2[(unsigned char )(X2 >> 8)]) ^ RT3[(unsigned char )X1];
#line 721
  Y1 = (((*(RK + 1) ^ RT0[(unsigned char )(X1 >> 24)]) ^ RT1[(unsigned char )(X0 >> 16)]) ^ RT2[(unsigned char )(X3 >> 8)]) ^ RT3[(unsigned char )X2];
#line 721
  Y2 = (((*(RK + 2) ^ RT0[(unsigned char )(X2 >> 24)]) ^ RT1[(unsigned char )(X1 >> 16)]) ^ RT2[(unsigned char )(X0 >> 8)]) ^ RT3[(unsigned char )X3];
#line 721
  Y3 = (((*(RK + 3) ^ RT0[(unsigned char )(X3 >> 24)]) ^ RT1[(unsigned char )(X2 >> 16)]) ^ RT2[(unsigned char )(X1 >> 8)]) ^ RT3[(unsigned char )X0];
#line 723
  if (ctx___0->nr > 10) {
#line 725
    RK += 4;
#line 725
    X0 = (((*(RK + 0) ^ RT0[(unsigned char )(Y0 >> 24)]) ^ RT1[(unsigned char )(Y3 >> 16)]) ^ RT2[(unsigned char )(Y2 >> 8)]) ^ RT3[(unsigned char )Y1];
#line 725
    X1 = (((*(RK + 1) ^ RT0[(unsigned char )(Y1 >> 24)]) ^ RT1[(unsigned char )(Y0 >> 16)]) ^ RT2[(unsigned char )(Y3 >> 8)]) ^ RT3[(unsigned char )Y2];
#line 725
    X2 = (((*(RK + 2) ^ RT0[(unsigned char )(Y2 >> 24)]) ^ RT1[(unsigned char )(Y1 >> 16)]) ^ RT2[(unsigned char )(Y0 >> 8)]) ^ RT3[(unsigned char )Y3];
#line 725
    X3 = (((*(RK + 3) ^ RT0[(unsigned char )(Y3 >> 24)]) ^ RT1[(unsigned char )(Y2 >> 16)]) ^ RT2[(unsigned char )(Y1 >> 8)]) ^ RT3[(unsigned char )Y0];
#line 726
    RK += 4;
#line 726
    Y0 = (((*(RK + 0) ^ RT0[(unsigned char )(X0 >> 24)]) ^ RT1[(unsigned char )(X3 >> 16)]) ^ RT2[(unsigned char )(X2 >> 8)]) ^ RT3[(unsigned char )X1];
#line 726
    Y1 = (((*(RK + 1) ^ RT0[(unsigned char )(X1 >> 24)]) ^ RT1[(unsigned char )(X0 >> 16)]) ^ RT2[(unsigned char )(X3 >> 8)]) ^ RT3[(unsigned char )X2];
#line 726
    Y2 = (((*(RK + 2) ^ RT0[(unsigned char )(X2 >> 24)]) ^ RT1[(unsigned char )(X1 >> 16)]) ^ RT2[(unsigned char )(X0 >> 8)]) ^ RT3[(unsigned char )X3];
#line 726
    Y3 = (((*(RK + 3) ^ RT0[(unsigned char )(X3 >> 24)]) ^ RT1[(unsigned char )(X2 >> 16)]) ^ RT2[(unsigned char )(X1 >> 8)]) ^ RT3[(unsigned char )X0];
  }
#line 729
  if (ctx___0->nr > 12) {
#line 731
    RK += 4;
#line 731
    X0 = (((*(RK + 0) ^ RT0[(unsigned char )(Y0 >> 24)]) ^ RT1[(unsigned char )(Y3 >> 16)]) ^ RT2[(unsigned char )(Y2 >> 8)]) ^ RT3[(unsigned char )Y1];
#line 731
    X1 = (((*(RK + 1) ^ RT0[(unsigned char )(Y1 >> 24)]) ^ RT1[(unsigned char )(Y0 >> 16)]) ^ RT2[(unsigned char )(Y3 >> 8)]) ^ RT3[(unsigned char )Y2];
#line 731
    X2 = (((*(RK + 2) ^ RT0[(unsigned char )(Y2 >> 24)]) ^ RT1[(unsigned char )(Y1 >> 16)]) ^ RT2[(unsigned char )(Y0 >> 8)]) ^ RT3[(unsigned char )Y3];
#line 731
    X3 = (((*(RK + 3) ^ RT0[(unsigned char )(Y3 >> 24)]) ^ RT1[(unsigned char )(Y2 >> 16)]) ^ RT2[(unsigned char )(Y1 >> 8)]) ^ RT3[(unsigned char )Y0];
#line 732
    RK += 4;
#line 732
    Y0 = (((*(RK + 0) ^ RT0[(unsigned char )(X0 >> 24)]) ^ RT1[(unsigned char )(X3 >> 16)]) ^ RT2[(unsigned char )(X2 >> 8)]) ^ RT3[(unsigned char )X1];
#line 732
    Y1 = (((*(RK + 1) ^ RT0[(unsigned char )(X1 >> 24)]) ^ RT1[(unsigned char )(X0 >> 16)]) ^ RT2[(unsigned char )(X3 >> 8)]) ^ RT3[(unsigned char )X2];
#line 732
    Y2 = (((*(RK + 2) ^ RT0[(unsigned char )(X2 >> 24)]) ^ RT1[(unsigned char )(X1 >> 16)]) ^ RT2[(unsigned char )(X0 >> 8)]) ^ RT3[(unsigned char )X3];
#line 732
    Y3 = (((*(RK + 3) ^ RT0[(unsigned char )(X3 >> 24)]) ^ RT1[(unsigned char )(X2 >> 16)]) ^ RT2[(unsigned char )(X1 >> 8)]) ^ RT3[(unsigned char )X0];
  }
#line 737
  RK += 4;
#line 739
  X0 = (((*(RK + 0) ^ (RSb[(unsigned char )(Y0 >> 24)] << 24)) ^ (RSb[(unsigned char )(Y3 >> 16)] << 16)) ^ (RSb[(unsigned char )(Y2 >> 8)] << 8)) ^ RSb[(unsigned char )Y1];
#line 744
  X1 = (((*(RK + 1) ^ (RSb[(unsigned char )(Y1 >> 24)] << 24)) ^ (RSb[(unsigned char )(Y0 >> 16)] << 16)) ^ (RSb[(unsigned char )(Y3 >> 8)] << 8)) ^ RSb[(unsigned char )Y2];
#line 749
  X2 = (((*(RK + 2) ^ (RSb[(unsigned char )(Y2 >> 24)] << 24)) ^ (RSb[(unsigned char )(Y1 >> 16)] << 16)) ^ (RSb[(unsigned char )(Y0 >> 8)] << 8)) ^ RSb[(unsigned char )Y3];
#line 754
  X3 = (((*(RK + 3) ^ (RSb[(unsigned char )(Y3 >> 24)] << 24)) ^ (RSb[(unsigned char )(Y2 >> 16)] << 16)) ^ (RSb[(unsigned char )(Y1 >> 8)] << 8)) ^ RSb[(unsigned char )Y0];
#line 759
  *(output + 0) = (unsigned char )(X0 >> 24);
#line 759
  *(output + 1) = (unsigned char )(X0 >> 16);
#line 759
  *(output + 2) = (unsigned char )(X0 >> 8);
#line 759
  *(output + 3) = (unsigned char )X0;
#line 760
  *(output + 4) = (unsigned char )(X1 >> 24);
#line 760
  *(output + 5) = (unsigned char )(X1 >> 16);
#line 760
  *(output + 6) = (unsigned char )(X1 >> 8);
#line 760
  *(output + 7) = (unsigned char )X1;
#line 761
  *(output + 8) = (unsigned char )(X2 >> 24);
#line 761
  *(output + 9) = (unsigned char )(X2 >> 16);
#line 761
  *(output + 10) = (unsigned char )(X2 >> 8);
#line 761
  *(output + 11) = (unsigned char )X2;
#line 762
  *(output + 12) = (unsigned char )(X3 >> 24);
#line 762
  *(output + 13) = (unsigned char )(X3 >> 16);
#line 762
  *(output + 14) = (unsigned char )(X3 >> 8);
#line 762
  *(output + 15) = (unsigned char )X3;
#line 763
  return;
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 779 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/progress.c"
void progress_create(prog_t *ctx___0 , int width ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  prog_t tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 53
  tmp___3 = malloc(sizeof(struct prog_struct ));
#line 53
  tmp___2 = (prog_t )tmp___3;
#line 53
  *ctx___0 = tmp___2;
  }
#line 53
  if (tmp___2) {
    {
#line 54
    (*ctx___0)->magic = -1412623820;
#line 55
    (*ctx___0)->maxbars = width - 2;
#line 56
    (*ctx___0)->bars = 0;
#line 57
    (*ctx___0)->bar = (char )'.';
#line 58
    tmp = isatty(1);
    }
#line 58
    if (tmp) {
#line 58
      tmp___0 = 0;
    } else {
#line 58
      tmp___0 = 1;
    }
#line 58
    (*ctx___0)->batch = tmp___0;
#line 59
    if ((*ctx___0)->batch) {
      {
#line 60
      printf((char const   */* __restrict  */)"|");
      }
    } else {
      {
#line 62
      printf((char const   */* __restrict  */)"|%*s|", (*ctx___0)->maxbars, "");
      }
      {
#line 63
      while (1) {
        while_continue: /* CIL Label */ ;
#line 63
        tmp___1 = width;
#line 63
        width --;
#line 63
        if (! (tmp___1 > 1)) {
#line 63
          goto while_break;
        }
        {
#line 64
        printf((char const   */* __restrict  */)"\b");
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 66
    fflush(stdout);
    }
  }
#line 68
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/progress.c"
void progress_destroy(prog_t ctx___0 ) 
{ 


  {
#line 73
  if (ctx___0) {
#line 74
    if (! ((unsigned int )ctx___0->magic == 2882343476U)) {
      {
#line 74
      __assert_fail("ctx->magic == 0xabcd1234", "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/progress.c",
                    74U, "progress_destroy");
      }
    }
    {
#line 75
    ctx___0->bar = (char )'x';
#line 76
    progress_update(ctx___0, 1.0);
#line 77
    ctx___0->magic = 0;
    }
#line 78
    if (ctx___0->batch) {
      {
#line 79
      printf((char const   */* __restrict  */)"|\n");
      }
    } else {
      {
#line 81
      printf((char const   */* __restrict  */)"\n");
      }
    }
    {
#line 82
    free((void *)ctx___0);
    }
  }
#line 84
  return;
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/progress.c"
void progress_update(prog_t ctx___0 , double complete ) 
{ 


  {
#line 89
  if (complete >= 0.0) {
#line 89
    if (! (complete <= 1.0)) {
      {
#line 89
      __assert_fail("complete >= 0.0 && complete <= 1.0", "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/progress.c",
                    89U, "progress_update");
      }
    }
  } else {
    {
#line 89
    __assert_fail("complete >= 0.0 && complete <= 1.0", "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/progress.c",
                  89U, "progress_update");
    }
  }
#line 90
  if (ctx___0) {
#line 91
    if (! ((unsigned int )ctx___0->magic == 2882343476U)) {
      {
#line 91
      __assert_fail("ctx->magic == 0xabcd1234", "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/progress.c",
                    91U, "progress_update");
      }
    }
    {
#line 92
    while (1) {
      while_continue: /* CIL Label */ ;
#line 92
      if (! ((double )ctx___0->bars < (double )ctx___0->maxbars * complete)) {
#line 92
        goto while_break;
      }
      {
#line 93
      printf((char const   */* __restrict  */)"%c", (int )ctx___0->bar);
#line 94
      fflush(stdout);
#line 95
      (ctx___0->bars) ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 98
  return;
}
}
#line 381 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand_r)(unsigned int *__seed ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/genrand.c"
static _Bool no_hwrand  =    (_Bool)0;
#line 54 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/genrand.c"
static _Bool (*gen_hwrand)(unsigned char * , int  )  ;
#line 56 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/genrand.c"
static aes_context ctx  ;
#line 57 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/genrand.c"
static unsigned char ctr[16]  ;
#line 60 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/genrand.c"
static unsigned int seed  ;
#line 73 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/genrand.c"
static void incr128(unsigned char *val ) 
{ 
  unsigned long long *t ;

  {
#line 76
  t = (unsigned long long *)val;
#line 78
  if (! (sizeof(unsigned long long ) == 8UL)) {
    {
#line 78
    __assert_fail("sizeof(unsigned long long) == 8", "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/genrand.c",
                  78U, "incr128");
    }
  }
#line 80
  (*(t + 0)) ++;
#line 80
  if (*(t + 0) == 0ULL) {
#line 81
    (*(t + 1)) ++;
  }
#line 82
  return;
}
}
#line 89
static int genrandraw(unsigned char *buf , int buflen ) ;
#line 89 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/genrand.c"
static int fd  =    -1;
#line 86 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/genrand.c"
static int genrandraw(unsigned char *buf , int buflen ) 
{ 
  int n ;
  int tmp ;
  int *tmp___0 ;

  {
#line 92
  if (fd < 0) {
    {
#line 93
    fd = open("/dev/urandom", 0);
    }
#line 96
    if (fd < 0) {
#line 98
      n = 0;
      {
#line 98
      while (1) {
        while_continue: /* CIL Label */ ;
#line 98
        if (! (n < buflen)) {
#line 98
          goto while_break;
        }
        {
#line 99
        tmp = rand_r(& seed);
#line 99
        *(buf + n) = (unsigned char )tmp;
#line 98
        n ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 109
      return;
    }
  }
  {
#line 113
  n = read_all(fd, buf, buflen);
  }
#line 114
  if (n < 0) {
#line 115
    goto error;
  }
#line 116
  if (n == 0) {
    {
#line 117
    tmp___0 = __errno_location();
#line 117
    *tmp___0 = 5;
    }
#line 118
    goto error;
  }
#line 120
  return (0);
  error: 
#line 122
  return (-1);
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/genrand.c"
int churnrand(void) 
{ 
  unsigned char key[16] ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 132
  tmp = genrandraw(ctr, 16);
  }
#line 132
  if (tmp < 0) {
#line 133
    goto error;
  }
  {
#line 134
  tmp___0 = genrandraw(key, 16);
  }
#line 134
  if (tmp___0 < 0) {
#line 135
    goto error;
  }
  {
#line 136
  tmp___2 = aes_set_key(& ctx, key, 128);
  }
#line 136
  if (tmp___2 != 0) {
    {
#line 137
    tmp___1 = __errno_location();
#line 137
    *tmp___1 = 22;
    }
#line 138
    goto error;
  }
#line 140
  return (0);
  error: 
#line 142
  return (-1);
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/genrand.c"
int initrand(void) 
{ 
  struct timeval tv ;
  int tmp ;
  int tmp___0 ;

  {
#line 152
  if (! no_hwrand) {
    {
#line 153
    gen_hwrand = init_hwrand();
    }
  }
  {
#line 157
  tmp = gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
  }
#line 157
  if (tmp < 0) {
#line 158
    goto error;
  }
  {
#line 160
  seed = (unsigned int )tv.tv_usec;
#line 165
  tmp___0 = churnrand();
  }
#line 165
  if (tmp___0 < 0) {
#line 166
    goto error;
  }
#line 167
  return (0);
  error: 
#line 169
  return (-1);
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/genrand.c"
void genrand(unsigned char *buf , int buflen ) 
{ 
  int i ;
  unsigned char out[16] ;
  int cpylen ;
  _Bool hwok ;
  _Bool tmp ;

  {
#line 179
  cpylen = 16;
#line 181
  if (gen_hwrand) {
    {
#line 182
    tmp = (*gen_hwrand)(buf, buflen);
#line 182
    hwok = tmp;
    }
#line 183
    if (hwok) {
#line 184
      return;
    }
  }
#line 187
  i = 0;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! (i < buflen)) {
#line 187
      goto while_break;
    }
    {
#line 188
    aes_encrypt(& ctx, (unsigned char *)(ctr), (unsigned char *)(out));
#line 189
    incr128(ctr);
    }
#line 190
    if (cpylen > buflen - i) {
#line 191
      cpylen = buflen - i;
    }
    {
#line 192
    memcpy((void */* __restrict  */)(buf + i), (void const   */* __restrict  */)(out),
           (size_t )cpylen);
#line 187
    i += cpylen;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 194
  if (! (i == buflen)) {
    {
#line 194
    __assert_fail("i == buflen", "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/genrand.c",
                  194U, "genrand");
    }
  }
#line 195
  return;
}
}
#line 200 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/genrand.c"
void disable_hwrand(void) 
{ 


  {
#line 203
  no_hwrand = (_Bool)1;
#line 204
  return;
}
}
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/pattern.h"
sequence_t const   *seq_lookup_byindex(int i ) ;
#line 53
int const   seq_count(void) ;
#line 54
void seq2str(sequence_t const   *sp , char *buf , int len ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/pattern.c"
static struct __anonstruct_sequence_t_73  const  dirent_seq  =    {(char *)"dirent", (char *)"dirent", 6, {{(ptype_t )0, 1, {50}}, {(ptype_t )0,
                                                                     1, {77}}, {(ptype_t )0,
                                                                                1,
                                                                                {50}},
                                            {(ptype_t )0, 1, {77}}, {(ptype_t )0,
                                                                     1, {50}}, {(ptype_t )0,
                                                                                1,
                                                                                {77}}}};
#line 60 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/pattern.c"
static struct __anonstruct_sequence_t_73  const  old_seq  =    {(char *)"old", (char *)"pre v1.7 scrub", 5, {{(ptype_t )0, 1, {0}}, {(ptype_t )0,
                                                                         1, {255}},
                                                 {(ptype_t )0, 1, {170}}, {(ptype_t )1,
                                                                           0, {0}},
                                                 {(ptype_t )2, 1, {85}}}};
#line 70 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/pattern.c"
static struct __anonstruct_sequence_t_73  const  fastold_seq  =    {(char *)"fastold", (char *)"pre v1.7 scrub (skip random)", 4, {{(ptype_t )0, 1,
                                                                    {0}}, {(ptype_t )0,
                                                                           1, {255}},
                                                                   {(ptype_t )0, 1,
                                                                    {170}}, {(ptype_t )2,
                                                                             1, {85}}}};
#line 79 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/pattern.c"
static struct __anonstruct_sequence_t_73  const  nnsa_seq  =    {(char *)"nnsa", (char *)"NNSA NAP-14.1-C", 3, {{(ptype_t )1, 0, {0}}, {(ptype_t )1,
                                                                           0, {0}},
                                                   {(ptype_t )2, 1, {0}}}};
#line 87 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/pattern.c"
static struct __anonstruct_sequence_t_73  const  dod_seq  =    {(char *)"dod", (char *)"DoD 5220.22-M", 3, {{(ptype_t )1, 0, {0}}, {(ptype_t )0,
                                                                        1, {0}}, {(ptype_t )2,
                                                                                  1,
                                                                                  {255}}}};
#line 95 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/pattern.c"
static struct __anonstruct_sequence_t_73  const  bsi_seq  =    {(char *)"bsi", (char *)"BSI", 9, {{(ptype_t )0, 1, {255}}, {(ptype_t )0, 1, {254}},
                                      {(ptype_t )0, 1, {253}}, {(ptype_t )0, 1, {251}},
                                      {(ptype_t )0, 1, {247}}, {(ptype_t )0, 1, {239}},
                                      {(ptype_t )0, 1, {223}}, {(ptype_t )0, 1, {191}},
                                      {(ptype_t )0, 1, {127}}}};
#line 109 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/pattern.c"
static struct __anonstruct_sequence_t_73  const  gutmann_seq  =    {(char *)"gutmann", (char *)"Gutmann", 35, {{(ptype_t )1, 0, {0}}, {(ptype_t )1,
                                                                       0, {0}}, {(ptype_t )1,
                                                                                 0,
                                                                                 {0}},
                                               {(ptype_t )1, 0, {0}}, {(ptype_t )0,
                                                                       1, {85}}, {(ptype_t )0,
                                                                                  1,
                                                                                  {170}},
                                               {(ptype_t )0, 3, {146, 73, 36}}, {(ptype_t )0,
                                                                                 3,
                                                                                 {73,
                                                                                  36,
                                                                                  146}},
                                               {(ptype_t )0, 3, {36, 146, 73}}, {(ptype_t )0,
                                                                                 1,
                                                                                 {0}},
                                               {(ptype_t )0, 1, {17}}, {(ptype_t )0,
                                                                        1, {34}},
                                               {(ptype_t )0, 1, {51}}, {(ptype_t )0,
                                                                        1, {68}},
                                               {(ptype_t )0, 1, {85}}, {(ptype_t )0,
                                                                        1, {102}},
                                               {(ptype_t )0, 1, {119}}, {(ptype_t )0,
                                                                         1, {136}},
                                               {(ptype_t )0, 1, {153}}, {(ptype_t )0,
                                                                         1, {170}},
                                               {(ptype_t )0, 1, {187}}, {(ptype_t )0,
                                                                         1, {204}},
                                               {(ptype_t )0, 1, {221}}, {(ptype_t )0,
                                                                         1, {238}},
                                               {(ptype_t )0, 1, {255}}, {(ptype_t )0,
                                                                         3, {146,
                                                                             73, 36}},
                                               {(ptype_t )0, 3, {73, 36, 146}}, {(ptype_t )0,
                                                                                 3,
                                                                                 {36,
                                                                                  146,
                                                                                  73}},
                                               {(ptype_t )0, 3, {109, 182, 219}},
                                               {(ptype_t )0, 3, {182, 219, 109}},
                                               {(ptype_t )0, 3, {219, 109, 182}},
                                               {(ptype_t )1, 0, {0}}, {(ptype_t )1,
                                                                       0, {0}}, {(ptype_t )1,
                                                                                 0,
                                                                                 {0}},
                                               {(ptype_t )1, 0, {0}}}};
#line 149 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/pattern.c"
static struct __anonstruct_sequence_t_73  const  random_seq  =    {(char *)"random", (char *)"One Random Pass", 1, {{(ptype_t )1, 0, {0}}}};
#line 155 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/pattern.c"
static struct __anonstruct_sequence_t_73  const  random2_seq  =    {(char *)"random2", (char *)"Two Random Passes", 2, {{(ptype_t )1, 0, {0}}, {(ptype_t )1,
                                                                                0,
                                                                                {0}}}};
#line 162 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/pattern.c"
static struct __anonstruct_sequence_t_73  const  schneier_seq  =    {(char *)"schneier", (char *)"Bruce Schneier Algorithm", 7, {{(ptype_t )0, 1, {0}},
                                                                {(ptype_t )0, 1, {255}},
                                                                {(ptype_t )1, 0, {0}},
                                                                {(ptype_t )1, 0, {0}},
                                                                {(ptype_t )1, 0, {0}},
                                                                {(ptype_t )1, 0, {0}},
                                                                {(ptype_t )1, 0, {0}}}};
#line 174 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/pattern.c"
static struct __anonstruct_sequence_t_73  const  pfitzner7_seq  =    {(char *)"pfitzner7", (char *)"Roy Pfitzner 7-random-pass method", 7, {{(ptype_t )1,
                                                                           0, {0}},
                                                                          {(ptype_t )1,
                                                                           0, {0}},
                                                                          {(ptype_t )1,
                                                                           0, {0}},
                                                                          {(ptype_t )1,
                                                                           0, {0}},
                                                                          {(ptype_t )1,
                                                                           0, {0}},
                                                                          {(ptype_t )1,
                                                                           0, {0}},
                                                                          {(ptype_t )1,
                                                                           0, {0}}}};
#line 186 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/pattern.c"
static struct __anonstruct_sequence_t_73  const  pfitzner33_seq  =    {(char *)"pfitzner33", (char *)"Roy Pfitzner 33-random-pass method", 33, {{(ptype_t )1,
                                                                              0, {0}},
                                                                             {(ptype_t )1,
                                                                              0, {0}},
                                                                             {(ptype_t )1,
                                                                              0, {0}},
                                                                             {(ptype_t )1,
                                                                              0, {0}},
                                                                             {(ptype_t )1,
                                                                              0, {0}},
                                                                             {(ptype_t )1,
                                                                              0, {0}},
                                                                             {(ptype_t )1,
                                                                              0, {0}},
                                                                             {(ptype_t )1,
                                                                              0, {0}},
                                                                             {(ptype_t )1,
                                                                              0, {0}},
                                                                             {(ptype_t )1,
                                                                              0, {0}},
                                                                             {(ptype_t )1,
                                                                              0, {0}},
                                                                             {(ptype_t )1,
                                                                              0, {0}},
                                                                             {(ptype_t )1,
                                                                              0, {0}},
                                                                             {(ptype_t )1,
                                                                              0, {0}},
                                                                             {(ptype_t )1,
                                                                              0, {0}},
                                                                             {(ptype_t )1,
                                                                              0, {0}},
                                                                             {(ptype_t )1,
                                                                              0, {0}},
                                                                             {(ptype_t )1,
                                                                              0, {0}},
                                                                             {(ptype_t )1,
                                                                              0, {0}},
                                                                             {(ptype_t )1,
                                                                              0, {0}},
                                                                             {(ptype_t )1,
                                                                              0, {0}},
                                                                             {(ptype_t )1,
                                                                              0, {0}},
                                                                             {(ptype_t )1,
                                                                              0, {0}},
                                                                             {(ptype_t )1,
                                                                              0, {0}},
                                                                             {(ptype_t )1,
                                                                              0, {0}},
                                                                             {(ptype_t )1,
                                                                              0, {0}},
                                                                             {(ptype_t )1,
                                                                              0, {0}},
                                                                             {(ptype_t )1,
                                                                              0, {0}},
                                                                             {(ptype_t )1,
                                                                              0, {0}},
                                                                             {(ptype_t )1,
                                                                              0, {0}},
                                                                             {(ptype_t )1,
                                                                              0, {0}},
                                                                             {(ptype_t )1,
                                                                              0, {0}},
                                                                             {(ptype_t )1,
                                                                              0, {0}}}};
#line 224 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/pattern.c"
static struct __anonstruct_sequence_t_73  const  usarmy_seq  =    {(char *)"usarmy", (char *)"US Army AR380-19", 3, {{(ptype_t )0, 1, {0}}, {(ptype_t )0,
                                                                              1, {255}},
                                                      {(ptype_t )1, 0, {0}}}};
#line 232 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/pattern.c"
static struct __anonstruct_sequence_t_73  const  fillzero_seq  =    {(char *)"fillzero", (char *)"Quick Fill with 0x00", 1, {{(ptype_t )0, 1, {0}}}};
#line 238 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/pattern.c"
static struct __anonstruct_sequence_t_73  const  fillff_seq  =    {(char *)"fillff", (char *)"Quick Fill with 0xff", 1, {{(ptype_t )0, 1, {255}}}};
#line 244 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/pattern.c"
static struct __anonstruct_sequence_t_73  const  custom_seq  =    {(char *)"custom", (char *)"custom=\"string\" 16b max, use escapes \\xnn, \\nnn, \\\\",
    1, {{0U, 0, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}, {0U, 0, {0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0}},
        {0U, 0, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}, {0U, 0, {0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0}},
        {0U, 0, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}, {0U, 0, {0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0}},
        {0U, 0, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}, {0U, 0, {0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0}},
        {0U, 0, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}, {0U, 0, {0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0}},
        {0U, 0, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}, {0U, 0, {0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0}},
        {0U, 0, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}, {0U, 0, {0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0}},
        {0U, 0, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}, {0U, 0, {0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0}},
        {0U, 0, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}, {0U, 0, {0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0}},
        {0U, 0, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}, {0U, 0, {0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0}},
        {0U, 0, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}, {0U, 0, {0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0}},
        {0U, 0, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}, {0U, 0, {0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0}},
        {0U, 0, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}, {0U, 0, {0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0}},
        {0U, 0, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}, {0U, 0, {0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0}},
        {0U, 0, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}, {0U, 0, {0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0}},
        {0U, 0, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}, {0U, 0, {0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0}},
        {0U, 0, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}, {0U, 0, {0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0}},
        {0U, 0, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}}};
#line 249 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/pattern.c"
static sequence_t const   *sequences[15]  = 
#line 249
  {      & nnsa_seq,      & dod_seq,      & bsi_seq,      & usarmy_seq, 
        & random_seq,      & random2_seq,      & schneier_seq,      & pfitzner7_seq, 
        & pfitzner33_seq,      & gutmann_seq,      & fastold_seq,      & old_seq, 
        & dirent_seq,      & fillzero_seq,      & fillff_seq};
#line 267 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/pattern.c"
int const   seq_count(void) 
{ 


  {
#line 270
  return ((int const   )(sizeof(sequences) / sizeof(sequences[0])));
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/pattern.c"
static int strtomem(int *data , int len , char *s ) 
{ 
  char tmp[16] ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  unsigned long tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;

  {
#line 285
  i = 0;
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 287
    if (*s) {
#line 287
      if (! (i < len)) {
#line 287
        goto while_break;
      }
    } else {
#line 287
      goto while_break;
    }
#line 288
    if ((int )*s == 92) {
#line 288
      if ((int )*(s + 1) == 92) {
#line 289
        tmp___0 = i;
#line 289
        i ++;
#line 289
        *(data + tmp___0) = (int )*s;
#line 290
        s += 2;
#line 291
        goto while_continue;
      }
    }
#line 293
    if ((int )*s == 92) {
      {
#line 293
      tmp___3 = strlen((char const   *)s);
      }
#line 293
      if (tmp___3 >= 4UL) {
#line 293
        if ((int )*(s + 1) == 120) {
#line 293
          if ((int )*(s + 2) >= 48) {
#line 293
            if ((int )*(s + 2) <= 57) {
#line 293
              goto _L___2;
            } else {
#line 293
              goto _L___4;
            }
          } else
          _L___4: /* CIL Label */ 
#line 293
          if ((int )*(s + 2) >= 97) {
#line 293
            if ((int )*(s + 2) <= 102) {
#line 293
              goto _L___2;
            } else {
#line 293
              goto _L___3;
            }
          } else
          _L___3: /* CIL Label */ 
#line 293
          if ((int )*(s + 2) >= 65) {
#line 293
            if ((int )*(s + 2) <= 70) {
              _L___2: /* CIL Label */ 
#line 293
              if ((int )*(s + 3) >= 48) {
#line 293
                if ((int )*(s + 3) <= 57) {
#line 293
                  goto _L;
                } else {
#line 293
                  goto _L___1;
                }
              } else
              _L___1: /* CIL Label */ 
#line 293
              if ((int )*(s + 3) >= 97) {
#line 293
                if ((int )*(s + 3) <= 102) {
#line 293
                  goto _L;
                } else {
#line 293
                  goto _L___0;
                }
              } else
              _L___0: /* CIL Label */ 
#line 293
              if ((int )*(s + 3) >= 65) {
#line 293
                if ((int )*(s + 3) <= 70) {
                  _L: /* CIL Label */ 
                  {
#line 295
                  memcpy((void */* __restrict  */)(tmp), (void const   */* __restrict  */)(s + 2),
                         (size_t )2);
#line 296
                  tmp[2] = (char )'\000';
#line 297
                  tmp___1 = i;
#line 297
                  i ++;
#line 297
                  tmp___2 = strtoul((char const   */* __restrict  */)(tmp), (char **/* __restrict  */)((void *)0),
                                    16);
#line 297
                  *(data + tmp___1) = (int )tmp___2;
#line 298
                  s += 4;
                  }
#line 299
                  goto while_continue;
                }
              }
            }
          }
        }
      }
    }
#line 301
    if ((int )*s == 92) {
      {
#line 301
      tmp___6 = strlen((char const   *)s);
      }
#line 301
      if (tmp___6 >= 4UL) {
#line 301
        if ((int )*(s + 1) >= 48) {
#line 301
          if ((int )*(s + 1) <= 55) {
#line 301
            if ((int )*(s + 2) >= 48) {
#line 301
              if ((int )*(s + 2) <= 55) {
#line 301
                if ((int )*(s + 3) >= 48) {
#line 301
                  if ((int )*(s + 3) <= 55) {
                    {
#line 303
                    memcpy((void */* __restrict  */)(tmp), (void const   */* __restrict  */)(s + 1),
                           (size_t )3);
#line 304
                    tmp[3] = (char )'\000';
#line 305
                    tmp___4 = i;
#line 305
                    i ++;
#line 305
                    tmp___5 = strtoul((char const   */* __restrict  */)(tmp), (char **/* __restrict  */)((void *)0),
                                      8);
#line 305
                    *(data + tmp___4) = (int )tmp___5;
#line 306
                    s += 4;
                    }
#line 307
                    goto while_continue;
                  }
                }
              }
            }
          }
        }
      }
    }
#line 309
    tmp___7 = i;
#line 309
    i ++;
#line 309
    tmp___8 = s;
#line 309
    s ++;
#line 309
    *(data + tmp___7) = (int )*tmp___8;
  }
  while_break: /* CIL Label */ ;
  }
#line 311
  if (*s) {
#line 311
    tmp___9 = -1;
  } else {
#line 311
    tmp___9 = i;
  }
#line 311
  return (tmp___9);
}
}
#line 314 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/pattern.c"
void seq_destroy(sequence_t *sp ) 
{ 


  {
#line 317
  if (sp->key) {
    {
#line 318
    free((void *)sp->key);
    }
  }
#line 319
  if (sp->desc) {
    {
#line 320
    free((void *)sp->desc);
    }
  }
  {
#line 321
  free((void *)sp);
  }
#line 322
  return;
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/pattern.c"
sequence_t *seq_create(char *key , char *desc , char *s ) 
{ 
  sequence_t *sp ;
  int len ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 327
  sp = (sequence_t *)((void *)0);
#line 330
  tmp = malloc(sizeof(*sp));
#line 330
  sp = (sequence_t *)tmp;
  }
#line 330
  if (! sp) {
#line 331
    goto nomem;
  }
  {
#line 332
  memset((void *)sp, 0, sizeof(*sp));
#line 333
  tmp___0 = strdup((char const   *)key);
#line 333
  sp->key = tmp___0;
  }
#line 333
  if (! tmp___0) {
#line 334
    goto nomem;
  }
  {
#line 335
  tmp___1 = strdup((char const   *)desc);
#line 335
  sp->desc = tmp___1;
  }
#line 335
  if (! tmp___1) {
#line 336
    goto nomem;
  }
  {
#line 337
  sp->len = 1;
#line 338
  len = strtomem(sp->pat[0].pat, 16, s);
  }
#line 339
  if (len < 0) {
    {
#line 340
    tmp___2 = __errno_location();
#line 340
    *tmp___2 = 22;
    }
#line 341
    goto error;
  }
#line 343
  sp->pat[0].len = len;
#line 344
  return (sp);
  nomem: 
  {
#line 346
  tmp___3 = __errno_location();
#line 346
  *tmp___3 = 12;
  }
  error: 
#line 348
  if (sp) {
    {
#line 349
    seq_destroy(sp);
    }
  }
#line 350
  return ((sequence_t *)((void *)0));
}
}
#line 353 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/pattern.c"
sequence_t const   *seq_lookup(char *key ) 
{ 
  int len ;
  int tmp ;
  sequence_t const   *seq ;
  int i ;
  int tmp___0 ;

  {
  {
#line 356
  tmp = (int )seq_count();
#line 356
  len = (int )tmp;
#line 357
  seq = (sequence_t const   *)((void *)0);
#line 360
  i = 0;
  }
  {
#line 360
  while (1) {
    while_continue: /* CIL Label */ ;
#line 360
    if (! (i < len)) {
#line 360
      goto while_break;
    }
    {
#line 361
    tmp___0 = strcmp((char const   *)(sequences[i])->key, (char const   *)key);
    }
#line 361
    if (! tmp___0) {
#line 362
      seq = sequences[i];
#line 363
      goto while_break;
    }
#line 360
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 366
  return (seq);
}
}
#line 369 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/pattern.c"
sequence_t const   *seq_lookup_byindex(int i ) 
{ 
  int tmp ;

  {
#line 372
  if (i >= 0) {
    {
#line 372
    tmp = (int )seq_count();
    }
#line 372
    if (! (i < (int )tmp)) {
      {
#line 372
      __assert_fail("i >= 0 && i < seq_count()", "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/pattern.c",
                    372U, "seq_lookup_byindex");
      }
    }
  } else {
    {
#line 372
    __assert_fail("i >= 0 && i < seq_count()", "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/pattern.c",
                  372U, "seq_lookup_byindex");
    }
  }
#line 373
  return (sequences[i]);
}
}
#line 376 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/pattern.c"
void memset_pat(void *s , pattern_t p , size_t n ) 
{ 
  int i ;
  char *sp ;

  {
#line 380
  sp = (char *)s;
#line 382
  i = 0;
  {
#line 382
  while (1) {
    while_continue: /* CIL Label */ ;
#line 382
    if (! ((size_t )i < n)) {
#line 382
      goto while_break;
    }
#line 383
    *(sp + i) = (char )p.pat[i % p.len];
#line 382
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 384
  return;
}
}
#line 389 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/pattern.c"
static char str[35]  ;
#line 386 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/pattern.c"
char *pat2str(pattern_t p ) 
{ 
  int i ;
  int len ;

  {
#line 391
  len = p.len;
#line 393
  if (len > 4) {
#line 394
    len = 4;
  }
  {
#line 396
  if ((unsigned int )p.ptype == 1U) {
#line 396
    goto case_1;
  }
#line 400
  if ((unsigned int )p.ptype == 0U) {
#line 400
    goto case_0;
  }
#line 400
  if ((unsigned int )p.ptype == 2U) {
#line 400
    goto case_0;
  }
#line 395
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 397
  snprintf((char */* __restrict  */)(str), sizeof(str), (char const   */* __restrict  */)"random");
  }
#line 398
  goto switch_break;
  case_0: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 401
  snprintf((char */* __restrict  */)(str), sizeof(str), (char const   */* __restrict  */)"0x");
#line 402
  i = 0;
  }
  {
#line 402
  while (1) {
    while_continue: /* CIL Label */ ;
#line 402
    if (! (i < len)) {
#line 402
      goto while_break;
    }
    {
#line 403
    snprintf((char */* __restrict  */)((str + 2 * i) + 2), (sizeof(str) - (unsigned long )(2 * i)) - 2UL,
             (char const   */* __restrict  */)"%.2x", p.pat[i]);
#line 402
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 404
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 406
  return (str);
}
}
#line 409 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/pattern.c"
void seq2str(sequence_t const   *sp , char *buf , int len ) 
{ 


  {
  {
#line 412
  snprintf((char */* __restrict  */)buf, (size_t )len, (char const   */* __restrict  */)"  %-10.10s %4.d-pass   %s",
           sp->key, sp->len, sp->desc);
  }
#line 414
  return;
}
}
#line 416 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/pattern.c"
void seq_list(void) 
{ 
  int len ;
  int tmp ;
  char buf[80] ;
  int i ;

  {
  {
#line 419
  tmp = (int )seq_count();
#line 419
  len = (int )tmp;
#line 423
  i = 0;
  }
  {
#line 423
  while (1) {
    while_continue: /* CIL Label */ ;
#line 423
    if (! (i < len)) {
#line 423
      goto while_break;
    }
    {
#line 424
    seq2str(sequences[i], buf, (int )sizeof(buf));
#line 425
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            buf);
#line 423
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 427
  seq2str(& custom_seq, buf, (int )sizeof(buf));
#line 428
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          buf);
  }
#line 429
  return;
}
}
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 81 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) uname)(struct utsname *__name ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/getsize.c"
int getsize(char *path , off_t *sizep ) 
{ 
  struct utsname ut ;
  unsigned long long numbytes ;
  int valid_blkgetsize64 ;
  int fd___0 ;
  int tmp ;
  int tmp___0 ;
  unsigned long numblocks ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 58
  valid_blkgetsize64 = 1;
#line 59
  fd___0 = -1;
#line 61
  fd___0 = open((char const   *)path, 0);
  }
#line 61
  if (fd___0 < 0) {
#line 62
    goto error;
  }
  {
#line 65
  tmp = uname(& ut);
  }
#line 65
  if (tmp == 0) {
#line 65
    if ((int )ut.release[0] == 50) {
#line 65
      if ((int )ut.release[1] == 46) {
#line 65
        if ((int )ut.release[2] < 54) {
#line 65
          if ((int )ut.release[3] == 46) {
#line 68
            valid_blkgetsize64 = 0;
          }
        }
      }
    }
  }
#line 69
  if (valid_blkgetsize64) {
    {
#line 70
    tmp___0 = ioctl(fd___0, (unsigned long )(((2U << 30) | (unsigned int )(18 << 8)) | 114U) | (sizeof(size_t ) << 16),
                    & numbytes);
    }
#line 70
    if (tmp___0 < 0) {
#line 71
      goto error;
    }
  } else {
    {
#line 75
    tmp___1 = ioctl(fd___0, (unsigned long )((unsigned int )(18 << 8) | 96U), & numblocks);
    }
#line 75
    if (tmp___1 < 0) {
#line 76
      goto error;
    }
#line 77
    numbytes = (unsigned long long )((off_t )numblocks * 512L);
  }
  {
#line 80
  tmp___2 = close(fd___0);
  }
#line 80
  if (tmp___2 < 0) {
#line 81
    goto error;
  }
#line 82
  *sizep = (off_t )numbytes;
#line 83
  return (0);
  error: 
#line 85
  if (fd___0 != -1) {
    {
#line 86
    close(fd___0);
    }
  }
#line 87
  return (-1);
}
}
#line 242 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/getsize.c"
void size2str(char *str___0 , int len , off_t size ) 
{ 
  off_t eb ;
  off_t pb ;
  off_t tb ;
  off_t gb ;
  off_t mb ;
  off_t kb ;
  off_t num ;
  char *unit ;

  {
#line 245
  eb = size >> 60;
#line 246
  pb = size >> 50;
#line 247
  tb = size >> 40;
#line 248
  gb = size >> 30;
#line 249
  mb = size >> 20;
#line 250
  kb = size >> 10;
#line 251
  num = (off_t )0;
#line 252
  unit = (char *)((void *)0);
#line 254
  if (eb >= 1L) {
#line 255
    num = eb;
#line 255
    unit = (char *)"EB";
  } else
#line 256
  if (pb >= 10L) {
#line 257
    num = pb;
#line 257
    unit = (char *)"PB";
  } else
#line 258
  if (tb >= 10L) {
#line 259
    num = tb;
#line 259
    unit = (char *)"TB";
  } else
#line 260
  if (gb >= 10L) {
#line 261
    num = gb;
#line 261
    unit = (char *)"GB";
  } else
#line 262
  if (mb >= 10L) {
#line 263
    num = mb;
#line 263
    unit = (char *)"MB";
  } else
#line 264
  if (kb >= 10L) {
#line 265
    num = kb;
#line 265
    unit = (char *)"KB";
  }
#line 268
  if (unit) {
    {
#line 269
    snprintf((char */* __restrict  */)str___0, (size_t )len, (char const   */* __restrict  */)"%lld bytes (~%lld%s)",
             (long long )size, (long long )num, unit);
    }
  } else {
    {
#line 272
    snprintf((char */* __restrict  */)str___0, (size_t )len, (char const   */* __restrict  */)"%lld bytes",
             (long long )size);
    }
  }
#line 273
  return;
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/getsize.c"
off_t str2size(char *str___0 ) 
{ 
  char *endptr ;
  unsigned long long size ;
  int shift ;
  int tmp ;

  {
  {
#line 280
  shift = 0;
#line 282
  tmp = sscanf((char const   */* __restrict  */)str___0, (char const   */* __restrict  */)"%llu",
               & size);
  }
#line 282
  if (tmp != 1) {
#line 283
    goto err;
  }
#line 284
  endptr = str___0;
  {
#line 284
  while (1) {
    while_continue: /* CIL Label */ ;
#line 284
    if (! *endptr) {
#line 284
      goto while_break;
    }
#line 285
    if ((int )*endptr < 48) {
#line 286
      goto while_break;
    } else
#line 285
    if ((int )*endptr > 57) {
#line 286
      goto while_break;
    }
#line 284
    endptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 287
  if (endptr) {
    {
#line 290
    if ((int )*endptr == 107) {
#line 290
      goto case_107;
    }
#line 290
    if ((int )*endptr == 75) {
#line 290
      goto case_107;
    }
#line 294
    if ((int )*endptr == 109) {
#line 294
      goto case_109;
    }
#line 294
    if ((int )*endptr == 77) {
#line 294
      goto case_109;
    }
#line 298
    if ((int )*endptr == 103) {
#line 298
      goto case_103;
    }
#line 298
    if ((int )*endptr == 71) {
#line 298
      goto case_103;
    }
#line 302
    if ((int )*endptr == 116) {
#line 302
      goto case_116;
    }
#line 302
    if ((int )*endptr == 84) {
#line 302
      goto case_116;
    }
#line 306
    if ((int )*endptr == 112) {
#line 306
      goto case_112;
    }
#line 306
    if ((int )*endptr == 80) {
#line 306
      goto case_112;
    }
#line 310
    if ((int )*endptr == 101) {
#line 310
      goto case_101;
    }
#line 310
    if ((int )*endptr == 69) {
#line 310
      goto case_101;
    }
#line 313
    if ((int )*endptr == 0) {
#line 313
      goto case_0;
    }
#line 315
    goto switch_default;
    case_107: /* CIL Label */ 
    case_75: /* CIL Label */ 
#line 291
    shift = 10;
#line 292
    goto switch_break;
    case_109: /* CIL Label */ 
    case_77: /* CIL Label */ 
#line 295
    shift = 20;
#line 296
    goto switch_break;
    case_103: /* CIL Label */ 
    case_71: /* CIL Label */ 
#line 299
    shift = 30;
#line 300
    goto switch_break;
    case_116: /* CIL Label */ 
    case_84: /* CIL Label */ 
#line 303
    shift = 40;
#line 304
    goto switch_break;
    case_112: /* CIL Label */ 
    case_80: /* CIL Label */ 
#line 307
    shift = 50;
#line 308
    goto switch_break;
    case_101: /* CIL Label */ 
    case_69: /* CIL Label */ 
#line 311
    shift = 60;
#line 312
    goto switch_break;
    case_0: /* CIL Label */ 
#line 314
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 316
    goto err;
    switch_break: /* CIL Label */ ;
    }
#line 318
    if (shift > 0) {
#line 319
      if ((unsigned long )shift > sizeof(size) * 8UL) {
#line 320
        goto err;
      }
#line 321
      if (size >> ((sizeof(size) * 8UL - (unsigned long )shift) - 1UL) > 0ULL) {
#line 322
        goto err;
      }
#line 323
      size <<= shift;
    }
  }
#line 326
  return ((off_t )size);
  err: 
#line 328
  return ((off_t )0);
}
}
#line 331 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/getsize.c"
int str2int(char *str___0 ) 
{ 
  off_t val ;
  off_t tmp ;

  {
  {
#line 334
  tmp = str2size(str___0);
#line 334
  val = tmp;
  }
#line 336
  if (val > 2147483647L) {
#line 337
    val = (off_t )0;
  } else
#line 336
  if (val < 0L) {
#line 337
    val = (off_t )0;
  }
#line 338
  return ((int )val);
}
}
#line 263 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 503 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) posix_memalign)(void **__memptr ,
                                                                                                     size_t __alignment ,
                                                                                                     size_t __size ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/util.c"
int read_all(int fd___0 , unsigned char *buf , int count ) 
{ 
  int n ;
  ssize_t tmp ;

  {
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 47
    tmp = read(fd___0, (void *)buf, (size_t )count);
#line 47
    n = (int )tmp;
    }
#line 48
    if (n > 0) {
#line 49
      count -= n;
#line 50
      buf += n;
    }
#line 46
    if (n > 0) {
#line 46
      if (! (count > 0)) {
#line 46
        goto while_break;
      }
    } else {
#line 46
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 54
  return (n);
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/util.c"
int write_all(int fd___0 , unsigned char const   *buf , int count ) 
{ 
  int n ;
  ssize_t tmp ;

  {
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 65
    tmp = write(fd___0, (void const   *)buf, (size_t )count);
#line 65
    n = (int )tmp;
    }
#line 66
    if (n > 0) {
#line 67
      count -= n;
#line 68
      buf += n;
    }
#line 64
    if (n > 0) {
#line 64
      if (! (count > 0)) {
#line 64
        goto while_break;
      }
    } else {
#line 64
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  return (n);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/util.c"
filetype_t filetype(char *path ) 
{ 
  struct stat sb ;
  filetype_t res ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 82
  res = (filetype_t )0;
#line 84
  tmp = lstat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& sb));
  }
#line 84
  if (tmp == 0) {
#line 84
    if ((sb.st_mode & 61440U) == 40960U) {
#line 85
      return ((filetype_t )4);
    }
  }
  {
#line 88
  tmp___0 = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& sb));
  }
#line 88
  if (tmp___0 == 0) {
#line 89
    if ((sb.st_mode & 61440U) == 32768U) {
#line 90
      res = (filetype_t )1;
    } else
#line 91
    if ((sb.st_mode & 61440U) == 8192U) {
#line 92
      res = (filetype_t )2;
    } else
#line 93
    if ((sb.st_mode & 61440U) == 24576U) {
#line 94
      res = (filetype_t )3;
    } else {
#line 96
      res = (filetype_t )5;
    }
  }
#line 98
  return (res);
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/util.c"
off_t blkalign(off_t offset , int blocksize , round_t rtype ) 
{ 
  off_t r ;

  {
#line 106
  r = offset % (long )blocksize;
#line 108
  if (r > 0L) {
    {
#line 110
    if ((unsigned int )rtype == 0U) {
#line 110
      goto case_0;
    }
#line 113
    if ((unsigned int )rtype == 1U) {
#line 113
      goto case_1;
    }
#line 109
    goto switch_break;
    case_0: /* CIL Label */ 
#line 111
    offset += (off_t )blocksize - r;
#line 112
    goto switch_break;
    case_1: /* CIL Label */ 
#line 114
    offset -= r;
#line 115
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 119
  return (offset);
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/util.c"
void *alloc_buffer(int bufsize ) 
{ 
  void *ptr ;
  int err ;
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 131
  tmp = posix_memalign(& ptr, (size_t )16777216, (size_t )bufsize);
#line 131
  err = tmp;
  }
#line 132
  if (err) {
    {
#line 133
    tmp___0 = __errno_location();
#line 133
    *tmp___0 = err;
#line 134
    ptr = (void *)0;
    }
  }
#line 142
  return (ptr);
}
}
#line 956 "/usr/include/unistd.h"
extern int fsync(int __fd ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 26 "/usr/include/libgen.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) dirname)(char *__path ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/filldentry.c"
static int dirsync(char *dir ) 
{ 
  int fd___0 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 56
  fd___0 = -1;
#line 58
  fd___0 = open((char const   *)dir, 0);
  }
#line 58
  if (fd___0 < 0) {
#line 59
    goto error;
  }
  {
#line 60
  tmp = fsync(fd___0);
  }
#line 60
  if (tmp < 0) {
#line 61
    goto error;
  }
  {
#line 62
  tmp___0 = close(fd___0);
  }
#line 62
  if (tmp___0 < 0) {
#line 63
    goto error;
  }
#line 64
  return (0);
  error: 
#line 66
  if (fd___0 != -1) {
    {
#line 67
    close(fd___0);
    }
  }
#line 68
  return (-1);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/filldentry.c"
static char *newname(char *old , int pat ) 
{ 
  char *new ;
  char *base ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 81
  if (! ((unsigned long )old != (unsigned long )((void *)0))) {
    {
#line 81
    __assert_fail("old != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/filldentry.c",
                  81U, "newname");
    }
  }
  {
#line 82
  tmp = strlen((char const   *)old);
  }
#line 82
  if (! (tmp > 0UL)) {
    {
#line 82
    __assert_fail("strlen(old) > 0", "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/filldentry.c",
                  82U, "newname");
    }
  }
#line 83
  if (! (pat != 0)) {
    {
#line 83
    __assert_fail("pat != 0", "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/filldentry.c",
                  83U, "newname");
    }
  }
#line 84
  if (! (pat <= 255)) {
    {
#line 84
    __assert_fail("pat <= 0xff", "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/filldentry.c",
                  84U, "newname");
    }
  }
  {
#line 86
  new = strdup((char const   *)old);
  }
#line 87
  if (new) {
    {
#line 88
    base = strrchr((char const   *)new, '/');
    }
#line 88
    if (base) {
#line 89
      base ++;
    } else {
#line 91
      base = new;
    }
    {
#line 92
    tmp___0 = strlen((char const   *)base);
#line 92
    memset((void *)base, pat, tmp___0);
    }
  }
#line 95
  return (new);
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/filldentry.c"
int filldentry(char *path , int pat ) 
{ 
  char *new ;
  char *cpy ;
  char *dir ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int *tmp___5 ;

  {
  {
#line 104
  new = (char *)((void *)0);
#line 105
  cpy = (char *)((void *)0);
#line 108
  new = newname(path, pat);
  }
#line 108
  if (! new) {
#line 109
    goto nomem;
  }
  {
#line 110
  cpy = strdup((char const   *)path);
  }
#line 110
  if (! cpy) {
#line 111
    goto nomem;
  }
  {
#line 112
  tmp = strlen((char const   *)cpy);
#line 112
  tmp___0 = strlen((char const   *)new);
  }
#line 112
  if (! (tmp == tmp___0)) {
    {
#line 112
    __assert_fail("strlen(cpy) == strlen(new)", "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/filldentry.c",
                  112U, "filldentry");
    }
  }
  {
#line 113
  tmp___1 = rename((char const   *)path, (char const   *)new);
  }
#line 113
  if (tmp___1 == -1) {
#line 114
    goto error;
  }
  {
#line 115
  dir = dirname(cpy);
#line 116
  tmp___2 = dirsync(dir);
  }
#line 116
  if (tmp___2 < 0) {
#line 117
    goto error;
  }
  {
#line 118
  free((void *)cpy);
#line 119
  tmp___3 = strlen((char const   *)path);
#line 119
  tmp___4 = strlen((char const   *)new);
  }
#line 119
  if (! (tmp___3 == tmp___4)) {
    {
#line 119
    __assert_fail("strlen(path) == strlen(new)", "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/filldentry.c",
                  119U, "filldentry");
    }
  }
  {
#line 120
  strcpy((char */* __restrict  */)path, (char const   */* __restrict  */)new);
#line 121
  free((void *)new);
  }
#line 122
  return (0);
  nomem: 
  {
#line 124
  tmp___5 = __errno_location();
#line 124
  *tmp___5 = 12;
  }
  error: 
#line 126
  if (cpy) {
    {
#line 127
    free((void *)cpy);
    }
  }
#line 128
  if (new) {
    {
#line 129
    free((void *)new);
    }
  }
#line 130
  return (-1);
}
}
#line 238 "/usr/include/fcntl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) posix_fadvise)(int __fd ,
                                                                                    off_t __offset ,
                                                                                    off_t __len ,
                                                                                    int __advise ) ;
#line 244 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
#line 261
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/fillfile.c"
static int no_threads  =    0;
#line 66 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/fillfile.c"
static void *refill_thread(void *arg ) 
{ 
  struct memstruct *mp ;

  {
  {
#line 69
  mp = (struct memstruct *)arg;
#line 71
  (*(mp->refill))(mp->buf, mp->size);
  }
#line 72
  return ((void *)mp);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/fillfile.c"
static int refill_memcpy(struct memstruct *mp , unsigned char *mem , int memsize ,
                         off_t filesize , off_t written ) 
{ 
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 80
  if (no_threads) {
    {
#line 81
    mp->size = memsize;
#line 82
    refill_thread((void *)mp);
    }
  } else {
    {
#line 84
    tmp___0 = pthread_join(mp->thd, (void **)((void *)0));
#line 84
    mp->err = tmp___0;
    }
#line 84
    if (tmp___0) {
      {
#line 85
      tmp = __errno_location();
#line 85
      *tmp = mp->err;
      }
#line 86
      goto error;
    }
#line 88
    if (! (memsize == mp->size)) {
      {
#line 88
      __assert_fail("memsize == mp->size", "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/fillfile.c",
                    88U, "refill_memcpy");
      }
    }
  }
  {
#line 94
  memcpy((void */* __restrict  */)mem, (void const   */* __restrict  */)mp->buf, (size_t )memsize);
  }
#line 96
  if (! no_threads) {
#line 97
    written += (off_t )memsize;
#line 98
    if (filesize - written > 0L) {
#line 99
      if ((off_t )mp->size > filesize - written) {
#line 100
        mp->size = (int )(filesize - written);
      }
      {
#line 101
      tmp___2 = pthread_create((pthread_t */* __restrict  */)(& mp->thd), (pthread_attr_t const   */* __restrict  */)((void *)0),
                               & refill_thread, (void */* __restrict  */)mp);
#line 101
      mp->err = tmp___2;
      }
#line 101
      if (tmp___2) {
        {
#line 102
        tmp___1 = __errno_location();
#line 102
        *tmp___1 = mp->err;
        }
#line 103
        goto error;
      }
    }
  }
#line 108
  return (0);
  error: 
#line 110
  return (-1);
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/fillfile.c"
static int refill_init(struct memstruct **mpp , void (*refill)(unsigned char *mem ,
                                                               int memsize ) , int memsize ) 
{ 
  struct memstruct *mp ;
  void *tmp ;
  unsigned char *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 116
  mp = (struct memstruct *)((void *)0);
#line 118
  tmp = malloc(sizeof(struct memstruct ));
#line 118
  mp = (struct memstruct *)tmp;
  }
#line 118
  if (! mp) {
#line 119
    goto nomem;
  }
  {
#line 120
  tmp___1 = malloc((size_t )memsize);
#line 120
  tmp___0 = (unsigned char *)tmp___1;
#line 120
  mp->buf = tmp___0;
  }
#line 120
  if (! tmp___0) {
#line 121
    goto nomem;
  }
#line 122
  mp->size = memsize;
#line 123
  mp->refill = refill;
#line 125
  if (! no_threads) {
    {
#line 126
    tmp___3 = pthread_create((pthread_t */* __restrict  */)(& mp->thd), (pthread_attr_t const   */* __restrict  */)((void *)0),
                             & refill_thread, (void */* __restrict  */)mp);
#line 126
    mp->err = tmp___3;
    }
#line 126
    if (tmp___3) {
      {
#line 127
      tmp___2 = __errno_location();
#line 127
      *tmp___2 = mp->err;
      }
#line 128
      goto error;
    }
  }
#line 132
  *mpp = mp;
#line 133
  return (0);
  nomem: 
  {
#line 135
  tmp___4 = __errno_location();
#line 135
  *tmp___4 = 12;
  }
  error: 
#line 137
  return (-1);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/fillfile.c"
static void refill_fini(struct memstruct *mp ) 
{ 


  {
#line 144
  if (! no_threads) {
    {
#line 145
    pthread_join(mp->thd, (void **)((void *)0));
    }
  }
  {
#line 147
  free((void *)mp->buf);
#line 148
  free((void *)mp);
  }
#line 149
  return;
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/fillfile.c"
off_t fillfile(char *path , off_t filesize , unsigned char *mem , int memsize , void (*progress)(void *arg ,
                                                                                                 double completed ) ,
               void *arg , void (*refill)(unsigned char *mem , int memsize ) , _Bool sparse ,
               _Bool creat___0 ) 
{ 
  int fd___0 ;
  off_t n ;
  off_t written ;
  int openflags ;
  struct memstruct *mp ;
  filetype_t tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  __off_t tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 164
  fd___0 = -1;
#line 166
  written = (off_t )0LL;
#line 167
  openflags = 1;
#line 168
  mp = (struct memstruct *)((void *)0);
#line 170
  tmp = filetype(path);
  }
#line 170
  if ((unsigned int )tmp != 2U) {
#line 171
    openflags |= 16384;
  }
#line 172
  if (creat___0) {
#line 173
    openflags |= 64;
  }
  {
#line 174
  fd___0 = open((char const   *)path, openflags, 420);
  }
#line 175
  if (fd___0 < 0) {
    {
#line 175
    tmp___0 = __errno_location();
    }
#line 175
    if (*tmp___0 == 22) {
#line 175
      if (openflags & 16384) {
        {
#line 177
        openflags &= -16385;
#line 178
        fd___0 = open((char const   *)path, openflags, 420);
        }
      }
    }
  }
#line 180
  if (fd___0 < 0) {
#line 181
    goto error;
  }
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 183
    if (written + (off_t )memsize > filesize) {
#line 184
      memsize = (int )(filesize - written);
    }
#line 185
    if (refill) {
#line 185
      if (! sparse) {
#line 186
        if (! mp) {
          {
#line 187
          tmp___1 = refill_init(& mp, refill, memsize);
          }
#line 187
          if (tmp___1 < 0) {
#line 188
            goto error;
          }
        }
        {
#line 189
        tmp___2 = refill_memcpy(mp, mem, memsize, filesize, written);
        }
#line 189
        if (tmp___2 < 0) {
#line 190
          goto error;
        }
      }
    }
#line 192
    if (sparse) {
#line 192
      if (! (written == 0L)) {
#line 192
        if (! (written + (off_t )memsize == filesize)) {
          {
#line 193
          tmp___3 = lseek(fd___0, (__off_t )memsize, 1);
          }
#line 193
          if (tmp___3 < 0L) {
#line 194
            goto error;
          }
#line 195
          written += (off_t )memsize;
        } else {
#line 192
          goto _L___0;
        }
      } else {
#line 192
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 197
      tmp___4 = write_all(fd___0, (unsigned char const   *)mem, memsize);
#line 197
      n = (off_t )tmp___4;
      }
#line 198
      if (creat___0) {
#line 198
        if (n < 0L) {
          {
#line 198
          tmp___5 = __errno_location();
          }
#line 198
          if (*tmp___5 == 28) {
#line 199
            goto while_break;
          }
        }
      }
#line 200
      if (n == 0L) {
        {
#line 201
        tmp___6 = __errno_location();
#line 201
        *tmp___6 = 22;
        }
#line 202
        goto error;
      } else
#line 203
      if (n < 0L) {
#line 204
        goto error;
      }
#line 205
      written += n;
    }
#line 207
    if (progress) {
      {
#line 208
      (*progress)(arg, (double )written / (double )filesize);
      }
    }
#line 182
    if (! (written < filesize)) {
#line 182
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 210
  tmp___7 = fsync(fd___0);
  }
#line 210
  if (tmp___7 < 0) {
#line 211
    goto error;
  }
  {
#line 214
  posix_fadvise(fd___0, (off_t )0, filesize, 4);
#line 216
  tmp___8 = close(fd___0);
  }
#line 216
  if (tmp___8 < 0) {
#line 217
    goto error;
  }
#line 218
  if (mp) {
    {
#line 219
    refill_fini(mp);
    }
  }
#line 220
  return (written);
  error: 
#line 222
  if (mp) {
    {
#line 223
    refill_fini(mp);
    }
  }
#line 224
  if (fd___0 != -1) {
    {
#line 225
    close(fd___0);
    }
  }
#line 226
  return ((off_t )-1);
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/fillfile.c"
off_t checkfile(char *path , off_t filesize , unsigned char *mem , int memsize , void (*progress)(void *arg ,
                                                                                                  double completed ) ,
                void *arg , _Bool sparse ) 
{ 
  int fd___0 ;
  off_t n ;
  off_t verified ;
  unsigned char *buf ;
  int openflags ;
  void *tmp ;
  filetype_t tmp___0 ;
  int *tmp___1 ;
  __off_t tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;

  {
  {
#line 235
  fd___0 = -1;
#line 237
  verified = (off_t )0LL;
#line 238
  buf = (unsigned char *)((void *)0);
#line 239
  openflags = 0;
#line 241
  tmp = alloc_buffer(memsize);
#line 241
  buf = (unsigned char *)tmp;
  }
#line 241
  if (! buf) {
#line 242
    goto nomem;
  }
  {
#line 243
  tmp___0 = filetype(path);
  }
#line 243
  if ((unsigned int )tmp___0 != 2U) {
#line 244
    openflags |= 16384;
  }
  {
#line 245
  fd___0 = open((char const   *)path, openflags);
  }
#line 246
  if (fd___0 < 0) {
    {
#line 246
    tmp___1 = __errno_location();
    }
#line 246
    if (*tmp___1 == 22) {
#line 246
      if (openflags & 16384) {
        {
#line 248
        openflags &= -16385;
#line 249
        fd___0 = open((char const   *)path, openflags);
        }
      }
    }
  }
#line 251
  if (fd___0 < 0) {
#line 252
    goto error;
  }
  {
#line 253
  while (1) {
    while_continue: /* CIL Label */ ;
#line 254
    if (verified + (off_t )memsize > filesize) {
#line 255
      memsize = (int )(filesize - verified);
    }
#line 256
    if (sparse) {
#line 256
      if (! (verified == 0L)) {
#line 256
        if (! (verified + (off_t )memsize == filesize)) {
          {
#line 257
          tmp___2 = lseek(fd___0, (__off_t )memsize, 1);
          }
#line 257
          if (tmp___2 < 0L) {
#line 258
            goto error;
          }
#line 259
          verified += (off_t )memsize;
        } else {
#line 256
          goto _L___0;
        }
      } else {
#line 256
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 261
      tmp___3 = read_all(fd___0, buf, memsize);
#line 261
      n = (off_t )tmp___3;
      }
#line 262
      if (n < 0L) {
#line 263
        goto error;
      }
#line 264
      if (n == 0L) {
        {
#line 265
        tmp___4 = __errno_location();
#line 265
        *tmp___4 = 22;
        }
#line 266
        goto error;
      }
      {
#line 268
      tmp___5 = memcmp((void const   *)mem, (void const   *)buf, (size_t )memsize);
      }
#line 268
      if (tmp___5 != 0) {
#line 269
        goto while_break;
      }
#line 271
      verified += n;
    }
#line 273
    if (progress) {
      {
#line 274
      (*progress)(arg, (double )verified / (double )filesize);
      }
    }
#line 253
    if (! (verified < filesize)) {
#line 253
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 276
  tmp___6 = close(fd___0);
  }
#line 276
  if (tmp___6 < 0) {
#line 277
    goto error;
  }
  {
#line 278
  free((void *)buf);
  }
#line 279
  return (verified);
  nomem: 
  {
#line 281
  tmp___7 = __errno_location();
#line 281
  *tmp___7 = 12;
  }
  error: 
#line 283
  if (buf) {
    {
#line 284
    free((void *)buf);
    }
  }
#line 285
  if (fd___0 != -1) {
    {
#line 286
    close(fd___0);
    }
  }
#line 287
  return ((off_t )-1);
}
}
#line 290 "/home/june/repo/benchmarks/collector/temp/scrub-2.5.2/src/fillfile.c"
void disable_threads(void) 
{ 


  {
#line 293
  no_threads = 1;
#line 294
  return;
}
}
