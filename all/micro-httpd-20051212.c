/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 86 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off_t off_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 497 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 580
extern int putchar(int __c ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 254 "/usr/include/dirent.h"
extern int ( __attribute__((__nonnull__(1,2))) scandir)(char const   * __restrict  __dir ,
                                                        struct dirent *** __restrict  __namelist ,
                                                        int (*__selector)(struct dirent  const  * ) ,
                                                        int (*__cmp)(struct dirent  const  ** ,
                                                                     struct dirent  const  ** ) ) ;
#line 324
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) alphasort)(struct dirent  const  **__e1 ,
                                                                                                  struct dirent  const  **__e2 )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 205
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 239
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime)(time_t const   *__timer ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 263
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 47 "/home/wheatley/newnew/temp/micro-httpd-20051212/micro_httpd.c"
static void file_details(char *dir , char *name ) ;
#line 48
static void send_error(int status , char *title , char *extra_header , char *text ) ;
#line 49
static void send_headers(int status , char *title , char *extra_header , char *mime_type ,
                         off_t length , time_t mod ) ;
#line 50
static char *get_mime_type(char *name ) ;
#line 51
static void strdecode(char *to , char *from ) ;
#line 52
static int hexit(char c ) ;
#line 53
static void strencode(char *to , size_t tosize , char const   *from ) ;
#line 56 "/home/wheatley/newnew/temp/micro-httpd-20051212/micro_httpd.c"
int main(int argc , char **argv ) 
{ 
  char line[10000] ;
  char method[10000] ;
  char path[10000] ;
  char protocol[10000] ;
  char idx[20000] ;
  char location[20000] ;
  char *file ;
  size_t len ;
  int ich ;
  struct stat sb ;
  FILE *fp ;
  struct dirent **dl ;
  int i ;
  int n ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;

  {
#line 68
  if (argc != 2) {
    {
#line 69
    send_error(500, (char *)"Internal Error", (char *)0, (char *)"Config error - no dir specified.");
    }
  }
  {
#line 70
  tmp = chdir((char const   *)*(argv + 1));
  }
#line 70
  if (tmp < 0) {
    {
#line 71
    send_error(500, (char *)"Internal Error", (char *)0, (char *)"Config error - couldn\'t chdir().");
    }
  }
  {
#line 72
  tmp___0 = fgets((char */* __restrict  */)(line), (int )sizeof(line), (FILE */* __restrict  */)stdin);
  }
#line 72
  if ((unsigned long )tmp___0 == (unsigned long )((char *)0)) {
    {
#line 73
    send_error(400, (char *)"Bad Request", (char *)0, (char *)"No request found.");
    }
  }
  {
#line 74
  tmp___1 = sscanf((char const   */* __restrict  */)(line), (char const   */* __restrict  */)"%[^ ] %[^ ] %[^ ]",
                   method, path, protocol);
  }
#line 74
  if (tmp___1 != 3) {
    {
#line 75
    send_error(400, (char *)"Bad Request", (char *)0, (char *)"Can\'t parse request.");
    }
  }
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 76
    tmp___4 = fgets((char */* __restrict  */)(line), (int )sizeof(line), (FILE */* __restrict  */)stdin);
    }
#line 76
    if (! ((unsigned long )tmp___4 != (unsigned long )((char *)0))) {
#line 76
      goto while_break;
    }
    {
#line 78
    tmp___2 = strcmp((char const   *)(line), "\n");
    }
#line 78
    if (tmp___2 == 0) {
#line 79
      goto while_break;
    } else {
      {
#line 78
      tmp___3 = strcmp((char const   *)(line), "\r\n");
      }
#line 78
      if (tmp___3 == 0) {
#line 79
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 81
  tmp___5 = strcasecmp((char const   *)(method), "get");
  }
#line 81
  if (tmp___5 != 0) {
    {
#line 82
    send_error(501, (char *)"Not Implemented", (char *)0, (char *)"That method is not implemented.");
    }
  }
#line 83
  if ((int )path[0] != 47) {
    {
#line 84
    send_error(400, (char *)"Bad Request", (char *)0, (char *)"Bad filename.");
    }
  }
  {
#line 85
  file = & path[1];
#line 86
  strdecode(file, file);
  }
#line 87
  if ((int )*(file + 0) == 0) {
#line 88
    file = (char *)"./";
  }
  {
#line 89
  len = strlen((char const   *)file);
  }
#line 90
  if ((int )*(file + 0) == 47) {
    {
#line 91
    send_error(400, (char *)"Bad Request", (char *)0, (char *)"Illegal filename.");
    }
  } else {
    {
#line 90
    tmp___6 = strcmp((char const   *)file, "..");
    }
#line 90
    if (tmp___6 == 0) {
      {
#line 91
      send_error(400, (char *)"Bad Request", (char *)0, (char *)"Illegal filename.");
      }
    } else {
      {
#line 90
      tmp___7 = strncmp((char const   *)file, "../", (size_t )3);
      }
#line 90
      if (tmp___7 == 0) {
        {
#line 91
        send_error(400, (char *)"Bad Request", (char *)0, (char *)"Illegal filename.");
        }
      } else {
        {
#line 90
        tmp___8 = strstr((char const   *)file, "/../");
        }
#line 90
        if ((unsigned long )tmp___8 != (unsigned long )((char *)0)) {
          {
#line 91
          send_error(400, (char *)"Bad Request", (char *)0, (char *)"Illegal filename.");
          }
        } else {
          {
#line 90
          tmp___9 = strcmp((char const   *)(file + (len - 3UL)), "/..");
          }
#line 90
          if (tmp___9 == 0) {
            {
#line 91
            send_error(400, (char *)"Bad Request", (char *)0, (char *)"Illegal filename.");
            }
          }
        }
      }
    }
  }
  {
#line 92
  tmp___10 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& sb));
  }
#line 92
  if (tmp___10 < 0) {
    {
#line 93
    send_error(404, (char *)"Not Found", (char *)0, (char *)"File not found.");
    }
  }
#line 94
  if ((sb.st_mode & 61440U) == 16384U) {
#line 96
    if ((int )*(file + (len - 1UL)) != 47) {
      {
#line 98
      snprintf((char */* __restrict  */)(location), sizeof(location), (char const   */* __restrict  */)"Location: %s/",
               path);
#line 100
      send_error(302, (char *)"Found", location, (char *)"Directories must end with a slash.");
      }
    }
    {
#line 102
    snprintf((char */* __restrict  */)(idx), sizeof(idx), (char const   */* __restrict  */)"%sindex.html",
             file);
#line 103
    tmp___11 = stat((char const   */* __restrict  */)(idx), (struct stat */* __restrict  */)(& sb));
    }
#line 103
    if (tmp___11 >= 0) {
#line 105
      file = idx;
#line 106
      goto do_file;
    }
    {
#line 108
    send_headers(200, (char *)"Ok", (char *)0, (char *)"text/html", (off_t )-1, sb.st_mtim.tv_sec);
#line 109
    printf((char const   */* __restrict  */)"<html><head><title>Index of %s</title></head>\n<body bgcolor=\"#99cc99\"><h4>Index of %s</h4>\n<pre>\n",
           file, file);
#line 110
    n = scandir((char const   */* __restrict  */)file, (struct dirent ***/* __restrict  */)(& dl),
                (int (*)(struct dirent  const  * ))((void *)0), (int (*)(struct dirent  const  ** ,
                                                                         struct dirent  const  ** ))(& alphasort));
    }
#line 111
    if (n < 0) {
      {
#line 112
      perror("scandir");
      }
    } else {
#line 114
      i = 0;
      {
#line 114
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 114
        if (! (i < n)) {
#line 114
          goto while_break___0;
        }
        {
#line 115
        file_details(file, (*(dl + i))->d_name);
#line 114
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 116
    printf((char const   */* __restrict  */)"</pre>\n<hr>\n<address><a href=\"%s\">%s</a></address>\n</body></html>\n",
           "http://www.acme.com/software/micro_httpd/", "micro_httpd");
    }
  } else {
    do_file: 
    {
#line 121
    fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"r");
    }
#line 122
    if ((unsigned long )fp == (unsigned long )((FILE *)0)) {
      {
#line 123
      send_error(403, (char *)"Forbidden", (char *)0, (char *)"File is protected.");
      }
    }
    {
#line 124
    tmp___12 = get_mime_type(file);
#line 124
    send_headers(200, (char *)"Ok", (char *)0, tmp___12, sb.st_size, sb.st_mtim.tv_sec);
    }
    {
#line 125
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 125
      ich = _IO_getc(fp);
      }
#line 125
      if (! (ich != -1)) {
#line 125
        goto while_break___1;
      }
      {
#line 126
      putchar(ich);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 129
  fflush(stdout);
#line 130
  exit(0);
  }
}
}
#line 137 "/home/wheatley/newnew/temp/micro-httpd-20051212/micro_httpd.c"
static char encoded_name[1000]  ;
#line 138 "/home/wheatley/newnew/temp/micro-httpd-20051212/micro_httpd.c"
static char path[2000]  ;
#line 134 "/home/wheatley/newnew/temp/micro-httpd-20051212/micro_httpd.c"
static void file_details(char *dir , char *name ) 
{ 
  struct stat sb ;
  char timestr[16] ;
  struct tm *tmp ;
  int tmp___0 ;

  {
  {
#line 142
  strencode(encoded_name, sizeof(encoded_name), (char const   *)name);
#line 143
  snprintf((char */* __restrict  */)(path), sizeof(path), (char const   */* __restrict  */)"%s/%s",
           dir, name);
#line 144
  tmp___0 = lstat((char const   */* __restrict  */)(path), (struct stat */* __restrict  */)(& sb));
  }
#line 144
  if (tmp___0 < 0) {
    {
#line 145
    printf((char const   */* __restrict  */)"<a href=\"%s\">%-32.32s</a>    ???\n",
           encoded_name, name);
    }
  } else {
    {
#line 148
    tmp = localtime((time_t const   *)(& sb.st_mtim.tv_sec));
#line 148
    strftime((char */* __restrict  */)(timestr), sizeof(timestr), (char const   */* __restrict  */)"%d%b%Y %H:%M",
             (struct tm  const  */* __restrict  */)tmp);
#line 149
    printf((char const   */* __restrict  */)"<a href=\"%s\">%-32.32s</a>    %15s %14lld\n",
           encoded_name, name, timestr, sb.st_size);
    }
  }
#line 151
  return;
}
}
#line 154 "/home/wheatley/newnew/temp/micro-httpd-20051212/micro_httpd.c"
static void send_error(int status , char *title , char *extra_header , char *text ) 
{ 


  {
  {
#line 157
  send_headers(status, title, extra_header, (char *)"text/html", (off_t )-1, (time_t )-1);
#line 158
  printf((char const   */* __restrict  */)"<html><head><title>%d %s</title></head>\n<body bgcolor=\"#cc9999\"><h4>%d %s</h4>\n",
         status, title, status, title);
#line 159
  printf((char const   */* __restrict  */)"%s\n", text);
#line 160
  printf((char const   */* __restrict  */)"<hr>\n<address><a href=\"%s\">%s</a></address>\n</body></html>\n",
         "http://www.acme.com/software/micro_httpd/", "micro_httpd");
#line 161
  fflush(stdout);
#line 162
  exit(1);
  }
}
}
#line 166 "/home/wheatley/newnew/temp/micro-httpd-20051212/micro_httpd.c"
static void send_headers(int status , char *title , char *extra_header , char *mime_type ,
                         off_t length , time_t mod ) 
{ 
  time_t now ;
  char timebuf[100] ;
  struct tm *tmp ;
  struct tm *tmp___0 ;

  {
  {
#line 172
  printf((char const   */* __restrict  */)"%s %d %s\r\n", "HTTP/1.0", status, title);
#line 173
  printf((char const   */* __restrict  */)"Server: %s\r\n", "micro_httpd");
#line 174
  now = time((time_t *)0);
#line 175
  tmp = gmtime((time_t const   *)(& now));
#line 175
  strftime((char */* __restrict  */)(timebuf), sizeof(timebuf), (char const   */* __restrict  */)"%a, %d %b %Y %H:%M:%S GMT",
           (struct tm  const  */* __restrict  */)tmp);
#line 176
  printf((char const   */* __restrict  */)"Date: %s\r\n", timebuf);
  }
#line 177
  if ((unsigned long )extra_header != (unsigned long )((char *)0)) {
    {
#line 178
    printf((char const   */* __restrict  */)"%s\r\n", extra_header);
    }
  }
#line 179
  if ((unsigned long )mime_type != (unsigned long )((char *)0)) {
    {
#line 180
    printf((char const   */* __restrict  */)"Content-Type: %s\r\n", mime_type);
    }
  }
#line 181
  if (length >= 0L) {
    {
#line 182
    printf((char const   */* __restrict  */)"Content-Length: %lld\r\n", length);
    }
  }
#line 183
  if (mod != -1L) {
    {
#line 185
    tmp___0 = gmtime((time_t const   *)(& mod));
#line 185
    strftime((char */* __restrict  */)(timebuf), sizeof(timebuf), (char const   */* __restrict  */)"%a, %d %b %Y %H:%M:%S GMT",
             (struct tm  const  */* __restrict  */)tmp___0);
#line 186
    printf((char const   */* __restrict  */)"Last-Modified: %s\r\n", timebuf);
    }
  }
  {
#line 188
  printf((char const   */* __restrict  */)"Connection: close\r\n");
#line 189
  printf((char const   */* __restrict  */)"\r\n");
  }
#line 190
  return;
}
}
#line 193 "/home/wheatley/newnew/temp/micro-httpd-20051212/micro_httpd.c"
static char *get_mime_type(char *name ) 
{ 
  char *dot ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;

  {
  {
#line 198
  dot = strrchr((char const   *)name, '.');
  }
#line 199
  if ((unsigned long )dot == (unsigned long )((char *)0)) {
#line 200
    return ((char *)"text/plain; utf-8");
  }
  {
#line 201
  tmp = strcmp((char const   *)dot, ".html");
  }
#line 201
  if (tmp == 0) {
#line 202
    return ((char *)"text/html; utf-8");
  } else {
    {
#line 201
    tmp___0 = strcmp((char const   *)dot, ".htm");
    }
#line 201
    if (tmp___0 == 0) {
#line 202
      return ((char *)"text/html; utf-8");
    }
  }
  {
#line 203
  tmp___1 = strcmp((char const   *)dot, ".jpg");
  }
#line 203
  if (tmp___1 == 0) {
#line 204
    return ((char *)"image/jpeg");
  } else {
    {
#line 203
    tmp___2 = strcmp((char const   *)dot, ".jpeg");
    }
#line 203
    if (tmp___2 == 0) {
#line 204
      return ((char *)"image/jpeg");
    }
  }
  {
#line 205
  tmp___3 = strcmp((char const   *)dot, ".gif");
  }
#line 205
  if (tmp___3 == 0) {
#line 206
    return ((char *)"image/gif");
  }
  {
#line 207
  tmp___4 = strcmp((char const   *)dot, ".png");
  }
#line 207
  if (tmp___4 == 0) {
#line 208
    return ((char *)"image/png");
  }
  {
#line 209
  tmp___5 = strcmp((char const   *)dot, ".css");
  }
#line 209
  if (tmp___5 == 0) {
#line 210
    return ((char *)"text/css");
  }
  {
#line 211
  tmp___6 = strcmp((char const   *)dot, ".au");
  }
#line 211
  if (tmp___6 == 0) {
#line 212
    return ((char *)"audio/basic");
  }
  {
#line 213
  tmp___7 = strcmp((char const   *)dot, ".wav");
  }
#line 213
  if (tmp___7 == 0) {
#line 214
    return ((char *)"audio/wav");
  }
  {
#line 215
  tmp___8 = strcmp((char const   *)dot, ".avi");
  }
#line 215
  if (tmp___8 == 0) {
#line 216
    return ((char *)"video/x-msvideo");
  }
  {
#line 217
  tmp___9 = strcmp((char const   *)dot, ".swf");
  }
#line 217
  if (tmp___9 == 0) {
#line 218
    return ((char *)"application/x-shockwave-flash");
  }
  {
#line 219
  tmp___10 = strcmp((char const   *)dot, ".mov");
  }
#line 219
  if (tmp___10 == 0) {
#line 220
    return ((char *)"video/quicktime");
  } else {
    {
#line 219
    tmp___11 = strcmp((char const   *)dot, ".qt");
    }
#line 219
    if (tmp___11 == 0) {
#line 220
      return ((char *)"video/quicktime");
    }
  }
  {
#line 221
  tmp___12 = strcmp((char const   *)dot, ".mpeg");
  }
#line 221
  if (tmp___12 == 0) {
#line 222
    return ((char *)"video/mpeg");
  } else {
    {
#line 221
    tmp___13 = strcmp((char const   *)dot, ".mpe");
    }
#line 221
    if (tmp___13 == 0) {
#line 222
      return ((char *)"video/mpeg");
    }
  }
  {
#line 223
  tmp___14 = strcmp((char const   *)dot, ".vrml");
  }
#line 223
  if (tmp___14 == 0) {
#line 224
    return ((char *)"model/vrml");
  } else {
    {
#line 223
    tmp___15 = strcmp((char const   *)dot, ".wrl");
    }
#line 223
    if (tmp___15 == 0) {
#line 224
      return ((char *)"model/vrml");
    }
  }
  {
#line 225
  tmp___16 = strcmp((char const   *)dot, ".midi");
  }
#line 225
  if (tmp___16 == 0) {
#line 226
    return ((char *)"audio/midi");
  } else {
    {
#line 225
    tmp___17 = strcmp((char const   *)dot, ".mid");
    }
#line 225
    if (tmp___17 == 0) {
#line 226
      return ((char *)"audio/midi");
    }
  }
  {
#line 227
  tmp___18 = strcmp((char const   *)dot, ".mp3");
  }
#line 227
  if (tmp___18 == 0) {
#line 228
    return ((char *)"audio/mpeg");
  }
  {
#line 229
  tmp___19 = strcmp((char const   *)dot, ".ogg");
  }
#line 229
  if (tmp___19 == 0) {
#line 230
    return ((char *)"application/ogg");
  }
  {
#line 231
  tmp___20 = strcmp((char const   *)dot, ".pac");
  }
#line 231
  if (tmp___20 == 0) {
#line 232
    return ((char *)"application/x-ns-proxy-autoconfig");
  }
#line 233
  return ((char *)"text/plain; utf-8");
}
}
#line 237 "/home/wheatley/newnew/temp/micro-httpd-20051212/micro_httpd.c"
static void strdecode(char *to , char *from ) 
{ 
  int tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
  {
#line 240
  while (1) {
    while_continue: /* CIL Label */ ;
#line 240
    if (! ((int )*from != 0)) {
#line 240
      goto while_break;
    }
#line 242
    if ((int )*(from + 0) == 37) {
      {
#line 242
      tmp___1 = __ctype_b_loc();
      }
#line 242
      if ((int const   )*(*tmp___1 + (int )*(from + 1)) & 4096) {
        {
#line 242
        tmp___2 = __ctype_b_loc();
        }
#line 242
        if ((int const   )*(*tmp___2 + (int )*(from + 2)) & 4096) {
          {
#line 244
          tmp = hexit(*(from + 1));
#line 244
          tmp___0 = hexit(*(from + 2));
#line 244
          *to = (char )(tmp * 16 + tmp___0);
#line 245
          from += 2;
          }
        } else {
#line 248
          *to = *from;
        }
      } else {
#line 248
        *to = *from;
      }
    } else {
#line 248
      *to = *from;
    }
#line 240
    to ++;
#line 240
    from ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 250
  *to = (char )'\000';
#line 251
  return;
}
}
#line 254 "/home/wheatley/newnew/temp/micro-httpd-20051212/micro_httpd.c"
static int hexit(char c ) 
{ 


  {
#line 257
  if ((int )c >= 48) {
#line 257
    if ((int )c <= 57) {
#line 258
      return ((int )c - 48);
    }
  }
#line 259
  if ((int )c >= 97) {
#line 259
    if ((int )c <= 102) {
#line 260
      return (((int )c - 97) + 10);
    }
  }
#line 261
  if ((int )c >= 65) {
#line 261
    if ((int )c <= 70) {
#line 262
      return (((int )c - 65) + 10);
    }
  }
#line 263
  return (0);
}
}
#line 267 "/home/wheatley/newnew/temp/micro-httpd-20051212/micro_httpd.c"
static void strencode(char *to , size_t tosize , char const   *from ) 
{ 
  int tolen ;
  unsigned short const   **tmp ;
  char *tmp___0 ;

  {
#line 272
  tolen = 0;
  {
#line 272
  while (1) {
    while_continue: /* CIL Label */ ;
#line 272
    if ((int const   )*from != 0) {
#line 272
      if (! ((size_t )(tolen + 4) < tosize)) {
#line 272
        goto while_break;
      }
    } else {
#line 272
      goto while_break;
    }
    {
#line 274
    tmp = __ctype_b_loc();
    }
#line 274
    if ((int const   )*(*tmp + (int )*from) & 8) {
#line 276
      *to = (char )*from;
#line 277
      to ++;
#line 278
      tolen ++;
    } else {
      {
#line 274
      tmp___0 = strchr("/_.-~", (int )*from);
      }
#line 274
      if ((unsigned long )tmp___0 != (unsigned long )((char *)0)) {
#line 276
        *to = (char )*from;
#line 277
        to ++;
#line 278
        tolen ++;
      } else {
        {
#line 282
        sprintf((char */* __restrict  */)to, (char const   */* __restrict  */)"%%%02x",
                (int )*from & 255);
#line 283
        to += 3;
#line 284
        tolen += 3;
        }
      }
    }
#line 272
    from ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 287
  *to = (char )'\000';
#line 288
  return;
}
}
