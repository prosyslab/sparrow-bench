/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 116 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __caddr_t caddr_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned char u_int8_t;
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 26 "/usr/include/x86_64-linux-gnu/bits/netdb.h"
struct netent {
   char *n_name ;
   char **n_aliases ;
   int n_addrtype ;
   uint32_t n_net ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 20 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 22 "/usr/include/asm-generic/int-ll64.h"
typedef short __s16;
#line 23 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "/usr/include/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 32 "/usr/include/net/ethernet.h"
struct ether_addr {
   u_int8_t ether_addr_octet[6] ;
} __attribute__((__packed__)) ;
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 138 "/usr/include/net/if_arp.h"
struct arpreq {
   struct sockaddr arp_pa ;
   struct sockaddr arp_ha ;
   int arp_flags ;
   struct sockaddr arp_netmask ;
   char arp_dev[16] ;
};
#line 111 "/usr/include/net/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifrn_42 {
   char ifrn_name[16] ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifru_43 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   __caddr_t ifru_data ;
};
#line 126 "/usr/include/net/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_42 ifr_ifrn ;
   union __anonunion_ifr_ifru_43 ifr_ifru ;
};
#line 176 "/usr/include/net/if.h"
union __anonunion_ifc_ifcu_44 {
   __caddr_t ifcu_buf ;
   struct ifreq *ifcu_req ;
};
#line 176 "/usr/include/net/if.h"
struct ifconf {
   int ifc_len ;
   union __anonunion_ifc_ifcu_44 ifc_ifcu ;
};
#line 694 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/wireless.h"
struct iw_param {
   __s32 value ;
   __u8 fixed ;
   __u8 disabled ;
   __u16 flags ;
};
#line 706 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/wireless.h"
struct iw_point {
   void *pointer ;
   __u16 length ;
   __u16 flags ;
};
#line 721 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/wireless.h"
struct iw_freq {
   __s32 m ;
   __s16 e ;
   __u8 i ;
   __u8 flags ;
};
#line 732 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/wireless.h"
struct iw_quality {
   __u8 qual ;
   __u8 level ;
   __u8 noise ;
   __u8 updated ;
};
#line 748 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/wireless.h"
struct iw_discarded {
   __u32 nwid ;
   __u32 code ;
   __u32 fragment ;
   __u32 retries ;
   __u32 misc ;
};
#line 761 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/wireless.h"
struct iw_missed {
   __u32 beacon ;
};
#line 769 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/wireless.h"
struct iw_thrspy {
   struct sockaddr addr ;
   struct iw_quality qual ;
   struct iw_quality low ;
   struct iw_quality high ;
};
#line 788 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/wireless.h"
struct iw_scan_req {
   __u8 scan_type ;
   __u8 essid_len ;
   __u8 num_channels ;
   __u8 flags ;
   struct sockaddr bssid ;
   __u8 essid[32] ;
   __u32 min_channel_time ;
   __u32 max_channel_time ;
   struct iw_freq channel_list[32] ;
};
#line 850 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/wireless.h"
struct iw_encode_ext {
   __u32 ext_flags ;
   __u8 tx_seq[8] ;
   __u8 rx_seq[8] ;
   struct sockaddr addr ;
   __u16 alg ;
   __u16 key_len ;
   __u8 key[0] ;
};
#line 864 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/wireless.h"
struct iw_mlme {
   __u16 cmd ;
   __u16 reason_code ;
   struct sockaddr addr ;
};
#line 878 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/wireless.h"
struct iw_pmksa {
   __u32 cmd ;
   struct sockaddr bssid ;
   __u8 pmkid[16] ;
};
#line 886 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/wireless.h"
struct iw_michaelmicfailure {
   __u32 flags ;
   struct sockaddr src_addr ;
   __u8 tsc[8] ;
};
#line 895 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/wireless.h"
struct iw_pmkid_cand {
   __u32 flags ;
   __u32 index ;
   struct sockaddr bssid ;
};
#line 907 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/wireless.h"
struct iw_statistics {
   __u16 status ;
   struct iw_quality qual ;
   struct iw_discarded discard ;
   struct iw_missed miss ;
};
#line 929 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/wireless.h"
union iwreq_data {
   char name[16] ;
   struct iw_point essid ;
   struct iw_param nwid ;
   struct iw_freq freq ;
   struct iw_param sens ;
   struct iw_param bitrate ;
   struct iw_param txpower ;
   struct iw_param rts ;
   struct iw_param frag ;
   __u32 mode ;
   struct iw_param retry ;
   struct iw_point encoding ;
   struct iw_param power ;
   struct iw_quality qual ;
   struct sockaddr ap_addr ;
   struct sockaddr addr ;
   struct iw_param param ;
   struct iw_point data ;
};
#line 967 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/wireless.h"
union __anonunion_ifr_ifrn_45 {
   char ifrn_name[16] ;
};
#line 967 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/wireless.h"
struct iwreq {
   union __anonunion_ifr_ifrn_45 ifr_ifrn ;
   union iwreq_data u ;
};
#line 988 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/wireless.h"
struct iw_range {
   __u32 throughput ;
   __u32 min_nwid ;
   __u32 max_nwid ;
   __u16 old_num_channels ;
   __u8 old_num_frequency ;
   __u8 scan_capa ;
   __u32 event_capa[6] ;
   __s32 sensitivity ;
   struct iw_quality max_qual ;
   struct iw_quality avg_qual ;
   __u8 num_bitrates ;
   __s32 bitrate[32] ;
   __s32 min_rts ;
   __s32 max_rts ;
   __s32 min_frag ;
   __s32 max_frag ;
   __s32 min_pmp ;
   __s32 max_pmp ;
   __s32 min_pmt ;
   __s32 max_pmt ;
   __u16 pmp_flags ;
   __u16 pmt_flags ;
   __u16 pm_capa ;
   __u16 encoding_size[8] ;
   __u8 num_encoding_sizes ;
   __u8 max_encoding_tokens ;
   __u8 encoding_login_index ;
   __u16 txpower_capa ;
   __u8 num_txpower ;
   __s32 txpower[8] ;
   __u8 we_version_compiled ;
   __u8 we_version_source ;
   __u16 retry_capa ;
   __u16 retry_flags ;
   __u16 r_time_flags ;
   __s32 min_retry ;
   __s32 max_retry ;
   __s32 min_r_time ;
   __s32 max_r_time ;
   __u16 num_channels ;
   __u8 num_frequency ;
   struct iw_freq freq[32] ;
   __u32 enc_capa ;
   __s32 min_pms ;
   __s32 max_pms ;
   __u16 pms_flags ;
   __s32 modul_capa ;
   __u32 bitrate_capa ;
};
#line 1104 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/wireless.h"
struct iw_priv_args {
   __u32 cmd ;
   __u16 set_args ;
   __u16 get_args ;
   char name[16] ;
};
#line 1122 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/wireless.h"
struct iw_event {
   __u16 len ;
   __u16 cmd ;
   union iwreq_data u ;
};
#line 78 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.h"
typedef struct iw_statistics iwstats;
#line 79 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.h"
typedef struct iw_range iwrange;
#line 80 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.h"
typedef struct iw_param iwparam;
#line 81 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.h"
typedef struct iw_freq iwfreq;
#line 82 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.h"
typedef struct iw_quality iwqual;
#line 83 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.h"
typedef struct iw_priv_args iwprivargs;
#line 84 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.h"
typedef struct sockaddr sockaddr;
#line 90 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.h"
struct wireless_config {
   char name[17] ;
   int has_nwid ;
   iwparam nwid ;
   int has_freq ;
   double freq ;
   int freq_flags ;
   int has_key ;
   unsigned char key[64] ;
   int key_size ;
   int key_flags ;
   int has_essid ;
   int essid_on ;
   char essid[34] ;
   int essid_len ;
   int has_mode ;
   int mode ;
};
#line 90 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.h"
typedef struct wireless_config wireless_config;
#line 154 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.h"
struct wireless_scan {
   struct wireless_scan *next ;
   int has_ap_addr ;
   sockaddr ap_addr ;
   struct wireless_config b ;
   iwstats stats ;
   int has_stats ;
   iwparam maxbitrate ;
   int has_maxbitrate ;
};
#line 154 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.h"
typedef struct wireless_scan wireless_scan;
#line 174 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.h"
struct wireless_scan_head {
   wireless_scan *result ;
   int retry ;
};
#line 174 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.h"
typedef struct wireless_scan_head wireless_scan_head;
#line 182 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.h"
struct stream_descr {
   char *end ;
   char *current ;
   char *value ;
};
#line 197 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.h"
struct iw_modul_descr {
   unsigned int mask ;
   char cmd[8] ;
   char *verbose ;
};
#line 33 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
struct iw15_range {
   __u32 throughput ;
   __u32 min_nwid ;
   __u32 max_nwid ;
   __u16 num_channels ;
   __u8 num_frequency ;
   struct iw_freq freq[16] ;
   __s32 sensitivity ;
   struct iw_quality max_qual ;
   __u8 num_bitrates ;
   __s32 bitrate[8] ;
   __s32 min_rts ;
   __s32 max_rts ;
   __s32 min_frag ;
   __s32 max_frag ;
   __s32 min_pmp ;
   __s32 max_pmp ;
   __s32 min_pmt ;
   __s32 max_pmt ;
   __u16 pmp_flags ;
   __u16 pmt_flags ;
   __u16 pm_capa ;
   __u16 encoding_size[8] ;
   __u8 num_encoding_sizes ;
   __u8 max_encoding_tokens ;
   __u16 txpower_capa ;
   __u8 num_txpower ;
   __s32 txpower[8] ;
   __u8 we_version_compiled ;
   __u8 we_version_source ;
   __u16 retry_capa ;
   __u16 retry_flags ;
   __u16 r_time_flags ;
   __s32 min_retry ;
   __s32 max_retry ;
   __s32 min_r_time ;
   __s32 max_r_time ;
   struct iw_quality avg_qual ;
};
#line 79 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
union iw_range_raw {
   struct iw15_range range15 ;
   struct iw_range range ;
};
#line 96 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
union iw_align_u16 {
   __u16 value ;
   unsigned char byte[2] ;
};
#line 2464 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
struct iw_ioctl_description {
   __u8 header_type ;
   __u8 token_type ;
   __u16 token_size ;
   __u16 min_tokens ;
   __u16 max_tokens ;
   __u32 flags ;
};
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 141 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
struct ethtool_drvinfo {
   __u32 cmd ;
   char driver[32] ;
   char version[32] ;
   char fw_version[32] ;
   char bus_info[32] ;
   char reserved1[32] ;
   char reserved2[16] ;
   __u32 n_stats ;
   __u32 testinfo_len ;
   __u32 eedump_len ;
   __u32 regdump_len ;
};
#line 158 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
struct if_mapping {
   struct if_mapping *next ;
   char ifname[17] ;
   char *sysfs_devpath ;
   int sysfs_devplen ;
   int active[14] ;
   unsigned char mac[16] ;
   int mac_len ;
   char mac_filter[49] ;
   unsigned short hw_type ;
   char driver[32] ;
   char bus_info[32] ;
   char fw_version[32] ;
   unsigned short base_addr ;
   unsigned char irq ;
   char iwproto[17] ;
   int pcmcia_slot ;
   char *sysfs[8] ;
   char prevname[17] ;
};
#line 158 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
typedef struct if_mapping if_mapping;
#line 188 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
struct add_extra {
   char *modif_pos ;
   size_t modif_len ;
};
#line 212 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
struct mapping_selector {
   char *name ;
   int (*add_fn)(struct if_mapping *ifnode , int *active , char *pos , size_t len ,
                 struct add_extra *extra , int linenum ) ;
   int (*cmp_fn)(struct if_mapping *ifnode , struct if_mapping *target ) ;
   int (*get_fn)(int skfd , char const   *ifname , struct if_mapping *target , int flag ) ;
};
#line 221 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
struct sysfs_metadata {
   char *root ;
   int rlen ;
   int filenum ;
   char *filename[8] ;
};
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 11 "/usr/include/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;
#line 35 "/usr/include/linux/netlink.h"
struct sockaddr_nl {
   __kernel_sa_family_t nl_family ;
   unsigned short nl_pad ;
   __u32 nl_pid ;
   __u32 nl_groups ;
};
#line 42 "/usr/include/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};
#line 149 "/usr/include/linux/rtnetlink.h"
struct rtattr {
   unsigned short rta_len ;
   unsigned short rta_type ;
};
#line 445 "/usr/include/linux/rtnetlink.h"
struct ifinfomsg {
   unsigned char ifi_family ;
   unsigned char __ifi_pad ;
   unsigned short ifi_type ;
   int ifi_index ;
   unsigned int ifi_flags ;
   unsigned int ifi_change ;
};
#line 40 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwevent.c"
struct wireless_iface {
   struct wireless_iface *next ;
   int ifindex ;
   char ifname[17] ;
   struct iw_range range ;
   int has_range ;
};
#line 74 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwevent.c"
struct rtnl_handle {
   int fd ;
   struct sockaddr_nl local ;
   struct sockaddr_nl peer ;
   __u32 seq ;
   __u32 dump ;
};
#line 91 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib-private.h"
struct iw_pk_event {
   __u16 len ;
   __u16 cmd ;
   union iwreq_data u ;
} __attribute__((__packed__)) ;
#line 97 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib-private.h"
struct iw_pk_point {
   void *pointer ;
   __u16 length ;
   __u16 flags ;
} __attribute__((__packed__)) ;
#line 22 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlist.c"
struct iwscan_state {
   int ap_num ;
   int val_index ;
};
#line 32 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlist.c"
struct iwmask_name {
   unsigned int mask ;
   char const   *name ;
};
#line 41 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlist.c"
struct iw_auth_descr {
   int value ;
   char const   *label ;
   struct iwmask_name  const  *names ;
   int const   num_names ;
};
#line 2074 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlist.c"
struct iwlist_entry {
   char const   *cmd ;
   int (*fn)(int skfd , char *ifname , char **args , int count ) ;
   int max_count ;
   char const   *argsname ;
};
#line 2074 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlist.c"
typedef struct iwlist_entry iwlist_cmd;
#line 112 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.h"
struct wireless_info {
   struct wireless_config b ;
   int has_sens ;
   iwparam sens ;
   int has_nickname ;
   char nickname[34] ;
   int has_ap_addr ;
   sockaddr ap_addr ;
   int has_bitrate ;
   iwparam bitrate ;
   int has_rts ;
   iwparam rts ;
   int has_frag ;
   iwparam frag ;
   int has_power ;
   iwparam power ;
   int has_txpower ;
   iwparam txpower ;
   int has_retry ;
   iwparam retry ;
   iwstats stats ;
   int has_stats ;
   iwrange range ;
   int has_range ;
   int auth_key_mgmt ;
   int has_auth_key_mgmt ;
   int auth_cipher_pairwise ;
   int has_auth_cipher_pairwise ;
   int auth_cipher_group ;
   int has_auth_cipher_group ;
};
#line 516 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwconfig.c"
struct iwconfig_modifier {
   char const   *cmd ;
   __u16 flag ;
   __u16 exclude ;
};
#line 1701 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwconfig.c"
struct iwconfig_entry {
   char const   *cmd ;
   int (*fn)(int skfd , char *ifname , char **args , int count ) ;
   int min_count ;
   int request ;
   char const   *name ;
   char const   *argsname ;
};
#line 1701 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwconfig.c"
typedef struct iwconfig_entry iwconfig_cmd;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 112 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) log10)(double __x ) ;
#line 153
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) pow)(double __x ,
                                                                             double __y ) ;
#line 178
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) ceil)(double __x )  __attribute__((__const__)) ;
#line 184
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) floor)(double __x )  __attribute__((__const__)) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 285
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 459
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1), __leaf__)) bzero)(void *__s ,
                                                                                             size_t __n ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 460
extern int usleep(__useconds_t __useconds ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 377 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 61 "/usr/include/netdb.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __h_errno_location)(void)  __attribute__((__const__)) ;
#line 144
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 224
extern struct netent *getnetbyname(char const   *__name ) ;
#line 210 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.h"
int iw_sockets_open(void) ;
#line 212
void iw_enum_devices(int skfd , int (*fn)(int skfd , char *ifname , char **args ,
                                          int count ) , char **args , int count ) ;
#line 218
int iw_get_kernel_we_version(void) ;
#line 220
int iw_print_version_info(char const   *toolname ) ;
#line 222
int iw_get_range_info(int skfd , char const   *ifname , iwrange *range ) ;
#line 226
int iw_get_priv_info(int skfd , char const   *ifname , iwprivargs **ppriv ) ;
#line 230
int iw_get_basic_config(int skfd , char const   *ifname , wireless_config *info ) ;
#line 234
int iw_set_basic_config(int skfd , char const   *ifname , wireless_config *info ) ;
#line 239
int iw_protocol_compare(char const   *protocol1 , char const   *protocol2 ) ;
#line 243
void iw_essid_escape(char *dest , char const   *src , int const   slen ) ;
#line 247
int iw_essid_unescape(char *dest , char const   *src ) ;
#line 251
void iw_float2freq(double in , iwfreq *out ) ;
#line 254
double iw_freq2float(iwfreq const   *in ) ;
#line 256
void iw_print_freq_value(char *buffer , int buflen , double freq ) ;
#line 260
void iw_print_freq(char *buffer , int buflen , double freq , int channel , int freq_flags ) ;
#line 266
int iw_freq_to_channel(double freq , struct iw_range  const  *range ) ;
#line 269
int iw_channel_to_freq(int channel , double *pfreq , struct iw_range  const  *range ) ;
#line 273
void iw_print_bitrate(char *buffer , int buflen , int bitrate ) ;
#line 278
int iw_dbm2mwatt(int in ) ;
#line 280
int iw_mwatt2dbm(int in ) ;
#line 282
void iw_print_txpower(char *buffer , int buflen , struct iw_param *txpower ) ;
#line 287
int iw_get_stats(int skfd , char const   *ifname , iwstats *stats , iwrange const   *range ,
                 int has_range ) ;
#line 293
void iw_print_stats(char *buffer , int buflen , iwqual const   *qual , iwrange const   *range ,
                    int has_range ) ;
#line 300
void iw_print_key(char *buffer , int buflen , unsigned char const   *key , int key_size ,
                  int key_flags ) ;
#line 306
int iw_in_key(char const   *input , unsigned char *key ) ;
#line 309
int iw_in_key_full(int skfd , char const   *ifname , char const   *input , unsigned char *key ,
                   __u16 *flags ) ;
#line 316
void iw_print_pm_value(char *buffer , int buflen , int value , int flags , int we_version ) ;
#line 322
void iw_print_pm_mode(char *buffer , int buflen , int flags ) ;
#line 327
void iw_print_retry_value(char *buffer , int buflen , int value , int flags , int we_version ) ;
#line 334
void iw_print_timeval(char *buffer , int buflen , struct timeval  const  *timev ,
                      struct timezone  const  *tz ) ;
#line 340
int iw_check_mac_addr_type(int skfd , char const   *ifname ) ;
#line 343
int iw_check_if_addr_type(int skfd , char const   *ifname ) ;
#line 346
char *iw_mac_ntop(unsigned char const   *mac , int maclen , char *buf , int buflen ) ;
#line 351
void iw_ether_ntop(struct ether_addr  const  *eth , char *buf ) ;
#line 354
char *iw_sawap_ntop(struct sockaddr  const  *sap , char *buf ) ;
#line 357
int iw_mac_aton(char const   *orig , unsigned char *mac , int macmax ) ;
#line 361
int iw_ether_aton(char const   *orig , struct ether_addr *eth ) ;
#line 363
int iw_in_inet(char *name , struct sockaddr *sap ) ;
#line 365
int iw_in_addr(int skfd , char const   *ifname , char *bufp , struct sockaddr *sap ) ;
#line 371
int iw_get_priv_size(int args ) ;
#line 375
void iw_init_event_stream(struct stream_descr *stream , char *data , int len ) ;
#line 379
int iw_extract_event_stream(struct stream_descr *stream , struct iw_event *iwe , int we_version ) ;
#line 384
int iw_process_scan(int skfd , char *ifname , int we_version , wireless_scan_head *context ) ;
#line 389
int iw_scan(int skfd , char *ifname , int we_version , wireless_scan_head *context ) ;
#line 398
char const   * const  iw_operation_mode[8] ;
#line 403
struct iw_modul_descr  const  iw_modul_list[16] ;
#line 421 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.h"
__inline static int ( __attribute__((__always_inline__)) iw_set_ext)(int skfd , char const   *ifname ,
                                                                     int request ,
                                                                     struct iwreq *pwrq ) 
{ 
  int tmp ;

  {
  {
#line 428
  strncpy((char */* __restrict  */)(pwrq->ifr_ifrn.ifrn_name), (char const   */* __restrict  */)ifname,
          (size_t )16);
#line 430
  tmp = ioctl(skfd, (unsigned long )request, pwrq);
  }
#line 430
  return (tmp);
}
}
#line 453 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.h"
__inline static void iw_sockets_close(int skfd ) 
{ 


  {
  {
#line 456
  close(skfd);
  }
#line 457
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib-private.h"
__inline static int ( __attribute__((__always_inline__)) iw_saether_aton)(char const   *bufp ,
                                                                          struct sockaddr *sap ) 
{ 
  int tmp ;

  {
  {
#line 131
  sap->sa_family = (sa_family_t )1;
#line 132
  tmp = iw_ether_aton(bufp, (struct ether_addr *)(sap->sa_data));
  }
#line 132
  return (tmp);
}
}
#line 161 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib-private.h"
__inline static int ( __attribute__((__always_inline__)) iw_ether_cmp)(struct ether_addr  const  *eth1 ,
                                                                       struct ether_addr  const  *eth2 ) 
{ 
  int tmp ;

  {
  {
#line 164
  tmp = memcmp((void const   *)eth1, (void const   *)eth2, sizeof(*eth1));
  }
#line 164
  return (tmp);
}
}
#line 105 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
char const   * const  iw_operation_mode[8]  = 
#line 105 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
  {      (char const   */* const  */)"Auto",      (char const   */* const  */)"Ad-Hoc",      (char const   */* const  */)"Managed",      (char const   */* const  */)"Master", 
        (char const   */* const  */)"Repeater",      (char const   */* const  */)"Secondary",      (char const   */* const  */)"Monitor",      (char const   */* const  */)"Unknown/bug"};
#line 115 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
struct iw_modul_descr  const  iw_modul_list[16]  = 
#line 115
  {      {54U, {(char )'1', (char )'1', (char )'a', (char )'g', (char )'\000'}, (char *)"IEEE 802.11a + 802.11g (2.4 & 5 GHz, up to 54 Mb/s)"}, 
        {22U,
      {(char )'1', (char )'1', (char )'a', (char )'b', (char )'\000'}, (char *)"IEEE 802.11a + 802.11b (2.4 & 5 GHz, up to 54 Mb/s)"}, 
        {38U,
      {(char )'1', (char )'1', (char )'g', (char )'\000'}, (char *)"IEEE 802.11g (2.4 GHz, up to 54 Mb/s)"}, 
        {16U,
      {(char )'1', (char )'1', (char )'a', (char )'\000'}, (char *)"IEEE 802.11a (5 GHz, up to 54 Mb/s)"}, 
        {6U,
      {(char )'1', (char )'1', (char )'b', (char )'\000'}, (char *)"IEEE 802.11b (2.4 GHz, up to 11 Mb/s)"}, 
        {80U,
      {(char )'t', (char )'u', (char )'r', (char )'b', (char )'o', (char )'a', (char )'\000'},
      (char *)"Atheros turbo mode at 5 GHz (up to 108 Mb/s)"}, 
        {102U, {(char )'t', (char )'u', (char )'r', (char )'b', (char )'o', (char )'g',
             (char )'\000'}, (char *)"Atheros turbo mode at 2.4 GHz (up to 108 Mb/s)"}, 
        {14U,
      {(char )'1', (char )'1', (char )'+', (char )'\000'}, (char *)"TI 802.11+ (2.4 GHz, up to 22 Mb/s)"}, 
        {32U,
      {(char )'O', (char )'F', (char )'D', (char )'M', (char )'g', (char )'\000'},
      (char *)"802.11g higher rates, OFDM at 2.4 GHz (up to 54 Mb/s)"}, 
        {16U, {(char )'O', (char )'F', (char )'D', (char )'M', (char )'a', (char )'\000'},
      (char *)"802.11a, OFDM at 5 GHz (up to 54 Mb/s)"}, 
        {4U, {(char )'C', (char )'C', (char )'K', (char )'\000'}, (char *)"802.11b higher rates (2.4 GHz, up to 11 Mb/s)"}, 
        {2U,
      {(char )'D', (char )'S', (char )'\000'}, (char *)"802.11 Direct Sequence (2.4 GHz, up to 2 Mb/s)"}, 
        {1U,
      {(char )'F', (char )'H', (char )'\000'}, (char *)"802.11 Frequency Hopping (2,4 GHz, up to 2 Mb/s)"}, 
        {64U,
      {(char )'t', (char )'u', (char )'r', (char )'b', (char )'o', (char )'\000'},
      (char *)"Atheros turbo mode, channel bonding (up to 108 Mb/s)"}, 
        {8U, {(char )'P', (char )'B', (char )'C', (char )'C', (char )'\000'}, (char *)"TI 802.11+ higher rates (2.4 GHz, up to 22 Mb/s)"}, 
        {1073741824U,
      {(char )'c', (char )'u', (char )'s', (char )'t', (char )'o', (char )'m', (char )'\000'},
      (char *)"Driver specific modulation (check driver documentation)"}};
#line 151 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
int iw_ignore_version  =    0;
#line 164 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static int const   families[4]  = {      (int const   )2,      (int const   )4,      (int const   )3,      (int const   )5};
#line 161 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
int iw_sockets_open(void) 
{ 
  unsigned int i ;
  int sock ;

  {
#line 180
  i = 0U;
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 180
    if (! ((unsigned long )i < sizeof(families) / sizeof(int ))) {
#line 180
      goto while_break;
    }
    {
#line 183
    sock = socket((int )families[i], 2, 0);
    }
#line 184
    if (sock >= 0) {
#line 185
      return (sock);
    }
#line 180
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  return (-1);
}
}
#line 195 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
__inline static char *( __attribute__((__always_inline__)) iw_get_ifname)(char *name ,
                                                                          int nsize ,
                                                                          char *buf ) 
{ 
  char *end ;
  unsigned short const   **tmp ;

  {
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 203
    tmp = __ctype_b_loc();
    }
#line 203
    if (! ((int const   )*(*tmp + (int )*buf) & 8192)) {
#line 203
      goto while_break;
    }
#line 204
    buf ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 209
  end = strrchr((char const   *)buf, ':');
  }
#line 219
  if ((unsigned long )end == (unsigned long )((void *)0)) {
#line 220
    return ((char *)((void *)0));
  } else
#line 219
  if ((end - buf) + 1L > (long )nsize) {
#line 220
    return ((char *)((void *)0));
  }
  {
#line 223
  memcpy((void */* __restrict  */)name, (void const   */* __restrict  */)buf, (size_t )(end - buf));
#line 224
  *(name + (end - buf)) = (char )'\000';
  }
#line 227
  return (end);
}
}
#line 238 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
void iw_enum_devices(int skfd , int (*fn)(int skfd , char *ifname , char **args ,
                                          int count ) , char **args , int count ) 
{ 
  char buff[1024] ;
  FILE *fh ;
  struct ifconf ifc ;
  struct ifreq *ifr ;
  int i ;
  char name[17] ;
  char *s ;
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 252
  fh = fopen((char const   */* __restrict  */)"/proc/net/dev", (char const   */* __restrict  */)"r");
  }
#line 258
  if ((unsigned long )fh != (unsigned long )((void *)0)) {
    {
#line 263
    fgets((char */* __restrict  */)(buff), (int )sizeof(buff), (FILE */* __restrict  */)fh);
#line 264
    fgets((char */* __restrict  */)(buff), (int )sizeof(buff), (FILE */* __restrict  */)fh);
    }
    {
#line 267
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 267
      tmp = fgets((char */* __restrict  */)(buff), (int )sizeof(buff), (FILE */* __restrict  */)fh);
      }
#line 267
      if (! tmp) {
#line 267
        goto while_break;
      }
#line 274
      if ((int )buff[0] == 0) {
#line 275
        goto while_continue;
      } else
#line 274
      if ((int )buff[1] == 0) {
#line 275
        goto while_continue;
      }
      {
#line 278
      s = iw_get_ifname(name, (int )sizeof(name), buff);
      }
#line 280
      if (! s) {
        {
#line 284
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot parse /proc/net/dev\n");
        }
      } else {
        {
#line 291
        (*fn)(skfd, name, args, count);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 294
    fclose(fh);
    }
  } else {
    {
#line 299
    ifc.ifc_len = (int )sizeof(buff);
#line 300
    ifc.ifc_ifcu.ifcu_buf = buff;
#line 301
    tmp___2 = ioctl(skfd, 35090UL, & ifc);
    }
#line 301
    if (tmp___2 < 0) {
      {
#line 303
      tmp___0 = __errno_location();
#line 303
      tmp___1 = strerror(*tmp___0);
#line 303
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SIOCGIFCONF: %s\n",
              tmp___1);
      }
#line 304
      return;
    }
#line 306
    ifr = ifc.ifc_ifcu.ifcu_req;
#line 309
    i = (int )((unsigned long )ifc.ifc_len / sizeof(struct ifreq ));
    {
#line 309
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 309
      i --;
#line 309
      if (! (i >= 0)) {
#line 309
        goto while_break___0;
      }
      {
#line 310
      (*fn)(skfd, ifr->ifr_ifrn.ifrn_name, args, count);
#line 309
      ifr ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 312
  return;
}
}
#line 328 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
int iw_get_kernel_we_version(void) 
{ 
  char buff[1024] ;
  FILE *fh ;
  char *p ;
  int v ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 337
  fh = fopen((char const   */* __restrict  */)"/proc/net/wireless", (char const   */* __restrict  */)"r");
  }
#line 339
  if ((unsigned long )fh == (unsigned long )((void *)0)) {
    {
#line 341
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot read /proc/net/wireless\n");
    }
#line 342
    return (-1);
  }
  {
#line 346
  fgets((char */* __restrict  */)(buff), (int )sizeof(buff), (FILE */* __restrict  */)fh);
#line 348
  tmp___0 = strstr((char const   *)(buff), "| WE");
  }
#line 348
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    {
#line 353
    tmp = strstr((char const   *)(buff), "| Missed");
    }
#line 353
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 354
      v = 11;
    } else {
#line 356
      v = 15;
    }
    {
#line 357
    fclose(fh);
    }
#line 358
    return (v);
  }
  {
#line 362
  fgets((char */* __restrict  */)(buff), (int )sizeof(buff), (FILE */* __restrict  */)fh);
#line 365
  p = strrchr((char const   *)(buff), '|');
  }
#line 366
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 368
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot parse /proc/net/wireless\n");
#line 369
    fclose(fh);
    }
#line 370
    return (-1);
  } else {
    {
#line 366
    tmp___1 = sscanf((char const   */* __restrict  */)(p + 1), (char const   */* __restrict  */)"%d",
                     & v);
    }
#line 366
    if (tmp___1 != 1) {
      {
#line 368
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot parse /proc/net/wireless\n");
#line 369
      fclose(fh);
      }
#line 370
      return (-1);
    }
  }
  {
#line 373
  fclose(fh);
  }
#line 374
  return (v);
}
}
#line 381 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static int print_iface_version_info(int skfd , char *ifname , char **args , int count ) 
{ 
  struct iwreq wrq ;
  char buffer[sizeof(iwrange ) * 2UL] ;
  struct iw_range *range ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 392
  args = args;
#line 392
  count = count;
#line 396
  tmp = iw_set_ext(skfd, (char const   *)ifname, 35585, & wrq);
  }
#line 396
  if (tmp < 0) {
#line 397
    return (-1);
  }
  {
#line 400
  memset((void *)(buffer), 0, sizeof(buffer));
#line 402
  wrq.u.data.pointer = (void *)(buffer);
#line 403
  wrq.u.data.length = (__u16 )sizeof(buffer);
#line 404
  wrq.u.data.flags = (__u16 )0;
#line 405
  tmp___0 = iw_set_ext(skfd, (char const   *)ifname, 35595, & wrq);
  }
#line 405
  if (tmp___0 < 0) {
    {
#line 408
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  Driver has no Wireless Extension version information.\n\n",
            ifname);
    }
#line 409
    return (0);
  }
#line 413
  range = (struct iw_range *)(buffer);
#line 417
  if ((int )wrq.u.data.length >= 300) {
    {
#line 420
    printf((char const   */* __restrict  */)"%-8.16s  Recommend Wireless Extension v%d or later,\n",
           ifname, (int )range->we_version_source);
#line 422
    printf((char const   */* __restrict  */)"          Currently compiled with Wireless Extension v%d.\n\n",
           (int )range->we_version_compiled);
    }
  } else {
    {
#line 427
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  Wireless Extension version too old.\n\n",
            ifname);
    }
  }
#line 432
  return (0);
}
}
#line 439 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
int iw_print_version_info(char const   *toolname ) 
{ 
  int skfd ;
  int we_kernel_version ;

  {
  {
#line 446
  skfd = iw_sockets_open();
  }
#line 446
  if (skfd < 0) {
    {
#line 448
    perror("socket");
    }
#line 449
    return (-1);
  }
#line 453
  if ((unsigned long )toolname != (unsigned long )((void *)0)) {
    {
#line 454
    printf((char const   */* __restrict  */)"%-8.16s  Wireless-Tools version %d\n",
           toolname, 30);
    }
  }
  {
#line 455
  printf((char const   */* __restrict  */)"          Compatible with Wireless Extension v11 to v%d.\n\n",
         22);
#line 459
  we_kernel_version = iw_get_kernel_we_version();
  }
#line 461
  if (we_kernel_version > 15) {
    {
#line 462
    printf((char const   */* __restrict  */)"Kernel    Currently compiled with Wireless Extension v%d.\n\n",
           we_kernel_version);
    }
  }
  {
#line 466
  iw_enum_devices(skfd, & print_iface_version_info, (char **)((void *)0), 0);
#line 468
  iw_sockets_close(skfd);
  }
#line 470
  return (0);
}
}
#line 477 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
int iw_get_range_info(int skfd , char const   *ifname , iwrange *range ) 
{ 
  struct iwreq wrq ;
  char buffer[sizeof(iwrange ) * 2UL] ;
  union iw_range_raw *range_raw ;
  int tmp ;

  {
  {
#line 487
  bzero((void *)(buffer), sizeof(buffer));
#line 489
  wrq.u.data.pointer = (void *)(buffer);
#line 490
  wrq.u.data.length = (__u16 )sizeof(buffer);
#line 491
  wrq.u.data.flags = (__u16 )0;
#line 492
  tmp = iw_set_ext(skfd, ifname, 35595, & wrq);
  }
#line 492
  if (tmp < 0) {
#line 493
    return (-1);
  }
#line 496
  range_raw = (union iw_range_raw *)(buffer);
#line 500
  if ((int )wrq.u.data.length < 300) {
#line 503
    range_raw->range.we_version_compiled = (__u8 )9;
  }
#line 507
  if ((int )range_raw->range.we_version_compiled > 15) {
    {
#line 511
    memcpy((void */* __restrict  */)((char *)range), (void const   */* __restrict  */)(buffer),
           sizeof(iwrange ));
    }
  } else {
    {
#line 516
    bzero((void *)((char *)range), sizeof(struct iw_range ));
#line 519
    memcpy((void */* __restrict  */)((char *)range), (void const   */* __restrict  */)(buffer),
           (size_t )((char *)(& ((struct iw15_range *)((void *)0))->num_channels) - (char *)((void *)0)));
#line 523
    memcpy((void */* __restrict  */)((char *)range + ((char *)(& ((struct iw_range *)((void *)0))->num_channels) - (char *)((void *)0))),
           (void const   */* __restrict  */)(buffer + ((char *)(& ((struct iw15_range *)((void *)0))->num_channels) - (char *)((void *)0))),
           (size_t )(((char *)(& ((struct iw15_range *)((void *)0))->sensitivity) - (char *)((void *)0)) - ((char *)(& ((struct iw15_range *)((void *)0))->num_channels) - (char *)((void *)0))));
#line 527
    memcpy((void */* __restrict  */)((char *)range + ((char *)(& ((struct iw_range *)((void *)0))->sensitivity) - (char *)((void *)0))),
           (void const   */* __restrict  */)(buffer + ((char *)(& ((struct iw15_range *)((void *)0))->sensitivity) - (char *)((void *)0))),
           (size_t )(((char *)(& ((struct iw15_range *)((void *)0))->num_bitrates) - (char *)((void *)0)) - ((char *)(& ((struct iw15_range *)((void *)0))->sensitivity) - (char *)((void *)0))));
#line 531
    memcpy((void */* __restrict  */)((char *)range + ((char *)(& ((struct iw_range *)((void *)0))->num_bitrates) - (char *)((void *)0))),
           (void const   */* __restrict  */)(buffer + ((char *)(& ((struct iw15_range *)((void *)0))->num_bitrates) - (char *)((void *)0))),
           (size_t )(((char *)(& ((struct iw15_range *)((void *)0))->min_rts) - (char *)((void *)0)) - ((char *)(& ((struct iw15_range *)((void *)0))->num_bitrates) - (char *)((void *)0))));
#line 535
    memcpy((void */* __restrict  */)((char *)range + ((char *)(& ((struct iw_range *)((void *)0))->min_rts) - (char *)((void *)0))),
           (void const   */* __restrict  */)(buffer + ((char *)(& ((struct iw15_range *)((void *)0))->min_rts) - (char *)((void *)0))),
           (size_t )(((char *)(& ((struct iw15_range *)((void *)0))->txpower_capa) - (char *)((void *)0)) - ((char *)(& ((struct iw15_range *)((void *)0))->min_rts) - (char *)((void *)0))));
#line 539
    memcpy((void */* __restrict  */)((char *)range + ((char *)(& ((struct iw_range *)((void *)0))->txpower_capa) - (char *)((void *)0))),
           (void const   */* __restrict  */)(buffer + ((char *)(& ((struct iw15_range *)((void *)0))->txpower_capa) - (char *)((void *)0))),
           (size_t )(((char *)(& ((struct iw15_range *)((void *)0))->txpower) - (char *)((void *)0)) - ((char *)(& ((struct iw15_range *)((void *)0))->txpower_capa) - (char *)((void *)0))));
#line 543
    memcpy((void */* __restrict  */)((char *)range + ((char *)(& ((struct iw_range *)((void *)0))->txpower) - (char *)((void *)0))),
           (void const   */* __restrict  */)(buffer + ((char *)(& ((struct iw15_range *)((void *)0))->txpower) - (char *)((void *)0))),
           (size_t )(((char *)(& ((struct iw15_range *)((void *)0))->avg_qual) - (char *)((void *)0)) - ((char *)(& ((struct iw15_range *)((void *)0))->txpower) - (char *)((void *)0))));
#line 547
    memcpy((void */* __restrict  */)((char *)range + ((char *)(& ((struct iw_range *)((void *)0))->avg_qual) - (char *)((void *)0))),
           (void const   */* __restrict  */)(buffer + ((char *)(& ((struct iw15_range *)((void *)0))->avg_qual) - (char *)((void *)0))),
           sizeof(struct iw_quality ));
    }
  }
#line 555
  if (! iw_ignore_version) {
#line 558
    if ((int )range->we_version_compiled <= 10) {
      {
#line 560
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Driver for device %s has been compiled with an ancient version\n",
              ifname);
#line 561
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"of Wireless Extension, while this program support version 11 and later.\n");
#line 562
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Some things may be broken...\n\n");
      }
    }
#line 567
    if ((int )range->we_version_compiled > 22) {
      {
#line 569
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Driver for device %s has been compiled with version %d\n",
              ifname, (int )range->we_version_compiled);
#line 570
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"of Wireless Extension, while this program supports up to version %d.\n",
              22);
#line 571
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Some things may be broken...\n\n");
      }
    }
#line 575
    if ((int )range->we_version_compiled > 10) {
#line 575
      if ((int )range->we_version_compiled < (int )range->we_version_source) {
        {
#line 578
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Driver for device %s recommend version %d of Wireless Extension,\n",
                ifname, (int )range->we_version_source);
#line 579
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"but has been compiled with version %d, therefore some driver features\n",
                (int )range->we_version_compiled);
#line 580
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"may not be available...\n\n");
        }
      }
    }
  }
#line 590
  iw_ignore_version = 1;
#line 592
  return (0);
}
}
#line 602 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
int iw_get_priv_info(int skfd , char const   *ifname , iwprivargs **ppriv ) 
{ 
  struct iwreq wrq ;
  iwprivargs *priv ;
  int maxpriv ;
  iwprivargs *newpriv ;
  void *tmp ;
  int tmp___0 ;
  int *tmp___1 ;

  {
#line 608
  priv = (iwprivargs *)((void *)0);
#line 609
  maxpriv = 16;
  {
#line 617
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 620
    tmp = realloc((void *)priv, (unsigned long )maxpriv * sizeof(*(priv + 0)));
#line 620
    newpriv = (iwprivargs *)tmp;
    }
#line 621
    if ((unsigned long )newpriv == (unsigned long )((void *)0)) {
      {
#line 623
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Allocation failed\n",
              "iw_get_priv_info");
      }
#line 624
      goto while_break;
    }
    {
#line 626
    priv = newpriv;
#line 629
    wrq.u.data.pointer = (void *)((caddr_t )priv);
#line 630
    wrq.u.data.length = (__u16 )maxpriv;
#line 631
    wrq.u.data.flags = (__u16 )0;
#line 632
    tmp___0 = iw_set_ext(skfd, ifname, 35597, & wrq);
    }
#line 632
    if (tmp___0 >= 0) {
#line 635
      *ppriv = priv;
#line 637
      return ((int )wrq.u.data.length);
    }
    {
#line 641
    tmp___1 = __errno_location();
    }
#line 641
    if (*tmp___1 != 7) {
#line 644
      goto while_break;
    }
#line 649
    if ((int )wrq.u.data.length > maxpriv) {
#line 650
      maxpriv = (int )wrq.u.data.length;
    } else {
#line 652
      maxpriv *= 2;
    }
#line 617
    if (! (maxpriv < 1000)) {
#line 617
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 657
  if (priv) {
    {
#line 658
    free((void *)priv);
    }
  }
#line 659
  *ppriv = (iwprivargs *)((void *)0);
#line 661
  return (-1);
}
}
#line 672 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
int iw_get_basic_config(int skfd , char const   *ifname , wireless_config *info ) 
{ 
  struct iwreq wrq ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 679
  memset((void *)((char *)(& wrq)), 0, sizeof(struct iwreq ));
#line 680
  memset((void *)((char *)info), 0, sizeof(struct wireless_config ));
#line 683
  tmp = iw_set_ext(skfd, ifname, 35585, & wrq);
  }
#line 683
  if (tmp < 0) {
#line 685
    return (-1);
  } else {
    {
#line 688
    strncpy((char */* __restrict  */)(info->name), (char const   */* __restrict  */)(wrq.u.name),
            (size_t )16);
#line 689
    info->name[16] = (char )'\000';
    }
  }
  {
#line 693
  tmp___0 = iw_set_ext(skfd, ifname, 35587, & wrq);
  }
#line 693
  if (tmp___0 >= 0) {
    {
#line 695
    info->has_nwid = 1;
#line 696
    memcpy((void */* __restrict  */)(& info->nwid), (void const   */* __restrict  */)(& wrq.u.nwid),
           sizeof(iwparam ));
    }
  }
  {
#line 700
  tmp___1 = iw_set_ext(skfd, ifname, 35589, & wrq);
  }
#line 700
  if (tmp___1 >= 0) {
    {
#line 702
    info->has_freq = 1;
#line 703
    info->freq = iw_freq2float((iwfreq const   *)(& wrq.u.freq));
#line 704
    info->freq_flags = (int )wrq.u.freq.flags;
    }
  }
  {
#line 708
  wrq.u.data.pointer = (void *)((caddr_t )(info->key));
#line 709
  wrq.u.data.length = (__u16 )64;
#line 710
  wrq.u.data.flags = (__u16 )0;
#line 711
  tmp___2 = iw_set_ext(skfd, ifname, 35627, & wrq);
  }
#line 711
  if (tmp___2 >= 0) {
#line 713
    info->has_key = 1;
#line 714
    info->key_size = (int )wrq.u.data.length;
#line 715
    info->key_flags = (int )wrq.u.data.flags;
  }
  {
#line 719
  wrq.u.essid.pointer = (void *)(info->essid);
#line 720
  wrq.u.essid.length = (__u16 )34;
#line 721
  wrq.u.essid.flags = (__u16 )0;
#line 722
  tmp___3 = iw_set_ext(skfd, ifname, 35611, & wrq);
  }
#line 722
  if (tmp___3 >= 0) {
#line 724
    info->has_essid = 1;
#line 725
    info->essid_on = (int )wrq.u.data.flags;
#line 726
    info->essid_len = (int )wrq.u.essid.length;
  }
  {
#line 730
  tmp___4 = iw_set_ext(skfd, ifname, 35591, & wrq);
  }
#line 730
  if (tmp___4 >= 0) {
#line 732
    info->has_mode = 1;
#line 734
    if (wrq.u.mode < 7U) {
#line 735
      info->mode = (int )wrq.u.mode;
    } else {
#line 737
      info->mode = 7;
    }
  }
#line 740
  return (0);
}
}
#line 750 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
int iw_set_basic_config(int skfd , char const   *ifname , wireless_config *info ) 
{ 
  struct iwreq wrq ;
  int ret ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int flags ;
  int *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int *tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int we_kernel_version ;
  size_t tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;

  {
  {
#line 756
  ret = 0;
#line 759
  tmp = iw_set_ext(skfd, ifname, 35585, & wrq);
  }
#line 759
  if (tmp < 0) {
#line 761
    return (-2);
  }
#line 767
  if (info->has_mode) {
    {
#line 769
    strncpy((char */* __restrict  */)(wrq.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)ifname,
            (size_t )16);
#line 770
    wrq.u.mode = (__u32 )info->mode;
#line 772
    tmp___2 = iw_set_ext(skfd, ifname, 35590, & wrq);
    }
#line 772
    if (tmp___2 < 0) {
      {
#line 774
      tmp___0 = __errno_location();
#line 774
      tmp___1 = strerror(*tmp___0);
#line 774
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SIOCSIWMODE: %s\n",
              tmp___1);
#line 775
      ret = -1;
      }
    }
  }
#line 780
  if (info->has_freq) {
    {
#line 782
    iw_float2freq(info->freq, & wrq.u.freq);
#line 784
    tmp___5 = iw_set_ext(skfd, ifname, 35588, & wrq);
    }
#line 784
    if (tmp___5 < 0) {
      {
#line 786
      tmp___3 = __errno_location();
#line 786
      tmp___4 = strerror(*tmp___3);
#line 786
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SIOCSIWFREQ: %s\n",
              tmp___4);
#line 787
      ret = -1;
      }
    }
  }
#line 792
  if (info->has_key) {
#line 794
    flags = info->key_flags;
#line 797
    if ((flags & 255) > 0) {
      {
#line 800
      wrq.u.data.pointer = (void *)((caddr_t )((void *)0));
#line 801
      wrq.u.data.flags = (__u16 )((flags & 255) | 2048);
#line 802
      wrq.u.data.length = (__u16 )0;
#line 804
      tmp___9 = iw_set_ext(skfd, ifname, 35626, & wrq);
      }
#line 804
      if (tmp___9 < 0) {
        {
#line 806
        tmp___6 = __errno_location();
#line 806
        tmp___7 = strerror(*tmp___6);
#line 806
        tmp___8 = __errno_location();
#line 806
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SIOCSIWENCODE(%d): %s\n",
                *tmp___8, tmp___7);
#line 808
        ret = -1;
        }
      }
    }
#line 813
    flags &= -256;
#line 816
    wrq.u.data.pointer = (void *)((caddr_t )(info->key));
#line 817
    wrq.u.data.length = (__u16 )info->key_size;
#line 818
    wrq.u.data.flags = (__u16 )flags;
#line 821
    if (flags & 2048) {
#line 822
      wrq.u.data.pointer = (void *)0;
    }
    {
#line 824
    tmp___13 = iw_set_ext(skfd, ifname, 35626, & wrq);
    }
#line 824
    if (tmp___13 < 0) {
      {
#line 826
      tmp___10 = __errno_location();
#line 826
      tmp___11 = strerror(*tmp___10);
#line 826
      tmp___12 = __errno_location();
#line 826
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SIOCSIWENCODE(%d): %s\n",
              *tmp___12, tmp___11);
#line 828
      ret = -1;
      }
    }
  }
#line 833
  if (info->has_nwid) {
    {
#line 835
    memcpy((void */* __restrict  */)(& wrq.u.nwid), (void const   */* __restrict  */)(& info->nwid),
           sizeof(iwparam ));
#line 836
    wrq.u.nwid.fixed = (__u8 )1;
#line 838
    tmp___16 = iw_set_ext(skfd, ifname, 35586, & wrq);
    }
#line 838
    if (tmp___16 < 0) {
      {
#line 840
      tmp___14 = __errno_location();
#line 840
      tmp___15 = strerror(*tmp___14);
#line 840
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SIOCSIWNWID: %s\n",
              tmp___15);
#line 841
      ret = -1;
      }
    }
  }
#line 850
  if (info->has_essid) {
    {
#line 853
    we_kernel_version = iw_get_kernel_we_version();
#line 855
    wrq.u.essid.pointer = (void *)(info->essid);
#line 856
    tmp___17 = strlen((char const   *)(info->essid));
#line 856
    wrq.u.essid.length = (__u16 )tmp___17;
#line 857
    wrq.u.data.flags = (__u16 )info->essid_on;
    }
#line 858
    if (we_kernel_version < 21) {
#line 859
      wrq.u.essid.length = (__u16 )((int )wrq.u.essid.length + 1);
    }
    {
#line 861
    tmp___20 = iw_set_ext(skfd, ifname, 35610, & wrq);
    }
#line 861
    if (tmp___20 < 0) {
      {
#line 863
      tmp___18 = __errno_location();
#line 863
      tmp___19 = strerror(*tmp___18);
#line 863
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SIOCSIWESSID: %s\n",
              tmp___19);
#line 864
      ret = -1;
      }
    }
  }
#line 868
  return (ret);
}
}
#line 887 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
int iw_protocol_compare(char const   *protocol1 , char const   *protocol2 ) 
{ 
  char const   *dot11 ;
  char const   *dot11_ds ;
  char const   *dot11_5g ;
  int tmp ;
  char const   *sub1 ;
  size_t tmp___0 ;
  char const   *sub2 ;
  size_t tmp___1 ;
  unsigned int i ;
  int isds1 ;
  int isds2 ;
  int is5g1 ;
  int is5g2 ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;

  {
  {
#line 891
  dot11 = "IEEE 802.11";
#line 892
  dot11_ds = "Dbg";
#line 893
  dot11_5g = "a";
#line 896
  tmp = strncmp(protocol1, protocol2, (size_t )16);
  }
#line 896
  if (! tmp) {
#line 897
    return (1);
  }
  {
#line 900
  tmp___8 = strlen(dot11);
#line 900
  tmp___9 = strncmp(protocol1, dot11, tmp___8);
  }
#line 900
  if (! tmp___9) {
    {
#line 900
    tmp___10 = strlen(dot11);
#line 900
    tmp___11 = strncmp(protocol2, dot11, tmp___10);
    }
#line 900
    if (! tmp___11) {
      {
#line 903
      tmp___0 = strlen(dot11);
#line 903
      sub1 = protocol1 + tmp___0;
#line 904
      tmp___1 = strlen(dot11);
#line 904
      sub2 = protocol2 + tmp___1;
#line 906
      isds1 = 0;
#line 907
      isds2 = 0;
#line 908
      is5g1 = 0;
#line 909
      is5g2 = 0;
#line 912
      i = 0U;
      }
      {
#line 912
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 912
        tmp___4 = strlen(dot11_ds);
        }
#line 912
        if (! ((size_t )i < tmp___4)) {
#line 912
          goto while_break;
        }
        {
#line 914
        tmp___2 = strchr(sub1, (int )*(dot11_ds + i));
        }
#line 914
        if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 915
          isds1 = 1;
        }
        {
#line 916
        tmp___3 = strchr(sub2, (int )*(dot11_ds + i));
        }
#line 916
        if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 917
          isds2 = 1;
        }
#line 912
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 919
      if (isds1) {
#line 919
        if (isds2) {
#line 920
          return (1);
        }
      }
#line 923
      i = 0U;
      {
#line 923
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 923
        tmp___7 = strlen(dot11_5g);
        }
#line 923
        if (! ((size_t )i < tmp___7)) {
#line 923
          goto while_break___0;
        }
        {
#line 925
        tmp___5 = strchr(sub1, (int )*(dot11_5g + i));
        }
#line 925
        if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
#line 926
          is5g1 = 1;
        }
        {
#line 927
        tmp___6 = strchr(sub2, (int )*(dot11_5g + i));
        }
#line 927
        if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
#line 928
          is5g2 = 1;
        }
#line 923
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 930
      if (is5g1) {
#line 930
        if (is5g2) {
#line 931
          return (1);
        }
      }
    }
  }
#line 934
  return (0);
}
}
#line 957 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
void iw_essid_escape(char *dest , char const   *src , int const   slen ) 
{ 
  unsigned char const   *s ;
  unsigned char const   *e ;
  char *d ;
  int isescape ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 962
  s = (unsigned char const   *)src;
#line 963
  e = s + slen;
#line 964
  d = dest;
  {
#line 967
  while (1) {
    while_continue: /* CIL Label */ ;
#line 967
    if (! ((unsigned long )s < (unsigned long )e)) {
#line 967
      goto while_break;
    }
#line 974
    if ((int const   )*s == 92) {
#line 977
      if (e - s > 4L) {
#line 977
        if ((int const   )*(s + 1) == 120) {
          {
#line 977
          tmp = __ctype_b_loc();
          }
#line 977
          if ((int const   )*(*tmp + (int )*(s + 2)) & 4096) {
            {
#line 977
            tmp___0 = __ctype_b_loc();
            }
#line 977
            if ((int const   )*(*tmp___0 + (int )*(s + 3)) & 4096) {
#line 980
              isescape = 1;
            } else {
#line 983
              isescape = 0;
            }
          } else {
#line 983
            isescape = 0;
          }
        } else {
#line 983
          isescape = 0;
        }
      } else {
#line 983
        isescape = 0;
      }
    } else {
#line 986
      isescape = 0;
    }
#line 990
    if (isescape) {
      {
#line 993
      sprintf((char */* __restrict  */)d, (char const   */* __restrict  */)"\\x%02X",
              (int const   )*s);
#line 994
      d += 4;
      }
    } else
#line 990
    if (! (((int const   )*s & -128) == 0)) {
      {
#line 993
      sprintf((char */* __restrict  */)d, (char const   */* __restrict  */)"\\x%02X",
              (int const   )*s);
#line 994
      d += 4;
      }
    } else {
      {
#line 990
      tmp___1 = __ctype_b_loc();
      }
#line 990
      if ((int const   )*(*tmp___1 + (int )*s) & 2) {
        {
#line 993
        sprintf((char */* __restrict  */)d, (char const   */* __restrict  */)"\\x%02X",
                (int const   )*s);
#line 994
        d += 4;
        }
      } else {
#line 999
        *d = (char )*s;
#line 1000
        d ++;
      }
    }
#line 1002
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1006
  *d = (char )'\000';
#line 1007
  return;
}
}
#line 1019 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
int iw_essid_unescape(char *dest , char const   *src ) 
{ 
  char const   *s ;
  char *d ;
  char *p ;
  int len ;
  unsigned int temp ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;

  {
#line 1023
  s = src;
#line 1024
  d = dest;
  {
#line 1029
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1029
    p = strchr(s, '\\');
    }
#line 1029
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 1029
      goto while_break;
    }
    {
#line 1032
    len = (int )(p - (char *)s);
#line 1033
    memcpy((void */* __restrict  */)d, (void const   */* __restrict  */)s, (size_t )len);
#line 1034
    d += len;
#line 1035
    s += len;
    }
#line 1038
    if ((int const   )*(s + 1) == 120) {
      {
#line 1038
      tmp = __ctype_b_loc();
      }
#line 1038
      if ((int const   )*(*tmp + (int )*(s + 2)) & 4096) {
        {
#line 1038
        tmp___0 = __ctype_b_loc();
        }
#line 1038
        if ((int const   )*(*tmp___0 + (int )*(s + 3)) & 4096) {
          {
#line 1042
          sscanf((char const   */* __restrict  */)(s + 2), (char const   */* __restrict  */)"%2X",
                 & temp);
#line 1043
          *d = (char )temp;
#line 1044
          d ++;
#line 1045
          s += 4;
          }
        } else {
#line 1050
          *d = (char )*s;
#line 1051
          d ++;
#line 1052
          s ++;
        }
      } else {
#line 1050
        *d = (char )*s;
#line 1051
        d ++;
#line 1052
        s ++;
      }
    } else {
#line 1050
      *d = (char )*s;
#line 1051
      d ++;
#line 1052
      s ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1057
  tmp___1 = strlen(s);
#line 1057
  len = (int )tmp___1;
#line 1058
  memcpy((void */* __restrict  */)d, (void const   */* __restrict  */)s, (size_t )(len + 1));
  }
#line 1060
  return ((int )((d - dest) + (long )len));
}
}
#line 1080 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
void iw_float2freq(double in , iwfreq *out ) 
{ 
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
  {
#line 1095
  tmp = log10(in);
#line 1095
  tmp___0 = floor(tmp);
#line 1095
  out->e = (short )tmp___0;
  }
#line 1096
  if ((int )out->e > 8) {
    {
#line 1098
    tmp___1 = pow((double )10, (double )((int )out->e - 6));
#line 1098
    tmp___2 = floor(in / tmp___1);
#line 1098
    out->m = (__s32 )((long )tmp___2 * 100L);
#line 1099
    out->e = (__s16 )((int )out->e - 8);
    }
  } else {
#line 1103
    out->m = (__s32 )((long )in);
#line 1104
    out->e = (__s16 )0;
  }
#line 1107
  return;
}
}
#line 1113 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
double iw_freq2float(iwfreq const   *in ) 
{ 
  double tmp ;

  {
  {
#line 1125
  tmp = pow((double )10, (double )in->e);
  }
#line 1125
  return ((double )in->m * tmp);
}
}
#line 1133 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
void iw_print_freq_value(char *buffer , int buflen , double freq ) 
{ 
  char scale ;
  int divisor ;

  {
#line 1138
  if (freq < 1e3) {
    {
#line 1139
    snprintf((char */* __restrict  */)buffer, (size_t )buflen, (char const   */* __restrict  */)"%g",
             freq);
    }
  } else {
#line 1145
    if (freq >= 1e9) {
#line 1147
      scale = (char )'G';
#line 1148
      divisor = (int )1e9;
    } else
#line 1152
    if (freq >= 1e6) {
#line 1154
      scale = (char )'M';
#line 1155
      divisor = (int )1e6;
    } else {
#line 1159
      scale = (char )'k';
#line 1160
      divisor = (int )1e3;
    }
    {
#line 1163
    snprintf((char */* __restrict  */)buffer, (size_t )buflen, (char const   */* __restrict  */)"%g %cHz",
             freq / (double )divisor, (int )scale);
    }
  }
#line 1165
  return;
}
}
#line 1171 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
void iw_print_freq(char *buffer , int buflen , double freq , int channel , int freq_flags ) 
{ 
  char sep ;
  int tmp ;
  char vbuf[16] ;

  {
#line 1178
  if (freq_flags & 1) {
#line 1178
    tmp = '=';
  } else {
#line 1178
    tmp = ':';
  }
  {
#line 1178
  sep = (char )tmp;
#line 1182
  iw_print_freq_value(vbuf, (int )sizeof(vbuf), freq);
  }
#line 1185
  if (freq < 1e3) {
    {
#line 1186
    snprintf((char */* __restrict  */)buffer, (size_t )buflen, (char const   */* __restrict  */)"Channel%c%s",
             (int )sep, vbuf);
    }
  } else
#line 1190
  if (channel >= 0) {
    {
#line 1191
    snprintf((char */* __restrict  */)buffer, (size_t )buflen, (char const   */* __restrict  */)"Frequency%c%s (Channel %d)",
             (int )sep, vbuf, channel);
    }
  } else {
    {
#line 1194
    snprintf((char */* __restrict  */)buffer, (size_t )buflen, (char const   */* __restrict  */)"Frequency%c%s",
             (int )sep, vbuf);
    }
  }
#line 1196
  return;
}
}
#line 1202 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
int iw_freq_to_channel(double freq , struct iw_range  const  *range ) 
{ 
  double ref_freq ;
  int k ;

  {
#line 1210
  if (freq < 1e3) {
#line 1211
    return (-1);
  }
#line 1215
  k = 0;
  {
#line 1215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1215
    if (! (k < (int )range->num_frequency)) {
#line 1215
      goto while_break;
    }
    {
#line 1217
    ref_freq = iw_freq2float((iwfreq const   *)(& range->freq[k]));
    }
#line 1218
    if (freq == ref_freq) {
#line 1219
      return ((int )range->freq[k].i);
    }
#line 1215
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1222
  return (-2);
}
}
#line 1230 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
int iw_channel_to_freq(int channel , double *pfreq , struct iw_range  const  *range ) 
{ 
  int has_freq ;
  int k ;

  {
#line 1235
  has_freq = 0;
#line 1239
  k = 0;
  {
#line 1239
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1239
    if (! (k < (int )range->num_frequency)) {
#line 1239
      goto while_break;
    }
#line 1241
    if ((int const   )range->freq[k].e != 0) {
#line 1242
      has_freq = 1;
    } else
#line 1241
    if (range->freq[k].m > (__s32 const   )((int )1e3)) {
#line 1242
      has_freq = 1;
    }
#line 1239
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1244
  if (! has_freq) {
#line 1245
    return (-1);
  }
#line 1248
  k = 0;
  {
#line 1248
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1248
    if (! (k < (int )range->num_frequency)) {
#line 1248
      goto while_break___0;
    }
#line 1250
    if ((int const   )range->freq[k].i == (int const   )channel) {
      {
#line 1252
      *pfreq = iw_freq2float((iwfreq const   *)(& range->freq[k]));
      }
#line 1253
      return (channel);
    }
#line 1248
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1257
  return (-2);
}
}
#line 1266 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
void iw_print_bitrate(char *buffer , int buflen , int bitrate ) 
{ 
  double rate ;
  char scale ;
  int divisor ;

  {
#line 1271
  rate = (double )bitrate;
#line 1275
  if (rate >= 1e9) {
#line 1277
    scale = (char )'G';
#line 1278
    divisor = (int )1e9;
  } else
#line 1282
  if (rate >= 1e6) {
#line 1284
    scale = (char )'M';
#line 1285
    divisor = (int )1e6;
  } else {
#line 1289
    scale = (char )'k';
#line 1290
    divisor = (int )1e3;
  }
  {
#line 1293
  snprintf((char */* __restrict  */)buffer, (size_t )buflen, (char const   */* __restrict  */)"%g %cb/s",
           rate / (double )divisor, (int )scale);
  }
#line 1294
  return;
}
}
#line 1302 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
int iw_dbm2mwatt(int in ) 
{ 
  double tmp ;
  double tmp___0 ;

  {
  {
#line 1320
  tmp = pow(10.0, (double )in / 10.0);
#line 1320
  tmp___0 = floor(tmp);
  }
#line 1320
  return ((int )tmp___0);
}
}
#line 1328 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
int iw_mwatt2dbm(int in ) 
{ 
  double tmp ;
  double tmp___0 ;

  {
  {
#line 1350
  tmp = log10((double )in);
#line 1350
  tmp___0 = ceil(10.0 * tmp);
  }
#line 1350
  return ((int )tmp___0);
}
}
#line 1358 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
void iw_print_txpower(char *buffer , int buflen , struct iw_param *txpower ) 
{ 
  int dbm ;

  {
#line 1366
  if (txpower->disabled) {
    {
#line 1368
    snprintf((char */* __restrict  */)buffer, (size_t )buflen, (char const   */* __restrict  */)"off");
    }
  } else
#line 1373
  if ((int )txpower->flags & 2) {
    {
#line 1375
    snprintf((char */* __restrict  */)buffer, (size_t )buflen, (char const   */* __restrict  */)"%d",
             txpower->value);
    }
  } else {
#line 1380
    if ((int )txpower->flags & 1) {
      {
#line 1381
      dbm = iw_mwatt2dbm(txpower->value);
      }
    } else {
#line 1383
      dbm = txpower->value;
    }
    {
#line 1386
    snprintf((char */* __restrict  */)buffer, (size_t )buflen, (char const   */* __restrict  */)"%d dBm",
             dbm);
    }
  }
#line 1389
  return;
}
}
#line 1398 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
int iw_get_stats(int skfd , char const   *ifname , iwstats *stats , iwrange const   *range ,
                 int has_range ) 
{ 
  struct iwreq wrq ;
  int tmp ;
  FILE *f ;
  FILE *tmp___0 ;
  char buf[256] ;
  char *bp ;
  int t ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;

  {
#line 1406
  if (has_range) {
#line 1406
    if ((int const   )range->we_version_compiled > 11) {
      {
#line 1409
      wrq.u.data.pointer = (void *)((caddr_t )stats);
#line 1410
      wrq.u.data.length = (__u16 )sizeof(struct iw_statistics );
#line 1411
      wrq.u.data.flags = (__u16 )1;
#line 1412
      strncpy((char */* __restrict  */)(wrq.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)ifname,
              (size_t )16);
#line 1413
      tmp = iw_set_ext(skfd, ifname, 35599, & wrq);
      }
#line 1413
      if (tmp < 0) {
#line 1414
        return (-1);
      }
#line 1417
      return (0);
    } else {
#line 1406
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 1421
    tmp___0 = fopen((char const   */* __restrict  */)"/proc/net/wireless", (char const   */* __restrict  */)"r");
#line 1421
    f = tmp___0;
    }
#line 1426
    if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 1427
      return (-1);
    }
    {
#line 1429
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1429
      tmp___8 = fgets((char */* __restrict  */)(buf), 255, (FILE */* __restrict  */)f);
      }
#line 1429
      if (! tmp___8) {
#line 1429
        goto while_break;
      }
#line 1431
      bp = buf;
      {
#line 1432
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1432
        if (*bp) {
          {
#line 1432
          tmp___1 = __ctype_b_loc();
          }
#line 1432
          if (! ((int const   )*(*tmp___1 + (int )*bp) & 8192)) {
#line 1432
            goto while_break___0;
          }
        } else {
#line 1432
          goto while_break___0;
        }
#line 1433
        bp ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1435
      tmp___5 = strlen(ifname);
#line 1435
      tmp___6 = strncmp((char const   *)bp, ifname, tmp___5);
      }
#line 1435
      if (tmp___6 == 0) {
        {
#line 1435
        tmp___7 = strlen(ifname);
        }
#line 1435
        if ((int )*(bp + tmp___7) == 58) {
          {
#line 1438
          bp = strchr((char const   *)bp, ':');
#line 1439
          bp ++;
#line 1441
          bp = strtok((char */* __restrict  */)bp, (char const   */* __restrict  */)" ");
#line 1442
          sscanf((char const   */* __restrict  */)bp, (char const   */* __restrict  */)"%X",
                 & t);
#line 1443
          stats->status = (unsigned short )t;
#line 1445
          bp = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
#line 1446
          tmp___2 = strchr((char const   *)bp, '.');
          }
#line 1446
          if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 1447
            stats->qual.updated = (__u8 )((int )stats->qual.updated | 1);
          }
          {
#line 1448
          sscanf((char const   */* __restrict  */)bp, (char const   */* __restrict  */)"%d",
                 & t);
#line 1449
          stats->qual.qual = (unsigned char )t;
#line 1451
          bp = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
#line 1452
          tmp___3 = strchr((char const   *)bp, '.');
          }
#line 1452
          if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 1453
            stats->qual.updated = (__u8 )((int )stats->qual.updated | 2);
          }
          {
#line 1454
          sscanf((char const   */* __restrict  */)bp, (char const   */* __restrict  */)"%d",
                 & t);
#line 1455
          stats->qual.level = (unsigned char )t;
#line 1457
          bp = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
#line 1458
          tmp___4 = strchr((char const   *)bp, '.');
          }
#line 1458
          if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
#line 1459
            stats->qual.updated = (__u8 )((int )stats->qual.updated + 4);
          }
          {
#line 1460
          sscanf((char const   */* __restrict  */)bp, (char const   */* __restrict  */)"%d",
                 & t);
#line 1461
          stats->qual.noise = (unsigned char )t;
#line 1463
          bp = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
#line 1464
          sscanf((char const   */* __restrict  */)bp, (char const   */* __restrict  */)"%d",
                 & stats->discard.nwid);
#line 1465
          bp = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
#line 1466
          sscanf((char const   */* __restrict  */)bp, (char const   */* __restrict  */)"%d",
                 & stats->discard.code);
#line 1467
          bp = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
#line 1468
          sscanf((char const   */* __restrict  */)bp, (char const   */* __restrict  */)"%d",
                 & stats->discard.misc);
#line 1469
          fclose(f);
          }
#line 1471
          return (0);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1474
    fclose(f);
    }
#line 1475
    return (-1);
  }
}
}
#line 1483 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
void iw_print_stats(char *buffer , int buflen , iwqual const   *qual , iwrange const   *range ,
                    int has_range ) 
{ 
  int len ;
  int tmp ;
  double rcpilevel ;
  int tmp___0 ;
  double rcpinoise ;
  int tmp___1 ;
  int dblevel ;
  int tmp___2 ;
  int dbnoise ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1525
  if (has_range) {
#line 1525
    if ((int const   )qual->level != 0) {
#line 1525
      goto _L___0;
    } else
#line 1525
    if ((int const   )qual->updated & 136) {
      _L___0: /* CIL Label */ 
#line 1529
      if (! ((int const   )qual->updated & 16)) {
#line 1531
        if ((int const   )qual->updated & 1) {
#line 1531
          tmp = '=';
        } else {
#line 1531
          tmp = ':';
        }
        {
#line 1531
        len = snprintf((char */* __restrict  */)buffer, (size_t )buflen, (char const   */* __restrict  */)"Quality%c%d/%d  ",
                       tmp, (int const   )qual->qual, (int const   )range->max_qual.qual);
#line 1534
        buffer += len;
#line 1535
        buflen -= len;
        }
      }
#line 1539
      if ((int const   )qual->updated & 128) {
#line 1543
        if (! ((int const   )qual->updated & 32)) {
#line 1545
          rcpilevel = (double )qual->level / 2.0 - 110.0;
#line 1546
          if ((int const   )qual->updated & 2) {
#line 1546
            tmp___0 = '=';
          } else {
#line 1546
            tmp___0 = ':';
          }
          {
#line 1546
          len = snprintf((char */* __restrict  */)buffer, (size_t )buflen, (char const   */* __restrict  */)"Signal level%c%g dBm  ",
                         tmp___0, rcpilevel);
#line 1549
          buffer += len;
#line 1550
          buflen -= len;
          }
        }
#line 1554
        if (! ((int const   )qual->updated & 64)) {
#line 1556
          rcpinoise = (double )qual->noise / 2.0 - 110.0;
#line 1557
          if ((int const   )qual->updated & 4) {
#line 1557
            tmp___1 = '=';
          } else {
#line 1557
            tmp___1 = ':';
          }
          {
#line 1557
          len = snprintf((char */* __restrict  */)buffer, (size_t )buflen, (char const   */* __restrict  */)"Noise level%c%g dBm",
                         tmp___1, rcpinoise);
          }
        }
      } else
#line 1565
      if ((int const   )qual->updated & 8) {
#line 1565
        goto _L;
      } else
#line 1565
      if ((int const   )qual->level > (int const   )range->max_qual.level) {
        _L: /* CIL Label */ 
#line 1569
        if (! ((int const   )qual->updated & 32)) {
#line 1571
          dblevel = (int )qual->level;
#line 1573
          if ((int const   )qual->level >= 64) {
#line 1574
            dblevel -= 256;
          }
#line 1575
          if ((int const   )qual->updated & 2) {
#line 1575
            tmp___2 = '=';
          } else {
#line 1575
            tmp___2 = ':';
          }
          {
#line 1575
          len = snprintf((char */* __restrict  */)buffer, (size_t )buflen, (char const   */* __restrict  */)"Signal level%c%d dBm  ",
                         tmp___2, dblevel);
#line 1578
          buffer += len;
#line 1579
          buflen -= len;
          }
        }
#line 1583
        if (! ((int const   )qual->updated & 64)) {
#line 1585
          dbnoise = (int )qual->noise;
#line 1587
          if ((int const   )qual->noise >= 64) {
#line 1588
            dbnoise -= 256;
          }
#line 1589
          if ((int const   )qual->updated & 4) {
#line 1589
            tmp___3 = '=';
          } else {
#line 1589
            tmp___3 = ':';
          }
          {
#line 1589
          len = snprintf((char */* __restrict  */)buffer, (size_t )buflen, (char const   */* __restrict  */)"Noise level%c%d dBm",
                         tmp___3, dbnoise);
          }
        }
      } else {
#line 1597
        if (! ((int const   )qual->updated & 32)) {
#line 1599
          if ((int const   )qual->updated & 2) {
#line 1599
            tmp___4 = '=';
          } else {
#line 1599
            tmp___4 = ':';
          }
          {
#line 1599
          len = snprintf((char */* __restrict  */)buffer, (size_t )buflen, (char const   */* __restrict  */)"Signal level%c%d/%d  ",
                         tmp___4, (int const   )qual->level, (int const   )range->max_qual.level);
#line 1602
          buffer += len;
#line 1603
          buflen -= len;
          }
        }
#line 1607
        if (! ((int const   )qual->updated & 64)) {
#line 1609
          if ((int const   )qual->updated & 4) {
#line 1609
            tmp___5 = '=';
          } else {
#line 1609
            tmp___5 = ':';
          }
          {
#line 1609
          len = snprintf((char */* __restrict  */)buffer, (size_t )buflen, (char const   */* __restrict  */)"Noise level%c%d/%d",
                         tmp___5, (int const   )qual->noise, (int const   )range->max_qual.noise);
          }
        }
      }
    } else {
      {
#line 1619
      snprintf((char */* __restrict  */)buffer, (size_t )buflen, (char const   */* __restrict  */)"Quality:%d  Signal level:%d  Noise level:%d",
               (int const   )qual->qual, (int const   )qual->level, (int const   )qual->noise);
      }
    }
  } else {
    {
#line 1619
    snprintf((char */* __restrict  */)buffer, (size_t )buflen, (char const   */* __restrict  */)"Quality:%d  Signal level:%d  Noise level:%d",
             (int const   )qual->qual, (int const   )qual->level, (int const   )qual->noise);
    }
  }
#line 1623
  return;
}
}
#line 1631 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
void iw_print_key(char *buffer , int buflen , unsigned char const   *key , int key_size ,
                  int key_flags ) 
{ 
  int i ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 1641
  if (key_size * 3 > buflen) {
    {
#line 1643
    snprintf((char */* __restrict  */)buffer, (size_t )buflen, (char const   */* __restrict  */)"<too big>");
    }
#line 1644
    return;
  }
#line 1648
  if (key_flags & 2048) {
#line 1651
    if (key_size <= 0) {
      {
#line 1652
      strcpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)"on");
      }
    } else {
      {
#line 1655
      strcpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)"**");
#line 1656
      buffer += 2;
#line 1657
      i = 1;
      }
      {
#line 1657
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1657
        if (! (i < key_size)) {
#line 1657
          goto while_break;
        }
#line 1659
        if ((i & 1) == 0) {
          {
#line 1660
          tmp = buffer;
#line 1660
          buffer ++;
#line 1660
          strcpy((char */* __restrict  */)tmp, (char const   */* __restrict  */)"-");
          }
        }
        {
#line 1661
        strcpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)"**");
#line 1662
        buffer += 2;
#line 1657
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 1669
    sprintf((char */* __restrict  */)buffer, (char const   */* __restrict  */)"%.2X",
            (int const   )*(key + 0));
#line 1670
    buffer += 2;
#line 1671
    i = 1;
    }
    {
#line 1671
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1671
      if (! (i < key_size)) {
#line 1671
        goto while_break___0;
      }
#line 1673
      if ((i & 1) == 0) {
        {
#line 1674
        tmp___0 = buffer;
#line 1674
        buffer ++;
#line 1674
        strcpy((char */* __restrict  */)tmp___0, (char const   */* __restrict  */)"-");
        }
      }
      {
#line 1675
      sprintf((char */* __restrict  */)buffer, (char const   */* __restrict  */)"%.2X",
              (int const   )*(key + i));
#line 1676
      buffer += 2;
#line 1671
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1679
  return;
}
}
#line 1687 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static int iw_pass_key(char const   *input , unsigned char *key ) 
{ 


  {
  {
#line 1691
  input = input;
#line 1691
  key = key;
#line 1692
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Passphrase not implemented\n");
  }
#line 1693
  return (-1);
}
}
#line 1702 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
int iw_in_key(char const   *input , unsigned char *key ) 
{ 
  int keylen ;
  size_t tmp ;
  int tmp___0 ;
  char const   *p ;
  int dlen ;
  unsigned char out[64] ;
  int temph ;
  int templ ;
  int count ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 1706
  keylen = 0;
#line 1709
  tmp___4 = strncmp(input, "s:", (size_t )2);
  }
#line 1709
  if (tmp___4) {
    {
#line 1718
    tmp___3 = strncmp(input, "p:", (size_t )2);
    }
#line 1718
    if (tmp___3) {
#line 1730
      p = input;
#line 1731
      dlen = -1;
      {
#line 1734
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1734
        if (! ((int const   )*p != 0)) {
#line 1734
          goto while_break;
        }
#line 1740
        if (dlen <= 0) {
#line 1743
          if (dlen == 0) {
#line 1744
            p ++;
          }
          {
#line 1746
          tmp___1 = strcspn(p, "-:;.,");
#line 1746
          dlen = (int )tmp___1;
          }
        }
        {
#line 1750
        count = sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%1X%1X",
                       & temph, & templ);
        }
#line 1751
        if (count < 1) {
#line 1752
          return (-1);
        }
#line 1754
        if (dlen % 2) {
#line 1755
          count = 1;
        }
#line 1757
        if (count == 2) {
#line 1758
          templ |= temph << 4;
        } else {
#line 1760
          templ = temph;
        }
#line 1761
        tmp___2 = keylen;
#line 1761
        keylen ++;
#line 1761
        out[tmp___2] = (unsigned char )(templ & 255);
#line 1763
        if (keylen >= 64) {
#line 1764
          goto while_break;
        }
#line 1766
        p += count;
#line 1767
        dlen -= count;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1774
      memcpy((void */* __restrict  */)key, (void const   */* __restrict  */)(out),
             (size_t )keylen);
      }
    } else {
      {
#line 1721
      tmp___0 = iw_pass_key(input + 2, key);
      }
#line 1721
      return (tmp___0);
    }
  } else {
    {
#line 1712
    tmp = strlen(input + 2);
#line 1712
    keylen = (int )tmp;
    }
#line 1713
    if (keylen > 64) {
#line 1714
      keylen = 64;
    }
    {
#line 1715
    memcpy((void */* __restrict  */)key, (void const   */* __restrict  */)(input + 2),
           (size_t )keylen);
    }
  }
#line 1785
  return (keylen);
}
}
#line 1793 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
int iw_in_key_full(int skfd , char const   *ifname , char const   *input , unsigned char *key ,
                   __u16 *flags ) 
{ 
  int keylen ;
  char *p ;
  struct iw_range range ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1800
  keylen = 0;
#line 1803
  tmp___2 = strncmp(input, "l:", (size_t )2);
  }
#line 1803
  if (tmp___2) {
    {
#line 1847
    keylen = iw_in_key(input, key);
    }
  } else {
    {
#line 1808
    tmp = strlen(input + 2);
#line 1808
    keylen = (int )(tmp + 1UL);
    }
#line 1810
    if (keylen > 64) {
#line 1811
      keylen = 64;
    }
    {
#line 1812
    memcpy((void */* __restrict  */)key, (void const   */* __restrict  */)(input + 2),
           (size_t )keylen);
#line 1815
    p = strchr((char const   *)((char *)key), ':');
    }
#line 1816
    if ((unsigned long )p == (unsigned long )((void *)0)) {
      {
#line 1818
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Invalid login format\n");
      }
#line 1819
      return (-1);
    }
    {
#line 1821
    *p = (char )'\000';
#line 1824
    tmp___0 = iw_get_range_info(skfd, ifname, & range);
    }
#line 1824
    if (tmp___0 < 0) {
      {
#line 1826
      memset((void *)(& range), 0, sizeof(range));
      }
    }
#line 1828
    if ((int )range.we_version_compiled > 15) {
      {
#line 1831
      printf((char const   */* __restrict  */)"flags = %X, index = %X\n", (int )*flags,
             (int )range.encoding_login_index);
      }
#line 1833
      if (((int )*flags & 255) == 0) {
        {
#line 1836
        tmp___1 = iw_get_range_info(skfd, ifname, & range);
        }
#line 1836
        if (tmp___1 < 0) {
          {
#line 1837
          memset((void *)(& range), 0, sizeof(range));
          }
        }
        {
#line 1838
        printf((char const   */* __restrict  */)"flags = %X, index = %X\n", (int )*flags,
               (int )range.encoding_login_index);
#line 1840
        *flags = (__u16 )((int )*flags | ((int )range.encoding_login_index & 255));
        }
      }
      {
#line 1842
      printf((char const   */* __restrict  */)"flags = %X, index = %X\n", (int )*flags,
             (int )range.encoding_login_index);
      }
    }
  }
#line 1849
  return (keylen);
}
}
#line 1858 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
void iw_print_pm_value(char *buffer , int buflen , int value , int flags , int we_version ) 
{ 


  {
#line 1866
  if (buflen < 25) {
    {
#line 1868
    snprintf((char */* __restrict  */)buffer, (size_t )buflen, (char const   */* __restrict  */)"<too big>");
    }
#line 1869
    return;
  }
#line 1871
  buflen -= 25;
#line 1874
  if (flags & 1) {
    {
#line 1876
    strcpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)" min");
#line 1877
    buffer += 4;
    }
  }
#line 1879
  if (flags & 2) {
    {
#line 1881
    strcpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)" max");
#line 1882
    buffer += 4;
    }
  }
#line 1886
  if (flags & 8192) {
    {
#line 1888
    strcpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)" timeout:");
#line 1889
    buffer += 9;
    }
  } else
#line 1893
  if (flags & 16384) {
    {
#line 1895
    strcpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)" saving:");
#line 1896
    buffer += 8;
    }
  } else {
    {
#line 1900
    strcpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)" period:");
#line 1901
    buffer += 8;
    }
  }
#line 1906
  if (flags & 4) {
#line 1908
    if (we_version < 21) {
#line 1909
      value = (int )((double )value / 1e6);
    }
    {
#line 1910
    snprintf((char */* __restrict  */)buffer, (size_t )buflen, (char const   */* __restrict  */)"%d",
             value);
    }
  } else
#line 1915
  if (value >= (int )1e6) {
    {
#line 1916
    snprintf((char */* __restrict  */)buffer, (size_t )buflen, (char const   */* __restrict  */)"%gs",
             (double )value / 1e6);
    }
  } else
#line 1918
  if (value >= (int )1e3) {
    {
#line 1919
    snprintf((char */* __restrict  */)buffer, (size_t )buflen, (char const   */* __restrict  */)"%gms",
             (double )value / 1e3);
    }
  } else {
    {
#line 1921
    snprintf((char */* __restrict  */)buffer, (size_t )buflen, (char const   */* __restrict  */)"%dus",
             value);
    }
  }
#line 1923
  return;
}
}
#line 1929 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
void iw_print_pm_mode(char *buffer , int buflen , int flags ) 
{ 


  {
#line 1935
  if (buflen < 28) {
    {
#line 1937
    snprintf((char */* __restrict  */)buffer, (size_t )buflen, (char const   */* __restrict  */)"<too big>");
    }
#line 1938
    return;
  }
  {
#line 1944
  if ((flags & 3840) == 256) {
#line 1944
    goto case_256;
  }
#line 1947
  if ((flags & 3840) == 512) {
#line 1947
    goto case_512;
  }
#line 1950
  if ((flags & 3840) == 768) {
#line 1950
    goto case_768;
  }
#line 1953
  if ((flags & 3840) == 1024) {
#line 1953
    goto case_1024;
  }
#line 1956
  if ((flags & 3840) == 2048) {
#line 1956
    goto case_2048;
  }
#line 1959
  goto switch_default;
  case_256: /* CIL Label */ 
  {
#line 1945
  strcpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)"mode:Unicast only received");
  }
#line 1946
  goto switch_break;
  case_512: /* CIL Label */ 
  {
#line 1948
  strcpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)"mode:Multicast only received");
  }
#line 1949
  goto switch_break;
  case_768: /* CIL Label */ 
  {
#line 1951
  strcpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)"mode:All packets received");
  }
#line 1952
  goto switch_break;
  case_1024: /* CIL Label */ 
  {
#line 1954
  strcpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)"mode:Force sending");
  }
#line 1955
  goto switch_break;
  case_2048: /* CIL Label */ 
  {
#line 1957
  strcpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)"mode:Repeat multicasts");
  }
#line 1958
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1960
  strcpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)"");
  }
#line 1961
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1963
  return;
}
}
#line 1971 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
void iw_print_retry_value(char *buffer , int buflen , int value , int flags , int we_version ) 
{ 


  {
#line 1979
  if (buflen < 20) {
    {
#line 1981
    snprintf((char */* __restrict  */)buffer, (size_t )buflen, (char const   */* __restrict  */)"<too big>");
    }
#line 1982
    return;
  }
#line 1984
  buflen -= 20;
#line 1987
  if (flags & 1) {
    {
#line 1989
    strcpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)" min");
#line 1990
    buffer += 4;
    }
  }
#line 1992
  if (flags & 2) {
    {
#line 1994
    strcpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)" max");
#line 1995
    buffer += 4;
    }
  }
#line 1997
  if (flags & 16) {
    {
#line 1999
    strcpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)" short");
#line 2000
    buffer += 6;
    }
  }
#line 2002
  if (flags & 32) {
    {
#line 2004
    strcpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)"  long");
#line 2005
    buffer += 6;
    }
  }
#line 2009
  if (flags & 8192) {
    {
#line 2011
    strcpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)" lifetime:");
#line 2012
    buffer += 10;
    }
#line 2015
    if (flags & 4) {
#line 2017
      if (we_version < 21) {
#line 2018
        value = (int )((double )value / 1e6);
      }
      {
#line 2019
      snprintf((char */* __restrict  */)buffer, (size_t )buflen, (char const   */* __restrict  */)"%d",
               value);
      }
    } else
#line 2024
    if (value >= (int )1e6) {
      {
#line 2025
      snprintf((char */* __restrict  */)buffer, (size_t )buflen, (char const   */* __restrict  */)"%gs",
               (double )value / 1e6);
      }
    } else
#line 2027
    if (value >= (int )1e3) {
      {
#line 2028
      snprintf((char */* __restrict  */)buffer, (size_t )buflen, (char const   */* __restrict  */)"%gms",
               (double )value / 1e3);
      }
    } else {
      {
#line 2030
      snprintf((char */* __restrict  */)buffer, (size_t )buflen, (char const   */* __restrict  */)"%dus",
               value);
      }
    }
  } else {
    {
#line 2034
    snprintf((char */* __restrict  */)buffer, (size_t )buflen, (char const   */* __restrict  */)" limit:%d",
             value);
    }
  }
#line 2035
  return;
}
}
#line 2044 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
void iw_print_timeval(char *buffer , int buflen , struct timeval  const  *timev ,
                      struct timezone  const  *tz ) 
{ 
  int s ;

  {
  {
#line 2052
  s = (int )((timev->tv_sec - (__time_t const   )(tz->tz_minuteswest * 60)) % 86400L);
#line 2053
  snprintf((char */* __restrict  */)buffer, (size_t )buflen, (char const   */* __restrict  */)"%02d:%02d:%02d.%06u",
           s / 3600, (s % 3600) / 60, s % 60, (u_int32_t )timev->tv_usec);
  }
#line 2056
  return;
}
}
#line 2069 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
int iw_check_mac_addr_type(int skfd , char const   *ifname ) 
{ 
  struct ifreq ifr ;
  int tmp ;

  {
  {
#line 2076
  strncpy((char */* __restrict  */)(ifr.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)ifname,
          (size_t )16);
#line 2077
  tmp = ioctl(skfd, 35111UL, & ifr);
  }
#line 2077
  if (tmp < 0) {
    {
#line 2082
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Interface %s doesn\'t support MAC addresses\n",
            ifname);
    }
#line 2084
    return (-1);
  } else
#line 2077
  if ((int )ifr.ifr_ifru.ifru_hwaddr.sa_family != 1) {
#line 2077
    if ((int )ifr.ifr_ifru.ifru_hwaddr.sa_family != 801) {
      {
#line 2082
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Interface %s doesn\'t support MAC addresses\n",
              ifname);
      }
#line 2084
      return (-1);
    }
  }
#line 2095
  return (0);
}
}
#line 2103 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
int iw_check_if_addr_type(int skfd , char const   *ifname ) 
{ 
  struct ifreq ifr ;
  int tmp ;

  {
  {
#line 2110
  strncpy((char */* __restrict  */)(ifr.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)ifname,
          (size_t )16);
#line 2111
  tmp = ioctl(skfd, 35093UL, & ifr);
  }
#line 2111
  if (tmp < 0) {
    {
#line 2115
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Interface %s doesn\'t support IP addresses\n",
            ifname);
    }
#line 2116
    return (-1);
  } else
#line 2111
  if ((int )ifr.ifr_ifru.ifru_addr.sa_family != 2) {
    {
#line 2115
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Interface %s doesn\'t support IP addresses\n",
            ifname);
    }
#line 2116
    return (-1);
  }
#line 2124
  return (0);
}
}
#line 2131 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
char *iw_mac_ntop(unsigned char const   *mac , int maclen , char *buf , int buflen ) 
{ 
  int i ;

  {
#line 2140
  if (buflen < (maclen * 3 - 1) + 1) {
#line 2141
    return ((char *)((void *)0));
  }
  {
#line 2144
  sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"%02X", (int const   )*(mac + 0));
#line 2147
  i = 1;
  }
  {
#line 2147
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2147
    if (! (i < maclen)) {
#line 2147
      goto while_break;
    }
    {
#line 2148
    sprintf((char */* __restrict  */)((buf + i * 3) - 1), (char const   */* __restrict  */)":%02X",
            (int const   )*(mac + i));
#line 2147
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2149
  return (buf);
}
}
#line 2156 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
void iw_ether_ntop(struct ether_addr  const  *eth , char *buf ) 
{ 


  {
  {
#line 2160
  sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"%02X:%02X:%02X:%02X:%02X:%02X",
          (int )eth->ether_addr_octet[0], (int )eth->ether_addr_octet[1], (int )eth->ether_addr_octet[2],
          (int )eth->ether_addr_octet[3], (int )eth->ether_addr_octet[4], (int )eth->ether_addr_octet[5]);
  }
#line 2164
  return;
}
}
#line 2172 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
char *iw_sawap_ntop(struct sockaddr  const  *sap , char *buf ) 
{ 
  struct ether_addr ether_zero ;
  struct ether_addr ether_bcast ;
  struct ether_addr ether_hack ;
  struct ether_addr  const  *ether_wap ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 2176
  ether_zero.ether_addr_octet[0] = (u_int8_t )0;
#line 2176
  ether_zero.ether_addr_octet[1] = (u_int8_t )0;
#line 2176
  ether_zero.ether_addr_octet[2] = (u_int8_t )0;
#line 2176
  ether_zero.ether_addr_octet[3] = (u_int8_t )0;
#line 2176
  ether_zero.ether_addr_octet[4] = (u_int8_t )0;
#line 2176
  ether_zero.ether_addr_octet[5] = (u_int8_t )0;
#line 2177
  ether_bcast.ether_addr_octet[0] = (u_int8_t )255;
#line 2177
  ether_bcast.ether_addr_octet[1] = (u_int8_t )255;
#line 2177
  ether_bcast.ether_addr_octet[2] = (u_int8_t )255;
#line 2177
  ether_bcast.ether_addr_octet[3] = (u_int8_t )255;
#line 2177
  ether_bcast.ether_addr_octet[4] = (u_int8_t )255;
#line 2177
  ether_bcast.ether_addr_octet[5] = (u_int8_t )255;
#line 2178
  ether_hack.ether_addr_octet[0] = (u_int8_t )68;
#line 2178
  ether_hack.ether_addr_octet[1] = (u_int8_t )68;
#line 2178
  ether_hack.ether_addr_octet[2] = (u_int8_t )68;
#line 2178
  ether_hack.ether_addr_octet[3] = (u_int8_t )68;
#line 2178
  ether_hack.ether_addr_octet[4] = (u_int8_t )68;
#line 2178
  ether_hack.ether_addr_octet[5] = (u_int8_t )68;
#line 2179
  ether_wap = (struct ether_addr  const  *)(sap->sa_data);
#line 2181
  tmp___1 = iw_ether_cmp(ether_wap, (struct ether_addr  const  *)(& ether_zero));
  }
#line 2181
  if (tmp___1) {
    {
#line 2184
    tmp___0 = iw_ether_cmp(ether_wap, (struct ether_addr  const  *)(& ether_bcast));
    }
#line 2184
    if (tmp___0) {
      {
#line 2187
      tmp = iw_ether_cmp(ether_wap, (struct ether_addr  const  *)(& ether_hack));
      }
#line 2187
      if (tmp) {
        {
#line 2190
        iw_ether_ntop(ether_wap, buf);
        }
      } else {
        {
#line 2188
        sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"None");
        }
      }
    } else {
      {
#line 2185
      sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"Invalid");
      }
    }
  } else {
    {
#line 2182
    sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"Not-Associated");
    }
  }
#line 2191
  return (buf);
}
}
#line 2199 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
int iw_mac_aton(char const   *orig , unsigned char *mac , int macmax ) 
{ 
  char const   *p ;
  int maclen ;
  int temph ;
  int templ ;
  int count ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 2204
  p = orig;
#line 2205
  maclen = 0;
  {
#line 2208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2208
    if (! ((int const   )*p != 0)) {
#line 2208
      goto while_break;
    }
    {
#line 2214
    count = sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%1X%1X",
                   & temph, & templ);
    }
#line 2215
    if (count != 2) {
#line 2216
      goto while_break;
    }
#line 2218
    templ |= temph << 4;
#line 2219
    tmp = maclen;
#line 2219
    maclen ++;
#line 2219
    *(mac + tmp) = (unsigned char )(templ & 255);
#line 2222
    p += 2;
#line 2223
    if ((int const   )*p == 0) {
#line 2230
      return (maclen);
    }
#line 2234
    if (maclen >= macmax) {
      {
#line 2239
      tmp___0 = __errno_location();
#line 2239
      *tmp___0 = 7;
      }
#line 2240
      return (0);
    }
#line 2244
    if ((int const   )*p != 58) {
#line 2245
      goto while_break;
    }
#line 2246
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2253
  tmp___1 = __errno_location();
#line 2253
  *tmp___1 = 22;
  }
#line 2254
  return (0);
}
}
#line 2261 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
int iw_ether_aton(char const   *orig , struct ether_addr *eth ) 
{ 
  int maclen ;
  int *tmp ;

  {
  {
#line 2265
  maclen = iw_mac_aton(orig, (unsigned char *)eth, 6);
  }
#line 2266
  if (maclen > 0) {
#line 2266
    if (maclen < 6) {
      {
#line 2268
      tmp = __errno_location();
#line 2268
      *tmp = 22;
#line 2269
      maclen = 0;
      }
    }
  }
#line 2271
  return (maclen);
}
}
#line 2278 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
int iw_in_inet(char *name , struct sockaddr *sap ) 
{ 
  struct hostent *hp ;
  struct netent *np ;
  struct sockaddr_in *sain ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 2283
  sain = (struct sockaddr_in *)sap;
#line 2286
  sain->sin_family = (sa_family_t )2;
#line 2287
  sain->sin_port = (in_port_t )0;
#line 2290
  tmp = strcmp((char const   *)name, "default");
  }
#line 2290
  if (! tmp) {
#line 2291
    sain->sin_addr.s_addr = (in_addr_t )0;
#line 2292
    return (1);
  }
  {
#line 2296
  np = getnetbyname((char const   *)name);
  }
#line 2296
  if ((unsigned long )np != (unsigned long )((struct netent *)((void *)0))) {
    {
#line 2297
    sain->sin_addr.s_addr = htonl(np->n_net);
#line 2298
    strcpy((char */* __restrict  */)name, (char const   */* __restrict  */)np->n_name);
    }
#line 2299
    return (1);
  }
  {
#line 2303
  hp = gethostbyname((char const   *)name);
  }
#line 2303
  if ((unsigned long )hp == (unsigned long )((struct hostent *)((void *)0))) {
    {
#line 2304
    tmp___0 = __errno_location();
#line 2304
    tmp___1 = __h_errno_location();
#line 2304
    *tmp___0 = *tmp___1;
    }
#line 2305
    return (-1);
  }
  {
#line 2307
  memcpy((void */* __restrict  */)((char *)(& sain->sin_addr)), (void const   */* __restrict  */)*(hp->h_addr_list + 0),
         (size_t )hp->h_length);
#line 2308
  strcpy((char */* __restrict  */)name, (char const   */* __restrict  */)hp->h_name);
  }
#line 2309
  return (0);
}
}
#line 2316 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
int iw_in_addr(int skfd , char const   *ifname , char *bufp , struct sockaddr *sap ) 
{ 
  struct sockaddr if_address ;
  struct arpreq arp_query ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 2323
  tmp___5 = strchr((char const   *)bufp, ':');
  }
#line 2323
  if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
    {
#line 2329
    tmp = iw_check_if_addr_type(skfd, ifname);
    }
#line 2329
    if (tmp < 0) {
      {
#line 2331
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  Interface doesn\'t support IP addresses\n",
              ifname);
      }
#line 2332
      return (-1);
    }
    {
#line 2336
    tmp___0 = iw_in_inet(bufp, & if_address);
    }
#line 2336
    if (tmp___0 < 0) {
      {
#line 2338
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid interface address %s\n",
              bufp);
      }
#line 2339
      return (-1);
    }
    {
#line 2343
    memcpy((void */* __restrict  */)((char *)(& arp_query.arp_pa)), (void const   */* __restrict  */)((char *)(& if_address)),
           sizeof(struct sockaddr ));
#line 2346
    arp_query.arp_ha.sa_family = (sa_family_t )0;
#line 2347
    arp_query.arp_flags = 0;
#line 2350
    strncpy((char */* __restrict  */)(arp_query.arp_dev), (char const   */* __restrict  */)ifname,
            (size_t )16);
#line 2351
    tmp___2 = ioctl(skfd, 35156UL, & arp_query);
    }
#line 2351
    if (tmp___2 < 0) {
      {
#line 2354
      tmp___1 = __errno_location();
#line 2354
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Arp failed for %s on %s... (%d)\nTry to ping the address before setting it.\n",
              bufp, ifname, *tmp___1);
      }
#line 2356
      return (-1);
    } else
#line 2351
    if (! (arp_query.arp_flags & 2)) {
      {
#line 2354
      tmp___1 = __errno_location();
#line 2354
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Arp failed for %s on %s... (%d)\nTry to ping the address before setting it.\n",
              bufp, ifname, *tmp___1);
      }
#line 2356
      return (-1);
    }
    {
#line 2360
    memcpy((void */* __restrict  */)((char *)sap), (void const   */* __restrict  */)((char *)(& arp_query.arp_ha)),
           sizeof(struct sockaddr ));
    }
  } else {
    {
#line 2375
    tmp___3 = iw_check_mac_addr_type(skfd, ifname);
    }
#line 2375
    if (tmp___3 < 0) {
      {
#line 2377
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  Interface doesn\'t support MAC addresses\n",
              ifname);
      }
#line 2378
      return (-1);
    }
    {
#line 2382
    tmp___4 = iw_saether_aton((char const   *)bufp, sap);
    }
#line 2382
    if (tmp___4 == 0) {
      {
#line 2384
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid hardware address %s\n",
              bufp);
      }
#line 2385
      return (-1);
    }
  }
#line 2396
  return (0);
}
}
#line 2402 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static int const   priv_type_size[8]  = 
#line 2402
  {      (int const   )0,      (int const   )1,      (int const   )1,      (int const   )0, 
        (int const   )sizeof(__u32 ),      (int const   )sizeof(struct iw_freq ),      (int const   )sizeof(struct sockaddr ),      (int const   )0};
#line 2417 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
int iw_get_priv_size(int args ) 
{ 
  int num ;
  int type ;

  {
#line 2420
  num = args & 2047;
#line 2421
  type = (args & 28672) >> 12;
#line 2423
  return (num * (int )priv_type_size[type]);
}
}
#line 2480 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static struct iw_ioctl_description  const  standard_ioctl_descr[55]  = 
#line 2480
  {      {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )2, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )2}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )5, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )2}, 
        {(__u8 )5, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )4, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )2}, 
        {(__u8 )4, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )sizeof(struct iw_range ),
      (__u32 )1}, 
        {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )8, (unsigned char)0, (__u16 )sizeof(struct sockaddr ), (unsigned short)0,
      (__u16 )8, 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )(sizeof(struct sockaddr ) + sizeof(struct iw_quality )),
      (unsigned short)0, (__u16 )8, 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )sizeof(struct iw_thrspy ), (__u16 )1, (__u16 )1,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )sizeof(struct iw_thrspy ), (__u16 )1, (__u16 )1,
      0U}, 
        {(__u8 )6, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )6, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (__u16 )sizeof(struct iw_mlme ), (__u16 )sizeof(struct iw_mlme ),
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )(sizeof(struct sockaddr ) + sizeof(struct iw_quality )),
      (unsigned short)0, (__u16 )64, (__u32 )8}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (__u16 )0, (__u16 )sizeof(struct iw_scan_req ),
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )4096, (__u32 )8}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )33, (__u32 )2}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )33, (__u32 )1}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )33, 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )33, 0U}, 
        {(unsigned char)0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(unsigned char)0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )0, (unsigned short)0, (__u16 )64, (__u32 )6}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )0, (unsigned short)0, (__u16 )64, (__u32 )5}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )1024, 0U}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )1024, 0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (__u16 )sizeof(struct iw_encode_ext ),
      (__u16 )(sizeof(struct iw_encode_ext ) + 64UL), 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (__u16 )sizeof(struct iw_encode_ext ),
      (__u16 )(sizeof(struct iw_encode_ext ) + 64UL), 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (__u16 )sizeof(struct iw_pmksa ), (__u16 )sizeof(struct iw_pmksa ),
      0U}};
#line 2712 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static unsigned int const   standard_ioctl_num  =    (unsigned int const   )(sizeof(standard_ioctl_descr) / sizeof(struct iw_ioctl_description ));
#line 2719 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static struct iw_ioctl_description  const  standard_event_descr[10]  = 
#line 2719
  {      {(__u8 )6, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )10, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )256, 0U}, 
        {(__u8 )6, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )6, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )1024, 0U}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )sizeof(struct iw_michaelmicfailure ),
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )1024, 0U}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )1024, 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )sizeof(struct iw_pmkid_cand ),
      0U}};
#line 2763 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static unsigned int const   standard_event_num  =    (unsigned int const   )(sizeof(standard_event_descr) / sizeof(struct iw_ioctl_description ));
#line 2767 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static int const   event_type_size[11]  = 
#line 2767
  {      (int const   )4,      (int const   )0,      (int const   )20,      (int const   )0, 
        (int const   )(4UL + sizeof(__u32 )),      (int const   )(4UL + sizeof(struct iw_freq )),      (int const   )(4UL + sizeof(struct sockaddr )),      (int const   )0, 
        (int const   )8,      (int const   )(4UL + sizeof(struct iw_param )),      (int const   )(4UL + sizeof(struct iw_quality ))};
#line 2786 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
void iw_init_event_stream(struct stream_descr *stream , char *data , int len ) 
{ 


  {
  {
#line 2792
  memset((void *)((char *)stream), '\000', sizeof(struct stream_descr ));
#line 2795
  stream->current = data;
#line 2796
  stream->end = data + len;
  }
#line 2797
  return;
}
}
#line 2803 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
int iw_extract_event_stream(struct stream_descr *stream , struct iw_event *iwe , int we_version ) 
{ 
  struct iw_ioctl_description  const  *descr ;
  int event_type ;
  unsigned int event_len ;
  char *pointer ;
  unsigned int cmd_index ;
  unsigned int extra_len ;
  unsigned int token_len ;
  union iw_align_u16 alt_dlen ;
  unsigned int alt_token_len ;

  {
#line 2808
  descr = (struct iw_ioctl_description  const  *)((void *)0);
#line 2809
  event_type = 0;
#line 2810
  event_len = 1U;
#line 2816
  if ((unsigned long )(stream->current + 4) > (unsigned long )stream->end) {
#line 2817
    return (0);
  }
  {
#line 2826
  memcpy((void */* __restrict  */)((char *)iwe), (void const   */* __restrict  */)stream->current,
         (size_t )4);
  }
#line 2834
  if ((int )iwe->len <= 4) {
#line 2835
    return (-1);
  }
#line 2838
  if ((int )iwe->cmd <= 35839) {
#line 2840
    cmd_index = (unsigned int )((int )iwe->cmd - 35584);
#line 2841
    if (cmd_index < (unsigned int )standard_ioctl_num) {
#line 2842
      descr = & standard_ioctl_descr[cmd_index];
    }
  } else {
#line 2846
    cmd_index = (unsigned int )((int )iwe->cmd - 35840);
#line 2847
    if (cmd_index < (unsigned int )standard_event_num) {
#line 2848
      descr = & standard_event_descr[cmd_index];
    }
  }
#line 2850
  if ((unsigned long )descr != (unsigned long )((void *)0)) {
#line 2851
    event_type = (int )descr->header_type;
  }
#line 2853
  event_len = (unsigned int )event_type_size[event_type];
#line 2855
  if (we_version <= 18) {
#line 2855
    if (event_type == 8) {
#line 2856
      event_len = (unsigned int )((long )event_len + ((char *)(& ((struct iw_point *)((void *)0))->length) - (char *)((void *)0)));
    }
  }
#line 2859
  if (event_len <= 4U) {
#line 2862
    stream->current += (int )iwe->len;
#line 2863
    return (2);
  }
#line 2865
  event_len -= 4U;
#line 2868
  if ((unsigned long )stream->value != (unsigned long )((void *)0)) {
#line 2869
    pointer = stream->value;
  } else {
#line 2871
    pointer = stream->current + 4;
  }
#line 2879
  if ((unsigned long )(pointer + event_len) > (unsigned long )stream->end) {
#line 2882
    stream->current += (int )iwe->len;
#line 2883
    return (-2);
  }
#line 2887
  if (we_version > 18) {
#line 2887
    if (event_type == 8) {
      {
#line 2888
      memcpy((void */* __restrict  */)(((char *)iwe + (sizeof(struct iw_event ) - sizeof(union iwreq_data ))) + ((char *)(& ((struct iw_point *)((void *)0))->length) - (char *)((void *)0))),
             (void const   */* __restrict  */)pointer, (size_t )event_len);
      }
    } else {
      {
#line 2891
      memcpy((void */* __restrict  */)((char *)iwe + (sizeof(struct iw_event ) - sizeof(union iwreq_data ))),
             (void const   */* __restrict  */)pointer, (size_t )event_len);
      }
    }
  } else {
    {
#line 2891
    memcpy((void */* __restrict  */)((char *)iwe + (sizeof(struct iw_event ) - sizeof(union iwreq_data ))),
           (void const   */* __restrict  */)pointer, (size_t )event_len);
    }
  }
#line 2894
  pointer += event_len;
#line 2897
  if (event_type == 8) {
#line 2900
    extra_len = (unsigned int )iwe->len - (event_len + 4U);
#line 2901
    if (extra_len > 0U) {
#line 2904
      iwe->u.data.pointer = (void *)pointer;
#line 2907
      if ((unsigned long )descr == (unsigned long )((void *)0)) {
#line 2909
        iwe->u.data.pointer = (void *)0;
      } else {
#line 2915
        token_len = (unsigned int )((int )iwe->u.data.length * (int )descr->token_size);
#line 2921
        if (token_len != extra_len) {
#line 2921
          if (extra_len >= 4U) {
#line 2928
            alt_dlen.byte[0] = (unsigned char )*pointer;
#line 2929
            alt_dlen.byte[1] = (unsigned char )*(pointer + 1);
#line 2930
            alt_token_len = (unsigned int )((int )alt_dlen.value * (int )descr->token_size);
#line 2936
            if (alt_token_len + 8U == extra_len) {
              {
#line 2939
              pointer -= event_len;
#line 2940
              pointer += 4;
#line 2942
              memcpy((void */* __restrict  */)(((char *)iwe + (sizeof(struct iw_event ) - sizeof(union iwreq_data ))) + ((char *)(& ((struct iw_point *)((void *)0))->length) - (char *)((void *)0))),
                     (void const   */* __restrict  */)pointer, (size_t )event_len);
#line 2944
              pointer += event_len + 4U;
#line 2945
              token_len = alt_token_len;
              }
#line 2947
              if (alt_token_len) {
#line 2948
                iwe->u.data.pointer = (void *)pointer;
              } else {
#line 2950
                iwe->u.data.pointer = (void *)0;
              }
            }
          }
        }
#line 2956
        if (token_len > extra_len) {
#line 2957
          iwe->u.data.pointer = (void *)0;
        }
#line 2960
        if ((int )iwe->u.data.length > (int )descr->max_tokens) {
#line 2960
          if (! (descr->flags & 8U)) {
#line 2962
            iwe->u.data.pointer = (void *)0;
          }
        }
#line 2964
        if ((int )iwe->u.data.length < (int )descr->min_tokens) {
#line 2965
          iwe->u.data.pointer = (void *)0;
        }
      }
    } else {
#line 2974
      iwe->u.data.pointer = (void *)0;
    }
#line 2977
    stream->current += (int )iwe->len;
  } else {
#line 2985
    if ((unsigned long )stream->value == (unsigned long )((void *)0)) {
#line 2985
      if ((unsigned int )((int )iwe->len - 4) % event_len == 4U) {
        {
#line 2993
        pointer -= event_len;
#line 2994
        pointer += 4;
#line 2996
        memcpy((void */* __restrict  */)((char *)iwe + (sizeof(struct iw_event ) - sizeof(union iwreq_data ))),
               (void const   */* __restrict  */)pointer, (size_t )event_len);
#line 2997
        pointer += event_len;
        }
      } else
#line 2985
      if ((int )iwe->len == 12) {
#line 2985
        if (event_type == 4) {
          {
#line 2993
          pointer -= event_len;
#line 2994
          pointer += 4;
#line 2996
          memcpy((void */* __restrict  */)((char *)iwe + (sizeof(struct iw_event ) - sizeof(union iwreq_data ))),
                 (void const   */* __restrict  */)pointer, (size_t )event_len);
#line 2997
          pointer += event_len;
          }
        } else
#line 2985
        if (event_type == 10) {
          {
#line 2993
          pointer -= event_len;
#line 2994
          pointer += 4;
#line 2996
          memcpy((void */* __restrict  */)((char *)iwe + (sizeof(struct iw_event ) - sizeof(union iwreq_data ))),
                 (void const   */* __restrict  */)pointer, (size_t )event_len);
#line 2997
          pointer += event_len;
          }
        }
      }
    }
#line 3001
    if ((unsigned long )(pointer + event_len) <= (unsigned long )(stream->current + (int )iwe->len)) {
#line 3003
      stream->value = pointer;
    } else {
#line 3007
      stream->value = (char *)((void *)0);
#line 3008
      stream->current += (int )iwe->len;
    }
  }
#line 3011
  return (1);
}
}
#line 3048 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
__inline static struct wireless_scan *( __attribute__((__always_inline__)) iw_process_scanning_token)(struct iw_event *event ,
                                                                                                      struct wireless_scan *wscan ) 
{ 
  struct wireless_scan *oldwscan ;
  void *tmp ;

  {
  {
#line 3057
  if ((int )event->cmd == 35605) {
#line 3057
    goto case_35605;
  }
#line 3074
  if ((int )event->cmd == 35587) {
#line 3074
    goto case_35587;
  }
#line 3078
  if ((int )event->cmd == 35589) {
#line 3078
    goto case_35589;
  }
#line 3083
  if ((int )event->cmd == 35591) {
#line 3083
    goto case_35591;
  }
#line 3088
  if ((int )event->cmd == 35611) {
#line 3088
    goto case_35611;
  }
#line 3095
  if ((int )event->cmd == 35627) {
#line 3095
    goto case_35627;
  }
#line 3104
  if ((int )event->cmd == 35841) {
#line 3104
    goto case_35841;
  }
#line 3109
  if ((int )event->cmd == 35617) {
#line 3109
    goto case_35617;
  }
#line 3120
  goto switch_default;
  case_35605: /* CIL Label */ 
  {
#line 3059
  oldwscan = wscan;
#line 3060
  tmp = malloc(sizeof(struct wireless_scan ));
#line 3060
  wscan = (struct wireless_scan *)tmp;
  }
#line 3061
  if ((unsigned long )wscan == (unsigned long )((void *)0)) {
#line 3062
    return (wscan);
  }
#line 3064
  if ((unsigned long )oldwscan != (unsigned long )((void *)0)) {
#line 3065
    oldwscan->next = wscan;
  }
  {
#line 3068
  bzero((void *)wscan, sizeof(struct wireless_scan ));
#line 3071
  wscan->has_ap_addr = 1;
#line 3072
  memcpy((void */* __restrict  */)(& wscan->ap_addr), (void const   */* __restrict  */)(& event->u.ap_addr),
         sizeof(sockaddr ));
  }
#line 3073
  goto switch_break;
  case_35587: /* CIL Label */ 
  {
#line 3075
  wscan->b.has_nwid = 1;
#line 3076
  memcpy((void */* __restrict  */)(& wscan->b.nwid), (void const   */* __restrict  */)(& event->u.nwid),
         sizeof(iwparam ));
  }
#line 3077
  goto switch_break;
  case_35589: /* CIL Label */ 
  {
#line 3079
  wscan->b.has_freq = 1;
#line 3080
  wscan->b.freq = iw_freq2float((iwfreq const   *)(& event->u.freq));
#line 3081
  wscan->b.freq_flags = (int )event->u.freq.flags;
  }
#line 3082
  goto switch_break;
  case_35591: /* CIL Label */ 
#line 3084
  wscan->b.mode = (int )event->u.mode;
#line 3085
  if (wscan->b.mode < 7) {
#line 3085
    if (wscan->b.mode >= 0) {
#line 3086
      wscan->b.has_mode = 1;
    }
  }
#line 3087
  goto switch_break;
  case_35611: /* CIL Label */ 
  {
#line 3089
  wscan->b.has_essid = 1;
#line 3090
  wscan->b.essid_on = (int )event->u.data.flags;
#line 3091
  memset((void *)(wscan->b.essid), '\000', (size_t )33);
  }
#line 3092
  if (event->u.essid.pointer) {
#line 3092
    if (event->u.essid.length) {
      {
#line 3093
      memcpy((void */* __restrict  */)(wscan->b.essid), (void const   */* __restrict  */)event->u.essid.pointer,
             (size_t )event->u.essid.length);
      }
    }
  }
#line 3094
  goto switch_break;
  case_35627: /* CIL Label */ 
#line 3096
  wscan->b.has_key = 1;
#line 3097
  wscan->b.key_size = (int )event->u.data.length;
#line 3098
  wscan->b.key_flags = (int )event->u.data.flags;
#line 3099
  if (event->u.data.pointer) {
    {
#line 3100
    memcpy((void */* __restrict  */)(wscan->b.key), (void const   */* __restrict  */)event->u.essid.pointer,
           (size_t )event->u.data.length);
    }
  } else {
#line 3102
    wscan->b.key_flags |= 2048;
  }
#line 3103
  goto switch_break;
  case_35841: /* CIL Label */ 
  {
#line 3106
  wscan->has_stats = 1;
#line 3107
  memcpy((void */* __restrict  */)(& wscan->stats.qual), (void const   */* __restrict  */)(& event->u.qual),
         sizeof(struct iw_quality ));
  }
#line 3108
  goto switch_break;
  case_35617: /* CIL Label */ 
#line 3112
  if (! wscan->has_maxbitrate) {
    {
#line 3115
    wscan->has_maxbitrate = 1;
#line 3116
    memcpy((void */* __restrict  */)(& wscan->maxbitrate), (void const   */* __restrict  */)(& event->u.bitrate),
           sizeof(iwparam ));
    }
  } else
#line 3112
  if (event->u.bitrate.value > wscan->maxbitrate.value) {
    {
#line 3115
    wscan->has_maxbitrate = 1;
#line 3116
    memcpy((void */* __restrict  */)(& wscan->maxbitrate), (void const   */* __restrict  */)(& event->u.bitrate),
           sizeof(iwparam ));
    }
  }
  switch_default: /* CIL Label */ 
#line 3121
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3124
  return (wscan);
}
}
#line 3136 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
int iw_process_scan(int skfd , char *ifname , int we_version , wireless_scan_head *context ) 
{ 
  struct iwreq wrq ;
  unsigned char *buffer ;
  int buflen ;
  unsigned char *newbuf ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  struct iw_event iwe ;
  struct stream_descr stream ;
  struct wireless_scan *wscan ;
  int ret ;
  int *tmp___7 ;

  {
#line 3143
  buffer = (unsigned char *)((void *)0);
#line 3144
  buflen = 4096;
#line 3148
  (context->retry) ++;
#line 3149
  if (context->retry > 150) {
    {
#line 3151
    tmp = __errno_location();
#line 3151
    *tmp = 62;
    }
#line 3152
    return (-1);
  }
#line 3156
  if (context->retry == 1) {
    {
#line 3159
    wrq.u.data.pointer = (void *)0;
#line 3160
    wrq.u.data.flags = (__u16 )0;
#line 3161
    wrq.u.data.length = (__u16 )0;
#line 3163
    tmp___0 = iw_set_ext(skfd, (char const   *)ifname, 35608, & wrq);
    }
#line 3163
    if (tmp___0 < 0) {
      {
#line 3163
      tmp___1 = __errno_location();
      }
#line 3163
      if (*tmp___1 != 1) {
#line 3165
        return (-1);
      }
    }
#line 3167
    return (250);
  }
  realloc: 
  {
#line 3172
  tmp___2 = realloc((void *)buffer, (size_t )buflen);
#line 3172
  newbuf = (unsigned char *)tmp___2;
  }
#line 3173
  if ((unsigned long )newbuf == (unsigned long )((void *)0)) {
#line 3176
    if (buffer) {
      {
#line 3177
      free((void *)buffer);
      }
    }
    {
#line 3178
    tmp___3 = __errno_location();
#line 3178
    *tmp___3 = 12;
    }
#line 3179
    return (-1);
  }
  {
#line 3181
  buffer = newbuf;
#line 3184
  wrq.u.data.pointer = (void *)buffer;
#line 3185
  wrq.u.data.flags = (__u16 )0;
#line 3186
  wrq.u.data.length = (__u16 )buflen;
#line 3187
  tmp___6 = iw_set_ext(skfd, (char const   *)ifname, 35609, & wrq);
  }
#line 3187
  if (tmp___6 < 0) {
    {
#line 3190
    tmp___4 = __errno_location();
    }
#line 3190
    if (*tmp___4 == 7) {
#line 3190
      if (we_version > 16) {
#line 3190
        if (buflen < 65535) {
#line 3201
          if ((int )wrq.u.data.length > buflen) {
#line 3202
            buflen = (int )wrq.u.data.length;
          } else {
#line 3204
            buflen *= 2;
          }
#line 3207
          if (buflen > 65535) {
#line 3208
            buflen = 65535;
          }
#line 3211
          goto realloc;
        }
      }
    }
    {
#line 3215
    tmp___5 = __errno_location();
    }
#line 3215
    if (*tmp___5 == 11) {
      {
#line 3217
      free((void *)buffer);
      }
#line 3219
      return (100);
    }
    {
#line 3222
    free((void *)buffer);
    }
#line 3224
    return (-1);
  }
#line 3228
  if (wrq.u.data.length) {
    {
#line 3232
    wscan = (struct wireless_scan *)((void *)0);
#line 3244
    iw_init_event_stream(& stream, (char *)buffer, (int )wrq.u.data.length);
#line 3246
    context->result = (wireless_scan *)((void *)0);
    }
    {
#line 3249
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 3252
      ret = iw_extract_event_stream(& stream, & iwe, we_version);
      }
#line 3253
      if (ret > 0) {
        {
#line 3256
        wscan = iw_process_scanning_token(& iwe, wscan);
        }
#line 3258
        if ((unsigned long )wscan == (unsigned long )((void *)0)) {
          {
#line 3260
          free((void *)buffer);
#line 3261
          tmp___7 = __errno_location();
#line 3261
          *tmp___7 = 12;
          }
#line 3262
          return (-1);
        }
#line 3265
        if ((unsigned long )context->result == (unsigned long )((void *)0)) {
#line 3266
          context->result = wscan;
        }
      }
#line 3249
      if (! (ret > 0)) {
#line 3249
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 3273
  free((void *)buffer);
  }
#line 3274
  return (0);
}
}
#line 3295 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
int iw_scan(int skfd , char *ifname , int we_version , wireless_scan_head *context ) 
{ 
  int delay ;

  {
#line 3304
  context->result = (wireless_scan *)((void *)0);
#line 3305
  context->retry = 0;
  {
#line 3308
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3311
    delay = iw_process_scan(skfd, ifname, we_version, context);
    }
#line 3314
    if (delay <= 0) {
#line 3315
      goto while_break;
    }
    {
#line 3318
    usleep((__useconds_t )(delay * 1000));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3322
  return (delay);
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 71 "/usr/include/getopt.h"
extern int optind ;
#line 173
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 81 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwgetid.c"
static int print_essid(int skfd , char const   *ifname , int format ) 
{ 
  struct iwreq wrq ;
  char essid[34] ;
  char pessid[129] ;
  unsigned int i ;
  unsigned int j ;
  int tmp ;
  unsigned int tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  {
#line 93
  memset((void *)(essid), 0, sizeof(essid));
#line 96
  wrq.u.essid.pointer = (void *)(essid);
#line 97
  wrq.u.essid.length = (__u16 )34;
#line 98
  wrq.u.essid.flags = (__u16 )0;
#line 99
  tmp = iw_set_ext(skfd, ifname, 35611, & wrq);
  }
#line 99
  if (tmp < 0) {
#line 100
    return (-1);
  }
  {
#line 104
  if (format == 1) {
#line 104
    goto case_1;
  }
#line 115
  if (format == 2) {
#line 115
    goto case_2;
  }
#line 118
  goto switch_default;
  case_1: /* CIL Label */ 
#line 106
  j = 0U;
#line 107
  i = 0U;
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    if (! (i < (unsigned int )wrq.u.essid.length)) {
#line 107
      goto while_break;
    }
    {
#line 108
    tmp___1 = __ctype_b_loc();
    }
#line 108
    if ((int const   )*(*tmp___1 + (int )essid[i]) & 8) {
#line 109
      tmp___0 = j;
#line 109
      j ++;
#line 109
      pessid[tmp___0] = essid[i];
    }
#line 107
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  pessid[j] = (char )'\000';
#line 111
  if (j == 0U) {
#line 112
    return (-2);
  } else
#line 111
  if (j > 32U) {
#line 112
    return (-2);
  }
  {
#line 113
  printf((char const   */* __restrict  */)"%s\n", pessid);
  }
#line 114
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 116
  printf((char const   */* __restrict  */)"%s\n", essid);
  }
#line 117
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 119
  iw_essid_escape(pessid, (char const   *)(essid), (int const   )wrq.u.essid.length);
#line 120
  printf((char const   */* __restrict  */)"%-8.16s  ESSID:\"%s\"\n", ifname, pessid);
  }
#line 121
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 124
  return (0);
}
}
#line 131 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwgetid.c"
static int print_nwid(int skfd , char const   *ifname , int format ) 
{ 
  struct iwreq wrq ;
  int tmp ;

  {
  {
#line 139
  tmp = iw_set_ext(skfd, ifname, 35587, & wrq);
  }
#line 139
  if (tmp < 0) {
#line 140
    return (-1);
  }
  {
#line 144
  if (format == 1) {
#line 144
    goto case_1;
  }
#line 148
  if (format == 2) {
#line 148
    goto case_2;
  }
#line 151
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 146
  printf((char const   */* __restrict  */)"nwid%X\n", wrq.u.nwid.value);
  }
#line 147
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 149
  printf((char const   */* __restrict  */)"%X\n", wrq.u.nwid.value);
  }
#line 150
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 152
  printf((char const   */* __restrict  */)"%-8.16s  NWID:%X\n", ifname, wrq.u.nwid.value);
  }
#line 153
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 156
  return (0);
}
}
#line 165 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwgetid.c"
static int print_ap(int skfd , char const   *ifname , int format ) 
{ 
  struct iwreq wrq ;
  char buffer[64] ;
  int tmp ;

  {
  {
#line 174
  tmp = iw_set_ext(skfd, ifname, 35605, & wrq);
  }
#line 174
  if (tmp < 0) {
#line 175
    return (-1);
  }
  {
#line 178
  iw_ether_ntop((struct ether_addr  const  *)(wrq.u.ap_addr.sa_data), buffer);
  }
  {
#line 184
  if (format == 2) {
#line 184
    goto case_2;
  }
#line 184
  if (format == 1) {
#line 184
    goto case_2;
  }
#line 187
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 185
  printf((char const   */* __restrict  */)"%s\n", buffer);
  }
#line 186
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 188
  printf((char const   */* __restrict  */)"%-8.16s  Access Point/Cell: %s\n", ifname,
         buffer);
  }
#line 189
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 192
  return (0);
}
}
#line 201 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwgetid.c"
static int print_freq(int skfd , char const   *ifname , int format ) 
{ 
  struct iwreq wrq ;
  double freq ;
  char buffer[64] ;
  int tmp ;

  {
  {
#line 211
  tmp = iw_set_ext(skfd, ifname, 35589, & wrq);
  }
#line 211
  if (tmp < 0) {
#line 212
    return (-1);
  }
  {
#line 215
  freq = iw_freq2float((iwfreq const   *)(& wrq.u.freq));
  }
  {
#line 218
  if (format == 1) {
#line 218
    goto case_1;
  }
#line 222
  if (format == 2) {
#line 222
    goto case_2;
  }
#line 225
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 220
  printf((char const   */* __restrict  */)"freq%g\n", freq);
  }
#line 221
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 223
  printf((char const   */* __restrict  */)"%g\n", freq);
  }
#line 224
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 226
  iw_print_freq(buffer, (int )sizeof(buffer), freq, -1, (int )wrq.u.freq.flags);
#line 227
  printf((char const   */* __restrict  */)"%-8.16s  %s\n", ifname, buffer);
  }
#line 228
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 231
  return (0);
}
}
#line 238 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwgetid.c"
static int print_channel(int skfd , char const   *ifname , int format ) 
{ 
  struct iwreq wrq ;
  struct iw_range range ;
  double freq ;
  int channel ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 249
  tmp = iw_set_ext(skfd, ifname, 35589, & wrq);
  }
#line 249
  if (tmp < 0) {
#line 250
    return (-1);
  }
  {
#line 253
  tmp___0 = iw_get_range_info(skfd, ifname, & range);
  }
#line 253
  if (tmp___0 < 0) {
#line 254
    return (-2);
  }
  {
#line 255
  freq = iw_freq2float((iwfreq const   *)(& wrq.u.freq));
  }
#line 256
  if (freq < 1e3) {
#line 257
    channel = (int )freq;
  } else {
    {
#line 260
    channel = iw_freq_to_channel(freq, (struct iw_range  const  *)(& range));
    }
#line 261
    if (channel < 0) {
#line 262
      return (-3);
    }
  }
  {
#line 268
  if (format == 1) {
#line 268
    goto case_1;
  }
#line 272
  if (format == 2) {
#line 272
    goto case_2;
  }
#line 275
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 270
  printf((char const   */* __restrict  */)"channel%d\n", channel);
  }
#line 271
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 273
  printf((char const   */* __restrict  */)"%d\n", channel);
  }
#line 274
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 276
  printf((char const   */* __restrict  */)"%-8.16s  Channel:%d\n", ifname, channel);
  }
#line 277
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 280
  return (0);
}
}
#line 287 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwgetid.c"
static int print_mode(int skfd , char const   *ifname , int format ) 
{ 
  struct iwreq wrq ;
  int tmp ;

  {
  {
#line 295
  tmp = iw_set_ext(skfd, ifname, 35591, & wrq);
  }
#line 295
  if (tmp < 0) {
#line 296
    return (-1);
  }
#line 297
  if (wrq.u.mode >= 7U) {
#line 298
    return (-2);
  }
  {
#line 303
  if (format == 1) {
#line 303
    goto case_1;
  }
#line 310
  if (format == 2) {
#line 310
    goto case_2;
  }
#line 313
  goto switch_default;
  case_1: /* CIL Label */ 
#line 305
  if (wrq.u.mode == 1U) {
    {
#line 306
    printf((char const   */* __restrict  */)"AdHoc\n");
    }
  } else {
    {
#line 308
    printf((char const   */* __restrict  */)"%s\n", iw_operation_mode[wrq.u.mode]);
    }
  }
#line 309
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 311
  printf((char const   */* __restrict  */)"%d\n", wrq.u.mode);
  }
#line 312
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 314
  printf((char const   */* __restrict  */)"%-8.16s  Mode:%s\n", ifname, iw_operation_mode[wrq.u.mode]);
  }
#line 315
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 318
  return (0);
}
}
#line 325 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwgetid.c"
static int print_protocol(int skfd , char const   *ifname , int format ) 
{ 
  struct iwreq wrq ;
  char proto[17] ;
  char pproto[17] ;
  unsigned int i ;
  unsigned int j ;
  int tmp ;
  unsigned int tmp___0 ;
  unsigned short const   **tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 337
  tmp = iw_set_ext(skfd, ifname, 35585, & wrq);
  }
#line 337
  if (tmp < 0) {
#line 338
    return (-1);
  }
  {
#line 339
  strncpy((char */* __restrict  */)(proto), (char const   */* __restrict  */)(wrq.u.name),
          (size_t )16);
#line 340
  proto[16] = (char )'\000';
  }
  {
#line 344
  if (format == 1) {
#line 344
    goto case_1;
  }
#line 355
  if (format == 2) {
#line 355
    goto case_2;
  }
#line 358
  goto switch_default;
  case_1: /* CIL Label */ 
#line 346
  j = 0U;
#line 347
  i = 0U;
  {
#line 347
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 347
    tmp___2 = strlen((char const   *)(proto));
    }
#line 347
    if (! ((size_t )i < tmp___2)) {
#line 347
      goto while_break;
    }
    {
#line 348
    tmp___1 = __ctype_b_loc();
    }
#line 348
    if ((int const   )*(*tmp___1 + (int )proto[i]) & 8) {
#line 349
      tmp___0 = j;
#line 349
      j ++;
#line 349
      pproto[tmp___0] = proto[i];
    }
#line 347
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 350
  pproto[j] = (char )'\000';
#line 351
  if (j == 0U) {
#line 352
    return (-2);
  } else
#line 351
  if (j > 32U) {
#line 352
    return (-2);
  }
  {
#line 353
  printf((char const   */* __restrict  */)"%s\n", pproto);
  }
#line 354
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 356
  printf((char const   */* __restrict  */)"%s\n", proto);
  }
#line 357
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 359
  printf((char const   */* __restrict  */)"%-8.16s  Protocol Name:\"%s\"\n", ifname,
         proto);
  }
#line 360
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 363
  return (0);
}
}
#line 372 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwgetid.c"
static int print_one_device(int skfd , int format , int wtype , char const   *ifname ) 
{ 
  int ret ;

  {
  {
#line 383
  if (wtype == 1) {
#line 383
    goto case_1;
  }
#line 388
  if (wtype == 3) {
#line 388
    goto case_3;
  }
#line 393
  if (wtype == 2) {
#line 393
    goto case_2;
  }
#line 398
  if (wtype == 4) {
#line 398
    goto case_4;
  }
#line 403
  if (wtype == 5) {
#line 403
    goto case_5;
  }
#line 408
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 385
  ret = print_ap(skfd, ifname, format);
  }
#line 386
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 390
  ret = print_channel(skfd, ifname, format);
  }
#line 391
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 395
  ret = print_freq(skfd, ifname, format);
  }
#line 396
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 400
  ret = print_mode(skfd, ifname, format);
  }
#line 401
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 405
  ret = print_protocol(skfd, ifname, format);
  }
#line 406
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 410
  ret = print_essid(skfd, ifname, format);
  }
#line 411
  if (ret < 0) {
    {
#line 414
    ret = print_nwid(skfd, ifname, format);
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 418
  return (ret);
}
}
#line 430 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwgetid.c"
static int scan_devices(int skfd , int format , int wtype ) 
{ 
  char buff[1024] ;
  struct ifconf ifc ;
  struct ifreq *ifr ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 441
  ifc.ifc_len = (int )sizeof(buff);
#line 442
  ifc.ifc_ifcu.ifcu_buf = buff;
#line 443
  tmp = ioctl(skfd, 35090UL, & ifc);
  }
#line 443
  if (tmp < 0) {
    {
#line 445
    perror("SIOCGIFCONF");
    }
#line 446
    return (-1);
  }
#line 448
  ifr = ifc.ifc_ifcu.ifcu_req;
#line 451
  i = (int )((unsigned long )ifc.ifc_len / sizeof(struct ifreq ));
  {
#line 451
  while (1) {
    while_continue: /* CIL Label */ ;
#line 451
    i --;
#line 451
    if (! (i >= 0)) {
#line 451
      goto while_break;
    }
    {
#line 453
    tmp___0 = print_one_device(skfd, format, wtype, (char const   *)(ifr->ifr_ifrn.ifrn_name));
    }
#line 453
    if (tmp___0 >= 0) {
#line 454
      return (0);
    }
#line 451
    ifr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 456
  return (-1);
}
}
#line 463 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwgetid.c"
static void iw_usage(int status ) 
{ 
  struct _IO_FILE *tmp ;

  {
#line 466
  if (status) {
#line 466
    tmp = stderr;
  } else {
#line 466
    tmp = stdout;
  }
  {
#line 466
  fputs((char const   */* __restrict  */)"Usage iwgetid [OPTIONS] [ifname]\n  Options are:\n    -a,--ap       Print the access point address\n    -c,--channel  Print the current channel\n    -f,--freq     Print the current frequency\n    -m,--mode     Print the current mode\n    -p,--protocol Print the protocol name\n    -r,--raw      Format the output as raw value for shell scripts\n    -s,--scheme   Format the output as a PCMCIA scheme identifier\n    -h,--help     Print this message\n",
        (FILE */* __restrict  */)tmp);
#line 477
  exit(status);
  }
}
}
#line 480 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwgetid.c"
static struct option  const  long_opts[9]  = 
#line 480
  {      {"ap", 0, (int *)((void *)0), 'a'}, 
        {"channel", 0, (int *)((void *)0), 'c'}, 
        {"freq", 0, (int *)((void *)0), 'f'}, 
        {"mode", 0, (int *)((void *)0), 'm'}, 
        {"protocol", 0, (int *)((void *)0), 'p'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {"raw", 0, (int *)((void *)0), 'r'}, 
        {"scheme", 0, (int *)((void *)0), 's'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 496 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwgetid.c"
int main(int argc , char **argv ) 
{ 
  int skfd ;
  int format ;
  int wtype ;
  int opt ;
  int ret ;

  {
#line 501
  format = 0;
#line 502
  wtype = 0;
#line 504
  ret = -1;
  {
#line 507
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 507
    opt = getopt_long(argc, (char * const  *)argv, "acfhmprs", long_opts, (int *)((void *)0));
    }
#line 507
    if (! (opt > 0)) {
#line 507
      goto while_break;
    }
    {
#line 511
    if (opt == 97) {
#line 511
      goto case_97;
    }
#line 516
    if (opt == 99) {
#line 516
      goto case_99;
    }
#line 521
    if (opt == 102) {
#line 521
      goto case_102;
    }
#line 526
    if (opt == 109) {
#line 526
      goto case_109;
    }
#line 531
    if (opt == 112) {
#line 531
      goto case_112;
    }
#line 536
    if (opt == 104) {
#line 536
      goto case_104;
    }
#line 540
    if (opt == 114) {
#line 540
      goto case_114;
    }
#line 545
    if (opt == 115) {
#line 545
      goto case_115;
    }
#line 550
    goto switch_default;
    case_97: /* CIL Label */ 
#line 513
    wtype = 1;
#line 514
    goto switch_break;
    case_99: /* CIL Label */ 
#line 518
    wtype = 3;
#line 519
    goto switch_break;
    case_102: /* CIL Label */ 
#line 523
    wtype = 2;
#line 524
    goto switch_break;
    case_109: /* CIL Label */ 
#line 528
    wtype = 4;
#line 529
    goto switch_break;
    case_112: /* CIL Label */ 
#line 533
    wtype = 5;
#line 534
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 537
    iw_usage(0);
    }
#line 538
    goto switch_break;
    case_114: /* CIL Label */ 
#line 542
    format = 2;
#line 543
    goto switch_break;
    case_115: /* CIL Label */ 
#line 547
    format = 1;
#line 548
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 551
    iw_usage(1);
    }
#line 552
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 555
  if (optind + 1 < argc) {
    {
#line 556
    fputs((char const   */* __restrict  */)"Too many arguments.\n", (FILE */* __restrict  */)stderr);
#line 557
    iw_usage(1);
    }
  }
  {
#line 561
  skfd = iw_sockets_open();
  }
#line 561
  if (skfd < 0) {
    {
#line 563
    perror("socket");
    }
#line 564
    return (-1);
  }
#line 568
  if (optind < argc) {
    {
#line 571
    ret = print_one_device(skfd, format, wtype, (char const   *)*(argv + optind));
    }
  } else {
    {
#line 576
    ret = scan_devices(skfd, format, wtype);
    }
  }
  {
#line 579
  fflush(stdout);
#line 580
  iw_sockets_close(skfd);
  }
#line 581
  return (ret);
}
}
#line 164 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static int const   families___0[4]  = {      (int const   )2,      (int const   )4,      (int const   )3,      (int const   )5};
#line 381 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static int print_iface_version_info___0(int skfd , char *ifname , char **args , int count ) 
{ 
  struct iwreq wrq ;
  char buffer[sizeof(iwrange ) * 2UL] ;
  struct iw_range *range ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 392
  args = args;
#line 392
  count = count;
#line 396
  tmp = iw_set_ext(skfd, (char const   *)ifname, 35585, & wrq);
  }
#line 396
  if (tmp < 0) {
#line 397
    return (-1);
  }
  {
#line 400
  memset((void *)(buffer), 0, sizeof(buffer));
#line 402
  wrq.u.data.pointer = (void *)(buffer);
#line 403
  wrq.u.data.length = (__u16 )sizeof(buffer);
#line 404
  wrq.u.data.flags = (__u16 )0;
#line 405
  tmp___0 = iw_set_ext(skfd, (char const   *)ifname, 35595, & wrq);
  }
#line 405
  if (tmp___0 < 0) {
    {
#line 408
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  Driver has no Wireless Extension version information.\n\n",
            ifname);
    }
#line 409
    return (0);
  }
#line 413
  range = (struct iw_range *)(buffer);
#line 417
  if ((int )wrq.u.data.length >= 300) {
    {
#line 420
    printf((char const   */* __restrict  */)"%-8.16s  Recommend Wireless Extension v%d or later,\n",
           ifname, (int )range->we_version_source);
#line 422
    printf((char const   */* __restrict  */)"          Currently compiled with Wireless Extension v%d.\n\n",
           (int )range->we_version_compiled);
    }
  } else {
    {
#line 427
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  Wireless Extension version too old.\n\n",
            ifname);
    }
  }
#line 432
  return (0);
}
}
#line 1687 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static int iw_pass_key___0(char const   *input , unsigned char *key ) 
{ 


  {
  {
#line 1691
  input = input;
#line 1691
  key = key;
#line 1692
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Passphrase not implemented\n");
  }
#line 1693
  return (-1);
}
}
#line 2402 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static int const   priv_type_size___0[8]  = 
#line 2402
  {      (int const   )0,      (int const   )1,      (int const   )1,      (int const   )0, 
        (int const   )sizeof(__u32 ),      (int const   )sizeof(struct iw_freq ),      (int const   )sizeof(struct sockaddr ),      (int const   )0};
#line 2480 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static struct iw_ioctl_description  const  standard_ioctl_descr___0[55]  = 
#line 2480
  {      {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )2, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )2}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )5, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )2}, 
        {(__u8 )5, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )4, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )2}, 
        {(__u8 )4, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )sizeof(struct iw_range ),
      (__u32 )1}, 
        {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )8, (unsigned char)0, (__u16 )sizeof(struct sockaddr ), (unsigned short)0,
      (__u16 )8, 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )(sizeof(struct sockaddr ) + sizeof(struct iw_quality )),
      (unsigned short)0, (__u16 )8, 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )sizeof(struct iw_thrspy ), (__u16 )1, (__u16 )1,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )sizeof(struct iw_thrspy ), (__u16 )1, (__u16 )1,
      0U}, 
        {(__u8 )6, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )6, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (__u16 )sizeof(struct iw_mlme ), (__u16 )sizeof(struct iw_mlme ),
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )(sizeof(struct sockaddr ) + sizeof(struct iw_quality )),
      (unsigned short)0, (__u16 )64, (__u32 )8}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (__u16 )0, (__u16 )sizeof(struct iw_scan_req ),
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )4096, (__u32 )8}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )33, (__u32 )2}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )33, (__u32 )1}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )33, 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )33, 0U}, 
        {(unsigned char)0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(unsigned char)0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )0, (unsigned short)0, (__u16 )64, (__u32 )6}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )0, (unsigned short)0, (__u16 )64, (__u32 )5}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )1024, 0U}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )1024, 0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (__u16 )sizeof(struct iw_encode_ext ),
      (__u16 )(sizeof(struct iw_encode_ext ) + 64UL), 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (__u16 )sizeof(struct iw_encode_ext ),
      (__u16 )(sizeof(struct iw_encode_ext ) + 64UL), 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (__u16 )sizeof(struct iw_pmksa ), (__u16 )sizeof(struct iw_pmksa ),
      0U}};
#line 2712 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static unsigned int const   standard_ioctl_num___0  =    (unsigned int const   )(sizeof(standard_ioctl_descr___0) / sizeof(struct iw_ioctl_description ));
#line 2719 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static struct iw_ioctl_description  const  standard_event_descr___0[10]  = 
#line 2719
  {      {(__u8 )6, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )10, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )256, 0U}, 
        {(__u8 )6, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )6, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )1024, 0U}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )sizeof(struct iw_michaelmicfailure ),
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )1024, 0U}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )1024, 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )sizeof(struct iw_pmkid_cand ),
      0U}};
#line 2763 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static unsigned int const   standard_event_num___0  =    (unsigned int const   )(sizeof(standard_event_descr___0) / sizeof(struct iw_ioctl_description ));
#line 2767 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static int const   event_type_size___0[11]  = 
#line 2767
  {      (int const   )4,      (int const   )0,      (int const   )20,      (int const   )0, 
        (int const   )(4UL + sizeof(__u32 )),      (int const   )(4UL + sizeof(struct iw_freq )),      (int const   )(4UL + sizeof(struct sockaddr )),      (int const   )0, 
        (int const   )8,      (int const   )(4UL + sizeof(struct iw_param )),      (int const   )(4UL + sizeof(struct iw_quality ))};
#line 118 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib-private.h"
__inline static char *( __attribute__((__always_inline__)) iw_saether_ntop)(struct sockaddr  const  *sap ,
                                                                            char *bufp ) 
{ 


  {
  {
#line 121
  iw_ether_ntop((struct ether_addr  const  *)(sap->sa_data), bufp);
  }
#line 122
  return (bufp);
}
}
#line 231 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwpriv.c"
static char const   *argtype[7]  = {      "     ",      "byte ",      "char ",      "", 
        "int  ",      "float",      "addr "};
#line 240 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwpriv.c"
static void iw_usage___0(void) 
{ 


  {
  {
#line 243
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: iwpriv interface [private-command [private-arguments]]\n");
  }
#line 244
  return;
}
}
#line 252 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwpriv.c"
static int set_private_cmd(int skfd , char **args , int count , char *ifname , char *cmdname ,
                           iwprivargs *priv , int priv_num ) 
{ 
  struct iwreq wrq ;
  u_char buffer[4096] ;
  int i ;
  int k ;
  int temp ;
  int subcmd ;
  int offset ;
  int tmp ;
  int tmp___0 ;
  int j ;
  size_t tmp___1 ;
  double freq ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int j___0 ;
  int n ;
  int tmp___12 ;
  double freq___0 ;
  char scratch[128] ;
  struct sockaddr *hwa ;
  size_t tmp___13 ;
  char *tmp___14 ;

  {
#line 263
  i = 0;
#line 266
  subcmd = 0;
#line 267
  offset = 0;
#line 272
  if (count >= 1) {
    {
#line 272
    tmp = sscanf((char const   */* __restrict  */)*(args + 0), (char const   */* __restrict  */)"[%i]",
                 & temp);
    }
#line 272
    if (tmp == 1) {
#line 274
      subcmd = temp;
#line 275
      args ++;
#line 276
      count --;
    }
  }
#line 280
  k = -1;
  {
#line 281
  while (1) {
    while_continue: /* CIL Label */ ;
#line 281
    k ++;
#line 281
    if (k < priv_num) {
      {
#line 281
      tmp___0 = strcmp((char const   *)((priv + k)->name), (char const   *)cmdname);
      }
#line 281
      if (! tmp___0) {
#line 281
        goto while_break;
      }
    } else {
#line 281
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 284
  if (k == priv_num) {
    {
#line 286
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid command : %s\n",
            cmdname);
    }
#line 287
    return (-1);
  }
#line 291
  if ((priv + k)->cmd < 35312U) {
#line 293
    j = -1;
    {
#line 296
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 296
      j ++;
#line 296
      if (j < priv_num) {
#line 296
        if (! ((int )(priv + j)->name[0] != 0)) {
#line 296
          if (! ((int )(priv + j)->set_args != (int )(priv + k)->set_args)) {
#line 296
            if (! ((int )(priv + j)->get_args != (int )(priv + k)->get_args)) {
#line 296
              goto while_break___0;
            }
          }
        }
      } else {
#line 296
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 301
    if (j == priv_num) {
      {
#line 303
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid private ioctl definition for : %s\n",
              cmdname);
      }
#line 305
      return (-1);
    }
#line 309
    subcmd = (int )(priv + k)->cmd;
#line 311
    offset = (int )sizeof(__u32 );
#line 313
    k = j;
  }
#line 322
  if ((int )(priv + k)->set_args & 28672) {
#line 322
    if ((int )(priv + k)->set_args & 2047) {
      {
#line 327
      if (((int )(priv + k)->set_args & 28672) == 4096) {
#line 327
        goto case_4096;
      }
#line 340
      if (((int )(priv + k)->set_args & 28672) == 16384) {
#line 340
        goto case_16384;
      }
#line 353
      if (((int )(priv + k)->set_args & 28672) == 8192) {
#line 353
        goto case_8192;
      }
#line 373
      if (((int )(priv + k)->set_args & 28672) == 20480) {
#line 373
        goto case_20480;
      }
#line 395
      if (((int )(priv + k)->set_args & 28672) == 24576) {
#line 395
        goto case_24576;
      }
#line 412
      goto switch_default;
      case_4096: /* CIL Label */ 
#line 329
      wrq.u.data.length = (__u16 )count;
#line 330
      if ((int )wrq.u.data.length > ((int )(priv + k)->set_args & 2047)) {
#line 331
        wrq.u.data.length = (__u16 )((int )(priv + k)->set_args & 2047);
      }
      {
#line 334
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 334
        if (! (i < (int )wrq.u.data.length)) {
#line 334
          goto while_break___1;
        }
        {
#line 335
        sscanf((char const   */* __restrict  */)*(args + i), (char const   */* __restrict  */)"%i",
               & temp);
#line 336
        buffer[i] = (u_char )((char )temp);
#line 334
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 338
      goto switch_break;
      case_16384: /* CIL Label */ 
#line 342
      wrq.u.data.length = (__u16 )count;
#line 343
      if ((int )wrq.u.data.length > ((int )(priv + k)->set_args & 2047)) {
#line 344
        wrq.u.data.length = (__u16 )((int )(priv + k)->set_args & 2047);
      }
      {
#line 347
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 347
        if (! (i < (int )wrq.u.data.length)) {
#line 347
          goto while_break___2;
        }
        {
#line 348
        sscanf((char const   */* __restrict  */)*(args + i), (char const   */* __restrict  */)"%i",
               & temp);
#line 349
        *((__s32 *)(buffer) + i) = temp;
#line 347
        i ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 351
      goto switch_break;
      case_8192: /* CIL Label */ 
#line 354
      if (i < count) {
        {
#line 357
        tmp___1 = strlen((char const   *)*(args + i));
#line 357
        wrq.u.data.length = (__u16 )(tmp___1 + 1UL);
        }
#line 358
        if ((int )wrq.u.data.length > ((int )(priv + k)->set_args & 2047)) {
#line 359
          wrq.u.data.length = (__u16 )((int )(priv + k)->set_args & 2047);
        }
        {
#line 362
        memcpy((void */* __restrict  */)(buffer), (void const   */* __restrict  */)*(args + i),
               (size_t )wrq.u.data.length);
#line 363
        buffer[sizeof(buffer) - 1UL] = (u_char )'\000';
#line 364
        i ++;
        }
      } else {
#line 368
        wrq.u.data.length = (__u16 )1;
#line 369
        buffer[0] = (u_char )'\000';
      }
#line 371
      goto switch_break;
      case_20480: /* CIL Label */ 
#line 375
      wrq.u.data.length = (__u16 )count;
#line 376
      if ((int )wrq.u.data.length > ((int )(priv + k)->set_args & 2047)) {
#line 377
        wrq.u.data.length = (__u16 )((int )(priv + k)->set_args & 2047);
      }
      {
#line 380
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 380
        if (! (i < (int )wrq.u.data.length)) {
#line 380
          goto while_break___3;
        }
        {
#line 382
        tmp___2 = sscanf((char const   */* __restrict  */)*(args + i), (char const   */* __restrict  */)"%lg",
                         & freq);
        }
#line 382
        if (tmp___2 != 1) {
          {
#line 384
          printf((char const   */* __restrict  */)"Invalid float [%s]...\n", *(args + i));
          }
#line 385
          return (-1);
        }
        {
#line 387
        tmp___3 = strchr((char const   *)*(args + i), 'G');
        }
#line 387
        if (tmp___3) {
#line 387
          freq *= 1e9;
        }
        {
#line 388
        tmp___4 = strchr((char const   *)*(args + i), 'M');
        }
#line 388
        if (tmp___4) {
#line 388
          freq *= 1e6;
        }
        {
#line 389
        tmp___5 = strchr((char const   *)*(args + i), 'k');
        }
#line 389
        if (tmp___5) {
#line 389
          freq *= 1e3;
        }
        {
#line 390
        sscanf((char const   */* __restrict  */)*(args + i), (char const   */* __restrict  */)"%i",
               & temp);
#line 391
        iw_float2freq(freq, (struct iw_freq *)(buffer) + i);
#line 380
        i ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 393
      goto switch_break;
      case_24576: /* CIL Label */ 
#line 397
      wrq.u.data.length = (__u16 )count;
#line 398
      if ((int )wrq.u.data.length > ((int )(priv + k)->set_args & 2047)) {
#line 399
        wrq.u.data.length = (__u16 )((int )(priv + k)->set_args & 2047);
      }
      {
#line 402
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 402
        if (! (i < (int )wrq.u.data.length)) {
#line 402
          goto while_break___4;
        }
        {
#line 403
        tmp___6 = iw_in_addr(skfd, (char const   *)ifname, *(args + i), (struct sockaddr *)(buffer) + i);
        }
#line 403
        if (tmp___6 < 0) {
          {
#line 406
          printf((char const   */* __restrict  */)"Invalid address [%s]...\n", *(args + i));
          }
#line 407
          return (-1);
        }
#line 402
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 410
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 413
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not implemented...\n");
      }
#line 414
      return (-1);
      switch_break: /* CIL Label */ ;
      }
#line 417
      if ((int )(priv + k)->set_args & 2048) {
#line 417
        if ((int )wrq.u.data.length != ((int )(priv + k)->set_args & 2047)) {
          {
#line 420
          printf((char const   */* __restrict  */)"The command %s needs exactly %d argument(s)...\n",
                 cmdname, (int )(priv + k)->set_args & 2047);
          }
#line 422
          return (-1);
        }
      }
    } else {
#line 427
      wrq.u.data.length = (__u16 )0L;
    }
  } else {
#line 427
    wrq.u.data.length = (__u16 )0L;
  }
  {
#line 430
  strncpy((char */* __restrict  */)(wrq.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)ifname,
          (size_t )16);
  }
#line 434
  if ((int )(priv + k)->set_args & 2048) {
    {
#line 434
    tmp___8 = iw_get_priv_size((int )(priv + k)->set_args);
    }
#line 434
    if (tmp___8 + offset <= 16) {
#line 438
      if (offset) {
#line 439
        wrq.u.mode = (__u32 )subcmd;
      }
      {
#line 440
      memcpy((void */* __restrict  */)(wrq.u.name + offset), (void const   */* __restrict  */)(buffer),
             (size_t )(16 - offset));
      }
    } else {
#line 434
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 444
  if ((int )(priv + k)->set_args == 0) {
#line 444
    if ((int )(priv + k)->get_args & 2048) {
      {
#line 444
      tmp___7 = iw_get_priv_size((int )(priv + k)->get_args);
      }
#line 444
      if (tmp___7 <= 16) {
#line 449
        if (offset) {
#line 450
          wrq.u.mode = (__u32 )subcmd;
        }
      } else {
#line 455
        wrq.u.data.pointer = (void *)((caddr_t )(buffer));
#line 456
        wrq.u.data.flags = (__u16 )subcmd;
      }
    } else {
#line 455
      wrq.u.data.pointer = (void *)((caddr_t )(buffer));
#line 456
      wrq.u.data.flags = (__u16 )subcmd;
    }
  } else {
#line 455
    wrq.u.data.pointer = (void *)((caddr_t )(buffer));
#line 456
    wrq.u.data.flags = (__u16 )subcmd;
  }
  {
#line 461
  tmp___11 = ioctl(skfd, (unsigned long )(priv + k)->cmd, & wrq);
  }
#line 461
  if (tmp___11 < 0) {
    {
#line 463
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Interface doesn\'t accept private ioctl...\n");
#line 464
    tmp___9 = __errno_location();
#line 464
    tmp___10 = strerror(*tmp___9);
#line 464
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s (%X): %s\n",
            cmdname, (priv + k)->cmd, tmp___10);
    }
#line 465
    return (-1);
  }
#line 469
  if ((int )(priv + k)->get_args & 28672) {
#line 469
    if ((int )(priv + k)->get_args & 2047) {
      {
#line 473
      n = 0;
#line 475
      printf((char const   */* __restrict  */)"%-8.16s  %s:", ifname, cmdname);
      }
#line 478
      if ((int )(priv + k)->get_args & 2048) {
        {
#line 478
        tmp___12 = iw_get_priv_size((int )(priv + k)->get_args);
        }
#line 478
        if (tmp___12 <= 16) {
          {
#line 481
          memcpy((void */* __restrict  */)(buffer), (void const   */* __restrict  */)(wrq.u.name),
                 (size_t )16);
#line 482
          n = (int )(priv + k)->get_args & 2047;
          }
        } else {
#line 485
          n = (int )wrq.u.data.length;
        }
      } else {
#line 485
        n = (int )wrq.u.data.length;
      }
      {
#line 489
      if (((int )(priv + k)->get_args & 28672) == 4096) {
#line 489
        goto case_4096___0;
      }
#line 496
      if (((int )(priv + k)->get_args & 28672) == 16384) {
#line 496
        goto case_16384___0;
      }
#line 503
      if (((int )(priv + k)->get_args & 28672) == 8192) {
#line 503
        goto case_8192___0;
      }
#line 509
      if (((int )(priv + k)->get_args & 28672) == 20480) {
#line 509
        goto case_20480___0;
      }
#line 528
      if (((int )(priv + k)->get_args & 28672) == 24576) {
#line 528
        goto case_24576___0;
      }
#line 544
      goto switch_default___0;
      case_4096___0: /* CIL Label */ 
#line 491
      j___0 = 0;
      {
#line 491
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 491
        if (! (j___0 < n)) {
#line 491
          goto while_break___5;
        }
        {
#line 492
        printf((char const   */* __restrict  */)"%d  ", (int )buffer[j___0]);
#line 491
        j___0 ++;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 493
      printf((char const   */* __restrict  */)"\n");
      }
#line 494
      goto switch_break___0;
      case_16384___0: /* CIL Label */ 
#line 498
      j___0 = 0;
      {
#line 498
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 498
        if (! (j___0 < n)) {
#line 498
          goto while_break___6;
        }
        {
#line 499
        printf((char const   */* __restrict  */)"%d  ", *((__s32 *)(buffer) + j___0));
#line 498
        j___0 ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 500
      printf((char const   */* __restrict  */)"\n");
      }
#line 501
      goto switch_break___0;
      case_8192___0: /* CIL Label */ 
      {
#line 505
      buffer[n] = (u_char )'\000';
#line 506
      printf((char const   */* __restrict  */)"%s\n", buffer);
      }
#line 507
      goto switch_break___0;
      case_20480___0: /* CIL Label */ 
#line 513
      j___0 = 0;
      {
#line 513
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 513
        if (! (j___0 < n)) {
#line 513
          goto while_break___7;
        }
        {
#line 515
        freq___0 = iw_freq2float((iwfreq const   *)((struct iw_freq *)(buffer) + j___0));
        }
#line 516
        if (freq___0 >= 1e9) {
          {
#line 517
          printf((char const   */* __restrict  */)"%gG  ", freq___0 / 1e9);
          }
        } else
#line 519
        if (freq___0 >= 1e6) {
          {
#line 520
          printf((char const   */* __restrict  */)"%gM  ", freq___0 / 1e6);
          }
        } else {
          {
#line 522
          printf((char const   */* __restrict  */)"%gk  ", freq___0 / 1e3);
          }
        }
#line 513
        j___0 ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 524
      printf((char const   */* __restrict  */)"\n");
      }
#line 526
      goto switch_break___0;
      case_24576___0: /* CIL Label */ 
#line 533
      j___0 = 0;
      {
#line 533
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 533
        if (! (j___0 < n)) {
#line 533
          goto while_break___8;
        }
#line 535
        hwa = (struct sockaddr *)(buffer) + j___0;
#line 536
        if (j___0) {
          {
#line 537
          tmp___13 = strlen((char const   *)cmdname);
#line 537
          printf((char const   */* __restrict  */)"           %.*s", (int )tmp___13,
                 "                ");
          }
        }
        {
#line 539
        tmp___14 = iw_saether_ntop((struct sockaddr  const  *)hwa, scratch);
#line 539
        printf((char const   */* __restrict  */)"%s\n", tmp___14);
#line 533
        j___0 ++;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
#line 542
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
      {
#line 545
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not yet implemented...\n");
      }
#line 546
      return (-1);
      switch_break___0: /* CIL Label */ ;
      }
    }
  }
#line 550
  return (0);
}
}
#line 557 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwpriv.c"
__inline static int ( __attribute__((__always_inline__)) set_private)(int skfd , char **args ,
                                                                      int count ,
                                                                      char *ifname ) 
{ 
  iwprivargs *priv ;
  int number ;
  int ret ;

  {
  {
#line 568
  number = iw_get_priv_info(skfd, (char const   *)ifname, & priv);
  }
#line 571
  if (number <= 0) {
    {
#line 574
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  no private ioctls.\n\n",
            ifname);
    }
#line 576
    if (priv) {
      {
#line 577
      free((void *)priv);
      }
    }
#line 578
    return (-1);
  }
  {
#line 582
  ret = set_private_cmd(skfd, args + 1, count - 1, ifname, *(args + 0), priv, number);
#line 585
  free((void *)priv);
  }
#line 586
  return (ret);
}
}
#line 596 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwpriv.c"
static int print_priv_info(int skfd , char *ifname , char **args , int count ) 
{ 
  int k ;
  iwprivargs *priv ;
  int n ;

  {
  {
#line 607
  args = args;
#line 607
  count = count;
#line 610
  n = iw_get_priv_info(skfd, (char const   *)ifname, & priv);
  }
#line 613
  if (n <= 0) {
    {
#line 616
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  no private ioctls.\n\n",
            ifname);
    }
  } else {
    {
#line 621
    printf((char const   */* __restrict  */)"%-8.16s  Available private ioctls :\n",
           ifname);
#line 623
    k = 0;
    }
    {
#line 623
    while (1) {
      while_continue: /* CIL Label */ ;
#line 623
      if (! (k < n)) {
#line 623
        goto while_break;
      }
#line 624
      if ((int )(priv + k)->name[0] != 0) {
        {
#line 625
        printf((char const   */* __restrict  */)"          %-16.16s (%.4X) : set %3d %s & get %3d %s\n",
               (priv + k)->name, (priv + k)->cmd, (int )(priv + k)->set_args & 2047,
               argtype[((int )(priv + k)->set_args & 28672) >> 12], (int )(priv + k)->get_args & 2047,
               argtype[((int )(priv + k)->get_args & 28672) >> 12]);
        }
      }
#line 623
      k ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 631
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 635
  if (priv) {
    {
#line 636
    free((void *)priv);
    }
  }
#line 637
  return (0);
}
}
#line 645 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwpriv.c"
static int print_priv_all(int skfd , char *ifname , char **args , int count ) 
{ 
  int k ;
  iwprivargs *priv ;
  int n ;

  {
  {
#line 656
  args = args;
#line 656
  count = count;
#line 659
  n = iw_get_priv_info(skfd, (char const   *)ifname, & priv);
  }
#line 662
  if (n <= 0) {
    {
#line 665
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  no private ioctls.\n\n",
            ifname);
    }
  } else {
    {
#line 670
    printf((char const   */* __restrict  */)"%-8.16s  Available read-only private ioctl :\n",
           ifname);
#line 672
    k = 0;
    }
    {
#line 672
    while (1) {
      while_continue: /* CIL Label */ ;
#line 672
      if (! (k < n)) {
#line 672
        goto while_break;
      }
#line 675
      if ((int )(priv + k)->name[0] != 0) {
#line 675
        if ((int )(priv + k)->set_args == 0) {
#line 675
          if ((int )(priv + k)->get_args != 0) {
            {
#line 677
            set_private_cmd(skfd, (char **)((void *)0), 0, ifname, (priv + k)->name,
                            priv, n);
            }
          }
        }
      }
#line 672
      k ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 679
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 683
  if (priv) {
    {
#line 684
    free((void *)priv);
    }
  }
#line 685
  return (0);
}
}
#line 164 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static int const   families___1[4]  = {      (int const   )2,      (int const   )4,      (int const   )3,      (int const   )5};
#line 381 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static int print_iface_version_info___1(int skfd , char *ifname , char **args , int count ) 
{ 
  struct iwreq wrq ;
  char buffer[sizeof(iwrange ) * 2UL] ;
  struct iw_range *range ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 392
  args = args;
#line 392
  count = count;
#line 396
  tmp = iw_set_ext(skfd, (char const   *)ifname, 35585, & wrq);
  }
#line 396
  if (tmp < 0) {
#line 397
    return (-1);
  }
  {
#line 400
  memset((void *)(buffer), 0, sizeof(buffer));
#line 402
  wrq.u.data.pointer = (void *)(buffer);
#line 403
  wrq.u.data.length = (__u16 )sizeof(buffer);
#line 404
  wrq.u.data.flags = (__u16 )0;
#line 405
  tmp___0 = iw_set_ext(skfd, (char const   *)ifname, 35595, & wrq);
  }
#line 405
  if (tmp___0 < 0) {
    {
#line 408
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  Driver has no Wireless Extension version information.\n\n",
            ifname);
    }
#line 409
    return (0);
  }
#line 413
  range = (struct iw_range *)(buffer);
#line 417
  if ((int )wrq.u.data.length >= 300) {
    {
#line 420
    printf((char const   */* __restrict  */)"%-8.16s  Recommend Wireless Extension v%d or later,\n",
           ifname, (int )range->we_version_source);
#line 422
    printf((char const   */* __restrict  */)"          Currently compiled with Wireless Extension v%d.\n\n",
           (int )range->we_version_compiled);
    }
  } else {
    {
#line 427
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  Wireless Extension version too old.\n\n",
            ifname);
    }
  }
#line 432
  return (0);
}
}
#line 1687 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static int iw_pass_key___1(char const   *input , unsigned char *key ) 
{ 


  {
  {
#line 1691
  input = input;
#line 1691
  key = key;
#line 1692
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Passphrase not implemented\n");
  }
#line 1693
  return (-1);
}
}
#line 2402 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static int const   priv_type_size___1[8]  = 
#line 2402
  {      (int const   )0,      (int const   )1,      (int const   )1,      (int const   )0, 
        (int const   )sizeof(__u32 ),      (int const   )sizeof(struct iw_freq ),      (int const   )sizeof(struct sockaddr ),      (int const   )0};
#line 2480 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static struct iw_ioctl_description  const  standard_ioctl_descr___1[55]  = 
#line 2480
  {      {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )2, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )2}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )5, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )2}, 
        {(__u8 )5, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )4, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )2}, 
        {(__u8 )4, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )sizeof(struct iw_range ),
      (__u32 )1}, 
        {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )8, (unsigned char)0, (__u16 )sizeof(struct sockaddr ), (unsigned short)0,
      (__u16 )8, 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )(sizeof(struct sockaddr ) + sizeof(struct iw_quality )),
      (unsigned short)0, (__u16 )8, 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )sizeof(struct iw_thrspy ), (__u16 )1, (__u16 )1,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )sizeof(struct iw_thrspy ), (__u16 )1, (__u16 )1,
      0U}, 
        {(__u8 )6, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )6, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (__u16 )sizeof(struct iw_mlme ), (__u16 )sizeof(struct iw_mlme ),
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )(sizeof(struct sockaddr ) + sizeof(struct iw_quality )),
      (unsigned short)0, (__u16 )64, (__u32 )8}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (__u16 )0, (__u16 )sizeof(struct iw_scan_req ),
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )4096, (__u32 )8}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )33, (__u32 )2}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )33, (__u32 )1}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )33, 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )33, 0U}, 
        {(unsigned char)0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(unsigned char)0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )0, (unsigned short)0, (__u16 )64, (__u32 )6}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )0, (unsigned short)0, (__u16 )64, (__u32 )5}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )1024, 0U}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )1024, 0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (__u16 )sizeof(struct iw_encode_ext ),
      (__u16 )(sizeof(struct iw_encode_ext ) + 64UL), 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (__u16 )sizeof(struct iw_encode_ext ),
      (__u16 )(sizeof(struct iw_encode_ext ) + 64UL), 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (__u16 )sizeof(struct iw_pmksa ), (__u16 )sizeof(struct iw_pmksa ),
      0U}};
#line 2712 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static unsigned int const   standard_ioctl_num___1  =    (unsigned int const   )(sizeof(standard_ioctl_descr___1) / sizeof(struct iw_ioctl_description ));
#line 2719 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static struct iw_ioctl_description  const  standard_event_descr___1[10]  = 
#line 2719
  {      {(__u8 )6, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )10, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )256, 0U}, 
        {(__u8 )6, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )6, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )1024, 0U}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )sizeof(struct iw_michaelmicfailure ),
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )1024, 0U}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )1024, 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )sizeof(struct iw_pmkid_cand ),
      0U}};
#line 2763 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static unsigned int const   standard_event_num___1  =    (unsigned int const   )(sizeof(standard_event_descr___1) / sizeof(struct iw_ioctl_description ));
#line 2767 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static int const   event_type_size___1[11]  = 
#line 2767
  {      (int const   )4,      (int const   )0,      (int const   )20,      (int const   )0, 
        (int const   )(4UL + sizeof(__u32 )),      (int const   )(4UL + sizeof(struct iw_freq )),      (int const   )(4UL + sizeof(struct sockaddr )),      (int const   )0, 
        (int const   )8,      (int const   )(4UL + sizeof(struct iw_param )),      (int const   )(4UL + sizeof(struct iw_quality ))};
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 56 "/usr/include/fnmatch.h"
extern int fnmatch(char const   *__pattern , char const   *__name , int __flags ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 678
extern __ssize_t getline(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                         FILE * __restrict  __stream ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 96
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 184
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strndup)(char const   *__string ,
                                                                                                size_t __n )  __attribute__((__malloc__)) ;
#line 289
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 604
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) basename)(char const   *__filename ) ;
#line 497 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 501
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchdir)(int __fd ) ;
#line 511
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 809
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__nonnull__(1,2), __leaf__)) readlink)(char const   * __restrict  __path ,
                                                                                                     char * __restrict  __buf ,
                                                                                                     size_t __len ) ;
#line 61 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
char const   DEFAULT_CONF[11]  = 
#line 61 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
  {      (char const   )'/',      (char const   )'e',      (char const   )'t',      (char const   )'c', 
        (char const   )'/',      (char const   )'i',      (char const   )'f',      (char const   )'t', 
        (char const   )'a',      (char const   )'b',      (char const   )'\000'};
#line 64 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
char const   DEBIAN_CONFIG_FILE[24]  = 
#line 64
  {      (char const   )'/',      (char const   )'e',      (char const   )'t',      (char const   )'c', 
        (char const   )'/',      (char const   )'n',      (char const   )'e',      (char const   )'t', 
        (char const   )'w',      (char const   )'o',      (char const   )'r',      (char const   )'k', 
        (char const   )'/',      (char const   )'i',      (char const   )'n',      (char const   )'t', 
        (char const   )'e',      (char const   )'r',      (char const   )'f',      (char const   )'a', 
        (char const   )'c',      (char const   )'e',      (char const   )'s',      (char const   )'\000'};
#line 72 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
int const   SELECT_MAC  =    (int const   )0;
#line 73 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
int const   SELECT_ETHADDR  =    (int const   )1;
#line 74 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
int const   SELECT_ARP  =    (int const   )2;
#line 75 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
int const   SELECT_LINKTYPE  =    (int const   )3;
#line 76 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
int const   SELECT_DRIVER  =    (int const   )4;
#line 77 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
int const   SELECT_BUSINFO  =    (int const   )5;
#line 78 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
int const   SELECT_FIRMWARE  =    (int const   )6;
#line 79 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
int const   SELECT_BASEADDR  =    (int const   )7;
#line 80 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
int const   SELECT_IRQ  =    (int const   )8;
#line 81 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
int const   SELECT_INTERRUPT  =    (int const   )9;
#line 82 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
int const   SELECT_IWPROTO  =    (int const   )10;
#line 83 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
int const   SELECT_PCMCIASLOT  =    (int const   )11;
#line 84 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
int const   SELECT_SYSFS  =    (int const   )12;
#line 85 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
int const   SELECT_PREVNAME  =    (int const   )13;
#line 92 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
struct ether_addr  const  zero_mac  =    {{(u_int8_t )0, (u_int8_t )0, (u_int8_t )0, (u_int8_t )0, (u_int8_t )0, (u_int8_t )0}};
#line 94 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
struct option  const  long_opt[11]  = 
#line 94
  {      {"config-file", 1, (int *)((void *)0), 'c'}, 
        {"debian", 0, (int *)((void *)0), 'd'}, 
        {"dry-run", 0, (int *)((void *)0), 'D'}, 
        {"help", 0, (int *)((void *)0), '?'}, 
        {"interface", 1, (int *)((void *)0), 'i'}, 
        {"newname", 1, (int *)((void *)0), 'n'}, 
        {"takeover", 0, (int *)((void *)0), 't'}, 
        {"udev", 0, (int *)((void *)0), 'u'}, 
        {"version", 0, (int *)((void *)0), 'v'}, 
        {"verbose", 0, (int *)((void *)0), 'V'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), '\000'}};
#line 128 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
int const   weird_mac_len[3][2]  = { {        (int const   )24,        (int const   )8}, 
   {        (int const   )27,        (int const   )8}, 
   {        (int const   )783,        (int const   )4}};
#line 134 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
int const   weird_mac_len_num  =    (int const   )(sizeof(weird_mac_len) / sizeof(weird_mac_len[0]));
#line 231
static int mapping_addmac(struct if_mapping *ifnode , int *active , char *string ,
                          size_t len , struct add_extra *extra , int linenum ) ;
#line 238
static int mapping_cmpmac(struct if_mapping *ifnode , struct if_mapping *target ) ;
#line 241
static int mapping_getmac(int skfd , char const   *ifname , struct if_mapping *target ,
                          int flag ) ;
#line 246
static int mapping_addarp(struct if_mapping *ifnode , int *active , char *string ,
                          size_t len , struct add_extra *extra , int linenum ) ;
#line 253
static int mapping_cmparp(struct if_mapping *ifnode , struct if_mapping *target ) ;
#line 256
static int mapping_getarp(int skfd , char const   *ifname , struct if_mapping *target ,
                          int flag ) ;
#line 261
static int mapping_adddriver(struct if_mapping *ifnode , int *active , char *string ,
                             size_t len , struct add_extra *extra , int linenum ) ;
#line 268
static int mapping_cmpdriver(struct if_mapping *ifnode , struct if_mapping *target ) ;
#line 271
static int mapping_addbusinfo(struct if_mapping *ifnode , int *active , char *string ,
                              size_t len , struct add_extra *extra , int linenum ) ;
#line 278
static int mapping_cmpbusinfo(struct if_mapping *ifnode , struct if_mapping *target ) ;
#line 281
static int mapping_addfirmware(struct if_mapping *ifnode , int *active , char *string ,
                               size_t len , struct add_extra *extra , int linenum ) ;
#line 288
static int mapping_cmpfirmware(struct if_mapping *ifnode , struct if_mapping *target ) ;
#line 291
static int mapping_getdriverbusinfo(int skfd , char const   *ifname , struct if_mapping *target ,
                                    int flag ) ;
#line 296
static int mapping_addbaseaddr(struct if_mapping *ifnode , int *active , char *string ,
                               size_t len , struct add_extra *extra , int linenum ) ;
#line 303
static int mapping_cmpbaseaddr(struct if_mapping *ifnode , struct if_mapping *target ) ;
#line 306
static int mapping_addirq(struct if_mapping *ifnode , int *active , char *string ,
                          size_t len , struct add_extra *extra , int linenum ) ;
#line 313
static int mapping_cmpirq(struct if_mapping *ifnode , struct if_mapping *target ) ;
#line 316
static int mapping_getbaseaddrirq(int skfd , char const   *ifname , struct if_mapping *target ,
                                  int flag ) ;
#line 321
static int mapping_addiwproto(struct if_mapping *ifnode , int *active , char *string ,
                              size_t len , struct add_extra *extra , int linenum ) ;
#line 328
static int mapping_cmpiwproto(struct if_mapping *ifnode , struct if_mapping *target ) ;
#line 331
static int mapping_getiwproto(int skfd , char const   *ifname , struct if_mapping *target ,
                              int flag ) ;
#line 336
static int mapping_addpcmciaslot(struct if_mapping *ifnode , int *active , char *string ,
                                 size_t len , struct add_extra *extra , int linenum ) ;
#line 343
static int mapping_cmppcmciaslot(struct if_mapping *ifnode , struct if_mapping *target ) ;
#line 346
static int mapping_getpcmciaslot(int skfd , char const   *ifname , struct if_mapping *target ,
                                 int flag ) ;
#line 351
static int mapping_addsysfs(struct if_mapping *ifnode , int *active , char *string ,
                            size_t len , struct add_extra *extra , int linenum ) ;
#line 358
static int mapping_cmpsysfs(struct if_mapping *ifnode , struct if_mapping *target ) ;
#line 361
static int mapping_getsysfs(int skfd , char const   *ifname , struct if_mapping *target ,
                            int flag ) ;
#line 366
static int mapping_addprevname(struct if_mapping *ifnode , int *active , char *string ,
                               size_t len , struct add_extra *extra , int linenum ) ;
#line 373
static int mapping_cmpprevname(struct if_mapping *ifnode , struct if_mapping *target ) ;
#line 376
static int mapping_getprevname(int skfd , char const   *ifname , struct if_mapping *target ,
                               int flag ) ;
#line 385 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
struct if_mapping *mapping_list  =    (struct if_mapping *)((void *)0);
#line 388 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
struct mapping_selector  const  selector_list[15]  = 
#line 388
  {      {(char *)"mac", & mapping_addmac, & mapping_cmpmac, & mapping_getmac}, 
        {(char *)"ethaddr", & mapping_addmac, & mapping_cmpmac, & mapping_getmac}, 
        {(char *)"arp", & mapping_addarp, & mapping_cmparp, & mapping_getarp}, 
        {(char *)"linktype", & mapping_addarp, & mapping_cmparp, & mapping_getarp}, 
        {(char *)"driver", & mapping_adddriver, & mapping_cmpdriver, & mapping_getdriverbusinfo}, 
        {(char *)"businfo",
      & mapping_addbusinfo, & mapping_cmpbusinfo, & mapping_getdriverbusinfo}, 
        {(char *)"firmware", & mapping_addfirmware, & mapping_cmpfirmware, & mapping_getdriverbusinfo}, 
        {(char *)"baseaddress",
      & mapping_addbaseaddr, & mapping_cmpbaseaddr, & mapping_getbaseaddrirq}, 
        {(char *)"irq", & mapping_addirq, & mapping_cmpirq, & mapping_getbaseaddrirq}, 
        {(char *)"interrupt",
      & mapping_addirq, & mapping_cmpirq, & mapping_getbaseaddrirq}, 
        {(char *)"iwproto", & mapping_addiwproto, & mapping_cmpiwproto, & mapping_getiwproto}, 
        {(char *)"pcmciaslot",
      & mapping_addpcmciaslot, & mapping_cmppcmciaslot, & mapping_getpcmciaslot}, 
        {(char *)"sysfs", & mapping_addsysfs, & mapping_cmpsysfs, & mapping_getsysfs}, 
        {(char *)"prevname",
      & mapping_addprevname, & mapping_cmpprevname, & mapping_getprevname}, 
        {(char *)((void *)0), (int (*)(struct if_mapping *ifnode , int *active , char *pos ,
                                    size_t len , struct add_extra *extra , int linenum ))((void *)0),
      (int (*)(struct if_mapping *ifnode , struct if_mapping *target ))((void *)0),
      (int (*)(int skfd , char const   *ifname , struct if_mapping *target , int flag ))((void *)0)}};
#line 418 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
int const   selector_num  =    (int const   )(sizeof(selector_list) / sizeof(selector_list[0]));
#line 421 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
int selector_active[14]  ;
#line 431 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
int print_newname  =    0;
#line 432 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
char *new_name  =    (char *)((void *)0);
#line 435 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
int force_takeover  =    0;
#line 436 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
int num_takeover  =    0;
#line 439 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
int num_mapping_match  =    0;
#line 442 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
int dry_run  =    0;
#line 445 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
int verbose  =    0;
#line 448 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
int udev_output  =    0;
#line 451 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
struct sysfs_metadata sysfs_global  =    {(char *)((void *)0), 0, 0, {(char *)((void *)0), (char *)((void *)0), (char *)((void *)0),
                                (char *)((void *)0), (char *)((void *)0)}};
#line 471 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
static int if_match_ifname(char const   *pattern , char const   *value ) 
{ 
  char const   *p ;
  char const   *v ;
  int n ;
  int ret ;
  char *tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;

  {
  {
#line 481
  tmp = strchr(pattern, '*');
#line 481
  p = (char const   *)tmp;
  }
#line 484
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 485
    tmp___0 = strcmp(pattern, value);
    }
#line 485
    return (tmp___0);
  }
  {
#line 488
  n = (int )(p - pattern);
#line 489
  ret = strncmp(pattern, value, (size_t )n);
  }
#line 490
  if (ret) {
#line 491
    return (ret);
  }
  {
#line 494
  v = value + n;
#line 495
  tmp___1 = __ctype_b_loc();
  }
#line 495
  if (! ((int const   )*(*tmp___1 + (int )*v) & 2048)) {
#line 496
    return (-1);
  }
  {
#line 499
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 500
    v ++;
#line 499
    tmp___2 = __ctype_b_loc();
    }
#line 499
    if (! ((int const   )*(*tmp___2 + (int )*v) & 2048)) {
#line 499
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 504
  p ++;
#line 507
  tmp___3 = strcmp(p, v);
  }
#line 507
  return (tmp___3);
}
}
#line 520 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
static int if_takeover_name(int skfd , char const   *victimname ) 
{ 
  char autoname[17] ;
  int len ;
  struct ifreq ifr ;
  int ret ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 530
  tmp = strlen(victimname);
#line 530
  len = (int )tmp;
#line 531
  memcpy((void */* __restrict  */)(autoname), (void const   */* __restrict  */)victimname,
         (size_t )(len + 1));
  }
#line 532
  if (len > 14) {
#line 533
    len = 14;
  }
#line 534
  len --;
  {
#line 535
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 535
    tmp___0 = __ctype_b_loc();
    }
#line 535
    if (! ((int const   )*(*tmp___0 + (int )autoname[len]) & 2048)) {
#line 535
      goto while_break;
    }
#line 536
    len --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 537
  strcpy((char */* __restrict  */)((autoname + len) + 1), (char const   */* __restrict  */)"%d");
  }
#line 539
  if (verbose) {
    {
#line 540
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Takeover : moving interface `%s\' to `%s\'.\n",
            victimname, autoname);
    }
  }
  {
#line 544
  bzero((void *)(& ifr), sizeof(struct ifreq ));
#line 545
  strncpy((char */* __restrict  */)(ifr.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)victimname,
          (size_t )16);
#line 546
  strncpy((char */* __restrict  */)(ifr.ifr_ifru.ifru_newname), (char const   */* __restrict  */)(autoname),
          (size_t )16);
#line 549
  ret = ioctl(skfd, 35107UL, & ifr);
  }
#line 551
  if (! ret) {
#line 552
    num_takeover ++;
  }
#line 554
  return (ret);
}
}
#line 563 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
static int if_set_name(int skfd , char const   *oldname , char const   *newname ,
                       char *retname ) 
{ 
  struct ifreq ifr ;
  char *star ;
  int ret ;
  int tmp ;
  int slen ;
  int *tmp___0 ;

  {
  {
#line 579
  tmp = if_match_ifname(newname, oldname);
  }
#line 579
  if (! tmp) {
#line 581
    if (verbose) {
      {
#line 582
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Setting : Interface `%s\' already matches `%s\'.\n",
              oldname, newname);
      }
    }
    {
#line 585
    strcpy((char */* __restrict  */)retname, (char const   */* __restrict  */)oldname);
    }
#line 586
    return (0);
  }
  {
#line 590
  bzero((void *)(& ifr), sizeof(struct ifreq ));
#line 591
  strncpy((char */* __restrict  */)(ifr.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)oldname,
          (size_t )16);
#line 592
  strncpy((char */* __restrict  */)(ifr.ifr_ifru.ifru_newname), (char const   */* __restrict  */)newname,
          (size_t )16);
#line 598
  star = strchr(newname, '*');
  }
#line 599
  if ((unsigned long )star != (unsigned long )((void *)0)) {
    {
#line 601
    slen = (int )(star - (char *)newname);
#line 603
    star = ifr.ifr_ifru.ifru_newname + slen;
#line 605
    memmove((void *)(star + 2), (void const   *)(star + 1), (size_t )((16 - slen) - 2));
#line 606
    *(star + 0) = (char )'%';
#line 607
    *(star + 1) = (char )'d';
    }
  }
  {
#line 611
  ret = ioctl(skfd, 35107UL, & ifr);
  }
#line 614
  if (ret) {
    {
#line 614
    tmp___0 = __errno_location();
    }
#line 614
    if (*tmp___0 == 17) {
#line 614
      if (force_takeover) {
        {
#line 617
        ret = if_takeover_name(skfd, newname);
        }
#line 618
        if (! ret) {
          {
#line 620
          ret = ioctl(skfd, 35107UL, & ifr);
          }
        }
      }
    }
  }
#line 623
  if (! ret) {
    {
#line 626
    strcpy((char */* __restrict  */)retname, (char const   */* __restrict  */)(ifr.ifr_ifru.ifru_newname));
    }
#line 628
    if (verbose) {
      {
#line 629
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Setting : Interface `%s\' renamed to `%s\'.\n",
              oldname, retname);
      }
    }
  }
#line 633
  return (ret);
}
}
#line 645 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
static int mapping_addmac(struct if_mapping *ifnode , int *active , char *string ,
                          size_t len , struct add_extra *extra , int linenum ) 
{ 
  size_t n ;
  int tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 656
  extra = extra;
#line 659
  if (len >= sizeof(ifnode->mac_filter)) {
    {
#line 661
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error : MAC address too long at line %d\n",
            linenum);
    }
#line 662
    return (-1);
  }
  {
#line 664
  n = strspn((char const   *)string, "0123456789ABCDEFabcdef:*");
  }
#line 665
  if (n < len) {
    {
#line 667
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Invalid MAC address `%s\' at line %d\n",
            string, linenum);
    }
#line 669
    return (-1);
  }
  {
#line 673
  memcpy((void */* __restrict  */)(ifnode->mac_filter), (void const   */* __restrict  */)string,
         len + 1UL);
#line 676
  tmp___0 = strchr((char const   *)(ifnode->mac_filter), '*');
  }
#line 676
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 680
    ifnode->active[SELECT_MAC] = 2;
#line 681
    *(active + SELECT_MAC) = 2;
  } else {
    {
#line 686
    ifnode->mac_len = iw_mac_aton((char const   *)(ifnode->mac_filter), ifnode->mac,
                                  16);
    }
#line 688
    if (ifnode->mac_len == 0) {
      {
#line 690
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Invalid MAC address `%s\' at line %d\n",
              ifnode->mac_filter, linenum);
      }
#line 692
      return (-1);
    }
#line 696
    if (ifnode->mac_len == 6) {
      {
#line 696
      tmp = memcmp((void const   *)(& ifnode->mac), (void const   *)(& zero_mac),
                   (size_t )6);
      }
#line 696
      if (! tmp) {
        {
#line 698
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: MAC address is null at line %d, this is dangerous...\n",
                linenum);
        }
      }
    }
#line 703
    ifnode->active[SELECT_MAC] = 1;
#line 704
    if (*(active + SELECT_MAC) == 0) {
#line 705
      *(active + SELECT_MAC) = 1;
    }
  }
#line 708
  if (verbose) {
#line 709
    if (ifnode->active[SELECT_MAC] == 2) {
#line 709
      tmp___1 = "filter";
    } else {
#line 709
      tmp___1 = "exact";
    }
    {
#line 709
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Parsing : Added %s MAC address `%s\' from line %d.\n",
            tmp___1, ifnode->mac_filter, linenum);
    }
  }
#line 714
  return (0);
}
}
#line 721 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
static int mapping_cmpmac(struct if_mapping *ifnode , struct if_mapping *target ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 726
  if (ifnode->active[SELECT_MAC] == 2) {
    {
#line 728
    tmp = fnmatch((char const   *)(ifnode->mac_filter), (char const   *)(target->mac_filter),
                  1 << 4);
    }
#line 728
    return (tmp);
  } else {
#line 731
    if (ifnode->mac_len != target->mac_len) {
#line 731
      tmp___1 = 1;
    } else {
      {
#line 731
      tmp___0 = memcmp((void const   *)(ifnode->mac), (void const   *)(target->mac),
                       (size_t )ifnode->mac_len);
      }
#line 731
      if (tmp___0) {
#line 731
        tmp___1 = 1;
      } else {
#line 731
        tmp___1 = 0;
      }
    }
#line 731
    return (tmp___1);
  }
}
}
#line 739 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
static int mapping_getmac(int skfd , char const   *ifname , struct if_mapping *target ,
                          int flag ) 
{ 
  struct ifreq ifr ;
  int ret ;
  int i ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 750
  bzero((void *)(& ifr), sizeof(struct ifreq ));
#line 751
  strncpy((char */* __restrict  */)(ifr.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)ifname,
          (size_t )16);
#line 752
  ret = ioctl(skfd, 35111UL, & ifr);
  }
#line 753
  if (ret < 0) {
    {
#line 755
    tmp = __errno_location();
#line 755
    tmp___0 = strerror(*tmp);
#line 755
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Can\'t read MAC address on interface `%s\' : %s\n",
            ifname, tmp___0);
    }
#line 757
    return (-1);
  }
#line 761
  target->hw_type = ifr.ifr_ifru.ifru_hwaddr.sa_family;
#line 763
  target->mac_len = 6;
#line 764
  i = 0;
  {
#line 764
  while (1) {
    while_continue: /* CIL Label */ ;
#line 764
    if (! (i < (int )weird_mac_len_num)) {
#line 764
      goto while_break;
    }
#line 765
    if (weird_mac_len[i][0] == (int const   )ifr.ifr_ifru.ifru_hwaddr.sa_family) {
#line 767
      target->mac_len = (int )weird_mac_len[i][1];
#line 768
      goto while_break;
    }
#line 764
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 771
  memcpy((void */* __restrict  */)(target->mac), (void const   */* __restrict  */)(ifr.ifr_ifru.ifru_hwaddr.sa_data),
         (size_t )target->mac_len);
  }
#line 774
  if (flag == 2) {
    {
#line 777
    iw_mac_ntop((unsigned char const   *)(target->mac), target->mac_len, target->mac_filter,
                (int )sizeof(target->mac_filter));
    }
  } else
#line 774
  if (verbose) {
    {
#line 777
    iw_mac_ntop((unsigned char const   *)(target->mac), target->mac_len, target->mac_filter,
                (int )sizeof(target->mac_filter));
    }
  }
#line 781
  target->active[SELECT_MAC] = flag;
#line 782
  target->active[SELECT_ARP] = 1;
#line 784
  if (verbose) {
    {
#line 785
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Querying %s : Got MAC address `%s\' and ARP/Link Type `%d\'.\n",
            ifname, target->mac_filter, (int )target->hw_type);
    }
  }
#line 789
  return (0);
}
}
#line 796 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
static int mapping_addarp(struct if_mapping *ifnode , int *active , char *string ,
                          size_t len , struct add_extra *extra , int linenum ) 
{ 
  size_t n ;
  unsigned int type ;
  int tmp ;

  {
  {
#line 808
  extra = extra;
#line 811
  n = strspn((char const   *)string, "0123456789");
  }
#line 812
  if (n < len) {
    {
#line 814
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Invalid ARP/Link Type `%s\' at line %d\n",
            string, linenum);
    }
#line 816
    return (-1);
  } else {
    {
#line 812
    tmp = sscanf((char const   */* __restrict  */)string, (char const   */* __restrict  */)"%d",
                 & type);
    }
#line 812
    if (tmp != 1) {
      {
#line 814
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Invalid ARP/Link Type `%s\' at line %d\n",
              string, linenum);
      }
#line 816
      return (-1);
    }
  }
#line 819
  ifnode->hw_type = (unsigned short )type;
#line 820
  ifnode->active[SELECT_ARP] = 1;
#line 821
  *(active + SELECT_ARP) = 1;
#line 823
  if (verbose) {
    {
#line 824
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Parsing : Added ARP/Link Type `%d\' from line %d.\n",
            (int )ifnode->hw_type, linenum);
    }
  }
#line 827
  return (0);
}
}
#line 834 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
static int mapping_cmparp(struct if_mapping *ifnode , struct if_mapping *target ) 
{ 


  {
#line 838
  return (! ((int )ifnode->hw_type == (int )target->hw_type));
}
}
#line 845 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
static int mapping_getarp(int skfd , char const   *ifname , struct if_mapping *target ,
                          int flag ) 
{ 
  int tmp ;

  {
#line 852
  if (target->active[SELECT_MAC]) {
#line 853
    return (0);
  }
  {
#line 856
  tmp = mapping_getmac(skfd, ifname, target, flag);
  }
#line 856
  return (tmp);
}
}
#line 863 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
static int mapping_adddriver(struct if_mapping *ifnode , int *active , char *string ,
                             size_t len , struct add_extra *extra , int linenum ) 
{ 


  {
#line 872
  extra = extra;
#line 875
  if (len >= sizeof(ifnode->driver)) {
    {
#line 877
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Driver name too long at line %d\n",
            linenum);
    }
#line 878
    return (-1);
  }
  {
#line 882
  memcpy((void */* __restrict  */)(ifnode->driver), (void const   */* __restrict  */)string,
         len + 1UL);
#line 885
  ifnode->active[SELECT_DRIVER] = 1;
#line 886
  *(active + SELECT_DRIVER) = 1;
  }
#line 888
  if (verbose) {
    {
#line 889
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Parsing : Added Driver name `%s\' from line %d.\n",
            ifnode->driver, linenum);
    }
  }
#line 893
  return (0);
}
}
#line 900 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
static int mapping_cmpdriver(struct if_mapping *ifnode , struct if_mapping *target ) 
{ 
  int tmp ;

  {
  {
#line 905
  tmp = fnmatch((char const   *)(ifnode->driver), (char const   *)(target->driver),
                1 << 4);
  }
#line 905
  return (tmp);
}
}
#line 912 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
static int mapping_addbusinfo(struct if_mapping *ifnode , int *active , char *string ,
                              size_t len , struct add_extra *extra , int linenum ) 
{ 


  {
#line 925
  extra = extra;
#line 928
  if (len >= sizeof(ifnode->bus_info)) {
    {
#line 930
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bus Info too long at line %d\n",
            linenum);
    }
#line 931
    return (-1);
  }
  {
#line 945
  memcpy((void */* __restrict  */)(ifnode->bus_info), (void const   */* __restrict  */)string,
         len + 1UL);
#line 948
  ifnode->active[SELECT_BUSINFO] = 1;
#line 949
  *(active + SELECT_BUSINFO) = 1;
  }
#line 951
  if (verbose) {
    {
#line 952
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Parsing : Added Bus Info `%s\' from line %d.\n",
            ifnode->bus_info, linenum);
    }
  }
#line 956
  return (0);
}
}
#line 963 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
static int mapping_cmpbusinfo(struct if_mapping *ifnode , struct if_mapping *target ) 
{ 
  int tmp ;

  {
  {
#line 968
  tmp = fnmatch((char const   *)(ifnode->bus_info), (char const   *)(target->bus_info),
                1 << 4);
  }
#line 968
  return (tmp);
}
}
#line 975 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
static int mapping_addfirmware(struct if_mapping *ifnode , int *active , char *string ,
                               size_t len , struct add_extra *extra , int linenum ) 
{ 


  {
#line 984
  extra = extra;
#line 987
  if (len >= sizeof(ifnode->fw_version)) {
    {
#line 989
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Firmware revision too long at line %d\n",
            linenum);
    }
#line 990
    return (-1);
  }
  {
#line 994
  memcpy((void */* __restrict  */)(ifnode->fw_version), (void const   */* __restrict  */)string,
         len + 1UL);
#line 997
  ifnode->active[SELECT_FIRMWARE] = 1;
#line 998
  *(active + SELECT_FIRMWARE) = 1;
  }
#line 1000
  if (verbose) {
    {
#line 1001
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Parsing : Added Firmware Revision `%s\' from line %d.\n",
            ifnode->fw_version, linenum);
    }
  }
#line 1005
  return (0);
}
}
#line 1012 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
static int mapping_cmpfirmware(struct if_mapping *ifnode , struct if_mapping *target ) 
{ 
  int tmp ;

  {
  {
#line 1017
  tmp = fnmatch((char const   *)(ifnode->fw_version), (char const   *)(target->fw_version),
                1 << 4);
  }
#line 1017
  return (tmp);
}
}
#line 1024 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
static int mapping_getdriverbusinfo(int skfd , char const   *ifname , struct if_mapping *target ,
                                    int flag ) 
{ 
  struct ifreq ifr ;
  struct ethtool_drvinfo drvinfo ;
  int ret ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 1035
  flag = flag;
#line 1038
  if (target->active[SELECT_DRIVER]) {
#line 1040
    return (0);
  } else
#line 1038
  if (target->active[SELECT_BUSINFO]) {
#line 1040
    return (0);
  } else
#line 1038
  if (target->active[SELECT_FIRMWARE]) {
#line 1040
    return (0);
  }
  {
#line 1043
  bzero((void *)(& ifr), sizeof(struct ifreq ));
#line 1044
  bzero((void *)(& drvinfo), sizeof(struct ethtool_drvinfo ));
#line 1045
  strncpy((char */* __restrict  */)(ifr.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)ifname,
          (size_t )16);
#line 1046
  drvinfo.cmd = (__u32 )3;
#line 1047
  ifr.ifr_ifru.ifru_data = (caddr_t )(& drvinfo);
#line 1050
  ret = ioctl(skfd, 35142UL, & ifr);
  }
#line 1051
  if (ret < 0) {
#line 1054
    if (verbose) {
      {
#line 1055
      tmp = __errno_location();
#line 1055
      tmp___0 = strerror(*tmp);
#line 1055
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Can\'t read driver/bus-info on interface `%s\' : %s\n",
              ifname, tmp___0);
      }
    }
#line 1058
    return (-1);
  }
  {
#line 1062
  strcpy((char */* __restrict  */)(target->driver), (char const   */* __restrict  */)(drvinfo.driver));
#line 1063
  strcpy((char */* __restrict  */)(target->bus_info), (char const   */* __restrict  */)(drvinfo.bus_info));
#line 1064
  strcpy((char */* __restrict  */)(target->fw_version), (char const   */* __restrict  */)(drvinfo.fw_version));
#line 1067
  target->active[SELECT_DRIVER] = 1;
#line 1068
  target->active[SELECT_BUSINFO] = 1;
#line 1069
  target->active[SELECT_FIRMWARE] = 1;
  }
#line 1071
  if (verbose) {
    {
#line 1072
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Querying %s : Got Driver name `%s\', Bus Info `%s\' and Firmware `%s\'.\n",
            ifname, target->driver, target->bus_info, target->fw_version);
    }
  }
#line 1076
  return (0);
}
}
#line 1083 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
static int mapping_addbaseaddr(struct if_mapping *ifnode , int *active , char *string ,
                               size_t len , struct add_extra *extra , int linenum ) 
{ 
  size_t n ;
  unsigned int address ;
  int tmp ;

  {
  {
#line 1095
  extra = extra;
#line 1098
  n = strspn((char const   *)string, "0123456789ABCDEFabcdefx");
  }
#line 1099
  if (n < len) {
    {
#line 1101
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Invalid Base Address `%s\' at line %d\n",
            string, linenum);
    }
#line 1103
    return (-1);
  } else {
    {
#line 1099
    tmp = sscanf((char const   */* __restrict  */)string, (char const   */* __restrict  */)"0x%X",
                 & address);
    }
#line 1099
    if (tmp != 1) {
      {
#line 1101
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Invalid Base Address `%s\' at line %d\n",
              string, linenum);
      }
#line 1103
      return (-1);
    }
  }
#line 1107
  ifnode->base_addr = (unsigned short )address;
#line 1110
  ifnode->active[SELECT_BASEADDR] = 1;
#line 1111
  *(active + SELECT_BASEADDR) = 1;
#line 1113
  if (verbose) {
    {
#line 1114
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Parsing : Added Base Address `0x%X\' from line %d.\n",
            (int )ifnode->base_addr, linenum);
    }
  }
#line 1118
  return (0);
}
}
#line 1125 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
static int mapping_cmpbaseaddr(struct if_mapping *ifnode , struct if_mapping *target ) 
{ 


  {
#line 1130
  return (! ((int )ifnode->base_addr == (int )target->base_addr));
}
}
#line 1137 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
static int mapping_addirq(struct if_mapping *ifnode , int *active , char *string ,
                          size_t len , struct add_extra *extra , int linenum ) 
{ 
  size_t n ;
  unsigned int irq ;
  int tmp ;

  {
  {
#line 1149
  extra = extra;
#line 1152
  n = strspn((char const   *)string, "0123456789");
  }
#line 1153
  if (n < len) {
    {
#line 1155
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Invalid Base Address `%s\' at line %d\n",
            string, linenum);
    }
#line 1157
    return (-1);
  } else {
    {
#line 1153
    tmp = sscanf((char const   */* __restrict  */)string, (char const   */* __restrict  */)"%d",
                 & irq);
    }
#line 1153
    if (tmp != 1) {
      {
#line 1155
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Invalid Base Address `%s\' at line %d\n",
              string, linenum);
      }
#line 1157
      return (-1);
    }
  }
#line 1161
  ifnode->irq = (unsigned char )irq;
#line 1164
  ifnode->active[SELECT_IRQ] = 1;
#line 1165
  *(active + SELECT_IRQ) = 1;
#line 1167
  if (verbose) {
    {
#line 1168
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Parsing : Added IRQ `%d\' from line %d.\n",
            (int )ifnode->irq, linenum);
    }
  }
#line 1172
  return (0);
}
}
#line 1179 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
static int mapping_cmpirq(struct if_mapping *ifnode , struct if_mapping *target ) 
{ 


  {
#line 1184
  return (! ((int )ifnode->irq == (int )target->irq));
}
}
#line 1191 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
static int mapping_getbaseaddrirq(int skfd , char const   *ifname , struct if_mapping *target ,
                                  int flag ) 
{ 
  struct ifreq ifr ;
  struct ifmap map ;
  int ret ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 1202
  flag = flag;
#line 1205
  if (target->active[SELECT_BASEADDR]) {
#line 1206
    return (0);
  } else
#line 1205
  if (target->active[SELECT_IRQ]) {
#line 1206
    return (0);
  }
  {
#line 1209
  bzero((void *)(& ifr), sizeof(struct ifreq ));
#line 1210
  bzero((void *)(& map), sizeof(struct ifmap ));
#line 1211
  strncpy((char */* __restrict  */)(ifr.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)ifname,
          (size_t )16);
#line 1214
  ret = ioctl(skfd, 35184UL, & ifr);
  }
#line 1215
  if (ret < 0) {
#line 1218
    if (verbose) {
      {
#line 1219
      tmp = __errno_location();
#line 1219
      tmp___0 = strerror(*tmp);
#line 1219
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Can\'t read base address/irq on interface `%s\' : %s\n",
              ifname, tmp___0);
      }
    }
#line 1222
    return (-1);
  }
#line 1226
  if ((int )ifr.ifr_ifru.ifru_map.base_addr >= 256) {
#line 1228
    target->base_addr = ifr.ifr_ifru.ifru_map.base_addr;
#line 1229
    target->active[SELECT_BASEADDR] = 1;
  }
#line 1231
  target->irq = ifr.ifr_ifru.ifru_map.irq;
#line 1232
  target->active[SELECT_IRQ] = 1;
#line 1234
  if (verbose) {
    {
#line 1235
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Querying %s : Got Base Address `0x%X\' and IRQ `%d\'.\n",
            ifname, (int )target->base_addr, (int )target->irq);
    }
  }
#line 1239
  return (0);
}
}
#line 1246 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
static int mapping_addiwproto(struct if_mapping *ifnode , int *active , char *string ,
                              size_t len , struct add_extra *extra , int linenum ) 
{ 


  {
#line 1255
  extra = extra;
#line 1258
  if (len >= sizeof(ifnode->iwproto)) {
    {
#line 1260
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wireless Protocol too long at line %d\n",
            linenum);
    }
#line 1261
    return (-1);
  }
  {
#line 1265
  memcpy((void */* __restrict  */)(ifnode->iwproto), (void const   */* __restrict  */)string,
         len + 1UL);
#line 1268
  ifnode->active[SELECT_IWPROTO] = 1;
#line 1269
  *(active + SELECT_IWPROTO) = 1;
  }
#line 1271
  if (verbose) {
    {
#line 1272
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Parsing : Added Wireless Protocol `%s\' from line %d.\n",
            ifnode->iwproto, linenum);
    }
  }
#line 1276
  return (0);
}
}
#line 1283 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
static int mapping_cmpiwproto(struct if_mapping *ifnode , struct if_mapping *target ) 
{ 
  int tmp ;

  {
  {
#line 1288
  tmp = fnmatch((char const   *)(ifnode->iwproto), (char const   *)(target->iwproto),
                1 << 4);
  }
#line 1288
  return (tmp);
}
}
#line 1295 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
static int mapping_getiwproto(int skfd , char const   *ifname , struct if_mapping *target ,
                              int flag ) 
{ 
  struct iwreq wrq ;
  int tmp ;

  {
  {
#line 1304
  flag = flag;
#line 1307
  tmp = iw_set_ext(skfd, ifname, 35585, & wrq);
  }
#line 1307
  if (tmp < 0) {
#line 1309
    return (-1);
  }
  {
#line 1311
  strncpy((char */* __restrict  */)(target->iwproto), (char const   */* __restrict  */)(wrq.u.name),
          (size_t )16);
#line 1312
  target->iwproto[16] = (char )'\000';
#line 1315
  target->active[SELECT_IWPROTO] = 1;
  }
#line 1317
  if (verbose) {
    {
#line 1318
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Querying %s : Got Wireless Protocol `%s\'.\n",
            ifname, target->iwproto);
    }
  }
#line 1322
  return (0);
}
}
#line 1329 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
static int mapping_addpcmciaslot(struct if_mapping *ifnode , int *active , char *string ,
                                 size_t len , struct add_extra *extra , int linenum ) 
{ 
  size_t n ;
  int tmp ;

  {
  {
#line 1340
  extra = extra;
#line 1343
  n = strspn((char const   *)string, "0123456789");
  }
#line 1344
  if (n < len) {
    {
#line 1346
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Invalid Pcmcia Slot `%s\' at line %d\n",
            string, linenum);
    }
#line 1348
    return (-1);
  } else {
    {
#line 1344
    tmp = sscanf((char const   */* __restrict  */)string, (char const   */* __restrict  */)"%d",
                 & ifnode->pcmcia_slot);
    }
#line 1344
    if (tmp != 1) {
      {
#line 1346
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Invalid Pcmcia Slot `%s\' at line %d\n",
              string, linenum);
      }
#line 1348
      return (-1);
    }
  }
#line 1351
  ifnode->active[SELECT_PCMCIASLOT] = 1;
#line 1352
  *(active + SELECT_PCMCIASLOT) = 1;
#line 1354
  if (verbose) {
    {
#line 1355
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Parsing : Added Pcmcia Slot `%d\' from line %d.\n",
            ifnode->pcmcia_slot, linenum);
    }
  }
#line 1358
  return (0);
}
}
#line 1365 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
static int mapping_cmppcmciaslot(struct if_mapping *ifnode , struct if_mapping *target ) 
{ 


  {
#line 1369
  return (! (ifnode->pcmcia_slot == target->pcmcia_slot));
}
}
#line 1385 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
static int mapping_getpcmciaslot(int skfd , char const   *ifname , struct if_mapping *target ,
                                 int flag ) 
{ 
  FILE *stream ;
  char *linebuf ;
  size_t linelen ;
  int linenum ;
  int *tmp ;
  char *tmp___0 ;
  char *p ;
  size_t n ;
  size_t k ;
  int pcmcia_slot ;
  int i ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  __ssize_t tmp___5 ;
  int tmp___6 ;

  {
  {
#line 1392
  linebuf = (char *)((void *)0);
#line 1393
  linelen = (size_t )0;
#line 1394
  linenum = 0;
#line 1397
  skfd = skfd;
#line 1398
  flag = flag;
#line 1401
  stream = fopen((char const   */* __restrict  */)"/var/lib/pcmcia/stab", (char const   */* __restrict  */)"r");
  }
#line 1402
  if (! stream) {
    {
#line 1405
    stream = fopen((char const   */* __restrict  */)"/var/run/stab", (char const   */* __restrict  */)"r");
    }
#line 1406
    if (! stream) {
      {
#line 1408
      tmp = __errno_location();
#line 1408
      tmp___0 = strerror(*tmp);
#line 1408
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Can\'t open PCMCIA Stab file `%s\' or `%s\': %s\n",
              "/var/lib/pcmcia/stab", "/var/run/stab", tmp___0);
      }
#line 1410
      return (-1);
    }
  }
  {
#line 1417
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1417
    tmp___5 = getline((char **/* __restrict  */)(& linebuf), (size_t */* __restrict  */)(& linelen),
                      (FILE */* __restrict  */)stream);
    }
#line 1417
    if (! (tmp___5 > 0L)) {
#line 1417
      goto while_break;
    }
#line 1426
    linenum ++;
#line 1429
    p = linebuf;
    {
#line 1430
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1430
      tmp___1 = __ctype_b_loc();
      }
#line 1430
      if (! ((int const   )*(*tmp___1 + (int )*p) & 8192)) {
#line 1430
        goto while_break___0;
      }
#line 1431
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1432
    if ((int )*p == 0) {
#line 1433
      goto while_continue;
    }
    {
#line 1434
    n = strcspn((char const   *)p, " \t\n");
#line 1435
    k = strspn((char const   *)p, "0123456789");
    }
#line 1436
    if (k < n) {
#line 1438
      goto while_continue;
    } else {
      {
#line 1436
      tmp___2 = sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%d",
                       & pcmcia_slot);
      }
#line 1436
      if (tmp___2 != 1) {
#line 1438
        goto while_continue;
      }
    }
#line 1442
    i = 0;
    {
#line 1442
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1442
      if (! (i < 4)) {
#line 1442
        goto while_break___1;
      }
      {
#line 1445
      p += n;
#line 1447
      tmp___3 = strspn((char const   *)p, " \t\n");
#line 1447
      p += tmp___3;
      }
#line 1448
      if ((int )*p == 0) {
#line 1449
        goto while_break___1;
      }
      {
#line 1451
      n = strcspn((char const   *)p, " \t\n");
#line 1442
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1453
    if ((int )*p == 0) {
#line 1454
      goto while_continue;
    }
    {
#line 1457
    *(p + n) = (char )'\000';
#line 1460
    tmp___4 = strcmp((char const   *)p, ifname);
    }
#line 1460
    if (! tmp___4) {
#line 1463
      target->pcmcia_slot = pcmcia_slot;
#line 1466
      target->active[SELECT_PCMCIASLOT] = 1;
#line 1468
      if (verbose) {
        {
#line 1469
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Querying %s : Got Pcmcia Slot `%d\'.\n",
                ifname, target->pcmcia_slot);
        }
      }
#line 1473
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1480
  free((void *)linebuf);
#line 1481
  fclose(stream);
  }
#line 1483
  if (target->active[SELECT_PCMCIASLOT]) {
#line 1483
    tmp___6 = 0;
  } else {
#line 1483
    tmp___6 = -1;
  }
#line 1483
  return (tmp___6);
}
}
#line 1490 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
static int mapping_addsysfs(struct if_mapping *ifnode , int *active , char *string ,
                            size_t len , struct add_extra *extra , int linenum ) 
{ 
  int findex ;
  char *sdup ;
  int tmp ;

  {
#line 1502
  if ((unsigned long )extra == (unsigned long )((void *)0)) {
    {
#line 1504
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: No SYSFS filename at line %d\n",
            linenum);
    }
#line 1505
    return (-1);
  } else
#line 1502
  if ((unsigned long )extra->modif_pos == (unsigned long )((void *)0)) {
    {
#line 1504
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: No SYSFS filename at line %d\n",
            linenum);
    }
#line 1505
    return (-1);
  }
#line 1509
  findex = 0;
  {
#line 1509
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1509
    if (! (findex < sysfs_global.filenum)) {
#line 1509
      goto while_break;
    }
    {
#line 1511
    tmp = strcmp((char const   *)extra->modif_pos, (char const   *)sysfs_global.filename[findex]);
    }
#line 1511
    if (! tmp) {
#line 1512
      goto while_break;
    }
#line 1509
    findex ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1516
  if (findex == sysfs_global.filenum) {
#line 1518
    if (findex == 8) {
      {
#line 1520
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Too many SYSFS filenames at line %d\n",
              linenum);
      }
#line 1521
      return (-1);
    }
    {
#line 1523
    sdup = strndup((char const   *)extra->modif_pos, extra->modif_len);
    }
#line 1524
    if ((unsigned long )sdup == (unsigned long )((void *)0)) {
      {
#line 1526
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Can\'t allocate SYSFS file\n");
      }
#line 1527
      return (-1);
    }
#line 1529
    sysfs_global.filename[findex] = sdup;
#line 1530
    (sysfs_global.filenum) ++;
  }
  {
#line 1534
  sdup = strndup((char const   *)string, len);
  }
#line 1535
  if ((unsigned long )sdup == (unsigned long )((void *)0)) {
    {
#line 1537
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Can\'t allocate SYSFS value\n");
    }
#line 1538
    return (-1);
  }
#line 1540
  ifnode->sysfs[findex] = sdup;
#line 1543
  ifnode->active[SELECT_SYSFS] = 1;
#line 1544
  *(active + SELECT_SYSFS) = 1;
#line 1546
  if (verbose) {
    {
#line 1547
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Parsing : Added SYSFS filename `%s\' value `%s\' from line %d.\n",
            sysfs_global.filename[findex], ifnode->sysfs[findex], linenum);
    }
  }
#line 1551
  return (0);
}
}
#line 1558 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
static int mapping_cmpsysfs(struct if_mapping *ifnode , struct if_mapping *target ) 
{ 
  int findex ;
  int match ;
  int tmp ;

  {
#line 1563
  match = 1;
#line 1566
  findex = 0;
  {
#line 1566
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1566
    if (! (findex < sysfs_global.filenum)) {
#line 1566
      goto while_break;
    }
#line 1569
    if ((unsigned long )ifnode->sysfs[findex] != (unsigned long )((void *)0)) {
#line 1571
      if ((unsigned long )target->sysfs[findex] == (unsigned long )((void *)0)) {
#line 1575
        match = 0;
      } else {
        {
#line 1571
        tmp = fnmatch((char const   *)ifnode->sysfs[findex], (char const   *)target->sysfs[findex],
                      1 << 4);
        }
#line 1571
        if (tmp) {
#line 1575
          match = 0;
        }
      }
    }
#line 1566
    findex ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1578
  return (! match);
}
}
#line 1585 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
static int mapping_getsysfs(int skfd , char const   *ifname , struct if_mapping *target ,
                            int flag ) 
{ 
  FILE *stream ;
  char *fname ;
  int fnsize ;
  char *linebuf ;
  size_t linelen ;
  char *sdup ;
  int findex ;
  int *tmp ;
  char *tmp___0 ;
  int i ;
  char *p ;
  size_t n ;
  char *token[3] ;
  size_t toklen[3] ;
  unsigned short const   **tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  __ssize_t tmp___5 ;
  void *tmp___6 ;
  char *p___0 ;
  ssize_t n___0 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int allocsize ;
  int retry ;
  char *linkpath ;
  int pathlen ;
  void *tmp___11 ;
  ssize_t tmp___12 ;
  int tmp___13 ;
  int cwd_fd ;
  int tmp___14 ;
  int ret ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
#line 1594
  linebuf = (char *)((void *)0);
#line 1595
  linelen = (size_t )0;
#line 1600
  skfd = skfd;
#line 1601
  flag = flag;
#line 1604
  if ((unsigned long )target->sysfs_devpath == (unsigned long )((void *)0)) {
#line 1607
    if ((unsigned long )sysfs_global.root == (unsigned long )((void *)0)) {
      {
#line 1610
      stream = fopen((char const   */* __restrict  */)"/proc/mounts", (char const   */* __restrict  */)"r");
      }
#line 1611
      if (! stream) {
        {
#line 1613
        tmp = __errno_location();
#line 1613
        tmp___0 = strerror(*tmp);
#line 1613
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Can\'t open /proc/mounts file: %s\n",
                tmp___0);
        }
#line 1615
        return (-1);
      }
      {
#line 1621
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 1621
        tmp___5 = getline((char **/* __restrict  */)(& linebuf), (size_t */* __restrict  */)(& linelen),
                          (FILE */* __restrict  */)stream);
        }
#line 1621
        if (! (tmp___5 > 0L)) {
#line 1621
          goto while_break;
        }
#line 1637
        p = linebuf;
#line 1638
        i = 0;
        {
#line 1638
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1638
          if (! (i < 3)) {
#line 1638
            goto while_break___0;
          }
          {
#line 1640
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 1640
            tmp___1 = __ctype_b_loc();
            }
#line 1640
            if (! ((int const   )*(*tmp___1 + (int )*p) & 8192)) {
#line 1640
              goto while_break___1;
            }
#line 1641
            p ++;
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 1642
          token[i] = p;
#line 1643
          n = strcspn((char const   *)p, " \t\n");
#line 1644
          toklen[i] = n;
#line 1645
          p += n;
#line 1638
          i ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1648
        if (n == 5UL) {
          {
#line 1648
          tmp___4 = strncasecmp((char const   *)token[2], "sysfs", (size_t )5);
          }
#line 1648
          if (! tmp___4) {
            {
#line 1651
            n = toklen[1];
#line 1652
            sdup = strndup((char const   *)token[1], n);
            }
#line 1653
            if (n == 0UL) {
              {
#line 1655
              tmp___2 = __errno_location();
#line 1655
              tmp___3 = strerror(*tmp___2);
#line 1655
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Can\'t parse /proc/mounts file: %s\n",
                      tmp___3);
              }
#line 1658
              return (-1);
            } else
#line 1653
            if ((unsigned long )sdup == (unsigned long )((void *)0)) {
              {
#line 1655
              tmp___2 = __errno_location();
#line 1655
              tmp___3 = strerror(*tmp___2);
#line 1655
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Can\'t parse /proc/mounts file: %s\n",
                      tmp___3);
              }
#line 1658
              return (-1);
            }
#line 1661
            sysfs_global.root = sdup;
#line 1662
            sysfs_global.rlen = (int )n;
#line 1663
            goto while_break;
          }
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1669
      fclose(stream);
      }
#line 1672
      if ((unsigned long )sysfs_global.root == (unsigned long )((void *)0)) {
        {
#line 1674
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Can\'t find sysfs in /proc/mounts file\n");
#line 1676
        free((void *)linebuf);
        }
#line 1677
        return (-1);
      }
    }
    {
#line 1683
    fnsize = ((sysfs_global.rlen + 11) + 16) + 1;
#line 1684
    tmp___6 = malloc((size_t )fnsize);
#line 1684
    fname = (char *)tmp___6;
    }
#line 1685
    if ((unsigned long )fname == (unsigned long )((void *)0)) {
      {
#line 1687
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Can\'t allocate SYSFS devpath\n");
      }
#line 1688
      return (-1);
    }
    {
#line 1691
    target->sysfs_devplen = sprintf((char */* __restrict  */)fname, (char const   */* __restrict  */)"%s/class/net/%s",
                                    sysfs_global.root, ifname);
#line 1693
    target->sysfs_devpath = fname;
    }
  }
#line 1697
  findex = 0;
  {
#line 1697
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1697
    if (! (findex < sysfs_global.filenum)) {
#line 1697
      goto while_break___2;
    }
    {
#line 1703
    tmp___7 = strlen((char const   *)sysfs_global.filename[findex]);
#line 1703
    fnsize = (int )(((size_t )(target->sysfs_devplen + 1) + tmp___7) + 1UL);
#line 1705
    tmp___8 = malloc((size_t )fnsize);
#line 1705
    fname = (char *)tmp___8;
    }
#line 1706
    if ((unsigned long )fname == (unsigned long )((void *)0)) {
      {
#line 1708
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Can\'t allocate SYSFS filename\n");
#line 1709
      free((void *)linebuf);
      }
#line 1710
      return (-1);
    }
    {
#line 1712
    sprintf((char */* __restrict  */)fname, (char const   */* __restrict  */)"%s/%s",
            target->sysfs_devpath, sysfs_global.filename[findex]);
#line 1716
    stream = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"r");
    }
#line 1717
    if (! stream) {
#line 1720
      if (verbose) {
        {
#line 1721
        tmp___9 = __errno_location();
#line 1721
        tmp___10 = strerror(*tmp___9);
#line 1721
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Can\'t open file `%s\': %s\n",
                fname, tmp___10);
        }
      }
#line 1724
      goto __Cont;
    }
    {
#line 1728
    n___0 = getline((char **/* __restrict  */)(& linebuf), (size_t */* __restrict  */)(& linelen),
                    (FILE */* __restrict  */)stream);
#line 1729
    fclose(stream);
    }
#line 1730
    if (n___0 <= 0L) {
#line 1743
      allocsize = 128;
#line 1744
      retry = 16;
#line 1745
      linkpath = (char *)((void *)0);
      {
#line 1749
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 1751
        allocsize *= 2;
#line 1752
        tmp___11 = realloc((void *)linkpath, (size_t )allocsize);
#line 1752
        linkpath = (char *)tmp___11;
#line 1753
        tmp___12 = readlink((char const   */* __restrict  */)fname, (char */* __restrict  */)linkpath,
                            (size_t )allocsize);
#line 1753
        pathlen = (int )tmp___12;
        }
#line 1755
        if (pathlen < allocsize) {
#line 1756
          goto while_break___3;
        }
#line 1749
        tmp___13 = retry;
#line 1749
        retry --;
#line 1749
        if (! (tmp___13 > 0)) {
#line 1749
          goto while_break___3;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1761
      if (pathlen > 0) {
#line 1763
        *(linkpath + pathlen) = (char )'\000';
      } else {
        {
#line 1767
        free((void *)linkpath);
#line 1775
        tmp___16 = strcmp((char const   *)((fname + fnsize) - 4), "/..");
        }
#line 1775
        if (tmp___16) {
#line 1806
          if (verbose) {
            {
#line 1807
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Can\'t read file `%s\'\n",
                    fname);
            }
          }
#line 1809
          goto __Cont;
        } else {
          {
#line 1780
          tmp___14 = open(".", 0);
#line 1780
          cwd_fd = tmp___14;
#line 1781
          linkpath = (char *)((void *)0);
          }
#line 1782
          if (cwd_fd > 0) {
            {
#line 1784
            tmp___15 = chdir((char const   *)fname);
#line 1784
            ret = tmp___15;
            }
#line 1785
            if (ret == 0) {
              {
#line 1787
              linkpath = getcwd((char *)((void *)0), (size_t )0);
              }
            }
            {
#line 1789
            fchdir(cwd_fd);
            }
          }
#line 1792
          if (! linkpath) {
            {
#line 1794
            free((void *)linkpath);
            }
#line 1795
            if (verbose) {
              {
#line 1796
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Can\'t read parent directory `%s\'\n",
                      fname);
              }
            }
#line 1798
            goto __Cont;
          }
        }
      }
      {
#line 1816
      p___0 = basename((char const   *)linkpath);
#line 1817
      sdup = strdup((char const   *)p___0);
#line 1818
      free((void *)linkpath);
      }
    } else {
#line 1824
      p___0 = linebuf;
#line 1825
      if ((int )*(p___0 + (n___0 - 1L)) == 10) {
#line 1826
        n___0 --;
      }
      {
#line 1827
      sdup = strndup((char const   *)p___0, (size_t )n___0);
      }
    }
#line 1829
    if ((unsigned long )sdup == (unsigned long )((void *)0)) {
      {
#line 1831
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Can\'t allocate SYSFS value\n");
#line 1832
      free((void *)linebuf);
      }
#line 1833
      return (-1);
    }
#line 1835
    target->sysfs[findex] = sdup;
#line 1838
    target->active[SELECT_SYSFS] = 1;
#line 1840
    if (verbose) {
      {
#line 1841
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Querying %s : Got SYSFS filename `%s\' value `%s\'.\n",
              ifname, sysfs_global.filename[findex], target->sysfs[findex]);
      }
    }
    __Cont: /* CIL Label */ 
#line 1697
    findex ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1849
  free((void *)linebuf);
  }
#line 1851
  if (target->active[SELECT_SYSFS]) {
#line 1851
    tmp___17 = 0;
  } else {
#line 1851
    tmp___17 = -1;
  }
#line 1851
  return (tmp___17);
}
}
#line 1858 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
static int mapping_addprevname(struct if_mapping *ifnode , int *active , char *string ,
                               size_t len , struct add_extra *extra , int linenum ) 
{ 


  {
#line 1867
  extra = extra;
#line 1870
  if (len >= sizeof(ifnode->prevname)) {
    {
#line 1872
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Old Interface Name too long at line %d\n",
            linenum);
    }
#line 1873
    return (-1);
  }
  {
#line 1877
  memcpy((void */* __restrict  */)(ifnode->prevname), (void const   */* __restrict  */)string,
         len + 1UL);
#line 1880
  ifnode->active[SELECT_PREVNAME] = 1;
#line 1881
  *(active + SELECT_PREVNAME) = 1;
  }
#line 1883
  if (verbose) {
    {
#line 1884
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Parsing : Added Old Interface Name `%s\' from line %d.\n",
            ifnode->prevname, linenum);
    }
  }
#line 1888
  return (0);
}
}
#line 1896 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
static int mapping_cmpprevname(struct if_mapping *ifnode , struct if_mapping *target ) 
{ 
  int tmp ;

  {
  {
#line 1901
  tmp = fnmatch((char const   *)(ifnode->prevname), (char const   *)(target->ifname),
                1 << 4);
  }
#line 1901
  return (tmp);
}
}
#line 1908 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
static int mapping_getprevname(int skfd , char const   *ifname , struct if_mapping *target ,
                               int flag ) 
{ 


  {
#line 1915
  skfd = skfd;
#line 1915
  ifname = ifname;
#line 1915
  flag = flag;
#line 1920
  target->active[SELECT_PREVNAME] = 1;
#line 1922
  return (0);
}
}
#line 1937 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
static struct if_mapping *mapping_create(char *pos , int len , int linenum ) 
{ 
  struct if_mapping *ifnode ;
  char *star ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 1945
  tmp = memchr((void const   *)pos, '*', (size_t )len);
#line 1945
  star = (char *)tmp;
  }
#line 1948
  if (len + ((unsigned long )star != (unsigned long )((void *)0)) > 16) {
    {
#line 1950
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Interface name `%.*s\' too long at line %d\n",
            len, pos, linenum);
    }
#line 1952
    return ((struct if_mapping *)((void *)0));
  }
  {
#line 1956
  tmp___0 = calloc((size_t )1, sizeof(if_mapping ));
#line 1956
  ifnode = (struct if_mapping *)tmp___0;
  }
#line 1957
  if (! ifnode) {
    {
#line 1959
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Can\'t allocate interface mapping.\n");
    }
#line 1960
    return ((struct if_mapping *)((void *)0));
  }
  {
#line 1964
  memcpy((void */* __restrict  */)(ifnode->ifname), (void const   */* __restrict  */)pos,
         (size_t )len);
#line 1965
  ifnode->ifname[len] = (char )'\000';
  }
#line 1970
  if (! force_takeover) {
    {
#line 1970
    tmp___1 = strcmp((char const   *)(ifnode->ifname), "eth0");
    }
#line 1970
    if (tmp___1) {
      {
#line 1970
      tmp___2 = strcmp((char const   *)(ifnode->ifname), "wlan0");
      }
#line 1970
      if (! tmp___2) {
        {
#line 1972
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Interface name is `%s\' at line %d, can\'t be mapped reliably.\n",
                ifnode->ifname, linenum);
        }
      }
    } else {
      {
#line 1972
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Interface name is `%s\' at line %d, can\'t be mapped reliably.\n",
              ifnode->ifname, linenum);
      }
    }
  }
  {
#line 1975
  tmp___3 = strchr((char const   *)(ifnode->ifname), ':');
  }
#line 1975
  if (tmp___3) {
    {
#line 1976
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Alias device `%s\' at line %d probably can\'t be mapped.\n",
            ifnode->ifname, linenum);
    }
  }
#line 1979
  if (verbose) {
    {
#line 1980
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Parsing : Added Mapping `%s\' from line %d.\n",
            ifnode->ifname, linenum);
    }
  }
#line 1984
  return (ifnode);
}
}
#line 1991 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
__inline static struct mapping_selector  const  *selector_find(char const   *string ,
                                                               size_t slen , int linenum ) 
{ 
  struct mapping_selector  const  *found ;
  int ambig ;
  int i ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 1996
  found = (struct mapping_selector  const  *)((void *)0);
#line 1997
  ambig = 0;
#line 2001
  i = 0;
  {
#line 2001
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2001
    if (! ((unsigned long )selector_list[i].name != (unsigned long )((void *)0))) {
#line 2001
      goto while_break;
    }
    {
#line 2004
    tmp = strncasecmp((char const   *)selector_list[i].name, string, slen);
    }
#line 2004
    if (tmp != 0) {
#line 2005
      goto __Cont;
    }
    {
#line 2008
    tmp___0 = strlen((char const   *)selector_list[i].name);
    }
#line 2008
    if (slen == tmp___0) {
#line 2009
      return (& selector_list[i]);
    }
#line 2012
    if ((unsigned long )found == (unsigned long )((void *)0)) {
#line 2014
      found = & selector_list[i];
    } else
#line 2017
    if ((unsigned long )selector_list[i].add_fn != (unsigned long )found->add_fn) {
#line 2018
      ambig = 1;
    }
    __Cont: /* CIL Label */ 
#line 2001
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2021
  if ((unsigned long )found == (unsigned long )((void *)0)) {
    {
#line 2023
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Unknown selector `%.*s\' at line %d.\n",
            (int )slen, string, linenum);
    }
#line 2025
    return ((struct mapping_selector  const  *)((void *)0));
  }
#line 2028
  if (ambig) {
    {
#line 2030
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Selector `%.*s\'at line %d is ambiguous.\n",
            (int )slen, string, linenum);
    }
#line 2032
    return ((struct mapping_selector  const  *)((void *)0));
  }
#line 2035
  return (found);
}
}
#line 2043 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
static int mapping_readfile(char const   *filename ) 
{ 
  FILE *stream ;
  char *linebuf ;
  size_t linelen ;
  int linenum ;
  struct add_extra extrainfo ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  struct if_mapping *ifnode ;
  char *p ;
  char *e ;
  size_t n ;
  int ret ;
  unsigned short const   **tmp___2 ;
  size_t tmp___3 ;
  struct mapping_selector  const  *selector ;
  struct add_extra *extra ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  __ssize_t tmp___6 ;

  {
  {
#line 2047
  linebuf = (char *)((void *)0);
#line 2048
  linelen = (size_t )0;
#line 2049
  linenum = 0;
#line 2053
  bzero((void *)(selector_active), sizeof(selector_active));
#line 2056
  tmp___1 = strcmp(filename, "-");
  }
#line 2056
  if (tmp___1) {
    {
#line 2065
    stream = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
    }
#line 2066
    if (! stream) {
      {
#line 2068
      tmp = __errno_location();
#line 2068
      tmp___0 = strerror(*tmp);
#line 2068
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Can\'t open configuration file `%s\': %s\n",
              filename, tmp___0);
      }
#line 2070
      return (-1);
    }
  } else {
#line 2059
    stream = stdin;
  }
  {
#line 2077
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2077
    tmp___6 = getline((char **/* __restrict  */)(& linebuf), (size_t */* __restrict  */)(& linelen),
                      (FILE */* __restrict  */)stream);
    }
#line 2077
    if (! (tmp___6 > 0L)) {
#line 2077
      goto while_break;
    }
    {
#line 2083
    ret = -13;
#line 2086
    linenum ++;
#line 2089
    p = strchr((char const   *)linebuf, '#');
    }
#line 2089
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 2090
      *p = (char )'\000';
    }
#line 2093
    p = linebuf;
    {
#line 2094
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 2094
      tmp___2 = __ctype_b_loc();
      }
#line 2094
      if (! ((int const   )*(*tmp___2 + (int )*p) & 8192)) {
#line 2094
        goto while_break___0;
      }
#line 2095
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2096
    if ((int )*p == 0) {
#line 2097
      goto while_continue;
    }
    {
#line 2098
    n = strcspn((char const   *)p, " \t\n");
#line 2101
    ifnode = mapping_create(p, (int )n, linenum);
    }
#line 2102
    if (! ifnode) {
#line 2103
      goto while_continue;
    }
    {
#line 2104
    p += n;
#line 2105
    tmp___3 = strspn((char const   *)p, " \t\n");
#line 2105
    p += tmp___3;
    }
    {
#line 2108
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2108
      if (! ((int )*p != 0)) {
#line 2108
        goto while_break___1;
      }
      {
#line 2110
      selector = (struct mapping_selector  const  *)((void *)0);
#line 2111
      extra = (struct add_extra *)((void *)0);
#line 2114
      n = strcspn((char const   *)p, " \t\n{");
#line 2117
      selector = selector_find((char const   *)p, n, linenum);
      }
#line 2118
      if (! selector) {
#line 2120
        ret = -1;
#line 2121
        goto while_break___1;
      }
#line 2123
      p += n;
#line 2126
      if ((int )*p == 123) {
        {
#line 2128
        p ++;
#line 2130
        e = strchr((char const   *)p, '}');
        }
#line 2131
        if ((unsigned long )e == (unsigned long )((void *)0)) {
          {
#line 2133
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: unterminated selector modifier value on line %d\n",
                  linenum);
#line 2136
          ret = -1;
          }
#line 2137
          goto while_break___1;
        }
#line 2140
        extrainfo.modif_pos = p;
#line 2141
        extrainfo.modif_len = (size_t )(e - p);
#line 2142
        extra = & extrainfo;
#line 2144
        *(e + 0) = (char )'\000';
#line 2146
        p = e + 1;
      }
      {
#line 2150
      tmp___4 = strspn((char const   *)p, " \t\n");
#line 2150
      p += tmp___4;
      }
#line 2151
      if ((int )*p == 0) {
        {
#line 2153
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: no value for selector `%s\' on line %d\n",
                selector->name, linenum);
#line 2155
        ret = -1;
        }
#line 2156
        goto while_break___1;
      }
#line 2159
      if ((int )*p == 34) {
        {
#line 2161
        p ++;
#line 2162
        e = strchr((char const   *)p, '\"');
        }
#line 2163
        if ((unsigned long )e == (unsigned long )((void *)0)) {
          {
#line 2165
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: unterminated quoted value on line %d\n",
                  linenum);
#line 2168
          ret = -1;
          }
#line 2169
          goto while_break___1;
        }
#line 2171
        n = (size_t )(e - p);
#line 2172
        e ++;
      } else {
        {
#line 2177
        n = strcspn((char const   *)p, " \t\n");
#line 2178
        e = p + n;
        }
      }
#line 2181
      if ((int )*e != 0) {
#line 2182
        e ++;
      }
      {
#line 2184
      *(p + n) = (char )'\000';
#line 2187
      ret = (*(selector->add_fn))(ifnode, selector_active, p, n, extra, linenum);
      }
#line 2189
      if (ret < 0) {
#line 2190
        goto while_break___1;
      }
      {
#line 2193
      p = e;
#line 2194
      tmp___5 = strspn((char const   *)p, " \t\n");
#line 2194
      p += tmp___5;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2199
    if (ret < 0) {
#line 2202
      if (ret == -13) {
        {
#line 2203
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Line %d ignored, no valid selectors\n",
                linenum);
        }
      } else {
        {
#line 2206
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Line %d ignored due to prior errors\n",
                linenum);
        }
      }
      {
#line 2209
      free((void *)ifnode);
      }
    } else {
#line 2214
      ifnode->next = mapping_list;
#line 2215
      mapping_list = ifnode;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2220
  free((void *)linebuf);
  }
#line 2223
  if ((unsigned long )stream != (unsigned long )stdin) {
    {
#line 2224
    fclose(stream);
    }
  }
#line 2225
  return (0);
}
}
#line 2232 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
static struct if_mapping *mapping_extract(int skfd , char const   *ifname ) 
{ 
  struct if_mapping *target ;
  int i ;
  void *tmp ;

  {
  {
#line 2240
  tmp = calloc((size_t )1, sizeof(if_mapping ));
#line 2240
  target = (struct if_mapping *)tmp;
  }
#line 2241
  if (! target) {
    {
#line 2243
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Can\'t allocate interface mapping.\n");
    }
#line 2244
    return ((struct if_mapping *)((void *)0));
  }
  {
#line 2248
  strcpy((char */* __restrict  */)(target->ifname), (char const   */* __restrict  */)ifname);
#line 2251
  i = 0;
  }
  {
#line 2251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2251
    if (! (i < 14)) {
#line 2251
      goto while_break;
    }
#line 2254
    if (selector_active[i] != 0) {
      {
#line 2257
      (*(selector_list[i].get_fn))(skfd, ifname, target, selector_active[i]);
      }
    }
#line 2251
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2263
  return (target);
}
}
#line 2270 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
static struct if_mapping *mapping_find(struct if_mapping *target ) 
{ 
  struct if_mapping *ifnode ;
  int i ;
  int matches ;
  int tmp ;

  {
#line 2277
  ifnode = mapping_list;
  {
#line 2277
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2277
    if (! ((unsigned long )ifnode != (unsigned long )((void *)0))) {
#line 2277
      goto while_break;
    }
#line 2279
    matches = 1;
#line 2282
    i = 0;
    {
#line 2282
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2282
      if (! (i < 14)) {
#line 2282
        goto while_break___0;
      }
#line 2285
      if (ifnode->active[i] != 0) {
#line 2288
        if (target->active[i] == 0) {
#line 2291
          matches = 0;
#line 2292
          goto while_break___0;
        } else {
          {
#line 2288
          tmp = (*(selector_list[i].cmp_fn))(ifnode, target);
          }
#line 2288
          if (tmp != 0) {
#line 2291
            matches = 0;
#line 2292
            goto while_break___0;
          }
        }
      }
#line 2282
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2298
    if (matches) {
#line 2299
      return (ifnode);
    }
#line 2277
    ifnode = ifnode->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2303
  return ((struct if_mapping *)((void *)0));
}
}
#line 2319 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
__inline static void probe_mappings(int skfd ) 
{ 
  struct if_mapping *ifnode ;
  struct ifreq ifr ;
  char *tmp ;

  {
#line 2326
  ifnode = mapping_list;
  {
#line 2326
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2326
    if (! ((unsigned long )ifnode != (unsigned long )((void *)0))) {
#line 2326
      goto while_break;
    }
    {
#line 2329
    tmp = strchr((char const   *)(ifnode->ifname), '*');
    }
#line 2329
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 2330
      goto __Cont;
    }
#line 2332
    if (verbose) {
      {
#line 2333
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Probing : Trying to load/probe interface [%s]\n",
              ifnode->ifname);
      }
    }
    {
#line 2342
    strncpy((char */* __restrict  */)(ifr.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)(ifnode->ifname),
            (size_t )16);
#line 2343
    ioctl(skfd, 35111UL, & ifr);
    }
    __Cont: /* CIL Label */ 
#line 2326
    ifnode = ifnode->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2345
  return;
}
}
#line 2354 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
__inline static void probe_debian(int skfd ) 
{ 
  FILE *stream ;
  char *linebuf ;
  size_t linelen ;
  struct ifreq ifr ;
  char *p ;
  char *e ;
  size_t n ;
  size_t tmp ;
  int tmp___0 ;
  __ssize_t tmp___1 ;

  {
  {
#line 2358
  linebuf = (char *)((void *)0);
#line 2359
  linelen = (size_t )0;
#line 2363
  stream = fopen((char const   */* __restrict  */)(DEBIAN_CONFIG_FILE), (char const   */* __restrict  */)"r");
  }
#line 2364
  if ((unsigned long )stream == (unsigned long )((void *)0)) {
    {
#line 2366
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: can\'t open file [%s]\n",
            DEBIAN_CONFIG_FILE);
    }
#line 2367
    return;
  }
  {
#line 2373
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2373
    tmp___1 = getline((char **/* __restrict  */)(& linebuf), (size_t */* __restrict  */)(& linelen),
                      (FILE */* __restrict  */)stream);
    }
#line 2373
    if (! (tmp___1 > 0L)) {
#line 2373
      goto while_break;
    }
    {
#line 2380
    tmp___0 = strncasecmp((char const   *)linebuf, "auto ", (size_t )5);
    }
#line 2380
    if (! tmp___0) {
      {
#line 2383
      p = linebuf + 5;
#line 2386
      e = strchr((char const   *)p, '#');
      }
#line 2387
      if ((unsigned long )e != (unsigned long )((void *)0)) {
#line 2388
        *e = (char )'\000';
      }
      {
#line 2391
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2391
        if (! ((int )*p != 0)) {
#line 2391
          goto while_break___0;
        }
        {
#line 2394
        n = strcspn((char const   *)p, " \t\n");
#line 2397
        e = p + n;
        }
#line 2399
        if ((int )*e != 0) {
#line 2400
          e ++;
        }
#line 2402
        *(p + n) = (char )'\000';
#line 2404
        if (verbose) {
          {
#line 2405
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Probing : Trying to load interface [%s]\n",
                  p);
          }
        }
        {
#line 2409
        strncpy((char */* __restrict  */)(ifr.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)p,
                (size_t )16);
#line 2410
        ioctl(skfd, 35111UL, & ifr);
#line 2413
        p = e;
#line 2414
        tmp = strspn((char const   *)p, " \t\n");
#line 2414
        p += tmp;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2420
  fclose(stream);
  }
#line 2421
  return;
}
}
#line 2430 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
static int process_rename(int skfd , char *ifname , char *newname ) 
{ 
  char retname[17] ;
  int len ;
  char *star ;
  size_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 2439
  tmp = strlen((char const   *)newname);
#line 2439
  len = (int )tmp;
#line 2440
  star = strchr((char const   *)newname, '*');
  }
#line 2443
  if (len + ((unsigned long )star != (unsigned long )((void *)0)) > 16) {
    {
#line 2445
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Interface name `%s\' too long.\n",
            newname);
    }
#line 2447
    return (-1);
  }
  {
#line 2451
  tmp___2 = if_set_name(skfd, (char const   *)ifname, (char const   *)newname, retname);
  }
#line 2451
  if (tmp___2 < 0) {
    {
#line 2453
    tmp___0 = __errno_location();
#line 2453
    tmp___1 = strerror(*tmp___0);
#line 2453
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: cannot change name of %s to %s: %s\n",
            ifname, newname, tmp___1);
    }
#line 2455
    return (-1);
  }
  {
#line 2461
  printf((char const   */* __restrict  */)"%s\n", retname);
  }
#line 2464
  return (0);
}
}
#line 2471 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
static int process_ifname(int skfd , char *ifname , char **args , int count ) 
{ 
  struct if_mapping *target ;
  struct if_mapping  const  *mapping ;
  char retname[17] ;
  char const   *env ;
  char *tmp ;
  int env_len ;
  size_t tmp___0 ;
  void *tmp___1 ;
  struct if_mapping *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *pos ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 2482
  args = args;
#line 2482
  count = count;
#line 2485
  target = mapping_extract(skfd, (char const   *)ifname);
  }
#line 2486
  if ((unsigned long )target == (unsigned long )((void *)0)) {
#line 2487
    return (-1);
  }
#line 2490
  if (udev_output) {
    {
#line 2494
    tmp = getenv("DEVPATH");
#line 2494
    env = (char const   *)tmp;
    }
#line 2495
    if (env) {
      {
#line 2497
      tmp___0 = strlen(env);
#line 2497
      env_len = (int )tmp___0;
#line 2498
      target->sysfs_devplen = env_len;
#line 2500
      tmp___1 = malloc((size_t )((env_len + 16) + 1));
#line 2500
      target->sysfs_devpath = (char *)tmp___1;
      }
#line 2501
      if ((unsigned long )target->sysfs_devpath != (unsigned long )((void *)0)) {
        {
#line 2502
        memcpy((void */* __restrict  */)target->sysfs_devpath, (void const   */* __restrict  */)env,
               (size_t )(env_len + 1));
        }
      }
    }
  }
  {
#line 2508
  tmp___2 = mapping_find(target);
#line 2508
  mapping = (struct if_mapping  const  *)tmp___2;
  }
#line 2509
  if ((unsigned long )mapping == (unsigned long )((void *)0)) {
#line 2510
    return (-1);
  }
#line 2514
  if ((unsigned long )new_name != (unsigned long )((void *)0)) {
    {
#line 2514
    tmp___3 = if_match_ifname((char const   *)(mapping->ifname), (char const   *)new_name);
    }
#line 2514
    if (tmp___3 != 0) {
#line 2515
      return (-1);
    }
  }
#line 2520
  if (dry_run) {
    {
#line 2522
    strcpy((char */* __restrict  */)(retname), (char const   */* __restrict  */)(mapping->ifname));
#line 2523
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Dry-run : Would rename %s to %s.\n",
            target->ifname, mapping->ifname);
    }
  } else {
    {
#line 2529
    tmp___6 = if_set_name(skfd, (char const   *)(target->ifname), (char const   *)(mapping->ifname),
                          retname);
    }
#line 2529
    if (tmp___6 < 0) {
      {
#line 2531
      tmp___4 = __errno_location();
#line 2531
      tmp___5 = strerror(*tmp___4);
#line 2531
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: cannot change name of %s to %s: %s\n",
              target->ifname, mapping->ifname, tmp___5);
      }
#line 2533
      return (-1);
    }
  }
#line 2538
  num_mapping_match ++;
#line 2541
  if (print_newname) {
#line 2543
    if (! udev_output) {
      {
#line 2547
      printf((char const   */* __restrict  */)"%s\n", retname);
      }
    } else {
      {
#line 2552
      tmp___8 = strcmp((char const   *)(target->ifname), (char const   *)(retname));
      }
#line 2552
      if (tmp___8) {
#line 2556
        if (! target->sysfs_devpath) {
          {
#line 2557
          mapping_getsysfs(skfd, (char const   *)ifname, target, 0);
          }
        }
        {
#line 2559
        pos = strrchr((char const   *)target->sysfs_devpath, '/');
        }
#line 2560
        if ((unsigned long )pos != (unsigned long )((void *)0)) {
          {
#line 2560
          tmp___7 = strcmp((char const   *)(target->ifname), (char const   *)(pos + 1));
          }
#line 2560
          if (! tmp___7) {
            {
#line 2561
            strcpy((char */* __restrict  */)(pos + 1), (char const   */* __restrict  */)(retname));
            }
          }
        }
        {
#line 2563
        printf((char const   */* __restrict  */)"DEVPATH=%s\nINTERFACE=%s\nINTERFACE_OLD=%s\n",
               target->sysfs_devpath, retname, target->ifname);
        }
      }
    }
  }
#line 2569
  return (0);
}
}
#line 2576 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
static int process_iflist(int skfd , char **args , int count , int use_probe , int is_debian ) 
{ 


  {
#line 2583
  num_takeover = 0;
#line 2584
  num_mapping_match = 0;
#line 2587
  if (use_probe) {
#line 2589
    if (is_debian) {
      {
#line 2590
      probe_debian(skfd);
      }
    } else {
      {
#line 2592
      probe_mappings(skfd);
      }
    }
  }
  {
#line 2596
  iw_enum_devices(skfd, & process_ifname, args, count);
  }
#line 2599
  return (0);
}
}
#line 2608 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/ifrename.c"
static void usage(void) 
{ 


  {
  {
#line 2611
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage: ifrename [-c configurationfile] [-i ifname] [-p] [-t] [-d] [-D]\n");
#line 2612
  exit(1);
  }
}
}
#line 164 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static int const   families___2[4]  = {      (int const   )2,      (int const   )4,      (int const   )3,      (int const   )5};
#line 381 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static int print_iface_version_info___2(int skfd , char *ifname , char **args , int count ) 
{ 
  struct iwreq wrq ;
  char buffer[sizeof(iwrange ) * 2UL] ;
  struct iw_range *range ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 392
  args = args;
#line 392
  count = count;
#line 396
  tmp = iw_set_ext(skfd, (char const   *)ifname, 35585, & wrq);
  }
#line 396
  if (tmp < 0) {
#line 397
    return (-1);
  }
  {
#line 400
  memset((void *)(buffer), 0, sizeof(buffer));
#line 402
  wrq.u.data.pointer = (void *)(buffer);
#line 403
  wrq.u.data.length = (__u16 )sizeof(buffer);
#line 404
  wrq.u.data.flags = (__u16 )0;
#line 405
  tmp___0 = iw_set_ext(skfd, (char const   *)ifname, 35595, & wrq);
  }
#line 405
  if (tmp___0 < 0) {
    {
#line 408
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  Driver has no Wireless Extension version information.\n\n",
            ifname);
    }
#line 409
    return (0);
  }
#line 413
  range = (struct iw_range *)(buffer);
#line 417
  if ((int )wrq.u.data.length >= 300) {
    {
#line 420
    printf((char const   */* __restrict  */)"%-8.16s  Recommend Wireless Extension v%d or later,\n",
           ifname, (int )range->we_version_source);
#line 422
    printf((char const   */* __restrict  */)"          Currently compiled with Wireless Extension v%d.\n\n",
           (int )range->we_version_compiled);
    }
  } else {
    {
#line 427
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  Wireless Extension version too old.\n\n",
            ifname);
    }
  }
#line 432
  return (0);
}
}
#line 1687 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static int iw_pass_key___2(char const   *input , unsigned char *key ) 
{ 


  {
  {
#line 1691
  input = input;
#line 1691
  key = key;
#line 1692
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Passphrase not implemented\n");
  }
#line 1693
  return (-1);
}
}
#line 2402 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static int const   priv_type_size___2[8]  = 
#line 2402
  {      (int const   )0,      (int const   )1,      (int const   )1,      (int const   )0, 
        (int const   )sizeof(__u32 ),      (int const   )sizeof(struct iw_freq ),      (int const   )sizeof(struct sockaddr ),      (int const   )0};
#line 2480 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static struct iw_ioctl_description  const  standard_ioctl_descr___2[55]  = 
#line 2480
  {      {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )2, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )2}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )5, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )2}, 
        {(__u8 )5, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )4, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )2}, 
        {(__u8 )4, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )sizeof(struct iw_range ),
      (__u32 )1}, 
        {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )8, (unsigned char)0, (__u16 )sizeof(struct sockaddr ), (unsigned short)0,
      (__u16 )8, 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )(sizeof(struct sockaddr ) + sizeof(struct iw_quality )),
      (unsigned short)0, (__u16 )8, 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )sizeof(struct iw_thrspy ), (__u16 )1, (__u16 )1,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )sizeof(struct iw_thrspy ), (__u16 )1, (__u16 )1,
      0U}, 
        {(__u8 )6, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )6, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (__u16 )sizeof(struct iw_mlme ), (__u16 )sizeof(struct iw_mlme ),
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )(sizeof(struct sockaddr ) + sizeof(struct iw_quality )),
      (unsigned short)0, (__u16 )64, (__u32 )8}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (__u16 )0, (__u16 )sizeof(struct iw_scan_req ),
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )4096, (__u32 )8}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )33, (__u32 )2}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )33, (__u32 )1}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )33, 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )33, 0U}, 
        {(unsigned char)0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(unsigned char)0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )0, (unsigned short)0, (__u16 )64, (__u32 )6}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )0, (unsigned short)0, (__u16 )64, (__u32 )5}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )1024, 0U}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )1024, 0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (__u16 )sizeof(struct iw_encode_ext ),
      (__u16 )(sizeof(struct iw_encode_ext ) + 64UL), 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (__u16 )sizeof(struct iw_encode_ext ),
      (__u16 )(sizeof(struct iw_encode_ext ) + 64UL), 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (__u16 )sizeof(struct iw_pmksa ), (__u16 )sizeof(struct iw_pmksa ),
      0U}};
#line 2712 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static unsigned int const   standard_ioctl_num___2  =    (unsigned int const   )(sizeof(standard_ioctl_descr___2) / sizeof(struct iw_ioctl_description ));
#line 2719 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static struct iw_ioctl_description  const  standard_event_descr___2[10]  = 
#line 2719
  {      {(__u8 )6, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )10, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )256, 0U}, 
        {(__u8 )6, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )6, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )1024, 0U}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )sizeof(struct iw_michaelmicfailure ),
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )1024, 0U}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )1024, 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )sizeof(struct iw_pmkid_cand ),
      0U}};
#line 2763 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static unsigned int const   standard_event_num___2  =    (unsigned int const   )(sizeof(standard_event_descr___2) / sizeof(struct iw_ioctl_description ));
#line 2767 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static int const   event_type_size___2[11]  = 
#line 2767
  {      (int const   )4,      (int const   )0,      (int const   )20,      (int const   )0, 
        (int const   )(4UL + sizeof(__u32 )),      (int const   )(4UL + sizeof(struct iw_freq )),      (int const   )(4UL + sizeof(struct sockaddr )),      (int const   )0, 
        (int const   )8,      (int const   )(4UL + sizeof(struct iw_param )),      (int const   )(4UL + sizeof(struct iw_quality ))};
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 123 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockname)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 174
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 57 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwevent.c"
struct wireless_iface *interface_cache  =    (struct wireless_iface *)((void *)0);
#line 83 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwevent.c"
__inline static void ( __attribute__((__always_inline__)) rtnl_close)(struct rtnl_handle *rth ) 
{ 


  {
  {
#line 85
  close(rth->fd);
  }
#line 86
  return;
}
}
#line 88 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwevent.c"
__inline static int ( __attribute__((__always_inline__)) rtnl_open)(struct rtnl_handle *rth ,
                                                                    unsigned int subscriptions ) 
{ 
  int addr_len ;
  int tmp ;
  int tmp___0 ;
  time_t tmp___1 ;

  {
  {
#line 92
  memset((void *)rth, 0, sizeof(rth));
#line 94
  rth->fd = socket(16, 3, 0);
  }
#line 95
  if (rth->fd < 0) {
    {
#line 96
    perror("Cannot open netlink socket");
    }
#line 97
    return (-1);
  }
  {
#line 100
  memset((void *)(& rth->local), 0, sizeof(rth->local));
#line 101
  rth->local.nl_family = (__kernel_sa_family_t )16;
#line 102
  rth->local.nl_groups = subscriptions;
#line 104
  tmp = bind(rth->fd, (struct sockaddr  const  *)((struct sockaddr *)(& rth->local)),
             (socklen_t )sizeof(rth->local));
  }
#line 104
  if (tmp < 0) {
    {
#line 105
    perror("Cannot bind netlink socket");
    }
#line 106
    return (-1);
  }
  {
#line 108
  addr_len = (int )sizeof(rth->local);
#line 109
  tmp___0 = getsockname(rth->fd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& rth->local)),
                        (socklen_t */* __restrict  */)((socklen_t *)(& addr_len)));
  }
#line 109
  if (tmp___0 < 0) {
    {
#line 111
    perror("Cannot getsockname");
    }
#line 112
    return (-1);
  }
#line 114
  if ((unsigned long )addr_len != sizeof(rth->local)) {
    {
#line 115
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrong address length %d\n",
            addr_len);
    }
#line 116
    return (-1);
  }
#line 118
  if ((int )rth->local.nl_family != 16) {
    {
#line 119
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrong address family %d\n",
            (int )rth->local.nl_family);
    }
#line 120
    return (-1);
  }
  {
#line 122
  tmp___1 = time((time_t *)((void *)0));
#line 122
  rth->seq = (__u32 )tmp___1;
  }
#line 123
  return (0);
}
}
#line 144 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwevent.c"
__inline static int ( __attribute__((__always_inline__)) index2name)(int skfd , int ifindex ,
                                                                     char *name ) 
{ 
  struct ifreq irq ;
  int ret ;
  int tmp ;

  {
  {
#line 150
  ret = 0;
#line 152
  memset((void *)name, 0, (size_t )17);
#line 155
  irq.ifr_ifru.ifru_ivalue = ifindex;
#line 156
  tmp = ioctl(skfd, 35088UL, & irq);
  }
#line 156
  if (tmp < 0) {
#line 157
    ret = -1;
  } else {
    {
#line 159
    strncpy((char */* __restrict  */)name, (char const   */* __restrict  */)(irq.ifr_ifrn.ifrn_name),
            (size_t )16);
    }
  }
#line 161
  return (ret);
}
}
#line 168 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwevent.c"
static struct wireless_iface *iw_get_interface_data(int ifindex ) 
{ 
  struct wireless_iface *curr ;
  int skfd ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 172
  skfd = -1;
#line 175
  curr = interface_cache;
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    if (! ((unsigned long )curr != (unsigned long )((void *)0))) {
#line 176
      goto while_break;
    }
#line 179
    if (curr->ifindex == ifindex) {
#line 184
      return (curr);
    }
#line 187
    curr = curr->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 192
  skfd = iw_sockets_open();
  }
#line 192
  if (skfd < 0) {
    {
#line 194
    perror("iw_sockets_open");
    }
#line 195
    return ((struct wireless_iface *)((void *)0));
  }
  {
#line 199
  tmp = calloc((size_t )1, sizeof(struct wireless_iface ));
#line 199
  curr = (struct wireless_iface *)tmp;
  }
#line 200
  if (! curr) {
    {
#line 202
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Malloc failed\n");
    }
#line 203
    return ((struct wireless_iface *)((void *)0));
  }
  {
#line 205
  curr->ifindex = ifindex;
#line 208
  tmp___0 = index2name(skfd, ifindex, curr->ifname);
  }
#line 208
  if (tmp___0 < 0) {
    {
#line 210
    perror("index2name");
#line 211
    free((void *)curr);
    }
#line 212
    return ((struct wireless_iface *)((void *)0));
  }
  {
#line 214
  tmp___1 = iw_get_range_info(skfd, (char const   *)(curr->ifname), & curr->range);
#line 214
  curr->has_range = tmp___1 >= 0;
#line 218
  iw_sockets_close(skfd);
#line 221
  curr->next = interface_cache;
#line 222
  interface_cache = curr;
  }
#line 224
  return (curr);
}
}
#line 231 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwevent.c"
static void iw_del_interface_data(int ifindex ) 
{ 
  struct wireless_iface *curr ;
  struct wireless_iface *prev ;
  struct wireless_iface *next ;

  {
#line 235
  prev = (struct wireless_iface *)((void *)0);
#line 239
  curr = interface_cache;
  {
#line 240
  while (1) {
    while_continue: /* CIL Label */ ;
#line 240
    if (! curr) {
#line 240
      goto while_break;
    }
#line 242
    next = curr->next;
#line 245
    if (curr->ifindex == ifindex) {
#line 248
      if (! prev) {
#line 249
        interface_cache = next;
      } else {
#line 251
        prev->next = next;
      }
      {
#line 255
      free((void *)curr);
      }
    } else {
#line 260
      prev = curr;
    }
#line 264
    curr = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 266
  return;
}
}
#line 279 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwevent.c"
static char *iw_hexdump(char *buf , size_t buflen , unsigned char const   *data ,
                        size_t datalen ) 
{ 
  size_t i ;
  char *pos ;
  int tmp ;

  {
#line 286
  pos = buf;
#line 288
  i = (size_t )0;
  {
#line 288
  while (1) {
    while_continue: /* CIL Label */ ;
#line 288
    if (! (i < datalen)) {
#line 288
      goto while_break;
    }
    {
#line 289
    tmp = snprintf((char */* __restrict  */)pos, (size_t )((buf + buflen) - pos),
                   (char const   */* __restrict  */)"%02X", (int const   )*(data + i));
#line 289
    pos += tmp;
#line 288
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 290
  return (buf);
}
}
#line 297 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwevent.c"
__inline static int ( __attribute__((__always_inline__)) print_event_token)(struct iw_event *event ,
                                                                            struct iw_range *iw_range ,
                                                                            int has_range ) 
{ 
  char buffer[128] ;
  char buffer2[30] ;
  char *prefix ;
  char const   *tmp ;
  double freq ;
  int channel ;
  char essid[129] ;
  unsigned char key[64] ;
  char *tmp___0 ;
  char *tmp___1 ;
  char custom[257] ;
  char *tmp___2 ;
  char *tmp___3 ;
  struct iw_thrspy threshold ;
  char *tmp___4 ;
  struct iw_michaelmicfailure mf ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  struct iw_pmkid_cand cand ;
  char *tmp___9 ;

  {
#line 304
  if ((int )event->cmd & 1) {
#line 304
    tmp = "New";
  } else {
#line 304
    tmp = "Set";
  }
#line 304
  prefix = (char *)tmp;
  {
#line 311
  if ((int )event->cmd == 35586) {
#line 311
    goto case_35586;
  }
#line 318
  if ((int )event->cmd == 35589) {
#line 318
    goto case_35589;
  }
#line 318
  if ((int )event->cmd == 35588) {
#line 318
    goto case_35589;
  }
#line 337
  if ((int )event->cmd == 35590) {
#line 337
    goto case_35590;
  }
#line 342
  if ((int )event->cmd == 35611) {
#line 342
    goto case_35611;
  }
#line 342
  if ((int )event->cmd == 35610) {
#line 342
    goto case_35611;
  }
#line 362
  if ((int )event->cmd == 35626) {
#line 362
    goto case_35626;
  }
#line 392
  if ((int )event->cmd == 35605) {
#line 392
    goto case_35605;
  }
#line 396
  if ((int )event->cmd == 35609) {
#line 396
    goto case_35609;
  }
#line 399
  if ((int )event->cmd == 35840) {
#line 399
    goto case_35840;
  }
#line 403
  if ((int )event->cmd == 35842) {
#line 403
    goto case_35842;
  }
#line 412
  if ((int )event->cmd == 35843) {
#line 412
    goto case_35843;
  }
#line 416
  if ((int )event->cmd == 35844) {
#line 416
    goto case_35844;
  }
#line 420
  if ((int )event->cmd == 35603) {
#line 420
    goto case_35603;
  }
#line 439
  if ((int )event->cmd == 35846) {
#line 439
    goto case_35846;
  }
#line 451
  if ((int )event->cmd == 35847) {
#line 451
    goto case_35847;
  }
#line 456
  if ((int )event->cmd == 35848) {
#line 456
    goto case_35848;
  }
#line 461
  if ((int )event->cmd == 35849) {
#line 461
    goto case_35849;
  }
#line 473
  if ((int )event->cmd == 35617) {
#line 473
    goto case_35617;
  }
#line 477
  if ((int )event->cmd == 35585) {
#line 477
    goto case_35585;
  }
#line 480
  if ((int )event->cmd == 35841) {
#line 480
    goto case_35841;
  }
#line 488
  goto switch_default;
  case_35586: /* CIL Label */ 
#line 312
  if (event->u.nwid.disabled) {
    {
#line 313
    printf((char const   */* __restrict  */)"Set NWID:off/any\n");
    }
  } else {
    {
#line 315
    printf((char const   */* __restrict  */)"Set NWID:%X\n", event->u.nwid.value);
    }
  }
#line 316
  goto switch_break;
  case_35589: /* CIL Label */ 
  case_35588: /* CIL Label */ 
  {
#line 321
  channel = -1;
#line 322
  freq = iw_freq2float((iwfreq const   *)(& event->u.freq));
  }
#line 323
  if (has_range) {
#line 325
    if (freq < 1e3) {
      {
#line 327
      channel = iw_channel_to_freq((int )freq, & freq, (struct iw_range  const  *)iw_range);
      }
    } else {
      {
#line 330
      channel = iw_freq_to_channel(freq, (struct iw_range  const  *)iw_range);
      }
    }
  }
  {
#line 332
  iw_print_freq(buffer, (int )sizeof(buffer), freq, channel, (int )event->u.freq.flags);
#line 334
  printf((char const   */* __restrict  */)"%s %s\n", prefix, buffer);
  }
#line 336
  goto switch_break;
  case_35590: /* CIL Label */ 
  {
#line 338
  printf((char const   */* __restrict  */)"Set Mode:%s\n", iw_operation_mode[event->u.mode]);
  }
#line 340
  goto switch_break;
  case_35611: /* CIL Label */ 
  case_35610: /* CIL Label */ 
  {
#line 345
  memset((void *)(essid), '\000', sizeof(essid));
  }
#line 346
  if (event->u.essid.pointer) {
#line 346
    if (event->u.essid.length) {
      {
#line 347
      iw_essid_escape(essid, (char const   *)event->u.essid.pointer, (int const   )event->u.essid.length);
      }
    }
  }
#line 349
  if (event->u.essid.flags) {
#line 352
    if (((int )event->u.essid.flags & 255) > 1) {
      {
#line 353
      printf((char const   */* __restrict  */)"%s ESSID:\"%s\" [%d]\n", prefix, essid,
             (int )event->u.essid.flags & 255);
      }
    } else {
      {
#line 356
      printf((char const   */* __restrict  */)"%s ESSID:\"%s\"\n", prefix, essid);
      }
    }
  } else {
    {
#line 359
    printf((char const   */* __restrict  */)"%s ESSID:off/any\n", prefix);
    }
  }
#line 361
  goto switch_break;
  case_35626: /* CIL Label */ 
#line 365
  if (event->u.data.pointer) {
    {
#line 366
    memcpy((void */* __restrict  */)(key), (void const   */* __restrict  */)event->u.data.pointer,
           (size_t )event->u.data.length);
    }
  } else {
#line 368
    event->u.data.flags = (__u16 )((int )event->u.data.flags | 2048);
  }
  {
#line 369
  printf((char const   */* __restrict  */)"Set Encryption key:{%X}", (int )event->u.data.flags);
  }
#line 370
  if ((int )event->u.data.flags & 32768) {
    {
#line 371
    printf((char const   */* __restrict  */)"off\n");
    }
  } else {
    {
#line 375
    iw_print_key(buffer, (int )sizeof(buffer), (unsigned char const   *)(key), (int )event->u.data.length,
                 (int )event->u.data.flags);
#line 377
    printf((char const   */* __restrict  */)"%s", buffer);
    }
#line 380
    if (((int )event->u.data.flags & 255) > 1) {
      {
#line 381
      printf((char const   */* __restrict  */)" [%d]", (int )event->u.data.flags & 255);
      }
    }
#line 382
    if ((int )event->u.data.flags & 16384) {
      {
#line 383
      printf((char const   */* __restrict  */)"   Security mode:restricted");
      }
    }
#line 384
    if ((int )event->u.data.flags & 8192) {
      {
#line 385
      printf((char const   */* __restrict  */)"   Security mode:open");
      }
    }
    {
#line 386
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 389
  goto switch_break;
  case_35605: /* CIL Label */ 
  {
#line 393
  tmp___0 = iw_sawap_ntop((struct sockaddr  const  *)(& event->u.ap_addr), buffer);
#line 393
  printf((char const   */* __restrict  */)"New Access Point/Cell address:%s\n", tmp___0);
  }
#line 395
  goto switch_break;
  case_35609: /* CIL Label */ 
  {
#line 397
  printf((char const   */* __restrict  */)"Scan request completed\n");
  }
#line 398
  goto switch_break;
  case_35840: /* CIL Label */ 
  {
#line 400
  tmp___1 = iw_saether_ntop((struct sockaddr  const  *)(& event->u.addr), buffer);
#line 400
  printf((char const   */* __restrict  */)"Tx packet dropped:%s\n", tmp___1);
  }
#line 402
  goto switch_break;
  case_35842: /* CIL Label */ 
  {
#line 406
  memset((void *)(custom), '\000', sizeof(custom));
  }
#line 407
  if (event->u.data.pointer) {
#line 407
    if (event->u.data.length) {
      {
#line 408
      memcpy((void */* __restrict  */)(custom), (void const   */* __restrict  */)event->u.data.pointer,
             (size_t )event->u.data.length);
      }
    }
  }
  {
#line 409
  printf((char const   */* __restrict  */)"Custom driver event:%s\n", custom);
  }
#line 411
  goto switch_break;
  case_35843: /* CIL Label */ 
  {
#line 413
  tmp___2 = iw_saether_ntop((struct sockaddr  const  *)(& event->u.addr), buffer);
#line 413
  printf((char const   */* __restrict  */)"Registered node:%s\n", tmp___2);
  }
#line 415
  goto switch_break;
  case_35844: /* CIL Label */ 
  {
#line 417
  tmp___3 = iw_saether_ntop((struct sockaddr  const  *)(& event->u.addr), buffer);
#line 417
  printf((char const   */* __restrict  */)"Expired node:%s\n", tmp___3);
  }
#line 419
  goto switch_break;
  case_35603: /* CIL Label */ 
#line 423
  if (event->u.data.pointer) {
#line 423
    if (event->u.data.length) {
      {
#line 425
      memcpy((void */* __restrict  */)(& threshold), (void const   */* __restrict  */)event->u.data.pointer,
             sizeof(struct iw_thrspy ));
#line 427
      tmp___4 = iw_saether_ntop((struct sockaddr  const  *)(& threshold.addr), buffer);
#line 427
      printf((char const   */* __restrict  */)"Spy threshold crossed on address:%s\n",
             tmp___4);
#line 429
      iw_print_stats(buffer, (int )sizeof(buffer), (iwqual const   *)(& threshold.qual),
                     (iwrange const   *)iw_range, has_range);
#line 431
      printf((char const   */* __restrict  */)"                            Link %s\n",
             buffer);
      }
    } else {
      {
#line 434
      printf((char const   */* __restrict  */)"Invalid Spy Threshold event\n");
      }
    }
  } else {
    {
#line 434
    printf((char const   */* __restrict  */)"Invalid Spy Threshold event\n");
    }
  }
#line 436
  goto switch_break;
  case_35846: /* CIL Label */ 
#line 440
  if ((unsigned long )event->u.data.length >= sizeof(struct iw_michaelmicfailure )) {
    {
#line 443
    memcpy((void */* __restrict  */)(& mf), (void const   */* __restrict  */)event->u.data.pointer,
           sizeof(mf));
#line 444
    tmp___5 = iw_hexdump(buffer, sizeof(buffer), (unsigned char const   *)(mf.tsc),
                         (size_t )8);
#line 444
    tmp___6 = iw_saether_ntop((struct sockaddr  const  *)(& mf.src_addr), buffer2);
#line 444
    printf((char const   */* __restrict  */)"Michael MIC failure flags:0x%X src_addr:%s tsc:%s\n",
           mf.flags, tmp___6, tmp___5);
    }
  }
#line 450
  goto switch_break;
  case_35847: /* CIL Label */ 
  {
#line 452
  tmp___7 = iw_hexdump(buffer, sizeof(buffer), (unsigned char const   *)event->u.data.pointer,
                       (size_t )event->u.data.length);
#line 452
  printf((char const   */* __restrict  */)"Association Request IEs:%s\n", tmp___7);
  }
#line 455
  goto switch_break;
  case_35848: /* CIL Label */ 
  {
#line 457
  tmp___8 = iw_hexdump(buffer, sizeof(buffer), (unsigned char const   *)event->u.data.pointer,
                       (size_t )event->u.data.length);
#line 457
  printf((char const   */* __restrict  */)"Association Response IEs:%s\n", tmp___8);
  }
#line 460
  goto switch_break;
  case_35849: /* CIL Label */ 
#line 462
  if ((unsigned long )event->u.data.length >= sizeof(struct iw_pmkid_cand )) {
    {
#line 465
    memcpy((void */* __restrict  */)(& cand), (void const   */* __restrict  */)event->u.data.pointer,
           sizeof(cand));
#line 466
    tmp___9 = iw_saether_ntop((struct sockaddr  const  *)(& cand.bssid), buffer);
#line 466
    printf((char const   */* __restrict  */)"PMKID candidate flags:0x%X index:%d bssid:%s\n",
           cand.flags, cand.index, tmp___9);
    }
  }
#line 470
  goto switch_break;
  case_35617: /* CIL Label */ 
  {
#line 474
  iw_print_bitrate(buffer, (int )sizeof(buffer), event->u.bitrate.value);
#line 475
  printf((char const   */* __restrict  */)"New Bit Rate:%s\n", buffer);
  }
#line 476
  goto switch_break;
  case_35585: /* CIL Label */ 
  {
#line 478
  printf((char const   */* __restrict  */)"Protocol:%-1.16s\n", event->u.name);
  }
#line 479
  goto switch_break;
  case_35841: /* CIL Label */ 
  {
#line 482
  event->u.qual.updated = (__u8 )0;
#line 483
  iw_print_stats(buffer, (int )sizeof(buffer), (iwqual const   *)(& event->u.qual),
                 (iwrange const   *)iw_range, has_range);
#line 485
  printf((char const   */* __restrict  */)"Link %s\n", buffer);
  }
#line 486
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 489
  printf((char const   */* __restrict  */)"(Unknown Wireless event 0x%04X)\n", (int )event->cmd);
  }
  switch_break: /* CIL Label */ ;
  }
#line 492
  return (0);
}
}
#line 501 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwevent.c"
__inline static int ( __attribute__((__always_inline__)) print_event_stream)(int ifindex ,
                                                                             char *data ,
                                                                             int len ) 
{ 
  struct iw_event iwe ;
  struct stream_descr stream ;
  int i ;
  int ret ;
  char buffer[64] ;
  struct timeval recv_time ;
  struct timezone tz ;
  struct wireless_iface *wireless_data ;
  int tmp ;

  {
  {
#line 508
  i = 0;
#line 516
  wireless_data = iw_get_interface_data(ifindex);
  }
#line 517
  if ((unsigned long )wireless_data == (unsigned long )((void *)0)) {
#line 518
    return (-1);
  }
  {
#line 521
  gettimeofday((struct timeval */* __restrict  */)(& recv_time), (__timezone_ptr_t )(& tz));
#line 522
  iw_print_timeval(buffer, (int )sizeof(buffer), (struct timeval  const  *)(& recv_time),
                   (struct timezone  const  *)(& tz));
#line 524
  iw_init_event_stream(& stream, data, len);
  }
  {
#line 525
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 528
    ret = iw_extract_event_stream(& stream, & iwe, (int )wireless_data->range.we_version_compiled);
    }
#line 530
    if (ret != 0) {
#line 532
      tmp = i;
#line 532
      i ++;
#line 532
      if (tmp == 0) {
        {
#line 533
        printf((char const   */* __restrict  */)"%s   %-8.16s ", buffer, wireless_data->ifname);
        }
      } else {
        {
#line 535
        printf((char const   */* __restrict  */)"                           ");
        }
      }
#line 536
      if (ret > 0) {
        {
#line 537
        print_event_token(& iwe, & wireless_data->range, wireless_data->has_range);
        }
      } else {
        {
#line 540
        printf((char const   */* __restrict  */)"(Invalid event)\n");
        }
      }
      {
#line 542
      fflush(stdout);
      }
    }
#line 525
    if (! (ret > 0)) {
#line 525
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 547
  return (0);
}
}
#line 560 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwevent.c"
static int LinkCatcher(struct nlmsghdr *nlh ) 
{ 
  struct ifinfomsg *ifi ;
  int attrlen ;
  struct rtattr *attr ;

  {
#line 569
  ifi = (struct ifinfomsg *)((void *)((char *)nlh + (int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
#line 574
  if ((int )nlh->nlmsg_type == 17) {
    {
#line 577
    iw_del_interface_data(ifi->ifi_index);
    }
#line 578
    return (0);
  }
#line 582
  if ((int )nlh->nlmsg_type != 16) {
#line 583
    return (0);
  }
#line 586
  if ((unsigned long )nlh->nlmsg_len > (((sizeof(struct ifinfomsg ) + 4UL) - 1UL) & 4294967292UL)) {
#line 588
    attrlen = (int )((unsigned long )nlh->nlmsg_len - (((sizeof(struct ifinfomsg ) + 4UL) - 1UL) & 4294967292UL));
#line 589
    attr = (struct rtattr *)((void *)((char *)ifi + (((sizeof(struct ifinfomsg ) + 4UL) - 1UL) & 4294967292UL)));
    {
#line 592
    while (1) {
      while_continue: /* CIL Label */ ;
#line 592
      if (attrlen >= (int )sizeof(struct rtattr )) {
#line 592
        if ((unsigned long )attr->rta_len >= sizeof(struct rtattr )) {
#line 592
          if (! ((int )attr->rta_len <= attrlen)) {
#line 592
            goto while_break;
          }
        } else {
#line 592
          goto while_break;
        }
      } else {
#line 592
        goto while_break;
      }
#line 595
      if ((int )attr->rta_type == 11) {
        {
#line 598
        print_event_stream(ifi->ifi_index, (char *)attr + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL),
                           (int )((unsigned long )attr->rta_len - (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL)));
        }
      }
#line 602
      attrlen -= (((int )attr->rta_len + 4) - 1) & -4;
#line 602
      attr = (struct rtattr *)((char *)attr + ((((int )attr->rta_len + 4) - 1) & -4));
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 606
  return (0);
}
}
#line 615 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwevent.c"
__inline static void ( __attribute__((__always_inline__)) handle_netlink_events)(struct rtnl_handle *rth ) 
{ 
  struct sockaddr_nl sanl ;
  socklen_t sanllen ;
  struct nlmsghdr *h ;
  int amt ;
  char buf[8192] ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int len ;
  int l ;

  {
  {
#line 618
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 621
    sanllen = (socklen_t )sizeof(struct sockaddr_nl );
#line 627
    tmp = recvfrom(rth->fd, (void */* __restrict  */)(buf), sizeof(buf), 64, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& sanl)),
                   (socklen_t */* __restrict  */)(& sanllen));
#line 627
    amt = (int )tmp;
    }
#line 628
    if (amt < 0) {
      {
#line 630
      tmp___2 = __errno_location();
      }
#line 630
      if (*tmp___2 != 4) {
        {
#line 630
        tmp___3 = __errno_location();
        }
#line 630
        if (*tmp___3 != 11) {
          {
#line 632
          tmp___0 = __errno_location();
#line 632
          tmp___1 = strerror(*tmp___0);
#line 632
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error reading netlink: %s.\n",
                  "handle_netlink_events", tmp___1);
          }
        }
      }
#line 635
      return;
    }
#line 638
    if (amt == 0) {
      {
#line 640
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: EOF on netlink??\n",
              "handle_netlink_events");
      }
#line 641
      return;
    }
#line 644
    h = (struct nlmsghdr *)(buf);
    {
#line 645
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 645
      if (! (amt >= (int )sizeof(*h))) {
#line 645
        goto while_break___0;
      }
#line 647
      len = (int )h->nlmsg_len;
#line 648
      l = (int )((unsigned long )len - sizeof(*h));
#line 650
      if (l < 0) {
        {
#line 652
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: malformed netlink message: len=%d\n",
                "handle_netlink_events", len);
        }
#line 653
        goto while_break___0;
      } else
#line 650
      if (len > amt) {
        {
#line 652
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: malformed netlink message: len=%d\n",
                "handle_netlink_events", len);
        }
#line 653
        goto while_break___0;
      }
      {
#line 659
      if ((int )h->nlmsg_type == 17) {
#line 659
        goto case_17;
      }
#line 659
      if ((int )h->nlmsg_type == 16) {
#line 659
        goto case_17;
      }
#line 662
      goto switch_default;
      case_17: /* CIL Label */ 
      case_16: /* CIL Label */ 
      {
#line 660
      LinkCatcher(h);
      }
#line 661
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 666
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 669
      len = (int )((((unsigned int )len + 4U) - 1U) & 4294967292U);
#line 670
      amt -= len;
#line 671
      h = (struct nlmsghdr *)((char *)h + len);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 674
    if (amt > 0) {
      {
#line 675
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: remnant of size %d on netlink\n",
              "handle_netlink_events", amt);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 685 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwevent.c"
__inline static int ( __attribute__((__always_inline__)) wait_for_event)(struct rtnl_handle *rth ) 
{ 
  fd_set rfds ;
  int last_fd ;
  int ret ;
  int __d0 ;
  int __d1 ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 693
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 700
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 700
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& rfds.__fds_bits[0]): "memory");
#line 700
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 701
    rfds.__fds_bits[rth->fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << rth->fd % (8 * (int )sizeof(__fd_mask ));
#line 702
    last_fd = rth->fd;
#line 705
    ret = select(last_fd + 1, (fd_set */* __restrict  */)(& rfds), (fd_set */* __restrict  */)((void *)0),
                 (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
    }
#line 708
    if (ret < 0) {
      {
#line 710
      tmp = __errno_location();
      }
#line 710
      if (*tmp == 11) {
#line 711
        goto while_continue;
      } else {
        {
#line 710
        tmp___0 = __errno_location();
        }
#line 710
        if (*tmp___0 == 4) {
#line 711
          goto while_continue;
        }
      }
      {
#line 712
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unhandled signal - exiting...\n");
      }
#line 713
      goto while_break;
    }
#line 717
    if (ret == 0) {
#line 719
      goto while_continue;
    }
#line 723
    if ((rfds.__fds_bits[rth->fd / (8 * (int )sizeof(__fd_mask ))] & (1L << rth->fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 724
      handle_netlink_events(rth);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 727
  return (0);
}
}
#line 736 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwevent.c"
static void iw_usage___1(int status ) 
{ 
  struct _IO_FILE *tmp ;

  {
#line 739
  if (status) {
#line 739
    tmp = stderr;
  } else {
#line 739
    tmp = stdout;
  }
  {
#line 739
  fputs((char const   */* __restrict  */)"Usage: iwevent [OPTIONS]\n   Monitors and displays Wireless Events.\n   Options are:\n     -h,--help     Print this message.\n     -v,--version  Show version of this program.\n",
        (FILE */* __restrict  */)tmp);
#line 745
  exit(status);
  }
}
}
#line 748 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwevent.c"
static struct option  const  long_opts___0[3]  = {      {"help", 0, (int *)((void *)0), 'h'}, 
        {"version", 0, (int *)((void *)0), 'v'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 164 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static int const   families___3[4]  = {      (int const   )2,      (int const   )4,      (int const   )3,      (int const   )5};
#line 381 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static int print_iface_version_info___3(int skfd , char *ifname , char **args , int count ) 
{ 
  struct iwreq wrq ;
  char buffer[sizeof(iwrange ) * 2UL] ;
  struct iw_range *range ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 392
  args = args;
#line 392
  count = count;
#line 396
  tmp = iw_set_ext(skfd, (char const   *)ifname, 35585, & wrq);
  }
#line 396
  if (tmp < 0) {
#line 397
    return (-1);
  }
  {
#line 400
  memset((void *)(buffer), 0, sizeof(buffer));
#line 402
  wrq.u.data.pointer = (void *)(buffer);
#line 403
  wrq.u.data.length = (__u16 )sizeof(buffer);
#line 404
  wrq.u.data.flags = (__u16 )0;
#line 405
  tmp___0 = iw_set_ext(skfd, (char const   *)ifname, 35595, & wrq);
  }
#line 405
  if (tmp___0 < 0) {
    {
#line 408
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  Driver has no Wireless Extension version information.\n\n",
            ifname);
    }
#line 409
    return (0);
  }
#line 413
  range = (struct iw_range *)(buffer);
#line 417
  if ((int )wrq.u.data.length >= 300) {
    {
#line 420
    printf((char const   */* __restrict  */)"%-8.16s  Recommend Wireless Extension v%d or later,\n",
           ifname, (int )range->we_version_source);
#line 422
    printf((char const   */* __restrict  */)"          Currently compiled with Wireless Extension v%d.\n\n",
           (int )range->we_version_compiled);
    }
  } else {
    {
#line 427
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  Wireless Extension version too old.\n\n",
            ifname);
    }
  }
#line 432
  return (0);
}
}
#line 1687 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static int iw_pass_key___3(char const   *input , unsigned char *key ) 
{ 


  {
  {
#line 1691
  input = input;
#line 1691
  key = key;
#line 1692
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Passphrase not implemented\n");
  }
#line 1693
  return (-1);
}
}
#line 2402 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static int const   priv_type_size___3[8]  = 
#line 2402
  {      (int const   )0,      (int const   )1,      (int const   )1,      (int const   )0, 
        (int const   )sizeof(__u32 ),      (int const   )sizeof(struct iw_freq ),      (int const   )sizeof(struct sockaddr ),      (int const   )0};
#line 2480 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static struct iw_ioctl_description  const  standard_ioctl_descr___3[55]  = 
#line 2480
  {      {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )2, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )2}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )5, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )2}, 
        {(__u8 )5, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )4, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )2}, 
        {(__u8 )4, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )sizeof(struct iw_range ),
      (__u32 )1}, 
        {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )8, (unsigned char)0, (__u16 )sizeof(struct sockaddr ), (unsigned short)0,
      (__u16 )8, 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )(sizeof(struct sockaddr ) + sizeof(struct iw_quality )),
      (unsigned short)0, (__u16 )8, 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )sizeof(struct iw_thrspy ), (__u16 )1, (__u16 )1,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )sizeof(struct iw_thrspy ), (__u16 )1, (__u16 )1,
      0U}, 
        {(__u8 )6, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )6, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (__u16 )sizeof(struct iw_mlme ), (__u16 )sizeof(struct iw_mlme ),
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )(sizeof(struct sockaddr ) + sizeof(struct iw_quality )),
      (unsigned short)0, (__u16 )64, (__u32 )8}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (__u16 )0, (__u16 )sizeof(struct iw_scan_req ),
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )4096, (__u32 )8}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )33, (__u32 )2}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )33, (__u32 )1}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )33, 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )33, 0U}, 
        {(unsigned char)0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(unsigned char)0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )0, (unsigned short)0, (__u16 )64, (__u32 )6}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )0, (unsigned short)0, (__u16 )64, (__u32 )5}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )1024, 0U}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )1024, 0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (__u16 )sizeof(struct iw_encode_ext ),
      (__u16 )(sizeof(struct iw_encode_ext ) + 64UL), 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (__u16 )sizeof(struct iw_encode_ext ),
      (__u16 )(sizeof(struct iw_encode_ext ) + 64UL), 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (__u16 )sizeof(struct iw_pmksa ), (__u16 )sizeof(struct iw_pmksa ),
      0U}};
#line 2712 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static unsigned int const   standard_ioctl_num___3  =    (unsigned int const   )(sizeof(standard_ioctl_descr___3) / sizeof(struct iw_ioctl_description ));
#line 2719 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static struct iw_ioctl_description  const  standard_event_descr___3[10]  = 
#line 2719
  {      {(__u8 )6, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )10, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )256, 0U}, 
        {(__u8 )6, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )6, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )1024, 0U}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )sizeof(struct iw_michaelmicfailure ),
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )1024, 0U}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )1024, 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )sizeof(struct iw_pmkid_cand ),
      0U}};
#line 2763 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static unsigned int const   standard_event_num___3  =    (unsigned int const   )(sizeof(standard_event_descr___3) / sizeof(struct iw_ioctl_description ));
#line 2767 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static int const   event_type_size___3[11]  = 
#line 2767
  {      (int const   )4,      (int const   )0,      (int const   )20,      (int const   )0, 
        (int const   )(4UL + sizeof(__u32 )),      (int const   )(4UL + sizeof(struct iw_freq )),      (int const   )(4UL + sizeof(struct sockaddr )),      (int const   )0, 
        (int const   )8,      (int const   )(4UL + sizeof(struct iw_param )),      (int const   )(4UL + sizeof(struct iw_quality ))};
#line 70 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlist.c"
static struct iwmask_name  const  iw_auth_capa_name[4]  = {      {1U, "WPA"}, 
        {2U, "WPA2"}, 
        {4U, "CIPHER-TKIP"}, 
        {8U, "CIPHER-CCMP"}};
#line 78 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlist.c"
static struct iwmask_name  const  iw_auth_cypher_name[5]  = {      {1U, "none"}, 
        {2U, "WEP-40"}, 
        {4U, "TKIP"}, 
        {8U, "CCMP"}, 
        {16U, "WEP-104"}};
#line 87 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlist.c"
static struct iwmask_name  const  iw_wpa_ver_name[3]  = {      {1U, "disabled"}, 
        {2U, "WPA"}, 
        {4U, "WPA2"}};
#line 94 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlist.c"
static struct iwmask_name  const  iw_auth_key_mgmt_name[2]  = {      {1U, "802.1x"}, 
        {2U, "PSK"}};
#line 100 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlist.c"
static struct iwmask_name  const  iw_auth_alg_name[3]  = {      {1U, "open"}, 
        {2U, "shared-key"}, 
        {4U, "LEAP"}};
#line 107 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlist.c"
static struct iw_auth_descr  const  iw_auth_settings[10]  = 
#line 107
  {      {0, "WPA version", iw_wpa_ver_name, (int const   )(sizeof(iw_wpa_ver_name) / sizeof(iw_wpa_ver_name[0]))}, 
        {3,
      "Key management", iw_auth_key_mgmt_name, (int const   )(sizeof(iw_auth_key_mgmt_name) / sizeof(iw_auth_key_mgmt_name[0]))}, 
        {1,
      "Pairwise cipher", iw_auth_cypher_name, (int const   )(sizeof(iw_auth_cypher_name) / sizeof(iw_auth_cypher_name[0]))}, 
        {2,
      "Pairwise cipher", iw_auth_cypher_name, (int const   )(sizeof(iw_auth_cypher_name) / sizeof(iw_auth_cypher_name[0]))}, 
        {4,
      "TKIP countermeasures", (struct iwmask_name  const  *)((void *)0), (int const   )0}, 
        {5,
      "Drop unencrypted", (struct iwmask_name  const  *)((void *)0), (int const   )0}, 
        {6,
      "Authentication algorithm", iw_auth_alg_name, (int const   )(sizeof(iw_auth_alg_name) / sizeof(iw_auth_alg_name[0]))}, 
        {8,
      "Receive unencrypted EAPOL", (struct iwmask_name  const  *)((void *)0), (int const   )0}, 
        {9,
      "Roaming control", (struct iwmask_name  const  *)((void *)0), (int const   )0}, 
        {10,
      "Privacy invoked", (struct iwmask_name  const  *)((void *)0), (int const   )0}};
#line 122 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlist.c"
static char const   *iw_encode_alg_name[5]  = {      "none",      "WEP",      "TKIP",      "CCMP", 
        "unknown"};
#line 146 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlist.c"
static char const   *iw_ie_cypher_name[6]  = {      "none",      "WEP-40",      "TKIP",      "WRAP", 
        "CCMP",      "WEP-104"};
#line 157 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlist.c"
static char const   *iw_ie_key_mgmt_name[3]  = {      "none",      "802.1x",      "PSK"};
#line 174 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlist.c"
static void iw_print_mask_name(unsigned int mask , struct iwmask_name  const  *names ,
                               unsigned int const   num_names , char const   *sep ) 
{ 
  unsigned int i ;

  {
#line 183
  i = 0U;
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 183
    if (! (i < (unsigned int )num_names)) {
#line 183
      goto while_break;
    }
#line 185
    if (mask & (unsigned int )(names + i)->mask) {
      {
#line 188
      printf((char const   */* __restrict  */)"%s%s", sep, (names + i)->name);
#line 190
      mask &= (unsigned int )(~ (names + i)->mask);
      }
    }
#line 183
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 194
  if (mask != 0U) {
    {
#line 195
    printf((char const   */* __restrict  */)"%sUnknown", sep);
    }
  }
#line 196
  return;
}
}
#line 202 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlist.c"
static void iw_print_value_name(unsigned int value , char const   **names , unsigned int const   num_names ) 
{ 


  {
#line 207
  if (value >= (unsigned int )num_names) {
    {
#line 208
    printf((char const   */* __restrict  */)" unknown (%d)", value);
    }
  } else {
    {
#line 210
    printf((char const   */* __restrict  */)" %s", *(names + value));
    }
  }
#line 211
  return;
}
}
#line 218 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlist.c"
static void iw_print_ie_unknown(unsigned char *iebuf , int buflen ) 
{ 
  int ielen ;
  int i ;

  {
#line 222
  ielen = (int )*(iebuf + 1) + 2;
#line 225
  if (ielen > buflen) {
#line 226
    ielen = buflen;
  }
  {
#line 228
  printf((char const   */* __restrict  */)"Unknown: ");
#line 229
  i = 0;
  }
  {
#line 229
  while (1) {
    while_continue: /* CIL Label */ ;
#line 229
    if (! (i < ielen)) {
#line 229
      goto while_break;
    }
    {
#line 230
    printf((char const   */* __restrict  */)"%02X", (int )*(iebuf + i));
#line 229
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 231
  printf((char const   */* __restrict  */)"\n");
  }
#line 232
  return;
}
}
#line 239 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlist.c"
__inline static void ( __attribute__((__always_inline__)) iw_print_ie_wpa)(unsigned char *iebuf ,
                                                                           int buflen ) 
{ 
  int ielen ;
  int offset ;
  unsigned char wpa1_oui[3] ;
  unsigned char wpa2_oui[3] ;
  unsigned char *wpa_oui ;
  int i ;
  uint16_t ver ;
  uint16_t cnt ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 243
  ielen = (int )*(iebuf + 1) + 2;
#line 244
  offset = 2;
#line 245
  wpa1_oui[0] = (unsigned char)0;
#line 245
  wpa1_oui[1] = (unsigned char)80;
#line 245
  wpa1_oui[2] = (unsigned char)242;
#line 246
  wpa2_oui[0] = (unsigned char)0;
#line 246
  wpa2_oui[1] = (unsigned char)15;
#line 246
  wpa2_oui[2] = (unsigned char)172;
#line 249
  ver = (uint16_t )0;
#line 250
  cnt = (uint16_t )0;
#line 252
  if (ielen > buflen) {
#line 253
    ielen = buflen;
  }
  {
#line 265
  if ((int )*(iebuf + 0) == 48) {
#line 265
    goto case_48;
  }
#line 276
  if ((int )*(iebuf + 0) == 221) {
#line 276
    goto case_221;
  }
#line 293
  goto switch_default;
  case_48: /* CIL Label */ 
#line 267
  if (ielen < 4) {
    {
#line 269
    iw_print_ie_unknown(iebuf, buflen);
    }
#line 270
    return;
  }
#line 273
  wpa_oui = wpa2_oui;
#line 274
  goto switch_break;
  case_221: /* CIL Label */ 
#line 277
  wpa_oui = wpa1_oui;
#line 281
  if (ielen < 8) {
    {
#line 285
    iw_print_ie_unknown(iebuf, buflen);
    }
#line 286
    return;
  } else {
    {
#line 281
    tmp = memcmp((void const   *)(iebuf + offset), (void const   *)wpa_oui, (size_t )3);
    }
#line 281
    if (tmp != 0) {
      {
#line 285
      iw_print_ie_unknown(iebuf, buflen);
      }
#line 286
      return;
    } else
#line 281
    if ((int )*(iebuf + (offset + 3)) != 1) {
      {
#line 285
      iw_print_ie_unknown(iebuf, buflen);
      }
#line 286
      return;
    }
  }
#line 290
  offset += 4;
#line 291
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 294
  return;
  switch_break: /* CIL Label */ ;
  }
#line 298
  ver = (uint16_t )((int )*(iebuf + offset) | ((int )*(iebuf + (offset + 1)) << 8));
#line 299
  offset += 2;
#line 301
  if ((int )*(iebuf + 0) == 221) {
    {
#line 302
    printf((char const   */* __restrict  */)"WPA Version %d\n", (int )ver);
    }
  }
#line 303
  if ((int )*(iebuf + 0) == 48) {
    {
#line 304
    printf((char const   */* __restrict  */)"IEEE 802.11i/WPA2 Version %d\n", (int )ver);
    }
  }
#line 309
  if (ielen < offset + 4) {
    {
#line 312
    printf((char const   */* __restrict  */)"                        Group Cipher : TKIP\n");
#line 313
    printf((char const   */* __restrict  */)"                        Pairwise Cipher : TKIP\n");
    }
#line 314
    return;
  }
  {
#line 318
  tmp___0 = memcmp((void const   *)(iebuf + offset), (void const   *)wpa_oui, (size_t )3);
  }
#line 318
  if (tmp___0 != 0) {
    {
#line 320
    printf((char const   */* __restrict  */)"                        Group Cipher : Proprietary\n");
    }
  } else {
    {
#line 324
    printf((char const   */* __restrict  */)"                        Group Cipher :");
#line 325
    iw_print_value_name((unsigned int )*(iebuf + (offset + 3)), iw_ie_cypher_name,
                        (unsigned int const   )(sizeof(iw_ie_cypher_name) / sizeof(iw_ie_cypher_name[0])));
#line 327
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 329
  offset += 4;
#line 332
  if (ielen < offset + 2) {
    {
#line 335
    printf((char const   */* __restrict  */)"                        Pairwise Ciphers : TKIP\n");
    }
#line 336
    return;
  }
  {
#line 340
  cnt = (uint16_t )((int )*(iebuf + offset) | ((int )*(iebuf + (offset + 1)) << 8));
#line 341
  offset += 2;
#line 342
  printf((char const   */* __restrict  */)"                        Pairwise Ciphers (%d) :",
         (int )cnt);
  }
#line 344
  if (ielen < offset + 4 * (int )cnt) {
#line 345
    return;
  }
#line 347
  i = 0;
  {
#line 347
  while (1) {
    while_continue: /* CIL Label */ ;
#line 347
    if (! (i < (int )cnt)) {
#line 347
      goto while_break;
    }
    {
#line 349
    tmp___1 = memcmp((void const   *)(iebuf + offset), (void const   *)wpa_oui, (size_t )3);
    }
#line 349
    if (tmp___1 != 0) {
      {
#line 351
      printf((char const   */* __restrict  */)" Proprietary");
      }
    } else {
      {
#line 355
      iw_print_value_name((unsigned int )*(iebuf + (offset + 3)), iw_ie_cypher_name,
                          (unsigned int const   )(sizeof(iw_ie_cypher_name) / sizeof(iw_ie_cypher_name[0])));
      }
    }
#line 358
    offset += 4;
#line 347
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 360
  printf((char const   */* __restrict  */)"\n");
  }
#line 363
  if (ielen < offset + 2) {
#line 364
    return;
  }
  {
#line 367
  cnt = (uint16_t )((int )*(iebuf + offset) | ((int )*(iebuf + (offset + 1)) << 8));
#line 368
  offset += 2;
#line 369
  printf((char const   */* __restrict  */)"                        Authentication Suites (%d) :",
         (int )cnt);
  }
#line 371
  if (ielen < offset + 4 * (int )cnt) {
#line 372
    return;
  }
#line 374
  i = 0;
  {
#line 374
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 374
    if (! (i < (int )cnt)) {
#line 374
      goto while_break___0;
    }
    {
#line 376
    tmp___2 = memcmp((void const   *)(iebuf + offset), (void const   *)wpa_oui, (size_t )3);
    }
#line 376
    if (tmp___2 != 0) {
      {
#line 378
      printf((char const   */* __restrict  */)" Proprietary");
      }
    } else {
      {
#line 382
      iw_print_value_name((unsigned int )*(iebuf + (offset + 3)), iw_ie_key_mgmt_name,
                          (unsigned int const   )(sizeof(iw_ie_key_mgmt_name) / sizeof(iw_ie_key_mgmt_name[0])));
      }
    }
#line 385
    offset += 4;
#line 374
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 387
  printf((char const   */* __restrict  */)"\n");
  }
#line 390
  if (ielen < offset + 1) {
#line 391
    return;
  }
#line 397
  if ((int )*(iebuf + offset) & 1) {
    {
#line 399
    printf((char const   */* __restrict  */)"                       Preauthentication Supported\n");
    }
  }
#line 401
  return;
}
}
#line 409 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlist.c"
__inline static void ( __attribute__((__always_inline__)) iw_print_gen_ie)(unsigned char *buffer ,
                                                                           int buflen ) 
{ 
  int offset ;

  {
#line 413
  offset = 0;
  {
#line 416
  while (1) {
    while_continue: /* CIL Label */ ;
#line 416
    if (! (offset <= buflen - 2)) {
#line 416
      goto while_break;
    }
    {
#line 418
    printf((char const   */* __restrict  */)"                    IE: ");
    }
    {
#line 424
    if ((int )*(buffer + offset) == 48) {
#line 424
      goto case_48;
    }
#line 424
    if ((int )*(buffer + offset) == 221) {
#line 424
      goto case_48;
    }
#line 427
    goto switch_default;
    case_48: /* CIL Label */ 
    case_221: /* CIL Label */ 
    {
#line 425
    iw_print_ie_wpa(buffer + offset, buflen);
    }
#line 426
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 428
    iw_print_ie_unknown(buffer + offset, buflen);
    }
    switch_break: /* CIL Label */ ;
    }
#line 431
    offset += (int )*(buffer + (offset + 1)) + 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 433
  return;
}
}
#line 451 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlist.c"
__inline static void ( __attribute__((__always_inline__)) print_scanning_token)(struct stream_descr *stream ,
                                                                                struct iw_event *event ,
                                                                                struct iwscan_state *state ,
                                                                                struct iw_range *iw_range ,
                                                                                int has_range ) 
{ 
  char buffer[128] ;
  char *tmp ;
  double freq ;
  int channel ;
  char essid[129] ;
  unsigned char key[64] ;
  unsigned int modul ;
  int i ;
  int n ;
  int tmp___0 ;
  char custom[257] ;

  {
  {
#line 463
  if ((int )event->cmd == 35605) {
#line 463
    goto case_35605;
  }
#line 468
  if ((int )event->cmd == 35587) {
#line 468
    goto case_35587;
  }
#line 474
  if ((int )event->cmd == 35589) {
#line 474
    goto case_35589;
  }
#line 487
  if ((int )event->cmd == 35591) {
#line 487
    goto case_35591;
  }
#line 494
  if ((int )event->cmd == 35585) {
#line 494
    goto case_35585;
  }
#line 497
  if ((int )event->cmd == 35611) {
#line 497
    goto case_35611;
  }
#line 517
  if ((int )event->cmd == 35627) {
#line 517
    goto case_35627;
  }
#line 545
  if ((int )event->cmd == 35617) {
#line 545
    goto case_35617;
  }
#line 564
  if ((int )event->cmd == 35631) {
#line 564
    goto case_35631;
  }
#line 584
  if ((int )event->cmd == 35841) {
#line 584
    goto case_35841;
  }
#line 590
  if ((int )event->cmd == 35845) {
#line 590
    goto case_35845;
  }
#line 595
  if ((int )event->cmd == 35842) {
#line 595
    goto case_35842;
  }
#line 604
  goto switch_default;
  case_35605: /* CIL Label */ 
  {
#line 464
  tmp = iw_saether_ntop((struct sockaddr  const  *)(& event->u.ap_addr), buffer);
#line 464
  printf((char const   */* __restrict  */)"          Cell %02d - Address: %s\n", state->ap_num,
         tmp);
#line 466
  (state->ap_num) ++;
  }
#line 467
  goto switch_break;
  case_35587: /* CIL Label */ 
#line 469
  if (event->u.nwid.disabled) {
    {
#line 470
    printf((char const   */* __restrict  */)"                    NWID:off/any\n");
    }
  } else {
    {
#line 472
    printf((char const   */* __restrict  */)"                    NWID:%X\n", event->u.nwid.value);
    }
  }
#line 473
  goto switch_break;
  case_35589: /* CIL Label */ 
  {
#line 477
  channel = -1;
#line 478
  freq = iw_freq2float((iwfreq const   *)(& event->u.freq));
  }
#line 480
  if (has_range) {
    {
#line 481
    channel = iw_freq_to_channel(freq, (struct iw_range  const  *)iw_range);
    }
  }
  {
#line 482
  iw_print_freq(buffer, (int )sizeof(buffer), freq, channel, (int )event->u.freq.flags);
#line 484
  printf((char const   */* __restrict  */)"                    %s\n", buffer);
  }
#line 486
  goto switch_break;
  case_35591: /* CIL Label */ 
#line 489
  if (event->u.mode >= 7U) {
#line 490
    event->u.mode = (__u32 )7;
  }
  {
#line 491
  printf((char const   */* __restrict  */)"                    Mode:%s\n", iw_operation_mode[event->u.mode]);
  }
#line 493
  goto switch_break;
  case_35585: /* CIL Label */ 
  {
#line 495
  printf((char const   */* __restrict  */)"                    Protocol:%-1.16s\n",
         event->u.name);
  }
#line 496
  goto switch_break;
  case_35611: /* CIL Label */ 
  {
#line 500
  memset((void *)(essid), '\000', sizeof(essid));
  }
#line 501
  if (event->u.essid.pointer) {
#line 501
    if (event->u.essid.length) {
      {
#line 502
      iw_essid_escape(essid, (char const   *)event->u.essid.pointer, (int const   )event->u.essid.length);
      }
    }
  }
#line 504
  if (event->u.essid.flags) {
#line 507
    if (((int )event->u.essid.flags & 255) > 1) {
      {
#line 508
      printf((char const   */* __restrict  */)"                    ESSID:\"%s\" [%d]\n",
             essid, (int )event->u.essid.flags & 255);
      }
    } else {
      {
#line 511
      printf((char const   */* __restrict  */)"                    ESSID:\"%s\"\n",
             essid);
      }
    }
  } else {
    {
#line 514
    printf((char const   */* __restrict  */)"                    ESSID:off/any/hidden\n");
    }
  }
#line 516
  goto switch_break;
  case_35627: /* CIL Label */ 
#line 520
  if (event->u.data.pointer) {
    {
#line 521
    memcpy((void */* __restrict  */)(key), (void const   */* __restrict  */)event->u.data.pointer,
           (size_t )event->u.data.length);
    }
  } else {
#line 523
    event->u.data.flags = (__u16 )((int )event->u.data.flags | 2048);
  }
  {
#line 524
  printf((char const   */* __restrict  */)"                    Encryption key:");
  }
#line 525
  if ((int )event->u.data.flags & 32768) {
    {
#line 526
    printf((char const   */* __restrict  */)"off\n");
    }
  } else {
    {
#line 530
    iw_print_key(buffer, (int )sizeof(buffer), (unsigned char const   *)(key), (int )event->u.data.length,
                 (int )event->u.data.flags);
#line 532
    printf((char const   */* __restrict  */)"%s", buffer);
    }
#line 535
    if (((int )event->u.data.flags & 255) > 1) {
      {
#line 536
      printf((char const   */* __restrict  */)" [%d]", (int )event->u.data.flags & 255);
      }
    }
#line 537
    if ((int )event->u.data.flags & 16384) {
      {
#line 538
      printf((char const   */* __restrict  */)"   Security mode:restricted");
      }
    }
#line 539
    if ((int )event->u.data.flags & 8192) {
      {
#line 540
      printf((char const   */* __restrict  */)"   Security mode:open");
      }
    }
    {
#line 541
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 544
  goto switch_break;
  case_35617: /* CIL Label */ 
#line 546
  if (state->val_index == 0) {
    {
#line 547
    printf((char const   */* __restrict  */)"                    Bit Rates:");
    }
  } else
#line 549
  if (state->val_index % 5 == 0) {
    {
#line 550
    printf((char const   */* __restrict  */)"\n                              ");
    }
  } else {
    {
#line 552
    printf((char const   */* __restrict  */)"; ");
    }
  }
  {
#line 553
  iw_print_bitrate(buffer, (int )sizeof(buffer), event->u.bitrate.value);
#line 554
  printf((char const   */* __restrict  */)"%s", buffer);
  }
#line 556
  if ((unsigned long )stream->value == (unsigned long )((void *)0)) {
    {
#line 558
    printf((char const   */* __restrict  */)"\n");
#line 559
    state->val_index = 0;
    }
  } else {
#line 562
    (state->val_index) ++;
  }
#line 563
  goto switch_break;
  case_35631: /* CIL Label */ 
  {
#line 566
  modul = (unsigned int )event->u.param.value;
#line 568
  n = 0;
#line 569
  printf((char const   */* __restrict  */)"                    Modulations :");
#line 570
  i = 0;
  }
  {
#line 570
  while (1) {
    while_continue: /* CIL Label */ ;
#line 570
    if (! (i < 16)) {
#line 570
      goto while_break;
    }
#line 572
    if ((modul & (unsigned int )iw_modul_list[i].mask) == (unsigned int )iw_modul_list[i].mask) {
#line 574
      tmp___0 = n;
#line 574
      n ++;
#line 574
      if (tmp___0 % 8 == 7) {
        {
#line 575
        printf((char const   */* __restrict  */)"\n                        ");
        }
      } else {
        {
#line 577
        printf((char const   */* __restrict  */)" ; ");
        }
      }
      {
#line 578
      printf((char const   */* __restrict  */)"%s", iw_modul_list[i].cmd);
      }
    }
#line 570
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 581
  printf((char const   */* __restrict  */)"\n");
  }
#line 583
  goto switch_break;
  case_35841: /* CIL Label */ 
  {
#line 585
  iw_print_stats(buffer, (int )sizeof(buffer), (iwqual const   *)(& event->u.qual),
                 (iwrange const   *)iw_range, has_range);
#line 587
  printf((char const   */* __restrict  */)"                    %s\n", buffer);
  }
#line 588
  goto switch_break;
  case_35845: /* CIL Label */ 
  {
#line 592
  iw_print_gen_ie((unsigned char *)event->u.data.pointer, (int )event->u.data.length);
  }
#line 593
  goto switch_break;
  case_35842: /* CIL Label */ 
#line 598
  if (event->u.data.pointer) {
#line 598
    if (event->u.data.length) {
      {
#line 599
      memcpy((void */* __restrict  */)(custom), (void const   */* __restrict  */)event->u.data.pointer,
             (size_t )event->u.data.length);
      }
    }
  }
  {
#line 600
  custom[event->u.data.length] = (char )'\000';
#line 601
  printf((char const   */* __restrict  */)"                    Extra:%s\n", custom);
  }
#line 603
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 605
  printf((char const   */* __restrict  */)"                    (Unknown Wireless Token 0x%04X)\n",
         (int )event->cmd);
  }
  switch_break: /* CIL Label */ ;
  }
#line 608
  return;
}
}
#line 614 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlist.c"
static int print_scanning_info(int skfd , char *ifname , char **args , int count ) 
{ 
  struct iwreq wrq ;
  struct iw_scan_req scanopt ;
  int scanflags ;
  unsigned char *buffer ;
  int buflen ;
  struct iw_range range ;
  int has_range ;
  struct timeval tv ;
  int timeout ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  fd_set rfds ;
  int last_fd ;
  int ret ;
  int __d0 ;
  int __d1 ;
  int *tmp___7 ;
  int *tmp___8 ;
  unsigned char *newbuf ;
  void *tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  struct iw_event iwe ;
  struct stream_descr stream ;
  struct iwscan_state state ;
  int ret___0 ;

  {
#line 622
  scanflags = 0;
#line 623
  buffer = (unsigned char *)((void *)0);
#line 624
  buflen = 4096;
#line 628
  timeout = 15000000;
#line 631
  args = args;
#line 631
  count = count;
#line 634
  if (sizeof(struct iw_pk_event ) - sizeof(union iwreq_data ) != 4UL) {
    {
#line 636
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*** Please report to jt@hpl.hp.com your platform details\n");
#line 637
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*** and the following line :\n");
#line 638
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*** IW_EV_LCP_PK2_LEN = %zu ; IW_EV_POINT_PK2_LEN = %zu\n\n",
            sizeof(struct iw_pk_event ) - sizeof(union iwreq_data ), ((sizeof(struct iw_pk_event ) - sizeof(union iwreq_data )) + sizeof(struct iw_pk_point )) - (unsigned long )((char *)(& ((struct iw_point *)((void *)0))->length) - (char *)((void *)0)));
    }
  } else
#line 634
  if (((sizeof(struct iw_pk_event ) - sizeof(union iwreq_data )) + sizeof(struct iw_pk_point )) - (unsigned long )((char *)(& ((struct iw_point *)((void *)0))->length) - (char *)((void *)0)) != 8UL) {
    {
#line 636
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*** Please report to jt@hpl.hp.com your platform details\n");
#line 637
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*** and the following line :\n");
#line 638
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*** IW_EV_LCP_PK2_LEN = %zu ; IW_EV_POINT_PK2_LEN = %zu\n\n",
            sizeof(struct iw_pk_event ) - sizeof(union iwreq_data ), ((sizeof(struct iw_pk_event ) - sizeof(union iwreq_data )) + sizeof(struct iw_pk_point )) - (unsigned long )((char *)(& ((struct iw_point *)((void *)0))->length) - (char *)((void *)0)));
    }
  }
  {
#line 643
  tmp = iw_get_range_info(skfd, (char const   *)ifname, & range);
#line 643
  has_range = tmp >= 0;
  }
#line 646
  if (! has_range) {
    {
#line 648
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  Interface doesn\'t support scanning.\n\n",
            ifname);
    }
#line 650
    return (-1);
  } else
#line 646
  if ((int )range.we_version_compiled < 14) {
    {
#line 648
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  Interface doesn\'t support scanning.\n\n",
            ifname);
    }
#line 650
    return (-1);
  }
  {
#line 654
  tv.tv_sec = (__time_t )0;
#line 655
  tv.tv_usec = (__suseconds_t )250000;
#line 658
  memset((void *)(& scanopt), 0, sizeof(scanopt));
  }
  {
#line 663
  while (1) {
    while_continue: /* CIL Label */ ;
#line 663
    if (! (count > 0)) {
#line 663
      goto while_break;
    }
    {
#line 666
    count --;
#line 671
    tmp___2 = strncmp((char const   *)*(args + 0), "essid", (size_t )5);
    }
#line 671
    if (tmp___2) {
      {
#line 696
      tmp___1 = strncmp((char const   *)*(args + 0), "last", (size_t )4);
      }
#line 696
      if (tmp___1) {
        {
#line 703
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid scanning option [%s]\n",
                *(args + 0));
        }
#line 704
        return (-1);
      } else {
#line 699
        scanflags |= 32768;
      }
    } else {
#line 673
      if (count < 1) {
        {
#line 675
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Too few arguments for scanning option [%s]\n",
                *(args + 0));
        }
#line 677
        return (-1);
      }
      {
#line 679
      args ++;
#line 680
      count --;
#line 683
      tmp___0 = strlen((char const   *)*(args + 0));
#line 683
      scanopt.essid_len = (__u8 )tmp___0;
#line 684
      memcpy((void */* __restrict  */)(scanopt.essid), (void const   */* __restrict  */)*(args + 0),
             (size_t )scanopt.essid_len);
      }
#line 686
      if ((int )scanopt.bssid.sa_family == 0) {
        {
#line 688
        scanopt.bssid.sa_family = (sa_family_t )1;
#line 689
        memset((void *)(scanopt.bssid.sa_data), 255, (size_t )6);
        }
      }
#line 692
      scanflags |= 2;
    }
#line 708
    args ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 712
  if (scanflags) {
#line 714
    wrq.u.data.pointer = (void *)((caddr_t )(& scanopt));
#line 715
    wrq.u.data.length = (__u16 )sizeof(scanopt);
#line 716
    wrq.u.data.flags = (__u16 )scanflags;
  } else {
#line 720
    wrq.u.data.pointer = (void *)0;
#line 721
    wrq.u.data.flags = (__u16 )0;
#line 722
    wrq.u.data.length = (__u16 )0;
  }
#line 726
  if (scanflags == 32768) {
#line 729
    tv.tv_usec = (__suseconds_t )0;
  } else {
    {
#line 734
    tmp___6 = iw_set_ext(skfd, (char const   *)ifname, 35608, & wrq);
    }
#line 734
    if (tmp___6 < 0) {
      {
#line 736
      tmp___5 = __errno_location();
      }
#line 736
      if (*tmp___5 != 1) {
        {
#line 738
        tmp___3 = __errno_location();
#line 738
        tmp___4 = strerror(*tmp___3);
#line 738
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  Interface doesn\'t support scanning : %s\n\n",
                ifname, tmp___4);
        }
#line 740
        return (-1);
      } else
#line 736
      if (scanflags != 0) {
        {
#line 738
        tmp___3 = __errno_location();
#line 738
        tmp___4 = strerror(*tmp___3);
#line 738
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  Interface doesn\'t support scanning : %s\n\n",
                ifname, tmp___4);
        }
#line 740
        return (-1);
      }
#line 749
      tv.tv_usec = (__suseconds_t )0;
    }
  }
#line 752
  timeout = (int )((__suseconds_t )timeout - tv.tv_usec);
  {
#line 755
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 762
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 762
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& rfds.__fds_bits[0]): "memory");
#line 762
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 763
    last_fd = -1;
#line 768
    ret = select(last_fd + 1, (fd_set */* __restrict  */)(& rfds), (fd_set */* __restrict  */)((void *)0),
                 (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
    }
#line 771
    if (ret < 0) {
      {
#line 773
      tmp___7 = __errno_location();
      }
#line 773
      if (*tmp___7 == 11) {
#line 774
        goto while_continue___0;
      } else {
        {
#line 773
        tmp___8 = __errno_location();
        }
#line 773
        if (*tmp___8 == 4) {
#line 774
          goto while_continue___0;
        }
      }
      {
#line 775
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unhandled signal - exiting...\n");
      }
#line 776
      return (-1);
    }
#line 780
    if (ret == 0) {
      realloc: 
      {
#line 786
      tmp___9 = realloc((void *)buffer, (size_t )buflen);
#line 786
      newbuf = (unsigned char *)tmp___9;
      }
#line 787
      if ((unsigned long )newbuf == (unsigned long )((void *)0)) {
#line 789
        if (buffer) {
          {
#line 790
          free((void *)buffer);
          }
        }
        {
#line 791
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Allocation failed\n",
                "print_scanning_info");
        }
#line 792
        return (-1);
      }
      {
#line 794
      buffer = newbuf;
#line 797
      wrq.u.data.pointer = (void *)buffer;
#line 798
      wrq.u.data.flags = (__u16 )0;
#line 799
      wrq.u.data.length = (__u16 )buflen;
#line 800
      tmp___14 = iw_set_ext(skfd, (char const   *)ifname, 35609, & wrq);
      }
#line 800
      if (tmp___14 < 0) {
        {
#line 803
        tmp___10 = __errno_location();
        }
#line 803
        if (*tmp___10 == 7) {
#line 803
          if ((int )range.we_version_compiled > 16) {
#line 803
            if (buflen < 65535) {
#line 815
              if ((int )wrq.u.data.length > buflen) {
#line 816
                buflen = (int )wrq.u.data.length;
              } else {
#line 818
                buflen *= 2;
              }
#line 821
              if (buflen > 65535) {
#line 822
                buflen = 65535;
              }
#line 825
              goto realloc;
            }
          }
        }
        {
#line 829
        tmp___11 = __errno_location();
        }
#line 829
        if (*tmp___11 == 11) {
#line 832
          tv.tv_sec = (__time_t )0;
#line 833
          tv.tv_usec = (__suseconds_t )100000;
#line 834
          timeout = (int )((__suseconds_t )timeout - tv.tv_usec);
#line 835
          if (timeout > 0) {
#line 836
            goto while_continue___0;
          }
        }
        {
#line 840
        free((void *)buffer);
#line 841
        tmp___12 = __errno_location();
#line 841
        tmp___13 = strerror(*tmp___12);
#line 841
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  Failed to read scan data : %s\n\n",
                ifname, tmp___13);
        }
#line 843
        return (-2);
      } else {
#line 847
        goto while_break___0;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 854
  if (wrq.u.data.length) {
    {
#line 858
    state.ap_num = 1;
#line 858
    state.val_index = 0;
#line 869
    printf((char const   */* __restrict  */)"%-8.16s  Scan completed :\n", ifname);
#line 870
    iw_init_event_stream(& stream, (char *)buffer, (int )wrq.u.data.length);
    }
    {
#line 871
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 874
      ret___0 = iw_extract_event_stream(& stream, & iwe, (int )range.we_version_compiled);
      }
#line 876
      if (ret___0 > 0) {
        {
#line 877
        print_scanning_token(& stream, & iwe, & state, & range, has_range);
        }
      }
#line 871
      if (! (ret___0 > 0)) {
#line 871
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 881
    printf((char const   */* __restrict  */)"\n");
    }
  } else {
    {
#line 884
    printf((char const   */* __restrict  */)"%-8.16s  No scan results\n\n", ifname);
    }
  }
  {
#line 886
  free((void *)buffer);
  }
#line 887
  return (0);
}
}
#line 896 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlist.c"
static int print_freq_info(int skfd , char *ifname , char **args , int count ) 
{ 
  struct iwreq wrq ;
  struct iw_range range ;
  double freq ;
  int k ;
  int channel ;
  char buffer[128] ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 910
  args = args;
#line 910
  count = count;
#line 913
  tmp___0 = iw_get_range_info(skfd, (char const   *)ifname, & range);
  }
#line 913
  if (tmp___0 < 0) {
    {
#line 914
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  no frequency information.\n\n",
            ifname);
    }
  } else {
#line 918
    if ((int )range.num_frequency > 0) {
      {
#line 920
      printf((char const   */* __restrict  */)"%-8.16s  %d channels in total; available frequencies :\n",
             ifname, (int )range.num_channels);
#line 923
      k = 0;
      }
      {
#line 923
      while (1) {
        while_continue: /* CIL Label */ ;
#line 923
        if (! (k < (int )range.num_frequency)) {
#line 923
          goto while_break;
        }
        {
#line 925
        freq = iw_freq2float((iwfreq const   *)(& range.freq[k]));
#line 926
        iw_print_freq_value(buffer, (int )sizeof(buffer), freq);
#line 927
        printf((char const   */* __restrict  */)"          Channel %.2d : %s\n", (int )range.freq[k].i,
               buffer);
#line 923
        k ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 932
      printf((char const   */* __restrict  */)"%-8.16s  %d channels\n", ifname, (int )range.num_channels);
      }
    }
    {
#line 936
    tmp = iw_set_ext(skfd, (char const   *)ifname, 35589, & wrq);
    }
#line 936
    if (tmp >= 0) {
      {
#line 938
      freq = iw_freq2float((iwfreq const   *)(& wrq.u.freq));
#line 939
      channel = iw_freq_to_channel(freq, (struct iw_range  const  *)(& range));
#line 940
      iw_print_freq(buffer, (int )sizeof(buffer), freq, channel, (int )wrq.u.freq.flags);
#line 942
      printf((char const   */* __restrict  */)"          Current %s\n\n", buffer);
      }
    }
  }
#line 945
  return (0);
}
}
#line 954 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlist.c"
static int print_bitrate_info(int skfd , char *ifname , char **args , int count ) 
{ 
  struct iwreq wrq ;
  struct iw_range range ;
  int k ;
  char buffer[128] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 966
  args = args;
#line 966
  count = count;
#line 969
  tmp___3 = iw_get_range_info(skfd, (char const   *)ifname, & range);
  }
#line 969
  if (tmp___3 < 0) {
    {
#line 970
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  no bit-rate information.\n\n",
            ifname);
    }
  } else {
#line 974
    if ((int )range.num_bitrates > 0) {
#line 974
      if ((int )range.num_bitrates <= 32) {
        {
#line 976
        printf((char const   */* __restrict  */)"%-8.16s  %d available bit-rates :\n",
               ifname, (int )range.num_bitrates);
#line 979
        k = 0;
        }
        {
#line 979
        while (1) {
          while_continue: /* CIL Label */ ;
#line 979
          if (! (k < (int )range.num_bitrates)) {
#line 979
            goto while_break;
          }
          {
#line 981
          iw_print_bitrate(buffer, (int )sizeof(buffer), range.bitrate[k]);
#line 983
          printf((char const   */* __restrict  */)"\t  %s\n", buffer);
#line 979
          k ++;
          }
        }
        while_break: /* CIL Label */ ;
        }
      } else {
        {
#line 987
        printf((char const   */* __restrict  */)"%-8.16s  unknown bit-rate information.\n",
               ifname);
        }
      }
    } else {
      {
#line 987
      printf((char const   */* __restrict  */)"%-8.16s  unknown bit-rate information.\n",
             ifname);
      }
    }
    {
#line 990
    tmp___0 = iw_set_ext(skfd, (char const   *)ifname, 35617, & wrq);
    }
#line 990
    if (tmp___0 >= 0) {
      {
#line 992
      iw_print_bitrate(buffer, (int )sizeof(buffer), wrq.u.bitrate.value);
      }
#line 993
      if (wrq.u.bitrate.fixed) {
#line 993
        tmp = '=';
      } else {
#line 993
        tmp = ':';
      }
      {
#line 993
      printf((char const   */* __restrict  */)"          Current Bit Rate%c%s\n",
             tmp, buffer);
      }
    }
#line 998
    if (range.bitrate_capa & 2U) {
      {
#line 1000
      wrq.u.bitrate.flags = (__u16 )2;
#line 1001
      tmp___2 = iw_set_ext(skfd, (char const   *)ifname, 35617, & wrq);
      }
#line 1001
      if (tmp___2 >= 0) {
        {
#line 1003
        iw_print_bitrate(buffer, (int )sizeof(buffer), wrq.u.bitrate.value);
        }
#line 1004
        if (wrq.u.bitrate.fixed) {
#line 1004
          tmp___1 = '=';
        } else {
#line 1004
          tmp___1 = ':';
        }
        {
#line 1004
        printf((char const   */* __restrict  */)"          Broadcast Bit Rate%c%s\n",
               tmp___1, buffer);
        }
      }
    }
    {
#line 1009
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 1011
  return (0);
}
}
#line 1020 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlist.c"
static int print_keys_info(int skfd , char *ifname , char **args , int count ) 
{ 
  struct iwreq wrq ;
  struct iw_range range ;
  unsigned char key[64] ;
  unsigned int k ;
  char buffer[128] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1033
  args = args;
#line 1033
  count = count;
#line 1036
  tmp___3 = iw_get_range_info(skfd, (char const   *)ifname, & range);
  }
#line 1036
  if (tmp___3 < 0) {
    {
#line 1037
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  no encryption keys information.\n\n",
            ifname);
    }
  } else {
    {
#line 1041
    printf((char const   */* __restrict  */)"%-8.16s  ", ifname);
    }
#line 1043
    if ((int )range.num_encoding_sizes > 0) {
#line 1043
      if ((int )range.num_encoding_sizes < 8) {
        {
#line 1046
        printf((char const   */* __restrict  */)"%d key sizes : %d", (int )range.num_encoding_sizes,
               (int )range.encoding_size[0] * 8);
#line 1049
        k = 1U;
        }
        {
#line 1049
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1049
          if (! (k < (unsigned int )range.num_encoding_sizes)) {
#line 1049
            goto while_break;
          }
          {
#line 1050
          printf((char const   */* __restrict  */)", %d", (int )range.encoding_size[k] * 8);
#line 1049
          k ++;
          }
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 1051
        printf((char const   */* __restrict  */)"bits\n          ");
        }
      }
    }
    {
#line 1054
    printf((char const   */* __restrict  */)"%d keys available :\n", (int )range.max_encoding_tokens);
#line 1055
    k = 1U;
    }
    {
#line 1055
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1055
      if (! (k <= (unsigned int )range.max_encoding_tokens)) {
#line 1055
        goto while_break___0;
      }
      {
#line 1057
      wrq.u.data.pointer = (void *)((caddr_t )(key));
#line 1058
      wrq.u.data.length = (__u16 )64;
#line 1059
      wrq.u.data.flags = (__u16 )k;
#line 1060
      tmp___1 = iw_set_ext(skfd, (char const   *)ifname, 35627, & wrq);
      }
#line 1060
      if (tmp___1 < 0) {
        {
#line 1062
        tmp = __errno_location();
#line 1062
        tmp___0 = strerror(*tmp);
#line 1062
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error reading wireless keys (SIOCGIWENCODE): %s\n",
                tmp___0);
        }
#line 1063
        goto while_break___0;
      }
#line 1065
      if ((int )wrq.u.data.flags & 32768) {
        {
#line 1067
        printf((char const   */* __restrict  */)"\t\t[%d]: off\n", k);
        }
      } else
#line 1065
      if ((int )wrq.u.data.length == 0) {
        {
#line 1067
        printf((char const   */* __restrict  */)"\t\t[%d]: off\n", k);
        }
      } else {
        {
#line 1071
        iw_print_key(buffer, (int )sizeof(buffer), (unsigned char const   *)(key),
                     (int )wrq.u.data.length, (int )wrq.u.data.flags);
#line 1073
        printf((char const   */* __restrict  */)"\t\t[%d]: %s", k, buffer);
#line 1076
        printf((char const   */* __restrict  */)" (%d bits)", (int )wrq.u.data.length * 8);
#line 1077
        printf((char const   */* __restrict  */)"\n");
        }
      }
#line 1055
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1081
    wrq.u.data.pointer = (void *)((caddr_t )(key));
#line 1082
    wrq.u.data.length = (__u16 )64;
#line 1083
    wrq.u.data.flags = (__u16 )0;
#line 1084
    tmp___2 = iw_set_ext(skfd, (char const   *)ifname, 35627, & wrq);
    }
#line 1084
    if (tmp___2 >= 0) {
      {
#line 1088
      printf((char const   */* __restrict  */)"          Current Transmit Key: [%d]\n",
             (int )wrq.u.data.flags & 255);
      }
#line 1090
      if ((int )wrq.u.data.flags & 16384) {
        {
#line 1091
        printf((char const   */* __restrict  */)"          Security mode:restricted\n");
        }
      }
#line 1092
      if ((int )wrq.u.data.flags & 8192) {
        {
#line 1093
        printf((char const   */* __restrict  */)"          Security mode:open\n");
        }
      }
    }
    {
#line 1096
    printf((char const   */* __restrict  */)"\n\n");
    }
  }
#line 1098
  return (0);
}
}
#line 1107 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlist.c"
static int get_pm_value(int skfd , char *ifname , struct iwreq *pwrq , int flags ,
                        char *buffer , int buflen , int we_version_compiled ) 
{ 
  int tmp ;

  {
  {
#line 1117
  pwrq->u.power.flags = (__u16 )flags;
#line 1118
  tmp = iw_set_ext(skfd, (char const   *)ifname, 35629, pwrq);
  }
#line 1118
  if (tmp >= 0) {
#line 1121
    if ((int )pwrq->u.power.flags & 61440) {
      {
#line 1123
      iw_print_pm_value(buffer, buflen, pwrq->u.power.value, (int )pwrq->u.power.flags,
                        we_version_compiled);
#line 1126
      printf((char const   */* __restrict  */)"\n                 %s", buffer);
      }
    }
  }
#line 1129
  return ((int )pwrq->u.power.flags);
}
}
#line 1136 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlist.c"
static void print_pm_value_range(char *name , int mask , int iwr_flags , int iwr_min ,
                                 int iwr_max , char *buffer , int buflen , int we_version_compiled ) 
{ 
  int flags ;
  char const   *tmp ;

  {
#line 1146
  if (iwr_flags & mask) {
#line 1148
    flags = iwr_flags & -4;
#line 1150
    if (iwr_flags & 1) {
#line 1150
      tmp = "Auto ";
    } else {
#line 1150
      tmp = "Fixed";
    }
    {
#line 1150
    printf((char const   */* __restrict  */)"%s %s ; ", tmp, name);
#line 1154
    iw_print_pm_value(buffer, buflen, iwr_min, flags | 1, we_version_compiled);
#line 1157
    printf((char const   */* __restrict  */)"%s\n                          ", buffer);
#line 1158
    iw_print_pm_value(buffer, buflen, iwr_max, flags | 2, we_version_compiled);
#line 1161
    printf((char const   */* __restrict  */)"%s\n          ", buffer);
    }
  }
#line 1163
  return;
}
}
#line 1169 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlist.c"
static unsigned int const   pm_type_flags[3]  = {      (unsigned int const   )4096,      (unsigned int const   )8192,      (unsigned int const   )16384};
#line 1174 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlist.c"
static int const   pm_type_flags_size  =    (int const   )(sizeof(pm_type_flags) / sizeof(pm_type_flags[0]));
#line 1180 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlist.c"
static int print_pm_info(int skfd , char *ifname , char **args , int count ) 
{ 
  struct iwreq wrq ;
  struct iw_range range ;
  char buffer[128] ;
  int flags ;
  unsigned int pm_type ;
  unsigned int pm_mask ;
  unsigned int remain_mask ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1191
  args = args;
#line 1191
  count = count;
#line 1194
  tmp___0 = iw_get_range_info(skfd, (char const   *)ifname, & range);
  }
#line 1194
  if (tmp___0 < 0) {
    {
#line 1196
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  no power management information.\n\n",
            ifname);
    }
  } else
#line 1194
  if ((int )range.we_version_compiled < 10) {
    {
#line 1196
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  no power management information.\n\n",
            ifname);
    }
  } else {
    {
#line 1200
    printf((char const   */* __restrict  */)"%-8.16s  ", ifname);
    }
#line 1203
    if ((int )range.pm_capa & 3840) {
      {
#line 1205
      printf((char const   */* __restrict  */)"Supported modes :\n          ");
      }
#line 1206
      if ((int )range.pm_capa & 768) {
        {
#line 1207
        printf((char const   */* __restrict  */)"\t\to Receive all packets (unicast & multicast)\n          ");
        }
      }
#line 1208
      if ((int )range.pm_capa & 256) {
        {
#line 1209
        printf((char const   */* __restrict  */)"\t\to Receive Unicast only (discard multicast)\n          ");
        }
      }
#line 1210
      if ((int )range.pm_capa & 512) {
        {
#line 1211
        printf((char const   */* __restrict  */)"\t\to Receive Multicast only (discard unicast)\n          ");
        }
      }
#line 1212
      if ((int )range.pm_capa & 1024) {
        {
#line 1213
        printf((char const   */* __restrict  */)"\t\to Force sending using Power Management\n          ");
        }
      }
#line 1214
      if ((int )range.pm_capa & 2048) {
        {
#line 1215
        printf((char const   */* __restrict  */)"\t\to Repeat multicast\n          ");
        }
      }
    }
    {
#line 1218
    print_pm_value_range((char *)"period ", 4096, (int )range.pmp_flags, range.min_pmp,
                         range.max_pmp, buffer, (int )sizeof(buffer), (int )range.we_version_compiled);
#line 1222
    print_pm_value_range((char *)"timeout", 8192, (int )range.pmt_flags, range.min_pmt,
                         range.max_pmt, buffer, (int )sizeof(buffer), (int )range.we_version_compiled);
#line 1226
    print_pm_value_range((char *)"saving ", 16384, (int )range.pms_flags, range.min_pms,
                         range.max_pms, buffer, (int )sizeof(buffer), (int )range.we_version_compiled);
#line 1231
    wrq.u.power.flags = (__u16 )0;
#line 1232
    tmp = iw_set_ext(skfd, (char const   *)ifname, 35629, & wrq);
    }
#line 1232
    if (tmp >= 0) {
#line 1234
      flags = (int )wrq.u.power.flags;
#line 1237
      if (wrq.u.power.disabled) {
        {
#line 1238
        printf((char const   */* __restrict  */)"Current mode:off\n");
        }
      } else {
        {
#line 1241
        pm_type = 0U;
#line 1242
        pm_mask = 0U;
#line 1243
        remain_mask = (unsigned int )((int )range.pm_capa & 61440);
#line 1244
        i = 0;
#line 1247
        iw_print_pm_mode(buffer, (int )sizeof(buffer), flags);
#line 1248
        printf((char const   */* __restrict  */)"Current %s", buffer);
        }
#line 1251
        if ((flags & 3840) == 0) {
          {
#line 1252
          printf((char const   */* __restrict  */)"mode:on");
          }
        }
#line 1255
        if ((int )wrq.u.power.flags & 61440) {
          {
#line 1257
          iw_print_pm_value(buffer, (int )sizeof(buffer), wrq.u.power.value, (int )wrq.u.power.flags,
                            (int )range.we_version_compiled);
#line 1260
          printf((char const   */* __restrict  */)"\n                 %s", buffer);
          }
        }
        {
#line 1263
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1266
          pm_mask = 0U;
#line 1268
          if (flags & 1) {
#line 1269
            pm_mask = 2U;
          }
#line 1271
          if (flags & 2) {
#line 1272
            pm_mask = 1U;
          }
#line 1274
          if (pm_mask) {
            {
#line 1276
            pm_mask |= pm_type;
#line 1277
            get_pm_value(skfd, ifname, & wrq, (int )pm_mask, buffer, (int )sizeof(buffer),
                         (int )range.we_version_compiled);
            }
          }
#line 1283
          remain_mask &= (unsigned int )(~ ((int )wrq.u.power.flags));
          {
#line 1286
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 1286
            if (! (i < (int )pm_type_flags_size)) {
#line 1286
              goto while_break___0;
            }
#line 1288
            pm_type = remain_mask & (unsigned int )pm_type_flags[i];
#line 1289
            if (pm_type) {
#line 1290
              goto while_break___0;
            }
#line 1291
            i ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 1294
          if (! pm_type) {
#line 1295
            goto while_break;
          }
          {
#line 1298
          flags = get_pm_value(skfd, ifname, & wrq, (int )pm_type, buffer, (int )sizeof(buffer),
                               (int )range.we_version_compiled);
          }
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 1303
        printf((char const   */* __restrict  */)"\n");
        }
      }
    }
    {
#line 1306
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 1308
  return (0);
}
}
#line 1318 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlist.c"
static int print_txpower_info(int skfd , char *ifname , char **args , int count ) 
{ 
  struct iwreq wrq ;
  struct iw_range range ;
  int dbm ;
  int mwatt ;
  int k ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1331
  args = args;
#line 1331
  count = count;
#line 1334
  tmp___0 = iw_get_range_info(skfd, (char const   *)ifname, & range);
  }
#line 1334
  if (tmp___0 < 0) {
    {
#line 1336
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  no transmit-power information.\n\n",
            ifname);
    }
  } else
#line 1334
  if ((int )range.we_version_compiled < 10) {
    {
#line 1336
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  no transmit-power information.\n\n",
            ifname);
    }
  } else {
#line 1340
    if ((int )range.num_txpower <= 0) {
      {
#line 1341
      printf((char const   */* __restrict  */)"%-8.16s  unknown transmit-power information.\n\n",
             ifname);
      }
    } else
#line 1340
    if ((int )range.num_txpower > 8) {
      {
#line 1341
      printf((char const   */* __restrict  */)"%-8.16s  unknown transmit-power information.\n\n",
             ifname);
      }
    } else {
      {
#line 1344
      printf((char const   */* __restrict  */)"%-8.16s  %d available transmit-powers :\n",
             ifname, (int )range.num_txpower);
#line 1347
      k = 0;
      }
      {
#line 1347
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1347
        if (! (k < (int )range.num_txpower)) {
#line 1347
          goto while_break;
        }
#line 1350
        if ((int )range.txpower_capa & 2) {
          {
#line 1352
          printf((char const   */* __restrict  */)"\t  %d (no units)\n", range.txpower[k]);
          }
        } else {
#line 1356
          if ((int )range.txpower_capa & 1) {
            {
#line 1358
            dbm = iw_mwatt2dbm(range.txpower[k]);
#line 1359
            mwatt = range.txpower[k];
            }
          } else {
            {
#line 1363
            dbm = range.txpower[k];
#line 1364
            mwatt = iw_dbm2mwatt(range.txpower[k]);
            }
          }
          {
#line 1366
          printf((char const   */* __restrict  */)"\t  %d dBm  \t(%d mW)\n", dbm,
                 mwatt);
          }
        }
#line 1347
        k ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 1372
    tmp = iw_set_ext(skfd, (char const   *)ifname, 35623, & wrq);
    }
#line 1372
    if (tmp >= 0) {
      {
#line 1374
      printf((char const   */* __restrict  */)"          Current Tx-Power");
      }
#line 1376
      if (wrq.u.txpower.disabled) {
        {
#line 1377
        printf((char const   */* __restrict  */)":off\n\n");
        }
      } else {
#line 1381
        if (wrq.u.txpower.fixed) {
          {
#line 1382
          printf((char const   */* __restrict  */)"=");
          }
        } else {
          {
#line 1384
          printf((char const   */* __restrict  */)":");
          }
        }
#line 1386
        if ((int )wrq.u.txpower.flags & 2) {
          {
#line 1392
          printf((char const   */* __restrict  */)"\t  %d (no units)\n", wrq.u.txpower.value);
          }
        } else {
#line 1396
          if ((int )wrq.u.txpower.flags & 1) {
            {
#line 1398
            dbm = iw_mwatt2dbm(wrq.u.txpower.value);
#line 1399
            mwatt = wrq.u.txpower.value;
            }
          } else {
            {
#line 1403
            dbm = wrq.u.txpower.value;
#line 1404
            mwatt = iw_dbm2mwatt(wrq.u.txpower.value);
            }
          }
          {
#line 1406
          printf((char const   */* __restrict  */)"%d dBm  \t(%d mW)\n\n", dbm, mwatt);
          }
        }
      }
    }
  }
#line 1411
  return (0);
}
}
#line 1420 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlist.c"
static int get_retry_value(int skfd , char *ifname , struct iwreq *pwrq , int flags ,
                           char *buffer , int buflen , int we_version_compiled ) 
{ 
  int tmp ;

  {
  {
#line 1430
  pwrq->u.retry.flags = (__u16 )flags;
#line 1431
  tmp = iw_set_ext(skfd, (char const   *)ifname, 35625, pwrq);
  }
#line 1431
  if (tmp >= 0) {
#line 1434
    if ((int )pwrq->u.retry.flags & 61440) {
      {
#line 1436
      iw_print_retry_value(buffer, buflen, pwrq->u.retry.value, (int )pwrq->u.retry.flags,
                           we_version_compiled);
#line 1439
      printf((char const   */* __restrict  */)"%s\n                 ", buffer);
      }
    }
  }
#line 1442
  return ((int )pwrq->u.retry.flags);
}
}
#line 1449 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlist.c"
static void print_retry_value_range(char *name , int mask , int iwr_flags , int iwr_min ,
                                    int iwr_max , char *buffer , int buflen , int we_version_compiled ) 
{ 
  int flags ;
  char const   *tmp ;

  {
#line 1459
  if (iwr_flags & mask) {
#line 1461
    flags = iwr_flags & -4;
#line 1463
    if (iwr_flags & 1) {
#line 1463
      tmp = "Auto ";
    } else {
#line 1463
      tmp = "Fixed";
    }
    {
#line 1463
    printf((char const   */* __restrict  */)"%s %s ; ", tmp, name);
#line 1467
    iw_print_retry_value(buffer, buflen, iwr_min, flags | 1, we_version_compiled);
#line 1470
    printf((char const   */* __restrict  */)"%s\n                           ", buffer);
#line 1471
    iw_print_retry_value(buffer, buflen, iwr_max, flags | 2, we_version_compiled);
#line 1474
    printf((char const   */* __restrict  */)"%s\n          ", buffer);
    }
  }
#line 1476
  return;
}
}
#line 1482 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlist.c"
static int print_retry_info(int skfd , char *ifname , char **args , int count ) 
{ 
  struct iwreq wrq ;
  struct iw_range range ;
  char buffer[128] ;
  int flags ;
  unsigned int retry_type ;
  unsigned int retry_mask ;
  unsigned int remain_mask ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1493
  args = args;
#line 1493
  count = count;
#line 1496
  tmp___0 = iw_get_range_info(skfd, (char const   *)ifname, & range);
  }
#line 1496
  if (tmp___0 < 0) {
    {
#line 1498
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  no retry limit/lifetime information.\n\n",
            ifname);
    }
  } else
#line 1496
  if ((int )range.we_version_compiled < 11) {
    {
#line 1498
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  no retry limit/lifetime information.\n\n",
            ifname);
    }
  } else {
    {
#line 1502
    printf((char const   */* __restrict  */)"%-8.16s  ", ifname);
#line 1505
    print_retry_value_range((char *)"limit   ", 4096, (int )range.retry_flags, range.min_retry,
                            range.max_retry, buffer, (int )sizeof(buffer), (int )range.we_version_compiled);
#line 1510
    print_retry_value_range((char *)"lifetime", 8192, (int )range.r_time_flags, range.min_r_time,
                            range.max_r_time, buffer, (int )sizeof(buffer), (int )range.we_version_compiled);
#line 1517
    wrq.u.retry.flags = (__u16 )0;
#line 1518
    tmp = iw_set_ext(skfd, (char const   *)ifname, 35625, & wrq);
    }
#line 1518
    if (tmp >= 0) {
#line 1520
      flags = (int )wrq.u.retry.flags;
#line 1523
      if (wrq.u.retry.disabled) {
        {
#line 1524
        printf((char const   */* __restrict  */)"Current mode:off\n          ");
        }
      } else {
        {
#line 1527
        retry_type = 0U;
#line 1528
        retry_mask = 0U;
#line 1529
        remain_mask = (unsigned int )((int )range.retry_capa & 61440);
#line 1532
        printf((char const   */* __restrict  */)"Current mode:on\n                 ");
        }
#line 1535
        if ((int )wrq.u.retry.flags & 61440) {
          {
#line 1537
          iw_print_retry_value(buffer, (int )sizeof(buffer), wrq.u.retry.value, (int )wrq.u.retry.flags,
                               (int )range.we_version_compiled);
#line 1540
          printf((char const   */* __restrict  */)"%s\n                 ", buffer);
          }
        }
        {
#line 1543
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1546
          retry_mask = 0U;
#line 1548
          if (flags & 1) {
#line 1549
            retry_mask = 2U;
          }
#line 1551
          if (flags & 2) {
#line 1552
            retry_mask = 1U;
          }
#line 1554
          if (flags & 16) {
#line 1555
            retry_mask = 32U;
          }
#line 1556
          if (flags & 32) {
#line 1557
            retry_mask = 16U;
          }
#line 1559
          if (retry_mask) {
            {
#line 1561
            retry_mask |= retry_type;
#line 1562
            get_retry_value(skfd, ifname, & wrq, (int )retry_mask, buffer, (int )sizeof(buffer),
                            (int )range.we_version_compiled);
            }
          }
#line 1569
          remain_mask &= (unsigned int )(~ ((int )wrq.u.retry.flags));
#line 1570
          retry_type = remain_mask;
#line 1572
          if (! retry_type) {
#line 1573
            goto while_break;
          }
          {
#line 1576
          flags = get_retry_value(skfd, ifname, & wrq, (int )retry_type, buffer, (int )sizeof(buffer),
                                  (int )range.we_version_compiled);
          }
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
    {
#line 1583
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 1585
  return (0);
}
}
#line 1599 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlist.c"
static int print_ap_info(int skfd , char *ifname , char **args , int count ) 
{ 
  struct iwreq wrq ;
  char buffer[(sizeof(struct iw_quality ) + sizeof(struct sockaddr )) * 64UL] ;
  char temp[128] ;
  struct sockaddr *hwa ;
  struct iw_quality *qual ;
  iwrange range ;
  int has_range ;
  int has_qual ;
  int n ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 1612
  has_range = 0;
#line 1613
  has_qual = 0;
#line 1618
  args = args;
#line 1618
  count = count;
#line 1621
  wrq.u.data.pointer = (void *)(buffer);
#line 1622
  wrq.u.data.length = (__u16 )64;
#line 1623
  wrq.u.data.flags = (__u16 )0;
#line 1624
  tmp = iw_set_ext(skfd, (char const   *)ifname, 35607, & wrq);
  }
#line 1624
  if (tmp < 0) {
    {
#line 1626
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  Interface doesn\'t have a list of Peers/Access-Points\n\n",
            ifname);
    }
#line 1627
    return (-1);
  }
  {
#line 1631
  n = (int )wrq.u.data.length;
#line 1632
  has_qual = (int )wrq.u.data.flags;
#line 1635
  hwa = (struct sockaddr *)(buffer);
#line 1636
  qual = (struct iw_quality *)(buffer + sizeof(struct sockaddr ) * (unsigned long )n);
#line 1639
  tmp___0 = iw_check_mac_addr_type(skfd, (char const   *)ifname);
  }
#line 1639
  if (tmp___0 < 0) {
    {
#line 1641
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  Interface doesn\'t support MAC addresses\n\n",
            ifname);
    }
#line 1642
    return (-2);
  }
  {
#line 1646
  tmp___1 = iw_get_range_info(skfd, (char const   *)ifname, & range);
  }
#line 1646
  if (tmp___1 >= 0) {
#line 1647
    has_range = 1;
  }
#line 1650
  if (n == 0) {
    {
#line 1651
    printf((char const   */* __restrict  */)"%-8.16s  No Peers/Access-Point in range\n",
           ifname);
    }
  } else {
    {
#line 1653
    printf((char const   */* __restrict  */)"%-8.16s  Peers/Access-Points in range:\n",
           ifname);
    }
  }
#line 1654
  i = 0;
  {
#line 1654
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1654
    if (! (i < n)) {
#line 1654
      goto while_break;
    }
#line 1656
    if (has_qual) {
      {
#line 1659
      tmp___2 = iw_saether_ntop((struct sockaddr  const  *)(hwa + i), temp);
#line 1659
      printf((char const   */* __restrict  */)"    %s : ", tmp___2);
#line 1660
      iw_print_stats(temp, (int )sizeof(buffer), (iwqual const   *)(qual + i), (iwrange const   *)(& range),
                     has_range);
#line 1661
      printf((char const   */* __restrict  */)"%s\n", temp);
      }
    } else {
      {
#line 1665
      tmp___3 = iw_saether_ntop((struct sockaddr  const  *)(hwa + i), temp);
#line 1665
      printf((char const   */* __restrict  */)"    %s\n", tmp___3);
      }
    }
#line 1654
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1667
  printf((char const   */* __restrict  */)"\n");
  }
#line 1668
  return (0);
}
}
#line 1673 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlist.c"
static char const   *event_capa_req[46]  = 
#line 1673
  {      (char const   *)0,      (char const   *)0,      "Set NWID (kernel generated)",      (char const   *)0, 
        "Set Frequency/Channel (kernel generated)",      "New Frequency/Channel",      "Set Mode (kernel generated)",      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      "Spy threshold crossed", 
        (char const   *)0,      "New Access Point/Cell address - roaming",      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      "Scan request completed",      "Set ESSID (kernel generated)",      "New ESSID", 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      "New bit-rate",      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      "Set Encoding (kernel generated)",      (char const   *)0, 
        (char const   *)0,      (char const   *)((void *)0)};
#line 1689 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlist.c"
static char const   *event_capa_evt[5]  = {      "Tx packet dropped - retry exceeded",      (char const   *)0,      "Custom driver event",      "Registered node", 
        "Expired node"};
#line 1697 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlist.c"
static struct iwmask_name  const  iw_scan_capa_name[7]  = {      {1U, "ESSID"}, 
        {2U, "BSSID"}, 
        {4U, "Channel"}, 
        {8U, "Mode"}, 
        {16U, "Rate"}, 
        {32U, "Type"}, 
        {64U, "Time"}};
#line 1712 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlist.c"
static int print_event_capa_info(int skfd , char *ifname , char **args , int count ) 
{ 
  struct iw_range range ;
  int cmd ;
  int idx ;
  int tmp ;
  int mask ;
  int tmp___0 ;
  int idx___0 ;
  int tmp___1 ;
  int mask___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1722
  args = args;
#line 1722
  count = count;
#line 1725
  tmp___3 = iw_get_range_info(skfd, (char const   *)ifname, & range);
  }
#line 1725
  if (tmp___3 < 0) {
    {
#line 1727
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  no wireless event capability information.\n\n",
            ifname);
    }
  } else
#line 1725
  if ((int )range.we_version_compiled < 10) {
    {
#line 1727
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  no wireless event capability information.\n\n",
            ifname);
    }
  } else {
    {
#line 1741
    printf((char const   */* __restrict  */)"%-8.16s  Wireless Events supported :\n",
           ifname);
#line 1743
    cmd = 35584;
    }
    {
#line 1743
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1743
      if (! (cmd <= 35629)) {
#line 1743
        goto while_break;
      }
#line 1745
      if (cmd >= 35808) {
#line 1745
        tmp = (cmd - 35808) + 96;
      } else {
#line 1745
        tmp = cmd - 35584;
      }
#line 1745
      idx = tmp >> 5;
#line 1746
      if (cmd >= 35808) {
#line 1746
        tmp___0 = (cmd - 35808) + 96;
      } else {
#line 1746
        tmp___0 = cmd - 35584;
      }
#line 1746
      mask = 1 << (tmp___0 & 31);
#line 1747
      if (range.event_capa[idx] & (unsigned int )mask) {
        {
#line 1748
        printf((char const   */* __restrict  */)"          0x%04X : %s\n", cmd, event_capa_req[cmd - 35584]);
        }
      }
#line 1743
      cmd ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1751
    cmd = 35840;
    {
#line 1751
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1751
      if (! (cmd <= 35844)) {
#line 1751
        goto while_break___0;
      }
#line 1753
      if (cmd >= 35808) {
#line 1753
        tmp___1 = (cmd - 35808) + 96;
      } else {
#line 1753
        tmp___1 = cmd - 35584;
      }
#line 1753
      idx___0 = tmp___1 >> 5;
#line 1754
      if (cmd >= 35808) {
#line 1754
        tmp___2 = (cmd - 35808) + 96;
      } else {
#line 1754
        tmp___2 = cmd - 35584;
      }
#line 1754
      mask___0 = 1 << (tmp___2 & 31);
#line 1755
      if (range.event_capa[idx___0] & (unsigned int )mask___0) {
        {
#line 1756
        printf((char const   */* __restrict  */)"          0x%04X : %s\n", cmd, event_capa_evt[cmd - 35840]);
        }
      }
#line 1751
      cmd ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1759
    printf((char const   */* __restrict  */)"\n");
    }
#line 1762
    if ((int )range.scan_capa != 0) {
      {
#line 1764
      printf((char const   */* __restrict  */)"%-8.16s  Scanning capabilities :",
             ifname);
#line 1765
      iw_print_mask_name((unsigned int )range.scan_capa, iw_scan_capa_name, (unsigned int const   )(sizeof(iw_scan_capa_name) / sizeof(iw_scan_capa_name[0])),
                         "\n\t\t- ");
#line 1768
      printf((char const   */* __restrict  */)"\n\n");
      }
    }
  }
#line 1771
  return (0);
}
}
#line 1780 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlist.c"
static int print_auth_info(int skfd , char *ifname , char **args , int count ) 
{ 
  struct iwreq wrq ;
  struct iw_range range ;
  unsigned int k ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1791
  args = args;
#line 1791
  count = count;
#line 1794
  tmp___1 = iw_get_range_info(skfd, (char const   *)ifname, & range);
  }
#line 1794
  if (tmp___1 < 0) {
    {
#line 1796
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  no authentication information.\n\n",
            ifname);
    }
  } else
#line 1794
  if ((int )range.we_version_compiled < 18) {
    {
#line 1796
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  no authentication information.\n\n",
            ifname);
    }
  } else {
#line 1801
    if (! range.enc_capa) {
      {
#line 1803
      printf((char const   */* __restrict  */)"%-8.16s  unknown authentication information.\n\n",
             ifname);
      }
    } else {
      {
#line 1808
      printf((char const   */* __restrict  */)"%-8.16s  Authentication capabilities :",
             ifname);
#line 1809
      iw_print_mask_name(range.enc_capa, iw_auth_capa_name, (unsigned int const   )(sizeof(iw_auth_capa_name) / sizeof(iw_auth_capa_name[0])),
                         "\n\t\t");
#line 1812
      printf((char const   */* __restrict  */)"\n");
#line 1815
      k = 0U;
      }
      {
#line 1815
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1815
        if (! ((unsigned long )k < sizeof(iw_auth_settings) / sizeof(iw_auth_settings[0]))) {
#line 1815
          goto while_break;
        }
        {
#line 1817
        wrq.u.param.flags = (__u16 )iw_auth_settings[k].value;
#line 1818
        tmp___0 = iw_set_ext(skfd, (char const   *)ifname, 35635, & wrq);
        }
#line 1818
        if (tmp___0 >= 0) {
          {
#line 1820
          printf((char const   */* __restrict  */)"          Current %s :", iw_auth_settings[k].label);
          }
#line 1821
          if ((unsigned long )iw_auth_settings[k].names != (unsigned long )((void *)0)) {
            {
#line 1822
            iw_print_mask_name((unsigned int )wrq.u.param.value, (struct iwmask_name  const  *)iw_auth_settings[k].names,
                               (unsigned int const   )iw_auth_settings[k].num_names,
                               "\n\t\t");
            }
          } else {
#line 1827
            if (wrq.u.param.value) {
#line 1827
              tmp = " yes";
            } else {
#line 1827
              tmp = " no";
            }
            {
#line 1827
            printf((char const   */* __restrict  */)tmp);
            }
          }
          {
#line 1828
          printf((char const   */* __restrict  */)"\n");
          }
        }
#line 1815
        k ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 1833
    printf((char const   */* __restrict  */)"\n\n");
    }
  }
#line 1835
  return (0);
}
}
#line 1842 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlist.c"
static int print_wpakeys_info(int skfd , char *ifname , char **args , int count ) 
{ 
  struct iwreq wrq ;
  struct iw_range range ;
  unsigned char extbuf[sizeof(struct iw_encode_ext ) + 64UL] ;
  struct iw_encode_ext *extinfo ;
  unsigned int k ;
  char buffer[128] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 1856
  args = args;
#line 1856
  count = count;
#line 1859
  extinfo = (struct iw_encode_ext *)(extbuf);
#line 1862
  tmp___4 = iw_get_range_info(skfd, (char const   *)ifname, & range);
  }
#line 1862
  if (tmp___4 < 0) {
    {
#line 1863
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  no wpa key information.\n\n",
            ifname);
    }
  } else {
    {
#line 1867
    printf((char const   */* __restrict  */)"%-8.16s  ", ifname);
    }
#line 1869
    if ((int )range.num_encoding_sizes > 0) {
#line 1869
      if ((int )range.num_encoding_sizes < 8) {
        {
#line 1872
        printf((char const   */* __restrict  */)"%d key sizes : %d", (int )range.num_encoding_sizes,
               (int )range.encoding_size[0] * 8);
#line 1875
        k = 1U;
        }
        {
#line 1875
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1875
          if (! (k < (unsigned int )range.num_encoding_sizes)) {
#line 1875
            goto while_break;
          }
          {
#line 1876
          printf((char const   */* __restrict  */)", %d", (int )range.encoding_size[k] * 8);
#line 1875
          k ++;
          }
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 1877
        printf((char const   */* __restrict  */)"bits\n          ");
        }
      }
    }
    {
#line 1881
    printf((char const   */* __restrict  */)"%d keys available :\n", (int )range.max_encoding_tokens);
#line 1882
    k = 1U;
    }
    {
#line 1882
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1882
      if (! (k <= (unsigned int )range.max_encoding_tokens)) {
#line 1882
        goto while_break___0;
      }
      {
#line 1885
      memset((void *)(extbuf), '\000', sizeof(struct iw_encode_ext ) + 64UL);
#line 1888
      wrq.u.data.pointer = (void *)((caddr_t )(extbuf));
#line 1889
      wrq.u.data.length = (__u16 )(sizeof(struct iw_encode_ext ) + 64UL);
#line 1890
      wrq.u.data.flags = (__u16 )k;
#line 1891
      tmp___1 = iw_set_ext(skfd, (char const   *)ifname, 35637, & wrq);
      }
#line 1891
      if (tmp___1 < 0) {
        {
#line 1893
        tmp = __errno_location();
#line 1893
        tmp___0 = strerror(*tmp);
#line 1893
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error reading wpa keys (SIOCGIWENCODEEXT): %s\n",
                tmp___0);
        }
#line 1894
        goto while_break___0;
      }
#line 1898
      if ((unsigned long )wrq.u.data.length < sizeof(struct iw_encode_ext ) + (unsigned long )extinfo->key_len) {
#line 1900
        goto while_break___0;
      }
#line 1903
      if ((int )wrq.u.data.flags & 32768) {
        {
#line 1905
        printf((char const   */* __restrict  */)"\t\t[%d]: off\n", k);
        }
      } else
#line 1903
      if ((int )extinfo->key_len == 0) {
        {
#line 1905
        printf((char const   */* __restrict  */)"\t\t[%d]: off\n", k);
        }
      } else {
        {
#line 1909
        iw_print_key(buffer, (int )sizeof(buffer), (unsigned char const   *)(extinfo->key),
                     (int )extinfo->key_len, (int )wrq.u.data.flags);
#line 1911
        printf((char const   */* __restrict  */)"\t\t[%d]: %s", k, buffer);
#line 1914
        printf((char const   */* __restrict  */)" (%d bits)", (int )extinfo->key_len * 8);
#line 1915
        printf((char const   */* __restrict  */)"\n");
#line 1918
        tmp___2 = iw_saether_ntop((struct sockaddr  const  *)(& extinfo->addr), buffer);
#line 1918
        printf((char const   */* __restrict  */)"\t\t     Address: %s\n", tmp___2);
#line 1921
        printf((char const   */* __restrict  */)"\t\t     Algorithm:");
#line 1922
        iw_print_value_name((unsigned int )extinfo->alg, iw_encode_alg_name, (unsigned int const   )(sizeof(iw_encode_alg_name) / sizeof(iw_encode_alg_name[0])));
#line 1925
        printf((char const   */* __restrict  */)"\n\t\t     Flags: 0x%08x\n", extinfo->ext_flags);
        }
#line 1926
        if (extinfo->ext_flags & 1U) {
          {
#line 1927
          printf((char const   */* __restrict  */)"\t\t        tx-seq-valid\n");
          }
        }
#line 1928
        if (extinfo->ext_flags & 2U) {
          {
#line 1929
          printf((char const   */* __restrict  */)"\t\t        rx-seq-valid\n");
          }
        }
#line 1930
        if (extinfo->ext_flags & 4U) {
          {
#line 1931
          printf((char const   */* __restrict  */)"\t\t        group-key\n");
          }
        }
      }
#line 1882
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1935
    wrq.u.data.pointer = (void *)((caddr_t )(extbuf));
#line 1936
    wrq.u.data.length = (__u16 )(sizeof(struct iw_encode_ext ) + 64UL);
#line 1937
    wrq.u.data.flags = (__u16 )0;
#line 1938
    tmp___3 = iw_set_ext(skfd, (char const   *)ifname, 35637, & wrq);
    }
#line 1938
    if (tmp___3 >= 0) {
      {
#line 1942
      printf((char const   */* __restrict  */)"          Current Transmit Key: [%d]\n",
             (int )wrq.u.data.flags & 255);
      }
#line 1944
      if ((int )wrq.u.data.flags & 16384) {
        {
#line 1945
        printf((char const   */* __restrict  */)"          Security mode:restricted\n");
        }
      }
#line 1946
      if ((int )wrq.u.data.flags & 8192) {
        {
#line 1947
        printf((char const   */* __restrict  */)"          Security mode:open\n");
        }
      }
    }
    {
#line 1950
    printf((char const   */* __restrict  */)"\n\n");
    }
  }
#line 1952
  return (0);
}
}
#line 1960 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlist.c"
static int print_gen_ie_info(int skfd , char *ifname , char **args , int count ) 
{ 
  struct iwreq wrq ;
  unsigned char buf[1024] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1970
  args = args;
#line 1970
  count = count;
#line 1972
  wrq.u.data.pointer = (void *)((caddr_t )(buf));
#line 1973
  wrq.u.data.length = (__u16 )1024;
#line 1974
  wrq.u.data.flags = (__u16 )0;
#line 1976
  tmp___1 = iw_set_ext(skfd, (char const   *)ifname, 35633, & wrq);
  }
#line 1976
  if (tmp___1 < 0) {
    {
#line 1977
    tmp = __errno_location();
#line 1977
    tmp___0 = strerror(*tmp);
#line 1977
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  no generic IE (%s).\n\n",
            ifname, tmp___0);
    }
  } else {
    {
#line 1981
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s\n",
            ifname);
    }
#line 1982
    if ((int )wrq.u.data.length == 0) {
      {
#line 1983
      printf((char const   */* __restrict  */)"          empty generic IE\n");
      }
    } else {
      {
#line 1985
      iw_print_gen_ie(buf, (int )wrq.u.data.length);
      }
    }
    {
#line 1986
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 1988
  return (0);
}
}
#line 1997 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlist.c"
static int print_modul_info(int skfd , char *ifname , char **args , int count ) 
{ 
  struct iwreq wrq ;
  struct iw_range range ;
  int i ;
  unsigned int modul ;
  int n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 2007
  args = args;
#line 2007
  count = count;
#line 2010
  tmp___2 = iw_get_range_info(skfd, (char const   *)ifname, & range);
  }
#line 2010
  if (tmp___2 < 0) {
    {
#line 2012
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  no modulation information.\n\n",
            ifname);
    }
  } else
#line 2010
  if ((int )range.we_version_compiled < 11) {
    {
#line 2012
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  no modulation information.\n\n",
            ifname);
    }
  } else
#line 2016
  if (range.modul_capa == 0) {
    {
#line 2017
    printf((char const   */* __restrict  */)"%-8.16s  unknown modulation information.\n\n",
           ifname);
    }
  } else {
    {
#line 2021
    printf((char const   */* __restrict  */)"%-8.16s  Modulations available :\n",
           ifname);
#line 2024
    i = 0;
    }
    {
#line 2024
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2024
      if (! (i < 16)) {
#line 2024
        goto while_break;
      }
#line 2026
      if (((unsigned int const   )range.modul_capa & iw_modul_list[i].mask) == iw_modul_list[i].mask) {
        {
#line 2028
        printf((char const   */* __restrict  */)"              %-8s: %s\n", iw_modul_list[i].cmd,
               iw_modul_list[i].verbose);
        }
      }
#line 2024
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2033
    wrq.u.param.flags = (__u16 )0;
#line 2034
    tmp___1 = iw_set_ext(skfd, (char const   *)ifname, 35631, & wrq);
    }
#line 2034
    if (tmp___1 >= 0) {
#line 2036
      modul = (unsigned int )wrq.u.param.value;
#line 2037
      n = 0;
#line 2039
      if (wrq.u.param.fixed) {
#line 2039
        tmp = '=';
      } else {
#line 2039
        tmp = ':';
      }
      {
#line 2039
      printf((char const   */* __restrict  */)"          Current modulations %c",
             tmp);
#line 2043
      i = 0;
      }
      {
#line 2043
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2043
        if (! (i < 16)) {
#line 2043
          goto while_break___0;
        }
#line 2045
        if ((modul & (unsigned int )iw_modul_list[i].mask) == (unsigned int )iw_modul_list[i].mask) {
#line 2047
          tmp___0 = n;
#line 2047
          n ++;
#line 2047
          if (tmp___0 % 8 == 0) {
            {
#line 2048
            printf((char const   */* __restrict  */)"\n              ");
            }
          } else {
            {
#line 2050
            printf((char const   */* __restrict  */)" ; ");
            }
          }
          {
#line 2051
          printf((char const   */* __restrict  */)"%s", iw_modul_list[i].cmd);
          }
        }
#line 2043
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 2055
      printf((char const   */* __restrict  */)"\n");
      }
    }
    {
#line 2057
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 2060
  return (0);
}
}
#line 2081 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlist.c"
static struct iwlist_entry  const  iwlist_cmds[19]  = 
#line 2081
  {      {"scanning", & print_scanning_info, -1, "[essid NNN] [last]"}, 
        {"frequency", & print_freq_info, 0, (char const   *)((void *)0)}, 
        {"channel", & print_freq_info, 0, (char const   *)((void *)0)}, 
        {"bitrate", & print_bitrate_info, 0, (char const   *)((void *)0)}, 
        {"rate", & print_bitrate_info, 0, (char const   *)((void *)0)}, 
        {"encryption", & print_keys_info, 0, (char const   *)((void *)0)}, 
        {"keys", & print_keys_info, 0, (char const   *)((void *)0)}, 
        {"power", & print_pm_info, 0, (char const   *)((void *)0)}, 
        {"txpower", & print_txpower_info, 0, (char const   *)((void *)0)}, 
        {"retry", & print_retry_info, 0, (char const   *)((void *)0)}, 
        {"ap", & print_ap_info, 0, (char const   *)((void *)0)}, 
        {"accesspoints", & print_ap_info, 0, (char const   *)((void *)0)}, 
        {"peers", & print_ap_info, 0, (char const   *)((void *)0)}, 
        {"event", & print_event_capa_info, 0, (char const   *)((void *)0)}, 
        {"auth", & print_auth_info, 0, (char const   *)((void *)0)}, 
        {"wpakeys", & print_wpakeys_info, 0, (char const   *)((void *)0)}, 
        {"genie", & print_gen_ie_info, 0, (char const   *)((void *)0)}, 
        {"modulation", & print_modul_info, 0, (char const   *)((void *)0)}, 
        {(char const   *)((void *)0), (int (*)(int skfd , char *ifname , char **args ,
                                            int count ))((void *)0), 0, (char const   *)0}};
#line 2109 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlist.c"
__inline static iwlist_cmd const   *( __attribute__((__always_inline__)) find_command)(char const   *cmd ) 
{ 
  iwlist_cmd const   *found ;
  int ambig ;
  unsigned int len ;
  size_t tmp ;
  int i ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 2112
  found = (iwlist_cmd const   *)((void *)0);
#line 2113
  ambig = 0;
#line 2114
  tmp = strlen(cmd);
#line 2114
  len = (unsigned int )tmp;
#line 2118
  i = 0;
  }
  {
#line 2118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2118
    if (! ((unsigned long )iwlist_cmds[i].cmd != (unsigned long )((void *)0))) {
#line 2118
      goto while_break;
    }
    {
#line 2121
    tmp___0 = strncasecmp((char const   *)iwlist_cmds[i].cmd, cmd, (size_t )len);
    }
#line 2121
    if (tmp___0 != 0) {
#line 2122
      goto __Cont;
    }
    {
#line 2125
    tmp___1 = strlen((char const   *)iwlist_cmds[i].cmd);
    }
#line 2125
    if ((size_t )len == tmp___1) {
#line 2126
      return (& iwlist_cmds[i]);
    }
#line 2129
    if ((unsigned long )found == (unsigned long )((void *)0)) {
#line 2131
      found = & iwlist_cmds[i];
    } else
#line 2134
    if ((unsigned long )iwlist_cmds[i].fn != (unsigned long )found->fn) {
#line 2135
      ambig = 1;
    }
    __Cont: /* CIL Label */ 
#line 2118
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2138
  if ((unsigned long )found == (unsigned long )((void *)0)) {
    {
#line 2140
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"iwlist: unknown command `%s\' (check \'iwlist --help\').\n",
            cmd);
    }
#line 2141
    return ((iwlist_cmd const   *)((void *)0));
  }
#line 2144
  if (ambig) {
    {
#line 2146
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"iwlist: command `%s\' is ambiguous (check \'iwlist --help\').\n",
            cmd);
    }
#line 2147
    return ((iwlist_cmd const   *)((void *)0));
  }
#line 2150
  return (found);
}
}
#line 2157 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlist.c"
static void iw_usage___2(int status ) 
{ 
  FILE *f ;
  struct _IO_FILE *tmp ;
  int i ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 2159
  if (status) {
#line 2159
    tmp = stderr;
  } else {
#line 2159
    tmp = stdout;
  }
#line 2159
  f = tmp;
#line 2162
  i = 0;
  {
#line 2162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2162
    if (! ((unsigned long )iwlist_cmds[i].cmd != (unsigned long )((void *)0))) {
#line 2162
      goto while_break;
    }
#line 2164
    if (iwlist_cmds[i].argsname) {
#line 2164
      tmp___0 = iwlist_cmds[i].argsname;
    } else {
#line 2164
      tmp___0 = (char const   */* const  */)"";
    }
#line 2164
    if (i) {
#line 2164
      tmp___1 = "             ";
    } else {
#line 2164
      tmp___1 = "Usage: iwlist";
    }
    {
#line 2164
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s [interface] %s %s\n",
            tmp___1, iwlist_cmds[i].cmd, tmp___0);
#line 2162
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2170
  exit(status);
  }
}
}
#line 164 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) strtod)(char const   * __restrict  __nptr ,
                                                                                                char ** __restrict  __endptr ) ;
#line 534 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 139 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib-private.h"
__inline static void ( __attribute__((__always_inline__)) iw_broad_ether)(struct sockaddr *sap ) 
{ 


  {
  {
#line 142
  sap->sa_family = (sa_family_t )1;
#line 143
  memset((void *)(sap->sa_data), 255, (size_t )6);
  }
#line 144
  return;
}
}
#line 150 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib-private.h"
__inline static void ( __attribute__((__always_inline__)) iw_null_ether)(struct sockaddr *sap ) 
{ 


  {
  {
#line 153
  sap->sa_family = (sa_family_t )1;
#line 154
  memset((void *)(sap->sa_data), 0, (size_t )6);
  }
#line 155
  return;
}
}
#line 33 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwconfig.c"
static int errarg  ;
#line 34 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwconfig.c"
static int errmax  ;
#line 44 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwconfig.c"
static int get_info(int skfd , char *ifname , struct wireless_info *info ) 
{ 
  struct iwreq wrq ;
  struct ifreq ifr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  {
#line 51
  memset((void *)((char *)info), 0, sizeof(struct wireless_info ));
#line 54
  tmp___0 = iw_get_basic_config(skfd, (char const   *)ifname, & info->b);
  }
#line 54
  if (tmp___0 < 0) {
    {
#line 60
    strncpy((char */* __restrict  */)(ifr.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)ifname,
            (size_t )16);
#line 61
    tmp = ioctl(skfd, 35091UL, & ifr);
    }
#line 61
    if (tmp < 0) {
#line 62
      return (-19);
    } else {
#line 64
      return (-95);
    }
  }
  {
#line 68
  tmp___1 = iw_get_range_info(skfd, (char const   *)ifname, & info->range);
  }
#line 68
  if (tmp___1 >= 0) {
#line 69
    info->has_range = 1;
  }
  {
#line 72
  tmp___2 = iw_set_ext(skfd, (char const   *)ifname, 35605, & wrq);
  }
#line 72
  if (tmp___2 >= 0) {
    {
#line 74
    info->has_ap_addr = 1;
#line 75
    memcpy((void */* __restrict  */)(& info->ap_addr), (void const   */* __restrict  */)(& wrq.u.ap_addr),
           sizeof(sockaddr ));
    }
  }
  {
#line 79
  tmp___3 = iw_set_ext(skfd, (char const   *)ifname, 35617, & wrq);
  }
#line 79
  if (tmp___3 >= 0) {
    {
#line 81
    info->has_bitrate = 1;
#line 82
    memcpy((void */* __restrict  */)(& info->bitrate), (void const   */* __restrict  */)(& wrq.u.bitrate),
           sizeof(iwparam ));
    }
  }
  {
#line 86
  wrq.u.power.flags = (__u16 )0;
#line 87
  tmp___4 = iw_set_ext(skfd, (char const   *)ifname, 35629, & wrq);
  }
#line 87
  if (tmp___4 >= 0) {
    {
#line 89
    info->has_power = 1;
#line 90
    memcpy((void */* __restrict  */)(& info->power), (void const   */* __restrict  */)(& wrq.u.power),
           sizeof(iwparam ));
    }
  }
  {
#line 94
  tmp___5 = iw_get_stats(skfd, (char const   *)ifname, & info->stats, (iwrange const   *)(& info->range),
                         info->has_range);
  }
#line 94
  if (tmp___5 >= 0) {
#line 97
    info->has_stats = 1;
  }
  {
#line 102
  wrq.u.essid.pointer = (void *)(info->nickname);
#line 103
  wrq.u.essid.length = (__u16 )34;
#line 104
  wrq.u.essid.flags = (__u16 )0;
#line 105
  tmp___6 = iw_set_ext(skfd, (char const   *)ifname, 35613, & wrq);
  }
#line 105
  if (tmp___6 >= 0) {
#line 106
    if ((int )wrq.u.data.length > 1) {
#line 107
      info->has_nickname = 1;
    }
  }
#line 109
  if (info->has_range) {
#line 109
    if ((int )info->range.we_version_compiled > 9) {
      {
#line 112
      tmp___7 = iw_set_ext(skfd, (char const   *)ifname, 35623, & wrq);
      }
#line 112
      if (tmp___7 >= 0) {
        {
#line 114
        info->has_txpower = 1;
#line 115
        memcpy((void */* __restrict  */)(& info->txpower), (void const   */* __restrict  */)(& wrq.u.txpower),
               sizeof(iwparam ));
        }
      }
    }
  }
  {
#line 120
  tmp___8 = iw_set_ext(skfd, (char const   *)ifname, 35593, & wrq);
  }
#line 120
  if (tmp___8 >= 0) {
    {
#line 122
    info->has_sens = 1;
#line 123
    memcpy((void */* __restrict  */)(& info->sens), (void const   */* __restrict  */)(& wrq.u.sens),
           sizeof(iwparam ));
    }
  }
#line 126
  if (info->has_range) {
#line 126
    if ((int )info->range.we_version_compiled > 10) {
      {
#line 129
      tmp___9 = iw_set_ext(skfd, (char const   *)ifname, 35625, & wrq);
      }
#line 129
      if (tmp___9 >= 0) {
        {
#line 131
        info->has_retry = 1;
#line 132
        memcpy((void */* __restrict  */)(& info->retry), (void const   */* __restrict  */)(& wrq.u.retry),
               sizeof(iwparam ));
        }
      }
    }
  }
  {
#line 137
  tmp___10 = iw_set_ext(skfd, (char const   *)ifname, 35619, & wrq);
  }
#line 137
  if (tmp___10 >= 0) {
    {
#line 139
    info->has_rts = 1;
#line 140
    memcpy((void */* __restrict  */)(& info->rts), (void const   */* __restrict  */)(& wrq.u.rts),
           sizeof(iwparam ));
    }
  }
  {
#line 144
  tmp___11 = iw_set_ext(skfd, (char const   *)ifname, 35621, & wrq);
  }
#line 144
  if (tmp___11 >= 0) {
    {
#line 146
    info->has_frag = 1;
#line 147
    memcpy((void */* __restrict  */)(& info->frag), (void const   */* __restrict  */)(& wrq.u.frag),
           sizeof(iwparam ));
    }
  }
#line 151
  return (0);
}
}
#line 159 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwconfig.c"
static void display_info(struct wireless_info *info , char *ifname ) 
{ 
  char buffer[256] ;
  int tokens ;
  double freq ;
  int channel ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 166
  tokens = 3;
#line 169
  printf((char const   */* __restrict  */)"%-8.16s  %s  ", ifname, info->b.name);
  }
#line 172
  if (info->b.has_essid) {
#line 174
    if (info->b.essid_on) {
      {
#line 177
      iw_essid_escape(buffer, (char const   *)(info->b.essid), (int const   )info->b.essid_len);
      }
#line 179
      if ((info->b.essid_on & 255) > 1) {
        {
#line 180
        printf((char const   */* __restrict  */)"ESSID:\"%s\" [%d]  ", buffer, info->b.essid_on & 255);
        }
      } else {
        {
#line 183
        printf((char const   */* __restrict  */)"ESSID:\"%s\"  ", buffer);
        }
      }
    } else {
      {
#line 186
      printf((char const   */* __restrict  */)"ESSID:off/any  ");
      }
    }
  }
#line 191
  if (info->has_nickname) {
    {
#line 192
    printf((char const   */* __restrict  */)"Nickname:\"%s\"", info->nickname);
    }
  }
#line 196
  if (info->b.has_essid) {
    {
#line 198
    printf((char const   */* __restrict  */)"\n          ");
#line 199
    tokens = 0;
    }
  } else
#line 196
  if (info->has_nickname) {
    {
#line 198
    printf((char const   */* __restrict  */)"\n          ");
#line 199
    tokens = 0;
    }
  }
#line 204
  if (info->b.has_nwid) {
#line 208
    if (info->b.nwid.disabled) {
      {
#line 209
      printf((char const   */* __restrict  */)"NWID:off/any  ");
      }
    } else {
      {
#line 211
      printf((char const   */* __restrict  */)"NWID:%X  ", info->b.nwid.value);
      }
    }
#line 212
    tokens += 2;
  }
#line 217
  if (info->b.has_mode) {
    {
#line 219
    printf((char const   */* __restrict  */)"Mode:%s  ", iw_operation_mode[info->b.mode]);
#line 220
    tokens += 3;
    }
  }
#line 224
  if (info->b.has_freq) {
#line 226
    freq = info->b.freq;
#line 227
    channel = -1;
#line 231
    if (info->has_range) {
#line 231
      if (freq < 1e3) {
        {
#line 232
        channel = iw_channel_to_freq((int )freq, & freq, (struct iw_range  const  *)(& info->range));
        }
      }
    }
    {
#line 234
    iw_print_freq(buffer, (int )sizeof(buffer), freq, -1, info->b.freq_flags);
#line 235
    printf((char const   */* __restrict  */)"%s  ", buffer);
#line 236
    tokens += 4;
    }
  }
#line 240
  if (info->has_ap_addr) {
#line 243
    if (tokens > 8) {
      {
#line 245
      printf((char const   */* __restrict  */)"\n          ");
#line 246
      tokens = 0;
      }
    }
#line 248
    tokens += 6;
#line 251
    if (info->b.has_mode) {
#line 251
      if (info->b.mode == 1) {
        {
#line 252
        printf((char const   */* __restrict  */)"Cell:");
        }
      } else {
        {
#line 254
        printf((char const   */* __restrict  */)"Access Point:");
        }
      }
    } else {
      {
#line 254
      printf((char const   */* __restrict  */)"Access Point:");
      }
    }
    {
#line 255
    tmp = iw_sawap_ntop((struct sockaddr  const  *)(& info->ap_addr), buffer);
#line 255
    printf((char const   */* __restrict  */)" %s   ", tmp);
    }
  }
#line 259
  if (info->has_bitrate) {
#line 262
    if (tokens > 11) {
      {
#line 264
      printf((char const   */* __restrict  */)"\n          ");
#line 265
      tokens = 0;
      }
    }
    {
#line 267
    tokens += 3;
#line 270
    iw_print_bitrate(buffer, (int )sizeof(buffer), info->bitrate.value);
    }
#line 271
    if (info->bitrate.fixed) {
#line 271
      tmp___0 = '=';
    } else {
#line 271
      tmp___0 = ':';
    }
    {
#line 271
    printf((char const   */* __restrict  */)"Bit Rate%c%s   ", tmp___0, buffer);
    }
  }
#line 276
  if (info->has_txpower) {
#line 279
    if (tokens > 11) {
      {
#line 281
      printf((char const   */* __restrict  */)"\n          ");
#line 282
      tokens = 0;
      }
    }
    {
#line 284
    tokens += 3;
#line 287
    iw_print_txpower(buffer, (int )sizeof(buffer), & info->txpower);
    }
#line 288
    if (info->txpower.fixed) {
#line 288
      tmp___1 = '=';
    } else {
#line 288
      tmp___1 = ':';
    }
    {
#line 288
    printf((char const   */* __restrict  */)"Tx-Power%c%s   ", tmp___1, buffer);
    }
  }
#line 292
  if (info->has_sens) {
#line 295
    if (tokens > 10) {
      {
#line 297
      printf((char const   */* __restrict  */)"\n          ");
#line 298
      tokens = 0;
      }
    }
#line 300
    tokens += 4;
#line 303
    if (info->sens.fixed) {
#line 303
      tmp___2 = '=';
    } else {
#line 303
      tmp___2 = ':';
    }
    {
#line 303
    printf((char const   */* __restrict  */)"Sensitivity%c", tmp___2);
    }
#line 305
    if (info->has_range) {
#line 307
      if (info->sens.value < 0) {
        {
#line 308
        printf((char const   */* __restrict  */)"%d dBm  ", info->sens.value);
        }
      } else {
        {
#line 310
        printf((char const   */* __restrict  */)"%d/%d  ", info->sens.value, info->range.sensitivity);
        }
      }
    } else {
      {
#line 312
      printf((char const   */* __restrict  */)"%d  ", info->sens.value);
      }
    }
  }
  {
#line 316
  printf((char const   */* __restrict  */)"\n          ");
#line 317
  tokens = 0;
  }
#line 321
  if (info->has_retry) {
    {
#line 323
    printf((char const   */* __restrict  */)"Retry");
    }
#line 325
    if (info->retry.disabled) {
      {
#line 326
      printf((char const   */* __restrict  */)":off");
      }
    } else {
#line 330
      if ((int )info->retry.flags & 61440) {
        {
#line 332
        iw_print_retry_value(buffer, (int )sizeof(buffer), info->retry.value, (int )info->retry.flags,
                             (int )info->range.we_version_compiled);
#line 335
        printf((char const   */* __restrict  */)"%s", buffer);
        }
      }
#line 339
      if ((int )info->retry.flags == 0) {
        {
#line 340
        printf((char const   */* __restrict  */)":on");
        }
      }
    }
    {
#line 342
    printf((char const   */* __restrict  */)"   ");
#line 343
    tokens += 5;
    }
  }
#line 347
  if (info->has_rts) {
#line 350
    if (info->rts.disabled) {
      {
#line 351
      printf((char const   */* __restrict  */)"RTS thr:off   ");
      }
    } else {
#line 355
      if (info->rts.fixed) {
#line 355
        tmp___3 = '=';
      } else {
#line 355
        tmp___3 = ':';
      }
      {
#line 355
      printf((char const   */* __restrict  */)"RTS thr%c%d B   ", tmp___3, info->rts.value);
      }
    }
#line 359
    tokens += 3;
  }
#line 363
  if (info->has_frag) {
#line 366
    if (tokens > 10) {
      {
#line 368
      printf((char const   */* __restrict  */)"\n          ");
#line 369
      tokens = 0;
      }
    }
#line 371
    tokens += 4;
#line 374
    if (info->frag.disabled) {
      {
#line 375
      printf((char const   */* __restrict  */)"Fragment thr:off");
      }
    } else {
#line 379
      if (info->frag.fixed) {
#line 379
        tmp___4 = '=';
      } else {
#line 379
        tmp___4 = ':';
      }
      {
#line 379
      printf((char const   */* __restrict  */)"Fragment thr%c%d B   ", tmp___4, info->frag.value);
      }
    }
  }
#line 386
  if (tokens > 0) {
    {
#line 387
    printf((char const   */* __restrict  */)"\n          ");
    }
  }
#line 392
  if (info->b.has_key) {
    {
#line 394
    printf((char const   */* __restrict  */)"Encryption key:");
    }
#line 395
    if (info->b.key_flags & 32768) {
      {
#line 396
      printf((char const   */* __restrict  */)"off");
      }
    } else
#line 395
    if (info->b.key_size == 0) {
      {
#line 396
      printf((char const   */* __restrict  */)"off");
      }
    } else {
      {
#line 400
      iw_print_key(buffer, (int )sizeof(buffer), (unsigned char const   *)(info->b.key),
                   info->b.key_size, info->b.key_flags);
#line 402
      printf((char const   */* __restrict  */)"%s", buffer);
      }
#line 405
      if ((info->b.key_flags & 255) > 1) {
        {
#line 406
        printf((char const   */* __restrict  */)" [%d]", info->b.key_flags & 255);
        }
      }
#line 407
      if (info->b.key_flags & 16384) {
        {
#line 408
        printf((char const   */* __restrict  */)"   Security mode:restricted");
        }
      }
#line 409
      if (info->b.key_flags & 8192) {
        {
#line 410
        printf((char const   */* __restrict  */)"   Security mode:open");
        }
      }
    }
    {
#line 412
    printf((char const   */* __restrict  */)"\n          ");
    }
  }
#line 418
  if (info->has_power) {
    {
#line 420
    printf((char const   */* __restrict  */)"Power Management");
    }
#line 422
    if (info->power.disabled) {
      {
#line 423
      printf((char const   */* __restrict  */)":off");
      }
    } else {
#line 427
      if ((int )info->power.flags & 61440) {
        {
#line 429
        iw_print_pm_value(buffer, (int )sizeof(buffer), info->power.value, (int )info->power.flags,
                          (int )info->range.we_version_compiled);
#line 432
        printf((char const   */* __restrict  */)"%s  ", buffer);
        }
      }
      {
#line 436
      iw_print_pm_mode(buffer, (int )sizeof(buffer), (int )info->power.flags);
#line 437
      printf((char const   */* __restrict  */)"%s", buffer);
      }
#line 440
      if ((int )info->power.flags == 0) {
        {
#line 441
        printf((char const   */* __restrict  */)":on");
        }
      }
    }
    {
#line 443
    printf((char const   */* __restrict  */)"\n          ");
    }
  }
#line 447
  if (info->has_stats) {
    {
#line 449
    iw_print_stats(buffer, (int )sizeof(buffer), (iwqual const   *)(& info->stats.qual),
                   (iwrange const   *)(& info->range), info->has_range);
#line 451
    printf((char const   */* __restrict  */)"Link %s\n", buffer);
    }
#line 453
    if ((int )info->range.we_version_compiled > 11) {
      {
#line 454
      printf((char const   */* __restrict  */)"          Rx invalid nwid:%d  Rx invalid crypt:%d  Rx invalid frag:%d\n          Tx excessive retries:%d  Invalid misc:%d   Missed beacon:%d\n",
             info->stats.discard.nwid, info->stats.discard.code, info->stats.discard.fragment,
             info->stats.discard.retries, info->stats.discard.misc, info->stats.miss.beacon);
      }
    } else {
      {
#line 462
      printf((char const   */* __restrict  */)"          Rx invalid nwid:%d  invalid crypt:%d  invalid misc:%d\n",
             info->stats.discard.nwid, info->stats.discard.code, info->stats.discard.misc);
      }
    }
  }
  {
#line 468
  printf((char const   */* __restrict  */)"\n");
  }
#line 469
  return;
}
}
#line 476 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwconfig.c"
static int print_info(int skfd , char *ifname , char **args , int count ) 
{ 
  struct wireless_info info ;
  int rc ;
  char *tmp ;

  {
  {
#line 486
  args = args;
#line 486
  count = count;
#line 488
  rc = get_info(skfd, ifname, & info);
  }
  {
#line 491
  if (rc == 0) {
#line 491
    goto case_0;
  }
#line 496
  if (rc == -95) {
#line 496
    goto case_neg_95;
  }
#line 501
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 493
  display_info(& info, ifname);
  }
#line 494
  goto switch_break;
  case_neg_95: /* CIL Label */ 
  {
#line 497
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  no wireless extensions.\n\n",
          ifname);
  }
#line 499
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 502
  tmp = strerror(- rc);
#line 502
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  %s\n\n",
          ifname, tmp);
  }
  switch_break: /* CIL Label */ ;
  }
#line 504
  return (rc);
}
}
#line 526 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwconfig.c"
static struct iwconfig_modifier  const  iwmod_power[5]  = {      {"min", (__u16 )1, (__u16 )2}, 
        {"max", (__u16 )2, (__u16 )1}, 
        {"period", (__u16 )4096, (__u16 )24576}, 
        {"timeout", (__u16 )8192, (__u16 )20480}, 
        {"saving", (__u16 )16384, (__u16 )12288}};
#line 540 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwconfig.c"
static struct iwconfig_modifier  const  iwmod_retry[6]  = {      {"min", (__u16 )1, (__u16 )2}, 
        {"max", (__u16 )2, (__u16 )1}, 
        {"short", (__u16 )16, (__u16 )32}, 
        {"long", (__u16 )32, (__u16 )16}, 
        {"limit", (__u16 )4096, (__u16 )8192}, 
        {"lifetime", (__u16 )8192, (__u16 )4096}};
#line 557 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwconfig.c"
static int parse_modifiers(char **args , int count , __u16 *pout , struct iwconfig_modifier  const  *modifier ,
                           int modnum ) 
{ 
  int i ;
  int k ;
  __u16 result ;
  int tmp ;

  {
#line 564
  i = 0;
#line 565
  k = 0;
#line 566
  result = (__u16 )0;
  {
#line 569
  while (1) {
    while_continue: /* CIL Label */ ;
#line 571
    k = 0;
    {
#line 571
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 571
      if (! (k < modnum)) {
#line 571
        goto while_break___0;
      }
      {
#line 574
      tmp = strcasecmp((char const   *)*(args + i), (char const   *)(modifier + k)->cmd);
      }
#line 574
      if (! tmp) {
#line 577
        if ((int )result & (int )(modifier + k)->exclude) {
#line 579
          errarg = i;
#line 580
          return (-5);
        }
#line 583
        result = (__u16 )((int )result | (int )(modifier + k)->flag);
#line 584
        i ++;
#line 585
        goto while_break___0;
      }
#line 571
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 569
    if (i < count) {
#line 569
      if (! (k < modnum)) {
#line 569
        goto while_break;
      }
    } else {
#line 569
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 593
  if (i >= count) {
#line 594
    return (-2);
  }
#line 597
  *pout = result;
#line 598
  return (i);
}
}
#line 616 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwconfig.c"
static int set_essid_info(int skfd , char *ifname , char **args , int count ) 
{ 
  struct iwreq wrq ;
  int i ;
  char essid[129] ;
  int essid_len ;
  int essid_index ;
  int we_kernel_version ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 623
  i = 1;
#line 629
  tmp___6 = strcasecmp((char const   *)*(args + 0), "off");
  }
#line 629
  if (tmp___6) {
    {
#line 629
    tmp___7 = strcasecmp((char const   *)*(args + 0), "any");
    }
#line 629
    if (tmp___7) {
      {
#line 637
      tmp___5 = strcasecmp((char const   *)*(args + 0), "on");
      }
#line 637
      if (tmp___5) {
        {
#line 651
        i = 0;
#line 656
        tmp___1 = strcmp((char const   *)*(args + 0), "-");
        }
#line 656
        if (tmp___1) {
          {
#line 656
          tmp___2 = strcmp((char const   *)*(args + 0), "--");
          }
#line 656
          if (! tmp___2) {
            _L: /* CIL Label */ 
#line 658
            i ++;
#line 658
            if (i >= count) {
#line 659
              return (-2);
            }
            {
#line 660
            tmp___0 = strlen((char const   *)*(args + i));
#line 660
            essid_len = (int )tmp___0;
            }
          }
        } else {
#line 656
          goto _L;
        }
        {
#line 665
        tmp___3 = strlen((char const   *)*(args + i));
        }
#line 665
        if (tmp___3 > 128UL) {
#line 667
          errmax = 32;
#line 668
          return (-4);
        }
        {
#line 672
        essid_len = iw_essid_unescape(essid, (char const   *)*(args + i));
        }
#line 675
        if (essid_len > 32) {
#line 677
          errmax = 32;
#line 678
          return (-4);
        }
#line 681
        wrq.u.essid.flags = (__u16 )1;
#line 682
        i ++;
#line 685
        if (i < count) {
          {
#line 685
          tmp___4 = sscanf((char const   */* __restrict  */)*(args + i), (char const   */* __restrict  */)"[%i]",
                           & essid_index);
          }
#line 685
          if (tmp___4 == 1) {
#line 685
            if (essid_index > 0) {
#line 685
              if (essid_index < 255) {
#line 689
                wrq.u.essid.flags = (__u16 )essid_index;
#line 690
                i ++;
              }
            }
          }
        }
      } else {
        {
#line 640
        memset((void *)(essid), '\000', sizeof(essid));
#line 641
        wrq.u.essid.pointer = (void *)(essid);
#line 642
        wrq.u.essid.length = (__u16 )34;
#line 643
        wrq.u.essid.flags = (__u16 )0;
#line 644
        tmp = iw_set_ext(skfd, (char const   *)ifname, 35611, & wrq);
        }
#line 644
        if (tmp < 0) {
#line 645
          return (-7);
        }
#line 646
        wrq.u.essid.flags = (__u16 )1;
#line 647
        essid_len = (int )wrq.u.essid.length;
      }
    } else {
#line 632
      wrq.u.essid.flags = (__u16 )0;
#line 633
      essid[0] = (char )'\000';
#line 634
      essid_len = 0;
    }
  } else {
#line 632
    wrq.u.essid.flags = (__u16 )0;
#line 633
    essid[0] = (char )'\000';
#line 634
    essid_len = 0;
  }
  {
#line 695
  we_kernel_version = iw_get_kernel_we_version();
#line 698
  wrq.u.essid.pointer = (void *)(essid);
#line 699
  wrq.u.essid.length = (__u16 )essid_len;
  }
#line 700
  if (we_kernel_version < 21) {
#line 701
    wrq.u.essid.length = (__u16 )((int )wrq.u.essid.length + 1);
  }
  {
#line 703
  tmp___8 = iw_set_ext(skfd, (char const   *)ifname, 35610, & wrq);
  }
#line 703
  if (tmp___8 < 0) {
#line 704
    return (-6);
  }
#line 707
  return (i);
}
}
#line 714 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwconfig.c"
static int set_mode_info(int skfd , char *ifname , char **args , int count ) 
{ 
  struct iwreq wrq ;
  unsigned int k ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 724
  count = count;
#line 727
  tmp___0 = sscanf((char const   */* __restrict  */)*(args + 0), (char const   */* __restrict  */)"%i",
                   & k);
  }
#line 727
  if (tmp___0 != 1) {
#line 729
    k = 0U;
    {
#line 730
    while (1) {
      while_continue: /* CIL Label */ ;
#line 730
      if (k < 7U) {
        {
#line 730
        tmp = strncasecmp((char const   *)*(args + 0), (char const   *)iw_operation_mode[k],
                          (size_t )3);
        }
#line 730
        if (! tmp) {
#line 730
          goto while_break;
        }
      } else {
#line 730
        goto while_break;
      }
#line 732
      k ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 734
  if (k >= 7U) {
#line 736
    errarg = 0;
#line 737
    return (-3);
  }
  {
#line 740
  wrq.u.mode = k;
#line 741
  tmp___1 = iw_set_ext(skfd, (char const   *)ifname, 35590, & wrq);
  }
#line 741
  if (tmp___1 < 0) {
#line 742
    return (-6);
  }
#line 745
  return (1);
}
}
#line 752 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwconfig.c"
static int set_freq_info(int skfd , char *ifname , char **args , int count ) 
{ 
  struct iwreq wrq ;
  int i ;
  int tmp ;
  double freq ;
  char *unit ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 759
  i = 1;
#line 761
  tmp___3 = strcasecmp((char const   *)*(args + 0), "auto");
  }
#line 761
  if (tmp___3) {
    {
#line 769
    tmp___2 = strcasecmp((char const   *)*(args + 0), "fixed");
    }
#line 769
    if (tmp___2) {
      {
#line 781
      freq = strtod((char const   */* __restrict  */)*(args + 0), (char **/* __restrict  */)(& unit));
      }
#line 782
      if ((unsigned long )unit == (unsigned long )*(args + 0)) {
#line 784
        errarg = 0;
#line 785
        return (-3);
      }
#line 787
      if ((unsigned long )unit != (unsigned long )((void *)0)) {
#line 789
        if ((int )*(unit + 0) == 71) {
#line 789
          freq *= 1e9;
        }
#line 790
        if ((int )*(unit + 0) == 77) {
#line 790
          freq *= 1e6;
        }
#line 791
        if ((int )*(unit + 0) == 107) {
#line 791
          freq *= 1e3;
        }
      }
      {
#line 794
      iw_float2freq(freq, & wrq.u.freq);
#line 796
      wrq.u.freq.flags = (__u8 )1;
      }
#line 799
      if (i < count) {
        {
#line 799
        tmp___0 = strcasecmp((char const   *)*(args + i), "auto");
        }
#line 799
        if (! tmp___0) {
#line 801
          wrq.u.freq.flags = (__u8 )0;
#line 802
          i ++;
        }
      }
#line 804
      if (i < count) {
        {
#line 804
        tmp___1 = strcasecmp((char const   *)*(args + i), "fixed");
        }
#line 804
        if (! tmp___1) {
#line 806
          wrq.u.freq.flags = (__u8 )1;
#line 807
          i ++;
        }
      }
    } else {
      {
#line 772
      tmp = iw_set_ext(skfd, (char const   *)ifname, 35589, & wrq);
      }
#line 772
      if (tmp < 0) {
#line 773
        return (-7);
      }
#line 774
      wrq.u.freq.flags = (__u8 )1;
    }
  } else {
#line 763
    wrq.u.freq.m = -1;
#line 764
    wrq.u.freq.e = (__s16 )0;
#line 765
    wrq.u.freq.flags = (__u8 )0;
  }
  {
#line 812
  tmp___4 = iw_set_ext(skfd, (char const   *)ifname, 35588, & wrq);
  }
#line 812
  if (tmp___4 < 0) {
#line 813
    return (-6);
  }
#line 816
  return (i);
}
}
#line 823 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwconfig.c"
static int set_bitrate_info(int skfd , char *ifname , char **args , int count ) 
{ 
  struct iwreq wrq ;
  int i ;
  int tmp ;
  double brate ;
  char *unit ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 830
  i = 1;
#line 832
  wrq.u.bitrate.flags = (__u16 )0;
#line 833
  tmp___5 = strcasecmp((char const   *)*(args + 0), "auto");
  }
#line 833
  if (tmp___5) {
    {
#line 840
    tmp___4 = strcasecmp((char const   *)*(args + 0), "fixed");
    }
#line 840
    if (tmp___4) {
      {
#line 852
      brate = strtod((char const   */* __restrict  */)*(args + 0), (char **/* __restrict  */)(& unit));
      }
#line 853
      if ((unsigned long )unit == (unsigned long )*(args + 0)) {
#line 855
        errarg = 0;
#line 856
        return (-3);
      }
#line 858
      if ((unsigned long )unit != (unsigned long )((void *)0)) {
#line 860
        if ((int )*(unit + 0) == 71) {
#line 860
          brate *= 1e9;
        }
#line 861
        if ((int )*(unit + 0) == 77) {
#line 861
          brate *= 1e6;
        }
#line 862
        if ((int )*(unit + 0) == 107) {
#line 862
          brate *= 1e3;
        }
      }
#line 864
      wrq.u.bitrate.value = (__s32 )((long )brate);
#line 865
      wrq.u.bitrate.fixed = (__u8 )1;
#line 868
      if (i < count) {
        {
#line 868
        tmp___0 = strcasecmp((char const   *)*(args + i), "auto");
        }
#line 868
        if (! tmp___0) {
#line 870
          wrq.u.bitrate.fixed = (__u8 )0;
#line 871
          i ++;
        }
      }
#line 873
      if (i < count) {
        {
#line 873
        tmp___1 = strcasecmp((char const   *)*(args + i), "fixed");
        }
#line 873
        if (! tmp___1) {
#line 875
          wrq.u.bitrate.fixed = (__u8 )1;
#line 876
          i ++;
        }
      }
#line 878
      if (i < count) {
        {
#line 878
        tmp___2 = strcasecmp((char const   *)*(args + i), "unicast");
        }
#line 878
        if (! tmp___2) {
#line 880
          wrq.u.bitrate.flags = (__u16 )((int )wrq.u.bitrate.flags | 1);
#line 881
          i ++;
        }
      }
#line 883
      if (i < count) {
        {
#line 883
        tmp___3 = strcasecmp((char const   *)*(args + i), "broadcast");
        }
#line 883
        if (! tmp___3) {
#line 885
          wrq.u.bitrate.flags = (__u16 )((int )wrq.u.bitrate.flags | 2);
#line 886
          i ++;
        }
      }
    } else {
      {
#line 843
      tmp = iw_set_ext(skfd, (char const   *)ifname, 35617, & wrq);
      }
#line 843
      if (tmp < 0) {
#line 844
        return (-7);
      }
#line 845
      wrq.u.bitrate.fixed = (__u8 )1;
    }
  } else {
#line 835
    wrq.u.bitrate.value = -1;
#line 836
    wrq.u.bitrate.fixed = (__u8 )0;
  }
  {
#line 891
  tmp___6 = iw_set_ext(skfd, (char const   *)ifname, 35616, & wrq);
  }
#line 891
  if (tmp___6 < 0) {
#line 892
    return (-6);
  }
#line 895
  return (i);
}
}
#line 902 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwconfig.c"
static int set_enc_info(int skfd , char *ifname , char **args , int count ) 
{ 
  struct iwreq wrq ;
  int i ;
  unsigned char key[64] ;
  int tmp ;
  int gotone ;
  int oldone ;
  int keylen ;
  int temp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 909
  i = 1;
#line 912
  tmp___5 = strcasecmp((char const   *)*(args + 0), "on");
  }
#line 912
  if (tmp___5) {
#line 924
    gotone = 0;
#line 929
    wrq.u.data.pointer = (void *)((caddr_t )((void *)0));
#line 930
    wrq.u.data.flags = (__u16 )0;
#line 931
    wrq.u.data.length = (__u16 )0;
#line 932
    i = 0;
    {
#line 935
    while (1) {
      while_continue: /* CIL Label */ ;
#line 937
      oldone = gotone;
#line 940
      if (i < count) {
        {
#line 942
        keylen = iw_in_key_full(skfd, (char const   *)ifname, (char const   *)*(args + i),
                                key, & wrq.u.data.flags);
        }
#line 944
        if (keylen > 0) {
#line 946
          wrq.u.data.length = (__u16 )keylen;
#line 947
          wrq.u.data.pointer = (void *)((caddr_t )(key));
#line 948
          i ++;
#line 949
          gotone ++;
        }
      }
#line 954
      if (i < count) {
        {
#line 954
        tmp___0 = sscanf((char const   */* __restrict  */)*(args + i), (char const   */* __restrict  */)"[%i]",
                         & temp);
        }
#line 954
        if (tmp___0 == 1) {
#line 954
          if (temp > 0) {
#line 954
            if (temp < 255) {
#line 958
              wrq.u.encoding.flags = (__u16 )((int )wrq.u.encoding.flags | temp);
#line 959
              i ++;
#line 960
              gotone ++;
            }
          }
        }
      }
#line 964
      if (i < count) {
        {
#line 964
        tmp___1 = strcasecmp((char const   *)*(args + i), "off");
        }
#line 964
        if (! tmp___1) {
#line 966
          wrq.u.data.flags = (__u16 )((int )wrq.u.data.flags | 32768);
#line 967
          i ++;
#line 968
          gotone ++;
        }
      }
#line 970
      if (i < count) {
        {
#line 970
        tmp___2 = strcasecmp((char const   *)*(args + i), "open");
        }
#line 970
        if (! tmp___2) {
#line 972
          wrq.u.data.flags = (__u16 )((int )wrq.u.data.flags | 8192);
#line 973
          i ++;
#line 974
          gotone ++;
        }
      }
#line 976
      if (i < count) {
        {
#line 976
        tmp___3 = strncasecmp((char const   *)*(args + i), "restricted", (size_t )5);
        }
#line 976
        if (! tmp___3) {
#line 978
          wrq.u.data.flags = (__u16 )((int )wrq.u.data.flags | 16384);
#line 979
          i ++;
#line 980
          gotone ++;
        }
      }
#line 982
      if (i < count) {
        {
#line 982
        tmp___4 = strncasecmp((char const   *)*(args + i), "temporary", (size_t )4);
        }
#line 982
        if (! tmp___4) {
#line 984
          wrq.u.data.flags = (__u16 )((int )wrq.u.data.flags | 1024);
#line 985
          i ++;
#line 986
          gotone ++;
        }
      }
#line 935
      if (! (gotone != oldone)) {
#line 935
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 992
    if ((unsigned long )wrq.u.data.pointer == (unsigned long )((void *)0)) {
#line 993
      wrq.u.data.flags = (__u16 )((int )wrq.u.data.flags | 2048);
    }
#line 996
    if (! gotone) {
#line 998
      errarg = 0;
#line 999
      return (-3);
    }
  } else {
    {
#line 915
    wrq.u.data.pointer = (void *)((caddr_t )(key));
#line 916
    wrq.u.data.length = (__u16 )64;
#line 917
    wrq.u.data.flags = (__u16 )0;
#line 918
    tmp = iw_set_ext(skfd, (char const   *)ifname, 35627, & wrq);
    }
#line 918
    if (tmp < 0) {
#line 919
      return (-7);
    }
#line 920
    wrq.u.data.flags = (__u16 )((int )wrq.u.data.flags & -32769);
  }
  {
#line 1003
  tmp___6 = iw_set_ext(skfd, (char const   *)ifname, 35626, & wrq);
  }
#line 1003
  if (tmp___6 < 0) {
#line 1004
    return (-6);
  }
#line 1007
  return (i);
}
}
#line 1014 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwconfig.c"
static int set_power_info(int skfd , char *ifname , char **args , int count ) 
{ 
  struct iwreq wrq ;
  int i ;
  int tmp ;
  double value ;
  char *unit ;
  int gotone ;
  struct iw_range range ;
  int flags ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 1021
  i = 1;
#line 1023
  tmp___7 = strcasecmp((char const   *)*(args + 0), "off");
  }
#line 1023
  if (tmp___7) {
    {
#line 1026
    tmp___6 = strcasecmp((char const   *)*(args + 0), "on");
    }
#line 1026
    if (tmp___6) {
      {
#line 1038
      gotone = 0;
#line 1041
      i = parse_modifiers(args, count, & wrq.u.power.flags, iwmod_power, (int )(sizeof(iwmod_power) / sizeof(iwmod_power[0])));
      }
#line 1043
      if (i < 0) {
#line 1044
        return (i);
      }
      {
#line 1046
      wrq.u.power.disabled = (__u8 )0;
#line 1049
      value = strtod((char const   */* __restrict  */)*(args + i), (char **/* __restrict  */)(& unit));
      }
#line 1050
      if ((unsigned long )unit != (unsigned long )*(args + i)) {
        {
#line 1055
        tmp___0 = iw_get_range_info(skfd, (char const   *)ifname, & range);
        }
#line 1055
        if (tmp___0 < 0) {
          {
#line 1056
          memset((void *)(& range), 0, sizeof(range));
          }
        }
        {
#line 1061
        if (((int )wrq.u.power.flags & 61440) == 16384) {
#line 1061
          goto case_16384;
        }
#line 1064
        if (((int )wrq.u.power.flags & 61440) == 8192) {
#line 1064
          goto case_8192;
        }
#line 1067
        goto switch_default;
        case_16384: /* CIL Label */ 
#line 1062
        flags = (int )range.pms_flags;
#line 1063
        goto switch_break;
        case_8192: /* CIL Label */ 
#line 1065
        flags = (int )range.pmt_flags;
#line 1066
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 1068
        flags = (int )range.pmp_flags;
#line 1069
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 1072
        if (flags & 4) {
#line 1074
          if ((int )range.we_version_compiled < 21) {
#line 1075
            value *= 1e6;
          } else {
#line 1077
            wrq.u.power.flags = (__u16 )((int )wrq.u.power.flags | 4);
          }
        } else {
#line 1081
          value *= 1e6;
#line 1082
          if ((int )*(unit + 0) == 117) {
#line 1082
            value /= 1e6;
          }
#line 1083
          if ((int )*(unit + 0) == 109) {
#line 1083
            value /= 1e3;
          }
        }
#line 1085
        wrq.u.power.value = (__s32 )((long )value);
#line 1087
        if (((int )wrq.u.power.flags & 61440) == 0) {
#line 1088
          wrq.u.power.flags = (__u16 )((int )wrq.u.power.flags | 4096);
        }
#line 1089
        i ++;
#line 1090
        gotone = 1;
      }
#line 1094
      if (i < count) {
        {
#line 1096
        tmp___1 = strcasecmp((char const   *)*(args + i), "all");
        }
#line 1096
        if (! tmp___1) {
#line 1097
          wrq.u.power.flags = (__u16 )((int )wrq.u.power.flags | 768);
        }
        {
#line 1098
        tmp___2 = strncasecmp((char const   *)*(args + i), "unicast", (size_t )4);
        }
#line 1098
        if (! tmp___2) {
#line 1099
          wrq.u.power.flags = (__u16 )((int )wrq.u.power.flags | 256);
        }
        {
#line 1100
        tmp___3 = strncasecmp((char const   *)*(args + i), "multicast", (size_t )5);
        }
#line 1100
        if (! tmp___3) {
#line 1101
          wrq.u.power.flags = (__u16 )((int )wrq.u.power.flags | 512);
        }
        {
#line 1102
        tmp___4 = strncasecmp((char const   *)*(args + i), "force", (size_t )5);
        }
#line 1102
        if (! tmp___4) {
#line 1103
          wrq.u.power.flags = (__u16 )((int )wrq.u.power.flags | 1024);
        }
        {
#line 1104
        tmp___5 = strcasecmp((char const   *)*(args + i), "repeat");
        }
#line 1104
        if (! tmp___5) {
#line 1105
          wrq.u.power.flags = (__u16 )((int )wrq.u.power.flags | 2048);
        }
#line 1106
        if ((int )wrq.u.power.flags & 3840) {
#line 1108
          i ++;
#line 1109
          gotone = 1;
        }
      }
#line 1112
      if (! gotone) {
#line 1114
        errarg = i;
#line 1115
        return (-3);
      }
    } else {
      {
#line 1029
      wrq.u.power.flags = (__u16 )0;
#line 1030
      tmp = iw_set_ext(skfd, (char const   *)ifname, 35629, & wrq);
      }
#line 1030
      if (tmp < 0) {
#line 1031
        return (-7);
      }
#line 1032
      wrq.u.power.disabled = (__u8 )0;
    }
  } else {
#line 1024
    wrq.u.power.disabled = (__u8 )1;
  }
  {
#line 1119
  tmp___8 = iw_set_ext(skfd, (char const   *)ifname, 35628, & wrq);
  }
#line 1119
  if (tmp___8 < 0) {
#line 1120
    return (-6);
  }
#line 1123
  return (i);
}
}
#line 1131 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwconfig.c"
static int set_nick_info(int skfd , char *ifname , char **args , int count ) 
{ 
  struct iwreq wrq ;
  int we_kernel_version ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1141
  count = count;
#line 1143
  tmp = strlen((char const   *)*(args + 0));
  }
#line 1143
  if (tmp > 32UL) {
#line 1145
    errmax = 32;
#line 1146
    return (-4);
  }
  {
#line 1149
  we_kernel_version = iw_get_kernel_we_version();
#line 1151
  wrq.u.essid.pointer = (void *)*(args + 0);
#line 1152
  tmp___0 = strlen((char const   *)*(args + 0));
#line 1152
  wrq.u.essid.length = (__u16 )tmp___0;
  }
#line 1153
  if (we_kernel_version < 21) {
#line 1154
    wrq.u.essid.length = (__u16 )((int )wrq.u.essid.length + 1);
  }
  {
#line 1156
  tmp___1 = iw_set_ext(skfd, (char const   *)ifname, 35612, & wrq);
  }
#line 1156
  if (tmp___1 < 0) {
#line 1157
    return (-6);
  }
#line 1160
  return (1);
}
}
#line 1167 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwconfig.c"
static int set_nwid_info(int skfd , char *ifname , char **args , int count ) 
{ 
  struct iwreq wrq ;
  unsigned long temp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 1177
  count = count;
#line 1179
  tmp___2 = strcasecmp((char const   *)*(args + 0), "off");
  }
#line 1179
  if (tmp___2) {
    {
#line 1179
    tmp___3 = strcasecmp((char const   *)*(args + 0), "any");
    }
#line 1179
    if (tmp___3) {
      {
#line 1183
      tmp___1 = strcasecmp((char const   *)*(args + 0), "on");
      }
#line 1183
      if (tmp___1) {
        {
#line 1191
        tmp___0 = sscanf((char const   */* __restrict  */)*(args + 0), (char const   */* __restrict  */)"%lX",
                         & temp);
        }
#line 1191
        if (tmp___0 != 1) {
#line 1193
          errarg = 0;
#line 1194
          return (-3);
        } else {
#line 1198
          wrq.u.nwid.value = (__s32 )temp;
#line 1199
          wrq.u.nwid.disabled = (__u8 )0;
        }
      } else {
        {
#line 1186
        tmp = iw_set_ext(skfd, (char const   *)ifname, 35587, & wrq);
        }
#line 1186
        if (tmp < 0) {
#line 1187
          return (-7);
        }
#line 1188
        wrq.u.nwid.disabled = (__u8 )0;
      }
    } else {
#line 1181
      wrq.u.nwid.disabled = (__u8 )1;
    }
  } else {
#line 1181
    wrq.u.nwid.disabled = (__u8 )1;
  }
  {
#line 1202
  wrq.u.nwid.fixed = (__u8 )1;
#line 1205
  tmp___4 = iw_set_ext(skfd, (char const   *)ifname, 35586, & wrq);
  }
#line 1205
  if (tmp___4 < 0) {
#line 1206
    return (-6);
  }
#line 1209
  return (1);
}
}
#line 1216 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwconfig.c"
static int set_apaddr_info(int skfd , char *ifname , char **args , int count ) 
{ 
  struct iwreq wrq ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1225
  count = count;
#line 1227
  tmp___1 = strcasecmp((char const   *)*(args + 0), "auto");
  }
#line 1227
  if (tmp___1) {
    {
#line 1227
    tmp___2 = strcasecmp((char const   *)*(args + 0), "any");
    }
#line 1227
    if (tmp___2) {
      {
#line 1235
      tmp___0 = strcasecmp((char const   *)*(args + 0), "off");
      }
#line 1235
      if (tmp___0) {
        {
#line 1243
        tmp = iw_in_addr(skfd, (char const   *)ifname, *(args + 0), & wrq.u.ap_addr);
        }
#line 1243
        if (tmp < 0) {
#line 1245
          errarg = 0;
#line 1246
          return (-3);
        }
      } else {
        {
#line 1238
        iw_null_ether(& wrq.u.ap_addr);
        }
      }
    } else {
      {
#line 1231
      iw_broad_ether(& wrq.u.ap_addr);
      }
    }
  } else {
    {
#line 1231
    iw_broad_ether(& wrq.u.ap_addr);
    }
  }
  {
#line 1251
  tmp___3 = iw_set_ext(skfd, (char const   *)ifname, 35604, & wrq);
  }
#line 1251
  if (tmp___3 < 0) {
#line 1252
    return (-6);
  }
#line 1255
  return (1);
}
}
#line 1262 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwconfig.c"
static int set_txpower_info(int skfd , char *ifname , char **args , int count ) 
{ 
  struct iwreq wrq ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int power ;
  int ismwatt ;
  struct iw_range range ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
  {
#line 1269
  i = 1;
#line 1272
  args = args;
#line 1272
  count = count;
#line 1275
  wrq.u.txpower.value = -1;
#line 1276
  wrq.u.txpower.fixed = (__u8 )1;
#line 1277
  wrq.u.txpower.disabled = (__u8 )0;
#line 1278
  wrq.u.txpower.flags = (__u16 )0;
#line 1280
  tmp___11 = strcasecmp((char const   *)*(args + 0), "off");
  }
#line 1280
  if (tmp___11) {
    {
#line 1283
    tmp___10 = strcasecmp((char const   *)*(args + 0), "auto");
    }
#line 1283
    if (tmp___10) {
      {
#line 1287
      tmp___9 = strcasecmp((char const   *)*(args + 0), "on");
      }
#line 1287
      if (tmp___9) {
        {
#line 1296
        tmp___8 = strcasecmp((char const   *)*(args + 0), "fixed");
        }
#line 1296
        if (tmp___8) {
          {
#line 1307
          ismwatt = 0;
#line 1311
          tmp___1 = iw_get_range_info(skfd, (char const   *)ifname, & range);
          }
#line 1311
          if (tmp___1 < 0) {
            {
#line 1312
            memset((void *)(& range), 0, sizeof(range));
            }
          }
          {
#line 1315
          tmp___2 = sscanf((char const   */* __restrict  */)*(args + 0), (char const   */* __restrict  */)"%i",
                           & power);
          }
#line 1315
          if (tmp___2 != 1) {
#line 1317
            errarg = 0;
#line 1318
            return (-3);
          }
          {
#line 1324
          tmp___3 = strchr((char const   *)*(args + 0), 'm');
          }
#line 1324
          if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
            {
#line 1324
            tmp___4 = strchr((char const   *)*(args + 0), 'd');
            }
#line 1324
            if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
#line 1324
              tmp___5 = 1;
            } else {
#line 1324
              tmp___5 = 0;
            }
          } else {
#line 1324
            tmp___5 = 0;
          }
#line 1324
          ismwatt = tmp___5;
#line 1330
          if ((int )range.txpower_capa & 2) {
#line 1333
            if (ismwatt) {
#line 1335
              errarg = 0;
#line 1336
              return (-3);
            }
#line 1338
            wrq.u.txpower.flags = (__u16 )2;
          } else
#line 1341
          if ((int )range.txpower_capa & 1) {
#line 1343
            if (! ismwatt) {
              {
#line 1344
              power = iw_dbm2mwatt(power);
              }
            }
#line 1345
            wrq.u.txpower.flags = (__u16 )1;
          } else {
#line 1349
            if (ismwatt) {
              {
#line 1350
              power = iw_mwatt2dbm(power);
              }
            }
#line 1351
            wrq.u.txpower.flags = (__u16 )0;
          }
#line 1353
          wrq.u.txpower.value = power;
#line 1356
          if (i < count) {
            {
#line 1356
            tmp___6 = strcasecmp((char const   *)*(args + i), "auto");
            }
#line 1356
            if (! tmp___6) {
#line 1358
              wrq.u.txpower.fixed = (__u8 )0;
#line 1359
              i ++;
            }
          }
#line 1361
          if (i < count) {
            {
#line 1361
            tmp___7 = strcasecmp((char const   *)*(args + i), "fixed");
            }
#line 1361
            if (! tmp___7) {
#line 1363
              wrq.u.txpower.fixed = (__u8 )1;
#line 1364
              i ++;
            }
          }
        } else {
          {
#line 1299
          tmp___0 = iw_set_ext(skfd, (char const   *)ifname, 35623, & wrq);
          }
#line 1299
          if (tmp___0 < 0) {
#line 1300
            return (-7);
          }
#line 1301
          wrq.u.txpower.fixed = (__u8 )1;
#line 1302
          wrq.u.txpower.disabled = (__u8 )0;
        }
      } else {
        {
#line 1290
        tmp = iw_set_ext(skfd, (char const   *)ifname, 35623, & wrq);
        }
#line 1290
        if (tmp < 0) {
#line 1291
          return (-7);
        }
#line 1292
        wrq.u.txpower.disabled = (__u8 )0;
      }
    } else {
#line 1284
      wrq.u.txpower.fixed = (__u8 )0;
    }
  } else {
#line 1281
    wrq.u.txpower.disabled = (__u8 )1;
  }
  {
#line 1370
  tmp___12 = iw_set_ext(skfd, (char const   *)ifname, 35622, & wrq);
  }
#line 1370
  if (tmp___12 < 0) {
#line 1371
    return (-6);
  }
#line 1374
  return (i);
}
}
#line 1381 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwconfig.c"
static int set_sens_info(int skfd , char *ifname , char **args , int count ) 
{ 
  struct iwreq wrq ;
  int temp ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1391
  count = count;
#line 1393
  tmp = sscanf((char const   */* __restrict  */)*(args + 0), (char const   */* __restrict  */)"%i",
               & temp);
  }
#line 1393
  if (tmp != 1) {
#line 1395
    errarg = 0;
#line 1396
    return (-3);
  }
  {
#line 1398
  wrq.u.sens.value = temp;
#line 1400
  tmp___0 = iw_set_ext(skfd, (char const   *)ifname, 35592, & wrq);
  }
#line 1400
  if (tmp___0 < 0) {
#line 1401
    return (-6);
  }
#line 1404
  return (1);
}
}
#line 1411 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwconfig.c"
static int set_retry_info(int skfd , char *ifname , char **args , int count ) 
{ 
  struct iwreq wrq ;
  int i ;
  double value ;
  char *unit ;
  struct iw_range range ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1418
  i = 0;
#line 1423
  i = parse_modifiers(args, count, & wrq.u.retry.flags, iwmod_retry, (int )(sizeof(iwmod_retry) / sizeof(iwmod_retry[0])));
  }
#line 1425
  if (i < 0) {
#line 1426
    return (i);
  }
#line 1429
  if (((int )wrq.u.retry.flags & 61440) == 0) {
#line 1430
    wrq.u.retry.flags = (__u16 )((int )wrq.u.retry.flags | 4096);
  }
  {
#line 1432
  wrq.u.retry.disabled = (__u8 )0;
#line 1435
  value = strtod((char const   */* __restrict  */)*(args + i), (char **/* __restrict  */)(& unit));
  }
#line 1436
  if ((unsigned long )unit == (unsigned long )*(args + i)) {
#line 1438
    errarg = i;
#line 1439
    return (-3);
  }
#line 1443
  if ((int )wrq.u.retry.flags & 8192) {
    {
#line 1447
    tmp = iw_get_range_info(skfd, (char const   *)ifname, & range);
    }
#line 1447
    if (tmp < 0) {
      {
#line 1448
      memset((void *)(& range), 0, sizeof(range));
      }
    }
#line 1450
    if ((int )range.r_time_flags & 4) {
#line 1452
      if ((int )range.we_version_compiled < 21) {
#line 1453
        value *= 1e6;
      } else {
#line 1455
        wrq.u.retry.flags = (__u16 )((int )wrq.u.retry.flags | 4);
      }
    } else {
#line 1460
      value *= 1e6;
#line 1461
      if ((int )*(unit + 0) == 117) {
#line 1461
        value /= 1e6;
      }
#line 1462
      if ((int )*(unit + 0) == 109) {
#line 1462
        value /= 1e3;
      }
    }
  }
  {
#line 1465
  wrq.u.retry.value = (__s32 )((long )value);
#line 1466
  i ++;
#line 1468
  tmp___0 = iw_set_ext(skfd, (char const   *)ifname, 35624, & wrq);
  }
#line 1468
  if (tmp___0 < 0) {
#line 1469
    return (-6);
  }
#line 1472
  return (i);
}
}
#line 1479 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwconfig.c"
static int set_rts_info(int skfd , char *ifname , char **args , int count ) 
{ 
  struct iwreq wrq ;
  int tmp ;
  long temp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 1488
  count = count;
#line 1490
  wrq.u.rts.value = -1;
#line 1491
  wrq.u.rts.fixed = (__u8 )1;
#line 1492
  wrq.u.rts.disabled = (__u8 )0;
#line 1494
  tmp___3 = strcasecmp((char const   *)*(args + 0), "off");
  }
#line 1494
  if (tmp___3) {
    {
#line 1497
    tmp___2 = strcasecmp((char const   *)*(args + 0), "auto");
    }
#line 1497
    if (tmp___2) {
      {
#line 1501
      tmp___1 = strcasecmp((char const   *)*(args + 0), "fixed");
      }
#line 1501
      if (tmp___1) {
        {
#line 1511
        tmp___0 = sscanf((char const   */* __restrict  */)*(args + 0), (char const   */* __restrict  */)"%li",
                         (unsigned long *)(& temp));
        }
#line 1511
        if (tmp___0 != 1) {
#line 1513
          errarg = 0;
#line 1514
          return (-3);
        }
#line 1516
        wrq.u.rts.value = (__s32 )temp;
      } else {
        {
#line 1504
        tmp = iw_set_ext(skfd, (char const   *)ifname, 35619, & wrq);
        }
#line 1504
        if (tmp < 0) {
#line 1505
          return (-7);
        }
#line 1506
        wrq.u.rts.fixed = (__u8 )1;
      }
    } else {
#line 1498
      wrq.u.rts.fixed = (__u8 )0;
    }
  } else {
#line 1495
    wrq.u.rts.disabled = (__u8 )1;
  }
  {
#line 1520
  tmp___4 = iw_set_ext(skfd, (char const   *)ifname, 35618, & wrq);
  }
#line 1520
  if (tmp___4 < 0) {
#line 1521
    return (-6);
  }
#line 1524
  return (1);
}
}
#line 1531 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwconfig.c"
static int set_frag_info(int skfd , char *ifname , char **args , int count ) 
{ 
  struct iwreq wrq ;
  int tmp ;
  long temp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 1540
  count = count;
#line 1542
  wrq.u.frag.value = -1;
#line 1543
  wrq.u.frag.fixed = (__u8 )1;
#line 1544
  wrq.u.frag.disabled = (__u8 )0;
#line 1546
  tmp___3 = strcasecmp((char const   *)*(args + 0), "off");
  }
#line 1546
  if (tmp___3) {
    {
#line 1549
    tmp___2 = strcasecmp((char const   *)*(args + 0), "auto");
    }
#line 1549
    if (tmp___2) {
      {
#line 1553
      tmp___1 = strcasecmp((char const   *)*(args + 0), "fixed");
      }
#line 1553
      if (tmp___1) {
        {
#line 1563
        tmp___0 = sscanf((char const   */* __restrict  */)*(args + 0), (char const   */* __restrict  */)"%li",
                         & temp);
        }
#line 1563
        if (tmp___0 != 1) {
#line 1566
          errarg = 0;
#line 1567
          return (-3);
        }
#line 1569
        wrq.u.frag.value = (__s32 )temp;
      } else {
        {
#line 1556
        tmp = iw_set_ext(skfd, (char const   *)ifname, 35621, & wrq);
        }
#line 1556
        if (tmp < 0) {
#line 1557
          return (-7);
        }
#line 1558
        wrq.u.frag.fixed = (__u8 )1;
      }
    } else {
#line 1550
      wrq.u.frag.fixed = (__u8 )0;
    }
  } else {
#line 1547
    wrq.u.frag.disabled = (__u8 )1;
  }
  {
#line 1573
  tmp___4 = iw_set_ext(skfd, (char const   *)ifname, 35620, & wrq);
  }
#line 1573
  if (tmp___4 < 0) {
#line 1574
    return (-6);
  }
#line 1577
  return (1);
}
}
#line 1584 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwconfig.c"
static int set_modulation_info(int skfd , char *ifname , char **args , int count ) 
{ 
  struct iwreq wrq ;
  int i ;
  int tmp ;
  int k ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 1591
  i = 1;
#line 1594
  args = args;
#line 1594
  count = count;
#line 1596
  tmp___4 = strcasecmp((char const   *)*(args + 0), "auto");
  }
#line 1596
  if (tmp___4) {
    {
#line 1600
    tmp___3 = strcasecmp((char const   *)*(args + 0), "fixed");
    }
#line 1600
    if (tmp___3) {
#line 1612
      wrq.u.param.value = 0;
#line 1613
      i = 0;
      {
#line 1614
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1616
        k = 0;
        {
#line 1616
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1616
          if (! (k < 16)) {
#line 1616
            goto while_break___0;
          }
          {
#line 1618
          tmp___0 = strcasecmp((char const   *)*(args + i), (char const   *)(iw_modul_list[k].cmd));
          }
#line 1618
          if (! tmp___0) {
#line 1620
            wrq.u.param.value = (__s32 )((unsigned int const   )wrq.u.param.value | iw_modul_list[k].mask);
#line 1621
            i ++;
#line 1622
            goto while_break___0;
          }
#line 1616
          k ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1614
        if (i < count) {
#line 1614
          if (! (k < 16)) {
#line 1614
            goto while_break;
          }
        } else {
#line 1614
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 1630
      if (i == 0) {
#line 1632
        errarg = 0;
#line 1633
        return (-3);
      }
#line 1637
      if (i < count) {
        {
#line 1637
        tmp___1 = strcasecmp((char const   *)*(args + i), "auto");
        }
#line 1637
        if (! tmp___1) {
#line 1639
          wrq.u.param.fixed = (__u8 )0;
#line 1640
          i ++;
        }
      }
#line 1642
      if (i < count) {
        {
#line 1642
        tmp___2 = strcasecmp((char const   *)*(args + i), "fixed");
        }
#line 1642
        if (! tmp___2) {
#line 1644
          wrq.u.param.fixed = (__u8 )1;
#line 1645
          i ++;
        }
      }
    } else {
      {
#line 1603
      tmp = iw_set_ext(skfd, (char const   *)ifname, 35631, & wrq);
      }
#line 1603
      if (tmp < 0) {
#line 1604
        return (-7);
      }
#line 1605
      wrq.u.param.fixed = (__u8 )1;
    }
  } else {
#line 1597
    wrq.u.param.fixed = (__u8 )0;
  }
  {
#line 1650
  tmp___5 = iw_set_ext(skfd, (char const   *)ifname, 35630, & wrq);
  }
#line 1650
  if (tmp___5 < 0) {
#line 1651
    return (-6);
  }
#line 1654
  return (i);
}
}
#line 1662 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwconfig.c"
static int set_commit_info(int skfd , char *ifname , char **args , int count ) 
{ 
  struct iwreq wrq ;
  int tmp ;

  {
  {
#line 1671
  args = args;
#line 1671
  count = count;
#line 1673
  tmp = iw_set_ext(skfd, (char const   *)ifname, 35584, & wrq);
  }
#line 1673
  if (tmp < 0) {
#line 1674
    return (-6);
  }
#line 1677
  return (0);
}
}
#line 1710 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwconfig.c"
static struct iwconfig_entry  const  iwconfig_cmds[20]  = 
#line 1710
  {      {"essid", & set_essid_info, 1, 35610, "Set ESSID", "{NNN|any|on|off}"}, 
        {"mode", & set_mode_info, 1, 35590, "Set Mode", "{managed|ad-hoc|master|...}"}, 
        {"freq",
      & set_freq_info, 1, 35588, "Set Frequency", "N.NNN[k|M|G]"}, 
        {"channel", & set_freq_info, 1, 35588, "Set Frequency", "N"}, 
        {"bit", & set_bitrate_info, 1, 35616, "Set Bit Rate", "{N[k|M|G]|auto|fixed}"}, 
        {"rate",
      & set_bitrate_info, 1, 35616, "Set Bit Rate", "{N[k|M|G]|auto|fixed}"}, 
        {"enc", & set_enc_info, 1, 35626, "Set Encode", "{NNNN-NNNN|off}"}, 
        {"key", & set_enc_info, 1, 35626, "Set Encode", "{NNNN-NNNN|off}"}, 
        {"power", & set_power_info, 1, 35628, "Set Power Management", "{period N|timeout N|saving N|off}"}, 
        {"nickname",
      & set_nick_info, 1, 35612, "Set Nickname", "NNN"}, 
        {"nwid", & set_nwid_info, 1, 35586, "Set NWID", "{NN|on|off}"}, 
        {"ap", & set_apaddr_info, 1, 35604, "Set AP Address", "{N|off|auto}"}, 
        {"txpower", & set_txpower_info, 1, 35622, "Set Tx Power", "{NmW|NdBm|off|auto}"}, 
        {"sens",
      & set_sens_info, 1, 35592, "Set Sensitivity", "N"}, 
        {"retry", & set_retry_info, 1, 35624, "Set Retry Limit", "{limit N|lifetime N}"}, 
        {"rts",
      & set_rts_info, 1, 35618, "Set RTS Threshold", "{N|auto|fixed|off}"}, 
        {"frag", & set_frag_info, 1, 35620, "Set Fragmentation Threshold", "{N|auto|fixed|off}"}, 
        {"modulation",
      & set_modulation_info, 1, 35631, "Set Modulation", "{11g|11a|CCK|OFDMg|...}"}, 
        {"commit",
      & set_commit_info, 0, 35584, "Commit changes", ""}, 
        {(char const   *)((void *)0), (int (*)(int skfd , char *ifname , char **args ,
                                            int count ))((void *)0), 0, 0, (char const   *)((void *)0),
      (char const   *)((void *)0)}};
#line 1758 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwconfig.c"
__inline static iwconfig_cmd const   *( __attribute__((__always_inline__)) find_command___0)(char const   *cmd ) 
{ 
  iwconfig_cmd const   *found ;
  int ambig ;
  unsigned int len ;
  size_t tmp ;
  int i ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 1761
  found = (iwconfig_cmd const   *)((void *)0);
#line 1762
  ambig = 0;
#line 1763
  tmp = strlen(cmd);
#line 1763
  len = (unsigned int )tmp;
#line 1767
  i = 0;
  }
  {
#line 1767
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1767
    if (! ((unsigned long )iwconfig_cmds[i].cmd != (unsigned long )((void *)0))) {
#line 1767
      goto while_break;
    }
    {
#line 1770
    tmp___0 = strncasecmp((char const   *)iwconfig_cmds[i].cmd, cmd, (size_t )len);
    }
#line 1770
    if (tmp___0 != 0) {
#line 1771
      goto __Cont;
    }
    {
#line 1774
    tmp___1 = strlen((char const   *)iwconfig_cmds[i].cmd);
    }
#line 1774
    if ((size_t )len == tmp___1) {
#line 1775
      return (& iwconfig_cmds[i]);
    }
#line 1778
    if ((unsigned long )found == (unsigned long )((void *)0)) {
#line 1780
      found = & iwconfig_cmds[i];
    } else
#line 1783
    if ((unsigned long )iwconfig_cmds[i].fn != (unsigned long )found->fn) {
#line 1784
      ambig = 1;
    }
    __Cont: /* CIL Label */ 
#line 1767
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1787
  if ((unsigned long )found == (unsigned long )((void *)0)) {
    {
#line 1789
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"iwconfig: unknown command \"%s\"\n",
            cmd);
    }
#line 1790
    return ((iwconfig_cmd const   *)((void *)0));
  }
#line 1793
  if (ambig) {
    {
#line 1795
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"iwconfig: command \"%s\" is ambiguous\n",
            cmd);
    }
#line 1796
    return ((iwconfig_cmd const   *)((void *)0));
  }
#line 1799
  return (found);
}
}
#line 1807 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwconfig.c"
static int set_info(int skfd , char **args , int count , char *ifname ) 
{ 
  iwconfig_cmd const   *iwcmd ;
  int ret ;
  int request ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 1817
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1817
    if (! (count > 0)) {
#line 1817
      goto while_break;
    }
    {
#line 1820
    iwcmd = find_command___0((char const   *)*(args + 0));
    }
#line 1821
    if ((unsigned long )iwcmd == (unsigned long )((void *)0)) {
#line 1824
      return (-1);
    }
#line 1828
    args ++;
#line 1829
    count --;
#line 1832
    if (count < (int )iwcmd->min_count) {
#line 1833
      ret = -2;
    } else {
#line 1835
      ret = 0;
    }
#line 1838
    if (! ret) {
      {
#line 1839
      ret = (*(iwcmd->fn))(skfd, ifname, args, count);
      }
    }
#line 1842
    if (ret < 0) {
#line 1844
      request = (int )iwcmd->request;
#line 1845
      if (ret == -7) {
#line 1846
        request ++;
      }
      {
#line 1848
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error for wireless request \"%s\" (%X) :\n",
              iwcmd->name, request);
      }
      {
#line 1852
      if (ret == -2) {
#line 1852
        goto case_neg_2;
      }
#line 1855
      if (ret == -3) {
#line 1855
        goto case_neg_3;
      }
#line 1862
      if (ret == -4) {
#line 1862
        goto case_neg_4;
      }
#line 1865
      if (ret == -5) {
#line 1865
        goto case_neg_5;
      }
#line 1872
      if (ret == -6) {
#line 1872
        goto case_neg_6;
      }
#line 1876
      if (ret == -7) {
#line 1876
        goto case_neg_7;
      }
#line 1850
      goto switch_break;
      case_neg_2: /* CIL Label */ 
      {
#line 1853
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    too few arguments.\n");
      }
#line 1854
      goto switch_break;
      case_neg_3: /* CIL Label */ 
#line 1856
      if (errarg < 0) {
#line 1857
        errarg = 0;
      }
#line 1858
      if (errarg >= count) {
#line 1859
        errarg = count - 1;
      }
      {
#line 1860
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    invalid argument \"%s\".\n",
              *(args + errarg));
      }
#line 1861
      goto switch_break;
      case_neg_4: /* CIL Label */ 
      {
#line 1863
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    argument too big (max %d)\n",
              errmax);
      }
#line 1864
      goto switch_break;
      case_neg_5: /* CIL Label */ 
#line 1866
      if (errarg < 0) {
#line 1867
        errarg = 0;
      }
#line 1868
      if (errarg >= count) {
#line 1869
        errarg = count - 1;
      }
      {
#line 1870
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    conflicting argument \"%s\".\n",
              *(args + errarg));
      }
#line 1871
      goto switch_break;
      case_neg_6: /* CIL Label */ 
      {
#line 1873
      tmp = __errno_location();
#line 1873
      tmp___0 = strerror(*tmp);
#line 1873
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    SET failed on device %-1.16s ; %s.\n",
              ifname, tmp___0);
      }
#line 1875
      goto switch_break;
      case_neg_7: /* CIL Label */ 
      {
#line 1877
      tmp___1 = __errno_location();
#line 1877
      tmp___2 = strerror(*tmp___1);
#line 1877
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    GET failed on device %-1.16s ; %s.\n",
              ifname, tmp___2);
      }
#line 1879
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 1883
      return (ret);
    }
#line 1887
    args += ret;
#line 1888
    count -= ret;
  }
  while_break: /* CIL Label */ ;
  }
#line 1894
  return (0);
}
}
#line 1901 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwconfig.c"
__inline static void ( __attribute__((__always_inline__)) iw_usage___3)(void) 
{ 
  int i ;

  {
  {
#line 1906
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: iwconfig [interface]\n");
#line 1907
  i = 0;
  }
  {
#line 1907
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1907
    if (! ((unsigned long )iwconfig_cmds[i].cmd != (unsigned long )((void *)0))) {
#line 1907
      goto while_break;
    }
    {
#line 1908
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                interface %s %s\n",
            iwconfig_cmds[i].cmd, iwconfig_cmds[i].argsname);
#line 1907
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1910
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"       Check man pages for more details.\n");
  }
#line 1911
  return;
}
}
#line 164 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static int const   families___4[4]  = {      (int const   )2,      (int const   )4,      (int const   )3,      (int const   )5};
#line 381 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static int print_iface_version_info___4(int skfd , char *ifname , char **args , int count ) 
{ 
  struct iwreq wrq ;
  char buffer[sizeof(iwrange ) * 2UL] ;
  struct iw_range *range ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 392
  args = args;
#line 392
  count = count;
#line 396
  tmp = iw_set_ext(skfd, (char const   *)ifname, 35585, & wrq);
  }
#line 396
  if (tmp < 0) {
#line 397
    return (-1);
  }
  {
#line 400
  memset((void *)(buffer), 0, sizeof(buffer));
#line 402
  wrq.u.data.pointer = (void *)(buffer);
#line 403
  wrq.u.data.length = (__u16 )sizeof(buffer);
#line 404
  wrq.u.data.flags = (__u16 )0;
#line 405
  tmp___0 = iw_set_ext(skfd, (char const   *)ifname, 35595, & wrq);
  }
#line 405
  if (tmp___0 < 0) {
    {
#line 408
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  Driver has no Wireless Extension version information.\n\n",
            ifname);
    }
#line 409
    return (0);
  }
#line 413
  range = (struct iw_range *)(buffer);
#line 417
  if ((int )wrq.u.data.length >= 300) {
    {
#line 420
    printf((char const   */* __restrict  */)"%-8.16s  Recommend Wireless Extension v%d or later,\n",
           ifname, (int )range->we_version_source);
#line 422
    printf((char const   */* __restrict  */)"          Currently compiled with Wireless Extension v%d.\n\n",
           (int )range->we_version_compiled);
    }
  } else {
    {
#line 427
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  Wireless Extension version too old.\n\n",
            ifname);
    }
  }
#line 432
  return (0);
}
}
#line 1687 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static int iw_pass_key___4(char const   *input , unsigned char *key ) 
{ 


  {
  {
#line 1691
  input = input;
#line 1691
  key = key;
#line 1692
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Passphrase not implemented\n");
  }
#line 1693
  return (-1);
}
}
#line 2402 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static int const   priv_type_size___4[8]  = 
#line 2402
  {      (int const   )0,      (int const   )1,      (int const   )1,      (int const   )0, 
        (int const   )sizeof(__u32 ),      (int const   )sizeof(struct iw_freq ),      (int const   )sizeof(struct sockaddr ),      (int const   )0};
#line 2480 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static struct iw_ioctl_description  const  standard_ioctl_descr___4[55]  = 
#line 2480
  {      {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )2, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )2}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )5, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )2}, 
        {(__u8 )5, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )4, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )2}, 
        {(__u8 )4, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )sizeof(struct iw_range ),
      (__u32 )1}, 
        {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )8, (unsigned char)0, (__u16 )sizeof(struct sockaddr ), (unsigned short)0,
      (__u16 )8, 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )(sizeof(struct sockaddr ) + sizeof(struct iw_quality )),
      (unsigned short)0, (__u16 )8, 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )sizeof(struct iw_thrspy ), (__u16 )1, (__u16 )1,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )sizeof(struct iw_thrspy ), (__u16 )1, (__u16 )1,
      0U}, 
        {(__u8 )6, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )6, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (__u16 )sizeof(struct iw_mlme ), (__u16 )sizeof(struct iw_mlme ),
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )(sizeof(struct sockaddr ) + sizeof(struct iw_quality )),
      (unsigned short)0, (__u16 )64, (__u32 )8}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (__u16 )0, (__u16 )sizeof(struct iw_scan_req ),
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )4096, (__u32 )8}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )33, (__u32 )2}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )33, (__u32 )1}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )33, 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )33, 0U}, 
        {(unsigned char)0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(unsigned char)0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )0, (unsigned short)0, (__u16 )64, (__u32 )6}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )0, (unsigned short)0, (__u16 )64, (__u32 )5}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )1024, 0U}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )1024, 0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (__u16 )sizeof(struct iw_encode_ext ),
      (__u16 )(sizeof(struct iw_encode_ext ) + 64UL), 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (__u16 )sizeof(struct iw_encode_ext ),
      (__u16 )(sizeof(struct iw_encode_ext ) + 64UL), 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (__u16 )sizeof(struct iw_pmksa ), (__u16 )sizeof(struct iw_pmksa ),
      0U}};
#line 2712 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static unsigned int const   standard_ioctl_num___4  =    (unsigned int const   )(sizeof(standard_ioctl_descr___4) / sizeof(struct iw_ioctl_description ));
#line 2719 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static struct iw_ioctl_description  const  standard_event_descr___4[10]  = 
#line 2719
  {      {(__u8 )6, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )10, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )256, 0U}, 
        {(__u8 )6, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )6, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )1024, 0U}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )sizeof(struct iw_michaelmicfailure ),
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )1024, 0U}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )1024, 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )sizeof(struct iw_pmkid_cand ),
      0U}};
#line 2763 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static unsigned int const   standard_event_num___4  =    (unsigned int const   )(sizeof(standard_event_descr___4) / sizeof(struct iw_ioctl_description ));
#line 2767 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static int const   event_type_size___4[11]  = 
#line 2767
  {      (int const   )4,      (int const   )0,      (int const   )20,      (int const   )0, 
        (int const   )(4UL + sizeof(__u32 )),      (int const   )(4UL + sizeof(struct iw_freq )),      (int const   )(4UL + sizeof(struct sockaddr )),      (int const   )0, 
        (int const   )8,      (int const   )(4UL + sizeof(struct iw_param )),      (int const   )(4UL + sizeof(struct iw_quality ))};
#line 164 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static int const   families___5[4]  = {      (int const   )2,      (int const   )4,      (int const   )3,      (int const   )5};
#line 381 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static int print_iface_version_info___5(int skfd , char *ifname , char **args , int count ) 
{ 
  struct iwreq wrq ;
  char buffer[sizeof(iwrange ) * 2UL] ;
  struct iw_range *range ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 392
  args = args;
#line 392
  count = count;
#line 396
  tmp = iw_set_ext(skfd, (char const   *)ifname, 35585, & wrq);
  }
#line 396
  if (tmp < 0) {
#line 397
    return (-1);
  }
  {
#line 400
  memset((void *)(buffer), 0, sizeof(buffer));
#line 402
  wrq.u.data.pointer = (void *)(buffer);
#line 403
  wrq.u.data.length = (__u16 )sizeof(buffer);
#line 404
  wrq.u.data.flags = (__u16 )0;
#line 405
  tmp___0 = iw_set_ext(skfd, (char const   *)ifname, 35595, & wrq);
  }
#line 405
  if (tmp___0 < 0) {
    {
#line 408
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  Driver has no Wireless Extension version information.\n\n",
            ifname);
    }
#line 409
    return (0);
  }
#line 413
  range = (struct iw_range *)(buffer);
#line 417
  if ((int )wrq.u.data.length >= 300) {
    {
#line 420
    printf((char const   */* __restrict  */)"%-8.16s  Recommend Wireless Extension v%d or later,\n",
           ifname, (int )range->we_version_source);
#line 422
    printf((char const   */* __restrict  */)"          Currently compiled with Wireless Extension v%d.\n\n",
           (int )range->we_version_compiled);
    }
  } else {
    {
#line 427
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  Wireless Extension version too old.\n\n",
            ifname);
    }
  }
#line 432
  return (0);
}
}
#line 1687 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static int iw_pass_key___5(char const   *input , unsigned char *key ) 
{ 


  {
  {
#line 1691
  input = input;
#line 1691
  key = key;
#line 1692
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Passphrase not implemented\n");
  }
#line 1693
  return (-1);
}
}
#line 2402 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static int const   priv_type_size___5[8]  = 
#line 2402
  {      (int const   )0,      (int const   )1,      (int const   )1,      (int const   )0, 
        (int const   )sizeof(__u32 ),      (int const   )sizeof(struct iw_freq ),      (int const   )sizeof(struct sockaddr ),      (int const   )0};
#line 2480 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static struct iw_ioctl_description  const  standard_ioctl_descr___5[55]  = 
#line 2480
  {      {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )2, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )2}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )5, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )2}, 
        {(__u8 )5, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )4, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )2}, 
        {(__u8 )4, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )sizeof(struct iw_range ),
      (__u32 )1}, 
        {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )8, (unsigned char)0, (__u16 )sizeof(struct sockaddr ), (unsigned short)0,
      (__u16 )8, 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )(sizeof(struct sockaddr ) + sizeof(struct iw_quality )),
      (unsigned short)0, (__u16 )8, 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )sizeof(struct iw_thrspy ), (__u16 )1, (__u16 )1,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )sizeof(struct iw_thrspy ), (__u16 )1, (__u16 )1,
      0U}, 
        {(__u8 )6, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )6, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (__u16 )sizeof(struct iw_mlme ), (__u16 )sizeof(struct iw_mlme ),
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )(sizeof(struct sockaddr ) + sizeof(struct iw_quality )),
      (unsigned short)0, (__u16 )64, (__u32 )8}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (__u16 )0, (__u16 )sizeof(struct iw_scan_req ),
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )4096, (__u32 )8}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )33, (__u32 )2}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )33, (__u32 )1}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )33, 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )33, 0U}, 
        {(unsigned char)0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(unsigned char)0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )0, (unsigned short)0, (__u16 )64, (__u32 )6}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )0, (unsigned short)0, (__u16 )64, (__u32 )5}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )1024, 0U}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )1024, 0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (__u16 )sizeof(struct iw_encode_ext ),
      (__u16 )(sizeof(struct iw_encode_ext ) + 64UL), 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (__u16 )sizeof(struct iw_encode_ext ),
      (__u16 )(sizeof(struct iw_encode_ext ) + 64UL), 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (__u16 )sizeof(struct iw_pmksa ), (__u16 )sizeof(struct iw_pmksa ),
      0U}};
#line 2712 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static unsigned int const   standard_ioctl_num___5  =    (unsigned int const   )(sizeof(standard_ioctl_descr___5) / sizeof(struct iw_ioctl_description ));
#line 2719 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static struct iw_ioctl_description  const  standard_event_descr___5[10]  = 
#line 2719
  {      {(__u8 )6, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )10, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )256, 0U}, 
        {(__u8 )6, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )6, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )1024, 0U}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )sizeof(struct iw_michaelmicfailure ),
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )1024, 0U}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )1024, 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )sizeof(struct iw_pmkid_cand ),
      0U}};
#line 2763 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static unsigned int const   standard_event_num___5  =    (unsigned int const   )(sizeof(standard_event_descr___5) / sizeof(struct iw_ioctl_description ));
#line 2767 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static int const   event_type_size___5[11]  = 
#line 2767
  {      (int const   )4,      (int const   )0,      (int const   )20,      (int const   )0, 
        (int const   )(4UL + sizeof(__u32 )),      (int const   )(4UL + sizeof(struct iw_freq )),      (int const   )(4UL + sizeof(struct sockaddr )),      (int const   )0, 
        (int const   )8,      (int const   )(4UL + sizeof(struct iw_param )),      (int const   )(4UL + sizeof(struct iw_quality ))};
#line 21 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwspy.c"
static int print_spy_info(int skfd , char *ifname , char **args , int count ) 
{ 
  struct iwreq wrq ;
  char buffer[(sizeof(struct iw_quality ) + sizeof(struct sockaddr )) * 8UL] ;
  char temp[128] ;
  struct sockaddr *hwa ;
  struct iw_quality *qual ;
  iwrange range ;
  int has_range ;
  int n ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  iwstats stats ;
  int tmp___3 ;

  {
  {
#line 34
  has_range = 0;
#line 39
  args = args;
#line 39
  count = count;
#line 42
  wrq.u.data.pointer = (void *)(buffer);
#line 43
  wrq.u.data.length = (__u16 )8;
#line 44
  wrq.u.data.flags = (__u16 )0;
#line 45
  tmp = iw_set_ext(skfd, (char const   *)ifname, 35601, & wrq);
  }
#line 45
  if (tmp < 0) {
    {
#line 47
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  Interface doesn\'t support wireless statistic collection\n\n",
            ifname);
    }
#line 48
    return (-1);
  }
  {
#line 52
  n = (int )wrq.u.data.length;
#line 55
  tmp___0 = iw_check_mac_addr_type(skfd, (char const   *)ifname);
  }
#line 55
  if (tmp___0 < 0) {
    {
#line 57
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  Interface doesn\'t support MAC addresses\n\n",
            ifname);
    }
#line 58
    return (-2);
  }
  {
#line 62
  tmp___1 = iw_get_range_info(skfd, (char const   *)ifname, & range);
  }
#line 62
  if (tmp___1 >= 0) {
#line 63
    has_range = 1;
  }
#line 66
  if (n == 0) {
    {
#line 67
    printf((char const   */* __restrict  */)"%-8.16s  No statistics to collect\n",
           ifname);
    }
  } else {
    {
#line 69
    printf((char const   */* __restrict  */)"%-8.16s  Statistics collected:\n", ifname);
    }
  }
#line 72
  hwa = (struct sockaddr *)(buffer);
#line 73
  qual = (struct iw_quality *)(buffer + sizeof(struct sockaddr ) * (unsigned long )n);
#line 75
  i = 0;
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    if (! (i < n)) {
#line 75
      goto while_break;
    }
    {
#line 78
    tmp___2 = iw_saether_ntop((struct sockaddr  const  *)(hwa + i), temp);
#line 78
    printf((char const   */* __restrict  */)"    %s : ", tmp___2);
#line 79
    iw_print_stats(temp, (int )sizeof(temp), (iwqual const   *)(qual + i), (iwrange const   *)(& range),
                   has_range);
#line 80
    printf((char const   */* __restrict  */)"%s\n", temp);
#line 75
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  if (n > 0) {
#line 83
    if (has_range) {
#line 83
      if ((int )range.we_version_compiled > 11) {
        {
#line 88
        tmp___3 = iw_get_stats(skfd, (char const   *)ifname, & stats, (iwrange const   *)(& range),
                               has_range);
        }
#line 88
        if (tmp___3 >= 0) {
          {
#line 90
          iw_print_stats(temp, (int )sizeof(temp), (iwqual const   *)(& stats.qual),
                         (iwrange const   *)(& range), has_range);
#line 91
          printf((char const   */* __restrict  */)"    Link/Cell/AP      : %s\n",
                 temp);
#line 93
          iw_print_stats(temp, (int )sizeof(temp), (iwqual const   *)(& range.avg_qual),
                         (iwrange const   *)(& range), has_range);
#line 95
          printf((char const   */* __restrict  */)"    Typical/Reference : %s\n",
                 temp);
          }
        }
      }
    }
  }
  {
#line 99
  printf((char const   */* __restrict  */)"\n");
  }
#line 100
  return (0);
}
}
#line 107 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwspy.c"
static int get_spy_threshold(int skfd , char *ifname , char **args , int count ) 
{ 
  struct iwreq wrq ;
  struct iw_thrspy threshold ;
  iwrange range ;
  int has_range ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 116
  has_range = 0;
#line 119
  args = args;
#line 119
  count = count;
#line 122
  wrq.u.data.pointer = (void *)((caddr_t )(& threshold));
#line 123
  wrq.u.data.length = (__u16 )1;
#line 124
  wrq.u.data.flags = (__u16 )0;
#line 125
  tmp___1 = iw_set_ext(skfd, (char const   *)ifname, 35603, & wrq);
  }
#line 125
  if (tmp___1 < 0) {
    {
#line 127
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Interface doesn\'t support thresholds...\n");
#line 128
    tmp = __errno_location();
#line 128
    tmp___0 = strerror(*tmp);
#line 128
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SIOCGIWTHRSPY: %s\n",
            tmp___0);
    }
#line 129
    return (-1);
  }
  {
#line 133
  tmp___2 = iw_get_range_info(skfd, (char const   *)ifname, & range);
  }
#line 133
  if (tmp___2 >= 0) {
#line 134
    has_range = 1;
  }
#line 137
  if (has_range) {
#line 137
    if (threshold.low.level) {
#line 140
      if ((int )threshold.low.level > (int )range.max_qual.level) {
        {
#line 143
        printf((char const   */* __restrict  */)"%-8.16s  Low threshold:%d dBm  High threshold:%d dBm\n\n",
               ifname, (int )threshold.low.level - 256, (int )threshold.high.level - 256);
        }
      } else {
        {
#line 150
        printf((char const   */* __restrict  */)"%-8.16s  Low threshold:%d/%d  High threshold:%d/%d\n\n",
               ifname, (int )threshold.low.level, (int )range.max_qual.level, (int )threshold.high.level,
               (int )range.max_qual.level);
        }
      }
    } else {
      {
#line 159
      printf((char const   */* __restrict  */)"%-8.16s  Low threshold:%d  High threshold:%d\n\n",
             ifname, (int )threshold.low.level, (int )threshold.high.level);
      }
    }
  } else {
    {
#line 159
    printf((char const   */* __restrict  */)"%-8.16s  Low threshold:%d  High threshold:%d\n\n",
           ifname, (int )threshold.low.level, (int )threshold.high.level);
    }
  }
#line 164
  return (0);
}
}
#line 173 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwspy.c"
static int set_spy_info(int skfd , char *ifname , char **args , int count ) 
{ 
  struct iwreq wrq ;
  int i ;
  int nbr ;
  struct sockaddr hw_address[8] ;
  char buffer[(sizeof(struct iw_quality ) + sizeof(struct sockaddr )) * 8UL] ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;

  {
  {
#line 185
  i = 0;
#line 186
  nbr = 0;
#line 189
  tmp___6 = strcmp((char const   *)*(args + 0), "off");
  }
#line 189
  if (tmp___6) {
    {
#line 194
    tmp___3 = strcmp((char const   *)*(args + 0), "+");
    }
#line 194
    if (! tmp___3) {
      {
#line 200
      tmp = iw_check_mac_addr_type(skfd, (char const   *)ifname);
      }
#line 200
      if (tmp < 0) {
        {
#line 202
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  Interface doesn\'t support MAC addresses\n",
                ifname);
        }
#line 203
        return (-1);
      }
      {
#line 206
      wrq.u.data.pointer = (void *)(buffer);
#line 207
      wrq.u.data.length = (__u16 )8;
#line 208
      wrq.u.data.flags = (__u16 )0;
#line 209
      tmp___2 = iw_set_ext(skfd, (char const   *)ifname, 35601, & wrq);
      }
#line 209
      if (tmp___2 < 0) {
        {
#line 211
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Interface doesn\'t accept reading addresses...\n");
#line 212
        tmp___0 = __errno_location();
#line 212
        tmp___1 = strerror(*tmp___0);
#line 212
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SIOCGIWSPY: %s\n",
                tmp___1);
        }
#line 213
        return (-1);
      }
      {
#line 217
      nbr = (int )wrq.u.data.length;
#line 218
      memcpy((void */* __restrict  */)(hw_address), (void const   */* __restrict  */)(buffer),
             (unsigned long )nbr * sizeof(struct sockaddr ));
#line 220
      i = 1;
      }
    }
    {
#line 224
    while (1) {
      while_continue: /* CIL Label */ ;
#line 224
      if (i < count) {
#line 224
        if (! (nbr < 8)) {
#line 224
          goto while_break;
        }
      } else {
#line 224
        goto while_break;
      }
      {
#line 227
      tmp___4 = i;
#line 227
      i ++;
#line 227
      tmp___5 = iw_in_addr(skfd, (char const   *)ifname, *(args + tmp___4), & hw_address[nbr]);
      }
#line 227
      if (tmp___5 < 0) {
#line 228
        goto while_continue;
      }
#line 229
      nbr ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 233
    if (nbr == 0) {
      {
#line 235
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No valid addresses found : exiting...\n");
      }
#line 236
      return (-1);
    }
  } else {
#line 190
    i = 1;
  }
#line 241
  if (i < count) {
    {
#line 243
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Got only the first %d arguments, remaining discarded\n",
            i);
    }
  }
  {
#line 247
  wrq.u.data.pointer = (void *)((caddr_t )(hw_address));
#line 248
  wrq.u.data.length = (__u16 )nbr;
#line 249
  wrq.u.data.flags = (__u16 )0;
#line 250
  tmp___9 = iw_set_ext(skfd, (char const   *)ifname, 35600, & wrq);
  }
#line 250
  if (tmp___9 < 0) {
    {
#line 252
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Interface doesn\'t accept addresses...\n");
#line 253
    tmp___7 = __errno_location();
#line 253
    tmp___8 = strerror(*tmp___7);
#line 253
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SIOCSIWSPY: %s\n",
            tmp___8);
    }
#line 254
    return (-1);
  }
#line 257
  return (0);
}
}
#line 264 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwspy.c"
static int set_spy_threshold(int skfd , char *ifname , char **args , int count ) 
{ 
  struct iwreq wrq ;
  struct iw_thrspy threshold ;
  int low_thr ;
  int high_thr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 276
  memset((void *)(& threshold), '\000', sizeof(threshold));
#line 279
  tmp___1 = strcmp((char const   *)*(args + 0), "off");
  }
#line 279
  if (tmp___1) {
#line 286
    if (count < 2) {
      {
#line 288
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  Need two threshold values\n",
              ifname);
      }
#line 289
      return (-1);
    }
    {
#line 291
    tmp = sscanf((char const   */* __restrict  */)*(args + 0), (char const   */* __restrict  */)"%i",
                 & low_thr);
    }
#line 291
    if (tmp != 1) {
      {
#line 294
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  Invalid threshold values\n",
              ifname);
      }
#line 295
      return (-1);
    } else {
      {
#line 291
      tmp___0 = sscanf((char const   */* __restrict  */)*(args + 1), (char const   */* __restrict  */)"%i",
                       & high_thr);
      }
#line 291
      if (tmp___0 != 1) {
        {
#line 294
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  Invalid threshold values\n",
                ifname);
        }
#line 295
        return (-1);
      }
    }
#line 298
    if (high_thr < low_thr) {
      {
#line 300
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  Inverted threshold range\n",
              ifname);
      }
#line 301
      return (-1);
    }
#line 304
    threshold.low.level = (__u8 )low_thr;
#line 305
    threshold.low.updated = (__u8 )2;
#line 306
    threshold.high.level = (__u8 )high_thr;
#line 307
    threshold.high.updated = (__u8 )2;
  }
  {
#line 311
  wrq.u.data.pointer = (void *)((caddr_t )(& threshold));
#line 312
  wrq.u.data.length = (__u16 )1;
#line 313
  wrq.u.data.flags = (__u16 )0;
#line 314
  tmp___4 = iw_set_ext(skfd, (char const   *)ifname, 35602, & wrq);
  }
#line 314
  if (tmp___4 < 0) {
    {
#line 316
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Interface doesn\'t accept thresholds...\n");
#line 317
    tmp___2 = __errno_location();
#line 317
    tmp___3 = strerror(*tmp___2);
#line 317
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SIOCSIWTHRSPY: %s\n",
            tmp___3);
    }
#line 318
    return (-1);
  }
#line 321
  return (0);
}
}
#line 164 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static int const   families___6[4]  = {      (int const   )2,      (int const   )4,      (int const   )3,      (int const   )5};
#line 381 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static int print_iface_version_info___6(int skfd , char *ifname , char **args , int count ) 
{ 
  struct iwreq wrq ;
  char buffer[sizeof(iwrange ) * 2UL] ;
  struct iw_range *range ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 392
  args = args;
#line 392
  count = count;
#line 396
  tmp = iw_set_ext(skfd, (char const   *)ifname, 35585, & wrq);
  }
#line 396
  if (tmp < 0) {
#line 397
    return (-1);
  }
  {
#line 400
  memset((void *)(buffer), 0, sizeof(buffer));
#line 402
  wrq.u.data.pointer = (void *)(buffer);
#line 403
  wrq.u.data.length = (__u16 )sizeof(buffer);
#line 404
  wrq.u.data.flags = (__u16 )0;
#line 405
  tmp___0 = iw_set_ext(skfd, (char const   *)ifname, 35595, & wrq);
  }
#line 405
  if (tmp___0 < 0) {
    {
#line 408
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  Driver has no Wireless Extension version information.\n\n",
            ifname);
    }
#line 409
    return (0);
  }
#line 413
  range = (struct iw_range *)(buffer);
#line 417
  if ((int )wrq.u.data.length >= 300) {
    {
#line 420
    printf((char const   */* __restrict  */)"%-8.16s  Recommend Wireless Extension v%d or later,\n",
           ifname, (int )range->we_version_source);
#line 422
    printf((char const   */* __restrict  */)"          Currently compiled with Wireless Extension v%d.\n\n",
           (int )range->we_version_compiled);
    }
  } else {
    {
#line 427
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8.16s  Wireless Extension version too old.\n\n",
            ifname);
    }
  }
#line 432
  return (0);
}
}
#line 1687 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static int iw_pass_key___6(char const   *input , unsigned char *key ) 
{ 


  {
  {
#line 1691
  input = input;
#line 1691
  key = key;
#line 1692
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Passphrase not implemented\n");
  }
#line 1693
  return (-1);
}
}
#line 2402 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static int const   priv_type_size___6[8]  = 
#line 2402
  {      (int const   )0,      (int const   )1,      (int const   )1,      (int const   )0, 
        (int const   )sizeof(__u32 ),      (int const   )sizeof(struct iw_freq ),      (int const   )sizeof(struct sockaddr ),      (int const   )0};
#line 2480 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static struct iw_ioctl_description  const  standard_ioctl_descr___6[55]  = 
#line 2480
  {      {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )2, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )2}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )5, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )2}, 
        {(__u8 )5, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )4, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )2}, 
        {(__u8 )4, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )sizeof(struct iw_range ),
      (__u32 )1}, 
        {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )8, (unsigned char)0, (__u16 )sizeof(struct sockaddr ), (unsigned short)0,
      (__u16 )8, 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )(sizeof(struct sockaddr ) + sizeof(struct iw_quality )),
      (unsigned short)0, (__u16 )8, 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )sizeof(struct iw_thrspy ), (__u16 )1, (__u16 )1,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )sizeof(struct iw_thrspy ), (__u16 )1, (__u16 )1,
      0U}, 
        {(__u8 )6, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )6, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u32 )1}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (__u16 )sizeof(struct iw_mlme ), (__u16 )sizeof(struct iw_mlme ),
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )(sizeof(struct sockaddr ) + sizeof(struct iw_quality )),
      (unsigned short)0, (__u16 )64, (__u32 )8}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (__u16 )0, (__u16 )sizeof(struct iw_scan_req ),
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )4096, (__u32 )8}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )33, (__u32 )2}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )33, (__u32 )1}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )33, 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )33, 0U}, 
        {(unsigned char)0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(unsigned char)0, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )0, (unsigned short)0, (__u16 )64, (__u32 )6}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )0, (unsigned short)0, (__u16 )64, (__u32 )5}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )1024, 0U}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )1024, 0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )9, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (__u16 )sizeof(struct iw_encode_ext ),
      (__u16 )(sizeof(struct iw_encode_ext ) + 64UL), 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (__u16 )sizeof(struct iw_encode_ext ),
      (__u16 )(sizeof(struct iw_encode_ext ) + 64UL), 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (__u16 )sizeof(struct iw_pmksa ), (__u16 )sizeof(struct iw_pmksa ),
      0U}};
#line 2712 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static unsigned int const   standard_ioctl_num___6  =    (unsigned int const   )(sizeof(standard_ioctl_descr___6) / sizeof(struct iw_ioctl_description ));
#line 2719 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static struct iw_ioctl_description  const  standard_event_descr___6[10]  = 
#line 2719
  {      {(__u8 )6, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )10, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )256, 0U}, 
        {(__u8 )6, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )6, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )1024, 0U}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )sizeof(struct iw_michaelmicfailure ),
      0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )1024, 0U}, 
        {(__u8 )8,
      (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )1024, 0U}, 
        {(__u8 )8, (unsigned char)0, (__u16 )1, (unsigned short)0, (__u16 )sizeof(struct iw_pmkid_cand ),
      0U}};
#line 2763 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static unsigned int const   standard_event_num___6  =    (unsigned int const   )(sizeof(standard_event_descr___6) / sizeof(struct iw_ioctl_description ));
#line 2767 "/home/june/repo/benchmarks/collector2/temp/wireless-tools-30~pre9/iwlib.c"
static int const   event_type_size___6[11]  = 
#line 2767
  {      (int const   )4,      (int const   )0,      (int const   )20,      (int const   )0, 
        (int const   )(4UL + sizeof(__u32 )),      (int const   )(4UL + sizeof(struct iw_freq )),      (int const   )(4UL + sizeof(struct sockaddr )),      (int const   )0, 
        (int const   )8,      (int const   )(4UL + sizeof(struct iw_param )),      (int const   )(4UL + sizeof(struct iw_quality ))};
