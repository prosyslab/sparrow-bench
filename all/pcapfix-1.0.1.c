/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef int int32_t;
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 9 "/home/wheatley/newnew/temp/pcapfix-1.0.1/pcap.h"
struct global_hdr_s {
   u_int32_t magic_number ;
   u_short version_major ;
   u_short version_minor ;
   int32_t thiszone ;
   u_int32_t sigfigs ;
   u_int32_t snaplen ;
   u_int32_t network ;
};
#line 20 "/home/wheatley/newnew/temp/pcapfix-1.0.1/pcap.h"
struct packet_hdr_s {
   u_int32_t ts_sec ;
   u_int32_t ts_usec ;
   u_int32_t incl_len ;
   u_int32_t orig_len ;
};
#line 197 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef long int64_t;
#line 5 "/home/wheatley/newnew/temp/pcapfix-1.0.1/pcapng.c"
struct block_header {
   u_int32_t block_type ;
   u_int32_t total_length ;
};
#line 11 "/home/wheatley/newnew/temp/pcapfix-1.0.1/pcapng.c"
struct option_header {
   u_short option_code ;
   u_short option_length ;
};
#line 17 "/home/wheatley/newnew/temp/pcapfix-1.0.1/pcapng.c"
struct section_header_block {
   u_int32_t byte_order_magic ;
   u_short major_version ;
   u_short minor_version ;
   int64_t section_length ;
};
#line 25 "/home/wheatley/newnew/temp/pcapfix-1.0.1/pcapng.c"
struct interface_description_block {
   u_short linktype ;
   u_short reserved ;
   u_int32_t snaplen ;
};
#line 32 "/home/wheatley/newnew/temp/pcapfix-1.0.1/pcapng.c"
struct packet_block {
   u_short interface_id ;
   u_short drops_count ;
   u_int32_t timestamp_high ;
   u_int32_t timestamp_low ;
   u_int32_t caplen ;
   u_int32_t len ;
};
#line 42 "/home/wheatley/newnew/temp/pcapfix-1.0.1/pcapng.c"
struct simple_packet_block {
   u_int32_t len ;
};
#line 47 "/home/wheatley/newnew/temp/pcapfix-1.0.1/pcapng.c"
struct name_resolution_block {
   u_short record_type ;
   u_short record_length ;
};
#line 53 "/home/wheatley/newnew/temp/pcapfix-1.0.1/pcapng.c"
struct interface_statistics_block {
   u_int32_t interface_id ;
   u_int32_t timestamp_high ;
   u_int32_t timestamp_low ;
};
#line 60 "/home/wheatley/newnew/temp/pcapfix-1.0.1/pcapng.c"
struct enhanced_packet_block {
   u_int32_t interface_id ;
   u_int32_t timestamp_high ;
   u_int32_t timestamp_low ;
   u_int32_t caplen ;
   u_int32_t len ;
};
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 377 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 36 "/home/wheatley/newnew/temp/pcapfix-1.0.1/pcapfix.h"
extern unsigned short conshort(unsigned short var ) ;
#line 51
extern unsigned int conint(unsigned int var ) ;
#line 62
extern void print_progress(unsigned long pos , unsigned long filesize ) ;
#line 65
extern int deep_scan ;
#line 66
extern int verbose ;
#line 67
extern int swapped ;
#line 68
extern int data_link_type ;
#line 44 "/home/wheatley/newnew/temp/pcapfix-1.0.1/pcap.h"
int is_plausible(struct packet_hdr_s hdr , unsigned int prior_ts ) ;
#line 60
int check_header(char *buffer , unsigned int size , unsigned int prior_ts , struct packet_hdr_s *hdr ) ;
#line 77
int fix_pcap(FILE *pcap , FILE *pcap_fix ) ;
#line 4 "/home/wheatley/newnew/temp/pcapfix-1.0.1/pcap.c"
int nanoseconds  =    0;
#line 23 "/home/wheatley/newnew/temp/pcapfix-1.0.1/pcap.c"
int is_plausible(struct packet_hdr_s hdr , unsigned int prior_ts ) 
{ 
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;

  {
  {
#line 27
  tmp = conint(hdr.incl_len);
  }
#line 27
  if (tmp < 10U) {
#line 27
    return (-1);
  }
  {
#line 28
  tmp___0 = conint(hdr.orig_len);
  }
#line 28
  if (tmp___0 < 10U) {
#line 28
    return (-2);
  }
  {
#line 31
  tmp___1 = conint(hdr.incl_len);
  }
#line 31
  if (tmp___1 > 65535U) {
#line 31
    return (-3);
  }
  {
#line 32
  tmp___2 = conint(hdr.orig_len);
  }
#line 32
  if (tmp___2 > 65535U) {
#line 32
    return (-4);
  }
  {
#line 35
  tmp___3 = conint(hdr.incl_len);
#line 35
  tmp___4 = conint(hdr.orig_len);
  }
#line 35
  if (tmp___3 > tmp___4) {
#line 35
    return (-5);
  }
#line 38
  if (prior_ts != 0U) {
    {
#line 38
    tmp___5 = conint(hdr.ts_sec);
    }
#line 38
    if (tmp___5 > prior_ts + 86400U) {
#line 38
      return (-6);
    }
  }
#line 41
  if (prior_ts >= 86400U) {
    {
#line 41
    tmp___6 = conint(hdr.ts_sec);
    }
#line 41
    if (tmp___6 < prior_ts - 86400U) {
#line 41
      return (-7);
    }
  }
#line 44
  if (nanoseconds == 0) {
    {
#line 46
    tmp___7 = conint(hdr.ts_usec);
    }
#line 46
    if (tmp___7 > 1000000U) {
#line 46
      return (-8);
    }
  } else {
    {
#line 49
    tmp___8 = conint(hdr.ts_usec);
    }
#line 49
    if (tmp___8 > 1000000000U) {
#line 49
      return (-9);
    }
  }
#line 53
  return (0);
}
}
#line 70 "/home/wheatley/newnew/temp/pcapfix-1.0.1/pcap.c"
int check_header(char *buffer , unsigned int size , unsigned int prior_ts , struct packet_hdr_s *hdr ) 
{ 
  unsigned int i ;
  int res ;
  char *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 76
  memcpy((void */* __restrict  */)hdr, (void const   */* __restrict  */)buffer, sizeof(struct packet_hdr_s ));
#line 77
  tmp___0 = is_plausible(*hdr, prior_ts);
  }
#line 77
  if (tmp___0 == 0) {
#line 77
    return (0);
  }
#line 81
  if (size <= 25U) {
#line 81
    return (-1);
  }
#line 84
  i = 0U;
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! ((unsigned long )i < sizeof(struct packet_hdr_s ))) {
#line 84
      goto while_break;
    }
#line 86
    if ((int )*(buffer + i) == 13) {
#line 86
      if ((int )*(buffer + (i + 1U)) == 10) {
        {
#line 89
        tmp___1 = malloc((size_t )size);
#line 89
        tmp = (char *)tmp___1;
#line 92
        memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)buffer,
               (size_t )i);
#line 93
        memcpy((void */* __restrict  */)(tmp + i), (void const   */* __restrict  */)((buffer + i) + 1),
               (size_t )((size - i) - 1U));
#line 96
        res = check_header(tmp, size - 1U, prior_ts, hdr);
#line 99
        free((void *)tmp);
        }
#line 102
        if (res != -1) {
#line 102
          return (res + 1);
        }
      }
    }
#line 84
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  return (-1);
}
}
#line 125 "/home/wheatley/newnew/temp/pcapfix-1.0.1/pcap.c"
int fix_pcap(FILE *pcap , FILE *pcap_fix ) 
{ 
  struct global_hdr_s global_hdr ;
  struct packet_hdr_s packet_hdr ;
  struct packet_hdr_s next_packet_hdr ;
  char hdrbuffer[sizeof(packet_hdr) * 2UL] ;
  char buffer[65535] ;
  unsigned long pos ;
  unsigned long nextpos ;
  unsigned long bytes ;
  unsigned long filesize ;
  unsigned int count ;
  unsigned int step ;
  unsigned int last_correct_ts_sec ;
  unsigned int last_correct_ts_usec ;
  unsigned short hdr_integ ;
  int ascii ;
  int corrupted ;
  int res ;
  long tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  unsigned short tmp___2 ;
  unsigned short tmp___3 ;
  unsigned short tmp___4 ;
  unsigned short tmp___5 ;
  unsigned short tmp___6 ;
  unsigned short tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned short tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;
  unsigned int tmp___15 ;
  unsigned int tmp___16 ;
  unsigned int tmp___17 ;
  unsigned int tmp___18 ;
  unsigned int tmp___19 ;
  unsigned int tmp___20 ;
  unsigned int tmp___21 ;
  long tmp___22 ;
  unsigned int tmp___23 ;
  unsigned int tmp___24 ;
  unsigned int tmp___25 ;
  unsigned int tmp___26 ;
  unsigned int tmp___27 ;
  unsigned int tmp___28 ;
  unsigned int tmp___29 ;
  unsigned int tmp___30 ;
  unsigned int tmp___31 ;
  unsigned int tmp___32 ;
  unsigned int tmp___33 ;
  size_t tmp___34 ;
  unsigned int tmp___35 ;
  unsigned int tmp___36 ;
  unsigned int tmp___37 ;
  unsigned int tmp___38 ;
  unsigned int tmp___39 ;
  unsigned int tmp___40 ;
  unsigned int tmp___41 ;
  unsigned int tmp___42 ;
  unsigned int tmp___43 ;
  unsigned int tmp___44 ;
  unsigned int tmp___45 ;
  unsigned int tmp___46 ;
  unsigned int tmp___47 ;
  unsigned int tmp___48 ;
  unsigned int tmp___49 ;
  unsigned int tmp___50 ;
  unsigned int tmp___51 ;
  unsigned int tmp___52 ;
  unsigned int tmp___53 ;
  unsigned int tmp___54 ;
  int tmp___55 ;
  unsigned int tmp___56 ;
  unsigned int tmp___57 ;
  unsigned int tmp___58 ;
  unsigned int tmp___59 ;
  unsigned int tmp___60 ;
  unsigned int tmp___61 ;
  unsigned int tmp___62 ;
  unsigned int tmp___63 ;
  unsigned int tmp___64 ;
  unsigned int tmp___65 ;
  unsigned int tmp___66 ;
  unsigned int tmp___67 ;
  unsigned int tmp___68 ;
  unsigned int tmp___69 ;
  unsigned int tmp___70 ;
  unsigned int tmp___71 ;
  size_t tmp___72 ;
  unsigned int tmp___73 ;
  unsigned int tmp___74 ;
  unsigned int tmp___75 ;
  unsigned int tmp___76 ;
  unsigned int tmp___77 ;
  unsigned int tmp___78 ;
  unsigned int tmp___79 ;
  unsigned int tmp___80 ;
  unsigned int tmp___81 ;
  unsigned int tmp___82 ;
  unsigned int tmp___83 ;
  unsigned int tmp___84 ;
  unsigned int tmp___85 ;
  unsigned int tmp___86 ;
  unsigned int tmp___87 ;
  unsigned int tmp___88 ;
  unsigned int tmp___89 ;
  unsigned int tmp___90 ;
  unsigned int tmp___91 ;
  unsigned int tmp___92 ;
  unsigned int tmp___93 ;
  unsigned int tmp___94 ;
  long tmp___95 ;

  {
  {
#line 133
  pos = 0UL;
#line 134
  nextpos = 0UL;
#line 138
  step = 1U;
#line 139
  last_correct_ts_sec = 0U;
#line 140
  last_correct_ts_usec = 0U;
#line 143
  ascii = 0;
#line 144
  corrupted = 0;
#line 148
  fseek(pcap, 0L, 2);
#line 149
  tmp = ftell(pcap);
#line 149
  filesize = (unsigned long )tmp;
#line 150
  fseek(pcap, 0L, 0);
#line 154
  printf((char const   */* __restrict  */)"[*] Analyzing Global Header...\n");
#line 155
  bytes = fread((void */* __restrict  */)(& global_hdr), sizeof(global_hdr), (size_t )1,
                (FILE */* __restrict  */)pcap);
  }
#line 156
  if (bytes != 1UL) {
#line 156
    return (-3);
  }
#line 159
  hdr_integ = (unsigned short)0;
#line 162
  if (global_hdr.magic_number == 2712847316U) {
#line 164
    if (verbose) {
      {
#line 164
      printf((char const   */* __restrict  */)"[+] Magic number: 0x%x\n", global_hdr.magic_number);
      }
    }
  } else {
    {
#line 165
    tmp___1 = htonl(2712847316U);
    }
#line 165
    if (global_hdr.magic_number == tmp___1) {
#line 167
      if (verbose) {
        {
#line 167
        printf((char const   */* __restrict  */)"[+] Magic number: 0x%x (SWAPPED)\n",
               global_hdr.magic_number);
        }
      }
#line 168
      swapped = 1;
    } else
#line 169
    if (global_hdr.magic_number == 2712812621U) {
#line 171
      if (verbose) {
        {
#line 171
        printf((char const   */* __restrict  */)"[+] Magic number: 0x%x (NANOSECONDS)\n",
               global_hdr.magic_number);
        }
      }
#line 172
      nanoseconds = 1;
    } else {
      {
#line 173
      tmp___0 = htonl(2712812621U);
      }
#line 173
      if (global_hdr.magic_number == tmp___0) {
#line 175
        if (verbose) {
          {
#line 175
          printf((char const   */* __restrict  */)"[+] Magic number: 0x%x (SWAPPED - NANOSECONDS)\n",
                 global_hdr.magic_number);
          }
        }
#line 176
        swapped = 1;
#line 177
        nanoseconds = 1;
      } else {
#line 180
        hdr_integ = (unsigned short )((int )hdr_integ + 1);
#line 181
        if (verbose) {
          {
#line 181
          printf((char const   */* __restrict  */)"[-] Magic number: 0x%x\n", global_hdr.magic_number);
          }
        }
#line 184
        global_hdr.magic_number = 2712847316U;
      }
    }
  }
  {
#line 188
  tmp___4 = conshort(global_hdr.version_major);
  }
#line 188
  if ((int )tmp___4 == 2) {
#line 189
    if (verbose) {
      {
#line 189
      tmp___2 = conshort(global_hdr.version_major);
#line 189
      printf((char const   */* __restrict  */)"[+] Major version number: %hu\n", (int )tmp___2);
      }
    }
  } else {
#line 191
    hdr_integ = (unsigned short )((int )hdr_integ + 1);
#line 192
    if (verbose) {
      {
#line 192
      tmp___3 = conshort(global_hdr.version_major);
#line 192
      printf((char const   */* __restrict  */)"[-] Major version number: %hu\n", (int )tmp___3);
      }
    }
    {
#line 193
    global_hdr.version_major = conshort((unsigned short)2);
    }
  }
  {
#line 197
  tmp___7 = conshort(global_hdr.version_minor);
  }
#line 197
  if ((int )tmp___7 == 4) {
#line 198
    if (verbose) {
      {
#line 198
      tmp___5 = conshort(global_hdr.version_minor);
#line 198
      printf((char const   */* __restrict  */)"[+] Minor version number: %hu\n", (int )tmp___5);
      }
    }
  } else {
#line 200
    hdr_integ = (unsigned short )((int )hdr_integ + 1);
#line 201
    if (verbose) {
      {
#line 201
      tmp___6 = conshort(global_hdr.version_minor);
#line 201
      printf((char const   */* __restrict  */)"[-] Minor version number: %hu\n", (int )tmp___6);
      }
    }
    {
#line 202
    global_hdr.version_minor = conshort((unsigned short)4);
    }
  }
  {
#line 206
  tmp___11 = conshort((unsigned short )global_hdr.thiszone);
  }
#line 206
  if ((int )tmp___11 == 0) {
#line 207
    if (verbose) {
      {
#line 207
      tmp___8 = conint((unsigned int )global_hdr.thiszone);
#line 207
      printf((char const   */* __restrict  */)"[+] GTM to local correction: %d\n",
             tmp___8);
      }
    }
  } else {
#line 209
    hdr_integ = (unsigned short )((int )hdr_integ + 1);
#line 210
    if (verbose) {
      {
#line 210
      tmp___9 = conint((unsigned int )global_hdr.thiszone);
#line 210
      printf((char const   */* __restrict  */)"[-] GTM to local correction: %d\n",
             tmp___9);
      }
    }
    {
#line 211
    tmp___10 = conint(0U);
#line 211
    global_hdr.thiszone = (int32_t )tmp___10;
    }
  }
  {
#line 215
  tmp___14 = conint(global_hdr.sigfigs);
  }
#line 215
  if (tmp___14 == 0U) {
#line 216
    if (verbose) {
      {
#line 216
      tmp___12 = conint(global_hdr.sigfigs);
#line 216
      printf((char const   */* __restrict  */)"[+] Accuracy of timestamps: %u\n",
             tmp___12);
      }
    }
  } else {
#line 218
    hdr_integ = (unsigned short )((int )hdr_integ + 1);
#line 219
    if (verbose) {
      {
#line 219
      tmp___13 = conint(global_hdr.sigfigs);
#line 219
      printf((char const   */* __restrict  */)"[-] Accuracy of timestamps: %u\n",
             tmp___13);
      }
    }
    {
#line 220
    global_hdr.sigfigs = conint(0U);
    }
  }
  {
#line 224
  tmp___17 = conint(global_hdr.snaplen);
  }
#line 224
  if (tmp___17 > 0U) {
    {
#line 224
    tmp___18 = conint(global_hdr.snaplen);
    }
#line 224
    if (tmp___18 <= 65535U) {
#line 225
      if (verbose) {
        {
#line 225
        tmp___15 = conint(global_hdr.snaplen);
#line 225
        printf((char const   */* __restrict  */)"[+] Max packet length: %u\n", tmp___15);
        }
      }
    } else {
#line 224
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 227
    hdr_integ = (unsigned short )((int )hdr_integ + 1);
#line 228
    if (verbose) {
      {
#line 228
      tmp___16 = conint(global_hdr.snaplen);
#line 228
      printf((char const   */* __restrict  */)"[-] Max packet length: %u\n", tmp___16);
      }
    }
    {
#line 229
    global_hdr.snaplen = conint(65535U);
    }
  }
  {
#line 233
  tmp___21 = conint(global_hdr.network);
  }
#line 233
  if (tmp___21 <= 251U) {
#line 234
    if (verbose) {
      {
#line 234
      tmp___19 = conint(global_hdr.network);
#line 234
      printf((char const   */* __restrict  */)"[+] Data link type: %u\n", tmp___19);
      }
    }
  } else {
#line 236
    hdr_integ = (unsigned short )((int )hdr_integ + 1);
#line 237
    if (verbose) {
      {
#line 237
      tmp___20 = conint(global_hdr.network);
#line 237
      printf((char const   */* __restrict  */)"[-] Data link type: %u\n", tmp___20);
      }
    }
    {
#line 239
    global_hdr.network = conint(1U);
    }
  }
#line 243
  if (data_link_type != -1) {
    {
#line 244
    printf((char const   */* __restrict  */)"[+] Changing data link type to %d.\n",
           data_link_type);
#line 245
    global_hdr.network = conint((unsigned int )data_link_type);
    }
  }
#line 249
  if ((int )hdr_integ == 0) {
    {
#line 250
    printf((char const   */* __restrict  */)"[+] The global pcap header seems to be fine!\n");
    }
  } else
#line 251
  if ((int )hdr_integ >= 4) {
    {
#line 252
    printf((char const   */* __restrict  */)"[-] The global pcap header seems to be missing ==> CORRECTED!\n");
#line 256
    fseek(pcap, 0L, 0);
#line 259
    global_hdr.snaplen = conint(65535U);
    }
#line 261
    if (data_link_type != -1) {
      {
#line 262
      global_hdr.network = conint((unsigned int )data_link_type);
      }
    } else {
      {
#line 264
      global_hdr.network = conint(1U);
      }
    }
  } else {
    {
#line 267
    printf((char const   */* __restrict  */)"[-] The global pcap header seems to be corrupt! ==> CORRECTED\n");
    }
  }
  {
#line 271
  bytes = fwrite((void const   */* __restrict  */)(& global_hdr), sizeof(global_hdr),
                 (size_t )1, (FILE */* __restrict  */)pcap_fix);
#line 277
  printf((char const   */* __restrict  */)"[*] Analyzing packets...\n");
#line 289
  tmp___22 = ftell(pcap);
#line 289
  pos = (unsigned long )tmp___22;
#line 292
  count = 1U;
  }
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
#line 292
    if (! (pos < filesize)) {
#line 292
      goto while_break;
    }
#line 295
    if (verbose == 0) {
#line 295
      if (((float )5 * (float )pos) / (float )filesize > (float )step) {
        {
#line 296
        print_progress(pos, filesize);
#line 297
        step ++;
        }
      }
    }
    {
#line 301
    bytes = fread((void */* __restrict  */)(hdrbuffer), sizeof(hdrbuffer), (size_t )1,
                  (FILE */* __restrict  */)pcap);
#line 304
    res = check_header(hdrbuffer, (unsigned int )sizeof(hdrbuffer), last_correct_ts_sec,
                       & packet_hdr);
    }
#line 305
    if (res != -1) {
      {
#line 308
      pos += (unsigned long )res;
#line 309
      fseek(pcap, (long )(pos + 16UL), 0);
#line 312
      tmp___33 = conint(packet_hdr.incl_len);
#line 312
      tmp___34 = fread((void */* __restrict  */)(& buffer), (size_t )tmp___33, (size_t )1,
                       (FILE */* __restrict  */)pcap);
      }
#line 312
      if (tmp___34 == 0UL) {
#line 312
        goto _L___0;
      } else {
        {
#line 312
        tmp___35 = conint(packet_hdr.incl_len);
        }
#line 312
        if (filesize - ((pos + 16UL) + (unsigned long )tmp___35) > 0UL) {
          {
#line 312
          tmp___36 = conint(packet_hdr.incl_len);
          }
#line 312
          if (filesize - ((pos + 16UL) + (unsigned long )tmp___36) < 16UL) {
            _L___0: /* CIL Label */ 
#line 316
            if (verbose >= 1) {
              {
#line 316
              tmp___23 = conint(packet_hdr.orig_len);
#line 316
              tmp___24 = conint(packet_hdr.incl_len);
#line 316
              tmp___25 = conint(packet_hdr.ts_usec);
#line 316
              tmp___26 = conint(packet_hdr.ts_sec);
#line 316
              printf((char const   */* __restrict  */)"[-] LAST PACKET MISMATCH (%u | %u | %u | %u)\n",
                     tmp___26, tmp___25, tmp___24, tmp___23);
              }
            }
            {
#line 319
            packet_hdr.incl_len = conint((unsigned int )((filesize - pos) - 16UL));
#line 322
            tmp___27 = conint(packet_hdr.incl_len);
#line 322
            tmp___28 = conint(packet_hdr.orig_len);
            }
#line 322
            if (tmp___27 > tmp___28) {
#line 322
              packet_hdr.orig_len = packet_hdr.incl_len;
            }
            {
#line 325
            tmp___29 = conint(packet_hdr.orig_len);
#line 325
            tmp___30 = conint(packet_hdr.incl_len);
#line 325
            tmp___31 = conint(packet_hdr.ts_usec);
#line 325
            tmp___32 = conint(packet_hdr.ts_sec);
#line 325
            printf((char const   */* __restrict  */)"[+] CORRECTED Packet #%u at position %ld (%u | %u | %u | %u).\n",
                   count, pos, tmp___32, tmp___31, tmp___30, tmp___29);
#line 326
            corrupted ++;
            }
          }
        }
      }
      {
#line 333
      bytes = fread((void */* __restrict  */)(hdrbuffer), sizeof(hdrbuffer), (size_t )1,
                    (FILE */* __restrict  */)pcap);
#line 336
      tmp___54 = conint(packet_hdr.ts_sec);
#line 336
      tmp___55 = check_header(hdrbuffer, (unsigned int )sizeof(hdrbuffer), tmp___54,
                              & next_packet_hdr);
      }
#line 336
      if (tmp___55 == -1) {
#line 341
        nextpos = (pos + 16UL) + 1UL;
        {
#line 341
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 341
          tmp___53 = conint(packet_hdr.incl_len);
          }
#line 341
          if (! (nextpos < ((pos + 16UL) + (unsigned long )tmp___53) + 32UL)) {
#line 341
            if (count == 1U) {
#line 341
              if (! (deep_scan == 1)) {
#line 341
                goto while_break___0;
              }
            } else {
#line 341
              goto while_break___0;
            }
          }
          {
#line 344
          fseek(pcap, (long )nextpos, 0);
#line 345
          bytes = fread((void */* __restrict  */)(hdrbuffer), sizeof(hdrbuffer), (size_t )1,
                        (FILE */* __restrict  */)pcap);
          }
#line 348
          if (verbose >= 2) {
            {
#line 348
            tmp___37 = conint(next_packet_hdr.orig_len);
#line 348
            tmp___38 = conint(next_packet_hdr.incl_len);
#line 348
            tmp___39 = conint(next_packet_hdr.ts_usec);
#line 348
            tmp___40 = conint(next_packet_hdr.ts_sec);
#line 348
            printf((char const   */* __restrict  */)"[*] Trying Packet #%u at position %ld (%u | %u | %u | %u).\n",
                   count + 1U, nextpos, tmp___40, tmp___39, tmp___38, tmp___37);
            }
          }
          {
#line 351
          res = check_header(hdrbuffer, (unsigned int )sizeof(hdrbuffer), last_correct_ts_sec,
                             & next_packet_hdr);
          }
#line 352
          if (res != -1) {
#line 355
            if (verbose >= 1) {
              {
#line 355
              tmp___41 = conint(next_packet_hdr.orig_len);
#line 355
              tmp___42 = conint(next_packet_hdr.incl_len);
#line 355
              tmp___43 = conint(next_packet_hdr.ts_usec);
#line 355
              tmp___44 = conint(next_packet_hdr.ts_sec);
#line 355
              printf((char const   */* __restrict  */)"[-] FOUND OVERLAPPING data of Packet #%u at position %ld (%u | %u | %u | %u).\n",
                     count + 1U, nextpos, tmp___44, tmp___43, tmp___42, tmp___41);
              }
            }
            {
#line 358
            packet_hdr.incl_len = conint((unsigned int )((nextpos - (pos + 16UL)) + (unsigned long )res));
#line 359
            packet_hdr.orig_len = packet_hdr.incl_len;
            }
#line 362
            if (count == 1U) {
              {
#line 363
              tmp___48 = conint(next_packet_hdr.ts_usec);
              }
#line 363
              if (tmp___48 > 0U) {
                {
#line 365
                packet_hdr.ts_sec = next_packet_hdr.ts_sec;
#line 366
                tmp___45 = conint(next_packet_hdr.ts_usec);
#line 366
                packet_hdr.ts_usec = conint(tmp___45 - 1U);
                }
              } else {
                {
#line 367
                tmp___47 = conint(next_packet_hdr.ts_sec);
                }
#line 367
                if (tmp___47 > 0U) {
                  {
#line 369
                  tmp___46 = conint(next_packet_hdr.ts_sec);
#line 369
                  packet_hdr.ts_sec = conint(tmp___46 - 1U);
#line 370
                  packet_hdr.ts_usec = conint(999999U);
                  }
                } else {
                  {
#line 373
                  packet_hdr.ts_sec = conint(0U);
#line 374
                  packet_hdr.ts_usec = conint(0U);
                  }
                }
              }
            }
            {
#line 379
            tmp___49 = conint(packet_hdr.orig_len);
#line 379
            tmp___50 = conint(packet_hdr.incl_len);
#line 379
            tmp___51 = conint(packet_hdr.ts_usec);
#line 379
            tmp___52 = conint(packet_hdr.ts_sec);
#line 379
            printf((char const   */* __restrict  */)"[+] CORRECTED Packet #%u at position %ld (%u | %u | %u | %u).\n",
                   count, pos, tmp___52, tmp___51, tmp___50, tmp___49);
#line 380
            corrupted ++;
#line 383
            ascii ++;
            }
#line 385
            goto while_break___0;
          }
#line 341
          nextpos ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 391
      tmp___56 = conint(packet_hdr.incl_len);
#line 391
      fseek(pcap, (long )((pos + 16UL) + (unsigned long )tmp___56), 0);
      }
#line 394
      if (verbose >= 1) {
        {
#line 394
        tmp___57 = conint(packet_hdr.orig_len);
#line 394
        tmp___58 = conint(packet_hdr.incl_len);
#line 394
        tmp___59 = conint(packet_hdr.ts_usec);
#line 394
        tmp___60 = conint(packet_hdr.ts_sec);
#line 394
        printf((char const   */* __restrict  */)"[+] Packet #%u at position %ld (%u | %u | %u | %u).\n",
               count, pos, tmp___60, tmp___59, tmp___58, tmp___57);
        }
      }
      {
#line 397
      bytes = fwrite((void const   */* __restrict  */)(& packet_hdr), sizeof(packet_hdr),
                     (size_t )1, (FILE */* __restrict  */)pcap_fix);
#line 398
      tmp___61 = conint(packet_hdr.incl_len);
#line 398
      bytes = fwrite((void const   */* __restrict  */)(& buffer), (size_t )tmp___61,
                     (size_t )1, (FILE */* __restrict  */)pcap_fix);
#line 401
      last_correct_ts_sec = conint(packet_hdr.ts_sec);
#line 402
      last_correct_ts_usec = conint(packet_hdr.ts_usec);
      }
    } else {
#line 408
      if (verbose >= 1) {
        {
#line 408
        tmp___62 = conint(packet_hdr.orig_len);
#line 408
        tmp___63 = conint(packet_hdr.incl_len);
#line 408
        tmp___64 = conint(packet_hdr.ts_usec);
#line 408
        tmp___65 = conint(packet_hdr.ts_sec);
#line 408
        printf((char const   */* __restrict  */)"[-] CORRUPTED Packet #%u at position %ld (%u | %u | %u | %u).\n",
               count, pos, tmp___65, tmp___64, tmp___63, tmp___62);
        }
      }
#line 412
      nextpos = (pos + 16UL) + 1UL;
      {
#line 412
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 412
        if (! (nextpos <= (pos + 16UL) + 65535UL)) {
#line 412
          if (count == 1U) {
#line 412
            if (! (deep_scan == 1)) {
#line 412
              goto while_break___1;
            }
          } else {
#line 412
            goto while_break___1;
          }
        }
        {
#line 415
        fseek(pcap, (long )nextpos, 0);
#line 416
        tmp___72 = fread((void */* __restrict  */)(hdrbuffer), sizeof(hdrbuffer),
                         (size_t )1, (FILE */* __restrict  */)pcap);
        }
#line 416
        if (tmp___72 == 0UL) {
#line 419
          if (count == 1U) {
#line 419
            if (deep_scan == 1) {
#line 422
              pos = 0UL;
#line 423
              corrupted = -1;
#line 424
              goto while_break___1;
            }
          }
          {
#line 427
          printf((char const   */* __restrict  */)"[*] End of file reached. Aligning last packet.\n");
#line 430
          packet_hdr.incl_len = conint((unsigned int )(filesize - (pos + 16UL)));
#line 431
          packet_hdr.orig_len = packet_hdr.incl_len;
          }
#line 434
          if (count == 1U) {
            {
#line 435
            packet_hdr.ts_sec = conint(0U);
#line 436
            packet_hdr.ts_usec = conint(0U);
            }
          } else {
            {
#line 438
            packet_hdr.ts_sec = conint(last_correct_ts_sec);
#line 439
            packet_hdr.ts_usec = conint(last_correct_ts_usec + 1U);
            }
          }
          {
#line 443
          fseek(pcap, (long )(pos + 16UL), 0);
#line 444
          tmp___66 = conint(packet_hdr.incl_len);
#line 444
          bytes = fread((void */* __restrict  */)(& buffer), (size_t )tmp___66, (size_t )1,
                        (FILE */* __restrict  */)pcap);
#line 447
          bytes = fwrite((void const   */* __restrict  */)(& packet_hdr), sizeof(packet_hdr),
                         (size_t )1, (FILE */* __restrict  */)pcap_fix);
#line 448
          tmp___67 = conint(packet_hdr.incl_len);
#line 448
          bytes = fwrite((void const   */* __restrict  */)(& buffer), (size_t )tmp___67,
                         (size_t )1, (FILE */* __restrict  */)pcap_fix);
#line 451
          last_correct_ts_sec = packet_hdr.ts_sec;
#line 452
          last_correct_ts_usec = packet_hdr.ts_usec;
#line 455
          tmp___68 = conint(packet_hdr.orig_len);
#line 455
          tmp___69 = conint(packet_hdr.incl_len);
#line 455
          tmp___70 = conint(packet_hdr.ts_usec);
#line 455
          tmp___71 = conint(packet_hdr.ts_sec);
#line 455
          printf((char const   */* __restrict  */)"[+] CORRECTED LAST Packet #%u at position %ld (%u | %u | %u | %u).\n",
                 count, pos, tmp___71, tmp___70, tmp___69, tmp___68);
#line 456
          corrupted ++;
          }
#line 458
          goto while_break___1;
        }
#line 462
        if (corrupted == -1) {
#line 462
          goto while_break___1;
        }
#line 465
        if (verbose >= 2) {
          {
#line 465
          tmp___73 = conint(next_packet_hdr.orig_len);
#line 465
          tmp___74 = conint(next_packet_hdr.incl_len);
#line 465
          tmp___75 = conint(next_packet_hdr.ts_usec);
#line 465
          tmp___76 = conint(next_packet_hdr.ts_sec);
#line 465
          printf((char const   */* __restrict  */)"[*] Trying Packet #%u at position %ld (%u | %u | %u | %u).\n",
                 count + 1U, nextpos, tmp___76, tmp___75, tmp___74, tmp___73);
          }
        }
        {
#line 468
        res = check_header(hdrbuffer, (unsigned int )sizeof(hdrbuffer), last_correct_ts_sec,
                           & next_packet_hdr);
        }
#line 469
        if (res != -1) {
#line 472
          if (nextpos - (pos + 16UL) > 65535UL) {
#line 472
            if (count == 1U) {
#line 472
              if (deep_scan == 1) {
#line 474
                if (verbose >= 1) {
                  {
#line 474
                  tmp___77 = conint(next_packet_hdr.orig_len);
#line 474
                  tmp___78 = conint(next_packet_hdr.incl_len);
#line 474
                  tmp___79 = conint(next_packet_hdr.ts_usec);
#line 474
                  tmp___80 = conint(next_packet_hdr.ts_sec);
#line 474
                  printf((char const   */* __restrict  */)"[+] (DEEP SCAN) FOUND FIRST Packet #%u at position %ld (%u | %u | %u | %u).\n",
                         count, nextpos, tmp___80, tmp___79, tmp___78, tmp___77);
                  }
                }
                {
#line 477
                fseek(pcap, (long )nextpos, 0);
#line 480
                count --;
                }
              } else {
#line 472
                goto _L___2;
              }
            } else {
#line 472
              goto _L___2;
            }
          } else {
            _L___2: /* CIL Label */ 
#line 485
            if (verbose >= 1) {
              {
#line 485
              tmp___81 = conint(next_packet_hdr.orig_len);
#line 485
              tmp___82 = conint(next_packet_hdr.incl_len);
#line 485
              tmp___83 = conint(next_packet_hdr.ts_usec);
#line 485
              tmp___84 = conint(next_packet_hdr.ts_sec);
#line 485
              printf((char const   */* __restrict  */)"[+] FOUND NEXT Packet #%u at position %ld (%u | %u | %u | %u).\n",
                     count + 1U, nextpos, tmp___84, tmp___83, tmp___82, tmp___81);
              }
            }
            {
#line 488
            packet_hdr.incl_len = conint((unsigned int )(nextpos - (pos + 16UL)));
#line 489
            packet_hdr.orig_len = packet_hdr.incl_len;
            }
#line 491
            if (count == 1U) {
              {
#line 492
              tmp___88 = conint(next_packet_hdr.ts_usec);
              }
#line 492
              if (tmp___88 > 0U) {
                {
#line 494
                packet_hdr.ts_sec = next_packet_hdr.ts_sec;
#line 495
                tmp___85 = conint(next_packet_hdr.ts_usec);
#line 495
                packet_hdr.ts_usec = conint(tmp___85 - 1U);
                }
              } else {
                {
#line 496
                tmp___87 = conint(next_packet_hdr.ts_sec);
                }
#line 496
                if (tmp___87 > 0U) {
                  {
#line 498
                  tmp___86 = conint(next_packet_hdr.ts_sec);
#line 498
                  packet_hdr.ts_sec = conint(tmp___86 - 1U);
#line 499
                  packet_hdr.ts_usec = conint(999999U);
                  }
                } else {
                  {
#line 502
                  packet_hdr.ts_sec = conint(0U);
#line 503
                  packet_hdr.ts_usec = conint(0U);
                  }
                }
              }
            } else {
              {
#line 506
              packet_hdr.ts_sec = last_correct_ts_sec;
#line 507
              packet_hdr.ts_usec = conint(last_correct_ts_usec + 1U);
              }
            }
            {
#line 511
            fseek(pcap, (long )(pos + 16UL), 0);
#line 512
            tmp___89 = conint(packet_hdr.incl_len);
#line 512
            bytes = fread((void */* __restrict  */)(& buffer), (size_t )tmp___89,
                          (size_t )1, (FILE */* __restrict  */)pcap);
#line 515
            bytes = fwrite((void const   */* __restrict  */)(& packet_hdr), sizeof(packet_hdr),
                           (size_t )1, (FILE */* __restrict  */)pcap_fix);
#line 516
            tmp___90 = conint(packet_hdr.incl_len);
#line 516
            bytes = fwrite((void const   */* __restrict  */)(& buffer), (size_t )tmp___90,
                           (size_t )1, (FILE */* __restrict  */)pcap_fix);
#line 519
            last_correct_ts_sec = packet_hdr.ts_sec;
#line 520
            last_correct_ts_usec = packet_hdr.ts_usec;
#line 523
            tmp___91 = conint(packet_hdr.orig_len);
#line 523
            tmp___92 = conint(packet_hdr.incl_len);
#line 523
            tmp___93 = conint(packet_hdr.ts_usec);
#line 523
            tmp___94 = conint(packet_hdr.ts_sec);
#line 523
            printf((char const   */* __restrict  */)"[+] CORRECTED Packet #%u at position %ld (%u | %u | %u | %u).\n",
                   count, pos, tmp___94, tmp___93, tmp___92, tmp___91);
            }
          }
#line 528
          corrupted ++;
#line 531
          goto while_break___1;
        }
#line 412
        nextpos ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 537
      if (corrupted == -1) {
#line 537
        goto while_break;
      }
#line 540
      if (count == 1U) {
#line 540
        if (deep_scan == 0) {
#line 540
          if (nextpos > (pos + 16UL) + 65535UL) {
#line 544
            if (verbose >= 1) {
              {
#line 544
              printf((char const   */* __restrict  */)"[-] Cannot align corrupted packet! \n");
              }
            }
#line 545
            goto while_break;
          }
        }
      }
    }
    {
#line 551
    tmp___95 = ftell(pcap);
#line 551
    pos = (unsigned long )tmp___95;
#line 292
    count ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 555
  if (verbose == 0) {
    {
#line 555
    print_progress(pos, filesize);
    }
  }
#line 558
  if (pos != filesize) {
    {
#line 559
    printf((char const   */* __restrict  */)"[-] Reached EOF without finding more packets!\n");
#line 560
    corrupted = -1;
    }
  }
#line 567
  if ((int )hdr_integ == 0) {
#line 567
    if (corrupted == 0) {
#line 570
      return (0);
    } else {
#line 567
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 572
  if (corrupted == -1) {
#line 576
    if (count == 1U) {
#line 579
      return (-1);
    } else {
#line 584
      return (-2);
    }
  } else {
    {
#line 592
    printf((char const   */* __restrict  */)"[*] Wrote %u packets to file.\n", count - 1U);
    }
#line 595
    if (ascii) {
      {
#line 596
      printf((char const   */* __restrict  */)"[!] This corruption seems to be a result of an ascii-mode transferred pcap file via FTP.\n");
#line 597
      printf((char const   */* __restrict  */)"[!] The pcap structure of those files can be repaired, but the data inside might still be corrupted!\n");
      }
    }
#line 600
    return ((int )hdr_integ + corrupted);
  }
}
}
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 32 "/home/wheatley/newnew/temp/pcapfix-1.0.1/pcapng.h"
int fix_pcapng(FILE *pcap , FILE *pcap_fix ) ;
#line 46
int find_valid_block(FILE *pcap , unsigned long filesize ) ;
#line 60
int write_shb(FILE *pcap_fix ) ;
#line 74
int write_idb(FILE *pcap_fix ) ;
#line 83 "/home/wheatley/newnew/temp/pcapfix-1.0.1/pcapng.c"
int fix_pcapng(FILE *pcap , FILE *pcap_fix ) 
{ 
  struct block_header bh ;
  struct option_header oh ;
  struct section_header_block shb ;
  struct interface_description_block idb ;
  struct packet_block pb ;
  struct simple_packet_block spb ;
  struct name_resolution_block nrb ;
  struct interface_statistics_block isb ;
  struct enhanced_packet_block epb ;
  char *data ;
  char *new_block ;
  unsigned long bytes ;
  unsigned long padding ;
  unsigned long pos ;
  unsigned long filesize ;
  unsigned int block_pos ;
  unsigned int check ;
  unsigned int count ;
  unsigned int shb_num ;
  unsigned int idb_num ;
  unsigned int step ;
  long left ;
  int fixes ;
  int res ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  void *tmp___2 ;
  uint32_t tmp___3 ;
  unsigned short tmp___4 ;
  unsigned short tmp___5 ;
  unsigned short tmp___6 ;
  unsigned short tmp___7 ;
  unsigned short tmp___8 ;
  unsigned short tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  long tmp___20 ;
  long tmp___21 ;
  long tmp___22 ;

  {
  {
#line 113
  fseek(pcap, 0L, 2);
#line 114
  tmp = ftell(pcap);
#line 114
  filesize = (unsigned long )tmp;
#line 115
  fseek(pcap, 0L, 0);
#line 118
  pos = 0UL;
#line 119
  fixes = 0;
#line 120
  shb_num = 0U;
#line 121
  idb_num = 0U;
#line 122
  step = 1U;
  }
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;
#line 125
    if (! (pos < filesize)) {
#line 125
      goto while_break;
    }
#line 128
    if (verbose == 0) {
#line 128
      if (((float )5 * (float )pos) / (float )filesize > (float )step) {
        {
#line 129
        print_progress(pos, filesize);
#line 130
        step ++;
        }
      }
    }
    {
#line 134
    bytes = fread((void */* __restrict  */)(& bh), sizeof(bh), (size_t )1, (FILE */* __restrict  */)pcap);
    }
#line 135
    if (bytes != 1UL) {
#line 135
      return (-3);
    }
#line 138
    if ((unsigned long )bh.total_length > filesize - pos) {
#line 141
      if (verbose >= 1) {
        {
#line 141
        printf((char const   */* __restrict  */)"[-] Block Length (%u) exceeds file size (%ld).\n",
               bh.total_length, filesize);
        }
      }
#line 144
      if (verbose >= 1) {
        {
#line 144
        printf((char const   */* __restrict  */)"[*] Trying to align next block...\n");
        }
      }
      {
#line 145
      res = find_valid_block(pcap, filesize);
      }
#line 148
      if (res == 0) {
#line 151
        if (verbose >= 1) {
          {
#line 151
          tmp___0 = ftell(pcap);
#line 151
          printf((char const   */* __restrict  */)"[+] GOT Next Block at Position %ld\n",
                 tmp___0);
          }
        }
        {
#line 154
        tmp___1 = ftell(pcap);
#line 154
        bh.total_length = (u_int32_t )((unsigned long )tmp___1 - pos);
        }
      } else {
#line 159
        if (verbose >= 1) {
          {
#line 159
          printf((char const   */* __restrict  */)"[*] No more valid Blocks found inside file! (maybe it was the last one)\n");
          }
        }
#line 162
        bh.total_length = (u_int32_t )(filesize - pos);
      }
#line 166
      if (verbose >= 1) {
        {
#line 166
        printf((char const   */* __restrict  */)"[*] Assuming this blocks size as %u bytes.\n",
               bh.total_length);
        }
      } else {
        {
#line 167
        printf((char const   */* __restrict  */)"[-] Invalid Block size => CORRECTED.\n");
        }
      }
      {
#line 170
      fseek(pcap, (long )(pos + sizeof(struct block_header )), 0);
#line 173
      fixes ++;
      }
    }
    {
#line 177
    left = (long )(((unsigned long )bh.total_length - sizeof(bh)) - sizeof(check));
#line 180
    tmp___2 = malloc((size_t )bh.total_length);
#line 180
    new_block = (char *)tmp___2;
#line 183
    memcpy((void */* __restrict  */)new_block, (void const   */* __restrict  */)(& bh),
           (size_t )8);
#line 184
    block_pos = 8U;
    }
    {
#line 190
    if (bh.block_type == 168627466U) {
#line 190
      goto case_168627466;
    }
#line 328
    if (bh.block_type == 2U) {
#line 328
      goto case_2___0;
    }
#line 461
    if (bh.block_type == 3U) {
#line 461
      goto case_3___1;
    }
#line 505
    if (bh.block_type == 1U) {
#line 505
      goto case_1___1;
    }
#line 655
    if (bh.block_type == 4U) {
#line 655
      goto case_4___1;
    }
#line 834
    if (bh.block_type == 5U) {
#line 834
      goto case_5___0;
    }
#line 960
    if (bh.block_type == 6U) {
#line 960
      goto case_6___1;
    }
#line 187
    goto switch_break;
    case_168627466: /* CIL Label */ 
#line 191
    if (verbose >= 1) {
      {
#line 191
      printf((char const   */* __restrict  */)"[*] FOUND: Section Header Block: 0x%08x (%u bytes)\n",
             bh.block_type, bh.total_length);
      }
    }
    {
#line 194
    bytes = fread((void */* __restrict  */)(& shb), sizeof(shb), (size_t )1, (FILE */* __restrict  */)pcap);
    }
#line 195
    if (bytes != 1UL) {
#line 195
      return (-3);
    }
#line 196
    left = (long )((unsigned long )left - sizeof(shb));
#line 199
    if (shb.byte_order_magic == 439041101U) {
#line 200
      if (verbose >= 1) {
        {
#line 200
        printf((char const   */* __restrict  */)"[+] Byte Order Magic: 0x%x\n", shb.byte_order_magic);
        }
      }
    } else {
      {
#line 201
      tmp___3 = htonl((uint32_t )439041101);
      }
#line 201
      if (shb.byte_order_magic == tmp___3) {
#line 202
        if (verbose >= 1) {
          {
#line 202
          printf((char const   */* __restrict  */)"[+] Byte Order Magic: 0x%x (SWAPPED)\n",
                 shb.byte_order_magic);
          }
        }
#line 203
        swapped = 1;
      } else {
        {
#line 205
        printf((char const   */* __restrict  */)"[-] Unknown Byte Order Magic: 0x%x ==> CORRECTED.\n",
               shb.byte_order_magic);
#line 206
        shb.byte_order_magic = (u_int32_t )439041101;
#line 207
        fixes ++;
        }
      }
    }
    {
#line 211
    tmp___6 = conshort(shb.major_version);
    }
#line 211
    if ((int )tmp___6 == 1) {
#line 212
      if (verbose >= 1) {
        {
#line 212
        tmp___4 = conshort(shb.major_version);
#line 212
        printf((char const   */* __restrict  */)"[+] Major version number: %hu\n",
               (int )tmp___4);
        }
      }
    } else {
      {
#line 214
      tmp___5 = conshort(shb.major_version);
#line 214
      printf((char const   */* __restrict  */)"[-] Major version number: %hu ==> CORRECTED.\n",
             (int )tmp___5);
#line 215
      shb.major_version = conshort((unsigned short)1);
#line 216
      fixes ++;
      }
    }
    {
#line 220
    tmp___9 = conshort(shb.minor_version);
    }
#line 220
    if ((int )tmp___9 == 0) {
#line 221
      if (verbose >= 1) {
        {
#line 221
        tmp___7 = conshort(shb.minor_version);
#line 221
        printf((char const   */* __restrict  */)"[+] Minor version number: %hu\n",
               (int )tmp___7);
        }
      }
    } else {
      {
#line 223
      tmp___8 = conshort(shb.minor_version);
#line 223
      printf((char const   */* __restrict  */)"[-] Minor version number: %hu ==> CORRECTED.\n",
             (int )tmp___8);
#line 224
      shb.minor_version = conshort((unsigned short)0);
#line 225
      fixes ++;
      }
    }
#line 229
    if (shb.section_length == -1L) {
#line 230
      if (verbose >= 1) {
        {
#line 230
        printf((char const   */* __restrict  */)"[*] Section length: %ld\n", shb.section_length);
        }
      }
    } else {
#line 233
      if (verbose >= 1) {
        {
#line 233
        printf((char const   */* __restrict  */)"[*] Section length: %ld ==> SETTING TO -1\n",
               shb.section_length);
        }
      }
#line 234
      shb.section_length = (int64_t )-1;
    }
    {
#line 238
    memcpy((void */* __restrict  */)(new_block + block_pos), (void const   */* __restrict  */)(& shb),
           sizeof(shb));
#line 239
    block_pos = (unsigned int )((unsigned long )block_pos + sizeof(shb));
#line 242
    count = 0U;
    }
    {
#line 243
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 243
      if (! (left > 0L)) {
#line 243
        goto while_break___0;
      }
      {
#line 246
      bytes = fread((void */* __restrict  */)(& oh), sizeof(oh), (size_t )1, (FILE */* __restrict  */)pcap);
      }
#line 247
      if (bytes != 1UL) {
#line 247
        return (-3);
      }
#line 248
      left = (long )((unsigned long )left - sizeof(oh));
      {
#line 253
      if ((int )oh.option_code == 0) {
#line 253
        goto case_0;
      }
#line 257
      if ((int )oh.option_code == 1) {
#line 257
        goto case_1;
      }
#line 261
      if ((int )oh.option_code == 2) {
#line 261
        goto case_2;
      }
#line 265
      if ((int )oh.option_code == 3) {
#line 265
        goto case_3;
      }
#line 269
      if ((int )oh.option_code == 4) {
#line 269
        goto case_4;
      }
#line 251
      goto switch_break___0;
      case_0: /* CIL Label */ 
#line 254
      if (verbose >= 2) {
        {
#line 254
        printf((char const   */* __restrict  */)"[+] OPTION: End of Options... (%u bytes)\n",
               (int )oh.option_length);
        }
      }
#line 255
      goto switch_break___0;
      case_1: /* CIL Label */ 
#line 258
      if (verbose >= 2) {
        {
#line 258
        printf((char const   */* __restrict  */)"[+] OPTION: Comment... (%u bytes)\n",
               (int )oh.option_length);
        }
      }
#line 259
      goto switch_break___0;
      case_2: /* CIL Label */ 
#line 262
      if (verbose >= 2) {
        {
#line 262
        printf((char const   */* __restrict  */)"[+] OPTION: Hardware... (%u bytes)\n",
               (int )oh.option_length);
        }
      }
#line 263
      goto switch_break___0;
      case_3: /* CIL Label */ 
#line 266
      if (verbose >= 2) {
        {
#line 266
        printf((char const   */* __restrict  */)"[+] OPTION: Operating System... (%u bytes)\n",
               (int )oh.option_length);
        }
      }
#line 267
      goto switch_break___0;
      case_4: /* CIL Label */ 
#line 270
      if (verbose >= 2) {
        {
#line 270
        printf((char const   */* __restrict  */)"[+] OPTION: Userappl... (%u bytes)\n",
               (int )oh.option_length);
        }
      }
#line 271
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 275
      if ((int )oh.option_code > 4) {
        {
#line 276
        printf((char const   */* __restrict  */)"[-] Unknown option code: 0x%04x (%u bytes) ==> SKIPPING.\n",
               (int )oh.option_code, (int )oh.option_length);
#line 279
        fixes ++;
        }
#line 282
        if (count == 0U) {
#line 284
          if (verbose >= 1) {
            {
#line 284
            printf((char const   */* __restrict  */)"[*] No Options inside -> no need for End of Options...\n");
            }
          }
#line 285
          goto while_break___0;
        }
#line 290
        if (verbose >= 1) {
          {
#line 290
          printf((char const   */* __restrict  */)"[*] %u Options inside -> Finishing with End of Options...\n",
                 count);
          }
        }
#line 293
        oh.option_code = (u_short )0;
#line 294
        oh.option_length = (u_short )0;
      }
      {
#line 300
      memcpy((void */* __restrict  */)(new_block + block_pos), (void const   */* __restrict  */)(& oh),
             sizeof(oh));
#line 301
      block_pos = (unsigned int )((unsigned long )block_pos + sizeof(oh));
      }
#line 304
      if ((int )oh.option_code == 0) {
#line 304
        if ((int )oh.option_length == 0) {
#line 304
          goto while_break___0;
        }
      }
#line 307
      padding = (unsigned long )oh.option_length;
#line 308
      if ((int )oh.option_length % 4 != 0) {
#line 308
        padding += (unsigned long )(4 - (int )oh.option_length % 4);
      }
      {
#line 311
      tmp___10 = malloc(padding);
#line 311
      data = (char *)tmp___10;
#line 312
      bytes = fread((void */* __restrict  */)data, padding, (size_t )1, (FILE */* __restrict  */)pcap);
#line 313
      left = (long )((unsigned long )left - padding);
#line 316
      memcpy((void */* __restrict  */)(new_block + block_pos), (void const   */* __restrict  */)data,
             padding);
#line 317
      block_pos = (unsigned int )((unsigned long )block_pos + padding);
#line 320
      free((void *)data);
#line 322
      count ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 325
    goto switch_break;
    case_2___0: /* CIL Label */ 
#line 331
    if (shb_num == 0U) {
      {
#line 333
      printf((char const   */* __restrict  */)"[-] No Section Block header found ==> CREATING.\n");
#line 334
      write_shb(pcap_fix);
#line 337
      shb_num ++;
#line 338
      fixes ++;
      }
    }
#line 341
    if (verbose >= 2) {
      {
#line 341
      printf((char const   */* __restrict  */)"[*] FOUND: Packet Block: 0x%08x (%u bytes)\n",
             bh.block_type, bh.total_length);
      }
    }
    {
#line 344
    bytes = fread((void */* __restrict  */)(& pb), sizeof(pb), (size_t )1, (FILE */* __restrict  */)pcap);
    }
#line 345
    if (bytes != 1UL) {
#line 345
      return (-3);
    }
#line 346
    left = (long )((unsigned long )left - sizeof(pb));
    {
#line 349
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 349
      if (! ((unsigned int )pb.interface_id >= idb_num)) {
#line 349
        goto while_break___1;
      }
      {
#line 351
      printf((char const   */* __restrict  */)"[-] Missing IDB for Interface #%u ==> CREATING (#%u).\n",
             (int )pb.interface_id, idb_num);
#line 352
      write_idb(pcap_fix);
#line 355
      idb_num ++;
#line 356
      fixes ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 360
    memcpy((void */* __restrict  */)(new_block + block_pos), (void const   */* __restrict  */)(& pb),
           sizeof(pb));
#line 361
    block_pos = (unsigned int )((unsigned long )block_pos + sizeof(pb));
#line 364
    padding = (unsigned long )pb.caplen;
    }
#line 365
    if (pb.caplen % 4U != 0U) {
#line 365
      padding += (unsigned long )(4U - pb.caplen % 4U);
    }
    {
#line 368
    tmp___11 = malloc(padding);
#line 368
    data = (char *)tmp___11;
#line 369
    bytes = fread((void */* __restrict  */)data, padding, (size_t )1, (FILE */* __restrict  */)pcap);
#line 370
    left = (long )((unsigned long )left - padding);
#line 373
    memcpy((void */* __restrict  */)(new_block + block_pos), (void const   */* __restrict  */)data,
           padding);
#line 374
    block_pos = (unsigned int )((unsigned long )block_pos + padding);
#line 377
    free((void *)data);
#line 380
    count = 0U;
    }
    {
#line 381
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 381
      if (! (left > 0L)) {
#line 381
        goto while_break___2;
      }
      {
#line 384
      bytes = fread((void */* __restrict  */)(& oh), sizeof(oh), (size_t )1, (FILE */* __restrict  */)pcap);
      }
#line 385
      if (bytes != 1UL) {
#line 385
        return (-3);
      }
#line 386
      left = (long )((unsigned long )left - sizeof(oh));
      {
#line 391
      if ((int )oh.option_code == 0) {
#line 391
        goto case_0___0;
      }
#line 395
      if ((int )oh.option_code == 1) {
#line 395
        goto case_1___0;
      }
#line 399
      if ((int )oh.option_code == 2) {
#line 399
        goto case_2___1;
      }
#line 403
      if ((int )oh.option_code == 3) {
#line 403
        goto case_3___0;
      }
#line 389
      goto switch_break___1;
      case_0___0: /* CIL Label */ 
#line 392
      if (verbose >= 2) {
        {
#line 392
        printf((char const   */* __restrict  */)"[+] OPTION: End of Options... (%u bytes)\n",
               (int )oh.option_length);
        }
      }
#line 393
      goto switch_break___1;
      case_1___0: /* CIL Label */ 
#line 396
      if (verbose >= 2) {
        {
#line 396
        printf((char const   */* __restrict  */)"[+] OPTION: Comment... (%u bytes)\n",
               (int )oh.option_length);
        }
      }
#line 397
      goto switch_break___1;
      case_2___1: /* CIL Label */ 
#line 400
      if (verbose >= 2) {
        {
#line 400
        printf((char const   */* __restrict  */)"[+] OPTION: Link Layer Flags... (%u bytes)\n",
               (int )oh.option_length);
        }
      }
#line 401
      goto switch_break___1;
      case_3___0: /* CIL Label */ 
#line 404
      if (verbose >= 2) {
        {
#line 404
        printf((char const   */* __restrict  */)"[+] OPTION: Packet Hash... (%u bytes)\n",
               (int )oh.option_length);
        }
      }
#line 405
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
#line 409
      if ((int )oh.option_code > 3) {
        {
#line 410
        printf((char const   */* __restrict  */)"[-] Unknown option code: 0x%04x (%u bytes) ==> SKIPPING.\n",
               (int )oh.option_code, (int )oh.option_length);
#line 413
        fixes ++;
        }
#line 416
        if (count == 0U) {
#line 418
          if (verbose >= 1) {
            {
#line 418
            printf((char const   */* __restrict  */)"[*] No Options inside -> no need for End of Options...\n");
            }
          }
#line 419
          goto while_break___2;
        }
#line 424
        if (verbose >= 1) {
          {
#line 424
          printf((char const   */* __restrict  */)"[*] %u Options inside -> Finishing with End of Options...\n",
                 count);
          }
        }
#line 427
        oh.option_code = (u_short )0;
#line 428
        oh.option_length = (u_short )0;
      }
      {
#line 434
      memcpy((void */* __restrict  */)(new_block + block_pos), (void const   */* __restrict  */)(& oh),
             sizeof(oh));
#line 435
      block_pos = (unsigned int )((unsigned long )block_pos + sizeof(oh));
      }
#line 438
      if ((int )oh.option_code == 0) {
#line 438
        if ((int )oh.option_length == 0) {
#line 438
          goto while_break___2;
        }
      }
#line 441
      padding = (unsigned long )oh.option_length;
#line 442
      if ((int )oh.option_length % 4 != 0) {
#line 442
        padding += (unsigned long )(4 - (int )oh.option_length % 4);
      }
      {
#line 445
      tmp___12 = malloc(padding);
#line 445
      data = (char *)tmp___12;
#line 446
      bytes = fread((void */* __restrict  */)data, padding, (size_t )1, (FILE */* __restrict  */)pcap);
#line 447
      left = (long )((unsigned long )left - padding);
#line 450
      memcpy((void */* __restrict  */)(new_block + block_pos), (void const   */* __restrict  */)data,
             padding);
#line 451
      block_pos = (unsigned int )((unsigned long )block_pos + padding);
#line 454
      free((void *)data);
#line 456
      count ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 458
    goto switch_break;
    case_3___1: /* CIL Label */ 
#line 464
    if (shb_num == 0U) {
      {
#line 466
      printf((char const   */* __restrict  */)"[-] No Section Block header found ==> CREATING.\n");
#line 467
      write_shb(pcap_fix);
#line 470
      shb_num ++;
#line 471
      fixes ++;
      }
    }
#line 474
    if (verbose >= 2) {
      {
#line 474
      printf((char const   */* __restrict  */)"[*] FOUND: Simple Packet Block: 0x%08x (%u bytes)\n",
             bh.block_type, bh.total_length);
      }
    }
    {
#line 477
    bytes = fread((void */* __restrict  */)(& spb), sizeof(spb), (size_t )1, (FILE */* __restrict  */)pcap);
    }
#line 478
    if (bytes != 1UL) {
#line 478
      return (-3);
    }
    {
#line 479
    left = (long )((unsigned long )left - sizeof(spb));
#line 482
    memcpy((void */* __restrict  */)(new_block + block_pos), (void const   */* __restrict  */)(& spb),
           sizeof(spb));
#line 483
    block_pos = (unsigned int )((unsigned long )block_pos + sizeof(spb));
#line 487
    padding = (unsigned long )spb.len;
    }
#line 488
    if (spb.len % 4U != 0U) {
#line 488
      padding += (unsigned long )(4U - spb.len % 4U);
    }
    {
#line 491
    tmp___13 = malloc(padding);
#line 491
    data = (char *)tmp___13;
#line 492
    bytes = fread((void */* __restrict  */)data, padding, (size_t )1, (FILE */* __restrict  */)pcap);
#line 493
    left = (long )((unsigned long )left - padding);
#line 496
    memcpy((void */* __restrict  */)(new_block + block_pos), (void const   */* __restrict  */)data,
           padding);
#line 497
    block_pos = (unsigned int )((unsigned long )block_pos + padding);
#line 500
    free((void *)data);
    }
#line 502
    goto switch_break;
    case_1___1: /* CIL Label */ 
#line 508
    if (shb_num == 0U) {
      {
#line 510
      printf((char const   */* __restrict  */)"[-] No Section Block header found ==> CREATING.\n");
#line 511
      write_shb(pcap_fix);
#line 514
      shb_num ++;
#line 515
      fixes ++;
      }
    }
#line 518
    if (verbose >= 1) {
      {
#line 518
      printf((char const   */* __restrict  */)"[*] FOUND: Interface Description Block: 0x%08x (%u bytes)\n",
             bh.block_type, bh.total_length);
      }
    }
    {
#line 521
    bytes = fread((void */* __restrict  */)(& idb), sizeof(idb), (size_t )1, (FILE */* __restrict  */)pcap);
    }
#line 522
    if (bytes != 1UL) {
#line 522
      return (-3);
    }
    {
#line 523
    left = (long )((unsigned long )left - sizeof(idb));
#line 526
    memcpy((void */* __restrict  */)(new_block + block_pos), (void const   */* __restrict  */)(& idb),
           sizeof(idb));
#line 527
    block_pos = (unsigned int )((unsigned long )block_pos + sizeof(idb));
#line 530
    count = 0U;
    }
    {
#line 531
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 531
      if (! (left > 0L)) {
#line 531
        goto while_break___3;
      }
      {
#line 534
      bytes = fread((void */* __restrict  */)(& oh), sizeof(oh), (size_t )1, (FILE */* __restrict  */)pcap);
      }
#line 535
      if (bytes != 1UL) {
#line 535
        return (-3);
      }
#line 536
      left = (long )((unsigned long )left - sizeof(oh));
      {
#line 541
      if ((int )oh.option_code == 0) {
#line 541
        goto case_0___1;
      }
#line 545
      if ((int )oh.option_code == 1) {
#line 545
        goto case_1___2;
      }
#line 549
      if ((int )oh.option_code == 2) {
#line 549
        goto case_2___2;
      }
#line 553
      if ((int )oh.option_code == 3) {
#line 553
        goto case_3___2;
      }
#line 557
      if ((int )oh.option_code == 4) {
#line 557
        goto case_4___0;
      }
#line 561
      if ((int )oh.option_code == 5) {
#line 561
        goto case_5;
      }
#line 565
      if ((int )oh.option_code == 6) {
#line 565
        goto case_6;
      }
#line 569
      if ((int )oh.option_code == 7) {
#line 569
        goto case_7;
      }
#line 573
      if ((int )oh.option_code == 8) {
#line 573
        goto case_8;
      }
#line 577
      if ((int )oh.option_code == 9) {
#line 577
        goto case_9;
      }
#line 581
      if ((int )oh.option_code == 10) {
#line 581
        goto case_10;
      }
#line 585
      if ((int )oh.option_code == 11) {
#line 585
        goto case_11;
      }
#line 589
      if ((int )oh.option_code == 12) {
#line 589
        goto case_12;
      }
#line 593
      if ((int )oh.option_code == 13) {
#line 593
        goto case_13;
      }
#line 597
      if ((int )oh.option_code == 14) {
#line 597
        goto case_14;
      }
#line 539
      goto switch_break___2;
      case_0___1: /* CIL Label */ 
#line 542
      if (verbose >= 2) {
        {
#line 542
        printf((char const   */* __restrict  */)"[+] OPTION: End of Options... (%u bytes)\n",
               (int )oh.option_length);
        }
      }
#line 543
      goto switch_break___2;
      case_1___2: /* CIL Label */ 
#line 546
      if (verbose >= 2) {
        {
#line 546
        printf((char const   */* __restrict  */)"[+] OPTION: Comment... (%u bytes)\n",
               (int )oh.option_length);
        }
      }
#line 547
      goto switch_break___2;
      case_2___2: /* CIL Label */ 
#line 550
      if (verbose >= 2) {
        {
#line 550
        printf((char const   */* __restrict  */)"[+] OPTION: Interface Name... (%u bytes)\n",
               (int )oh.option_length);
        }
      }
#line 551
      goto switch_break___2;
      case_3___2: /* CIL Label */ 
#line 554
      if (verbose >= 2) {
        {
#line 554
        printf((char const   */* __restrict  */)"[+] OPTION: Interface Description... (%u bytes)\n",
               (int )oh.option_length);
        }
      }
#line 555
      goto switch_break___2;
      case_4___0: /* CIL Label */ 
#line 558
      if (verbose >= 2) {
        {
#line 558
        printf((char const   */* __restrict  */)"[+] OPTION: IPv4 Address... (%u bytes)\n",
               (int )oh.option_length);
        }
      }
#line 559
      goto switch_break___2;
      case_5: /* CIL Label */ 
#line 562
      if (verbose >= 2) {
        {
#line 562
        printf((char const   */* __restrict  */)"[+] OPTION: IPv6 Address... (%u bytes)\n",
               (int )oh.option_length);
        }
      }
#line 563
      goto switch_break___2;
      case_6: /* CIL Label */ 
#line 566
      if (verbose >= 2) {
        {
#line 566
        printf((char const   */* __restrict  */)"[+] OPTION: MAC Address... (%u bytes)\n",
               (int )oh.option_length);
        }
      }
#line 567
      goto switch_break___2;
      case_7: /* CIL Label */ 
#line 570
      if (verbose >= 2) {
        {
#line 570
        printf((char const   */* __restrict  */)"[+] OPTION: EUI Address... (%u bytes)\n",
               (int )oh.option_length);
        }
      }
#line 571
      goto switch_break___2;
      case_8: /* CIL Label */ 
#line 574
      if (verbose >= 2) {
        {
#line 574
        printf((char const   */* __restrict  */)"[+] OPTION: Interface Speed... (%u bytes)\n",
               (int )oh.option_length);
        }
      }
#line 575
      goto switch_break___2;
      case_9: /* CIL Label */ 
#line 578
      if (verbose >= 2) {
        {
#line 578
        printf((char const   */* __restrict  */)"[+] OPTION: Resolution of Timestamps... (%u bytes)\n",
               (int )oh.option_length);
        }
      }
#line 579
      goto switch_break___2;
      case_10: /* CIL Label */ 
#line 582
      if (verbose >= 2) {
        {
#line 582
        printf((char const   */* __restrict  */)"[+] OPTION: Timezone... (%u bytes)\n",
               (int )oh.option_length);
        }
      }
#line 583
      goto switch_break___2;
      case_11: /* CIL Label */ 
#line 586
      if (verbose >= 2) {
        {
#line 586
        printf((char const   */* __restrict  */)"[+] OPTION: Filter expression... (%u bytes)\n",
               (int )oh.option_length);
        }
      }
#line 587
      goto switch_break___2;
      case_12: /* CIL Label */ 
#line 590
      if (verbose >= 2) {
        {
#line 590
        printf((char const   */* __restrict  */)"[+] OPTION: Operating System... (%u bytes)\n",
               (int )oh.option_length);
        }
      }
#line 591
      goto switch_break___2;
      case_13: /* CIL Label */ 
#line 594
      if (verbose >= 2) {
        {
#line 594
        printf((char const   */* __restrict  */)"[+] OPTION: Frame Check Sequence Length... (%u bytes)\n",
               (int )oh.option_length);
        }
      }
#line 595
      goto switch_break___2;
      case_14: /* CIL Label */ 
#line 598
      if (verbose >= 2) {
        {
#line 598
        printf((char const   */* __restrict  */)"[+] OPTION: Timestamp Offset... (%u bytes)\n",
               (int )oh.option_length);
        }
      }
#line 599
      goto switch_break___2;
      switch_break___2: /* CIL Label */ ;
      }
#line 603
      if ((int )oh.option_code > 14) {
        {
#line 604
        printf((char const   */* __restrict  */)"[-] Unknown option code: 0x%04x (%u bytes) ==> SKIPPING.\n",
               (int )oh.option_code, (int )oh.option_length);
#line 607
        fixes ++;
        }
#line 610
        if (count == 0U) {
#line 612
          if (verbose >= 1) {
            {
#line 612
            printf((char const   */* __restrict  */)"[*] No Options inside -> no need for End of Options...\n");
            }
          }
#line 613
          goto while_break___3;
        }
#line 618
        if (verbose >= 1) {
          {
#line 618
          printf((char const   */* __restrict  */)"[*] %u Options inside -> Finishing with End of Options...\n",
                 count);
          }
        }
#line 621
        oh.option_code = (u_short )0;
#line 622
        oh.option_length = (u_short )0;
      }
      {
#line 628
      memcpy((void */* __restrict  */)(new_block + block_pos), (void const   */* __restrict  */)(& oh),
             sizeof(oh));
#line 629
      block_pos = (unsigned int )((unsigned long )block_pos + sizeof(oh));
      }
#line 632
      if ((int )oh.option_code == 0) {
#line 632
        if ((int )oh.option_length == 0) {
#line 632
          goto while_break___3;
        }
      }
#line 635
      padding = (unsigned long )oh.option_length;
#line 636
      if ((int )oh.option_length % 4 != 0) {
#line 636
        padding += (unsigned long )(4 - (int )oh.option_length % 4);
      }
      {
#line 639
      tmp___14 = malloc(padding);
#line 639
      data = (char *)tmp___14;
#line 640
      bytes = fread((void */* __restrict  */)data, padding, (size_t )1, (FILE */* __restrict  */)pcap);
#line 641
      left = (long )((unsigned long )left - padding);
#line 644
      memcpy((void */* __restrict  */)(new_block + block_pos), (void const   */* __restrict  */)data,
             padding);
#line 645
      block_pos = (unsigned int )((unsigned long )block_pos + padding);
#line 648
      free((void *)data);
#line 650
      count ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 652
    goto switch_break;
    case_4___1: /* CIL Label */ 
#line 658
    if (shb_num == 0U) {
      {
#line 660
      printf((char const   */* __restrict  */)"[-] No Section Block header found ==> CREATING.\n");
#line 661
      write_shb(pcap_fix);
#line 664
      shb_num ++;
#line 665
      fixes ++;
      }
    }
#line 668
    if (verbose >= 1) {
      {
#line 668
      printf((char const   */* __restrict  */)"[*] FOUND: Name Resolution Block: 0x%08x (%u bytes)\n",
             bh.block_type, bh.total_length);
      }
    }
#line 671
    count = 0U;
    {
#line 672
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 672
      if (! (left > 0L)) {
#line 672
        goto while_break___4;
      }
      {
#line 675
      bytes = fread((void */* __restrict  */)(& nrb), sizeof(nrb), (size_t )1, (FILE */* __restrict  */)pcap);
      }
#line 676
      if (bytes != 1UL) {
#line 676
        return (-3);
      }
#line 677
      left = (long )((unsigned long )left - sizeof(nrb));
      {
#line 682
      if ((int )nrb.record_type == 0) {
#line 682
        goto case_0___2;
      }
#line 686
      if ((int )nrb.record_type == 1) {
#line 686
        goto case_1___3;
      }
#line 690
      if ((int )nrb.record_type == 2) {
#line 690
        goto case_2___3;
      }
#line 680
      goto switch_break___3;
      case_0___2: /* CIL Label */ 
#line 683
      if (verbose >= 2) {
        {
#line 683
        printf((char const   */* __restrict  */)"[+] RECORD: End of Records... (%u bytes)\n",
               (int )nrb.record_length);
        }
      }
#line 684
      goto switch_break___3;
      case_1___3: /* CIL Label */ 
#line 687
      if (verbose >= 2) {
        {
#line 687
        printf((char const   */* __restrict  */)"[+] RECORD: IPv4 Record... (%u bytes)\n",
               (int )nrb.record_length);
        }
      }
#line 688
      goto switch_break___3;
      case_2___3: /* CIL Label */ 
#line 691
      if (verbose >= 2) {
        {
#line 691
        printf((char const   */* __restrict  */)"[+] RECORD: IPv6 Record... (%u bytes)\n",
               (int )nrb.record_length);
        }
      }
#line 692
      goto switch_break___3;
      switch_break___3: /* CIL Label */ ;
      }
#line 696
      if ((int )nrb.record_type > 2) {
        {
#line 697
        printf((char const   */* __restrict  */)"[-] Unknown record type: 0x%04x (%u bytes) ==> SKIPPING.\n",
               (int )nrb.record_type, (int )nrb.record_length);
#line 700
        fixes ++;
        }
#line 703
        if (count == 0U) {
#line 705
          if (verbose >= 1) {
            {
#line 705
            printf((char const   */* __restrict  */)"[*] No Records inside -> no need for End of Records...\n");
            }
          }
#line 706
          goto while_break___4;
        }
#line 711
        if (verbose >= 1) {
          {
#line 711
          printf((char const   */* __restrict  */)"[*] %u Records inside -> Finishing with End of Records...\n",
                 count);
          }
        }
#line 714
        nrb.record_type = (u_short )0;
#line 715
        nrb.record_length = (u_short )0;
      }
      {
#line 721
      memcpy((void */* __restrict  */)(new_block + block_pos), (void const   */* __restrict  */)(& nrb),
             sizeof(nrb));
#line 722
      block_pos = (unsigned int )((unsigned long )block_pos + sizeof(nrb));
      }
#line 725
      if ((int )nrb.record_type == 0) {
#line 725
        if ((int )nrb.record_length == 0) {
#line 725
          goto while_break___4;
        }
      }
#line 728
      padding = (unsigned long )nrb.record_length;
#line 729
      if ((int )nrb.record_length % 4 != 0) {
#line 729
        padding += (unsigned long )(4 - (int )nrb.record_length % 4);
      }
      {
#line 732
      tmp___15 = malloc(padding);
#line 732
      data = (char *)tmp___15;
#line 733
      bytes = fread((void */* __restrict  */)data, padding, (size_t )1, (FILE */* __restrict  */)pcap);
#line 734
      left = (long )((unsigned long )left - padding);
#line 737
      memcpy((void */* __restrict  */)(new_block + block_pos), (void const   */* __restrict  */)data,
             padding);
#line 738
      block_pos = (unsigned int )((unsigned long )block_pos + padding);
#line 741
      free((void *)data);
#line 743
      count ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 748
    count = 0U;
    {
#line 749
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 749
      if (! (left > 0L)) {
#line 749
        goto while_break___5;
      }
      {
#line 752
      bytes = fread((void */* __restrict  */)(& oh), sizeof(oh), (size_t )1, (FILE */* __restrict  */)pcap);
      }
#line 753
      if (bytes != 1UL) {
#line 753
        return (-3);
      }
#line 754
      left = (long )((unsigned long )left - sizeof(oh));
      {
#line 759
      if ((int )oh.option_code == 0) {
#line 759
        goto case_0___3;
      }
#line 763
      if ((int )oh.option_code == 1) {
#line 763
        goto case_1___4;
      }
#line 767
      if ((int )oh.option_code == 2) {
#line 767
        goto case_2___4;
      }
#line 771
      if ((int )oh.option_code == 3) {
#line 771
        goto case_3___3;
      }
#line 775
      if ((int )oh.option_code == 4) {
#line 775
        goto case_4___2;
      }
#line 757
      goto switch_break___4;
      case_0___3: /* CIL Label */ 
#line 760
      if (verbose >= 2) {
        {
#line 760
        printf((char const   */* __restrict  */)"[+] OPTION: End of Options... (%u bytes)\n",
               (int )oh.option_length);
        }
      }
#line 761
      goto switch_break___4;
      case_1___4: /* CIL Label */ 
#line 764
      if (verbose >= 2) {
        {
#line 764
        printf((char const   */* __restrict  */)"[+] OPTION: Comment... (%u bytes)\n",
               (int )oh.option_length);
        }
      }
#line 765
      goto switch_break___4;
      case_2___4: /* CIL Label */ 
#line 768
      if (verbose >= 2) {
        {
#line 768
        printf((char const   */* __restrict  */)"[+] OPTION: DNS Server... (%u bytes)\n",
               (int )oh.option_length);
        }
      }
#line 769
      goto switch_break___4;
      case_3___3: /* CIL Label */ 
#line 772
      if (verbose >= 2) {
        {
#line 772
        printf((char const   */* __restrict  */)"[+] OPTION: IPv4 Address of DNS Server... (%u bytes)\n",
               (int )oh.option_length);
        }
      }
#line 773
      goto switch_break___4;
      case_4___2: /* CIL Label */ 
#line 776
      if (verbose >= 2) {
        {
#line 776
        printf((char const   */* __restrict  */)"[+] OPTION: IPv6 Address of DNS Server... (%u bytes)\n",
               (int )oh.option_length);
        }
      }
#line 777
      goto switch_break___4;
      switch_break___4: /* CIL Label */ ;
      }
#line 781
      if ((int )oh.option_code > 4) {
        {
#line 782
        printf((char const   */* __restrict  */)"[-] Unknown option code: 0x%04x (%u bytes) ==> SKIPPING.\n",
               (int )oh.option_code, (int )oh.option_length);
#line 785
        fixes ++;
        }
#line 788
        if (count == 0U) {
#line 790
          if (verbose >= 1) {
            {
#line 790
            printf((char const   */* __restrict  */)"[*] No Options inside -> no need for End of Options...\n");
            }
          }
#line 791
          goto while_break___5;
        }
#line 796
        if (verbose >= 1) {
          {
#line 796
          printf((char const   */* __restrict  */)"[*] %u Options inside -> Finishing with End of Options...\n",
                 count);
          }
        }
#line 799
        oh.option_code = (u_short )0;
#line 800
        oh.option_length = (u_short )0;
      }
      {
#line 806
      memcpy((void */* __restrict  */)(new_block + block_pos), (void const   */* __restrict  */)(& oh),
             sizeof(oh));
#line 807
      block_pos = (unsigned int )((unsigned long )block_pos + sizeof(oh));
      }
#line 810
      if ((int )oh.option_code == 0) {
#line 810
        if ((int )oh.option_length == 0) {
#line 810
          goto while_break___5;
        }
      }
#line 813
      padding = (unsigned long )oh.option_length;
#line 814
      if ((int )oh.option_length % 4 != 0) {
#line 814
        padding += (unsigned long )(4 - (int )oh.option_length % 4);
      }
      {
#line 817
      tmp___16 = malloc(padding);
#line 817
      data = (char *)tmp___16;
#line 818
      bytes = fread((void */* __restrict  */)data, padding, (size_t )1, (FILE */* __restrict  */)pcap);
#line 819
      left = (long )((unsigned long )left - padding);
#line 822
      memcpy((void */* __restrict  */)(new_block + block_pos), (void const   */* __restrict  */)data,
             padding);
#line 823
      block_pos = (unsigned int )((unsigned long )block_pos + padding);
#line 826
      free((void *)data);
#line 828
      count ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 831
    goto switch_break;
    case_5___0: /* CIL Label */ 
#line 837
    if (shb_num == 0U) {
      {
#line 839
      printf((char const   */* __restrict  */)"[-] No Section Block header found ==> CREATING.\n");
#line 840
      write_shb(pcap_fix);
#line 843
      shb_num ++;
#line 844
      fixes ++;
      }
    }
#line 847
    if (verbose >= 1) {
      {
#line 847
      printf((char const   */* __restrict  */)"[*] FOUND: Interface Statistics Block: 0x%08x (%u bytes)\n",
             bh.block_type, bh.total_length);
      }
    }
    {
#line 850
    bytes = fread((void */* __restrict  */)(& isb), sizeof(isb), (size_t )1, (FILE */* __restrict  */)pcap);
    }
#line 851
    if (bytes != 1UL) {
#line 851
      return (-3);
    }
    {
#line 852
    left = (long )((unsigned long )left - sizeof(isb));
#line 855
    memcpy((void */* __restrict  */)(new_block + block_pos), (void const   */* __restrict  */)(& isb),
           sizeof(isb));
#line 856
    block_pos = (unsigned int )((unsigned long )block_pos + sizeof(isb));
#line 859
    count = 0U;
    }
    {
#line 860
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 860
      if (! (left > 0L)) {
#line 860
        goto while_break___6;
      }
      {
#line 863
      bytes = fread((void */* __restrict  */)(& oh), sizeof(oh), (size_t )1, (FILE */* __restrict  */)pcap);
      }
#line 864
      if (bytes != 1UL) {
#line 864
        return (-3);
      }
#line 865
      left = (long )((unsigned long )left - sizeof(oh));
      {
#line 870
      if ((int )oh.option_code == 0) {
#line 870
        goto case_0___4;
      }
#line 874
      if ((int )oh.option_code == 1) {
#line 874
        goto case_1___5;
      }
#line 878
      if ((int )oh.option_code == 2) {
#line 878
        goto case_2___5;
      }
#line 882
      if ((int )oh.option_code == 3) {
#line 882
        goto case_3___4;
      }
#line 886
      if ((int )oh.option_code == 4) {
#line 886
        goto case_4___3;
      }
#line 890
      if ((int )oh.option_code == 5) {
#line 890
        goto case_5___1;
      }
#line 894
      if ((int )oh.option_code == 6) {
#line 894
        goto case_6___0;
      }
#line 898
      if ((int )oh.option_code == 7) {
#line 898
        goto case_7___0;
      }
#line 902
      if ((int )oh.option_code == 8) {
#line 902
        goto case_8___0;
      }
#line 868
      goto switch_break___5;
      case_0___4: /* CIL Label */ 
#line 871
      if (verbose >= 2) {
        {
#line 871
        printf((char const   */* __restrict  */)"[+] OPTION: End of Options... (%u bytes)\n",
               (int )oh.option_length);
        }
      }
#line 872
      goto switch_break___5;
      case_1___5: /* CIL Label */ 
#line 875
      if (verbose >= 2) {
        {
#line 875
        printf((char const   */* __restrict  */)"[+] OPTION: Comment... (%u bytes)\n",
               (int )oh.option_length);
        }
      }
#line 876
      goto switch_break___5;
      case_2___5: /* CIL Label */ 
#line 879
      if (verbose >= 2) {
        {
#line 879
        printf((char const   */* __restrict  */)"[+] OPTION: Capture Start Time... (%u bytes)\n",
               (int )oh.option_length);
        }
      }
#line 880
      goto switch_break___5;
      case_3___4: /* CIL Label */ 
#line 883
      if (verbose >= 2) {
        {
#line 883
        printf((char const   */* __restrict  */)"[+] OPTION: Capture End Time... (%u bytes)\n",
               (int )oh.option_length);
        }
      }
#line 884
      goto switch_break___5;
      case_4___3: /* CIL Label */ 
#line 887
      if (verbose >= 2) {
        {
#line 887
        printf((char const   */* __restrict  */)"[+] OPTION: Packets received... (%u bytes)\n",
               (int )oh.option_length);
        }
      }
#line 888
      goto switch_break___5;
      case_5___1: /* CIL Label */ 
#line 891
      if (verbose >= 2) {
        {
#line 891
        printf((char const   */* __restrict  */)"[+] OPTION: Packets dropped... (%u bytes)\n",
               (int )oh.option_length);
        }
      }
#line 892
      goto switch_break___5;
      case_6___0: /* CIL Label */ 
#line 895
      if (verbose >= 2) {
        {
#line 895
        printf((char const   */* __restrict  */)"[+] OPTION: Filter packets accepted... (%u bytes)\n",
               (int )oh.option_length);
        }
      }
#line 896
      goto switch_break___5;
      case_7___0: /* CIL Label */ 
#line 899
      if (verbose >= 2) {
        {
#line 899
        printf((char const   */* __restrict  */)"[+] OPTION: Packets dropped by OS... (%u bytes)\n",
               (int )oh.option_length);
        }
      }
#line 900
      goto switch_break___5;
      case_8___0: /* CIL Label */ 
#line 903
      if (verbose >= 2) {
        {
#line 903
        printf((char const   */* __restrict  */)"[+] OPTION: Packets delivered to user... (%u bytes)\n",
               (int )oh.option_length);
        }
      }
#line 904
      goto switch_break___5;
      switch_break___5: /* CIL Label */ ;
      }
#line 908
      if ((int )oh.option_code > 8) {
        {
#line 909
        printf((char const   */* __restrict  */)"[-] Unknown option code: 0x%04x (%u bytes) ==> SKIPPING.\n",
               (int )oh.option_code, (int )oh.option_length);
#line 912
        fixes ++;
        }
#line 915
        if (count == 0U) {
#line 917
          if (verbose >= 1) {
            {
#line 917
            printf((char const   */* __restrict  */)"[*] No Options inside -> no need for End of Options...\n");
            }
          }
#line 918
          goto while_break___6;
        }
#line 923
        if (verbose >= 1) {
          {
#line 923
          printf((char const   */* __restrict  */)"[*] %u Options inside -> Finishing with End of Options...\n",
                 count);
          }
        }
#line 926
        oh.option_code = (u_short )0;
#line 927
        oh.option_length = (u_short )0;
      }
      {
#line 933
      memcpy((void */* __restrict  */)(new_block + block_pos), (void const   */* __restrict  */)(& oh),
             sizeof(oh));
#line 934
      block_pos = (unsigned int )((unsigned long )block_pos + sizeof(oh));
      }
#line 937
      if ((int )oh.option_code == 0) {
#line 937
        if ((int )oh.option_length == 0) {
#line 937
          goto while_break___6;
        }
      }
#line 940
      padding = (unsigned long )oh.option_length;
#line 941
      if ((int )oh.option_length % 4 != 0) {
#line 941
        padding += (unsigned long )(4 - (int )oh.option_length % 4);
      }
      {
#line 944
      tmp___17 = malloc(padding);
#line 944
      data = (char *)tmp___17;
#line 945
      bytes = fread((void */* __restrict  */)data, padding, (size_t )1, (FILE */* __restrict  */)pcap);
#line 946
      left = (long )((unsigned long )left - padding);
#line 949
      memcpy((void */* __restrict  */)(new_block + block_pos), (void const   */* __restrict  */)data,
             padding);
#line 950
      block_pos = (unsigned int )((unsigned long )block_pos + padding);
#line 953
      free((void *)data);
#line 955
      count ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
#line 957
    goto switch_break;
    case_6___1: /* CIL Label */ 
#line 963
    if (shb_num == 0U) {
      {
#line 965
      printf((char const   */* __restrict  */)"[-] No Section Block header found ==> CREATING.\n");
#line 966
      write_shb(pcap_fix);
#line 969
      shb_num ++;
#line 970
      fixes ++;
      }
    }
#line 973
    if (verbose >= 2) {
      {
#line 973
      printf((char const   */* __restrict  */)"[*] FOUND: Enhanced Packet Block: 0x%08x (%u bytes)\n",
             bh.block_type, bh.total_length);
      }
    }
    {
#line 976
    bytes = fread((void */* __restrict  */)(& epb), sizeof(epb), (size_t )1, (FILE */* __restrict  */)pcap);
    }
#line 977
    if (bytes != 1UL) {
#line 977
      return (-3);
    }
#line 978
    left = (long )((unsigned long )left - sizeof(epb));
    {
#line 981
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 981
      if (! (epb.interface_id >= idb_num)) {
#line 981
        goto while_break___7;
      }
      {
#line 983
      printf((char const   */* __restrict  */)"[-] Missing IDB for Interface #%u ==> CREATING (#%u).\n",
             epb.interface_id, idb_num);
#line 984
      write_idb(pcap_fix);
#line 987
      idb_num ++;
#line 988
      fixes ++;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
#line 992
    if ((long )epb.caplen > left) {
      {
#line 993
      printf((char const   */* __restrict  */)"[-] Enhanced packet data exceeds packet length (%u > %ld) ==> CORRECTED.\n",
             epb.caplen, left);
#line 994
      epb.caplen = (u_int32_t )left;
#line 996
      fixes ++;
      }
    }
    {
#line 1000
    memcpy((void */* __restrict  */)(new_block + block_pos), (void const   */* __restrict  */)(& epb),
           sizeof(epb));
#line 1001
    block_pos = (unsigned int )((unsigned long )block_pos + sizeof(epb));
#line 1004
    padding = (unsigned long )epb.caplen;
    }
#line 1005
    if (epb.caplen % 4U != 0U) {
#line 1005
      padding += (unsigned long )(4U - epb.caplen % 4U);
    }
    {
#line 1008
    tmp___18 = malloc(padding);
#line 1008
    data = (char *)tmp___18;
#line 1009
    bytes = fread((void */* __restrict  */)data, padding, (size_t )1, (FILE */* __restrict  */)pcap);
#line 1010
    left = (long )((unsigned long )left - padding);
#line 1013
    memcpy((void */* __restrict  */)(new_block + block_pos), (void const   */* __restrict  */)data,
           padding);
#line 1014
    block_pos = (unsigned int )((unsigned long )block_pos + padding);
#line 1017
    free((void *)data);
#line 1020
    count = 0U;
    }
    {
#line 1021
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1021
      if (! (left > 0L)) {
#line 1021
        goto while_break___8;
      }
      {
#line 1024
      bytes = fread((void */* __restrict  */)(& oh), sizeof(oh), (size_t )1, (FILE */* __restrict  */)pcap);
      }
#line 1025
      if (bytes != 1UL) {
#line 1025
        return (-3);
      }
#line 1026
      left = (long )((unsigned long )left - sizeof(oh));
      {
#line 1031
      if ((int )oh.option_code == 0) {
#line 1031
        goto case_0___5;
      }
#line 1035
      if ((int )oh.option_code == 1) {
#line 1035
        goto case_1___6;
      }
#line 1039
      if ((int )oh.option_code == 2) {
#line 1039
        goto case_2___6;
      }
#line 1043
      if ((int )oh.option_code == 3) {
#line 1043
        goto case_3___5;
      }
#line 1047
      if ((int )oh.option_code == 4) {
#line 1047
        goto case_4___4;
      }
#line 1029
      goto switch_break___6;
      case_0___5: /* CIL Label */ 
#line 1032
      if (verbose >= 2) {
        {
#line 1032
        printf((char const   */* __restrict  */)"[+] OPTION: End of Options... (%u bytes)\n",
               (int )oh.option_length);
        }
      }
#line 1033
      goto switch_break___6;
      case_1___6: /* CIL Label */ 
#line 1036
      if (verbose >= 2) {
        {
#line 1036
        printf((char const   */* __restrict  */)"[+] OPTION: Comment... (%u bytes)\n",
               (int )oh.option_length);
        }
      }
#line 1037
      goto switch_break___6;
      case_2___6: /* CIL Label */ 
#line 1040
      if (verbose >= 2) {
        {
#line 1040
        printf((char const   */* __restrict  */)"[+] OPTION: Link Layer Flags... (%u bytes)\n",
               (int )oh.option_length);
        }
      }
#line 1041
      goto switch_break___6;
      case_3___5: /* CIL Label */ 
#line 1044
      if (verbose >= 2) {
        {
#line 1044
        printf((char const   */* __restrict  */)"[+] OPTION: Packet Hash... (%u bytes)\n",
               (int )oh.option_length);
        }
      }
#line 1045
      goto switch_break___6;
      case_4___4: /* CIL Label */ 
#line 1048
      if (verbose >= 2) {
        {
#line 1048
        printf((char const   */* __restrict  */)"[+] OPTION: Dropped Packets Counter... (%u bytes)\n",
               (int )oh.option_length);
        }
      }
#line 1049
      goto switch_break___6;
      switch_break___6: /* CIL Label */ ;
      }
#line 1053
      if ((int )oh.option_code > 4) {
        {
#line 1054
        printf((char const   */* __restrict  */)"[-] Unknown option code: 0x%04x (%u bytes) ==> SKIPPING.\n",
               (int )oh.option_code, (int )oh.option_length);
#line 1057
        fixes ++;
        }
#line 1060
        if (count == 0U) {
#line 1062
          if (verbose >= 1) {
            {
#line 1062
            printf((char const   */* __restrict  */)"[*] No Options inside -> no need for End of Options...\n");
            }
          }
#line 1063
          goto while_break___8;
        }
#line 1068
        if (verbose >= 1) {
          {
#line 1068
          printf((char const   */* __restrict  */)"[*] %u Options inside -> Finishing with End of Options...\n",
                 count);
          }
        }
#line 1071
        oh.option_code = (u_short )0;
#line 1072
        oh.option_length = (u_short )0;
      }
      {
#line 1078
      memcpy((void */* __restrict  */)(new_block + block_pos), (void const   */* __restrict  */)(& oh),
             sizeof(oh));
#line 1079
      block_pos = (unsigned int )((unsigned long )block_pos + sizeof(oh));
      }
#line 1082
      if ((int )oh.option_code == 0) {
#line 1082
        if ((int )oh.option_length == 0) {
#line 1082
          goto while_break___8;
        }
      }
#line 1085
      padding = (unsigned long )oh.option_length;
#line 1086
      if ((int )oh.option_length % 4 != 0) {
#line 1086
        padding += (unsigned long )(4 - (int )oh.option_length % 4);
      }
      {
#line 1089
      tmp___19 = malloc(padding);
#line 1089
      data = (char *)tmp___19;
#line 1090
      bytes = fread((void */* __restrict  */)data, padding, (size_t )1, (FILE */* __restrict  */)pcap);
#line 1091
      left = (long )((unsigned long )left - padding);
#line 1094
      memcpy((void */* __restrict  */)(new_block + block_pos), (void const   */* __restrict  */)data,
             padding);
#line 1095
      block_pos = (unsigned int )((unsigned long )block_pos + padding);
#line 1098
      free((void *)data);
#line 1100
      count ++;
      }
    }
    while_break___8: /* CIL Label */ ;
    }
#line 1102
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1107
    if (bh.block_type != 168627466U) {
#line 1107
      if (bh.block_type > 6U) {
        {
#line 1110
        printf((char const   */* __restrict  */)"[-] Unknown block type!: 0x%08x ==> SKIPPING.\n",
               bh.block_type);
#line 1113
        fixes ++;
        }
      } else {
#line 1107
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1107
    if (bh.block_type == 0U) {
      {
#line 1110
      printf((char const   */* __restrict  */)"[-] Unknown block type!: 0x%08x ==> SKIPPING.\n",
             bh.block_type);
#line 1113
      fixes ++;
      }
    } else {
      {
#line 1119
      block_pos = (unsigned int )((unsigned long )block_pos + sizeof(bh.total_length));
#line 1120
      memcpy((void */* __restrict  */)(new_block + 4), (void const   */* __restrict  */)(& block_pos),
             sizeof(bh.total_length));
#line 1121
      memcpy((void */* __restrict  */)((new_block + block_pos) - 4), (void const   */* __restrict  */)(& block_pos),
             sizeof(bh.total_length));
      }
#line 1124
      if (block_pos != bh.total_length) {
#line 1127
        if (verbose >= 1) {
          {
#line 1127
          printf((char const   */* __restrict  */)"[*] Block size adjusted (%u --> %u).\n",
                 bh.total_length, block_pos);
          }
        }
#line 1130
        fixes ++;
      }
#line 1134
      if (verbose >= 2) {
        {
#line 1134
        printf((char const   */* __restrict  */)"[*] Writing block to file (%u bytes).\n",
               block_pos);
        }
      }
      {
#line 1135
      bytes = fwrite((void const   */* __restrict  */)new_block, (size_t )block_pos,
                     (size_t )1, (FILE */* __restrict  */)pcap_fix);
#line 1136
      free((void *)new_block);
      }
#line 1139
      if (bh.block_type == 168627466U) {
#line 1139
        shb_num ++;
      }
#line 1140
      if (bh.block_type == 1U) {
#line 1140
        idb_num ++;
      }
    }
#line 1144
    if (left == 0L) {
#line 1146
      if (verbose >= 2) {
        {
#line 1146
        printf((char const   */* __restrict  */)"[+] End of Block reached... byte counter is correct!\n");
        }
      }
    } else
#line 1149
    if (verbose >= 1) {
      {
#line 1149
      printf((char const   */* __restrict  */)"[-] Did not hit the end of the block! (%ld bytes left)\n",
             left);
      }
    }
    {
#line 1153
    bytes = fread((void */* __restrict  */)(& check), sizeof(check), (size_t )1, (FILE */* __restrict  */)pcap);
    }
#line 1156
    if (check == bh.total_length) {
#line 1158
      if (verbose >= 2) {
        {
#line 1158
        printf((char const   */* __restrict  */)"[+] Block size matches (%u)!\n",
               check);
        }
      }
    } else {
      {
#line 1162
      printf((char const   */* __restrict  */)"[-] Block size mismatch (0x%08x != 0x%08x) ==> CORRECTED.\n",
             check, bh.total_length);
#line 1163
      fixes ++;
#line 1168
      tmp___20 = ftell(pcap);
#line 1168
      bytes = (unsigned long )tmp___20;
      }
#line 1170
      if (bytes != filesize) {
#line 1173
        if (verbose >= 1) {
          {
#line 1173
          printf((char const   */* __restrict  */)"[*] Trying to align next block...\n");
          }
        }
        {
#line 1174
        res = find_valid_block(pcap, filesize);
#line 1177
        tmp___21 = ftell(pcap);
#line 1177
        printf((char const   */* __restrict  */)"[-] Found %ld bytes of unknown data ==> SKIPPING.\n",
               (unsigned long )tmp___21 - bytes);
#line 1180
        fixes ++;
        }
#line 1183
        if (res == -1) {
#line 1185
          if (verbose >= 1) {
            {
#line 1185
            printf((char const   */* __restrict  */)"[*] No more valid blocks found inside file! (maybe it was the last one)\n");
            }
          }
#line 1186
          goto while_break;
        }
      }
    }
    {
#line 1194
    tmp___22 = ftell(pcap);
#line 1194
    pos = (unsigned long )tmp___22;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1202
  if (shb_num == 0U) {
#line 1202
    return (-1);
  }
#line 1205
  return (fixes);
}
}
#line 1220 "/home/wheatley/newnew/temp/pcapfix-1.0.1/pcapng.c"
int find_valid_block(FILE *pcap , unsigned long filesize ) 
{ 
  unsigned int bytes ;
  unsigned long i ;
  unsigned int check ;
  struct block_header bh ;
  long tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 1227
  tmp = ftell(pcap);
#line 1227
  i = (unsigned long )(tmp - 4L);
  }
  {
#line 1227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1227
    if (! (i < filesize)) {
#line 1227
      goto while_break;
    }
    {
#line 1229
    fseek(pcap, (long )i, 0);
#line 1232
    tmp___0 = fread((void */* __restrict  */)(& bh), sizeof(bh), (size_t )1, (FILE */* __restrict  */)pcap);
#line 1232
    bytes = (unsigned int )tmp___0;
    }
#line 1233
    if (bytes != 1U) {
#line 1233
      return (-1);
    }
#line 1238
    if (bh.total_length >= 12U) {
#line 1238
      if (bh.block_type >= 1U) {
#line 1238
        if (bh.block_type <= 6U) {
          {
#line 1242
          fseek(pcap, (long )((i + (unsigned long )bh.total_length) - 4UL), 0);
#line 1243
          tmp___1 = fread((void */* __restrict  */)(& check), sizeof(check), (size_t )1,
                          (FILE */* __restrict  */)pcap);
#line 1243
          bytes = (unsigned int )tmp___1;
          }
#line 1244
          if (check == bh.total_length) {
#line 1246
            if (verbose >= 1) {
              {
#line 1246
              printf((char const   */* __restrict  */)"[+] FOUND: Block (Type: 0x%08x) at Position %ld\n",
                     bh.block_type, i);
              }
            }
            {
#line 1249
            fseek(pcap, (long )i, 0);
            }
#line 1250
            return (0);
          }
        }
      }
    }
#line 1227
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1256
  return (-1);
}
}
#line 1271 "/home/wheatley/newnew/temp/pcapfix-1.0.1/pcapng.c"
int write_shb(FILE *pcap_fix ) 
{ 
  struct block_header bh ;
  struct section_header_block shb ;
  struct option_header oh ;
  unsigned long bytes ;
  unsigned int size ;
  unsigned int padding ;
  unsigned char *data ;
  char comment[22] ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 1277
  size = 0U;
#line 1283
  comment[0] = (char )'A';
#line 1283
  comment[1] = (char )'d';
#line 1283
  comment[2] = (char )'d';
#line 1283
  comment[3] = (char )'e';
#line 1283
  comment[4] = (char )'d';
#line 1283
  comment[5] = (char )' ';
#line 1283
  comment[6] = (char )'b';
#line 1283
  comment[7] = (char )'y';
#line 1283
  comment[8] = (char )' ';
#line 1283
  comment[9] = (char )'p';
#line 1283
  comment[10] = (char )'c';
#line 1283
  comment[11] = (char )'a';
#line 1283
  comment[12] = (char )'p';
#line 1283
  comment[13] = (char )'f';
#line 1283
  comment[14] = (char )'i';
#line 1283
  comment[15] = (char )'x';
#line 1283
  comment[16] = (char )'.';
#line 1283
  comment[17] = (char )'\000';
#line 1283
  comment[18] = (char )'\000';
#line 1283
  comment[19] = (char )'\000';
#line 1283
  comment[20] = (char )'\000';
#line 1283
  comment[21] = (char )'\000';
#line 1286
  bh.block_type = (u_int32_t )168627466;
#line 1289
  size = (unsigned int )((unsigned long )size + sizeof(struct block_header ));
#line 1292
  shb.byte_order_magic = (u_int32_t )439041101;
#line 1293
  shb.major_version = (u_short )1;
#line 1294
  shb.minor_version = (u_short )0;
#line 1297
  size = (unsigned int )((unsigned long )size + sizeof(struct section_header_block ));
#line 1300
  oh.option_code = (u_short )1;
#line 1301
  tmp = strlen((char const   *)(comment));
#line 1301
  oh.option_length = (u_short )tmp;
#line 1304
  size = (unsigned int )((unsigned long )size + sizeof(struct option_header ));
#line 1307
  padding = (unsigned int )oh.option_length;
  }
#line 1308
  if ((int )oh.option_length % 4 != 0) {
#line 1308
    padding += (unsigned int )(4 - (int )oh.option_length % 4);
  }
  {
#line 1311
  size += padding;
#line 1314
  size += 4U;
#line 1317
  size += 4U;
#line 1320
  bh.total_length = size;
#line 1323
  tmp___0 = malloc((size_t )size);
#line 1323
  data = (unsigned char *)tmp___0;
#line 1326
  memcpy((void */* __restrict  */)data, (void const   */* __restrict  */)(& bh), sizeof(bh));
#line 1328
  memcpy((void */* __restrict  */)(data + sizeof(bh)), (void const   */* __restrict  */)(& shb),
         sizeof(shb));
#line 1330
  memcpy((void */* __restrict  */)((data + sizeof(bh)) + sizeof(shb)), (void const   */* __restrict  */)(& oh),
         sizeof(oh));
#line 1332
  memcpy((void */* __restrict  */)(((data + sizeof(bh)) + sizeof(shb)) + sizeof(oh)),
         (void const   */* __restrict  */)(comment), (size_t )padding);
#line 1334
  memset((void *)((((data + sizeof(bh)) + sizeof(shb)) + sizeof(oh)) + padding), 0,
         (size_t )4);
#line 1336
  memcpy((void */* __restrict  */)(((((data + sizeof(bh)) + sizeof(shb)) + sizeof(oh)) + padding) + 4),
         (void const   */* __restrict  */)(& size), sizeof(size));
#line 1339
  bytes = fwrite((void const   */* __restrict  */)data, (size_t )size, (size_t )1,
                 (FILE */* __restrict  */)pcap_fix);
  }
#line 1340
  if (bytes != 1UL) {
#line 1340
    return (-1);
  }
  {
#line 1343
  free((void *)data);
  }
#line 1346
  return (0);
}
}
#line 1361 "/home/wheatley/newnew/temp/pcapfix-1.0.1/pcapng.c"
int write_idb(FILE *pcap_fix ) 
{ 
  struct block_header bh ;
  struct interface_description_block idb ;
  struct option_header oh ;
  unsigned long bytes ;
  unsigned int size ;
  unsigned int padding ;
  unsigned char *data ;
  char comment[22] ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 1367
  size = 0U;
#line 1373
  comment[0] = (char )'A';
#line 1373
  comment[1] = (char )'d';
#line 1373
  comment[2] = (char )'d';
#line 1373
  comment[3] = (char )'e';
#line 1373
  comment[4] = (char )'d';
#line 1373
  comment[5] = (char )' ';
#line 1373
  comment[6] = (char )'b';
#line 1373
  comment[7] = (char )'y';
#line 1373
  comment[8] = (char )' ';
#line 1373
  comment[9] = (char )'p';
#line 1373
  comment[10] = (char )'c';
#line 1373
  comment[11] = (char )'a';
#line 1373
  comment[12] = (char )'p';
#line 1373
  comment[13] = (char )'f';
#line 1373
  comment[14] = (char )'i';
#line 1373
  comment[15] = (char )'x';
#line 1373
  comment[16] = (char )'.';
#line 1373
  comment[17] = (char )'\000';
#line 1373
  comment[18] = (char )'\000';
#line 1373
  comment[19] = (char )'\000';
#line 1373
  comment[20] = (char )'\000';
#line 1373
  comment[21] = (char )'\000';
#line 1376
  bh.block_type = (u_int32_t )1;
#line 1379
  size = (unsigned int )((unsigned long )size + sizeof(struct block_header ));
#line 1384
  if (data_link_type != -1) {
#line 1385
    idb.linktype = (u_short )data_link_type;
  } else {
#line 1387
    idb.linktype = (u_short )1;
  }
  {
#line 1391
  idb.reserved = (u_short )0;
#line 1394
  idb.snaplen = (u_int32_t )65535;
#line 1397
  size = (unsigned int )((unsigned long )size + sizeof(struct interface_description_block ));
#line 1400
  oh.option_code = (u_short )1;
#line 1401
  tmp = strlen((char const   *)(comment));
#line 1401
  oh.option_length = (u_short )tmp;
#line 1404
  size = (unsigned int )((unsigned long )size + sizeof(struct option_header ));
#line 1407
  padding = (unsigned int )oh.option_length;
  }
#line 1408
  if ((int )oh.option_length % 4 != 0) {
#line 1408
    padding += (unsigned int )(4 - (int )oh.option_length % 4);
  }
  {
#line 1411
  size += padding;
#line 1414
  size += 4U;
#line 1417
  size += 4U;
#line 1420
  bh.total_length = size;
#line 1423
  tmp___0 = malloc((size_t )size);
#line 1423
  data = (unsigned char *)tmp___0;
#line 1426
  memcpy((void */* __restrict  */)data, (void const   */* __restrict  */)(& bh), sizeof(bh));
#line 1428
  memcpy((void */* __restrict  */)(data + sizeof(bh)), (void const   */* __restrict  */)(& idb),
         sizeof(idb));
#line 1430
  memcpy((void */* __restrict  */)((data + sizeof(bh)) + sizeof(idb)), (void const   */* __restrict  */)(& oh),
         sizeof(oh));
#line 1432
  memcpy((void */* __restrict  */)(((data + sizeof(bh)) + sizeof(idb)) + sizeof(oh)),
         (void const   */* __restrict  */)(comment), (size_t )padding);
#line 1434
  memset((void *)((((data + sizeof(bh)) + sizeof(idb)) + sizeof(oh)) + padding), 0,
         (size_t )4);
#line 1436
  memcpy((void */* __restrict  */)(((((data + sizeof(bh)) + sizeof(idb)) + sizeof(oh)) + padding) + 4),
         (void const   */* __restrict  */)(& size), sizeof(size));
#line 1439
  bytes = fwrite((void const   */* __restrict  */)data, (size_t )size, (size_t )1,
                 (FILE */* __restrict  */)pcap_fix);
  }
#line 1440
  if (bytes != 1UL) {
#line 1440
    return (-1);
  }
  {
#line 1443
  free((void *)data);
  }
#line 1446
  return (0);
}
}
