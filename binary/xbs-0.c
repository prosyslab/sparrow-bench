/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 66 "/usr/include/X11/X.h"
typedef unsigned long XID;
#line 74 "/usr/include/X11/X.h"
typedef unsigned long Atom;
#line 76 "/usr/include/X11/X.h"
typedef unsigned long VisualID;
#line 77 "/usr/include/X11/X.h"
typedef unsigned long Time;
#line 96 "/usr/include/X11/X.h"
typedef XID Window;
#line 97 "/usr/include/X11/X.h"
typedef XID Drawable;
#line 100 "/usr/include/X11/X.h"
typedef XID Font;
#line 102 "/usr/include/X11/X.h"
typedef XID Pixmap;
#line 104 "/usr/include/X11/X.h"
typedef XID Colormap;
#line 106 "/usr/include/X11/X.h"
typedef XID KeySym;
#line 92 "/usr/include/X11/Xlib.h"
typedef char *XPointer;
#line 160 "/usr/include/X11/Xlib.h"
struct _XExtData {
   int number ;
   struct _XExtData *next ;
   int (*free_private)(struct _XExtData *extension ) ;
   XPointer private_data ;
};
#line 160 "/usr/include/X11/Xlib.h"
typedef struct _XExtData XExtData;
#line 193 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGCValues_51 {
   int function ;
   unsigned long plane_mask ;
   unsigned long foreground ;
   unsigned long background ;
   int line_width ;
   int line_style ;
   int cap_style ;
   int join_style ;
   int fill_style ;
   int fill_rule ;
   int arc_mode ;
   Pixmap tile ;
   Pixmap stipple ;
   int ts_x_origin ;
   int ts_y_origin ;
   Font font ;
   int subwindow_mode ;
   int graphics_exposures ;
   int clip_x_origin ;
   int clip_y_origin ;
   Pixmap clip_mask ;
   int dash_offset ;
   char dashes ;
};
#line 193 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGCValues_51 XGCValues;
#line 226
struct _XGC;
#line 226 "/usr/include/X11/Xlib.h"
typedef struct _XGC *GC;
#line 239 "/usr/include/X11/Xlib.h"
struct __anonstruct_Visual_52 {
   XExtData *ext_data ;
   VisualID visualid ;
   int class ;
   unsigned long red_mask ;
   unsigned long green_mask ;
   unsigned long blue_mask ;
   int bits_per_rgb ;
   int map_entries ;
};
#line 239 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Visual_52 Visual;
#line 255 "/usr/include/X11/Xlib.h"
struct __anonstruct_Depth_53 {
   int depth ;
   int nvisuals ;
   Visual *visuals ;
};
#line 255 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Depth_53 Depth;
#line 267
struct _XDisplay;
#line 267
struct _XDisplay;
#line 269 "/usr/include/X11/Xlib.h"
struct __anonstruct_Screen_54 {
   XExtData *ext_data ;
   struct _XDisplay *display ;
   Window root ;
   int width ;
   int height ;
   int mwidth ;
   int mheight ;
   int ndepths ;
   Depth *depths ;
   int root_depth ;
   Visual *root_visual ;
   GC default_gc ;
   Colormap cmap ;
   unsigned long white_pixel ;
   unsigned long black_pixel ;
   int max_maps ;
   int min_maps ;
   int backing_store ;
   int save_unders ;
   long root_input_mask ;
};
#line 269 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Screen_54 Screen;
#line 292 "/usr/include/X11/Xlib.h"
struct __anonstruct_ScreenFormat_55 {
   XExtData *ext_data ;
   int depth ;
   int bits_per_pixel ;
   int scanline_pad ;
};
#line 292 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_ScreenFormat_55 ScreenFormat;
#line 422 "/usr/include/X11/Xlib.h"
struct __anonstruct_XColor_61 {
   unsigned long pixel ;
   unsigned short red ;
   unsigned short green ;
   unsigned short blue ;
   char flags ;
   char pad ;
};
#line 422 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XColor_61 XColor;
#line 438 "/usr/include/X11/Xlib.h"
struct __anonstruct_XPoint_63 {
   short x ;
   short y ;
};
#line 438 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XPoint_63 XPoint;
#line 499 "/usr/include/X11/Xlib.h"
typedef struct _XDisplay Display;
#line 502
struct _XPrivate;
#line 502
struct _XPrivate;
#line 503
struct _XrmHashBucketRec;
#line 503
struct _XrmHashBucketRec;
#line 505 "/usr/include/X11/Xlib.h"
struct __anonstruct__XPrivDisplay_70 {
   XExtData *ext_data ;
   struct _XPrivate *private1 ;
   int fd ;
   int private2 ;
   int proto_major_version ;
   int proto_minor_version ;
   char *vendor ;
   XID private3 ;
   XID private4 ;
   XID private5 ;
   int private6 ;
   XID (*resource_alloc)(struct _XDisplay * ) ;
   int byte_order ;
   int bitmap_unit ;
   int bitmap_pad ;
   int bitmap_bit_order ;
   int nformats ;
   ScreenFormat *pixmap_format ;
   int private8 ;
   int release ;
   struct _XPrivate *private9 ;
   struct _XPrivate *private10 ;
   int qlen ;
   unsigned long last_request_read ;
   unsigned long request ;
   XPointer private11 ;
   XPointer private12 ;
   XPointer private13 ;
   XPointer private14 ;
   unsigned int max_request_size ;
   struct _XrmHashBucketRec *db ;
   int (*private15)(struct _XDisplay * ) ;
   char *display_name ;
   int default_screen ;
   int nscreens ;
   Screen *screens ;
   unsigned long motion_buffer ;
   unsigned long private16 ;
   int min_keycode ;
   int max_keycode ;
   XPointer private17 ;
   XPointer private18 ;
   int private19 ;
   char *xdefaults ;
};
#line 505 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct__XPrivDisplay_70 *_XPrivDisplay;
#line 569 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeyEvent_71 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int keycode ;
   int same_screen ;
};
#line 569 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeyEvent_71 XKeyEvent;
#line 587 "/usr/include/X11/Xlib.h"
struct __anonstruct_XButtonEvent_72 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int button ;
   int same_screen ;
};
#line 587 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XButtonEvent_72 XButtonEvent;
#line 605 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMotionEvent_73 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   char is_hint ;
   int same_screen ;
};
#line 605 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMotionEvent_73 XMotionEvent;
#line 622 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCrossingEvent_74 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   int mode ;
   int detail ;
   int same_screen ;
   int focus ;
   unsigned int state ;
};
#line 622 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCrossingEvent_74 XCrossingEvent;
#line 646 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFocusChangeEvent_75 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int mode ;
   int detail ;
};
#line 646 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFocusChangeEvent_75 XFocusChangeEvent;
#line 665 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeymapEvent_76 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   char key_vector[32] ;
};
#line 665 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeymapEvent_76 XKeymapEvent;
#line 674 "/usr/include/X11/Xlib.h"
struct __anonstruct_XExposeEvent_77 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
};
#line 674 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XExposeEvent_77 XExposeEvent;
#line 685 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGraphicsExposeEvent_78 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
   int major_code ;
   int minor_code ;
};
#line 685 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGraphicsExposeEvent_78 XGraphicsExposeEvent;
#line 698 "/usr/include/X11/Xlib.h"
struct __anonstruct_XNoExposeEvent_79 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int major_code ;
   int minor_code ;
};
#line 698 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XNoExposeEvent_79 XNoExposeEvent;
#line 708 "/usr/include/X11/Xlib.h"
struct __anonstruct_XVisibilityEvent_80 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int state ;
};
#line 708 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XVisibilityEvent_80 XVisibilityEvent;
#line 717 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCreateWindowEvent_81 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   int override_redirect ;
};
#line 717 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCreateWindowEvent_81 XCreateWindowEvent;
#line 730 "/usr/include/X11/Xlib.h"
struct __anonstruct_XDestroyWindowEvent_82 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
};
#line 730 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XDestroyWindowEvent_82 XDestroyWindowEvent;
#line 739 "/usr/include/X11/Xlib.h"
struct __anonstruct_XUnmapEvent_83 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int from_configure ;
};
#line 739 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XUnmapEvent_83 XUnmapEvent;
#line 749 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapEvent_84 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int override_redirect ;
};
#line 749 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapEvent_84 XMapEvent;
#line 759 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapRequestEvent_85 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
};
#line 759 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapRequestEvent_85 XMapRequestEvent;
#line 768 "/usr/include/X11/Xlib.h"
struct __anonstruct_XReparentEvent_86 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   Window parent ;
   int x ;
   int y ;
   int override_redirect ;
};
#line 768 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XReparentEvent_86 XReparentEvent;
#line 780 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureEvent_87 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int override_redirect ;
};
#line 780 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureEvent_87 XConfigureEvent;
#line 794 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGravityEvent_88 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
};
#line 794 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGravityEvent_88 XGravityEvent;
#line 804 "/usr/include/X11/Xlib.h"
struct __anonstruct_XResizeRequestEvent_89 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int width ;
   int height ;
};
#line 804 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XResizeRequestEvent_89 XResizeRequestEvent;
#line 813 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureRequestEvent_90 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int detail ;
   unsigned long value_mask ;
};
#line 813 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureRequestEvent_90 XConfigureRequestEvent;
#line 828 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateEvent_91 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int place ;
};
#line 828 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateEvent_91 XCirculateEvent;
#line 838 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateRequestEvent_92 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int place ;
};
#line 838 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateRequestEvent_92 XCirculateRequestEvent;
#line 848 "/usr/include/X11/Xlib.h"
struct __anonstruct_XPropertyEvent_93 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom atom ;
   Time time ;
   int state ;
};
#line 848 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XPropertyEvent_93 XPropertyEvent;
#line 859 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionClearEvent_94 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom selection ;
   Time time ;
};
#line 859 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionClearEvent_94 XSelectionClearEvent;
#line 869 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionRequestEvent_95 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window owner ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 869 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionRequestEvent_95 XSelectionRequestEvent;
#line 882 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionEvent_96 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 882 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionEvent_96 XSelectionEvent;
#line 894 "/usr/include/X11/Xlib.h"
struct __anonstruct_XColormapEvent_97 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Colormap colormap ;
   int new ;
   int state ;
};
#line 894 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XColormapEvent_97 XColormapEvent;
#line 909 "/usr/include/X11/Xlib.h"
union __anonunion_data_99 {
   char b[20] ;
   short s[10] ;
   long l[5] ;
};
#line 909 "/usr/include/X11/Xlib.h"
struct __anonstruct_XClientMessageEvent_98 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom message_type ;
   int format ;
   union __anonunion_data_99 data ;
};
#line 909 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XClientMessageEvent_98 XClientMessageEvent;
#line 924 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMappingEvent_100 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int request ;
   int first_keycode ;
   int count ;
};
#line 924 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMappingEvent_100 XMappingEvent;
#line 936 "/usr/include/X11/Xlib.h"
struct __anonstruct_XErrorEvent_101 {
   int type ;
   Display *display ;
   XID resourceid ;
   unsigned long serial ;
   unsigned char error_code ;
   unsigned char request_code ;
   unsigned char minor_code ;
};
#line 936 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XErrorEvent_101 XErrorEvent;
#line 946 "/usr/include/X11/Xlib.h"
struct __anonstruct_XAnyEvent_102 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
};
#line 946 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XAnyEvent_102 XAnyEvent;
#line 960 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGenericEvent_103 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
};
#line 960 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGenericEvent_103 XGenericEvent;
#line 970 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGenericEventCookie_104 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
   unsigned int cookie ;
   void *data ;
};
#line 970 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGenericEventCookie_104 XGenericEventCookie;
#line 985 "/usr/include/X11/Xlib.h"
union _XEvent {
   int type ;
   XAnyEvent xany ;
   XKeyEvent xkey ;
   XButtonEvent xbutton ;
   XMotionEvent xmotion ;
   XCrossingEvent xcrossing ;
   XFocusChangeEvent xfocus ;
   XExposeEvent xexpose ;
   XGraphicsExposeEvent xgraphicsexpose ;
   XNoExposeEvent xnoexpose ;
   XVisibilityEvent xvisibility ;
   XCreateWindowEvent xcreatewindow ;
   XDestroyWindowEvent xdestroywindow ;
   XUnmapEvent xunmap ;
   XMapEvent xmap ;
   XMapRequestEvent xmaprequest ;
   XReparentEvent xreparent ;
   XConfigureEvent xconfigure ;
   XGravityEvent xgravity ;
   XResizeRequestEvent xresizerequest ;
   XConfigureRequestEvent xconfigurerequest ;
   XCirculateEvent xcirculate ;
   XCirculateRequestEvent xcirculaterequest ;
   XPropertyEvent xproperty ;
   XSelectionClearEvent xselectionclear ;
   XSelectionRequestEvent xselectionrequest ;
   XSelectionEvent xselection ;
   XColormapEvent xcolormap ;
   XClientMessageEvent xclient ;
   XMappingEvent xmapping ;
   XErrorEvent xerror ;
   XKeymapEvent xkeymap ;
   XGenericEvent xgeneric ;
   XGenericEventCookie xcookie ;
   long pad[24] ;
};
#line 985 "/usr/include/X11/Xlib.h"
typedef union _XEvent XEvent;
#line 81 "/usr/include/X11/Xutil.h"
struct __anonstruct_min_aspect_130 {
   int x ;
   int y ;
};
#line 81 "/usr/include/X11/Xutil.h"
struct __anonstruct_XSizeHints_129 {
   long flags ;
   int x ;
   int y ;
   int width ;
   int height ;
   int min_width ;
   int min_height ;
   int max_width ;
   int max_height ;
   int width_inc ;
   int height_inc ;
   struct __anonstruct_min_aspect_130 min_aspect ;
   struct __anonstruct_min_aspect_130 max_aspect ;
   int base_width ;
   int base_height ;
   int win_gravity ;
};
#line 81 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XSizeHints_129 XSizeHints;
#line 231 "/usr/include/X11/Xutil.h"
struct _XComposeStatus {
   XPointer compose_ptr ;
   int chars_matched ;
};
#line 231 "/usr/include/X11/Xutil.h"
typedef struct _XComposeStatus XComposeStatus;
#line 74 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
struct ballstr {
   float pos[3] ;
   float rad ;
   float gray ;
   float r ;
   float g ;
   float b ;
   int col ;
   int special ;
   char lab[21] ;
};
#line 84 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
struct stickstr {
   int start ;
   int end ;
   float rad ;
   float gray ;
   int col ;
};
#line 94 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
struct __anonstruct_spec_140 {
   char lab[21] ;
   float rad ;
   float r ;
   float g ;
   float b ;
   char cname[81] ;
   int col ;
   float gray ;
};
#line 103 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
struct __anonstruct_atom_141 {
   char lab[21] ;
   float pos[3] ;
   float pol[3] ;
};
#line 109 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
struct __anonstruct_bonds_142 {
   char lab1[21] ;
   char lab2[21] ;
   float min ;
   float max ;
   float rad ;
   float r ;
   float g ;
   float b ;
   char cname[81] ;
   int col ;
   float gray ;
};
#line 121 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
struct __anonstruct_xline_143 {
   float a[3] ;
   float b[3] ;
};
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 425
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __asm__("__isoc99_fscanf")  ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 144 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 1495 "/usr/include/X11/Xlib.h"
extern Display *XOpenDisplay(char const   * ) ;
#line 1592
extern Font XLoadFont(Display * , char const   * ) ;
#line 1596
extern GC XCreateGC(Display * , Drawable  , unsigned long  , XGCValues * ) ;
#line 1609
extern Pixmap XCreatePixmap(Display * , Drawable  , unsigned int  , unsigned int  ,
                            unsigned int  ) ;
#line 1616
extern Pixmap XCreateBitmapFromData(Display * , Drawable  , char const   * , unsigned int  ,
                                    unsigned int  ) ;
#line 1623
extern Pixmap XCreatePixmapFromBitmapData(Display * , Drawable  , char * , unsigned int  ,
                                          unsigned int  , unsigned long  , unsigned long  ,
                                          unsigned int  ) ;
#line 1633
extern Window XCreateSimpleWindow(Display * , Window  , int  , int  , unsigned int  ,
                                  unsigned int  , unsigned int  , unsigned long  ,
                                  unsigned long  ) ;
#line 1830
extern Colormap XDefaultColormap(Display * , int  ) ;
#line 1970
extern int XAllocColor(Display * , Colormap  , XColor * ) ;
#line 2022
extern int XBell(Display * , int  ) ;
#line 2121
extern int XCheckTypedEvent(Display * , int  , XEvent * ) ;
#line 2172
extern int XCloseDisplay(Display * ) ;
#line 2196
extern int XCopyArea(Display * , Drawable  , Drawable  , GC  , int  , int  , unsigned int  ,
                     unsigned int  , int  , int  ) ;
#line 2230
extern int XDefaultDepth(Display * , int  ) ;
#line 2255
extern int XDestroyWindow(Display * , Window  ) ;
#line 2314
extern int XDrawArc(Display * , Drawable  , GC  , int  , int  , unsigned int  , unsigned int  ,
                    int  , int  ) ;
#line 2354
extern int XDrawLine(Display * , Drawable  , GC  , int  , int  , int  , int  ) ;
#line 2364
extern int XDrawLines(Display * , Drawable  , GC  , XPoint * , int  , int  ) ;
#line 2416
extern int XDrawString(Display * , Drawable  , GC  , int  , int  , char const   * ,
                       int  ) ;
#line 2471
extern int XFillArc(Display * , Drawable  , GC  , int  , int  , unsigned int  , unsigned int  ,
                    int  , int  ) ;
#line 2491
extern int XFillPolygon(Display * , Drawable  , GC  , XPoint * , int  , int  , int  ) ;
#line 2501
extern int XFillRectangle(Display * , Drawable  , GC  , int  , int  , unsigned int  ,
                          unsigned int  ) ;
#line 2519
extern int XFlush(Display * ) ;
#line 2573
extern int XFreeGC(Display * , GC  ) ;
#line 2582
extern int XFreePixmap(Display * , Pixmap  ) ;
#line 2795
extern int XLookupColor(Display * , Colormap  , char const   * , XColor * , XColor * ) ;
#line 2808
extern int XMapRaised(Display * , Window  ) ;
#line 2853
extern int XNextEvent(Display * , XEvent * ) ;
#line 2869
extern int XParseGeometry(char const   * , int * , int * , unsigned int * , unsigned int * ) ;
#line 2910
extern int XPutBackEvent(Display * , XEvent * ) ;
#line 3141
extern int XSelectInput(Display * , Window  , long  ) ;
#line 3166
extern int XSetBackground(Display * , GC  , unsigned long  ) ;
#line 3221
extern int XSetFillStyle(Display * , GC  , int  ) ;
#line 3227
extern int XSetFont(Display * , GC  , Font  ) ;
#line 3239
extern int XSetForeground(Display * , GC  , unsigned long  ) ;
#line 3270
extern int XSetLineAttributes(Display * , GC  , unsigned int  , int  , int  , int  ) ;
#line 3339
extern int XSetTile(Display * , GC  , Pixmap  ) ;
#line 534 "/usr/include/X11/Xutil.h"
extern int XLookupString(XKeyEvent * , char * , int  , KeySym * , XComposeStatus * ) ;
#line 617
extern int XSetStandardProperties(Display * , Window  , char const   * , char const   * ,
                                  Pixmap  , char ** , int  , XSizeHints * ) ;
#line 54 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) acos)(double __x ) ;
#line 56
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) asin)(double __x ) ;
#line 63
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) cos)(double __x ) ;
#line 65
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sin)(double __x ) ;
#line 100
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) exp)(double __x ) ;
#line 153
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) pow)(double __x ,
                                                                             double __y ) ;
#line 156
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sqrt)(double __x ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 264
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
#line 94 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
struct __anonstruct_spec_140 spec[50]  ;
#line 103 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
struct __anonstruct_atom_141 atom[2000]  ;
#line 109 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
struct __anonstruct_bonds_142 bonds[200]  ;
#line 121 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
struct __anonstruct_xline_143 xline[50]  ;
#line 125 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int natom  ;
#line 125 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int nbond  ;
#line 126 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
struct ballstr ball[2000]  ;
#line 127 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
struct stickstr stick[8000]  ;
#line 129 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
float arc[5][2]  ;
#line 129 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
float xbot  ;
#line 129 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
float xtop  ;
#line 129 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
float ybot  ;
#line 129 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
float ytop  ;
#line 131 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
Display *dpy  ;
#line 132 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
Window win  ;
#line 133 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
Drawable drw  ;
#line 134 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
Pixmap pixmap  ;
#line 134 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
Pixmap bgrmap  ;
#line 135 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
GC gc  ;
#line 135 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
GC gcbg  ;
#line 135 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
GC graygc[31]  ;
#line 135 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
GC shadowgc  ;
#line 135 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
GC labelgc  ;
#line 135 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
GC labbggc  ;
#line 135 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
GC lngc  ;
#line 136 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
unsigned long fground  ;
#line 136 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
unsigned long bground  ;
#line 136 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
unsigned long gpx[31]  ;
#line 137 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int screen  ;
#line 137 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int depth  ;
#line 137 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int ncol  ;
#line 138 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
Screen *screenptr  ;
#line 139 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
Colormap cmap  ;
#line 142 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
float p[2000][3]  ;
#line 143 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int nspec  ;
#line 143 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int nbas  ;
#line 143 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int nbonds  ;
#line 143 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int ngray  ;
#line 143 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int nxline  ;
#line 144 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int count  ;
#line 145 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int ipr  =    10;
#line 146 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int igeo  ;
#line 146 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int igx  ;
#line 146 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int igy  ;
#line 146 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int igw  ;
#line 146 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int igh  ;
#line 147 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
float igs  ;
#line 148 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int midx  ;
#line 148 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int midy  ;
#line 149 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
float alat  ;
#line 149 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
float dist  ;
#line 149 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
float dist0  ;
#line 149 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
float amp  ;
#line 149 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
float dalfa  ;
#line 149 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
float scale  ;
#line 149 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
float tmat[3][3]  ;
#line 149 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
float radfac  ;
#line 149 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
float bndfac  ;
#line 150 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
float taux  ;
#line 150 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
float tauy  ;
#line 150 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
float dtaux  ;
#line 150 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
float dtauy  ;
#line 150 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
float taux0  ;
#line 150 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
float tauy0  ;
#line 150 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
float bg  ;
#line 151 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
float gslope  ;
#line 151 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
float gz0  ;
#line 151 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
float light[3]  ;
#line 152 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
float center[3]  ;
#line 154 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
float frame[3][70000]  ;
#line 155 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
char frstr[8000][81]  ;
#line 156 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int nframe  ;
#line 156 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int iframe  ;
#line 156 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int saveframe  ;
#line 158 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
FILE *outfp  ;
#line 159 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int hardcopy  ;
#line 159 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int usepixmap  ;
#line 159 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int numbers  ;
#line 159 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int grayvalues  ;
#line 159 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int wrinfo  ;
#line 159 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int fstep  ;
#line 159 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int wrhelp  ;
#line 160 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int bline  ;
#line 160 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int wire  ;
#line 160 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int withbonds  ;
#line 160 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int recenter  ;
#line 160 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int pmode  ;
#line 160 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int gmode  ;
#line 160 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int shadow  ;
#line 160 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int bondnums  ;
#line 161 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int color  ;
#line 161 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int autocolor  ;
#line 161 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int reverse  ;
#line 161 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int coords  ;
#line 161 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int stippled  ;
#line 162 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int showaxes  ;
#line 162 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int showlines  ;
#line 163 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int replot  ;
#line 163 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int resetup  ;
#line 163 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int startup  ;
#line 163 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int chginfo  ;
#line 164 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int num_print  ;
#line 165 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
float pr_xoff  ;
#line 165 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
float pr_yoff  ;
#line 166 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int lnum  ;
#line 166 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int xln  ;
#line 168 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
char inf[81]  = {      (char )'i',      (char )'n',      (char )'.',      (char )'b', 
        (char )'s',      (char )'\000'};
#line 168 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
char outf[81]  = 
#line 168
  {      (char )'S',      (char )'a',      (char )'v',      (char )'e', 
        (char )'.',      (char )'b',      (char )'s',      (char )'\000'};
#line 168 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
char prf[81]  = {      (char )'B',      (char )'s',      (char )'.',      (char )'p', 
        (char )'s',      (char )'\000'};
#line 169 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
char inmv[81]  ;
#line 169 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
char prfsave[81]  ;
#line 169 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
char wname[81]  ;
#line 169 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
char curf[81]  ;
#line 170 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
char gmsg[101]  ;
#line 170 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
char emsg[101]  ;
#line 171 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
char svinput[10][257]  ;
#line 172 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int svline  ;
#line 172 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int nsvline  =    1;
#line 175
void WriteStatus(Drawable draw ) ;
#line 176
void WriteInfo(Drawable draw ) ;
#line 177
void WriteHelp(void) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 13 "/home/june/repo/benchmarks/collector2/temp/xbs-0/grsubs.h"
int parse_color(char *str , float *rval , float *gval , float *bval , float *gray ) 
{ 
  int isname ;
  int j ;
  int j0___0 ;
  int rc ;
  XColor color___0 ;
  XColor exact ;
  float r ;
  float g ;
  float b ;
  char cname[81] ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 22
  rc = 1;
#line 23
  strcpy((char */* __restrict  */)(cname), (char const   */* __restrict  */)str);
#line 24
  j0___0 = 0;
#line 25
  isname = 0;
#line 26
  j = 0;
  }
  {
#line 26
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 26
    tmp___0 = strlen((char const   *)(cname));
    }
#line 26
    if (! ((size_t )j < tmp___0)) {
#line 26
      goto while_break;
    }
    {
#line 27
    tmp = __ctype_b_loc();
    }
#line 27
    if ((int const   )*(*tmp + (int )cname[j]) & 1024) {
#line 27
      isname = 1;
    }
#line 28
    if ((int )cname[j] != 32) {
#line 28
      j0___0 = j;
    }
#line 26
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 31
  if (isname) {
#line 32
    if (j0___0 > 0) {
#line 32
      cname[j0___0 + 1] = (char)0;
    }
#line 33
    if (j0___0 > 0) {
#line 33
      *(str + (j0___0 + 1)) = (char)0;
    }
    {
#line 34
    tmp___1 = XLookupColor(dpy, cmap, (char const   *)(cname), & exact, & color___0);
    }
#line 34
    if (tmp___1) {
#line 35
      r = (float )exact.red / (float )65535;
#line 36
      g = (float )exact.green / (float )65535;
#line 37
      b = (float )exact.blue / (float )65535;
    } else {
#line 40
      b = (float )1.0;
#line 40
      g = b;
#line 40
      r = g;
#line 41
      rc = 0;
    }
  } else {
    {
#line 45
    g = (float )999.9;
#line 45
    b = g;
#line 45
    r = b;
#line 46
    sscanf((char const   */* __restrict  */)(cname), (char const   */* __restrict  */)"%f %f %f",
           & r, & g, & b);
    }
#line 47
    if ((double )r > 999.0) {
#line 47
      r = (float )0.0;
    }
#line 48
    if ((double )g > 999.0) {
#line 48
      g = r;
    }
#line 49
    if ((double )b > 999.0) {
#line 49
      b = r;
    }
  }
#line 52
  if (reverse) {
#line 52
    r = (float )(1.0 - (double )r);
#line 52
    g = (float )(1.0 - (double )g);
#line 52
    b = (float )(1.0 - (double )b);
  }
#line 53
  *rval = r;
#line 54
  *gval = g;
#line 55
  *bval = b;
#line 56
  *gray = (float )((double )((r + g) + b) / 3.0);
#line 59
  return (rc);
}
}
#line 64 "/home/june/repo/benchmarks/collector2/temp/xbs-0/grsubs.h"
int GetColorGC(unsigned long gpixel ) 
{ 
  int j ;
  int j0___0 ;
  int icol ;

  {
#line 69
  j0___0 = -1;
#line 70
  j = 0;
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    if (! (j < ncol)) {
#line 70
      goto while_break;
    }
#line 70
    if (gpx[j] == gpixel) {
#line 70
      j0___0 = j;
    }
#line 70
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  if (j0___0 >= 0) {
#line 74
    return (j0___0);
  }
#line 77
  if (ncol >= 31) {
    {
#line 78
    sprintf((char */* __restrict  */)(emsg), (char const   */* __restrict  */)"no more room for colors.. increase dimension NCOL");
    }
#line 79
    return (0);
  }
#line 83
  icol = ncol;
#line 84
  j = 0;
  {
#line 84
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 84
    if (! (j < ncol)) {
#line 84
      goto while_break___0;
    }
#line 85
    if (gpx[j] == 0xffffffffffffffffUL) {
#line 85
      icol = j;
    }
#line 84
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 92
  if (icol == ncol) {
#line 92
    ncol ++;
  }
  {
#line 93
  graygc[icol] = XCreateGC(dpy, win, 0UL, (XGCValues *)0);
#line 94
  XSetForeground(dpy, graygc[icol], gpixel);
#line 95
  gpx[icol] = gpixel;
  }
#line 96
  return (icol);
}
}
#line 101 "/home/june/repo/benchmarks/collector2/temp/xbs-0/grsubs.h"
int FreeColorGC(int icol ) 
{ 
  int i ;
  int num ;

  {
#line 106
  num = 0;
#line 107
  i = 0;
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    if (! (i < nspec)) {
#line 107
      goto while_break;
    }
#line 108
    if (spec[i].col == icol) {
#line 108
      num ++;
    }
#line 107
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 109
  i = 0;
  {
#line 109
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 109
    if (! (i < nbonds)) {
#line 109
      goto while_break___0;
    }
#line 110
    if (bonds[i].col == icol) {
#line 110
      num ++;
    }
#line 109
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 112
  if (num == 0) {
    {
#line 113
    XFreeGC(dpy, graygc[icol]);
#line 114
    gpx[icol] = 0xffffffffffffffffUL;
    }
  }
#line 117
  return (0);
}
}
#line 120 "/home/june/repo/benchmarks/collector2/temp/xbs-0/grsubs.h"
void SetColors(void) 
{ 
  int i ;
  int colptr ;
  unsigned long gpixel ;
  unsigned long bground___0 ;
  XColor color___0 ;
  XColor col1 ;
  int tmp ;

  {
#line 127
  bground___0 = (((_XPrivDisplay )dpy)->screens + screen)->white_pixel;
#line 129
  ncol = 0;
#line 130
  i = 0;
  {
#line 130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 130
    if (! (i < nspec + nbonds)) {
#line 130
      goto while_break;
    }
#line 131
    if (i < nspec) {
#line 132
      col1.red = (unsigned short )(spec[i].r * (float )65535);
#line 133
      col1.green = (unsigned short )(spec[i].g * (float )65535);
#line 134
      col1.blue = (unsigned short )(spec[i].b * (float )65535);
    } else {
#line 137
      col1.red = (unsigned short )(bonds[i - nspec].r * (float )65535);
#line 138
      col1.green = (unsigned short )(bonds[i - nspec].g * (float )65535);
#line 139
      col1.blue = (unsigned short )(bonds[i - nspec].b * (float )65535);
    }
    {
#line 142
    color___0 = col1;
#line 143
    tmp = XAllocColor(dpy, cmap, & color___0);
    }
#line 143
    if (tmp) {
#line 144
      gpixel = color___0.pixel;
    } else {
      {
#line 147
      printf((char const   */* __restrict  */)"Cannot allocate %6d %6d %6d, use background instead\n",
             (int )col1.red, (int )col1.blue, (int )col1.green);
#line 149
      gpixel = bground___0;
      }
    }
    {
#line 152
    colptr = GetColorGC(gpixel);
    }
#line 153
    if (i < nspec) {
#line 154
      spec[i].col = colptr;
    } else {
#line 156
      bonds[i - nspec].col = colptr;
    }
#line 130
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 158
  return;
}
}
#line 185
int match(char *str , char *pat ) ;
#line 162 "/home/june/repo/benchmarks/collector2/temp/xbs-0/grsubs.h"
int NewSpecColor(char *pat , char *cname , int helpme ) 
{ 
  int i ;
  int icol ;
  int nmatch ;
  unsigned long gpixel ;
  float f ;
  char list[151] ;
  XColor col1 ;
  XColor col2 ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;

  {
#line 172
  if (helpme) {
    {
#line 173
    sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"Usage: color pattern [color]  - query or set color");
    }
#line 174
    return (0);
  }
  {
#line 177
  tmp = strlen((char const   *)pat);
  }
#line 177
  if (tmp == 0UL) {
    {
#line 178
    sprintf((char */* __restrict  */)(emsg), (char const   */* __restrict  */)"color: no pattern specified");
    }
#line 179
    return (0);
  }
  {
#line 182
  nmatch = 0;
#line 183
  strcpy((char */* __restrict  */)(list), (char const   */* __restrict  */)"color");
#line 184
  i = 0;
  }
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    if (! (i < nspec)) {
#line 184
      goto while_break;
    }
    {
#line 185
    tmp___3 = match(spec[i].lab, pat);
    }
#line 185
    if (tmp___3) {
      {
#line 186
      nmatch ++;
#line 187
      strcat((char */* __restrict  */)(list), (char const   */* __restrict  */)" ");
#line 188
      strcat((char */* __restrict  */)(list), (char const   */* __restrict  */)(spec[i].lab));
#line 189
      tmp___0 = strlen((char const   *)cname);
      }
#line 189
      if (tmp___0 == 0UL) {
        {
#line 190
        sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"Species %s has color <%s> rgb %.2f %.2f %.2f",
                spec[i].lab, spec[i].cname, (double )spec[i].r, (double )spec[i].g,
                (double )spec[i].b);
        }
#line 192
        return (0);
      }
      {
#line 195
      tmp___1 = parse_color(cname, & spec[i].r, & spec[i].g, & spec[i].b, & spec[i].gray);
      }
#line 195
      if (! tmp___1) {
        {
#line 197
        sprintf((char */* __restrict  */)(emsg), (char const   */* __restrict  */)"Cannot identify color <%s>",
                cname);
        }
#line 198
        return (0);
      }
      {
#line 201
      strcpy((char */* __restrict  */)(spec[i].cname), (char const   */* __restrict  */)cname);
      }
#line 202
      if (color) {
        {
#line 203
        col1.red = (unsigned short )(spec[i].r * (float )65535);
#line 204
        col1.green = (unsigned short )(spec[i].g * (float )65535);
#line 205
        col1.blue = (unsigned short )(spec[i].b * (float )65535);
#line 206
        col2 = col1;
#line 207
        tmp___2 = XAllocColor(dpy, cmap, & col1);
        }
#line 207
        if (tmp___2) {
#line 208
          gpixel = col1.pixel;
        } else {
          {
#line 210
          sprintf((char */* __restrict  */)(emsg), (char const   */* __restrict  */)"Cannot allocate color <%s>",
                  cname);
          }
#line 211
          return (0);
        }
        {
#line 214
        icol = spec[i].col;
#line 215
        spec[i].col = -1;
#line 216
        FreeColorGC(icol);
#line 217
        icol = GetColorGC(gpixel);
#line 218
        spec[i].col = icol;
        }
      }
    }
#line 184
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  if (nmatch == 0) {
    {
#line 223
    tmp___4 = strlen((char const   *)cname);
    }
#line 223
    if (tmp___4 == 0UL) {
      {
#line 224
      sprintf((char */* __restrict  */)(emsg), (char const   */* __restrict  */)"No species matches \'%s\'",
              pat);
      }
#line 225
      return (0);
    }
  }
  {
#line 228
  f = (float )65535;
#line 229
  sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"%s <%s> rgb %.2f %.2f %.2f shown as %.2f %.2f %.2f",
          list, cname, (double )((float )col2.red / f), (double )((float )col2.green / f),
          (double )((float )col2.blue / f), (double )((float )col1.red / f), (double )((float )col1.green / f),
          (double )((float )col1.blue / f));
  }
#line 232
  if (nmatch == 0) {
#line 232
    return (0);
  }
#line 233
  return (1);
}
}
#line 237 "/home/june/repo/benchmarks/collector2/temp/xbs-0/grsubs.h"
void SetSmoothGrays(void) 
{ 
  int i ;
  int allocated[31] ;
  int lastgnum ;
  unsigned long gpixel ;
  XColor color___0 ;
  int g1 ;
  int g2 ;
  int gnum ;
  float dg ;

  {
#line 246
  ngray = 21;
#line 247
  g1 = 65535;
#line 248
  g2 = 0;
#line 249
  dg = (float )((double )(g2 - g1) / ((double )ngray - 1.0));
#line 251
  lastgnum = 0;
#line 252
  i = 0;
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (! (i < ngray)) {
#line 252
      goto while_break;
    }
    {
#line 253
    gnum = (int )((float )g1 + (float )i * dg);
#line 254
    color___0.green = (unsigned short )gnum;
#line 254
    color___0.blue = color___0.green;
#line 254
    color___0.red = color___0.blue;
#line 255
    allocated[i] = XAllocColor(dpy, cmap, & color___0);
    }
#line 256
    if (allocated[i]) {
#line 257
      lastgnum = gnum;
    } else {
      {
#line 260
      printf((char const   */* __restrict  */)"%7d: cannot allocate color.. use %d\n",
             gnum, lastgnum);
#line 261
      color___0.green = (unsigned short )lastgnum;
#line 261
      color___0.blue = color___0.green;
#line 261
      color___0.red = color___0.blue;
#line 262
      XAllocColor(dpy, cmap, & color___0);
      }
    }
    {
#line 264
    graygc[i] = XCreateGC(dpy, win, 0UL, (XGCValues *)0);
#line 265
    gpixel = color___0.pixel;
#line 266
    XSetForeground(dpy, graygc[i], gpixel);
#line 252
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 268
  return;
}
}
#line 279
void SetStippled4x4(void) ;
#line 279 "/home/june/repo/benchmarks/collector2/temp/xbs-0/grsubs.h"
static char t0[4]  = {      (char)0,      (char)0,      (char)0,      (char)0};
#line 280
void SetStippled4x4(void) ;
#line 280 "/home/june/repo/benchmarks/collector2/temp/xbs-0/grsubs.h"
static char t2[4]  = {      (char)1,      (char)0,      (char)4,      (char)0};
#line 281
void SetStippled4x4(void) ;
#line 281 "/home/june/repo/benchmarks/collector2/temp/xbs-0/grsubs.h"
static char t4[4]  = {      (char)1,      (char)4,      (char)1,      (char)4};
#line 282
void SetStippled4x4(void) ;
#line 282 "/home/june/repo/benchmarks/collector2/temp/xbs-0/grsubs.h"
static char t6[4]  = {      (char)5,      (char)2,      (char)5,      (char)8};
#line 283
void SetStippled4x4(void) ;
#line 283 "/home/june/repo/benchmarks/collector2/temp/xbs-0/grsubs.h"
static char t8[4]  = {      (char)5,      (char)10,      (char)5,      (char)10};
#line 284
void SetStippled4x4(void) ;
#line 284 "/home/june/repo/benchmarks/collector2/temp/xbs-0/grsubs.h"
static char t10[4]  = {      (char)-6,      (char)-3,      (char)-6,      (char)-9};
#line 285
void SetStippled4x4(void) ;
#line 285 "/home/june/repo/benchmarks/collector2/temp/xbs-0/grsubs.h"
static char t12[4]  = {      (char)-2,      (char)-5,      (char)-2,      (char)-5};
#line 286
void SetStippled4x4(void) ;
#line 286 "/home/june/repo/benchmarks/collector2/temp/xbs-0/grsubs.h"
static char t14[4]  = {      (char)-2,      (char)-1,      (char)-5,      (char)-1};
#line 271 "/home/june/repo/benchmarks/collector2/temp/xbs-0/grsubs.h"
void SetStippled4x4(void) 
{ 
  int i ;
  int j ;
  int n ;
  int depth___0 ;
  int gnum1 ;
  int gnum2 ;
  unsigned long fg ;
  unsigned long bg___0 ;
  unsigned long lg ;
  unsigned long dg ;
  unsigned long g1 ;
  unsigned long g2 ;
  XColor color1 ;
  XColor color2 ;
  Pixmap tile ;
  int tw ;
  int th ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 278
  tw = 4;
#line 278
  th = 4;
#line 288
  depth___0 = XDefaultDepth(dpy, screen);
#line 289
  fg = (((_XPrivDisplay )dpy)->screens + screen)->black_pixel;
#line 290
  bg___0 = (((_XPrivDisplay )dpy)->screens + screen)->white_pixel;
#line 292
  gnum1 = (int )(0.33 * (double )65535 + 0.67 * (double )0);
#line 293
  color1.green = (unsigned short )gnum1;
#line 293
  color1.blue = color1.green;
#line 293
  color1.red = color1.blue;
#line 294
  tmp = XAllocColor(dpy, cmap, & color1);
  }
#line 294
  if (tmp) {
#line 294
    dg = color1.pixel;
  } else {
    {
#line 295
    printf((char const   */* __restrict  */)"Could not allocate gray value %d\n",
           gnum1);
    }
  }
  {
#line 297
  gnum2 = (int )(0.67 * (double )65535 + 0.33 * (double )0);
#line 298
  color2.green = (unsigned short )gnum2;
#line 298
  color2.blue = color2.green;
#line 298
  color2.red = color2.blue;
#line 299
  tmp___0 = XAllocColor(dpy, cmap, & color2);
  }
#line 299
  if (tmp___0) {
#line 299
    lg = color2.pixel;
  } else {
    {
#line 300
    printf((char const   */* __restrict  */)"Could not allocate gray value %d\n",
           gnum2);
    }
  }
#line 303
  n = 0;
#line 304
  j = 0;
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 304
    if (! (j < 3)) {
#line 304
      goto while_break;
    }
#line 305
    if (j == 2) {
#line 305
      g1 = fg;
#line 305
      g2 = dg;
    }
#line 306
    if (j == 1) {
#line 306
      g1 = dg;
#line 306
      g2 = lg;
    }
#line 307
    if (j == 0) {
#line 307
      g1 = lg;
#line 307
      g2 = bg___0;
    }
#line 308
    i = 0;
    {
#line 308
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 308
      if (! (i < 8)) {
#line 308
        goto while_break___0;
      }
      {
#line 309
      graygc[n] = XCreateGC(dpy, win, 0UL, (XGCValues *)0);
      }
#line 310
      if (i == 0) {
        {
#line 310
        tile = XCreatePixmapFromBitmapData(dpy, win, t0, (unsigned int )tw, (unsigned int )th,
                                           g1, g2, (unsigned int )depth___0);
        }
      }
#line 311
      if (i == 1) {
        {
#line 311
        tile = XCreatePixmapFromBitmapData(dpy, win, t2, (unsigned int )tw, (unsigned int )th,
                                           g1, g2, (unsigned int )depth___0);
        }
      }
#line 312
      if (i == 2) {
        {
#line 312
        tile = XCreatePixmapFromBitmapData(dpy, win, t4, (unsigned int )tw, (unsigned int )th,
                                           g1, g2, (unsigned int )depth___0);
        }
      }
#line 313
      if (i == 3) {
        {
#line 313
        tile = XCreatePixmapFromBitmapData(dpy, win, t6, (unsigned int )tw, (unsigned int )th,
                                           g1, g2, (unsigned int )depth___0);
        }
      }
#line 314
      if (i == 4) {
        {
#line 314
        tile = XCreatePixmapFromBitmapData(dpy, win, t8, (unsigned int )tw, (unsigned int )th,
                                           g1, g2, (unsigned int )depth___0);
        }
      }
#line 315
      if (i == 5) {
        {
#line 315
        tile = XCreatePixmapFromBitmapData(dpy, win, t10, (unsigned int )tw, (unsigned int )th,
                                           g1, g2, (unsigned int )depth___0);
        }
      }
#line 316
      if (i == 6) {
        {
#line 316
        tile = XCreatePixmapFromBitmapData(dpy, win, t12, (unsigned int )tw, (unsigned int )th,
                                           g1, g2, (unsigned int )depth___0);
        }
      }
#line 317
      if (i == 7) {
        {
#line 317
        tile = XCreatePixmapFromBitmapData(dpy, win, t14, (unsigned int )tw, (unsigned int )th,
                                           g1, g2, (unsigned int )depth___0);
        }
      }
      {
#line 318
      XSetTile(dpy, graygc[n], tile);
#line 319
      XSetFillStyle(dpy, graygc[n], 1);
#line 320
      n ++;
#line 308
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 304
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 323
  ngray = n;
#line 324
  return;
}
}
#line 334
void SetStippled4x6(void) ;
#line 334 "/home/june/repo/benchmarks/collector2/temp/xbs-0/grsubs.h"
static char t0___0[6]  = {      (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0};
#line 335
void SetStippled4x6(void) ;
#line 335 "/home/june/repo/benchmarks/collector2/temp/xbs-0/grsubs.h"
static char t6___0[6]  = {      (char)1,      (char)4,      (char)1,      (char)4, 
        (char)1,      (char)4};
#line 336
void SetStippled4x6(void) ;
#line 336 "/home/june/repo/benchmarks/collector2/temp/xbs-0/grsubs.h"
static char t12___0[6]  = {      (char)5,      (char)10,      (char)5,      (char)10, 
        (char)5,      (char)10};
#line 337
void SetStippled4x6(void) ;
#line 337 "/home/june/repo/benchmarks/collector2/temp/xbs-0/grsubs.h"
static char t18[6]  = {      (char)-2,      (char)-5,      (char)-2,      (char)-5, 
        (char)-2,      (char)-5};
#line 338
void SetStippled4x6(void) ;
#line 338 "/home/june/repo/benchmarks/collector2/temp/xbs-0/grsubs.h"
static char t24[6]  = {      (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1};
#line 327 "/home/june/repo/benchmarks/collector2/temp/xbs-0/grsubs.h"
void SetStippled4x6(void) 
{ 
  int i ;
  int depth___0 ;
  unsigned long fg ;
  unsigned long bg___0 ;
  unsigned long gr ;
  XColor color___0 ;
  Pixmap tile ;
  int tw ;
  int th ;
  int tmp ;

  {
  {
#line 333
  tw = 4;
#line 333
  th = 6;
#line 340
  depth___0 = XDefaultDepth(dpy, screen);
#line 341
  fg = (((_XPrivDisplay )dpy)->screens + screen)->black_pixel;
#line 342
  bg___0 = (((_XPrivDisplay )dpy)->screens + screen)->white_pixel;
#line 344
  tmp = XAllocColor(dpy, cmap, & color___0);
  }
#line 344
  if (tmp) {
    {
#line 345
    gr = color___0.pixel;
#line 346
    printf((char const   */* __restrict  */)" gray is %d %d %d\n", (int )color___0.red,
           (int )color___0.blue, (int )color___0.green);
    }
  } else {
    {
#line 348
    printf((char const   */* __restrict  */)"Could not allocate gray value\n");
    }
  }
#line 350
  ngray = 9;
#line 351
  i = 0;
  {
#line 351
  while (1) {
    while_continue: /* CIL Label */ ;
#line 351
    if (! (i < ngray)) {
#line 351
      goto while_break;
    }
    {
#line 352
    graygc[i] = XCreateGC(dpy, win, 0UL, (XGCValues *)0);
    }
#line 354
    if (i == 8) {
      {
#line 355
      tile = XCreatePixmapFromBitmapData(dpy, win, t0___0, (unsigned int )tw, (unsigned int )th,
                                         gr, bg___0, (unsigned int )depth___0);
#line 356
      XSetTile(dpy, graygc[i], tile);
      }
    }
#line 358
    if (i == 7) {
      {
#line 359
      tile = XCreatePixmapFromBitmapData(dpy, win, t6___0, (unsigned int )tw, (unsigned int )th,
                                         gr, bg___0, (unsigned int )depth___0);
#line 360
      XSetTile(dpy, graygc[i], tile);
      }
    }
#line 362
    if (i == 6) {
      {
#line 363
      tile = XCreatePixmapFromBitmapData(dpy, win, t12___0, (unsigned int )tw, (unsigned int )th,
                                         gr, bg___0, (unsigned int )depth___0);
#line 364
      XSetTile(dpy, graygc[i], tile);
      }
    }
#line 366
    if (i == 5) {
      {
#line 367
      tile = XCreatePixmapFromBitmapData(dpy, win, t18, (unsigned int )tw, (unsigned int )th,
                                         gr, bg___0, (unsigned int )depth___0);
#line 368
      XSetTile(dpy, graygc[i], tile);
      }
    }
#line 371
    if (i == 4) {
      {
#line 372
      tile = XCreatePixmapFromBitmapData(dpy, win, t0___0, (unsigned int )tw, (unsigned int )th,
                                         fg, gr, (unsigned int )depth___0);
#line 373
      XSetTile(dpy, graygc[i], tile);
      }
    }
#line 375
    if (i == 3) {
      {
#line 376
      tile = XCreatePixmapFromBitmapData(dpy, win, t6___0, (unsigned int )tw, (unsigned int )th,
                                         fg, gr, (unsigned int )depth___0);
#line 377
      XSetTile(dpy, graygc[i], tile);
      }
    }
#line 379
    if (i == 2) {
      {
#line 380
      tile = XCreatePixmapFromBitmapData(dpy, win, t12___0, (unsigned int )tw, (unsigned int )th,
                                         fg, gr, (unsigned int )depth___0);
#line 381
      XSetTile(dpy, graygc[i], tile);
      }
    }
#line 383
    if (i == 1) {
      {
#line 384
      tile = XCreatePixmapFromBitmapData(dpy, win, t18, (unsigned int )tw, (unsigned int )th,
                                         fg, gr, (unsigned int )depth___0);
#line 385
      XSetTile(dpy, graygc[i], tile);
      }
    }
#line 387
    if (i == 0) {
      {
#line 388
      tile = XCreatePixmapFromBitmapData(dpy, win, t24, (unsigned int )tw, (unsigned int )th,
                                         fg, gr, (unsigned int )depth___0);
#line 389
      XSetTile(dpy, graygc[i], tile);
      }
    }
    {
#line 392
    XSetFillStyle(dpy, graygc[i], 1);
#line 351
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 394
  return;
}
}
#line 397 "/home/june/repo/benchmarks/collector2/temp/xbs-0/grsubs.h"
GC ChooseColor(float gray , int col0 ) 
{ 
  int igray ;

  {
#line 403
  if (! grayvalues) {
#line 403
    return (gcbg);
  }
#line 404
  if (color) {
#line 405
    return (graygc[col0]);
  } else {
#line 408
    igray = (int )((1.0 - (double )gray) * (double )ngray - 0.49);
#line 409
    if (igray > ngray - 1) {
#line 409
      igray = ngray - 1;
    }
#line 410
    if (igray < 0) {
#line 410
      igray = 0;
    }
#line 411
    return (graygc[igray]);
  }
}
}
#line 416 "/home/june/repo/benchmarks/collector2/temp/xbs-0/grsubs.h"
void showline(Drawable drawable , int x , int y , char *s1 , char *s2 , char *s3 ) 
{ 
  char sx[1001] ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 422
  strcpy((char */* __restrict  */)(sx), (char const   */* __restrict  */)s1);
#line 423
  strcat((char */* __restrict  */)(sx), (char const   */* __restrict  */)s2);
#line 424
  strcat((char */* __restrict  */)(sx), (char const   */* __restrict  */)s3);
#line 425
  tmp = strlen((char const   *)(sx));
#line 425
  XFillRectangle(dpy, drawable, gcbg, x, (igh - y) - 9, (unsigned int )((size_t )x + 6UL * tmp),
                 12U);
#line 426
  tmp___0 = strlen((char const   *)(sx));
#line 426
  XDrawString(dpy, drawable, labelgc, x, igh - y, (char const   *)(sx), (int )tmp___0);
  }
#line 428
  return;
}
}
#line 431 "/home/june/repo/benchmarks/collector2/temp/xbs-0/grsubs.h"
void clearline(Drawable drawable , int x , int y ) 
{ 


  {
  {
#line 435
  XFillRectangle(dpy, drawable, gcbg, x, (igh - y) - 11, (unsigned int )((igw - x) - 20),
                 14U);
  }
#line 436
  return;
}
}
#line 439 "/home/june/repo/benchmarks/collector2/temp/xbs-0/grsubs.h"
void DrawArrow(float x0 , float y0___0 , float x1 , float y1___0 , float rad , char *str ) 
{ 
  int xx1 ;
  int yy1 ;
  int xx0 ;
  int yy0 ;
  int xx ;
  int yy ;
  int dd ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 445
  xx1 = (int )((double )midx + 1.42 * (double )x1);
#line 446
  yy1 = (int )((double )midy - 1.42 * (double )y1___0);
#line 447
  xx0 = (int )((double )midx + 1.42 * (double )x0);
#line 448
  yy0 = (int )((double )midy - 1.42 * (double )y0___0);
#line 449
  xx = (int )(0.9 * (double )xx0 + 0.1 * (double )xx1);
#line 450
  yy = (int )(0.9 * (double )yy0 + 0.1 * (double )yy1);
#line 451
  XDrawLine(dpy, drw, shadowgc, xx, yy, xx1, yy1);
#line 452
  XDrawLine(dpy, drw, gc, xx0, yy0, xx1, yy1);
#line 454
  xx = (int )((double )xx1 + 0.3 * (double )(xx1 - xx0));
#line 455
  yy = (int )(((double )yy1 + 0.3 * (double )(yy1 - yy0)) + (double )4);
#line 456
  tmp = strlen((char const   *)str);
#line 456
  dd = (int )(tmp * 6UL);
#line 457
  XDrawLine(dpy, drw, labbggc, (xx + 2) - dd / 2, yy - 4, (xx + dd / 2) - 2, yy - 4);
#line 458
  tmp___0 = strlen((char const   *)str);
#line 458
  XDrawString(dpy, drw, labelgc, xx - dd / 2, yy, (char const   *)str, (int )tmp___0);
  }
#line 460
  return;
}
}
#line 464 "/home/june/repo/benchmarks/collector2/temp/xbs-0/grsubs.h"
void DrawLine(float x0 , float y0___0 , float x1 , float y1___0 , GC thegc ) 
{ 
  int xx1 ;
  int yy1 ;
  int xx0 ;
  int yy0 ;

  {
  {
#line 470
  xx1 = (int )((double )midx + 1.42 * (double )x1);
#line 471
  yy1 = (int )((double )midy - 1.42 * (double )y1___0);
#line 472
  xx0 = (int )((double )midx + 1.42 * (double )x0);
#line 473
  yy0 = (int )((double )midy - 1.42 * (double )y0___0);
#line 474
  XDrawLine(dpy, drw, thegc, xx0, yy0, xx1, yy1);
  }
#line 476
  return;
}
}
#line 480 "/home/june/repo/benchmarks/collector2/temp/xbs-0/grsubs.h"
void DrawBall(float gray , int col0 , float x , float y , float rad ) 
{ 
  int xx ;
  int yy ;
  int rr ;
  GC gcfill ;

  {
#line 487
  rr = (int )(1.42 * (double )rad);
#line 488
  xx = (int )((double )midx + 1.42 * (double )x);
#line 489
  yy = (int )((double )midy - 1.42 * (double )y);
#line 490
  if (shadow) {
    {
#line 491
    XDrawArc(dpy, drw, shadowgc, xx - rr, yy - rr, (unsigned int )(2 * rr), (unsigned int )(2 * rr),
             0, 23040);
    }
  }
#line 492
  if (! wire) {
    {
#line 493
    gcfill = ChooseColor(gray, col0);
#line 494
    XFillArc(dpy, drw, gcfill, xx - rr, yy - rr, (unsigned int )(2 * rr), (unsigned int )(2 * rr),
             0, 23040);
    }
  }
  {
#line 496
  XDrawArc(dpy, drw, gc, xx - rr, yy - rr, (unsigned int )(2 * rr), (unsigned int )(2 * rr),
           0, 23040);
  }
#line 497
  return;
}
}
#line 500 "/home/june/repo/benchmarks/collector2/temp/xbs-0/grsubs.h"
void DrawStick(float gray , int col0 , float *m1 , float *m2 ) 
{ 
  int x1 ;
  int y1___0 ;
  int x2 ;
  int y2 ;
  int i ;
  float x ;
  float y ;
  XPoint pp[11] ;
  GC gcfill ;

  {
#line 509
  if (bline) {
#line 510
    x1 = (int )((double )midx + 1.42 * (double )*(m1 + 4));
#line 511
    y1___0 = (int )((double )midy - 1.42 * (double )*(m1 + 5));
#line 512
    x2 = (int )((double )midx + 1.42 * (double )*(m2 + 4));
#line 513
    y2 = (int )((double )midy - 1.42 * (double )*(m2 + 5));
#line 514
    if (shadow) {
      {
#line 515
      XDrawLine(dpy, drw, shadowgc, x1, y1___0, x2, y2);
      }
    }
    {
#line 516
    XDrawLine(dpy, drw, gc, x1, y1___0, x2, y2);
    }
#line 517
    return;
  }
#line 520
  i = 0;
  {
#line 520
  while (1) {
    while_continue: /* CIL Label */ ;
#line 520
    if (! (i < 5)) {
#line 520
      goto while_break;
    }
#line 521
    x = (*(m1 + 0) * arc[i][0] + *(m1 + 2) * arc[i][1]) + *(m1 + 4);
#line 522
    y = (*(m1 + 1) * arc[i][0] + *(m1 + 3) * arc[i][1]) + *(m1 + 5);
#line 523
    pp[i].x = (short )((double )midx + 1.42 * (double )x);
#line 524
    pp[i].y = (short )((double )midy - 1.42 * (double )y);
#line 520
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 526
  i = 0;
  {
#line 526
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 526
    if (! (i < 5)) {
#line 526
      goto while_break___0;
    }
#line 527
    x = (- *(m2 + 0) * arc[i][0] + *(m2 + 2) * arc[i][1]) + *(m2 + 4);
#line 528
    y = (- *(m2 + 1) * arc[i][0] + *(m2 + 3) * arc[i][1]) + *(m2 + 5);
#line 529
    pp[(10 - i) - 1].x = (short )((double )midx + 1.42 * (double )x);
#line 530
    pp[(10 - i) - 1].y = (short )((double )midy - 1.42 * (double )y);
#line 526
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 532
  pp[10] = pp[0];
#line 534
  if (shadow) {
    {
#line 535
    XDrawLines(dpy, drw, shadowgc, & pp[0], 11, 0);
    }
  }
#line 536
  if (! wire) {
    {
#line 537
    gcfill = ChooseColor(gray, col0);
#line 538
    XFillPolygon(dpy, drw, gcfill, & pp[0], 11, 1, 0);
    }
  }
  {
#line 541
  XDrawLines(dpy, drw, gc, & pp[0], 11, 0);
  }
#line 543
  return;
}
}
#line 546 "/home/june/repo/benchmarks/collector2/temp/xbs-0/grsubs.h"
void LabelBG(float x , float y , float g1 , float g2 , char *str ) 
{ 
  int xx ;
  int yy ;
  int dd ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 552
  xx = (int )((double )midx + 1.42 * (double )x);
#line 553
  yy = (int )((double )midy - 1.42 * (double )y);
#line 556
  tmp = strlen((char const   *)str);
#line 556
  dd = (int )(tmp * 6UL);
#line 558
  XDrawLine(dpy, drw, labbggc, (xx + 2) - dd / 2, yy - 4, (xx + dd / 2) - 2, yy - 4);
#line 561
  tmp___0 = strlen((char const   *)str);
#line 561
  XDrawString(dpy, drw, labelgc, xx - dd / 2, yy, (char const   *)str, (int )tmp___0);
  }
#line 563
  return;
}
}
#line 2 "/home/june/repo/benchmarks/collector2/temp/xbs-0/hardcopy.h"
void HCballFull(void) 
{ 


  {
#line 4
  if (color) {
    {
#line 5
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"/BALL  { 0 360 arc    gsave setrgbcolor fill grestore stroke } bind def\n");
    }
  } else {
    {
#line 9
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"/BALL  { 0 360 arc    gsave setgray fill grestore stroke } bind def\n");
    }
  }
#line 12
  return;
}
}
#line 14 "/home/june/repo/benchmarks/collector2/temp/xbs-0/hardcopy.h"
void HCballWire(void) 
{ 


  {
  {
#line 16
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"/BALL  { 0 360 arc pop stroke } bind def\n");
  }
#line 18
  return;
}
}
#line 20 "/home/june/repo/benchmarks/collector2/temp/xbs-0/hardcopy.h"
void HCballShadow(float gray , float wid ) 
{ 


  {
  {
#line 22
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"/BALL  { 0 360 arc\n    gsave %.2f setgray %.2f setlinewidth stroke grestore\n   gsave setgray fill grestore\n   stroke } bind def\n",
          (double )gray, (double )wid);
  }
#line 27
  return;
}
}
#line 29 "/home/june/repo/benchmarks/collector2/temp/xbs-0/hardcopy.h"
void HCstickFull(void) 
{ 


  {
  {
#line 31
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"/STICK { CP gsave setgray fill grestore stroke } bind def\n");
  }
#line 33
  return;
}
}
#line 35 "/home/june/repo/benchmarks/collector2/temp/xbs-0/hardcopy.h"
void HCstickShadow(float gray , float wid ) 
{ 


  {
  {
#line 37
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"/STICK { CP\ngsave %.2f setgray %.2f setlinewidth stroke grestore\ngsave setgray fill grestore\nstroke } bind def\n",
          (double )gray, (double )wid);
  }
#line 42
  return;
}
}
#line 44 "/home/june/repo/benchmarks/collector2/temp/xbs-0/hardcopy.h"
void HCstickWire(void) 
{ 


  {
  {
#line 46
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"/STICK { CPW pop stroke } bind def\n");
  }
#line 48
  return;
}
}
#line 50 "/home/june/repo/benchmarks/collector2/temp/xbs-0/hardcopy.h"
void HCstickLine(void) 
{ 


  {
  {
#line 52
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"/STICK { CP0 gsave setgray stroke grestore newpath} bind def\n");
  }
#line 55
  return;
}
}
#line 57 "/home/june/repo/benchmarks/collector2/temp/xbs-0/hardcopy.h"
void HCstickLineShadow(float gray , float wid ) 
{ 


  {
  {
#line 59
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"/STICK { CP0 \ngsave %.2f setgray %.2f setlinewidth stroke grestore\ngsave setgray stroke grestore \nnewpath} bind def\n",
          (double )gray, (double )wid);
  }
#line 64
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector2/temp/xbs-0/hardcopy.h"
void HCdbond(void) 
{ 


  {
  {
#line 68
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"/XDB { } bind def\n");
  }
#line 69
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector2/temp/xbs-0/hardcopy.h"
void HCdbondShadow(float gray , float wid ) 
{ 


  {
  {
#line 73
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"/XDB { gsave %.2f setgray %.2f setlinewidth\nstroke grestore } bind def\n",
          (double )gray, (double )wid);
  }
#line 76
  return;
}
}
#line 79 "/home/june/repo/benchmarks/collector2/temp/xbs-0/hardcopy.h"
void hardcopy_init(char *outname ) 
{ 


  {
  {
#line 81
  outfp = fopen((char const   */* __restrict  */)outname, (char const   */* __restrict  */)"w");
  }
#line 81
  if ((unsigned long )outfp == (unsigned long )((void *)0)) {
    {
#line 82
    printf((char const   */* __restrict  */)"Cannot open output file\n");
#line 82
    exit(1);
    }
  }
  {
#line 84
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%%!PS-Adobe-3.0\n%%%%Creator: bs\n%%%%Pages: 1\n%%%%EndComments\n%%%%BeginPageSetup\n%%%%Page: 1 1\n 15 15 translate\n%%%%PageOrientation: Landscape\n 90 rotate 0 -580 translate\n/CP { %% Full cylinder path. Args: [CM1] [CM2]\n  exch matrix currentmatrix exch concat 0 0 1 90 270 arc\n  setmatrix matrix currentmatrix exch concat 0 0 1 -90 90 arc\n  closepath setmatrix } bind def\n/CP0 {\n  exch matrix currentmatrix exch concat 0 0 moveto\n  setmatrix matrix currentmatrix exch concat\n  0 0 lineto setmatrix } bind def\n/CPW {\nexch matrix currentmatrix exch concat 0 0 1 90 630 arc\nsetmatrix matrix currentmatrix exch concat\n0 0 1 -90 450 arc closepath setmatrix } bind def\n/LAB { gsave 3 copy /Courier 9 selectfont\n1 setgray 10 setlinewidth 1 setlinecap 3 add exch 2 add exch\nmoveto stringwidth exch 4 sub exch rlineto stroke\n0 setgray moveto show grestore} bind def\n");
#line 111
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"/LNE { moveto lineto stroke } bind def \n/DSH { gsave [2 5] 0 setdash moveto lineto stroke grestore} bind def\n");
  }
#line 120
  if (wire) {
    {
#line 121
    HCballWire();
#line 122
    HCstickWire();
    }
  } else
#line 125
  if (shadow) {
    {
#line 126
    HCballShadow((float )1.0, (float )4.0);
    }
#line 127
    if (bline) {
      {
#line 127
      HCstickLineShadow((float )1.0, (float )4.0);
      }
    } else {
      {
#line 128
      HCstickShadow((float )1.0, (float )4.0);
      }
    }
  } else {
    {
#line 131
    HCballFull();
    }
#line 132
    if (bline) {
      {
#line 132
      HCstickLine();
      }
    } else {
      {
#line 133
      HCstickFull();
      }
    }
  }
#line 136
  if (shadow) {
    {
#line 136
    HCdbondShadow((float )1.0, (float )4.0);
    }
  } else {
    {
#line 137
    HCdbond();
    }
  }
  {
#line 138
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%%%%EndPageSetup\n");
  }
#line 139
  return;
}
}
#line 143 "/home/june/repo/benchmarks/collector2/temp/xbs-0/hardcopy.h"
void hardcopy_redefine(void) 
{ 


  {
#line 145
  if (wire) {
    {
#line 146
    HCballWire();
#line 147
    HCstickWire();
    }
  } else
#line 150
  if (shadow) {
    {
#line 151
    HCballShadow((float )1.0, (float )4.0);
    }
#line 152
    if (bline) {
      {
#line 152
      HCstickLineShadow((float )1.0, (float )4.0);
      }
    } else {
      {
#line 153
      HCstickShadow((float )1.0, (float )4.0);
      }
    }
  } else {
    {
#line 156
    HCballFull();
    }
#line 157
    if (bline) {
      {
#line 157
      HCstickLine();
      }
    } else {
      {
#line 158
      HCstickFull();
      }
    }
  }
#line 161
  if (shadow) {
    {
#line 161
    HCdbondShadow((float )1.0, (float )4.0);
    }
  } else {
    {
#line 162
    HCdbond();
    }
  }
#line 163
  return;
}
}
#line 166 "/home/june/repo/benchmarks/collector2/temp/xbs-0/hardcopy.h"
void hardcopy_ball(float gray , float r , float g , float b , float x , float y ,
                   float rad ) 
{ 


  {
#line 168
  if (color) {
    {
#line 169
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%.2f %.2f %.2f %8.1f%8.1f%8.1f  BALL\n",
            (double )r, (double )g, (double )b, (double )x + (double )midx / 1.42,
            (double )(y + (float )600) - (double )midy / 1.42, (double )rad);
    }
  } else {
    {
#line 172
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%6.2f%8.1f%8.1f%8.1f  BALL\n",
            (double )gray, (double )x + (double )midx / 1.42, (double )(y + (float )600) - (double )midy / 1.42,
            (double )rad);
    }
  }
#line 174
  return;
}
}
#line 177 "/home/june/repo/benchmarks/collector2/temp/xbs-0/hardcopy.h"
void hardcopy_label(float x , float y , char *str ) 
{ 
  int sh ;
  size_t tmp ;

  {
  {
#line 180
  tmp = strlen((char const   *)str);
#line 180
  sh = (int )(2.2 * (double )tmp);
#line 181
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"(%s) %7.2f %7.2f LAB\n",
          str, ((double )x + (double )midx / 1.42) - (double )sh, ((double )(y + (float )600) - (double )midy / 1.42) - (double )2);
  }
#line 183
  return;
}
}
#line 185 "/home/june/repo/benchmarks/collector2/temp/xbs-0/hardcopy.h"
void hardcopy_stick(float gray , float *m1 , float *m2 ) 
{ 


  {
  {
#line 187
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%6.2f [%7.1f%7.1f%7.1f%7.1f%7.1f%7.1f ]\n",
          (double )gray, (double )*(m1 + 0), (double )*(m1 + 1), (double )*(m1 + 2),
          (double )*(m1 + 3), (double )*(m1 + 4) + (double )midx / 1.42, (double )(*(m1 + 5) + (float )600) - (double )midy / 1.42);
#line 192
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"       [%7.1f%7.1f%7.1f%7.1f%7.1f%7.1f ]  STICK\n",
          (double )*(m2 + 0), (double )*(m2 + 1), (double )*(m2 + 2), (double )*(m2 + 3),
          (double )*(m2 + 4) + (double )midx / 1.42, (double )(*(m2 + 5) + (float )600) - (double )midy / 1.42);
  }
#line 196
  return;
}
}
#line 200 "/home/june/repo/benchmarks/collector2/temp/xbs-0/hardcopy.h"
void hardcopy_line(float x1 , float y1___0 , float x2 , float y2 , int dash ) 
{ 


  {
#line 205
  if (dash) {
    {
#line 206
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%7.1f %7.1f %7.1f %7.1f DSH\n",
            (double )x1 + (double )midx / 1.42, (double )(y1___0 + (float )600) - (double )midy / 1.42,
            (double )x2 + (double )midx / 1.42, (double )(y2 + (float )600) - (double )midy / 1.42);
    }
  } else {
    {
#line 210
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%7.1f %7.1f %7.1f %7.1f LNE\n",
            (double )x1 + (double )midx / 1.42, (double )(y1___0 + (float )600) - (double )midy / 1.42,
            (double )x2 + (double )midx / 1.42, (double )(y2 + (float )600) - (double )midy / 1.42);
    }
  }
#line 215
  return;
}
}
#line 219 "/home/june/repo/benchmarks/collector2/temp/xbs-0/hardcopy.h"
void hardcopy_close(void) 
{ 


  {
  {
#line 221
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"showpage\n%%%%EOF\n");
#line 224
  fclose(outfp);
  }
#line 225
  return;
}
}
#line 227 "/home/june/repo/benchmarks/collector2/temp/xbs-0/hardcopy.h"
void hardcopy_xdbond(float gray , float *m1 , float *m2 , float alf ) 
{ 


  {
  {
#line 229
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)" matrix currentmatrix");
#line 230
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)" [%7.1f%7.1f%7.1f%7.1f%7.1f%7.1f ] concat\n",
          (double )*(m1 + 0), (double )*(m1 + 1), (double )*(m1 + 2), (double )*(m1 + 3),
          (double )*(m1 + 4), (double )*(m1 + 5));
#line 232
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)" 0 0 1 %7.2f %7.2f arc setmatrix\n",
          (double )((float )90 + alf), (double )((float )270 - alf));
#line 234
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)" matrix currentmatrix");
#line 235
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)" [%7.1f%7.1f%7.1f%7.1f%7.1f%7.1f ] concat\n",
          (double )*(m2 + 0), (double )*(m2 + 1), (double )*(m2 + 2), (double )*(m2 + 3),
          (double )*(m2 + 4), (double )*(m2 + 5));
#line 237
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)" 0 0 1 %7.2f %7.2f arc closepath setmatrix XDB \n",
          (double )((float )-90 - alf), (double )((float )90 + alf));
#line 239
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)" gsave %6.2f setgray fill grestore stroke\n",
          (double )gray);
  }
#line 241
  return;
}
}
#line 243 "/home/june/repo/benchmarks/collector2/temp/xbs-0/hardcopy.h"
void hardcopy_ydbond(float gray , float *m1 , float *m2 , float alf ) 
{ 


  {
  {
#line 245
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)" matrix currentmatrix");
#line 246
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)" [%7.1f%7.1f%7.1f%7.1f%7.1f%7.1f ] concat\n",
          (double )*(m2 + 0), (double )*(m2 + 1), (double )*(m2 + 2), (double )*(m2 + 3),
          (double )*(m2 + 4), (double )*(m2 + 5));
#line 248
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)" 0 0 1 0 360 arc setmatrix XDB\n");
#line 249
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)" gsave %6.2f setgray fill grestore stroke\n",
          (double )gray);
  }
#line 251
  return;
}
}
#line 5 "/home/june/repo/benchmarks/collector2/temp/xbs-0/subs.h"
void rx(char *msg ) 
{ 


  {
  {
#line 7
  printf((char const   */* __restrict  */)"Error: %s\n", msg);
#line 8
  exit(1);
  }
}
}
#line 11 "/home/june/repo/benchmarks/collector2/temp/xbs-0/subs.h"
void cross(float *a , float *b , float *c ) 
{ 


  {
#line 13
  *(c + 0) = *(a + 1) * *(b + 2) - *(a + 2) * *(b + 1);
#line 14
  *(c + 1) = *(a + 2) * *(b + 0) - *(a + 0) * *(b + 2);
#line 15
  *(c + 2) = *(a + 0) * *(b + 1) - *(a + 1) * *(b + 0);
#line 16
  return;
}
}
#line 19 "/home/june/repo/benchmarks/collector2/temp/xbs-0/subs.h"
float sp(float *a , float *b ) 
{ 
  float sp1 ;

  {
#line 22
  sp1 = (*(a + 0) * *(b + 0) + *(a + 1) * *(b + 1)) + *(a + 2) * *(b + 2);
#line 23
  return (sp1);
}
}
#line 26 "/home/june/repo/benchmarks/collector2/temp/xbs-0/subs.h"
void vscal(float *a , float ca , float *v ) 
{ 


  {
#line 28
  *(v + 0) = *(a + 0) * ca;
#line 29
  *(v + 1) = *(a + 1) * ca;
#line 30
  *(v + 2) = *(a + 2) * ca;
#line 31
  return;
}
}
#line 34 "/home/june/repo/benchmarks/collector2/temp/xbs-0/subs.h"
void vsum(float *a , float *b , float ca , float cb , float *v ) 
{ 


  {
#line 36
  *(v + 0) = ca * *(a + 0) + cb * *(b + 0);
#line 37
  *(v + 1) = ca * *(a + 1) + cb * *(b + 1);
#line 38
  *(v + 2) = ca * *(a + 2) + cb * *(b + 2);
#line 39
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector2/temp/xbs-0/subs.h"
int parse_args(char *str , char (*w)[41] ) 
{ 
  int i ;
  int num ;
  int reading ;
  int quoted ;
  char *p___0 ;

  {
#line 49
  p___0 = str;
#line 50
  quoted = 0;
#line 50
  reading = quoted;
#line 51
  num = -1;
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    if (! ((int )*p___0 != 0)) {
#line 52
      goto while_break;
    }
#line 53
    if (reading) {
#line 54
      if (quoted) {
#line 54
        if ((int )*p___0 == 39) {
#line 55
          i ++;
#line 55
          (*(w + num))[i] = (char)0;
#line 55
          reading = 0;
        } else {
#line 54
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 54
      if (! quoted) {
#line 54
        if ((int )*p___0 == 32) {
#line 55
          i ++;
#line 55
          (*(w + num))[i] = (char)0;
#line 55
          reading = 0;
        } else {
#line 56
          i ++;
#line 56
          (*(w + num))[i] = *p___0;
        }
      } else {
#line 56
        i ++;
#line 56
        (*(w + num))[i] = *p___0;
      }
    } else
#line 59
    if ((int )*p___0 != 32) {
#line 60
      num ++;
#line 61
      if ((int )*p___0 == 39) {
#line 61
        quoted = 1;
#line 61
        i = -1;
      } else {
#line 62
        i = 0;
#line 62
        (*(w + num))[i] = *p___0;
      }
#line 63
      reading = 1;
    }
#line 66
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 68
  if (reading) {
#line 68
    i ++;
#line 68
    (*(w + num))[i] = (char)0;
  }
#line 69
  num ++;
#line 70
  return (num);
}
}
#line 73 "/home/june/repo/benchmarks/collector2/temp/xbs-0/subs.h"
void strip(char *str1 , char *str ) 
{ 
  int l ;
  int i ;
  int i1 ;
  int i2 ;
  size_t tmp ;

  {
  {
#line 77
  tmp = strlen((char const   *)str);
#line 77
  l = (int )tmp;
#line 79
  i1 = 0;
#line 80
  i = 0;
  }
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    if (! (i < l)) {
#line 80
      goto while_break;
    }
#line 81
    if ((int )*(str + i) != 32) {
#line 81
      if ((int )*(str + i) != 10) {
#line 81
        i1 = i;
#line 81
        goto while_break;
      }
    }
#line 80
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  i2 = 0;
#line 83
  i = l - 1;
  {
#line 83
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 83
    if (! (i >= 0)) {
#line 83
      goto while_break___0;
    }
#line 84
    if ((int )*(str + i) != 32) {
#line 84
      if ((int )*(str + i) != 10) {
#line 84
        i2 = i + 1;
#line 84
        goto while_break___0;
      }
    }
#line 83
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 85
  i = i1;
  {
#line 85
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 85
    if (! (i < i2)) {
#line 85
      goto while_break___1;
    }
#line 85
    *(str1 + (i - i1)) = *(str + i);
#line 85
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 86
  *(str1 + (i2 - i1)) = (char)0;
#line 88
  return;
}
}
#line 90 "/home/june/repo/benchmarks/collector2/temp/xbs-0/subs.h"
int abbrev(char *str , char *ab , int nchar ) 
{ 
  int i ;
  int nc ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 95
  tmp = strlen((char const   *)str);
#line 95
  tmp___0 = strlen((char const   *)ab);
  }
#line 95
  if (tmp > tmp___0) {
#line 95
    return (0);
  }
  {
#line 96
  tmp___1 = strlen((char const   *)str);
#line 96
  nc = (int )tmp___1;
  }
#line 97
  if (nc < nchar) {
#line 97
    nc = nchar;
  }
#line 98
  i = 0;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (i < nc)) {
#line 98
      goto while_break;
    }
#line 98
    if ((int )*(str + i) != (int )*(ab + i)) {
#line 98
      return (0);
    }
#line 98
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  return (1);
}
}
#line 105 "/home/june/repo/benchmarks/collector2/temp/xbs-0/subs.h"
void strext(char *fid1 , char *fid , char *ext , int force ) 
{ 
  int i ;
  int l ;
  char *p___0 ;
  char *q ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 112
  strcpy((char */* __restrict  */)fid1, (char const   */* __restrict  */)fid);
#line 113
  tmp = strlen((char const   *)fid1);
#line 113
  l = (int )tmp;
#line 114
  p___0 = fid1;
#line 115
  i = 0;
  }
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 115
    if (! (i < l)) {
#line 115
      goto while_break;
    }
#line 116
    if ((int )*(fid1 + i) == 47) {
#line 116
      p___0 = fid1 + i;
    }
#line 115
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  if (! force) {
    {
#line 119
    q = strchr((char const   *)p___0, '.');
    }
#line 120
    if (q) {
      {
#line 120
      tmp___0 = strlen((char const   *)fid1);
      }
#line 120
      if ((unsigned long )q != (unsigned long )((fid1 + tmp___0) - 1)) {
#line 120
        return;
      }
    }
  }
  {
#line 122
  tmp___1 = strchr((char const   *)p___0, '.');
  }
#line 122
  if (! tmp___1) {
    {
#line 122
    strcat((char */* __restrict  */)fid1, (char const   */* __restrict  */)".");
    }
  }
  {
#line 123
  q = strchr((char const   *)p___0, '.');
#line 124
  tmp___2 = strlen((char const   *)ext);
  }
#line 124
  if (tmp___2 > 0UL) {
#line 124
    q ++;
  }
  {
#line 125
  *q = (char)0;
#line 126
  strcat((char */* __restrict  */)fid1, (char const   */* __restrict  */)ext);
  }
#line 128
  return;
}
}
#line 132 "/home/june/repo/benchmarks/collector2/temp/xbs-0/subs.h"
int match(char *str , char *pat ) 
{ 
  char *p___0 ;
  char *s ;
  int tmp ;

  {
#line 136
  p___0 = pat;
#line 137
  s = str;
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    if (! ((int )*p___0 != 0)) {
#line 139
      goto while_break;
    }
#line 141
    if ((int )*p___0 == 42) {
#line 142
      p___0 ++;
      {
#line 143
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 143
        if (! ((int )*p___0 == 42)) {
#line 143
          goto while_break___0;
        }
#line 143
        p___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 144
      if ((int )*p___0 == 0) {
#line 144
        return (1);
      }
      {
#line 145
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 146
        if ((int )*s == 0) {
#line 146
          return (0);
        }
#line 147
        if ((int )*s == (int )*p___0) {
#line 147
          goto _L;
        } else
#line 147
        if ((int )*p___0 == 43) {
          _L: /* CIL Label */ 
          {
#line 148
          tmp = match(s + 1, p___0 + 1);
          }
#line 148
          if (tmp) {
#line 148
            return (1);
          }
        }
#line 149
        s ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 151
      return (0);
    } else {
#line 155
      if ((int )*s == 0) {
#line 155
        return (0);
      }
#line 156
      if ((int )*p___0 != (int )*s) {
#line 156
        if ((int )*p___0 != 43) {
#line 156
          return (0);
        }
      }
#line 157
      s ++;
    }
#line 159
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 162
  if ((int )*s != 0) {
#line 162
    return (0);
  }
#line 163
  return (1);
}
}
#line 167 "/home/june/repo/benchmarks/collector2/temp/xbs-0/subs.h"
void get_extent(float *xx1 , float *xx2 , float *yy1 , float *yy2 , float *zz1 , float *zz2 ) 
{ 
  float big ;
  float x1 ;
  float x2 ;
  float y1___0 ;
  float y2 ;
  float z1 ;
  float z2 ;
  int i ;

  {
#line 173
  big = (float )1000000;
#line 173
  if (nbas == 0) {
#line 173
    big = (float )0;
  }
#line 174
  z1 = big;
#line 174
  y1___0 = z1;
#line 174
  x1 = y1___0;
#line 175
  z2 = - big;
#line 175
  y2 = z2;
#line 175
  x2 = y2;
#line 176
  i = 0;
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    if (! (i < nbas)) {
#line 176
      goto while_break;
    }
#line 177
    if (p[i][0] < x1) {
#line 177
      x1 = p[i][0];
    }
#line 178
    if (p[i][0] > x2) {
#line 178
      x2 = p[i][0];
    }
#line 179
    if (p[i][1] < y1___0) {
#line 179
      y1___0 = p[i][1];
    }
#line 180
    if (p[i][1] > y2) {
#line 180
      y2 = p[i][1];
    }
#line 181
    if (p[i][2] < z1) {
#line 181
      z1 = p[i][2];
    }
#line 182
    if (p[i][2] > z2) {
#line 182
      z2 = p[i][2];
    }
#line 176
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  *xx1 = x1 + center[0];
#line 184
  *xx2 = x2 + center[0];
#line 185
  *yy1 = y1___0 + center[1];
#line 185
  *yy2 = y2 + center[1];
#line 186
  *zz1 = z1 + center[2];
#line 186
  *zz2 = z2 + center[2];
#line 187
  return;
}
}
#line 190 "/home/june/repo/benchmarks/collector2/temp/xbs-0/subs.h"
void atompos(float fac , float *p___0 , float rad , float *zp , float *zr ) 
{ 
  float y[3] ;
  float q[3] ;
  float v1[3] ;
  float v2[3] ;
  float xxx ;
  float za1 ;
  float za2 ;
  float zb1 ;
  float zb2 ;
  float a ;
  float b ;
  float tmp ;
  float tmp___0 ;
  float tmp___1 ;
  float tmp___2 ;
  float tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;

  {
#line 196
  if (pmode == 1) {
#line 197
    *(zp + 0) = fac * *(p___0 + 0);
#line 198
    *(zp + 1) = fac * *(p___0 + 1);
#line 199
    *zr = fac * rad;
#line 200
    *zr = (float )100.0;
#line 201
    if (dist0 - *(p___0 + 2) > (float )0) {
#line 201
      *zr = ((fac * rad) * dist0) / (dist0 - *(p___0 + 2));
    }
#line 202
    if ((double )*zr > 100.0) {
#line 202
      *zr = (float )100.0;
    }
#line 203
    return;
  }
  {
#line 206
  vscal(p___0, (float )1.0, (float *)(q));
#line 207
  q[2] -= dist;
#line 208
  vscal(p___0, (float )1.0, (float *)(y));
#line 209
  tmp = sp((float *)(y), (float *)(q));
#line 209
  tmp___0 = sp((float *)(q), (float *)(q));
#line 209
  xxx = - tmp / tmp___0;
#line 210
  vsum((float *)(y), (float *)(q), (float )1.0, xxx, (float *)(y));
#line 211
  tmp___1 = sp((float *)(y), (float *)(y));
  }
#line 211
  if ((double )tmp___1 <= 1e-3) {
#line 211
    y[0] = (float )1.0;
#line 211
    y[1] = (float )0.0;
#line 211
    y[2] = (float )0.0;
  }
  {
#line 213
  tmp___2 = sp((float *)(q), (float *)(q));
#line 213
  a = (- rad * rad) / tmp___2;
#line 214
  tmp___3 = sp((float *)(y), (float *)(y));
#line 214
  tmp___4 = sqrt((1.0 + (double )a) / (double )tmp___3);
#line 214
  b = (float )((double )rad * tmp___4);
#line 215
  vsum((float *)(q), (float *)(y), a, b, (float *)(v1));
#line 216
  vsum((float *)(q), (float *)(y), a, - b, (float *)(v2));
#line 217
  vsum(p___0, (float *)(v1), (float )1.0, (float )1.0, (float *)(v1));
#line 218
  vsum(p___0, (float *)(v2), (float )1.0, (float )1.0, (float *)(v2));
#line 219
  za1 = ((fac * v1[0]) * dist) / (dist - v1[2]);
#line 220
  za2 = ((fac * v1[1]) * dist) / (dist - v1[2]);
#line 221
  zb1 = ((fac * v2[0]) * dist) / (dist - v2[2]);
#line 222
  zb2 = ((fac * v2[1]) * dist) / (dist - v2[2]);
#line 223
  *(zp + 0) = (float )(0.5 * (double )(za1 + zb1));
#line 224
  *(zp + 1) = (float )(0.5 * (double )(za2 + zb2));
#line 225
  *zr = (zb1 - za1) * (zb1 - za1) + (zb2 - za2) * (zb2 - za2);
#line 226
  tmp___5 = sqrt((double )*zr);
#line 226
  *zr = (float )(0.5 * tmp___5);
  }
#line 227
  return;
}
}
#line 269
int readclusterline(char *str , int helpme ) ;
#line 230 "/home/june/repo/benchmarks/collector2/temp/xbs-0/subs.h"
int readclusterdata(char *infile ) 
{ 
  FILE *fp ;
  char str[257] ;
  char token[81] ;
  char xxx[81] ;
  char *p___0 ;
  int l ;
  int i ;
  int nn ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 238
  fp = fopen((char const   */* __restrict  */)infile, (char const   */* __restrict  */)"r");
  }
#line 238
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 238
    return (0);
  }
  {
#line 240
  fgets((char */* __restrict  */)(str), 257, (FILE */* __restrict  */)fp);
  }
  {
#line 241
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 241
    tmp___1 = feof(fp);
    }
#line 241
    if (tmp___1) {
#line 241
      goto while_break;
    }
    {
#line 242
    tmp = strlen((char const   *)(str));
#line 242
    l = (int )tmp;
#line 243
    str[l + 1] = (char )'\000';
#line 244
    strcpy((char */* __restrict  */)(token), (char const   */* __restrict  */)"SNOT");
#line 245
    sscanf((char const   */* __restrict  */)(str), (char const   */* __restrict  */)"%s",
           token);
#line 246
    p___0 = strstr((char const   *)(str), "frame");
    }
#line 246
    if (p___0) {
#line 247
      if (nframe * nbas > 70000) {
        {
#line 247
        rx((char *)"increase internal dimension FBMAX");
        }
      }
#line 248
      if (nframe > 8000) {
        {
#line 248
        rx((char *)"increase internal dimension NFRMAX");
        }
      }
      {
#line 249
      p___0 += 6;
#line 250
      sprintf((char */* __restrict  */)(frstr[nframe]), (char const   */* __restrict  */)"%-80s",
              p___0);
#line 251
      i = 0;
      }
      {
#line 251
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 251
        tmp___0 = strlen((char const   *)(frstr[nframe]));
        }
#line 251
        if (! ((size_t )i < tmp___0)) {
#line 251
          goto while_break___0;
        }
#line 252
        if ((int )frstr[nframe][i] == 10) {
#line 252
          frstr[nframe][i] = (char )'\000';
        }
#line 251
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 253
      i = 0;
      {
#line 253
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 253
        if (! (i < nbas)) {
#line 253
          goto while_break___1;
        }
        {
#line 254
        nn = nframe * nbas + i;
#line 255
        fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%f",
               & frame[0][nn]);
#line 256
        fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%f",
               & frame[1][nn]);
#line 257
        fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%f",
               & frame[2][nn]);
#line 253
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 259
      nframe ++;
#line 261
      if (nframe % 50 == 0) {
        {
#line 262
        sprintf((char */* __restrict  */)(xxx), (char const   */* __restrict  */)": frame %d         ",
                nframe);
#line 263
        showline(win, 10, 8, (char *)"Reading ", inmv, xxx);
#line 264
        XFlush(dpy);
        }
      }
      {
#line 267
      fgets((char */* __restrict  */)(str), 257, (FILE */* __restrict  */)fp);
      }
    } else {
      {
#line 269
      readclusterline(str, 0);
      }
    }
    {
#line 270
    fgets((char */* __restrict  */)(str), 257, (FILE */* __restrict  */)fp);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 272
  sprintf((char */* __restrict  */)(curf), (char const   */* __restrict  */)"%s ",
          inf);
  }
#line 273
  return (1);
}
}
#line 277 "/home/june/repo/benchmarks/collector2/temp/xbs-0/subs.h"
int readclusterline(char *str , int helpme ) 
{ 
  char token[81] ;
  int l ;
  int n ;
  int nn ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;

  {
  {
#line 283
  tmp = strlen((char const   *)str);
#line 283
  l = (int )tmp;
  }
#line 283
  if (l < 1) {
#line 283
    return (0);
  }
  {
#line 284
  strcpy((char */* __restrict  */)(token), (char const   */* __restrict  */)"SNOT");
#line 285
  sscanf((char const   */* __restrict  */)str, (char const   */* __restrict  */)"%s",
         token);
#line 286
  tmp___0 = strcmp((char const   *)(token), "SNOT");
  }
#line 286
  if (! tmp___0) {
#line 286
    return (0);
  }
#line 287
  if ((int )token[0] == 42) {
#line 287
    return (0);
  }
#line 289
  if (helpme) {
    {
#line 290
    tmp___14 = abbrev(token, (char *)"spec", 4);
    }
#line 290
    if (tmp___14) {
      {
#line 291
      sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"Usage: spec label radius color  - define species");
      }
    } else {
      {
#line 292
      tmp___13 = abbrev(token, (char *)"atom", 4);
      }
#line 292
      if (tmp___13) {
        {
#line 293
        sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"Usage: atom label x y z  - place atom at (x,y,z)");
        }
      } else {
        {
#line 294
        tmp___12 = abbrev(token, (char *)"bonds", 5);
        }
#line 294
        if (tmp___12) {
          {
#line 295
          sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"Usage: bonds pat1 pat2 min max rad color  - select bonds");
          }
        } else {
          {
#line 296
          tmp___11 = abbrev(token, (char *)"light", 5);
          }
#line 296
          if (tmp___11) {
            {
#line 297
            sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"Usage: light vx vy vz  - light along vector in bw mode)");
            }
          } else {
            {
#line 298
            tmp___10 = abbrev(token, (char *)"inc", 3);
            }
#line 298
            if (tmp___10) {
              {
#line 299
              sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"Usage: inc degrees  - angle increment for rotation");
              }
            } else {
              {
#line 300
              tmp___9 = abbrev(token, (char *)"dist", 5);
              }
#line 300
              if (tmp___9) {
                {
#line 301
                sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"Usage: dist d  - set distance for perspective");
                }
              } else {
                {
#line 302
                tmp___8 = abbrev(token, (char *)"frm", 3);
                }
#line 302
                if (tmp___8) {
                  {
#line 303
                  sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"Usage: frm n  - goto frame n");
                  }
                } else {
                  {
#line 304
                  tmp___7 = abbrev(token, (char *)"step", 4);
                  }
#line 304
                  if (tmp___7) {
                    {
#line 305
                    sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"Usage: step n  - set step for frames");
                    }
                  } else {
                    {
#line 306
                    tmp___6 = abbrev(token, (char *)"gramp", 5);
                    }
#line 306
                    if (tmp___6) {
                      {
#line 307
                      sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"Usage: gramp slope [middle]  - set gray ramp in bw mode)");
                      }
                    } else {
                      {
#line 308
                      tmp___5 = abbrev(token, (char *)"scale", 5);
                      }
#line 308
                      if (tmp___5) {
                        {
#line 309
                        sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"Usage: scale x  - set overall scale factor");
                        }
                      } else {
                        {
#line 310
                        tmp___4 = abbrev(token, (char *)"rfac", 4);
                        }
#line 310
                        if (tmp___4) {
                          {
#line 311
                          sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"Usage: rfac x  - scale all sphere radii by x");
                          }
                        } else {
                          {
#line 312
                          tmp___3 = abbrev(token, (char *)"bfac", 4);
                          }
#line 312
                          if (tmp___3) {
                            {
#line 313
                            sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"Usage: bfac x  - scale all bond radii by x");
                            }
                          } else {
                            {
#line 314
                            tmp___2 = abbrev(token, (char *)"pos", 3);
                            }
#line 314
                            if (tmp___2) {
                              {
#line 315
                              sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"Usage: pos px py  - set position on page");
                              }
                            } else {
                              {
#line 316
                              tmp___1 = abbrev(token, (char *)"dpos", 4);
                              }
#line 316
                              if (tmp___1) {
                                {
#line 317
                                sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"Usage: dpos x  - set increment for position");
                                }
                              } else {
                                {
#line 319
                                sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"No help available on %s",
                                        token);
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 320
    return (0);
  }
  {
#line 323
  tmp___15 = strcmp((char const   *)(token), "spec");
  }
#line 323
  if (! tmp___15) {
    {
#line 324
    sscanf((char const   */* __restrict  */)str, (char const   */* __restrict  */)"%*s %s %f %n",
           spec[nspec].lab, & spec[nspec].rad, & n);
#line 325
    strip(spec[nspec].cname, str + n);
#line 326
    nspec ++;
    }
#line 327
    if (nspec > 50) {
      {
#line 327
      rx((char *)"increase internal dimension NSPMAX");
      }
    }
#line 328
    return (2);
  }
  {
#line 331
  tmp___16 = strcmp((char const   *)(token), "atom");
  }
#line 331
  if (! tmp___16) {
    {
#line 332
    atom[nbas].pol[0] = (float )0;
#line 333
    atom[nbas].pol[1] = (float )0;
#line 334
    atom[nbas].pol[2] = (float )0;
#line 335
    sscanf((char const   */* __restrict  */)str, (char const   */* __restrict  */)"%*s %s %f %f %f %f %f %f",
           atom[nbas].lab, & atom[nbas].pos[0], & atom[nbas].pos[1], & atom[nbas].pos[2],
           & atom[nbas].pol[0], & atom[nbas].pol[1], & atom[nbas].pol[2]);
#line 338
    nbas ++;
    }
#line 338
    if (nbas > 2000) {
      {
#line 338
      rx((char *)"increase internal dimension NAMAX");
      }
    }
#line 339
    return (2);
  }
  {
#line 342
  tmp___17 = strcmp((char const   *)(token), "bonds");
  }
#line 342
  if (! tmp___17) {
    {
#line 343
    sscanf((char const   */* __restrict  */)str, (char const   */* __restrict  */)"%*s %s %s %f %f %f %n",
           bonds[nbonds].lab1, bonds[nbonds].lab2, & bonds[nbonds].min, & bonds[nbonds].max,
           & bonds[nbonds].rad, & n);
#line 346
    strip(bonds[nbonds].cname, str + n);
#line 347
    nbonds ++;
    }
#line 348
    if (nbonds > 200) {
      {
#line 348
      rx((char *)"increase internal dimension NBTMAX");
      }
    }
#line 349
    return (2);
  }
  {
#line 352
  tmp___18 = strcmp((char const   *)(token), "line");
  }
#line 352
  if (! tmp___18) {
    {
#line 353
    sscanf((char const   */* __restrict  */)str, (char const   */* __restrict  */)"%*s %f %f %f %f %f %f",
           & xline[nxline].a[0], & xline[nxline].a[1], & xline[nxline].a[2], & xline[nxline].b[0],
           & xline[nxline].b[1], & xline[nxline].b[2]);
#line 356
    nxline ++;
    }
#line 357
    if (nxline > 50) {
      {
#line 357
      rx((char *)"increase internal dimension NLNMAX");
      }
    }
#line 358
    return (1);
  }
  {
#line 361
  tmp___19 = strcmp((char const   *)(token), "tmat");
  }
#line 361
  if (! tmp___19) {
    {
#line 362
    sscanf((char const   */* __restrict  */)str, (char const   */* __restrict  */)"%*s %f %f %f %f %f %f %f %f %f",
           & tmat[0][0], & tmat[0][1], & tmat[0][2], & tmat[1][0], & tmat[1][1], & tmat[1][2],
           & tmat[2][0], & tmat[2][1], & tmat[2][2]);
    }
#line 366
    return (1);
  }
  {
#line 369
  tmp___20 = strcmp((char const   *)(token), "dist");
  }
#line 369
  if (tmp___20) {
    {
#line 369
    tmp___21 = strcmp((char const   *)(token), "d");
    }
#line 369
    if (! tmp___21) {
      {
#line 370
      sscanf((char const   */* __restrict  */)str, (char const   */* __restrict  */)"%*s %f",
             & dist0);
      }
#line 371
      return (1);
    }
  } else {
    {
#line 370
    sscanf((char const   */* __restrict  */)str, (char const   */* __restrict  */)"%*s %f",
           & dist0);
    }
#line 371
    return (1);
  }
  {
#line 374
  tmp___22 = strcmp((char const   *)(token), "inc");
  }
#line 374
  if (! tmp___22) {
    {
#line 374
    sscanf((char const   */* __restrict  */)str, (char const   */* __restrict  */)"%*s %f",
           & dalfa);
    }
#line 374
    return (3);
  }
  {
#line 376
  tmp___23 = strcmp((char const   *)(token), "frm");
  }
#line 376
  if (! tmp___23) {
    {
#line 377
    sscanf((char const   */* __restrict  */)str, (char const   */* __restrict  */)"%*s %d",
           & nn);
    }
#line 378
    if (nn > nframe) {
      {
#line 379
      sprintf((char */* __restrict  */)(emsg), (char const   */* __restrict  */)"No frame %d available",
              nn);
      }
#line 380
      return (0);
    } else
#line 378
    if (nn < 1) {
      {
#line 379
      sprintf((char */* __restrict  */)(emsg), (char const   */* __restrict  */)"No frame %d available",
              nn);
      }
#line 380
      return (0);
    }
#line 382
    if (iframe == nn - 1) {
#line 382
      return (0);
    }
#line 383
    iframe = nn - 1;
#line 384
    return (2);
  }
  {
#line 387
  tmp___24 = strcmp((char const   *)(token), "light");
  }
#line 387
  if (! tmp___24) {
    {
#line 388
    light[2] = (float )0.0;
#line 388
    light[1] = light[2];
#line 388
    light[0] = light[1];
#line 389
    sscanf((char const   */* __restrict  */)str, (char const   */* __restrict  */)"%*s %f %f %f",
           & light[0], & light[1], & light[2]);
    }
#line 390
    if ((double )((light[0] * light[0] + light[1] * light[1]) + light[2] * light[2]) < .01) {
      {
#line 391
      sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"Use standard coloring");
#line 392
      gmode = 0;
      }
#line 393
      return (2);
    }
#line 395
    if (color) {
      {
#line 396
      sprintf((char */* __restrict  */)(emsg), (char const   */* __restrict  */)"light: only works in b/w mode");
      }
#line 397
      return (0);
    }
#line 399
    gmode = 2;
#line 400
    return (2);
  }
  {
#line 403
  tmp___25 = strcmp((char const   *)(token), "step");
  }
#line 403
  if (! tmp___25) {
    {
#line 403
    sscanf((char const   */* __restrict  */)str, (char const   */* __restrict  */)"%*s %d",
           & fstep);
    }
#line 403
    return (1);
  }
  {
#line 404
  tmp___26 = strcmp((char const   *)(token), "scale");
  }
#line 404
  if (! tmp___26) {
    {
#line 405
    sscanf((char const   */* __restrict  */)str, (char const   */* __restrict  */)"%*s %f",
           & scale);
#line 406
    scale *= igs;
    }
#line 407
    return (1);
  }
  {
#line 409
  tmp___27 = strcmp((char const   *)(token), "rfac");
  }
#line 409
  if (! tmp___27) {
    {
#line 409
    sscanf((char const   */* __restrict  */)str, (char const   */* __restrict  */)"%*s %f",
           & radfac);
    }
#line 409
    return (1);
  }
  {
#line 410
  tmp___28 = strcmp((char const   *)(token), "bfac");
  }
#line 410
  if (! tmp___28) {
    {
#line 410
    sscanf((char const   */* __restrict  */)str, (char const   */* __restrict  */)"%*s %f",
           & bndfac);
    }
#line 410
    return (1);
  }
  {
#line 411
  tmp___29 = strcmp((char const   *)(token), "amp");
  }
#line 411
  if (! tmp___29) {
    {
#line 411
    sscanf((char const   */* __restrict  */)str, (char const   */* __restrict  */)"%*s %f",
           & amp);
    }
#line 411
    return (2);
  }
  {
#line 412
  tmp___30 = strcmp((char const   *)(token), "pos");
  }
#line 412
  if (! tmp___30) {
    {
#line 413
    sscanf((char const   */* __restrict  */)str, (char const   */* __restrict  */)"%*s %f %f",
           & taux, & tauy);
    }
#line 413
    return (1);
  }
  {
#line 414
  tmp___31 = strcmp((char const   *)(token), "dpos");
  }
#line 414
  if (! tmp___31) {
    {
#line 415
    sscanf((char const   */* __restrict  */)str, (char const   */* __restrict  */)"%*s %f",
           & dtaux);
#line 415
    dtauy = dtaux;
#line 415
    chginfo = 1;
    }
#line 415
    return (0);
  }
  {
#line 417
  tmp___32 = strcmp((char const   *)(token), "gramp");
  }
#line 417
  if (! tmp___32) {
    {
#line 418
    gz0 = (float )0;
#line 418
    gslope = gz0;
#line 419
    sscanf((char const   */* __restrict  */)str, (char const   */* __restrict  */)"%*s %f %f",
           & gslope, & gz0);
    }
#line 420
    if ((double )(gslope * gslope) < 0.1) {
      {
#line 421
      sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"Use standard coloring");
#line 422
      gmode = 0;
      }
#line 423
      return (2);
    }
#line 425
    if (color) {
      {
#line 426
      sprintf((char */* __restrict  */)(emsg), (char const   */* __restrict  */)"gramp: only works in b/w mode");
      }
#line 427
      return (0);
    }
#line 429
    gmode = 1;
#line 430
    return (2);
  }
  {
#line 433
  tmp___33 = strcmp((char const   *)(token), "switches");
  }
#line 433
  if (! tmp___33) {
    {
#line 434
    sscanf((char const   */* __restrict  */)str, (char const   */* __restrict  */)"%*s %d %d %d %d %d %d %d %d %d",
           & usepixmap, & numbers, & grayvalues, & bline, & wire, & withbonds, & recenter,
           & pmode, & shadow);
    }
#line 437
    return (2);
  }
  {
#line 440
  sprintf((char */* __restrict  */)(emsg), (char const   */* __restrict  */)"Undefined command: %s",
          token);
  }
#line 441
  if (startup) {
    {
#line 441
    printf((char const   */* __restrict  */)"Cannot understand line: %s\n", str);
    }
  }
#line 442
  return (0);
}
}
#line 446 "/home/june/repo/benchmarks/collector2/temp/xbs-0/subs.h"
void writeclusterdata(char *outfile , int svstep , int svrgb ) 
{ 
  FILE *fp ;
  char nm[81] ;
  int i ;
  int nn ;
  int n ;
  int nfrm ;
  time_t ltime ;
  char timestr[41] ;
  char *tmp ;

  {
  {
#line 454
  fp = fopen((char const   */* __restrict  */)outfile, (char const   */* __restrict  */)"w");
  }
#line 454
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 455
    sprintf((char */* __restrict  */)(emsg), (char const   */* __restrict  */)"Cannot open file %s\n",
            outfile);
    }
#line 455
    return;
  }
  {
#line 457
  time(& ltime);
#line 458
  tmp = ctime((time_t const   *)(& ltime));
#line 458
  strcpy((char */* __restrict  */)(timestr), (char const   */* __restrict  */)tmp);
#line 459
  timestr[24] = (char)0;
#line 460
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"* Saved %s from %s\n\n",
          timestr, inf);
#line 462
  i = 0;
  }
  {
#line 462
  while (1) {
    while_continue: /* CIL Label */ ;
#line 462
    if (! (i < nbas)) {
#line 462
      goto while_break;
    }
    {
#line 463
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"atom %6s  %10.3f %10.3f %10.3f \n",
            atom[i].lab, (double )atom[i].pos[0], (double )atom[i].pos[1], (double )atom[i].pos[2]);
#line 462
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 467
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
#line 468
  i = 0;
  }
  {
#line 468
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 468
    if (! (i < nspec)) {
#line 468
      goto while_break___0;
    }
#line 469
    if (svrgb) {
      {
#line 470
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"spec %6s %10.3f   %.2f %.2f %.2f\n",
              spec[i].lab, (double )spec[i].rad, (double )spec[i].r, (double )spec[i].g,
              (double )spec[i].b);
      }
    } else
#line 469
    if (reverse) {
      {
#line 470
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"spec %6s %10.3f   %.2f %.2f %.2f\n",
              spec[i].lab, (double )spec[i].rad, (double )spec[i].r, (double )spec[i].g,
              (double )spec[i].b);
      }
    } else {
      {
#line 473
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"spec %6s %10.3f   %s\n",
              spec[i].lab, (double )spec[i].rad, spec[i].cname);
      }
    }
#line 468
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 476
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
#line 477
  i = 0;
  }
  {
#line 477
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 477
    if (! (i < nbonds)) {
#line 477
      goto while_break___1;
    }
#line 478
    if (svrgb) {
      {
#line 479
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"bonds %5s %5s %8.3f %8.3f %8.3f   %.2f %.2f %.2f\n",
              bonds[i].lab1, bonds[i].lab2, (double )bonds[i].min, (double )bonds[i].max,
              (double )bonds[i].rad, (double )bonds[i].r, (double )bonds[i].g, (double )bonds[i].b);
      }
    } else
#line 478
    if (reverse) {
      {
#line 479
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"bonds %5s %5s %8.3f %8.3f %8.3f   %.2f %.2f %.2f\n",
              bonds[i].lab1, bonds[i].lab2, (double )bonds[i].min, (double )bonds[i].max,
              (double )bonds[i].rad, (double )bonds[i].r, (double )bonds[i].g, (double )bonds[i].b);
      }
    } else {
      {
#line 483
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"bonds %5s %5s %8.3f %8.3f %8.3f   %s\n",
              bonds[i].lab1, bonds[i].lab2, (double )bonds[i].min, (double )bonds[i].max,
              (double )bonds[i].rad, bonds[i].cname);
      }
    }
#line 477
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 487
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\ntmat %6.3f %6.3f %6.3f %6.3f %6.3f %6.3f %6.3f %6.3f %6.3f\n",
          (double )tmat[0][0], (double )tmat[0][1], (double )tmat[0][2], (double )tmat[1][0],
          (double )tmat[1][1], (double )tmat[1][2], (double )tmat[2][0], (double )tmat[2][1],
          (double )tmat[2][2]);
#line 491
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"dist  %8.3f\n",
          (double )dist0);
#line 492
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"inc   %8.3f\n",
          (double )dalfa);
#line 493
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"scale %8.3f\nrfac %.2f\nbfac %.2f\n",
          (double )scale, (double )radfac, (double )bndfac);
#line 494
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"pos %8.3f %8.3f\n",
          (double )taux, (double )tauy);
  }
#line 495
  if (gmode == 1) {
    {
#line 496
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"gramp %8.3f %8.3f\n",
            (double )gslope, (double )gz0);
    }
  }
#line 497
  if (gmode == 2) {
    {
#line 498
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"light %8.3f %8.3f %8.3f\n",
            (double )light[0], (double )light[1], (double )light[2]);
    }
  }
  {
#line 500
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"switches %d %d %d %d %d %d %d %d %d\n",
          usepixmap, numbers, grayvalues, bline, wire, withbonds, recenter, pmode,
          shadow);
#line 504
  fclose(fp);
#line 505
  sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"Saved in %s",
          outfile);
  }
#line 507
  if (nframe > 1) {
    {
#line 508
    strext(nm, outfile, (char *)"mv", 1);
#line 509
    fp = fopen((char const   */* __restrict  */)(nm), (char const   */* __restrict  */)"w");
    }
#line 509
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
      {
#line 510
      sprintf((char */* __restrict  */)(emsg), (char const   */* __restrict  */)"Cannot open file %s\n",
              nm);
      }
#line 510
      return;
    }
#line 511
    nfrm = 1;
#line 512
    i = 1;
    {
#line 512
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 512
      if (! (i < nframe)) {
#line 512
        goto while_break___2;
      }
      {
#line 513
      nfrm ++;
#line 514
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"frame %s\n",
              frstr[i]);
#line 515
      n = 0;
      }
      {
#line 515
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 515
        if (! (n < nbas)) {
#line 515
          goto while_break___3;
        }
        {
#line 516
        nn = i * nbas + n;
#line 517
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%.3f %.3f %.3f ",
                (double )frame[0][nn], (double )frame[1][nn], (double )frame[2][nn]);
#line 515
        n ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 520
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n\n");
#line 512
      i += svstep;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 522
    fclose(fp);
#line 523
    sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"Saved %d frames in %s and %s",
            nfrm, outfile, nm);
    }
  }
#line 527
  return;
}
}
#line 531 "/home/june/repo/benchmarks/collector2/temp/xbs-0/subs.h"
void parse_all_colors(void) 
{ 
  int i ;

  {
#line 535
  i = 0;
  {
#line 535
  while (1) {
    while_continue: /* CIL Label */ ;
#line 535
    if (! (i < nspec)) {
#line 535
      goto while_break;
    }
    {
#line 536
    parse_color(spec[i].cname, & spec[i].r, & spec[i].g, & spec[i].b, & spec[i].gray);
#line 535
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 539
  i = 0;
  {
#line 539
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 539
    if (! (i < nbonds)) {
#line 539
      goto while_break___0;
    }
    {
#line 540
    parse_color(bonds[i].cname, & bonds[i].r, & bonds[i].g, & bonds[i].b, & bonds[i].gray);
#line 539
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 542
  return;
}
}
#line 545 "/home/june/repo/benchmarks/collector2/temp/xbs-0/subs.h"
void set_auto_colors(void) 
{ 
  int k ;
  int i ;
  int up1 ;
  char id[21] ;
  char *p___0 ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 551
  k = 0;
  {
#line 551
  while (1) {
    while_continue: /* CIL Label */ ;
#line 551
    if (! (k < nspec)) {
#line 551
      goto while_break;
    }
    {
#line 553
    tmp = __ctype_b_loc();
#line 553
    up1 = (int )((int const   )*(*tmp + (int )spec[k].lab[0]) & 256);
#line 554
    p___0 = & spec[k].lab[0];
#line 555
    i = 0;
    }
    {
#line 556
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 556
      if (! ((int )*p___0 != 0)) {
#line 556
        goto while_break___0;
      }
      {
#line 557
      tmp___0 = toupper((int )*p___0);
#line 557
      id[i] = (char )tmp___0;
#line 557
      p___0 ++;
#line 557
      i ++;
#line 558
      tmp___1 = __ctype_b_loc();
      }
#line 558
      if (! ((int const   )*(*tmp___1 + (int )*p___0) & 1024)) {
#line 558
        goto while_break___0;
      }
#line 559
      if (up1) {
        {
#line 559
        tmp___2 = __ctype_b_loc();
        }
#line 559
        if ((int const   )*(*tmp___2 + (int )*p___0) & 256) {
#line 559
          goto while_break___0;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 561
    id[i] = (char)0;
#line 565
    strcpy((char */* __restrict  */)(spec[k].cname), (char const   */* __restrict  */)".68 .85 .90");
#line 567
    tmp___3 = strcmp((char const   *)(id), "H");
    }
#line 567
    if (! tmp___3) {
      {
#line 567
      strcpy((char */* __restrict  */)(spec[k].cname), (char const   */* __restrict  */)"1.0 0.2 0.2");
      }
    }
    {
#line 568
    tmp___4 = strcmp((char const   *)(id), "C");
    }
#line 568
    if (! tmp___4) {
      {
#line 568
      strcpy((char */* __restrict  */)(spec[k].cname), (char const   */* __restrict  */)"0.65 0.7 0.7");
      }
    }
    {
#line 570
    tmp___5 = strcmp((char const   *)(id), "O");
    }
#line 570
    if (! tmp___5) {
      {
#line 570
      strcpy((char */* __restrict  */)(spec[k].cname), (char const   */* __restrict  */)"blue");
      }
    }
    {
#line 571
    tmp___6 = strcmp((char const   *)(id), "N");
    }
#line 571
    if (! tmp___6) {
      {
#line 571
      strcpy((char */* __restrict  */)(spec[k].cname), (char const   */* __restrict  */)"0.8 0.0 1.0");
      }
    }
    {
#line 572
    tmp___7 = strcmp((char const   *)(id), "P");
    }
#line 572
    if (! tmp___7) {
      {
#line 572
      strcpy((char */* __restrict  */)(spec[k].cname), (char const   */* __restrict  */)"0.0 0.8 0.0");
      }
    }
    {
#line 573
    tmp___8 = strcmp((char const   *)(id), "CL");
    }
#line 573
    if (! tmp___8) {
      {
#line 573
      strcpy((char */* __restrict  */)(spec[k].cname), (char const   */* __restrict  */)"0.9 0.9 0.7");
      }
    }
    {
#line 574
    tmp___9 = strcmp((char const   *)(id), "TI");
    }
#line 574
    if (! tmp___9) {
      {
#line 574
      strcpy((char */* __restrict  */)(spec[k].cname), (char const   */* __restrict  */)"0.2 1.0 1.0");
      }
    }
#line 551
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 577
  k = 0;
  {
#line 577
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 577
    if (! (k < nbonds)) {
#line 577
      goto while_break___1;
    }
    {
#line 578
    strcpy((char */* __restrict  */)(bonds[k].cname), (char const   */* __restrict  */)"0.8 0.8 0.8");
#line 577
    k ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 580
  return;
}
}
#line 583 "/home/june/repo/benchmarks/collector2/temp/xbs-0/subs.h"
int ball_list(struct ballstr *ball___0 , int jpr ) 
{ 
  int i ;
  int j ;
  int k ;
  int m ;
  float top ;
  float bot ;
  float sp___0 ;
  int tmp ;

  {
#line 588
  i = 0;
  {
#line 588
  while (1) {
    while_continue: /* CIL Label */ ;
#line 588
    if (! (i < nbas)) {
#line 588
      goto while_break;
    }
#line 589
    k = -1;
#line 590
    j = 0;
    {
#line 590
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 590
      if (! (j < nspec)) {
#line 590
        goto while_break___0;
      }
      {
#line 590
      tmp = strcmp((char const   *)(spec[j].lab), (char const   *)(atom[i].lab));
      }
#line 590
      if (! tmp) {
#line 590
        k = j;
      }
#line 590
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 591
    if (k == -1) {
#line 592
      if (! startup) {
        {
#line 593
        sprintf((char */* __restrict  */)(emsg), (char const   */* __restrict  */)"Undefined species %s ",
                atom[i].lab);
        }
      } else {
        {
#line 595
        printf((char const   */* __restrict  */)"Undefined species %s\n", atom[i].lab);
        }
      }
#line 596
      goto __Cont;
    }
#line 598
    m = 0;
    {
#line 598
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 598
      if (! (m < 3)) {
#line 598
        goto while_break___1;
      }
#line 598
      (ball___0 + i)->pos[m] = atom[i].pos[m] + amp * atom[i].pol[m];
#line 598
      m ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 599
    (ball___0 + i)->rad = spec[k].rad;
#line 600
    (ball___0 + i)->gray = spec[k].gray;
#line 601
    (ball___0 + i)->r = spec[k].r;
#line 602
    (ball___0 + i)->g = spec[k].g;
#line 603
    (ball___0 + i)->b = spec[k].b;
#line 604
    strcpy((char */* __restrict  */)((ball___0 + i)->lab), (char const   */* __restrict  */)(spec[k].lab));
#line 605
    (ball___0 + i)->special = 0;
#line 606
    (ball___0 + i)->col = spec[k].col;
    }
#line 607
    if ((double )spec[k].gray < - 0.1) {
#line 607
      (ball___0 + i)->gray = (float )1.0;
#line 607
      (ball___0 + i)->special = 1;
    }
    __Cont: /* CIL Label */ 
#line 588
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 610
  if (gmode == 2) {
#line 611
    top = (float )(- 1000.0);
#line 612
    bot = (float )1000.0;
#line 613
    i = 0;
    {
#line 613
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 613
      if (! (i < nbas)) {
#line 613
        goto while_break___2;
      }
#line 614
      if (! (ball___0 + i)->special) {
#line 615
        sp___0 = ((ball___0 + i)->pos[0] * light[0] + (ball___0 + i)->pos[1] * light[1]) + (ball___0 + i)->pos[2] * light[2];
#line 617
        if (sp___0 > top) {
#line 617
          top = sp___0;
        }
#line 618
        if (sp___0 < bot) {
#line 618
          bot = sp___0;
        }
      }
#line 613
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 621
    i = 0;
    {
#line 621
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 621
      if (! (i < nbas)) {
#line 621
        goto while_break___3;
      }
#line 622
      if (! (ball___0 + i)->special) {
#line 623
        sp___0 = ((ball___0 + i)->pos[0] * light[0] + (ball___0 + i)->pos[1] * light[1]) + (ball___0 + i)->pos[2] * light[2];
#line 625
        (ball___0 + i)->gray = (sp___0 - bot) / (top - bot);
      }
#line 621
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 630
  return (nbas);
}
}
#line 634 "/home/june/repo/benchmarks/collector2/temp/xbs-0/subs.h"
int stick_list(struct ballstr *ball___0 , struct stickstr *stick___0 ) 
{ 
  int i ;
  int j ;
  int k ;
  int l ;
  int m ;
  int nbond___0 ;
  int kb ;
  float dis ;
  float dd ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  double tmp___3 ;

  {
#line 639
  i = -1;
#line 640
  k = 0;
  {
#line 640
  while (1) {
    while_continue: /* CIL Label */ ;
#line 640
    if (! (k < nbas)) {
#line 640
      goto while_break;
    }
#line 641
    l = k + 1;
    {
#line 641
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 641
      if (! (l < nbas)) {
#line 641
        goto while_break___0;
      }
#line 642
      kb = -1;
#line 643
      j = 0;
      {
#line 643
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 643
        if (! (j < nbonds)) {
#line 643
          goto while_break___1;
        }
        {
#line 644
        tmp = match((ball___0 + k)->lab, bonds[j].lab1);
        }
#line 644
        if (tmp) {
          {
#line 644
          tmp___0 = match((ball___0 + l)->lab, bonds[j].lab2);
          }
#line 644
          if (tmp___0) {
#line 645
            kb = j;
          }
        }
        {
#line 646
        tmp___1 = match((ball___0 + l)->lab, bonds[j].lab1);
        }
#line 646
        if (tmp___1) {
          {
#line 646
          tmp___2 = match((ball___0 + k)->lab, bonds[j].lab2);
          }
#line 646
          if (tmp___2) {
#line 647
            kb = j;
          }
        }
#line 643
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 653
      if (kb > -1) {
#line 654
        dis = (float )0.0;
#line 655
        m = 0;
        {
#line 655
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 655
          if (! (m < 3)) {
#line 655
            goto while_break___2;
          }
#line 656
          dd = (ball___0 + k)->pos[m] - (ball___0 + l)->pos[m];
#line 657
          dis += dd * dd;
#line 655
          m ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 659
        tmp___3 = sqrt((double )dis);
#line 659
        dis = (float )((double )alat * tmp___3);
        }
#line 660
        if (dis >= bonds[kb].min) {
#line 660
          if (dis <= bonds[kb].max) {
#line 661
            i ++;
#line 661
            if (i > 8000) {
              {
#line 661
              rx((char *)"increase internal dimension NBMAX");
              }
            }
#line 662
            (stick___0 + i)->start = k;
#line 663
            (stick___0 + i)->end = l;
#line 664
            (stick___0 + i)->rad = bonds[kb].rad;
#line 665
            (stick___0 + i)->gray = bonds[kb].gray;
#line 666
            (stick___0 + i)->col = bonds[kb].col;
          }
        }
      }
#line 641
      l ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 640
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 671
  nbond___0 = i + 1;
#line 672
  return (nbond___0);
}
}
#line 677 "/home/june/repo/benchmarks/collector2/temp/xbs-0/subs.h"
int duplicate_atoms(float (*sh)[6] , int helpme ) 
{ 
  int k ;
  int l ;
  int iv ;
  int nbas1 ;
  int ndup ;
  int fr ;
  int nn ;
  int nn1 ;
  float cx ;
  float cy ;
  float cz ;

  {
#line 684
  if (helpme) {
    {
#line 685
    sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"Usage: dup vx vy vz  - duplicate shifted by vector");
    }
#line 686
    return (0);
  }
#line 689
  ndup = 0;
#line 690
  iv = 0;
  {
#line 690
  while (1) {
    while_continue: /* CIL Label */ ;
#line 690
    if (! (iv < 6)) {
#line 690
      goto while_break;
    }
#line 691
    cx = (*(sh + 0))[iv];
#line 691
    cy = (*(sh + 1))[iv];
#line 691
    cz = (*(sh + 2))[iv];
#line 692
    if ((double )((cx * cx + cy * cy) + cz * cz) > 0.001) {
#line 692
      ndup ++;
    }
#line 690
    iv ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 695
  if (ndup == 0) {
    {
#line 696
    sprintf((char */* __restrict  */)(emsg), (char const   */* __restrict  */)"Cannot dup for (0,0,0)");
    }
#line 697
    return (0);
  }
#line 700
  nbas1 = nbas * (ndup + 1);
#line 701
  if (nframe * nbas1 > 70000) {
    {
#line 702
    sprintf((char */* __restrict  */)(emsg), (char const   */* __restrict  */)"Cannot dup, internal dimension FBMAX too small");
    }
#line 703
    return (0);
  }
#line 705
  if (nbas * (ndup + 1) > 2000) {
    {
#line 706
    sprintf((char */* __restrict  */)(emsg), (char const   */* __restrict  */)"Cannot dup, internal dimension NAMAX too small");
    }
#line 707
    return (0);
  }
#line 710
  iv = 0;
  {
#line 710
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 710
    if (! (iv < ndup)) {
#line 710
      goto while_break___0;
    }
#line 711
    k = 0;
    {
#line 711
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 711
      if (! (k < nbas)) {
#line 711
        goto while_break___1;
      }
      {
#line 712
      l = k + nbas * (iv + 1);
#line 713
      strcpy((char */* __restrict  */)(atom[l].lab), (char const   */* __restrict  */)(atom[k].lab));
#line 714
      atom[l].pos[0] = atom[k].pos[0] + (*(sh + 0))[iv];
#line 715
      atom[l].pos[1] = atom[k].pos[1] + (*(sh + 1))[iv];
#line 716
      atom[l].pos[2] = atom[k].pos[2] + (*(sh + 2))[iv];
#line 717
      atom[l].pol[0] = atom[k].pol[0];
#line 718
      atom[l].pol[1] = atom[k].pol[1];
#line 719
      atom[l].pol[2] = atom[k].pol[2];
#line 711
      k ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 710
    iv ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 723
  fr = nframe - 1;
  {
#line 723
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 723
    if (! (fr >= 0)) {
#line 723
      goto while_break___2;
    }
#line 724
    k = 0;
    {
#line 724
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 724
      if (! (k < nbas)) {
#line 724
        goto while_break___3;
      }
#line 725
      nn = fr * nbas + k;
#line 726
      nn1 = fr * nbas1 + k;
#line 727
      frame[0][nn1] = frame[0][nn];
#line 728
      frame[1][nn1] = frame[1][nn];
#line 729
      frame[2][nn1] = frame[2][nn];
#line 730
      iv = 0;
      {
#line 730
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 730
        if (! (iv < ndup)) {
#line 730
          goto while_break___4;
        }
#line 731
        nn1 += nbas;
#line 732
        frame[0][nn1] = frame[0][nn] + (*(sh + 0))[iv];
#line 733
        frame[1][nn1] = frame[1][nn] + (*(sh + 1))[iv];
#line 734
        frame[2][nn1] = frame[2][nn] + (*(sh + 2))[iv];
#line 730
        iv ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 724
      k ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 723
    fr --;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 739
  sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"Increased from %d to %d atoms",
          nbas, nbas1);
#line 740
  nbas = nbas1;
  }
#line 741
  return (1);
}
}
#line 745 "/home/june/repo/benchmarks/collector2/temp/xbs-0/subs.h"
int cut_atoms(float *cut , float cut1 , float cut2 , int helpme ) 
{ 
  int i ;
  int j ;
  int nbas1 ;
  int fr ;
  int nn ;
  int nn1 ;
  float c2 ;
  float s ;
  float fuzz ;
  int ip[2000] ;

  {
#line 753
  if (helpme) {
    {
#line 754
    sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"Usage: cut vx vy vz a b  - cut along vector at a and b");
    }
#line 755
    return (0);
  }
#line 758
  fuzz = (float )0.001;
#line 759
  c2 = (*(cut + 0) * *(cut + 0) + *(cut + 1) * *(cut + 1)) + *(cut + 2) * *(cut + 2);
#line 760
  if ((double )c2 < 0.01) {
    {
#line 761
    sprintf((char */* __restrict  */)(emsg), (char const   */* __restrict  */)"cut: invalid vector (%.2f,%.2f,%.2f)",
            (double )*(cut + 0), (double )*(cut + 1), (double )*(cut + 2), (double )cut1,
            (double )cut2);
    }
#line 763
    return (0);
  }
#line 766
  nbas1 = 0;
#line 767
  i = 0;
  {
#line 767
  while (1) {
    while_continue: /* CIL Label */ ;
#line 767
    if (! (i < nbas)) {
#line 767
      goto while_break;
    }
#line 768
    s = (atom[i].pos[0] * *(cut + 0) + atom[i].pos[1] * *(cut + 1)) + atom[i].pos[2] * *(cut + 2);
#line 769
    if (c2 * cut1 - fuzz < s) {
#line 769
      if (s < c2 * cut2 + fuzz) {
#line 770
        ip[nbas1] = i;
#line 771
        nbas1 ++;
      }
    }
#line 767
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 774
  if (nbas1 == nbas) {
    {
#line 775
    sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"No atoms were cut");
    }
#line 776
    return (0);
  }
#line 779
  i = 0;
  {
#line 779
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 779
    if (! (i < nbas1)) {
#line 779
      goto while_break___0;
    }
    {
#line 780
    j = ip[i];
#line 781
    atom[i].pos[0] = atom[j].pos[0];
#line 782
    atom[i].pos[1] = atom[j].pos[1];
#line 783
    atom[i].pos[2] = atom[j].pos[2];
#line 784
    atom[i].pol[0] = atom[j].pol[0];
#line 785
    atom[i].pol[1] = atom[j].pol[1];
#line 786
    atom[i].pol[2] = atom[j].pol[2];
#line 787
    strcpy((char */* __restrict  */)(atom[i].lab), (char const   */* __restrict  */)(atom[j].lab));
#line 779
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 790
  fr = 0;
  {
#line 790
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 790
    if (! (fr < nframe)) {
#line 790
      goto while_break___1;
    }
#line 791
    i = 0;
    {
#line 791
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 791
      if (! (i < nbas1)) {
#line 791
        goto while_break___2;
      }
#line 792
      j = ip[i];
#line 793
      nn = fr * nbas + j;
#line 794
      nn1 = fr * nbas1 + i;
#line 795
      frame[0][nn1] = frame[0][nn];
#line 796
      frame[1][nn1] = frame[1][nn];
#line 797
      frame[2][nn1] = frame[2][nn];
#line 791
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 790
    fr ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 801
  sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"Reduced from %d to %d atoms",
          nbas, nbas1);
#line 802
  nbas = nbas1;
  }
#line 803
  return (1);
}
}
#line 811 "/home/june/repo/benchmarks/collector2/temp/xbs-0/subs.h"
int selectbonds(int natom___0 , struct ballstr *ball___0 , float blen , float rad ,
                float gray , struct stickstr *stick___0 ) 
{ 
  int i ;
  int k ;
  int l ;
  int m ;
  int nbond___0 ;
  float dis ;
  float dd ;
  double tmp ;

  {
#line 817
  i = -1;
#line 818
  k = 0;
  {
#line 818
  while (1) {
    while_continue: /* CIL Label */ ;
#line 818
    if (! (k < natom___0)) {
#line 818
      goto while_break;
    }
#line 819
    l = k + 1;
    {
#line 819
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 819
      if (! (l < natom___0)) {
#line 819
        goto while_break___0;
      }
#line 820
      dis = (float )0.0;
#line 821
      m = 0;
      {
#line 821
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 821
        if (! (m < 3)) {
#line 821
          goto while_break___1;
        }
#line 822
        dd = (ball___0 + k)->pos[m] - (ball___0 + l)->pos[m];
#line 823
        dis += dd * dd;
#line 821
        m ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 825
      tmp = sqrt((double )dis);
#line 825
      dis = (float )tmp;
      }
#line 826
      if (dis <= blen) {
#line 827
        i ++;
#line 828
        (stick___0 + i)->start = k;
#line 829
        (stick___0 + i)->end = l;
#line 830
        (stick___0 + i)->rad = rad;
#line 831
        (stick___0 + i)->gray = gray;
      }
#line 819
      l ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 818
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 835
  printf((char const   */* __restrict  */)"bond   start  end    radius    gray\n");
#line 836
  nbond___0 = i + 1;
#line 837
  i = 0;
  }
  {
#line 837
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 837
    if (! (i < nbond___0)) {
#line 837
      goto while_break___2;
    }
    {
#line 838
    printf((char const   */* __restrict  */)"%3d    %3d   %3d    %7.3f  %6.2f\n",
           i + 1, (stick___0 + i)->start + 1, (stick___0 + i)->end + 1, (double )(stick___0 + i)->rad,
           (double )(stick___0 + i)->gray);
#line 837
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 841
  return (nbond___0);
}
}
#line 846 "/home/june/repo/benchmarks/collector2/temp/xbs-0/subs.h"
void rotmat(int ixyz , float alfa ) 
{ 
  int i ;
  int j ;
  int k ;
  float rot[3][3] ;
  float w[3][3] ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;

  {
  {
#line 852
  if (ixyz == 3) {
#line 852
    goto case_3;
  }
#line 857
  if (ixyz == 1) {
#line 857
    goto case_1;
  }
#line 862
  if (ixyz == 2) {
#line 862
    goto case_2;
  }
#line 867
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 853
  tmp = cos((double )alfa);
#line 853
  rot[0][0] = (float )tmp;
#line 853
  tmp___0 = sin((double )alfa);
#line 853
  rot[0][1] = (float )(- tmp___0);
#line 853
  rot[0][2] = (float )0.0;
#line 854
  tmp___1 = sin((double )alfa);
#line 854
  rot[1][0] = (float )tmp___1;
#line 854
  tmp___2 = cos((double )alfa);
#line 854
  rot[1][1] = (float )tmp___2;
#line 854
  rot[1][2] = (float )0.0;
#line 855
  rot[2][0] = (float )0.0;
#line 855
  rot[2][1] = (float )0.0;
#line 855
  rot[2][2] = (float )1.0;
  }
#line 856
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 858
  tmp___3 = cos((double )alfa);
#line 858
  rot[0][0] = (float )tmp___3;
#line 858
  rot[0][1] = (float )0.0;
#line 858
  tmp___4 = sin((double )alfa);
#line 858
  rot[0][2] = (float )tmp___4;
#line 859
  rot[1][0] = (float )0.0;
#line 859
  rot[1][1] = (float )1.0;
#line 859
  rot[1][2] = (float )0.0;
#line 860
  tmp___5 = sin((double )alfa);
#line 860
  rot[2][0] = (float )(- tmp___5);
#line 860
  rot[2][1] = (float )0.0;
#line 860
  tmp___6 = cos((double )alfa);
#line 860
  rot[2][2] = (float )tmp___6;
  }
#line 861
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 863
  rot[0][0] = (float )1.0;
#line 863
  rot[0][1] = (float )0.0;
#line 863
  rot[0][2] = (float )0.0;
#line 864
  rot[1][0] = (float )0.0;
#line 864
  tmp___7 = cos((double )alfa);
#line 864
  rot[1][1] = (float )tmp___7;
#line 864
  tmp___8 = sin((double )alfa);
#line 864
  rot[1][2] = (float )(- tmp___8);
#line 865
  rot[2][0] = (float )0.0;
#line 865
  tmp___9 = sin((double )alfa);
#line 865
  rot[2][1] = (float )tmp___9;
#line 865
  tmp___10 = cos((double )alfa);
#line 865
  rot[2][2] = (float )tmp___10;
  }
#line 866
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 868
  return;
  switch_break: /* CIL Label */ ;
  }
#line 871
  i = 0;
  {
#line 871
  while (1) {
    while_continue: /* CIL Label */ ;
#line 871
    if (! (i < 3)) {
#line 871
      goto while_break;
    }
#line 871
    j = 0;
    {
#line 871
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 871
      if (! (j < 3)) {
#line 871
        goto while_break___0;
      }
#line 872
      w[i][j] = (float )0.0;
#line 873
      k = 0;
      {
#line 873
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 873
        if (! (k < 3)) {
#line 873
          goto while_break___1;
        }
#line 873
        w[i][j] += rot[i][k] * tmat[k][j];
#line 873
        k ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 871
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 871
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 876
  i = 0;
  {
#line 876
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 876
    if (! (i < 3)) {
#line 876
      goto while_break___2;
    }
#line 876
    j = 0;
    {
#line 876
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 876
      if (! (j < 3)) {
#line 876
        goto while_break___3;
      }
#line 876
      tmat[i][j] = w[i][j];
#line 876
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 876
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 877
  return;
}
}
#line 880 "/home/june/repo/benchmarks/collector2/temp/xbs-0/subs.h"
void eumat(float alfa , float beta , float gama ) 
{ 
  int i ;
  int j ;
  int k ;
  float gam[3][3] ;
  float bet[3][3] ;
  float alf[3][3] ;
  float w[3][3] ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;

  {
  {
#line 886
  gam[0][0] = (float )1.0;
#line 886
  gam[0][1] = (float )0.0;
#line 886
  gam[0][2] = (float )0.0;
#line 887
  gam[1][0] = (float )0.0;
#line 887
  tmp = cos((double )gama);
#line 887
  gam[1][1] = (float )tmp;
#line 887
  tmp___0 = sin((double )gama);
#line 887
  gam[1][2] = (float )(- tmp___0);
#line 888
  gam[2][0] = (float )0.0;
#line 888
  tmp___1 = sin((double )gama);
#line 888
  gam[2][1] = (float )tmp___1;
#line 888
  gam[2][2] = (float )1.0;
#line 890
  tmp___2 = cos((double )beta);
#line 890
  bet[0][0] = (float )tmp___2;
#line 890
  bet[0][1] = (float )0.0;
#line 890
  tmp___3 = sin((double )beta);
#line 890
  bet[0][2] = (float )tmp___3;
#line 891
  bet[1][0] = (float )0.0;
#line 891
  bet[1][1] = (float )1.0;
#line 891
  bet[1][2] = (float )0.0;
#line 892
  tmp___4 = sin((double )beta);
#line 892
  bet[2][0] = (float )(- tmp___4);
#line 892
  bet[2][1] = (float )0.0;
#line 892
  tmp___5 = cos((double )beta);
#line 892
  bet[2][2] = (float )tmp___5;
#line 894
  tmp___6 = cos((double )alfa);
#line 894
  alf[0][0] = (float )tmp___6;
#line 894
  tmp___7 = sin((double )alfa);
#line 894
  alf[0][1] = (float )(- tmp___7);
#line 894
  alf[0][2] = (float )0.0;
#line 895
  tmp___8 = sin((double )alfa);
#line 895
  alf[1][0] = (float )tmp___8;
#line 895
  tmp___9 = cos((double )alfa);
#line 895
  alf[1][1] = (float )tmp___9;
#line 895
  alf[1][2] = (float )0.0;
#line 896
  alf[2][0] = (float )0.0;
#line 896
  alf[2][1] = (float )0.0;
#line 896
  alf[2][2] = (float )1.0;
#line 898
  i = 0;
  }
  {
#line 898
  while (1) {
    while_continue: /* CIL Label */ ;
#line 898
    if (! (i < 3)) {
#line 898
      goto while_break;
    }
#line 898
    j = 0;
    {
#line 898
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 898
      if (! (j < 3)) {
#line 898
        goto while_break___0;
      }
#line 899
      w[i][j] = (float )0.0;
#line 900
      k = 0;
      {
#line 900
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 900
        if (! (k < 3)) {
#line 900
          goto while_break___1;
        }
#line 900
        w[i][j] += bet[i][k] * alf[k][j];
#line 900
        k ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 898
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 898
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 903
  i = 0;
  {
#line 903
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 903
    if (! (i < 3)) {
#line 903
      goto while_break___2;
    }
#line 903
    j = 0;
    {
#line 903
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 903
      if (! (j < 3)) {
#line 903
        goto while_break___3;
      }
#line 904
      tmat[i][j] = (float )0.0;
#line 905
      k = 0;
      {
#line 905
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 905
        if (! (k < 3)) {
#line 905
          goto while_break___4;
        }
#line 905
        tmat[i][j] += gam[i][k] * w[k][j];
#line 905
        k ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 903
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 903
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 907
  return;
}
}
#line 911 "/home/june/repo/benchmarks/collector2/temp/xbs-0/subs.h"
void dbond(float gray , float *m1 , float *m2 ) 
{ 
  float dfac ;
  float rfac ;
  float r ;
  float ax ;
  float ay ;
  float bx ;
  float by ;
  float a1 ;
  float b1 ;
  float dx ;
  float dy ;
  float alf ;
  float d1 ;
  float bb ;
  float x ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;

  {
  {
#line 913
  dfac = (float )0.8;
#line 914
  rfac = (float )2.0;
#line 918
  *(m2 + 4) = dfac * *(m2 + 4) + ((float )1 - dfac) * *(m1 + 4);
#line 919
  *(m2 + 5) = dfac * *(m2 + 5) + ((float )1 - dfac) * *(m1 + 5);
#line 921
  ax = *(m2 + 0);
#line 922
  ay = *(m2 + 1);
#line 923
  bx = *(m2 + 2);
#line 924
  by = *(m2 + 3);
#line 926
  tmp = sqrt((double )(bx * bx + by * by));
#line 926
  b1 = (float )tmp;
#line 927
  tmp___0 = sqrt((double )(ax * ax + ay * ay));
#line 927
  a1 = (float )tmp___0;
#line 928
  r = rfac * b1;
#line 929
  *(m2 + 0) = (- r * ax) / a1;
#line 930
  *(m2 + 1) = (- r * ay) / a1;
#line 931
  *(m2 + 2) = (r * bx) / b1;
#line 932
  *(m2 + 3) = (r * by) / b1;
#line 934
  dx = *(m2 + 4) - *(m1 + 4);
#line 935
  dy = *(m2 + 5) - *(m1 + 5);
  }
#line 937
  if (*(m2 + 0) * dx < (float )0) {
#line 937
    goto _L;
  } else
#line 937
  if (*(m2 + 1) * dy < (float )0) {
    _L: /* CIL Label */ 
#line 938
    *(m1 + 0) = - *(m1 + 0);
#line 938
    *(m1 + 1) = - *(m1 + 1);
#line 938
    *(m1 + 2) = - *(m1 + 2);
#line 938
    *(m1 + 3) = - *(m1 + 3);
#line 939
    *(m2 + 0) = - *(m2 + 0);
#line 939
    *(m2 + 1) = - *(m2 + 1);
#line 939
    *(m2 + 2) = - *(m2 + 2);
#line 939
    *(m2 + 3) = - *(m2 + 3);
  }
  {
#line 942
  tmp___1 = sqrt((double )(dx * dx + dy * dy));
#line 942
  d1 = (float )tmp___1;
#line 943
  tmp___2 = sqrt((double )(*(m1 + 2) * *(m1 + 2) + *(m1 + 3) * *(m1 + 3)));
#line 943
  bb = (float )tmp___2;
  }
#line 944
  if (r - bb < d1) {
    {
#line 945
    x = (bb * d1) / (r - bb);
#line 946
    tmp___3 = asin((double )(bb / x));
#line 946
    alf = (float )(tmp___3 * 57.3);
    }
#line 947
    if (hardcopy) {
      {
#line 948
      hardcopy_xdbond(gray, m1, m2, alf);
      }
    } else {
      {
#line 950
      printf((char const   */* __restrict  */)"PSWxdbond.. not changed yet\n");
      }
    }
  } else
#line 954
  if (hardcopy) {
    {
#line 955
    hardcopy_ydbond(gray, m1, m2, alf);
    }
  } else {
    {
#line 957
    printf((char const   */* __restrict  */)"PSWydbond.. not changed yet\n");
    }
  }
#line 960
  return;
}
}
#line 964 "/home/june/repo/benchmarks/collector2/temp/xbs-0/subs.h"
void getframe(struct ballstr *ball___0 , int fnum ) 
{ 
  register int m ;
  register int n ;
  register int nn ;
  float sum ;

  {
#line 969
  if (recenter) {
#line 970
    m = 0;
    {
#line 970
    while (1) {
      while_continue: /* CIL Label */ ;
#line 970
      if (! (m < 3)) {
#line 970
        goto while_break;
      }
#line 971
      sum = (float )0.0;
#line 972
      n = 0;
      {
#line 972
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 972
        if (! (n < nbas)) {
#line 972
          goto while_break___0;
        }
#line 973
        nn = fnum * nbas + n;
#line 974
        sum += frame[m][nn];
#line 972
        n ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 976
      center[m] = sum / (float )nbas;
#line 970
      m ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 980
  n = 0;
  {
#line 980
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 980
    if (! (n < nbas)) {
#line 980
      goto while_break___1;
    }
#line 981
    nn = fnum * nbas + n;
#line 982
    (ball___0 + n)->pos[0] = frame[0][nn] - center[0];
#line 983
    (ball___0 + n)->pos[1] = frame[1][nn] - center[1];
#line 984
    (ball___0 + n)->pos[2] = frame[2][nn] - center[2];
#line 980
    n ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 986
  return;
}
}
#line 990 "/home/june/repo/benchmarks/collector2/temp/xbs-0/subs.h"
void putframe(struct ballstr *ball___0 , int fnum ) 
{ 
  int n ;
  int nn ;

  {
#line 993
  n = 0;
  {
#line 993
  while (1) {
    while_continue: /* CIL Label */ ;
#line 993
    if (! (n < nbas)) {
#line 993
      goto while_break;
    }
#line 994
    nn = fnum * nbas + n;
#line 995
    frame[0][nn] = (ball___0 + n)->pos[0];
#line 996
    frame[1][nn] = (ball___0 + n)->pos[1];
#line 997
    frame[2][nn] = (ball___0 + n)->pos[2];
#line 993
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 999
  return;
}
}
#line 1003 "/home/june/repo/benchmarks/collector2/temp/xbs-0/subs.h"
void prframes(void) 
{ 


  {
  {
#line 1005
  printf((char const   */* __restrict  */)"Number of frames: %d\n", nframe);
#line 1006
  printf((char const   */* __restrict  */)"frame %-5d <%s>\n", 1, frstr[0]);
  }
#line 1007
  if (nframe > 1) {
    {
#line 1007
    printf((char const   */* __restrict  */)"frame %-5d <%s>\n", 2, frstr[1]);
    }
  }
#line 1008
  if (nframe > 2) {
    {
#line 1008
    printf((char const   */* __restrict  */)"frame %-5d <%s>\n", nframe, frstr[nframe - 1]);
    }
  }
#line 1010
  return;
}
}
#line 1014 "/home/june/repo/benchmarks/collector2/temp/xbs-0/subs.h"
void draw_lines(int dash ) 
{ 
  float p___0[3] ;
  float q[3] ;
  float fac ;
  float zp1[2] ;
  float zp2[2] ;
  float r0 ;
  int n ;
  int m ;

  {
#line 1020
  fac = scale;
#line 1022
  n = 0;
  {
#line 1022
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1022
    if (! (n < nxline)) {
#line 1022
      goto while_break;
    }
#line 1024
    m = 0;
    {
#line 1024
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1024
      if (! (m < 3)) {
#line 1024
        goto while_break___0;
      }
#line 1025
      p___0[m] = (tmat[m][0] * (xline[n].a[0] - center[0]) + tmat[m][1] * (xline[n].a[1] - center[1])) + tmat[m][2] * (xline[n].a[2] - center[2]);
#line 1029
      q[m] = (tmat[m][0] * (xline[n].b[0] - center[0]) + tmat[m][1] * (xline[n].b[1] - center[1])) + tmat[m][2] * (xline[n].b[2] - center[2]);
#line 1024
      m ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1034
    atompos(fac, (float *)(p___0), (float )1.0, (float *)(zp1), & r0);
#line 1035
    atompos(fac, (float *)(q), (float )1.0, (float *)(zp2), & r0);
    }
#line 1037
    if (hardcopy) {
      {
#line 1038
      hardcopy_line(zp1[0] + taux, zp1[1] + tauy, zp2[0] + taux, zp2[1] + tauy, dash);
      }
    } else
#line 1041
    if (dash) {
      {
#line 1042
      DrawLine(zp1[0] + taux, zp1[1] + tauy, zp2[0] + taux, zp2[1] + tauy, lngc);
      }
    } else {
      {
#line 1044
      DrawLine(zp1[0] + taux, zp1[1] + tauy, zp2[0] + taux, zp2[1] + tauy, gc);
      }
    }
#line 1022
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1048
  return;
}
}
#line 1052 "/home/june/repo/benchmarks/collector2/temp/xbs-0/subs.h"
void draw_axes(void) 
{ 
  float e0[3] ;
  float e1[3] ;
  float e2[3] ;
  float z0[2] ;
  float z1[2] ;
  float z2[2] ;
  float fac ;
  float r0 ;
  float r1 ;
  float r2 ;
  float tx ;
  float ty ;
  float zz[3] ;
  int m ;
  int i ;
  int i0 ;

  {
#line 1058
  tx = (float )((double )(70 - midx) / 1.42);
#line 1059
  ty = (float )((double )(- ((igh - 120) - midy)) / 1.42);
#line 1060
  fac = (float )30;
#line 1062
  m = 0;
  {
#line 1062
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1062
    if (! (m < 3)) {
#line 1062
      goto while_break;
    }
#line 1063
    e0[m] = tmat[m][0];
#line 1064
    e1[m] = tmat[m][1];
#line 1065
    e2[m] = tmat[m][2];
#line 1062
    m ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1068
  atompos(fac, (float *)(e0), (float )1.0, (float *)(z0), & r0);
#line 1069
  atompos(fac, (float *)(e1), (float )1.0, (float *)(z1), & r1);
#line 1070
  atompos(fac, (float *)(e2), (float )1.0, (float *)(z2), & r2);
#line 1073
  zz[0] = e0[2];
#line 1074
  zz[1] = e1[2];
#line 1075
  zz[2] = e2[2];
#line 1077
  i = 0;
  }
  {
#line 1077
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1077
    if (! (i < 3)) {
#line 1077
      goto while_break___0;
    }
#line 1078
    i0 = 0;
#line 1079
    if (zz[1] < zz[i0]) {
#line 1079
      i0 = 1;
    }
#line 1080
    if (zz[2] < zz[i0]) {
#line 1080
      i0 = 2;
    }
#line 1081
    if (i0 == 0) {
      {
#line 1081
      DrawArrow(tx, ty, z0[0] + tx, z0[1] + ty, r0, (char *)"100");
      }
    }
#line 1082
    if (i0 == 1) {
      {
#line 1082
      DrawArrow(tx, ty, z1[0] + tx, z1[1] + ty, r1, (char *)"010");
      }
    }
#line 1083
    if (i0 == 2) {
      {
#line 1083
      DrawArrow(tx, ty, z2[0] + tx, z2[1] + ty, r2, (char *)"001");
      }
    }
#line 1084
    zz[i0] = (float )1e10;
#line 1077
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1087
  return;
}
}
#line 1090 "/home/june/repo/benchmarks/collector2/temp/xbs-0/subs.h"
void bs_transform(int natom___0 , struct ballstr *ball___0 ) 
{ 
  register int m ;
  register int n ;

  {
#line 1094
  n = 0;
  {
#line 1094
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1094
    if (! (n < natom___0)) {
#line 1094
      goto while_break;
    }
#line 1095
    m = 0;
    {
#line 1095
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1095
      if (! (m < 3)) {
#line 1095
        goto while_break___0;
      }
#line 1096
      p[n][m] = (tmat[m][0] * (ball___0 + n)->pos[0] + tmat[m][1] * (ball___0 + n)->pos[1]) + tmat[m][2] * (ball___0 + n)->pos[2];
#line 1095
      m ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1094
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1100
  return;
}
}
#line 1103 "/home/june/repo/benchmarks/collector2/temp/xbs-0/subs.h"
void bs_kernel(int natom___0 , struct ballstr *ball___0 , int nbond___0 , struct stickstr *stick___0 ) 
{ 
  int flag[2000] ;
  int ip[2000] ;
  int j ;
  int k ;
  int kk ;
  int m ;
  int n ;
  int ibot ;
  float br ;
  float xx ;
  float bx ;
  float by ;
  float rk ;
  float rkk ;
  float th1 ;
  float th2 ;
  float cth1 ;
  float cth2 ;
  float sth1 ;
  float sth2 ;
  float w ;
  float ww ;
  float bb ;
  float aa ;
  float crit1 ;
  float crit2 ;
  float fac ;
  float beta ;
  float gray ;
  char label[81] ;
  int ib ;
  int note ;
  float zp[2000][2] ;
  float zr[2000] ;
  float q1[3] ;
  float q2[3] ;
  float b[3] ;
  float d[3] ;
  float bot ;
  float big ;
  float fudgefac ;
  float bmidx ;
  float bmidy ;
  float dd ;
  float m1[6] ;
  float m2[6] ;
  int nbx ;
  int ibx ;
  int jbx ;
  int kbx[100] ;
  int abx[100] ;
  int pbx[100] ;
  int fbx[100] ;
  double tmp ;
  double tmp___0 ;
  float tmp___1 ;
  float tmp___2 ;
  float tmp___3 ;
  double tmp___4 ;
  float tmp___5 ;
  float tmp___6 ;
  float tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  double tmp___13 ;
  double tmp___14 ;
  double tmp___15 ;
  double tmp___16 ;
  double tmp___17 ;
  double tmp___18 ;
  double tmp___19 ;

  {
#line 1113
  fudgefac = (float )0.6;
#line 1116
  dist = dist0;
#line 1117
  if (pmode == 0) {
#line 1117
    dist = (float )10000.0;
  } else
#line 1117
  if (pmode == 1) {
#line 1117
    dist = (float )10000.0;
  }
#line 1118
  d[0] = (float )0.0;
#line 1118
  d[1] = (float )0.0;
#line 1118
  d[2] = dist;
#line 1119
  fac = scale;
#line 1122
  k = 0;
  {
#line 1122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1122
    if (! (k < natom___0)) {
#line 1122
      goto while_break;
    }
#line 1122
    flag[k] = 0;
#line 1122
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1123
  n = 0;
  {
#line 1123
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1123
    if (! (n < natom___0)) {
#line 1123
      goto while_break___0;
    }
#line 1124
    bot = (float )1.0e10;
#line 1124
    ibot = 0;
#line 1125
    k = 0;
    {
#line 1125
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1125
      if (! (k < natom___0)) {
#line 1125
        goto while_break___1;
      }
#line 1126
      if (p[k][2] < bot) {
#line 1126
        if (! flag[k]) {
#line 1126
          bot = p[k][2];
#line 1126
          ibot = k;
        }
      }
#line 1125
      k ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1127
    ip[n] = ibot;
#line 1127
    flag[ibot] = 1;
#line 1123
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1131
  big = (float )1000000;
#line 1131
  if (nbas == 0) {
#line 1131
    big = (float )0;
  }
#line 1132
  ybot = big;
#line 1132
  xbot = ybot;
#line 1133
  ytop = - big;
#line 1133
  xtop = ytop;
#line 1134
  k = 0;
  {
#line 1134
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1134
    if (! (k < natom___0)) {
#line 1134
      goto while_break___2;
    }
    {
#line 1135
    atompos(fac, (float *)(p[k]), (ball___0 + k)->rad, (float *)(zp[k]), & zr[k]);
#line 1136
    zr[k] = radfac * zr[k];
    }
#line 1137
    if (zp[k][0] - zr[k] < xbot) {
#line 1137
      xbot = zp[k][0] - zr[k];
    }
#line 1138
    if (zp[k][0] + zr[k] > xtop) {
#line 1138
      xtop = zp[k][0] + zr[k];
    }
#line 1139
    if (zp[k][1] - zr[k] < ybot) {
#line 1139
      ybot = zp[k][1] - zr[k];
    }
#line 1140
    if (zp[k][1] + zr[k] > ytop) {
#line 1140
      ytop = zp[k][1] + zr[k];
    }
#line 1134
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1146
  n = 0;
  {
#line 1146
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1146
    if (! (n < natom___0)) {
#line 1146
      goto while_break___3;
    }
#line 1147
    k = ip[n];
#line 1148
    rk = (ball___0 + k)->rad;
#line 1150
    if (! (ball___0 + k)->special) {
      {
#line 1151
      tmp = exp((double )((gslope * (p[k][2] - gz0)) * gslope));
#line 1151
      beta = (float )tmp;
      }
#line 1152
      if (grayvalues) {
#line 1153
        if (gmode == 1) {
#line 1154
          gray = (float )((double )(beta * (ball___0 + k)->gray) + (double )((float )1 - beta) * 0.5);
        } else {
#line 1156
          gray = (ball___0 + k)->gray;
        }
      } else {
#line 1158
        gray = (float )1.0;
      }
#line 1159
      if (hardcopy) {
        {
#line 1160
        hardcopy_ball(gray, (ball___0 + k)->r, (ball___0 + k)->g, (ball___0 + k)->b,
                      zp[k][0] + taux, zp[k][1] + tauy, zr[k]);
        }
      } else {
        {
#line 1163
        DrawBall(gray, (ball___0 + k)->col, zp[k][0] + taux, zp[k][1] + tauy, zr[k]);
        }
      }
#line 1165
      if (numbers) {
#line 1165
        goto _L;
      } else
#line 1165
      if (coords) {
        _L: /* CIL Label */ 
#line 1166
        if (numbers == 1) {
          {
#line 1166
          sprintf((char */* __restrict  */)(label), (char const   */* __restrict  */)"%d",
                  k + 1);
          }
        }
#line 1167
        if (numbers == 2) {
          {
#line 1167
          sprintf((char */* __restrict  */)(label), (char const   */* __restrict  */)"%s",
                  (ball___0 + k)->lab);
          }
        }
#line 1168
        if (coords) {
          {
#line 1169
          sprintf((char */* __restrict  */)(label), (char const   */* __restrict  */)"(%.2f,%.2f,%.2f)",
                  (double )((ball___0 + k)->pos[0] + center[0]), (double )((ball___0 + k)->pos[1] + center[1]),
                  (double )((ball___0 + k)->pos[2] + center[2]));
          }
        }
#line 1172
        if (hardcopy) {
          {
#line 1173
          hardcopy_label(zp[k][0] + taux, zp[k][1] + tauy, label);
          }
        } else {
          {
#line 1175
          LabelBG(zp[k][0] + taux, (zp[k][1] + tauy) - (float )2, (float )0.0, (float )1.0,
                  label);
          }
        }
      }
    }
#line 1180
    if (! withbonds) {
#line 1180
      goto __Cont;
    }
#line 1181
    nbx = 0;
#line 1182
    j = 0;
    {
#line 1182
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1182
      if (! (j < nbond___0)) {
#line 1182
        goto while_break___4;
      }
#line 1183
      if (k == (stick___0 + j)->start) {
#line 1184
        kbx[nbx] = j;
#line 1185
        abx[nbx] = (stick___0 + j)->end;
#line 1186
        nbx ++;
      } else
#line 1188
      if (k == (stick___0 + j)->end) {
#line 1189
        kbx[nbx] = j;
#line 1190
        abx[nbx] = (stick___0 + j)->start;
#line 1191
        nbx ++;
      }
#line 1182
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1194
    if (nbx == 0) {
#line 1194
      goto __Cont;
    }
#line 1196
    m = 0;
    {
#line 1196
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1196
      if (! (m < nbx)) {
#line 1196
        goto while_break___5;
      }
#line 1196
      fbx[m] = 0;
#line 1196
      m ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1197
    m = 0;
    {
#line 1197
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1197
      if (! (m < nbx)) {
#line 1197
        goto while_break___6;
      }
#line 1198
      bot = (float )1.0e10;
#line 1198
      ibot = 0;
#line 1199
      j = 0;
      {
#line 1199
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 1199
        if (! (j < nbx)) {
#line 1199
          goto while_break___7;
        }
#line 1200
        if (p[abx[j]][2] < bot) {
#line 1200
          if (! fbx[j]) {
#line 1200
            bot = p[abx[j]][2];
#line 1200
            ibot = j;
          }
        }
#line 1199
        j ++;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 1201
      pbx[m] = ibot;
#line 1201
      fbx[ibot] = 1;
#line 1197
      m ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 1205
    ibx = 0;
    {
#line 1205
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1205
      if (! (ibx < nbx)) {
#line 1205
        goto while_break___8;
      }
#line 1206
      jbx = pbx[ibx];
#line 1207
      kk = abx[jbx];
#line 1208
      ib = kbx[jbx];
#line 1209
      if (ib < 0) {
        {
#line 1209
        printf((char const   */* __restrict  */)"this cannot happen\n");
        }
      }
#line 1210
      rkk = (ball___0 + kk)->rad;
#line 1221
      if (ib >= 0) {
        {
#line 1222
        br = bndfac * (stick___0 + ib)->rad;
#line 1223
        bx = zp[kk][0] - zp[k][0];
#line 1224
        by = zp[kk][1] - zp[k][1];
#line 1225
        tmp___0 = sqrt((double )(bx * bx + by * by));
#line 1225
        xx = (float )tmp___0;
        }
#line 1226
        if ((double )(xx * xx) < 0.0001) {
#line 1226
          goto __Cont___0;
        }
        {
#line 1227
        bx /= xx;
#line 1228
        by /= xx;
#line 1229
        vsum((float *)(d), (float *)(p[k]), (float )1.0, (float )(- 1.0), (float *)(q1));
#line 1230
        vsum((float *)(d), (float *)(p[kk]), (float )1.0, (float )(- 1.0), (float *)(q2));
#line 1231
        vsum((float *)(p[kk]), (float *)(p[k]), (float )1.0, (float )(- 1.0), (float *)(b));
#line 1232
        tmp___1 = sp((float *)(q1), (float *)(b));
#line 1232
        tmp___2 = sp((float *)(q1), (float *)(q1));
#line 1232
        tmp___3 = sp((float *)(b), (float *)(b));
#line 1232
        tmp___4 = sqrt((double )(tmp___2 * tmp___3));
#line 1232
        cth1 = (float )((double )tmp___1 / tmp___4);
#line 1233
        tmp___5 = sp((float *)(q2), (float *)(b));
#line 1233
        tmp___6 = sp((float *)(q2), (float *)(q2));
#line 1233
        tmp___7 = sp((float *)(b), (float *)(b));
#line 1233
        tmp___8 = sqrt((double )(tmp___6 * tmp___7));
#line 1233
        cth2 = (float )((double )(- tmp___5) / tmp___8);
#line 1234
        tmp___9 = acos((double )cth1);
#line 1234
        th1 = (float )tmp___9;
#line 1235
        tmp___10 = acos((double )cth2);
#line 1235
        th2 = (float )tmp___10;
#line 1236
        tmp___11 = asin((double )(br / rk));
#line 1236
        crit1 = (float )(tmp___11 * (double )fudgefac);
        }
#line 1237
        if ((double )crit1 < 0.0) {
#line 1237
          crit1 = (float )0.0;
        }
        {
#line 1238
        tmp___12 = asin((double )(br / rkk));
#line 1238
        crit2 = (float )(tmp___12 * (double )fudgefac);
        }
#line 1239
        if ((double )crit2 < 0.0) {
#line 1239
          crit2 = (float )0.0;
        }
#line 1240
        note = 0;
#line 1241
        if ((double )th2 - 0.5 * 3.1415926 > (double )crit2) {
#line 1241
          if (k < kk) {
#line 1241
            note = 1;
          }
        }
#line 1242
        if ((double )th1 - 0.5 * 3.1415926 < (double )crit1) {
#line 1242
          if (k > kk) {
#line 1242
            note = 2;
          }
        }
#line 1247
        if (note == 1) {
#line 1247
          goto _L___0;
        } else
#line 1247
        if (note == 2) {
          _L___0: /* CIL Label */ 
          {
#line 1248
          tmp___13 = sqrt((double )(rk * rk - br * br));
#line 1248
          w = (float )tmp___13;
#line 1249
          tmp___14 = sqrt(1.0 - (double )(cth1 * cth1));
#line 1249
          sth1 = (float )tmp___14;
#line 1250
          ww = ((w * sth1) * zr[k]) / rk;
#line 1251
          bb = (br * zr[k]) / rk;
#line 1252
          aa = ((br * cth1) * zr[k]) / rk;
#line 1253
          m1[0] = bx * aa;
#line 1253
          m1[1] = by * aa;
#line 1254
          m1[2] = - by * bb;
#line 1254
          m1[3] = bx * bb;
#line 1255
          m1[4] = (zp[k][0] + bx * ww) + taux;
#line 1256
          m1[5] = (zp[k][1] + by * ww) + tauy;
#line 1257
          tmp___15 = sqrt((double )(rkk * rkk - br * br));
#line 1257
          w = (float )tmp___15;
#line 1258
          tmp___16 = sqrt(1.0 - (double )(cth2 * cth2));
#line 1258
          sth2 = (float )tmp___16;
#line 1259
          ww = ((w * sth2) * zr[kk]) / rkk;
#line 1260
          bb = (br * zr[kk]) / rkk;
#line 1261
          aa = ((br * cth2) * zr[kk]) / rkk;
#line 1262
          m2[0] = bx * aa;
#line 1262
          m2[1] = by * aa;
#line 1263
          m2[2] = - by * bb;
#line 1263
          m2[3] = bx * bb;
#line 1264
          m2[4] = (zp[kk][0] - bx * ww) + taux;
#line 1265
          m2[5] = (zp[kk][1] - by * ww) + tauy;
#line 1267
          tmp___17 = exp(((double )gslope * (0.5 * (double )(p[k][2] + p[kk][2]) - (double )gz0)) * (double )gslope);
#line 1267
          beta = (float )tmp___17;
          }
#line 1268
          if (grayvalues) {
#line 1269
            if (gmode == 0) {
#line 1270
              gray = (stick___0 + ib)->gray;
            } else
#line 1271
            if (gmode == 2) {
#line 1272
              gray = (float )(0.5 * (double )((ball___0 + k)->gray + (ball___0 + kk)->gray));
            } else
#line 1273
            if (gmode == 1) {
#line 1274
              gray = (float )((double )(beta * (stick___0 + ib)->gray) + (double )((float )1 - beta) * 0.5);
            }
          } else {
#line 1276
            gray = (float )1.0;
          }
#line 1278
          if (grayvalues) {
#line 1278
            if (bline) {
#line 1278
              if ((double )gray > 0.7) {
#line 1278
                gray = (float )0.7;
              }
            }
          }
#line 1279
          if (! grayvalues) {
#line 1279
            if (bline) {
#line 1279
              gray = (float )0.0;
            }
          }
#line 1280
          if (grayvalues) {
#line 1280
            if (wire) {
#line 1280
              gray = (float )0.0;
            }
          }
#line 1281
          if (bline) {
#line 1281
            gray = (float )0.0;
          }
#line 1282
          if ((ball___0 + k)->special) {
            {
#line 1283
            dbond((float )1.0, (float *)(m2), (float *)(m1));
            }
          } else
#line 1284
          if ((ball___0 + kk)->special) {
            {
#line 1285
            dbond((float )1.0, (float *)(m1), (float *)(m2));
            }
          } else
#line 1287
          if (hardcopy) {
            {
#line 1288
            hardcopy_stick(gray, (float *)(m1), (float *)(m2));
            }
          } else {
            {
#line 1291
            DrawStick(gray, (stick___0 + ib)->col, (float *)(m1), (float *)(m2));
            }
          }
#line 1295
          if (bondnums) {
#line 1296
            bmidx = (float )(0.5 * (double )(zp[k][0] + zp[kk][0]) + (double )taux);
#line 1297
            bmidy = (float )(0.5 * (double )(zp[k][1] + zp[kk][1]) + (double )tauy);
#line 1298
            dd = (float )0;
#line 1299
            m = 0;
            {
#line 1299
            while (1) {
              while_continue___9: /* CIL Label */ ;
#line 1299
              if (! (m < 3)) {
#line 1299
                goto while_break___9;
              }
              {
#line 1300
              tmp___18 = pow((double )((ball___0 + k)->pos[m] - (ball___0 + kk)->pos[m]),
                             (double )2);
#line 1300
              dd = (float )((double )dd + tmp___18);
#line 1299
              m ++;
              }
            }
            while_break___9: /* CIL Label */ ;
            }
            {
#line 1301
            tmp___19 = sqrt((double )dd);
#line 1301
            dd = (float )tmp___19;
#line 1302
            sprintf((char */* __restrict  */)(label), (char const   */* __restrict  */)"%.2f",
                    (double )dd);
            }
#line 1303
            if (hardcopy) {
              {
#line 1304
              hardcopy_label(bmidx, bmidy, label);
              }
            } else {
              {
#line 1306
              LabelBG(bmidx, bmidy, (float )0.0, (float )1.0, label);
              }
            }
          }
        }
      }
      __Cont___0: /* CIL Label */ 
#line 1205
      ibx ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 1146
    n ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1314
  if (showaxes) {
    {
#line 1314
    draw_axes();
    }
  }
#line 1316
  if (showlines == 1) {
    {
#line 1316
    draw_lines(0);
    }
  }
#line 1317
  if (showlines == 2) {
    {
#line 1317
    draw_lines(1);
    }
  }
#line 1319
  return;
}
}
#line 185 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int do_ConfigureNotify(XEvent *eventp ) 
{ 
  XConfigureEvent *e ;
  int mmx ;
  int mmy ;
  int h1 ;
  int w1 ;

  {
#line 188
  e = (XConfigureEvent *)eventp;
#line 196
  mmx = midx;
#line 197
  mmy = midy;
#line 198
  w1 = igw;
#line 199
  h1 = igh;
#line 201
  if (e->height != igh) {
#line 201
    goto _L;
  } else
#line 201
  if (e->width != igw) {
    _L: /* CIL Label */ 
    {
#line 202
    igw = e->width;
#line 203
    igh = e->height;
#line 204
    midx = igw / 2;
#line 205
    midy = igh / 2 - 20;
#line 208
    XCopyArea(dpy, bgrmap, pixmap, gc, 0, 0, (unsigned int )w1, (unsigned int )h1,
              0, 0);
#line 209
    XFreePixmap(dpy, bgrmap);
#line 210
    bgrmap = XCreatePixmap(dpy, win, (unsigned int )igw, (unsigned int )igh, (unsigned int )depth);
#line 211
    XFillRectangle(dpy, bgrmap, gcbg, 0, 0, (unsigned int )igw, (unsigned int )igh);
#line 212
    XCopyArea(dpy, pixmap, bgrmap, gc, 0, 0, (unsigned int )w1, (unsigned int )h1,
              0, 0);
#line 213
    XFreePixmap(dpy, pixmap);
#line 214
    pixmap = XCreatePixmap(dpy, win, (unsigned int )igw, (unsigned int )igh, (unsigned int )depth);
    }
#line 216
    if (num_print == 0) {
#line 217
      taux0 = (float )0;
#line 217
      taux = taux0;
#line 218
      tauy0 = (float )0;
#line 218
      tauy = tauy0;
    } else {
#line 221
      taux = (float )((double )taux - (double )(midx - mmx) / 1.42);
#line 222
      taux0 = (float )((double )taux0 - (double )(midx - mmx) / 1.42);
#line 223
      tauy = (float )((double )tauy - (double )(((midy - mmy) - igh) + h1) / 1.42);
#line 224
      tauy0 = (float )((double )tauy0 - (double )(((midy - mmy) - igh) + h1) / 1.42);
    }
#line 227
    return (1);
  } else {
#line 230
    return (0);
  }
}
}
#line 235 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int close_print(int helpme ) 
{ 


  {
#line 239
  if (helpme) {
    {
#line 240
    sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"Usage: close  - close current print file");
    }
#line 241
    return (0);
  }
#line 244
  if (num_print == 0) {
    {
#line 245
    sprintf((char */* __restrict  */)(emsg), (char const   */* __restrict  */)"close: no print file is open");
    }
#line 246
    return;
  }
  {
#line 249
  hardcopy_close();
#line 250
  XFillRectangle(dpy, bgrmap, gcbg, 0, 0, (unsigned int )igw, (unsigned int )igh);
#line 251
  num_print = 0;
  }
#line 252
  return (0);
}
}
#line 256 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int handle_print(char *msg1 , char *msg2 , int helpme ) 
{ 
  char xx[81] ;
  float x ;
  float y ;
  int ix ;
  int iy ;
  int dd ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;

  {
#line 265
  if (helpme) {
    {
#line 266
    sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"Usage: print [-T] [-t title] [file]  - print to PS file");
    }
#line 267
    return (0);
  }
  {
#line 270
  sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"Print:");
  }
#line 271
  if (num_print > 0) {
    {
#line 271
    tmp = strcmp((char const   *)(prf), (char const   *)(prfsave));
    }
#line 271
    if (tmp) {
      {
#line 272
      close_print(0);
#line 273
      sprintf((char */* __restrict  */)(xx), (char const   */* __restrict  */)" %s closed,",
              prfsave);
#line 274
      strcat((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)(xx));
#line 275
      replot = 1;
      }
    }
  }
#line 278
  if (num_print == 0) {
    {
#line 279
    hardcopy_init(prf);
#line 280
    sprintf((char */* __restrict  */)(xx), (char const   */* __restrict  */)" %s opened,",
            prf);
#line 281
    strcat((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)(xx));
#line 282
    pr_xoff = (float )0;
#line 283
    pr_yoff = ybot - (float )15;
    }
  } else {
    {
#line 285
    hardcopy_redefine();
    }
  }
  {
#line 287
  num_print ++;
#line 288
  strcpy((char */* __restrict  */)(prfsave), (char const   */* __restrict  */)(prf));
#line 289
  hardcopy = 1;
#line 290
  bs_transform(natom, ball);
#line 291
  bs_kernel(natom, ball, nbond, stick);
#line 292
  hardcopy = 0;
#line 293
  drw = bgrmap;
#line 294
  bs_kernel(natom, ball, nbond, stick);
#line 296
  tmp___3 = strlen((char const   *)msg1);
  }
#line 296
  if (tmp___3 > 0UL) {
    {
#line 297
    x = pr_xoff + taux;
#line 298
    y = pr_yoff + tauy;
#line 299
    hardcopy_label(x, y, msg1);
#line 300
    ix = (int )((double )midx + 1.42 * (double )x);
#line 301
    iy = (int )((double )midy - 1.42 * (double )y);
#line 302
    tmp___0 = strlen((char const   *)msg1);
#line 302
    dd = (int )(tmp___0 * 6UL);
#line 303
    tmp___1 = strlen((char const   *)msg1);
#line 303
    XDrawString(dpy, win, labelgc, ix - dd / 2, iy, (char const   *)msg1, (int )tmp___1);
#line 304
    tmp___2 = strlen((char const   *)msg1);
#line 304
    XDrawString(dpy, bgrmap, labelgc, ix - dd / 2, iy, (char const   *)msg1, (int )tmp___2);
    }
  }
  {
#line 306
  tmp___7 = strlen((char const   *)msg2);
  }
#line 306
  if (tmp___7 > 0UL) {
    {
#line 307
    x = pr_xoff + taux;
#line 308
    y = (pr_yoff + tauy) - (float )10;
#line 309
    hardcopy_label(x, y, msg2);
#line 310
    ix = (int )((double )midx + 1.42 * (double )x);
#line 311
    iy = (int )((double )midy - 1.42 * (double )y);
#line 312
    tmp___4 = strlen((char const   *)msg2);
#line 312
    dd = (int )(tmp___4 * 6UL);
#line 313
    tmp___5 = strlen((char const   *)msg2);
#line 313
    XDrawString(dpy, win, labelgc, ix - dd / 2, iy, (char const   *)msg2, (int )tmp___5);
#line 314
    tmp___6 = strlen((char const   *)msg2);
#line 314
    XDrawString(dpy, bgrmap, labelgc, ix - dd / 2, iy, (char const   *)msg2, (int )tmp___6);
    }
  }
  {
#line 316
  fflush(outfp);
#line 317
  sprintf((char */* __restrict  */)(xx), (char const   */* __restrict  */)" write(%d) to %s",
          num_print, prf);
#line 318
  strcat((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)(xx));
  }
#line 319
  return (0);
}
}
#line 324 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int update_from_file(void) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 331
  nbas = 0;
#line 331
  nbonds = 0;
#line 331
  nspec = 0;
#line 332
  nframe = 1;
#line 333
  tmp = readclusterdata(inf);
  }
#line 333
  if (! tmp) {
    {
#line 334
    sprintf((char */* __restrict  */)(emsg), (char const   */* __restrict  */)"Cannot update from file %s",
            inf);
    }
#line 335
    return (0);
  }
  {
#line 338
  sprintf((char */* __restrict  */)(curf), (char const   */* __restrict  */)"%s ",
          inf);
#line 339
  clearline(win, 10, 8);
#line 340
  showline(win, 10, 8, (char *)"Reading ", inmv, (char *)" .. please wait");
#line 341
  XFlush(dpy);
#line 342
  sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"Updated from %s ",
          inf);
#line 343
  tmp___0 = readclusterdata(inmv);
  }
#line 343
  if (tmp___0) {
    {
#line 344
    sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"Updated from %s and %s",
            inf, inmv);
#line 345
    sprintf((char */* __restrict  */)(frstr[0]), (char const   */* __restrict  */)"%s",
            "start ..\000");
#line 346
    strcat((char */* __restrict  */)(curf), (char const   */* __restrict  */)(inmv));
    }
  }
#line 349
  i = 0;
  {
#line 349
  while (1) {
    while_continue: /* CIL Label */ ;
#line 349
    if (! (i < ncol)) {
#line 349
      goto while_break;
    }
    {
#line 349
    FreeColorGC(i);
#line 349
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 350
  if (autocolor) {
    {
#line 350
    set_auto_colors();
    }
  }
  {
#line 351
  parse_all_colors();
  }
#line 352
  if (color) {
    {
#line 353
    SetColors();
    }
  } else
#line 355
  if (stippled) {
    {
#line 355
    SetStippled4x4();
    }
  } else {
    {
#line 356
    SetSmoothGrays();
    }
  }
  {
#line 359
  natom = ball_list(ball, 0);
#line 360
  nbond = stick_list(ball, stick);
#line 361
  putframe(ball, 0);
#line 362
  getframe(ball, iframe);
#line 363
  replot = 1;
#line 364
  resetup = 1;
  }
#line 365
  return (1);
}
}
#line 369 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int interpret_input(char *inp ) 
{ 
  char msg1[81] ;
  char msg2[81] ;
  char str[81] ;
  char pat[81] ;
  char w[8][41] ;
  float sh[3][6] ;
  float cut[3] ;
  float cut1 ;
  float cut2 ;
  int i ;
  int j ;
  int n ;
  int rc ;
  int nw ;
  int svstep ;
  int svrgb ;
  int helpme ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char const   *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  size_t tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;

  {
  {
#line 377
  nw = parse_args(inp, (char (*)[41])(w));
  }
#line 378
  if (nw == 0) {
    {
#line 379
    sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"Empty input");
    }
#line 380
    return;
  }
  {
#line 383
  helpme = 0;
#line 384
  tmp = strcmp((char const   *)(w[1]), "?");
  }
#line 384
  if (! tmp) {
#line 384
    helpme = 1;
  }
  {
#line 385
  tmp___0 = strcmp((char const   *)(w[1]), "-h");
  }
#line 385
  if (! tmp___0) {
#line 385
    helpme = 1;
  }
  {
#line 387
  tmp___1 = abbrev(w[0], (char *)"help", 4);
  }
#line 387
  if (tmp___1) {
#line 388
    if (nw == 1) {
      {
#line 389
      sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"Try \'command ?\' or press key h");
      }
#line 390
      return;
    } else {
      {
#line 393
      helpme = 1;
#line 394
      sprintf((char */* __restrict  */)inp, (char const   */* __restrict  */)"%s",
              w[1]);
#line 395
      nw = parse_args(inp, (char (*)[41])(w));
      }
    }
  }
  {
#line 399
  tmp___24 = abbrev(w[0], (char *)"update", 2);
  }
#line 399
  if (tmp___24) {
#line 400
    if (helpme) {
      {
#line 401
      sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"Usage: update [-color] [-rv] [+rv] [-bw] [-st] [-auto] [file]  - update from file");
      }
    } else {
#line 404
      i = 1;
      {
#line 405
      while (1) {
        while_continue: /* CIL Label */ ;
#line 405
        if (! (i < nw)) {
#line 405
          goto while_break;
        }
        {
#line 406
        tmp___7 = abbrev(w[i], (char *)"-st", 3);
        }
#line 406
        if (tmp___7) {
#line 406
          stippled = 1;
#line 406
          color = 0;
        } else {
          {
#line 407
          tmp___6 = abbrev(w[i], (char *)"-bw", 3);
          }
#line 407
          if (tmp___6) {
#line 407
            stippled = 0;
#line 407
            color = 0;
          } else {
            {
#line 408
            tmp___5 = abbrev(w[i], (char *)"-color", 4);
            }
#line 408
            if (tmp___5) {
#line 408
              color = 1;
            } else {
              {
#line 409
              tmp___4 = abbrev(w[i], (char *)"-auto", 5);
              }
#line 409
              if (tmp___4) {
#line 409
                autocolor = 1;
#line 409
                color = 1;
              } else {
                {
#line 410
                tmp___3 = abbrev(w[i], (char *)"-rv", 3);
                }
#line 410
                if (tmp___3) {
#line 410
                  reverse = 1;
                } else {
                  {
#line 411
                  tmp___2 = abbrev(w[i], (char *)"+rv", 3);
                  }
#line 411
                  if (tmp___2) {
#line 411
                    reverse = 0;
                  } else
#line 412
                  if ((int )w[i][0] == 45) {
                    {
#line 413
                    sprintf((char */* __restrict  */)(emsg), (char const   */* __restrict  */)"update: unknown flag %s",
                            w[i]);
                    }
#line 414
                    return;
                  } else {
                    {
#line 417
                    strext(inf, w[i], (char *)"bs", 0);
#line 418
                    strext(inmv, inf, (char *)"mv", 1);
                    }
                  }
                }
              }
            }
          }
        }
#line 420
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 422
      update_from_file();
      }
    }
  } else {
    {
#line 426
    tmp___23 = abbrev(w[0], (char *)"save", 3);
    }
#line 426
    if (tmp___23) {
#line 427
      if (helpme) {
        {
#line 428
        sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"Usage: save [-rgb] [-step n] file  - save data");
        }
      } else {
#line 430
        i = 1;
#line 430
        svstep = 1;
#line 430
        svrgb = 0;
        {
#line 431
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 431
          if (! (i < nw)) {
#line 431
            goto while_break___0;
          }
          {
#line 432
          tmp___9 = abbrev(w[i], (char *)"-step", 3);
          }
#line 432
          if (tmp___9) {
            {
#line 432
            i ++;
#line 432
            svstep = atoi((char const   *)(w[i]));
            }
          } else {
            {
#line 433
            tmp___8 = abbrev(w[i], (char *)"-rgb", 4);
            }
#line 433
            if (tmp___8) {
#line 433
              svrgb = 1;
            } else
#line 434
            if ((int )w[i][0] == 45) {
              {
#line 435
              sprintf((char */* __restrict  */)(emsg), (char const   */* __restrict  */)"save: unknown flag %s",
                      w[i]);
              }
#line 436
              return;
            } else {
              {
#line 438
              strext(outf, w[i], (char *)"bs", 0);
              }
            }
          }
#line 439
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 441
        showline(win, 10, 8, (char *)"Saving .. ", (char *)"", (char *)"");
#line 442
        XFlush(dpy);
#line 443
        writeclusterdata(outf, svstep, svrgb);
        }
      }
    } else {
      {
#line 447
      tmp___22 = abbrev(w[0], (char *)"print", 2);
      }
#line 447
      if (tmp___22) {
#line 448
        if (helpme) {
          {
#line 449
          handle_print(msg1, msg2, helpme);
          }
        } else {
          {
#line 451
          i = 1;
#line 452
          strcpy((char */* __restrict  */)(msg1), (char const   */* __restrict  */)"");
#line 453
          strcpy((char */* __restrict  */)(msg2), (char const   */* __restrict  */)"");
          }
          {
#line 454
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 454
            if (! (i < nw)) {
#line 454
              goto while_break___1;
            }
            {
#line 455
            tmp___12 = strcmp((char const   *)(w[i]), "-t");
            }
#line 455
            if (tmp___12) {
              {
#line 459
              tmp___11 = strcmp((char const   *)(w[i]), "-T");
              }
#line 459
              if (tmp___11) {
#line 463
                if ((int )w[i][0] == 45) {
                  {
#line 464
                  sprintf((char */* __restrict  */)(emsg), (char const   */* __restrict  */)"print: unknown flag %s",
                          w[i]);
                  }
#line 465
                  return;
                } else {
                  {
#line 468
                  strext(prf, w[i], (char *)"ps", 0);
                  }
                }
              } else {
                {
#line 460
                sprintf((char */* __restrict  */)(msg1), (char const   */* __restrict  */)"%s frame %d of %d",
                        inf, iframe + 1, nframe);
#line 461
                tmp___10 = strlen((char const   *)(frstr[iframe]));
                }
#line 461
                if (tmp___10 > 0UL) {
                  {
#line 461
                  strip(msg2, frstr[iframe]);
                  }
                }
              }
            } else {
              {
#line 456
              i ++;
#line 457
              strcpy((char */* __restrict  */)(msg1), (char const   */* __restrict  */)(w[i]));
              }
            }
#line 470
            i ++;
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 472
          handle_print(msg1, msg2, helpme);
          }
        }
      } else {
        {
#line 476
        tmp___21 = abbrev(w[0], (char *)"close", 2);
        }
#line 476
        if (tmp___21) {
#line 477
          if (! helpme) {
#line 478
            if (num_print == 1) {
#line 478
              tmp___13 = "";
            } else {
#line 478
              tmp___13 = "s";
            }
            {
#line 478
            sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"Print: %s closed after %d write%s",
                    prf, num_print, tmp___13);
            }
          }
          {
#line 480
          close_print(helpme);
#line 481
          replot = 1;
          }
        } else {
          {
#line 484
          tmp___20 = abbrev(w[0], (char *)"dup", 3);
          }
#line 484
          if (tmp___20) {
#line 485
            i = 0;
            {
#line 485
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 485
              if (! (i < 3)) {
#line 485
                goto while_break___2;
              }
#line 485
              j = 0;
              {
#line 485
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 485
                if (! (j < 6)) {
#line 485
                  goto while_break___3;
                }
#line 485
                sh[i][j] = (float )0;
#line 485
                j ++;
              }
              while_break___3: /* CIL Label */ ;
              }
#line 485
              i ++;
            }
            while_break___2: /* CIL Label */ ;
            }
            {
#line 486
            sscanf((char const   */* __restrict  */)inp, (char const   */* __restrict  */)"%*s %f %f %f %f %f %f %f %f %f %f %f %f",
                   & sh[0][0], & sh[1][0], & sh[2][0], & sh[0][1], & sh[1][1], & sh[2][1],
                   & sh[0][2], & sh[1][2], & sh[2][2], & sh[0][3], & sh[1][3], & sh[2][3],
                   & sh[0][4], & sh[1][4], & sh[2][4], & sh[0][5], & sh[1][5], & sh[2][5]);
#line 490
            tmp___14 = duplicate_atoms((float (*)[6])(sh), helpme);
            }
#line 490
            if (tmp___14) {
#line 490
              resetup = 2;
            }
          } else {
            {
#line 493
            tmp___19 = abbrev(w[0], (char *)"cut", 3);
            }
#line 493
            if (tmp___19) {
              {
#line 494
              cut2 = (float )0;
#line 494
              cut1 = cut2;
#line 494
              cut[2] = cut1;
#line 494
              cut[1] = cut[2];
#line 494
              cut[0] = cut[1];
#line 495
              sscanf((char const   */* __restrict  */)inp, (char const   */* __restrict  */)"%*s %f %f %f %f %f",
                     & cut[0], & cut[1], & cut[2], & cut1, & cut2);
#line 497
              tmp___15 = cut_atoms((float *)(cut), cut1, cut2, helpme);
              }
#line 497
              if (tmp___15) {
#line 497
                resetup = 2;
              }
            } else {
              {
#line 500
              tmp___18 = abbrev(w[0], (char *)"color", 3);
              }
#line 500
              if (tmp___18) {
                {
#line 501
                strcpy((char */* __restrict  */)(pat), (char const   */* __restrict  */)"");
#line 502
                sscanf((char const   */* __restrict  */)inp, (char const   */* __restrict  */)"%*s %s %n",
                       pat, & n);
#line 503
                i = n;
                }
                {
#line 503
                while (1) {
                  while_continue___4: /* CIL Label */ ;
                  {
#line 503
                  tmp___16 = strlen((char const   *)inp);
                  }
#line 503
                  if (! ((size_t )i < tmp___16 + 1UL)) {
#line 503
                    goto while_break___4;
                  }
#line 503
                  str[i - n] = *(inp + i);
#line 503
                  i ++;
                }
                while_break___4: /* CIL Label */ ;
                }
                {
#line 504
                tmp___17 = NewSpecColor(pat, str, helpme);
                }
#line 504
                if (tmp___17) {
#line 504
                  resetup = 1;
                }
              } else {
                {
#line 508
                rc = readclusterline(inp, helpme);
                }
#line 509
                if (rc == 1) {
#line 509
                  replot = 1;
                }
#line 510
                if (rc == 2) {
#line 510
                  resetup = 1;
                }
              }
            }
          }
        }
      }
    }
  }
#line 513
  return (0);
}
}
#line 3 "/home/june/repo/benchmarks/collector2/temp/xbs-0/bs_icon"
int main(int argc , char **argv ) ;
#line 3 "/home/june/repo/benchmarks/collector2/temp/xbs-0/bs_icon"
static char bs_icon_bits[350]  = 
#line 3
  {      (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)124, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)-125,      (char)1, 
        (char)0,      (char)0,      (char)-8,      (char)3, 
        (char)-128,      (char)0,      (char)2,      (char)0, 
        (char)0,      (char)-84,      (char)6,      (char)64, 
        (char)0,      (char)4,      (char)0,      (char)0, 
        (char)87,      (char)29,      (char)64,      (char)0, 
        (char)4,      (char)0,      (char)0,      (char)-85, 
        (char)26,      (char)32,      (char)0,      (char)8, 
        (char)0,      (char)-128,      (char)85,      (char)53, 
        (char)32,      (char)0,      (char)8,      (char)0, 
        (char)-64,      (char)-86,      (char)106,      (char)32, 
        (char)6,      (char)8,      (char)0,      (char)64, 
        (char)85,      (char)85,      (char)-2,      (char)1, 
        (char)8,      (char)0,      (char)-64,      (char)-86, 
        (char)-22,      (char)33,      (char)0,      (char)8, 
        (char)0,      (char)64,      (char)85,      (char)85, 
        (char)64,      (char)0,      (char)4,      (char)0, 
        (char)-64,      (char)-86,      (char)106,      (char)64, 
        (char)0,      (char)4,      (char)0,      (char)64, 
        (char)-43,      (char)85,      (char)-128,      (char)0, 
        (char)2,      (char)0,      (char)-64,      (char)-86, 
        (char)106,      (char)0,      (char)-125,      (char)1, 
        (char)0,      (char)-128,      (char)-43,      (char)53, 
        (char)0,      (char)124,      (char)0,      (char)0, 
        (char)0,      (char)-85,      (char)27,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)87,      (char)29,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)-84, 
        (char)7,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)-8,      (char)3, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)2,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)2,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)4,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)-2, 
        (char)3,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)1,      (char)4, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)-64,      (char)0,      (char)24,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)64, 
        (char)0,      (char)16,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)32,      (char)0, 
        (char)32,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)16,      (char)0,      (char)64, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)16,      (char)0,      (char)64,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)16, 
        (char)0,      (char)64,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)16,      (char)0, 
        (char)64,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)16,      (char)0,      (char)64, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)16,      (char)0,      (char)64,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)16, 
        (char)0,      (char)64,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)16,      (char)0, 
        (char)64,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)16,      (char)0,      (char)64, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)32,      (char)0,      (char)32,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)64, 
        (char)0,      (char)16,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)-64,      (char)0, 
        (char)24,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)1,      (char)4, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)-2,      (char)3,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0};
#line 791 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int interpret_keypress(XEvent *ev , int *inpmode , char *input , int *ixyz , float *alfa ) ;
#line 516 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int main(int argc , char **argv ) 
{ 
  Pixmap iconmap ;
  XEvent ev ;
  XEvent ev1 ;
  Font font ;
  XSizeHints hint ;
  char input[257] ;
  int keytype ;
  int inpmode ;
  int finished ;
  char *p___0 ;
  int i ;
  int j ;
  int k ;
  int ixyz ;
  float alfa ;
  float beta ;
  float gama ;
  char yn___0[2][5] ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  float phi ;
  double tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  double tmp___15 ;
  double tmp___16 ;
  int tmp___17 ;
  size_t tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;

  {
#line 533
  yn___0[0][0] = (char )'n';
#line 533
  yn___0[0][1] = (char )'o';
#line 533
  yn___0[0][2] = (char )'\000';
#line 533
  tmp = 3U;
  {
#line 533
  while (1) {
    while_continue: /* CIL Label */ ;
#line 533
    if (tmp >= 5U) {
#line 533
      goto while_break;
    }
#line 533
    yn___0[0][tmp] = (char)0;
#line 533
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 533
  yn___0[1][0] = (char )'y';
#line 533
  yn___0[1][1] = (char )'e';
#line 533
  yn___0[1][2] = (char )'s';
#line 533
  yn___0[1][3] = (char )'\000';
#line 533
  tmp___0 = 4U;
  {
#line 533
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 533
    if (tmp___0 >= 5U) {
#line 533
      goto while_break___0;
    }
#line 533
    yn___0[1][tmp___0] = (char)0;
#line 533
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 538
  dist0 = (float )15.0;
#line 538
  dist = dist0;
#line 539
  scale = (float )15;
#line 540
  igs = (float )1.0;
#line 541
  tauy = (float )0;
#line 541
  tauy0 = tauy;
#line 541
  taux = tauy0;
#line 541
  taux0 = taux;
#line 542
  dtaux = (float )10;
#line 543
  dtauy = (float )10;
#line 544
  wire = 0;
#line 545
  bline = 0;
#line 546
  radfac = (float )1.0;
#line 547
  bndfac = (float )1.0;
#line 548
  alfa = (float )0;
#line 548
  beta = (float )0;
#line 548
  gama = (float )0;
#line 549
  eumat((float )(((double )alfa * 3.1415926) / 180.0), (float )(((double )beta * 3.1415926) / 180.0),
        (float )(((double )gama * 3.1415926) / 180.0));
#line 550
  dalfa = (float )90.0;
#line 551
  nspec = 0;
#line 552
  nbas = 0;
#line 553
  nbonds = 0;
#line 554
  nxline = 0;
#line 555
  alat = (float )1.0;
#line 556
  amp = (float )0.0;
#line 557
  hardcopy = 0;
#line 558
  usepixmap = 0;
#line 559
  numbers = 0;
#line 560
  pmode = 0;
#line 561
  recenter = 1;
#line 562
  wrhelp = 0;
#line 563
  shadow = 0;
#line 564
  grayvalues = 1;
#line 565
  withbonds = 1;
#line 566
  bondnums = 0;
#line 567
  color = 1;
#line 568
  autocolor = 0;
#line 569
  reverse = 0;
#line 570
  fstep = 1;
#line 571
  wrinfo = 0;
#line 572
  stippled = 0;
#line 573
  showaxes = 0;
#line 574
  showlines = 1;
#line 575
  saveframe = -99;
#line 576
  coords = 0;
#line 577
  gmode = 0;
#line 578
  center[2] = (float )0;
#line 578
  center[1] = center[2];
#line 578
  center[0] = center[1];
#line 579
  startup = 1;
#line 581
  hint.x = 0;
#line 582
  hint.y = 0;
#line 583
  hint.width = 550;
#line 584
  hint.height = 450;
#line 587
  i = 1;
#line 587
  j = 0;
#line 587
  k = -1;
#line 587
  igeo = 0;
  }
  {
#line 588
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 588
    if (! (i < argc)) {
#line 588
      goto while_break___1;
    }
    {
#line 589
    tmp___11 = strcmp((char const   *)*(argv + i), "-geo");
    }
#line 589
    if (tmp___11) {
      {
#line 593
      tmp___10 = abbrev(*(argv + i), (char *)"-sc", 3);
      }
#line 593
      if (tmp___10) {
        {
#line 593
        i ++;
#line 593
        tmp___1 = atof((char const   *)*(argv + i));
#line 593
        igs = (float )tmp___1;
        }
      } else {
        {
#line 594
        tmp___9 = abbrev(*(argv + i), (char *)"-t", 2);
        }
#line 594
        if (tmp___9) {
#line 594
          i ++;
#line 594
          k = i;
        } else {
          {
#line 595
          tmp___8 = abbrev(*(argv + i), (char *)"-st", 3);
          }
#line 595
          if (tmp___8) {
#line 595
            stippled = 1;
#line 595
            color = 0;
          } else {
            {
#line 596
            tmp___7 = abbrev(*(argv + i), (char *)"-bw", 3);
            }
#line 596
            if (tmp___7) {
#line 596
              stippled = 0;
#line 596
              color = 0;
            } else {
              {
#line 597
              tmp___6 = abbrev(*(argv + i), (char *)"-color", 4);
              }
#line 597
              if (tmp___6) {
#line 597
                color = 1;
              } else {
                {
#line 598
                tmp___5 = abbrev(*(argv + i), (char *)"-autocolor", 5);
                }
#line 598
                if (tmp___5) {
#line 598
                  autocolor = 1;
#line 598
                  color = 1;
                } else {
                  {
#line 599
                  tmp___4 = abbrev(*(argv + i), (char *)"-rv", 3);
                  }
#line 599
                  if (tmp___4) {
#line 599
                    reverse = 1;
                  } else {
                    {
#line 600
                    tmp___3 = abbrev(*(argv + i), (char *)"-hh", 3);
                    }
#line 600
                    if (tmp___3) {
                      {
#line 600
                      WriteHelp();
#line 600
                      exit(0);
                      }
                    } else {
                      {
#line 601
                      tmp___2 = abbrev(*(argv + i), (char *)"-h", 2);
                      }
#line 601
                      if (tmp___2) {
#line 601
                        j = 1;
                      } else
#line 602
                      if ((int )*(*(argv + i) + 0) == 45) {
                        {
#line 603
                        printf((char const   */* __restrict  */)"Unknown flag %s\n",
                               *(argv + i));
#line 603
                        exit(1);
                        }
                      } else {
                        {
#line 604
                        strext(inf, *(argv + i), (char *)"bs", 0);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    } else {
      {
#line 590
      i ++;
#line 591
      igeo = XParseGeometry((char const   *)*(argv + i), & igx, & igy, (unsigned int *)(& igw),
                            (unsigned int *)(& igh));
      }
    }
#line 605
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 607
  p___0 = inf;
#line 608
  i = 0;
  {
#line 608
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 608
    tmp___12 = strlen((char const   *)(inf));
    }
#line 608
    if (! ((size_t )i < tmp___12)) {
#line 608
      goto while_break___2;
    }
#line 608
    if ((int )inf[i] == 47) {
#line 608
      p___0 = (inf + i) + 1;
    }
#line 608
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 609
  strcpy((char */* __restrict  */)(wname), (char const   */* __restrict  */)p___0);
  }
#line 610
  if (k > -1) {
    {
#line 610
    strcpy((char */* __restrict  */)(wname), (char const   */* __restrict  */)*(argv + k));
    }
  }
#line 612
  if (igeo & 4) {
#line 612
    hint.width = igw;
  } else {
#line 613
    igw = hint.width;
  }
#line 614
  if (igeo & 8) {
#line 614
    hint.height = igh;
  } else {
#line 615
    igh = hint.height;
  }
#line 616
  if (igeo & 1) {
#line 616
    hint.x = igx;
  }
#line 617
  if (igeo & 2) {
#line 617
    hint.y = igy;
  }
#line 619
  if (igeo & 1) {
#line 619
    if (hint.x == 0) {
#line 619
      if (hint.y == 0) {
#line 619
        hint.x = 1;
      }
    }
  }
#line 621
  if (j == 1) {
    {
#line 622
    printf((char const   */* __restrict  */)"\nUsage:  xbs [flags] id   -- ball-and-sticks plotting program\nData is read from files id.bs and id.mv\n\nFlags:  -geo gg     set window geometry   \n        -sc x       set scale factor\n        -t title    set window title\n        -color      use color\n        -bw         b/w with smooth grays\n        -st         b/w with stippled grays\n        -rv         reverse colors\n        -autocolor  chose own colors\n        -hh         long help\n\nHelp: Enter \'xbs -hh\' to get an overview.\nFor on-line help, press key \'h\' for the overview or use\n\'help <cmd>\' or \'<cmd> ?\' in the input line for information\non a specific command (including possible options).\nRequest the input line with key \'i\'.\n");
#line 639
    printf((char const   */* __restrict  */)"\nSettings: geometry %dx%d%+d%+d, scale %.2f,\ncolor %s, autocolor %s, stippled %s, reverse %s\n ",
           hint.width, hint.height, hint.x, hint.y, (double )igs, yn___0[color], yn___0[autocolor],
           yn___0[stippled], yn___0[reverse]);
#line 645
    exit(0);
    }
  }
  {
#line 648
  tmp___13 = strstr((char const   *)(inf), ".");
  }
#line 648
  if (! tmp___13) {
    {
#line 648
    strcat((char */* __restrict  */)(inf), (char const   */* __restrict  */)".bs");
    }
  }
  {
#line 651
  sprintf((char */* __restrict  */)(curf), (char const   */* __restrict  */)"%s ",
          inf);
#line 652
  nframe = 1;
#line 653
  strext(inmv, inf, (char *)"mv", 1);
#line 654
  tmp___14 = readclusterdata(inf);
  }
#line 654
  if (! tmp___14) {
    {
#line 655
    printf((char const   */* __restrict  */)"Could not open input file %s\n", inf);
#line 656
    exit(1);
    }
  }
#line 658
  if (natom <= 80) {
#line 658
    usepixmap = 1;
  }
  {
#line 661
  dpy = XOpenDisplay("");
  }
#line 662
  if (! dpy) {
    {
#line 663
    printf((char const   */* __restrict  */)"Error: could not open display\n");
#line 664
    exit(1);
    }
  }
#line 666
  screen = ((_XPrivDisplay )dpy)->default_screen;
#line 667
  screenptr = ((_XPrivDisplay )dpy)->screens + ((_XPrivDisplay )dpy)->default_screen;
#line 668
  bground = (((_XPrivDisplay )dpy)->screens + screen)->white_pixel;
#line 669
  fground = (((_XPrivDisplay )dpy)->screens + screen)->black_pixel;
#line 671
  if (igeo & 1) {
#line 671
    if (igeo & 16) {
#line 672
      hint.x = ((igx + screenptr->width) - hint.width) - 18;
    }
  }
#line 673
  if (igeo & 2) {
#line 673
    if (igeo & 32) {
#line 674
      hint.y = ((igy + screenptr->height) - hint.height) - 34;
    }
  }
  {
#line 676
  hint.flags = (1L << 2) | (1L << 3);
#line 677
  win = XCreateSimpleWindow(dpy, (((_XPrivDisplay )dpy)->screens + ((_XPrivDisplay )dpy)->default_screen)->root,
                            hint.x, hint.y, (unsigned int )hint.width, (unsigned int )hint.height,
                            0U, 0UL, bground);
#line 680
  midx = igw / 2;
#line 681
  midy = igh / 2 - 20;
#line 683
  iconmap = XCreateBitmapFromData(dpy, win, (char const   *)(bs_icon_bits), 50U, 50U);
#line 686
  XSetStandardProperties(dpy, win, (char const   *)(wname), (char const   *)(wname),
                         iconmap, argv, argc, & hint);
#line 689
  gc = XCreateGC(dpy, win, 0UL, (XGCValues *)0);
#line 690
  XSetBackground(dpy, gc, bground);
#line 691
  XSetForeground(dpy, gc, fground);
#line 692
  XSelectInput(dpy, win, (1L | (1L << 15)) | (1L << 17));
#line 693
  XMapRaised(dpy, win);
#line 694
  drw = win;
#line 697
  font = XLoadFont(dpy, "8x13");
#line 698
  XSetFont(dpy, gc, font);
#line 699
  gcbg = XCreateGC(dpy, win, 0UL, (XGCValues *)0);
#line 700
  XSetForeground(dpy, gcbg, bground);
#line 701
  shadowgc = XCreateGC(dpy, win, 0UL, (XGCValues *)0);
#line 702
  XSetLineAttributes(dpy, shadowgc, 5U, 0, 2, 2);
#line 704
  XSetForeground(dpy, shadowgc, bground);
#line 705
  labelgc = XCreateGC(dpy, win, 0UL, (XGCValues *)0);
#line 706
  XSetForeground(dpy, labelgc, fground);
#line 707
  font = XLoadFont(dpy, "6x10");
#line 708
  XSetFont(dpy, labelgc, font);
#line 709
  labbggc = XCreateGC(dpy, win, 0UL, (XGCValues *)0);
#line 710
  XSetLineAttributes(dpy, labbggc, 13U, 0, 2, 0);
#line 712
  XSetForeground(dpy, labbggc, bground);
#line 714
  lngc = XCreateGC(dpy, win, 0UL, (XGCValues *)0);
#line 715
  XSetLineAttributes(dpy, lngc, 1U, 1, 2, 2);
#line 719
  cmap = XDefaultColormap(dpy, screen);
#line 721
  i = 0;
  }
  {
#line 721
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 721
    if (! (i < 5)) {
#line 721
      goto while_break___3;
    }
    {
#line 722
    phi = (float )(((double )i * 3.1415926) / ((double )5 - 1.0));
#line 723
    tmp___15 = sin((double )phi);
#line 723
    arc[i][0] = (float )(- tmp___15);
#line 724
    tmp___16 = cos((double )phi);
#line 724
    arc[i][1] = (float )tmp___16;
#line 721
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 728
  if (autocolor) {
    {
#line 728
    set_auto_colors();
    }
  }
  {
#line 729
  parse_all_colors();
  }
#line 730
  if (color) {
    {
#line 731
    SetColors();
    }
  } else
#line 733
  if (stippled) {
    {
#line 733
    SetStippled4x4();
    }
  } else {
    {
#line 734
    SetSmoothGrays();
    }
  }
  {
#line 737
  natom = ball_list(ball, 10);
#line 738
  nbond = stick_list(ball, stick);
#line 739
  putframe(ball, 0);
#line 740
  getframe(ball, 0);
#line 741
  sprintf((char */* __restrict  */)(frstr[0]), (char const   */* __restrict  */)"%s",
          " \000");
#line 745
  depth = XDefaultDepth(dpy, screen);
#line 746
  pixmap = XCreatePixmap(dpy, win, (unsigned int )igw, (unsigned int )igh, (unsigned int )depth);
#line 747
  bgrmap = XCreatePixmap(dpy, win, (unsigned int )igw, (unsigned int )igh, (unsigned int )depth);
#line 748
  XFillRectangle(dpy, bgrmap, gcbg, 0, 0, (unsigned int )igw, (unsigned int )igh);
#line 751
  inpmode = 0;
#line 752
  finished = 0;
#line 753
  num_print = 0;
#line 754
  count = 0;
#line 755
  iframe = 0;
#line 756
  keytype = 0;
#line 757
  strcpy((char */* __restrict  */)(prfsave), (char const   */* __restrict  */)(prf));
  }
  {
#line 759
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 759
    if (! (finished == 0)) {
#line 759
      goto while_break___4;
    }
    {
#line 760
    XNextEvent(dpy, & ev);
#line 761
    ixyz = 0;
#line 762
    chginfo = 0;
#line 762
    resetup = chginfo;
#line 762
    replot = resetup;
#line 763
    strcpy((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"");
#line 764
    strcpy((char */* __restrict  */)(emsg), (char const   */* __restrict  */)"");
    }
    {
#line 767
    if (ev.type == 12) {
#line 767
      goto case_12;
    }
#line 782
    if (ev.type == 22) {
#line 782
      goto case_22;
    }
#line 788
    if (ev.type == 2) {
#line 788
      goto case_2;
    }
#line 765
    goto switch_break;
    case_12: /* CIL Label */ 
#line 768
    if (ev.xexpose.count == 0) {
#line 769
      if (! startup) {
        {
#line 770
        XCopyArea(dpy, pixmap, win, gc, 0, 0, (unsigned int )igw, (unsigned int )igh,
                  0, 0);
        }
#line 771
        if (inpmode) {
          {
#line 772
          clearline(win, 10, 8);
#line 773
          showline(win, 10, 8, (char *)"Input: ", input, (char *)"_ ");
          }
        }
#line 775
        if (wrhelp > 0) {
          {
#line 775
          WriteHelp();
          }
        }
      } else {
#line 778
        replot = 1;
      }
    }
#line 780
    goto switch_break;
    case_22: /* CIL Label */ 
    {
#line 783
    tmp___17 = do_ConfigureNotify(& ev);
    }
#line 783
    if (tmp___17) {
#line 783
      replot = 1;
    }
#line 784
    if (startup) {
#line 784
      replot = 0;
    }
#line 785
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 789
    strcpy((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"");
#line 790
    strcpy((char */* __restrict  */)(emsg), (char const   */* __restrict  */)"");
#line 791
    keytype = interpret_keypress(& ev, & inpmode, input, & ixyz, & alfa);
    }
    {
#line 793
    if (keytype == 1) {
#line 793
      goto case_1;
    }
#line 796
    if (keytype == 2) {
#line 796
      goto case_2___0;
    }
#line 799
    if (keytype == 3) {
#line 799
      goto case_3;
    }
#line 802
    if (keytype == 5) {
#line 802
      goto case_5;
    }
#line 806
    if (keytype == 6) {
#line 806
      goto case_6;
    }
#line 815
    if (keytype == 4) {
#line 815
      goto case_4;
    }
#line 792
    goto switch_break___0;
    case_1: /* CIL Label */ 
#line 794
    finished = 1;
#line 795
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
#line 797
    replot = 1;
#line 798
    goto switch_break___0;
    case_3: /* CIL Label */ 
#line 800
    resetup = 1;
#line 801
    goto switch_break___0;
    case_5: /* CIL Label */ 
    {
#line 803
    clearline(win, 10, 8);
#line 804
    showline(win, 10, 8, (char *)"Input: ", input, (char *)"_           ");
    }
#line 805
    goto switch_break___0;
    case_6: /* CIL Label */ 
    {
#line 807
    clearline(win, 10, 8);
#line 808
    tmp___18 = strlen((char const   *)(input));
    }
#line 808
    if (tmp___18 > 0UL) {
#line 809
      k = 9;
      {
#line 809
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 809
        if (! (k > 1)) {
#line 809
          goto while_break___5;
        }
        {
#line 809
        strcpy((char */* __restrict  */)(svinput[k]), (char const   */* __restrict  */)(svinput[k - 1]));
#line 809
        k --;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 810
      strcpy((char */* __restrict  */)(svinput[1]), (char const   */* __restrict  */)(input));
#line 811
      nsvline ++;
      }
    }
    {
#line 813
    interpret_input(input);
    }
#line 814
    goto switch_break___0;
    case_4: /* CIL Label */ 
    {
#line 816
    update_from_file();
    }
#line 817
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 819
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 823
    if (resetup) {
      {
#line 824
      natom = ball_list(ball, 0);
#line 825
      getframe(ball, iframe);
#line 826
      nbond = stick_list(ball, stick);
#line 827
      replot = 1;
      }
    }
#line 831
    if (replot) {
      {
#line 832
      rotmat(ixyz, (float )(((double )alfa * 3.1415926) / 180.0));
#line 833
      bs_transform(natom, ball);
      }
#line 835
      if (usepixmap) {
        {
#line 836
        drw = pixmap;
#line 837
        XCopyArea(dpy, bgrmap, pixmap, gc, 0, 0, (unsigned int )igw, (unsigned int )igh,
                  0, 0);
        }
      } else {
#line 840
        drw = win;
#line 841
        if (wrinfo) {
          {
#line 841
          WriteInfo(drw);
          }
        }
#line 842
        if (wrhelp > 0) {
          {
#line 842
          WriteHelp();
          }
        }
        {
#line 843
        XCopyArea(dpy, bgrmap, win, gc, 0, 0, (unsigned int )igw, (unsigned int )igh,
                  0, 0);
        }
      }
      {
#line 846
      showline(win, 10, 8, (char *)"Busy                    ", (char *)" ", (char *)" ");
#line 847
      bs_kernel(natom, ball, nbond, stick);
      }
#line 848
      if (startup) {
        {
#line 848
        showline(win, 10, 8, (char *)"Reading ", inmv, (char *)" ..");
        }
      }
      {
#line 850
      WriteStatus(drw);
      }
#line 851
      if (wrinfo) {
        {
#line 851
        WriteInfo(drw);
        }
      }
#line 852
      if (wrhelp > 0) {
        {
#line 852
        WriteHelp();
        }
      }
#line 854
      if (usepixmap) {
        {
#line 855
        XCopyArea(dpy, pixmap, win, gc, 0, 0, (unsigned int )igw, (unsigned int )igh,
                  0, 0);
        }
      }
#line 857
      if (startup) {
        {
#line 858
        showline(win, 10, 8, (char *)"Reading ", inmv, (char *)" .. please wait");
#line 859
        XFlush(dpy);
#line 860
        k = nframe;
#line 861
        tmp___19 = readclusterdata(inmv);
        }
#line 861
        if (tmp___19) {
          {
#line 862
          sprintf((char */* __restrict  */)(frstr[0]), (char const   */* __restrict  */)"%s",
                  "start ..\000");
#line 863
          sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"%d frames were read from %s",
                  nframe - k, inmv);
#line 864
          strcat((char */* __restrict  */)(curf), (char const   */* __restrict  */)(inmv));
#line 865
          WriteStatus(win);
          }
        } else {
          {
#line 867
          sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"No frames in %s",
                  inmv);
          }
        }
#line 868
        startup = 0;
      }
#line 871
      if (! usepixmap) {
        {
#line 872
        XCopyArea(dpy, win, pixmap, gc, 0, 0, (unsigned int )igw, (unsigned int )igh,
                  0, 0);
        }
      }
      {
#line 873
      showline(win, 10, 8, (char *)"Done                          ", (char *)"", (char *)" ");
#line 877
      i = 0;
      }
      {
#line 878
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 878
        tmp___20 = XCheckTypedEvent(dpy, 2, & ev1);
        }
#line 878
        if (! tmp___20) {
#line 878
          goto while_break___6;
        }
#line 878
        i = 1;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 879
      if (i == 1) {
        {
#line 879
        XPutBackEvent(dpy, & ev1);
        }
      }
    }
    {
#line 883
    tmp___22 = strlen((char const   *)(emsg));
    }
#line 883
    if (tmp___22 > 0UL) {
      {
#line 884
      clearline(win, 10, 8);
#line 885
      showline(win, 10, 8, (char *)"+++ ", emsg, (char *)"");
#line 886
      showline(pixmap, 10, 8, (char *)"+++ ", emsg, (char *)"");
#line 887
      XBell(dpy, 30);
      }
    } else {
      {
#line 889
      tmp___21 = strlen((char const   *)(gmsg));
      }
#line 889
      if (tmp___21 > 0UL) {
        {
#line 890
        clearline(win, 10, 8);
#line 891
        showline(win, 10, 8, gmsg, (char *)"", (char *)"");
#line 892
        showline(pixmap, 10, 8, gmsg, (char *)"", (char *)"");
        }
      }
    }
#line 895
    if (! replot) {
#line 895
      if (wrinfo) {
#line 895
        if (chginfo) {
          {
#line 895
          WriteInfo(win);
          }
        }
      }
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 901
  if (num_print > 0) {
    {
#line 901
    hardcopy_close();
    }
  }
  {
#line 902
  XFreeGC(dpy, gc);
#line 903
  XDestroyWindow(dpy, win);
#line 904
  XCloseDisplay(dpy);
  }
#line 905
  return (0);
}
}
#line 908 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
int interpret_keypress(XEvent *ev , int *inpmode , char *input , int *ixyz , float *alfa ) 
{ 
  int count___0 ;
  int l ;
  char buff[8] ;
  KeySym key ;
  size_t tmp ;

  {
  {
#line 915
  count___0 = XLookupString(& ev->xkey, buff, 8, & key, (XComposeStatus *)0);
  }
#line 917
  if (*inpmode) {
    {
#line 918
    tmp = strlen((char const   *)input);
#line 918
    l = (int )tmp;
    }
#line 919
    if (key == 65362UL) {
#line 920
      if (svline == 0) {
        {
#line 920
        strcpy((char */* __restrict  */)(svinput[0]), (char const   */* __restrict  */)input);
        }
      }
#line 921
      if (svline < nsvline - 1) {
#line 921
        svline ++;
      }
      {
#line 922
      strcpy((char */* __restrict  */)input, (char const   */* __restrict  */)(svinput[svline]));
      }
#line 923
      return (5);
    }
#line 925
    if (key == 65364UL) {
#line 926
      if (svline > 0) {
#line 926
        svline --;
      }
      {
#line 927
      strcpy((char */* __restrict  */)input, (char const   */* __restrict  */)(svinput[svline]));
      }
#line 928
      return (5);
    }
#line 930
    if (key == 65364UL) {
      {
#line 930
      strcpy((char */* __restrict  */)input, (char const   */* __restrict  */)"");
      }
#line 930
      return (5);
    }
#line 931
    if (key == 65293UL) {
#line 931
      *inpmode = 0;
#line 931
      return (6);
    }
#line 932
    if (key == 65288UL) {
#line 932
      goto _L;
    } else
#line 932
    if (key == 65361UL) {
      _L: /* CIL Label */ 
#line 933
      if (l > 0) {
#line 933
        *(input + (l - 1)) = (char )'\000';
      }
#line 933
      return (5);
    }
#line 935
    if (count___0 > 0) {
#line 935
      *(input + l) = buff[0];
#line 935
      *(input + (l + 1)) = (char )'\000';
    }
#line 936
    return (5);
  }
#line 939
  if (key == 93UL) {
#line 940
    if (iframe == nframe - 1) {
      {
#line 940
      sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"Last frame");
      }
#line 940
      return (0);
    }
#line 941
    iframe += fstep;
#line 942
    if (iframe >= nframe) {
#line 942
      iframe = nframe - 1;
    }
#line 943
    return (3);
  }
#line 946
  if (key == 91UL) {
#line 947
    if (iframe == 0) {
      {
#line 947
      sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"First frame");
      }
#line 947
      return (0);
    }
#line 948
    iframe -= fstep;
#line 949
    if (iframe <= 0) {
#line 949
      iframe = 0;
    }
#line 950
    return (3);
  }
#line 953
  if (key == 92UL) {
    {
#line 954
    saveframe = iframe;
#line 955
    sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"Marked frame %d",
            saveframe + 1);
    }
#line 956
    return (0);
  }
#line 959
  if (key == 124UL) {
#line 960
    if (saveframe == -99) {
      {
#line 960
      sprintf((char */* __restrict  */)(emsg), (char const   */* __restrict  */)"No frame was marked");
      }
#line 960
      return (0);
    }
#line 961
    if (saveframe < 0) {
      {
#line 962
      sprintf((char */* __restrict  */)(emsg), (char const   */* __restrict  */)"Marked frame %d does not exist",
              saveframe + 1);
      }
#line 962
      return (0);
    } else
#line 961
    if (saveframe >= nframe) {
      {
#line 962
      sprintf((char */* __restrict  */)(emsg), (char const   */* __restrict  */)"Marked frame %d does not exist",
              saveframe + 1);
      }
#line 962
      return (0);
    }
#line 963
    if (iframe == saveframe) {
      {
#line 963
      sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"Already at frame %d",
              saveframe + 1);
      }
#line 963
      return (0);
    }
    {
#line 964
    iframe = saveframe;
#line 965
    sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"Go back to frame %d",
            saveframe + 1);
    }
#line 966
    return (3);
  }
#line 969
  if (key == 123UL) {
#line 969
    iframe = 0;
#line 969
    return (3);
  }
#line 970
  if (key == 125UL) {
#line 970
    iframe = nframe - 1;
#line 970
    return (3);
  }
#line 972
  if (key == 81UL) {
#line 972
    return (1);
  }
#line 973
  if (key == 85UL) {
#line 973
    return (4);
  }
#line 974
  if (key == 104UL) {
#line 974
    wrhelp = 1 - wrhelp;
#line 974
    return (2);
  }
#line 976
  if (key == 105UL) {
    {
#line 976
    strcpy((char */* __restrict  */)input, (char const   */* __restrict  */)"");
#line 976
    *inpmode = 1;
#line 976
    svline = 0;
    }
#line 976
    return (5);
  }
#line 978
  *alfa = (float )0;
#line 978
  *ixyz = 0;
#line 979
  if (key == 65363UL) {
#line 979
    *alfa = dalfa;
#line 979
    *ixyz = 1;
#line 979
    return (2);
  }
#line 980
  if (key == 65361UL) {
#line 980
    *alfa = - dalfa;
#line 980
    *ixyz = 1;
#line 980
    return (2);
  }
#line 981
  if (key == 65362UL) {
#line 981
    *alfa = - dalfa;
#line 981
    *ixyz = 2;
#line 981
    return (2);
  }
#line 982
  if (key == 65364UL) {
#line 982
    *alfa = dalfa;
#line 982
    *ixyz = 2;
#line 982
    return (2);
  }
#line 983
  if (key == 44UL) {
#line 983
    *alfa = dalfa;
#line 983
    *ixyz = 3;
#line 983
    return (2);
  }
#line 984
  if (key == 46UL) {
#line 984
    *alfa = - dalfa;
#line 984
    *ixyz = 3;
#line 984
    return (2);
  }
#line 986
  if (key == 112UL) {
#line 986
    pmode ++;
#line 986
    if (pmode == 3) {
#line 986
      pmode = 0;
    }
#line 986
    return (2);
  }
#line 987
  if (key == 80UL) {
#line 987
    pmode --;
#line 987
    if (pmode == -1) {
#line 987
      pmode = 2;
    }
#line 987
    return (2);
  }
#line 989
  if (key == 100UL) {
#line 989
    dist0 = (float )((double )dist0 * 1.05);
#line 989
    return (2);
  }
#line 990
  if (key == 68UL) {
#line 990
    dist0 = (float )((double )dist0 / 1.05);
#line 990
    return (2);
  }
#line 991
  if (key == 114UL) {
#line 991
    return (2);
  }
#line 992
  if (key == 43UL) {
#line 993
    scale = (float )((double )scale * 1.05);
#line 993
    return (2);
  } else
#line 992
  if (key == 65451UL) {
#line 993
    scale = (float )((double )scale * 1.05);
#line 993
    return (2);
  }
#line 994
  if (key == 45UL) {
#line 995
    scale = (float )((double )scale / 1.05);
#line 995
    return (2);
  } else
#line 994
  if (key == 65453UL) {
#line 995
    scale = (float )((double )scale / 1.05);
#line 995
    return (2);
  }
#line 997
  if (key == 65462UL) {
#line 997
    taux += dtaux;
#line 997
    return (2);
  }
#line 998
  if (key == 65460UL) {
#line 998
    taux -= dtaux;
#line 998
    return (2);
  }
#line 999
  if (key == 65464UL) {
#line 999
    tauy += dtauy;
#line 999
    return (2);
  }
#line 1000
  if (key == 65458UL) {
#line 1000
    tauy -= dtauy;
#line 1000
    return (2);
  }
#line 1001
  if (key == 65463UL) {
#line 1001
    taux = taux0;
#line 1001
    tauy = tauy0;
#line 1001
    return (2);
  }
#line 1002
  if (key == 65450UL) {
    {
#line 1003
    taux0 = taux;
#line 1003
    tauy0 = tauy;
#line 1004
    sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"New home position: %.2f %.2f",
            (double )taux0, (double )tauy0);
#line 1005
    chginfo = 1;
    }
#line 1006
    return (0);
  }
#line 1009
  if (key == 108UL) {
#line 1010
    bline = 1 - bline;
#line 1011
    if (withbonds) {
#line 1011
      return (2);
    }
#line 1012
    chginfo = 1;
#line 1013
    if (bline) {
      {
#line 1013
      sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"Bonds as lines       ");
      }
    } else {
      {
#line 1014
      sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"Bonds as cylinders   ");
      }
    }
#line 1015
    return (0);
  }
#line 1018
  if (key == 76UL) {
#line 1019
    showlines ++;
#line 1020
    if (showlines == 3) {
#line 1020
      showlines = 0;
    }
#line 1021
    chginfo = 1;
#line 1022
    if (showlines == 1) {
      {
#line 1022
      sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"Draw extra lines lines       ");
      }
    }
#line 1023
    if (showlines == 2) {
      {
#line 1023
      sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"Dash extra lines lines       ");
      }
    }
#line 1024
    if (showlines == 0) {
      {
#line 1024
      sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"Supress extra lines lines    ");
      }
    }
#line 1025
    if (nxline > 0) {
#line 1025
      return (2);
    }
  }
#line 1028
  if (key == 115UL) {
#line 1028
    shadow = 1 - shadow;
#line 1028
    return (2);
  }
#line 1030
  if (key == 97UL) {
#line 1030
    showaxes = 1 - showaxes;
#line 1030
    return (2);
  }
#line 1032
  if (key == 119UL) {
#line 1032
    wire = 1 - wire;
#line 1032
    return (2);
  }
#line 1034
  if (key == 120UL) {
#line 1035
    chginfo = 1;
#line 1036
    usepixmap = 1 - usepixmap;
#line 1037
    if (usepixmap) {
      {
#line 1037
      sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"Draw to pixmap buffer");
      }
    } else {
      {
#line 1038
      sprintf((char */* __restrict  */)(gmsg), (char const   */* __restrict  */)"Draw to screen");
      }
    }
#line 1039
    chginfo = 1;
#line 1040
    return (0);
  }
#line 1043
  if (key == 32UL) {
#line 1043
    wrinfo = 1 - wrinfo;
#line 1043
    return (2);
  }
#line 1045
  if (key == 98UL) {
#line 1045
    withbonds = 1 - withbonds;
#line 1045
    return (2);
  }
#line 1046
  if (key == 110UL) {
#line 1047
    numbers ++;
#line 1047
    if (numbers == 3) {
#line 1047
      numbers = 0;
    }
#line 1047
    return (2);
  }
#line 1049
  if (key == 99UL) {
#line 1049
    coords = 1 - coords;
#line 1049
    return (2);
  }
#line 1050
  if (key == 78UL) {
#line 1050
    bondnums = 1 - bondnums;
#line 1050
    return (2);
  }
#line 1051
  if (key == 103UL) {
#line 1051
    grayvalues = 1 - grayvalues;
#line 1051
    return (2);
  }
#line 1052
  return (0);
}
}
#line 1057 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
void wln(char *x ) 
{ 
  int xx ;
  size_t tmp ;

  {
#line 1061
  if (! startup) {
#line 1062
    xx = xln;
#line 1063
    if (xx < 1) {
#line 1063
      xx = 1;
    }
    {
#line 1064
    tmp = strlen((char const   *)x);
#line 1064
    XDrawString(dpy, drw, labelgc, xx, 10 * lnum, (char const   *)x, (int )tmp);
#line 1065
    lnum ++;
    }
  } else {
    {
#line 1068
    printf((char const   */* __restrict  */)"%s\n", x);
    }
  }
#line 1070
  return;
}
}
#line 1073 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
void WriteHelp(void) 
{ 


  {
  {
#line 1075
  lnum = 1;
#line 1078
  xln = igw - 250;
#line 1079
  wln((char *)" ");
#line 1080
  wln((char *)"COMMANDS for input line:");
#line 1081
  wln((char *)"  help  cmd         - on-line help");
#line 1082
  wln((char *)"  inc   degrees     - rotation increment");
#line 1083
  wln((char *)"  pos   x y         - set position");
#line 1084
  wln((char *)"  dpos  dxy         - shift increment");
#line 1085
  wln((char *)"  dist  d           - set distance");
#line 1086
  wln((char *)"  rfac  fac         - scale all radii");
#line 1087
  wln((char *)"  bfac  fac         - scale all bonds");
#line 1088
  wln((char *)"  scale fac         - scale plot");
#line 1089
  wln((char *)"  gramp slope mid   - gray ramp");
#line 1090
  wln((char *)"  light x y z       - light direction");
#line 1091
  wln((char *)"  step  n           - set frame step");
#line 1092
  wln((char *)"  dup   x y z       - duplicate");
#line 1093
  wln((char *)"  cut   x y z a b   - planar cut");
#line 1094
  wln((char *)"  frm   n           - go to frame");
#line 1095
  wln((char *)"  color pat cname   - query or set color");
#line 1096
  wln((char *)"  save   fname      - save data");
#line 1097
  wln((char *)"  update fname      - update from file");
#line 1098
  wln((char *)"  print  fname      - postscript output");
#line 1099
  wln((char *)"  close             - close print file");
#line 1102
  xln = igw - 200;
#line 1103
  wln((char *)" ");
#line 1104
  wln((char *)"KEYS (KP=Keypad):");
#line 1105
  wln((char *)"  i        activate input line");
#line 1106
  wln((char *)"  h        help");
#line 1107
  wln((char *)"  space    info");
#line 1108
  wln((char *)"  cursor   rotate R/L, U/D");
#line 1109
  wln((char *)"  , .      rotate in plane");
#line 1110
  wln((char *)"  + -      zoom");
#line 1111
  wln((char *)"  KP 8642  shift plot");
#line 1112
  wln((char *)"  KP 7     shift home");
#line 1113
  wln((char *)"  KP *     set home");
#line 1114
  wln((char *)"  r        redraw");
#line 1115
  wln((char *)"  n        atom numbers");
#line 1116
  wln((char *)"  c        coordinates");
#line 1117
  wln((char *)"  N        bond lengths");
#line 1118
  wln((char *)"  w        wire mode");
#line 1119
  wln((char *)"  g        gray/bw");
#line 1120
  wln((char *)"  b        bonds");
#line 1121
  wln((char *)"  l        cylinders/lines");
#line 1122
  wln((char *)"  L        extra lines");
#line 1123
  wln((char *)"  p        perspective");
#line 1124
  wln((char *)"  a        show axes");
#line 1125
  wln((char *)"  s        line shadows");
#line 1126
  wln((char *)"  x        pixmap buffer");
#line 1127
  wln((char *)"  d D      distance");
#line 1128
  wln((char *)"  [ ]      step frames fw/bk");
#line 1129
  wln((char *)"  { }      first/last frame");
#line 1130
  wln((char *)"  \\ |      mark/goto frame");
#line 1131
  wln((char *)"  U        update from file");
#line 1132
  wln((char *)"  Q        quit");
#line 1135
  xln = igw - 250;
#line 1136
  wln((char *)" ");
#line 1137
  wln((char *)"INPUT data format:");
#line 1138
  wln((char *)"  atom   label x y z ");
#line 1139
  wln((char *)"  spec   label radius color");
#line 1140
  wln((char *)"  bonds  lab1 lab2 min max radius color");
#line 1141
  wln((char *)"  frame  str   x1 ..   - add frame");
#line 1142
  wln((char *)"  tmat   t1 .. t9      - viewpoint");
#line 1143
  wln((char *)"Also commands which set parameters");
  }
#line 1145
  return;
}
}
#line 1148 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
void WriteInfo(Drawable draw ) 
{ 
  float x1 ;
  float x2 ;
  float y1___0 ;
  float y2 ;
  float z1 ;
  float z2 ;
  char str[201] ;
  char stt[201] ;
  char gmd[3][8] ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 1153
  gmd[0][0] = (char )'s';
#line 1153
  gmd[0][1] = (char )'t';
#line 1153
  gmd[0][2] = (char )'d';
#line 1153
  gmd[0][3] = (char )'\000';
#line 1153
  tmp = 4U;
  {
#line 1153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1153
    if (tmp >= 8U) {
#line 1153
      goto while_break;
    }
#line 1153
    gmd[0][tmp] = (char)0;
#line 1153
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1153
  gmd[1][0] = (char )'r';
#line 1153
  gmd[1][1] = (char )'a';
#line 1153
  gmd[1][2] = (char )'m';
#line 1153
  gmd[1][3] = (char )'p';
#line 1153
  gmd[1][4] = (char )'\000';
#line 1153
  tmp___0 = 5U;
  {
#line 1153
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1153
    if (tmp___0 >= 8U) {
#line 1153
      goto while_break___0;
    }
#line 1153
    gmd[1][tmp___0] = (char)0;
#line 1153
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1153
  gmd[2][0] = (char )'l';
#line 1153
  gmd[2][1] = (char )'i';
#line 1153
  gmd[2][2] = (char )'g';
#line 1153
  gmd[2][3] = (char )'h';
#line 1153
  gmd[2][4] = (char )'t';
#line 1153
  gmd[2][5] = (char )'\000';
#line 1153
  tmp___1 = 6U;
  {
#line 1153
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1153
    if (tmp___1 >= 8U) {
#line 1153
      goto while_break___1;
    }
#line 1153
    gmd[2][tmp___1] = (char)0;
#line 1153
    tmp___1 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1155
  get_extent(& x1, & x2, & y1___0, & y2, & z1, & z2);
  }
#line 1156
  if (natom == 1) {
    {
#line 1156
    sprintf((char */* __restrict  */)(str), (char const   */* __restrict  */)"%d atom, ",
            natom);
    }
  } else {
    {
#line 1157
    sprintf((char */* __restrict  */)(str), (char const   */* __restrict  */)"%d atoms, ",
            natom);
    }
  }
#line 1158
  if (nbond == 1) {
    {
#line 1158
    sprintf((char */* __restrict  */)(stt), (char const   */* __restrict  */)"%d bond ",
            nbond);
    }
  } else {
    {
#line 1159
    sprintf((char */* __restrict  */)(stt), (char const   */* __restrict  */)"%d bonds",
            nbond);
    }
  }
  {
#line 1160
  showline(draw, 10, igh - 20, (char *)"", str, stt);
#line 1161
  sprintf((char */* __restrict  */)(str), (char const   */* __restrict  */)"extent x %.2f to %.2f,  y %.2f to %.2f,  z %.2f to %.2f",
          (double )x1, (double )x2, (double )y1___0, (double )y2, (double )z1, (double )z2);
#line 1163
  showline(draw, 10, igh - 30, (char *)"", str, (char *)"");
#line 1164
  sprintf((char */* __restrict  */)(str), (char const   */* __restrict  */)"tmat %6.3f %6.3f %6.3f %6.3f %6.3f %6.3f %6.3f %6.3f %6.3f",
          (double )tmat[0][0], (double )tmat[0][1], (double )tmat[0][2], (double )tmat[1][0],
          (double )tmat[1][1], (double )tmat[1][2], (double )tmat[2][0], (double )tmat[2][1],
          (double )tmat[2][2]);
#line 1167
  showline(draw, 10, igh - 40, (char *)"", str, (char *)"");
#line 1168
  sprintf((char */* __restrict  */)(str), (char const   */* __restrict  */)"dist %.2f, scale %.2f, rfac %.2f, bfac %.2f",
          (double )dist0, (double )scale, (double )radfac, (double )bndfac);
#line 1170
  showline(draw, 10, igh - 50, (char *)"", str, (char *)"");
#line 1171
  sprintf((char */* __restrict  */)(str), (char const   */* __restrict  */)"gmode %s, ramp,slope %.2f %.2f, light %.2f %.2f %.2f",
          gmd[gmode], (double )gslope, (double )gz0, (double )light[0], (double )light[1],
          (double )light[2]);
#line 1173
  showline(draw, 10, igh - 60, (char *)"", str, (char *)"");
#line 1174
  sprintf((char */* __restrict  */)(str), (char const   */* __restrict  */)"pos (%.1f,%.1f), dpos %.1f, home (%.1f,%.1f)",
          (double )taux, (double )tauy, (double )dtaux, (double )taux0, (double )tauy0);
#line 1176
  showline(draw, 10, igh - 70, (char *)"", str, (char *)"");
#line 1177
  sprintf((char */* __restrict  */)(str), (char const   */* __restrict  */)"color %d, reverse %d, stippled %d, pixmap %d, gray %d, bonds %d, lines %d",
          color, reverse, stippled, usepixmap, grayvalues, withbonds, bline);
#line 1181
  showline(draw, 10, igh - 80, (char *)"", str, (char *)"");
#line 1182
  sprintf((char */* __restrict  */)(str), (char const   */* __restrict  */)"input %s %s, save %s, print %s, nprint=%d",
          inf, inmv, outf, prf, num_print);
#line 1184
  showline(draw, 10, igh - 90, (char *)"", str, (char *)"");
  }
#line 1185
  return;
}
}
#line 1189 "/home/june/repo/benchmarks/collector2/temp/xbs-0/xbs.c"
void WriteStatus(Drawable draw ) 
{ 
  char pers[3][8] ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  char str[201] ;

  {
#line 1191
  pers[0][0] = (char )'o';
#line 1191
  pers[0][1] = (char )'f';
#line 1191
  pers[0][2] = (char )'f';
#line 1191
  pers[0][3] = (char )'\000';
#line 1191
  tmp = 4U;
  {
#line 1191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1191
    if (tmp >= 8U) {
#line 1191
      goto while_break;
    }
#line 1191
    pers[0][tmp] = (char)0;
#line 1191
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1191
  pers[1][0] = (char )'p';
#line 1191
  pers[1][1] = (char )'s';
#line 1191
  pers[1][2] = (char )'e';
#line 1191
  pers[1][3] = (char )'u';
#line 1191
  pers[1][4] = (char )'d';
#line 1191
  pers[1][5] = (char )'o';
#line 1191
  pers[1][6] = (char )'\000';
#line 1191
  tmp___0 = 7U;
  {
#line 1191
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1191
    if (tmp___0 >= 8U) {
#line 1191
      goto while_break___0;
    }
#line 1191
    pers[1][tmp___0] = (char)0;
#line 1191
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1191
  pers[2][0] = (char )'t';
#line 1191
  pers[2][1] = (char )'r';
#line 1191
  pers[2][2] = (char )'u';
#line 1191
  pers[2][3] = (char )'e';
#line 1191
  pers[2][4] = (char )'\000';
#line 1191
  tmp___1 = 5U;
  {
#line 1191
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1191
    if (tmp___1 >= 8U) {
#line 1191
      goto while_break___1;
    }
#line 1191
    pers[2][tmp___1] = (char)0;
#line 1191
    tmp___1 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1194
  sprintf((char */* __restrict  */)(str), (char const   */* __restrict  */)" %5.2f %5.2f %5.2f   inc=%.1f   d=%.2f   p=%s",
          (double )tmat[2][0], (double )tmat[2][1], (double )tmat[2][2], (double )dalfa,
          (double )dist0, pers[pmode]);
#line 1199
  showline(draw, 10, 20, (char *)"View:", str, (char *)"");
#line 1200
  sprintf((char */* __restrict  */)(str), (char const   */* __restrict  */)"Frame %3d of %d (step %d)  <%s>",
          iframe + 1, nframe, fstep, frstr[iframe]);
#line 1202
  showline(draw, 10, 44, (char *)"Files: ", curf, (char *)"");
#line 1203
  showline(draw, 10, 32, str, (char *)"", (char *)"");
  }
#line 1205
  return;
}
}
