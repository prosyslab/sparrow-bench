/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 30 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 80 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/header.h"
typedef void *yaddr;
#line 81 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/header.h"
typedef yaddr yterm;
#line 82 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/header.h"
typedef u_char ychar;
#line 84 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/header.h"
typedef u_int ylong;
#line 91 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/header.h"
struct __anonstruct_y_parm_59 {
   u_char w_rows ;
   u_char w_cols ;
   char protocol ;
   char pad1 ;
   short vmajor ;
   short vminor ;
   u_short rows ;
   u_short cols ;
   u_short my_rows ;
   u_short my_cols ;
   ylong pid ;
   char pad[44] ;
};
#line 91 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/header.h"
typedef struct __anonstruct_y_parm_59 y_parm;
#line 104 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/header.h"
struct __anonstruct_vt_60 {
   char got_esc ;
   int av[4] ;
   u_int ac ;
   char lparen ;
   char hash ;
};
#line 104 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/header.h"
struct __anonstruct_gt_61 {
   char got_gt ;
   char *buf ;
   char type ;
   int len ;
   char *version ;
};
#line 104 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/header.h"
struct _yuser {
   struct _yuser *next ;
   struct _yuser *unext ;
   int fd ;
   int output_fd ;
   ylong flags ;
   ychar edit[4] ;
   char crlf ;
   u_short t_rows ;
   u_short t_cols ;
   u_short rows ;
   u_short cols ;
   y_parm remote ;
   ychar **scr ;
   char *scr_tabs ;
   char bump ;
   char onend ;
   ychar old_rub ;
   ychar key ;
   int y ;
   int x ;
   int sy ;
   int sx ;
   int sc_top ;
   int sc_bot ;
   char region_set ;
   char *full_name ;
   char *user_name ;
   char *host_name ;
   char *host_fqdn ;
   char *tty_name ;
   ylong host_addr ;
   int daemon ;
   ylong l_id ;
   ylong r_id ;
   ylong d_id ;
   ylong last_invite ;
   struct sockaddr_in sock ;
   struct sockaddr_in orig_sock ;
   int dbuf_size ;
   ychar *dbuf ;
   ychar *dptr ;
   int drain ;
   void (*dfunc)() ;
   int got_oob ;
   struct __anonstruct_vt_60 vt ;
   struct __anonstruct_gt_61 gt ;
   yterm term ;
};
#line 104 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/header.h"
typedef struct _yuser yuser;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.h"
struct __anonstruct_menu_item_66 {
   char *item ;
   void (*func)() ;
   ychar key ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.h"
typedef struct __anonstruct_menu_item_66 menu_item;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 299 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/header.h"
struct alias {
   char from[256] ;
   char to[256] ;
   int type ;
   struct alias *next ;
};
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 150 "/usr/include/curses.h"
typedef unsigned long chtype;
#line 358
struct _win_st;
#line 358 "/usr/include/curses.h"
typedef struct _win_st WINDOW;
#line 360 "/usr/include/curses.h"
typedef chtype attr_t;
#line 405
struct ldat;
#line 407 "/usr/include/curses.h"
struct pdat {
   short _pad_y ;
   short _pad_x ;
   short _pad_top ;
   short _pad_left ;
   short _pad_bottom ;
   short _pad_right ;
};
#line 407 "/usr/include/curses.h"
struct _win_st {
   short _cury ;
   short _curx ;
   short _maxy ;
   short _maxx ;
   short _begy ;
   short _begx ;
   short _flags ;
   attr_t _attrs ;
   chtype _bkgd ;
   _Bool _notimeout ;
   _Bool _clear ;
   _Bool _leaveok ;
   _Bool _scroll ;
   _Bool _idlok ;
   _Bool _idcok ;
   _Bool _immed ;
   _Bool _sync ;
   _Bool _use_keypad ;
   int _delay ;
   struct ldat *_line ;
   short _regtop ;
   short _regbottom ;
   int _parx ;
   int _pary ;
   WINDOW *_parent ;
   struct pdat _pad ;
   short _yoffset ;
};
#line 36 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/cwin.c"
struct _ywin {
   struct _ywin *next ;
   yuser *user ;
   WINDOW *win ;
   int height ;
   int width ;
   int row ;
   int col ;
   char *title ;
};
#line 36 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/cwin.c"
typedef struct _ywin ywin;
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 48 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/fd.c"
struct fd_func {
   void (*func)() ;
};
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 43 "/usr/include/x86_64-linux-gnu/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 209 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/header.h"
struct __anonstruct_v3_pack_62 {
   ychar code ;
   char filler[3] ;
   ylong host_addr ;
   ylong pid ;
   char name[16] ;
   char host[64] ;
};
#line 209 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/header.h"
typedef struct __anonstruct_v3_pack_62 v3_pack;
#line 223 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/header.h"
struct __anonstruct_v3_flags_63 {
   ychar code ;
   char filler[3] ;
   ylong flags ;
};
#line 223 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/header.h"
typedef struct __anonstruct_v3_flags_63 v3_flags;
#line 233 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/header.h"
struct __anonstruct_v3_winch_64 {
   ychar code ;
   char filler[3] ;
   u_short rows ;
   u_short cols ;
};
#line 233 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/header.h"
typedef struct __anonstruct_v3_winch_64 v3_winch;
#line 249 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/header.h"
struct __anonstruct_v2_pack_65 {
   ychar code ;
   char filler ;
   char name[12] ;
   char host[64] ;
};
#line 249 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/header.h"
typedef struct __anonstruct_v2_pack_65 v2_pack;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 257 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 27 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.h"
struct _talkd {
   struct sockaddr_in sock ;
   int fd ;
   short port ;
   yaddr mptr ;
   size_t mlen ;
   yaddr rptr ;
   size_t rlen ;
};
#line 37 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.h"
struct _hostinfo {
   struct _hostinfo *next ;
   ylong host_addr ;
   int dtype ;
};
#line 37 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.h"
typedef struct _hostinfo hostinfo;
#line 43 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.h"
struct _readdr {
   struct _readdr *next ;
   ylong from_addr ;
   ylong from_mask ;
   ylong addr ;
   ylong mask ;
   ylong id_addr ;
   ylong id_mask ;
};
#line 43 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.h"
typedef struct _readdr readdr;
#line 61 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.h"
struct bsd42_sockaddr_in {
   u_short sin_family ;
   u_short sin_port ;
   struct in_addr sin_addr ;
   char sin_zero[8] ;
};
#line 61 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.h"
typedef struct bsd42_sockaddr_in BSD42_SOCK;
#line 71 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.h"
struct __anonstruct_CTL_MSG_67 {
   char type ;
   char l_name[9] ;
   char r_name[9] ;
   char filler ;
   ylong id_num ;
   ylong pid ;
   char r_tty[16] ;
   BSD42_SOCK addr ;
   BSD42_SOCK ctl_addr ;
};
#line 71 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.h"
typedef struct __anonstruct_CTL_MSG_67 CTL_MSG;
#line 86 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.h"
struct __anonstruct_CTL_RESPONSE_68 {
   char type ;
   char answer ;
   u_short filler ;
   ylong id_num ;
   BSD42_SOCK addr ;
};
#line 86 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.h"
typedef struct __anonstruct_CTL_RESPONSE_68 CTL_RESPONSE;
#line 99 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.h"
struct __anonstruct_CTL_MSG42_69 {
   u_char vers ;
   char type ;
   u_short filler ;
   ylong id_num ;
   BSD42_SOCK addr ;
   BSD42_SOCK ctl_addr ;
   ylong pid ;
   char l_name[12] ;
   char r_name[12] ;
   char r_tty[16] ;
};
#line 99 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.h"
typedef struct __anonstruct_CTL_MSG42_69 CTL_MSG42;
#line 115 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.h"
struct __anonstruct_CTL_RESPONSE42_70 {
   u_char vers ;
   char type ;
   char answer ;
   char filler ;
   ylong id_num ;
   BSD42_SOCK addr ;
};
#line 115 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.h"
typedef struct __anonstruct_CTL_RESPONSE42_70 CTL_RESPONSE42;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 324 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/header.h"
void move_term(yuser *user , int y , int x ) ;
#line 325
void fill_term(yuser *user , int y1 , int x1 , int y2 , int x2 , ychar c ) ;
#line 326
void clreol_term(yuser *user ) ;
#line 327
void clreos_term(yuser *user ) ;
#line 328
void scroll_term(yuser *user ) ;
#line 329
void rev_scroll_term(yuser *user ) ;
#line 335
void newline_term(yuser *user ) ;
#line 336
void lf_term(yuser *user ) ;
#line 337
void add_line_term(yuser *user , int num ) ;
#line 338
void del_line_term(yuser *user , int num ) ;
#line 339
void add_char_term(yuser *user , int num ) ;
#line 340
void del_char_term(yuser *user , int num ) ;
#line 341
void redraw_term(yuser *user , int y ) ;
#line 342
void keypad_term(yuser *user , int bf ) ;
#line 346
void set_scroll_region(yuser *user , int top , int bottom ) ;
#line 402
void vt100_process(yuser *user , char data ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/vt100.c"
void vt100_process(yuser *user , char data ) 
{ 
  int i ;

  {
#line 31
  if ((int )data >= 48) {
#line 31
    if ((int )data <= 57) {
#line 32
      if ((int )user->vt.got_esc > 1) {
#line 33
        user->vt.av[user->vt.ac] = user->vt.av[user->vt.ac] * 10 + ((int )data - 48);
#line 34
        return;
      }
#line 36
      if ((int )user->vt.hash == 1) {
#line 36
        if ((int )data == 56) {
          {
#line 37
          fill_term(user, 0, 0, (int )user->rows - 1, (int )user->cols - 1, 'E');
#line 38
          redraw_term(user, 0);
#line 39
          user->vt.got_esc = (char)0;
          }
#line 40
          return;
        }
      }
    }
  }
  {
#line 45
  if ((int )data == 59) {
#line 45
    goto case_59;
  }
#line 49
  if ((int )data == 91) {
#line 49
    goto case_91;
  }
#line 52
  if ((int )data == 63) {
#line 52
    goto case_63;
  }
#line 58
  if ((int )data == 69) {
#line 58
    goto case_69;
  }
#line 62
  if ((int )data == 35) {
#line 62
    goto case_35;
  }
#line 65
  if ((int )data == 99) {
#line 65
    goto case_99;
  }
#line 69
  if ((int )data == 8) {
#line 69
    goto case_8;
  }
#line 73
  if ((int )data == 11) {
#line 73
    goto case_11;
  }
#line 76
  if ((int )data == 13) {
#line 76
    goto case_13;
  }
#line 79
  if ((int )data == 115) {
#line 79
    goto case_115;
  }
#line 88
  if ((int )data == 117) {
#line 88
    goto case_117;
  }
#line 96
  if ((int )data == 104) {
#line 96
    goto case_104;
  }
#line 104
  if ((int )data == 108) {
#line 104
    goto case_108;
  }
#line 112
  if ((int )data == 61) {
#line 112
    goto case_61;
  }
#line 116
  if ((int )data == 62) {
#line 116
    goto case_62;
  }
#line 120
  if ((int )data == 64) {
#line 120
    goto case_64;
  }
#line 129
  if ((int )data == 65) {
#line 129
    goto case_65;
  }
#line 138
  if ((int )data == 66) {
#line 138
    goto case_66;
  }
#line 151
  if ((int )data == 67) {
#line 151
    goto case_67;
  }
#line 162
  if ((int )data == 68) {
#line 162
    goto case_68;
  }
#line 179
  if ((int )data == 72) {
#line 179
    goto case_72;
  }
#line 179
  if ((int )data == 102) {
#line 179
    goto case_72;
  }
#line 192
  if ((int )data == 71) {
#line 192
    goto case_71;
  }
#line 200
  if ((int )data == 103) {
#line 200
    goto case_103;
  }
#line 214
  if ((int )data == 74) {
#line 214
    goto case_74;
  }
#line 233
  if ((int )data == 75) {
#line 233
    goto case_75;
  }
#line 251
  if ((int )data == 76) {
#line 251
    goto case_76;
  }
#line 260
  if ((int )data == 77) {
#line 260
    goto case_77;
  }
#line 273
  if ((int )data == 80) {
#line 273
    goto case_80;
  }
#line 282
  if ((int )data == 83) {
#line 282
    goto case_83;
  }
#line 286
  if ((int )data == 114) {
#line 286
    goto case_114;
  }
#line 297
  if ((int )data == 40) {
#line 297
    goto case_40;
  }
#line 300
  if ((int )data == 48) {
#line 300
    goto case_48;
  }
#line 305
  if ((int )data == 55) {
#line 305
    goto case_55;
  }
#line 310
  if ((int )data == 56) {
#line 310
    goto case_56;
  }
#line 314
  goto switch_default___0;
  case_59: /* CIL Label */ 
#line 46
  if (user->vt.ac < 3U) {
#line 47
    (user->vt.ac) ++;
#line 47
    user->vt.av[user->vt.ac] = 0;
  }
#line 48
  goto switch_break;
  case_91: /* CIL Label */ 
#line 50
  user->vt.got_esc = (char)2;
#line 51
  goto switch_break;
  case_63: /* CIL Label */ 
#line 53
  if ((int )user->vt.got_esc == 2) {
#line 54
    user->vt.got_esc = (char)3;
  } else {
#line 56
    user->vt.got_esc = (char)0;
  }
#line 57
  goto switch_break;
  case_69: /* CIL Label */ 
  {
#line 59
  newline_term(user);
#line 60
  user->vt.got_esc = (char)0;
  }
#line 61
  goto switch_break;
  case_35: /* CIL Label */ 
#line 63
  user->vt.hash = (char)1;
#line 64
  goto switch_break;
  case_99: /* CIL Label */ 
  {
#line 66
  write(user->fd, (void const   *)"\033[0c", (size_t )4);
#line 67
  user->vt.got_esc = (char)0;
  }
#line 68
  goto switch_break;
  case_8: /* CIL Label */ 
#line 70
  if (user->x > 0) {
    {
#line 71
    move_term(user, user->y, user->x - 1);
    }
  }
#line 72
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 74
  lf_term(user);
  }
#line 75
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 77
  move_term(user, user->y, 0);
  }
#line 78
  goto switch_break;
  case_115: /* CIL Label */ 
#line 80
  if ((int )user->vt.got_esc != 2) {
#line 81
    user->vt.got_esc = (char)0;
#line 82
    goto switch_break;
  }
#line 84
  user->sy = user->y;
#line 85
  user->sx = user->x;
#line 86
  user->vt.got_esc = (char)0;
#line 87
  goto switch_break;
  case_117: /* CIL Label */ 
#line 89
  if ((int )user->vt.got_esc != 2) {
#line 90
    user->vt.got_esc = (char)0;
#line 91
    goto switch_break;
  }
  {
#line 93
  move_term(user, user->sy, user->sx);
#line 94
  user->vt.got_esc = (char)0;
  }
#line 95
  goto switch_break;
  case_104: /* CIL Label */ 
  {
#line 98
  if (user->vt.av[0] == 1) {
#line 98
    goto case_1;
  }
#line 97
  goto switch_break___0;
  case_1: /* CIL Label */ 
  {
#line 99
  keypad_term(user, 1);
  }
#line 100
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 102
  user->vt.got_esc = (char)0;
#line 103
  goto switch_break;
  case_108: /* CIL Label */ 
  {
#line 106
  if (user->vt.av[0] == 1) {
#line 106
    goto case_1___0;
  }
#line 105
  goto switch_break___1;
  case_1___0: /* CIL Label */ 
  {
#line 107
  keypad_term(user, 0);
  }
#line 108
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 110
  user->vt.got_esc = (char)0;
#line 111
  goto switch_break;
  case_61: /* CIL Label */ 
  {
#line 113
  keypad_term(user, 1);
#line 114
  user->vt.got_esc = (char)0;
  }
#line 115
  goto switch_break;
  case_62: /* CIL Label */ 
  {
#line 117
  keypad_term(user, 0);
#line 118
  user->vt.got_esc = (char)0;
  }
#line 119
  goto switch_break;
  case_64: /* CIL Label */ 
#line 121
  if ((int )user->vt.got_esc == 2) {
#line 122
    if (user->vt.av[0] == 0) {
      {
#line 123
      add_char_term(user, 1);
      }
    } else {
      {
#line 125
      add_char_term(user, user->vt.av[0]);
      }
    }
  }
#line 127
  user->vt.got_esc = (char)0;
#line 128
  goto switch_break;
  case_65: /* CIL Label */ 
#line 130
  if (user->vt.av[0] == 0) {
    {
#line 131
    move_term(user, user->y - 1, user->x);
    }
  } else
#line 132
  if (user->vt.av[0] > user->y) {
    {
#line 133
    move_term(user, 0, user->x);
    }
  } else {
    {
#line 135
    move_term(user, user->y - user->vt.av[0], user->x);
    }
  }
#line 136
  user->vt.got_esc = (char)0;
#line 137
  goto switch_break;
  case_66: /* CIL Label */ 
#line 139
  if (user->vt.lparen) {
#line 140
    user->vt.lparen = (char)0;
  } else
#line 142
  if (user->y != (int )user->rows) {
#line 143
    if (user->vt.av[0] == 0) {
      {
#line 144
      move_term(user, user->y + 1, user->x);
      }
    } else {
      {
#line 146
      move_term(user, user->y + user->vt.av[0], user->x);
      }
    }
  }
#line 149
  user->vt.got_esc = (char)0;
#line 150
  goto switch_break;
  case_67: /* CIL Label */ 
#line 152
  if ((int )user->vt.got_esc == 2) {
#line 153
    if (user->x != (int )user->cols) {
#line 154
      if (user->vt.av[0] == 0) {
        {
#line 155
        move_term(user, user->y, user->x + 1);
        }
      } else {
        {
#line 157
        move_term(user, user->y, user->x + user->vt.av[0]);
        }
      }
    }
  }
#line 160
  user->vt.got_esc = (char)0;
#line 161
  goto switch_break;
  case_68: /* CIL Label */ 
#line 163
  if ((int )user->vt.got_esc == 2) {
#line 164
    if (user->vt.av[0] == 0) {
      {
#line 165
      move_term(user, user->y, user->x - 1);
      }
    } else
#line 166
    if (user->vt.av[0] > user->x) {
      {
#line 167
      move_term(user, user->y, 0);
      }
    } else {
      {
#line 169
      move_term(user, user->y, user->x - user->vt.av[0]);
      }
    }
  } else
#line 171
  if (user->y < user->sc_bot) {
#line 172
    (user->y) ++;
  } else {
    {
#line 174
    scroll_term(user);
    }
  }
#line 176
  user->vt.got_esc = (char)0;
#line 177
  goto switch_break;
  case_72: /* CIL Label */ 
  case_102: /* CIL Label */ 
#line 180
  if ((int )user->vt.got_esc == 2) {
#line 181
    if (user->vt.av[0] > 0) {
#line 182
      (user->vt.av[0]) --;
    }
#line 183
    if (user->vt.av[1] > 0) {
#line 184
      (user->vt.av[1]) --;
    }
    {
#line 185
    move_term(user, user->vt.av[0], user->vt.av[1]);
    }
  } else
#line 187
  if ((int )data == 72) {
#line 188
    *(user->scr_tabs + user->x) = (char)1;
  }
#line 190
  user->vt.got_esc = (char)0;
#line 191
  goto switch_break;
  case_71: /* CIL Label */ 
#line 193
  if ((int )user->vt.got_esc == 2) {
#line 194
    if (user->vt.av[0] > 0) {
#line 195
      (user->vt.av[0]) --;
    }
    {
#line 196
    move_term(user, user->y, user->vt.av[0]);
    }
  }
#line 198
  user->vt.got_esc = (char)0;
#line 199
  goto switch_break;
  case_103: /* CIL Label */ 
#line 201
  if ((int )user->vt.got_esc == 2) {
    {
#line 203
    if (user->vt.av[0] == 3) {
#line 203
      goto case_3;
    }
#line 207
    if (user->vt.av[0] == 0) {
#line 207
      goto case_0;
    }
#line 202
    goto switch_break___2;
    case_3: /* CIL Label */ 
#line 204
    i = 0;
    {
#line 204
    while (1) {
      while_continue: /* CIL Label */ ;
#line 204
      if (! (i < (int )user->t_cols)) {
#line 204
        goto while_break;
      }
#line 205
      *(user->scr_tabs + i) = (char)0;
#line 204
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 206
    goto switch_break___2;
    case_0: /* CIL Label */ 
#line 208
    *(user->scr_tabs + user->x) = (char)0;
#line 209
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
  }
#line 212
  user->vt.got_esc = (char)0;
#line 213
  goto switch_break;
  case_74: /* CIL Label */ 
#line 215
  if ((int )user->vt.got_esc == 2) {
    {
#line 217
    if (user->vt.av[0] == 1) {
#line 217
      goto case_1___1;
    }
#line 223
    if (user->vt.av[0] == 2) {
#line 223
      goto case_2;
    }
#line 227
    goto switch_default;
    case_1___1: /* CIL Label */ 
#line 218
    if (user->x > 0) {
      {
#line 219
      fill_term(user, 0, 0, user->y - 1, (int )user->cols - 1, ' ');
      }
    }
    {
#line 220
    fill_term(user, user->y, 0, user->y, user->x, ' ');
#line 221
    redraw_term(user, 0);
    }
#line 222
    goto switch_break___3;
    case_2: /* CIL Label */ 
    {
#line 224
    fill_term(user, 0, 0, (int )user->rows - 1, (int )user->cols - 1, ' ');
#line 225
    redraw_term(user, 0);
    }
#line 226
    goto switch_break___3;
    switch_default: /* CIL Label */ 
    {
#line 228
    clreos_term(user);
    }
    switch_break___3: /* CIL Label */ ;
    }
  }
#line 231
  user->vt.got_esc = (char)0;
#line 232
  goto switch_break;
  case_75: /* CIL Label */ 
#line 234
  if ((int )user->vt.got_esc == 2) {
    {
#line 236
    if (user->vt.av[0] == 0) {
#line 236
      goto case_0___0;
    }
#line 239
    if (user->vt.av[0] == 1) {
#line 239
      goto case_1___2;
    }
#line 243
    if (user->vt.av[0] == 2) {
#line 243
      goto case_2___0;
    }
#line 235
    goto switch_break___4;
    case_0___0: /* CIL Label */ 
    {
#line 237
    clreol_term(user);
    }
#line 238
    goto switch_break___4;
    case_1___2: /* CIL Label */ 
    {
#line 240
    fill_term(user, user->y, 0, user->y, user->x, ' ');
#line 241
    redraw_term(user, 0);
    }
#line 242
    goto switch_break___4;
    case_2___0: /* CIL Label */ 
    {
#line 244
    fill_term(user, user->y, 0, user->y, (int )user->cols - 1, ' ');
#line 245
    redraw_term(user, 0);
    }
#line 246
    goto switch_break___4;
    switch_break___4: /* CIL Label */ ;
    }
  }
#line 249
  user->vt.got_esc = (char)0;
#line 250
  goto switch_break;
  case_76: /* CIL Label */ 
#line 252
  if ((int )user->vt.got_esc == 2) {
#line 253
    if (user->vt.av[0] == 0) {
      {
#line 254
      add_line_term(user, 1);
      }
    } else {
      {
#line 256
      add_line_term(user, user->vt.av[0]);
      }
    }
  }
#line 258
  user->vt.got_esc = (char)0;
#line 259
  goto switch_break;
  case_77: /* CIL Label */ 
#line 261
  if ((int )user->vt.got_esc == 2) {
#line 262
    if (user->vt.av[0] == 0) {
      {
#line 263
      del_line_term(user, 1);
      }
    } else {
      {
#line 265
      del_line_term(user, user->vt.av[0]);
      }
    }
  } else
#line 267
  if (user->y > user->sc_top) {
#line 268
    (user->y) --;
  } else {
    {
#line 270
    rev_scroll_term(user);
    }
  }
#line 271
  user->vt.got_esc = (char)0;
#line 272
  goto switch_break;
  case_80: /* CIL Label */ 
#line 274
  if ((int )user->vt.got_esc == 2) {
#line 275
    if (user->vt.av[0] == 0) {
      {
#line 276
      del_char_term(user, 1);
      }
    } else {
      {
#line 278
      del_char_term(user, user->vt.av[0]);
      }
    }
  }
#line 280
  user->vt.got_esc = (char)0;
#line 281
  goto switch_break;
  case_83: /* CIL Label */ 
  {
#line 283
  scroll_term(user);
#line 284
  user->vt.got_esc = (char)0;
  }
#line 285
  goto switch_break;
  case_114: /* CIL Label */ 
#line 287
  if ((int )user->vt.got_esc == 2) {
#line 288
    if (user->vt.av[0] > 0) {
#line 289
      (user->vt.av[0]) --;
    }
#line 290
    if (user->vt.av[1] > 0) {
#line 291
      (user->vt.av[1]) --;
    }
    {
#line 292
    set_scroll_region(user, user->vt.av[0], user->vt.av[1]);
#line 293
    move_term(user, 0, 0);
    }
  }
#line 295
  user->vt.got_esc = (char)0;
#line 296
  goto switch_break;
  case_40: /* CIL Label */ 
#line 298
  user->vt.lparen = (char)1;
#line 299
  goto switch_break;
  case_48: /* CIL Label */ 
#line 301
  if (user->vt.lparen) {
#line 302
    user->vt.lparen = (char)0;
  }
#line 303
  user->vt.got_esc = (char)0;
#line 304
  goto switch_break;
  case_55: /* CIL Label */ 
#line 306
  user->sy = user->y;
#line 307
  user->sx = user->x;
#line 308
  user->vt.got_esc = (char)0;
#line 309
  goto switch_break;
  case_56: /* CIL Label */ 
  {
#line 311
  move_term(user, user->sy, user->sx);
#line 312
  user->vt.got_esc = (char)0;
  }
#line 313
  goto switch_break;
  switch_default___0: /* CIL Label */ 
#line 315
  user->vt.got_esc = (char)0;
  switch_break: /* CIL Label */ ;
  }
#line 317
  return;
}
}
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 277 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/header.h"
yuser *me ;
#line 290
int running_process ;
#line 312
void bail(int n ) ;
#line 314
void show_error(char *str ) ;
#line 316
void init_term(void) ;
#line 317
void set_terminal_size(int fd , int rows , int cols ) ;
#line 318
void set_terminal_flags(int fd ) ;
#line 319
int what_term(void) ;
#line 320
void end_term(void) ;
#line 321
int open_term(yuser *user , char *title ) ;
#line 322
void close_term(yuser *user ) ;
#line 323
void addch_term(yuser *user , ychar c ) ;
#line 330
void flush_term(yuser *user ) ;
#line 331
void rub_term(yuser *user ) ;
#line 332
void word_term(yuser *user ) ;
#line 333
void kill_term(yuser *user ) ;
#line 334
void tab_term(yuser *user ) ;
#line 343
void resize_win(yuser *user , int height , int width ) ;
#line 344
void set_win_region(yuser *user , int height , int width ) ;
#line 345
void end_win_region(yuser *user ) ;
#line 347
void msg_term(yuser *user , char *str ) ;
#line 348
void spew_term(yuser *user , int fd , int rows , int cols ) ;
#line 349
int center(int width , int n ) ;
#line 350
void redraw_all_terms(void) ;
#line 351
void set_raw_term(void) ;
#line 352
void set_cooked_term(void) ;
#line 371
void send_winch(yuser *user ) ;
#line 372
void send_region(void) ;
#line 373
void send_end_region(void) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/mem.h"
yaddr get_mem(size_t n ) ;
#line 45
yaddr realloc_mem(yaddr p , size_t n ) ;
#line 46
void free_mem(yaddr addr ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 66 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
#line 70
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/cwin.h"
void init_curses(void) ;
#line 22
void end_curses(void) ;
#line 23
int open_curses(yuser *user , char *title ) ;
#line 24
void close_curses(yuser *user ) ;
#line 25
void addch_curses(yuser *user , ychar c ) ;
#line 26
void move_curses(yuser *user , int y , int x ) ;
#line 27
void clreol_curses(yuser *user ) ;
#line 28
void clreos_curses(yuser *user ) ;
#line 29
void scroll_curses(yuser *user ) ;
#line 30
void keypad_curses(_Bool bf ) ;
#line 31
void flush_curses(yuser *user ) ;
#line 32
void redisplay_curses(void) ;
#line 33
void set_raw_curses(void) ;
#line 34
void set_cooked_curses(void) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.h"
menu_item *menu_ptr ;
#line 37
void update_menu(void) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/term.c"
static int term_type  =    0;
#line 52 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/term.c"
static struct termios tio  ;
#line 86 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/term.c"
static void init_termios(void) 
{ 
  int tmp___0 ;

  {
  {
#line 91
  tmp___0 = tcgetattr(0, & tio);
  }
#line 91
  if (tmp___0 < 0) {
    {
#line 92
    show_error("tcgetattr failed");
#line 93
    bail(1);
    }
  }
#line 95
  me->old_rub = tio.c_cc[2];
#line 96
  me->edit[0] = (ychar )254;
#line 98
  me->edit[1] = tio.c_cc[3];
#line 103
  me->edit[2] = tio.c_cc[14];
#line 104
  if ((int )me->edit[2] == 255) {
#line 105
    me->edit[2] = (ychar )'\027';
  }
#line 109
  me->edit[3] = (ychar )'\024';
#line 110
  return;
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/term.c"
void init_term(void) 
{ 
  char tmpstr[64] ;
  int tmp___0 ;

  {
  {
#line 124
  init_termios();
#line 127
  init_curses();
#line 128
  term_type = 1;
#line 133
  snprintf((char */* __restrict  */)(tmpstr), sizeof(tmpstr), (char const   */* __restrict  */)"YTalk version %s",
           "3.3.0");
#line 137
  tmp___0 = open_term(me, tmpstr);
  }
#line 137
  if (tmp___0 < 0) {
    {
#line 138
    end_term();
#line 139
    show_error("init_term: open_term() failed");
#line 140
    bail(0);
    }
  }
#line 142
  return;
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/term.c"
void set_terminal_size(int fd , int rows , int cols ) 
{ 
  struct winsize winsize ;

  {
  {
#line 154
  winsize.ws_row = (unsigned short )rows;
#line 155
  winsize.ws_col = (unsigned short )cols;
#line 156
  ioctl(fd, 21524UL, & winsize);
  }
#line 158
  return;
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/term.c"
void set_terminal_flags(int fd ) 
{ 
  int tmp___0 ;

  {
  {
#line 174
  tmp___0 = tcsetattr(fd, 0, (struct termios  const  *)(& tio));
  }
#line 174
  if (tmp___0 < 0) {
    {
#line 175
    show_error("tcsetattr failed");
    }
  }
#line 177
  return;
}
}
#line 179 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/term.c"
int what_term(void) 
{ 


  {
#line 182
  return (term_type);
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/term.c"
void keypad_term(yuser *user , int bf ) 
{ 


  {
#line 193
  if ((unsigned long )user != (unsigned long )me) {
#line 194
    return;
  }
#line 195
  if (term_type == 1) {
    {
#line 196
    keypad_curses(bf);
    }
  }
#line 197
  return;
}
}
#line 202 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/term.c"
void end_term(void) 
{ 


  {
#line 205
  if (term_type == 1) {
    {
#line 206
    end_curses();
    }
  }
#line 207
  term_type = 0;
#line 208
  return;
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/term.c"
int open_term(yuser *user , char *title ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 218
  tmp___0 = open_curses(user, title);
  }
#line 218
  if (tmp___0 != 0) {
#line 219
    return (-1);
  }
#line 220
  tmp___1 = 0;
#line 220
  user->y = tmp___1;
#line 220
  user->x = tmp___1;
#line 221
  if ((unsigned long )user->scr == (unsigned long )((void *)0)) {
    {
#line 222
    resize_win(user, 24, 80);
    }
  }
#line 223
  return (0);
}
}
#line 229 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/term.c"
void close_term(yuser *user ) 
{ 
  register int i ;
  u_short tmp___0 ;
  u_short tmp___1 ;

  {
#line 235
  if (user->scr) {
    {
#line 236
    close_curses(user);
#line 237
    i = 0;
    }
    {
#line 237
    while (1) {
      while_continue: /* CIL Label */ ;
#line 237
      if (! (i < (int )user->t_rows)) {
#line 237
        goto while_break;
      }
      {
#line 238
      free_mem(*(user->scr + i));
#line 237
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 239
    free_mem(user->scr);
#line 240
    user->scr = (ychar **)((void *)0);
#line 241
    free_mem(user->scr_tabs);
#line 242
    user->scr_tabs = (char *)((void *)0);
#line 243
    tmp___0 = (u_short )0;
#line 243
    user->rows = tmp___0;
#line 243
    user->t_rows = tmp___0;
#line 244
    tmp___1 = (u_short )0;
#line 244
    user->cols = tmp___1;
#line 244
    user->t_cols = tmp___1;
    }
  }
#line 246
  return;
}
}
#line 251 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/term.c"
void addch_term(yuser *user , ychar c ) 
{ 


  {
#line 256
  if ((int )c >= 32) {
#line 256
    if ((int )c <= 126) {
#line 256
      goto _L;
    } else {
#line 256
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 256
  if ((int )c >= 160) {
    _L: /* CIL Label */ 
#line 256
    if ((int )c != 254) {
      {
#line 257
      addch_curses(user, (int )c);
#line 258
      *(*(user->scr + user->y) + user->x) = c;
#line 259
      (user->x) ++;
      }
#line 259
      if (user->x >= (int )user->cols) {
#line 260
        user->bump = (char)1;
#line 261
        user->x = (int )user->cols - 1;
#line 262
        if ((int )user->cols < (int )user->t_cols) {
          {
#line 263
          move_curses(user, user->y, user->x);
          }
        }
      }
    }
  }
#line 266
  return;
}
}
#line 271 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/term.c"
void move_term(yuser *user , int y , int x ) 
{ 


  {
#line 276
  if (y < 0) {
#line 277
    y = user->sc_bot;
  } else
#line 276
  if (y > user->sc_bot) {
#line 277
    y = user->sc_bot;
  }
#line 278
  if (x < 0) {
#line 279
    user->bump = (char)1;
#line 280
    x = (int )user->cols - 1;
  } else
#line 278
  if (x >= (int )user->cols) {
#line 279
    user->bump = (char)1;
#line 280
    x = (int )user->cols - 1;
  } else {
#line 282
    user->bump = (char)0;
#line 283
    user->onend = (char)0;
  }
  {
#line 285
  move_curses(user, y, x);
#line 286
  user->y = y;
#line 287
  user->x = x;
  }
#line 288
  return;
}
}
#line 293 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/term.c"
void fill_term(yuser *user , int y1 , int x1 , int y2 , int x2 , ychar c ) 
{ 
  int y ;
  int x ;

  {
#line 300
  y = y1;
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 300
    if (! (y <= y2)) {
#line 300
      goto while_break;
    }
#line 301
    x = x1;
    {
#line 301
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 301
      if (! (x <= x2)) {
#line 301
        goto while_break___0;
      }
#line 302
      *(*(user->scr + y) + x) = c;
#line 301
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 300
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 303
  return;
}
}
#line 309 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/term.c"
void clreol_term(yuser *user ) 
{ 
  register int j ;
  register ychar *c ;
  ychar *tmp___0 ;
  ychar *tmp___1 ;

  {
#line 316
  if ((int )user->cols < (int )user->t_cols) {
#line 317
    c = *(user->scr + user->y) + user->x;
#line 318
    j = user->x;
    {
#line 318
    while (1) {
      while_continue: /* CIL Label */ ;
#line 318
      if (! (j < (int )user->cols)) {
#line 318
        goto while_break;
      }
      {
#line 319
      tmp___0 = c;
#line 319
      c ++;
#line 319
      *tmp___0 = (ychar )' ';
#line 320
      addch_curses(user, ' ');
#line 318
      j ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 322
    move_term(user, user->y, user->x);
    }
  } else {
    {
#line 324
    clreol_curses(user);
#line 325
    c = *(user->scr + user->y) + user->x;
#line 326
    j = user->x;
    }
    {
#line 326
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 326
      if (! (j < (int )user->cols)) {
#line 326
        goto while_break___0;
      }
#line 327
      tmp___1 = c;
#line 327
      c ++;
#line 327
      *tmp___1 = (ychar )' ';
#line 326
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 329
  return;
}
}
#line 334 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/term.c"
void clreos_term(yuser *user ) 
{ 
  register int j ;
  register int i ;
  register ychar *c ;
  int x ;
  int y ;
  ychar *tmp___0 ;

  {
#line 342
  if ((int )user->cols < (int )user->t_cols) {
#line 342
    goto _L;
  } else
#line 342
  if ((int )user->rows < (int )user->t_rows) {
    _L: /* CIL Label */ 
    {
#line 343
    x = user->x;
#line 344
    y = user->y;
#line 345
    clreol_term(user);
#line 346
    i = user->y + 1;
    }
    {
#line 346
    while (1) {
      while_continue: /* CIL Label */ ;
#line 346
      if (! (i < (int )user->rows)) {
#line 346
        goto while_break;
      }
      {
#line 347
      move_term(user, i, 0);
#line 348
      clreol_term(user);
#line 346
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 350
    move_term(user, y, x);
    }
  } else {
    {
#line 352
    clreos_curses(user);
#line 353
    j = user->x;
#line 354
    i = user->y;
    }
    {
#line 354
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 354
      if (! (i < (int )user->rows)) {
#line 354
        goto while_break___0;
      }
#line 355
      c = *(user->scr + i) + j;
      {
#line 356
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 356
        if (! (j < (int )user->cols)) {
#line 356
          goto while_break___1;
        }
#line 357
        tmp___0 = c;
#line 357
        c ++;
#line 357
        *tmp___0 = (ychar )' ';
#line 356
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 358
      j = 0;
#line 354
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 361
  return;
}
}
#line 366 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/term.c"
void scroll_term(yuser *user ) 
{ 
  register int i ;
  register ychar *c ;
  int sy ;
  int sx ;
  ychar *tmp___0 ;

  {
#line 374
  if (user->sc_bot > user->sc_top) {
#line 375
    c = *(user->scr + user->sc_top);
#line 376
    i = user->sc_top;
    {
#line 376
    while (1) {
      while_continue: /* CIL Label */ ;
#line 376
      if (! (i < user->sc_bot)) {
#line 376
        goto while_break;
      }
#line 377
      *(user->scr + i) = *(user->scr + (i + 1));
#line 376
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 378
    *(user->scr + user->sc_bot) = c;
#line 379
    i = 0;
    {
#line 379
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 379
      if (! (i < (int )user->cols)) {
#line 379
        goto while_break___0;
      }
#line 380
      tmp___0 = c;
#line 380
      c ++;
#line 380
      *tmp___0 = (ychar )' ';
#line 379
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 381
    if ((int )user->rows == (int )user->t_rows) {
#line 381
      if ((int )user->cols == (int )user->t_cols) {
#line 381
        if (user->sc_top == 0) {
#line 381
          if (user->sc_bot == (int )user->rows - 1) {
            {
#line 385
            scroll_curses(user);
            }
          } else {
            {
#line 387
            redraw_term(user, 0);
            }
          }
        } else {
          {
#line 387
          redraw_term(user, 0);
          }
        }
      } else {
        {
#line 387
        redraw_term(user, 0);
        }
      }
    } else {
      {
#line 387
      redraw_term(user, 0);
      }
    }
  } else {
    {
#line 389
    sy = user->y;
#line 390
    sx = user->x;
#line 391
    move_term(user, user->sc_top, 0);
#line 392
    clreol_term(user);
#line 393
    move_term(user, sy, sx);
    }
  }
#line 395
  return;
}
}
#line 400 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/term.c"
void rev_scroll_term(yuser *user ) 
{ 
  register int i ;
  register ychar *c ;
  int sy ;
  int sx ;
  ychar *tmp___0 ;

  {
#line 408
  if (user->sc_bot > user->sc_top) {
#line 409
    c = *(user->scr + user->sc_bot);
#line 410
    i = user->sc_bot;
    {
#line 410
    while (1) {
      while_continue: /* CIL Label */ ;
#line 410
      if (! (i > user->sc_top)) {
#line 410
        goto while_break;
      }
#line 411
      *(user->scr + i) = *(user->scr + (i - 1));
#line 410
      i --;
    }
    while_break: /* CIL Label */ ;
    }
#line 412
    *(user->scr + user->sc_top) = c;
#line 413
    i = 0;
    {
#line 413
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 413
      if (! (i < (int )user->cols)) {
#line 413
        goto while_break___0;
      }
#line 414
      tmp___0 = c;
#line 414
      c ++;
#line 414
      *tmp___0 = (ychar )' ';
#line 413
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 415
    redraw_term(user, 0);
    }
  } else {
    {
#line 417
    sy = user->y;
#line 418
    sx = user->x;
#line 419
    move_term(user, user->sc_top, 0);
#line 420
    clreol_term(user);
#line 421
    move_term(user, sy, sx);
    }
  }
#line 423
  return;
}
}
#line 428 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/term.c"
void flush_term(yuser *user ) 
{ 


  {
  {
#line 432
  flush_curses(user);
  }
#line 433
  return;
}
}
#line 438 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/term.c"
void rub_term(yuser *user ) 
{ 


  {
#line 442
  if (user->x > 0) {
#line 443
    if (user->x == (int )user->cols - 1) {
#line 444
      user->onend = (char)0;
    }
#line 445
    if (user->bump) {
      {
#line 446
      addch_term(user, (ychar )' ');
#line 447
      user->bump = (char)0;
      }
    } else {
      {
#line 449
      move_term(user, user->y, user->x - 1);
#line 450
      addch_term(user, (ychar )' ');
#line 451
      move_term(user, user->y, user->x - 1);
      }
    }
  }
#line 455
  return;
}
}
#line 460 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/term.c"
void word_term(yuser *user ) 
{ 
  register int x ;

  {
#line 466
  x = user->x - 1;
  {
#line 466
  while (1) {
    while_continue: /* CIL Label */ ;
#line 466
    if (x >= 0) {
#line 466
      if (! ((int )*(*(user->scr + user->y) + x) == 32)) {
#line 466
        goto while_break;
      }
    } else {
#line 466
      goto while_break;
    }
#line 467
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 466
    x --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 468
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 468
    if (x >= 0) {
#line 468
      if (! ((int )*(*(user->scr + user->y) + x) != 32)) {
#line 468
        goto while_break___0;
      }
    } else {
#line 468
      goto while_break___0;
    }
#line 469
    goto __Cont___0;
    __Cont___0: /* CIL Label */ 
#line 468
    x --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 470
  x ++;
#line 470
  if (user->x - x <= 0) {
#line 471
    return;
  }
  {
#line 472
  move_term(user, user->y, x);
#line 473
  clreol_term(user);
  }
#line 474
  return;
}
}
#line 480 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/term.c"
void kill_term(yuser *user ) 
{ 


  {
#line 484
  if (user->x > 0) {
    {
#line 485
    move_term(user, user->y, 0);
#line 486
    clreol_term(user);
    }
  }
#line 488
  return;
}
}
#line 493 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/term.c"
void tab_term(yuser *user ) 
{ 
  int i ;

  {
#line 499
  if (user->x < (int )user->t_cols) {
#line 500
    i = user->x + 1;
    {
#line 500
    while (1) {
      while_continue: /* CIL Label */ ;
#line 500
      if (! (i <= (int )user->t_cols)) {
#line 500
        goto while_break;
      }
#line 501
      if ((int )*(user->scr_tabs + i) == 1) {
        {
#line 502
        move_term(user, user->y, i);
        }
#line 503
        goto while_break;
      }
#line 500
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 507
  return;
}
}
#line 512 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/term.c"
void lf_term(yuser *user ) 
{ 
  register int new_y ;
  register int next_y ;

  {
#line 518
  new_y = user->y + 1;
#line 519
  if ((long )user->flags & 1L) {
#line 520
    if (new_y > user->sc_bot) {
#line 521
      if ((long )user->flags & 2L) {
        {
#line 522
        scroll_term(user);
        }
      }
    }
    {
#line 524
    move_term(user, new_y, user->x);
    }
  } else {
#line 526
    if (new_y > user->sc_bot) {
#line 527
      if ((long )user->flags & 2L) {
        {
#line 528
        scroll_term(user);
#line 529
        move_term(user, user->y, user->x);
        }
#line 530
        return;
      }
#line 532
      new_y = 0;
    }
#line 534
    next_y = new_y + 1;
#line 535
    if (next_y >= (int )user->rows) {
#line 536
      next_y = 0;
    }
#line 537
    if (next_y > 0) {
      {
#line 538
      move_term(user, next_y, user->x);
#line 539
      clreol_term(user);
      }
    } else
#line 537
    if (! ((long )user->flags & 2L)) {
      {
#line 538
      move_term(user, next_y, user->x);
#line 539
      clreol_term(user);
      }
    }
    {
#line 541
    move_term(user, new_y, user->x);
    }
  }
#line 543
  return;
}
}
#line 548 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/term.c"
void newline_term(yuser *user ) 
{ 
  register int new_y ;
  register int next_y ;

  {
#line 554
  new_y = user->y + 1;
#line 555
  if ((long )user->flags & 1L) {
#line 556
    if (new_y > user->sc_bot) {
#line 557
      if ((long )user->flags & 2L) {
        {
#line 558
        scroll_term(user);
        }
      }
    }
    {
#line 560
    move_term(user, new_y, 0);
    }
  } else {
#line 562
    if (new_y > user->sc_bot) {
#line 563
      if ((long )user->flags & 2L) {
        {
#line 564
        scroll_term(user);
#line 565
        move_term(user, user->y, 0);
        }
#line 566
        return;
      }
#line 568
      new_y = 0;
    }
#line 570
    next_y = new_y + 1;
#line 571
    if (next_y >= (int )user->rows) {
#line 572
      next_y = 0;
    }
#line 573
    if (next_y > 0) {
      {
#line 574
      move_term(user, next_y, 0);
#line 575
      clreol_term(user);
      }
    } else
#line 573
    if (! ((long )user->flags & 2L)) {
      {
#line 574
      move_term(user, next_y, 0);
#line 575
      clreol_term(user);
      }
    }
    {
#line 577
    move_term(user, new_y, 0);
#line 578
    clreol_term(user);
    }
  }
#line 580
  return;
}
}
#line 585 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/term.c"
void add_line_term(yuser *user , int num ) 
{ 
  register ychar *c ;
  register int i ;
  ychar *tmp___0 ;

  {
#line 593
  if (num == 1) {
#line 593
    if (user->y == 0) {
      {
#line 594
      rev_scroll_term(user);
      }
    } else {
#line 593
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 598
    i = ((int )user->rows - user->y) - num;
#line 599
    if (i <= 0) {
      {
#line 600
      i = user->x;
#line 601
      move_term(user, user->y, 0);
#line 602
      clreos_term(user);
#line 603
      move_term(user, user->y, i);
      }
#line 604
      return;
    }
#line 608
    i --;
    {
#line 608
    while (1) {
      while_continue: /* CIL Label */ ;
#line 608
      if (! (i >= 0)) {
#line 608
        goto while_break;
      }
#line 609
      c = *(user->scr + (user->y + i));
#line 610
      *(user->scr + (user->y + i)) = *(user->scr + ((user->y + i) + num));
#line 611
      *(user->scr + ((user->y + i) + num)) = c;
#line 608
      i --;
    }
    while_break: /* CIL Label */ ;
    }
#line 615
    num --;
    {
#line 615
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 615
      if (! (num >= 0)) {
#line 615
        goto while_break___0;
      }
#line 616
      c = *(user->scr + (user->y + num));
#line 617
      i = 0;
      {
#line 617
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 617
        if (! (i < (int )user->cols)) {
#line 617
          goto while_break___1;
        }
#line 618
        tmp___0 = c;
#line 618
        c ++;
#line 618
        *tmp___0 = (ychar )' ';
#line 617
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 615
      num --;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 620
    redraw_term(user, user->y);
    }
  }
#line 622
  return;
}
}
#line 627 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/term.c"
void del_line_term(yuser *user , int num ) 
{ 
  register ychar *c ;
  register int i ;
  ychar *tmp___0 ;

  {
#line 635
  if (num == 1) {
#line 635
    if (user->y == 0) {
      {
#line 636
      scroll_term(user);
      }
    } else {
#line 635
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 639
    i = ((int )user->rows - user->y) - num;
#line 640
    if (i <= 0) {
      {
#line 641
      i = user->x;
#line 642
      move_term(user, user->y, 0);
#line 643
      clreos_term(user);
#line 644
      move_term(user, user->y, i);
      }
#line 645
      return;
    }
    {
#line 649
    while (1) {
      while_continue: /* CIL Label */ ;
#line 649
      if (! (i > 0)) {
#line 649
        goto while_break;
      }
#line 650
      c = *(user->scr + ((int )user->rows - i));
#line 651
      *(user->scr + ((int )user->rows - i)) = *(user->scr + (((int )user->rows - i) - num));
#line 652
      *(user->scr + (((int )user->rows - i) - num)) = c;
#line 649
      i --;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 656
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 656
      if (! (num > 0)) {
#line 656
        goto while_break___0;
      }
#line 657
      c = *(user->scr + ((int )user->rows - num));
#line 658
      i = 0;
      {
#line 658
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 658
        if (! (i < (int )user->cols)) {
#line 658
          goto while_break___1;
        }
#line 659
        tmp___0 = c;
#line 659
        c ++;
#line 659
        *tmp___0 = (ychar )' ';
#line 658
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 656
      num --;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 661
    redraw_term(user, user->y);
    }
  }
#line 663
  return;
}
}
#line 665 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/term.c"
static void copy_text(ychar *fr , ychar *to , int count ) 
{ 
  ychar *tmp___0 ;
  ychar *tmp___1 ;

  {
#line 670
  if ((unsigned long )to < (unsigned long )fr) {
    {
#line 671
    while (1) {
      while_continue: /* CIL Label */ ;
#line 671
      if (! (count > 0)) {
#line 671
        goto while_break;
      }
#line 672
      tmp___0 = to;
#line 672
      to ++;
#line 672
      tmp___1 = fr;
#line 672
      fr ++;
#line 672
      *tmp___0 = *tmp___1;
#line 671
      count --;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 674
    fr += count;
#line 675
    to += count;
    {
#line 676
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 676
      if (! (count > 0)) {
#line 676
        goto while_break___0;
      }
#line 677
      to --;
#line 677
      fr --;
#line 677
      *to = *fr;
#line 676
      count --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 679
  return;
}
}
#line 684 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/term.c"
void add_char_term(yuser *user , int num ) 
{ 
  register ychar *c ;
  register int i ;
  ychar *tmp___0 ;
  ychar *tmp___1 ;

  {
#line 694
  i = ((int )user->cols - user->x) - num;
#line 695
  c = ((*(user->scr + user->y) + (int )user->cols) - num) - 1;
  {
#line 696
  while (1) {
    while_continue: /* CIL Label */ ;
#line 696
    if (i > 0) {
#line 696
      if (! ((int )*c == 32)) {
#line 696
        goto while_break;
      }
    } else {
#line 696
      goto while_break;
    }
#line 697
    c --;
#line 697
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 698
  if (i <= 0) {
    {
#line 699
    clreol_term(user);
    }
#line 700
    return;
  }
  {
#line 705
  c ++;
#line 706
  copy_text(c - i, (c - i) + num, i);
#line 707
  c -= i;
  }
  {
#line 707
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 707
    if (! (num > 0)) {
#line 707
      goto while_break___0;
    }
    {
#line 708
    tmp___0 = c;
#line 708
    c ++;
#line 708
    *tmp___0 = (ychar )' ';
#line 709
    addch_curses(user, ' ');
#line 707
    num --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 711
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 711
    if (! (i > 0)) {
#line 711
      goto while_break___1;
    }
    {
#line 712
    tmp___1 = c;
#line 712
    c ++;
#line 712
    addch_curses(user, (int )*tmp___1);
#line 711
    i --;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 713
  move_curses(user, user->y, user->x);
  }
#line 714
  return;
}
}
#line 719 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/term.c"
void del_char_term(yuser *user , int num ) 
{ 
  register ychar *c ;
  register int i ;
  ychar *tmp___0 ;
  ychar *tmp___1 ;

  {
#line 729
  i = ((int )user->cols - user->x) - num;
#line 730
  c = (*(user->scr + user->y) + (int )user->cols) - 1;
  {
#line 731
  while (1) {
    while_continue: /* CIL Label */ ;
#line 731
    if (i > 0) {
#line 731
      if (! ((int )*c == 32)) {
#line 731
        goto while_break;
      }
    } else {
#line 731
      goto while_break;
    }
#line 732
    c --;
#line 732
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 733
  if (i <= 0) {
    {
#line 734
    clreol_term(user);
    }
#line 735
    return;
  }
  {
#line 740
  c ++;
#line 741
  copy_text(c - i, (c - i) - num, i);
#line 742
  c -= i + num;
  }
  {
#line 742
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 742
    if (! (i > 0)) {
#line 742
      goto while_break___0;
    }
    {
#line 743
    tmp___0 = c;
#line 743
    c ++;
#line 743
    addch_curses(user, (int )*tmp___0);
#line 742
    i --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 744
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 744
    if (! (num > 0)) {
#line 744
      goto while_break___1;
    }
    {
#line 745
    tmp___1 = c;
#line 745
    c ++;
#line 745
    *tmp___1 = (ychar )' ';
#line 746
    addch_curses(user, ' ');
#line 744
    num --;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 748
  move_curses(user, user->y, user->x);
  }
#line 749
  return;
}
}
#line 754 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/term.c"
void redraw_term(yuser *user , int y ) 
{ 
  register int x ;
  register int spaces ;
  register ychar *c ;

  {
  {
#line 762
  while (1) {
    while_continue: /* CIL Label */ ;
#line 762
    if (! (y < (int )user->t_rows)) {
#line 762
      goto while_break;
    }
    {
#line 763
    move_curses(user, y, 0);
#line 764
    clreol_curses(user);
#line 765
    spaces = 0;
#line 766
    c = *(user->scr + y);
#line 767
    x = 0;
    }
    {
#line 767
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 767
      if (! (x < (int )user->t_cols)) {
#line 767
        goto while_break___0;
      }
#line 768
      if ((int )*c == 32) {
#line 769
        spaces ++;
      } else {
#line 771
        if (spaces) {
#line 772
          if (spaces <= 3) {
            {
#line 773
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 773
              if (! (spaces > 0)) {
#line 773
                goto while_break___1;
              }
              {
#line 774
              addch_curses(user, ' ');
#line 773
              spaces --;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
          } else {
            {
#line 776
            move_curses(user, y, x);
#line 777
            spaces = 0;
            }
          }
        }
        {
#line 780
        addch_curses(user, (int )*c);
        }
      }
#line 767
      x ++;
#line 767
      c ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 762
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 786
  if ((unsigned long )menu_ptr != (unsigned long )((void *)0)) {
    {
#line 787
    update_menu();
    }
  } else {
    {
#line 789
    move_curses(user, user->y, user->x);
    }
  }
#line 790
  return;
}
}
#line 796 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/term.c"
static int first_interesting_row(yuser *user , int height , int width ) 
{ 
  register int j ;
  register int i ;
  register ychar *c ;

  {
#line 804
  if (height < (int )user->t_rows) {
#line 805
    j = (user->y + 1) - height;
#line 806
    if (j < 0) {
#line 807
      j += (int )user->t_rows;
    }
  } else {
#line 809
    j = user->y + 1;
#line 810
    if (j >= (int )user->t_rows) {
#line 811
      j = 0;
    }
  }
  {
#line 813
  while (1) {
    while_continue: /* CIL Label */ ;
#line 813
    if (! (j != user->y)) {
#line 813
      goto while_break;
    }
#line 814
    if (width > (int )user->t_cols) {
#line 814
      i = (int )user->t_cols;
    } else {
#line 814
      i = width;
    }
#line 815
    c = *(user->scr + j);
    {
#line 815
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 815
      if (! (i > 0)) {
#line 815
        goto while_break___0;
      }
#line 816
      if ((int )*c != 32) {
#line 817
        goto while_break___0;
      }
#line 815
      i --;
#line 815
      c ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 818
    if (i > 0) {
#line 819
      goto while_break;
    }
#line 820
    j ++;
#line 820
    if (j >= (int )user->t_rows) {
#line 821
      j = 0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 823
  return (j);
}
}
#line 829 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/term.c"
void resize_win(yuser *user , int height , int width ) 
{ 
  register int j ;
  register int i ;
  register ychar *c ;
  register ychar **new_scr ;
  int new_y ;
  int y_pos ;
  yaddr tmp___0 ;
  u_short tmp___1 ;
  u_short tmp___2 ;
  yaddr tmp___3 ;
  yaddr tmp___4 ;
  ychar *tmp___5 ;
  yaddr tmp___6 ;
  ychar *tmp___7 ;
  u_short tmp___8 ;
  u_short tmp___9 ;

  {
#line 838
  if (height == (int )user->t_rows) {
#line 838
    if (width == (int )user->t_cols) {
#line 839
      return;
    }
  }
  {
#line 843
  new_y = -1;
#line 844
  y_pos = 0;
#line 845
  tmp___0 = get_mem((unsigned long )height * sizeof(ychar *));
#line 845
  new_scr = (ychar **)tmp___0;
  }
#line 846
  if ((unsigned long )user->scr == (unsigned long )((void *)0)) {
#line 847
    tmp___1 = (u_short )0;
#line 847
    user->rows = tmp___1;
#line 847
    user->t_rows = tmp___1;
#line 848
    tmp___2 = (u_short )0;
#line 848
    user->cols = tmp___2;
#line 848
    user->t_cols = tmp___2;
  } else
#line 849
  if (user->region_set) {
#line 852
    j = 0;
    {
#line 852
    while (1) {
      while_continue: /* CIL Label */ ;
#line 852
      if (j < height) {
#line 852
        if (! (j < (int )user->t_rows)) {
#line 852
          goto while_break;
        }
      } else {
#line 852
        goto while_break;
      }
#line 853
      *(new_scr + j) = *(user->scr + j);
#line 852
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 854
    new_y = j - 1;
#line 855
    y_pos = user->y;
    {
#line 856
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 856
      if (! (j < (int )user->t_rows)) {
#line 856
        goto while_break___0;
      }
      {
#line 857
      free_mem(*(user->scr + j));
#line 856
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 858
    free_mem(user->scr);
    }
  } else {
    {
#line 862
    j = first_interesting_row(user, height, width);
#line 863
    i = 0;
    }
    {
#line 863
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 863
      if (! (i < height)) {
#line 863
        goto while_break___1;
      }
#line 864
      new_y ++;
#line 864
      *(new_scr + new_y) = *(user->scr + j);
#line 865
      if (j == user->y) {
#line 866
        goto while_break___1;
      }
#line 867
      j ++;
#line 867
      if (j >= (int )user->t_rows) {
#line 868
        j = 0;
      }
#line 863
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 870
    i ++;
    {
#line 870
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 870
      if (! (i < (int )user->t_rows)) {
#line 870
        goto while_break___2;
      }
#line 871
      j ++;
#line 871
      if (j >= (int )user->t_rows) {
#line 872
        j = 0;
      }
      {
#line 873
      free_mem(*(user->scr + j));
#line 870
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 875
    y_pos = new_y;
#line 876
    free_mem(user->scr);
    }
  }
#line 878
  user->scr = new_scr;
#line 882
  if (width > (int )user->t_cols) {
#line 883
    i = 0;
    {
#line 883
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 883
      if (! (i <= new_y)) {
#line 883
        goto while_break___3;
      }
      {
#line 884
      tmp___3 = realloc_mem(*(user->scr + i), width);
#line 884
      *(user->scr + i) = (ychar *)tmp___3;
#line 885
      j = (int )user->t_cols;
      }
      {
#line 885
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 885
        if (! (j < width)) {
#line 885
          goto while_break___4;
        }
#line 886
        *(*(user->scr + i) + j) = (ychar )' ';
#line 885
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 883
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 889
    tmp___4 = realloc_mem(user->scr_tabs, (unsigned long )width * sizeof(char ));
#line 889
    user->scr_tabs = (char *)tmp___4;
#line 890
    j = (int )user->t_cols;
    }
    {
#line 890
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 890
      if (! (j < width)) {
#line 890
        goto while_break___5;
      }
#line 891
      if (j % 8 == 0) {
#line 892
        *(user->scr_tabs + j) = (char)1;
      } else {
#line 894
        *(user->scr_tabs + j) = (char)0;
      }
#line 890
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 897
    *(user->scr_tabs + (width - 1)) = (char)1;
  }
#line 899
  i = new_y + 1;
  {
#line 899
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 899
    if (! (i < height)) {
#line 899
      goto while_break___6;
    }
    {
#line 900
    tmp___6 = get_mem(width);
#line 900
    tmp___5 = (ychar *)tmp___6;
#line 900
    *(user->scr + i) = tmp___5;
#line 900
    c = tmp___5;
#line 901
    j = 0;
    }
    {
#line 901
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 901
      if (! (j < width)) {
#line 901
        goto while_break___7;
      }
#line 902
      tmp___7 = c;
#line 902
      c ++;
#line 902
      *tmp___7 = (ychar )' ';
#line 901
      j ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 899
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 907
  tmp___8 = (u_short )height;
#line 907
  user->rows = tmp___8;
#line 907
  user->t_rows = tmp___8;
#line 908
  tmp___9 = (u_short )width;
#line 908
  user->cols = tmp___9;
#line 908
  user->t_cols = tmp___9;
#line 909
  user->sc_top = 0;
#line 910
  user->sc_bot = height - 1;
#line 911
  move_term(user, y_pos, user->x);
#line 912
  send_winch(user);
#line 913
  redraw_term(user, 0);
#line 914
  flush_term(user);
  }
#line 917
  if (running_process) {
    {
#line 918
    set_raw_term();
    }
  }
#line 919
  return;
}
}
#line 924 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/term.c"
static void draw_box(yuser *user , int height , int width , char c ) 
{ 
  register int i ;

  {
#line 932
  if (width < (int )user->t_cols) {
#line 933
    i = 0;
    {
#line 933
    while (1) {
      while_continue: /* CIL Label */ ;
#line 933
      if (! (i < height)) {
#line 933
        goto while_break;
      }
      {
#line 934
      move_term(user, i, width);
#line 935
      addch_term(user, (ychar )c);
      }
#line 936
      if (width + 1 < (int )user->t_cols) {
        {
#line 937
        clreol_term(user);
        }
      }
#line 933
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 940
  if (height < (int )user->t_rows) {
    {
#line 941
    move_term(user, height, 0);
#line 942
    i = 0;
    }
    {
#line 942
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 942
      if (! (i < width)) {
#line 942
        goto while_break___0;
      }
      {
#line 943
      addch_term(user, (ychar )c);
#line 942
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 944
    if (width < (int )user->t_cols) {
      {
#line 945
      addch_term(user, (ychar )c);
      }
    }
#line 946
    if (width + 1 < (int )user->t_cols) {
      {
#line 947
      clreol_term(user);
      }
    }
#line 948
    if (height + 1 < (int )user->t_rows) {
      {
#line 949
      move_term(user, height + 1, 0);
#line 950
      clreos_term(user);
      }
    }
  }
#line 953
  return;
}
}
#line 958 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/term.c"
void set_win_region(yuser *user , int height , int width ) 
{ 
  register int x ;
  register int y ;
  int old_height ;
  int old_width ;

  {
#line 966
  if (height < 2) {
#line 967
    height = (int )user->t_rows;
  } else
#line 966
  if (height > (int )user->t_rows) {
#line 967
    height = (int )user->t_rows;
  }
#line 968
  if (width < 2) {
#line 969
    width = (int )user->t_cols;
  } else
#line 968
  if (width > (int )user->t_cols) {
#line 969
    width = (int )user->t_cols;
  }
#line 977
  old_height = (int )user->rows;
#line 978
  old_width = (int )user->cols;
#line 979
  user->rows = user->t_rows;
#line 980
  user->cols = user->t_cols;
#line 981
  if (user->region_set) {
#line 982
    x = user->x;
#line 983
    y = user->y;
#line 984
    if (width > old_width) {
      {
#line 985
      draw_box(user, old_height, old_width, (char )' ');
      }
    } else
#line 984
    if (height > old_height) {
      {
#line 985
      draw_box(user, old_height, old_width, (char )' ');
      }
    }
  } else {
    {
#line 987
    y = 0;
#line 987
    x = y;
#line 988
    move_term(user, 0, 0);
#line 989
    clreos_term(user);
#line 990
    user->region_set = (char)1;
    }
  }
  {
#line 992
  draw_box(user, height, width, (char )'%');
#line 996
  user->rows = (u_short )height;
#line 997
  user->cols = (u_short )width;
#line 998
  user->sc_top = 0;
#line 999
  user->sc_bot = height - 1;
#line 1000
  move_term(user, y, x);
#line 1001
  flush_term(user);
  }
#line 1003
  if ((unsigned long )user == (unsigned long )me) {
    {
#line 1004
    send_region();
    }
  }
#line 1005
  return;
}
}
#line 1010 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/term.c"
void end_win_region(yuser *user ) 
{ 
  int old_height ;
  int old_width ;

  {
#line 1016
  old_height = (int )user->rows;
#line 1017
  old_width = (int )user->cols;
#line 1018
  user->rows = user->t_rows;
#line 1019
  user->cols = user->t_cols;
#line 1020
  user->sc_top = 0;
#line 1021
  user->sc_bot = (int )user->rows - 1;
#line 1022
  if (old_height < (int )user->t_rows) {
    {
#line 1023
    draw_box(user, old_height, old_width, (char )' ');
    }
  } else
#line 1022
  if (old_width < (int )user->t_cols) {
    {
#line 1023
    draw_box(user, old_height, old_width, (char )' ');
    }
  }
#line 1024
  user->region_set = (char)0;
#line 1025
  if ((unsigned long )user == (unsigned long )me) {
    {
#line 1026
    send_end_region();
    }
  }
#line 1027
  return;
}
}
#line 1032 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/term.c"
void set_scroll_region(yuser *user , int top , int bottom ) 
{ 


  {
#line 1037
  if (top < 0) {
#line 1039
    user->sc_top = 0;
#line 1040
    user->sc_bot = (int )user->rows - 1;
  } else
#line 1037
  if (top >= (int )user->rows) {
#line 1039
    user->sc_top = 0;
#line 1040
    user->sc_bot = (int )user->rows - 1;
  } else
#line 1037
  if (bottom >= (int )user->rows) {
#line 1039
    user->sc_top = 0;
#line 1040
    user->sc_bot = (int )user->rows - 1;
  } else
#line 1037
  if (bottom < top) {
#line 1039
    user->sc_top = 0;
#line 1040
    user->sc_bot = (int )user->rows - 1;
  } else
#line 1037
  if (bottom <= 0) {
#line 1037
    if (top <= 0) {
#line 1039
      user->sc_top = 0;
#line 1040
      user->sc_bot = (int )user->rows - 1;
    } else {
#line 1042
      user->sc_top = top;
#line 1043
      user->sc_bot = bottom;
    }
  } else {
#line 1042
    user->sc_top = top;
#line 1043
    user->sc_bot = bottom;
  }
#line 1045
  return;
}
}
#line 1050 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/term.c"
void msg_term(yuser *user , char *str ) 
{ 
  int y ;
  char *tmp___0 ;

  {
#line 1057
  y = user->y + 1;
#line 1057
  if (y >= (int )user->rows) {
#line 1058
    y = 0;
  }
  {
#line 1059
  move_curses(user, y, 0);
#line 1060
  addch_curses(user, '[');
  }
  {
#line 1061
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1061
    if (! *str) {
#line 1061
      goto while_break;
    }
    {
#line 1062
    tmp___0 = str;
#line 1062
    str ++;
#line 1062
    addch_curses(user, (int )*tmp___0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1063
  addch_curses(user, ']');
#line 1064
  clreol_curses(user);
#line 1065
  move_curses(user, user->y, user->x);
#line 1066
  flush_curses(user);
  }
#line 1067
  return;
}
}
#line 1080 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/term.c"
static char tmp[20]  ;
#line 1072 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/term.c"
void spew_term(yuser *user , int fd , int rows , int cols ) 
{ 
  register ychar *c ;
  register ychar *e ;
  register int len ;
  int y ;
  size_t tmp___0 ;

  {
#line 1082
  if (user->region_set) {
#line 1083
    y = 0;
#line 1084
    if (cols > (int )user->cols) {
#line 1085
      cols = (int )user->cols;
    }
#line 1086
    if (rows > (int )user->rows) {
#line 1087
      rows = (int )user->rows;
    }
    {
#line 1088
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1089
      e = *(user->scr + y);
#line 1089
      c = e;
#line 1089
      len = cols;
      {
#line 1089
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1089
        if (! (len > 0)) {
#line 1089
          goto while_break___0;
        }
#line 1090
        if ((int )*c != 32) {
#line 1091
          e = c + 1;
        }
#line 1089
        len --;
#line 1089
        c ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1092
      if ((unsigned long )e != (unsigned long )*(user->scr + y)) {
        {
#line 1093
        write(fd, (void const   *)*(user->scr + y), (size_t )(e - *(user->scr + y)));
        }
      }
#line 1094
      y ++;
#line 1094
      if (y >= rows) {
#line 1095
        goto while_break;
      }
#line 1096
      if ((int )user->crlf == 1) {
        {
#line 1097
        write(fd, (void const   *)"\r\n", (size_t )2);
        }
      } else {
        {
#line 1099
        write(fd, (void const   *)"\n", (size_t )1);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1105
    snprintf((char */* __restrict  */)(tmp), sizeof(tmp), (char const   */* __restrict  */)"%c[%d;%dH",
             27, user->y + 1, user->x + 1);
#line 1109
    tmp___0 = strlen((char const   *)(tmp));
#line 1109
    write(fd, (void const   *)(tmp), tmp___0);
    }
  } else {
    {
#line 1111
    y = first_interesting_row(user, rows, cols);
    }
    {
#line 1112
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1113
      if (y == user->y) {
#line 1114
        if (user->x > 0) {
          {
#line 1115
          write(fd, (void const   *)*(user->scr + y), (size_t )user->x);
          }
        }
#line 1116
        goto while_break___1;
      }
#line 1118
      e = *(user->scr + y);
#line 1118
      c = e;
#line 1118
      len = (int )user->t_cols;
      {
#line 1118
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1118
        if (! (len > 0)) {
#line 1118
          goto while_break___2;
        }
#line 1119
        if ((int )*c != 32) {
#line 1120
          e = c + 1;
        }
#line 1118
        len --;
#line 1118
        c ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1121
      if ((unsigned long )e != (unsigned long )*(user->scr + y)) {
        {
#line 1122
        write(fd, (void const   *)*(user->scr + y), (size_t )(e - *(user->scr + y)));
        }
      }
#line 1123
      if ((int )user->crlf == 1) {
        {
#line 1124
        write(fd, (void const   *)"\r\n", (size_t )2);
        }
      } else {
        {
#line 1126
        write(fd, (void const   *)"\n", (size_t )1);
        }
      }
#line 1127
      y ++;
#line 1127
      if (y >= (int )user->t_rows) {
#line 1128
        y = 0;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1131
  return;
}
}
#line 1144 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/term.c"
void raw_term(yuser *user , int y , int x , ychar *str , int len ) 
{ 
  register ychar *c ;

  {
#line 1153
  if (y < 0) {
#line 1154
    return;
  } else
#line 1153
  if (y >= (int )user->t_rows) {
#line 1154
    return;
  }
#line 1155
  if (x < 0) {
#line 1156
    return;
  } else
#line 1155
  if (x >= (int )user->t_cols) {
#line 1156
    return;
  }
  {
#line 1157
  move_curses(user, y, x);
#line 1159
  c = str;
  }
  {
#line 1159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1159
    if (! (len > 0)) {
#line 1159
      goto while_break;
    }
#line 1160
    if ((int )*c == 0) {
#line 1161
      c = str;
    }
#line 1162
    if ((int )*c >= 32) {
#line 1162
      if ((int )*c <= 126) {
#line 1162
        goto _L;
      } else {
#line 1162
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1162
    if ((int )*c >= 160) {
      _L: /* CIL Label */ 
#line 1162
      if (! ((int )*c != 254)) {
#line 1163
        return;
      }
    } else {
#line 1163
      return;
    }
    {
#line 1164
    addch_curses(user, (int )*c);
#line 1159
    len --;
#line 1159
    c ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1166
  return;
}
}
#line 1168 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/term.c"
int center(int width , int n ) 
{ 


  {
#line 1172
  if (n >= width) {
#line 1173
    return (0);
  }
#line 1174
  return ((width - n) / 2);
}
}
#line 1177 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/term.c"
void redraw_all_terms(void) 
{ 


  {
#line 1180
  if (term_type == 1) {
    {
#line 1181
    redisplay_curses();
    }
  }
#line 1182
  return;
}
}
#line 1184 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/term.c"
void set_raw_term(void) 
{ 


  {
#line 1187
  if (term_type == 1) {
    {
#line 1188
    set_raw_curses();
    }
  }
#line 1189
  return;
}
}
#line 1191 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/term.c"
void set_cooked_term(void) 
{ 


  {
#line 1194
  if (term_type == 1) {
    {
#line 1195
    set_cooked_curses();
    }
  }
#line 1196
  return;
}
}
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 278 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/header.h"
yuser *user_list ;
#line 283
char errstr[132] ;
#line 284
ylong def_flags ;
#line 291
ylong myuid ;
#line 390
void readdress_host(char *from_id , char *to_id , char *on_id ) ;
#line 392
void read_ytalkrc(void) ;
#line 393
char *resolve_alias(char *uh ) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/rc.c"
char *vhost ;
#line 30 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/rc.c"
static struct alias *alias0  =    (struct alias *)((void *)0);
#line 34 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/rc.c"
static char *get_word(char **p ) 
{ 
  register char *c ;
  register char *out ;
  char *tmp___0 ;

  {
#line 40
  c = *p;
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;
#line 41
    if (! ((int )*c == 32)) {
#line 41
      if (! ((int )*c == 9)) {
#line 41
        if (! ((int )*c == 10)) {
#line 41
          goto while_break;
        }
      }
    }
#line 42
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 43
  if ((int )*c == 0) {
#line 44
    return ((char *)((void *)0));
  }
#line 45
  out = c;
  {
#line 46
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 46
    if (*c) {
#line 46
      if ((int )*c == 32) {
#line 46
        goto while_break___0;
      } else
#line 46
      if ((int )*c == 9) {
#line 46
        goto while_break___0;
      } else
#line 46
      if ((int )*c == 10) {
#line 46
        goto while_break___0;
      }
    } else {
#line 46
      goto while_break___0;
    }
#line 47
    c ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 48
  if (*c) {
#line 49
    tmp___0 = c;
#line 49
    c ++;
#line 49
    *tmp___0 = (char )'\000';
  }
#line 50
  *p = c;
#line 51
  return (out);
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/rc.c"
static int set_option(char *opt , char *value ) 
{ 
  ylong mask ;
  int set_it ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;

  {
  {
#line 58
  mask = (ylong )0;
#line 61
  tmp___2 = strcmp((char const   *)value, "true");
  }
#line 61
  if (tmp___2 == 0) {
#line 62
    set_it = 1;
  } else {
    {
#line 61
    tmp___3 = strcmp((char const   *)value, "on");
    }
#line 61
    if (tmp___3 == 0) {
#line 62
      set_it = 1;
    } else {
      {
#line 63
      tmp___0 = strcmp((char const   *)value, "false");
      }
#line 63
      if (tmp___0 == 0) {
#line 64
        set_it = 0;
      } else {
        {
#line 63
        tmp___1 = strcmp((char const   *)value, "off");
        }
#line 63
        if (tmp___1 == 0) {
#line 64
          set_it = 0;
        } else {
#line 66
          return (-1);
        }
      }
    }
  }
  {
#line 68
  tmp___42 = strcmp((char const   *)opt, "scroll");
  }
#line 68
  if (tmp___42 == 0) {
#line 71
    mask = (ylong )((long )mask | 2L);
  } else {
    {
#line 68
    tmp___43 = strcmp((char const   *)opt, "scrolling");
    }
#line 68
    if (tmp___43 == 0) {
#line 71
      mask = (ylong )((long )mask | 2L);
    } else {
      {
#line 68
      tmp___44 = strcmp((char const   *)opt, "sc");
      }
#line 68
      if (tmp___44 == 0) {
#line 71
        mask = (ylong )((long )mask | 2L);
      } else {
        {
#line 73
        tmp___37 = strcmp((char const   *)opt, "wrap");
        }
#line 73
        if (tmp___37 == 0) {
#line 78
          mask = (ylong )((long )mask | 4L);
        } else {
          {
#line 73
          tmp___38 = strcmp((char const   *)opt, "word-wrap");
          }
#line 73
          if (tmp___38 == 0) {
#line 78
            mask = (ylong )((long )mask | 4L);
          } else {
            {
#line 73
            tmp___39 = strcmp((char const   *)opt, "wordwrap");
            }
#line 73
            if (tmp___39 == 0) {
#line 78
              mask = (ylong )((long )mask | 4L);
            } else {
              {
#line 73
              tmp___40 = strcmp((char const   *)opt, "wrapping");
              }
#line 73
              if (tmp___40 == 0) {
#line 78
                mask = (ylong )((long )mask | 4L);
              } else {
                {
#line 73
                tmp___41 = strcmp((char const   *)opt, "ww");
                }
#line 73
                if (tmp___41 == 0) {
#line 78
                  mask = (ylong )((long )mask | 4L);
                } else {
                  {
#line 80
                  tmp___31 = strcmp((char const   *)opt, "import");
                  }
#line 80
                  if (tmp___31 == 0) {
#line 86
                    mask = (ylong )((long )mask | 8L);
                  } else {
                    {
#line 80
                    tmp___32 = strcmp((char const   *)opt, "auto-import");
                    }
#line 80
                    if (tmp___32 == 0) {
#line 86
                      mask = (ylong )((long )mask | 8L);
                    } else {
                      {
#line 80
                      tmp___33 = strcmp((char const   *)opt, "autoimport");
                      }
#line 80
                      if (tmp___33 == 0) {
#line 86
                        mask = (ylong )((long )mask | 8L);
                      } else {
                        {
#line 80
                        tmp___34 = strcmp((char const   *)opt, "importing");
                        }
#line 80
                        if (tmp___34 == 0) {
#line 86
                          mask = (ylong )((long )mask | 8L);
                        } else {
                          {
#line 80
                          tmp___35 = strcmp((char const   *)opt, "aip");
                          }
#line 80
                          if (tmp___35 == 0) {
#line 86
                            mask = (ylong )((long )mask | 8L);
                          } else {
                            {
#line 80
                            tmp___36 = strcmp((char const   *)opt, "ai");
                            }
#line 80
                            if (tmp___36 == 0) {
#line 86
                              mask = (ylong )((long )mask | 8L);
                            } else {
                              {
#line 88
                              tmp___26 = strcmp((char const   *)opt, "invite");
                              }
#line 88
                              if (tmp___26 == 0) {
#line 93
                                mask = (ylong )((long )mask | 16L);
                              } else {
                                {
#line 88
                                tmp___27 = strcmp((char const   *)opt, "auto-invite");
                                }
#line 88
                                if (tmp___27 == 0) {
#line 93
                                  mask = (ylong )((long )mask | 16L);
                                } else {
                                  {
#line 88
                                  tmp___28 = strcmp((char const   *)opt, "autoinvite");
                                  }
#line 88
                                  if (tmp___28 == 0) {
#line 93
                                    mask = (ylong )((long )mask | 16L);
                                  } else {
                                    {
#line 88
                                    tmp___29 = strcmp((char const   *)opt, "aiv");
                                    }
#line 88
                                    if (tmp___29 == 0) {
#line 93
                                      mask = (ylong )((long )mask | 16L);
                                    } else {
                                      {
#line 88
                                      tmp___30 = strcmp((char const   *)opt, "av");
                                      }
#line 88
                                      if (tmp___30 == 0) {
#line 93
                                        mask = (ylong )((long )mask | 16L);
                                      } else {
                                        {
#line 95
                                        tmp___23 = strcmp((char const   *)opt, "ring");
                                        }
#line 95
                                        if (tmp___23 == 0) {
#line 98
                                          mask = (ylong )((long )mask | 32L);
                                        } else {
                                          {
#line 95
                                          tmp___24 = strcmp((char const   *)opt, "rering");
                                          }
#line 95
                                          if (tmp___24 == 0) {
#line 98
                                            mask = (ylong )((long )mask | 32L);
                                          } else {
                                            {
#line 95
                                            tmp___25 = strcmp((char const   *)opt,
                                                              "r");
                                            }
#line 95
                                            if (tmp___25 == 0) {
#line 98
                                              mask = (ylong )((long )mask | 32L);
                                            } else {
                                              {
#line 100
                                              tmp___18 = strcmp((char const   *)opt,
                                                                "prompt-ring");
                                              }
#line 100
                                              if (tmp___18 == 0) {
#line 105
                                                mask = (ylong )((long )mask | 1024L);
                                              } else {
                                                {
#line 100
                                                tmp___19 = strcmp((char const   *)opt,
                                                                  "prompt-rering");
                                                }
#line 100
                                                if (tmp___19 == 0) {
#line 105
                                                  mask = (ylong )((long )mask | 1024L);
                                                } else {
                                                  {
#line 100
                                                  tmp___20 = strcmp((char const   *)opt,
                                                                    "promptring");
                                                  }
#line 100
                                                  if (tmp___20 == 0) {
#line 105
                                                    mask = (ylong )((long )mask | 1024L);
                                                  } else {
                                                    {
#line 100
                                                    tmp___21 = strcmp((char const   *)opt,
                                                                      "promptrering");
                                                    }
#line 100
                                                    if (tmp___21 == 0) {
#line 105
                                                      mask = (ylong )((long )mask | 1024L);
                                                    } else {
                                                      {
#line 100
                                                      tmp___22 = strcmp((char const   *)opt,
                                                                        "pr");
                                                      }
#line 100
                                                      if (tmp___22 == 0) {
#line 105
                                                        mask = (ylong )((long )mask | 1024L);
                                                      } else {
                                                        {
#line 107
                                                        tmp___15 = strcmp((char const   *)opt,
                                                                          "prompt-quit");
                                                        }
#line 107
                                                        if (tmp___15 == 0) {
#line 110
                                                          mask = (ylong )((long )mask | 8192L);
                                                        } else {
                                                          {
#line 107
                                                          tmp___16 = strcmp((char const   *)opt,
                                                                            "promptquit");
                                                          }
#line 107
                                                          if (tmp___16 == 0) {
#line 110
                                                            mask = (ylong )((long )mask | 8192L);
                                                          } else {
                                                            {
#line 107
                                                            tmp___17 = strcmp((char const   *)opt,
                                                                              "pq");
                                                            }
#line 107
                                                            if (tmp___17 == 0) {
#line 110
                                                              mask = (ylong )((long )mask | 8192L);
                                                            } else {
                                                              {
#line 112
                                                              tmp___14 = strcmp((char const   *)opt,
                                                                                "beeps");
                                                              }
#line 112
                                                              if (tmp___14 == 0) {
#line 113
                                                                mask = (ylong )((long )mask | 2048L);
                                                              } else {
                                                                {
#line 115
                                                                tmp___13 = strcmp((char const   *)opt,
                                                                                  "ignorebreak");
                                                                }
#line 115
                                                                if (tmp___13 == 0) {
#line 116
                                                                  mask = (ylong )((long )mask | 4096L);
                                                                } else {
                                                                  {
#line 118
                                                                  tmp___12 = strcmp((char const   *)opt,
                                                                                    "escape-yesno");
                                                                  }
#line 118
                                                                  if (tmp___12 == 0) {
#line 119
                                                                    mask = (ylong )((long )mask | 16384L);
                                                                  } else {
                                                                    {
#line 121
                                                                    tmp___8 = strcmp((char const   *)opt,
                                                                                     "caps");
                                                                    }
#line 121
                                                                    if (tmp___8 == 0) {
#line 125
                                                                      mask = (ylong )((long )mask | 256L);
                                                                    } else {
                                                                      {
#line 121
                                                                      tmp___9 = strcmp((char const   *)opt,
                                                                                       "CAPS");
                                                                      }
#line 121
                                                                      if (tmp___9 == 0) {
#line 125
                                                                        mask = (ylong )((long )mask | 256L);
                                                                      } else {
                                                                        {
#line 121
                                                                        tmp___10 = strcmp((char const   *)opt,
                                                                                          "ca");
                                                                        }
#line 121
                                                                        if (tmp___10 == 0) {
#line 125
                                                                          mask = (ylong )((long )mask | 256L);
                                                                        } else {
                                                                          {
#line 121
                                                                          tmp___11 = strcmp((char const   *)opt,
                                                                                            "CA");
                                                                          }
#line 121
                                                                          if (tmp___11 == 0) {
#line 125
                                                                            mask = (ylong )((long )mask | 256L);
                                                                          } else {
                                                                            {
#line 127
                                                                            tmp___4 = strcmp((char const   *)opt,
                                                                                             "noinvite");
                                                                            }
#line 127
                                                                            if (tmp___4 == 0) {
#line 131
                                                                              mask = (ylong )((long )mask | 512L);
                                                                            } else {
                                                                              {
#line 127
                                                                              tmp___5 = strcmp((char const   *)opt,
                                                                                               "no-invite");
                                                                              }
#line 127
                                                                              if (tmp___5 == 0) {
#line 131
                                                                                mask = (ylong )((long )mask | 512L);
                                                                              } else {
                                                                                {
#line 127
                                                                                tmp___6 = strcmp((char const   *)opt,
                                                                                                 "noinv");
                                                                                }
#line 127
                                                                                if (tmp___6 == 0) {
#line 131
                                                                                  mask = (ylong )((long )mask | 512L);
                                                                                } else {
                                                                                  {
#line 127
                                                                                  tmp___7 = strcmp((char const   *)opt,
                                                                                                   "ni");
                                                                                  }
#line 127
                                                                                  if (tmp___7 == 0) {
#line 131
                                                                                    mask = (ylong )((long )mask | 512L);
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 133
  if (! mask) {
#line 134
    return (-1);
  }
#line 136
  if (set_it) {
#line 137
    def_flags |= mask;
  } else {
#line 139
    def_flags &= ~ mask;
  }
#line 141
  return (0);
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/rc.c"
static void read_rcfile(char *fname ) 
{ 
  FILE *fp ;
  char *buf___3 ;
  char *ptr ;
  char *w ;
  char *arg1 ;
  char *arg2 ;
  char *arg3 ;
  char *at___0 ;
  int line_no ;
  int errline ;
  struct alias *a ;
  int *tmp___0 ;
  yaddr tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  yaddr tmp___4 ;
  yaddr tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  int *tmp___14 ;

  {
  {
#line 154
  fp = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"r");
  }
#line 154
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 155
    tmp___0 = __errno_location();
    }
#line 155
    if (*tmp___0 != 2) {
      {
#line 156
      show_error(fname);
      }
    }
#line 157
    return;
  }
  {
#line 159
  tmp___1 = get_mem(8192);
#line 159
  buf___3 = (char *)tmp___1;
#line 161
  errline = 0;
#line 161
  line_no = errline;
  }
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 162
    tmp___13 = fgets((char */* __restrict  */)buf___3, 8192, (FILE */* __restrict  */)fp);
    }
#line 162
    if (! ((unsigned long )tmp___13 != (unsigned long )((void *)0))) {
#line 162
      goto while_break;
    }
    {
#line 163
    line_no ++;
#line 164
    ptr = buf___3;
#line 165
    w = get_word(& ptr);
    }
#line 166
    if ((unsigned long )w == (unsigned long )((void *)0)) {
#line 167
      goto while_continue;
    } else
#line 166
    if ((int )*w == 35) {
#line 167
      goto while_continue;
    }
    {
#line 169
    tmp___12 = strcmp((char const   *)w, "readdress");
    }
#line 169
    if (tmp___12 == 0) {
      {
#line 170
      arg1 = get_word(& ptr);
#line 171
      arg2 = get_word(& ptr);
#line 172
      arg3 = get_word(& ptr);
      }
#line 173
      if ((unsigned long )arg3 == (unsigned long )((void *)0)) {
#line 174
        errline = line_no;
#line 175
        goto while_break;
      }
      {
#line 177
      readdress_host(arg1, arg2, arg3);
      }
    } else {
      {
#line 178
      tmp___10 = strcmp((char const   *)w, "set");
      }
#line 178
      if (tmp___10 == 0) {
#line 178
        goto _L;
      } else {
        {
#line 178
        tmp___11 = strcmp((char const   *)w, "turn");
        }
#line 178
        if (tmp___11 == 0) {
          _L: /* CIL Label */ 
          {
#line 179
          arg1 = get_word(& ptr);
#line 180
          arg2 = get_word(& ptr);
          }
#line 181
          if ((unsigned long )arg2 == (unsigned long )((void *)0)) {
#line 182
            errline = line_no;
#line 183
            goto while_break;
          }
          {
#line 185
          tmp___2 = set_option(arg1, arg2);
          }
#line 185
          if (tmp___2 < 0) {
#line 186
            errline = line_no;
#line 187
            goto while_break;
          }
        } else {
          {
#line 189
          tmp___9 = strcmp((char const   *)w, "localhost");
          }
#line 189
          if (tmp___9 == 0) {
            {
#line 190
            arg1 = get_word(& ptr);
            }
#line 191
            if ((unsigned long )arg1 == (unsigned long )((void *)0)) {
#line 192
              errline = line_no;
#line 193
              goto while_break;
            }
#line 195
            if ((unsigned long )vhost == (unsigned long )((void *)0)) {
              {
#line 196
              tmp___3 = strlen((char const   *)arg1);
#line 196
              tmp___4 = get_mem(1UL + tmp___3);
#line 196
              vhost = (char *)tmp___4;
              }
#line 197
              if ((unsigned long )vhost != (unsigned long )((void *)0)) {
                {
#line 198
                strcpy((char */* __restrict  */)vhost, (char const   */* __restrict  */)arg1);
                }
              }
            }
          } else {
            {
#line 200
            tmp___8 = strcmp((char const   *)w, "alias");
            }
#line 200
            if (tmp___8 == 0) {
              {
#line 201
              arg1 = get_word(& ptr);
#line 202
              arg2 = get_word(& ptr);
              }
#line 203
              if ((unsigned long )arg2 == (unsigned long )((void *)0)) {
#line 204
                errline = line_no;
#line 205
                goto while_break;
              }
              {
#line 207
              tmp___5 = get_mem(sizeof(struct alias ));
#line 207
              a = (struct alias *)tmp___5;
#line 208
              at___0 = strchr((char const   *)arg1, '@');
              }
#line 209
              if ((unsigned long )at___0 == (unsigned long )arg1) {
                {
#line 210
                a->type = 2;
#line 211
                strncpy((char */* __restrict  */)(a->from), (char const   */* __restrict  */)(arg1 + 1),
                        (size_t )255);
#line 212
                a->from[254] = (char)0;
                }
#line 213
                if ((int )*arg2 == 64) {
#line 213
                  tmp___6 = arg2 + 1;
                } else {
#line 213
                  tmp___6 = arg2;
                }
                {
#line 213
                strncpy((char */* __restrict  */)(a->to), (char const   */* __restrict  */)tmp___6,
                        (size_t )255);
#line 214
                a->to[254] = (char)0;
                }
              } else {
                {
#line 215
                tmp___7 = strlen((char const   *)arg1);
                }
#line 215
                if ((unsigned long )at___0 == (unsigned long )((arg1 + tmp___7) - 1)) {
                  {
#line 216
                  a->type = 1;
#line 217
                  *at___0 = (char)0;
#line 218
                  strncpy((char */* __restrict  */)(a->from), (char const   */* __restrict  */)arg1,
                          (size_t )255);
#line 219
                  a->from[254] = (char)0;
#line 220
                  strncpy((char */* __restrict  */)(a->to), (char const   */* __restrict  */)arg2,
                          (size_t )255);
#line 221
                  a->to[254] = (char)0;
#line 222
                  at___0 = strchr((char const   *)(a->to), '@');
                  }
#line 222
                  if ((unsigned long )at___0 != (unsigned long )((void *)0)) {
#line 223
                    *at___0 = (char)0;
                  }
                } else {
                  {
#line 225
                  a->type = 0;
#line 226
                  strncpy((char */* __restrict  */)(a->from), (char const   */* __restrict  */)arg1,
                          (size_t )255);
#line 227
                  a->from[254] = (char)0;
#line 228
                  strncpy((char */* __restrict  */)(a->to), (char const   */* __restrict  */)arg2,
                          (size_t )255);
#line 229
                  a->to[254] = (char)0;
                  }
                }
              }
#line 231
              a->next = alias0;
#line 232
              alias0 = a;
            } else {
#line 234
              errline = line_no;
#line 235
              goto while_break;
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 238
  if (errline) {
    {
#line 240
    snprintf((char */* __restrict  */)(errstr), (size_t )132, (char const   */* __restrict  */)"%s: syntax error at line %d",
             fname, errline);
#line 244
    tmp___14 = __errno_location();
#line 244
    *tmp___14 = 0;
#line 245
    show_error(errstr);
    }
  }
  {
#line 247
  free_mem(buf___3);
#line 248
  fclose(fp);
  }
#line 249
  return;
}
}
#line 258 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/rc.c"
static char uh1[256]  ;
#line 258 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/rc.c"
static char *at  ;
#line 253 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/rc.c"
char *resolve_alias(char *uh ) 
{ 
  struct alias *a ;
  int found ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;

  {
#line 259
  found = 0;
#line 261
  a = alias0;
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 261
    if (! a) {
#line 261
      goto while_break;
    }
#line 262
    if (a->type == 0) {
      {
#line 262
      tmp___0 = strcmp((char const   *)uh, (char const   *)(a->from));
      }
#line 262
      if (tmp___0 == 0) {
#line 263
        return (a->to);
      }
    }
#line 261
    a = a->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 265
  strncpy((char */* __restrict  */)(uh1), (char const   */* __restrict  */)uh, (size_t )255);
#line 266
  uh1[254] = (char)0;
#line 267
  at = strchr((char const   *)(uh1), '@');
  }
#line 267
  if ((unsigned long )at != (unsigned long )((void *)0)) {
#line 268
    *at = (char)0;
  }
#line 269
  a = alias0;
  {
#line 269
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 269
    if (! a) {
#line 269
      goto while_break___0;
    }
#line 270
    if (a->type == 1) {
      {
#line 270
      tmp___3 = strcmp((char const   *)(uh1), (char const   *)(a->from));
      }
#line 270
      if (tmp___3 == 0) {
        {
#line 271
        found = 1;
#line 272
        strncpy((char */* __restrict  */)(uh1), (char const   */* __restrict  */)(a->to),
                (size_t )255);
#line 273
        uh1[254] = (char)0;
#line 274
        at = strchr((char const   *)uh, '@');
        }
#line 274
        if ((unsigned long )at != (unsigned long )((void *)0)) {
          {
#line 275
          tmp___1 = strlen((char const   *)(uh1));
#line 275
          tmp___2 = strlen((char const   *)at);
          }
#line 275
          if (tmp___1 + tmp___2 < 256UL) {
            {
#line 276
            strcat((char */* __restrict  */)(uh1), (char const   */* __restrict  */)at);
            }
          }
        }
#line 277
        uh = uh1;
#line 278
        goto while_break___0;
      }
    }
#line 269
    a = a->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 281
  if (! found) {
    {
#line 282
    strncpy((char */* __restrict  */)(uh1), (char const   */* __restrict  */)uh, (size_t )255);
#line 283
    uh1[254] = (char)0;
    }
  }
  {
#line 285
  at = strchr((char const   *)(uh1), '@');
  }
#line 286
  if (at) {
#line 286
    if (*(at + 1)) {
#line 287
      at ++;
#line 288
      a = alias0;
      {
#line 288
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 288
        if (! a) {
#line 288
          goto while_break___1;
        }
#line 289
        if (a->type == 2) {
          {
#line 289
          tmp___5 = strcmp((char const   *)at, (char const   *)(a->from));
          }
#line 289
          if (tmp___5 == 0) {
            {
#line 290
            found = 1;
#line 291
            tmp___4 = strlen((char const   *)(a->to));
            }
#line 291
            if (tmp___4 + (size_t )(at - uh1) < 255UL) {
              {
#line 292
              strcpy((char */* __restrict  */)at, (char const   */* __restrict  */)(a->to));
              }
            }
#line 293
            goto while_break___1;
          }
        }
#line 288
        a = a->next;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
#line 297
  if (found) {
#line 298
    return (uh1);
  } else {
#line 300
    return (uh);
  }
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/rc.c"
void read_ytalkrc(void) 
{ 
  yuser *u ;
  char *home ;
  char *fname ;
  struct passwd *pw ;
  size_t tmp___0 ;
  yaddr tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 311
  read_rcfile((char *)"/usr/local/etc/ytalkrc");
#line 315
  home = getenv("HOME");
  }
#line 317
  if ((unsigned long )home == (unsigned long )((void *)0)) {
    {
#line 318
    pw = getpwuid(myuid);
    }
#line 319
    if ((unsigned long )pw != (unsigned long )((void *)0)) {
#line 320
      home = pw->pw_dir;
    }
  }
#line 322
  if ((unsigned long )home != (unsigned long )((void *)0)) {
    {
#line 323
    tmp___0 = strlen((char const   *)home);
#line 323
    tmp___1 = get_mem(tmp___0 + 10UL);
#line 323
    fname = (char *)tmp___1;
#line 325
    tmp___2 = strlen((char const   *)home);
#line 325
    snprintf((char */* __restrict  */)fname, tmp___2 + 10UL, (char const   */* __restrict  */)"%s/.ytalkrc",
             home);
#line 329
    read_rcfile(fname);
#line 330
    free_mem(fname);
    }
  }
#line 334
  u = user_list;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! ((unsigned long )u != (unsigned long )((void *)0))) {
#line 334
      goto while_break;
    }
#line 335
    if (! ((long )u->flags & 1073741824L)) {
#line 336
      u->flags = def_flags;
    }
#line 334
    u = u->unext;
  }
  while_break: /* CIL Label */ ;
  }
#line 337
  return;
}
}
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 362 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/header.h"
void add_fd(int fd , void (*user_func)() ) ;
#line 376
void my_input(yuser *user , ychar *buf___3 , int len ) ;
#line 587 "/usr/include/curses.h"
extern int cbreak(void) ;
#line 603
extern int delwin(WINDOW * ) ;
#line 611
extern int endwin(void) ;
#line 632
extern WINDOW *initscr(void) ;
#line 647
extern int keypad(WINDOW * , _Bool  ) ;
#line 707
extern WINDOW *newwin(int  , int  , int  , int  ) ;
#line 711
extern int noecho(void) ;
#line 714
extern int noraw(void) ;
#line 727
extern int raw(void) ;
#line 741
extern int scrollok(WINDOW * , _Bool  ) ;
#line 785
extern int waddch(WINDOW * , chtype const    ) ;
#line 801
extern int wclear(WINDOW * ) ;
#line 802
extern int wclrtobot(WINDOW * ) ;
#line 803
extern int wclrtoeol(WINDOW * ) ;
#line 824
extern int wmove(WINDOW * , int  , int  ) ;
#line 829
extern int wrefresh(WINDOW * ) ;
#line 832
extern int wscrl(WINDOW * , int  ) ;
#line 1386
extern WINDOW *stdscr ;
#line 1390
extern int COLS ;
#line 1392
extern int LINES ;
#line 45 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/cwin.c"
static ywin *head  ;
#line 55 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/cwin.c"
static ychar buf[4096]  ;
#line 50 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/cwin.c"
static void curses_input(int fd ) 
{ 
  register int rc ;
  ssize_t tmp___0 ;

  {
  {
#line 57
  tmp___0 = read(fd, (void *)(buf), (size_t )4096);
#line 57
  rc = (int )tmp___0;
  }
#line 57
  if (rc <= 0) {
#line 58
    if (rc == 0) {
      {
#line 59
      bail(0);
      }
    }
    {
#line 60
    bail(4);
    }
  }
  {
#line 62
  my_input(me, buf, rc);
  }
#line 63
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/cwin.c"
static ywin *new_ywin(yuser *user , char *title ) 
{ 
  register ywin *out ;
  register int len ;
  size_t tmp___0 ;
  yaddr tmp___1 ;

  {
  {
#line 73
  tmp___0 = strlen((char const   *)title);
#line 73
  len = (int )tmp___0;
#line 74
  tmp___1 = get_mem((sizeof(ywin ) + (unsigned long )len) + 1UL);
#line 74
  out = (ywin *)tmp___1;
#line 75
  memset((void *)out, 0, sizeof(ywin ));
#line 76
  out->user = user;
#line 77
  out->title = (char *)out + sizeof(ywin );
#line 78
  strcpy((char */* __restrict  */)out->title, (char const   */* __restrict  */)title);
  }
#line 79
  return (out);
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/cwin.c"
static void make_win(ywin *w , int height , int width , int row , int col ) 
{ 
  WINDOW *tmp___0 ;

  {
  {
#line 87
  tmp___0 = newwin(height, width, row, col);
#line 87
  w->win = tmp___0;
  }
#line 87
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 88
    w = (ywin *)me->term;
#line 89
    if ((unsigned long )w->win != (unsigned long )((void *)0)) {
      {
#line 90
      show_error("make_win: newwin() failed");
      }
    }
    {
#line 91
    bail(4);
    }
  }
  {
#line 93
  w->height = height;
#line 94
  w->width = width;
#line 95
  w->row = row;
#line 96
  w->col = col;
#line 97
  scrollok(w->win, (_Bool)0);
#line 98
  wmove(w->win, 0, 0);
  }
#line 99
  return;
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/cwin.c"
static void draw_title(ywin *w ) 
{ 
  register int pad ;
  register int x ;
  register char *t ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 108
  tmp___0 = strlen((char const   *)w->title);
  }
#line 108
  if ((int )tmp___0 > w->width) {
#line 109
    x = 0;
    {
#line 109
    while (1) {
      while_continue: /* CIL Label */ ;
#line 109
      if (! (x < w->width)) {
#line 109
        goto while_break;
      }
      {
#line 110
      waddch(stdscr, (chtype const   )'-');
#line 109
      x ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 111
    return;
  }
  {
#line 113
  tmp___1 = strlen((char const   *)w->title);
#line 113
  pad = (int )(((size_t )w->width - tmp___1) / 2UL);
#line 114
  wmove(stdscr, w->row - 1, w->col);
#line 115
  x = 0;
  }
  {
#line 116
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 116
    if (! (x < pad - 2)) {
#line 116
      goto while_break___0;
    }
    {
#line 117
    waddch(stdscr, (chtype const   )'-');
#line 116
    x ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 118
  if (pad >= 2) {
    {
#line 119
    waddch(stdscr, (chtype const   )'=');
#line 120
    waddch(stdscr, (chtype const   )' ');
#line 121
    x += 2;
    }
  }
#line 123
  t = w->title;
  {
#line 123
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 123
    if (*t) {
#line 123
      if (! (x < w->width)) {
#line 123
        goto while_break___1;
      }
    } else {
#line 123
      goto while_break___1;
    }
    {
#line 124
    waddch(stdscr, (chtype const   )*t);
#line 123
    x ++;
#line 123
    t ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 125
  if (pad >= 2) {
    {
#line 126
    waddch(stdscr, (chtype const   )' ');
#line 127
    waddch(stdscr, (chtype const   )'=');
#line 128
    x += 2;
    }
  }
  {
#line 130
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 130
    if (! (x < w->width)) {
#line 130
      goto while_break___2;
    }
    {
#line 131
    waddch(stdscr, (chtype const   )'-');
#line 130
    x ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 132
  return;
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/cwin.c"
static int win_size(int wins ) 
{ 


  {
#line 141
  if (wins == 0) {
#line 142
    return (0);
  }
#line 143
  return ((LINES - 1) / wins);
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/cwin.c"
static void curses_redraw(void) 
{ 
  register ywin *w ;
  register int row ;
  register int wins ;
  register int wsize ;
  int *tmp___0 ;

  {
#line 157
  wins = 0;
#line 158
  w = head;
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (! w) {
#line 158
      goto while_break;
    }
#line 159
    if (w->win) {
      {
#line 160
      delwin(w->win);
#line 161
      w->win = (WINDOW *)((void *)0);
      }
    }
#line 163
    wins ++;
#line 158
    w = w->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 165
  wsize = win_size(wins);
  }
#line 165
  if (wsize < 3) {
    {
#line 166
    end_term();
#line 167
    tmp___0 = __errno_location();
#line 167
    *tmp___0 = 0;
#line 168
    show_error("curses_redraw: window size too small");
#line 169
    bail(4);
    }
  }
  {
#line 174
  wclear(stdscr);
#line 175
  wrefresh(stdscr);
#line 176
  row = 0;
#line 177
  w = head;
  }
  {
#line 177
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 177
    if (! w) {
#line 177
      goto while_break___0;
    }
#line 178
    if (w->next) {
      {
#line 179
      make_win(w, wsize - 1, COLS, row + 1, 0);
#line 180
      resize_win(w->user, wsize - 1, COLS);
      }
    } else {
      {
#line 182
      make_win(w, (LINES - row) - 2, COLS, row + 1, 0);
#line 183
      resize_win(w->user, (LINES - row) - 2, COLS);
      }
    }
    {
#line 185
    draw_title(w);
#line 186
    row += wsize;
#line 187
    wrefresh(stdscr);
#line 188
    wrefresh(w->win);
#line 177
    w = w->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 190
  return;
}
}
#line 195 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/cwin.c"
static void curses_start(void) 
{ 
  char *term ;
  char const   *tmp___0 ;
  WINDOW *tmp___1 ;

  {
  {
#line 199
  tmp___1 = initscr();
  }
#line 199
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    {
#line 200
    term = getenv("TERM");
    }
#line 201
    if (term) {
#line 201
      tmp___0 = (char const   *)term;
    } else {
#line 201
      tmp___0 = "(null)";
    }
    {
#line 201
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error opening terminal: %s.\n",
            tmp___0);
#line 202
    bail(1);
    }
  }
  {
#line 204
  noraw();
#line 205
  cbreak();
#line 206
  noecho();
#line 207
  wclear(stdscr);
  }
#line 208
  return;
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/cwin.c"
static void curses_restart(void) 
{ 
  register ywin *w ;

  {
#line 220
  w = head;
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    if (! w) {
#line 220
      goto while_break;
    }
#line 221
    if (w->win) {
      {
#line 222
      delwin(w->win);
#line 223
      w->win = (WINDOW *)((void *)0);
      }
    }
#line 220
    w = w->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 228
  endwin();
#line 229
  curses_start();
#line 233
  wrefresh(stdscr);
#line 234
  curses_redraw();
#line 238
  signal(28, (void (*)(int  ))(& curses_restart));
  }
#line 240
  return;
}
}
#line 244 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/cwin.c"
void init_curses(void) 
{ 


  {
  {
#line 247
  curses_start();
#line 248
  wrefresh(stdscr);
#line 249
  head = (ywin *)((void *)0);
#line 250
  add_fd(0, & curses_input);
#line 254
  signal(28, (void (*)(int  ))(& curses_restart));
  }
#line 256
  return;
}
}
#line 258 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/cwin.c"
void end_curses(void) 
{ 


  {
  {
#line 261
  wmove(stdscr, LINES - 1, 0);
#line 262
  wclrtoeol(stdscr);
#line 263
  wrefresh(stdscr);
#line 264
  endwin();
  }
#line 265
  return;
}
}
#line 270 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/cwin.c"
int open_curses(yuser *user , char *title ) 
{ 
  register ywin *w ;
  register int wins ;
  int tmp___0 ;

  {
#line 282
  wins = 0;
#line 283
  w = head;
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 283
    if (! w) {
#line 283
      goto while_break;
    }
#line 284
    wins ++;
#line 283
    w = w->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 285
  tmp___0 = win_size(wins + 1);
  }
#line 285
  if (tmp___0 < 3) {
#line 286
    return (-1);
  }
#line 290
  if ((unsigned long )head == (unsigned long )((void *)0)) {
    {
#line 291
    head = new_ywin(user, title);
#line 291
    w = head;
    }
  } else {
#line 293
    w = head;
    {
#line 293
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 293
      if (! w) {
#line 293
        goto while_break___0;
      }
#line 294
      if ((unsigned long )w->next == (unsigned long )((void *)0)) {
        {
#line 295
        w->next = new_ywin(user, title);
#line 296
        w = w->next;
        }
#line 297
        goto while_break___0;
      }
#line 293
      w = w->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 299
  user->term = (yterm )w;
#line 302
  curses_redraw();
  }
#line 304
  return (0);
}
}
#line 310 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/cwin.c"
void close_curses(yuser *user ) 
{ 
  register ywin *w ;
  register ywin *p ;

  {
#line 318
  w = (ywin *)user->term;
#line 319
  if ((unsigned long )w == (unsigned long )head) {
#line 320
    head = w->next;
  } else {
#line 322
    p = head;
    {
#line 322
    while (1) {
      while_continue: /* CIL Label */ ;
#line 322
      if (! p) {
#line 322
        goto while_break;
      }
#line 323
      if ((unsigned long )w == (unsigned long )p->next) {
#line 324
        p->next = w->next;
#line 325
        goto while_break;
      }
#line 322
      p = p->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 327
    if ((unsigned long )p == (unsigned long )((void *)0)) {
      {
#line 328
      show_error("close_curses: user not found");
      }
#line 329
      return;
    }
  }
  {
#line 332
  delwin(w->win);
#line 333
  free_mem(w);
#line 334
  w = (ywin *)((void *)0);
#line 335
  user->term = (void *)0;
#line 336
  curses_redraw();
  }
#line 337
  return;
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/cwin.c"
void addch_curses(yuser *user , ychar c ) 
{ 
  register ywin *w ;
  register int x ;
  register int y ;

  {
#line 347
  w = (ywin *)user->term;
#line 348
  if (w->win) {
#line 348
    y = (int )(w->win)->_cury;
  } else {
#line 348
    y = -1;
  }
#line 348
  if (w->win) {
#line 348
    x = (int )(w->win)->_curx;
  } else {
#line 348
    x = -1;
  }
  {
#line 349
  waddch(w->win, (chtype const   )c);
  }
#line 350
  if (x >= COLS - 1) {
    {
#line 351
    wmove(w->win, y, x);
    }
  }
#line 352
  return;
}
}
#line 354 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/cwin.c"
void move_curses(yuser *user , int y , int x ) 
{ 
  register ywin *w ;

  {
  {
#line 361
  w = (ywin *)user->term;
#line 362
  wmove(w->win, y, x);
  }
#line 363
  return;
}
}
#line 365 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/cwin.c"
void clreol_curses(yuser *user ) 
{ 
  register ywin *w ;

  {
  {
#line 371
  w = (ywin *)user->term;
#line 372
  wclrtoeol(w->win);
  }
#line 373
  return;
}
}
#line 375 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/cwin.c"
void clreos_curses(yuser *user ) 
{ 
  register ywin *w ;

  {
  {
#line 381
  w = (ywin *)user->term;
#line 382
  wclrtobot(w->win);
  }
#line 383
  return;
}
}
#line 385 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/cwin.c"
void scroll_curses(yuser *user ) 
{ 
  register ywin *w ;

  {
  {
#line 397
  w = (ywin *)user->term;
#line 398
  scrollok(w->win, (_Bool)1);
#line 399
  wscrl(w->win, 1);
#line 400
  scrollok(w->win, (_Bool)0);
#line 406
  wmove(w->win, (int )user->t_rows - 1, 0);
#line 407
  wclrtoeol(w->win);
#line 408
  wmove(w->win, user->y, user->x);
  }
#line 409
  return;
}
}
#line 411 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/cwin.c"
void keypad_curses(_Bool bf ) 
{ 


  {
  {
#line 416
  keypad(((ywin *)me->term)->win, bf);
  }
#line 418
  return;
}
}
#line 420 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/cwin.c"
void flush_curses(yuser *user ) 
{ 
  register ywin *w ;

  {
  {
#line 426
  w = (ywin *)user->term;
#line 427
  wrefresh(w->win);
  }
#line 428
  return;
}
}
#line 433 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/cwin.c"
void redisplay_curses(void) 
{ 
  register ywin *w ;

  {
  {
#line 438
  wclear(stdscr);
#line 439
  wrefresh(stdscr);
#line 440
  w = head;
  }
  {
#line 440
  while (1) {
    while_continue: /* CIL Label */ ;
#line 440
    if (! w) {
#line 440
      goto while_break;
    }
    {
#line 441
    redraw_term(w->user, 0);
#line 442
    draw_title(w);
#line 443
    wrefresh(stdscr);
#line 444
    wrefresh(w->win);
#line 440
    w = w->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 446
  return;
}
}
#line 451 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/cwin.c"
void set_raw_curses(void) 
{ 


  {
  {
#line 454
  raw();
  }
#line 455
  return;
}
}
#line 460 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/cwin.c"
void set_cooked_curses(void) 
{ 


  {
  {
#line 463
  noraw();
#line 464
  cbreak();
#line 465
  noecho();
  }
#line 466
  return;
}
}
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 444 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 283 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/header.h"
char errstr[132]  ;
#line 291 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/header.h"
ylong myuid  ;
#line 313
char *str_copy(char *str ) ;
#line 354
void init_user(char *vhost___0 ) ;
#line 359
void free_users(void) ;
#line 361
void init_fd(void) ;
#line 365
void main_loop(void) ;
#line 367
void bail_loop(void) ;
#line 369
yuser *invite(char *name , int send_announce ) ;
#line 381
void init_socket(void) ;
#line 385
void kill_auto(void) ;
#line 395
void execute(char *command ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.h"
int show_mesg(char *mesg , void (*func)() ) ;
#line 44
int show_error_menu(char *str1 , char *str2 ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/main.c"
char *vhost  =    (char *)((void *)0);
#line 34 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/main.c"
void bail(int n ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 38
  kill_auto();
  }
#line 39
  if (n == -1) {
#line 39
    if ((long )def_flags & 8192L) {
      {
#line 40
      tmp___0 = show_mesg("Press any key to quit.", (void *)0);
      }
#line 40
      if (tmp___0 == 0) {
        {
#line 41
        update_menu();
#line 42
        bail_loop();
        }
      }
    }
  }
  {
#line 44
  end_term();
#line 45
  free_users();
  }
#line 49
  if (n == -1) {
#line 49
    tmp___1 = 0;
  } else {
#line 49
    tmp___1 = n;
  }
  {
#line 49
  exit(tmp___1);
  }
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/main.c"
static int in_error  =    0;
#line 59 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/main.c"
void show_error(char *str ) 
{ 
  register char *syserr ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 66
  tmp___1 = __errno_location();
  }
#line 66
  if (*tmp___1 == 0) {
#line 67
    syserr = (char *)((void *)0);
  } else {
    {
#line 69
    tmp___0 = __errno_location();
#line 69
    syserr = strerror(*tmp___0);
    }
  }
#line 71
  if ((long )def_flags & 2048L) {
    {
#line 72
    _IO_putc(7, stderr);
    }
  }
#line 73
  if (in_error == 0) {
    {
#line 73
    tmp___3 = what_term();
    }
#line 73
    if (tmp___3 != 0) {
      {
#line 74
      in_error = 1;
#line 75
      tmp___2 = show_error_menu(str, syserr);
      }
#line 75
      if (tmp___2 < 0) {
        {
#line 76
        show_error((char *)"show_error: show_error_menu() failed");
#line 77
        show_error(str);
        }
      } else {
        {
#line 79
        update_menu();
        }
      }
#line 80
      in_error = 0;
    } else {
#line 73
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 82
    if ((unsigned long )syserr != (unsigned long )((void *)0)) {
      {
#line 83
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n",
              str, syserr);
      }
    } else {
      {
#line 85
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              str);
      }
    }
    {
#line 86
    sleep(2U);
    }
  }
#line 88
  return;
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/main.c"
char *str_copy(char *str ) 
{ 
  register char *out ;
  register size_t len ;
  size_t tmp___0 ;
  yaddr tmp___1 ;

  {
#line 100
  if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 101
    return ((char *)((void *)0));
  }
  {
#line 102
  tmp___0 = strlen((char const   *)str);
#line 102
  len = tmp___0 + 1UL;
#line 103
  tmp___1 = get_mem(len);
#line 103
  out = (char *)tmp___1;
#line 104
  memcpy((void */* __restrict  */)out, (void const   */* __restrict  */)str, len);
  }
#line 105
  return (out);
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/main.c"
static void got_sig(int n ) 
{ 


  {
#line 115
  if (n == 2) {
#line 116
    if ((long )def_flags & 4096L) {
#line 117
      return;
    }
    {
#line 118
    bail(0);
    }
  }
  {
#line 120
  bail(3);
  }
#line 121
  return;
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/main.c"
int main(int argc , char **argv ) 
{ 
  int sflg ;
  int yflg ;
  int iflg ;
  int vflg ;
  int qflg ;
  int eflg ;
  char *prog ;
  char **tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;

  {
#line 129
  sflg = 0;
#line 129
  yflg = 0;
#line 129
  iflg = 0;
#line 129
  vflg = 0;
#line 129
  qflg = 0;
#line 129
  eflg = 0;
#line 142
  prog = *argv;
#line 143
  argv ++;
#line 143
  argc --;
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if (argc > 0) {
#line 144
      if (! ((int )*(*argv) == 45)) {
#line 144
        goto while_break;
      }
    } else {
#line 144
      goto while_break;
    }
    {
#line 145
    tmp___7 = strcmp((char const   *)*argv, "-Y");
    }
#line 145
    if (tmp___7 == 0) {
#line 146
      yflg ++;
#line 147
      argv ++;
#line 147
      argc --;
    } else {
      {
#line 148
      tmp___6 = strcmp((char const   *)*argv, "-E");
      }
#line 148
      if (tmp___6 == 0) {
#line 149
        eflg ++;
#line 150
        argv ++;
#line 150
        argc --;
      } else {
        {
#line 151
        tmp___5 = strcmp((char const   *)*argv, "-i");
        }
#line 151
        if (tmp___5 == 0) {
#line 152
          iflg ++;
#line 153
          argv ++;
#line 153
          argc --;
        } else {
          {
#line 154
          tmp___4 = strcmp((char const   *)*argv, "-v");
          }
#line 154
          if (tmp___4 == 0) {
#line 155
            vflg ++;
#line 156
            argv ++;
#line 156
            argc --;
          } else {
            {
#line 157
            tmp___3 = strcmp((char const   *)*argv, "-h");
            }
#line 157
            if (tmp___3 == 0) {
#line 158
              argv ++;
#line 159
              tmp___0 = argv;
#line 159
              argv ++;
#line 159
              vhost = *tmp___0;
#line 160
              argc -= 2;
            } else {
              {
#line 161
              tmp___2 = strcmp((char const   *)*argv, "-s");
              }
#line 161
              if (tmp___2 == 0) {
#line 162
                sflg ++;
#line 163
                argv ++;
#line 163
                argc --;
              } else {
                {
#line 164
                tmp___1 = strcmp((char const   *)*argv, "-q");
                }
#line 164
                if (tmp___1 == 0) {
#line 165
                  qflg ++;
#line 166
                  argv ++;
#line 166
                  argc --;
                } else {
#line 168
                  argc = 0;
                }
              }
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 171
  if (vflg) {
    {
#line 173
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"YTalk %s\n",
            "3.3.0");
#line 174
    exit(0);
    }
  }
#line 178
  if (argc <= 0) {
    {
#line 179
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage:    %s [options] user[@host][#tty]...\n",
            prog);
#line 180
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Options:     -i             --    no auto-invite port\n             -Y             --    require caps on all y/n answers\n             -E             --    require <esc> before y/n answers\n             -s             --    start a shell\n             -q             --    prompt before quitting\n             -v             --    print program version\n             -h host_or_ip  --    select interface or virtual host\n");
#line 188
    exit(1);
    }
  }
  {
#line 192
  signal(2, & got_sig);
#line 193
  signal(1, & got_sig);
#line 194
  signal(3, & got_sig);
#line 195
  signal(6, & got_sig);
#line 196
  signal(13, (void (*)(int  ))1);
#line 199
  myuid = getuid();
#line 202
  def_flags = (ylong )3106L;
#line 205
  tmp___8 = __errno_location();
#line 205
  *tmp___8 = 0;
#line 206
  init_fd();
#line 207
  read_ytalkrc();
#line 208
  init_user(vhost);
  }
#line 209
  if (yflg) {
#line 210
    def_flags = (ylong )((long )def_flags | 256L);
  }
#line 211
  if (eflg) {
#line 212
    def_flags = (ylong )((long )def_flags | 16384L);
  }
#line 213
  if (iflg) {
#line 214
    def_flags = (ylong )((long )def_flags | 512L);
  }
#line 215
  if (qflg) {
#line 216
    def_flags = (ylong )((long )def_flags | 8192L);
  }
  {
#line 218
  init_term();
#line 219
  init_socket();
  }
  {
#line 220
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 220
    if (! (argc > 0)) {
#line 220
      goto while_break___0;
    }
    {
#line 221
    invite(*argv, 1);
#line 220
    argc --;
#line 220
    argv ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 222
  if (sflg) {
    {
#line 223
    execute((void *)0);
    }
  } else {
    {
#line 225
    msg_term(me, "Waiting for connection...");
    }
  }
  {
#line 226
  main_loop();
#line 227
  bail(-1);
  }
#line 229
  return (0);
}
}
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 279 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/header.h"
yuser *connect_list ;
#line 280
yuser *wait_list ;
#line 287
ychar *io_ptr ;
#line 288
int io_len ;
#line 356
void free_user(yuser *user ) ;
#line 366
void input_loop(void) ;
#line 379
void rering_all(void) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.h"
void kill_menu(void) ;
#line 38
int show_menu(menu_item *menu , int len ) ;
#line 39
int show_text(char *prompt , void (*func)() ) ;
#line 41
int show_main_menu(void) ;
#line 42
int show_option_menu(void) ;
#line 43
int show_user_menu(char *title , void (*func)() , int metoo ) ;
#line 45
int yes_no(char *prompt ) ;
#line 46
void update_user_menu(void) ;
#line 47
void stalkversion(yuser *user , char *buf___3 , size_t len ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
int show_user_list(void) ;
#line 39
static void main_menu_sel(ychar key___0 ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
menu_item *menu_ptr  =    (menu_item *)((void *)0);
#line 41 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
static int menu_len  ;
#line 42 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
static int menu_long  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
static int menu_line  ;
#line 44 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
static int text_pos  =    -1;
#line 45 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
static int text_ypos  =    -1;
#line 45 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
static int text_xpos  =    -1;
#line 51 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
static menu_item main_menu[12]  = 
#line 51
  {      {(char *)"Main Menu", (void (*)())((void *)0), (ychar )' '}, 
        {(char *)"", (void (*)())((void *)0), (ychar )' '}, 
        {(char *)"add a user", & main_menu_sel, (ychar )'a'}, 
        {(char *)"delete a user", & main_menu_sel, (ychar )'d'}, 
        {(char *)"kill all unconnected", & main_menu_sel, (ychar )'k'}, 
        {(char *)"options", & main_menu_sel, (ychar )'o'}, 
        {(char *)"rering all", & main_menu_sel, (ychar )'r'}, 
        {(char *)"shell", & main_menu_sel, (ychar )'s'}, 
        {(char *)"user list", & main_menu_sel, (ychar )'u'}, 
        {(char *)"output user to file", & main_menu_sel, (ychar )'w'}, 
        {(char *)"quit", & main_menu_sel, (ychar )'q'}, 
        {(char *)"", (void (*)())((void *)0), (ychar )'\000'}};
#line 67 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
static menu_item user_menu[52]  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
static menu_item option_menu[20]  ;
#line 69 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
static menu_item yes_no_menu[1]  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
static menu_item mesg_menu[1]  ;
#line 72 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
static char text_str[51]  ;
#line 73 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
static menu_item text_menu[2]  ;
#line 74 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
static char user_buf[52][80]  ;
#line 78 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
static int got_error  =    0;
#line 79 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
static char err_str[8][132]  ;
#line 80 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
static menu_item error_menu[14]  = 
#line 80
  {      {(char *)"Ytalk Error", (void (*)())((void *)0), (ychar )' '}, 
        {(char *)"", (void (*)())((void *)0), (ychar )' '}, 
        {(char *)((void *)0), & show_error, (ychar )' '}, 
        {(char *)((void *)0), & show_error, (ychar )' '}, 
        {(char *)"", (void (*)())((void *)0), (ychar )' '}, 
        {(char *)((void *)0), & show_error, (ychar )' '}, 
        {(char *)((void *)0), & show_error, (ychar )' '}, 
        {(char *)"", (void (*)())((void *)0), (ychar )' '}, 
        {(char *)((void *)0), & show_error, (ychar )' '}, 
        {(char *)((void *)0), & show_error, (ychar )' '}, 
        {(char *)"", (void (*)())((void *)0), (ychar )' '}, 
        {(char *)((void *)0), & show_error, (ychar )' '}, 
        {(char *)((void *)0), & show_error, (ychar )' '}, 
        {(char *)"", (void (*)())((void *)0), (ychar )'\000'}};
#line 99 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
static yuser *output_user  =    (yuser *)((void *)0);
#line 101 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
static void do_output(char *filename ) 
{ 
  int fd ;

  {
#line 107
  if ((unsigned long )output_user == (unsigned long )((void *)0)) {
#line 108
    return;
  }
  {
#line 109
  fd = open((char const   *)filename, 578, 384);
  }
#line 109
  if (fd < 0) {
    {
#line 110
    show_error(filename);
    }
#line 111
    return;
  }
  {
#line 113
  output_user->output_fd = fd;
#line 114
  spew_term(output_user, fd, (int )output_user->rows, (int )output_user->cols);
#line 115
  output_user = (yuser *)((void *)0);
  }
#line 116
  return;
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
static void do_output_user(yuser *user ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
#line 123
  if (user->output_fd > 0) {
    {
#line 124
    close(user->output_fd);
#line 125
    user->output_fd = 0;
#line 126
    tmp___0 = show_mesg("Output Terminated", (void *)0);
    }
#line 126
    if (tmp___0 >= 0) {
      {
#line 127
      update_menu();
      }
    }
#line 128
    return;
  }
  {
#line 132
  output_user = user;
#line 133
  tmp___1 = show_text("Output filename?", & do_output);
  }
#line 133
  if (tmp___1 >= 0) {
    {
#line 134
    update_menu();
    }
  } else {
#line 136
    output_user = (yuser *)((void *)0);
  }
#line 137
  return;
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
static void do_invite(char *name ) 
{ 


  {
  {
#line 143
  invite(name, 1);
  }
#line 144
  return;
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
static void kill_all_unconnected(void) 
{ 


  {
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 149
    if (! wait_list) {
#line 149
      goto while_break;
    }
    {
#line 150
    free_user(wait_list);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 151
  return;
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
static void main_menu_sel(ychar key___0 ) 
{ 
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 158
  if ((int )key___0 == 97) {
#line 158
    goto case_97;
  }
#line 162
  if ((int )key___0 == 100) {
#line 162
    goto case_100;
  }
#line 166
  if ((int )key___0 == 107) {
#line 166
    goto case_107;
  }
#line 170
  if ((int )key___0 == 111) {
#line 170
    goto case_111;
  }
#line 174
  if ((int )key___0 == 114) {
#line 174
    goto case_114;
  }
#line 178
  if ((int )key___0 == 115) {
#line 178
    goto case_115;
  }
#line 182
  if ((int )key___0 == 117) {
#line 182
    goto case_117;
  }
#line 186
  if ((int )key___0 == 119) {
#line 186
    goto case_119;
  }
#line 190
  if ((int )key___0 == 113) {
#line 190
    goto case_113;
  }
#line 157
  goto switch_break;
  case_97: /* CIL Label */ 
  {
#line 159
  tmp___0 = show_text("Add Which User?", & do_invite);
  }
#line 159
  if (tmp___0 >= 0) {
    {
#line 160
    update_menu();
    }
  }
#line 161
  goto switch_break;
  case_100: /* CIL Label */ 
  {
#line 163
  tmp___1 = show_user_menu("Delete Which User?", & free_user, 0);
  }
#line 163
  if (tmp___1 >= 0) {
    {
#line 164
    update_menu();
    }
  }
#line 165
  goto switch_break;
  case_107: /* CIL Label */ 
  {
#line 167
  kill_all_unconnected();
#line 168
  kill_menu();
  }
#line 169
  goto switch_break;
  case_111: /* CIL Label */ 
  {
#line 171
  tmp___2 = show_option_menu();
  }
#line 171
  if (tmp___2 >= 0) {
    {
#line 172
    update_menu();
    }
  }
#line 173
  goto switch_break;
  case_114: /* CIL Label */ 
  {
#line 175
  rering_all();
#line 176
  kill_menu();
  }
#line 177
  goto switch_break;
  case_115: /* CIL Label */ 
  {
#line 179
  kill_menu();
#line 180
  execute((void *)0);
  }
#line 181
  goto switch_break;
  case_117: /* CIL Label */ 
  {
#line 183
  tmp___3 = show_user_list();
  }
#line 183
  if (tmp___3 >= 0) {
    {
#line 184
    update_menu();
    }
  }
#line 185
  goto switch_break;
  case_119: /* CIL Label */ 
  {
#line 187
  tmp___4 = show_user_menu("Output Which User?", & do_output_user, 1);
  }
#line 187
  if (tmp___4 >= 0) {
    {
#line 188
    update_menu();
    }
  }
#line 189
  goto switch_break;
  case_113: /* CIL Label */ 
  {
#line 191
  bail(0);
  }
  switch_break: /* CIL Label */ ;
  }
#line 193
  return;
}
}
#line 195 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
static void option_menu_sel(ychar key___0 ) 
{ 
  register yuser *u ;
  ylong old_flags ;
  int tmp___0 ;

  {
#line 202
  old_flags = def_flags;
  {
#line 204
  if ((int )key___0 == 115) {
#line 204
    goto case_115;
  }
#line 207
  if ((int )key___0 == 119) {
#line 207
    goto case_119;
  }
#line 210
  if ((int )key___0 == 105) {
#line 210
    goto case_105;
  }
#line 213
  if ((int )key___0 == 118) {
#line 213
    goto case_118;
  }
#line 216
  if ((int )key___0 == 114) {
#line 216
    goto case_114;
  }
#line 219
  if ((int )key___0 == 112) {
#line 219
    goto case_112;
  }
#line 222
  if ((int )key___0 == 113) {
#line 222
    goto case_113;
  }
#line 203
  goto switch_break;
  case_115: /* CIL Label */ 
#line 205
  def_flags = (ylong )((long )def_flags ^ 2L);
#line 206
  goto switch_break;
  case_119: /* CIL Label */ 
#line 208
  def_flags = (ylong )((long )def_flags ^ 4L);
#line 209
  goto switch_break;
  case_105: /* CIL Label */ 
#line 211
  def_flags = (ylong )((long )def_flags ^ 8L);
#line 212
  goto switch_break;
  case_118: /* CIL Label */ 
#line 214
  def_flags = (ylong )((long )def_flags ^ 16L);
#line 215
  goto switch_break;
  case_114: /* CIL Label */ 
#line 217
  def_flags = (ylong )((long )def_flags ^ 32L);
#line 218
  goto switch_break;
  case_112: /* CIL Label */ 
#line 220
  def_flags = (ylong )((long )def_flags ^ 1024L);
#line 221
  goto switch_break;
  case_113: /* CIL Label */ 
#line 223
  def_flags = (ylong )((long )def_flags ^ 8192L);
#line 224
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 227
  if (old_flags != def_flags) {
#line 228
    u = user_list;
    {
#line 228
    while (1) {
      while_continue: /* CIL Label */ ;
#line 228
      if (! ((unsigned long )u != (unsigned long )((void *)0))) {
#line 228
        goto while_break;
      }
#line 229
      if (! ((long )u->flags & 1073741824L)) {
#line 230
        u->flags = def_flags;
      }
#line 228
      u = u->unext;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 232
  tmp___0 = show_option_menu();
  }
#line 232
  if (tmp___0 >= 0) {
    {
#line 233
    update_menu();
    }
  } else {
    {
#line 235
    kill_menu();
    }
  }
#line 236
  return;
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
static void user_menu_sel(ychar key___0 ) 
{ 
  register int i ;
  register yuser *u ;
  int tmp___0 ;

  {
#line 250
  i = 0;
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    if (! (i < menu_len)) {
#line 250
      goto while_break;
    }
#line 251
    if ((int )user_menu[i].key == (int )key___0) {
#line 252
      u = user_list;
      {
#line 252
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 252
        if (! u) {
#line 252
          goto while_break___0;
        }
#line 253
        if ((int )u->key == (int )key___0) {
          {
#line 253
          tmp___0 = strcmp((char const   *)u->full_name, (char const   *)user_menu[i].item);
          }
#line 253
          if (tmp___0 == 0) {
            {
#line 255
            (*(user_menu[0].func))(u);
            }
#line 256
            goto while_break___0;
          }
        }
#line 252
        u = u->unext;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 258
      goto while_break;
    }
#line 250
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 260
  if ((unsigned long )menu_ptr == (unsigned long )(user_menu)) {
    {
#line 261
    kill_menu();
    }
  }
#line 262
  return;
}
}
#line 267 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
static void generate_text_length(void) 
{ 


  {
#line 270
  menu_long = ((int )me->t_cols - 7) - 2;
#line 271
  if (menu_long < 5) {
#line 272
    menu_long = 50;
  } else
#line 271
  if (menu_long > 50) {
#line 272
    menu_long = 50;
  }
#line 273
  return;
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
static void generate_yes_no_length(void) 
{ 
  size_t tmp___0 ;

  {
  {
#line 278
  tmp___0 = strlen((char const   *)yes_no_menu[0].item);
#line 278
  menu_long = (int )(tmp___0 - 2UL);
  }
#line 279
  return;
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
static void pad_str(char *from , int len , char *to ) 
{ 
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 286
    if (len > 0) {
#line 286
      if (! *from) {
#line 286
        goto while_break;
      }
    } else {
#line 286
      goto while_break;
    }
#line 287
    tmp___0 = to;
#line 287
    to ++;
#line 287
    *tmp___0 = *from;
#line 286
    len --;
#line 286
    from ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 288
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 288
    if (! (len > 0)) {
#line 288
      goto while_break___0;
    }
#line 289
    tmp___1 = to;
#line 289
    to ++;
#line 289
    *tmp___1 = (char )' ';
#line 288
    len --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 290
  *to = (char )'\000';
#line 291
  return;
}
}
#line 298 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
void kill_menu(void) 
{ 
  register int i ;

  {
#line 303
  if ((unsigned long )menu_ptr != (unsigned long )((void *)0)) {
    {
#line 304
    menu_ptr = (menu_item *)((void *)0);
#line 305
    redraw_term(me, 0);
#line 306
    flush_term(me);
#line 307
    text_pos = -1;
#line 308
    text_ypos = -1;
#line 309
    text_xpos = -1;
    }
  }
#line 311
  if (got_error) {
#line 312
    got_error = 0;
#line 313
    i = 0;
    {
#line 313
    while (1) {
      while_continue: /* CIL Label */ ;
#line 313
      if (! ((int )error_menu[i].key != 0)) {
#line 313
        goto while_break;
      }
#line 314
      if ((unsigned long )error_menu[i].func != (unsigned long )((void *)0)) {
#line 315
        error_menu[i].item = (char *)((void *)0);
      }
#line 313
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 317
  return;
}
}
#line 328 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
static ychar *buf___0  =    (ychar *)((void *)0);
#line 329 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
static int buflen  =    0;
#line 322 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
void update_menu(void) 
{ 
  register ychar *c ;
  register char *d ;
  register int j ;
  register int i ;
  register int y ;
  register int x ;
  ychar ic ;
  ychar *tmp___0 ;
  ychar *tmp___1 ;
  ychar *tmp___2 ;
  yaddr tmp___3 ;
  int tmp___4 ;
  ychar *tmp___5 ;
  ychar *tmp___6 ;
  ychar *tmp___7 ;
  ychar *tmp___8 ;
  int temp___0 ;
  size_t tmp___9 ;
  ychar *tmp___10 ;
  ychar *tmp___11 ;
  ychar *tmp___12 ;
  ychar *tmp___13 ;
  ychar *tmp___14 ;
  ychar *tmp___15 ;
  ychar *tmp___16 ;
  ychar *tmp___17 ;
  ychar *tmp___18 ;
  ychar *tmp___19 ;
  ychar *tmp___20 ;
  ychar *tmp___21 ;
  ychar *tmp___22 ;
  ychar *tmp___23 ;
  ychar *tmp___24 ;
  ychar *tmp___25 ;
  ychar *tmp___26 ;
  ychar *tmp___27 ;
  ychar *tmp___28 ;

  {
#line 331
  if ((unsigned long )menu_ptr == (unsigned long )((void *)0)) {
#line 332
    return;
  }
#line 336
  if (io_len > 0) {
#line 339
    if ((unsigned long )menu_ptr == (unsigned long )(text_menu)) {
      {
#line 340
      while (1) {
        while_continue: /* CIL Label */ ;
#line 340
        if (! (io_len > 0)) {
#line 340
          goto while_break;
        }
#line 341
        tmp___0 = io_ptr;
#line 341
        io_ptr ++;
#line 341
        ic = *tmp___0;
#line 343
        if ((int )ic > 32) {
#line 343
          if ((int )ic <= 126) {
#line 344
            if (text_pos >= menu_long) {
#line 344
              if ((long )def_flags & 2048L) {
                {
#line 345
                _IO_putc(7, stderr);
                }
              } else {
#line 344
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
#line 347
              text_str[text_pos] = (char )ic;
#line 348
              if (text_ypos >= 0) {
                {
#line 349
                raw_term(me, text_ypos, text_xpos + text_pos, text_str + text_pos,
                         1);
                }
              }
#line 351
              text_pos ++;
#line 351
              text_str[text_pos] = (char )'\000';
            }
          } else {
#line 343
            goto _L___2;
          }
        } else
        _L___2: /* CIL Label */ 
#line 353
        if ((int )ic == (int )me->old_rub) {
#line 354
          if (text_pos > 0) {
#line 355
            text_pos --;
#line 355
            text_str[text_pos] = (char )'\000';
#line 356
            if (text_ypos >= 0) {
              {
#line 357
              raw_term(me, text_ypos, text_xpos + text_pos, " ", 1);
              }
            }
          }
        } else
#line 360
        if ((int )ic == (int )me->edit[1]) {
#line 360
          goto _L___1;
        } else
#line 360
        if ((int )ic == (int )me->edit[2]) {
          _L___1: /* CIL Label */ 
#line 361
          if (text_pos > 0) {
#line 362
            text_str[0] = (char )'\000';
#line 363
            text_pos = 0;
#line 364
            if (text_ypos > 0) {
              {
#line 365
              raw_term(me, text_ypos, text_xpos, "     ", menu_long);
              }
            }
          }
        } else
#line 368
        if ((int )ic == 10) {
#line 368
          goto _L___0;
        } else
#line 368
        if ((int )ic == 13) {
          _L___0: /* CIL Label */ 
#line 369
          if (text_pos > 0) {
            {
#line 370
            text_str[text_pos] = (char )'\000';
#line 371
            kill_menu();
#line 372
            (*(text_menu[0].func))(text_str);
            }
          } else {
            {
#line 374
            kill_menu();
            }
          }
#line 375
          return;
        } else
#line 376
        if ((int )ic == 27) {
          {
#line 377
          kill_menu();
          }
#line 378
          return;
        } else
#line 376
        if ((int )ic == 4) {
          {
#line 377
          kill_menu();
          }
#line 378
          return;
        }
#line 340
        io_len --;
      }
      while_break: /* CIL Label */ ;
      }
#line 381
      if (text_ypos >= 0) {
        {
#line 382
        raw_term(me, text_ypos, text_xpos + text_pos, (void *)0, 0);
#line 383
        flush_term(me);
        }
#line 384
        return;
      }
    } else
#line 386
    if (! ((unsigned long )menu_ptr == (unsigned long )(yes_no_menu))) {
#line 388
      if ((unsigned long )menu_ptr == (unsigned long )(mesg_menu)) {
        {
#line 389
        tmp___1 = io_ptr;
#line 389
        io_ptr ++;
#line 389
        ic = *tmp___1;
#line 390
        io_len --;
#line 391
        kill_menu();
        }
#line 392
        if (mesg_menu[0].func) {
          {
#line 393
          (*(mesg_menu[0].func))((int )ic);
          }
        }
#line 394
        return;
      } else {
#line 396
        tmp___2 = io_ptr;
#line 396
        io_ptr ++;
#line 396
        ic = *tmp___2;
#line 397
        io_len --;
#line 398
        if ((int )ic == 32) {
#line 398
          goto _L___3;
        } else
#line 398
        if ((int )ic == 10) {
#line 398
          goto _L___3;
        } else
#line 398
        if ((int )ic == 13) {
          _L___3: /* CIL Label */ 
#line 401
          menu_line += (int )me->t_rows - 1;
#line 402
          if (menu_line >= menu_len) {
            {
#line 403
            kill_menu();
            }
#line 404
            return;
          }
#line 406
          i = menu_len - ((int )me->t_rows - 1);
#line 407
          if (i < menu_line) {
#line 408
            menu_line = i;
          }
        } else
#line 409
        if ((int )ic > 32) {
#line 409
          if ((int )ic <= 126) {
#line 410
            i = 0;
            {
#line 410
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 410
              if (! (i < menu_len)) {
#line 410
                goto while_break___0;
              }
#line 411
              if ((int )(menu_ptr + i)->key == (int )ic) {
#line 411
                if ((unsigned long )(menu_ptr + i)->func != (unsigned long )((void *)0)) {
                  {
#line 412
                  (*((menu_ptr + i)->func))((int )ic);
#line 416
                  i = -1;
                  }
#line 417
                  goto while_break___0;
                }
              }
#line 410
              i ++;
            }
            while_break___0: /* CIL Label */ ;
            }
#line 419
            if (i >= 0) {
              {
#line 420
              kill_menu();
              }
            }
#line 421
            return;
          } else {
            {
#line 423
            kill_menu();
            }
#line 424
            return;
          }
        } else {
          {
#line 423
          kill_menu();
          }
#line 424
          return;
        }
      }
    }
  }
#line 433
  if ((unsigned long )menu_ptr == (unsigned long )(text_menu)) {
    {
#line 434
    generate_text_length();
#line 435
    text_ypos = -1;
#line 436
    text_xpos = -1;
    }
  } else
#line 437
  if ((unsigned long )menu_ptr == (unsigned long )(yes_no_menu)) {
    {
#line 438
    menu_len = 1;
#line 439
    menu_line = 0;
#line 440
    generate_yes_no_length();
    }
  }
#line 442
  if (menu_long > buflen) {
    {
#line 443
    buflen = menu_long + 64;
#line 444
    tmp___3 = realloc_mem(buf___0, buflen + 7);
#line 444
    buf___0 = (ychar *)tmp___3;
    }
  }
  {
#line 448
  x = center((int )me->t_cols, menu_long + 7);
  }
#line 449
  if (menu_line == 0) {
#line 450
    if (menu_len + 2 <= (int )me->t_rows) {
      {
#line 451
      y = center((int )me->t_rows, menu_len + 2);
#line 452
      tmp___4 = y;
#line 452
      y ++;
#line 452
      raw_term(me, tmp___4, x, "#####", menu_long + 7);
      }
    } else {
#line 454
      y = 0;
    }
  } else {
#line 456
    y = 0;
  }
#line 460
  i = menu_line;
  {
#line 460
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 460
    if (y + 1 < (int )me->t_rows) {
#line 460
      if (! (i < menu_len)) {
#line 460
        goto while_break___1;
      }
    } else {
#line 460
      goto while_break___1;
    }
#line 461
    c = buf___0;
#line 462
    tmp___5 = c;
#line 462
    c ++;
#line 462
    *tmp___5 = (ychar )'#';
#line 463
    tmp___6 = c;
#line 463
    c ++;
#line 463
    *tmp___6 = (ychar )' ';
#line 464
    if ((int )(menu_ptr + i)->key == 32) {
#line 465
      j = 0;
#line 466
      if ((unsigned long )menu_ptr == (unsigned long )(text_menu)) {
#line 467
        if (i > 0) {
#line 468
          tmp___7 = c;
#line 468
          c ++;
#line 468
          *tmp___7 = (ychar )'>';
#line 469
          tmp___8 = c;
#line 469
          c ++;
#line 469
          *tmp___8 = (ychar )' ';
#line 470
          j += 2;
#line 471
          text_ypos = y;
#line 472
          text_xpos = (x + j) + 2;
        }
      } else
#line 474
      if ((unsigned long )menu_ptr != (unsigned long )(yes_no_menu)) {
        {
#line 476
        tmp___9 = strlen((char const   *)(menu_ptr + i)->item);
#line 476
        temp___0 = center(menu_long + 3, tmp___9);
        }
        {
#line 477
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 477
          if (! (j < temp___0)) {
#line 477
            goto while_break___2;
          }
#line 478
          tmp___10 = c;
#line 478
          c ++;
#line 478
          *tmp___10 = (ychar )' ';
#line 477
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 480
      d = (menu_ptr + i)->item;
      {
#line 480
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 480
        if (! *d) {
#line 480
          goto while_break___3;
        }
#line 481
        tmp___11 = c;
#line 481
        c ++;
#line 481
        *tmp___11 = (ychar )*d;
#line 480
        d ++;
#line 480
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 482
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 482
        if (! (j < menu_long + 3)) {
#line 482
          goto while_break___4;
        }
#line 483
        tmp___12 = c;
#line 483
        c ++;
#line 483
        *tmp___12 = (ychar )' ';
#line 482
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else {
#line 485
      tmp___13 = c;
#line 485
      c ++;
#line 485
      *tmp___13 = (menu_ptr + i)->key;
#line 486
      tmp___14 = c;
#line 486
      c ++;
#line 486
      *tmp___14 = (ychar )':';
#line 487
      tmp___15 = c;
#line 487
      c ++;
#line 487
      *tmp___15 = (ychar )' ';
#line 488
      d = (menu_ptr + i)->item;
#line 488
      j = 0;
      {
#line 488
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 488
        if (! *d) {
#line 488
          goto while_break___5;
        }
#line 489
        tmp___16 = c;
#line 489
        c ++;
#line 489
        *tmp___16 = (ychar )*d;
#line 488
        d ++;
#line 488
        j ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 490
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 490
        if (! (j < menu_long)) {
#line 490
          goto while_break___6;
        }
#line 491
        tmp___17 = c;
#line 491
        c ++;
#line 491
        *tmp___17 = (ychar )' ';
#line 490
        j ++;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
    {
#line 493
    tmp___18 = c;
#line 493
    c ++;
#line 493
    *tmp___18 = (ychar )' ';
#line 494
    tmp___19 = c;
#line 494
    c ++;
#line 494
    *tmp___19 = (ychar )'#';
#line 495
    raw_term(me, y, x, buf___0, c - buf___0);
#line 460
    i ++;
#line 460
    y ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 497
  if (y < (int )me->t_rows) {
#line 498
    if (i < menu_len) {
#line 499
      c = buf___0;
#line 500
      tmp___20 = c;
#line 500
      c ++;
#line 500
      *tmp___20 = (ychar )'#';
#line 501
      tmp___21 = c;
#line 501
      c ++;
#line 501
      *tmp___21 = (ychar )' ';
#line 502
      tmp___22 = c;
#line 502
      c ++;
#line 502
      *tmp___22 = (ychar )' ';
#line 503
      tmp___23 = c;
#line 503
      c ++;
#line 503
      *tmp___23 = (ychar )' ';
#line 504
      tmp___24 = c;
#line 504
      c ++;
#line 504
      *tmp___24 = (ychar )' ';
#line 505
      d = (char *)"(more)";
#line 505
      j = 0;
      {
#line 505
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 505
        if (! *d) {
#line 505
          goto while_break___7;
        }
#line 506
        tmp___25 = c;
#line 506
        c ++;
#line 506
        *tmp___25 = (ychar )*d;
#line 505
        d ++;
#line 505
        j ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 507
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 507
        if (! (j < menu_long)) {
#line 507
          goto while_break___8;
        }
#line 508
        tmp___26 = c;
#line 508
        c ++;
#line 508
        *tmp___26 = (ychar )' ';
#line 507
        j ++;
      }
      while_break___8: /* CIL Label */ ;
      }
      {
#line 509
      tmp___27 = c;
#line 509
      c ++;
#line 509
      *tmp___27 = (ychar )' ';
#line 510
      tmp___28 = c;
#line 510
      c ++;
#line 510
      *tmp___28 = (ychar )'#';
#line 511
      raw_term(me, y, x, buf___0, c - buf___0);
#line 512
      raw_term(me, y, x + 12, (void *)0, 0);
      }
    } else {
      {
#line 514
      raw_term(me, y, x, "#####", menu_long + 7);
      }
#line 515
      if ((unsigned long )menu_ptr == (unsigned long )(text_menu)) {
        {
#line 516
        raw_term(me, text_ypos, text_xpos + text_pos, (void *)0, 0);
        }
      } else
#line 517
      if ((unsigned long )menu_ptr == (unsigned long )(yes_no_menu)) {
        {
#line 518
        raw_term(me, y - 1, ((x + menu_long) + 7) - 2, (void *)0, 0);
        }
      } else {
        {
#line 520
        raw_term(me, y, (int )me->t_cols / 2, (void *)0, 0);
        }
      }
    }
  }
  {
#line 523
  flush_term(me);
  }
#line 524
  return;
}
}
#line 529 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
int show_menu(menu_item *menu , int len ) 
{ 
  register int i ;
  register int j ;
  size_t tmp___0 ;

  {
#line 536
  if ((int )me->t_rows < 2) {
    {
#line 537
    show_error("show_menu: window too small");
    }
#line 538
    return (-1);
  }
#line 542
  menu_long = 0;
#line 543
  i = 0;
  {
#line 543
  while (1) {
    while_continue: /* CIL Label */ ;
#line 543
    if (! (i < len)) {
#line 543
      goto while_break;
    }
    {
#line 544
    tmp___0 = strlen((char const   *)(menu + i)->item);
#line 544
    j = (int )tmp___0;
    }
#line 544
    if (j > menu_long) {
#line 545
      menu_long = j;
    }
#line 546
    if ((int )(menu + i)->key < 32) {
      {
#line 547
      show_error("show_menu: invalid key");
      }
#line 548
      return (-1);
    } else
#line 546
    if ((int )(menu + i)->key >= 126) {
      {
#line 547
      show_error("show_menu: invalid key");
      }
#line 548
      return (-1);
    }
#line 543
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 551
  if (menu_long <= 0) {
    {
#line 552
    show_error("show_menu: menu too small");
    }
#line 553
    return (-1);
  }
#line 555
  if (menu_long < 10) {
#line 556
    menu_long = 10;
  }
#line 560
  menu_ptr = menu;
#line 561
  menu_len = len;
#line 562
  menu_line = 0;
#line 564
  return (0);
}
}
#line 570 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
int show_text(char *prompt , void (*func)() ) 
{ 


  {
#line 575
  if ((int )me->t_rows < 3) {
    {
#line 576
    show_error("show_text: window too small");
    }
#line 577
    return (-1);
  }
  {
#line 581
  text_menu[0].item = prompt;
#line 582
  text_menu[0].func = func;
#line 583
  text_menu[0].key = (ychar )' ';
#line 585
  text_str[0] = (char )'\000';
#line 586
  text_menu[1].item = text_str;
#line 587
  text_menu[1].func = (void (*)())((void *)0);
#line 588
  text_menu[1].key = (ychar )' ';
#line 590
  menu_ptr = text_menu;
#line 591
  menu_len = 2;
#line 592
  menu_line = 0;
#line 593
  text_ypos = -1;
#line 594
  text_xpos = -1;
#line 595
  text_pos = 0;
#line 596
  generate_text_length();
  }
#line 598
  return (0);
}
}
#line 604 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
int show_mesg(char *mesg , void (*func)() ) 
{ 
  int tmp___0 ;

  {
  {
#line 611
  mesg_menu[0].item = mesg;
#line 612
  mesg_menu[0].func = func;
#line 613
  mesg_menu[0].key = (ychar )' ';
#line 615
  tmp___0 = show_menu(mesg_menu, 1);
  }
#line 615
  return (tmp___0);
}
}
#line 621 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
static int main_items  =    0;
#line 618 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
int show_main_menu(void) 
{ 
  int tmp___0 ;

  {
#line 623
  if (main_items == 0) {
    {
#line 624
    while (1) {
      while_continue: /* CIL Label */ ;
#line 624
      if (! ((int )main_menu[main_items].key != 0)) {
#line 624
        goto while_break;
      }
#line 625
      main_items ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 627
  tmp___0 = show_menu(main_menu, main_items);
  }
#line 627
  return (tmp___0);
}
}
#line 630 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
int show_option_menu(void) 
{ 
  register int i ;
  int tmp___0 ;

  {
#line 633
  i = 0;
#line 635
  option_menu[i].item = (char *)"Options Menu";
#line 636
  option_menu[i].func = (void (*)())((void *)0);
#line 637
  option_menu[i].key = (ychar )' ';
#line 638
  i ++;
#line 640
  option_menu[i].item = (char *)"";
#line 641
  option_menu[i].func = (void (*)())((void *)0);
#line 642
  option_menu[i].key = (ychar )' ';
#line 643
  i ++;
#line 645
  if ((long )def_flags & 2L) {
#line 646
    option_menu[i].item = (char *)"turn scrolling off";
  } else {
#line 648
    option_menu[i].item = (char *)"turn scrolling on";
  }
#line 649
  option_menu[i].func = (void (*)())(& option_menu_sel);
#line 650
  option_menu[i].key = (ychar )'s';
#line 651
  i ++;
#line 653
  if ((long )def_flags & 4L) {
#line 654
    option_menu[i].item = (char *)"turn word-wrap off";
  } else {
#line 656
    option_menu[i].item = (char *)"turn word-wrap on";
  }
#line 657
  option_menu[i].func = (void (*)())(& option_menu_sel);
#line 658
  option_menu[i].key = (ychar )'w';
#line 659
  i ++;
#line 661
  if ((long )def_flags & 8L) {
#line 662
    option_menu[i].item = (char *)"turn auto-import off";
  } else {
#line 664
    option_menu[i].item = (char *)"turn auto-import on";
  }
#line 665
  option_menu[i].func = (void (*)())(& option_menu_sel);
#line 666
  option_menu[i].key = (ychar )'i';
#line 667
  i ++;
#line 669
  if ((long )def_flags & 16L) {
#line 670
    option_menu[i].item = (char *)"turn auto-invite off";
  } else {
#line 672
    option_menu[i].item = (char *)"turn auto-invite on";
  }
#line 673
  option_menu[i].func = (void (*)())(& option_menu_sel);
#line 674
  option_menu[i].key = (ychar )'v';
#line 675
  i ++;
#line 677
  if ((long )def_flags & 32L) {
#line 678
    option_menu[i].item = (char *)"turn reringing off";
  } else {
#line 680
    option_menu[i].item = (char *)"turn reringing on";
  }
#line 681
  option_menu[i].func = (void (*)())(& option_menu_sel);
#line 682
  option_menu[i].key = (ychar )'r';
#line 683
  i ++;
#line 685
  if ((long )def_flags & 1024L) {
#line 686
    option_menu[i].item = (char *)"don\'t prompt rerings   ";
  } else {
#line 688
    option_menu[i].item = (char *)"prompt before reringing";
  }
#line 689
  option_menu[i].func = (void (*)())(& option_menu_sel);
#line 690
  option_menu[i].key = (ychar )'p';
#line 691
  i ++;
#line 693
  if ((long )def_flags & 8192L) {
#line 694
    option_menu[i].item = (char *)"don\'t prompt to quit";
  } else {
#line 696
    option_menu[i].item = (char *)"prompt before quitting";
  }
  {
#line 697
  option_menu[i].func = (void (*)())(& option_menu_sel);
#line 698
  option_menu[i].key = (ychar )'q';
#line 699
  i ++;
#line 701
  tmp___0 = show_menu(option_menu, i);
  }
#line 701
  return (tmp___0);
}
}
#line 704 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
int show_user_menu(char *title , void (*func)() , int metoo ) 
{ 
  register int i ;
  register yuser *u ;
  int tmp___0 ;

  {
#line 713
  user_menu[0].item = title;
#line 714
  user_menu[0].func = func;
#line 715
  user_menu[0].key = (ychar )(32 + (metoo != 0));
#line 717
  user_menu[1].item = (char *)"";
#line 718
  user_menu[1].func = (void (*)())((void *)0);
#line 719
  user_menu[1].key = (ychar )' ';
#line 721
  i = 2;
#line 721
  u = user_list;
  {
#line 721
  while (1) {
    while_continue: /* CIL Label */ ;
#line 721
    if ((unsigned long )u != (unsigned long )((void *)0)) {
#line 721
      if (! (i < 52)) {
#line 721
        goto while_break;
      }
    } else {
#line 721
      goto while_break;
    }
#line 722
    if ((unsigned long )u != (unsigned long )me) {
#line 722
      goto _L;
    } else
#line 722
    if (metoo) {
      _L: /* CIL Label */ 
#line 723
      if ((int )u->key != 0) {
        {
#line 724
        strcpy((char */* __restrict  */)(user_buf[i]), (char const   */* __restrict  */)u->full_name);
#line 725
        user_menu[i].item = user_buf[i];
#line 726
        user_menu[i].func = (void (*)())(& user_menu_sel);
#line 727
        user_menu[i].key = u->key;
#line 728
        i ++;
        }
      }
    }
#line 721
    u = u->unext;
  }
  while_break: /* CIL Label */ ;
  }
#line 731
  if (i > 2) {
    {
#line 732
    tmp___0 = show_menu(user_menu, i);
    }
#line 732
    return (tmp___0);
  }
  {
#line 733
  kill_menu();
  }
#line 734
  return (-1);
}
}
#line 737 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
void stalkversion(yuser *user , char *buf___3 , size_t len ) 
{ 


  {
#line 744
  if ((int )user->remote.vmajor > 2) {
    {
#line 745
    snprintf((char */* __restrict  */)buf___3, len, (char const   */* __restrict  */)"YTalk V%d.%d",
             (int )user->remote.vmajor, (int )user->remote.vminor);
    }
  } else
#line 747
  if ((int )user->remote.vmajor == 2) {
    {
#line 748
    snprintf((char */* __restrict  */)buf___3, len, (char const   */* __restrict  */)"YTalk V2.?");
    }
  } else
#line 749
  if ((unsigned long )user->gt.version != (unsigned long )((void *)0)) {
    {
#line 750
    snprintf((char */* __restrict  */)buf___3, len, (char const   */* __restrict  */)"GNU Talk");
    }
  } else {
    {
#line 752
    snprintf((char */* __restrict  */)buf___3, len, (char const   */* __restrict  */)"BSD Talk");
    }
  }
#line 765
  return;
}
}
#line 773 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
static char name_buf[25]  ;
#line 773 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
static char stat_buf[25]  ;
#line 768 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
int show_user_list(void) 
{ 
  register int i ;
  register yuser *u ;
  int tmp___0 ;

  {
#line 775
  i = 0;
#line 777
  user_menu[i].item = (char *)"User List";
#line 778
  user_menu[i].func = (void (*)())((void *)0);
#line 779
  user_menu[i].key = (ychar )' ';
#line 780
  i ++;
#line 782
  user_menu[i].item = (char *)"Name            Winsize [My_Size] Software       ";
#line 783
  user_menu[i].func = (void (*)())((void *)0);
#line 784
  user_menu[i].key = (ychar )' ';
#line 785
  i ++;
#line 787
  user_menu[i].item = (char *)"";
#line 788
  user_menu[i].func = (void (*)())((void *)0);
#line 789
  user_menu[i].key = (ychar )' ';
#line 790
  i ++;
#line 792
  u = connect_list;
  {
#line 792
  while (1) {
    while_continue: /* CIL Label */ ;
#line 792
    if (u) {
#line 792
      if (! (i < 52)) {
#line 792
        goto while_break;
      }
    } else {
#line 792
      goto while_break;
    }
#line 793
    if ((unsigned long )u != (unsigned long )me) {
      {
#line 794
      stalkversion(u, stat_buf, sizeof(stat_buf));
#line 795
      pad_str(u->full_name, 15, name_buf);
#line 796
      pad_str(stat_buf, 15, stat_buf);
#line 798
      snprintf((char */* __restrict  */)(user_buf[i]), (size_t )80, (char const   */* __restrict  */)"%s %3.3dx%3.3d [%3.3dx%3.3d] %s",
               name_buf, (int )u->remote.cols, (int )u->remote.rows, (int )u->remote.my_cols,
               (int )u->remote.my_rows, stat_buf);
#line 803
      user_menu[i].item = user_buf[i];
#line 804
      user_menu[i].func = (void (*)())((void *)0);
#line 805
      user_menu[i].key = (ychar )' ';
#line 806
      i ++;
      }
    }
#line 792
    u = u->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 808
  u = wait_list;
  {
#line 808
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 808
    if (u) {
#line 808
      if (! (i < 52)) {
#line 808
        goto while_break___0;
      }
    } else {
#line 808
      goto while_break___0;
    }
    {
#line 809
    pad_str(u->full_name, 15, name_buf);
#line 810
    pad_str((char *)"<unconnected>", 15, stat_buf);
#line 812
    snprintf((char */* __restrict  */)(user_buf[i]), (size_t )80, (char const   */* __restrict  */)"%s                   %s",
             name_buf, stat_buf);
#line 817
    user_menu[i].item = user_buf[i];
#line 818
    user_menu[i].func = (void (*)())((void *)0);
#line 819
    user_menu[i].key = (ychar )' ';
#line 820
    i ++;
#line 808
    u = u->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 823
  tmp___0 = show_menu(user_menu, i);
  }
#line 823
  return (tmp___0);
}
}
#line 826 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
int show_error_menu(char *str1 , char *str2 ) 
{ 
  register int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 832
  i = 0;
  {
#line 832
  while (1) {
    while_continue: /* CIL Label */ ;
#line 832
    if (! ((int )error_menu[i].key != 0)) {
#line 832
      goto while_break;
    }
#line 833
    if ((unsigned long )error_menu[i].item == (unsigned long )((void *)0)) {
      {
#line 834
      strncpy((char */* __restrict  */)(err_str[got_error]), (char const   */* __restrict  */)str1,
              (size_t )132);
#line 835
      err_str[got_error][131] = (char )'\000';
#line 836
      tmp___0 = i;
#line 836
      i ++;
#line 836
      tmp___1 = got_error;
#line 836
      got_error ++;
#line 836
      error_menu[tmp___0].item = err_str[tmp___1];
      }
#line 838
      if ((unsigned long )str2 != (unsigned long )((void *)0)) {
        {
#line 839
        strncpy((char */* __restrict  */)(err_str[got_error]), (char const   */* __restrict  */)str2,
                (size_t )132);
#line 840
        err_str[got_error][131] = (char )'\000';
#line 841
        tmp___2 = i;
#line 841
        i ++;
#line 841
        tmp___3 = got_error;
#line 841
        got_error ++;
#line 841
        error_menu[tmp___2].item = err_str[tmp___3];
        }
      }
      {
#line 843
      tmp___4 = show_menu(error_menu, i);
      }
#line 843
      return (tmp___4);
    }
#line 832
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 845
  return (0);
}
}
#line 852 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
int yes_no(char *prompt ) 
{ 
  int out ;
  int esc_pressed ;
  char *p ;

  {
  {
#line 856
  out = 0;
#line 857
  esc_pressed = 0;
#line 860
  p = str_copy(prompt);
  }
#line 862
  if (! ((long )def_flags & 16384L)) {
#line 863
    esc_pressed = 1;
  }
#line 865
  yes_no_menu[0].func = (void (*)())((void *)0);
#line 866
  yes_no_menu[0].key = (ychar )' ';
  {
#line 870
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 871
    yes_no_menu[0].item = p;
#line 872
    menu_ptr = yes_no_menu;
#line 873
    update_menu();
#line 874
    input_loop();
    }
#line 875
    if ((unsigned long )menu_ptr != (unsigned long )(yes_no_menu)) {
      {
#line 877
      kill_menu();
#line 878
      io_len = 0;
      }
    } else
#line 875
    if ((unsigned long )yes_no_menu[0].item != (unsigned long )p) {
      {
#line 877
      kill_menu();
#line 878
      io_len = 0;
      }
    }
    {
#line 880
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 880
      if (! esc_pressed) {
#line 880
        if (! (io_len > 0)) {
#line 880
          goto while_break___0;
        }
      } else {
#line 880
        goto while_break___0;
      }
#line 881
      if ((int )*io_ptr == 27) {
#line 882
        esc_pressed = 1;
      }
#line 880
      io_len --;
#line 880
      io_ptr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 883
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 883
      if (! (io_len > 0)) {
#line 883
        goto while_break___1;
      }
#line 884
      if ((int )*io_ptr == 89) {
#line 885
        out = 'y';
#line 886
        goto while_break___1;
      } else
#line 884
      if ((int )*io_ptr == 121) {
#line 884
        if (! ((long )def_flags & 256L)) {
#line 885
          out = 'y';
#line 886
          goto while_break___1;
        }
      }
#line 888
      if ((int )*io_ptr == 78) {
#line 889
        out = 'n';
#line 890
        goto while_break___1;
      } else
#line 888
      if ((int )*io_ptr == 110) {
#line 888
        if (! ((long )def_flags & 256L)) {
#line 889
          out = 'n';
#line 890
          goto while_break___1;
        } else {
#line 888
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 888
      if ((int )*io_ptr == 27) {
#line 889
        out = 'n';
#line 890
        goto while_break___1;
      }
#line 883
      io_len --;
#line 883
      io_ptr ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 870
    if (! (out == 0)) {
#line 870
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 895
  free_mem(p);
#line 896
  kill_menu();
#line 897
  io_len = 0;
  }
#line 898
  return (out);
}
}
#line 901 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/menu.c"
void update_user_menu(void) 
{ 


  {
#line 904
  if ((unsigned long )menu_ptr == (unsigned long )(user_menu)) {
    {
#line 905
    redraw_term(me, 0);
    }
#line 906
    if (user_menu[0].func) {
      {
#line 907
      show_user_menu(user_menu[0].item, user_menu[0].func, (int )user_menu[0].key - 32);
      }
    } else {
      {
#line 909
      show_user_list();
      }
    }
    {
#line 910
    update_menu();
    }
  }
#line 912
  return;
}
}
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 215 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 221
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                                                int __signo ) ;
#line 248
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigprocmask)(int __how ,
                                                                                  sigset_t const   * __restrict  __set ,
                                                                                  sigset_t * __restrict  __oset ) ;
#line 285 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/header.h"
int user_winch ;
#line 363
void remove_fd(int fd ) ;
#line 364
int full_read(int fd , char *buf___3 , size_t len ) ;
#line 370
void house_clean(void) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/fd.c"
static fd_set fdset  ;
#line 42 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/fd.c"
static fd_set fdtmp  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/fd.c"
static fd_set sel  ;
#line 44 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/fd.c"
static int high_fd  =    0;
#line 45 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/fd.c"
int input_flag  =    0;
#line 46 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/fd.c"
int user_winch  =    0;
#line 51 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/fd.c"
static struct fd_func tag[256]  ;
#line 56 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/fd.c"
void init_fd(void) 
{ 
  int __d0 ;
  int __d1 ;

  {
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fdset.__fds_bits[0]): "memory");
#line 59
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 60
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/fd.c"
void add_fd(int fd , void (*user_func)() ) 
{ 


  {
#line 71
  if (fd < 0) {
    {
#line 72
    show_error("add_fd: descriptor out of range");
    }
#line 73
    return;
  } else
#line 71
  if (fd >= 256) {
    {
#line 72
    show_error("add_fd: descriptor out of range");
    }
#line 73
    return;
  }
#line 75
  fdset.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
#line 76
  tag[fd].func = user_func;
#line 77
  if (fd >= high_fd) {
#line 78
    high_fd = fd + 1;
  }
#line 79
  return;
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/fd.c"
void remove_fd(int fd ) 
{ 


  {
#line 88
  if (fd < 0) {
    {
#line 89
    show_error("remove_fd: descriptor out of range");
    }
#line 90
    return;
  } else
#line 88
  if (fd >= 256) {
    {
#line 89
    show_error("remove_fd: descriptor out of range");
    }
#line 90
    return;
  }
#line 92
  fdset.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << fd % (8 * (int )sizeof(__fd_mask )));
#line 93
  fdtmp.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << fd % (8 * (int )sizeof(__fd_mask )));
#line 94
  sel.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << fd % (8 * (int )sizeof(__fd_mask )));
#line 95
  return;
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/fd.c"
int full_read(int fd , char *buf___3 , size_t len ) 
{ 
  register int rc ;
  ssize_t tmp___0 ;

  {
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 108
    if (! (len > 0UL)) {
#line 108
      goto while_break;
    }
    {
#line 109
    tmp___0 = read(fd, (void *)buf___3, len);
#line 109
    rc = (int )tmp___0;
    }
#line 109
    if (rc <= 0) {
#line 110
      return (-1);
    }
#line 111
    buf___3 += rc;
#line 112
    len -= (size_t )rc;
  }
  while_break: /* CIL Label */ ;
  }
#line 114
  return (0);
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/fd.c"
static ylong lastping  ;
#line 119 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/fd.c"
static ylong curtime  ;
#line 121 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/fd.c"
void main_loop(void) 
{ 
  register int fd ;
  register int rc ;
  struct timeval tv ;
  sigset_t mask ;
  sigset_t old_mask ;
  time_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  time_t tmp___3 ;
  time_t tmp___4 ;

  {
  {
#line 141
  sigemptyset(& mask);
#line 142
  sigaddset(& mask, 28);
#line 150
  signal(17, (void (*)(int  ))1);
#line 164
  house_clean();
#line 165
  tmp___0 = time((time_t *)((void *)0));
#line 165
  lastping = (ylong )tmp___0;
#line 165
  curtime = lastping;
  }
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    if ((unsigned long )connect_list == (unsigned long )((void *)0)) {
#line 169
      if ((unsigned long )wait_list == (unsigned long )((void *)0)) {
#line 169
        if ((unsigned long )menu_ptr == (unsigned long )((void *)0)) {
#line 169
          if (running_process == 0) {
            {
#line 173
            bail(0);
            }
          }
        }
      }
    }
#line 177
    sel = fdset;
#line 178
    if (curtime > lastping + 16U) {
#line 179
      tv.tv_sec = (__time_t )0;
    } else {
#line 181
      tv.tv_sec = (__time_t )((lastping + 16U) - curtime);
    }
    {
#line 182
    tv.tv_usec = (__suseconds_t )0;
#line 183
    rc = select(high_fd, (fd_set */* __restrict  */)(& sel), (fd_set */* __restrict  */)0,
                (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& tv));
    }
#line 183
    if (rc < 0) {
      {
#line 184
      tmp___1 = __errno_location();
      }
#line 184
      if (*tmp___1 != 4) {
        {
#line 185
        show_error("main_loop: select failed");
        }
      }
    }
    {
#line 191
    sigprocmask(0, (sigset_t const   */* __restrict  */)(& mask), (sigset_t */* __restrict  */)(& old_mask));
    }
#line 203
    if (rc > 0) {
#line 204
      fd = 0;
      {
#line 204
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 204
        if (! (fd < high_fd)) {
#line 204
          goto while_break___0;
        }
#line 205
        if ((sel.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
          {
#line 206
          tmp___2 = __errno_location();
#line 206
          *tmp___2 = 0;
#line 207
          (*(tag[fd].func))(fd);
#line 208
          rc --;
          }
#line 208
          if (rc <= 0) {
#line 209
            goto while_break___0;
          }
        }
#line 204
        fd ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 213
    tmp___3 = time((time_t *)((void *)0));
#line 213
    curtime = (ylong )tmp___3;
    }
#line 214
    if (curtime - lastping >= 16U) {
      {
#line 215
      house_clean();
#line 216
      tmp___4 = time((time_t *)((void *)0));
#line 216
      lastping = (ylong )tmp___4;
      }
    }
    {
#line 222
    sigprocmask(2, (sigset_t const   */* __restrict  */)(& old_mask), (sigset_t */* __restrict  */)((void *)0));
    }
#line 232
    if (user_winch) {
      {
#line 238
      user_winch = 0;
#line 239
      update_user_menu();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 255 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/fd.c"
static int left_loop  ;
#line 250 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/fd.c"
void input_loop(void) 
{ 
  register int fd ;
  register int rc ;
  struct timeval tv ;
  int *tmp___0 ;
  int *tmp___1 ;
  time_t tmp___2 ;
  time_t tmp___3 ;

  {
#line 257
  left_loop = 0;
#line 258
  fdtmp = fdset;
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
#line 259
    if (! (io_len <= 0)) {
#line 259
      goto while_break;
    }
#line 262
    sel = fdtmp;
#line 263
    if (curtime > lastping + 16U) {
#line 264
      tv.tv_sec = (__time_t )0;
    } else {
#line 266
      tv.tv_sec = (__time_t )((lastping + 16U) - curtime);
    }
    {
#line 267
    tv.tv_usec = (__suseconds_t )0;
#line 268
    rc = select(high_fd, (fd_set */* __restrict  */)(& sel), (fd_set */* __restrict  */)0,
                (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& tv));
    }
#line 268
    if (rc < 0) {
      {
#line 269
      tmp___0 = __errno_location();
      }
#line 269
      if (*tmp___0 != 4) {
        {
#line 270
        show_error("input_loop: select failed");
        }
      }
    }
#line 274
    if (rc > 0) {
#line 275
      fd = 0;
      {
#line 275
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 275
        if (! (fd < high_fd)) {
#line 275
          goto while_break___0;
        }
#line 276
        if ((sel.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
          {
#line 287
          tmp___1 = __errno_location();
#line 287
          *tmp___1 = 0;
#line 288
          input_flag = 1;
#line 289
          (*(tag[fd].func))(fd);
          }
#line 290
          if (left_loop) {
#line 292
            return;
          }
#line 294
          if (input_flag == 0) {
#line 299
            fdtmp.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << fd % (8 * (int )sizeof(__fd_mask )));
          }
#line 301
          rc --;
#line 301
          if (rc <= 0) {
#line 302
            goto while_break___0;
          }
        }
#line 275
        fd ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 306
    tmp___2 = time((time_t *)((void *)0));
#line 306
    curtime = (ylong )tmp___2;
    }
#line 307
    if (curtime - lastping >= 16U) {
      {
#line 308
      input_flag = 1;
#line 309
      house_clean();
#line 310
      tmp___3 = time((time_t *)((void *)0));
#line 310
      lastping = (ylong )tmp___3;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 313
  input_flag = 0;
#line 314
  left_loop = 1;
#line 315
  return;
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/fd.c"
void bail_loop(void) 
{ 
  char keypress ;

  {
  {
#line 325
  full_read(0, & keypress, sizeof(char ));
  }
#line 326
  return;
}
}
#line 28 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/gtalk.h"
void gtalk_process(yuser *user , ychar data ) ;
#line 30
char *gtalk_parse_version(char *str , ychar ukill ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/gtalk.c"
void gtalk_process(yuser *user , ychar data ) 
{ 
  yaddr tmp___0 ;
  int tmp___1 ;

  {
#line 32
  if (user->gt.len >= 4095) {
#line 36
    user->gt.got_gt = (char)0;
#line 37
    return;
  }
#line 40
  if ((int )user->gt.type == 0) {
#line 41
    user->gt.type = (char )data;
#line 42
    return;
  }
#line 45
  if ((unsigned long )user->gt.buf == (unsigned long )((void *)0)) {
    {
#line 46
    tmp___0 = get_mem(4096);
#line 46
    user->gt.buf = (char *)tmp___0;
    }
  }
#line 48
  if ((int )data == (int )user->edit[1]) {
#line 48
    goto _L;
  } else
#line 48
  if ((int )data == 10) {
    _L: /* CIL Label */ 
#line 49
    user->gt.got_gt = (char)0;
#line 50
    *(user->gt.buf + user->gt.len) = (char)0;
    {
#line 52
    if ((int )user->gt.type == 8) {
#line 52
      goto case_8;
    }
#line 51
    goto switch_break;
    case_8: /* CIL Label */ 
#line 53
    if ((unsigned long )user->gt.version != (unsigned long )((void *)0)) {
      {
#line 54
      free_mem(user->gt.version);
      }
    }
    {
#line 55
    user->gt.version = gtalk_parse_version(user->gt.buf, (int )user->edit[1]);
#line 57
    user_winch = 1;
    }
#line 58
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 60
    return;
  }
#line 63
  tmp___1 = user->gt.len;
#line 63
  (user->gt.len) ++;
#line 63
  *(user->gt.buf + tmp___1) = (char )data;
#line 64
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/gtalk.c"
char *gtalk_parse_version(char *str , ychar ukill ) 
{ 
  char *p ;
  char *e ;
  char *tmp___0 ;

  {
  {
#line 72
  p = strchr((char const   *)str, ' ');
  }
#line 73
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 74
    p = strchr((char const   *)(p + 1), ' ');
    }
  }
#line 75
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 76
    p ++;
#line 77
    e = p;
    {
#line 77
    while (1) {
      while_continue: /* CIL Label */ ;
#line 77
      if (! *e) {
#line 77
        goto while_break;
      }
#line 78
      if ((int )*e == (int )ukill) {
#line 79
        *e = (char)0;
#line 80
        goto while_break;
      } else
#line 78
      if ((int )*e == 10) {
#line 79
        *e = (char)0;
#line 80
        goto while_break;
      }
#line 77
      e ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 82
    tmp___0 = str_copy(p);
    }
#line 82
    return (tmp___0);
  }
#line 84
  return ((char *)((void *)0));
}
}
#line 50 "/usr/include/x86_64-linux-gnu/sys/uio.h"
extern ssize_t writev(int __fd , struct iovec  const  *__iovec , int __count ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockname)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 141
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getpeername)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 375
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 377
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 281 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/header.h"
yuser *fd_to_user[256] ;
#line 287 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/header.h"
ychar *io_ptr  ;
#line 355
yuser *new_user(char *name , char *hostname , char *tty ) ;
#line 357
yuser *find_user(char *name , ylong host_addr , ylong pid___0 ) ;
#line 358
void generate_full_name(yuser *user ) ;
#line 374
void send_users(yuser *user , ychar *buf___3 , int len , ychar *cbuf , int clen ) ;
#line 375
void show_input(yuser *user , ychar *buf___3 , int len ) ;
#line 377
void lock_flags(ylong flags ) ;
#line 378
void unlock_flags(void) ;
#line 383
int send_dgram(yuser *user , u_char type ) ;
#line 384
int send_auto(u_char type ) ;
#line 386
int newsock(yuser *user ) ;
#line 387
int connect_to(yuser *user ) ;
#line 388
ylong get_host_addr(char *hostname ) ;
#line 389
char *host_name(ylong addr ) ;
#line 396
void update_exec(void) ;
#line 398
void winch_exec(void) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/comm.c"
int io_len  =    0;
#line 49 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/comm.c"
int dont_change_my_addr  =    0;
#line 57 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/comm.c"
static y_parm parm  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/comm.c"
static v2_pack v2p  ;
#line 59 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/comm.c"
static v3_pack v3p  ;
#line 60 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/comm.c"
static v3_flags v3f  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/comm.c"
static v3_winch v3w  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/comm.c"
static void drain_user(yuser *user , int len , void (*func)() ) 
{ 
  yaddr tmp___0 ;

  {
#line 72
  if (len > user->dbuf_size) {
    {
#line 73
    user->dbuf_size = len + 64;
#line 74
    tmp___0 = realloc_mem(user->dbuf, user->dbuf_size);
#line 74
    user->dbuf = (ychar *)tmp___0;
    }
  }
#line 76
  user->drain = len;
#line 77
  user->dptr = user->dbuf;
#line 78
  user->dfunc = func;
#line 79
  return;
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/comm.c"
static struct iovec iov[3]  ;
#line 84 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/comm.c"
static void send_oob(int fd , yaddr ptr , ychar len ) 
{ 
  ychar oob ;
  ychar size ;
  int r ;
  int *tmp___0 ;
  int *tmp___1 ;
  ssize_t tmp___2 ;

  {
  {
#line 94
  oob = (ychar )253;
#line 95
  iov[0].iov_base = (yaddr )(& oob);
#line 96
  iov[0].iov_len = (size_t )1;
#line 98
  size = len;
#line 99
  iov[1].iov_base = (yaddr )(& size);
#line 100
  iov[1].iov_len = (size_t )1;
#line 102
  iov[2].iov_base = ptr;
#line 103
  iov[2].iov_len = (size_t )len;
#line 105
  tmp___2 = writev(fd, (struct iovec  const  *)(iov), 3);
#line 105
  r = (int )tmp___2;
  }
#line 105
  if (r != (int )len + 2) {
#line 106
    if (r >= 0) {
      {
#line 107
      show_error("send_oob: write failed");
      }
    } else {
      {
#line 106
      tmp___0 = __errno_location();
      }
#line 106
      if (*tmp___0 != 32) {
        {
#line 106
        tmp___1 = __errno_location();
        }
#line 106
        if (*tmp___1 != 104) {
          {
#line 107
          show_error("send_oob: write failed");
          }
        }
      }
    }
  }
#line 109
  return;
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/comm.c"
static void send_import(yuser *to , yuser *from ) 
{ 


  {
#line 119
  if ((int )to->remote.vmajor > 2) {
    {
#line 120
    v3p.code = (ychar )102;
#line 121
    v3p.host_addr = htonl(from->host_addr);
#line 122
    v3p.pid = htonl(from->remote.pid);
#line 123
    strncpy((char */* __restrict  */)(v3p.name), (char const   */* __restrict  */)from->user_name,
            (size_t )16);
#line 124
    strncpy((char */* __restrict  */)(v3p.host), (char const   */* __restrict  */)from->host_fqdn,
            (size_t )64);
#line 125
    send_oob(to->fd, (yaddr )(& v3p), (ychar )sizeof(v3_pack ));
    }
  } else
#line 126
  if ((int )to->remote.vmajor == 2) {
    {
#line 127
    v2p.code = (ychar )131;
#line 128
    strncpy((char */* __restrict  */)(v2p.name), (char const   */* __restrict  */)from->user_name,
            (size_t )12);
#line 129
    strncpy((char */* __restrict  */)(v2p.host), (char const   */* __restrict  */)from->host_fqdn,
            (size_t )64);
#line 130
    write(to->fd, (void const   *)((yaddr )(& v2p)), sizeof(v2_pack ));
    }
  }
#line 132
  return;
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/comm.c"
static void send_accept(yuser *to , yuser *from ) 
{ 


  {
#line 141
  if ((int )to->remote.vmajor > 2) {
    {
#line 142
    v3p.code = (ychar )103;
#line 143
    v3p.host_addr = htonl(from->host_addr);
#line 144
    v3p.pid = htonl(from->remote.pid);
#line 145
    strncpy((char */* __restrict  */)(v3p.name), (char const   */* __restrict  */)from->user_name,
            (size_t )16);
#line 146
    strncpy((char */* __restrict  */)(v3p.host), (char const   */* __restrict  */)from->host_fqdn,
            (size_t )64);
#line 147
    send_oob(to->fd, (yaddr )(& v3p), (ychar )sizeof(v3_pack ));
    }
  } else
#line 148
  if ((int )to->remote.vmajor == 2) {
    {
#line 149
    v2p.code = (ychar )132;
#line 150
    strncpy((char */* __restrict  */)(v2p.name), (char const   */* __restrict  */)from->user_name,
            (size_t )12);
#line 151
    strncpy((char */* __restrict  */)(v2p.host), (char const   */* __restrict  */)from->host_fqdn,
            (size_t )64);
#line 152
    write(to->fd, (void const   *)((yaddr )(& v2p)), sizeof(v2_pack ));
    }
  }
#line 154
  return;
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/comm.c"
static void v2_process(yuser *user , v2_pack *pack ) 
{ 
  register yuser *u ;
  ylong host_addr ;
  char *estr___0 ;
  char *name ;
  char *host ;
  yaddr tmp___0 ;
  yaddr tmp___1 ;
  int *tmp___2 ;
  yaddr tmp___3 ;
  yuser *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 168
  tmp___0 = get_mem(13);
#line 168
  name = (char *)tmp___0;
#line 169
  tmp___1 = get_mem(65);
#line 169
  host = (char *)tmp___1;
#line 175
  strncpy((char */* __restrict  */)name, (char const   */* __restrict  */)(pack->name),
          (size_t )12);
#line 176
  strncpy((char */* __restrict  */)host, (char const   */* __restrict  */)(pack->host),
          (size_t )64);
#line 177
  *(name + 12) = (char )'\000';
#line 178
  *(host + 64) = (char )'\000';
#line 179
  host_addr = get_host_addr(host);
  }
#line 179
  if (host_addr == 4294967295U) {
    {
#line 180
    tmp___2 = __errno_location();
#line 180
    *tmp___2 = 0;
#line 182
    snprintf((char */* __restrict  */)(errstr), (size_t )132, (char const   */* __restrict  */)"unknown host: \'%s\'",
             host);
#line 186
    show_error(errstr);
#line 187
    show_error("port from ytalk V2.? failed");
#line 188
    free_mem(host);
#line 189
    free_mem(name);
    }
#line 190
    return;
  }
  {
#line 192
  tmp___3 = get_mem(96);
#line 192
  estr___0 = (char *)tmp___3;
  }
  {
#line 194
  if ((int )pack->code == 131) {
#line 194
    goto case_131;
  }
#line 225
  if ((int )pack->code == 130) {
#line 225
    goto case_130;
  }
#line 235
  if ((int )pack->code == 132) {
#line 235
    goto case_132;
  }
#line 193
  goto switch_break;
  case_131: /* CIL Label */ 
  {
#line 199
  tmp___4 = find_user(name, host_addr, (ylong )-1);
  }
#line 199
  if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
#line 200
    goto switch_break;
  }
#line 201
  if (! ((long )def_flags & 8L)) {
    {
#line 203
    snprintf((char */* __restrict  */)estr___0, (size_t )96, (char const   */* __restrict  */)"Import %s@%s?",
             name, host);
#line 207
    tmp___5 = yes_no(estr___0);
    }
#line 207
    if (tmp___5 == 110) {
#line 208
      goto switch_break;
    }
  }
  {
#line 213
  snprintf((char */* __restrict  */)estr___0, (size_t )96, (char const   */* __restrict  */)"%s@%s",
           name, host);
#line 217
  invite(estr___0, 0);
#line 221
  pack->code = (ychar )130;
#line 222
  write(user->fd, (void const   *)pack, sizeof(v2_pack ));
  }
#line 224
  goto switch_break;
  case_130: /* CIL Label */ 
  {
#line 231
  u = find_user(name, host_addr, (ylong )-1);
  }
#line 231
  if ((unsigned long )u == (unsigned long )((void *)0)) {
#line 232
    goto switch_break;
  }
  {
#line 233
  send_accept(u, user);
  }
#line 234
  goto switch_break;
  case_132: /* CIL Label */ 
  {
#line 237
  snprintf((char */* __restrict  */)estr___0, (size_t )96, (char const   */* __restrict  */)"%s@%s",
           name, host);
#line 241
  invite(estr___0, 1);
  }
#line 242
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 244
  free_mem(host);
#line 245
  free_mem(name);
#line 246
  free_mem(estr___0);
  }
#line 247
  return;
}
}
#line 252 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/comm.c"
static void v3_process_pack(yuser *user , v3_pack *pack ) 
{ 
  register yuser *u ;
  register yuser *u2 ;
  ylong host_addr ;
  ylong pid___0 ;
  char *estr___0 ;
  char *name ;
  char *host ;
  yaddr tmp___0 ;
  yaddr tmp___1 ;
  yaddr tmp___2 ;
  yuser *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 261
  tmp___0 = get_mem(100);
#line 261
  estr___0 = (char *)tmp___0;
#line 262
  tmp___1 = get_mem(17);
#line 262
  name = (char *)tmp___1;
#line 263
  tmp___2 = get_mem(65);
#line 263
  host = (char *)tmp___2;
#line 265
  strncpy((char */* __restrict  */)name, (char const   */* __restrict  */)(pack->name),
          (size_t )16);
#line 266
  strncpy((char */* __restrict  */)host, (char const   */* __restrict  */)(pack->host),
          (size_t )64);
#line 267
  *(name + 16) = (char )'\000';
#line 268
  *(host + 64) = (char )'\000';
#line 269
  host_addr = get_host_addr(host);
  }
#line 269
  if (host_addr == 4294967295U) {
    {
#line 270
    host_addr = ntohl(pack->host_addr);
    }
  }
  {
#line 271
  pid___0 = ntohl(pack->pid);
  }
  {
#line 274
  if ((int )pack->code == 102) {
#line 274
    goto case_102;
  }
#line 314
  if ((int )pack->code == 101) {
#line 314
    goto case_101;
  }
#line 324
  if ((int )pack->code == 103) {
#line 324
    goto case_103;
  }
#line 273
  goto switch_break;
  case_102: /* CIL Label */ 
  {
#line 280
  tmp___3 = find_user(name, host_addr, pid___0);
  }
#line 280
  if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 281
    goto switch_break;
  }
#line 282
  if (! ((long )def_flags & 8L)) {
    {
#line 284
    snprintf((char */* __restrict  */)estr___0, (size_t )100, (char const   */* __restrict  */)"Import %s@%s?",
             name, host);
#line 288
    tmp___4 = yes_no(estr___0);
    }
#line 288
    if (tmp___4 == 110) {
#line 289
      goto switch_break;
    }
  }
  {
#line 294
  snprintf((char */* __restrict  */)estr___0, (size_t )100, (char const   */* __restrict  */)"%s@%s",
           name, host);
#line 298
  u2 = invite(estr___0, 0);
  }
#line 304
  if ((unsigned long )u2 != (unsigned long )((void *)0)) {
    {
#line 304
    tmp___5 = strcmp((char const   *)u2->user_name, (char const   *)name);
    }
#line 304
    if (tmp___5 == 0) {
#line 304
      if (host_addr == u2->host_addr) {
#line 306
        u2->remote.pid = pid___0;
      }
    }
  }
  {
#line 310
  pack->code = (ychar )101;
#line 311
  send_oob(user->fd, (yaddr )pack, (ychar )sizeof(v3_pack ));
  }
#line 313
  goto switch_break;
  case_101: /* CIL Label */ 
  {
#line 320
  u = find_user(name, host_addr, pid___0);
  }
#line 320
  if ((unsigned long )u == (unsigned long )((void *)0)) {
#line 321
    goto switch_break;
  }
  {
#line 322
  send_accept(u, user);
  }
#line 323
  goto switch_break;
  case_103: /* CIL Label */ 
  {
#line 326
  snprintf((char */* __restrict  */)estr___0, (size_t )100, (char const   */* __restrict  */)"%s@%s",
           name, host);
#line 330
  invite(estr___0, 1);
  }
#line 331
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 333
  free_mem(host);
#line 334
  free_mem(name);
#line 335
  free_mem(estr___0);
  }
#line 336
  return;
}
}
#line 342 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/comm.c"
static void v3_process_flags(yuser *user , v3_flags *pack ) 
{ 
  uint32_t tmp___0 ;

  {
  {
#line 348
  if ((int )pack->code == 111) {
#line 348
    goto case_111;
  }
#line 351
  if ((int )pack->code == 112) {
#line 351
    goto case_112;
  }
#line 347
  goto switch_break;
  case_111: /* CIL Label */ 
  {
#line 349
  tmp___0 = ntohl(pack->flags);
#line 349
  user->flags = (ylong )((long )tmp___0 | 1073741824L);
  }
#line 350
  goto switch_break;
  case_112: /* CIL Label */ 
#line 352
  user->flags = def_flags;
#line 353
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 355
  return;
}
}
#line 360 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/comm.c"
static void v3_process_winch(yuser *user , v3_winch *pack ) 
{ 


  {
  {
#line 366
  if ((int )pack->code == 121) {
#line 366
    goto case_121;
  }
#line 371
  if ((int )pack->code == 122) {
#line 371
    goto case_122;
  }
#line 375
  if ((int )pack->code == 123) {
#line 375
    goto case_123;
  }
#line 365
  goto switch_break;
  case_121: /* CIL Label */ 
  {
#line 367
  user->remote.my_rows = ntohs(pack->rows);
#line 368
  user->remote.my_cols = ntohs(pack->cols);
#line 369
  winch_exec();
  }
#line 370
  goto switch_break;
  case_122: /* CIL Label */ 
  {
#line 372
  user->remote.rows = ntohs(pack->rows);
#line 373
  user->remote.cols = ntohs(pack->cols);
  }
#line 374
  goto switch_break;
  case_123: /* CIL Label */ 
  {
#line 376
  pack->rows = ntohs(pack->rows);
#line 377
  pack->cols = ntohs(pack->cols);
  }
#line 378
  if ((int )pack->rows > 0) {
    {
#line 379
    set_win_region(user, (int )pack->rows, (int )pack->cols);
    }
  } else {
    {
#line 381
    end_win_region(user);
    }
  }
#line 382
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 384
  user_winch = 1;
#line 385
  return;
}
}
#line 391 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/comm.c"
static void v3_process(yuser *user , yaddr ptr ) 
{ 
  ychar *str ;

  {
#line 400
  str = (ychar *)ptr;
  {
#line 404
  if ((int )*str == 103) {
#line 404
    goto case_103;
  }
#line 404
  if ((int )*str == 101) {
#line 404
    goto case_103;
  }
#line 404
  if ((int )*str == 102) {
#line 404
    goto case_103;
  }
#line 408
  if ((int )*str == 112) {
#line 408
    goto case_112;
  }
#line 408
  if ((int )*str == 111) {
#line 408
    goto case_112;
  }
#line 413
  if ((int )*str == 123) {
#line 413
    goto case_123;
  }
#line 413
  if ((int )*str == 122) {
#line 413
    goto case_123;
  }
#line 413
  if ((int )*str == 121) {
#line 413
    goto case_123;
  }
#line 401
  goto switch_break;
  case_103: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_102: /* CIL Label */ 
  {
#line 405
  v3_process_pack(user, (v3_pack *)ptr);
  }
#line 406
  goto switch_break;
  case_112: /* CIL Label */ 
  case_111: /* CIL Label */ 
  {
#line 409
  v3_process_flags(user, (v3_flags *)ptr);
  }
#line 410
  goto switch_break;
  case_123: /* CIL Label */ 
  case_122: /* CIL Label */ 
  case_121: /* CIL Label */ 
  {
#line 414
  v3_process_winch(user, (v3_winch *)ptr);
  }
#line 415
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 417
  return;
}
}
#line 430 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/comm.c"
static ychar buf___1[512]  ;
#line 423 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/comm.c"
static void read_user(int fd ) 
{ 
  register ychar *c ;
  register ychar *p ;
  register ssize_t rc ;
  register yuser *user ;
  int *tmp___0 ;
  int *tmp___1 ;
  ychar *tmp___2 ;
  ychar *tmp___3 ;
  ssize_t tmp___4 ;

  {
#line 432
  if (input_flag) {
#line 434
    input_flag = 0;
#line 435
    return;
  }
#line 437
  user = fd_to_user[fd];
#line 437
  if ((unsigned long )user == (unsigned long )((void *)0)) {
    {
#line 438
    remove_fd(fd);
#line 439
    show_error("read_user: unknown contact");
    }
#line 440
    return;
  }
  {
#line 442
  rc = read(fd, (void *)(buf___1), sizeof(buf___1));
  }
#line 442
  if (rc <= 0L) {
#line 443
    if (rc < 0L) {
      {
#line 443
      tmp___0 = __errno_location();
      }
#line 443
      if (*tmp___0 != 104) {
        {
#line 443
        tmp___1 = __errno_location();
        }
#line 443
        if (*tmp___1 != 32) {
          {
#line 444
          show_error("read_user: read() failed");
          }
        }
      }
    }
    {
#line 445
    free_user(user);
    }
#line 446
    return;
  }
#line 448
  c = buf___1;
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
#line 449
    if (! (rc > 0L)) {
#line 449
      goto while_break;
    }
#line 450
    if (user->drain > 0) {
#line 452
      if (rc < (ssize_t )user->drain) {
        {
#line 453
        memcpy((void */* __restrict  */)user->dptr, (void const   */* __restrict  */)c,
               (size_t )rc);
#line 454
        user->dptr += rc;
#line 455
        user->drain = (int )((ssize_t )user->drain - rc);
#line 456
        rc = (ssize_t )0;
        }
      } else {
        {
#line 458
        memcpy((void */* __restrict  */)user->dptr, (void const   */* __restrict  */)c,
               (size_t )user->drain);
#line 459
        rc -= (ssize_t )user->drain;
#line 460
        c += user->drain;
#line 461
        user->drain = 0;
#line 462
        (*(user->dfunc))(user, user->dbuf);
        }
      }
    } else {
#line 478
      p = buf___1;
#line 479
      if (user->got_oob) {
#line 480
        user->got_oob = 0;
#line 481
        if ((int )*c <= 252) {
          {
#line 482
          drain_user(user, (int )*c, (void (*)())(& v3_process));
#line 483
          c ++;
#line 483
          rc --;
          }
#line 484
          goto while_continue;
        }
#line 486
        tmp___2 = p;
#line 486
        p ++;
#line 486
        *tmp___2 = *c;
#line 487
        c ++;
#line 487
        rc --;
      }
      {
#line 489
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 489
        if (! (rc > 0L)) {
#line 489
          goto while_break___0;
        }
#line 490
        if ((int )*c > 127) {
#line 491
          if ((int )user->remote.vmajor > 2) {
#line 492
            if ((int )*c == 253) {
#line 493
              c ++;
#line 493
              rc --;
#line 494
              if (rc > 0L) {
#line 495
                if ((int )*c <= 252) {
                  {
#line 496
                  drain_user(user, (int )*c, (void (*)())(& v3_process));
#line 497
                  c ++;
#line 497
                  rc --;
                  }
#line 498
                  goto while_break___0;
                }
              } else {
#line 501
                user->got_oob = 1;
#line 502
                goto while_break___0;
              }
            }
          } else
#line 505
          if ((int )user->remote.vmajor == 2) {
#line 511
            if ((int )*c == 131) {
              {
#line 513
              drain_user(user, (int )sizeof(v2_pack ), (void (*)())(& v2_process));
              }
#line 520
              goto while_break___0;
            } else
#line 511
            if ((int )*c == 130) {
              {
#line 513
              drain_user(user, (int )sizeof(v2_pack ), (void (*)())(& v2_process));
              }
#line 520
              goto while_break___0;
            } else
#line 511
            if ((int )*c == 132) {
              {
#line 513
              drain_user(user, (int )sizeof(v2_pack ), (void (*)())(& v2_process));
              }
#line 520
              goto while_break___0;
            } else
#line 511
            if ((int )*c == 133) {
              {
#line 513
              drain_user(user, (int )sizeof(v2_pack ), (void (*)())(& v2_process));
              }
#line 520
              goto while_break___0;
            }
          }
        }
#line 524
        tmp___3 = p;
#line 524
        p ++;
#line 524
        *tmp___3 = *c;
#line 489
        c ++;
#line 489
        rc --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 526
      if ((unsigned long )p > (unsigned long )(buf___1)) {
#line 527
        if (user->output_fd > 0) {
          {
#line 528
          tmp___4 = write(user->output_fd, (void const   *)(buf___1), (size_t )(p - buf___1));
          }
#line 528
          if (tmp___4 <= 0L) {
            {
#line 529
            show_error("write to user output file failed");
#line 530
            close(user->output_fd);
#line 531
            user->output_fd = 0;
            }
          }
        }
        {
#line 533
        show_input(user, buf___1, p - buf___1);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 537
  return;
}
}
#line 542 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/comm.c"
static void ytalk_user(int fd ) 
{ 
  register yuser *user ;
  register yuser *u ;
  u_short cols ;
  int tmp___0 ;
  uint16_t tmp___1 ;
  uint16_t tmp___2 ;

  {
#line 549
  user = fd_to_user[fd];
#line 549
  if ((unsigned long )user == (unsigned long )((void *)0)) {
    {
#line 550
    remove_fd(fd);
#line 551
    show_error("ytalk_user: unknown contact");
    }
#line 552
    return;
  }
  {
#line 554
  tmp___0 = full_read(user->fd, (char *)(& parm), sizeof(y_parm ));
  }
#line 554
  if (tmp___0 < 0) {
    {
#line 555
    free_user(user);
#line 556
    show_error("ytalk_user: bad ytalk contact");
    }
#line 557
    return;
  }
  {
#line 560
  if ((int )parm.protocol == 20) {
#line 560
    goto case_20;
  }
#line 568
  if ((int )parm.protocol == 27) {
#line 568
    goto case_27;
  }
#line 578
  goto switch_default;
  case_20: /* CIL Label */ 
  {
#line 561
  cols = (u_short )parm.w_cols;
#line 562
  memset((void *)(& parm), 0, sizeof(y_parm ));
#line 563
  parm.vmajor = (short)2;
#line 564
  parm.cols = cols;
#line 565
  parm.my_cols = cols;
#line 566
  spew_term(me, fd, (int )me->t_rows, (int )parm.cols);
  }
#line 567
  goto switch_break;
  case_27: /* CIL Label */ 
  {
#line 569
  tmp___1 = ntohs((uint16_t )parm.vmajor);
#line 569
  parm.vmajor = (short )tmp___1;
#line 570
  tmp___2 = ntohs((uint16_t )parm.vminor);
#line 570
  parm.vminor = (short )tmp___2;
#line 571
  parm.rows = ntohs(parm.rows);
#line 572
  parm.cols = ntohs(parm.cols);
#line 573
  parm.my_rows = ntohs(parm.my_rows);
#line 574
  parm.my_cols = ntohs(parm.my_cols);
#line 575
  parm.pid = ntohl(parm.pid);
  }
#line 577
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 579
  free_user(user);
#line 580
  show_error("ytalk_user: unsupported ytalk protocol");
  }
#line 581
  return;
  switch_break: /* CIL Label */ ;
  }
#line 583
  user->remote = parm;
#line 586
  if ((int )user->remote.vmajor < 3) {
#line 588
    user->crlf = (char)0;
  } else
#line 586
  if ((int )user->remote.vmajor == 3) {
#line 586
    if ((int )user->remote.vminor < 2) {
#line 588
      user->crlf = (char)0;
    } else {
#line 590
      user->crlf = (char)1;
    }
  } else {
#line 590
    user->crlf = (char)1;
  }
  {
#line 592
  user_winch = 1;
#line 593
  add_fd(fd, & read_user);
  }
#line 597
  if ((unsigned long )user == (unsigned long )wait_list) {
#line 598
    wait_list = user->next;
  } else {
#line 600
    u = wait_list;
    {
#line 600
    while (1) {
      while_continue: /* CIL Label */ ;
#line 600
      if (! u) {
#line 600
        goto while_break;
      }
#line 601
      if ((unsigned long )u->next == (unsigned long )user) {
#line 602
        u->next = user->next;
#line 603
        goto while_break;
      }
#line 600
      u = u->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 605
  user->next = connect_list;
#line 606
  connect_list = user;
#line 610
  if ((int )user->remote.vmajor > 2) {
#line 611
    if (me->region_set) {
      {
#line 612
      v3w.code = (ychar )123;
#line 613
      v3w.rows = htons(me->rows);
#line 614
      v3w.cols = htons(me->cols);
#line 615
      send_oob(fd, (yaddr )(& v3w), (ychar )sizeof(v3_winch ));
#line 616
      winch_exec();
#line 617
      spew_term(me, fd, (int )me->rows, (int )me->cols);
      }
    } else {
      {
#line 619
      spew_term(me, fd, (int )parm.rows, (int )parm.cols);
      }
    }
#line 621
    if ((long )me->flags & 1073741824L) {
      {
#line 622
      v3f.code = (ychar )111;
#line 623
      v3f.flags = htonl(me->flags);
#line 624
      send_oob(fd, (yaddr )(& v3f), (ychar )sizeof(v3_flags ));
      }
    }
  }
#line 629
  u = connect_list;
  {
#line 629
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 629
    if (! u) {
#line 629
      goto while_break___0;
    }
#line 630
    if ((unsigned long )u != (unsigned long )user) {
      {
#line 631
      send_import(u, user);
      }
    }
#line 629
    u = u->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 632
  return;
}
}
#line 638 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/comm.c"
static void connect_user(int fd ) 
{ 
  register yuser *user ;
  register yuser *u ;
  int tmp___0 ;
  int tmp___1 ;
  uint16_t tmp___2 ;
  uint16_t tmp___3 ;

  {
#line 644
  user = fd_to_user[fd];
#line 644
  if ((unsigned long )user == (unsigned long )((void *)0)) {
    {
#line 645
    remove_fd(fd);
#line 646
    show_error("connect_user: unknown contact");
    }
#line 647
    return;
  }
  {
#line 649
  tmp___0 = full_read(fd, user->edit, 3);
  }
#line 649
  if (tmp___0 < 0) {
    {
#line 650
    free_user(user);
#line 651
    show_error("connect_user: bad read");
    }
#line 652
    return;
  }
  {
#line 654
  tmp___1 = open_term(user, user->full_name);
  }
#line 654
  if (tmp___1 < 0) {
    {
#line 655
    free_user(user);
#line 656
    show_error("connect_user: open_term() failed");
    }
#line 657
    return;
  }
#line 661
  if ((int )user->edit[0] == 254) {
    {
#line 662
    memset((void *)(& parm), 0, sizeof(y_parm ));
#line 663
    parm.protocol = (char)27;
#line 664
    tmp___2 = htons((uint16_t )3);
#line 664
    parm.vmajor = (short )tmp___2;
#line 665
    tmp___3 = htons((uint16_t )3);
#line 665
    parm.vminor = (short )tmp___3;
#line 666
    parm.rows = htons(me->t_rows);
#line 667
    parm.cols = htons(me->t_cols);
#line 668
    parm.my_rows = htons(user->t_rows);
#line 669
    parm.my_cols = htons(user->t_cols);
#line 670
    parm.w_rows = (u_char )parm.rows;
#line 671
    parm.w_cols = (u_char )parm.cols;
#line 672
    parm.pid = htonl(me->remote.pid);
#line 673
    write(user->fd, (void const   *)(& parm), sizeof(y_parm ));
#line 674
    add_fd(fd, & ytalk_user);
    }
  } else {
#line 678
    if ((unsigned long )user == (unsigned long )wait_list) {
#line 679
      wait_list = user->next;
    } else {
#line 681
      u = wait_list;
      {
#line 681
      while (1) {
        while_continue: /* CIL Label */ ;
#line 681
        if (! u) {
#line 681
          goto while_break;
        }
#line 682
        if ((unsigned long )u->next == (unsigned long )user) {
#line 683
          u->next = user->next;
#line 684
          goto while_break;
        }
#line 681
        u = u->next;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 686
    user->next = connect_list;
#line 687
    connect_list = user;
#line 689
    spew_term(me, fd, (int )me->t_rows, (int )me->t_cols);
#line 690
    user_winch = 1;
#line 691
    add_fd(fd, & read_user);
    }
  }
#line 693
  return;
}
}
#line 699 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/comm.c"
static void contact_user(int fd ) 
{ 
  register yuser *user ;
  register int n ;
  socklen_t socklen ;
  struct sockaddr_in peer ;
  char *hname ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 709
  remove_fd(fd);
#line 710
  user = fd_to_user[fd];
  }
#line 710
  if ((unsigned long )user == (unsigned long )((void *)0)) {
    {
#line 711
    show_error("contact_user: unknown contact");
    }
#line 712
    return;
  }
  {
#line 714
  send_dgram(user, 4);
#line 715
  socklen = (socklen_t )sizeof(struct sockaddr_in );
#line 716
  n = accept(fd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& user->sock)),
             (socklen_t */* __restrict  */)(& socklen));
  }
#line 716
  if (n < 0) {
    {
#line 717
    free_user(user);
#line 718
    tmp___0 = __errno_location();
    }
#line 718
    if (*tmp___0 != 32) {
      {
#line 718
      tmp___1 = __errno_location();
      }
#line 718
      if (*tmp___1 != 104) {
        {
#line 719
        show_error("connect_user: accept() failed");
        }
      }
    }
#line 720
    return;
  }
  {
#line 722
  close(fd);
#line 723
  fd_to_user[fd] = (yuser *)((void *)0);
#line 729
  socklen = (socklen_t )sizeof(struct sockaddr_in );
#line 730
  tmp___2 = getpeername(n, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& peer)),
                        (socklen_t */* __restrict  */)(& socklen));
  }
#line 730
  if (tmp___2 >= 0) {
#line 731
    if (peer.sin_addr.s_addr != user->host_addr) {
#line 732
      if (user->host_name) {
        {
#line 733
        free_mem(user->host_name);
        }
      }
#line 734
      if (user->host_fqdn) {
        {
#line 735
        free_mem(user->host_fqdn);
        }
      }
      {
#line 736
      user->host_addr = peer.sin_addr.s_addr;
#line 737
      hname = host_name(user->host_addr);
#line 738
      user->host_name = str_copy(hname);
#line 739
      user->host_fqdn = str_copy(hname);
#line 740
      generate_full_name(user);
#line 741
      show_error("Connection from unexpected host!");
      }
    }
  }
  {
#line 744
  user->fd = n;
#line 745
  fd_to_user[user->fd] = user;
#line 746
  add_fd(user->fd, & connect_user);
#line 747
  write(user->fd, (void const   *)(me->edit), (size_t )3);
  }
#line 748
  return;
}
}
#line 758 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/comm.c"
static ychar temp[20]  ;
#line 753 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/comm.c"
static int word_wrap(yuser *user ) 
{ 
  register int i ;
  register int x ;
  register int bound ;

  {
#line 760
  x = user->x;
#line 761
  bound = x / 2;
#line 761
  if (bound > 20) {
#line 762
    bound = 20;
  }
#line 763
  i = 1;
  {
#line 763
  while (1) {
    while_continue: /* CIL Label */ ;
#line 763
    if (i < bound) {
#line 763
      if (! ((int )*(*(user->scr + user->y) + (x - i)) != 32)) {
#line 763
        goto while_break;
      }
    } else {
#line 763
      goto while_break;
    }
#line 764
    temp[i] = *(*(user->scr + user->y) + (x - i));
#line 763
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 765
  if (i >= bound) {
#line 766
    return (-1);
  }
  {
#line 767
  move_term(user, user->y, x - i);
#line 768
  clreol_term(user);
#line 769
  newline_term(user);
#line 770
  i --;
  }
  {
#line 770
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 770
    if (! (i >= 1)) {
#line 770
      goto while_break___0;
    }
    {
#line 771
    addch_term(user, (int )temp[i]);
#line 770
    i --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 772
  return (0);
}
}
#line 779 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/comm.c"
static int announce(yuser *user ) 
{ 
  register int rc ;
  register int fd ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 785
  tmp___0 = __errno_location();
#line 785
  *tmp___0 = 0;
  }
  {
#line 786
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 786
    rc = send_dgram(user, 5);
    }
#line 786
    if (! (rc == 0)) {
#line 786
      goto while_break;
    }
    {
#line 789
    fd = connect_to((yuser *)0);
    }
#line 789
    if (fd < 0) {
#line 790
      if (fd == -3) {
#line 791
        goto while_break;
      }
#line 792
      if (fd == -2) {
        {
#line 794
        send_dgram(user, 6);
#line 795
        tmp___1 = __errno_location();
#line 795
        *tmp___1 = 0;
        }
#line 796
        goto while_continue;
      }
#line 798
      return (-1);
    }
    {
#line 804
    v2p.code = (ychar )133;
#line 805
    strncpy((char */* __restrict  */)(v2p.name), (char const   */* __restrict  */)me->user_name,
            (size_t )12);
#line 806
    strncpy((char */* __restrict  */)(v2p.host), (char const   */* __restrict  */)me->host_name,
            (size_t )64);
#line 807
    v2p.name[11] = (char )'\000';
#line 808
    v2p.host[63] = (char )'\000';
#line 809
    write(fd, (void const   *)(& v2p), sizeof(v2_pack ));
#line 810
    close(fd);
    }
#line 811
    return (0);
  }
  while_break: /* CIL Label */ ;
  }
#line 813
  if (rc == -1) {
#line 814
    return (-1);
  }
  {
#line 816
  tmp___2 = __errno_location();
#line 816
  *tmp___2 = 0;
#line 817
  rc = send_dgram(user, 3);
  }
#line 817
  if (rc == 0) {
#line 818
    return (0);
  }
#line 819
  if (rc == 4) {
#line 820
    return (1);
  }
#line 821
  return (-1);
}
}
#line 830 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/comm.c"
yuser *invite(char *name , int send_announce ) 
{ 
  register int rc ;
  char *hisname ;
  char *hishost ;
  char *histty ;
  yuser *user ;
  struct sockaddr_in tmpsock ;
  socklen_t i ;
  int sock ;
  int tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  int tmp___3 ;
  time_t tmp___4 ;
  time_t tmp___5 ;
  int tmp___6 ;
  time_t tmp___7 ;

  {
  {
#line 844
  name = resolve_alias(name);
#line 845
  hisname = str_copy(name);
#line 846
  hishost = (char *)((void *)0);
#line 847
  histty = (char *)((void *)0);
#line 848
  name = hisname;
  }
  {
#line 848
  while (1) {
    while_continue: /* CIL Label */ ;
#line 848
    if (! *name) {
#line 848
      goto while_break;
    }
#line 849
    if ((int )*name == 64) {
#line 850
      *name = (char )'\000';
#line 851
      hishost = name + 1;
    }
#line 853
    if ((int )*name == 35) {
#line 854
      *name = (char )'\000';
#line 855
      histty = name + 1;
    }
#line 848
    name ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 858
  user = new_user(hisname, hishost, histty);
#line 859
  free_mem(hisname);
  }
#line 860
  if ((unsigned long )user == (unsigned long )((void *)0)) {
#line 861
    return ((yuser *)((void *)0));
  }
#line 874
  if (! dont_change_my_addr) {
    {
#line 879
    sock = socket(2, 2, 0);
    }
#line 881
    if (sock >= 0) {
      {
#line 882
      tmpsock.sin_port = htons((uint16_t )518);
#line 883
      tmpsock.sin_family = (sa_family_t )2;
#line 884
      tmpsock.sin_addr.s_addr = user->host_addr;
#line 885
      tmp___3 = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& tmpsock)),
                        (socklen_t )sizeof(tmpsock));
      }
#line 885
      if (tmp___3 == 0) {
        {
#line 886
        i = (socklen_t )sizeof(struct sockaddr_in );
#line 892
        tmp___0 = getsockname(sock, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& tmpsock)),
                              (socklen_t */* __restrict  */)(& i));
        }
#line 892
        if (tmp___0 == 0) {
          {
#line 892
          tmp___1 = htonl((in_addr_t )0);
          }
#line 892
          if (tmpsock.sin_addr.s_addr != tmp___1) {
            {
#line 892
            tmp___2 = htonl((in_addr_t )2130706433);
            }
#line 892
            if (tmpsock.sin_addr.s_addr != tmp___2) {
#line 895
              me->host_addr = tmpsock.sin_addr.s_addr;
#line 896
              dont_change_my_addr ++;
            }
          }
        }
      }
      {
#line 899
      close(sock);
      }
    }
  }
#line 904
  user->next = wait_list;
#line 905
  wait_list = user;
#line 906
  user_winch = 1;
  {
#line 907
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 907
    rc = send_dgram(user, 1);
    }
#line 907
    if (! (rc == 0)) {
#line 907
      goto while_break___0;
    }
    {
#line 909
    rc = connect_to(user);
    }
#line 909
    if (rc < 0) {
#line 910
      if (rc == -3) {
#line 911
        goto while_break___0;
      }
#line 912
      if (rc == -2) {
        {
#line 914
        send_dgram(user, 2);
        }
#line 915
        goto while_continue___0;
      }
      {
#line 917
      free_user(user);
      }
#line 918
      return ((yuser *)((void *)0));
    }
    {
#line 920
    tmp___4 = time((time_t *)((void *)0));
#line 920
    user->last_invite = (ylong )tmp___4;
#line 921
    add_fd(user->fd, & connect_user);
#line 922
    write(user->fd, (void const   *)(me->edit), (size_t )3);
    }
#line 923
    return (user);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 925
  if (rc == -1) {
    {
#line 930
    tmp___5 = time((time_t *)((void *)0));
#line 930
    user->last_invite = (ylong )tmp___5;
    }
#line 931
    return (user);
  }
#line 935
  if (send_announce) {
    {
#line 937
    snprintf((char */* __restrict  */)(errstr), (size_t )132, (char const   */* __restrict  */)"Ringing %s...",
             user->user_name);
#line 941
    msg_term(me, errstr);
    }
  }
  {
#line 943
  tmp___6 = newsock(user);
  }
#line 943
  if (tmp___6 != 0) {
    {
#line 944
    free_user(user);
    }
#line 945
    return ((yuser *)((void *)0));
  }
  {
#line 947
  send_dgram(user, 0);
#line 948
  tmp___7 = time((time_t *)((void *)0));
#line 948
  user->last_invite = (ylong )tmp___7;
  }
#line 949
  if (send_announce) {
    {
#line 949
    rc = announce(user);
    }
#line 949
    if (rc != 0) {
      {
#line 950
      send_dgram(user, 4);
      }
#line 951
      if (rc > 0) {
        {
#line 953
        snprintf((char */* __restrict  */)(errstr), (size_t )132, (char const   */* __restrict  */)"%s refusing messages",
                 user->full_name);
        }
      } else {
        {
#line 959
        snprintf((char */* __restrict  */)(errstr), (size_t )132, (char const   */* __restrict  */)"%s not logged in",
                 user->full_name);
        }
      }
      {
#line 963
      show_error(errstr);
#line 964
      free_user(user);
      }
#line 965
      return ((yuser *)((void *)0));
    }
  }
  {
#line 967
  add_fd(user->fd, & contact_user);
  }
#line 968
  return (user);
}
}
#line 979 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/comm.c"
static char estr[80]  ;
#line 980 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/comm.c"
static ylong last_auto  =    (ylong )0;
#line 974 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/comm.c"
void house_clean(void) 
{ 
  register yuser *u ;
  register yuser *next ;
  ylong t ;
  int answer ;
  int rc ;
  time_t tmp___0 ;
  int tmp___1 ;
  time_t tmp___2 ;
  time_t tmp___3 ;

  {
  {
#line 983
  tmp___0 = time((time_t *)((void *)0));
#line 983
  t = (ylong )tmp___0;
  }
#line 985
  if (t - last_auto >= 30U) {
    {
#line 986
    last_auto = t;
#line 987
    tmp___1 = send_auto(0);
    }
#line 987
    if (tmp___1 != 0) {
      {
#line 988
      show_error("house_clean: send_auto() failed");
#line 989
      kill_auto();
      }
    }
  }
#line 992
  u = wait_list;
  {
#line 992
  while (1) {
    while_continue: /* CIL Label */ ;
#line 992
    if (! u) {
#line 992
      goto while_break;
    }
#line 993
    next = u->next;
#line 994
    if (t - u->last_invite >= 30U) {
      {
#line 995
      send_dgram(u, 0);
#line 996
      tmp___2 = time((time_t *)((void *)0));
#line 996
      t = (ylong )tmp___2;
#line 996
      u->last_invite = t;
      }
#line 997
      if (! ((long )def_flags & 32L)) {
#line 998
        goto __Cont;
      }
#line 999
      if ((long )def_flags & 1024L) {
#line 1000
        if (input_flag) {
#line 1001
          goto __Cont;
        }
        {
#line 1003
        snprintf((char */* __restrict  */)(estr), sizeof(estr), (char const   */* __restrict  */)"Rering %s?",
                 u->full_name);
#line 1007
        answer = yes_no(estr);
#line 1008
        tmp___3 = time((time_t *)((void *)0));
#line 1008
        t = (ylong )tmp___3;
        }
#line 1009
        if (answer == 110) {
#line 1010
          goto __Cont;
        }
      }
      {
#line 1012
      rc = announce(u);
      }
#line 1012
      if (rc != 0) {
        {
#line 1013
        send_dgram(u, 4);
        }
#line 1014
        if (rc > 0) {
          {
#line 1016
          snprintf((char */* __restrict  */)(errstr), (size_t )132, (char const   */* __restrict  */)"%s refusing messages",
                   u->full_name);
          }
        } else {
          {
#line 1022
          snprintf((char */* __restrict  */)(errstr), (size_t )132, (char const   */* __restrict  */)"%s not logged in",
                   u->full_name);
          }
        }
        {
#line 1026
        show_error(errstr);
#line 1027
        free_user(u);
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 992
    u = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1031
  return;
}
}
#line 1033 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/comm.c"
void rering_all(void) 
{ 
  yuser *u ;
  yuser *next ;
  int rc ;
  int tmp___0 ;
  time_t tmp___1 ;

  {
  {
#line 1039
  tmp___0 = send_auto(0);
  }
#line 1039
  if (tmp___0 != 0) {
    {
#line 1040
    show_error("rering_all: send_auto() failed");
#line 1041
    kill_auto();
    }
  }
#line 1043
  u = wait_list;
  {
#line 1043
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1043
    if (! u) {
#line 1043
      goto while_break;
    }
    {
#line 1044
    next = u->next;
#line 1045
    send_dgram(u, 0);
#line 1046
    tmp___1 = time((time_t *)((void *)0));
#line 1046
    u->last_invite = (ylong )tmp___1;
#line 1047
    rc = announce(u);
    }
#line 1047
    if (rc != 0) {
      {
#line 1048
      send_dgram(u, 4);
      }
#line 1049
      if (rc > 0) {
        {
#line 1051
        snprintf((char */* __restrict  */)(errstr), (size_t )132, (char const   */* __restrict  */)"%s refusing messages",
                 u->full_name);
        }
      } else {
        {
#line 1057
        snprintf((char */* __restrict  */)(errstr), (size_t )132, (char const   */* __restrict  */)"%s not logged in",
                 u->full_name);
        }
      }
      {
#line 1061
      show_error(errstr);
#line 1062
      free_user(u);
      }
    }
#line 1043
    u = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1065
  return;
}
}
#line 1067 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/comm.c"
void send_winch(yuser *user ) 
{ 
  register yuser *u ;

  {
  {
#line 1073
  v3w.rows = htons(user->t_rows);
#line 1074
  v3w.cols = htons(user->t_cols);
  }
#line 1076
  if ((unsigned long )user == (unsigned long )me) {
#line 1077
    v3w.code = (ychar )122;
#line 1078
    u = connect_list;
    {
#line 1078
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1078
      if (! u) {
#line 1078
        goto while_break;
      }
#line 1079
      if ((int )u->remote.vmajor > 2) {
        {
#line 1080
        send_oob(u->fd, (yaddr )(& v3w), (ychar )sizeof(v3_winch ));
        }
      }
#line 1078
      u = u->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1081
    winch_exec();
    }
  } else
#line 1082
  if ((int )user->remote.vmajor > 2) {
    {
#line 1083
    v3w.code = (ychar )121;
#line 1084
    send_oob(user->fd, (yaddr )(& v3w), (ychar )sizeof(v3_winch ));
    }
  }
#line 1086
  return;
}
}
#line 1088 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/comm.c"
void send_region(void) 
{ 
  register yuser *u ;

  {
  {
#line 1093
  v3w.code = (ychar )123;
#line 1094
  v3w.rows = htons(me->rows);
#line 1095
  v3w.cols = htons(me->cols);
#line 1097
  u = connect_list;
  }
  {
#line 1097
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1097
    if (! u) {
#line 1097
      goto while_break;
    }
#line 1098
    if ((int )u->remote.vmajor > 2) {
      {
#line 1099
      send_oob(u->fd, (yaddr )(& v3w), (ychar )sizeof(v3_winch ));
      }
    }
#line 1097
    u = u->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1100
  return;
}
}
#line 1102 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/comm.c"
void send_end_region(void) 
{ 
  register yuser *u ;

  {
  {
#line 1107
  v3w.code = (ychar )123;
#line 1108
  v3w.rows = htons((uint16_t )0);
#line 1109
  v3w.cols = htons((uint16_t )0);
#line 1111
  u = connect_list;
  }
  {
#line 1111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1111
    if (! u) {
#line 1111
      goto while_break;
    }
#line 1112
    if ((int )u->remote.vmajor > 2) {
      {
#line 1113
      send_oob(u->fd, (yaddr )(& v3w), (ychar )sizeof(v3_winch ));
      }
    }
#line 1111
    u = u->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1114
  return;
}
}
#line 1128 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/comm.c"
static ychar *o_buf  =    (ychar *)((void *)0);
#line 1129 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/comm.c"
static ychar *o_cbuf  =    (ychar *)((void *)0);
#line 1130 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/comm.c"
static int o_len  =    0;
#line 1130 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/comm.c"
static int o_clen  =    0;
#line 1120 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/comm.c"
void send_users(yuser *user , ychar *buf___3 , int len , ychar *cbuf , int clen ) 
{ 
  register yuser *u ;
  ychar *o ;
  ychar *b ;
  ychar *co ;
  ychar *cb ;
  yaddr tmp___0 ;
  yaddr tmp___1 ;
  ychar *tmp___2 ;
  ychar *tmp___3 ;
  ychar *tmp___4 ;
  ychar *tmp___5 ;

  {
#line 1133
  if (len << 1 > o_len) {
    {
#line 1134
    o_len = (len << 1) + 512;
#line 1135
    tmp___0 = realloc_mem(o_buf, o_len);
#line 1135
    o_buf = (ychar *)tmp___0;
    }
  }
#line 1137
  if (clen << 1 > o_clen) {
    {
#line 1138
    o_clen = (clen << 1) + 512;
#line 1139
    tmp___1 = realloc_mem(o_cbuf, o_clen);
#line 1139
    o_cbuf = (ychar *)tmp___1;
    }
  }
#line 1141
  b = buf___3;
#line 1141
  o = o_buf;
  {
#line 1141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1141
    if (! (len > 0)) {
#line 1141
      goto while_break;
    }
#line 1142
    tmp___2 = o;
#line 1142
    o ++;
#line 1142
    *tmp___2 = *b;
#line 1143
    if ((int )*b == 253) {
#line 1144
      tmp___3 = o;
#line 1144
      o ++;
#line 1144
      *tmp___3 = (ychar )253;
    }
#line 1141
    b ++;
#line 1141
    len --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1146
  cb = cbuf;
#line 1146
  co = o_cbuf;
  {
#line 1146
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1146
    if (! (clen > 0)) {
#line 1146
      goto while_break___0;
    }
#line 1147
    tmp___4 = co;
#line 1147
    co ++;
#line 1147
    *tmp___4 = *cb;
#line 1148
    if ((int )*cb == 253) {
#line 1149
      tmp___5 = co;
#line 1149
      co ++;
#line 1149
      *tmp___5 = (ychar )253;
    }
#line 1146
    cb ++;
#line 1146
    clen --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1152
  if (user) {
#line 1152
    if ((unsigned long )user != (unsigned long )me) {
#line 1153
      if (user->fd > 0) {
#line 1154
        if ((int )user->remote.vmajor > 2) {
#line 1155
          if ((int )user->crlf == 1) {
            {
#line 1156
            write(user->fd, (void const   *)o_cbuf, (size_t )(co - o_cbuf));
            }
          } else {
            {
#line 1158
            write(user->fd, (void const   *)o_buf, (size_t )(o - o_buf));
            }
          }
        } else {
          {
#line 1160
          write(user->fd, (void const   *)buf___3, (size_t )(b - buf___3));
          }
        }
      }
    } else {
#line 1152
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1163
    u = connect_list;
    {
#line 1163
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1163
      if (! u) {
#line 1163
        goto while_break___1;
      }
#line 1164
      if ((int )user->remote.vmajor > 2) {
#line 1165
        if ((int )u->crlf == 1) {
          {
#line 1166
          write(u->fd, (void const   *)o_cbuf, (size_t )(co - o_cbuf));
          }
        } else {
          {
#line 1168
          write(u->fd, (void const   *)o_buf, (size_t )(o - o_buf));
          }
        }
      } else {
        {
#line 1170
        write(u->fd, (void const   *)buf___3, (size_t )(b - buf___3));
        }
      }
#line 1163
      u = u->next;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1172
  return;
}
}
#line 1177 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/comm.c"
void show_input(yuser *user , ychar *buf___3 , int len ) 
{ 
  int tmp___0 ;

  {
#line 1183
  if (user->vt.got_esc) {
    process_esc: 
    {
#line 1185
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1185
      if (! (len > 0)) {
#line 1185
        goto while_break;
      }
      {
#line 1186
      vt100_process(user, (int )*buf___3);
      }
#line 1187
      if ((int )user->vt.got_esc == 0) {
#line 1188
        len --;
#line 1188
        buf___3 ++;
#line 1189
        goto while_break;
      }
#line 1185
      len --;
#line 1185
      buf___3 ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1193
  if (user->gt.got_gt) {
    process_gt: 
    {
#line 1195
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1195
      if (! (len > 0)) {
#line 1195
        goto while_break___0;
      }
      {
#line 1196
      gtalk_process(user, (int )*buf___3);
      }
#line 1197
      if ((int )user->gt.got_gt == 0) {
#line 1198
        len --;
#line 1198
        buf___3 ++;
#line 1199
        if ((int )*buf___3 == 10) {
#line 1200
          len --;
#line 1200
          buf___3 ++;
        }
#line 1201
        goto while_break___0;
      }
#line 1195
      len --;
#line 1195
      buf___3 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 1205
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1205
    if (! (len > 0)) {
#line 1205
      goto while_break___1;
    }
#line 1206
    if ((int )*buf___3 >= 32) {
#line 1206
      if ((int )*buf___3 <= 126) {
#line 1206
        goto _L___3;
      } else {
#line 1206
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 1206
    if ((int )*buf___3 >= 160) {
      _L___3: /* CIL Label */ 
#line 1206
      if ((int )*buf___3 != 254) {
#line 1207
        if (user->x + 1 >= (int )user->cols) {
#line 1208
          if ((long )user->flags & 4L) {
#line 1209
            if ((int )*buf___3 == 32) {
              {
#line 1210
              newline_term(user);
              }
            } else {
              {
#line 1211
              tmp___0 = word_wrap(user);
              }
#line 1211
              if (tmp___0 >= 0) {
                {
#line 1212
                addch_term(user, (int )*buf___3);
                }
              } else {
                {
#line 1214
                addch_term(user, (int )*buf___3);
#line 1215
                newline_term(user);
                }
              }
            }
          } else
#line 1218
          if (user->x == (int )user->cols - 1) {
#line 1219
            if ((int )user->onend == 1) {
              {
#line 1220
              newline_term(user);
#line 1221
              addch_term(user, (int )*buf___3);
#line 1222
              user->onend = (char)0;
              }
            } else {
              {
#line 1224
              addch_term(user, (int )*buf___3);
#line 1225
              user->onend = (char)1;
              }
            }
          }
        } else {
          {
#line 1230
          addch_term(user, (int )*buf___3);
          }
        }
      } else {
#line 1206
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 1231
    if ((int )*buf___3 == (int )user->edit[0]) {
#line 1231
      if (! ((long )user->flags & 1L)) {
        {
#line 1232
        rub_term(user);
        }
      } else {
#line 1231
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 1233
    if ((int )*buf___3 == (int )user->edit[2]) {
#line 1233
      if (! ((long )user->flags & 1L)) {
        {
#line 1234
        word_term(user);
        }
      } else {
#line 1233
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1235
    if ((int )*buf___3 == (int )user->edit[1]) {
#line 1235
      if (! ((long )user->flags & 1L)) {
        {
#line 1236
        kill_term(user);
        }
      } else {
#line 1235
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 1239
      if ((int )*buf___3 == 7) {
#line 1239
        goto case_7;
      }
#line 1243
      if ((int )*buf___3 == 8) {
#line 1243
        goto case_8;
      }
#line 1247
      if ((int )*buf___3 == 9) {
#line 1247
        goto case_9;
      }
#line 1250
      if ((int )*buf___3 == 10) {
#line 1250
        goto case_10;
      }
#line 1256
      if ((int )*buf___3 == 11) {
#line 1256
        goto case_11;
      }
#line 1259
      if ((int )*buf___3 == 13) {
#line 1259
        goto case_13;
      }
#line 1265
      if ((int )*buf___3 == 27) {
#line 1265
        goto case_27;
      }
#line 1274
      if ((int )*buf___3 == 3) {
#line 1274
        goto case_3;
      }
#line 1280
      goto switch_default;
      case_7: /* CIL Label */ 
#line 1240
      if ((long )def_flags & 2048L) {
        {
#line 1241
        _IO_putc(7, stderr);
        }
      }
#line 1242
      goto switch_break;
      case_8: /* CIL Label */ 
#line 1244
      if (user->x > 0) {
        {
#line 1245
        move_term(user, user->y, user->x - 1);
        }
      }
#line 1246
      goto switch_break;
      case_9: /* CIL Label */ 
      {
#line 1248
      tab_term(user);
      }
#line 1249
      goto switch_break;
      case_10: /* CIL Label */ 
#line 1251
      if ((int )user->crlf == 1) {
        {
#line 1252
        lf_term(user);
        }
      } else {
        {
#line 1254
        newline_term(user);
        }
      }
#line 1255
      goto switch_break;
      case_11: /* CIL Label */ 
      {
#line 1257
      lf_term(user);
      }
#line 1258
      goto switch_break;
      case_13: /* CIL Label */ 
#line 1260
      if ((long )user->flags & 1L) {
        {
#line 1261
        move_term(user, user->y, 0);
        }
      } else
#line 1260
      if ((int )user->crlf == 1) {
        {
#line 1261
        move_term(user, user->y, 0);
        }
      } else {
        {
#line 1263
        newline_term(user);
        }
      }
#line 1264
      goto switch_break;
      case_27: /* CIL Label */ 
#line 1266
      user->vt.got_esc = (char)1;
#line 1267
      user->vt.ac = (u_int )0;
#line 1268
      user->vt.av[0] = 0;
#line 1269
      user->vt.av[1] = 0;
#line 1270
      user->vt.hash = (char)0;
#line 1271
      user->vt.lparen = (char)0;
#line 1272
      len --;
#line 1272
      buf___3 ++;
#line 1273
      goto process_esc;
      case_3: /* CIL Label */ 
#line 1275
      user->gt.got_gt = (char)1;
#line 1276
      user->gt.type = (char)0;
#line 1277
      user->gt.len = 0;
#line 1278
      len --;
#line 1278
      buf___3 ++;
#line 1279
      goto process_gt;
      switch_default: /* CIL Label */ ;
      switch_break: /* CIL Label */ ;
      }
    }
#line 1205
    len --;
#line 1205
    buf___3 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1287
  flush_term(user);
  }
#line 1288
  return;
}
}
#line 1301 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/comm.c"
static ychar *nbuf  =    (ychar *)((void *)0);
#line 1302 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/comm.c"
static int nlen  =    0;
#line 1293 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/comm.c"
void my_input(yuser *user , ychar *buf___3 , int len ) 
{ 
  ychar *c ;
  ychar *n ;
  int i ;
  int j ;
  yaddr tmp___0 ;
  ychar *tmp___1 ;

  {
#line 1306
  if (input_flag) {
#line 1307
    io_ptr = buf___3;
#line 1308
    io_len = len;
#line 1309
    return;
  }
#line 1312
  if (len << 1 > nlen) {
    {
#line 1313
    nlen = (len << 1) + 512;
#line 1314
    tmp___0 = realloc_mem(nbuf, nlen);
#line 1314
    nbuf = (ychar *)tmp___0;
    }
  }
  {
#line 1318
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1318
    if (! (len > 0)) {
#line 1318
      goto while_break;
    }
#line 1321
    if (menu_ptr) {
      {
#line 1322
      io_ptr = buf___3;
#line 1323
      io_len = len;
#line 1324
      update_menu();
#line 1325
      buf___3 = io_ptr;
#line 1326
      len = io_len;
#line 1327
      io_len = 0;
      }
    }
#line 1331
    if (running_process) {
      {
#line 1332
      io_ptr = buf___3;
#line 1333
      io_len = len;
#line 1334
      update_exec();
#line 1335
      buf___3 = io_ptr;
#line 1336
      len = io_len;
#line 1337
      io_len = 0;
      }
    } else {
      {
#line 1341
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1341
        if (! (len > 0)) {
#line 1341
          goto while_break___0;
        }
#line 1342
        c = buf___3;
        {
#line 1343
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1343
          if (! (len > 0)) {
#line 1343
            goto while_break___1;
          }
#line 1344
          if ((int )*buf___3 == (int )me->old_rub) {
#line 1345
            *buf___3 = me->edit[0];
          } else
#line 1344
          if ((int )*buf___3 == 8) {
#line 1345
            *buf___3 = me->edit[0];
          } else
#line 1344
          if ((int )*buf___3 == 127) {
#line 1345
            *buf___3 = me->edit[0];
          } else
#line 1346
          if ((int )*buf___3 == 3) {
            {
#line 1347
            bail(0);
            }
          } else
#line 1348
          if ((int )*buf___3 == 13) {
#line 1349
            *buf___3 = (ychar )'\n';
          } else
#line 1350
          if ((int )*buf___3 == 27) {
#line 1351
            goto while_break___1;
          } else
#line 1352
          if ((int )*buf___3 == 12) {
#line 1353
            goto while_break___1;
          } else
#line 1352
          if ((int )*buf___3 == 18) {
#line 1353
            goto while_break___1;
          }
#line 1343
          buf___3 ++;
#line 1343
          len --;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1355
        i = (int )(buf___3 - c);
#line 1355
        if (i > 0) {
#line 1356
          n = nbuf;
#line 1356
          j = 0;
          {
#line 1356
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1356
            if (! ((long )j < buf___3 - c)) {
#line 1356
              goto while_break___2;
            }
#line 1357
            if ((int )*(c + j) == 10) {
#line 1358
              tmp___1 = n;
#line 1358
              n ++;
#line 1358
              *tmp___1 = (ychar )'\r';
#line 1359
              *n = (ychar )'\n';
            } else {
#line 1361
              *n = *(c + j);
            }
#line 1356
            n ++;
#line 1356
            j ++;
          }
          while_break___2: /* CIL Label */ ;
          }
          {
#line 1363
          j = (int )(n - nbuf);
#line 1364
          show_input(me, nbuf, j);
#line 1365
          send_users(user, c, i, nbuf, j);
          }
        }
#line 1367
        if (len > 0) {
#line 1368
          if ((int )*buf___3 == 27) {
#line 1369
            goto while_break___0;
          }
#line 1370
          if ((int )*buf___3 == 12) {
            {
#line 1371
            redraw_all_terms();
#line 1372
            buf___3 ++;
#line 1372
            len --;
            }
          } else
#line 1370
          if ((int )*buf___3 == 18) {
            {
#line 1371
            redraw_all_terms();
#line 1372
            buf___3 ++;
#line 1372
            len --;
            }
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1380
    if (len > 0) {
      {
#line 1381
      buf___3 ++;
#line 1381
      len --;
#line 1382
      show_main_menu();
      }
#line 1383
      if (len <= 0) {
        {
#line 1384
        update_menu();
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1387
  return;
}
}
#line 1389 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/comm.c"
void lock_flags(ylong flags ) 
{ 
  register yuser *u ;

  {
  {
#line 1395
  me->flags = (ylong )((long )flags | 1073741824L);
#line 1399
  v3f.code = (ychar )111;
#line 1400
  v3f.flags = htonl(me->flags);
#line 1401
  u = connect_list;
  }
  {
#line 1401
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1401
    if (! u) {
#line 1401
      goto while_break;
    }
#line 1402
    if ((int )u->remote.vmajor > 2) {
      {
#line 1403
      send_oob(u->fd, (yaddr )(& v3f), (ychar )sizeof(v3_flags ));
      }
    }
#line 1401
    u = u->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1404
  return;
}
}
#line 1406 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/comm.c"
void unlock_flags(void) 
{ 
  register yuser *u ;

  {
  {
#line 1411
  me->flags = def_flags;
#line 1415
  v3f.code = (ychar )112;
#line 1416
  v3f.flags = htonl(me->flags);
#line 1417
  u = connect_list;
  }
  {
#line 1417
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1417
    if (! u) {
#line 1417
      goto while_break;
    }
#line 1418
    if ((int )u->remote.vmajor > 2) {
      {
#line 1419
      send_oob(u->fd, (yaddr )(& v3f), (ychar )sizeof(v3_flags ));
      }
    }
#line 1417
    u = u->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1420
  return;
}
}
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 129 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/mem.c"
yaddr get_mem(size_t n ) 
{ 
  yaddr out ;
  void *tmp___0 ;

  {
  {
#line 141
  tmp___0 = malloc(n);
#line 141
  out = tmp___0;
  }
#line 141
  if ((unsigned long )out == (unsigned long )((void *)0)) {
    {
#line 142
    show_error("malloc() failed");
#line 143
    bail(2);
    }
  }
#line 148
  return (out);
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/mem.c"
void free_mem(yaddr addr ) 
{ 


  {
  {
#line 159
  free(addr);
  }
#line 160
  return;
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/mem.c"
yaddr realloc_mem(yaddr p , size_t n ) 
{ 
  yaddr out ;
  yaddr tmp___0 ;
  void *tmp___1 ;

  {
#line 202
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 207
    tmp___0 = get_mem(n);
    }
#line 207
    return (tmp___0);
  }
  {
#line 210
  tmp___1 = realloc(p, n);
#line 210
  out = tmp___1;
  }
#line 210
  if ((unsigned long )out == (unsigned long )((void *)0)) {
    {
#line 211
    show_error("realloc() failed");
#line 212
    bail(2);
    }
  }
#line 217
  return (out);
}
}
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 879
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gethostname)(char *__name ,
                                                                                                  size_t __len ) ;
#line 277 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/header.h"
yuser *me  ;
#line 278 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/header.h"
yuser *user_list  ;
#line 279 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/header.h"
yuser *connect_list  ;
#line 280 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/header.h"
yuser *wait_list  ;
#line 281 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/header.h"
yuser *fd_to_user[256]  ;
#line 282 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/header.h"
yuser *key_to_user[128]  ;
#line 78 "/usr/include/pwd.h"
extern void endpwent(void) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/user.c"
ylong def_flags  =    (ylong )0L;
#line 37 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/user.c"
static ylong daemon_id  ;
#line 41 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/user.c"
static int passwd_opened  =    0;
#line 43 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/user.c"
static char *user_name(ylong uid ) 
{ 
  register struct passwd *pw ;

  {
  {
#line 48
  passwd_opened = 1;
#line 49
  pw = getpwuid(uid);
  }
#line 49
  if ((unsigned long )pw == (unsigned long )((void *)0)) {
#line 50
    return ((char *)((void *)0));
  }
#line 51
  return (pw->pw_name);
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/user.c"
static void close_passwd(void) 
{ 


  {
#line 57
  if (passwd_opened) {
    {
#line 58
    endpwent();
#line 59
    passwd_opened = 0;
    }
  }
#line 61
  return;
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/user.c"
void generate_full_name(yuser *user ) 
{ 
  register char *c ;
  register char *d ;
  register char *ce ;
  yaddr tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 69
  if ((unsigned long )user->full_name == (unsigned long )((void *)0)) {
    {
#line 70
    tmp___0 = get_mem(50);
#line 70
    user->full_name = (char *)tmp___0;
    }
  }
#line 71
  c = user->full_name;
#line 71
  ce = user->full_name + 49;
#line 73
  d = user->user_name;
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (*d) {
#line 73
      if (! ((unsigned long )c < (unsigned long )ce)) {
#line 73
        goto while_break;
      }
    } else {
#line 73
      goto while_break;
    }
#line 74
    tmp___1 = c;
#line 74
    c ++;
#line 74
    *tmp___1 = *d;
#line 73
    d ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 76
  if ((unsigned long )c < (unsigned long )ce) {
#line 77
    tmp___2 = c;
#line 77
    c ++;
#line 77
    *tmp___2 = (char )'@';
  }
#line 78
  d = user->host_fqdn;
  {
#line 78
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 78
    if (*d) {
#line 78
      if (! ((unsigned long )c < (unsigned long )ce)) {
#line 78
        goto while_break___0;
      }
    } else {
#line 78
      goto while_break___0;
    }
#line 79
    tmp___3 = c;
#line 79
    c ++;
#line 79
    *tmp___3 = *d;
#line 78
    d ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 81
  if (*(user->tty_name + 0)) {
#line 82
    if ((unsigned long )c < (unsigned long )ce) {
#line 83
      tmp___4 = c;
#line 83
      c ++;
#line 83
      *tmp___4 = (char )'#';
    }
#line 84
    d = user->tty_name;
    {
#line 84
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 84
      if (*d) {
#line 84
        if (! ((unsigned long )c < (unsigned long )ce)) {
#line 84
          goto while_break___1;
        }
      } else {
#line 84
        goto while_break___1;
      }
#line 85
      tmp___5 = c;
#line 85
      c ++;
#line 85
      *tmp___5 = *d;
#line 84
      d ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 87
  *c = (char )'\000';
#line 88
  return;
}
}
#line 95
static void assign_key(yuser *user ) ;
#line 95 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/user.c"
static ychar key  =    (ychar )'a';
#line 90 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/user.c"
static void assign_key(yuser *user ) 
{ 
  register ychar old ;

  {
#line 97
  if ((int )user->key != 0) {
#line 98
    return;
  } else
#line 97
  if ((unsigned long )user == (unsigned long )me) {
#line 98
    return;
  } else
#line 97
  if ((unsigned long )user_list == (unsigned long )((void *)0)) {
#line 98
    return;
  }
#line 99
  old = key;
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if ((unsigned long )key_to_user[key] == (unsigned long )((void *)0)) {
#line 102
      key_to_user[key] = user;
#line 103
      user->key = key;
#line 104
      return;
    }
#line 106
    if ((int )key == 122) {
#line 107
      key = (ychar )'A';
    } else
#line 108
    if ((int )key == 90) {
#line 109
      key = (ychar )'a';
    } else {
#line 111
      key = (ychar )((int )key + 1);
    }
#line 100
    if (! ((int )old != (int )key)) {
#line 100
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  user->key = (ychar )'\000';
#line 114
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/user.c"
void init_user(char *vhost___0 ) 
{ 
  char *my_name ;
  char *my_vhost ;
  char my_host[100] ;
  __pid_t tmp___0 ;
  ylong adr ;
  ylong tmp___1 ;
  char *name ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  __pid_t tmp___6 ;

  {
  {
#line 128
  user_list = (yuser *)((void *)0);
#line 129
  connect_list = (yuser *)((void *)0);
#line 130
  wait_list = (yuser *)((void *)0);
#line 131
  tmp___0 = getpid();
#line 131
  daemon_id = (ylong )(tmp___0 << 10);
#line 132
  memset((void *)(fd_to_user), 0, 256UL * sizeof(yuser *));
#line 133
  memset((void *)(key_to_user), 0, 128UL * sizeof(yuser *));
#line 136
  my_name = user_name(myuid);
  }
#line 137
  if ((unsigned long )my_name == (unsigned long )((void *)0)) {
    {
#line 138
    show_error("Who are you?");
#line 139
    bail(4);
    }
  } else
#line 137
  if ((int )*(my_name + 0) == 0) {
    {
#line 138
    show_error("Who are you?");
#line 139
    bail(4);
    }
  }
#line 143
  my_vhost = vhost___0;
#line 143
  if (my_vhost) {
    {
#line 144
    strncpy((char */* __restrict  */)(my_host), (char const   */* __restrict  */)my_vhost,
            (size_t )99);
#line 145
    dont_change_my_addr = 1;
    }
  } else {
    {
#line 143
    my_vhost = getenv("LOCALHOST");
    }
#line 143
    if (my_vhost) {
      {
#line 144
      strncpy((char */* __restrict  */)(my_host), (char const   */* __restrict  */)my_vhost,
              (size_t )99);
#line 145
      dont_change_my_addr = 1;
      }
    } else {
      {
#line 147
      tmp___5 = gethostname(my_host, (size_t )100);
      }
#line 147
      if (tmp___5 < 0) {
        {
#line 148
        show_error("init_user: gethostname() failed");
#line 149
        bail(4);
        }
      } else {
        {
#line 152
        tmp___4 = strchr((char const   *)(my_host), '.');
        }
#line 152
        if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
          {
#line 153
          tmp___1 = get_host_addr(my_host);
#line 153
          adr = tmp___1;
          }
#line 154
          if (adr != 0U) {
#line 154
            if (adr != 4294967295U) {
              {
#line 155
              tmp___2 = host_name(adr);
#line 155
              name = tmp___2;
              }
#line 156
              if (name) {
                {
#line 156
                tmp___3 = strchr((char const   *)name, '.');
                }
#line 156
                if (tmp___3) {
                  {
#line 157
                  strncpy((char */* __restrict  */)(my_host), (char const   */* __restrict  */)name,
                          (size_t )99);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 162
  my_host[99] = (char)0;
#line 165
  me = new_user(my_name, my_host, (void *)0);
  }
#line 165
  if ((unsigned long )me == (unsigned long )((void *)0)) {
    {
#line 166
    bail(4);
    }
  }
  {
#line 168
  me->key = (ychar )'@';
#line 169
  me->remote.protocol = (char)27;
#line 170
  me->remote.vmajor = (short)3;
#line 171
  me->remote.vminor = (short)3;
#line 172
  tmp___6 = getpid();
#line 172
  me->remote.pid = (ylong )tmp___6;
#line 175
  me->crlf = (char)1;
#line 177
  close_passwd();
  }
#line 178
  return;
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/user.c"
yuser *new_user(char *name , char *hostname , char *tty ) 
{ 
  register yuser *out ;
  register yuser *u ;
  ylong addr ;
  yaddr tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  ylong tmp___3 ;

  {
#line 192
  if ((unsigned long )hostname == (unsigned long )((void *)0)) {
#line 193
    hostname = me->host_name;
#line 194
    addr = me->host_addr;
  } else
#line 192
  if ((int )*hostname == 0) {
#line 193
    hostname = me->host_name;
#line 194
    addr = me->host_addr;
  } else {
    {
#line 195
    addr = get_host_addr(hostname);
    }
#line 195
    if (addr == 4294967295U) {
      {
#line 197
      snprintf((char */* __restrict  */)(errstr), (size_t )132, (char const   */* __restrict  */)"new_user: bad host: \'%s\'",
               hostname);
#line 201
      show_error(errstr);
      }
#line 202
      return ((yuser *)((void *)0));
    }
  }
  {
#line 207
  tmp___0 = get_mem(sizeof(yuser ));
#line 207
  out = (yuser *)tmp___0;
#line 208
  memset((void *)out, 0, sizeof(yuser ));
#line 209
  out->user_name = str_copy(name);
#line 210
  out->host_name = str_copy(hostname);
#line 211
  tmp___2 = strchr((char const   *)hostname, '.');
  }
#line 211
  if (tmp___2) {
    {
#line 212
    out->host_fqdn = str_copy(hostname);
    }
  } else {
    {
#line 214
    tmp___1 = host_name(addr);
#line 214
    out->host_fqdn = str_copy(tmp___1);
    }
  }
#line 215
  out->host_addr = addr;
#line 216
  if (tty) {
    {
#line 217
    out->tty_name = str_copy(tty);
    }
  } else {
    {
#line 219
    out->tty_name = str_copy("");
    }
  }
  {
#line 220
  tmp___3 = daemon_id;
#line 220
  daemon_id ++;
#line 220
  out->d_id = tmp___3;
#line 221
  generate_full_name(out);
#line 222
  assign_key(out);
#line 223
  out->flags = def_flags;
  }
#line 227
  if ((unsigned long )user_list == (unsigned long )((void *)0)) {
#line 228
    out->unext = user_list;
#line 229
    user_list = out;
  } else
#line 227
  if ((int )out->key <= (int )user_list->key) {
#line 228
    out->unext = user_list;
#line 229
    user_list = out;
  } else {
#line 231
    u = user_list;
    {
#line 231
    while (1) {
      while_continue: /* CIL Label */ ;
#line 231
      if (! ((unsigned long )u->unext != (unsigned long )((void *)0))) {
#line 231
        goto while_break;
      }
#line 232
      if ((int )out->key <= (int )(u->unext)->key) {
#line 233
        goto while_break;
      }
#line 231
      u = u->unext;
    }
    while_break: /* CIL Label */ ;
    }
#line 234
    out->unext = u->unext;
#line 235
    u->unext = out;
  }
#line 237
  return (out);
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/user.c"
static void clear_user(yuser *user ) 
{ 
  unsigned int i ;

  {
  {
#line 245
  free_mem(user->user_name);
#line 246
  free_mem(user->host_name);
#line 247
  free_mem(user->host_fqdn);
#line 248
  free_mem(user->tty_name);
#line 249
  free_mem(user->full_name);
  }
#line 250
  if ((unsigned long )user->gt.buf != (unsigned long )((void *)0)) {
    {
#line 251
    free_mem(user->gt.buf);
    }
  }
#line 252
  if ((unsigned long )user->gt.version != (unsigned long )((void *)0)) {
    {
#line 253
    free_mem(user->gt.version);
    }
  }
#line 254
  if ((unsigned long )user->dbuf != (unsigned long )((void *)0)) {
    {
#line 255
    free_mem(user->dbuf);
    }
  }
#line 256
  if ((unsigned long )user->term != (unsigned long )((void *)0)) {
    {
#line 257
    free_mem(user->term);
    }
  }
#line 258
  if (user->output_fd > 0) {
    {
#line 259
    close(user->output_fd);
    }
  }
#line 260
  if (user->fd) {
    {
#line 261
    remove_fd(user->fd);
#line 262
    fd_to_user[user->fd] = (yuser *)((void *)0);
#line 263
    close(user->fd);
    }
  }
#line 265
  if ((int )user->key != 0) {
#line 266
    key_to_user[user->key] = (yuser *)((void *)0);
  }
#line 267
  if ((unsigned long )user->scr != (unsigned long )((void *)0)) {
#line 268
    i = 0U;
    {
#line 268
    while (1) {
      while_continue: /* CIL Label */ ;
#line 268
      if (! (i < (unsigned int )user->rows)) {
#line 268
        goto while_break;
      }
      {
#line 269
      free_mem(*(user->scr + i));
#line 268
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 270
    free_mem(user->scr);
#line 271
    free_mem(user->scr_tabs);
    }
  }
  {
#line 273
  free_mem(user);
  }
#line 274
  return;
}
}
#line 276 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/user.c"
void free_user(yuser *user ) 
{ 
  register yuser *u ;

  {
#line 284
  if ((unsigned long )user == (unsigned long )user_list) {
#line 285
    user_list = user->unext;
  } else {
#line 287
    u = user_list;
    {
#line 287
    while (1) {
      while_continue: /* CIL Label */ ;
#line 287
      if (! u) {
#line 287
        goto while_break;
      }
#line 288
      if ((unsigned long )u->unext == (unsigned long )user) {
#line 289
        u->unext = user->unext;
#line 290
        goto while_break;
      }
#line 287
      u = u->unext;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 292
  if ((unsigned long )user == (unsigned long )connect_list) {
#line 293
    connect_list = user->next;
  } else {
#line 295
    u = connect_list;
    {
#line 295
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 295
      if (! u) {
#line 295
        goto while_break___0;
      }
#line 296
      if ((unsigned long )u->next == (unsigned long )user) {
#line 297
        u->next = user->next;
#line 298
        goto while_break___0;
      }
#line 295
      u = u->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 300
  if ((unsigned long )user == (unsigned long )wait_list) {
#line 301
    wait_list = user->next;
  } else {
#line 303
    u = wait_list;
    {
#line 303
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 303
      if (! u) {
#line 303
        goto while_break___1;
      }
#line 304
      if ((unsigned long )u->next == (unsigned long )user) {
#line 305
        u->next = user->next;
#line 306
        goto while_break___1;
      }
#line 303
      u = u->next;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 311
  if ((unsigned long )connect_list == (unsigned long )((void *)0)) {
#line 311
    if ((unsigned long )wait_list == (unsigned long )((void *)0)) {
#line 311
      if ((unsigned long )menu_ptr == (unsigned long )((void *)0)) {
#line 311
        if (running_process == 0) {
          {
#line 315
          bail(-1);
          }
        }
      }
    }
  }
  {
#line 317
  close_term(user);
#line 318
  clear_user(user);
  }
#line 320
  if ((unsigned long )connect_list == (unsigned long )((void *)0)) {
#line 320
    if ((unsigned long )wait_list != (unsigned long )((void *)0)) {
      {
#line 321
      msg_term(me, "Waiting for connection...");
      }
    }
  }
#line 322
  user_winch = 1;
#line 323
  return;
}
}
#line 330 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/user.c"
yuser *find_user(char *name , ylong host_addr , ylong pid___0 ) 
{ 
  register yuser *u ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 337
  u = user_list;
  {
#line 337
  while (1) {
    while_continue: /* CIL Label */ ;
#line 337
    if (! u) {
#line 337
      goto while_break;
    }
#line 338
    if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 338
      goto _L___0;
    } else {
      {
#line 338
      tmp___0 = strcmp((char const   *)u->user_name, (char const   *)name);
      }
#line 338
      if (tmp___0 == 0) {
        _L___0: /* CIL Label */ 
#line 339
        if (host_addr == 4294967295U) {
#line 339
          goto _L;
        } else
#line 339
        if (u->host_addr == host_addr) {
          _L: /* CIL Label */ 
#line 340
          if (pid___0 == 4294967295U) {
#line 341
            return (u);
          } else
#line 340
          if (u->remote.pid == pid___0) {
#line 341
            return (u);
          }
        }
      }
    }
#line 337
    u = u->unext;
  }
  while_break: /* CIL Label */ ;
  }
#line 345
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 345
    goto _L___2;
  } else {
    {
#line 345
    tmp___1 = strcmp((char const   *)me->user_name, (char const   *)name);
    }
#line 345
    if (tmp___1 == 0) {
      _L___2: /* CIL Label */ 
#line 346
      if (host_addr == 4294967295U) {
#line 346
        goto _L___1;
      } else
#line 346
      if (me->host_addr == host_addr) {
        _L___1: /* CIL Label */ 
#line 347
        if (pid___0 == 4294967295U) {
#line 348
          return (me);
        } else
#line 347
        if (me->remote.pid == pid___0) {
#line 348
          return (me);
        }
      }
    }
  }
#line 352
  return ((yuser *)((void *)0));
}
}
#line 358 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/user.c"
void free_users(void) 
{ 
  yuser *u ;
  yuser *un ;

  {
#line 362
  u = user_list;
  {
#line 362
  while (1) {
    while_continue: /* CIL Label */ ;
#line 362
    if (! ((unsigned long )u != (unsigned long )((void *)0))) {
#line 362
      goto while_break;
    }
    {
#line 363
    un = u->unext;
#line 364
    clear_user(u);
#line 365
    u = un;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 367
  return;
}
}
#line 123 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 156
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 163
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  *__addr , socklen_t __addr_len ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 382 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/header.h"
void close_all(void) ;
#line 137 "/usr/include/netdb.h"
extern struct hostent *gethostbyaddr(void const   *__addr , __socklen_t __len , int __type ) ;
#line 144
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 290
extern struct servent *getservbyname(char const   *__name , char const   *__proto ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.h"
struct _talkd talkd[6]  ;
#line 54
int daemons ;
#line 34 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t ( __attribute__((__leaf__)) inet_addr)(char const   *__cp ) ;
#line 53
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.c"
int daemons  =    0;
#line 53 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.c"
static int otalk  ;
#line 53 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.c"
static int ntalk  ;
#line 54 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.c"
static CTL_MSG omsg  ;
#line 55 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.c"
static CTL_RESPONSE orsp  ;
#line 56 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.c"
static CTL_MSG42 nmsg  ;
#line 57 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.c"
static CTL_RESPONSE42 nrsp  ;
#line 59 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.c"
static int autofd  =    -1;
#line 60 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.c"
static struct sockaddr_in autosock  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.c"
static ylong autoid[6]  ;
#line 62 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.c"
static ylong announce_id  =    (ylong )0;
#line 63 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.c"
static readdr *readdr_list  =    (readdr *)((void *)0);
#line 74 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.c"
static int init_dgram(struct sockaddr_in *sock ) 
{ 
  int fd ;
  socklen_t socklen ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 81
  sock->sin_family = (sa_family_t )2;
#line 82
  sock->sin_addr.s_addr = (in_addr_t )0;
#line 83
  sock->sin_port = (in_port_t )0;
#line 84
  fd = socket(2, 2, 0);
  }
#line 84
  if (fd < 0) {
    {
#line 85
    show_error("init_dgram: socket() failed");
#line 86
    bail(4);
    }
  }
  {
#line 88
  tmp___0 = bind(fd, (struct sockaddr  const  *)((struct sockaddr *)sock), (socklen_t )sizeof(struct sockaddr_in ));
  }
#line 88
  if (tmp___0 != 0) {
    {
#line 89
    close(fd);
#line 90
    show_error("init_dgram: bind() failed");
#line 91
    bail(4);
    }
  }
  {
#line 93
  socklen = (socklen_t )sizeof(struct sockaddr_in );
#line 94
  tmp___1 = getsockname(fd, (struct sockaddr */* __restrict  */)((struct sockaddr *)sock),
                        (socklen_t */* __restrict  */)(& socklen));
  }
#line 94
  if (tmp___1 < 0) {
    {
#line 95
    close(fd);
#line 96
    show_error("init_dgram: getsockname() failed");
#line 97
    bail(4);
    }
  }
#line 99
  sock->sin_addr.s_addr = me->host_addr;
#line 100
  return (fd);
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.c"
static int init_daemon(char *name , short port , yaddr mptr , int mlen , yaddr rptr ,
                       int rlen ) 
{ 
  struct servent *serv ;
  int d ;

  {
#line 116
  if (daemons >= 5) {
    {
#line 117
    show_error("init_daemon: too many daemons");
#line 118
    bail(4);
    }
  }
  {
#line 120
  daemons ++;
#line 120
  d = daemons;
#line 122
  serv = getservbyname((char const   *)name, "udp");
  }
#line 122
  if ((unsigned long )serv != (unsigned long )((void *)0)) {
#line 123
    talkd[d].port = (short )serv->s_port;
  } else {
#line 125
    talkd[d].port = port;
  }
  {
#line 127
  talkd[d].fd = init_dgram(& talkd[d].sock);
#line 128
  talkd[d].mptr = mptr;
#line 129
  talkd[d].mlen = (size_t )mlen;
#line 130
  talkd[d].rptr = rptr;
#line 131
  talkd[d].rlen = (size_t )rlen;
  }
#line 132
  return (d);
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.c"
static void read_autoport(int fd ) 
{ 
  socklen_t socklen ;
  v2_pack *pack ;
  char *estr___0 ;
  struct sockaddr_in temp___0 ;
  yaddr tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  yaddr tmp___3 ;
  int tmp___4 ;

  {
  {
#line 144
  tmp___0 = get_mem(sizeof(v2_pack ));
#line 144
  pack = (v2_pack *)tmp___0;
#line 148
  socklen = (socklen_t )sizeof(struct sockaddr_in );
#line 149
  fd = accept(autofd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& temp___0)),
              (socklen_t */* __restrict  */)(& socklen));
  }
#line 149
  if (fd == -1) {
    {
#line 150
    show_error("read_autoport: accept() failed");
#line 151
    free_mem(pack);
    }
#line 152
    return;
  }
  {
#line 157
  tmp___1 = __errno_location();
#line 157
  *tmp___1 = 0;
#line 158
  tmp___2 = full_read(fd, (char *)pack, sizeof(v2_pack ));
  }
#line 158
  if (tmp___2 < 0) {
    {
#line 159
    show_error("read_autoport: unknown auto-invite connection");
#line 160
    close(fd);
#line 161
    free_mem(pack);
    }
#line 162
    return;
  } else
#line 158
  if ((int )pack->code != 133) {
    {
#line 159
    show_error("read_autoport: unknown auto-invite connection");
#line 160
    close(fd);
#line 161
    free_mem(pack);
    }
#line 162
    return;
  }
  {
#line 164
  close(fd);
#line 167
  pack->name[11] = (char )'\000';
#line 168
  pack->host[63] = (char )'\000';
#line 170
  tmp___3 = get_mem(96);
#line 170
  estr___0 = (char *)tmp___3;
  }
#line 172
  if (! ((long )def_flags & 16L)) {
    {
#line 174
    snprintf((char */* __restrict  */)estr___0, (size_t )96, (char const   */* __restrict  */)"Talk to %s@%s?",
             pack->name, pack->host);
#line 178
    tmp___4 = yes_no(estr___0);
    }
#line 178
    if (tmp___4 == 110) {
      {
#line 179
      free_mem(estr___0);
#line 180
      free_mem(pack);
      }
#line 181
      return;
    }
  }
  {
#line 185
  snprintf((char */* __restrict  */)estr___0, (size_t )96, (char const   */* __restrict  */)"%s@%s",
           pack->name, pack->host);
#line 189
  invite(estr___0, 1);
#line 190
  free_mem(estr___0);
#line 191
  free_mem(pack);
  }
#line 192
  return;
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.c"
static void init_autoport(void) 
{ 
  socklen_t socklen ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 202
  autosock.sin_family = (sa_family_t )2;
#line 203
  autosock.sin_addr.s_addr = (in_addr_t )0;
#line 204
  autosock.sin_port = (in_port_t )0;
#line 205
  autofd = socket(2, 1, 0);
  }
#line 205
  if (autofd < 0) {
    {
#line 206
    show_error("init_autoport: socket() failed");
    }
#line 207
    return;
  }
  {
#line 209
  tmp___0 = bind(autofd, (struct sockaddr  const  *)((struct sockaddr *)(& autosock)),
                 (socklen_t )sizeof(struct sockaddr_in ));
  }
#line 209
  if (tmp___0 < 0) {
    {
#line 211
    close(autofd);
#line 212
    autofd = -1;
#line 213
    show_error("init_autoport: bind() failed");
    }
#line 214
    return;
  }
  {
#line 216
  socklen = (socklen_t )sizeof(struct sockaddr_in );
#line 217
  tmp___1 = getsockname(autofd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& autosock)),
                        (socklen_t */* __restrict  */)(& socklen));
  }
#line 217
  if (tmp___1 < 0) {
    {
#line 218
    close(autofd);
#line 219
    autofd = -1;
#line 220
    show_error("init_autoport: getsockname() failed");
    }
#line 221
    return;
  }
  {
#line 223
  autosock.sin_addr.s_addr = me->host_addr;
#line 224
  tmp___2 = listen(autofd, 5);
  }
#line 224
  if (tmp___2 < 0) {
    {
#line 225
    close(autofd);
#line 226
    autofd = -1;
#line 227
    show_error("init_autoport: listen() failed");
    }
#line 228
    return;
  }
  {
#line 230
  memset((void *)(autoid), 0, 6UL * sizeof(ylong ));
#line 231
  add_fd(autofd, & read_autoport);
  }
#line 232
  return;
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.c"
static void place_my_address(BSD42_SOCK *sock , ylong addr ) 
{ 
  register readdr *r ;

  {
#line 245
  r = readdr_list;
  {
#line 245
  while (1) {
    while_continue: /* CIL Label */ ;
#line 245
    if (! ((unsigned long )r != (unsigned long )((void *)0))) {
#line 245
      goto while_break;
    }
#line 246
    if ((r->from_addr & r->from_mask) == (me->host_addr & r->from_mask)) {
#line 246
      if ((addr & r->mask) == r->addr) {
#line 248
        addr = (r->id_addr & r->id_mask) | (me->host_addr & ~ r->id_mask);
#line 250
        sock->sin_addr.s_addr = addr;
#line 251
        goto while_break;
      }
    }
#line 245
    r = r->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  if ((unsigned long )r == (unsigned long )((void *)0)) {
#line 254
    sock->sin_addr.s_addr = me->host_addr;
  }
  {
#line 255
  sock->sin_family = htons((uint16_t )2);
  }
#line 256
  return;
}
}
#line 262 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.c"
static int sendit(ylong addr , int d ) 
{ 
  ssize_t n ;
  struct sockaddr_in remote_daemon ;
  struct timeval tv ;
  char *rtype ;
  char *mtype ;
  fd_set sel___0 ;
  int __d0 ;
  int __d1 ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  u_short t ;
  char *c ;
  uint16_t tmp___4 ;
  uint16_t tmp___5 ;

  {
#line 275
  if (d == ntalk) {
    {
#line 276
    nmsg.vers = (u_char )1;
#line 277
    place_my_address(& nmsg.ctl_addr, addr);
#line 278
    mtype = & nmsg.type;
#line 279
    rtype = & nrsp.type;
    }
  } else
#line 280
  if (d == otalk) {
    {
#line 281
    omsg.type = nmsg.type;
#line 282
    omsg.addr = nmsg.addr;
#line 283
    omsg.id_num = nmsg.id_num;
#line 284
    omsg.pid = nmsg.pid;
#line 285
    strncpy((char */* __restrict  */)(omsg.l_name), (char const   */* __restrict  */)(nmsg.l_name),
            (size_t )9);
#line 286
    strncpy((char */* __restrict  */)(omsg.r_name), (char const   */* __restrict  */)(nmsg.r_name),
            (size_t )9);
#line 287
    strncpy((char */* __restrict  */)(omsg.r_tty), (char const   */* __restrict  */)(nmsg.r_tty),
            (size_t )16);
#line 288
    place_my_address(& omsg.ctl_addr, addr);
#line 289
    mtype = & omsg.type;
#line 290
    rtype = & orsp.type;
    }
  } else {
    {
#line 293
    snprintf((char */* __restrict  */)(errstr), (size_t )132, (char const   */* __restrict  */)"Unkown daemon type: %d",
             d);
#line 297
    show_error(errstr);
    }
#line 298
    return (-1);
  }
#line 303
  remote_daemon.sin_family = (sa_family_t )2;
#line 304
  remote_daemon.sin_addr.s_addr = addr;
#line 305
  remote_daemon.sin_port = (in_port_t )talkd[d].port;
  {
#line 309
  while (1) {
    while_continue: /* CIL Label */ ;
#line 309
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& sel___0.__fds_bits[0]): "memory");
#line 309
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 310
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 311
    tv.tv_sec = 0L;
#line 312
    tv.tv_usec = 0L;
#line 313
    sel___0.__fds_bits[talkd[d].fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << talkd[d].fd % (8 * (int )sizeof(__fd_mask ));
#line 314
    tmp___0 = select(talkd[d].fd + 1, (fd_set */* __restrict  */)(& sel___0), (fd_set */* __restrict  */)0,
                     (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& tv));
#line 314
    n = (ssize_t )tmp___0;
    }
#line 314
    if (n < 0L) {
      {
#line 315
      show_error("sendit: flush select() failed");
      }
#line 316
      return (-1);
    }
#line 318
    if (n <= 0L) {
#line 319
      goto while_break___0;
    }
    {
#line 320
    tmp___1 = recv(talkd[d].fd, talkd[d].rptr, talkd[d].rlen, 0);
    }
#line 320
    if (tmp___1 < 0L) {
      {
#line 321
      show_error("sendit: flush recv() failed");
      }
#line 322
      return (-1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 333
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 334
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 335
      n = sendto(talkd[d].fd, (void const   *)((char *)talkd[d].mptr), talkd[d].mlen,
                 0, (struct sockaddr  const  *)((struct sockaddr *)(& remote_daemon)),
                 (socklen_t )sizeof(remote_daemon));
      }
#line 337
      if (n != (ssize_t )talkd[d].mlen) {
        {
#line 338
        show_error("sendit: sendto() failed");
        }
#line 339
        return (-1);
      }
      {
#line 341
      tv.tv_sec = 5L;
#line 342
      tv.tv_usec = 0L;
#line 343
      sel___0.__fds_bits[talkd[d].fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << talkd[d].fd % (8 * (int )sizeof(__fd_mask ));
#line 344
      tmp___2 = select(talkd[d].fd + 1, (fd_set */* __restrict  */)(& sel___0), (fd_set */* __restrict  */)0,
                       (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& tv));
#line 344
      n = (ssize_t )tmp___2;
      }
#line 344
      if (n < 0L) {
        {
#line 345
        show_error("sendit: first select() failed");
        }
#line 346
        return (-1);
      }
#line 334
      if (! (n <= 0L)) {
#line 334
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 350
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 351
      n = recv(talkd[d].fd, talkd[d].rptr, talkd[d].rlen, 0);
      }
#line 352
      if (n < 0L) {
        {
#line 353
        show_error("sendit: recv() failed");
        }
#line 354
        return (-1);
      }
#line 356
      if ((int )*rtype != (int )*mtype) {
#line 357
        tv.tv_sec = 5L;
      } else {
#line 359
        tv.tv_sec = 0L;
      }
      {
#line 360
      tv.tv_usec = 0L;
#line 361
      sel___0.__fds_bits[talkd[d].fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << talkd[d].fd % (8 * (int )sizeof(__fd_mask ));
#line 362
      tmp___3 = select(talkd[d].fd + 1, (fd_set */* __restrict  */)(& sel___0), (fd_set */* __restrict  */)0,
                       (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& tv));
#line 362
      n = (ssize_t )tmp___3;
      }
#line 362
      if (n < 0L) {
        {
#line 363
        show_error("sendit: second select() failed");
        }
#line 364
        return (-1);
      }
#line 350
      if (n > 0L) {
#line 350
        if (! ((int )*rtype != (int )*mtype)) {
#line 350
          goto while_break___3;
        }
      } else {
#line 350
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 333
    if (! ((int )*rtype != (int )*mtype)) {
#line 333
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 381
  if (d == otalk) {
#line 381
    if ((int )nrsp.type == 1) {
#line 381
      if ((int )nrsp.answer == 0) {
        {
#line 383
        memcpy((void */* __restrict  */)((char *)(& t)), (void const   */* __restrict  */)((char *)(& orsp.addr.sin_family) - 2),
               sizeof(t));
#line 384
        tmp___4 = ntohs(t);
        }
#line 384
        if ((int )tmp___4 == 2) {
          {
#line 384
          tmp___5 = ntohs(orsp.addr.sin_family);
          }
#line 384
          if ((int )tmp___5 != 2) {
#line 386
            c = ((char *)(& orsp) + sizeof(orsp)) - 1;
            {
#line 387
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 387
              if (! ((unsigned long )c >= (unsigned long )((char *)(& orsp.id_num)))) {
#line 387
                goto while_break___4;
              }
#line 388
              *c = *(c - 2);
#line 387
              c --;
            }
            while_break___4: /* CIL Label */ ;
            }
          }
        }
      }
    }
  }
#line 395
  if (d == otalk) {
#line 396
    nrsp.type = orsp.type;
#line 397
    nrsp.answer = orsp.answer;
#line 398
    nrsp.id_num = orsp.id_num;
#line 399
    nrsp.addr = orsp.addr;
  }
#line 401
  return (0);
}
}
#line 420
static int find_daemon(ylong addr ) ;
#line 420 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.c"
static hostinfo *host_head  =    (hostinfo *)((void *)0);
#line 408 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.c"
static int find_daemon(ylong addr ) 
{ 
  register hostinfo *h ;
  register int n ;
  register int i ;
  register int d ;
  CTL_MSG m1 ;
  CTL_MSG42 m2 ;
  struct sockaddr_in remote_daemon ;
  struct timeval tv ;
  int out ;
  int max ;
  fd_set sel___0 ;
  ssize_t tmp___0 ;
  ssize_t tmp___1 ;
  int __d0 ;
  int __d1 ;
  int r ;
  ssize_t tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int __d0___0 ;
  int __d1___0 ;
  yaddr tmp___5 ;
  char *tmp___6 ;

  {
#line 426
  h = host_head;
  {
#line 426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 426
    if (! h) {
#line 426
      goto while_break;
    }
#line 427
    if (h->host_addr == addr) {
#line 428
      return (h->dtype);
    }
#line 426
    h = h->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 430
  remote_daemon.sin_family = (sa_family_t )2;
#line 431
  remote_daemon.sin_addr.s_addr = addr;
#line 433
  m1 = omsg;
#line 434
  m2 = nmsg;
#line 436
  memcpy((void */* __restrict  */)(& m1.ctl_addr), (void const   */* __restrict  */)(& talkd[otalk].sock),
         sizeof(m1.ctl_addr));
#line 437
  place_my_address(& m1.ctl_addr, addr);
#line 439
  memcpy((void */* __restrict  */)(& m2.ctl_addr), (void const   */* __restrict  */)(& talkd[ntalk].sock),
         sizeof(m2.ctl_addr));
#line 440
  place_my_address(& m2.ctl_addr, addr);
#line 441
  m2.type = (char)1;
#line 441
  m1.type = m2.type;
#line 442
  m2.id_num = htonl((uint32_t )0);
#line 442
  m1.id_num = m2.id_num;
#line 443
  m2.r_tty[0] = (char )'\000';
#line 443
  m1.r_tty[0] = m2.r_tty[0];
#line 444
  strcpy((char */* __restrict  */)(m1.r_name), (char const   */* __restrict  */)"ytalk");
#line 445
  strcpy((char */* __restrict  */)(m2.r_name), (char const   */* __restrict  */)"ytalk");
#line 446
  m2.addr.sin_family = htons((uint16_t )2);
#line 446
  m1.addr.sin_family = m2.addr.sin_family;
#line 447
  m2.ctl_addr.sin_family = htons((uint16_t )2);
#line 447
  m1.ctl_addr.sin_family = m2.ctl_addr.sin_family;
#line 449
  out = 0;
#line 450
  i = 0;
  }
  {
#line 450
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 450
    if (! (i < 5)) {
#line 450
      goto while_break___0;
    }
    {
#line 451
    remote_daemon.sin_port = (in_port_t )talkd[ntalk].port;
#line 452
    tmp___0 = sendto(talkd[ntalk].fd, (void const   *)((char *)(& m2)), sizeof(m2),
                     0, (struct sockaddr  const  *)((struct sockaddr *)(& remote_daemon)),
                     (socklen_t )sizeof(remote_daemon));
#line 452
    n = (int )tmp___0;
    }
#line 454
    if ((unsigned long )n != sizeof(m2)) {
      {
#line 455
      show_error("Warning: cannot write to new talk daemon");
      }
    }
    {
#line 457
    remote_daemon.sin_port = (in_port_t )talkd[otalk].port;
#line 458
    tmp___1 = sendto(talkd[otalk].fd, (void const   *)((char *)(& m1)), sizeof(m1),
                     0, (struct sockaddr  const  *)((struct sockaddr *)(& remote_daemon)),
                     (socklen_t )sizeof(remote_daemon));
#line 458
    n = (int )tmp___1;
    }
#line 460
    if ((unsigned long )n != sizeof(m1)) {
      {
#line 461
      show_error("Warning: cannot write to old talk daemon");
      }
    }
#line 463
    tv.tv_sec = 4L;
#line 464
    tv.tv_usec = 0L;
    {
#line 466
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 466
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& sel___0.__fds_bits[0]): "memory");
#line 466
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 467
    sel___0.__fds_bits[talkd[ntalk].fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << talkd[ntalk].fd % (8 * (int )sizeof(__fd_mask ));
#line 468
    sel___0.__fds_bits[talkd[otalk].fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << talkd[otalk].fd % (8 * (int )sizeof(__fd_mask ));
#line 469
    max = talkd[ntalk].fd;
#line 470
    if (max < talkd[otalk].fd) {
#line 471
      max = talkd[otalk].fd;
    }
    {
#line 473
    n = select(1 + max, (fd_set */* __restrict  */)(& sel___0), (fd_set */* __restrict  */)((void *)0),
               (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
    }
#line 473
    if (n < 0) {
      {
#line 474
      show_error("find_daemon: first select() failed");
      }
#line 475
      goto __Cont;
    }
#line 477
    if (n == 0) {
#line 478
      goto __Cont;
    }
    {
#line 480
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 481
      d = 1;
      {
#line 481
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 481
        if (! (d <= daemons)) {
#line 481
          goto while_break___3;
        }
#line 482
        if ((sel___0.__fds_bits[talkd[d].fd / (8 * (int )sizeof(__fd_mask ))] & (1L << talkd[d].fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
          {
#line 485
          tmp___2 = recv(talkd[d].fd, (void *)(errstr), talkd[d].rlen, 0);
#line 485
          r = (int )tmp___2;
          }
#line 486
          if (r < 0) {
            {
#line 487
            tmp___3 = __errno_location();
            }
#line 487
            if (*tmp___3 == 4) {
#line 488
              goto __Cont___0;
            } else {
              {
#line 487
              tmp___4 = __errno_location();
              }
#line 487
              if (*tmp___4 == 111) {
#line 488
                goto __Cont___0;
              } else {
                {
#line 490
                show_error("find_daemon: recv() failed");
                }
              }
            }
          }
#line 492
          out |= 1 << d;
        }
        __Cont___0: /* CIL Label */ 
#line 481
        d ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 494
      tv.tv_sec = 0L;
#line 495
      tv.tv_usec = 500000L;
      {
#line 497
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 497
        __asm__  volatile   ("cld; rep; "
                             "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& sel___0.__fds_bits[0]): "memory");
#line 497
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 498
      sel___0.__fds_bits[talkd[ntalk].fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << talkd[ntalk].fd % (8 * (int )sizeof(__fd_mask ));
#line 499
      sel___0.__fds_bits[talkd[otalk].fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << talkd[otalk].fd % (8 * (int )sizeof(__fd_mask ));
#line 500
      n = select(1 + max, (fd_set */* __restrict  */)(& sel___0), (fd_set */* __restrict  */)((void *)0),
                 (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
      }
#line 500
      if (n < 0) {
        {
#line 501
        show_error("find_daemon: second select() failed");
        }
      }
#line 480
      if (! (n > 0)) {
#line 480
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 504
    tmp___5 = get_mem(sizeof(hostinfo ));
#line 504
    h = (hostinfo *)tmp___5;
#line 505
    h->next = host_head;
#line 506
    host_head = h;
#line 507
    h->host_addr = addr;
#line 508
    h->dtype = out;
    }
#line 509
    if (out) {
#line 510
      return (out);
    }
    __Cont: /* CIL Label */ 
#line 450
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 513
  tmp___6 = host_name(addr);
#line 513
  snprintf((char */* __restrict  */)(errstr), (size_t )132, (char const   */* __restrict  */)"No talk daemon on %s",
           tmp___6);
#line 517
  show_error(errstr);
  }
#line 518
  return (0);
}
}
#line 521 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.c"
static ylong make_net_mask(ylong addr ) 
{ 


  {
#line 525
  if (addr & 255U) {
#line 526
    return (4294967295U);
  }
#line 527
  if (addr & 65535U) {
#line 528
    return (4294967040U);
  }
#line 529
  if (addr & 16777215U) {
#line 530
    return (4294901760U);
  }
#line 531
  if (addr) {
#line 532
    return (4278190080U);
  }
#line 533
  return ((ylong )0);
}
}
#line 541 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.c"
void init_socket(void) 
{ 


  {
  {
#line 546
  ntalk = init_daemon((char *)"ntalk", (short)518, (yaddr )(& nmsg), (int )sizeof(nmsg),
                      (yaddr )(& nrsp), (int )sizeof(nrsp));
#line 548
  otalk = init_daemon((char *)"talk", (short)517, (yaddr )(& omsg), (int )sizeof(omsg),
                      (yaddr )(& orsp), (int )sizeof(orsp));
#line 551
  strncpy((char */* __restrict  */)(nmsg.l_name), (char const   */* __restrict  */)me->user_name,
          (size_t )12);
#line 555
  memcpy((void */* __restrict  */)(& omsg.ctl_addr), (void const   */* __restrict  */)(& talkd[otalk].sock),
         sizeof(omsg.ctl_addr));
#line 556
  memcpy((void */* __restrict  */)(& nmsg.ctl_addr), (void const   */* __restrict  */)(& talkd[ntalk].sock),
         sizeof(nmsg.ctl_addr));
#line 558
  nmsg.ctl_addr.sin_family = htons((uint16_t )2);
#line 558
  omsg.ctl_addr.sin_family = nmsg.ctl_addr.sin_family;
#line 559
  nmsg.vers = (u_char )1;
#line 561
  find_daemon(me->host_addr);
  }
#line 562
  if (! ((long )def_flags & 512L)) {
    {
#line 563
    init_autoport();
    }
  }
#line 564
  return;
}
}
#line 570 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.c"
void close_all(void) 
{ 
  register yuser *u ;
  register int d ;

  {
#line 576
  u = user_list;
  {
#line 576
  while (1) {
    while_continue: /* CIL Label */ ;
#line 576
    if (! u) {
#line 576
      goto while_break;
    }
#line 577
    if (u->fd > 0) {
      {
#line 578
      close(u->fd);
      }
    }
#line 579
    if (u->output_fd > 0) {
      {
#line 580
      close(u->output_fd);
      }
    }
#line 576
    u = u->unext;
  }
  while_break: /* CIL Label */ ;
  }
#line 582
  if (autofd > 0) {
    {
#line 583
    close(autofd);
    }
  }
#line 584
  d = 1;
  {
#line 584
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 584
    if (! (d <= daemons)) {
#line 584
      goto while_break___0;
    }
    {
#line 585
    close(talkd[d].fd);
#line 584
    d ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 586
  return;
}
}
#line 596 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.c"
int send_dgram(yuser *user , u_char type ) 
{ 
  ylong addr ;
  int d ;
  int *tmp___0 ;
  int dtype ;
  int d1 ;
  int d2 ;
  int tmp___1 ;

  {
  {
#line 607
  if ((int )type == 0) {
#line 607
    goto case_0;
  }
#line 612
  if ((int )type == 4) {
#line 612
    goto case_4;
  }
#line 617
  if ((int )type == 3) {
#line 617
    goto case_3;
  }
#line 623
  if ((int )type == 1) {
#line 623
    goto case_1;
  }
#line 628
  if ((int )type == 2) {
#line 628
    goto case_2;
  }
#line 633
  if ((int )type == 5) {
#line 633
    goto case_5;
  }
#line 638
  if ((int )type == 6) {
#line 638
    goto case_6;
  }
#line 643
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 608
  addr = me->host_addr;
#line 609
  nmsg.type = (char)0;
#line 610
  nmsg.id_num = htonl(user->l_id);
  }
#line 611
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 613
  addr = me->host_addr;
#line 614
  nmsg.type = (char)2;
#line 615
  nmsg.id_num = htonl(user->l_id);
  }
#line 616
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 618
  addr = user->host_addr;
#line 619
  nmsg.type = (char)3;
#line 620
  announce_id += 5U;
#line 621
  nmsg.id_num = htonl(announce_id);
  }
#line 622
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 624
  addr = user->host_addr;
#line 625
  nmsg.type = (char)1;
#line 626
  nmsg.id_num = htonl(user->r_id);
  }
#line 627
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 629
  addr = user->host_addr;
#line 630
  nmsg.type = (char)2;
#line 631
  nmsg.id_num = htonl(user->r_id);
  }
#line 632
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 634
  addr = user->host_addr;
#line 635
  nmsg.type = (char)1;
#line 636
  nmsg.id_num = htonl(user->r_id);
  }
#line 637
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 639
  addr = user->host_addr;
#line 640
  nmsg.type = (char)2;
#line 641
  nmsg.id_num = htonl(user->r_id);
  }
#line 642
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 644
  tmp___0 = __errno_location();
#line 644
  *tmp___0 = 0;
#line 645
  show_error("send_dgram: unknown type");
  }
#line 646
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 651
  if (user->daemon != 0) {
#line 652
    d = user->daemon;
  } else {
    {
#line 662
    d1 = find_daemon(user->host_addr);
#line 663
    d2 = find_daemon(me->host_addr);
#line 664
    dtype = d1 & d2;
    }
#line 666
    if (d1 == 0) {
#line 667
      return (-1);
    } else
#line 666
    if (d2 == 0) {
#line 667
      return (-1);
    }
#line 668
    if (dtype == 0) {
      {
#line 669
      dtype = find_daemon(addr);
#line 670
      d = 1;
      }
      {
#line 670
      while (1) {
        while_continue: /* CIL Label */ ;
#line 670
        if (! (d <= daemons)) {
#line 670
          goto while_break;
        }
#line 671
        if (dtype & (1 << d)) {
#line 672
          goto while_break;
        }
#line 670
        d ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 673
      if (d > daemons) {
#line 674
        return (-1);
      }
    } else {
#line 676
      d = 1;
      {
#line 676
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 676
        if (! (d <= daemons)) {
#line 676
          goto while_break___0;
        }
#line 677
        if (dtype & (1 << d)) {
#line 678
          user->daemon = d;
#line 679
          goto while_break___0;
        }
#line 676
        d ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 681
      if (d > daemons) {
#line 682
        return (-1);
      }
    }
  }
  {
#line 695
  nmsg.pid = htonl(user->d_id);
  }
#line 696
  if ((int )type == 5) {
    {
#line 697
    strcpy((char */* __restrict  */)(nmsg.l_name), (char const   */* __restrict  */)"+AUTO");
#line 698
    strncpy((char */* __restrict  */)(nmsg.r_name), (char const   */* __restrict  */)user->user_name,
            (size_t )12);
#line 699
    nmsg.r_tty[0] = (char )'\000';
    }
  } else
#line 696
  if ((int )type == 6) {
    {
#line 697
    strcpy((char */* __restrict  */)(nmsg.l_name), (char const   */* __restrict  */)"+AUTO");
#line 698
    strncpy((char */* __restrict  */)(nmsg.r_name), (char const   */* __restrict  */)user->user_name,
            (size_t )12);
#line 699
    nmsg.r_tty[0] = (char )'\000';
    }
  } else {
    {
#line 701
    strncpy((char */* __restrict  */)(nmsg.r_name), (char const   */* __restrict  */)user->user_name,
            (size_t )12);
#line 702
    strncpy((char */* __restrict  */)(nmsg.r_tty), (char const   */* __restrict  */)user->tty_name,
            (size_t )16);
    }
  }
  {
#line 705
  memcpy((void */* __restrict  */)(& nmsg.addr), (void const   */* __restrict  */)(& user->sock),
         sizeof(nmsg.addr));
#line 706
  nmsg.addr.sin_family = htons((uint16_t )2);
#line 707
  tmp___1 = sendit(addr, d);
  }
#line 707
  if (tmp___1 != 0) {
#line 708
    if ((int )type == 5) {
      {
#line 709
      strncpy((char */* __restrict  */)(nmsg.l_name), (char const   */* __restrict  */)me->user_name,
              (size_t )12);
      }
    } else
#line 708
    if ((int )type == 6) {
      {
#line 709
      strncpy((char */* __restrict  */)(nmsg.l_name), (char const   */* __restrict  */)me->user_name,
              (size_t )12);
      }
    }
#line 710
    return (-2);
  }
  {
#line 713
  if ((int )type == 0) {
#line 713
    goto case_0___0;
  }
#line 716
  if ((int )type == 1) {
#line 716
    goto case_1___0;
  }
#line 719
  if ((int )type == 5) {
#line 719
    goto case_5___0;
  }
#line 723
  if ((int )type == 6) {
#line 723
    goto case_6___0;
  }
#line 712
  goto switch_break___0;
  case_0___0: /* CIL Label */ 
  {
#line 714
  user->l_id = ntohl(nrsp.id_num);
  }
#line 715
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
  {
#line 717
  user->r_id = ntohl(nrsp.id_num);
  }
#line 718
  goto switch_break___0;
  case_5___0: /* CIL Label */ 
  {
#line 720
  strncpy((char */* __restrict  */)(nmsg.l_name), (char const   */* __restrict  */)me->user_name,
          (size_t )12);
#line 721
  user->r_id = ntohl(nrsp.id_num);
  }
#line 722
  goto switch_break___0;
  case_6___0: /* CIL Label */ 
  {
#line 724
  strncpy((char */* __restrict  */)(nmsg.l_name), (char const   */* __restrict  */)me->user_name,
          (size_t )12);
  }
#line 725
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 727
  return ((int )nrsp.answer);
}
}
#line 734 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.c"
int send_auto(u_char type ) 
{ 
  int dtype ;
  int d ;
  int rc ;
  int tmp___0 ;

  {
#line 740
  if (autofd < 0) {
#line 741
    return (0);
  }
  {
#line 742
  nmsg.type = (char )type;
#line 743
  strcpy((char */* __restrict  */)(nmsg.r_name), (char const   */* __restrict  */)"+AUTO");
#line 744
  nmsg.r_tty[0] = (char )'\000';
#line 746
  memcpy((void */* __restrict  */)(& nmsg.addr), (void const   */* __restrict  */)(& autosock),
         sizeof(nmsg.addr));
#line 747
  nmsg.addr.sin_family = htons((uint16_t )2);
#line 749
  rc = 0;
#line 750
  dtype = find_daemon(me->host_addr);
#line 751
  d = daemons;
  }
  {
#line 751
  while (1) {
    while_continue: /* CIL Label */ ;
#line 751
    if (! (d >= 1)) {
#line 751
      goto while_break;
    }
#line 752
    if (dtype & (1 << d)) {
      {
#line 753
      nmsg.id_num = htonl(autoid[d]);
#line 754
      nmsg.pid = htonl((uint32_t )1);
#line 755
      tmp___0 = sendit(me->host_addr, d);
      }
#line 755
      if (tmp___0 < 0) {
#line 756
        rc = -1;
      } else {
        {
#line 758
        autoid[d] = ntohl(nrsp.id_num);
        }
      }
    }
#line 751
    d --;
  }
  while_break: /* CIL Label */ ;
  }
#line 760
  if (rc) {
#line 761
    return (rc);
  }
#line 762
  if ((int )type == 0) {
#line 763
    return (0);
  }
#line 764
  return ((int )nrsp.answer);
}
}
#line 770 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.c"
void kill_auto(void) 
{ 


  {
#line 773
  if (autofd < 0) {
#line 774
    return;
  }
  {
#line 775
  send_auto((u_char )2);
#line 776
  remove_fd(autofd);
#line 777
  close(autofd);
#line 778
  autofd = -1;
  }
#line 779
  return;
}
}
#line 784 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.c"
int newsock(yuser *user ) 
{ 
  int fd ;
  socklen_t socklen ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 791
  user->sock.sin_family = (sa_family_t )2;
#line 792
  user->sock.sin_addr.s_addr = (in_addr_t )0;
#line 793
  user->sock.sin_port = (in_port_t )0;
#line 794
  fd = socket(2, 1, 0);
  }
#line 794
  if (fd < 0) {
    {
#line 795
    show_error("newsock: socket() failed");
    }
#line 796
    return (-1);
  }
  {
#line 798
  tmp___0 = bind(fd, (struct sockaddr  const  *)((struct sockaddr *)(& user->sock)),
                 (socklen_t )sizeof(struct sockaddr_in ));
  }
#line 798
  if (tmp___0 < 0) {
    {
#line 799
    close(fd);
#line 800
    show_error("newsock: bind() failed");
    }
#line 801
    return (-1);
  }
  {
#line 803
  socklen = (socklen_t )sizeof(struct sockaddr_in );
#line 804
  tmp___1 = getsockname(fd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& user->sock)),
                        (socklen_t */* __restrict  */)(& socklen));
  }
#line 804
  if (tmp___1 < 0) {
    {
#line 805
    close(fd);
#line 806
    show_error("newsock: getsockname() failed");
    }
#line 807
    return (-1);
  }
  {
#line 809
  place_my_address((BSD42_SOCK *)(& user->sock), user->host_addr);
#line 810
  tmp___2 = listen(fd, 5);
  }
#line 810
  if (tmp___2 < 0) {
    {
#line 811
    close(fd);
#line 812
    show_error("newsock: listen() failed");
    }
#line 813
    return (-1);
  }
#line 815
  user->fd = fd;
#line 816
  fd_to_user[user->fd] = user;
#line 817
  user->orig_sock = user->sock;
#line 818
  return (0);
}
}
#line 824 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.c"
int connect_to(yuser *user ) 
{ 
  register yuser *u ;
  int fd ;
  socklen_t socklen ;
  struct sockaddr_in sock ;
  struct sockaddr_in orig_sock ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 833
  orig_sock = *((struct sockaddr_in *)(& nrsp.addr));
#line 834
  orig_sock.sin_family = (sa_family_t )2;
#line 837
  u = user_list;
  {
#line 837
  while (1) {
    while_continue: /* CIL Label */ ;
#line 837
    if (! u) {
#line 837
      goto while_break;
    }
#line 838
    if ((int )orig_sock.sin_port == (int )u->orig_sock.sin_port) {
#line 838
      if (orig_sock.sin_addr.s_addr == u->orig_sock.sin_addr.s_addr) {
#line 839
        return (-3);
      }
    }
#line 837
    u = u->unext;
  }
  while_break: /* CIL Label */ ;
  }
#line 840
  if ((int )orig_sock.sin_port == (int )autosock.sin_port) {
#line 840
    if (orig_sock.sin_addr.s_addr == autosock.sin_addr.s_addr) {
#line 841
      return (-3);
    }
  }
  {
#line 843
  sock = orig_sock;
#line 844
  fd = socket(2, 1, 0);
  }
#line 844
  if (fd < 0) {
    {
#line 845
    show_error("connect_to: socket() failed");
    }
#line 846
    return (-1);
  }
  {
#line 848
  tmp___2 = connect(fd, (struct sockaddr  const  *)((struct sockaddr *)(& sock)),
                    (socklen_t )sizeof(struct sockaddr_in ));
  }
#line 848
  if (tmp___2 < 0) {
    {
#line 849
    close(fd);
#line 850
    tmp___1 = __errno_location();
    }
#line 850
    if (*tmp___1 == 111) {
      {
#line 851
      tmp___0 = __errno_location();
#line 851
      *tmp___0 = 0;
      }
#line 852
      return (-2);
    }
    {
#line 854
    show_error("connect_to: connect() failed");
    }
#line 855
    return (-1);
  }
  {
#line 857
  socklen = (socklen_t )sizeof(struct sockaddr_in );
#line 858
  tmp___3 = getsockname(fd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& sock)),
                        (socklen_t */* __restrict  */)(& socklen));
  }
#line 858
  if (tmp___3 < 0) {
    {
#line 859
    close(fd);
#line 860
    show_error("connect_to: getsockname() failed");
    }
#line 861
    return (-1);
  }
#line 863
  if (user) {
#line 864
    user->sock = sock;
#line 865
    user->orig_sock = orig_sock;
#line 866
    user->fd = fd;
#line 867
    fd_to_user[user->fd] = user;
  }
#line 869
  return (fd);
}
}
#line 875 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.c"
ylong get_host_addr(char *hostname ) 
{ 
  struct hostent *host ;
  ylong addr ;
  int *tmp___0 ;
  in_addr_t tmp___1 ;
  struct hostent *tmp___2 ;

  {
  {
#line 882
  tmp___0 = __errno_location();
#line 882
  *tmp___0 = 0;
#line 883
  tmp___2 = gethostbyname((char const   *)hostname);
#line 883
  host = tmp___2;
  }
#line 883
  if ((unsigned long )host != (unsigned long )((void *)0)) {
#line 884
    if ((unsigned long )host->h_length != sizeof(addr)) {
      {
#line 886
      snprintf((char */* __restrict  */)(errstr), (size_t )132, (char const   */* __restrict  */)"Bad IN addr: %s",
               hostname);
#line 890
      show_error(errstr);
      }
#line 891
      return ((ylong )-1);
    }
    {
#line 893
    memcpy((void */* __restrict  */)(& addr), (void const   */* __restrict  */)*(host->h_addr_list + 0),
           sizeof(addr));
    }
  } else {
    {
#line 894
    tmp___1 = inet_addr((char const   *)hostname);
#line 894
    addr = tmp___1;
    }
#line 894
    if (addr == 4294967295U) {
#line 895
      return ((ylong )-1);
    }
  }
#line 896
  return (addr);
}
}
#line 903 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.c"
char *host_name(ylong addr ) 
{ 
  struct hostent *host ;
  char **s ;
  struct in_addr tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 910
  host = gethostbyaddr((void const   *)((char *)(& addr)), (__socklen_t )sizeof(addr),
                       2);
  }
#line 910
  if ((unsigned long )host == (unsigned long )((void *)0)) {
    {
#line 912
    tmp___0.s_addr = addr;
#line 913
    tmp___1 = inet_ntoa(tmp___0);
    }
#line 913
    return (tmp___1);
  }
  {
#line 915
  tmp___2 = strchr((char const   *)host->h_name, '.');
  }
#line 915
  if (tmp___2) {
#line 916
    return (host->h_name);
  }
#line 917
  s = host->h_aliases;
#line 918
  if (s) {
#line 918
    if (*s) {
      {
#line 919
      while (1) {
        while_continue: /* CIL Label */ ;
#line 919
        if (! *s) {
#line 919
          goto while_break;
        }
        {
#line 920
        tmp___3 = strchr((char const   *)*s, '.');
        }
#line 920
        if (tmp___3) {
#line 921
          return (*s);
        }
#line 919
        s ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 922
  return (host->h_name);
}
}
#line 931 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/socket.c"
void readdress_host(char *from_id , char *to_id , char *on_id ) 
{ 
  register readdr *new ;
  ylong from_addr ;
  ylong to_addr ;
  ylong on_addr ;
  ylong from_mask ;
  ylong to_mask ;
  ylong on_mask ;
  yaddr tmp___0 ;

  {
  {
#line 939
  from_addr = get_host_addr(from_id);
  }
#line 939
  if (from_addr == 4294967295U) {
    {
#line 941
    snprintf((char */* __restrict  */)(errstr), (size_t )132, (char const   */* __restrict  */)"Unknown host: \'%s\'",
             from_id);
#line 945
    show_error(errstr);
    }
#line 946
    return;
  }
  {
#line 948
  to_addr = get_host_addr(to_id);
  }
#line 948
  if (to_addr == 4294967295U) {
    {
#line 950
    snprintf((char */* __restrict  */)(errstr), (size_t )132, (char const   */* __restrict  */)"Unknown host: \'%s\'",
             to_id);
#line 954
    show_error(errstr);
    }
#line 955
    return;
  }
  {
#line 957
  on_addr = get_host_addr(on_id);
  }
#line 957
  if (on_addr == 4294967295U) {
    {
#line 959
    snprintf((char */* __restrict  */)(errstr), (size_t )132, (char const   */* __restrict  */)"Unknown host: \'%s\'",
             on_id);
#line 963
    show_error(errstr);
    }
#line 964
    return;
  }
  {
#line 966
  from_mask = make_net_mask(from_addr);
#line 967
  to_mask = make_net_mask(to_addr);
#line 968
  on_mask = make_net_mask(on_addr);
  }
#line 974
  if (from_addr == to_addr) {
#line 975
    return;
  }
  {
#line 977
  tmp___0 = get_mem(sizeof(readdr ));
#line 977
  new = (readdr *)tmp___0;
#line 978
  new->addr = on_addr;
#line 979
  new->mask = on_mask;
#line 980
  new->from_addr = from_addr;
#line 981
  new->from_mask = from_mask;
#line 982
  new->id_addr = to_addr;
#line 983
  new->id_mask = to_mask;
#line 984
  new->next = readdr_list;
#line 985
  readdr_list = new;
  }
#line 986
  return;
}
}
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 578 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) putenv)(char *__string ) ;
#line 846 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 534 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 573
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execl)(char const   *__path ,
                                                                                              char const   *__arg 
                                                                                              , ...) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 397 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/header.h"
void kill_exec(void) ;
#line 90 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcflush)(int __fd ,
                                                                              int __queue_selector ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 64 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/exec.c"
extern int openpty(int * , int * , char * , struct termios * , struct winsize * ) ;
#line 72 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/exec.c"
int running_process  =    0;
#line 73 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/exec.c"
static int pid  ;
#line 74 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/exec.c"
static int pfd  ;
#line 75 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/exec.c"
static int prows  ;
#line 75 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/exec.c"
static int pcols  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/exec.c"
static ychar buf___2[4096]  ;
#line 103 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/exec.c"
static void exec_input(int fd ) 
{ 
  register int rc ;
  int *tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 110
  tmp___1 = read(fd, (void *)(buf___2), (size_t )4096);
#line 110
  rc = (int )tmp___1;
  }
#line 110
  if (rc <= 0) {
    {
#line 111
    kill_exec();
#line 112
    tmp___0 = __errno_location();
#line 112
    *tmp___0 = 0;
#line 113
    show_error("command shell terminated");
    }
#line 114
    return;
  }
  {
#line 116
  show_input(me, buf___2, rc);
#line 117
  send_users(me, buf___2, rc, buf___2, rc);
  }
#line 118
  return;
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/exec.c"
static void calculate_size(int *rows , int *cols ) 
{ 
  register yuser *u ;

  {
#line 126
  *rows = (int )me->t_rows;
#line 127
  *cols = (int )me->t_cols;
#line 129
  u = connect_list;
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    if (! u) {
#line 129
      goto while_break;
    }
#line 130
    if ((int )u->remote.vmajor > 2) {
#line 131
      if ((int )u->remote.my_rows > 1) {
#line 131
        if ((int )u->remote.my_rows < *rows) {
#line 132
          *rows = (int )u->remote.my_rows;
        }
      }
#line 133
      if ((int )u->remote.my_cols > 1) {
#line 133
        if ((int )u->remote.my_cols < *cols) {
#line 134
          *cols = (int )u->remote.my_cols;
        }
      }
    }
#line 129
    u = u->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 136
  return;
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/exec.c"
void execute(char *command ) 
{ 
  int fd ;
  char yvenv[25] ;
  char name[20] ;
  char *shell ;
  struct stat sbuf ;
  struct passwd *pw ;
  int fds ;
  int *tmp___0 ;
  int tmp___1 ;
  __pid_t tmp___2 ;
  int tmp___3 ;

  {
#line 154
  pw = (struct passwd *)((void *)0);
#line 159
  if ((long )me->flags & 1073741824L) {
    {
#line 160
    tmp___0 = __errno_location();
#line 160
    *tmp___0 = 0;
#line 161
    show_error("alternate mode already running");
    }
#line 162
    return;
  }
  {
#line 165
  tmp___1 = openpty(& fd, & fds, name, (struct termios *)((void *)0), (struct winsize *)((void *)0));
  }
#line 165
  if (tmp___1 < 0) {
    {
#line 166
    msg_term(me, "cannot get pseudo terminal");
    }
#line 167
    return;
  }
  {
#line 169
  close(fds);
#line 180
  tcflush(fd, 2);
#line 191
  pw = getpwuid(myuid);
  }
#line 192
  if ((unsigned long )pw != (unsigned long )((void *)0)) {
#line 193
    shell = pw->pw_shell;
  } else {
#line 195
    shell = (char *)"/bin/sh";
  }
  {
#line 198
  calculate_size(& prows, & pcols);
#line 206
  signal(17, (void (*)(int  ))0);
#line 213
  pid = fork();
  }
#line 213
  if (pid == 0) {
    {
#line 214
    close(fd);
#line 215
    close_all();
#line 216
    tmp___2 = setsid();
    }
#line 216
    if (tmp___2 < 0) {
      {
#line 217
      exit(-1);
      }
    }
    {
#line 218
    fd = open((char const   *)(name), 2);
    }
#line 218
    if (fd < 0) {
      {
#line 219
      exit(-1);
      }
    }
    {
#line 234
    dup2(fd, 0);
#line 235
    dup2(fd, 1);
#line 236
    dup2(fd, 2);
#line 240
    signal(28, (void (*)(int  ))1);
#line 245
    set_terminal_flags(fd);
#line 246
    set_terminal_size(fd, prows, pcols);
#line 250
    putenv((char *)"TERM=vt100");
#line 253
    snprintf((char */* __restrict  */)(yvenv), sizeof(yvenv), (char const   */* __restrict  */)"YTALK_VERSION=%s",
             "3.3.0");
#line 257
    putenv(yvenv);
#line 265
    ioctl(fd, 21518UL);
#line 269
    tmp___3 = stat((char const   */* __restrict  */)(name), (struct stat */* __restrict  */)(& sbuf));
    }
#line 269
    if (tmp___3 == 0) {
#line 270
      if (sbuf.st_mode & 4U) {
        {
#line 271
        write(1, (void const   *)"Warning: This pseudo-terminal is world-readable.\n",
              (size_t )49);
        }
      }
    }
#line 276
    if (command) {
      {
#line 277
      execl((char const   *)shell, (char const   *)shell, "-c", command, (char *)((void *)0));
      }
    } else {
      {
#line 279
      execl((char const   *)shell, (char const   *)shell, (char *)((void *)0));
      }
    }
    {
#line 280
    perror("execl");
#line 281
    exit(-1);
    }
  }
  {
#line 285
  signal(17, (void (*)(int  ))1);
  }
#line 292
  if (pid < 0) {
    {
#line 293
    show_error("fork() failed");
    }
#line 294
    return;
  }
  {
#line 296
  set_win_region(me, prows, pcols);
#line 297
  sleep(1U);
#line 298
  pfd = fd;
#line 299
  running_process = 1;
#line 300
  lock_flags((ylong )3L);
#line 301
  set_raw_term();
#line 302
  add_fd(fd, & exec_input);
  }
#line 303
  return;
}
}
#line 308 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/exec.c"
void update_exec(void) 
{ 


  {
  {
#line 311
  write(pfd, (void const   *)io_ptr, (size_t )io_len);
#line 312
  io_len = 0;
  }
#line 313
  return;
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/exec.c"
void kill_exec(void) 
{ 


  {
#line 321
  if (! running_process) {
#line 322
    return;
  }
  {
#line 323
  remove_fd(pfd);
#line 324
  close(pfd);
#line 325
  running_process = 0;
#line 326
  unlock_flags();
#line 327
  set_cooked_term();
#line 328
  end_win_region(me);
  }
#line 329
  return;
}
}
#line 334 "/home/june/repo/benchmarks/collector/temp/ytalk-3.3.0/src/exec.c"
void winch_exec(void) 
{ 
  int rows ;
  int cols ;

  {
#line 339
  if (! running_process) {
#line 340
    return;
  }
  {
#line 344
  calculate_size(& rows, & cols);
  }
#line 345
  if (rows == prows) {
#line 345
    if (cols == pcols) {
#line 346
      if (prows != (int )me->rows) {
        {
#line 347
        set_win_region(me, prows, pcols);
        }
      } else
#line 346
      if (pcols != (int )me->cols) {
        {
#line 347
        set_win_region(me, prows, pcols);
        }
      }
#line 348
      return;
    }
  }
  {
#line 352
  prows = rows;
#line 353
  pcols = cols;
#line 354
  set_terminal_size(pfd, prows, pcols);
#line 355
  set_win_region(me, prows, pcols);
#line 357
  kill(pid, 28);
  }
#line 359
  return;
}
}
