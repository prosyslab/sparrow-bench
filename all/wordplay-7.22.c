/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 170
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 127 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 152 "/home/june/repo/benchmarks/collector2/temp/wordplay-7.22/wordplay.c"
char *uppercase(char *s ) ;
#line 153
char *alphabetic(char *s ) ;
#line 154
int numvowels(char *s ) ;
#line 155
void anagramr7(char *s , char **accum , int *minkey , int *level ) ;
#line 156
char *extract(char *s1 , char *s2 ) ;
#line 157
int intmask(char *s ) ;
#line 159 "/home/june/repo/benchmarks/collector2/temp/wordplay-7.22/wordplay.c"
char **words2  ;
#line 160 "/home/june/repo/benchmarks/collector2/temp/wordplay-7.22/wordplay.c"
char *words2mem  ;
#line 161 "/home/june/repo/benchmarks/collector2/temp/wordplay-7.22/wordplay.c"
char **words2ptrs  ;
#line 162 "/home/june/repo/benchmarks/collector2/temp/wordplay-7.22/wordplay.c"
char **wordss  ;
#line 163 "/home/june/repo/benchmarks/collector2/temp/wordplay-7.22/wordplay.c"
char *keymem  ;
#line 164 "/home/june/repo/benchmarks/collector2/temp/wordplay-7.22/wordplay.c"
int *wordsn  ;
#line 165 "/home/june/repo/benchmarks/collector2/temp/wordplay-7.22/wordplay.c"
int *wordmasks  ;
#line 166 "/home/june/repo/benchmarks/collector2/temp/wordplay-7.22/wordplay.c"
int ncount  ;
#line 167 "/home/june/repo/benchmarks/collector2/temp/wordplay-7.22/wordplay.c"
int longestlength  ;
#line 168 "/home/june/repo/benchmarks/collector2/temp/wordplay-7.22/wordplay.c"
char largestlet  ;
#line 169 "/home/june/repo/benchmarks/collector2/temp/wordplay-7.22/wordplay.c"
int rec_anag_count  ;
#line 171 "/home/june/repo/benchmarks/collector2/temp/wordplay-7.22/wordplay.c"
int adjacentdups  ;
#line 172 "/home/june/repo/benchmarks/collector2/temp/wordplay-7.22/wordplay.c"
int specfirstword  ;
#line 173 "/home/june/repo/benchmarks/collector2/temp/wordplay-7.22/wordplay.c"
int maxdepthspec  ;
#line 174 "/home/june/repo/benchmarks/collector2/temp/wordplay-7.22/wordplay.c"
int silent  ;
#line 175 "/home/june/repo/benchmarks/collector2/temp/wordplay-7.22/wordplay.c"
int max_depth  ;
#line 176 "/home/june/repo/benchmarks/collector2/temp/wordplay-7.22/wordplay.c"
int vowelcheck  ;
#line 178 "/home/june/repo/benchmarks/collector2/temp/wordplay-7.22/wordplay.c"
int *lindx1  ;
#line 179 "/home/june/repo/benchmarks/collector2/temp/wordplay-7.22/wordplay.c"
int *lindx2  ;
#line 180 "/home/june/repo/benchmarks/collector2/temp/wordplay-7.22/wordplay.c"
int findx1[26]  ;
#line 181 "/home/june/repo/benchmarks/collector2/temp/wordplay-7.22/wordplay.c"
int findx2[26]  ;
#line 260
extern int ( /* missing proto */  exit)() ;
#line 443
extern int ( /* missing proto */  malloc)() ;
#line 512
extern int ( /* missing proto */  realloc)() ;
#line 183 "/home/june/repo/benchmarks/collector2/temp/wordplay-7.22/wordplay.c"
int main(int argc , char **argv ) 
{ 
  FILE *word_file_ptr ;
  char buffer[128] ;
  char ubuffer[128] ;
  char alphbuffer[128] ;
  char initword[128] ;
  char remaininitword[128] ;
  char word_file_name[256] ;
  char first_word[128] ;
  char u_first_word[128] ;
  char tempword[128] ;
  int ilength ;
  int size ;
  int gap ;
  int switches ;
  int iholdn ;
  char chold ;
  char *wholdptr ;
  int curlen ;
  int curpos ;
  char curlet ;
  int icurlet ;
  int recursiveanag ;
  int listcandwords ;
  int wordfilespec ;
  int firstwordspec ;
  int maxcwordlength ;
  int mincwordlength ;
  int iarg ;
  int keyi ;
  int keyj ;
  char **accum ;
  int level ;
  int minkey ;
  char leftover[128] ;
  int w2size ;
  char *w2memptr ;
  int w2offset ;
  char *keymemptr ;
  int keyoffset ;
  char no[3] ;
  char yes[4] ;
  int fileinput ;
  int hasnumber ;
  int i ;
  int j ;
  int k ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  size_t tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  size_t tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  size_t tmp___25 ;
  size_t tmp___26 ;
  size_t tmp___27 ;
  size_t tmp___28 ;
  int tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  char *tmp___34 ;
  size_t tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  int tmp___41 ;
  size_t tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  char *tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  char *tmp___51 ;
  int tmp___52 ;

  {
#line 224
  no[0] = (char )'n';
#line 224
  no[1] = (char )'o';
#line 224
  no[2] = (char )'\000';
#line 225
  yes[0] = (char )'y';
#line 225
  yes[1] = (char )'e';
#line 225
  yes[2] = (char )'s';
#line 225
  yes[3] = (char )'\000';
#line 238
  if (argc < 2) {
    {
#line 240
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wordplay Version 7.22  03-20-96, 1991   by Evans A Criswell\n");
#line 242
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"University of Alabama in Huntsville     criswell@cs.uah.edu\n\n");
#line 244
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage:  ");
#line 245
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"wordplay string_to_anagram [-slxavnXmXdX] [-w word] [-f word_file]\n\n");
#line 247
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Capital X represents an integer.\n\n");
#line 248
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"s  = silent operation (no header or line numbers)\n");
#line 249
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"l  = print candidate word list\n");
#line 250
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"x  = do not generate anagrams (useful with l option)\n");
#line 251
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"a  = multiple occurrences of a word in an anagram OK\n");
#line 252
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"v  = allow words with no vowels to be considered\n");
#line 253
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"nX = candidate words must have n characters minimum\n");
#line 254
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mX = candidate words must have m characters maximum\n");
#line 255
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dX = limit anagrams to d words\n\n");
#line 256
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"w word = word to start anagrams\n");
#line 257
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"f file = word file to use (\"-f -\" for stdin)\n\n");
#line 258
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Suggestion:  Run \"wordplay trymenow\"  to get started.\n");
#line 260
    exit(-1);
    }
  }
  {
#line 263
  strcpy((char */* __restrict  */)(word_file_name), (char const   */* __restrict  */)"/usr/share/games/wordplay/words721.txt");
#line 265
  recursiveanag = 1;
#line 266
  listcandwords = 0;
#line 267
  wordfilespec = 0;
#line 268
  firstwordspec = 0;
#line 269
  specfirstword = 0;
#line 270
  silent = 0;
#line 271
  vowelcheck = 1;
#line 272
  maxdepthspec = 0;
#line 274
  maxcwordlength = 128;
#line 275
  mincwordlength = 0;
#line 277
  max_depth = 32;
#line 279
  iarg = 1;
  }
  {
#line 280
  while (1) {
    while_continue: /* CIL Label */ ;
#line 280
    if (! (iarg < argc)) {
#line 280
      goto while_break;
    }
#line 282
    if (wordfilespec == 1) {
      {
#line 284
      strcpy((char */* __restrict  */)(word_file_name), (char const   */* __restrict  */)*(argv + iarg));
#line 285
      iarg ++;
#line 286
      wordfilespec = 0;
      }
#line 287
      goto while_continue;
    }
#line 289
    if (firstwordspec == 1) {
      {
#line 291
      strcpy((char */* __restrict  */)(first_word), (char const   */* __restrict  */)*(argv + iarg));
#line 292
      iarg ++;
#line 293
      firstwordspec = 0;
      }
#line 294
      goto while_continue;
    }
#line 296
    if ((int )*(*(argv + iarg) + 0) == 45) {
      {
#line 298
      tmp___3 = strlen((char const   *)*(argv + iarg));
      }
#line 298
      if ((int )tmp___3 > 1) {
#line 300
        i = 1;
        {
#line 301
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 301
          tmp___2 = strlen((char const   *)*(argv + iarg));
          }
#line 301
          if (! (i < (int )tmp___2)) {
#line 301
            goto while_break___0;
          }
          {
#line 305
          if ((int )*(*(argv + iarg) + i) == 97) {
#line 305
            goto case_97;
          }
#line 307
          if ((int )*(*(argv + iarg) + i) == 108) {
#line 307
            goto case_108;
          }
#line 309
          if ((int )*(*(argv + iarg) + i) == 102) {
#line 309
            goto case_102;
          }
#line 311
          if ((int )*(*(argv + iarg) + i) == 120) {
#line 311
            goto case_120;
          }
#line 313
          if ((int )*(*(argv + iarg) + i) == 115) {
#line 313
            goto case_115;
          }
#line 315
          if ((int )*(*(argv + iarg) + i) == 118) {
#line 315
            goto case_118;
          }
#line 317
          if ((int )*(*(argv + iarg) + i) == 119) {
#line 317
            goto case_119;
          }
#line 320
          if ((int )*(*(argv + iarg) + i) == 109) {
#line 320
            goto case_109;
          }
#line 327
          if ((int )*(*(argv + iarg) + i) == 110) {
#line 327
            goto case_110;
          }
#line 333
          if ((int )*(*(argv + iarg) + i) == 100) {
#line 333
            goto case_100;
          }
#line 341
          goto switch_default;
          case_97: /* CIL Label */ 
#line 305
          adjacentdups = 1;
#line 306
          goto switch_break;
          case_108: /* CIL Label */ 
#line 307
          listcandwords = 1;
#line 308
          goto switch_break;
          case_102: /* CIL Label */ 
#line 309
          wordfilespec = 1;
#line 310
          goto switch_break;
          case_120: /* CIL Label */ 
#line 311
          recursiveanag = 0;
#line 312
          goto switch_break;
          case_115: /* CIL Label */ 
#line 313
          silent = 1;
#line 314
          goto switch_break;
          case_118: /* CIL Label */ 
#line 315
          vowelcheck = 0;
#line 316
          goto switch_break;
          case_119: /* CIL Label */ 
#line 317
          firstwordspec = 1;
#line 318
          specfirstword = 1;
#line 319
          goto switch_break;
          case_109: /* CIL Label */ 
#line 320
          maxcwordlength = 0;
#line 321
          i ++;
          {
#line 322
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 322
            if ((int )*(*(argv + iarg) + i) >= 48) {
#line 322
              if (! ((int )*(*(argv + iarg) + i) <= 57)) {
#line 322
                goto while_break___1;
              }
            } else {
#line 322
              goto while_break___1;
            }
#line 323
            tmp = i;
#line 323
            i ++;
#line 323
            maxcwordlength = maxcwordlength * 10 + ((int )*(*(argv + iarg) + tmp) - 48);
          }
          while_break___1: /* CIL Label */ ;
          }
#line 325
          i --;
#line 326
          goto switch_break;
          case_110: /* CIL Label */ 
#line 327
          i ++;
          {
#line 328
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 328
            if ((int )*(*(argv + iarg) + i) >= 48) {
#line 328
              if (! ((int )*(*(argv + iarg) + i) <= 57)) {
#line 328
                goto while_break___2;
              }
            } else {
#line 328
              goto while_break___2;
            }
#line 329
            tmp___0 = i;
#line 329
            i ++;
#line 329
            mincwordlength = mincwordlength * 10 + ((int )*(*(argv + iarg) + tmp___0) - 48);
          }
          while_break___2: /* CIL Label */ ;
          }
#line 331
          i --;
#line 332
          goto switch_break;
          case_100: /* CIL Label */ 
#line 333
          maxdepthspec = 1;
#line 334
          max_depth = 0;
#line 335
          i ++;
          {
#line 336
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 336
            if ((int )*(*(argv + iarg) + i) >= 48) {
#line 336
              if (! ((int )*(*(argv + iarg) + i) <= 57)) {
#line 336
                goto while_break___3;
              }
            } else {
#line 336
              goto while_break___3;
            }
#line 337
            tmp___1 = i;
#line 337
            i ++;
#line 337
            max_depth = max_depth * 10 + ((int )*(*(argv + iarg) + tmp___1) - 48);
          }
          while_break___3: /* CIL Label */ ;
          }
#line 339
          i --;
#line 340
          goto switch_break;
          switch_default: /* CIL Label */ 
          {
#line 341
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid option: \"%c\" - Ignored\n",
                  (int )*(*(argv + iarg) + i));
          }
#line 343
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
#line 345
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 348
      iarg ++;
    } else {
      {
#line 352
      tmp___4 = uppercase(*(argv + iarg));
#line 352
      strcpy((char */* __restrict  */)(initword), (char const   */* __restrict  */)tmp___4);
#line 353
      iarg ++;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 357
  if (silent == 0) {
    {
#line 359
    printf((char const   */* __restrict  */)"Wordplay Version 7.22  03-20-96, 1991   by Evans A Criswell\n");
#line 360
    printf((char const   */* __restrict  */)"University of Alabama in Huntsville     criswell@cs.uah.edu\n\n");
    }
  }
#line 363
  if (silent == 0) {
    {
#line 365
    printf((char const   */* __restrict  */)"\n");
    }
#line 366
    if (listcandwords == 0) {
#line 366
      tmp___5 = no;
    } else {
#line 366
      tmp___5 = yes;
    }
    {
#line 366
    printf((char const   */* __restrict  */)"Candidate word list :  %s\n", tmp___5);
    }
#line 367
    if (recursiveanag == 0) {
#line 367
      tmp___6 = no;
    } else {
#line 367
      tmp___6 = yes;
    }
    {
#line 367
    printf((char const   */* __restrict  */)"Anagram Generation  :  %s\n", tmp___6);
    }
#line 368
    if (adjacentdups == 0) {
#line 368
      tmp___7 = no;
    } else {
#line 368
      tmp___7 = yes;
    }
    {
#line 368
    printf((char const   */* __restrict  */)"Adjacent duplicates :  %s\n", tmp___7);
    }
#line 369
    if (vowelcheck == 0) {
#line 369
      tmp___8 = yes;
    } else {
#line 369
      tmp___8 = no;
    }
    {
#line 369
    printf((char const   */* __restrict  */)"Vowel-free words OK :  %s\n\n", tmp___8);
#line 371
    printf((char const   */* __restrict  */)"Max anagram depth   :  %d\n", max_depth);
#line 372
    printf((char const   */* __restrict  */)"Maximum word length :  %d\n", maxcwordlength);
#line 373
    printf((char const   */* __restrict  */)"Minimum word length :  %d\n\n", mincwordlength);
    }
#line 375
    if (specfirstword) {
      {
#line 376
      printf((char const   */* __restrict  */)"First word          :  \"%s\"\n", first_word);
      }
    }
    {
#line 378
    printf((char const   */* __restrict  */)"Word list file      :  \"%s\"\n", word_file_name);
#line 379
    printf((char const   */* __restrict  */)"String to anagram   :  \"%s\"\n", initword);
#line 380
    printf((char const   */* __restrict  */)"\n");
    }
  }
  {
#line 385
  tmp___9 = alphabetic(initword);
#line 385
  strcpy((char */* __restrict  */)(tempword), (char const   */* __restrict  */)tmp___9);
#line 386
  strcpy((char */* __restrict  */)(initword), (char const   */* __restrict  */)(tempword));
#line 388
  tmp___10 = strlen((char const   *)(initword));
#line 388
  ilength = (int )tmp___10;
#line 392
  size = ilength;
#line 393
  gap = size;
  }
  {
#line 394
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 396
    if ((gap * 10) / 13 > 1) {
#line 396
      gap = (gap * 10) / 13;
    } else {
#line 396
      gap = 1;
    }
#line 397
    switches = 0;
#line 398
    i = 0;
    {
#line 398
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 398
      if (! (i < size - gap)) {
#line 398
        goto while_break___5;
      }
#line 400
      j = i + gap;
#line 401
      if ((int )initword[i] > (int )initword[j]) {
#line 403
        chold = initword[i];
#line 404
        initword[i] = initword[j];
#line 405
        initword[j] = chold;
#line 406
        switches ++;
      }
#line 398
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 394
    if (! ((switches != 0) | (gap != 1))) {
#line 394
      goto while_break___4;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 415
  if (specfirstword) {
    {
#line 417
    tmp___11 = uppercase(first_word);
#line 417
    strcpy((char */* __restrict  */)(u_first_word), (char const   */* __restrict  */)tmp___11);
#line 418
    tmp___12 = extract(initword, u_first_word);
#line 418
    strcpy((char */* __restrict  */)(remaininitword), (char const   */* __restrict  */)tmp___12);
    }
#line 419
    if ((int )remaininitword[0] == 48) {
      {
#line 421
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Specified first word \"%s\" cannot be extracted from initial string \"%s\"\n",
              u_first_word, initword);
#line 423
      exit(1);
      }
    }
    {
#line 425
    tmp___13 = strlen((char const   *)(remaininitword));
    }
#line 425
    if (tmp___13 == 0UL) {
#line 427
      if (silent == 0) {
        {
#line 429
        printf((char const   */* __restrict  */)"Anagrams found:\n");
#line 430
        printf((char const   */* __restrict  */)"     0.  %s\n", u_first_word);
        }
      } else {
        {
#line 433
        printf((char const   */* __restrict  */)"%s\n", u_first_word);
        }
      }
      {
#line 434
      exit(0);
      }
    }
  }
  {
#line 441
  w2size = 4096;
#line 443
  tmp___14 = malloc((unsigned long )w2size * sizeof(char ));
#line 443
  words2mem = (char *)tmp___14;
  }
#line 443
  if ((unsigned long )words2mem == (unsigned long )((char *)((void *)0))) {
    {
#line 445
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory; malloc returned NULL.\n");
#line 446
    exit(-1);
    }
  }
#line 451
  if (silent == 0) {
    {
#line 453
    printf((char const   */* __restrict  */)"\nInitializing.  Please wait while words are being loaded\n");
#line 454
    printf((char const   */* __restrict  */)"and unnecessary words are being filtered out ...\n");
    }
  }
  {
#line 457
  tmp___15 = strcmp((char const   *)(word_file_name), "-");
  }
#line 457
  if (tmp___15 == 0) {
#line 459
    fileinput = 0;
#line 460
    word_file_ptr = stdin;
  } else {
    {
#line 464
    word_file_ptr = fopen((char const   */* __restrict  */)(word_file_name), (char const   */* __restrict  */)"r");
    }
#line 464
    if ((unsigned long )word_file_ptr == (unsigned long )((void *)0)) {
      {
#line 466
      fileinput = 1;
#line 467
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error opening word file.\n");
      }
#line 468
      return (-1);
    }
  }
#line 472
  i = 0;
#line 473
  w2memptr = words2mem;
#line 474
  w2offset = 0;
#line 475
  longestlength = 0;
  {
#line 477
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 477
    tmp___30 = fgets((char */* __restrict  */)(buffer), 128, (FILE */* __restrict  */)word_file_ptr);
    }
#line 477
    if (! ((unsigned long )tmp___30 != (unsigned long )((char *)((void *)0)))) {
#line 477
      goto while_break___6;
    }
    {
#line 480
    tmp___16 = strlen((char const   *)(buffer));
#line 480
    j = (int )tmp___16 - 1;
#line 484
    tmp___17 = j;
#line 484
    j --;
#line 484
    buffer[tmp___17] = (char )'\000';
#line 486
    tmp___18 = alphabetic(buffer);
#line 486
    strcpy((char */* __restrict  */)(alphbuffer), (char const   */* __restrict  */)tmp___18);
#line 488
    tmp___19 = strlen((char const   *)(alphbuffer));
    }
#line 488
    if ((int )tmp___19 < mincwordlength) {
#line 490
      goto while_continue___6;
    } else {
      {
#line 488
      tmp___20 = strlen((char const   *)(alphbuffer));
      }
#line 488
      if ((int )tmp___20 > maxcwordlength) {
#line 490
        goto while_continue___6;
      }
    }
#line 492
    hasnumber = 0;
#line 493
    j = 0;
    {
#line 493
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 493
      tmp___21 = strlen((char const   *)(buffer));
      }
#line 493
      if (! (j < (int )tmp___21)) {
#line 493
        goto while_break___7;
      }
#line 494
      if ((int )buffer[j] >= 48) {
#line 494
        if ((int )buffer[j] <= 57) {
#line 494
          hasnumber = 1;
        }
      }
#line 493
      j ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 496
    if (hasnumber == 1) {
#line 496
      goto while_continue___6;
    }
    {
#line 498
    tmp___22 = uppercase(alphbuffer);
#line 498
    strcpy((char */* __restrict  */)(ubuffer), (char const   */* __restrict  */)tmp___22);
#line 499
    tmp___23 = extract(initword, ubuffer);
#line 499
    strcpy((char */* __restrict  */)(leftover), (char const   */* __restrict  */)tmp___23);
    }
#line 500
    if ((int )leftover[0] == 48) {
#line 500
      goto while_continue___6;
    }
    {
#line 502
    tmp___24 = uppercase(buffer);
#line 502
    strcpy((char */* __restrict  */)w2memptr, (char const   */* __restrict  */)tmp___24);
#line 503
    tmp___25 = strlen((char const   *)(buffer));
#line 503
    w2memptr += tmp___25 + 1UL;
#line 504
    tmp___26 = strlen((char const   *)(buffer));
#line 504
    w2offset = (int )((size_t )w2offset + (tmp___26 + 1UL));
#line 506
    tmp___28 = strlen((char const   *)(alphbuffer));
    }
#line 506
    if ((int )tmp___28 > longestlength) {
      {
#line 507
      tmp___27 = strlen((char const   *)(alphbuffer));
#line 507
      longestlength = (int )tmp___27;
      }
    }
#line 509
    if (w2size - w2offset < 129) {
      {
#line 511
      w2size += 4096;
#line 512
      tmp___29 = realloc(words2mem, w2size);
#line 512
      words2mem = (char *)tmp___29;
      }
#line 512
      if ((unsigned long )words2mem == (unsigned long )((char *)((void *)0))) {
        {
#line 514
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory.  realloc() returned NULL.\n");
#line 515
        exit(-1);
        }
      }
#line 517
      w2memptr = words2mem + w2offset;
    }
#line 520
    i ++;
#line 521
    ncount = i;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 524
  if (fileinput == 1) {
    {
#line 524
    fclose(word_file_ptr);
    }
  }
  {
#line 528
  tmp___31 = malloc((unsigned long )ncount * sizeof(char *));
#line 528
  words2 = (char **)tmp___31;
  }
#line 528
  if ((unsigned long )words2 == (unsigned long )((char **)((void *)0))) {
    {
#line 530
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory.  malloc() returned NULL.\n");
#line 531
    exit(-1);
    }
  }
#line 536
  *(words2 + 0) = words2mem;
#line 537
  j = 1;
#line 538
  i = 0;
  {
#line 538
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 538
    if (! (i < w2size)) {
#line 538
      goto while_break___8;
    }
#line 539
    if (j < ncount) {
#line 540
      if ((int )*(words2mem + i) == 0) {
#line 540
        tmp___32 = j;
#line 540
        j ++;
#line 540
        *(words2 + tmp___32) = (words2mem + i) + 1;
      }
    }
#line 538
    i ++;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 543
  if (silent == 0) {
    {
#line 543
    printf((char const   */* __restrict  */)"\n%d words loaded (%d byte block).  Longest kept:  %d letters.\n",
           ncount, w2size, longestlength);
    }
  }
#line 547
  if (ncount == 0) {
#line 549
    if (silent == 0) {
      {
#line 550
      printf((char const   */* __restrict  */)"\nNo candidate words were found, so there are no anagrams.\n");
      }
    }
    {
#line 551
    exit(0);
    }
  }
  {
#line 556
  tmp___33 = malloc((unsigned long )ncount * sizeof(int ));
#line 556
  wordsn = (int *)tmp___33;
  }
#line 556
  if ((unsigned long )wordsn == (unsigned long )((void *)0)) {
    {
#line 558
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory; malloc returned NULL.\n");
#line 559
    exit(-1);
    }
  }
#line 562
  i = 0;
  {
#line 562
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 562
    if (! (i < ncount)) {
#line 562
      goto while_break___9;
    }
    {
#line 564
    tmp___34 = alphabetic(*(words2 + i));
#line 564
    strcpy((char */* __restrict  */)(alphbuffer), (char const   */* __restrict  */)tmp___34);
#line 565
    tmp___35 = strlen((char const   *)(alphbuffer));
#line 565
    *(wordsn + i) = (int )tmp___35;
#line 562
    i ++;
    }
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 570
  tmp___36 = malloc((unsigned long )ncount * sizeof(char *));
#line 570
  words2ptrs = (char **)tmp___36;
  }
#line 570
  if ((unsigned long )words2ptrs == (unsigned long )((char **)((void *)0))) {
    {
#line 573
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory; malloc returned NULL.\n");
#line 574
    exit(-1);
    }
  }
#line 577
  i = 0;
  {
#line 577
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 577
    if (! (i < ncount)) {
#line 577
      goto while_break___10;
    }
#line 577
    *(words2ptrs + i) = *(words2 + i);
#line 577
    i ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 584
  tmp___37 = malloc((unsigned long )ncount * sizeof(char *));
#line 584
  wordss = (char **)tmp___37;
  }
#line 584
  if ((unsigned long )wordss == (unsigned long )((char **)((void *)0))) {
    {
#line 586
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory; malloc returned NULL.\n");
#line 587
    exit(-1);
    }
  }
  {
#line 592
  tmp___38 = malloc((unsigned long )w2size * sizeof(char ));
#line 592
  keymem = (char *)tmp___38;
  }
#line 592
  if ((unsigned long )keymem == (unsigned long )((char *)((void *)0))) {
    {
#line 594
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory; malloc() returned NULL.\n");
#line 595
    exit(-1);
    }
  }
#line 601
  keymemptr = keymem;
#line 602
  keyoffset = 0;
#line 604
  i = 0;
  {
#line 604
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 604
    if (! (i < ncount)) {
#line 604
      goto while_break___11;
    }
    {
#line 606
    tmp___39 = alphabetic(*(words2 + i));
#line 606
    strcpy((char */* __restrict  */)(alphbuffer), (char const   */* __restrict  */)tmp___39);
#line 607
    tmp___40 = uppercase(alphbuffer);
#line 607
    strcpy((char */* __restrict  */)(ubuffer), (char const   */* __restrict  */)tmp___40);
#line 608
    strcpy((char */* __restrict  */)keymemptr, (char const   */* __restrict  */)(ubuffer));
#line 609
    keymemptr += *(wordsn + i) + 1;
#line 610
    keyoffset += *(wordsn + i) + 1;
#line 604
    i ++;
    }
  }
  while_break___11: /* CIL Label */ ;
  }
#line 617
  *(wordss + 0) = keymem;
#line 618
  j = 1;
#line 619
  i = 0;
  {
#line 619
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 619
    if (! (i < w2size)) {
#line 619
      goto while_break___12;
    }
#line 620
    if (j < ncount) {
#line 621
      if ((int )*(keymem + i) == 0) {
#line 621
        tmp___41 = j;
#line 621
        j ++;
#line 621
        *(wordss + tmp___41) = (keymem + i) + 1;
      }
    }
#line 619
    i ++;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 626
  k = 0;
  {
#line 626
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 626
    if (! (k < ncount)) {
#line 626
      goto while_break___13;
    }
    {
#line 628
    tmp___42 = strlen((char const   *)*(wordss + k));
#line 628
    size = (int )tmp___42;
#line 629
    gap = size;
    }
    {
#line 630
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 632
      if ((gap * 10) / 13 > 1) {
#line 632
        gap = (gap * 10) / 13;
      } else {
#line 632
        gap = 1;
      }
#line 633
      switches = 0;
#line 634
      i = 0;
      {
#line 634
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 634
        if (! (i < size - gap)) {
#line 634
          goto while_break___15;
        }
#line 636
        j = i + gap;
#line 637
        if ((int )*(*(wordss + k) + i) > (int )*(*(wordss + k) + j)) {
#line 639
          chold = *(*(wordss + k) + i);
#line 640
          *(*(wordss + k) + i) = *(*(wordss + k) + j);
#line 641
          *(*(wordss + k) + j) = chold;
#line 642
          switches ++;
        }
#line 634
        i ++;
      }
      while_break___15: /* CIL Label */ ;
      }
#line 630
      if (! ((switches != 0) | (gap != 1))) {
#line 630
        goto while_break___14;
      }
    }
    while_break___14: /* CIL Label */ ;
    }
#line 626
    k ++;
  }
  while_break___13: /* CIL Label */ ;
  }
#line 653
  size = ncount;
#line 654
  gap = size;
  {
#line 655
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 657
    if ((gap * 10) / 13 > 1) {
#line 657
      gap = (gap * 10) / 13;
    } else {
#line 657
      gap = 1;
    }
#line 658
    switches = 0;
#line 659
    i = 0;
    {
#line 659
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 659
      if (! (i < size - gap)) {
#line 659
        goto while_break___17;
      }
      {
#line 661
      j = i + gap;
#line 662
      tmp___43 = strcmp((char const   *)*(wordss + i), (char const   *)*(wordss + j));
      }
#line 662
      if (tmp___43 > 0) {
#line 664
        wholdptr = *(wordss + i);
#line 665
        *(wordss + i) = *(wordss + j);
#line 666
        *(wordss + j) = wholdptr;
#line 667
        wholdptr = *(words2ptrs + i);
#line 668
        *(words2ptrs + i) = *(words2ptrs + j);
#line 669
        *(words2ptrs + j) = wholdptr;
#line 670
        switches ++;
      }
#line 659
      i ++;
    }
    while_break___17: /* CIL Label */ ;
    }
#line 655
    if (! ((switches != 0) | (gap != 1))) {
#line 655
      goto while_break___16;
    }
  }
  while_break___16: /* CIL Label */ ;
  }
#line 675
  largestlet = *(*(wordss + (ncount - 1)) + 0);
#line 679
  size = ncount;
#line 680
  gap = size;
  {
#line 681
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 683
    if ((gap * 10) / 13 > 1) {
#line 683
      gap = (gap * 10) / 13;
    } else {
#line 683
      gap = 1;
    }
#line 684
    switches = 0;
#line 685
    i = 0;
    {
#line 685
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 685
      if (! (i < size - gap)) {
#line 685
        goto while_break___19;
      }
#line 687
      j = i + gap;
#line 688
      keyi = *(wordsn + i);
#line 689
      keyj = *(wordsn + j);
#line 690
      if (keyi > keyj) {
#line 692
        iholdn = *(wordsn + i);
#line 693
        *(wordsn + i) = *(wordsn + j);
#line 694
        *(wordsn + j) = iholdn;
#line 695
        wholdptr = *(words2 + i);
#line 696
        *(words2 + i) = *(words2 + j);
#line 697
        *(words2 + j) = wholdptr;
#line 698
        switches ++;
      }
#line 685
      i ++;
    }
    while_break___19: /* CIL Label */ ;
    }
#line 681
    if (! ((switches != 0) | (gap != 1))) {
#line 681
      goto while_break___18;
    }
  }
  while_break___18: /* CIL Label */ ;
  }
#line 706
  if (listcandwords) {
#line 708
    if (silent == 0) {
      {
#line 708
      printf((char const   */* __restrict  */)"\nList of candidate words:\n");
      }
    }
#line 709
    i = 0;
    {
#line 709
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 709
      if (! (i < ncount)) {
#line 709
        goto while_break___20;
      }
#line 711
      if (silent == 0) {
        {
#line 712
        printf((char const   */* __restrict  */)"%6d.  %s\n", i, *(words2 + i));
        }
      } else {
        {
#line 714
        printf((char const   */* __restrict  */)"%s\n", *(words2 + i));
        }
      }
#line 709
      i ++;
    }
    while_break___20: /* CIL Label */ ;
    }
  }
  {
#line 724
  tmp___44 = malloc((unsigned long )(longestlength + 1) * sizeof(int ));
#line 724
  lindx1 = (int *)tmp___44;
  }
#line 724
  if ((unsigned long )lindx1 == (unsigned long )((int *)((void *)0))) {
    {
#line 727
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory.  malloc() returned NULL.\n");
#line 728
    exit(-1);
    }
  }
  {
#line 731
  tmp___45 = malloc((unsigned long )(longestlength + 1) * sizeof(int ));
#line 731
  lindx2 = (int *)tmp___45;
  }
#line 731
  if ((unsigned long )lindx2 == (unsigned long )((int *)((void *)0))) {
    {
#line 734
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory.  malloc() returned NULL.\n");
#line 735
    exit(-1);
    }
  }
#line 738
  i = 0;
  {
#line 738
  while (1) {
    while_continue___21: /* CIL Label */ ;
#line 738
    if (! (i <= longestlength)) {
#line 738
      goto while_break___21;
    }
#line 740
    *(lindx1 + i) = -1;
#line 741
    *(lindx2 + i) = -2;
#line 738
    i ++;
  }
  while_break___21: /* CIL Label */ ;
  }
#line 744
  if (ncount > 0) {
#line 746
    curpos = 0;
#line 747
    curlen = *(wordsn + curpos);
#line 748
    *(lindx1 + curlen) = curpos;
    {
#line 749
    while (1) {
      while_continue___22: /* CIL Label */ ;
      {
#line 751
      while (1) {
        while_continue___23: /* CIL Label */ ;
#line 751
        if (! (curpos < ncount)) {
#line 751
          goto while_break___23;
        }
#line 753
        if (*(wordsn + curpos) == curlen) {
#line 754
          curpos ++;
        } else {
#line 756
          goto while_break___23;
        }
      }
      while_break___23: /* CIL Label */ ;
      }
#line 759
      if (curpos >= ncount) {
#line 761
        *(lindx2 + curlen) = ncount - 1;
#line 762
        goto while_break___22;
      }
#line 764
      *(lindx2 + curlen) = curpos - 1;
#line 765
      curlen = *(wordsn + curpos);
#line 766
      *(lindx1 + curlen) = curpos;
#line 749
      if (! (curpos < ncount)) {
#line 749
        goto while_break___22;
      }
    }
    while_break___22: /* CIL Label */ ;
    }
  }
#line 780
  i = 0;
  {
#line 780
  while (1) {
    while_continue___24: /* CIL Label */ ;
#line 780
    if (! (i < 26)) {
#line 780
      goto while_break___24;
    }
#line 782
    findx1[i] = -1;
#line 783
    findx2[i] = -2;
#line 780
    i ++;
  }
  while_break___24: /* CIL Label */ ;
  }
#line 786
  if (ncount > 0) {
#line 788
    curpos = 0;
#line 789
    curlet = *(*(wordss + curpos) + 0);
#line 790
    icurlet = (int )curlet - 65;
#line 791
    findx1[icurlet] = curpos;
    {
#line 792
    while (1) {
      while_continue___25: /* CIL Label */ ;
      {
#line 794
      while (1) {
        while_continue___26: /* CIL Label */ ;
#line 794
        if (! (curpos < ncount)) {
#line 794
          goto while_break___26;
        }
#line 796
        if ((int )*(*(wordss + curpos) + 0) == (int )curlet) {
#line 797
          curpos ++;
        } else {
#line 799
          goto while_break___26;
        }
      }
      while_break___26: /* CIL Label */ ;
      }
#line 801
      if (curpos >= ncount) {
#line 803
        findx2[icurlet] = ncount - 1;
#line 804
        goto while_break___25;
      }
#line 806
      findx2[icurlet] = curpos - 1;
#line 807
      curlet = *(*(wordss + curpos) + 0);
#line 808
      icurlet = (int )curlet - 65;
#line 809
      findx1[icurlet] = curpos;
#line 792
      if (! (curpos < ncount)) {
#line 792
        goto while_break___25;
      }
    }
    while_break___25: /* CIL Label */ ;
    }
  }
  {
#line 816
  tmp___46 = malloc((unsigned long )ncount * sizeof(int ));
#line 816
  wordmasks = (int *)tmp___46;
  }
#line 816
  if ((unsigned long )wordmasks == (unsigned long )((void *)0)) {
    {
#line 818
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory; malloc returned NULL.\n");
#line 819
    exit(-1);
    }
  }
#line 822
  i = 0;
  {
#line 822
  while (1) {
    while_continue___27: /* CIL Label */ ;
#line 822
    if (! (i < ncount)) {
#line 822
      goto while_break___27;
    }
    {
#line 822
    *(wordmasks + i) = intmask(*(wordss + i));
#line 822
    i ++;
    }
  }
  while_break___27: /* CIL Label */ ;
  }
#line 826
  if (specfirstword == 0) {
#line 826
    if (recursiveanag) {
#line 828
      if (silent == 0) {
        {
#line 828
        printf((char const   */* __restrict  */)"\nAnagrams found:\n");
        }
      }
      {
#line 830
      tmp___47 = malloc(32UL * sizeof(char *));
#line 830
      accum = (char **)tmp___47;
      }
#line 830
      if ((unsigned long )accum == (unsigned long )((char **)((void *)0))) {
        {
#line 833
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory; malloc returned NULL.\n");
#line 834
        exit(-1);
        }
      }
#line 837
      i = 0;
      {
#line 837
      while (1) {
        while_continue___28: /* CIL Label */ ;
#line 837
        if (! (i < 32)) {
#line 837
          goto while_break___28;
        }
        {
#line 838
        tmp___49 = malloc((unsigned long )(longestlength + 1) * sizeof(char ));
#line 838
        tmp___48 = (char *)tmp___49;
#line 838
        *(accum + i) = tmp___48;
        }
#line 838
        if ((unsigned long )tmp___48 == (unsigned long )((char *)((void *)0))) {
          {
#line 841
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory; malloc returned NULL.\n");
#line 842
          exit(-1);
          }
        }
#line 837
        i ++;
      }
      while_break___28: /* CIL Label */ ;
      }
      {
#line 845
      *(*(accum + 0) + 0) = (char )'\000';
#line 846
      level = 0;
#line 847
      rec_anag_count = 0;
#line 849
      minkey = findx1[(int )initword[0] - 65];
#line 851
      anagramr7(initword, accum, & minkey, & level);
      }
#line 852
      if (rec_anag_count == 0) {
#line 853
        if (silent == 0) {
          {
#line 854
          printf((char const   */* __restrict  */)"\nNo anagrams found by recursive algorithm.\n");
          }
        }
      }
    }
  }
#line 857
  if (specfirstword == 1) {
#line 857
    if (recursiveanag) {
#line 859
      if (silent == 0) {
        {
#line 859
        printf((char const   */* __restrict  */)"\nRecursive anagrams found:\n");
        }
      }
      {
#line 861
      tmp___50 = malloc(32UL * sizeof(char *));
#line 861
      accum = (char **)tmp___50;
      }
#line 861
      if ((unsigned long )accum == (unsigned long )((char **)((void *)0))) {
        {
#line 864
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory; malloc returned NULL.\n");
#line 865
        exit(-1);
        }
      }
#line 868
      i = 0;
      {
#line 868
      while (1) {
        while_continue___29: /* CIL Label */ ;
#line 868
        if (! (i < 32)) {
#line 868
          goto while_break___29;
        }
        {
#line 869
        tmp___52 = malloc(129UL * sizeof(char ));
#line 869
        tmp___51 = (char *)tmp___52;
#line 869
        *(accum + i) = tmp___51;
        }
#line 869
        if ((unsigned long )tmp___51 == (unsigned long )((char *)((void *)0))) {
          {
#line 872
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory; malloc returned NULL.\n");
#line 873
          exit(-1);
          }
        }
#line 868
        i ++;
      }
      while_break___29: /* CIL Label */ ;
      }
      {
#line 876
      strcpy((char */* __restrict  */)*(accum + 0), (char const   */* __restrict  */)(u_first_word));
#line 877
      level = 1;
#line 878
      rec_anag_count = 0;
#line 880
      minkey = findx1[(int )remaininitword[0] - 65];
#line 882
      anagramr7(remaininitword, accum, & minkey, & level);
      }
#line 883
      if (rec_anag_count == 0) {
        {
#line 884
        printf((char const   */* __restrict  */)"\nNo anagrams found by recursive algorithm.\n");
        }
      }
    }
  }
#line 887
  return (0);
}
}
#line 892 "/home/june/repo/benchmarks/collector2/temp/wordplay-7.22/wordplay.c"
static char upcasestr[129]  ;
#line 890 "/home/june/repo/benchmarks/collector2/temp/wordplay-7.22/wordplay.c"
char *uppercase(char *s ) 
{ 
  int i ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 895
  i = 0;
  {
#line 895
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 895
    tmp___0 = strlen((char const   *)s);
    }
#line 895
    if (! (i < (int )tmp___0)) {
#line 895
      goto while_break;
    }
    {
#line 895
    tmp = toupper((int )*(s + i));
#line 895
    upcasestr[i] = (char )tmp;
#line 895
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 896
  upcasestr[i] = (char )'\000';
#line 898
  return (upcasestr);
}
}
#line 903 "/home/june/repo/benchmarks/collector2/temp/wordplay-7.22/wordplay.c"
static char alphstr[129]  ;
#line 901 "/home/june/repo/benchmarks/collector2/temp/wordplay-7.22/wordplay.c"
char *alphabetic(char *s ) 
{ 
  int i ;
  int pos ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 906
  pos = 0;
#line 907
  i = 0;
  {
#line 907
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 907
    tmp___0 = strlen((char const   *)s);
    }
#line 907
    if (! (i < (int )tmp___0)) {
#line 907
      goto while_break;
    }
#line 908
    if ((int )*(s + i) >= 65) {
#line 908
      if ((int )*(s + i) <= 90) {
#line 909
        tmp = pos;
#line 909
        pos ++;
#line 909
        alphstr[tmp] = *(s + i);
      } else {
#line 908
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 908
    if ((int )*(s + i) >= 97) {
#line 908
      if ((int )*(s + i) <= 122) {
#line 909
        tmp = pos;
#line 909
        pos ++;
#line 909
        alphstr[tmp] = *(s + i);
      }
    }
#line 907
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 910
  alphstr[pos] = (char )'\000';
#line 912
  return (alphstr);
}
}
#line 915 "/home/june/repo/benchmarks/collector2/temp/wordplay-7.22/wordplay.c"
int numvowels(char *s ) 
{ 
  int vcount ;
  char *cptr ;

  {
#line 920
  vcount = 0;
#line 922
  cptr = s;
  {
#line 922
  while (1) {
    while_continue: /* CIL Label */ ;
#line 922
    if (! ((int )*cptr != 0)) {
#line 922
      goto while_break;
    }
    {
#line 925
    if ((int )*cptr == 89) {
#line 925
      goto case_89;
    }
#line 925
    if ((int )*cptr == 85) {
#line 925
      goto case_89;
    }
#line 925
    if ((int )*cptr == 79) {
#line 925
      goto case_89;
    }
#line 925
    if ((int )*cptr == 73) {
#line 925
      goto case_89;
    }
#line 925
    if ((int )*cptr == 69) {
#line 925
      goto case_89;
    }
#line 925
    if ((int )*cptr == 65) {
#line 925
      goto case_89;
    }
#line 923
    goto switch_break;
    case_89: /* CIL Label */ 
    case_85: /* CIL Label */ 
    case_79: /* CIL Label */ 
    case_73: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_65: /* CIL Label */ 
#line 926
    vcount ++;
#line 926
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 922
    cptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 928
  return (vcount);
}
}
#line 931 "/home/june/repo/benchmarks/collector2/temp/wordplay-7.22/wordplay.c"
void anagramr7(char *s , char **accum , int *minkey , int *level ) 
{ 
  int i ;
  int j ;
  int extsuccess ;
  int icurlet ;
  int newminkey ;
  int s_mask ;
  char exts[128] ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 948
  if (*level >= max_depth) {
#line 950
    (*level) --;
#line 951
    return;
  }
#line 958
  if (maxdepthspec == 1) {
    {
#line 959
    tmp = strlen((char const   *)s);
    }
#line 959
    if ((size_t )((max_depth - *level) * longestlength) < tmp) {
#line 961
      (*level) --;
#line 962
      return;
    }
  }
#line 967
  if (vowelcheck == 1) {
    {
#line 968
    tmp___0 = numvowels(s);
    }
#line 968
    if (tmp___0 == 0) {
#line 970
      (*level) --;
#line 971
      return;
    }
  }
  {
#line 974
  s_mask = intmask(s);
#line 978
  extsuccess = 0;
#line 980
  icurlet = (int )*(s + 0) - 65;
  }
#line 981
  if (*minkey > findx1[icurlet]) {
#line 981
    i = *minkey;
  } else {
#line 981
    i = findx1[icurlet];
  }
  {
#line 981
  while (1) {
    while_continue: /* CIL Label */ ;
#line 981
    if (! (i <= findx2[icurlet])) {
#line 981
      goto while_break;
    }
#line 992
    if ((s_mask | *(wordmasks + i)) != s_mask) {
#line 992
      goto __Cont;
    }
#line 997
    if (adjacentdups == 0) {
#line 998
      if (*level > 0) {
        {
#line 998
        tmp___1 = strcmp((char const   *)*(words2ptrs + i), (char const   *)*(accum + (*level - 1)));
        }
#line 998
        if (tmp___1 == 0) {
#line 999
          goto __Cont;
        }
      }
    }
    {
#line 1003
    tmp___2 = extract(s, *(wordss + i));
#line 1003
    strcpy((char */* __restrict  */)(exts), (char const   */* __restrict  */)tmp___2);
    }
#line 1007
    if ((int )exts[0] == 48) {
#line 1007
      goto __Cont;
    }
#line 1012
    if ((int )exts[0] == 0) {
      {
#line 1014
      rec_anag_count ++;
#line 1015
      strcpy((char */* __restrict  */)*(accum + *level), (char const   */* __restrict  */)*(words2ptrs + i));
      }
#line 1016
      if (silent == 0) {
        {
#line 1016
        printf((char const   */* __restrict  */)"%6d.  ", rec_anag_count);
        }
      }
#line 1017
      j = 0;
      {
#line 1017
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1017
        if (! (j < *level)) {
#line 1017
          goto while_break___0;
        }
        {
#line 1017
        printf((char const   */* __restrict  */)"%s ", *(accum + j));
#line 1017
        j ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1018
      printf((char const   */* __restrict  */)"%s\n", *(words2ptrs + i));
#line 1019
      extsuccess = 1;
      }
#line 1020
      goto __Cont;
    }
    {
#line 1026
    extsuccess = 1;
#line 1028
    strcpy((char */* __restrict  */)*(accum + *level), (char const   */* __restrict  */)*(words2ptrs + i));
#line 1029
    (*level) ++;
    }
#line 1031
    if (adjacentdups == 0) {
#line 1032
      newminkey = i + 1;
    } else {
#line 1034
      newminkey = i;
    }
    {
#line 1036
    anagramr7(exts, accum, & newminkey, level);
    }
    __Cont: /* CIL Label */ 
#line 981
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1041
  if (extsuccess == 0) {
#line 1043
    (*level) --;
#line 1044
    return;
  }
#line 1046
  (*level) --;
#line 1048
  return;
}
}
#line 1066 "/home/june/repo/benchmarks/collector2/temp/wordplay-7.22/wordplay.c"
static char r1[128]  ;
#line 1051 "/home/june/repo/benchmarks/collector2/temp/wordplay-7.22/wordplay.c"
char *extract(char *s1 , char *s2 ) 
{ 
  char t1[128] ;
  char *s1p ;
  char *s2p ;
  char *r1p ;
  char *s1end ;
  char *s2end ;
  int found ;
  int s1len ;
  int s2len ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 1071
  r1p = r1;
#line 1073
  strcpy((char */* __restrict  */)(t1), (char const   */* __restrict  */)s1);
#line 1074
  s1p = t1;
#line 1075
  tmp = strlen((char const   *)s1p);
#line 1075
  s1len = (int )tmp;
#line 1076
  s1end = s1p + s1len;
#line 1078
  s2p = s2;
#line 1079
  tmp___0 = strlen((char const   *)s2);
#line 1079
  s2len = (int )tmp___0;
#line 1080
  s2end = s2p + s2len;
#line 1082
  s2p = s2;
  }
  {
#line 1082
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1082
    if (! ((unsigned long )s2p < (unsigned long )s2end)) {
#line 1082
      goto while_break;
    }
#line 1084
    found = 0;
#line 1085
    s1p = t1;
    {
#line 1085
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1085
      if (! ((unsigned long )s1p < (unsigned long )s1end)) {
#line 1085
        goto while_break___0;
      }
#line 1087
      if ((int )*s2p == (int )*s1p) {
#line 1089
        *s1p = (char )'0';
#line 1090
        found = 1;
#line 1091
        goto while_break___0;
      }
#line 1085
      s1p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1094
    if (found == 0) {
#line 1096
      r1[0] = (char )'0';
#line 1097
      *(r1 + 1) = (char )'\000';
#line 1098
      return (r1);
    }
#line 1082
    s2p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1102
  r1p = r1;
#line 1103
  s1p = t1;
  {
#line 1103
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1103
    if (! ((unsigned long )s1p < (unsigned long )s1end)) {
#line 1103
      goto while_break___1;
    }
#line 1104
    if ((int )*s1p != 48) {
#line 1104
      tmp___1 = r1p;
#line 1104
      r1p ++;
#line 1104
      *tmp___1 = *s1p;
    }
#line 1103
    s1p ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1105
  *r1p = (char )'\000';
#line 1107
  return (r1);
}
}
#line 1110 "/home/june/repo/benchmarks/collector2/temp/wordplay-7.22/wordplay.c"
int intmask(char *s ) 
{ 
  char *sptr ;
  int mask ;

  {
#line 1118
  mask = 0;
#line 1119
  sptr = s;
  {
#line 1119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1119
    if (! ((int )*sptr != 0)) {
#line 1119
      goto while_break;
    }
#line 1120
    if ((int )*sptr >= 65) {
#line 1120
      if ((int )*sptr <= 90) {
#line 1120
        mask |= 1 << ((int )*sptr - 65);
      }
    }
#line 1119
    sptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1122
  return (mask);
}
}
